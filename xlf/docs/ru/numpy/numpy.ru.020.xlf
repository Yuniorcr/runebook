<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="numpy">
    <body>
      <group id="numpy">
        <trans-unit id="0716cf4800278ada150f876e9ddcae3c99250b13" translate="yes" xml:space="preserve">
          <source>Their are two basic approaches to calling compiled code: writing an extension module that is then imported to Python using the import command, or calling a shared-library subroutine directly from Python using the &lt;a href=&quot;https://docs.python.org/3/library/ctypes.html&quot;&gt;ctypes&lt;/a&gt; module. Writing an extension module is the most common method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="13617ef6d1ed670620e3eee1fe6521faed558f33" translate="yes" xml:space="preserve">
          <source>Their contents are described below.</source>
          <target state="translated">Их содержание описано ниже.</target>
        </trans-unit>
        <trans-unit id="d67a14bba38674d133aa6326e1d56a5430227ffd" translate="yes" xml:space="preserve">
          <source>Then modify it as follows</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="18de376fec5af9b24c105e03578c15d330983aed" translate="yes" xml:space="preserve">
          <source>Then you can obtain a lot of useful information (first details about &lt;code&gt;a&lt;/code&gt; itself, followed by the docstring of &lt;code&gt;ndarray&lt;/code&gt; of which &lt;code&gt;a&lt;/code&gt; is an instance):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="beca14a81e09ec62e1fbfc41746f56a23c04a2b2" translate="yes" xml:space="preserve">
          <source>Then, I can compile the extension module using:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="daa5af99f0618068c146112b2487469ac95f27c4" translate="yes" xml:space="preserve">
          <source>Then, all the HTML files will be generated in &lt;code&gt;doc/build/html/&lt;/code&gt;. Since the documentation is based on docstrings, the appropriate version of numpy must be installed in the host python used to run sphinx.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7bbaffa25ddeac5ba58545ce47397f8a88d6c19f" translate="yes" xml:space="preserve">
          <source>Then, create a new branch based on the master branch of the upstream repository:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a64f3ff6d48531fcbe93b1b844e9cc7950b3eeb4" translate="yes" xml:space="preserve">
          <source>Then, go to your forked repository github page, say &lt;code&gt;https://github.com/your-user-name/numpy&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2304d640a16ae9bfebc931161006126d186e787e" translate="yes" xml:space="preserve">
          <source>Then:</source>
          <target state="translated">Then:</target>
        </trans-unit>
        <trans-unit id="2a2d6eb0d79238cba7c8636b58f3ce6ad4b5b344" translate="yes" xml:space="preserve">
          <source>There are 4 relevant uses of the word &lt;code&gt;align&lt;/code&gt; used in numpy:</source>
          <target state="translated">Есть 4 важных &lt;code&gt;align&lt;/code&gt; использования слова align, используемого в numpy:</target>
        </trans-unit>
        <trans-unit id="d627a19c8c5bea4de4ec9dd15face492281b6f90" translate="yes" xml:space="preserve">
          <source>There are 5 basic numerical types representing booleans (bool), integers (int), unsigned integers (uint) floating point (float) and complex. Those with numbers in their name indicate the bitsize of the type (i.e. how many bits are needed to represent a single value in memory). Some types, such as &lt;code&gt;int&lt;/code&gt; and &lt;code&gt;intp&lt;/code&gt;, have differing bitsizes, dependent on the platforms (e.g. 32-bit vs. 64-bit machines). This should be taken into account when interfacing with low-level code (such as C or Fortran) where the raw memory is addressed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="17bb2653ac2aa7153e927fc1353ff32c9d0fadd9" translate="yes" xml:space="preserve">
          <source>There are 5 general mechanisms for creating arrays:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a7e737fa7ec2df18d82d046fe4547a421ecb3b7" translate="yes" xml:space="preserve">
          <source>There are 6 (binary) flags that describe the memory area used by the data buffer. These constants are defined in &lt;code&gt;arrayobject.h&lt;/code&gt; and determine the bit-position of the flag. Python exposes a nice attribute- based interface as well as a dictionary-like interface for getting (and, if appropriate, setting) these flags.</source>
          <target state="translated">Есть 6 (двоичных) флагов, которые описывают область памяти, используемую буфером данных. Эти константы определены в &lt;code&gt;arrayobject.h&lt;/code&gt; и определяют битовую позицию флага. Python предоставляет удобный интерфейс на основе атрибутов, а также интерфейс, подобный словарю, для получения (и, при необходимости, установки) этих флагов.</target>
        </trans-unit>
        <trans-unit id="92880b58f6bd9442d0573770c5bcc16b810e1cdc" translate="yes" xml:space="preserve">
          <source>There are &lt;code&gt;num&lt;/code&gt; equally spaced samples in the closed interval &lt;code&gt;[start, stop]&lt;/code&gt; or the half-open interval &lt;code&gt;[start, stop)&lt;/code&gt; (depending on whether &lt;code&gt;endpoint&lt;/code&gt; is True or False).</source>
          <target state="translated">Есть &lt;code&gt;num&lt;/code&gt; равноотстоящих образцов в замкнутом интервале &lt;code&gt;[start, stop]&lt;/code&gt; или полуинтервал &lt;code&gt;[start, stop)&lt;/code&gt; ( в зависимости от того , &lt;code&gt;endpoint&lt;/code&gt; является истинной или ложной).</target>
        </trans-unit>
        <trans-unit id="8269e59da4433043c91490542198a44ae2a7bd22" translate="yes" xml:space="preserve">
          <source>There are a few commonly reported issues depending on your system/setup. If none of the following tips help you, please be sure to note the following:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f20349ffc92d6259aa973ed6765d972938b14bd" translate="yes" xml:space="preserve">
          <source>There are a number of ways to assign values to a structured array: Using python tuples, using scalar values, or using other structured arrays.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aabadb6a5aa99979671de060b5cf5eb2bfdc73b8" translate="yes" xml:space="preserve">
          <source>There are a variety of approaches one can use. If the file has a relatively simple format then one can write a simple I/O library and use the numpy fromfile() function and .tofile() method to read and write numpy arrays directly (mind your byteorder though!) If a good C or C++ library exists that read the data, one can wrap that library with a variety of techniques though that certainly is much more work and requires significantly more advanced knowledge to interface with C or C++.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6009b813cfbdbc400ba73901cd26bc8dc165215e" translate="yes" xml:space="preserve">
          <source>There are also typedefs for signed integers, unsigned integers, floating point, and complex floating point types of specific bit- widths. The available type names are</source>
          <target state="translated">Существуют также typedefs для знаковых целых чисел,беззнаковых целых чисел,типов с плавающей точкой и сложных типов с плавающей точкой определенной битовой ширины.Доступные имена типов</target>
        </trans-unit>
        <trans-unit id="2cd3e7355c4c3985bff39b5837a16202e8c1540c" translate="yes" xml:space="preserve">
          <source>There are currently more than 60 universal functions defined in &lt;a href=&quot;index#module-numpy&quot;&gt;&lt;code&gt;numpy&lt;/code&gt;&lt;/a&gt; on one or more types, covering a wide variety of operations. Some of these ufuncs are called automatically on arrays when the relevant infix notation is used (&lt;em&gt;e.g.&lt;/em&gt;, &lt;a href=&quot;generated/numpy.add#numpy.add&quot;&gt;&lt;code&gt;add(a, b)&lt;/code&gt;&lt;/a&gt; is called internally when &lt;code&gt;a + b&lt;/code&gt; is written and &lt;em&gt;a&lt;/em&gt; or &lt;em&gt;b&lt;/em&gt; is an &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt;). Nevertheless, you may still want to use the ufunc call in order to use the optional output argument(s) to place the output(s) in an object (or objects) of your choice.</source>
          <target state="translated">В настоящее время существует более 60 универсальных функций, определенных в &lt;a href=&quot;index#module-numpy&quot;&gt; &lt;code&gt;numpy&lt;/code&gt; &lt;/a&gt; для одного или нескольких типов, охватывающих широкий спектр операций. Некоторые из этих функций вызываются автоматически для массивов, когда используется соответствующая инфиксная нотация ( &lt;em&gt;например&lt;/em&gt; , &lt;a href=&quot;generated/numpy.add#numpy.add&quot;&gt; &lt;code&gt;add(a, b)&lt;/code&gt; &lt;/a&gt; вызывается внутри, когда записывается &lt;code&gt;a + b&lt;/code&gt; а &lt;em&gt;a&lt;/em&gt; или &lt;em&gt;b&lt;/em&gt; является &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt; ). Тем не менее, вы все равно можете использовать вызов ufunc, чтобы использовать необязательный выходной аргумент (ы) для размещения вывода (ов) в объекте (или объектах) по вашему выбору.</target>
        </trans-unit>
        <trans-unit id="775b5ff21441ff77356a90016945326f51981b32" translate="yes" xml:space="preserve">
          <source>There are fairly common issues when using PyCharm together with Anaconda, please see the &lt;a href=&quot;https://www.jetbrains.com/help/pycharm/conda-support-creating-conda-virtual-environment.html&quot;&gt;PyCharm support&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3438358c09e82d3e17ac10e9485821f710c7159e" translate="yes" xml:space="preserve">
          <source>There are libraries that can be used to generate arrays for special purposes and it isn&amp;rsquo;t possible to enumerate all of them. The most common uses are use of the many array generation functions in random that can generate arrays of random values, and some utility functions to generate special matrices (e.g. diagonal).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c69a32040141b3969da2a2cbb310c56f38084713" translate="yes" xml:space="preserve">
          <source>There are lots of examples of how to use &lt;a href=&quot;https://docs.python.org/dev/c-api/arg.html#c.PyArg_ParseTuple&quot;&gt;&lt;code&gt;PyArg_ParseTuple&lt;/code&gt;&lt;/a&gt; throughout the NumPy source code. The standard usage is like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="68b9dbbab83df5d12e3f17adf9850959d4114286" translate="yes" xml:space="preserve">
          <source>There are many C or C++ array/NumPy array situations not covered by a simple &lt;code&gt;%include &quot;numpy.i&quot;&lt;/code&gt; and subsequent &lt;code&gt;%apply&lt;/code&gt; directives.</source>
          <target state="translated">Есть много ситуаций с массивами C или C ++ / NumPy, которые не охватываются простым &lt;code&gt;%include &quot;numpy.i&quot;&lt;/code&gt; и последующими директивами &lt;code&gt;%apply&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a3c7bbd8e8aff936bd091f138c70193c9efdefe3" translate="yes" xml:space="preserve">
          <source>There are many online tutorials to help you &lt;a href=&quot;https://www.atlassian.com/git/tutorials/&quot;&gt;learn git&lt;/a&gt;. For discussions of specific git workflows, see these discussions on &lt;a href=&quot;https://www.mail-archive.com/dri-devel@lists.sourceforge.net/msg39091.html&quot;&gt;linux git workflow&lt;/a&gt;, and &lt;a href=&quot;http://mail.python.org/pipermail/ipython-dev/2010-October/006746.html&quot;&gt;ipython git workflow&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e7a362f552d6539941413dc2279097986613078" translate="yes" xml:space="preserve">
          <source>There are many ways of working with &lt;a href=&quot;https://git-scm.com/&quot;&gt;git&lt;/a&gt;; here are some posts on the rules of thumb that other projects have come up with:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="850bf20dccfb45fbea5bb3bf4cc123a24de9ce74" translate="yes" xml:space="preserve">
          <source>There are many ways to define the DFT, varying in the sign of the exponent, normalization, etc. In this implementation, the DFT is defined as</source>
          <target state="translated">Существует множество способов определения DFT,различающихся по знаку экспоненты,нормализации и т.д.В этой реализации DFT определяется как</target>
        </trans-unit>
        <trans-unit id="76da8844fec054fd5276e6ad85d740b68fcb82e8" translate="yes" xml:space="preserve">
          <source>There are no general requirements on the return value from &lt;code&gt;__array_function__&lt;/code&gt;, although most sensible implementations should probably return array(s) with the same type as one of the function&amp;rsquo;s arguments.</source>
          <target state="translated">Нет общих требований к возвращаемому значению из &lt;code&gt;__array_function__&lt;/code&gt; , хотя наиболее разумные реализации, вероятно, должны возвращать массив (ы) с тем же типом, что и один из аргументов функции.</target>
        </trans-unit>
        <trans-unit id="06faa5c6fcba06f9dd8ca92063029df6a41e4c58" translate="yes" xml:space="preserve">
          <source>There are often instances where we want NumPy to initialize the values of an array. NumPy offers functions like &lt;code&gt;ones()&lt;/code&gt; and &lt;code&gt;zeros()&lt;/code&gt;, and the &lt;code&gt;random.Generator&lt;/code&gt; class for random number generation for that. All you need to do is pass in the number of elements you want it to generate:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="95381d820ed4d179172c69e3a1efc8e39007df94" translate="yes" xml:space="preserve">
          <source>There are only integer array indices so that no subarray exists.</source>
          <target state="translated">Существуют только индексы целочисленных массивов,так что подмассивов не существует.</target>
        </trans-unit>
        <trans-unit id="115526010a225042aa40f787fc2f47f797982daf" translate="yes" xml:space="preserve">
          <source>There are other points in the use of ndarrays where we need such views, such as copying arrays (&lt;code&gt;c_arr.copy()&lt;/code&gt;), creating ufunc output arrays (see also &lt;a href=&quot;#array-wrap&quot;&gt;__array_wrap__ for ufuncs and other functions&lt;/a&gt;), and reducing methods (like &lt;code&gt;c_arr.mean()&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="72e1214b4766467e55cb3f8f030a4456afbf45a2" translate="yes" xml:space="preserve">
          <source>There are other wrapping situations in which &lt;code&gt;numpy.i&lt;/code&gt; may be helpful when you encounter them.</source>
          <target state="translated">Существуют и другие ситуации обертывания, в которых &lt;code&gt;numpy.i&lt;/code&gt; может быть полезен, когда вы с ними сталкиваетесь.</target>
        </trans-unit>
        <trans-unit id="318856ec210de70f7b88df3c75c2a12aaa8c93b2" translate="yes" xml:space="preserve">
          <source>There are pros and cons to using both:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f83bfa0078610ce5c1a2e851fa86300b3de47263" translate="yes" xml:space="preserve">
          <source>There are several disadvantages of using Cython:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c928426bd7e5582ef0057cd443cd0554ec0f93c" translate="yes" xml:space="preserve">
          <source>There are several examples of using the multi-iterator in the NumPy source code as it makes N-dimensional broadcasting-code very simple to write. Browse the source for more examples.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="27bf18c3e68f395d5dcf853e32e810c666f7a43d" translate="yes" xml:space="preserve">
          <source>There are several requirements for a shared library that can be used with ctypes that are platform specific. This guide assumes you have some familiarity with making a shared library on your system (or simply have a shared library available to you). Items to remember are:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b82ec3b39568bfec9a11840bdb7b6ec4c84323cc" translate="yes" xml:space="preserve">
          <source>There are several ways to construct a masked array.</source>
          <target state="translated">Существует несколько способов построения маскированного массива.</target>
        </trans-unit>
        <trans-unit id="c4a7e4b025b48bc40d3703a29b57ae48e3043f29" translate="yes" xml:space="preserve">
          <source>There are several ways to create arrays.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ffbc541dfd45825fd321c5ec3bdf633ecc4c702b" translate="yes" xml:space="preserve">
          <source>There are some informational attributes that universal functions possess. None of the attributes can be set.</source>
          <target state="translated">Существуют некоторые информационные атрибуты,которыми обладают универсальные функции.Ни один из атрибутов не может быть установлен.</target>
        </trans-unit>
        <trans-unit id="25b081aeb44044a8abafdf90f986afb1775ac9ea" translate="yes" xml:space="preserve">
          <source>There are sometimes issues reported on Raspberry Pi setups when installing using &lt;code&gt;pip3 install&lt;/code&gt; (or &lt;code&gt;pip&lt;/code&gt; install). These will typically mention:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="014e04d63bbb11cf7242b7931500c73711d0520d" translate="yes" xml:space="preserve">
          <source>There are standard variable types for each of the numeric data types and the bool data type. Some of these are already available in the C-specification. You can create variables in extension code with these types.</source>
          <target state="translated">Для каждого из числовых типов данных и типа данных bool существуют стандартные типы переменных.Некоторые из них уже доступны в C-спецификации.С помощью этих типов можно создавать переменные в коде расширений.</target>
        </trans-unit>
        <trans-unit id="d266f8d3fc00db82d70a1cf8a8ecaaaa80431033" translate="yes" xml:space="preserve">
          <source>There are three independent testing frameworks supported, for one-, two-, and three-dimensional arrays respectively. For one-dimensional arrays, there are two C++ files, a header and a source, named:</source>
          <target state="translated">Поддерживаются три независимые тестовые фреймворки для одно-,двух-и трехмерных массивов соответственно.Для одномерных массивов существует два С++файла,заголовок и источник с именем:</target>
        </trans-unit>
        <trans-unit id="a98d06ff6365cb9b94028f7c87529f8503c9281a" translate="yes" xml:space="preserve">
          <source>There are three methods of ufuncs that require calculation similar to the general-purpose ufuncs. These are reduce, accumulate, and reduceat. Each of these methods requires a setup command followed by a loop. There are four loop styles possible for the methods corresponding to no-elements, one-element, strided-loop, and buffered- loop. These are the same basic loop styles as implemented for the general purpose function call except for the no-element and one- element cases which are special-cases occurring when the input array objects have 0 and 1 elements respectively.</source>
          <target state="translated">Существуют три метода использования уфунков,которые требуют расчетов,аналогичных уфунксам общего назначения.Это уменьшение,накопление и уменьшение.Каждый из этих методов требует команды установки с последующим циклом.Для методов,соответствующих no-elements,одноэлементному,strided-loop и буферному циклу,возможны четыре стиля цикла.Это те же основные стили цикла,что и при вызове функции общего назначения,за исключением случаев с нулевым элементом и одним элементом,которые являются специальными случаями,когда объекты входного массива имеют 0 и 1 элемент соответственно.</target>
        </trans-unit>
        <trans-unit id="79149af5bd80302b7d9a0d00bba8113083202d98" translate="yes" xml:space="preserve">
          <source>There are three steps to the process.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="30d692f23dd01af5033268a8ed1b02fd45c32c1c" translate="yes" xml:space="preserve">
          <source>There are three strategies implemented that can be used to produce repeatable pseudo-random numbers across multiple processes (local or distributed).</source>
          <target state="translated">Существует три стратегии,которые могут быть использованы для получения повторяющихся псевдослучайных чисел для нескольких процессов (локальных или распределенных).</target>
        </trans-unit>
        <trans-unit id="9dfb3a62923157363de4f21bfcb4cc89da91a3e2" translate="yes" xml:space="preserve">
          <source>There are three use-cases related to memory alignment in numpy (as of 1.14):</source>
          <target state="translated">Существует три варианта использования,связанных с выравниванием памяти цифрами (по состоянию на 1.14):</target>
        </trans-unit>
        <trans-unit id="1878e6ac9e299677e2b59b09c76f88c728c9412d" translate="yes" xml:space="preserve">
          <source>There are times when it is important to visit the elements of an array in a specific order, irrespective of the layout of the elements in memory. The &lt;a href=&quot;generated/numpy.nditer#numpy.nditer&quot;&gt;&lt;code&gt;nditer&lt;/code&gt;&lt;/a&gt; object provides an &lt;code&gt;order&lt;/code&gt; parameter to control this aspect of iteration. The default, having the behavior described above, is order=&amp;rsquo;K&amp;rsquo; to keep the existing order. This can be overridden with order=&amp;rsquo;C&amp;rsquo; for C order and order=&amp;rsquo;F&amp;rsquo; for Fortran order.</source>
          <target state="translated">Бывают случаи, когда важно посетить элементы массива в определенном порядке, независимо от расположения элементов в памяти. Объект &lt;a href=&quot;generated/numpy.nditer#numpy.nditer&quot;&gt; &lt;code&gt;nditer&lt;/code&gt; &lt;/a&gt; предоставляет параметр &lt;code&gt;order&lt;/code&gt; для управления этим аспектом итерации. По умолчанию, при описанном выше поведении, порядок = 'K', чтобы сохранить существующий порядок. Это можно изменить, указав order = 'C' для порядка C и order = 'F' для порядка Fortran.</target>
        </trans-unit>
        <trans-unit id="8bcb408782f4cab8808f9329f353388438a050d8" translate="yes" xml:space="preserve">
          <source>There are times when it is necessary to treat an array as a different data type than it is stored as. For instance, one may want to do all computations on 64-bit floats, even if the arrays being manipulated are 32-bit floats. Except when writing low-level C code, it&amp;rsquo;s generally better to let the iterator handle the copying or buffering instead of casting the data type yourself in the inner loop.</source>
          <target state="translated">Бывают случаи, когда необходимо рассматривать массив как другой тип данных, чем он хранится как. Например, может потребоваться выполнить все вычисления на 64-битных числах с плавающей запятой, даже если обрабатываемые массивы являются 32-битными числами с плавающей запятой. За исключением случаев написания низкоуровневого кода C, обычно лучше позволить итератору обрабатывать копирование или буферизацию вместо того, чтобы приводить тип данных самостоятельно во внутреннем цикле.</target>
        </trans-unit>
        <trans-unit id="49296589bf54025f71f98956452ad22438eb00b7" translate="yes" xml:space="preserve">
          <source>There are times when you might want to carry out an operation between an array and a single number (also called &lt;em&gt;an operation between a vector and a scalar&lt;/em&gt;) or between arrays of two different sizes. For example, your array (we&amp;rsquo;ll call it &amp;ldquo;data&amp;rdquo;) might contain information about distance in miles but you want to convert the information to kilometers. You can perform this operation with:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="52cac18f5846d7a58eabeae3e5d687453dc981d9" translate="yes" xml:space="preserve">
          <source>There are two Timedelta units (&amp;lsquo;Y&amp;rsquo;, years and &amp;lsquo;M&amp;rsquo;, months) which are treated specially, because how much time they represent changes depending on when they are used. While a timedelta day unit is equivalent to 24 hours, there is no way to convert a month unit into days, because different months have different numbers of days.</source>
          <target state="translated">Есть две единицы Timedelta (&amp;laquo;Y&amp;raquo;, годы и &amp;laquo;M&amp;raquo;, месяцы), которые обрабатываются особым образом, потому что время, в течение которого они представляют, изменяется в зависимости от того, когда они используются. Хотя единица дня timedelta эквивалентна 24 часам, невозможно преобразовать единицу месяца в дни, поскольку в разных месяцах разное количество дней.</target>
        </trans-unit>
        <trans-unit id="47ec50226de8d5ba6a84cfb19309924a297ce7ae" translate="yes" xml:space="preserve">
          <source>There are two aspects to the machinery that ndarray uses to support views and new-from-template in subclasses.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ced97d88ae2c849acfa28a2cee713cefa36672d2" translate="yes" xml:space="preserve">
          <source>There are two major new types: the ndarray ( &lt;a href=&quot;#c.PyArray_Type&quot;&gt;&lt;code&gt;PyArray_Type&lt;/code&gt;&lt;/a&gt; ) and the ufunc ( &lt;a href=&quot;#c.PyUFunc_Type&quot;&gt;&lt;code&gt;PyUFunc_Type&lt;/code&gt;&lt;/a&gt; ). Additional types play a supportive role: the &lt;a href=&quot;#c.PyArrayIter_Type&quot;&gt;&lt;code&gt;PyArrayIter_Type&lt;/code&gt;&lt;/a&gt;, the &lt;a href=&quot;#c.PyArrayMultiIter_Type&quot;&gt;&lt;code&gt;PyArrayMultiIter_Type&lt;/code&gt;&lt;/a&gt;, and the &lt;a href=&quot;#c.PyArrayDescr_Type&quot;&gt;&lt;code&gt;PyArrayDescr_Type&lt;/code&gt;&lt;/a&gt; . The &lt;a href=&quot;#c.PyArrayIter_Type&quot;&gt;&lt;code&gt;PyArrayIter_Type&lt;/code&gt;&lt;/a&gt; is the type for a flat iterator for an ndarray (the object that is returned when getting the flat attribute). The &lt;a href=&quot;#c.PyArrayMultiIter_Type&quot;&gt;&lt;code&gt;PyArrayMultiIter_Type&lt;/code&gt;&lt;/a&gt; is the type of the object returned when calling &lt;code&gt;broadcast&lt;/code&gt; (). It handles iteration and broadcasting over a collection of nested sequences. Also, the &lt;a href=&quot;#c.PyArrayDescr_Type&quot;&gt;&lt;code&gt;PyArrayDescr_Type&lt;/code&gt;&lt;/a&gt; is the data-type-descriptor type whose instances describe the data. Finally, there are 21 new scalar-array types which are new Python scalars corresponding to each of the fundamental data types available for arrays. An additional 10 other types are place holders that allow the array scalars to fit into a hierarchy of actual Python types.</source>
          <target state="translated">Есть два основных новых типа: ndarray ( &lt;a href=&quot;#c.PyArray_Type&quot;&gt; &lt;code&gt;PyArray_Type&lt;/code&gt; &lt;/a&gt; ) и ufunc ( &lt;a href=&quot;#c.PyUFunc_Type&quot;&gt; &lt;code&gt;PyUFunc_Type&lt;/code&gt; &lt;/a&gt; ). Дополнительные типы играют вспомогательную роль: &lt;a href=&quot;#c.PyArrayIter_Type&quot;&gt; &lt;code&gt;PyArrayIter_Type&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#c.PyArrayMultiIter_Type&quot;&gt; &lt;code&gt;PyArrayMultiIter_Type&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;#c.PyArrayDescr_Type&quot;&gt; &lt;code&gt;PyArrayDescr_Type&lt;/code&gt; &lt;/a&gt; . &lt;a href=&quot;#c.PyArrayIter_Type&quot;&gt; &lt;code&gt;PyArrayIter_Type&lt;/code&gt; &lt;/a&gt; является типом для плоского итератора для ndarray (объекта , который возвращается при получении плоского атрибута). &lt;a href=&quot;#c.PyArrayMultiIter_Type&quot;&gt; &lt;code&gt;PyArrayMultiIter_Type&lt;/code&gt; &lt;/a&gt; тип объекта возвращается при вызове &lt;code&gt;broadcast&lt;/code&gt; (). Он обрабатывает итерацию и рассылку по набору вложенных последовательностей. Кроме того, &lt;a href=&quot;#c.PyArrayDescr_Type&quot;&gt; &lt;code&gt;PyArrayDescr_Type&lt;/code&gt; &lt;/a&gt;- это тип дескриптора типа данных, экземпляры которого описывают данные. Наконец, существует 21 новый тип скалярных массивов, которые представляют собой новые скаляры Python, соответствующие каждому из основных типов данных, доступных для массивов. Еще 10 других типов являются заполнителями, которые позволяют скалярам массива вписаться в иерархию реальных типов Python.</target>
        </trans-unit>
        <trans-unit id="c37fba99ab33d4532607fe9319066dc8a4405878" translate="yes" xml:space="preserve">
          <source>There are two mechanisms which allow this to be done, temporary copies and buffering mode. With temporary copies, a copy of the entire array is made with the new data type, then iteration is done in the copy. Write access is permitted through a mode which updates the original array after all the iteration is complete. The major drawback of temporary copies is that the temporary copy may consume a large amount of memory, particularly if the iteration data type has a larger itemsize than the original one.</source>
          <target state="translated">Существуют два механизма,которые позволяют это делать:временное копирование и режим буферизации.При использовании временных копий создается копия всего массива с новым типом данных,затем выполняется итерация в копии.Доступ на запись разрешен через режим,который обновляет исходный массив после завершения всей итерации.Основным недостатком временных копий является то,что временная копия может потреблять большой объем памяти,особенно если итерационный тип данных имеет больший размер элемента,чем исходная копия.</target>
        </trans-unit>
        <trans-unit id="bbd0e93d84494368770e6b417effb4b358f4babd" translate="yes" xml:space="preserve">
          <source>There are two modes of creating an array using &lt;code&gt;__new__&lt;/code&gt;:</source>
          <target state="translated">Есть два режима создания массива с использованием &lt;code&gt;__new__&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="e95a2d13ee09be4667ba99a7e23d783a62c61eb8" translate="yes" xml:space="preserve">
          <source>There are two popular ways to flatten an array: &lt;code&gt;.flatten()&lt;/code&gt; and &lt;code&gt;.ravel()&lt;/code&gt;. The primary difference between the two is that the new array created using &lt;code&gt;ravel()&lt;/code&gt; is actually a reference to the parent array (i.e., a &amp;ldquo;view&amp;rdquo;). This means that any changes to the new array will affect the parent array as well. Since &lt;code&gt;ravel&lt;/code&gt; does not create a copy, it&amp;rsquo;s memory efficient.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="97769fec67515ece6f805db56bd64883845242d0" translate="yes" xml:space="preserve">
          <source>There are two types of proper-contiguous NumPy arrays:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0373fb682b5018f30be6571b2e08840bdbbdebff" translate="yes" xml:space="preserve">
          <source>There are two ways to capture floating-point error messages. The first is to set the error-handler to &amp;lsquo;call&amp;rsquo;, using &lt;a href=&quot;numpy.seterr#numpy.seterr&quot;&gt;&lt;code&gt;seterr&lt;/code&gt;&lt;/a&gt;. Then, set the function to call using this function.</source>
          <target state="translated">Есть два способа записывать сообщения об ошибках с плавающей запятой. Первый - настроить обработчик ошибок на &amp;laquo;вызов&amp;raquo; с помощью &lt;a href=&quot;numpy.seterr#numpy.seterr&quot;&gt; &lt;code&gt;seterr&lt;/code&gt; &lt;/a&gt; . Затем установите функцию для вызова с использованием этой функции.</target>
        </trans-unit>
        <trans-unit id="7822fba8682a2c5b4fec5101c082332701ec52bb" translate="yes" xml:space="preserve">
          <source>There are two ways to effectively define a new array scalar type (apart from composing structured types &lt;a href=&quot;arrays.dtypes#arrays-dtypes&quot;&gt;dtypes&lt;/a&gt; from the built-in scalar types): One way is to simply subclass the &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt; and overwrite the methods of interest. This will work to a degree, but internally certain behaviors are fixed by the data type of the array. To fully customize the data type of an array you need to define a new data-type, and register it with NumPy. Such new types can only be defined in C, using the &lt;a href=&quot;c-api#c-api&quot;&gt;NumPy C-API&lt;/a&gt;.</source>
          <target state="translated">Есть два способа эффективно определить новый скалярный тип массива (помимо составления &lt;a href=&quot;arrays.dtypes#arrays-dtypes&quot;&gt;dtypes&lt;/a&gt; структурированных типов из встроенных скалярных типов): Один из способов - просто &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt; подкласс ndarray и перезаписать интересующие методы. В определенной степени это будет работать, но внутренне определенное поведение фиксируется типом данных массива. Чтобы полностью настроить тип данных массива, вам необходимо определить новый тип данных и зарегистрировать его с помощью NumPy. Такие новые типы могут быть определены только на C, используя &lt;a href=&quot;c-api#c-api&quot;&gt;NumPy C-API&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5c78474a57486cf4a85d9232cd27ee1937bd696d" translate="yes" xml:space="preserve">
          <source>There are two ways to effectively define a new array scalar type (apart from composing structured types &lt;a href=&quot;arrays.dtypes#arrays-dtypes&quot;&gt;dtypes&lt;/a&gt; from the built-in scalar types): One way is to simply subclass the &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt; and overwrite the methods of interest. This will work to a degree, but internally certain behaviors are fixed by the data type of the array. To fully customize the data type of an array you need to define a new data-type, and register it with NumPy. Such new types can only be defined in C, using the &lt;a href=&quot;c-api/index#c-api&quot;&gt;NumPy C-API&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cedb91ab21e9adb6003c75e29f535939f4382660" translate="yes" xml:space="preserve">
          <source>There are two ways to update the source release on PyPI, the first one is:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="07256ff1dd075c50fc2daea66eb388157aacb269" translate="yes" xml:space="preserve">
          <source>There are two ways to use the interface: A Python side and a C-side. Both are separate attributes.</source>
          <target state="translated">Есть два способа использования интерфейса:со стороны питона и со стороны С.Оба являются отдельными атрибутами.</target>
        </trans-unit>
        <trans-unit id="b03a9c50082003b4ef01f90e63c960011178dda8" translate="yes" xml:space="preserve">
          <source>There has been no consistent prefix for NumPy public functions, but they all begin with a prefix of some sort, followed by an underscore, and are in camel case: &lt;code&gt;PyArray_DescrAlignConverter&lt;/code&gt;, &lt;code&gt;NpyIter_GetIterNext&lt;/code&gt;. In the future the names should be of the form &lt;code&gt;Npy*_PublicFunction&lt;/code&gt;, where the star is something appropriate.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dde43af7d13c44f94f0d79c46e9390e7c8216335" translate="yes" xml:space="preserve">
          <source>There is a Python type for each of the different built-in data types that can be present in the array Most of these are simple wrappers around the corresponding data type in C. The C-names for these types are &lt;code&gt;Py{TYPE}ArrType_Type&lt;/code&gt; where &lt;code&gt;{TYPE}&lt;/code&gt; can be</source>
          <target state="translated">Существует тип Python для каждого из различных встроенных типов данных, которые могут присутствовать в массиве. Большинство из них являются простыми оболочками вокруг соответствующего типа данных в C. Имена C для этих типов: &lt;code&gt;Py{TYPE}ArrType_Type&lt;/code&gt; где &lt;code&gt;{TYPE}&lt;/code&gt; может быть</target>
        </trans-unit>
        <trans-unit id="07c5411b83a37216eb927b90741cd5630b9b2108" translate="yes" xml:space="preserve">
          <source>There is a clear distinction between element-wise operations and linear algebra operations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c0d05d2bbb1d4347eb1dace6314a1a3b989e2daa" translate="yes" xml:space="preserve">
          <source>There is a fragment for converting a Python integer to a C &lt;code&gt;long&lt;/code&gt;. There is a different fragment that converts a Python integer to a C &lt;code&gt;int&lt;/code&gt;, that calls the routine defined in the &lt;code&gt;long&lt;/code&gt; fragment. We can make the changes we want here by changing the definition for the &lt;code&gt;long&lt;/code&gt; fragment. &lt;a href=&quot;http://www.swig.org&quot;&gt;SWIG&lt;/a&gt; determines the active definition for a fragment using a &amp;ldquo;first come, first served&amp;rdquo; system. That is, we need to define the fragment for &lt;code&gt;long&lt;/code&gt; conversions prior to &lt;a href=&quot;http://www.swig.org&quot;&gt;SWIG&lt;/a&gt; doing it internally. &lt;a href=&quot;http://www.swig.org&quot;&gt;SWIG&lt;/a&gt; allows us to do this by putting our fragment definitions in the file &lt;code&gt;pyfragments.swg&lt;/code&gt;. If we were to put the new fragment definitions in &lt;code&gt;numpy.i&lt;/code&gt;, they would be ignored.</source>
          <target state="translated">Существует фрагмент для преобразования целого числа в Python C &lt;code&gt;long&lt;/code&gt; . Существует другой фрагмент, который преобразует целое число Python в C &lt;code&gt;int&lt;/code&gt; , вызывая процедуру, определенную в &lt;code&gt;long&lt;/code&gt; фрагменте. Мы можем внести здесь нужные изменения, изменив определение &lt;code&gt;long&lt;/code&gt; фрагмента. &lt;a href=&quot;http://www.swig.org&quot;&gt;SWIG&lt;/a&gt; определяет активное определение для фрагмента, используя систему &amp;laquo;первым пришел - первым обслужен&amp;raquo;. То есть нам нужно определить фрагмент для &lt;code&gt;long&lt;/code&gt; преобразований до того, как &lt;a href=&quot;http://www.swig.org&quot;&gt;SWIG&lt;/a&gt; выполнит это внутренне. &lt;a href=&quot;http://www.swig.org&quot;&gt;SWIG&lt;/a&gt; позволяет нам делать это, помещая определения наших фрагментов в файл &lt;code&gt;pyfragments.swg&lt;/code&gt; . Если бы мы поместили новые определения фрагментов в &lt;code&gt;numpy.i&lt;/code&gt; , они будут проигнорированы.</target>
        </trans-unit>
        <trans-unit id="d31593a379a881f2302877c7bf40c8ae65305ffb" translate="yes" xml:space="preserve">
          <source>There is a general need for looping over not only functions on scalars but also over functions on vectors (or arrays). This concept is realized in NumPy by generalizing the universal functions (ufuncs). In regular ufuncs, the elementary function is limited to element-by-element operations, whereas the generalized version (gufuncs) supports &amp;ldquo;sub-array&amp;rdquo; by &amp;ldquo;sub-array&amp;rdquo; operations. The Perl vector library PDL provides a similar functionality and its terms are re-used in the following.</source>
          <target state="translated">Существует общая потребность в цикле не только по функциям на скалярах, но и по функциям с векторами (или массивами). Эта концепция реализована в NumPy путем обобщения универсальных функций (ufuncs). В обычных ufuncs элементарная функция ограничена поэлементными операциями, тогда как обобщенная версия (gufuncs) поддерживает операции &amp;laquo;подмассив&amp;raquo; за &amp;laquo;подмассивом&amp;raquo;. Векторная библиотека Perl PDL обеспечивает аналогичную функциональность, и ее термины используются в дальнейшем.</target>
        </trans-unit>
        <trans-unit id="16ce9fcfde9d0ef11eba9dffd6932b4fb7fe6e10" translate="yes" xml:space="preserve">
          <source>There is a list of enumerated types defined providing the basic 24 data types plus some useful generic names. Whenever the code requires a type number, one of these enumerated types is requested. The types are all called &lt;code&gt;NPY_{NAME}&lt;/code&gt;:</source>
          <target state="translated">Существует список определенных перечислимых типов, содержащий 24 основных типа данных плюс некоторые полезные общие имена. Когда код требует номер типа, запрашивается один из этих перечислимых типов. Все типы называются &lt;code&gt;NPY_{NAME}&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="fd095b1a939a3168566a681ecc0b30a59e81e682" translate="yes" xml:space="preserve">
          <source>There is a small difference between &lt;a href=&quot;#numpy.ma.masked_array.mini&quot;&gt;&lt;code&gt;mini&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;numpy.ma.min#numpy.ma.min&quot;&gt;&lt;code&gt;min&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="426d6a71d6ada6c4fe36711b0bf2acc4eb8a1d92" translate="yes" xml:space="preserve">
          <source>There is a subarray but it has exactly one element. This case can be handled as if there is no subarray, but needs some care during setup.</source>
          <target state="translated">Есть подмассив,но в нем есть ровно один элемент.Этот случай может быть обработан так,как будто подмассива нет,но требует некоторого ухода во время установки.</target>
        </trans-unit>
        <trans-unit id="a1e2cb9284c447866f4fcfbd5e36a19034ca7940" translate="yes" xml:space="preserve">
          <source>There is also a &amp;ldquo;flat&amp;rdquo; in-place array for situations in which you would like to modify or process each element, regardless of the number of dimensions. One example is a &amp;ldquo;quantization&amp;rdquo; function that quantizes each element of an array in-place, be it 1D, 2D or whatever. This form checks for continuity but allows either C or Fortran ordering.</source>
          <target state="translated">Существует также &amp;laquo;плоский&amp;raquo; массив на месте для ситуаций, в которых вы хотите изменить или обработать каждый элемент, независимо от количества измерений. Одним из примеров является функция &amp;laquo;квантования&amp;raquo;, которая квантует каждый элемент массива на месте, будь то 1D, 2D или что-то еще. Эта форма проверяет непрерывность, но допускает упорядочивание на языке C или Fortran.</target>
        </trans-unit>
        <trans-unit id="42d7ce17e767848814f251a3d945724bdcad4394" translate="yes" xml:space="preserve">
          <source>There is an &lt;a href=&quot;../arrays.nditer#arrays-nditer&quot;&gt;introductory guide to array iteration&lt;/a&gt; which may be of interest for those using this C API. In many instances, testing out ideas by creating the iterator in Python is a good idea before writing the C iteration code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="89b73fe8185f285d3a10cd617f08eb8cadb40473" translate="yes" xml:space="preserve">
          <source>There is an &lt;a href=&quot;arrays.nditer#arrays-nditer&quot;&gt;introductory guide to array iteration&lt;/a&gt; which may be of interest for those using this C API. In many instances, testing out ideas by creating the iterator in Python is a good idea before writing the C iteration code.</source>
          <target state="translated">Существует &lt;a href=&quot;arrays.nditer#arrays-nditer&quot;&gt;вводное руководство по итерации массива,&lt;/a&gt; которое может быть интересно тем, кто использует этот C API. Во многих случаях рекомендуется проверить идеи путем создания итератора в Python перед написанием итерационного кода C.</target>
        </trans-unit>
        <trans-unit id="606a479ef2292dc711e91c789c67dff3002d3e8e" translate="yes" xml:space="preserve">
          <source>There is an ongoing effort to improve the API. It is important in this effort to ensure that code that compiles for NumPy 1.X continues to compile for NumPy 1.X. At the same time, certain API&amp;rsquo;s will be marked as deprecated so that future-looking code can avoid these API&amp;rsquo;s and follow better practices.</source>
          <target state="translated">Мы постоянно работаем над улучшением API. В этих усилиях важно убедиться, что код, который компилируется для NumPy 1.X, продолжает компилироваться для NumPy 1.X. В то же время некоторые API-интерфейсы будут помечены как устаревшие, чтобы ориентированный на будущее код мог избегать этих API и следовать передовым методам.</target>
        </trans-unit>
        <trans-unit id="2d9dbfa834497f6482a194ae6bc42d9b31e1c027" translate="yes" xml:space="preserve">
          <source>There is exactly one function that must be defined in your C-code in order for Python to use it as an extension module. The function must be called init{name} where {name} is the name of the module from Python. This function must be declared so that it is visible to code outside of the routine. Besides adding the methods and constants you desire, this subroutine must also contain calls like &lt;code&gt;import_array()&lt;/code&gt; and/or &lt;code&gt;import_ufunc()&lt;/code&gt; depending on which C-API is needed. Forgetting to place these commands will show itself as an ugly segmentation fault (crash) as soon as any C-API subroutine is actually called. It is actually possible to have multiple init{name} functions in a single file in which case multiple modules will be defined by that file. However, there are some tricks to get that to work correctly and it is not covered here.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c951415e0655e2f1d542beb400e29df172840589" translate="yes" xml:space="preserve">
          <source>There is more than one definition of sign in common use for complex numbers. The definition used here is equivalent to</source>
          <target state="translated">Существует более одного определения знака,обычно используемого для комплексных чисел.Используемое здесь определение эквивалентно</target>
        </trans-unit>
        <trans-unit id="81f07ae1e9b8a43b5991326dbec6dd373febf78b" translate="yes" xml:space="preserve">
          <source>There is no need to use &lt;code&gt;intent(c)&lt;/code&gt; for one-dimensional arrays, no matter if the wrapped function is either a Fortran or a C function. This is because the concepts of Fortran- and C contiguity overlap in one-dimensional cases.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b1c5400df70c93e783da6a5dac7fee87f2f1e727" translate="yes" xml:space="preserve">
          <source>There is no standard way in Python distutils to create a standard shared library (an extension module is a &amp;ldquo;special&amp;rdquo; shared library Python understands) in a cross-platform manner. Thus, a big disadvantage of ctypes at the time of writing this book is that it is difficult to distribute in a cross-platform manner a Python extension that uses ctypes and includes your own code which should be compiled as a shared library on the users system.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="23297908101e96f4ab7052c44ca172ce18526477" translate="yes" xml:space="preserve">
          <source>There is one indexing array and it, as well as the assignment array, can be iterated trivially. For example they may be contiguous. Also the indexing array must be of &lt;code&gt;intp&lt;/code&gt; type and the value array in assignments should be of the correct type. This is purely a fast path.</source>
          <target state="translated">Есть один индексирующий массив, и его, как и массив присваивания, можно тривиально повторять. Например, они могут быть смежными. Кроме того, индексирующий массив должен иметь тип &lt;code&gt;intp&lt;/code&gt; , а массив значений в присвоениях должен быть правильного типа. Это чисто быстрый путь.</target>
        </trans-unit>
        <trans-unit id="d8fac7ab155f3d88da854276783ffad458c19c82" translate="yes" xml:space="preserve">
          <source>There is one notable exception to this behavior: if the optional argument &lt;code&gt;names=True&lt;/code&gt;, the first commented line will be examined for names.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df9a641fbd94988d395fb4542afcc38f2bd13355" translate="yes" xml:space="preserve">
          <source>There must be at least 1 argument, and define the last argument as &lt;em&gt;item&lt;/em&gt;. Then, &lt;code&gt;a.itemset(*args)&lt;/code&gt; is equivalent to but faster than &lt;code&gt;a[args] = item&lt;/code&gt;. The item should be a scalar value and &lt;code&gt;args&lt;/code&gt; must select a single item in the array &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">Должен быть как минимум 1 аргумент, и последний аргумент определяется как &lt;em&gt;элемент&lt;/em&gt; . Тогда &lt;code&gt;a.itemset(*args)&lt;/code&gt; эквивалентен, но быстрее, чем &lt;code&gt;a[args] = item&lt;/code&gt; . Элемент должен быть скалярным значением, а &lt;code&gt;args&lt;/code&gt; должны выбирать один элемент в массиве &lt;code&gt;a&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bc33808ec0ca031cf8b9c1fdd7c9278c78f0db38" translate="yes" xml:space="preserve">
          <source>There was no __array_interface__ attribute instead all of the keys (except for version) in the __array_interface__ dictionary were their own attribute: Thus to obtain the Python-side information you had to access separately the attributes:</source>
          <target state="translated">Вместо атрибута __array_interface__в словаре __array_interface__не было атрибута __array_interface__,все ключи (кроме версии)были собственным атрибутом:Таким образом,для получения информации на питоновской стороне необходимо было получить доступ к атрибутам по отдельности:</target>
        </trans-unit>
        <trans-unit id="1d3ca63c0d0c4fb92d45d132b89354f4e2a0e2fc" translate="yes" xml:space="preserve">
          <source>There will not be anything &lt;em&gt;wrong&lt;/em&gt; with the results, per se; even a seed of 0 is perfectly fine thanks to the processing that &lt;a href=&quot;generated/numpy.random.seedsequence#numpy.random.SeedSequence&quot;&gt;&lt;code&gt;SeedSequence&lt;/code&gt;&lt;/a&gt; does. If you just need &lt;em&gt;some&lt;/em&gt; fixed value for unit tests or debugging, feel free to use whatever seed you like. But if you want to make inferences from the results or publish them, drawing from a larger set of seeds is good practice.</source>
          <target state="translated">По сути, в результатах не будет ничего &lt;em&gt;плохого&lt;/em&gt; ; даже семя 0 прекрасно благодаря обработке, &lt;a href=&quot;generated/numpy.random.seedsequence#numpy.random.SeedSequence&quot;&gt; &lt;code&gt;SeedSequence&lt;/code&gt; &lt;/a&gt; выполняет SeedSequence . Если вам просто нужно &lt;em&gt;какое-то&lt;/em&gt; фиксированное значение для модульных тестов или отладки, не стесняйтесь использовать любое семя, которое вам нравится. Но если вы хотите сделать выводы из результатов или опубликовать их, хорошей практикой будет извлечение из большего набора семян.</target>
        </trans-unit>
        <trans-unit id="1a33a5d0a80b8b553aad5ef6b8b9d3cf3a744293" translate="yes" xml:space="preserve">
          <source>There&amp;rsquo;s an embarrassing typo in a commit you made? Or perhaps the you made several false starts you would like the posterity not to see.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="de5a5e9111615649ff06d77b214a9aa4744c2e9e" translate="yes" xml:space="preserve">
          <source>These Boolean-valued flags affect how numpy interprets the memory area used by &lt;code&gt;a&lt;/code&gt; (see Notes below). The ALIGNED flag can only be set to True if the data is actually aligned according to the type. The WRITEBACKIFCOPY and (deprecated) UPDATEIFCOPY flags can never be set to True. The flag WRITEABLE can only be set to True if the array owns its own memory, or the ultimate owner of the memory exposes a writeable buffer interface, or is a string. (The exception for string is made so that unpickling can be done without copying memory.)</source>
          <target state="translated">Эти флаги с логическим значением влияют на то, как numpy интерпретирует область памяти, используемую &lt;code&gt;a&lt;/code&gt; (см. Примечания ниже). Флаг ALIGNED может быть установлен в True только в том случае, если данные фактически выровнены в соответствии с типом. Флаги WRITEBACKIFCOPY и (устаревшие) UPDATEIFCOPY никогда не могут быть установлены в значение True. Флаг WRITEABLE может быть установлен в True, только если массив владеет собственной памятью, или конечный владелец памяти предоставляет доступный для записи интерфейс буфера, или является строкой. (Исключение для строки сделано для того, чтобы распаковку можно было выполнить без копирования памяти.)</target>
        </trans-unit>
        <trans-unit id="a6788920c31464c6803c23f30203598688f71c50" translate="yes" xml:space="preserve">
          <source>These additional dependencies for building the documentation are listed in &lt;code&gt;doc_requirements.txt&lt;/code&gt; and can be conveniently installed with:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7faf38a4c03dd7b8b5f6a940a17e52f4253526ca" translate="yes" xml:space="preserve">
          <source>These all achieve the same result:</source>
          <target state="translated">Все они достигают одного и того же результата:</target>
        </trans-unit>
        <trans-unit id="ca33633bc8f8738d475e05fabdb7eda73e305c81" translate="yes" xml:space="preserve">
          <source>These are defined for &lt;code&gt;{bits}&lt;/code&gt; = 8, 16, 32, 64, 128, and 256 and provide the maximum (minimum) value of the corresponding (unsigned) integer type. Note: the actual integer type may not be available on all platforms (i.e. 128-bit and 256-bit integers are rare).</source>
          <target state="translated">Они определены для &lt;code&gt;{bits}&lt;/code&gt; = 8, 16, 32, 64, 128 и 256 и обеспечивают максимальное (минимальное) значение соответствующего (беззнакового) целочисленного типа. Примечание: фактический целочисленный тип может быть доступен не на всех платформах (т.е. 128-битные и 256-битные целые числа встречаются редко).</target>
        </trans-unit>
        <trans-unit id="8ddb00a13475a7300c7d1510545ce91de444184f" translate="yes" xml:space="preserve">
          <source>These are enhanced arrays of either &lt;code&gt;string_&lt;/code&gt; type or &lt;code&gt;unicode_&lt;/code&gt; type. These arrays inherit from the &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt;, but specially-define the operations &lt;code&gt;+&lt;/code&gt;, &lt;code&gt;*&lt;/code&gt;, and &lt;code&gt;%&lt;/code&gt; on a (broadcasting) element-by-element basis. These operations are not available on the standard &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt; of character type. In addition, the &lt;a href=&quot;generated/numpy.chararray#numpy.chararray&quot;&gt;&lt;code&gt;chararray&lt;/code&gt;&lt;/a&gt; has all of the standard &lt;a href=&quot;https://docs.python.org/dev/library/stdtypes.html#str&quot;&gt;&lt;code&gt;string&lt;/code&gt;&lt;/a&gt; (and &lt;code&gt;unicode&lt;/code&gt;) methods, executing them on an element-by-element basis. Perhaps the easiest way to create a chararray is to use &lt;a href=&quot;generated/numpy.ndarray.view#numpy.ndarray.view&quot;&gt;&lt;code&gt;self.view(chararray)&lt;/code&gt;&lt;/a&gt; where &lt;em&gt;self&lt;/em&gt; is an ndarray of str or unicode data-type. However, a chararray can also be created using the &lt;a href=&quot;generated/numpy.chararray#numpy.chararray&quot;&gt;&lt;code&gt;numpy.chararray&lt;/code&gt;&lt;/a&gt; constructor, or via the &lt;a href=&quot;generated/numpy.core.defchararray.array#numpy.core.defchararray.array&quot;&gt;&lt;code&gt;numpy.char.array&lt;/code&gt;&lt;/a&gt; function:</source>
          <target state="translated">Они усиливаются массивы либо &lt;code&gt;string_&lt;/code&gt; типа или &lt;code&gt;unicode_&lt;/code&gt; типа. Эти массивы наследуются от &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt; , но специально определяют операции &lt;code&gt;+&lt;/code&gt; , &lt;code&gt;*&lt;/code&gt; и &lt;code&gt;%&lt;/code&gt; на (широковещательной) поэлементной основе. Эти операции недоступны для стандартного &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt; символьного типа. Кроме того, &lt;a href=&quot;generated/numpy.chararray#numpy.chararray&quot;&gt; &lt;code&gt;chararray&lt;/code&gt; &lt;/a&gt; имеет все стандартные &lt;a href=&quot;https://docs.python.org/dev/library/stdtypes.html#str&quot;&gt; &lt;code&gt;string&lt;/code&gt; &lt;/a&gt; (и &lt;code&gt;unicode&lt;/code&gt; ) методы, выполняющие их поэлементно. Возможно, самый простой способ создать chararray - использовать &lt;a href=&quot;generated/numpy.ndarray.view#numpy.ndarray.view&quot;&gt; &lt;code&gt;self.view(chararray)&lt;/code&gt; &lt;/a&gt; где &lt;em&gt;self&lt;/em&gt;представляет собой ndarray типа данных str или unicode. Однако chararray также можно создать с &lt;a href=&quot;generated/numpy.chararray#numpy.chararray&quot;&gt; &lt;code&gt;numpy.chararray&lt;/code&gt; &lt;/a&gt; конструктора numpy.chararray или с помощью функции &lt;a href=&quot;generated/numpy.core.defchararray.array#numpy.core.defchararray.array&quot;&gt; &lt;code&gt;numpy.char.array&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="5c5d09f4ce60946e76740852fd56ca7c8c49e5bd" translate="yes" xml:space="preserve">
          <source>These are roughly ordered from least-to-most precision.</source>
          <target state="translated">Они грубо заказываются с наименьшей точностью.</target>
        </trans-unit>
        <trans-unit id="2ce5765c6141294e2d5121321badaf2a8b57c10d" translate="yes" xml:space="preserve">
          <source>These are some detailed notes, which are not of importance for day to day indexing (in no particular order):</source>
          <target state="translated">Это некоторые подробные примечания,которые не важны для ежедневной индексации (не в определенном порядке):</target>
        </trans-unit>
        <trans-unit id="3f20305498e715f2e7a95c2c0aa48306a2b1d79a" translate="yes" xml:space="preserve">
          <source>These are the arrays for the operation.</source>
          <target state="translated">Это массивы для операции.</target>
        </trans-unit>
        <trans-unit id="7a1ac004102d237171aefc6abd621531cd490cc4" translate="yes" xml:space="preserve">
          <source>These are the constants and functions for accessing the ufunc C-API from extension modules in precisely the same way as the array C-API can be accessed. The &lt;code&gt;import_ufunc&lt;/code&gt; () function must always be called (in the initialization subroutine of the extension module). If your extension module is in one file then that is all that is required. The other two constants are useful if your extension module makes use of multiple files. In that case, define &lt;a href=&quot;#c.PY_UFUNC_UNIQUE_SYMBOL&quot;&gt;&lt;code&gt;PY_UFUNC_UNIQUE_SYMBOL&lt;/code&gt;&lt;/a&gt; to something unique to your code and then in source files that do not contain the module initialization function but still need access to the UFUNC API, define &lt;a href=&quot;#c.PY_UFUNC_UNIQUE_SYMBOL&quot;&gt;&lt;code&gt;PY_UFUNC_UNIQUE_SYMBOL&lt;/code&gt;&lt;/a&gt; to the same name used previously and also define &lt;a href=&quot;#c.NO_IMPORT_UFUNC&quot;&gt;&lt;code&gt;NO_IMPORT_UFUNC&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Это константы и функции для доступа к ufunc C-API из модулей расширения точно так же, как к массиву C-API. Функция &lt;code&gt;import_ufunc&lt;/code&gt; () должна вызываться всегда (в подпрограмме инициализации модуля расширения). Если ваш модуль расширения находится в одном файле, это все, что требуется. Две другие константы полезны, если ваш модуль расширения использует несколько файлов. В этом случае определите &lt;a href=&quot;#c.PY_UFUNC_UNIQUE_SYMBOL&quot;&gt; &lt;code&gt;PY_UFUNC_UNIQUE_SYMBOL&lt;/code&gt; &lt;/a&gt; для чего-то уникального для вашего кода, а затем в исходных файлах, которые не содержат функцию инициализации модуля, но все же нуждаются в доступе к UFUNC API, определите &lt;a href=&quot;#c.PY_UFUNC_UNIQUE_SYMBOL&quot;&gt; &lt;code&gt;PY_UFUNC_UNIQUE_SYMBOL&lt;/code&gt; &lt;/a&gt; с тем же именем, которое использовалось ранее, а также определите &lt;a href=&quot;#c.NO_IMPORT_UFUNC&quot;&gt; &lt;code&gt;NO_IMPORT_UFUNC&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e0aaea1e5f2c4b6d0e0dc28a8aa40e102fa58beb" translate="yes" xml:space="preserve">
          <source>These are the indices that would allow you to access the upper triangular part of any 3x3 array:</source>
          <target state="translated">Это индексы,которые позволяют получить доступ к верхней треугольной части любого массива 3x3:</target>
        </trans-unit>
        <trans-unit id="38bc2b8e25d17f4fb4231aea381549f2e431c561" translate="yes" xml:space="preserve">
          <source>These are the instructions if you just want to follow the latest &lt;em&gt;NumPy&lt;/em&gt; source, but you don&amp;rsquo;t need to do any development for now. If you do want to contribute a patch (excellent!) or do more extensive NumPy development, see &lt;a href=&quot;../development_workflow#development-workflow&quot;&gt;Development workflow&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="43efdc6f451764645e6025c80a5a83f304f68569" translate="yes" xml:space="preserve">
          <source>These are typically used in situations where in C/C++, you would allocate a(n) array(s) on the heap, and call the function to fill the array(s) values. In Python, the arrays are allocated for you and returned as new array objects.</source>
          <target state="translated">Обычно они используются в ситуациях,когда в Си/Си++необходимо выделить массив(ы)a(n)на куче и вызвать функцию для заполнения значений массива(ов).В Python массивы выделяются для вас и возвращаются как новые объекты массива.</target>
        </trans-unit>
        <trans-unit id="f04a7bcc6ce293328ac2b1079d0f95ad7b19da67" translate="yes" xml:space="preserve">
          <source>These are written in doctest format, and should illustrate how to use the function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a93c5dc49de55891886f179425b788a1c6ad1b35" translate="yes" xml:space="preserve">
          <source>These arrays are views on the original arrays. They are typically not contiguous. Furthermore, more than one element of a broadcasted array may refer to a single memory location. If you need to write to the arrays, make copies first. While you can set the &lt;code&gt;writable&lt;/code&gt; flag True, writing to a single output value may end up changing more than one location in the output array.</source>
          <target state="translated">Эти массивы представляют собой просмотры исходных массивов. Обычно они не являются смежными. Кроме того, более одного элемента широковещательного массива могут ссылаться на одну ячейку памяти. Если вам нужно записать в массивы, сначала сделайте копии. Хотя вы можете установить флаг &lt;code&gt;writable&lt;/code&gt; True, запись в одно выходное значение может привести к изменению более чем одного места в выходном массиве.</target>
        </trans-unit>
        <trans-unit id="95e5069d3636251c2ff01dcc947b04bbf8ba1923" translate="yes" xml:space="preserve">
          <source>These behaviors can be set for all kinds of errors or specific ones:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7f0acac4ec85b4b4bd7ae1e0ff5a3f9603fcfbc3" translate="yes" xml:space="preserve">
          <source>These constants are used in &lt;a href=&quot;#c.PyArray_FromAny&quot;&gt;&lt;code&gt;PyArray_FromAny&lt;/code&gt;&lt;/a&gt; (and its macro forms) to specify desired properties of the new array.</source>
          <target state="translated">Эти константы используются в &lt;a href=&quot;#c.PyArray_FromAny&quot;&gt; &lt;code&gt;PyArray_FromAny&lt;/code&gt; &lt;/a&gt; (и его формах макросов) для определения желаемых свойств нового массива.</target>
        </trans-unit>
        <trans-unit id="3d245bb5214c903868626d468b5ef8607e3f9a4a" translate="yes" xml:space="preserve">
          <source>These cover almost the whole array (two diagonals right of the main one):</source>
          <target state="translated">Они покрывают практически весь массив (две диагонали справа от основной):</target>
        </trans-unit>
        <trans-unit id="f7e900132de2199b00f5d74615e0a1848ce14490" translate="yes" xml:space="preserve">
          <source>These cover only a small part of the whole array (two diagonals right of the main one):</source>
          <target state="translated">Они покрывают лишь малую часть всего массива (две диагонали справа от основной):</target>
        </trans-unit>
        <trans-unit id="1adc6f5a53325e3aa2e7cccdff9469027b73b4ce" translate="yes" xml:space="preserve">
          <source>These documents are intended as an introductory overview of NumPy and its features. For detailed reference documentation of the functions and classes contained in the package, see the &lt;a href=&quot;../reference/index#reference&quot;&gt;API reference&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca02dca00e56b01dd5323ec3c2c51c9bba04e9a2" translate="yes" xml:space="preserve">
          <source>These documents are intended as recipes to common tasks using NumPy. For detailed reference documentation of the functions and classes contained in the package, see the &lt;a href=&quot;../reference/index#reference&quot;&gt;API reference&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad1b854bfa000aee75512c8df139be2e2841e0fd" translate="yes" xml:space="preserve">
          <source>These documents are intended to explain in detail the concepts and techniques used in NumPy. For the reference documentation of the functions and classes contained in the package, see the &lt;a href=&quot;../reference/index#reference&quot;&gt;API reference&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="63868acfbf699fe963e728a55308e7d3a9b22eb9" translate="yes" xml:space="preserve">
          <source>These examples illustrate the low-level &lt;a href=&quot;#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt; constructor. Refer to the &lt;code&gt;See Also&lt;/code&gt; section above for easier ways of constructing an ndarray.</source>
          <target state="translated">Эти примеры иллюстрируют низкоуровневый конструктор &lt;a href=&quot;#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt; . Обратитесь к разделу &quot; &lt;code&gt;See Also&lt;/code&gt; выше, чтобы узнать о более простых способах создания ndarray.</target>
        </trans-unit>
        <trans-unit id="8a348b17d2fb1b33a90b7baa8a557d9af808a018" translate="yes" xml:space="preserve">
          <source>These function all require integer arguments and they manipulate the bit-pattern of those arguments.</source>
          <target state="translated">Все эти функции требуют целочисленных аргументов и манипулируют их битовой моделью.</target>
        </trans-unit>
        <trans-unit id="d7e647d09c10f9f4521e851e5661f2624622c65e" translate="yes" xml:space="preserve">
          <source>These functions along with a minimal setup file are included in the examples folder.</source>
          <target state="translated">Эти функции вместе с минимальным файлом настройки включены в папку примеров.</target>
        </trans-unit>
        <trans-unit id="47c8ad5dd0ea816b255a3666826ae66a37ff3a15" translate="yes" xml:space="preserve">
          <source>These functions and macros provide easy access to elements of the ndarray from C. These work for all arrays. You may need to take care when accessing the data in the array, however, if it is not in machine byte-order, misaligned, or not writeable. In other words, be sure to respect the state of the flags unless you know what you are doing, or have previously guaranteed an array that is writeable, aligned, and in machine byte-order using &lt;a href=&quot;#c.PyArray_FromAny&quot;&gt;&lt;code&gt;PyArray_FromAny&lt;/code&gt;&lt;/a&gt;. If you wish to handle all types of arrays, the copyswap function for each type is useful for handling misbehaved arrays. Some platforms (e.g. Solaris) do not like misaligned data and will crash if you de-reference a misaligned pointer. Other platforms (e.g. x86 Linux) will just work more slowly with misaligned data.</source>
          <target state="translated">Эти функции и макросы обеспечивают легкий доступ к элементам ndarray из C. Они работают для всех массивов. Однако вам может потребоваться осторожность при доступе к данным в массиве, если они не в машинном порядке байтов, смещены или недоступны для записи. Другими словами, обязательно соблюдайте состояние флагов, если вы не знаете, что делаете, или ранее не гарантировали, что массив может быть записан, выровнен и в машинном порядке байтов с использованием &lt;a href=&quot;#c.PyArray_FromAny&quot;&gt; &lt;code&gt;PyArray_FromAny&lt;/code&gt; &lt;/a&gt; . Если вы хотите обрабатывать все типы массивов, функция copyswap для каждого типа полезна для обработки неправильно функционирующих массивов. Некоторым платформам (например, Solaris) не нравятся смещенные данные, и при отмене ссылки на смещенный указатель произойдет сбой. Другие платформы (например, x86 Linux) просто будут работать медленнее с несогласованными данными.</target>
        </trans-unit>
        <trans-unit id="a0b164307df93568d43c0a9ad269b4dbe393e0e6" translate="yes" xml:space="preserve">
          <source>These functions are included here because they are used at least once in the array object&amp;rsquo;s methods. The function returns -1 (without setting a Python Error) if one of the objects being assigned is not callable.</source>
          <target state="translated">Эти функции включены сюда, потому что они используются хотя бы один раз в методах объекта массива. Функция возвращает -1 (без установки ошибки Python), если один из назначаемых объектов не может быть вызван.</target>
        </trans-unit>
        <trans-unit id="8de7e7b6b1e1ede303832d725868059c022d2d0a" translate="yes" xml:space="preserve">
          <source>These functions are very similar to functions without keyword arguments. The only difference is that the function signature is:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="474e0e7c22745c37837977d2aed3d481ae32dc24" translate="yes" xml:space="preserve">
          <source>These identities allow a Chebyshev series to be expressed as a finite, symmetric Laurent series. In this module, this sort of Laurent series is referred to as a &amp;ldquo;z-series.&amp;rdquo;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a58240a1702d16b3630637ee0890f803946e53fd" translate="yes" xml:space="preserve">
          <source>These macros access the &lt;a href=&quot;types-and-structures#c.PyArrayObject&quot;&gt;&lt;code&gt;PyArrayObject&lt;/code&gt;&lt;/a&gt; structure members and are defined in &lt;code&gt;ndarraytypes.h&lt;/code&gt;. The input argument, &lt;em&gt;arr&lt;/em&gt;, can be any &lt;a href=&quot;https://docs.python.org/dev/c-api/structures.html#c.PyObject&quot;&gt;&lt;code&gt;PyObject *&lt;/code&gt;&lt;/a&gt; that is directly interpretable as a &lt;a href=&quot;types-and-structures#c.PyArrayObject&quot;&gt;&lt;code&gt;PyArrayObject *&lt;/code&gt;&lt;/a&gt; (any instance of the &lt;a href=&quot;types-and-structures#c.PyArray_Type&quot;&gt;&lt;code&gt;PyArray_Type&lt;/code&gt;&lt;/a&gt; and itssub-types).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="13b269cced89ab6392bc06c8030f96e4b737c057" translate="yes" xml:space="preserve">
          <source>These macros all access the &lt;a href=&quot;c-api.types-and-structures#c.PyArrayObject&quot;&gt;&lt;code&gt;PyArrayObject&lt;/code&gt;&lt;/a&gt; structure members. The input argument, arr, can be any &lt;a href=&quot;https://docs.python.org/dev/c-api/structures.html#c.PyObject&quot;&gt;&lt;code&gt;PyObject *&lt;/code&gt;&lt;/a&gt; that is directly interpretable as a &lt;a href=&quot;c-api.types-and-structures#c.PyArrayObject&quot;&gt;&lt;code&gt;PyArrayObject *&lt;/code&gt;&lt;/a&gt; (any instance of the &lt;a href=&quot;c-api.types-and-structures#c.PyArray_Type&quot;&gt;&lt;code&gt;PyArray_Type&lt;/code&gt;&lt;/a&gt; and its sub-types).</source>
          <target state="translated">Все эти макросы обращаются к &lt;a href=&quot;c-api.types-and-structures#c.PyArrayObject&quot;&gt; &lt;code&gt;PyArrayObject&lt;/code&gt; &lt;/a&gt; структуры PyArrayObject . Входной аргумент arr может быть любым &lt;a href=&quot;https://docs.python.org/dev/c-api/structures.html#c.PyObject&quot;&gt; &lt;code&gt;PyObject *&lt;/code&gt; ,&lt;/a&gt; который напрямую интерпретируется как &lt;a href=&quot;c-api.types-and-structures#c.PyArrayObject&quot;&gt; &lt;code&gt;PyArrayObject *&lt;/code&gt; &lt;/a&gt; (любой экземпляр &lt;a href=&quot;c-api.types-and-structures#c.PyArray_Type&quot;&gt; &lt;code&gt;PyArray_Type&lt;/code&gt; &lt;/a&gt; и его подтипы ).</target>
        </trans-unit>
        <trans-unit id="0b21dcbffd2b61b3d3ee30959d3bc33fc08a9c74" translate="yes" xml:space="preserve">
          <source>These macros are only meaningful if &lt;code&gt;NPY_ALLOW_THREADS&lt;/code&gt; evaluates True during compilation of the extension module. Otherwise, these macros are equivalent to whitespace. Python uses a single Global Interpreter Lock (GIL) for each Python process so that only a single thread may execute at a time (even on multi-cpu machines). When calling out to a compiled function that may take time to compute (and does not have side-effects for other threads like updated global variables), the GIL should be released so that other Python threads can run while the time-consuming calculations are performed. This can be accomplished using two groups of macros. Typically, if one macro in a group is used in a code block, all of them must be used in the same code block. Currently, &lt;code&gt;NPY_ALLOW_THREADS&lt;/code&gt; is defined to the python-defined &lt;code&gt;WITH_THREADS&lt;/code&gt; constant unless the environment variable &lt;code&gt;NPY_NOSMP&lt;/code&gt; is set in which case &lt;code&gt;NPY_ALLOW_THREADS&lt;/code&gt; is defined to be 0.</source>
          <target state="translated">Эти макросы имеют смысл только в том случае, если &lt;code&gt;NPY_ALLOW_THREADS&lt;/code&gt; оценивает True во время компиляции модуля расширения. В противном случае эти макросы эквивалентны пробелам. Python использует одну глобальную блокировку интерпретатора (GIL) для каждого процесса Python, так что одновременно может выполняться только один поток (даже на машинах с несколькими процессорами). При вызове скомпилированной функции, вычисление которой может занять время (и не имеет побочных эффектов для других потоков, таких как обновленные глобальные переменные), GIL должен быть освобожден, чтобы другие потоки Python могли работать, пока выполняются трудоемкие вычисления. . Это можно сделать с помощью двух групп макросов. Обычно, если один макрос в группе используется в блоке кода, все они должны использоваться в одном блоке кода. В настоящее время &lt;code&gt;NPY_ALLOW_THREADS&lt;/code&gt; определяется для константы &lt;code&gt;WITH_THREADS&lt;/code&gt; , определенной в Python, если переменная среды &lt;code&gt;NPY_NOSMP&lt;/code&gt; не установлена, и в этом случае &lt;code&gt;NPY_ALLOW_THREADS&lt;/code&gt; определено как 0.</target>
        </trans-unit>
        <trans-unit id="da2fff533a172874c502697494e5cdbf3a7c39b3" translate="yes" xml:space="preserve">
          <source>These macros use different memory allocators, depending on the constant &lt;code&gt;NPY_USE_PYMEM&lt;/code&gt;. The system malloc is used when &lt;code&gt;NPY_USE_PYMEM&lt;/code&gt; is 0, if &lt;code&gt;NPY_USE_PYMEM&lt;/code&gt; is 1, then the Python memory allocator is used.</source>
          <target state="translated">Эти макросы используют разные распределители памяти в зависимости от константы &lt;code&gt;NPY_USE_PYMEM&lt;/code&gt; . Системный malloc используется, когда &lt;code&gt;NPY_USE_PYMEM&lt;/code&gt; равен 0, если &lt;code&gt;NPY_USE_PYMEM&lt;/code&gt; равен 1, тогда используется распределитель памяти Python.</target>
        </trans-unit>
        <trans-unit id="512de4565bde2a4a800d6eb7f4ecd21ece637307" translate="yes" xml:space="preserve">
          <source>These members are both pointers to functions to copy data from &lt;em&gt;src&lt;/em&gt; to &lt;em&gt;dest&lt;/em&gt; and &lt;em&gt;swap&lt;/em&gt; if indicated. The value of arr is only used for flexible ( &lt;a href=&quot;c-api.dtype#c.NPY_STRING&quot;&gt;&lt;code&gt;NPY_STRING&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;c-api.dtype#c.NPY_UNICODE&quot;&gt;&lt;code&gt;NPY_UNICODE&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;c-api.dtype#c.NPY_VOID&quot;&gt;&lt;code&gt;NPY_VOID&lt;/code&gt;&lt;/a&gt; ) arrays (and is obtained from &lt;code&gt;arr-&amp;gt;descr-&amp;gt;elsize&lt;/code&gt; ). The second function copies a single value, while the first loops over n values with the provided strides. These functions can deal with misbehaved &lt;em&gt;src&lt;/em&gt; data. If &lt;em&gt;src&lt;/em&gt; is NULL then no copy is performed. If &lt;em&gt;swap&lt;/em&gt; is 0, then no byteswapping occurs. It is assumed that &lt;em&gt;dest&lt;/em&gt; and &lt;em&gt;src&lt;/em&gt; do not overlap. If they overlap, then use &lt;code&gt;memmove&lt;/code&gt; (&amp;hellip;) first followed by &lt;code&gt;copyswap(n)&lt;/code&gt; with NULL valued &lt;code&gt;src&lt;/code&gt;.</source>
          <target state="translated">Эти члены являются указателями на функции для копирования данных из &lt;em&gt;src&lt;/em&gt; в &lt;em&gt;dest&lt;/em&gt; и &lt;em&gt;обмена,&lt;/em&gt; если указано. Значение arr используется только для гибких &lt;a href=&quot;c-api.dtype#c.NPY_STRING&quot;&gt; &lt;code&gt;NPY_STRING&lt;/code&gt; &lt;/a&gt; ( NPY_STRING , &lt;a href=&quot;c-api.dtype#c.NPY_UNICODE&quot;&gt; &lt;code&gt;NPY_UNICODE&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;c-api.dtype#c.NPY_VOID&quot;&gt; &lt;code&gt;NPY_VOID&lt;/code&gt; &lt;/a&gt; ) (и получается из &lt;code&gt;arr-&amp;gt;descr-&amp;gt;elsize&lt;/code&gt; ). Вторая функция копирует одно значение, а первая перебирает n значений с предоставленными шагами. Эти функции могут работать с некорректными данными &lt;em&gt;src&lt;/em&gt; . Если &lt;em&gt;src&lt;/em&gt; равен NULL, то копирование не выполняется. Если &lt;em&gt;swap&lt;/em&gt; равен 0, то перестановка байтов не происходит. Предполагается, что &lt;em&gt;dest&lt;/em&gt; и &lt;em&gt;src&lt;/em&gt;не перекрываются. Если они перекрываются, то &lt;code&gt;memmove&lt;/code&gt; используйте memmove (&amp;hellip;), а затем &lt;code&gt;copyswap(n)&lt;/code&gt; с нулевым значением &lt;code&gt;src&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6a72dfa72e903b9f6c19523d338aa7b21c3b5f83" translate="yes" xml:space="preserve">
          <source>These members are both pointers to functions to copy data from &lt;em&gt;src&lt;/em&gt; to &lt;em&gt;dest&lt;/em&gt; and &lt;em&gt;swap&lt;/em&gt; if indicated. The value of arr is only used for flexible ( &lt;a href=&quot;dtype#c.NPY_STRING&quot;&gt;&lt;code&gt;NPY_STRING&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;dtype#c.NPY_UNICODE&quot;&gt;&lt;code&gt;NPY_UNICODE&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;dtype#c.NPY_VOID&quot;&gt;&lt;code&gt;NPY_VOID&lt;/code&gt;&lt;/a&gt; ) arrays (and is obtained from &lt;code&gt;arr-&amp;gt;descr-&amp;gt;elsize&lt;/code&gt; ). The second function copies a single value, while the first loops over n values with the provided strides. These functions can deal with misbehaved &lt;em&gt;src&lt;/em&gt; data. If &lt;em&gt;src&lt;/em&gt; is NULL then no copy is performed. If &lt;em&gt;swap&lt;/em&gt; is 0, then no byteswapping occurs. It is assumed that &lt;em&gt;dest&lt;/em&gt; and &lt;em&gt;src&lt;/em&gt; do not overlap. If they overlap, then use &lt;code&gt;memmove&lt;/code&gt; (&amp;hellip;) first followed by &lt;code&gt;copyswap(n)&lt;/code&gt; with NULL valued &lt;code&gt;src&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d6721252244f80ca68ee960086197a2ea6f31616" translate="yes" xml:space="preserve">
          <source>These numbers in the previous line represent (0, 0) to machine precision</source>
          <target state="translated">Эти цифры в предыдущей строке представляют (0,0)для точности обработки.</target>
        </trans-unit>
        <trans-unit id="dc06d74801540c694b86fd1603123c1d29a31d44" translate="yes" xml:space="preserve">
          <source>These options determine the way floating point numbers, arrays and other NumPy objects are displayed.</source>
          <target state="translated">Эти опции определяют способ отображения чисел с плавающей точкой,массивов и других объектов NumPy.</target>
        </trans-unit>
        <trans-unit id="c7caafe15667a4da0d6093971259ebc7a46a9f78" translate="yes" xml:space="preserve">
          <source>These pages describe a general &lt;a href=&quot;https://git-scm.com/&quot;&gt;git&lt;/a&gt; and &lt;a href=&quot;https://github.com/numpy/numpy&quot;&gt;github&lt;/a&gt; workflow.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df150acba8d3f0417e81ddcccc29e42e2e807db8" translate="yes" xml:space="preserve">
          <source>These paths both use the same machinery. We make the distinction here, because they result in different input to your methods. Specifically, &lt;a href=&quot;#view-casting&quot;&gt;View casting&lt;/a&gt; means you have created a new instance of your array type from any potential subclass of ndarray. &lt;a href=&quot;#new-from-template&quot;&gt;Creating new from template&lt;/a&gt; means you have created a new instance of your class from a pre-existing instance, allowing you - for example - to copy across attributes that are particular to your subclass.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dcba0fcabfaea90dcbb4dedc9f83dbe704fc9440" translate="yes" xml:space="preserve">
          <source>These pointers are different from the pointers accepted by &lt;code&gt;NpyIter_ResetBasePointers&lt;/code&gt;, because the direction along some axes may have been reversed.</source>
          <target state="translated">Эти указатели отличаются от указателей, принимаемых &lt;code&gt;NpyIter_ResetBasePointers&lt;/code&gt; , потому что направление вдоль некоторых осей могло быть изменено на обратное.</target>
        </trans-unit>
        <trans-unit id="2936192ef68f1082cb1baded7a4cc1332510cdca" translate="yes" xml:space="preserve">
          <source>These properties together mean that we can safely mix together the usual user-provided seed with simple incrementing counters to get &lt;a href=&quot;bit_generators/generated/numpy.random.bitgenerator#numpy.random.BitGenerator&quot;&gt;&lt;code&gt;BitGenerator&lt;/code&gt;&lt;/a&gt; states that are (to very high probability) independent of each other. We can wrap this together into an API that is easy to use and difficult to misuse.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="43a8a14f212cc60aa00fe9447268d1975d32ef40" translate="yes" xml:space="preserve">
          <source>These properties together mean that we can safely mix together the usual user-provided seed with simple incrementing counters to get &lt;code&gt;BitGenerator&lt;/code&gt; states that are (to very high probability) independent of each other. We can wrap this together into an API that is easy to use and difficult to misuse.</source>
          <target state="translated">Эти свойства вместе означают, что мы можем безопасно смешивать обычное начальное число, предоставляемое пользователем, с простыми увеличивающимися счетчиками, чтобы получить состояния &lt;code&gt;BitGenerator&lt;/code&gt; , которые (с очень высокой вероятностью) независимы друг от друга. Мы можем объединить все это в API, который прост в использовании и труден для злоупотребления.</target>
        </trans-unit>
        <trans-unit id="a6a12c973c6b3912e3652bb2e3ed402ca4234700" translate="yes" xml:space="preserve">
          <source>These tools have been found useful by others using Python and so are included here. They are discussed separately because they are either older ways to do things now handled by f2py, Cython, or ctypes (SWIG, PyFort) or because I don&amp;rsquo;t know much about them (SIP, Boost). I have not added links to these methods because my experience is that you can find the most relevant link faster using Google or some other search engine, and any links provided here would be quickly dated. Do not assume that just because it is included in this list, I don&amp;rsquo;t think the package deserves your attention. I&amp;rsquo;m including information about these packages because many people have found them useful and I&amp;rsquo;d like to give you as many options as possible for tackling the problem of easily integrating your code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f0fbc806872e828602fd0c760ad7240ac769262d" translate="yes" xml:space="preserve">
          <source>These two macros are similar and obtain the pointer to the data-buffer for the array. The first macro can (and should be) assigned to a particular pointer where the second is for generic processing. If you have not guaranteed a contiguous and/or aligned array then be sure you understand how to access the data in the array to avoid memory and/or alignment problems.</source>
          <target state="translated">Эти два макроса похожи и получают указатель на буфер данных для массива.Первый макрос может (и должен быть)присвоен конкретному указателю,где второй-для общей обработки.Если вы не гарантировали наличие смежного и/или выровненного массива,то во избежание проблем с памятью и/или выравниванием убедитесь,что вы понимаете,как получить доступ к данным в массиве.</target>
        </trans-unit>
        <trans-unit id="e28f8dd7e1d385fa1bfc87cb75abfbb7c4a8ade7" translate="yes" xml:space="preserve">
          <source>These type names are part of the C-API and can therefore be created in extension C-code. There is also a &lt;code&gt;PyIntpArrType_Type&lt;/code&gt; and a &lt;code&gt;PyUIntpArrType_Type&lt;/code&gt; that are simple substitutes for one of the integer types that can hold a pointer on the platform. The structure of these scalar objects is not exposed to C-code. The function &lt;a href=&quot;array#c.PyArray_ScalarAsCtype&quot;&gt;&lt;code&gt;PyArray_ScalarAsCtype&lt;/code&gt;&lt;/a&gt; (..) can be used to extract the C-type value from the array scalar and the function &lt;a href=&quot;array#c.PyArray_Scalar&quot;&gt;&lt;code&gt;PyArray_Scalar&lt;/code&gt;&lt;/a&gt; (&amp;hellip;) can be used to construct an array scalar from a C-value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be4a900566749a67d476933d0258a41ade60543e" translate="yes" xml:space="preserve">
          <source>These type names are part of the C-API and can therefore be created in extension C-code. There is also a &lt;code&gt;PyIntpArrType_Type&lt;/code&gt; and a &lt;code&gt;PyUIntpArrType_Type&lt;/code&gt; that are simple substitutes for one of the integer types that can hold a pointer on the platform. The structure of these scalar objects is not exposed to C-code. The function &lt;a href=&quot;c-api.array#c.PyArray_ScalarAsCtype&quot;&gt;&lt;code&gt;PyArray_ScalarAsCtype&lt;/code&gt;&lt;/a&gt; (..) can be used to extract the C-type value from the array scalar and the function &lt;a href=&quot;c-api.array#c.PyArray_Scalar&quot;&gt;&lt;code&gt;PyArray_Scalar&lt;/code&gt;&lt;/a&gt; (&amp;hellip;) can be used to construct an array scalar from a C-value.</source>
          <target state="translated">Эти имена типов являются частью C-API и поэтому могут быть созданы в расширении C-code. Также существуют &lt;code&gt;PyIntpArrType_Type&lt;/code&gt; и &lt;code&gt;PyUIntpArrType_Type&lt;/code&gt; , которые являются простыми заменителями одного из целочисленных типов, которые могут содержать указатель на платформе. Структура этих скалярных объектов не отображается в C-коде. Функция &lt;a href=&quot;c-api.array#c.PyArray_ScalarAsCtype&quot;&gt; &lt;code&gt;PyArray_ScalarAsCtype&lt;/code&gt; &lt;/a&gt; (..) может использоваться для извлечения значения C-типа из скаляра массива, а функция &lt;a href=&quot;c-api.array#c.PyArray_Scalar&quot;&gt; &lt;code&gt;PyArray_Scalar&lt;/code&gt; &lt;/a&gt; (&amp;hellip;) может использоваться для создания скаляра массива из C-значения.</target>
        </trans-unit>
        <trans-unit id="39c33e43ad465d1114668c2913272d120aead183" translate="yes" xml:space="preserve">
          <source>These typemaps now check to make sure that the &lt;code&gt;INPLACE_ARRAY&lt;/code&gt; arguments use native byte ordering. If not, an exception is raised.</source>
          <target state="translated">Эти карты типов теперь проверяют, используют &lt;code&gt;INPLACE_ARRAY&lt;/code&gt; аргументы INPLACE_ARRAY собственный порядок байтов. Если нет, возникает исключение.</target>
        </trans-unit>
        <trans-unit id="afffd3e5751f118e6c4a8e5fa416a0de7397d2ff" translate="yes" xml:space="preserve">
          <source>These values are appended to a copy of &lt;code&gt;a&lt;/code&gt;. It must be of the correct shape (the same shape as &lt;code&gt;a&lt;/code&gt;, excluding &lt;code&gt;axis&lt;/code&gt;). If &lt;code&gt;axis&lt;/code&gt; is not specified, &lt;code&gt;b&lt;/code&gt; can be any shape and will be flattened before use.</source>
          <target state="translated">Эти значения добавляются к копии &lt;code&gt;a&lt;/code&gt; . Он должен быть правильной формы (такой же, как &lt;code&gt;a&lt;/code&gt; , за исключением &lt;code&gt;axis&lt;/code&gt; ). Если &lt;code&gt;axis&lt;/code&gt; не указана, &lt;code&gt;b&lt;/code&gt; может иметь любую форму и перед использованием будет сплющен.</target>
        </trans-unit>
        <trans-unit id="612fafedc61071a5e61db03c65c0f553ab91df63" translate="yes" xml:space="preserve">
          <source>These values are appended to a copy of &lt;code&gt;arr&lt;/code&gt;. It must be of the correct shape (the same shape as &lt;code&gt;arr&lt;/code&gt;, excluding &lt;code&gt;axis&lt;/code&gt;). If &lt;code&gt;axis&lt;/code&gt; is not specified, &lt;code&gt;values&lt;/code&gt; can be any shape and will be flattened before use.</source>
          <target state="translated">Эти значения добавляются к копии &lt;code&gt;arr&lt;/code&gt; . Он должен быть правильной формы (такой же, как &lt;code&gt;arr&lt;/code&gt; , за исключением &lt;code&gt;axis&lt;/code&gt; ). Если &lt;code&gt;axis&lt;/code&gt; не указана, &lt;code&gt;values&lt;/code&gt; могут иметь любую форму и перед использованием будут развернуты.</target>
        </trans-unit>
        <trans-unit id="c265d10397c2203b05e143772f5cfb33ffa2cf8c" translate="yes" xml:space="preserve">
          <source>These values are only returned if &lt;code&gt;full&lt;/code&gt; = True</source>
          <target state="translated">Эти значения возвращаются, только если &lt;code&gt;full&lt;/code&gt; = True</target>
        </trans-unit>
        <trans-unit id="94c85fa0224cf9a04b1b6ccf08fcebfe46c06507" translate="yes" xml:space="preserve">
          <source>These values will be element-wise interpolated into the string.</source>
          <target state="translated">Эти значения будут интерполированы в строку по элементам.</target>
        </trans-unit>
        <trans-unit id="8f43e0b4384b8a2ab0accbd750c1e3d8364a7037" translate="yes" xml:space="preserve">
          <source>They are the standard vector/matrix/tensor type of numpy. Many numpy functions return arrays, not matrices.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d528fd04772fea95a1dd88b443f26490baf33962" translate="yes" xml:space="preserve">
          <source>Things are a little bit more tricky when combining reduction and allocated operands. Before iteration is started, any reduction operand must be initialized to its starting values. Here&amp;rsquo;s how we can do this, taking sums along the last axis of &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">С объединением сокращения и выделенных операндов все немного сложнее. Перед началом итерации любой операнд редукции должен быть инициализирован его начальными значениями. Вот как мы можем это сделать, взяв суммы по последней оси &lt;code&gt;a&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4d8c3ebfdc398f463f36600d7ef80c9d888a357d" translate="yes" xml:space="preserve">
          <source>Things become more complex when multidimensional arrays are indexed, particularly with multidimensional index arrays. These tend to be more unusual uses, but they are permitted, and they are useful for some problems. We&amp;rsquo;ll start with the simplest multidimensional case (using the array y from the previous examples):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="998943208ea6deef89245cfe0875a67c35f9b773" translate="yes" xml:space="preserve">
          <source>Think of &lt;a href=&quot;#numpy.linalg.multi_dot&quot;&gt;&lt;code&gt;multi_dot&lt;/code&gt;&lt;/a&gt; as:</source>
          <target state="translated">Думайте о &lt;a href=&quot;#numpy.linalg.multi_dot&quot;&gt; &lt;code&gt;multi_dot&lt;/code&gt; &lt;/a&gt; как о:</target>
        </trans-unit>
        <trans-unit id="80d13b605601d6c6ca920c19b73c5be17b635404" translate="yes" xml:space="preserve">
          <source>This 2-d averaging filter runs quickly because the loop is in C and the pointer computations are done only as needed. If the code above is compiled as a module &lt;code&gt;image&lt;/code&gt;, then a 2-d image, &lt;code&gt;img&lt;/code&gt;, can be filtered using this code very quickly using:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="269959a51cb8489ddd62f29ffab3f7d5a6b40d53" translate="yes" xml:space="preserve">
          <source>This Chapter attempts to explain the logic behind some of the new pieces of code. The purpose behind these explanations is to enable somebody to be able to understand the ideas behind the implementation somewhat more easily than just staring at the code. Perhaps in this way, the algorithms can be improved on, borrowed from, and/or optimized by more people.</source>
          <target state="translated">В этой главе мы попытаемся объяснить логику,лежащую в основе некоторых новых частей кода.Цель этих объяснений состоит в том,чтобы кому-то было легче понять идеи,стоящие за реализацией,нежели просто смотреть на код.Возможно,таким образом,алгоритмы могут быть улучшены,заимствованы и/или оптимизированы большим количеством людей.</target>
        </trans-unit>
        <trans-unit id="d6d4a7a2f523794d0b16e4b9b049698c812e64fd" translate="yes" xml:space="preserve">
          <source>This Subcommittee shall NOT make decisions about the direction, scope or technical direction of the Project.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e344df267f24877e3c878787dee0c7157b282950" translate="yes" xml:space="preserve">
          <source>This Subcommittee will have 5 members, 4 of whom will be current Council Members and 1 of whom will be external to the Steering Council. No more than 2 Subcommittee Members can report to one person through employment or contracting work (including the reportee, i.e. the reportee + 1 is the max). This avoids effective majorities resting on one person.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d8eb7804ceb212518c04178ca9353c5652cddc34" translate="yes" xml:space="preserve">
          <source>This address may be cached before the iteration loop, calling &lt;code&gt;iternext&lt;/code&gt; will not change it. The value itself may change during iteration, in particular if buffering is enabled. This function may be safely called without holding the Python GIL.</source>
          <target state="translated">Этот адрес может быть кэширован перед циклом итерации, вызов &lt;code&gt;iternext&lt;/code&gt; не изменит его. Само значение может измениться во время итерации, в частности, если включена буферизация. Эту функцию можно безопасно вызывать, не удерживая Python GIL.</target>
        </trans-unit>
        <trans-unit id="2dacb6ef0aabe4e0449ac2f7d6e826edb424af8c" translate="yes" xml:space="preserve">
          <source>This advanced indexing occurs when obj is an array object of Boolean type, such as may be returned from comparison operators. A single boolean index array is practically identical to &lt;code&gt;x[obj.nonzero()]&lt;/code&gt; where, as described above, &lt;a href=&quot;generated/numpy.ndarray.nonzero#numpy.ndarray.nonzero&quot;&gt;&lt;code&gt;obj.nonzero()&lt;/code&gt;&lt;/a&gt; returns a tuple (of length &lt;a href=&quot;generated/numpy.ndarray.ndim#numpy.ndarray.ndim&quot;&gt;&lt;code&gt;obj.ndim&lt;/code&gt;&lt;/a&gt;) of integer index arrays showing the &lt;code&gt;True&lt;/code&gt; elements of &lt;em&gt;obj&lt;/em&gt;. However, it is faster when &lt;code&gt;obj.shape == x.shape&lt;/code&gt;.</source>
          <target state="translated">Это расширенное индексирование происходит, когда obj является объектом массива логического типа, например, который может быть возвращен операторами сравнения. Одиночный массив логических индексов практически идентичен &lt;code&gt;x[obj.nonzero()]&lt;/code&gt; где, как описано выше, &lt;a href=&quot;generated/numpy.ndarray.nonzero#numpy.ndarray.nonzero&quot;&gt; &lt;code&gt;obj.nonzero()&lt;/code&gt; &lt;/a&gt; возвращает кортеж (длиной &lt;a href=&quot;generated/numpy.ndarray.ndim#numpy.ndarray.ndim&quot;&gt; &lt;code&gt;obj.ndim&lt;/code&gt; &lt;/a&gt; ) массивов целочисленных индексов, показывающий элементы &lt;code&gt;True&lt;/code&gt; объекта &lt;em&gt;obj&lt;/em&gt; . Однако это быстрее, если &lt;code&gt;obj.shape == x.shape&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="710121ccc37af7c57d603d19a46f2cadc801d4ee" translate="yes" xml:space="preserve">
          <source>This allows multithreading to fill large arrays in chunks using suitable BitGenerators in parallel.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af03503ddeac7c1214ea6c40abe67021cd6a3a66" translate="yes" xml:space="preserve">
          <source>This allows you to import the in-place built NumPy &lt;em&gt;from the repo base directory only&lt;/em&gt;. If you want the in-place build to be visible outside that base dir, you need to point your &lt;code&gt;PYTHONPATH&lt;/code&gt; environment variable to this directory. Some IDEs (&lt;a href=&quot;https://www.spyder-ide.org/&quot;&gt;Spyder&lt;/a&gt; for example) have utilities to manage &lt;code&gt;PYTHONPATH&lt;/code&gt;. On Linux and OSX, you can run the command:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a10be423c319c36683d60f03c4235ea58ef43ca" translate="yes" xml:space="preserve">
          <source>This also works for functions and other objects that &lt;strong&gt;you&lt;/strong&gt; create. Just remember to include a docstring with your function using a string literal (&lt;code&gt;&quot;&quot;&quot; &quot;&quot;&quot;&lt;/code&gt; or &lt;code&gt;''' '''&lt;/code&gt; around your documentation).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d1c39c0afd071dc6e571fc8d1273c278aad6faa3" translate="yes" xml:space="preserve">
          <source>This also works with 2D arrays! If you start with this array:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d160c6be16a498bbc805a56a17ad9724ae3c358b" translate="yes" xml:space="preserve">
          <source>This applies type promotion to all the inputs, using the NumPy rules for combining scalars and arrays, to determine the output type of a set of operands. This is the same result type that ufuncs produce. The specific algorithm used is as follows.</source>
          <target state="translated">Это применяет продвижение типа ко всем входам,используя правила NumPy для объединения скаляров и массивов,для определения типа выхода набора операндов.Это тот же тип результата,который производит ufuncs.Используемый конкретный алгоритм заключается в следующем.</target>
        </trans-unit>
        <trans-unit id="2e8bc0cbcc5f069a41dc6497b9c0a909fd514a44" translate="yes" xml:space="preserve">
          <source>This approach to the array interface allows for faster access to an array using only one attribute lookup and a well-defined C-structure.</source>
          <target state="translated">Такой подход к интерфейсу массива позволяет быстрее получить доступ к массиву,используя только один поиск атрибута и четко определенную C-структуру.</target>
        </trans-unit>
        <trans-unit id="b2cfa3868ca6d5d3eec71f613d2a281e952e696d" translate="yes" xml:space="preserve">
          <source>This approach to the interface consists of the object having an &lt;a href=&quot;#__array_interface__&quot;&gt;&lt;code&gt;__array_interface__&lt;/code&gt;&lt;/a&gt; attribute.</source>
          <target state="translated">Этот подход к интерфейсу состоит из объекта, имеющего атрибут &lt;a href=&quot;#__array_interface__&quot;&gt; &lt;code&gt;__array_interface__&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e27c7321ec2c09e2c1e41b0fb7ac933d7973957f" translate="yes" xml:space="preserve">
          <source>This arrangement allow for very flexible use of arrays. One thing that it allows is simple changes of the metadata to change the interpretation of the array buffer. Changing the byteorder of the array is a simple change involving no rearrangement of the data. The shape of the array can be changed very easily without changing anything in the data buffer or any data copying at all</source>
          <target state="translated">Такое расположение позволяет очень гибко использовать массивы.Одно из того,что она позволяет-это простое изменение метаданных для изменения интерпретации буфера массива.Изменение байт-порядка массива-это простое изменение,не требующее перестановки данных.Форма массива может быть изменена очень легко без изменения чего-либо в буфере данных или копирования данных вообще.</target>
        </trans-unit>
        <trans-unit id="13b0f80cc0af4acb749cdb54d3ae94021e334ad5" translate="yes" xml:space="preserve">
          <source>This array creation routine allows for the convenient creation of a new array matching an existing array&amp;rsquo;s shapes and memory layout, possibly changing the layout and/or data type.</source>
          <target state="translated">Эта процедура создания массива позволяет удобно создавать новый массив, соответствующий формам существующего массива и структуре памяти, возможно, изменяя макет и / или тип данных.</target>
        </trans-unit>
        <trans-unit id="b6ad81be881df54f2faa5255b14c490a53a2cd92" translate="yes" xml:space="preserve">
          <source>This array is a copy of some other array. The C-API function PyArray_ResolveWritebackIfCopy must be called before deallocating to the base array will be updated with the contents of this array.</source>
          <target state="translated">Этот массив является копией какого-то другого массива.Перед тем,как произойдет обновление транзакции к базовому массиву,необходимо вызвать C-API-функцию PyArray_ResolveWritebackIfCopy с содержимым этого массива.</target>
        </trans-unit>
        <trans-unit id="9975deeda2df7b42c75df625b9b5fc69426c2203" translate="yes" xml:space="preserve">
          <source>This array is stored in memory as 40 bytes, one after the other (known as a contiguous block of memory). The strides of an array tell us how many bytes we have to skip in memory to move to the next position along a certain axis. For example, we have to skip 4 bytes (1 value) to move to the next column, but 20 bytes (5 values) to get to the same position in the next row. As such, the strides for the array &lt;code&gt;x&lt;/code&gt; will be &lt;code&gt;(20, 4)&lt;/code&gt;.</source>
          <target state="translated">Этот массив хранится в памяти в виде 40 байтов, один за другим (известный как непрерывный блок памяти). Шаги массива говорят нам, сколько байтов мы должны пропустить в памяти, чтобы перейти к следующей позиции по определенной оси. Например, нам нужно пропустить 4 байта (1 значение), чтобы перейти к следующему столбцу, но 20 байтов (5 значений), чтобы перейти в ту же позицию в следующей строке. Таким образом, шаги для массива &lt;code&gt;x&lt;/code&gt; будут &lt;code&gt;(20, 4)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="38cb8241a835a683d594eee86aed4e56e6c6635d" translate="yes" xml:space="preserve">
          <source>This array is the mask for all &lt;a href=&quot;../generated/numpy.nditer#numpy.nditer&quot;&gt;&lt;code&gt;writemasked&lt;/code&gt;&lt;/a&gt; operands. Code uses the &lt;code&gt;writemasked&lt;/code&gt; flag which indicates that only elements where the chosen ARRAYMASK operand is True will be written to. In general, the iterator does not enforce this, it is up to the code doing the iteration to follow that promise.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ed5fe179d122dc6d0ff4af8af1bf207796107b0" translate="yes" xml:space="preserve">
          <source>This array is the mask for all &lt;a href=&quot;generated/numpy.nditer#numpy.nditer&quot;&gt;&lt;code&gt;writemasked&lt;/code&gt;&lt;/a&gt; operands. Code uses the &lt;code&gt;writemasked&lt;/code&gt; flag which indicates that only elements where the chosen ARRAYMASK operand is True will be written to. In general, the iterator does not enforce this, it is up to the code doing the iteration to follow that promise.</source>
          <target state="translated">Этот массив является маской для всех операндов с маской &lt;a href=&quot;generated/numpy.nditer#numpy.nditer&quot;&gt; &lt;code&gt;writemasked&lt;/code&gt; &lt;/a&gt; . Код использует флаг &lt;code&gt;writemasked&lt;/code&gt; , который указывает, что будут записаны только те элементы, в которых выбран операнд ARRAYMASK - True. Как правило, итератор не обеспечивает этого, это зависит от кода, выполняющего итерацию, чтобы выполнить это обещание.</target>
        </trans-unit>
        <trans-unit id="da76cf9484436ae5f595cbe33ce62d99eee348ae" translate="yes" xml:space="preserve">
          <source>This array is used in computing an N-d index from a 1-d index. It contains needed products of the dimensions.</source>
          <target state="translated">Этот массив используется при вычислении N-d индекса из 1-d индекса.Он содержит необходимые произведения размеров.</target>
        </trans-unit>
        <trans-unit id="2950d768bc15bd8305b22a36aa90ddcbd53411a1" translate="yes" xml:space="preserve">
          <source>This array method can be conveniently chained:</source>
          <target state="translated">Этот метод массива может быть удобно связан:</target>
        </trans-unit>
        <trans-unit id="cd59928fafb5b8b3afd2257d5348ff12e61a3751" translate="yes" xml:space="preserve">
          <source>This array must contain integers in &lt;code&gt;[0, n-1]&lt;/code&gt;, where &lt;code&gt;n&lt;/code&gt; is the number of choices, unless &lt;code&gt;mode=wrap&lt;/code&gt; or &lt;code&gt;mode=clip&lt;/code&gt;, in which cases any integers are permissible.</source>
          <target state="translated">Этот массив должен содержать целые числа в &lt;code&gt;[0, n-1]&lt;/code&gt; , где &lt;code&gt;n&lt;/code&gt; - количество вариантов, если только &lt;code&gt;mode=wrap&lt;/code&gt; или &lt;code&gt;mode=clip&lt;/code&gt; , и в этом случае допустимы любые целые числа.</target>
        </trans-unit>
        <trans-unit id="2801e85aeaae18790917a73e502d7026a3a34d08" translate="yes" xml:space="preserve">
          <source>This array must contain integers in &lt;code&gt;[0, n-1]&lt;/code&gt;, where n is the number of choices.</source>
          <target state="translated">Этот массив должен содержать целые числа в &lt;code&gt;[0, n-1]&lt;/code&gt; , где n - количество вариантов.</target>
        </trans-unit>
        <trans-unit id="7231182809746ea9e4a7a5bcc665f806413fd373" translate="yes" xml:space="preserve">
          <source>This assumes that you have forked &lt;a href=&quot;https://github.com/scipy/scipy.org&quot;&gt;https://github.com/scipy/scipy.org&lt;/a&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3397e055cb40235a1ae2818b229475b2582745a3" translate="yes" xml:space="preserve">
          <source>This attribute allows simple but flexible determination of which sub- type should be considered &amp;ldquo;primary&amp;rdquo; when an operation involving two or more sub-types arises. In operations where different sub-types are being used, the sub-type with the largest &lt;a href=&quot;../reference/arrays.classes#numpy.class.__array_priority__&quot;&gt;&lt;code&gt;__array_priority__&lt;/code&gt;&lt;/a&gt; attribute will determine the sub-type of the output(s). If two sub- types have the same &lt;a href=&quot;../reference/arrays.classes#numpy.class.__array_priority__&quot;&gt;&lt;code&gt;__array_priority__&lt;/code&gt;&lt;/a&gt; then the sub-type of the first argument determines the output. The default &lt;a href=&quot;../reference/arrays.classes#numpy.class.__array_priority__&quot;&gt;&lt;code&gt;__array_priority__&lt;/code&gt;&lt;/a&gt; attribute returns a value of 0.0 for the base ndarray type and 1.0 for a sub-type. This attribute can also be defined by objects that are not sub-types of the ndarray and can be used to determine which &lt;a href=&quot;../reference/arrays.classes#numpy.class.__array_wrap__&quot;&gt;&lt;code&gt;__array_wrap__&lt;/code&gt;&lt;/a&gt; method should be called for the return output.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="19820dc6931f03b4ce34d1e382ce5208e82ba583" translate="yes" xml:space="preserve">
          <source>This attribute can also be an object exposing the &lt;a href=&quot;https://docs.python.org/dev/c-api/objbuffer.html#c.PyObject_AsCharBuffer&quot;&gt;&lt;code&gt;buffer interface&lt;/code&gt;&lt;/a&gt; which will be used to share the data. If this key is not present (or returns &lt;code&gt;None&lt;/code&gt;), then memory sharing will be done through the buffer interface of the object itself. In this case, the offset key can be used to indicate the start of the buffer. A reference to the object exposing the array interface must be stored by the new object if the memory area is to be secured.</source>
          <target state="translated">Этот атрибут также может быть объектом, предоставляющим &lt;a href=&quot;https://docs.python.org/dev/c-api/objbuffer.html#c.PyObject_AsCharBuffer&quot;&gt; &lt;code&gt;buffer interface&lt;/code&gt; &lt;/a&gt; который будет использоваться для обмена данными. Если этот ключ отсутствует (или возвращает &lt;code&gt;None&lt;/code&gt; ), то совместное использование памяти будет осуществляться через интерфейс буфера самого объекта. В этом случае клавиша смещения может использоваться для указания начала буфера. Ссылка на объект, предоставляющий интерфейс массива, должна быть сохранена новым объектом, если область памяти должна быть защищена.</target>
        </trans-unit>
        <trans-unit id="357acc58797c34ec7ee3526baa5d4678b200c571" translate="yes" xml:space="preserve">
          <source>This attribute can also be an object exposing the &lt;code&gt;buffer interface&lt;/code&gt; which will be used to share the data. If this key is not present (or returns None), then memory sharing will be done through the buffer interface of the object itself. In this case, the offset key can be used to indicate the start of the buffer. A reference to the object exposing the array interface must be stored by the new object if the memory area is to be secured.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99486092092808fe1a7a3c63950908fb38dd3c25" translate="yes" xml:space="preserve">
          <source>This attribute creates an object that makes it easier to use arrays when calling shared libraries with the ctypes module. The returned object has, among others, data, shape, and strides attributes (see Notes below) which themselves return ctypes objects that can be used as arguments to a shared library.</source>
          <target state="translated">Данный атрибут создает объект,который упрощает использование массивов при вызове общих библиотек с модулем ctypes.Возвращаемый объект имеет,среди прочего,атрибуты данных,формы и шага (см.Примечания ниже),которые сами по себе возвращают объекты типа,которые могут быть использованы в качестве аргументов для разделяемой библиотеки.</target>
        </trans-unit>
        <trans-unit id="94f279541eccc23ec8d58b2be974fecc119fa4c7" translate="yes" xml:space="preserve">
          <source>This basic behavior can be augmented by passing a 2-tuple in as the file argument. The first element of the tuple should specify the relative path (under the package install directory) where the remaining sequence of files should be installed to (it has nothing to do with the file-names in the source distribution). The second element of the tuple is the sequence of files that should be installed. The files in this sequence can be filenames, relative paths, or absolute paths. For absolute paths the file will be installed in the top-level package installation directory (regardless of the first argument). Filenames and relative path names will be installed in the package install directory under the path name given as the first element of the tuple.</source>
          <target state="translated">Это основное поведение может быть дополнено передачей 2-фрагмента в качестве аргумента файла.Первый элемент кортежа должен указать относительный путь (под директорией установки пакета),куда должна быть установлена оставшаяся последовательность файлов (это не имеет никакого отношения к именам файлов в дистрибутиве исходников).Второй элемент кортежа-последовательность файлов,которые должны быть установлены.Файлы в этой последовательности могут быть именами файлов,относительными или абсолютными.Для абсолютных путей файл будет установлен в каталог установки пакета верхнего уровня (независимо от первого аргумента).Имена файлов и относительные пути будут устанавливаться в каталог установки пакета под именем пути,заданным в качестве первого элемента кортежа.</target>
        </trans-unit>
        <trans-unit id="38d8b59be8238ec40cd52d11a1691c2db5ac9b19" translate="yes" xml:space="preserve">
          <source>This broadcasting can also be achieved using the function &lt;a href=&quot;generated/numpy.ix_#numpy.ix_&quot;&gt;&lt;code&gt;ix_&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">Этого вещания также можно добиться с помощью функции &lt;a href=&quot;generated/numpy.ix_#numpy.ix_&quot;&gt; &lt;code&gt;ix_&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="040d755c45914cdad7e449ca2485bc004cd21eb5" translate="yes" xml:space="preserve">
          <source>This bug causes Python before 3.4 to not reliably show warnings again after they have been ignored once (even within catch_warnings). It means that no &amp;ldquo;ignore&amp;rdquo; filter can be used easily, since following tests might need to see the warning. Additionally it allows easier specificity for testing warnings and can be nested.</source>
          <target state="translated">Эта ошибка приводит к тому, что Python до 3.4 не показывает надежно снова предупреждения после того, как они были проигнорированы один раз (даже в пределах catch_warnings). Это означает, что нельзя легко использовать фильтр &amp;laquo;игнорировать&amp;raquo;, поскольку при следующих тестах может потребоваться увидеть предупреждение. Кроме того, он обеспечивает более легкую специфичность для тестирования предупреждений и может быть вложенным.</target>
        </trans-unit>
        <trans-unit id="b97776ec43283f6527b6b56ee297ecb07c0e7a5e" translate="yes" xml:space="preserve">
          <source>This builds NumPy first, so the first time it may take a few minutes. If you specify &lt;code&gt;-n&lt;/code&gt;, the tests are run against the version of NumPy (if any) found on current PYTHONPATH.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="25f8c2b712d454554ccb3b1572df7e3d85a8d6a8" translate="yes" xml:space="preserve">
          <source>This can be done via &lt;em&gt;interactive rebasing&lt;/em&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d1ccaf9367b320b45fde18f5d1b6d26c14c28d1" translate="yes" xml:space="preserve">
          <source>This can be used on multidimensional arrays too:</source>
          <target state="translated">Это можно использовать и на многомерных массивах:</target>
        </trans-unit>
        <trans-unit id="4619f696b33e2f5aafe4335faf3807d265baaeed" translate="yes" xml:space="preserve">
          <source>This can have multiple paragraphs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b0866e6d60c935d1c1a437309972ddf022e2bfb" translate="yes" xml:space="preserve">
          <source>This chapter will review many of the tools that are available for the purpose of accessing code written in other compiled languages. There are many resources available for learning to call other compiled libraries from Python and the purpose of this Chapter is not to make you an expert. The main goal is to make you aware of some of the possibilities so that you will know what to &amp;ldquo;Google&amp;rdquo; in order to learn more.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f7b07ef80d0cc13652d9fe61895de6904fd8ef60" translate="yes" xml:space="preserve">
          <source>This class implements the special methods for almost all of Python&amp;rsquo;s builtin operators defined in the &lt;a href=&quot;https://docs.python.org/dev/library/operator.html#module-operator&quot;&gt;&lt;code&gt;operator&lt;/code&gt;&lt;/a&gt; module, including comparisons (&lt;code&gt;==&lt;/code&gt;, &lt;code&gt;&amp;gt;&lt;/code&gt;, etc.) and arithmetic (&lt;code&gt;+&lt;/code&gt;, &lt;code&gt;*&lt;/code&gt;, &lt;code&gt;-&lt;/code&gt;, etc.), by deferring to the &lt;code&gt;__array_ufunc__&lt;/code&gt; method, which subclasses must implement.</source>
          <target state="translated">Этот класс реализует специальные методы почти для всех встроенных операторов Python, определенных в модуле &lt;a href=&quot;https://docs.python.org/dev/library/operator.html#module-operator&quot;&gt; &lt;code&gt;operator&lt;/code&gt; &lt;/a&gt; , включая сравнения ( &lt;code&gt;==&lt;/code&gt; , &lt;code&gt;&amp;gt;&lt;/code&gt; и т. Д.) И арифметические &lt;code&gt;__array_ufunc__&lt;/code&gt; ( &lt;code&gt;+&lt;/code&gt; , &lt;code&gt;*&lt;/code&gt; , &lt;code&gt;-&lt;/code&gt; и т. Д.), Путем обращения к методу __array_ufunc__ , какие подклассы должны быть реализованы.</target>
        </trans-unit>
        <trans-unit id="cbc453ece1fc4bcfba8a214ebb68dae3ad49689e" translate="yes" xml:space="preserve">
          <source>This class is provided for numarray backward-compatibility. New code (not concerned with numarray compatibility) should use arrays of type &lt;code&gt;string_&lt;/code&gt; or &lt;code&gt;unicode_&lt;/code&gt; and use the free functions in &lt;code&gt;numpy.char&lt;/code&gt; for fast vectorized string operations instead.</source>
          <target state="translated">Этот класс предоставляется для обратной совместимости numarray. Новый код (не связанный с совместимостью с numarray) должен использовать массивы типа &lt;code&gt;string_&lt;/code&gt; или &lt;code&gt;unicode_&lt;/code&gt; и вместо этого использовать бесплатные функции в &lt;code&gt;numpy.char&lt;/code&gt; для быстрых векторизованных строковых операций.</target>
        </trans-unit>
        <trans-unit id="817afa6aa8358446cc6150c81d202fd10664d253" translate="yes" xml:space="preserve">
          <source>This class isn&amp;rsquo;t very useful, because it has the same constructor as the bare ndarray object, including passing in buffers and shapes and so on. We would probably prefer the constructor to be able to take an already formed ndarray from the usual numpy calls to &lt;code&gt;np.array&lt;/code&gt; and return an object.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="547d58e17f08661cffe0028727466b3bfecb1f09" translate="yes" xml:space="preserve">
          <source>This class may at some point be turned into a factory function which returns a view into an mmap buffer.</source>
          <target state="translated">Этот класс в какой-то момент может быть превращен в заводскую функцию,которая возвращает вид в буфер mmap.</target>
        </trans-unit>
        <trans-unit id="9f0e2bd2c54e1831a429118c49099c40d4fc6a31" translate="yes" xml:space="preserve">
          <source>This code can be compiled and linked into an extension module named filter using:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="051a76f1d3dcebdcceb5b6a498f248ede74e08da" translate="yes" xml:space="preserve">
          <source>This code has a significant amount of error handling. Note the &lt;code&gt;SWIG_fail&lt;/code&gt; is a macro for &lt;code&gt;goto fail&lt;/code&gt;, referring to the label at line 28. If the user provides the wrong number of arguments, this will be caught at line 10. If construction of the NumPy array fails or produces an array with the wrong number of dimensions, these errors are caught at line 17. And finally, if an error is detected, memory is still managed correctly at line 30.</source>
          <target state="translated">Этот код содержит значительную часть обработки ошибок. Обратите внимание, что &lt;code&gt;SWIG_fail&lt;/code&gt; - это макрос для &lt;code&gt;goto fail&lt;/code&gt; , ссылающийся на метку в строке 28. Если пользователь предоставляет неправильное количество аргументов, это будет зафиксировано в строке 10. Если построение массива NumPy завершится неудачно или создаст массив с неправильным числа измерений, эти ошибки фиксируются в строке 17. И, наконец, если ошибка обнаружена, память по-прежнему управляется правильно в строке 30.</target>
        </trans-unit>
        <trans-unit id="3999b914a2658c99b5fe639f3ab379867f2570ac" translate="yes" xml:space="preserve">
          <source>This code is not exhaustive or complete. It serves to distill our common understanding of a collaborative, shared environment and goals. Please try to follow this code in spirit as much as in letter, to create a friendly and productive environment that enriches the surrounding community.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc2f712a7c05e996ac3e38345d45b7f3d7e23038" translate="yes" xml:space="preserve">
          <source>This code loads the shared library named &lt;code&gt;code.{ext}&lt;/code&gt; located in the same path as this file. It then adds a return type of void to the functions contained in the library. It also adds argument checking to the functions in the library so that ndarrays can be passed as the first three arguments along with an integer (large enough to hold a pointer on the platform) as the fourth argument.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="533c867c6a351c2be81a48161bc93203ea12c76d" translate="yes" xml:space="preserve">
          <source>This code of conduct applies to all spaces managed by the NumPy project, including all public and private mailing lists, issue trackers, wikis, blogs, Twitter, and any other communication channel used by our community. The NumPy project does not organise in-person events, however events related to our community should have a code of conduct similar in spirit to this one.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cff208b4a7eacc934c607e5c41003491618977d7" translate="yes" xml:space="preserve">
          <source>This code of conduct should be honored by everyone who participates in the NumPy community formally or informally, or claims any affiliation with the project, in any project-related activities and especially when representing the project, in any role.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f194434e38b3846c0fd28dc955d7908e8501694" translate="yes" xml:space="preserve">
          <source>This command builds (see &lt;code&gt;-c&lt;/code&gt; flag, execute &lt;code&gt;python -m numpy.f2py&lt;/code&gt; without arguments to see the explanation of command line options) an extension module &lt;code&gt;fib1.so&lt;/code&gt; (see &lt;code&gt;-m&lt;/code&gt; flag) to the current directory. Now, in Python the Fortran subroutine &lt;code&gt;FIB&lt;/code&gt; is accessible via &lt;code&gt;fib1.fib&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bbb1615a9d0e074d0b52d81da555b5659d5320b3" translate="yes" xml:space="preserve">
          <source>This command leaves a file named add.{ext} in the current directory (where {ext} is the appropriate extension for a python extension module on your platform &amp;mdash; so, pyd, &lt;em&gt;etc.&lt;/em&gt; ). This module may then be imported from Python. It will contain a method for each subroutine in add (zadd, cadd, dadd, sadd). The docstring of each method contains information about how the module method may be called:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b8208674ec726acd6f311802a0a4f9952791f4b6" translate="yes" xml:space="preserve">
          <source>This command leaves the file add.pyf in the current directory. The section of this file corresponding to zadd is:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e0a485b84958d1031e7018c2536aa8e72a66489" translate="yes" xml:space="preserve">
          <source>This condition is broadcast over the input. At locations where the condition is True, the &lt;code&gt;out&lt;/code&gt; array will be set to the ufunc result. Elsewhere, the &lt;code&gt;out&lt;/code&gt; array will retain its original value. Note that if an uninitialized &lt;code&gt;out&lt;/code&gt; array is created via the default &lt;code&gt;out=None&lt;/code&gt;, locations within it where the condition is False will remain uninitialized.</source>
          <target state="translated">Это условие транслируется по входу. В местах, где условие истинно, массив &lt;code&gt;out&lt;/code&gt; будет установлен на результат ufunc. В другом &lt;code&gt;out&lt;/code&gt; массив out сохранит свое исходное значение. Обратите внимание , что если инициализирован &lt;code&gt;out&lt;/code&gt; массива создается по умолчанию &lt;code&gt;out=None&lt;/code&gt; , места в нем , где условие ложно будет оставаться инициализирован.</target>
        </trans-unit>
        <trans-unit id="ee4c6c49dffb551e0984368af8f98c122bd3ccfb" translate="yes" xml:space="preserve">
          <source>This constructor can be compared to &lt;code&gt;empty&lt;/code&gt;: it creates a new record array but does not fill it with data. To create a record array from data, use one of the following methods:</source>
          <target state="translated">Этот конструктор можно сравнить с &lt;code&gt;empty&lt;/code&gt; : он создает новый массив записей, но не заполняет его данными. Чтобы создать массив записей из данных, используйте один из следующих методов:</target>
        </trans-unit>
        <trans-unit id="33c942d2092f2a81aa60d19a082d10077f5b892d" translate="yes" xml:space="preserve">
          <source>This constructor creates the array, using &lt;code&gt;buffer&lt;/code&gt; (with &lt;code&gt;offset&lt;/code&gt; and &lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/reference/generated/numpy.chararray.strides.html#numpy.chararray.strides&quot;&gt;&lt;code&gt;strides&lt;/code&gt;&lt;/a&gt;) if it is not &lt;code&gt;None&lt;/code&gt;. If &lt;code&gt;buffer&lt;/code&gt; is &lt;code&gt;None&lt;/code&gt;, then constructs a new array with &lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/reference/generated/numpy.chararray.strides.html#numpy.chararray.strides&quot;&gt;&lt;code&gt;strides&lt;/code&gt;&lt;/a&gt; in &amp;ldquo;C order&amp;rdquo;, unless both &lt;code&gt;len(shape) &amp;gt;= 2&lt;/code&gt; and &lt;code&gt;order='Fortran'&lt;/code&gt;, in which case &lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/reference/generated/numpy.chararray.strides.html#numpy.chararray.strides&quot;&gt;&lt;code&gt;strides&lt;/code&gt;&lt;/a&gt; is in &amp;ldquo;Fortran order&amp;rdquo;.</source>
          <target state="translated">Этот конструктор создает массив, используя &lt;code&gt;buffer&lt;/code&gt; (со &lt;code&gt;offset&lt;/code&gt; и &lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/reference/generated/numpy.chararray.strides.html#numpy.chararray.strides&quot;&gt; &lt;code&gt;strides&lt;/code&gt; &lt;/a&gt; ), если он не равен &lt;code&gt;None&lt;/code&gt; . Если &lt;code&gt;buffer&lt;/code&gt; равен &lt;code&gt;None&lt;/code&gt; , то строит новый массив с &lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/reference/generated/numpy.chararray.strides.html#numpy.chararray.strides&quot;&gt; &lt;code&gt;strides&lt;/code&gt; &lt;/a&gt; в &amp;laquo;порядке C&amp;raquo;, если только &lt;code&gt;len(shape) &amp;gt;= 2&lt;/code&gt; и &lt;code&gt;order='Fortran'&lt;/code&gt; , и в этом случае &lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/reference/generated/numpy.chararray.strides.html#numpy.chararray.strides&quot;&gt; &lt;code&gt;strides&lt;/code&gt; &lt;/a&gt; находятся в &amp;laquo;порядке Fortran&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="953bdd8047346bccedc501390c7ed7305dc6711a" translate="yes" xml:space="preserve">
          <source>This constructor creates the array, using &lt;code&gt;buffer&lt;/code&gt; (with &lt;code&gt;offset&lt;/code&gt; and &lt;a href=&quot;numpy.char.chararray.strides#numpy.char.chararray.strides&quot;&gt;&lt;code&gt;strides&lt;/code&gt;&lt;/a&gt;) if it is not &lt;code&gt;None&lt;/code&gt;. If &lt;code&gt;buffer&lt;/code&gt; is &lt;code&gt;None&lt;/code&gt;, then constructs a new array with &lt;a href=&quot;numpy.char.chararray.strides#numpy.char.chararray.strides&quot;&gt;&lt;code&gt;strides&lt;/code&gt;&lt;/a&gt; in &amp;ldquo;C order&amp;rdquo;, unless both &lt;code&gt;len(shape) &amp;gt;= 2&lt;/code&gt; and &lt;code&gt;order='F'&lt;/code&gt;, in which case &lt;a href=&quot;numpy.char.chararray.strides#numpy.char.chararray.strides&quot;&gt;&lt;code&gt;strides&lt;/code&gt;&lt;/a&gt; is in &amp;ldquo;Fortran order&amp;rdquo;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="244906121f35fcb6808baef572df1faf5ecac2b9" translate="yes" xml:space="preserve">
          <source>This constructor creates the array, using &lt;code&gt;buffer&lt;/code&gt; (with &lt;code&gt;offset&lt;/code&gt; and &lt;a href=&quot;numpy.char.chararray.strides#numpy.char.chararray.strides&quot;&gt;&lt;code&gt;strides&lt;/code&gt;&lt;/a&gt;) if it is not &lt;code&gt;None&lt;/code&gt;. If &lt;code&gt;buffer&lt;/code&gt; is &lt;code&gt;None&lt;/code&gt;, then constructs a new array with &lt;a href=&quot;numpy.char.chararray.strides#numpy.char.chararray.strides&quot;&gt;&lt;code&gt;strides&lt;/code&gt;&lt;/a&gt; in &amp;ldquo;C order&amp;rdquo;, unless both &lt;code&gt;len(shape) &amp;gt;= 2&lt;/code&gt; and &lt;code&gt;order='Fortran'&lt;/code&gt;, in which case &lt;a href=&quot;numpy.char.chararray.strides#numpy.char.chararray.strides&quot;&gt;&lt;code&gt;strides&lt;/code&gt;&lt;/a&gt; is in &amp;ldquo;Fortran order&amp;rdquo;.</source>
          <target state="translated">Этот конструктор создает массив, используя &lt;code&gt;buffer&lt;/code&gt; (со &lt;code&gt;offset&lt;/code&gt; и &lt;a href=&quot;numpy.char.chararray.strides#numpy.char.chararray.strides&quot;&gt; &lt;code&gt;strides&lt;/code&gt; &lt;/a&gt; ), если он не равен &lt;code&gt;None&lt;/code&gt; . Если &lt;code&gt;buffer&lt;/code&gt; равен &lt;code&gt;None&lt;/code&gt; , то строит новый массив с &lt;a href=&quot;numpy.char.chararray.strides#numpy.char.chararray.strides&quot;&gt; &lt;code&gt;strides&lt;/code&gt; &lt;/a&gt; в &amp;laquo;порядке C&amp;raquo;, если только &lt;code&gt;len(shape) &amp;gt;= 2&lt;/code&gt; и &lt;code&gt;order='Fortran'&lt;/code&gt; , и в этом случае &lt;a href=&quot;numpy.char.chararray.strides#numpy.char.chararray.strides&quot;&gt; &lt;code&gt;strides&lt;/code&gt; &lt;/a&gt; находятся в &amp;laquo;порядке Fortran&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="472735a82ef7af1ec4165da8f5b7c128444159de" translate="yes" xml:space="preserve">
          <source>This constructor creates the array, using &lt;code&gt;buffer&lt;/code&gt; (with &lt;code&gt;offset&lt;/code&gt; and &lt;a href=&quot;numpy.chararray.strides#numpy.chararray.strides&quot;&gt;&lt;code&gt;strides&lt;/code&gt;&lt;/a&gt;) if it is not &lt;code&gt;None&lt;/code&gt;. If &lt;code&gt;buffer&lt;/code&gt; is &lt;code&gt;None&lt;/code&gt;, then constructs a new array with &lt;a href=&quot;numpy.chararray.strides#numpy.chararray.strides&quot;&gt;&lt;code&gt;strides&lt;/code&gt;&lt;/a&gt; in &amp;ldquo;C order&amp;rdquo;, unless both &lt;code&gt;len(shape) &amp;gt;= 2&lt;/code&gt; and &lt;code&gt;order='F'&lt;/code&gt;, in which case &lt;a href=&quot;numpy.chararray.strides#numpy.chararray.strides&quot;&gt;&lt;code&gt;strides&lt;/code&gt;&lt;/a&gt; is in &amp;ldquo;Fortran order&amp;rdquo;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="25eee032d6ea1636789f057c08bed3526280036b" translate="yes" xml:space="preserve">
          <source>This could then be registered to convert doubles to floats using the code:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a5986918bf935c1ed16d4421ab17b1ade1eafe40" translate="yes" xml:space="preserve">
          <source>This declares that the corresponding argument depends on the values of variables in the list &lt;code&gt;&amp;lt;names&amp;gt;&lt;/code&gt;. For example, &lt;code&gt;&amp;lt;init_expr&amp;gt;&lt;/code&gt; may use the values of other arguments. Using information given by &lt;code&gt;depend(..)&lt;/code&gt; attributes, F2PY ensures that arguments are initialized in a proper order. If &lt;code&gt;depend(..)&lt;/code&gt; attribute is not used then F2PY determines dependence relations automatically. Use &lt;code&gt;depend()&lt;/code&gt; to disable dependence relations generated by F2PY.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c221f7f1dff9c4b5017181532f28da44b16fcb82" translate="yes" xml:space="preserve">
          <source>This decorator can be used to filter DeprecationWarning&amp;rsquo;s, to avoid printing them during the test suite run, while checking that the test actually raises a DeprecationWarning.</source>
          <target state="translated">Этот декоратор можно использовать для фильтрации DeprecationWarning, чтобы избежать их печати во время выполнения набора тестов, одновременно проверяя, действительно ли тест вызывает DeprecationWarning.</target>
        </trans-unit>
        <trans-unit id="50d52a319d15baa1479e649a743cee7e5d09023b" translate="yes" xml:space="preserve">
          <source>This decorator can&amp;rsquo;t use the nose namespace, because it can be called from a non-test module. See also &lt;code&gt;istest&lt;/code&gt; and &lt;code&gt;nottest&lt;/code&gt; in &lt;code&gt;nose.tools&lt;/code&gt;.</source>
          <target state="translated">Этот декоратор не может использовать пространство имен носа, потому что его можно вызвать из не тестового модуля. См. Также &lt;code&gt;istest&lt;/code&gt; и &lt;code&gt;nottest&lt;/code&gt; в программе &lt;code&gt;nose.tools&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="67fd7e1d7456c74a698475b7f144fadff01137fb" translate="yes" xml:space="preserve">
          <source>This default iterator selects a sub-array of dimension</source>
          <target state="translated">Этот итератор по умолчанию выбирает подмассив размером</target>
        </trans-unit>
        <trans-unit id="cfb9c1da992a1d1aaddfb397e6c91ff1039b17da" translate="yes" xml:space="preserve">
          <source>This default threshold is designed to detect rank deficiency accounting for the numerical errors of the SVD computation. Imagine that there is a column in &lt;code&gt;M&lt;/code&gt; that is an exact (in floating point) linear combination of other columns in &lt;code&gt;M&lt;/code&gt;. Computing the SVD on &lt;code&gt;M&lt;/code&gt; will not produce a singular value exactly equal to 0 in general: any difference of the smallest SVD value from 0 will be caused by numerical imprecision in the calculation of the SVD. Our threshold for small SVD values takes this numerical imprecision into account, and the default threshold will detect such numerical rank deficiency. The threshold may declare a matrix &lt;code&gt;M&lt;/code&gt; rank deficient even if the linear combination of some columns of &lt;code&gt;M&lt;/code&gt; is not exactly equal to another column of &lt;code&gt;M&lt;/code&gt; but only numerically very close to another column of &lt;code&gt;M&lt;/code&gt;.</source>
          <target state="translated">Этот порог по умолчанию предназначен для обнаружения дефицита ранга с учетом численных ошибок вычисления SVD. Представьте , что существует столбец в &lt;code&gt;M&lt;/code&gt; , который является точным (с плавающей точкой) линейной комбинацией других столбцов &lt;code&gt;M&lt;/code&gt; . Вычисление SVD на &lt;code&gt;M&lt;/code&gt; не даст сингулярного значения, точно равного 0: любое отличие наименьшего значения SVD от 0 будет вызвано числовой неточностью в вычислении SVD. Наш порог для малых значений SVD учитывает эту числовую неточность, а порог по умолчанию обнаруживает такой числовой дефицит ранга. Порог может объявить матрицу &lt;code&gt;M&lt;/code&gt; с недостаточным рангом, даже если линейная комбинация некоторых столбцов &lt;code&gt;M&lt;/code&gt; не в точности равна другой колонке &lt;code&gt;M&lt;/code&gt; , но только численно очень близко к другой колонке &lt;code&gt;M&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b6968499a16ad7614bdea90ae8f3aad570e0c60e" translate="yes" xml:space="preserve">
          <source>This document describes the syntax and best practices for docstrings used with the numpydoc extension for &lt;a href=&quot;http://sphinx-doc.org/&quot;&gt;Sphinx&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b45b65ecc52b644a63152b28ad1bde6a3a5e1f70" translate="yes" xml:space="preserve">
          <source>This document gives coding conventions for the C code comprising the C implementation of NumPy. Note, rules are there to be broken. Two good reasons to break a particular rule:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c3b557b3201940ffcbe7e57b7ac3945729bb630" translate="yes" xml:space="preserve">
          <source>This document itself was written in ReStructuredText. &lt;a href=&quot;#example&quot;&gt;An example&lt;/a&gt; of the format shown here is available.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2007e99c49141c98bee8b2f4b8b703b1ff66930c" translate="yes" xml:space="preserve">
          <source>This does not compute the usual correlation: if op2 is larger than op1, the arguments are swapped, and the conjugate is never taken for complex arrays. See PyArray_Correlate2 for the usual signal processing correlation.</source>
          <target state="translated">Это не вычисляет обычную корреляцию:если op2 больше op1,то аргументы меняются,а конъюгат никогда не принимается за сложные массивы.См.PyArray_Correlate2 для обычной корреляции обработки сигналов.</target>
        </trans-unit>
        <trans-unit id="2ac0e7432126a7d32cb5b22ed347524b29026575" translate="yes" xml:space="preserve">
          <source>This enables the iterator to reason about data dependency, possibly avoiding unnecessary copies.</source>
          <target state="translated">Это позволяет итератору рассуждать о зависимости от данных,возможно,избегая лишних копий.</target>
        </trans-unit>
        <trans-unit id="fb73eae3981c0a0cbcb09d6d3ccfc761b4660a9a" translate="yes" xml:space="preserve">
          <source>This example makes use of Python 3 &lt;a href=&quot;https://docs.python.org/dev/library/concurrent.futures.html#module-concurrent.futures&quot;&gt;&lt;code&gt;concurrent.futures&lt;/code&gt;&lt;/a&gt; to fill an array using multiple threads. Threads are long-lived so that repeated calls do not require any additional overheads from thread creation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff3d50ffaaf1fbc724fd92676a9a6bf2dd386440" translate="yes" xml:space="preserve">
          <source>This example makes use of Python 3 &lt;a href=&quot;https://docs.python.org/dev/library/concurrent.futures.html#module-concurrent.futures&quot;&gt;&lt;code&gt;concurrent.futures&lt;/code&gt;&lt;/a&gt; to fill an array using multiple threads. Threads are long-lived so that repeated calls do not require any additional overheads from thread creation. The underlying BitGenerator is &lt;code&gt;PCG64&lt;/code&gt; which is fast, has a long period and supports using &lt;code&gt;PCG64.jumped&lt;/code&gt; to return a new generator while advancing the state. The random numbers generated are reproducible in the sense that the same seed will produce the same outputs.</source>
          <target state="translated">В этом примере используется Python 3 &lt;a href=&quot;https://docs.python.org/dev/library/concurrent.futures.html#module-concurrent.futures&quot;&gt; &lt;code&gt;concurrent.futures&lt;/code&gt; &lt;/a&gt; для заполнения массива с использованием нескольких потоков. Потоки долговечны, поэтому повторные вызовы не требуют дополнительных затрат на создание потоков. Базовый BitGenerator - это &lt;code&gt;PCG64&lt;/code&gt; , который работает быстро, имеет длительный период и поддерживает использование &lt;code&gt;PCG64.jumped&lt;/code&gt; для возврата нового генератора при продвижении состояния. Сгенерированные случайные числа воспроизводимы в том смысле, что одно и то же начальное число будет давать одинаковые результаты.</target>
        </trans-unit>
        <trans-unit id="40004ca036e22114daf23d8e12216a484254a12b" translate="yes" xml:space="preserve">
          <source>This example shows how &lt;code&gt;converters&lt;/code&gt; can be used to convert a field with a trailing minus sign into a negative number.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b788d751d6a8b5a6ea3f2e12485a26037e6ed998" translate="yes" xml:space="preserve">
          <source>This example shows how numba can be used to produce Box-Muller normals using a pure Python implementation which is then compiled. The random numbers are provided by &lt;code&gt;ctypes.next_double&lt;/code&gt;.</source>
          <target state="translated">Этот пример показывает, как numba можно использовать для создания нормалей Box-Muller с использованием чистой реализации Python, которая затем компилируется. Случайные числа предоставляются &lt;code&gt;ctypes.next_double&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c43d650067bf3f7811ad3426eb67449ba8f8d778" translate="yes" xml:space="preserve">
          <source>This example shows how numba can be used to produce gaussian samples using a pure Python implementation which is then compiled. The random numbers are provided by &lt;code&gt;ctypes.next_double&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="21f8a7f3cdbbf2fa9d3bdab5400251540901f919" translate="yes" xml:space="preserve">
          <source>This example shows how to create a ufunc for a structured array dtype. For the example we show a trivial ufunc for adding two arrays with dtype &amp;lsquo;u8,u8,u8&amp;rsquo;. The process is a bit different from the other examples since a call to &lt;a href=&quot;../reference/c-api/ufunc#c.PyUFunc_FromFuncAndData&quot;&gt;&lt;code&gt;PyUFunc_FromFuncAndData&lt;/code&gt;&lt;/a&gt; doesn&amp;rsquo;t fully register ufuncs for custom dtypes and structured array dtypes. We need to also call &lt;a href=&quot;../reference/c-api/ufunc#c.PyUFunc_RegisterLoopForDescr&quot;&gt;&lt;code&gt;PyUFunc_RegisterLoopForDescr&lt;/code&gt;&lt;/a&gt; to finish setting up the ufunc.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f7280fcf983a91daf5dc16e89c6643dc47e38c1" translate="yes" xml:space="preserve">
          <source>This example shows that a negative value can be returned when the input is an array of signed integers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="15659709a5e32bf1f77ae2078941bf91dc0f1586" translate="yes" xml:space="preserve">
          <source>This example uses a temporary file so that doctest doesn&amp;rsquo;t write files to your directory. You would use a &amp;lsquo;normal&amp;rsquo; filename.</source>
          <target state="translated">В этом примере используется временный файл, поэтому doctest не записывает файлы в ваш каталог. Вы должны использовать &amp;laquo;обычное&amp;raquo; имя файла.</target>
        </trans-unit>
        <trans-unit id="c6a6109259025b3790be906b9d5fd08b4a7ddd22" translate="yes" xml:space="preserve">
          <source>This explanation of &lt;code&gt;fmt&lt;/code&gt; is not complete, for an exhaustive specification see &lt;a href=&quot;#r672d4d5b6143-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt;.</source>
          <target state="translated">Это объяснение &lt;code&gt;fmt&lt;/code&gt; не является полным; исчерпывающую спецификацию см. &lt;a href=&quot;#r672d4d5b6143-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c6f060f066c80d886f242a9ad00dc6b69ec16949" translate="yes" xml:space="preserve">
          <source>This feature lets you make local decisions about when and how to split up streams without coordination between processes. You do not have to preallocate space to avoid overlapping or request streams from a common global service. This general &amp;ldquo;tree-hashing&amp;rdquo; scheme is &lt;a href=&quot;https://www.iro.umontreal.ca/~lecuyer/myftp/papers/parallel-rng-imacs.pdf&quot;&gt;not unique to numpy&lt;/a&gt; but not yet widespread. Python has increasingly-flexible mechanisms for parallelization available, and this scheme fits in very well with that kind of use.</source>
          <target state="translated">Эта функция позволяет вам принимать локальные решения о том, когда и как разделять потоки без координации между процессами. Вам не нужно заранее выделять пространство, чтобы избежать перекрытия или запросов потоков от общей глобальной службы. Эта общая схема &amp;laquo;древовидного хеширования&amp;raquo; &lt;a href=&quot;https://www.iro.umontreal.ca/~lecuyer/myftp/papers/parallel-rng-imacs.pdf&quot;&gt;не уникальна для numpy,&lt;/a&gt; но еще не получила широкого распространения. В Python доступны все более гибкие механизмы распараллеливания, и эта схема очень хорошо подходит для такого использования.</target>
        </trans-unit>
        <trans-unit id="1eaab0e05e888941195d61599512548e7a521f9d" translate="yes" xml:space="preserve">
          <source>This file contains a walkthrough of the NumPy 1.14.5 release on Linux, modified for building on azure and uploading to anaconda.org The commands can be copied into the command line, but be sure to replace 1.14.5 by the correct version.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bbd2bf0596d8530c916e2a9e88d889eff818ebc6" translate="yes" xml:space="preserve">
          <source>This file gives an overview of what is necessary to build binary releases for NumPy.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="482a4249cfca9480f9fad090626bdeb4f2b9945b" translate="yes" xml:space="preserve">
          <source>This file is installed to the package installation directory.</source>
          <target state="translated">Этот файл устанавливается в каталог установки пакетов.</target>
        </trans-unit>
        <trans-unit id="53df6470e0b1cc077e937e47a1974181b9abe4c8" translate="yes" xml:space="preserve">
          <source>This flag can only be used with &lt;a href=&quot;#c.NPY_ITER_EXTERNAL_LOOP&quot;&gt;&lt;code&gt;NPY_ITER_EXTERNAL_LOOP&lt;/code&gt;&lt;/a&gt; when &lt;a href=&quot;#c.NPY_ITER_BUFFERED&quot;&gt;&lt;code&gt;NPY_ITER_BUFFERED&lt;/code&gt;&lt;/a&gt; is enabled. This is because without buffering, the inner loop is always the size of the innermost iteration dimension, and allowing it to get cut up would require special handling, effectively making it more like the buffered version.</source>
          <target state="translated">Этот флаг может использоваться только с &lt;a href=&quot;#c.NPY_ITER_EXTERNAL_LOOP&quot;&gt; &lt;code&gt;NPY_ITER_EXTERNAL_LOOP&lt;/code&gt; ,&lt;/a&gt; когда &lt;a href=&quot;#c.NPY_ITER_BUFFERED&quot;&gt; &lt;code&gt;NPY_ITER_BUFFERED&lt;/code&gt; &lt;/a&gt; включен. Это связано с тем, что без буферизации внутренний цикл всегда имеет размер самого внутреннего измерения итерации, и для того, чтобы его разрезать, потребовалась бы особая обработка, что фактически сделало бы его более похожим на буферизованную версию.</target>
        </trans-unit>
        <trans-unit id="b15ae805eec5e668ba73f9b0b01c1bc16e63444d" translate="yes" xml:space="preserve">
          <source>This flag has effect only if &lt;code&gt;NPY_ITER_COPY_IF_OVERLAP&lt;/code&gt; is enabled on the iterator.</source>
          <target state="translated">Этот флаг действует, только если на итераторе включен &lt;code&gt;NPY_ITER_COPY_IF_OVERLAP&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9da2bfdfbda0e7663b5a969172c32a000741b205" translate="yes" xml:space="preserve">
          <source>This flag is incompatible with &lt;a href=&quot;#c.NPY_ITER_C_INDEX&quot;&gt;&lt;code&gt;NPY_ITER_C_INDEX&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#c.NPY_ITER_F_INDEX&quot;&gt;&lt;code&gt;NPY_ITER_F_INDEX&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;#c.NPY_ITER_MULTI_INDEX&quot;&gt;&lt;code&gt;NPY_ITER_MULTI_INDEX&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Этот флаг несовместим с &lt;a href=&quot;#c.NPY_ITER_C_INDEX&quot;&gt; &lt;code&gt;NPY_ITER_C_INDEX&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#c.NPY_ITER_F_INDEX&quot;&gt; &lt;code&gt;NPY_ITER_F_INDEX&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;#c.NPY_ITER_MULTI_INDEX&quot;&gt; &lt;code&gt;NPY_ITER_MULTI_INDEX&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f18364f6e6e63625675c7a8e617237459cb62263" translate="yes" xml:space="preserve">
          <source>This flag is true if the underlying array is &lt;a href=&quot;array#c.NPY_ARRAY_C_CONTIGUOUS&quot;&gt;&lt;code&gt;NPY_ARRAY_C_CONTIGUOUS&lt;/code&gt;&lt;/a&gt;. It is used to simplify calculations when possible.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dded0adeb2bd9373f814af71190afe223e5d417b" translate="yes" xml:space="preserve">
          <source>This flag is true if the underlying array is &lt;a href=&quot;c-api.array#c.NPY_ARRAY_C_CONTIGUOUS&quot;&gt;&lt;code&gt;NPY_ARRAY_C_CONTIGUOUS&lt;/code&gt;&lt;/a&gt;. It is used to simplify calculations when possible.</source>
          <target state="translated">Этот флаг истинен, если базовый массив - &lt;a href=&quot;c-api.array#c.NPY_ARRAY_C_CONTIGUOUS&quot;&gt; &lt;code&gt;NPY_ARRAY_C_CONTIGUOUS&lt;/code&gt; &lt;/a&gt; . По возможности используется для упрощения расчетов.</target>
        </trans-unit>
        <trans-unit id="8bd5458653c4b0d4b9801dcf72f3813b331fc2dd" translate="yes" xml:space="preserve">
          <source>This flag is useful for arrays that must be in C-contiguous order and aligned. These kinds of arrays are usually input arrays for some algorithm.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="174700adc5b2ef69a266d85c159fde8b55bae281" translate="yes" xml:space="preserve">
          <source>This flag is useful to specify an array that is in C-contiguous order, is aligned, and can be written to as well. Such an array is usually returned as output (although normally such output arrays are created from scratch).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5677601b0eb842974f94991fa89b82f29f0accae" translate="yes" xml:space="preserve">
          <source>This flag is useful to specify an array that will be used for both input and output. &lt;a href=&quot;../reference/c-api/array#c.PyArray_ResolveWritebackIfCopy&quot;&gt;&lt;code&gt;PyArray_ResolveWritebackIfCopy&lt;/code&gt;&lt;/a&gt; must be called before &lt;a href=&quot;https://docs.python.org/dev/c-api/refcounting.html#c.Py_DECREF&quot;&gt;&lt;code&gt;Py_DECREF&lt;/code&gt;&lt;/a&gt; at the end of the interface routine to write back the temporary data into the original array passed in. Use of the &lt;a href=&quot;../reference/c-api/array#c.NPY_ARRAY_WRITEBACKIFCOPY&quot;&gt;&lt;code&gt;NPY_ARRAY_WRITEBACKIFCOPY&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../reference/c-api/array#c.NPY_ARRAY_UPDATEIFCOPY&quot;&gt;&lt;code&gt;NPY_ARRAY_UPDATEIFCOPY&lt;/code&gt;&lt;/a&gt; flags requires that the input object is already an array (because other objects cannot be automatically updated in this fashion). If an error occurs use &lt;a href=&quot;../reference/c-api/array#c.PyArray_DiscardWritebackIfCopy&quot;&gt;&lt;code&gt;PyArray_DiscardWritebackIfCopy&lt;/code&gt;&lt;/a&gt; (obj) on an array with these flags set. This will set the underlying base array writable without causing the contents to be copied back into the original array.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e07be9168d02cb1629420a221f75d6ebada0e23c" translate="yes" xml:space="preserve">
          <source>This flag only affects writing from the buffer back to the array. This means that if the operand is also &lt;a href=&quot;#c.NPY_ITER_READWRITE&quot;&gt;&lt;code&gt;NPY_ITER_READWRITE&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#c.NPY_ITER_WRITEONLY&quot;&gt;&lt;code&gt;NPY_ITER_WRITEONLY&lt;/code&gt;&lt;/a&gt;, code doing iteration can write to this operand to control which elements will be untouched and which ones will be modified. This is useful when the mask should be a combination of input masks.</source>
          <target state="translated">Этот флаг влияет только на запись из буфера обратно в массив. Это означает, что если операнд также является &lt;a href=&quot;#c.NPY_ITER_READWRITE&quot;&gt; &lt;code&gt;NPY_ITER_READWRITE&lt;/code&gt; &lt;/a&gt; или &lt;a href=&quot;#c.NPY_ITER_WRITEONLY&quot;&gt; &lt;code&gt;NPY_ITER_WRITEONLY&lt;/code&gt; &lt;/a&gt; , код, выполняющий итерацию, может писать в этот операнд, чтобы контролировать, какие элементы будут нетронутыми, а какие будут изменены. Это полезно, когда маска должна быть комбинацией масок ввода.</target>
        </trans-unit>
        <trans-unit id="61e9f59feb262d0f073bfa393f7c68aa5599a46b" translate="yes" xml:space="preserve">
          <source>This form also makes it possible to specify struct dtypes with overlapping fields, functioning like the &amp;lsquo;union&amp;rsquo; type in C. This usage is discouraged, however, and the union mechanism is preferred.</source>
          <target state="translated">Эта форма также позволяет указывать типы структур с перекрывающимися полями, действуя как тип &amp;laquo;объединение&amp;raquo; в C. Однако такое использование не рекомендуется, и предпочтительным является механизм объединения.</target>
        </trans-unit>
        <trans-unit id="0d302c80ebc9e23237f250ea17213abaf97a46db" translate="yes" xml:space="preserve">
          <source>This form is discouraged because Python dictionaries do not preserve order in Python versions before Python 3.6, and the order of the fields in a structured dtype has meaning. &lt;a href=&quot;#titles&quot;&gt;Field Titles&lt;/a&gt; may be specified by using a 3-tuple, see below.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="55ceb45713d06ac7d3696f87a18d50201d0b6641" translate="yes" xml:space="preserve">
          <source>This function &lt;strong&gt;steals a reference&lt;/strong&gt; to &lt;code&gt;obj&lt;/code&gt; and sets it as the base property of &lt;code&gt;arr&lt;/code&gt;.</source>
          <target state="translated">Эта функция &lt;strong&gt;крадет ссылку&lt;/strong&gt; на &lt;code&gt;obj&lt;/code&gt; и устанавливает ее как базовое свойство &lt;code&gt;arr&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d09c0732b811d51b99b90004b51ceb77de43b711" translate="yes" xml:space="preserve">
          <source>This function &lt;strong&gt;steals a reference&lt;/strong&gt; to &lt;code&gt;op&lt;/code&gt; and makes sure that &lt;code&gt;op&lt;/code&gt; is a base-class ndarray. It special cases array scalars, but otherwise calls &lt;a href=&quot;#c.PyArray_FromAny&quot;&gt;&lt;code&gt;PyArray_FromAny&lt;/code&gt;&lt;/a&gt; ( &lt;code&gt;op&lt;/code&gt;, NULL, 0, 0, &lt;a href=&quot;#c.NPY_ARRAY_ENSUREARRAY&quot;&gt;&lt;code&gt;NPY_ARRAY_ENSUREARRAY&lt;/code&gt;&lt;/a&gt;, NULL).</source>
          <target state="translated">Эта функция &lt;strong&gt;крадет ссылку&lt;/strong&gt; на &lt;code&gt;op&lt;/code&gt; и проверяет, является ли &lt;code&gt;op&lt;/code&gt; ndarray базового класса. Это особые случаи скаляров массива, но иначе вызывает &lt;a href=&quot;#c.PyArray_FromAny&quot;&gt; &lt;code&gt;PyArray_FromAny&lt;/code&gt; &lt;/a&gt; ( &lt;code&gt;op&lt;/code&gt; , NULL, 0, 0, &lt;a href=&quot;#c.NPY_ARRAY_ENSUREARRAY&quot;&gt; &lt;code&gt;NPY_ARRAY_ENSUREARRAY&lt;/code&gt; &lt;/a&gt; , NULL).</target>
        </trans-unit>
        <trans-unit id="39a0c64e238756c013e69a01cf344f4e1849a8a1" translate="yes" xml:space="preserve">
          <source>This function accepts but discards arguments &lt;code&gt;bias&lt;/code&gt; and &lt;code&gt;ddof&lt;/code&gt;. This is for backwards compatibility with previous versions of this function. These arguments had no effect on the return values of the function and can be safely ignored in this and previous versions of numpy.</source>
          <target state="translated">Эта функция принимает, но отбрасывает аргументы &lt;code&gt;bias&lt;/code&gt; и &lt;code&gt;ddof&lt;/code&gt; . Это сделано для обратной совместимости с предыдущими версиями этой функции. Эти аргументы не повлияли на возвращаемые значения функции и могут быть проигнорированы в этой и предыдущих версиях numpy.</target>
        </trans-unit>
        <trans-unit id="f2fa4598ed049a537ca6f0801826008a1fe6bde0" translate="yes" xml:space="preserve">
          <source>This function aims to be a fast reader for simply formatted files. The &lt;a href=&quot;numpy.genfromtxt#numpy.genfromtxt&quot;&gt;&lt;code&gt;genfromtxt&lt;/code&gt;&lt;/a&gt; function provides more sophisticated handling of, e.g., lines with missing values.</source>
          <target state="translated">Эта функция предназначена для быстрого чтения файлов с простым форматированием. Функция &lt;a href=&quot;numpy.genfromtxt#numpy.genfromtxt&quot;&gt; &lt;code&gt;genfromtxt&lt;/code&gt; &lt;/a&gt; обеспечивает более сложную обработку, например, строк с пропущенными значениями.</target>
        </trans-unit>
        <trans-unit id="ff21c5d7fbe80ce59f5b300cd13fc6a4fc144e9d" translate="yes" xml:space="preserve">
          <source>This function allows one set of bins to be computed, and reused across multiple histograms:</source>
          <target state="translated">Эта функция позволяет вычислить один набор бинов и повторно использовать его на нескольких гистограммах:</target>
        </trans-unit>
        <trans-unit id="8a2a88415c2050cb4cd9564db4ec54b1d4908d16" translate="yes" xml:space="preserve">
          <source>This function allows the user to register a 1-d loop with an already- created ufunc to be used whenever the ufunc is called with any of its input arguments as the user-defined data-type. This is needed in order to make ufuncs work with built-in data-types. The data-type must have been previously registered with the numpy system. The loop is passed in as &lt;em&gt;function&lt;/em&gt;. This loop can take arbitrary data which should be passed in as &lt;em&gt;data&lt;/em&gt;. The data-types the loop requires are passed in as &lt;em&gt;arg_types&lt;/em&gt; which must be a pointer to memory at least as large as ufunc-&amp;gt;nargs.</source>
          <target state="translated">Эта функция позволяет пользователю зарегистрировать 1-мерный цикл с уже созданным ufunc, который будет использоваться всякий раз, когда ufunc вызывается с любым из его входных аргументов в качестве определяемого пользователем типа данных. Это необходимо для того, чтобы ufuncs работал со встроенными типами данных. Тип данных должен быть ранее зарегистрирован в системе numpy. Цикл передается как &lt;em&gt;функция&lt;/em&gt; . Этот цикл может принимать произвольные данные, которые следует передавать как &lt;em&gt;данные&lt;/em&gt; . Типы данных, которые требуются циклу, передаются как &lt;em&gt;arg_types,&lt;/em&gt; которые должны быть указателем на память размером не менее ufunc-&amp;gt; nargs.</target>
        </trans-unit>
        <trans-unit id="f1576babab462c2253d07a719792b0ff878bb525" translate="yes" xml:space="preserve">
          <source>This function allows you to alter the tp_str and tp_repr methods of the array object to any Python function. Thus you can alter what happens for all arrays when str(arr) or repr(arr) is called from Python. The function to be called is passed in as &lt;em&gt;op&lt;/em&gt;. If &lt;em&gt;repr&lt;/em&gt; is non-zero, then this function will be called in response to repr(arr), otherwise the function will be called in response to str(arr). No check on whether or not &lt;em&gt;op&lt;/em&gt; is callable is performed. The callable passed in to &lt;em&gt;op&lt;/em&gt; should expect an array argument and should return a string to be printed.</source>
          <target state="translated">Эта функция позволяет вам изменять методы tp_str и tp_repr объекта массива на любую функцию Python. Таким образом, вы можете изменить то, что происходит для всех массивов, когда str (arr) или repr (arr) вызывается из Python. Вызываемая функция передается как &lt;em&gt;op&lt;/em&gt; . Если &lt;em&gt;repr&lt;/em&gt; не равно нулю, тогда эта функция будет вызываться в ответ на repr (arr), в противном случае функция будет вызываться в ответ на str (arr). Никакая проверка того, является ли &lt;em&gt;op&lt;/em&gt; вызываемым, не выполняется. Вызываемый объект, переданный в &lt;em&gt;op,&lt;/em&gt; должен ожидать аргумент массива и должен возвращать строку для печати.</target>
        </trans-unit>
        <trans-unit id="3bb2d31f5b88cf1b316b3ceb02135e04993b15e9" translate="yes" xml:space="preserve">
          <source>This function assigns from the old to the new array by name, so the value of a field in the output array is the value of the field with the same name in the source array. This has the effect of creating a new ndarray containing only the fields &amp;ldquo;required&amp;rdquo; by the required_dtype.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="12c8f95658bf6b7edc09d3adda4d0c4816cea136" translate="yes" xml:space="preserve">
          <source>This function behaves like PyUFunc_RegisterLoopForType above, except that it allows the user to register a 1-d loop using PyArray_Descr objects instead of dtype type num values. This allows a 1-d loop to be registered for structured array data-dtypes and custom data-types instead of scalar data-types.</source>
          <target state="translated">Эта функция ведет себя как PyUFunc_RegisterLoopForType выше,за исключением того,что она позволяет пользователю регистрировать 1-d цикл,используя объекты PyArray_Descr вместо значений типа d type num.Это позволяет регистрировать 1-d цикл для типов данных структурированных массивов и пользовательских типов данных вместо скалярных типов данных.</target>
        </trans-unit>
        <trans-unit id="e6245a8e454db1361715a92d11f03ae0bff098bc" translate="yes" xml:space="preserve">
          <source>This function can be exponentially slow for some inputs, unless &lt;code&gt;max_work&lt;/code&gt; is set to a finite number or &lt;code&gt;MAY_SHARE_BOUNDS&lt;/code&gt;. If in doubt, use &lt;a href=&quot;numpy.may_share_memory#numpy.may_share_memory&quot;&gt;&lt;code&gt;numpy.may_share_memory&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="71ac25efd0c9fb7e70f813509afc2d6139c57b07" translate="yes" xml:space="preserve">
          <source>This function changes the fill value of the masked array &lt;code&gt;a&lt;/code&gt; in place. If &lt;code&gt;a&lt;/code&gt; is not a masked array, the function returns silently, without doing anything.</source>
          <target state="translated">Эта функция изменяет значение заполнения замаскированного массива &lt;code&gt;a&lt;/code&gt; на месте. Если &lt;code&gt;a&lt;/code&gt; не является замаскированным массивом, функция возвращается молча, ничего не делая.</target>
        </trans-unit>
        <trans-unit id="dc2a1bc44c01911d64ceae9284770c887ff15ab1" translate="yes" xml:space="preserve">
          <source>This function checks to see if &lt;em&gt;arr&lt;/em&gt; is a 0-dimensional array and, if so, returns the appropriate array scalar. It should be used whenever 0-dimensional arrays could be returned to Python.</source>
          <target state="translated">Эта функция проверяет, является ли &lt;em&gt;arr&lt;/em&gt; 0-мерным массивом, и, если да, возвращает соответствующий скаляр массива. Его следует использовать всякий раз, когда 0-мерные массивы могут быть возвращены в Python.</target>
        </trans-unit>
        <trans-unit id="6e0d86a376dbbcdcd20b9ab0ced8ac2eae8ffe8a" translate="yes" xml:space="preserve">
          <source>This function computes the &lt;em&gt;N&lt;/em&gt;-dimensional discrete Fourier Transform over any number of axes in an &lt;em&gt;M&lt;/em&gt;-dimensional array by means of the Fast Fourier Transform (FFT).</source>
          <target state="translated">Эта функция вычисляет &lt;em&gt;N-&lt;/em&gt; мерное дискретное преобразование Фурье по любому количеству осей в &lt;em&gt;M-&lt;/em&gt; мерном массиве с помощью быстрого преобразования Фурье (БПФ).</target>
        </trans-unit>
        <trans-unit id="f34d917f1e7128a56a07b81dc929875f904b8a8c" translate="yes" xml:space="preserve">
          <source>This function computes the &lt;em&gt;n&lt;/em&gt;-dimensional discrete Fourier Transform over any axes in an &lt;em&gt;M&lt;/em&gt;-dimensional array by means of the Fast Fourier Transform (FFT). By default, the transform is computed over the last two axes of the input array, i.e., a 2-dimensional FFT.</source>
          <target state="translated">Эта функция вычисляет &lt;em&gt;n-&lt;/em&gt; мерное дискретное преобразование Фурье по любым осям в &lt;em&gt;M&lt;/em&gt; -мерном массиве с помощью быстрого преобразования Фурье (БПФ). По умолчанию преобразование вычисляется по двум последним осям входного массива, т. Е. Двухмерному БПФ.</target>
        </trans-unit>
        <trans-unit id="b8915bccc6bfc2e5b959f002fb985788d011a64f" translate="yes" xml:space="preserve">
          <source>This function computes the N-dimensional discrete Fourier Transform over any number of axes in an M-dimensional real array by means of the Fast Fourier Transform (FFT). By default, all axes are transformed, with the real transform performed over the last axis, while the remaining transforms are complex.</source>
          <target state="translated">Эта функция вычисляет N-мерное дискретное преобразование Фурье по любому числу осей в M-мерном реальном массиве с помощью Быстрого преобразования Фурье (БПФ).По умолчанию преобразуются все оси,при этом реальное преобразование выполняется по последней оси,а остальные преобразования являются комплексными.</target>
        </trans-unit>
        <trans-unit id="b8c7b22438d176337766fd2e49c4b7cfc3e07bab" translate="yes" xml:space="preserve">
          <source>This function computes the correlation as generally defined in signal processing texts:</source>
          <target state="translated">Эта функция вычисляет корреляцию,как это обычно определяется в текстах обработки сигналов:</target>
        </trans-unit>
        <trans-unit id="cd6ec7a4da9a308e6c6acab0d22d9735b9865d50" translate="yes" xml:space="preserve">
          <source>This function computes the inverse of the 2-dimensional discrete Fourier Transform over any number of axes in an M-dimensional array by means of the Fast Fourier Transform (FFT). In other words, &lt;code&gt;ifft2(fft2(a)) == a&lt;/code&gt; to within numerical accuracy. By default, the inverse transform is computed over the last two axes of the input array.</source>
          <target state="translated">Эта функция вычисляет обратное к двумерному дискретному преобразованию Фурье по любому количеству осей в M-мерном массиве с помощью быстрого преобразования Фурье (БПФ). Другими словами, &lt;code&gt;ifft2(fft2(a)) == a&lt;/code&gt; с точностью до числового значения. По умолчанию обратное преобразование вычисляется по двум последним осям входного массива.</target>
        </trans-unit>
        <trans-unit id="1a4ebaf525beaf877d17151690d3a34bb9c59baf" translate="yes" xml:space="preserve">
          <source>This function computes the inverse of the N-dimensional discrete Fourier Transform for real input over any number of axes in an M-dimensional array by means of the Fast Fourier Transform (FFT). In other words, &lt;code&gt;irfftn(rfftn(a), a.shape) == a&lt;/code&gt; to within numerical accuracy. (The &lt;code&gt;a.shape&lt;/code&gt; is necessary like &lt;code&gt;len(a)&lt;/code&gt; is for &lt;a href=&quot;numpy.fft.irfft#numpy.fft.irfft&quot;&gt;&lt;code&gt;irfft&lt;/code&gt;&lt;/a&gt;, and for the same reason.)</source>
          <target state="translated">Эта функция вычисляет обратное значение N-мерного дискретного преобразования Фурье для реального ввода по любому количеству осей в M-мерном массиве с помощью быстрого преобразования Фурье (БПФ). Другими словами, &lt;code&gt;irfftn(rfftn(a), a.shape) == a&lt;/code&gt; с точностью до числового значения. ( &lt;code&gt;a.shape&lt;/code&gt; необходим, как и &lt;code&gt;len(a)&lt;/code&gt; для &lt;a href=&quot;numpy.fft.irfft#numpy.fft.irfft&quot;&gt; &lt;code&gt;irfft&lt;/code&gt; &lt;/a&gt; , и по той же причине.)</target>
        </trans-unit>
        <trans-unit id="0c7a0cee522d4ce9c957b628834b82e1d28defa5" translate="yes" xml:space="preserve">
          <source>This function computes the inverse of the N-dimensional discrete Fourier Transform over any number of axes in an M-dimensional array by means of the Fast Fourier Transform (FFT). In other words, &lt;code&gt;ifftn(fftn(a)) == a&lt;/code&gt; to within numerical accuracy. For a description of the definitions and conventions used, see &lt;a href=&quot;../routines.fft#module-numpy.fft&quot;&gt;&lt;code&gt;numpy.fft&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Эта функция вычисляет обратное к N-мерному дискретному преобразованию Фурье по любому количеству осей в M-мерном массиве с помощью быстрого преобразования Фурье (БПФ). Другими словами, &lt;code&gt;ifftn(fftn(a)) == a&lt;/code&gt; с точностью до числового значения. Описание используемых определений и соглашений см. На &lt;a href=&quot;../routines.fft#module-numpy.fft&quot;&gt; &lt;code&gt;numpy.fft&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b2f9d73633ea8b8eb82a0685fcd08ea3505d9a66" translate="yes" xml:space="preserve">
          <source>This function computes the inverse of the one-dimensional &lt;em&gt;n&lt;/em&gt;-point discrete Fourier Transform of real input computed by &lt;a href=&quot;numpy.fft.rfft#numpy.fft.rfft&quot;&gt;&lt;code&gt;rfft&lt;/code&gt;&lt;/a&gt;. In other words, &lt;code&gt;irfft(rfft(a), len(a)) == a&lt;/code&gt; to within numerical accuracy. (See Notes below for why &lt;code&gt;len(a)&lt;/code&gt; is necessary here.)</source>
          <target state="translated">Эта функция вычисляет обратное к одномерному &lt;em&gt;n-&lt;/em&gt; точечному дискретному преобразованию Фурье реальных входных данных, вычисленному с помощью &lt;a href=&quot;numpy.fft.rfft#numpy.fft.rfft&quot;&gt; &lt;code&gt;rfft&lt;/code&gt; &lt;/a&gt; . Другими словами, &lt;code&gt;irfft(rfft(a), len(a)) == a&lt;/code&gt; с точностью до числового значения. (См. Примечания ниже, чтобы узнать, почему здесь необходим &lt;code&gt;len(a)&lt;/code&gt; .)</target>
        </trans-unit>
        <trans-unit id="35acba32b3eea01535885b216d423da5ad809ed9" translate="yes" xml:space="preserve">
          <source>This function computes the inverse of the one-dimensional &lt;em&gt;n&lt;/em&gt;-point discrete Fourier transform computed by &lt;a href=&quot;numpy.fft.fft#numpy.fft.fft&quot;&gt;&lt;code&gt;fft&lt;/code&gt;&lt;/a&gt;. In other words, &lt;code&gt;ifft(fft(a)) == a&lt;/code&gt; to within numerical accuracy. For a general description of the algorithm and definitions, see &lt;a href=&quot;../routines.fft#module-numpy.fft&quot;&gt;&lt;code&gt;numpy.fft&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Эта функция вычисляет обратное к одномерному &lt;em&gt;n-&lt;/em&gt; точечному дискретному преобразованию Фурье, вычисленному функцией &lt;a href=&quot;numpy.fft.fft#numpy.fft.fft&quot;&gt; &lt;code&gt;fft&lt;/code&gt; &lt;/a&gt; . Другими словами, &lt;code&gt;ifft(fft(a)) == a&lt;/code&gt; с точностью до числового значения. Для общего описания алгоритма и определений см. &lt;a href=&quot;../routines.fft#module-numpy.fft&quot;&gt; &lt;code&gt;numpy.fft&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ad9d7d69d57ac9facd5b4f82ac6ba6f908913a31" translate="yes" xml:space="preserve">
          <source>This function computes the one-dimensional &lt;em&gt;n&lt;/em&gt;-point discrete Fourier Transform (DFT) of a real-valued array by means of an efficient algorithm called the Fast Fourier Transform (FFT).</source>
          <target state="translated">Эта функция вычисляет одномерное &lt;em&gt;n-&lt;/em&gt; точечное дискретное преобразование Фурье (ДПФ) вещественного массива с помощью эффективного алгоритма, называемого быстрым преобразованием Фурье (БПФ).</target>
        </trans-unit>
        <trans-unit id="68ec181d19ee1190284573e044b4ba392f94f385" translate="yes" xml:space="preserve">
          <source>This function computes the one-dimensional &lt;em&gt;n&lt;/em&gt;-point discrete Fourier Transform (DFT) with the efficient Fast Fourier Transform (FFT) algorithm [CT].</source>
          <target state="translated">Эта функция вычисляет одномерное &lt;em&gt;n-&lt;/em&gt; точечное дискретное преобразование Фурье (ДПФ) с помощью эффективного алгоритма быстрого преобразования Фурье (БПФ) [CT].</target>
        </trans-unit>
        <trans-unit id="30a498de56241e50f5fd1a10939273e87357615d" translate="yes" xml:space="preserve">
          <source>This function continues to be supported for backward compatibility, but you should prefer &lt;a href=&quot;numpy.moveaxis#numpy.moveaxis&quot;&gt;&lt;code&gt;moveaxis&lt;/code&gt;&lt;/a&gt;. The &lt;a href=&quot;numpy.moveaxis#numpy.moveaxis&quot;&gt;&lt;code&gt;moveaxis&lt;/code&gt;&lt;/a&gt; function was added in NumPy 1.11.</source>
          <target state="translated">Эта функция по-прежнему поддерживается для обратной совместимости, но вам следует предпочесть &lt;a href=&quot;numpy.moveaxis#numpy.moveaxis&quot;&gt; &lt;code&gt;moveaxis&lt;/code&gt; &lt;/a&gt; . Функция &lt;a href=&quot;numpy.moveaxis#numpy.moveaxis&quot;&gt; &lt;code&gt;moveaxis&lt;/code&gt; &lt;/a&gt; была добавлена ​​в NumPy 1.11.</target>
        </trans-unit>
        <trans-unit id="307209890a37b51bcd317c1d8679c25cf8cf32dc" translate="yes" xml:space="preserve">
          <source>This function creates a new neighborhood iterator from an existing iterator. The neighborhood will be computed relatively to the position currently pointed by &lt;em&gt;iter&lt;/em&gt;, the bounds define the shape of the neighborhood iterator, and the mode argument the boundaries handling mode.</source>
          <target state="translated">Эта функция создает новый итератор окрестности из существующего итератора. Окрестность будет вычисляться относительно позиции, на которую в данный момент указывает &lt;em&gt;iter&lt;/em&gt; , границы определяют форму итератора окрестности, а аргумент режима - режим обработки границ.</target>
        </trans-unit>
        <trans-unit id="33522609896e19e2c62ce4cc185c0f8e169d65db" translate="yes" xml:space="preserve">
          <source>This function does &lt;em&gt;not&lt;/em&gt; initialize the returned array; to do that use &lt;a href=&quot;numpy.zeros_like#numpy.zeros_like&quot;&gt;&lt;code&gt;zeros_like&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;numpy.ones_like#numpy.ones_like&quot;&gt;&lt;code&gt;ones_like&lt;/code&gt;&lt;/a&gt; instead. It may be marginally faster than the functions that do set the array values.</source>
          <target state="translated">Эта функция &lt;em&gt;не&lt;/em&gt; инициализирует возвращаемый массив; для этого используйте вместо этого &lt;a href=&quot;numpy.zeros_like#numpy.zeros_like&quot;&gt; &lt;code&gt;zeros_like&lt;/code&gt; &lt;/a&gt; или &lt;a href=&quot;numpy.ones_like#numpy.ones_like&quot;&gt; &lt;code&gt;ones_like&lt;/code&gt; &lt;/a&gt; . Это может быть немного быстрее, чем функции, которые устанавливают значения массива.</target>
        </trans-unit>
        <trans-unit id="0decc5010e2e82ceb19b7a45f9d7da5f4f237524" translate="yes" xml:space="preserve">
          <source>This function does &lt;em&gt;not&lt;/em&gt; initialize the returned array; to do that use &lt;code&gt;zeros_like&lt;/code&gt; or &lt;code&gt;ones_like&lt;/code&gt; instead. It may be marginally faster than the functions that do set the array values.</source>
          <target state="translated">Эта функция &lt;em&gt;не&lt;/em&gt; инициализирует возвращаемый массив; для этого используйте вместо этого &lt;code&gt;zeros_like&lt;/code&gt; или &lt;code&gt;ones_like&lt;/code&gt; . Это может быть немного быстрее, чем функции, которые устанавливают значения массива.</target>
        </trans-unit>
        <trans-unit id="960581e2e13399cd79a7bf3c883aeb7b8d2e979d" translate="yes" xml:space="preserve">
          <source>This function does not check the contents of the input, only that the type is MaskType. In particular, this function returns False if the mask has a flexible dtype.</source>
          <target state="translated">Эта функция не проверяет содержимое входа,а только то,что тип MaskType.В частности,эта функция возвращает False,если маска имеет гибкий d-тип.</target>
        </trans-unit>
        <trans-unit id="0a232150acd8a12e027d94aeed56f5ff4aae9f46" translate="yes" xml:space="preserve">
          <source>This function does not enforce that the blocks lie on a fixed grid. &lt;code&gt;np.block([[a, b], [c, d]])&lt;/code&gt; is not restricted to arrays of the form:</source>
          <target state="translated">Эта функция не требует, чтобы блоки лежали на фиксированной сетке. &lt;code&gt;np.block([[a, b], [c, d]])&lt;/code&gt; не ограничивается массивами формы:</target>
        </trans-unit>
        <trans-unit id="6dc40074e04bdcad2b344dd285961cdc7ff85df9" translate="yes" xml:space="preserve">
          <source>This function does not losslessly round-trip in either direction.</source>
          <target state="translated">Эта функция не позволяет без потерь совершать кругосветное путешествие в любом направлении.</target>
        </trans-unit>
        <trans-unit id="b71c712d42350c6a8a0c257c490e077558876dad" translate="yes" xml:space="preserve">
          <source>This function encapsulates the broadcasting rules. The &lt;em&gt;mit&lt;/em&gt; container should already contain iterators for all the arrays that need to be broadcast. On return, these iterators will be adjusted so that iteration over each simultaneously will accomplish the broadcasting. A negative number is returned if an error occurs.</source>
          <target state="translated">Эта функция инкапсулирует правила вещания. &lt;em&gt;Мит&lt;/em&gt; контейнер должен уже содержать итераторы для всех массивов , которые должны быть вещания. По возвращении эти итераторы будут настроены так, чтобы итерация по каждому одновременно выполняла широковещательную передачу. Отрицательное число возвращается, если возникает ошибка.</target>
        </trans-unit>
        <trans-unit id="9bf48997cebca64928a72fe75ea6eb1ebc70dbfb" translate="yes" xml:space="preserve">
          <source>This function handles NaN comparisons as if NaN was a &amp;ldquo;normal&amp;rdquo; number. That is, AssertionError is not raised if both objects have NaNs in the same positions. This is in contrast to the IEEE standard on NaNs, which says that NaN compared to anything must return False.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b02f77dc9fbab1956d3050387654fd71594ea916" translate="yes" xml:space="preserve">
          <source>This function handles NaN comparisons as if NaN was a &amp;ldquo;normal&amp;rdquo; number. That is, no assertion is raised if both objects have NaNs in the same positions. This is in contrast to the IEEE standard on NaNs, which says that NaN compared to anything must return False.</source>
          <target state="translated">Эта функция обрабатывает сравнения NaN, как если бы NaN было &amp;laquo;нормальным&amp;raquo; числом. То есть утверждение не возникает, если оба объекта имеют NaN в одинаковых позициях. Это контрастирует со стандартом IEEE для NaN, который говорит, что NaN по сравнению с чем-либо должен возвращать False.</target>
        </trans-unit>
        <trans-unit id="d5f910d97d6aeb7075f641616a02d523dd4438a4" translate="yes" xml:space="preserve">
          <source>This function has been deprecated. Use randint instead.</source>
          <target state="translated">Эта функция была устарела.Вместо этого используйте randint.</target>
        </trans-unit>
        <trans-unit id="77fe5df00c0c7c8132af4661573c5a4cca000d13" translate="yes" xml:space="preserve">
          <source>This function has to be used with extreme care, see notes.</source>
          <target state="translated">Эту функцию следует использовать с особой осторожностью,см.примечания.</target>
        </trans-unit>
        <trans-unit id="eade9f90c736ff6d6151ab5c5bf1151931416ec5" translate="yes" xml:space="preserve">
          <source>This function instead copies &amp;ldquo;by field name&amp;rdquo;, such that fields in the dst are assigned from the identically named field in the src. This applies recursively for nested structures. This is how structure assignment worked in numpy &amp;gt;= 1.6 to &amp;lt;= 1.13.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="965a01bc9232ab2e9c3c470747ee3c2312761abb" translate="yes" xml:space="preserve">
          <source>This function is a compatibility alias for tobytes.</source>
          <target state="translated">Эта функция является псевдонимом совместимости для тобайтов.</target>
        </trans-unit>
        <trans-unit id="a3014854fc3aff1db547e25e4accc358bdc45e8a" translate="yes" xml:space="preserve">
          <source>This function is a compatibility alias for tobytes. Despite its name it returns bytes not strings.</source>
          <target state="translated">Эта функция является псевдонимом совместимости для тобайтов.Несмотря на свое название,она возвращает байты,а не строки.</target>
        </trans-unit>
        <trans-unit id="5bced6280c853e5763696660107e62b1e9050b26" translate="yes" xml:space="preserve">
          <source>This function is a shortcut to &lt;code&gt;mask_rowcols&lt;/code&gt; with &lt;code&gt;axis&lt;/code&gt; equal to 0.</source>
          <target state="translated">Эта функция является ярлыком для &lt;code&gt;mask_rowcols&lt;/code&gt; с &lt;code&gt;axis&lt;/code&gt; равной 0.</target>
        </trans-unit>
        <trans-unit id="892aad8c63a29b7082fcd31d81f9eafb9d342e8e" translate="yes" xml:space="preserve">
          <source>This function is a shortcut to &lt;code&gt;mask_rowcols&lt;/code&gt; with &lt;code&gt;axis&lt;/code&gt; equal to 1.</source>
          <target state="translated">Эта функция является ярлыком для &lt;code&gt;mask_rowcols&lt;/code&gt; с &lt;code&gt;axis&lt;/code&gt; равной 1.</target>
        </trans-unit>
        <trans-unit id="ebac1dd8653756fd79c832147de01fce0d7f87ae" translate="yes" xml:space="preserve">
          <source>This function is a shortcut to &lt;code&gt;masked_where&lt;/code&gt;, with &lt;code&gt;condition&lt;/code&gt; = (x != value).</source>
          <target state="translated">Эта функция является ярлыком для &lt;code&gt;masked_where&lt;/code&gt; с &lt;code&gt;condition&lt;/code&gt; = (x! = Значение).</target>
        </trans-unit>
        <trans-unit id="ab411b054ab6959d52991c7253cba72df24e6757" translate="yes" xml:space="preserve">
          <source>This function is a shortcut to &lt;code&gt;masked_where&lt;/code&gt;, with &lt;code&gt;condition&lt;/code&gt; = (x &amp;gt; value).</source>
          <target state="translated">Эта функция является ярлыком для &lt;code&gt;masked_where&lt;/code&gt; с &lt;code&gt;condition&lt;/code&gt; = (x&amp;gt; value).</target>
        </trans-unit>
        <trans-unit id="bf30dbf11727720fe8d30e29bf375cde077485f8" translate="yes" xml:space="preserve">
          <source>This function is a shortcut to &lt;code&gt;masked_where&lt;/code&gt;, with &lt;code&gt;condition&lt;/code&gt; = (x &amp;gt;= value).</source>
          <target state="translated">Эта функция является ярлыком для &lt;code&gt;masked_where&lt;/code&gt; с &lt;code&gt;condition&lt;/code&gt; = (x&amp;gt; = value).</target>
        </trans-unit>
        <trans-unit id="af1053b8f0ec97d05015f270566c5b82959272a7" translate="yes" xml:space="preserve">
          <source>This function is a shortcut to &lt;code&gt;masked_where&lt;/code&gt;, with &lt;code&gt;condition&lt;/code&gt; = (x &amp;lt; value).</source>
          <target state="translated">Эта функция является ярлыком для &lt;code&gt;masked_where&lt;/code&gt; с &lt;code&gt;condition&lt;/code&gt; = (x &amp;lt;значение).</target>
        </trans-unit>
        <trans-unit id="f9189002c6a19182c690d1c6efc00b46a33f7232" translate="yes" xml:space="preserve">
          <source>This function is a shortcut to &lt;code&gt;masked_where&lt;/code&gt;, with &lt;code&gt;condition&lt;/code&gt; = (x &amp;lt;= value).</source>
          <target state="translated">Эта функция является ярлыком для &lt;code&gt;masked_where&lt;/code&gt; с &lt;code&gt;condition&lt;/code&gt; = (x &amp;lt;= value).</target>
        </trans-unit>
        <trans-unit id="f46637928627180e5c802e1527edd637c13a58b6" translate="yes" xml:space="preserve">
          <source>This function is a shortcut to &lt;code&gt;masked_where&lt;/code&gt;, with &lt;code&gt;condition&lt;/code&gt; = (x == value). For floating point arrays, consider using &lt;code&gt;masked_values(x, value)&lt;/code&gt;.</source>
          <target state="translated">Эта функция является ярлыком для &lt;code&gt;masked_where&lt;/code&gt; с &lt;code&gt;condition&lt;/code&gt; = (x == value). Для массивов с плавающей запятой рассмотрите возможность использования &lt;code&gt;masked_values(x, value)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f4434dee55a64bbfebaafbec40077ada7cc2e4b4" translate="yes" xml:space="preserve">
          <source>This function is a shortcut to &lt;code&gt;masked_where&lt;/code&gt;, with &lt;code&gt;condition&lt;/code&gt; = ~(np.isfinite(a)). Any pre-existing mask is conserved. Only applies to arrays with a dtype where NaNs or infs make sense (i.e. floating point types), but accepts any array_like object.</source>
          <target state="translated">Эта функция является ярлыком для &lt;code&gt;masked_where&lt;/code&gt; с &lt;code&gt;condition&lt;/code&gt; = ~ (np.isfinite (a)). Любая ранее существовавшая маска сохраняется. Применяется только к массивам с типом dtype, где значения NaN или infs имеют смысл (например, типы с плавающей запятой), но принимает любой объект, подобный array_like.</target>
        </trans-unit>
        <trans-unit id="f28b126f5c6b2ce96d11bc92753f383ad4cd6485" translate="yes" xml:space="preserve">
          <source>This function is able to return one of eight different matrix norms, or one of an infinite number of vector norms (described below), depending on the value of the &lt;code&gt;ord&lt;/code&gt; parameter.</source>
          <target state="translated">Эта функция может возвращать одну из восьми различных норм матриц или одну из бесконечного числа векторных норм (описанных ниже), в зависимости от значения параметра &lt;code&gt;ord&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c1758140bc8fa9fd28fc8bc131c3f6321c42d5db" translate="yes" xml:space="preserve">
          <source>This function is capable of returning the condition number using one of seven different norms, depending on the value of &lt;code&gt;p&lt;/code&gt; (see Parameters below).</source>
          <target state="translated">Эта функция способна возвращать номер условия, используя одну из семи различных норм, в зависимости от значения &lt;code&gt;p&lt;/code&gt; (см. Параметры ниже).</target>
        </trans-unit>
        <trans-unit id="7f257a627b846a11d8d82d4b0986234672c8d024" translate="yes" xml:space="preserve">
          <source>This function is equivalent to &lt;a href=&quot;#numpy.ma.allclose&quot;&gt;&lt;code&gt;allclose&lt;/code&gt;&lt;/a&gt; except that masked values are treated as equal (default) or unequal, depending on the &lt;a href=&quot;numpy.ma.masked_equal#numpy.ma.masked_equal&quot;&gt;&lt;code&gt;masked_equal&lt;/code&gt;&lt;/a&gt; argument.</source>
          <target state="translated">Эта функция эквивалентна &lt;a href=&quot;#numpy.ma.allclose&quot;&gt; &lt;code&gt;allclose&lt;/code&gt; ,&lt;/a&gt; за исключением того, что маскированные значения обрабатываются как равные (по умолчанию) или неравные, в зависимости от аргумента &lt;a href=&quot;numpy.ma.masked_equal#numpy.ma.masked_equal&quot;&gt; &lt;code&gt;masked_equal&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a3debc8695bd72584953abb12e719fb90548f7dd" translate="yes" xml:space="preserve">
          <source>This function is equivalent to calling the &amp;ldquo;compressed&amp;rdquo; method of a &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray&quot;&gt;&lt;code&gt;MaskedArray&lt;/code&gt;&lt;/a&gt;, see &lt;a href=&quot;numpy.ma.maskedarray.compressed#numpy.ma.MaskedArray.compressed&quot;&gt;&lt;code&gt;MaskedArray.compressed&lt;/code&gt;&lt;/a&gt; for details.</source>
          <target state="translated">Эта функция эквивалентна вызову &amp;laquo;сжатого&amp;raquo; метода объекта &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray&quot;&gt; &lt;code&gt;MaskedArray&lt;/code&gt; &lt;/a&gt; , подробности см. В разделе &lt;a href=&quot;numpy.ma.maskedarray.compressed#numpy.ma.MaskedArray.compressed&quot;&gt; &lt;code&gt;MaskedArray.compressed&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="614f9af44de8bf025b95f7feb6cfbfad93376ecb" translate="yes" xml:space="preserve">
          <source>This function is equivalent to tuple axis arguments to reorderable ufuncs with keepdims=True. Tuple axis arguments to ufuncs have been available since version 1.7.0.</source>
          <target state="translated">Эта функция эквивалентна аргументам оси кортежа для переупорядочиваемых ufuncs с keepdims=True.Аргументы кортежей осей доступны ufuncs начиная с версии 1.7.0.</target>
        </trans-unit>
        <trans-unit id="3c5d87f95304bba4f22f4f3bc79a0366620caeda" translate="yes" xml:space="preserve">
          <source>This function is exactly equivalent to &lt;a href=&quot;numpy.transpose#numpy.transpose&quot;&gt;&lt;code&gt;numpy.transpose&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Эта функция в точности эквивалентна &lt;a href=&quot;numpy.transpose#numpy.transpose&quot;&gt; &lt;code&gt;numpy.transpose&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0a042d76cb2129f19b61e5085381910d8b99bdbc" translate="yes" xml:space="preserve">
          <source>This function is intended to be used in EXTERNAL_LOOP mode only, and will produce some wrong answers when that mode is not enabled.</source>
          <target state="translated">Эта функция предназначена для использования только в режиме EXTERNAL_LOOP и будет давать неверные ответы,если этот режим не включен.</target>
        </trans-unit>
        <trans-unit id="d3aeb8a347cc701a9fec8946ae6c740c1103bc20" translate="yes" xml:space="preserve">
          <source>This function is not defined for complex-valued arguments; for the so-called argument of complex values, use &lt;a href=&quot;numpy.angle#numpy.angle&quot;&gt;&lt;code&gt;angle&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Эта функция не определена для комплексных аргументов; для так называемого аргумента комплексных значений используйте &lt;a href=&quot;numpy.angle#numpy.angle&quot;&gt; &lt;code&gt;angle&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="42c780622358a45155401477993b5d9d0b335549" translate="yes" xml:space="preserve">
          <source>This function is not designed to work with integers.</source>
          <target state="translated">Эта функция не предназначена для работы с целыми числами.</target>
        </trans-unit>
        <trans-unit id="ea62cc16ec217ef39d7f7c8e5969148da37fd3a3" translate="yes" xml:space="preserve">
          <source>This function is not implemented yet.</source>
          <target state="translated">Эта функция еще не реализована.</target>
        </trans-unit>
        <trans-unit id="b2f9356116ad7b6b9ba74a0d07b768457fca53e0" translate="yes" xml:space="preserve">
          <source>This function is obsolete and, because of changes due to relaxed stride checking, its return value for the same array may differ for versions of NumPy &amp;gt;= 1.10.0 and previous versions. If you only want to check if an array is Fortran contiguous use &lt;code&gt;a.flags.f_contiguous&lt;/code&gt; instead.</source>
          <target state="translated">Эта функция устарела, и из-за изменений, связанных с ослабленной проверкой шага, ее возвращаемое значение для одного и того же массива может отличаться для версий NumPy&amp;gt; = 1.10.0 и предыдущих версий. Если вы хотите только проверить, является ли массив непрерывным в Fortran, используйте вместо этого &lt;code&gt;a.flags.f_contiguous&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="258358cbdd467c9c344ce8e3f9c85d0cd7f428e4" translate="yes" xml:space="preserve">
          <source>This function is similar to &lt;a href=&quot;numpy.ma.masked_values#numpy.ma.masked_values&quot;&gt;&lt;code&gt;masked_values&lt;/code&gt;&lt;/a&gt;, but only suitable for object arrays: for floating point, use &lt;a href=&quot;numpy.ma.masked_values#numpy.ma.masked_values&quot;&gt;&lt;code&gt;masked_values&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">Эта функция похожа на &lt;a href=&quot;numpy.ma.masked_values#numpy.ma.masked_values&quot;&gt; &lt;code&gt;masked_values&lt;/code&gt; &lt;/a&gt; , но подходит только для массивов объектов: для чисел с плавающей запятой используйте вместо них &lt;a href=&quot;numpy.ma.masked_values#numpy.ma.masked_values&quot;&gt; &lt;code&gt;masked_values&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="42e4240c2bc84555a7f741757d674e8c82e565ad" translate="yes" xml:space="preserve">
          <source>This function is superceded by &lt;a href=&quot;#c.PyArray_MinScalarType&quot;&gt;&lt;code&gt;PyArray_MinScalarType&lt;/code&gt;&lt;/a&gt; and/or &lt;a href=&quot;#c.PyArray_ResultType&quot;&gt;&lt;code&gt;PyArray_ResultType&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Эта функция &lt;a href=&quot;#c.PyArray_MinScalarType&quot;&gt; &lt;code&gt;PyArray_MinScalarType&lt;/code&gt; &lt;/a&gt; и / или &lt;a href=&quot;#c.PyArray_ResultType&quot;&gt; &lt;code&gt;PyArray_ResultType&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f3e20de601f3ca24a5ff2472df08d779de8dd632" translate="yes" xml:space="preserve">
          <source>This function is superceded by &lt;a href=&quot;#c.PyArray_ResultType&quot;&gt;&lt;code&gt;PyArray_ResultType&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Эта функция &lt;a href=&quot;#c.PyArray_ResultType&quot;&gt; &lt;code&gt;PyArray_ResultType&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="223dd6fd50941f5cca2c485c95e8e5dc687d05fb" translate="yes" xml:space="preserve">
          <source>This function is superseded by &lt;a href=&quot;#c.PyArray_MinScalarType&quot;&gt;&lt;code&gt;PyArray_MinScalarType&lt;/code&gt;&lt;/a&gt; and/or &lt;a href=&quot;#c.PyArray_ResultType&quot;&gt;&lt;code&gt;PyArray_ResultType&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc0b6a66579ee7b8e064413a2fb5429da45dba58" translate="yes" xml:space="preserve">
          <source>This function is superseded by &lt;a href=&quot;#c.PyArray_ResultType&quot;&gt;&lt;code&gt;PyArray_ResultType&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b1ff7898f391050d07732317e1b4b4bc976ee58" translate="yes" xml:space="preserve">
          <source>This function is symmetric, but rarely associative.</source>
          <target state="translated">Эта функция симметрична,но редко ассоциативна.</target>
        </trans-unit>
        <trans-unit id="fb34e601302a103a0946045a1719e9ad4309bf62" translate="yes" xml:space="preserve">
          <source>This function is the equivalent of &lt;a href=&quot;numpy.diag#numpy.diag&quot;&gt;&lt;code&gt;numpy.diag&lt;/code&gt;&lt;/a&gt; that takes masked values into account, see &lt;a href=&quot;numpy.diag#numpy.diag&quot;&gt;&lt;code&gt;numpy.diag&lt;/code&gt;&lt;/a&gt; for details.</source>
          <target state="translated">Эта функция эквивалентна &lt;a href=&quot;numpy.diag#numpy.diag&quot;&gt; &lt;code&gt;numpy.diag&lt;/code&gt; ,&lt;/a&gt; который учитывает маскированные значения, подробности см. В &lt;a href=&quot;numpy.diag#numpy.diag&quot;&gt; &lt;code&gt;numpy.diag&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="762735a831cc238bcd6be4852c06ac0013225a54" translate="yes" xml:space="preserve">
          <source>This function is the equivalent of &lt;a href=&quot;numpy.dot#numpy.dot&quot;&gt;&lt;code&gt;numpy.dot&lt;/code&gt;&lt;/a&gt; that takes masked values into account. Note that &lt;code&gt;strict&lt;/code&gt; and &lt;code&gt;out&lt;/code&gt; are in different position than in the method version. In order to maintain compatibility with the corresponding method, it is recommended that the optional arguments be treated as keyword only. At some point that may be mandatory.</source>
          <target state="translated">Эта функция эквивалентна &lt;a href=&quot;numpy.dot#numpy.dot&quot;&gt; &lt;code&gt;numpy.dot&lt;/code&gt; ,&lt;/a&gt; которая учитывает замаскированные значения. Обратите внимание, что &lt;code&gt;strict&lt;/code&gt; и &lt;code&gt;out&lt;/code&gt; находятся в другом положении, чем в версии метода. Для обеспечения совместимости с соответствующим методом рекомендуется обрабатывать необязательные аргументы только как ключевое слово. В какой-то момент это может быть обязательно.</target>
        </trans-unit>
        <trans-unit id="b3449fce446ccae1d5ae6c6d55107b82701f20fd" translate="yes" xml:space="preserve">
          <source>This function is the equivalent of &lt;a href=&quot;numpy.ediff1d#numpy.ediff1d&quot;&gt;&lt;code&gt;numpy.ediff1d&lt;/code&gt;&lt;/a&gt; that takes masked values into account, see &lt;a href=&quot;numpy.ediff1d#numpy.ediff1d&quot;&gt;&lt;code&gt;numpy.ediff1d&lt;/code&gt;&lt;/a&gt; for details.</source>
          <target state="translated">Эта функция эквивалентна &lt;a href=&quot;numpy.ediff1d#numpy.ediff1d&quot;&gt; &lt;code&gt;numpy.ediff1d&lt;/code&gt; ,&lt;/a&gt; которая учитывает маскированные значения, подробности см. В &lt;a href=&quot;numpy.ediff1d#numpy.ediff1d&quot;&gt; &lt;code&gt;numpy.ediff1d&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="fc125d9cdb2114a10df5933b4e6f500d1c08539d" translate="yes" xml:space="preserve">
          <source>This function is used to simplify access to fields nested in other fields.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="48492051f92b9e0c98dfd72175da1464af62c22d" translate="yes" xml:space="preserve">
          <source>This function is useful for calculating a fill value suitable for taking the maximum of an array with a given dtype.</source>
          <target state="translated">Данная функция полезна для вычисления значения заливки,пригодного для взятия максимума массива с заданным типом d.</target>
        </trans-unit>
        <trans-unit id="514144ea48299b81c7b15dfcf631d31668bd3186" translate="yes" xml:space="preserve">
          <source>This function is useful for determining a common type that two or more arrays can be converted to. It only works for non-flexible array types as no itemsize information is passed. The &lt;em&gt;mintype&lt;/em&gt; argument represents the minimum type acceptable, and &lt;em&gt;op&lt;/em&gt; represents the object that will be converted to an array. The return value is the enumerated typenumber that represents the data-type that &lt;em&gt;op&lt;/em&gt; should have.</source>
          <target state="translated">Эта функция полезна для определения общего типа, в который можно преобразовать два или более массива. Он работает только для негибких типов массивов, поскольку информация о размере элементов не передается. &lt;em&gt;Mintype&lt;/em&gt; аргумент представляет минимальный типа приемлем, и &lt;em&gt;оп&lt;/em&gt; представляет собой объект , который будет преобразован в массив. Возвращаемое значение - это пронумерованный типовой номер, который представляет тип данных, который должен иметь &lt;em&gt;op&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="66ea2fa9dfd3553ca39f3787970de46499229028" translate="yes" xml:space="preserve">
          <source>This function is useful to be sure that an array with the correct flags is returned for passing to compiled code (perhaps through ctypes).</source>
          <target state="translated">Эта функция полезна для того,чтобы быть уверенным,что массив с корректными флагами возвращается для передачи в скомпилированный код (возможно,через типы).</target>
        </trans-unit>
        <trans-unit id="8e9b1bcfe6f895f9426e7973caf7f080e53d5b02" translate="yes" xml:space="preserve">
          <source>This function is very similar to &lt;code&gt;PyUFunc_FromFuncAndDataAndSignature&lt;/code&gt; above, but has an extra &lt;em&gt;identity_value&lt;/em&gt; argument, to define an arbitrary identity for the ufunc when &lt;code&gt;identity&lt;/code&gt; is passed as &lt;code&gt;PyUFunc_IdentityValue&lt;/code&gt;.</source>
          <target state="translated">Эта функция очень похожа на &lt;code&gt;PyUFunc_FromFuncAndDataAndSignature&lt;/code&gt; выше, но имеет дополнительный аргумент &lt;em&gt;identity_value&lt;/em&gt; , чтобы определить произвольный идентификатор для ufunc, когда &lt;code&gt;identity&lt;/code&gt; передается как &lt;code&gt;PyUFunc_IdentityValue&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e6ae878f05630a69160b11c652744c88c73b83f7" translate="yes" xml:space="preserve">
          <source>This function is very similar to PyUFunc_FromFuncAndData above, but has an extra &lt;em&gt;signature&lt;/em&gt; argument, to define a &lt;a href=&quot;c-api.generalized-ufuncs#c-api-generalized-ufuncs&quot;&gt;generalized universal functions&lt;/a&gt;. Similarly to how ufuncs are built around an element-by-element operation, gufuncs are around subarray-by-subarray operations, the &lt;a href=&quot;c-api.generalized-ufuncs#details-of-signature&quot;&gt;signature&lt;/a&gt; defining the subarrays to operate on.</source>
          <target state="translated">Эта функция очень похожа на PyUFunc_FromFuncAndData выше, но имеет дополнительный аргумент &lt;em&gt;сигнатуры&lt;/em&gt; для определения &lt;a href=&quot;c-api.generalized-ufuncs#c-api-generalized-ufuncs&quot;&gt;обобщенных универсальных функций&lt;/a&gt; . Подобно тому, как ufuncs строятся вокруг поэлементной операции, gufuncs строятся вокруг операций подмассива за подмассивом, &lt;a href=&quot;c-api.generalized-ufuncs#details-of-signature&quot;&gt;сигнатура&lt;/a&gt; определяет подмассивы для работы.</target>
        </trans-unit>
        <trans-unit id="7d7c3c059d66b50ac25de48e14a9110e6ed62010" translate="yes" xml:space="preserve">
          <source>This function is very similar to PyUFunc_FromFuncAndData above, but has an extra &lt;em&gt;signature&lt;/em&gt; argument, to define a &lt;a href=&quot;generalized-ufuncs#c-api-generalized-ufuncs&quot;&gt;generalized universal functions&lt;/a&gt;. Similarly to how ufuncs are built around an element-by-element operation, gufuncs are around subarray-by-subarray operations, the &lt;a href=&quot;generalized-ufuncs#details-of-signature&quot;&gt;signature&lt;/a&gt; defining the subarrays to operate on.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0dc77b4e140ac75bc9ac3e89d41f38fc73185d22" translate="yes" xml:space="preserve">
          <source>This function makes most sense for arrays with up to 3 dimensions. For instance, for pixel-data with a height (first axis), width (second axis), and r/g/b channels (third axis). The functions &lt;a href=&quot;numpy.concatenate#numpy.concatenate&quot;&gt;&lt;code&gt;concatenate&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;numpy.stack#numpy.stack&quot;&gt;&lt;code&gt;stack&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;numpy.block#numpy.block&quot;&gt;&lt;code&gt;block&lt;/code&gt;&lt;/a&gt; provide more general stacking and concatenation operations.</source>
          <target state="translated">Эта функция наиболее удобна для массивов до 3-х измерений. Например, для пиксельных данных с высотой (первая ось), шириной (вторая ось) и каналами r / g / b (третья ось). Функции &lt;a href=&quot;numpy.concatenate#numpy.concatenate&quot;&gt; &lt;code&gt;concatenate&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;numpy.stack#numpy.stack&quot;&gt; &lt;code&gt;stack&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;numpy.block#numpy.block&quot;&gt; &lt;code&gt;block&lt;/code&gt; &lt;/a&gt; обеспечивают более общие операции стекирования и конкатенации.</target>
        </trans-unit>
        <trans-unit id="f7b019770de00d4d47b09eabe135d2ae721a995a" translate="yes" xml:space="preserve">
          <source>This function makes most sense for arrays with up to 3 dimensions. For instance, for pixel-data with a height (first axis), width (second axis), and r/g/b channels (third axis). The functions &lt;a href=&quot;numpy.ma.concatenate#numpy.ma.concatenate&quot;&gt;&lt;code&gt;concatenate&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;numpy.ma.stack#numpy.ma.stack&quot;&gt;&lt;code&gt;stack&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;block&lt;/code&gt; provide more general stacking and concatenation operations.</source>
          <target state="translated">Эта функция наиболее удобна для массивов до 3-х измерений. Например, для пиксельных данных с высотой (первая ось), шириной (вторая ось) и каналами r / g / b (третья ось). Функции &lt;a href=&quot;numpy.ma.concatenate#numpy.ma.concatenate&quot;&gt; &lt;code&gt;concatenate&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;numpy.ma.stack#numpy.ma.stack&quot;&gt; &lt;code&gt;stack&lt;/code&gt; &lt;/a&gt; и &lt;code&gt;block&lt;/code&gt; обеспечивают более общие операции стекирования и конкатенации.</target>
        </trans-unit>
        <trans-unit id="f15e5fa1742619380116b3f34a00c85d55366c55" translate="yes" xml:space="preserve">
          <source>This function may also be used as a decorator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d585b637d27940cc37d90ebf4940a9aa2e521b5d" translate="yes" xml:space="preserve">
          <source>This function may be safely called without holding the Python GIL.</source>
          <target state="translated">Эта функция может быть безопасно вызвана без удержания Python GIL.</target>
        </trans-unit>
        <trans-unit id="cd200e9dfe3f17be99d159e426b6fa9331db61ec" translate="yes" xml:space="preserve">
          <source>This function may only be called if the iterator is tracking a multi-index and if &lt;a href=&quot;#c.NPY_ITER_DONT_NEGATE_STRIDES&quot;&gt;&lt;code&gt;NPY_ITER_DONT_NEGATE_STRIDES&lt;/code&gt;&lt;/a&gt; was used to prevent an axis from being iterated in reverse order.</source>
          <target state="translated">Эта функция может быть вызвана только в том случае, если итератор отслеживает мультииндекс и если &lt;a href=&quot;#c.NPY_ITER_DONT_NEGATE_STRIDES&quot;&gt; &lt;code&gt;NPY_ITER_DONT_NEGATE_STRIDES&lt;/code&gt; &lt;/a&gt; использовался для предотвращения итерации оси в обратном порядке.</target>
        </trans-unit>
        <trans-unit id="6ca18036fbf762cae2043baf8ac3fa8494d28495" translate="yes" xml:space="preserve">
          <source>This function must be called in the initialization section of a module that will make use of the C-API. It imports the module where the function-pointer table is stored and points the correct variable to it.</source>
          <target state="translated">Эта функция должна быть вызвана в секции инициализации модуля,который будет использовать C-API.Она импортирует модуль,в котором хранится таблица указателей функции,и указывает на нее корректную переменную.</target>
        </trans-unit>
        <trans-unit id="cf5ee49acb54388d21032f90f2de16dca9ddb6c3" translate="yes" xml:space="preserve">
          <source>This function must take two arguments, &lt;code&gt;func(a, axis)&lt;/code&gt;.</source>
          <target state="translated">Эта функция должна принимать два аргумента, &lt;code&gt;func(a, axis)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="dba1259c24481a4a54d81a8fdecff9fadce8f02f" translate="yes" xml:space="preserve">
          <source>This function only shuffles the array along the first axis of a multi-dimensional array. The order of sub-arrays is changed but their contents remains the same.</source>
          <target state="translated">Эта функция перемещает массив только по первой оси многомерного массива.Порядок подмассивов меняется,но их содержимое остается неизменным.</target>
        </trans-unit>
        <trans-unit id="68ca7042b267a7f2923f8a89cc886956d3a640a1" translate="yes" xml:space="preserve">
          <source>This function provides greater precision than &lt;code&gt;exp(x) - 1&lt;/code&gt; for small values of &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">Эта функция обеспечивает большую точность, чем &lt;code&gt;exp(x) - 1&lt;/code&gt; для малых значений &lt;code&gt;x&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="40a3f0ad0a26c2dcd1667ccf5fd0beae55099939" translate="yes" xml:space="preserve">
          <source>This function reads from the system entropy pool and so samples are not reproducible. In particular, it does &lt;em&gt;NOT&lt;/em&gt; make use of a BitGenerator, and so &lt;code&gt;seed&lt;/code&gt; and setting &lt;code&gt;state&lt;/code&gt; have no effect.</source>
          <target state="translated">Эта функция считывает данные из пула энтропии системы, поэтому образцы не воспроизводятся. В частности, он &lt;em&gt;НЕ&lt;/em&gt; использует BitGenerator, поэтому &lt;code&gt;seed&lt;/code&gt; и &lt;code&gt;state&lt;/code&gt; настройки не имеют никакого эффекта.</target>
        </trans-unit>
        <trans-unit id="326a3290cbe737031cbcfe2c255c104d77bb6d98" translate="yes" xml:space="preserve">
          <source>This function returns a (C-style) contiguous and behaved function array from any nested sequence or array interface exporting object, &lt;em&gt;op&lt;/em&gt;, of (non-flexible) type given by the enumerated &lt;em&gt;typenum&lt;/em&gt;, of minimum depth &lt;em&gt;min_depth&lt;/em&gt;, and of maximum depth &lt;em&gt;max_depth&lt;/em&gt;. Equivalent to a call to &lt;a href=&quot;#c.PyArray_FromAny&quot;&gt;&lt;code&gt;PyArray_FromAny&lt;/code&gt;&lt;/a&gt; with requirements set to &lt;a href=&quot;#c.NPY_ARRAY_DEFAULT&quot;&gt;&lt;code&gt;NPY_ARRAY_DEFAULT&lt;/code&gt;&lt;/a&gt; and the type_num member of the type argument set to &lt;em&gt;typenum&lt;/em&gt;.</source>
          <target state="translated">Эта функция возвращает (в стиле C) непрерывный и управляемый массив функций из любой вложенной последовательности или объекта экспорта интерфейса массива &lt;em&gt;op&lt;/em&gt; (негибкого) типа, заданного перечислимым &lt;em&gt;типом&lt;/em&gt; , минимальной глубины &lt;em&gt;min_depth&lt;/em&gt; и максимальной глубины &lt;em&gt;max_depth&lt;/em&gt; . Эквивалентен вызову &lt;a href=&quot;#c.PyArray_FromAny&quot;&gt; &lt;code&gt;PyArray_FromAny&lt;/code&gt; &lt;/a&gt; с требованиями, установленными на &lt;a href=&quot;#c.NPY_ARRAY_DEFAULT&quot;&gt; &lt;code&gt;NPY_ARRAY_DEFAULT&lt;/code&gt; ,&lt;/a&gt; и членом type_num аргумента типа, установленным на &lt;em&gt;typenum&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="cd99a05c88fddf54e9c57ac9cd52857632e3d1f8" translate="yes" xml:space="preserve">
          <source>This function returns a boolean ndarray with all entries False, that can be used in common mask manipulations. If a complex dtype is specified, the type of each field is converted to a boolean type.</source>
          <target state="translated">Эта функция возвращает булевый указатель со всеми записями False,который может быть использован в обычных манипуляциях с масками.Если задан сложный d-тип,то тип каждого поля преобразуется в булевую.</target>
        </trans-unit>
        <trans-unit id="d5e7626c8e43009c9d0e23e7f2d941b6cb967b32" translate="yes" xml:space="preserve">
          <source>This function returns the absolute values (positive magnitude) of the data in &lt;code&gt;x&lt;/code&gt;. Complex values are not handled, use &lt;a href=&quot;numpy.absolute#numpy.absolute&quot;&gt;&lt;code&gt;absolute&lt;/code&gt;&lt;/a&gt; to find the absolute values of complex data.</source>
          <target state="translated">Эта функция возвращает абсолютные значения (положительную величину) данных в &lt;code&gt;x&lt;/code&gt; . Сложные значения не обрабатываются, используйте &lt;a href=&quot;numpy.absolute#numpy.absolute&quot;&gt; &lt;code&gt;absolute&lt;/code&gt; ,&lt;/a&gt; чтобы найти абсолютные значения сложных данных.</target>
        </trans-unit>
        <trans-unit id="89fee3e999f1c558b74709781bf21911d5dc8fa4" translate="yes" xml:space="preserve">
          <source>This function returns the value</source>
          <target state="translated">Эта функция возвращает значение</target>
        </trans-unit>
        <trans-unit id="1cc55e517c256ea42c557b8b54e3efb3b6cafcb6" translate="yes" xml:space="preserve">
          <source>This function returns the values:</source>
          <target state="translated">Эта функция возвращает значения:</target>
        </trans-unit>
        <trans-unit id="a6d07b33b778389f427bd3ca9fc11f04feb25982" translate="yes" xml:space="preserve">
          <source>This function should accept 1-D arrays. It is applied to 1-D slices of &lt;code&gt;arr&lt;/code&gt; along the specified axis.</source>
          <target state="translated">Эта функция должна принимать одномерные массивы. Применяется к 1-мерным срезам &lt;code&gt;arr&lt;/code&gt; вдоль указанной оси.</target>
        </trans-unit>
        <trans-unit id="5cfabdc0232ab8cc8ac575fbc0d4dec6b2dd7bf7" translate="yes" xml:space="preserve">
          <source>This function steals a reference to &lt;em&gt;arr&lt;/em&gt;.</source>
          <target state="translated">Эта функция крадет ссылку на &lt;em&gt;arr&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="3ceff3d1be740072d08fa441617d883813e56f19" translate="yes" xml:space="preserve">
          <source>This function steals a reference to &lt;em&gt;descr&lt;/em&gt; if it is not NULL.</source>
          <target state="translated">Эта функция крадет ссылку на &lt;em&gt;descr,&lt;/em&gt; если она не равна NULL.</target>
        </trans-unit>
        <trans-unit id="8281b58eb98855581eef0364cfa182f403baf433" translate="yes" xml:space="preserve">
          <source>This function steals a reference to &lt;em&gt;descr&lt;/em&gt;.</source>
          <target state="translated">Эта функция крадет ссылку на &lt;em&gt;descr&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="71bb778b3ae86d2314883f6bdb50a6590499183c" translate="yes" xml:space="preserve">
          <source>This function steals a reference to &lt;em&gt;descr&lt;/em&gt;. The easiest way to get one is using &lt;a href=&quot;#c.PyArray_DescrFromType&quot;&gt;&lt;code&gt;PyArray_DescrFromType&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Эта функция крадет ссылку на &lt;em&gt;descr&lt;/em&gt; . Самый простой способ получить его - использовать &lt;a href=&quot;#c.PyArray_DescrFromType&quot;&gt; &lt;code&gt;PyArray_DescrFromType&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f6d42633714a13d2a78f3f69e93cf9d52e8a857e" translate="yes" xml:space="preserve">
          <source>This function supports both indexing conventions through the indexing keyword argument. Giving the string &amp;lsquo;ij&amp;rsquo; returns a meshgrid with matrix indexing, while &amp;lsquo;xy&amp;rsquo; returns a meshgrid with Cartesian indexing. In the 2-D case with inputs of length M and N, the outputs are of shape (N, M) for &amp;lsquo;xy&amp;rsquo; indexing and (M, N) for &amp;lsquo;ij&amp;rsquo; indexing. In the 3-D case with inputs of length M, N and P, outputs are of shape (N, M, P) for &amp;lsquo;xy&amp;rsquo; indexing and (M, N, P) for &amp;lsquo;ij&amp;rsquo; indexing. The difference is illustrated by the following code snippet:</source>
          <target state="translated">Эта функция поддерживает оба соглашения об индексировании с помощью аргумента ключевого слова индексации. Строка ij возвращает сетку с матричной индексацией, а xy возвращает сетку с декартовой индексацией. В двумерном случае с входами длины M и N выходы имеют форму (N, M) для индексации &amp;laquo;xy&amp;raquo; и (M, N) для индексации &amp;laquo;ij&amp;raquo;. В трехмерном случае с входами длины M, N и P выходы имеют форму (N, M, P) для индексации &amp;laquo;xy&amp;raquo; и (M, N, P) для индексации &amp;laquo;ij&amp;raquo;. Разница иллюстрируется следующим фрагментом кода:</target>
        </trans-unit>
        <trans-unit id="e857d76db9c7bac209f1715cec1437cf523540d8" translate="yes" xml:space="preserve">
          <source>This function swaps half-spaces for all axes listed (defaults to all). Note that &lt;code&gt;y[0]&lt;/code&gt; is the Nyquist component only if &lt;code&gt;len(x)&lt;/code&gt; is even.</source>
          <target state="translated">Эта функция меняет местами полупространства для всех перечисленных осей (по умолчанию все). Обратите внимание, что &lt;code&gt;y[0]&lt;/code&gt; является компонентом Найквиста, только если &lt;code&gt;len(x)&lt;/code&gt; четно.</target>
        </trans-unit>
        <trans-unit id="a7870153b27cca4d6c02a86ec8c830b616e4b3c3" translate="yes" xml:space="preserve">
          <source>This function takes N 1-D sequences and returns N outputs with N dimensions each, such that the shape is 1 in all but one dimension and the dimension with the non-unit shape value cycles through all N dimensions.</source>
          <target state="translated">Данная функция принимает N 1-D последовательностей и возвращает N выходов с N размерами каждый,таким образом,что форма является 1 во всех,кроме одного,измерениях,а размер с не единичными циклами значений формы-во всех N измерениях.</target>
        </trans-unit>
        <trans-unit id="b4e43f62f7a361a5fb222fc70fbd3c26bd5104e6" translate="yes" xml:space="preserve">
          <source>This function takes a multi-iterator object that has been previously &amp;ldquo;broadcasted,&amp;rdquo; finds the dimension with the smallest &amp;ldquo;sum of strides&amp;rdquo; in the broadcasted result and adapts all the iterators so as not to iterate over that dimension (by effectively making them of length-1 in that dimension). The corresponding dimension is returned unless &lt;em&gt;mit&lt;/em&gt; -&amp;gt;nd is 0, then -1 is returned. This function is useful for constructing ufunc-like routines that broadcast their inputs correctly and then call a strided 1-d version of the routine as the inner-loop. This 1-d version is usually optimized for speed and for this reason the loop should be performed over the axis that won&amp;rsquo;t require large stride jumps.</source>
          <target state="translated">Эта функция принимает объект с несколькими итераторами, который ранее был &amp;laquo;транслирован&amp;raquo;, находит измерение с наименьшей &amp;laquo;суммой шагов&amp;raquo; в транслируемом результате и адаптирует все итераторы, чтобы не повторять это измерение (эффективно делая их из длина-1 в этом измерении). Соответствующее измерение возвращается, если &lt;em&gt;mit&lt;/em&gt; -&amp;gt; nd не равен 0, тогда возвращается -1. Эта функция полезна для создания подпрограмм, подобных ufunc, которые правильно транслируют свои входные данные, а затем вызывают последовательную 1-мерную версию подпрограммы как внутренний цикл. Эта одномерная версия обычно оптимизирована для скорости, и по этой причине петля должна выполняться по оси, которая не требует больших прыжков с шагом.</target>
        </trans-unit>
        <trans-unit id="102958a161ae2e87757cf73f96956c3988a66269" translate="yes" xml:space="preserve">
          <source>This function uses the same algorithm as the builtin python &lt;a href=&quot;https://docs.python.org/dev/library/bisect.html#bisect.bisect_left&quot;&gt;&lt;code&gt;bisect.bisect_left&lt;/code&gt;&lt;/a&gt; (&lt;code&gt;side='left'&lt;/code&gt;) and &lt;a href=&quot;https://docs.python.org/dev/library/bisect.html#bisect.bisect_right&quot;&gt;&lt;code&gt;bisect.bisect_right&lt;/code&gt;&lt;/a&gt; (&lt;code&gt;side='right'&lt;/code&gt;) functions, which is also vectorized in the &lt;code&gt;v&lt;/code&gt; argument.</source>
          <target state="translated">Эта функция использует тот же алгоритм, что и встроенные функции python &lt;a href=&quot;https://docs.python.org/dev/library/bisect.html#bisect.bisect_left&quot;&gt; &lt;code&gt;bisect.bisect_left&lt;/code&gt; &lt;/a&gt; ( &lt;code&gt;side='left'&lt;/code&gt; ) и &lt;a href=&quot;https://docs.python.org/dev/library/bisect.html#bisect.bisect_right&quot;&gt; &lt;code&gt;bisect.bisect_right&lt;/code&gt; &lt;/a&gt; ( &lt;code&gt;side='right'&lt;/code&gt; ), которые также векторизованы в аргументе &lt;code&gt;v&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f4a094c15ea96c9120e1bb02da934b3ab9299caa" translate="yes" xml:space="preserve">
          <source>This function will not demote complex to float or anything to boolean, but will demote a signed integer to an unsigned integer when the scalar value is positive.</source>
          <target state="translated">Эта функция не будет понижать комплексное значение до плавающего или что-либо до булева,а будет понижать знаковое целое число до беззнакового при положительном скалярном значении.</target>
        </trans-unit>
        <trans-unit id="e431cb683c0bc7c35e7633e888e952e4559756e5" translate="yes" xml:space="preserve">
          <source>This function will not preserve masking of MaskedArray inputs.</source>
          <target state="translated">Эта функция не сохраняет маскировку входов MaskedArray.</target>
        </trans-unit>
        <trans-unit id="2a9b1f287c173d330577d2300449ee4dfd3daa91" translate="yes" xml:space="preserve">
          <source>This function works on subclasses of ndarray like &lt;a href=&quot;numpy.ma.array#numpy.ma.array&quot;&gt;&lt;code&gt;ma.array&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Эта функция работает с подклассами ndarray, такими как &lt;a href=&quot;numpy.ma.array#numpy.ma.array&quot;&gt; &lt;code&gt;ma.array&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b6a52abd835e7532e9891ffc574fd5f4220e58bc" translate="yes" xml:space="preserve">
          <source>This function works similarly to &lt;a href=&quot;#c.PyArray_ObjectType&quot;&gt;&lt;code&gt;PyArray_ObjectType&lt;/code&gt;&lt;/a&gt; (&amp;hellip;) except it handles flexible arrays. The &lt;em&gt;mintype&lt;/em&gt; argument can have an itemsize member and the &lt;em&gt;outtype&lt;/em&gt; argument will have an itemsize member at least as big but perhaps bigger depending on the object &lt;em&gt;op&lt;/em&gt;.</source>
          <target state="translated">Эта функция работает аналогично &lt;a href=&quot;#c.PyArray_ObjectType&quot;&gt; &lt;code&gt;PyArray_ObjectType&lt;/code&gt; &lt;/a&gt; (&amp;hellip;), за исключением того, что она обрабатывает гибкие массивы. &lt;em&gt;Mintype&lt;/em&gt; аргумент может иметь элемент itemsize и &lt;em&gt;outtype&lt;/em&gt; аргумент будет иметь itemsize элемент , по крайней мере , как большой , но , возможно , больше , в зависимости от объекта &lt;em&gt;цит&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="24bfcaf02c26210c6ce475ff904488dd4e86859f" translate="yes" xml:space="preserve">
          <source>This functionality can be obtained via &lt;a href=&quot;numpy.diag_indices#numpy.diag_indices&quot;&gt;&lt;code&gt;diag_indices&lt;/code&gt;&lt;/a&gt;, but internally this version uses a much faster implementation that never constructs the indices and uses simple slicing.</source>
          <target state="translated">Эту функциональность можно получить с помощью &lt;a href=&quot;numpy.diag_indices#numpy.diag_indices&quot;&gt; &lt;code&gt;diag_indices&lt;/code&gt; &lt;/a&gt; , но внутренне эта версия использует гораздо более быструю реализацию, которая никогда не создает индексы и использует простую срезку.</target>
        </trans-unit>
        <trans-unit id="8df0c373fc062bf47c7c593de18498c118dd2c34" translate="yes" xml:space="preserve">
          <source>This general purpose 1-d core function assumes that &lt;em&gt;func&lt;/em&gt; is a string representing a method of the input object that takes one argument. The first argument in &lt;em&gt;args&lt;/em&gt; is the method whose function is called, the second argument in &lt;em&gt;args&lt;/em&gt; is the argument passed to the function. The output of the function is stored in the third entry of &lt;em&gt;args&lt;/em&gt;.</source>
          <target state="translated">Эта одномерная базовая функция общего назначения предполагает, что &lt;em&gt;func&lt;/em&gt; - это строка, представляющая метод входного объекта, который принимает один аргумент. Первый аргумент в &lt;em&gt;args&lt;/em&gt; - это метод, функция которого вызывается, второй аргумент в &lt;em&gt;args&lt;/em&gt; - это аргумент, переданный функции. Выходные данные функции хранятся в третьей записи &lt;em&gt;аргументов&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="71fb70d934e71392e5b977e3d5908e6d14ba65f1" translate="yes" xml:space="preserve">
          <source>This general purpose 1-d core function assumes that &lt;em&gt;func&lt;/em&gt; is a string representing a method of the input object. For each iteration of the loop, the Python object is extracted from the array and its &lt;em&gt;func&lt;/em&gt; method is called returning the result to the output array.</source>
          <target state="translated">Эта 1-мерная базовая функция общего назначения предполагает, что &lt;em&gt;func&lt;/em&gt; - это строка, представляющая метод входного объекта. Для каждой итерации цикла объект Python извлекается из массива, и вызывается его метод &lt;em&gt;func,&lt;/em&gt; возвращающий результат в выходной массив.</target>
        </trans-unit>
        <trans-unit id="ebe1403d50c0fdb0002abff6822f498479faa88e" translate="yes" xml:space="preserve">
          <source>This geometrical property can be seen in two dimensions by plotting generated data-points:</source>
          <target state="translated">Это геометрическое свойство можно увидеть в двух измерениях,построив сгенерированные точки данных:</target>
        </trans-unit>
        <trans-unit id="e1dc7a565ca8eeac49fa065474eb2fca785df357" translate="yes" xml:space="preserve">
          <source>This gives back a pointer to the &lt;code&gt;nop&lt;/code&gt; data pointers. If &lt;a href=&quot;#c.NPY_ITER_EXTERNAL_LOOP&quot;&gt;&lt;code&gt;NPY_ITER_EXTERNAL_LOOP&lt;/code&gt;&lt;/a&gt; was not specified, each data pointer points to the current data item of the iterator. If no inner iteration was specified, it points to the first data item of the inner loop.</source>
          <target state="translated">Это возвращает указатель на указатели данных &lt;code&gt;nop&lt;/code&gt; . Если &lt;a href=&quot;#c.NPY_ITER_EXTERNAL_LOOP&quot;&gt; &lt;code&gt;NPY_ITER_EXTERNAL_LOOP&lt;/code&gt; &lt;/a&gt; не был указан, каждый указатель данных указывает на текущий элемент данных итератора. Если внутренняя итерация не указана, она указывает на первый элемент данных внутреннего цикла.</target>
        </trans-unit>
        <trans-unit id="ad9e42c674af93de7c3d00b721f840bb2a3ba388" translate="yes" xml:space="preserve">
          <source>This gives back a pointer to the &lt;code&gt;nop&lt;/code&gt; data type Descrs for the objects being iterated. The result points into &lt;code&gt;iter&lt;/code&gt;, so the caller does not gain any references to the Descrs.</source>
          <target state="translated">Это возвращает указатель на тип данных &lt;code&gt;nop&lt;/code&gt; Descrs для повторяемых объектов. Результат указывает на &lt;code&gt;iter&lt;/code&gt; , поэтому вызывающий не получает никаких ссылок на Descrs.</target>
        </trans-unit>
        <trans-unit id="04484c93294b17e48ec0072eb06cb15b6ce824d8" translate="yes" xml:space="preserve">
          <source>This gives back a pointer to the &lt;code&gt;nop&lt;/code&gt; operand PyObjects that are being iterated. The result points into &lt;code&gt;iter&lt;/code&gt;, so the caller does not gain any references to the PyObjects.</source>
          <target state="translated">Это возвращает указатель на повторяющиеся объекты PyObject &lt;code&gt;nop&lt;/code&gt; . Результат указывает на &lt;code&gt;iter&lt;/code&gt; , поэтому вызывающий объект не получает никаких ссылок на PyObjects.</target>
        </trans-unit>
        <trans-unit id="de4914e9685130ac5234ec503748e2bb51b5d569" translate="yes" xml:space="preserve">
          <source>This gives back a pointer to the index being tracked, or NULL if no index is being tracked. It is only useable if one of the flags &lt;a href=&quot;#c.NPY_ITER_C_INDEX&quot;&gt;&lt;code&gt;NPY_ITER_C_INDEX&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#c.NPY_ITER_F_INDEX&quot;&gt;&lt;code&gt;NPY_ITER_F_INDEX&lt;/code&gt;&lt;/a&gt; were specified during construction.</source>
          <target state="translated">Это возвращает указатель на отслеживаемый индекс или NULL, если индекс не отслеживается. Его можно использовать, только если во время построения был указан один из флагов &lt;a href=&quot;#c.NPY_ITER_C_INDEX&quot;&gt; &lt;code&gt;NPY_ITER_C_INDEX&lt;/code&gt; &lt;/a&gt; или &lt;a href=&quot;#c.NPY_ITER_F_INDEX&quot;&gt; &lt;code&gt;NPY_ITER_F_INDEX&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="76e1c3a277ebfaa2cffaf967d76cec0c7e8df194" translate="yes" xml:space="preserve">
          <source>This gives back a reference to a new ndarray view, which is a view into the i-th object in the array &lt;a href=&quot;#c.NpyIter_GetOperandArray&quot;&gt;&lt;code&gt;NpyIter_GetOperandArray&lt;/code&gt;&lt;/a&gt;, whose dimensions and strides match the internal optimized iteration pattern. A C-order iteration of this view is equivalent to the iterator&amp;rsquo;s iteration order.</source>
          <target state="translated">Это возвращает ссылку на новое представление ndarray, которое является представлением i-го объекта в массиве &lt;a href=&quot;#c.NpyIter_GetOperandArray&quot;&gt; &lt;code&gt;NpyIter_GetOperandArray&lt;/code&gt; &lt;/a&gt; , размеры и шаги которого соответствуют внутреннему оптимизированному шаблону итерации. Итерация C-порядка этого представления эквивалентна порядку итерации итератора.</target>
        </trans-unit>
        <trans-unit id="5203e44570d99c05fcfa2df4337f300e46c186be" translate="yes" xml:space="preserve">
          <source>This group is used to call code that may take some time but does not use any Python C-API calls. Thus, the GIL should be released during its calculation.</source>
          <target state="translated">Эта группа используется для вызова кода,который может занять некоторое время,но не использует никаких вызовов Python C-API.Таким образом,GIL должен быть освобожден при его вычислении.</target>
        </trans-unit>
        <trans-unit id="5bcd38e59fd6cf93688e83d10245c536ddb55a3a" translate="yes" xml:space="preserve">
          <source>This group is used to re-acquire the Python GIL after it has been released. For example, suppose the GIL has been released (using the previous calls), and then some path in the code (perhaps in a different subroutine) requires use of the Python C-API, then these macros are useful to acquire the GIL. These macros accomplish essentially a reverse of the previous three (acquire the LOCK saving what state it had) and then re-release it with the saved state.</source>
          <target state="translated">Эта группа используется для повторного получения Python GIL после того,как он был выпущен.Например,предположим,что GIL была освобождена (используя предыдущие вызовы),а затем какой-то путь в коде (возможно,в другой подпрограмме)требует использования Python C-API,тогда эти макросы полезны для получения GIL.Эти макросы,по сути,делают обратный ход по сравнению с предыдущими тремя (приобретают БЛОКИРОВКУ,сохраняя то состояние,которое у него было),а затем заново освобождают его с сохраненным состоянием.</target>
        </trans-unit>
        <trans-unit id="22e8bed5de814991ce18d8f44ecb60dc6c28da78" translate="yes" xml:space="preserve">
          <source>This info dict can then be used as input to a &lt;a href=&quot;../distutils#numpy.distutils.misc_util.Configuration&quot;&gt;&lt;code&gt;Configuration&lt;/code&gt;&lt;/a&gt; instance:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="594238b01d9d524cb6fb409e28f8c563967eda11" translate="yes" xml:space="preserve">
          <source>This information will be collected in writing, and whenever possible the group&amp;rsquo;s deliberations will be recorded and retained (i.e. chat transcripts, email discussions, recorded conference calls, summaries of voice conversations, etc).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="11fb823e6d137af2611381a853679838cd294872" translate="yes" xml:space="preserve">
          <source>This interface describes homogeneous arrays in the sense that each item of the array has the same &amp;ldquo;type&amp;rdquo;. This type can be very simple or it can be a quite arbitrary and complicated C-like structure.</source>
          <target state="translated">Этот интерфейс описывает однородные массивы в том смысле, что каждый элемент массива имеет один и тот же &amp;laquo;тип&amp;raquo;. Этот тип может быть очень простым, или это может быть довольно произвольная и сложная C-подобная структура.</target>
        </trans-unit>
        <trans-unit id="669065ebaf0e163f0816c64449775393f24910fd" translate="yes" xml:space="preserve">
          <source>This is a &lt;a href=&quot;numpy.flatiter#numpy.flatiter&quot;&gt;&lt;code&gt;numpy.flatiter&lt;/code&gt;&lt;/a&gt; instance, which acts similarly to, but is not a subclass of, Python&amp;rsquo;s built-in iterator object.</source>
          <target state="translated">Это экземпляр &lt;a href=&quot;numpy.flatiter#numpy.flatiter&quot;&gt; &lt;code&gt;numpy.flatiter&lt;/code&gt; &lt;/a&gt; , который действует аналогично встроенному объекту итератора Python, но не является его подклассом.</target>
        </trans-unit>
        <trans-unit id="c616752b11f5b5590e848100c7afe1eff6eb31fb" translate="yes" xml:space="preserve">
          <source>This is a convenience function for quick storage of array data. Information on endianness and precision is lost, so this method is not a good choice for files intended to archive data or transport data between machines with different endianness. Some of these problems can be overcome by outputting the data as text files, at the expense of speed and file size.</source>
          <target state="translated">Это удобная функция для быстрого хранения данных массива.Информация о эндиантности и точности теряется,поэтому данный метод не является хорошим выбором для файлов,предназначенных для архивирования данных или передачи данных между машинами с различной эндианностью.Некоторые из этих проблем можно преодолеть,выводя данные в виде текстовых файлов,за счет скорости и размера файла.</target>
        </trans-unit>
        <trans-unit id="e143678de16b85b14841ff12151066d84f46e8b0" translate="yes" xml:space="preserve">
          <source>This is a convenience function for users porting code from Matlab, and wraps &lt;a href=&quot;numpy.random.random_sample#numpy.random.random_sample&quot;&gt;&lt;code&gt;random_sample&lt;/code&gt;&lt;/a&gt;. That function takes a tuple to specify the size of the output, which is consistent with other NumPy functions like &lt;a href=&quot;../../generated/numpy.zeros#numpy.zeros&quot;&gt;&lt;code&gt;numpy.zeros&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../generated/numpy.ones#numpy.ones&quot;&gt;&lt;code&gt;numpy.ones&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="637f2f7f4587e6fab14f3bc29737254f8ece5452" translate="yes" xml:space="preserve">
          <source>This is a convenience function for users porting code from Matlab, and wraps &lt;a href=&quot;numpy.random.standard_normal#numpy.random.standard_normal&quot;&gt;&lt;code&gt;standard_normal&lt;/code&gt;&lt;/a&gt;. That function takes a tuple to specify the size of the output, which is consistent with other NumPy functions like &lt;a href=&quot;../../generated/numpy.zeros#numpy.zeros&quot;&gt;&lt;code&gt;numpy.zeros&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../generated/numpy.ones#numpy.ones&quot;&gt;&lt;code&gt;numpy.ones&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aebce3c953e4d7a8aa40a69097fcdae621194f4a" translate="yes" xml:space="preserve">
          <source>This is a convenience function for users porting code from Matlab, and wraps &lt;code&gt;numpy.random.random_sample&lt;/code&gt;. That function takes a tuple to specify the size of the output, which is consistent with other NumPy functions like &lt;a href=&quot;../../generated/numpy.zeros#numpy.zeros&quot;&gt;&lt;code&gt;numpy.zeros&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../generated/numpy.ones#numpy.ones&quot;&gt;&lt;code&gt;numpy.ones&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Это удобная функция для пользователей, &lt;code&gt;numpy.random.random_sample&lt;/code&gt; код из Matlab, она обертывает numpy.random.random_sample . Эта функция принимает кортеж для указания размера вывода, что согласуется с другими функциями NumPy, такими как &lt;a href=&quot;../../generated/numpy.zeros#numpy.zeros&quot;&gt; &lt;code&gt;numpy.zeros&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;../../generated/numpy.ones#numpy.ones&quot;&gt; &lt;code&gt;numpy.ones&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8a8395276aef2b1c09ac3507c06c6aeae1c56edd" translate="yes" xml:space="preserve">
          <source>This is a convenience function for users porting code from Matlab, and wraps &lt;code&gt;numpy.random.standard_normal&lt;/code&gt;. That function takes a tuple to specify the size of the output, which is consistent with other NumPy functions like &lt;a href=&quot;../../generated/numpy.zeros#numpy.zeros&quot;&gt;&lt;code&gt;numpy.zeros&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../generated/numpy.ones#numpy.ones&quot;&gt;&lt;code&gt;numpy.ones&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Это удобная функция для пользователей, &lt;code&gt;numpy.random.standard_normal&lt;/code&gt; код из Matlab, и она обертывает numpy.random.standard_normal . Эта функция принимает кортеж для указания размера вывода, что согласуется с другими функциями NumPy, такими как &lt;a href=&quot;../../generated/numpy.zeros#numpy.zeros&quot;&gt; &lt;code&gt;numpy.zeros&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;../../generated/numpy.ones#numpy.ones&quot;&gt; &lt;code&gt;numpy.ones&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="14bed771c7ecf5fb5c7f3988c3e80ea720b90d56" translate="yes" xml:space="preserve">
          <source>This is a convenience, legacy function.</source>
          <target state="translated">Это удобство,функция наследия.</target>
        </trans-unit>
        <trans-unit id="8386d98dd4fd3fd3372da264e738d2eec8c472de" translate="yes" xml:space="preserve">
          <source>This is a default converter for output arrays given to functions. If &lt;em&gt;obj&lt;/em&gt; is &lt;a href=&quot;https://docs.python.org/dev/c-api/none.html#c.Py_None&quot;&gt;&lt;code&gt;Py_None&lt;/code&gt;&lt;/a&gt; or &lt;code&gt;NULL&lt;/code&gt;, then &lt;em&gt;*address&lt;/em&gt; will be &lt;code&gt;NULL&lt;/code&gt; but the call will succeed. If &lt;a href=&quot;#c.PyArray_Check&quot;&gt;&lt;code&gt;PyArray_Check&lt;/code&gt;&lt;/a&gt; ( &lt;em&gt;obj&lt;/em&gt;) is TRUE then it is returned in &lt;em&gt;*address&lt;/em&gt; without incrementing its reference count.</source>
          <target state="translated">Это преобразователь по умолчанию для выходных массивов, данных функциям. Если &lt;em&gt;obj&lt;/em&gt; равно &lt;a href=&quot;https://docs.python.org/dev/c-api/none.html#c.Py_None&quot;&gt; &lt;code&gt;Py_None&lt;/code&gt; &lt;/a&gt; или &lt;code&gt;NULL&lt;/code&gt; , тогда &lt;em&gt;* адрес&lt;/em&gt; будет &lt;code&gt;NULL&lt;/code&gt; , но вызов будет успешным. Если &lt;a href=&quot;#c.PyArray_Check&quot;&gt; &lt;code&gt;PyArray_Check&lt;/code&gt; &lt;/a&gt; ( &lt;em&gt;obj&lt;/em&gt; ) имеет значение TRUE, то он возвращается в &lt;em&gt;* адресе&lt;/em&gt; без увеличения его счетчика ссылок.</target>
        </trans-unit>
        <trans-unit id="ebf6bd0b70f0575c64ee3df5fdd00ac441de460d" translate="yes" xml:space="preserve">
          <source>This is a function equivalent to C99 copysign: return x with the same sign as y. Works for any value, including inf and nan. Single and extended precisions are available with suffix f and l.</source>
          <target state="translated">Это функция,эквивалентная копи-сигналу C99:return x с тем же знаком,что и y.Работает для любого значения,включая инф и нан.Одиночная и расширенная точности доступны с суффиксом f и l.</target>
        </trans-unit>
        <trans-unit id="9c5d9b74232b5b43fdac1227d638313277afa572" translate="yes" xml:space="preserve">
          <source>This is a function equivalent to C99 nextafter: return next representable floating point value from x in the direction of y. Single and extended precisions are available with suffix f and l.</source>
          <target state="translated">Эта функция эквивалентна некстати C99:возвращает следующее репрезентативное значение с плавающей точкой от x в направлении y.Одиночные и расширенные точности доступны с суффиксом f и l.</target>
        </trans-unit>
        <trans-unit id="6cef9e65ee084ca1f09a67a21a4b3ef4b9523383" translate="yes" xml:space="preserve">
          <source>This is a function equivalent to Fortran intrinsic. Return distance between x and next representable floating point value from x, e.g. spacing(1) == eps. spacing of nan and +/- inf return nan. Single and extended precisions are available with suffix f and l.</source>
          <target state="translated">Это функция,эквивалентная Fortran intrinsic.Возвращает расстояние между x и следующим представляемым значением с плавающей точкой от x,например,расстояние(1)==eps.интервал между наном и +/-inf возвращаемый нан.Однократные и расширенные точности доступны с суффиксом f и l.</target>
        </trans-unit>
        <trans-unit id="f691a7cca2d5bab9d5322a451f5071b060431b18" translate="yes" xml:space="preserve">
          <source>This is a function pointer for getting the current iterator multi-index, returned by &lt;a href=&quot;#c.NpyIter_GetGetMultiIndex&quot;&gt;&lt;code&gt;NpyIter_GetGetMultiIndex&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Это указатель на функцию для получения текущего мультииндекса итератора, возвращаемого &lt;a href=&quot;#c.NpyIter_GetGetMultiIndex&quot;&gt; &lt;code&gt;NpyIter_GetGetMultiIndex&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="afe9f9d9e5612f0c43f0b6f2ab1ddbf98d2077ed" translate="yes" xml:space="preserve">
          <source>This is a function pointer for the iteration loop, returned by &lt;a href=&quot;#c.NpyIter_GetIterNext&quot;&gt;&lt;code&gt;NpyIter_GetIterNext&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Это указатель на функцию для цикла итерации, возвращаемый &lt;a href=&quot;#c.NpyIter_GetIterNext&quot;&gt; &lt;code&gt;NpyIter_GetIterNext&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="682e5efdefc09e15bb711f19c6e22c6512c8e3c9" translate="yes" xml:space="preserve">
          <source>This is a list of flags for each operand. At minimum, one of &lt;code&gt;readonly&lt;/code&gt;, &lt;code&gt;readwrite&lt;/code&gt;, or &lt;code&gt;writeonly&lt;/code&gt; must be specified.</source>
          <target state="translated">Это список флагов для каждого операнда. Как минимум, один из &lt;code&gt;readonly&lt;/code&gt; , &lt;code&gt;readwrite&lt;/code&gt; , или &lt;code&gt;writeonly&lt;/code&gt; должен быть указан.</target>
        </trans-unit>
        <trans-unit id="daee1c27087ebe5008ffab37bf86e6cef5520692" translate="yes" xml:space="preserve">
          <source>This is a macro, and is equivalent to C99 isfinite: works for single, double and extended precision, and return a non 0 value is x is neither a NaN nor an infinity.</source>
          <target state="translated">Это макрос,эквивалентный C99 isfinite:работает с одинарной,двойной и расширенной точностью,а возвращаемое не 0 значение x не является ни NaN,ни бесконечностью.</target>
        </trans-unit>
        <trans-unit id="80381bd72606c65ade88008349bbceb47f771261" translate="yes" xml:space="preserve">
          <source>This is a macro, and is equivalent to C99 isinf: works for single, double and extended precision, and return a non 0 value is x is infinite (positive and negative).</source>
          <target state="translated">Это макрос,и он эквивалентен C99 isinf:работает с одинарной,двойной и расширенной точностью,а возвращаемое не 0 значение x бесконечно (положительное и отрицательное).</target>
        </trans-unit>
        <trans-unit id="0a2766c5fc1ee9982025de76ae4aa9f68ecd22db" translate="yes" xml:space="preserve">
          <source>This is a macro, and is equivalent to C99 isnan: works for single, double and extended precision, and return a non 0 value is x is a NaN.</source>
          <target state="translated">Это макрос,эквивалентный C99 isnan:работает с одинарной,двойной и расширенной точностью,а возвращаемое значение,отличное от 0,равно x-NaN.</target>
        </trans-unit>
        <trans-unit id="ba072edcddb8314e48393832fd145a168df5e278" translate="yes" xml:space="preserve">
          <source>This is a macro, and is equivalent to C99 signbit: works for single, double and extended precision, and return a non 0 value is x has the signbit set (that is the number is negative).</source>
          <target state="translated">Это макрос,и он эквивалентен знаку C99:работает для одинарной,двойной и расширенной точности,а возвращаемое значение,отличное от 0,равно x имеет набор знаков (т.е.число отрицательное).</target>
        </trans-unit>
        <trans-unit id="e912c91523a3cdb66f72696d355ab45d0a9a414f" translate="yes" xml:space="preserve">
          <source>This is a relatively robust method to compare two arrays whose amplitude is variable.</source>
          <target state="translated">Это относительно робастный метод сравнения двух массивов,амплитуда которых варьируется.</target>
        </trans-unit>
        <trans-unit id="f9e98f643e268bceb892d520470f87f06bd3ffa1" translate="yes" xml:space="preserve">
          <source>This is a scalar if both &lt;code&gt;x1&lt;/code&gt; and &lt;code&gt;x2&lt;/code&gt; are scalars.</source>
          <target state="translated">Это скаляр, если и &lt;code&gt;x1&lt;/code&gt; , и &lt;code&gt;x2&lt;/code&gt; являются скалярами.</target>
        </trans-unit>
        <trans-unit id="daaf8424b18b172abdada56262484be0114cb050" translate="yes" xml:space="preserve">
          <source>This is a setup.py file for the above code. As before, the module can be build via calling python setup.py build at the command prompt, or installed to site-packages via python setup.py install.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b6ff4b3ee0d226dd43f100afc9a5e9fc743a95d" translate="yes" xml:space="preserve">
          <source>This is a simple way to build up arrays quickly. There are two use cases.</source>
          <target state="translated">Это простой способ быстрого создания массивов.Есть два варианта использования.</target>
        </trans-unit>
        <trans-unit id="5bf246dfc26ef7aa2b64da9e4b03eace45db2857" translate="yes" xml:space="preserve">
          <source>This is a special flag that is set if this array represents a copy made because a user required certain flags in &lt;a href=&quot;#c.PyArray_FromAny&quot;&gt;&lt;code&gt;PyArray_FromAny&lt;/code&gt;&lt;/a&gt; and a copy had to be made of some other array (and the user asked for this flag to be set in such a situation). The base attribute then points to the &amp;ldquo;misbehaved&amp;rdquo; array (which is set read_only). :c:func`PyArray_ResolveWritebackIfCopy` will copy its contents back to the &amp;ldquo;misbehaved&amp;rdquo; array (casting if necessary) and will reset the &amp;ldquo;misbehaved&amp;rdquo; array to &lt;a href=&quot;#c.NPY_ARRAY_WRITEABLE&quot;&gt;&lt;code&gt;NPY_ARRAY_WRITEABLE&lt;/code&gt;&lt;/a&gt;. If the &amp;ldquo;misbehaved&amp;rdquo; array was not &lt;a href=&quot;#c.NPY_ARRAY_WRITEABLE&quot;&gt;&lt;code&gt;NPY_ARRAY_WRITEABLE&lt;/code&gt;&lt;/a&gt; to begin with then &lt;a href=&quot;#c.PyArray_FromAny&quot;&gt;&lt;code&gt;PyArray_FromAny&lt;/code&gt;&lt;/a&gt; would have returned an error because &lt;a href=&quot;#c.NPY_ARRAY_WRITEBACKIFCOPY&quot;&gt;&lt;code&gt;NPY_ARRAY_WRITEBACKIFCOPY&lt;/code&gt;&lt;/a&gt; would not have been possible.</source>
          <target state="translated">Это специальный флаг, который устанавливается, если этот массив представляет собой копию, сделанную потому, что пользователю требовались определенные флаги в &lt;a href=&quot;#c.PyArray_FromAny&quot;&gt; &lt;code&gt;PyArray_FromAny&lt;/code&gt; ,&lt;/a&gt; а копия должна была быть сделана из некоторого другого массива (и пользователь попросил установить этот флаг в такой ситуации) . Затем базовый атрибут указывает на массив &amp;laquo;неверного поведения&amp;raquo; (для которого установлено значение read_only). : c: func`PyArray_ResolveWritebackIfCopy` скопирует свое содержимое обратно в массив с &amp;laquo;неправильным поведением&amp;raquo; (преобразование, если необходимо) и сбросит массив &amp;laquo;с неправильным поведением&amp;raquo; на &lt;a href=&quot;#c.NPY_ARRAY_WRITEABLE&quot;&gt; &lt;code&gt;NPY_ARRAY_WRITEABLE&lt;/code&gt; &lt;/a&gt; . Если бы массив с &amp;laquo;неправильным поведением&amp;raquo; &lt;a href=&quot;#c.NPY_ARRAY_WRITEABLE&quot;&gt; &lt;code&gt;NPY_ARRAY_WRITEABLE&lt;/code&gt; &lt;/a&gt; не был NPY_ARRAY_WRITEABLE, тогда &lt;a href=&quot;#c.PyArray_FromAny&quot;&gt; &lt;code&gt;PyArray_FromAny&lt;/code&gt; &lt;/a&gt; возвратил бы ошибку, потому что &lt;a href=&quot;#c.NPY_ARRAY_WRITEBACKIFCOPY&quot;&gt; &lt;code&gt;NPY_ARRAY_WRITEBACKIFCOPY&lt;/code&gt; &lt;/a&gt; было бы невозможно.</target>
        </trans-unit>
        <trans-unit id="d494bbd6ea4e55e23b6320030cf19b92084fb2cb" translate="yes" xml:space="preserve">
          <source>This is a very flexible function; &lt;a href=&quot;numpy.array_repr#numpy.array_repr&quot;&gt;&lt;code&gt;array_repr&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;numpy.array_str#numpy.array_str&quot;&gt;&lt;code&gt;array_str&lt;/code&gt;&lt;/a&gt; are using &lt;a href=&quot;#numpy.array2string&quot;&gt;&lt;code&gt;array2string&lt;/code&gt;&lt;/a&gt; internally so keywords with the same name should work identically in all three functions.</source>
          <target state="translated">Это очень гибкая функция; &lt;a href=&quot;numpy.array_repr#numpy.array_repr&quot;&gt; &lt;code&gt;array_repr&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;numpy.array_str#numpy.array_str&quot;&gt; &lt;code&gt;array_str&lt;/code&gt; &lt;/a&gt; внутренне используют &lt;a href=&quot;#numpy.array2string&quot;&gt; &lt;code&gt;array2string&lt;/code&gt; ,&lt;/a&gt; поэтому ключевые слова с одинаковым именем должны одинаково работать во всех трех функциях.</target>
        </trans-unit>
        <trans-unit id="4a20d6c5e13bf5949cf2f01fed00be4a85ee83c8" translate="yes" xml:space="preserve">
          <source>This is a wrapper around &lt;code&gt;cPickle.dump&lt;/code&gt;.</source>
          <target state="translated">Это оболочка для &lt;code&gt;cPickle.dump&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="72c0baacc027dca1b05db754f60ee813fa6dbfcf" translate="yes" xml:space="preserve">
          <source>This is a wrapper around &lt;code&gt;cPickle.dumps&lt;/code&gt;.</source>
          <target state="translated">Это оболочка для &lt;code&gt;cPickle.dumps&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b6ae9c5b7de866ac0dd1b4b58c7a54bd18149043" translate="yes" xml:space="preserve">
          <source>This is almost the same as the result of PyArray_CanCastTypeTo(PyArray_MinScalarType(arr), totype, casting), but it also handles a special case arising because the set of uint values is not a subset of the int values for types with the same number of bits.</source>
          <target state="translated">Это почти то же самое,что и результат PyArray_CanCastTypeTo(PyArray_MinScalarType(arr),totype,casting),но также обрабатывает особый случай,возникающий из-за того,что набор значений uint не является подмножеством значений int для типов с одинаковым количеством бит.</target>
        </trans-unit>
        <trans-unit id="06d558ced35712eb9368208c693942a96aac9510" translate="yes" xml:space="preserve">
          <source>This is an alias of &lt;a href=&quot;generated/numpy.random.random_sample#numpy.random.random_sample&quot;&gt;&lt;code&gt;random_sample&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6be9e8aa17773bdb0efb0eec1cc4294398d93d4d" translate="yes" xml:space="preserve">
          <source>This is an alias of &lt;a href=&quot;numpy.random.random_sample#numpy.random.random_sample&quot;&gt;&lt;code&gt;random_sample&lt;/code&gt;&lt;/a&gt;. See &lt;a href=&quot;numpy.random.random_sample#numpy.random.random_sample&quot;&gt;&lt;code&gt;random_sample&lt;/code&gt;&lt;/a&gt; for the complete documentation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="abef17cd5a41150617b797dd34026cad2a72bcf3" translate="yes" xml:space="preserve">
          <source>This is an example of a func specialized for addition of doubles returning doubles.</source>
          <target state="translated">Это пример функции,специализирующейся на добавлении дубликатов,возвращающих дубликаты.</target>
        </trans-unit>
        <trans-unit id="8d1fbd89490e7598a40d0ab430364ea01d0cff36" translate="yes" xml:space="preserve">
          <source>This is an interface to the LAPACK routines &lt;code&gt;dgeqrf&lt;/code&gt;, &lt;code&gt;zgeqrf&lt;/code&gt;, &lt;code&gt;dorgqr&lt;/code&gt;, and &lt;code&gt;zungqr&lt;/code&gt;.</source>
          <target state="translated">Это интерфейс для подпрограмм LAPACK &lt;code&gt;dgeqrf&lt;/code&gt; , &lt;code&gt;zgeqrf&lt;/code&gt; , &lt;code&gt;dorgqr&lt;/code&gt; и &lt;code&gt;zungqr&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="944d000b70e8d3d375939368b9ee8662949fdd56" translate="yes" xml:space="preserve">
          <source>This is an iterator object that makes it easy to loop over an N-dimensional array. It is the object returned from the flat attribute of an ndarray. It is also used extensively throughout the implementation internals to loop over an N-dimensional array. The tp_as_mapping interface is implemented so that the iterator object can be indexed (using 1-d indexing), and a few methods are implemented through the tp_methods table. This object implements the next method and can be used anywhere an iterator can be used in Python.</source>
          <target state="translated">Это объект итератора,который позволяет легко перебирать N-мерный массив.Это объект,возвращаемый из плоского атрибута an ndarray.Он также широко используется во внутреннем устройстве реализации для обхода N-мерного массива.Интерфейс tp_as_mapping реализован таким образом,что объект итератора может быть проиндексирован (с помощью 1-d индексации),а несколько методов реализованы через таблицу tp_methods.Этот объект реализует следующий метод и может быть использован в любом месте,где итератор может быть использован на Python.</target>
        </trans-unit>
        <trans-unit id="39877197a88959914be74b4d252daeba988b0567" translate="yes" xml:space="preserve">
          <source>This is an iterator object that makes it easy to loop over an N-dimensional neighborhood.</source>
          <target state="translated">Это объект итератора,который позволяет легко перебирать N-мерный район.</target>
        </trans-unit>
        <trans-unit id="ed4488f4638f84c1e1e4b827cf0b8579c8c851e4" translate="yes" xml:space="preserve">
          <source>This is an opaque pointer type for the iterator. Access to its contents can only be done through the iterator API.</source>
          <target state="translated">Это непрозрачный тип указателя для итератора.Доступ к его содержимому возможен только через API итератора.</target>
        </trans-unit>
        <trans-unit id="b4c12ec7da04774c2971488c28da077dd954ab73" translate="yes" xml:space="preserve">
          <source>This is defined for &lt;code&gt;{type}&lt;/code&gt; = &lt;strong&gt;BYTE&lt;/strong&gt;, &lt;strong&gt;SHORT&lt;/strong&gt;, &lt;strong&gt;INT&lt;/strong&gt;, &lt;strong&gt;LONG&lt;/strong&gt;, &lt;strong&gt;LONGLONG&lt;/strong&gt;, &lt;strong&gt;INTP&lt;/strong&gt;</source>
          <target state="translated">Это определено для &lt;code&gt;{type}&lt;/code&gt; = &lt;strong&gt;BYTE&lt;/strong&gt; , &lt;strong&gt;SHORT&lt;/strong&gt; , &lt;strong&gt;INT&lt;/strong&gt; , &lt;strong&gt;LONG&lt;/strong&gt; , &lt;strong&gt;LONGLONG&lt;/strong&gt; , &lt;strong&gt;INTP&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="1cb38ad4a8a5f0f7eaad9358f9b24fff730b48c2" translate="yes" xml:space="preserve">
          <source>This is defined for all defined for &lt;code&gt;{type}&lt;/code&gt; = &lt;strong&gt;BYTE&lt;/strong&gt;, &lt;strong&gt;UBYTE&lt;/strong&gt;, &lt;strong&gt;SHORT&lt;/strong&gt;, &lt;strong&gt;USHORT&lt;/strong&gt;, &lt;strong&gt;INT&lt;/strong&gt;, &lt;strong&gt;UINT&lt;/strong&gt;, &lt;strong&gt;LONG&lt;/strong&gt;, &lt;strong&gt;ULONG&lt;/strong&gt;, &lt;strong&gt;LONGLONG&lt;/strong&gt;, &lt;strong&gt;ULONGLONG&lt;/strong&gt;, &lt;strong&gt;INTP&lt;/strong&gt;, &lt;strong&gt;UINTP&lt;/strong&gt;</source>
          <target state="translated">Это определено для всех, определенных для &lt;code&gt;{type}&lt;/code&gt; = &lt;strong&gt;BYTE&lt;/strong&gt; , &lt;strong&gt;UBYTE&lt;/strong&gt; , &lt;strong&gt;SHORT&lt;/strong&gt; , &lt;strong&gt;USHORT&lt;/strong&gt; , &lt;strong&gt;INT&lt;/strong&gt; , &lt;strong&gt;UINT&lt;/strong&gt; , &lt;strong&gt;LONG&lt;/strong&gt; , &lt;strong&gt;ULONG&lt;/strong&gt; , &lt;strong&gt;LONGLONG&lt;/strong&gt; , &lt;strong&gt;ULONGLONG&lt;/strong&gt; , &lt;strong&gt;INTP&lt;/strong&gt; , &lt;strong&gt;UINTP.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="3e53b90b8b35ae60046587f59e89f7b60e6df85a" translate="yes" xml:space="preserve">
          <source>This is different from &lt;a href=&quot;numpy.load#numpy.load&quot;&gt;&lt;code&gt;numpy.load&lt;/code&gt;&lt;/a&gt;, which does not use cPickle but loads the NumPy binary .npy format.</source>
          <target state="translated">Это отличается от &lt;a href=&quot;numpy.load#numpy.load&quot;&gt; &lt;code&gt;numpy.load&lt;/code&gt; &lt;/a&gt; , который не использует cPickle, но загружает двоичный формат NumPy .npy.</target>
        </trans-unit>
        <trans-unit id="ad4d2eb9b0ee11d28c4e5a349ba480c6768dfc79" translate="yes" xml:space="preserve">
          <source>This is equivalent to (but faster than) the following use of &lt;a href=&quot;numpy.ndindex#numpy.ndindex&quot;&gt;&lt;code&gt;ndindex&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;numpy.s_#numpy.s_&quot;&gt;&lt;code&gt;s_&lt;/code&gt;&lt;/a&gt;, which sets each of &lt;code&gt;ii&lt;/code&gt; and &lt;code&gt;kk&lt;/code&gt; to a tuple of indices:</source>
          <target state="translated">Это эквивалентно (но быстрее) следующему использованию &lt;a href=&quot;numpy.ndindex#numpy.ndindex&quot;&gt; &lt;code&gt;ndindex&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;numpy.s_#numpy.s_&quot;&gt; &lt;code&gt;s_&lt;/code&gt; &lt;/a&gt; , которое устанавливает для каждого из &lt;code&gt;ii&lt;/code&gt; и &lt;code&gt;kk&lt;/code&gt; кортеж индексов:</target>
        </trans-unit>
        <trans-unit id="f5170749efab413ba3776c33568562d9c4634a7d" translate="yes" xml:space="preserve">
          <source>This is equivalent to (but faster than) the following use of &lt;a href=&quot;numpy.ndindex#numpy.ndindex&quot;&gt;&lt;code&gt;ndindex&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;numpy.s_#numpy.s_&quot;&gt;&lt;code&gt;s_&lt;/code&gt;&lt;/a&gt;, which sets each of &lt;code&gt;ii&lt;/code&gt;, &lt;code&gt;jj&lt;/code&gt;, and &lt;code&gt;kk&lt;/code&gt; to a tuple of indices:</source>
          <target state="translated">Это эквивалентно (но быстрее) следующему использованию &lt;a href=&quot;numpy.ndindex#numpy.ndindex&quot;&gt; &lt;code&gt;ndindex&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;numpy.s_#numpy.s_&quot;&gt; &lt;code&gt;s_&lt;/code&gt; &lt;/a&gt; , которые устанавливают для каждого из &lt;code&gt;ii&lt;/code&gt; , &lt;code&gt;jj&lt;/code&gt; и &lt;code&gt;kk&lt;/code&gt; кортеж индексов:</target>
        </trans-unit>
        <trans-unit id="f723a36a0fdceaf5add767f4dfa10dbdef0cf27e" translate="yes" xml:space="preserve">
          <source>This is equivalent to (but faster than) the following use of &lt;code&gt;ndindex&lt;/code&gt; and &lt;code&gt;s_&lt;/code&gt;, which sets each of &lt;code&gt;ii&lt;/code&gt;, &lt;code&gt;jj&lt;/code&gt;, and &lt;code&gt;kk&lt;/code&gt; to a tuple of indices:</source>
          <target state="translated">Это эквивалентно (но быстрее) следующему использованию &lt;code&gt;ndindex&lt;/code&gt; и &lt;code&gt;s_&lt;/code&gt; , которые устанавливают для каждого из &lt;code&gt;ii&lt;/code&gt; , &lt;code&gt;jj&lt;/code&gt; и &lt;code&gt;kk&lt;/code&gt; кортеж индексов:</target>
        </trans-unit>
        <trans-unit id="9623032760a445ce084ed7cad1f49c8e81cbc730" translate="yes" xml:space="preserve">
          <source>This is equivalent to &lt;code&gt;np.compress(ravel(condition), ravel(arr))&lt;/code&gt;. If &lt;code&gt;condition&lt;/code&gt; is boolean &lt;code&gt;np.extract&lt;/code&gt; is equivalent to &lt;code&gt;arr[condition]&lt;/code&gt;.</source>
          <target state="translated">Это эквивалентно &lt;code&gt;np.compress(ravel(condition), ravel(arr))&lt;/code&gt; . Если &lt;code&gt;condition&lt;/code&gt; является логическим, &lt;code&gt;np.extract&lt;/code&gt; эквивалентно &lt;code&gt;arr[condition]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="512416aca8fa4fb317d305f7a3902a8f4f57268d" translate="yes" xml:space="preserve">
          <source>This is equivalent to &lt;code&gt;np.ma.compress_rowcols(a, 0)&lt;/code&gt;, see &lt;code&gt;extras.compress_rowcols&lt;/code&gt; for details.</source>
          <target state="translated">Это эквивалентно &lt;code&gt;np.ma.compress_rowcols(a, 0)&lt;/code&gt; , подробности см. В &lt;code&gt;extras.compress_rowcols&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1aabefa5df0b67ecae64f8e5a2fb2a4d5dd2e5ee" translate="yes" xml:space="preserve">
          <source>This is equivalent to &lt;code&gt;np.ma.compress_rowcols(a, 1)&lt;/code&gt;, see &lt;code&gt;extras.compress_rowcols&lt;/code&gt; for details.</source>
          <target state="translated">Это эквивалентно &lt;code&gt;np.ma.compress_rowcols(a, 1)&lt;/code&gt; , подробности см. В &lt;code&gt;extras.compress_rowcols&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2e12dd8fc795d33b8f8bcabb847c3e158c738c5e" translate="yes" xml:space="preserve">
          <source>This is equivalent to concatenation along the first axis after 1-D arrays of shape &lt;code&gt;(N,)&lt;/code&gt; have been reshaped to &lt;code&gt;(1,N)&lt;/code&gt;. Rebuilds arrays divided by &lt;a href=&quot;numpy.vsplit#numpy.vsplit&quot;&gt;&lt;code&gt;vsplit&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Это эквивалентно объединению вдоль первой оси после того, как одномерные массивы формы &lt;code&gt;(N,)&lt;/code&gt; были преобразованы в форму &lt;code&gt;(1,N)&lt;/code&gt; . Восстанавливает массивы, разделенные &lt;a href=&quot;numpy.vsplit#numpy.vsplit&quot;&gt; &lt;code&gt;vsplit&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8a1612db7b39849ef3a6bd08b64bed8c3240f816" translate="yes" xml:space="preserve">
          <source>This is equivalent to concatenation along the first axis after 1-D arrays of shape &lt;code&gt;(N,)&lt;/code&gt; have been reshaped to &lt;code&gt;(1,N)&lt;/code&gt;. Rebuilds arrays divided by &lt;code&gt;vsplit&lt;/code&gt;.</source>
          <target state="translated">Это эквивалентно объединению вдоль первой оси после того, как одномерные массивы формы &lt;code&gt;(N,)&lt;/code&gt; были преобразованы в форму &lt;code&gt;(1,N)&lt;/code&gt; . Восстанавливает массивы, разделенные &lt;code&gt;vsplit&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e9676c88264ef3cd76556860f143548d10e94eb6" translate="yes" xml:space="preserve">
          <source>This is equivalent to concatenation along the second axis, except for 1-D arrays where it concatenates along the first axis. Rebuilds arrays divided by &lt;a href=&quot;numpy.hsplit#numpy.hsplit&quot;&gt;&lt;code&gt;hsplit&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Это эквивалентно объединению по второй оси, за исключением одномерных массивов, где оно объединяется по первой оси. Восстанавливает массивы, разделенные &lt;a href=&quot;numpy.hsplit#numpy.hsplit&quot;&gt; &lt;code&gt;hsplit&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e6a5b26fca5a2a732affc24a30a8305bc7f4ee4d" translate="yes" xml:space="preserve">
          <source>This is equivalent to concatenation along the second axis, except for 1-D arrays where it concatenates along the first axis. Rebuilds arrays divided by &lt;a href=&quot;numpy.ma.hsplit#numpy.ma.hsplit&quot;&gt;&lt;code&gt;hsplit&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Это эквивалентно объединению по второй оси, за исключением одномерных массивов, где оно объединяется по первой оси. Восстанавливает массивы, разделенные &lt;a href=&quot;numpy.ma.hsplit#numpy.ma.hsplit&quot;&gt; &lt;code&gt;hsplit&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5f3f85e2c1a9f572b9f43cddeb78f8794cecabcf" translate="yes" xml:space="preserve">
          <source>This is equivalent to concatenation along the third axis after 2-D arrays of shape &lt;code&gt;(M,N)&lt;/code&gt; have been reshaped to &lt;code&gt;(M,N,1)&lt;/code&gt; and 1-D arrays of shape &lt;code&gt;(N,)&lt;/code&gt; have been reshaped to &lt;code&gt;(1,N,1)&lt;/code&gt;. Rebuilds arrays divided by &lt;a href=&quot;numpy.dsplit#numpy.dsplit&quot;&gt;&lt;code&gt;dsplit&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Это эквивалентно объединению вдоль третьей оси после того, как двумерные массивы формы &lt;code&gt;(M,N)&lt;/code&gt; были преобразованы в &lt;code&gt;(M,N,1)&lt;/code&gt; , а одномерные массивы формы &lt;code&gt;(N,)&lt;/code&gt; были преобразованы в &lt;code&gt;(1,N,1)&lt;/code&gt; . Восстанавливает массивы, разделенные &lt;a href=&quot;numpy.dsplit#numpy.dsplit&quot;&gt; &lt;code&gt;dsplit&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5c6f9c31ab715a660b4d23dc2f49389f45ea5bda" translate="yes" xml:space="preserve">
          <source>This is equivalent to concatenation along the third axis after 2-D arrays of shape &lt;code&gt;(M,N)&lt;/code&gt; have been reshaped to &lt;code&gt;(M,N,1)&lt;/code&gt; and 1-D arrays of shape &lt;code&gt;(N,)&lt;/code&gt; have been reshaped to &lt;code&gt;(1,N,1)&lt;/code&gt;. Rebuilds arrays divided by &lt;code&gt;dsplit&lt;/code&gt;.</source>
          <target state="translated">Это эквивалентно объединению вдоль третьей оси после того, как двумерные массивы формы &lt;code&gt;(M,N)&lt;/code&gt; были преобразованы в &lt;code&gt;(M,N,1)&lt;/code&gt; , а одномерные массивы формы &lt;code&gt;(N,)&lt;/code&gt; были преобразованы в &lt;code&gt;(1,N,1)&lt;/code&gt; . Восстанавливает массивы, разделенные &lt;code&gt;dsplit&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d218a0a3e8c4c5860255504a9ba19c22b6fab14a" translate="yes" xml:space="preserve">
          <source>This is equivalent to np.nonzero(np.ravel(a))[0].</source>
          <target state="translated">Это эквивалентно np.nonzero(np.ravel(a))[0].</target>
        </trans-unit>
        <trans-unit id="c1506fb5159fec603ce600935782977e9cc4a640" translate="yes" xml:space="preserve">
          <source>This is equivalent to the &lt;code&gt;density&lt;/code&gt; argument, but produces incorrect results for unequal bin widths. It should not be used.</source>
          <target state="translated">Это эквивалентно аргументу &lt;code&gt;density&lt;/code&gt; , но дает неверные результаты для бинов разной ширины. Его не следует использовать.</target>
        </trans-unit>
        <trans-unit id="59cfbae4022883700bb27212977a0aea4a1ca893" translate="yes" xml:space="preserve">
          <source>This is equivalent to the buffer object structure in Python up to the ptr member. On 32-bit platforms (&lt;em&gt;i.e.&lt;/em&gt; if &lt;a href=&quot;c-api.config#c.NPY_SIZEOF_INT&quot;&gt;&lt;code&gt;NPY_SIZEOF_INT&lt;/code&gt;&lt;/a&gt; == &lt;code&gt;NPY_SIZEOF_INTP&lt;/code&gt;), the len member also matches an equivalent member of the buffer object. It is useful to represent a generic single-segment chunk of memory.</source>
          <target state="translated">Это эквивалентно структуре объекта буфера в Python до члена ptr. На 32-битных платформах ( &lt;em&gt;т.е.&lt;/em&gt; если &lt;a href=&quot;c-api.config#c.NPY_SIZEOF_INT&quot;&gt; &lt;code&gt;NPY_SIZEOF_INT&lt;/code&gt; &lt;/a&gt; == &lt;code&gt;NPY_SIZEOF_INTP&lt;/code&gt; ) член len также соответствует эквивалентному члену объекта буфера. Полезно представить общий односегментный фрагмент памяти.</target>
        </trans-unit>
        <trans-unit id="0f80c76f4b696fc66848fb5ef4ea2fb36f89e0f9" translate="yes" xml:space="preserve">
          <source>This is equivalent to the buffer object structure in Python up to the ptr member. On 32-bit platforms (&lt;em&gt;i.e.&lt;/em&gt; if &lt;a href=&quot;config#c.NPY_SIZEOF_INT&quot;&gt;&lt;code&gt;NPY_SIZEOF_INT&lt;/code&gt;&lt;/a&gt; == &lt;code&gt;NPY_SIZEOF_INTP&lt;/code&gt;), the len member also matches an equivalent member of the buffer object. It is useful to represent a generic single-segment chunk of memory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c4a19f41f357e975c7ecf272280bda06a0a7837" translate="yes" xml:space="preserve">
          <source>This is equivalent to:</source>
          <target state="translated">Это эквивалентно:</target>
        </trans-unit>
        <trans-unit id="71a0da6263af85d6d95df709a66cce1cab814a13" translate="yes" xml:space="preserve">
          <source>This is for output arrays, and requires that the flag &lt;a href=&quot;#c.NPY_ITER_WRITEONLY&quot;&gt;&lt;code&gt;NPY_ITER_WRITEONLY&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#c.NPY_ITER_READWRITE&quot;&gt;&lt;code&gt;NPY_ITER_READWRITE&lt;/code&gt;&lt;/a&gt; be set. If &lt;code&gt;op[i]&lt;/code&gt; is NULL, creates a new array with the final broadcast dimensions, and a layout matching the iteration order of the iterator.</source>
          <target state="translated">Это для выходных массивов и требует, чтобы был установлен флаг &lt;a href=&quot;#c.NPY_ITER_WRITEONLY&quot;&gt; &lt;code&gt;NPY_ITER_WRITEONLY&lt;/code&gt; &lt;/a&gt; или &lt;a href=&quot;#c.NPY_ITER_READWRITE&quot;&gt; &lt;code&gt;NPY_ITER_READWRITE&lt;/code&gt; &lt;/a&gt; . Если &lt;code&gt;op[i]&lt;/code&gt; равен NULL, создает новый массив с конечными размерами широковещательной рассылки и компоновкой, соответствующей порядку итераций итератора.</target>
        </trans-unit>
        <trans-unit id="e43476e1c5b08d4915c75da838fbd060f4d5522a" translate="yes" xml:space="preserve">
          <source>This is how subclasses of the ndarray class are able to return views that preserve the class type. When taking a view, the standard ndarray machinery creates the new ndarray object with something like:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="271064c73ce5e7dc4de339611f7b4db1a780a7f2" translate="yes" xml:space="preserve">
          <source>This is implemented using the &lt;code&gt;_geev&lt;/code&gt; LAPACK routines which compute the eigenvalues and eigenvectors of general square arrays.</source>
          <target state="translated">Это реализуется с помощью подпрограмм &lt;code&gt;_geev&lt;/code&gt; LAPACK, которые вычисляют собственные значения и собственные векторы квадратных массивов общего вида.</target>
        </trans-unit>
        <trans-unit id="caec4ff4a054237a51c7a499531b302398f70bf8" translate="yes" xml:space="preserve">
          <source>This is indicated in the documentation via input parameter specifications such as &lt;code&gt;a : (..., M, M) array_like&lt;/code&gt;. This means that if for instance given an input array &lt;code&gt;a.shape == (N, M, M)&lt;/code&gt;, it is interpreted as a &amp;ldquo;stack&amp;rdquo; of N matrices, each of size M-by-M. Similar specification applies to return values, for instance the determinant has &lt;code&gt;det : (...)&lt;/code&gt; and will in this case return an array of shape &lt;code&gt;det(a).shape == (N,)&lt;/code&gt;. This generalizes to linear algebra operations on higher-dimensional arrays: the last 1 or 2 dimensions of a multidimensional array are interpreted as vectors or matrices, as appropriate for each operation.</source>
          <target state="translated">Это указано в документации через спецификации входных параметров, такие как &lt;code&gt;a : (..., M, M) array_like&lt;/code&gt; . Это означает, что если, например, задан входной массив &lt;code&gt;a.shape == (N, M, M)&lt;/code&gt; , он интерпретируется как &amp;laquo;стек&amp;raquo; из N матриц, каждая размером M на M. Аналогичная спецификация применяется к возвращаемым значениям, например, определитель имеет &lt;code&gt;det : (...)&lt;/code&gt; и в этом случае будет возвращать массив формы &lt;code&gt;det(a).shape == (N,)&lt;/code&gt; . Это обобщается на операции линейной алгебры над многомерными массивами: последние 1 или 2 измерения многомерного массива интерпретируются как векторы или матрицы в зависимости от каждой операции.</target>
        </trans-unit>
        <trans-unit id="142401db7b88684f56ec37cbd8f1ca65b6bf6771" translate="yes" xml:space="preserve">
          <source>This is intended for working with source directories that are in an SVN repository.</source>
          <target state="translated">Предназначен для работы с исходными каталогами,находящимися в SVN-репозитории.</target>
        </trans-unit>
        <trans-unit id="f497c1d2afa9510500c0e5d52cafff444023b2a6" translate="yes" xml:space="preserve">
          <source>This is needed by all Python objects. It consists of (at least) a reference count member ( &lt;code&gt;ob_refcnt&lt;/code&gt; ) and a pointer to the typeobject ( &lt;code&gt;ob_type&lt;/code&gt; ). (Other elements may also be present if Python was compiled with special options see Include/object.h in the Python source tree for more information). The ob_type member points to a Python type object.</source>
          <target state="translated">Это необходимо всем объектам Python. Он состоит из (как минимум) члена счетчика ссылок ( &lt;code&gt;ob_refcnt&lt;/code&gt; ) и указателя на объект типа ( &lt;code&gt;ob_type&lt;/code&gt; ). (Другие элементы также могут присутствовать, если Python был скомпилирован со специальными параметрами, см. Include / object.h в дереве исходных текстов Python для получения дополнительной информации). Член ob_type указывает на объект типа Python.</target>
        </trans-unit>
        <trans-unit id="1833467ed646c8f15235c25f8dda305acdfb6a3c" translate="yes" xml:space="preserve">
          <source>This is not a comprehensive &lt;a href=&quot;https://git-scm.com/&quot;&gt;git&lt;/a&gt; reference. It&amp;rsquo;s tailored to the &lt;a href=&quot;https://github.com/numpy/numpy&quot;&gt;github&lt;/a&gt; hosting service. You may well find better or quicker ways of getting stuff done with &lt;a href=&quot;https://git-scm.com/&quot;&gt;git&lt;/a&gt;, but these should get you started.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d2a35d83e287759b7b772b39fa92c000861d127f" translate="yes" xml:space="preserve">
          <source>This is often used when a function returns multiple values:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="daec8aebc5133f38a1a0c690c98645fa0bf3cd6e" translate="yes" xml:space="preserve">
          <source>This is particularly useful for evaluating functions of multiple dimensions on a regular grid.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="26d53d8ee495c7f638b914dab0d30642c949b736" translate="yes" xml:space="preserve">
          <source>This is presumably the most common case of large array creation. The details, of course, depend greatly on the format of data on disk and so this section can only give general pointers on how to handle various formats.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd8997d00c105166c9b4b9f773f5d0cdd6fa01f2" translate="yes" xml:space="preserve">
          <source>This is raised when an binary operation is passed Poly objects with different domains.</source>
          <target state="translated">Этот параметр повышается,когда передается двоичная операция Poly объектов с разными доменами.</target>
        </trans-unit>
        <trans-unit id="e57f721854d8f362e4016c48c315f6301f247f80" translate="yes" xml:space="preserve">
          <source>This is really &lt;a href=&quot;numpy.fft.irfftn#numpy.fft.irfftn&quot;&gt;&lt;code&gt;irfftn&lt;/code&gt;&lt;/a&gt; with different defaults. For more details see &lt;a href=&quot;numpy.fft.irfftn#numpy.fft.irfftn&quot;&gt;&lt;code&gt;irfftn&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Это действительно &lt;a href=&quot;numpy.fft.irfftn#numpy.fft.irfftn&quot;&gt; &lt;code&gt;irfftn&lt;/code&gt; &lt;/a&gt; с разными значениями по умолчанию. Подробнее см. &lt;a href=&quot;numpy.fft.irfftn#numpy.fft.irfftn&quot;&gt; &lt;code&gt;irfftn&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ed9f359368f007790ca5657cc8ec4082492a200b" translate="yes" xml:space="preserve">
          <source>This is really just &lt;a href=&quot;numpy.fft.rfftn#numpy.fft.rfftn&quot;&gt;&lt;code&gt;rfftn&lt;/code&gt;&lt;/a&gt; with different default behavior. For more details see &lt;a href=&quot;numpy.fft.rfftn#numpy.fft.rfftn&quot;&gt;&lt;code&gt;rfftn&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">На самом деле это просто &lt;a href=&quot;numpy.fft.rfftn#numpy.fft.rfftn&quot;&gt; &lt;code&gt;rfftn&lt;/code&gt; &lt;/a&gt; с другим поведением по умолчанию. Подробнее см. &lt;a href=&quot;numpy.fft.rfftn#numpy.fft.rfftn&quot;&gt; &lt;code&gt;rfftn&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="77938c782ff5f0e5fde7cba046a7d880a01771f8" translate="yes" xml:space="preserve">
          <source>This is reasonable enough, but watch out if you want to use Python&amp;rsquo;s &lt;code&gt;+=&lt;/code&gt; construct, as it may not do what you expect:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ef26806f6ea74b6485ab483c2778eff715e4572" translate="yes" xml:space="preserve">
          <source>This is short-hand for &lt;code&gt;np.r_['-1,2,0', index expression]&lt;/code&gt;, which is useful because of its common occurrence. In particular, arrays will be stacked along their last axis after being upgraded to at least 2-D with 1&amp;rsquo;s post-pended to the shape (column vectors made out of 1-D arrays).</source>
          <target state="translated">Это сокращение от &lt;code&gt;np.r_['-1,2,0', index expression]&lt;/code&gt; , которое полезно из-за его частого появления. В частности, массивы будут укладываться вдоль своей последней оси после обновления как минимум до 2-мерного с добавлением единицы к форме (векторы-столбцы, составленные из 1-мерных массивов).</target>
        </trans-unit>
        <trans-unit id="1c88394abdc65a1b05a8dd5d8683693375531a89" translate="yes" xml:space="preserve">
          <source>This is similar to &lt;a href=&quot;#c.PyArray_NewFromDescr&quot;&gt;&lt;code&gt;PyArray_NewFromDescr&lt;/code&gt;&lt;/a&gt; (&amp;hellip;) except you specify the data-type descriptor with &lt;em&gt;type_num&lt;/em&gt; and &lt;em&gt;itemsize&lt;/em&gt;, where &lt;em&gt;type_num&lt;/em&gt; corresponds to a builtin (or user-defined) type. If the type always has the same number of bytes, then itemsize is ignored. Otherwise, itemsize specifies the particular size of this array.</source>
          <target state="translated">Это похоже на &lt;a href=&quot;#c.PyArray_NewFromDescr&quot;&gt; &lt;code&gt;PyArray_NewFromDescr&lt;/code&gt; &lt;/a&gt; (&amp;hellip;), за исключением того, что вы указываете дескриптор типа данных с &lt;em&gt;type_num&lt;/em&gt; и &lt;em&gt;itemsize&lt;/em&gt; , где &lt;em&gt;type_num&lt;/em&gt; соответствует встроенному (или определяемому пользователем) типу. Если тип всегда имеет одинаковое количество байтов, то размер элемента игнорируется. В противном случае itemsize указывает конкретный размер этого массива.</target>
        </trans-unit>
        <trans-unit id="ed43500d52b0e3a9d4bae70ddb5bfbe100ff1dd8" translate="yes" xml:space="preserve">
          <source>This is similar to &lt;a href=&quot;numpy.logspace#numpy.logspace&quot;&gt;&lt;code&gt;logspace&lt;/code&gt;&lt;/a&gt;, but with endpoints specified directly. Each output sample is a constant multiple of the previous.</source>
          <target state="translated">Это похоже на &lt;a href=&quot;numpy.logspace#numpy.logspace&quot;&gt; &lt;code&gt;logspace&lt;/code&gt; &lt;/a&gt; , но с прямым указанием конечных точек. Каждый выходной отсчет является постоянным кратным предыдущему.</target>
        </trans-unit>
        <trans-unit id="c5fcd33629df929b0bdb1a57cfbe776ef13fe120" translate="yes" xml:space="preserve">
          <source>This is similar to &lt;code&gt;apply_along_axis&lt;/code&gt;, but treats the fields of a structured array as an extra axis. The fields are all first cast to a common type following the type-promotion rules from &lt;a href=&quot;../reference/generated/numpy.result_type#numpy.result_type&quot;&gt;&lt;code&gt;numpy.result_type&lt;/code&gt;&lt;/a&gt; applied to the field&amp;rsquo;s dtypes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="852b3e753a1b8cdcb6346c93877a110d2d715f72" translate="yes" xml:space="preserve">
          <source>This is similar to choose or select, except that functions are evaluated on elements of &lt;code&gt;x&lt;/code&gt; that satisfy the corresponding condition from &lt;code&gt;condlist&lt;/code&gt;.</source>
          <target state="translated">Это похоже на select или select, за исключением того, что функции оцениваются для элементов &lt;code&gt;x&lt;/code&gt; , которые удовлетворяют соответствующему условию из &lt;code&gt;condlist&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2c3a50a4a39023a7aa06d7ec91f3ecdac2409160" translate="yes" xml:space="preserve">
          <source>This is the &amp;ldquo;average&amp;rdquo; periodically compounded rate of return that gives a net present value of 0.0; for a more complete explanation, see Notes below.</source>
          <target state="translated">Это &amp;laquo;средняя&amp;raquo; периодически рассчитываемая ставка доходности, которая дает чистую приведенную стоимость 0,0; для более полного объяснения см. Примечания ниже.</target>
        </trans-unit>
        <trans-unit id="0dbc891d865ae88284f9bfa0a0edbf0c765484c8" translate="yes" xml:space="preserve">
          <source>This is the 1-d core function used by the dynamic ufuncs created by umath.frompyfunc(function, nin, nout). In this case &lt;em&gt;func&lt;/em&gt; is a pointer to a &lt;a href=&quot;#c.PyUFunc_PyFuncData&quot;&gt;&lt;code&gt;PyUFunc_PyFuncData&lt;/code&gt;&lt;/a&gt; structure which has definition</source>
          <target state="translated">Это 1-мерная основная функция, используемая динамическими ufuncs, созданными umath.frompyfunc (function, nin, nout). В этом случае &lt;em&gt;func&lt;/em&gt; - это указатель на структуру &lt;a href=&quot;#c.PyUFunc_PyFuncData&quot;&gt; &lt;code&gt;PyUFunc_PyFuncData&lt;/code&gt; ,&lt;/a&gt; которая имеет определение</target>
        </trans-unit>
        <trans-unit id="692a8cf195747eb5dfe92c87d684aef132c27f68" translate="yes" xml:space="preserve">
          <source>This is the NumPy implementation of the C library function fmod, the remainder has the same sign as the dividend &lt;code&gt;x1&lt;/code&gt;. It is equivalent to the Matlab(TM) &lt;code&gt;rem&lt;/code&gt; function and should not be confused with the Python modulus operator &lt;code&gt;x1 % x2&lt;/code&gt;.</source>
          <target state="translated">Это реализация NumPy функции FMOD библиотеки С, остаток имеет тот же знак, что и дивидендов &lt;code&gt;x1&lt;/code&gt; . Это эквивалентно функции &lt;code&gt;rem&lt;/code&gt; в Matlab (TM), и ее не следует путать с оператором модуля Python &lt;code&gt;x1 % x2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9f70c1d8b15029e4bba377d8eb228f8ad3621041" translate="yes" xml:space="preserve">
          <source>This is the code that handles the situation whenever the input and/or output arrays are either misaligned or of the wrong data-type (including being byte-swapped) from what the underlying 1-D loop expects. The arrays are also assumed to be non-contiguous. The code works very much like the strided-loop except for the inner 1-D loop is modified so that pre-processing is performed on the inputs and post- processing is performed on the outputs in bufsize chunks (where bufsize is a user-settable parameter). The underlying 1-D computational loop is called on data that is copied over (if it needs to be). The setup code and the loop code is considerably more complicated in this case because it has to handle:</source>
          <target state="translated">Это код,который обрабатывает ситуацию,когда входные и/или выходные массивы либо неправильно выровнены,либо имеют неверный тип данных (включая обмен байтами)от того,что ожидает основной 1-D цикл.Массивы также считаются не связанными между собой.Код работает так же,как и strided-loop,за исключением того,что внутренний 1-D цикл модифицирован таким образом,что на входах выполняется предварительная обработка,а на выходах-пост-обработка в bufsize кусках (где bufsize-параметр,устанавливаемый пользователем).Основной 1-D цикл вычислений вызывается на данных,которые копируются (если это необходимо).Код установки и код цикла в этом случае значительно сложнее,так как он должен быть обработан:</target>
        </trans-unit>
        <trans-unit id="97fdbbb09a00c84ec3c672ccc77676c7df568ed7" translate="yes" xml:space="preserve">
          <source>This is the docstring for the example.py module. Modules names should have short, all-lowercase names. The module name may have underscores if this improves readability.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="938b03b0272fe214e0bd4545d8c331ea33459bae" translate="yes" xml:space="preserve">
          <source>This is the exact same method signature for &lt;code&gt;np.sum&lt;/code&gt;, so now if a user calls &lt;code&gt;np.sum&lt;/code&gt; on this object, numpy will call the object&amp;rsquo;s own &lt;code&gt;sum&lt;/code&gt; method and pass in these arguments enumerated above in the signature, and no errors will be raised because the signatures are completely compatible with each other.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="754ab86dfdc616fd9f3289ae80c9fb161f6f47b6" translate="yes" xml:space="preserve">
          <source>This is the main array creation function. Most new arrays are created with this flexible function.</source>
          <target state="translated">Это основная функция создания массивов.Большинство новых массивов создается с помощью этой гибкой функции.</target>
        </trans-unit>
        <trans-unit id="ae96a364309b5dfa1ba1a5f179699cc1e3ea0752" translate="yes" xml:space="preserve">
          <source>This is the main function used to obtain an array from any nested sequence, or object that exposes the array interface, &lt;em&gt;op&lt;/em&gt;. The parameters allow specification of the required &lt;em&gt;dtype&lt;/em&gt;, the minimum (&lt;em&gt;min_depth&lt;/em&gt;) and maximum (&lt;em&gt;max_depth&lt;/em&gt;) number of dimensions acceptable, and other &lt;em&gt;requirements&lt;/em&gt; for the array. This function &lt;strong&gt;steals a reference&lt;/strong&gt; to the dtype argument, which needs to be a &lt;a href=&quot;c-api.types-and-structures#c.PyArray_Descr&quot;&gt;&lt;code&gt;PyArray_Descr&lt;/code&gt;&lt;/a&gt; structure indicating the desired data-type (including required byteorder). The &lt;em&gt;dtype&lt;/em&gt; argument may be &lt;code&gt;NULL&lt;/code&gt;, indicating that any data-type (and byteorder) is acceptable. Unless &lt;a href=&quot;#c.NPY_ARRAY_FORCECAST&quot;&gt;&lt;code&gt;NPY_ARRAY_FORCECAST&lt;/code&gt;&lt;/a&gt; is present in &lt;code&gt;flags&lt;/code&gt;, this call will generate an error if the data type cannot be safely obtained from the object. If you want to use &lt;code&gt;NULL&lt;/code&gt; for the &lt;em&gt;dtype&lt;/em&gt; and ensure the array is notswapped then use &lt;a href=&quot;#c.PyArray_CheckFromAny&quot;&gt;&lt;code&gt;PyArray_CheckFromAny&lt;/code&gt;&lt;/a&gt;. A value of 0 for either of the depth parameters causes the parameter to be ignored. Any of the following array flags can be added (&lt;em&gt;e.g.&lt;/em&gt; using |) to get the &lt;em&gt;requirements&lt;/em&gt; argument. If your code can handle general (&lt;em&gt;e.g.&lt;/em&gt; strided, byte-swapped, or unaligned arrays) then &lt;em&gt;requirements&lt;/em&gt; may be 0. Also, if &lt;em&gt;op&lt;/em&gt; is not already an array (or does not expose the array interface), then a new array will be created (and filled from &lt;em&gt;op&lt;/em&gt; using the sequence protocol). The new array will have &lt;a href=&quot;#c.NPY_ARRAY_DEFAULT&quot;&gt;&lt;code&gt;NPY_ARRAY_DEFAULT&lt;/code&gt;&lt;/a&gt; as its flags member. The &lt;em&gt;context&lt;/em&gt; argument is passed to the &lt;a href=&quot;arrays.classes#numpy.class.__array__&quot;&gt;&lt;code&gt;__array__&lt;/code&gt;&lt;/a&gt; method of &lt;em&gt;op&lt;/em&gt; and is only used if the array is constructed that way. Almost always this parameter is &lt;code&gt;NULL&lt;/code&gt;.</source>
          <target state="translated">Это основная функция, используемая для получения массива из любой вложенной последовательности или объекта, который предоставляет интерфейс массива, &lt;em&gt;op&lt;/em&gt; . Параметры позволяют &lt;em&gt;указать&lt;/em&gt; требуемый &lt;em&gt;dtype&lt;/em&gt; , минимальное ( &lt;em&gt;min_depth&lt;/em&gt; ) и максимальное ( &lt;em&gt;max_depth&lt;/em&gt; ) количество допустимых измерений и другие &lt;em&gt;требования&lt;/em&gt; к массиву. Эта функция &lt;strong&gt;крадет ссылку&lt;/strong&gt; на аргумент dtype, который должен быть структурой &lt;a href=&quot;c-api.types-and-structures#c.PyArray_Descr&quot;&gt; &lt;code&gt;PyArray_Descr&lt;/code&gt; ,&lt;/a&gt; указывающей желаемый тип данных (включая требуемый byteorder). &lt;em&gt;DTYPE&lt;/em&gt; аргумент может быть &lt;code&gt;NULL&lt;/code&gt; , указывая , что любой тип данных (и порядком байтов) является приемлемым. Если только &lt;a href=&quot;#c.NPY_ARRAY_FORCECAST&quot;&gt; &lt;code&gt;NPY_ARRAY_FORCECAST&lt;/code&gt; &lt;/a&gt;присутствует в &lt;code&gt;flags&lt;/code&gt; , этот вызов вызовет ошибку, если тип данных не может быть безопасно получен из объекта. Если вы хотите использовать &lt;code&gt;NULL&lt;/code&gt; для &lt;em&gt;dtype&lt;/em&gt; и убедиться, что массив не заменен, используйте &lt;a href=&quot;#c.PyArray_CheckFromAny&quot;&gt; &lt;code&gt;PyArray_CheckFromAny&lt;/code&gt; &lt;/a&gt; . Значение 0 для любого из параметров глубины приводит к тому, что параметр игнорируется. Для получения аргумента &lt;em&gt;требований&lt;/em&gt; можно добавить любой из следующих флагов массива ( &lt;em&gt;например,&lt;/em&gt; с помощью |) . Если ваш код может обрабатывать общие ( &lt;em&gt;например,&lt;/em&gt; массивы с последовательным, байтовым переключением или невыровненные массивы), тогда &lt;em&gt;требования&lt;/em&gt; могут быть равны 0. Также, если &lt;em&gt;op&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;еще не является массивом (или не предоставляет интерфейс массива), тогда будет создан новый массив (и заполнен из &lt;em&gt;op&lt;/em&gt; с использованием протокола последовательности). Новый массив будет иметь &lt;a href=&quot;#c.NPY_ARRAY_DEFAULT&quot;&gt; &lt;code&gt;NPY_ARRAY_DEFAULT&lt;/code&gt; в&lt;/a&gt; качестве члена флагов. &lt;em&gt;Контекст&lt;/em&gt; аргумент передается &lt;a href=&quot;arrays.classes#numpy.class.__array__&quot;&gt; &lt;code&gt;__array__&lt;/code&gt; &lt;/a&gt; метод &lt;em&gt;оп&lt;/em&gt; и используется только если массив построен таким образом. Почти всегда этот параметр равен &lt;code&gt;NULL&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4ef891de4e312961f5d43ee05c17aa291119de54" translate="yes" xml:space="preserve">
          <source>This is the main function used to obtain an array from any nested sequence, or object that exposes the array interface, &lt;em&gt;op&lt;/em&gt;. The parameters allow specification of the required &lt;em&gt;dtype&lt;/em&gt;, the minimum (&lt;em&gt;min_depth&lt;/em&gt;) and maximum (&lt;em&gt;max_depth&lt;/em&gt;) number of dimensions acceptable, and other &lt;em&gt;requirements&lt;/em&gt; for the array. This function &lt;strong&gt;steals a reference&lt;/strong&gt; to the dtype argument, which needs to be a &lt;a href=&quot;types-and-structures#c.PyArray_Descr&quot;&gt;&lt;code&gt;PyArray_Descr&lt;/code&gt;&lt;/a&gt; structure indicating the desired data-type (including required byteorder). The &lt;em&gt;dtype&lt;/em&gt; argument may be &lt;code&gt;NULL&lt;/code&gt;, indicating that any data-type (and byteorder) is acceptable. Unless &lt;a href=&quot;#c.NPY_ARRAY_FORCECAST&quot;&gt;&lt;code&gt;NPY_ARRAY_FORCECAST&lt;/code&gt;&lt;/a&gt; is present in &lt;code&gt;flags&lt;/code&gt;, this call will generate an error if the data type cannot be safely obtained from the object. If you want to use &lt;code&gt;NULL&lt;/code&gt; for the &lt;em&gt;dtype&lt;/em&gt; and ensure the array is notswapped then use &lt;a href=&quot;#c.PyArray_CheckFromAny&quot;&gt;&lt;code&gt;PyArray_CheckFromAny&lt;/code&gt;&lt;/a&gt;. A value of 0 for either of the depth parameters causes the parameter to be ignored. Any of the following array flags can be added (&lt;em&gt;e.g.&lt;/em&gt; using |) to get the &lt;em&gt;requirements&lt;/em&gt; argument. If your code can handle general (&lt;em&gt;e.g.&lt;/em&gt; strided, byte-swapped, or unaligned arrays) then &lt;em&gt;requirements&lt;/em&gt; may be 0. Also, if &lt;em&gt;op&lt;/em&gt; is not already an array (or does not expose the array interface), then a new array will be created (and filled from &lt;em&gt;op&lt;/em&gt; using the sequence protocol). The new array will have &lt;a href=&quot;#c.NPY_ARRAY_DEFAULT&quot;&gt;&lt;code&gt;NPY_ARRAY_DEFAULT&lt;/code&gt;&lt;/a&gt; as its flags member. The &lt;em&gt;context&lt;/em&gt; argument is unused.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0edcab26afcb3f2afd03c8c948c52b8fae9f82e5" translate="yes" xml:space="preserve">
          <source>This is the manual followed by NumPy&amp;rsquo;s Code of Conduct Committee. It&amp;rsquo;s used when we respond to an issue to make sure we&amp;rsquo;re consistent and fair.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ec8c6b5a6fa5ea604ca73fde0faa7f48e61f60d" translate="yes" xml:space="preserve">
          <source>This is the masked array version of &lt;a href=&quot;numpy.power#numpy.power&quot;&gt;&lt;code&gt;numpy.power&lt;/code&gt;&lt;/a&gt;. For details see &lt;a href=&quot;numpy.power#numpy.power&quot;&gt;&lt;code&gt;numpy.power&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Это версия &lt;a href=&quot;numpy.power#numpy.power&quot;&gt; &lt;code&gt;numpy.power&lt;/code&gt; &lt;/a&gt; с маскированным массивом . Подробнее см. &lt;a href=&quot;numpy.power#numpy.power&quot;&gt; &lt;code&gt;numpy.power&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c5b5fdafede3bb67234ee18c22a5b997e8095961" translate="yes" xml:space="preserve">
          <source>This is the masked array version of &lt;code&gt;lib.index_tricks.RClass&lt;/code&gt;.</source>
          <target state="translated">Это версия &lt;code&gt;lib.index_tricks.RClass&lt;/code&gt; в виде замаскированного массива .</target>
        </trans-unit>
        <trans-unit id="bf3cf3ae9cebee8b7306a5e44915e23de00facf1" translate="yes" xml:space="preserve">
          <source>This is the masked equivalent of the &lt;a href=&quot;numpy.resize#numpy.resize&quot;&gt;&lt;code&gt;numpy.resize&lt;/code&gt;&lt;/a&gt; function. The new array is filled with repeated copies of &lt;code&gt;x&lt;/code&gt; (in the order that the data are stored in memory). If &lt;code&gt;x&lt;/code&gt; is masked, the new array will be masked, and the new mask will be a repetition of the old one.</source>
          <target state="translated">Это замаскированный эквивалент функции &lt;a href=&quot;numpy.resize#numpy.resize&quot;&gt; &lt;code&gt;numpy.resize&lt;/code&gt; &lt;/a&gt; . Новый массив заполняется повторяющимися копиями &lt;code&gt;x&lt;/code&gt; (в том порядке, в котором данные хранятся в памяти). Если &lt;code&gt;x&lt;/code&gt; замаскирован, новый массив будет замаскирован, а новая маска будет повторением старой.</target>
        </trans-unit>
        <trans-unit id="0cb42e32affa717b335b3825c72824c3d8e04997" translate="yes" xml:space="preserve">
          <source>This is the most flexible form of specification since it allows control over the byte-offsets of the fields and the itemsize of the structure.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e638e46153cb5bd9d2b2cfadb202d5a4f7f60071" translate="yes" xml:space="preserve">
          <source>This is the same as &lt;a href=&quot;numpy.ndarray.all#numpy.ndarray.all&quot;&gt;&lt;code&gt;ndarray.all&lt;/code&gt;&lt;/a&gt;, but it returns a &lt;a href=&quot;numpy.matrix#numpy.matrix&quot;&gt;&lt;code&gt;matrix&lt;/code&gt;&lt;/a&gt; object.</source>
          <target state="translated">Это то же самое, что и &lt;a href=&quot;numpy.ndarray.all#numpy.ndarray.all&quot;&gt; &lt;code&gt;ndarray.all&lt;/code&gt; &lt;/a&gt; , но возвращает объект &lt;a href=&quot;numpy.matrix#numpy.matrix&quot;&gt; &lt;code&gt;matrix&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b28c44c91a00424416f03ba6b4985acf74627eb2" translate="yes" xml:space="preserve">
          <source>This is the same as &lt;a href=&quot;numpy.ndarray.argmax#numpy.ndarray.argmax&quot;&gt;&lt;code&gt;ndarray.argmax&lt;/code&gt;&lt;/a&gt;, but returns a &lt;a href=&quot;numpy.matrix#numpy.matrix&quot;&gt;&lt;code&gt;matrix&lt;/code&gt;&lt;/a&gt; object where &lt;a href=&quot;numpy.ndarray.argmax#numpy.ndarray.argmax&quot;&gt;&lt;code&gt;ndarray.argmax&lt;/code&gt;&lt;/a&gt; would return an &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Это то же самое, что и &lt;a href=&quot;numpy.ndarray.argmax#numpy.ndarray.argmax&quot;&gt; &lt;code&gt;ndarray.argmax&lt;/code&gt; &lt;/a&gt; , но возвращает объект &lt;a href=&quot;numpy.matrix#numpy.matrix&quot;&gt; &lt;code&gt;matrix&lt;/code&gt; &lt;/a&gt; где &lt;a href=&quot;numpy.ndarray.argmax#numpy.ndarray.argmax&quot;&gt; &lt;code&gt;ndarray.argmax&lt;/code&gt; &lt;/a&gt; вернет &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="22b8e33a3b4d40024b90c85a13a94be90c9158a1" translate="yes" xml:space="preserve">
          <source>This is the same as &lt;a href=&quot;numpy.ndarray.argmin#numpy.ndarray.argmin&quot;&gt;&lt;code&gt;ndarray.argmin&lt;/code&gt;&lt;/a&gt;, but returns a &lt;a href=&quot;numpy.matrix#numpy.matrix&quot;&gt;&lt;code&gt;matrix&lt;/code&gt;&lt;/a&gt; object where &lt;a href=&quot;numpy.ndarray.argmin#numpy.ndarray.argmin&quot;&gt;&lt;code&gt;ndarray.argmin&lt;/code&gt;&lt;/a&gt; would return an &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Это то же самое, что и &lt;a href=&quot;numpy.ndarray.argmin#numpy.ndarray.argmin&quot;&gt; &lt;code&gt;ndarray.argmin&lt;/code&gt; &lt;/a&gt; , но возвращает объект &lt;a href=&quot;numpy.matrix#numpy.matrix&quot;&gt; &lt;code&gt;matrix&lt;/code&gt; &lt;/a&gt; где &lt;a href=&quot;numpy.ndarray.argmin#numpy.ndarray.argmin&quot;&gt; &lt;code&gt;ndarray.argmin&lt;/code&gt; &lt;/a&gt; вернет &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b1090f814c7b352e9c36a05ce2322d963cddbde3" translate="yes" xml:space="preserve">
          <source>This is the same as &lt;a href=&quot;numpy.ndarray.max#numpy.ndarray.max&quot;&gt;&lt;code&gt;ndarray.max&lt;/code&gt;&lt;/a&gt;, but returns a &lt;a href=&quot;numpy.matrix#numpy.matrix&quot;&gt;&lt;code&gt;matrix&lt;/code&gt;&lt;/a&gt; object where &lt;a href=&quot;numpy.ndarray.max#numpy.ndarray.max&quot;&gt;&lt;code&gt;ndarray.max&lt;/code&gt;&lt;/a&gt; would return an ndarray.</source>
          <target state="translated">Это то же самое, что и &lt;a href=&quot;numpy.ndarray.max#numpy.ndarray.max&quot;&gt; &lt;code&gt;ndarray.max&lt;/code&gt; &lt;/a&gt; , но возвращает объект &lt;a href=&quot;numpy.matrix#numpy.matrix&quot;&gt; &lt;code&gt;matrix&lt;/code&gt; &lt;/a&gt; где &lt;a href=&quot;numpy.ndarray.max#numpy.ndarray.max&quot;&gt; &lt;code&gt;ndarray.max&lt;/code&gt; &lt;/a&gt; вернет ndarray.</target>
        </trans-unit>
        <trans-unit id="74e44d918d1f15516605ec010845ff539cc17530" translate="yes" xml:space="preserve">
          <source>This is the same as &lt;a href=&quot;numpy.ndarray.min#numpy.ndarray.min&quot;&gt;&lt;code&gt;ndarray.min&lt;/code&gt;&lt;/a&gt;, but returns a &lt;a href=&quot;numpy.matrix#numpy.matrix&quot;&gt;&lt;code&gt;matrix&lt;/code&gt;&lt;/a&gt; object where &lt;a href=&quot;numpy.ndarray.min#numpy.ndarray.min&quot;&gt;&lt;code&gt;ndarray.min&lt;/code&gt;&lt;/a&gt; would return an ndarray.</source>
          <target state="translated">Это то же самое, что и &lt;a href=&quot;numpy.ndarray.min#numpy.ndarray.min&quot;&gt; &lt;code&gt;ndarray.min&lt;/code&gt; &lt;/a&gt; , но возвращает объект &lt;a href=&quot;numpy.matrix#numpy.matrix&quot;&gt; &lt;code&gt;matrix&lt;/code&gt; &lt;/a&gt; где &lt;a href=&quot;numpy.ndarray.min#numpy.ndarray.min&quot;&gt; &lt;code&gt;ndarray.min&lt;/code&gt; &lt;/a&gt; вернет ndarray.</target>
        </trans-unit>
        <trans-unit id="124e720446d4f3612122d427a64991837042df14" translate="yes" xml:space="preserve">
          <source>This is the same as &lt;a href=&quot;numpy.ndarray.std#numpy.ndarray.std&quot;&gt;&lt;code&gt;ndarray.std&lt;/code&gt;&lt;/a&gt;, except that where an &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt; would be returned, a &lt;a href=&quot;numpy.matrix#numpy.matrix&quot;&gt;&lt;code&gt;matrix&lt;/code&gt;&lt;/a&gt; object is returned instead.</source>
          <target state="translated">Это то же самое, что и &lt;a href=&quot;numpy.ndarray.std#numpy.ndarray.std&quot;&gt; &lt;code&gt;ndarray.std&lt;/code&gt; &lt;/a&gt; , за исключением того, что &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt; возвращается объект &lt;a href=&quot;numpy.matrix#numpy.matrix&quot;&gt; &lt;code&gt;matrix&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a0acdb03a11a0405720f9b33ec10bd3e67d6e4fa" translate="yes" xml:space="preserve">
          <source>This is the same as &lt;a href=&quot;numpy.ndarray.sum#numpy.ndarray.sum&quot;&gt;&lt;code&gt;ndarray.sum&lt;/code&gt;&lt;/a&gt;, except that where an &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt; would be returned, a &lt;a href=&quot;numpy.matrix#numpy.matrix&quot;&gt;&lt;code&gt;matrix&lt;/code&gt;&lt;/a&gt; object is returned instead.</source>
          <target state="translated">Это то же самое, что и &lt;a href=&quot;numpy.ndarray.sum#numpy.ndarray.sum&quot;&gt; &lt;code&gt;ndarray.sum&lt;/code&gt; &lt;/a&gt; , за исключением того, что &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt; возвращается объект &lt;a href=&quot;numpy.matrix#numpy.matrix&quot;&gt; &lt;code&gt;matrix&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1b894bff66f53b91713c65daaeb95b50cb72fdfc" translate="yes" xml:space="preserve">
          <source>This is the same as &lt;a href=&quot;numpy.ndarray.var#numpy.ndarray.var&quot;&gt;&lt;code&gt;ndarray.var&lt;/code&gt;&lt;/a&gt;, except that where an &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt; would be returned, a &lt;a href=&quot;numpy.matrix#numpy.matrix&quot;&gt;&lt;code&gt;matrix&lt;/code&gt;&lt;/a&gt; object is returned instead.</source>
          <target state="translated">Это то же самое, что и &lt;a href=&quot;numpy.ndarray.var#numpy.ndarray.var&quot;&gt; &lt;code&gt;ndarray.var&lt;/code&gt; &lt;/a&gt; , за исключением того, что &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt; возвращается объект &lt;a href=&quot;numpy.matrix#numpy.matrix&quot;&gt; &lt;code&gt;matrix&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d6c0a4b3ef29201f690f9b9b88a69b8608d63748" translate="yes" xml:space="preserve">
          <source>This is the same for half-precision float as npy_nextafter and npy_nextafterf described in the low-level floating point section.</source>
          <target state="translated">Это то же самое для половинчатого float,что и npy_nextafter и npy_nextafterf,описанные в разделе о низкоуровневых плавающих точках.</target>
        </trans-unit>
        <trans-unit id="5a28a11e64cd4476f1fd45344cb04aff7bece602" translate="yes" xml:space="preserve">
          <source>This is the same for half-precision float as npy_spacing and npy_spacingf described in the low-level floating point section.</source>
          <target state="translated">Это то же самое для половинчатого float,что и npy_spacing и npy_spacingf,описанные в разделе о низкоуровневых плавающих точках.</target>
        </trans-unit>
        <trans-unit id="69592e67862b42a94f582425221058b3b2e662f2" translate="yes" xml:space="preserve">
          <source>This is the same polynomial as obtained by:</source>
          <target state="translated">Это тот же самый полином,что и полученный:</target>
        </trans-unit>
        <trans-unit id="8f841f69094513c4d7f4558bcdd113fb62e5f1f7" translate="yes" xml:space="preserve">
          <source>This is the simplest case of all. The ufunc is executed by calling the underlying 1-D loop exactly once. This is possible only when we have aligned data of the correct type (including byte-order) for both input and output and all arrays have uniform strides (either contiguous, 0-D, or 1-D). In this case, the 1-D computational loop is called once to compute the calculation for the entire array. Note that the hardware error flags are only checked after the entire calculation is complete.</source>
          <target state="translated">Это самый простой случай из всех.ufunc выполняется вызовом базового 1-D цикла ровно один раз.Это возможно только в том случае,если мы выровняли данные правильного типа (включая порядок байт)как для входа,так и для выхода,и все массивы имеют равномерные шаги (либо смежные,0-D,либо 1-D).В этом случае 1-D вычислительный цикл вызывается один раз для вычисления для всего массива.Обратите внимание,что флаги аппаратных ошибок проверяются только после завершения всего вычисления.</target>
        </trans-unit>
        <trans-unit id="963cd66868f04208a7a1c2183e363716e0ef0cf2" translate="yes" xml:space="preserve">
          <source>This is the type which exposes the iterator to Python. Currently, no API is exposed which provides access to the values of a Python-created iterator. If an iterator is created in Python, it must be used in Python and vice versa. Such an API will likely be created in a future version.</source>
          <target state="translated">Это тип,который выставляет итератор на Питон.В настоящее время ни один API не подвергается экспозиции,которая обеспечивала бы доступ к значениям итератора,созданного на питоне.Если итератор создан на Python,то он должен быть использован на Python и наоборот.Такой API,скорее всего,будет создан в будущей версии.</target>
        </trans-unit>
        <trans-unit id="4b42439256132aabca2f53b261c973f7c679d369" translate="yes" xml:space="preserve">
          <source>This is useful for setting up an accumulation loop, for example. The iterator can first be created with all the dimensions, including the accumulation axis, so that the output gets created correctly. Then, the accumulation axis can be removed, and the calculation done in a nested fashion.</source>
          <target state="translated">Это полезно,например,для настройки накопительного контура.Сначала можно создать итератор со всеми размерами,включая ось накопления,чтобы выход был создан корректно.Затем можно удалить ось накопления и выполнить вычисление по вложенности.</target>
        </trans-unit>
        <trans-unit id="5300cb088270de52a08527e24f73ff59ea30c2bb" translate="yes" xml:space="preserve">
          <source>This is useful in a setup.py script for adding sub-packages to a package.</source>
          <target state="translated">Это полезно в скрипте setup.py для добавления подпакетов в пакет.</target>
        </trans-unit>
        <trans-unit id="6e4aa46e2220dff2f0d0703b94a0af6befef5473" translate="yes" xml:space="preserve">
          <source>This is wonderful because the function writer doesn&amp;rsquo;t have to manually propagate infs or nans.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="82959a96175cd052449eddf58c5c4610e0b21bd3" translate="yes" xml:space="preserve">
          <source>This iterates over matching 1d slices oriented along the specified axis in the index and data arrays, and uses the former to look up values in the latter. These slices can be different lengths.</source>
          <target state="translated">При этом выполняется итерация при совпадении 1d срезов,ориентированных вдоль указанной оси в индексном массиве и массиве данных,и поиск значений во втором случае осуществляется с помощью первого среза.Эти срезы могут иметь разную длину.</target>
        </trans-unit>
        <trans-unit id="5c175a7e11a936be20457fa33dc8778b062c8741" translate="yes" xml:space="preserve">
          <source>This iterates over matching 1d slices oriented along the specified axis in the index and data arrays, and uses the former to place values into the latter. These slices can be different lengths.</source>
          <target state="translated">При этом происходит итерация при совпадении 1d срезов,ориентированных вдоль указанной оси в индексном массиве и массиве данных,и использование первого среза для размещения значений во втором.Эти срезы могут иметь разную длину.</target>
        </trans-unit>
        <trans-unit id="1d9086a3e8f6e523e455adb859a4bc6cbea3019a" translate="yes" xml:space="preserve">
          <source>This iterator returns elements of the array to be iterated over in &lt;a href=&quot;numpy.lib.arrayterator#numpy.lib.Arrayterator&quot;&gt;&lt;code&gt;Arrayterator&lt;/code&gt;&lt;/a&gt; one by one. It is similar to &lt;code&gt;flatiter&lt;/code&gt;.</source>
          <target state="translated">Этот итератор возвращает элементы массива, которые будут повторяться в &lt;a href=&quot;numpy.lib.arrayterator#numpy.lib.Arrayterator&quot;&gt; &lt;code&gt;Arrayterator&lt;/code&gt; &lt;/a&gt; один за другим. Это похоже на &lt;code&gt;flatiter&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9621dd1cff206294072ec88c5bdff12776a1ac23" translate="yes" xml:space="preserve">
          <source>This just returns the value &lt;a href=&quot;#c.NPY_VERSION&quot;&gt;&lt;code&gt;NPY_VERSION&lt;/code&gt;&lt;/a&gt;. &lt;a href=&quot;#c.NPY_VERSION&quot;&gt;&lt;code&gt;NPY_VERSION&lt;/code&gt;&lt;/a&gt; changes whenever a backward incompatible change at the ABI level. Because it is in the C-API, however, comparing the output of this function from the value defined in the current header gives a way to test if the C-API has changed thus requiring a re-compilation of extension modules that use the C-API. This is automatically checked in the function &lt;a href=&quot;#c.import_array&quot;&gt;&lt;code&gt;import_array&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Это просто возвращает значение &lt;a href=&quot;#c.NPY_VERSION&quot;&gt; &lt;code&gt;NPY_VERSION&lt;/code&gt; &lt;/a&gt; . &lt;a href=&quot;#c.NPY_VERSION&quot;&gt; &lt;code&gt;NPY_VERSION&lt;/code&gt; &lt;/a&gt; изменяется всякий раз, когда происходит обратное несовместимое изменение на уровне ABI. Однако, поскольку он находится в C-API, сравнение вывода этой функции со значением, определенным в текущем заголовке, дает возможность проверить, изменился ли C-API, что требует повторной компиляции модулей расширения, которые используют C -API. Это автоматически проверяется функцией &lt;a href=&quot;#c.import_array&quot;&gt; &lt;code&gt;import_array&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="75e16e673218df8f16a0a1029a429a437c420b9d" translate="yes" xml:space="preserve">
          <source>This just returns the value &lt;code&gt;NPY_FEATURE_VERSION&lt;/code&gt;. &lt;code&gt;NPY_FEATURE_VERSION&lt;/code&gt; changes whenever the API changes (e.g. a function is added). A changed value does not always require a recompile.</source>
          <target state="translated">Это просто возвращает значение &lt;code&gt;NPY_FEATURE_VERSION&lt;/code&gt; . &lt;code&gt;NPY_FEATURE_VERSION&lt;/code&gt; изменяется всякий раз, когда изменяется API (например, добавляется функция). Измененное значение не всегда требует перекомпиляции.</target>
        </trans-unit>
        <trans-unit id="57131d2cbf8754e0c0045e65c405a8ff98703b38" translate="yes" xml:space="preserve">
          <source>This macro is defined to +inf.</source>
          <target state="translated">Этот макрос определяется как +inf.</target>
        </trans-unit>
        <trans-unit id="8ca63ad5bc4e1dded64f0ca2a056ab5d5c7f090f" translate="yes" xml:space="preserve">
          <source>This macro is defined to -1.0.</source>
          <target state="translated">Данный макрос определен как -1.0.</target>
        </trans-unit>
        <trans-unit id="b30ee77ae33429489972a6d1172613ede0e766a9" translate="yes" xml:space="preserve">
          <source>This macro is defined to -inf.</source>
          <target state="translated">Этот макрос определен в -inf.</target>
        </trans-unit>
        <trans-unit id="b8842c8583817136af82824b8e5fdbb3f9c76f6e" translate="yes" xml:space="preserve">
          <source>This macro is defined to 1.0.</source>
          <target state="translated">Этот макрос определяется как 1.0.</target>
        </trans-unit>
        <trans-unit id="bd01732ce89574cb085cbbd769f60ac683ce37ab" translate="yes" xml:space="preserve">
          <source>This macro is defined to a NaN (Not a Number), and is guaranteed to have the signbit unset (&amp;lsquo;positive&amp;rsquo; NaN). The corresponding single and extension precision macro are available with the suffix F and L.</source>
          <target state="translated">Этот макрос определен как NaN (не число), и гарантированно, что знаковый бит не установлен (&amp;laquo;положительное&amp;raquo; NaN). Соответствующие макросы одинарной и расширенной точности доступны с суффиксами F и L.</target>
        </trans-unit>
        <trans-unit id="305a7f44534276994ed187e38461a42eaeb6b275" translate="yes" xml:space="preserve">
          <source>This macro is defined to a NaN value, guaranteed to have its sign bit unset.</source>
          <target state="translated">Данный макрос определяется как NaN-значение,гарантированно не имеющее знакового бита.</target>
        </trans-unit>
        <trans-unit id="15a2136199da842d310792facc84af7246036426" translate="yes" xml:space="preserve">
          <source>This macro is defined to a positive inf. The corresponding single and extension precision macro are available with the suffix F and L.</source>
          <target state="translated">Этот макрос определяется как положительный инф.Соответствующий единственный и расширенный точный макрос доступны с суффиксами F и L.</target>
        </trans-unit>
        <trans-unit id="c5ea17d1f0932fffe7fa9472293549c952ff5b71" translate="yes" xml:space="preserve">
          <source>This macro is defined to negative zero (that is with the sign bit set). The corresponding single and extension precision macro are available with the suffix F and L.</source>
          <target state="translated">Этот макрос определяется как отрицательный ноль (т.е.с установленным знаковым битом).Соответствующий единственный и расширенный точный макрос доступны с суффиксами F и L.</target>
        </trans-unit>
        <trans-unit id="28ffbdfd1fb5a238c0e6b132bd7b25e886a8862b" translate="yes" xml:space="preserve">
          <source>This macro is defined to negative zero.</source>
          <target state="translated">Этот макрос определяется как отрицательный ноль.</target>
        </trans-unit>
        <trans-unit id="6499719d1e23e1af1e93848438b61bc7bf9fb167" translate="yes" xml:space="preserve">
          <source>This macro is defined to positive zero.</source>
          <target state="translated">Этот макрос определяется как положительный ноль.</target>
        </trans-unit>
        <trans-unit id="c804fcf19685f98f19d42c1dc7c110945817d41e" translate="yes" xml:space="preserve">
          <source>This macro is defined to positive zero. The corresponding single and extension precision macro are available with the suffix F and L.</source>
          <target state="translated">Этот макрос определяется как положительный ноль.Соответствующий одиночный и расширенный точный макрос доступны с суффиксами F и L.</target>
        </trans-unit>
        <trans-unit id="4c35e4d492b4b66e88cf91e279bf815b9c6ef74c" translate="yes" xml:space="preserve">
          <source>This manual contains many examples of use, usually prefixed with the Python prompt &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt; (which is not a part of the example code). The examples assume that you have first entered:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc87f3907c86c15e0fab69c802c5a342d7203e00" translate="yes" xml:space="preserve">
          <source>This may be clearer with an example.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c451240677ff61c1a609e49bd0f07f461a99c611" translate="yes" xml:space="preserve">
          <source>This may be used when you want to match up operand axes in some fashion, then remove them with &lt;code&gt;NpyIter_RemoveAxis&lt;/code&gt; to handle their processing manually. By calling this function before removing the axes, you can get the strides for the manual processing.</source>
          <target state="translated">Это можно использовать, когда вы хотите каким-то образом сопоставить оси операндов, а затем удалить их с помощью &lt;code&gt;NpyIter_RemoveAxis&lt;/code&gt; , чтобы обрабатывать их вручную. Вызывая эту функцию перед удалением осей, вы можете получить шаги для ручной обработки.</target>
        </trans-unit>
        <trans-unit id="272240144b37c5af402b352038a269eb5d08f543" translate="yes" xml:space="preserve">
          <source>This may mainly help you if you are not running the python and/or NumPy version you are expecting to run.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c92d427e914a0dd599016040f8fd75a2d48dc062" translate="yes" xml:space="preserve">
          <source>This means that (i) we want to edit the commit message for &lt;code&gt;13d7934&lt;/code&gt;, and (ii) collapse the last three commits into one. Now we save and quit the editor.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="85b5c517a58e8aeec834229928a8cecac10d6dff" translate="yes" xml:space="preserve">
          <source>This member allows array objects to have weak references (using the weakref module).</source>
          <target state="translated">Этот член массива позволяет объектам массива иметь слабые ссылки (используя модуль weakref).</target>
        </trans-unit>
        <trans-unit id="ed18bc4ba4db4fad433f89f2b494c6f4723892b5" translate="yes" xml:space="preserve">
          <source>This member is used to hold a pointer to another Python object that is related to this array. There are two use cases:</source>
          <target state="translated">Этот член используется для удержания указателя на другой объект Python,который связан с этим массивом.Существует два варианта использования:</target>
        </trans-unit>
        <trans-unit id="9d7f481ab5f8b1d226ed9ed47a9904d6a830df77" translate="yes" xml:space="preserve">
          <source>This member points to an element in the ndarray indicated by the index.</source>
          <target state="translated">Этот член указывает на элемент в ндаррее,обозначенный индексом.</target>
        </trans-unit>
        <trans-unit id="74643da87d06b0da62bc7a9a046a5adf218ab99e" translate="yes" xml:space="preserve">
          <source>This method directly exposes the the raw underlying pseudo-random number generator. All values are returned as unsigned 64-bit values irrespective of the number of bits produced by the PRNG.</source>
          <target state="translated">Этот метод непосредственно подвергает необработанный генератор псевдослучайных чисел.Все значения возвращаются в виде неподписанных 64-битных значений независимо от количества битов,произведенных ГПСЧ.</target>
        </trans-unit>
        <trans-unit id="d818e6497cca20e6d8e8f1bc817ba9a89c8a342e" translate="yes" xml:space="preserve">
          <source>This method does nothing, except raise a ValueError exception. A masked array does not own its data and therefore cannot safely be resized in place. Use the &lt;a href=&quot;numpy.ma.resize#numpy.ma.resize&quot;&gt;&lt;code&gt;numpy.ma.resize&lt;/code&gt;&lt;/a&gt; function instead.</source>
          <target state="translated">Этот метод ничего не делает, кроме как вызывает исключение ValueError. Маскированный массив не владеет своими данными и поэтому не может безопасно изменять размер на месте. Используйте &lt;a href=&quot;numpy.ma.resize#numpy.ma.resize&quot;&gt; &lt;code&gt;numpy.ma.resize&lt;/code&gt; &lt;/a&gt; вместо функции.</target>
        </trans-unit>
        <trans-unit id="9518a02e6b8dc4cd7e3170e82e29518e38adcb79" translate="yes" xml:space="preserve">
          <source>This method does the heavy lifting for the &lt;a href=&quot;numpy.testing.tester.test#numpy.testing.Tester.test&quot;&gt;&lt;code&gt;test&lt;/code&gt;&lt;/a&gt; method. It takes all the same arguments, for details see &lt;a href=&quot;numpy.testing.tester.test#numpy.testing.Tester.test&quot;&gt;&lt;code&gt;test&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f55c9dffed1c2a6b5a2a9bf81f22b788e98f67b4" translate="yes" xml:space="preserve">
          <source>This method is called whenever the system internally allocates a new array from &lt;em&gt;obj&lt;/em&gt;, where &lt;em&gt;obj&lt;/em&gt; is a subclass (subtype) of the &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt;. It can be used to change attributes of &lt;em&gt;self&lt;/em&gt; after construction (so as to ensure a 2-d matrix for example), or to update meta-information from the &amp;ldquo;parent.&amp;rdquo; Subclasses inherit a default implementation of this method that does nothing.</source>
          <target state="translated">Этот метод вызывается всякий раз, когда система внутренне выделяет новый массив из &lt;em&gt;obj&lt;/em&gt; , где &lt;em&gt;obj&lt;/em&gt; является подклассом (подтипом) &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt; . Его можно использовать для изменения атрибутов &lt;em&gt;себя&lt;/em&gt; после построения (например, чтобы обеспечить двумерную матрицу) или для обновления метаинформации от &amp;laquo;родителя&amp;raquo;. Подклассы наследуют реализацию этого метода по умолчанию, которая ничего не делает.</target>
        </trans-unit>
        <trans-unit id="5957d72b0ca4a0dc20466e5e727abd34e77443e1" translate="yes" xml:space="preserve">
          <source>This method is difficult to implement safely and may be deprecated in future releases of NumPy.</source>
          <target state="translated">Этот метод трудно безопасно реализовать и может быть устаревшим в будущих релизах NumPy.</target>
        </trans-unit>
        <trans-unit id="7aaa9616f6dcdd0184bee8a152bd13d1e550b310" translate="yes" xml:space="preserve">
          <source>This method is for backward compatibility only: do not use.</source>
          <target state="translated">Этот метод предназначен только для обратной совместимости:не используйте.</target>
        </trans-unit>
        <trans-unit id="0ecb5e08ef8d16754216c422058e3a81999abee2" translate="yes" xml:space="preserve">
          <source>This method removes any overlaps and reorders the fields in memory so they have increasing byte offsets, and adds or removes padding bytes depending on the &lt;code&gt;align&lt;/code&gt; option, which behaves like the &lt;code&gt;align&lt;/code&gt; option to &lt;code&gt;np.dtype&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="83e657ddca83d2881d8a63d1d77710e25b3d7e94" translate="yes" xml:space="preserve">
          <source>This method scans files named __version__.py, &amp;lt;packagename&amp;gt;_version.py, version.py, and __svn_version__.py for string variables version, __version__, and &amp;lt;packagename&amp;gt;_version, until a version number is found.</source>
          <target state="translated">Этот метод сканирует файлы с именами __version__.py, &amp;lt;packagename&amp;gt; _version.py, version.py и __svn_version__.py на предмет строковых переменных version, __version__ и &amp;lt;packagename&amp;gt; _version, пока не будет найден номер версии.</target>
        </trans-unit>
        <trans-unit id="f89805770623a7cfcc87bb87063713e7dd822816" translate="yes" xml:space="preserve">
          <source>This module contains all functions in the &lt;a href=&quot;index#module-numpy&quot;&gt;&lt;code&gt;numpy&lt;/code&gt;&lt;/a&gt; namespace, with the following replacement functions that return &lt;a href=&quot;generated/numpy.matrix#numpy.matrix&quot;&gt;&lt;code&gt;matrices&lt;/code&gt;&lt;/a&gt; instead of &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarrays&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Этот модуль содержит все функции в пространстве имен &lt;a href=&quot;index#module-numpy&quot;&gt; &lt;code&gt;numpy&lt;/code&gt; &lt;/a&gt; со следующими функциями замены, которые возвращают &lt;a href=&quot;generated/numpy.matrix#numpy.matrix&quot;&gt; &lt;code&gt;matrices&lt;/code&gt; &lt;/a&gt; вместо &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarrays&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="265d65d83193df044b48a623f0d3f0dda63b008d" translate="yes" xml:space="preserve">
          <source>This module provides a number of objects (mostly functions) useful for dealing with Chebyshev series, including a &lt;a href=&quot;generated/numpy.polynomial.chebyshev.chebyshev#numpy.polynomial.chebyshev.Chebyshev&quot;&gt;&lt;code&gt;Chebyshev&lt;/code&gt;&lt;/a&gt; class that encapsulates the usual arithmetic operations. (General information on how this module represents and works with such polynomials is in the docstring for its &amp;ldquo;parent&amp;rdquo; sub-package, &lt;a href=&quot;routines.polynomials.package#module-numpy.polynomial&quot;&gt;&lt;code&gt;numpy.polynomial&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">Этот модуль предоставляет ряд объектов (в основном функций), полезных для работы с рядами Чебышева, включая класс &lt;a href=&quot;generated/numpy.polynomial.chebyshev.chebyshev#numpy.polynomial.chebyshev.Chebyshev&quot;&gt; &lt;code&gt;Chebyshev&lt;/code&gt; &lt;/a&gt; который инкапсулирует обычные арифметические операции. (Общая информация о том, как этот модуль представляет и работает с такими многочленами, находится в строке документации для его &amp;laquo;родительского&amp;raquo; &lt;a href=&quot;routines.polynomials.package#module-numpy.polynomial&quot;&gt; &lt;code&gt;numpy.polynomial&lt;/code&gt; &lt;/a&gt; , numpy.polynomial ).</target>
        </trans-unit>
        <trans-unit id="e0c12fd4ebad36a4626d24020b78132a2c170962" translate="yes" xml:space="preserve">
          <source>This module provides a number of objects (mostly functions) useful for dealing with Hermite series, including a &lt;a href=&quot;generated/numpy.polynomial.hermite.hermite#numpy.polynomial.hermite.Hermite&quot;&gt;&lt;code&gt;Hermite&lt;/code&gt;&lt;/a&gt; class that encapsulates the usual arithmetic operations. (General information on how this module represents and works with such polynomials is in the docstring for its &amp;ldquo;parent&amp;rdquo; sub-package, &lt;a href=&quot;routines.polynomials.package#module-numpy.polynomial&quot;&gt;&lt;code&gt;numpy.polynomial&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">Этот модуль предоставляет ряд объектов (в основном функций), полезных для работы с сериями Hermite, включая класс &lt;a href=&quot;generated/numpy.polynomial.hermite.hermite#numpy.polynomial.hermite.Hermite&quot;&gt; &lt;code&gt;Hermite&lt;/code&gt; ,&lt;/a&gt; который инкапсулирует обычные арифметические операции. (Общая информация о том, как этот модуль представляет и работает с такими многочленами, находится в строке документации для его &amp;laquo;родительского&amp;raquo; &lt;a href=&quot;routines.polynomials.package#module-numpy.polynomial&quot;&gt; &lt;code&gt;numpy.polynomial&lt;/code&gt; &lt;/a&gt; , numpy.polynomial ).</target>
        </trans-unit>
        <trans-unit id="009a1c885b932c48bc61dd45e0e34c3c31b1f286" translate="yes" xml:space="preserve">
          <source>This module provides a number of objects (mostly functions) useful for dealing with HermiteE series, including a &lt;a href=&quot;generated/numpy.polynomial.hermite_e.hermitee#numpy.polynomial.hermite_e.HermiteE&quot;&gt;&lt;code&gt;HermiteE&lt;/code&gt;&lt;/a&gt; class that encapsulates the usual arithmetic operations. (General information on how this module represents and works with such polynomials is in the docstring for its &amp;ldquo;parent&amp;rdquo; sub-package, &lt;a href=&quot;routines.polynomials.package#module-numpy.polynomial&quot;&gt;&lt;code&gt;numpy.polynomial&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">Этот модуль предоставляет ряд объектов (в основном функций), полезных для работы с сериями HermiteE, включая класс &lt;a href=&quot;generated/numpy.polynomial.hermite_e.hermitee#numpy.polynomial.hermite_e.HermiteE&quot;&gt; &lt;code&gt;HermiteE&lt;/code&gt; ,&lt;/a&gt; который инкапсулирует обычные арифметические операции. (Общая информация о том, как этот модуль представляет и работает с такими многочленами, находится в строке документации для его &amp;laquo;родительского&amp;raquo; &lt;a href=&quot;routines.polynomials.package#module-numpy.polynomial&quot;&gt; &lt;code&gt;numpy.polynomial&lt;/code&gt; &lt;/a&gt; , numpy.polynomial ).</target>
        </trans-unit>
        <trans-unit id="68d5327723a8c86e153df7ff9955c4a06be0ce20" translate="yes" xml:space="preserve">
          <source>This module provides a number of objects (mostly functions) useful for dealing with Hermite_e series, including a &lt;a href=&quot;generated/numpy.polynomial.hermite_e.hermitee#numpy.polynomial.hermite_e.HermiteE&quot;&gt;&lt;code&gt;HermiteE&lt;/code&gt;&lt;/a&gt; class that encapsulates the usual arithmetic operations. (General information on how this module represents and works with such polynomials is in the docstring for its &amp;ldquo;parent&amp;rdquo; sub-package, &lt;a href=&quot;routines.polynomials.package#module-numpy.polynomial&quot;&gt;&lt;code&gt;numpy.polynomial&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d0299f154387dc04b7a01cfe822909405b30805" translate="yes" xml:space="preserve">
          <source>This module provides a number of objects (mostly functions) useful for dealing with Laguerre series, including a &lt;a href=&quot;generated/numpy.polynomial.laguerre.laguerre#numpy.polynomial.laguerre.Laguerre&quot;&gt;&lt;code&gt;Laguerre&lt;/code&gt;&lt;/a&gt; class that encapsulates the usual arithmetic operations. (General information on how this module represents and works with such polynomials is in the docstring for its &amp;ldquo;parent&amp;rdquo; sub-package, &lt;a href=&quot;routines.polynomials.package#module-numpy.polynomial&quot;&gt;&lt;code&gt;numpy.polynomial&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">Этот модуль предоставляет ряд объектов (в основном функций), полезных для работы с рядами Лагерра, включая класс &lt;a href=&quot;generated/numpy.polynomial.laguerre.laguerre#numpy.polynomial.laguerre.Laguerre&quot;&gt; &lt;code&gt;Laguerre&lt;/code&gt; &lt;/a&gt; который инкапсулирует обычные арифметические операции. (Общая информация о том, как этот модуль представляет и работает с такими многочленами, находится в строке документации для его &amp;laquo;родительского&amp;raquo; &lt;a href=&quot;routines.polynomials.package#module-numpy.polynomial&quot;&gt; &lt;code&gt;numpy.polynomial&lt;/code&gt; &lt;/a&gt; , numpy.polynomial ).</target>
        </trans-unit>
        <trans-unit id="97167a7dd7012c05d960d350608d944b8fc4844a" translate="yes" xml:space="preserve">
          <source>This module provides a number of objects (mostly functions) useful for dealing with Legendre series, including a &lt;a href=&quot;generated/numpy.polynomial.legendre.legendre#numpy.polynomial.legendre.Legendre&quot;&gt;&lt;code&gt;Legendre&lt;/code&gt;&lt;/a&gt; class that encapsulates the usual arithmetic operations. (General information on how this module represents and works with such polynomials is in the docstring for its &amp;ldquo;parent&amp;rdquo; sub-package, &lt;a href=&quot;routines.polynomials.package#module-numpy.polynomial&quot;&gt;&lt;code&gt;numpy.polynomial&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">Этот модуль предоставляет ряд объектов (в основном функций), полезных для работы с рядами Лежандра, включая класс &lt;a href=&quot;generated/numpy.polynomial.legendre.legendre#numpy.polynomial.legendre.Legendre&quot;&gt; &lt;code&gt;Legendre&lt;/code&gt; &lt;/a&gt; который инкапсулирует обычные арифметические операции. (Общая информация о том, как этот модуль представляет и работает с такими многочленами, находится в строке документации для его &amp;laquo;родительского&amp;raquo; &lt;a href=&quot;routines.polynomials.package#module-numpy.polynomial&quot;&gt; &lt;code&gt;numpy.polynomial&lt;/code&gt; &lt;/a&gt; , numpy.polynomial ).</target>
        </trans-unit>
        <trans-unit id="27218660297bbc1672326aa7fc0091aba0aa4b36" translate="yes" xml:space="preserve">
          <source>This module provides a number of objects (mostly functions) useful for dealing with Polynomial series, including a &lt;a href=&quot;generated/numpy.polynomial.polynomial.polynomial#numpy.polynomial.polynomial.Polynomial&quot;&gt;&lt;code&gt;Polynomial&lt;/code&gt;&lt;/a&gt; class that encapsulates the usual arithmetic operations. (General information on how this module represents and works with such polynomials is in the docstring for its &amp;ldquo;parent&amp;rdquo; sub-package, &lt;a href=&quot;routines.polynomials.package#module-numpy.polynomial&quot;&gt;&lt;code&gt;numpy.polynomial&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">Этот модуль предоставляет ряд объектов (в основном функций), полезных для работы с полиномиальными рядами, включая класс &lt;a href=&quot;generated/numpy.polynomial.polynomial.polynomial#numpy.polynomial.polynomial.Polynomial&quot;&gt; &lt;code&gt;Polynomial&lt;/code&gt; ,&lt;/a&gt; который инкапсулирует обычные арифметические операции. (Общая информация о том, как этот модуль представляет и работает с такими многочленами, находится в строке документации для его &amp;laquo;родительского&amp;raquo; &lt;a href=&quot;routines.polynomials.package#module-numpy.polynomial&quot;&gt; &lt;code&gt;numpy.polynomial&lt;/code&gt; &lt;/a&gt; , numpy.polynomial ).</target>
        </trans-unit>
        <trans-unit id="1ab4c28fb83b693800bce3d9c0cb03cd8615a6cd" translate="yes" xml:space="preserve">
          <source>This module provides a number of objects (mostly functions) useful for dealing with polynomials, including a &lt;a href=&quot;generated/numpy.polynomial.polynomial.polynomial#numpy.polynomial.polynomial.Polynomial&quot;&gt;&lt;code&gt;Polynomial&lt;/code&gt;&lt;/a&gt; class that encapsulates the usual arithmetic operations. (General information on how this module represents and works with polynomial objects is in the docstring for its &amp;ldquo;parent&amp;rdquo; sub-package, &lt;a href=&quot;routines.polynomials.package#module-numpy.polynomial&quot;&gt;&lt;code&gt;numpy.polynomial&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6505e2a54b4c90d04c624c70346ad867092f98b2" translate="yes" xml:space="preserve">
          <source>This module provides: error and warning objects; a polynomial base class; and some routines used in both the &lt;code&gt;polynomial&lt;/code&gt; and &lt;code&gt;chebyshev&lt;/code&gt; modules.</source>
          <target state="translated">Этот модуль предоставляет: объекты ошибок и предупреждений; полиномиальный базовый класс; и некоторые процедуры, используемые как в &lt;code&gt;polynomial&lt;/code&gt; и в &lt;code&gt;chebyshev&lt;/code&gt; модулях.</target>
        </trans-unit>
        <trans-unit id="a2e1ca0b050299a02c26006ffc538095c291c293" translate="yes" xml:space="preserve">
          <source>This module shows use of the &lt;code&gt;cimport&lt;/code&gt; statement to load the definitions from the &lt;code&gt;numpy.pxd&lt;/code&gt; header that ships with Cython. It looks like NumPy is imported twice; &lt;code&gt;cimport&lt;/code&gt; only makes the NumPy C-API available, while the regular &lt;code&gt;import&lt;/code&gt; causes a Python-style import at runtime and makes it possible to call into the familiar NumPy Python API.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f02b8e116f7a7bed4ba561da0ffe80943392202" translate="yes" xml:space="preserve">
          <source>This module&amp;rsquo;s representation of the Chebyshev series for &lt;code&gt;off + scl*x&lt;/code&gt;.</source>
          <target state="translated">Это модульное представление ряда Чебышева для &lt;code&gt;off + scl*x&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a628eacd0f4bb9dd57ff71e63c578eed78e261b5" translate="yes" xml:space="preserve">
          <source>This module&amp;rsquo;s representation of the Hermite series for &lt;code&gt;off + scl*x&lt;/code&gt;.</source>
          <target state="translated">Этот модуль представляет серию Эрмита для &lt;code&gt;off + scl*x&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9ab2b6eda8208cc86132d50e5e53a2cf2e15859d" translate="yes" xml:space="preserve">
          <source>This module&amp;rsquo;s representation of the Laguerre series for &lt;code&gt;off + scl*x&lt;/code&gt;.</source>
          <target state="translated">Это модульное представление ряда Лагерра для &lt;code&gt;off + scl*x&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="23eb81bc9bb7a5f0cbd08a18f3b739c712c791cf" translate="yes" xml:space="preserve">
          <source>This module&amp;rsquo;s representation of the Legendre series for &lt;code&gt;off + scl*x&lt;/code&gt;.</source>
          <target state="translated">Представление этого модуля ряда Лежандра для &lt;code&gt;off + scl*x&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d92e37a5c688f24c68244c7cd58f9c4410908a50" translate="yes" xml:space="preserve">
          <source>This module&amp;rsquo;s representation of the linear polynomial &lt;code&gt;off +
scl*x&lt;/code&gt;.</source>
          <target state="translated">Представление этого модуля линейного полинома &lt;code&gt;off + scl*x&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cce1c3ab116538df151878b9366f2e0db3802d6b" translate="yes" xml:space="preserve">
          <source>This needs to be done after all installers are downloaded, but before the pavement file is updated for continued development:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a5151a066bb85cc108b39c4156d9c6c1e5f15d97" translate="yes" xml:space="preserve">
          <source>This obeys the structured array assignment rules described above. For example, this means that one can swap the values of two fields using appropriate multi-field indexes:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c93b1abaa0ee7234b376edaae74a000aa2ccbab" translate="yes" xml:space="preserve">
          <source>This object is no longer compatible with &lt;code&gt;np.sum&lt;/code&gt; because if you call &lt;code&gt;np.sum&lt;/code&gt;, it will pass in unexpected arguments &lt;code&gt;out&lt;/code&gt; and &lt;code&gt;keepdims&lt;/code&gt;, causing a TypeError to be raised.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b628f2a020e67ee402c9861512476edcb4af1ebf" translate="yes" xml:space="preserve">
          <source>This object is now compatible with &lt;code&gt;np.sum&lt;/code&gt; again because any extraneous arguments (i.e. keywords that are not &lt;code&gt;axis&lt;/code&gt; or &lt;code&gt;dtype&lt;/code&gt;) will be hidden away in the &lt;code&gt;**unused_kwargs&lt;/code&gt; parameter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="75a22002edc0d8d423cb72bfe9efb4e65f38427c" translate="yes" xml:space="preserve">
          <source>This only affects the iterator when &lt;a href=&quot;array#c.NPY_KEEPORDER&quot;&gt;&lt;code&gt;NPY_KEEPORDER&lt;/code&gt;&lt;/a&gt; is specified for the order parameter. By default with &lt;a href=&quot;array#c.NPY_KEEPORDER&quot;&gt;&lt;code&gt;NPY_KEEPORDER&lt;/code&gt;&lt;/a&gt;, the iterator reverses axes which have negative strides, so that memory is traversed in a forward direction. This disables this step. Use this flag if you want to use the underlying memory-ordering of the axes, but don&amp;rsquo;t want an axis reversed. This is the behavior of &lt;code&gt;numpy.ravel(a, order='K')&lt;/code&gt;, for instance.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eaa2fd8c1567b66e551b17269b1ebbbc61f96243" translate="yes" xml:space="preserve">
          <source>This only affects the iterator when &lt;a href=&quot;c-api.array#c.NPY_KEEPORDER&quot;&gt;&lt;code&gt;NPY_KEEPORDER&lt;/code&gt;&lt;/a&gt; is specified for the order parameter. By default with &lt;a href=&quot;c-api.array#c.NPY_KEEPORDER&quot;&gt;&lt;code&gt;NPY_KEEPORDER&lt;/code&gt;&lt;/a&gt;, the iterator reverses axes which have negative strides, so that memory is traversed in a forward direction. This disables this step. Use this flag if you want to use the underlying memory-ordering of the axes, but don&amp;rsquo;t want an axis reversed. This is the behavior of &lt;code&gt;numpy.ravel(a, order='K')&lt;/code&gt;, for instance.</source>
          <target state="translated">Это влияет на итератор, только если &lt;a href=&quot;c-api.array#c.NPY_KEEPORDER&quot;&gt; &lt;code&gt;NPY_KEEPORDER&lt;/code&gt; &lt;/a&gt; указан для параметра порядка. По умолчанию с &lt;a href=&quot;c-api.array#c.NPY_KEEPORDER&quot;&gt; &lt;code&gt;NPY_KEEPORDER&lt;/code&gt; &lt;/a&gt; итератор меняет оси с отрицательным шагом, так что память перемещается в прямом направлении. Это отключает этот шаг. Используйте этот флаг, если вы хотите использовать базовое упорядочение осей в памяти, но не хотите, чтобы ось перевернулась. Это поведение, например, &lt;code&gt;numpy.ravel(a, order='K')&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="dfc0d7340cbb0038d2b37c47d460673f198c8e36" translate="yes" xml:space="preserve">
          <source>This operation, dividing an array by a scalar, works because of NumPy&amp;rsquo;s &lt;a href=&quot;theory.broadcasting#array-broadcasting-in-numpy&quot;&gt;broadcasting rules&lt;/a&gt;). (Note that in real-world applications, it would be better to use, for example, the &lt;a href=&quot;https://scikit-image.org/docs/stable/api/skimage.html#skimage.img_as_float&quot;&gt;&lt;code&gt;img_as_float&lt;/code&gt;&lt;/a&gt; utility function from &lt;code&gt;scikit-image&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c162c5fa5c56025420698950fd9023cbce377364" translate="yes" xml:space="preserve">
          <source>This option is deprecated. Use &lt;code&gt;usercode&lt;/code&gt; statement to specify C code snippets directly in signature files.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae6b1796953475091b5cdaeb39e4d7e996e315e6" translate="yes" xml:space="preserve">
          <source>This optional parameter specifies the interpolation method to use when the desired percentile lies between two data points &lt;code&gt;i &amp;lt; j&lt;/code&gt;:</source>
          <target state="translated">Этот необязательный параметр указывает метод интерполяции, который следует использовать, когда желаемый процентиль находится между двумя точками данных &lt;code&gt;i &amp;lt; j&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="002fb17667dbbd628eca51b6e4ff99f2217649e0" translate="yes" xml:space="preserve">
          <source>This optional parameter specifies the interpolation method to use when the desired quantile lies between two data points &lt;code&gt;i &amp;lt; j&lt;/code&gt;:</source>
          <target state="translated">Этот необязательный параметр указывает метод интерполяции, который следует использовать, когда желаемый квантиль находится между двумя точками данных &lt;code&gt;i &amp;lt; j&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="c342edf9966c2e18280c4d355db707b32be4bff5" translate="yes" xml:space="preserve">
          <source>This package was developed independently of NumPy and was integrated in version 1.17.0. The original repo is at &lt;a href=&quot;https://github.com/bashtage/randomgen&quot;&gt;https://github.com/bashtage/randomgen&lt;/a&gt;.</source>
          <target state="translated">Этот пакет был разработан независимо от NumPy и был интегрирован в версию 1.17.0. Исходное репо находится по адресу &lt;a href=&quot;https://github.com/bashtage/randomgen&quot;&gt;https://github.com/bashtage/randomgen&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c427139240278bee81f47cf48768438afbe39755" translate="yes" xml:space="preserve">
          <source>This page describes the numpy-specific API for accessing the contents of a numpy array from other C extensions. &lt;a href=&quot;https://www.python.org/dev/peps/pep-3118&quot; id=&quot;index-1&quot;&gt;&lt;strong&gt;PEP 3118&lt;/strong&gt;&lt;/a&gt; &amp;ndash; &lt;a href=&quot;https://docs.python.org/dev/c-api/buffer.html#c.PyObject_GetBuffer&quot;&gt;&lt;code&gt;The Revised Buffer Protocol&lt;/code&gt;&lt;/a&gt; introduces similar, standardized API to Python 2.6 and 3.0 for any extension module to use. &lt;a href=&quot;http://cython.org/&quot;&gt;Cython&lt;/a&gt;&amp;rsquo;s buffer array support uses the &lt;a href=&quot;https://www.python.org/dev/peps/pep-3118&quot; id=&quot;index-2&quot;&gt;&lt;strong&gt;PEP 3118&lt;/strong&gt;&lt;/a&gt; API; see the &lt;a href=&quot;https://github.com/cython/cython/wiki/tutorials-numpy&quot;&gt;Cython numpy tutorial&lt;/a&gt;. Cython provides a way to write code that supports the buffer protocol with Python versions older than 2.6 because it has a backward-compatible implementation utilizing the array interface described here.</source>
          <target state="translated">На этой странице описывается специфичный для numpy API для доступа к содержимому массива numpy из других расширений C. &lt;a href=&quot;https://www.python.org/dev/peps/pep-3118&quot; id=&quot;index-1&quot;&gt;&lt;strong&gt;PEP 3118&lt;/strong&gt;&lt;/a&gt; - &lt;a href=&quot;https://docs.python.org/dev/c-api/buffer.html#c.PyObject_GetBuffer&quot;&gt; &lt;code&gt;The Revised Buffer Protocol&lt;/code&gt; &lt;/a&gt; представляет аналогичный стандартизированный API для Python 2.6 и 3.0 для использования любого модуля расширения. Поддержка буферного массива &lt;a href=&quot;http://cython.org/&quot;&gt;Cython&lt;/a&gt; использует API &lt;a href=&quot;https://www.python.org/dev/peps/pep-3118&quot; id=&quot;index-2&quot;&gt;&lt;strong&gt;PEP 3118&lt;/strong&gt;&lt;/a&gt; ; см. &lt;a href=&quot;https://github.com/cython/cython/wiki/tutorials-numpy&quot;&gt;учебник Cython numpy&lt;/a&gt; . Cython обеспечивает способ написания кода, который поддерживает протокол буфера с версиями Python старше 2.6, поскольку он имеет обратную совместимость с использованием интерфейса массива, описанного здесь.</target>
        </trans-unit>
        <trans-unit id="4df30a5dfa3e83d5a58c4b3babfef2e8f4555a00" translate="yes" xml:space="preserve">
          <source>This page documents the API for the iterator. The iterator is named &lt;code&gt;NpyIter&lt;/code&gt; and functions are named &lt;code&gt;NpyIter_*&lt;/code&gt;.</source>
          <target state="translated">Эта страница документирует API для итератора. Итератор называется &lt;code&gt;NpyIter&lt;/code&gt; , а функции - &lt;code&gt;NpyIter_*&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b79e823ebc32815d2b3460b90e34d0a2f9bed7dc" translate="yes" xml:space="preserve">
          <source>This pointer may be cached before the iteration loop, calling &lt;code&gt;iternext&lt;/code&gt; will not change it.</source>
          <target state="translated">Этот указатель может быть кэширован перед циклом итерации, вызов &lt;code&gt;iternext&lt;/code&gt; не изменит его.</target>
        </trans-unit>
        <trans-unit id="484a465c1e928c7fbd45d4d74c7fee12a21c59d4" translate="yes" xml:space="preserve">
          <source>This pointer may be cached before the iteration loop, calling &lt;code&gt;iternext&lt;/code&gt; will not change it. This function may be safely called without holding the Python GIL.</source>
          <target state="translated">Этот указатель может быть кэширован перед циклом итерации, вызов &lt;code&gt;iternext&lt;/code&gt; не изменит его. Эту функцию можно безопасно вызывать, не удерживая Python GIL.</target>
        </trans-unit>
        <trans-unit id="bb65fa9e55962767929fe75ece2f7703e6ac5b10" translate="yes" xml:space="preserve">
          <source>This produces the correct answer, but if &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; each contain millions of numbers, we will pay the price for the inefficiencies of looping in Python. We could accomplish the same task much more quickly in C by writing (for clarity we neglect variable declarations and initializations, memory allocation, etc.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc50269460cb12e12865cbec85480d4b3e10a0a9" translate="yes" xml:space="preserve">
          <source>This property can be very useful in assignments:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af7b379b2fcb530df7b5c66e85d1051773a408df" translate="yes" xml:space="preserve">
          <source>This property is a view on the imaginary part of this &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray&quot;&gt;&lt;code&gt;MaskedArray&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Это свойство представляет собой представление мнимой части этого &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray&quot;&gt; &lt;code&gt;MaskedArray&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9c2a714f693725c88c94ac2607ed6abee0322d99" translate="yes" xml:space="preserve">
          <source>This property is a view on the real part of this &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray&quot;&gt;&lt;code&gt;MaskedArray&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Это свойство является представлением реальной части этого &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray&quot;&gt; &lt;code&gt;MaskedArray&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="56ae11e0e5ca2982f115765c5eb4aa5c0c2cf88d" translate="yes" xml:space="preserve">
          <source>This reallocates space for the data area if necessary.</source>
          <target state="translated">При необходимости это перераспределяет пространство для области данных.</target>
        </trans-unit>
        <trans-unit id="3875a2efa104b3c26f06d6992550d8f8f4acd93f" translate="yes" xml:space="preserve">
          <source>This reference manual details functions, modules, and objects included in NumPy, describing what they are and what they do. For learning how to use NumPy, see also &lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/user/index.html#user&quot;&gt;NumPy User Guide&lt;/a&gt;.</source>
          <target state="translated">В этом справочном руководстве подробно описаны функции, модули и объекты, включенные в NumPy, с описанием того, что они собой представляют и что они делают. Чтобы узнать, как использовать NumPy, см. Также &lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/user/index.html#user&quot;&gt;Руководство пользователя NumPy&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6b66394de331bbd119ed305c44c97cddcc296f65" translate="yes" xml:space="preserve">
          <source>This reference manual details functions, modules, and objects included in NumPy, describing what they are and what they do. For learning how to use NumPy, see the &lt;a href=&quot;../contents#numpy-docs-mainpage&quot;&gt;complete documentation&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="49d7d34fc7b59b4f57a8fc699678974df3138f8f" translate="yes" xml:space="preserve">
          <source>This returns a tuple of indices that can be used to access the main diagonal of an array &lt;code&gt;a&lt;/code&gt; with &lt;code&gt;a.ndim &amp;gt;= 2&lt;/code&gt; dimensions and shape (n, n, &amp;hellip;, n). For &lt;code&gt;a.ndim = 2&lt;/code&gt; this is the usual diagonal, for &lt;code&gt;a.ndim &amp;gt; 2&lt;/code&gt; this is the set of indices to access &lt;code&gt;a[i, i, ..., i]&lt;/code&gt; for &lt;code&gt;i = [0..n-1]&lt;/code&gt;.</source>
          <target state="translated">Это возвращает кортеж индексов, которые можно использовать для доступа к главной диагонали массива &lt;code&gt;a&lt;/code&gt; с &lt;code&gt;a.ndim &amp;gt;= 2&lt;/code&gt; измерениями и формой (n, n,&amp;hellip;, n). Для &lt;code&gt;a.ndim = 2&lt;/code&gt; это обычная диагональ, для &lt;code&gt;a.ndim &amp;gt; 2&lt;/code&gt; это набор индексов для доступа к &lt;code&gt;a[i, i, ..., i]&lt;/code&gt; для &lt;code&gt;i = [0..n-1]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="445408c5f27be1f1d331536d4e933a74a8f78cb0" translate="yes" xml:space="preserve">
          <source>This returns the base object of the array. In most cases, this means the object which owns the memory the array is pointing at.</source>
          <target state="translated">При этом возвращается базовый объект массива.В большинстве случаев это означает,что объект,которому принадлежит память,на которую указывает массив.</target>
        </trans-unit>
        <trans-unit id="86f639de88fe17b751b6b11b662442ef7819d4d2" translate="yes" xml:space="preserve">
          <source>This routine simply adds the elements in two contiguous arrays and places the result in a third. The memory for all three arrays must be provided by the calling routine. A very basic interface to this routine can be automatically generated by f2py:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a52ed8eb1e1cedf938d67a58ab208207008af6c7" translate="yes" xml:space="preserve">
          <source>This routine succeeds where ordinary &lt;a href=&quot;numpy.linalg.det#numpy.linalg.det&quot;&gt;&lt;code&gt;det&lt;/code&gt;&lt;/a&gt; does not:</source>
          <target state="translated">Эта процедура выполняется там, где обычный &lt;a href=&quot;numpy.linalg.det#numpy.linalg.det&quot;&gt; &lt;code&gt;det&lt;/code&gt; &lt;/a&gt; не работает:</target>
        </trans-unit>
        <trans-unit id="bb5cd927267b8c85989f3387ce0a0d2359a4663d" translate="yes" xml:space="preserve">
          <source>This saves all the overhead involved in interpreting the Python code and manipulating Python objects, but at the expense of the benefits gained from coding in Python. Furthermore, the coding work required increases with the dimensionality of our data. In the case of a 2-D array, for example, the C code (abridged as before) expands to</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb7064b0e5d0b37eaed95ef4ac40f47e88476c2d" translate="yes" xml:space="preserve">
          <source>This scheme does require that you avoid reusing stream IDs. This may require coordination between the parallel processes.</source>
          <target state="translated">Эта схема требует избегать повторного использования идентификаторов потока.Это может потребовать координации между параллельными процессами.</target>
        </trans-unit>
        <trans-unit id="1aa4791ff179e31578c8776ff4ea075ff10d4756" translate="yes" xml:space="preserve">
          <source>This section and the next describe in detail how to set up git for working with the NumPy source code. If you have git already set up, skip to &lt;a href=&quot;../development_workflow#development-workflow&quot;&gt;Development workflow&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d2295424cf2146c8c588e01472068b4499bd8664" translate="yes" xml:space="preserve">
          <source>This section describes how the basic universal function computation loop is setup and executed for each of the three different kinds of execution. If &lt;code&gt;NPY_ALLOW_THREADS&lt;/code&gt; is defined during compilation, then as long as no object arrays are involved, the Python Global Interpreter Lock (GIL) is released prior to calling the loops. It is re-acquired if necessary to handle error conditions. The hardware error flags are checked only after the 1-D loop is completed.</source>
          <target state="translated">В этом разделе описывается, как настраивается и выполняется основной цикл вычисления универсальной функции для каждого из трех различных видов выполнения. Если &lt;code&gt;NPY_ALLOW_THREADS&lt;/code&gt; определяется во время компиляции, то до тех пор, пока не задействованы массивы объектов, перед вызовом циклов снимается глобальная блокировка интерпретатора Python (GIL). При необходимости он повторно запрашивается для обработки условий ошибки. Флаги аппаратных ошибок проверяются только после завершения одномерного цикла.</target>
        </trans-unit>
        <trans-unit id="36d38a5b23b654b48926d888ff2f70f4fd6663ca" translate="yes" xml:space="preserve">
          <source>This section describes the governance and leadership model of The Project.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="387c13e7d204cf584e66117f50223922b47b0d67" translate="yes" xml:space="preserve">
          <source>This section should be used judiciously, i.e., only for errors that are non-obvious or have a large chance of getting raised.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf292081ef6e3f6d3a2a86d3bb95335c9be71e92" translate="yes" xml:space="preserve">
          <source>This section should use the &lt;code&gt;deprecated&lt;/code&gt; Sphinx directive instead of an underlined section header.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0a9b94d3eaea207d20a5173591fa4612902baa5c" translate="yes" xml:space="preserve">
          <source>This section will not cover means of replicating, joining, or otherwise expanding or mutating existing arrays. Nor will it cover creating object arrays or structured arrays. Both of those are covered in their own sections.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a18449ed2fc82d845556e8871f21b5f905f1f97" translate="yes" xml:space="preserve">
          <source>This should be read together with the general directions in &lt;code&gt;releasing&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af85e32a0a54092009ceae627c9327451013292e" translate="yes" xml:space="preserve">
          <source>This should not be confused with:</source>
          <target state="translated">С этим не стоит путать:</target>
        </trans-unit>
        <trans-unit id="281bd1fc18f2200e68ef811b640b0f24111b0170" translate="yes" xml:space="preserve">
          <source>This simply has the effect of switching the definitions of &lt;code&gt;arg1&lt;/code&gt; and &lt;code&gt;arg2&lt;/code&gt; in lines 3 and 4 of the generated code above, and their assignments in lines 19 and 20.</source>
          <target state="translated">Это просто приводит к переключению определений &lt;code&gt;arg1&lt;/code&gt; и &lt;code&gt;arg2&lt;/code&gt; в строках 3 и 4 сгенерированного кода выше и их назначений в строках 19 и 20.</target>
        </trans-unit>
        <trans-unit id="54a1fbc955c54345f701059c4adac18f9144af8f" translate="yes" xml:space="preserve">
          <source>This single module should provide all the common functionality for numpy tests in a single location, so that &lt;a href=&quot;../dev/development_environment#development-environment&quot;&gt;test scripts&lt;/a&gt; can just import it and work right away. For background, see the &lt;a href=&quot;testing#testing-guidelines&quot;&gt;Testing Guidelines&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d5f0ce6428ed7ce9a3f007ac820d6ad83fbe35d9" translate="yes" xml:space="preserve">
          <source>This single module should provide all the common functionality for numpy tests in a single location, so that &lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/dev/development_environment.html#development-environment&quot;&gt;test scripts&lt;/a&gt; can just import it and work right away. For background, see the &lt;a href=&quot;testing#testing-guidelines&quot;&gt;Testing Guidelines&lt;/a&gt;</source>
          <target state="translated">Этот единственный модуль должен обеспечивать все общие функции для numpy-тестов в одном месте, чтобы &lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/dev/development_environment.html#development-environment&quot;&gt;тестовые сценарии&lt;/a&gt; могли просто импортировать его и сразу работать. Для получения дополнительной информации см. &lt;a href=&quot;testing#testing-guidelines&quot;&gt;Руководство&lt;/a&gt; по тестированию.</target>
        </trans-unit>
        <trans-unit id="feb22e5bb35e33b30ed01dab66654627fe20956a" translate="yes" xml:space="preserve">
          <source>This specifies the &amp;ldquo;intention&amp;rdquo; of the corresponding argument. &lt;code&gt;&amp;lt;intentspec&amp;gt;&lt;/code&gt; is a comma separated list of the following keys:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5e999bfd9ee7986bb74545207acc796f3e46abd8" translate="yes" xml:space="preserve">
          <source>This specifies which warnings to configure as &amp;lsquo;raise&amp;rsquo; instead of being shown once during the test execution. Valid strings are:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="355c08a8b685b52031d6593cc7642f8973231125" translate="yes" xml:space="preserve">
          <source>This step is only needed for final releases and can be skipped for pre-releases. &lt;code&gt;make merge-doc&lt;/code&gt; clones the &lt;code&gt;numpy/doc&lt;/code&gt; repo into &lt;code&gt;doc/build/merge&lt;/code&gt; and updates it with the new documentation:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f04c1b598b018608346e9a082214a1abd34ac499" translate="yes" xml:space="preserve">
          <source>This string will be used as the marker for missing data for all the columns</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d96875a0b29939a3e2bb067cb066089a92949861" translate="yes" xml:space="preserve">
          <source>This structure is very useful when shape and/or strides information is supposed to be interpreted. The structure is:</source>
          <target state="translated">Эта структура очень полезна,когда предполагается интерпретировать информацию о форме и/или шагах.Структура является:</target>
        </trans-unit>
        <trans-unit id="f5377b9ec1ee34b1b46afca48f12d70eda083569" translate="yes" xml:space="preserve">
          <source>This style allows passing in the &lt;a href=&quot;generated/numpy.dtype.fields#numpy.dtype.fields&quot;&gt;&lt;code&gt;fields&lt;/code&gt;&lt;/a&gt; attribute of a data-type object.</source>
          <target state="translated">Этот стиль позволяет передавать атрибут &lt;a href=&quot;generated/numpy.dtype.fields#numpy.dtype.fields&quot;&gt; &lt;code&gt;fields&lt;/code&gt; &lt;/a&gt; объекта типа данных.</target>
        </trans-unit>
        <trans-unit id="8baa5c3fa91f9d82d5f372676363ca92358b6704" translate="yes" xml:space="preserve">
          <source>This style does not accept &lt;em&gt;align&lt;/em&gt; in the &lt;a href=&quot;generated/numpy.dtype#numpy.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt; constructor as it is assumed that all of the memory is accounted for by the array interface description.</source>
          <target state="translated">Этот стиль не поддерживает &lt;em&gt;выравнивание&lt;/em&gt; в конструкторе &lt;a href=&quot;generated/numpy.dtype#numpy.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; ,&lt;/a&gt; поскольку предполагается, что вся память занята описанием интерфейса массива.</target>
        </trans-unit>
        <trans-unit id="63b067d6a5e8e9587ae90576ba34210d81e53f6b" translate="yes" xml:space="preserve">
          <source>This style has two required and three optional keys. The &lt;em&gt;names&lt;/em&gt; and &lt;em&gt;formats&lt;/em&gt; keys are required. Their respective values are equal-length lists with the field names and the field formats. The field names must be strings and the field formats can be any object accepted by &lt;a href=&quot;generated/numpy.dtype#numpy.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt; constructor.</source>
          <target state="translated">Этот стиль имеет два обязательных и три дополнительных ключа. Требуются &lt;em&gt;имена&lt;/em&gt; и ключи &lt;em&gt;форматов&lt;/em&gt; . Их соответствующие значения представляют собой списки одинаковой длины с именами полей и форматами полей. Имена полей должны быть строками, а &lt;a href=&quot;generated/numpy.dtype#numpy.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt; полей может быть любой объект, принимаемый конструктором dtype .</target>
        </trans-unit>
        <trans-unit id="9fd39c592746d75bfe12bf10bab5bf15e715d323" translate="yes" xml:space="preserve">
          <source>This subclass of ndarray has some unpleasant interactions with some operations, because it doesn&amp;rsquo;t quite fit properly as a subclass. An alternative to using this subclass is to create the &lt;code&gt;mmap&lt;/code&gt; object yourself, then create an ndarray with ndarray.__new__ directly, passing the object created in its &amp;lsquo;buffer=&amp;rsquo; parameter.</source>
          <target state="translated">Этот подкласс ndarray имеет некоторые неприятные взаимодействия с некоторыми операциями, поскольку он не совсем подходит как подкласс. Альтернативой использованию этого подкласса является создание объекта &lt;code&gt;mmap&lt;/code&gt; самостоятельно, а затем создание ndarray напрямую с помощью ndarray .__ new__, передавая объект, созданный в его параметре 'buffer ='.</target>
        </trans-unit>
        <trans-unit id="8a52b4cb6a8af65abce36bb79c9c41aa8777063c" translate="yes" xml:space="preserve">
          <source>This tells you that you are currently on the &lt;code&gt;master&lt;/code&gt; branch, and that you also have a &lt;code&gt;remote&lt;/code&gt; connection to &lt;code&gt;origin/master&lt;/code&gt;. What remote repository is &lt;code&gt;remote/origin&lt;/code&gt;? Try &lt;code&gt;git remote -v&lt;/code&gt; to see the URLs for the remote. They will point to your &lt;a href=&quot;https://github.com/numpy/numpy&quot;&gt;github&lt;/a&gt; fork.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="49e089f7d3412f57a533b95b4289e1725ee616b3" translate="yes" xml:space="preserve">
          <source>This template converter will replicate all &lt;strong&gt;function&lt;/strong&gt; and &lt;strong&gt;subroutine&lt;/strong&gt; blocks in the file with names that contain &amp;lsquo;&amp;lt;&amp;hellip;&amp;gt;&amp;rsquo; according to the rules in &amp;lsquo;&amp;lt;&amp;hellip;&amp;gt;&amp;rsquo;. The number of comma-separated words in &amp;lsquo;&amp;lt;&amp;hellip;&amp;gt;&amp;rsquo; determines the number of times the block is repeated. What these words are indicates what that repeat rule, &amp;lsquo;&amp;lt;&amp;hellip;&amp;gt;&amp;rsquo;, should be replaced with in each block. All of the repeat rules in a block must contain the same number of comma-separated words indicating the number of times that block should be repeated. If the word in the repeat rule needs a comma, leftarrow, or rightarrow, then prepend it with a backslash &amp;lsquo; &amp;lsquo;. If a word in the repeat rule matches &amp;lsquo; \&amp;lt;index&amp;gt;&amp;rsquo; then it will be replaced with the &amp;lt;index&amp;gt;-th word in the same repeat specification. There are two forms for the repeat rule: named and short.</source>
          <target state="translated">Этот конвертер шаблонов будет копировать все &lt;strong&gt;функции&lt;/strong&gt; и &lt;strong&gt;подпрограммы.&lt;/strong&gt;блоки в файле с именами, которые содержат &amp;laquo;&amp;lt;&amp;hellip;&amp;gt;&amp;raquo; согласно правилам в &amp;laquo;&amp;lt;&amp;hellip;&amp;gt;&amp;raquo;. Количество слов, разделенных запятыми, в '&amp;lt;&amp;hellip;&amp;gt;' определяет количество повторений блока. То, что означают эти слова, указывает на то, что это правило повтора, &amp;laquo;&amp;lt;&amp;hellip;&amp;gt;&amp;raquo;, должно быть заменено в каждом блоке. Все правила повтора в блоке должны содержать одинаковое количество слов, разделенных запятыми, указывающих, сколько раз этот блок должен быть повторен. Если для слова в правиле повтора требуется запятая, стрелка влево или вправо, добавьте перед ним обратную косую черту ''. Если слово в правиле повтора совпадает с '\ &amp;lt;index&amp;gt;', тогда оно будет заменено &amp;lt;index&amp;gt; -м словом в той же спецификации повтора. Существует две формы правила повтора: именованная и краткая.</target>
        </trans-unit>
        <trans-unit id="e17f08578fff4f4b7f45b2cc421b1a2466a7ddfd" translate="yes" xml:space="preserve">
          <source>This tutorial is for people who have a basic understanding of linear algebra and arrays in NumPy and want to understand how n-dimensional (</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f4e248732bbeee435a6603f84a77d8416a7d7b4" translate="yes" xml:space="preserve">
          <source>This tutorial is intended as a quick overview of algebra and arrays in NumPy and want to understand how n-dimensional (</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3fb6c8e0c4b1a20c93f451ff612ab566979e83c" translate="yes" xml:space="preserve">
          <source>This type provides an iterator that encapsulates the concept of broadcasting. It allows</source>
          <target state="translated">Этот тип предоставляет итератор,который инкапсулирует концепцию вещания.Он позволяет</target>
        </trans-unit>
        <trans-unit id="1cc43cfc53c5139a19951c354fea30226e0f77c2" translate="yes" xml:space="preserve">
          <source>This updates your feature branch with changes from the upstream &lt;a href=&quot;https://github.com/numpy/numpy&quot;&gt;NumPy github&lt;/a&gt; repo. If you do not absolutely need to do this, try to avoid doing it, except perhaps when you are finished. The first step will be to update the remote repository with new commits from upstream:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fedc2274acc4b818673988228fa9cde0f7271aad" translate="yes" xml:space="preserve">
          <source>This usage is discouraged, because it is ambiguous with the other dict-based construction method. If you have a field called &amp;lsquo;names&amp;rsquo; and a field called &amp;lsquo;formats&amp;rsquo; there will be a conflict.</source>
          <target state="translated">Такое использование не рекомендуется, поскольку оно неоднозначно с другим методом построения на основе dict. Если у вас есть поле с именем &amp;laquo;имена&amp;raquo; и поле с именем &amp;laquo;форматы&amp;raquo;, возникнет конфликт.</target>
        </trans-unit>
        <trans-unit id="57872c5abdb149b7d4963cf4f155c74d4913dff4" translate="yes" xml:space="preserve">
          <source>This version replaces the ASCII string (which in practice was latin1) with a utf8-encoded string, so supports structured types with any unicode field names.</source>
          <target state="translated">Эта версия заменяет ASCII-строку (которая на практике была латинской1)на строку в кодировке utf8,поэтому поддерживает структурированные типы с любыми юникодовыми именами полей.</target>
        </trans-unit>
        <trans-unit id="edc2f7bd6317d38177dd997f322c5b71aa234a4f" translate="yes" xml:space="preserve">
          <source>This view has the same dtype and itemsize as the indexed field, so it is typically a non-structured array, except in the case of nested structures.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f66a767f0f656eca452c102d2e2bcfa75e3b2eec" translate="yes" xml:space="preserve">
          <source>This way of working helps to keep work well organized and the history as clear as possible.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd10a8b1d06600ccbaab74bb218a771768eae1ee" translate="yes" xml:space="preserve">
          <source>This will ask for your key PGP passphrase, in order to sign the built source packages.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b6efd49b695f694142bfb54798d0f3fc1890e14" translate="yes" xml:space="preserve">
          <source>This will be a new view object if possible; otherwise, it will be a copy. Note there is no guarantee of the &lt;em&gt;memory layout&lt;/em&gt; (C- or Fortran- contiguous) of the returned array.</source>
          <target state="translated">Если возможно, это будет новый объект просмотра; в противном случае это будет копия. Обратите внимание, что нет гарантии, что структура &lt;em&gt;памяти&lt;/em&gt; (непрерывная на C или Фортране) возвращаемого массива.</target>
        </trans-unit>
        <trans-unit id="8a5efb1ea8118b8207bdfa5a6ca70f84b9755cf3" translate="yes" xml:space="preserve">
          <source>This will be the default for all columns</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ee2bb240a6f906f9c6caaca502a22c771c78509" translate="yes" xml:space="preserve">
          <source>This will compile numpy on 4 CPUs and install it into the specified prefix. to perform a parallel in-place build, run:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="82de4d27fe00c2e50e0f9b4ff494406f1e8a2a9f" translate="yes" xml:space="preserve">
          <source>This will create a report in &lt;code&gt;build/coverage&lt;/code&gt;, which can be viewed with:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8933167843c02b6efd0369f05c57b0cadbffbc22" translate="yes" xml:space="preserve">
          <source>This will install the file foo.ini into the directory package_dir/lib, and the foo.ini file will be generated from foo.ini.in, where each &lt;code&gt;@version@&lt;/code&gt; will be replaced by &lt;code&gt;subst_dict['version']&lt;/code&gt;. The dictionary has an additional prefix substitution rule automatically added, which contains the install prefix (since this is not easy to get from setup.py). npy-pkg-config files can also be installed at the same location as used for numpy, using the path returned from &lt;code&gt;get_npy_pkg_dir&lt;/code&gt; function.</source>
          <target state="translated">Это установит файл foo.ini в каталог каталог_пакета / lib, а файл foo.ini будет создан из foo.ini.in, где каждая &lt;code&gt;@version@&lt;/code&gt; будет заменена на &lt;code&gt;subst_dict['version']&lt;/code&gt; . В словарь автоматически добавляется дополнительное правило подстановки префикса, которое содержит префикс установки (поскольку его нелегко получить из setup.py). Файлы npy-pkg-config также могут быть установлены в том же месте, что и numpy, используя путь, возвращенный функцией &lt;code&gt;get_npy_pkg_dir&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="520884ce9a07e1b7b3267f965a90c87f51ddd2d6" translate="yes" xml:space="preserve">
          <source>This will open an editor with the following text in it:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="939c7c1369b63ae063d5f436c52d25c44b07c327" translate="yes" xml:space="preserve">
          <source>This will produce an extension module named filter.so in the current directory with a method named dfilter2d that returns a filtered version of the input.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da4b4079ec57ef48d099df7ab2d17f04629ceaf5" translate="yes" xml:space="preserve">
          <source>This will work with MSVC, which otherwise chokes on very long strings.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="09f5f63667326a5abebdc8b9ee9a7240e62a05f5" translate="yes" xml:space="preserve">
          <source>This will write the settings into your git configuration file, which should now contain a user section with your name and email:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="00582fa3dde2e164fba27e484b480804eaaba584" translate="yes" xml:space="preserve">
          <source>This works for both standard installs and in-place builds, i.e. the &lt;code&gt;@prefix@&lt;/code&gt; refer to the source directory for in-place builds.</source>
          <target state="translated">Это работает как для стандартной установки, так и для сборок на месте, т.е. &lt;code&gt;@prefix@&lt;/code&gt; относится к исходному каталогу для сборок на месте.</target>
        </trans-unit>
        <trans-unit id="8dbc0909265236a8e2f517b68e39944b2e4da272" translate="yes" xml:space="preserve">
          <source>Those can be useful for precise floating point comparison.</source>
          <target state="translated">Они могут быть полезны для точного сравнения с плавающей точкой.</target>
        </trans-unit>
        <trans-unit id="ae29a3649bad434c98c44c18fb3c7ec696b132a3" translate="yes" xml:space="preserve">
          <source>Those who want really good performance out of their low level operations should strongly consider directly using the iteration API provided in C, but for those who are not comfortable with C or C++, Cython is a good middle ground with reasonable performance tradeoffs. For the &lt;a href=&quot;generated/numpy.nditer#numpy.nditer&quot;&gt;&lt;code&gt;nditer&lt;/code&gt;&lt;/a&gt; object, this means letting the iterator take care of broadcasting, dtype conversion, and buffering, while giving the inner loop to Cython.</source>
          <target state="translated">Тем, кто хочет действительно хорошей производительности своих низкоуровневых операций, следует настоятельно рассмотреть возможность прямого использования итерационного API, представленного на C, но для тех, кто не чувствует себя комфортно с C или C ++, Cython является хорошим промежуточным звеном с разумными компромиссами с производительностью. Для объекта &lt;a href=&quot;generated/numpy.nditer#numpy.nditer&quot;&gt; &lt;code&gt;nditer&lt;/code&gt; &lt;/a&gt; это означает, что итератор может позаботиться о широковещательной рассылке, преобразовании dtype и буферизации, передавая внутренний цикл Cython.</target>
        </trans-unit>
        <trans-unit id="69a5e45c8dfd90560d7c862ef6ebab38e4725ee6" translate="yes" xml:space="preserve">
          <source>Though the demonstrated way of wrapping Fortran routines to Python is very straightforward, it has several drawbacks (see the comments above). These drawbacks are due to the fact that there is no way that F2PY can determine what is the actual intention of one or the other argument, is it input or output argument, or both, or something else. So, F2PY conservatively assumes that all arguments are input arguments by default.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ea9f95f9e9b92d3d1f748e1eafd1b88bb106fab" translate="yes" xml:space="preserve">
          <source>Though we welcome people fluent in all languages, NumPy development is conducted in English.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="35e557dff981ec6af1be9c041d1715ad421f55bd" translate="yes" xml:space="preserve">
          <source>Threading support</source>
          <target state="translated">Поддержка резьбы</target>
        </trans-unit>
        <trans-unit id="2d3ac6352887bde0f838813d8ea2d7bd7a567c2f" translate="yes" xml:space="preserve">
          <source>Three common use cases are:</source>
          <target state="translated">Три варианта использования:</target>
        </trans-unit>
        <trans-unit id="cfe35da7de09a2e27452780257d1fa8fced9ae75" translate="yes" xml:space="preserve">
          <source>Three ways to wrap - getting started</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="987f8885750fc51202cc3964c96525b26400aa8c" translate="yes" xml:space="preserve">
          <source>Three-by-two array of random numbers from [-5, 0):</source>
          <target state="translated">Массив случайных чисел из [-5,0]:</target>
        </trans-unit>
        <trans-unit id="648f2b8e04236f9ba0d33739777255491d46f3b0" translate="yes" xml:space="preserve">
          <source>Threshold below which SVD values are considered zero. If &lt;code&gt;tol&lt;/code&gt; is None, and &lt;code&gt;S&lt;/code&gt; is an array with singular values for &lt;code&gt;M&lt;/code&gt;, and &lt;code&gt;eps&lt;/code&gt; is the epsilon value for datatype of &lt;code&gt;S&lt;/code&gt;, then &lt;code&gt;tol&lt;/code&gt; is set to &lt;code&gt;S.max() * max(M.shape) * eps&lt;/code&gt;.</source>
          <target state="translated">Порог, ниже которого значения SVD считаются нулевыми. Если &lt;code&gt;tol&lt;/code&gt; равно None, а &lt;code&gt;S&lt;/code&gt; - это массив с сингулярными значениями для &lt;code&gt;M&lt;/code&gt; , а &lt;code&gt;eps&lt;/code&gt; - эпсилон-значение для типа данных &lt;code&gt;S&lt;/code&gt; , тогда &lt;code&gt;tol&lt;/code&gt; устанавливается в &lt;code&gt;S.max() * max(M.shape) * eps&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3a18ce980b9b6a0af6ba5335aa5043a3f61a2139" translate="yes" xml:space="preserve">
          <source>Throw a dice 20 times:</source>
          <target state="translated">Бросай кубик 20 раз:</target>
        </trans-unit>
        <trans-unit id="c6c62c18ed666f3768ae228e6da435d58941de5d" translate="yes" xml:space="preserve">
          <source>Thus, tuples might be thought of as the native Python equivalent to numpy&amp;rsquo;s structured types, much like native python integers are the equivalent to numpy&amp;rsquo;s integer types. Structured scalars may be converted to a tuple by calling &lt;code&gt;ndarray.item&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="699ce8b0c5a25495e7df7b31eb754f06f5937265" translate="yes" xml:space="preserve">
          <source>Tile an array.</source>
          <target state="translated">Напишите массив.</target>
        </trans-unit>
        <trans-unit id="9478b387e78ee7ed878f28def0d9d737a40db3cf" translate="yes" xml:space="preserve">
          <source>Tiling arrays</source>
          <target state="translated">Массивы плитки</target>
        </trans-unit>
        <trans-unit id="ae9e32a7bf76d858a6643fb3d615f4e6b741df45" translate="yes" xml:space="preserve">
          <source>Time span (absolute)</source>
          <target state="translated">Временной интервал (абсолютный)</target>
        </trans-unit>
        <trans-unit id="83a0b67f984af7843f2cd5f9c4c4a4937a96b824" translate="yes" xml:space="preserve">
          <source>Time span (relative)</source>
          <target state="translated">Временной интервал (относительный)</target>
        </trans-unit>
        <trans-unit id="f427901653e2f16331f232b03616db8d30b0bf3e" translate="yes" xml:space="preserve">
          <source>Timedelta</source>
          <target state="translated">Timedelta</target>
        </trans-unit>
        <trans-unit id="a836f04893b4c22a5902f8a189928c3d93f72795" translate="yes" xml:space="preserve">
          <source>Timezone information to use when displaying the datetime. If &amp;lsquo;UTC&amp;rsquo;, end with a Z to indicate UTC time. If &amp;lsquo;local&amp;rsquo;, convert to the local timezone first, and suffix with a +-#### timezone offset. If a tzinfo object, then do as with &amp;lsquo;local&amp;rsquo;, but use the specified timezone.</source>
          <target state="translated">Информация о часовом поясе для использования при отображении даты и времени. Если &quot;UTC&quot;, в конце укажите Z, чтобы указать время UTC. Если &quot;местный&quot;, сначала конвертируйте в местный часовой пояс и суффикс со смещением часового пояса + - ####. Если объект tzinfo, то сделайте то же, что и с 'local', но используйте указанный часовой пояс.</target>
        </trans-unit>
        <trans-unit id="73a38ab3a76b2ed7df0194513c7633ac39221da4" translate="yes" xml:space="preserve">
          <source>Timing of individual tests with &lt;code&gt;nose-timer&lt;/code&gt; (which needs to be installed). If True, time tests and report on all of them. If an integer (say &lt;code&gt;N&lt;/code&gt;), report timing results for &lt;code&gt;N&lt;/code&gt; slowest tests.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="661d4063b8ec8980f63428513015c42d7d7a39d4" translate="yes" xml:space="preserve">
          <source>Timings</source>
          <target state="translated">Timings</target>
        </trans-unit>
        <trans-unit id="535904f7958066905a2c6d516287e9eeaaa0c6e1" translate="yes" xml:space="preserve">
          <source>Timsort and radix sort have replaced mergesort for stable sorting</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="18696f01e06a1b84af54b40680c306637cf01d64" translate="yes" xml:space="preserve">
          <source>Timsort is added for better performance on already or nearly sorted data. On random data timsort is almost identical to mergesort. It is now used for stable sort while quicksort is still the default sort if none is chosen. For details of timsort, refer to &lt;a href=&quot;https://github.com/python/cpython/blob/3.7/Objects/listsort.txt&quot;&gt;CPython listsort.txt&lt;/a&gt;. &amp;lsquo;mergesort&amp;rsquo; and &amp;lsquo;stable&amp;rsquo; are mapped to radix sort for integer data types. Radix sort is an O(n) sort instead of O(n log n).</source>
          <target state="translated">Timsort добавлен для повышения производительности на уже или почти отсортированных данных. По случайным данным временная сортировка почти идентична сортировке слиянием. Теперь он используется для стабильной сортировки, в то время как быстрая сортировка по-прежнему является сортировкой по умолчанию, если она не выбрана. Дополнительные сведения о timsort см. В &lt;a href=&quot;https://github.com/python/cpython/blob/3.7/Objects/listsort.txt&quot;&gt;CPython listsort.txt&lt;/a&gt; . 'mergesort' и 'stable' отображаются для сортировки по основанию для целочисленных типов данных. Сортировка Radix - это сортировка O (n) вместо O (n log n).</target>
        </trans-unit>
        <trans-unit id="4c9ab7d1647422ac2345aafe56b9ec321ff2ddfd" translate="yes" xml:space="preserve">
          <source>Timsort is added for better performance on already or nearly sorted data. On random data timsort is almost identical to mergesort. It is now used for stable sort while quicksort is still the default sort if none is chosen. For timsort details, refer to &lt;a href=&quot;https://github.com/python/cpython/blob/3.7/Objects/listsort.txt&quot;&gt;CPython listsort.txt&lt;/a&gt;. &amp;lsquo;mergesort&amp;rsquo; and &amp;lsquo;stable&amp;rsquo; are mapped to radix sort for integer data types. Radix sort is an O(n) sort instead of O(n log n).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d19ceca501465c339e3bcf2bc0d8ff02bb697d6c" translate="yes" xml:space="preserve">
          <source>Tip</source>
          <target state="translated">Tip</target>
        </trans-unit>
        <trans-unit id="e4a5f9b37a824ec47658f0ce1a5ad5ba55b84339" translate="yes" xml:space="preserve">
          <source>Tip: &lt;code&gt;entry&lt;/code&gt; statement can be used to describe the signature of an arbitrary routine allowing F2PY to generate a number of wrappers from only one routine block signature. There are few restrictions while doing this: &lt;code&gt;fortranname&lt;/code&gt; cannot be used, &lt;code&gt;callstatement&lt;/code&gt; and &lt;code&gt;callprotoargument&lt;/code&gt; can be used only if they are valid for all entry routines, etc.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e96f3984eaaf637764ee32773288dabcc604bf6b" translate="yes" xml:space="preserve">
          <source>Tips &amp;amp; Tricks</source>
          <target state="translated">Советы и хитрости</target>
        </trans-unit>
        <trans-unit id="caa39d36bfce368de59fb6b06774c2bd179f06cf" translate="yes" xml:space="preserve">
          <source>Title case words start with uppercase characters, all remaining cased characters are lowercase.</source>
          <target state="translated">Слова в заглавном регистре начинаются с заглавных символов,все остальные символы в заглавном регистре-строчные.</target>
        </trans-unit>
        <trans-unit id="45c41172aa1c58d7ba017f081fcd4e2ace4e86f0" translate="yes" xml:space="preserve">
          <source>Title that is printed in the string representation of &lt;a href=&quot;#numpy.MachAr&quot;&gt;&lt;code&gt;MachAr&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Заголовок, который печатается в строковом представлении &lt;a href=&quot;#numpy.MachAr&quot;&gt; &lt;code&gt;MachAr&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="20fb23c1b6aaaab924d80202c9bd41b9e867e2de" translate="yes" xml:space="preserve">
          <source>To Cython-ize this function, we replace the inner loop (y[&amp;hellip;] += x*x) with Cython code that&amp;rsquo;s specialized for the float64 dtype. With the &amp;lsquo;external_loop&amp;rsquo; flag enabled, the arrays provided to the inner loop will always be one-dimensional, so very little checking needs to be done.</source>
          <target state="translated">Чтобы использовать эту функцию в Cython, мы заменяем внутренний цикл (y [&amp;hellip;] + = x * x) кодом Cython, специализированным для dtype float64. При включенном флаге external_loop массивы, предоставляемые внутреннему циклу, всегда будут одномерными, поэтому необходимо выполнять очень небольшую проверку.</target>
        </trans-unit>
        <trans-unit id="36e086a6bd3eb648c4aebbd467026f4cd1c91bb0" translate="yes" xml:space="preserve">
          <source>To achieve a behaviour similar to the basic slicing above, broadcasting can be used. The function &lt;a href=&quot;generated/numpy.ix_#numpy.ix_&quot;&gt;&lt;code&gt;ix_&lt;/code&gt;&lt;/a&gt; can help with this broadcasting. This is best understood with an example.</source>
          <target state="translated">Чтобы добиться поведения, аналогичного описанному выше базовому нарезанию, можно использовать широковещательную рассылку. Функция &lt;a href=&quot;generated/numpy.ix_#numpy.ix_&quot;&gt; &lt;code&gt;ix_&lt;/code&gt; &lt;/a&gt; может помочь с этим вещанием. Лучше всего это понять на примере.</target>
        </trans-unit>
        <trans-unit id="157492b79c5123115a363aac40a6322c3b4d23a2" translate="yes" xml:space="preserve">
          <source>To achieve what we want, we will make the following changes to it:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d82eff9778b88421c109607c96725b336dc7bcf8" translate="yes" xml:space="preserve">
          <source>To actually build the binaries after everything is set up correctly, the release.sh script can be used. For details of the build process itself, it is best to read the pavement.py script.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c76b68b96c698129b0e21483e667a083f4f8f28a" translate="yes" xml:space="preserve">
          <source>To add the rows or the columns in a 2D array, you would specify the axis.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3f0b09a56b5f5cb6866275af7bae4ae9b88cd546" translate="yes" xml:space="preserve">
          <source>To add titles when using the list-of-tuples form of dtype specification, the field name may be specified as a tuple of two strings instead of a single string, which will be the field&amp;rsquo;s title and field name respectively. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="03c09cbfb1aed4718ffc26452a3968e86a1cd3bc" translate="yes" xml:space="preserve">
          <source>To allow the datetime to be used in contexts where only certain days of the week are valid, NumPy includes a set of &amp;ldquo;busday&amp;rdquo; (business day) functions.</source>
          <target state="translated">Чтобы разрешить использование datetime в контекстах, где допустимы только определенные дни недели, NumPy включает набор функций &amp;laquo;busday&amp;raquo; (рабочий день).</target>
        </trans-unit>
        <trans-unit id="846af85fcfe300adce4c3f84895144d6dc4a75b5" translate="yes" xml:space="preserve">
          <source>To be completed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f6ad91f78d6c9353549254a135a4c203ecca9427" translate="yes" xml:space="preserve">
          <source>To be consistent with surrounding code that also breaks it (maybe for historic reasons) &amp;ndash; although this is also an opportunity to clean up someone else&amp;rsquo;s mess.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="172099588df066f08374020a56522cb6cad0b84f" translate="yes" xml:space="preserve">
          <source>To become eligible to join the Steering Council, an individual must be a Project Contributor who has produced contributions that are substantial in quality and quantity, and sustained over at least one year. Potential Council Members are nominated by existing Council members, and become members following consensus of the existing Council members, and confirmation that the potential Member is interested and willing to serve in that capacity. The Council will be initially formed from the set of existing Core Developers who, as of late 2015, have been significantly active over the last year.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="85134bce24b996ec39a48245eda44b01d4da42e0" translate="yes" xml:space="preserve">
          <source>To begin to make use of the new data-type, you need to first define a new Python type to hold the scalars of your new data-type. It should be acceptable to inherit from one of the array scalars if your new type has a binary compatible layout. This will allow your new data type to have the methods and attributes of array scalars. New data- types must have a fixed memory size (if you want to define a data-type that needs a flexible representation, like a variable-precision number, then use a pointer to the object as the data-type). The memory layout of the object structure for the new Python type must be PyObject_HEAD followed by the fixed-size memory needed for the data- type. For example, a suitable structure for the new Python type is:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c381239eecf186cabc8bbf33e7f7340c36dd415" translate="yes" xml:space="preserve">
          <source>To build an extension module, use</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="262ab678dba163772e713fb5aa569cad52138f55" translate="yes" xml:space="preserve">
          <source>To build any extension modules for Python, you&amp;rsquo;ll need a C compiler. Various NumPy modules use FORTRAN 77 libraries, so you&amp;rsquo;ll also need a FORTRAN 77 compiler installed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e7e5cfb4630032e513b61c1b673be491694cda68" translate="yes" xml:space="preserve">
          <source>To build docs, run &lt;code&gt;make&lt;/code&gt; from the &lt;code&gt;doc&lt;/code&gt; directory. &lt;code&gt;make help&lt;/code&gt; lists all targets. For example, to build the HTML documentation, you can run:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0116b47532b1c9e3e3765cf9819856a98d018b60" translate="yes" xml:space="preserve">
          <source>To build the PDF documentation, do instead:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="06915cfab63303daaadd53bd88f46eb60701ce38" translate="yes" xml:space="preserve">
          <source>To build the development version of NumPy and run tests, spawn interactive shells with the Python import paths properly set up etc., do one of:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="62e6dd105e1e44140e34cc1b1405df856709feb0" translate="yes" xml:space="preserve">
          <source>To build the final approximation matrix, we must understand how multiplication across different axes works.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9057f4f734687a0b8a5f3961b0c067a8d6921992" translate="yes" xml:space="preserve">
          <source>To change the dimensions of an array, you can omit one of the sizes which will then be deduced automatically:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="59e2711afc65081105d063104c0dfaff7b844b23" translate="yes" xml:space="preserve">
          <source>To commit the staged files into the local copy of your repo, do &lt;code&gt;git
commit&lt;/code&gt;. At this point, a text editor will open up to allow you to write a commit message. Read the &lt;a href=&quot;#writing-the-commit-message&quot;&gt;commit message section&lt;/a&gt; to be sure that you are writing a properly formatted and sufficiently detailed commit message. After saving your message and closing the editor, your commit will be saved. For trivial commits, a short commit message can be passed in through the command line using the &lt;code&gt;-m&lt;/code&gt; flag. For example, &lt;code&gt;git commit -am &quot;ENH: Some message&quot;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e713f5c0c4fc2dee368727d5468ec1ab8e8b8170" translate="yes" xml:space="preserve">
          <source>To construct an extension module, use</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d3a9fa41ffe14d77bbc445c74fe6fd7a66d7a2d" translate="yes" xml:space="preserve">
          <source>To convert the type of an array, use the .astype() method (preferred) or the type itself as a function. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="982c13e7b2d67cdbdf6848604f9d8f779a4cdca3" translate="yes" xml:space="preserve">
          <source>To create a NumPy array, you can use the function &lt;code&gt;np.array()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8941cedf9a3b3622178e2a604f85c6f9966d6beb" translate="yes" xml:space="preserve">
          <source>To create a masked array where all values close to 1.e20 are invalid, we would do:</source>
          <target state="translated">Для создания маскированного массива,в котором все значения,близкие к 1.e20,являются недействительными,мы бы сделали это:</target>
        </trans-unit>
        <trans-unit id="e67f8cba1a223a6d273b67fa4a3d036f127fda38" translate="yes" xml:space="preserve">
          <source>To create a sub-type, a similar procedure must be followed except only behaviors that are different require new entries in the type- object structure. All other entries can be NULL and will be filled in by &lt;a href=&quot;https://docs.python.org/dev/c-api/type.html#c.PyType_Ready&quot;&gt;&lt;code&gt;PyType_Ready&lt;/code&gt;&lt;/a&gt; with appropriate functions from the parent type(s). In particular, to create a sub-type in C follow these steps:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fdf86d74a7427ac0a22c6f0a9b96d12080099d0c" translate="yes" xml:space="preserve">
          <source>To create an array with the second element invalid, we would do:</source>
          <target state="translated">Для создания массива с недействительным вторым элементом мы бы сделали это:</target>
        </trans-unit>
        <trans-unit id="27de4fde4d9713bb683ffd50eb85f9b3570fc745" translate="yes" xml:space="preserve">
          <source>To create sequences of numbers, NumPy provides the &lt;code&gt;arange&lt;/code&gt; function which is analogous to the Python built-in &lt;code&gt;range&lt;/code&gt;, but returns an array.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="97ab86f3d69d58ce3be53a871603ed078f8824cf" translate="yes" xml:space="preserve">
          <source>To describe the type of scalar data, there are several &lt;a href=&quot;arrays.scalars#arrays-scalars-built-in&quot;&gt;built-in scalar types&lt;/a&gt; in NumPy for various precision of integers, floating-point numbers, &lt;em&gt;etc&lt;/em&gt;. An item extracted from an array, &lt;em&gt;e.g.&lt;/em&gt;, by indexing, will be a Python object whose type is the scalar type associated with the data type of the array.</source>
          <target state="translated">Чтобы описать тип скалярных данных, в NumPy есть несколько &lt;a href=&quot;arrays.scalars#arrays-scalars-built-in&quot;&gt;встроенных скалярных типов&lt;/a&gt; для различной точности целых чисел, чисел с плавающей запятой и &lt;em&gt;т&lt;/em&gt; . Д. Элемент, извлеченный из массива, &lt;em&gt;например&lt;/em&gt; , путем индексации, будет объектом Python, тип которого является скалярным типом, связанным с типом данных массива.</target>
        </trans-unit>
        <trans-unit id="44e1fab9f28a4fa50d8975e0a1e46a2e64c1e9dc" translate="yes" xml:space="preserve">
          <source>To determine the type of an array, look at the dtype attribute:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9f971fbdece5884152a2421faf1e4b6e44db96d0" translate="yes" xml:space="preserve">
          <source>To disable this behaviour and force NumPy to print the entire array, you can change the printing options using &lt;code&gt;set_printoptions&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="42815d30b39c91ade5f76679c62182278601bee8" translate="yes" xml:space="preserve">
          <source>To do buffered reduction requires yet another adjustment during the setup. Normally the iterator construction involves copying the first buffer of data from the readable arrays into the buffer. Any reduction operand is readable, so it may be read into a buffer. Unfortunately, initialization of the operand after this buffering operation is complete will not be reflected in the buffer that the iteration starts with, and garbage results will be produced.</source>
          <target state="translated">Для выполнения буферизованного уменьшения требуется еще одна регулировка во время настройки.Обычно конструкция итератора подразумевает копирование первого буфера данных из читаемых массивов в буфер.Любой операнд сокращения читается,поэтому он может быть прочитан в буфере.К сожалению,инициализация операнда после завершения этой операции буферизации не будет отражена в буфере,с которого начинается итерация,и будет получен мусорный результат.</target>
        </trans-unit>
        <trans-unit id="7bb73bf7d0560f6eb01b8f605dab2705b707dec2" translate="yes" xml:space="preserve">
          <source>To do this we need two files. The first is the C file which contains the actual code, and the second is the setup.py file used to create the module.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2a3fff7f3035206492b3a95d3cbf852432de0dee" translate="yes" xml:space="preserve">
          <source>To enable and control broadcasting, use an ellipsis. Default NumPy-style broadcasting is done by adding an ellipsis to the left of each term, like &lt;code&gt;np.einsum('...ii-&amp;gt;...i', a)&lt;/code&gt;. To take the trace along the first and last axes, you can do &lt;code&gt;np.einsum('i...i', a)&lt;/code&gt;, or to do a matrix-matrix product with the left-most indices instead of rightmost, one can do &lt;code&gt;np.einsum('ij...,jk...-&amp;gt;ik...', a, b)&lt;/code&gt;.</source>
          <target state="translated">Для включения и управления трансляцией используйте многоточие. Трансляция в стиле NumPy по умолчанию осуществляется путем добавления многоточия слева от каждого термина, например &lt;code&gt;np.einsum('...ii-&amp;gt;...i', a)&lt;/code&gt; . Чтобы провести трассировку по первой и последней осям, вы можете выполнить &lt;code&gt;np.einsum('i...i', a)&lt;/code&gt; или выполнить произведение матрица-матрица с крайними левыми индексами вместо крайних правых, можно сделать &lt;code&gt;np.einsum('ij...,jk...-&amp;gt;ik...', a, b)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="73e17138c97818c1d4c0e646e333300b5a17a016" translate="yes" xml:space="preserve">
          <source>To enforce summaries when doing merges (&lt;code&gt;~/.gitconfig&lt;/code&gt; file again):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="03b64a95ca31ed1440ed9609a8efdae966875477" translate="yes" xml:space="preserve">
          <source>To ensure all elements within an &lt;code&gt;object&lt;/code&gt; array are copied, use &lt;a href=&quot;https://docs.python.org/dev/library/copy.html#copy.deepcopy&quot;&gt;&lt;code&gt;copy.deepcopy&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="56d44cf88fb39b36da11cf8bbe02f976134b23c7" translate="yes" xml:space="preserve">
          <source>To facilitate easy matching of array shapes with expressions and in assignments, the np.newaxis object can be used within array indices to add new dimensions with a size of 1. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="09fc0ca575462761f878d637a2fecf46e1ccd71c" translate="yes" xml:space="preserve">
          <source>To facilitate this many similar unit tests, some high-level programming techniques are employed, including C and &lt;a href=&quot;http://www.swig.org&quot;&gt;SWIG&lt;/a&gt; macros, as well as Python inheritance. The purpose of this document is to describe the testing infrastructure employed to verify that the &lt;code&gt;numpy.i&lt;/code&gt; typemaps are working as expected.</source>
          <target state="translated">Чтобы облегчить это множество подобных модульных тестов, используются некоторые высокоуровневые методы программирования, включая макросы C и &lt;a href=&quot;http://www.swig.org&quot;&gt;SWIG&lt;/a&gt; , а также наследование Python. Целью этого документа является описание инфраструктуры тестирования, используемой для проверки того, что &lt;code&gt;numpy.i&lt;/code&gt; типов numpy.i работают должным образом.</target>
        </trans-unit>
        <trans-unit id="df1248d3a4c3c276bf78a49ecea34ca2333414db" translate="yes" xml:space="preserve">
          <source>To find how many valid days there are in a specified range of datetime64 dates, use &lt;a href=&quot;generated/numpy.busday_count#numpy.busday_count&quot;&gt;&lt;code&gt;busday_count&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">Чтобы узнать, сколько действительных дней находится в указанном диапазоне дат datetime64, используйте &lt;a href=&quot;generated/numpy.busday_count#numpy.busday_count&quot;&gt; &lt;code&gt;busday_count&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="319db282e290412afdbf4c23744ae53a90ac551e" translate="yes" xml:space="preserve">
          <source>To find the number of dimensions of the array, run:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3533d0798888b92292cdc274cd5cbd4e7bdef89" translate="yes" xml:space="preserve">
          <source>To find the total number of elements in the array, run:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="381cf7b173efa6d304977d6f48b6eab1589b8ebf" translate="yes" xml:space="preserve">
          <source>To find the union of more than two arrays, use functools.reduce:</source>
          <target state="translated">Чтобы найти объединение более чем двух массивов,используйте functools.reduce:</target>
        </trans-unit>
        <trans-unit id="f20ef83823da30eba7178dbce314c99b1ef83b27" translate="yes" xml:space="preserve">
          <source>To get a feel for writing custom array containers, we&amp;rsquo;ll begin with a simple example that has rather narrow utility but illustrates the concepts involved.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e3a3751da83fe0d7f7a6c4230ed886f73729cca0" translate="yes" xml:space="preserve">
          <source>To get back to a plain ndarray both the dtype and type must be reset. The following view does so, taking into account the unusual case that the recordarr was not a structured type:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4469a3b55f422122d26688e1424f485904a4794e" translate="yes" xml:space="preserve">
          <source>To get the indices of unique values in a NumPy array (an array of first index positions of unique values in the array), just pass the &lt;code&gt;return_index&lt;/code&gt; argument in &lt;code&gt;np.unique()&lt;/code&gt; as well as your array.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f05508b4b1612d928370bd8d22c78ce6740d7d75" translate="yes" xml:space="preserve">
          <source>To get the necessary information for the npymath library from NumPy:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b92fc58e63db5aa668493a43f6017a9433c467a" translate="yes" xml:space="preserve">
          <source>To get the unique rows, index position, and occurrence count, you can use:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8cb65420b2ca2983f196bbc9804b56531579abff" translate="yes" xml:space="preserve">
          <source>To group the indices by element, rather than dimension, use &lt;a href=&quot;numpy.argwhere#numpy.argwhere&quot;&gt;&lt;code&gt;argwhere&lt;/code&gt;&lt;/a&gt;, which returns a row for each non-zero element.</source>
          <target state="translated">Чтобы сгруппировать индексы по элементам, а не по размеру, используйте &lt;a href=&quot;numpy.argwhere#numpy.argwhere&quot;&gt; &lt;code&gt;argwhere&lt;/code&gt; &lt;/a&gt; , который возвращает строку для каждого ненулевого элемента.</target>
        </trans-unit>
        <trans-unit id="dd77da9e3cc0e1b206296360b148e66d7e5bf3e1" translate="yes" xml:space="preserve">
          <source>To group the indices by element, rather than dimension, use instead:</source>
          <target state="translated">Чтобы сгруппировать индексы по элементам,а не по размерности,используйте вместо них:</target>
        </trans-unit>
        <trans-unit id="ee4cd0adbfaa4d4a1d76673c36c93886ead4c8dd" translate="yes" xml:space="preserve">
          <source>To have a particular script file executed when the interactive Python interpreter is started, define the &lt;code&gt;PYTHONSTARTUP&lt;/code&gt; environment variable to contain the name of your startup script.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01fa3621bdaf741ed6a071c7af18f6f77c074d16" translate="yes" xml:space="preserve">
          <source>To implement the second method, NumPy provides the class-factory function &lt;a href=&quot;#ndpointer&quot;&gt;&lt;code&gt;ndpointer&lt;/code&gt;&lt;/a&gt; in the &lt;a href=&quot;../reference/routines.ctypeslib#module-numpy.ctypeslib&quot;&gt;&lt;code&gt;numpy.ctypeslib&lt;/code&gt;&lt;/a&gt; module. This class-factory function produces an appropriate class that can be placed in an argtypes attribute entry of a ctypes function. The class will contain a from_param method which ctypes will use to convert any ndarray passed in to the function to a ctypes-recognized object. In the process, the conversion will perform checking on any properties of the ndarray that were specified by the user in the call to &lt;a href=&quot;#ndpointer&quot;&gt;&lt;code&gt;ndpointer&lt;/code&gt;&lt;/a&gt;. Aspects of the ndarray that can be checked include the data-type, the number-of-dimensions, the shape, and/or the state of the flags on any array passed. The return value of the from_param method is the ctypes attribute of the array which (because it contains the &lt;code&gt;_as_parameter_&lt;/code&gt; attribute pointing to the array data area) can be used by ctypes directly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="50d801e69012a04f7e0e0473d58cee9ab38e87fd" translate="yes" xml:space="preserve">
          <source>To install NumPy, run:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd5ace9a611ff0639bf97923787f31ff3babad6c" translate="yes" xml:space="preserve">
          <source>To install NumPy, we strongly recommend using a scientific Python distribution. If you&amp;rsquo;re looking for the full instructions for installing NumPy on your operating system, you can &lt;a href=&quot;https://www.scipy.org/install.html&quot;&gt;find all of the details here&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ceadcdbd2ecba0b0b71d04b040d27f4a8978392" translate="yes" xml:space="preserve">
          <source>To intersect more than two arrays, use functools.reduce:</source>
          <target state="translated">Чтобы пересечь более двух массивов,используйте functools.reduce:</target>
        </trans-unit>
        <trans-unit id="1eeff99dc3325ea11208d15f34bf3ae08056f134" translate="yes" xml:space="preserve">
          <source>To keep in sync with changes in NumPy, you want to set up your repository so it pulls from &lt;code&gt;upstream&lt;/code&gt; by default. This can be done with:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="422eea08f184929b902e9a6c5257e9028826306a" translate="yes" xml:space="preserve">
          <source>To learn more about finding the unique elements in an array, see &lt;a href=&quot;../reference/generated/numpy.unique#numpy.unique&quot;&gt;&lt;code&gt;unique&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f5278c1b18ea2b8e10ed17f38664074c6889df4" translate="yes" xml:space="preserve">
          <source>To learn more about transposing and reshaping arrays, see &lt;a href=&quot;../reference/generated/numpy.transpose#numpy.transpose&quot;&gt;&lt;code&gt;transpose&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../reference/generated/numpy.reshape#numpy.reshape&quot;&gt;&lt;code&gt;reshape&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="68755700558e4129caf4a1646cfbb8316cee0dd6" translate="yes" xml:space="preserve">
          <source>To make an iterator similar to the old iterator, this should work.</source>
          <target state="translated">Чтобы сделать итератор похожим на старый итератор,это должно сработать.</target>
        </trans-unit>
        <trans-unit id="6d696015c14a0cbcd57511007788b5810594a8d0" translate="yes" xml:space="preserve">
          <source>To make its properties more readily accessible during iteration, &lt;a href=&quot;generated/numpy.nditer#numpy.nditer&quot;&gt;&lt;code&gt;nditer&lt;/code&gt;&lt;/a&gt; has an alternative syntax for iterating, which works explicitly with the iterator object itself. With this looping construct, the current value is accessible by indexing into the iterator. Other properties, such as tracked indices remain as before. The examples below produce identical results to the ones in the previous section.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dcb62bb890eb45640b1d129077fff1a1982947c5" translate="yes" xml:space="preserve">
          <source>To make the necessary build options available to third parties, you could use the &lt;code&gt;npy-pkg-config&lt;/code&gt; mechanism implemented in &lt;a href=&quot;#module-numpy.distutils&quot;&gt;&lt;code&gt;numpy.distutils&lt;/code&gt;&lt;/a&gt;. This mechanism is based on a .ini file which contains all the options. A .ini file is very similar to .pc files as used by the pkg-config unix utility:</source>
          <target state="translated">Чтобы сделать необходимые параметры сборки доступными для третьих лиц, вы можете использовать &lt;code&gt;npy-pkg-config&lt;/code&gt; , реализованный в &lt;a href=&quot;#module-numpy.distutils&quot;&gt; &lt;code&gt;numpy.distutils&lt;/code&gt; &lt;/a&gt; . Этот механизм основан на файле .ini, который содержит все параметры. Файл .ini очень похож на файлы .pc, используемые утилитой unix pkg-config:</target>
        </trans-unit>
        <trans-unit id="33556655b7ed4636c5875606d6d2c0f4cbb51bbb" translate="yes" xml:space="preserve">
          <source>To make your key more readily identifiable as you, consider sending your key to public keyservers, with a command such as:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="18c1e38c6bb6394f66a0d335e612f3011262ff50" translate="yes" xml:space="preserve">
          <source>To measure the test coverage, install &lt;a href=&quot;https://pytest-cov.readthedocs.io/en/latest/&quot;&gt;pytest-cov&lt;/a&gt; and then run:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6239277562da98f7f93ad4e57c8a93f41fe39464" translate="yes" xml:space="preserve">
          <source>To modify your Python search path to include the locations of your own modules, define the &lt;code&gt;PYTHONPATH&lt;/code&gt; environment variable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d1963ae310b977b5fdaf7c01ceaf03485096cb4" translate="yes" xml:space="preserve">
          <source>To override the automatic detection of available memory, set the environment variable &lt;code&gt;NPY_AVAILABLE_MEM&lt;/code&gt;, for example &lt;code&gt;NPY_AVAILABLE_MEM=32GB&lt;/code&gt;, or using pytest &lt;code&gt;--available-memory=32GB&lt;/code&gt; target option.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d1c61949e0ad3dc492f05ebb9e5438319174c320" translate="yes" xml:space="preserve">
          <source>To perform an in-place build that can be run from the source folder run:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c334cf8d4bed58e0564b6be3f28b72afdf600e2c" translate="yes" xml:space="preserve">
          <source>To proceed, import the linear algebra submodule from NumPy:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="02d722ee9de32d295a3f1aa488c332a62e29240a" translate="yes" xml:space="preserve">
          <source>To put back the default options, you can use:</source>
          <target state="translated">Чтобы вернуть опции по умолчанию,вы можете использовать:</target>
        </trans-unit>
        <trans-unit id="4f4e1d38162c68bbafa8964bc64bfa72b23866db" translate="yes" xml:space="preserve">
          <source>To read more about Matplotlib and what it can do, take a look at &lt;a href=&quot;https://matplotlib.org/&quot;&gt;the official documentation&lt;/a&gt;. For directions regarding installing Matplotlib, see the official &lt;a href=&quot;https://matplotlib.org/users/installing.html&quot;&gt;installation section&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="98026c8318a10abcb126d49806744b4ae23d3123" translate="yes" xml:space="preserve">
          <source>To read more about concatenate, see: &lt;a href=&quot;../reference/generated/numpy.concatenate#numpy.concatenate&quot;&gt;&lt;code&gt;concatenate&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="425cb75a01c3201b08612ec800f1a7971e0378d1" translate="yes" xml:space="preserve">
          <source>To read more about sorting an array, see: &lt;a href=&quot;../reference/generated/numpy.sort#numpy.sort&quot;&gt;&lt;code&gt;sort&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="33f422775354a46e3c9c41ff160bfb3c38d25920" translate="yes" xml:space="preserve">
          <source>To reduce the chance of misinterpretation, even though the following &amp;ldquo;abuse&amp;rdquo; is nominally supported, &lt;code&gt;choices&lt;/code&gt; should neither be, nor be thought of as, a single array, i.e., the outermost sequence-like container should be either a list or a tuple.</source>
          <target state="translated">Чтобы уменьшить вероятность неправильного толкования, даже если следующее &amp;laquo;злоупотребление&amp;raquo; номинально поддерживается, &lt;code&gt;choices&lt;/code&gt; должны быть и не должны рассматриваться как единый массив, т. Е. Внешний контейнер, подобный последовательности, должен быть либо списком, либо кортежем.</target>
        </trans-unit>
        <trans-unit id="69f7fdf215ee6723757c121f1000e16153523a1d" translate="yes" xml:space="preserve">
          <source>To retrieve only the valid entries, we can use the inverse of the mask as an index. The inverse of the mask can be calculated with the &lt;a href=&quot;generated/numpy.logical_not#numpy.logical_not&quot;&gt;&lt;code&gt;numpy.logical_not&lt;/code&gt;&lt;/a&gt; function or simply with the &lt;code&gt;~&lt;/code&gt; operator:</source>
          <target state="translated">Чтобы получить только действительные записи, мы можем использовать инверсию маски в качестве индекса. Обратное значение маски можно вычислить с &lt;a href=&quot;generated/numpy.logical_not#numpy.logical_not&quot;&gt; &lt;code&gt;numpy.logical_not&lt;/code&gt; &lt;/a&gt; функции numpy.logical_not или просто с помощью оператора &lt;code&gt;~&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="e546770d4089912cdd192abaecf0b1e29a9e2943" translate="yes" xml:space="preserve">
          <source>To return the indices of the values common to the input arrays along with the intersected values:</source>
          <target state="translated">Для возврата индексов значений,общих для входных массивов,вместе с пересекающимися значениями:</target>
        </trans-unit>
        <trans-unit id="67e6eaca69e6f48eb1845e3b15fc19b5fce3851f" translate="yes" xml:space="preserve">
          <source>To run SciPy&amp;rsquo;s full test suite, use the following:</source>
          <target state="translated">Чтобы запустить полный набор тестов SciPy, используйте следующее:</target>
        </trans-unit>
        <trans-unit id="402853161da9a462a3784d2121c2566aac78b1d2" translate="yes" xml:space="preserve">
          <source>To run a benchmark defined in a class, such as &lt;code&gt;Mandelbrot&lt;/code&gt; from &lt;code&gt;bench_avx.py&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3862a782eb6529a8c99b98cef4c13299f47f23c0" translate="yes" xml:space="preserve">
          <source>To run all benchmarks, navigate to the root NumPy directory at the command line and execute:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="12365d76682fb967acae76310ae656f9290fed8d" translate="yes" xml:space="preserve">
          <source>To run benchmarks from a particular benchmark module, such as &lt;code&gt;bench_core.py&lt;/code&gt;, simply append the filename without the extension:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9661928d3b7e0b0f53e4248625106d96b260f714" translate="yes" xml:space="preserve">
          <source>To sample from N evenly spaced floating-point numbers between a and b, use:</source>
          <target state="translated">Для выборки из N равномерно распределенных чисел с плавающей точкой между a и b используйте:</target>
        </trans-unit>
        <trans-unit id="cd520022e6b8a6d4a06e76bb94b1b7fee07bd6cf" translate="yes" xml:space="preserve">
          <source>To scan Fortran sources and generate a signature file, use</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="67f8780eccc675b04bcebf369f6ed02655b97ea2" translate="yes" xml:space="preserve">
          <source>To see a graphical representation of the repository branches and commits:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="39780ed9cf55125c359d05489224449255a114a4" translate="yes" xml:space="preserve">
          <source>To see a linear list of commits for this branch:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="79f07a6533e986fa44fe540266db879b8c346cb7" translate="yes" xml:space="preserve">
          <source>To see if an approximation is reasonable, we can check the values in &lt;code&gt;s&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc4aaad8d81152b0e7e6f7703b5cec989fcf2cef" translate="yes" xml:space="preserve">
          <source>To see if this makes sense in our image, we should use a colormap from &lt;code&gt;matplotlib&lt;/code&gt; corresponding to the color we wish to see in out image (otherwise, &lt;code&gt;matplotlib&lt;/code&gt; will default to a colormap that does not correspond to the real data).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="74691658cd7769d44a45cda5e12dd3bc908a227e" translate="yes" xml:space="preserve">
          <source>To see whether F2PY generated interface performs copies of array arguments, use &lt;code&gt;-DF2PY_REPORT_ON_ARRAY_COPY=&amp;lt;int&amp;gt;&lt;/code&gt;. When the size of an array argument is larger than &lt;code&gt;&amp;lt;int&amp;gt;&lt;/code&gt;, a message about the coping is sent to &lt;code&gt;stderr&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ed1275cdacf759ff47d03a08e3787f0594bb1bb" translate="yes" xml:space="preserve">
          <source>To set up on another computer, you can copy your &lt;code&gt;~/.gitconfig&lt;/code&gt; file, or run the commands above.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a4d884174d72a1ce55f9ee4b7d870c154a7a32b7" translate="yes" xml:space="preserve">
          <source>To skip a test, simply use &lt;code&gt;skipif&lt;/code&gt;:</source>
          <target state="translated">Чтобы пропустить тест, просто используйте &lt;code&gt;skipif&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="3dc6e4230f5944b1098c8c2df7bd61f24c145894" translate="yes" xml:space="preserve">
          <source>To submit your contribution:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ceffd750378d21341a7019937d0c789148b4f90a" translate="yes" xml:space="preserve">
          <source>To support it, we need to define the Python interfaces &lt;code&gt;__add__&lt;/code&gt;, &lt;code&gt;__lt__&lt;/code&gt;, and so on to dispatch to the corresponding ufunc. We can achieve this conveniently by inheriting from the mixin &lt;a href=&quot;../reference/generated/numpy.lib.mixins.ndarrayoperatorsmixin#numpy.lib.mixins.NDArrayOperatorsMixin&quot;&gt;&lt;code&gt;NDArrayOperatorsMixin&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="673335eebf9011c1628160cca5d99d26576f081d" translate="yes" xml:space="preserve">
          <source>To take the running sum of four successive values:</source>
          <target state="translated">Возьмем бегущую сумму из четырех последовательных значений:</target>
        </trans-unit>
        <trans-unit id="54587f602166cab38648eb3409cd921150aa4e7e" translate="yes" xml:space="preserve">
          <source>To test a datetime64 value to see if it is a valid day, use &lt;a href=&quot;generated/numpy.is_busday#numpy.is_busday&quot;&gt;&lt;code&gt;is_busday&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Чтобы проверить значение datetime64, чтобы убедиться, что это действительный день, используйте &lt;a href=&quot;generated/numpy.is_busday#numpy.is_busday&quot;&gt; &lt;code&gt;is_busday&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="054b90fbdf163bc568eceff518fb7e05620b88d4" translate="yes" xml:space="preserve">
          <source>To test the performance of F2PY generated interfaces, use &lt;code&gt;-DF2PY_REPORT_ATEXIT&lt;/code&gt;. Then a report of various timings is printed out at the exit of Python. This feature may not work on all platforms, currently only Linux platform is supported.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01b5e9d9370a428c2b83ae13e33fb71722d9bb4f" translate="yes" xml:space="preserve">
          <source>To test whether an array is C-contiguous, use the &lt;code&gt;.flags.c_contiguous&lt;/code&gt; attribute of NumPy arrays. To test for Fortran contiguity, use the &lt;code&gt;.flags.f_contiguous&lt;/code&gt; attribute.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ab2b1e95b971bb4c5c35b359a5634bf815d8fa6" translate="yes" xml:space="preserve">
          <source>To the extent possible under law, the authors have waived all copyright and related or neighboring rights to the NumPy project governance and decision-making document, as per the &lt;a href=&quot;https://creativecommons.org/publicdomain/zero/1.0/&quot;&gt;CC-0 public domain dedication / license&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b06b82cac8a278e2d618ab82ddb18a2d508ecee" translate="yes" xml:space="preserve">
          <source>To the maximum extent possible, Council discussions and activities will be public and done in collaboration and discussion with the Project Contributors and Community. The Council will have a private mailing list that will be used sparingly and only when a specific matter requires privacy. When private communications and decisions are needed, the Council will do its best to summarize those to the Community after eliding personal/private/sensitive information that should not be posted to the public internet.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3cb8696297023077cd0b0457359ff13c01cdb0ce" translate="yes" xml:space="preserve">
          <source>To transform input arrays to column major storage order before passing them to Fortran routines, use the function &lt;code&gt;numpy.asfortranarray(&amp;lt;array&amp;gt;)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ecbd73988a92874f75c5ca6f8256cc9806ceef6d" translate="yes" xml:space="preserve">
          <source>To unmask all masked entries of a masked array (provided the mask isn&amp;rsquo;t a hard mask), the simplest solution is to assign the constant &lt;a href=&quot;maskedarray.baseclass#numpy.ma.nomask&quot;&gt;&lt;code&gt;nomask&lt;/code&gt;&lt;/a&gt; to the mask:</source>
          <target state="translated">Чтобы демаскировать все замаскированные записи замаскированного массива (при условии, что маска не является жесткой маской), самое простое решение - присвоить &lt;a href=&quot;maskedarray.baseclass#numpy.ma.nomask&quot;&gt; &lt;code&gt;nomask&lt;/code&gt; &lt;/a&gt; постоянную nomask :</target>
        </trans-unit>
        <trans-unit id="573c20b6a49882f7eb74a61c9d6cc94e9816cad4" translate="yes" xml:space="preserve">
          <source>To unmask one or several specific entries, we can just assign one or several new valid values to them:</source>
          <target state="translated">Чтобы разоблачить одну или несколько конкретных записей,мы можем просто присвоить им одно или несколько новых действительных значений:</target>
        </trans-unit>
        <trans-unit id="9a8a0e07a3236c692c34f1277c4ab67311d7e811" translate="yes" xml:space="preserve">
          <source>To update your PR, make your changes on your local repository, commit, &lt;strong&gt;run tests, and only if they succeed&lt;/strong&gt; push to your fork. As soon as those changes are pushed up (to the same branch as before) the PR will update automatically. If you have no idea how to fix the test failures, you may push your changes anyway and ask for help in a PR comment.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="334270275fd281b533f438d90c3f3ba9ca0332d2" translate="yes" xml:space="preserve">
          <source>To use ctypes you must</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="678a8d94c4368f39ac59f5979ae212033bfc0aa2" translate="yes" xml:space="preserve">
          <source>To use the NPY_NO_DEPRECATED_API mechanism, you need to #define it to the target API version of NumPy before #including any NumPy headers. If you want to confirm that your code is clean against 1.7, use:</source>
          <target state="translated">Для использования механизма NPY_NO_DEPRECATED_API необходимо #определить его до целевой API версии NumPy,прежде чем #включать любые заголовки NumPy.Если вы хотите подтвердить,что ваш код чист против 1.7,используйте:</target>
        </trans-unit>
        <trans-unit id="a6632c1bd45113f2d4d1587bfeed07e24b0355a1" translate="yes" xml:space="preserve">
          <source>To use the core math library in your own extension, you need to add the npymath compile and link options to your extension in your setup.py:</source>
          <target state="translated">Чтобы использовать математическую библиотеку ядра в вашем собственном расширении,вам необходимо добавить опции компиляции npymath и компоновки ссылок в вашем расширении в файле setup.py:</target>
        </trans-unit>
        <trans-unit id="500206efd24c09b049a15922610b46ea489a6382" translate="yes" xml:space="preserve">
          <source>To use the setup.py file, place setup.py and spammodule.c in the same folder. Then python setup.py build will build the module to import, or setup.py install will install the module to your site-packages directory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b09eedfc76bdeeb31bc979256f245ac870f03de" translate="yes" xml:space="preserve">
          <source>Toggle between low-endian and big-endian data representation by returning a byteswapped array, optionally swapped in-place.</source>
          <target state="translated">Переключение между низко-и биг-ендианским представлением данных путем возврата массива с байтовой заменой,опционально заменяемого на месте.</target>
        </trans-unit>
        <trans-unit id="7ff4f3dd9acfe46112f7adc4d9246b8e34598f79" translate="yes" xml:space="preserve">
          <source>Toggle between low-endian and big-endian data representation by returning a byteswapped array, optionally swapped in-place. Arrays of byte-strings are not swapped. The real and imaginary parts of a complex number are swapped individually.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b37ca94c4e2eda42b84355ca6a25cdc55774133" translate="yes" xml:space="preserve">
          <source>Tolerance in machine epsilons for the complex part of the elements in the array.</source>
          <target state="translated">Допуск в машинных эпсилонах на сложную часть элементов в массиве.</target>
        </trans-unit>
        <trans-unit id="eb34b2131d6523965cdff1a43f4d01b982373d17" translate="yes" xml:space="preserve">
          <source>Tolerance parameters passed on to &lt;code&gt;isclose&lt;/code&gt;</source>
          <target state="translated">Параметры &lt;code&gt;isclose&lt;/code&gt; передаваемые в isclose</target>
        </trans-unit>
        <trans-unit id="6670aa4fd96fc23b9c267762a58d3e2634e5e33d" translate="yes" xml:space="preserve">
          <source>Tolerance when checking the singular values in covariance matrix. cov is cast to double before the check.</source>
          <target state="translated">Допуск при проверке сингулярных значений в ковариационной матрице.cov проставляется в двойном размере перед проверкой.</target>
        </trans-unit>
        <trans-unit id="849d7597da246bfdf3ea363c9c3966af6e67a060" translate="yes" xml:space="preserve">
          <source>Tool chain</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="62511550774b90e55fa9f4d081340a2b9a412907" translate="yes" xml:space="preserve">
          <source>Total bytes consumed by the elements of the array.</source>
          <target state="translated">Суммарные байты,потребляемые элементами массива.</target>
        </trans-unit>
        <trans-unit id="f98da7ab34ca5eed412ebdc84c5c6ee4a001f890" translate="yes" xml:space="preserve">
          <source>Total number of array elements which trigger summarization rather than full repr (default 1000).</source>
          <target state="translated">Общее количество элементов массива,которые инициируют суммирование,а не полный перезапуск (по умолчанию 1000).</target>
        </trans-unit>
        <trans-unit id="af14b2afdcc9cc3c661815c98f45cde11a73254a" translate="yes" xml:space="preserve">
          <source>Total number of array elements which trigger summarization rather than full repr (default 1000). To always use the full repr without summarization, pass &lt;a href=&quot;https://docs.python.org/dev/library/sys.html#sys.maxsize&quot;&gt;&lt;code&gt;sys.maxsize&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d7665d1d201c9ce2fd429127a2f276d913bba99d" translate="yes" xml:space="preserve">
          <source>Total number of array elements which trigger summarization rather than full repr. Defaults to &lt;code&gt;numpy.get_printoptions()['threshold']&lt;/code&gt;.</source>
          <target state="translated">Общее количество элементов массива, запускающих суммирование, а не полное воспроизведение. По умолчанию &lt;code&gt;numpy.get_printoptions()['threshold']&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7b009fd84652963a9ad5cd24ef82072817ddee41" translate="yes" xml:space="preserve">
          <source>Total size of broadcasted result.</source>
          <target state="translated">Общий размер транслируемого результата.</target>
        </trans-unit>
        <trans-unit id="77cca581150b844f956409245e7a5aa4e911b340" translate="yes" xml:space="preserve">
          <source>Trace of a matrix:</source>
          <target state="translated">След матрицы:</target>
        </trans-unit>
        <trans-unit id="b67024bc850bfd9a0093e89cd78bf7093386c17c" translate="yes" xml:space="preserve">
          <source>Trace of an array, &lt;a href=&quot;numpy.trace#numpy.trace&quot;&gt;&lt;code&gt;numpy.trace&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Трассировка массива, &lt;a href=&quot;numpy.trace#numpy.trace&quot;&gt; &lt;code&gt;numpy.trace&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ed0e339a8e0484e2fd0a0d26f8fea815f7ce8155" translate="yes" xml:space="preserve">
          <source>Tracking an Index or Multi-Index</source>
          <target state="translated">Отслеживание индекса или мультииндекса</target>
        </trans-unit>
        <trans-unit id="4cf0fc0db43adb86a6609aeef379773c878c22d3" translate="yes" xml:space="preserve">
          <source>Tracking an index or multi-index is incompatible with using an external loop, because it requires a different index value per element. If you try to combine these flags, the &lt;a href=&quot;generated/numpy.nditer#numpy.nditer&quot;&gt;&lt;code&gt;nditer&lt;/code&gt;&lt;/a&gt; object will raise an exception</source>
          <target state="translated">Отслеживание индекса или мультииндекса несовместимо с использованием внешнего цикла, поскольку для каждого элемента требуется другое значение индекса. Если вы попытаетесь объединить эти флаги, объект &lt;a href=&quot;generated/numpy.nditer#numpy.nditer&quot;&gt; &lt;code&gt;nditer&lt;/code&gt; &lt;/a&gt; вызовет исключение.</target>
        </trans-unit>
        <trans-unit id="d235c585e89d9d88a2fc997aec36a615cac97376" translate="yes" xml:space="preserve">
          <source>Tracking an index or multi-index is incompatible with using an external loop, because it requires a different index value per element. If you try to combine these flags, the &lt;a href=&quot;generated/numpy.nditer#numpy.nditer&quot;&gt;&lt;code&gt;nditer&lt;/code&gt;&lt;/a&gt; object will raise an exception.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0de8c9ca9943956fbbe74f36e563016e4ecbb6f6" translate="yes" xml:space="preserve">
          <source>Trailing (i.e., highest order) elements with absolute value less than or equal to &lt;code&gt;tol&lt;/code&gt; (default value is zero) are removed.</source>
          <target state="translated">Завершающие элементы (т. Е. Высшего порядка) с абсолютным значением меньше или равным &lt;code&gt;tol&lt;/code&gt; (значение по умолчанию - ноль) удаляются.</target>
        </trans-unit>
        <trans-unit id="60e5d748c9218c048de8740bcac1703e7a50da1a" translate="yes" xml:space="preserve">
          <source>Trailing comments should be used sparingly. Instead of</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="556492d634d78a1f54a40b4fbbb6e6c53716147d" translate="yes" xml:space="preserve">
          <source>Trailing zeros in the coefficients will be used in the evaluation, so they should be avoided if efficiency is a concern.</source>
          <target state="translated">При оценке будут использоваться трейлинговые нули в коэффициентах,поэтому их следует избегать,если речь идет об эффективности.</target>
        </trans-unit>
        <trans-unit id="745b5ecf9a2d85dc724cf9ddd7a6df396eb1df69" translate="yes" xml:space="preserve">
          <source>Transforms a masked array into a flexible-type array.</source>
          <target state="translated">Преобразовывает массив с маской в массив гибкого типа.</target>
        </trans-unit>
        <trans-unit id="5335ed0e86bcde3b96f32fd1545910f420f14d2e" translate="yes" xml:space="preserve">
          <source>Transition notice</source>
          <target state="translated">Переходное уведомление</target>
        </trans-unit>
        <trans-unit id="d362208ff2e702ca3538568841ed00ca61c441f9" translate="yes" xml:space="preserve">
          <source>Translate slice objects to concatenation along the first axis.</source>
          <target state="translated">Транслируйте срезы объектов в конкатенуацию по первой оси.</target>
        </trans-unit>
        <trans-unit id="c42fc49440b8d06a906b44be13eb608ca2ffc1dd" translate="yes" xml:space="preserve">
          <source>Translates slice objects to concatenation along the first axis.</source>
          <target state="translated">Транслирует срезанные объекты в конкатенуацию по первой оси.</target>
        </trans-unit>
        <trans-unit id="ff7c65a71ec845e39d241d138fd72490df88fa74" translate="yes" xml:space="preserve">
          <source>Translates slice objects to concatenation along the second axis.</source>
          <target state="translated">Транслирует срезанные объекты в конкатенуацию вдоль второй оси.</target>
        </trans-unit>
        <trans-unit id="59ccc78dea6365b58077aeb5bd29c68b822c1ef5" translate="yes" xml:space="preserve">
          <source>Translating content</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8def3943422e0dc87b7f47772bd3dc4ad8ea550b" translate="yes" xml:space="preserve">
          <source>Transpose-like operations</source>
          <target state="translated">Прозрачные операции</target>
        </trans-unit>
        <trans-unit id="1dfdbda20e491607190c97bd4edf114a4a693811" translate="yes" xml:space="preserve">
          <source>Transposing a 1-D array returns an unchanged view of the original array.</source>
          <target state="translated">Перемещение 1-D массива возвращает неизменный вид исходного массива.</target>
        </trans-unit>
        <trans-unit id="cfbc312acbc39b5f0298bdc7c7b5f4e1b759968b" translate="yes" xml:space="preserve">
          <source>Transposing and reshaping a matrix</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="66408bfa15c9ed2902e447a43b1f7abcdee55a60" translate="yes" xml:space="preserve">
          <source>Transpositions and permutations, &lt;a href=&quot;numpy.transpose#numpy.transpose&quot;&gt;&lt;code&gt;numpy.transpose&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Транспозиции и перестановки, &lt;a href=&quot;numpy.transpose#numpy.transpose&quot;&gt; &lt;code&gt;numpy.transpose&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a7b41f9df87a78abbe8128d5a249676911368def" translate="yes" xml:space="preserve">
          <source>Travis Oliphant - Project Founder / Emeritus Leader (served: 2005-2012)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8cd1d8f1121212090792af3b195766028fb3300b" translate="yes" xml:space="preserve">
          <source>Treatment for division by zero.</source>
          <target state="translated">Лечение при делении на ноль.</target>
        </trans-unit>
        <trans-unit id="c576a1cfdbaf816c1398a32382e59edc28900bee" translate="yes" xml:space="preserve">
          <source>Treatment for floating-point overflow.</source>
          <target state="translated">Очистка от переполнения с плавающей точкой.</target>
        </trans-unit>
        <trans-unit id="17721dd3ac43e33f85ad621f2dc25c086c0470c0" translate="yes" xml:space="preserve">
          <source>Treatment for floating-point underflow.</source>
          <target state="translated">Лечение подтоков с плавающей точкой.</target>
        </trans-unit>
        <trans-unit id="a13040b51033dafdb26f7572598a0d12e22e4ffe" translate="yes" xml:space="preserve">
          <source>Treatment for invalid floating-point operation.</source>
          <target state="translated">Лечение при недействительной операции с плавающей запятой.</target>
        </trans-unit>
        <trans-unit id="1150736fa84c0c4e53f25517e34313dcdeeed227" translate="yes" xml:space="preserve">
          <source>Tricks and Tips</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="daa2b8a97e48dc7878c0a5d70afe5d62a641a9fe" translate="yes" xml:space="preserve">
          <source>Trigger a build by pushing a commit of your edits to the repository. Note that you can do this on a branch, but it must be pushed upstream to the &lt;code&gt;MacPython/numpy-wheels&lt;/code&gt; repository to trigger uploads since only that repo has the appropriate tokens to allow uploads.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9ba6ba3648cadff3a99f26c6371ef76b8f5ec198" translate="yes" xml:space="preserve">
          <source>Trigger the wheel builds</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4be7bc22dfdfa583bec627625a7e1101bc895967" translate="yes" xml:space="preserve">
          <source>Trigger the wheels build by pointing the numpy-wheels repository at this commit. This can take up to an hour. The numpy-wheels repository is cloned from &lt;a href=&quot;https://github.com/MacPython/numpy-wheels&quot;&gt;https://github.com/MacPython/numpy-wheels&lt;/a&gt;. Start with a pull as the repo may have been accessed and changed by someone else and a push will fail:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a49a3516e9535a98c78b0ab59efaa267faaaeac" translate="yes" xml:space="preserve">
          <source>Triggers &lt;a href=&quot;#c.NPY_ITER_COPY&quot;&gt;&lt;code&gt;NPY_ITER_COPY&lt;/code&gt;&lt;/a&gt;, and when an array operand is flagged for writing and is copied, causes the data in a copy to be copied back to &lt;code&gt;op[i]&lt;/code&gt; when &lt;code&gt;NpyIter_Deallocate&lt;/code&gt; is called.</source>
          <target state="translated">Триггеры &lt;a href=&quot;#c.NPY_ITER_COPY&quot;&gt; &lt;code&gt;NPY_ITER_COPY&lt;/code&gt; &lt;/a&gt; , и когда массив операндов попадает в письменной форме и копируется, приводит данные в копии будут скопированы обратно в &lt;code&gt;op[i]&lt;/code&gt; , когда &lt;code&gt;NpyIter_Deallocate&lt;/code&gt; называется.</target>
        </trans-unit>
        <trans-unit id="b9e4c026492c440bf32166e0789393487d03b254" translate="yes" xml:space="preserve">
          <source>Trigonometric functions</source>
          <target state="translated">тригонометрические функции</target>
        </trans-unit>
        <trans-unit id="58cf0aee76fad599f97ff1db8c6a47d2270860db" translate="yes" xml:space="preserve">
          <source>Trigonometric inverse cosine, element-wise.</source>
          <target state="translated">Тригонометрический обратный косинус,по элементам.</target>
        </trans-unit>
        <trans-unit id="b0b82a06c2ae28e8fcf146e965d0c41fd4531e3a" translate="yes" xml:space="preserve">
          <source>Trigonometric inverse tangent, element-wise.</source>
          <target state="translated">Тригонометрический обратный тангенс,по элементам.</target>
        </trans-unit>
        <trans-unit id="ce4f3fa4852db4b9b207eedadc12e11135e46d85" translate="yes" xml:space="preserve">
          <source>Trigonometric sine, element-wise.</source>
          <target state="translated">Тригонометрический синус,по элементам.</target>
        </trans-unit>
        <trans-unit id="10a283c17897bbd0b4cb4fd810a9eeb88aa8ef58" translate="yes" xml:space="preserve">
          <source>Trim the leading and/or trailing zeros from a 1-D array or sequence.</source>
          <target state="translated">Обрежьте ведущие и/или трейлинговые нули из 1-D массива или последовательности.</target>
        </trans-unit>
        <trans-unit id="e488bb5cb2e281f3b003ce95222b8e4917db65a6" translate="yes" xml:space="preserve">
          <source>Troubleshooting ImportError</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="88b33e4e12f75ac8bf792aebde41f1a090f3a612" translate="yes" xml:space="preserve">
          <source>True</source>
          <target state="translated">True</target>
        </trans-unit>
        <trans-unit id="dec064efe14ed7a73f97fa4832f7dc39f8d37259" translate="yes" xml:space="preserve">
          <source>True divide self by other in-place.</source>
          <target state="translated">Истинное разделение на других на месте.</target>
        </trans-unit>
        <trans-unit id="7c6199295c88c515de03909ca69e74e54d8c40d0" translate="yes" xml:space="preserve">
          <source>True if &lt;code&gt;element&lt;/code&gt; is a scalar type, False if it is not.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="39cf2a1ac05eb7ec1f611fa8df3b32f9cff1d558" translate="yes" xml:space="preserve">
          <source>True if &lt;code&gt;m.dtype.type&lt;/code&gt; is MaskType, False otherwise.</source>
          <target state="translated">Истинно, если &lt;code&gt;m.dtype.type&lt;/code&gt; имеет значение MaskType, в противном случае - False.</target>
        </trans-unit>
        <trans-unit id="c7e5263b6e49f0164ce122995ea161e565df58fa" translate="yes" xml:space="preserve">
          <source>True if &lt;code&gt;num&lt;/code&gt; is a scalar type, False if it is not.</source>
          <target state="translated">Истинно, если &lt;code&gt;num&lt;/code&gt; является скалярным типом, и False, если это не так.</target>
        </trans-unit>
        <trans-unit id="2655b1728487edfb72db0ecd08ff9ea666177ee0" translate="yes" xml:space="preserve">
          <source>True if &lt;code&gt;path&lt;/code&gt; exists.</source>
          <target state="translated">Истинно, если &lt;code&gt;path&lt;/code&gt; существует.</target>
        </trans-unit>
        <trans-unit id="0acadbce2849d20449e701a26739adbff1b98e78" translate="yes" xml:space="preserve">
          <source>True if &lt;code&gt;x&lt;/code&gt; is a MaskedArray with masked values, False otherwise.</source>
          <target state="translated">Истина, если &lt;code&gt;x&lt;/code&gt; является MaskedArray с замаскированными значениями, в противном случае - False.</target>
        </trans-unit>
        <trans-unit id="05ff71445923acdd0c38d736b463809c9ccd39de" translate="yes" xml:space="preserve">
          <source>True if a Fortran 77 compiler is available (because a simple Fortran 77 code was able to be compiled successfully).</source>
          <target state="translated">Правда,если доступен компилятор Fortran 77 (потому что простой код Fortran 77 мог быть успешно скомпилирован).</target>
        </trans-unit>
        <trans-unit id="00cd0fd9fd4e9fcf05a5961ba064f7c5fc57b8ef" translate="yes" xml:space="preserve">
          <source>True if a Fortran 90 compiler is available (because a simple Fortran 90 code was able to be compiled successfully)</source>
          <target state="translated">Правда,если доступен компилятор Fortran 90 (поскольку простой код Fortran 90 был успешно скомпилирован).</target>
        </trans-unit>
        <trans-unit id="213506708b75038d86119f896c93fd459688fdaa" translate="yes" xml:space="preserve">
          <source>True if byteorder characters ( &lt;code&gt;NPY_LITTLE&lt;/code&gt;, &lt;code&gt;NPY_BIG&lt;/code&gt;, &lt;code&gt;NPY_NATIVE&lt;/code&gt;, &lt;code&gt;NPY_IGNORE&lt;/code&gt; ) are either equal or equivalent as to their specification of a native byte order. Thus, on a little-endian machine &lt;code&gt;NPY_LITTLE&lt;/code&gt; and &lt;code&gt;NPY_NATIVE&lt;/code&gt; are equivalent where they are not equivalent on a big-endian machine.</source>
          <target state="translated">Истинно, если байтовые символы ( &lt;code&gt;NPY_LITTLE&lt;/code&gt; , &lt;code&gt;NPY_BIG&lt;/code&gt; , &lt;code&gt;NPY_NATIVE&lt;/code&gt; , &lt;code&gt;NPY_IGNORE&lt;/code&gt; ) равны или эквивалентны их спецификации собственного порядка байтов. Таким образом, на машине с &lt;code&gt;NPY_LITTLE&lt;/code&gt; &lt;code&gt;NPY_NATIVE&lt;/code&gt; байтов NPY_LITTLE и NPY_NATIVE эквивалентны там, где они не эквивалентны на машине с прямым порядком байтов.</target>
        </trans-unit>
        <trans-unit id="ba3294550f0a20e5d9deb7f04a95fb8e4b4d1d46" translate="yes" xml:space="preserve">
          <source>True if cast can occur according to the casting rule.</source>
          <target state="translated">Правда,если разливка может произойти в соответствии с правилом разливки.</target>
        </trans-unit>
        <trans-unit id="1f63565b32d103f3a4de31640d426343af47dd7d" translate="yes" xml:space="preserve">
          <source>True if equivalent, False otherwise.</source>
          <target state="translated">Верно,если эквивалентно,Ложно,если нет.</target>
        </trans-unit>
        <trans-unit id="1e741019d05ad4b1c0222d2d53486f99a6732190" translate="yes" xml:space="preserve">
          <source>True if other is same class as self</source>
          <target state="translated">Правда,если &quot;другой&quot; относится к тому же классу,что и &quot;я&quot;.</target>
        </trans-unit>
        <trans-unit id="70fbd415e3863800b42dd70f2afc2d0435498df0" translate="yes" xml:space="preserve">
          <source>True if the coefficients are the same, False otherwise.</source>
          <target state="translated">Верно,если коэффициенты одинаковы,Ложно,иначе.</target>
        </trans-unit>
        <trans-unit id="a6afbacb41b3137cec218f989dffb959ca4f44cd" translate="yes" xml:space="preserve">
          <source>True if the domains are the same, False otherwise.</source>
          <target state="translated">Верно,если домены одни и те же,Ложно иначе.</target>
        </trans-unit>
        <trans-unit id="4bc2a6d6f70eb24c8def5df03724644edb474780" translate="yes" xml:space="preserve">
          <source>True if the windows are the same, False otherwise.</source>
          <target state="translated">Верно,если окна те же самые,Ложно иначе.</target>
        </trans-unit>
        <trans-unit id="24f9df4fb7133abd7e86f4b5f0391c10a93621e7" translate="yes" xml:space="preserve">
          <source>True if two arrays have the same shape and elements, False otherwise.</source>
          <target state="translated">Верно,если два массива имеют одинаковую форму и элементы,Ложно иначе.</target>
        </trans-unit>
        <trans-unit id="755e15abf3303ababe3ade30f10af71c607d4530" translate="yes" xml:space="preserve">
          <source>True where &lt;code&gt;x&lt;/code&gt; is NaN, false otherwise. This is a scalar if &lt;code&gt;x&lt;/code&gt; is a scalar.</source>
          <target state="translated">Истина, если &lt;code&gt;x&lt;/code&gt; - NaN, иначе - ложь. Это скаляр, если &lt;code&gt;x&lt;/code&gt; - скаляр.</target>
        </trans-unit>
        <trans-unit id="dc0b3f0e3c0fa8c731e1bcdadee661ee71b2ddb8" translate="yes" xml:space="preserve">
          <source>True where &lt;code&gt;x&lt;/code&gt; is NaT, false otherwise. This is a scalar if &lt;code&gt;x&lt;/code&gt; is a scalar.</source>
          <target state="translated">Истина, если &lt;code&gt;x&lt;/code&gt; - NaT, иначе - ложь. Это скаляр, если &lt;code&gt;x&lt;/code&gt; - скаляр.</target>
        </trans-unit>
        <trans-unit id="cd270c6be47d5f9045a9640d5cc8ead8711407bc" translate="yes" xml:space="preserve">
          <source>True where &lt;code&gt;x&lt;/code&gt; is not positive infinity, negative infinity, or NaN; false otherwise. This is a scalar if &lt;code&gt;x&lt;/code&gt; is a scalar.</source>
          <target state="translated">Истина, если &lt;code&gt;x&lt;/code&gt; не является положительной бесконечностью, отрицательной бесконечностью или NaN; иначе ложь. Это скаляр, если &lt;code&gt;x&lt;/code&gt; - скаляр.</target>
        </trans-unit>
        <trans-unit id="3170e8eb3762dd10d0e3ab109761eb5c944e9ac1" translate="yes" xml:space="preserve">
          <source>True where &lt;code&gt;x&lt;/code&gt; is positive or negative infinity, false otherwise. This is a scalar if &lt;code&gt;x&lt;/code&gt; is a scalar.</source>
          <target state="translated">Истина, если &lt;code&gt;x&lt;/code&gt; - положительная или отрицательная бесконечность, иначе - ложь. Это скаляр, если &lt;code&gt;x&lt;/code&gt; - скаляр.</target>
        </trans-unit>
        <trans-unit id="425b939d0909e079d100ad47521c0febc0bd307a" translate="yes" xml:space="preserve">
          <source>Truncate s values at 50 so plot is interesting:</source>
          <target state="translated">Усеченные значения s на 50,так что участок интересен:</target>
        </trans-unit>
        <trans-unit id="8726579bd5d3f34275a243eb604a9ceb6cbd38eb" translate="yes" xml:space="preserve">
          <source>Truncate series to length &lt;code&gt;size&lt;/code&gt;.</source>
          <target state="translated">Округление серии по длине &lt;code&gt;size&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="adcf68c15599690309b811decf083d5555853eeb" translate="yes" xml:space="preserve">
          <source>Truncate series to the given degree.</source>
          <target state="translated">Усеченная серия до заданной степени.</target>
        </trans-unit>
        <trans-unit id="d78b8c914ad90242aebfa1ad45be017c8a4ed426" translate="yes" xml:space="preserve">
          <source>Truth value of an array (&lt;code&gt;bool&lt;/code&gt;):</source>
          <target state="translated">Истинное значение массива ( &lt;code&gt;bool&lt;/code&gt; ):</target>
        </trans-unit>
        <trans-unit id="d14d79df6800bf8b855c978794baaad558b55ab7" translate="yes" xml:space="preserve">
          <source>Truth value testing</source>
          <target state="translated">Тестирование истинности</target>
        </trans-unit>
        <trans-unit id="a34d6317df428f3a0882e4fcc17ec8a423d926fc" translate="yes" xml:space="preserve">
          <source>Truth-value testing of an array invokes &lt;a href=&quot;generated/numpy.ndarray.__bool__#numpy.ndarray.__bool__&quot;&gt;&lt;code&gt;ndarray.__bool__&lt;/code&gt;&lt;/a&gt;, which raises an error if the number of elements in the array is larger than 1, because the truth value of such arrays is ambiguous. Use &lt;a href=&quot;generated/numpy.ndarray.any#numpy.ndarray.any&quot;&gt;&lt;code&gt;.any()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;generated/numpy.ndarray.all#numpy.ndarray.all&quot;&gt;&lt;code&gt;.all()&lt;/code&gt;&lt;/a&gt; instead to be clear about what is meant in such cases. (If the number of elements is 0, the array evaluates to &lt;code&gt;False&lt;/code&gt;.)</source>
          <target state="translated">Проверка &lt;a href=&quot;generated/numpy.ndarray.__bool__#numpy.ndarray.__bool__&quot;&gt; &lt;code&gt;ndarray.__bool__&lt;/code&gt; &lt;/a&gt; массива вызывает ndarray .__ bool__ , что вызывает ошибку, если количество элементов в массиве больше 1, потому что истинное значение таких массивов неоднозначно. &lt;a href=&quot;generated/numpy.ndarray.all#numpy.ndarray.all&quot;&gt; &lt;code&gt;.all()&lt;/code&gt; &lt;/a&gt; этого используйте &lt;a href=&quot;generated/numpy.ndarray.any#numpy.ndarray.any&quot;&gt; &lt;code&gt;.any()&lt;/code&gt; &lt;/a&gt; и .all (), чтобы понять, что имеется в виду в таких случаях. (Если количество элементов равно 0, массив оценивается как &lt;code&gt;False&lt;/code&gt; .)</target>
        </trans-unit>
        <trans-unit id="2ecf59a43e289ad2b017cf95dec49da40904a53e" translate="yes" xml:space="preserve">
          <source>Try to get version string of a package.</source>
          <target state="translated">Попробуйте получить строку версии пакета.</target>
        </trans-unit>
        <trans-unit id="d41c38be32c336059996707815d0e3ddc6359848" translate="yes" xml:space="preserve">
          <source>Try to keep the runtime of the benchmark reasonable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="78b28b6348f61eb4f458af0454cbb48914113f96" translate="yes" xml:space="preserve">
          <source>Tuple &lt;code&gt;(item_dtype, shape)&lt;/code&gt; if this &lt;a href=&quot;#numpy.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt; describes a sub-array, and None otherwise.</source>
          <target state="translated">Кортеж &lt;code&gt;(item_dtype, shape)&lt;/code&gt; если этот &lt;a href=&quot;#numpy.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt; описывает подмассив , и None в противном случае.</target>
        </trans-unit>
        <trans-unit id="3e6ddb0c1b967dfa42de0aef208f74bd1f3fd6c6" translate="yes" xml:space="preserve">
          <source>Tuple &lt;code&gt;(item_dtype, shape)&lt;/code&gt; if this &lt;a href=&quot;generated/numpy.dtype#numpy.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt; describes a sub-array, and None otherwise.</source>
          <target state="translated">Кортеж &lt;code&gt;(item_dtype, shape)&lt;/code&gt; если этот &lt;a href=&quot;generated/numpy.dtype#numpy.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt; описывает подмассив , и None в противном случае.</target>
        </trans-unit>
        <trans-unit id="f3757a0166a586f2a2125cefab21784843d386d2" translate="yes" xml:space="preserve">
          <source>Tuple &lt;code&gt;(item_dtype, shape)&lt;/code&gt; if this &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt; describes a sub-array, and None otherwise.</source>
          <target state="translated">Кортеж &lt;code&gt;(item_dtype, shape)&lt;/code&gt; если этот &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt; описывает подмассив , и None в противном случае.</target>
        </trans-unit>
        <trans-unit id="84be13d7b7fcc75e7ec8441a86e66cf302003bb9" translate="yes" xml:space="preserve">
          <source>Tuple axis arguments to ufuncs are equivalent:</source>
          <target state="translated">Аргументы оси кортежа для ufuncs эквивалентны:</target>
        </trans-unit>
        <trans-unit id="92e7c78c7d4063f090081adef280802cf975a20b" translate="yes" xml:space="preserve">
          <source>Tuple object dtypes</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="288ea08ff10a961743d4d8b925f5d1931f661310" translate="yes" xml:space="preserve">
          <source>Tuple of array dimensions.</source>
          <target state="translated">Кортеж размеров массива.</target>
        </trans-unit>
        <trans-unit id="119e92503836c54689c5f8c6dff4e15a28816a46" translate="yes" xml:space="preserve">
          <source>Tuple of bytes to step in each dimension when traversing an array.</source>
          <target state="translated">Обратный кортеж байт для шага в каждом измерении при обходе массива.</target>
        </trans-unit>
        <trans-unit id="a39e9bc9ce6796bfca6ebd0c63299d64e075f553" translate="yes" xml:space="preserve">
          <source>Tuple whose elements are the array size in each dimension. Each entry is an integer (a Python int or long). Note that these integers could be larger than the platform &amp;ldquo;int&amp;rdquo; or &amp;ldquo;long&amp;rdquo; could hold (a Python int is a C long). It is up to the code using this attribute to handle this appropriately; either by raising an error when overflow is possible, or by using &lt;code&gt;Py_LONG_LONG&lt;/code&gt; as the C type for the shapes.</source>
          <target state="translated">Кортеж, элементы которого являются размером массива в каждом измерении. Каждая запись представляет собой целое число (Python int или long). Обратите внимание, что эти целые числа могут быть больше, чем может вместить платформа int или long (Python int - это long C). Код, использующий этот атрибут, должен правильно обработать это; либо вызывая ошибку, когда возможно переполнение, либо используя &lt;code&gt;Py_LONG_LONG&lt;/code&gt; в качестве типа C для фигур.</target>
        </trans-unit>
        <trans-unit id="20d441ae2c7520e9597892d62d069dab012afe76" translate="yes" xml:space="preserve">
          <source>Turns pure python into efficient machine code through jit-like optimizations</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d9bd3e52f2caf4d6594b811b3960a4952fbdcd14" translate="yes" xml:space="preserve">
          <source>Tutorial: Linear algebra on n-dimensional arrays</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="654171647baa6be8557a5d627cf35c7075ebb257" translate="yes" xml:space="preserve">
          <source>Tutorials</source>
          <target state="translated">Tutorials</target>
        </trans-unit>
        <trans-unit id="a3aad8fcfc1fb793d988e46dd13b4c587f04cc94" translate="yes" xml:space="preserve">
          <source>Tutorials and summaries</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e8bc0a325097293ba3968264a6e780fc207371f" translate="yes" xml:space="preserve">
          <source>Tweaking the conversion</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a84f46a1bd48b0888bd11bac416f31bd455192d4" translate="yes" xml:space="preserve">
          <source>Two and three dots in difference specs</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eff015ed2b91595519ef0f82b5da310790ed8380" translate="yes" xml:space="preserve">
          <source>Two groups, children of diabetics (25 people) and children from people without diabetes (25 controls). Fasting blood glucose was measured, case group had a mean value of 86.1, controls had a mean value of 82.2. Standard deviations were 2.09 and 2.49 respectively. Are these data consistent with the null hypothesis that the parents diabetic status does not affect their children&amp;rsquo;s blood glucose levels? Calculating the F statistic from the data gives a value of 36.01.</source>
          <target state="translated">Две группы, дети диабетиков (25 человек) и дети от людей без диабета (25 контрольных). Измеряли уровень глюкозы в крови натощак, в группе случаев среднее значение 86,1, в контрольной группе - 82,2. Стандартные отклонения составили 2,09 и 2,49 соответственно. Соответствуют ли эти данные нулевой гипотезе о том, что диабетический статус родителей не влияет на уровень глюкозы в крови их детей? Расчет статистики F на основе данных дает значение 36,01.</target>
        </trans-unit>
        <trans-unit id="9a29304c220b1dd3134936cc76050af186cb5278" translate="yes" xml:space="preserve">
          <source>Two times the reciprocal of pi (</source>
          <target state="translated">Дважды обратная величина пи (</target>
        </trans-unit>
        <trans-unit id="c6b3128dd2f1c22ff8a2b286be1379fe8a8fe179" translate="yes" xml:space="preserve">
          <source>Two-by-four array of samples from</source>
          <target state="translated">Два-четыре массива образцов из</target>
        </trans-unit>
        <trans-unit id="b1f6d6c8746a437f90f0dee674c0b93df2f99381" translate="yes" xml:space="preserve">
          <source>Two-by-four array of samples from N(3, 6.25):</source>
          <target state="translated">Двух-четырех массива образцов из N(3,6.25):</target>
        </trans-unit>
        <trans-unit id="3db221513448342ff7f1391357dc023cdf6dc3dc" translate="yes" xml:space="preserve">
          <source>Two-by-four matrix of samples from</source>
          <target state="translated">Двух-четырехматричная матрица образцов из</target>
        </trans-unit>
        <trans-unit id="862d5ad68d4b198349fd0cc9c98a5797e23f13c7" translate="yes" xml:space="preserve">
          <source>Two-dimensional array:</source>
          <target state="translated">Двухмерный массив:</target>
        </trans-unit>
        <trans-unit id="4ca814bb64ef6897ea819d313fffbc4815334f0e" translate="yes" xml:space="preserve">
          <source>Two-dimensional arrays are tested in exactly the same manner. The above description applies, but with &lt;code&gt;Matrix&lt;/code&gt; substituted for &lt;code&gt;Vector&lt;/code&gt;. For three-dimensional tests, substitute &lt;code&gt;Tensor&lt;/code&gt; for &lt;code&gt;Vector&lt;/code&gt;. For four-dimensional tests, substitute &lt;code&gt;SuperTensor&lt;/code&gt; for &lt;code&gt;Vector&lt;/code&gt;. For flat in-place array tests, substitute &lt;code&gt;Flat&lt;/code&gt; for &lt;code&gt;Vector&lt;/code&gt;. For the descriptions that follow, we will reference the &lt;code&gt;Vector&lt;/code&gt; tests, but the same information applies to &lt;code&gt;Matrix&lt;/code&gt;, &lt;code&gt;Tensor&lt;/code&gt; and &lt;code&gt;SuperTensor&lt;/code&gt; tests.</source>
          <target state="translated">Точно так же тестируются двумерные массивы. Применимо приведенное выше описание, но вместо &lt;code&gt;Vector&lt;/code&gt; &lt;code&gt;Matrix&lt;/code&gt; . Для трехмерных тестов замените &lt;code&gt;Tensor&lt;/code&gt; на &lt;code&gt;Vector&lt;/code&gt; . Для четырехмерных тестов замените &lt;code&gt;SuperTensor&lt;/code&gt; на &lt;code&gt;Vector&lt;/code&gt; . Для тестов плоских массивов на месте замените &lt;code&gt;Flat&lt;/code&gt; на &lt;code&gt;Vector&lt;/code&gt; . В следующих описаниях мы будем ссылаться на &lt;code&gt;Vector&lt;/code&gt; тесты, но та же информация применима к &lt;code&gt;Matrix&lt;/code&gt; , &lt;code&gt;Tensor&lt;/code&gt; и &lt;code&gt;SuperTensor&lt;/code&gt; тестам.</target>
        </trans-unit>
        <trans-unit id="3deb7456519697ecf4eefc455516c969a3681bae" translate="yes" xml:space="preserve">
          <source>Type</source>
          <target state="translated">Type</target>
        </trans-unit>
        <trans-unit id="4f87d1dd8d472cbdfec76a8cf89933a4a1cf8dbd" translate="yes" xml:space="preserve">
          <source>Type Promotion</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="315f6367d2e7e25cde681d099ca28e1c2c774de1" translate="yes" xml:space="preserve">
          <source>Type declarations</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="546ef13b4643b6acadc0951eac37d6f468caac3d" translate="yes" xml:space="preserve">
          <source>Type description examples</source>
          <target state="translated">Примеры описания типа</target>
        </trans-unit>
        <trans-unit id="966782d7443e2170cf499e59f9a8368a7b7380cd" translate="yes" xml:space="preserve">
          <source>Type has fields associated with it.</source>
          <target state="translated">Тип имеет связанные с ним поля.</target>
        </trans-unit>
        <trans-unit id="ad1651cc08eba91d6dce8f9e7cbe0420ed624c49" translate="yes" xml:space="preserve">
          <source>Type has no size information attached, and can be resized. Should only be called on flexible dtypes. Types that are attached to an array will always be sized, hence the array form of this macro not existing.</source>
          <target state="translated">Тип не имеет информации о размере и может быть изменен.Называется только для гибких типов.Типы,которые прикрепляются к массиву,всегда будут иметь размер,поэтому форма массива данного макроса не существует.</target>
        </trans-unit>
        <trans-unit id="00fea5456fe9ccd4a61fecaaa45953e334c1c594" translate="yes" xml:space="preserve">
          <source>Type is either flexible or user-defined.</source>
          <target state="translated">Тип является гибким или определяется пользователем.</target>
        </trans-unit>
        <trans-unit id="fd89c694ef19c6e785630016c5d715bce35c6076" translate="yes" xml:space="preserve">
          <source>Type is preserved for boolean arrays, so the result will contain &lt;code&gt;False&lt;/code&gt; when consecutive elements are the same and &lt;code&gt;True&lt;/code&gt; when they differ.</source>
          <target state="translated">Тип сохраняется для логических массивов, поэтому результат будет содержать &lt;code&gt;False&lt;/code&gt; , если последовательные элементы совпадают, и &lt;code&gt;True&lt;/code&gt; , если они отличаются.</target>
        </trans-unit>
        <trans-unit id="5f129dda4a5f86710986e28a3910cacd0ab66b0a" translate="yes" xml:space="preserve">
          <source>Type of comparison.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c36d17e1133f5c5a545edd7db2e2ccd0a71a9cf5" translate="yes" xml:space="preserve">
          <source>Type of the data (integer, float, Python object, etc.)</source>
          <target state="translated">Тип данных (целое число,плавающий,объект Python и т.д.)</target>
        </trans-unit>
        <trans-unit id="dd429360d0a73315317719cd2b034bd7849c79e3" translate="yes" xml:space="preserve">
          <source>Type of the returned array and of the accumulator in which the elements are summed. If &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt; is not specified, it defaults to the dtype of &lt;code&gt;a&lt;/code&gt;, unless &lt;code&gt;a&lt;/code&gt; has an integer dtype with a precision less than that of the default platform integer. In that case, the default platform integer is used.</source>
          <target state="translated">Тип возвращаемого массива и аккумулятора, в котором суммируются элементы. Если &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt; не указан, по умолчанию используется dtype &lt;code&gt;a&lt;/code&gt; , если &lt;code&gt;a&lt;/code&gt; не имеет целочисленного dtype с точностью меньше, чем у целого числа платформы по умолчанию. В этом случае используется целое число платформы по умолчанию.</target>
        </trans-unit>
        <trans-unit id="07bc03c5a2d510ae05b611f9e4728e3dfbb4d656" translate="yes" xml:space="preserve">
          <source>Type of the returned array, as well as of the accumulator in which the elements are multiplied. If &lt;em&gt;dtype&lt;/em&gt; is not specified, it defaults to the dtype of &lt;code&gt;a&lt;/code&gt;, unless &lt;code&gt;a&lt;/code&gt; has an integer dtype with a precision less than that of the default platform integer. In that case, the default platform integer is used instead.</source>
          <target state="translated">Тип возвращаемого массива, а также аккумулятора, в котором умножаются элементы. Если &lt;em&gt;dtype&lt;/em&gt; не указан, по умолчанию используется dtype &lt;code&gt;a&lt;/code&gt; , если &lt;code&gt;a&lt;/code&gt; не имеет целочисленного dtype с точностью меньше, чем у целого числа платформы по умолчанию. В этом случае вместо этого используется целое число платформы по умолчанию.</target>
        </trans-unit>
        <trans-unit id="2fbcc881be006ea806d10d1a75e79dec487e047f" translate="yes" xml:space="preserve">
          <source>Type of the returned view, e.g., ndarray or matrix. Again, omission of the parameter results in type preservation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="36795fd8406bf11fda0ac3128a88df4463dd2892" translate="yes" xml:space="preserve">
          <source>Type of the returned view, e.g., ndarray or matrix. Again, the default None results in type preservation.</source>
          <target state="translated">Тип возвращаемого вида,например,ндаррей или матрица.Опять же,по умолчанию &quot;Нет&quot; приводит к сохранению типа.</target>
        </trans-unit>
        <trans-unit id="e3dd48b9d6f09dc7416ab4d63d6ccc2dc14a5715" translate="yes" xml:space="preserve">
          <source>Type of the returned view, either ndarray or a subclass. The default None results in type preservation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d0b3189219da3d7ba109eef463be8e2071fbe7e" translate="yes" xml:space="preserve">
          <source>Type promotion in NumPy works similarly to the rules in languages like C++, with some slight differences. When both scalars and arrays are used, the array&amp;rsquo;s type takes precedence and the actual value of the scalar is taken into account.</source>
          <target state="translated">Продвижение типов в NumPy работает аналогично правилам таких языков, как C ++, с некоторыми небольшими отличиями. Когда используются и скаляры, и массивы, тип массива имеет приоритет, и учитывается фактическое значение скаляра.</target>
        </trans-unit>
        <trans-unit id="66585ef6b68c044b299bc7220f22788121e21167" translate="yes" xml:space="preserve">
          <source>Type provided:</source>
          <target state="translated">Тип предоставлен:</target>
        </trans-unit>
        <trans-unit id="bc25fc1327a92506da2b55272b3113fcffa65d61" translate="yes" xml:space="preserve">
          <source>Type represents Boolean data type.</source>
          <target state="translated">Тип представляет собой булевский тип данных.</target>
        </trans-unit>
        <trans-unit id="60db025c166ec63b9a181b61c24b20c5d24b0648" translate="yes" xml:space="preserve">
          <source>Type represents a signed integer.</source>
          <target state="translated">Тип представляет собой знаковое целое число.</target>
        </trans-unit>
        <trans-unit id="acb6256437982d272438054c848d82884163b4d8" translate="yes" xml:space="preserve">
          <source>Type represents a string data type.</source>
          <target state="translated">Тип представляет собой строковый тип данных.</target>
        </trans-unit>
        <trans-unit id="08f325041fae51a65ee6e08f868548827f3e2b61" translate="yes" xml:space="preserve">
          <source>Type represents a user-defined type.</source>
          <target state="translated">Тип представляет собой определяемый пользователем тип.</target>
        </trans-unit>
        <trans-unit id="f5f87b05bbeb10ab3c2ec34871c51fb7f3e190f2" translate="yes" xml:space="preserve">
          <source>Type represents an enumerated type corresponding to one of the standard Python scalar (bool, int, float, or complex).</source>
          <target state="translated">Тип представляет собой перечисляемый тип,соответствующий одному из стандартных Python scalar (bool,int,float или complex).</target>
        </trans-unit>
        <trans-unit id="6fc847c0dbefe834d836a7b9b36c518b8a349fc4" translate="yes" xml:space="preserve">
          <source>Type represents an unsigned integer.</source>
          <target state="translated">Тип представляет собой беззнаковое целое число.</target>
        </trans-unit>
        <trans-unit id="f8e7a296ef6aceb534615bd823bf7fad61a5043e" translate="yes" xml:space="preserve">
          <source>Type represents any complex floating point number.</source>
          <target state="translated">Тип представляет собой любое комплексное число с плавающей точкой.</target>
        </trans-unit>
        <trans-unit id="28cd3b87be44c11187d7cc10075315e307082083" translate="yes" xml:space="preserve">
          <source>Type represents any floating point number.</source>
          <target state="translated">Тип представляет собой любое число с плавающей точкой.</target>
        </trans-unit>
        <trans-unit id="579601ba7e8ea9eb8623a33cadfe20f9eaea6f83" translate="yes" xml:space="preserve">
          <source>Type represents any integer, floating point, or complex floating point number.</source>
          <target state="translated">Тип представляет собой любое целое,плавающее число или сложное число с плавающей точкой.</target>
        </trans-unit>
        <trans-unit id="051ab06f1a62606ef03aadb95e9e56f705f31488" translate="yes" xml:space="preserve">
          <source>Type represents any integer.</source>
          <target state="translated">Тип представляет собой любое целое число.</target>
        </trans-unit>
        <trans-unit id="a2ba1da5781162c52e0abb1d3993de06d380b834" translate="yes" xml:space="preserve">
          <source>Type represents object data type.</source>
          <target state="translated">Тип представляет собой тип данных объекта.</target>
        </trans-unit>
        <trans-unit id="20eece7c06865b2554e5d1db1375400953d56528" translate="yes" xml:space="preserve">
          <source>Type represents one of the flexible array types ( &lt;a href=&quot;c-api.dtype#c.NPY_STRING&quot;&gt;&lt;code&gt;NPY_STRING&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;c-api.dtype#c.NPY_UNICODE&quot;&gt;&lt;code&gt;NPY_UNICODE&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&quot;c-api.dtype#c.NPY_VOID&quot;&gt;&lt;code&gt;NPY_VOID&lt;/code&gt;&lt;/a&gt; ).</source>
          <target state="translated">Тип представляет один из гибких типов массива ( &lt;a href=&quot;c-api.dtype#c.NPY_STRING&quot;&gt; &lt;code&gt;NPY_STRING&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;c-api.dtype#c.NPY_UNICODE&quot;&gt; &lt;code&gt;NPY_UNICODE&lt;/code&gt; &lt;/a&gt; или &lt;a href=&quot;c-api.dtype#c.NPY_VOID&quot;&gt; &lt;code&gt;NPY_VOID&lt;/code&gt; &lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="8e6c44e27b4edb7108b331e3527612380352acbf" translate="yes" xml:space="preserve">
          <source>Type represents one of the flexible array types ( &lt;a href=&quot;dtype#c.NPY_STRING&quot;&gt;&lt;code&gt;NPY_STRING&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;dtype#c.NPY_UNICODE&quot;&gt;&lt;code&gt;NPY_UNICODE&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&quot;dtype#c.NPY_VOID&quot;&gt;&lt;code&gt;NPY_VOID&lt;/code&gt;&lt;/a&gt; ).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cab551b16a69b24d82e03c4a0d668cc3040d4465" translate="yes" xml:space="preserve">
          <source>Type specific, core 1-d functions for ufuncs where each calculation is obtained by calling a function taking one input argument and returning one output. This function is passed in &lt;code&gt;func&lt;/code&gt;. The letters correspond to dtypechar&amp;rsquo;s of the supported data types ( &lt;code&gt;e&lt;/code&gt; - half, &lt;code&gt;f&lt;/code&gt; - float, &lt;code&gt;d&lt;/code&gt; - double, &lt;code&gt;g&lt;/code&gt; - long double, &lt;code&gt;F&lt;/code&gt; - cfloat, &lt;code&gt;D&lt;/code&gt; - cdouble, &lt;code&gt;G&lt;/code&gt; - clongdouble). The argument &lt;em&gt;func&lt;/em&gt; must support the same signature. The _As_X_X variants assume ndarray&amp;rsquo;s of one data type but cast the values to use an underlying function that takes a different data type. Thus, &lt;a href=&quot;#c.PyUFunc_f_f_As_d_d&quot;&gt;&lt;code&gt;PyUFunc_f_f_As_d_d&lt;/code&gt;&lt;/a&gt; uses ndarrays of data type &lt;a href=&quot;c-api.dtype#c.NPY_FLOAT&quot;&gt;&lt;code&gt;NPY_FLOAT&lt;/code&gt;&lt;/a&gt; but calls out to a C-function that takes double and returns double.</source>
          <target state="translated">Зависящие от типа основные одномерные функции для ufuncs, где каждое вычисление получается путем вызова функции, принимающей один входной аргумент и возвращающей один выходной. Эта функция передается в &lt;code&gt;func&lt;/code&gt; . Буквы соответствуют dtypechar поддерживаемых типов данных ( &lt;code&gt;e&lt;/code&gt; - half, &lt;code&gt;f&lt;/code&gt; - float, &lt;code&gt;d&lt;/code&gt; - double, &lt;code&gt;g&lt;/code&gt; - long double, &lt;code&gt;F&lt;/code&gt; - cfloat, &lt;code&gt;D&lt;/code&gt; - cdouble, &lt;code&gt;G&lt;/code&gt; - clongdouble). Аргумент &lt;em&gt;FUNC&lt;/em&gt; должен поддерживать ту же подпись. Варианты _As_X_X предполагают ndarray одного типа данных, но приводят значения для использования базовой функции, которая принимает другой тип данных. Таким образом, &lt;a href=&quot;#c.PyUFunc_f_f_As_d_d&quot;&gt; &lt;code&gt;PyUFunc_f_f_As_d_d&lt;/code&gt; &lt;/a&gt;использует ndarrays типа данных &lt;a href=&quot;c-api.dtype#c.NPY_FLOAT&quot;&gt; &lt;code&gt;NPY_FLOAT&lt;/code&gt; ,&lt;/a&gt; но вызывает C-функцию, которая принимает double и возвращает double.</target>
        </trans-unit>
        <trans-unit id="e494b69883a66d9ceddef7c995f1d4e3172789f0" translate="yes" xml:space="preserve">
          <source>Type specific, core 1-d functions for ufuncs where each calculation is obtained by calling a function taking one input argument and returning one output. This function is passed in &lt;code&gt;func&lt;/code&gt;. The letters correspond to dtypechar&amp;rsquo;s of the supported data types ( &lt;code&gt;e&lt;/code&gt; - half, &lt;code&gt;f&lt;/code&gt; - float, &lt;code&gt;d&lt;/code&gt; - double, &lt;code&gt;g&lt;/code&gt; - long double, &lt;code&gt;F&lt;/code&gt; - cfloat, &lt;code&gt;D&lt;/code&gt; - cdouble, &lt;code&gt;G&lt;/code&gt; - clongdouble). The argument &lt;em&gt;func&lt;/em&gt; must support the same signature. The _As_X_X variants assume ndarray&amp;rsquo;s of one data type but cast the values to use an underlying function that takes a different data type. Thus, &lt;a href=&quot;#c.PyUFunc_f_f_As_d_d&quot;&gt;&lt;code&gt;PyUFunc_f_f_As_d_d&lt;/code&gt;&lt;/a&gt; uses ndarrays of data type &lt;a href=&quot;dtype#c.NPY_FLOAT&quot;&gt;&lt;code&gt;NPY_FLOAT&lt;/code&gt;&lt;/a&gt; but calls out to a C-function that takes double and returns double.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2718d921f0c8c7bb73eed2147fee6ea79b6b6859" translate="yes" xml:space="preserve">
          <source>Type specific, core 1-d functions for ufuncs where each calculation is obtained by calling a function taking two input arguments and returning one output. The underlying function to call is passed in as &lt;em&gt;func&lt;/em&gt;. The letters correspond to dtypechar&amp;rsquo;s of the specific data type supported by the general-purpose function. The argument &lt;code&gt;func&lt;/code&gt; must support the corresponding signature. The &lt;code&gt;_As_XX_X&lt;/code&gt; variants assume ndarrays of one data type but cast the values at each iteration of the loop to use the underlying function that takes a different data type.</source>
          <target state="translated">Зависящие от типа, основные одномерные функции для ufuncs, где каждое вычисление получается путем вызова функции, принимающей два входных аргумента и возвращающей один выходной. Базовая функция для вызова передается как &lt;em&gt;func&lt;/em&gt; . Буквы соответствуют dtypechar определенного типа данных, поддерживаемого функцией общего назначения. Аргумент &lt;code&gt;func&lt;/code&gt; должен поддерживать соответствующую подпись. В &lt;code&gt;_As_XX_X&lt;/code&gt; варианта предполагают ndarrays одного типа данных , но отливать значения на каждой итерации цикла , чтобы использовать основную функцию , которая принимает другой тип данных.</target>
        </trans-unit>
        <trans-unit id="ef2ee12d948765f441a77e0dc116238b4eb26327" translate="yes" xml:space="preserve">
          <source>Type specifier strings are convertible to dtypes and can therefore be used instead of dtypes:</source>
          <target state="translated">Строки спецификаторов типов конвертируются в стипы и поэтому могут использоваться вместо стипов:</target>
        </trans-unit>
        <trans-unit id="f7df157385540da09117c232afd23b684eee205b" translate="yes" xml:space="preserve">
          <source>Type strings</source>
          <target state="translated">Шрифтовые строки</target>
        </trans-unit>
        <trans-unit id="b6e792a3d08a7bd144dac10e42edb461fd3dd2e3" translate="yes" xml:space="preserve">
          <source>Type to use in computing the mean. For integer inputs, the default is &lt;code&gt;float64&lt;/code&gt;; for floating point inputs, it is the same as the input dtype.</source>
          <target state="translated">Тип для использования при вычислении среднего. Для целочисленных входов значение по умолчанию - &lt;code&gt;float64&lt;/code&gt; ; для входных данных с плавающей запятой это то же самое, что и входной dtype.</target>
        </trans-unit>
        <trans-unit id="9f9df4fba8dcd1fb7d56164c04214c5a4ba9ba6b" translate="yes" xml:space="preserve">
          <source>Type to use in computing the mean. For integer inputs, the default is &lt;code&gt;float64&lt;/code&gt;; for inexact inputs, it is the same as the input dtype.</source>
          <target state="translated">Тип для использования при вычислении среднего. Для целочисленных входов значение по умолчанию - &lt;code&gt;float64&lt;/code&gt; ; для неточных входных данных он такой же, как входной dtype.</target>
        </trans-unit>
        <trans-unit id="3131a42adb40886f91b9db8d1e4f4fee7e5c8913" translate="yes" xml:space="preserve">
          <source>Type to use in computing the standard deviation. For arrays of integer type the default is float64, for arrays of float types it is the same as the array type.</source>
          <target state="translated">Тип для использования при вычислении стандартного отклонения.Для массивов целочисленного типа по умолчанию используется float64,для массивов типа float-тип массива.</target>
        </trans-unit>
        <trans-unit id="80e97dffa22c435830b854e8d6fb1c6cb57a1b46" translate="yes" xml:space="preserve">
          <source>Type to use in computing the variance. For arrays of integer type</source>
          <target state="translated">Тип для использования в вычислении дисперсии.Для массивов целочисленного типа</target>
        </trans-unit>
        <trans-unit id="c52f694878c4817d9cf0e30a93a5ac5c826ca338" translate="yes" xml:space="preserve">
          <source>Type to use in computing the variance. For arrays of integer type the default is &lt;code&gt;float32&lt;/code&gt;; for arrays of float types it is the same as the array type.</source>
          <target state="translated">Тип для использования при вычислении дисперсии. Для массивов целочисленного типа значение по умолчанию - &lt;code&gt;float32&lt;/code&gt; ; для массивов типов с плавающей запятой он совпадает с типом массива.</target>
        </trans-unit>
        <trans-unit id="251490cecef7141a0dccef6fed5a02c3f5f10907" translate="yes" xml:space="preserve">
          <source>Type to use in computing the variance. For arrays of integer type the default is &lt;code&gt;float64&lt;/code&gt;; for arrays of float types it is the same as the array type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d160c5845a8a77a5befb4851a7053d8bdf35eb94" translate="yes" xml:space="preserve">
          <source>Typecode or data-type to which the array is cast.</source>
          <target state="translated">Типичный код или тип данных,которому передается массив.</target>
        </trans-unit>
        <trans-unit id="41a5cdb8ef55e142306841748946bd3431f088b4" translate="yes" xml:space="preserve">
          <source>Typed versions of many of the &lt;a href=&quot;generator#numpy.random.Generator&quot;&gt;&lt;code&gt;Generator&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;bit_generators/generated/numpy.random.bitgenerator#numpy.random.BitGenerator&quot;&gt;&lt;code&gt;BitGenerator&lt;/code&gt;&lt;/a&gt; methods as well as the classes themselves can be accessed directly from Cython via</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="23cf72e69c01c79ece86b50f4bc0e1b659346558" translate="yes" xml:space="preserve">
          <source>Typemap conversions for complex floating-point types is also not supported automatically. This is because Python and NumPy are written in C, which does not have native complex types. Both Python and NumPy implement their own (essentially equivalent) &lt;code&gt;struct&lt;/code&gt; definitions for complex variables:</source>
          <target state="translated">Преобразование карты типов для сложных типов с плавающей запятой также не поддерживается автоматически. Это потому, что Python и NumPy написаны на C, который не имеет собственных сложных типов. И Python, и NumPy реализуют свои собственные (практически эквивалентные) определения &lt;code&gt;struct&lt;/code&gt; для сложных переменных:</target>
        </trans-unit>
        <trans-unit id="f2014cb40164abd5b9ac9cf3258c64ef343de062" translate="yes" xml:space="preserve">
          <source>Typemaps are keyed off a list of one or more function arguments, either by type or by type and name. We will refer to such lists as &lt;em&gt;signatures&lt;/em&gt;. One of the many typemaps defined by &lt;code&gt;numpy.i&lt;/code&gt; is used above and has the signature &lt;code&gt;(double* IN_ARRAY1, int DIM1)&lt;/code&gt;. The argument names are intended to suggest that the &lt;code&gt;double*&lt;/code&gt; argument is an input array of one dimension and that the &lt;code&gt;int&lt;/code&gt; represents the size of that dimension. This is precisely the pattern in the &lt;code&gt;rms&lt;/code&gt; prototype.</source>
          <target state="translated">Карты типов состоят из списка из одного или нескольких аргументов функции либо по типу, либо по типу и имени. Мы будем называть такие списки &lt;em&gt;подписями&lt;/em&gt; . Одна из многих карт типов, определенных &lt;code&gt;numpy.i&lt;/code&gt; , используется выше и имеет подпись &lt;code&gt;(double* IN_ARRAY1, int DIM1)&lt;/code&gt; . Имена аргументов предполагают, что аргумент &lt;code&gt;double*&lt;/code&gt; является входным массивом одного измерения, а &lt;code&gt;int&lt;/code&gt; представляет размер этого измерения. Именно &lt;code&gt;rms&lt;/code&gt; образец прототипа среднеквадратичного значения .</target>
        </trans-unit>
        <trans-unit id="908f34305dca26ca1d02c401b17bcc9125b1ab5c" translate="yes" xml:space="preserve">
          <source>Types with &lt;code&gt;.dtype&lt;/code&gt;</source>
          <target state="translated">Типы с &lt;code&gt;.dtype&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9f433de3a09f2cf5cd13a827c57725457d725e39" translate="yes" xml:space="preserve">
          <source>Typical usage:</source>
          <target state="translated">Типичное использование:</target>
        </trans-unit>
        <trans-unit id="e390f0c6d81411459ef6be418905b3473133c360" translate="yes" xml:space="preserve">
          <source>Typically a &amp;lsquo;greedy&amp;rsquo; algorithm is applied which empirical tests have shown returns the optimal path in the majority of cases. In some cases &amp;lsquo;optimal&amp;rsquo; will return the superlative path through a more expensive, exhaustive search. For iterative calculations it may be advisable to calculate the optimal path once and reuse that path by supplying it as an argument. An example is given below.</source>
          <target state="translated">Обычно применяется &amp;laquo;жадный&amp;raquo; алгоритм, который, как показали эмпирические тесты, в большинстве случаев возвращает оптимальный путь. В некоторых случаях &amp;laquo;оптимальный&amp;raquo; вернет превосходный путь через более дорогостоящий исчерпывающий поиск. Для итеративных вычислений может быть целесообразно вычислить оптимальный путь один раз и повторно использовать этот путь, указав его в качестве аргумента. Пример приведен ниже.</target>
        </trans-unit>
        <trans-unit id="291bb923a1cf51e55db8c8127cc92200f5117732" translate="yes" xml:space="preserve">
          <source>Typically these new versions of the array metadata but the same data buffer are new &amp;lsquo;views&amp;rsquo; into the data buffer. There is a different ndarray object, but it uses the same data buffer. This is why it is necessary to force copies through use of the .copy() method if one really wants to make a new and independent copy of the data buffer.</source>
          <target state="translated">Обычно эти новые версии метаданных массива, но тот же буфер данных, представляют собой новые &amp;laquo;представления&amp;raquo; в буфере данных. Есть другой объект ndarray, но он использует тот же буфер данных. Вот почему необходимо принудительно копировать с помощью метода .copy (), если кто-то действительно хочет создать новую и независимую копию буфера данных.</target>
        </trans-unit>
        <trans-unit id="54a23bec4dd6b17bf03f7139f1786ecb950b41b8" translate="yes" xml:space="preserve">
          <source>Typically this value will be one more than what you might expect because all ufuncs take the optional &amp;ldquo;out&amp;rdquo; argument.</source>
          <target state="translated">Обычно это значение будет на единицу больше, чем вы могли ожидать, потому что все ufunc принимают необязательный аргумент &amp;laquo;out&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="2db839a7e94204fc83aa9e6a4d27e6c5c452f385" translate="yes" xml:space="preserve">
          <source>Typically though, &lt;code&gt;self.min(axis=axis)&lt;/code&gt; is sufficient.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="32606a7a80aee72f839ad47d7de51922ee1b0957" translate="yes" xml:space="preserve">
          <source>Typically you get a new reference to a variable when it is created or is the return value of some function (there are some prominent exceptions, however &amp;mdash; such as getting an item out of a tuple or a dictionary). When you own the reference, you are responsible to make sure that &lt;a href=&quot;https://docs.python.org/dev/c-api/refcounting.html#c.Py_DECREF&quot;&gt;&lt;code&gt;Py_DECREF&lt;/code&gt;&lt;/a&gt; (var) is called when the variable is no longer necessary (and no other function has &amp;ldquo;stolen&amp;rdquo; its reference). Also, if you are passing a Python object to a function that will &amp;ldquo;steal&amp;rdquo; the reference, then you need to make sure you own it (or use &lt;a href=&quot;https://docs.python.org/dev/c-api/refcounting.html#c.Py_INCREF&quot;&gt;&lt;code&gt;Py_INCREF&lt;/code&gt;&lt;/a&gt; to get your own reference). You will also encounter the notion of borrowing a reference. A function that borrows a reference does not alter the reference count of the object and does not expect to &amp;ldquo;hold on &amp;ldquo;to the reference. It&amp;rsquo;s just going to use the object temporarily. When you use &lt;a href=&quot;https://docs.python.org/dev/c-api/arg.html#c.PyArg_ParseTuple&quot;&gt;&lt;code&gt;PyArg_ParseTuple&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;https://docs.python.org/dev/c-api/arg.html#c.PyArg_UnpackTuple&quot;&gt;&lt;code&gt;PyArg_UnpackTuple&lt;/code&gt;&lt;/a&gt; you receive a borrowed reference to the objects in the tuple and should not alter their reference count inside your function. With practice, you can learn to get reference counting right, but it can be frustrating at first.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3fadc3f723273062c4d9c5a6483a39eed14f9c66" translate="yes" xml:space="preserve">
          <source>Typically, the size of all core dimensions in an output will be determined by the size of a core dimension with the same label in an input array. This is not a requirement, and it is possible to define a signature where a label comes up for the first time in an output, although some precautions must be taken when calling such a function. An example would be the function &lt;code&gt;euclidean_pdist(a)&lt;/code&gt;, with signature &lt;code&gt;(n,d)-&amp;gt;(p)&lt;/code&gt;, that given an array of &lt;code&gt;n&lt;/code&gt;&lt;code&gt;d&lt;/code&gt;-dimensional vectors, computes all unique pairwise Euclidean distances among them. The output dimension &lt;code&gt;p&lt;/code&gt; must therefore be equal to &lt;code&gt;n * (n - 1) / 2&lt;/code&gt;, but it is the caller&amp;rsquo;s responsibility to pass in an output array of the right size. If the size of a core dimension of an output cannot be determined from a passed in input or output array, an error will be raised.</source>
          <target state="translated">Обычно размер всех основных измерений в выходных данных определяется размером основного измерения с той же меткой во входном массиве. Это не является обязательным требованием, и можно определить подпись там, где метка появляется впервые в выводе, хотя при вызове такой функции необходимо принять некоторые меры предосторожности. Примером может служить функция &lt;code&gt;euclidean_pdist(a)&lt;/code&gt; с сигнатурой &lt;code&gt;(n,d)-&amp;gt;(p)&lt;/code&gt; , которая, учитывая массив из &lt;code&gt;n&lt;/code&gt; &lt;code&gt;d&lt;/code&gt; -мерных векторов, вычисляет все уникальные попарные евклидовы расстояния между ними. Следовательно, выходной размер &lt;code&gt;p&lt;/code&gt; должен быть равен &lt;code&gt;n * (n - 1) / 2&lt;/code&gt; , но ответственность за передачу выходного массива правильного размера лежит на вызывающей стороне. Если размер основного измерения вывода не может быть определен из переданного входного или выходного массива, возникает ошибка.</target>
        </trans-unit>
        <trans-unit id="b2c7c0caa10a0cca5ea7d69e54018ae0c0389dd6" translate="yes" xml:space="preserve">
          <source>U</source>
          <target state="translated">U</target>
        </trans-unit>
        <trans-unit id="f1bad5a5addf87c78243a0908ff2f26f2b5c976f" translate="yes" xml:space="preserve">
          <source>UC Berkeley (Stefan van der Walt, Sebastian Berg, Warren Weckesser, Ross Barnowski)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="054ec2a1c571b996a33a40629d7bbd3a2c7c7a03" translate="yes" xml:space="preserve">
          <source>UFUNC_CHECK_ERROR()</source>
          <target state="translated">UFUNC_CHECK_ERROR()</target>
        </trans-unit>
        <trans-unit id="d2291265ceb8694acf9ebd2a0083ea66791f6665" translate="yes" xml:space="preserve">
          <source>UFUNC_CHECK_STATUS()</source>
          <target state="translated">UFUNC_CHECK_STATUS()</target>
        </trans-unit>
        <trans-unit id="7c45c7778c0f3c31bbfb06962ea0f2b3d024a473" translate="yes" xml:space="preserve">
          <source>UFUNC_ERR_{HANDLER}</source>
          <target state="translated">UFUNC_ERR_{HANDLER}</target>
        </trans-unit>
        <trans-unit id="46518eb931ec8d24ef410f576a7160b8b457bb69" translate="yes" xml:space="preserve">
          <source>UFunc API</source>
          <target state="translated">UFunc API</target>
        </trans-unit>
        <trans-unit id="779cd7c4bcd3367298526e617162cab51fe8f735" translate="yes" xml:space="preserve">
          <source>UPDATEIFCOPY (U) (deprecated), replaced by WRITEBACKIFCOPY;</source>
          <target state="translated">UPDATEIFCOPY (U)(устаревшая),заменена на WRITEBACKIFCOPY;</target>
        </trans-unit>
        <trans-unit id="4eab2a5ea17917129ec8fa19b15a7cfda3fe1d46" translate="yes" xml:space="preserve">
          <source>UPDATEIFCOPY / U</source>
          <target state="translated">ОБНОВЛЁННАЯ КОПИЯ/У</target>
        </trans-unit>
        <trans-unit id="8c955f87125d1d07da79b0f8b10f03f3519e41af" translate="yes" xml:space="preserve">
          <source>UPDATEIFCOPY can only be set &lt;code&gt;False&lt;/code&gt;.</source>
          <target state="translated">UPDATEIFCOPY может иметь только значение &lt;code&gt;False&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7033cb6e00b408f93174a1cb4dc874e5ec8f4436" translate="yes" xml:space="preserve">
          <source>URLs require a scheme string (&lt;code&gt;http://&lt;/code&gt;) to be used, without it they will fail:</source>
          <target state="translated">URL-адреса требуют использования строки схемы ( &lt;code&gt;http://&lt;/code&gt; ), без нее они не будут работать:</target>
        </trans-unit>
        <trans-unit id="76298f39f520148528f0c1a12443b1e9a612a67d" translate="yes" xml:space="preserve">
          <source>Ufunc API</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="07fbda00eaafb6ceaaf8098d7abd7adf2f3fa665" translate="yes" xml:space="preserve">
          <source>Ufunc behavior for overlapping inputs</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01787e5708f1880517c980a345514f0ac0d4f3a1" translate="yes" xml:space="preserve">
          <source>Ufuncs allow other array-like classes to be passed seamlessly through the interface in that inputs of a particular class will induce the outputs to be of that same class. The mechanism by which this works is the following. If any of the inputs are not ndarrays and define the &lt;a href=&quot;arrays.classes#numpy.class.__array_wrap__&quot;&gt;&lt;code&gt;__array_wrap__&lt;/code&gt;&lt;/a&gt; method, then the class with the largest &lt;a href=&quot;arrays.classes#numpy.class.__array_priority__&quot;&gt;&lt;code&gt;__array_priority__&lt;/code&gt;&lt;/a&gt; attribute determines the type of all the outputs (with the exception of any output arrays passed in). The &lt;a href=&quot;arrays.classes#numpy.class.__array_wrap__&quot;&gt;&lt;code&gt;__array_wrap__&lt;/code&gt;&lt;/a&gt; method of the input array will be called with the ndarray being returned from the ufunc as it&amp;rsquo;s input. There are two calling styles of the &lt;a href=&quot;arrays.classes#numpy.class.__array_wrap__&quot;&gt;&lt;code&gt;__array_wrap__&lt;/code&gt;&lt;/a&gt; function supported. The first takes the ndarray as the first argument and a tuple of &amp;ldquo;context&amp;rdquo; as the second argument. The context is (ufunc, arguments, output argument number). This is the first call tried. If a TypeError occurs, then the function is called with just the ndarray as the first argument.</source>
          <target state="translated">Ufuncs позволяют беспрепятственно передавать другие классы, подобные массивам, через интерфейс, поскольку входные данные определенного класса побуждают выходы к тому же классу. Механизм, с помощью которого это работает, следующий. Если какой-либо из входов не является ndarrays и определяет метод &lt;a href=&quot;arrays.classes#numpy.class.__array_wrap__&quot;&gt; &lt;code&gt;__array_wrap__&lt;/code&gt; &lt;/a&gt; , то класс с самым большим атрибутом &lt;a href=&quot;arrays.classes#numpy.class.__array_priority__&quot;&gt; &lt;code&gt;__array_priority__&lt;/code&gt; &lt;/a&gt; определяет тип всех выходов (за исключением любых переданных выходных массивов). Будет &lt;a href=&quot;arrays.classes#numpy.class.__array_wrap__&quot;&gt; &lt;code&gt;__array_wrap__&lt;/code&gt; &lt;/a&gt; метод __array_wrap__ входного массива, при этом ndarray будет возвращен из ufunc в качестве входного. Есть два стиля вызова &lt;a href=&quot;arrays.classes#numpy.class.__array_wrap__&quot;&gt; &lt;code&gt;__array_wrap__&lt;/code&gt; &lt;/a&gt;функция поддерживается. Первый принимает массив ndarray в качестве первого аргумента и кортеж &amp;laquo;context&amp;raquo; в качестве второго аргумента. Контекст (ufunc, аргументы, номер выходного аргумента). Это первая попытка звонка. Если возникает ошибка TypeError, функция вызывается только с ndarray в качестве первого аргумента.</target>
        </trans-unit>
        <trans-unit id="bb1e7beaee60184f94b2766ad490881fcda15d1a" translate="yes" xml:space="preserve">
          <source>Ufuncs also have a fifth method that allows in place operations to be performed using fancy indexing. No buffering is used on the dimensions where fancy indexing is used, so the fancy index can list an item more than once and the operation will be performed on the result of the previous operation for that item.</source>
          <target state="translated">Ufuncs также имеет пятый метод,который позволяет выполнять на месте операции с использованием фантазийной индексации.Для размеров,где используется фантазийная индексация,не используется буферизация,поэтому фантазийный индекс может перечислять элемент более одного раза,и операция будет выполняться по результату предыдущей операции для этого элемента.</target>
        </trans-unit>
        <trans-unit id="ebe1370731077d311895107006a4816f68d36e75" translate="yes" xml:space="preserve">
          <source>Ufuncs: If the &lt;code&gt;ALIGNED&lt;/code&gt; flag of an array is False, ufuncs will buffer/cast the array before evaluation. This is needed since ufunc inner loops access raw elements directly, which might fail on some archs if the elements are not true-aligned.</source>
          <target state="translated">Ufuncs: Если &lt;code&gt;ALIGNED&lt;/code&gt; флаг массива является значение False, ufuncs будет буфер / литой массив перед оценкой. Это необходимо, поскольку внутренние циклы ufunc напрямую обращаются к необработанным элементам, что может дать сбой на некоторых арках, если элементы не выровнены по истине.</target>
        </trans-unit>
        <trans-unit id="781ffa6fd9f0234942bb6847c5bb2f8924769498" translate="yes" xml:space="preserve">
          <source>Umath and multiarray c-extension modules merged into a single module</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="52313eed90dffcad6d336fc2df812a51c07afa3f" translate="yes" xml:space="preserve">
          <source>Un-sized flexible data-type objects do not have this attribute.</source>
          <target state="translated">Неразмерные объекты гибкого типа данных не имеют данного атрибута.</target>
        </trans-unit>
        <trans-unit id="b7fcaea31c03023df34e5b7b17cd0d3a054b94c0" translate="yes" xml:space="preserve">
          <source>Unary operations:</source>
          <target state="translated">Унарные операции:</target>
        </trans-unit>
        <trans-unit id="eb11f871299eef811cd072499c803b05b282a2bf" translate="yes" xml:space="preserve">
          <source>Under certain conditions, &lt;code&gt;nditer&lt;/code&gt; must be used in a context manager</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a813a893f115799fcd0b6f6dee8828d16c00cb4d" translate="yes" xml:space="preserve">
          <source>Under-the-hood Documentation for developers</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee256bb7a636957391cc28f26fc314ab3aeba52b" translate="yes" xml:space="preserve">
          <source>Under-the-hood docs</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="56332d95dfcc595c6bea8676636a72713f221f0a" translate="yes" xml:space="preserve">
          <source>Underflow: result so close to zero that some precision was lost.</source>
          <target state="translated">Underflow:результат настолько близок к нулю,что некоторая точность была потеряна.</target>
        </trans-unit>
        <trans-unit id="59c608e219e1ef1b3832d726571dbc3af32612af" translate="yes" xml:space="preserve">
          <source>Understand axis and shape properties for n-dimensional arrays.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a82cdb76fef36e8a84963b1363d0b9e06ddc672" translate="yes" xml:space="preserve">
          <source>Understand how to apply some linear algebra operations to n-dimensional arrays without using for-loops;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c54944247198ee020e57c96492a8adaa8f1c26ce" translate="yes" xml:space="preserve">
          <source>Understand the difference between one-, two- and n-dimensional arrays in NumPy;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="233fa68a512b31fd9c7e11c16b1a271f55f3bf8e" translate="yes" xml:space="preserve">
          <source>Understanding the code &amp;amp; getting started</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="de8fa4e24f45bc650b9e48b7af77833b4a2c462a" translate="yes" xml:space="preserve">
          <source>Undoes &lt;a href=&quot;numpy.fft.fftshift#numpy.fft.fftshift&quot;&gt;&lt;code&gt;fftshift&lt;/code&gt;&lt;/a&gt;, shifts zero-frequency terms to beginning of array.</source>
          <target state="translated">Отменяет &lt;a href=&quot;numpy.fft.fftshift#numpy.fft.fftshift&quot;&gt; &lt;code&gt;fftshift&lt;/code&gt; &lt;/a&gt; , сдвигает члены с нулевой частотой в начало массива.</target>
        </trans-unit>
        <trans-unit id="9ab0bd9a6126ee4b9d7538d5c6cba7aa587f31ed" translate="yes" xml:space="preserve">
          <source>Unicode</source>
          <target state="translated">Unicode</target>
        </trans-unit>
        <trans-unit id="4fee0b7959c07c12abdb6224e31004ed0e03fe8f" translate="yes" xml:space="preserve">
          <source>Unicode (fixed-length sequence of &lt;a href=&quot;https://docs.python.org/dev/c-api/unicode.html#c.Py_UNICODE&quot;&gt;&lt;code&gt;Py_UNICODE&lt;/code&gt;&lt;/a&gt;)</source>
          <target state="translated">Юникод (последовательность фиксированной длины &lt;a href=&quot;https://docs.python.org/dev/c-api/unicode.html#c.Py_UNICODE&quot;&gt; &lt;code&gt;Py_UNICODE&lt;/code&gt; &lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="1b41da839119c4860ed2bab536f19149822ad0f7" translate="yes" xml:space="preserve">
          <source>Unicode string</source>
          <target state="translated">строка Юникода</target>
        </trans-unit>
        <trans-unit id="b817c790c0e1eb2da135f6728ba7e7a734d36d2a" translate="yes" xml:space="preserve">
          <source>Uniforms</source>
          <target state="translated">Uniforms</target>
        </trans-unit>
        <trans-unit id="bd181d4ea0c5f747e6be59067008be3f6a568280" translate="yes" xml:space="preserve">
          <source>Uniforms (&lt;a href=&quot;generated/numpy.random.generator.random#numpy.random.Generator.random&quot;&gt;&lt;code&gt;random&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;generated/numpy.random.generator.integers#numpy.random.Generator.integers&quot;&gt;&lt;code&gt;integers&lt;/code&gt;&lt;/a&gt;)</source>
          <target state="translated">Униформа ( &lt;a href=&quot;generated/numpy.random.generator.random#numpy.random.Generator.random&quot;&gt; &lt;code&gt;random&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;generated/numpy.random.generator.integers#numpy.random.Generator.integers&quot;&gt; &lt;code&gt;integers&lt;/code&gt; &lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="e9cccdf4596cb9bd6da09d86e9aec754328ad900" translate="yes" xml:space="preserve">
          <source>Uniforms (&lt;a href=&quot;generated/numpy.random.generator.random#numpy.random.Generator.random&quot;&gt;&lt;code&gt;random&lt;/code&gt;&lt;/a&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2697f04d1c34bc0fd003a5d4f2f248be3c9842cb" translate="yes" xml:space="preserve">
          <source>Union types</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d19a005048195442e1a0367112ec40ef36c8dd2" translate="yes" xml:space="preserve">
          <source>Unique, sorted union of the input arrays.</source>
          <target state="translated">Уникальный,отсортированный союз входных массивов.</target>
        </trans-unit>
        <trans-unit id="76a96316e226896e4f1438a10bfe2c7d74733b0a" translate="yes" xml:space="preserve">
          <source>Unit Conversion</source>
          <target state="translated">Преобразование единицы продукции</target>
        </trans-unit>
        <trans-unit id="2b379c9399e276f2dc8f9383decfb02923fa06dd" translate="yes" xml:space="preserve">
          <source>Unitary array(s). The first &lt;code&gt;a.ndim - 2&lt;/code&gt; dimensions have the same size as those of the input &lt;code&gt;a&lt;/code&gt;. The size of the last two dimensions depends on the value of &lt;code&gt;full_matrices&lt;/code&gt;. Only returned when &lt;code&gt;compute_uv&lt;/code&gt; is True.</source>
          <target state="translated">Унитарный массив (ы). Размер первого &lt;code&gt;a.ndim - 2&lt;/code&gt; совпадает с размером входного &lt;code&gt;a&lt;/code&gt; . Размер двух последних измерений зависит от значения &lt;code&gt;full_matrices&lt;/code&gt; . Возвращается, только если &lt;code&gt;compute_uv&lt;/code&gt; имеет значение True.</target>
        </trans-unit>
        <trans-unit id="89952e170b7f249d54c02c56dc948ea92d581887" translate="yes" xml:space="preserve">
          <source>Universal Functions</source>
          <target state="translated">Универсальные функции</target>
        </trans-unit>
        <trans-unit id="7d5959424165b0a7771ddfd877626852ebcf0b02" translate="yes" xml:space="preserve">
          <source>Universal function. A fast element-wise, &lt;a href=&quot;#term-vectorization&quot;&gt;vectorized&lt;/a&gt; array operation. Examples include &lt;code&gt;add&lt;/code&gt;, &lt;code&gt;sin&lt;/code&gt; and &lt;code&gt;logical_or&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c4ed03ac8db5e6ac9dfa92939a06553bcbad44ab" translate="yes" xml:space="preserve">
          <source>Universal functions</source>
          <target state="translated">Универсальные функции</target>
        </trans-unit>
        <trans-unit id="e3950ded82824788c1d59c1dc67f67776133fd02" translate="yes" xml:space="preserve">
          <source>Universal functions (&lt;code&gt;ufunc&lt;/code&gt;)</source>
          <target state="translated">Универсальные функции ( &lt;code&gt;ufunc&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="825ac503579fb05389d22b5b4afa49b44dc3e914" translate="yes" xml:space="preserve">
          <source>Universal functions (ufunc)</source>
          <target state="translated">Универсальные функции (ufunc)</target>
        </trans-unit>
        <trans-unit id="1c8ff35a75bf6e5497766666bbe2a77eb53892e4" translate="yes" xml:space="preserve">
          <source>Universal functions are callable objects that take</source>
          <target state="translated">Универсальные функции-это вызываемые объекты,которые принимают</target>
        </trans-unit>
        <trans-unit id="14ef4c614fdbba7fe91a08e7e1d79eb5845cd489" translate="yes" xml:space="preserve">
          <source>Universal functions can trip special floating-point status registers in your hardware (such as divide-by-zero). If available on your platform, these registers will be regularly checked during calculation. Error handling is controlled on a per-thread basis, and can be configured using the functions</source>
          <target state="translated">Универсальные функции могут отключать специальные регистры состояния с плавающей запятой в вашем оборудовании (например,разделение на ноль).Если они доступны на вашей платформе,то эти регистры будут регулярно проверяться во время вычислений.Управление обработкой ошибок осуществляется поточно и может быть сконфигурировано с помощью функций</target>
        </trans-unit>
        <trans-unit id="f2a6f922fe59febd69c7ec0550beca70f253abf6" translate="yes" xml:space="preserve">
          <source>Universal functions in NumPy are flexible enough to have mixed type signatures. Thus, for example, a universal function could be defined that works with floating-point and integer values. See &lt;a href=&quot;generated/numpy.ldexp#numpy.ldexp&quot;&gt;&lt;code&gt;ldexp&lt;/code&gt;&lt;/a&gt; for an example.</source>
          <target state="translated">Универсальные функции в NumPy достаточно гибки, чтобы иметь подписи смешанного типа. Так, например, можно определить универсальную функцию, которая работает с значениями с плавающей запятой и целыми числами. См. Пример &lt;a href=&quot;generated/numpy.ldexp#numpy.ldexp&quot;&gt; &lt;code&gt;ldexp&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="dc2928ef9066faa49b65eacee08cc9ff5b8df03a" translate="yes" xml:space="preserve">
          <source>Unlabeled tests like the ones above are run in the default &lt;code&gt;scipy.test()&lt;/code&gt; run. If you want to label your test as slow - and therefore reserved for a full &lt;code&gt;scipy.test(label='full')&lt;/code&gt; run, you can label it with a decorator:</source>
          <target state="translated">Непомеченные тесты, подобные приведенным выше, запускаются при &lt;code&gt;scipy.test()&lt;/code&gt; по умолчанию . Если вы хотите пометить свой тест как медленный и, следовательно, зарезервированный для полного &lt;code&gt;scipy.test(label='full')&lt;/code&gt; , вы можете пометить его с помощью декоратора:</target>
        </trans-unit>
        <trans-unit id="f80a919f246626907387dd0726bbe89b8b51b4df" translate="yes" xml:space="preserve">
          <source>Unless &lt;a href=&quot;numpy.char.chararray.copy#numpy.char.chararray.copy&quot;&gt;&lt;code&gt;copy&lt;/code&gt;&lt;/a&gt; is False and the other conditions for returning the input array are satisfied (see description for &lt;a href=&quot;numpy.char.chararray.copy#numpy.char.chararray.copy&quot;&gt;&lt;code&gt;copy&lt;/code&gt;&lt;/a&gt; input parameter), &lt;code&gt;arr_t&lt;/code&gt; is a new array of the same shape as the input array, with dtype, order given by &lt;a href=&quot;numpy.char.chararray.dtype#numpy.char.chararray.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;order&lt;/code&gt;.</source>
          <target state="translated">Если &lt;a href=&quot;numpy.char.chararray.copy#numpy.char.chararray.copy&quot;&gt; &lt;code&gt;copy&lt;/code&gt; не&lt;/a&gt; имеет значения False и не выполняются другие условия для возврата входного массива (см. Описание входного параметра &lt;a href=&quot;numpy.char.chararray.copy#numpy.char.chararray.copy&quot;&gt; &lt;code&gt;copy&lt;/code&gt; &lt;/a&gt; ), &lt;code&gt;arr_t&lt;/code&gt; - это новый массив той же формы, что и входной массив, с dtype, порядок, заданный &lt;a href=&quot;numpy.char.chararray.dtype#numpy.char.chararray.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt; , &lt;code&gt;order&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ef7dd27d4664eeedf99baaa7e0c49db6deaa478b" translate="yes" xml:space="preserve">
          <source>Unless &lt;a href=&quot;numpy.copy#numpy.copy&quot;&gt;&lt;code&gt;copy&lt;/code&gt;&lt;/a&gt; is False and the other conditions for returning the input array are satisfied (see description for &lt;a href=&quot;numpy.copy#numpy.copy&quot;&gt;&lt;code&gt;copy&lt;/code&gt;&lt;/a&gt; input parameter), &lt;code&gt;arr_t&lt;/code&gt; is a new array of the same shape as the input array, with dtype, order given by &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;order&lt;/code&gt;.</source>
          <target state="translated">Если &lt;a href=&quot;numpy.copy#numpy.copy&quot;&gt; &lt;code&gt;copy&lt;/code&gt; не&lt;/a&gt; имеет значения False и не выполняются другие условия для возврата входного массива (см. Описание входного параметра &lt;a href=&quot;numpy.copy#numpy.copy&quot;&gt; &lt;code&gt;copy&lt;/code&gt; &lt;/a&gt; ), &lt;code&gt;arr_t&lt;/code&gt; - это новый массив той же формы, что и входной массив, с dtype, порядок, заданный &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt; , &lt;code&gt;order&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b5fb1f8307f01c7e357482bf17ec2115ae4f2033" translate="yes" xml:space="preserve">
          <source>Unless &lt;a href=&quot;numpy.ma.copy#numpy.ma.copy&quot;&gt;&lt;code&gt;copy&lt;/code&gt;&lt;/a&gt; is False and the other conditions for returning the input array are satisfied (see description for &lt;a href=&quot;numpy.ma.copy#numpy.ma.copy&quot;&gt;&lt;code&gt;copy&lt;/code&gt;&lt;/a&gt; input parameter), &lt;code&gt;arr_t&lt;/code&gt; is a new array of the same shape as the input array, with dtype, order given by &lt;a href=&quot;numpy.ma.masked_array.dtype#numpy.ma.masked_array.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;order&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd72f00597798516e6971a2dbcb92a29bbbdaed9" translate="yes" xml:space="preserve">
          <source>Unless &lt;a href=&quot;numpy.ma.copy#numpy.ma.copy&quot;&gt;&lt;code&gt;copy&lt;/code&gt;&lt;/a&gt; is False and the other conditions for returning the input array are satisfied (see description for &lt;a href=&quot;numpy.ma.copy#numpy.ma.copy&quot;&gt;&lt;code&gt;copy&lt;/code&gt;&lt;/a&gt; input parameter), &lt;code&gt;arr_t&lt;/code&gt; is a new array of the same shape as the input array, with dtype, order given by &lt;a href=&quot;numpy.ma.maskedarray.dtype#numpy.ma.MaskedArray.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;order&lt;/code&gt;.</source>
          <target state="translated">Если &lt;a href=&quot;numpy.ma.copy#numpy.ma.copy&quot;&gt; &lt;code&gt;copy&lt;/code&gt; не&lt;/a&gt; имеет значения False и не выполняются другие условия для возврата входного массива (см. Описание входного параметра &lt;a href=&quot;numpy.ma.copy#numpy.ma.copy&quot;&gt; &lt;code&gt;copy&lt;/code&gt; &lt;/a&gt; ), &lt;code&gt;arr_t&lt;/code&gt; - это новый массив той же формы, что и входной массив, с dtype, порядок, заданный &lt;a href=&quot;numpy.ma.maskedarray.dtype#numpy.ma.MaskedArray.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt; , &lt;code&gt;order&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6e2517e50c2cd18f9fa374a65d4b11b6882475bf" translate="yes" xml:space="preserve">
          <source>Unless &lt;code&gt;refcheck&lt;/code&gt; is False:</source>
          <target state="translated">Если &lt;code&gt;refcheck&lt;/code&gt; не ложна :</target>
        </trans-unit>
        <trans-unit id="5c06c023a0677199fe16b8704d88475521f3247a" translate="yes" xml:space="preserve">
          <source>Unless NumPy is made aware of an issue with this, this function is scheduled for rapid removal without replacement.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b12a052540dd37bc0bf5e60cc41fc32cdcbd4cfa" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;numpy.equal#numpy.equal&quot;&gt;&lt;code&gt;numpy.equal&lt;/code&gt;&lt;/a&gt;, this comparison is performed by first stripping whitespace characters from the end of the string. This behavior is provided for backward-compatibility with numarray.</source>
          <target state="translated">В отличие от &lt;a href=&quot;numpy.equal#numpy.equal&quot;&gt; &lt;code&gt;numpy.equal&lt;/code&gt; &lt;/a&gt; , это сравнение выполняется путем удаления пробельных символов в конце строки. Такое поведение предусмотрено для обратной совместимости с numarray.</target>
        </trans-unit>
        <trans-unit id="6b2b2c64bbd5177dd4a58ffb6ba3be3f39244e9c" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;numpy.fft.fftfreq#numpy.fft.fftfreq&quot;&gt;&lt;code&gt;fftfreq&lt;/code&gt;&lt;/a&gt; (but like &lt;a href=&quot;https://docs.scipy.org/doc/scipy/reference/generated/scipy.fftpack.rfftfreq.html#scipy.fftpack.rfftfreq&quot;&gt;&lt;code&gt;scipy.fftpack.rfftfreq&lt;/code&gt;&lt;/a&gt;) the Nyquist frequency component is considered to be positive.</source>
          <target state="translated">В отличие от &lt;a href=&quot;numpy.fft.fftfreq#numpy.fft.fftfreq&quot;&gt; &lt;code&gt;fftfreq&lt;/code&gt; &lt;/a&gt; (но как &lt;a href=&quot;https://docs.scipy.org/doc/scipy/reference/generated/scipy.fftpack.rfftfreq.html#scipy.fftpack.rfftfreq&quot;&gt; &lt;code&gt;scipy.fftpack.rfftfreq&lt;/code&gt; &lt;/a&gt; ) частотная составляющая Найквиста считается положительной.</target>
        </trans-unit>
        <trans-unit id="5f3a2cd1365b2531abc2f011c55c5607d024f719" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;numpy.greater#numpy.greater&quot;&gt;&lt;code&gt;numpy.greater&lt;/code&gt;&lt;/a&gt;, this comparison is performed by first stripping whitespace characters from the end of the string. This behavior is provided for backward-compatibility with numarray.</source>
          <target state="translated">В отличие от &lt;a href=&quot;numpy.greater#numpy.greater&quot;&gt; &lt;code&gt;numpy.greater&lt;/code&gt; &lt;/a&gt; , это сравнение выполняется путем удаления пробельных символов в конце строки. Такое поведение предусмотрено для обратной совместимости с numarray.</target>
        </trans-unit>
        <trans-unit id="8db96ae1e185ea43483bbcf2e2a064fdf5d5ac53" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;numpy.greater_equal#numpy.greater_equal&quot;&gt;&lt;code&gt;numpy.greater_equal&lt;/code&gt;&lt;/a&gt;, this comparison is performed by first stripping whitespace characters from the end of the string. This behavior is provided for backward-compatibility with numarray.</source>
          <target state="translated">В отличие от &lt;a href=&quot;numpy.greater_equal#numpy.greater_equal&quot;&gt; &lt;code&gt;numpy.greater_equal&lt;/code&gt; &lt;/a&gt; , это сравнение выполняется, сначала удаляя пробельные символы из конца строки. Такое поведение предусмотрено для обратной совместимости с numarray.</target>
        </trans-unit>
        <trans-unit id="cc98934fa39c9d5a378edf27cd9d3fdf09aca64f" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;numpy.less_equal#numpy.less_equal&quot;&gt;&lt;code&gt;numpy.less_equal&lt;/code&gt;&lt;/a&gt;, this comparison is performed by first stripping whitespace characters from the end of the string. This behavior is provided for backward-compatibility with numarray.</source>
          <target state="translated">В отличие от &lt;a href=&quot;numpy.less_equal#numpy.less_equal&quot;&gt; &lt;code&gt;numpy.less_equal&lt;/code&gt; &lt;/a&gt; , это сравнение выполняется, сначала удаляя пробельные символы из конца строки. Такое поведение предусмотрено для обратной совместимости с numarray.</target>
        </trans-unit>
        <trans-unit id="13463cefef0c63fb378a22fb3869ee59d3559110" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;numpy.matrix#numpy.matrix&quot;&gt;&lt;code&gt;matrix&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#numpy.asmatrix&quot;&gt;&lt;code&gt;asmatrix&lt;/code&gt;&lt;/a&gt; does not make a copy if the input is already a matrix or an ndarray. Equivalent to &lt;code&gt;matrix(data, copy=False)&lt;/code&gt;.</source>
          <target state="translated">В отличие от &lt;a href=&quot;numpy.matrix#numpy.matrix&quot;&gt; &lt;code&gt;matrix&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#numpy.asmatrix&quot;&gt; &lt;code&gt;asmatrix&lt;/code&gt; &lt;/a&gt; не делает копию, если вход уже является матрицей или ndarray. Эквивалентен &lt;code&gt;matrix(data, copy=False)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c0d5bc239c5d20908848ae252443d0a4e4413dd3" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;numpy.matrix#numpy.matrix&quot;&gt;&lt;code&gt;matrix&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;numpy.asmatrix#numpy.asmatrix&quot;&gt;&lt;code&gt;asmatrix&lt;/code&gt;&lt;/a&gt; does not make a copy if the input is already a matrix or an ndarray. Equivalent to &lt;code&gt;matrix(data, copy=False)&lt;/code&gt;.</source>
          <target state="translated">В отличие от &lt;a href=&quot;numpy.matrix#numpy.matrix&quot;&gt; &lt;code&gt;matrix&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;numpy.asmatrix#numpy.asmatrix&quot;&gt; &lt;code&gt;asmatrix&lt;/code&gt; &lt;/a&gt; не делает копию, если вход уже является матрицей или ndarray. Эквивалентен &lt;code&gt;matrix(data, copy=False)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a5b1299452ddecaa69fc7626dc84ab62f7aec6df" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;numpy.not_equal#numpy.not_equal&quot;&gt;&lt;code&gt;numpy.not_equal&lt;/code&gt;&lt;/a&gt;, this comparison is performed by first stripping whitespace characters from the end of the string. This behavior is provided for backward-compatibility with numarray.</source>
          <target state="translated">В отличие от &lt;a href=&quot;numpy.not_equal#numpy.not_equal&quot;&gt; &lt;code&gt;numpy.not_equal&lt;/code&gt; &lt;/a&gt; , это сравнение выполняется путем первого удаления пробельных символов из конца строки. Такое поведение предусмотрено для обратной совместимости с numarray.</target>
        </trans-unit>
        <trans-unit id="1df4f0edb26736c54c37d1f3f53f3c4e05be97d2" translate="yes" xml:space="preserve">
          <source>Unlike MATLAB&amp;reg;, where anything on your path can be called immediately, with Python you need to first do an &amp;lsquo;import&amp;rsquo; statement to make functions in a particular file accessible.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd2a67552682e7936714b3e48fc7203a2e15901a" translate="yes" xml:space="preserve">
          <source>Unlike in many matrix languages, the product operator &lt;code&gt;*&lt;/code&gt; operates elementwise in NumPy arrays. The matrix product can be performed using the &lt;code&gt;@&lt;/code&gt; operator (in python &amp;gt;=3.5) or the &lt;code&gt;dot&lt;/code&gt; function or method:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="991d558a10f3fed386601ea572b9a25a236458aa" translate="yes" xml:space="preserve">
          <source>Unlike in the case of integer index arrays, in the boolean case, the result is a 1-D array containing all the elements in the indexed array corresponding to all the true elements in the boolean array. The elements in the indexed array are always iterated and returned in &lt;a href=&quot;../glossary#term-row-major&quot;&gt;row-major&lt;/a&gt; (C-style) order. The result is also identical to &lt;code&gt;y[np.nonzero(b)]&lt;/code&gt;. As with index arrays, what is returned is a copy of the data, not a view as one gets with slices.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b9e6d341e111d5abaa8c91d594d12353e24be13" translate="yes" xml:space="preserve">
          <source>Unlike lists and tuples, numpy arrays support multidimensional indexing for multidimensional arrays. That means that it is not necessary to separate each dimension&amp;rsquo;s index into its own set of square brackets.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="70d4d959a48f1152d15702553262318c5fb98806" translate="yes" xml:space="preserve">
          <source>Unlike multiplication, division, etc., the difference of two Chebyshev series is a Chebyshev series (without having to &amp;ldquo;reproject&amp;rdquo; the result onto the basis set) so subtraction, just like that of &amp;ldquo;standard&amp;rdquo; polynomials, is simply &amp;ldquo;component-wise.&amp;rdquo;</source>
          <target state="translated">В отличие от умножения, деления и т. Д., Разность двух рядов Чебышева является рядом Чебышева (без необходимости &amp;laquo;перепроецировать&amp;raquo; результат на базисный набор), поэтому вычитание, как и вычитание &amp;laquo;стандартных&amp;raquo; полиномов, просто &amp;laquo;покомпонентно&amp;raquo;. . &amp;raquo;</target>
        </trans-unit>
        <trans-unit id="e46cc304c2f214fabbfe81dd6c99872edb6df227" translate="yes" xml:space="preserve">
          <source>Unlike multiplication, division, etc., the difference of two Hermite series is a Hermite series (without having to &amp;ldquo;reproject&amp;rdquo; the result onto the basis set) so subtraction, just like that of &amp;ldquo;standard&amp;rdquo; polynomials, is simply &amp;ldquo;component-wise.&amp;rdquo;</source>
          <target state="translated">В отличие от умножения, деления и т. Д., Разница двух рядов Эрмита является рядом Эрмита (без необходимости &amp;laquo;перепроецировать&amp;raquo; результат на базисный набор), поэтому вычитание, как и вычитание &amp;laquo;стандартных&amp;raquo; многочленов, просто &amp;laquo;покомпонентно&amp;raquo;. . &amp;raquo;</target>
        </trans-unit>
        <trans-unit id="0beee9ca9d008b84130a4966827a4791db0f0fc1" translate="yes" xml:space="preserve">
          <source>Unlike multiplication, division, etc., the difference of two Laguerre series is a Laguerre series (without having to &amp;ldquo;reproject&amp;rdquo; the result onto the basis set) so subtraction, just like that of &amp;ldquo;standard&amp;rdquo; polynomials, is simply &amp;ldquo;component-wise.&amp;rdquo;</source>
          <target state="translated">В отличие от умножения, деления и т. Д., Разность двух рядов Лагерра является рядом Лагерра (без необходимости &amp;laquo;перепроецировать&amp;raquo; результат на базисный набор), поэтому вычитание, как и вычитание &amp;laquo;стандартных&amp;raquo; многочленов, просто &amp;laquo;покомпонентно&amp;raquo;. . &amp;raquo;</target>
        </trans-unit>
        <trans-unit id="853913b39ae1eac706caf9dd0fbf8022480e5898" translate="yes" xml:space="preserve">
          <source>Unlike multiplication, division, etc., the difference of two Legendre series is a Legendre series (without having to &amp;ldquo;reproject&amp;rdquo; the result onto the basis set) so subtraction, just like that of &amp;ldquo;standard&amp;rdquo; polynomials, is simply &amp;ldquo;component-wise.&amp;rdquo;</source>
          <target state="translated">В отличие от умножения, деления и т. Д., Разница двух рядов Лежандра является рядом Лежандра (без необходимости &amp;laquo;перепроецировать&amp;raquo; результат на базисный набор), поэтому вычитание, как и вычитание &amp;laquo;стандартных&amp;raquo; многочленов, осуществляется просто &amp;laquo;покомпонентно&amp;raquo;. . &amp;raquo;</target>
        </trans-unit>
        <trans-unit id="817c653b37e40c515ff2966447fe5fceb6d50c2b" translate="yes" xml:space="preserve">
          <source>Unlike multiplication, division, etc., the sum of two Chebyshev series is a Chebyshev series (without having to &amp;ldquo;reproject&amp;rdquo; the result onto the basis set) so addition, just like that of &amp;ldquo;standard&amp;rdquo; polynomials, is simply &amp;ldquo;component-wise.&amp;rdquo;</source>
          <target state="translated">В отличие от умножения, деления и т. Д., Сумма двух рядов Чебышева является рядом Чебышева (без необходимости &amp;laquo;перепроецировать&amp;raquo; результат на базисный набор), поэтому сложение, как и для &amp;laquo;стандартных&amp;raquo; полиномов, просто &amp;laquo;покомпонентно&amp;raquo;. . &amp;raquo;</target>
        </trans-unit>
        <trans-unit id="96e94bebc99e72aa93e0ba2b3e9d976f9a242788" translate="yes" xml:space="preserve">
          <source>Unlike multiplication, division, etc., the sum of two Hermite series is a Hermite series (without having to &amp;ldquo;reproject&amp;rdquo; the result onto the basis set) so addition, just like that of &amp;ldquo;standard&amp;rdquo; polynomials, is simply &amp;ldquo;component-wise.&amp;rdquo;</source>
          <target state="translated">В отличие от умножения, деления и т. Д., Сумма двух рядов Эрмита является рядом Эрмита (без необходимости &amp;laquo;перепроецировать&amp;raquo; результат на базисный набор), поэтому сложение, как и &amp;laquo;стандартных&amp;raquo; многочленов, просто &amp;laquo;покомпонентно&amp;raquo;. . &amp;raquo;</target>
        </trans-unit>
        <trans-unit id="a1bfae60ca127fe23c05d0fcb5e3af8c025e808e" translate="yes" xml:space="preserve">
          <source>Unlike multiplication, division, etc., the sum of two Laguerre series is a Laguerre series (without having to &amp;ldquo;reproject&amp;rdquo; the result onto the basis set) so addition, just like that of &amp;ldquo;standard&amp;rdquo; polynomials, is simply &amp;ldquo;component-wise.&amp;rdquo;</source>
          <target state="translated">В отличие от умножения, деления и т. Д., Сумма двух рядов Лагерра является рядом Лагерра (без необходимости &amp;laquo;перепроецировать&amp;raquo; результат на базисный набор), поэтому сложение, как и сложение &amp;laquo;стандартных&amp;raquo; полиномов, просто &amp;laquo;покомпонентно&amp;raquo;. . &amp;raquo;</target>
        </trans-unit>
        <trans-unit id="479fccdc37cae736330d681081d02fd22d2b4c05" translate="yes" xml:space="preserve">
          <source>Unlike multiplication, division, etc., the sum of two Legendre series is a Legendre series (without having to &amp;ldquo;reproject&amp;rdquo; the result onto the basis set) so addition, just like that of &amp;ldquo;standard&amp;rdquo; polynomials, is simply &amp;ldquo;component-wise.&amp;rdquo;</source>
          <target state="translated">В отличие от умножения, деления и т. Д., Сумма двух рядов Лежандра является рядом Лежандра (без необходимости &amp;laquo;перепроецировать&amp;raquo; результат на базисный набор), поэтому сложение, как и сложение &amp;laquo;стандартных&amp;raquo; многочленов, просто &amp;laquo;покомпонентно&amp;raquo;. . &amp;raquo;</target>
        </trans-unit>
        <trans-unit id="c37836d2f2fa6578d699e351ca0672a2d96cc650" translate="yes" xml:space="preserve">
          <source>Unlike other numpy scalars, structured scalars are mutable and act like views into the original array, such that modifying the scalar will modify the original array. Structured scalars also support access and assignment by field name:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="191384b28da289c339b69142c174b4bdb8ca4902" translate="yes" xml:space="preserve">
          <source>Unlike some of the references (such as array and mask indices) assignments are always made to the original data in the array (indeed, nothing else would make sense!). Note though, that some actions may not work as one may naively expect. This particular example is often surprising to people:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6138c52b3d14f1f06df9ad9cd32f8b7c13aad36f" translate="yes" xml:space="preserve">
          <source>Unlike the built-in &lt;a href=&quot;https://docs.python.org/dev/library/math.html#math.isclose&quot;&gt;&lt;code&gt;math.isclose&lt;/code&gt;&lt;/a&gt;, the above equation is not symmetric in &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; &amp;ndash; it assumes &lt;code&gt;b&lt;/code&gt; is the reference value &amp;ndash; so that &lt;code&gt;isclose(a, b)&lt;/code&gt; might be different from &lt;code&gt;isclose(b, a)&lt;/code&gt;. Furthermore, the default value of atol is not zero, and is used to determine what small values should be considered close to zero. The default value is appropriate for expected values of order unity: if the expected values are significantly smaller than one, it can result in false positives. &lt;code&gt;atol&lt;/code&gt; should be carefully selected for the use case at hand. A zero value for &lt;code&gt;atol&lt;/code&gt; will result in &lt;code&gt;False&lt;/code&gt; if either &lt;code&gt;a&lt;/code&gt; or &lt;code&gt;b&lt;/code&gt; is zero.</source>
          <target state="translated">В отличие от встроенного &lt;a href=&quot;https://docs.python.org/dev/library/math.html#math.isclose&quot;&gt; &lt;code&gt;math.isclose&lt;/code&gt; &lt;/a&gt; , приведенное выше уравнение не является симметричным по &lt;code&gt;a&lt;/code&gt; и &lt;code&gt;b&lt;/code&gt; - оно предполагает, что &lt;code&gt;b&lt;/code&gt; является эталонным значением, поэтому &lt;code&gt;isclose(a, b)&lt;/code&gt; может отличаться от &lt;code&gt;isclose(b, a)&lt;/code&gt; . Кроме того, значение atol по умолчанию не равно нулю и используется для определения того, какие небольшие значения следует считать близкими к нулю. Значение по умолчанию подходит для ожидаемых значений порядка единицы: если ожидаемые значения значительно меньше единицы, это может привести к ложным срабатываниям. &lt;code&gt;atol&lt;/code&gt; следует тщательно выбирать для конкретного случая использования. Нулевое значение &lt;code&gt;atol&lt;/code&gt; приведет к &lt;code&gt;False&lt;/code&gt; если либо &lt;code&gt;a&lt;/code&gt; или &lt;code&gt;b&lt;/code&gt; равно нулю.</target>
        </trans-unit>
        <trans-unit id="b9b43bc2298a20c8156a6023d94ab148e7869ea1" translate="yes" xml:space="preserve">
          <source>Unlike the free function &lt;a href=&quot;numpy.reshape#numpy.reshape&quot;&gt;&lt;code&gt;numpy.reshape&lt;/code&gt;&lt;/a&gt;, this method on &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt; allows the elements of the shape parameter to be passed in as separate arguments. For example, &lt;code&gt;a.reshape(10, 11)&lt;/code&gt; is equivalent to &lt;code&gt;a.reshape((10, 11))&lt;/code&gt;.</source>
          <target state="translated">В отличие от бесплатной функции &lt;a href=&quot;numpy.reshape#numpy.reshape&quot;&gt; &lt;code&gt;numpy.reshape&lt;/code&gt; &lt;/a&gt; , этот метод в &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt; позволяет передавать элементы параметра формы как отдельные аргументы. Например, &lt;code&gt;a.reshape(10, 11)&lt;/code&gt; эквивалентно &lt;code&gt;a.reshape((10, 11))&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c055ec1da31f5b3a36529d3d52329cd0cef8c5de" translate="yes" xml:space="preserve">
          <source>Unlike the free function &lt;a href=&quot;numpy.reshape#numpy.reshape&quot;&gt;&lt;code&gt;numpy.reshape&lt;/code&gt;&lt;/a&gt;, this method on &lt;code&gt;ndarray&lt;/code&gt; allows the elements of the shape parameter to be passed in as separate arguments. For example, &lt;code&gt;a.reshape(10, 11)&lt;/code&gt; is equivalent to &lt;code&gt;a.reshape((10, 11))&lt;/code&gt;.</source>
          <target state="translated">В отличие от бесплатной функции &lt;a href=&quot;numpy.reshape#numpy.reshape&quot;&gt; &lt;code&gt;numpy.reshape&lt;/code&gt; &lt;/a&gt; , этот метод в &lt;code&gt;ndarray&lt;/code&gt; позволяет передавать элементы параметра формы как отдельные аргументы. Например, &lt;code&gt;a.reshape(10, 11)&lt;/code&gt; эквивалентно &lt;code&gt;a.reshape((10, 11))&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0206a9a6a08e980ce9de3768f0db78bc718405ea" translate="yes" xml:space="preserve">
          <source>Unlike the standard numpy comparison operators, the ones in the &lt;code&gt;char&lt;/code&gt; module strip trailing whitespace characters before performing the comparison.</source>
          <target state="translated">В отличие от стандартных операторов сравнения numpy, операторы в модуле &lt;code&gt;char&lt;/code&gt; удаляют завершающие пробельные символы перед выполнением сравнения.</target>
        </trans-unit>
        <trans-unit id="7fbacb4b6a81b741ccf818cdd058fa9d9f52d43b" translate="yes" xml:space="preserve">
          <source>Unmasking an entry</source>
          <target state="translated">Распаковка записи</target>
        </trans-unit>
        <trans-unit id="c37a5ee094534c733a693e498e6b83c12096d6e0" translate="yes" xml:space="preserve">
          <source>Unmasking an entry by direct assignment will silently fail if the masked array has a &lt;em&gt;hard&lt;/em&gt; mask, as shown by the &lt;code&gt;hardmask&lt;/code&gt; attribute. This feature was introduced to prevent overwriting the mask. To force the unmasking of an entry where the array has a hard mask, the mask must first to be softened using the &lt;a href=&quot;generated/numpy.ma.soften_mask#numpy.ma.soften_mask&quot;&gt;&lt;code&gt;soften_mask&lt;/code&gt;&lt;/a&gt; method before the allocation. It can be re-hardened with &lt;a href=&quot;generated/numpy.ma.harden_mask#numpy.ma.harden_mask&quot;&gt;&lt;code&gt;harden_mask&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">Разоблачение записи по прямому назначению будет молча терпеть неудачу , если маскируются массив имеет &lt;em&gt;жесткую&lt;/em&gt; маску, как показано &lt;code&gt;hardmask&lt;/code&gt; атрибут. Эта функция была введена для предотвращения перезаписи маски. Чтобы принудительно демаскировать запись, в которой массив имеет жесткую маску, маску нужно сначала смягчить с &lt;a href=&quot;generated/numpy.ma.soften_mask#numpy.ma.soften_mask&quot;&gt; &lt;code&gt;soften_mask&lt;/code&gt; &lt;/a&gt; метода softten_mask перед выделением. Его можно &lt;a href=&quot;generated/numpy.ma.harden_mask#numpy.ma.harden_mask&quot;&gt; &lt;code&gt;harden_mask&lt;/code&gt; &lt;/a&gt; с помощью harden_mask :</target>
        </trans-unit>
        <trans-unit id="5724dd60c593622fc16f28573a8be39237c1817b" translate="yes" xml:space="preserve">
          <source>Unmodified core dimensions that share the same name must have the same size. Each dimension name typically corresponds to one level of looping in the elementary function&amp;rsquo;s implementation.</source>
          <target state="translated">Неизмененные основные измерения с одинаковым именем должны иметь одинаковый размер. Каждое имя измерения обычно соответствует одному уровню цикла в реализации элементарной функции.</target>
        </trans-unit>
        <trans-unit id="0c8c8df9f7c1cb71b2c99863e55f28b2342c49c8" translate="yes" xml:space="preserve">
          <source>Unpacks elements of a uint8 array into a binary-valued output array.</source>
          <target state="translated">Распаковывает элементы массива uint8 в двоичный выходной массив.</target>
        </trans-unit>
        <trans-unit id="cfb0e26f84a72aa991cbd86d2a8e70f9268c36da" translate="yes" xml:space="preserve">
          <source>Unpickling while loading requires explicit opt-in</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c2316b90ad07a17bab89992c697827520a7c1a76" translate="yes" xml:space="preserve">
          <source>Unsafe int casting of the num attribute in &lt;code&gt;linspace&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b27e09825b38c1619e31484868bfeb48e96d8d2" translate="yes" xml:space="preserve">
          <source>Unsigned integer</source>
          <target state="translated">беззнаковое целое число</target>
        </trans-unit>
        <trans-unit id="19201d9c175004fe2d2c285a14b33dc2f3c58964" translate="yes" xml:space="preserve">
          <source>Unsigned integer (0 to 18446744073709551615)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d614ab4b08ea51c529ca2afd42bd5cb8f14039b7" translate="yes" xml:space="preserve">
          <source>Unsigned integer (0 to 255)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ece1b13212dbdde6f6979b0eb6cfffcea163e303" translate="yes" xml:space="preserve">
          <source>Unsigned integer (0 to 4294967295)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5280260c5f39b844aa889ca5265bd63ac321070f" translate="yes" xml:space="preserve">
          <source>Unsigned integer (0 to 65535)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="432373371510943ee2651ebf21148b86384d0a29" translate="yes" xml:space="preserve">
          <source>Unsigned integers:</source>
          <target state="translated">Беззнаковые целые числа:</target>
        </trans-unit>
        <trans-unit id="c824dd22d12bde4feee6277b067eb0b05fa4fdf1" translate="yes" xml:space="preserve">
          <source>Unsigned versions of the integers can be defined by pre-pending a &amp;lsquo;u&amp;rsquo; to the front of the integer name.</source>
          <target state="translated">Беззнаковые версии целых чисел можно определить, добавив &amp;laquo;u&amp;raquo; перед именем целого числа.</target>
        </trans-unit>
        <trans-unit id="3b4a1ed161e3d5d468bc7819a4a4469e69fb390c" translate="yes" xml:space="preserve">
          <source>Unstructured array or dtype to convert.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8443c9cc12807ec6c811788bbce2592aaf619083" translate="yes" xml:space="preserve">
          <source>Unstructured array with one more dimension.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd4f4dc80803ac1f52848ab12f25d8e2d5b8e16f" translate="yes" xml:space="preserve">
          <source>Until Python 3.5 the only disadvantage of using the array type was that you had to use &lt;code&gt;dot&lt;/code&gt; instead of &lt;code&gt;*&lt;/code&gt; to multiply (reduce) two tensors (scalar product, matrix vector multiplication etc.). Since Python 3.5 you can use the matrix multiplication &lt;code&gt;@&lt;/code&gt; operator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="91aa49f62879d325c6707e96a59652eaa942e8ca" translate="yes" xml:space="preserve">
          <source>Until the 1.15 release, NumPy used the &lt;a href=&quot;https://nose.readthedocs.io/en/latest/&quot;&gt;nose&lt;/a&gt; testing framework, it now uses the &lt;a href=&quot;https://pytest.readthedocs.io&quot;&gt;pytest&lt;/a&gt; framework. The older framework is still maintained in order to support downstream projects that use the old numpy framework, but all tests for NumPy should use pytest.</source>
          <target state="translated">До выпуска 1.15 NumPy использовал среду тестирования &lt;a href=&quot;https://nose.readthedocs.io/en/latest/&quot;&gt;носа&lt;/a&gt; , теперь она использует &lt;a href=&quot;https://pytest.readthedocs.io&quot;&gt;среду pytest&lt;/a&gt; . Старая структура по-прежнему поддерживается для поддержки последующих проектов, использующих старую структуру numpy, но все тесты для NumPy должны использовать pytest.</target>
        </trans-unit>
        <trans-unit id="f13be7738e1389f72c0f88aa84d17719f746bf4a" translate="yes" xml:space="preserve">
          <source>Unused.</source>
          <target state="translated">Unused.</target>
        </trans-unit>
        <trans-unit id="52bd5ee224646394816a409132afdc6f181c7d8b" translate="yes" xml:space="preserve">
          <source>Unwelcome sexual attention.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="91235b6cec5e2bdecb806fae5c6f1c673c46dd54" translate="yes" xml:space="preserve">
          <source>Unwrap by changing deltas between values to 2*pi complement.</source>
          <target state="translated">Разверните,изменив дельты между значениями на 2*pi дополнения.</target>
        </trans-unit>
        <trans-unit id="cba2ade8e0d37d0f36a249f716f7633b555a4616" translate="yes" xml:space="preserve">
          <source>Unwrap radian phase &lt;code&gt;p&lt;/code&gt; by changing absolute jumps greater than &lt;code&gt;discont&lt;/code&gt; to their 2*pi complement along the given axis.</source>
          <target state="translated">&lt;code&gt;discont&lt;/code&gt; фазу &lt;code&gt;p&lt;/code&gt; , изменив абсолютные скачки больше, чем discont, на их 2 * pi-дополнение вдоль данной оси.</target>
        </trans-unit>
        <trans-unit id="31f87bfbdb61e41f06f9d6ba5c2c33b85dec73cd" translate="yes" xml:space="preserve">
          <source>Upcasting:</source>
          <target state="translated">Upcasting:</target>
        </trans-unit>
        <trans-unit id="579edc70cbe349fcc3048fa42d7c965a563d10ae" translate="yes" xml:space="preserve">
          <source>Update PyPI</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a305b240bddfefe147af5326421c8f0107898199" translate="yes" xml:space="preserve">
          <source>Update Release documentation</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a858dc159ecba3062c1406c8e0fb587c83eace91" translate="yes" xml:space="preserve">
          <source>Update policy documents such as this one.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="676d87bea990c4c73ff4081f6b93aae5ebcc7dac" translate="yes" xml:space="preserve">
          <source>Update scipy.org</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64e81e08ab40d294f4651a8208d4e909d5156cbf" translate="yes" xml:space="preserve">
          <source>Update the Milestones in Trac.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8117487cd3d843fb21b5965b5f6cf86d9fd9d8a6" translate="yes" xml:space="preserve">
          <source>Update the release notes with a Highlights section. Mention some of the following:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd25c09dc3e898187644d607cbbc12c4edc2554e" translate="yes" xml:space="preserve">
          <source>Update the release status and create a release &amp;ldquo;tag&amp;rdquo;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1db22e1acc193e90fbde99ab0d68584a24cec01a" translate="yes" xml:space="preserve">
          <source>Update the version of the master branch</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="777088119e41bc0469a64ccb283496abe08bc95e" translate="yes" xml:space="preserve">
          <source>Updated version of PyArray_Correlate, which uses the usual definition of correlation for 1d arrays. The correlation is computed at each output point by multiplying &lt;em&gt;op1&lt;/em&gt; by a shifted version of &lt;em&gt;op2&lt;/em&gt; and summing the result. As a result of the shift, needed values outside of the defined range of &lt;em&gt;op1&lt;/em&gt; and &lt;em&gt;op2&lt;/em&gt; are interpreted as zero. The mode determines how many shifts to return: 0 - return only shifts that did not need to assume zero- values; 1 - return an object that is the same size as &lt;em&gt;op1&lt;/em&gt;, 2 - return all possible shifts (any overlap at all is accepted).</source>
          <target state="translated">Обновленная версия PyArray_Correlate, в которой используется обычное определение корреляции для одномерных массивов. Корреляция вычисляется в каждой выходной точке путем умножения &lt;em&gt;op1&lt;/em&gt; на сдвинутую версию &lt;em&gt;op2&lt;/em&gt; и суммирования результата. В результате сдвига необходимые значения за пределами определенного диапазона &lt;em&gt;op1&lt;/em&gt; и &lt;em&gt;op2&lt;/em&gt; интерпретируются как ноль. Режим определяет, сколько сдвигов нужно вернуть: 0 - возвращать только те сдвиги, для которых не нужно было принимать нулевые значения; 1 - вернуть объект того же размера, что и &lt;em&gt;op1&lt;/em&gt; , 2 - вернуть все возможные сдвиги (допускается любое перекрытие).</target>
        </trans-unit>
        <trans-unit id="a7409084cf2605b5cad89ac1878143241b496ed1" translate="yes" xml:space="preserve">
          <source>Updating the code</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ab89ee68187f5c809160685dea5430718e73ea0" translate="yes" xml:space="preserve">
          <source>Upload &lt;code&gt;doc/changelog/1.14.5-changelog.rst&lt;/code&gt; as a binary file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e8242899ac44525eea3639fc9196319bcd5798e1" translate="yes" xml:space="preserve">
          <source>Upload &lt;code&gt;release/README.rst&lt;/code&gt; as a binary file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4be4f20f37deddb1b1a33a72c43f77bfa0490a76" translate="yes" xml:space="preserve">
          <source>Upload &lt;code&gt;release/installers/numpy-1.14.5.tar.gz&lt;/code&gt; as a binary file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c5f92deadaf10f46166261ad542bc8986cab5d64" translate="yes" xml:space="preserve">
          <source>Upload &lt;code&gt;release/installers/numpy-1.14.5.zip&lt;/code&gt; as a binary file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="feca53bac4346b96bf1a7a8af5a58f9b95162f3b" translate="yes" xml:space="preserve">
          <source>Upload documents to numpy.org</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8bc2fac0bfff4c1c9d6c6f5a22fc6d38d8b5119c" translate="yes" xml:space="preserve">
          <source>Upload files to github</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="37ea156fa200c4b1e62bfc88ad83c78600949638" translate="yes" xml:space="preserve">
          <source>Upload to PyPI</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c16ab259dc55f6326fdf3044018a5aed36c63fd1" translate="yes" xml:space="preserve">
          <source>Upload to PyPI using &lt;code&gt;twine&lt;/code&gt;. A recent version of &lt;code&gt;twine&lt;/code&gt; of is needed after recent PyPI changes, version &lt;code&gt;1.11.0&lt;/code&gt; was used here.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6565e74e2ff5bcf02b09c60c49c14fcfab1feb84" translate="yes" xml:space="preserve">
          <source>Uploading to PyPI</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="80d1841e63317d86d0b2bbae07f2e08dc59ff7f9" translate="yes" xml:space="preserve">
          <source>Upper boundary of the output interval. All values generated will be less than high. The default value is 1.0.</source>
          <target state="translated">Верхняя граница выходного интервала.Все генерируемые значения будут меньше,чем высокие.Значение по умолчанию 1.0.</target>
        </trans-unit>
        <trans-unit id="94608c7ff5f4700d78cab2cf3285f4a9e6dc1615" translate="yes" xml:space="preserve">
          <source>Upper boundary of the output interval. All values generated will be less than or equal to high. The default value is 1.0.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="52be5864b9af229753de85f916fa14a1fa97d3a1" translate="yes" xml:space="preserve">
          <source>Upper limit, must be larger than &lt;code&gt;left&lt;/code&gt;.</source>
          <target state="translated">Верхний предел должен быть больше &lt;code&gt;left&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="528933f6438e2665073f1a6a0a370889bd9e0bae" translate="yes" xml:space="preserve">
          <source>Upper or lower-triangular Cholesky factor of &lt;code&gt;a&lt;/code&gt;. Returns a matrix object if &lt;code&gt;a&lt;/code&gt; is a matrix object.</source>
          <target state="translated">Верхний или нижнетреугольный фактор Холецкого &lt;code&gt;a&lt;/code&gt; . Возвращает объект матрицы , если является объектом матрицы. &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="57bb98258946012ee6623d2627640ef4f5f0bbc8" translate="yes" xml:space="preserve">
          <source>Upper triangle of an array.</source>
          <target state="translated">Верхний треугольник массива.</target>
        </trans-unit>
        <trans-unit id="0bb18642b70b9f8a9c12ccf39487328f306b8e19" translate="yes" xml:space="preserve">
          <source>Usage</source>
          <target state="translated">Usage</target>
        </trans-unit>
        <trans-unit id="a6ddf950ead3f5a277ec641c8bb4408b4523e874" translate="yes" xml:space="preserve">
          <source>Usage of ATLAS and other accelerated libraries in NumPy can be disabled via:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="861a0e430ffac5e4ae6e11b7a947f2c32d388cf4" translate="yes" xml:space="preserve">
          <source>Usage:</source>
          <target state="translated">Usage:</target>
        </trans-unit>
        <trans-unit id="f8422a8af0050351fb69661fa171b15f26430c90" translate="yes" xml:space="preserve">
          <source>Use 4-space indents and no tabs at all.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a4f4f55257b83792366b61f4d5627bfeafb83aa3" translate="yes" xml:space="preserve">
          <source>Use 64-bit integer size on 64-bit platforms in fallback lapack_lite</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a15df8cc43a52230464924d2366701940520ece7" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;#numpy.inf&quot;&gt;&lt;code&gt;inf&lt;/code&gt;&lt;/a&gt; because &lt;a href=&quot;#numpy.Inf&quot;&gt;&lt;code&gt;Inf&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#numpy.Infinity&quot;&gt;&lt;code&gt;Infinity&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#numpy.PINF&quot;&gt;&lt;code&gt;PINF&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#numpy.infty&quot;&gt;&lt;code&gt;infty&lt;/code&gt;&lt;/a&gt; are aliases for &lt;a href=&quot;#numpy.inf&quot;&gt;&lt;code&gt;inf&lt;/code&gt;&lt;/a&gt;. For more details, see &lt;a href=&quot;#numpy.inf&quot;&gt;&lt;code&gt;inf&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Используйте &lt;a href=&quot;#numpy.inf&quot;&gt; &lt;code&gt;inf&lt;/code&gt; ,&lt;/a&gt; потому что &lt;a href=&quot;#numpy.Inf&quot;&gt; &lt;code&gt;Inf&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#numpy.Infinity&quot;&gt; &lt;code&gt;Infinity&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#numpy.PINF&quot;&gt; &lt;code&gt;PINF&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;#numpy.infty&quot;&gt; &lt;code&gt;infty&lt;/code&gt; &lt;/a&gt; являются псевдонимами для &lt;a href=&quot;#numpy.inf&quot;&gt; &lt;code&gt;inf&lt;/code&gt; &lt;/a&gt; . Подробнее см. &lt;a href=&quot;#numpy.inf&quot;&gt; &lt;code&gt;inf&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6250a8c021e0b5f57d8def96501e9671eb570fb3" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;bit_generators/generated/numpy.random.seedsequence.spawn#numpy.random.SeedSequence.spawn&quot;&gt;&lt;code&gt;SeedSequence.spawn&lt;/code&gt;&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="315e845b90149a11b36b35f1bf0bf7c4eadadf53" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;bit_generators/generated/numpy.random.seedsequence.spawn#numpy.random.SeedSequence.spawn&quot;&gt;&lt;code&gt;spawn&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">Использовать &lt;a href=&quot;bit_generators/generated/numpy.random.seedsequence.spawn#numpy.random.SeedSequence.spawn&quot;&gt; &lt;code&gt;spawn&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="6cd23ceb7d31c81e1ae51bfa02cfeb8d16da6862" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;https://github.com/hawkowl/towncrier&quot;&gt;towncrier&lt;/a&gt; to build the release note and commit the changes. This will remove all the fragments from &lt;code&gt;doc/release/upcoming_changes&lt;/code&gt; and add &lt;code&gt;doc/release/&amp;lt;version&amp;gt;-note.rst&lt;/code&gt;. Note that currently towncrier must be installed from its master branch as the last release (19.2.0) is outdated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="239d871fd4cf571322892166220cc9bdd722de95" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;numpy.printoptions#numpy.printoptions&quot;&gt;&lt;code&gt;printoptions&lt;/code&gt;&lt;/a&gt; as a context manager to set the values temporarily.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f81e110951d1c31f755b7eda89bda400f45185fe" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;numpy.testing.assert_allclose#numpy.testing.assert_allclose&quot;&gt;&lt;code&gt;assert_allclose&lt;/code&gt;&lt;/a&gt; or one of the nulp (number of floating point values) functions for these cases instead:</source>
          <target state="translated">&lt;a href=&quot;numpy.testing.assert_allclose#numpy.testing.assert_allclose&quot;&gt; &lt;code&gt;assert_allclose&lt;/code&gt; &lt;/a&gt; используйте assert_allclose или одну из функций nulp (количество значений с плавающей запятой) для этих случаев:</target>
        </trans-unit>
        <trans-unit id="c2c3133adfff844d3d7390f3b12e049c01cfbf85" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;*italics*&lt;/code&gt;, &lt;code&gt;**bold**&lt;/code&gt; and &lt;code&gt;``monospace``&lt;/code&gt; if needed in any explanations (but not for variable names and doctest code or multi-line code). Variable, module, function, and class names should be written between single back-ticks (&lt;code&gt;`numpy`&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f96b961e5f74e075163f17783fa068cb28fd7dac" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;Py_BEGIN_ALLOW_THREADS .. Py_END_ALLOW_THREADS&lt;/code&gt; block around the call to Fortran/C function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="279c8e9cb261d8451ee87221b2c4c3c0acff77e2" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;atleast1d&lt;/code&gt; explicitly if this behavior is deliberate.</source>
          <target state="translated">&lt;code&gt;atleast1d&lt;/code&gt; используйте atleast1d, если такое поведение является преднамеренным.</target>
        </trans-unit>
        <trans-unit id="1f3c1a16eb9a2500b8452a8a5360fe793c9d0e80" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;integers(0, np.iinfo(np.int_).max,&lt;/code&gt;&lt;code&gt;endpoint=False)&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9990e788a91877bc1314e512b42f5fa96b72afa8" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;intent(callback)&lt;/code&gt; in situations where a Fortran/C code assumes that a user implements a function with given prototype and links it to an executable. Don&amp;rsquo;t use &lt;code&gt;intent(callback)&lt;/code&gt; if function appears in the argument list of a Fortran routine.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c8f354d8129891e4371211f7e2b02c3e86182e68" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;np.rec.fromrecords&lt;/code&gt;.</source>
          <target state="translated">Используйте &lt;code&gt;np.rec.fromrecords&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7b891c3328df6ed66c13f42757acead75f849207" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;transpose(a, argsort(axes))&lt;/code&gt; to invert the transposition of tensors when using the &lt;code&gt;axes&lt;/code&gt; keyword argument.</source>
          <target state="translated">Используйте &lt;code&gt;transpose(a, argsort(axes))&lt;/code&gt; чтобы инвертировать транспонирование тензоров при использовании аргумента ключевого слова &lt;code&gt;axes&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="464b9132a697ad83a17ca6141a5f052f243225bc" translate="yes" xml:space="preserve">
          <source>Use AVX512 intrinsic to implement &lt;code&gt;np.exp&lt;/code&gt; when input is &lt;code&gt;np.float64&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="54252b83acef1c2d4145831c1849100189007324" translate="yes" xml:space="preserve">
          <source>Use C99 (that is, the standard defined by ISO/IEC 9899:1999).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="711cfaf9a47519e9f223142a373928a92e01f581" translate="yes" xml:space="preserve">
          <source>Use C99 complex functions when available</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="98bf81203a370aca52162542f86441968d5a857b" translate="yes" xml:space="preserve">
          <source>Use a code checker:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e79cdecbdf930a5fc02d963ddb3cee0b341e1836" translate="yes" xml:space="preserve">
          <source>Use an index array to construct a new array from a set of choices.</source>
          <target state="translated">Используйте индексный массив для построения нового массива из набора вариантов.</target>
        </trans-unit>
        <trans-unit id="b449716c39e8e2ad1701598e0a781904fd930dad" translate="yes" xml:space="preserve">
          <source>Use boolean indexing to select all rows adding up to an even number. At the same time columns 0 and 2 should be selected with an advanced integer index. Using the &lt;a href=&quot;generated/numpy.ix_#numpy.ix_&quot;&gt;&lt;code&gt;ix_&lt;/code&gt;&lt;/a&gt; function this can be done with:</source>
          <target state="translated">Используйте логическое индексирование, чтобы выбрать все строки с получением четного числа. В то же время столбцы 0 и 2 следует выбирать с расширенным целочисленным индексом. Используя функцию &lt;a href=&quot;generated/numpy.ix_#numpy.ix_&quot;&gt; &lt;code&gt;ix_&lt;/code&gt; ,&lt;/a&gt; это можно сделать с помощью:</target>
        </trans-unit>
        <trans-unit id="8f82174ebfd083d8637822ce00a0c4c91588113b" translate="yes" xml:space="preserve">
          <source>Use frompyfunc to add broadcasting to the Python function &lt;code&gt;oct&lt;/code&gt;:</source>
          <target state="translated">Используйте frompyfunc, чтобы добавить трансляцию к функции Python &lt;code&gt;oct&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="1985c7d495449d5cb406d70622b9f8f51933acf4" translate="yes" xml:space="preserve">
          <source>Use integers()</source>
          <target state="translated">Использовать целые числа()</target>
        </trans-unit>
        <trans-unit id="dc8e632ae2c46f77a697535ec370bf0774d7d3a3" translate="yes" xml:space="preserve">
          <source>Use it inside source generating function to ensure that setup distribution instance has been initialized.</source>
          <target state="translated">Используйте его внутри функции генерации исходных текстов,чтобы убедиться,что экземпляр дистрибутива установки инициализирован.</target>
        </trans-unit>
        <trans-unit id="2ee4c011b47d55b7bfff5ce2a411098048a912df" translate="yes" xml:space="preserve">
          <source>Use numpy data types instead of strings (&lt;code&gt;np.uint8&lt;/code&gt; instead of &lt;code&gt;&quot;uint8&quot;&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2623e95742f95738b81e96ff23790e2857ea53b8" translate="yes" xml:space="preserve">
          <source>Use of Special Libraries</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="71894ec37f432f11f7de9a5b9b593a7cdf8ac0f3" translate="yes" xml:space="preserve">
          <source>Use of internal buffers</source>
          <target state="translated">Использование внутренних буферов</target>
        </trans-unit>
        <trans-unit id="19e9181ca40527ae40c5f3d764f8d2f436e1e1db" translate="yes" xml:space="preserve">
          <source>Use of special library functions (e.g., random)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="375ee90511f8800725237c9c32010dd6bfc434d9" translate="yes" xml:space="preserve">
          <source>Use one of the two predefined instances &lt;code&gt;index_exp&lt;/code&gt; or &lt;a href=&quot;#numpy.s_&quot;&gt;&lt;code&gt;s_&lt;/code&gt;&lt;/a&gt; rather than directly using &lt;code&gt;IndexExpression&lt;/code&gt;.</source>
          <target state="translated">Используйте один из двух предопределенных экземпляров &lt;code&gt;index_exp&lt;/code&gt; или &lt;a href=&quot;#numpy.s_&quot;&gt; &lt;code&gt;s_&lt;/code&gt; &lt;/a&gt; вместо прямого использования &lt;code&gt;IndexExpression&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4baff69e242f9bdf1683765ea1f2508b120d6009" translate="yes" xml:space="preserve">
          <source>Use statements:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f399bcf7c74a9a9e383f645bfc3f3a24ebea505e" translate="yes" xml:space="preserve">
          <source>Use the &lt;code&gt;--f2cmap&lt;/code&gt; command-line option to pass the file name to F2PY. By default, F2PY assumes file name is &lt;code&gt;.f2py_f2cmap&lt;/code&gt; in the current working directory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="563d6ccf41351782f370e56a915df0b3956e26f4" translate="yes" xml:space="preserve">
          <source>Use the &lt;code&gt;buf&lt;/code&gt; keyword.</source>
          <target state="translated">Используйте ключевое слово &lt;code&gt;buf&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6e0dab0efbd30d7f80d43f09e327292cfe0afdb8" translate="yes" xml:space="preserve">
          <source>Use the &lt;code&gt;endpoint&lt;/code&gt; kwarg to adjust the inclusion or exclution of the &lt;code&gt;high&lt;/code&gt; interval endpoint</source>
          <target state="translated">Используйте kwarg &lt;code&gt;endpoint&lt;/code&gt; точки для настройки включения или исключения конечной точки с &lt;code&gt;high&lt;/code&gt; интервалом</target>
        </trans-unit>
        <trans-unit id="1a4a01452f45e746c6cb102d0e1fd6cdbe229239" translate="yes" xml:space="preserve">
          <source>Use the &lt;code&gt;order&lt;/code&gt; keyword to specify a field to use when sorting a structured array:</source>
          <target state="translated">Используйте ключевое слово &lt;code&gt;order&lt;/code&gt; , чтобы указать поле, которое будет использоваться при сортировке структурированного массива:</target>
        </trans-unit>
        <trans-unit id="bd1412430a20e73aea7c2107ffe5351cd94a8833" translate="yes" xml:space="preserve">
          <source>Use the following import conventions:</source>
          <target state="new"/>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
