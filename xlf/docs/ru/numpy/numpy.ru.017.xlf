<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="numpy">
    <body>
      <group id="numpy">
        <trans-unit id="653a93daba5d03116d06838a5a76a1330934f611" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;str&lt;/code&gt; refers to either null terminated bytes or unicode strings depending on the Python version. In code targeting both Python 2 and 3 &lt;code&gt;np.unicode_&lt;/code&gt; should be used as a dtype for strings. See &lt;a href=&quot;#string-dtype-note&quot;&gt;Note on string types&lt;/a&gt;.</source>
          <target state="translated">Обратите внимание, что &lt;code&gt;str&lt;/code&gt; относится либо к байтам с завершающим нулем, либо к строкам Unicode в зависимости от версии Python. В коде, ориентированном на Python 2 и 3, &lt;code&gt;np.unicode_&lt;/code&gt; следует использовать как dtype для строк. См. &lt;a href=&quot;#string-dtype-note&quot;&gt;Примечание о типах строк&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="577f40a867da04018fffaab4749ee48c7ab85bee" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;test_&lt;/code&gt; functions or methods should not have a docstring, because that makes it hard to identify the test from the output of running the test suite with &lt;code&gt;verbose=2&lt;/code&gt; (or similar verbosity setting). Use plain comments (&lt;code&gt;#&lt;/code&gt;) if necessary.</source>
          <target state="translated">Обратите внимание, что функции или методы &lt;code&gt;test_&lt;/code&gt; не должны иметь строки документации, потому что это затрудняет идентификацию теста по выходным данным выполнения набора тестов с &lt;code&gt;verbose=2&lt;/code&gt; (или аналогичным параметром подробности). При необходимости используйте простые комментарии ( &lt;code&gt;#&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="84da082e7c60f89cf395b2c2caf3ee075a4fd999" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;tiny&lt;/code&gt; is not actually the smallest positive representable value in a NumPy floating point type. As in the IEEE-754 standard &lt;a href=&quot;#r2ee89c7f792a-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt;, NumPy floating point types make use of subnormal numbers to fill the gap between 0 and &lt;code&gt;tiny&lt;/code&gt;. However, subnormal numbers may have significantly reduced precision &lt;a href=&quot;#r2ee89c7f792a-2&quot; id=&quot;id2&quot;&gt;[2]&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="02e2af0a66e4601c973f5ec5d0ddca41b2da6bef" translate="yes" xml:space="preserve">
          <source>Note that C++ type &lt;code&gt;bool&lt;/code&gt; is not supported in the list in the &lt;a href=&quot;#available-typemaps&quot;&gt;Available Typemaps&lt;/a&gt; section. NumPy bools are a single byte, while the C++ &lt;code&gt;bool&lt;/code&gt; is four bytes (at least on my system). Therefore:</source>
          <target state="translated">Обратите внимание, что тип &lt;code&gt;bool&lt;/code&gt; в C ++ не поддерживается в списке в разделе &amp;laquo; &lt;a href=&quot;#available-typemaps&quot;&gt;Доступные карты типов&lt;/a&gt; &amp;raquo;. NumPy bool - это однобайтный, а C ++ &lt;code&gt;bool&lt;/code&gt; - четыре байта (по крайней мере, в моей системе). Следовательно:</target>
        </trans-unit>
        <trans-unit id="b7fb7bda276a077f32e3518dd51fb7c92f1227b3" translate="yes" xml:space="preserve">
          <source>Note that F2PY found that the second argument &lt;code&gt;n&lt;/code&gt; is the dimension of the first array argument &lt;code&gt;a&lt;/code&gt;. Since by default all arguments are input-only arguments, F2PY concludes that &lt;code&gt;n&lt;/code&gt; can be optional with the default value &lt;code&gt;len(a)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2aa71944aea37a075fc5603b1c286b6996796fc2" translate="yes" xml:space="preserve">
          <source>Note that LaTeX is not particularly easy to read, so use equations sparingly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9cc512ad322760dff623f859eafd23590a132e18" translate="yes" xml:space="preserve">
          <source>Note that NumPy is developed mainly using GNU compilers and tested on MSVC and Clang compilers. Compilers from other vendors such as Intel, Absoft, Sun, NAG, Compaq, Vast, Portland, Lahey, HP, IBM are only supported in the form of community feedback, and may not work out of the box. GCC 4.x (and later) compilers are recommended.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe4dc94a38ed3b66216a78c32ac7673436712897" translate="yes" xml:space="preserve">
          <source>Note that NumPy is developed mainly using GNU compilers and tested on MSVC and Clang compilers. Compilers from other vendors such as Intel, Absoft, Sun, NAG, Compaq, Vast, Portland, Lahey, HP, IBM are only supported in the form of community feedback, and may not work out of the box. GCC 4.x (and later) compilers are recommended. On ARM64 (aarch64) GCC 8.x (and later) are recommended.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d6fea2f832bdac55a57e8bcf7203f52e450af3e1" translate="yes" xml:space="preserve">
          <source>Note that NumPy submodules still use a file named &lt;code&gt;info.py&lt;/code&gt; in which the module docstring and &lt;code&gt;__all__&lt;/code&gt; dict are defined. These files will be removed at some point.</source>
          <target state="translated">Обратите внимание, что подмодули NumPy по-прежнему используют файл с именем &lt;code&gt;info.py&lt;/code&gt; , в котором определены docstring модуля и &lt;code&gt;__all__&lt;/code&gt; dict. В какой-то момент эти файлы будут удалены.</target>
        </trans-unit>
        <trans-unit id="cd1c6148abd4d8a68d9037726f201b07b6224a50" translate="yes" xml:space="preserve">
          <source>Note that a Fortran source file can contain many routines, and not necessarily all routines are needed to be used from Python. So, you can either specify which routines should be wrapped (in &lt;code&gt;only: .. :&lt;/code&gt; part) or which routines F2PY should ignored (in &lt;code&gt;skip: .. :&lt;/code&gt; part).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="59ecaa164d1fdc3d2b5cb9ca7ff5cce49bcc5610" translate="yes" xml:space="preserve">
          <source>Note that a sliding window approach is often &lt;strong&gt;not&lt;/strong&gt; optimal (see Notes).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="243df166efa690ac8a711211a7fdea37ebc1d718" translate="yes" xml:space="preserve">
          <source>Note that although almost all modern C compilers pad in this way by default, padding in C structs is C-implementation-dependent so this memory layout is not guaranteed to exactly match that of a corresponding struct in a C program. Some work may be needed, either on the numpy side or the C side, to obtain exact correspondence.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a0319be442be6ef174d641d2057417bdd72b054" translate="yes" xml:space="preserve">
          <source>Note that another approach would be to to use &lt;code&gt;getattr(ufunc,
methods)(*inputs, **kwargs)&lt;/code&gt; instead of the &lt;code&gt;super&lt;/code&gt; call. For this example, the result would be identical, but there is a difference if another operand also defines &lt;code&gt;__array_ufunc__&lt;/code&gt;. E.g., lets assume that we evalulate &lt;code&gt;np.add(a, b)&lt;/code&gt;, where &lt;code&gt;b&lt;/code&gt; is an instance of another class &lt;code&gt;B&lt;/code&gt; that has an override. If you use &lt;code&gt;super&lt;/code&gt; as in the example, &lt;code&gt;ndarray.__array_ufunc__&lt;/code&gt; will notice that &lt;code&gt;b&lt;/code&gt; has an override, which means it cannot evaluate the result itself. Thus, it will return &lt;code&gt;NotImplemented&lt;/code&gt; and so will our class &lt;code&gt;A&lt;/code&gt;. Then, control will be passed over to &lt;code&gt;b&lt;/code&gt;, which either knows how to deal with us and produces a result, or does not and returns &lt;code&gt;NotImplemented&lt;/code&gt;, raising a &lt;code&gt;TypeError&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f3a7170281d96c749df00a8822f6364f1c668d7" translate="yes" xml:space="preserve">
          <source>Note that another way to do an inplace build visible outside the repo base dir is with &lt;code&gt;python setup.py develop&lt;/code&gt;. Instead of adjusting &lt;code&gt;PYTHONPATH&lt;/code&gt;, this installs a &lt;code&gt;.egg-link&lt;/code&gt; file into your site-packages as well as adjusts the &lt;code&gt;easy-install.pth&lt;/code&gt; there, so its a more permanent (and magical) operation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d0bc3c9921682280a85d9ad74708f6af3774f00" translate="yes" xml:space="preserve">
          <source>Note that arrays with hard-coded dimensions are not supported. These cannot follow the double pointer signatures of these typemaps.</source>
          <target state="translated">Обратите внимание,что массивы с жестко заданными размерами не поддерживаются.Они не могут следовать за двойными указателями этих типовых карт.</target>
        </trans-unit>
        <trans-unit id="48706be1cfd595ac0f989289e2a8fb9947cff916" translate="yes" xml:space="preserve">
          <source>Note that as the order of the arguments are reversed, the side must be too. The &lt;a href=&quot;numpy.searchsorted#numpy.searchsorted&quot;&gt;&lt;code&gt;searchsorted&lt;/code&gt;&lt;/a&gt; call is marginally faster, as it does not do any monotonicity checks. Perhaps more importantly, it supports all dtypes.</source>
          <target state="translated">Обратите внимание, что, поскольку порядок аргументов меняется на обратный, сторона тоже должна быть. &lt;a href=&quot;numpy.searchsorted#numpy.searchsorted&quot;&gt; &lt;code&gt;searchsorted&lt;/code&gt; &lt;/a&gt; вызов немного быстрее, так как он не делает никаких проверок монотонности. Что еще более важно, он поддерживает все типы dtypes.</target>
        </trans-unit>
        <trans-unit id="b5450d42b830584acc5db98da979017850552b6b" translate="yes" xml:space="preserve">
          <source>Note that assignments may result in changes if assigning higher types to lower types (like floats to ints) or even exceptions (assigning complex to floats or ints):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1107611495a4cef20786212c1426d524434253be" translate="yes" xml:space="preserve">
          <source>Note that building the documentation on Windows is currently not actively supported, though it should be possible. (See &lt;a href=&quot;http://www.sphinx-doc.org/&quot;&gt;Sphinx&lt;/a&gt; documentation for more information.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="16a4ad0db92a475933d552d809189c9d735b06a9" translate="yes" xml:space="preserve">
          <source>Note that building the documentation on Windows is currently not actively supported, though it should be possible. (See &lt;a href=&quot;https://www.sphinx-doc.org/&quot;&gt;Sphinx&lt;/a&gt; documentation for more information.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b7ba7f496bb7ba121307112b93618161ad3c991" translate="yes" xml:space="preserve">
          <source>Note that by default using single &lt;code&gt;intent(out)&lt;/code&gt; also implies &lt;code&gt;intent(hide)&lt;/code&gt;. Arguments that have the &lt;code&gt;intent(hide)&lt;/code&gt; attribute specified will not be listed in the argument list of a wrapper function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e4dd030963aaaf3be4bd9f6afb2a54167cbe9671" translate="yes" xml:space="preserve">
          <source>Note that computing a monthly mortgage payment is only one use for this function. For example, pmt returns the periodic deposit one must make to achieve a specified future balance given an initial deposit, a fixed, periodically compounded interest rate, and the total number of periods.</source>
          <target state="translated">Обратите внимание,что вычисление ежемесячного платежа по ипотеке является только одним из способов использования этой функции.Например,pmt возвращает периодический депозит,который необходимо внести для достижения определенного будущего баланса при первоначальном депозите,фиксированной,периодически усложняющейся процентной ставке и общем количестве периодов.</target>
        </trans-unit>
        <trans-unit id="d45705fbd740d84091e3bf2b229712fdd0365205" translate="yes" xml:space="preserve">
          <source>Note that despite the name of this function it does not accept &lt;a href=&quot;https://docs.python.org/dev/library/stdtypes.html#str&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt; instances.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a3299a2dbf1b83250c6148ada8e7d466fe67fe1d" translate="yes" xml:space="preserve">
          <source>Note that despite the name of this function it does not accept &lt;code&gt;str&lt;/code&gt; instances.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46d023cb473537055d9b3a4020206aea9635b5fe" translate="yes" xml:space="preserve">
          <source>Note that dictionaries are not stored in any specific order. Also, most mutable (see &lt;em&gt;immutable&lt;/em&gt; below) objects, such as lists, may not be used as keys.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b262586803e1839adc1dd7ba61528562de1c4dc" translate="yes" xml:space="preserve">
          <source>Note that element</source>
          <target state="translated">Обратите внимание,что элемент</target>
        </trans-unit>
        <trans-unit id="3361278c66a9a950ab868f2606daa6d980ba0742" translate="yes" xml:space="preserve">
          <source>Note that fitting polynomial coefficients is inherently badly conditioned when the degree of the polynomial is large or the interval of sample points is badly centered. The quality of the fit should always be checked in these cases. When polynomial fits are not satisfactory, splines may be a good alternative.</source>
          <target state="translated">Обратите внимание,что подгоночные полиномиальные коэффициенты по своей природе плохо обусловлены,когда степень полинома велика или интервал точек выборки плохо отцентрирован.В этих случаях всегда следует проверять качество подгонки.В случае неудовлетворительной посадки полинома хорошей альтернативой могут быть сплайны.</target>
        </trans-unit>
        <trans-unit id="0754d929f5032a758a77b70b619d10e1a6b0a14a" translate="yes" xml:space="preserve">
          <source>Note that for complex numbers, the absolute value is taken before squaring, so that the result is always real and nonnegative.</source>
          <target state="translated">Обратите внимание,что для комплексных чисел абсолютное значение берется до квадрата,так что результат всегда вещественный и неотрицательный.</target>
        </trans-unit>
        <trans-unit id="17ba305768334a737a4dfbed178a872a09842e7e" translate="yes" xml:space="preserve">
          <source>Note that for documentation within numpy, it is not necessary to do &lt;code&gt;import numpy as np&lt;/code&gt; at the beginning of an example. However, some sub-modules, such as &lt;code&gt;fft&lt;/code&gt;, are not imported by default, and you have to include them explicitly:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc16e5fa0b99ff8394b543959e3c5038077d609b" translate="yes" xml:space="preserve">
          <source>Note that for floating-point input, the mean is computed using the same precision the input has. Depending on the input data, this can cause the results to be inaccurate, especially for &lt;a href=&quot;../arrays.scalars#numpy.float32&quot;&gt;&lt;code&gt;float32&lt;/code&gt;&lt;/a&gt; (see example below). Specifying a higher-precision accumulator using the &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt; keyword can alleviate this issue.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="81ef16afabd45555cde2cd7088469cd77b4f8e66" translate="yes" xml:space="preserve">
          <source>Note that for floating-point input, the mean is computed using the same precision the input has. Depending on the input data, this can cause the results to be inaccurate, especially for &lt;a href=&quot;../arrays.scalars#numpy.float32&quot;&gt;&lt;code&gt;float32&lt;/code&gt;&lt;/a&gt;. Specifying a higher-precision accumulator using the &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt; keyword can alleviate this issue.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c532f8402b234b1805dc32ad508ed06d2d992bc4" translate="yes" xml:space="preserve">
          <source>Note that for floating-point input, the mean is computed using the same precision the input has. Depending on the input data, this can cause the results to be inaccurate, especially for &lt;code&gt;float32&lt;/code&gt; (see example below). Specifying a higher-precision accumulator using the &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt; keyword can alleviate this issue.</source>
          <target state="translated">Обратите внимание, что для ввода с плавающей запятой среднее значение вычисляется с той же точностью, что и ввод. В зависимости от входных данных это может привести к неточности результатов, особенно для &lt;code&gt;float32&lt;/code&gt; (см. Пример ниже). Указание аккумулятора более высокой точности с использованием &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt; слова dtype может решить эту проблему.</target>
        </trans-unit>
        <trans-unit id="28ec6b24f09abee0bf153ce2a68e94e6fc60a244" translate="yes" xml:space="preserve">
          <source>Note that for floating-point input, the mean is computed using the same precision the input has. Depending on the input data, this can cause the results to be inaccurate, especially for &lt;code&gt;float32&lt;/code&gt;. Specifying a higher-precision accumulator using the &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt; keyword can alleviate this issue.</source>
          <target state="translated">Обратите внимание, что для ввода с плавающей запятой среднее значение вычисляется с той же точностью, что и ввод. В зависимости от входных данных это может привести к неточным результатам, особенно для &lt;code&gt;float32&lt;/code&gt; . Указание аккумулятора более высокой точности с использованием &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt; слова dtype может решить эту проблему.</target>
        </trans-unit>
        <trans-unit id="9429c3e4d702a779857d710d5ba3d4bb8d91e3db" translate="yes" xml:space="preserve">
          <source>Note that for higher dimensional inserts &lt;code&gt;obj=0&lt;/code&gt; behaves very different from &lt;code&gt;obj=[0]&lt;/code&gt; just like &lt;code&gt;arr[:,0,:] = values&lt;/code&gt; is different from &lt;code&gt;arr[:,[0],:] = values&lt;/code&gt;.</source>
          <target state="translated">Обратите внимание, что для вставок большего размера &lt;code&gt;obj=0&lt;/code&gt; сильно отличается от &lt;code&gt;obj=[0]&lt;/code&gt; точно так же, как &lt;code&gt;arr[:,0,:] = values&lt;/code&gt; отличается от &lt;code&gt;arr[:,[0],:] = values&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="64098939d0cc3bd11f1e190ea4842decacbcc08d" translate="yes" xml:space="preserve">
          <source>Note that higher-dimensional arrays are flattened!</source>
          <target state="translated">Обратите внимание,что более объемные массивы сглажены!</target>
        </trans-unit>
        <trans-unit id="08dbdae6232197f6e8ea8b77dc3750bf740014ac" translate="yes" xml:space="preserve">
          <source>Note that if &lt;code&gt;threads&lt;/code&gt; is not set by the user, it will be determined by &lt;code&gt;multiprocessing.cpu_count()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e03a6fba50452828f3483eb33a462b6c52de935" translate="yes" xml:space="preserve">
          <source>Note that if a field has the same name as an ndarray attribute, the ndarray attribute takes precedence. Such fields will be inaccessible by attribute but will still be accessible by index.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="18c7921c177ba1f557c86613521ffad6b35f74d0" translate="yes" xml:space="preserve">
          <source>Note that if an operand is given the flag &lt;a href=&quot;#c.NPY_ITER_COPY&quot;&gt;&lt;code&gt;NPY_ITER_COPY&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#c.NPY_ITER_UPDATEIFCOPY&quot;&gt;&lt;code&gt;NPY_ITER_UPDATEIFCOPY&lt;/code&gt;&lt;/a&gt;, a copy will be made in preference to buffering. Buffering will still occur when the array was broadcast so elements need to be duplicated to get a constant stride.</source>
          <target state="translated">Обратите внимание, что если &lt;a href=&quot;#c.NPY_ITER_COPY&quot;&gt; &lt;code&gt;NPY_ITER_COPY&lt;/code&gt; &lt;/a&gt;&lt;a href=&quot;#c.NPY_ITER_UPDATEIFCOPY&quot;&gt; &lt;code&gt;NPY_ITER_UPDATEIFCOPY&lt;/code&gt; &lt;/a&gt; флаг NPY_ITER_COPY или NPY_ITER_UPDATEIFCOPY , копия будет выполнена вместо буферизации. Буферизация все еще будет происходить, когда массив транслировался, поэтому элементы необходимо дублировать, чтобы получить постоянный шаг.</target>
        </trans-unit>
        <trans-unit id="b29d0e1167132199e264175b7a1e173cb2ad60e1" translate="yes" xml:space="preserve">
          <source>Note that if an uninitialized return array is created, values of False will leave those values &lt;strong&gt;uninitialized&lt;/strong&gt;.</source>
          <target state="translated">Обратите внимание: если создается неинициализированный возвращаемый массив, значения False оставят эти значения &lt;strong&gt;неинициализированными&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="8aa598501b8ebf0323315a582a961e1c62a8f937" translate="yes" xml:space="preserve">
          <source>Note that if one indexes a multidimensional array with fewer indices than dimensions, one gets a subdimensional array. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e7d909696047578f38bea71bdf411f55070df9d2" translate="yes" xml:space="preserve">
          <source>Note that if the C function signature was in a different order:</source>
          <target state="translated">Обратите внимание,что если сигнатура функции С была в другом порядке:</target>
        </trans-unit>
        <trans-unit id="01a168adfe5fe1f5dd6875481bec15e4f9aa1985" translate="yes" xml:space="preserve">
          <source>Note that if you want to do a reduction on an automatically allocated output, you must use &lt;a href=&quot;#c.NpyIter_GetOperandArray&quot;&gt;&lt;code&gt;NpyIter_GetOperandArray&lt;/code&gt;&lt;/a&gt; to get its reference, then set every value to the reduction unit before doing the iteration loop. In the case of a buffered reduction, this means you must also specify the flag &lt;a href=&quot;#c.NPY_ITER_DELAY_BUFALLOC&quot;&gt;&lt;code&gt;NPY_ITER_DELAY_BUFALLOC&lt;/code&gt;&lt;/a&gt;, then reset the iterator after initializing the allocated operand to prepare the buffers.</source>
          <target state="translated">Обратите внимание, что если вы хотите уменьшить автоматически выделенный вывод, вы должны использовать &lt;a href=&quot;#c.NpyIter_GetOperandArray&quot;&gt; &lt;code&gt;NpyIter_GetOperandArray&lt;/code&gt; ,&lt;/a&gt; чтобы получить его ссылку, а затем установить каждое значение в единицу сокращения перед выполнением цикла итерации. В случае буферизованного сокращения это означает, что вы также должны указать флаг &lt;a href=&quot;#c.NPY_ITER_DELAY_BUFALLOC&quot;&gt; &lt;code&gt;NPY_ITER_DELAY_BUFALLOC&lt;/code&gt; &lt;/a&gt; , а затем сбросить итератор после инициализации выделенного операнда для подготовки буферов.</target>
        </trans-unit>
        <trans-unit id="2b010bbfdb300bcd389c385bed7ea27b3386f09b" translate="yes" xml:space="preserve">
          <source>Note that in binary 160 = 1010 0000, 64 = 0100 0000, 192 = 1100 0000, and 32 = 0010 0000.</source>
          <target state="translated">Обратите внимание,что в двоичном коде 160=1010 0000,64=0100 0000,192=1100 0000,и 32=0010 0000.</target>
        </trans-unit>
        <trans-unit id="a6ebb270150b81af72246532a75002f3434d09b6" translate="yes" xml:space="preserve">
          <source>Note that in the code snippets below, &lt;code&gt;upstream&lt;/code&gt; refers to the root repository on github and &lt;code&gt;origin&lt;/code&gt; to a fork in your personal account. You may need to make adjustments if you have not forked the repository but simply cloned it locally. You can also edit &lt;code&gt;.git/config&lt;/code&gt; and add &lt;code&gt;upstream&lt;/code&gt; if it isn&amp;rsquo;t already present.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0deb1edca6a6f101961c6c8ff2fdf5eb19dff4d3" translate="yes" xml:space="preserve">
          <source>Note that integer divide-by-zero is handled by the same machinery. These behaviors are set on a per-thread basis.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6720060be8821678605a9cb8b96c71daf2200a5d" translate="yes" xml:space="preserve">
          <source>Note that it is not required for &lt;code&gt;__array_function__&lt;/code&gt; implementations to include &lt;em&gt;all&lt;/em&gt; of the corresponding NumPy function&amp;rsquo;s optional arguments (e.g., &lt;code&gt;broadcast_to&lt;/code&gt; above omits the irrelevant &lt;code&gt;subok&lt;/code&gt; argument). Optional arguments are only passed in to &lt;code&gt;__array_function__&lt;/code&gt; if they were explicitly used in the NumPy function call.</source>
          <target state="translated">Обратите внимание, что для реализаций &lt;code&gt;__array_function__&lt;/code&gt; не требуется включать &lt;em&gt;все&lt;/em&gt; дополнительные аргументы соответствующей функции NumPy (например, &lt;code&gt;broadcast_to&lt;/code&gt; выше опускает нерелевантный аргумент &lt;code&gt;subok&lt;/code&gt; ). Необязательные аргументы передаются в &lt;code&gt;__array_function__&lt;/code&gt; ,только если они явно использовались в вызове функции NumPy.</target>
        </trans-unit>
        <trans-unit id="401f22bf499be24336e06ca8c727f49552e9ba96" translate="yes" xml:space="preserve">
          <source>Note that it would be more straightforward in the above example to extract the required elements directly with &lt;code&gt;x[:2, :3]&lt;/code&gt;.</source>
          <target state="translated">Обратите внимание, что в приведенном выше примере было бы проще извлечь необходимые элементы напрямую с помощью &lt;code&gt;x[:2, :3]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="640acbca975ba8209807d8f3d4cb4b40d4247c4c" translate="yes" xml:space="preserve">
          <source>Note that license and author info, while often included in source files, do not belong in docstrings.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="03915cb39403716ec5a60a8297475cd1fe487299" translate="yes" xml:space="preserve">
          <source>Note that not all data-type information can be supplied with a type-object: for example, &lt;a href=&quot;arrays.scalars#numpy.flexible&quot;&gt;&lt;code&gt;flexible&lt;/code&gt;&lt;/a&gt; data-types have a default &lt;em&gt;itemsize&lt;/em&gt; of 0, and require an explicitly given size to be useful.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aaaef84f5e6e416f2f83a03c812a03e6bee63048" translate="yes" xml:space="preserve">
          <source>Note that not all data-type information can be supplied with a type-object: for example, &lt;code&gt;flexible&lt;/code&gt; data-types have a default &lt;em&gt;itemsize&lt;/em&gt; of 0, and require an explicitly given size to be useful.</source>
          <target state="translated">Обратите внимание, что не вся информация о типах данных может быть предоставлена ​​с помощью объекта-типа: например, &lt;code&gt;flexible&lt;/code&gt; типы данных имеют &lt;em&gt;размер&lt;/em&gt; элемента по умолчанию, &lt;em&gt;равный&lt;/em&gt; 0, и для их использования требуется явно заданный размер.</target>
        </trans-unit>
        <trans-unit id="780756f1773042c233a75d985a3181931209c4b9" translate="yes" xml:space="preserve">
          <source>Note that np.copy is a shallow copy and will not copy object elements within arrays. This is mainly important for arrays containing Python objects. The new array will contain the same object which may lead to surprises if that object can be modified (is mutable):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e81c263eba620a31c6f05237f30bb45194a05fe" translate="yes" xml:space="preserve">
          <source>Note that once the iterator is closed we can not access &lt;a href=&quot;generated/numpy.nditer.operands#numpy.nditer.operands&quot;&gt;&lt;code&gt;operands&lt;/code&gt;&lt;/a&gt; and must use a reference created inside the context manager.</source>
          <target state="translated">Обратите внимание, что после закрытия итератора мы не можем получить доступ к &lt;a href=&quot;generated/numpy.nditer.operands#numpy.nditer.operands&quot;&gt; &lt;code&gt;operands&lt;/code&gt; &lt;/a&gt; и должны использовать ссылку, созданную внутри диспетчера контекста.</target>
        </trans-unit>
        <trans-unit id="60c2866e24780637913bab15a3c10ed5a1e5ba08" translate="yes" xml:space="preserve">
          <source>Note that operations on integer scalar types (such as &lt;a href=&quot;../arrays.scalars#numpy.int16&quot;&gt;&lt;code&gt;int16&lt;/code&gt;&lt;/a&gt;) are handled like floating point, and are affected by these settings.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a0072c6c9282c50699dd3bb094606976a4136251" translate="yes" xml:space="preserve">
          <source>Note that operations on integer scalar types (such as &lt;code&gt;int16&lt;/code&gt;) are handled like floating point, and are affected by these settings.</source>
          <target state="translated">Обратите внимание, что операции с целочисленными скалярными типами (такими как &lt;code&gt;int16&lt;/code&gt; ) обрабатываются как с плавающей запятой, и на них влияют эти параметры.</target>
        </trans-unit>
        <trans-unit id="b5c0500d98fa9cc106c3d86fe8d639514bc7b011" translate="yes" xml:space="preserve">
          <source>Note that slices of arrays do not copy the internal array data but only produce new views of the original data. This is different from list or tuple slicing and an explicit &lt;code&gt;copy()&lt;/code&gt; is recommended if the original data is not required anymore.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="09f50c6ff377ac0a2ca64d0c66fbaa9d2065ec9a" translate="yes" xml:space="preserve">
          <source>Note that some examples may use &lt;code&gt;None&lt;/code&gt; instead of &lt;code&gt;np.newaxis&lt;/code&gt;. These are the same objects:</source>
          <target state="translated">Обратите внимание, что в некоторых примерах может использоваться &lt;code&gt;None&lt;/code&gt; вместо &lt;code&gt;np.newaxis&lt;/code&gt; . Это те же объекты:</target>
        </trans-unit>
        <trans-unit id="1c4abf3101df64ae31f9f09aef9564b202ca3573" translate="yes" xml:space="preserve">
          <source>Note that sometimes builds, like tests, fail for unrelated reasons and you will need to rerun them. You will need to be logged in under &amp;lsquo;numpy&amp;rsquo; to do this on azure.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f987286ad6faa40518b3a8186b7c20cb6434a93" translate="yes" xml:space="preserve">
          <source>Note that sometimes builds, like tests, fail for unrelated reasons and you will need to restart them.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ffa9fecdeba09a0f43a75d04eeb01c1da54d7720" translate="yes" xml:space="preserve">
          <source>Note that sorting is first according to the elements of &lt;code&gt;a&lt;/code&gt;. Secondary sorting is according to the elements of &lt;code&gt;b&lt;/code&gt;.</source>
          <target state="translated">Обратите внимание , что сортировка сначала по элементам . Вторичная сортировка производится по элементам &lt;code&gt;b&lt;/code&gt; . &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2ab2cbf3d7d05721e26131cbe4f74f5e6c689750" translate="yes" xml:space="preserve">
          <source>Note that the above may not produce exact integers:</source>
          <target state="translated">Обратите внимание,что вышеперечисленное может не давать точных целых чисел:</target>
        </trans-unit>
        <trans-unit id="eca364d78cae8f55568bb70af05b48416bbfc64c" translate="yes" xml:space="preserve">
          <source>Note that the columns have been rearranged &amp;ldquo;in bulk&amp;rdquo;: the values within each column have not changed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="816b54542ce937e025129bb5a02d396360440696" translate="yes" xml:space="preserve">
          <source>Note that the covariance matrix must be positive semidefinite (a.k.a. nonnegative-definite). Otherwise, the behavior of this method is undefined and backwards compatibility is not guaranteed.</source>
          <target state="translated">Обратите внимание,что ковариационная матрица должна быть положительной полубесконечной (a.k.a.неотрицательно-определённой).В противном случае поведение этого метода неопределенное и обратная совместимость не гарантируется.</target>
        </trans-unit>
        <trans-unit id="ce6b6a669d0954769df5e326b05520fbeb05f879" translate="yes" xml:space="preserve">
          <source>Note that the dtype of the second argument may change the dtype of the result and can lead to unexpected results in some cases (see &lt;a href=&quot;../ufuncs#ufuncs-casting&quot;&gt;Casting Rules&lt;/a&gt;):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="891f0fa3122015805e6600a7a4bd2235d2515ff8" translate="yes" xml:space="preserve">
          <source>Note that the length of the 1D boolean array must coincide with the length of the dimension (or axis) you want to slice. In the previous example, &lt;code&gt;b1&lt;/code&gt; has length 3 (the number of &lt;em&gt;rows&lt;/em&gt; in &lt;code&gt;a&lt;/code&gt;), and &lt;code&gt;b2&lt;/code&gt; (of length 4) is suitable to index the 2nd axis (columns) of &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="51fdfec7c0c161ff5cf20da12ebf59920f92cef4" translate="yes" xml:space="preserve">
          <source>Note that the order in which the diagonal is filled varies depending on the flip function.</source>
          <target state="translated">Обратите внимание,что порядок заполнения диагонали варьируется в зависимости от функции переворачивания.</target>
        </trans-unit>
        <trans-unit id="724f6e013fa8829f11659c1f81abf24921dbd546" translate="yes" xml:space="preserve">
          <source>Note that the order in which the diagonal is retrieved varies depending on the flip function.</source>
          <target state="translated">Обратите внимание,что порядок извлечения диагонали варьируется в зависимости от функции переворачивания.</target>
        </trans-unit>
        <trans-unit id="a99c18cf39a32483fd943f4224186f409906587f" translate="yes" xml:space="preserve">
          <source>Note that the output of &lt;a href=&quot;generated/numpy.ma.compressed#numpy.ma.compressed&quot;&gt;&lt;code&gt;compressed&lt;/code&gt;&lt;/a&gt; is always 1D.</source>
          <target state="translated">Обратите внимание, что &lt;a href=&quot;generated/numpy.ma.compressed#numpy.ma.compressed&quot;&gt; &lt;code&gt;compressed&lt;/code&gt; &lt;/a&gt; вывод всегда 1D.</target>
        </trans-unit>
        <trans-unit id="fe6f42e3829661cf63ecd7296a8f95be4fb61504" translate="yes" xml:space="preserve">
          <source>Note that the result of each integration is &lt;em&gt;multiplied&lt;/em&gt; by &lt;code&gt;scl&lt;/code&gt;. Why is this important to note? Say one is making a linear change of variable</source>
          <target state="translated">Обратите внимание, что результат каждого интегрирования &lt;em&gt;умножается&lt;/em&gt; на &lt;code&gt;scl&lt;/code&gt; . Почему это важно отметить? Скажем, кто-то делает линейное изменение переменной</target>
        </trans-unit>
        <trans-unit id="87d64ab0ec81404f96e3a3fd6a0cf4af1b48cd4a" translate="yes" xml:space="preserve">
          <source>Note that the result shape is identical to the (broadcast) indexing array shapes &lt;code&gt;ind_1, ..., ind_N&lt;/code&gt;.</source>
          <target state="translated">Обратите внимание, что форма результата идентична формам массива индексации (широковещательного) &lt;code&gt;ind_1, ..., ind_N&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="970776667a9fe553514eecc1dd1a72278348d24e" translate="yes" xml:space="preserve">
          <source>Note that the scalar types are not &lt;a href=&quot;generated/numpy.dtype#numpy.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt; objects, even though they can be used in place of one whenever a data type specification is needed in NumPy.</source>
          <target state="translated">Обратите внимание, что скалярные типы не &lt;a href=&quot;generated/numpy.dtype#numpy.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt; объектами dtype , даже если они могут использоваться вместо одного, когда в NumPy требуется спецификация типа данных.</target>
        </trans-unit>
        <trans-unit id="c59a59639135c22037a5377f994f5afdc88bff2a" translate="yes" xml:space="preserve">
          <source>Note that the strided-copy and strided-cast code are deeply intertwined and so any arrays being processed by them must be both uint and true aligned, even though the copy-code only needs uint alignment and the cast code only true alignment. If there is ever a big rewrite of this code it would be good to allow them to use different alignments.</source>
          <target state="translated">Обратите внимание на то,что прошитый и прошитый код глубоко переплетены и поэтому любые массивы,обрабатываемые ими,должны быть как uint,так и истинно выровнены,несмотря на то,что копировальный код нуждается только в выравнивании uint,а кастинговый код только в истинном выравнивании.Если когда-нибудь произойдёт большая перепись этого кода,было бы хорошо позволить им использовать различные выравнивания.</target>
        </trans-unit>
        <trans-unit id="773d567bd01efce78b3ce4a4307782bcff7af947" translate="yes" xml:space="preserve">
          <source>Note that the string representation of polynomials uses Unicode characters by default (except on Windows) to express powers and subscripts. An ASCII-based representation is also available (default on Windows). The polynomial string format can be toggled at the package-level with the &lt;a href=&quot;generated/numpy.polynomial.set_default_printstyle#numpy.polynomial.set_default_printstyle&quot;&gt;&lt;code&gt;set_default_printstyle&lt;/code&gt;&lt;/a&gt; function:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="66c05a00c87427b26e39bf9edf93e478c145e10d" translate="yes" xml:space="preserve">
          <source>Note that the terms in the multi-line Boolean expression are indented so as to make the beginning of the code block clearly visible.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fecfca7c041f47ec9751b796cf84238ada1da72a" translate="yes" xml:space="preserve">
          <source>Note that the ufunc (&lt;code&gt;np.add&lt;/code&gt;) has called the &lt;code&gt;__array_wrap__&lt;/code&gt; method with arguments &lt;code&gt;self&lt;/code&gt; as &lt;code&gt;obj&lt;/code&gt;, and &lt;code&gt;out_arr&lt;/code&gt; as the (ndarray) result of the addition. In turn, the default &lt;code&gt;__array_wrap__&lt;/code&gt; (&lt;code&gt;ndarray.__array_wrap__&lt;/code&gt;) has cast the result to class &lt;code&gt;MySubClass&lt;/code&gt;, and called &lt;code&gt;__array_finalize__&lt;/code&gt; - hence the copying of the &lt;code&gt;info&lt;/code&gt; attribute. This has all happened at the C level.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6d91192b6712228963707a6381dc069bd269f72d" translate="yes" xml:space="preserve">
          <source>Note that there are no new elements in the array, just that the dimensionality is increased. This can be handy to combine two arrays in a way that otherwise would require explicitly reshaping operations. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c86d4295cc278f91db8c615a2b6f47dcfb069bb" translate="yes" xml:space="preserve">
          <source>Note that there are some subtleties regarding the last usage that the user should be aware of that are described in the arange docstring.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3272a5f558b3fab42d4539ad3dc738bcb4ce852" translate="yes" xml:space="preserve">
          <source>Note that there are three parts to the long version of the printout. The first is the coefficients, the second is the domain, and the third is the window:</source>
          <target state="translated">Обратите внимание,что длинная версия распечатки состоит из трех частей.Первая-это коэффициенты,вторая-домен,а третья-окно:</target>
        </trans-unit>
        <trans-unit id="3a9c78ac3abf35e5e3337780f5e62c12c7df494d" translate="yes" xml:space="preserve">
          <source>Note that this distribution is very similar to the binomial distribution, except that in this case, samples are drawn without replacement, whereas in the Binomial case samples are drawn with replacement (or the sample space is infinite). As the sample space becomes large, this distribution approaches the binomial.</source>
          <target state="translated">Обратите внимание,что это распределение очень похоже на биномиальное,за исключением того,что в этом случае образцы отрисовываются без замены,тогда как в биномиальном случае образцы отрисовываются с заменой (или пространство образца бесконечно).По мере того,как пространство выборки становится большим,это распределение приближается к биномиальному.</target>
        </trans-unit>
        <trans-unit id="71bb480ec02fbb938cca2004bc6943842a328aaa" translate="yes" xml:space="preserve">
          <source>Note that this matches the precision of the builtin python &lt;code&gt;complex&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c75e7f017341538d8b3f779cf45143d903afb1a" translate="yes" xml:space="preserve">
          <source>Note that this matches the precision of the builtin python &lt;code&gt;float&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="207f864735403916ab64725fc35836347eea06c9" translate="yes" xml:space="preserve">
          <source>Note that unlike &lt;code&gt;data_as&lt;/code&gt;, a reference will not be kept to the array: code like &lt;code&gt;ctypes.c_void_p((a + b).ctypes.data)&lt;/code&gt; will result in a pointer to a deallocated array, and should be spelt &lt;code&gt;(a + b).ctypes.data_as(ctypes.c_void_p)&lt;/code&gt;</source>
          <target state="translated">Обратите внимание, что в отличие от &lt;code&gt;data_as&lt;/code&gt; , ссылка на массив не будет сохраняться: такой код, как &lt;code&gt;ctypes.c_void_p((a + b).ctypes.data)&lt;/code&gt; приведет к указателю на освобожденный массив и должен быть записан &lt;code&gt;(a + b).ctypes.data_as(ctypes.c_void_p)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="fa5eae61b870cb56e093988870d6dd9877647aa6" translate="yes" xml:space="preserve">
          <source>Note that unlike &lt;code&gt;numpy.ndarray&lt;/code&gt;, &lt;code&gt;ArrayLike&lt;/code&gt; does not allow operations with arbitrary, unrecognized types. This ensures that interactions with ArrayLike preserve a well-defined casting hierarchy.</source>
          <target state="translated">Обратите внимание, что в отличие от &lt;code&gt;numpy.ndarray&lt;/code&gt; , &lt;code&gt;ArrayLike&lt;/code&gt; не допускает операций с произвольными, нераспознанными типами. Это гарантирует, что взаимодействия с ArrayLike сохранят четко определенную иерархию приведения типов.</target>
        </trans-unit>
        <trans-unit id="43c59c07e98c965f271cd8992d38ce79563e80fe" translate="yes" xml:space="preserve">
          <source>Note that we can assign each color channel to a separate matrix using the slice syntax:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="448e8d337bf988d0c2429a16c43ede94f241e3d0" translate="yes" xml:space="preserve">
          <source>Note that we had to use only the first &lt;code&gt;k&lt;/code&gt; rows of &lt;code&gt;Vt&lt;/code&gt;, since all other rows would be multiplied by the zeros corresponding to the singular values we eliminated from this approximation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6653eb59198778eef2da729298a76ec147105c9f" translate="yes" xml:space="preserve">
          <source>Note that we picked datetimes that cross a DST boundary. Passing in a &lt;code&gt;pytz&lt;/code&gt; timezone object will print the appropriate offset</source>
          <target state="translated">Обратите внимание, что мы выбрали даты, которые пересекают границу летнего времени. Передача объекта часового пояса &lt;code&gt;pytz&lt;/code&gt; напечатает соответствующее смещение</target>
        </trans-unit>
        <trans-unit id="ff6a8871cdaa44abafcf71b9b33d5e54dbc5be42" translate="yes" xml:space="preserve">
          <source>Note that we support &lt;code&gt;DATA_TYPE*&lt;/code&gt; argout typemaps in 1D, but not 2D or 3D. This is because of a quirk with the &lt;a href=&quot;http://www.swig.org&quot;&gt;SWIG&lt;/a&gt; typemap syntax and cannot be avoided. Note that for these types of 1D typemaps, the Python function will take a single argument representing &lt;code&gt;DIM1&lt;/code&gt;.</source>
          <target state="translated">Обратите внимание, что мы поддерживаем &lt;code&gt;DATA_TYPE*&lt;/code&gt; типов DATA_TYPE * argout в 1D, но не в 2D или 3D. Это связано с особенностями синтаксиса карты типов &lt;a href=&quot;http://www.swig.org&quot;&gt;SWIG,&lt;/a&gt; и этого нельзя избежать. Обратите внимание, что для этих типов одномерных карт типов функция Python будет принимать один аргумент, представляющий &lt;code&gt;DIM1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="11034ab53fb8599a1310cf4207146288e154fc02" translate="yes" xml:space="preserve">
          <source>Note that when &lt;code&gt;a == 1&lt;/code&gt;, the normalization factor &lt;code&gt;v1 / (v1**2 - ddof * v2)&lt;/code&gt; goes over to &lt;code&gt;1 / (np.sum(f) - ddof)&lt;/code&gt; as it should.</source>
          <target state="translated">Обратите внимание, что когда &lt;code&gt;a == 1&lt;/code&gt; , коэффициент нормализации &lt;code&gt;v1 / (v1**2 - ddof * v2)&lt;/code&gt; переходит в &lt;code&gt;1 / (np.sum(f) - ddof)&lt;/code&gt; как и должно быть.</target>
        </trans-unit>
        <trans-unit id="9bc6e51338747705400e85f794a015c6a2357856" translate="yes" xml:space="preserve">
          <source>Note that when &lt;code&gt;out&lt;/code&gt; is given, the return value is &lt;code&gt;out&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3037f71e1ac80b9e7b6e511f234ab46281a3503" translate="yes" xml:space="preserve">
          <source>Note that when the &lt;code&gt;out&lt;/code&gt; parameter is given, the return value is &lt;code&gt;out&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="98530ea6c0be02d22c92fb9a99dc0d9aff053c64" translate="yes" xml:space="preserve">
          <source>Note that when type-casting is required and there is possible loss of information (e.g. when type-casting float to integer or complex to float), F2PY does not raise any exception. In complex to real type-casting only the real part of a complex number is used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="23123ffca4ff0e0a4a42f0653d7d9ea09cd17620" translate="yes" xml:space="preserve">
          <source>Note that whenever &lt;code&gt;&amp;lt;init_expr&amp;gt;&lt;/code&gt; is used, &lt;code&gt;optional&lt;/code&gt; attribute is set automatically by F2PY.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee0fb9212f997bf3174d26345ac37f18f11183de" translate="yes" xml:space="preserve">
          <source>Note that without the &lt;code&gt;np.ix_&lt;/code&gt; call, only the diagonal elements would be selected, as was used in the previous example. This difference is the most important thing to remember about indexing with multiple advanced indexes.</source>
          <target state="translated">Обратите внимание, что без вызова &lt;code&gt;np.ix_&lt;/code&gt; будут выбраны только диагональные элементы, как было использовано в предыдущем примере. Это различие является наиболее важным, о чем следует помнить при индексировании с помощью нескольких расширенных индексов.</target>
        </trans-unit>
        <trans-unit id="b5412b8a5c5e8aa3576931f3f122d134b272fe13" translate="yes" xml:space="preserve">
          <source>Note that you can eg. install NumPy to a temporary location and set the PYTHONPATH environment variable appropriately. Alternatively, if using Python virtual environments (via e.g. &lt;code&gt;conda&lt;/code&gt;, &lt;code&gt;virtualenv&lt;/code&gt; or the &lt;code&gt;venv&lt;/code&gt; module), installing numpy into a new virtual environment is recommended. All of the necessary dependencies for building the NumPy docs can be installed with:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b3edd40f42578284bf324094d774023e21eda09" translate="yes" xml:space="preserve">
          <source>Note that you get the time reversed, complex conjugated result when the two input sequences change places, i.e., &lt;code&gt;c_{va}[k] = c^{*}_{av}[-k]&lt;/code&gt;:</source>
          <target state="translated">Обратите внимание, что вы получаете комплексно-сопряженный результат с обратным временем, когда две входные последовательности меняются местами, то есть &lt;code&gt;c_{va}[k] = c^{*}_{av}[-k]&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="dc4f36c08ee65f253c387ba6c97a8e2ba7041327" translate="yes" xml:space="preserve">
          <source>Note that, above, we use the &lt;em&gt;Python&lt;/em&gt; float object as a dtype. NumPy knows that &lt;code&gt;int&lt;/code&gt; refers to &lt;code&gt;np.int_&lt;/code&gt;, &lt;code&gt;bool&lt;/code&gt; means &lt;code&gt;np.bool_&lt;/code&gt;, that &lt;code&gt;float&lt;/code&gt; is &lt;code&gt;np.float_&lt;/code&gt; and &lt;code&gt;complex&lt;/code&gt; is &lt;code&gt;np.complex_&lt;/code&gt;. The other data-types do not have Python equivalents.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba5c8fb85c6ca6f109e49af951ef9e99c064bb30" translate="yes" xml:space="preserve">
          <source>Note that, for complex numbers, &lt;a href=&quot;#numpy.std&quot;&gt;&lt;code&gt;std&lt;/code&gt;&lt;/a&gt; takes the absolute value before squaring, so that the result is always real and nonnegative.</source>
          <target state="translated">Обратите внимание, что для комплексных чисел &lt;a href=&quot;#numpy.std&quot;&gt; &lt;code&gt;std&lt;/code&gt; &lt;/a&gt; принимает абсолютное значение перед возведением в квадрат, поэтому результат всегда действительный и неотрицательный.</target>
        </trans-unit>
        <trans-unit id="67ff0ed45eb77e75fcc2a8d19c65a90ea73589bb" translate="yes" xml:space="preserve">
          <source>Note that, for complex numbers, &lt;a href=&quot;numpy.std#numpy.std&quot;&gt;&lt;code&gt;std&lt;/code&gt;&lt;/a&gt; takes the absolute value before squaring, so that the result is always real and nonnegative.</source>
          <target state="translated">Обратите внимание, что для комплексных чисел &lt;a href=&quot;numpy.std#numpy.std&quot;&gt; &lt;code&gt;std&lt;/code&gt; &lt;/a&gt; принимает абсолютное значение перед возведением в квадрат, поэтому результат всегда действительный и неотрицательный.</target>
        </trans-unit>
        <trans-unit id="70d9a8c143ac6b7cff84e338754a98ad2f6ecebc" translate="yes" xml:space="preserve">
          <source>Note that, in linear algebra, the dimension of a vector refers to the number of entries in an array. In NumPy, it instead defines the number of axes. For example, a 1D array is a vector such as &lt;code&gt;[1, 2, 3]&lt;/code&gt;, a 2D array is a matrix, and so forth.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="65e93cf7b4b44a5b77a394d19e4276d3eaadfbbd" translate="yes" xml:space="preserve">
          <source>Note that, in the old API that was deprecated in version 1.7, this function had the return type &lt;code&gt;int&lt;/code&gt;.</source>
          <target state="translated">Обратите внимание, что в старом API, который был объявлен устаревшим в версии 1.7, эта функция имела тип возврата &lt;code&gt;int&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7589de457b1bf436d7dda2480bd2ade65f60a09f" translate="yes" xml:space="preserve">
          <source>Note that, since NaN is unsortable, &lt;code&gt;xp&lt;/code&gt; also cannot contain NaNs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c60913e9a1e7e3a8383e344378c5f7011cb280cd" translate="yes" xml:space="preserve">
          <source>Note that, when we modify x, y changes, but not z:</source>
          <target state="translated">Обратите внимание,что когда мы изменяем x,y изменяется,но не z:</target>
        </trans-unit>
        <trans-unit id="a663ed58f0a095b16634564fa9a49f9e01516158" translate="yes" xml:space="preserve">
          <source>Note the array &lt;code&gt;dtype&lt;/code&gt; above of &lt;code&gt;&amp;gt;i2&lt;/code&gt;. The &lt;code&gt;&amp;gt;&lt;/code&gt; means &amp;lsquo;big-endian&amp;rsquo; (&lt;code&gt;&amp;lt;&lt;/code&gt; is little-endian) and &lt;code&gt;i2&lt;/code&gt; means &amp;lsquo;signed 2-byte integer&amp;rsquo;. For example, if our data represented a single unsigned 4-byte little-endian integer, the dtype string would be &lt;code&gt;&amp;lt;u4&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf42915649d8c90d2411a01638407672b7fa26fe" translate="yes" xml:space="preserve">
          <source>Note the array has not changed in memory:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b45db9188e4e378f18f56f3c51bcc9db7db73d40" translate="yes" xml:space="preserve">
          <source>Note the normalization factor of &lt;code&gt;pi&lt;/code&gt; used in the definition. This is the most commonly used definition in signal processing. Use &lt;code&gt;sinc(x / np.pi)&lt;/code&gt; to obtain the unnormalized sinc function</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7868473a32c7a3c40bb3a312d03eac57c7a37527" translate="yes" xml:space="preserve">
          <source>Note the order of the parameters. &lt;a href=&quot;#numpy.arctan2&quot;&gt;&lt;code&gt;arctan2&lt;/code&gt;&lt;/a&gt; is defined also when &lt;code&gt;x2&lt;/code&gt; = 0 and at several other special points, obtaining values in the range &lt;code&gt;[-pi, pi]&lt;/code&gt;:</source>
          <target state="translated">Обратите внимание на порядок параметров. &lt;a href=&quot;#numpy.arctan2&quot;&gt; &lt;code&gt;arctan2&lt;/code&gt; &lt;/a&gt; определяется также, когда &lt;code&gt;x2&lt;/code&gt; = 0 и в нескольких других специальных точках, получая значения в диапазоне &lt;code&gt;[-pi, pi]&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="3999859e7edf0b6850997e2b685c81e41f6bf30b" translate="yes" xml:space="preserve">
          <source>Note the unusual interpretation of sample when an array_like:</source>
          <target state="translated">Обратите внимание на необычную интерпретацию выборки,когда массив_подобен:</target>
        </trans-unit>
        <trans-unit id="4959b44a65b76595dc01fa81f812b74fb283e1a6" translate="yes" xml:space="preserve">
          <source>Note to those used to IDL or Fortran memory order as it relates to indexing. NumPy uses C-order indexing. That means that the last index usually represents the most rapidly changing memory location, unlike Fortran or IDL, where the first index represents the most rapidly changing location in memory. This difference represents a great potential for confusion.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="111feaa1cd8151a1eb25cfbf746ea648c6673cdc" translate="yes" xml:space="preserve">
          <source>Note: Prior to NumPy 1.10.0, less strict checks were in place: missing core dimensions were created by prepending 1&amp;rsquo;s to the shape as necessary, core dimensions with the same label were broadcast together, and undetermined dimensions were created with size 1.</source>
          <target state="translated">Примечание. До NumPy 1.10.0 применялись менее строгие проверки: отсутствующие основные размеры создавались путем добавления единиц к форме по мере необходимости, основные размеры с одной и той же меткой транслировались вместе, а неопределенные измерения создавались с размером 1.</target>
        </trans-unit>
        <trans-unit id="d21079fa664fe20f0bcb604959e5d77d12a5f0cb" translate="yes" xml:space="preserve">
          <source>Note: This function returns an array with at least one-dimension (1-d) so it will not preserve 0-d arrays.</source>
          <target state="translated">Примечание:данная функция возвращает массив как минимум с одним измерением (1-d),поэтому он не будет сохранять 0-d массивы.</target>
        </trans-unit>
        <trans-unit id="4a1a649c093516be216b047d4a6e07a8bfed16fc" translate="yes" xml:space="preserve">
          <source>Note: cannot use equality to test NaNs. E.g.:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="70440046a3dc2e079f23ee1c57dfa76669b732aa" translate="yes" xml:space="preserve">
          <source>Notes</source>
          <target state="translated">Notes</target>
        </trans-unit>
        <trans-unit id="046d816b2cced12f2b8341cea27cc367cd961583" translate="yes" xml:space="preserve">
          <source>Notes about the implementation algorithm (if needed).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a08e04c0814f8e83ad56517e19ff3c0721fcd94" translate="yes" xml:space="preserve">
          <source>Notes and Warnings : If there are points in the docstring that deserve special emphasis, the reST directives for a note or warning can be used in the vicinity of the context of the warning (inside a section). Syntax:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c3befe7e22c8667bc957541f49b0ee79970b588" translate="yes" xml:space="preserve">
          <source>Notes:</source>
          <target state="translated">Notes:</target>
        </trans-unit>
        <trans-unit id="f57a8f12c91535f8b3bf8808e86d3137e06887d9" translate="yes" xml:space="preserve">
          <source>Nothing happens if &lt;code&gt;a&lt;/code&gt; is not a masked array.</source>
          <target state="translated">Ничего не происходит , если не замаскированный массив. &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a10912bd64eec5f116a9c3fe1369faded07c9f4b" translate="yes" xml:space="preserve">
          <source>Nothing returned by this function.</source>
          <target state="translated">Ничто не возвращается этой функцией.</target>
        </trans-unit>
        <trans-unit id="15640e8dfd2dd046a0fb763219826f0e011ee43c" translate="yes" xml:space="preserve">
          <source>Notice how the final element of the &lt;a href=&quot;../routines.fft#module-numpy.fft&quot;&gt;&lt;code&gt;fft&lt;/code&gt;&lt;/a&gt; output is the complex conjugate of the second element, for real input. For &lt;a href=&quot;#numpy.fft.rfft&quot;&gt;&lt;code&gt;rfft&lt;/code&gt;&lt;/a&gt;, this symmetry is exploited to compute only the non-negative frequency terms.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="184b0a59161cac7480934a6869880704e9ffc1c5" translate="yes" xml:space="preserve">
          <source>Notice how the final element of the &lt;a href=&quot;numpy.fft.fft#numpy.fft.fft&quot;&gt;&lt;code&gt;fft&lt;/code&gt;&lt;/a&gt; output is the complex conjugate of the second element, for real input. For &lt;a href=&quot;#numpy.fft.rfft&quot;&gt;&lt;code&gt;rfft&lt;/code&gt;&lt;/a&gt;, this symmetry is exploited to compute only the non-negative frequency terms.</source>
          <target state="translated">Обратите внимание, как последний элемент вывода &lt;a href=&quot;numpy.fft.fft#numpy.fft.fft&quot;&gt; &lt;code&gt;fft&lt;/code&gt; &lt;/a&gt; является комплексным сопряжением второго элемента для реального ввода. Для &lt;a href=&quot;#numpy.fft.rfft&quot;&gt; &lt;code&gt;rfft&lt;/code&gt; &lt;/a&gt; эта симметрия используется для вычисления только неотрицательных частотных членов.</target>
        </trans-unit>
        <trans-unit id="9d24afb4770f955e79718f663c68d81c2708b5a7" translate="yes" xml:space="preserve">
          <source>Notice how the last term in the input to the ordinary &lt;a href=&quot;numpy.fft.ifft#numpy.fft.ifft&quot;&gt;&lt;code&gt;ifft&lt;/code&gt;&lt;/a&gt; is the complex conjugate of the second term, and the output has zero imaginary part everywhere. When calling &lt;a href=&quot;#numpy.fft.irfft&quot;&gt;&lt;code&gt;irfft&lt;/code&gt;&lt;/a&gt;, the negative frequencies are not specified, and the output array is purely real.</source>
          <target state="translated">Обратите внимание на то, что последний член на входе в обычный &lt;a href=&quot;numpy.fft.ifft#numpy.fft.ifft&quot;&gt; &lt;code&gt;ifft&lt;/code&gt; &lt;/a&gt; является комплексным сопряжением второго члена, а выход везде имеет нулевую мнимую часть. При вызове &lt;a href=&quot;#numpy.fft.irfft&quot;&gt; &lt;code&gt;irfft&lt;/code&gt; &lt;/a&gt; отрицательные частоты не указываются, а выходной массив является чисто реальным.</target>
        </trans-unit>
        <trans-unit id="ed100c4959db20fe84fd87eecf37518e6739a62d" translate="yes" xml:space="preserve">
          <source>Notice that Cython is an extension-module generator only. Unlike f2py, it includes no automatic facility for compiling and linking the extension module (which must be done in the usual fashion). It does provide a modified distutils class called &lt;code&gt;build_ext&lt;/code&gt; which lets you build an extension module from a &lt;code&gt;.pyx&lt;/code&gt; source. Thus, you could write in a &lt;code&gt;setup.py&lt;/code&gt; file:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0cb564d7e3f343c55b0fae22523656706209711d" translate="yes" xml:space="preserve">
          <source>Notice that the above 3 flags are defined so that a new, well- behaved array has these flags defined as true.</source>
          <target state="translated">Обратите внимание,что вышеуказанные 3 флага определены так,что в новом,хорошо себя зарекомендовавшем массиве эти флаги определены как истинные.</target>
        </trans-unit>
        <trans-unit id="933e026efdbeaa2316ba75443c7fec80dcb22b12" translate="yes" xml:space="preserve">
          <source>Notice that the full PyArrayObject is used as the first entry in order to ensure that the binary layout of instances of the new type is identical to the PyArrayObject.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="847535dd495885c3e2ed82b62e1abcb626ece607" translate="yes" xml:space="preserve">
          <source>Notice that the initial value is used as one of the elements for which the maximum is determined, unlike for the default argument Python&amp;rsquo;s max function, which is only used for empty iterables.</source>
          <target state="translated">Обратите внимание, что начальное значение используется как один из элементов, для которых определяется максимум, в отличие от функции max аргумента Python по умолчанию, которая используется только для пустых итераций.</target>
        </trans-unit>
        <trans-unit id="98ab17cc2cf9317019aeddb2bbabfef19cd3a629" translate="yes" xml:space="preserve">
          <source>Notice that the initial value is used as one of the elements for which the minimum is determined, unlike for the default argument Python&amp;rsquo;s max function, which is only used for empty iterables.</source>
          <target state="translated">Обратите внимание, что начальное значение используется в качестве одного из элементов, для которого определяется минимум, в отличие от функции max аргумента Python по умолчанию, которая используется только для пустых итераций.</target>
        </trans-unit>
        <trans-unit id="7a3bf5045be1e646ff0b1cf93fe99f156e23026b" translate="yes" xml:space="preserve">
          <source>Notice that the resulting wrapper to &lt;code&gt;FIB&lt;/code&gt; is as &amp;ldquo;smart&amp;rdquo; as in previous case:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="492b4a295e5558fecc78ff637653ffa8b09ca97f" translate="yes" xml:space="preserve">
          <source>Notice that the return type is a standard &lt;code&gt;numpy.ndarray&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="95fad7b0d0de8433821f8ae84856c18eccd090df" translate="yes" xml:space="preserve">
          <source>Notice that the second &lt;code&gt;usercode&lt;/code&gt; statement must be defined inside an &lt;code&gt;interface&lt;/code&gt; block and where the module dictionary is available through the variable &lt;code&gt;d&lt;/code&gt; (see &lt;code&gt;f2py var.pyf&lt;/code&gt;-generated &lt;code&gt;varmodule.c&lt;/code&gt; for additional details).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b99552cfe5ebf21e89509d47400467670883a7d" translate="yes" xml:space="preserve">
          <source>Notice that this isn&amp;rsquo;t the same as Python&amp;rsquo;s &lt;code&gt;default&lt;/code&gt; argument.</source>
          <target state="translated">Обратите внимание, что это не то же самое, что аргумент Python по &lt;code&gt;default&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="86ca463fe236705953b4cb323c8e44dbe110c67f" translate="yes" xml:space="preserve">
          <source>Notice the automatic conversion to the correct format that occurred.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="75917695664ab58d7b5d23aff9664353427c773e" translate="yes" xml:space="preserve">
          <source>Now all those people can do:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c558c7187dbb9215bbd627b6f1b25246d5a8c6fd" translate="yes" xml:space="preserve">
          <source>Now assume you attached &lt;strong&gt;hello.dispatch.c&lt;/strong&gt; to the source tree, then the infrastructure should generate a temporary config header called &lt;strong&gt;hello.dispatch.h&lt;/strong&gt; that can be reached by any source in the source tree, and it should contain the following code :</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="70bfcb10a3d92ea0cb076fb11e889a3f7696c2f5" translate="yes" xml:space="preserve">
          <source>Now editing a Python source file in NumPy allows you to immediately test and use your changes (in &lt;code&gt;.py&lt;/code&gt; files), by simply restarting the interpreter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="02f1d525547aac9ec4fc5c41b72c69bb1f2c8bfa" translate="yes" xml:space="preserve">
          <source>Now go to your fork and make a pull request for the branch.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="59497d295295e7471278d2cef4e18af42ce6655b" translate="yes" xml:space="preserve">
          <source>Now it must be a tuple whose first element is a string with &amp;ldquo;PyArrayInterface Version #&amp;rdquo; and whose second element is the object exposing the array.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1562b378f268443ad7a3ad7b80f355a383c82822" translate="yes" xml:space="preserve">
          <source>Now let&amp;rsquo;s tackle &lt;code&gt;__array_function__&lt;/code&gt;. We&amp;rsquo;ll create dict that maps numpy functions to our custom variants.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a4854dca388c79f7bb12e14a8a161b7a492c001a" translate="yes" xml:space="preserve">
          <source>Now multiply a diagonal matrix by &lt;code&gt;Q&lt;/code&gt; on one side and by &lt;code&gt;Q.T&lt;/code&gt; on the other:</source>
          <target state="translated">Теперь умножьте диагональную матрицу на &lt;code&gt;Q&lt;/code&gt; с одной стороны и на &lt;code&gt;Q.T&lt;/code&gt; с другой:</target>
        </trans-unit>
        <trans-unit id="d9aee1cf03a85f2c9234d34f54fa504a0ad159f3" translate="yes" xml:space="preserve">
          <source>Now our custom array type passes through numpy functions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="653b19d1d4883b62177051122cc7aeebf0172920" translate="yes" xml:space="preserve">
          <source>Now returns an empty list instead of None for a fully masked array</source>
          <target state="translated">Теперь возвращает пустой список вместо None для полностью замаскированного массива.</target>
        </trans-unit>
        <trans-unit id="ba8aa04151c2a1b06d4ae8fedf1218b84591b899" translate="yes" xml:space="preserve">
          <source>Now that our data has been masked, let&amp;rsquo;s try summing up all the cases in China:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec58b2146d74f6a1fb2a7b312c2b04a59b639bdc" translate="yes" xml:space="preserve">
          <source>Now the array &lt;em&gt;has&lt;/em&gt; changed in memory:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d5721d6e90bb96b54d081e10fa69a0fa60aa41ba" translate="yes" xml:space="preserve">
          <source>Now wait. If you get nervous at the amount of time taken &amp;ndash; the builds can take a while &amp;ndash; you can check the build progress by following the links provided at &lt;a href=&quot;https://github.com/MacPython/numpy-wheels&quot;&gt;https://github.com/MacPython/numpy-wheels&lt;/a&gt; to check the build status. Check if all the needed wheels have been built and uploaded before proceeding. There should currently be 21 of them at &lt;a href=&quot;https://anaconda.org/multibuild-wheels-staging/numpy/files&quot;&gt;https://anaconda.org/multibuild-wheels-staging/numpy/files&lt;/a&gt;, 3 for Mac, 6 for Windows, and 12 for Linux.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="699a899259937ad1e936681606eb842fe76f5cf4" translate="yes" xml:space="preserve">
          <source>Now wait. If you get nervous at the amount of time taken &amp;ndash; the builds can take a while &amp;ndash; you can check the build progress by following the links provided at &lt;a href=&quot;https://github.com/MacPython/numpy-wheels&quot;&gt;https://github.com/MacPython/numpy-wheels&lt;/a&gt; to check the build status. Check if all the needed wheels have been built and uploaded to the staging repository before proceeding.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a3a3bd4e9414b13e38275e5df8769440d431b61f" translate="yes" xml:space="preserve">
          <source>Now we are ready to apply the SVD:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="747aa74212ee1540da17718b2993f3a2e84b8796" translate="yes" xml:space="preserve">
          <source>Now we can correctly sum entries for mainland China:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f39ae5d13c5ad14506d67df0c86ac586848a064" translate="yes" xml:space="preserve">
          <source>Now we can iterate over &lt;code&gt;a_itor&lt;/code&gt;, and it will return arrays of size two. Since &lt;code&gt;buf_size&lt;/code&gt; was smaller than any dimension, the first dimension will be iterated over first:</source>
          <target state="translated">Теперь мы можем &lt;code&gt;a_itor&lt;/code&gt; , и он вернет массивы размера два. Поскольку &lt;code&gt;buf_size&lt;/code&gt; был меньше любого измерения, первое измерение будет повторяться первым:</target>
        </trans-unit>
        <trans-unit id="bf7432fe9f7d1de2712d47dd480396ec30fe9d54" translate="yes" xml:space="preserve">
          <source>Now we create an array &lt;code&gt;b1&lt;/code&gt; by slicing &lt;code&gt;a&lt;/code&gt; and modify the first element of &lt;code&gt;b1&lt;/code&gt;. This will modify the corresponding element in &lt;code&gt;a&lt;/code&gt; as well!</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e76ea020d2e734b4cfb0d824a7cb637d663128ae" translate="yes" xml:space="preserve">
          <source>Now we want to do the same kind of operation, but to all three colors. Our first instinct might be to repeat the same operation we did above to each color matrix individually. However, NumPy&amp;rsquo;s &lt;code&gt;broadcasting&lt;/code&gt; takes care of this for us.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be6dd4a7bf7c5c8f068a6e558d5c8ec36b5c692a" translate="yes" xml:space="preserve">
          <source>Now we write implementations of numpy functions for &lt;code&gt;DiagonalArray&lt;/code&gt;. For completeness, to support the usage &lt;code&gt;arr.sum()&lt;/code&gt; add a method &lt;code&gt;sum&lt;/code&gt; that calls &lt;code&gt;numpy.sum(self)&lt;/code&gt;, and the same for &lt;code&gt;mean&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8dc172f812b48628145c33844eeb0c5e41365a9a" translate="yes" xml:space="preserve">
          <source>Now you are ready to generate the docs, so write:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ae5aab236f57788a41324d9fac04d9f996796fb" translate="yes" xml:space="preserve">
          <source>Now you can do the following to test your module:</source>
          <target state="translated">Теперь вы можете сделать следующее,чтобы протестировать ваш модуль:</target>
        </trans-unit>
        <trans-unit id="93e01758207ef7eac9898579c0a0ad53ac2cbd99" translate="yes" xml:space="preserve">
          <source>Now you can make the release commit and tag. We recommend you don&amp;rsquo;t push the commit or tag immediately, just in case you need to do more cleanup. We prefer to defer the push of the tag until we&amp;rsquo;re confident this is the exact form of the released code (see: &lt;a href=&quot;#push-tag-and-commit&quot;&gt;Push the release tag and commit&lt;/a&gt;):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d14145f90c1ed14c03e17b7327ce3f007834c2f" translate="yes" xml:space="preserve">
          <source>Now you need to apply the changes from master to this branch using &lt;a href=&quot;https://www.kernel.org/pub/software/scm/git/docs/git-cherry-pick.html&quot;&gt;git cherry-pick&lt;/a&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da29f0210a502c721dd0dd5c83f6b4fa9f50c915" translate="yes" xml:space="preserve">
          <source>Now you want to connect to the upstream &lt;a href=&quot;https://github.com/numpy/numpy&quot;&gt;NumPy github&lt;/a&gt; repository, so you can merge in changes from trunk.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99261818f6547b5ed54374d3a2426ea44c25412d" translate="yes" xml:space="preserve">
          <source>Now,</source>
          <target state="translated">Now,</target>
        </trans-unit>
        <trans-unit id="54e3f4943855839d7ff1038b70ea21091b66f2f7" translate="yes" xml:space="preserve">
          <source>Now, &lt;code&gt;china_mask&lt;/code&gt; is an array of boolean values (&lt;code&gt;True&lt;/code&gt; or &lt;code&gt;False&lt;/code&gt;); we can check that the indices are what we wanted with the &lt;a href=&quot;../reference/generated/numpy.ma.nonzero#numpy.ma.nonzero&quot;&gt;&lt;code&gt;ma.nonzero&lt;/code&gt;&lt;/a&gt; method for masked arrays:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a849066ed1f230f65474fee40b0e94a7d98faa2" translate="yes" xml:space="preserve">
          <source>Now, &lt;code&gt;git remote -v&lt;/code&gt; will show two remote repositories named:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb1e590b12ac969204974436ab86b73a66b484b9" translate="yes" xml:space="preserve">
          <source>Now, &lt;code&gt;h&lt;/code&gt; is called a &lt;code&gt;House&lt;/code&gt; instance. An instance is therefore a specific realisation of a class.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c9d9c91fe6808bc153fedc3a3be54f274b18ccbd" translate="yes" xml:space="preserve">
          <source>Now, &lt;code&gt;img&lt;/code&gt; is a NumPy array, as we can see when using the &lt;code&gt;type&lt;/code&gt; function:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="52ef6adb474c75b77cfec6493b6e37127e46dd0c" translate="yes" xml:space="preserve">
          <source>Now, &lt;code&gt;img_gray&lt;/code&gt; has shape</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b5e3ab134c32e63476e019b6cc1db7108c6756a" translate="yes" xml:space="preserve">
          <source>Now, applying the &lt;a href=&quot;../reference/generated/numpy.linalg.svd#numpy.linalg.svd&quot;&gt;&lt;code&gt;linalg.svd&lt;/code&gt;&lt;/a&gt; function to this matrix, we obtain the following decomposition:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4103944902505e88c56a448e8658e10eed8eb1b4" translate="yes" xml:space="preserve">
          <source>Now, do one experiment throwing the dice 10 time, and 10 times again, and another throwing the dice 20 times, and 20 times again:</source>
          <target state="translated">Теперь,сделайте один эксперимент,бросив кубики 10 раз,и 10 раз снова,и еще один,бросив кубики 20 раз,и 20 раз снова:</target>
        </trans-unit>
        <trans-unit id="c02651c46a41ca9f07ac3b1090a827bd1aa0997e" translate="yes" xml:space="preserve">
          <source>Now, if we want to create a very simple approximation for this data, we should take into account the valid entries around the invalid ones. So first let&amp;rsquo;s select the dates for which the data is valid. Note that we can use the mask from the &lt;code&gt;china_total&lt;/code&gt; masked array to index the dates array:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d2ea454c7baf7564ea6fcb77c917ce2269209f53" translate="yes" xml:space="preserve">
          <source>Now, if we wish to rebuild the full SVD (with no approximation), we can do</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="79503e4a7bcf0bb6045b13fb5038f72cea2083ab" translate="yes" xml:space="preserve">
          <source>Now, the function can be called in a much more robust way:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a0435f8dfb75dd633a8592e953b3a61869c66ed" translate="yes" xml:space="preserve">
          <source>Now, throw the dice 20 times, and 20 times again:</source>
          <target state="translated">Теперь бросьте кости 20 раз,и 20 раз снова:</target>
        </trans-unit>
        <trans-unit id="e886cde483c798665f26429d663d928161ab6acf" translate="yes" xml:space="preserve">
          <source>Now, to build our approximation, we first need to make sure that our singular values are ready for multiplication, so we build our &lt;code&gt;Sigma&lt;/code&gt; matrix similarly to what we did before. The &lt;code&gt;Sigma&lt;/code&gt; array must have dimensions &lt;code&gt;(3, 768, 1024)&lt;/code&gt;. In order to add the singular values to the diagonal of &lt;code&gt;Sigma&lt;/code&gt;, we will use the &lt;code&gt;fill_diagonal&lt;/code&gt; function from NumPy, using each of the 3 rows in &lt;code&gt;s&lt;/code&gt; as the diagonal for each of the 3 matrices in &lt;code&gt;Sigma&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="565f463048564fa2ff4bfcbc1dc8859dde3aeacc" translate="yes" xml:space="preserve">
          <source>Now, to do the approximation, we must choose only the first &lt;code&gt;k&lt;/code&gt; singular values for each color channel. This can be done using the following syntax:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="53a0393525e01988d9f9cb1a6b35b57bda883e2e" translate="yes" xml:space="preserve">
          <source>Now, we create indices to manipulate a 3-D array:</source>
          <target state="translated">Теперь мы создаем индексы для манипулирования трехмерным массивом:</target>
        </trans-unit>
        <trans-unit id="c7902891716f837cf46001e7e450e13862b8420f" translate="yes" xml:space="preserve">
          <source>Now, we want to check if the reconstructed &lt;code&gt;U @ Sigma @ Vt&lt;/code&gt; is close to the original &lt;code&gt;img_gray&lt;/code&gt; matrix.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f06f8937e93eb4f141bfb2a705595fcdf67626f" translate="yes" xml:space="preserve">
          <source>Now, when we define a function, we can &amp;ldquo;decorate&amp;rdquo; it using &lt;code&gt;log&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4cc7b2e6b23e5632ad7c5158bf566b73a38ffebf" translate="yes" xml:space="preserve">
          <source>Now, whenever you want to switch to the virtual environment, you can use the command &lt;code&gt;source numpy-dev/bin/activate&lt;/code&gt;, and &lt;code&gt;deactivate&lt;/code&gt; to exit from the virtual environment and back to your previous shell.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="198b66dda9dfc0b0d1d736fde28782e16d5483f5" translate="yes" xml:space="preserve">
          <source>Now, you can go ahead and repeat this experiment with other values of &lt;code&gt;k&lt;/code&gt;, and each of your experiments should give you a slightly better (or worse) image depending on the value you choose.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1bd61014c9008087889fd725668b3c8d4970463d" translate="yes" xml:space="preserve">
          <source>Now, you can run:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a61d4e29999f717e20a2ffa02fda03db9cc09177" translate="yes" xml:space="preserve">
          <source>Now:</source>
          <target state="translated">Now:</target>
        </trans-unit>
        <trans-unit id="8b7fcaae0aa22776c49d066644c2b1975dfe6da1" translate="yes" xml:space="preserve">
          <source>NpyAuxData (C type)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34a30eac154cabdf7a90e0db5f0c2478a5065e89" translate="yes" xml:space="preserve">
          <source>NpyAuxData_CloneFunc</source>
          <target state="translated">NpyAuxData_CloneFunc</target>
        </trans-unit>
        <trans-unit id="34e8b7730172c8e3d3adc73c058819a6f92f117f" translate="yes" xml:space="preserve">
          <source>NpyAuxData_CloneFunc (C type)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c4fef0ec03464a7b11bd65b370680102da32d76" translate="yes" xml:space="preserve">
          <source>NpyAuxData_FreeFunc</source>
          <target state="translated">NpyAuxData_FreeFunc</target>
        </trans-unit>
        <trans-unit id="97e892e902cfe2bd9ee7b43a2c987c5ba8273d80" translate="yes" xml:space="preserve">
          <source>NpyAuxData_FreeFunc (C type)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e3a83bac5637b7f866d954fa04d5054091c36cc" translate="yes" xml:space="preserve">
          <source>NpyIter</source>
          <target state="translated">NpyIter</target>
        </trans-unit>
        <trans-unit id="82a0508669bbb7771cac0c8d3e2c866a68070845" translate="yes" xml:space="preserve">
          <source>NpyIter (C type)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="38c5db212050a32c003c23a2e475d5c5ce78e2df" translate="yes" xml:space="preserve">
          <source>NpyIter_AdvancedNew (C function)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8af20c5dee7afb2fdfe083ea49a8e985dcebda12" translate="yes" xml:space="preserve">
          <source>NpyIter_AdvancedNew()</source>
          <target state="translated">NpyIter_AdvancedNew()</target>
        </trans-unit>
        <trans-unit id="4b68aef05b915f8c4d85c85d6e5e698604e22d5b" translate="yes" xml:space="preserve">
          <source>NpyIter_Copy (C function)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b997b8b2b511720cd1069c024299823f83302c9e" translate="yes" xml:space="preserve">
          <source>NpyIter_Copy()</source>
          <target state="translated">NpyIter_Copy()</target>
        </trans-unit>
        <trans-unit id="dead001979a949af7bc216d40e317c11b1627b50" translate="yes" xml:space="preserve">
          <source>NpyIter_CreateCompatibleStrides (C function)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3fb78c3f62b576c1af874d751640db8eff8c9979" translate="yes" xml:space="preserve">
          <source>NpyIter_CreateCompatibleStrides()</source>
          <target state="translated">NpyIter_CreateCompatibleStrides()</target>
        </trans-unit>
        <trans-unit id="bd5f39811c4a438e4611fe7324c733dae8e18e94" translate="yes" xml:space="preserve">
          <source>NpyIter_Deallocate (C function)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ad45ab8ae95fe7da10aaac502dcfd57dbf572fa" translate="yes" xml:space="preserve">
          <source>NpyIter_Deallocate()</source>
          <target state="translated">NpyIter_Deallocate()</target>
        </trans-unit>
        <trans-unit id="9e58f50382b305a7c644ed30e9dbf73ab673b658" translate="yes" xml:space="preserve">
          <source>NpyIter_EnableExternalLoop (C function)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e39e8d7265758ca02d07e1e363c5debc0123f813" translate="yes" xml:space="preserve">
          <source>NpyIter_EnableExternalLoop()</source>
          <target state="translated">NpyIter_EnableExternalLoop()</target>
        </trans-unit>
        <trans-unit id="329ae7e5f8f4f861595a2f3783d09679b3a68e75" translate="yes" xml:space="preserve">
          <source>NpyIter_GetAxisStrideArray (C function)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb2c139e38956ebdf5ce855ccf3149ea641f8b05" translate="yes" xml:space="preserve">
          <source>NpyIter_GetAxisStrideArray()</source>
          <target state="translated">NpyIter_GetAxisStrideArray()</target>
        </trans-unit>
        <trans-unit id="11e9224b826aa03f20a5575963d1a61c21bde7ea" translate="yes" xml:space="preserve">
          <source>NpyIter_GetBufferSize (C function)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c71d1d0e6fd6d70024c7dd931246be434c73502" translate="yes" xml:space="preserve">
          <source>NpyIter_GetBufferSize()</source>
          <target state="translated">NpyIter_GetBufferSize()</target>
        </trans-unit>
        <trans-unit id="efd6b812e98d492f8edfd24e4ba12b4a6b2f06ff" translate="yes" xml:space="preserve">
          <source>NpyIter_GetDataPtrArray (C function)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="87a85869fc34454e6204a9b83263efd25b3b19a8" translate="yes" xml:space="preserve">
          <source>NpyIter_GetDataPtrArray()</source>
          <target state="translated">NpyIter_GetDataPtrArray()</target>
        </trans-unit>
        <trans-unit id="4818f80260586e06d259cc413bb89e872d11d852" translate="yes" xml:space="preserve">
          <source>NpyIter_GetDescrArray (C function)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="62cedbb3cbc591b2ae980b3bc6c8c39f71d0c16b" translate="yes" xml:space="preserve">
          <source>NpyIter_GetDescrArray()</source>
          <target state="translated">NpyIter_GetDescrArray()</target>
        </trans-unit>
        <trans-unit id="b2e4a49c346fdbeb713aed872c544759f393dc2a" translate="yes" xml:space="preserve">
          <source>NpyIter_GetGetMultiIndex (C function)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d029059dda4dad1438f1bd80a75d454f99834d6" translate="yes" xml:space="preserve">
          <source>NpyIter_GetGetMultiIndex()</source>
          <target state="translated">NpyIter_GetGetMultiIndex()</target>
        </trans-unit>
        <trans-unit id="0b61a40f2f042effaff1a816288916e29182e78d" translate="yes" xml:space="preserve">
          <source>NpyIter_GetIndexPtr (C function)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="66611101d6de9d68cce0bd7a8cf2f113e7678aaf" translate="yes" xml:space="preserve">
          <source>NpyIter_GetIndexPtr()</source>
          <target state="translated">NpyIter_GetIndexPtr()</target>
        </trans-unit>
        <trans-unit id="709bac1bb4a069b2df14e08fa3d634e04e1b48d8" translate="yes" xml:space="preserve">
          <source>NpyIter_GetInitialDataPtrArray (C function)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cca4420e7f21331a3412d9afdd62effd1a37e0d5" translate="yes" xml:space="preserve">
          <source>NpyIter_GetInitialDataPtrArray()</source>
          <target state="translated">NpyIter_GetInitialDataPtrArray()</target>
        </trans-unit>
        <trans-unit id="ce42d7c0034eff3c7307f8b08adc8d1d3d5232be" translate="yes" xml:space="preserve">
          <source>NpyIter_GetInnerFixedStrideArray (C function)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e2852a223ce3a2b4862d0d75cd1f8c82ebb096d" translate="yes" xml:space="preserve">
          <source>NpyIter_GetInnerFixedStrideArray()</source>
          <target state="translated">NpyIter_GetInnerFixedStrideArray()</target>
        </trans-unit>
        <trans-unit id="320bab14d48a2be5366699d949e501506d8b52ef" translate="yes" xml:space="preserve">
          <source>NpyIter_GetInnerLoopSizePtr (C function)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a28fb690d09a18949fd479bfd69414cd7025ffd8" translate="yes" xml:space="preserve">
          <source>NpyIter_GetInnerLoopSizePtr()</source>
          <target state="translated">NpyIter_GetInnerLoopSizePtr()</target>
        </trans-unit>
        <trans-unit id="2741ed5c537a092cf9f55caeb0d6909844811cae" translate="yes" xml:space="preserve">
          <source>NpyIter_GetInnerStrideArray (C function)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="459e9e1f94992501dfb6860694a283afdd8b7cd8" translate="yes" xml:space="preserve">
          <source>NpyIter_GetInnerStrideArray()</source>
          <target state="translated">NpyIter_GetInnerStrideArray()</target>
        </trans-unit>
        <trans-unit id="916bfb4b9ccc85a495812e9b0ef709804cf83e7b" translate="yes" xml:space="preserve">
          <source>NpyIter_GetIterIndex (C function)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b51d4d2bf86336410a4e52bb5d565c6529f946c" translate="yes" xml:space="preserve">
          <source>NpyIter_GetIterIndex()</source>
          <target state="translated">NpyIter_GetIterIndex()</target>
        </trans-unit>
        <trans-unit id="4f98f4187c0881fc46fb9149b68116d68e20d9ea" translate="yes" xml:space="preserve">
          <source>NpyIter_GetIterIndexRange (C function)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46f9917bbb45a59125169b7d51e52942d1ae839d" translate="yes" xml:space="preserve">
          <source>NpyIter_GetIterIndexRange()</source>
          <target state="translated">NpyIter_GetIterIndexRange()</target>
        </trans-unit>
        <trans-unit id="6ac9c145de13db3cda86b9108539ac806761dc14" translate="yes" xml:space="preserve">
          <source>NpyIter_GetIterNext (C function)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb93380537687af5addf300e0da2d51122534b79" translate="yes" xml:space="preserve">
          <source>NpyIter_GetIterSize (C function)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e7b47088c34a7caf54317e4c555ce5eeee306bf9" translate="yes" xml:space="preserve">
          <source>NpyIter_GetIterSize()</source>
          <target state="translated">NpyIter_GetIterSize()</target>
        </trans-unit>
        <trans-unit id="971f351012eac4ac6bf123d19280ff6e83e62e85" translate="yes" xml:space="preserve">
          <source>NpyIter_GetIterView (C function)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b37332e2ac83c27d275077f93c1a5465ad79ccdf" translate="yes" xml:space="preserve">
          <source>NpyIter_GetIterView()</source>
          <target state="translated">NpyIter_GetIterView()</target>
        </trans-unit>
        <trans-unit id="260ac3818c138694453f685279c2631308cb9db4" translate="yes" xml:space="preserve">
          <source>NpyIter_GetMultiIndexFunc</source>
          <target state="translated">NpyIter_GetMultiIndexFunc</target>
        </trans-unit>
        <trans-unit id="268c5739b883afa9c178c9d12b961525ac033a81" translate="yes" xml:space="preserve">
          <source>NpyIter_GetMultiIndexFunc (C type)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="12fef6dc6e8adca628a81ab1f9f58214b8989570" translate="yes" xml:space="preserve">
          <source>NpyIter_GetNDim (C function)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e9bba8a229eb928a91402e6ca604c155e3edd64" translate="yes" xml:space="preserve">
          <source>NpyIter_GetNDim()</source>
          <target state="translated">NpyIter_GetNDim()</target>
        </trans-unit>
        <trans-unit id="68db817bd7a88e9a2db3bf2cfbe83efefe3a7b98" translate="yes" xml:space="preserve">
          <source>NpyIter_GetNOp (C function)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="50db8bb821c577506b545754506219ead592b053" translate="yes" xml:space="preserve">
          <source>NpyIter_GetNOp()</source>
          <target state="translated">NpyIter_GetNOp()</target>
        </trans-unit>
        <trans-unit id="4be079e1aeeda5c22d683667022b51cf015a2c21" translate="yes" xml:space="preserve">
          <source>NpyIter_GetOperandArray (C function)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3af90f6f35483cf45c99c7df56d9615992da54dd" translate="yes" xml:space="preserve">
          <source>NpyIter_GetOperandArray()</source>
          <target state="translated">NpyIter_GetOperandArray()</target>
        </trans-unit>
        <trans-unit id="4b047889d28074e88029d8a1e07fab68c9e1b2a6" translate="yes" xml:space="preserve">
          <source>NpyIter_GetReadFlags (C function)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a30bb289b8e86739e36ea60928a2ed64312d2fec" translate="yes" xml:space="preserve">
          <source>NpyIter_GetReadFlags()</source>
          <target state="translated">NpyIter_GetReadFlags()</target>
        </trans-unit>
        <trans-unit id="72287467289d08139728b9bd588cb1fba0d298e1" translate="yes" xml:space="preserve">
          <source>NpyIter_GetShape (C function)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c3fe550cadce766e0ebaa92151a7d483873ef4a" translate="yes" xml:space="preserve">
          <source>NpyIter_GetShape()</source>
          <target state="translated">NpyIter_GetShape()</target>
        </trans-unit>
        <trans-unit id="16f7d0a2122c563a659425f4ce571bbbba298beb" translate="yes" xml:space="preserve">
          <source>NpyIter_GetWriteFlags (C function)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="acd9a2ff8ce509672e11ffa76fdbabff9b0c7181" translate="yes" xml:space="preserve">
          <source>NpyIter_GetWriteFlags()</source>
          <target state="translated">NpyIter_GetWriteFlags()</target>
        </trans-unit>
        <trans-unit id="6668661c9c3f5c1e327bd4f2c42ad82f1605c898" translate="yes" xml:space="preserve">
          <source>NpyIter_GotoIndex (C function)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d3120c654191cddf0b70bae47a341b3c86669393" translate="yes" xml:space="preserve">
          <source>NpyIter_GotoIndex()</source>
          <target state="translated">NpyIter_GotoIndex()</target>
        </trans-unit>
        <trans-unit id="32885a42e6fb8b031f26299bec0d11656e3b1eaa" translate="yes" xml:space="preserve">
          <source>NpyIter_GotoIterIndex (C function)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f1654c5ff8fe66cc2194f6b61e83a8e796fe628" translate="yes" xml:space="preserve">
          <source>NpyIter_GotoIterIndex()</source>
          <target state="translated">NpyIter_GotoIterIndex()</target>
        </trans-unit>
        <trans-unit id="e135f8536fc5fd83a52cd6bbd2bce201e704280c" translate="yes" xml:space="preserve">
          <source>NpyIter_GotoMultiIndex (C function)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d041142525a40cf564e2e7e029c65f6509b0a323" translate="yes" xml:space="preserve">
          <source>NpyIter_GotoMultiIndex()</source>
          <target state="translated">NpyIter_GotoMultiIndex()</target>
        </trans-unit>
        <trans-unit id="1d5b6a575bb6f461dea653952d455489a8ea3d4a" translate="yes" xml:space="preserve">
          <source>NpyIter_HasDelayedBufAlloc (C function)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed0864809f09d890d29d15054f92994f033a3f43" translate="yes" xml:space="preserve">
          <source>NpyIter_HasDelayedBufAlloc()</source>
          <target state="translated">NpyIter_HasDelayedBufAlloc()</target>
        </trans-unit>
        <trans-unit id="8d6631cc570fdeba0443b204635f61ead9da9cc0" translate="yes" xml:space="preserve">
          <source>NpyIter_HasExternalLoop (C function)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="02c750ba9fcfc1c225387cebcaf21e29ccbc7ab1" translate="yes" xml:space="preserve">
          <source>NpyIter_HasExternalLoop()</source>
          <target state="translated">NpyIter_HasExternalLoop()</target>
        </trans-unit>
        <trans-unit id="01ff965a16adc18e1fe09a249c239ef993e1e4cd" translate="yes" xml:space="preserve">
          <source>NpyIter_HasIndex (C function)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1495f8b014a812b7d5168151357e69d6e80056fa" translate="yes" xml:space="preserve">
          <source>NpyIter_HasIndex()</source>
          <target state="translated">NpyIter_HasIndex()</target>
        </trans-unit>
        <trans-unit id="524724e0000bf6ba5bb9fefb1e4de88d3ce724e6" translate="yes" xml:space="preserve">
          <source>NpyIter_HasMultiIndex (C function)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca93af25bd286e2ffe55a87884c419afcd79bfcd" translate="yes" xml:space="preserve">
          <source>NpyIter_HasMultiIndex()</source>
          <target state="translated">NpyIter_HasMultiIndex()</target>
        </trans-unit>
        <trans-unit id="b4e6deeafbbcf71e1a3f6bc2ac6366e5bd6c1b90" translate="yes" xml:space="preserve">
          <source>NpyIter_IsBuffered (C function)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="476b949116e329f3c582aec5e76ce2e141633429" translate="yes" xml:space="preserve">
          <source>NpyIter_IsBuffered()</source>
          <target state="translated">NpyIter_IsBuffered()</target>
        </trans-unit>
        <trans-unit id="7304a6b23051f3e1aaa8d76004af420f8c287e9d" translate="yes" xml:space="preserve">
          <source>NpyIter_IsFirstVisit (C function)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e9bbd57db7393e50498619291fc91b81f37f813" translate="yes" xml:space="preserve">
          <source>NpyIter_IsFirstVisit()</source>
          <target state="translated">NpyIter_IsFirstVisit()</target>
        </trans-unit>
        <trans-unit id="c71ca1fe83aa6474b8db38df750b5605a0ad4041" translate="yes" xml:space="preserve">
          <source>NpyIter_IsGrowInner (C function)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f0a2dba542604a7f3103127f1353c17a14acca2" translate="yes" xml:space="preserve">
          <source>NpyIter_IsGrowInner()</source>
          <target state="translated">NpyIter_IsGrowInner()</target>
        </trans-unit>
        <trans-unit id="89d075475c669dbbf16b180a78f6a538e870d992" translate="yes" xml:space="preserve">
          <source>NpyIter_IterNextFunc</source>
          <target state="translated">NpyIter_IterNextFunc</target>
        </trans-unit>
        <trans-unit id="ed5e1d448ea8ab46ae13594b26e85229c0f707c9" translate="yes" xml:space="preserve">
          <source>NpyIter_IterNextFunc (C type)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7035ada01b636882b1ed7a431b18b92987e61d41" translate="yes" xml:space="preserve">
          <source>NpyIter_MultiNew (C function)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="959108f7b8a46be14788dcc6f2c656a40adf98c1" translate="yes" xml:space="preserve">
          <source>NpyIter_MultiNew()</source>
          <target state="translated">NpyIter_MultiNew()</target>
        </trans-unit>
        <trans-unit id="ed094cc005976d6753311589b5d73c8f2c8e5e4f" translate="yes" xml:space="preserve">
          <source>NpyIter_New (C function)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="75df925e997f8a9b01f4fc38c2a52f970f929a3f" translate="yes" xml:space="preserve">
          <source>NpyIter_RemoveMultiIndex (C function)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d0fc99dccddcd13dec9ec17ac48fd49dd80c577" translate="yes" xml:space="preserve">
          <source>NpyIter_RemoveMultiIndex()</source>
          <target state="translated">NpyIter_RemoveMultiIndex()</target>
        </trans-unit>
        <trans-unit id="71dc9b48fe46c56aa709225d6c3eb5faead7860b" translate="yes" xml:space="preserve">
          <source>NpyIter_RequiresBuffering (C function)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a202ae5802958f468dad8c3e99a4bb5293a4dde8" translate="yes" xml:space="preserve">
          <source>NpyIter_RequiresBuffering()</source>
          <target state="translated">NpyIter_RequiresBuffering()</target>
        </trans-unit>
        <trans-unit id="082f6c0216a14a9d8e91d9d0eb80091b4c8e7c17" translate="yes" xml:space="preserve">
          <source>NpyIter_Reset (C function)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c109fda112a4bfc0725b7a5833fd46c5602a3173" translate="yes" xml:space="preserve">
          <source>NpyIter_Reset()</source>
          <target state="translated">NpyIter_Reset()</target>
        </trans-unit>
        <trans-unit id="70f5ee8ee0cc17ab92992d6cf6ee393f1e4520e7" translate="yes" xml:space="preserve">
          <source>NpyIter_ResetBasePointers (C function)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f1294ce3152cab7ceda644b504d717770b89e5c7" translate="yes" xml:space="preserve">
          <source>NpyIter_ResetBasePointers()</source>
          <target state="translated">NpyIter_ResetBasePointers()</target>
        </trans-unit>
        <trans-unit id="14a37f97f8b6e5b56b6e83ff5eb67b7c25067c0c" translate="yes" xml:space="preserve">
          <source>NpyIter_ResetToIterIndexRange (C function)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a0acf29df8ba8a7bb014f05220b41b68cf91300" translate="yes" xml:space="preserve">
          <source>NpyIter_ResetToIterIndexRange()</source>
          <target state="translated">NpyIter_ResetToIterIndexRange()</target>
        </trans-unit>
        <trans-unit id="73626c9be0436b0d908d20d700956f6f6ce365b0" translate="yes" xml:space="preserve">
          <source>NpyIter_Type</source>
          <target state="translated">NpyIter_Type</target>
        </trans-unit>
        <trans-unit id="61c3b0ba34d7f397bd9f7eff4691cefedb4d278d" translate="yes" xml:space="preserve">
          <source>NpyIter_Type (C type)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="114cc06627557f63febd03e44f39195669b3db75" translate="yes" xml:space="preserve">
          <source>NumFOCUS Subcommittee</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="148fb3e1f0f3a0a5a25d7af63d9dc5d6da0841ea" translate="yes" xml:space="preserve">
          <source>NumPy</source>
          <target state="translated">NumPy</target>
        </trans-unit>
        <trans-unit id="a9d2a1b57f4f20938978d4d1c165136857a81954" translate="yes" xml:space="preserve">
          <source>NumPy &amp;mdash; it provides packages like:</source>
          <target state="translated">NumPy - предоставляет такие пакеты, как:</target>
        </trans-unit>
        <trans-unit id="766bc7e1c62d6bf447df2796935c0002e01046b4" translate="yes" xml:space="preserve">
          <source>NumPy (&lt;strong&gt;Numerical Python&lt;/strong&gt;) is an open source Python library that&amp;rsquo;s used in almost every field of science and engineering. It&amp;rsquo;s the universal standard for working with numerical data in Python, and it&amp;rsquo;s at the core of the scientific Python and PyData ecosystems. NumPy users include everyone from beginning coders to experienced researchers doing state-of-the-art scientific and industrial research and development. The NumPy API is used extensively in Pandas, SciPy, Matplotlib, scikit-learn, scikit-image and most other data science and scientific Python packages.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c505ea92418c9a5d535f7526fb8ff95e78ef0962" translate="yes" xml:space="preserve">
          <source>NumPy &lt;a href=&quot;#term-object-array&quot;&gt;object arrays&lt;/a&gt;, which contain references to Python objects, fill the role of heterogeneous arrays.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd7856c2dbbcca63221ed726f4aced6db4c3c7ff" translate="yes" xml:space="preserve">
          <source>NumPy API Reference</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="de84e2593a0db73fdbbba3a6d668459795665a8b" translate="yes" xml:space="preserve">
          <source>NumPy API reference</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f41afbb931d30bf51df3c5d024df1c8569665b6f" translate="yes" xml:space="preserve">
          <source>NumPy Array Scalars and SWIG</source>
          <target state="translated">Скаляры числовых массивов и SWIG</target>
        </trans-unit>
        <trans-unit id="51ad55a9768d51db51dfc0fe1a4177bdd94eb2e8" translate="yes" xml:space="preserve">
          <source>NumPy C API</source>
          <target state="translated">NumPy C API</target>
        </trans-unit>
        <trans-unit id="3ee0e4047919b43a08c3c67ba0e3fc5e60d9cdaa" translate="yes" xml:space="preserve">
          <source>NumPy C Code Explanations</source>
          <target state="translated">NumPy C Код Пояснения</target>
        </trans-unit>
        <trans-unit id="e338b3196336652494be7c1852eae3cde59bd702" translate="yes" xml:space="preserve">
          <source>NumPy C Style Guide</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="808f9bc55e71edfa349e88dbc3b76c5d2e90cc3f" translate="yes" xml:space="preserve">
          <source>NumPy C style guide</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b6796af8c026b629052c1b19daa9ac3e40093d9f" translate="yes" xml:space="preserve">
          <source>NumPy C-API</source>
          <target state="translated">NumPy C-API</target>
        </trans-unit>
        <trans-unit id="a1586bc86c3a6e96b55470571a3b7966155b62c1" translate="yes" xml:space="preserve">
          <source>NumPy Code of Conduct</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1435e02825452fed2fb68e6c73bfa4d34ac784c1" translate="yes" xml:space="preserve">
          <source>NumPy Code of Conduct - How to follow up on a report</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d68b43adfe65e0ada7943e8e901732e697fd8106" translate="yes" xml:space="preserve">
          <source>NumPy Contributor Guide</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd9b8569488631e17e9c539e945f4151de6b16a5" translate="yes" xml:space="preserve">
          <source>NumPy Distutils - Users Guide</source>
          <target state="translated">NumPy Distutils-Руководство пользователя</target>
        </trans-unit>
        <trans-unit id="c956147a86ea5dbf2bd113161d5a9a92844fee2c" translate="yes" xml:space="preserve">
          <source>NumPy Distutils preprocesses C source files (extension: &lt;code&gt;.c.src&lt;/code&gt;) written in a custom templating language to generate C code. The &lt;code&gt;@&lt;/code&gt; symbol is used to wrap macro-style variables to empower a string substitution mechanism that might describe (for instance) a set of data types.</source>
          <target state="translated">NumPy Distutils предварительно обрабатывает исходные файлы C (расширение: &lt;code&gt;.c.src&lt;/code&gt; ), написанные на настраиваемом языке шаблонов, для генерации кода C. Символ &lt;code&gt;@&lt;/code&gt; используется для обертывания переменных в стиле макроса, чтобы дать возможность механизму подстановки строк, который может описывать (например) набор типов данных.</target>
        </trans-unit>
        <trans-unit id="6d3daec11f336cbe9aa58a4987acc6154b7a71ca" translate="yes" xml:space="preserve">
          <source>NumPy Docs</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a87b70e72189be1c91039076031182a00ca8a4a2" translate="yes" xml:space="preserve">
          <source>NumPy Documentation</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d11f236a358860bc1630b35d02b897f965a3abe6" translate="yes" xml:space="preserve">
          <source>NumPy Enhancement Proposal (NEP) 32, &lt;a href=&quot;https://numpy.org/neps/nep-0032-remove-financial-functions.html&quot;&gt;https://numpy.org/neps/nep-0032-remove-financial-functions.html&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a3f4b91200bead38a769f70a1e46a5128f09c922" translate="yes" xml:space="preserve">
          <source>NumPy Enhancement Proposals</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b610e33661eed30d2fd4d5c8298056db2d15c3b" translate="yes" xml:space="preserve">
          <source>NumPy How Tos</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="00b77a99ad474e5c770e0ddd949ded46acfaf38e" translate="yes" xml:space="preserve">
          <source>NumPy Issues: &lt;a href=&quot;https://github.com/numpy/numpy/issues&quot;&gt;https://github.com/numpy/numpy/issues&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b07568fa1b23354307b498eba5947dd449b1ae50" translate="yes" xml:space="preserve">
          <source>NumPy License</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df1797f9e232d63f819933885e2ac94ec0352d11" translate="yes" xml:space="preserve">
          <source>NumPy Reference</source>
          <target state="translated">NumPy Ссылка</target>
        </trans-unit>
        <trans-unit id="23bd4c05c1a40776eacbfc3e62d23e6f2151bb0f" translate="yes" xml:space="preserve">
          <source>NumPy Reference, section &lt;a href=&quot;https://docs.scipy.org/doc/numpy/reference/c-api.generalized-ufuncs.html&quot;&gt;Generalized Universal Function API&lt;/a&gt;.</source>
          <target state="translated">Справочник NumPy, раздел &lt;a href=&quot;https://docs.scipy.org/doc/numpy/reference/c-api.generalized-ufuncs.html&quot;&gt;Обобщенный API универсальных функций&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ba14bf798691d10d0084ffd0e5302c3bb4aff789" translate="yes" xml:space="preserve">
          <source>NumPy Scalars are cast when assigned to arrays</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bcf67cf31bc3a7972c91a07dd966f1740a8d146e" translate="yes" xml:space="preserve">
          <source>NumPy Tutorials</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da31cee45cf66b17220997ed18c1c784b896e561" translate="yes" xml:space="preserve">
          <source>NumPy User Guide, section &lt;a href=&quot;https://docs.scipy.org/doc/numpy/user/basics.io.genfromtxt.html&quot;&gt;I/O with NumPy&lt;/a&gt;.</source>
          <target state="translated">Руководство пользователя NumPy, раздел &lt;a href=&quot;https://docs.scipy.org/doc/numpy/user/basics.io.genfromtxt.html&quot;&gt;I / O с NumPy&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="dfb797f6ad28f48ccb741b2ddb48976e23e00a3f" translate="yes" xml:space="preserve">
          <source>NumPy allows the subtraction of two Datetime values, an operation which produces a number with a time unit. Because NumPy doesn&amp;rsquo;t have a physical quantities system in its core, the timedelta64 data type was created to complement datetime64.</source>
          <target state="translated">NumPy позволяет вычитать два значения Datetime, операция, которая производит число с единицей времени. Поскольку в ядре NumPy нет системы физических величин, тип данных timedelta64 был создан для дополнения datetime64.</target>
        </trans-unit>
        <trans-unit id="f9dacbde768b51aaba6413e3c788f0b194b5b375" translate="yes" xml:space="preserve">
          <source>NumPy allows the subtraction of two Datetime values, an operation which produces a number with a time unit. Because NumPy doesn&amp;rsquo;t have a physical quantities system in its core, the timedelta64 data type was created to complement datetime64. The arguments for timedelta64 are a number, to represent the number of units, and a date/time unit, such as (D)ay, (M)onth, (Y)ear, (h)ours, (m)inutes, or (s)econds. The timedelta64 data type also accepts the string &amp;ldquo;NAT&amp;rdquo; in place of the number for a &amp;ldquo;Not A Time&amp;rdquo; value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="750ef31835ba51a139fefe6ca7653831fa1d642d" translate="yes" xml:space="preserve">
          <source>NumPy also performs aggregation functions. In addition to &lt;code&gt;min&lt;/code&gt;, &lt;code&gt;max&lt;/code&gt;, and &lt;code&gt;sum&lt;/code&gt;, you can easily run &lt;code&gt;mean&lt;/code&gt; to get the average, &lt;code&gt;prod&lt;/code&gt; to get the result of multiplying the elements together, &lt;code&gt;std&lt;/code&gt; to get the standard deviation, and more.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3681d5d48b000e09eb74bcf9d80a233df272bb0f" translate="yes" xml:space="preserve">
          <source>NumPy and SWIG</source>
          <target state="translated">NumPy и SWIG</target>
        </trans-unit>
        <trans-unit id="c826d8c52c25e4bbad4a786ac8dfdcf96c8f11ac" translate="yes" xml:space="preserve">
          <source>NumPy and Swig</source>
          <target state="translated">NumPy и Swig</target>
        </trans-unit>
        <trans-unit id="378b259740f670c18f15c2234a2938b6e65c8a3f" translate="yes" xml:space="preserve">
          <source>NumPy array slicing uses pass-by-reference, that does not copy the arguments. Slicing operations are views into an array.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a3f3f40987eacf79da1da15ffc970ce1ce8e5996" translate="yes" xml:space="preserve">
          <source>NumPy arrays are &lt;strong&gt;not&lt;/strong&gt; directly &lt;a href=&quot;https://github.com/numpy/numpy/issues/12481&quot;&gt;JSON serializable&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd9f76864b0123b6e81c3abbfaba07bd1a398902" translate="yes" xml:space="preserve">
          <source>NumPy arrays are faster and more compact than Python lists. An array consumes less memory and is convenient to use. NumPy uses much less memory to store data and it provides a mechanism of specifying the data types. This allows the code to be optimized even further.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="45e9cb3043e5f97824505a55cbdfc5294d3ba613" translate="yes" xml:space="preserve">
          <source>NumPy arrays consist of two major components, the raw array data (from now on, referred to as the data buffer), and the information about the raw array data. The data buffer is typically what people think of as arrays in C or Fortran, a contiguous (and fixed) block of memory containing fixed sized data items. NumPy also contains a significant set of data that describes how to interpret the data in the data buffer. This extra information contains (among other things):</source>
          <target state="translated">Массивы NumPy состоят из двух основных компонентов:необработанных данных массива (отныне называемого буфером данных)и информации о необработанных данных массива.Буфер данных-это,как правило,то,что люди думают как массивы в C или Fortran,смежный (и фиксированный)блок памяти,содержащий элементы данных фиксированного размера.NumPy также содержит значительный набор данных,который описывает,как интерпретировать данные в буфере данных.Эта дополнительная информация содержит (среди прочего):</target>
        </trans-unit>
        <trans-unit id="064ff558785222ad92d746322b42cf271317a323" translate="yes" xml:space="preserve">
          <source>NumPy arrays facilitate advanced mathematical and other types of operations on large numbers of data. Typically, such operations are executed more efficiently and with less code than is possible using Python&amp;rsquo;s built-in sequences.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f9df6ed13e1a0bf8dd7a4da9cdb0f04829d71462" translate="yes" xml:space="preserve">
          <source>NumPy arrays have a fixed size at creation, unlike Python lists (which can grow dynamically). Changing the size of an &lt;code&gt;ndarray&lt;/code&gt; will create a new array and delete the original.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b9a2b1964b63758771b415bd46c81a550e3302e2" translate="yes" xml:space="preserve">
          <source>NumPy arrays may be indexed with other arrays (or any other sequence- like object that can be converted to an array, such as lists, with the exception of tuples; see the end of this document for why this is). The use of index arrays ranges from simple, straightforward cases to complex, hard-to-understand cases. For all cases of index arrays, what is returned is a copy of the original data, not a view as one gets for slices.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f594d6227d1e21e95a87fa36149ce8ba56ba3bd8" translate="yes" xml:space="preserve">
          <source>NumPy arrays with a structured dtype can also be viewed as &lt;a href=&quot;../reference/generated/numpy.recarray#numpy.recarray&quot;&gt;&lt;code&gt;recarray&lt;/code&gt;&lt;/a&gt;, where a field can be accessed as if it were an attribute. For that reason, we may need to make sure that the field name doesn&amp;rsquo;t contain any space or invalid character, or that it does not correspond to the name of a standard attribute (like &lt;code&gt;size&lt;/code&gt; or &lt;code&gt;shape&lt;/code&gt;), which would confuse the interpreter. &lt;a href=&quot;../reference/generated/numpy.genfromtxt#numpy.genfromtxt&quot;&gt;&lt;code&gt;genfromtxt&lt;/code&gt;&lt;/a&gt; accepts three optional arguments that provide a finer control on the names:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9ddb7bcd5abd45f2c144892bcef25d7ca724d758" translate="yes" xml:space="preserve">
          <source>NumPy assigns by reference</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac46c4db4be1d2bf47d471c892c8666f70fae9c0" translate="yes" xml:space="preserve">
          <source>NumPy basics</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a5ee6decc812823bbb32d4c52868169ed0e2dc6" translate="yes" xml:space="preserve">
          <source>NumPy benchmarks</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="acba6e54dd52e6409526789be99f698cf4b66810" translate="yes" xml:space="preserve">
          <source>NumPy binary files (NPY, NPZ)</source>
          <target state="translated">Двоичные файлы NumPy (NPY,NPZ)</target>
        </trans-unit>
        <trans-unit id="24422cd746cd54c121886f257099a4c4b493866b" translate="yes" xml:space="preserve">
          <source>NumPy can be tested in a number of ways, choose any way you feel comfortable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e2731ffa90b7c735aae8e17474bd85f4ca800f4d" translate="yes" xml:space="preserve">
          <source>NumPy can do operations on arrays whose shapes are mismatched:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d16a651e79e36287ab38bac721290bfd05bc2a01" translate="yes" xml:space="preserve">
          <source>NumPy comes with 24 builtin data-types. While this covers a large majority of possible use cases, it is conceivable that a user may have a need for an additional data-type. There is some support for adding an additional data-type into the NumPy system. This additional data- type will behave much like a regular data-type except ufuncs must have 1-d loops registered to handle it separately. Also checking for whether or not other data-types can be cast &amp;ldquo;safely&amp;rdquo; to and from this new type or not will always return &amp;ldquo;can cast&amp;rdquo; unless you also register which types your new data-type can be cast to and from.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e0f2beec853b334d966939a6cfbd8740cabbc29f" translate="yes" xml:space="preserve">
          <source>NumPy community</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="587dfdb00740f1bca4ab2388a780e1daaf9e9438" translate="yes" xml:space="preserve">
          <source>NumPy contains both an &lt;code&gt;array&lt;/code&gt; class and a &lt;code&gt;matrix&lt;/code&gt; class. The &lt;code&gt;array&lt;/code&gt; class is intended to be a general-purpose n-dimensional array for many kinds of numerical computing, while &lt;code&gt;matrix&lt;/code&gt; is intended to facilitate linear algebra computations specifically. In practice there are only a handful of key differences between the two.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="648b2c826e9dca058d52cb253a3629a695c1c05a" translate="yes" xml:space="preserve">
          <source>NumPy contributor guide</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e9e0392d352bfceb00b69b8aae489d3cfcd35b94" translate="yes" xml:space="preserve">
          <source>NumPy core libraries</source>
          <target state="translated">Библиотеки ядра NumPy</target>
        </trans-unit>
        <trans-unit id="ccf16bd0788fff6636ddfa05a6cb0f611b1a5988" translate="yes" xml:space="preserve">
          <source>NumPy core math library</source>
          <target state="translated">основная математическая библиотека NumPy</target>
        </trans-unit>
        <trans-unit id="973c555328d9b9a87fd43d16a1a900328d00f946" translate="yes" xml:space="preserve">
          <source>NumPy data type descriptions are instances of the &lt;a href=&quot;generated/numpy.dtype#numpy.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt; class.</source>
          <target state="translated">Описания типов данных NumPy являются экземплярами класса &lt;a href=&quot;generated/numpy.dtype#numpy.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="978f537fd61d02bcc51970587f176772f017251f" translate="yes" xml:space="preserve">
          <source>NumPy dispatcher is based on multi-source compiling, which means taking a certain source and compiling it multiple times with different compiler flags and also with different &lt;strong&gt;C&lt;/strong&gt; definitions that affect the code paths to enable certain instruction-sets for each compiled object depending on the required optimizations, then combining the returned objects together.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be9b40e5263a5085939745fd3402fa19fc002ecb" translate="yes" xml:space="preserve">
          <source>NumPy distutils - users guide</source>
          <target state="translated">Дистилляторы NumPy-руководство пользователя</target>
        </trans-unit>
        <trans-unit id="7682241df5064b6dcd3fa7f5b4aadf68c8c520d1" translate="yes" xml:space="preserve">
          <source>NumPy distutils supports automatic conversion of source files named &amp;lt;somefile&amp;gt;.src. This facility can be used to maintain very similar code blocks requiring only simple changes between blocks. During the build phase of setup, if a template file named &amp;lt;somefile&amp;gt;.src is encountered, a new file named &amp;lt;somefile&amp;gt; is constructed from the template and placed in the build directory to be used instead. Two forms of template conversion are supported. The first form occurs for files named &amp;lt;file&amp;gt;.ext.src where ext is a recognized Fortran extension (f, f90, f95, f77, for, ftn, pyf). The second form is used for all other cases.</source>
          <target state="translated">NumPy distutils поддерживает автоматическое преобразование исходных файлов с именем &amp;lt;somefile&amp;gt; .src. Это средство можно использовать для поддержки очень похожих блоков кода, требующих только простых изменений между блоками. Если на этапе сборки установки встречается файл шаблона с именем &amp;lt;somefile&amp;gt; .src, новый файл с именем &amp;lt;somefile&amp;gt; создается из шаблона и помещается в каталог сборки, который будет использоваться вместо него. Поддерживаются две формы преобразования шаблонов. Первая форма встречается для файлов с именем &amp;lt;file&amp;gt; .ext.src, где ext - это распознанное расширение Fortran (f, f90, f95, f77, for, ftn, pyf). Вторая форма используется для всех остальных случаев.</target>
        </trans-unit>
        <trans-unit id="52e91b4c51a9db40b4247ecf6771ad0f610935f6" translate="yes" xml:space="preserve">
          <source>NumPy distutils supports automatic conversion of source files named &amp;lt;somefile&amp;gt;.src. This facility can be used to maintain very similar code blocks requiring only simple changes between blocks. During the build phase of setup, if a template file named &amp;lt;somefile&amp;gt;.src is encountered, a new file named &amp;lt;somefile&amp;gt; is constructed from the template and placed in the build directory to be used instead. Two forms of template conversion are supported. The first form occurs for files named &amp;lt;file&amp;gt;.ext.src where ext is a recognized Fortran extension (f, f90, f95, f77, for, ftn, pyf). The second form is used for all other cases. See &lt;a href=&quot;distutils_guide#templating&quot;&gt;Conversion of .src files using Templates&lt;/a&gt;.</source>
          <target state="translated">NumPy distutils поддерживает автоматическое преобразование исходных файлов с именем &amp;lt;somefile&amp;gt; .src. Это средство можно использовать для поддержки очень похожих блоков кода, требующих только простых изменений между блоками. Если на этапе сборки установки встречается файл шаблона с именем &amp;lt;somefile&amp;gt; .src, новый файл с именем &amp;lt;somefile&amp;gt; создается из шаблона и помещается в каталог сборки, который будет использоваться вместо него. Поддерживаются две формы преобразования шаблонов. Первая форма встречается для файлов с именем &amp;lt;file&amp;gt; .ext.src, где ext - это распознанное расширение Fortran (f, f90, f95, f77, for, ftn, pyf). Вторая форма используется для всех остальных случаев. См. &lt;a href=&quot;distutils_guide#templating&quot;&gt;Преобразование файлов .src с использованием шаблонов&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="62cb8c054f8f025824b221606b89da66fb01bcbf" translate="yes" xml:space="preserve">
          <source>NumPy docs have the details covered. API reference documentation is generated directly from &lt;a href=&quot;https://www.python.org/dev/peps/pep-0257/&quot;&gt;docstrings&lt;/a&gt; in the code when the documentation is &lt;a href=&quot;../docs/howto_build_docs#howto-build-docs&quot;&gt;built&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1fd1726df240b387443461a0936d41d6367c1cbf" translate="yes" xml:space="preserve">
          <source>NumPy documentation is kept in the source code tree. To get your document into the docbase you must download the tree, &lt;a href=&quot;../docs/howto_build_docs#howto-build-docs&quot;&gt;build it&lt;/a&gt;, and submit a pull request. If GitHub and pull requests are new to you, check our &lt;a href=&quot;index#devindex&quot;&gt;Contributor Guide&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ec067cc97926d6f20fb73fa3184c126e233e754" translate="yes" xml:space="preserve">
          <source>NumPy does not provide a dtype with more precision than C&amp;rsquo;s &lt;code&gt;long double&lt;/code&gt;; in particular, the 128-bit IEEE quad precision data type (FORTRAN&amp;rsquo;s &lt;code&gt;REAL*16&lt;/code&gt;) is not available.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="71b5f2ddae9a416483671c90287f2072fd0042bc" translate="yes" xml:space="preserve">
          <source>NumPy does not provide a dtype with more precision than C&amp;rsquo;s &lt;code&gt;long double&lt;/code&gt;\; in particular, the 128-bit IEEE quad precision data type (FORTRAN&amp;rsquo;s &lt;code&gt;REAL*16&lt;/code&gt;\) is not available.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba5d51a5b62b750c1604f2d01dcf736580720f16" translate="yes" xml:space="preserve">
          <source>NumPy does not require any external linear algebra libraries to be installed. However, if these are available, NumPy&amp;rsquo;s setup script can detect them and use them for building. A number of different LAPACK library setups can be used, including optimized LAPACK libraries such as OpenBLAS or MKL. The choice and location of these libraries as well as include paths and other such build options can be specified in a &lt;code&gt;site.cfg&lt;/code&gt; file located in the NumPy root repository or a &lt;code&gt;.numpy-site.cfg&lt;/code&gt; file in your home directory. See the &lt;code&gt;site.cfg.example&lt;/code&gt; example file included in the NumPy repository or sdist for documentation, and below for specifying search priority from environmental variables.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c7a95170c1892d84e44be0593492dbf2a5886a93" translate="yes" xml:space="preserve">
          <source>NumPy doesn&amp;rsquo;t have a C function documentation standard at this time, but needs one. Most numpy functions are not documented in the code and that should change. One possibility is Doxygen with a plugin so that the same NumPy style used for Python functions can also be used for documenting C functions, see the files in doc/cdoc/.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8f68fa749d0083be9916fd2a5a507830517a2a85" translate="yes" xml:space="preserve">
          <source>NumPy for MATLAB users</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e2d7988a962e51ca82f6767321b92e79ba1d8ec3" translate="yes" xml:space="preserve">
          <source>NumPy for Matlab users</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c4cda8cf1f381ff8936b6e543e5a88f49fb98417" translate="yes" xml:space="preserve">
          <source>NumPy fully supports an object-oriented approach, starting, once again, with &lt;code&gt;ndarray&lt;/code&gt;. For example, &lt;code&gt;ndarray&lt;/code&gt; is a class, possessing numerous methods and attributes. Many of its methods are mirrored by functions in the outer-most NumPy namespace, allowing the programmer to code in whichever paradigm they prefer. This flexibility has allowed the NumPy array dialect and NumPy &lt;code&gt;ndarray&lt;/code&gt; class to become the &lt;em&gt;de-facto&lt;/em&gt; language of multi-dimensional data interchange used in Python.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4900e8d811971de762aa8ebe80dcd63c7e850d2e" translate="yes" xml:space="preserve">
          <source>NumPy functions now always support overrides with &lt;code&gt;__array_function__&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e2f30850bdb0a0d23d96244e831d9063c220901" translate="yes" xml:space="preserve">
          <source>NumPy functions now support overrides with &lt;code&gt;__array_function__&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="832b7ee6576dfafa6af4c3707e511d8557196774" translate="yes" xml:space="preserve">
          <source>NumPy generally returns elements of arrays as array scalars (a scalar with an associated dtype). Array scalars differ from Python scalars, but for the most part they can be used interchangeably (the primary exception is for versions of Python older than v2.x, where integer array scalars cannot act as indices for lists and tuples). There are some exceptions, such as when code requires very specific attributes of a scalar or when it checks specifically whether a value is a Python scalar. Generally, problems are easily fixed by explicitly converting array scalars to Python scalars, using the corresponding Python type function (e.g., &lt;code&gt;int&lt;/code&gt;, &lt;code&gt;float&lt;/code&gt;, &lt;code&gt;complex&lt;/code&gt;, &lt;code&gt;str&lt;/code&gt;, &lt;code&gt;unicode&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="890be7939c4a57f24699a49e8b1d3523457ca863" translate="yes" xml:space="preserve">
          <source>NumPy gives us the best of both worlds: element-by-element operations are the &amp;ldquo;default mode&amp;rdquo; when an &lt;code&gt;ndarray&lt;/code&gt; is involved, but the element-by-element operation is speedily executed by pre-compiled C code. In NumPy</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c84a4092d43fdae4261d3327c4c544413793832" translate="yes" xml:space="preserve">
          <source>NumPy gives you an enormous range of fast and efficient ways of creating arrays and manipulating numerical data inside them. While a Python list can contain different data types within a single list, all of the elements in a NumPy array should be homogeneous. The mathematical operations that are meant to be performed on arrays would be extremely inefficient if the arrays weren&amp;rsquo;t homogeneous.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d4e59636db0bed7b9eb085bfb86e99aa0957bc34" translate="yes" xml:space="preserve">
          <source>NumPy gives you an enormous range of fast and efficient ways of creating arrays and manipulating numerical data inside them. While a Python list can contain different data types within a single list, all of the elements in a NumPy array should be homogenous. The mathematical operations that are meant to be performed on arrays would be extremely inefficient if the arrays weren&amp;rsquo;t homogenous.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce24f4bb69b1ac53e640f756f04696d112954c58" translate="yes" xml:space="preserve">
          <source>NumPy governance</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fadfd147c1bce43e0bd90025c0c918f23b1fb090" translate="yes" xml:space="preserve">
          <source>NumPy hands off array processing to C, where looping and computation are much faster than in Python. To exploit this, programmers using NumPy eliminate Python loops in favor of array-to-array operations. &lt;a href=&quot;#term-vectorization&quot;&gt;vectorization&lt;/a&gt; can refer both to the C offloading and to structuring NumPy code to leverage it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="33fab98fb581f98170a2f8d5e454b21a4a9ae970" translate="yes" xml:space="preserve">
          <source>NumPy has a Documentation Team. We have open meetings on Zoom every three weeks and invite everyone to join. Don&amp;rsquo;t hesitate to reach out if you have questions or just need someone to guide you through your first steps - we&amp;rsquo;re always happy to help. Meetings are usually announced on the &lt;a href=&quot;https://mail.python.org/mailman/listinfo/numpy-discussion&quot;&gt;numpy-discussion mailing list&lt;/a&gt;. Meeting minutes are taken &lt;a href=&quot;https://hackmd.io/oB_boakvRqKR-_2jRV-Qjg&quot;&gt;on hackmd.io&lt;/a&gt; and stored in the &lt;a href=&quot;https://github.com/numpy/archive&quot;&gt;NumPy Archive repository&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1252a4902fb7242313c7e4fd534a4effe97cd036" translate="yes" xml:space="preserve">
          <source>NumPy has a few import-time, compile-time, or runtime options which change the global behaviour. Most of these are related to performance or for debugging purposes and will not be interesting to the vast majority of users.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99117692035516c5cb720484aff4e4e585660600" translate="yes" xml:space="preserve">
          <source>NumPy has a set of rules for dealing with arrays that have differing shapes which are applied whenever functions take multiple operands which combine element-wise. This is called &lt;a href=&quot;ufuncs#ufuncs-broadcasting&quot;&gt;broadcasting&lt;/a&gt;. The &lt;a href=&quot;generated/numpy.nditer#numpy.nditer&quot;&gt;&lt;code&gt;nditer&lt;/code&gt;&lt;/a&gt; object can apply these rules for you when you need to write such a function.</source>
          <target state="translated">В NumPy есть набор правил для работы с массивами различной формы, которые применяются всякий раз, когда функции принимают несколько операндов, которые объединяются поэлементно. Это называется &lt;a href=&quot;ufuncs#ufuncs-broadcasting&quot;&gt;трансляцией&lt;/a&gt; . Объект &lt;a href=&quot;generated/numpy.nditer#numpy.nditer&quot;&gt; &lt;code&gt;nditer&lt;/code&gt; &lt;/a&gt; может применить эти правила, когда вам нужно написать такую ​​функцию.</target>
        </trans-unit>
        <trans-unit id="333e27cc5487f69edc109f8bd0d8086fc2dbda03" translate="yes" xml:space="preserve">
          <source>NumPy has built-in functions for creating arrays from scratch:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="60168f40b56e28aca9cf44fb018703394a1b278b" translate="yes" xml:space="preserve">
          <source>NumPy has the following versioning scheme (numbers given are examples; they can be &amp;gt; 9) in principle):</source>
          <target state="translated">NumPy имеет следующую схему управления версиями (числа приведены в качестве примеров; в принципе они могут быть&amp;gt; 9):</target>
        </trans-unit>
        <trans-unit id="79eee1716a93d0c26d644ba6dc16d49583d1dea3" translate="yes" xml:space="preserve">
          <source>NumPy includes several constants:</source>
          <target state="translated">NumPy включает в себя несколько констант:</target>
        </trans-unit>
        <trans-unit id="7f95e3acee5a2de64945dfe9e2cae9083154d9ea" translate="yes" xml:space="preserve">
          <source>NumPy internals</source>
          <target state="translated">внутренние органы Нумерологии</target>
        </trans-unit>
        <trans-unit id="6dae93447071b4ec5703dcc87628e48329941095" translate="yes" xml:space="preserve">
          <source>NumPy is a community-owned and community-run project. To the maximum extent possible, decisions about project direction are made by community consensus (but note that &amp;ldquo;consensus&amp;rdquo; here has a somewhat technical meaning that might not match everyone&amp;rsquo;s expectations &amp;ndash; see below). Some members of the community additionally contribute by serving on the NumPy steering council, where they are responsible for facilitating the establishment of community consensus, for stewarding project resources, and &amp;ndash; in extreme cases &amp;ndash; for making project decisions if the normal community-based process breaks down.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99f4695ea1e6796c3681301e16dfcf7c8b735296" translate="yes" xml:space="preserve">
          <source>NumPy is a distributed, volunteer, open-source project. &lt;em&gt;You&lt;/em&gt; can help us make it better; if you believe something should be improved either in functionality or in documentation, don&amp;rsquo;t hesitate to contact us &amp;mdash; or even better, contact us and participate in fixing the problem.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="991ba5f7e8a9558d2bf270584d8056914d9ad664" translate="yes" xml:space="preserve">
          <source>NumPy is a successor for two earlier scientific Python libraries: Numeric and Numarray.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e2a33b46873f26a8ea57c12754716a4bc2bae10" translate="yes" xml:space="preserve">
          <source>NumPy is based on Python, a general-purpose language. The advantage to NumPy is access to Python libraries including: &lt;a href=&quot;https://www.scipy.org/&quot;&gt;SciPy&lt;/a&gt;, &lt;a href=&quot;https://matplotlib.org/&quot;&gt;Matplotlib&lt;/a&gt;, &lt;a href=&quot;https://pandas.pydata.org/&quot;&gt;Pandas&lt;/a&gt;, &lt;a href=&quot;https://opencv.org/&quot;&gt;OpenCV&lt;/a&gt;, and more. In addition, Python is often &lt;a href=&quot;https://en.wikipedia.org/wiki/List_of_Python_software#Embedded_as_a_scripting_language&quot;&gt;embedded as a scripting language&lt;/a&gt; in other software, allowing NumPy to be used there too.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0402fb92221bd3cd2c68208cc2865ddc5a180086" translate="yes" xml:space="preserve">
          <source>NumPy is based on Python, which was designed from the outset to be an excellent general-purpose programming language. While Matlab&amp;rsquo;s syntax for some array manipulations is more compact than NumPy&amp;rsquo;s, NumPy (by virtue of being an add-on to Python) can do many things that Matlab just cannot, for instance dealing properly with stacks of matrices.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0a1930f65134cee5b200e1969765b9f9a7fa7a24" translate="yes" xml:space="preserve">
          <source>NumPy is now typed</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6eab1c6f817d74852716edac9ada3c155fd78dc5" translate="yes" xml:space="preserve">
          <source>NumPy is the fundamental package for scientific computing in Python. It is a Python library that provides a multidimensional array object, various derived objects (such as masked arrays and matrices), and an assortment of routines for fast operations on arrays, including mathematical, logical, shape manipulation, sorting, selecting, I/O, discrete Fourier transforms, basic linear algebra, basic statistical operations, random simulation and much more.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0da01ca615e98a9d3de5876bf011bc4feb765cc1" translate="yes" xml:space="preserve">
          <source>NumPy is the fundamental package needed for scientific computing with Python. This package contains:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2707988141b2528631eeb146c6abc6ae889534d6" translate="yes" xml:space="preserve">
          <source>NumPy is very flexible. Trying to describe the full range of possibilities statically would result in types that are not very helpful. For that reason, the typed NumPy API is often stricter than the runtime NumPy API. This section describes some notable differences.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a0842da7a3c9a631b811fb55a0710af0d36229b7" translate="yes" xml:space="preserve">
          <source>NumPy itself is normally intentionally limited to a single thread during function calls, however it does support multiple Python threads running at the same time. Note that for performant linear algebra NumPy uses a BLAS backend such as OpenBLAS or MKL, which may use multiple threads that may be controlled by environment variables such as &lt;code&gt;OMP_NUM_THREADS&lt;/code&gt; depending on what is used. One way to control the number of threads is the package &lt;a href=&quot;https://pypi.org/project/threadpoolctl/&quot;&gt;threadpoolctl&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa3d14564899f1e1d8b53467e884e70e752511fc" translate="yes" xml:space="preserve">
          <source>NumPy license</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c6c5b9ca35b73a4c5ad8cc11ecf764298cf0bacc" translate="yes" xml:space="preserve">
          <source>NumPy may be built with relaxed stride checking debugging</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e53e90e7b656a00b8ffca88bb6b89ffe64b4a95" translate="yes" xml:space="preserve">
          <source>NumPy numerical types are instances of &lt;code&gt;dtype&lt;/code&gt; (data-type) objects, each having unique characteristics. Once you have imported NumPy using</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="385beaafbdefdbe97d289ec18bd9e262a0ed8458" translate="yes" xml:space="preserve">
          <source>NumPy offers more indexing facilities than regular Python sequences. In addition to indexing by integers and slices, as we saw before, arrays can be indexed by arrays of integers and arrays of booleans.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="14ac2c9d8a2fd7d4b8f16afdbb4951561e207021" translate="yes" xml:space="preserve">
          <source>NumPy operations are usually done on pairs of arrays on an element-by-element basis. In the simplest case, the two arrays must have exactly the same shape, as in the following example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0aab5ecc0999cd974eb3c7668641606fa9f4eb6b" translate="yes" xml:space="preserve">
          <source>NumPy project governance and decision-making</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="344b2ccffdbc846784cb6ec3e6e0955c7148fb58" translate="yes" xml:space="preserve">
          <source>NumPy provides &lt;a href=&quot;../reference/generated/numpy.iinfo#numpy.iinfo&quot;&gt;&lt;code&gt;numpy.iinfo&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../reference/generated/numpy.finfo#numpy.finfo&quot;&gt;&lt;code&gt;numpy.finfo&lt;/code&gt;&lt;/a&gt; to verify the minimum or maximum values of NumPy integer and floating point values respectively</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e0b798355ee6b0ba0edb9030dee01599200313df" translate="yes" xml:space="preserve">
          <source>NumPy provides a C-API to enable users to extend the system and get access to the array object for use in other routines. The best way to truly understand the C-API is to read the source code. If you are unfamiliar with (C) source code, however, this can be a daunting experience at first. Be assured that the task becomes easier with practice, and you may be surprised at how simple the C-code can be to understand. Even if you don&amp;rsquo;t think you can write C-code from scratch, it is much easier to understand and modify already-written source code than create it &lt;em&gt;de novo&lt;/em&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c8046368fea8bda3d4541728b814c2be74d1348d" translate="yes" xml:space="preserve">
          <source>NumPy provides a C-API to enable users to extend the system and get access to the array object for use in other routines. The best way to truly understand the C-API is to read the source code. If you are unfamiliar with (C) source code, however, this can be a daunting experience at first. Be assured that the task becomes easier with practice, and you may be surprised at how simple the C-code can be to understand. Even if you don&amp;rsquo;t think you can write C-code from scratch, it is much easier to understand and modify already-written source code then create it &lt;em&gt;de novo&lt;/em&gt;.</source>
          <target state="translated">NumPy предоставляет C-API, позволяющий пользователям расширять систему и получать доступ к объекту массива для использования в других процедурах. Лучший способ по-настоящему понять C-API - это прочитать исходный код. Однако, если вы не знакомы с исходным кодом (C), поначалу это может быть пугающим опытом. Будьте уверены, что с практикой задача станет проще, и вы можете быть удивлены тем, насколько простым может быть C-код для понимания. Даже если вы не думаете, что можете написать C-код с нуля, гораздо проще понять и изменить уже написанный исходный код, а затем создать его &lt;em&gt;de novo&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="93fc0aec43944a02522a3921ad457b6e9255c9c4" translate="yes" xml:space="preserve">
          <source>NumPy provides a convenience function called &lt;code&gt;ctypeslib.load_library&lt;/code&gt; (name, path). This function takes the name of the shared library (including any prefix like &amp;lsquo;lib&amp;rsquo; but excluding the extension) and a path where the shared library can be located. It returns a ctypes library object or raises an &lt;code&gt;OSError&lt;/code&gt; if the library cannot be found or raises an &lt;code&gt;ImportError&lt;/code&gt; if the ctypes module is not available. (Windows users: the ctypes library object loaded using &lt;code&gt;load_library&lt;/code&gt; is always loaded assuming cdecl calling convention. See the ctypes documentation under &lt;code&gt;ctypes.windll&lt;/code&gt; and/or &lt;code&gt;ctypes.oledll&lt;/code&gt; for ways to load libraries under other calling conventions).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1cfa01d82f003cb630031c6b813526f750ab53b1" translate="yes" xml:space="preserve">
          <source>NumPy provides a set of macros that define &lt;a href=&quot;https://numpy.org/neps/nep-0038-SIMD-optimizations.html&quot;&gt;Universal Intrinsics&lt;/a&gt; to abstract out typical platform-specific intrinsics so SIMD code needs to be written only once. There are three layers:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c7a7d5fdc3538cf929aee4c511ed8f06972767b8" translate="yes" xml:space="preserve">
          <source>NumPy provides an N-dimensional array type, the &lt;a href=&quot;arrays.ndarray#arrays-ndarray&quot;&gt;ndarray&lt;/a&gt;, which describes a collection of &amp;ldquo;items&amp;rdquo; of the same type. The items can be &lt;a href=&quot;arrays.indexing#arrays-indexing&quot;&gt;indexed&lt;/a&gt; using for example N integers.</source>
          <target state="translated">NumPy предоставляет N-мерный массив типа &lt;a href=&quot;arrays.ndarray#arrays-ndarray&quot;&gt;ndarray&lt;/a&gt; , который описывает коллекцию &amp;laquo;элементов&amp;raquo; одного и того же типа. Элементы можно &lt;a href=&quot;arrays.indexing#arrays-indexing&quot;&gt;проиндексировать,&lt;/a&gt; используя, например, N целых чисел.</target>
        </trans-unit>
        <trans-unit id="1a75765bb40779d587b945d346fd4f25656a32a8" translate="yes" xml:space="preserve">
          <source>NumPy provides enhanced distutils functionality to make it easier to build and install sub-packages, auto-generate code, and extension modules that use Fortran-compiled libraries. To use features of NumPy distutils, use the &lt;code&gt;setup&lt;/code&gt; command from &lt;code&gt;numpy.distutils.core&lt;/code&gt;. A useful &lt;a href=&quot;#numpy.distutils.misc_util.Configuration&quot;&gt;&lt;code&gt;Configuration&lt;/code&gt;&lt;/a&gt; class is also provided in &lt;a href=&quot;#module-numpy.distutils.misc_util&quot;&gt;&lt;code&gt;numpy.distutils.misc_util&lt;/code&gt;&lt;/a&gt; that can make it easier to construct keyword arguments to pass to the setup function (by passing the dictionary obtained from the todict() method of the class). More information is available in the &lt;a href=&quot;distutils_guide#distutils-user-guide&quot;&gt;NumPy Distutils - Users Guide&lt;/a&gt;.</source>
          <target state="translated">NumPy предоставляет расширенную функциональность distutils, чтобы упростить сборку и установку подпакетов, автогенерацию кода и модули расширения, которые используют скомпилированные библиотеки Fortran. Чтобы использовать функции NumPy distutils, используйте команду &lt;code&gt;setup&lt;/code&gt; из &lt;code&gt;numpy.distutils.core&lt;/code&gt; . Полезный класс &lt;a href=&quot;#numpy.distutils.misc_util.Configuration&quot;&gt; &lt;code&gt;Configuration&lt;/code&gt; &lt;/a&gt; также предоставляется в &lt;a href=&quot;#module-numpy.distutils.misc_util&quot;&gt; &lt;code&gt;numpy.distutils.misc_util&lt;/code&gt; ,&lt;/a&gt; который может упростить создание аргументов ключевого слова для передачи в функцию настройки (путем передачи словаря, полученного из метода todict () класса). Дополнительная информация доступна в &lt;a href=&quot;distutils_guide#distutils-user-guide&quot;&gt;NumPy Distutils - Руководство пользователя&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="dc45b2b061a3c987c044eb3531af83d969814354" translate="yes" xml:space="preserve">
          <source>NumPy provides enhanced distutils functionality to make it easier to build and install sub-packages, auto-generate code, and extension modules that use Fortran-compiled libraries. To use features of NumPy distutils, use the &lt;code&gt;setup&lt;/code&gt; command from &lt;code&gt;numpy.distutils.core&lt;/code&gt;. A useful &lt;a href=&quot;#numpy.distutils.misc_util.Configuration&quot;&gt;&lt;code&gt;Configuration&lt;/code&gt;&lt;/a&gt; class is also provided in &lt;a href=&quot;distutils/misc_util#module-numpy.distutils.misc_util&quot;&gt;&lt;code&gt;numpy.distutils.misc_util&lt;/code&gt;&lt;/a&gt; that can make it easier to construct keyword arguments to pass to the setup function (by passing the dictionary obtained from the todict() method of the class). More information is available in the &lt;a href=&quot;distutils_guide#distutils-user-guide&quot;&gt;NumPy Distutils - Users Guide&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a083cfd3cae0f2b0c71ffa2d89ecb4205930693" translate="yes" xml:space="preserve">
          <source>NumPy provides familiar mathematical functions such as sin, cos, and exp. In NumPy, these are called &amp;ldquo;universal functions&amp;rdquo;(&lt;code&gt;ufunc&lt;/code&gt;). Within NumPy, these functions operate elementwise on an array, producing an array as output.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a62542984876095dd49786ce30743b4af981559" translate="yes" xml:space="preserve">
          <source>NumPy provides several functions to create arrays from tabular data. We focus here on the &lt;a href=&quot;../reference/generated/numpy.genfromtxt#numpy.genfromtxt&quot;&gt;&lt;code&gt;genfromtxt&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="23cd70d7e4f84112d992fc760c41c139b7d9150b" translate="yes" xml:space="preserve">
          <source>NumPy provides several hooks that classes can customize:</source>
          <target state="translated">NumPy предоставляет несколько крючков,которые классы могут настраивать:</target>
        </trans-unit>
        <trans-unit id="db997f8d5529d90e4e824067ebfe5d83669d3578" translate="yes" xml:space="preserve">
          <source>NumPy provides the &lt;a href=&quot;generated/numpy.recarray#numpy.recarray&quot;&gt;&lt;code&gt;recarray&lt;/code&gt;&lt;/a&gt; class which allows accessing the fields of a structured array as attributes, and a corresponding scalar data type object &lt;a href=&quot;generated/numpy.record#numpy.record&quot;&gt;&lt;code&gt;record&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">NumPy предоставляет класс &lt;a href=&quot;generated/numpy.recarray#numpy.recarray&quot;&gt; &lt;code&gt;recarray&lt;/code&gt; ,&lt;/a&gt; который позволяет получить доступ к полям структурированного массива в качестве атрибутов и соответствующей &lt;a href=&quot;generated/numpy.record#numpy.record&quot;&gt; &lt;code&gt;record&lt;/code&gt; &lt;/a&gt; объекта скалярного типа данных .</target>
        </trans-unit>
        <trans-unit id="46067414ac2be3ec3b21adf1f81bfbaed905b370" translate="yes" xml:space="preserve">
          <source>NumPy quickstart</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2334ad60fc95510fca18811e881286378efc5596" translate="yes" xml:space="preserve">
          <source>NumPy refers to each dimension as an &lt;code&gt;axis&lt;/code&gt;. Because of how &lt;code&gt;imread&lt;/code&gt; works, the &lt;em&gt;first index in the 3rd axis&lt;/em&gt; is the red pixel data for our image. We can access this by using the syntax</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aaeae0e0ef5087fb1cba7dbba1eef7ee4ab1c725" translate="yes" xml:space="preserve">
          <source>NumPy searches for optimized linear algebra libraries such as BLAS and LAPACK. There are specific orders for searching these libraries, as described below and in the &lt;code&gt;site.cfg.example&lt;/code&gt; file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e6871239fcd860bb968e0e454a350e13641da17d" translate="yes" xml:space="preserve">
          <source>NumPy slices are by reference</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e0ea34766b2df6ce15b555bccc153c9453e468d7" translate="yes" xml:space="preserve">
          <source>NumPy slicing creates a &lt;a href=&quot;../glossary#term-view&quot;&gt;view&lt;/a&gt; instead of a copy as in the case of builtin Python sequences such as string, tuple and list. Care must be taken when extracting a small portion from a large array which becomes useless after the extraction, because the small portion extracted contains a reference to the large original array whose memory will not be released until all arrays derived from it are garbage-collected. In such cases an explicit &lt;code&gt;copy()&lt;/code&gt; is recommended.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b50bd9e44504ee882f7d36e3a1a29183cd10ae09" translate="yes" xml:space="preserve">
          <source>NumPy slicing creates a &lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/glossary.html#term-view&quot;&gt;view&lt;/a&gt; instead of a copy as in the case of builtin Python sequences such as string, tuple and list. Care must be taken when extracting a small portion from a large array which becomes useless after the extraction, because the small portion extracted contains a reference to the large original array whose memory will not be released until all arrays derived from it are garbage-collected. In such cases an explicit &lt;code&gt;copy()&lt;/code&gt; is recommended.</source>
          <target state="translated">Нарезка NumPy создает &lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/glossary.html#term-view&quot;&gt;представление&lt;/a&gt; вместо копии, как в случае встроенных последовательностей Python, таких как строка, кортеж и список. Необходимо соблюдать осторожность при извлечении небольшой части из большого массива, которая становится бесполезной после извлечения, потому что извлеченная небольшая часть содержит ссылку на большой исходный массив, память которого не будет освобождена до тех пор, пока все массивы, производные от него, не будут собраны мусором. В таких случаях рекомендуется явная &lt;code&gt;copy()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9315eaa766c603c7ff5592ed435945f3c4e579c8" translate="yes" xml:space="preserve">
          <source>NumPy stores an internal table of Python callable objects that are used to implement arithmetic operations for arrays as well as certain array calculation methods. This function allows the user to replace any or all of these Python objects with their own versions. The keys of the dictionary, &lt;em&gt;dict&lt;/em&gt;, are the named functions to replace and the paired value is the Python callable object to use. Care should be taken that the function used to replace an internal array operation does not itself call back to that internal array operation (unless you have designed the function to handle that), or an unchecked infinite recursion can result (possibly causing program crash). The key names that represent operations that can be replaced are:</source>
          <target state="translated">NumPy хранит внутреннюю таблицу вызываемых объектов Python, которые используются для реализации арифметических операций с массивами, а также некоторых методов вычисления массивов. Эта функция позволяет пользователю заменять любые или все эти объекты Python их собственными версиями. Ключи словаря &lt;em&gt;dict&lt;/em&gt; - это именованные функции, которые необходимо заменить, а парное значение - это вызываемый объект Python для использования. Следует позаботиться о том, чтобы функция, используемая для замены операции с внутренним массивом, сама по себе не вызывала эту операцию с внутренним массивом (если вы не разработали функцию для ее обработки), иначе может возникнуть неконтролируемая бесконечная рекурсия (что может привести к сбою программы). Имена клавиш, которые представляют операции, которые можно заменить:</target>
        </trans-unit>
        <trans-unit id="387d18f40b5cc90de6d4cee0fbe4a352c5b8dee6" translate="yes" xml:space="preserve">
          <source>NumPy style governs cases where:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e0ffae4d5e74817321bd554d6e22d7ad10db9e4c" translate="yes" xml:space="preserve">
          <source>NumPy supports PEP 3141 numbers:</source>
          <target state="translated">NumPy поддерживает номера PEP 3141:</target>
        </trans-unit>
        <trans-unit id="a30e09b28bd3a22ee136145ff9e9655f237427ce" translate="yes" xml:space="preserve">
          <source>NumPy supports a much greater variety of numerical types than Python does. This section shows which are available, and how to modify an array&amp;rsquo;s data-type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="233a312424d8a0ad1356c1a0f6d65ae323b75b8a" translate="yes" xml:space="preserve">
          <source>NumPy understands that the multiplication should happen with each cell. That concept is called &lt;strong&gt;broadcasting&lt;/strong&gt;. Broadcasting is a mechanism that allows NumPy to perform operations on arrays of different shapes. The dimensions of your array must be compatible, for example, when the dimensions of both arrays are equal or when one of them is 1. If the dimensions are not compatible, you will get a &lt;code&gt;ValueError&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce9b240ab41f1a17ca7549bbe67eafcc942f1048" translate="yes" xml:space="preserve">
          <source>NumPy user guide</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f9253086c7c4965c63bda0ce6993cc9b981baa4c" translate="yes" xml:space="preserve">
          <source>NumPy uses a series of tests to probe the compiler and libc libraries for funtions. The results are stored in &lt;code&gt;_numpyconfig.h&lt;/code&gt; and &lt;code&gt;config.h&lt;/code&gt; files using &lt;code&gt;HAVE_XXX&lt;/code&gt; definitions. These tests are run during the &lt;code&gt;build_src&lt;/code&gt; phase of the &lt;code&gt;_multiarray_umath&lt;/code&gt; module in the &lt;code&gt;generate_config_h&lt;/code&gt; and &lt;code&gt;generate_numpyconfig_h&lt;/code&gt; functions. Since the output of these calls includes many compiler warnings and errors, by default it is run quietly. If you wish to see this output, you can run the &lt;code&gt;build_src&lt;/code&gt; stage verbosely:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a7fbc5d580827f690776ae9fde2ddf99b3716968" translate="yes" xml:space="preserve">
          <source>NumPy uses both methods with a preference for the second method because it can be safer. The ctypes attribute of the ndarray returns an object that has an &lt;code&gt;_as_parameter_&lt;/code&gt; attribute which returns an integer representing the address of the ndarray to which it is associated. As a result, one can pass this ctypes attribute object directly to a function expecting a pointer to the data in your ndarray. The caller must be sure that the ndarray object is of the correct type, shape, and has the correct flags set or risk nasty crashes if the data-pointer to inappropriate arrays are passed in.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fddaf9c91d8d4012f023752f68ed0149bce87d6e" translate="yes" xml:space="preserve">
          <source>NumPy uses the IEEE Standard for Binary Floating-Point for Arithmetic (IEEE 754).</source>
          <target state="translated">NumPy использует стандарт IEEE для двоичной плавающей запятой для арифметики (IEEE 754).</target>
        </trans-unit>
        <trans-unit id="8667558f0f51c03b2587a599efedda1f9f4468ac" translate="yes" xml:space="preserve">
          <source>NumPy uses the IEEE Standard for Binary Floating-Point for Arithmetic (IEEE 754). Negative zero is considered to be a finite number.</source>
          <target state="translated">NumPy использует стандарт IEEE для двоичной плавающей запятой для арифметики (IEEE 754).Отрицательный ноль считается конечным числом.</target>
        </trans-unit>
        <trans-unit id="d23202e89199272fb59380a61ef4cc7654a36b65" translate="yes" xml:space="preserve">
          <source>NumPy uses the IEEE Standard for Binary Floating-Point for Arithmetic (IEEE 754). Positive zero is considered to be a finite number.</source>
          <target state="translated">NumPy использует стандарт IEEE для двоичной плавающей запятой для арифметики (IEEE 754).Положительный ноль считается конечным числом.</target>
        </trans-unit>
        <trans-unit id="f42533d92c39de593371e6aa3dde32696064d2b8" translate="yes" xml:space="preserve">
          <source>NumPy uses the IEEE Standard for Binary Floating-Point for Arithmetic (IEEE 754). This means that Not a Number is not equivalent to infinity.</source>
          <target state="translated">NumPy использует стандарт IEEE для двоичной плавающей запятой для арифметики (IEEE 754).Это означает,что Not a Number не эквивалентно бесконечности.</target>
        </trans-unit>
        <trans-unit id="af1c83a08aa63e00fff2b45b2f860192ca21bcf1" translate="yes" xml:space="preserve">
          <source>NumPy uses the IEEE Standard for Binary Floating-Point for Arithmetic (IEEE 754). This means that Not a Number is not equivalent to infinity. Also that positive infinity is not equivalent to negative infinity. But infinity is equivalent to positive infinity.</source>
          <target state="translated">NumPy использует стандарт IEEE для двоичной плавающей запятой для арифметики (IEEE 754).Это означает,что Not a Number не эквивалентно бесконечности.Также,что положительная бесконечность не эквивалентна отрицательной бесконечности.Но бесконечность эквивалентна положительной бесконечности.</target>
        </trans-unit>
        <trans-unit id="389fed054ec853b5b8bb20d440426bf9262e8e46" translate="yes" xml:space="preserve">
          <source>NumPy uses the IEEE Standard for Binary Floating-Point for Arithmetic (IEEE 754). This means that Not a Number is not equivalent to infinity. Also that positive infinity is not equivalent to negative infinity. But infinity is equivalent to positive infinity. Errors result if the second argument is also supplied when &lt;code&gt;x&lt;/code&gt; is a scalar input, or if first and second arguments have different shapes.</source>
          <target state="translated">NumPy использует стандарт IEEE для двоичных чисел с плавающей запятой для арифметики (IEEE 754). Это означает, что Not a Number не эквивалентно бесконечности. Также эта положительная бесконечность не эквивалентна отрицательной бесконечности. Но бесконечность эквивалентна положительной бесконечности. Ошибки возникают, если второй аргумент также предоставляется, когда &lt;code&gt;x&lt;/code&gt; является скалярным входом, или если первый и второй аргументы имеют разные формы.</target>
        </trans-unit>
        <trans-unit id="35a6249b4224925e0bdcfa0f8624c08fcc4790ef" translate="yes" xml:space="preserve">
          <source>NumPy uses the IEEE Standard for Binary Floating-Point for Arithmetic (IEEE 754). This means that Not a Number is not equivalent to infinity. Positive infinity is treated as a very large number and negative infinity is treated as a very small (i.e. negative) number.</source>
          <target state="translated">NumPy использует стандарт IEEE для двоичной плавающей запятой для арифметики (IEEE 754).Это означает,что Not a Number не эквивалентно бесконечности.Положительная бесконечность рассматривается как очень большое число,а отрицательная бесконечность-как очень маленькое (т.е.отрицательное)число.</target>
        </trans-unit>
        <trans-unit id="4026f26ee4d1cd9de2a496e4e3dd03a3e5a7f962" translate="yes" xml:space="preserve">
          <source>NumPy v1.19 Manual</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a799f9f2b696a8693dd829a76caa31a7afbdcb94" translate="yes" xml:space="preserve">
          <source>NumPy v1.20 Manual</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ea0a36ef00ca34de0c91ee7b58a561c1bb0550a" translate="yes" xml:space="preserve">
          <source>NumPy version comparison</source>
          <target state="translated">Сравнение версий NumPy</target>
        </trans-unit>
        <trans-unit id="8ba9f463515e23b0f299b2ffc9d54837e3d43200" translate="yes" xml:space="preserve">
          <source>NumPy version string (&lt;code&gt;np.__version__&lt;/code&gt;).</source>
          <target state="translated">Строка версии NumPy ( &lt;code&gt;np.__version__&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="9b3a90b67fc6e7751631f73fbd200fedcaf6517b" translate="yes" xml:space="preserve">
          <source>NumPy will gather implementations of &lt;code&gt;__array_function__&lt;/code&gt; from all specified inputs and call them in order: subclasses before superclasses, and otherwise left to right. Note that in some edge cases involving subclasses, this differs slightly from the &lt;a href=&quot;https://bugs.python.org/issue30140&quot;&gt;current behavior&lt;/a&gt; of Python.</source>
          <target state="translated">NumPy соберет реализации &lt;code&gt;__array_function__&lt;/code&gt; из всех указанных входов и вызовет их по порядку: подклассы перед суперклассами, в противном случае слева направо. Обратите внимание, что в некоторых крайних случаях, связанных с подклассами, это немного отличается от &lt;a href=&quot;https://bugs.python.org/issue30140&quot;&gt;текущего поведения&lt;/a&gt; Python.</target>
        </trans-unit>
        <trans-unit id="eaf96b4a25ad851a2b4abd4e522b636c4d667ac3" translate="yes" xml:space="preserve">
          <source>NumPy&amp;rsquo;s &lt;code&gt;np.flip()&lt;/code&gt; function allows you to flip, or reverse, the contents of an array along an axis. When using &lt;code&gt;np.flip()&lt;/code&gt;, specify the array you would like to reverse and the axis. If you don&amp;rsquo;t specify the axis, NumPy will reverse the contents along all of the axes of your input array.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2fb311f19fa41c253fcda50763e8cfca7eec45cb" translate="yes" xml:space="preserve">
          <source>NumPy&amp;rsquo;s &lt;code&gt;np.flip()&lt;/code&gt; function allows you to flip, or reverse, the contents of an array along an axis. When using &lt;code&gt;np.flip&lt;/code&gt;, specify the array you would like to reverse and the axis. If you don&amp;rsquo;t specify the axis, NumPy will reverse the contents along all of the axes of your input array.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b39796df6889956cc3b3ff1db77e20497876b0e" translate="yes" xml:space="preserve">
          <source>NumPy&amp;rsquo;s Documentation</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="86c194038698da06d4deba03ca0f701303ee7a9e" translate="yes" xml:space="preserve">
          <source>NumPy&amp;rsquo;s array class is called &lt;code&gt;ndarray&lt;/code&gt;. It is also known by the alias &lt;code&gt;array&lt;/code&gt;. Note that &lt;code&gt;numpy.array&lt;/code&gt; is not the same as the Standard Python Library class &lt;code&gt;array.array&lt;/code&gt;, which only handles one-dimensional arrays and offers less functionality. The more important attributes of an &lt;code&gt;ndarray&lt;/code&gt; object are:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0132beeeb0b4ce70a8210a70bdb9c78c481e563b" translate="yes" xml:space="preserve">
          <source>NumPy&amp;rsquo;s broadcasting rule relaxes this constraint when the arrays&amp;rsquo; shapes meet certain constraints. The simplest broadcasting example occurs when an array and a scalar value are combined in an operation:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da6e87a1254c0e2518a18db62672d9b8b4222aec" translate="yes" xml:space="preserve">
          <source>NumPy&amp;rsquo;s documentation uses several custom extensions to Sphinx. These are shipped in the &lt;code&gt;sphinxext/&lt;/code&gt; directory (as git submodules, as discussed above), and are automatically enabled when building NumPy&amp;rsquo;s documentation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c9b4ca4dd070cbb18cd729b7d82f19fbc8f9eb17" translate="yes" xml:space="preserve">
          <source>NumPy&amp;rsquo;s fast element-by-element computation (&lt;a href=&quot;#term-vectorization&quot;&gt;vectorization&lt;/a&gt;) gives a choice which function gets applied. The general term for the function is &lt;code&gt;ufunc&lt;/code&gt;, short for &lt;code&gt;universal function&lt;/code&gt;. NumPy routines have built-in ufuncs, but users can also &lt;a href=&quot;reference/ufuncs&quot;&gt;write their own.&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a23df3dc68bb04fcd72ce4a7accb7a59c107ed5" translate="yes" xml:space="preserve">
          <source>NumPy&amp;rsquo;s main object is the homogeneous multidimensional array. It is a table of elements (usually numbers), all of the same type, indexed by a tuple of non-negative integers. In NumPy dimensions are called &lt;em&gt;axes&lt;/em&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b6bdc0eebf8a97bb8d97d7e158fade619726770f" translate="yes" xml:space="preserve">
          <source>NumPy&amp;rsquo;s two-dimensional &lt;a href=&quot;reference/generated/numpy.matrix&quot;&gt;matrix class&lt;/a&gt; should no longer be used; use regular ndarrays.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e72e3b2d20e9ce05fa10cf5b67fd4a5d867f2b5" translate="yes" xml:space="preserve">
          <source>NumPy, &lt;a href=&quot;http://www.scipy.org&quot;&gt;SciPy&lt;/a&gt;, and the scikits follow a common convention for docstrings that provides for consistency, while also allowing our toolchain to produce well-formatted reference guides. This document describes the current community consensus for such a standard. If you have suggestions for improvements, post them on the &lt;a href=&quot;http://scipy.org/scipylib/mailing-lists.html&quot;&gt;numpy-discussion list&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="29e598a2efe067bb7689f0ffff5764af8bbe8461" translate="yes" xml:space="preserve">
          <source>NumPy, like Python, numbers indices from 0; &lt;code&gt;a[0]&lt;/code&gt; is the first element.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="65980c8f8cdaffbdb9dc6b41c004c578cf994ed4" translate="yes" xml:space="preserve">
          <source>NumPy, or rather Python, has similar facilities.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b99044d84c351a4ed63efec49bbe1ae3bf320ae" translate="yes" xml:space="preserve">
          <source>NumPy-specific help functions</source>
          <target state="translated">Функции помощи NumPy-специфические</target>
        </trans-unit>
        <trans-unit id="8e5883940f8591fc18bd2d38714b4441d0bc3808" translate="yes" xml:space="preserve">
          <source>NumPy-specific workflow is in &lt;a href=&quot;development_workflow#development-workflow&quot;&gt;numpy-development-workflow&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b61e66899eea7ee7ff7294019b3070d639ae0728" translate="yes" xml:space="preserve">
          <source>NumPy: the absolute basics for beginners</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="16f40cf39f0e25d8cf6f052959da2085155ae248" translate="yes" xml:space="preserve">
          <source>Numba</source>
          <target state="translated">Numba</target>
        </trans-unit>
        <trans-unit id="2ad094bf2eb6f204e2abae88bcc155073c5a7b5d" translate="yes" xml:space="preserve">
          <source>Numba can be used with either CTypes or CFFI. The current iteration of the BitGenerators all export a small set of functions through both interfaces.</source>
          <target state="translated">Numba может использоваться как с КТипами,так и с CFFI.Текущая итерация BitGenerators экспортирует небольшой набор функций через оба интерфейса.</target>
        </trans-unit>
        <trans-unit id="25996b6bfaea719dfb36b6f8bc64656e147e8c2f" translate="yes" xml:space="preserve">
          <source>Number Precision</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="858e21b5a976ec86aff538495ea9c4f65e263a29" translate="yes" xml:space="preserve">
          <source>Number of &amp;lsquo;guard digits&amp;rsquo; used when truncating the product of two mantissas to fit the representation.</source>
          <target state="translated">Количество &amp;laquo;защитных цифр&amp;raquo;, используемых при усечении произведения двух мантисс, чтобы соответствовать представлению.</target>
        </trans-unit>
        <trans-unit id="bbf91dba201dcc9eece0dc41a5e6c527d91e56cf" translate="yes" xml:space="preserve">
          <source>Number of Threads used for Linear Algebra</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4be768826cc42fcf995f3aef93d52ff0cd53e9ae" translate="yes" xml:space="preserve">
          <source>Number of array dimensions.</source>
          <target state="translated">Количество размеров массива.</target>
        </trans-unit>
        <trans-unit id="a97fad0d0844aff9a71f23c56eb56e01fb752db2" translate="yes" xml:space="preserve">
          <source>Number of array items in summary at beginning and end of each dimension (default 3).</source>
          <target state="translated">Количество элементов массива в резюме в начале и в конце каждого измерения (по умолчанию 3).</target>
        </trans-unit>
        <trans-unit id="9201c088075dba2ae62f215d4d2fdd9a8a777253" translate="yes" xml:space="preserve">
          <source>Number of array items in summary at beginning and end of each dimension. Defaults to &lt;code&gt;numpy.get_printoptions()['edgeitems']&lt;/code&gt;.</source>
          <target state="translated">Суммарное количество элементов массива в начале и в конце каждого измерения. По умолчанию &lt;code&gt;numpy.get_printoptions()['edgeitems']&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4574e45463a4337cd6208d1b13e93be562f45874" translate="yes" xml:space="preserve">
          <source>Number of base-&lt;code&gt;ibeta&lt;/code&gt; digits in the floating point mantissa M.</source>
          <target state="translated">Количество цифр с основанием &lt;code&gt;ibeta&lt;/code&gt; в мантиссе с плавающей запятой M.</target>
        </trans-unit>
        <trans-unit id="3ada3f66dbd1b40b353be9a0f81e475922b90cd9" translate="yes" xml:space="preserve">
          <source>Number of bits in data types</source>
          <target state="translated">Количество бит в типах данных</target>
        </trans-unit>
        <trans-unit id="f0e91946bba240191d8f8b60627edef4c8d6081d" translate="yes" xml:space="preserve">
          <source>Number of bits in the exponent (including its sign and bias).</source>
          <target state="translated">Количество битов в экспоненте (включая его знак и смещение).</target>
        </trans-unit>
        <trans-unit id="3a305056bc0be0ed46faf9a5c4020bd05011c494" translate="yes" xml:space="preserve">
          <source>Number of bits to remove at the right of &lt;code&gt;x1&lt;/code&gt;. If &lt;code&gt;x1.shape != x2.shape&lt;/code&gt;, they must be broadcastable to a common shape (which becomes the shape of the output).</source>
          <target state="translated">Количество битов, которые нужно удалить справа от &lt;code&gt;x1&lt;/code&gt; . Если &lt;code&gt;x1.shape != x2.shape&lt;/code&gt; , они должны транслироваться в общую форму (которая становится формой вывода).</target>
        </trans-unit>
        <trans-unit id="bcd1696318c5332018bcf91295a29c11afe64192" translate="yes" xml:space="preserve">
          <source>Number of bytes to skip before beginning the element view.</source>
          <target state="translated">Количество пропущенных байтов перед началом просмотра элемента.</target>
        </trans-unit>
        <trans-unit id="2bd38d497915bde99690ede2a81fd5739730552b" translate="yes" xml:space="preserve">
          <source>Number of columns in the array. By default, &lt;code&gt;M&lt;/code&gt; is taken equal to &lt;code&gt;N&lt;/code&gt;.</source>
          <target state="translated">Количество столбцов в массиве. По умолчанию &lt;code&gt;M&lt;/code&gt; принимается равным &lt;code&gt;N&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="27e78e98de656ac1f174b228b3b3cfaba70b125d" translate="yes" xml:space="preserve">
          <source>Number of columns in the output, defaults to &lt;code&gt;n&lt;/code&gt;.</source>
          <target state="translated">Количество столбцов в выводе, по умолчанию &lt;code&gt;n&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="00044a0ba0541a7997dd2599a4f9b91182edde55" translate="yes" xml:space="preserve">
          <source>Number of columns in the output. If &lt;code&gt;N&lt;/code&gt; is not specified, a square array is returned (&lt;code&gt;N = len(x)&lt;/code&gt;).</source>
          <target state="translated">Количество столбцов в выводе. Если &lt;code&gt;N&lt;/code&gt; не указано, возвращается квадратный массив ( &lt;code&gt;N = len(x)&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="a06d5e776ba9dffd0e77cd97b2c7b86bb26acb1a" translate="yes" xml:space="preserve">
          <source>Number of columns in the output. If None, defaults to &lt;code&gt;N&lt;/code&gt;.</source>
          <target state="translated">Количество столбцов в выводе. Если ни один, по умолчанию &lt;code&gt;N&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0217140ca3d5b8f088751040a1594d26b45a1b44" translate="yes" xml:space="preserve">
          <source>Number of compounding periods</source>
          <target state="translated">Количество периодов соединения</target>
        </trans-unit>
        <trans-unit id="97af9143d62e7223493889f6bc88440f1ed78209" translate="yes" xml:space="preserve">
          <source>Number of core dimensions of each argument</source>
          <target state="translated">Количество измерений ядра каждого аргумента</target>
        </trans-unit>
        <trans-unit id="33246fa87d0b3d8cf0cd33d590270d0d5b8977dd" translate="yes" xml:space="preserve">
          <source>Number of decimal places to round to (default: 0). If decimals is negative, it specifies the number of positions to the left of the decimal point.</source>
          <target state="translated">Количество десятичных знаков после запятой для округления до (по умолчанию:0).Если десятичные знаки отрицательны,то указывается количество позиций слева от десятичной точки.</target>
        </trans-unit>
        <trans-unit id="6d7f7a5c3f27de2bb3c70596c0f42aef8c17be9e" translate="yes" xml:space="preserve">
          <source>Number of decimals to round to. May be negative.</source>
          <target state="translated">Количество десятичных долей округления до.Может быть отрицательным.</target>
        </trans-unit>
        <trans-unit id="d0f39eca925aa79a0a6c1e41a38d8c60caef28f9" translate="yes" xml:space="preserve">
          <source>Number of degrees of freedom, must be &amp;gt; 0.</source>
          <target state="translated">Число степеней свободы должно быть&amp;gt; 0.</target>
        </trans-unit>
        <trans-unit id="947cb948510d628b02b33a2e4f5d937c49f48f16" translate="yes" xml:space="preserve">
          <source>Number of derivatives taken, must be non-negative. (Default: 1)</source>
          <target state="translated">Количество взятых производных должно быть неотрицательным.(По умолчанию:1)</target>
        </trans-unit>
        <trans-unit id="97245ef113e26038c737c690b9b01b48fa8ebd7e" translate="yes" xml:space="preserve">
          <source>Number of digits of precision for floating point output (default 8). May be &lt;code&gt;None&lt;/code&gt; if &lt;code&gt;floatmode&lt;/code&gt; is not &lt;code&gt;fixed&lt;/code&gt;, to print as many digits as necessary to uniquely specify the value.</source>
          <target state="translated">Число знаков точности для вывода с плавающей запятой (по умолчанию 8). Может иметь значение &lt;code&gt;None&lt;/code&gt; , если &lt;code&gt;floatmode&lt;/code&gt; не &lt;code&gt;fixed&lt;/code&gt; , чтобы напечатать столько цифр, сколько необходимо для однозначного определения значения.</target>
        </trans-unit>
        <trans-unit id="f527b9aa37b022d773444c86018ada827757d9b4" translate="yes" xml:space="preserve">
          <source>Number of digits of precision for floating point output (default 8). May be None if &lt;code&gt;floatmode&lt;/code&gt; is not &lt;code&gt;fixed&lt;/code&gt;, to print as many digits as necessary to uniquely specify the value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d97ec2f2e677c40d4431d2275107bedf5755ab8" translate="yes" xml:space="preserve">
          <source>Number of dimensions of broadcasted result.</source>
          <target state="translated">Количество размеров транслируемого результата.</target>
        </trans-unit>
        <trans-unit id="e3508cd09f84a8328fcc45ebfc715b277ccf9575" translate="yes" xml:space="preserve">
          <source>Number of dimensions of broadcasted result. Alias for &lt;a href=&quot;numpy.broadcast.nd#numpy.broadcast.nd&quot;&gt;&lt;code&gt;nd&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Количество измерений транслируемого результата. Псевдоним для &lt;a href=&quot;numpy.broadcast.nd#numpy.broadcast.nd&quot;&gt; &lt;code&gt;nd&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f2d295ce1b14b658fe281bd20aab41d9aab0b616" translate="yes" xml:space="preserve">
          <source>Number of dimensions of broadcasted result. For code intended for NumPy 1.12.0 and later the more consistent &lt;a href=&quot;numpy.broadcast.ndim#numpy.broadcast.ndim&quot;&gt;&lt;code&gt;ndim&lt;/code&gt;&lt;/a&gt; is preferred.</source>
          <target state="translated">Количество измерений транслируемого результата. Для кода, предназначенного для NumPy 1.12.0 и более &lt;a href=&quot;numpy.broadcast.ndim#numpy.broadcast.ndim&quot;&gt; &lt;code&gt;ndim&lt;/code&gt; &lt;/a&gt; , предпочтительнее более согласованный ndim .</target>
        </trans-unit>
        <trans-unit id="b135521e22bf0efd0692b304dc2944b4be1550dd" translate="yes" xml:space="preserve">
          <source>Number of dimensions of the sub-array if this data type describes a sub-array, and &lt;code&gt;0&lt;/code&gt; otherwise.</source>
          <target state="translated">Количество измерений подмассивов, если этот тип данных описывает подмассив, и &lt;code&gt;0&lt;/code&gt; в противном случае.</target>
        </trans-unit>
        <trans-unit id="19ea598f5fd4c1ee639980fee9928d5377e30cf8" translate="yes" xml:space="preserve">
          <source>Number of distinct core dimension names in the signature</source>
          <target state="translated">Количество различных названий размеров ядра в подписи</target>
        </trans-unit>
        <trans-unit id="30b78d11ec827a9cb1ca1519eabc00a62b47ac43" translate="yes" xml:space="preserve">
          <source>Number of draws to advance the RNG. Must be less than the size state variable in the underlying RNG.</source>
          <target state="translated">Количество розыгрышей для продвижения RNG.Должно быть меньше,чем переменная состояния размера в базовом RNG.</target>
        </trans-unit>
        <trans-unit id="70e37b72989cb2f41b3fc9d963c59f76fe6543ba" translate="yes" xml:space="preserve">
          <source>Number of elements along the specified axis.</source>
          <target state="translated">Количество элементов вдоль указанной оси.</target>
        </trans-unit>
        <trans-unit id="807011d441713287a8ad8dac9e44680a221be633" translate="yes" xml:space="preserve">
          <source>Number of elements in the array.</source>
          <target state="translated">Количество элементов в массиве.</target>
        </trans-unit>
        <trans-unit id="9dd78b22d2ed99e0d773b0892f1882002390793b" translate="yes" xml:space="preserve">
          <source>Number of experiments.</source>
          <target state="translated">Количество экспериментов.</target>
        </trans-unit>
        <trans-unit id="f483027559825fca9bfa4da6e5eb78910571331a" translate="yes" xml:space="preserve">
          <source>Number of first indices that are involved in the inverse sum. Must be a positive integer, default is 2.</source>
          <target state="translated">Количество первых индексов,участвующих в обратной сумме.Должно быть положительное целое число,по умолчанию 2.</target>
        </trans-unit>
        <trans-unit id="b1779d0462b8633175ab393ef9880942bb660fa7" translate="yes" xml:space="preserve">
          <source>Number of items sampled. Must be at least 1 and at most &lt;code&gt;ngood + nbad&lt;/code&gt;.</source>
          <target state="translated">Количество выбранных элементов. Должно быть не менее 1 и не более &lt;code&gt;ngood + nbad&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="eafdf0d454dc2aa43f8a71aaefeb0feceae0766e" translate="yes" xml:space="preserve">
          <source>Number of items sampled. Must be nonnegative and less than &lt;code&gt;ngood + nbad&lt;/code&gt;.</source>
          <target state="translated">Количество выбранных элементов. Должен быть неотрицательным и меньше &lt;code&gt;ngood + nbad&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="897014b016e872c41c97ea0a9d1726a5e3c782d9" translate="yes" xml:space="preserve">
          <source>Number of items to read. &lt;code&gt;-1&lt;/code&gt; means all data in the buffer.</source>
          <target state="translated">Количество элементов для чтения. &lt;code&gt;-1&lt;/code&gt; означает все данные в буфере.</target>
        </trans-unit>
        <trans-unit id="b39ddea78956da2963bde4fd3e57272e8d0acb35" translate="yes" xml:space="preserve">
          <source>Number of items to read. &lt;code&gt;-1&lt;/code&gt; means all items (i.e., the complete file).</source>
          <target state="translated">Количество элементов для чтения. &lt;code&gt;-1&lt;/code&gt; означает все элементы (т.е. полный файл).</target>
        </trans-unit>
        <trans-unit id="166e4814f7850463b72419995efff990410c931d" translate="yes" xml:space="preserve">
          <source>Number of iterators possessed by the broadcasted result.</source>
          <target state="translated">Количество итераторов,одержимых транслируемым результатом.</target>
        </trans-unit>
        <trans-unit id="4211a9fc555cfccd24b355f573ae3f8ff77483ef" translate="yes" xml:space="preserve">
          <source>Number of non-zero values in the array along a given axis. Otherwise, the total number of non-zero values in the array is returned.</source>
          <target state="translated">Количество ненулевых значений в массиве по заданной оси.В противном случае возвращается общее количество ненулевых значений в массиве.</target>
        </trans-unit>
        <trans-unit id="10474dca8982c65317e69ff33c6161fee40334b7" translate="yes" xml:space="preserve">
          <source>Number of point pairs to return. The default value is 100.</source>
          <target state="translated">Количество пар точек для возврата.Значение по умолчанию-100.</target>
        </trans-unit>
        <trans-unit id="551051df538e93f92abd0e4d70bab9ebd0a9979c" translate="yes" xml:space="preserve">
          <source>Number of points along transformation axis in the input to use. If &lt;code&gt;n&lt;/code&gt; is smaller than the length of the input, the input is cropped. If it is larger, the input is padded with zeros. If &lt;code&gt;n&lt;/code&gt; is not given, the length of the input along the axis specified by &lt;code&gt;axis&lt;/code&gt; is used.</source>
          <target state="translated">Количество точек по оси преобразования во входных данных для использования. Если &lt;code&gt;n&lt;/code&gt; меньше длины ввода, ввод обрезается. Если он больше, ввод дополняется нулями. Если &lt;code&gt;n&lt;/code&gt; не задано, используется длина входа по оси, заданной &lt;code&gt;axis&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1f1a0e92249dd7ea05411a06963194533d7918c7" translate="yes" xml:space="preserve">
          <source>Number of points in the output window. If zero or less, an empty array is returned.</source>
          <target state="translated">Количество точек в окне вывода.Если ноль или меньше,возвращается пустой массив.</target>
        </trans-unit>
        <trans-unit id="79e81bd3a9cf8f13e4e087ed6b9ef489d7061b0e" translate="yes" xml:space="preserve">
          <source>Number of random bytes.</source>
          <target state="translated">Количество случайных байтов.</target>
        </trans-unit>
        <trans-unit id="53975b0c071abdcd5131d1862834f5b08e87e264" translate="yes" xml:space="preserve">
          <source>Number of rows (and columns) in &lt;code&gt;n&lt;/code&gt; x &lt;code&gt;n&lt;/code&gt; output.</source>
          <target state="translated">Количество строк (и столбцов) в выводе &lt;code&gt;n&lt;/code&gt; x &lt;code&gt;n&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ba04adb79f4c3bf3f6caa8c01f8f929a74cbf8dc" translate="yes" xml:space="preserve">
          <source>Number of rows in the array.</source>
          <target state="translated">Количество строк в массиве.</target>
        </trans-unit>
        <trans-unit id="9371726ac94e49726635264017eacaef06541bb1" translate="yes" xml:space="preserve">
          <source>Number of rows in the output.</source>
          <target state="translated">Количество строк в выводе.</target>
        </trans-unit>
        <trans-unit id="89c00ebdcc34147d25718afd7dbd46f5e2d21937" translate="yes" xml:space="preserve">
          <source>Number of sample points and weights. It must be &amp;gt;= 1.</source>
          <target state="translated">Количество точек выборки и веса. Оно должно быть&amp;gt; = 1.</target>
        </trans-unit>
        <trans-unit id="394bbce360690b00428b0808fa6c2c7bc474b75c" translate="yes" xml:space="preserve">
          <source>Number of sample points desired.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8f13e51c56d80088f553a736484516fc0a17451a" translate="yes" xml:space="preserve">
          <source>Number of samples to generate. Default is 50.</source>
          <target state="translated">Количество сгенерированных образцов.По умолчанию 50.</target>
        </trans-unit>
        <trans-unit id="b944ba1a6a786da2de285aee44ef64df7a0334c1" translate="yes" xml:space="preserve">
          <source>Number of samples to generate. Default is 50. Must be non-negative.</source>
          <target state="translated">Количество сгенерированных образцов.По умолчанию 50.Должно быть,неотрицательно.</target>
        </trans-unit>
        <trans-unit id="b8477012cd08123303aba533415512dffd6caae6" translate="yes" xml:space="preserve">
          <source>Number of times the array is rotated by 90 degrees.</source>
          <target state="translated">Количество раз,когда массив поворачивается на 90 градусов.</target>
        </trans-unit>
        <trans-unit id="43c5f5739f871a7eba2351b02c5057ed709b7574" translate="yes" xml:space="preserve">
          <source>Number of times to jump the state of the bit generator returned</source>
          <target state="translated">Количество раз для прыжка в состояние возвращаемого генератора битов</target>
        </trans-unit>
        <trans-unit id="612ea9a9fedd365d5dfed6db5fa33a0bb992e5bc" translate="yes" xml:space="preserve">
          <source>Number of values padded to the edges of each axis. ((before_1, after_1), &amp;hellip; (before_N, after_N)) unique pad widths for each axis. ((before, after),) yields same before and after pad for each axis. (pad,) or int is a shortcut for before = after = pad width for all axes.</source>
          <target state="translated">Количество значений, добавленных к краям каждой оси. ((before_1, after_1),&amp;hellip; (before_N, after_N)) уникальная ширина контактных площадок для каждой оси. ((before, after),) дает одинаковую площадку до и после для каждой оси. (pad,) или int - это ярлык для before = after = pad width для всех осей.</target>
        </trans-unit>
        <trans-unit id="21f1fbd39c40968c76006276fee34189d50015b9" translate="yes" xml:space="preserve">
          <source>Number of ways to make a bad selection. Must be nonnegative and less than 10**9.</source>
          <target state="translated">Количество способов сделать плохой выбор.Должно быть отрицательным и менее 10**9.</target>
        </trans-unit>
        <trans-unit id="4fbe2e90660c2e70b194a26e014711298205f94b" translate="yes" xml:space="preserve">
          <source>Number of ways to make a bad selection. Must be nonnegative.</source>
          <target state="translated">Количество способов сделать плохой выбор.Должно быть,отрицательный.</target>
        </trans-unit>
        <trans-unit id="3f0216b57e4ddf8587c6f571d9e2b9562f1ca140" translate="yes" xml:space="preserve">
          <source>Number of ways to make a good selection. Must be nonnegative and less than 10**9.</source>
          <target state="translated">Количество способов сделать хороший выбор.Должно быть отрицательным и менее 10**9.</target>
        </trans-unit>
        <trans-unit id="e7a90f9a528b46c6111a9dd205b3c9485855546b" translate="yes" xml:space="preserve">
          <source>Number of ways to make a good selection. Must be nonnegative.</source>
          <target state="translated">Количество способов сделать хороший выбор.Должно быть,отрицательный.</target>
        </trans-unit>
        <trans-unit id="f8ef4addb29288d67ee3b4225212bd0c25d2c82e" translate="yes" xml:space="preserve">
          <source>Number of zeros padded on the left. Default is 0 (no padding).</source>
          <target state="translated">Количество нулей слева.По умолчанию 0 (без подкладки).</target>
        </trans-unit>
        <trans-unit id="c42ce792573d252e0e5bfedf479c34b63dd69907" translate="yes" xml:space="preserve">
          <source>Number of zeros to append to &lt;code&gt;x1&lt;/code&gt;. Has to be non-negative. If &lt;code&gt;x1.shape != x2.shape&lt;/code&gt;, they must be broadcastable to a common shape (which becomes the shape of the output).</source>
          <target state="translated">Количество нулей, добавляемых к &lt;code&gt;x1&lt;/code&gt; . Не должно быть отрицательным. Если &lt;code&gt;x1.shape != x2.shape&lt;/code&gt; , они должны транслироваться в общую форму (которая становится формой вывода).</target>
        </trans-unit>
        <trans-unit id="48744031d20b47daf05a16a7cf85445cecfa69bb" translate="yes" xml:space="preserve">
          <source>Number(s) to append at the end of the returned differences.</source>
          <target state="translated">Номер(ы),добавляемый(ые)в конце возвращаемой разницы.</target>
        </trans-unit>
        <trans-unit id="b058e82a0ebd1af4fdfdc76f108d0c56ee2817ee" translate="yes" xml:space="preserve">
          <source>Number(s) to prepend at the beginning of the returned differences.</source>
          <target state="translated">Номер(ы),который(ые)должен(ы)быть указан(ы)в начале возвращаемой разницы.</target>
        </trans-unit>
        <trans-unit id="415e3bf4df03605336c3914770641333dc739919" translate="yes" xml:space="preserve">
          <source>Numerator degrees of freedom in &lt;code&gt;random.noncentral_f&lt;/code&gt; need only be positive.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aef085dad0112ed12e20c9ac768d68c02abb5c39" translate="yes" xml:space="preserve">
          <source>Numerator degrees of freedom, must be &amp;gt; 0.</source>
          <target state="translated">Числитель степеней свободы должен быть&amp;gt; 0.</target>
        </trans-unit>
        <trans-unit id="915427ef41bad72baf07ece61495d7f8349cc6ce" translate="yes" xml:space="preserve">
          <source>Numerator.</source>
          <target state="translated">Numerator.</target>
        </trans-unit>
        <trans-unit id="725a001aa87d95c548766f8d2dce89bbb2b6023f" translate="yes" xml:space="preserve">
          <source>Numeric Compatibility: If you used old typecode characters in your Numeric code (which was never recommended), you will need to change some of them to the new characters. In particular, the needed changes are &lt;code&gt;c -&amp;gt; S1&lt;/code&gt;, &lt;code&gt;b -&amp;gt; B&lt;/code&gt;, &lt;code&gt;1 -&amp;gt; b&lt;/code&gt;, &lt;code&gt;s -&amp;gt; h&lt;/code&gt;, &lt;code&gt;w -&amp;gt;
H&lt;/code&gt;, and &lt;code&gt;u -&amp;gt; I&lt;/code&gt;. These changes make the type character convention more consistent with other Python modules such as the &lt;a href=&quot;https://docs.python.org/dev/library/struct.html#module-struct&quot;&gt;&lt;code&gt;struct&lt;/code&gt;&lt;/a&gt; module.</source>
          <target state="translated">Числовая совместимость: если вы использовали старые символы кода типа в своем числовом коде (что никогда не рекомендовалось), вам нужно будет заменить некоторые из них на новые символы. В частности, необходимые изменения &lt;code&gt;c -&amp;gt; S1&lt;/code&gt; , &lt;code&gt;b -&amp;gt; B&lt;/code&gt; , &lt;code&gt;1 -&amp;gt; b&lt;/code&gt; , &lt;code&gt;s -&amp;gt; h&lt;/code&gt; , &lt;code&gt;w -&amp;gt; H&lt;/code&gt; , а &lt;code&gt;u -&amp;gt; I&lt;/code&gt; . Эти изменения делают соглашение о символах типа более согласованным с другими модулями Python, такими как модуль &lt;a href=&quot;https://docs.python.org/dev/library/struct.html#module-struct&quot;&gt; &lt;code&gt;struct&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="cb439f202c0c83a4476c0493068474885a0d04ea" translate="yes" xml:space="preserve">
          <source>Numeric characters include digit characters, and all characters that have the Unicode numeric value property, e.g. &lt;code&gt;U+2155,
VULGAR FRACTION ONE FIFTH&lt;/code&gt;.</source>
          <target state="translated">Числовые символы включают символы цифр и все символы, которые имеют свойство числового значения Unicode, например &lt;code&gt;U+2155, VULGAR FRACTION ONE FIFTH&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d110fd1044993992c435dc5c01496d108d91112c" translate="yes" xml:space="preserve">
          <source>Numeric-style type names have been removed from type dictionaries</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef5636617d28e515f0b65e76f0f4004b94b623c0" translate="yes" xml:space="preserve">
          <source>Numerical negative, element-wise.</source>
          <target state="translated">Числовой отрицательный,по элементам.</target>
        </trans-unit>
        <trans-unit id="4370eb3bfbe7ac1a30c0f9e9ca59a934adb66660" translate="yes" xml:space="preserve">
          <source>Numerical operations</source>
          <target state="translated">Числовые операции</target>
        </trans-unit>
        <trans-unit id="42eddc11b63fd08bdfea69adf3f079710df9af97" translate="yes" xml:space="preserve">
          <source>Numerical operations can be easily performed without worrying about missing values, dividing by zero, square roots of negative numbers, etc.:</source>
          <target state="translated">Числовые операции можно легко выполнять,не беспокоясь о пропущенных значениях,делении на ноль,квадратных корнях отрицательных чисел и т.д.:</target>
        </trans-unit>
        <trans-unit id="4259f28206bfbca56d0e23c019e2fc661e9b9dc6" translate="yes" xml:space="preserve">
          <source>Numerical positive, element-wise.</source>
          <target state="translated">Числовой положительный,по элементам.</target>
        </trans-unit>
        <trans-unit id="52d7754f5a98c840b507e69ac61f5c2741e65c9f" translate="yes" xml:space="preserve">
          <source>Numerical ranges</source>
          <target state="translated">Числовые диапазоны</target>
        </trans-unit>
        <trans-unit id="6466751f790e1e415eaeb56dd6736b61b1be5ff5" translate="yes" xml:space="preserve">
          <source>Numpy Alignment Goals</source>
          <target state="translated">Немпые цели выравнивания</target>
        </trans-unit>
        <trans-unit id="5e9d87ae4602a83bd12085c965654deb5c3d6e16" translate="yes" xml:space="preserve">
          <source>Numpy has switched to using pytest instead of nose for testing</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ecbc9f20872e5d771f0c6a8fd21f4eb8338d6ff" translate="yes" xml:space="preserve">
          <source>Numpy no longer monkey-patches &lt;code&gt;ctypes&lt;/code&gt; with &lt;code&gt;__array_interface__&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="924ed3491b77ccfa9befdd61777a79adde9bfe4c" translate="yes" xml:space="preserve">
          <source>Numpy type</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dfa7af780a848cf7ff977252465dc8e7c6177248" translate="yes" xml:space="preserve">
          <source>Numpy uses one of two methods to automatically determine the field byte offsets and the overall itemsize of a structured datatype, depending on whether &lt;code&gt;align=True&lt;/code&gt; was specified as a keyword argument to &lt;a href=&quot;../reference/generated/numpy.dtype#numpy.dtype&quot;&gt;&lt;code&gt;numpy.dtype&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4bfbe596058b381b5d62de809d86afe7e25ae53f" translate="yes" xml:space="preserve">
          <source>Numpy uses two different forms of alignment to achieve these goals: &amp;ldquo;True alignment&amp;rdquo; and &amp;ldquo;Uint alignment&amp;rdquo;.</source>
          <target state="translated">Numpy использует две разные формы выравнивания для достижения этих целей: &amp;laquo;Истинное выравнивание&amp;raquo; и &amp;laquo;выравнивание Uint&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="0bb9027c1066c8ed830e4c8560442711a99e34e6" translate="yes" xml:space="preserve">
          <source>Numpy&amp;rsquo;s dispatch mechanism, introduced in numpy version v1.16 is the recommended approach for writing custom N-dimensional array containers that are compatible with the numpy API and provide custom implementations of numpy functionality. Applications include &lt;a href=&quot;http://dask.pydata.org&quot;&gt;dask&lt;/a&gt; arrays, an N-dimensional array distributed across multiple nodes, and &lt;a href=&quot;https://docs-cupy.chainer.org/en/stable/&quot;&gt;cupy&lt;/a&gt; arrays, an N-dimensional array on a GPU.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a93c9bf237607868ba74040bad035c52633b9e7e" translate="yes" xml:space="preserve">
          <source>Numpy&amp;rsquo;s dispatch mechanism, introduced in numpy version v1.16 is the recommended approach for writing custom N-dimensional array containers that are compatible with the numpy API and provide custom implementations of numpy functionality. Applications include &lt;a href=&quot;https://dask.pydata.org&quot;&gt;dask&lt;/a&gt; arrays, an N-dimensional array distributed across multiple nodes, and &lt;a href=&quot;https://docs-cupy.chainer.org/en/stable/&quot;&gt;cupy&lt;/a&gt; arrays, an N-dimensional array on a GPU.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="893f750b4312b0bd2ff35bac0b6f12ab34ffa8d1" translate="yes" xml:space="preserve">
          <source>Numpy&amp;rsquo;s random number routines produce pseudo random numbers using combinations of a &lt;a href=&quot;bit_generators/generated/numpy.random.bitgenerator#numpy.random.BitGenerator&quot;&gt;&lt;code&gt;BitGenerator&lt;/code&gt;&lt;/a&gt; to create sequences and a &lt;a href=&quot;generator#numpy.random.Generator&quot;&gt;&lt;code&gt;Generator&lt;/code&gt;&lt;/a&gt; to use those sequences to sample from different statistical distributions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="964f31d6716dc00a266686a77065b8428590080d" translate="yes" xml:space="preserve">
          <source>Numpy&amp;rsquo;s random number routines produce pseudo random numbers using combinations of a &lt;code&gt;BitGenerator&lt;/code&gt; to create sequences and a &lt;a href=&quot;generator#numpy.random.Generator&quot;&gt;&lt;code&gt;Generator&lt;/code&gt;&lt;/a&gt; to use those sequences to sample from different statistical distributions:</source>
          <target state="translated">Подпрограммы случайных чисел &lt;code&gt;BitGenerator&lt;/code&gt; создают псевдослучайные числа, используя комбинации BitGenerator для создания последовательностей и &lt;a href=&quot;generator#numpy.random.Generator&quot;&gt; &lt;code&gt;Generator&lt;/code&gt; &lt;/a&gt; для использования этих последовательностей для выборки из различных статистических распределений:</target>
        </trans-unit>
        <trans-unit id="dbcd930c38d963d5846a86153db381c82c24485e" translate="yes" xml:space="preserve">
          <source>NumpyVersion (class in numpy.lib)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1987fcddaae88d3445636d103d2f655d68cf7145" translate="yes" xml:space="preserve">
          <source>NumpyVersion class added</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="08a914cde05039694ef0194d9ee79ff9a79dde33" translate="yes" xml:space="preserve">
          <source>O</source>
          <target state="translated">O</target>
        </trans-unit>
        <trans-unit id="76403535a8ec16748017a87f4c76e50c07884d6f" translate="yes" xml:space="preserve">
          <source>O&amp;rsquo;Neill, Melissa E. &lt;a href=&quot;https://www.cs.hmc.edu/tr/hmc-cs-2014-0905.pdf&quot;&gt;&amp;ldquo;PCG: A Family of Simple Fast Space-Efficient Statistically Good Algorithms for Random Number Generation&amp;rdquo;&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ebc75cd71fe8ecc45d16e8fbe4ca608d05d1efe0" translate="yes" xml:space="preserve">
          <source>O(n)</source>
          <target state="translated">O(n)</target>
        </trans-unit>
        <trans-unit id="cd32e6ddbd41be3c5a4eb16b6f1ed3f8efca53a5" translate="yes" xml:space="preserve">
          <source>O(n*log(n))</source>
          <target state="translated">O(n*log(n))</target>
        </trans-unit>
        <trans-unit id="65ac5f452cfa676b59863240cc6b58ed94146182" translate="yes" xml:space="preserve">
          <source>O(n^2)</source>
          <target state="translated">O(n^2)</target>
        </trans-unit>
        <trans-unit id="16e21f4d3aaf4aa65a40bf94fc12335c25429454" translate="yes" xml:space="preserve">
          <source>O. McNoleg, &amp;ldquo;The integration of GIS, remote sensing, expert systems and adaptive co-kriging for environmental habitat modelling of the Highland Haggis using object-oriented, fuzzy-logic and neural-network techniques,&amp;rdquo; Computers &amp;amp; Geosciences, vol. 22, pp. 585-588, 1996.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9ce3bd4224c8c1780db56b4125ecf3f24bf748b7" translate="yes" xml:space="preserve">
          <source>OK</source>
          <target state="translated">OK</target>
        </trans-unit>
        <trans-unit id="9954b5cb646af3e1d62f8936ee802e399e164efe" translate="yes" xml:space="preserve">
          <source>OS X</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4363d346523c5b2cd1bf247b95c174fae0de6fec" translate="yes" xml:space="preserve">
          <source>OS X builds on travis currently use &lt;code&gt;clang&lt;/code&gt;. It appears that binary wheels for OSX &amp;gt;= 10.6 can be safely built from the travis-ci OSX 10.9 VMs when building against the Python from the Python.org installers;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3edf589ebc096e6f9b1588e4ff5155e67b354878" translate="yes" xml:space="preserve">
          <source>OS X versions &amp;gt;= 10.9 are supported, for Python version support see &lt;a href=&quot;https://numpy.org/neps/nep-0029-deprecation_policy.html&quot;&gt;NEP 29&lt;/a&gt;. We build binary wheels for OSX that are compatible with Python.org Python, system Python, homebrew and macports - see this &lt;a href=&quot;https://github.com/MacPython/wiki/wiki/Spinning-wheels&quot;&gt;OSX wheel building summary&lt;/a&gt; for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e4888b19146be35293d0e37e7d29c9c307248078" translate="yes" xml:space="preserve">
          <source>OS X versions &amp;gt;= 10.9 are supported, for Python version support see &lt;a href=&quot;https://numpy.org/neps/nep-0029-deprecation_policy.html#nep29&quot;&gt;NEP 29&lt;/a&gt;. We build binary wheels for OSX that are compatible with Python.org Python, system Python, homebrew and macports - see this &lt;a href=&quot;https://github.com/MacPython/wiki/wiki/Spinning-wheels&quot;&gt;OSX wheel building summary&lt;/a&gt; for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="495dc72791fecbe14725db696ffa42ad8b5edf3d" translate="yes" xml:space="preserve">
          <source>OSError</source>
          <target state="translated">OSError</target>
        </trans-unit>
        <trans-unit id="8803bb33e936d33e0faf20b780197077a08628ad" translate="yes" xml:space="preserve">
          <source>OSX: x64_86 OSX wheels built using travis-ci;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5fce725b9aa55e80045f38a3d07a2d5daf8ad25e" translate="yes" xml:space="preserve">
          <source>OWNDATA / O</source>
          <target state="translated">ОУНДАТА/О</target>
        </trans-unit>
        <trans-unit id="77cbefcb956b9d9d63f0f7b3f93654f940febe59" translate="yes" xml:space="preserve">
          <source>Object (i.e. the memory contains a pointer to &lt;a href=&quot;https://docs.python.org/dev/c-api/structures.html#c.PyObject&quot;&gt;&lt;code&gt;PyObject&lt;/code&gt;&lt;/a&gt;)</source>
          <target state="translated">Объект (т.е. память содержит указатель на &lt;a href=&quot;https://docs.python.org/dev/c-api/structures.html#c.PyObject&quot;&gt; &lt;code&gt;PyObject&lt;/code&gt; &lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="afdc54032033cacfee557f2ce2a005fa3b70eafb" translate="yes" xml:space="preserve">
          <source>Object array equality comparisons</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b3cc0c5c1acda14fa673f72ba7a000a4aeb4b75a" translate="yes" xml:space="preserve">
          <source>Object arrays containing multi-line objects have a more readable &lt;code&gt;repr&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3760fc40824fa6cae9e794ba9f7b99a3316407ab" translate="yes" xml:space="preserve">
          <source>Object that defines the index or indices before which &lt;code&gt;values&lt;/code&gt; is inserted.</source>
          <target state="translated">Объект, определяющий индекс или индексы, перед которыми вставляются &lt;code&gt;values&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d05ef3a802418a7aebbd13573f51be0ead5f4193" translate="yes" xml:space="preserve">
          <source>Object to be converted to a data type object.</source>
          <target state="translated">Объект,который должен быть преобразован в объект типа данных.</target>
        </trans-unit>
        <trans-unit id="1fd19fd89522d105167e839769054978a325524d" translate="yes" xml:space="preserve">
          <source>Object to test.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c4aa609fdcdcac826105f68748fd29ccfe3e04a" translate="yes" xml:space="preserve">
          <source>Objects implementing the &lt;code&gt;__array__&lt;/code&gt; protocol.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ce13dfb5c9252ebd908c62fdf9e3deef898f9e3" translate="yes" xml:space="preserve">
          <source>Objects with the &lt;code&gt;.dtype&lt;/code&gt; attribute.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a8900e78cbf680bcf40ca195f2953f79bcfe04f2" translate="yes" xml:space="preserve">
          <source>Observe that we are using the dataptr array inside the iterator, not copying the values to a local temporary. This is possible because when &lt;code&gt;iternext()&lt;/code&gt; is called, these pointers will be overwritten with fresh values, not incrementally updated.</source>
          <target state="translated">Обратите внимание, что мы используем массив dataptr внутри итератора, а не копируем значения в локальный временный объект. Это возможно, потому что при &lt;code&gt;iternext()&lt;/code&gt; эти указатели будут перезаписаны новыми значениями, а не обновлены постепенно.</target>
        </trans-unit>
        <trans-unit id="f7b6a1c7c2ab92717708ab52dfb304953f89b662" translate="yes" xml:space="preserve">
          <source>Observe that with the default of keeping native memory order, the iterator is able to provide a single one-dimensional chunk, whereas when forcing Fortran order, it has to provide three chunks of two elements each.</source>
          <target state="translated">Обратите внимание,что по умолчанию,итератор способен обеспечить один одномерный фрагмент памяти,в то время как при форсировании порядка Фортран он должен обеспечить три фрагмента по два элемента в каждом.</target>
        </trans-unit>
        <trans-unit id="d9a0a259d7da286202ed894d68d15acb64fcfe1b" translate="yes" xml:space="preserve">
          <source>Obtain the agreement of the reported person(s).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="03b79a5cda4ce7e7ddd9f792b9921027f93e2741" translate="yes" xml:space="preserve">
          <source>Obtain the agreement of the reporter(s). The reporter(s) have complete freedom to decline the mediation idea, or to propose an alternate mediator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be4aa4abf7a6245dfaef0c8852a595c8fb657a3c" translate="yes" xml:space="preserve">
          <source>Obvious &lt;strong&gt;wording&lt;/strong&gt; mistakes (like leaving out a &amp;ldquo;not&amp;rdquo;) fall into the typo category, but other rewordings &amp;ndash; even for grammar &amp;ndash; require a judgment call, which raises the bar. Test the waters by first presenting the fix as an issue.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b8499c2c896d61295bd16e3c134140b4e72b522" translate="yes" xml:space="preserve">
          <source>Occasionally there may be simple issues with old or bad installations of NumPy. In this case you may just try to uninstall and reinstall NumPy. Make sure that NumPy is not found after uninstalling.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa8a40208cbec6893957fea3d09da8c32d4bb67b" translate="yes" xml:space="preserve">
          <source>Of Chebyshev series coefficients representing the quotient and remainder.</source>
          <target state="translated">Чебышевского ряда коэффициенты,представляющие собой коэффициент и остаток.</target>
        </trans-unit>
        <trans-unit id="95a193973a1a38f794d62d2292b358ed61a158d4" translate="yes" xml:space="preserve">
          <source>Of Chebyshev series coefficients representing their difference.</source>
          <target state="translated">Чебышевских рядов коэффициентов,представляющих их разницу.</target>
        </trans-unit>
        <trans-unit id="f6f11800879153b66dc0982f5c4e19a52fd99bfd" translate="yes" xml:space="preserve">
          <source>Of Chebyshev series coefficients representing their product.</source>
          <target state="translated">Чебышевских рядов коэффициентов,представляющих их продукт.</target>
        </trans-unit>
        <trans-unit id="1e744292f68f81ff06c4af2891c2284d51276990" translate="yes" xml:space="preserve">
          <source>Of Hermite series coefficients representing the quotient and remainder.</source>
          <target state="translated">Коэффициенты ряда &quot;Эрмита&quot;,представляющие собой коэффициент и остаток.</target>
        </trans-unit>
        <trans-unit id="68e73a174e70afa8021e3a5b69b172f5340b60a0" translate="yes" xml:space="preserve">
          <source>Of Hermite series coefficients representing their difference.</source>
          <target state="translated">коэффициентов эрмитового ряда,представляющих их разницу.</target>
        </trans-unit>
        <trans-unit id="584dca0bbf2ee8dea79e52251025d455fc466309" translate="yes" xml:space="preserve">
          <source>Of Hermite series coefficients representing their product.</source>
          <target state="translated">Коэффициенты серии &quot;Эрмита&quot;,представляющие их продукт.</target>
        </trans-unit>
        <trans-unit id="f835afbe8ca3fee3a7aaf7264b53bfe89607c7f1" translate="yes" xml:space="preserve">
          <source>Of Laguerre series coefficients representing the quotient and remainder.</source>
          <target state="translated">Коэффициенты рядов Лагерра,представляющие собой коэффициент и остаток.</target>
        </trans-unit>
        <trans-unit id="90b47b338ded7c0b1d451aae2b6b202ac054bd26" translate="yes" xml:space="preserve">
          <source>Of Laguerre series coefficients representing their difference.</source>
          <target state="translated">коэффициентов рядов Лагерра,представляющих их разницу.</target>
        </trans-unit>
        <trans-unit id="9b96161c3659cfd1e35cc2549dc17860026b7cdc" translate="yes" xml:space="preserve">
          <source>Of Laguerre series coefficients representing their product.</source>
          <target state="translated">Коэффициенты серии Laguerre,представляющие их продукт.</target>
        </trans-unit>
        <trans-unit id="bd7f06a962c25e759bd9ef64c710ec6053768d88" translate="yes" xml:space="preserve">
          <source>Of Legendre series coefficients representing the quotient and remainder.</source>
          <target state="translated">Коэффициенты рядов Легенды,представляющие собой коэффициент и остаток.</target>
        </trans-unit>
        <trans-unit id="3059e37623b23a53a523c2b1352662c0102ac1da" translate="yes" xml:space="preserve">
          <source>Of Legendre series coefficients representing their difference.</source>
          <target state="translated">коэффициентов рядов Легенды,представляющих их разницу.</target>
        </trans-unit>
        <trans-unit id="50248795d9f87718e76bae1fc0c734509f84b250" translate="yes" xml:space="preserve">
          <source>Of Legendre series coefficients representing their product.</source>
          <target state="translated">Коэффициенты серии Легенда,представляющие их продукт.</target>
        </trans-unit>
        <trans-unit id="d8427b6e14c2b373d5a6dab581028bfc5f363679" translate="yes" xml:space="preserve">
          <source>Of coefficient series representing the quotient and remainder.</source>
          <target state="translated">Ряд коэффициентов,представляющих коэффициент и остаток.</target>
        </trans-unit>
        <trans-unit id="d290318bfec96b6b8a0b5657cb6aa25c8656f248" translate="yes" xml:space="preserve">
          <source>Of coefficients representing their difference.</source>
          <target state="translated">коэффициентов,представляющих их разницу.</target>
        </trans-unit>
        <trans-unit id="6a85fe85cc5899aa41f4c1b4360a890de25aa1af" translate="yes" xml:space="preserve">
          <source>Of course you&amp;rsquo;ll need to replace &lt;code&gt;Your Name&lt;/code&gt; and &lt;code&gt;you@yourdomain.example.com&lt;/code&gt; with your actual name and email address.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3c3f315ee6b4ab53b8b92ba8326227f97899e80b" translate="yes" xml:space="preserve">
          <source>Of course, a test can be unconditionally skipped or marked as a known failure by using &lt;code&gt;skip&lt;/code&gt; or &lt;code&gt;xfail&lt;/code&gt; without argument, respectively.</source>
          <target state="translated">Конечно, тест можно безоговорочно пропустить или пометить как известный сбой, используя &lt;code&gt;skip&lt;/code&gt; или &lt;code&gt;xfail&lt;/code&gt; без аргумента соответственно.</target>
        </trans-unit>
        <trans-unit id="fbcd4dc2b30c5efc09e8b8e0ac34e1195e3be111" translate="yes" xml:space="preserve">
          <source>Of course, this is not the best method to &lt;em&gt;approximate&lt;/em&gt; an image. However, there is, in fact, a result in linear algebra that says that the approximation we built above is the best we can get to the original matrix in terms of the norm of the difference. For more information, see &lt;em&gt;G. H. Golub and C. F. Van Loan, Matrix Computations, Baltimore, MD, Johns Hopkins University Press, 1985&lt;/em&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e8a45899d21a287f8cee5fcbf7d53b28d2a2524" translate="yes" xml:space="preserve">
          <source>Of the coefficients of their product.</source>
          <target state="translated">Коэффициенты их продукции.</target>
        </trans-unit>
        <trans-unit id="609c29eaa3c81a7bde19a799569654e9420a8d39" translate="yes" xml:space="preserve">
          <source>Offset into a memmap:</source>
          <target state="translated">Смещение в мемму:</target>
        </trans-unit>
        <trans-unit id="0bc2c6922816779fd173b29551f1ab7c3175a4b8" translate="yes" xml:space="preserve">
          <source>Offset is limited to C int, which is signed and usually 32 bits. If present, the optional title can be any object (if it is a string or unicode then it will also be a key in the fields dictionary, otherwise it&amp;rsquo;s meta-data). Notice also that the first two elements of the tuple can be passed directly as arguments to the &lt;code&gt;ndarray.getfield&lt;/code&gt; and &lt;code&gt;ndarray.setfield&lt;/code&gt; methods.</source>
          <target state="translated">Смещение ограничено C int, который подписан и обычно 32 бита. Если присутствует, необязательный заголовок может быть любым объектом (если это строка или Unicode, тогда он также будет ключом в словаре полей, в противном случае это метаданные). Также обратите внимание, что первые два элемента кортежа могут быть переданы непосредственно в качестве аргументов в методы &lt;code&gt;ndarray.getfield&lt;/code&gt; и &lt;code&gt;ndarray.setfield&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="86ce02382c3cd06f8561677ae11ec555fdb1fe4e" translate="yes" xml:space="preserve">
          <source>Offset of array data in buffer.</source>
          <target state="translated">Смещение данных массива в буфере.</target>
        </trans-unit>
        <trans-unit id="680177996996fd2c23e4d0d5181bef8478a843b3" translate="yes" xml:space="preserve">
          <source>Offset of the diagonal from the main diagonal. Can be both positive and negative. Defaults to 0.</source>
          <target state="translated">Смещение диагонали от главной диагонали.Может быть как положительным,так и отрицательным.По умолчанию 0.</target>
        </trans-unit>
        <trans-unit id="6b6b5a41310e8f5b4f7075c43a048e4d2e50484a" translate="yes" xml:space="preserve">
          <source>Offset of the diagonal from the main diagonal. Can be positive or negative. Defaults to main diagonal (0).</source>
          <target state="translated">Смещение диагонали от главной диагонали.Может быть положительным или отрицательным.По умолчанию смещение от главной диагонали (0).</target>
        </trans-unit>
        <trans-unit id="efcd2ae12c66734a66a7aa79ae569a447152e17b" translate="yes" xml:space="preserve">
          <source>Offset position in the file.</source>
          <target state="translated">Положение смещения в файле.</target>
        </trans-unit>
        <trans-unit id="e5143224a659eeda117fd7431883f438f099ac14" translate="yes" xml:space="preserve">
          <source>Offsets in bytes, here 0 and 25:</source>
          <target state="translated">Смещения в байтах,здесь 0 и 25:</target>
        </trans-unit>
        <trans-unit id="c9a4dc99b78136ab2e2bc1eee5d9d7344239f777" translate="yes" xml:space="preserve">
          <source>Offsets may be chosen such that the fields overlap, though this will mean that assigning to one field may clobber any overlapping field&amp;rsquo;s data. As an exception, fields of &lt;a href=&quot;../reference/arrays.scalars#numpy.object_&quot;&gt;&lt;code&gt;numpy.object_&lt;/code&gt;&lt;/a&gt; type cannot overlap with other fields, because of the risk of clobbering the internal object pointer and then dereferencing it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7329966e05964c08e33b7a47b16c9992cb5a4adf" translate="yes" xml:space="preserve">
          <source>Offsets may be chosen such that the fields overlap, though this will mean that assigning to one field may clobber any overlapping field&amp;rsquo;s data. As an exception, fields of &lt;code&gt;numpy.object&lt;/code&gt; type cannot overlap with other fields, because of the risk of clobbering the internal object pointer and then dereferencing it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="967a38eb8129ad7778f2c9f5678f5fdf3c82cadb" translate="yes" xml:space="preserve">
          <source>Often it is preferable to use a boolean mask. For example:</source>
          <target state="translated">Часто предпочтительнее использовать булевую маску.Например:</target>
        </trans-unit>
        <trans-unit id="6904502646c7743d277053efc8b47079c56c46bb" translate="yes" xml:space="preserve">
          <source>Often seen in method signatures, &lt;code&gt;self&lt;/code&gt; refers to the instance of the associated class. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e3b563fa4cc80accab04bf13505ac3eb5aa2b458" translate="yes" xml:space="preserve">
          <source>Often, the elements of an array are originally unknown, but its size is known. Hence, NumPy offers several functions to create arrays with initial placeholder content. These minimize the necessity of growing arrays, an expensive operation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="57f9c3f125b2ae3755f9cc2e88d97945e0b2e6b1" translate="yes" xml:space="preserve">
          <source>Old, no conjugate, version of correlate.</source>
          <target state="translated">Старый,без конъюгата,версия коррелята.</target>
        </trans-unit>
        <trans-unit id="22b35a56584d02836f725dd51b4643aaa3081190" translate="yes" xml:space="preserve">
          <source>Older Equivalent</source>
          <target state="translated">Эквивалент старшего возраста</target>
        </trans-unit>
        <trans-unit id="a2240253307fec1cb9e7de6b2b992423b8538bf0" translate="yes" xml:space="preserve">
          <source>On AArch64 &lt;code&gt;NEON&lt;/code&gt;&lt;code&gt;FP16&lt;/code&gt;&lt;code&gt;VFPV4&lt;/code&gt;&lt;code&gt;ASIMD&lt;/code&gt; implies each other since they are part of the hardware baseline.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="950780760d17e16ea15a84017774640eae55ce02" translate="yes" xml:space="preserve">
          <source>On Unix-like machines, reads from &lt;code&gt;/dev/urandom&lt;/code&gt;. On Windows machines reads from the RSA algorithm provided by the cryptographic service provider.</source>
          <target state="translated">На Unix-подобных машинах читает из &lt;code&gt;/dev/urandom&lt;/code&gt; . На компьютерах с Windows считывает из алгоритма RSA, предоставленного поставщиком службы криптографии.</target>
        </trans-unit>
        <trans-unit id="2d3188b9edd47b7b8e155f7d62759b49e4bbd63c" translate="yes" xml:space="preserve">
          <source>On array access use the &lt;code&gt;f-&amp;gt;getitem&lt;/code&gt; function pointer instead of the standard conversion to an array scalar. Must use if you don&amp;rsquo;t define an array scalar to go along with the data-type.</source>
          <target state="translated">При доступе к &lt;code&gt;f-&amp;gt;getitem&lt;/code&gt; используйте указатель на функцию f-&amp;gt; getitem вместо стандартного преобразования в скаляр массива. Необходимо использовать, если вы не определяете скаляр массива в соответствии с типом данных.</target>
        </trans-unit>
        <trans-unit id="4dcefd1cec20f7966d92a38bf6e10deb907560ec" translate="yes" xml:space="preserve">
          <source>On compilers which support a #warning mechanism, NumPy issues a compiler warning if you do not define the symbol NPY_NO_DEPRECATED_API. This way, the fact that there are deprecations will be flagged for third-party developers who may not have read the release notes closely.</source>
          <target state="translated">На компиляторах,поддерживающих #warning механизм,NumPy выдает предупреждение компилятору,если вы не определили символ NPY_NO_DEPRECATED_API.Таким образом,факт наличия депрессий будет отмечен для сторонних разработчиков,которые,возможно,не внимательно прочитали примечания к выпуску.</target>
        </trans-unit>
        <trans-unit id="3a15f70253da2dd06321b41b01d9ced818944641" translate="yes" xml:space="preserve">
          <source>On ppc64le &lt;code&gt;VSX(ISA 2.06)&lt;/code&gt; and &lt;code&gt;VSX2(ISA 2.07)&lt;/code&gt; both imply one another since the first generation that supports little-endian mode is Power-8`(ISA 2.07)`</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c713072ca3a05590ed7b22ab2b7c84fab6d46af9" translate="yes" xml:space="preserve">
          <source>On some platforms (&lt;em&gt;e.g.&lt;/em&gt; Windows), a shared library requires a .def file that specifies the functions to be exported. For example a mylib.def file might contain:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="30b6987bb053c195d4d4a88861df5cc0bec8c735" translate="yes" xml:space="preserve">
          <source>On the other hand, coolhelper.c would contain at the top:</source>
          <target state="translated">С другой стороны,в верхней части будет находиться coolhelper.c:</target>
        </trans-unit>
        <trans-unit id="8e10b67ab476fcac9d1e17bd9eaadbb9eeb769ca" translate="yes" xml:space="preserve">
          <source>On the other hand, the function &lt;a href=&quot;../reference/generated/numpy.row_stack#numpy.row_stack&quot;&gt;&lt;code&gt;row_stack&lt;/code&gt;&lt;/a&gt; is equivalent to &lt;a href=&quot;../reference/generated/numpy.vstack#numpy.vstack&quot;&gt;&lt;code&gt;vstack&lt;/code&gt;&lt;/a&gt; for any input arrays. In fact, &lt;a href=&quot;../reference/generated/numpy.row_stack#numpy.row_stack&quot;&gt;&lt;code&gt;row_stack&lt;/code&gt;&lt;/a&gt; is an alias for &lt;a href=&quot;../reference/generated/numpy.vstack#numpy.vstack&quot;&gt;&lt;code&gt;vstack&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e97323f6987cba1f587e924c7a9998279536c754" translate="yes" xml:space="preserve">
          <source>On the other hand, the function &lt;code&gt;row_stack&lt;/code&gt; is equivalent to &lt;a href=&quot;../reference/generated/numpy.vstack#numpy.vstack&quot;&gt;&lt;code&gt;vstack&lt;/code&gt;&lt;/a&gt; for any input arrays. In fact, &lt;code&gt;row_stack&lt;/code&gt; is an alias for &lt;a href=&quot;../reference/generated/numpy.vstack#numpy.vstack&quot;&gt;&lt;code&gt;vstack&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a8085f065b43ca0612f8f5a0dd702c78428f8a7" translate="yes" xml:space="preserve">
          <source>On this machine, building the .pyx file into a module looked like the following, but you may have to find some Cython tutorials to tell you the specifics for your system configuration.:</source>
          <target state="translated">На этой машине сборка файла .pyx в модуль выглядела следующим образом,но,возможно,вам придется найти некоторые учебные пособия Cython,чтобы рассказать вам о специфике настройки вашей системы..:</target>
        </trans-unit>
        <trans-unit id="9a506ebe097fd976b21e552ba29fd40b62947df8" translate="yes" xml:space="preserve">
          <source>Once a busdaycalendar object is created, the weekmask and holidays cannot be modified.</source>
          <target state="translated">После создания объекта busdaycalendar,маска и праздники не могут быть изменены.</target>
        </trans-unit>
        <trans-unit id="eba82deb0932802c527a81a17b1d4d366fc0af03" translate="yes" xml:space="preserve">
          <source>Once a new &lt;a href=&quot;../reference/c-api/types-and-structures#c.PyArray_Descr&quot;&gt;&lt;code&gt;PyArray_Descr&lt;/code&gt;&lt;/a&gt; structure is created and filled with the needed information and useful functions you call &lt;a href=&quot;../reference/c-api/array#c.PyArray_RegisterDataType&quot;&gt;&lt;code&gt;PyArray_RegisterDataType&lt;/code&gt;&lt;/a&gt; (new_descr). The return value from this call is an integer providing you with a unique type_number that specifies your data-type. This type number should be stored and made available by your module so that other modules can use it to recognize your data-type (the other mechanism for finding a user-defined data-type number is to search based on the name of the type-object associated with the data-type using &lt;code&gt;PyArray_TypeNumFromName&lt;/code&gt; ).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5183e36c12674d881f64d8eaa0dea9c0fa03d80d" translate="yes" xml:space="preserve">
          <source>Once a resolution is agreed upon, but before it is enacted, the committee will contact the original reporter and any other affected parties and explain the proposed resolution. The committee will ask if this resolution is acceptable, and must note feedback for the record.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d441f19f98ee4b31cf802d2cbf0a4fb74d4c8d91" translate="yes" xml:space="preserve">
          <source>Once everything seems satisfactory, commit and upload the changes:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="abc2ddc32e9564a57768ba3eb61dec0741c722ab" translate="yes" xml:space="preserve">
          <source>Once the &lt;code&gt;numpy/xxx/tests/test_yyy.py&lt;/code&gt; is written, its possible to run the tests by going to the &lt;code&gt;tests/&lt;/code&gt; directory and typing:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f7d8ca7f94183ec448b711283a3a7fa64f6c8872" translate="yes" xml:space="preserve">
          <source>Once the &lt;code&gt;scipy/xxx/tests/test_yyy.py&lt;/code&gt; is written, its possible to run the tests by going to the &lt;code&gt;tests/&lt;/code&gt; directory and typing:</source>
          <target state="translated">После того, как &lt;code&gt;scipy/xxx/tests/test_yyy.py&lt;/code&gt; написан, можно запустить тесты, перейдя в каталог &lt;code&gt;tests/&lt;/code&gt; и набрав:</target>
        </trans-unit>
        <trans-unit id="ac70209362afce77775660280fe98f52f86f930f" translate="yes" xml:space="preserve">
          <source>Once the SeedSequence is instantiated, you can call the &lt;a href=&quot;numpy.random.seedsequence.generate_state#numpy.random.SeedSequence.generate_state&quot;&gt;&lt;code&gt;generate_state&lt;/code&gt;&lt;/a&gt; method to get an appropriately sized seed. Calling &lt;a href=&quot;numpy.random.seedsequence.spawn#numpy.random.SeedSequence.spawn&quot;&gt;&lt;code&gt;spawn(n)&lt;/code&gt;&lt;/a&gt; will create &lt;code&gt;n&lt;/code&gt; SeedSequences that can be used to seed independent BitGenerators, i.e. for different threads.</source>
          <target state="translated">После создания экземпляра SeedSequence вы можете вызвать метод &lt;a href=&quot;numpy.random.seedsequence.generate_state#numpy.random.SeedSequence.generate_state&quot;&gt; &lt;code&gt;generate_state&lt;/code&gt; ,&lt;/a&gt; чтобы получить начальное число подходящего размера. Вызов &lt;a href=&quot;numpy.random.seedsequence.spawn#numpy.random.SeedSequence.spawn&quot;&gt; &lt;code&gt;spawn(n)&lt;/code&gt; &lt;/a&gt; создаст &lt;code&gt;n&lt;/code&gt; SeedSequences, которые можно использовать для заполнения независимых BitGenerators, то есть для разных потоков.</target>
        </trans-unit>
        <trans-unit id="9b8c845df2375661d6c8904939512353e20ecd41" translate="yes" xml:space="preserve">
          <source>Once the conversions to the appropriate C-structures and C data-types have been performed, the next step in the wrapper is to call the underlying function. This is straightforward if the underlying function is in C or C++. However, in order to call Fortran code you must be familiar with how Fortran subroutines are called from C/C++ using your compiler and platform. This can vary somewhat platforms and compilers (which is another reason f2py makes life much simpler for interfacing Fortran code) but generally involves underscore mangling of the name and the fact that all variables are passed by reference (i.e. all arguments are pointers).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9fd5de6f03a0c2c385081a0d6f534ba7e379838a" translate="yes" xml:space="preserve">
          <source>Once the file is defined and open for reading, &lt;a href=&quot;../reference/generated/numpy.genfromtxt#numpy.genfromtxt&quot;&gt;&lt;code&gt;genfromtxt&lt;/code&gt;&lt;/a&gt; splits each non-empty line into a sequence of strings. Empty or commented lines are just skipped. The &lt;code&gt;delimiter&lt;/code&gt; keyword is used to define how the splitting should take place.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="97b7cac8dde7cbe137262c702e77fb0ca9ad5356" translate="yes" xml:space="preserve">
          <source>Once the header is parsed by &lt;code&gt;ffi.cdef&lt;/code&gt;, the functions can be accessed directly from the &lt;code&gt;_generator&lt;/code&gt; shared object, using the &lt;a href=&quot;bit_generators/generated/numpy.random.bitgenerator.cffi#numpy.random.BitGenerator.cffi&quot;&gt;&lt;code&gt;BitGenerator.cffi&lt;/code&gt;&lt;/a&gt; interface.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="31e905cb6480a6fdb98cbdeb00114c7de3f9ecca" translate="yes" xml:space="preserve">
          <source>Once the iterator is prepared for iteration (after a reset if &lt;a href=&quot;#c.NPY_ITER_DELAY_BUFALLOC&quot;&gt;&lt;code&gt;NPY_ITER_DELAY_BUFALLOC&lt;/code&gt;&lt;/a&gt; was used), call this to get the strides which may be used to select a fast inner loop function. For example, if the stride is 0, that means the inner loop can always load its value into a variable once, then use the variable throughout the loop, or if the stride equals the itemsize, a contiguous version for that operand may be used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="231d4308334f05ae25082dce13bc3cf1e18cdbf8" translate="yes" xml:space="preserve">
          <source>Once the iterator is prepared for iteration (after a reset if &lt;code&gt;NPY_DELAY_BUFALLOC&lt;/code&gt; was used), call this to get the strides which may be used to select a fast inner loop function. For example, if the stride is 0, that means the inner loop can always load its value into a variable once, then use the variable throughout the loop, or if the stride equals the itemsize, a contiguous version for that operand may be used.</source>
          <target state="translated">Как только итератор подготовлен к итерации (после сброса, если использовался &lt;code&gt;NPY_DELAY_BUFALLOC&lt;/code&gt; ), вызовите его, чтобы получить шаги, которые можно использовать для выбора быстрой функции внутреннего цикла. Например, если шаг равен 0, это означает, что внутренний цикл всегда может загрузить свое значение в переменную один раз, а затем использовать переменную во всем цикле, или, если шаг равен размеру элемента, может использоваться непрерывная версия для этого операнда.</target>
        </trans-unit>
        <trans-unit id="c04dbd1660afe1562d16b591f18b1bb40507aaa1" translate="yes" xml:space="preserve">
          <source>Once the spam module is imported into python, you can call logit via spam.logit. Note that the function used above cannot be applied as-is to numpy arrays. To do so we must call numpy.vectorize on it. For example, if a python interpreter is opened in the file containing the spam library or spam has been installed, one can perform the following commands:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e78ec319a64fd7535ba4d9ce2b45a93a3eddd1ea" translate="yes" xml:space="preserve">
          <source>Once the wheels have been built and downloaded without errors tag the &lt;code&gt;REL&lt;/code&gt; commit, signing it with your gpg key:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="993e871933c3573c232eaa172843213039b4efd1" translate="yes" xml:space="preserve">
          <source>Once the wheels have been built and downloaded without errors, go back to your numpy repository in the maintenance branch and tag the &lt;code&gt;REL&lt;/code&gt; commit, signing it with your gpg key:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="44934f86865426c152af6fe43faca7909cb74599" translate="yes" xml:space="preserve">
          <source>Once you&amp;rsquo;ve created your arrays, you can start to work with them. Let&amp;rsquo;s say, for example, that you&amp;rsquo;ve created two arrays, one called &amp;ldquo;data&amp;rdquo; and one called &amp;ldquo;ones&amp;rdquo;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="71c392b0b03965e8b7e58ba06da44426e1525511" translate="yes" xml:space="preserve">
          <source>Once you&amp;rsquo;ve created your matrices, you can add and multiply them using arithmetic operators if you have two matrices that are the same size.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="77517b16ad949bec662df3d2780dff01b3a28d3c" translate="yes" xml:space="preserve">
          <source>One Loop</source>
          <target state="translated">Один цикл</target>
        </trans-unit>
        <trans-unit id="fb74c341b98c307818ac342dee77af9f705b8e7e" translate="yes" xml:space="preserve">
          <source>One big advantage of Cython-generated extension modules is that they are easy to distribute. In summary, Cython is a very capable tool for either gluing C code or generating an extension module quickly and should not be over-looked. It is especially useful for people that can&amp;rsquo;t or won&amp;rsquo;t write C or Fortran code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="91705b60cf41602239345b05e981d551e6358c23" translate="yes" xml:space="preserve">
          <source>One can also instantiate &lt;a href=&quot;generator#numpy.random.Generator&quot;&gt;&lt;code&gt;Generator&lt;/code&gt;&lt;/a&gt; directly with a &lt;a href=&quot;bit_generators/generated/numpy.random.bitgenerator#numpy.random.BitGenerator&quot;&gt;&lt;code&gt;BitGenerator&lt;/code&gt;&lt;/a&gt; instance.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="444c9c354929cf1b3a58f15b3f0b2168f58f68f7" translate="yes" xml:space="preserve">
          <source>One can also instantiate &lt;a href=&quot;generator#numpy.random.Generator&quot;&gt;&lt;code&gt;Generator&lt;/code&gt;&lt;/a&gt; directly with a &lt;a href=&quot;bit_generators/generated/numpy.random.bitgenerator#numpy.random.BitGenerator&quot;&gt;&lt;code&gt;BitGenerator&lt;/code&gt;&lt;/a&gt; instance. To use the older &lt;a href=&quot;bit_generators/mt19937#numpy.random.MT19937&quot;&gt;&lt;code&gt;MT19937&lt;/code&gt;&lt;/a&gt; algorithm, one can instantiate it directly and pass it to &lt;a href=&quot;generator#numpy.random.Generator&quot;&gt;&lt;code&gt;Generator&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8524b74ddf89508f43aa1069be40f8c206f86f89" translate="yes" xml:space="preserve">
          <source>One can also instantiate &lt;a href=&quot;generator#numpy.random.Generator&quot;&gt;&lt;code&gt;Generator&lt;/code&gt;&lt;/a&gt; directly with a &lt;code&gt;BitGenerator&lt;/code&gt; instance. To use the older &lt;a href=&quot;bit_generators/mt19937#numpy.random.mt19937.MT19937&quot;&gt;&lt;code&gt;MT19937&lt;/code&gt;&lt;/a&gt; algorithm, one can instantiate it directly and pass it to &lt;a href=&quot;generator#numpy.random.Generator&quot;&gt;&lt;code&gt;Generator&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Можно также создать экземпляр &lt;a href=&quot;generator#numpy.random.Generator&quot;&gt; &lt;code&gt;Generator&lt;/code&gt; &lt;/a&gt; напрямую с помощью экземпляра &lt;code&gt;BitGenerator&lt;/code&gt; . Чтобы использовать старый алгоритм &lt;a href=&quot;bit_generators/mt19937#numpy.random.mt19937.MT19937&quot;&gt; &lt;code&gt;MT19937&lt;/code&gt; &lt;/a&gt; , можно напрямую создать его экземпляр и передать в &lt;a href=&quot;generator#numpy.random.Generator&quot;&gt; &lt;code&gt;Generator&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="070709f2e07ce3e32b6abdd9998a1049f1bd5e84" translate="yes" xml:space="preserve">
          <source>One can index and assign to a structured array with a multi-field index, where the index is a list of field names.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e3340151bf466504ea342e74247a72d1486385a" translate="yes" xml:space="preserve">
          <source>One can use &lt;code&gt;PyUFunc_FromFuncAndDataAndSignature&lt;/code&gt; to declare a more general ufunc. The argument list is the same as &lt;code&gt;PyUFunc_FromFuncAndData&lt;/code&gt;, with an additional argument specifying the signature as C string.</source>
          <target state="translated">Можно использовать &lt;code&gt;PyUFunc_FromFuncAndDataAndSignature&lt;/code&gt; для объявления более общего ufunc. Список аргументов такой же, как &lt;code&gt;PyUFunc_FromFuncAndData&lt;/code&gt; , с дополнительным аргументом, указывающим подпись как строку C.</target>
        </trans-unit>
        <trans-unit id="e6a96a24425a79d2472bdd027a95e9628f8491bc" translate="yes" xml:space="preserve">
          <source>One can use different values for optional &lt;code&gt;n&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="93c665d4f58d5aed156c11bf302a241bec2c3bfe" translate="yes" xml:space="preserve">
          <source>One cannot mix negation and positives, nor have multiple negations, such cases will raise an error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="56899b43e5156c96d1005f04cd69878206c68abd" translate="yes" xml:space="preserve">
          <source>One common algorithmic requirement is to be able to walk over all elements in a multidimensional array. The array iterator object makes this easy to do in a generic way that works for arrays of any dimension. Naturally, if you know the number of dimensions you will be using, then you can always write nested for loops to accomplish the iteration. If, however, you want to write code that works with any number of dimensions, then you can make use of the array iterator. An array iterator object is returned when accessing the .flat attribute of an array.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="81089507935f358c69911644b087b72a2a0a612b" translate="yes" xml:space="preserve">
          <source>One common source of reference-count errors is the &lt;a href=&quot;https://docs.python.org/dev/c-api/arg.html#c.Py_BuildValue&quot;&gt;&lt;code&gt;Py_BuildValue&lt;/code&gt;&lt;/a&gt; function. Pay careful attention to the difference between the &amp;lsquo;N&amp;rsquo; format character and the &amp;lsquo;O&amp;rsquo; format character. If you create a new object in your subroutine (such as an output array), and you are passing it back in a tuple of return values, then you should most- likely use the &amp;lsquo;N&amp;rsquo; format character in &lt;a href=&quot;https://docs.python.org/dev/c-api/arg.html#c.Py_BuildValue&quot;&gt;&lt;code&gt;Py_BuildValue&lt;/code&gt;&lt;/a&gt;. The &amp;lsquo;O&amp;rsquo; character will increase the reference count by one. This will leave the caller with two reference counts for a brand-new array. When the variable is deleted and the reference count decremented by one, there will still be that extra reference count, and the array will never be deallocated. You will have a reference-counting induced memory leak. Using the &amp;lsquo;N&amp;rsquo; character will avoid this situation as it will return to the caller an object (inside the tuple) with a single reference count.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46d4e9404ec123b91b7f0181eb9f23e04fe59bd2" translate="yes" xml:space="preserve">
          <source>One deviation from the current behavior of &lt;code&gt;__array_ufunc__&lt;/code&gt; is that NumPy will only call &lt;code&gt;__array_function__&lt;/code&gt; on the &lt;em&gt;first&lt;/em&gt; argument of each unique type. This matches Python&amp;rsquo;s &lt;a href=&quot;https://docs.python.org/3/reference/datamodel.html#object.__ror__&quot;&gt;rule for calling reflected methods&lt;/a&gt;, and this ensures that checking overloads has acceptable performance even when there are a large number of overloaded arguments.</source>
          <target state="translated">Одно из отклонений от текущего поведения &lt;code&gt;__array_ufunc__&lt;/code&gt; состоит в том, что NumPy будет вызывать &lt;code&gt;__array_function__&lt;/code&gt; только для &lt;em&gt;первого&lt;/em&gt; аргумента каждого уникального типа. Это соответствует &lt;a href=&quot;https://docs.python.org/3/reference/datamodel.html#object.__ror__&quot;&gt;правилу&lt;/a&gt; Python для вызова отраженных методов и гарантирует, что проверка перегрузок будет иметь приемлемую производительность даже при большом количестве перегруженных аргументов.</target>
        </trans-unit>
        <trans-unit id="b47e08224aaf497fafd8b89783b8a17e95a05214" translate="yes" xml:space="preserve">
          <source>One dimensional array:</source>
          <target state="translated">Одномерный массив:</target>
        </trans-unit>
        <trans-unit id="bbfcf4855e8547b3c2c018358506a526943e1c9a" translate="yes" xml:space="preserve">
          <source>One fundamental aspect of the ndarray is that an array is seen as a &amp;ldquo;chunk&amp;rdquo; of memory starting at some location. The interpretation of this memory depends on the stride information. For each dimension in an</source>
          <target state="translated">Одним из фундаментальных аспектов ndarray является то, что массив рассматривается как &amp;laquo;кусок&amp;raquo; памяти, начинающийся в некотором месте. Интерпретация этого воспоминания зависит от информации о шаге. Для каждого измерения в</target>
        </trans-unit>
        <trans-unit id="16275c9ae04e235f8070983e66409df72503b036" translate="yes" xml:space="preserve">
          <source>One is returned for slices that are all-NaN or empty.</source>
          <target state="translated">Один возвращается для кусочков,которые полностью NaN или пустые.</target>
        </trans-unit>
        <trans-unit id="e2800fbab71db8fc98d5d383e0fd87d0d933e41f" translate="yes" xml:space="preserve">
          <source>One of &amp;ldquo;always&amp;rdquo;, &amp;ldquo;once&amp;rdquo;, &amp;ldquo;module&amp;rdquo;, or &amp;ldquo;location&amp;rdquo;. Analogous to the usual warnings module filter mode, it is useful to reduce noise mostly on the outmost level. Unsuppressed and unrecorded warnings will be forwarded based on this rule. Defaults to &amp;ldquo;always&amp;rdquo;. &amp;ldquo;location&amp;rdquo; is equivalent to the warnings &amp;ldquo;default&amp;rdquo;, match by exact location the warning warning originated from.</source>
          <target state="translated">Одно из &amp;laquo;всегда&amp;raquo;, &amp;laquo;один раз&amp;raquo;, &amp;laquo;модуль&amp;raquo; или &amp;laquo;местоположение&amp;raquo;. По аналогии с обычным режимом фильтрации модуля предупреждений, полезен для снижения шума в основном на крайнем уровне. Неподавленные и незарегистрированные предупреждения будут пересылаться на основе этого правила. По умолчанию &amp;laquo;всегда&amp;raquo;. &amp;laquo;Местоположение&amp;raquo; эквивалентно предупреждению &amp;laquo;по умолчанию&amp;raquo;, соответствует точному местоположению, из которого возникло предупреждение.</target>
        </trans-unit>
        <trans-unit id="a089b8e63dd4e8eb30432f942f75f4b932e1fd5a" translate="yes" xml:space="preserve">
          <source>One of None, &amp;lsquo;auto&amp;rsquo;, or a &lt;a href=&quot;../arrays.datetime#arrays-dtypes-dateunits&quot;&gt;datetime unit&lt;/a&gt;.</source>
          <target state="translated">Одно из значений None, auto или &lt;a href=&quot;../arrays.datetime#arrays-dtypes-dateunits&quot;&gt;datetime&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f39ed1de2c370ff6c78c1184ddb58d4c6a6a7345" translate="yes" xml:space="preserve">
          <source>One of the built-in data-types, the void data-type allows for arbitrary structured types containing 1 or more fields as elements of the array. A field is simply another data-type object along with an offset into the current structured type. In order to support arbitrarily nested fields, several recursive implementations of data-type access are implemented for the void type. A common idiom is to cycle through the elements of the dictionary and perform a specific operation based on the data-type object stored at the given offset. These offsets can be arbitrary numbers. Therefore, the possibility of encountering mis- aligned data must be recognized and taken into account if necessary.</source>
          <target state="translated">Один из встроенных типов данных-тип void data-позволяет использовать в качестве элементов массива произвольные структурированные типы,содержащие 1 и более полей.Поле-это просто еще один объект типа данных вместе со смещением в текущий структурный тип.Для поддержки произвольно вложенных полей реализовано несколько рекурсивных реализаций доступа к типу данных для типа void.Общая идиома состоит в том,чтобы циклически перебирать элементы словаря и выполнять определенную операцию на основе объекта типа данных,хранящегося при заданном смещении.Эти смещения могут быть произвольными числами.Поэтому возможность столкнуться с неправильно выровненными данными должна быть распознана и учтена при необходимости.</target>
        </trans-unit>
        <trans-unit id="7fb71e305de0bd82275b57dccd8d18215eb5533d" translate="yes" xml:space="preserve">
          <source>One of the elements in &lt;a href=&quot;../reference/c-api/types-and-structures#c.PyObject_HEAD&quot;&gt;&lt;code&gt;PyObject_HEAD&lt;/code&gt;&lt;/a&gt; is a pointer to a type-object structure. A new Python type is created by creating a new type-object structure and populating it with functions and pointers to describe the desired behavior of the type. Typically, a new C-structure is also created to contain the instance-specific information needed for each object of the type as well. For example, &lt;a href=&quot;../reference/c-api/types-and-structures#c.PyArray_Type&quot;&gt;&lt;code&gt;&amp;amp;PyArray_Type&lt;/code&gt;&lt;/a&gt; is a pointer to the type-object table for the ndarray while a &lt;a href=&quot;../reference/c-api/types-and-structures#c.PyArrayObject&quot;&gt;&lt;code&gt;PyArrayObject *&lt;/code&gt;&lt;/a&gt; variable is a pointer to a particular instance of an ndarray (one of the members of the ndarray structure is, in turn, a pointer to the type- object table &lt;a href=&quot;../reference/c-api/types-and-structures#c.PyArray_Type&quot;&gt;&lt;code&gt;&amp;amp;PyArray_Type&lt;/code&gt;&lt;/a&gt;). Finally &lt;a href=&quot;https://docs.python.org/dev/c-api/type.html#c.PyType_Ready&quot;&gt;&lt;code&gt;PyType_Ready&lt;/code&gt;&lt;/a&gt; (&amp;lt;pointer_to_type_object&amp;gt;) must be called for every new Python type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7f15581ffc61dc8d280c89c7bfaccc5af8a60a18" translate="yes" xml:space="preserve">
          <source>One of the elements in &lt;a href=&quot;https://docs.python.org/dev/c-api/structures.html#c.PyObject_HEAD&quot;&gt;&lt;code&gt;PyObject_HEAD&lt;/code&gt;&lt;/a&gt; is a pointer to a type-object structure. A new Python type is created by creating a new type-object structure and populating it with functions and pointers to describe the desired behavior of the type. Typically, a new C-structure is also created to contain the instance-specific information needed for each object of the type as well. For example, &lt;a href=&quot;../reference/c-api/types-and-structures#c.PyArray_Type&quot;&gt;&lt;code&gt;&amp;amp;PyArray_Type&lt;/code&gt;&lt;/a&gt; is a pointer to the type-object table for the ndarray while a &lt;a href=&quot;../reference/c-api/types-and-structures#c.PyArrayObject&quot;&gt;&lt;code&gt;PyArrayObject *&lt;/code&gt;&lt;/a&gt; variable is a pointer to a particular instance of an ndarray (one of the members of the ndarray structure is, in turn, a pointer to the type- object table &lt;a href=&quot;../reference/c-api/types-and-structures#c.PyArray_Type&quot;&gt;&lt;code&gt;&amp;amp;PyArray_Type&lt;/code&gt;&lt;/a&gt;). Finally &lt;a href=&quot;https://docs.python.org/dev/c-api/type.html#c.PyType_Ready&quot;&gt;&lt;code&gt;PyType_Ready&lt;/code&gt;&lt;/a&gt; (&amp;lt;pointer_to_type_object&amp;gt;) must be called for every new Python type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="800f0527f171cc2cc2f96013ed1d0d73822e318b" translate="yes" xml:space="preserve">
          <source>One of the enumerated types or &lt;a href=&quot;../reference/c-api/dtype#c.NPY_NOTYPE&quot;&gt;&lt;code&gt;NPY_NOTYPE&lt;/code&gt;&lt;/a&gt; if the data-type should be determined from the object itself. The C-based names can be used:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b8bb917d30f8e918beefbd1feb7c9a171676de0" translate="yes" xml:space="preserve">
          <source>One of the following string values or a user supplied function.</source>
          <target state="translated">Одно из следующих строковых значений или функция,поставляемая пользователем.</target>
        </trans-unit>
        <trans-unit id="c247d033f683cfebb6311017bf9488ea1b3de438" translate="yes" xml:space="preserve">
          <source>One of the lesser-used features that has been lurking in Python since 2.2 is the ability to sub-class types in C. This facility is one of the important reasons for basing NumPy off of the Numeric code-base which was already in C. A sub-type in C allows much more flexibility with regards to memory management. Sub-typing in C is not difficult even if you have only a rudimentary understanding of how to create new types for Python. While it is easiest to sub-type from a single parent type, sub-typing from multiple parent types is also possible. Multiple inheritance in C is generally less useful than it is in Python because a restriction on Python sub-types is that they have a binary compatible memory layout. Perhaps for this reason, it is somewhat easier to sub-type from a single parent type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="27403d9ce40c15186aafb846c5de4d2a9de532c0" translate="yes" xml:space="preserve">
          <source>One of the problems that ndarray solves is keeping track of memory ownership of ndarrays and their views. Consider the case where we have created an ndarray, &lt;code&gt;arr&lt;/code&gt; and have taken a slice with &lt;code&gt;v = arr[1:]&lt;/code&gt;. The two objects are looking at the same memory. NumPy keeps track of where the data came from for a particular array or view, with the &lt;code&gt;base&lt;/code&gt; attribute:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e3967d3ba22f4ac7f4c1ab09bac9634bd847ca9c" translate="yes" xml:space="preserve">
          <source>One of:</source>
          <target state="translated">Один из:</target>
        </trans-unit>
        <trans-unit id="eb28eadbd381d78c0578e9d33fcdb60f914be747" translate="yes" xml:space="preserve">
          <source>One or more array-like sequences. Non-array inputs are converted to arrays. Arrays that already have three or more dimensions are preserved.</source>
          <target state="translated">Одна или более массивовидных последовательностей.Входы,не относящиеся к массивам,преобразуются в массивы.Сохраняются массивы,уже имеющие три и более измерения.</target>
        </trans-unit>
        <trans-unit id="30e8ba24447e6b42366fd8b8bb4f9518361510cc" translate="yes" xml:space="preserve">
          <source>One or more array-like sequences. Non-array inputs are converted to arrays. Arrays that already have two or more dimensions are preserved.</source>
          <target state="translated">Одна или более массивовидных последовательностей.Входы,не относящиеся к массивам,преобразуются в массивы.Сохраняются массивы,которые уже имеют два или более измерения.</target>
        </trans-unit>
        <trans-unit id="b5ac146eea9a6c289d467e482f8a257b9519c8d8" translate="yes" xml:space="preserve">
          <source>One or more input arrays.</source>
          <target state="translated">Один или несколько массивов ввода.</target>
        </trans-unit>
        <trans-unit id="c995dd2d01832787cd57c037ae2c18a3ecd49592" translate="yes" xml:space="preserve">
          <source>One padding, Outside bounds values will be 1.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d567aa2c7888a9ebb9443758e2ad3f65f13a88e0" translate="yes" xml:space="preserve">
          <source>One possibility we can think of is to interpolate the missing data to estimate the number of cases in late January. Observe that we can select the masked elements using the &lt;code&gt;.mask&lt;/code&gt; attribute:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce4e66d66f3f25393b9b9092b14d986216b8ea91" translate="yes" xml:space="preserve">
          <source>One relatively simple and reliable way to check for the compiler used to build a library is to use ldd on the library. If libg2c.so is a dependency, this means that g77 has been used (note: g77 is no longer supported for building NumPy). If libgfortran.so is a dependency, gfortran has been used. If both are dependencies, this means both have been used, which is almost always a very bad idea.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e6362eba61fec5cf9abb4f9817d64b7cd0aed92b" translate="yes" xml:space="preserve">
          <source>One sees that the &lt;code&gt;super&lt;/code&gt; call, which goes to &lt;code&gt;ndarray.__new__&lt;/code&gt;, passes &lt;code&gt;__array_finalize__&lt;/code&gt; the new object, of our own class (&lt;code&gt;self&lt;/code&gt;) as well as the object from which the view has been taken (&lt;code&gt;obj&lt;/code&gt;). As you can see from the output above, the &lt;code&gt;self&lt;/code&gt; is always a newly created instance of our subclass, and the type of &lt;code&gt;obj&lt;/code&gt; differs for the three instance creation methods:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="33ec8922f9be1aeeb6fe45b52431c5e822f5d065" translate="yes" xml:space="preserve">
          <source>One simple way to achieve this is to install the released version in site-packages, by using a binary installer or pip for example, and set up the development version in a virtualenv. First install &lt;a href=&quot;http://www.virtualenv.org/&quot;&gt;virtualenv&lt;/a&gt; (optionally use &lt;a href=&quot;http://www.doughellmann.com/projects/virtualenvwrapper/&quot;&gt;virtualenvwrapper&lt;/a&gt;), then create your virtualenv (named numpy-dev here) with:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01bd59e7480ae8ee0b30eea6aab25ec69688345a" translate="yes" xml:space="preserve">
          <source>One thing to watch out for is conversions back to the original data type when using a read-write or write-only operand. A common case is to implement the inner loop in terms of 64-bit floats, and use &amp;lsquo;same_kind&amp;rsquo; casting to allow the other floating-point types to be processed as well. While in read-only mode, an integer array could be provided, read-write mode will raise an exception because conversion back to the array would violate the casting rule.</source>
          <target state="translated">Следует остерегаться обратного преобразования к исходному типу данных при использовании операнда для чтения-записи или только для записи. Распространенный случай - реализовать внутренний цикл в терминах 64-битных чисел с плавающей запятой и использовать приведение same_kind, чтобы разрешить обработку и других типов с плавающей запятой. В режиме только для чтения может быть предоставлен целочисленный массив, режим чтения-записи вызовет исключение, поскольку преобразование обратно в массив нарушит правило приведения типов.</target>
        </trans-unit>
        <trans-unit id="2cc36f9c20276e56c093db5e52fdeb366528fc58" translate="yes" xml:space="preserve">
          <source>One vector with dimension 2.</source>
          <target state="translated">Один вектор с размером 2.</target>
        </trans-unit>
        <trans-unit id="99918e2f05caf6cd6ec60dc844a473737b719247" translate="yes" xml:space="preserve">
          <source>One very nice feature of testing is allowing easy testing across a range of parameters - a nasty problem for standard unit tests. Use the &lt;code&gt;dec.paramaterize&lt;/code&gt; decorator.</source>
          <target state="translated">Одна очень приятная особенность тестирования - это возможность простого тестирования по ряду параметров - неприятная проблема для стандартных модульных тестов. Используйте декоратор &lt;code&gt;dec.paramaterize&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bd9c1c4f351a78f93a1ea46f7fb6388f8d6e8ce8" translate="yes" xml:space="preserve">
          <source>One way we can initialize NumPy arrays is from Python lists, using nested lists for two- or higher-dimensional data.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd980620fd6bb0d38c87e52f67df303553acf634" translate="yes" xml:space="preserve">
          <source>One-character strings</source>
          <target state="translated">Односимвольные строки</target>
        </trans-unit>
        <trans-unit id="7dd48564d3a850a05467a68a151727d64b2ad461" translate="yes" xml:space="preserve">
          <source>One-dimensional arrays are then printed as rows, bidimensionals as matrices and tridimensionals as lists of matrices.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5131dc464a794c785bc59aee87c51ca82227aaed" translate="yes" xml:space="preserve">
          <source>One-dimensional linear interpolation.</source>
          <target state="translated">Одномерная линейная интерполяция.</target>
        </trans-unit>
        <trans-unit id="cd572fc9dc51ce4fd31312f0bb79afc0c6e4432a" translate="yes" xml:space="preserve">
          <source>One-dimensional, two-dimensional, three-dimensional and four-dimensional arrays.</source>
          <target state="translated">Одномерные,двухмерные,трехмерные и четырехмерные массивы.</target>
        </trans-unit>
        <trans-unit id="3b7777f0a5babbc2cd6ca70c30ebaa80abc0442d" translate="yes" xml:space="preserve">
          <source>One-input, one-output, and two-input, one-output core 1-d functions for the &lt;a href=&quot;c-api.dtype#c.NPY_OBJECT&quot;&gt;&lt;code&gt;NPY_OBJECT&lt;/code&gt;&lt;/a&gt; data type. These functions handle reference count issues and return early on error. The actual function to call is &lt;em&gt;func&lt;/em&gt; and it must accept calls with the signature &lt;code&gt;(PyObject*)
(PyObject*)&lt;/code&gt; for &lt;a href=&quot;#c.PyUFunc_O_O&quot;&gt;&lt;code&gt;PyUFunc_O_O&lt;/code&gt;&lt;/a&gt; or &lt;code&gt;(PyObject*)(PyObject *,
PyObject *)&lt;/code&gt; for &lt;a href=&quot;#c.PyUFunc_OO_O&quot;&gt;&lt;code&gt;PyUFunc_OO_O&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Основные функции 1-d с одним входом, одним выходом, двумя входами и одним выходом для &lt;a href=&quot;c-api.dtype#c.NPY_OBJECT&quot;&gt; &lt;code&gt;NPY_OBJECT&lt;/code&gt; &lt;/a&gt; данных NPY_OBJECT . Эти функции обрабатывают проблемы с подсчетом ссылок и возвращают на раннем этапе ошибки. Фактически вызываемой функцией является &lt;em&gt;func,&lt;/em&gt; и она должна принимать вызовы с подписью &lt;code&gt;(PyObject*) (PyObject*)&lt;/code&gt; для &lt;a href=&quot;#c.PyUFunc_O_O&quot;&gt; &lt;code&gt;PyUFunc_O_O&lt;/code&gt; &lt;/a&gt; или &lt;code&gt;(PyObject*)(PyObject *, PyObject *)&lt;/code&gt; для &lt;a href=&quot;#c.PyUFunc_OO_O&quot;&gt; &lt;code&gt;PyUFunc_OO_O&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8c1f106f50e29c9c2b8a1ac2b65d27f3773387b3" translate="yes" xml:space="preserve">
          <source>One-input, one-output, and two-input, one-output core 1-d functions for the &lt;a href=&quot;dtype#c.NPY_OBJECT&quot;&gt;&lt;code&gt;NPY_OBJECT&lt;/code&gt;&lt;/a&gt; data type. These functions handle reference count issues and return early on error. The actual function to call is &lt;em&gt;func&lt;/em&gt; and it must accept calls with the signature &lt;code&gt;(PyObject*)
(PyObject*)&lt;/code&gt; for &lt;a href=&quot;#c.PyUFunc_O_O&quot;&gt;&lt;code&gt;PyUFunc_O_O&lt;/code&gt;&lt;/a&gt; or &lt;code&gt;(PyObject*)(PyObject *,
PyObject *)&lt;/code&gt; for &lt;a href=&quot;#c.PyUFunc_OO_O&quot;&gt;&lt;code&gt;PyUFunc_OO_O&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ddd47ce11e1fa9754d28954cfcd5881bbc1273cc" translate="yes" xml:space="preserve">
          <source>Ones and zeros</source>
          <target state="translated">нули и единицы</target>
        </trans-unit>
        <trans-unit id="cb940bbbd02e7c31b4ae50aac2139276e3822e9f" translate="yes" xml:space="preserve">
          <source>Ones are returned for slices that are all-NaN or empty.</source>
          <target state="translated">Они возвращаются для кусочков,которые полностью NaN или пустые.</target>
        </trans-unit>
        <trans-unit id="09f22eb6b2adcce43b85d8b07506fb5c95ab640d" translate="yes" xml:space="preserve">
          <source>Only a few, unrelated commits then prefer rebasing:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="32b697531330130760eafc916bd6f1be5353ebde" translate="yes" xml:space="preserve">
          <source>Only a survey of the choices. Little detail on how each works.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1addd7b3649a3c34fc344240c254d5a275033117" translate="yes" xml:space="preserve">
          <source>Only accepts 1-D arrays.</source>
          <target state="translated">Принимаются только одномерные массивы.</target>
        </trans-unit>
        <trans-unit id="bde044c10adb7133cf0f3ad6c4862788f16172f1" translate="yes" xml:space="preserve">
          <source>Only accepts 2-D arrays at most.</source>
          <target state="translated">Принимаются только двухмерные массивы максимум.</target>
        </trans-unit>
        <trans-unit id="7afe5b0a4d7cbceb0c653cfc81e1d454858d38ee" translate="yes" xml:space="preserve">
          <source>Only allow casts which will not cause values to be rounded, truncated, or otherwise changed.</source>
          <target state="translated">Допускаются только такие отливки,при которых значения не будут округляться,усекаться или иным образом изменяться.</target>
        </trans-unit>
        <trans-unit id="c3582e0ecb066430ad3be065ab374165ffa609f3" translate="yes" xml:space="preserve">
          <source>Only allow identical types.</source>
          <target state="translated">Разрешать только идентичные типы.</target>
        </trans-unit>
        <trans-unit id="603519900a2e75cc37ace5a2f71e7c45cdb8b832" translate="yes" xml:space="preserve">
          <source>Only an integer decimal number can be used.</source>
          <target state="translated">Можно использовать только целое десятичное число.</target>
        </trans-unit>
        <trans-unit id="cae35f53e6308f43d551d7ad3a2026ad04e15e23" translate="yes" xml:space="preserve">
          <source>Only contiguous arrays (data elements consecutive in memory) can be resized.</source>
          <target state="translated">Изменять размер можно только смежные массивы (последовательные в памяти элементы данных).</target>
        </trans-unit>
        <trans-unit id="e992238c6b6cf34041def067b036cda1362cc0ed" translate="yes" xml:space="preserve">
          <source>Only integer and boolean types are handled.</source>
          <target state="translated">Обрабатываются только целочисленные и булевые типы.</target>
        </trans-unit>
        <trans-unit id="ce974e565e6e54262541b566a10f88e312bc9462" translate="yes" xml:space="preserve">
          <source>Only integer and boolean types are handled. If &lt;code&gt;x1.shape != x2.shape&lt;/code&gt;, they must be broadcastable to a common shape (which becomes the shape of the output).</source>
          <target state="translated">Обрабатываются только целочисленные и логические типы. Если &lt;code&gt;x1.shape != x2.shape&lt;/code&gt; , они должны транслироваться в общую форму (которая становится формой вывода).</target>
        </trans-unit>
        <trans-unit id="7329167d275db4d33debe4e1e78cc7c194228992" translate="yes" xml:space="preserve">
          <source>Only on intel (windows?)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c1e46a9dd5cfa9d4541737997e2a69c528376429" translate="yes" xml:space="preserve">
          <source>Only return the middle values of the convolution. Contains boundary effects, where zeros are taken into account:</source>
          <target state="translated">Возвращайте только средние значения свертки.Содержит граничные эффекты,в которых учитываются нули:</target>
        </trans-unit>
        <trans-unit id="c646c2238b413bc43301092aedff89ef1f867724" translate="yes" xml:space="preserve">
          <source>Only returned if &lt;code&gt;retstep&lt;/code&gt; is True</source>
          <target state="translated">Возвращается, только если &lt;code&gt;retstep&lt;/code&gt; равен True</target>
        </trans-unit>
        <trans-unit id="e429b326ee86d54ede5217418c8826c4e767d391" translate="yes" xml:space="preserve">
          <source>Only the WRITEBACKIFCOPY, UPDATEIFCOPY, WRITEABLE, and ALIGNED flags can be changed by the user, via direct assignment to the attribute or dictionary entry, or by calling &lt;a href=&quot;numpy.ndarray.setflags#numpy.ndarray.setflags&quot;&gt;&lt;code&gt;ndarray.setflags&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Только флаги WRITEBACKIFCOPY, UPDATEIFCOPY, WRITEABLE и ALIGNED могут быть изменены пользователем путем прямого присвоения записи атрибута или словаря или путем вызова &lt;a href=&quot;numpy.ndarray.setflags#numpy.ndarray.setflags&quot;&gt; &lt;code&gt;ndarray.setflags&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ba8823766a1477c99c5d6107c4aad19cb79aa3fe" translate="yes" xml:space="preserve">
          <source>Only the WRITEBACKIFCOPY, UPDATEIFCOPY, WRITEABLE, and ALIGNED flags can be changed by the user, via direct assignment to the attribute or dictionary entry, or by calling &lt;code&gt;ndarray.setflags&lt;/code&gt;.</source>
          <target state="translated">Только флаги WRITEBACKIFCOPY, UPDATEIFCOPY, WRITEABLE и ALIGNED могут быть изменены пользователем путем прямого присвоения записи атрибута или словаря или путем вызова &lt;code&gt;ndarray.setflags&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="14128c80bfe87033c27d2c8a406f61e4d63d6d90" translate="yes" xml:space="preserve">
          <source>Only the memory bounds of a and b are checked by default.</source>
          <target state="translated">По умолчанию проверяются только границы памяти a и b.</target>
        </trans-unit>
        <trans-unit id="a133ec60f230a1d745372bd29522c9608116df62" translate="yes" xml:space="preserve">
          <source>Only the memory bounds of a and b are checked.</source>
          <target state="translated">Проверяются только границы памяти a и b.</target>
        </trans-unit>
        <trans-unit id="2828ce3af0ec6cf22589ee67ae2d61139d97726f" translate="yes" xml:space="preserve">
          <source>Only used in &lt;a href=&quot;#c.PyArray_CheckFromAny&quot;&gt;&lt;code&gt;PyArray_CheckFromAny&lt;/code&gt;&lt;/a&gt; to over-ride the byteorder of the data-type object passed in.</source>
          <target state="translated">Используется только в &lt;a href=&quot;#c.PyArray_CheckFromAny&quot;&gt; &lt;code&gt;PyArray_CheckFromAny&lt;/code&gt; &lt;/a&gt; для переопределения байтера переданного объекта типа данных.</target>
        </trans-unit>
        <trans-unit id="c499db64f45476fb60b7a934c6b0e9eae67b09aa" translate="yes" xml:space="preserve">
          <source>Only useful in forcing objects in object arrays on Python 3 to be pickled in a Python 2 compatible way. If &lt;code&gt;fix_imports&lt;/code&gt; is True, pickle will try to map the new Python 3 names to the old module names used in Python 2, so that the pickle data stream is readable with Python 2.</source>
          <target state="translated">Полезно только для того, чтобы заставить объекты в массивах объектов на Python 3 быть обработаны совместимым с Python 2 способом. Если &lt;code&gt;fix_imports&lt;/code&gt; имеет значение True, pickle попытается сопоставить новые имена Python 3 со старыми именами модулей, используемыми в Python 2, чтобы поток данных pickle был доступен для чтения с Python 2.</target>
        </trans-unit>
        <trans-unit id="9be2bb2a7cf937c49df50863791a7e2b8e618032" translate="yes" xml:space="preserve">
          <source>Only useful when loading Python 2 generated pickled files on Python 3, which includes npy/npz files containing object arrays. If &lt;code&gt;fix_imports&lt;/code&gt; is True, pickle will try to map the old Python 2 names to the new names used in Python 3.</source>
          <target state="translated">Полезно только при загрузке сгенерированных Python 2 файлов маринованных на Python 3, который включает файлы npy / npz, содержащие массивы объектов. Если &lt;code&gt;fix_imports&lt;/code&gt; имеет значение True, pickle попытается сопоставить старые имена Python 2 с новыми именами, используемыми в Python 3.</target>
        </trans-unit>
        <trans-unit id="284f33151b0cb79968c40e4b088e6fb638c9882a" translate="yes" xml:space="preserve">
          <source>Open a .npy file as a memory-mapped array.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="17ffc3b0833d539654e5ad58b641d1cef1d2a7bc" translate="yes" xml:space="preserve">
          <source>Open and return file-like object.</source>
          <target state="translated">Открыть и вернуть файл-подобный объект.</target>
        </trans-unit>
        <trans-unit id="bb7abb02e2506f465eda9d56007ed5a7e2b0bd98" translate="yes" xml:space="preserve">
          <source>Open existing file for reading and writing.</source>
          <target state="translated">Откройте существующий файл для чтения и записи.</target>
        </trans-unit>
        <trans-unit id="bd185b75f1b59e945b739489c944a7512ff51fd8" translate="yes" xml:space="preserve">
          <source>Open existing file for reading only.</source>
          <target state="translated">Откройте существующий файл только для чтения.</target>
        </trans-unit>
        <trans-unit id="96179d121ec9cf7124c6c2755cce0f345158530b" translate="yes" xml:space="preserve">
          <source>Open file object or filename.</source>
          <target state="translated">Открыть объект файла или имя файла.</target>
        </trans-unit>
        <trans-unit id="a6f0b5cd06c0857fa1094ec1c01c44ffc62a3722" translate="yes" xml:space="preserve">
          <source>Open text file with given encoding. The default encoding will be what &lt;a href=&quot;https://docs.python.org/dev/library/io.html#io.open&quot;&gt;&lt;code&gt;io.open&lt;/code&gt;&lt;/a&gt; uses.</source>
          <target state="translated">Открыть текстовый файл с заданной кодировкой. По умолчанию используется кодировка &lt;a href=&quot;https://docs.python.org/dev/library/io.html#io.open&quot;&gt; &lt;code&gt;io.open&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="988a0621a69f95c126d429edd6ad72b8b9753d30" translate="yes" xml:space="preserve">
          <source>OpenBLAS</source>
          <target state="translated">OpenBLAS</target>
        </trans-unit>
        <trans-unit id="9e6729afd8b62e6a17fee3a65c668dbe74656c3a" translate="yes" xml:space="preserve">
          <source>OpenBLAS ILP64 with &lt;code&gt;64_&lt;/code&gt; symbol suffix (&lt;code&gt;openblas64_&lt;/code&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6db258279bc027edbc14a901c4f72c25179352f5" translate="yes" xml:space="preserve">
          <source>OpenBLAS ILP64 without symbol suffix (&lt;code&gt;openblas_ilp64&lt;/code&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d9413e771602d364356d827e1ba5484c54b2980c" translate="yes" xml:space="preserve">
          <source>OpenGL Half Float Pixel Support</source>
          <target state="translated">Поддержка полуфлоатных пикселей OpenGL</target>
        </trans-unit>
        <trans-unit id="92b199ce7b8a6cd2b986683aff11b8b6f7fca3cd" translate="yes" xml:space="preserve">
          <source>Openness &amp;amp; Transparency</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a1fdaa6b2a846c8fcf18d414bf8c61db610eda6a" translate="yes" xml:space="preserve">
          <source>Operations</source>
          <target state="translated">Operations</target>
        </trans-unit>
        <trans-unit id="802737eaf4ae404056a43d4b36a403eb607a4663" translate="yes" xml:space="preserve">
          <source>Operations on an axis</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba63388b76fb2354877e0a00827567f3e7dd9beb" translate="yes" xml:space="preserve">
          <source>Operations on masked arrays</source>
          <target state="translated">Операции с масками</target>
        </trans-unit>
        <trans-unit id="52f32163af2ed7163e716ed54ad45e1abac6d362" translate="yes" xml:space="preserve">
          <source>Operations on masks</source>
          <target state="translated">Операции на масках</target>
        </trans-unit>
        <trans-unit id="ee87ced5cf49f6083697398814cf1d512f44d6ad" translate="yes" xml:space="preserve">
          <source>Operations on np.memmap objects return numpy arrays in most cases</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e36cb408f625975bc7da03d4112be652fbd5e3b3" translate="yes" xml:space="preserve">
          <source>Operations where ufunc input and output operands have memory overlap are defined to be the same as for equivalent operations where there is no memory overlap. Operations affected make temporary copies as needed to eliminate data dependency. As detecting these cases is computationally expensive, a heuristic is used, which may in rare cases result in needless temporary copies. For operations where the data dependency is simple enough for the heuristic to analyze, temporary copies will not be made even if the arrays overlap, if it can be deduced copies are not necessary. As an example, &lt;code&gt;np.add(a, b, out=a)&lt;/code&gt; will not involve copies.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9ca78838064bd04174cc1a2b7101984f13a328d5" translate="yes" xml:space="preserve">
          <source>Operators &lt;code&gt;*&lt;/code&gt; and &lt;code&gt;@&lt;/code&gt;, functions &lt;code&gt;dot()&lt;/code&gt;, and &lt;code&gt;multiply()&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c0563fccbe64a1dfd8037f51262c4fd0530cd94" translate="yes" xml:space="preserve">
          <source>Oppenheim, A.V., and R.W. Schafer. Discrete-Time Signal Processing. Upper Saddle River, NJ: Prentice-Hall, 1999, pp. 468-471.</source>
          <target state="translated">Оппенгейм,А.В.и Р.В.Шафер.Обработка дискретных сигналов.Река Верхнего седла,NJ:Prentice-Hall,1999,стр.468-471.</target>
        </trans-unit>
        <trans-unit id="dc6761ca91dcee4424a2851cbb50045197345e3f" translate="yes" xml:space="preserve">
          <source>Optimal &lt;a href=&quot;#numpy.einsum&quot;&gt;&lt;code&gt;einsum&lt;/code&gt;&lt;/a&gt; (best usage pattern in some use cases): ~110ms</source>
          <target state="translated">Оптимальный &lt;a href=&quot;#numpy.einsum&quot;&gt; &lt;code&gt;einsum&lt;/code&gt; &lt;/a&gt; (лучший образец использования в некоторых случаях): ~ 110 мс</target>
        </trans-unit>
        <trans-unit id="14a620b1a39a0c10e2201e1aff4cc0715f2dfce6" translate="yes" xml:space="preserve">
          <source>Optimization names can be CPU features or groups of features that gather several features or &lt;a href=&quot;#special-options&quot;&gt;special options&lt;/a&gt; to perform a series of procedures.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a6005faa183a89f9948e43f5a980447b421fb158" translate="yes" xml:space="preserve">
          <source>Optimizations for operations of the form &lt;code&gt;A.T @ A&lt;/code&gt; and &lt;code&gt;A @ A.T&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99a9abbcaa67a245b7df3c4aa99c089ac4fab21b" translate="yes" xml:space="preserve">
          <source>Optimizing a looping block by specialized code. In a traditional sense, vectorization performs the same operation on multiple elements with fixed strides between them via specialized hardware. Compilers know how to take advantage of well-constructed loops to implement such optimizations. NumPy uses &lt;a href=&quot;user/whatisnumpy#whatis-vectorization&quot;&gt;vectorization&lt;/a&gt; to mean any optimization via specialized code performing the same operations on multiple elements, typically achieving speedups by avoiding some of the overhead in looking up and converting the elements.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="92272bcec6c59382899a85edc8fe1911432803d7" translate="yes" xml:space="preserve">
          <source>Option whether to print a line feed or not. Defaults to True.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f1be0f36b97d1f66b6be8a1b7591fde1a83a0d94" translate="yes" xml:space="preserve">
          <source>Optional &lt;code&gt;axis&lt;/code&gt; argument for methods like &lt;a href=&quot;generated/numpy.random.generator.choice#numpy.random.Generator.choice&quot;&gt;&lt;code&gt;choice&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;generated/numpy.random.generator.permutation#numpy.random.Generator.permutation&quot;&gt;&lt;code&gt;permutation&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;generated/numpy.random.generator.shuffle#numpy.random.Generator.shuffle&quot;&gt;&lt;code&gt;shuffle&lt;/code&gt;&lt;/a&gt; that controls which axis an operation is performed over for multi-dimensional arrays.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb8be51f4f30d13faa44a6de0502a01108e24089" translate="yes" xml:space="preserve">
          <source>Optional &lt;code&gt;dtype&lt;/code&gt; argument that accepts &lt;code&gt;np.float32&lt;/code&gt; or &lt;code&gt;np.float64&lt;/code&gt; to produce either single or double prevision uniform random variables for select distributions</source>
          <target state="translated">Необязательный аргумент &lt;code&gt;dtype&lt;/code&gt; , который принимает &lt;code&gt;np.float32&lt;/code&gt; или &lt;code&gt;np.float64&lt;/code&gt; для создания однородных случайных величин с одинарным или двойным предвидением для выбранных распределений</target>
        </trans-unit>
        <trans-unit id="12126826f76c7f0467a4ffb91534c1d1ec680e4d" translate="yes" xml:space="preserve">
          <source>Optional &lt;code&gt;out&lt;/code&gt; argument that allows existing arrays to be filled for select distributions</source>
          <target state="translated">Необязательный аргумент &lt;code&gt;out&lt;/code&gt; , который позволяет заполнять существующие массивы для выбранных распределений</target>
        </trans-unit>
        <trans-unit id="01273e336bfe0a367b1748fe162d52aafeac5e31" translate="yes" xml:space="preserve">
          <source>Optional arguments &lt;code&gt;start&lt;/code&gt; and &lt;code&gt;end&lt;/code&gt; are interpreted as in slice notation.</source>
          <target state="translated">Необязательные аргументы &lt;code&gt;start&lt;/code&gt; и &lt;code&gt;end&lt;/code&gt; интерпретируются как в нотации среза.</target>
        </trans-unit>
        <trans-unit id="ad0126e97a8970efb03fe063de9451fa05d68f3f" translate="yes" xml:space="preserve">
          <source>Optional arguments &lt;code&gt;start&lt;/code&gt; and &lt;code&gt;end&lt;/code&gt; are interpreted as slice notation to specify the range in which to count.</source>
          <target state="translated">Необязательные аргументы &lt;code&gt;start&lt;/code&gt; и &lt;code&gt;end&lt;/code&gt; интерпретируются как нотация среза, чтобы указать диапазон, в котором следует вести подсчет.</target>
        </trans-unit>
        <trans-unit id="4dd32917dfd5f66fb159ebdd50889a1b4bed7749" translate="yes" xml:space="preserve">
          <source>Optional array of integer indices that sort array a into ascending order. They are typically the result of argsort.</source>
          <target state="translated">Необязательный массив целочисленных индексов,который сортирует массив a в порядке возрастания.Обычно они являются результатом аргументации.</target>
        </trans-unit>
        <trans-unit id="6024e1a91279063fb7e7889daf1b6251045d44cb" translate="yes" xml:space="preserve">
          <source>Optional character strings placed as the first element of the index expression can be used to change the output. The strings &amp;lsquo;r&amp;rsquo; or &amp;lsquo;c&amp;rsquo; result in matrix output. If the result is 1-D and &amp;lsquo;r&amp;rsquo; is specified a 1 x N (row) matrix is produced. If the result is 1-D and &amp;lsquo;c&amp;rsquo; is specified, then a N x 1 (column) matrix is produced. If the result is 2-D then both provide the same matrix result.</source>
          <target state="translated">Необязательные символьные строки, помещенные в качестве первого элемента индексного выражения, могут использоваться для изменения вывода. Строки 'r' или 'c' приводят к матричному выводу. Если результат 1-D и задано 'r', создается матрица размером 1 x N (строка). Если результат 1-D и задано 'c', то создается матрица N x 1 (столбец). Если результат является двумерным, то оба дают одинаковый матричный результат.</target>
        </trans-unit>
        <trans-unit id="fa7999c926f6055eca464cd4cd0189771a96574e" translate="yes" xml:space="preserve">
          <source>Optional keyword arguments</source>
          <target state="translated">Необязательные аргументы в пользу ключевого слова</target>
        </trans-unit>
        <trans-unit id="957ed642dc25daf64f22e9ce4f2d86f58626bccf" translate="yes" xml:space="preserve">
          <source>Optional keyword parameters have default values, which are displayed as part of the function signature. They can also be detailed in the description:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a5739d18910534a4fc38a98f7f49af50c8efbd3" translate="yes" xml:space="preserve">
          <source>Optional reduced verbosity for np.distutils</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5e7d5ecd852396fa81676288ee6a2c196a7a5edc" translate="yes" xml:space="preserve">
          <source>Optional: Check which files have changed with &lt;code&gt;git status&lt;/code&gt; (see &lt;a href=&quot;https://www.kernel.org/pub/software/scm/git/docs/git-status.html&quot;&gt;git status&lt;/a&gt;). You&amp;rsquo;ll see a listing like this one:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc6f5f42f191b45dd21642dce26f8c271e45fd28" translate="yes" xml:space="preserve">
          <source>Optional: Compare the changes with the previous version using with &lt;code&gt;git
diff&lt;/code&gt; (&lt;a href=&quot;https://www.kernel.org/pub/software/scm/git/docs/git-diff.html&quot;&gt;git diff&lt;/a&gt;). This brings up a simple text browser interface that highlights the difference between your files and the previous version.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b391073386a52a6e7c7d2a204ec775ecfe3f5d3a" translate="yes" xml:space="preserve">
          <source>Optional: set up SSH keys to avoid passwords</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a1956660192de93e6ae71981428d48e53a65ccc" translate="yes" xml:space="preserve">
          <source>Optionally SciPy-accelerated routines (&lt;code&gt;numpy.dual&lt;/code&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="32c0f096a4d20dec7aa72b3d7d08a3d6f13db350" translate="yes" xml:space="preserve">
          <source>Optionally SciPy-accelerated routines (numpy.dual)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8eb0ace95d7206d55e77238265b3a66f3d4c761a" translate="yes" xml:space="preserve">
          <source>Optionally Scipy-accelerated routines (&lt;code&gt;numpy.dual&lt;/code&gt;)</source>
          <target state="translated">Необязательно Scipy-ускоренные процедуры ( &lt;code&gt;numpy.dual&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="a841da812f87c91971335f8748cac5433932b134" translate="yes" xml:space="preserve">
          <source>Optionally Scipy-accelerated routines (numpy.dual)</source>
          <target state="translated">Опционально Scipy-скоростные программы (numpy.dual)</target>
        </trans-unit>
        <trans-unit id="8836fa518e3fcc554024b475844ea5ac0ecd26c6" translate="yes" xml:space="preserve">
          <source>Optionally, F2PY created signature files can be edited to optimize wrappers functions, make them &amp;ldquo;smarter&amp;rdquo; and more &amp;ldquo;Pythonic&amp;rdquo;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a19671beddc2d78364aeb52dc43b5315cb3a7f11" translate="yes" xml:space="preserve">
          <source>Or a non uniform one:</source>
          <target state="translated">Или не в форме:</target>
        </trans-unit>
        <trans-unit id="8fe65c617425af9e2c3d6f2775ea339d5f9f089e" translate="yes" xml:space="preserve">
          <source>Or a similar way from the command line:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="953f087657473d16d4beb73a89ced5320c3f6acc" translate="yes" xml:space="preserve">
          <source>Or an array filled with &lt;code&gt;1&lt;/code&gt;&amp;rsquo;s:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf7ef857cc1fde38181b075860bab6fb0bd52da8" translate="yes" xml:space="preserve">
          <source>Or as a decorator:</source>
          <target state="translated">Или как декоратор:</target>
        </trans-unit>
        <trans-unit id="c7e6a42ed35b95f820330f765f1edafa77be23aa" translate="yes" xml:space="preserve">
          <source>Or even an empty array! The function &lt;code&gt;empty&lt;/code&gt; creates an array whose initial content is random and depends on the state of the memory. The reason to use &lt;code&gt;empty&lt;/code&gt; over &lt;code&gt;zeros&lt;/code&gt; (or something similar) is speed - just make sure to fill every element afterwards!</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="de9b2d57a173de94af257f54a0e80ee07c9cf0f4" translate="yes" xml:space="preserve">
          <source>Or for a vectorized convolution:</source>
          <target state="translated">Или для векторизованного свертывания:</target>
        </trans-unit>
        <trans-unit id="b0d8b33e98de773e2f38b3003cb0a7e130e442fc" translate="yes" xml:space="preserve">
          <source>Or from the command line:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="87d726b49f504d34574328c172ded1bdd16da0e2" translate="yes" xml:space="preserve">
          <source>Or if you add &lt;code&gt;numpy/xxx/tests/&lt;/code&gt; to the Python path, you could run the tests interactively in the interpreter like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="60d67dbe290ba345acdc7d9f67357d1c9ca90c84" translate="yes" xml:space="preserve">
          <source>Or if you add &lt;code&gt;scipy/xxx/tests/&lt;/code&gt; to the Python path, you could run the tests interactively in the interpreter like this:</source>
          <target state="translated">Или, если вы добавите &lt;code&gt;scipy/xxx/tests/&lt;/code&gt; в путь Python, вы можете запустить тесты в интерактивном режиме в интерпретаторе следующим образом:</target>
        </trans-unit>
        <trans-unit id="86168e460ad3421414419c2552c4c8f1c87145ff" translate="yes" xml:space="preserve">
          <source>Or more generally, the f2cmap file must contain a dictionary with items:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a034f1d60dd7621f858f2d8cd0dbc13046363fae" translate="yes" xml:space="preserve">
          <source>Or reverse only the &lt;em&gt;columns&lt;/em&gt; with:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="002d2f07f89a6dd55f4dbdba5b6f9608201e1d77" translate="yes" xml:space="preserve">
          <source>Or select specific elements to include:</source>
          <target state="translated">Или выберите конкретные элементы для включения:</target>
        </trans-unit>
        <trans-unit id="91f70ad6cdb41e4acfd7bf765e82bbdee8fa8d5e" translate="yes" xml:space="preserve">
          <source>Or stack them horizontally with &lt;code&gt;hstack&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="56c3ddf3aab6700d937d53be3d5b45771f361386" translate="yes" xml:space="preserve">
          <source>Or wish to add a constant to all negative elements:</source>
          <target state="translated">Или хотите добавить константу ко всем негативным элементам:</target>
        </trans-unit>
        <trans-unit id="9ed306dae12d1d39fff858942862ae59bbc4399d" translate="yes" xml:space="preserve">
          <source>Or without &lt;code&gt;np.ix_&lt;/code&gt; (compare the integer array examples):</source>
          <target state="translated">Или без &lt;code&gt;np.ix_&lt;/code&gt; (сравните примеры целочисленных массивов):</target>
        </trans-unit>
        <trans-unit id="05b188193e465d376dab17b5c2f6bf78bee37c0c" translate="yes" xml:space="preserve">
          <source>Or you can open the file any time with a text editor!</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b97c15fab9ba4d55adcaf397914137e45e790605" translate="yes" xml:space="preserve">
          <source>Or you can select elements that satisfy two conditions using the &lt;code&gt;&amp;amp;&lt;/code&gt; and &lt;code&gt;|&lt;/code&gt; operators:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="522e527e2f2a0e03657e01d30970c004e213dc85" translate="yes" xml:space="preserve">
          <source>Or, for a column vector, you can insert an axis along the second dimension:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb0c3124f81c1d85f2179239c9449534ba1cd1e5" translate="yes" xml:space="preserve">
          <source>Or, if you start with these arrays:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="00fcdda14949d42c1610edfba9ca80d41d59564f" translate="yes" xml:space="preserve">
          <source>Or:</source>
          <target state="translated">Or:</target>
        </trans-unit>
        <trans-unit id="57f93044bc0a408687e6b01e33395f89ff4d70a4" translate="yes" xml:space="preserve">
          <source>Order of differentiation (default: 1)</source>
          <target state="translated">Порядок дифференциации (по умолчанию:1)</target>
        </trans-unit>
        <trans-unit id="788c2fe754b6f79f4fc9b0b665993b8ce7234c19" translate="yes" xml:space="preserve">
          <source>Order of integration, must be positive. (Default: 1)</source>
          <target state="translated">Порядок интеграции должен быть положительным.(По умолчанию:1)</target>
        </trans-unit>
        <trans-unit id="a5353df5e917b478408b634f2bf535553074c600" translate="yes" xml:space="preserve">
          <source>Order of operations optimization in &lt;code&gt;np.einsum&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="41ad4bbf3f62befe7c196979bd8380406f97a913" translate="yes" xml:space="preserve">
          <source>Order of the antiderivative. (Default: 1)</source>
          <target state="translated">Орден на антидепрессанты.(По умолчанию:1)</target>
        </trans-unit>
        <trans-unit id="c2ecce42b9cac400a1b6d5085507c247c9b755ae" translate="yes" xml:space="preserve">
          <source>Order of the data for multidimensional arrays: C, Fortran, or the same as for the original array.</source>
          <target state="translated">Порядок данных для многомерных массивов:С,Фортран или тот же самый,что и для исходного массива.</target>
        </trans-unit>
        <trans-unit id="1c001b919a2f52d0fbb20d49a83e3f37a24b3cfa" translate="yes" xml:space="preserve">
          <source>Order of the data item in the copy. Default is &amp;lsquo;C&amp;rsquo;.</source>
          <target state="translated">Порядок элемента данных в копии. По умолчанию - &amp;laquo;C&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="f847d5dac01910a77c77edf954ad824a1e14efe8" translate="yes" xml:space="preserve">
          <source>Order of the norm (see table under &lt;code&gt;Notes&lt;/code&gt;). inf means numpy&amp;rsquo;s &lt;a href=&quot;../constants#numpy.inf&quot;&gt;&lt;code&gt;inf&lt;/code&gt;&lt;/a&gt; object. The default is None.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46f142fafd57c235130d4ec687878d429370c853" translate="yes" xml:space="preserve">
          <source>Order of the norm (see table under &lt;code&gt;Notes&lt;/code&gt;). inf means numpy&amp;rsquo;s &lt;code&gt;inf&lt;/code&gt; object.</source>
          <target state="translated">Порядок нормы (см. Таблицу в &lt;code&gt;Notes&lt;/code&gt; ). Inf означает Numpy в &lt;code&gt;inf&lt;/code&gt; объект.</target>
        </trans-unit>
        <trans-unit id="b66f9f860fc227b1d5431e30c1b51053269954ff" translate="yes" xml:space="preserve">
          <source>Order of the norm (see table under &lt;code&gt;Notes&lt;/code&gt;). inf means numpy&amp;rsquo;s &lt;code&gt;inf&lt;/code&gt; object. The default is None.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="accc210a4b093569ae3685cc2f2612720dea8f1e" translate="yes" xml:space="preserve">
          <source>Order of the norm:</source>
          <target state="translated">Порядок нормы:</target>
        </trans-unit>
        <trans-unit id="b8a7abb1120bc925fdb57310f93f2fa464fdc7ae" translate="yes" xml:space="preserve">
          <source>Order of the powers of the columns. If True, the powers increase from left to right, if False (the default) they are reversed.</source>
          <target state="translated">Порядок полномочий колонн.Если Верно,то полномочия увеличиваются слева направо,если Ложно (по умолчанию),то они меняются на противоположные.</target>
        </trans-unit>
        <trans-unit id="9ad696b93bae4cfca8937f28f2148899d7322e0a" translate="yes" xml:space="preserve">
          <source>Order statistics</source>
          <target state="translated">Статистика заказов</target>
        </trans-unit>
        <trans-unit id="422e3f686c9f8818631b86e59adef2a48327ba9b" translate="yes" xml:space="preserve">
          <source>Ordered list of field names, or &lt;code&gt;None&lt;/code&gt; if there are no fields.</source>
          <target state="translated">Упорядоченный список имен полей или &lt;code&gt;None&lt;/code&gt; , если полей нет.</target>
        </trans-unit>
        <trans-unit id="d3ed86c1334d74f0ae883f47feef902d83b9d8c6" translate="yes" xml:space="preserve">
          <source>Ordering</source>
          <target state="translated">Ordering</target>
        </trans-unit>
        <trans-unit id="d1225815854e81b81f3a0215f90f105cc1022337" translate="yes" xml:space="preserve">
          <source>Ordinarly, vector operands must all be the same size, because NumPy works element by element &amp;ndash; for instance, &lt;code&gt;c = a * b&lt;/code&gt; is</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d44d98096c18e71b1176f355d8b6f0c7c16e1d1" translate="yes" xml:space="preserve">
          <source>Ordinary inner product for vectors:</source>
          <target state="translated">Обычный внутренний продукт для векторов:</target>
        </trans-unit>
        <trans-unit id="191b600520d98586a88c24fcdd4e2889be08fced" translate="yes" xml:space="preserve">
          <source>Ordinary inner product of vectors for 1-D arrays (without complex conjugation), in higher dimensions a sum product over the last axes.</source>
          <target state="translated">Обычное внутреннее произведение векторов для 1-D массивов (без комплексного спряжения),в более высоких размерах суммарное произведение по последним осям.</target>
        </trans-unit>
        <trans-unit id="eb7dc7265e25691a9373e1ca80276306cb88c7ca" translate="yes" xml:space="preserve">
          <source>Ordinate or &amp;ldquo;dependent variable&amp;rdquo; values.</source>
          <target state="translated">Значения ординат или &amp;laquo;зависимой переменной&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="8c7ff7749bfea5af2d2c09b7c86b2dbdfee56f2a" translate="yes" xml:space="preserve">
          <source>Ordinate or &amp;ldquo;dependent variable&amp;rdquo; values. If &lt;code&gt;b&lt;/code&gt; is two-dimensional, the least-squares solution is calculated for each of the &lt;code&gt;K&lt;/code&gt; columns of &lt;code&gt;b&lt;/code&gt;.</source>
          <target state="translated">Значения ординат или &amp;laquo;зависимой переменной&amp;raquo;. Если &lt;code&gt;b&lt;/code&gt; является двумерным, решение методом наименьших квадратов вычисляется для каждого из &lt;code&gt;K&lt;/code&gt; столбцов &lt;code&gt;b&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bedfebf0ecf8e3c63711ee41881ab8ce7f77971c" translate="yes" xml:space="preserve">
          <source>Original Source</source>
          <target state="translated">Первоисточник</target>
        </trans-unit>
        <trans-unit id="92bff9048309d096b7578598a0790ad0978b76db" translate="yes" xml:space="preserve">
          <source>Original Source of the Generator and BitGenerators</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f05a12c3fefa36c0646baab0998b9e0baf27dee" translate="yes" xml:space="preserve">
          <source>Original author: Robert Cimrman</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01d77937700b7f6304cd9cc6f6f114b310986845" translate="yes" xml:space="preserve">
          <source>Original positions of the axes to move. These must be unique.</source>
          <target state="translated">Исходные положения осей для перемещения.Они должны быть уникальными.</target>
        </trans-unit>
        <trans-unit id="6e6a6f2086bb5fe5dbfd17d8d5f502d48759834b" translate="yes" xml:space="preserve">
          <source>Other</source>
          <target state="translated">Other</target>
        </trans-unit>
        <trans-unit id="34d7150cfcec917eee04da671286a02a27c1a6b8" translate="yes" xml:space="preserve">
          <source>Other (void * &amp;ndash; each item is a fixed-size chunk of memory)</source>
          <target state="translated">Другое (void * - каждый элемент представляет собой фрагмент памяти фиксированного размера)</target>
        </trans-unit>
        <trans-unit id="16863278e548d66fae935c08b81b275cea6f9914" translate="yes" xml:space="preserve">
          <source>Other C-Structures</source>
          <target state="translated">Другие С-структуры</target>
        </trans-unit>
        <trans-unit id="c5164a0d79a937ac6a201b20d3ffe5ea4af04bc1" translate="yes" xml:space="preserve">
          <source>Other Common Types: bool</source>
          <target state="translated">Другие распространенные типы:шерсть</target>
        </trans-unit>
        <trans-unit id="9a529214aef07d296fc3d4d086152694a3e98921" translate="yes" xml:space="preserve">
          <source>Other Common Types: complex</source>
          <target state="translated">Другие распространенные типы:сложные</target>
        </trans-unit>
        <trans-unit id="708bf6f62e354ff314651598e7eebc62fd8d2bb2" translate="yes" xml:space="preserve">
          <source>Other Parameters</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0faa321ae463cf423d057b0fb19c09b0142f3c2a" translate="yes" xml:space="preserve">
          <source>Other Parameters:</source>
          <target state="translated">Другие параметры:</target>
        </trans-unit>
        <trans-unit id="3a704886f69c3b776903fa1eae3b74661fb05227" translate="yes" xml:space="preserve">
          <source>Other Polynomial Constructors</source>
          <target state="translated">Другие полиномические конструкторы</target>
        </trans-unit>
        <trans-unit id="407cab4f45e3f1e45a4d3d8364006412c6cfc5cd" translate="yes" xml:space="preserve">
          <source>Other Situations</source>
          <target state="translated">Другие ситуации</target>
        </trans-unit>
        <trans-unit id="ae276ac9fe79a4b2444ced92d93c1c04bd2cde2e" translate="yes" xml:space="preserve">
          <source>Other aliases</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d042bb243a9d93f7d217c6e5a0c1a49c971c43e7" translate="yes" xml:space="preserve">
          <source>Other attributes</source>
          <target state="translated">Другие атрибуты</target>
        </trans-unit>
        <trans-unit id="e84477e1de2ec14b541d8664b31b8881de493393" translate="yes" xml:space="preserve">
          <source>Other axes remain in their original order.</source>
          <target state="translated">Другие топоры остаются в своем первоначальном порядке.</target>
        </trans-unit>
        <trans-unit id="94a56f444dca5dd30ab9a1fe9100b3b01d86f467" translate="yes" xml:space="preserve">
          <source>Other build options</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="767a6c3afafd0ae34a74385fb566d6175cb96b17" translate="yes" xml:space="preserve">
          <source>Other constants</source>
          <target state="translated">Другие константы</target>
        </trans-unit>
        <trans-unit id="ed4b1121b10e2ed9c2b0a79e79f85e8ad19d33ae" translate="yes" xml:space="preserve">
          <source>Other conversions</source>
          <target state="translated">Другие преобразования</target>
        </trans-unit>
        <trans-unit id="b0c0a3787c5b36b4fe5b178d91a655c6a5cbdf6b" translate="yes" xml:space="preserve">
          <source>Other files</source>
          <target state="translated">Другие файлы</target>
        </trans-unit>
        <trans-unit id="e12e322f5b694198963cd183428de579cc666876" translate="yes" xml:space="preserve">
          <source>Other functions</source>
          <target state="translated">Другие функции</target>
        </trans-unit>
        <trans-unit id="1cddb5c0e17d84098d16d9325f9cc36b4d8d05b6" translate="yes" xml:space="preserve">
          <source>Other indexing options</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e0b002f2786124a662470fe9d1d4b2061560ed34" translate="yes" xml:space="preserve">
          <source>Other keys that can be used to set a group of types at once are:</source>
          <target state="translated">Другие клавиши,которые можно использовать для одновременной установки группы типов:</target>
        </trans-unit>
        <trans-unit id="04009c322c38e522287cb7657248010dcf883c3a" translate="yes" xml:space="preserve">
          <source>Other methods of running tests</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee6b0460067623519cc565a472bd480c100039cf" translate="yes" xml:space="preserve">
          <source>Other modules</source>
          <target state="translated">Другие модули</target>
        </trans-unit>
        <trans-unit id="486d94e1070b48b0053b9b70f1f9be9f4d9d5bf1" translate="yes" xml:space="preserve">
          <source>Other new functions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="599ffbd6e95e9102a19874cfc765e0666e6a5f25" translate="yes" xml:space="preserve">
          <source>Other options:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a99a2c4e58511e531864aed996a281648e9837a1" translate="yes" xml:space="preserve">
          <source>Other points to keep in mind</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="312a81da2e8af18ed2deb2ba9e65ed60e75f7dbe" translate="yes" xml:space="preserve">
          <source>Other related special value functions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b56243f47f05b7964d5f4fc1a7a1d5dc330f1664" translate="yes" xml:space="preserve">
          <source>Other special functions</source>
          <target state="translated">Другие специальные функции</target>
        </trans-unit>
        <trans-unit id="9cc692beb493cdd7b095a31706521fdb297cd3ab" translate="yes" xml:space="preserve">
          <source>Other statements:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b28f6f004c86b1b4979a17c950470ea4d696d78" translate="yes" xml:space="preserve">
          <source>Other than the view syntax, the function is immediately readable to a Python programmer. Static typing of the variable &lt;code&gt;i&lt;/code&gt; is implicit. Instead of the view syntax, we could also have used Cython&amp;rsquo;s special NumPy array syntax, but the view syntax is preferred.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c5befcc2e0951ae7c577c186d5015110ab50c93" translate="yes" xml:space="preserve">
          <source>Other types</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="db156a16585b32767d434efac29632f353ee893f" translate="yes" xml:space="preserve">
          <source>Other useful flags that can be OR&amp;rsquo;d as additional requirements are:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d80ae13d27005970d36a64205ad27c701906310c" translate="yes" xml:space="preserve">
          <source>Other useful related constants are</source>
          <target state="translated">Другими полезными связанными константами являются</target>
        </trans-unit>
        <trans-unit id="da626da9b3eb80a71166ddec09244cef236be1ee" translate="yes" xml:space="preserve">
          <source>Other ways to contribute</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b60a0a7b60b2c507b8c7be2f403c23dd728c5542" translate="yes" xml:space="preserve">
          <source>Otherwise F2PY makes a contiguous copy (with a proper dtype) of the input array and passes C pointer of the copy to Fortran subroutine. As a result, any possible changes to the (copy of) input array have no effect to the original argument, as demonstrated below:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01dc3acd71c35a47919d5dc18e67e38bbe2ca711" translate="yes" xml:space="preserve">
          <source>Otherwise we recommend simply learning to reverse the usual order of indices when accessing elements of an array. Granted, it goes against the grain, but it is more in line with Python semantics and the natural order of the data.</source>
          <target state="translated">В противном случае мы рекомендуем просто научиться менять обычный порядок индексов при доступе к элементам массива.Конечно,это идет против зерна,но больше соответствует семантике Python и естественному порядку данных.</target>
        </trans-unit>
        <trans-unit id="29b9f8169fedb0ad1c9be824eca55314fa16d94e" translate="yes" xml:space="preserve">
          <source>Otherwise, &lt;a href=&quot;numpy.min_scalar_type#numpy.min_scalar_type&quot;&gt;&lt;code&gt;min_scalar_type&lt;/code&gt;&lt;/a&gt; is called on each array, and the resulting data types are all combined with &lt;a href=&quot;numpy.promote_types#numpy.promote_types&quot;&gt;&lt;code&gt;promote_types&lt;/code&gt;&lt;/a&gt; to produce the return value.</source>
          <target state="translated">В противном случае для каждого массива &lt;a href=&quot;numpy.min_scalar_type#numpy.min_scalar_type&quot;&gt; &lt;code&gt;min_scalar_type&lt;/code&gt; &lt;/a&gt; , и все результирующие типы данных объединяются с &lt;a href=&quot;numpy.promote_types#numpy.promote_types&quot;&gt; &lt;code&gt;promote_types&lt;/code&gt; &lt;/a&gt; для получения возвращаемого значения.</target>
        </trans-unit>
        <trans-unit id="fae9e7a3585b77fe783d86ad593d20c5ecc3f354" translate="yes" xml:space="preserve">
          <source>Otherwise, PyArray_MinScalarType is called on each array, and the resulting data types are all combined with &lt;a href=&quot;#c.PyArray_PromoteTypes&quot;&gt;&lt;code&gt;PyArray_PromoteTypes&lt;/code&gt;&lt;/a&gt; to produce the return value.</source>
          <target state="translated">В противном случае PyArray_MinScalarType вызывается для каждого массива, и все результирующие типы данных объединяются с &lt;a href=&quot;#c.PyArray_PromoteTypes&quot;&gt; &lt;code&gt;PyArray_PromoteTypes&lt;/code&gt; &lt;/a&gt; для получения возвращаемого значения.</target>
        </trans-unit>
        <trans-unit id="a5347d369bb3cc80acdc3e9eec52dbe20542bf3e" translate="yes" xml:space="preserve">
          <source>Otherwise, only the &lt;code&gt;zip&lt;/code&gt; and &lt;code&gt;pdf&lt;/code&gt; links should be updated with the new tag name:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fcd38ba9fb1f1dbc35dcac58860b6157e6882b67" translate="yes" xml:space="preserve">
          <source>Our &lt;code&gt;MySubClass.__new__&lt;/code&gt; method only gets called in the case of the explicit constructor call, so we can&amp;rsquo;t rely on &lt;code&gt;MySubClass.__new__&lt;/code&gt; or &lt;code&gt;MySubClass.__init__&lt;/code&gt; to deal with the view casting and new-from-template. It turns out that &lt;code&gt;MySubClass.__array_finalize__&lt;/code&gt;&lt;em&gt;does&lt;/em&gt; get called for all three methods of object creation, so this is where our object creation housekeeping usually goes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="16c471225c8348ecdf3cb9056eeb4166b9df8525" translate="yes" xml:space="preserve">
          <source>Our current rules:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5388893497a63e10962c70e1e04399dd9d5a42e3" translate="yes" xml:space="preserve">
          <source>Our custom array can be instantiated like:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf78b3f6f52a00f298a7bfb0726e5baf2bd452dd" translate="yes" xml:space="preserve">
          <source>Our docstring standard uses &lt;a href=&quot;http://docutils.sourceforge.net/rst.html&quot;&gt;re-structured text (reST)&lt;/a&gt; syntax and is rendered using &lt;a href=&quot;http://sphinx.pocoo.org&quot;&gt;Sphinx&lt;/a&gt; (a pre-processor that understands the particular documentation style we are using). While a rich set of markup is available, we limit ourselves to a very basic subset, in order to provide docstrings that are easy to read on text-only terminals.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="699b767a44afe4a72b5254c097705dfd2fc0c0eb" translate="yes" xml:space="preserve">
          <source>Our final example is a ufunc with multiple arguments. It is a modification of the code for a logit ufunc for data with a single dtype. We compute (A*B, logit(A*B)).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd99f75ef9c59f37909a92800122629525cfc030" translate="yes" xml:space="preserve">
          <source>Our goal is that every module and package in NumPy should have a thorough set of unit tests. These tests should exercise the full functionality of a given routine as well as its robustness to erroneous or unexpected input arguments. Long experience has shown that by far the best time to write the tests is before you write or change the code - this is &lt;a href=&quot;https://en.wikipedia.org/wiki/Test-driven_development&quot;&gt;test-driven development&lt;/a&gt;. The arguments for this can sound rather abstract, but we can assure you that you will find that writing the tests first leads to more robust and better designed code. Well-designed tests with good coverage make an enormous difference to the ease of refactoring. Whenever a new bug is found in a routine, you should write a new test for that specific case and add it to the test suite to prevent that bug from creeping back in unnoticed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e4eb13334b28d2a094a12f8ab9ba2e910911e99a" translate="yes" xml:space="preserve">
          <source>Our goal is that every module and package in SciPy and NumPy should have a thorough set of unit tests. These tests should exercise the full functionality of a given routine as well as its robustness to erroneous or unexpected input arguments. Long experience has shown that by far the best time to write the tests is before you write or change the code - this is &lt;a href=&quot;https://en.wikipedia.org/wiki/Test-driven_development&quot;&gt;test-driven development&lt;/a&gt;. The arguments for this can sound rather abstract, but we can assure you that you will find that writing the tests first leads to more robust and better designed code. Well-designed tests with good coverage make an enormous difference to the ease of refactoring. Whenever a new bug is found in a routine, you should write a new test for that specific case and add it to the test suite to prevent that bug from creeping back in unnoticed.</source>
          <target state="translated">Наша цель состоит в том, чтобы каждый модуль и пакет в SciPy и NumPy имел тщательный набор модульных тестов. Эти тесты должны продемонстрировать полную функциональность данной процедуры, а также ее устойчивость к ошибочным или неожиданным входным аргументам. Многолетний опыт показал, что, безусловно, лучшее время для написания тестов - это до того, как вы напишете или измените код - это разработка через &lt;a href=&quot;https://en.wikipedia.org/wiki/Test-driven_development&quot;&gt;тестирование.&lt;/a&gt;, Аргументы в пользу этого могут звучать довольно абстрактно, но мы можем заверить вас, что вы обнаружите, что написание тестов в первую очередь приводит к более надежному и лучше спроектированному коду. Хорошо спроектированные тесты с хорошим покрытием имеют огромное значение для простоты рефакторинга. Каждый раз, когда в рутине обнаруживается новая ошибка, вы должны написать новый тест для этого конкретного случая и добавить его в набор тестов, чтобы предотвратить появление этой ошибки незамеченной.</target>
        </trans-unit>
        <trans-unit id="d68e5db67be9b03d20fd91c37de52993f3c9d547" translate="yes" xml:space="preserve">
          <source>Our main means of communication are:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2469d2ebc8c77151c167772e7a4f4b5ae56c779b" translate="yes" xml:space="preserve">
          <source>Our markup language is reStructuredText (rST), which is more elaborate than Markdown. Sphinx, the tool many Python projects use to build and link project documentation, converts the rST into HTML and other formats. For more on rST, see the &lt;a href=&quot;https://docutils.sourceforge.io/docs/user/rst/quickref.html&quot;&gt;Quick reStructuredText Guide&lt;/a&gt; or the &lt;a href=&quot;https://www.sphinx-doc.org/en/stable/usage/restructuredtext/basics.html&quot;&gt;reStructuredText Primer&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="092ac50b2f1d2b5a2fd5de4d521d3e71263ef97d" translate="yes" xml:space="preserve">
          <source>Our own &lt;a href=&quot;http://matthew-brett.github.com/pydagogue/foundation.html&quot;&gt;git foundation&lt;/a&gt; expands on the &lt;a href=&quot;http://tom.preston-werner.com/2009/05/19/the-git-parable.html&quot;&gt;git parable&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="09929ef69018d98fc6ab68200819ee812816f740" translate="yes" xml:space="preserve">
          <source>Our own &lt;a href=&quot;https://matthew-brett.github.com/pydagogue/foundation.html&quot;&gt;git foundation&lt;/a&gt; expands on the &lt;a href=&quot;http://tom.preston-werner.com/2009/05/19/the-git-parable.html&quot;&gt;git parable&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="154d74419b6aca893341269b8ba48a9e26a16006" translate="yes" xml:space="preserve">
          <source>Out has the same shape as &lt;code&gt;x&lt;/code&gt;. Its real part is in &lt;code&gt;[-pi/2, pi/2]&lt;/code&gt; (&lt;code&gt;arctan(+/-inf)&lt;/code&gt; returns &lt;code&gt;+/-pi/2&lt;/code&gt;). This is a scalar if &lt;code&gt;x&lt;/code&gt; is a scalar.</source>
          <target state="translated">Out имеет ту же форму, что и &lt;code&gt;x&lt;/code&gt; . Его действительная часть находится в &lt;code&gt;[-pi/2, pi/2]&lt;/code&gt; ( &lt;code&gt;arctan(+/-inf)&lt;/code&gt; возвращает &lt;code&gt;+/-pi/2&lt;/code&gt; ). Это скаляр, если &lt;code&gt;x&lt;/code&gt; - скаляр.</target>
        </trans-unit>
        <trans-unit id="851f8da769fc08fe920a7a332149d07bd3e21638" translate="yes" xml:space="preserve">
          <source>Out of the box, &lt;code&gt;numpy.i&lt;/code&gt; provides typemaps that support conversion between NumPy arrays and C arrays:</source>
          <target state="translated">По &lt;code&gt;numpy.i&lt;/code&gt; предоставляет карты типов, которые поддерживают преобразование между массивами NumPy и массивами C:</target>
        </trans-unit>
        <trans-unit id="b99f04d1fc495fb457ec6ab4bb045f1b70e94783" translate="yes" xml:space="preserve">
          <source>Outer Product Iteration</source>
          <target state="translated">Внешняя итерация продукта</target>
        </trans-unit>
        <trans-unit id="c6ee0caa49ecd5d48b8b76e247cdb1d691fc307b" translate="yes" xml:space="preserve">
          <source>Outer product, same as &lt;code&gt;outer(x, y)&lt;/code&gt;:</source>
          <target state="translated">Внешний продукт, такой же, как и &lt;code&gt;outer(x, y)&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="f31dd41cdb77529134dabee0a5149b6913233527" translate="yes" xml:space="preserve">
          <source>Outer product.</source>
          <target state="translated">Внешний продукт.</target>
        </trans-unit>
        <trans-unit id="a8eb7f250550fb11f31a150896a2c233c22e5afb" translate="yes" xml:space="preserve">
          <source>Output Arrays</source>
          <target state="translated">Выходные массивы</target>
        </trans-unit>
        <trans-unit id="69721e85622681a00d5e83b618b8602f51f2805c" translate="yes" xml:space="preserve">
          <source>Output a 3x8000 array:</source>
          <target state="translated">Вывод массива 3x8000:</target>
        </trans-unit>
        <trans-unit id="7156471f771c478a3049744cdf9adc5be3b74b53" translate="yes" xml:space="preserve">
          <source>Output argument. This must have the exact kind that would be returned if it was not used. In particular, it must have the right type, must be C-contiguous, and its dtype must be the dtype that would be returned for &lt;code&gt;dot(a, b)&lt;/code&gt;. This is a performance feature. Therefore, if these conditions are not met, an exception is raised, instead of attempting to be flexible.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="92e70b270c18c83f26e6230a7a984b1fb40cee94" translate="yes" xml:space="preserve">
          <source>Output argument. This must have the exact kind that would be returned if it was not used. In particular, it must have the right type, must be C-contiguous, and its dtype must be the dtype that would be returned for &lt;code&gt;dot(a,b)&lt;/code&gt;. This is a performance feature. Therefore, if these conditions are not met, an exception is raised, instead of attempting to be flexible.</source>
          <target state="translated">Выходной аргумент. Он должен иметь точный вид, который был бы возвращен, если бы он не использовался. В частности, он должен иметь правильный тип, быть C-смежным, а его dtype должен быть dtype, который будет возвращен для &lt;code&gt;dot(a,b)&lt;/code&gt; . Это характеристика производительности. Следовательно, если эти условия не выполняются, вместо попытки гибкости возникает исключение.</target>
        </trans-unit>
        <trans-unit id="6e978531d306139571810dad3cc0f8a44d943b22" translate="yes" xml:space="preserve">
          <source>Output argument. This must have the exact kind that would be returned if it was not used. In particular, it must have the right type, must be C-contiguous, and its dtype must be the dtype that would be returned for &lt;code&gt;ma.dot(a,b)&lt;/code&gt;. This is a performance feature. Therefore, if these conditions are not met, an exception is raised, instead of attempting to be flexible.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a83f71ed49812b1c51736e820cd87f0f9865fcb1" translate="yes" xml:space="preserve">
          <source>Output arguments to ufuncs can be tuples also for ufunc methods</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="85f12acadc64d21e2feac22d1a1b4692fb105ee3" translate="yes" xml:space="preserve">
          <source>Output array</source>
          <target state="translated">Выходной массив</target>
        </trans-unit>
        <trans-unit id="f89327ce1837e2c79277b79c5f26d1462b21d4b0" translate="yes" xml:space="preserve">
          <source>Output array for the exponent. Must have the same shape as &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">Выходной массив для экспоненты. Должен иметь ту же форму, что и &lt;code&gt;x&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ce4222d68677642db5d8cd581c2069a152c5cd0e" translate="yes" xml:space="preserve">
          <source>Output array for the mantissa. Must have the same shape as &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">Выходной массив для мантиссы. Должен иметь ту же форму, что и &lt;code&gt;x&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d1138d70b1d22742de8a7eec1ca180e5192ab003" translate="yes" xml:space="preserve">
          <source>Output array is same shape and type as &lt;code&gt;x&lt;/code&gt;. This is a scalar if &lt;code&gt;x&lt;/code&gt; is a scalar.</source>
          <target state="translated">Выходной массив имеет ту же форму и тип, что и &lt;code&gt;x&lt;/code&gt; . Это скаляр, если &lt;code&gt;x&lt;/code&gt; - скаляр.</target>
        </trans-unit>
        <trans-unit id="2e976c3ac1b3c4a193e0ef93cc1e51ab4229d440" translate="yes" xml:space="preserve">
          <source>Output array of &lt;a href=&quot;../arrays.scalars#numpy.string_&quot;&gt;&lt;code&gt;string_&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../arrays.scalars#numpy.unicode_&quot;&gt;&lt;code&gt;unicode_&lt;/code&gt;&lt;/a&gt;, depending on input types of the same shape as &lt;code&gt;x1&lt;/code&gt; and &lt;code&gt;x2&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9ef051a2e330bee8268ab4c049205eb02d245cc1" translate="yes" xml:space="preserve">
          <source>Output array of &lt;code&gt;string_&lt;/code&gt; or &lt;code&gt;unicode_&lt;/code&gt;, depending on input types of the same shape as &lt;code&gt;x1&lt;/code&gt; and &lt;code&gt;x2&lt;/code&gt;.</source>
          <target state="translated">Выходной массив &lt;code&gt;string_&lt;/code&gt; или &lt;code&gt;unicode_&lt;/code&gt; , в зависимости от типов ввода той же формы, что и &lt;code&gt;x1&lt;/code&gt; и &lt;code&gt;x2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5cd088a12712ab8d4c2c426261156c01f4ed1606" translate="yes" xml:space="preserve">
          <source>Output array of bools</source>
          <target state="translated">Выходной массив шпилек</target>
        </trans-unit>
        <trans-unit id="32b7b13439f3e6221fd4780b32449d5d4d7f2b86" translate="yes" xml:space="preserve">
          <source>Output array of bools, or a single bool if x1 and x2 are scalars.</source>
          <target state="translated">Выводите массив пулов или один пул,если x1 и x2-скаляры.</target>
        </trans-unit>
        <trans-unit id="242b7670831be50eb14727f2ee1d42762f40625b" translate="yes" xml:space="preserve">
          <source>Output array of bools.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="59628506899dd565c36cb8637802ca8d03d5a7e8" translate="yes" xml:space="preserve">
          <source>Output array of indices, of same shape as &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">Выходной массив индексов той же формы, что и &lt;code&gt;x&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5ee5c2cea50e4665a7ae56f4b3614a03fe2437d2" translate="yes" xml:space="preserve">
          <source>Output array of integers</source>
          <target state="translated">Выходной массив целых чисел</target>
        </trans-unit>
        <trans-unit id="7e2593695a5d88e14bbbac4809c3409ae05309b7" translate="yes" xml:space="preserve">
          <source>Output array of ints.</source>
          <target state="translated">Выходной массив из инъекций.</target>
        </trans-unit>
        <trans-unit id="52a772b58c524d2ad00244b1064922aec6a445c6" translate="yes" xml:space="preserve">
          <source>Output array of ints. Return -1 on failure.</source>
          <target state="translated">Выходной массив из инъекций.Возврат -1 при отказе.</target>
        </trans-unit>
        <trans-unit id="a30063ccd5b6202d238ce61d0b6db2952ded8310" translate="yes" xml:space="preserve">
          <source>Output array of ints. Returns -1 if &lt;code&gt;sub&lt;/code&gt; is not found.</source>
          <target state="translated">Выходной массив целых чисел. Возвращает -1, если &lt;code&gt;sub&lt;/code&gt; не найдена.</target>
        </trans-unit>
        <trans-unit id="9735bcc93d569bce2b6e7befd7418f0ba4b716c9" translate="yes" xml:space="preserve">
          <source>Output array of same shape as &lt;code&gt;x&lt;/code&gt;. This is a scalar if &lt;code&gt;x&lt;/code&gt; is a scalar.</source>
          <target state="translated">Выходной массив той же формы, что и &lt;code&gt;x&lt;/code&gt; . Это скаляр, если &lt;code&gt;x&lt;/code&gt; - скаляр.</target>
        </trans-unit>
        <trans-unit id="a38bebcd0d7b96b1c608bbee88ef6bc304e314b0" translate="yes" xml:space="preserve">
          <source>Output array of str or unicode, depending on input type</source>
          <target state="translated">Выходной массив строк или юникод,в зависимости от типа входа</target>
        </trans-unit>
        <trans-unit id="58c2378e8c8946ae97f1ea7dac73a13c10abcd50" translate="yes" xml:space="preserve">
          <source>Output array of str or unicode, depending on input type. The output array will have an extra dimension with 3 elements per input element.</source>
          <target state="translated">Выходной массив строк или юникод,в зависимости от типа входа.Выходной массив будет иметь дополнительное измерение с 3 элементами на каждый входной элемент.</target>
        </trans-unit>
        <trans-unit id="64d5dcb1c0c304c381fa58f443d7ded824e0bc47" translate="yes" xml:space="preserve">
          <source>Output array of str or unicode, depending on input types</source>
          <target state="translated">Выходной массив строк или юникод,в зависимости от типов входных данных</target>
        </trans-unit>
        <trans-unit id="fd13d84379a70df2e078233919d2189882423201" translate="yes" xml:space="preserve">
          <source>Output array of string or unicode, depending on input type. The output array will have an extra dimension with 3 elements per input element.</source>
          <target state="translated">Выводить массив строк или юникод,в зависимости от типа входного сигнала.Выходной массив будет иметь дополнительное измерение с 3 элементами на каждый входной элемент.</target>
        </trans-unit>
        <trans-unit id="f7c9fa3972ed6e6a39e0733beb489d1ce3ad7791" translate="yes" xml:space="preserve">
          <source>Output array which has the same shape as &lt;code&gt;a&lt;/code&gt;, except along the given axis.</source>
          <target state="translated">Выходной массив, имеющий ту же форму, что и &lt;code&gt;a&lt;/code&gt; , за исключением заданной оси.</target>
        </trans-unit>
        <trans-unit id="b3c1a1cbd46397d96a8e1319b9f70d2c4e83a943" translate="yes" xml:space="preserve">
          <source>Output array, containing the indices of the elements of &lt;code&gt;a.ravel()&lt;/code&gt; that are non-zero.</source>
          <target state="translated">Выходной массив, содержащий &lt;code&gt;a.ravel()&lt;/code&gt; индексы элементов a.ravel () .</target>
        </trans-unit>
        <trans-unit id="307c943561bf0b8b5ee1a6f51fb083d57904faed" translate="yes" xml:space="preserve">
          <source>Output array, element-wise comparison of &lt;code&gt;x1&lt;/code&gt; and &lt;code&gt;x2&lt;/code&gt;. Typically of type bool, unless &lt;code&gt;dtype=object&lt;/code&gt; is passed. This is a scalar if both &lt;code&gt;x1&lt;/code&gt; and &lt;code&gt;x2&lt;/code&gt; are scalars.</source>
          <target state="translated">Выходной массив, поэлементное сравнение &lt;code&gt;x1&lt;/code&gt; и &lt;code&gt;x2&lt;/code&gt; . Обычно имеет тип bool, если не &lt;code&gt;dtype=object&lt;/code&gt; . Это скаляр, если и &lt;code&gt;x1&lt;/code&gt; , и &lt;code&gt;x2&lt;/code&gt; являются скалярами.</target>
        </trans-unit>
        <trans-unit id="2e21fc9917d319d6359f007add3068ca89130f62" translate="yes" xml:space="preserve">
          <source>Output array, element-wise exponential of &lt;code&gt;x&lt;/code&gt;. This is a scalar if &lt;code&gt;x&lt;/code&gt; is a scalar.</source>
          <target state="translated">Выходной массив, поэлементная экспонента &lt;code&gt;x&lt;/code&gt; . Это скаляр, если &lt;code&gt;x&lt;/code&gt; - скаляр.</target>
        </trans-unit>
        <trans-unit id="16e86016f9dd58438b33f8fa3832e0a84ce8bad6" translate="yes" xml:space="preserve">
          <source>Output array, or reference to &lt;code&gt;out&lt;/code&gt; if that was supplied. This is a scalar if &lt;code&gt;x&lt;/code&gt; is a scalar.</source>
          <target state="translated">Выходной массив или ссылка на &lt;code&gt;out&lt;/code&gt; если она была предоставлена. Это скаляр, если &lt;code&gt;x&lt;/code&gt; - скаляр.</target>
        </trans-unit>
        <trans-unit id="1c4ffa82eda162fa8929d170e0a0f647fbc47d46" translate="yes" xml:space="preserve">
          <source>Output array, with the same shape as &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">Выходной массив той же формы, что &lt;code&gt;a&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6c7fe807ab5dc7a002fea6ec306d2d20dd6cd310" translate="yes" xml:space="preserve">
          <source>Output array.</source>
          <target state="translated">Выходной массив.</target>
        </trans-unit>
        <trans-unit id="bfcf0a026c1c1c3df16d07e5c463c5d22ef8d769" translate="yes" xml:space="preserve">
          <source>Output array. Its type is preserved and it must be of the right shape to hold the output.</source>
          <target state="translated">Выходной массив.Его тип сохраняется,и он должен иметь правильную форму,чтобы удерживать выходной массив.</target>
        </trans-unit>
        <trans-unit id="21470ea6838153d93bb789847f1e781e9233d56c" translate="yes" xml:space="preserve">
          <source>Output formatting</source>
          <target state="translated">Выходное форматирование</target>
        </trans-unit>
        <trans-unit id="ebe7bf947438344dfee2f421c7f0822ca9d92fa3" translate="yes" xml:space="preserve">
          <source>Output shape. If the given shape is, e.g., &lt;code&gt;(m, n)&lt;/code&gt;, then &lt;code&gt;m * n * k&lt;/code&gt; samples are drawn. Default is None, in which case a vector of length &lt;code&gt;k&lt;/code&gt; is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a267ec8ecd4cabb56c1672c1c1515df13c271b4b" translate="yes" xml:space="preserve">
          <source>Output shape. If the given shape is, e.g., &lt;code&gt;(m, n, k)&lt;/code&gt;, then &lt;code&gt;m * n * k&lt;/code&gt; samples are drawn from the 1-d &lt;code&gt;a&lt;/code&gt;. If &lt;code&gt;a&lt;/code&gt; has more than one dimension, the &lt;code&gt;size&lt;/code&gt; shape will be inserted into the &lt;code&gt;axis&lt;/code&gt; dimension, so the output &lt;code&gt;ndim&lt;/code&gt; will be &lt;code&gt;a.ndim - 1 +
len(size)&lt;/code&gt;. Default is None, in which case a single value is returned.</source>
          <target state="translated">Форма вывода. Если заданная форма, например, &lt;code&gt;(m, n, k)&lt;/code&gt; , то &lt;code&gt;m * n * k&lt;/code&gt; выборок отбираются из 1-d &lt;code&gt;a&lt;/code&gt; . Если &lt;code&gt;a&lt;/code&gt; имеет более одного измерения, форма &lt;code&gt;size&lt;/code&gt; будет вставлена ​​в размер &lt;code&gt;axis&lt;/code&gt; , поэтому выходной &lt;code&gt;ndim&lt;/code&gt; будет иметь вид &lt;code&gt;a.ndim - 1 + len(size)&lt;/code&gt; . По умолчанию None, и в этом случае возвращается одно значение.</target>
        </trans-unit>
        <trans-unit id="d2424a491af135ae36f950b7ab0516bd18ace8df" translate="yes" xml:space="preserve">
          <source>Output shape. If the given shape is, e.g., &lt;code&gt;(m, n, k)&lt;/code&gt;, then &lt;code&gt;m * n * k&lt;/code&gt; samples are drawn. Default is None, in which case a single value is returned.</source>
          <target state="translated">Форма вывода. Если заданная форма, например, &lt;code&gt;(m, n, k)&lt;/code&gt; , то отрисовывается &lt;code&gt;m * n * k&lt;/code&gt; выборок. По умолчанию None, и в этом случае возвращается одно значение.</target>
        </trans-unit>
        <trans-unit id="89e56aa13faf2ac19ffb0b3e5e716f7bfddc1ab9" translate="yes" xml:space="preserve">
          <source>Output shape. If the given shape is, e.g., &lt;code&gt;(m, n, k)&lt;/code&gt;, then &lt;code&gt;m * n * k&lt;/code&gt; samples are drawn. If size is &lt;code&gt;None&lt;/code&gt; (default), a single value is returned if &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; are both scalars. Otherwise, &lt;code&gt;np.broadcast(a, b).size&lt;/code&gt; samples are drawn.</source>
          <target state="translated">Форма вывода. Если заданная форма, например, &lt;code&gt;(m, n, k)&lt;/code&gt; , то отрисовывается &lt;code&gt;m * n * k&lt;/code&gt; выборок. Если размер равен &lt;code&gt;None&lt;/code&gt; (по умолчанию), возвращается одно значение, если &lt;code&gt;a&lt;/code&gt; и &lt;code&gt;b&lt;/code&gt; оба являются скалярами. В противном случае &lt;code&gt;np.broadcast(a, b).size&lt;/code&gt; образцы np.broadcast (a, b) .size .</target>
        </trans-unit>
        <trans-unit id="55b478ddcb62162e8ce07219dee1d9d6ca7a8be6" translate="yes" xml:space="preserve">
          <source>Output shape. If the given shape is, e.g., &lt;code&gt;(m, n, k)&lt;/code&gt;, then &lt;code&gt;m * n * k&lt;/code&gt; samples are drawn. If size is &lt;code&gt;None&lt;/code&gt; (default), a single value is returned if &lt;code&gt;a&lt;/code&gt; is a scalar. Otherwise, &lt;code&gt;np.array(a).size&lt;/code&gt; samples are drawn.</source>
          <target state="translated">Форма вывода. Если заданная форма, например, &lt;code&gt;(m, n, k)&lt;/code&gt; , то отрисовывается &lt;code&gt;m * n * k&lt;/code&gt; выборок. Если размер равен &lt;code&gt;None&lt;/code&gt; (по умолчанию), возвращается одно значение, если &lt;code&gt;a&lt;/code&gt; - скаляр. В противном случае &lt;code&gt;np.array(a).size&lt;/code&gt; образцы np.array (a) .size .</target>
        </trans-unit>
        <trans-unit id="bad13c9c05fba2155bd76b001de567b59798e200" translate="yes" xml:space="preserve">
          <source>Output shape. If the given shape is, e.g., &lt;code&gt;(m, n, k)&lt;/code&gt;, then &lt;code&gt;m * n * k&lt;/code&gt; samples are drawn. If size is &lt;code&gt;None&lt;/code&gt; (default), a single value is returned if &lt;code&gt;df&lt;/code&gt; and &lt;code&gt;nonc&lt;/code&gt; are both scalars. Otherwise, &lt;code&gt;np.broadcast(df, nonc).size&lt;/code&gt; samples are drawn.</source>
          <target state="translated">Форма вывода. Если заданная форма, например, &lt;code&gt;(m, n, k)&lt;/code&gt; , то отрисовывается &lt;code&gt;m * n * k&lt;/code&gt; выборок. Если размер равен &lt;code&gt;None&lt;/code&gt; (по умолчанию), возвращается одно значение, если &lt;code&gt;df&lt;/code&gt; и &lt;code&gt;nonc&lt;/code&gt; являются скалярами. В противном случае &lt;code&gt;np.broadcast(df, nonc).size&lt;/code&gt; образцы np.broadcast (df, nonc) .size .</target>
        </trans-unit>
        <trans-unit id="738b6886d61591bdc17ae069de249790d6b71087" translate="yes" xml:space="preserve">
          <source>Output shape. If the given shape is, e.g., &lt;code&gt;(m, n, k)&lt;/code&gt;, then &lt;code&gt;m * n * k&lt;/code&gt; samples are drawn. If size is &lt;code&gt;None&lt;/code&gt; (default), a single value is returned if &lt;code&gt;df&lt;/code&gt; is a scalar. Otherwise, &lt;code&gt;np.array(df).size&lt;/code&gt; samples are drawn.</source>
          <target state="translated">Форма вывода. Если заданная форма, например, &lt;code&gt;(m, n, k)&lt;/code&gt; , то отрисовывается &lt;code&gt;m * n * k&lt;/code&gt; выборок. Если размер равен &lt;code&gt;None&lt;/code&gt; (по умолчанию), возвращается одно значение, если &lt;code&gt;df&lt;/code&gt; является скаляром. В противном случае &lt;code&gt;np.array(df).size&lt;/code&gt; образцы np.array (df) .size .</target>
        </trans-unit>
        <trans-unit id="ae475a1d95fefab6fd2f2bedb6223f991fcc41b6" translate="yes" xml:space="preserve">
          <source>Output shape. If the given shape is, e.g., &lt;code&gt;(m, n, k)&lt;/code&gt;, then &lt;code&gt;m * n * k&lt;/code&gt; samples are drawn. If size is &lt;code&gt;None&lt;/code&gt; (default), a single value is returned if &lt;code&gt;dfnum&lt;/code&gt; and &lt;code&gt;dfden&lt;/code&gt; are both scalars. Otherwise, &lt;code&gt;np.broadcast(dfnum, dfden).size&lt;/code&gt; samples are drawn.</source>
          <target state="translated">Форма вывода. Если заданная форма, например, &lt;code&gt;(m, n, k)&lt;/code&gt; , то отрисовывается &lt;code&gt;m * n * k&lt;/code&gt; выборок. Если размер равен &lt;code&gt;None&lt;/code&gt; (по умолчанию), возвращается одно значение, если &lt;code&gt;dfnum&lt;/code&gt; и &lt;code&gt;dfden&lt;/code&gt; являются скалярами. В противном случае &lt;code&gt;np.broadcast(dfnum, dfden).size&lt;/code&gt; образцы np.broadcast (dfnum, dfden) .size .</target>
        </trans-unit>
        <trans-unit id="46a9903f305b04fd0f7d5079b4658c01625926e1" translate="yes" xml:space="preserve">
          <source>Output shape. If the given shape is, e.g., &lt;code&gt;(m, n, k)&lt;/code&gt;, then &lt;code&gt;m * n * k&lt;/code&gt; samples are drawn. If size is &lt;code&gt;None&lt;/code&gt; (default), a single value is returned if &lt;code&gt;dfnum&lt;/code&gt;, &lt;code&gt;dfden&lt;/code&gt;, and &lt;code&gt;nonc&lt;/code&gt; are all scalars. Otherwise, &lt;code&gt;np.broadcast(dfnum, dfden, nonc).size&lt;/code&gt; samples are drawn.</source>
          <target state="translated">Форма вывода. Если заданная форма, например, &lt;code&gt;(m, n, k)&lt;/code&gt; , то отрисовывается &lt;code&gt;m * n * k&lt;/code&gt; выборок. Если размер равен &lt;code&gt;None&lt;/code&gt; (по умолчанию), возвращается одно значение, если &lt;code&gt;dfnum&lt;/code&gt; , &lt;code&gt;dfden&lt;/code&gt; и &lt;code&gt;nonc&lt;/code&gt; являются скалярами. В противном случае &lt;code&gt;np.broadcast(dfnum, dfden, nonc).size&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cf9a357ee338f25bf2bcb1c6a39d7e36ff751b6d" translate="yes" xml:space="preserve">
          <source>Output shape. If the given shape is, e.g., &lt;code&gt;(m, n, k)&lt;/code&gt;, then &lt;code&gt;m * n * k&lt;/code&gt; samples are drawn. If size is &lt;code&gt;None&lt;/code&gt; (default), a single value is returned if &lt;code&gt;lam&lt;/code&gt; is a scalar. Otherwise, &lt;code&gt;np.array(lam).size&lt;/code&gt; samples are drawn.</source>
          <target state="translated">Форма вывода. Если заданная форма, например, &lt;code&gt;(m, n, k)&lt;/code&gt; , то отрисовывается &lt;code&gt;m * n * k&lt;/code&gt; выборок. Если размер равен &lt;code&gt;None&lt;/code&gt; (по умолчанию), возвращается одно значение, если &lt;code&gt;lam&lt;/code&gt; является скаляром. В противном случае &lt;code&gt;np.array(lam).size&lt;/code&gt; образцы np.array (lam) .size .</target>
        </trans-unit>
        <trans-unit id="6bfc36fdff77cbd952a127d76db752bf9585b331" translate="yes" xml:space="preserve">
          <source>Output shape. If the given shape is, e.g., &lt;code&gt;(m, n, k)&lt;/code&gt;, then &lt;code&gt;m * n * k&lt;/code&gt; samples are drawn. If size is &lt;code&gt;None&lt;/code&gt; (default), a single value is returned if &lt;code&gt;left&lt;/code&gt;, &lt;code&gt;mode&lt;/code&gt;, and &lt;code&gt;right&lt;/code&gt; are all scalars. Otherwise, &lt;code&gt;np.broadcast(left, mode, right).size&lt;/code&gt; samples are drawn.</source>
          <target state="translated">Форма вывода. Если заданная форма, например, &lt;code&gt;(m, n, k)&lt;/code&gt; , то отрисовывается &lt;code&gt;m * n * k&lt;/code&gt; выборок. Если размер равен &lt;code&gt;None&lt;/code&gt; (по умолчанию), возвращается одно значение, если &lt;code&gt;left&lt;/code&gt; , &lt;code&gt;mode&lt;/code&gt; и &lt;code&gt;right&lt;/code&gt; являются скалярами. В противном случае &lt;code&gt;np.broadcast(left, mode, right).size&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="221f43b3f6b78ea4ffc570a2b4686a11e53b9689" translate="yes" xml:space="preserve">
          <source>Output shape. If the given shape is, e.g., &lt;code&gt;(m, n, k)&lt;/code&gt;, then &lt;code&gt;m * n * k&lt;/code&gt; samples are drawn. If size is &lt;code&gt;None&lt;/code&gt; (default), a single value is returned if &lt;code&gt;loc&lt;/code&gt; and &lt;code&gt;scale&lt;/code&gt; are both scalars. Otherwise, &lt;code&gt;np.broadcast(loc, scale).size&lt;/code&gt; samples are drawn.</source>
          <target state="translated">Форма вывода. Если заданная форма, например, &lt;code&gt;(m, n, k)&lt;/code&gt; , то отрисовывается &lt;code&gt;m * n * k&lt;/code&gt; выборок. Если size равно &lt;code&gt;None&lt;/code&gt; (по умолчанию), возвращается одно значение, если &lt;code&gt;loc&lt;/code&gt; и &lt;code&gt;scale&lt;/code&gt; являются скалярами. В противном случае &lt;code&gt;np.broadcast(loc, scale).size&lt;/code&gt; образцы np.broadcast (loc, scale) .size .</target>
        </trans-unit>
        <trans-unit id="4282c4067b87ca3f0f86b5fc7e0e58c780e280c3" translate="yes" xml:space="preserve">
          <source>Output shape. If the given shape is, e.g., &lt;code&gt;(m, n, k)&lt;/code&gt;, then &lt;code&gt;m * n * k&lt;/code&gt; samples are drawn. If size is &lt;code&gt;None&lt;/code&gt; (default), a single value is returned if &lt;code&gt;low&lt;/code&gt; and &lt;code&gt;high&lt;/code&gt; are both scalars. Otherwise, &lt;code&gt;np.broadcast(low, high).size&lt;/code&gt; samples are drawn.</source>
          <target state="translated">Форма вывода. Если заданная форма, например, &lt;code&gt;(m, n, k)&lt;/code&gt; , то отрисовывается &lt;code&gt;m * n * k&lt;/code&gt; выборок. Если размер равен &lt;code&gt;None&lt;/code&gt; (по умолчанию), возвращается одно значение, если оба значения &lt;code&gt;low&lt;/code&gt; и &lt;code&gt;high&lt;/code&gt; являются скалярами. В противном случае &lt;code&gt;np.broadcast(low, high).size&lt;/code&gt; образцы np.broadcast (low, high) .size .</target>
        </trans-unit>
        <trans-unit id="d0683da40c0442ae9f7198c7d720ea85a5de1b4d" translate="yes" xml:space="preserve">
          <source>Output shape. If the given shape is, e.g., &lt;code&gt;(m, n, k)&lt;/code&gt;, then &lt;code&gt;m * n * k&lt;/code&gt; samples are drawn. If size is &lt;code&gt;None&lt;/code&gt; (default), a single value is returned if &lt;code&gt;mean&lt;/code&gt; and &lt;code&gt;scale&lt;/code&gt; are both scalars. Otherwise, &lt;code&gt;np.broadcast(mean, scale).size&lt;/code&gt; samples are drawn.</source>
          <target state="translated">Форма вывода. Если заданная форма, например, &lt;code&gt;(m, n, k)&lt;/code&gt; , то отрисовывается &lt;code&gt;m * n * k&lt;/code&gt; выборок. Если размер равен &lt;code&gt;None&lt;/code&gt; (по умолчанию), возвращается одно значение, если &lt;code&gt;mean&lt;/code&gt; и &lt;code&gt;scale&lt;/code&gt; являются скалярами. В противном случае &lt;code&gt;np.broadcast(mean, scale).size&lt;/code&gt; образцы np.broadcast (mean, scale) .size .</target>
        </trans-unit>
        <trans-unit id="0de49618d9158d1b17813c0b098c763f862b1d88" translate="yes" xml:space="preserve">
          <source>Output shape. If the given shape is, e.g., &lt;code&gt;(m, n, k)&lt;/code&gt;, then &lt;code&gt;m * n * k&lt;/code&gt; samples are drawn. If size is &lt;code&gt;None&lt;/code&gt; (default), a single value is returned if &lt;code&gt;mean&lt;/code&gt; and &lt;code&gt;sigma&lt;/code&gt; are both scalars. Otherwise, &lt;code&gt;np.broadcast(mean, sigma).size&lt;/code&gt; samples are drawn.</source>
          <target state="translated">Форма вывода. Если заданная форма, например, &lt;code&gt;(m, n, k)&lt;/code&gt; , то отрисовывается &lt;code&gt;m * n * k&lt;/code&gt; выборок. Если размер равен &lt;code&gt;None&lt;/code&gt; (по умолчанию), возвращается одно значение, если &lt;code&gt;mean&lt;/code&gt; и &lt;code&gt;sigma&lt;/code&gt; являются скалярами. В противном случае &lt;code&gt;np.broadcast(mean, sigma).size&lt;/code&gt; образцы np.broadcast (mean, sigma) .size .</target>
        </trans-unit>
        <trans-unit id="4e92a7af3b2b74719c734b754039059712af838b" translate="yes" xml:space="preserve">
          <source>Output shape. If the given shape is, e.g., &lt;code&gt;(m, n, k)&lt;/code&gt;, then &lt;code&gt;m * n * k&lt;/code&gt; samples are drawn. If size is &lt;code&gt;None&lt;/code&gt; (default), a single value is returned if &lt;code&gt;mu&lt;/code&gt; and &lt;code&gt;kappa&lt;/code&gt; are both scalars. Otherwise, &lt;code&gt;np.broadcast(mu, kappa).size&lt;/code&gt; samples are drawn.</source>
          <target state="translated">Форма вывода. Если заданная форма, например, &lt;code&gt;(m, n, k)&lt;/code&gt; , то отрисовывается &lt;code&gt;m * n * k&lt;/code&gt; выборок. Если размер равен &lt;code&gt;None&lt;/code&gt; (по умолчанию), возвращается одно значение, если &lt;code&gt;mu&lt;/code&gt; и &lt;code&gt;kappa&lt;/code&gt; являются скалярами. В противном случае &lt;code&gt;np.broadcast(mu, kappa).size&lt;/code&gt; образцы np.broadcast (mu, kappa) .size .</target>
        </trans-unit>
        <trans-unit id="508329c1fbd22ad6be84a6836708268204490867" translate="yes" xml:space="preserve">
          <source>Output shape. If the given shape is, e.g., &lt;code&gt;(m, n, k)&lt;/code&gt;, then &lt;code&gt;m * n * k&lt;/code&gt; samples are drawn. If size is &lt;code&gt;None&lt;/code&gt; (default), a single value is returned if &lt;code&gt;n&lt;/code&gt; and &lt;code&gt;p&lt;/code&gt; are both scalars. Otherwise, &lt;code&gt;np.broadcast(n, p).size&lt;/code&gt; samples are drawn.</source>
          <target state="translated">Форма вывода. Если заданная форма, например, &lt;code&gt;(m, n, k)&lt;/code&gt; , то отрисовывается &lt;code&gt;m * n * k&lt;/code&gt; выборок. Если размер равен &lt;code&gt;None&lt;/code&gt; (по умолчанию), возвращается одно значение, если &lt;code&gt;n&lt;/code&gt; и &lt;code&gt;p&lt;/code&gt; являются скалярами. В противном случае &lt;code&gt;np.broadcast(n, p).size&lt;/code&gt; образцы np.broadcast (n, p) .size .</target>
        </trans-unit>
        <trans-unit id="b122820c89df713b07cfbc58626294123f0af0a3" translate="yes" xml:space="preserve">
          <source>Output shape. If the given shape is, e.g., &lt;code&gt;(m, n, k)&lt;/code&gt;, then &lt;code&gt;m * n * k&lt;/code&gt; samples are drawn. If size is &lt;code&gt;None&lt;/code&gt; (default), a single value is returned if &lt;code&gt;ngood&lt;/code&gt;, &lt;code&gt;nbad&lt;/code&gt;, and &lt;code&gt;nsample&lt;/code&gt; are all scalars. Otherwise, &lt;code&gt;np.broadcast(ngood, nbad, nsample).size&lt;/code&gt; samples are drawn.</source>
          <target state="translated">Форма вывода. Если заданная форма, например, &lt;code&gt;(m, n, k)&lt;/code&gt; , то отрисовывается &lt;code&gt;m * n * k&lt;/code&gt; выборок. Если размер не является &lt;code&gt;None&lt;/code&gt; ( по умолчанию), одно значение возвращается , если &lt;code&gt;ngood&lt;/code&gt; , &lt;code&gt;nbad&lt;/code&gt; и &lt;code&gt;nsample&lt;/code&gt; все скаляры. В противном случае &lt;code&gt;np.broadcast(ngood, nbad, nsample).size&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="27d2ec43f10ca379398aac021ba6a41147bbbdc4" translate="yes" xml:space="preserve">
          <source>Output shape. If the given shape is, e.g., &lt;code&gt;(m, n, k)&lt;/code&gt;, then &lt;code&gt;m * n * k&lt;/code&gt; samples are drawn. If size is &lt;code&gt;None&lt;/code&gt; (default), a single value is returned if &lt;code&gt;p&lt;/code&gt; is a scalar. Otherwise, &lt;code&gt;np.array(p).size&lt;/code&gt; samples are drawn.</source>
          <target state="translated">Форма вывода. Если заданная форма, например, &lt;code&gt;(m, n, k)&lt;/code&gt; , то отрисовывается &lt;code&gt;m * n * k&lt;/code&gt; выборок. Если размер равен &lt;code&gt;None&lt;/code&gt; (по умолчанию), возвращается одно значение, если &lt;code&gt;p&lt;/code&gt; - скаляр. В противном случае &lt;code&gt;np.array(p).size&lt;/code&gt; образцы np.array (p) .size .</target>
        </trans-unit>
        <trans-unit id="df56295e78bed4d72315ff68acac7d0f9dadfb30" translate="yes" xml:space="preserve">
          <source>Output shape. If the given shape is, e.g., &lt;code&gt;(m, n, k)&lt;/code&gt;, then &lt;code&gt;m * n * k&lt;/code&gt; samples are drawn. If size is &lt;code&gt;None&lt;/code&gt; (default), a single value is returned if &lt;code&gt;scale&lt;/code&gt; is a scalar. Otherwise, &lt;code&gt;np.array(scale).size&lt;/code&gt; samples are drawn.</source>
          <target state="translated">Форма вывода. Если заданная форма, например, &lt;code&gt;(m, n, k)&lt;/code&gt; , то отрисовывается &lt;code&gt;m * n * k&lt;/code&gt; выборок. Если размер равен &lt;code&gt;None&lt;/code&gt; (по умолчанию), возвращается одно значение, если &lt;code&gt;scale&lt;/code&gt; является скаляром. В противном случае &lt;code&gt;np.array(scale).size&lt;/code&gt; образцы np.array (scale) .size .</target>
        </trans-unit>
        <trans-unit id="948b72efe91fbed7c1a9b81472148fc726a10ddb" translate="yes" xml:space="preserve">
          <source>Output shape. If the given shape is, e.g., &lt;code&gt;(m, n, k)&lt;/code&gt;, then &lt;code&gt;m * n * k&lt;/code&gt; samples are drawn. If size is &lt;code&gt;None&lt;/code&gt; (default), a single value is returned if &lt;code&gt;shape&lt;/code&gt; and &lt;code&gt;scale&lt;/code&gt; are both scalars. Otherwise, &lt;code&gt;np.broadcast(shape, scale).size&lt;/code&gt; samples are drawn.</source>
          <target state="translated">Форма вывода. Если заданная форма, например, &lt;code&gt;(m, n, k)&lt;/code&gt; , то отрисовывается &lt;code&gt;m * n * k&lt;/code&gt; выборок. Если размер равен &lt;code&gt;None&lt;/code&gt; (по умолчанию), возвращается одно значение, если &lt;code&gt;shape&lt;/code&gt; и &lt;code&gt;scale&lt;/code&gt; являются скалярами. В противном случае &lt;code&gt;np.broadcast(shape, scale).size&lt;/code&gt; образцы np.broadcast (shape, scale) .size .</target>
        </trans-unit>
        <trans-unit id="eb5df5a3ebce059571acee730f004ee96866a67f" translate="yes" xml:space="preserve">
          <source>Output shape. If the given shape is, e.g., &lt;code&gt;(m, n, k)&lt;/code&gt;, then &lt;code&gt;m * n * k&lt;/code&gt; samples are drawn. If size is &lt;code&gt;None&lt;/code&gt; (default), a single value is returned if &lt;code&gt;shape&lt;/code&gt; is a scalar. Otherwise, &lt;code&gt;np.array(shape).size&lt;/code&gt; samples are drawn.</source>
          <target state="translated">Форма вывода. Если заданная форма, например, &lt;code&gt;(m, n, k)&lt;/code&gt; , то отрисовывается &lt;code&gt;m * n * k&lt;/code&gt; выборок. Если размер равен &lt;code&gt;None&lt;/code&gt; (по умолчанию), возвращается одно значение, если &lt;code&gt;shape&lt;/code&gt; является скаляром. В противном случае &lt;code&gt;np.array(shape).size&lt;/code&gt; образцы np.array (shape) .size .</target>
        </trans-unit>
        <trans-unit id="93434be0fa874141cd4c8b5151bed934649c82c6" translate="yes" xml:space="preserve">
          <source>Output to existing array instead of creating new one, must have same shape as expected output</source>
          <target state="translated">Вывод в существующий массив вместо создания нового должен иметь ту же форму,что и ожидаемый вывод.</target>
        </trans-unit>
        <trans-unit id="84eedc132f8f3afc97e2735311f70af181b638d1" translate="yes" xml:space="preserve">
          <source>Output type determination</source>
          <target state="translated">Определение типа выхода</target>
        </trans-unit>
        <trans-unit id="25c6817215cc63aae8850c0698a2094523318f20" translate="yes" xml:space="preserve">
          <source>Output values. Used for performance testing since the generated values are not returned.</source>
          <target state="translated">Выходные значения.Используется для тестирования производительности,так как сгенерированные значения не возвращаются.</target>
        </trans-unit>
        <trans-unit id="645e7318aeb0e81470723bb7fa3e333eeb197cd2" translate="yes" xml:space="preserve">
          <source>Output view is of shape &lt;code&gt;(self.size,)&lt;/code&gt; (or &lt;code&gt;(np.ma.product(self.shape),)&lt;/code&gt;).</source>
          <target state="translated">Выходное представление имеет форму &lt;code&gt;(self.size,)&lt;/code&gt; (или &lt;code&gt;(np.ma.product(self.shape),)&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="75eaf4cf3feb6b5ab1173e2bce737a946dc189fe" translate="yes" xml:space="preserve">
          <source>Outputs an array of bools.</source>
          <target state="translated">Выводит массив шпилек.</target>
        </trans-unit>
        <trans-unit id="0ba159acbd720278d8203620bd6051e07665bfbd" translate="yes" xml:space="preserve">
          <source>Outside the context the error handling behavior has not changed:</source>
          <target state="translated">Вне контекста поведение при обработке ошибок не изменилось:</target>
        </trans-unit>
        <trans-unit id="8a528519bdaba69c0bdc57fdcdf7b370f2e098f2" translate="yes" xml:space="preserve">
          <source>Overall</source>
          <target state="translated">Overall</target>
        </trans-unit>
        <trans-unit id="3b4b69a29c016e758ecb737d47f6f3d84f5ea925" translate="yes" xml:space="preserve">
          <source>Overall view of discrete Fourier transforms, with definitions and conventions used.</source>
          <target state="translated">Общий вид дискретных преобразований Фурье,с использованием определений и конвенций.</target>
        </trans-unit>
        <trans-unit id="bd6510575c0d6b439267f2e4a3758c5ec63354f0" translate="yes" xml:space="preserve">
          <source>Overflow Errors</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e247da042a068cd8a71502e0fd76c6b94f4ca5d" translate="yes" xml:space="preserve">
          <source>Overflow: result too large to be expressed.</source>
          <target state="translated">Переполнение:результат слишком большой,чтобы его можно было выразить.</target>
        </trans-unit>
        <trans-unit id="2efc34a90711b7a3d99847c32b113347fb82c866" translate="yes" xml:space="preserve">
          <source>Override the default nditer flags for the ufunc.</source>
          <target state="translated">Отмените флаги nditer по умолчанию для ufunc.</target>
        </trans-unit>
        <trans-unit id="75e6a3ee5dadc59620ad485d88ddab650173edc7" translate="yes" xml:space="preserve">
          <source>Override the default operand flags for each ufunc operand.</source>
          <target state="translated">Отменить флаги операндов по умолчанию для каждого операндов ufunc.</target>
        </trans-unit>
        <trans-unit id="c7112a2f014dc699135617be0b1abde474ac316b" translate="yes" xml:space="preserve">
          <source>Overrideable operand flags in ufunc C-API</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d2e2dc0135e076adb3e9a12f5a92b84ec65a0542" translate="yes" xml:space="preserve">
          <source>Overrides the &lt;code&gt;normed&lt;/code&gt; keyword if given.</source>
          <target state="translated">Переопределяет &lt;code&gt;normed&lt;/code&gt; ключевое слово, если оно задано.</target>
        </trans-unit>
        <trans-unit id="3a7540b1b3a0dda7242487679ca9b11862d3a4ba" translate="yes" xml:space="preserve">
          <source>Overrides the data type of the result.</source>
          <target state="translated">Переопределяет тип данных результата.</target>
        </trans-unit>
        <trans-unit id="cb013ea80decaa67cad8a4fef77945440ec27842" translate="yes" xml:space="preserve">
          <source>Overrides the dtype of the calculation and output arrays. Similar to &lt;em&gt;signature&lt;/em&gt;.</source>
          <target state="translated">Переопределяет dtype расчетного и выходного массивов. Подобно &lt;em&gt;подписи&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="7006d2b6fc1325bb6529d58eb36199d98e2b6962" translate="yes" xml:space="preserve">
          <source>Overrides the memory layout of the result. &amp;lsquo;C&amp;rsquo; means C-order, &amp;lsquo;F&amp;rsquo; means F-order, &amp;lsquo;A&amp;rsquo; means &amp;lsquo;F&amp;rsquo; if &lt;code&gt;a&lt;/code&gt; is Fortran contiguous, &amp;lsquo;C&amp;rsquo; otherwise. &amp;lsquo;K&amp;rsquo; means match the layout of &lt;code&gt;a&lt;/code&gt; as closely as possible.</source>
          <target state="translated">Переопределяет структуру памяти результата. 'C' означает C-порядок, 'F' означает F-порядок, 'A' означает 'F', если &lt;code&gt;a&lt;/code&gt; является смежным Fortran, в противном случае 'C'. &amp;laquo;K&amp;raquo; означает максимально возможное соответствие макета &lt;code&gt;a&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ddaf5efe8542a3a691f6af72e37e55e4e33af102" translate="yes" xml:space="preserve">
          <source>Overrides the memory layout of the result. &amp;lsquo;C&amp;rsquo; means C-order, &amp;lsquo;F&amp;rsquo; means F-order, &amp;lsquo;A&amp;rsquo; means &amp;lsquo;F&amp;rsquo; if &lt;code&gt;prototype&lt;/code&gt; is Fortran contiguous, &amp;lsquo;C&amp;rsquo; otherwise. &amp;lsquo;K&amp;rsquo; means match the layout of &lt;code&gt;prototype&lt;/code&gt; as closely as possible.</source>
          <target state="translated">Переопределяет структуру памяти результата. 'C' означает C-порядок, 'F' означает F-порядок, 'A' означает 'F', если &lt;code&gt;prototype&lt;/code&gt; является непрерывным Fortran, в противном случае 'C'. &amp;laquo;К&amp;raquo; означает максимально возможное соответствие макету &lt;code&gt;prototype&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4bd31b5015136a3790d4ea1e4b56f5e23f60c98d" translate="yes" xml:space="preserve">
          <source>Overrides the shape of the result. If order=&amp;rsquo;K&amp;rsquo; and the number of dimensions is unchanged, will try to keep order, otherwise, order=&amp;rsquo;C&amp;rsquo; is implied.</source>
          <target state="translated">Переопределяет форму результата. Если order = 'K' и количество измерений не изменилось, будет пытаться сохранить порядок, в противном случае подразумевается order = 'C'.</target>
        </trans-unit>
        <trans-unit id="3ab7f8eaa264cb0094ba3f9ca231b49fca803e1c" translate="yes" xml:space="preserve">
          <source>Overriding Ufunc behavior</source>
          <target state="translated">Переопределяющее поведение Ufunc</target>
        </trans-unit>
        <trans-unit id="0efc2e6be4c23b9a513d7ce0dcff8ed80e8912e7" translate="yes" xml:space="preserve">
          <source>Overview</source>
          <target state="translated">Overview</target>
        </trans-unit>
        <trans-unit id="4b0a4170e8329f03d8b135ba293e3ad03fce2389" translate="yes" xml:space="preserve">
          <source>Overview of numpy type hierarchy.</source>
          <target state="translated">Обзор иерархии типа numpy.</target>
        </trans-unit>
        <trans-unit id="043d190b03e4fa8608d62de06341dd2afb4fd385" translate="yes" xml:space="preserve">
          <source>Overview of the numpy type hierarchy.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34ec4594b7176e776330d622e2702954b1c3e9ee" translate="yes" xml:space="preserve">
          <source>Overwrite existing signature file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="511993d3c99719e38a6779073019dacd7178ddb9" translate="yes" xml:space="preserve">
          <source>P</source>
          <target state="translated">P</target>
        </trans-unit>
        <trans-unit id="aa00a8efe8f9b81ac75da5a75a43b320bd64395d" translate="yes" xml:space="preserve">
          <source>P. R. Peebles Jr., &amp;ldquo;Central Limit Theorem&amp;rdquo; in &amp;ldquo;Probability, Random Variables and Random Signal Principles&amp;rdquo;, 4th ed., 2001, pp. 51, 51, 125.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb033dba7abb6161a0c83b9f27fd0eb075c43755" translate="yes" xml:space="preserve">
          <source>PCG-64 - The default. A fast generator that supports many parallel streams and can be advanced by an arbitrary amount. See the documentation for &lt;a href=&quot;generated/numpy.random.pcg64.advance#numpy.random.PCG64.advance&quot;&gt;&lt;code&gt;advance&lt;/code&gt;&lt;/a&gt;. PCG-64 has a period of</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="852c68657fb7b98de4c0c80a1fc558db4eb1cb65" translate="yes" xml:space="preserve">
          <source>PCG-64 - The default. A fast generator that supports many parallel streams and can be advanced by an arbitrary amount. See the documentation for &lt;a href=&quot;generated/numpy.random.pcg64.pcg64.advance#numpy.random.pcg64.PCG64.advance&quot;&gt;&lt;code&gt;advance&lt;/code&gt;&lt;/a&gt;. PCG-64 has a period of</source>
          <target state="translated">PCG-64 - по умолчанию. Быстрый генератор, который поддерживает множество параллельных потоков и может быть увеличен на произвольную величину. См. Документацию &lt;a href=&quot;generated/numpy.random.pcg64.pcg64.advance#numpy.random.pcg64.PCG64.advance&quot;&gt; &lt;code&gt;advance&lt;/code&gt; &lt;/a&gt; . PCG-64 имеет период</target>
        </trans-unit>
        <trans-unit id="ec3f94c212b0721b903c3ee685e360e3ef15a646" translate="yes" xml:space="preserve">
          <source>PCG-64 is a 128-bit implementation of O&amp;rsquo;Neill&amp;rsquo;s permutation congruential generator (&lt;a href=&quot;#r4523891264fe-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt;, &lt;a href=&quot;#r4523891264fe-2&quot; id=&quot;id2&quot;&gt;[2]&lt;/a&gt;). PCG-64 has a period of</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c1cc812d4eb7fa422b89cbdb7060063b9828124" translate="yes" xml:space="preserve">
          <source>PCG-64 is a 128-bit implementation of O&amp;rsquo;Neill&amp;rsquo;s permutation congruential generator (&lt;a href=&quot;#r7c40bac0730f-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt;, &lt;a href=&quot;#r7c40bac0730f-2&quot; id=&quot;id2&quot;&gt;[2]&lt;/a&gt;). PCG-64 has a period of</source>
          <target state="translated">PCG-64 - это 128-битная реализация конгруэнтного генератора перестановок О'Нила ( &lt;a href=&quot;#r7c40bac0730f-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt; , &lt;a href=&quot;#r7c40bac0730f-2&quot; id=&quot;id2&quot;&gt;[2]&lt;/a&gt; ). PCG-64 имеет период</target>
        </trans-unit>
        <trans-unit id="4af2a60ae4795c459c6aaf972e39b31efa85a47c" translate="yes" xml:space="preserve">
          <source>PCG64</source>
          <target state="translated">PCG64</target>
        </trans-unit>
        <trans-unit id="8b80c7ece909214affee51ebe9e335eee960dd93" translate="yes" xml:space="preserve">
          <source>PCG64 (class in numpy.random)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d3f1df54c65ec3141b5ad7708d8f310bb35110f" translate="yes" xml:space="preserve">
          <source>PCG64.advance()</source>
          <target state="translated">PCG64.advance()</target>
        </trans-unit>
        <trans-unit id="f8024fbbc3a3aef5b6b9fb19f286aa8ddd8b1f19" translate="yes" xml:space="preserve">
          <source>PCG64.cffi</source>
          <target state="translated">PCG64.cffi</target>
        </trans-unit>
        <trans-unit id="b27789fa8622c7f5407c0a21c98dc4e2c03c99f5" translate="yes" xml:space="preserve">
          <source>PCG64.ctypes</source>
          <target state="translated">PCG64.ctypes</target>
        </trans-unit>
        <trans-unit id="010490775ec92003581521aea797462d39c6844f" translate="yes" xml:space="preserve">
          <source>PCG64.jumped()</source>
          <target state="translated">PCG64.jumped()</target>
        </trans-unit>
        <trans-unit id="e1d334c49d4a4c7a9578ef9b5cd8b69493afac43" translate="yes" xml:space="preserve">
          <source>PCG64.state</source>
          <target state="translated">PCG64.state</target>
        </trans-unit>
        <trans-unit id="b4ff946c27bb613726f09f76ac9051fb9b0f1727" translate="yes" xml:space="preserve">
          <source>PEP 3141 numeric objects (including builtins)</source>
          <target state="translated">PEP 3141 числовые объекты (включая встроенные)</target>
        </trans-unit>
        <trans-unit id="93b1d16c8417eaf68b67a446e7919aa4647e6c45" translate="yes" xml:space="preserve">
          <source>PINF (in module numpy)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="728c523d01503026dd65bbe13e4eb1af6cdeb12e" translate="yes" xml:space="preserve">
          <source>PY_ARRAY_UNIQUE_SYMBOL</source>
          <target state="translated">PY_ARRAY_UNIQUE_SYMBOL</target>
        </trans-unit>
        <trans-unit id="bf891340ec2a11d1acd9aa49c131d2652c5c5626" translate="yes" xml:space="preserve">
          <source>PY_ARRAY_UNIQUE_SYMBOL (C macro)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8adb71a4a1fa67dfff7b23658e29a4c4a31b4cbc" translate="yes" xml:space="preserve">
          <source>PY_UFUNC_UNIQUE_SYMBOL (C variable)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d61443247e63f7e1c0daa436e40747dc59c5d67e" translate="yes" xml:space="preserve">
          <source>PZERO (in module numpy)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0a6424a476b9cde6f4b3f1412e542dd2b247eca9" translate="yes" xml:space="preserve">
          <source>PZERO : Defines positive zero.</source>
          <target state="translated">PZERO:Определяет положительный ноль.</target>
        </trans-unit>
        <trans-unit id="3a39b68c35be609fae3db651a70893a29f102145" translate="yes" xml:space="preserve">
          <source>Packaging</source>
          <target state="translated">Packaging</target>
        </trans-unit>
        <trans-unit id="187a0323079ad9d1ef0a509dbcf41c04c294cb65" translate="yes" xml:space="preserve">
          <source>Packaging (&lt;code&gt;numpy.distutils&lt;/code&gt;)</source>
          <target state="translated">Упаковка ( &lt;code&gt;numpy.distutils&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="f08e1747044acab6d3f1cde93a671bbd941456b2" translate="yes" xml:space="preserve">
          <source>Packaging (numpy.distutils)</source>
          <target state="translated">Упаковка (нумизматические дистилляторы)</target>
        </trans-unit>
        <trans-unit id="ed87cf15ee01e886c94b1a38b3e93dd2cc6fc493" translate="yes" xml:space="preserve">
          <source>Packs the elements of a binary-valued array into bits in a uint8 array.</source>
          <target state="translated">Упаковывает элементы массива двоичных значений в биты в массиве uint8.</target>
        </trans-unit>
        <trans-unit id="bd1a1b48e12df64d08abc99d20b4177d10bc8831" translate="yes" xml:space="preserve">
          <source>Pad an array.</source>
          <target state="translated">Подключите массив.</target>
        </trans-unit>
        <trans-unit id="623338c7d8c79f8103d39448c8e5b48ec92bd71f" translate="yes" xml:space="preserve">
          <source>Pad the exponent with zeros until it contains at least this many digits. If omitted, the exponent will be at least 2 digits.</source>
          <target state="translated">Нажимайте на экспонат нулями до тех пор,пока он не будет содержать по крайней мере столько цифр.Если опустить,то экспонента будет не менее 2-х цифр.</target>
        </trans-unit>
        <trans-unit id="b75a7faadf1505590310ce2efd9e725c23bd6630" translate="yes" xml:space="preserve">
          <source>Pad the left side of the string with whitespace until at least that many characters are to the left of the decimal point.</source>
          <target state="translated">Закладывайте левую часть строки пробелами до тех пор,пока,по крайней мере,многие символы не окажутся слева от десятичной точки.</target>
        </trans-unit>
        <trans-unit id="5afbc760d761bf736b4d58352656b475cf0c23ca" translate="yes" xml:space="preserve">
          <source>Pad the right side of the string with whitespace until at least that many characters are to the right of the decimal point.</source>
          <target state="translated">Поднимайте правую часть строки пробелами до тех пор,пока,по крайней мере,многие символы не окажутся справа от десятичной точки.</target>
        </trans-unit>
        <trans-unit id="d76599ff9339cbc70b09ca989f2b38f16c5bb949" translate="yes" xml:space="preserve">
          <source>Padded array of rank equal to &lt;a href=&quot;numpy.array#numpy.array&quot;&gt;&lt;code&gt;array&lt;/code&gt;&lt;/a&gt; with shape increased according to &lt;code&gt;pad_width&lt;/code&gt;.</source>
          <target state="translated">Заполненный массив ранга, равного &lt;a href=&quot;numpy.array#numpy.array&quot;&gt; &lt;code&gt;array&lt;/code&gt; &lt;/a&gt; с формой, увеличенной в соответствии с &lt;code&gt;pad_width&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ee9a393873e0b61a69dbdfe6eb9af32cf2ca2765" translate="yes" xml:space="preserve">
          <source>Padding Arrays</source>
          <target state="translated">пульверизационные решётки</target>
        </trans-unit>
        <trans-unit id="0e79fa15dcf3528049b2a29ae0606a9732799d3f" translate="yes" xml:space="preserve">
          <source>Padding arrays</source>
          <target state="translated">пустотные массивы</target>
        </trans-unit>
        <trans-unit id="7d526b53b9f3056522af85f26a2d434f580eafad" translate="yes" xml:space="preserve">
          <source>Padding function, see Notes.</source>
          <target state="translated">Функция подкладки,см.примечания.</target>
        </trans-unit>
        <trans-unit id="ed38b70d664fac1df990b27835f8a3a31c0260f4" translate="yes" xml:space="preserve">
          <source>Pads with a constant value.</source>
          <target state="translated">Подушечки с постоянным значением.</target>
        </trans-unit>
        <trans-unit id="d9f2ac48720b42a9d74674f19c7f64e1c0499c32" translate="yes" xml:space="preserve">
          <source>Pads with the edge values of array.</source>
          <target state="translated">Клодки с краевыми значениями массива.</target>
        </trans-unit>
        <trans-unit id="fca51805348b473c846607d0a2857abe02017fd5" translate="yes" xml:space="preserve">
          <source>Pads with the linear ramp between end_value and the array edge value.</source>
          <target state="translated">Косички с линейным темпом между значением end_value и краевым значением массива.</target>
        </trans-unit>
        <trans-unit id="630cd57bb220770a2f515175c115bde03142bb98" translate="yes" xml:space="preserve">
          <source>Pads with the maximum value of all or part of the vector along each axis.</source>
          <target state="translated">Косички с максимальным значением всего или части вектора вдоль каждой оси.</target>
        </trans-unit>
        <trans-unit id="d3b2120b9c4caeb3f445da36215883fca44003eb" translate="yes" xml:space="preserve">
          <source>Pads with the mean value of all or part of the vector along each axis.</source>
          <target state="translated">Косички со средним значением всего или части вектора вдоль каждой оси.</target>
        </trans-unit>
        <trans-unit id="65b8c9f7297b280c0b0ee0ea3cb9a6f56b7bac40" translate="yes" xml:space="preserve">
          <source>Pads with the median value of all or part of the vector along each axis.</source>
          <target state="translated">Косички с медианным значением всего или части вектора вдоль каждой оси.</target>
        </trans-unit>
        <trans-unit id="ec1953311c26ffb67e42015bdd267c1393f31365" translate="yes" xml:space="preserve">
          <source>Pads with the minimum value of all or part of the vector along each axis.</source>
          <target state="translated">Косички с минимальным значением всего или части вектора вдоль каждой оси.</target>
        </trans-unit>
        <trans-unit id="84bf3b9c4e883de4227d55b10846e004bac799fd" translate="yes" xml:space="preserve">
          <source>Pads with the reflection of the vector mirrored along the edge of the array.</source>
          <target state="translated">Коврики с отражением вектора,зеркально отображенные по краю массива.</target>
        </trans-unit>
        <trans-unit id="4b83447ca8923bd3b3b6c9f855b78e24ddedd519" translate="yes" xml:space="preserve">
          <source>Pads with the reflection of the vector mirrored on the first and last values of the vector along each axis.</source>
          <target state="translated">Косички с отражением вектора,зеркально отображенные на первом и последнем значениях вектора вдоль каждой оси.</target>
        </trans-unit>
        <trans-unit id="ef5d2e46c3cd8911ff34acad9b1fd07efaafaa7f" translate="yes" xml:space="preserve">
          <source>Pads with the wrap of the vector along the axis. The first values are used to pad the end and the end values are used to pad the beginning.</source>
          <target state="translated">Коврики с обертыванием вектора вдоль оси.Первые значения используются для запечатывания конца,а конечные значения-для запечатывания начала.</target>
        </trans-unit>
        <trans-unit id="5d9b9b2531a80866d4446740404b61350cb894e2" translate="yes" xml:space="preserve">
          <source>Pads with undefined values.</source>
          <target state="translated">Колодки с неопределенными значениями.</target>
        </trans-unit>
        <trans-unit id="30bf8ab0f9434e52331cad6b06732b0029f39c77" translate="yes" xml:space="preserve">
          <source>Paired indices, comma separated (not colon), specifying slices to reduce.</source>
          <target state="translated">Парные индексы,разделенные запятыми (не двоеточие),с указанием срезов для уменьшения.</target>
        </trans-unit>
        <trans-unit id="a438d0b43daa8f2d136f89cacc82c90b7152dea4" translate="yes" xml:space="preserve">
          <source>Papoulis, A., &amp;ldquo;Probability, Random Variables, and Stochastic Processes,&amp;rdquo; 3rd ed., New York: McGraw-Hill, 1991.</source>
          <target state="translated">Папулис, А., &amp;laquo;Вероятность, случайные величины и случайные процессы&amp;raquo;, 3-е изд., Нью-Йорк: McGraw-Hill, 1991.</target>
        </trans-unit>
        <trans-unit id="b8d6037f133c5f0d5c4523ae33087584f0a1405b" translate="yes" xml:space="preserve">
          <source>Parallel Applications</source>
          <target state="translated">Параллельные приложения</target>
        </trans-unit>
        <trans-unit id="aac167a2f3e07666230480dee8733fd1d08660a0" translate="yes" xml:space="preserve">
          <source>Parallel Congruent Generator (64-bit, PCG64)</source>
          <target state="translated">Параллельный конгруэнтный генератор (64-битный,PCG64)</target>
        </trans-unit>
        <trans-unit id="c11bc78976f584d51e758640f9947c4868085ffb" translate="yes" xml:space="preserve">
          <source>Parallel Generation</source>
          <target state="translated">Параллельное генерирование</target>
        </trans-unit>
        <trans-unit id="28c385ef0bb17bc2f9b3f8a95422e1692d0ab57f" translate="yes" xml:space="preserve">
          <source>Parallel Random Number Generation</source>
          <target state="translated">Генерация параллельных случайных чисел</target>
        </trans-unit>
        <trans-unit id="a05f67574ff8722f0c85f0dfa090ee3948151417" translate="yes" xml:space="preserve">
          <source>Parallel builds</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9941199a0536bd27f4ba9e0cd3912352ab02906b" translate="yes" xml:space="preserve">
          <source>Parallel generation</source>
          <target state="translated">Параллельное генерирование</target>
        </trans-unit>
        <trans-unit id="e68f24d053a783af78bf2916ad834b59d3272612" translate="yes" xml:space="preserve">
          <source>Parameter of the distribution (k dimension for sample of dimension k).</source>
          <target state="translated">Параметр распределения (размер k для образца размера k).</target>
        </trans-unit>
        <trans-unit id="5aa3c312bfd3d4206107887488694b91a51af27a" translate="yes" xml:space="preserve">
          <source>Parameter of the distribution (length &lt;code&gt;k&lt;/code&gt; for sample of length &lt;code&gt;k&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="70f52333135962fba02933f939303deb96a3ad5b" translate="yes" xml:space="preserve">
          <source>Parameter of the distribution, &amp;gt; 0.</source>
          <target state="translated">Параметр распределения&amp;gt; 0.</target>
        </trans-unit>
        <trans-unit id="ea913350c134ad81bd1f5863f2b7b64acafebc1a" translate="yes" xml:space="preserve">
          <source>Parameter of the distribution, &amp;gt;= 0 and &amp;lt;=1.</source>
          <target state="translated">Параметр распределения,&amp;gt; = 0 и &amp;lt;= 1.</target>
        </trans-unit>
        <trans-unit id="617d0343737dbfbd0f0f6ec71b30f6e0961d6b3c" translate="yes" xml:space="preserve">
          <source>Parameter of the distribution, &amp;gt;= 0. Floats are also accepted, but they will be truncated to integers.</source>
          <target state="translated">Параметр распределения,&amp;gt; = 0. Допускаются также числа с плавающей запятой, но они будут усечены до целых чисел.</target>
        </trans-unit>
        <trans-unit id="41e8c4e61c4d4560f4c6864639517a272c9f4976" translate="yes" xml:space="preserve">
          <source>Parameter of the distribution. Default is 0.</source>
          <target state="translated">Параметр распределения.По умолчанию 0.</target>
        </trans-unit>
        <trans-unit id="699574a6b4b57fab6065ea4b5f6ef3f03b3ea735" translate="yes" xml:space="preserve">
          <source>Parameter of the distribution. Must be non-negative.</source>
          <target state="translated">Параметр распределения.Должен быть неотрицательным.</target>
        </trans-unit>
        <trans-unit id="1b9843d14161f83cfaa303eb7a8d9c859f6d9f77" translate="yes" xml:space="preserve">
          <source>Parameter of the distribution. Must be non-negative. Default is 1.</source>
          <target state="translated">Параметр распределения.Должен быть неотрицательным.По умолчанию 1.</target>
        </trans-unit>
        <trans-unit id="e42d7698a7fc31da8e47db0ca607a272026fd177" translate="yes" xml:space="preserve">
          <source>Parameter of the distribution. Must satisfy 0 &amp;lt; p &amp;lt;= 1.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e1c357c2b875b90cada80608cc164df535a0ecfc" translate="yes" xml:space="preserve">
          <source>Parameter, must be non-negative.</source>
          <target state="translated">Параметр должен быть неотрицательным.</target>
        </trans-unit>
        <trans-unit id="a975eea30db9fa05003e3b5097688bd49ec7e01b" translate="yes" xml:space="preserve">
          <source>Parameters</source>
          <target state="translated">Parameters</target>
        </trans-unit>
        <trans-unit id="381c775599d6e4185d4410725809e360928357cd" translate="yes" xml:space="preserve">
          <source>Parameters:</source>
          <target state="translated">Parameters:</target>
        </trans-unit>
        <trans-unit id="9e0892c276c48dd008b5fe6e010bfd8cfb08da04" translate="yes" xml:space="preserve">
          <source>Parametric tests</source>
          <target state="translated">Параметрические тесты</target>
        </trans-unit>
        <trans-unit id="768ae1b1301865b35eda7aa4c4ef56497e1e3a2c" translate="yes" xml:space="preserve">
          <source>Parent name.</source>
          <target state="translated">Родительское имя.</target>
        </trans-unit>
        <trans-unit id="0afd4ac6a1f194c4487e49e8f1f570664d022158" translate="yes" xml:space="preserve">
          <source>Pareto, V. (1896). Course of Political Economy. Lausanne.</source>
          <target state="translated">Парето,В.(1896).Курс политической экономии.Лозанна.</target>
        </trans-unit>
        <trans-unit id="5fa3e0d5937fa68006f8ed4ea820c3f856e05107" translate="yes" xml:space="preserve">
          <source>Parse and compare numpy version strings.</source>
          <target state="translated">Разобрать и сравнить нумированные строки версий.</target>
        </trans-unit>
        <trans-unit id="89743befa343f135565af63acf81651d7fa56a28" translate="yes" xml:space="preserve">
          <source>Partial sort.</source>
          <target state="translated">Частичная сортировка.</target>
        </trans-unit>
        <trans-unit id="c9b347464deed01215a4b73f0c568de4c1b1f29c" translate="yes" xml:space="preserve">
          <source>Partial support for 64-bit f2py extensions with MinGW</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf1f476600e3b441461161e5761f11632e411e50" translate="yes" xml:space="preserve">
          <source>Partition (split) each element around the right-most separator.</source>
          <target state="translated">Разделите (разделите)каждый элемент вокруг самого правого разделителя.</target>
        </trans-unit>
        <trans-unit id="8e7a1711564903156f9d326524293916fcf5f95c" translate="yes" xml:space="preserve">
          <source>Partition each element in &lt;code&gt;a&lt;/code&gt; around &lt;code&gt;sep&lt;/code&gt;.</source>
          <target state="translated">Partition каждого элемента в &lt;code&gt;a&lt;/code&gt; вокруг &lt;code&gt;sep&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b8f7f9acaefcb4179a22219e6e4159e78558c3ee" translate="yes" xml:space="preserve">
          <source>Partition each element in &lt;code&gt;self&lt;/code&gt; around &lt;code&gt;sep&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b9f060d2d7460c8bb8da409bb17ec782b77da6c8" translate="yes" xml:space="preserve">
          <source>Pass in &lt;a href=&quot;#c.NPY_MAXDIMS&quot;&gt;&lt;code&gt;NPY_MAXDIMS&lt;/code&gt;&lt;/a&gt; for axis in order to achieve the same effect that is obtained by passing in &lt;code&gt;axis=None&lt;/code&gt; in Python (treating the array as a 1-d array).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="73cd8d136978e78fbd97dbe5ed74c150dbf70d53" translate="yes" xml:space="preserve">
          <source>Pass in &lt;a href=&quot;#c.NPY_MAXDIMS&quot;&gt;&lt;code&gt;NPY_MAXDIMS&lt;/code&gt;&lt;/a&gt; for axis in order to achieve the same effect that is obtained by passing in &lt;em&gt;axis&lt;/em&gt; = &lt;code&gt;None&lt;/code&gt; in Python (treating the array as a 1-d array).</source>
          <target state="translated">Передайте &lt;a href=&quot;#c.NPY_MAXDIMS&quot;&gt; &lt;code&gt;NPY_MAXDIMS&lt;/code&gt; &lt;/a&gt; для оси, чтобы добиться того же эффекта, который получается при передаче &lt;em&gt;axis&lt;/em&gt; = &lt;code&gt;None&lt;/code&gt; в Python (обработка массива как 1-мерного массива).</target>
        </trans-unit>
        <trans-unit id="58a3162e63c74cd0a5b9f30fee127febc4cf5551" translate="yes" xml:space="preserve">
          <source>Pass the data and shape information on to a subroutine or other section of code that actually performs the computation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="156da705bee027f7cedec8eb9921a006c401c66c" translate="yes" xml:space="preserve">
          <source>Passing &lt;code&gt;shape=0&lt;/code&gt; to factory functions in &lt;code&gt;numpy.rec&lt;/code&gt; is deprecated</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d10d9cbcf594e625c1e314a82048242c6dbb90d" translate="yes" xml:space="preserve">
          <source>Passing &lt;code&gt;shape=None&lt;/code&gt; to functions with a non-optional shape argument is deprecated</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d15e20b835ab140727ff8c5a5d6d26cf599eec85" translate="yes" xml:space="preserve">
          <source>Passing None for &lt;code&gt;dtype&lt;/code&gt; is different from omitting the parameter, since the former invokes &lt;code&gt;dtype(None)&lt;/code&gt; which is an alias for &lt;code&gt;dtype('float_')&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b89022c4aa33577203e66e96c9430c9099309a83" translate="yes" xml:space="preserve">
          <source>Passing a single array in the &amp;lsquo;out&amp;rsquo; keyword argument to a ufunc with multiple outputs is deprecated, and will raise a warning in numpy 1.10, and an error in a future release.</source>
          <target state="translated">Передача одного массива в аргументе ключевого слова out в ufunc с несколькими выходами устарела и вызовет предупреждение в numpy 1.10 и ошибку в будущей версии.</target>
        </trans-unit>
        <trans-unit id="cc5f2cbfa94aa687203b7f58cf1ebb3635d8adf8" translate="yes" xml:space="preserve">
          <source>Passing in a unit will change the precision</source>
          <target state="translated">Прохождение в устройстве изменит точность</target>
        </trans-unit>
        <trans-unit id="0f7da55a06e16eb446ed0921edff81714e6fd8fa" translate="yes" xml:space="preserve">
          <source>Path to data files can be a function taking no arguments and returning path(s) to data files &amp;ndash; this is a useful when data files are generated while building the package. (XXX: explain the step when this function are called exactly)</source>
          <target state="translated">Путь к файлам данных может быть функцией, не принимающей аргументов и возвращающей путь (пути) к файлам данных - это полезно, когда файлы данных генерируются при сборке пакета. (XXX: объясните шаг, когда именно вызывается эта функция)</target>
        </trans-unit>
        <trans-unit id="7b09e5c11956eb9c1498f52bbb0e9c021d2dd1d7" translate="yes" xml:space="preserve">
          <source>Path to install the library, relative to the current sub-package.</source>
          <target state="translated">Путь для установки библиотеки,относительно текущего подпакета.</target>
        </trans-unit>
        <trans-unit id="bcea45c9bd2476c9e4cd30676023f4aeef1d6024" translate="yes" xml:space="preserve">
          <source>Path to test module, or None. By default, run the module from which this function is called.</source>
          <target state="translated">Путь к модулю тестирования,или Нет.По умолчанию запустите модуль,из которого эта функция вызывается.</target>
        </trans-unit>
        <trans-unit id="5aaad5ad47911a6ee3698400062dbd905a7c854b" translate="yes" xml:space="preserve">
          <source>Path to the directory where the source file gets downloaded to for use. If &lt;code&gt;destpath&lt;/code&gt; is None, a temporary directory will be created. The default path is the current directory.</source>
          <target state="translated">Путь к каталогу, в который загружается исходный файл для использования. Если &lt;code&gt;destpath&lt;/code&gt; равен None, будет создан временный каталог. Путь по умолчанию - текущий каталог.</target>
        </trans-unit>
        <trans-unit id="f9f9dd4b0f8cff037993dd2cabb077c76f25ccdf" translate="yes" xml:space="preserve">
          <source>Path to the mapped file.</source>
          <target state="translated">Путь к картографическому файлу.</target>
        </trans-unit>
        <trans-unit id="469a6fbd3b07320fafdf1032dad3f5f283c78450" translate="yes" xml:space="preserve">
          <source>Pathlib support for &lt;code&gt;fromfile&lt;/code&gt;, &lt;code&gt;tofile&lt;/code&gt; and &lt;code&gt;ndarray.dump&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="881e30b3dab6ac95c64ea97e026f084d13c834c1" translate="yes" xml:space="preserve">
          <source>Pauli Virtanen</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e03200e2fcb1cc9aa1208bae4cef4e55d8221f5a" translate="yes" xml:space="preserve">
          <source>Paver (pip)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b5d38425a72fb16fe116f884b547ba73162e566c" translate="yes" xml:space="preserve">
          <source>Paver is used to build the source releases. It will create the &lt;code&gt;release&lt;/code&gt; and &lt;code&gt;release/installers&lt;/code&gt; directories and put the &lt;code&gt;*.zip&lt;/code&gt; and &lt;code&gt;*.tar.gz&lt;/code&gt; source releases in the latter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b41a92bed03261664717a6afdad4edf3d5d6ef6e" translate="yes" xml:space="preserve">
          <source>Payment</source>
          <target state="translated">Payment</target>
        </trans-unit>
        <trans-unit id="0e3a3cc21418fc90fe6ecc74f59b0c52c7573497" translate="yes" xml:space="preserve">
          <source>Payment against loan plus interest. If all input is scalar, returns a scalar float. If any input is array_like, returns payment for each input element. If multiple inputs are array_like, they all must have the same shape.</source>
          <target state="translated">Оплата кредита плюс проценты.Если все введенные данные являются скалярными,возвращается скалярный поплавок.Если любой вход является массивом_подобным,возвращает оплату за каждый входной элемент.Если несколько входов похожи на массив_,то все они должны иметь одинаковую форму.</target>
        </trans-unit>
        <trans-unit id="271672e73ea39752eac8cd415579fb64e6dce733" translate="yes" xml:space="preserve">
          <source>Peak to peak (maximum - minimum) value along a given axis.</source>
          <target state="translated">Пиковое (максимальное-минимальное)значение вдоль заданной оси.</target>
        </trans-unit>
        <trans-unit id="6440f5bac3611c7691e3f3b6096a90aded3cd7c7" translate="yes" xml:space="preserve">
          <source>Peak-to-peak (maximum - minimum) value along the given axis.</source>
          <target state="translated">Пиковое (максимальное-минимальное)значение вдоль данной оси.</target>
        </trans-unit>
        <trans-unit id="a4d9b598086b2e4807ae948d1154096a596ee878" translate="yes" xml:space="preserve">
          <source>People use the terms &amp;ldquo;how-to&amp;rdquo; and &amp;ldquo;tutorial&amp;rdquo; interchangeably, but we draw a distinction, following Daniele Procida&amp;rsquo;s &lt;a href=&quot;https://documentation.divio.com/&quot;&gt;taxonomy of documentation&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3cede1363e0d94b858cd773fa14f118d5eb0e6f" translate="yes" xml:space="preserve">
          <source>Percentile implemented in terms of &lt;code&gt;np.partition&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e770ebd82c1aff8fd49c8c27f132133320abb8f" translate="yes" xml:space="preserve">
          <source>Percentile or sequence of percentiles to compute, which must be between 0 and 100 inclusive.</source>
          <target state="translated">Процент или последовательность перцентилей для вычисления,которые должны быть в диапазоне от 0 до 100 включительно.</target>
        </trans-unit>
        <trans-unit id="a255b994d23ac7634da6f95c324c497d0ac47849" translate="yes" xml:space="preserve">
          <source>Percentile output changes</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="591430971d8daa3533d8d46e03b21bb8d090d46c" translate="yes" xml:space="preserve">
          <source>Percentile supports more interpolation options</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="39e5a5c70ff7afff4f74e23e5b6f9bc7ce3c427f" translate="yes" xml:space="preserve">
          <source>Perform an indirect partition along the given axis using the algorithm specified by the &lt;code&gt;kind&lt;/code&gt; keyword.</source>
          <target state="translated">Выполните косвенное разбиение по заданной оси, используя алгоритм, заданный ключевым словом &lt;code&gt;kind&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="aa6a3a9823da0a46526f859015ecc6fb3fbea02b" translate="yes" xml:space="preserve">
          <source>Perform an indirect partition along the given axis using the algorithm specified by the &lt;code&gt;kind&lt;/code&gt; keyword. It returns an array of indices of the same shape as &lt;code&gt;a&lt;/code&gt; that index data along the given axis in partitioned order.</source>
          <target state="translated">Выполните косвенное разбиение по заданной оси, используя алгоритм, заданный ключевым словом &lt;code&gt;kind&lt;/code&gt; . Он возвращает массив индексов той же формы , как &lt;code&gt;a&lt;/code&gt; этот индекс данные вдоль заданной оси в секционированной порядке.</target>
        </trans-unit>
        <trans-unit id="64032456cbe8319e7d98bde786ae8344738e1455" translate="yes" xml:space="preserve">
          <source>Perform an indirect sort along the given axis using the algorithm specified by the &lt;code&gt;kind&lt;/code&gt; keyword. It returns an array of indices of the same shape as &lt;code&gt;a&lt;/code&gt; that index data along the given axis in sorted order.</source>
          <target state="translated">Выполните косвенную сортировку по заданной оси, используя алгоритм, заданный ключевым словом &lt;code&gt;kind&lt;/code&gt; . Он возвращает массив индексов той же формы , как &lt;code&gt;a&lt;/code&gt; этот индекс данные вдоль заданной оси в отсортированном порядке.</target>
        </trans-unit>
        <trans-unit id="e51a52f04a9140623599aa3b0b98ea5b1cc97dfc" translate="yes" xml:space="preserve">
          <source>Perform an indirect stable sort using a sequence of keys.</source>
          <target state="translated">Выполните косвенную стабильную сортировку,используя последовательность клавиш.</target>
        </trans-unit>
        <trans-unit id="67a1b7c0504ae299de04313d9433cb77c326b1c0" translate="yes" xml:space="preserve">
          <source>Perform consistency check of arguments by evaluating &lt;code&gt;&amp;lt;C-booleanexpr&amp;gt;&lt;/code&gt;; if &lt;code&gt;&amp;lt;C-booleanexpr&amp;gt;&lt;/code&gt; returns 0, an exception is raised.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="63c904559993935c470f516c8b549ca7f3640dbb" translate="yes" xml:space="preserve">
          <source>Performance</source>
          <target state="translated">Performance</target>
        </trans-unit>
        <trans-unit id="6637203688f192cd4c7831fd72958ca38674eef7" translate="yes" xml:space="preserve">
          <source>Performance differs across platforms due to compiler and hardware availability (e.g., register width) differences. The default bit generator has been chosen to perform well on 64-bit platforms. Performance on 32-bit operating systems is very different.</source>
          <target state="translated">Производительность отличается в зависимости от платформы из-за различий в компиляторе и доступности оборудования (например,ширина регистра).Для успешной работы на 64-битных платформах был выбран генератор битов по умолчанию.Производительность на 32-битных операционных системах сильно отличается.</target>
        </trans-unit>
        <trans-unit id="9c52299828f379fa31ccf418c483aeec41f916ab" translate="yes" xml:space="preserve">
          <source>Performance improvement for &lt;code&gt;np.array&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b0c97591e66a1a7ade5603056a75445a61446141" translate="yes" xml:space="preserve">
          <source>Performance improvement for &lt;code&gt;np.searchsorted&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9603b88256d72407ab6e6c3f19a0ffa5841913bc" translate="yes" xml:space="preserve">
          <source>Performance improvements and changes</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b6f4578a97efb62d654157c29d267317ee2475b0" translate="yes" xml:space="preserve">
          <source>Performance improvements for &lt;code&gt;packbits&lt;/code&gt; and &lt;code&gt;unpackbits&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a3dba14d8d4ce495c233d380d634d031e87a8cd0" translate="yes" xml:space="preserve">
          <source>Performance improvements to &lt;code&gt;isnan&lt;/code&gt;, &lt;code&gt;isinf&lt;/code&gt;, &lt;code&gt;isfinite&lt;/code&gt; and &lt;code&gt;byteswap&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b448d45ff6016d5c9cee889d533aea1f08a20b36" translate="yes" xml:space="preserve">
          <source>Performance improvements to &lt;code&gt;median&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ced4e57dc2a9cf06efc202bc15e74ab7476bdf9c" translate="yes" xml:space="preserve">
          <source>Performance improvements to &lt;code&gt;pad&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7518fcdea1f898cd57fb2174ab71737760cfa801" translate="yes" xml:space="preserve">
          <source>Performance improvements via SSE2 vectorization</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c4d87af8409567870f0a8884054dba62da5530d" translate="yes" xml:space="preserve">
          <source>Performance on different Operating Systems</source>
          <target state="translated">Производительность на различных операционных системах</target>
        </trans-unit>
        <trans-unit id="5459d1c079af547b963e3b424e98d9eb9d73b000" translate="yes" xml:space="preserve">
          <source>Performance tuning</source>
          <target state="translated">Настройка производительности</target>
        </trans-unit>
        <trans-unit id="d8745def767a8cd0cac8c9e4b16803d5c76be3a9" translate="yes" xml:space="preserve">
          <source>Performance-Related Options</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b8da6105b8a6d69384985610612578b000a977b" translate="yes" xml:space="preserve">
          <source>Performs a (local) reduce with specified slices over a single axis.</source>
          <target state="translated">Выполняет (локальное)уменьшение с заданными срезами по одной оси.</target>
        </trans-unit>
        <trans-unit id="793e356298f57d9115bf94bc021ff4af3ab35b36" translate="yes" xml:space="preserve">
          <source>Performs element-wise comparison of two string arrays using the comparison operator specified by &lt;code&gt;cmp_op&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c5da77705e71b95e951ed4d7ec45e06388841c4" translate="yes" xml:space="preserve">
          <source>Performs unbuffered in place operation on operand &amp;lsquo;a&amp;rsquo; for elements specified by &amp;lsquo;indices&amp;rsquo;.</source>
          <target state="translated">Выполняет небуферизованную операцию на месте для операнда &amp;laquo;а&amp;raquo; для элементов, указанных в &amp;laquo;индексах&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="64fcbb980b448111a78376527afea140c32d0b99" translate="yes" xml:space="preserve">
          <source>Performs unbuffered in place operation on operand &amp;lsquo;a&amp;rsquo; for elements specified by &amp;lsquo;indices&amp;rsquo;. For addition ufunc, this method is equivalent to &lt;code&gt;a[indices] += b&lt;/code&gt;, except that results are accumulated for elements that are indexed more than once. For example, &lt;code&gt;a[[0,0]] += 1&lt;/code&gt; will only increment the first element once because of buffering, whereas &lt;code&gt;add.at(a, [0,0], 1)&lt;/code&gt; will increment the first element twice.</source>
          <target state="translated">Выполняет небуферизованную операцию на месте для операнда &amp;laquo;а&amp;raquo; для элементов, указанных в &amp;laquo;индексах&amp;raquo;. Для сложения ufunc этот метод эквивалентен &lt;code&gt;a[indices] += b&lt;/code&gt; , за исключением того, что результаты накапливаются для элементов, которые индексируются более одного раза. Например, &lt;code&gt;a[[0,0]] += 1&lt;/code&gt; увеличивает первый элемент только один раз из-за буферизации, тогда как &lt;code&gt;add.at(a, [0,0], 1)&lt;/code&gt; увеличивает первый элемент дважды.</target>
        </trans-unit>
        <trans-unit id="170a28a9db6d27d7212fc6dc249434a57517e7bc" translate="yes" xml:space="preserve">
          <source>Period</source>
          <target state="translated">Period</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
