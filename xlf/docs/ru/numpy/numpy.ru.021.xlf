<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="numpy">
    <body>
      <group id="numpy">
        <trans-unit id="95260188435af534996db3e9c839aec2ec1973f1" translate="yes" xml:space="preserve">
          <source>Split array into multiple sub-arrays horizontally (column wise)</source>
          <target state="translated">Разбиение массива на несколько подмассивов по горизонтали (с учетом столбца).</target>
        </trans-unit>
        <trans-unit id="51dd8171b04c2b0c76ba9d323ee327eabec86d47" translate="yes" xml:space="preserve">
          <source>Split array into multiple sub-arrays horizontally (column wise).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a58d1a7c17bf5b26ef79c3a68ad7dfd39dc14fd" translate="yes" xml:space="preserve">
          <source>Split array into multiple sub-arrays horizontally (column-wise).</source>
          <target state="translated">Разделите массив на несколько подмассивов по горизонтали (по столбцам).</target>
        </trans-unit>
        <trans-unit id="aaa399416b95737d5812be5e3aafc40e1bde329d" translate="yes" xml:space="preserve">
          <source>Split array into multiple sub-arrays of equal size.</source>
          <target state="translated">Разделите массив на несколько подмассивов одинакового размера.</target>
        </trans-unit>
        <trans-unit id="32200fb547976d9cdce1bf0123e79ad3d01d45c6" translate="yes" xml:space="preserve">
          <source>Split array into multiple sub-arrays vertically (row wise)</source>
          <target state="translated">Разделите массив на несколько подмассивов по вертикали (с учетом строк).</target>
        </trans-unit>
        <trans-unit id="5e2072ff967b60fe048397bbdc922e037ef75e9d" translate="yes" xml:space="preserve">
          <source>Split array into multiple sub-arrays vertically (row wise).</source>
          <target state="translated">Разделите массив на несколько подмассивов по вертикали (с учетом строк).</target>
        </trans-unit>
        <trans-unit id="d638a6c0e1614240bc1fdb2bb9a33a3845eee28f" translate="yes" xml:space="preserve">
          <source>Splitting arrays</source>
          <target state="translated">Разделительные массивы</target>
        </trans-unit>
        <trans-unit id="e788a54fb6fdb2a43a1ae31294a2bfe96a83c4a8" translate="yes" xml:space="preserve">
          <source>Splitting one array into several smaller ones</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="154e3ad24baea0d9af086340b67288378fdfe64f" translate="yes" xml:space="preserve">
          <source>Splitting the lines into columns</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d58ebaf799f88b14e5a55e0738d2ff6431f8e7d" translate="yes" xml:space="preserve">
          <source>Square identity matrix.</source>
          <target state="translated">Квадратная матрица идентификации.</target>
        </trans-unit>
        <trans-unit id="3613d80d3881f6e72e0182c8791baa68e9f04486" translate="yes" xml:space="preserve">
          <source>Square root (of data size) estimator, used by Excel and other programs for its speed and simplicity.</source>
          <target state="translated">Квадратный корень (размера данных)оценщик,используемый Excel и другими программами для его скорости и простоты.</target>
        </trans-unit>
        <trans-unit id="bf5a12657392766edfc9adfbf010a7c69c0ce01d" translate="yes" xml:space="preserve">
          <source>Squashing commits or cleaning up commit messages of a PR that you consider too messy is OK. Remember to retain the original author&amp;rsquo;s name when doing this. Make sure commit messages follow the &lt;a href=&quot;development_workflow#writing-the-commit-message&quot;&gt;rules for NumPy&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0a4dd332ee1cc0f34be7b423ca38b3a124b358e2" translate="yes" xml:space="preserve">
          <source>St&amp;eacute;fan van der Walt</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a20f5de17a778177c1d20a924357600fac4e355d" translate="yes" xml:space="preserve">
          <source>Stack 1-D arrays as columns into a 2-D array.</source>
          <target state="translated">Стек 1-D массивов в виде столбцов в 2-D массив.</target>
        </trans-unit>
        <trans-unit id="22aff824a88fb9e372dada7709040605bdecb795" translate="yes" xml:space="preserve">
          <source>Stack a sequence of arrays along a new axis.</source>
          <target state="translated">Сложите последовательность массивов вдоль новой оси.</target>
        </trans-unit>
        <trans-unit id="b708f3f441cf8b7881ef5ae7003def9a89be1321" translate="yes" xml:space="preserve">
          <source>Stack along first axis.</source>
          <target state="translated">Стойка вдоль первой оси.</target>
        </trans-unit>
        <trans-unit id="4e6821d485f2c248408d2340ce48afc4638994d9" translate="yes" xml:space="preserve">
          <source>Stack along second axis.</source>
          <target state="translated">Стойка вдоль второй оси.</target>
        </trans-unit>
        <trans-unit id="654d38ec444eb1ee8c9c4cb4064b5c34d10ed04b" translate="yes" xml:space="preserve">
          <source>Stack arrays in sequence along a new dimension.</source>
          <target state="translated">Складывайте массивы последовательно по новому измерению.</target>
        </trans-unit>
        <trans-unit id="8075374116f55fd4a715fc7ce7ce68e6a94d1c6b" translate="yes" xml:space="preserve">
          <source>Stack arrays in sequence depth wise (along third axis).</source>
          <target state="translated">Массивы стека в последовательности по глубине (вдоль третьей оси).</target>
        </trans-unit>
        <trans-unit id="49771b17dcab7c55c17889eac7ab065c2d3411f8" translate="yes" xml:space="preserve">
          <source>Stack arrays in sequence depth wise (along third dimension)</source>
          <target state="translated">Массивы стека в последовательности по глубине (по третьему измерению)</target>
        </trans-unit>
        <trans-unit id="d03609f09d0072b17b53d7c9e81abc547dbe26af" translate="yes" xml:space="preserve">
          <source>Stack arrays in sequence depth wise (along third dimension).</source>
          <target state="translated">Массивы стекаются последовательно по глубине (по третьему измерению).</target>
        </trans-unit>
        <trans-unit id="9d4bdc812ef44d6a84449088558f278a7a04fd89" translate="yes" xml:space="preserve">
          <source>Stack arrays in sequence horizontally (column wise)</source>
          <target state="translated">Массивы стекаются последовательно по горизонтали (по столбцам)</target>
        </trans-unit>
        <trans-unit id="ab9d3847a31919c576029d377c5a503add8ffa12" translate="yes" xml:space="preserve">
          <source>Stack arrays in sequence horizontally (column wise).</source>
          <target state="translated">Массивы стекаются последовательно по горизонтали (по столбцам).</target>
        </trans-unit>
        <trans-unit id="6895241ba9b7ce75e412efb0b37cc740ec4c6f5a" translate="yes" xml:space="preserve">
          <source>Stack arrays in sequence vertically (row wise)</source>
          <target state="translated">Массивы стекаются последовательно по вертикали (с учетом строк)</target>
        </trans-unit>
        <trans-unit id="d3ccf82c78c83570433d65f4d8ae10b7fd8977b2" translate="yes" xml:space="preserve">
          <source>Stack arrays in sequence vertically (row wise).</source>
          <target state="translated">Массивы стекаются последовательно по вертикали (с учетом строк).</target>
        </trans-unit>
        <trans-unit id="32995c381170a7cab2370b6bab49aaf95973692d" translate="yes" xml:space="preserve">
          <source>Stacking together different arrays</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8085e023a3bd83539ee52ab6920d2f5d11c78066" translate="yes" xml:space="preserve">
          <source>Stacks of matrices are broadcast together as if the matrices were elements, respecting the signature &lt;code&gt;(n,k),(k,m)-&amp;gt;(n,m)&lt;/code&gt;:</source>
          <target state="translated">Стеки матриц транслируются вместе, как если бы матрицы были элементами, соблюдая сигнатуру &lt;code&gt;(n,k),(k,m)-&amp;gt;(n,m)&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="d04797e8ae7899c2001f6f6340094625d64a3d75" translate="yes" xml:space="preserve">
          <source>Stacks of object matrices are not currently supported.</source>
          <target state="translated">Стеки объектных матриц в настоящее время не поддерживаются.</target>
        </trans-unit>
        <trans-unit id="67bfee426b8f29b7c1b147b264c4ea92422abbce" translate="yes" xml:space="preserve">
          <source>Stadlober, Ernst, &amp;ldquo;The ratio of uniforms approach for generating discrete random variates&amp;rdquo;, Journal of Computational and Applied Mathematics, 31, pp. 181-189 (1990).</source>
          <target state="translated">Штадлобер, Эрнст, &amp;laquo;Подход с использованием отношения униформ для генерации дискретных случайных величин&amp;raquo;, Журнал вычислительной и прикладной математики, 31, стр. 181-189 (1990).</target>
        </trans-unit>
        <trans-unit id="f35d3ef365b37da6958be17fda8b07fc8d89e22e" translate="yes" xml:space="preserve">
          <source>Standard Binary Formats</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6555192e9f6da8cd095b33f3c4f7b71a9783ffae" translate="yes" xml:space="preserve">
          <source>Standard Exponentials (&lt;a href=&quot;generated/numpy.random.generator.standard_exponential#numpy.random.Generator.standard_exponential&quot;&gt;&lt;code&gt;standard_exponential&lt;/code&gt;&lt;/a&gt;)</source>
          <target state="translated">Стандартные экспоненты ( &lt;a href=&quot;generated/numpy.random.generator.standard_exponential#numpy.random.Generator.standard_exponential&quot;&gt; &lt;code&gt;standard_exponential&lt;/code&gt; &lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="a76b8a339223d559651cacde3723ee6065b8680a" translate="yes" xml:space="preserve">
          <source>Standard FFTs</source>
          <target state="translated">Стандартные БПФ</target>
        </trans-unit>
        <trans-unit id="8a50b57204e2e599132c00b62a1be1df8baa7ef4" translate="yes" xml:space="preserve">
          <source>Standard Gammas (&lt;a href=&quot;generated/numpy.random.generator.standard_gamma#numpy.random.Generator.standard_gamma&quot;&gt;&lt;code&gt;standard_gamma&lt;/code&gt;&lt;/a&gt;)</source>
          <target state="translated">Стандартная гамма ( &lt;a href=&quot;generated/numpy.random.generator.standard_gamma#numpy.random.Generator.standard_gamma&quot;&gt; &lt;code&gt;standard_gamma&lt;/code&gt; &lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="f24592e2f6f33fdf5fc1ae7710b26e85d05408ff" translate="yes" xml:space="preserve">
          <source>Standard acronyms to start the commit message with are:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6acbc6354e507f6042f5f9e2e8ed73fc0f0df274" translate="yes" xml:space="preserve">
          <source>Standard array subclasses</source>
          <target state="translated">Стандартные массивы подклассов</target>
        </trans-unit>
        <trans-unit id="cc94a4125e37461a7eb45a58071de9b78020fdd7" translate="yes" xml:space="preserve">
          <source>Standard container class</source>
          <target state="translated">Стандартный класс контейнера</target>
        </trans-unit>
        <trans-unit id="d97a83beb388d3e9a736d669dd24314ad1c4c05d" translate="yes" xml:space="preserve">
          <source>Standard container-class for easy multiple-inheritance.</source>
          <target state="translated">Стандартный контейнерный класс для легкого многократного наследования.</target>
        </trans-unit>
        <trans-unit id="fd746f492ad659d3f7460598edb734faace83b3c" translate="yes" xml:space="preserve">
          <source>Standard deviation</source>
          <target state="translated">среднеквадратическое отклонение</target>
        </trans-unit>
        <trans-unit id="abfc13a248e3a8f054556e98e30f2c835c7640af" translate="yes" xml:space="preserve">
          <source>Standard deviation (spread or &amp;ldquo;width&amp;rdquo;) of the distribution. Must be non-negative.</source>
          <target state="translated">Стандартное отклонение (разброс или &amp;laquo;ширина&amp;raquo;) распределения. Должен быть неотрицательным.</target>
        </trans-unit>
        <trans-unit id="353ecc8b9a821fe897c9828f33c52edee66e1903" translate="yes" xml:space="preserve">
          <source>Standard deviation of the underlying normal distribution. Must be non-negative. Default is 1.</source>
          <target state="translated">Стандартное отклонение основного нормального распределения.Должно быть неотрицательным.По умолчанию 1.</target>
        </trans-unit>
        <trans-unit id="23af397f01a5349c3364864801bdaded9c9fd69b" translate="yes" xml:space="preserve">
          <source>Standard division.</source>
          <target state="translated">Стандартное деление.</target>
        </trans-unit>
        <trans-unit id="41e65f8d183f4a9b208031a1e27c9fa561f1fc26" translate="yes" xml:space="preserve">
          <source>Standard iterator method, returns the index tuple and array value.</source>
          <target state="translated">Стандартный метод итератора,возвращает значение индекса кортежа и массива.</target>
        </trans-unit>
        <trans-unit id="5dc1c8c87cf79f5d6e41fc7b3d5b58a53840de0c" translate="yes" xml:space="preserve">
          <source>Standard iterator method, updates the index and returns the index tuple.</source>
          <target state="translated">Стандартный метод итератора,обновляет индекс и возвращает кортеж индекса.</target>
        </trans-unit>
        <trans-unit id="705c64e14cad8de0cc699306d0ca12c91eb54644" translate="yes" xml:space="preserve">
          <source>Standards for behaviour in the NumPy community are detailed in the Code of Conduct above. Participants in our community should uphold these standards in all their interactions and help others to do so as well (see next section).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dfc6bedfe760398884b530bf566a3b19e904ba58" translate="yes" xml:space="preserve">
          <source>Start a new &lt;em&gt;feature branch&lt;/em&gt; for each set of edits that you do. See &lt;a href=&quot;#making-a-new-feature-branch&quot;&gt;below&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e86c7fa9ebee31bc3e748ec98755eaa91eec7ff" translate="yes" xml:space="preserve">
          <source>Start and stop arrays for &lt;code&gt;linspace&lt;/code&gt;, &lt;code&gt;logspace&lt;/code&gt; and &lt;code&gt;geomspace&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3dd4f400b2542c4291d804ded14e6f7d8e21e239" translate="yes" xml:space="preserve">
          <source>Start here for an overview of NumPy features and syntax</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df808e9a53d2f9ad1713cebd06d023de29058b1f" translate="yes" xml:space="preserve">
          <source>Start of interval. The interval includes this value. The default start value is 0.</source>
          <target state="translated">Начало интервала.Интервал включает в себя это значение.Начальное значение по умолчанию равно 0.</target>
        </trans-unit>
        <trans-unit id="e3d56ccfa43387f906331b5afa2c49c8c391ba34" translate="yes" xml:space="preserve">
          <source>Start reading buffer (&lt;code&gt;buf&lt;/code&gt;) from this offset onwards.</source>
          <target state="translated">Начните чтение буфера ( &lt;code&gt;buf&lt;/code&gt; ) начиная с этого смещения.</target>
        </trans-unit>
        <trans-unit id="8a8f60afc4e5d9508e376d3a267b217a51489d68" translate="yes" xml:space="preserve">
          <source>Start reading the buffer from this offset (in bytes); default: 0.</source>
          <target state="translated">Начать чтение буфера с этого смещения (в байтах);по умолчанию:0.</target>
        </trans-unit>
        <trans-unit id="ddcac8bcdcee9d908ef620776b7aaacfebecb3f8" translate="yes" xml:space="preserve">
          <source>Start search at this level.</source>
          <target state="translated">Начните поиск на этом уровне.</target>
        </trans-unit>
        <trans-unit id="1b68451d2955d61b15e001c6fdcdc0d7038975d3" translate="yes" xml:space="preserve">
          <source>Starting from numpy 1.3.0, we are working on separating the pure C, &amp;ldquo;computational&amp;rdquo; code from the python dependent code. The goal is twofolds: making the code cleaner, and enabling code reuse by other extensions outside numpy (scipy, etc&amp;hellip;).</source>
          <target state="translated">Начиная с numpy 1.3.0, мы работаем над отделением &amp;laquo;вычислительного&amp;raquo; кода на чистом C от кода, зависящего от Python. Задача двоякая: сделать код чище и разрешить повторное использование кода другими расширениями за пределами numpy (scipy и т. Д.).</target>
        </trans-unit>
        <trans-unit id="190bfe8a8e41d4d3adc0d8967b2fb6cda62c785e" translate="yes" xml:space="preserve">
          <source>Starting guess for solving the rate of interest, default 0.1</source>
          <target state="translated">Начальная догадка для решения процентной ставки,по умолчанию 0.1</target>
        </trans-unit>
        <trans-unit id="1998183b3f42c5d604f45eee6e025b0b95e779c9" translate="yes" xml:space="preserve">
          <source>Starting in NumPy 1.7, there are core array data types which natively support datetime functionality. The data type is called &amp;ldquo;datetime64&amp;rdquo;, so named because &amp;ldquo;datetime&amp;rdquo; is already taken by the datetime library included in Python.</source>
          <target state="translated">Начиная с NumPy 1.7, существуют типы данных массива ядра, которые изначально поддерживают функциональность datetime. Тип данных называется &amp;laquo;datetime64&amp;raquo;, потому что &amp;laquo;datetime&amp;raquo; уже используется библиотекой datetime, включенной в Python.</target>
        </trans-unit>
        <trans-unit id="e4430717cba93d1575e5d9028fa5b9735d7a5640" translate="yes" xml:space="preserve">
          <source>Starting in NumPy 1.9 it returns a read-only view on the original array. Attempting to write to the resulting array will produce an error.</source>
          <target state="translated">Начиная с NumPy 1.9,он возвращает вид только для чтения на исходном массиве.Попытка записи в результирующий массив приведет к ошибке.</target>
        </trans-unit>
        <trans-unit id="03579e07c4a86e15aa2daa8e0ee5d8b2de28c77b" translate="yes" xml:space="preserve">
          <source>Starting in NumPy 1.9, promote_types function now returns a valid string length when given an integer or float dtype as one argument and a string dtype as another argument. Previously it always returned the input string dtype, even if it wasn&amp;rsquo;t long enough to store the max integer/float value converted to a string.</source>
          <target state="translated">Начиная с NumPy 1.9, функция Promo_types теперь возвращает допустимую длину строки, если ей задано целое число или тип dtype с плавающей запятой в качестве одного аргумента и строку dtype в качестве другого аргумента. Раньше он всегда возвращал входную строку dtype, даже если ее было недостаточно для хранения максимального целочисленного / плавающего значения, преобразованного в строку.</target>
        </trans-unit>
        <trans-unit id="48acaf98f98fb538de8401c0548aec9b9591fd70" translate="yes" xml:space="preserve">
          <source>Starting value for the sum. See &lt;a href=&quot;numpy.ufunc.reduce#numpy.ufunc.reduce&quot;&gt;&lt;code&gt;reduce&lt;/code&gt;&lt;/a&gt; for details.</source>
          <target state="translated">Начальное значение суммы. Подробнее см. &lt;a href=&quot;numpy.ufunc.reduce#numpy.ufunc.reduce&quot;&gt; &lt;code&gt;reduce&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5b2aae9c414bf14230f85547c67e7be26bffec39" translate="yes" xml:space="preserve">
          <source>Starting with this array:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a72502067518684f9deeec70cf119fd26326cd33" translate="yes" xml:space="preserve">
          <source>State</source>
          <target state="translated">State</target>
        </trans-unit>
        <trans-unit id="5653cebc057d4791ce07031ad9286e729de6d691" translate="yes" xml:space="preserve">
          <source>Statements</source>
          <target state="translated">Statements</target>
        </trans-unit>
        <trans-unit id="2086b21f8f49274138c38d476bee317a84a8aecc" translate="yes" xml:space="preserve">
          <source>Statistics</source>
          <target state="translated">Statistics</target>
        </trans-unit>
        <trans-unit id="7d6d3c7e587c7e68d91b665ed9a95bf9852d4a61" translate="yes" xml:space="preserve">
          <source>Steering Council</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="33ead70d43f6e06f674323c3d94bcc353904043d" translate="yes" xml:space="preserve">
          <source>Steering council</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64897d13af61fe94427b3180ce50b9b970318112" translate="yes" xml:space="preserve">
          <source>Stefan van der Walt</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa99ded051e65cfde097e3a6929d1b68ade9d957" translate="yes" xml:space="preserve">
          <source>Step-by-Step Directions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b0ef44a7ef3024cbe8a08b7dc9dc3bf5ebcd97a8" translate="yes" xml:space="preserve">
          <source>Stephan Hoyer</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="55fdc4e46b10f8815926e76cd96fd99504aad94e" translate="yes" xml:space="preserve">
          <source>Store compressed data to disk, and load it again:</source>
          <target state="translated">Сохраните сжатые данные на диск и загрузите их снова:</target>
        </trans-unit>
        <trans-unit id="c40b4ecf74fcdef0fac2e2b3e7ed1b00b25b3fa6" translate="yes" xml:space="preserve">
          <source>Store data to disk, and load it again:</source>
          <target state="translated">Храните данные на диске и загружайте их снова:</target>
        </trans-unit>
        <trans-unit id="e1c52dc3262f206eabc8e2236b28e7c92720ec86" translate="yes" xml:space="preserve">
          <source>Stores all of the necessary information to reconstruct the array including shape and dtype on a machine of a different architecture. Both little-endian and big-endian arrays are supported, and a file with little-endian numbers will yield a little-endian array on any machine reading the file. The types are described in terms of their actual sizes. For example, if a machine with a 64-bit C &amp;ldquo;long int&amp;rdquo; writes out an array with &amp;ldquo;long ints&amp;rdquo;, a reading machine with 32-bit C &amp;ldquo;long ints&amp;rdquo; will yield an array with 64-bit integers.</source>
          <target state="translated">Хранит всю необходимую информацию для восстановления массива, включая форму и dtype, на машине с другой архитектурой. Поддерживаются массивы как с прямым порядком, так и с прямым порядком байтов, а файл с прямым порядком байтов будет давать массив с прямым порядком байтов на любой машине, читающей файл. Типы описаны в соответствии с их действительными размерами. Например, если машина с 64-битным C &amp;laquo;long int&amp;raquo; записывает массив с &amp;laquo;длинными целыми числами&amp;raquo;, то читающая машина с 32-битным C &amp;laquo;long int&amp;raquo; выдаст массив с 64-битными целыми числами.</target>
        </trans-unit>
        <trans-unit id="4be1432cfaeaa9150a93183cf4c2899fcef7c724" translate="yes" xml:space="preserve">
          <source>Stores object arrays, i.e. arrays containing elements that are arbitrary Python objects. Files with object arrays are not to be mmapable, but can be read and written to disk.</source>
          <target state="translated">Хранит массивы объектов,т.е.массивы,содержащие элементы,которые являются произвольными объектами Python.Файлы с массивами объектов не должны быть отображены на карте,но могут быть прочитаны и записаны на диск.</target>
        </trans-unit>
        <trans-unit id="f27167d2cff299e4b6bdced9e8ba574539ece3ec" translate="yes" xml:space="preserve">
          <source>Strided Loop</source>
          <target state="translated">Петля с перечеркнутым контуром</target>
        </trans-unit>
        <trans-unit id="0229721b8100825a2747d58dc18cba748992b615" translate="yes" xml:space="preserve">
          <source>Strided copy code: Here, &amp;ldquo;uint alignment&amp;rdquo; is used instead. If the itemsize of an array is equal to 1, 2, 4, 8 or 16 bytes and the array is uint aligned then instead numpy will do &lt;code&gt;*(uintN*)dst) = *(uintN*)src)&lt;/code&gt; for appropriate N. Otherwise numpy copies by doing &lt;code&gt;memcpy(dst, src, N)&lt;/code&gt;.</source>
          <target state="translated">Код копии с полосами: здесь вместо этого используется &amp;laquo;выравнивание по uint&amp;raquo;. Если размер элемента массива равен 1, 2, 4, 8 или 16 байтам и массив выровнен по uint, тогда вместо этого numpy выполнит &lt;code&gt;*(uintN*)dst) = *(uintN*)src)&lt;/code&gt; для соответствующего N. В противном случае numpy копирует, выполнив &lt;code&gt;memcpy(dst, src, N)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f1c72d03ba013d5a43f8687bb5c241e852fd854a" translate="yes" xml:space="preserve">
          <source>Strides are computed automatically from an array&amp;rsquo;s dtype and shape, but can be directly specified using &lt;a href=&quot;reference/generated/numpy.lib.stride_tricks.as_strided&quot;&gt;as_strided.&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="416989873d1bb367de9329586677a513ca98acbb" translate="yes" xml:space="preserve">
          <source>Strides for the array (see &lt;a href=&quot;numpy.ndarray.strides#numpy.ndarray.strides&quot;&gt;&lt;code&gt;ndarray.strides&lt;/code&gt;&lt;/a&gt; for full description). Default is None.</source>
          <target state="translated">Шаги для массива ( полное описание см. В &lt;a href=&quot;numpy.ndarray.strides#numpy.ndarray.strides&quot;&gt; &lt;code&gt;ndarray.strides&lt;/code&gt; &lt;/a&gt; ). По умолчанию нет.</target>
        </trans-unit>
        <trans-unit id="abe83ed756895533bb0aacd0ff6c133f19d2f819" translate="yes" xml:space="preserve">
          <source>Strides for the array (see &lt;code&gt;ndarray.strides&lt;/code&gt; for full description). Default is None.</source>
          <target state="translated">Шаги для массива ( полное описание см. В &lt;code&gt;ndarray.strides&lt;/code&gt; ). По умолчанию нет.</target>
        </trans-unit>
        <trans-unit id="715d0f58588cad2551c57b871fab2907378f7743" translate="yes" xml:space="preserve">
          <source>Strides of data in memory.</source>
          <target state="translated">Шаги данных в памяти.</target>
        </trans-unit>
        <trans-unit id="4afc193de85ea729f32e1a7419493e9d11ac22a1" translate="yes" xml:space="preserve">
          <source>String (fixed-length sequence of char)</source>
          <target state="translated">Строка (последовательность символов фиксированной длины)</target>
        </trans-unit>
        <trans-unit id="f12af9aa3dd629be8a9ae33b8570944039c84f2e" translate="yes" xml:space="preserve">
          <source>String Parsing</source>
          <target state="translated">Разбор струн</target>
        </trans-unit>
        <trans-unit id="50f87962b3ace37596528a4245b60309cd75dbef" translate="yes" xml:space="preserve">
          <source>String appended to the names of the fields of r1 that are present in r2 but absent of the key.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="db01bd7e0ba81f6c4e00a0e50e0f3454439e8ce9" translate="yes" xml:space="preserve">
          <source>String appended to the names of the fields of r2 that are present in r1 but absent of the key.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e9197f99b1939b8ff77cd228aa2b591342615e8" translate="yes" xml:space="preserve">
          <source>String arguments</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34123bf351844b619c4dbfc6727ace35b50b4db7" translate="yes" xml:space="preserve">
          <source>String containing words to look for.</source>
          <target state="translated">Строка,содержащая слова,которые нужно искать.</target>
        </trans-unit>
        <trans-unit id="4df4e94946ef158e4c1e5b716aaee91f272b4a7e" translate="yes" xml:space="preserve">
          <source>String formatting</source>
          <target state="translated">Строковое форматирование</target>
        </trans-unit>
        <trans-unit id="92531b336e4e7bb6a1d7d30a01f8111947fec115" translate="yes" xml:space="preserve">
          <source>String information</source>
          <target state="translated">Информация о строке</target>
        </trans-unit>
        <trans-unit id="c2b35fa4d37ee8a6b4bd38cea3798cc9fbf4cba7" translate="yes" xml:space="preserve">
          <source>String integers specify the axis to concatenate along or the minimum number of dimensions to force entries into.</source>
          <target state="translated">Целые числа строк указывают ось,на которую следует наложить конкатенцию,или минимальное количество размеров для принудительных записей.</target>
        </trans-unit>
        <trans-unit id="f501c85c352da3ec100086db122d9f22d122b32e" translate="yes" xml:space="preserve">
          <source>String of length &lt;code&gt;length&lt;/code&gt;.</source>
          <target state="translated">Строка длины &lt;code&gt;length&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="766f45c1227c8c7d13e31b3c8218c7c441dc99b1" translate="yes" xml:space="preserve">
          <source>String operations</source>
          <target state="translated">Струнные операции</target>
        </trans-unit>
        <trans-unit id="b92216b3243250ff57b76e23d2f013b608ec0972" translate="yes" xml:space="preserve">
          <source>String or character separating columns.</source>
          <target state="translated">Столбцы,разделяющие строки или символы.</target>
        </trans-unit>
        <trans-unit id="791d1bdb2ea8c1e1e2ac650ffdc82b6e091407c9" translate="yes" xml:space="preserve">
          <source>String or character separating lines.</source>
          <target state="translated">Строки или строки,разделяющие символы.</target>
        </trans-unit>
        <trans-unit id="5bf0b490a78803009321c9fbedd01bde002ba5bc" translate="yes" xml:space="preserve">
          <source>String or sequence of strings corresponding to the names of the fields to drop.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3963028df99dc7715d5baee7dd3364c748e67766" translate="yes" xml:space="preserve">
          <source>String or sequence of strings corresponding to the names of the new fields.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b2c574a7189a987a1b45d751ffbabcb3c43118c9" translate="yes" xml:space="preserve">
          <source>String representation of &lt;a href=&quot;../arrays.scalars#numpy.number&quot;&gt;&lt;code&gt;number&lt;/code&gt;&lt;/a&gt; in &lt;code&gt;base&lt;/code&gt; system.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="070445e0a7bd458bdad35ce8dcb2d1d0173ff69e" translate="yes" xml:space="preserve">
          <source>String representation of &lt;code&gt;number&lt;/code&gt; in &lt;code&gt;base&lt;/code&gt; system.</source>
          <target state="translated">Строковое представление &lt;code&gt;number&lt;/code&gt; в &lt;code&gt;base&lt;/code&gt; системе.</target>
        </trans-unit>
        <trans-unit id="2e31e8b091806f3d1f281cc4ba782be9fda82868" translate="yes" xml:space="preserve">
          <source>String representation of floating point infinity (default inf).</source>
          <target state="translated">Строковое представление бесконечности с плавающей точкой (inf по умолчанию).</target>
        </trans-unit>
        <trans-unit id="01373c57fb8fe982545c8617e4790c9bba32d3bd" translate="yes" xml:space="preserve">
          <source>String representation of floating point not-a-number (default nan).</source>
          <target state="translated">Строковое представление числа с плавающей точкой не-а (по умолчанию nan).</target>
        </trans-unit>
        <trans-unit id="9f3842d201b21eb0e7888c9c3d9a2c881516b8c4" translate="yes" xml:space="preserve">
          <source>String representation of the array.</source>
          <target state="translated">Строковое представление массива.</target>
        </trans-unit>
        <trans-unit id="4db97d521f52ac6d93080543eb6b74577ba23cc3" translate="yes" xml:space="preserve">
          <source>String representations:</source>
          <target state="translated">Строковые представления:</target>
        </trans-unit>
        <trans-unit id="e0d061a82ce8af858bef95987cfb2e899639d475" translate="yes" xml:space="preserve">
          <source>String that will be prepended to the &lt;code&gt;header&lt;/code&gt; and &lt;code&gt;footer&lt;/code&gt; strings, to mark them as comments. Default: &amp;lsquo;# &amp;lsquo;, as expected by e.g. &lt;code&gt;numpy.loadtxt&lt;/code&gt;.</source>
          <target state="translated">Строка, которая будет добавлена ​​к строкам &lt;code&gt;header&lt;/code&gt; и &lt;code&gt;footer&lt;/code&gt; , чтобы пометить их как комментарии. По умолчанию: '#', как ожидается, например, &lt;code&gt;numpy.loadtxt&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="29161ee7a7a15a1abaf0f1612beb0eae4baa01d7" translate="yes" xml:space="preserve">
          <source>String that will be written at the beginning of the file.</source>
          <target state="translated">Строка,которая будет записана в начале файла.</target>
        </trans-unit>
        <trans-unit id="5c5d64e1c727d0403596e9c5ea3308951b6f9d69" translate="yes" xml:space="preserve">
          <source>String that will be written at the end of the file.</source>
          <target state="translated">Строка,которая будет записана в конце файла.</target>
        </trans-unit>
        <trans-unit id="65875ffed7d9c75f6fe284ddd93f194bd7eecd53" translate="yes" xml:space="preserve">
          <source>String used in lieu of missing data when a masked array is printed. By default, this string is &lt;code&gt;'--'&lt;/code&gt;.</source>
          <target state="translated">Строка, используемая вместо отсутствующих данных при печати замаскированного массива. По умолчанию это строка &lt;code&gt;'--'&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e619565781aeac87df5988755d8308bf2c9d2598" translate="yes" xml:space="preserve">
          <source>String with comma-separated fields</source>
          <target state="translated">Строка с полями,разделенными запятыми</target>
        </trans-unit>
        <trans-unit id="70f2192ce102bd881643cbec0959f90e05d94515" translate="yes" xml:space="preserve">
          <source>Strings are also a scalar type:</source>
          <target state="translated">Строки также являются скалярным типом:</target>
        </trans-unit>
        <trans-unit id="025562ddbed3dad7a75bf305224aa0613cc95adf" translate="yes" xml:space="preserve">
          <source>Structural indexing tools</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e3ede8ae87a5a729acffafa15db76210d17aa723" translate="yes" xml:space="preserve">
          <source>Structure Comparison</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c475f22df4d51f1c694f4e8b82c1dd74e7d4395b" translate="yes" xml:space="preserve">
          <source>Structured &lt;a href=&quot;#numpy.void&quot;&gt;&lt;code&gt;void&lt;/code&gt;&lt;/a&gt; scalars can only be constructed via extraction from &lt;a href=&quot;../user/basics.rec#structured-arrays&quot;&gt;Structured arrays&lt;/a&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee01ace9a33011b4e2e528c088a784d76eaefcf9" translate="yes" xml:space="preserve">
          <source>Structured &lt;code&gt;dtype&lt;/code&gt; objects can be indexed with multiple fields names</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1520da6d2d936a8bd0f22ba817625147b591a57d" translate="yes" xml:space="preserve">
          <source>Structured Datatype Creation</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f59e528dc3bc2a58ccace788dd71fad8e33ad21" translate="yes" xml:space="preserve">
          <source>Structured Datatypes</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7896426a8d21b91891b59c18e2d68b7b2a456f68" translate="yes" xml:space="preserve">
          <source>Structured array for which to apply func.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9017b7fa0fc7c65db95140441edbe12b0b3b19e5" translate="yes" xml:space="preserve">
          <source>Structured array or dtype to convert. Cannot contain object datatype.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c5690b1975e9db6337f5e8803f19ce3e684e4c7f" translate="yes" xml:space="preserve">
          <source>Structured array with fewer dimensions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="100bd7609a857d45a4a47e5a45ddd93a22acfb34" translate="yes" xml:space="preserve">
          <source>Structured arrays</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6bec79a6913cf5ec32ba9f585d2c682833361c77" translate="yes" xml:space="preserve">
          <source>Structured arrays are ndarrays whose datatype is a composition of simpler datatypes organized as a sequence of named &lt;a href=&quot;../glossary#term-field&quot;&gt;fields&lt;/a&gt;. For example,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="abee4933ed6df48a826b4ec24a053bf896cc2409" translate="yes" xml:space="preserve">
          <source>Structured arrays are sorted lexically by &lt;code&gt;argsort&lt;/code&gt;:</source>
          <target state="translated">Структурированные массивы лексически сортируются по &lt;code&gt;argsort&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="5159a7dd665ced2e100370992bcf1539f3126846" translate="yes" xml:space="preserve">
          <source>Structured arrays can also be assigned to unstructured arrays, but only if the structured datatype has just a single field:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f67ef4d80561aaaf60344e6fb29a5ab9f31295d6" translate="yes" xml:space="preserve">
          <source>Structured arrays indexed with non-existent fields raise &lt;code&gt;KeyError&lt;/code&gt; not &lt;code&gt;ValueError&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b043e88113de27795d789deafd7320abb4b7fdb" translate="yes" xml:space="preserve">
          <source>Structured arrays.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3afe855ad262a7516ddbebc2077f0e2c93c19240" translate="yes" xml:space="preserve">
          <source>Structured data types are formed by creating a data type whose &lt;a href=&quot;../glossary#term-field&quot;&gt;field&lt;/a&gt; contain other data types. Each field has a name by which it can be &lt;a href=&quot;arrays.indexing#arrays-indexing-fields&quot;&gt;accessed&lt;/a&gt;. The parent data type should be of sufficient size to contain all its fields; the parent is nearly always based on the &lt;a href=&quot;arrays.scalars#numpy.void&quot;&gt;&lt;code&gt;void&lt;/code&gt;&lt;/a&gt; type which allows an arbitrary item size. Structured data types may also contain nested structured sub-array data types in their fields.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="83f9bc65f5fce31cd776de3d718987b80efd194a" translate="yes" xml:space="preserve">
          <source>Structured data types are formed by creating a data type whose &lt;a href=&quot;../glossary#term-field&quot;&gt;field&lt;/a&gt; contain other data types. Each field has a name by which it can be &lt;a href=&quot;arrays.indexing#arrays-indexing-fields&quot;&gt;accessed&lt;/a&gt;. The parent data type should be of sufficient size to contain all its fields; the parent is nearly always based on the &lt;code&gt;void&lt;/code&gt; type which allows an arbitrary item size. Structured data types may also contain nested structured sub-array data types in their fields.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f15140621e0cd4e0f0fe72960c228d9f03950ae6" translate="yes" xml:space="preserve">
          <source>Structured data types are formed by creating a data type whose &lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/glossary.html#term-field&quot;&gt;field&lt;/a&gt; contain other data types. Each field has a name by which it can be &lt;a href=&quot;arrays.indexing#arrays-indexing-fields&quot;&gt;accessed&lt;/a&gt;. The parent data type should be of sufficient size to contain all its fields; the parent is nearly always based on the &lt;code&gt;void&lt;/code&gt; type which allows an arbitrary item size. Structured data types may also contain nested structured sub-array data types in their fields.</source>
          <target state="translated">Структурированные типы данных формируются путем создания типа данных, &lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/glossary.html#term-field&quot;&gt;поле&lt;/a&gt; которого содержит другие типы данных. У каждого поля есть имя, по которому к нему можно получить &lt;a href=&quot;arrays.indexing#arrays-indexing-fields&quot;&gt;доступ&lt;/a&gt; . Родительский тип данных должен быть достаточного размера, чтобы содержать все его поля; родительский элемент почти всегда основан на типе &lt;code&gt;void&lt;/code&gt; , который допускает произвольный размер элемента. Структурированные типы данных могут также содержать в своих полях вложенные типы данных структурированного подмассива.</target>
        </trans-unit>
        <trans-unit id="1db5d72ed0ef809181a6b4792660521a677761d3" translate="yes" xml:space="preserve">
          <source>Structured datatypes are designed to be able to mimic &amp;lsquo;structs&amp;rsquo; in the C language, and share a similar memory layout. They are meant for interfacing with C code and for low-level manipulation of structured buffers, for example for interpreting binary blobs. For these purposes they support specialized features such as subarrays, nested datatypes, and unions, and allow control over the memory layout of the structure.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6430d9960863ffd1da1c228ca6625d7a868c86b1" translate="yes" xml:space="preserve">
          <source>Structured datatypes are implemented in numpy to have base type &lt;a href=&quot;../reference/arrays.scalars#numpy.void&quot;&gt;&lt;code&gt;numpy.void&lt;/code&gt;&lt;/a&gt; by default, but it is possible to interpret other numpy types as structured types using the &lt;code&gt;(base_dtype, dtype)&lt;/code&gt; form of dtype specification described in &lt;a href=&quot;../reference/arrays.dtypes#arrays-dtypes-constructing&quot;&gt;Data Type Objects&lt;/a&gt;. Here, &lt;code&gt;base_dtype&lt;/code&gt; is the desired underlying dtype, and fields and flags will be copied from &lt;code&gt;dtype&lt;/code&gt;. This dtype is similar to a &amp;lsquo;union&amp;rsquo; in C.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="35ae44b4e9475697a4a50339f6e2ae5fa9e282a4" translate="yes" xml:space="preserve">
          <source>Structured datatypes are implemented in numpy to have base type &lt;code&gt;numpy.void&lt;/code&gt; by default, but it is possible to interpret other numpy types as structured types using the &lt;code&gt;(base_dtype, dtype)&lt;/code&gt; form of dtype specification described in &lt;a href=&quot;../reference/arrays.dtypes#arrays-dtypes-constructing&quot;&gt;Data Type Objects&lt;/a&gt;. Here, &lt;code&gt;base_dtype&lt;/code&gt; is the desired underlying dtype, and fields and flags will be copied from &lt;code&gt;dtype&lt;/code&gt;. This dtype is similar to a &amp;lsquo;union&amp;rsquo; in C.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c5f3d86c3ad0938e801983471d9d88dc5223acd7" translate="yes" xml:space="preserve">
          <source>Structured datatypes may be created using the function &lt;a href=&quot;../reference/generated/numpy.dtype#numpy.dtype&quot;&gt;&lt;code&gt;numpy.dtype&lt;/code&gt;&lt;/a&gt;. There are 4 alternative forms of specification which vary in flexibility and conciseness. These are further documented in the &lt;a href=&quot;../reference/arrays.dtypes#arrays-dtypes-constructing&quot;&gt;Data Type Objects&lt;/a&gt; reference page, and in summary they are:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6624b07c38a844e59271b0a0c26ed454ac19dbe9" translate="yes" xml:space="preserve">
          <source>Structured type, one field name &amp;lsquo;f1&amp;rsquo;, containing int16:</source>
          <target state="translated">Структурированный тип, одно имя поля 'f1', содержащее int16:</target>
        </trans-unit>
        <trans-unit id="d2e117ca328d87720528f1cfaf8d8960167ffb11" translate="yes" xml:space="preserve">
          <source>Structured type, one field named &amp;lsquo;f1&amp;rsquo;, in itself containing a structured type with one field:</source>
          <target state="translated">Структурированный тип, одно поле с именем 'f1', само по себе содержит структурированный тип с одним полем:</target>
        </trans-unit>
        <trans-unit id="58f4a5191b04c275b13b1266e03ae0e69f92c2c1" translate="yes" xml:space="preserve">
          <source>Structured type, two fields: the first field contains an unsigned int, the second an int32:</source>
          <target state="translated">Структурный тип,два поля:первое поле содержит беззнаковый int,второе-int32:</target>
        </trans-unit>
        <trans-unit id="ca4456203ca66897ff0941bbafc31276906d7671" translate="yes" xml:space="preserve">
          <source>Structured view(s) of &lt;a href=&quot;numpy.nditer.operands#numpy.nditer.operands&quot;&gt;&lt;code&gt;operands&lt;/code&gt;&lt;/a&gt; in memory, matching the reordered and optimized iterator access pattern. Valid only before the iterator is closed.</source>
          <target state="translated">Структурированные представления &lt;a href=&quot;numpy.nditer.operands#numpy.nditer.operands&quot;&gt; &lt;code&gt;operands&lt;/code&gt; &lt;/a&gt; в памяти, соответствующие переупорядоченному и оптимизированному шаблону доступа итератора. Действует только до закрытия итератора.</target>
        </trans-unit>
        <trans-unit id="64b82b877494406e2f3a32e02b06a27f71eea3a4" translate="yes" xml:space="preserve">
          <source>Style Guide for C Code</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01d5cb7a8cd071c4380d4985485547b9c9160ad6" translate="yes" xml:space="preserve">
          <source>Style Guide for Python Code</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0404cfe2117190faccc065f3c4e76c4322b57e18" translate="yes" xml:space="preserve">
          <source>Stylistic Guidelines</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="803fd087e54001bfefdde2c389864825258535d4" translate="yes" xml:space="preserve">
          <source>Sub-arrays always have a C-contiguous memory layout.</source>
          <target state="translated">Подмассивы всегда имеют С-сопряженную схему памяти.</target>
        </trans-unit>
        <trans-unit id="b5f988ec613aba03f62b8fb5c8cfc27a7a1a6d0f" translate="yes" xml:space="preserve">
          <source>Sub-optimal &lt;a href=&quot;#numpy.einsum&quot;&gt;&lt;code&gt;einsum&lt;/code&gt;&lt;/a&gt; (due to repeated path calculation time): ~330ms</source>
          <target state="translated">Суб-оптимальное &lt;a href=&quot;#numpy.einsum&quot;&gt; &lt;code&gt;einsum&lt;/code&gt; &lt;/a&gt; (из - за неоднократное время расчета пути): ~ 330ms</target>
        </trans-unit>
        <trans-unit id="55af143d1bbc195dac68e528a5caca790b79468f" translate="yes" xml:space="preserve">
          <source>Subclasses of &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt; are preserved except for the &amp;lsquo;raw&amp;rsquo; mode. So if &lt;code&gt;a&lt;/code&gt; is of type &lt;a href=&quot;numpy.matrix#numpy.matrix&quot;&gt;&lt;code&gt;matrix&lt;/code&gt;&lt;/a&gt;, all the return values will be matrices too.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa0a23c0a00071a5375730590cb136590b810c95" translate="yes" xml:space="preserve">
          <source>Subclasses of &lt;code&gt;ndarray&lt;/code&gt; are preserved except for the &amp;lsquo;raw&amp;rsquo; mode. So if &lt;code&gt;a&lt;/code&gt; is of type &lt;code&gt;matrix&lt;/code&gt;, all the return values will be matrices too.</source>
          <target state="translated">Подклассы &lt;code&gt;ndarray&lt;/code&gt; сохраняются, за исключением &amp;laquo;сырого&amp;raquo; режима. Таким образом, если &lt;code&gt;a&lt;/code&gt; имеет тип &lt;code&gt;matrix&lt;/code&gt; , все возвращаемые значения также будут матрицами.</target>
        </trans-unit>
        <trans-unit id="a9ce918753c36dd7a183b105790cb0ccc1e3d737" translate="yes" xml:space="preserve">
          <source>Subclassing a &lt;code&gt;numpy.ndarray&lt;/code&gt; is possible but if your goal is to create an array with &lt;em&gt;modified&lt;/em&gt; behavior, as do dask arrays for distributed computation and cupy arrays for GPU-based computation, subclassing is discouraged. Instead, using numpy&amp;rsquo;s &lt;a href=&quot;../user/basics.dispatch#basics-dispatch&quot;&gt;dispatch mechanism&lt;/a&gt; is recommended.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d147ab8047bc6066411af552791a9504b59a189" translate="yes" xml:space="preserve">
          <source>Subclassing a &lt;code&gt;numpy.ndarray&lt;/code&gt; is possible but if your goal is to create an array with &lt;em&gt;modified&lt;/em&gt; behavior, as do dask arrays for distributed computation and cupy arrays for GPU-based computation, subclassing is discouraged. Instead, using numpy&amp;rsquo;s &lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/user/basics.dispatch.html#basics-dispatch&quot;&gt;dispatch mechanism&lt;/a&gt; is recommended.</source>
          <target state="translated">&lt;code&gt;numpy.ndarray&lt;/code&gt; подкласса numpy.ndarray возможно, но если ваша цель - создать массив с &lt;em&gt;измененным&lt;/em&gt; поведением, как это делают массивы dask для распределенных вычислений и массивы Cupy для вычислений на базе GPU, создание подклассов не рекомендуется. Вместо этого рекомендуется использовать &lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/user/basics.dispatch.html#basics-dispatch&quot;&gt;механизм отправки&lt;/a&gt; numpy .</target>
        </trans-unit>
        <trans-unit id="272f065bb249898427d153b9ddec706f4a4c8ea8" translate="yes" xml:space="preserve">
          <source>Subclassing and Downstream Compatibility</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cee47368b2544d06d66a7be14203632ad1161eec" translate="yes" xml:space="preserve">
          <source>Subclassing is preserved. This means that if, e.g., the data part of the masked array is a recarray, &lt;a href=&quot;#numpy.ma.MaskedArray.filled&quot;&gt;&lt;code&gt;filled&lt;/code&gt;&lt;/a&gt; returns a recarray:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="33bc88cf96b41fa0646c461894f505af99f67ac1" translate="yes" xml:space="preserve">
          <source>Subclassing is preserved. This means that if, e.g., the data part of the masked array is a recarray, &lt;a href=&quot;numpy.ma.filled#numpy.ma.filled&quot;&gt;&lt;code&gt;filled&lt;/code&gt;&lt;/a&gt; returns a recarray:</source>
          <target state="translated">Подклассы сохранены. Это означает , что если, например, часть данных из замаскированного массива является recarray, &lt;a href=&quot;numpy.ma.filled#numpy.ma.filled&quot;&gt; &lt;code&gt;filled&lt;/code&gt; &lt;/a&gt; возвращает recarray:</target>
        </trans-unit>
        <trans-unit id="dcd026d87f16ab5d865099378d38748e1049d4d8" translate="yes" xml:space="preserve">
          <source>Subclassing ndarray</source>
          <target state="translated">Подкласс ndarray</target>
        </trans-unit>
        <trans-unit id="b7c286e3d93f3ece394b3827e135e8a12233cdf1" translate="yes" xml:space="preserve">
          <source>Subclassing ndarray is complicated by the fact that new instances of ndarray classes can come about in three different ways. These are:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a44ddbc8fd0076edc9e53d1235eba11c7929dc0" translate="yes" xml:space="preserve">
          <source>Subclassing ndarray is relatively simple, but it has some complications compared to other Python objects. On this page we explain the machinery that allows you to subclass ndarray, and the implications for implementing a subclass.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="63f32464b42a864e77739b2bee513b261ea02191" translate="yes" xml:space="preserve">
          <source>Subcommittees</source>
          <target state="translated">Subcommittees</target>
        </trans-unit>
        <trans-unit id="d9952117e8cb53d0fd7ca6ba7d99ad537965d8c9" translate="yes" xml:space="preserve">
          <source>Subdivide &lt;code&gt;int16&lt;/code&gt; into 2 &lt;code&gt;int8&lt;/code&gt;&amp;rsquo;s, called x and y. 0 and 1 are the offsets in bytes:</source>
          <target state="translated">Разделить &lt;code&gt;int16&lt;/code&gt; в 2 &lt;code&gt;int8&lt;/code&gt; &amp;laquo;с, называемых х и у. 0 и 1 - смещения в байтах:</target>
        </trans-unit>
        <trans-unit id="7cd760711c541e202c788fb098af0b33b391721e" translate="yes" xml:space="preserve">
          <source>Subsequence with trailing zeros removed. If the resulting sequence would be empty, return the first element. The returned sequence may or may not be a view.</source>
          <target state="translated">Последующая с удалением следящих нулей.Если результирующая последовательность будет пустой,верните первый элемент.Возвращаемая последовательность может быть или не быть просмотром.</target>
        </trans-unit>
        <trans-unit id="97ff96af5de437e8628eccf16dfbbe360cbfcf72" translate="yes" xml:space="preserve">
          <source>Substantial portions of this document were adapted from the &lt;a href=&quot;https://github.com/jupyter/governance&quot;&gt;Jupyter/IPython project&amp;rsquo;s governance document&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c763109714f2536fc1c4a6c89fdf2646454177e1" translate="yes" xml:space="preserve">
          <source>Substantial portions of this document were adapted from the &lt;a href=&quot;https://github.com/jupyter/governance/blob/master/governance.md&quot;&gt;Jupyter/IPython project&amp;rsquo;s governance document&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="259ff26648e77d2b9a5ec16a4f186ec8e1c65753" translate="yes" xml:space="preserve">
          <source>Substitute a polynomial for x and expand the result. Here we substitute p in itself leading to a new polynomial of degree 4 after expansion. If the polynomials are regarded as functions this is composition of functions:</source>
          <target state="translated">Замените полиномию на х и увеличьте результат.Здесь мы заменяем р сам по себе,что приводит к появлению нового полинома 4-й степени после расширения.Если полиномы рассматриваются как функции,то это и есть состав функций:</target>
        </trans-unit>
        <trans-unit id="8d18e7a773fc8ec030ec151dbf7cd596c836697a" translate="yes" xml:space="preserve">
          <source>Substitution:</source>
          <target state="translated">Substitution:</target>
        </trans-unit>
        <trans-unit id="976370d3324e5eaaec19ed99a261ec090486b0fa" translate="yes" xml:space="preserve">
          <source>Subtract arguments, element-wise.</source>
          <target state="translated">Вычитайте аргументы,по элементам.</target>
        </trans-unit>
        <trans-unit id="8567fbb4d729f4cd5b7fbe5674c01c465635fa47" translate="yes" xml:space="preserve">
          <source>Subtract one Chebyshev series from another.</source>
          <target state="translated">Вычитайте одну чебышевскую серию из другой.</target>
        </trans-unit>
        <trans-unit id="a494f472ea255a2aaa4f1c8f52b90c62196690f5" translate="yes" xml:space="preserve">
          <source>Subtract one Hermite series from another.</source>
          <target state="translated">Вычитайте одну серию &quot;Эрмита&quot; из другой.</target>
        </trans-unit>
        <trans-unit id="60b31c93b32c6d82ec367e99b58e2a7fd1690435" translate="yes" xml:space="preserve">
          <source>Subtract one Laguerre series from another.</source>
          <target state="translated">Вычитайте одну серию Лагер из другой.</target>
        </trans-unit>
        <trans-unit id="09477810015d786e3a1ce0d9827bfd9d00039de6" translate="yes" xml:space="preserve">
          <source>Subtract one Legendre series from another.</source>
          <target state="translated">Вычитайте одну серию &quot;Легенды&quot; из другой.</target>
        </trans-unit>
        <trans-unit id="a2407a57a6647eba13b915586134c7e1d7534217" translate="yes" xml:space="preserve">
          <source>Subtract one polynomial from another.</source>
          <target state="translated">Вычитайте один полиноминал из другого.</target>
        </trans-unit>
        <trans-unit id="5de67be97d964e12a293477e154e8fa146741938" translate="yes" xml:space="preserve">
          <source>Subtract other from self in-place.</source>
          <target state="translated">Вычитайте другие из себя на месте.</target>
        </trans-unit>
        <trans-unit id="b3957443ea74659d4523c7bc9e466d304ba155cf" translate="yes" xml:space="preserve">
          <source>Subtract other from self, and return a new masked array.</source>
          <target state="translated">Извлеките другое из себя и верните новый замаскированный массив.</target>
        </trans-unit>
        <trans-unit id="6cf676697a4c117ec3074a618da8a2b0fca9cd14" translate="yes" xml:space="preserve">
          <source>Subtract self from other, and return a new masked array.</source>
          <target state="translated">Вычитайте себя из других и верните новый массив.</target>
        </trans-unit>
        <trans-unit id="77a74ccf7fd60ada9c57d2300edad576a2eb6285" translate="yes" xml:space="preserve">
          <source>Subtyping the ndarray in C</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d0b818b7784e48b243d98be89f763b62cb9fc7bd" translate="yes" xml:space="preserve">
          <source>Successfully tested on:</source>
          <target state="translated">Успешно протестирована:</target>
        </trans-unit>
        <trans-unit id="7f477dc5121884706ef8fed21e4d11c24e6db091" translate="yes" xml:space="preserve">
          <source>Sum across array propagating NaNs.</source>
          <target state="translated">Сумма по массиву,распространяющему NaN.</target>
        </trans-unit>
        <trans-unit id="b2cc82eaee79a7562889de3502bb827b013693aa" translate="yes" xml:space="preserve">
          <source>Sum along diagonals.</source>
          <target state="translated">Суммируй по диагоналям.</target>
        </trans-unit>
        <trans-unit id="b221abad8e52361732192c7acb9613f67b076ac3" translate="yes" xml:space="preserve">
          <source>Sum array elements.</source>
          <target state="translated">Суммируйте элементы массива.</target>
        </trans-unit>
        <trans-unit id="96c00e26cd369dd11b081a1035d4633225e7965d" translate="yes" xml:space="preserve">
          <source>Sum of array elements over a given axis.</source>
          <target state="translated">Сумма элементов массива по заданной оси.</target>
        </trans-unit>
        <trans-unit id="6302a8aa98d30db8a3e7186cb73eb9e4337d618b" translate="yes" xml:space="preserve">
          <source>Sum over an axis (requires explicit form):</source>
          <target state="translated">Сумма по оси (требует явной формы):</target>
        </trans-unit>
        <trans-unit id="1c979daf2b6e4cef98bd537ad236de258dbc0d5a" translate="yes" xml:space="preserve">
          <source>Sum over axes 0 and 2. The result has same number of dimensions as the original array:</source>
          <target state="translated">Сумма по осям 0 и 2.Результат имеет такое же количество размеров,что и исходный массив:</target>
        </trans-unit>
        <trans-unit id="1103f1f7acbd2c5b9349bcbddbb45121fae537eb" translate="yes" xml:space="preserve">
          <source>Sum products over arbitrary axes.</source>
          <target state="translated">Сумма продуктов по произвольным осям.</target>
        </trans-unit>
        <trans-unit id="12b71c3e0fe5f7c0b8d17cc03186e281412da4a8" translate="yes" xml:space="preserve">
          <source>Summary</source>
          <target state="translated">Summary</target>
        </trans-unit>
        <trans-unit id="bf661fd6213ae079ce34c2c9dd00db526c359e2b" translate="yes" xml:space="preserve">
          <source>Sums of residuals; squared Euclidean 2-norm for each column in &lt;code&gt;b - a*x&lt;/code&gt;. If the rank of &lt;code&gt;a&lt;/code&gt; is &amp;lt; N or M &amp;lt;= N, this is an empty array. If &lt;code&gt;b&lt;/code&gt; is 1-dimensional, this is a (1,) shape array. Otherwise the shape is (K,).</source>
          <target state="translated">Суммы остатков; квадрат евклидовой 2-нормы для каждого столбца в &lt;code&gt;b - a*x&lt;/code&gt; . Если ранг &lt;code&gt;a&lt;/code&gt; &amp;lt;N или M &amp;lt;= N, это пустой массив. Если &lt;code&gt;b&lt;/code&gt; одномерный, это массив формы (1,). В противном случае форма будет (K,).</target>
        </trans-unit>
        <trans-unit id="2f33a7a1cb4338af5c5245b28f2bd71c178caccc" translate="yes" xml:space="preserve">
          <source>Sums of squared residuals: Squared Euclidean 2-norm for each column in &lt;code&gt;b - a @ x&lt;/code&gt;. If the rank of &lt;code&gt;a&lt;/code&gt; is &amp;lt; N or M &amp;lt;= N, this is an empty array. If &lt;code&gt;b&lt;/code&gt; is 1-dimensional, this is a (1,) shape array. Otherwise the shape is (K,).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b6c71b95244ccde5ac8df906b9633b9278b04563" translate="yes" xml:space="preserve">
          <source>Sums, products, differences</source>
          <target state="translated">Суммы,продукты,различия</target>
        </trans-unit>
        <trans-unit id="56cedb0b6384ebe895f048d3113a97e19adce9ed" translate="yes" xml:space="preserve">
          <source>SunOS 5.9, Python 2.2, 2.3.2</source>
          <target state="translated">SunOS 5.9,Питон 2.2,2.3.2</target>
        </trans-unit>
        <trans-unit id="67fd60fec12a23f41f4967a1b913d9c8325a3d58" translate="yes" xml:space="preserve">
          <source>Superposes arrays fields by fields</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a1f3a3e0dca6bfb201866f4e02f7f0f252f0503d" translate="yes" xml:space="preserve">
          <source>Supplying additional compiler flags</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd465d5e53c115d109beacd89675429e7fe9e2eb" translate="yes" xml:space="preserve">
          <source>Support for 64-bit OpenBLAS</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="05979ff1799bf4b31c7aaaf6575b3a44600e6938" translate="yes" xml:space="preserve">
          <source>Support for &lt;code&gt;decimal.Decimal&lt;/code&gt; in &lt;code&gt;np.lib.financial&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94bf5963bbdc6b1a3677d96a194c63df08cc0ebe" translate="yes" xml:space="preserve">
          <source>Support for PGI flang compiler on Windows</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8dcbec54e843ff9113eeef63ba5ba94427429af2" translate="yes" xml:space="preserve">
          <source>Support for cross-platform builds for iOS</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d4312602ded392453d6506535641b2fe8fc3f434" translate="yes" xml:space="preserve">
          <source>Support for linear algebra on stacked arrays</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d1486bb007dde41a6cd27d40051180a9824cbf65" translate="yes" xml:space="preserve">
          <source>Support for median and percentile in nanfunctions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5732c875d678ed7bc376f8bdb01c865cd0e57b5f" translate="yes" xml:space="preserve">
          <source>Support for multiple insertions when &lt;code&gt;obj&lt;/code&gt; is a single scalar or a sequence with one element (similar to calling insert multiple times).</source>
          <target state="translated">Поддержка множественных вставок, когда &lt;code&gt;obj&lt;/code&gt; - это один скаляр или последовательность с одним элементом (аналогично вызову вставки несколько раз).</target>
        </trans-unit>
        <trans-unit id="4c2c6be525f6d9a610c57848f9ef0612672209f9" translate="yes" xml:space="preserve">
          <source>Support for reading lzma compressed text files in Python 3</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="57ebd340f9cd250715efd00bc82361318ecaf77c" translate="yes" xml:space="preserve">
          <source>Support for returning arrays of arbitrary dimensions in &lt;code&gt;apply_along_axis&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2d5e2188fd70bec3fdf433ddaeea9f504cb04b41" translate="yes" xml:space="preserve">
          <source>Support for the &amp;lsquo;@&amp;rsquo; operator in Python 3.5+</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="96793ccd7b743fcb4b68f47fc4a80f55eade2824" translate="yes" xml:space="preserve">
          <source>Support for the &lt;strong&gt;Yields&lt;/strong&gt; section was added in &lt;a href=&quot;https://github.com/numpy/numpydoc&quot;&gt;numpydoc&lt;/a&gt; version 0.6.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="729714232faf9c660ac35de89eac7db896893cb6" translate="yes" xml:space="preserve">
          <source>Support for tracemalloc in Python 3.6</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="08bf3021612bda0edd29ed3bce556141bfaab8f8" translate="yes" xml:space="preserve">
          <source>Support of object arrays in &lt;code&gt;matmul&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="738f921dd6d285f914885c453cfc677ad8fc0e6b" translate="yes" xml:space="preserve">
          <source>Support path-like objects for more functions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6d95257e0d6b5ee52701ed6e60955d7b5cf2355f" translate="yes" xml:space="preserve">
          <source>Supported BitGenerators</source>
          <target state="translated">Поддерживаемые битгенераторы</target>
        </trans-unit>
        <trans-unit id="35d1294934e4cc4b101779bccdbe627fdf3b5b49" translate="yes" xml:space="preserve">
          <source>Supported platforms and versions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="090678b79c24d0799aa7434df5ba4e013c0ea2ff" translate="yes" xml:space="preserve">
          <source>Supports Fortran-contiguous arrays directly.</source>
          <target state="translated">Поддерживает непосредственно сопрягаемые массивы Fortran.</target>
        </trans-unit>
        <trans-unit id="62c4a407a3644c899b58964ef70d8d5ea099dfdd" translate="yes" xml:space="preserve">
          <source>Supports full broadcasting of the inputs.</source>
          <target state="translated">Поддерживает полную трансляцию входов.</target>
        </trans-unit>
        <trans-unit id="12f46de9102cae348756a951378fba972f726b07" translate="yes" xml:space="preserve">
          <source>Supports rolling over multiple dimensions simultaneously.</source>
          <target state="translated">Поддерживает прокат по нескольким размерам одновременно.</target>
        </trans-unit>
        <trans-unit id="c531221221ae570c082e108201b731a1c902860f" translate="yes" xml:space="preserve">
          <source>Supports the method &lt;a href=&quot;generated/numpy.random.pcg64.advance#numpy.random.PCG64.advance&quot;&gt;&lt;code&gt;advance&lt;/code&gt;&lt;/a&gt; to advance the RNG an arbitrary number of steps. The state of the PCG-64 RNG is represented by 2 128-bit unsigned integers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d97b0cce7cf0a1a8ea78834b26b7eaa1e93207d9" translate="yes" xml:space="preserve">
          <source>Supports the method &lt;a href=&quot;generated/numpy.random.pcg64.pcg64.advance#numpy.random.pcg64.PCG64.advance&quot;&gt;&lt;code&gt;advance&lt;/code&gt;&lt;/a&gt; to advance the RNG an arbitrary number of steps. The state of the PCG-64 RNG is represented by 2 128-bit unsigned integers.</source>
          <target state="translated">Поддерживает &lt;a href=&quot;generated/numpy.random.pcg64.pcg64.advance#numpy.random.pcg64.PCG64.advance&quot;&gt; &lt;code&gt;advance&lt;/code&gt; &lt;/a&gt; метода для продвижения ГСЧ на произвольное количество шагов. Состояние ГСЧ PCG-64 представлено 2 128-битными целыми числами без знака.</target>
        </trans-unit>
        <trans-unit id="7316bd03b503c1032cc14acdf4020a574c762c3f" translate="yes" xml:space="preserve">
          <source>Suppose &lt;code&gt;x.shape&lt;/code&gt; is (10,20,30) and &lt;code&gt;ind&lt;/code&gt; is a (2,3,4)-shaped indexing &lt;a href=&quot;arrays.scalars#numpy.intp&quot;&gt;&lt;code&gt;intp&lt;/code&gt;&lt;/a&gt; array, then &lt;code&gt;result = x[...,ind,:]&lt;/code&gt; has shape (10,2,3,4,30) because the (20,)-shaped subspace has been replaced with a (2,3,4)-shaped broadcasted indexing subspace. If we let &lt;em&gt;i, j, k&lt;/em&gt; loop over the (2,3,4)-shaped subspace then &lt;code&gt;result[...,i,j,k,:] = x[...,ind[i,j,k],:]&lt;/code&gt;. This example produces the same result as &lt;a href=&quot;generated/numpy.ndarray.take#numpy.ndarray.take&quot;&gt;&lt;code&gt;x.take(ind, axis=-2)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34c5f00d14223115d609ab63804b8bf6dbd38059" translate="yes" xml:space="preserve">
          <source>Suppose &lt;code&gt;x.shape&lt;/code&gt; is (10,20,30) and &lt;code&gt;ind&lt;/code&gt; is a (2,3,4)-shaped indexing &lt;code&gt;intp&lt;/code&gt; array, then &lt;code&gt;result = x[...,ind,:]&lt;/code&gt; has shape (10,2,3,4,30) because the (20,)-shaped subspace has been replaced with a (2,3,4)-shaped broadcasted indexing subspace. If we let &lt;em&gt;i, j, k&lt;/em&gt; loop over the (2,3,4)-shaped subspace then &lt;code&gt;result[...,i,j,k,:] = x[...,ind[i,j,k],:]&lt;/code&gt;. This example produces the same result as &lt;a href=&quot;generated/numpy.ndarray.take#numpy.ndarray.take&quot;&gt;&lt;code&gt;x.take(ind, axis=-2)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Предположим, что &lt;code&gt;x.shape&lt;/code&gt; - это (10,20,30), а &lt;code&gt;ind&lt;/code&gt; - это (2,3,4) -образный индексирующий массив &lt;code&gt;intp&lt;/code&gt; , тогда &lt;code&gt;result = x[...,ind,:]&lt;/code&gt; имеет форму (10,2,3 , 4,30), потому что подпространство в форме (20,) было заменено подпространством широковещательной индексации в форме (2,3,4). Если мы позволим &lt;em&gt;i, j, k&lt;/em&gt; перебирать подпространство (2,3,4) -образной формы, то &lt;code&gt;result[...,i,j,k,:] = x[...,ind[i,j,k],:]&lt;/code&gt; . Этот пример дает тот же результат, что и &lt;a href=&quot;generated/numpy.ndarray.take#numpy.ndarray.take&quot;&gt; &lt;code&gt;x.take(ind, axis=-2)&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ab6e03b971eeb9906907892d695f98f70c00c465" translate="yes" xml:space="preserve">
          <source>Suppose I have two files coolmodule.c and coolhelper.c which need to be compiled and linked into a single extension module. Suppose coolmodule.c contains the required initcool module initialization function (with the import_array() function called). Then, coolmodule.c would have at the top:</source>
          <target state="translated">Предположим,у меня есть два файла coolmodule.c и coolhelper.c,которые нужно скомпилировать и связать в один модуль расширения.Предположим,что в coolmodule.c содержится необходимая функция инициализации модуля initcool (с вызовом функции import_array()).Затем,coolmodule.c будет иметь в верхней части:</target>
        </trans-unit>
        <trans-unit id="1a06be2cc716b778d6a1c32b124922e42d2cce52" translate="yes" xml:space="preserve">
          <source>Suppose now that we wish to print that same data, but with the missing values replaced by the average value.</source>
          <target state="translated">Предположим,теперь мы хотим распечатать те же самые данные,но с пропущенными значениями,замененными на среднее значение.</target>
        </trans-unit>
        <trans-unit id="c30e0906e4415225d057040ed0740bd62f0ab08e" translate="yes" xml:space="preserve">
          <source>Suppose that the commit history looks like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5dca6dc181cc53601add013bc2ada72709458943" translate="yes" xml:space="preserve">
          <source>Suppose the first operand is one dimensional and the second operand is two dimensional. The iterator will have three dimensions, so &lt;code&gt;op_axes&lt;/code&gt; will have two 3-element lists. The first list picks out the one axis of the first operand, and is -1 for the rest of the iterator axes, with a final result of [0, -1, -1]. The second list picks out the two axes of the second operand, but shouldn&amp;rsquo;t overlap with the axes picked out in the first operand. Its list is [-1, 0, 1]. The output operand maps onto the iterator axes in the standard manner, so we can provide None instead of constructing another list.</source>
          <target state="translated">Предположим, что первый операнд одномерный, а второй - двумерный. Итератор будет иметь три измерения, поэтому &lt;code&gt;op_axes&lt;/code&gt; будет иметь два списка из трех элементов. Первый список выбирает одну ось первого операнда и равен -1 для остальных осей итератора, с окончательным результатом [0, -1, -1]. Второй список выбирает две оси второго операнда, но не должен перекрываться с осями, выбранными в первом операнде. Его список [-1, 0, 1]. Выходной операнд отображается на оси итератора стандартным образом, поэтому мы можем предоставить None вместо создания другого списка.</target>
        </trans-unit>
        <trans-unit id="94712928e34f9dfa7af3b9cd6b14ec949c85f00d" translate="yes" xml:space="preserve">
          <source>Suppose you have a NumPy module &lt;code&gt;numpy/xxx/yyy.py&lt;/code&gt; containing a function &lt;code&gt;zzz()&lt;/code&gt;. To test this function you would create a test module called &lt;code&gt;test_yyy.py&lt;/code&gt;. If you only need to test one aspect of &lt;code&gt;zzz&lt;/code&gt;, you can simply add a test function:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ffbff519fe81519b5859278de1db83d3776384bb" translate="yes" xml:space="preserve">
          <source>Suppose you have a SciPy module &lt;code&gt;scipy/xxx/yyy.py&lt;/code&gt; containing a function &lt;code&gt;zzz()&lt;/code&gt;. To test this function you would create a test module called &lt;code&gt;test_yyy.py&lt;/code&gt;. If you only need to test one aspect of &lt;code&gt;zzz&lt;/code&gt;, you can simply add a test function:</source>
          <target state="translated">Предположим, у вас есть модуль SciPy &lt;code&gt;scipy/xxx/yyy.py&lt;/code&gt; , содержащий функцию &lt;code&gt;zzz()&lt;/code&gt; . Чтобы протестировать эту функцию, вы должны создать тестовый модуль с именем &lt;code&gt;test_yyy.py&lt;/code&gt; . Если вам нужно протестировать только один аспект &lt;code&gt;zzz&lt;/code&gt; , вы можете просто добавить тестовую функцию:</target>
        </trans-unit>
        <trans-unit id="561e62ec5d03ac50c21e0a257548d3eb990ac028" translate="yes" xml:space="preserve">
          <source>Suppose you have an urn with 15 white and 15 black marbles. If you pull 15 marbles at random, how likely is it that 12 or more of them are one color?</source>
          <target state="translated">Предположим,у вас есть урна с 15 белыми и 15 черными шариками.Если Вы вытягиваете 15 шариков случайным образом,насколько вероятно,что 12 или более из них одного цвета?</target>
        </trans-unit>
        <trans-unit id="7c7cd36a0c21d430e2827a371600cad0b35b80b7" translate="yes" xml:space="preserve">
          <source>Suppress the rows and/or columns of a 2-D array that contain masked values.</source>
          <target state="translated">Подавление строк и/или столбцов 2-D массива,содержащих маскированные значения.</target>
        </trans-unit>
        <trans-unit id="00f54cf02ad98c4bd3014ede43830053636d4545" translate="yes" xml:space="preserve">
          <source>Suppress whole columns of a 2-D array that contain masked values.</source>
          <target state="translated">Подавление целых столбцов двухмерного массива,содержащего маскированные значения.</target>
        </trans-unit>
        <trans-unit id="685b0c43425911b6f904fe6d170e96c0345d4cbf" translate="yes" xml:space="preserve">
          <source>Suppress whole rows of a 2-D array that contain masked values.</source>
          <target state="translated">Подавление целых строк 2-D массива,содержащего маскированные значения.</target>
        </trans-unit>
        <trans-unit id="b11d9a95741366c39b17b9d4fd94445d808b15b4" translate="yes" xml:space="preserve">
          <source>Swap the bytes of the array elements</source>
          <target state="translated">Замена байт элементов массива</target>
        </trans-unit>
        <trans-unit id="bbdcf90ffec6f9d47a9ac51cf19b00a93a140fa9" translate="yes" xml:space="preserve">
          <source>Switch determining nature of return value. When it is False (the default) just the coefficients are returned, when True diagnostic information from the singular value decomposition is also returned.</source>
          <target state="translated">Переключатель определения характера возвращаемого значения.При False (по умолчанию)возвращаются только коэффициенты,когда также возвращается True диагностическая информация из сингулярного разложения значений.</target>
        </trans-unit>
        <trans-unit id="6b3384dea957229bd45073ab4c8cae823f791969" translate="yes" xml:space="preserve">
          <source>Switch determining the nature of the return value. When &lt;code&gt;False&lt;/code&gt; (the default) just the coefficients are returned; when &lt;code&gt;True&lt;/code&gt;, diagnostic information from the singular value decomposition (used to solve the fit&amp;rsquo;s matrix equation) is also returned.</source>
          <target state="translated">Переключатель, определяющий характер возвращаемого значения. Если &lt;code&gt;False&lt;/code&gt; (по умолчанию), возвращаются только коэффициенты; когда &lt;code&gt;True&lt;/code&gt; , также возвращается диагностическая информация из разложения по сингулярным значениям (используемого для решения матричного уравнения подгонки).</target>
        </trans-unit>
        <trans-unit id="7af38070c59fd5383f5319f90871324cb011240a" translate="yes" xml:space="preserve">
          <source>System Entropy</source>
          <target state="translated">система энтропии</target>
        </trans-unit>
        <trans-unit id="1b1430441b7b7dd5a90d83f42f914deacc5fd0e5" translate="yes" xml:space="preserve">
          <source>System configuration</source>
          <target state="translated">Системная конфигурация</target>
        </trans-unit>
        <trans-unit id="47e68638ef3b94e3c34563e1179f97e827fb9bec" translate="yes" xml:space="preserve">
          <source>SystemError</source>
          <target state="translated">SystemError</target>
        </trans-unit>
        <trans-unit id="c2c53d66948214258a26ca9ca845d7ac0c17f8e7" translate="yes" xml:space="preserve">
          <source>T</source>
          <target state="translated">T</target>
        </trans-unit>
        <trans-unit id="29f1b70dfc7cd7e2755985e321ea4063c37e7f58" translate="yes" xml:space="preserve">
          <source>T (numpy.char.chararray attribute)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="08fb6d4b20d17768263265c26a0d6392cfb83ed1" translate="yes" xml:space="preserve">
          <source>T() (numpy.ma.masked_array property)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="494db6c744e0093634443456957eafcc51937e81" translate="yes" xml:space="preserve">
          <source>THE RESULTING LOGIT FUNCTION IS NOT FAST! numpy.vectorize simply loops over spam.logit. The loop is done at the C level, but the numpy array is constantly being parsed and build back up. This is expensive. When the author compared numpy.vectorize(spam.logit) against the logit ufuncs constructed below, the logit ufuncs were almost exactly 4 times faster. Larger or smaller speedups are, of course, possible depending on the nature of the function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d06ee651a160babb28eda47548bd9fad2ca6df2" translate="yes" xml:space="preserve">
          <source>THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &amp;ldquo;AS IS&amp;rdquo; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e0d354392fe3fc9d2a5d83e7fd5a6f24a2b815a" translate="yes" xml:space="preserve">
          <source>TODO: Maybe it would be better to introduce a function &lt;code&gt;NpyIter_GetWrappedOutput&lt;/code&gt; and remove this flag?</source>
          <target state="translated">TODO: Может, лучше было бы ввести функцию &lt;code&gt;NpyIter_GetWrappedOutput&lt;/code&gt; и убрать этот флаг?</target>
        </trans-unit>
        <trans-unit id="c398f641b79127cbb5368a052c9c18ee4b191edd" translate="yes" xml:space="preserve">
          <source>TODO: This feature can be easily extended for Fortran 90 codes as well. Let us know if you would need such a feature.</source>
          <target state="translated">TODO:Эта функция может быть легко расширена и для кодов Fortran 90.Сообщите нам,если вам понадобится такая функция.</target>
        </trans-unit>
        <trans-unit id="8cfd932f7721749006331a6f950d4068e186ddf4" translate="yes" xml:space="preserve">
          <source>Table of Rough MATLAB-NumPy Equivalents</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b2e0fad2c7303a14e3d40f2816778e4a945515d7" translate="yes" xml:space="preserve">
          <source>Tag the release</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d2bf59208074c19e062d597b69c91e24c1b3f65d" translate="yes" xml:space="preserve">
          <source>Take a sequence of 1-D arrays and stack them as columns to make a single 2-D array. 2-D arrays are stacked as-is, just like with &lt;a href=&quot;numpy.hstack#numpy.hstack&quot;&gt;&lt;code&gt;hstack&lt;/code&gt;&lt;/a&gt;. 1-D arrays are turned into 2-D columns first.</source>
          <target state="translated">Возьмите последовательность одномерных массивов и сложите их как столбцы, чтобы получился один двумерный массив. &lt;a href=&quot;numpy.hstack#numpy.hstack&quot;&gt; &lt;code&gt;hstack&lt;/code&gt; &lt;/a&gt; массивы складываются как есть, как и в случае с hstack . Сначала одномерные массивы преобразуются в двухмерные столбцы.</target>
        </trans-unit>
        <trans-unit id="a7063ff9c282b69776d4b6c1965ce5cc8d3d21f1" translate="yes" xml:space="preserve">
          <source>Take a sequence of 1-D arrays and stack them as columns to make a single 2-D array. 2-D arrays are stacked as-is, just like with &lt;a href=&quot;numpy.ma.hstack#numpy.ma.hstack&quot;&gt;&lt;code&gt;hstack&lt;/code&gt;&lt;/a&gt;. 1-D arrays are turned into 2-D columns first.</source>
          <target state="translated">Возьмите последовательность одномерных массивов и сложите их как столбцы, чтобы получился один двумерный массив. &lt;a href=&quot;numpy.ma.hstack#numpy.ma.hstack&quot;&gt; &lt;code&gt;hstack&lt;/code&gt; &lt;/a&gt; массивы складываются как есть, как и в случае с hstack . Сначала одномерные массивы преобразуются в двухмерные столбцы.</target>
        </trans-unit>
        <trans-unit id="948650b27c1b2b9784a79436cafe48d7d653c938" translate="yes" xml:space="preserve">
          <source>Take along an axis, using the same indices for every 1d slice</source>
          <target state="translated">Возьмите по оси,используя одни и те же индексы для каждого 1д среза.</target>
        </trans-unit>
        <trans-unit id="750d821c9fa304621f4be0f3b88564bf9278e152" translate="yes" xml:space="preserve">
          <source>Take elements by matching the array and the index arrays</source>
          <target state="translated">Взять элементы путем сопоставления массива и индексных массивов</target>
        </trans-unit>
        <trans-unit id="e11fd16230a195030272e04871b014d038eef9ab" translate="yes" xml:space="preserve">
          <source>Take elements from an array along an axis.</source>
          <target state="translated">Возьмите элементы из массива по оси.</target>
        </trans-unit>
        <trans-unit id="2bd0abec8d18fb4f628e5467a962eaf329bb6905" translate="yes" xml:space="preserve">
          <source>Take elements using a boolean mask</source>
          <target state="translated">Возьмите элементы с помощью булевой маски</target>
        </trans-unit>
        <trans-unit id="17496f471ffa9e41a2e92dd83c6a717d70cae831" translate="yes" xml:space="preserve">
          <source>Take log base n of x.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b8cd92f0049ea13b3db726f84fc3411287caeddf" translate="yes" xml:space="preserve">
          <source>Take the fields dictionary, &lt;em&gt;dict&lt;/em&gt;, such as the one attached to a data-type object and construct an ordered-list of field names such as is stored in the names field of the &lt;a href=&quot;c-api.types-and-structures#c.PyArray_Descr&quot;&gt;&lt;code&gt;PyArray_Descr&lt;/code&gt;&lt;/a&gt; object.</source>
          <target state="translated">Возьмите словарь полей, &lt;em&gt;dict&lt;/em&gt; , такой как тот, который прикреплен к объекту типа данных, и &lt;a href=&quot;c-api.types-and-structures#c.PyArray_Descr&quot;&gt; &lt;code&gt;PyArray_Descr&lt;/code&gt; &lt;/a&gt; упорядоченный список имен полей, который хранится в поле имен объекта PyArray_Descr .</target>
        </trans-unit>
        <trans-unit id="8588b385cd332763c111b95b02976dcd4b8a50f6" translate="yes" xml:space="preserve">
          <source>Take the fields dictionary, &lt;em&gt;dict&lt;/em&gt;, such as the one attached to a data-type object and construct an ordered-list of field names such as is stored in the names field of the &lt;a href=&quot;types-and-structures#c.PyArray_Descr&quot;&gt;&lt;code&gt;PyArray_Descr&lt;/code&gt;&lt;/a&gt; object.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="673397230d0da22f7147b4eeece871fd1294c5ff" translate="yes" xml:space="preserve">
          <source>Take values from the input array by matching 1d index and data slices</source>
          <target state="translated">Взять значения из входного массива путем сопоставления 1d индекса и срезов данных</target>
        </trans-unit>
        <trans-unit id="7f4b8f1ca46302f3d1aba5fbdc3749dad60f0480" translate="yes" xml:space="preserve">
          <source>Take values from the input array by matching 1d index and data slices.</source>
          <target state="translated">Взять значения из входного массива путем сопоставления 1d индекса и срезов данных.</target>
        </trans-unit>
        <trans-unit id="567aaaa85050a78f736c937e4e349477825e7c6c" translate="yes" xml:space="preserve">
          <source>Takes an arbitrary Python function and returns a NumPy ufunc.</source>
          <target state="translated">Принимает произвольную Python-функцию и возвращает NumPy ufunc.</target>
        </trans-unit>
        <trans-unit id="ad884a5ab2796ce61beab25497caa48a0c350a18" translate="yes" xml:space="preserve">
          <source>Takes an arbitrary Python function and returns a ufunc</source>
          <target state="translated">Принимает произвольную функцию питона и возвращает ufunc.</target>
        </trans-unit>
        <trans-unit id="4fe8421f7b4bac2910c2919a03e01d32f910e006" translate="yes" xml:space="preserve">
          <source>Taking an example cited in Wikipedia, this distribution can be used if one wanted to cut strings (each of initial length 1.0) into K pieces with different lengths, where each piece had, on average, a designated average length, but allowing some variation in the relative sizes of the pieces.</source>
          <target state="translated">Возьмем пример,приведенный в Википедии,это распределение может быть использовано,если нужно вырезать строки (каждая из начальной длины 1.0)на K штук разной длины,где каждая штука имеет,в среднем,обозначенную среднюю длину,но допускает некоторые вариации в относительных размерах штук.</target>
        </trans-unit>
        <trans-unit id="a8980c440e8f502e5c59dc6cdcc36215481bcc7e" translate="yes" xml:space="preserve">
          <source>Taking no further action</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af1237aaefe517f485a7a53e6bb8a3bb8a86a6a4" translate="yes" xml:space="preserve">
          <source>Target array.</source>
          <target state="translated">Массив целей.</target>
        </trans-unit>
        <trans-unit id="29750e559748752bfadb381caa3f9398aa376d70" translate="yes" xml:space="preserve">
          <source>Target groups: pre-configured configuration statements used for managing the required optimizations from outside the dispatch-able source.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="51038a1a794fec6114fafbb47a8bce902f23294f" translate="yes" xml:space="preserve">
          <source>Target indices, interpreted as integers.</source>
          <target state="translated">Целевые индексы,интерпретируемые как целые числа.</target>
        </trans-unit>
        <trans-unit id="695f8bb0287f4fc300e17fa93e5262f0b53e9bb1" translate="yes" xml:space="preserve">
          <source>Temporary directories are deleted when the DataSource is deleted.</source>
          <target state="translated">Временные каталоги удаляются при удалении DataSource.</target>
        </trans-unit>
        <trans-unit id="b3d2d960e69084c198868bb0c51081b279e6d57d" translate="yes" xml:space="preserve">
          <source>Temporary elision</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6701dda5ea2a62c52d8395d7a5c8f390a0ab64df" translate="yes" xml:space="preserve">
          <source>Tensor contraction:</source>
          <target state="translated">Сокращение тензора:</target>
        </trans-unit>
        <trans-unit id="7e786b6ecaa33c3bfa2a663250579b348bbb6678" translate="yes" xml:space="preserve">
          <source>Tensor contractions, &lt;a href=&quot;numpy.tensordot#numpy.tensordot&quot;&gt;&lt;code&gt;numpy.tensordot&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Тензорные сокращения, &lt;a href=&quot;numpy.tensordot#numpy.tensordot&quot;&gt; &lt;code&gt;numpy.tensordot&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8aa53899fcc2f4722e3aaa13b02a9f0c21a58b0c" translate="yes" xml:space="preserve">
          <source>Tensor to &amp;lsquo;invert&amp;rsquo;. Its shape must be &amp;lsquo;square&amp;rsquo;, i. e., &lt;code&gt;prod(a.shape[:ind]) == prod(a.shape[ind:])&lt;/code&gt;.</source>
          <target state="translated">Тензор для инвертирования. Его форма должна быть &amp;laquo;квадратной&amp;raquo;, то есть &lt;code&gt;prod(a.shape[:ind]) == prod(a.shape[ind:])&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5a7912060e7ae8d981d410c16692b658bc5a8653" translate="yes" xml:space="preserve">
          <source>Tensors to &amp;ldquo;dot&amp;rdquo;.</source>
          <target state="translated">Тензоры в &amp;laquo;точку&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="71218d40834bc4913fe2fbb95e52de19a584b43a" translate="yes" xml:space="preserve">
          <source>Test Running</source>
          <target state="translated">Прогон тестов</target>
        </trans-unit>
        <trans-unit id="2ec99dbb44d0090912e3c4ddf71222f3cee61914" translate="yes" xml:space="preserve">
          <source>Test Support (&lt;code&gt;numpy.testing&lt;/code&gt;)</source>
          <target state="translated">Поддержка тестирования ( &lt;code&gt;numpy.testing&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="c35554b04739c6c6869f7c83d9841e0dda4c5073" translate="yes" xml:space="preserve">
          <source>Test Support (numpy.testing)</source>
          <target state="translated">Поддержка тестирования (numpy.testing)</target>
        </trans-unit>
        <trans-unit id="a0b0d520e3181fa7765d42a80050b97cb70dbe30" translate="yes" xml:space="preserve">
          <source>Test coverage</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="59afddee1692b59da457c30d92a5b65f5e31115a" translate="yes" xml:space="preserve">
          <source>Test element-wise for NaN and return result as a boolean array.</source>
          <target state="translated">Тестируйте по элементам для NaN и возвращайте результат в виде булевого массива.</target>
        </trans-unit>
        <trans-unit id="ed391a308f11ca7f40c17a765e9b20cc4e1035a2" translate="yes" xml:space="preserve">
          <source>Test element-wise for NaT (not a time) and return result as a boolean array.</source>
          <target state="translated">Тестируйте по элементам для NaT (не по времени)и возвращайте результат в виде булевого массива.</target>
        </trans-unit>
        <trans-unit id="9f34997c659f4457d18a667e13e9b54ff7ea7b5d" translate="yes" xml:space="preserve">
          <source>Test element-wise for finiteness (not infinity or not Not a Number).</source>
          <target state="translated">Тест на конечность (не бесконечность или не число).</target>
        </trans-unit>
        <trans-unit id="b73482f0dd7c13ea3e95362c875b37244def5b6c" translate="yes" xml:space="preserve">
          <source>Test element-wise for negative infinity, return result as bool array.</source>
          <target state="translated">Тест на отрицательную бесконечность по элементам,возвращает результат в виде массива bool.</target>
        </trans-unit>
        <trans-unit id="f441420173d81baeaa59a4fb443d5293972df75a" translate="yes" xml:space="preserve">
          <source>Test element-wise for positive infinity, return result as bool array.</source>
          <target state="translated">Тестируйте по элементам на положительную бесконечность,возвращайте результат в виде массива bool.</target>
        </trans-unit>
        <trans-unit id="f76286ad13fcd1d6939365b38ad9443c5711054b" translate="yes" xml:space="preserve">
          <source>Test element-wise for positive or negative infinity.</source>
          <target state="translated">Тест на положительную или отрицательную бесконечность по элементам.</target>
        </trans-unit>
        <trans-unit id="a54ae1b5fd87138bbeb065cc5056362be6e773bd" translate="yes" xml:space="preserve">
          <source>Test if &lt;code&gt;path&lt;/code&gt; exists as (and in this order):</source>
          <target state="translated">Проверьте, существует ли &lt;code&gt;path&lt;/code&gt; как (и в этом порядке):</target>
        </trans-unit>
        <trans-unit id="6db21c53daecd81068cb27c5716c17cf9ec8f853" translate="yes" xml:space="preserve">
          <source>Test if path exists.</source>
          <target state="translated">Проверьте,существует ли путь.</target>
        </trans-unit>
        <trans-unit id="ab9c97d91f47360ac72bf2e9386f7b26c75db7d2" translate="yes" xml:space="preserve">
          <source>Test if two strings are equal.</source>
          <target state="translated">Проверьте,равны ли две строки.</target>
        </trans-unit>
        <trans-unit id="90c99592ef3a4e369f5b8438543a142bc4a6d8c8" translate="yes" xml:space="preserve">
          <source>Test support</source>
          <target state="translated">Тестовая поддержка</target>
        </trans-unit>
        <trans-unit id="fe6e53750db930a15ff2a9eb0786f6b4b0dd49e8" translate="yes" xml:space="preserve">
          <source>Test whether &lt;code&gt;ary&lt;/code&gt; is contiguous. If so, return 1. Otherwise, set a Python error and return 0.</source>
          <target state="translated">Проверьте, является ли &lt;code&gt;ary&lt;/code&gt; смежной. Если да, верните 1. В противном случае установите ошибку Python и верните 0.</target>
        </trans-unit>
        <trans-unit id="e52099e2b541a96f27cc77aa438f266ac05e538f" translate="yes" xml:space="preserve">
          <source>Test whether all array elements along a given axis evaluate to True.</source>
          <target state="translated">Проверьте,все ли элементы массива вдоль заданной оси оцениваются в True.</target>
        </trans-unit>
        <trans-unit id="7d4c1c04414d7af36c37c81837979d62019dac75" translate="yes" xml:space="preserve">
          <source>Test whether all elements along a given axis evaluate to True.</source>
          <target state="translated">Проверьте,все ли элементы вдоль данной оси оцениваются в True.</target>
        </trans-unit>
        <trans-unit id="8dcb7ed405671230192b179ae33bab118c7f5996" translate="yes" xml:space="preserve">
          <source>Test whether all matrix elements along a given axis evaluate to True.</source>
          <target state="translated">Проверьте,все ли элементы матрицы вдоль заданной оси оцениваются в True.</target>
        </trans-unit>
        <trans-unit id="a8cd365e47952360dc676cadf55d3bc2ecae44b5" translate="yes" xml:space="preserve">
          <source>Test whether any array element along a given axis evaluates to True.</source>
          <target state="translated">Проверьте,оценивает ли какой-либо элемент массива вдоль заданной оси значение True.</target>
        </trans-unit>
        <trans-unit id="e54011a9e26f7c9e97e1ca23a771785990f7e7d4" translate="yes" xml:space="preserve">
          <source>Test whether any element along a given axis evaluates to True.</source>
          <target state="translated">Проверьте,оценивается ли какой-либо элемент вдоль данной оси в True.</target>
        </trans-unit>
        <trans-unit id="3c5d24b0586eac0954dbcb6d49897a1641c89d36" translate="yes" xml:space="preserve">
          <source>Test whether each element of a 1-D array is also present in a second array.</source>
          <target state="translated">Проверьте,присутствует ли каждый элемент 1-D массива во втором массиве.</target>
        </trans-unit>
        <trans-unit id="025a700084bfede250ccd79227b915c047f7f35d" translate="yes" xml:space="preserve">
          <source>Test whether input is an instance of MaskedArray.</source>
          <target state="translated">Проверьте,является ли входным параметром MaskedArray.</target>
        </trans-unit>
        <trans-unit id="5904fc9bcfebbe0d053c7cdc88d0d4fdd88cf00c" translate="yes" xml:space="preserve">
          <source>Tester (in module numpy.testing)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0820b32b206b7352858e8903a838ed14319acdfd" translate="yes" xml:space="preserve">
          <source>Testing</source>
          <target state="translated">Testing</target>
        </trans-unit>
        <trans-unit id="43d2fa7f4fbc625f4df01f08ea6653e49f950cbd" translate="yes" xml:space="preserve">
          <source>Testing Guidelines</source>
          <target state="translated">Руководство по тестированию</target>
        </trans-unit>
        <trans-unit id="ef9606fae34bdb52d82ad257949ec42aea0b9b12" translate="yes" xml:space="preserve">
          <source>Testing Header Files</source>
          <target state="translated">Файлы тестовых заголовков</target>
        </trans-unit>
        <trans-unit id="8c4816453a13f4ed79fdc1f72aaf2f8bbcc370cd" translate="yes" xml:space="preserve">
          <source>Testing NumPy</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d322a0e8fe52f19dbe7d5bd52156ee63071b90d8" translate="yes" xml:space="preserve">
          <source>Testing Organization</source>
          <target state="translated">Тестирующая организация</target>
        </trans-unit>
        <trans-unit id="e3148b0ff766bdb8347a198898838253aab4da96" translate="yes" xml:space="preserve">
          <source>Testing Python Scripts</source>
          <target state="translated">Тестирование питоновских сценариев</target>
        </trans-unit>
        <trans-unit id="8c3a61a48bb499744371cb7fc30761102d86f229" translate="yes" xml:space="preserve">
          <source>Testing SWIG Interface Files</source>
          <target state="translated">Тестирование файлов интерфейса SWIG</target>
        </trans-unit>
        <trans-unit id="34d08d85bddb11f11da76ad84dab43a94d74c7ed" translate="yes" xml:space="preserve">
          <source>Testing Source Files</source>
          <target state="translated">Файлы источников тестирования</target>
        </trans-unit>
        <trans-unit id="01135c69ed3ceb06607a7ed768bb69a01b974feb" translate="yes" xml:space="preserve">
          <source>Testing a subset of NumPy:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad0aa0ce3fefa4686bfefac5eb7c9ff2df0a50c6" translate="yes" xml:space="preserve">
          <source>Testing builds</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7704b172077f920ddd46d5adbcffe86730e58a19" translate="yes" xml:space="preserve">
          <source>Testing looks for module-level or class-level setup and teardown functions by name; thus:</source>
          <target state="translated">Тестирование ищет функции настройки на модульном или классовом уровне,а также функции по названию:</target>
        </trans-unit>
        <trans-unit id="45ece46e91d1fe305feeee99aed2fad182be7b30" translate="yes" xml:space="preserve">
          <source>Testing the numpy.i Typemaps</source>
          <target state="translated">Тестирование типовых карт numpy.i.</target>
        </trans-unit>
        <trans-unit id="00774e7f83f997b0fda8acccd1c59071701a2ddf" translate="yes" xml:space="preserve">
          <source>Tests can also be run with &lt;code&gt;pytest numpy&lt;/code&gt;, however then the NumPy-specific plugin is not found which causes strange side effects</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7f86100126c53e2e34ca1a3d91679a3a06b6d132" translate="yes" xml:space="preserve">
          <source>Tests for a module should ideally cover all code in that module, i.e., statement coverage should be at 100%.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="417d130b240483956f423e540d6cb689832b6f9e" translate="yes" xml:space="preserve">
          <source>Tests on random data</source>
          <target state="translated">Тесты на случайных данных</target>
        </trans-unit>
        <trans-unit id="f3d72180c504c070f745ad049bd21c11042867d1" translate="yes" xml:space="preserve">
          <source>Tests on random data are good, but since test failures are meant to expose new bugs or regressions, a test that passes most of the time but fails occasionally with no code changes is not helpful. Make the random data deterministic by setting the random number seed before generating it. Use either Python&amp;rsquo;s &lt;code&gt;random.seed(some_number)&lt;/code&gt; or NumPy&amp;rsquo;s &lt;code&gt;numpy.random.seed(some_number)&lt;/code&gt;, depending on the source of random numbers.</source>
          <target state="translated">Тесты на случайных данных хороши, но поскольку сбои тестов предназначены для выявления новых ошибок или регрессий, тест, который проходит большую часть времени, но иногда терпит неудачу без изменений кода, бесполезен. Сделайте случайные данные детерминированными, установив начальное число случайных чисел перед их генерацией. Используйте либо Пайтон &lt;code&gt;random.seed(some_number)&lt;/code&gt; или Numpy в &lt;code&gt;numpy.random.seed(some_number)&lt;/code&gt; , в зависимости от источника случайных чисел.</target>
        </trans-unit>
        <trans-unit id="927f696caa5bf0529c4f0991bbe8b99afb2fa55b" translate="yes" xml:space="preserve">
          <source>Tests whether the half-precision float has a value equal to zero. This may be slightly faster than calling npy_half_eq(h, NPY_ZERO).</source>
          <target state="translated">Тестирует,имеет ли плавающий диск половинной точности значение,равное нулю.Это может быть несколько быстрее,чем вызов npy_half_eq(h,NPY_ZERO).</target>
        </trans-unit>
        <trans-unit id="b3be553d33f0513a6775eaa86f3391147a1aac09" translate="yes" xml:space="preserve">
          <source>Tests whether the half-precision float is a NaN.</source>
          <target state="translated">Проверяет,является ли поплавок половинной точности NaN.</target>
        </trans-unit>
        <trans-unit id="6424a62751d70065c8ad2d16d22d5e29e4d2e45c" translate="yes" xml:space="preserve">
          <source>Tests whether the half-precision float is finite (not NaN or Inf).</source>
          <target state="translated">Проверяет,является ли плавающий поплавок половинной точности конечным (не NaN или Inf).</target>
        </trans-unit>
        <trans-unit id="b796fd95ec3aee28c84902e310b3fcc5e87bd087" translate="yes" xml:space="preserve">
          <source>Tests whether the half-precision float is plus or minus Inf.</source>
          <target state="translated">Проверяет,является ли половинчатый поплавок плюс-минус Inf.</target>
        </trans-unit>
        <trans-unit id="9cad929af9630184e2ec9f960cd674271afcf718" translate="yes" xml:space="preserve">
          <source>Tests, that send messages to stderr, fail when executed from MSYS prompt because the messages are lost at some point.</source>
          <target state="translated">Тесты,которые посылают сообщения в stderr,терпят неудачу при выполнении из MSYS подсказки,потому что сообщения в какой-то момент теряются.</target>
        </trans-unit>
        <trans-unit id="d627254d7ccb3ce266ce9cf0341eff8096cd2a09" translate="yes" xml:space="preserve">
          <source>Texlive (or MikTeX on Windows)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0a988a505d4f9bd1f41a57f4c2458a2423baedc7" translate="yes" xml:space="preserve">
          <source>Text files</source>
          <target state="translated">Текстовые файлы</target>
        </trans-unit>
        <trans-unit id="4ba343aecd438b7c22876dbbd27f537f09be5607" translate="yes" xml:space="preserve">
          <source>Text formatting options</source>
          <target state="translated">Опции форматирования текста</target>
        </trans-unit>
        <trans-unit id="839b1da5d3ca352faa5ce69a674d5b04a8fa489d" translate="yes" xml:space="preserve">
          <source>Thanks to Yarik Halchenko for this explanation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5219411122630dca47bf818c11bfaef89c8f5266" translate="yes" xml:space="preserve">
          <source>That also takes extra arguments, like &lt;code&gt;--pdb&lt;/code&gt; which drops you into the Python debugger when a test fails or an exception is raised.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="90e8faeace432448f3522160a796443560f628f2" translate="yes" xml:space="preserve">
          <source>That can be one of 12 different scalar types: &lt;code&gt;signed char&lt;/code&gt;, &lt;code&gt;unsigned char&lt;/code&gt;, &lt;code&gt;short&lt;/code&gt;, &lt;code&gt;unsigned short&lt;/code&gt;, &lt;code&gt;int&lt;/code&gt;, &lt;code&gt;unsigned int&lt;/code&gt;, &lt;code&gt;long&lt;/code&gt;, &lt;code&gt;unsigned long&lt;/code&gt;, &lt;code&gt;long long&lt;/code&gt;, &lt;code&gt;unsigned long long&lt;/code&gt;, &lt;code&gt;float&lt;/code&gt; and &lt;code&gt;double&lt;/code&gt;.</source>
          <target state="translated">Это может быть один из 12 различных скалярных типов: &lt;code&gt;signed char&lt;/code&gt; , &lt;code&gt;unsigned char&lt;/code&gt; , &lt;code&gt;short&lt;/code&gt; , &lt;code&gt;unsigned short&lt;/code&gt; , &lt;code&gt;int&lt;/code&gt; , &lt;code&gt;unsigned int&lt;/code&gt; , &lt;code&gt;long&lt;/code&gt; , &lt;code&gt;unsigned long&lt;/code&gt; , &lt;code&gt;long long&lt;/code&gt; , &lt;code&gt;unsigned long long&lt;/code&gt; , &lt;code&gt;float&lt;/code&gt; и &lt;code&gt;double&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="be4b72468f984c83d93633e8f8bf75388e94a047" translate="yes" xml:space="preserve">
          <source>That is a looser test than originally documented, but agrees with what the actual implementation did up to rounding vagaries. An exception is raised at shape mismatch or conflicting values. In contrast to the standard usage in numpy, NaNs are compared like numbers, no assertion is raised if both objects have NaNs in the same positions.</source>
          <target state="translated">Это более проигрышный тест,чем первоначально документированный,но согласуется с тем,что реальная реализация сделала с капризами округления.Исключение поднимается при несовпадении форм или противоречивых значениях.В отличие от стандартного использования в нумерации,NaNs сравниваются как числа,утверждение не поднимается,если оба объекта имеют NaNs в одних и тех же позициях.</target>
        </trans-unit>
        <trans-unit id="31ca174a88927a9e0e7f8f15283f8ce9b3459f51" translate="yes" xml:space="preserve">
          <source>That is a looser test than originally documented, but agrees with what the actual implementation in &lt;a href=&quot;numpy.testing.assert_array_almost_equal#numpy.testing.assert_array_almost_equal&quot;&gt;&lt;code&gt;assert_array_almost_equal&lt;/code&gt;&lt;/a&gt; did up to rounding vagaries. An exception is raised at conflicting values. For ndarrays this delegates to assert_array_almost_equal</source>
          <target state="translated">Это более свободный тест, чем изначально задокументированный, но он согласуется с тем, что было &lt;a href=&quot;numpy.testing.assert_array_almost_equal#numpy.testing.assert_array_almost_equal&quot;&gt; &lt;code&gt;assert_array_almost_equal&lt;/code&gt; &lt;/a&gt; в реальной реализации в assert_array_almost_equal , вплоть до капризов округления. Исключение возникает при противоречивых значениях. Для ndarrays это делегирует assert_array_almost_equal</target>
        </trans-unit>
        <trans-unit id="78c7ba93686b82a275a0b9b502ec9d6d238b4d32" translate="yes" xml:space="preserve">
          <source>That is better: no more negative values. However, we can still see that for some days, the cumulative number of cases seems to go down (from 835 to 10, for example), which does not agree with the definition of &amp;ldquo;cumulative data&amp;rdquo;. If we look more closely at the data, we can see that in the period where there was missing data in mainland China, there was valid data for Hong Kong, Taiwan, Macau and &amp;ldquo;Unspecified&amp;rdquo; regions of China. Maybe we can remove those from the total sum of cases in China, to get a better understanding of the data.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="89910f6f21cfa928fbf09ccc006fad6eb4f77601" translate="yes" xml:space="preserve">
          <source>That is, each index specified selects the array corresponding to the rest of the dimensions selected. In the above example, choosing 0 means that the remaining dimension of length 5 is being left unspecified, and that what is returned is an array of that dimensionality and size. It must be noted that the returned array is not a copy of the original, but points to the same values in memory as does the original array. In this case, the 1-D array at the first position (0) is returned. So using a single index on the returned array, results in a single element being returned. That is:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9424a0780491d95b42071bfcb7519b4471231e07" translate="yes" xml:space="preserve">
          <source>That solves the problem of returning views of the same type, but now we have a new problem. The machinery of ndarray can set the class this way, in its standard methods for taking views, but the ndarray &lt;code&gt;__new__&lt;/code&gt; method knows nothing of what we have done in our own &lt;code&gt;__new__&lt;/code&gt; method in order to set attributes, and so on. (Aside - why not call &lt;code&gt;obj = subdtype.__new__(...&lt;/code&gt; then? Because we may not have a &lt;code&gt;__new__&lt;/code&gt; method with the same call signature).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b5240cf478eeccab2d778da09495ef32dd780cc8" translate="yes" xml:space="preserve">
          <source>That support 74 different argument signatures for each data type, including:</source>
          <target state="translated">Поддерживаются 74 различные сигнатуры аргументов для каждого типа данных,в том числе:</target>
        </trans-unit>
        <trans-unit id="93ef0dd827103681fcee453b78be2ff14e1a261d" translate="yes" xml:space="preserve">
          <source>The</source>
          <target state="translated">The</target>
        </trans-unit>
        <trans-unit id="5c4c1c79691cc97764af36fe5679519dac98f423" translate="yes" xml:space="preserve">
          <source>The &amp;ldquo;busday&amp;rdquo; functions can additionally check a list of &amp;ldquo;holiday&amp;rdquo; dates, specific dates that are not valid days.</source>
          <target state="translated">Функции &amp;laquo;рабочий день&amp;raquo; могут дополнительно проверить список &amp;laquo;праздничных&amp;raquo; дат, определенных дат, которые не являются действительными днями.</target>
        </trans-unit>
        <trans-unit id="b6c70d4694de1c6fa7fc40232e3591d1a1b102a5" translate="yes" xml:space="preserve">
          <source>The &amp;ldquo;count&amp;rdquo; algorithm is roughly equivalent to the following numpy code:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a2e889671201d8619d4999f2673b8d825f07526" translate="yes" xml:space="preserve">
          <source>The &amp;ldquo;count&amp;rdquo; algorithm uses a temporary array of integers with length &lt;code&gt;sum(colors)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="701df984a45b35c07efc7a2ab11dc3b2d9004e29" translate="yes" xml:space="preserve">
          <source>The &amp;ldquo;four quadrant&amp;rdquo; arctan of the angle formed by (&lt;code&gt;x&lt;/code&gt;, &lt;code&gt;y&lt;/code&gt;) and the positive &lt;code&gt;x&lt;/code&gt;-axis.</source>
          <target state="translated">&amp;laquo;Четырехквадрантный&amp;raquo; арктангенс угла, образованного ( &lt;code&gt;x&lt;/code&gt; , &lt;code&gt;y&lt;/code&gt; ) и положительной осью &lt;code&gt;x&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7af7d8f19766359bdf4ea2069305031d08b0663c" translate="yes" xml:space="preserve">
          <source>The &amp;ldquo;marginals&amp;rdquo; algorithm generates a variate by using repeated calls to the univariate hypergeometric sampler. It is roughly equivalent to:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="72e5831aa41d1e2f9af8c987044c60e05af0be5f" translate="yes" xml:space="preserve">
          <source>The &amp;ldquo;smart way&amp;rdquo; of wrapping Fortran functions, as explained above, is suitable for wrapping (e.g. third party) Fortran codes for which modifications to their source codes are not desirable nor even possible.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2adc5d4e116d43dd248737cacbfac03ed3ef63f9" translate="yes" xml:space="preserve">
          <source>The &amp;ldquo;y-intercept&amp;rdquo; and &amp;ldquo;slope&amp;rdquo; of the line, respectively.</source>
          <target state="translated">&amp;laquo;Y-точка пересечения&amp;raquo; и &amp;laquo;наклон&amp;raquo; линии соответственно.</target>
        </trans-unit>
        <trans-unit id="e4a0235cef14b392c275cecc105837cde82d5723" translate="yes" xml:space="preserve">
          <source>The &amp;lsquo;a&amp;rsquo; variable is unstripped from c[1] because whitespace leading.</source>
          <target state="translated">Переменная 'a' не отделена от c [1] из-за пробела.</target>
        </trans-unit>
        <trans-unit id="bda37a7da4e6885245e567c4fedb24dc646e8a1c" translate="yes" xml:space="preserve">
          <source>The &amp;lsquo;out&amp;rsquo; keyword argument is expected to be a tuple with one entry per output (which can be &lt;code&gt;None&lt;/code&gt; for arrays to be allocated by the ufunc). For ufuncs with a single output, passing a single array (instead of a tuple holding a single array) is also valid.</source>
          <target state="translated">Ожидается, что аргумент ключевого слова out будет кортежем с одной записью на каждый вывод (который может иметь значение &lt;code&gt;None&lt;/code&gt; для массивов, выделяемых ufunc). Для ufuncs с одним выходом также допустима передача одного массива (вместо кортежа, содержащего один массив).</target>
        </trans-unit>
        <trans-unit id="db204a13b36f2cf86d7bd1794820137a1ac066ee" translate="yes" xml:space="preserve">
          <source>The &amp;lsquo;out&amp;rsquo; keyword argument is expected to be a tuple with one entry per output (which can be None for arrays to be allocated by the ufunc). For ufuncs with a single output, passing a single array (instead of a tuple holding a single array) is also valid.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34701f78458bf915d5b828bf9386058d6824fbe4" translate="yes" xml:space="preserve">
          <source>The &amp;lsquo;per&amp;rsquo; variable represents the periods of the loan. Remember that financial equations start the period count at 1!</source>
          <target state="translated">Переменная &quot;per&quot; представляет периоды ссуды. Помните, что в финансовых уравнениях отсчет периода начинается с 1!</target>
        </trans-unit>
        <trans-unit id="cb090179fdd970838b19c1b214a4530cfcd16ee3" translate="yes" xml:space="preserve">
          <source>The (non-conjugated) transpose of the matrix.</source>
          <target state="translated">(несопряженная)транспозиция матрицы.</target>
        </trans-unit>
        <trans-unit id="2c0a3ac18c0e35ff547f3a4005419b0e018f9e8e" translate="yes" xml:space="preserve">
          <source>The 1.6 implementation of datetime does not convert between units correctly.:</source>
          <target state="translated">1.6 реализация даты не корректно конвертирует время между единицами..:</target>
        </trans-unit>
        <trans-unit id="f72725eb7318a896f41cd0cf447d8c91f324fb0d" translate="yes" xml:space="preserve">
          <source>The 1.6 implementation of datetime only works correctly for a small subset of arithmetic operations. Here we show some simple cases.:</source>
          <target state="translated">Реализация datetime 1.6 корректно работает только для небольшого подмножества арифметических операций.Здесь мы покажем несколько простых случаев:</target>
        </trans-unit>
        <trans-unit id="887cfe3b8a793575511e5fe48982dbd8c7813d6e" translate="yes" xml:space="preserve">
          <source>The 2-D output array.</source>
          <target state="translated">2-D выходной массив.</target>
        </trans-unit>
        <trans-unit id="8d40d72287619706da0622aa60cf9b527faa81be" translate="yes" xml:space="preserve">
          <source>The 24 built-in &lt;a href=&quot;arrays.scalars#arrays-scalars-built-in&quot;&gt;array scalar type objects&lt;/a&gt; all convert to an associated data-type object. This is true for their sub-classes as well.</source>
          <target state="translated">Все 24 &lt;a href=&quot;arrays.scalars#arrays-scalars-built-in&quot;&gt;объекта скалярного типа&lt;/a&gt; встроенного массива преобразуются в связанный объект типа данных. Это верно и для их подклассов.</target>
        </trans-unit>
        <trans-unit id="3182f1dfa2639174f8b34fe5f092a96393f1cf6d" translate="yes" xml:space="preserve">
          <source>The 64-bit OpenBLAS with &lt;code&gt;64_&lt;/code&gt; symbol suffix is obtained by compiling OpenBLAS with settings:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="44abfc0b778e06539587a775fdc8b33ee9085231" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#c.NPY_ARRAY_C_CONTIGUOUS&quot;&gt;&lt;code&gt;NPY_ARRAY_C_CONTIGUOUS&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#c.NPY_ARRAY_ALIGNED&quot;&gt;&lt;code&gt;NPY_ARRAY_ALIGNED&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;#c.NPY_ARRAY_F_CONTIGUOUS&quot;&gt;&lt;code&gt;NPY_ARRAY_F_CONTIGUOUS&lt;/code&gt;&lt;/a&gt; array flags can be &amp;ldquo;calculated&amp;rdquo; from the array object itself. This routine updates one or more of these flags of &lt;em&gt;arr&lt;/em&gt; as specified in &lt;em&gt;flagmask&lt;/em&gt; by performing the required calculation.</source>
          <target state="translated">В &lt;a href=&quot;#c.NPY_ARRAY_C_CONTIGUOUS&quot;&gt; &lt;code&gt;NPY_ARRAY_C_CONTIGUOUS&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#c.NPY_ARRAY_ALIGNED&quot;&gt; &lt;code&gt;NPY_ARRAY_ALIGNED&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;#c.NPY_ARRAY_F_CONTIGUOUS&quot;&gt; &lt;code&gt;NPY_ARRAY_F_CONTIGUOUS&lt;/code&gt; &lt;/a&gt; флаги массива могут быть &amp;laquo;вычислены&amp;raquo; от самого объекта массива. Эта процедура обновляет один или несколько из этих флагов &lt;em&gt;arr,&lt;/em&gt; как указано в &lt;em&gt;flagmask,&lt;/em&gt; путем выполнения необходимых вычислений.</target>
        </trans-unit>
        <trans-unit id="d5ab1d9e20a833c167142777c07717d8769b7541" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#c.PyArrayDescr_Type&quot;&gt;&lt;code&gt;PyArrayDescr_Type&lt;/code&gt;&lt;/a&gt; is the built-in type of the data-type-descriptor objects used to describe how the bytes comprising the array are to be interpreted. There are 21 statically-defined &lt;a href=&quot;#c.PyArray_Descr&quot;&gt;&lt;code&gt;PyArray_Descr&lt;/code&gt;&lt;/a&gt; objects for the built-in data-types. While these participate in reference counting, their reference count should never reach zero. There is also a dynamic table of user-defined &lt;a href=&quot;#c.PyArray_Descr&quot;&gt;&lt;code&gt;PyArray_Descr&lt;/code&gt;&lt;/a&gt; objects that is also maintained. Once a data-type-descriptor object is &amp;ldquo;registered&amp;rdquo; it should never be deallocated either. The function &lt;a href=&quot;array#c.PyArray_DescrFromType&quot;&gt;&lt;code&gt;PyArray_DescrFromType&lt;/code&gt;&lt;/a&gt; (&amp;hellip;) can be used to retrieve a &lt;a href=&quot;#c.PyArray_Descr&quot;&gt;&lt;code&gt;PyArray_Descr&lt;/code&gt;&lt;/a&gt; object from an enumerated type-number (either built-in or user- defined).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="83e501c171dddeb86862ef16beddd704b5bc114a" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#c.PyArrayDescr_Type&quot;&gt;&lt;code&gt;PyArrayDescr_Type&lt;/code&gt;&lt;/a&gt; is the built-in type of the data-type-descriptor objects used to describe how the bytes comprising the array are to be interpreted. There are 21 statically-defined &lt;a href=&quot;#c.PyArray_Descr&quot;&gt;&lt;code&gt;PyArray_Descr&lt;/code&gt;&lt;/a&gt; objects for the built-in data-types. While these participate in reference counting, their reference count should never reach zero. There is also a dynamic table of user-defined &lt;a href=&quot;#c.PyArray_Descr&quot;&gt;&lt;code&gt;PyArray_Descr&lt;/code&gt;&lt;/a&gt; objects that is also maintained. Once a data-type-descriptor object is &amp;ldquo;registered&amp;rdquo; it should never be deallocated either. The function &lt;a href=&quot;c-api.array#c.PyArray_DescrFromType&quot;&gt;&lt;code&gt;PyArray_DescrFromType&lt;/code&gt;&lt;/a&gt; (&amp;hellip;) can be used to retrieve a &lt;a href=&quot;#c.PyArray_Descr&quot;&gt;&lt;code&gt;PyArray_Descr&lt;/code&gt;&lt;/a&gt; object from an enumerated type-number (either built-in or user- defined).</source>
          <target state="translated">&lt;a href=&quot;#c.PyArrayDescr_Type&quot;&gt; &lt;code&gt;PyArrayDescr_Type&lt;/code&gt; &lt;/a&gt; является встроенным типом данных для типа дескриптора объектов , используемый для описания , как байты , содержащие массив должны интерпретироваться. Есть 21 статически определенный &lt;a href=&quot;#c.PyArray_Descr&quot;&gt; &lt;code&gt;PyArray_Descr&lt;/code&gt; &lt;/a&gt; для встроенных типов данных. Хотя они участвуют в подсчете ссылок, их счетчик ссылок никогда не должен достигать нуля. Также поддерживается динамическая таблица определяемых &lt;a href=&quot;#c.PyArray_Descr&quot;&gt; &lt;code&gt;PyArray_Descr&lt;/code&gt; &lt;/a&gt; объектов PyArray_Descr . После того как объект дескриптора типа данных &amp;laquo;зарегистрирован&amp;raquo;, его также нельзя освобождать. Функцию &lt;a href=&quot;c-api.array#c.PyArray_DescrFromType&quot;&gt; &lt;code&gt;PyArray_DescrFromType&lt;/code&gt; &lt;/a&gt; (&amp;hellip;) можно использовать для получения объекта &lt;a href=&quot;#c.PyArray_Descr&quot;&gt; &lt;code&gt;PyArray_Descr&lt;/code&gt; &lt;/a&gt; из пронумерованного типа-номера (встроенного или определяемого пользователем).</target>
        </trans-unit>
        <trans-unit id="97cab03f1f33635249cbaecab51bab4753bac00b" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#c.PyArrayInterface&quot;&gt;&lt;code&gt;PyArrayInterface&lt;/code&gt;&lt;/a&gt; structure is defined so that NumPy and other extension modules can use the rapid array interface protocol. The &lt;a href=&quot;../arrays.interface#object.__array_struct__&quot;&gt;&lt;code&gt;__array_struct__&lt;/code&gt;&lt;/a&gt; method of an object that supports the rapid array interface protocol should return a &lt;a href=&quot;https://docs.python.org/dev/c-api/capsule.html#c.PyCapsule&quot;&gt;&lt;code&gt;PyCapsule&lt;/code&gt;&lt;/a&gt; that contains a pointer to a &lt;a href=&quot;#c.PyArrayInterface&quot;&gt;&lt;code&gt;PyArrayInterface&lt;/code&gt;&lt;/a&gt; structure with the relevant details of the array. After the new array is created, the attribute should be &lt;code&gt;DECREF&lt;/code&gt;&amp;rsquo;d which will free the &lt;a href=&quot;#c.PyArrayInterface&quot;&gt;&lt;code&gt;PyArrayInterface&lt;/code&gt;&lt;/a&gt; structure. Remember to &lt;code&gt;INCREF&lt;/code&gt; the object (whose &lt;a href=&quot;../arrays.interface#object.__array_struct__&quot;&gt;&lt;code&gt;__array_struct__&lt;/code&gt;&lt;/a&gt; attribute was retrieved) and point the base member of the new &lt;a href=&quot;#c.PyArrayObject&quot;&gt;&lt;code&gt;PyArrayObject&lt;/code&gt;&lt;/a&gt; to this same object. In this way the memory for the array will be managed correctly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3bd6fb4bf6c794847df919e4e53f9f40e8a12e37" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#c.PyArrayInterface&quot;&gt;&lt;code&gt;PyArrayInterface&lt;/code&gt;&lt;/a&gt; structure is defined so that NumPy and other extension modules can use the rapid array interface protocol. The &lt;code&gt;__array_struct__&lt;/code&gt; method of an object that supports the rapid array interface protocol should return a &lt;code&gt;PyCObject&lt;/code&gt; that contains a pointer to a &lt;a href=&quot;#c.PyArrayInterface&quot;&gt;&lt;code&gt;PyArrayInterface&lt;/code&gt;&lt;/a&gt; structure with the relevant details of the array. After the new array is created, the attribute should be &lt;code&gt;DECREF&lt;/code&gt;&amp;rsquo;d which will free the &lt;a href=&quot;#c.PyArrayInterface&quot;&gt;&lt;code&gt;PyArrayInterface&lt;/code&gt;&lt;/a&gt; structure. Remember to &lt;code&gt;INCREF&lt;/code&gt; the object (whose &lt;code&gt;__array_struct__&lt;/code&gt; attribute was retrieved) and point the base member of the new &lt;a href=&quot;#c.PyArrayObject&quot;&gt;&lt;code&gt;PyArrayObject&lt;/code&gt;&lt;/a&gt; to this same object. In this way the memory for the array will be managed correctly.</source>
          <target state="translated">Структура &lt;a href=&quot;#c.PyArrayInterface&quot;&gt; &lt;code&gt;PyArrayInterface&lt;/code&gt; &lt;/a&gt; определена так, что NumPy и другие модули расширения могут использовать протокол интерфейса быстрого массива. Метод &lt;code&gt;__array_struct__&lt;/code&gt; объекта, который поддерживает протокол интерфейса быстрого массива, должен возвращать &lt;code&gt;PyCObject&lt;/code&gt; , содержащий указатель на структуру &lt;a href=&quot;#c.PyArrayInterface&quot;&gt; &lt;code&gt;PyArrayInterface&lt;/code&gt; &lt;/a&gt; с соответствующими деталями массива. После создания нового массива атрибут должен быть &lt;code&gt;DECREF&lt;/code&gt; 'd, который освободит структуру &lt;a href=&quot;#c.PyArrayInterface&quot;&gt; &lt;code&gt;PyArrayInterface&lt;/code&gt; &lt;/a&gt; . Не забудьте &lt;code&gt;INCREF&lt;/code&gt; объект (чей атрибут &lt;code&gt;__array_struct__&lt;/code&gt; был извлечен) и указать базовый член нового &lt;a href=&quot;#c.PyArrayObject&quot;&gt; &lt;code&gt;PyArrayObject&lt;/code&gt; &lt;/a&gt;к этому же объекту. Таким образом, память для массива будет управляться правильно.</target>
        </trans-unit>
        <trans-unit id="e1afd7f4d29ab170c9bd7906c54475c6dcf363f8" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#c.PyArrayObject&quot;&gt;&lt;code&gt;PyArrayObject&lt;/code&gt;&lt;/a&gt; C-structure contains all of the required information for an array. All instances of an ndarray (and its subclasses) will have this structure. For future compatibility, these structure members should normally be accessed using the provided macros. If you need a shorter name, then you can make use of &lt;a href=&quot;#c.NPY_AO&quot;&gt;&lt;code&gt;NPY_AO&lt;/code&gt;&lt;/a&gt; (deprecated) which is defined to be equivalent to &lt;a href=&quot;#c.PyArrayObject&quot;&gt;&lt;code&gt;PyArrayObject&lt;/code&gt;&lt;/a&gt;. Direct access to the struct fields are deprecated. Use the &lt;code&gt;PyArray_*(arr)&lt;/code&gt; form instead. As of NumPy 1.20, the size of this struct is not considered part of the NumPy ABI (see note at the end of the member list).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd84e3bef1191839ce6ab3739e785dd2e1559188" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#c.PyArrayObject&quot;&gt;&lt;code&gt;PyArrayObject&lt;/code&gt;&lt;/a&gt; C-structure contains all of the required information for an array. All instances of an ndarray (and its subclasses) will have this structure. For future compatibility, these structure members should normally be accessed using the provided macros. If you need a shorter name, then you can make use of &lt;code&gt;NPY_AO&lt;/code&gt; (deprecated) which is defined to be equivalent to &lt;a href=&quot;#c.PyArrayObject&quot;&gt;&lt;code&gt;PyArrayObject&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#c.PyArrayObject&quot;&gt; &lt;code&gt;PyArrayObject&lt;/code&gt; &lt;/a&gt; С-структура содержит всю необходимую информацию для массива. Все экземпляры ndarray (и его подклассы) будут иметь эту структуру. Для будущей совместимости к этим элементам структуры обычно следует обращаться с помощью предоставленных макросов. Если вам нужно более короткое имя, вы можете использовать &lt;code&gt;NPY_AO&lt;/code&gt; (устаревший), который определен как эквивалент &lt;a href=&quot;#c.PyArrayObject&quot;&gt; &lt;code&gt;PyArrayObject&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ef190e5abe2d8e5d647d302d7a90a94792c8ed21" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#c.PyArrayObject&quot;&gt;&lt;code&gt;PyArrayObject&lt;/code&gt;&lt;/a&gt; C-structure contains all of the required information for an array. All instances of an ndarray (and its subclasses) will have this structure. For future compatibility, these structure members should normally be accessed using the provided macros. If you need a shorter name, then you can make use of &lt;code&gt;NPY_AO&lt;/code&gt; (deprecated) which is defined to be equivalent to &lt;a href=&quot;#c.PyArrayObject&quot;&gt;&lt;code&gt;PyArrayObject&lt;/code&gt;&lt;/a&gt;. Direct access to the struct fields are deprecated. Use the &lt;code&gt;PyArray_*(arr)&lt;/code&gt; form instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d2c044849f6b8be8bb6f06a8ac4ced885f369cf" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#c.PyArray_Descr&quot;&gt;&lt;code&gt;PyArray_Descr&lt;/code&gt;&lt;/a&gt; structure lies at the heart of the &lt;a href=&quot;#c.PyArrayDescr_Type&quot;&gt;&lt;code&gt;PyArrayDescr_Type&lt;/code&gt;&lt;/a&gt;. While it is described here for completeness, it should be considered internal to NumPy and manipulated via &lt;code&gt;PyArrayDescr_*&lt;/code&gt; or &lt;code&gt;PyDataType*&lt;/code&gt; functions and macros. The size of this structure is subject to change across versions of NumPy. To ensure compatibility:</source>
          <target state="translated">Структура &lt;a href=&quot;#c.PyArray_Descr&quot;&gt; &lt;code&gt;PyArray_Descr&lt;/code&gt; &lt;/a&gt; лежит в основе &lt;a href=&quot;#c.PyArrayDescr_Type&quot;&gt; &lt;code&gt;PyArrayDescr_Type&lt;/code&gt; &lt;/a&gt; . Хотя он описан здесь для полноты, его следует рассматривать как внутренний для NumPy и управлять им с помощью функций и макросов &lt;code&gt;PyArrayDescr_*&lt;/code&gt; или &lt;code&gt;PyDataType*&lt;/code&gt; . Размер этой структуры может меняться в разных версиях NumPy. Для обеспечения совместимости:</target>
        </trans-unit>
        <trans-unit id="2e3e60e01ee7ee0a4514d09bc8a1e601d0467625" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#c.PyArray_Type&quot;&gt;&lt;code&gt;PyArray_Type&lt;/code&gt;&lt;/a&gt; typeobject implements many of the features of &lt;a href=&quot;https://docs.python.org/dev/c-api/type.html#c.PyTypeObject&quot;&gt;&lt;code&gt;Python objects&lt;/code&gt;&lt;/a&gt; including the &lt;a href=&quot;https://docs.python.org/dev/c-api/typeobj.html#c.PyTypeObject.tp_as_number&quot;&gt;&lt;code&gt;tp_as_number&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://docs.python.org/dev/c-api/typeobj.html#c.PyTypeObject.tp_as_sequence&quot;&gt;&lt;code&gt;tp_as_sequence&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://docs.python.org/dev/c-api/typeobj.html#c.PyTypeObject.tp_as_mapping&quot;&gt;&lt;code&gt;tp_as_mapping&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;https://docs.python.org/dev/c-api/typeobj.html#c.PyTypeObject.tp_as_buffer&quot;&gt;&lt;code&gt;tp_as_buffer&lt;/code&gt;&lt;/a&gt; interfaces. The &lt;a href=&quot;https://docs.python.org/dev/c-api/typeobj.html#c.richcmpfunc&quot;&gt;&lt;code&gt;rich comparison&lt;/code&gt;&lt;/a&gt;) is also used along with new-style attribute lookup for member (&lt;a href=&quot;https://docs.python.org/dev/c-api/typeobj.html#c.PyTypeObject.tp_members&quot;&gt;&lt;code&gt;tp_members&lt;/code&gt;&lt;/a&gt;) and properties (&lt;a href=&quot;https://docs.python.org/dev/c-api/typeobj.html#c.PyTypeObject.tp_getset&quot;&gt;&lt;code&gt;tp_getset&lt;/code&gt;&lt;/a&gt;). The &lt;a href=&quot;#c.PyArray_Type&quot;&gt;&lt;code&gt;PyArray_Type&lt;/code&gt;&lt;/a&gt; can also be sub-typed.</source>
          <target state="translated">В &lt;a href=&quot;#c.PyArray_Type&quot;&gt; &lt;code&gt;PyArray_Type&lt;/code&gt; &lt;/a&gt; typeobject реализует многие из особенностей &lt;a href=&quot;https://docs.python.org/dev/c-api/type.html#c.PyTypeObject&quot;&gt; &lt;code&gt;Python objects&lt;/code&gt; &lt;/a&gt; , в том числе &lt;a href=&quot;https://docs.python.org/dev/c-api/typeobj.html#c.PyTypeObject.tp_as_number&quot;&gt; &lt;code&gt;tp_as_number&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;https://docs.python.org/dev/c-api/typeobj.html#c.PyTypeObject.tp_as_sequence&quot;&gt; &lt;code&gt;tp_as_sequence&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;https://docs.python.org/dev/c-api/typeobj.html#c.PyTypeObject.tp_as_mapping&quot;&gt; &lt;code&gt;tp_as_mapping&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;https://docs.python.org/dev/c-api/typeobj.html#c.PyTypeObject.tp_as_buffer&quot;&gt; &lt;code&gt;tp_as_buffer&lt;/code&gt; &lt;/a&gt; интерфейсы. Расширенное &lt;a href=&quot;https://docs.python.org/dev/c-api/typeobj.html#c.richcmpfunc&quot;&gt; &lt;code&gt;rich comparison&lt;/code&gt; &lt;/a&gt; ) также используется вместе с поиском атрибутов нового стиля для члена ( &lt;a href=&quot;https://docs.python.org/dev/c-api/typeobj.html#c.PyTypeObject.tp_members&quot;&gt; &lt;code&gt;tp_members&lt;/code&gt; &lt;/a&gt; ) и свойств ( &lt;a href=&quot;https://docs.python.org/dev/c-api/typeobj.html#c.PyTypeObject.tp_getset&quot;&gt; &lt;code&gt;tp_getset&lt;/code&gt; &lt;/a&gt; ). &lt;a href=&quot;#c.PyArray_Type&quot;&gt; &lt;code&gt;PyArray_Type&lt;/code&gt; &lt;/a&gt; также может быть суб-набран.</target>
        </trans-unit>
        <trans-unit id="aa6c6f999e9bb42f4a925a834755e66032534d3b" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#c.bitgen_t&quot;&gt;&lt;code&gt;bitgen_t&lt;/code&gt;&lt;/a&gt; holds the current state of the BitGenerator and pointers to functions that return standard C types while advancing the state.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a7f3033ad68411cb4e323558e1cdf3cb92ca263d" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#module-numpy.char&quot;&gt;&lt;code&gt;numpy.char&lt;/code&gt;&lt;/a&gt; module provides a set of vectorized string operations for arrays of type &lt;a href=&quot;arrays.scalars#numpy.str_&quot;&gt;&lt;code&gt;numpy.str_&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;arrays.scalars#numpy.bytes_&quot;&gt;&lt;code&gt;numpy.bytes_&lt;/code&gt;&lt;/a&gt;. All of them are based on the string methods in the Python standard library.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f2f36b5d156bf75520af226984583d62ec445b7c" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#module-numpy.char&quot;&gt;&lt;code&gt;numpy.char&lt;/code&gt;&lt;/a&gt; module provides a set of vectorized string operations for arrays of type &lt;code&gt;numpy.string_&lt;/code&gt; or &lt;code&gt;numpy.unicode_&lt;/code&gt;. All of them are based on the string methods in the Python standard library.</source>
          <target state="translated">Модуль &lt;a href=&quot;#module-numpy.char&quot;&gt; &lt;code&gt;numpy.char&lt;/code&gt; &lt;/a&gt; предоставляет набор векторизованных строковых операций для массивов типа &lt;code&gt;numpy.string_&lt;/code&gt; или &lt;code&gt;numpy.unicode_&lt;/code&gt; . Все они основаны на строковых методах стандартной библиотеки Python.</target>
        </trans-unit>
        <trans-unit id="2314014335c763a38d9f2613dc7158883ea47e7a" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#module-numpy.ma&quot;&gt;&lt;code&gt;numpy.ma&lt;/code&gt;&lt;/a&gt; module can be used as an addition to &lt;a href=&quot;index#module-numpy&quot;&gt;&lt;code&gt;numpy&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">Модуль &lt;a href=&quot;#module-numpy.ma&quot;&gt; &lt;code&gt;numpy.ma&lt;/code&gt; &lt;/a&gt; можно использовать как дополнение к &lt;a href=&quot;index#module-numpy&quot;&gt; &lt;code&gt;numpy&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="bc31921d14e06fe1077c1cf00e508c39081a2db7" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#module-numpy.ma&quot;&gt;&lt;code&gt;numpy.ma&lt;/code&gt;&lt;/a&gt; module comes with a specific implementation of most ufuncs. Unary and binary functions that have a validity domain (such as &lt;a href=&quot;generated/numpy.log#numpy.log&quot;&gt;&lt;code&gt;log&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;generated/numpy.divide#numpy.divide&quot;&gt;&lt;code&gt;divide&lt;/code&gt;&lt;/a&gt;) return the &lt;a href=&quot;maskedarray.baseclass#numpy.ma.masked&quot;&gt;&lt;code&gt;masked&lt;/code&gt;&lt;/a&gt; constant whenever the input is masked or falls outside the validity domain:</source>
          <target state="translated">Модуль &lt;a href=&quot;#module-numpy.ma&quot;&gt; &lt;code&gt;numpy.ma&lt;/code&gt; &lt;/a&gt; поставляется с конкретной реализацией большинства функций ufunc. Унарные и двоичные функции, у которых есть область допустимости (например, &lt;a href=&quot;generated/numpy.log#numpy.log&quot;&gt; &lt;code&gt;log&lt;/code&gt; &lt;/a&gt; или &lt;a href=&quot;generated/numpy.divide#numpy.divide&quot;&gt; &lt;code&gt;divide&lt;/code&gt; &lt;/a&gt; ), возвращают &lt;a href=&quot;maskedarray.baseclass#numpy.ma.masked&quot;&gt; &lt;code&gt;masked&lt;/code&gt; &lt;/a&gt; константу всякий раз, когда ввод замаскирован или выходит за пределы области допустимости:</target>
        </trans-unit>
        <trans-unit id="fa3b79ebc7390f266094dfbaf9c2d9e50cf1ca20" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#numpy.bool_&quot;&gt;&lt;code&gt;bool_&lt;/code&gt;&lt;/a&gt; data type is very similar to the Python &lt;a href=&quot;https://docs.python.org/dev/library/functions.html#bool&quot;&gt;&lt;code&gt;bool&lt;/code&gt;&lt;/a&gt; but does not inherit from it because Python&amp;rsquo;s &lt;a href=&quot;https://docs.python.org/dev/library/functions.html#bool&quot;&gt;&lt;code&gt;bool&lt;/code&gt;&lt;/a&gt; does not allow itself to be inherited from, and on the C-level the size of the actual bool data is not the same as a Python Boolean scalar.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8bb6355ecaeb41d5fc25266f7c26f41c7ee5179d" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#numpy.bool_&quot;&gt;&lt;code&gt;bool_&lt;/code&gt;&lt;/a&gt; type is not a subclass of the &lt;a href=&quot;#numpy.int_&quot;&gt;&lt;code&gt;int_&lt;/code&gt;&lt;/a&gt; type (the &lt;a href=&quot;#numpy.bool_&quot;&gt;&lt;code&gt;bool_&lt;/code&gt;&lt;/a&gt; is not even a number type). This is different than Python&amp;rsquo;s default implementation of &lt;a href=&quot;https://docs.python.org/dev/library/functions.html#bool&quot;&gt;&lt;code&gt;bool&lt;/code&gt;&lt;/a&gt; as a sub-class of &lt;a href=&quot;https://docs.python.org/dev/library/functions.html#int&quot;&gt;&lt;code&gt;int&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b2581729cb5a508c4225155bce5e9d0c211d34fc" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#numpy.char.chararray&quot;&gt;&lt;code&gt;chararray&lt;/code&gt;&lt;/a&gt; class exists for backwards compatibility with Numarray, it is not recommended for new development. Starting from numpy 1.4, if one needs arrays of strings, it is recommended to use arrays of &lt;a href=&quot;numpy.char.chararray.dtype#numpy.char.chararray.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt;&lt;code&gt;object_&lt;/code&gt;, &lt;code&gt;string_&lt;/code&gt; or &lt;code&gt;unicode_&lt;/code&gt;, and use the free functions in the &lt;a href=&quot;../routines.char#module-numpy.char&quot;&gt;&lt;code&gt;numpy.char&lt;/code&gt;&lt;/a&gt; module for fast vectorized string operations.</source>
          <target state="translated">Класс &lt;a href=&quot;#numpy.char.chararray&quot;&gt; &lt;code&gt;chararray&lt;/code&gt; &lt;/a&gt; существует для обратной совместимости с Numarray, он не рекомендуется для новых разработок. Начиная с numpy 1.4, если нужны массивы строк, рекомендуется использовать массивы &lt;a href=&quot;numpy.char.chararray.dtype#numpy.char.chararray.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt; &lt;code&gt;object_&lt;/code&gt; , &lt;code&gt;string_&lt;/code&gt; или &lt;code&gt;unicode_&lt;/code&gt; , а также использовать бесплатные функции в модуле &lt;a href=&quot;../routines.char#module-numpy.char&quot;&gt; &lt;code&gt;numpy.char&lt;/code&gt; &lt;/a&gt; для быстрых векторизованных строковых операций.</target>
        </trans-unit>
        <trans-unit id="bfd56b98bdff55bc0967f4255e8d608e0cada88c" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#numpy.char.chararray.flags&quot;&gt;&lt;code&gt;flags&lt;/code&gt;&lt;/a&gt; object can be accessed dictionary-like (as in &lt;code&gt;a.flags['WRITEABLE']&lt;/code&gt;), or by using lowercased attribute names (as in &lt;code&gt;a.flags.writeable&lt;/code&gt;). Short flag names are only supported in dictionary access.</source>
          <target state="translated">&lt;a href=&quot;#numpy.char.chararray.flags&quot;&gt; &lt;code&gt;flags&lt;/code&gt; &lt;/a&gt; объект может быть доступен по словарю , как (как в &lt;code&gt;a.flags['WRITEABLE']&lt;/code&gt; ), или с помощью строчных имен атрибутов (как в &lt;code&gt;a.flags.writeable&lt;/code&gt; ). Короткие имена флагов поддерживаются только при доступе к словарю.</target>
        </trans-unit>
        <trans-unit id="09be04e2f9d7e3507979d5970697a0d5b8afb3bd" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#numpy.chararray&quot;&gt;&lt;code&gt;chararray&lt;/code&gt;&lt;/a&gt; class exists for backwards compatibility with Numarray, it is not recommended for new development. Starting from numpy 1.4, if one needs arrays of strings, it is recommended to use arrays of &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt;&lt;a href=&quot;../arrays.scalars#numpy.object_&quot;&gt;&lt;code&gt;object_&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../arrays.scalars#numpy.string_&quot;&gt;&lt;code&gt;string_&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../arrays.scalars#numpy.unicode_&quot;&gt;&lt;code&gt;unicode_&lt;/code&gt;&lt;/a&gt;, and use the free functions in the &lt;a href=&quot;../routines.char#module-numpy.char&quot;&gt;&lt;code&gt;numpy.char&lt;/code&gt;&lt;/a&gt; module for fast vectorized string operations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b3e9186bfdffbf3c12bbb5a751b0411b0862a0b" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#numpy.chararray&quot;&gt;&lt;code&gt;chararray&lt;/code&gt;&lt;/a&gt; class exists for backwards compatibility with Numarray, it is not recommended for new development. Starting from numpy 1.4, if one needs arrays of strings, it is recommended to use arrays of &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt;&lt;code&gt;object_&lt;/code&gt;, &lt;code&gt;string_&lt;/code&gt; or &lt;code&gt;unicode_&lt;/code&gt;, and use the free functions in the &lt;a href=&quot;../routines.char#module-numpy.char&quot;&gt;&lt;code&gt;numpy.char&lt;/code&gt;&lt;/a&gt; module for fast vectorized string operations.</source>
          <target state="translated">Класс &lt;a href=&quot;#numpy.chararray&quot;&gt; &lt;code&gt;chararray&lt;/code&gt; &lt;/a&gt; существует для обратной совместимости с Numarray, он не рекомендуется для новых разработок. Начиная с numpy 1.4, если нужны массивы строк, рекомендуется использовать массивы &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt; &lt;code&gt;object_&lt;/code&gt; , &lt;code&gt;string_&lt;/code&gt; или &lt;code&gt;unicode_&lt;/code&gt; , а также использовать бесплатные функции в модуле &lt;a href=&quot;../routines.char#module-numpy.char&quot;&gt; &lt;code&gt;numpy.char&lt;/code&gt; &lt;/a&gt; для быстрых векторизованных строковых операций.</target>
        </trans-unit>
        <trans-unit id="680a1891b2c8f5bcdb98b3e8673e99320813b4a5" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#numpy.chararray.flags&quot;&gt;&lt;code&gt;flags&lt;/code&gt;&lt;/a&gt; object can be accessed dictionary-like (as in &lt;code&gt;a.flags['WRITEABLE']&lt;/code&gt;), or by using lowercased attribute names (as in &lt;code&gt;a.flags.writeable&lt;/code&gt;). Short flag names are only supported in dictionary access.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd3c89bd69aef7cd1fbb65d37b473ebbe78ede31" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#numpy.divmod&quot;&gt;&lt;code&gt;divmod&lt;/code&gt;&lt;/a&gt; function can be used as a shorthand for &lt;code&gt;np.divmod&lt;/code&gt; on ndarrays.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a4b36fc0eface1e15cca304b6a430b16f1e89759" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#numpy.int_&quot;&gt;&lt;code&gt;int_&lt;/code&gt;&lt;/a&gt; type does &lt;strong&gt;not&lt;/strong&gt; inherit from the &lt;a href=&quot;https://docs.python.org/dev/library/functions.html#int&quot;&gt;&lt;code&gt;int&lt;/code&gt;&lt;/a&gt; built-in under Python 3, because type &lt;a href=&quot;https://docs.python.org/dev/library/functions.html#int&quot;&gt;&lt;code&gt;int&lt;/code&gt;&lt;/a&gt; is no longer a fixed-width integer type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3c48c115471617c80e93a7432dc970b4f61e8b90" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#numpy.ma.MaskedArray.data&quot;&gt;&lt;code&gt;data&lt;/code&gt;&lt;/a&gt;, as a regular &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;numpy.ndarray&lt;/code&gt;&lt;/a&gt; of any shape or datatype (the data).</source>
          <target state="translated">&lt;a href=&quot;#numpy.ma.MaskedArray.data&quot;&gt; &lt;code&gt;data&lt;/code&gt; &lt;/a&gt; , как обычный &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;numpy.ndarray&lt;/code&gt; &lt;/a&gt; любой формы или типа данных (данные).</target>
        </trans-unit>
        <trans-unit id="a0df6452154474f3f899180d65ac301d22c1fea9" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#numpy.ma.MaskedArray.flags&quot;&gt;&lt;code&gt;flags&lt;/code&gt;&lt;/a&gt; object can be accessed dictionary-like (as in &lt;code&gt;a.flags['WRITEABLE']&lt;/code&gt;), or by using lowercased attribute names (as in &lt;code&gt;a.flags.writeable&lt;/code&gt;). Short flag names are only supported in dictionary access.</source>
          <target state="translated">&lt;a href=&quot;#numpy.ma.MaskedArray.flags&quot;&gt; &lt;code&gt;flags&lt;/code&gt; &lt;/a&gt; объект может быть доступен по словарю , как (как в &lt;code&gt;a.flags['WRITEABLE']&lt;/code&gt; ), или с помощью строчных имен атрибутов (как в &lt;code&gt;a.flags.writeable&lt;/code&gt; ). Короткие имена флагов поддерживаются только при доступе к словарю.</target>
        </trans-unit>
        <trans-unit id="768878a0d288c4cac805d022d60e3e5c74cdd571" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#numpy.ma.masked&quot;&gt;&lt;code&gt;masked&lt;/code&gt;&lt;/a&gt; constant is a special case of &lt;a href=&quot;#numpy.ma.MaskedArray&quot;&gt;&lt;code&gt;MaskedArray&lt;/code&gt;&lt;/a&gt;, with a float datatype and a null shape. It is used to test whether a specific entry of a masked array is masked, or to mask one or several entries of a masked array:</source>
          <target state="translated">&lt;a href=&quot;#numpy.ma.masked&quot;&gt; &lt;code&gt;masked&lt;/code&gt; &lt;/a&gt; константа представляет собой частный случай &lt;a href=&quot;#numpy.ma.MaskedArray&quot;&gt; &lt;code&gt;MaskedArray&lt;/code&gt; &lt;/a&gt; , с поплавком типом данными и формой нуля. Он используется для проверки того, замаскирована ли конкретная запись замаскированного массива, или для маскировки одной или нескольких записей замаскированного массива:</target>
        </trans-unit>
        <trans-unit id="7aed7dc2945cfed4e354b7948f5becc4b487bdfa" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#numpy.ma.masked_array.flags&quot;&gt;&lt;code&gt;flags&lt;/code&gt;&lt;/a&gt; object can be accessed dictionary-like (as in &lt;code&gt;a.flags['WRITEABLE']&lt;/code&gt;), or by using lowercased attribute names (as in &lt;code&gt;a.flags.writeable&lt;/code&gt;). Short flag names are only supported in dictionary access.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="146a5b50c3ebb2fb745630d24192949df345a171" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#numpy.matrix.flags&quot;&gt;&lt;code&gt;flags&lt;/code&gt;&lt;/a&gt; object can be accessed dictionary-like (as in &lt;code&gt;a.flags['WRITEABLE']&lt;/code&gt;), or by using lowercased attribute names (as in &lt;code&gt;a.flags.writeable&lt;/code&gt;). Short flag names are only supported in dictionary access.</source>
          <target state="translated">&lt;a href=&quot;#numpy.matrix.flags&quot;&gt; &lt;code&gt;flags&lt;/code&gt; &lt;/a&gt; объект может быть доступен по словарю , как (как в &lt;code&gt;a.flags['WRITEABLE']&lt;/code&gt; ), или с помощью строчных имен атрибутов (как в &lt;code&gt;a.flags.writeable&lt;/code&gt; ). Короткие имена флагов поддерживаются только при доступе к словарю.</target>
        </trans-unit>
        <trans-unit id="3f13797b1afe52954d80b3598ced06b92d07000d" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#numpy.memmap.flags&quot;&gt;&lt;code&gt;flags&lt;/code&gt;&lt;/a&gt; object can be accessed dictionary-like (as in &lt;code&gt;a.flags['WRITEABLE']&lt;/code&gt;), or by using lowercased attribute names (as in &lt;code&gt;a.flags.writeable&lt;/code&gt;). Short flag names are only supported in dictionary access.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="59336961ce31b9039ac38b42d5319606fa0f917b" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#numpy.ndarray.flags&quot;&gt;&lt;code&gt;flags&lt;/code&gt;&lt;/a&gt; object can be accessed dictionary-like (as in &lt;code&gt;a.flags['WRITEABLE']&lt;/code&gt;), or by using lowercased attribute names (as in &lt;code&gt;a.flags.writeable&lt;/code&gt;). Short flag names are only supported in dictionary access.</source>
          <target state="translated">&lt;a href=&quot;#numpy.ndarray.flags&quot;&gt; &lt;code&gt;flags&lt;/code&gt; &lt;/a&gt; объект может быть доступен по словарю , как (как в &lt;code&gt;a.flags['WRITEABLE']&lt;/code&gt; ), или с помощью строчных имен атрибутов (как в &lt;code&gt;a.flags.writeable&lt;/code&gt; ). Короткие имена флагов поддерживаются только при доступе к словарю.</target>
        </trans-unit>
        <trans-unit id="6d0bd00bbf169f78d9e7d2f8db44466c1472859d" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#numpy.random.Generator&quot;&gt;&lt;code&gt;Generator&lt;/code&gt;&lt;/a&gt; provides access to a wide range of distributions, and served as a replacement for &lt;a href=&quot;legacy#numpy.random.RandomState&quot;&gt;&lt;code&gt;RandomState&lt;/code&gt;&lt;/a&gt;. The main difference between the two is that &lt;code&gt;Generator&lt;/code&gt; relies on an additional BitGenerator to manage state and generate the random bits, which are then transformed into random values from useful distributions. The default BitGenerator used by &lt;code&gt;Generator&lt;/code&gt; is &lt;a href=&quot;bit_generators/pcg64#numpy.random.PCG64&quot;&gt;&lt;code&gt;PCG64&lt;/code&gt;&lt;/a&gt;. The BitGenerator can be changed by passing an instantized BitGenerator to &lt;code&gt;Generator&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="550894140eb6b413b0c8bb49cded0a5d50198b4c" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#numpy.random.Generator&quot;&gt;&lt;code&gt;Generator&lt;/code&gt;&lt;/a&gt; provides access to a wide range of distributions, and served as a replacement for &lt;code&gt;RandomState&lt;/code&gt;. The main difference between the two is that &lt;code&gt;Generator&lt;/code&gt; relies on an additional BitGenerator to manage state and generate the random bits, which are then transformed into random values from useful distributions. The default BitGenerator used by &lt;code&gt;Generator&lt;/code&gt; is &lt;code&gt;PCG64&lt;/code&gt;. The BitGenerator can be changed by passing an instantized BitGenerator to &lt;code&gt;Generator&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;#numpy.random.Generator&quot;&gt; &lt;code&gt;Generator&lt;/code&gt; &lt;/a&gt; обеспечивает доступ к широкому спектру распределений, и служил в качестве замены для &lt;code&gt;RandomState&lt;/code&gt; . Основное различие между ними заключается в том, что &lt;code&gt;Generator&lt;/code&gt; полагается на дополнительный BitGenerator для управления состоянием и генерации случайных битов, которые затем преобразуются в случайные значения из полезных распределений. По умолчанию BitGenerator используется &lt;code&gt;Generator&lt;/code&gt; является &lt;code&gt;PCG64&lt;/code&gt; . BitGenerator можно изменить, передав экземпляр BitGenerator в &lt;code&gt;Generator&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f79d27f6e9c849366cec196aa3ca02a3888f3ef3" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#numpy.random.RandomState&quot;&gt;&lt;code&gt;RandomState&lt;/code&gt;&lt;/a&gt; provides access to legacy generators. This generator is considered frozen and will have no further improvements. It is guaranteed to produce the same values as the final point release of NumPy v1.16. These all depend on Box-Muller normals or inverse CDF exponentials or gammas. This class should only be used if it is essential to have randoms that are identical to what would have been produced by previous versions of NumPy.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c4a823e24105a263472e6db5aa11ef1abc5d69b0" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#numpy.random.mtrand.RandomState&quot;&gt;&lt;code&gt;RandomState&lt;/code&gt;&lt;/a&gt; provides access to legacy generators. This generator is considered frozen and will have no further improvements. It is guaranteed to produce the same values as the final point release of NumPy v1.16. These all depend on Box-Muller normals or inverse CDF exponentials or gammas. This class should only be used if it is essential to have randoms that are identical to what would have been produced by previous versions of NumPy.</source>
          <target state="translated">&lt;a href=&quot;#numpy.random.mtrand.RandomState&quot;&gt; &lt;code&gt;RandomState&lt;/code&gt; &lt;/a&gt; обеспечивает доступ к унаследованным генераторам. Этот генератор считается замороженным и не будет улучшаться. Гарантируется, что будут получены те же значения, что и в финальной версии NumPy v1.16. Все они зависят от нормалей Бокса-Мюллера или обратных экспонент или гамм CDF. Этот класс следует использовать только в том случае, если необходимо иметь случайные числа, идентичные тому, что было бы создано предыдущими версиями NumPy.</target>
        </trans-unit>
        <trans-unit id="81979ac862ad90b476e52b55f8477208f98b95b1" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#numpy.recarray.flags&quot;&gt;&lt;code&gt;flags&lt;/code&gt;&lt;/a&gt; object can be accessed dictionary-like (as in &lt;code&gt;a.flags['WRITEABLE']&lt;/code&gt;), or by using lowercased attribute names (as in &lt;code&gt;a.flags.writeable&lt;/code&gt;). Short flag names are only supported in dictionary access.</source>
          <target state="translated">&lt;a href=&quot;#numpy.recarray.flags&quot;&gt; &lt;code&gt;flags&lt;/code&gt; &lt;/a&gt; объект может быть доступен по словарю , как (как в &lt;code&gt;a.flags['WRITEABLE']&lt;/code&gt; ), или с помощью строчных имен атрибутов (как в &lt;code&gt;a.flags.writeable&lt;/code&gt; ). Короткие имена флагов поддерживаются только при доступе к словарю.</target>
        </trans-unit>
        <trans-unit id="84da36ced33272fa147152f5a355ea7313e10b52" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#numpy.sign&quot;&gt;&lt;code&gt;sign&lt;/code&gt;&lt;/a&gt; function returns &lt;code&gt;-1 if x &amp;lt; 0, 0 if x==0, 1 if x &amp;gt; 0&lt;/code&gt;. nan is returned for nan inputs.</source>
          <target state="translated">В &lt;a href=&quot;#numpy.sign&quot;&gt; &lt;code&gt;sign&lt;/code&gt; &lt;/a&gt; функция возвращает &lt;code&gt;-1 if x &amp;lt; 0, 0 if x==0, 1 if x &amp;gt; 0&lt;/code&gt; . nan возвращается для входов nan.</target>
        </trans-unit>
        <trans-unit id="158d36e54da803a47a7693e104765168fbd40d0b" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#numpy.testing.dec.deprecated&quot;&gt;&lt;code&gt;deprecated&lt;/code&gt;&lt;/a&gt; decorator itself.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c8f5bdf7e480a14edfbd94978da2fd35d2b6fd26" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#numpy.testing.decorators.deprecated&quot;&gt;&lt;code&gt;deprecated&lt;/code&gt;&lt;/a&gt; decorator itself.</source>
          <target state="translated">Сам &lt;a href=&quot;#numpy.testing.decorators.deprecated&quot;&gt; &lt;code&gt;deprecated&lt;/code&gt; &lt;/a&gt; декоратор.</target>
        </trans-unit>
        <trans-unit id="bc50ca3a4518970647f9ac3d39890db20ed25800" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#numpy.typing.ArrayLike&quot;&gt;&lt;code&gt;ArrayLike&lt;/code&gt;&lt;/a&gt; type tries to avoid creating object arrays. For example,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da249e1d126343fd0059e721337a79a20ba3ee7c" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#numpy.typing.DTypeLike&quot;&gt;&lt;code&gt;DTypeLike&lt;/code&gt;&lt;/a&gt; type tries to avoid creation of dtype objects using dictionary of fields like below:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f00c158e6b19c749648df9ba6c6e65d03c7d496b" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#numpy.vectorize&quot;&gt;&lt;code&gt;vectorize&lt;/code&gt;&lt;/a&gt; function is provided primarily for convenience, not for performance. The implementation is essentially a for loop.</source>
          <target state="translated">Функция &lt;a href=&quot;#numpy.vectorize&quot;&gt; &lt;code&gt;vectorize&lt;/code&gt; &lt;/a&gt; предназначена в первую очередь для удобства, а не для повышения производительности. Реализация по сути представляет собой цикл for.</target>
        </trans-unit>
        <trans-unit id="5870961c86339efdff46c3532a51705af2f592f0" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../arrays.datetime#arrays-dtypes-dateunits&quot;&gt;datetime unit&lt;/a&gt; on which this dtype is based.</source>
          <target state="translated">&lt;a href=&quot;../arrays.datetime#arrays-dtypes-dateunits&quot;&gt;DateTime модуль&lt;/a&gt; , на котором основан этот DTYPE.</target>
        </trans-unit>
        <trans-unit id="9a8f8d0455dbf7ee235ddf8ac19ee0fef4868e46" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../reference/c-api/array#c.PyArray_IterAllButAxis&quot;&gt;&lt;code&gt;PyArray_IterAllButAxis&lt;/code&gt;&lt;/a&gt; ( &lt;code&gt;array&lt;/code&gt;, &lt;code&gt;&amp;amp;dim&lt;/code&gt; ) constructs an iterator object that is modified so that it will not iterate over the dimension indicated by dim. The only restriction on this iterator object, is that the &lt;a href=&quot;../reference/c-api/array#c.PyArray_ITER_GOTO1D&quot;&gt;&lt;code&gt;PyArray_ITER_GOTO1D&lt;/code&gt;&lt;/a&gt; ( &lt;code&gt;it&lt;/code&gt;, &lt;code&gt;ind&lt;/code&gt; ) macro cannot be used (thus flat indexing won&amp;rsquo;t work either if you pass this object back to Python &amp;mdash; so you shouldn&amp;rsquo;t do this). Note that the returned object from this routine is still usually cast to PyArrayIterObject *. All that&amp;rsquo;s been done is to modify the strides and dimensions of the returned iterator to simulate iterating over array[&amp;hellip;,0,&amp;hellip;] where 0 is placed on the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3bf8c2953924a9568aac6e665e279dc1312c55ef" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../reference/c-api/array#c.PyArray_IterAllButAxis&quot;&gt;&lt;code&gt;PyArray_IterAllButAxis&lt;/code&gt;&lt;/a&gt; ( &lt;code&gt;array&lt;/code&gt;, &lt;code&gt;&amp;amp;dim&lt;/code&gt; ) constructs an iterator object that is modified so that it will not iterate over the dimension indicated by dim. The only restriction on this iterator object, is that the &lt;code&gt;PyArray_Iter_GOTO1D&lt;/code&gt; ( &lt;code&gt;it&lt;/code&gt;, &lt;code&gt;ind&lt;/code&gt; ) macro cannot be used (thus flat indexing won&amp;rsquo;t work either if you pass this object back to Python &amp;mdash; so you shouldn&amp;rsquo;t do this). Note that the returned object from this routine is still usually cast to PyArrayIterObject *. All that&amp;rsquo;s been done is to modify the strides and dimensions of the returned iterator to simulate iterating over array[&amp;hellip;,0,&amp;hellip;] where 0 is placed on the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bdc8c909824e69cdd63045d775139e4bf32c31d6" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../reference/generated/numpy.genfromtxt#numpy.genfromtxt&quot;&gt;&lt;code&gt;genfromtxt&lt;/code&gt;&lt;/a&gt; function provides two other complementary mechanisms: the &lt;code&gt;missing_values&lt;/code&gt; argument is used to recognize missing data and a second argument, &lt;code&gt;filling_values&lt;/code&gt;, is used to process these missing data.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="26c941be06c3bf21e3b8632eab293bedde5eb0c6" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../reference/generated/numpy.ix_#numpy.ix_&quot;&gt;&lt;code&gt;ix_&lt;/code&gt;&lt;/a&gt; function can be used to combine different vectors so as to obtain the result for each n-uplet. For example, if you want to compute all the a+b*c for all the triplets taken from each of the vectors a, b and c:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7647b692ad78d569f80f8f518b4edab8e65fa5cd" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../reference/generated/numpy.reshape#numpy.reshape&quot;&gt;&lt;code&gt;reshape&lt;/code&gt;&lt;/a&gt; function returns its argument with a modified shape, whereas the &lt;a href=&quot;../reference/generated/numpy.ndarray.resize#numpy.ndarray.resize&quot;&gt;&lt;code&gt;ndarray.resize&lt;/code&gt;&lt;/a&gt; method modifies the array itself:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="28dfdb3c00777ce3fdb3f61c50c67ab257910e81" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../reference/routines.linalg#module-numpy.linalg&quot;&gt;&lt;code&gt;linalg&lt;/code&gt;&lt;/a&gt; module includes a &lt;code&gt;norm&lt;/code&gt; function, which computes the norm of a vector or matrix represented in a NumPy array. For example, from the SVD explanation above, we would expect the norm of the difference between &lt;code&gt;img_gray&lt;/code&gt; and the reconstructed SVD product to be small. As expected, you should see something like</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a98bd2e9d383259ba90aad2f3b46a4c0ddbbec99" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../routines.testing#module-numpy.testing&quot;&gt;&lt;code&gt;numpy.testing&lt;/code&gt;&lt;/a&gt; module includes &lt;code&gt;import decorators as dec&lt;/code&gt;. A test can be decorated as slow like this:</source>
          <target state="translated">Модуль &lt;a href=&quot;../routines.testing#module-numpy.testing&quot;&gt; &lt;code&gt;numpy.testing&lt;/code&gt; &lt;/a&gt; включает &lt;code&gt;import decorators as dec&lt;/code&gt; . Тест можно оформить так медленно:</target>
        </trans-unit>
        <trans-unit id="de30aba764dee819e88bbb9fb0c475c23aa5f7b0" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;arrays.scalars#numpy.timedelta64&quot;&gt;&lt;code&gt;timedelta64&lt;/code&gt;&lt;/a&gt; class is not considered a subclass of &lt;a href=&quot;arrays.scalars#numpy.signedinteger&quot;&gt;&lt;code&gt;signedinteger&lt;/code&gt;&lt;/a&gt;, the former only inheriting from &lt;a href=&quot;arrays.scalars#numpy.generic&quot;&gt;&lt;code&gt;generic&lt;/code&gt;&lt;/a&gt; while static type checking.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="081ce1a530a1e04a18f2e8f054e26ae81b0c4d57" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;bit_generators/generated/numpy.random.bitgenerator#numpy.random.BitGenerator&quot;&gt;&lt;code&gt;BitGenerator&lt;/code&gt;&lt;/a&gt; has a limited set of responsibilities. It manages state and provides functions to produce random doubles and random unsigned 32- and 64-bit values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c4d94d478ef39d11efc586cafc38818b04af19cb" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c-api.array#c.PyArray_Broadcast&quot;&gt;&lt;code&gt;PyArray_Broadcast&lt;/code&gt;&lt;/a&gt; function takes the iterators that have already been defined and uses them to determine the broadcast shape in each dimension (to create the iterators at the same time that broadcasting occurs then use the &lt;code&gt;PyMultiIter_New&lt;/code&gt; function). Then, the iterators are adjusted so that each iterator thinks it is iterating over an array with the broadcast size. This is done by adjusting the iterators number of dimensions, and the shape in each dimension. This works because the iterator strides are also adjusted. Broadcasting only adjusts (or adds) length-1 dimensions. For these dimensions, the strides variable is simply set to 0 so that the data-pointer for the iterator over that array doesn&amp;rsquo;t move as the broadcasting operation operates over the extended dimension.</source>
          <target state="translated">Функция &lt;a href=&quot;c-api.array#c.PyArray_Broadcast&quot;&gt; &lt;code&gt;PyArray_Broadcast&lt;/code&gt; &lt;/a&gt; принимает итераторы, которые уже были определены, и использует их для определения формы широковещательной передачи в каждом измерении (для создания итераторов одновременно с широковещательной передачей используйте функцию &lt;code&gt;PyMultiIter_New&lt;/code&gt; ). Затем итераторы настраиваются таким образом, чтобы каждый итератор считал, что выполняет итерацию по массиву с широковещательным размером. Это делается путем настройки количества измерений итераторов и формы в каждом измерении. Это работает, потому что шаги итератора также регулируются. Трансляция только корректирует (или добавляет) размерность длины 1. Для этих измерений переменная strides просто устанавливается в 0, чтобы указатель данных для итератора по этому массиву не перемещался, когда операция широковещательной передачи работает в расширенном измерении.</target>
        </trans-unit>
        <trans-unit id="c97c8834f84b1e523aa39964fc0db10088004e6f" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c-api/array#c.PyArray_Broadcast&quot;&gt;&lt;code&gt;PyArray_Broadcast&lt;/code&gt;&lt;/a&gt; function takes the iterators that have already been defined and uses them to determine the broadcast shape in each dimension (to create the iterators at the same time that broadcasting occurs then use the &lt;a href=&quot;c-api/array#c.PyArray_MultiIterNew&quot;&gt;&lt;code&gt;PyArray_MultiIterNew&lt;/code&gt;&lt;/a&gt; function). Then, the iterators are adjusted so that each iterator thinks it is iterating over an array with the broadcast size. This is done by adjusting the iterators number of dimensions, and the shape in each dimension. This works because the iterator strides are also adjusted. Broadcasting only adjusts (or adds) length-1 dimensions. For these dimensions, the strides variable is simply set to 0 so that the data-pointer for the iterator over that array doesn&amp;rsquo;t move as the broadcasting operation operates over the extended dimension.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="725a4957fd19b096134c24b6194f54dd74c72c01" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c-api/array#c.PyArray_Broadcast&quot;&gt;&lt;code&gt;PyArray_Broadcast&lt;/code&gt;&lt;/a&gt; function takes the iterators that have already been defined and uses them to determine the broadcast shape in each dimension (to create the iterators at the same time that broadcasting occurs then use the &lt;code&gt;PyMultiIter_New&lt;/code&gt; function). Then, the iterators are adjusted so that each iterator thinks it is iterating over an array with the broadcast size. This is done by adjusting the iterators number of dimensions, and the shape in each dimension. This works because the iterator strides are also adjusted. Broadcasting only adjusts (or adds) length-1 dimensions. For these dimensions, the strides variable is simply set to 0 so that the data-pointer for the iterator over that array doesn&amp;rsquo;t move as the broadcasting operation operates over the extended dimension.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ebbc509274309886438bbf3a6fbee60f4ccccb56" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c-api/types-and-structures#c.PyArrayInterface&quot;&gt;&lt;code&gt;PyArrayInterface&lt;/code&gt;&lt;/a&gt; structure is defined in &lt;code&gt;numpy/ndarrayobject.h&lt;/code&gt; as:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d36f842f2997c8193b726b30df3debd673ecb729" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;constants#numpy.newaxis&quot;&gt;&lt;code&gt;newaxis&lt;/code&gt;&lt;/a&gt; object can be used in all slicing operations to create an axis of length one. &lt;a href=&quot;constants#numpy.newaxis&quot;&gt;&lt;code&gt;newaxis&lt;/code&gt;&lt;/a&gt; is an alias for &amp;lsquo;None&amp;rsquo;, and &amp;lsquo;None&amp;rsquo; can be used in place of this with the same result.</source>
          <target state="translated">Объект &lt;a href=&quot;constants#numpy.newaxis&quot;&gt; &lt;code&gt;newaxis&lt;/code&gt; &lt;/a&gt; можно использовать во всех операциях нарезки для создания оси длины один. &lt;a href=&quot;constants#numpy.newaxis&quot;&gt; &lt;code&gt;newaxis&lt;/code&gt; &lt;/a&gt; - это псевдоним для &amp;laquo;None&amp;raquo;, и &amp;laquo;None&amp;raquo; может использоваться вместо этого с тем же результатом.</target>
        </trans-unit>
        <trans-unit id="cc1b8dc088cfaeaf7d1c0a0d0771b79ef43d8e56" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;generated/numpy.chararray#numpy.chararray&quot;&gt;&lt;code&gt;chararray&lt;/code&gt;&lt;/a&gt; class exists for backwards compatibility with Numarray, it is not recommended for new development. Starting from numpy 1.4, if one needs arrays of strings, it is recommended to use arrays of &lt;a href=&quot;generated/numpy.dtype#numpy.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt;&lt;a href=&quot;arrays.scalars#numpy.object_&quot;&gt;&lt;code&gt;object_&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;arrays.scalars#numpy.bytes_&quot;&gt;&lt;code&gt;bytes_&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;arrays.scalars#numpy.str_&quot;&gt;&lt;code&gt;str_&lt;/code&gt;&lt;/a&gt;, and use the free functions in the &lt;a href=&quot;routines.char#module-numpy.char&quot;&gt;&lt;code&gt;numpy.char&lt;/code&gt;&lt;/a&gt; module for fast vectorized string operations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="149f4058a1754093961b02f9ea6b9d5dd9c10925" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;generated/numpy.chararray#numpy.chararray&quot;&gt;&lt;code&gt;chararray&lt;/code&gt;&lt;/a&gt; class exists for backwards compatibility with Numarray, it is not recommended for new development. Starting from numpy 1.4, if one needs arrays of strings, it is recommended to use arrays of &lt;a href=&quot;generated/numpy.dtype#numpy.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt;&lt;code&gt;object_&lt;/code&gt;, &lt;code&gt;string_&lt;/code&gt; or &lt;code&gt;unicode_&lt;/code&gt;, and use the free functions in the &lt;a href=&quot;routines.char#module-numpy.char&quot;&gt;&lt;code&gt;numpy.char&lt;/code&gt;&lt;/a&gt; module for fast vectorized string operations.</source>
          <target state="translated">Класс &lt;a href=&quot;generated/numpy.chararray#numpy.chararray&quot;&gt; &lt;code&gt;chararray&lt;/code&gt; &lt;/a&gt; существует для обратной совместимости с Numarray, он не рекомендуется для новых разработок. Начиная с numpy 1.4, если нужны массивы строк, рекомендуется использовать массивы &lt;a href=&quot;generated/numpy.dtype#numpy.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt; &lt;code&gt;object_&lt;/code&gt; , &lt;code&gt;string_&lt;/code&gt; или &lt;code&gt;unicode_&lt;/code&gt; , а также использовать бесплатные функции в модуле &lt;a href=&quot;routines.char#module-numpy.char&quot;&gt; &lt;code&gt;numpy.char&lt;/code&gt; &lt;/a&gt; для быстрых векторизованных строковых операций.</target>
        </trans-unit>
        <trans-unit id="f9537bf435fae2ec4edc2520b8aeb23abd0ca21e" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt; can be inherited from (in Python or in C) if desired. Therefore, it can form a foundation for many useful classes. Often whether to sub-class the array object or to simply use the core array component as an internal part of a new class is a difficult decision, and can be simply a matter of choice. NumPy has several tools for simplifying how your new object interacts with other array objects, and so the choice may not be significant in the end. One way to simplify the question is by asking yourself if the object you are interested in can be replaced as a single array or does it really require two or more arrays at its core.</source>
          <target state="translated">При &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt; может быть унаследован от (в Python или C). Следовательно, он может стать основой для многих полезных классов. Часто вопрос о том, следует ли подклассифицировать объект массива или просто использовать основной компонент массива как внутреннюю часть нового класса, является трудным решением и может быть просто вопросом выбора. В NumPy есть несколько инструментов для упрощения взаимодействия вашего нового объекта с другими объектами массива, поэтому в конечном итоге выбор может быть несущественным. Один из способов упростить вопрос - спросить себя, можно ли заменить интересующий вас объект как единый массив или действительно ли для этого требуется два или более массивов в своей основе.</target>
        </trans-unit>
        <trans-unit id="c0cd171dc2a149543f352698d4bc596e7f8afac8" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;generated/numpy.nditer#numpy.nditer&quot;&gt;&lt;code&gt;nditer&lt;/code&gt;&lt;/a&gt; will try to provide chunks that are as large as possible to the inner loop. By forcing &amp;lsquo;C&amp;rsquo; and &amp;lsquo;F&amp;rsquo; order, we get different external loop sizes. This mode is enabled by specifying an iterator flag.</source>
          <target state="translated">&lt;a href=&quot;generated/numpy.nditer#numpy.nditer&quot;&gt; &lt;code&gt;nditer&lt;/code&gt; &lt;/a&gt; будет пытаться обеспечить куски, которые как можно больше , чтобы внутренний цикл. Установив порядок &amp;laquo;C&amp;raquo; и &amp;laquo;F&amp;raquo;, мы получаем разные размеры внешних петель. Этот режим включается указанием флага итератора.</target>
        </trans-unit>
        <trans-unit id="60bea32ad7ce3442c75308b468830ac8ceb23fe9" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;generator#numpy.random.Generator&quot;&gt;&lt;code&gt;Generator&lt;/code&gt;&lt;/a&gt; is the user-facing object that is nearly identical to &lt;a href=&quot;legacy#numpy.random.RandomState&quot;&gt;&lt;code&gt;RandomState&lt;/code&gt;&lt;/a&gt;. The canonical method to initialize a generator passes a &lt;a href=&quot;bit_generators/pcg64#numpy.random.PCG64&quot;&gt;&lt;code&gt;PCG64&lt;/code&gt;&lt;/a&gt; bit generator as the sole argument.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f0287b2a9be936e86bf33e5d1e69557ad4042b14" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;generator#numpy.random.Generator&quot;&gt;&lt;code&gt;Generator&lt;/code&gt;&lt;/a&gt; is the user-facing object that is nearly identical to &lt;a href=&quot;legacy#numpy.random.mtrand.RandomState&quot;&gt;&lt;code&gt;RandomState&lt;/code&gt;&lt;/a&gt;. The canonical method to initialize a generator passes a &lt;a href=&quot;bit_generators/pcg64#numpy.random.pcg64.PCG64&quot;&gt;&lt;code&gt;PCG64&lt;/code&gt;&lt;/a&gt; bit generator as the sole argument.</source>
          <target state="translated">&lt;a href=&quot;generator#numpy.random.Generator&quot;&gt; &lt;code&gt;Generator&lt;/code&gt; &lt;/a&gt; является пользователем перед объектом , который почти идентичен &lt;a href=&quot;legacy#numpy.random.mtrand.RandomState&quot;&gt; &lt;code&gt;RandomState&lt;/code&gt; &lt;/a&gt; . Канонический метод инициализации генератора передает битовый генератор &lt;a href=&quot;bit_generators/pcg64#numpy.random.pcg64.PCG64&quot;&gt; &lt;code&gt;PCG64&lt;/code&gt; &lt;/a&gt; в качестве единственного аргумента.</target>
        </trans-unit>
        <trans-unit id="3f1db6cd813b8bcecf8e6a0fb5885a478eae7000" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;generator#numpy.random.Generator&quot;&gt;&lt;code&gt;Generator&lt;/code&gt;&lt;/a&gt; is the user-facing object that is nearly identical to the legacy &lt;a href=&quot;legacy#numpy.random.RandomState&quot;&gt;&lt;code&gt;RandomState&lt;/code&gt;&lt;/a&gt;. It accepts a bit generator instance as an argument. The default is currently &lt;a href=&quot;bit_generators/pcg64#numpy.random.PCG64&quot;&gt;&lt;code&gt;PCG64&lt;/code&gt;&lt;/a&gt; but this may change in future versions. As a convenience NumPy provides the &lt;a href=&quot;generator#numpy.random.default_rng&quot;&gt;&lt;code&gt;default_rng&lt;/code&gt;&lt;/a&gt; function to hide these details:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a44536d85a990a438123d796af5725162190334f" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;generator#numpy.random.Generator&quot;&gt;&lt;code&gt;random generator&lt;/code&gt;&lt;/a&gt; takes the bit generator-provided stream and transforms them into more useful distributions, e.g., simulated normal random values. This structure allows alternative bit generators to be used with little code duplication.</source>
          <target state="translated">&lt;a href=&quot;generator#numpy.random.Generator&quot;&gt; &lt;code&gt;random generator&lt;/code&gt; &lt;/a&gt; принимает поток разр дного генератора, при условии , и преобразует их в более полезные распределения, например, моделируемых нормальные случайные величины. Эта структура позволяет использовать альтернативные битовые генераторы с небольшим дублированием кода.</target>
        </trans-unit>
        <trans-unit id="65fbb3e3590895ec54d650742d5a8544c871fca6" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://tom.preston-werner.com/2009/05/19/the-git-parable.html&quot;&gt;git parable&lt;/a&gt; is an easy read explaining the concepts behind git.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f7f755efceb36d8200d20dc31c04e76cd3c9faf2" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://www.swig.org&quot;&gt;SWIG&lt;/a&gt; type checking and conversion system is a complicated combination of C macros, &lt;a href=&quot;http://www.swig.org&quot;&gt;SWIG&lt;/a&gt; macros, &lt;a href=&quot;http://www.swig.org&quot;&gt;SWIG&lt;/a&gt; typemaps and &lt;a href=&quot;http://www.swig.org&quot;&gt;SWIG&lt;/a&gt; fragments. Fragments are a way to conditionally insert code into your wrapper file if it is needed, and not insert it if not needed. If multiple typemaps require the same fragment, the fragment only gets inserted into your wrapper code once.</source>
          <target state="translated">&lt;a href=&quot;http://www.swig.org&quot;&gt;ГЛОТОК&lt;/a&gt; проверки типа и преобразования система представляет собой сложное сочетание макросов C, &lt;a href=&quot;http://www.swig.org&quot;&gt;Swig&lt;/a&gt; макросов, &lt;a href=&quot;http://www.swig.org&quot;&gt;Swig&lt;/a&gt; typemaps и &lt;a href=&quot;http://www.swig.org&quot;&gt;Swig&lt;/a&gt; фрагментов. Фрагменты - это способ условно вставить код в файл-оболочку, если он необходим, и не вставлять его, если он не нужен. Если для нескольких карт типов требуется один и тот же фрагмент, этот фрагмент вставляется в код оболочки только один раз.</target>
        </trans-unit>
        <trans-unit id="03230fc37f6936da8ac6bdd751efc6bea8b56636" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://book.git-scm.com/&quot;&gt;git community book&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5936a1cdd9fb41f86db8cb5d458a0fab18964b44" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://docs.python.org/dev/library/functions.html#abs&quot;&gt;&lt;code&gt;abs&lt;/code&gt;&lt;/a&gt; function can be used as a shorthand for &lt;code&gt;np.absolute&lt;/code&gt; on ndarrays.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2a0a2b61ac5cec04459e6745c23a016af8875dce" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://docs.python.org/dev/library/stdtypes.html#bltin-boolean-values&quot;&gt;boolean objects&lt;/a&gt; in Python are &lt;code&gt;True&lt;/code&gt; and &lt;code&gt;False&lt;/code&gt;, as opposed to MATLAB logical types of &lt;code&gt;1&lt;/code&gt; and &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="81e8045e59daf616aee34810d48dbb7db178f9f3" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://docs.python.org/tutorial/&quot;&gt;Python tutorial&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e3ce3d1a866c8fe3ec8d4e7bfc02ebc4b98d4d1c" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://git-scm.com/book/&quot;&gt;pro git book&lt;/a&gt; is a good in-depth book on git.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c5b683753cdf3b551962126ba95310173bb4c1cb" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://www.kernel.org/pub/software/scm/git/docs/gittutorial.html&quot;&gt;git tutorial&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bccf408a44196396f7493f86e249b28e7b329b3e" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://www.kernel.org/pub/software/scm/git/docs/user-manual.html&quot;&gt;git user manual&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="249ba57d44afc37bc099ea38dc52d2396ce8f064" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt; parameter defines the underlying data type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a20426fc7bb4d929b1ae303283b379020fbc254" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;numpy.polynomial.polynomial.polynomial.fit#numpy.polynomial.polynomial.Polynomial.fit&quot;&gt;&lt;code&gt;Polynomial.fit&lt;/code&gt;&lt;/a&gt; class method is recommended for new code as it is more stable numerically. See the documentation of the method for more information.</source>
          <target state="translated">Для нового кода рекомендуется использовать метод класса &lt;a href=&quot;numpy.polynomial.polynomial.polynomial.fit#numpy.polynomial.polynomial.Polynomial.fit&quot;&gt; &lt;code&gt;Polynomial.fit&lt;/code&gt; ,&lt;/a&gt; поскольку он более стабилен численно. Дополнительную информацию см. В документации по методу.</target>
        </trans-unit>
        <trans-unit id="2106750b1623894aaf03937b68ff34531437daf6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;!=&lt;/code&gt; operator can be used as a shorthand for &lt;code&gt;np.not_equal&lt;/code&gt; on ndarrays.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="17ec1581f01c72c941c4dc77fd68463096a8bba3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;%&lt;/code&gt; operator can be used as a shorthand for &lt;code&gt;np.remainder&lt;/code&gt; on ndarrays.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fedbb2e901febe4e3a84316b4d8ddf825237dddb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&amp;amp;&lt;/code&gt; operator can be used as a shorthand for &lt;code&gt;np.bitwise_and&lt;/code&gt; on ndarrays.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3618bbea51263c31902b2474f8c1ec0676a4715a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&amp;amp;&lt;/code&gt; operator can be used as a shorthand for &lt;code&gt;np.logical_and&lt;/code&gt; on boolean ndarrays.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="30fd69974271e0304c5c6131b9dcfd6fed219f24" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; operator can be used as a shorthand for &lt;code&gt;np.right_shift&lt;/code&gt; on ndarrays.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ffa04e0143b8eff0d77a2fbb55cf86a562838af" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&amp;gt;&lt;/code&gt; operator can be used as a shorthand for &lt;code&gt;np.greater&lt;/code&gt; on ndarrays.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba583585bd7f53f4136770b0b1a134a6605b81d8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&amp;gt;=&lt;/code&gt; operator can be used as a shorthand for &lt;code&gt;np.greater_equal&lt;/code&gt; on ndarrays.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f87484d0d314be662c174caa809586486bdddc0c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt; operator can be used as a shorthand for &lt;code&gt;np.left_shift&lt;/code&gt; on ndarrays.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3210c2d9abaca33a8760be87735591310e75c5cf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&amp;lt;&lt;/code&gt; and &lt;code&gt;&amp;gt;&lt;/code&gt; operators always return &lt;code&gt;False&lt;/code&gt; when comparing void structured arrays, and arithmetic and bitwise operations are not supported.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="03f43c01c8d4047248089bbb2b583edb9535d173" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&amp;lt;&lt;/code&gt; operator can be used as a shorthand for &lt;code&gt;np.less&lt;/code&gt; on ndarrays.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f2e166673f9235ba15062d40c69beb65946de696" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&amp;lt;=&lt;/code&gt; operator can be used as a shorthand for &lt;code&gt;np.less_equal&lt;/code&gt; on ndarrays.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7efea03dca2b9d161f9ef2bba68b5604f07ac3fd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&amp;lt;argument/variable attribute statement&amp;gt;&lt;/code&gt; is &lt;code&gt;&amp;lt;argument/variable type declaration&amp;gt;&lt;/code&gt; without &lt;code&gt;&amp;lt;typespec&amp;gt;&lt;/code&gt;. In addition, in an attribute statement one cannot use other attributes, also &lt;code&gt;&amp;lt;entitydecl&amp;gt;&lt;/code&gt; can be only a list of names.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7fa4578e6de9d14302f059bb642ff99cac46413e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&amp;lt;other statement&amp;gt;&lt;/code&gt; part refers to any other Fortran language constructs that are not described above. F2PY ignores most of them except</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="03b1c818206b030797e65b1fc6d22265a88666ff" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;**&lt;/code&gt; operator can be used as a shorthand for &lt;code&gt;np.power&lt;/code&gt; on ndarrays.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="db80fa3dd1381ab36565d5142bc02d5226e4a0a9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;*&lt;/code&gt; operator can be used as a shorthand for &lt;code&gt;np.multiply&lt;/code&gt; on ndarrays.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4eef4b12a58a37d37f227dee3b5581f18cebb5c7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;+&lt;/code&gt; operator can be used as a shorthand for &lt;code&gt;np.add&lt;/code&gt; on ndarrays.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="955ea5ea660ef432dc046daf72c13f161af64749" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--cpu-baseline&lt;/code&gt; argument force-enables implied features, e.g. &lt;code&gt;--cpu-baseline&lt;/code&gt;=&amp;rdquo;sse42&amp;rdquo; is equivalent to &lt;code&gt;--cpu-baseline&lt;/code&gt;=&amp;rdquo;sse sse2 sse3 ssse3 sse41 popcnt sse42&amp;rdquo;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99fbc9561d840478417c6519c6d2fb97f9a66f14" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;-&lt;/code&gt; operator can be used as a shorthand for &lt;code&gt;np.subtract&lt;/code&gt; on ndarrays.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="03addd0e1d3adac1696638d2556f4f3e8a49b2fa" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;-s&lt;/code&gt; flag makes a PGP (usually GPG) signed tag. Please do sign the release tags.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a1f02257b982558ed0038cd836405c4aaec01705" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;-v&lt;/code&gt; flag gives verbose feedback, &lt;code&gt;-s&lt;/code&gt; causes the script to sign the wheels with your GPG key before upload. Don&amp;rsquo;t forget to upload the wheels before the source tarball, so there is no period for which people switch from an expected binary install to a source install from PyPI.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ea1937064d555fd6f04fc2b57ae9e905ce9bf17" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.npy&lt;/code&gt; format is the standard binary file format in NumPy for persisting a &lt;em&gt;single&lt;/em&gt; arbitrary NumPy array on disk. The format stores all of the shape and dtype information necessary to reconstruct the array correctly even on another machine with a different architecture. The format is designed to be as simple as possible while achieving its limited goals.</source>
          <target state="translated">Формат &lt;code&gt;.npy&lt;/code&gt; - это стандартный двоичный формат файла в NumPy для сохранения &lt;em&gt;одного&lt;/em&gt; произвольного массива NumPy на диске. Формат хранит всю информацию о форме и типе данных, необходимую для правильного восстановления массива даже на другом компьютере с другой архитектурой. Формат разработан так, чтобы быть максимально простым, но при этом достигать своих ограниченных целей.</target>
        </trans-unit>
        <trans-unit id="2c04852673cf174afe38ae3c6a6dffb2c948ac9a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.npy&lt;/code&gt; format, including motivation for creating it and a comparison of alternatives, is described in the &lt;a href=&quot;https://numpy.org/neps/nep-0001-npy-format.html&quot;&gt;&amp;ldquo;npy-format&amp;rdquo; NEP&lt;/a&gt;, however details have evolved with time and this document is more current.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d25fde9120bc920bdf839700f32d6b700adf8720" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.npy&lt;/code&gt; format, including motivation for creating it and a comparison of alternatives, is described in the &lt;a href=&quot;https://www.numpy.org/neps/nep-0001-npy-format.html&quot;&gt;&amp;ldquo;npy-format&amp;rdquo; NEP&lt;/a&gt;, however details have evolved with time and this document is more current.</source>
          <target state="translated">Формат &lt;code&gt;.npy&lt;/code&gt; , включая мотивацию для его создания и сравнение альтернатив, описан в &lt;a href=&quot;https://www.numpy.org/neps/nep-0001-npy-format.html&quot;&gt;&amp;laquo;npy-формате&amp;raquo; NEP&lt;/a&gt; , однако со временем детали изменились, и этот документ является более современным.</target>
        </trans-unit>
        <trans-unit id="22e53f126c53ee44cfae93fe323456796e3a7525" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.npz&lt;/code&gt; file format is a zipped archive of files named after the variables they contain. The archive is compressed with &lt;code&gt;zipfile.ZIP_DEFLATED&lt;/code&gt; and each file in the archive contains one variable in &lt;code&gt;.npy&lt;/code&gt; format. For a description of the &lt;code&gt;.npy&lt;/code&gt; format, see &lt;a href=&quot;numpy.lib.format#module-numpy.lib.format&quot;&gt;&lt;code&gt;numpy.lib.format&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;.npz&lt;/code&gt; формат файла является Молнии архив файлов с именем после того, как переменные , которые они содержат. Архив сжимается с помощью &lt;code&gt;zipfile.ZIP_DEFLATED&lt;/code&gt; , и каждый файл в архиве содержит одну переменную в формате &lt;code&gt;.npy&lt;/code&gt; . Для описания &lt;code&gt;.npy&lt;/code&gt; формата см &lt;a href=&quot;numpy.lib.format#module-numpy.lib.format&quot;&gt; &lt;code&gt;numpy.lib.format&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6b51e4d01309ff5a759f392af08bb39d1e99043e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.npz&lt;/code&gt; file format is a zipped archive of files named after the variables they contain. The archive is not compressed and each file in the archive contains one variable in &lt;code&gt;.npy&lt;/code&gt; format. For a description of the &lt;code&gt;.npy&lt;/code&gt; format, see &lt;a href=&quot;numpy.lib.format#module-numpy.lib.format&quot;&gt;&lt;code&gt;numpy.lib.format&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;.npz&lt;/code&gt; формат файла является Молнии архив файлов с именем после того, как переменные , которые они содержат. Архив не сжимается, и каждый файл в архиве содержит одну переменную в формате &lt;code&gt;.npy&lt;/code&gt; . Для описания &lt;code&gt;.npy&lt;/code&gt; формата см &lt;a href=&quot;numpy.lib.format#module-numpy.lib.format&quot;&gt; &lt;code&gt;numpy.lib.format&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a5c00dd2aa73f26e18024a200e3875179deacef9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.npz&lt;/code&gt; format is the standard format for persisting &lt;em&gt;multiple&lt;/em&gt; NumPy arrays on disk. A &lt;code&gt;.npz&lt;/code&gt; file is a zip file containing multiple &lt;code&gt;.npy&lt;/code&gt; files, one for each array.</source>
          <target state="translated">Формат &lt;code&gt;.npz&lt;/code&gt; - это стандартный формат для хранения &lt;em&gt;нескольких&lt;/em&gt; массивов NumPy на диске. &lt;code&gt;.npz&lt;/code&gt; файл почтовый файл , содержащий несколько &lt;code&gt;.npy&lt;/code&gt; файлов, по одному для каждого массива.</target>
        </trans-unit>
        <trans-unit id="49926d6e6d5a1cf1d353c4c16bd799098aac6cff" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.wav&lt;/code&gt; file header as a NumPy structured dtype:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="101d581073e2abaa90459f2609e076c53bbb6672" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.wav&lt;/code&gt; file header is a 44-byte block preceding &lt;code&gt;data_size&lt;/code&gt; bytes of the actual sound data:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b48c3ed20fe9905219c0e18e9a68879ea305c96f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;//&lt;/code&gt; operator can be used as a shorthand for &lt;code&gt;np.floor_divide&lt;/code&gt; on ndarrays.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d0d9c3e4a778f5248a1356d5526d29630bde5db" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;/&lt;/code&gt; operator can be used as a shorthand for &lt;code&gt;np.true_divide&lt;/code&gt; on ndarrays.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c632b7dc98e3f058a1b177bc4932a231dc8f4b56" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;==&lt;/code&gt; operator can be used as a shorthand for &lt;code&gt;np.equal&lt;/code&gt; on ndarrays.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d940227ec40cbafe833315ddae39bbf8b8dfa835" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;@&lt;/code&gt; operator can be used as a shorthand for &lt;code&gt;np.matmul&lt;/code&gt; on ndarrays.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="19658579206ac4f8753c064c0302ad76f2f72a46" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ALIGNED&lt;/code&gt; flag of an ndarray, computed in &lt;code&gt;IsAligned&lt;/code&gt; and checked by &lt;code&gt;PyArray_ISALIGNED&lt;/code&gt;. This is computed from &lt;code&gt;dtype.alignment&lt;/code&gt;. It is set to &lt;code&gt;True&lt;/code&gt; if every item in the array is at a memory location consistent with &lt;code&gt;dtype.alignment&lt;/code&gt;, which is the case if the data ptr and all strides of the array are multiples of that alignment.</source>
          <target state="translated">&lt;code&gt;ALIGNED&lt;/code&gt; флаг из ndarray, вычисленный в &lt;code&gt;IsAligned&lt;/code&gt; и проверяются &lt;code&gt;PyArray_ISALIGNED&lt;/code&gt; . Это вычисляется из &lt;code&gt;dtype.alignment&lt;/code&gt; . Для него установлено значение &lt;code&gt;True&lt;/code&gt; , если каждый элемент в массиве находится в ячейке памяти, согласованной с &lt;code&gt;dtype.alignment&lt;/code&gt; , что имеет место, если ptr данных и все шаги массива кратны этому выравниванию.</target>
        </trans-unit>
        <trans-unit id="85388f353d8827d53025cb4498ec7c4f7175db9d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;BitGenerator&lt;/code&gt; has a limited set of responsibilities. It manages state and provides functions to produce random doubles and random unsigned 32- and 64-bit values.</source>
          <target state="translated">&lt;code&gt;BitGenerator&lt;/code&gt; имеет ограниченный набор функций. Он управляет состоянием и предоставляет функции для создания случайных чисел двойной точности и случайных 32- и 64-битных значений без знака.</target>
        </trans-unit>
        <trans-unit id="29642d4a46e1b1f330f5d899a27d8931b3675855" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Configuration&lt;/code&gt; constructor has a fourth optional argument, &lt;code&gt;package_path&lt;/code&gt;, that can be used when package files are located in a different location than the directory of the &lt;code&gt;setup.py&lt;/code&gt; file.</source>
          <target state="translated">У конструктора &lt;code&gt;Configuration&lt;/code&gt; есть четвертый необязательный аргумент, &lt;code&gt;package_path&lt;/code&gt; , который можно использовать, когда файлы пакета расположены в другом месте, чем каталог файла &lt;code&gt;setup.py&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="831e4b75031bb8f9a8d29e89a9890ddda53ce469" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;LibraryInfo&lt;/code&gt; instance containing the build information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d942d62411c592ee85272583cee21a0d612eb9cd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;MT19937&lt;/code&gt; state vector consists of a 624-element array of 32-bit unsigned integers plus a single integer value between 0 and 624 that indexes the current position within the main array.</source>
          <target state="translated">&lt;code&gt;MT19937&lt;/code&gt; вектор состояния состоит из 624-элемента массива в 32-битных целых чисел без знака плюс одно целое число от 0 до 624 , что индексы текущее положение внутри основного массива.</target>
        </trans-unit>
        <trans-unit id="a95fd45cabac9b94aa97772f024779835dc306b4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Makefile&lt;/code&gt; calls &lt;code&gt;swig&lt;/code&gt; to generate &lt;code&gt;Vector.py&lt;/code&gt; and &lt;code&gt;Vector_wrap.cxx&lt;/code&gt;, and also executes the &lt;code&gt;setup.py&lt;/code&gt; script that compiles &lt;code&gt;Vector_wrap.cxx&lt;/code&gt; and links together the extension module &lt;code&gt;_Vector.so&lt;/code&gt; or &lt;code&gt;_Vector.dylib&lt;/code&gt;, depending on the platform. This extension module and the proxy file &lt;code&gt;Vector.py&lt;/code&gt; are both placed in a subdirectory under the &lt;code&gt;build&lt;/code&gt; directory.</source>
          <target state="translated">В &lt;code&gt;Makefile&lt;/code&gt; звонки &lt;code&gt;swig&lt;/code&gt; генерировать &lt;code&gt;Vector.py&lt;/code&gt; и &lt;code&gt;Vector_wrap.cxx&lt;/code&gt; , а также выполняет &lt;code&gt;setup.py&lt;/code&gt; скрипт , который компилирует &lt;code&gt;Vector_wrap.cxx&lt;/code&gt; и ссылки вместе модуля расширения &lt;code&gt;_Vector.so&lt;/code&gt; или &lt;code&gt;_Vector.dylib&lt;/code&gt; , в зависимости от платформы. Этот модуль расширения и прокси-файл &lt;code&gt;Vector.py&lt;/code&gt; помещаются в подкаталог в каталоге &lt;code&gt;build&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a509290375510505b589158f3b8f2b07b506f6b0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;MaskedArray&lt;/code&gt; class</source>
          <target state="translated">&lt;code&gt;MaskedArray&lt;/code&gt; класс</target>
        </trans-unit>
        <trans-unit id="b55e755e6d26d2135c464a8b79f8ff9c154dcada" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;NPY_SIZEOF_{CTYPE}&lt;/code&gt; constants are defined so that sizeof information is available to the pre-processor.</source>
          <target state="translated">Константы &lt;code&gt;NPY_SIZEOF_{CTYPE}&lt;/code&gt; определены так, чтобы информация о размере была доступна препроцессору.</target>
        </trans-unit>
        <trans-unit id="d0911aba3c1681f9c5a1ccf39d3f2fd5866ac6b2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;NpzFile&lt;/code&gt; returned by &lt;code&gt;np.savez&lt;/code&gt; is now a &lt;code&gt;collections.abc.Mapping&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d918fc830e6f124f45ecb19bab96030d1a7583a5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;PCG64&lt;/code&gt; state vector consists of 2 unsigned 128-bit values, which are represented externally as Python ints. One is the state of the PRNG, which is advanced by a linear congruential generator (LCG). The second is a fixed odd increment used in the LCG.</source>
          <target state="translated">&lt;code&gt;PCG64&lt;/code&gt; вектор состояния состоит из 2 -х без знака 128-битовых значений, которые представлены в виде целых чисел извне Python. Один из них - это состояние ГПСЧ, которое продвигается линейным конгруэнтным генератором (LCG). Второй - это фиксированное приращение нечетности, используемое в LCG.</target>
        </trans-unit>
        <trans-unit id="c1a90ac63bb863a062bb153b73df1e64c4857aff" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Philox&lt;/code&gt; state vector consists of a 256-bit value encoded as a 4-element uint64 array and a 128-bit value encoded as a 2-element uint64 array. The former is a counter which is incremented by 1 for every 4 64-bit randoms produced. The second is a key which determined the sequence produced. Using different keys produces independent sequences.</source>
          <target state="translated">&lt;code&gt;Philox&lt;/code&gt; вектор состояния состоит из 256-битового значения , закодированного как массив UInt64 4-элементной и 128-битное значение , кодируется как массив UInt64 2-элемента. Первый - это счетчик, который увеличивается на 1 для каждых 4 произведенных 64-битных случайных чисел. Второй - это ключ, определяющий производимую последовательность. Использование разных ключей дает независимые последовательности.</target>
        </trans-unit>
        <trans-unit id="77835deaa4168f146eec7ddf2548bcb524ae4254" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;PyArray_DescrCheck&lt;/code&gt; macro is modified</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d1f94165781d8145f1fd80c467f6bd0f760f0b8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;SFC64&lt;/code&gt; state vector consists of 4 unsigned 64-bit values. The last is a 64-bit counter that increments by 1 each iteration.</source>
          <target state="translated">&lt;code&gt;SFC64&lt;/code&gt; вектор состояния состоит из 4 беззнаковых 64-битовых значений. Последний - это 64-битный счетчик, который увеличивается на 1 каждую итерацию.</target>
        </trans-unit>
        <trans-unit id="1c61cd8903722b01c74a952853626a7fa047bc24" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;See the sights&lt;/code&gt; how-to should link to a set of narrower how-tos:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f2597c1ce05865ef5dc6c1fd54908d9266820030" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;^&lt;/code&gt; operator can be used as a shorthand for &lt;code&gt;np.bitwise_xor&lt;/code&gt; on ndarrays.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a79e711795f6e28c85d83994efa93c2930d50249" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;__array_ufunc__&lt;/code&gt; receives:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7be3375866469167b9378a498844a5222b829ab9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;__complex__&lt;/code&gt; method has been implemented for the ndarrays</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="395b8858a352467f67b6a09c4a5fc424e26cfad2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;__init__.py&lt;/code&gt; file</source>
          <target state="translated">&lt;code&gt;__init__.py&lt;/code&gt; файл</target>
        </trans-unit>
        <trans-unit id="55e0b71eae2cfd6e566258a88d10c513a1a5a113" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;align&lt;/code&gt; keyword of the dtype constructor, which only affects structured arrays. If the structure&amp;rsquo;s field offsets are not manually provided numpy determines offsets automatically. In that case, &lt;code&gt;align=True&lt;/code&gt; pads the structure so that each field is &amp;ldquo;true&amp;rdquo; aligned in memory and sets &lt;code&gt;dtype.alignment&lt;/code&gt; to be the largest of the field &amp;ldquo;true&amp;rdquo; alignments. This is like what C-structs usually do. Otherwise if offsets or itemsize were manually provided &lt;code&gt;align=True&lt;/code&gt; simply checks that all the fields are &amp;ldquo;true&amp;rdquo; aligned and that the total itemsize is a multiple of the largest field alignment. In either case &lt;code&gt;dtype.isalignedstruct&lt;/code&gt; is also set to True.</source>
          <target state="translated">&lt;code&gt;align&lt;/code&gt; ключевых слов конструктора DTYPE, который влияет только на структурированные массивы. Если смещения полей структуры не указаны вручную, numpy определяет смещения автоматически. В этом случае &lt;code&gt;align=True&lt;/code&gt; дополняет структуру так, чтобы каждое поле было &amp;laquo;истинным&amp;raquo; выровненным в памяти, и устанавливает &lt;code&gt;dtype.alignment&lt;/code&gt; как наибольшее из &amp;laquo;истинных&amp;raquo; выравниваний поля. Это похоже на то, что обычно делают C-структуры. В противном случае, если смещения или размер элементов были предоставлены вручную, &lt;code&gt;align=True&lt;/code&gt; просто проверяет, что все поля выровнены &amp;laquo;истинно&amp;raquo; и что общий размер элементов является кратным максимальному выравниванию поля. В любом случае &lt;code&gt;dtype.isalignedstruct&lt;/code&gt; также имеет значение True.</target>
        </trans-unit>
        <trans-unit id="ed305f750328762db1dc6ead8c6be67eaf77ffcb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;array&lt;/code&gt; constructor &lt;strong&gt;takes (nested) Python sequences as initializers&lt;/strong&gt;. As in, &lt;code&gt;array([[1,2,3],[4,5,6]])&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d7af29f13d56d1534071fc5be1d8e6902e6aa373" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;array&lt;/code&gt; is thus much more advisable to use. Indeed, we intend to deprecate &lt;code&gt;matrix&lt;/code&gt; eventually.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd27c9fa716237737a1b850fd84a88e9e84db97b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;as&lt;/code&gt;-clause of the &lt;code&gt;with&lt;/code&gt;-statement gives the current print options:</source>
          <target state="translated">Предложение &lt;code&gt;as&lt;/code&gt; в выражении &lt;code&gt;with&lt;/code&gt; дает текущие параметры печати:</target>
        </trans-unit>
        <trans-unit id="2c28e104a97f1a1f15fc38cbcd9f731be438b4c3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;autostrip&lt;/code&gt; argument</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad906fe89b0c268cf5fd9b3376621745175a9a41" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;axis&lt;/code&gt; argument to &lt;code&gt;numpy.ma.mask_cols&lt;/code&gt; and &lt;code&gt;numpy.ma.mask_row&lt;/code&gt; is deprecated</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="caa858c948295450c18bcef4c572e68d7eda67a9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;axis&lt;/code&gt; keyword can be used to specify a subset of axes of which the gradient is calculated</source>
          <target state="translated">&lt;code&gt;axis&lt;/code&gt; ключевое слово может быть использовано , чтобы указать подмножество осей которых вычисляется градиент</target>
        </trans-unit>
        <trans-unit id="c68a2d64e2aeed4fdf4077c45259bb4b7c07822e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;axis&lt;/code&gt; parameter specifies the index of the new axis in the dimensions of the result. For example, if &lt;code&gt;axis=0&lt;/code&gt; it will be the first dimension and if &lt;code&gt;axis=-1&lt;/code&gt; it will be the last dimension.</source>
          <target state="translated">Параметр &lt;code&gt;axis&lt;/code&gt; указывает индекс новой оси в измерениях результата. Например, если &lt;code&gt;axis=0&lt;/code&gt; это будет первое измерение, а если &lt;code&gt;axis=-1&lt;/code&gt; это будет последнее измерение.</target>
        </trans-unit>
        <trans-unit id="285d55a28a1a269db45a5f84582658fc7e3a43b7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;base&lt;/code&gt; attribute is useful in being able to tell whether we have a view or the original array. This in turn can be useful if we need to know whether or not to do some specific cleanup when the subclassed array is deleted. For example, we may only want to do the cleanup if the original array is deleted, but not the views. For an example of how this can work, have a look at the &lt;code&gt;memmap&lt;/code&gt; class in &lt;code&gt;numpy.core&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d4cb66724d02c13ff5f50a065c67d6d75a20a6a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;bool_&lt;/code&gt; data type is very similar to the Python &lt;code&gt;BooleanType&lt;/code&gt; but does not inherit from it because Python&amp;rsquo;s &lt;code&gt;BooleanType&lt;/code&gt; does not allow itself to be inherited from, and on the C-level the size of the actual bool data is not the same as a Python Boolean scalar.</source>
          <target state="translated">&lt;code&gt;bool_&lt;/code&gt; тип данных очень похож на Python &lt;code&gt;BooleanType&lt;/code&gt; , но не наследует от него , потому что в Python &lt;code&gt;BooleanType&lt;/code&gt; не позволяет себе быть унаследованы от, а на C-уровне размер фактических данных BOOL не то же самое , как Python Boolean скаляр.</target>
        </trans-unit>
        <trans-unit id="1a9ec4df6ec3fb7357baf90864b29d969f59440a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;bool_&lt;/code&gt; type is not a subclass of the &lt;code&gt;int_&lt;/code&gt; type (the &lt;code&gt;bool_&lt;/code&gt; is not even a number type). This is different than Python&amp;rsquo;s default implementation of &lt;a href=&quot;https://docs.python.org/dev/library/functions.html#bool&quot;&gt;&lt;code&gt;bool&lt;/code&gt;&lt;/a&gt; as a sub-class of int.</source>
          <target state="translated">Тип &lt;code&gt;bool_&lt;/code&gt; не является подклассом типа &lt;code&gt;int_&lt;/code&gt; ( &lt;code&gt;bool_&lt;/code&gt; даже не является числовым типом). Это отличается от реализации Python по умолчанию для &lt;a href=&quot;https://docs.python.org/dev/library/functions.html#bool&quot;&gt; &lt;code&gt;bool&lt;/code&gt; &lt;/a&gt; как подкласса int.</target>
        </trans-unit>
        <trans-unit id="3f5c3b6d52d4becfb53cc5a7dd0ae6b04cdb9085" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;chars&lt;/code&gt; argument is a string specifying the set of characters to be removed. If omitted or None, the &lt;code&gt;chars&lt;/code&gt; argument defaults to removing whitespace. The &lt;code&gt;chars&lt;/code&gt; argument is not a prefix or suffix; rather, all combinations of its values are stripped.</source>
          <target state="translated">&lt;code&gt;chars&lt;/code&gt; аргументом является строка , определяющая набор символов , которые будут удалены. Если опущено или None, аргумент &lt;code&gt;chars&lt;/code&gt; по умолчанию удаляет пробелы. &lt;code&gt;chars&lt;/code&gt; аргумент не префикс или суффикс; скорее, удаляются все комбинации его значений.</target>
        </trans-unit>
        <trans-unit id="44ca716c299a61027880c154634feb6b89178fc1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;chars&lt;/code&gt; argument is a string specifying the set of characters to be removed. If omitted or None, the &lt;code&gt;chars&lt;/code&gt; argument defaults to removing whitespace. The &lt;code&gt;chars&lt;/code&gt; argument is not a prefix; rather, all combinations of its values are stripped.</source>
          <target state="translated">&lt;code&gt;chars&lt;/code&gt; аргументом является строка , определяющая набор символов , которые будут удалены. Если опущено или None, аргумент &lt;code&gt;chars&lt;/code&gt; по умолчанию удаляет пробелы. &lt;code&gt;chars&lt;/code&gt; аргумент не префикс; скорее, удаляются все комбинации его значений.</target>
        </trans-unit>
        <trans-unit id="3ab81d1fe754db2126af526470043294b9859fdc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;chars&lt;/code&gt; argument is a string specifying the set of characters to be removed. If omitted or None, the &lt;code&gt;chars&lt;/code&gt; argument defaults to removing whitespace. The &lt;code&gt;chars&lt;/code&gt; argument is not a suffix; rather, all combinations of its values are stripped.</source>
          <target state="translated">&lt;code&gt;chars&lt;/code&gt; аргументом является строка , определяющая набор символов , которые будут удалены. Если опущено или None, аргумент &lt;code&gt;chars&lt;/code&gt; по умолчанию удаляет пробелы. &lt;code&gt;chars&lt;/code&gt; аргумент не суффикс; скорее, удаляются все комбинации его значений.</target>
        </trans-unit>
        <trans-unit id="c5f389d1809eca65fc531558b3a6934398b93db5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;code.c&lt;/code&gt; file also contains the function &lt;code&gt;dfilter2d&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1062b010a751d11306d8dd6990fc1281fafefff6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;comments&lt;/code&gt; argument</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="49098bbf1639e574a8a45e0dbe1faacda5a0f942" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;context&lt;/code&gt; member of the &lt;a href=&quot;https://docs.python.org/dev/c-api/capsule.html#c.PyCapsule&quot;&gt;&lt;code&gt;PyCapsule&lt;/code&gt;&lt;/a&gt; (formally the &lt;code&gt;desc&lt;/code&gt; member of the &lt;code&gt;PyCObject&lt;/code&gt;) returned from &lt;code&gt;__array_struct__&lt;/code&gt; was not specified. Usually, it was the object exposing the array (so that a reference to it could be kept and destroyed when the C-object was destroyed). It is now an explicit requirement that this field be used in some way to hold a reference to the owning object.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b3f924ee1f48ac861086d833eab7f0e461342200" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;converters&lt;/code&gt; argument</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1bf25618f0e89873a8966e075d9cc930c281ddb2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;copy&lt;/code&gt; method makes a complete copy of the array and its data.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="04c7d601eb1b28391adc5c0db2ef77348e27c0e6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;defaultfmt&lt;/code&gt; argument</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a534898d388f95602366c3e92d612246a0ec8f63" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;delimiter&lt;/code&gt; argument</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="961750d0f31ee27657eeda3c0b92ff071d0d3872" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;doc/swig&lt;/code&gt; directory moved</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c5f33c0fec12debe8698b9f3d00999bb3fb759ea" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;dtype.alignment&lt;/code&gt; attribute (&lt;code&gt;descr-&amp;gt;alignment&lt;/code&gt; in C). This is meant to reflect the &amp;ldquo;true alignment&amp;rdquo; of the type. It has arch-dependent default values for all datatypes, with the exception of structured types created with &lt;code&gt;align=True&lt;/code&gt; as described below.</source>
          <target state="translated">&lt;code&gt;dtype.alignment&lt;/code&gt; атрибут ( &lt;code&gt;descr-&amp;gt;alignment&lt;/code&gt; в C). Это сделано для того, чтобы отразить &amp;laquo;истинное соответствие&amp;raquo; типа. Он имеет зависящие от архитектуры значения по умолчанию для всех типов данных, за исключением структурированных типов, созданных с помощью &lt;code&gt;align=True&lt;/code&gt; , как описано ниже.</target>
        </trans-unit>
        <trans-unit id="323a6b614fe91ba8419451439d97b4868d61c2a1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;dtype.fields&lt;/code&gt; dictionary will contain titles as keys, if any titles are used. This means effectively that a field with a title will be represented twice in the fields dictionary. The tuple values for these fields will also have a third element, the field title. Because of this, and because the &lt;code&gt;names&lt;/code&gt; attribute preserves the field order while the &lt;code&gt;fields&lt;/code&gt; attribute may not, it is recommended to iterate through the fields of a dtype using the &lt;code&gt;names&lt;/code&gt; attribute of the dtype, which will not list titles, as in:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e0428300bbf21ef1b533ffa3e86adb5ceddd8dd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;dtype&lt;/code&gt; parameter defines the underlying data type.</source>
          <target state="translated">Параметр &lt;code&gt;dtype&lt;/code&gt; определяет базовый тип данных.</target>
        </trans-unit>
        <trans-unit id="93f7d511e2846b265125fabe4d5030e15709832e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;excluded&lt;/code&gt; argument can be used to prevent vectorizing over certain arguments. This can be useful for array-like arguments of a fixed length such as the coefficients for a polynomial as in &lt;a href=&quot;numpy.polyval#numpy.polyval&quot;&gt;&lt;code&gt;polyval&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">&lt;code&gt;excluded&lt;/code&gt; аргумент может быть использован для предотвращения векторизации над определенными аргументами. Это может быть полезно для аргументов, подобных массиву, фиксированной длины, таких как коэффициенты для многочлена, как в &lt;a href=&quot;numpy.polyval#numpy.polyval&quot;&gt; &lt;code&gt;polyval&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="359c30915e6710377793414f9e99d77e6eeeea63" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;f2py -c&lt;/code&gt; option must be applied either to an existing &lt;code&gt;.pyf&lt;/code&gt; file (plus the source/object/library files) or one must specify the &lt;code&gt;-m &amp;lt;modulename&amp;gt;&lt;/code&gt; option (plus the sources/object/library files). Use one of the following options:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2beff53e54fda1bd096a7e81c4708f352287d275" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;flags&lt;/code&gt; attribute of the &lt;code&gt;PyArrayObject&lt;/code&gt; structure contains important information about the memory used by the array (pointed to by the data member) This flag information must be kept accurate or strange results and even segfaults may result.</source>
          <target state="translated">&lt;code&gt;flags&lt;/code&gt; атрибут &lt;code&gt;PyArrayObject&lt;/code&gt; структуры содержит важную информацию о памяти , используемой в массиве ( на который указывает элементу данных) Этот флаг информации должны храниться точные или странные результаты и даже может привести возвращает ошибку сегментации.</target>
        </trans-unit>
        <trans-unit id="8cff4dd26e77da7e42ef944b6a6e55860dbd33d0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;genfromtxt&lt;/code&gt; function provides two other complementary mechanisms: the &lt;code&gt;missing_values&lt;/code&gt; argument is used to recognize missing data and a second argument, &lt;code&gt;filling_values&lt;/code&gt;, is used to process these missing data.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b08d522b6b1cfd800cd6bda4d86b04d644f1baf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;int_&lt;/code&gt; type does &lt;strong&gt;not&lt;/strong&gt; inherit from the &lt;a href=&quot;https://docs.python.org/dev/library/functions.html#int&quot;&gt;&lt;code&gt;int&lt;/code&gt;&lt;/a&gt; built-in under Python 3, because type &lt;a href=&quot;https://docs.python.org/dev/library/functions.html#int&quot;&gt;&lt;code&gt;int&lt;/code&gt;&lt;/a&gt; is no longer a fixed-width integer type.</source>
          <target state="translated">&lt;code&gt;int_&lt;/code&gt; типа не имеет &lt;strong&gt;не&lt;/strong&gt; наследует от &lt;a href=&quot;https://docs.python.org/dev/library/functions.html#int&quot;&gt; &lt;code&gt;int&lt;/code&gt; &lt;/a&gt; встроенного под Python 3, поскольку типа &lt;a href=&quot;https://docs.python.org/dev/library/functions.html#int&quot;&gt; &lt;code&gt;int&lt;/code&gt; &lt;/a&gt; больше не является фиксированной шириной целого типа.</target>
        </trans-unit>
        <trans-unit id="5032550323e57bc7dec27d8af2d8f9df18642750" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;itershape&lt;/code&gt; parameter allows you to force the iterator to have a specific iteration shape. It is an array of length &lt;code&gt;oa_ndim&lt;/code&gt;. When an entry is negative, its value is determined from the operands. This parameter allows automatically allocated outputs to get additional dimensions which don&amp;rsquo;t match up with any dimension of an input.</source>
          <target state="translated">Параметр &lt;code&gt;itershape&lt;/code&gt; позволяет заставить итератор иметь определенную форму итерации. Это массив длиной &lt;code&gt;oa_ndim&lt;/code&gt; . Когда запись отрицательная, ее значение определяется операндами. Этот параметр позволяет автоматически назначенным выходам получать дополнительные измерения, которые не совпадают ни с одним из измерений входа.</target>
        </trans-unit>
        <trans-unit id="d1b139e99319cf8723f8471165f727072e0de12d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;k&lt;/code&gt; different &amp;ldquo;columns&amp;rdquo; to be sorted. The last column (or row if &lt;code&gt;keys&lt;/code&gt; is a 2D array) is the primary sort key.</source>
          <target state="translated">В &lt;code&gt;k&lt;/code&gt; разным &amp;laquo;столбцам&amp;raquo; для сортировки. Последний столбец (или строка, если &lt;code&gt;keys&lt;/code&gt; - это 2D-массив) - это первичный ключ сортировки.</target>
        </trans-unit>
        <trans-unit id="1a2dff01d273bbb026a37bec4c9c698a3a5dbb3a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;like&lt;/code&gt; keyword is an experimental feature pending on acceptance of &lt;a href=&quot;https://numpy.org/neps/nep-0035-array-creation-dispatch-with-array-function.html#nep35&quot;&gt;NEP 35&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf501ea6ca94cccfb99a424407f3991a7fe0b23a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;mask&lt;/code&gt; can be initialized with an array of boolean values with the same shape as &lt;code&gt;data&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b7a81ce30e9985e9cc6aff4a084478e80352aabd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;matrix&lt;/code&gt; constructor additionally &lt;strong&gt;takes a convenient string initializer&lt;/strong&gt;. As in &lt;code&gt;matrix(&quot;[1&amp;nbsp;2&amp;nbsp;3;&amp;nbsp;4&amp;nbsp;5&amp;nbsp;6]&quot;)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ab61433b884d13cbf28918d009f77e172c843e81" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;n&lt;/code&gt; arrays of indices corresponding to the locations where &lt;code&gt;mask_func(np.ones((n, n)), k)&lt;/code&gt; is True.</source>
          <target state="translated">В &lt;code&gt;n&lt;/code&gt; массивы индексов , соответствующих местах , где &lt;code&gt;mask_func(np.ones((n, n)), k)&lt;/code&gt; истинно.</target>
        </trans-unit>
        <trans-unit id="69bba282bdcb3fd4a040d50fe46e42c40f81a639" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;names&lt;/code&gt; argument</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="68e43d8a15f5f97ea384a5e71f1342015a6bc434" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ndarray&lt;/code&gt; is an object that provide a python array interface to data in memory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="77729f42697ab0235a0349b2968dd91c608b2d96" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ndincr&lt;/code&gt; method of &lt;code&gt;ndindex&lt;/code&gt; is deprecated</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="68dcfe0b1fdf3a267f300958e2039277e48ae02c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;new_order&lt;/code&gt; code can be any from the following:</source>
          <target state="translated">Код &lt;code&gt;new_order&lt;/code&gt; может быть любым из следующих:</target>
        </trans-unit>
        <trans-unit id="8693a0f592844bcf9978c5fbaa78f4621036206e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;nonzero&lt;/code&gt; method of the condition array can also be called.</source>
          <target state="translated">Также может быть вызван &lt;code&gt;nonzero&lt;/code&gt; метод массива условий.</target>
        </trans-unit>
        <trans-unit id="119598850fcb719f758c8505ecbfd545e55a9647" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;np.einsum&lt;/code&gt; function will use BLAS when possible and optimize by default</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e03ccb4d87ad4f35f1ad3c43da765c8e7da17640" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;np.percentile&lt;/code&gt; &amp;lsquo;midpoint&amp;rsquo; interpolation method fixed for exact indices</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eabf6694e45f9bef7f8445dcaf6ddb978e5e6f05" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;npy_3kcompat.h&lt;/code&gt; header changed</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d18c665ad6cff39ded6fc90bc8648963ab9ee138" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;numpy.i&lt;/code&gt; file contains several macros and routines that it uses internally to build its typemaps. However, these functions may be useful elsewhere in your interface file. These macros and routines are implemented as fragments, which are described briefly in the previous section. If you try to use one or more of the following macros or functions, but your compiler complains that it does not recognize the symbol, then you need to force these fragments to appear in your code using:</source>
          <target state="translated">&lt;code&gt;numpy.i&lt;/code&gt; файл содержит несколько макросов и процедур , которые он использует внутренне строить свои typemaps. Однако эти функции могут быть полезны в другом месте вашего интерфейсного файла. Эти макросы и подпрограммы реализованы в виде фрагментов, которые кратко описаны в предыдущем разделе. Если вы пытаетесь использовать один или несколько из следующих макросов или функций, но ваш компилятор жалуется, что он не распознает символ, вам нужно заставить эти фрагменты появиться в вашем коде, используя:</target>
        </trans-unit>
        <trans-unit id="9f4cb37fdc51e8b1f5c2b248e5fd15fdd94aa9b6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;numpy.i&lt;/code&gt; file is currently located in the &lt;code&gt;tools/swig&lt;/code&gt; sub-directory under the &lt;code&gt;numpy&lt;/code&gt; installation directory. Typically, you will want to copy it to the directory where you are developing your wrappers.</source>
          <target state="translated">&lt;code&gt;numpy.i&lt;/code&gt; файл в настоящее время находится в &lt;code&gt;tools/swig&lt;/code&gt; подкаталоге под &lt;code&gt;numpy&lt;/code&gt; каталога установки. Как правило, вам нужно скопировать его в каталог, в котором вы разрабатываете свои оболочки.</target>
        </trans-unit>
        <trans-unit id="96831ff16133b13c87cfe870992604959917c570" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;numpy.i&lt;/code&gt; interface file also provides additional tools for wrapper developers, including:</source>
          <target state="translated">&lt;code&gt;numpy.i&lt;/code&gt; файл интерфейс также предоставляет дополнительные инструменты для разработчиков оболочек, в том числе:</target>
        </trans-unit>
        <trans-unit id="d04832f55eba99f2bc4cc0dceb3d718f68b6cac8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;numpy.i&lt;/code&gt; interface file does not support typemaps for output arrays, for several reasons. First, C/C++ return arguments are limited to a single value. This prevents obtaining dimension information in a general way. Second, arrays with hard-coded lengths are not permitted as return arguments. In other words:</source>
          <target state="translated">&lt;code&gt;numpy.i&lt;/code&gt; файл интерфейс не поддерживает typemaps для вывода массивов, по нескольким причинам. Во-первых, возвращаемые аргументы C / C ++ ограничены одним значением. Это предотвращает получение информации о размерах в общем виде. Во-вторых, массивы с жестко заданной длиной не допускаются в качестве возвращаемых аргументов. Другими словами:</target>
        </trans-unit>
        <trans-unit id="65e8b572ae6dc55c16aea9abc0f0766e897fe055" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;numpy.i&lt;/code&gt; interface file uses the &lt;code&gt;%numpy_typemaps&lt;/code&gt; macro to implement typemaps for the following C data types and &lt;code&gt;int&lt;/code&gt; dimension types:</source>
          <target state="translated">В &lt;code&gt;numpy.i&lt;/code&gt; интерфейса &lt;code&gt;%numpy_typemaps&lt;/code&gt; макрос % numpy_typemaps используется для реализации карт типов для следующих типов данных C и типов измерений &lt;code&gt;int&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="d99e0e96fa984690444350c5bb3087380beb5586" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;numpy.ma&lt;/code&gt; module</source>
          <target state="translated">&lt;code&gt;numpy.ma&lt;/code&gt; модуль</target>
        </trans-unit>
        <trans-unit id="1f4db4ab31f145b9bac6edb4b0915cc64c0ea3a4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;numpy.ndarray&lt;/code&gt; constructor no longer interprets &lt;code&gt;strides=()&lt;/code&gt; as &lt;code&gt;strides=None&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="70a302d51ef0fc934fa61a7faa2fee138940dfc8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;numpy.rec&lt;/code&gt; module provides a number of other convenience functions for creating record arrays, see &lt;a href=&quot;../reference/routines.array-creation#routines-array-creation-rec&quot;&gt;record array creation routines&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="65de759e5fe00055883d5521d08146904c48c69b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;operator.concat&lt;/code&gt; function now raises TypeError for array arguments</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c8ade543f0e1c46d97cf061c562c3116b9639d4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;order&lt;/code&gt; keyword gives the index ordering both for &lt;em&gt;fetching&lt;/em&gt; the values from &lt;code&gt;a&lt;/code&gt;, and then &lt;em&gt;placing&lt;/em&gt; the values into the output array. For example, let&amp;rsquo;s say you have an array:</source>
          <target state="translated">&lt;code&gt;order&lt;/code&gt; ключевых слов дает индекс заказа как для &lt;em&gt;извлечения&lt;/em&gt; значений из , а затем &lt;em&gt;помещая&lt;/em&gt; значения в выходной массив. Например, допустим, у вас есть массив: &lt;code&gt;a&lt;/code&gt; &lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="b38e6e5718f484c9be916df67070a4920d8e24c9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;repr&lt;/code&gt; of &lt;code&gt;np.polynomial&lt;/code&gt; classes is more explicit</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7075c0200f067381f77164e531b354de40ba5d19" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;savetxt()&lt;/code&gt; and &lt;code&gt;loadtxt()&lt;/code&gt; functions accept additional optional parameters such as header, footer, and delimiter. While text files can be easier for sharing, .npy and .npz files are smaller and faster to read. If you need more sophisticated handling of your text file (for example, if you need to work with lines that contain missing values), you will want to use the &lt;a href=&quot;../reference/generated/numpy.genfromtxt#numpy.genfromtxt&quot;&gt;&lt;code&gt;genfromtxt&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="022ed8cd0b6cf9d8c83ca5b8b482f20886ea6324" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;series&lt;/code&gt; is expected to be an instance of some polynomial series of one of the types supported by by the numpy.polynomial module, but could be some other class that supports the convert method.</source>
          <target state="translated">Ожидается, что эта &lt;code&gt;series&lt;/code&gt; будет экземпляром некоторой полиномиальной серии одного из типов, поддерживаемых модулем numpy.polynomial, но может быть другим классом, поддерживающим метод convert.</target>
        </trans-unit>
        <trans-unit id="f4910f2b9024b32efada1e65d4c1134f65374f1c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;setup.py&lt;/code&gt; file</source>
          <target state="translated">&lt;code&gt;setup.py&lt;/code&gt; файл</target>
        </trans-unit>
        <trans-unit id="0948550106d7d72b97910c4e4918bcddbe3d6d6b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;signature&lt;/code&gt; argument allows for vectorizing functions that act on non-scalar arrays of fixed length. For example, you can use it for a vectorized calculation of Pearson correlation coefficient and its p-value:</source>
          <target state="translated">&lt;code&gt;signature&lt;/code&gt; аргумент позволяет векторизации функции , которые действуют на нескалярных массивы фиксированной длины. Например, вы можете использовать его для векторизованного расчета коэффициента корреляции Пирсона и его p-значения:</target>
        </trans-unit>
        <trans-unit id="692ace7013c4ccf7dfcd73ad9c88abfaeb03c00c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;skip_header&lt;/code&gt; and &lt;code&gt;skip_footer&lt;/code&gt; arguments</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="19cc10b9b9bd6104c6aeb8b9be441a8dc8445028" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;state&lt;/code&gt; argument must be a sequence that contains the following elements:</source>
          <target state="translated">&lt;code&gt;state&lt;/code&gt; аргумент должен быть последовательность , которая содержит следующие элементы:</target>
        </trans-unit>
        <trans-unit id="28db18b99085783cc1cb19c430887ae4c1bd2dc8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;state&lt;/code&gt; tuple has the following items:</source>
          <target state="translated">&lt;code&gt;state&lt;/code&gt; кортеж имеет следующие элементы:</target>
        </trans-unit>
        <trans-unit id="0e4c35736a2eec986972a33d172a5be16d326f7c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;tp_as_number&lt;/code&gt; methods use a generic approach to call whatever function has been registered for handling the operation. When the &lt;code&gt;_multiarray_umath module&lt;/code&gt; is imported, it sets the numeric operations for all arrays to the corresponding ufuncs. This choice can be changed with &lt;a href=&quot;c-api.ufunc#c.PyUFunc_ReplaceLoopBySignature&quot;&gt;&lt;code&gt;PyUFunc_ReplaceLoopBySignature&lt;/code&gt;&lt;/a&gt; The &lt;code&gt;tp_str&lt;/code&gt; and &lt;code&gt;tp_repr&lt;/code&gt; methods can also be altered using &lt;a href=&quot;c-api.array#c.PyArray_SetStringFunction&quot;&gt;&lt;code&gt;PyArray_SetStringFunction&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">В &lt;code&gt;tp_as_number&lt;/code&gt; методы используют общий подход для вызова любой функции были зарегистрирован для обработки операции. Когда &lt;code&gt;_multiarray_umath module&lt;/code&gt; импортируется, он устанавливает числовые операции для всех массивов в соответствующие ufuncs. Этот выбор можно изменить с помощью &lt;a href=&quot;c-api.ufunc#c.PyUFunc_ReplaceLoopBySignature&quot;&gt; &lt;code&gt;PyUFunc_ReplaceLoopBySignature&lt;/code&gt; &lt;/a&gt; . &lt;code&gt;tp_str&lt;/code&gt; и &lt;code&gt;tp_repr&lt;/code&gt; также можно изменить с помощью &lt;a href=&quot;c-api.array#c.PyArray_SetStringFunction&quot;&gt; &lt;code&gt;PyArray_SetStringFunction&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="008291952c69e3c178208fe3d11495f165132897" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;tp_as_number&lt;/code&gt; methods use a generic approach to call whatever function has been registered for handling the operation. When the &lt;code&gt;_multiarray_umath module&lt;/code&gt; is imported, it sets the numeric operations for all arrays to the corresponding ufuncs. This choice can be changed with &lt;a href=&quot;ufunc#c.PyUFunc_ReplaceLoopBySignature&quot;&gt;&lt;code&gt;PyUFunc_ReplaceLoopBySignature&lt;/code&gt;&lt;/a&gt; The &lt;code&gt;tp_str&lt;/code&gt; and &lt;code&gt;tp_repr&lt;/code&gt; methods can also be altered using &lt;a href=&quot;array#c.PyArray_SetStringFunction&quot;&gt;&lt;code&gt;PyArray_SetStringFunction&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed5f797071b24065d3a9e203b1fcea474546397a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;usecols&lt;/code&gt; argument</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dacc9a6ff7c4ed92c303c098ba1201530567896c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;|&lt;/code&gt; operator can be used as a shorthand for &lt;code&gt;np.bitwise_or&lt;/code&gt; on ndarrays.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64f414452963f507b1ec195fd0751843c6eb8871" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;|&lt;/code&gt; operator can be used as a shorthand for &lt;code&gt;np.logical_or&lt;/code&gt; on boolean ndarrays.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="db182f9eeb35e8d962f93ac7e0672564ab9219b6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;~&lt;/code&gt; operator can be used as a shorthand for &lt;code&gt;np.invert&lt;/code&gt; on ndarrays.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5186f89054917ad06c4418d857ded8a6ad552d9f" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;Documentation&lt;/em&gt; for a software project is the set of reference, instructional, educational, informative material generated by the project developers and contributors, as well as discussions, presentations, videos and other user-generated content. It may include learning-oriented content (such as tutorials and how-tos), use-cases or in-depth explanations and reference for developers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="88a54cde186ec5ee99014b55275737fd8ded4abc" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;bounds&lt;/em&gt; argument is expected to be a (2 * iter-&amp;gt;ao-&amp;gt;nd) arrays, such as the range bound[2*i]-&amp;gt;bounds[2*i+1] defines the range where to walk for dimension i (both bounds are included in the walked coordinates). The bounds should be ordered for each dimension (bounds[2*i] &amp;lt;= bounds[2*i+1]).</source>
          <target state="translated">Ожидается, что аргумент &lt;em&gt;bounds&lt;/em&gt; будет массивом (2 * iter-&amp;gt; ao-&amp;gt; nd), например, range bound [2 * i] -&amp;gt; bounds [2 * i + 1] определяет диапазон, по которому нужно пройти для измерения i. (обе границы включены в пройденные координаты). Границы должны быть упорядочены для каждого измерения (bounds [2 * i] &amp;lt;= bounds [2 * i + 1]).</target>
        </trans-unit>
        <trans-unit id="167173497ff130611588ae9a0a550c00ffde124f" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;compile-time&lt;/em&gt; environment variables:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea1fe523a0552e237800f38d8997bfcb72c8d0f5" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;func&lt;/em&gt;, &lt;em&gt;data&lt;/em&gt;, &lt;em&gt;types&lt;/em&gt;, &lt;em&gt;name&lt;/em&gt;, and &lt;em&gt;doc&lt;/em&gt; arguments are not copied by &lt;a href=&quot;#c.PyUFunc_FromFuncAndData&quot;&gt;&lt;code&gt;PyUFunc_FromFuncAndData&lt;/code&gt;&lt;/a&gt;. The caller must ensure that the memory used by these arrays is not freed as long as the ufunc object is alive.</source>
          <target state="translated">В &lt;em&gt;функ&lt;/em&gt; , &lt;em&gt;данные&lt;/em&gt; , &lt;em&gt;типы&lt;/em&gt; , &lt;em&gt;имя&lt;/em&gt; и &lt;em&gt;Дока&lt;/em&gt; аргументы не копируются &lt;a href=&quot;#c.PyUFunc_FromFuncAndData&quot;&gt; &lt;code&gt;PyUFunc_FromFuncAndData&lt;/code&gt; &lt;/a&gt; . Вызывающий должен гарантировать, что память, используемая этими массивами, не освобождена, пока жив объект ufunc.</target>
        </trans-unit>
        <trans-unit id="20c9d63d4d93167ef641a021fb26c115a182b092" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;itemsize&lt;/em&gt; key allows the total size of the dtype to be set, and must be an integer large enough so all the fields are within the dtype. If the dtype being constructed is aligned, the &lt;em&gt;itemsize&lt;/em&gt; must also be divisible by the struct alignment. Total dtype &lt;em&gt;itemsize&lt;/em&gt; is limited to &lt;a href=&quot;https://docs.python.org/dev/library/ctypes.html#ctypes.c_int&quot;&gt;&lt;code&gt;ctypes.c_int&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;em&gt;Itemsize&lt;/em&gt; ключ позволяет общий размер DTYPE быть множество, и должно быть целым числом достаточно большим , так что все поля находятся в пределах DTYPE. Если конструируемый dtype выровнен, &lt;em&gt;размер элемента&lt;/em&gt; также должен делиться на выравнивание структуры. Общий размер элементов &lt;em&gt;dtype&lt;/em&gt; ограничен &lt;a href=&quot;https://docs.python.org/dev/library/ctypes.html#ctypes.c_int&quot;&gt; &lt;code&gt;ctypes.c_int&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2ed9f0881461d81b2f7af8ce5229589ca6d28abd" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;n&lt;/em&gt;-dimensional FFT of real input.</source>
          <target state="translated">&lt;em&gt;П&lt;/em&gt; - мерный FFT реального ввода.</target>
        </trans-unit>
        <trans-unit id="35066a9f7cb50260dfe6cd2d771163f62f1011ce" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;n&lt;/em&gt;-dimensional FFT.</source>
          <target state="translated">&lt;em&gt;П&lt;/em&gt; - мерный FFT.</target>
        </trans-unit>
        <trans-unit id="1f82e353fb8bee88c46f056efaf0e1b9b205e05a" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;out&lt;/em&gt; argument to &lt;a href=&quot;numpy.power#numpy.power&quot;&gt;&lt;code&gt;numpy.power&lt;/code&gt;&lt;/a&gt; is not supported, &lt;code&gt;third&lt;/code&gt; has to be None.</source>
          <target state="translated">&lt;em&gt;Из&lt;/em&gt; аргумента &lt;a href=&quot;numpy.power#numpy.power&quot;&gt; &lt;code&gt;numpy.power&lt;/code&gt; &lt;/a&gt; не поддерживается, &lt;code&gt;third&lt;/code&gt; имеют не должна быть ни один.</target>
        </trans-unit>
        <trans-unit id="17d0c90784f11b0394d45b1939c2a01c10fdf407" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;shape&lt;/em&gt; is the fixed shape of the sub-array described by this data type, and &lt;em&gt;item_dtype&lt;/em&gt; the data type of the array.</source>
          <target state="translated">&lt;em&gt;Форма&lt;/em&gt; представляет собой фиксированную форму суб-массива , описанного этим типом данных, и &lt;em&gt;item_dtype&lt;/em&gt; тип данных массива.</target>
        </trans-unit>
        <trans-unit id="aec9eb1678f53d31cf0a922b19885b55fcafd16e" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;side&lt;/em&gt; argument indicates whether the index returned should be that of the first suitable location (if &lt;a href=&quot;#c.NPY_SEARCHLEFT&quot;&gt;&lt;code&gt;NPY_SEARCHLEFT&lt;/code&gt;&lt;/a&gt;) or of the last (if &lt;a href=&quot;#c.NPY_SEARCHRIGHT&quot;&gt;&lt;code&gt;NPY_SEARCHRIGHT&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e35e90d2e4f0ba849a49c1795babe3ab2a9f08fe" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;side&lt;/em&gt; argument indicates whether the index returned should be that of the first suitable location (if &lt;code&gt;NPY_SEARCHLEFT&lt;/code&gt;) or of the last (if &lt;code&gt;NPY_SEARCHRIGHT&lt;/code&gt;).</source>
          <target state="translated">&lt;em&gt;Сторона&lt;/em&gt; аргумент указывает ли индекс должен быть возвращен , что в первом подходящем месте (если &lt;code&gt;NPY_SEARCHLEFT&lt;/code&gt; ) или из последних (если &lt;code&gt;NPY_SEARCHRIGHT&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="099bc64f90d3db4f6c006d553b07493bf40349bd" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;sorter&lt;/em&gt; argument, if not &lt;code&gt;NULL&lt;/code&gt;, must be a 1D array of integer indices the same length as &lt;em&gt;self&lt;/em&gt;, that sorts it into ascending order. This is typically the result of a call to &lt;a href=&quot;#c.PyArray_ArgSort&quot;&gt;&lt;code&gt;PyArray_ArgSort&lt;/code&gt;&lt;/a&gt; (&amp;hellip;) Binary search is used to find the required insertion points.</source>
          <target state="translated">&lt;em&gt;Сортировщик&lt;/em&gt; аргумент, если не &lt;code&gt;NULL&lt;/code&gt; , должен быть массив 1D целочисленных индексов такой же длины , как и &lt;em&gt;я&lt;/em&gt; , что сортирует их в порядке возрастания. Обычно это результат вызова &lt;a href=&quot;#c.PyArray_ArgSort&quot;&gt; &lt;code&gt;PyArray_ArgSort&lt;/code&gt; &lt;/a&gt; (&amp;hellip;). Двоичный поиск используется для поиска необходимых точек вставки.</target>
        </trans-unit>
        <trans-unit id="9171c42e0d10b56599a94002523d8b2e0c0e8b3e" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;.npy&lt;/strong&gt; and &lt;strong&gt;.npz&lt;/strong&gt; files store data, shape, dtype, and other information required to reconstruct the ndarray in a way that allows the array to be correctly retrieved, even when the file is on another machine with different architecture.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a635945c029e67349a5e1c329cf33ef8efa9b4ec" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;dots&lt;/strong&gt; (&lt;code&gt;...&lt;/code&gt;) represent as many colons as needed to produce a complete indexing tuple. For example, if &lt;code&gt;x&lt;/code&gt; is an array with 5 axes, then</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7fad9b84d117a49a76f66aa7359451abb9299209" translate="yes" xml:space="preserve">
          <source>The API exposed by NumPy for third-party extensions has grown over years of releases, and has allowed programmers to directly access NumPy functionality from C. This API can be best described as &amp;ldquo;organic&amp;rdquo;. It has emerged from multiple competing desires and from multiple points of view over the years, strongly influenced by the desire to make it easy for users to move to NumPy from Numeric and Numarray. The core API originated with Numeric in 1995 and there are patterns such as the heavy use of macros written to mimic Python&amp;rsquo;s C-API as well as account for compiler technology of the late 90&amp;rsquo;s. There is also only a small group of volunteers who have had very little time to spend on improving this API.</source>
          <target state="translated">API, предоставляемый NumPy для сторонних расширений, вырос за годы выпусков и позволил программистам напрямую обращаться к функциям NumPy из C. Этот API лучше всего можно описать как &amp;laquo;органический&amp;raquo;. Он возник из множества конкурирующих желаний и с разных точек зрения на протяжении многих лет, под сильным влиянием желания облегчить пользователям переход на NumPy с Numeric и Numarray. Ядро API зародилось в Numeric в 1995 году, и есть такие закономерности, как интенсивное использование макросов, написанных для имитации C-API Python, а также с учетом технологии компиляторов конца 90-х. Также есть небольшая группа добровольцев, у которых было очень мало времени, чтобы потратить на улучшение этого API.</target>
        </trans-unit>
        <trans-unit id="00284168716cc312202174053f58f3f176efd9f0" translate="yes" xml:space="preserve">
          <source>The Array Interface</source>
          <target state="translated">Массивный интерфейс</target>
        </trans-unit>
        <trans-unit id="0126a67e2a45442b450ea70b10470e175bf968af" translate="yes" xml:space="preserve">
          <source>The Bartlett window is defined as</source>
          <target state="translated">Окно Бартлета определяется как</target>
        </trans-unit>
        <trans-unit id="937ca2e1b9d54c371bf73ce20e57493839ccf829" translate="yes" xml:space="preserve">
          <source>The Bartlett window is very similar to a triangular window, except that the end points are at zero. It is often used in signal processing for tapering a signal, without generating too much ripple in the frequency domain.</source>
          <target state="translated">Окно Бартлета очень похоже на треугольное окно,за исключением того,что конечные точки находятся на нуле.Оно часто используется при обработке сигнала для сужающегося сигнала,не создавая слишком большой пульсации в частотной области.</target>
        </trans-unit>
        <trans-unit id="a093f7952b1838c4dd6aeda28ea5e1fc38030960" translate="yes" xml:space="preserve">
          <source>The Basics</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c87b609239622a7f33fd7054a79bbe3b69d99bf" translate="yes" xml:space="preserve">
          <source>The Beta distribution is a special case of the Dirichlet distribution, and is related to the Gamma distribution. It has the probability distribution function</source>
          <target state="translated">Бета-дистрибуция является особым случаем дирихлетского дистрибутива и связана с гамма-дистрибутивом.Оно имеет функцию вероятностного распределения</target>
        </trans-unit>
        <trans-unit id="2fd0f76d8d8eab0518886bc71aed9b0148fca33e" translate="yes" xml:space="preserve">
          <source>The BitGenerator can also be directly accessed using the members of the &lt;code&gt;bitgen_t&lt;/code&gt; struct.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b111fe41355b271c80f9d028d2e71b1df692e910" translate="yes" xml:space="preserve">
          <source>The BitGenerator can also be directly accessed using the members of the basic RNG structure.</source>
          <target state="translated">К BitGenerator можно получить прямой доступ,используя членов базовой структуры RNG.</target>
        </trans-unit>
        <trans-unit id="fe9a0ff0e1aba5f3307dd340548f412e309bd12d" translate="yes" xml:space="preserve">
          <source>The BitGenerators have been designed to be extendable using standard tools for high-performance Python &amp;ndash; numba and Cython. The &lt;a href=&quot;generator#numpy.random.Generator&quot;&gt;&lt;code&gt;Generator&lt;/code&gt;&lt;/a&gt; object can also be used with user-provided BitGenerators as long as these export a small set of required functions.</source>
          <target state="translated">BitGenerators были разработаны с возможностью расширения с использованием стандартных инструментов для высокопроизводительного Python - numba и Cython. Объект &lt;a href=&quot;generator#numpy.random.Generator&quot;&gt; &lt;code&gt;Generator&lt;/code&gt; &lt;/a&gt; также можно использовать с предоставленными пользователем BitGenerators, если они экспортируют небольшой набор необходимых функций.</target>
        </trans-unit>
        <trans-unit id="d038e7d7a9d5b6013d6bf710bb0f42c26b9ffb86" translate="yes" xml:space="preserve">
          <source>The Blackman window is a taper formed by using the first three terms of a summation of cosines. It was designed to have close to the minimal leakage possible. It is close to optimal, only slightly worse than a Kaiser window.</source>
          <target state="translated">Окно Blackman-это конус,образованный с помощью первых трех терминов суммирования косинусов.Оно было спроектировано таким образом,чтобы иметь почти минимальную утечку.Оно близко к оптимальному,только немного хуже,чем окно Кайзера.</target>
        </trans-unit>
        <trans-unit id="df8aff554aa2b04bd579ded0666721d3f45ae21e" translate="yes" xml:space="preserve">
          <source>The Blackman window is defined as</source>
          <target state="translated">Окно Blackman определяется как</target>
        </trans-unit>
        <trans-unit id="b108efac05f697f2e430596f72b3bb61068c8903" translate="yes" xml:space="preserve">
          <source>The Box-Muller method used to produce NumPy&amp;rsquo;s normals is no longer available in &lt;a href=&quot;generator#numpy.random.Generator&quot;&gt;&lt;code&gt;Generator&lt;/code&gt;&lt;/a&gt;. It is not possible to reproduce the exact random values using &lt;code&gt;Generator&lt;/code&gt; for the normal distribution or any other distribution that relies on the normal such as the &lt;a href=&quot;generated/numpy.random.generator.gamma#numpy.random.Generator.gamma&quot;&gt;&lt;code&gt;Generator.gamma&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;generated/numpy.random.generator.standard_t#numpy.random.Generator.standard_t&quot;&gt;&lt;code&gt;Generator.standard_t&lt;/code&gt;&lt;/a&gt;. If you require bitwise backward compatible streams, use &lt;a href=&quot;legacy#numpy.random.RandomState&quot;&gt;&lt;code&gt;RandomState&lt;/code&gt;&lt;/a&gt;, i.e., &lt;a href=&quot;generated/numpy.random.randomstate.gamma#numpy.random.RandomState.gamma&quot;&gt;&lt;code&gt;RandomState.gamma&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;generated/numpy.random.randomstate.standard_t#numpy.random.RandomState.standard_t&quot;&gt;&lt;code&gt;RandomState.standard_t&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="201133c822c73c7e6eedbd7735bf455db76c868e" translate="yes" xml:space="preserve">
          <source>The Box-Muller method used to produce NumPy&amp;rsquo;s normals is no longer available in &lt;a href=&quot;generator#numpy.random.Generator&quot;&gt;&lt;code&gt;Generator&lt;/code&gt;&lt;/a&gt;. It is not possible to reproduce the exact random values using &lt;code&gt;Generator&lt;/code&gt; for the normal distribution or any other distribution that relies on the normal such as the &lt;code&gt;gamma&lt;/code&gt; or &lt;code&gt;standard_t&lt;/code&gt;. If you require bitwise backward compatible streams, use &lt;code&gt;RandomState&lt;/code&gt;.</source>
          <target state="translated">Метод Бокса-Мюллера, используемый для создания нормалей NumPy, больше не доступен в &lt;a href=&quot;generator#numpy.random.Generator&quot;&gt; &lt;code&gt;Generator&lt;/code&gt; &lt;/a&gt; . Невозможно воспроизвести точные случайные значения с помощью &lt;code&gt;Generator&lt;/code&gt; для нормального распределения или любого другого распределения, которое полагается на нормальное, такое как &lt;code&gt;gamma&lt;/code&gt; или &lt;code&gt;standard_t&lt;/code&gt; . Если вам требуются побитовые потоки с обратной совместимостью, используйте &lt;code&gt;RandomState&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="530afb1a91925fe435a9294f8360e96b319ffb64" translate="yes" xml:space="preserve">
          <source>The Box-Muller method used to produce NumPy&amp;rsquo;s normals is no longer available in &lt;a href=&quot;generator#numpy.random.Generator&quot;&gt;&lt;code&gt;Generator&lt;/code&gt;&lt;/a&gt;. It is not possible to reproduce the exact random values using Generator for the normal distribution or any other distribution that relies on the normal such as the &lt;a href=&quot;generated/numpy.random.mtrand.randomstate.gamma#numpy.random.mtrand.RandomState.gamma&quot;&gt;&lt;code&gt;RandomState.gamma&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;generated/numpy.random.mtrand.randomstate.standard_t#numpy.random.mtrand.RandomState.standard_t&quot;&gt;&lt;code&gt;RandomState.standard_t&lt;/code&gt;&lt;/a&gt;. If you require bitwise backward compatible streams, use &lt;a href=&quot;legacy#numpy.random.mtrand.RandomState&quot;&gt;&lt;code&gt;RandomState&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Метод Бокса-Мюллера, используемый для создания нормалей NumPy, больше не доступен в &lt;a href=&quot;generator#numpy.random.Generator&quot;&gt; &lt;code&gt;Generator&lt;/code&gt; &lt;/a&gt; . Невозможно воспроизвести точные случайные значения с помощью генератора для нормального распределения или любого другого распределения, которое основывается на нормальном, например &lt;a href=&quot;generated/numpy.random.mtrand.randomstate.gamma#numpy.random.mtrand.RandomState.gamma&quot;&gt; &lt;code&gt;RandomState.gamma&lt;/code&gt; &lt;/a&gt; или &lt;a href=&quot;generated/numpy.random.mtrand.randomstate.standard_t#numpy.random.mtrand.RandomState.standard_t&quot;&gt; &lt;code&gt;RandomState.standard_t&lt;/code&gt; &lt;/a&gt; . Если вам требуются побитовые потоки с обратной совместимостью, используйте &lt;a href=&quot;legacy#numpy.random.mtrand.RandomState&quot;&gt; &lt;code&gt;RandomState&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="21ca435d6d38aadf77947319cb2cc6cd824fa4fc" translate="yes" xml:space="preserve">
          <source>The Box-Muller method used to produce NumPy&amp;rsquo;s normals is no longer available in &lt;a href=&quot;generator#numpy.random.Generator&quot;&gt;&lt;code&gt;Generator&lt;/code&gt;&lt;/a&gt;. It is not possible to reproduce the exact random values using Generator for the normal distribution or any other distribution that relies on the normal such as the &lt;a href=&quot;generated/numpy.random.randomstate.gamma#numpy.random.RandomState.gamma&quot;&gt;&lt;code&gt;RandomState.gamma&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;generated/numpy.random.randomstate.standard_t#numpy.random.RandomState.standard_t&quot;&gt;&lt;code&gt;RandomState.standard_t&lt;/code&gt;&lt;/a&gt;. If you require bitwise backward compatible streams, use &lt;a href=&quot;legacy#numpy.random.RandomState&quot;&gt;&lt;code&gt;RandomState&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="08ca8f1d4aa8ba16007dde802489e6ef41f52bf0" translate="yes" xml:space="preserve">
          <source>The Box-Muller method used to produce NumPy&amp;rsquo;s normals is no longer available.</source>
          <target state="translated">Метод Бокса-Мюллера, используемый для создания нормалей NumPy, больше не доступен.</target>
        </trans-unit>
        <trans-unit id="2ae4a149c67359ea20a856b43946c0a1b6f16635" translate="yes" xml:space="preserve">
          <source>The Broadcasting Rule</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9895a5af5b1d937c582f3977255f2f51e2fa8cde" translate="yes" xml:space="preserve">
          <source>The C ABI version number in numpy/core/setup_common.py should only be updated for a major release.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9f1ca425ef21b0d3713606817fa90d6d2d43ef46" translate="yes" xml:space="preserve">
          <source>The C API version needs to be tracked in three places</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="12c85becd504bcc9e1840ed9b25393915f66f319" translate="yes" xml:space="preserve">
          <source>The C code to be wrapped for argoutview arrays are characterized by pointers: pointers to the dimensions and double pointers to the data, so that these values can be passed back to the user. The argoutview typemap signatures are therefore</source>
          <target state="translated">Код на языке Си,который должен быть обернут для массивов argoutview,характеризуется указателями:указателями на размеры и двойными указателями на данные,так что эти значения могут быть переданы обратно пользователю.Следовательно,сигнатуры карты типов argoutview являются следующими</target>
        </trans-unit>
        <trans-unit id="21de11f0f6aeb101275d43918daa34e6c36dce23" translate="yes" xml:space="preserve">
          <source>The C file is given below.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce59a78e88c7f509dea5f34f975be44fdfb7e3ba" translate="yes" xml:space="preserve">
          <source>The C file is given below. The ufunc generated takes two arguments A and B. It returns a tuple whose first element is A*B and whose second element is logit(A*B). Note that it automatically supports broadcasting, as well as all other properties of a ufunc.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b86dcfa016c911d4342c93c728710eb6da34647" translate="yes" xml:space="preserve">
          <source>The C-API is actually an array of function pointers. This array is created (and pointed to by a global variable) by import_ufunc. The global variable is either statically defined or allowed to be seen by other files depending on the state of &lt;a href=&quot;#c.PY_UFUNC_UNIQUE_SYMBOL&quot;&gt;&lt;code&gt;PY_UFUNC_UNIQUE_SYMBOL&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#c.NO_IMPORT_UFUNC&quot;&gt;&lt;code&gt;NO_IMPORT_UFUNC&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">C-API на самом деле представляет собой массив указателей на функции. Этот массив создается (и указывается глобальной переменной) с помощью import_ufunc. Глобальная переменная либо определяется статически, либо может быть видна другим файлам в зависимости от состояния &lt;a href=&quot;#c.PY_UFUNC_UNIQUE_SYMBOL&quot;&gt; &lt;code&gt;PY_UFUNC_UNIQUE_SYMBOL&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;#c.NO_IMPORT_UFUNC&quot;&gt; &lt;code&gt;NO_IMPORT_UFUNC&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="96e666c1c0b5a663da4c4f946173e189e8d49d4f" translate="yes" xml:space="preserve">
          <source>The C-code generated by Cython is hard to read and modify (and typically compiles with annoying but harmless warnings).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="27ac48dd933ed72b23987767613d8001cf662454" translate="yes" xml:space="preserve">
          <source>The C-structure corresponding to an object of &lt;a href=&quot;#c.PyArrayIter_Type&quot;&gt;&lt;code&gt;PyArrayIter_Type&lt;/code&gt;&lt;/a&gt; is the &lt;a href=&quot;#c.PyArrayIterObject&quot;&gt;&lt;code&gt;PyArrayIterObject&lt;/code&gt;&lt;/a&gt;. The &lt;a href=&quot;#c.PyArrayIterObject&quot;&gt;&lt;code&gt;PyArrayIterObject&lt;/code&gt;&lt;/a&gt; is used to keep track of a pointer into an N-dimensional array. It contains associated information used to quickly march through the array. The pointer can be adjusted in three basic ways: 1) advance to the &amp;ldquo;next&amp;rdquo; position in the array in a C-style contiguous fashion, 2) advance to an arbitrary N-dimensional coordinate in the array, and 3) advance to an arbitrary one-dimensional index into the array. The members of the &lt;a href=&quot;#c.PyArrayIterObject&quot;&gt;&lt;code&gt;PyArrayIterObject&lt;/code&gt;&lt;/a&gt; structure are used in these calculations. Iterator objects keep their own dimension and strides information about an array. This can be adjusted as needed for &amp;ldquo;broadcasting,&amp;rdquo; or to loop over only specific dimensions.</source>
          <target state="translated">C-структура, соответствующая объекту &lt;a href=&quot;#c.PyArrayIter_Type&quot;&gt; &lt;code&gt;PyArrayIter_Type&lt;/code&gt; ,&lt;/a&gt; - это &lt;a href=&quot;#c.PyArrayIterObject&quot;&gt; &lt;code&gt;PyArrayIterObject&lt;/code&gt; &lt;/a&gt; . &lt;a href=&quot;#c.PyArrayIterObject&quot;&gt; &lt;code&gt;PyArrayIterObject&lt;/code&gt; &lt;/a&gt; используется для отслеживания указателя в N-мерный массив. Он содержит связанную информацию, используемую для быстрого перехода по массиву. Указатель можно настроить тремя основными способами: 1) перейти к &amp;laquo;следующей&amp;raquo; позиции в массиве непрерывным способом в стиле C, 2) перейти к произвольной N-мерной координате в массиве и 3) перейти к произвольный одномерный индекс в массив. Члены &lt;a href=&quot;#c.PyArrayIterObject&quot;&gt; &lt;code&gt;PyArrayIterObject&lt;/code&gt; &lt;/a&gt;структуры используются в этих расчетах. Объекты-итераторы сохраняют свое собственное измерение и передают информацию о массиве. Это можно отрегулировать по мере необходимости для &amp;laquo;широковещательной передачи&amp;raquo; или для обхода только определенных измерений.</target>
        </trans-unit>
        <trans-unit id="5b65035b5e2ef1f9ddd680e8269d8b6e8cd78edf" translate="yes" xml:space="preserve">
          <source>The C-structure corresponding to an object of &lt;a href=&quot;#c.PyArrayNeighborhoodIter_Type&quot;&gt;&lt;code&gt;PyArrayNeighborhoodIter_Type&lt;/code&gt;&lt;/a&gt; is the &lt;a href=&quot;#c.PyArrayNeighborhoodIterObject&quot;&gt;&lt;code&gt;PyArrayNeighborhoodIterObject&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">C-структура, соответствующая объекту &lt;a href=&quot;#c.PyArrayNeighborhoodIter_Type&quot;&gt; &lt;code&gt;PyArrayNeighborhoodIter_Type&lt;/code&gt; ,&lt;/a&gt; - это &lt;a href=&quot;#c.PyArrayNeighborhoodIterObject&quot;&gt; &lt;code&gt;PyArrayNeighborhoodIterObject&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b70a592ea3e52c944c4250fca143b3a7150ee3c2" translate="yes" xml:space="preserve">
          <source>The Cauchy distribution arises in the solution to the driven harmonic oscillator problem, and also describes spectral line broadening. It also describes the distribution of values at which a line tilted at a random angle will cut the x axis.</source>
          <target state="translated">Распределение Коши возникает при решении задачи управляемого гармонического осциллятора,а также описывает расширение спектральных линий.Оно также описывает распределение значений,при котором линия,наклоненная под случайным углом,отрежет ось Х.</target>
        </trans-unit>
        <trans-unit id="7e16b7bac76fd95a18826e75104c29f03fcae229" translate="yes" xml:space="preserve">
          <source>The Chebyshev class provides the standard Python numerical methods &amp;lsquo;+&amp;rsquo;, &amp;lsquo;-&amp;lsquo;, &amp;lsquo;*&amp;rsquo;, &amp;lsquo;//&amp;rsquo;, &amp;lsquo;%&amp;rsquo;, &amp;lsquo;divmod&amp;rsquo;, &amp;lsquo;**&amp;rsquo;, and &amp;lsquo;()&amp;rsquo; as well as the methods listed below.</source>
          <target state="translated">Класс Чебышева предоставляет стандартные числовые методы Python '+', '-', '*', '//', '%', 'divmod', '**' и '()', а также перечисленные методы ниже.</target>
        </trans-unit>
        <trans-unit id="c6a112ce3f849b264d8d346313df28993dc02ff9" translate="yes" xml:space="preserve">
          <source>The Chebyshev points of the first kind are the points &lt;code&gt;cos(x)&lt;/code&gt;, where &lt;code&gt;x = [pi*(k + .5)/npts for k in range(npts)]&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b0a900a5e45540387f1b83ea73e67c934d19eae" translate="yes" xml:space="preserve">
          <source>The Chebyshev points of the first kind.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca4f0f30abc65b046f7d9e6e691b51c78603fec0" translate="yes" xml:space="preserve">
          <source>The Chebyshev points of the second kind are the points &lt;code&gt;cos(x)&lt;/code&gt;, where &lt;code&gt;x = [pi*k/(npts - 1) for k in range(npts)]&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="196d20b8bbd6f4729eb062a203e433edbc71fdcc" translate="yes" xml:space="preserve">
          <source>The Chebyshev points of the second kind.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="18aa36d5e6637359f0f8c985312900157e497010" translate="yes" xml:space="preserve">
          <source>The Chebyshev polynomials used in the interpolation are orthogonal when sampled at the Chebyshev points of the first kind. If it is desired to constrain some of the coefficients they can simply be set to the desired value after the interpolation, no new interpolation or fit is needed. This is especially useful if it is known apriori that some of coefficients are zero. For instance, if the function is even then the coefficients of the terms of odd degree in the result can be set to zero.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="993466511b9f370f4f72797c543b0fe46fcac4af" translate="yes" xml:space="preserve">
          <source>The Chebyshev series basis polynomials aren&amp;rsquo;t powers of &lt;code&gt;x&lt;/code&gt; so the results of this function may seem unintuitive.</source>
          <target state="translated">Базисные полиномы ряда Чебышева не являются степенями &lt;code&gt;x&lt;/code&gt; , поэтому результаты этой функции могут показаться неинтуитивными.</target>
        </trans-unit>
        <trans-unit id="46d5d357969a2c2d8e943734dcd70f209f532e7d" translate="yes" xml:space="preserve">
          <source>The Cholesky decomposition is often used as a fast way of solving</source>
          <target state="translated">Разложение Холесского часто используется в качестве быстрого способа разложения</target>
        </trans-unit>
        <trans-unit id="794b3c9b410012bd85aeaac5a58c341f1529d513" translate="yes" xml:space="preserve">
          <source>The Code of Conduct Committee should aim to have a resolution agreed upon within two weeks. In the event that a resolution can&amp;rsquo;t be determined in that time, the committee will respond to the reporter(s) with an update and projected timeline for resolution.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df5489514988058a36fb9ae08de6595979ec21a6" translate="yes" xml:space="preserve">
          <source>The Code of Conduct Committee will formally review and sign off on all cases where this mechanism has been applied to make sure it is not being used to control ordinary heated disagreement.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e3bda4dc5a743a992fdb89cad8080af0867b844" translate="yes" xml:space="preserve">
          <source>The Council can create subcommittees that provide leadership and guidance for specific aspects of the project. Like the Council as a whole, subcommittees should conduct their business in an open and public manner unless privacy is specifically called for. Private subcommittee communications should happen on the main private mailing list of the Council unless specifically called for.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7cca4e29456fdc96aaa3058f6b88f125bd4fb528" translate="yes" xml:space="preserve">
          <source>The Council reserves the right to eject current Members, if they are deemed to be actively harmful to the project&amp;rsquo;s well-being, and attempts at communication and conflict resolution have failed. This requires the consensus of the remaining Members.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="777c1bc322cb9c22bf40b3217235aef27f1cd1cf" translate="yes" xml:space="preserve">
          <source>The Council will maintain one narrowly focused subcommittee to manage its interactions with NumFOCUS.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7319ec02e3cbbaab7add308cd0a417516f369a3b" translate="yes" xml:space="preserve">
          <source>The DFT is defined, with the conventions used in this implementation, in the documentation for the &lt;a href=&quot;../routines.fft#module-numpy.fft&quot;&gt;&lt;code&gt;numpy.fft&lt;/code&gt;&lt;/a&gt; module.</source>
          <target state="translated">ДПФ определяется с использованием соглашений, используемых в этой реализации, в документации для модуля &lt;a href=&quot;../routines.fft#module-numpy.fft&quot;&gt; &lt;code&gt;numpy.fft&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c850428d828f95dc2c92af14d3b7a369fbb6f873" translate="yes" xml:space="preserve">
          <source>The DFT is in general defined for complex inputs and outputs, and a single-frequency component at linear frequency</source>
          <target state="translated">DFT,как правило,определяется для сложных входов и выходов,а также одночастотной составляющей на линейной частоте.</target>
        </trans-unit>
        <trans-unit id="e1f0dbe8081449397bad0aa2cc6ad0fe41215d23" translate="yes" xml:space="preserve">
          <source>The Datetime and Timedelta data types support a large number of time units, as well as generic units which can be coerced into any of the other units based on input data.</source>
          <target state="translated">Типы данных Datetime и Timedelta поддерживают большое количество единиц времени,а также общие единицы,которые могут быть принудительно введены в любой из других блоков на основе входных данных.</target>
        </trans-unit>
        <trans-unit id="fcc8fbde1f068047c588e86f64b1d9bca100dc12" translate="yes" xml:space="preserve">
          <source>The Dirichlet distribution is a distribution over vectors</source>
          <target state="translated">Дирихлетское распределение-это распределение по векторам.</target>
        </trans-unit>
        <trans-unit id="a4edf1637ded5c0257b8e49c407baa1302046498" translate="yes" xml:space="preserve">
          <source>The Einstein summation convention can be used to compute many multi-dimensional, linear algebraic array operations. &lt;a href=&quot;#numpy.einsum&quot;&gt;&lt;code&gt;einsum&lt;/code&gt;&lt;/a&gt; provides a succinct way of representing these.</source>
          <target state="translated">Соглашение Эйнштейна о суммировании можно использовать для вычисления многих многомерных операций с линейными алгебраическими массивами. &lt;a href=&quot;#numpy.einsum&quot;&gt; &lt;code&gt;einsum&lt;/code&gt; &lt;/a&gt; предоставляет сжатый способ их представления.</target>
        </trans-unit>
        <trans-unit id="28b073ac0a61d366802edc13aac74cfca673e0d2" translate="yes" xml:space="preserve">
          <source>The Euler constant</source>
          <target state="translated">Константа Эйлера</target>
        </trans-unit>
        <trans-unit id="e516b8e0c93fdf83378c5af74b4c3f11ab8b2eec" translate="yes" xml:space="preserve">
          <source>The F statistic is used to compare in-group variances to between-group variances. Calculating the distribution depends on the sampling, and so it is a function of the respective degrees of freedom in the problem. The variable &lt;code&gt;dfnum&lt;/code&gt; is the number of samples minus one, the between-groups degrees of freedom, while &lt;code&gt;dfden&lt;/code&gt; is the within-groups degrees of freedom, the sum of the number of samples in each group minus the number of groups.</source>
          <target state="translated">Статистика F используется для сравнения внутригрупповых отклонений с межгрупповыми отклонениями. Расчет распределения зависит от выборки и, следовательно, является функцией соответствующих степеней свободы в задаче. Переменная &lt;code&gt;dfnum&lt;/code&gt; - это количество образцов минус один, степени свободы между группами, а &lt;code&gt;dfden&lt;/code&gt; - это степени свободы внутри групп, сумма количества образцов в каждой группе за вычетом количества групп.</target>
        </trans-unit>
        <trans-unit id="ec341083311bc5d9e93dc0e719289499e7876f9f" translate="yes" xml:space="preserve">
          <source>The F2PY interface to Fortran 90 module data is similar to Fortran 77 common blocks.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="255611abe871551a6f0d10449c721d9ac320d3a5" translate="yes" xml:space="preserve">
          <source>The Frobenius norm is given by &lt;a href=&quot;#rac1c834adb66-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt;:</source>
          <target state="translated">Норма Фробениуса дается формулой &lt;a href=&quot;#rac1c834adb66-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="4ebf7b4a74f003f8630476569ef53bec8c91caed" translate="yes" xml:space="preserve">
          <source>The GIL is released for all &lt;code&gt;np.einsum&lt;/code&gt; variations</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7783b7563d5c19477bd0cec8f560b128f37ead00" translate="yes" xml:space="preserve">
          <source>The Gamma distribution is often used to model the times to failure of electronic components, and arises naturally in processes for which the waiting times between Poisson distributed events are relevant.</source>
          <target state="translated">Распределение Гаммы часто используется для моделирования времени до отказа электронных компонентов,и возникает естественным образом в процессах,для которых релевантно время ожидания между распределенными событиями Пуассона.</target>
        </trans-unit>
        <trans-unit id="9c990e445bfb7966adc1e3b9adac640f1e0e9113" translate="yes" xml:space="preserve">
          <source>The Generator&amp;rsquo;s normal, exponential and gamma functions use 256-step Ziggurat methods which are 2-10 times faster than NumPy&amp;rsquo;s Box-Muller or inverse CDF implementations.</source>
          <target state="translated">Нормальные, экспоненциальные и гамма-функции Генератора используют 256-шаговые методы Ziggurat, которые в 2-10 раз быстрее, чем реализация NumPy Box-Muller или обратная реализация CDF.</target>
        </trans-unit>
        <trans-unit id="5fd129bc188ef44c6bd32a38b068d9f3ddc783f7" translate="yes" xml:space="preserve">
          <source>The Gumbel (named for German mathematician Emil Julius Gumbel) was used very early in the hydrology literature, for modeling the occurrence of flood events. It is also used for modeling maximum wind speed and rainfall rates. It is a &amp;ldquo;fat-tailed&amp;rdquo; distribution - the probability of an event in the tail of the distribution is larger than if one used a Gaussian, hence the surprisingly frequent occurrence of 100-year floods. Floods were initially modeled as a Gaussian process, which underestimated the frequency of extreme events.</source>
          <target state="translated">Гумбель (названный в честь немецкого математика Эмиля Юлиуса Гумбеля) использовался очень рано в литературе по гидрологии для моделирования возникновения наводнений. Он также используется для моделирования максимальной скорости ветра и количества осадков. Это распределение с &amp;laquo;толстым хвостом&amp;raquo; - вероятность события в хвосте распределения выше, чем при использовании гауссианы, отсюда удивительно частое возникновение 100-летних наводнений. Первоначально наводнения моделировались как гауссовский процесс, который недооценивал частоту экстремальных явлений.</target>
        </trans-unit>
        <trans-unit id="aa1cbdb34f4d0d2f5ba482222c9284e53a83897b" translate="yes" xml:space="preserve">
          <source>The Gumbel (or Smallest Extreme Value (SEV) or the Smallest Extreme Value Type I) distribution is one of a class of Generalized Extreme Value (GEV) distributions used in modeling extreme value problems. The Gumbel is a special case of the Extreme Value Type I distribution for maximums from distributions with &amp;ldquo;exponential-like&amp;rdquo; tails.</source>
          <target state="translated">Распределение Гамбеля (или наименьшего экстремального значения (SEV) или наименьшего экстремального значения, тип I) является одним из класса распределений обобщенного экстремального значения (GEV), используемых при моделировании проблем экстремальных значений. Gumbel - это частный случай распределения типа I с экстремальным значением для максимумов из распределений с &amp;laquo;экспоненциальными&amp;raquo; хвостами.</target>
        </trans-unit>
        <trans-unit id="d38e3c533241c1cffef7a77e2fb316d839d0e953" translate="yes" xml:space="preserve">
          <source>The Hamming was named for R. W. Hamming, an associate of J. W. Tukey and is described in Blackman and Tukey. It was recommended for smoothing the truncated autocovariance function in the time domain. Most references to the Hamming window come from the signal processing literature, where it is used as one of many windowing functions for smoothing values. It is also known as an apodization (which means &amp;ldquo;removing the foot&amp;rdquo;, i.e. smoothing discontinuities at the beginning and end of the sampled signal) or tapering function.</source>
          <target state="translated">Хэмминг был назван в честь Р. У. Хэмминга, сотрудника Дж. У. Тьюки, и описан у Блэкмана и Тьюки. Он был рекомендован для сглаживания усеченной функции автоковариации во временной области. Большинство ссылок на окно Хэмминга происходит из литературы по обработке сигналов, где оно используется в качестве одной из многих оконных функций для сглаживания значений. Это также известно как аподизация (что означает &amp;laquo;удаление стопы&amp;raquo;, т. Е. Сглаживание разрывов в начале и конце дискретизированного сигнала) или функция сужения.</target>
        </trans-unit>
        <trans-unit id="f6f99a10c7b1d0ed496e360cabc47ad0e8b4f95f" translate="yes" xml:space="preserve">
          <source>The Hamming window is a taper formed by using a weighted cosine.</source>
          <target state="translated">Окно Hamming представляет собой конус,образованный с помощью утяжеленного косинуса.</target>
        </trans-unit>
        <trans-unit id="c543c8775de7884a498fb8d25199a6da7865f313" translate="yes" xml:space="preserve">
          <source>The Hamming window is defined as</source>
          <target state="translated">Окно Хамминга определяется как</target>
        </trans-unit>
        <trans-unit id="c53c036c06b914f30dfda36ac484fab584082b10" translate="yes" xml:space="preserve">
          <source>The Hanning was named for Julius von Hann, an Austrian meteorologist. It is also known as the Cosine Bell. Some authors prefer that it be called a Hann window, to help avoid confusion with the very similar Hamming window.</source>
          <target state="translated">Ханнинг был назван в честь Юлиуса фон Ханна,австрийского метеоролога.Он также известен как &quot;Косиновый колокол&quot;.Некоторые авторы предпочитают,чтобы его называли &quot;окном Ханна&quot;,чтобы избежать путаницы с очень похожим окном Хамминга.</target>
        </trans-unit>
        <trans-unit id="ff9ff54dbcac5fb28018a438cebbfd23097afaae" translate="yes" xml:space="preserve">
          <source>The Hanning window is a taper formed by using a weighted cosine.</source>
          <target state="translated">Окно Hanning-это конус,образованный с помощью утяжеленного косинуса.</target>
        </trans-unit>
        <trans-unit id="7063e81cb7e74fa0cdbf05d1c6333c059e7c5e09" translate="yes" xml:space="preserve">
          <source>The Hanning window is defined as</source>
          <target state="translated">Окно Hanning определяется как</target>
        </trans-unit>
        <trans-unit id="48a86546760e1edd4295f33a270bba0337fe9c75" translate="yes" xml:space="preserve">
          <source>The Heaviside step function is defined as:</source>
          <target state="translated">Функция шага Хевисайда определяется как:</target>
        </trans-unit>
        <trans-unit id="a4ab8a335073ed439b508ce34550cc0419ac6836" translate="yes" xml:space="preserve">
          <source>The Hermite class provides the standard Python numerical methods &amp;lsquo;+&amp;rsquo;, &amp;lsquo;-&amp;lsquo;, &amp;lsquo;*&amp;rsquo;, &amp;lsquo;//&amp;rsquo;, &amp;lsquo;%&amp;rsquo;, &amp;lsquo;divmod&amp;rsquo;, &amp;lsquo;**&amp;rsquo;, and &amp;lsquo;()&amp;rsquo; as well as the attributes and methods listed in the &lt;code&gt;ABCPolyBase&lt;/code&gt; documentation.</source>
          <target state="translated">Класс Hermite предоставляет стандартные числовые методы Python '+', '-', '*', '//', '%', 'divmod', '**' и '()', а также атрибуты и методы, перечисленные в документации &lt;code&gt;ABCPolyBase&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="18c51c2fe8d0823ca52707c91973d012f1770684" translate="yes" xml:space="preserve">
          <source>The Hermite series basis polynomials aren&amp;rsquo;t powers of &lt;code&gt;x&lt;/code&gt; so the results of this function may seem unintuitive.</source>
          <target state="translated">Базисные полиномы ряда Эрмита не являются степенями &lt;code&gt;x&lt;/code&gt; , поэтому результаты этой функции могут показаться неинтуитивными.</target>
        </trans-unit>
        <trans-unit id="29f886dede3063b00d8467b1f756a147bc393097" translate="yes" xml:space="preserve">
          <source>The HermiteE class provides the standard Python numerical methods &amp;lsquo;+&amp;rsquo;, &amp;lsquo;-&amp;lsquo;, &amp;lsquo;*&amp;rsquo;, &amp;lsquo;//&amp;rsquo;, &amp;lsquo;%&amp;rsquo;, &amp;lsquo;divmod&amp;rsquo;, &amp;lsquo;**&amp;rsquo;, and &amp;lsquo;()&amp;rsquo; as well as the attributes and methods listed in the &lt;code&gt;ABCPolyBase&lt;/code&gt; documentation.</source>
          <target state="translated">Класс HermiteE предоставляет стандартные числовые методы Python '+', '-', '*', '//', '%', 'divmod', '**' и '()', а также атрибуты и методы, перечисленные в документации &lt;code&gt;ABCPolyBase&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8cc8b1724a44c8d63d2cfd0d81bc585f17fc260c" translate="yes" xml:space="preserve">
          <source>The HermiteE series basis polynomials aren&amp;rsquo;t powers of &lt;code&gt;x&lt;/code&gt; so the results of this function may seem unintuitive.</source>
          <target state="translated">Базисные полиномы серии HermiteE не являются степенями &lt;code&gt;x&lt;/code&gt; , поэтому результаты этой функции могут показаться неинтуитивными.</target>
        </trans-unit>
        <trans-unit id="d4c697a75ca6fe93876f5946baa1a9463872c64a" translate="yes" xml:space="preserve">
          <source>The IRR is perhaps best understood through an example (illustrated using np.irr in the Examples section below). Suppose one invests 100 units and then makes the following withdrawals at regular (fixed) intervals: 39, 59, 55, 20. Assuming the ending value is 0, one&amp;rsquo;s 100 unit investment yields 173 units; however, due to the combination of compounding and the periodic withdrawals, the &amp;ldquo;average&amp;rdquo; rate of return is neither simply 0.73/4 nor (1.73)^0.25-1. Rather, it is the solution (for</source>
          <target state="translated">IRR, возможно, лучше всего понять на примере (проиллюстрированном с помощью np.irr в разделе &amp;laquo;Примеры&amp;raquo; ниже). Предположим, что кто-то инвестирует 100 единиц, а затем через регулярные (фиксированные) интервалы снимает следующие суммы: 39, 59, 55, 20. Предположим, что конечное значение равно 0, вложение 100 единиц дает 173 единицы; однако из-за комбинации начисления сложных процентов и периодического снятия средств &amp;laquo;средняя&amp;raquo; норма доходности не равна ни 0,73 / 4, ни (1,73) ^ 0,25-1. Скорее, это решение (для</target>
        </trans-unit>
        <trans-unit id="ddbfb62d79e442dbada344aa5b0b7d3f75bd62fd" translate="yes" xml:space="preserve">
          <source>The Kaiser can approximate many other windows by varying the beta parameter.</source>
          <target state="translated">Кайзер может приближаться ко многим другим окнам,изменяя параметр бета-версии.</target>
        </trans-unit>
        <trans-unit id="61a6a7b7c0a7a3c07a636b9187a5aa5c8ed22e80" translate="yes" xml:space="preserve">
          <source>The Kaiser was named for Jim Kaiser, who discovered a simple approximation to the DPSS window based on Bessel functions. The Kaiser window is a very good approximation to the Digital Prolate Spheroidal Sequence, or Slepian window, which is the transform which maximizes the energy in the main lobe of the window relative to total energy.</source>
          <target state="translated">Кайзер был назван в честь Джима Кайзера,который обнаружил простое приближение к окну DPSS,основанному на функциях Бесселя.Окно Кайзера является очень хорошим приближением к Цифровой Шаровидной последовательности,или Слепийскому окну,которое является преобразованием,которое максимизирует энергию в главной доле окна относительно полной энергии.</target>
        </trans-unit>
        <trans-unit id="3c47d6f84b8a7a5230ef01c3b24f485faf045505" translate="yes" xml:space="preserve">
          <source>The Kaiser window is a taper formed by using a Bessel function.</source>
          <target state="translated">Окно Кайзера представляет собой конус,образованный с помощью функции Бесселя.</target>
        </trans-unit>
        <trans-unit id="d40317952ac62ac63be6a7eb42d8bb031447a844" translate="yes" xml:space="preserve">
          <source>The Kaiser window is defined as</source>
          <target state="translated">Окно Кайзера определяется как</target>
        </trans-unit>
        <trans-unit id="de389ba4bc7accb91ca973f3199d4d09bb36d074" translate="yes" xml:space="preserve">
          <source>The Laguerre class provides the standard Python numerical methods &amp;lsquo;+&amp;rsquo;, &amp;lsquo;-&amp;lsquo;, &amp;lsquo;*&amp;rsquo;, &amp;lsquo;//&amp;rsquo;, &amp;lsquo;%&amp;rsquo;, &amp;lsquo;divmod&amp;rsquo;, &amp;lsquo;**&amp;rsquo;, and &amp;lsquo;()&amp;rsquo; as well as the attributes and methods listed in the &lt;code&gt;ABCPolyBase&lt;/code&gt; documentation.</source>
          <target state="translated">Класс Laguerre предоставляет стандартные числовые методы Python '+', '-', '*', '//', '%', 'divmod', '**' и '()', а также атрибуты и методы, перечисленные в документации &lt;code&gt;ABCPolyBase&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="673da347447c32096475798f43cd3eae37f1e962" translate="yes" xml:space="preserve">
          <source>The Laguerre series basis polynomials aren&amp;rsquo;t powers of &lt;code&gt;x&lt;/code&gt; so the results of this function may seem unintuitive.</source>
          <target state="translated">Базисные полиномы ряда Лагерра не являются степенями &lt;code&gt;x&lt;/code&gt; , поэтому результаты этой функции могут показаться неинтуитивными.</target>
        </trans-unit>
        <trans-unit id="beacaa427ac9dd11f90d057bc9c94b6f47608f00" translate="yes" xml:space="preserve">
          <source>The Laplace distribution is similar to the Gaussian/normal distribution, but is sharper at the peak and has fatter tails. It represents the difference between two independent, identically distributed exponential random variables.</source>
          <target state="translated">Распределение Лапласа аналогично гауссовскому/нормальному распределению,но острее на пике и имеет более толстые хвосты.Оно представляет собой разность между двумя независимыми,одинаково распределенными экспоненциальными случайными переменными.</target>
        </trans-unit>
        <trans-unit id="9f6965544802824fa340cc542a5a8e5ec41b1a8a" translate="yes" xml:space="preserve">
          <source>The Legendre class provides the standard Python numerical methods &amp;lsquo;+&amp;rsquo;, &amp;lsquo;-&amp;lsquo;, &amp;lsquo;*&amp;rsquo;, &amp;lsquo;//&amp;rsquo;, &amp;lsquo;%&amp;rsquo;, &amp;lsquo;divmod&amp;rsquo;, &amp;lsquo;**&amp;rsquo;, and &amp;lsquo;()&amp;rsquo; as well as the attributes and methods listed in the &lt;code&gt;ABCPolyBase&lt;/code&gt; documentation.</source>
          <target state="translated">Класс Legendre предоставляет стандартные числовые методы Python '+', '-', '*', '//', '%', 'divmod', '**' и '()', а также атрибуты и методы, перечисленные в документации &lt;code&gt;ABCPolyBase&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="083c119f1df4d844bfc4b2160deea854a1daea76" translate="yes" xml:space="preserve">
          <source>The Legendre series basis polynomials aren&amp;rsquo;t powers of &lt;code&gt;x&lt;/code&gt; so the results of this function may seem unintuitive.</source>
          <target state="translated">Базисные полиномы ряда Лежандра не являются степенями &lt;code&gt;x&lt;/code&gt; , поэтому результаты этой функции могут показаться неинтуитивными.</target>
        </trans-unit>
        <trans-unit id="191a6c01d66efbf4468b0c4b76d708edbb3efb30" translate="yes" xml:space="preserve">
          <source>The Logistic distribution is used in Extreme Value problems where it can act as a mixture of Gumbel distributions, in Epidemiology, and by the World Chess Federation (FIDE) where it is used in the Elo ranking system, assuming the performance of each player is a logistically distributed random variable.</source>
          <target state="translated">Логистическое распределение используется в задачах Extreme Value,где оно может действовать как смесь распределений Гумбеля,в Эпидемиологии и во Всемирной шахматной федерации (FIDE),где оно используется в системе ранжирования Эло,предполагая,что производительность каждого игрока является логистически распределенной случайной величиной.</target>
        </trans-unit>
        <trans-unit id="7e46f1b490ad93ea0aa4b70cea1c8217c1eeec4d" translate="yes" xml:space="preserve">
          <source>The Lomax or Pareto II distribution is a shifted Pareto distribution. The classical Pareto distribution can be obtained from the Lomax distribution by adding 1 and multiplying by the scale parameter &lt;code&gt;m&lt;/code&gt; (see Notes). The smallest value of the Lomax distribution is zero while for the classical Pareto distribution it is &lt;code&gt;mu&lt;/code&gt;, where the standard Pareto distribution has location &lt;code&gt;mu = 1&lt;/code&gt;. Lomax can also be considered as a simplified version of the Generalized Pareto distribution (available in SciPy), with the scale set to one and the location set to zero.</source>
          <target state="translated">Распределение Ломакса или Парето II является смещенным распределением Парето. Классическое распределение Парето может быть получено из распределения Ломакса путем добавления 1 и умножения на параметр масштаба &lt;code&gt;m&lt;/code&gt; (см. Примечания). Наименьшее значение распределения Ломакса равно нулю, в то время как для классического распределения Парето это &lt;code&gt;mu&lt;/code&gt; , где стандартное распределение Парето имеет местоположение &lt;code&gt;mu = 1&lt;/code&gt; . Lomax также можно рассматривать как упрощенную версию обобщенного распределения Парето (доступного в SciPy) с масштабом, установленным на единицу, и положением, установленным на ноль.</target>
        </trans-unit>
        <trans-unit id="913eec14ed443e489cdc77c2f2c24950a32724fd" translate="yes" xml:space="preserve">
          <source>The MATLAB &lt;code&gt;rem&lt;/code&gt; function and or the C &lt;code&gt;%&lt;/code&gt; operator which is the complement to &lt;code&gt;int(x1 / x2)&lt;/code&gt;.</source>
          <target state="translated">Функция MATLAB &lt;code&gt;rem&lt;/code&gt; и / или оператор C &lt;code&gt;%&lt;/code&gt; , который является дополнением к &lt;code&gt;int(x1 / x2)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="accc4f84d711af6e82c6efbbd034211d91d17fc7" translate="yes" xml:space="preserve">
          <source>The MaskedArray class</source>
          <target state="translated">Класс MaskedArray</target>
        </trans-unit>
        <trans-unit id="5110aa799914ad12dc0bd211beae0c5585bdbc96" translate="yes" xml:space="preserve">
          <source>The Matrix class</source>
          <target state="translated">Класс &quot;Матрица</target>
        </trans-unit>
        <trans-unit id="aae8587a9f8f2d6d760d4e3f9211a40fc1df3fef" translate="yes" xml:space="preserve">
          <source>The N-dimensional array (&lt;code&gt;ndarray&lt;/code&gt;)</source>
          <target state="translated">N-мерный массив ( &lt;code&gt;ndarray&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="ebbab7ca4ee7572bcfa080543866bf18ac7ca419" translate="yes" xml:space="preserve">
          <source>The N-dimensional array (ndarray)</source>
          <target state="translated">N-мерный массив (ndarray)</target>
        </trans-unit>
        <trans-unit id="9062ffe94800b2d5eac1ade12a3d3195e3fb90d9" translate="yes" xml:space="preserve">
          <source>The NPV of the input cash flow series &lt;code&gt;values&lt;/code&gt; at the discount &lt;a href=&quot;numpy.rate#numpy.rate&quot;&gt;&lt;code&gt;rate&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">NPV &lt;code&gt;values&lt;/code&gt; ряда входных денежных потоков по &lt;a href=&quot;numpy.rate#numpy.rate&quot;&gt; &lt;code&gt;rate&lt;/code&gt; &lt;/a&gt; дисконтирования .</target>
        </trans-unit>
        <trans-unit id="5866f74403500e7f4919cdc811cc2cfc492bf57b" translate="yes" xml:space="preserve">
          <source>The NVIDIA HPC SDK nvfortran compiler is now supported</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb50b084062a9f4384d9b2a21c7bda6e285e1c12" translate="yes" xml:space="preserve">
          <source>The NumFOCUS Subcommittee is comprised of 5 persons who manage project funding that comes through NumFOCUS. It is expected that these funds will be spent in a manner that is consistent with the non-profit mission of NumFOCUS and the direction of the Project as determined by the full Council.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="06341e3da348b45983c3d2e0a0cf15e91944f0fa" translate="yes" xml:space="preserve">
          <source>The NumPy 1.6 release includes a more primitive datetime data type than 1.7. This section documents many of the changes that have taken place.</source>
          <target state="translated">Релиз NumPy 1.6 включает более примитивный тип данных по дате,чем 1.7.В этом разделе документируются многие из произошедших изменений.</target>
        </trans-unit>
        <trans-unit id="5b56ea0dc221ea864b938eecd7f439b2151cafda" translate="yes" xml:space="preserve">
          <source>The NumPy &lt;code&gt;histogram&lt;/code&gt; function applied to an array returns a pair of vectors: the histogram of the array and a vector of the bin edges. Beware: &lt;code&gt;matplotlib&lt;/code&gt; also has a function to build histograms (called &lt;code&gt;hist&lt;/code&gt;, as in Matlab) that differs from the one in NumPy. The main difference is that &lt;code&gt;pylab.hist&lt;/code&gt; plots the histogram automatically, while &lt;code&gt;numpy.histogram&lt;/code&gt; only generates the data.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7115851ea78ca88c35b2190db524dfdbfb383870" translate="yes" xml:space="preserve">
          <source>The NumPy C coding conventions are based on Python PEP-0007 by Guido van Rossum with a few added strictures. There are many C coding conventions and it must be emphasized that the primary goal of the NumPy conventions isn&amp;rsquo;t to choose the &amp;lsquo;best&amp;rsquo;, about which there is certain to be disagreement, but to achieve uniformity. Because the NumPy conventions are very close to those in PEP-0007, that PEP is used as a template below with the NumPy additions and variations in the appropriate spots.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="04034fa7b7a5e94b567d768903257e06b83fadc3" translate="yes" xml:space="preserve">
          <source>The NumPy Project (The Project) is an open source software project affiliated with the 501(c)3 NumFOCUS Foundation. The goal of The Project is to develop open source software for array-based computing in Python, and in particular the &lt;code&gt;numpy&lt;/code&gt; package, along with related software such as &lt;code&gt;f2py&lt;/code&gt; and the NumPy Sphinx extensions. The Software developed by The Project is released under the BSD (or similar) open source license, developed openly and hosted on public GitHub repositories under the &lt;code&gt;numpy&lt;/code&gt; GitHub organization.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e7fe9a4dc07ec7ee2f30fa5e00a09db0b807ddfc" translate="yes" xml:space="preserve">
          <source>The NumPy community has set a firm goal of improving its documentation. We hold regular documentation meetings on Zoom (dates are announced on the &lt;a href=&quot;https://mail.python.org/mailman/listinfo/numpy-discussion&quot;&gt;numpy-discussion mailing list&lt;/a&gt;), and everyone is welcome. Reach out if you have questions or need someone to guide you through your first steps &amp;ndash; we&amp;rsquo;re happy to help. Minutes are taken &lt;a href=&quot;https://hackmd.io/oB_boakvRqKR-_2jRV-Qjg&quot;&gt;on hackmd.io&lt;/a&gt; and stored in the &lt;a href=&quot;https://github.com/numpy/archive&quot;&gt;NumPy Archive repository&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="318543629420726d92de226b61b0ea2568472ff7" translate="yes" xml:space="preserve">
          <source>The NumPy library contains multidimensional array and matrix data structures (you&amp;rsquo;ll find more information about this in later sections). It provides &lt;strong&gt;ndarray&lt;/strong&gt;, a homogeneous n-dimensional array object, with methods to efficiently operate on it. NumPy can be used to perform a wide variety of mathematical operations on arrays. It adds powerful data structures to Python that guarantee efficient calculations with arrays and matrices and it supplies an enormous library of high-level mathematical functions that operate on these arrays and matrices.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="22808a8257a77bd3771514110cd88913c8cbfe31" translate="yes" xml:space="preserve">
          <source>The NumPy linear algebra functions rely on BLAS and LAPACK to provide efficient low level implementations of standard linear algebra algorithms. Those libraries may be provided by NumPy itself using C versions of a subset of their reference implementations but, when possible, highly optimized libraries that take advantage of specialized processor functionality are preferred. Examples of such libraries are &lt;a href=&quot;https://www.openblas.net/&quot;&gt;OpenBLAS&lt;/a&gt;, MKL (TM), and ATLAS. Because those libraries are multithreaded and processor dependent, environmental variables and external packages such as &lt;a href=&quot;https://github.com/joblib/threadpoolctl&quot;&gt;threadpoolctl&lt;/a&gt; may be needed to control the number of threads or specify the processor architecture.</source>
          <target state="translated">Функции линейной алгебры NumPy полагаются на BLAS и LAPACK для обеспечения эффективных низкоуровневых реализаций стандартных алгоритмов линейной алгебры. Эти библиотеки могут быть предоставлены самим NumPy с использованием C-версий подмножества их эталонных реализаций, но, когда это возможно, предпочтительны высокооптимизированные библиотеки, которые используют преимущества специализированных функций процессора. Примерами таких библиотек являются &lt;a href=&quot;https://www.openblas.net/&quot;&gt;OpenBLAS&lt;/a&gt; , MKL &amp;trade; и ATLAS. Поскольку эти библиотеки являются многопоточными и зависят от процессора, могут потребоваться переменные среды и внешние пакеты, такие как &lt;a href=&quot;https://github.com/joblib/threadpoolctl&quot;&gt;threadpoolctl&lt;/a&gt; , для управления количеством потоков или определения архитектуры процессора.</target>
        </trans-unit>
        <trans-unit id="d47a0c6ae88af6350c5a45d963a159c319eddcab" translate="yes" xml:space="preserve">
          <source>The NumPy project welcomes and encourages participation by everyone. We are committed to being a community that everyone enjoys being part of. Although we may not always be able to accommodate each individual&amp;rsquo;s preferences, we try our best to treat everyone kindly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d3df208d2d18d19aa23dcbfeea9ad1c54e2544eb" translate="yes" xml:space="preserve">
          <source>The NumPy source code includes an example of a custom data-type as part of its test suite. The file &lt;code&gt;_rational_tests.c.src&lt;/code&gt; in the source code directory &lt;code&gt;numpy/numpy/core/src/umath/&lt;/code&gt; contains an implementation of a data-type that represents a rational number as the ratio of two 32 bit integers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5abe575872513074969d9820a4d531c3d12a22f7" translate="yes" xml:space="preserve">
          <source>The Pareto distribution must be greater than zero, and is unbounded above. It is also known as the &amp;ldquo;80-20 rule&amp;rdquo;. In this distribution, 80 percent of the weights are in the lowest 20 percent of the range, while the other 20 percent fill the remaining 80 percent of the range.</source>
          <target state="translated">Распределение Парето должно быть больше нуля и не ограничено сверху. Это также известно как &amp;laquo;правило 80-20&amp;raquo;. В этом распределении 80 процентов весов относятся к нижним 20 процентам диапазона, а остальные 20 процентов заполняют оставшиеся 80 процентов диапазона.</target>
        </trans-unit>
        <trans-unit id="b64969899a77da87dee3d04492ed6838966132f3" translate="yes" xml:space="preserve">
          <source>The Pareto distribution, named after the Italian economist Vilfredo Pareto, is a power law probability distribution useful in many real world problems. Outside the field of economics it is generally referred to as the Bradford distribution. Pareto developed the distribution to describe the distribution of wealth in an economy. It has also found use in insurance, web page access statistics, oil field sizes, and many other problems, including the download frequency for projects in Sourceforge &lt;a href=&quot;#r3973533a530a-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt;. It is one of the so-called &amp;ldquo;fat-tailed&amp;rdquo; distributions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7bc6e3f7c2b1acfa8159e10332ced928c3809746" translate="yes" xml:space="preserve">
          <source>The Pareto distribution, named after the Italian economist Vilfredo Pareto, is a power law probability distribution useful in many real world problems. Outside the field of economics it is generally referred to as the Bradford distribution. Pareto developed the distribution to describe the distribution of wealth in an economy. It has also found use in insurance, web page access statistics, oil field sizes, and many other problems, including the download frequency for projects in Sourceforge &lt;a href=&quot;#r4338a4b3d731-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt;. It is one of the so-called &amp;ldquo;fat-tailed&amp;rdquo; distributions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed5b998678bc3c838f5d54a5f0beb5816b99470d" translate="yes" xml:space="preserve">
          <source>The Pareto distribution, named after the Italian economist Vilfredo Pareto, is a power law probability distribution useful in many real world problems. Outside the field of economics it is generally referred to as the Bradford distribution. Pareto developed the distribution to describe the distribution of wealth in an economy. It has also found use in insurance, web page access statistics, oil field sizes, and many other problems, including the download frequency for projects in Sourceforge &lt;a href=&quot;#r8689274e67cd-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt;. It is one of the so-called &amp;ldquo;fat-tailed&amp;rdquo; distributions.</source>
          <target state="translated">Распределение Парето, названное в честь итальянского экономиста Вильфредо Парето, представляет собой степенное распределение вероятностей, которое можно использовать во многих реальных проблемах. За пределами области экономики его обычно называют распределением Брэдфорда. Парето разработал распределение для описания распределения богатства в экономике. Он также нашел применение в страховании, статистике доступа к веб-страницам, размерах нефтяных месторождений и во многих других задачах, включая частоту загрузки проектов в Sourceforge &lt;a href=&quot;#r8689274e67cd-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt; . Это одно из так называемых распределений с толстым хвостом.</target>
        </trans-unit>
        <trans-unit id="2867a07ee69e6406fe64c658305fdda7fb7b8075" translate="yes" xml:space="preserve">
          <source>The Pareto distribution, named after the Italian economist Vilfredo Pareto, is a power law probability distribution useful in many real world problems. Outside the field of economics it is generally referred to as the Bradford distribution. Pareto developed the distribution to describe the distribution of wealth in an economy. It has also found use in insurance, web page access statistics, oil field sizes, and many other problems, including the download frequency for projects in Sourceforge &lt;a href=&quot;#rc338d9f74bfc-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt;. It is one of the so-called &amp;ldquo;fat-tailed&amp;rdquo; distributions.</source>
          <target state="translated">Распределение Парето, названное в честь итальянского экономиста Вильфредо Парето, представляет собой степенное распределение вероятностей, которое можно использовать во многих реальных проблемах. За пределами области экономики его обычно называют распределением Брэдфорда. Парето разработал распределение для описания распределения богатства в экономике. Он также нашел применение в страховании, статистике доступа к веб-страницам, размерах нефтяных месторождений и во многих других задачах, включая частоту загрузки проектов в Sourceforge &lt;a href=&quot;#rc338d9f74bfc-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt; . Это одно из так называемых распределений с толстым хвостом.</target>
        </trans-unit>
        <trans-unit id="8aa87161535a17c7b4517b9679a26277a14402b5" translate="yes" xml:space="preserve">
          <source>The Poisson distribution</source>
          <target state="translated">Распределение Пуассона</target>
        </trans-unit>
        <trans-unit id="0ebdde94b2528198e1aa6a1394f362ff4a94706c" translate="yes" xml:space="preserve">
          <source>The Poisson distribution is the limit of the binomial distribution for large N.</source>
          <target state="translated">Распределение Пуассона является пределом биномиального распределения для больших N.</target>
        </trans-unit>
        <trans-unit id="9280ad29766a65718d4060a0ccabd4c148a5c905" translate="yes" xml:space="preserve">
          <source>The Polynomial class provides the standard Python numerical methods &amp;lsquo;+&amp;rsquo;, &amp;lsquo;-&amp;lsquo;, &amp;lsquo;*&amp;rsquo;, &amp;lsquo;//&amp;rsquo;, &amp;lsquo;%&amp;rsquo;, &amp;lsquo;divmod&amp;rsquo;, &amp;lsquo;**&amp;rsquo;, and &amp;lsquo;()&amp;rsquo; as well as the attributes and methods listed in the &lt;code&gt;ABCPolyBase&lt;/code&gt; documentation.</source>
          <target state="translated">Класс Polynomial предоставляет стандартные числовые методы Python '+', '-', '*', '//', '%', 'divmod', '**' и '()', а также атрибуты и методы, перечисленные в документации &lt;code&gt;ABCPolyBase&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ababcd2092c790cd48094defea5bb6fa5036c0d6" translate="yes" xml:space="preserve">
          <source>The Project</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9cd0ae31276093703b68264061cf438be92cd228" translate="yes" xml:space="preserve">
          <source>The Project Community consists of all Contributors and Users of the Project. Contributors work on behalf of and are responsible to the larger Project Community and we strive to keep the barrier between Contributors and Users as low as possible.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d50f5379e9d76b5e7242532277a2b9c64fd49c0" translate="yes" xml:space="preserve">
          <source>The Project is developed by a team of distributed developers, called Contributors. Contributors are individuals who have contributed code, documentation, designs or other work to the Project. Anyone can be a Contributor. Contributors can be affiliated with any legal entity or none. Contributors participate in the project by submitting, reviewing and discussing GitHub Pull Requests and Issues and participating in open and public Project discussions on GitHub, mailing lists, and other channels. The foundation of Project participation is openness and transparency.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c1c2647aef99f143f4382e220b44eada277008ef" translate="yes" xml:space="preserve">
          <source>The Project is formally affiliated with the 501(c)3 NumFOCUS Foundation (&lt;a href=&quot;http://numfocus.org&quot;&gt;http://numfocus.org&lt;/a&gt;), which serves as its fiscal sponsor, may hold project trademarks and other intellectual property, helps manage project donations and acts as a parent legal entity. NumFOCUS is the only legal entity that has a formal relationship with the project (see Institutional Partners section below).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3f211023ee392fd3cd9d9691f710a52d06a9bae2" translate="yes" xml:space="preserve">
          <source>The Project will have a Steering Council that consists of Project Contributors who have produced contributions that are substantial in quality and quantity, and sustained over at least one year. The overall role of the Council is to ensure, with input from the Community, the long-term well-being of the project, both technically and as a community.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="827ba55564ba45b324c36aacf3e17c27674e9dcd" translate="yes" xml:space="preserve">
          <source>The PyArrayInterface structure had no descr member at the end (and therefore no flag ARR_HAS_DESCR)</source>
          <target state="translated">Структура PyArrayInterface не имела члена descr в конце (и,следовательно,флага ARR_HAS_DESCR).</target>
        </trans-unit>
        <trans-unit id="41d158f9c0cb59631db3742cfa40b5047248d25c" translate="yes" xml:space="preserve">
          <source>The PyArrayInterface structure is defined in &lt;code&gt;numpy/ndarrayobject.h&lt;/code&gt; as:</source>
          <target state="translated">Структура PyArrayInterface определяется в &lt;code&gt;numpy/ndarrayobject.h&lt;/code&gt; как:</target>
        </trans-unit>
        <trans-unit id="e6049ecf431eb4a7049f3f47b3c4c1bf1fc4e575" translate="yes" xml:space="preserve">
          <source>The Python &lt;a href=&quot;https://docs.python.org/dev/glossary.html#term-slice&quot;&gt;slice&lt;/a&gt; operator. In ndarrays, slicing can be applied to every axis:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f9e4e5af356a67d9cce5fec6bebfc002a3fe5b0" translate="yes" xml:space="preserve">
          <source>The Python exposure supplies two iteration interfaces, one which follows the Python iterator protocol, and another which mirrors the C-style do-while pattern. The native Python approach is better in most cases, but if you need the coordinates or index of an iterator, use the C-style pattern.</source>
          <target state="translated">Python экспозиция обеспечивает два итерационных интерфейса,один из которых следует протоколу итератора Python,и другой,который зеркально отображает картину в стиле C,тем временем.Нативный подход к Python в большинстве случаев лучше,но если вам нужны координаты или индекс итератора,используйте шаблон в стиле C.</target>
        </trans-unit>
        <trans-unit id="52c071d4e6dd56561ca8fc870ab3c5e829454e91" translate="yes" xml:space="preserve">
          <source>The Python function &lt;code&gt;max()&lt;/code&gt; will find the maximum over a one-dimensional array, but it will do so using a slower sequence interface. The reduce method of the maximum ufunc is much faster. Also, the &lt;code&gt;max()&lt;/code&gt; method will not give answers you might expect for arrays with greater than one dimension. The reduce method of minimum also allows you to compute a total minimum over an array.</source>
          <target state="translated">Функция Python &lt;code&gt;max()&lt;/code&gt; найдет максимум для одномерного массива, но сделает это с помощью более медленного интерфейса последовательности. Метод сокращения максимального ufunc намного быстрее. Кроме того, метод &lt;code&gt;max()&lt;/code&gt; не даст ответов, которые вы могли бы ожидать для массивов с более чем одним измерением. Метод уменьшения минимума также позволяет вам вычислять общий минимум по массиву.</target>
        </trans-unit>
        <trans-unit id="faf8bfa039d6b92e8c05db35a7f948162088fe3f" translate="yes" xml:space="preserve">
          <source>The Python interactive interpreter unfortunately prints out the values of expressions inside the while loop during each iteration of the loop. We have modified the output in the examples using this looping construct in order to be more readable.</source>
          <target state="translated">Интерактивный интерпретатор Python,к сожалению,распечатывает значения выражений внутри цикла while во время каждой итерации цикла.Мы изменили вывод в примерах,используя эту конструкцию петли,чтобы быть более читабельным.</target>
        </trans-unit>
        <trans-unit id="4b9b366242a59401489f5a3a46b627dbab76f505" translate="yes" xml:space="preserve">
          <source>The Python interface that we want is:</source>
          <target state="translated">Интерфейс Python,который нам нужен:</target>
        </trans-unit>
        <trans-unit id="a4e789fdc99a292c8a541209ecbc17b1d6c5f8c7" translate="yes" xml:space="preserve">
          <source>The Python iterator protocol doesn&amp;rsquo;t have a natural way to query these additional values from the iterator, so we introduce an alternate syntax for iterating with an &lt;a href=&quot;generated/numpy.nditer#numpy.nditer&quot;&gt;&lt;code&gt;nditer&lt;/code&gt;&lt;/a&gt;. This syntax explicitly works with the iterator object itself, so its properties are readily accessible during iteration. With this looping construct, the current value is accessible by indexing into the iterator, and the index being tracked is the property &lt;code&gt;index&lt;/code&gt; or &lt;code&gt;multi_index&lt;/code&gt; depending on what was requested.</source>
          <target state="translated">Протокол итератора Python не имеет естественного способа запрашивать эти дополнительные значения у итератора, поэтому мы вводим альтернативный синтаксис для итерации с помощью &lt;a href=&quot;generated/numpy.nditer#numpy.nditer&quot;&gt; &lt;code&gt;nditer&lt;/code&gt; &lt;/a&gt; . Этот синтаксис явно работает с самим объектом итератора, поэтому его свойства легко доступны во время итерации. С этой циклической конструкцией текущее значение доступно путем индексации в итераторе, а отслеживаемый индекс - это &lt;code&gt;index&lt;/code&gt; свойства или &lt;code&gt;multi_index&lt;/code&gt; в зависимости от того, что было запрошено.</target>
        </trans-unit>
        <trans-unit id="6867d7144d35416337495ca1b602061770d80f10" translate="yes" xml:space="preserve">
          <source>The Python list representation of the masked array.</source>
          <target state="translated">Представление списка Python массива по маске.</target>
        </trans-unit>
        <trans-unit id="10730a9ceb03252e7c33bf729de07821aa7c70e5" translate="yes" xml:space="preserve">
          <source>The Python object this chunk of memory comes from. Needed so that memory can be accounted for properly.</source>
          <target state="translated">Объект Python,откуда взялся этот кусок памяти.Нужно для того,чтобы память могла быть учтена правильно.</target>
        </trans-unit>
        <trans-unit id="0d4a1c83a85c3f9ef90edda93dbe3641642446d4" translate="yes" xml:space="preserve">
          <source>The Python stdlib module &amp;ldquo;random&amp;rdquo; also contains a Mersenne Twister pseudo-random number generator with a number of methods that are similar to the ones available in &lt;a href=&quot;#numpy.random.RandomState&quot;&gt;&lt;code&gt;RandomState&lt;/code&gt;&lt;/a&gt;. &lt;a href=&quot;#numpy.random.RandomState&quot;&gt;&lt;code&gt;RandomState&lt;/code&gt;&lt;/a&gt;, besides being NumPy-aware, has the advantage that it provides a much larger number of probability distributions to choose from.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a0585dac865895f74c0e37d281119c6e2073a73" translate="yes" xml:space="preserve">
          <source>The Python stdlib module &amp;ldquo;random&amp;rdquo; also contains a Mersenne Twister pseudo-random number generator with a number of methods that are similar to the ones available in &lt;a href=&quot;#numpy.random.mtrand.RandomState&quot;&gt;&lt;code&gt;RandomState&lt;/code&gt;&lt;/a&gt;. &lt;a href=&quot;#numpy.random.mtrand.RandomState&quot;&gt;&lt;code&gt;RandomState&lt;/code&gt;&lt;/a&gt;, besides being NumPy-aware, has the advantage that it provides a much larger number of probability distributions to choose from.</source>
          <target state="translated">Модуль Python stdlib &amp;laquo;random&amp;raquo; также содержит генератор псевдослучайных чисел Mersenne Twister с рядом методов, аналогичных тем, которые доступны в &lt;a href=&quot;#numpy.random.mtrand.RandomState&quot;&gt; &lt;code&gt;RandomState&lt;/code&gt; &lt;/a&gt; . &lt;a href=&quot;#numpy.random.mtrand.RandomState&quot;&gt; &lt;code&gt;RandomState&lt;/code&gt; &lt;/a&gt; , помимо того, что он знает NumPy, имеет то преимущество, что он предоставляет гораздо большее количество распределений вероятностей на выбор.</target>
        </trans-unit>
        <trans-unit id="e2bba830daa553cb7faa782d38dcb55b1552bd1f" translate="yes" xml:space="preserve">
          <source>The Python stdlib module &amp;ldquo;random&amp;rdquo; also contains a Mersenne Twister pseudo-random number generator.</source>
          <target state="translated">Модуль Python stdlib &amp;laquo;random&amp;raquo; также содержит генератор псевдослучайных чисел Mersenne Twister.</target>
        </trans-unit>
        <trans-unit id="d16bb9351563ad26c9ac5328e3a25381d78f799b" translate="yes" xml:space="preserve">
          <source>The Python stdlib module &lt;a href=&quot;generated/numpy.random.generator.random#numpy.random.Generator.random&quot;&gt;&lt;code&gt;random&lt;/code&gt;&lt;/a&gt; contains pseudo-random number generator with a number of methods that are similar to the ones available in &lt;code&gt;Generator&lt;/code&gt;. It uses Mersenne Twister, and this bit generator can be accessed using &lt;code&gt;MT19937&lt;/code&gt;. &lt;code&gt;Generator&lt;/code&gt;, besides being NumPy-aware, has the advantage that it provides a much larger number of probability distributions to choose from.</source>
          <target state="translated">Модуль Python stdlib &lt;a href=&quot;generated/numpy.random.generator.random#numpy.random.Generator.random&quot;&gt; &lt;code&gt;random&lt;/code&gt; &lt;/a&gt; содержит генератор псевдослучайных чисел с рядом методов, аналогичных тем, которые доступны в &lt;code&gt;Generator&lt;/code&gt; . Он использует Mersenne Twister, и к этому генератору бит можно получить доступ с помощью &lt;code&gt;MT19937&lt;/code&gt; . &lt;code&gt;Generator&lt;/code&gt; , помимо того, что он поддерживает NumPy, имеет то преимущество, что он предоставляет гораздо большее количество распределений вероятностей на выбор.</target>
        </trans-unit>
        <trans-unit id="da363cfdc7ce6e2caf650d00ffad698f370feca3" translate="yes" xml:space="preserve">
          <source>The Python stdlib module &lt;a href=&quot;generated/numpy.random.random#numpy.random.random&quot;&gt;&lt;code&gt;random&lt;/code&gt;&lt;/a&gt; contains pseudo-random number generator with a number of methods that are similar to the ones available in &lt;code&gt;Generator&lt;/code&gt;. It uses Mersenne Twister, and this bit generator can be accessed using &lt;code&gt;MT19937&lt;/code&gt;. &lt;code&gt;Generator&lt;/code&gt;, besides being NumPy-aware, has the advantage that it provides a much larger number of probability distributions to choose from.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bbfe8c34ab4f057b17acc33f18a11bfdb2e17b46" translate="yes" xml:space="preserve">
          <source>The Python type of the ndarray is &lt;a href=&quot;#c.PyArray_Type&quot;&gt;&lt;code&gt;PyArray_Type&lt;/code&gt;&lt;/a&gt;. In C, every ndarray is a pointer to a &lt;a href=&quot;#c.PyArrayObject&quot;&gt;&lt;code&gt;PyArrayObject&lt;/code&gt;&lt;/a&gt; structure. The ob_type member of this structure contains a pointer to the &lt;a href=&quot;#c.PyArray_Type&quot;&gt;&lt;code&gt;PyArray_Type&lt;/code&gt;&lt;/a&gt; typeobject.</source>
          <target state="translated">Тип Python для ndarray - &lt;a href=&quot;#c.PyArray_Type&quot;&gt; &lt;code&gt;PyArray_Type&lt;/code&gt; &lt;/a&gt; . В C каждый ndarray является указателем на структуру &lt;a href=&quot;#c.PyArrayObject&quot;&gt; &lt;code&gt;PyArrayObject&lt;/code&gt; &lt;/a&gt; . Член ob_type этой структуры содержит указатель на &lt;a href=&quot;#c.PyArray_Type&quot;&gt; &lt;code&gt;PyArray_Type&lt;/code&gt; &lt;/a&gt; PyArray_Type.</target>
        </trans-unit>
        <trans-unit id="92e614f1f8b5e40429cf0717c65db8d5a132db4d" translate="yes" xml:space="preserve">
          <source>The Rayleigh distribution would arise, for example, if the East and North components of the wind velocity had identical zero-mean Gaussian distributions. Then the wind speed would have a Rayleigh distribution.</source>
          <target state="translated">Релевое распределение возникло бы,например,если бы восточная и северная компоненты скорости ветра имели одинаковые нулевые среднегауссовые распределения.Тогда бы скорость ветра имела релеевское распределение.</target>
        </trans-unit>
        <trans-unit id="d73f8fe753523f4db33185ee7a9f4cc2e7b4d46f" translate="yes" xml:space="preserve">
          <source>The SciPy Code of Conduct</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="43e766ac17c08bb4c8b9b072ff682fb439dd2765" translate="yes" xml:space="preserve">
          <source>The SciPy library also contains a &lt;a href=&quot;https://docs.scipy.org/doc/scipy/reference/linalg.html#module-scipy.linalg&quot;&gt;&lt;code&gt;linalg&lt;/code&gt;&lt;/a&gt; submodule, and there is overlap in the functionality provided by the SciPy and NumPy submodules. SciPy contains functions not found in &lt;a href=&quot;#module-numpy.linalg&quot;&gt;&lt;code&gt;numpy.linalg&lt;/code&gt;&lt;/a&gt;, such as functions related to LU decomposition and the Schur decomposition, multiple ways of calculating the pseudoinverse, and matrix transcendentals such as the matrix logarithm. Some functions that exist in both have augmented functionality in &lt;a href=&quot;https://docs.scipy.org/doc/scipy/reference/linalg.html#module-scipy.linalg&quot;&gt;&lt;code&gt;scipy.linalg&lt;/code&gt;&lt;/a&gt;. For example, &lt;a href=&quot;https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.eig.html#scipy.linalg.eig&quot;&gt;&lt;code&gt;scipy.linalg.eig&lt;/code&gt;&lt;/a&gt; can take a second matrix argument for solving generalized eigenvalue problems. Some functions in NumPy, however, have more flexible broadcasting options. For example, &lt;a href=&quot;generated/numpy.linalg.solve#numpy.linalg.solve&quot;&gt;&lt;code&gt;numpy.linalg.solve&lt;/code&gt;&lt;/a&gt; can handle &amp;ldquo;stacked&amp;rdquo; arrays, while &lt;a href=&quot;https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.solve.html#scipy.linalg.solve&quot;&gt;&lt;code&gt;scipy.linalg.solve&lt;/code&gt;&lt;/a&gt; accepts only a single square array as its first argument.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b5319e40dafd8caa389916efd26acade11e750d" translate="yes" xml:space="preserve">
          <source>The SciPy module &lt;a href=&quot;https://docs.scipy.org/doc/scipy/reference/fft.html#module-scipy.fft&quot;&gt;&lt;code&gt;scipy.fft&lt;/code&gt;&lt;/a&gt; is a more comprehensive superset of &lt;code&gt;numpy.fft&lt;/code&gt;, which includes only a basic set of routines.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0175f443d47358199cf2723ff7e49526482ab828" translate="yes" xml:space="preserve">
          <source>The Simple Wrapper and Interface Generator (or &lt;a href=&quot;http://www.swig.org&quot;&gt;SWIG&lt;/a&gt;) is a powerful tool for generating wrapper code for interfacing to a wide variety of scripting languages. &lt;a href=&quot;http://www.swig.org&quot;&gt;SWIG&lt;/a&gt; can parse header files, and using only the code prototypes, create an interface to the target language. But &lt;a href=&quot;http://www.swig.org&quot;&gt;SWIG&lt;/a&gt; is not omnipotent. For example, it cannot know from the prototype:</source>
          <target state="translated">Simple Wrapper and Interface Generator (или &lt;a href=&quot;http://www.swig.org&quot;&gt;SWIG&lt;/a&gt; ) - мощный инструмент для генерации кода оболочки для взаимодействия с широким спектром языков сценариев. &lt;a href=&quot;http://www.swig.org&quot;&gt;SWIG&lt;/a&gt; может анализировать файлы заголовков и, используя только прототипы кода, создавать интерфейс для целевого языка. Но &lt;a href=&quot;http://www.swig.org&quot;&gt;SWIG&lt;/a&gt; не всемогущ. Например, он не может узнать из прототипа:</target>
        </trans-unit>
        <trans-unit id="50fd73730ba7e10c720fa72fd00d9f7e0810994f" translate="yes" xml:space="preserve">
          <source>The Steering Council and its Members play a special role in certain situations. In particular, the Council may, if necessary:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd611f012e4b731c3416db83b8b9fa4821f6de96" translate="yes" xml:space="preserve">
          <source>The Steering Council are the primary leadership for the project. No outside institution, individual or legal entity has the ability to own, control, usurp or influence the project other than by participating in the Project as Contributors and Council Members. However, because institutions can be an important funding mechanism for the project, it is important to formally acknowledge institutional participation in the project. These are Institutional Partners.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3486112e5f71acaa9b7cc7fff52d1dbfa7f50dd3" translate="yes" xml:space="preserve">
          <source>The Vandermonde matrix. The shape of the returned matrix is &lt;code&gt;x.shape + (deg + 1,)&lt;/code&gt;, where the last index is the power of &lt;code&gt;x&lt;/code&gt;. The dtype will be the same as the converted &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">Матрица Вандермонда. Форма возвращаемой матрицы - &lt;code&gt;x.shape + (deg + 1,)&lt;/code&gt; , где последний индекс - это степень &lt;code&gt;x&lt;/code&gt; . Dtype будет таким же, как преобразованный &lt;code&gt;x&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="39a7c567f58b9f21ca516451a55bb90e053dd395" translate="yes" xml:space="preserve">
          <source>The Weibull (or Type III asymptotic extreme value distribution for smallest values, SEV Type III, or Rosin-Rammler distribution) is one of a class of Generalized Extreme Value (GEV) distributions used in modeling extreme value problems. This class includes the Gumbel and Frechet distributions.</source>
          <target state="translated">Распределение экстремальных значений Weibull (или асимптотическое распределение экстремальных значений типа III для наименьших значений,SEV Type III,или распределение Rosin-Rammler)является одним из классов обобщенных распределений экстремальных значений (GEV),используемых при моделировании задач с экстремальными значениями.Этот класс включает в себя распределения Гумбеля и Фреше.</target>
        </trans-unit>
        <trans-unit id="201b34b560ffa9f638b13b95cb2b860322d162bb" translate="yes" xml:space="preserve">
          <source>The Zipf distribution (also known as the zeta distribution) is a continuous probability distribution that satisfies Zipf&amp;rsquo;s law: the frequency of an item is inversely proportional to its rank in a frequency table.</source>
          <target state="translated">Распределение Ципфа (также известное как дзета-распределение) - это непрерывное распределение вероятностей, которое удовлетворяет закону Ципфа: частота элемента обратно пропорциональна его рангу в таблице частот.</target>
        </trans-unit>
        <trans-unit id="9f96ae0b2c3d21dc0c18c679782e710a2d562c21" translate="yes" xml:space="preserve">
          <source>The __array_finalize__ method</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b8acfe985a2bfa5e5957d0281e0418889b56a0c2" translate="yes" xml:space="preserve">
          <source>The __array_priority__ attribute</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c8638dacd7dbc859e55b29c8e0ee5d2ee1f9573" translate="yes" xml:space="preserve">
          <source>The __array_wrap__ method</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb048510e93bd94f0172757e215cb9cb29cef573" translate="yes" xml:space="preserve">
          <source>The ability to be used as a context manager is new in NumPy v1.11.0.</source>
          <target state="translated">Возможность использования в качестве контекстного менеджера появилась в NumPy v1.11.0.</target>
        </trans-unit>
        <trans-unit id="10ff963859461b5262a67238fd0cc7b697172b26" translate="yes" xml:space="preserve">
          <source>The above does not hold for in-place operators, for which &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt; never returns &lt;a href=&quot;https://docs.python.org/dev/library/constants.html#NotImplemented&quot;&gt;&lt;code&gt;NotImplemented&lt;/code&gt;&lt;/a&gt;. Hence, &lt;code&gt;arr += obj&lt;/code&gt; would always lead to a &lt;a href=&quot;https://docs.python.org/dev/library/exceptions.html#TypeError&quot;&gt;&lt;code&gt;TypeError&lt;/code&gt;&lt;/a&gt;. This is because for arrays in-place operations cannot generically be replaced by a simple reverse operation. (For instance, by default, &lt;code&gt;arr += obj&lt;/code&gt; would be translated to &lt;code&gt;arr =
arr + obj&lt;/code&gt;, i.e., &lt;code&gt;arr&lt;/code&gt; would be replaced, contrary to what is expected for in-place array operations.)</source>
          <target state="translated">Вышеупомянутое не относится к операторам на месте, для которых &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt; никогда не возвращает &lt;a href=&quot;https://docs.python.org/dev/library/constants.html#NotImplemented&quot;&gt; &lt;code&gt;NotImplemented&lt;/code&gt; &lt;/a&gt; . Следовательно, &lt;code&gt;arr += obj&lt;/code&gt; всегда будет приводить к &lt;a href=&quot;https://docs.python.org/dev/library/exceptions.html#TypeError&quot;&gt; &lt;code&gt;TypeError&lt;/code&gt; &lt;/a&gt; . Это связано с тем, что операции с массивами на месте в общем случае не могут быть заменены простой обратной операцией. (Например, по умолчанию &lt;code&gt;arr += obj&lt;/code&gt; будет преобразовано в &lt;code&gt;arr = arr + obj&lt;/code&gt; , то есть &lt;code&gt;arr&lt;/code&gt; будет заменено, в отличие от того, что ожидается для операций с массивами на месте.)</target>
        </trans-unit>
        <trans-unit id="68e86910bcee8988f5fee730ecb24162fd22e6a7" translate="yes" xml:space="preserve">
          <source>The above equation is not symmetric in &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt;, so that &lt;code&gt;allclose(a, b)&lt;/code&gt; might be different from &lt;code&gt;allclose(b, a)&lt;/code&gt; in some rare cases.</source>
          <target state="translated">Приведенное выше уравнение не является симметричным по &lt;code&gt;a&lt;/code&gt; и &lt;code&gt;b&lt;/code&gt; , поэтому &lt;code&gt;allclose(a, b)&lt;/code&gt; может отличаться от &lt;code&gt;allclose(b, a)&lt;/code&gt; в некоторых редких случаях.</target>
        </trans-unit>
        <trans-unit id="6185045f653324c861d3553f34d55db24911888b" translate="yes" xml:space="preserve">
          <source>The above is &lt;strong&gt;not&lt;/strong&gt; true for advanced indexing.</source>
          <target state="translated">Выше &lt;strong&gt;не&lt;/strong&gt; относится к расширенному индексации.</target>
        </trans-unit>
        <trans-unit id="21db79b1f2f5936ea0ef3cfbbfc9697c308c56be" translate="yes" xml:space="preserve">
          <source>The above rules may be clearer in the following template source example:</source>
          <target state="translated">Вышеприведенные правила могут быть более понятными в следующем примере источника шаблона:</target>
        </trans-unit>
        <trans-unit id="bbd30ffed27aefb02b7cc5cbecba164ede0884a8" translate="yes" xml:space="preserve">
          <source>The absolute tolerance parameter (see Notes).</source>
          <target state="translated">Абсолютный параметр допуска (см.Примечания).</target>
        </trans-unit>
        <trans-unit id="b410151dc56a82d87375b78c87d1aad1438a967a" translate="yes" xml:space="preserve">
          <source>The absolute values of &lt;code&gt;x&lt;/code&gt;, the returned values are always floats. This is a scalar if &lt;code&gt;x&lt;/code&gt; is a scalar.</source>
          <target state="translated">Абсолютные значения &lt;code&gt;x&lt;/code&gt; , возвращаемые значения всегда являются плавающими. Это скаляр, если &lt;code&gt;x&lt;/code&gt; - скаляр.</target>
        </trans-unit>
        <trans-unit id="a714cd42c4750db7daf108e375247bf95502ae46" translate="yes" xml:space="preserve">
          <source>The accumulate function is very similar to the reduce function in that the output and the second input both point to the output. The difference is that the second input points to memory one stride behind the current output pointer. Thus, the operation performed is</source>
          <target state="translated">Функция накопления очень похожа на функцию уменьшения в том,что выход и второй вход оба указывают на выход.Разница состоит в том,что второй вход указывает на память на один шаг позади текущего указателя выхода.Таким образом,выполняется операция</target>
        </trans-unit>
        <trans-unit id="09fde86411dc88385ee0c9001b20e47aa778341c" translate="yes" xml:space="preserve">
          <source>The accumulated values. If &lt;code&gt;out&lt;/code&gt; was supplied, &lt;code&gt;r&lt;/code&gt; is a reference to &lt;code&gt;out&lt;/code&gt;.</source>
          <target state="translated">Накопленные значения. Если был предоставлен &lt;code&gt;out&lt;/code&gt; , &lt;code&gt;r&lt;/code&gt; является ссылкой на &lt;code&gt;out&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ea47ba00873e187022bea737541efbc8a18ba099" translate="yes" xml:space="preserve">
          <source>The actual object to check.</source>
          <target state="translated">Фактический объект для проверки.</target>
        </trans-unit>
        <trans-unit id="2c2156efeae8cdcc13e079cd68ed8ee62442ae55" translate="yes" xml:space="preserve">
          <source>The actual testing takes place with a Python script named:</source>
          <target state="translated">Фактическое тестирование происходит с именем скрипта Python:</target>
        </trans-unit>
        <trans-unit id="b137bb987f3be59004e7fe6c03cebc2b50e503bc" translate="yes" xml:space="preserve">
          <source>The addition of an &lt;code&gt;axis&lt;/code&gt; keyword argument to methods such as &lt;a href=&quot;generated/numpy.random.generator.choice#numpy.random.Generator.choice&quot;&gt;&lt;code&gt;Generator.choice&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;generated/numpy.random.generator.permutation#numpy.random.Generator.permutation&quot;&gt;&lt;code&gt;Generator.permutation&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;generated/numpy.random.generator.shuffle#numpy.random.Generator.shuffle&quot;&gt;&lt;code&gt;Generator.shuffle&lt;/code&gt;&lt;/a&gt; improves support for sampling from and shuffling multi-dimensional arrays.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e611ef52ce3f87e2cae1cb595f38cf187d2711d5" translate="yes" xml:space="preserve">
          <source>The advanced indexes are all next to each other. For example &lt;code&gt;x[..., arr1, arr2, :]&lt;/code&gt; but &lt;em&gt;not&lt;/em&gt;&lt;code&gt;x[arr1, :, 1]&lt;/code&gt; since &lt;code&gt;1&lt;/code&gt; is an advanced index in this regard.</source>
          <target state="translated">Все расширенные индексы расположены рядом друг с другом. Например, &lt;code&gt;x[..., arr1, arr2, :]&lt;/code&gt; но &lt;em&gt;не &lt;/em&gt; &lt;code&gt;x[arr1, :, 1]&lt;/code&gt; поскольку &lt;code&gt;1&lt;/code&gt; является расширенным индексом в этом отношении.</target>
        </trans-unit>
        <trans-unit id="8562f49387be48296682139d8c90e489ffc329b9" translate="yes" xml:space="preserve">
          <source>The advanced indexes are separated by a slice, &lt;a href=&quot;https://docs.python.org/dev/library/constants.html#Ellipsis&quot;&gt;&lt;code&gt;Ellipsis&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;constants#numpy.newaxis&quot;&gt;&lt;code&gt;newaxis&lt;/code&gt;&lt;/a&gt;. For example &lt;code&gt;x[arr1, :, arr2]&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="31c1e1991e0db334efbc077fcf4425ba78851bf7" translate="yes" xml:space="preserve">
          <source>The advanced indexes are separated by a slice, &lt;code&gt;Ellipsis&lt;/code&gt; or &lt;a href=&quot;constants#numpy.newaxis&quot;&gt;&lt;code&gt;newaxis&lt;/code&gt;&lt;/a&gt;. For example &lt;code&gt;x[arr1, :, arr2]&lt;/code&gt;.</source>
          <target state="translated">Расширенные индексы разделяются срезом, &lt;code&gt;Ellipsis&lt;/code&gt; или &lt;a href=&quot;constants#numpy.newaxis&quot;&gt; &lt;code&gt;newaxis&lt;/code&gt; &lt;/a&gt; . Например, &lt;code&gt;x[arr1, :, arr2]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a0943937a225e08eb4e31b510a59e3603b58c132" translate="yes" xml:space="preserve">
          <source>The advantage of the hand-generated wrapper is that you have complete control over how the C-library gets used and called which can lead to a lean and tight interface with minimal over-head. The disadvantage is that you have to write, debug, and maintain C-code, although most of it can be adapted using the time-honored technique of &amp;ldquo;cutting-pasting-and-modifying&amp;rdquo; from other extension modules. Because, the procedure of calling out to additional C-code is fairly regimented, code-generation procedures have been developed to make this process easier. One of these code-generation techniques is distributed with NumPy and allows easy integration with Fortran and (simple) C code. This package, f2py, will be covered briefly in the next section.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d764668c927e5f32ce22801332fbd537f1d04076" translate="yes" xml:space="preserve">
          <source>The advantage of this creation function is that one can guarantee the number of elements and the starting and end point, which arange() generally will not do for arbitrary start, stop, and step values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0930947f097a3d759f1db1653e4d8d773b593cd3" translate="yes" xml:space="preserve">
          <source>The advantage of this version of reduce compared to the normal ufunc.reduce is that it makes use of the &lt;a href=&quot;#broadcasting-rules&quot;&gt;broadcasting rules&lt;/a&gt; in order to avoid creating an argument array the size of the output times the number of vectors.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="51620b35cf3af304da0134bf0e98ad6e2d38905c" translate="yes" xml:space="preserve">
          <source>The advantage of this version of reduce compared to the normal ufunc.reduce is that it makes use of the &lt;a href=&quot;tentative_numpy_tutorial#head-c43f3f81719d84f09ae2b33a22eaf50b26333db8&quot;&gt;Broadcasting Rules&lt;/a&gt; in order to avoid creating an argument array the size of the output times the number of vectors.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cbeaf56d095a4acc2c96fd5080608f5dcf659b8a" translate="yes" xml:space="preserve">
          <source>The advantages over random generation include tools to replay and share failures without requiring a fixed seed, reporting &lt;em&gt;minimal&lt;/em&gt; examples for each failure, and better-than-naive-random techniques for triggering bugs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e14666a8704d081387416d669f25517240f5f545" translate="yes" xml:space="preserve">
          <source>The aim of this document is to describe how to add new tools to SciPy.</source>
          <target state="translated">Цель этого документа-описать,как добавлять новые инструменты в SciPy.</target>
        </trans-unit>
        <trans-unit id="ddbe83e4c507cabc5c6e4f89a6b5af846c612df5" translate="yes" xml:space="preserve">
          <source>The algorithm is carefully designed to eliminate a number of possible ways to collide. For example, if one only does one level of spawning, it is guaranteed that all states will be unique. But it&amp;rsquo;s easier to estimate the naive upper bound on a napkin and take comfort knowing that the probability is actually lower.</source>
          <target state="translated">Алгоритм тщательно разработан, чтобы исключить ряд возможных способов столкновения. Например, если выполняется только один уровень нереста, гарантируется, что все состояния будут уникальными. Но проще оценить наивную верхнюю границу на салфетке и успокоиться, зная, что вероятность на самом деле ниже.</target>
        </trans-unit>
        <trans-unit id="31b40688fb93dbcbc32e9b43e4ccf1abfa448a2d" translate="yes" xml:space="preserve">
          <source>The algorithm relies on computing the eigenvalues of the companion matrix &lt;a href=&quot;#r01a8f58ef25b-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt;.</source>
          <target state="translated">Алгоритм основан на вычислении собственных значений сопутствующей матрицы &lt;a href=&quot;#r01a8f58ef25b-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ddd22305ce6ff69cc69c0e35a34dfdaaddbe6b6d" translate="yes" xml:space="preserve">
          <source>The algorithm works by first finding a &amp;ldquo;running dimension&amp;rdquo;, along which the blocks will be extracted. Given an array of dimensions &lt;code&gt;(d1, d2, ..., dn)&lt;/code&gt;, e.g. if &lt;code&gt;buf_size&lt;/code&gt; is smaller than &lt;code&gt;d1&lt;/code&gt;, the first dimension will be used. If, on the other hand, &lt;code&gt;d1 &amp;lt; buf_size &amp;lt; d1*d2&lt;/code&gt; the second dimension will be used, and so on. Blocks are extracted along this dimension, and when the last block is returned the process continues from the next dimension, until all elements have been read.</source>
          <target state="translated">Алгоритм работает, сначала находя &amp;laquo;бегущее измерение&amp;raquo;, по которому будут извлекаться блоки. Учитывая массив измерений &lt;code&gt;(d1, d2, ..., dn)&lt;/code&gt; , например, если &lt;code&gt;buf_size&lt;/code&gt; меньше &lt;code&gt;d1&lt;/code&gt; , будет использоваться первое измерение. Если, с другой стороны, &lt;code&gt;d1 &amp;lt; buf_size &amp;lt; d1*d2&lt;/code&gt; будет использоваться второе измерение и так далее. Блоки извлекаются по этому измерению, и когда возвращается последний блок, процесс продолжается со следующего измерения, пока не будут прочитаны все элементы.</target>
        </trans-unit>
        <trans-unit id="bddd09a9de7b4e7a6ce50c8c2ab936314f5f7ae0" translate="yes" xml:space="preserve">
          <source>The angle of the ray intersecting the unit circle at the given &lt;code&gt;x&lt;/code&gt;-coordinate in radians [0, pi]. This is a scalar if &lt;code&gt;x&lt;/code&gt; is a scalar.</source>
          <target state="translated">Угол луча, пересекающего единичный круг в данной координате &lt;code&gt;x&lt;/code&gt; , в радианах [0, pi]. Это скаляр, если &lt;code&gt;x&lt;/code&gt; - скаляр.</target>
        </trans-unit>
        <trans-unit id="a13da23a8343744c8c54019aa364c899333968f0" translate="yes" xml:space="preserve">
          <source>The anti-diagonal can be filled by reversing the order of elements using either &lt;a href=&quot;numpy.flipud#numpy.flipud&quot;&gt;&lt;code&gt;numpy.flipud&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;numpy.fliplr#numpy.fliplr&quot;&gt;&lt;code&gt;numpy.fliplr&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;numpy.flipud#numpy.flipud&quot;&gt; &lt;code&gt;numpy.flipud&lt;/code&gt; &lt;/a&gt; можно заполнить, изменив порядок элементов, используя numpy.flipud или &lt;a href=&quot;numpy.fliplr#numpy.fliplr&quot;&gt; &lt;code&gt;numpy.fliplr&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="900a13fc7d937db8f345df515885761fbb0acd80" translate="yes" xml:space="preserve">
          <source>The anti-diagonal can be obtained by reversing the order of elements using either &lt;a href=&quot;numpy.flipud#numpy.flipud&quot;&gt;&lt;code&gt;numpy.flipud&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;numpy.fliplr#numpy.fliplr&quot;&gt;&lt;code&gt;numpy.fliplr&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;numpy.flipud#numpy.flipud&quot;&gt; &lt;code&gt;numpy.flipud&lt;/code&gt; &lt;/a&gt; можно получить, изменив порядок элементов с помощью numpy.flipud или &lt;a href=&quot;numpy.fliplr#numpy.fliplr&quot;&gt; &lt;code&gt;numpy.fliplr&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="bdd6673496c6fd17d43bfb63694d67b1a23e7074" translate="yes" xml:space="preserve">
          <source>The approximate decimal resolution of this type, i.e., &lt;code&gt;10**-precision&lt;/code&gt;.</source>
          <target state="translated">Примерное десятичное разрешение этого типа, т. &lt;code&gt;10**-precision&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a6b2d49779da2fb225e5136c9ad3c68e119d3fee" translate="yes" xml:space="preserve">
          <source>The approximate number of decimal digits to which this kind of float is precise.</source>
          <target state="translated">Ориентировочное количество десятичных цифр,к которым точно относится этот вид поплавка.</target>
        </trans-unit>
        <trans-unit id="8617d617458fa70c05d4242aac245212778759db" translate="yes" xml:space="preserve">
          <source>The argument &lt;code&gt;norm&lt;/code&gt; indicates which direction of the pair of direct/inverse transforms is scaled and with what normalization factor. The default normalization (&lt;code&gt;&quot;backward&quot;&lt;/code&gt;) has the direct (forward) transforms unscaled and the inverse (backward) transforms scaled by</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="179dbf39b5fae7c06c4d27f6dfe6017b20eda9b8" translate="yes" xml:space="preserve">
          <source>The argument is considered as a return variable. It is appended to the &lt;code&gt;&amp;lt;returned variables&amp;gt;&lt;/code&gt; list. Using &lt;code&gt;intent(out)&lt;/code&gt; sets &lt;code&gt;intent(hide)&lt;/code&gt; automatically, unless also &lt;code&gt;intent(in)&lt;/code&gt; or &lt;code&gt;intent(inout)&lt;/code&gt; were used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c118204e070c804541b682daff7d70c7213a6696" translate="yes" xml:space="preserve">
          <source>The argument is considered as an input-only argument. It means that the value of the argument is passed to Fortran/C function and that function is expected not to change the value of an argument.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7586639cfc35e105e2ea737d69664cf533fb71d1" translate="yes" xml:space="preserve">
          <source>The argument is considered as an input/output or &lt;em&gt;in situ&lt;/em&gt; output argument. &lt;code&gt;intent(inout)&lt;/code&gt; arguments can be only &amp;ldquo;contiguous&amp;rdquo; NumPy arrays with proper type and size. Here &amp;ldquo;contiguous&amp;rdquo; can be either in Fortran or C sense. The latter one coincides with the contiguous concept used in NumPy and is effective only if &lt;code&gt;intent(c)&lt;/code&gt; is used. Fortran contiguity is assumed by default.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="958b7637686a26352441daf916242ddf2818e972" translate="yes" xml:space="preserve">
          <source>The argument is considered as an input/output or &lt;em&gt;in situ&lt;/em&gt; output argument. &lt;code&gt;intent(inplace)&lt;/code&gt; arguments must be NumPy arrays with proper size. If the type of an array is not &amp;ldquo;proper&amp;rdquo; or the array is non-contiguous then the array will be changed in-place to fix the type and make it contiguous.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f19b8026a1e189b122954edffa090fdbeb3a72f0" translate="yes" xml:space="preserve">
          <source>The argument is removed from the list of required or optional arguments. Typically &lt;code&gt;intent(hide)&lt;/code&gt; is used with &lt;code&gt;intent(out)&lt;/code&gt; or when &lt;code&gt;&amp;lt;init_expr&amp;gt;&lt;/code&gt; completely determines the value of the argument like in the following example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="898b40f4d53206c78d6c1d07150f357243064d8d" translate="yes" xml:space="preserve">
          <source>The argument is treated as a C scalar or C array argument. In the case of a scalar argument, its value is passed to C function as a C scalar argument (recall that Fortran scalar arguments are actually C pointer arguments). In the case of an array argument, the wrapper function is assumed to treat multidimensional arrays as C-contiguous arrays.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f859808cd7ae59bcb9315c9be074383ed18866fa" translate="yes" xml:space="preserve">
          <source>The argument is treated as a junk of memory. No Fortran nor C contiguity checks are carried out. Using &lt;code&gt;intent(cache)&lt;/code&gt; makes sense only for array arguments, also in connection with &lt;code&gt;intent(hide)&lt;/code&gt; or &lt;code&gt;optional&lt;/code&gt; attributes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0fe8c5bbb5b2bd70ddad0ccf0217bddc268f6835" translate="yes" xml:space="preserve">
          <source>The arguments &lt;code&gt;ngood&lt;/code&gt; and &lt;code&gt;nbad&lt;/code&gt; each must be less than &lt;code&gt;10**9&lt;/code&gt;. For extremely large arguments, the algorithm that is used to compute the samples &lt;a href=&quot;#r688e4aa3bfc3-4&quot; id=&quot;id1&quot;&gt;[4]&lt;/a&gt; breaks down because of loss of precision in floating point calculations. For such large values, if &lt;code&gt;nsample&lt;/code&gt; is not also large, the distribution can be approximated with the binomial distribution, &lt;code&gt;binomial(n=nsample, p=ngood/(ngood + nbad))&lt;/code&gt;.</source>
          <target state="translated">Аргументы &lt;code&gt;ngood&lt;/code&gt; и &lt;code&gt;nbad&lt;/code&gt; каждый должен быть меньше , чем &lt;code&gt;10**9&lt;/code&gt; . Для чрезвычайно больших аргументов алгоритм, используемый для вычисления выборок &lt;a href=&quot;#r688e4aa3bfc3-4&quot; id=&quot;id1&quot;&gt;[4],&lt;/a&gt; не работает из-за потери точности вычислений с плавающей запятой. Для таких больших значений, если &lt;code&gt;nsample&lt;/code&gt; также не велик, распределение может быть аппроксимировано биномиальным распределением, &lt;code&gt;binomial(n=nsample, p=ngood/(ngood + nbad))&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2d355dbffda7b60d25c8fd14c77261de1c537b59" translate="yes" xml:space="preserve">
          <source>The arguments of the &lt;code&gt;configuration&lt;/code&gt; function specify the name of parent SciPy package (&lt;code&gt;parent_package&lt;/code&gt;) and the directory location of the main &lt;code&gt;setup.py&lt;/code&gt; script (&lt;code&gt;top_path&lt;/code&gt;). These arguments, along with the name of the current package, should be passed to the &lt;code&gt;Configuration&lt;/code&gt; constructor.</source>
          <target state="translated">Аргументы функции &lt;code&gt;configuration&lt;/code&gt; указывают имя родительского пакета SciPy ( &lt;code&gt;parent_package&lt;/code&gt; ) и расположение каталога основного скрипта &lt;code&gt;setup.py&lt;/code&gt; ( &lt;code&gt;top_path&lt;/code&gt; ). Эти аргументы вместе с именем текущего пакета следует передать конструктору &lt;code&gt;Configuration&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5e50719893eed3edf2e32e25c59bbd130545cd4a" translate="yes" xml:space="preserve">
          <source>The arguments that &lt;code&gt;__array_finalize__&lt;/code&gt; receives differ for the three methods of instance creation above.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b1212b40ba5f9b8205d7b64e2e9c20d35b415b3" translate="yes" xml:space="preserve">
          <source>The arithmetic mean is the sum of the elements along the axis divided by the number of elements.</source>
          <target state="translated">Среднее арифметическое-это сумма элементов вдоль оси,деленная на количество элементов.</target>
        </trans-unit>
        <trans-unit id="149dc5ada110e245afebc011f82badc7bfaf2c21" translate="yes" xml:space="preserve">
          <source>The arithmetic mean is the sum of the non-NaN elements along the axis divided by the number of non-NaN elements.</source>
          <target state="translated">Среднее арифметическое-это сумма не NaN-элементов вдоль оси,деленная на количество не NaN-элементов.</target>
        </trans-unit>
        <trans-unit id="893ac85ca56066bc9e23a82ef1519d73c4482726" translate="yes" xml:space="preserve">
          <source>The array &lt;code&gt;v&lt;/code&gt; of eigenvectors may not be of maximum rank, that is, some of the columns may be linearly dependent, although round-off error may obscure that fact. If the eigenvalues are all different, then theoretically the eigenvectors are linearly independent and &lt;code&gt;a&lt;/code&gt; can be diagonalized by a similarity transformation using &lt;code&gt;v&lt;/code&gt;, i.e, &lt;code&gt;inv(v) @ a @ v&lt;/code&gt; is diagonal.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a686d6fd794f1b48b235aeae1a3e22a10c775aa4" translate="yes" xml:space="preserve">
          <source>The array &lt;code&gt;v&lt;/code&gt; of eigenvectors may not be of maximum rank, that is, some of the columns may be linearly dependent, although round-off error may obscure that fact. If the eigenvalues are all different, then theoretically the eigenvectors are linearly independent. Likewise, the (complex-valued) matrix of eigenvectors &lt;code&gt;v&lt;/code&gt; is unitary if the matrix &lt;code&gt;a&lt;/code&gt; is normal, i.e., if &lt;code&gt;dot(a, a.H) = dot(a.H, a)&lt;/code&gt;, where &lt;code&gt;a.H&lt;/code&gt; denotes the conjugate transpose of &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">Массив &lt;code&gt;v&lt;/code&gt; собственных векторов может не иметь максимального ранга, то есть некоторые столбцы могут быть линейно зависимыми, хотя ошибка округления может скрыть этот факт. Если собственные значения все разные, то теоретически собственные векторы линейно независимы. Аналогично, (комплексная) матрица собственных векторов &lt;code&gt;v&lt;/code&gt; является унитарной, если матрица &lt;code&gt;a&lt;/code&gt; нормальна, т.е. если &lt;code&gt;dot(a, a.H) = dot(a.H, a)&lt;/code&gt; , где &lt;code&gt;a.H&lt;/code&gt; обозначает сопряженное транспонирование &lt;code&gt;a&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="539630988d5b7ef9eff53456e4a77b468fdbbd35" translate="yes" xml:space="preserve">
          <source>The array &lt;code&gt;x&lt;/code&gt; is prefilled with its filling value.</source>
          <target state="translated">Массив &lt;code&gt;x&lt;/code&gt; предварительно заполняется значением заполнения.</target>
        </trans-unit>
        <trans-unit id="048ae46227673b90cff5c0388062d4ed48f2b030" translate="yes" xml:space="preserve">
          <source>The array assembled from the given blocks.</source>
          <target state="translated">Массив,собранный из данных блоков.</target>
        </trans-unit>
        <trans-unit id="f6532b7ade94739e158787e37c1d9655afff859b" translate="yes" xml:space="preserve">
          <source>The array can be indexed using Python container-like syntax:</source>
          <target state="translated">Массив может быть проиндексирован с использованием контейнероподобного синтаксиса Python:</target>
        </trans-unit>
        <trans-unit id="a7b308d78b11f2c07c75c1db0756393dc3ae53a1" translate="yes" xml:space="preserve">
          <source>The array data-type or scalar for which the default fill value is returned.</source>
          <target state="translated">Тип данных массива или скаляр,для которого возвращается значение заполнения по умолчанию.</target>
        </trans-unit>
        <trans-unit id="3821c84ea0df179e936beb82ec9c4a845023032b" translate="yes" xml:space="preserve">
          <source>The array element of the current iteration.</source>
          <target state="translated">Элемент массива текущей итерации.</target>
        </trans-unit>
        <trans-unit id="930ed301b34bfc297be655fe9a537d3e2971d137" translate="yes" xml:space="preserve">
          <source>The array flags cannot be set arbitrarily:</source>
          <target state="translated">Флаги массива не могут быть установлены произвольно:</target>
        </trans-unit>
        <trans-unit id="67bdbd5d8bcbe5caab95cc4d4f8dabba43280775" translate="yes" xml:space="preserve">
          <source>The array for which the string representation of the pickle is returned.</source>
          <target state="translated">Массив,для которого возвращается строковое представление пикули.</target>
        </trans-unit>
        <trans-unit id="2a33c6111cdd8f36d42a5e94437f624d1b58746f" translate="yes" xml:space="preserve">
          <source>The array for which to count non-zeros.</source>
          <target state="translated">Массив,для которого нужно считать ненулевые.</target>
        </trans-unit>
        <trans-unit id="ceccbd318dae2746e4f8b98dac923588a6a52441" translate="yes" xml:space="preserve">
          <source>The array formed by stacking the given arrays, will be at least 2-D.</source>
          <target state="translated">Массив,формируемый путем суммирования данных массивов,будет не менее 2-D.</target>
        </trans-unit>
        <trans-unit id="2568bf2e437e715b60f945dc9695881ce8ef667f" translate="yes" xml:space="preserve">
          <source>The array formed by stacking the given arrays, will be at least 3-D.</source>
          <target state="translated">Массив,формируемый путем суммирования данных массивов,будет не менее 3-D.</target>
        </trans-unit>
        <trans-unit id="b2c061ec289a87d3c0d4e9e7c64e5126014d42ed" translate="yes" xml:space="preserve">
          <source>The array formed by stacking the given arrays.</source>
          <target state="translated">Массив,сформированный путем суммирования данных массивов.</target>
        </trans-unit>
        <trans-unit id="8e505b1ebbfcf9d9aa6a8f699f88f4ba40304f40" translate="yes" xml:space="preserve">
          <source>The array from which values are copied.</source>
          <target state="translated">Массив,из которого копируются значения.</target>
        </trans-unit>
        <trans-unit id="2d987760deb151bcafba733adc9b3a186c4d7f93" translate="yes" xml:space="preserve">
          <source>The array function protocol which allows array-like objects to hook into the NumPy API is currently enabled by default. This option exists since NumPy 1.16 and is enabled by default since NumPy 1.17. It can be disabled using:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c8fb39bbbe950fa5ba32f6dec4764ff1752adf1" translate="yes" xml:space="preserve">
          <source>The array h contains the Householder reflectors that generate q along with r. The tau array contains scaling factors for the reflectors. In the deprecated &amp;lsquo;economic&amp;rsquo; mode only h is returned.</source>
          <target state="translated">Массив h содержит отражатели Хаусхолдера, которые генерируют q вместе с r. Тау-массив содержит масштабные коэффициенты для отражателей. В устаревшем &amp;laquo;экономичном&amp;raquo; режиме возвращается только h.</target>
        </trans-unit>
        <trans-unit id="d2932d4203636051c0cde3cab914ac5caf308f90" translate="yes" xml:space="preserve">
          <source>The array interface (sometimes called array protocol) was created in 2005 as a means for array-like Python objects to re-use each other&amp;rsquo;s data buffers intelligently whenever possible. The homogeneous N-dimensional array interface is a default mechanism for objects to share N-dimensional array memory and information. The interface consists of a Python-side and a C-side using two attributes. Objects wishing to be considered an N-dimensional array in application code should support at least one of these attributes. Objects wishing to support an N-dimensional array in application code should look for at least one of these attributes and use the information provided appropriately.</source>
          <target state="translated">Интерфейс массива (иногда называемый протоколом массива) был создан в 2005 году для того, чтобы объекты Python, подобные массивам, могли разумно повторно использовать буферы данных друг друга, когда это возможно. Интерфейс однородного N-мерного массива - это механизм по умолчанию, позволяющий объектам совместно использовать память и информацию о N-мерном массиве. Интерфейс состоит из стороны Python и стороны C, использующих два атрибута. Объекты, которые должны рассматриваться в коде приложения как N-мерный массив, должны поддерживать хотя бы один из этих атрибутов. Объекты, желающие поддерживать N-мерный массив в коде приложения, должны искать хотя бы один из этих атрибутов и использовать предоставленную информацию соответствующим образом.</target>
        </trans-unit>
        <trans-unit id="3b7adbdac3eaf5c6305f1f61b91018f4287bec67" translate="yes" xml:space="preserve">
          <source>The array into which values are copied.</source>
          <target state="translated">Массив,в который копируются значения.</target>
        </trans-unit>
        <trans-unit id="8a281d694c98742955f6444ee26a08d74603ea7a" translate="yes" xml:space="preserve">
          <source>The array is filled with a fill value before the string conversion.</source>
          <target state="translated">Перед преобразованием строки массив заполняется значением fill.</target>
        </trans-unit>
        <trans-unit id="fba8708c42061e69f757d72f0e5d1d004653f4bc" translate="yes" xml:space="preserve">
          <source>The array is rotated in the plane defined by the axes. Axes must be different.</source>
          <target state="translated">Массив поворачивается в плоскости,определенной осями.Оси должны быть разными.</target>
        </trans-unit>
        <trans-unit id="9a1223a8243cbae9aaa7753c7ea500a550cf52c0" translate="yes" xml:space="preserve">
          <source>The array iterator encapsulates many of the key features in ufuncs, allowing user code to support features like output parameters, preservation of memory layouts, and buffering of data with the wrong alignment or type, without requiring difficult coding.</source>
          <target state="translated">Итератор массивов инкапсулирует многие ключевые функции в ufuncs,позволяя коду пользователя поддерживать такие функции,как выходные параметры,сохранение макетов памяти и буферизацию данных с неправильным выравниванием или типом,не требуя сложного кодирования.</target>
        </trans-unit>
        <trans-unit id="c6e1241b8c7d132ea91621f870c2bd3aaf572b4c" translate="yes" xml:space="preserve">
          <source>The array may be recreated via &lt;code&gt;a = np.array(a.tolist())&lt;/code&gt;, although this may sometimes lose precision.</source>
          <target state="translated">Массив можно воссоздать с помощью &lt;code&gt;a = np.array(a.tolist())&lt;/code&gt; , хотя иногда это может привести к потере точности.</target>
        </trans-unit>
        <trans-unit id="1eee9d9d69514705c81523ac5b902691363a28a0" translate="yes" xml:space="preserve">
          <source>The array of UTC timestamps to format.</source>
          <target state="translated">Массив UTC временных меток для форматирования.</target>
        </trans-unit>
        <trans-unit id="c75d57d539a00e02934380f0ab251d1c277b5e1c" translate="yes" xml:space="preserve">
          <source>The array of dates to process.</source>
          <target state="translated">Массив дат для обработки.</target>
        </trans-unit>
        <trans-unit id="cc2f192e213603a4bcf402844b3339c10f79380e" translate="yes" xml:space="preserve">
          <source>The array of numbers for which the absolute values are required. If &lt;code&gt;x&lt;/code&gt; is a scalar, the result &lt;code&gt;y&lt;/code&gt; will also be a scalar.</source>
          <target state="translated">Массив чисел, для которого требуются абсолютные значения. Если &lt;code&gt;x&lt;/code&gt; - скаляр, результат &lt;code&gt;y&lt;/code&gt; также будет скаляром.</target>
        </trans-unit>
        <trans-unit id="f9c4960d6bbbc8f2591cc039cfe68db4d8e24d90" translate="yes" xml:space="preserve">
          <source>The array of offsets, which is broadcast with &lt;code&gt;dates&lt;/code&gt;.</source>
          <target state="translated">Массив смещений, который транслируется с &lt;code&gt;dates&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2d674fe1383c12f697c52fd3b5198eb57b81bcb7" translate="yes" xml:space="preserve">
          <source>The array of rounded numbers</source>
          <target state="translated">Массив округленных чисел</target>
        </trans-unit>
        <trans-unit id="202adb7679573040b63e561db69df0e93b9eb75e" translate="yes" xml:space="preserve">
          <source>The array of the end dates for counting, which are excluded from the count themselves.</source>
          <target state="translated">Массив конечных дат для подсчета,которые исключаются из самого подсчета.</target>
        </trans-unit>
        <trans-unit id="f508cbbca81c78d6c3819b4c01ca29622bef56f6" translate="yes" xml:space="preserve">
          <source>The array of the first dates for counting.</source>
          <target state="translated">Массив первых дат для подсчета.</target>
        </trans-unit>
        <trans-unit id="a4e03a6eeebaef72c6a7e32f280b123bbf142ff2" translate="yes" xml:space="preserve">
          <source>The array or list to be shuffled.</source>
          <target state="translated">Массив или список,который нужно перетасовать.</target>
        </trans-unit>
        <trans-unit id="1f6abc9406bedaa275a3843a6290b585462b97a3" translate="yes" xml:space="preserve">
          <source>The array or matrix to be repeated.</source>
          <target state="translated">Массив или матрица,которую нужно повторить.</target>
        </trans-unit>
        <trans-unit id="53aead7fb32cb3de7311369b48d13d4953d0adc5" translate="yes" xml:space="preserve">
          <source>The array owns the memory it uses or borrows it from another object.</source>
          <target state="translated">Массив владеет памятью,которую он использует или заимствует у другого объекта.</target>
        </trans-unit>
        <trans-unit id="8df4e8232db4a79568062cac77624a670d547db6" translate="yes" xml:space="preserve">
          <source>The array scalar objects have an &lt;a href=&quot;arrays.classes#numpy.class.__array_priority__&quot;&gt;&lt;code&gt;array priority&lt;/code&gt;&lt;/a&gt; of &lt;a href=&quot;c-api/array#c.NPY_SCALAR_PRIORITY&quot;&gt;&lt;code&gt;NPY_SCALAR_PRIORITY&lt;/code&gt;&lt;/a&gt; (-1,000,000.0). They also do not (yet) have a &lt;a href=&quot;generated/numpy.ndarray.ctypes#numpy.ndarray.ctypes&quot;&gt;&lt;code&gt;ctypes&lt;/code&gt;&lt;/a&gt; attribute. Otherwise, they share the same attributes as arrays:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8abf01fdd64396d234195c26c60e850e4a12a8d7" translate="yes" xml:space="preserve">
          <source>The array scalar objects have an &lt;code&gt;array priority&lt;/code&gt; of &lt;a href=&quot;c-api.array#c.NPY_SCALAR_PRIORITY&quot;&gt;&lt;code&gt;NPY_SCALAR_PRIORITY&lt;/code&gt;&lt;/a&gt; (-1,000,000.0). They also do not (yet) have a &lt;a href=&quot;generated/numpy.ndarray.ctypes#numpy.ndarray.ctypes&quot;&gt;&lt;code&gt;ctypes&lt;/code&gt;&lt;/a&gt; attribute. Otherwise, they share the same attributes as arrays:</source>
          <target state="translated">Объекты массива скалярные имеют &lt;code&gt;array priority&lt;/code&gt; из &lt;a href=&quot;c-api.array#c.NPY_SCALAR_PRIORITY&quot;&gt; &lt;code&gt;NPY_SCALAR_PRIORITY&lt;/code&gt; &lt;/a&gt; (-1,000,000.0). У них также (пока) нет атрибута &lt;a href=&quot;generated/numpy.ndarray.ctypes#numpy.ndarray.ctypes&quot;&gt; &lt;code&gt;ctypes&lt;/code&gt; &lt;/a&gt; . В противном случае они имеют те же атрибуты, что и массивы:</target>
        </trans-unit>
        <trans-unit id="5774b39bb119ab7d3a197a6eee5e164f12892112" translate="yes" xml:space="preserve">
          <source>The array scalar objects have an &lt;code&gt;array priority&lt;/code&gt; of &lt;a href=&quot;c-api/array#c.NPY_SCALAR_PRIORITY&quot;&gt;&lt;code&gt;NPY_SCALAR_PRIORITY&lt;/code&gt;&lt;/a&gt; (-1,000,000.0). They also do not (yet) have a &lt;a href=&quot;generated/numpy.ndarray.ctypes#numpy.ndarray.ctypes&quot;&gt;&lt;code&gt;ctypes&lt;/code&gt;&lt;/a&gt; attribute. Otherwise, they share the same attributes as arrays:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c0162c81e2783b3bcbb0dd799de5c3ba91aba6a" translate="yes" xml:space="preserve">
          <source>The array scalars also offer the same methods and attributes as arrays with the intent that the same code can be used to support arbitrary dimensions (including 0-dimensions). The array scalars are read-only (immutable) with the exception of the void scalar which can also be written to so that structured array field setting works more naturally (a[0][&amp;lsquo;f1&amp;rsquo;] = &lt;code&gt;value&lt;/code&gt; ).</source>
          <target state="translated">Скаляры массива также предлагают те же методы и атрибуты, что и массивы, с намерением, что один и тот же код может использоваться для поддержки произвольных размеров (включая 0-размерности). Скаляры массива только для чтения (неизменный), за исключением пустот скаляра , которые также могут быть записаны так , что структурированные поля настройка массива работает более естественно (а [0] [ &amp;laquo;f1&amp;raquo;] = &lt;code&gt;value&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="d0afa5fdfdf427a8322c75c5712091eca91eabac" translate="yes" xml:space="preserve">
          <source>The array scalars offer a hierarchy of Python types that allow a one- to-one correspondence between the data-type stored in an array and the Python-type that is returned when an element is extracted from the array. An exception to this rule was made with object arrays. Object arrays are heterogeneous collections of arbitrary Python objects. When you select an item from an object array, you get back the original Python object (and not an object array scalar which does exist but is rarely used for practical purposes).</source>
          <target state="translated">Скаляры массивов предлагают иерархию типов Python,которая позволяет однозначное соответствие между типом данных,хранящимся в массиве,и типом Python,который возвращается,когда элемент извлекается из массива.Исключение из этого правила было сделано для объектных массивов.Массивы объектов представляют собой разнородные наборы произвольных объектов питоновского типа.При выделении элемента из объектного массива возвращается исходный объект Python (а не скаляр объектного массива,который существует,но редко используется для практических целей).</target>
        </trans-unit>
        <trans-unit id="4e947f26c0ecf6d9ff639e9f27b5b5f852135d7e" translate="yes" xml:space="preserve">
          <source>The array to act on.</source>
          <target state="translated">Массив для действий.</target>
        </trans-unit>
        <trans-unit id="7000ca786d20479930ea43aa17e050c42578abc2" translate="yes" xml:space="preserve">
          <source>The array to be pickled.</source>
          <target state="translated">Массив,который будет маринован.</target>
        </trans-unit>
        <trans-unit id="25694c63a056a35911c5654e87ce1708648d0cd3" translate="yes" xml:space="preserve">
          <source>The array to broadcast.</source>
          <target state="translated">Массив для трансляции.</target>
        </trans-unit>
        <trans-unit id="61fa35e69f8b8bb03ffef7462ad7cef9c9cdddeb" translate="yes" xml:space="preserve">
          <source>The array to mask. If not a MaskedArray instance (or if no array elements are masked). The result is a MaskedArray with &lt;code&gt;mask&lt;/code&gt; set to &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.nomask&quot;&gt;&lt;code&gt;nomask&lt;/code&gt;&lt;/a&gt; (False). Must be a 2D array.</source>
          <target state="translated">Маскируемый массив. Если это не экземпляр MaskedArray (или если элементы массива не замаскированы). Результатом является MaskedArray с &lt;code&gt;mask&lt;/code&gt; установленной на &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.nomask&quot;&gt; &lt;code&gt;nomask&lt;/code&gt; &lt;/a&gt; (False). Должен быть 2D-массив.</target>
        </trans-unit>
        <trans-unit id="9a0afda668850edc1a593d4069db9a58418e2d74" translate="yes" xml:space="preserve">
          <source>The array to operate on. If not a MaskedArray instance (or if no array elements are masked), &lt;code&gt;x&lt;/code&gt; is interpreted as a MaskedArray with &lt;code&gt;mask&lt;/code&gt; set to &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.nomask&quot;&gt;&lt;code&gt;nomask&lt;/code&gt;&lt;/a&gt;. Must be a 2D array.</source>
          <target state="translated">Массив для работы. Если это не экземпляр MaskedArray (или если элементы массива не замаскированы), &lt;code&gt;x&lt;/code&gt; интерпретируется как MaskedArray с &lt;code&gt;mask&lt;/code&gt; установленной в &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.nomask&quot;&gt; &lt;code&gt;nomask&lt;/code&gt; &lt;/a&gt; . Должен быть 2D-массив.</target>
        </trans-unit>
        <trans-unit id="da7df7a6420823a6b7e45bca218ba68631febc25" translate="yes" xml:space="preserve">
          <source>The array to pad.</source>
          <target state="translated">Массив на панель.</target>
        </trans-unit>
        <trans-unit id="8966af5b1934b124717f0c80ec9988807e784cf9" translate="yes" xml:space="preserve">
          <source>The array to perform in place operation on.</source>
          <target state="translated">Массив для выполнения операций на месте.</target>
        </trans-unit>
        <trans-unit id="1a2586a66b67a305c2797e7e06685302608f4ea4" translate="yes" xml:space="preserve">
          <source>The array whose axes should be reordered.</source>
          <target state="translated">Массив,оси которого должны быть переупорядочены.</target>
        </trans-unit>
        <trans-unit id="81f5ca8ebafc1afb8a9d51589c5e138b4b807e19" translate="yes" xml:space="preserve">
          <source>The array(s) to be iterated over. Valid only before the iterator is closed.</source>
          <target state="translated">Массив(ы),подлежащий итерации.Проверяется только перед закрытием итератора.</target>
        </trans-unit>
        <trans-unit id="8c52ea12181e4277b350926a7c51f79608004cd5" translate="yes" xml:space="preserve">
          <source>The array(s) to iterate over.</source>
          <target state="translated">Массив(ы)для выполнения итераций.</target>
        </trans-unit>
        <trans-unit id="44ee88d0d0ad997d1f49ea29b7557e01d238c30a" translate="yes" xml:space="preserve">
          <source>The array, list or mutable sequence to be shuffled.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae34a0f5008cfcf7a204a6ae1b41350a0a8ffea9" translate="yes" xml:space="preserve">
          <source>The array-protocol typestring of this data-type object.</source>
          <target state="translated">Массив-протокол типизирует этот объект типа данных.</target>
        </trans-unit>
        <trans-unit id="342be16484b97c95949f88958c455899735a9596" translate="yes" xml:space="preserve">
          <source>The arrays all have exactly the same shape.</source>
          <target state="translated">Все массивы имеют одинаковую форму.</target>
        </trans-unit>
        <trans-unit id="d48d7d91bb3512b8a648b512669295a09d607ddf" translate="yes" xml:space="preserve">
          <source>The arrays all have the same number of dimensions and the length of each dimensions is either a common length or 1.</source>
          <target state="translated">Все массивы имеют одинаковое количество размеров,и длина каждого из них либо общая длина,либо 1.</target>
        </trans-unit>
        <trans-unit id="3b32b95e95ce590daa0a88406a7282f0b6f9ae1f" translate="yes" xml:space="preserve">
          <source>The arrays holding the elements to be compared. If &lt;code&gt;x1.shape != x2.shape&lt;/code&gt;, they must be broadcastable to a common shape (which becomes the shape of the output).</source>
          <target state="translated">Массивы, содержащие сравниваемые элементы. Если &lt;code&gt;x1.shape != x2.shape&lt;/code&gt; , они должны транслироваться в общую форму (которая становится формой вывода).</target>
        </trans-unit>
        <trans-unit id="b72974524c2659f265dc742386bd383e243bc4a6" translate="yes" xml:space="preserve">
          <source>The arrays must have the same shape along all but the first axis. 1-D arrays must have the same length.</source>
          <target state="translated">Массивы должны иметь одинаковую форму вдоль всех,кроме первой оси.1-D массивы должны иметь одинаковую длину.</target>
        </trans-unit>
        <trans-unit id="9548b85aa3e636c88bbbc65cfcdf4e6b5fff4585" translate="yes" xml:space="preserve">
          <source>The arrays must have the same shape along all but the second axis, except 1-D arrays which can be any length.</source>
          <target state="translated">Массивы должны иметь одинаковую форму вдоль всей,кроме второй,оси,за исключением 1-D массивов,которые могут иметь любую длину.</target>
        </trans-unit>
        <trans-unit id="34736140b85990281116cda8321b303d602cfb2e" translate="yes" xml:space="preserve">
          <source>The arrays must have the same shape along all but the third axis. 1-D or 2-D arrays must have the same shape.</source>
          <target state="translated">Массивы должны иметь одинаковую форму вдоль всех,кроме третьей оси.1-D или 2-D массивы должны иметь одинаковую форму.</target>
        </trans-unit>
        <trans-unit id="250d7318b7910004f5ade9c6bf7fa2a62b2d0aa6" translate="yes" xml:space="preserve">
          <source>The arrays must have the same shape, except in the dimension corresponding to &lt;code&gt;axis&lt;/code&gt; (the first, by default).</source>
          <target state="translated">Массивы должны иметь одинаковую форму, за исключением измерения, соответствующего &lt;code&gt;axis&lt;/code&gt; (первого по умолчанию).</target>
        </trans-unit>
        <trans-unit id="3650412314ab8d0d6cc595877979b22653a06cac" translate="yes" xml:space="preserve">
          <source>The arrays that have too few dimensions can have their shapes prepended with a dimension of length 1 to satisfy property 2.</source>
          <target state="translated">Массивы,которые имеют слишком малое количество размеров,могут иметь свои формы с размером длины 1,чтобы удовлетворить свойство 2.</target>
        </trans-unit>
        <trans-unit id="3c7fb6624c1c578e967064538473cd4324bc56b1" translate="yes" xml:space="preserve">
          <source>The arrays to be added. If &lt;code&gt;x1.shape != x2.shape&lt;/code&gt;, they must be broadcastable to a common shape (which becomes the shape of the output).</source>
          <target state="translated">Добавляемые массивы. Если &lt;code&gt;x1.shape != x2.shape&lt;/code&gt; , они должны транслироваться в общую форму (которая становится формой вывода).</target>
        </trans-unit>
        <trans-unit id="61831d63f8eb03ec54ea81f37b4edf92245e6861" translate="yes" xml:space="preserve">
          <source>The arrays to be subtracted from each other. If &lt;code&gt;x1.shape != x2.shape&lt;/code&gt;, they must be broadcastable to a common shape (which becomes the shape of the output).</source>
          <target state="translated">Массивы, которые нужно вычесть друг из друга. Если &lt;code&gt;x1.shape != x2.shape&lt;/code&gt; , они должны транслироваться в общую форму (которая становится формой вывода).</target>
        </trans-unit>
        <trans-unit id="b989bf28be4c34813d52a00110756329cfab3199" translate="yes" xml:space="preserve">
          <source>The arrays to broadcast.</source>
          <target state="translated">Массивы для трансляции.</target>
        </trans-unit>
        <trans-unit id="4bc127992ac15b346e5ebc50b22b2084cc253474" translate="yes" xml:space="preserve">
          <source>The available functions are defined in &amp;lt;numpy/npy_math.h&amp;gt; - please refer to this header when in doubt.</source>
          <target state="translated">Доступные функции определены в &amp;lt;numpy / npy_math.h&amp;gt; - пожалуйста, обратитесь к этому заголовку в случае сомнений.</target>
        </trans-unit>
        <trans-unit id="686cb4c9f84e6a825a4dffab12a90e362cecd993" translate="yes" xml:space="preserve">
          <source>The average along the specified axis. When returned is &lt;code&gt;True&lt;/code&gt;, return a tuple with the average as the first element and the sum of the weights as the second element. The return type is &lt;code&gt;np.float64&lt;/code&gt; if &lt;code&gt;a&lt;/code&gt; is of integer type and floats smaller than &lt;a href=&quot;../arrays.scalars#numpy.float64&quot;&gt;&lt;code&gt;float64&lt;/code&gt;&lt;/a&gt;, or the input data-type, otherwise. If returned, &lt;code&gt;sum_of_weights&lt;/code&gt; is always &lt;a href=&quot;../arrays.scalars#numpy.float64&quot;&gt;&lt;code&gt;float64&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c1200844d5256d1bf5c45cf0a767eb7723d9e5e" translate="yes" xml:space="preserve">
          <source>The average along the specified axis. When returned is &lt;code&gt;True&lt;/code&gt;, return a tuple with the average as the first element and the sum of the weights as the second element. The return type is &lt;code&gt;np.float64&lt;/code&gt; if &lt;code&gt;a&lt;/code&gt; is of integer type and floats smaller than &lt;code&gt;float64&lt;/code&gt;, or the input data-type, otherwise. If returned, &lt;code&gt;sum_of_weights&lt;/code&gt; is always &lt;code&gt;float64&lt;/code&gt;.</source>
          <target state="translated">Среднее значение по указанной оси. Если возвращено значение &lt;code&gt;True&lt;/code&gt; , вернуть кортеж со средним значением в качестве первого элемента и суммой весов в качестве второго элемента. Тип возврата - &lt;code&gt;np.float64&lt;/code&gt; , если &lt;code&gt;a&lt;/code&gt; имеет целочисленный тип и число с плавающей запятой меньше &lt;code&gt;float64&lt;/code&gt; , или тип входных данных, в противном случае. Если возвращается, &lt;code&gt;sum_of_weights&lt;/code&gt; всегда имеет значение &lt;code&gt;float64&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="542875b084a7c351a7a1f8a6d2d600675ca4d2a7" translate="yes" xml:space="preserve">
          <source>The average squared deviation is normally calculated as &lt;code&gt;x.sum() / N&lt;/code&gt;, where &lt;code&gt;N = len(x)&lt;/code&gt;. If, however, &lt;code&gt;ddof&lt;/code&gt; is specified, the divisor &lt;code&gt;N - ddof&lt;/code&gt; is used instead. In standard statistical practice, &lt;code&gt;ddof=1&lt;/code&gt; provides an unbiased estimator of the variance of the infinite population. &lt;code&gt;ddof=0&lt;/code&gt; provides a maximum likelihood estimate of the variance for normally distributed variables. The standard deviation computed in this function is the square root of the estimated variance, so even with &lt;code&gt;ddof=1&lt;/code&gt;, it will not be an unbiased estimate of the standard deviation per se.</source>
          <target state="translated">Среднее квадратическое отклонение обычно рассчитывается как &lt;code&gt;x.sum() / N&lt;/code&gt; , где &lt;code&gt;N = len(x)&lt;/code&gt; . Однако, &lt;code&gt;ddof&lt;/code&gt; указано &lt;code&gt;N - ddof&lt;/code&gt; вместо него используется делитель N - ddof . В стандартной статистической практике &lt;code&gt;ddof=1&lt;/code&gt; обеспечивает несмещенную оценку дисперсии бесконечной совокупности. &lt;code&gt;ddof=0&lt;/code&gt; обеспечивает оценку максимального правдоподобия дисперсии для нормально распределенных переменных. Стандартное отклонение, вычисленное в этой функции, является квадратным корнем из оцененной дисперсии, поэтому даже при &lt;code&gt;ddof=1&lt;/code&gt; это не будет несмещенной оценкой стандартного отклонения как таковой.</target>
        </trans-unit>
        <trans-unit id="e5371b975bd9a5aa7f9f30c169b220e1eedba6bf" translate="yes" xml:space="preserve">
          <source>The average squared deviation is typically calculated as &lt;code&gt;x.sum() / N&lt;/code&gt;, where &lt;code&gt;N = len(x)&lt;/code&gt;. If, however, &lt;code&gt;ddof&lt;/code&gt; is specified, the divisor &lt;code&gt;N - ddof&lt;/code&gt; is used instead. In standard statistical practice, &lt;code&gt;ddof=1&lt;/code&gt; provides an unbiased estimator of the variance of the infinite population. &lt;code&gt;ddof=0&lt;/code&gt; provides a maximum likelihood estimate of the variance for normally distributed variables. The standard deviation computed in this function is the square root of the estimated variance, so even with &lt;code&gt;ddof=1&lt;/code&gt;, it will not be an unbiased estimate of the standard deviation per se.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="21ebdcee890d352b954472165e15ea262b078aa8" translate="yes" xml:space="preserve">
          <source>The axes over which to compute the inverse fft. Default is the last two axes.</source>
          <target state="translated">Оси,по которым рассчитывается обратный ффт.По умолчанию это последние две оси.</target>
        </trans-unit>
        <trans-unit id="3f6da36d69c95a72b5592c0677dd407fdc9cfa2c" translate="yes" xml:space="preserve">
          <source>The axis along which &lt;code&gt;v&lt;/code&gt; are appended. If &lt;code&gt;axis&lt;/code&gt; is not given, both &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; are flattened before use.</source>
          <target state="translated">Ось, по которой добавляются буквы &lt;code&gt;v&lt;/code&gt; . Если &lt;code&gt;axis&lt;/code&gt; не указана, перед использованием выравниваются и &lt;code&gt;a&lt;/code&gt; , и &lt;code&gt;b&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="071585631d8d75cc42162ae0da0a1b91474572d1" translate="yes" xml:space="preserve">
          <source>The axis along which &lt;code&gt;values&lt;/code&gt; are appended. If &lt;code&gt;axis&lt;/code&gt; is not given, both &lt;code&gt;arr&lt;/code&gt; and &lt;code&gt;values&lt;/code&gt; are flattened before use.</source>
          <target state="translated">Ось, по которой добавляются &lt;code&gt;values&lt;/code&gt; . Если &lt;code&gt;axis&lt;/code&gt; не указана, перед использованием выравниваются и &lt;code&gt;arr&lt;/code&gt; , и &lt;code&gt;values&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d25eb0541fd006d52dcbebc548c80309c583cc52" translate="yes" xml:space="preserve">
          <source>The axis along which the arrays will be joined. Default is 0.</source>
          <target state="translated">Ось,вдоль которой будут соединяться массивы.По умолчанию 0.</target>
        </trans-unit>
        <trans-unit id="ab324f8b42b072f0ce80303066858390de817e59" translate="yes" xml:space="preserve">
          <source>The axis along which the arrays will be joined. If axis is None, arrays are flattened before use. Default is 0.</source>
          <target state="translated">Ось,вдоль которой будут соединяться массивы.Если ось Нет,то перед использованием массивы уплотняются.По умолчанию 0.</target>
        </trans-unit>
        <trans-unit id="b85856e591095eebb92c2f542dccaa68776b00c8" translate="yes" xml:space="preserve">
          <source>The axis along which the difference is taken, default is the last axis.</source>
          <target state="translated">Ось,вдоль которой берется разница,по умолчанию является последней осью.</target>
        </trans-unit>
        <trans-unit id="848f8430ea7a17384babb0b6d388a2e2e8bda711" translate="yes" xml:space="preserve">
          <source>The axis along which the selection is performed. The default, 0, selects by row.</source>
          <target state="translated">Ось,вдоль которой производится выделение.По умолчанию 0,выбирается по строке.</target>
        </trans-unit>
        <trans-unit id="db9105950615faa8709d8dba888767b4f466811c" translate="yes" xml:space="preserve">
          <source>The axis along which to apply the accumulation; default is zero.</source>
          <target state="translated">Ось,по которой следует применять накопление;по умолчанию равна нулю.</target>
        </trans-unit>
        <trans-unit id="b45496da67ff059714d0b1ae6911029e831dd2fd" translate="yes" xml:space="preserve">
          <source>The axis along which to apply the reduceat.</source>
          <target state="translated">Ось,вдоль которой следует применять редуктор.</target>
        </trans-unit>
        <trans-unit id="ef9dbd3a8e7509325fd10ad7183022f46facda83" translate="yes" xml:space="preserve">
          <source>The axis along which to delete the subarray defined by &lt;code&gt;obj&lt;/code&gt;. If &lt;code&gt;axis&lt;/code&gt; is None, &lt;code&gt;obj&lt;/code&gt; is applied to the flattened array.</source>
          <target state="translated">Ось, по которой следует удалить подмассив, определенный &lt;code&gt;obj&lt;/code&gt; . Если &lt;code&gt;axis&lt;/code&gt; None, &lt;code&gt;obj&lt;/code&gt; применяется к сглаженному массиву.</target>
        </trans-unit>
        <trans-unit id="3c27f5e5d6b589ff51ec356603f9f33684d0e877" translate="yes" xml:space="preserve">
          <source>The axis along which to find the minima. Default is None, in which case the minimum value in the whole array is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5932d4cf836b6b58485bd9f15e2f20474363c36f" translate="yes" xml:space="preserve">
          <source>The axis along which to integrate.</source>
          <target state="translated">Ось,вдоль которой нужно интегрировать.</target>
        </trans-unit>
        <trans-unit id="0011917dec1b66b996673fed4476058c1c23ee6e" translate="yes" xml:space="preserve">
          <source>The axis along which to repeat values. By default, use the flattened input array, and return a flat output array.</source>
          <target state="translated">Ось,вдоль которой повторяются значения.По умолчанию используйте плоский входной массив и возвращайте плоский выходной массив.</target>
        </trans-unit>
        <trans-unit id="407371d3199afc3105f3e75619a63b4981063028" translate="yes" xml:space="preserve">
          <source>The axis along which to split, default is 0.</source>
          <target state="translated">По умолчанию ось,по которой происходит разделение,равна 0.</target>
        </trans-unit>
        <trans-unit id="6c8aa23aca8c1dff0d85e03c9e665e89973587d4" translate="yes" xml:space="preserve">
          <source>The axis can be specified explicitly:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="40f4cb16df8166b16f689cc3f6a27ceb034ca2a8" translate="yes" xml:space="preserve">
          <source>The axis currently being calculated.</source>
          <target state="translated">Ось,которая в настоящее время рассчитывается.</target>
        </trans-unit>
        <trans-unit id="779396c94c96c008627d39cce908fca96b699246" translate="yes" xml:space="preserve">
          <source>The axis in the result array along which the input arrays are stacked.</source>
          <target state="translated">Ось в результирующем массиве,по которой укладываются входные массивы.</target>
        </trans-unit>
        <trans-unit id="f53c3f1c70993fc128dae4ee501fb80cbace06f6" translate="yes" xml:space="preserve">
          <source>The axis in the result to store the samples. Relevant only if start or stop are array-like. By default (0), the samples will be along a new axis inserted at the beginning. Use -1 to get an axis at the end.</source>
          <target state="translated">Ось в результатах для хранения образцов.Актуальна только в том случае,если старт или стоп являются массивами.По умолчанию (0),примеры будут располагаться вдоль новой вставленной в начало оси.Для получения оси в конце используйте -1.</target>
        </trans-unit>
        <trans-unit id="5d9b30084a3b37c792a839c94c54a5cdb7a8cfce" translate="yes" xml:space="preserve">
          <source>The axis is rolled until it lies before this position. The default, 0, results in a &amp;ldquo;complete&amp;rdquo; roll.</source>
          <target state="translated">Ось катится, пока она не окажется перед этим положением. Значение по умолчанию 0 означает &amp;laquo;полный&amp;raquo; бросок.</target>
        </trans-unit>
        <trans-unit id="bb67daef266f9ea49c20107e1bf4911d74a22608" translate="yes" xml:space="preserve">
          <source>The axis over which to select values. By default, the flattened input array is used.</source>
          <target state="translated">Ось,по которой выбираются значения.По умолчанию используется плоский входной массив.</target>
        </trans-unit>
        <trans-unit id="6a2ce88413f2bc22b3ef2d3c9420680ad19eebe6" translate="yes" xml:space="preserve">
          <source>The axis to be rolled. The positions of the other axes do not change relative to one another.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d0edfc48d57e03c356c790b28b9213c10fc98a8b" translate="yes" xml:space="preserve">
          <source>The axis to operate on. If None, &lt;code&gt;ar&lt;/code&gt; will be flattened. If an integer, the subarrays indexed by the given axis will be flattened and treated as the elements of a 1-D array with the dimension of the given axis, see the notes for more details. Object arrays or structured arrays that contain objects are not supported if the &lt;code&gt;axis&lt;/code&gt; kwarg is used. The default is None.</source>
          <target state="translated">Ось для работы. Если нет, &lt;code&gt;ar&lt;/code&gt; будет сплющен. Если это целое число, подмассивы, проиндексированные данной осью, будут сглажены и обработаны как элементы одномерного массива с размером данной оси, см. Примечания для более подробной информации. Массивы объектов или структурированные массивы, содержащие объекты, не поддерживаются, если используется &lt;code&gt;axis&lt;/code&gt; kwarg. По умолчанию - Нет.</target>
        </trans-unit>
        <trans-unit id="b9493a9f29cafe569828c852de6864aa7f5d0ff6" translate="yes" xml:space="preserve">
          <source>The axis to roll backwards. The positions of the other axes do not change relative to one another.</source>
          <target state="translated">Ось для отката назад.Позиции других осей не меняются относительно друг друга.</target>
        </trans-unit>
        <trans-unit id="340d3fc196833339a77972eea60efcdfd52ba73c" translate="yes" xml:space="preserve">
          <source>The axis to take 1d slices along. If axis is None, the destination array is treated as if a flattened 1d view had been created of it.</source>
          <target state="translated">Ось,чтобы взять 1d срезов вдоль.Если ось None,то массив назначения обрабатывается так,как если бы из него был создан плоский 1d вид.</target>
        </trans-unit>
        <trans-unit id="a049beb1044c250e5951941014a3acba639cb49d" translate="yes" xml:space="preserve">
          <source>The axis to take 1d slices along. If axis is None, the input array is treated as if it had first been flattened to 1d, for consistency with &lt;a href=&quot;numpy.sort#numpy.sort&quot;&gt;&lt;code&gt;sort&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;numpy.argsort#numpy.argsort&quot;&gt;&lt;code&gt;argsort&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Ось, по которой нужно брать 1d срезы. Если ось None, входной массив обрабатывается так, как если бы он сначала был сведен к 1d, для согласованности с &lt;a href=&quot;numpy.sort#numpy.sort&quot;&gt; &lt;code&gt;sort&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;numpy.argsort#numpy.argsort&quot;&gt; &lt;code&gt;argsort&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a5f8cd862df0c3dc198b03cdec5c823ff5bfd3ca" translate="yes" xml:space="preserve">
          <source>The axis which &lt;code&gt;x&lt;/code&gt; is shuffled along. Default is 0.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b08fd6e477a7b8aeeb4332f420687b1d376d9496" translate="yes" xml:space="preserve">
          <source>The axis which &lt;code&gt;x&lt;/code&gt; is shuffled along. Default is 0. It is only supported on &lt;a href=&quot;../../generated/numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt; objects.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="24f5f1b01f9d6c3c18ebf1e91b8c1b0eb06217c1" translate="yes" xml:space="preserve">
          <source>The axis which &lt;code&gt;x&lt;/code&gt; is shuffled along. Default is 0. It is only supported on &lt;code&gt;ndarray&lt;/code&gt; objects.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8262154fa6203f128694759e7e2ae715f81f6fa1" translate="yes" xml:space="preserve">
          <source>The base BitGenerator.state must be overridden by a subclass</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="98787e1071b5327d0b2e07537c81bb27588db08e" translate="yes" xml:space="preserve">
          <source>The base case for this recursion is a 0D array:</source>
          <target state="translated">Базовым регистром для этой рекурсии является массив 0D:</target>
        </trans-unit>
        <trans-unit id="88d21dfd4e25736b7184078ba7f33b64bea753e0" translate="yes" xml:space="preserve">
          <source>The base of an array that owns its memory is None:</source>
          <target state="translated">Основой массива,которому принадлежит память,является None:</target>
        </trans-unit>
        <trans-unit id="074b16b582d8ec2099beaee8dcbc987839646a35" translate="yes" xml:space="preserve">
          <source>The base of the log space. The step size between the elements in &lt;code&gt;ln(samples) / ln(base)&lt;/code&gt; (or &lt;code&gt;log_base(samples)&lt;/code&gt;) is uniform. Default is 10.0.</source>
          <target state="translated">Основание бревенчатого пространства. Размер шага между элементами в &lt;code&gt;ln(samples) / ln(base)&lt;/code&gt; (или &lt;code&gt;log_base(samples)&lt;/code&gt; ) одинаков. По умолчанию 10.0.</target>
        </trans-unit>
        <trans-unit id="7276467b8228c2e569c11964caa906fd33040a07" translate="yes" xml:space="preserve">
          <source>The baseline</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="535897fba7f592c8b7dd04c68596d9a31edf2e11" translate="yes" xml:space="preserve">
          <source>The bases in &lt;code&gt;x1&lt;/code&gt; raised to the exponents in &lt;code&gt;x2&lt;/code&gt;. This is a scalar if both &lt;code&gt;x1&lt;/code&gt; and &lt;code&gt;x2&lt;/code&gt; are scalars.</source>
          <target state="translated">Основания в &lt;code&gt;x1&lt;/code&gt; возведены в степень в &lt;code&gt;x2&lt;/code&gt; . Это скаляр, если и &lt;code&gt;x1&lt;/code&gt; , и &lt;code&gt;x2&lt;/code&gt; являются скалярами.</target>
        </trans-unit>
        <trans-unit id="707f28b031c35e2bf30d29bbd42946a1e8c7dc8c" translate="yes" xml:space="preserve">
          <source>The bases.</source>
          <target state="translated">Базы.</target>
        </trans-unit>
        <trans-unit id="5bc92f7e413935d311df16000ae397f9e815d85b" translate="yes" xml:space="preserve">
          <source>The basic data element&amp;rsquo;s size in bytes</source>
          <target state="translated">Размер базового элемента данных в байтах</target>
        </trans-unit>
        <trans-unit id="68fe9eda4da762f1f4d04299c59c07412dcd5a69" translate="yes" xml:space="preserve">
          <source>The basic slice syntax is &lt;code&gt;i:j:k&lt;/code&gt; where &lt;em&gt;i&lt;/em&gt; is the starting index, &lt;em&gt;j&lt;/em&gt; is the stopping index, and &lt;em&gt;k&lt;/em&gt; is the step (</source>
          <target state="translated">Базовый синтаксис среза - &lt;code&gt;i:j:k&lt;/code&gt; , где &lt;em&gt;i&lt;/em&gt; - начальный индекс, &lt;em&gt;j&lt;/em&gt; - индекс остановки, а &lt;em&gt;k&lt;/em&gt; - шаг (</target>
        </trans-unit>
        <trans-unit id="aeeddb45e8f2002e147b881df220bd44abec802b" translate="yes" xml:space="preserve">
          <source>The basic type character codes are:</source>
          <target state="translated">Основные символьные коды типа:</target>
        </trans-unit>
        <trans-unit id="94f38793f86bdba698e5ca03402c847550f50738" translate="yes" xml:space="preserve">
          <source>The basis polynomials are scaled so that the companion matrix is symmetric when &lt;code&gt;c&lt;/code&gt; is a Chebyshev basis polynomial. This provides better eigenvalue estimates than the unscaled case and for basis polynomials the eigenvalues are guaranteed to be real if &lt;a href=&quot;numpy.linalg.eigvalsh#numpy.linalg.eigvalsh&quot;&gt;&lt;code&gt;numpy.linalg.eigvalsh&lt;/code&gt;&lt;/a&gt; is used to obtain them.</source>
          <target state="translated">Базисные полиномы масштабируются так, чтобы сопутствующая матрица была симметричной, когда &lt;code&gt;c&lt;/code&gt; является базисным полиномом Чебышева. Это обеспечивает лучшие оценки собственных значений, чем немасштабированный случай, и для базисных полиномов собственные значения гарантированно будут действительными, если для их получения используется &lt;a href=&quot;numpy.linalg.eigvalsh#numpy.linalg.eigvalsh&quot;&gt; &lt;code&gt;numpy.linalg.eigvalsh&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="fd443fcafad8cfc7235ab73b5edb8fa2361feb5f" translate="yes" xml:space="preserve">
          <source>The basis polynomials are scaled so that the companion matrix is symmetric when &lt;code&gt;c&lt;/code&gt; is an Hermite basis polynomial. This provides better eigenvalue estimates than the unscaled case and for basis polynomials the eigenvalues are guaranteed to be real if &lt;a href=&quot;numpy.linalg.eigvalsh#numpy.linalg.eigvalsh&quot;&gt;&lt;code&gt;numpy.linalg.eigvalsh&lt;/code&gt;&lt;/a&gt; is used to obtain them.</source>
          <target state="translated">Базисные полиномы масштабируются так, чтобы сопутствующая матрица была симметричной, когда &lt;code&gt;c&lt;/code&gt; является базисным полиномом Эрмита. Это обеспечивает лучшие оценки собственных значений, чем немасштабированный случай, и для базисных полиномов собственные значения гарантированно будут действительными, если для их получения используется &lt;a href=&quot;numpy.linalg.eigvalsh#numpy.linalg.eigvalsh&quot;&gt; &lt;code&gt;numpy.linalg.eigvalsh&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e1520a86bfcd397936d59363e21a13733e7a71b7" translate="yes" xml:space="preserve">
          <source>The basis polynomials are scaled so that the companion matrix is symmetric when &lt;code&gt;c&lt;/code&gt; is an HermiteE basis polynomial. This provides better eigenvalue estimates than the unscaled case and for basis polynomials the eigenvalues are guaranteed to be real if &lt;a href=&quot;numpy.linalg.eigvalsh#numpy.linalg.eigvalsh&quot;&gt;&lt;code&gt;numpy.linalg.eigvalsh&lt;/code&gt;&lt;/a&gt; is used to obtain them.</source>
          <target state="translated">Базисные полиномы масштабируются так, чтобы сопутствующая матрица была симметричной, когда &lt;code&gt;c&lt;/code&gt; является базисным полиномом Эрмита. Это обеспечивает лучшие оценки собственных значений, чем немасштабированный случай, и для базисных полиномов собственные значения гарантированно будут действительными, если для их получения используется &lt;a href=&quot;numpy.linalg.eigvalsh#numpy.linalg.eigvalsh&quot;&gt; &lt;code&gt;numpy.linalg.eigvalsh&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="31e8496a7482cd5cd28cb680bd285957a80df61e" translate="yes" xml:space="preserve">
          <source>The basis polynomials are scaled so that the companion matrix is symmetric when &lt;code&gt;c&lt;/code&gt; is an Legendre basis polynomial. This provides better eigenvalue estimates than the unscaled case and for basis polynomials the eigenvalues are guaranteed to be real if &lt;a href=&quot;numpy.linalg.eigvalsh#numpy.linalg.eigvalsh&quot;&gt;&lt;code&gt;numpy.linalg.eigvalsh&lt;/code&gt;&lt;/a&gt; is used to obtain them.</source>
          <target state="translated">Базисные полиномы масштабируются так, чтобы сопутствующая матрица была симметричной, когда &lt;code&gt;c&lt;/code&gt; является базисным полиномом Лежандра. Это обеспечивает лучшие оценки собственных значений, чем немасштабированный случай, и для базисных полиномов собственные значения гарантированно будут действительными, если для их получения используется &lt;a href=&quot;numpy.linalg.eigvalsh#numpy.linalg.eigvalsh&quot;&gt; &lt;code&gt;numpy.linalg.eigvalsh&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f437318ff72364f761b90a9b7cf38009e657db81" translate="yes" xml:space="preserve">
          <source>The behavior depends on the arguments in the following way.</source>
          <target state="translated">Поведение зависит от аргументов следующим образом.</target>
        </trans-unit>
        <trans-unit id="52cedd9e4737e7d41b9c0573b9212f2735c44e68" translate="yes" xml:space="preserve">
          <source>The behavior of multi-field indexes changed from Numpy 1.15 to Numpy 1.16.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c61d26e0bac97d24671e4708fc43eaa9dd53127" translate="yes" xml:space="preserve">
          <source>The behaviour of NumPy and Python integer types differs significantly for integer overflows and may confuse users expecting NumPy integers to behave similar to Python&amp;rsquo;s &lt;code&gt;int&lt;/code&gt;. Unlike NumPy, the size of Python&amp;rsquo;s &lt;code&gt;int&lt;/code&gt; is flexible. This means Python integers may expand to accommodate any integer and will not overflow.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="226707a677bb2dfd051d5e6d30579822a26a8454" translate="yes" xml:space="preserve">
          <source>The benchmark parameters etc. should not depend on which NumPy version is installed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="52a11e20913e7d4cf3019155d32cde05064b5abf" translate="yes" xml:space="preserve">
          <source>The benchmark suite should be importable with any NumPy version.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e2bdcfca6c07efc9e236b5653fc2391d3452350a" translate="yes" xml:space="preserve">
          <source>The best practice is to &lt;strong&gt;not&lt;/strong&gt; reseed a BitGenerator, rather to recreate a new one. This method is here for legacy reasons. This example demonstrates best practice.</source>
          <target state="translated">Лучше всего &lt;strong&gt;не&lt;/strong&gt; повторно загружать BitGenerator, а воссоздать новый. Этот метод используется по устаревшим причинам. Этот пример демонстрирует передовой опыт.</target>
        </trans-unit>
        <trans-unit id="c109a555c27db42b8f7688c8df998553f8ab7653" translate="yes" xml:space="preserve">
          <source>The best strategy to better understand the code base is to pick something you want to change and start reading the code to figure out how it works. When in doubt, you can ask questions on the mailing list. It is perfectly okay if your pull requests aren&amp;rsquo;t perfect, the community is always happy to help. As a volunteer project, things do sometimes get dropped and it&amp;rsquo;s totally fine to ping us if something has sat without a response for about two to four weeks.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aae59e3eb6aeca266807eb2b03def986d4d70e96" translate="yes" xml:space="preserve">
          <source>The best way to become familiar with the iterator is to look at its usage within the NumPy codebase itself. For example, here is a slightly tweaked version of the code for &lt;a href=&quot;array#c.PyArray_CountNonzero&quot;&gt;&lt;code&gt;PyArray_CountNonzero&lt;/code&gt;&lt;/a&gt;, which counts the number of non-zero elements in an array.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b917d701e1031f727f4614d1e3412a655c750b99" translate="yes" xml:space="preserve">
          <source>The best way to become familiar with the iterator is to look at its usage within the NumPy codebase itself. For example, here is a slightly tweaked version of the code for &lt;a href=&quot;c-api.array#c.PyArray_CountNonzero&quot;&gt;&lt;code&gt;PyArray_CountNonzero&lt;/code&gt;&lt;/a&gt;, which counts the number of non-zero elements in an array.</source>
          <target state="translated">Лучший способ познакомиться с итератором - взглянуть на его использование в самой кодовой базе NumPy. Например, вот немного измененная версия кода &lt;a href=&quot;c-api.array#c.PyArray_CountNonzero&quot;&gt; &lt;code&gt;PyArray_CountNonzero&lt;/code&gt; &lt;/a&gt; , который подсчитывает количество ненулевых элементов в массиве.</target>
        </trans-unit>
        <trans-unit id="de71d7b03048d0ddf7e9d872a2d91138dd227be5" translate="yes" xml:space="preserve">
          <source>The best way to encode the options required to link against the specified C libraries is to use a &amp;ldquo;libname.ini&amp;rdquo; file, and use &lt;a href=&quot;#numpy.distutils.misc_util.Configuration.get_info&quot;&gt;&lt;code&gt;get_info&lt;/code&gt;&lt;/a&gt; to retrieve the required options (see &lt;a href=&quot;#numpy.distutils.misc_util.Configuration.add_npy_pkg_config&quot;&gt;&lt;code&gt;add_npy_pkg_config&lt;/code&gt;&lt;/a&gt; for more information).</source>
          <target state="translated">Лучший способ закодировать параметры, необходимые для компоновки с указанными библиотеками C, - это использовать файл &amp;laquo;libname.ini&amp;raquo; и использовать &lt;a href=&quot;#numpy.distutils.misc_util.Configuration.get_info&quot;&gt; &lt;code&gt;get_info&lt;/code&gt; &lt;/a&gt; для получения требуемых параметров (см. &lt;a href=&quot;#numpy.distutils.misc_util.Configuration.add_npy_pkg_config&quot;&gt; &lt;code&gt;add_npy_pkg_config&lt;/code&gt; &lt;/a&gt; для получения дополнительной информации).</target>
        </trans-unit>
        <trans-unit id="bd068dc6ad18c4bdc86034d17ab908d7b76c4670" translate="yes" xml:space="preserve">
          <source>The best way to encode the options required to link against the specified C libraries is to use a &amp;ldquo;libname.ini&amp;rdquo; file, and use &lt;a href=&quot;distutils/misc_util#numpy.distutils.misc_util.get_info&quot;&gt;&lt;code&gt;get_info&lt;/code&gt;&lt;/a&gt; to retrieve the required options (see &lt;a href=&quot;#numpy.distutils.misc_util.Configuration.add_npy_pkg_config&quot;&gt;&lt;code&gt;add_npy_pkg_config&lt;/code&gt;&lt;/a&gt; for more information).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1969d49698b808b6d276d97e5d8d4c69483e3b58" translate="yes" xml:space="preserve">
          <source>The bi-dimensional histogram of samples &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;. Values in &lt;code&gt;x&lt;/code&gt; are histogrammed along the first dimension and values in &lt;code&gt;y&lt;/code&gt; are histogrammed along the second dimension.</source>
          <target state="translated">Двумерная гистограмма выборок &lt;code&gt;x&lt;/code&gt; и &lt;code&gt;y&lt;/code&gt; . Значения в &lt;code&gt;x&lt;/code&gt; отображаются гистограммой по первому измерению, а значения по &lt;code&gt;y&lt;/code&gt; - по гистограмме по второму измерению.</target>
        </trans-unit>
        <trans-unit id="ccfae57716d7eef7191c06c0e81d2ccf59d9fed0" translate="yes" xml:space="preserve">
          <source>The biggest difficulty when writing extension modules is reference counting. It is an important reason for the popularity of f2py, weave, Cython, ctypes, etc&amp;hellip;. If you mis-handle reference counts you can get problems from memory-leaks to segmentation faults. The only strategy I know of to handle reference counts correctly is blood, sweat, and tears. First, you force it into your head that every Python variable has a reference count. Then, you understand exactly what each function does to the reference count of your objects, so that you can properly use DECREF and INCREF when you need them. Reference counting can really test the amount of patience and diligence you have towards your programming craft. Despite the grim depiction, most cases of reference counting are quite straightforward with the most common difficulty being not using DECREF on objects before exiting early from a routine due to some error. In second place, is the common error of not owning the reference on an object that is passed to a function or macro that is going to steal the reference ( &lt;em&gt;e.g.&lt;/em&gt;&lt;a href=&quot;https://docs.python.org/dev/c-api/tuple.html#c.PyTuple_SET_ITEM&quot;&gt;&lt;code&gt;PyTuple_SET_ITEM&lt;/code&gt;&lt;/a&gt;, and most functions that take &lt;a href=&quot;../reference/c-api/types-and-structures#c.PyArray_Descr&quot;&gt;&lt;code&gt;PyArray_Descr&lt;/code&gt;&lt;/a&gt; objects).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="14050b2975e92118c403ebf94bd3985c0b813e9c" translate="yes" xml:space="preserve">
          <source>The bin edges along the first dimension.</source>
          <target state="translated">Края мусорного контейнера вдоль первого измерения.</target>
        </trans-unit>
        <trans-unit id="4350d5e237c7d985f1cac8ee28f6158f7c836a6a" translate="yes" xml:space="preserve">
          <source>The bin edges along the second dimension.</source>
          <target state="translated">Края мусорного контейнера вдоль второго измерения.</target>
        </trans-unit>
        <trans-unit id="a2867162a2727e5c2d9c039d549ef3ce42449ec8" translate="yes" xml:space="preserve">
          <source>The bin specification:</source>
          <target state="translated">Спецификация мусорного контейнера:</target>
        </trans-unit>
        <trans-unit id="60d93abeda71712ad2c6a79ef8adc26f40d2aa9b" translate="yes" xml:space="preserve">
          <source>The binwidth is proportional to the interquartile range (IQR) and inversely proportional to cube root of a.size. Can be too conservative for small datasets, but is quite good for large datasets. The IQR is very robust to outliers.</source>
          <target state="translated">Ширина полосы пропорциональна межквартильному диапазону (IQR)и обратно пропорциональна кубическому корню размера a.size.Может быть слишком консервативным для маленьких наборов данных,но довольно хорошим для больших наборов данных.IQR очень устойчив к отклонениям.</target>
        </trans-unit>
        <trans-unit id="fcdd8e437719df337fcbc4c74083d021a1773472" translate="yes" xml:space="preserve">
          <source>The binwidth is proportional to the standard deviation of the data and inversely proportional to cube root of &lt;code&gt;x.size&lt;/code&gt;. Can be too conservative for small datasets, but is quite good for large datasets. The standard deviation is not very robust to outliers. Values are very similar to the Freedman-Diaconis estimator in the absence of outliers.</source>
          <target state="translated">Ширина бина пропорциональна стандартному отклонению данных и обратно пропорциональна кубическому корню из &lt;code&gt;x.size&lt;/code&gt; . Может быть слишком консервативным для небольших наборов данных, но вполне подходит для больших наборов данных. Стандартное отклонение не очень устойчиво к выбросам. Значения очень похожи на оценку Фридмана-Диакониса при отсутствии выбросов.</target>
        </trans-unit>
        <trans-unit id="4bfe7be4cfb5e7ee31495fab431c2ade90ea37b4" translate="yes" xml:space="preserve">
          <source>The bit generator instance used by the generator</source>
          <target state="translated">Экземпляр генератора битов,используемый генератором</target>
        </trans-unit>
        <trans-unit id="1c9ceb11680f6c0c1b9aff1a5015653854b99511" translate="yes" xml:space="preserve">
          <source>The bit generators can be used in downstream projects via &lt;a href=&quot;extending#random-cython&quot;&gt;Cython&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c5d3462c76522066d7ff9beefce9a7effa7d1a7a" translate="yes" xml:space="preserve">
          <source>The bit generators can be used in downstream projects via &lt;a href=&quot;extending#randomgen-cython&quot;&gt;Cython&lt;/a&gt;.</source>
          <target state="translated">Генераторы битов можно использовать в последующих проектах через &lt;a href=&quot;extending#randomgen-cython&quot;&gt;Cython&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="bb60b63a1d593f422d320c08f605d5c913dee609" translate="yes" xml:space="preserve">
          <source>The bit generators can be used in downstream projects via Cython.</source>
          <target state="translated">Генераторы битов могут быть использованы в последующих проектах через Cython.</target>
        </trans-unit>
        <trans-unit id="6e4e6fbd0cb3401b8c573dd3679e44e3f4f81dbf" translate="yes" xml:space="preserve">
          <source>The bit-width names can also be used (e.g. &lt;a href=&quot;c-api.dtype#c.NPY_INT32&quot;&gt;&lt;code&gt;NPY_INT32&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;c-api.dtype#c.NPY_COMPLEX128&quot;&gt;&lt;code&gt;NPY_COMPLEX128&lt;/code&gt;&lt;/a&gt; ) if desired.</source>
          <target state="translated">При желании можно также использовать имена разрядности (например, &lt;a href=&quot;c-api.dtype#c.NPY_INT32&quot;&gt; &lt;code&gt;NPY_INT32&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;c-api.dtype#c.NPY_COMPLEX128&quot;&gt; &lt;code&gt;NPY_COMPLEX128&lt;/code&gt; &lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="bc2ab75ee612016fcf37354aa06f319d50bc9810" translate="yes" xml:space="preserve">
          <source>The bit-width names can also be used (e.g. &lt;a href=&quot;dtype#c.NPY_INT32&quot;&gt;&lt;code&gt;NPY_INT32&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;dtype#c.NPY_COMPLEX128&quot;&gt;&lt;code&gt;NPY_COMPLEX128&lt;/code&gt;&lt;/a&gt; ) if desired.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="81d10a070991358c5aabcf2c4a0f8549725777dd" translate="yes" xml:space="preserve">
          <source>The bit-wise operators &amp;amp; and | are the proper way to perform element-by-element array comparisons. Be sure you understand the operator precedence: &lt;code&gt;(a &amp;gt; 2) &amp;amp; (a &amp;lt; 5)&lt;/code&gt; is the proper syntax because &lt;code&gt;a &amp;gt; 2 &amp;amp; a &amp;lt; 5&lt;/code&gt; will result in an error due to the fact that &lt;code&gt;2 &amp;amp; a&lt;/code&gt; is evaluated first.</source>
          <target state="translated">Поразрядные операторы &amp;amp; и | являются подходящим способом для поэлементного сравнения массивов. Убедитесь, что вы понимаете приоритет оператора: &lt;code&gt;(a &amp;gt; 2) &amp;amp; (a &amp;lt; 5)&lt;/code&gt; - правильный синтаксис, потому что &lt;code&gt;a &amp;gt; 2 &amp;amp; a &amp;lt; 5&lt;/code&gt; приведет к ошибке из-за того, что &lt;code&gt;2 &amp;amp; a&lt;/code&gt; оцениваются первыми.</target>
        </trans-unit>
        <trans-unit id="023be86065ffa72daa5873059c9ec3d6c37210a4" translate="yes" xml:space="preserve">
          <source>The bits that are inherited for the parent data-type if these bits are set in any field of the data-type. Currently ( &lt;a href=&quot;#c.NPY_NEEDS_INIT&quot;&gt;&lt;code&gt;NPY_NEEDS_INIT&lt;/code&gt;&lt;/a&gt; | &lt;a href=&quot;#c.NPY_LIST_PICKLE&quot;&gt;&lt;code&gt;NPY_LIST_PICKLE&lt;/code&gt;&lt;/a&gt; | &lt;a href=&quot;#c.NPY_ITEM_REFCOUNT&quot;&gt;&lt;code&gt;NPY_ITEM_REFCOUNT&lt;/code&gt;&lt;/a&gt; | &lt;a href=&quot;#c.NPY_NEEDS_PYAPI&quot;&gt;&lt;code&gt;NPY_NEEDS_PYAPI&lt;/code&gt;&lt;/a&gt; ).</source>
          <target state="translated">Биты, которые наследуются для родительского типа данных, если эти биты установлены в любом поле этого типа данных. В настоящее время ( &lt;a href=&quot;#c.NPY_NEEDS_INIT&quot;&gt; &lt;code&gt;NPY_NEEDS_INIT&lt;/code&gt; &lt;/a&gt; | &lt;a href=&quot;#c.NPY_LIST_PICKLE&quot;&gt; &lt;code&gt;NPY_LIST_PICKLE&lt;/code&gt; &lt;/a&gt; | &lt;a href=&quot;#c.NPY_ITEM_REFCOUNT&quot;&gt; &lt;code&gt;NPY_ITEM_REFCOUNT&lt;/code&gt; &lt;/a&gt; | &lt;a href=&quot;#c.NPY_NEEDS_PYAPI&quot;&gt; &lt;code&gt;NPY_NEEDS_PYAPI&lt;/code&gt; &lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="66bf7e5c5d6cdd2845e962d8640e4eedc7ddbd7e" translate="yes" xml:space="preserve">
          <source>The branches shown by &lt;code&gt;git branch -a&lt;/code&gt; will include</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eec4adb38715609db3c28173012b3acac012a710" translate="yes" xml:space="preserve">
          <source>The broadcasting mechanism permits index arrays to be combined with scalars for other indices. The effect is that the scalar value is used for all the corresponding values of the index arrays:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="04bf04fd5bcca4e99a8d9955edaad658791a1949" translate="yes" xml:space="preserve">
          <source>The broadcasting rules are:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4cdfeeb979f5beeacca8e8ed28ded2c7c6f59236" translate="yes" xml:space="preserve">
          <source>The buffer size. If &lt;code&gt;buf_size&lt;/code&gt; is supplied, the maximum amount of data that will be read into memory is &lt;code&gt;buf_size&lt;/code&gt; elements. Default is None, which will read as many element as possible into memory.</source>
          <target state="translated">Размер буфера. Если &lt;code&gt;buf_size&lt;/code&gt; , максимальный объем данных, который будет считан в память, - &lt;code&gt;buf_size&lt;/code&gt; элементы buf_size . По умолчанию - Нет, при этом в память будет прочитано как можно больше элементов.</target>
        </trans-unit>
        <trans-unit id="2e41256de81634e573afba6a93755e0b3e1dcc73" translate="yes" xml:space="preserve">
          <source>The built-in scalar types are shown below. Along with their (mostly) C-derived names, the integer, float, and complex data-types are also available using a bit-width convention so that an array of the right size can always be ensured (e.g. &lt;code&gt;int8&lt;/code&gt;, &lt;code&gt;float64&lt;/code&gt;, &lt;code&gt;complex128&lt;/code&gt;). Two aliases (&lt;code&gt;intp&lt;/code&gt; and &lt;code&gt;uintp&lt;/code&gt;) pointing to the integer type that is sufficiently large to hold a C pointer are also provided. The C-like names are associated with character codes, which are shown in the table. Use of the character codes, however, is discouraged.</source>
          <target state="translated">Встроенные скалярные типы показаны ниже. Наряду с их (в основном) именами, производными от C, целочисленные, float и сложные типы данных также доступны с использованием соглашения о ширине битов, так что всегда можно обеспечить массив правильного размера (например, &lt;code&gt;int8&lt;/code&gt; , &lt;code&gt;float64&lt;/code&gt; , &lt;code&gt;complex128&lt;/code&gt; ) . Также предоставляются два псевдонима ( &lt;code&gt;intp&lt;/code&gt; и &lt;code&gt;uintp&lt;/code&gt; ), указывающие на целочисленный тип, который достаточно велик, чтобы содержать указатель C. C-подобные имена связаны с кодами символов, которые показаны в таблице. Однако использование кодов символов не рекомендуется.</target>
        </trans-unit>
        <trans-unit id="c4c8520f0fdeec5c9624ae64d988b36f0b68f100" translate="yes" xml:space="preserve">
          <source>The built-in scalar types are shown below. The C-like names are associated with character codes, which are shown in their descriptions. Use of the character codes, however, is discouraged.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c0f5f929adb8df8a6adc766b8c78557ffdeb6dfb" translate="yes" xml:space="preserve">
          <source>The byte offset of element &lt;code&gt;(i[0], i[1], ..., i[n])&lt;/code&gt; in an array &lt;code&gt;a&lt;/code&gt; is:</source>
          <target state="translated">Байтовое смещение элемента &lt;code&gt;(i[0], i[1], ..., i[n])&lt;/code&gt; в массиве &lt;code&gt;a&lt;/code&gt; равно:</target>
        </trans-unit>
        <trans-unit id="4e1d8f651723be5f774ab2e5c504d861c7a87264" translate="yes" xml:space="preserve">
          <source>The byte offsets of the fields within the structure and the total structure itemsize are determined automatically.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a157c5730d5626d8d468cb6666e1e8a306635908" translate="yes" xml:space="preserve">
          <source>The byte order of the data (which may not be the native byte order)</source>
          <target state="translated">Порядок байт данных (который может не быть родным порядком байт)</target>
        </trans-unit>
        <trans-unit id="54750603ecbabb9e0fbfb396fe440127b1696b3c" translate="yes" xml:space="preserve">
          <source>The byteswapped array. If &lt;code&gt;inplace&lt;/code&gt; is &lt;code&gt;True&lt;/code&gt;, this is a view to self.</source>
          <target state="translated">Массив с заменой байтов. Если &lt;code&gt;inplace&lt;/code&gt; имеет значение &lt;code&gt;True&lt;/code&gt; , это представление для себя.</target>
        </trans-unit>
        <trans-unit id="50ca95011c00b72a055aafd7f7fd748d3ee5666f" translate="yes" xml:space="preserve">
          <source>The calculation based on the Einstein summation convention.</source>
          <target state="translated">Расчет на основе конвенции об объединении Эйнштейна.</target>
        </trans-unit>
        <trans-unit id="f28022cc3c759ea7fff9649dace591b586e47f2a" translate="yes" xml:space="preserve">
          <source>The call function takes two arguments. The first is a string describing the type of error (such as &amp;ldquo;divide by zero&amp;rdquo;, &amp;ldquo;overflow&amp;rdquo;, &amp;ldquo;underflow&amp;rdquo;, or &amp;ldquo;invalid value&amp;rdquo;), and the second is the status flag. The flag is a byte, whose four least-significant bits indicate the type of error, one of &amp;ldquo;divide&amp;rdquo;, &amp;ldquo;over&amp;rdquo;, &amp;ldquo;under&amp;rdquo;, &amp;ldquo;invalid&amp;rdquo;:</source>
          <target state="translated">Функция вызова принимает два аргумента. Первая - это строка, описывающая тип ошибки (например, &amp;laquo;разделить на ноль&amp;raquo;, &amp;laquo;переполнение&amp;raquo;, &amp;laquo;потеря значимости&amp;raquo; или &amp;laquo;недопустимое значение&amp;raquo;), а вторая - это флаг состояния. Флаг представляет собой байт, четыре младших бита которого указывают тип ошибки: &amp;laquo;разделить&amp;raquo;, &amp;laquo;больше&amp;raquo;, &amp;laquo;меньше&amp;raquo;, &amp;laquo;недействительно&amp;raquo;:</target>
        </trans-unit>
        <trans-unit id="65bfb33c8f536eca2e334a181b45563504281f94" translate="yes" xml:space="preserve">
          <source>The callable to test.</source>
          <target state="translated">Призыв к тестированию.</target>
        </trans-unit>
        <trans-unit id="a3a1c9abf4ffccd45f5331c5f42edc1f3d2d1d9d" translate="yes" xml:space="preserve">
          <source>The callback function may also be explicitly set in the module. Then it is not necessary to pass the function in the argument list to the Fortran function. This may be desired if the Fortran function calling the python callback function is itself called by another Fortran function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="431e9b7795bdf48241d6bec5990fb4a0130d071a" translate="yes" xml:space="preserve">
          <source>The ceil of the scalar &lt;code&gt;x&lt;/code&gt; is the smallest integer &lt;code&gt;i&lt;/code&gt;, such that &lt;code&gt;i &amp;gt;= x&lt;/code&gt;. It is often denoted as</source>
          <target state="translated">Ceil скаляра &lt;code&gt;x&lt;/code&gt; - это наименьшее целое число &lt;code&gt;i&lt;/code&gt; такое, что &lt;code&gt;i &amp;gt;= x&lt;/code&gt; . Часто обозначается как</target>
        </trans-unit>
        <trans-unit id="e9d3cf326f9a7a53ec955615e43eb638c61eb8ef" translate="yes" xml:space="preserve">
          <source>The ceiling of each element in &lt;code&gt;x&lt;/code&gt;, with &lt;a href=&quot;https://docs.python.org/dev/library/functions.html#float&quot;&gt;&lt;code&gt;float&lt;/code&gt;&lt;/a&gt; dtype. This is a scalar if &lt;code&gt;x&lt;/code&gt; is a scalar.</source>
          <target state="translated">Потолок каждого элемента в &lt;code&gt;x&lt;/code&gt; , с &lt;a href=&quot;https://docs.python.org/dev/library/functions.html#float&quot;&gt; &lt;code&gt;float&lt;/code&gt; &lt;/a&gt; dtype. Это скаляр, если &lt;code&gt;x&lt;/code&gt; - скаляр.</target>
        </trans-unit>
        <trans-unit id="39a8dcb488a9fc6fc34cf5a558688abf07d39d3f" translate="yes" xml:space="preserve">
          <source>The character representing the minimum-size type that was found.</source>
          <target state="translated">Символ,представляющий найденный тип минимального размера.</target>
        </trans-unit>
        <trans-unit id="97cbe8e263bc4b6b77075dcb6bab028e565a01e7" translate="yes" xml:space="preserve">
          <source>The character to use for padding</source>
          <target state="translated">Символ,который нужно использовать для набивки</target>
        </trans-unit>
        <trans-unit id="6c4bf24ea0f35b24c677f85fded0fd7b09f23149" translate="yes" xml:space="preserve">
          <source>The character used to indicate the start of a comment. All the characters occurring on a line after a comment are discarded</source>
          <target state="translated">Символ,используемый для обозначения начала комментария.Все символы,встречающиеся в строке после комментария,отбрасываются.</target>
        </trans-unit>
        <trans-unit id="d85f382686a835461ae276491d1cc1f7d794fafc" translate="yes" xml:space="preserve">
          <source>The characteristic polynomial,</source>
          <target state="translated">Характерный полиномиальный,</target>
        </trans-unit>
        <trans-unit id="95fe0ca98cff261937758debf60dec87c78a570a" translate="yes" xml:space="preserve">
          <source>The characters or list of characters used to indicate the start of a comment. None implies no comments. For backwards compatibility, byte strings will be decoded as &amp;lsquo;latin1&amp;rsquo;. The default is &amp;lsquo;#&amp;rsquo;.</source>
          <target state="translated">Символы или список символов, используемых для обозначения начала комментария. Ни один не подразумевает никаких комментариев. Для обратной совместимости байтовые строки будут декодироваться как latin1. По умолчанию - &quot;#&quot;.</target>
        </trans-unit>
        <trans-unit id="16535da2d1a6378c09b05298f374b6373da93c3c" translate="yes" xml:space="preserve">
          <source>The choice and location of linked libraries such as BLAS and LAPACK as well as include paths and other such build options can be specified in a &lt;code&gt;site.cfg&lt;/code&gt; file located in the NumPy root repository or a &lt;code&gt;.numpy-site.cfg&lt;/code&gt; file in your home directory. See the &lt;code&gt;site.cfg.example&lt;/code&gt; example file included in the NumPy repository or sdist for documentation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b3f50108009441cc91c801c6a0d50e7f118400f" translate="yes" xml:space="preserve">
          <source>The class defining the warning that &lt;code&gt;func&lt;/code&gt; is expected to throw.</source>
          <target state="translated">Класс, определяющий предупреждение, которое, как ожидается , &lt;code&gt;func&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="da74e7889b120a1d89220abab914f35b23ca6ac5" translate="yes" xml:space="preserve">
          <source>The clear choice to wrap Fortran code is &lt;a href=&quot;https://docs.scipy.org/doc/numpy/f2py/&quot;&gt;f2py&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3182c5f9b369539a27f1bc7716b92f10416add66" translate="yes" xml:space="preserve">
          <source>The code does a case-insensitive check on the first letter of &lt;code&gt;new_order&lt;/code&gt; for these alternatives. For example, any of &amp;lsquo;&amp;gt;&amp;rsquo; or &amp;lsquo;B&amp;rsquo; or &amp;lsquo;b&amp;rsquo; or &amp;lsquo;brian&amp;rsquo; are valid to specify big-endian.</source>
          <target state="translated">Код проверяет первую букву &lt;code&gt;new_order&lt;/code&gt; без учета регистра для этих альтернатив. Например, любое из '&amp;gt;', 'B', 'b' или 'brian' допустимо для указания прямого порядка байтов.</target>
        </trans-unit>
        <trans-unit id="80380a308ceba94a9432deb39fde76dbd31d736a" translate="yes" xml:space="preserve">
          <source>The code in the second example is more efficient than that in the first because broadcasting moves less memory around during the multiplication (&lt;code&gt;b&lt;/code&gt; is a scalar rather than an array).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b154e2d8d3173f85d365231f520eaf5d3d14ed4d" translate="yes" xml:space="preserve">
          <source>The code to produce the figures is part of the &lt;a href=&quot;http://www.astroml.org/book_figures/appendix/fig_broadcast_visual.html&quot;&gt;AstroML book&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d7fde77cc6d2864c99d7d852dc9654a8a2c232a" translate="yes" xml:space="preserve">
          <source>The coefficient array representing their sum.</source>
          <target state="translated">Массив коэффициентов,представляющий их сумму.</target>
        </trans-unit>
        <trans-unit id="8877be945db0e0267ce25ed710aea10434e74470" translate="yes" xml:space="preserve">
          <source>The coefficient matrix of the coefficients &lt;code&gt;p&lt;/code&gt; is a Vandermonde matrix.</source>
          <target state="translated">Матрица коэффициентов коэффициентов &lt;code&gt;p&lt;/code&gt; является матрицей Вандермонда.</target>
        </trans-unit>
        <trans-unit id="1749ca10e1fd82b0f81734b8e3040c222ba10138" translate="yes" xml:space="preserve">
          <source>The coefficient of the last term is 1 for monic polynomials in this form.</source>
          <target state="translated">Коэффициент последнего члена для монических полиномов в этой форме равен 1.</target>
        </trans-unit>
        <trans-unit id="7f518b8b3d036f3e65aa1004d0ce4c9fe4f469f2" translate="yes" xml:space="preserve">
          <source>The coefficient of the last term is not generally 1 for monic polynomials in Chebyshev form.</source>
          <target state="translated">Коэффициент последнего члена обычно не равен 1 для монических многочленов в чебышевской форме.</target>
        </trans-unit>
        <trans-unit id="c6e27aff7bd03298a7abe7cdd24c2851e78ffc19" translate="yes" xml:space="preserve">
          <source>The coefficient of the last term is not generally 1 for monic polynomials in Hermite form.</source>
          <target state="translated">Коэффициент последнего члена обычно не равен 1 для монических полиномов в эрмитарной форме.</target>
        </trans-unit>
        <trans-unit id="d8180193920e1d179284839e524518471959f55d" translate="yes" xml:space="preserve">
          <source>The coefficient of the last term is not generally 1 for monic polynomials in HermiteE form.</source>
          <target state="translated">Коэффициент последнего члена для монических полиномов в форме HermiteE обычно не равен 1.</target>
        </trans-unit>
        <trans-unit id="870417532aa77b335abb3ff61d44b3280649b54a" translate="yes" xml:space="preserve">
          <source>The coefficient of the last term is not generally 1 for monic polynomials in Laguerre form.</source>
          <target state="translated">Коэффициент последнего члена,как правило,не является 1 для монических полиномов в форме Лагера.</target>
        </trans-unit>
        <trans-unit id="d2eb9fcb4c7fc816e015e2f1263164865a84ea2c" translate="yes" xml:space="preserve">
          <source>The coefficient of the last term is not generally 1 for monic polynomials in Legendre form.</source>
          <target state="translated">Коэффициент последнего члена обычно не равен 1 для монических полиномов в форме Легенды.</target>
        </trans-unit>
        <trans-unit id="c0eab4462e93f35863c8383ff656ddde3733b00b" translate="yes" xml:space="preserve">
          <source>The coefficients are determined by multiplying together linear factors of the form &lt;code&gt;(x - r_i)&lt;/code&gt;, i.e.</source>
          <target state="translated">Коэффициенты определяются путем умножения линейных коэффициентов вида &lt;code&gt;(x - r_i)&lt;/code&gt; , т.е.</target>
        </trans-unit>
        <trans-unit id="96b42532f49d3b3a4358a0737c1292c860f167f7" translate="yes" xml:space="preserve">
          <source>The column &lt;code&gt;v[:, i]&lt;/code&gt; is the normalized eigenvector corresponding to the eigenvalue &lt;code&gt;w[i]&lt;/code&gt;. Will return a matrix object if &lt;code&gt;a&lt;/code&gt; is a matrix object.</source>
          <target state="translated">Столбец &lt;code&gt;v[:, i]&lt;/code&gt; - это нормализованный собственный вектор, соответствующий собственному значению &lt;code&gt;w[i]&lt;/code&gt; . Вернет объект матрицы, если &lt;code&gt;a&lt;/code&gt; является объектом матрицы.</target>
        </trans-unit>
        <trans-unit id="05afae6f6316038b8a077ed2d79753233c9700ab" translate="yes" xml:space="preserve">
          <source>The column dimension of the arrays for which the returned arrays will be valid. By default &lt;code&gt;m&lt;/code&gt; is taken equal to &lt;code&gt;n&lt;/code&gt;.</source>
          <target state="translated">Размер столбца массивов, для которых будут действительны возвращаемые массивы. По умолчанию &lt;code&gt;m&lt;/code&gt; принимается равным &lt;code&gt;n&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="049227627bd4dfed2d2a3d0a02023afddf2ece4d" translate="yes" xml:space="preserve">
          <source>The columns of the output matrix are powers of the input vector. The order of the powers is determined by the &lt;code&gt;increasing&lt;/code&gt; boolean argument. Specifically, when &lt;code&gt;increasing&lt;/code&gt; is False, the &lt;code&gt;i&lt;/code&gt;-th output column is the input vector raised element-wise to the power of &lt;code&gt;N - i - 1&lt;/code&gt;. Such a matrix with a geometric progression in each row is named for Alexandre- Theophile Vandermonde.</source>
          <target state="translated">Столбцы выходной матрицы являются степенями входного вектора. Порядок степеней определяется &lt;code&gt;increasing&lt;/code&gt; логическим аргументом. В частности, когда &lt;code&gt;increasing&lt;/code&gt; имеет значение Ложь, &lt;code&gt;i&lt;/code&gt; -й выходной столбец представляет собой входной вектор, поэтапно возведенный в степень &lt;code&gt;N - i - 1&lt;/code&gt; . Такая матрица с геометрической прогрессией в каждой строке названа в честь Александра-Теофиля Вандермонда.</target>
        </trans-unit>
        <trans-unit id="fd5ff7ed1e1b0436ec4f4722206a381ca973b853" translate="yes" xml:space="preserve">
          <source>The command &lt;code&gt;make test&lt;/code&gt; will ensure that all of the test software is built and then run all three test scripts.</source>
          <target state="translated">Команда &lt;code&gt;make test&lt;/code&gt; гарантирует, что все тестовое программное обеспечение создано, а затем запускает все три тестовых сценария.</target>
        </trans-unit>
        <trans-unit id="16227b68a1418fc90dc494649e7c543fabd7409c" translate="yes" xml:space="preserve">
          <source>The command arguments are available in &lt;code&gt;build&lt;/code&gt;, &lt;code&gt;build_clib&lt;/code&gt;, and &lt;code&gt;build_ext&lt;/code&gt;. if &lt;code&gt;build_clib&lt;/code&gt; or &lt;code&gt;build_ext&lt;/code&gt; are not specified by the user, the arguments of &lt;code&gt;build&lt;/code&gt; will be used instead, which also holds the default values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e66bb28254c2c47afebe31be29c7f178c6baf9ce" translate="yes" xml:space="preserve">
          <source>The committee must agree on a resolution by consensus. If the group cannot reach consensus and deadlocks for over a week, the group will turn the matter over to the Steering Council for resolution.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f296a348ca6c5f048bde7ff72475becfa99bfb54" translate="yes" xml:space="preserve">
          <source>The committee will never publicly discuss the issue; all public statements will be made by the chair of the Code of Conduct Committee or the NumPy Steering Council.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1da455687a62d6eecd2b4975d23b71811215c8f1" translate="yes" xml:space="preserve">
          <source>The committee will respond to any report as soon as possible, and at most within 72 hours.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b080620b2cb81b4501691bc62009a0f3cdee2b1d" translate="yes" xml:space="preserve">
          <source>The committee will then review the incident and determine, to the best of their ability:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="24aa155f0fb452987333532fc0871b6b96e25258" translate="yes" xml:space="preserve">
          <source>The common data type, which is the maximum of &lt;code&gt;array_types&lt;/code&gt; ignoring &lt;code&gt;scalar_types&lt;/code&gt;, unless the maximum of &lt;code&gt;scalar_types&lt;/code&gt; is of a different kind (&lt;a href=&quot;numpy.dtype.kind#numpy.dtype.kind&quot;&gt;&lt;code&gt;dtype.kind&lt;/code&gt;&lt;/a&gt;). If the kind is not understood, then None is returned.</source>
          <target state="translated">Общий тип данных, который представляет собой максимум из &lt;code&gt;array_types&lt;/code&gt; , игнорируя &lt;code&gt;scalar_types&lt;/code&gt; , если только максимум &lt;code&gt;scalar_types&lt;/code&gt; не имеет другого типа ( &lt;a href=&quot;numpy.dtype.kind#numpy.dtype.kind&quot;&gt; &lt;code&gt;dtype.kind&lt;/code&gt; &lt;/a&gt; ). Если вид не понят, возвращается None.</target>
        </trans-unit>
        <trans-unit id="6557c9bc2aa7a334ee156279cd2e6ed26882b290" translate="yes" xml:space="preserve">
          <source>The common fill value, or None.</source>
          <target state="translated">Общее заполняющее значение,или Нет.</target>
        </trans-unit>
        <trans-unit id="792a2de181f669c74b9db5a5aeebd6abe9c93185" translate="yes" xml:space="preserve">
          <source>The common situations in which you need to change byte ordering are:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c7c4929011c41aa057f46d2bc4e51aaccf9a85a1" translate="yes" xml:space="preserve">
          <source>The companion matrix for power series cannot be made symmetric by scaling the basis, so this function differs from those for the orthogonal polynomials.</source>
          <target state="translated">Матрица-сопутствующая для силовых рядов не может быть симметричной при масштабировании базиса,поэтому эта функция отличается от матрицы для ортогональных полиномов.</target>
        </trans-unit>
        <trans-unit id="50728cc7411772baf0d23ae9dab7a04fd085919c" translate="yes" xml:space="preserve">
          <source>The comparison of &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; uses standard broadcasting, which means that &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; need not have the same shape in order for &lt;code&gt;allclose(a, b)&lt;/code&gt; to evaluate to True. The same is true for &lt;a href=&quot;numpy.equal#numpy.equal&quot;&gt;&lt;code&gt;equal&lt;/code&gt;&lt;/a&gt; but not &lt;a href=&quot;numpy.array_equal#numpy.array_equal&quot;&gt;&lt;code&gt;array_equal&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">При сравнении &lt;code&gt;a&lt;/code&gt; и &lt;code&gt;b&lt;/code&gt; используется стандартная широковещательная передача, а это означает, что &lt;code&gt;a&lt;/code&gt; и &lt;code&gt;b&lt;/code&gt; не обязательно должны иметь одинаковую форму, чтобы &lt;code&gt;allclose(a, b)&lt;/code&gt; оценивался как True. То же самое верно для &lt;a href=&quot;numpy.equal#numpy.equal&quot;&gt; &lt;code&gt;equal&lt;/code&gt; ,&lt;/a&gt; но не для &lt;a href=&quot;numpy.array_equal#numpy.array_equal&quot;&gt; &lt;code&gt;array_equal&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ed9a376f5659e4753c56a46ffbea586e1c5b762b" translate="yes" xml:space="preserve">
          <source>The complex conjugate of &lt;code&gt;x&lt;/code&gt;, with same dtype as &lt;code&gt;y&lt;/code&gt;. This is a scalar if &lt;code&gt;x&lt;/code&gt; is a scalar.</source>
          <target state="translated">Комплексное сопряжение &lt;code&gt;x&lt;/code&gt; с тем же dtype, что и &lt;code&gt;y&lt;/code&gt; . Это скаляр, если &lt;code&gt;x&lt;/code&gt; - скаляр.</target>
        </trans-unit>
        <trans-unit id="d1ca0ff74dd3394813701dd385de23f306fa9c69" translate="yes" xml:space="preserve">
          <source>The complex conjugate of a complex number is obtained by changing the sign of its imaginary part.</source>
          <target state="translated">Комплексный конъюгат комплексного числа получается путем изменения знака его воображаемой части.</target>
        </trans-unit>
        <trans-unit id="41eb6fa093181f73897902c7f0874292edf29e51" translate="yes" xml:space="preserve">
          <source>The compressed array.</source>
          <target state="translated">Сжатый массив.</target>
        </trans-unit>
        <trans-unit id="5eb5823a400c379807aed8ab125dee97f320721d" translate="yes" xml:space="preserve">
          <source>The concatenated array with any masked entries preserved.</source>
          <target state="translated">Сокращенный массив с любыми маскированными записями сохраняется.</target>
        </trans-unit>
        <trans-unit id="a37868502a5a0d6add95945d1a64803e757adeaa" translate="yes" xml:space="preserve">
          <source>The concatenated array.</source>
          <target state="translated">Конкатенированный массив.</target>
        </trans-unit>
        <trans-unit id="3af59c1bb124d9d3dff66fb6d58de527a5027e82" translate="yes" xml:space="preserve">
          <source>The concept of a behaved segment is used in the description of the function pointers. A behaved segment is one that is aligned and in native machine byte-order for the data-type. The &lt;code&gt;nonzero&lt;/code&gt;, &lt;code&gt;copyswap&lt;/code&gt;, &lt;code&gt;copyswapn&lt;/code&gt;, &lt;code&gt;getitem&lt;/code&gt;, and &lt;code&gt;setitem&lt;/code&gt; functions can (and must) deal with mis-behaved arrays. The other functions require behaved memory segments.</source>
          <target state="translated">В описании указателей на функции используется понятие управляемого сегмента. Сегмент с поведением - это сегмент, который выровнен и имеет собственный машинный порядок байтов для типа данных. В &lt;code&gt;nonzero&lt;/code&gt; , &lt;code&gt;copyswap&lt;/code&gt; , &lt;code&gt;copyswapn&lt;/code&gt; , &lt;code&gt;getitem&lt;/code&gt; и &lt;code&gt;setitem&lt;/code&gt; функции могут (и должны) иметь дело с неправильно вели себя массивы. Для других функций требуются сегменты памяти с управляемым поведением.</target>
        </trans-unit>
        <trans-unit id="46e686c81ff0f33a7ee42cbdb148b2206e722231" translate="yes" xml:space="preserve">
          <source>The condition number of &lt;code&gt;x&lt;/code&gt; is defined as the norm of &lt;code&gt;x&lt;/code&gt; times the norm of the inverse of &lt;code&gt;x&lt;/code&gt;&lt;a href=&quot;#r611900c44d60-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt;; the norm can be the usual L2-norm (root-of-sum-of-squares) or one of a number of other matrix norms.</source>
          <target state="translated">Число обусловленности &lt;code&gt;x&lt;/code&gt; определяется как норма &lt;code&gt;x&lt;/code&gt; , умноженная на норму, обратную &lt;code&gt;x&lt;/code&gt; &lt;a href=&quot;#r611900c44d60-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt; ; норма может быть обычной L2-нормой (корень из суммы квадратов) или одной из ряда других матричных норм.</target>
        </trans-unit>
        <trans-unit id="7ed508e4defcab357510ceacda28d2924496cd06" translate="yes" xml:space="preserve">
          <source>The condition number of the matrix. May be infinite.</source>
          <target state="translated">Номер условия матрицы.Может быть бесконечным.</target>
        </trans-unit>
        <trans-unit id="c901451fe41cf6f1482465c84b6a4c739cbccbff" translate="yes" xml:space="preserve">
          <source>The config file generated from &lt;code&gt;template&lt;/code&gt; is installed in the given install directory, using &lt;code&gt;subst_dict&lt;/code&gt; for variable substitution.</source>
          <target state="translated">Файл конфигурации, созданный из &lt;code&gt;template&lt;/code&gt; , устанавливается в указанном каталоге установки с использованием &lt;code&gt;subst_dict&lt;/code&gt; для подстановки переменных.</target>
        </trans-unit>
        <trans-unit id="2fe0070d6ccb31708b92b4e4ed2caabdfe3d249d" translate="yes" xml:space="preserve">
          <source>The constants &lt;strong&gt;NPY_INTP&lt;/strong&gt; and &lt;strong&gt;NPY_UINTP&lt;/strong&gt; refer to an enumerated integer type that is large enough to hold a pointer on the platform. Index arrays should always be converted to &lt;strong&gt;NPY_INTP&lt;/strong&gt; , because the dimension of the array is of type npy_intp.</source>
          <target state="translated">Константы &lt;strong&gt;NPY_INTP&lt;/strong&gt; и &lt;strong&gt;NPY_UINTP&lt;/strong&gt; относятся к перечислимому целочисленному типу, который достаточно велик, чтобы содержать указатель на платформе. Индексные массивы всегда следует преобразовывать в &lt;strong&gt;NPY_INTP&lt;/strong&gt; , поскольку размерность массива имеет тип npy_intp.</target>
        </trans-unit>
        <trans-unit id="fd8a200b77c06e1513f552e8d61858be6438182d" translate="yes" xml:space="preserve">
          <source>The constructed array.</source>
          <target state="translated">Построенный массив.</target>
        </trans-unit>
        <trans-unit id="8c8c3ae23d3b8b9d4c2965f608e114605317b1d2" translate="yes" xml:space="preserve">
          <source>The constructed extension module is saved as &lt;code&gt;&amp;lt;modulename&amp;gt;module.c&lt;/code&gt; to the current directory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1564bd8e09196ae3556506f90562583aff6d8fc2" translate="yes" xml:space="preserve">
          <source>The content of a modified version of &lt;code&gt;fib1.pyf&lt;/code&gt; (saved as &lt;code&gt;fib2.pyf&lt;/code&gt;) is as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f12164e316c899cbeec8a520db14b994fa35a8e" translate="yes" xml:space="preserve">
          <source>The contiguous constraint applies only to the inner loop, successive inner loops may have arbitrary pointer changes.</source>
          <target state="translated">Сопряженное ограничение относится только к внутреннему циклу,последовательные внутренние циклы могут иметь произвольное изменение указателя.</target>
        </trans-unit>
        <trans-unit id="a28f32d0e2528be0855bfa01e7539cc0e939d215" translate="yes" xml:space="preserve">
          <source>The convenience classes provided by the polynomial package are:</source>
          <target state="translated">Классы удобства,предоставляемые полиноминальным пакетом:</target>
        </trans-unit>
        <trans-unit id="5a4e9570e8f8bcacc96f206106a01eefad39bd6f" translate="yes" xml:space="preserve">
          <source>The convert method can also convert domain and window:</source>
          <target state="translated">Метод преобразования также может преобразовывать домен и окно:</target>
        </trans-unit>
        <trans-unit id="60131768e228b843852dbff6de95273c5e8b7bcb" translate="yes" xml:space="preserve">
          <source>The converted data-type.</source>
          <target state="translated">Преобразованный тип данных.</target>
        </trans-unit>
        <trans-unit id="1fc6b89fce1f12a34477c12a69d7cd751ad23c91" translate="yes" xml:space="preserve">
          <source>The convolution operator is often seen in signal processing, where it models the effect of a linear time-invariant system on a signal &lt;a href=&quot;#r95849f33d2b1-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt;. In probability theory, the sum of two independent random variables is distributed according to the convolution of their individual distributions.</source>
          <target state="translated">Оператор свертки часто используется при обработке сигналов, где он моделирует влияние линейной инвариантной во времени системы на сигнал &lt;a href=&quot;#r95849f33d2b1-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt; . В теории вероятностей сумма двух независимых случайных величин распределяется согласно свертке их индивидуальных распределений.</target>
        </trans-unit>
        <trans-unit id="1b7a113f553d13745aed52a84f8c20493ad427e3" translate="yes" xml:space="preserve">
          <source>The coordinates member of the &lt;a href=&quot;c-api.types-and-structures#c.PyArrayIterObject&quot;&gt;&lt;code&gt;PyArrayIterObject&lt;/code&gt;&lt;/a&gt; structure maintains the current N-d counter unless the underlying array is C-contiguous in which case the coordinate counting is by-passed. The index member of the &lt;a href=&quot;c-api.types-and-structures#c.PyArrayIterObject&quot;&gt;&lt;code&gt;PyArrayIterObject&lt;/code&gt;&lt;/a&gt; keeps track of the current flat index of the iterator. It is updated by the &lt;a href=&quot;c-api.array#c.PyArray_ITER_NEXT&quot;&gt;&lt;code&gt;PyArray_ITER_NEXT&lt;/code&gt;&lt;/a&gt; macro.</source>
          <target state="translated">Член координаты структуры &lt;a href=&quot;c-api.types-and-structures#c.PyArrayIterObject&quot;&gt; &lt;code&gt;PyArrayIterObject&lt;/code&gt; &lt;/a&gt; поддерживает текущий счетчик Nd, если только базовый массив не является C-смежным, и в этом случае подсчет координат не выполняется. Член индекса &lt;a href=&quot;c-api.types-and-structures#c.PyArrayIterObject&quot;&gt; &lt;code&gt;PyArrayIterObject&lt;/code&gt; &lt;/a&gt; отслеживает текущий плоский индекс итератора. Он обновляется &lt;a href=&quot;c-api.array#c.PyArray_ITER_NEXT&quot;&gt; &lt;code&gt;PyArray_ITER_NEXT&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a60368fcddf184df8cd7ef5081ac979bc50c50f2" translate="yes" xml:space="preserve">
          <source>The coordinates member of the &lt;a href=&quot;c-api/types-and-structures#c.PyArrayIterObject&quot;&gt;&lt;code&gt;PyArrayIterObject&lt;/code&gt;&lt;/a&gt; structure maintains the current N-d counter unless the underlying array is C-contiguous in which case the coordinate counting is by-passed. The index member of the &lt;a href=&quot;c-api/types-and-structures#c.PyArrayIterObject&quot;&gt;&lt;code&gt;PyArrayIterObject&lt;/code&gt;&lt;/a&gt; keeps track of the current flat index of the iterator. It is updated by the &lt;a href=&quot;c-api/array#c.PyArray_ITER_NEXT&quot;&gt;&lt;code&gt;PyArray_ITER_NEXT&lt;/code&gt;&lt;/a&gt; macro.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="893c6dfe4a5a151e44d6687fac35fbd3b646a45a" translate="yes" xml:space="preserve">
          <source>The core dimensions are removed from all inputs and the remaining dimensions are broadcast together, defining the loop dimensions.</source>
          <target state="translated">Размеры ядра удаляются со всех входов,а остальные размеры передаются вместе,определяя размеры петли.</target>
        </trans-unit>
        <trans-unit id="72b350bebf37a78a10162e24af07cb3168e9e839" translate="yes" xml:space="preserve">
          <source>The core of the ufunc is the &lt;a href=&quot;#c.PyUFuncObject&quot;&gt;&lt;code&gt;PyUFuncObject&lt;/code&gt;&lt;/a&gt; which contains all the information needed to call the underlying C-code loops that perform the actual work. While it is described here for completeness, it should be considered internal to NumPy and manipulated via &lt;code&gt;PyUFunc_*&lt;/code&gt; functions. The size of this structure is subject to change across versions of NumPy. To ensure compatibility:</source>
          <target state="translated">Ядром ufunc является &lt;a href=&quot;#c.PyUFuncObject&quot;&gt; &lt;code&gt;PyUFuncObject&lt;/code&gt; ,&lt;/a&gt; который содержит всю информацию, необходимую для вызова базовых циклов C-кода, которые выполняют фактическую работу. Хотя он описан здесь для полноты, он должен считаться внутренним для NumPy и управляться через функции &lt;code&gt;PyUFunc_*&lt;/code&gt; . Размер этой структуры может меняться в разных версиях NumPy. Для обеспечения совместимости:</target>
        </trans-unit>
        <trans-unit id="773b5bb85bcdc60b3e588df5ec27ee1692be9141" translate="yes" xml:space="preserve">
          <source>The correct interpretation of the hermitian input depends on the length of the original data, as given by &lt;code&gt;n&lt;/code&gt;. This is because each input shape could correspond to either an odd or even length signal. By default, &lt;a href=&quot;#numpy.fft.hfft&quot;&gt;&lt;code&gt;hfft&lt;/code&gt;&lt;/a&gt; assumes an even output length which puts the last entry at the Nyquist frequency; aliasing with its symmetric counterpart. By Hermitian symmetry, the value is thus treated as purely real. To avoid losing information, the shape of the full signal &lt;strong&gt;must&lt;/strong&gt; be given.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b5b1507243ebb36968e1fec7c90425484cafd21a" translate="yes" xml:space="preserve">
          <source>The correct interpretation of the hermitian input depends on the length of the original data, as given by &lt;code&gt;n&lt;/code&gt;. This is because each input shape could correspond to either an odd or even length signal. By default, &lt;a href=&quot;#numpy.fft.irfft&quot;&gt;&lt;code&gt;irfft&lt;/code&gt;&lt;/a&gt; assumes an even output length which puts the last entry at the Nyquist frequency; aliasing with its symmetric counterpart. By Hermitian symmetry, the value is thus treated as purely real. To avoid losing information, the correct length of the real input &lt;strong&gt;must&lt;/strong&gt; be given.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="37beab5b2e24a56105c7c01133a885f5a78e9481" translate="yes" xml:space="preserve">
          <source>The correct interpretation of the hermitian input depends on the shape of the original data, as given by &lt;code&gt;s&lt;/code&gt;. This is because each input shape could correspond to either an odd or even length signal. By default, &lt;a href=&quot;#numpy.fft.irfftn&quot;&gt;&lt;code&gt;irfftn&lt;/code&gt;&lt;/a&gt; assumes an even output length which puts the last entry at the Nyquist frequency; aliasing with its symmetric counterpart. When performing the final complex to real transform, the last value is thus treated as purely real. To avoid losing information, the correct shape of the real input &lt;strong&gt;must&lt;/strong&gt; be given.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="76b4be14cc8fe5491309195ba608e3525321fc00" translate="yes" xml:space="preserve">
          <source>The correlation coefficient matrix of the variables.</source>
          <target state="translated">Матрица коэффициентов корреляции переменных.</target>
        </trans-unit>
        <trans-unit id="f4e710373f0588180cd5157b94f36ff64a509ad5" translate="yes" xml:space="preserve">
          <source>The corresponding angle in degrees. This is a scalar if &lt;code&gt;x&lt;/code&gt; is a scalar.</source>
          <target state="translated">Соответствующий угол в градусах. Это скаляр, если &lt;code&gt;x&lt;/code&gt; - скаляр.</target>
        </trans-unit>
        <trans-unit id="a2c63fcb50ab2a66bb9a9ad01ce9f4ff69c1d271" translate="yes" xml:space="preserve">
          <source>The corresponding angle in radians. This is a scalar if &lt;code&gt;x&lt;/code&gt; is a scalar.</source>
          <target state="translated">Соответствующий угол в радианах. Это скаляр, если &lt;code&gt;x&lt;/code&gt; - скаляр.</target>
        </trans-unit>
        <trans-unit id="1f2189e088542b025710d6c9de389530dc9fecea" translate="yes" xml:space="preserve">
          <source>The corresponding argument is a function provided by user. The signature of this so-called call-back function can be defined</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f35b3b067b2fb40c400d505d2d253ac20a239da1" translate="yes" xml:space="preserve">
          <source>The corresponding argument is considered as a required one. This is default. You need to specify &lt;code&gt;required&lt;/code&gt; only if there is a need to disable automatic &lt;code&gt;optional&lt;/code&gt; setting when &lt;code&gt;&amp;lt;init_expr&amp;gt;&lt;/code&gt; is used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b483a77dd25e17d676f790b212de11141a0187e" translate="yes" xml:space="preserve">
          <source>The corresponding argument is moved to the end of &lt;code&gt;&amp;lt;optional
arguments&amp;gt;&lt;/code&gt; list. A default value for an optional argument can be specified &lt;code&gt;&amp;lt;init_expr&amp;gt;&lt;/code&gt;, see &lt;code&gt;entitydecl&lt;/code&gt; definition. Note that the default value must be given as a valid C expression.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1050e106455b1ea647f4b0ec3bf8ddb674675631" translate="yes" xml:space="preserve">
          <source>The corresponding array scalar type is &lt;a href=&quot;arrays.scalars#numpy.int32&quot;&gt;&lt;code&gt;int32&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c2babda63010514076aef395fac45645683b9564" translate="yes" xml:space="preserve">
          <source>The corresponding array scalar type is &lt;code&gt;int32&lt;/code&gt;.</source>
          <target state="translated">Соответствующий скалярный тип массива - &lt;code&gt;int32&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cd11fa4205dd5b33a3e2b183413534954599bad7" translate="yes" xml:space="preserve">
          <source>The corresponding cosine values. This is a scalar if &lt;code&gt;x&lt;/code&gt; is a scalar.</source>
          <target state="translated">Соответствующие значения косинуса. Это скаляр, если &lt;code&gt;x&lt;/code&gt; - скаляр.</target>
        </trans-unit>
        <trans-unit id="6d98f6605847a59a64fcad02a0b3d4fdfd44ca3d" translate="yes" xml:space="preserve">
          <source>The corresponding degree values; if &lt;code&gt;out&lt;/code&gt; was supplied this is a reference to it. This is a scalar if &lt;code&gt;x&lt;/code&gt; is a scalar.</source>
          <target state="translated">Соответствующие значения в градусах; если был поставлен &lt;code&gt;out&lt;/code&gt; , это ссылка на него. Это скаляр, если &lt;code&gt;x&lt;/code&gt; - скаляр.</target>
        </trans-unit>
        <trans-unit id="2584010810109879710934f24451582df80fa088" translate="yes" xml:space="preserve">
          <source>The corresponding hyperbolic sine values. This is a scalar if &lt;code&gt;x&lt;/code&gt; is a scalar.</source>
          <target state="translated">Соответствующие значения гиперболического синуса. Это скаляр, если &lt;code&gt;x&lt;/code&gt; - скаляр.</target>
        </trans-unit>
        <trans-unit id="2f46b05f80b785698faf42d321e3104fa7625e8a" translate="yes" xml:space="preserve">
          <source>The corresponding hyperbolic tangent values. This is a scalar if &lt;code&gt;x&lt;/code&gt; is a scalar.</source>
          <target state="translated">Соответствующие значения гиперболического тангенса. Это скаляр, если &lt;code&gt;x&lt;/code&gt; - скаляр.</target>
        </trans-unit>
        <trans-unit id="d9ca95035c9f509708b9e99487c1ebe9e3ab11bd" translate="yes" xml:space="preserve">
          <source>The corresponding radian values. This is a scalar if &lt;code&gt;x&lt;/code&gt; is a scalar.</source>
          <target state="translated">Соответствующие значения в радианах. Это скаляр, если &lt;code&gt;x&lt;/code&gt; - скаляр.</target>
        </trans-unit>
        <trans-unit id="c1e4a7360c69977ad10edc5bee560d5ac06dcf90" translate="yes" xml:space="preserve">
          <source>The corresponding tangent values. This is a scalar if &lt;code&gt;x&lt;/code&gt; is a scalar.</source>
          <target state="translated">Соответствующие значения касательных. Это скаляр, если &lt;code&gt;x&lt;/code&gt; - скаляр.</target>
        </trans-unit>
        <trans-unit id="794da0dacd34a3a537b8957b7fa2b5dd6a0fb954" translate="yes" xml:space="preserve">
          <source>The corresponding user-provided Python function are then:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b0e664cdf4ef8fa1adefc68661d3976d497abf20" translate="yes" xml:space="preserve">
          <source>The corresponding variable is Fortran 90 allocatable array defined as Fortran 90 module data.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="48e42f957c48b62c124f0261112a23bae77caa2c" translate="yes" xml:space="preserve">
          <source>The corresponding variable is a parameter and it must have a fixed value. F2PY replaces all parameter occurrences by their corresponding values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c2320966ba7c65e57cb9263bdefeef1fa1cb2d7e" translate="yes" xml:space="preserve">
          <source>The corresponding variable is considered as an array with given dimensions in &lt;code&gt;&amp;lt;arrayspec&amp;gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f1763b6e0e62ea8d29f68696fab1bd4ea96474d4" translate="yes" xml:space="preserve">
          <source>The cost for a matrix multiplication can be calculated with the following function:</source>
          <target state="translated">Стоимость умножения матриц можно рассчитать с помощью следующей функции:</target>
        </trans-unit>
        <trans-unit id="6933bada15117031adec212786a3dbdf77a91aff" translate="yes" xml:space="preserve">
          <source>The costs for the two different parenthesizations are as follows:</source>
          <target state="translated">Расходы по двум различным скобкам приведены ниже:</target>
        </trans-unit>
        <trans-unit id="71417050531966fa2bba7739241abcc4b67310e0" translate="yes" xml:space="preserve">
          <source>The counterclockwise angle from the positive real axis on the complex plane in the range &lt;code&gt;(-pi, pi]&lt;/code&gt;, with dtype as numpy.float64.</source>
          <target state="translated">Угол против часовой стрелки от положительной действительной оси на комплексной плоскости в диапазоне &lt;code&gt;(-pi, pi]&lt;/code&gt; , с dtype как numpy.float64.</target>
        </trans-unit>
        <trans-unit id="1b6aacea9be65b883730cfcba5386d3d1b9a0223" translate="yes" xml:space="preserve">
          <source>The cov input is used to compute a factor matrix A such that &lt;code&gt;A @ A.T = cov&lt;/code&gt;. This argument is used to select the method used to compute the factor matrix A. The default method &amp;lsquo;svd&amp;rsquo; is the slowest, while &amp;lsquo;cholesky&amp;rsquo; is the fastest but less robust than the slowest method. The method &lt;code&gt;eigh&lt;/code&gt; uses eigen decomposition to compute A and is faster than svd but slower than cholesky.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="703b92f1857fec3346f55e95a27ed079fdf918ac" translate="yes" xml:space="preserve">
          <source>The covariance matrix of the variables.</source>
          <target state="translated">Ковариационная матрица переменных.</target>
        </trans-unit>
        <trans-unit id="f56bfc3801b5981a49e90ddd94a5011933b03e11" translate="yes" xml:space="preserve">
          <source>The cross product of &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; in</source>
          <target state="translated">Перекрестное произведение &lt;code&gt;a&lt;/code&gt; и &lt;code&gt;b&lt;/code&gt; в</target>
        </trans-unit>
        <trans-unit id="430c46a913654deeda9ef3928a00e710ee9f7b73" translate="yes" xml:space="preserve">
          <source>The ctypes attribute of an ndarray is also endowed with additional attributes that may be convenient when passing additional information about the array into a ctypes function. The attributes &lt;strong&gt;data&lt;/strong&gt;, &lt;strong&gt;shape&lt;/strong&gt;, and &lt;strong&gt;strides&lt;/strong&gt; can provide ctypes compatible types corresponding to the data-area, the shape, and the strides of the array. The data attribute returns a &lt;code&gt;c_void_p&lt;/code&gt; representing a pointer to the data area. The shape and strides attributes each return an array of ctypes integers (or None representing a NULL pointer, if a 0-d array). The base ctype of the array is a ctype integer of the same size as a pointer on the platform. There are also methods &lt;code&gt;data_as({ctype})&lt;/code&gt;, &lt;code&gt;shape_as(&amp;lt;base ctype&amp;gt;)&lt;/code&gt;, and &lt;code&gt;strides_as(&amp;lt;base
ctype&amp;gt;)&lt;/code&gt;. These return the data as a ctype object of your choice and the shape/strides arrays using an underlying base type of your choice. For convenience, the &lt;code&gt;ctypeslib&lt;/code&gt; module also contains &lt;code&gt;c_intp&lt;/code&gt; as a ctypes integer data-type whose size is the same as the size of &lt;code&gt;c_void_p&lt;/code&gt; on the platform (its value is None if ctypes is not installed).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d70737d8a9b599cea578eef90e469f4ec5cade8d" translate="yes" xml:space="preserve">
          <source>The cumulative product for each column (i.e., over the rows) of &lt;code&gt;a&lt;/code&gt;:</source>
          <target state="translated">Кумулятивная продукт для каждого столбца (т.е. по строкам) из : &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4974aaba8d216c55c50471b0bc56ddd6323d0ebc" translate="yes" xml:space="preserve">
          <source>The cumulative product for each row (i.e. over the columns) of &lt;code&gt;a&lt;/code&gt;:</source>
          <target state="translated">Кумулятивная продукт для каждой строки (т.е. по столбцам) из : &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="50631d91282d5f6763c8dcfd14a90d74339342d9" translate="yes" xml:space="preserve">
          <source>The current (1-d) index into the broadcasted result.</source>
          <target state="translated">Текущий (1-d)индекс в транслируемом результате.</target>
        </trans-unit>
        <trans-unit id="8c233acaa927b0b3ae6437f9077a3fae3621ed5f" translate="yes" xml:space="preserve">
          <source>The current 1-d index into the array.</source>
          <target state="translated">Текущий 1-d индекс в массиве.</target>
        </trans-unit>
        <trans-unit id="2fbbd9d31a318df9bc191ffa89f350440a39a71f" translate="yes" xml:space="preserve">
          <source>The current Python interface to the &lt;code&gt;f2py&lt;/code&gt; module is not mature and may change in the future.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cbb3baf8a681bbb5337a5050d23b30de4d838c39" translate="yes" xml:space="preserve">
          <source>The current error handler. If no handler was set through &lt;a href=&quot;numpy.seterrcall#numpy.seterrcall&quot;&gt;&lt;code&gt;seterrcall&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;None&lt;/code&gt; is returned.</source>
          <target state="translated">Текущий обработчик ошибок. Если через &lt;a href=&quot;numpy.seterrcall#numpy.seterrcall&quot;&gt; &lt;code&gt;seterrcall&lt;/code&gt; &lt;/a&gt; не был установлен обработчик , возвращается &lt;code&gt;None&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="67a8fb2d19e8571c91416871498dce96f7ad1021" translate="yes" xml:space="preserve">
          <source>The current info on building and releasing NumPy and SciPy is scattered in several places. It should be summarized in one place, updated, and where necessary described in more detail. The sections below list all places where useful info can be found.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fcd1e82b97c62204928be3c1426e12c2f8f2093c" translate="yes" xml:space="preserve">
          <source>The current interface remains unchanged, and &lt;code&gt;PyUFunc_FromFuncAndData&lt;/code&gt; can still be used to implement (specialized) ufuncs, consisting of scalar elementary functions.</source>
          <target state="translated">Текущий интерфейс остается неизменным, и &lt;code&gt;PyUFunc_FromFuncAndData&lt;/code&gt; все еще может использоваться для реализации (специализированных) u-функций, состоящих из скалярных элементарных функций.</target>
        </trans-unit>
        <trans-unit id="0ec2778c22d5d6f2fae8e55f79998855331eeed7" translate="yes" xml:space="preserve">
          <source>The current membership of the NumFOCUS Subcommittee is listed at the page &lt;a href=&quot;people#governance-people&quot;&gt;Current steering council and institutional partners&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ddf5c702a9dae519e990225b8843e9d50a71303" translate="yes" xml:space="preserve">
          <source>The current version of the C-API.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c61490656f67eede266b093f71fb6862a43e638d" translate="yes" xml:space="preserve">
          <source>The current version of the ndarray object (check to see if this variable is defined to guarantee the &lt;code&gt;numpy/arrayobject.h&lt;/code&gt; header is being used).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4809e84f7d3a9eb68e3d6e9384c7ac43b19e108c" translate="yes" xml:space="preserve">
          <source>The current version of the ndarray object (check to see if this variable is defined to guarantee the numpy/arrayobject.h header is being used).</source>
          <target state="translated">Текущая версия объекта ndarray (проверьте,определена ли эта переменная,чтобы гарантировать использование заголовка numpy/arrayobject.h).</target>
        </trans-unit>
        <trans-unit id="5a1853977173afb941f37a0bea064ac890d366c2" translate="yes" xml:space="preserve">
          <source>The data actually stored in object arrays (&lt;em&gt;i.e.&lt;/em&gt;, arrays having dtype &lt;a href=&quot;#numpy.object_&quot;&gt;&lt;code&gt;object_&lt;/code&gt;&lt;/a&gt;) are references to Python objects, not the objects themselves. Hence, object arrays behave more like usual Python &lt;a href=&quot;https://docs.python.org/dev/library/stdtypes.html#list&quot;&gt;&lt;code&gt;lists&lt;/code&gt;&lt;/a&gt;, in the sense that their contents need not be of the same Python type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d02692cc2b9183733a0e1ac33e907e722f2cb651" translate="yes" xml:space="preserve">
          <source>The data actually stored in object arrays (&lt;em&gt;i.e.&lt;/em&gt;, arrays having dtype &lt;code&gt;object_&lt;/code&gt;) are references to Python objects, not the objects themselves. Hence, object arrays behave more like usual Python &lt;a href=&quot;https://docs.python.org/dev/library/stdtypes.html#list&quot;&gt;&lt;code&gt;lists&lt;/code&gt;&lt;/a&gt;, in the sense that their contents need not be of the same Python type.</source>
          <target state="translated">Данные, фактически хранящиеся в массивах объектов ( &lt;em&gt;т.&lt;/em&gt; Е. В массивах с dtype &lt;code&gt;object_&lt;/code&gt; ), являются ссылками на объекты Python, а не сами объекты. Следовательно, массивы объектов ведут себя больше как обычные &lt;a href=&quot;https://docs.python.org/dev/library/stdtypes.html#list&quot;&gt; &lt;code&gt;lists&lt;/code&gt; &lt;/a&gt; Python в том смысле, что их содержимое не обязательно должно быть одного типа Python.</target>
        </trans-unit>
        <trans-unit id="2b8f4fa1516918fd8297afcfb360ffa13708823d" translate="yes" xml:space="preserve">
          <source>The data and all elements are aligned appropriately for the hardware.</source>
          <target state="translated">Данные и все элементы выровнены в соответствии с аппаратным обеспечением.</target>
        </trans-unit>
        <trans-unit id="3286aa81b485c3d7add58cb76776a5c44fcb4bf2" translate="yes" xml:space="preserve">
          <source>The data area and all array elements are aligned appropriately.</source>
          <target state="translated">Область данных и все элементы массива выровнены соответствующим образом.</target>
        </trans-unit>
        <trans-unit id="c1365a86184a90bddcccd2199d804c180d307014" translate="yes" xml:space="preserve">
          <source>The data area can be written to.</source>
          <target state="translated">Область данных может быть записана в.</target>
        </trans-unit>
        <trans-unit id="539587e7a7889df8e80a73151cc3ac06f87c111c" translate="yes" xml:space="preserve">
          <source>The data area can be written to. Setting this to False locks the data, making it read-only. A view (slice, etc.) inherits WRITEABLE from its base array at creation time, but a view of a writeable array may be subsequently locked while the base array remains writeable. (The opposite is not true, in that a view of a locked array may not be made writeable. However, currently, locking a base object does not lock any views that already reference it, so under that circumstance it is possible to alter the contents of a locked array via a previously created writeable view onto it.) Attempting to change a non-writeable array raises a RuntimeError exception.</source>
          <target state="translated">Область данных может быть записана в.Установка False блокирует данные,делая их доступными только для чтения.Вид (срез и т.д.)наследует WRITEABLE от своего базового массива на момент создания,но вид массива,доступного для записи,может быть впоследствии заблокирован,в то время как базовый массив остается доступным для записи.(Обратное не верно,так как вид заблокированного массива может быть не доступен для записи.Однако в настоящее время блокировка базового объекта не блокирует уже ссылающиеся на него виды,поэтому в этом случае можно изменить содержимое заблокированного массива с помощью ранее созданного вида массива,доступного для записи).При попытке изменить массив,не подлежащий записи,возникает исключение RuntimeError.</target>
        </trans-unit>
        <trans-unit id="dfe7ced9a654feaf927f01f408558bf43f63134c" translate="yes" xml:space="preserve">
          <source>The data area is in C-style contiguous order (last index varies the fastest).</source>
          <target state="translated">Область данных находится в непрерывном порядке в стиле С (последний индекс изменяется быстрее всего).</target>
        </trans-unit>
        <trans-unit id="28271e4f2d83215b5c3293be14583eebd0638934" translate="yes" xml:space="preserve">
          <source>The data area is in Fortran-style contiguous order (first index varies the fastest).</source>
          <target state="translated">Область данных находится в непрерывном порядке в стиле Фортран (первый индекс изменяется быстрее всего).</target>
        </trans-unit>
        <trans-unit id="a2e621a0b9254b737a1faf535f1456a6f33c01ae" translate="yes" xml:space="preserve">
          <source>The data area is owned by this array.</source>
          <target state="translated">Область данных принадлежит этому массиву.</target>
        </trans-unit>
        <trans-unit id="ca9e054ad351441ecdb18cea4952500858e11b12" translate="yes" xml:space="preserve">
          <source>The data area represents a (well-behaved) copy whose information should be transferred back to the original when &lt;a href=&quot;#c.PyArray_ResolveWritebackIfCopy&quot;&gt;&lt;code&gt;PyArray_ResolveWritebackIfCopy&lt;/code&gt;&lt;/a&gt; is called.</source>
          <target state="translated">Область данных представляет собой (корректную) копию, информация которой должна быть передана обратно в оригинал при &lt;a href=&quot;#c.PyArray_ResolveWritebackIfCopy&quot;&gt; &lt;code&gt;PyArray_ResolveWritebackIfCopy&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ffc8a46da91112c07e5b1f8d0c8b1ad0c0413487" translate="yes" xml:space="preserve">
          <source>The data file contains data of different types and is organized as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="15eb3cf2a1c1abdf07a79e9fe9ea7b5a63c62afd" translate="yes" xml:space="preserve">
          <source>The data in the array is returned as a single string. This function is similar to &lt;a href=&quot;numpy.array_repr#numpy.array_repr&quot;&gt;&lt;code&gt;array_repr&lt;/code&gt;&lt;/a&gt;, the difference being that &lt;a href=&quot;numpy.array_repr#numpy.array_repr&quot;&gt;&lt;code&gt;array_repr&lt;/code&gt;&lt;/a&gt; also returns information on the kind of array and its data type.</source>
          <target state="translated">Данные в массиве возвращаются в виде одной строки. Эта функция похожа на &lt;a href=&quot;numpy.array_repr#numpy.array_repr&quot;&gt; &lt;code&gt;array_repr&lt;/code&gt; &lt;/a&gt; , с той разницей, что &lt;a href=&quot;numpy.array_repr#numpy.array_repr&quot;&gt; &lt;code&gt;array_repr&lt;/code&gt; &lt;/a&gt; также возвращает информацию о типе массива и его типе данных.</target>
        </trans-unit>
        <trans-unit id="4cbbe8ca710f692f60ad1bfe0fc2af00b27f6fa9" translate="yes" xml:space="preserve">
          <source>The data in the same field can be heterogeneous, they will be promoted to the highest data type. This method is intended for creating smaller record arrays. If used to create large array without formats defined</source>
          <target state="translated">Данные в одной и той же области могут быть неоднородными,они будут продвигаться к самому высокому типу данных.Этот метод предназначен для создания массивов записей меньшего размера.Если используется для создания больших массивов без заданных форматов</target>
        </trans-unit>
        <trans-unit id="f030fb38724d73d189a884d6cd4eaca4e1c69e90" translate="yes" xml:space="preserve">
          <source>The data is in a single, C-style contiguous segment.</source>
          <target state="translated">Данные находятся в одном смежном сегменте в стиле С.</target>
        </trans-unit>
        <trans-unit id="5f1d8da4b437441472e9916d9ae01c496d02e5d4" translate="yes" xml:space="preserve">
          <source>The data is in a single, Fortran-style contiguous segment.</source>
          <target state="translated">Данные находятся в одном смежном сегменте в стиле Фортран.</target>
        </trans-unit>
        <trans-unit id="56a1a480524e7bf67ab594cb10c3c6101b00713c" translate="yes" xml:space="preserve">
          <source>The data of the resulting array will not be byteswapped, but will be interpreted correctly.</source>
          <target state="translated">Данные результирующего массива не будут заменяться байтами,а будут корректно интерпретированы.</target>
        </trans-unit>
        <trans-unit id="b88d2dbaff9987ad87362817ef4a120d93a6244e" translate="yes" xml:space="preserve">
          <source>The data to be histogrammed.</source>
          <target state="translated">Данные для гистограммирования.</target>
        </trans-unit>
        <trans-unit id="5386b778229b14d65914edc6d972b4efb28b5001" translate="yes" xml:space="preserve">
          <source>The data type object associated with the array can be found in the &lt;a href=&quot;generated/numpy.ndarray.dtype#numpy.ndarray.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt; attribute:</source>
          <target state="translated">Объект типа данных, связанный с массивом, можно найти в &lt;a href=&quot;generated/numpy.ndarray.dtype#numpy.ndarray.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="1c7886ffa6332318e280aa7625497d4df1ee7f24" translate="yes" xml:space="preserve">
          <source>The data type of &lt;code&gt;rep&lt;/code&gt;.</source>
          <target state="translated">Тип данных &lt;code&gt;rep&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4b822d3fbc39f811ebad48ba4194f76d214d3123" translate="yes" xml:space="preserve">
          <source>The data type of an operand with this flag should be either &lt;a href=&quot;c-api.dtype#c.NPY_BOOL&quot;&gt;&lt;code&gt;NPY_BOOL&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;c-api.dtype#c.NPY_MASK&quot;&gt;&lt;code&gt;NPY_MASK&lt;/code&gt;&lt;/a&gt;, or a struct dtype whose fields are all valid mask dtypes. In the latter case, it must match up with a struct operand being WRITEMASKED, as it is specifying a mask for each field of that array.</source>
          <target state="translated">Тип данных операнда с этим флагом должен быть &lt;a href=&quot;c-api.dtype#c.NPY_BOOL&quot;&gt; &lt;code&gt;NPY_BOOL&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;c-api.dtype#c.NPY_MASK&quot;&gt; &lt;code&gt;NPY_MASK&lt;/code&gt; &lt;/a&gt; или struct dtype, все поля которой являются допустимыми dtypes маски. В последнем случае он должен совпадать с операндом структуры WRITEMASKED, поскольку он определяет маску для каждого поля этого массива.</target>
        </trans-unit>
        <trans-unit id="ba40ae5f60c6c9bf8317272fcf427a71c0e5f01a" translate="yes" xml:space="preserve">
          <source>The data type of an operand with this flag should be either &lt;a href=&quot;dtype#c.NPY_BOOL&quot;&gt;&lt;code&gt;NPY_BOOL&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;dtype#c.NPY_MASK&quot;&gt;&lt;code&gt;NPY_MASK&lt;/code&gt;&lt;/a&gt;, or a struct dtype whose fields are all valid mask dtypes. In the latter case, it must match up with a struct operand being WRITEMASKED, as it is specifying a mask for each field of that array.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7bb62a4898d6e5e76b1d210de9cba3c87352d927" translate="yes" xml:space="preserve">
          <source>The data type of the array if we are creating a new file in &amp;ldquo;write&amp;rdquo; mode, if not, &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt; is ignored. The default value is None, which results in a data-type of &lt;a href=&quot;../arrays.scalars#numpy.float64&quot;&gt;&lt;code&gt;float64&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="11db59fda83e28216c250b45f855268127882d3e" translate="yes" xml:space="preserve">
          <source>The data type of the array; default: float. For binary input data, the data must be in exactly this format.</source>
          <target state="translated">Тип данных массива;по умолчанию:float.Для двоичных входных данных данные должны быть именно в этом формате.</target>
        </trans-unit>
        <trans-unit id="7ef4dd0c7cf28c23f4cb2015d84e3c63ca538a1e" translate="yes" xml:space="preserve">
          <source>The data type of the array; default: float. For binary input data, the data must be in exactly this format. Most builtin numeric types are supported and extension types may be supported.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6121c8d9cd39c4f61e9ffef0d098e3b7d36639d6" translate="yes" xml:space="preserve">
          <source>The data type of the output of &lt;code&gt;vectorized&lt;/code&gt; is determined by calling the function with the first element of the input. This can be avoided by specifying the &lt;code&gt;otypes&lt;/code&gt; argument.</source>
          <target state="translated">Тип данных вывода &lt;code&gt;vectorized&lt;/code&gt; определяется путем вызова функции с первым элементом ввода. Этого можно избежать, указав аргумент &lt;code&gt;otypes&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bc2814a7f847db35d30b7458174ec64d03a7e7a5" translate="yes" xml:space="preserve">
          <source>The data type of the view. The dtype size of the view can not be larger than that of the array itself.</source>
          <target state="translated">Тип данных представления.Размер d-типа представления не может быть больше,чем размер самого массива.</target>
        </trans-unit>
        <trans-unit id="99643c3f7e25f9a00992f90ee5d0bdd7cb79f63e" translate="yes" xml:space="preserve">
          <source>The data types of the values provided in &lt;a href=&quot;numpy.nditer.value#numpy.nditer.value&quot;&gt;&lt;code&gt;value&lt;/code&gt;&lt;/a&gt;. This may be different from the operand data types if buffering is enabled. Valid only before the iterator is closed.</source>
          <target state="translated">Типы данных значений, представленных в &lt;a href=&quot;numpy.nditer.value#numpy.nditer.value&quot;&gt; &lt;code&gt;value&lt;/code&gt; &lt;/a&gt; . Они могут отличаться от типов данных операндов, если буферизация включена. Действует только до закрытия итератора.</target>
        </trans-unit>
        <trans-unit id="9d016fef105a6db00651ac782a1c7e9c999e6600" translate="yes" xml:space="preserve">
          <source>The data-type is an important abstraction of the ndarray. Operations will look to the data-type to provide the key functionality that is needed to operate on the array. This functionality is provided in the list of function pointers pointed to by the &amp;lsquo;f&amp;rsquo; member of the &lt;a href=&quot;c-api.types-and-structures#c.PyArray_Descr&quot;&gt;&lt;code&gt;PyArray_Descr&lt;/code&gt;&lt;/a&gt; structure. In this way, the number of data-types can be extended simply by providing a &lt;a href=&quot;c-api.types-and-structures#c.PyArray_Descr&quot;&gt;&lt;code&gt;PyArray_Descr&lt;/code&gt;&lt;/a&gt; structure with suitable function pointers in the &amp;lsquo;f&amp;rsquo; member. For built-in types there are some optimizations that by-pass this mechanism, but the point of the data- type abstraction is to allow new data-types to be added.</source>
          <target state="translated">Тип данных - важная абстракция ndarray. Операции будут обращать внимание на тип данных, чтобы обеспечить ключевые функции, необходимые для работы с массивом. Эта функциональность предоставляется в списке указателей функций, на которые указывает член 'f' структуры &lt;a href=&quot;c-api.types-and-structures#c.PyArray_Descr&quot;&gt; &lt;code&gt;PyArray_Descr&lt;/code&gt; &lt;/a&gt; . Таким образом, количество типов данных можно расширить, просто предоставив структуру &lt;a href=&quot;c-api.types-and-structures#c.PyArray_Descr&quot;&gt; &lt;code&gt;PyArray_Descr&lt;/code&gt; &lt;/a&gt; с подходящими указателями на функции в члене 'f'. Для встроенных типов есть некоторые оптимизации, которые обходят этот механизм, но суть абстракции типов данных состоит в том, чтобы разрешить добавление новых типов данных.</target>
        </trans-unit>
        <trans-unit id="3bc7ca60ba414cbf4855ce7f1e99de3ef90f6929" translate="yes" xml:space="preserve">
          <source>The data-type is an important abstraction of the ndarray. Operations will look to the data-type to provide the key functionality that is needed to operate on the array. This functionality is provided in the list of function pointers pointed to by the &amp;lsquo;f&amp;rsquo; member of the &lt;a href=&quot;c-api/types-and-structures#c.PyArray_Descr&quot;&gt;&lt;code&gt;PyArray_Descr&lt;/code&gt;&lt;/a&gt; structure. In this way, the number of data-types can be extended simply by providing a &lt;a href=&quot;c-api/types-and-structures#c.PyArray_Descr&quot;&gt;&lt;code&gt;PyArray_Descr&lt;/code&gt;&lt;/a&gt; structure with suitable function pointers in the &amp;lsquo;f&amp;rsquo; member. For built-in types there are some optimizations that by-pass this mechanism, but the point of the data- type abstraction is to allow new data-types to be added.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b58fbdafeaa8107e58c408c096a3cb8ca5d659d7" translate="yes" xml:space="preserve">
          <source>The data-type of the returned array.</source>
          <target state="translated">Тип данных возвращаемого массива.</target>
        </trans-unit>
        <trans-unit id="2fa997f7f869fcd4a6074bb94b595bafa78357ab" translate="yes" xml:space="preserve">
          <source>The data-type used to interpret the file contents. Default is &lt;a href=&quot;../arrays.scalars#numpy.uint8&quot;&gt;&lt;code&gt;uint8&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c8d679fa5d2836b35d4e189ea3c3c42c4a9bfcc" translate="yes" xml:space="preserve">
          <source>The data-type used to interpret the file contents. Default is &lt;code&gt;uint8&lt;/code&gt;.</source>
          <target state="translated">Тип данных, используемый для интерпретации содержимого файла. По умолчанию &lt;code&gt;uint8&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e1e17b816f5aa8d3b539033dd4f8579bd040ce7c" translate="yes" xml:space="preserve">
          <source>The data-type used to represent the intermediate results. Defaults to the data-type of the output array if such is provided, or the the data-type of the input array if no output array is provided.</source>
          <target state="translated">Тип данных,используемый для представления промежуточных результатов.По умолчанию используется тип данных выходного массива,если он предоставляется,или тип данных входного массива,если выходной массив не предоставляется.</target>
        </trans-unit>
        <trans-unit id="932e882a29033e270334b0a0ca27c7a0b749d38c" translate="yes" xml:space="preserve">
          <source>The data-type-descriptor object of the base-type.</source>
          <target state="translated">Объект описания типа данных базового типа.</target>
        </trans-unit>
        <trans-unit id="4cbb5795026a8150753d0425fdbf885e8015baf4" translate="yes" xml:space="preserve">
          <source>The datatype describing the (identically typed) elements in an ndarray. It can be changed to reinterpret the array contents. For details, see &lt;a href=&quot;reference/arrays.dtypes&quot;&gt;Data type objects (dtype).&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d6987a7425e0ff97a8320c32ec6abc8ee62f4f4d" translate="yes" xml:space="preserve">
          <source>The datatype determines which of &amp;lsquo;mergesort&amp;rsquo; or &amp;lsquo;timsort&amp;rsquo; is actually used, even if &amp;lsquo;mergesort&amp;rsquo; is specified. User selection at a finer scale is not currently available.</source>
          <target state="translated">Тип данных определяет, какой из &amp;laquo;mergesort&amp;raquo; или &amp;laquo;timsort&amp;raquo; фактически используется, даже если &amp;laquo;mergesort&amp;raquo; указан. Выбор пользователя в более точном масштабе в настоящее время недоступен.</target>
        </trans-unit>
        <trans-unit id="f8494cadb009486b1d5ee5b6a13352cbf85e331c" translate="yes" xml:space="preserve">
          <source>The datetime API is &lt;em&gt;experimental&lt;/em&gt; in 1.7.0, and may undergo changes in future versions of NumPy.</source>
          <target state="translated">API datetime является &lt;em&gt;экспериментальным&lt;/em&gt; в версии 1.7.0 и может претерпеть изменения в будущих версиях NumPy.</target>
        </trans-unit>
        <trans-unit id="5a29e38fde2fbef6d304ea68f9f28e90e826577d" translate="yes" xml:space="preserve">
          <source>The datetime object represents a single moment in time. If two datetimes have different units, they may still be representing the same moment of time, and converting from a bigger unit like months to a smaller unit like days is considered a &amp;lsquo;safe&amp;rsquo; cast because the moment of time is still being represented exactly.</source>
          <target state="translated">Объект datetime представляет отдельный момент времени. Если два datetime имеют разные единицы, они могут по-прежнему представлять один и тот же момент времени, и преобразование большей единицы, такой как месяцы, в меньшую, например, дней, считается &amp;laquo;безопасным&amp;raquo; приведением, потому что момент времени по-прежнему отображается точно.</target>
        </trans-unit>
        <trans-unit id="96194d206533dca35ec887829a70fc8982e7d450" translate="yes" xml:space="preserve">
          <source>The datetime string parser in NumPy 1.6 is very liberal in what it accepts, and silently allows invalid input without raising errors. The parser in NumPy 1.7 is quite strict about only accepting ISO 8601 dates, with a few convenience extensions. 1.6 always creates microsecond (us) units by default, whereas 1.7 detects a unit based on the format of the string. Here is a comparison.:</source>
          <target state="translated">Парсер строк даты в NumPy 1.6 очень либеральный в том,что он принимает,и беззвучно допускает некорректный ввод,не вызывая ошибок.Парсер в NumPy 1.7 достаточно строг в том,чтобы принимать только даты ISO 8601,с несколькими удобными расширениями.1.6 по умолчанию всегда создает микросекундные (нам)единицы,в то время как 1.7 определяет единицу по формату строки.Вот сравнение:</target>
        </trans-unit>
        <trans-unit id="1369383d5a514fcfed8df04d6ed924de54d6f3b1" translate="yes" xml:space="preserve">
          <source>The datetime type works with many common NumPy functions, for example &lt;a href=&quot;generated/numpy.arange#numpy.arange&quot;&gt;&lt;code&gt;arange&lt;/code&gt;&lt;/a&gt; can be used to generate ranges of dates.</source>
          <target state="translated">Тип datetime работает со многими распространенными функциями NumPy, например, &lt;a href=&quot;generated/numpy.arange#numpy.arange&quot;&gt; &lt;code&gt;arange&lt;/code&gt; &lt;/a&gt; можно использовать для генерации диапазонов дат.</target>
        </trans-unit>
        <trans-unit id="60d7f83834880a987611358eebe758ac593dc7d2" translate="yes" xml:space="preserve">
          <source>The decomposition is performed using LAPACK routine &lt;code&gt;_gesdd&lt;/code&gt;.</source>
          <target state="translated">Декомпозиция выполняется с использованием подпрограммы LAPACK &lt;code&gt;_gesdd&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e1516fc7b62e4a0344208958aa595053689db869" translate="yes" xml:space="preserve">
          <source>The decorated test &lt;code&gt;t&lt;/code&gt;.</source>
          <target state="translated">Декорированный тест &lt;code&gt;t&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e9657b7f30a96eb6a9709525e36cff8e84658cbb" translate="yes" xml:space="preserve">
          <source>The decorator itself is decorated with the &lt;code&gt;nose.tools.make_decorator&lt;/code&gt; function in order to transmit function name, and various other metadata.</source>
          <target state="translated">Сам декоратор украшен функцией &lt;code&gt;nose.tools.make_decorator&lt;/code&gt; для передачи имени функции и различных других метаданных.</target>
        </trans-unit>
        <trans-unit id="4a37da8a9aa52a4088272dd54ccf6dae2a209ad8" translate="yes" xml:space="preserve">
          <source>The default &lt;code&gt;atol&lt;/code&gt; is not appropriate for comparing numbers that are much smaller than one (see Notes).</source>
          <target state="translated">&lt;code&gt;atol&lt;/code&gt; умолчанию не подходит для сравнения чисел, которые намного меньше единицы (см. Примечания).</target>
        </trans-unit>
        <trans-unit id="cb5293865f62263e0a19bbfa34c77f6486814f1d" translate="yes" xml:space="preserve">
          <source>The default __array_priority__ of matrix objects is 10.0, and therefore mixed operations with ndarrays always produce matrices.</source>
          <target state="translated">По умолчанию __приоритет_массивов_объектов матрицы равен 10.0,поэтому смешанные операции с ndarrays всегда приводят к появлению матриц.</target>
        </trans-unit>
        <trans-unit id="cd69cae26ca025156d4d72a557a24e650bb3e040" translate="yes" xml:space="preserve">
          <source>The default character, this is returned if none of the characters in &lt;code&gt;typechars&lt;/code&gt; matches a character in &lt;code&gt;typeset&lt;/code&gt;.</source>
          <target state="translated">По умолчанию символ, это возвращается , если ни один из персонажей &lt;code&gt;typechars&lt;/code&gt; не соответствует символ в &lt;code&gt;typeset&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f5464337fdab09809b32b82a7eac52309846c7ea" translate="yes" xml:space="preserve">
          <source>The default data type in NumPy is &lt;a href=&quot;#numpy.float_&quot;&gt;&lt;code&gt;float_&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
