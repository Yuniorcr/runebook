<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="numpy">
    <body>
      <group id="numpy">
        <trans-unit id="3e3af0fcef04d64e093680f90bd154da4da6f7e6" translate="yes" xml:space="preserve">
          <source>Drawn samples from the parameterized beta distribution.</source>
          <target state="translated">Нарисовали образцы из параметризованного бета-распределения.</target>
        </trans-unit>
        <trans-unit id="66aa1280d92bc58e93f2dd0657680e02202ddedc" translate="yes" xml:space="preserve">
          <source>Drawn samples from the parameterized binomial distribution, where each sample is equal to the number of successes over the n trials.</source>
          <target state="translated">Рисуйте образцы из параметризованного биномиального распределения,где каждый образец равен количеству успешных n испытаний.</target>
        </trans-unit>
        <trans-unit id="803cd0d20a6c49e0eab984068f59353e0ec6f797" translate="yes" xml:space="preserve">
          <source>Drawn samples from the parameterized chi-square distribution.</source>
          <target state="translated">Нарисуйте образцы из параметризованного распределения хи-квадрат.</target>
        </trans-unit>
        <trans-unit id="0a07d0ff0927ba822ed7f54576b179ec4780bfd4" translate="yes" xml:space="preserve">
          <source>Drawn samples from the parameterized exponential distribution.</source>
          <target state="translated">Нарисуйте образцы из параметризованного экспоненциального распределения.</target>
        </trans-unit>
        <trans-unit id="a2f28dab17c9ec69c1e4c0816e2b49d0d97cc8c9" translate="yes" xml:space="preserve">
          <source>Drawn samples from the parameterized gamma distribution.</source>
          <target state="translated">Нарисовали образцы из параметризованного гамма-распределения.</target>
        </trans-unit>
        <trans-unit id="645b194e18330c38a086d019ef409b1ad04a10ac" translate="yes" xml:space="preserve">
          <source>Drawn samples from the parameterized geometric distribution.</source>
          <target state="translated">Нарисуйте образцы из параметризованного геометрического распределения.</target>
        </trans-unit>
        <trans-unit id="675c1d8f69c01109a94a55f050b7feba6cfeb004" translate="yes" xml:space="preserve">
          <source>Drawn samples from the parameterized hypergeometric distribution. Each sample is the number of good items within a randomly selected subset of size &lt;code&gt;nsample&lt;/code&gt; taken from a set of &lt;code&gt;ngood&lt;/code&gt; good items and &lt;code&gt;nbad&lt;/code&gt; bad items.</source>
          <target state="translated">Нарисованы образцы из параметризованного гипергеометрического распределения. Каждый образец является количеством хороших элементов в случайно выбранном подмножестве размера &lt;code&gt;nsample&lt;/code&gt; , взятом из набора &lt;code&gt;ngood&lt;/code&gt; пунктов хороших и &lt;code&gt;nbad&lt;/code&gt; плохих элементов.</target>
        </trans-unit>
        <trans-unit id="0ec5fd25c15e2f401571dd2213b5e63981af1884" translate="yes" xml:space="preserve">
          <source>Drawn samples from the parameterized log-normal distribution.</source>
          <target state="translated">Рисуйте образцы из параметризованного лог-нормального распределения.</target>
        </trans-unit>
        <trans-unit id="92c1e4b50e7e0ed6389caf6bd275c9d96e903819" translate="yes" xml:space="preserve">
          <source>Drawn samples from the parameterized logarithmic series distribution.</source>
          <target state="translated">Рисуем образцы из параметризованного логарифмического распределения рядов.</target>
        </trans-unit>
        <trans-unit id="0418a31cc205f33ce6262d40794bf3e47add1b19" translate="yes" xml:space="preserve">
          <source>Drawn samples from the parameterized logistic distribution.</source>
          <target state="translated">Нарисуйте образцы из параметризованного логистического распределения.</target>
        </trans-unit>
        <trans-unit id="16ad062ab33ce9488dba4d726621ff0742f56c11" translate="yes" xml:space="preserve">
          <source>Drawn samples from the parameterized negative binomial distribution, where each sample is equal to N, the number of failures that occurred before a total of n successes was reached.</source>
          <target state="translated">Отрисовывались выборки из параметризованного отрицательного биномиального распределения,где каждая выборка равна N,количество неудач,которые имели место до достижения суммарного n успешных результатов.</target>
        </trans-unit>
        <trans-unit id="afe023dcddff604c4223693c51bcae1660f6eba8" translate="yes" xml:space="preserve">
          <source>Drawn samples from the parameterized noncentral Fisher distribution.</source>
          <target state="translated">Отрисовывайте образцы из параметризованного нецентрального распределения Фишера.</target>
        </trans-unit>
        <trans-unit id="0dad06577da3cf941b7346f737f68fc3b67c036b" translate="yes" xml:space="preserve">
          <source>Drawn samples from the parameterized noncentral chi-square distribution.</source>
          <target state="translated">Отбираются образцы из параметризованного нецентрального распределения хи-квадрат.</target>
        </trans-unit>
        <trans-unit id="1b7aa6be999ea249ca4e25e9eb3c5a161f178b65" translate="yes" xml:space="preserve">
          <source>Drawn samples from the parameterized normal distribution.</source>
          <target state="translated">Нарисуйте образцы из параметризованного нормального распределения.</target>
        </trans-unit>
        <trans-unit id="75a239b9fd8457ca43a81ea8883cb90f669b784d" translate="yes" xml:space="preserve">
          <source>Drawn samples from the parameterized power distribution.</source>
          <target state="translated">Нарисуйте образцы из параметризованного распределения мощности.</target>
        </trans-unit>
        <trans-unit id="417f5f8f2a7e8f51ee4be6e5ef1c8c34cc318b2f" translate="yes" xml:space="preserve">
          <source>Drawn samples from the parameterized standard Student&amp;rsquo;s t distribution.</source>
          <target state="translated">Нарисованные образцы из параметризованного стандартного t-распределения Стьюдента.</target>
        </trans-unit>
        <trans-unit id="9cfa7b49541ac131db1708e85662c20f82750d1b" translate="yes" xml:space="preserve">
          <source>Drawn samples from the parameterized standard gamma distribution.</source>
          <target state="translated">Отрисовываются образцы из параметризованного стандартного гамма-распределения.</target>
        </trans-unit>
        <trans-unit id="24c6b8b6588f6544b47569ada0a5521ca47031b8" translate="yes" xml:space="preserve">
          <source>Drawn samples from the parameterized triangular distribution.</source>
          <target state="translated">Нарисуйте образцы из параметризованного треугольного распределения.</target>
        </trans-unit>
        <trans-unit id="59ea0a59c91c46f3d89e817e79cad726c3dc2dab" translate="yes" xml:space="preserve">
          <source>Drawn samples from the parameterized uniform distribution.</source>
          <target state="translated">Нарисуйте образцы из параметризованного равномерного распределения.</target>
        </trans-unit>
        <trans-unit id="f20dd8e0ca9375ee4c56dd90351efacbd5b573d8" translate="yes" xml:space="preserve">
          <source>Drawn samples from the parameterized von Mises distribution.</source>
          <target state="translated">Нарисуйте образцы из параметризованного распределения фон Мизеса.</target>
        </trans-unit>
        <trans-unit id="cb8b86177c95587cf24b6f015131fe691b9fc3ba" translate="yes" xml:space="preserve">
          <source>Drawn samples.</source>
          <target state="translated">Нарисованные образцы.</target>
        </trans-unit>
        <trans-unit id="1d18cceebff607d37e9bf2c1387fbd956866a568" translate="yes" xml:space="preserve">
          <source>Draws samples in [0, 1] from a power distribution with positive exponent a - 1.</source>
          <target state="translated">Рисует образцы в [0,1]из распределения мощности с положительным экспонентом a-1.</target>
        </trans-unit>
        <trans-unit id="3494c64843d7663d424ff8535f672114cde4d98a" translate="yes" xml:space="preserve">
          <source>Dropped Support</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d056b5f5f0adde2e16d37463c52db860d944e35" translate="yes" xml:space="preserve">
          <source>Dtype for the structured array.</source>
          <target state="translated">D-тип для структурированного массива.</target>
        </trans-unit>
        <trans-unit id="74a25c41a58aa29ed3adc5f8de64d6df2cab73e9" translate="yes" xml:space="preserve">
          <source>Dtype parameter added to &lt;code&gt;np.linspace&lt;/code&gt; and &lt;code&gt;np.logspace&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="90ed446a6c6e03872b9c3414013b747e673d0a8f" translate="yes" xml:space="preserve">
          <source>Dtypes for structured arrays can be specified in several forms, but all forms specify at least the data type and field name. For details see &lt;a href=&quot;../../user/basics.rec#module-numpy.doc.structured_arrays&quot;&gt;&lt;code&gt;doc.structured_arrays&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c6259462846b5f9baee7053eaac196aa6133053" translate="yes" xml:space="preserve">
          <source>Dtypes for structured arrays can be specified in several forms, but all forms specify at least the data type and field name. For details see &lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/user/basics.rec.html#module-numpy.doc.structured_arrays&quot;&gt;&lt;code&gt;doc.structured_arrays&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Dtypes для структурированных массивов могут быть указаны в нескольких формах, но все формы определяют по крайней мере тип данных и имя поля. Подробнее см. &lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/user/basics.rec.html#module-numpy.doc.structured_arrays&quot;&gt; &lt;code&gt;doc.structured_arrays&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ffaaa2445408170b57b919ca6485e258a7c95d8b" translate="yes" xml:space="preserve">
          <source>Duda, R. O., Hart, P. E., and Stork, D. G., &amp;ldquo;Pattern Classification,&amp;rdquo; 2nd ed., New York: Wiley, 2001.</source>
          <target state="translated">Дуда, Р. О., Харт, П. Е. и Сторк, Д. Г., &amp;laquo;Классификация образцов&amp;raquo;, 2-е изд., Нью-Йорк: Wiley, 2001.</target>
        </trans-unit>
        <trans-unit id="6baaefd65351906a350ba168fbf221f0d184adfa" translate="yes" xml:space="preserve">
          <source>Due to floating point rounding the resulting array may not be Hermitian, the diagonal elements may not be 1, and the elements may not satisfy the inequality abs(a) &amp;lt;= 1. The real and imaginary parts are clipped to the interval [-1, 1] in an attempt to improve on that situation but is not much help in the complex case.</source>
          <target state="translated">Из-за округления с плавающей запятой результирующий массив может не быть эрмитовым, диагональные элементы не могут быть равны 1, а элементы могут не удовлетворять неравенству abs (a) &amp;lt;= 1. Действительная и мнимая части обрезаются до интервала [-1 , 1] в попытке улучшить эту ситуацию, но не очень помогает в сложном случае.</target>
        </trans-unit>
        <trans-unit id="d5668939217d0a50f3a990081bee30e034ec210d" translate="yes" xml:space="preserve">
          <source>Due to limitations in the interpretation of structured dtypes, dtypes with fields with empty names will have the names replaced by &amp;lsquo;f0&amp;rsquo;, &amp;lsquo;f1&amp;rsquo;, etc. Such arrays will not round-trip through the format entirely accurately. The data is intact; only the field names will differ. We are working on a fix for this. This fix will not require a change in the file format. The arrays with such structures can still be saved and restored, and the correct dtype may be restored by using the &lt;code&gt;loadedarray.view(correct_dtype)&lt;/code&gt; method.</source>
          <target state="translated">Из-за ограничений в интерпретации структурированных dtypes, dtypes с полями с пустыми именами будут иметь имена, замененные на 'f0', 'f1' и т. Д. Такие массивы не будут полностью точно проходить через формат. Данные не повреждены; будут отличаться только названия полей. Мы работаем над решением этой проблемы. Это исправление не потребует изменения формата файла. Массивы с такими структурами все еще можно сохранять и восстанавливать, а правильный тип dtype можно восстановить с помощью &lt;code&gt;loadedarray.view(correct_dtype)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="be47cf08679632a886113408bbed677d155a3d74" translate="yes" xml:space="preserve">
          <source>Dump a pickle of the array to the specified file.</source>
          <target state="translated">Выполните дамп маринования массива в указанный файл.</target>
        </trans-unit>
        <trans-unit id="c5317185019827371b1e31a396e0d441834d3252" translate="yes" xml:space="preserve">
          <source>Dump a pickle of the array to the specified file. The array can be read back with pickle.load or numpy.load.</source>
          <target state="translated">Выполните дамп маринования массива в указанный файл.Массив можно считать обратно с помощью pickle.load или numpy.load.</target>
        </trans-unit>
        <trans-unit id="7a2c1b02316fce9ee22b42f7f9087251340c710e" translate="yes" xml:space="preserve">
          <source>During iteration, you may want to use the index of the current element in a computation. For example, you may want to visit the elements of an array in memory order, but use a C-order, Fortran-order, or multidimensional index to look up values in a different array.</source>
          <target state="translated">Во время итерации можно использовать индекс текущего элемента в вычислениях.Например,вы можете захотеть посетить элементы массива в порядке памяти,но использовать C-порядок,Fortran-порядок или многомерный индекс для поиска значений в другом массиве.</target>
        </trans-unit>
        <trans-unit id="3bf08c964c7c95130d665e4d98704726bfb41a50" translate="yes" xml:space="preserve">
          <source>During the beta/RC phase, an explicit request for testing the binaries with several other libraries (SciPy/Matplotlib/Pygame) should be posted on the mailing list.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b260078602d9938ed8897f4dbe8eacdc7db28c29" translate="yes" xml:space="preserve">
          <source>During the everyday project activities, council members participate in all discussions, code review and other project activities as peers with all other Contributors and the Community. In these everyday activities, Council Members do not have any special power or privilege through their membership on the Council. However, it is expected that because of the quality and quantity of their contributions and their expert knowledge of the Project Software and Services that Council Members will provide useful guidance, both technical and in terms of project direction, to potentially less experienced contributors.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a97e818f2855e4e5e1bc73604c63d51f0dc4bf1" translate="yes" xml:space="preserve">
          <source>Durran D. R. (1999) Numerical Methods for Wave Equations in Geophysical Fluid Dynamics. New York: Springer.</source>
          <target state="translated">Дурран Д.Р.(1999)Численные методы волновых уравнений в геофизической динамике жидкостей.Нью-Йорк:Шпрингер.</target>
        </trans-unit>
        <trans-unit id="e0184adedf913b076626646d3f52c3b49c39ad6d" translate="yes" xml:space="preserve">
          <source>E</source>
          <target state="translated">E</target>
        </trans-unit>
        <trans-unit id="26aa5b06114619ee705d4e196e09408f75d82651" translate="yes" xml:space="preserve">
          <source>E.R. Kanasewich, &amp;ldquo;Time Sequence Analysis in Geophysics&amp;rdquo;, The University of Alberta Press, 1975, pp. 106-108.</source>
          <target state="translated">ER Kanasewich, &amp;laquo;Анализ временных последовательностей в геофизике&amp;raquo;, Издательство Университета Альберты, 1975, стр. 106-108.</target>
        </trans-unit>
        <trans-unit id="7020945b62676f3792048d52264e61eaf1f2f06e" translate="yes" xml:space="preserve">
          <source>E.R. Kanasewich, &amp;ldquo;Time Sequence Analysis in Geophysics&amp;rdquo;, The University of Alberta Press, 1975, pp. 109-110.</source>
          <target state="translated">ER Kanasewich, &amp;laquo;Анализ временных последовательностей в геофизике&amp;raquo;, Издательство Университета Альберты, 1975, стр. 109-110.</target>
        </trans-unit>
        <trans-unit id="3bd1ccd7ec68cbb9d222ef47028613ad14f66cf8" translate="yes" xml:space="preserve">
          <source>E.R. Kanasewich, &amp;ldquo;Time Sequence Analysis in Geophysics&amp;rdquo;, The University of Alberta Press, 1975, pp. 177-178.</source>
          <target state="translated">ER Kanasewich, &amp;laquo;Анализ временных последовательностей в геофизике&amp;raquo;, Издательство Университета Альберты, 1975, стр. 177-178.</target>
        </trans-unit>
        <trans-unit id="9282259a9bffd46a322a6acfc9997c91e019e7d4" translate="yes" xml:space="preserve">
          <source>Each &lt;a href=&quot;constants#numpy.newaxis&quot;&gt;&lt;code&gt;newaxis&lt;/code&gt;&lt;/a&gt; object in the selection tuple serves to expand the dimensions of the resulting selection by one unit-length dimension. The added dimension is the position of the &lt;a href=&quot;constants#numpy.newaxis&quot;&gt;&lt;code&gt;newaxis&lt;/code&gt;&lt;/a&gt; object in the selection tuple.</source>
          <target state="translated">Каждый объект &lt;a href=&quot;constants#numpy.newaxis&quot;&gt; &lt;code&gt;newaxis&lt;/code&gt; &lt;/a&gt; в кортеже выбора служит для увеличения размеров результирующего выделения на одно измерение единичной длины. Добавленное измерение - это позиция объекта &lt;a href=&quot;constants#numpy.newaxis&quot;&gt; &lt;code&gt;newaxis&lt;/code&gt; &lt;/a&gt; в выбранном кортеже.</target>
        </trans-unit>
        <trans-unit id="073efad576bf9e16c2944aef4f81bdac4eda711d" translate="yes" xml:space="preserve">
          <source>Each NumPy module exposes &lt;a href=&quot;#numpy.testing.Tester.bench&quot;&gt;&lt;code&gt;bench&lt;/code&gt;&lt;/a&gt; in its namespace to run all benchmarks for it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f2eda913d3072244fb087de35642a2b1eb54ff25" translate="yes" xml:space="preserve">
          <source>Each NumPy module exposes &lt;a href=&quot;#numpy.testing.Tester.test&quot;&gt;&lt;code&gt;test&lt;/code&gt;&lt;/a&gt; in its namespace to run all tests for it. For example, to run all tests for numpy.lib:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f76bc743577aee15d005972242975d93c3b7f843" translate="yes" xml:space="preserve">
          <source>Each array in the tuple has the same shape as the &lt;code&gt;indices&lt;/code&gt; array.</source>
          <target state="translated">Каждый массив в кортеже имеет ту же форму, что и массив &lt;code&gt;indices&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="386efca9f91ba00773f6c9bc7ed1232d730522e6" translate="yes" xml:space="preserve">
          <source>Each array must have the same shape.</source>
          <target state="translated">Каждый массив должен иметь одинаковую форму.</target>
        </trans-unit>
        <trans-unit id="286a71006dd39afde343b3c45a4fd98ff7cec30e" translate="yes" xml:space="preserve">
          <source>Each boolean array corresponds to a function in &lt;code&gt;funclist&lt;/code&gt;. Wherever &lt;code&gt;condlist[i]&lt;/code&gt; is True, &lt;code&gt;funclist[i](x)&lt;/code&gt; is used as the output value.</source>
          <target state="translated">Каждый логический массив соответствует функции в &lt;code&gt;funclist&lt;/code&gt; . Если &lt;code&gt;condlist[i]&lt;/code&gt; имеет значение True, &lt;code&gt;funclist[i](x)&lt;/code&gt; используется в качестве выходного значения.</target>
        </trans-unit>
        <trans-unit id="eef78733a1d1f7432ec1ab2af99217db7ce78c93" translate="yes" xml:space="preserve">
          <source>Each boolean array in &lt;code&gt;condlist&lt;/code&gt; selects a piece of &lt;code&gt;x&lt;/code&gt;, and should therefore be of the same shape as &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">Каждый логический массив в &lt;code&gt;condlist&lt;/code&gt; выбирает кусок &lt;code&gt;x&lt;/code&gt; и, следовательно, должен иметь ту же форму, что и &lt;code&gt;x&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8fe6ffb6ecffd6c39387e8f0ab0c3a109b7064bf" translate="yes" xml:space="preserve">
          <source>Each built-in data-type has a character code (the updated Numeric typecodes), that uniquely identifies it.</source>
          <target state="translated">Каждый встроенный тип данных имеет символьный код (обновленные Числовые шрифты),который однозначно идентифицирует его.</target>
        </trans-unit>
        <trans-unit id="a69a75e46ca3ac2d199e74b13f3b32f8dd1d6b80" translate="yes" xml:space="preserve">
          <source>Each differentiation is multiplied by &lt;code&gt;scl&lt;/code&gt;. The end result is multiplication by &lt;code&gt;scl**m&lt;/code&gt;. This is for use in a linear change of variable. (Default: 1)</source>
          <target state="translated">Каждая дифференциация умножается на &lt;code&gt;scl&lt;/code&gt; . Конечный результат - умножение на &lt;code&gt;scl**m&lt;/code&gt; . Это для использования при линейном изменении переменной. (По умолчанию: 1)</target>
        </trans-unit>
        <trans-unit id="80d6286823e7a8996b335e27ee039bd71682bf33" translate="yes" xml:space="preserve">
          <source>Each dimension in the signature is matched to a dimension of the corresponding passed-in array, starting from the end of the shape tuple.</source>
          <target state="translated">Каждое измерение в сигнатуре сопоставляется с измерением соответствующего переданного массива,начиная с конца кортежа фигуры.</target>
        </trans-unit>
        <trans-unit id="e3a7c87b9ea1dd98d592dea35e0511973a19c5ea" translate="yes" xml:space="preserve">
          <source>Each dimension in the signature is matched to a dimension of the corresponding passed-in array, starting from the end of the shape tuple. These are the core dimensions, and they must be present in the arrays, or an error will be raised.</source>
          <target state="translated">Каждое измерение в сигнатуре сопоставляется с измерением соответствующего переданного массива,начиная с конца кортежа фигуры.Это размеры ядра,и они должны присутствовать в массивах,иначе возникнет ошибка.</target>
        </trans-unit>
        <trans-unit id="f8fa7f34f98b652b735f9d41844bf81c524a5373" translate="yes" xml:space="preserve">
          <source>Each element of &lt;code&gt;a&lt;/code&gt; represents a bit-field that should be unpacked into a binary-valued output array. The shape of the output array is either 1-D (if &lt;code&gt;axis&lt;/code&gt; is &lt;code&gt;None&lt;/code&gt;) or the same shape as the input array with unpacking done along the axis specified.</source>
          <target state="translated">Каждый элемент &lt;code&gt;a&lt;/code&gt; представляет собой битовое поле, которое следует распаковать в выходной массив с двоичными значениями. Форма выходного массива является либо 1-D (если &lt;code&gt;axis&lt;/code&gt; не &lt;code&gt;None&lt;/code&gt; ) или ту же форму, что и входной массив с распаковкой сделано вдоль оси указанного.</target>
        </trans-unit>
        <trans-unit id="50237f597aa5c58319566769ed4e784a20d0c8c4" translate="yes" xml:space="preserve">
          <source>Each element of the sum of the &amp;lsquo;ipmt&amp;rsquo; and &amp;lsquo;ppmt&amp;rsquo; arrays should equal &amp;lsquo;pmt&amp;rsquo;.</source>
          <target state="translated">Каждый элемент суммы массивов ipmt и ppmt должен равняться pmt.</target>
        </trans-unit>
        <trans-unit id="20a2380f652b4d55cd4c96370ca8c7d2de50620c" translate="yes" xml:space="preserve">
          <source>Each entry in the mymethods array is a &lt;a href=&quot;https://docs.python.org/dev/c-api/structures.html#c.PyMethodDef&quot;&gt;&lt;code&gt;PyMethodDef&lt;/code&gt;&lt;/a&gt; structure containing 1) the Python name, 2) the C-function that implements the function, 3) flags indicating whether or not keywords are accepted for this function, and 4) The docstring for the function. Any number of functions may be defined for a single module by adding more entries to this table. The last entry must be all NULL as shown to act as a sentinel. Python looks for this entry to know that all of the functions for the module have been defined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f33bf09c046e31c2241219b2051cb5ec2d5021c" translate="yes" xml:space="preserve">
          <source>Each entry will be the default for the corresponding column</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6596e910451a16280ea499b967185410396fa721" translate="yes" xml:space="preserve">
          <source>Each function is evaluated over &lt;code&gt;x&lt;/code&gt; wherever its corresponding condition is True. It should take a 1d array as input and give an 1d array or a scalar value as output. If, instead of a callable, a scalar is provided then a constant function (&lt;code&gt;lambda x: scalar&lt;/code&gt;) is assumed.</source>
          <target state="translated">Каждая функция оценивается по &lt;code&gt;x&lt;/code&gt; , если соответствующее ей условие истинно. Он должен принимать 1d-массив на входе и выдавать 1d-массив или скалярное значение на выходе. Если вместо вызываемого объекта предоставляется скаляр, то предполагается постоянная функция ( &lt;code&gt;lambda x: scalar&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="8d8deda694e466984ce525e906c00ea4f5dea09d" translate="yes" xml:space="preserve">
          <source>Each generalized ufunc has information associated with it that states what the &amp;ldquo;core&amp;rdquo; dimensionality of the inputs is, as well as the corresponding dimensionality of the outputs (the element-wise ufuncs have zero core dimensions). The list of the core dimensions for all arguments is called the &amp;ldquo;signature&amp;rdquo; of a ufunc. For example, the ufunc numpy.add has signature &lt;code&gt;(),()-&amp;gt;()&lt;/code&gt; defining two scalar inputs and one scalar output.</source>
          <target state="translated">Каждый обобщенный ufunc имеет связанную с ним информацию, которая указывает, какова &amp;laquo;основная&amp;raquo; размерность входов, а также соответствующая размерность выходов (поэлементные ufunc имеют нулевую размерность ядра). Список основных измерений для всех аргументов называется &amp;laquo;сигнатурой&amp;raquo; ufunc. Например, ufunc numpy.add имеет подпись &lt;code&gt;(),()-&amp;gt;()&lt;/code&gt; , определяющую два скалярных входа и один скалярный выход.</target>
        </trans-unit>
        <trans-unit id="93ff2ff5db4665bc2536253e2cbc256cc6ee369b" translate="yes" xml:space="preserve">
          <source>Each item is used as an &amp;ldquo;op_axes&amp;rdquo; argument to an nditer</source>
          <target state="translated">Каждый элемент используется как аргумент &amp;laquo;op_axes&amp;raquo; для nditer.</target>
        </trans-unit>
        <trans-unit id="6515db7940afb238e42bf63e06ca75d53b616e9e" translate="yes" xml:space="preserve">
          <source>Each key can be a column index or a column name, and the corresponding value should be a single object. We can use the special key &lt;code&gt;None&lt;/code&gt; to define a default for all columns.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="83888ab60bad511e4b53bdc1db03bb5f1c808f79" translate="yes" xml:space="preserve">
          <source>Each line past the first &lt;code&gt;skip_header&lt;/code&gt; lines is split at the &lt;code&gt;delimiter&lt;/code&gt; character, and characters following the &lt;code&gt;comments&lt;/code&gt; character are discarded.</source>
          <target state="translated">Каждая строка после первых строк &lt;code&gt;skip_header&lt;/code&gt; разделяется символом- &lt;code&gt;delimiter&lt;/code&gt; , а символы, следующие за символом &lt;code&gt;comments&lt;/code&gt; , отбрасываются.</target>
        </trans-unit>
        <trans-unit id="af447abfb761a63b2a173a6fe4db497d82a1d986" translate="yes" xml:space="preserve">
          <source>Each module should have a docstring with at least a summary line. Other sections are optional, and should be used in the same order as for documenting functions when they are appropriate:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="13efd9029e94adb763eb953172be3877d35b0214" translate="yes" xml:space="preserve">
          <source>Each of the arithmetic operations (&lt;code&gt;+&lt;/code&gt;, &lt;code&gt;-&lt;/code&gt;, &lt;code&gt;*&lt;/code&gt;, &lt;code&gt;/&lt;/code&gt;, &lt;code&gt;//&lt;/code&gt;, &lt;code&gt;%&lt;/code&gt;, &lt;code&gt;divmod()&lt;/code&gt;, &lt;code&gt;**&lt;/code&gt; or &lt;code&gt;pow()&lt;/code&gt;, &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;amp;&lt;/code&gt;, &lt;code&gt;^&lt;/code&gt;, &lt;code&gt;|&lt;/code&gt;, &lt;code&gt;~&lt;/code&gt;) and the comparisons (&lt;code&gt;==&lt;/code&gt;, &lt;code&gt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;=&lt;/code&gt;, &lt;code&gt;&amp;gt;=&lt;/code&gt;, &lt;code&gt;!=&lt;/code&gt;) is equivalent to the corresponding universal function (or &lt;a href=&quot;../glossary#term-ufunc&quot;&gt;ufunc&lt;/a&gt; for short) in NumPy. For more information, see the section on &lt;a href=&quot;ufuncs#ufuncs&quot;&gt;Universal Functions&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3956c5acda082528edb0dd788f86e08b90ce29c7" translate="yes" xml:space="preserve">
          <source>Each of the arithmetic operations (&lt;code&gt;+&lt;/code&gt;, &lt;code&gt;-&lt;/code&gt;, &lt;code&gt;*&lt;/code&gt;, &lt;code&gt;/&lt;/code&gt;, &lt;code&gt;//&lt;/code&gt;, &lt;code&gt;%&lt;/code&gt;, &lt;code&gt;divmod()&lt;/code&gt;, &lt;code&gt;**&lt;/code&gt; or &lt;code&gt;pow()&lt;/code&gt;, &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;amp;&lt;/code&gt;, &lt;code&gt;^&lt;/code&gt;, &lt;code&gt;|&lt;/code&gt;, &lt;code&gt;~&lt;/code&gt;) and the comparisons (&lt;code&gt;==&lt;/code&gt;, &lt;code&gt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;=&lt;/code&gt;, &lt;code&gt;&amp;gt;=&lt;/code&gt;, &lt;code&gt;!=&lt;/code&gt;) is equivalent to the corresponding universal function (or &lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/glossary.html#term-ufunc&quot;&gt;ufunc&lt;/a&gt; for short) in NumPy. For more information, see the section on &lt;a href=&quot;ufuncs#ufuncs&quot;&gt;Universal Functions&lt;/a&gt;.</source>
          <target state="translated">Каждая из арифметических операций ( &lt;code&gt;+&lt;/code&gt; , &lt;code&gt;-&lt;/code&gt; , &lt;code&gt;*&lt;/code&gt; , &lt;code&gt;/&lt;/code&gt; , &lt;code&gt;//&lt;/code&gt; , &lt;code&gt;%&lt;/code&gt; , &lt;code&gt;divmod()&lt;/code&gt; , &lt;code&gt;**&lt;/code&gt; или &lt;code&gt;pow()&lt;/code&gt; , &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt; , &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;amp;&lt;/code&gt; , &lt;code&gt;^&lt;/code&gt; , &lt;code&gt;|&lt;/code&gt; , &lt;code&gt;~&lt;/code&gt; ) и сравнения ( &lt;code&gt;==&lt;/code&gt; , &lt;code&gt;&amp;lt;&lt;/code&gt; , &lt;code&gt;&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;=&lt;/code&gt; , &lt;code&gt;&amp;gt;=&lt;/code&gt; , &lt;code&gt;!=&lt;/code&gt; ) эквивалентно соответствующему универсальной функции (или &lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/glossary.html#term-ufunc&quot;&gt;ufunc&lt;/a&gt; для краткости) в NumPy. Для получения дополнительной информации см. Раздел&lt;a href=&quot;ufuncs#ufuncs&quot;&gt;Универсальные функции&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ce900752c03b63d004b95034fc7fe45e45781bb2" translate="yes" xml:space="preserve">
          <source>Each of these 12 classes is collected into a &lt;code&gt;unittest.TestSuite&lt;/code&gt;, which is then executed. Errors and failures are summed together and returned as the exit argument. Any non-zero result indicates that at least one test did not pass.</source>
          <target state="translated">Каждый из этих 12 классов собирается в &lt;code&gt;unittest.TestSuite&lt;/code&gt; , который затем выполняется. Ошибки и сбои суммируются и возвращаются в качестве аргумента выхода. Любой ненулевой результат означает, что хотя бы один тест не прошел.</target>
        </trans-unit>
        <trans-unit id="534d5807de7d2badcef1e7e804770614e9153a49" translate="yes" xml:space="preserve">
          <source>Each of these sub-topics is covered in the following sub-sections.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f67c4cfb6e2d44f4338462a5c73308f6ff60ab98" translate="yes" xml:space="preserve">
          <source>Each row in the text file must have the same number of values.</source>
          <target state="translated">Каждая строка в текстовом файле должна иметь одинаковое количество значений.</target>
        </trans-unit>
        <trans-unit id="8b09b89b09738ea85b440f6b9b0782f598ebe968" translate="yes" xml:space="preserve">
          <source>Each sequence should be of integer or boolean type. Boolean sequences will be interpreted as boolean masks for the corresponding dimension (equivalent to passing in &lt;code&gt;np.nonzero(boolean_sequence)&lt;/code&gt;).</source>
          <target state="translated">Каждая последовательность должна быть целочисленного или логического типа. Булевы последовательности будут интерпретироваться как логические маски для соответствующего измерения (эквивалентно передаче &lt;code&gt;np.nonzero(boolean_sequence)&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="b117b16ba13396092e447a51f24074ff2e6bd854" translate="yes" xml:space="preserve">
          <source>Each test defined by the &lt;code&gt;VectorTestCase&lt;/code&gt; class extracts the python function it is trying to test by accessing the &lt;code&gt;Vector&lt;/code&gt; module&amp;rsquo;s dictionary:</source>
          <target state="translated">Каждый тест, определенный классом &lt;code&gt;VectorTestCase&lt;/code&gt; , извлекает функцию python, которую он пытается проверить, обращаясь к словарю модуля &lt;code&gt;Vector&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="6083c3d38cbd0a21c59fda4f10850fe83ec68a22" translate="yes" xml:space="preserve">
          <source>Each tuple has the form &lt;code&gt;(fieldname, datatype, shape)&lt;/code&gt; where shape is optional. &lt;code&gt;fieldname&lt;/code&gt; is a string (or tuple if titles are used, see &lt;a href=&quot;#titles&quot;&gt;Field Titles&lt;/a&gt; below), &lt;code&gt;datatype&lt;/code&gt; may be any object convertible to a datatype, and &lt;code&gt;shape&lt;/code&gt; is a tuple of integers specifying subarray shape.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a7730362892427e71964e48c12006a9cf86055b3" translate="yes" xml:space="preserve">
          <source>Each ufunc consists of an elementary function that performs the most basic operation on the smallest portion of array arguments (e.g. adding two numbers is the most basic operation in adding two arrays). The ufunc applies the elementary function multiple times on different parts of the arrays. The input/output of elementary functions can be vectors; e.g., the elementary function of inner1d takes two vectors as input.</source>
          <target state="translated">Каждая ufunc состоит из элементарной функции,которая выполняет самую базовую операцию над наименьшим количеством аргументов массива (например,сложение двух чисел является самой базовой операцией при сложении двух массивов).ufunc многократно применяет элементарную функцию к различным частям массивов.Вход/выход элементарной функции может быть векторным;например,элементарная функция inner1d принимает на вход два вектора.</target>
        </trans-unit>
        <trans-unit id="cb1cf57d2ff93f75da1bd8ea2b2acd61c3fea8cd" translate="yes" xml:space="preserve">
          <source>Each universal function takes array inputs and produces array outputs by performing the core function element-wise on the inputs (where an element is generally a scalar, but can be a vector or higher-order sub-array for generalized ufuncs). Standard broadcasting rules are applied so that inputs not sharing exactly the same shapes can still be usefully operated on. Broadcasting can be understood by four rules:</source>
          <target state="translated">Каждая универсальная функция берет на себя входы в массив и производит на выходе массивы,выполняя на входах элемент ядра функции по элементам (где элемент,как правило,является скаляром,но может быть векторным или подмассивом более высокого порядка для обобщенных уфунков).Применяются стандартные правила вещания,так что на входах,не имеющих точно такой же формы,можно с пользой работать.Трансляцию можно понять по четырем правилам:</target>
        </trans-unit>
        <trans-unit id="778a8f870adb20070c9bbd4345579e90072a320d" translate="yes" xml:space="preserve">
          <source>Easier setup and teardown functions / methods</source>
          <target state="translated">Более простая настройка и функции/методы</target>
        </trans-unit>
        <trans-unit id="2797646a63f7af5bb42f88a4088468f8dc30c1ee" translate="yes" xml:space="preserve">
          <source>Edit pavement.py and setup.py as detailed in HOWTO_RELEASE:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2810e44da03a82e21b0a6385cc2c1eef5fd13ec6" translate="yes" xml:space="preserve">
          <source>Edit the &lt;code&gt;azure/posix.yml&lt;/code&gt; and &lt;code&gt;azure/windows.yml&lt;/code&gt; files to make sure they have the correct version, and put in the commit hash for the &lt;code&gt;REL&lt;/code&gt; commit created above for &lt;code&gt;BUILD_COMMIT&lt;/code&gt;, see an _example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c7e9fb2ea6c3b8c3ce97645eb902c348d859f36d" translate="yes" xml:space="preserve">
          <source>Editor</source>
          <target state="translated">Editor</target>
        </trans-unit>
        <trans-unit id="93d5c22f934ab8df1b20f8c3472b63bf839853fa" translate="yes" xml:space="preserve">
          <source>Effect of the &lt;a href=&quot;numpy.ma.copy#numpy.ma.copy&quot;&gt;&lt;code&gt;copy&lt;/code&gt;&lt;/a&gt; argument.</source>
          <target state="translated">Эффект аргумента &lt;a href=&quot;numpy.ma.copy#numpy.ma.copy&quot;&gt; &lt;code&gt;copy&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b16a3ec6ab9f466c4d89051f80bac7ab3d7a2dde" translate="yes" xml:space="preserve">
          <source>Effect of the &lt;code&gt;shrink&lt;/code&gt; parameter.</source>
          <target state="translated">Влияние параметра &lt;code&gt;shrink&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="15b4ace616414347d2dd3d2801314c174bc7ba08" translate="yes" xml:space="preserve">
          <source>Effectively, this implements:</source>
          <target state="translated">По сути,это орудие:</target>
        </trans-unit>
        <trans-unit id="76eeaec1ccfef9304ec0a31b036423f1378c5288" translate="yes" xml:space="preserve">
          <source>Efficient</source>
          <target state="translated">Efficient</target>
        </trans-unit>
        <trans-unit id="2b4d17c36c1ff28a27a4b2931f3e20dd1dbef5a2" translate="yes" xml:space="preserve">
          <source>Efficient multi-dimensional iterator object to iterate over arrays.</source>
          <target state="translated">Эффективный многомерный объект итератора для итераций по массивам.</target>
        </trans-unit>
        <trans-unit id="7e03cfade90e6c295c76156a8e2c563a63efa318" translate="yes" xml:space="preserve">
          <source>Efficient multi-dimensional iterator object to iterate over arrays. To get started using this object, see the &lt;a href=&quot;../arrays.nditer#arrays-nditer&quot;&gt;introductory guide to array iteration&lt;/a&gt;.</source>
          <target state="translated">Эффективный многомерный объект-итератор для перебора массивов. Чтобы начать использовать этот объект, см. &lt;a href=&quot;../arrays.nditer#arrays-nditer&quot;&gt;Вводное руководство по итерации массива&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="036e376170c1d3906a5f0a04018619e235105dc6" translate="yes" xml:space="preserve">
          <source>Effort to spend on solving the overlap problem (maximum number of candidate solutions to consider). The following special values are recognized:</source>
          <target state="translated">Усилия по решению проблемы перекрытия (максимальное количество рассматриваемых кандидатур).Признаются следующие специальные значения:</target>
        </trans-unit>
        <trans-unit id="ab3820529f3b083c6a31ff8350ee28b11115b842" translate="yes" xml:space="preserve">
          <source>Effort to spend on solving the overlap problem. See &lt;a href=&quot;numpy.shares_memory#numpy.shares_memory&quot;&gt;&lt;code&gt;shares_memory&lt;/code&gt;&lt;/a&gt; for details. Default for &lt;code&gt;may_share_memory&lt;/code&gt; is to do a bounds check.</source>
          <target state="translated">Усилия потратить на решение проблемы перекрытия. Подробнее см. &lt;a href=&quot;numpy.shares_memory#numpy.shares_memory&quot;&gt; &lt;code&gt;shares_memory&lt;/code&gt; &lt;/a&gt; . По умолчанию для &lt;code&gt;may_share_memory&lt;/code&gt; выполняется проверка границ.</target>
        </trans-unit>
        <trans-unit id="444baf679021343f134e3ab4afdb77852c13f5b7" translate="yes" xml:space="preserve">
          <source>Einstein summation convention.</source>
          <target state="translated">Съезд Эйнштейна по подведению итогов.</target>
        </trans-unit>
        <trans-unit id="9e7269d88813a122dd6b4c8836b591f55f6ef940" translate="yes" xml:space="preserve">
          <source>Einsum</source>
          <target state="translated">Einsum</target>
        </trans-unit>
        <trans-unit id="b7f8aa394c8c17e22a13e4ec50ff49bf4fdd395d" translate="yes" xml:space="preserve">
          <source>Einsum optimization path updates and efficiency improvements</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f574da7dabc16cec8dc28f2e16dcdf93d39e214" translate="yes" xml:space="preserve">
          <source>Either &amp;lsquo;inv&amp;rsquo; or &amp;lsquo;zig&amp;rsquo;. &amp;lsquo;inv&amp;rsquo; uses the default inverse CDF method. &amp;lsquo;zig&amp;rsquo; uses the much faster Ziggurat method of Marsaglia and Tsang.</source>
          <target state="translated">Либо inv, либо zig. inv использует обратный метод CDF по умолчанию. 'zig' использует гораздо более быстрый метод зиккурата Марсальи и Цанга.</target>
        </trans-unit>
        <trans-unit id="41ec8a6c5a0f22c1b241625049fb5165828e9c89" translate="yes" xml:space="preserve">
          <source>Either &lt;a href=&quot;ufunc#c.PyUFunc_One&quot;&gt;&lt;code&gt;PyUFunc_One&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;ufunc#c.PyUFunc_Zero&quot;&gt;&lt;code&gt;PyUFunc_Zero&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;ufunc#c.PyUFunc_None&quot;&gt;&lt;code&gt;PyUFunc_None&lt;/code&gt;&lt;/a&gt; or &lt;code&gt;PyUFunc_AllOnes&lt;/code&gt; to indicate the identity for this operation. It is only used for a reduce-like call on an empty array.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f248b6168fbf2f57439344bf599f0d52d7a807c7" translate="yes" xml:space="preserve">
          <source>Either &lt;code&gt;NULL&lt;/code&gt; or a dictionary containing low-level casting functions for user- defined data-types. Each function is wrapped in a &lt;code&gt;PyCObject *&lt;/code&gt; and keyed by the data-type number.</source>
          <target state="translated">Либо &lt;code&gt;NULL&lt;/code&gt; , либо словарь, содержащий низкоуровневые функции приведения для пользовательских типов данных. Каждая функция заключена в &lt;code&gt;PyCObject *&lt;/code&gt; и снабжена номером типа данных.</target>
        </trans-unit>
        <trans-unit id="cd680ae51259fbdc5100a31577a59d7a7923df2f" translate="yes" xml:space="preserve">
          <source>Either &lt;code&gt;NULL&lt;/code&gt; or an array of &lt;a href=&quot;array#c.NPY_NSCALARKINDS&quot;&gt;&lt;code&gt;NPY_NSCALARKINDS&lt;/code&gt;&lt;/a&gt; pointers. These pointers should each be either &lt;code&gt;NULL&lt;/code&gt; or a pointer to an array of integers (terminated by &lt;a href=&quot;dtype#c.NPY_NOTYPE&quot;&gt;&lt;code&gt;NPY_NOTYPE&lt;/code&gt;&lt;/a&gt;) indicating data-types that a scalar of this data-type of the specified kind can be cast to safely (this usually means without losing precision).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff36def358c4174701abf75ea4d4e0cdcf5bd477" translate="yes" xml:space="preserve">
          <source>Either &lt;code&gt;NULL&lt;/code&gt; or an array of &lt;a href=&quot;c-api.array#c.NPY_NSCALARKINDS&quot;&gt;&lt;code&gt;NPY_NSCALARKINDS&lt;/code&gt;&lt;/a&gt; pointers. These pointers should each be either &lt;code&gt;NULL&lt;/code&gt; or a pointer to an array of integers (terminated by &lt;a href=&quot;c-api.dtype#c.NPY_NOTYPE&quot;&gt;&lt;code&gt;NPY_NOTYPE&lt;/code&gt;&lt;/a&gt;) indicating data-types that a scalar of this data-type of the specified kind can be cast to safely (this usually means without losing precision).</source>
          <target state="translated">Либо &lt;code&gt;NULL&lt;/code&gt; , либо массив указателей &lt;a href=&quot;c-api.array#c.NPY_NSCALARKINDS&quot;&gt; &lt;code&gt;NPY_NSCALARKINDS&lt;/code&gt; &lt;/a&gt; . Каждый из этих указателей должен быть либо &lt;code&gt;NULL&lt;/code&gt; , либо указателем на массив целых чисел (заканчивающийся &lt;a href=&quot;c-api.dtype#c.NPY_NOTYPE&quot;&gt; &lt;code&gt;NPY_NOTYPE&lt;/code&gt; &lt;/a&gt; ), указывающий типы данных, к которым можно безопасно привести скаляр этого типа данных указанного типа (обычно это означает без потери точности).</target>
        </trans-unit>
        <trans-unit id="9b68604ef80074abda088f5c021808f55b2ed04d" translate="yes" xml:space="preserve">
          <source>Either &lt;code&gt;NULL&lt;/code&gt; or an array of integers (terminated by &lt;a href=&quot;c-api.dtype#c.NPY_NOTYPE&quot;&gt;&lt;code&gt;NPY_NOTYPE&lt;/code&gt;&lt;/a&gt; ) indicated data-types that this data-type can be cast to safely (this usually means without losing precision).</source>
          <target state="translated">Либо &lt;code&gt;NULL&lt;/code&gt; , либо массив целых чисел (заканчивающийся &lt;a href=&quot;c-api.dtype#c.NPY_NOTYPE&quot;&gt; &lt;code&gt;NPY_NOTYPE&lt;/code&gt; &lt;/a&gt; ) указывают типы данных, к которым этот тип данных может быть безопасно приведен (обычно это означает без потери точности).</target>
        </trans-unit>
        <trans-unit id="8a8e73551f33a77ec9147f05121309347af67814" translate="yes" xml:space="preserve">
          <source>Either &lt;code&gt;NULL&lt;/code&gt; or an array of integers (terminated by &lt;a href=&quot;dtype#c.NPY_NOTYPE&quot;&gt;&lt;code&gt;NPY_NOTYPE&lt;/code&gt;&lt;/a&gt; ) indicated data-types that this data-type can be cast to safely (this usually means without losing precision).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="accffd1618e3de5c69c33d1510a23e42c114bdf3" translate="yes" xml:space="preserve">
          <source>Either &lt;code&gt;None&lt;/code&gt; to indicate a C-style contiguous array or a Tuple of strides which provides the number of bytes needed to jump to the next array element in the corresponding dimension. Each entry must be an integer (a Python &lt;code&gt;int&lt;/code&gt; or &lt;code&gt;long&lt;/code&gt;). As with shape, the values may be larger than can be represented by a C &amp;ldquo;int&amp;rdquo; or &amp;ldquo;long&amp;rdquo;; the calling code should handle this appropriately, either by raising an error, or by using &lt;code&gt;Py_LONG_LONG&lt;/code&gt; in C. The default is &lt;code&gt;None&lt;/code&gt; which implies a C-style contiguous memory buffer. In this model, the last dimension of the array varies the fastest. For example, the default strides tuple for an object whose array entries are 8 bytes long and whose shape is (10,20,30) would be (4800, 240, 8)</source>
          <target state="translated">Либо &lt;code&gt;None&lt;/code&gt; , чтобы указать непрерывный массив в стиле C, либо набор шагов, который обеспечивает количество байтов, необходимое для перехода к следующему элементу массива в соответствующем измерении. Каждая запись должна быть целым числом (Python &lt;code&gt;int&lt;/code&gt; или &lt;code&gt;long&lt;/code&gt; ). Как и в случае с shape, значения могут быть больше, чем могут быть представлены C &amp;laquo;int&amp;raquo; или &amp;laquo;long&amp;raquo;; вызывающий код должен обработать это соответствующим образом, либо путем создания ошибки, либо путем использования &lt;code&gt;Py_LONG_LONG&lt;/code&gt; в C. По умолчанию установлено значение &lt;code&gt;None&lt;/code&gt; , что подразумевает непрерывный буфер памяти в стиле C. В этой модели последнее измерение массива изменяется быстрее всего. Например, кортеж шагов по умолчанию для объекта, элементы массива которого имеют длину 8 байтов и форма (10,20,30), будет иметь вид (4800, 240, 8)</target>
        </trans-unit>
        <trans-unit id="2e35b148ce133a87759db1169ada9bc7afe8b136" translate="yes" xml:space="preserve">
          <source>Either &lt;code&gt;PyUFunc_One&lt;/code&gt;, &lt;code&gt;PyUFunc_Zero&lt;/code&gt;, &lt;code&gt;PyUFunc_None&lt;/code&gt; or &lt;code&gt;PyUFunc_AllOnes&lt;/code&gt; to indicate the identity for this operation. It is only used for a reduce-like call on an empty array.</source>
          <target state="translated">Либо &lt;code&gt;PyUFunc_One&lt;/code&gt; , &lt;code&gt;PyUFunc_Zero&lt;/code&gt; , &lt;code&gt;PyUFunc_None&lt;/code&gt; или &lt;code&gt;PyUFunc_AllOnes&lt;/code&gt; , чтобы указать идентификатор для этой операции. Он используется только для вызова, подобного сокращению, для пустого массива.</target>
        </trans-unit>
        <trans-unit id="fb67ce0cbc08322db9293cceafb38eefe75acb01" translate="yes" xml:space="preserve">
          <source>Either None to indicate a C-style contiguous array or a Tuple of strides which provides the number of bytes needed to jump to the next array element in the corresponding dimension. Each entry must be an integer (a Python &lt;code&gt;int&lt;/code&gt; or &lt;code&gt;long&lt;/code&gt;). As with shape, the values may be larger than can be represented by a C &amp;ldquo;int&amp;rdquo; or &amp;ldquo;long&amp;rdquo;; the calling code should handle this appropriately, either by raising an error, or by using &lt;code&gt;Py_LONG_LONG&lt;/code&gt; in C. The default is None which implies a C-style contiguous memory buffer. In this model, the last dimension of the array varies the fastest. For example, the default strides tuple for an object whose array entries are 8 bytes long and whose shape is (10,20,30) would be (4800, 240, 8)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="987f54d54272ffd5f21f8146bd411a9086f8f96d" translate="yes" xml:space="preserve">
          <source>Either a basic-type description string as in &lt;em&gt;typestr&lt;/em&gt; or another list (for nested structured types)</source>
          <target state="translated">Либо строка описания базового типа, как в &lt;em&gt;typestr,&lt;/em&gt; либо другой список (для вложенных структурированных типов)</target>
        </trans-unit>
        <trans-unit id="e36f94dd4a5bc304e7b8e5a337101261c2694c11" translate="yes" xml:space="preserve">
          <source>Either a data-type, a tuple of data-types, or a special signature string indicating the input and output types of a ufunc. This argument allows you to provide a specific signature for the 1-d loop to use in the underlying calculation. If the loop specified does not exist for the ufunc, then a TypeError is raised. Normally, a suitable loop is found automatically by comparing the input types with what is available and searching for a loop with data-types to which all inputs can be cast safely. This keyword argument lets you bypass that search and choose a particular loop. A list of available signatures is provided by the &lt;strong&gt;types&lt;/strong&gt; attribute of the ufunc object. For backwards compatibility this argument can also be provided as &lt;em&gt;sig&lt;/em&gt;, although the long form is preferred. Note that this should not be confused with the generalized ufunc &lt;a href=&quot;c-api.generalized-ufuncs#details-of-signature&quot;&gt;signature&lt;/a&gt; that is stored in the &lt;strong&gt;signature&lt;/strong&gt; attribute of the of the ufunc object.</source>
          <target state="translated">Либо тип данных, либо кортеж типов данных, либо специальная строка подписи, указывающая типы ввода и вывода ufunc. Этот аргумент позволяет указать конкретную сигнатуру для 1-мерного цикла, которая будет использоваться в базовых вычислениях. Если указанный цикл не существует для ufunc, возникает ошибка TypeError. Обычно подходящий цикл находится автоматически путем сравнения типов ввода с доступными и поиска цикла с типами данных, в которые можно безопасно привести все входные данные. Этот аргумент ключевого слова позволяет обойти этот поиск и выбрать конкретный цикл. Список доступных подписей обеспечиваются &lt;strong&gt;типами&lt;/strong&gt; атрибут ufunc объекта. Для обратной совместимости этот аргумент также может быть &lt;em&gt;указан&lt;/em&gt; как &lt;em&gt;sig&lt;/em&gt;, хотя длинная форма предпочтительнее. Обратите внимание, что это не следует путать с обобщенной &lt;a href=&quot;c-api.generalized-ufuncs#details-of-signature&quot;&gt;подписью&lt;/a&gt; ufunc, которая хранится в атрибуте &lt;strong&gt;подписи&lt;/strong&gt; объекта ufunc.</target>
        </trans-unit>
        <trans-unit id="7610b5a110dcd0d84cf907684a00201bedfda50b" translate="yes" xml:space="preserve">
          <source>Either a data-type, a tuple of data-types, or a special signature string indicating the input and output types of a ufunc. This argument allows you to provide a specific signature for the 1-d loop to use in the underlying calculation. If the loop specified does not exist for the ufunc, then a TypeError is raised. Normally, a suitable loop is found automatically by comparing the input types with what is available and searching for a loop with data-types to which all inputs can be cast safely. This keyword argument lets you bypass that search and choose a particular loop. A list of available signatures is provided by the &lt;strong&gt;types&lt;/strong&gt; attribute of the ufunc object. For backwards compatibility this argument can also be provided as &lt;em&gt;sig&lt;/em&gt;, although the long form is preferred. Note that this should not be confused with the generalized ufunc &lt;a href=&quot;c-api/generalized-ufuncs#details-of-signature&quot;&gt;signature&lt;/a&gt; that is stored in the &lt;strong&gt;signature&lt;/strong&gt; attribute of the of the ufunc object.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e1209e0f0503ff7dc267174ecb081f65f265397" translate="yes" xml:space="preserve">
          <source>Either passing n arguments as in njoin(&amp;lsquo;a&amp;rsquo;,&amp;rsquo;b&amp;rsquo;), or a sequence of n names as in njoin([&amp;lsquo;a&amp;rsquo;,&amp;rsquo;b&amp;rsquo;]) is handled, or a mixture of such arguments.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c7015ddb90f8a42ecbacfed5d690fb153cc71ff7" translate="yes" xml:space="preserve">
          <source>Either the file name (string) or an open file (file-like object) where the data will be saved. If file is a string or a Path, the &lt;code&gt;.npz&lt;/code&gt; extension will be appended to the file name if it is not already there.</source>
          <target state="translated">Либо имя файла (строка), либо открытый файл (файлоподобный объект), в котором будут сохранены данные. Если файл представляет собой строку или путь, к имени &lt;code&gt;.npz&lt;/code&gt; будет добавлено расширение .npz, если его еще нет.</target>
        </trans-unit>
        <trans-unit id="0f9fa4310da3a7c0b9cf42ac99c7003bdc5b813b" translate="yes" xml:space="preserve">
          <source>Either the filename (string) or an open file (file-like object) where the data will be saved. If file is a string or a Path, the &lt;code&gt;.npz&lt;/code&gt; extension will be appended to the filename if it is not already there.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2953df344283c54bedef1d8e252fb3c96e667a80" translate="yes" xml:space="preserve">
          <source>Element index to partition by. The k-th element will be in its final sorted position and all smaller elements will be moved before it and all larger elements behind it. The order all elements in the partitions is undefined. If provided with a sequence of k-th it will partition all of them into their sorted position at once.</source>
          <target state="translated">Индекс элементов для разделения на.k-й элемент будет находиться в окончательном отсортированном положении,а все более мелкие элементы будут перемещены перед ним и все более крупные элементы позади него.Порядок расположения всех элементов в простенках не определен.Если предусмотрена последовательность k-ых,то все они будут разделены в их отсортированном положении сразу.</target>
        </trans-unit>
        <trans-unit id="603f2f92b6e79eef48a044dac1baeab309560ae3" translate="yes" xml:space="preserve">
          <source>Element index to partition by. The k-th value of the element will be in its final sorted position and all smaller elements will be moved before it and all equal or greater elements behind it. The order of all elements in the partitions is undefined. If provided with a sequence of k-th it will partition all elements indexed by k-th of them into their sorted position at once.</source>
          <target state="translated">Индекс элементов для разделения на.Значение k-го элемента будет находиться в конечном отсортированном положении и все меньшие элементы будут перемещены перед ним,а все равные или большие элементы-за ним.Порядок расположения всех элементов в простенках не определен.Если предусмотрена последовательность k-ых,то все элементы,проиндексированные k-ыми из них,будут разделены в их отсортированном положении сразу.</target>
        </trans-unit>
        <trans-unit id="dd1e5c082697760ec705616bbb818b3e3054f2a3" translate="yes" xml:space="preserve">
          <source>Element index to partition by. The kth element value will be in its final sorted position and all smaller elements will be moved before it and all equal or greater elements behind it. The order of all elements in the partitions is undefined. If provided with a sequence of kth it will partition all elements indexed by kth of them into their sorted position at once.</source>
          <target state="translated">Индекс элементов для разделения на.Значение k-го элемента будет находиться в окончательном отсортированном положении и все меньшие элементы будут перемещены перед ним и все равные или большие элементы за ним.Порядок расположения всех элементов в простенках не определен.Если предусмотрена последовательность kth,то он разбивает все элементы,проиндексированные kth из них,на их отсортированное положение сразу.</target>
        </trans-unit>
        <trans-unit id="67afd821e881e618d2d3c592047caa6ab2545d17" translate="yes" xml:space="preserve">
          <source>Element-wise 2 to the power &lt;code&gt;x&lt;/code&gt;. This is a scalar if &lt;code&gt;x&lt;/code&gt; is a scalar.</source>
          <target state="translated">Поэлементно 2 в степени &lt;code&gt;x&lt;/code&gt; . Это скаляр, если &lt;code&gt;x&lt;/code&gt; - скаляр.</target>
        </trans-unit>
        <trans-unit id="adaf9e130e6f948876c40cb7079ab5374d49e139" translate="yes" xml:space="preserve">
          <source>Element-wise &lt;code&gt;x*x&lt;/code&gt;, of the same shape and dtype as &lt;code&gt;x&lt;/code&gt;. This is a scalar if &lt;code&gt;x&lt;/code&gt; is a scalar.</source>
          <target state="translated">Поэлементно &lt;code&gt;x*x&lt;/code&gt; , из одной и той же формы и DTYPE как &lt;code&gt;x&lt;/code&gt; . Это скаляр, если &lt;code&gt;x&lt;/code&gt; - скаляр.</target>
        </trans-unit>
        <trans-unit id="808b6a2cc974757f97aaa854c54baffd849df5f9" translate="yes" xml:space="preserve">
          <source>Element-wise arc tangent of &lt;code&gt;x1/x2&lt;/code&gt; choosing the quadrant correctly.</source>
          <target state="translated">Поэлементный арктангенс &lt;code&gt;x1/x2&lt;/code&gt; с правильным выбором квадранта.</target>
        </trans-unit>
        <trans-unit id="2ac96759d5e7cde7bc053be626eb0c73009447e8" translate="yes" xml:space="preserve">
          <source>Element-wise exponential minus one: &lt;code&gt;out = exp(x) - 1&lt;/code&gt;. This is a scalar if &lt;code&gt;x&lt;/code&gt; is a scalar.</source>
          <target state="translated">Поэлементная экспонента минус один: &lt;code&gt;out = exp(x) - 1&lt;/code&gt; . Это скаляр, если &lt;code&gt;x&lt;/code&gt; - скаляр.</target>
        </trans-unit>
        <trans-unit id="2e24669e28a8f1555e04e187ba59f7b56eef5d74" translate="yes" xml:space="preserve">
          <source>Element-wise maximum of array elements.</source>
          <target state="translated">Элементный максимум элементов массива.</target>
        </trans-unit>
        <trans-unit id="de0f8227b430f00f150f25df31d4c6130cd8dee1" translate="yes" xml:space="preserve">
          <source>Element-wise maximum of two arrays, ignores NaNs.</source>
          <target state="translated">Максимум два массива по Элементу,игнорирует NaNs.</target>
        </trans-unit>
        <trans-unit id="f0000ade51e0b31f8609d90f1fdd9bbd95746777" translate="yes" xml:space="preserve">
          <source>Element-wise maximum of two arrays, ignoring any NaNs.</source>
          <target state="translated">Максимум два массива по Элементу,игнорируя любые NaN.</target>
        </trans-unit>
        <trans-unit id="a0de4ef4fdf4c984be543486b8ef23d43631cea6" translate="yes" xml:space="preserve">
          <source>Element-wise maximum of two arrays, propagates NaNs.</source>
          <target state="translated">Элементный максимум в двух массивах,распространяет NaNs.</target>
        </trans-unit>
        <trans-unit id="bdcc1733a93ea05c9ded4af3bbc823384a01061c" translate="yes" xml:space="preserve">
          <source>Element-wise maximum of two arrays, propagating any NaNs.</source>
          <target state="translated">Максимум два массива по Элементу,распространяющих любые NaNs.</target>
        </trans-unit>
        <trans-unit id="117fbbb294a3d3f4ec6bf9953291f0979ba3eb6d" translate="yes" xml:space="preserve">
          <source>Element-wise minimum of array elements.</source>
          <target state="translated">Элементный минимум элементов массива.</target>
        </trans-unit>
        <trans-unit id="f10c8e11f8111bdb87b272aa363c7d5a87d2958e" translate="yes" xml:space="preserve">
          <source>Element-wise minimum of two arrays, ignores NaNs.</source>
          <target state="translated">Минимум два массива по Элементу,игнорирует NaNs.</target>
        </trans-unit>
        <trans-unit id="0c1d7d39298313f44ede26ddbe99082deaf8d999" translate="yes" xml:space="preserve">
          <source>Element-wise minimum of two arrays, ignoring any NaNs.</source>
          <target state="translated">Минимум два массива по Элементу,игнорируя любые NaNs.</target>
        </trans-unit>
        <trans-unit id="129e7a520fce7febf9e89723a4b3e31c307bd988" translate="yes" xml:space="preserve">
          <source>Element-wise minimum of two arrays, propagates NaNs.</source>
          <target state="translated">Минимум два массива по Элементу,распространяет NaNs.</target>
        </trans-unit>
        <trans-unit id="31ccb3abbc1e393d00365ccd1319992c54e9ed13" translate="yes" xml:space="preserve">
          <source>Element-wise minimum of two arrays, propagating any NaNs.</source>
          <target state="translated">Минимум два массива по Элементу,распространяющих любые NaNs.</target>
        </trans-unit>
        <trans-unit id="a664254a8e3d768c1b8ca8504a3064612680ed55" translate="yes" xml:space="preserve">
          <source>Element-wise quotient resulting from floor division. This is a scalar if both &lt;code&gt;x1&lt;/code&gt; and &lt;code&gt;x2&lt;/code&gt; are scalars.</source>
          <target state="translated">Поэлементное частное в результате разделения этажей. Это скаляр, если и &lt;code&gt;x1&lt;/code&gt; , и &lt;code&gt;x2&lt;/code&gt; являются скалярами.</target>
        </trans-unit>
        <trans-unit id="35a0aab7c92a2f3f84b40cb7246ed8c1bcebd9a8" translate="yes" xml:space="preserve">
          <source>Element-wise remainder from floor division. This is a scalar if both &lt;code&gt;x1&lt;/code&gt; and &lt;code&gt;x2&lt;/code&gt; are scalars.</source>
          <target state="translated">Поэлементный остаток от разделения этажа. Это скаляр, если и &lt;code&gt;x1&lt;/code&gt; , и &lt;code&gt;x2&lt;/code&gt; являются скалярами.</target>
        </trans-unit>
        <trans-unit id="41a18c5c80ce790e4ab72162c437f0a9d09ae712" translate="yes" xml:space="preserve">
          <source>Elementary Function</source>
          <target state="translated">Элементарная функция</target>
        </trans-unit>
        <trans-unit id="04982a80ae05d1b0cdf8cb6f954f5d90370c1f1a" translate="yes" xml:space="preserve">
          <source>Elements shapes must match along the appropriate axes (without broadcasting), but leading 1s will be prepended to the shape as necessary to make the dimensions match.</source>
          <target state="translated">Формы элементов должны совпадать по соответствующим осям (без трансляции),но передние 1 будут дополнены формой по мере необходимости,чтобы размеры совпадали.</target>
        </trans-unit>
        <trans-unit id="ec73af38a64af612d36b6b1e08ea284a14bd8798" translate="yes" xml:space="preserve">
          <source>Elements that roll beyond the last position are re-introduced at the first.</source>
          <target state="translated">Элементы,которые скатываются за пределы последнего положения,вводятся повторно при первом положении.</target>
        </trans-unit>
        <trans-unit id="8ec956445b767a135cb8c6d627b5a2dfeb02537d" translate="yes" xml:space="preserve">
          <source>Elements to compare for the maximum. See &lt;a href=&quot;numpy.ufunc.reduce#numpy.ufunc.reduce&quot;&gt;&lt;code&gt;reduce&lt;/code&gt;&lt;/a&gt; for details.</source>
          <target state="translated">Элементы для сравнения по максимуму. Подробнее см. &lt;a href=&quot;numpy.ufunc.reduce#numpy.ufunc.reduce&quot;&gt; &lt;code&gt;reduce&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4ba7c2272413ef1378137b3e69e8b4722f8659b1" translate="yes" xml:space="preserve">
          <source>Elements to compare for the minimum. See &lt;a href=&quot;numpy.ufunc.reduce#numpy.ufunc.reduce&quot;&gt;&lt;code&gt;reduce&lt;/code&gt;&lt;/a&gt; for details.</source>
          <target state="translated">Элементы для сравнения по минимуму. Подробнее см. &lt;a href=&quot;numpy.ufunc.reduce#numpy.ufunc.reduce&quot;&gt; &lt;code&gt;reduce&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9c0973f46abdf4cfdea56a1e0e2597c002a92fb2" translate="yes" xml:space="preserve">
          <source>Elements to include in the product. See &lt;a href=&quot;numpy.ufunc.reduce#numpy.ufunc.reduce&quot;&gt;&lt;code&gt;reduce&lt;/code&gt;&lt;/a&gt; for details.</source>
          <target state="translated">Элементы для включения в продукт. Подробнее см. &lt;a href=&quot;numpy.ufunc.reduce#numpy.ufunc.reduce&quot;&gt; &lt;code&gt;reduce&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="836bba81daa7bbfa24fcec9d876cd0ca01db1438" translate="yes" xml:space="preserve">
          <source>Elements to include in the sum. See &lt;a href=&quot;numpy.ufunc.reduce#numpy.ufunc.reduce&quot;&gt;&lt;code&gt;reduce&lt;/code&gt;&lt;/a&gt; for details.</source>
          <target state="translated">Элементы для включения в сумму. Подробнее см. &lt;a href=&quot;numpy.ufunc.reduce#numpy.ufunc.reduce&quot;&gt; &lt;code&gt;reduce&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a68b36609400536b206e5ed8f4915662a0a2020b" translate="yes" xml:space="preserve">
          <source>Elements to sum.</source>
          <target state="translated">Элементы в сумме.</target>
        </trans-unit>
        <trans-unit id="680319fcdd621a03121d173370e025227fa7d8d6" translate="yes" xml:space="preserve">
          <source>Elementwise bit operations</source>
          <target state="translated">элементообразующие битовые операции</target>
        </trans-unit>
        <trans-unit id="59a9a9f6dbe39b1cf060328792d82b4916bb1fe4" translate="yes" xml:space="preserve">
          <source>Email the editor of LWN to let them know of the release. Directions at: &lt;a href=&quot;https://lwn.net/op/FAQ.lwn#contact&quot;&gt;https://lwn.net/op/FAQ.lwn#contact&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="599d2acd649f524c65c4bd78c5dfde8f2b7d2eea" translate="yes" xml:space="preserve">
          <source>Emeritus members</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="975003171b5d10383f8baffd2a3aedbe6bfb0ccf" translate="yes" xml:space="preserve">
          <source>Emit py3kwarnings for division of integer arrays</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b188c1a7743df45af55da550ee4905951a67f8f" translate="yes" xml:space="preserve">
          <source>Emphasize empathy for individuals rather than judging behavior, avoiding binary labels of &amp;ldquo;good&amp;rdquo; and &amp;ldquo;bad/evil&amp;rdquo;. Overt, clear-cut aggression and harassment exists and we will be address that firmly. But many scenarios that can prove challenging to resolve are those where normal disagreements devolve into unhelpful or harmful behavior from multiple parties. Understanding the full context and finding a path that re-engages all is hard, but ultimately the most productive for our community.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="777a53a52816c5597e4f366c2ef31bc0f2a213da" translate="yes" xml:space="preserve">
          <source>Empty array of the given shape and type.</source>
          <target state="translated">Пустой массив заданной формы и типа.</target>
        </trans-unit>
        <trans-unit id="30b8b3469c24b495eeedeb9693c9bf36670e4dcd" translate="yes" xml:space="preserve">
          <source>Empty masked array modelled on an existing array.</source>
          <target state="translated">Пустой массив,смоделированный на существующем массиве.</target>
        </trans-unit>
        <trans-unit id="6985c4b0d668125594b4f0ca6436e1c86a0154e8" translate="yes" xml:space="preserve">
          <source>Empty masked array with all elements masked.</source>
          <target state="translated">Пустой массив с маскировкой всех элементов.</target>
        </trans-unit>
        <trans-unit id="680b8e573f5c82aced131f36a223b41bb3352d25" translate="yes" xml:space="preserve">
          <source>Empty masked array with the properties of an existing array.</source>
          <target state="translated">Пустой массив со свойствами существующего массива.</target>
        </trans-unit>
        <trans-unit id="45886aabb4d2355c3b829d3be8c1cca38e105c36" translate="yes" xml:space="preserve">
          <source>Enable AVX2/AVX512 at compile time</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a122b7a065f1b0b6e65770d5576676e667e835a7" translate="yes" xml:space="preserve">
          <source>Enables support for iteration of sub-ranges of the full &lt;code&gt;iterindex&lt;/code&gt; range &lt;code&gt;[0, NpyIter_IterSize(iter))&lt;/code&gt;. Use the function &lt;a href=&quot;#c.NpyIter_ResetToIterIndexRange&quot;&gt;&lt;code&gt;NpyIter_ResetToIterIndexRange&lt;/code&gt;&lt;/a&gt; to specify a range for iteration.</source>
          <target state="translated">Включает поддержку итерации поддиапазонов полного диапазона &lt;code&gt;iterindex&lt;/code&gt; &lt;code&gt;[0, NpyIter_IterSize(iter))&lt;/code&gt; . Используйте функцию &lt;a href=&quot;#c.NpyIter_ResetToIterIndexRange&quot;&gt; &lt;code&gt;NpyIter_ResetToIterIndexRange&lt;/code&gt; ,&lt;/a&gt; чтобы указать диапазон для итерации.</target>
        </trans-unit>
        <trans-unit id="0bc79001ca7d4881c81aec2ea04317198e31e1bd" translate="yes" xml:space="preserve">
          <source>Enables the specified array flags. This function does no validation, and assumes that you know what you&amp;rsquo;re doing.</source>
          <target state="translated">Включает указанные флаги массива. Эта функция не выполняет проверки и предполагает, что вы знаете, что делаете.</target>
        </trans-unit>
        <trans-unit id="2919970bd082897345d32d119a4800b54dae0c81" translate="yes" xml:space="preserve">
          <source>Encapsulate the functionality of functions and methods that take the axis= keyword and work properly with None as the axis argument. The input array is &lt;code&gt;obj&lt;/code&gt;, while &lt;code&gt;*axis&lt;/code&gt; is a converted integer (so that &amp;gt;=MAXDIMS is the None value), and &lt;code&gt;requirements&lt;/code&gt; gives the needed properties of &lt;code&gt;obj&lt;/code&gt;. The output is a converted version of the input so that requirements are met and if needed a flattening has occurred. On output negative values of &lt;code&gt;*axis&lt;/code&gt; are converted and the new value is checked to ensure consistency with the shape of &lt;code&gt;obj&lt;/code&gt;.</source>
          <target state="translated">Инкапсулируйте функциональность функций и методов, которые принимают ключевое слово axis = и правильно работают с None в качестве аргумента оси. Входной массив - это &lt;code&gt;obj&lt;/code&gt; , а &lt;code&gt;*axis&lt;/code&gt; - это преобразованное целое число (так что&amp;gt; = MAXDIMS является значением None), а &lt;code&gt;requirements&lt;/code&gt; задают необходимые свойства &lt;code&gt;obj&lt;/code&gt; . Выходные данные представляют собой преобразованную версию входных данных, поэтому требования выполняются и, если необходимо, произошло выравнивание. На выходе отрицательные значения &lt;code&gt;*axis&lt;/code&gt; преобразуются, и новое значение проверяется, чтобы гарантировать согласованность с формой &lt;code&gt;obj&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="27ce22c6173324f95f01ae2e015c760af4bd2880" translate="yes" xml:space="preserve">
          <source>Enclose variables in single backticks. The colon must be preceded by a space, or omitted if the type is absent.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="349d554a10586cdec500258debd97663d605504e" translate="yes" xml:space="preserve">
          <source>Encoding argument for text IO functions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3fcbf1219e531263b67edb6bcb90e0e603ad6031" translate="yes" xml:space="preserve">
          <source>Encoding used to decode the inputfile. Does not apply to input streams.</source>
          <target state="translated">Кодирование,используемое для декодирования входного файла.Не применяется к входным потокам.</target>
        </trans-unit>
        <trans-unit id="b27e46c5a085977e5cb88681f8a881b52c0fec71" translate="yes" xml:space="preserve">
          <source>Encoding used to decode the inputfile. Does not apply to input streams. The special value &amp;lsquo;bytes&amp;rsquo; enables backward compatibility workarounds that ensures you receive byte arrays as results if possible and passes &amp;lsquo;latin1&amp;rsquo; encoded strings to converters. Override this value to receive unicode arrays and pass strings as input to converters. If set to None the system default is used. The default value is &amp;lsquo;bytes&amp;rsquo;.</source>
          <target state="translated">Кодировка, используемая для декодирования входного файла. Не применяется к входным потокам. Специальное значение &amp;laquo;bytes&amp;raquo; включает обходные пути обратной совместимости, которые гарантируют получение массивов байтов в качестве результатов, если это возможно, и передачу строк в кодировке &amp;laquo;latin1&amp;raquo; конвертерам. Переопределите это значение, чтобы получать массивы Unicode и передавать строки в качестве входных данных для преобразователей. Если установлено значение &amp;laquo;Нет&amp;raquo;, используется система по умолчанию. Значение по умолчанию - &amp;laquo;байты&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="6776a87f17cb7165db7de968828852a089f8cd2b" translate="yes" xml:space="preserve">
          <source>Encoding used to decode the inputfile. Does not apply when &lt;code&gt;fname&lt;/code&gt; is a file object. The special value &amp;lsquo;bytes&amp;rsquo; enables backward compatibility workarounds that ensure that you receive byte arrays when possible and passes latin1 encoded strings to converters. Override this value to receive unicode arrays and pass strings as input to converters. If set to None the system default is used. The default value is &amp;lsquo;bytes&amp;rsquo;.</source>
          <target state="translated">Кодировка, используемая для декодирования входного файла. Не применяется, если &lt;code&gt;fname&lt;/code&gt; является файловым объектом. Специальное значение &amp;laquo;bytes&amp;raquo; включает обходные пути обратной совместимости, которые гарантируют получение байтовых массивов, когда это возможно, и передачу строк в кодировке latin1 конвертерам. Переопределите это значение, чтобы получать массивы Unicode и передавать строки в качестве входных данных для преобразователей. Если установлено значение Нет, используется система по умолчанию. Значение по умолчанию - &amp;laquo;байты&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="8e2939a9752e2c7114a267e7bcdaebdf8d9a69e0" translate="yes" xml:space="preserve">
          <source>Encoding used to encode the outputfile. Does not apply to output streams. If the encoding is something other than &amp;lsquo;bytes&amp;rsquo; or &amp;lsquo;latin1&amp;rsquo; you will not be able to load the file in NumPy versions &amp;lt; 1.14. Default is &amp;lsquo;latin1&amp;rsquo;.</source>
          <target state="translated">Кодировка, используемая для кодирования выходного файла. Не применяется к выходным потокам. Если кодировка отличается от &amp;laquo;байтов&amp;raquo; или &amp;laquo;latin1&amp;raquo;, вы не сможете загрузить файл в версиях NumPy &amp;lt;1.14. По умолчанию - latin1.</target>
        </trans-unit>
        <trans-unit id="672959489089d143587fef9e4d4ad09fb66e2197" translate="yes" xml:space="preserve">
          <source>End of interval. The interval does not include this value, except in some cases where &lt;code&gt;step&lt;/code&gt; is not an integer and floating point round-off affects the length of &lt;code&gt;out&lt;/code&gt;.</source>
          <target state="translated">Конец интервала. Интервал не включает это значение, за исключением некоторых случаев, когда &lt;code&gt;step&lt;/code&gt; не является целым числом, а округление с плавающей запятой влияет на длину &lt;code&gt;out&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d9b220f5e9cefe4e27d14fddf001bfa3a63353e7" translate="yes" xml:space="preserve">
          <source>Endianness of this data:</source>
          <target state="translated">Эндианность этих данных:</target>
        </trans-unit>
        <trans-unit id="90010140c11fc0bb2865fc9b51fcfa59f205ccef" translate="yes" xml:space="preserve">
          <source>Endnotes</source>
          <target state="translated">Endnotes</target>
        </trans-unit>
        <trans-unit id="05406404937f1ded938df8b2535e2c18c93233ac" translate="yes" xml:space="preserve">
          <source>Enforcing the Code of Conduct impacts our community today and for the future. It&amp;rsquo;s an action that we do not take lightly. When reviewing enforcement measures, the Code of Conduct Committee will keep the following values and guidelines in mind:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3bf2be725863fdffb3b97618f54e280ae615ed8" translate="yes" xml:space="preserve">
          <source>Enhancements</source>
          <target state="translated">Enhancements</target>
        </trans-unit>
        <trans-unit id="83a41a009718ba8b1b08f10745bce80452ba74f4" translate="yes" xml:space="preserve">
          <source>Enlarging an array: as above, but missing entries are filled with zeros:</source>
          <target state="translated">Расширение массива:как указано выше,но отсутствующие записи заполняются нулями:</target>
        </trans-unit>
        <trans-unit id="6c8cedd3caa9e42a775e9fa4b437c16d37b9b189" translate="yes" xml:space="preserve">
          <source>Ensure that the original contents of &lt;code&gt;intent(in)&lt;/code&gt; argument is preserved. Typically used in connection with &lt;code&gt;intent(in,out)&lt;/code&gt; attribute. F2PY creates an optional argument &lt;code&gt;overwrite_&amp;lt;argument name&amp;gt;&lt;/code&gt; with the default value &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b1cfaa83bf2eab645405941ddc61295f0ec9ed6" translate="yes" xml:space="preserve">
          <source>Ensure you are dealing with a well-behaved array (aligned, in machine byte-order and single-segment) of the correct type and number of dimensions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="31a314f110f22f052f3fa828713d2b2afb82f2d3" translate="yes" xml:space="preserve">
          <source>Ensures that the input or output matches the iteration dimensions exactly.</source>
          <target state="translated">Обеспечивает точное совпадение размеров входа или выхода с размерами итераций.</target>
        </trans-unit>
        <trans-unit id="2dfe05db0717fbae4e4c8fa997a9589c52cb7615" translate="yes" xml:space="preserve">
          <source>Enter your GitHub username and password (repeat contributors or advanced users can remove this step by connecting to GitHub with &lt;a href=&quot;gitwash/development_setup#set-up-and-configure-a-github-account&quot;&gt;SSH&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b3a6fa7af7b1354d47707152a8ad806c277ca980" translate="yes" xml:space="preserve">
          <source>Entropy bits in 32-bit unsigned integers. A scalar is returned if size is &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="translated">Биты энтропии в 32-битных целых числах без знака. Скаляр возвращается, если размер равен &lt;code&gt;None&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b0366a10ef9d6d3ef8c64dd51eeccb78bad1656a" translate="yes" xml:space="preserve">
          <source>Enumerated Types</source>
          <target state="translated">Перечисленные типы</target>
        </trans-unit>
        <trans-unit id="e4ac742e5d17c07aad844f80aaa89a24ed90f881" translate="yes" xml:space="preserve">
          <source>Equal to &lt;code&gt;np.prod(a.shape)&lt;/code&gt;, i.e., the product of the array&amp;rsquo;s dimensions.</source>
          <target state="translated">Равно &lt;code&gt;np.prod(a.shape)&lt;/code&gt; , то есть произведению размеров массива.</target>
        </trans-unit>
        <trans-unit id="2baf15a74d602a8791ff350bd57dfdac0a7e5d0e" translate="yes" xml:space="preserve">
          <source>Equations : as discussed in the &lt;strong&gt;Notes&lt;/strong&gt; section above, LaTeX formatting should be kept to a minimum. Often it&amp;rsquo;s possible to show equations as Python code or pseudo-code instead, which is much more readable in a terminal. For inline display use double backticks (like &lt;code&gt;y = np.sin(x)&lt;/code&gt;). For display with blank lines above and below, use a double colon and indent the code, like:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf762494180c61769e42e78eeea4e46c35cf2ea1" translate="yes" xml:space="preserve">
          <source>Equations can also be typeset underneath the math directive:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b75f0322b44b0e91520f5021f79c37a01c9e121d" translate="yes" xml:space="preserve">
          <source>Equivalent array function.</source>
          <target state="translated">Функция эквивалентного массива.</target>
        </trans-unit>
        <trans-unit id="a87b0e23e278c7d5e4e266e84f6badc171df142a" translate="yes" xml:space="preserve">
          <source>Equivalent array method.</source>
          <target state="translated">Метод эквивалентных массивов.</target>
        </trans-unit>
        <trans-unit id="1f85d863747d1d952d2380d6f9b0e6bc4a93c6e6" translate="yes" xml:space="preserve">
          <source>Equivalent function</source>
          <target state="translated">Эквивалентная функция</target>
        </trans-unit>
        <trans-unit id="ec48c460ff53cdf24f427482ba077c38b868cbe6" translate="yes" xml:space="preserve">
          <source>Equivalent function for ndarrays.</source>
          <target state="translated">Эквивалентная функция для ndarrays.</target>
        </trans-unit>
        <trans-unit id="47b16a4308d5d95c02caa6becddf32961f2329b1" translate="yes" xml:space="preserve">
          <source>Equivalent function in the NumPy module.</source>
          <target state="translated">Эквивалентная функция в модуле NumPy.</target>
        </trans-unit>
        <trans-unit id="3fda7b941f8c3619f7cfea52fae50b8fafb8283f" translate="yes" xml:space="preserve">
          <source>Equivalent function in the masked array module.</source>
          <target state="translated">Эквивалентная функция в массивном модуле.</target>
        </trans-unit>
        <trans-unit id="f3946f30225c2c4e0913895a299311328885ca06" translate="yes" xml:space="preserve">
          <source>Equivalent function in the top level NumPy module.</source>
          <target state="translated">Эквивалентная функция на верхнем уровне модуля NumPy.</target>
        </trans-unit>
        <trans-unit id="e79348928e8ad109f51e4deea501091d1124a6a4" translate="yes" xml:space="preserve">
          <source>Equivalent function in the top-level NumPy module.</source>
          <target state="translated">Эквивалентная функция в модуле NumPy верхнего уровня.</target>
        </trans-unit>
        <trans-unit id="f012d5b24482ab2f7fe8b36bc8562d2e06cf863d" translate="yes" xml:space="preserve">
          <source>Equivalent function in top-level NumPy module.</source>
          <target state="translated">Эквивалентная функция в модуле NumPy верхнего уровня.</target>
        </trans-unit>
        <trans-unit id="bb89f40e9f2471ebbc500654e8790a75f09e8680" translate="yes" xml:space="preserve">
          <source>Equivalent function with additional &lt;code&gt;loc&lt;/code&gt; and &lt;code&gt;scale&lt;/code&gt; arguments for setting the mean and standard deviation.</source>
          <target state="translated">Эквивалентная функция с дополнительными аргументами &lt;code&gt;loc&lt;/code&gt; и &lt;code&gt;scale&lt;/code&gt; для установки среднего и стандартного отклонения.</target>
        </trans-unit>
        <trans-unit id="3fec03561045f830610698c03c4e7cda301e9182" translate="yes" xml:space="preserve">
          <source>Equivalent functionality of &lt;a href=&quot;numpy.add#numpy.add&quot;&gt;&lt;code&gt;add&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Эквивалентная функциональность &lt;a href=&quot;numpy.add#numpy.add&quot;&gt; &lt;code&gt;add&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="73110076e1002b6b052fe8f385604bf0bd306ff9" translate="yes" xml:space="preserve">
          <source>Equivalent method in ndarray</source>
          <target state="translated">Эквивалентный метод in ndarray</target>
        </trans-unit>
        <trans-unit id="8b818de9537a41af44762a6ff8c93846b78172ce" translate="yes" xml:space="preserve">
          <source>Equivalent method on ndarray object.</source>
          <target state="translated">Эквивалентный метод на объекте ndarray.</target>
        </trans-unit>
        <trans-unit id="323a53e2d1eaaaf783c2a6e70d300696fee31861" translate="yes" xml:space="preserve">
          <source>Equivalent method when working on 1-D arrays</source>
          <target state="translated">Эквивалентный метод при работе с 1-D массивами</target>
        </trans-unit>
        <trans-unit id="198298ece560304dd9cecebb0a6c0ea2bb7a8bae" translate="yes" xml:space="preserve">
          <source>Equivalent method.</source>
          <target state="translated">Эквивалентный метод.</target>
        </trans-unit>
        <trans-unit id="46b37d7b2f299efd2d123535be0f6369732ae724" translate="yes" xml:space="preserve">
          <source>Equivalent ndarray method.</source>
          <target state="translated">Метод эквивалентной ндарреи.</target>
        </trans-unit>
        <trans-unit id="c920736bc05ff403de2ed423ca7f0b9c0f3adffb" translate="yes" xml:space="preserve">
          <source>Equivalent of Python &lt;code&gt;//&lt;/code&gt; operator.</source>
          <target state="translated">Эквивалент оператора Python &lt;code&gt;//&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="505d790701850092dede13a1225a7d0508099ca4" translate="yes" xml:space="preserve">
          <source>Equivalent of the MATLAB &lt;code&gt;rem&lt;/code&gt; function.</source>
          <target state="translated">Эквивалент функции MATLAB &lt;code&gt;rem&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4cdc670d68d8d05adfb0ac70f3d0ea4670424187" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;#c.PyDataType_FLAGCHK&quot;&gt;&lt;code&gt;PyDataType_FLAGCHK&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;dtype&lt;/em&gt;, &lt;a href=&quot;#c.NPY_ITEM_REFCOUNT&quot;&gt;&lt;code&gt;NPY_ITEM_REFCOUNT&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">Эквивалентен &lt;a href=&quot;#c.PyDataType_FLAGCHK&quot;&gt; &lt;code&gt;PyDataType_FLAGCHK&lt;/code&gt; &lt;/a&gt; ( &lt;em&gt;dtype&lt;/em&gt; , &lt;a href=&quot;#c.NPY_ITEM_REFCOUNT&quot;&gt; &lt;code&gt;NPY_ITEM_REFCOUNT&lt;/code&gt; &lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="fee6dbfeac3ceda19730d1e4e0704640fe75ab77" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;../generated/numpy.ndarray.all#numpy.ndarray.all&quot;&gt;&lt;code&gt;ndarray.all&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;axis&lt;/em&gt;). Return an array with True elements for every 1-d sub-array of &lt;code&gt;self&lt;/code&gt; defined by &lt;code&gt;axis&lt;/code&gt; in which all the elements are True.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="186b0b563cbae838de8810c69312c1eaa62ec654" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;../generated/numpy.ndarray.any#numpy.ndarray.any&quot;&gt;&lt;code&gt;ndarray.any&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;axis&lt;/em&gt;). Return an array with True elements for every 1-d sub-array of &lt;em&gt;self&lt;/em&gt; defined by &lt;em&gt;axis&lt;/em&gt; in which any of the elements are True.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7f442103406eabff3384a2561e7e4f3b1cb166d5" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;../generated/numpy.ndarray.argmax#numpy.ndarray.argmax&quot;&gt;&lt;code&gt;ndarray.argmax&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;axis&lt;/em&gt;). Return the index of the largest element of &lt;em&gt;self&lt;/em&gt; along &lt;em&gt;axis&lt;/em&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c75a0ddd8d31ee8d0abd1790434d076eb8e7770e" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;../generated/numpy.ndarray.argmin#numpy.ndarray.argmin&quot;&gt;&lt;code&gt;ndarray.argmin&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;axis&lt;/em&gt;). Return the index of the smallest element of &lt;em&gt;self&lt;/em&gt; along &lt;em&gt;axis&lt;/em&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a28fa5901ef493ca3cfeb35f1edc348f4ba70f84" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;../generated/numpy.ndarray.argpartition#numpy.ndarray.argpartition&quot;&gt;&lt;code&gt;ndarray.argpartition&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;ktharray&lt;/em&gt;, &lt;em&gt;axis&lt;/em&gt;, &lt;em&gt;kind&lt;/em&gt;). Return an array of indices such that selection of these indices along the given &lt;code&gt;axis&lt;/code&gt; would return a partitioned version of &lt;em&gt;self&lt;/em&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e47633b0ba2c1ea2ce577109feb2860147110ce7" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;../generated/numpy.ndarray.argsort#numpy.ndarray.argsort&quot;&gt;&lt;code&gt;ndarray.argsort&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;axis&lt;/em&gt;). Return an array of indices such that selection of these indices along the given &lt;code&gt;axis&lt;/code&gt; would return a sorted version of &lt;em&gt;self&lt;/em&gt;. If &lt;em&gt;self&lt;/em&gt; -&amp;gt;descr is a data-type with fields defined, then self-&amp;gt;descr-&amp;gt;names is used to determine the sort order. A comparison where the first field is equal will use the second field and so on. To alter the sort order of a structured array, create a new data-type with a different order of names and construct a view of the array with that new data-type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ab44c6dfb76d44a22896198277fc1dfa63e19a39" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;../generated/numpy.ndarray.byteswap#numpy.ndarray.byteswap&quot;&gt;&lt;code&gt;ndarray.byteswap&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;inplace&lt;/em&gt;). Return an array whose data area is byteswapped. If &lt;em&gt;inplace&lt;/em&gt; is non-zero, then do the byteswap inplace and return a reference to self. Otherwise, create a byteswapped copy and leave self unchanged.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="63580b7937fc29a8cc1a69e6dad1db1d8c003559" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;../generated/numpy.ndarray.choose#numpy.ndarray.choose&quot;&gt;&lt;code&gt;ndarray.choose&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;op&lt;/em&gt;, &lt;em&gt;ret&lt;/em&gt;, &lt;em&gt;clipmode&lt;/em&gt;). Create a new array by selecting elements from the sequence of arrays in &lt;em&gt;op&lt;/em&gt; based on the integer values in &lt;em&gt;self&lt;/em&gt;. The arrays must all be broadcastable to the same shape and the entries in &lt;em&gt;self&lt;/em&gt; should be between 0 and len(&lt;em&gt;op&lt;/em&gt;). The output is placed in &lt;em&gt;ret&lt;/em&gt; unless it is &lt;code&gt;NULL&lt;/code&gt; in which case a new output is created. The &lt;em&gt;clipmode&lt;/em&gt; argument determines behavior for when entries in &lt;em&gt;self&lt;/em&gt; are not between 0 and len(&lt;em&gt;op&lt;/em&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c3b2ea44431c439616093a9d5ebd74980360b6c" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;../generated/numpy.ndarray.clip#numpy.ndarray.clip&quot;&gt;&lt;code&gt;ndarray.clip&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;min&lt;/em&gt;, &lt;em&gt;max&lt;/em&gt;). Clip an array, &lt;em&gt;self&lt;/em&gt;, so that values larger than &lt;em&gt;max&lt;/em&gt; are fixed to &lt;em&gt;max&lt;/em&gt; and values less than &lt;em&gt;min&lt;/em&gt; are fixed to &lt;em&gt;min&lt;/em&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="48d43c27921059f0a7a10c6b7d33e4ffbe0ee4d6" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;../generated/numpy.ndarray.compress#numpy.ndarray.compress&quot;&gt;&lt;code&gt;ndarray.compress&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;condition&lt;/em&gt;, &lt;em&gt;axis&lt;/em&gt; ). Return the elements along &lt;em&gt;axis&lt;/em&gt; corresponding to elements of &lt;em&gt;condition&lt;/em&gt; that are true.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d9aa772deed9dfab23ce08d5aaf5096e5f550d9a" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;../generated/numpy.ndarray.conjugate#numpy.ndarray.conjugate&quot;&gt;&lt;code&gt;ndarray.conjugate&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;). Return the complex conjugate of &lt;em&gt;self&lt;/em&gt;. If &lt;em&gt;self&lt;/em&gt; is not of complex data type, then return &lt;em&gt;self&lt;/em&gt; with a reference.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e0619959acd54807feb74d65e4fc49e0c39d7c4" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;../generated/numpy.ndarray.copy#numpy.ndarray.copy&quot;&gt;&lt;code&gt;ndarray.copy&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;fortran&lt;/em&gt;). Make a copy of the &lt;em&gt;old&lt;/em&gt; array. The returned array is always aligned and writeable with data interpreted the same as the old array. If &lt;em&gt;order&lt;/em&gt; is &lt;a href=&quot;#c.NPY_CORDER&quot;&gt;&lt;code&gt;NPY_CORDER&lt;/code&gt;&lt;/a&gt;, then a C-style contiguous array is returned. If &lt;em&gt;order&lt;/em&gt; is &lt;a href=&quot;#c.NPY_FORTRANORDER&quot;&gt;&lt;code&gt;NPY_FORTRANORDER&lt;/code&gt;&lt;/a&gt;, then a Fortran-style contiguous array is returned. If &lt;em&gt;order is&lt;/em&gt;&lt;a href=&quot;#c.NPY_ANYORDER&quot;&gt;&lt;code&gt;NPY_ANYORDER&lt;/code&gt;&lt;/a&gt;, then the array returned is Fortran-style contiguous only if the old one is; otherwise, it is C-style contiguous.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a0c3cd7eb6fa6d356c2901bb9f6d3ba8cab9d89e" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;../generated/numpy.ndarray.cumprod#numpy.ndarray.cumprod&quot;&gt;&lt;code&gt;ndarray.cumprod&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;axis&lt;/em&gt;, &lt;em&gt;rtype&lt;/em&gt;). Return 1-d cumulative products of elements in &lt;code&gt;self&lt;/code&gt; along &lt;code&gt;axis&lt;/code&gt;. Perform the product after converting data to data type &lt;code&gt;rtype&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb82bf0e510f4d18fb05a89ac99cab0f063a9efd" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;../generated/numpy.ndarray.cumsum#numpy.ndarray.cumsum&quot;&gt;&lt;code&gt;ndarray.cumsum&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;axis&lt;/em&gt;, &lt;em&gt;rtype&lt;/em&gt;). Return cumulative 1-d sums of elements in &lt;em&gt;self&lt;/em&gt; along &lt;em&gt;axis&lt;/em&gt;. Perform the sum after converting data to data type &lt;em&gt;rtype&lt;/em&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="147baa3bca301ee2641ca21a0eba77e7a019e912" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;../generated/numpy.ndarray.diagonal#numpy.ndarray.diagonal&quot;&gt;&lt;code&gt;ndarray.diagonal&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;offset&lt;/em&gt;, &lt;em&gt;axis1&lt;/em&gt;, &lt;em&gt;axis2&lt;/em&gt; ). Return the &lt;em&gt;offset&lt;/em&gt; diagonals of the 2-d arrays defined by &lt;em&gt;axis1&lt;/em&gt; and &lt;em&gt;axis2&lt;/em&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a8dee6eb2f62046701960813747a2ce4d3c4eb9" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;../generated/numpy.ndarray.flatten#numpy.ndarray.flatten&quot;&gt;&lt;code&gt;ndarray.flatten&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;order&lt;/em&gt;). Return a 1-d copy of the array. If &lt;em&gt;order&lt;/em&gt; is &lt;a href=&quot;#c.NPY_FORTRANORDER&quot;&gt;&lt;code&gt;NPY_FORTRANORDER&lt;/code&gt;&lt;/a&gt; the elements are scanned out in Fortran order (first-dimension varies the fastest). If &lt;em&gt;order&lt;/em&gt; is &lt;a href=&quot;#c.NPY_CORDER&quot;&gt;&lt;code&gt;NPY_CORDER&lt;/code&gt;&lt;/a&gt;, the elements of &lt;code&gt;self&lt;/code&gt; are scanned in C-order (last dimension varies the fastest). If &lt;em&gt;order&lt;/em&gt;&lt;a href=&quot;#c.NPY_ANYORDER&quot;&gt;&lt;code&gt;NPY_ANYORDER&lt;/code&gt;&lt;/a&gt;, then the result of &lt;a href=&quot;#c.PyArray_ISFORTRAN&quot;&gt;&lt;code&gt;PyArray_ISFORTRAN&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;) is used to determine which order to flatten.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="55b8b003a6301beae59c2337672b7d873a7a30b4" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;../generated/numpy.ndarray.getfield#numpy.ndarray.getfield&quot;&gt;&lt;code&gt;ndarray.getfield&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;dtype&lt;/em&gt;, &lt;em&gt;offset&lt;/em&gt;). This function &lt;a href=&quot;https://docs.python.org/3/c-api/intro.html?reference-count-details&quot;&gt;steals a reference&lt;/a&gt; to &lt;code&gt;PyArray_Descr&lt;/code&gt; and returns a new array of the given &lt;code&gt;dtype&lt;/code&gt; using the data in the current array at a specified &lt;code&gt;offset&lt;/code&gt; in bytes. The &lt;code&gt;offset&lt;/code&gt; plus the itemsize of the new array type must be less than &lt;code&gt;self
-&amp;gt;descr-&amp;gt;elsize&lt;/code&gt; or an error is raised. The same shape and strides as the original array are used. Therefore, this function has the effect of returning a field from a structured array. But, it can also be used to select specific bytes or groups of bytes from any array type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e4d22054d186b1f1ff23d804468173438990f202" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;../generated/numpy.ndarray.max#numpy.ndarray.max&quot;&gt;&lt;code&gt;ndarray.max&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;axis&lt;/em&gt;). Returns the largest element of &lt;em&gt;self&lt;/em&gt; along the given &lt;em&gt;axis&lt;/em&gt;. When the result is a single element, returns a numpy scalar instead of an ndarray.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d38f65f39197f34563c038f540e3b44a0d2f6ba" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;../generated/numpy.ndarray.mean#numpy.ndarray.mean&quot;&gt;&lt;code&gt;ndarray.mean&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;axis&lt;/em&gt;, &lt;em&gt;rtype&lt;/em&gt;). Returns the mean of the elements along the given &lt;em&gt;axis&lt;/em&gt;, using the enumerated type &lt;em&gt;rtype&lt;/em&gt; as the data type to sum in. Default sum behavior is obtained using &lt;a href=&quot;dtype#c.NPY_NOTYPE&quot;&gt;&lt;code&gt;NPY_NOTYPE&lt;/code&gt;&lt;/a&gt; for &lt;em&gt;rtype&lt;/em&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5cb706fff5203c363163a51434cc7adef7ffc29f" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;../generated/numpy.ndarray.min#numpy.ndarray.min&quot;&gt;&lt;code&gt;ndarray.min&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;axis&lt;/em&gt;). Return the smallest element of &lt;em&gt;self&lt;/em&gt; along the given &lt;em&gt;axis&lt;/em&gt;. When the result is a single element, returns a numpy scalar instead of an ndarray.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d5d5265b484ee101637dbdbbeb657d0f5063ebd7" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;../generated/numpy.ndarray.nonzero#numpy.ndarray.nonzero&quot;&gt;&lt;code&gt;ndarray.nonzero&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;). Returns a tuple of index arrays that select elements of &lt;em&gt;self&lt;/em&gt; that are nonzero. If (nd= &lt;a href=&quot;#c.PyArray_NDIM&quot;&gt;&lt;code&gt;PyArray_NDIM&lt;/code&gt;&lt;/a&gt; ( &lt;code&gt;self&lt;/code&gt; ))==1, then a single index array is returned. The index arrays have data type &lt;a href=&quot;dtype#c.NPY_INTP&quot;&gt;&lt;code&gt;NPY_INTP&lt;/code&gt;&lt;/a&gt;. If a tuple is returned (nd</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="404bdbd3b8a1b96a6c46adc73debf37dfd647756" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;../generated/numpy.ndarray.partition#numpy.ndarray.partition&quot;&gt;&lt;code&gt;ndarray.partition&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;ktharray&lt;/em&gt;, &lt;em&gt;axis&lt;/em&gt;, &lt;em&gt;kind&lt;/em&gt;). Partitions the array so that the values of the element indexed by &lt;em&gt;ktharray&lt;/em&gt; are in the positions they would be if the array is fully sorted and places all elements smaller than the kth before and all elements equal or greater after the kth element. The ordering of all elements within the partitions is undefined. If &lt;em&gt;self&lt;/em&gt;-&amp;gt;descr is a data-type with fields defined, then self-&amp;gt;descr-&amp;gt;names is used to determine the sort order. A comparison where the first field is equal will use the second field and so on. To alter the sort order of a structured array, create a new data-type with a different order of names and construct a view of the array with that new data-type. Returns zero on success and -1 on failure.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c549a447e1ab678178d605e0abed17f0cd61d094" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;../generated/numpy.ndarray.prod#numpy.ndarray.prod&quot;&gt;&lt;code&gt;ndarray.prod&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;axis&lt;/em&gt;, &lt;em&gt;rtype&lt;/em&gt;). Return 1-d products of elements in &lt;em&gt;self&lt;/em&gt; along &lt;em&gt;axis&lt;/em&gt;. Perform the product after converting data to data type &lt;em&gt;rtype&lt;/em&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="50e5592224385bd5a5a47c4e8db5171ddcc2ccb3" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;../generated/numpy.ndarray.ptp#numpy.ndarray.ptp&quot;&gt;&lt;code&gt;ndarray.ptp&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;axis&lt;/em&gt;). Return the difference between the largest element of &lt;em&gt;self&lt;/em&gt; along &lt;em&gt;axis&lt;/em&gt; and the smallest element of &lt;em&gt;self&lt;/em&gt; along &lt;em&gt;axis&lt;/em&gt;. When the result is a single element, returns a numpy scalar instead of an ndarray.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8518311e2b7b6ac094e9b94bd62860a33aa8bf47" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;../generated/numpy.ndarray.repeat#numpy.ndarray.repeat&quot;&gt;&lt;code&gt;ndarray.repeat&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;op&lt;/em&gt;, &lt;em&gt;axis&lt;/em&gt;). Copy the elements of &lt;em&gt;self&lt;/em&gt;, &lt;em&gt;op&lt;/em&gt; times along the given &lt;em&gt;axis&lt;/em&gt;. Either &lt;em&gt;op&lt;/em&gt; is a scalar integer or a sequence of length &lt;em&gt;self&lt;/em&gt; -&amp;gt;dimensions[ &lt;em&gt;axis&lt;/em&gt; ] indicating how many times to repeat each item along the axis.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d8cf34534cc24beb73c77b84496c087a2293d28" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;../generated/numpy.ndarray.reshape#numpy.ndarray.reshape&quot;&gt;&lt;code&gt;ndarray.reshape&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;shape&lt;/em&gt;) where &lt;em&gt;shape&lt;/em&gt; is a sequence. Converts &lt;em&gt;shape&lt;/em&gt; to a &lt;a href=&quot;types-and-structures#c.PyArray_Dims&quot;&gt;&lt;code&gt;PyArray_Dims&lt;/code&gt;&lt;/a&gt; structure and calls &lt;a href=&quot;#c.PyArray_Newshape&quot;&gt;&lt;code&gt;PyArray_Newshape&lt;/code&gt;&lt;/a&gt; internally. For back-ward compatibility &amp;ndash; Not recommended</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="638611d108c9a9ce025011cf0fefaaa249e16115" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;../generated/numpy.ndarray.resize#numpy.ndarray.resize&quot;&gt;&lt;code&gt;ndarray.resize&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;newshape&lt;/em&gt;, refcheck &lt;code&gt;=&lt;/code&gt;&lt;em&gt;refcheck&lt;/em&gt;, order= fortran ). This function only works on single-segment arrays. It changes the shape of &lt;em&gt;self&lt;/em&gt; inplace and will reallocate the memory for &lt;em&gt;self&lt;/em&gt; if &lt;em&gt;newshape&lt;/em&gt; has a different total number of elements then the old shape. If reallocation is necessary, then &lt;em&gt;self&lt;/em&gt; must own its data, have &lt;em&gt;self&lt;/em&gt; - &lt;code&gt;&amp;gt;base==NULL&lt;/code&gt;, have &lt;em&gt;self&lt;/em&gt; - &lt;code&gt;&amp;gt;weakrefs==NULL&lt;/code&gt;, and (unless refcheck is 0) not be referenced by any other array. The fortran argument can be &lt;a href=&quot;#c.NPY_ANYORDER&quot;&gt;&lt;code&gt;NPY_ANYORDER&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#c.NPY_CORDER&quot;&gt;&lt;code&gt;NPY_CORDER&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&quot;#c.NPY_FORTRANORDER&quot;&gt;&lt;code&gt;NPY_FORTRANORDER&lt;/code&gt;&lt;/a&gt;. It currently has no effect. Eventually it could be used to determine how the resize operation should view the data when constructing a differently-dimensioned array. Returns None on success and NULL on error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="54966ab6c4e29db133f8104359b27e76b17c469a" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;../generated/numpy.ndarray.round#numpy.ndarray.round&quot;&gt;&lt;code&gt;ndarray.round&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;decimals&lt;/em&gt;, &lt;em&gt;out&lt;/em&gt;). Returns the array with elements rounded to the nearest decimal place. The decimal place is defined as the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec01042d1895112ebd1035318c0017010dd4e832" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;../generated/numpy.ndarray.searchsorted#numpy.ndarray.searchsorted&quot;&gt;&lt;code&gt;ndarray.searchsorted&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;values&lt;/em&gt;, &lt;em&gt;side&lt;/em&gt;, &lt;em&gt;perm&lt;/em&gt;). Assuming &lt;em&gt;self&lt;/em&gt; is a 1-d array in ascending order, then the output is an array of indices the same shape as &lt;em&gt;values&lt;/em&gt; such that, if the elements in &lt;em&gt;values&lt;/em&gt; were inserted before the indices, the order of &lt;em&gt;self&lt;/em&gt; would be preserved. No checking is done on whether or not self is in ascending order.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cef7e5af80a428c5254d2fef178ea505c8c19ead" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;../generated/numpy.ndarray.setfield#numpy.ndarray.setfield&quot;&gt;&lt;code&gt;ndarray.setfield&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;val&lt;/em&gt;, &lt;em&gt;dtype&lt;/em&gt;, &lt;em&gt;offset&lt;/em&gt; ). Set the field starting at &lt;em&gt;offset&lt;/em&gt; in bytes and of the given &lt;em&gt;dtype&lt;/em&gt; to &lt;em&gt;val&lt;/em&gt;. The &lt;em&gt;offset&lt;/em&gt; plus &lt;em&gt;dtype&lt;/em&gt; -&amp;gt;elsize must be less than &lt;em&gt;self&lt;/em&gt; -&amp;gt;descr-&amp;gt;elsize or an error is raised. Otherwise, the &lt;em&gt;val&lt;/em&gt; argument is converted to an array and copied into the field pointed to. If necessary, the elements of &lt;em&gt;val&lt;/em&gt; are repeated to fill the destination array, But, the number of elements in the destination must be an integer multiple of the number of elements in &lt;em&gt;val&lt;/em&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a3c3255647be24898e308dd8ac21dadefba0c0a" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;../generated/numpy.ndarray.sort#numpy.ndarray.sort&quot;&gt;&lt;code&gt;ndarray.sort&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;axis&lt;/em&gt;, &lt;em&gt;kind&lt;/em&gt;). Return an array with the items of &lt;em&gt;self&lt;/em&gt; sorted along &lt;em&gt;axis&lt;/em&gt;. The array is sorted using the algorithm denoted by &lt;em&gt;kind&lt;/em&gt;, which is an integer/enum pointing to the type of sorting algorithms used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="27a6b11953d97b15697fad15568b370248cfeb20" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;../generated/numpy.ndarray.squeeze#numpy.ndarray.squeeze&quot;&gt;&lt;code&gt;ndarray.squeeze&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;). Return a new view of &lt;em&gt;self&lt;/em&gt; with all of the dimensions of length 1 removed from the shape.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="862af43d2c6b0a55c85e6d3a6b411873c5226258" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;../generated/numpy.ndarray.std#numpy.ndarray.std&quot;&gt;&lt;code&gt;ndarray.std&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;axis&lt;/em&gt;, &lt;em&gt;rtype&lt;/em&gt;). Return the standard deviation using data along &lt;em&gt;axis&lt;/em&gt; converted to data type &lt;em&gt;rtype&lt;/em&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e292f5ba0e99a5f16bcc2829ab5d9470ad0f4d13" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;../generated/numpy.ndarray.sum#numpy.ndarray.sum&quot;&gt;&lt;code&gt;ndarray.sum&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;axis&lt;/em&gt;, &lt;em&gt;rtype&lt;/em&gt;). Return 1-d vector sums of elements in &lt;em&gt;self&lt;/em&gt; along &lt;em&gt;axis&lt;/em&gt;. Perform the sum after converting data to data type &lt;em&gt;rtype&lt;/em&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="246fe22eecb98bac6eed58c36c5c002cc77b5ad9" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;../generated/numpy.ndarray.swapaxes#numpy.ndarray.swapaxes&quot;&gt;&lt;code&gt;ndarray.swapaxes&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;a1&lt;/em&gt;, &lt;em&gt;a2&lt;/em&gt;). The returned array is a new view of the data in &lt;em&gt;self&lt;/em&gt; with the given axes, &lt;em&gt;a1&lt;/em&gt; and &lt;em&gt;a2&lt;/em&gt;, swapped.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a390cc4ddaa841114316d31bea2078c5a16e1cf6" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;../generated/numpy.ndarray.take#numpy.ndarray.take&quot;&gt;&lt;code&gt;ndarray.take&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;indices&lt;/em&gt;, &lt;em&gt;axis&lt;/em&gt;, &lt;em&gt;ret&lt;/em&gt;, &lt;em&gt;clipmode&lt;/em&gt;) except &lt;em&gt;axis&lt;/em&gt; =None in Python is obtained by setting &lt;em&gt;axis&lt;/em&gt; = &lt;a href=&quot;#c.NPY_MAXDIMS&quot;&gt;&lt;code&gt;NPY_MAXDIMS&lt;/code&gt;&lt;/a&gt; in C. Extract the items from self indicated by the integer-valued &lt;em&gt;indices&lt;/em&gt; along the given &lt;em&gt;axis.&lt;/em&gt; The clipmode argument can be &lt;a href=&quot;#c.NPY_RAISE&quot;&gt;&lt;code&gt;NPY_RAISE&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#c.NPY_WRAP&quot;&gt;&lt;code&gt;NPY_WRAP&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&quot;#c.NPY_CLIP&quot;&gt;&lt;code&gt;NPY_CLIP&lt;/code&gt;&lt;/a&gt; to indicate what to do with out-of-bound indices. The &lt;em&gt;ret&lt;/em&gt; argument can specify an output array rather than having one created internally.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7206ce6e4a585b31fefc3d225467d40239cdb106" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;../generated/numpy.ndarray.tobytes#numpy.ndarray.tobytes&quot;&gt;&lt;code&gt;ndarray.tobytes&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;order&lt;/em&gt;). Return the bytes of this array in a Python string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="171c56ed06f2b8f601e0836c87ae1d6a49d81221" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;../generated/numpy.ndarray.tolist#numpy.ndarray.tolist&quot;&gt;&lt;code&gt;ndarray.tolist&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;). Return a nested Python list from &lt;em&gt;self&lt;/em&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d77e40fb42cd93f8c483ffa7d7241b393d0e4ae3" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;../generated/numpy.ndarray.trace#numpy.ndarray.trace&quot;&gt;&lt;code&gt;ndarray.trace&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;offset&lt;/em&gt;, &lt;em&gt;axis1&lt;/em&gt;, &lt;em&gt;axis2&lt;/em&gt;, &lt;em&gt;rtype&lt;/em&gt;). Return the sum (using &lt;em&gt;rtype&lt;/em&gt; as the data type of summation) over the &lt;em&gt;offset&lt;/em&gt; diagonal elements of the 2-d arrays defined by &lt;em&gt;axis1&lt;/em&gt; and &lt;em&gt;axis2&lt;/em&gt; variables. A positive offset chooses diagonals above the main diagonal. A negative offset selects diagonals below the main diagonal.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9dd34a2c83d97a0f513db9230449465e813314c6" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;../generated/numpy.ndarray.transpose#numpy.ndarray.transpose&quot;&gt;&lt;code&gt;ndarray.transpose&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;permute&lt;/em&gt;). Permute the axes of the ndarray object &lt;em&gt;self&lt;/em&gt; according to the data structure &lt;em&gt;permute&lt;/em&gt; and return the result. If &lt;em&gt;permute&lt;/em&gt; is &lt;code&gt;NULL&lt;/code&gt;, then the resulting array has its axes reversed. For example if &lt;em&gt;self&lt;/em&gt; has shape</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b13fb477c1c38e7bfcb6352e8ffc5f4bb87dd24f" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;../generated/numpy.ndarray.view#numpy.ndarray.view&quot;&gt;&lt;code&gt;ndarray.view&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;dtype&lt;/em&gt;). Return a new view of the array &lt;em&gt;self&lt;/em&gt; as possibly a different data-type, &lt;em&gt;dtype&lt;/em&gt;, and different array subclass &lt;em&gt;ptype&lt;/em&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e3ecf3d3dd70eafb08906a1ad49ac399520f10f8" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;generated/numpy.ndarray.all#numpy.ndarray.all&quot;&gt;&lt;code&gt;ndarray.all&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;axis&lt;/em&gt;). Return an array with True elements for every 1-d sub-array of &lt;code&gt;self&lt;/code&gt; defined by &lt;code&gt;axis&lt;/code&gt; in which all the elements are True.</source>
          <target state="translated">Эквивалентен &lt;a href=&quot;generated/numpy.ndarray.all#numpy.ndarray.all&quot;&gt; &lt;code&gt;ndarray.all&lt;/code&gt; &lt;/a&gt; ( &lt;em&gt;self&lt;/em&gt; , &lt;em&gt;axis&lt;/em&gt; ). Возвращает массив с элементами True для каждого 1-мерного подмассива &lt;code&gt;self&lt;/code&gt; , определенного &lt;code&gt;axis&lt;/code&gt; в которой все элементы имеют значение True.</target>
        </trans-unit>
        <trans-unit id="efd8289812e23cf1b7df07369198edcd67ccd665" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;generated/numpy.ndarray.any#numpy.ndarray.any&quot;&gt;&lt;code&gt;ndarray.any&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;axis&lt;/em&gt;). Return an array with True elements for every 1-d sub-array of &lt;em&gt;self&lt;/em&gt; defined by &lt;em&gt;axis&lt;/em&gt; in which any of the elements are True.</source>
          <target state="translated">Эквивалентен &lt;a href=&quot;generated/numpy.ndarray.any#numpy.ndarray.any&quot;&gt; &lt;code&gt;ndarray.any&lt;/code&gt; &lt;/a&gt; ( &lt;em&gt;self&lt;/em&gt; , &lt;em&gt;axis&lt;/em&gt; ). Возвращает массив с элементами True для каждого 1-мерного подмассива &lt;em&gt;self,&lt;/em&gt; определенного &lt;em&gt;осью,&lt;/em&gt; в которой любой из элементов имеет значение True.</target>
        </trans-unit>
        <trans-unit id="ea109271e7fe639649aeaaf2a0b5dd56ecc23fcf" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;generated/numpy.ndarray.argmax#numpy.ndarray.argmax&quot;&gt;&lt;code&gt;ndarray.argmax&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;axis&lt;/em&gt;). Return the index of the largest element of &lt;em&gt;self&lt;/em&gt; along &lt;em&gt;axis&lt;/em&gt;.</source>
          <target state="translated">Эквивалентен &lt;a href=&quot;generated/numpy.ndarray.argmax#numpy.ndarray.argmax&quot;&gt; &lt;code&gt;ndarray.argmax&lt;/code&gt; &lt;/a&gt; ( &lt;em&gt;self&lt;/em&gt; , &lt;em&gt;axis&lt;/em&gt; ). Вернуть индекс самого большого элемента &lt;em&gt;self&lt;/em&gt; вдоль &lt;em&gt;оси&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="9e5a451b453bc4aefcc71e37cd8b0e84168886e8" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;generated/numpy.ndarray.argmin#numpy.ndarray.argmin&quot;&gt;&lt;code&gt;ndarray.argmin&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;axis&lt;/em&gt;). Return the index of the smallest element of &lt;em&gt;self&lt;/em&gt; along &lt;em&gt;axis&lt;/em&gt;.</source>
          <target state="translated">Эквивалентен &lt;a href=&quot;generated/numpy.ndarray.argmin#numpy.ndarray.argmin&quot;&gt; &lt;code&gt;ndarray.argmin&lt;/code&gt; &lt;/a&gt; ( &lt;em&gt;self&lt;/em&gt; , &lt;em&gt;axis&lt;/em&gt; ). Вернуть индекс самого маленького элемента &lt;em&gt;self&lt;/em&gt; вдоль &lt;em&gt;оси&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="cf7a1a44ff60373e9f731b7ce7e339177577c561" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;generated/numpy.ndarray.argpartition#numpy.ndarray.argpartition&quot;&gt;&lt;code&gt;ndarray.argpartition&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;ktharray&lt;/em&gt;, &lt;em&gt;axis&lt;/em&gt;, &lt;em&gt;kind&lt;/em&gt;). Return an array of indices such that selection of these indices along the given &lt;code&gt;axis&lt;/code&gt; would return a partitioned version of &lt;em&gt;self&lt;/em&gt;.</source>
          <target state="translated">Эквивалентен &lt;a href=&quot;generated/numpy.ndarray.argpartition#numpy.ndarray.argpartition&quot;&gt; &lt;code&gt;ndarray.argpartition&lt;/code&gt; &lt;/a&gt; ( &lt;em&gt;self&lt;/em&gt; , &lt;em&gt;ktharray&lt;/em&gt; , &lt;em&gt;axis&lt;/em&gt; , &lt;em&gt;kind&lt;/em&gt; ). Возвратите массив индексов таким образом, чтобы выбор этих индексов по заданной &lt;code&gt;axis&lt;/code&gt; возвращал секционированную версию &lt;em&gt;self&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="d75ff39235401fe4390dbb04fd226bfccafd46e5" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;generated/numpy.ndarray.argsort#numpy.ndarray.argsort&quot;&gt;&lt;code&gt;ndarray.argsort&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;axis&lt;/em&gt;). Return an array of indices such that selection of these indices along the given &lt;code&gt;axis&lt;/code&gt; would return a sorted version of &lt;em&gt;self&lt;/em&gt;. If &lt;em&gt;self&lt;/em&gt; -&amp;gt;descr is a data-type with fields defined, then self-&amp;gt;descr-&amp;gt;names is used to determine the sort order. A comparison where the first field is equal will use the second field and so on. To alter the sort order of a structured array, create a new data-type with a different order of names and construct a view of the array with that new data-type.</source>
          <target state="translated">Эквивалентен &lt;a href=&quot;generated/numpy.ndarray.argsort#numpy.ndarray.argsort&quot;&gt; &lt;code&gt;ndarray.argsort&lt;/code&gt; &lt;/a&gt; ( &lt;em&gt;self&lt;/em&gt; , &lt;em&gt;axis&lt;/em&gt; ). Вернуть массив индексов, чтобы выбор этих индексов по заданной &lt;code&gt;axis&lt;/code&gt; возвращал отсортированную версию &lt;em&gt;self&lt;/em&gt; . Если &lt;em&gt;self&lt;/em&gt; -&amp;gt; descr является типом данных с определенными полями, то self-&amp;gt; descr-&amp;gt; names используется для определения порядка сортировки. При сравнении, в котором первое поле равно, будет использоваться второе поле и так далее. Чтобы изменить порядок сортировки структурированного массива, создайте новый тип данных с другим порядком имен и создайте представление массива с этим новым типом данных.</target>
        </trans-unit>
        <trans-unit id="6daadea926a9bfb0a800c60a35b85b50c40374a1" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;generated/numpy.ndarray.byteswap#numpy.ndarray.byteswap&quot;&gt;&lt;code&gt;ndarray.byteswap&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;inplace&lt;/em&gt;). Return an array whose data area is byteswapped. If &lt;em&gt;inplace&lt;/em&gt; is non-zero, then do the byteswap inplace and return a reference to self. Otherwise, create a byteswapped copy and leave self unchanged.</source>
          <target state="translated">Эквивалентен &lt;a href=&quot;generated/numpy.ndarray.byteswap#numpy.ndarray.byteswap&quot;&gt; &lt;code&gt;ndarray.byteswap&lt;/code&gt; &lt;/a&gt; ( &lt;em&gt;self&lt;/em&gt; , &lt;em&gt;inplace&lt;/em&gt; ). Вернуть массив, область данных которого поменяна байтами. Если &lt;em&gt;inplace&lt;/em&gt; не равно нулю, тогда выполните замену байтов на месте и верните ссылку на self. В противном случае создайте копию с заменой байта и оставьте self без изменений.</target>
        </trans-unit>
        <trans-unit id="2ab0b0009765a5d262f32c0eec580607299fc96a" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;generated/numpy.ndarray.choose#numpy.ndarray.choose&quot;&gt;&lt;code&gt;ndarray.choose&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;op&lt;/em&gt;, &lt;em&gt;ret&lt;/em&gt;, &lt;em&gt;clipmode&lt;/em&gt;). Create a new array by selecting elements from the sequence of arrays in &lt;em&gt;op&lt;/em&gt; based on the integer values in &lt;em&gt;self&lt;/em&gt;. The arrays must all be broadcastable to the same shape and the entries in &lt;em&gt;self&lt;/em&gt; should be between 0 and len(&lt;em&gt;op&lt;/em&gt;). The output is placed in &lt;em&gt;ret&lt;/em&gt; unless it is &lt;code&gt;NULL&lt;/code&gt; in which case a new output is created. The &lt;em&gt;clipmode&lt;/em&gt; argument determines behavior for when entries in &lt;em&gt;self&lt;/em&gt; are not between 0 and len(&lt;em&gt;op&lt;/em&gt;).</source>
          <target state="translated">Эквивалентно &lt;a href=&quot;generated/numpy.ndarray.choose#numpy.ndarray.choose&quot;&gt; &lt;code&gt;ndarray.choose&lt;/code&gt; &lt;/a&gt; ( &lt;em&gt;self&lt;/em&gt; , &lt;em&gt;op&lt;/em&gt; , &lt;em&gt;ret&lt;/em&gt; , &lt;em&gt;clipmode&lt;/em&gt; ). Создайте новый массив, выбрав элементы из последовательности массивов в &lt;em&gt;op&lt;/em&gt; на основе целочисленных значений в &lt;em&gt;self&lt;/em&gt; . Все массивы должны транслироваться в одну и ту же форму, а записи в &lt;em&gt;self&lt;/em&gt; должны быть от 0 до len ( &lt;em&gt;op&lt;/em&gt; ). Вывод помещается в &lt;em&gt;ret,&lt;/em&gt; если он не равен &lt;code&gt;NULL&lt;/code&gt; ,и в этом случае создается новый вывод. &lt;em&gt;Clipmode&lt;/em&gt; аргумент определяет поведение для того, когда записи в &lt;em&gt;себя&lt;/em&gt; не между 0 и LEN ( &lt;em&gt;ор&lt;/em&gt; ).</target>
        </trans-unit>
        <trans-unit id="07498cd87fe2ef12a2b26de127164c39b4bd9e44" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;generated/numpy.ndarray.clip#numpy.ndarray.clip&quot;&gt;&lt;code&gt;ndarray.clip&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;min&lt;/em&gt;, &lt;em&gt;max&lt;/em&gt;). Clip an array, &lt;em&gt;self&lt;/em&gt;, so that values larger than &lt;em&gt;max&lt;/em&gt; are fixed to &lt;em&gt;max&lt;/em&gt; and values less than &lt;em&gt;min&lt;/em&gt; are fixed to &lt;em&gt;min&lt;/em&gt;.</source>
          <target state="translated">Эквивалентно &lt;a href=&quot;generated/numpy.ndarray.clip#numpy.ndarray.clip&quot;&gt; &lt;code&gt;ndarray.clip&lt;/code&gt; &lt;/a&gt; ( &lt;em&gt;self&lt;/em&gt; , &lt;em&gt;min&lt;/em&gt; , &lt;em&gt;max&lt;/em&gt; ). Обрезать массив &lt;em&gt;self&lt;/em&gt; , чтобы значения больше &lt;em&gt;max&lt;/em&gt; фиксировались на &lt;em&gt;max,&lt;/em&gt; а значения меньше &lt;em&gt;min&lt;/em&gt; - на &lt;em&gt;min&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="c163c568fd35392b35f7cb27b6a29f0e9cbd90da" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;generated/numpy.ndarray.compress#numpy.ndarray.compress&quot;&gt;&lt;code&gt;ndarray.compress&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;condition&lt;/em&gt;, &lt;em&gt;axis&lt;/em&gt; ). Return the elements along &lt;em&gt;axis&lt;/em&gt; corresponding to elements of &lt;em&gt;condition&lt;/em&gt; that are true.</source>
          <target state="translated">Эквивалентно &lt;a href=&quot;generated/numpy.ndarray.compress#numpy.ndarray.compress&quot;&gt; &lt;code&gt;ndarray.compress&lt;/code&gt; &lt;/a&gt; ( &lt;em&gt;self&lt;/em&gt; , &lt;em&gt;condition&lt;/em&gt; , &lt;em&gt;axis&lt;/em&gt; ). Вернуть элементы по &lt;em&gt;оси,&lt;/em&gt; соответствующие элементам &lt;em&gt;условия,&lt;/em&gt; которые являются истинными.</target>
        </trans-unit>
        <trans-unit id="dd9acb1c9e137920376909d2dadce0362beab80c" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;generated/numpy.ndarray.conjugate#numpy.ndarray.conjugate&quot;&gt;&lt;code&gt;ndarray.conjugate&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;). Return the complex conjugate of &lt;em&gt;self&lt;/em&gt;. If &lt;em&gt;self&lt;/em&gt; is not of complex data type, then return &lt;em&gt;self&lt;/em&gt; with a reference.</source>
          <target state="translated">Эквивалентно &lt;a href=&quot;generated/numpy.ndarray.conjugate#numpy.ndarray.conjugate&quot;&gt; &lt;code&gt;ndarray.conjugate&lt;/code&gt; &lt;/a&gt; ( &lt;em&gt;self&lt;/em&gt; ). Верните комплексное сопряжение &lt;em&gt;себя&lt;/em&gt; . Если &lt;em&gt;self&lt;/em&gt; не относится к сложному типу данных, верните &lt;em&gt;self&lt;/em&gt; со ссылкой.</target>
        </trans-unit>
        <trans-unit id="cf40d04106c5d52e1884e99b3a37b71d8a81e331" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;generated/numpy.ndarray.copy#numpy.ndarray.copy&quot;&gt;&lt;code&gt;ndarray.copy&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;fortran&lt;/em&gt;). Make a copy of the &lt;em&gt;old&lt;/em&gt; array. The returned array is always aligned and writeable with data interpreted the same as the old array. If &lt;em&gt;order&lt;/em&gt; is &lt;a href=&quot;#c.NPY_CORDER&quot;&gt;&lt;code&gt;NPY_CORDER&lt;/code&gt;&lt;/a&gt;, then a C-style contiguous array is returned. If &lt;em&gt;order&lt;/em&gt; is &lt;a href=&quot;#c.NPY_FORTRANORDER&quot;&gt;&lt;code&gt;NPY_FORTRANORDER&lt;/code&gt;&lt;/a&gt;, then a Fortran-style contiguous array is returned. If &lt;em&gt;order is&lt;/em&gt;&lt;a href=&quot;#c.NPY_ANYORDER&quot;&gt;&lt;code&gt;NPY_ANYORDER&lt;/code&gt;&lt;/a&gt;, then the array returned is Fortran-style contiguous only if the old one is; otherwise, it is C-style contiguous.</source>
          <target state="translated">Эквивалентен &lt;a href=&quot;generated/numpy.ndarray.copy#numpy.ndarray.copy&quot;&gt; &lt;code&gt;ndarray.copy&lt;/code&gt; &lt;/a&gt; ( &lt;em&gt;self&lt;/em&gt; , &lt;em&gt;fortran&lt;/em&gt; ). Сделайте копию &lt;em&gt;старого&lt;/em&gt; массива. Возвращаемый массив всегда выровнен и доступен для записи с данными, интерпретируемыми так же, как и старый массив. Если &lt;em&gt;порядок&lt;/em&gt; равен &lt;a href=&quot;#c.NPY_CORDER&quot;&gt; &lt;code&gt;NPY_CORDER&lt;/code&gt; &lt;/a&gt; , то возвращается непрерывный массив в стиле C. Если &lt;em&gt;порядок&lt;/em&gt; равен &lt;a href=&quot;#c.NPY_FORTRANORDER&quot;&gt; &lt;code&gt;NPY_FORTRANORDER&lt;/code&gt; &lt;/a&gt; , то возвращается непрерывный массив в стиле Фортрана. Если &lt;em&gt;порядок равен &lt;/em&gt;&lt;a href=&quot;#c.NPY_ANYORDER&quot;&gt; &lt;code&gt;NPY_ANYORDER&lt;/code&gt; &lt;/a&gt; , то возвращаемый массив является непрерывным в стиле Фортрана, только если старый; в противном случае он является непрерывным в стиле C.</target>
        </trans-unit>
        <trans-unit id="98feecd02ab5026f0970a3c09806ab4167d96259" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;generated/numpy.ndarray.cumprod#numpy.ndarray.cumprod&quot;&gt;&lt;code&gt;ndarray.cumprod&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;axis&lt;/em&gt;, &lt;em&gt;rtype&lt;/em&gt;). Return 1-d cumulative products of elements in &lt;code&gt;self&lt;/code&gt; along &lt;code&gt;axis&lt;/code&gt;. Perform the product after converting data to data type &lt;code&gt;rtype&lt;/code&gt;.</source>
          <target state="translated">Эквивалентен &lt;a href=&quot;generated/numpy.ndarray.cumprod#numpy.ndarray.cumprod&quot;&gt; &lt;code&gt;ndarray.cumprod&lt;/code&gt; &lt;/a&gt; ( &lt;em&gt;self&lt;/em&gt; , &lt;em&gt;axis&lt;/em&gt; , &lt;em&gt;rtype&lt;/em&gt; ). Возврат 1-го кумулятивного произведения элементов в &lt;code&gt;self&lt;/code&gt; вдоль &lt;code&gt;axis&lt;/code&gt; . Выполните произведение после преобразования данных в тип данных &lt;code&gt;rtype&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="26f34a6ad4ecf38e07a2778b6f8366d8507a10ea" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;generated/numpy.ndarray.cumsum#numpy.ndarray.cumsum&quot;&gt;&lt;code&gt;ndarray.cumsum&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;axis&lt;/em&gt;, &lt;em&gt;rtype&lt;/em&gt;). Return cumulative 1-d sums of elements in &lt;em&gt;self&lt;/em&gt; along &lt;em&gt;axis&lt;/em&gt;. Perform the sum after converting data to data type &lt;em&gt;rtype&lt;/em&gt;.</source>
          <target state="translated">Эквивалентен &lt;a href=&quot;generated/numpy.ndarray.cumsum#numpy.ndarray.cumsum&quot;&gt; &lt;code&gt;ndarray.cumsum&lt;/code&gt; &lt;/a&gt; ( &lt;em&gt;self&lt;/em&gt; , &lt;em&gt;axis&lt;/em&gt; , &lt;em&gt;rtype&lt;/em&gt; ). Возврат совокупных одномерных сумм элементов в &lt;em&gt;себе&lt;/em&gt; вдоль &lt;em&gt;оси&lt;/em&gt; . Выполните суммирование после преобразования данных в тип данных &lt;em&gt;rtype&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="44d031ba857ad4460b29f51ce74504941e945e52" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;generated/numpy.ndarray.diagonal#numpy.ndarray.diagonal&quot;&gt;&lt;code&gt;ndarray.diagonal&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;offset&lt;/em&gt;, &lt;em&gt;axis1&lt;/em&gt;, &lt;em&gt;axis2&lt;/em&gt; ). Return the &lt;em&gt;offset&lt;/em&gt; diagonals of the 2-d arrays defined by &lt;em&gt;axis1&lt;/em&gt; and &lt;em&gt;axis2&lt;/em&gt;.</source>
          <target state="translated">Эквивалентен &lt;a href=&quot;generated/numpy.ndarray.diagonal#numpy.ndarray.diagonal&quot;&gt; &lt;code&gt;ndarray.diagonal&lt;/code&gt; &lt;/a&gt; ( &lt;em&gt;self&lt;/em&gt; , &lt;em&gt;offset&lt;/em&gt; , &lt;em&gt;axis1&lt;/em&gt; , &lt;em&gt;axis2&lt;/em&gt; ). Возвращает диагонали &lt;em&gt;смещения &lt;/em&gt;&lt;em&gt;двумерных&lt;/em&gt; массивов, определенных &lt;em&gt;осями axis1&lt;/em&gt; и &lt;em&gt;axis2&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="e6400ea427e27ba969159bbf1cd1e50c3dd25455" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;generated/numpy.ndarray.flatten#numpy.ndarray.flatten&quot;&gt;&lt;code&gt;ndarray.flatten&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;order&lt;/em&gt;). Return a 1-d copy of the array. If &lt;em&gt;order&lt;/em&gt; is &lt;a href=&quot;#c.NPY_FORTRANORDER&quot;&gt;&lt;code&gt;NPY_FORTRANORDER&lt;/code&gt;&lt;/a&gt; the elements are scanned out in Fortran order (first-dimension varies the fastest). If &lt;em&gt;order&lt;/em&gt; is &lt;a href=&quot;#c.NPY_CORDER&quot;&gt;&lt;code&gt;NPY_CORDER&lt;/code&gt;&lt;/a&gt;, the elements of &lt;code&gt;self&lt;/code&gt; are scanned in C-order (last dimension varies the fastest). If &lt;em&gt;order&lt;/em&gt;&lt;a href=&quot;#c.NPY_ANYORDER&quot;&gt;&lt;code&gt;NPY_ANYORDER&lt;/code&gt;&lt;/a&gt;, then the result of &lt;a href=&quot;#c.PyArray_ISFORTRAN&quot;&gt;&lt;code&gt;PyArray_ISFORTRAN&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;) is used to determine which order to flatten.</source>
          <target state="translated">Эквивалентен &lt;a href=&quot;generated/numpy.ndarray.flatten#numpy.ndarray.flatten&quot;&gt; &lt;code&gt;ndarray.flatten&lt;/code&gt; &lt;/a&gt; ( &lt;em&gt;self&lt;/em&gt; , &lt;em&gt;order&lt;/em&gt; ). Вернуть 1-мерную копию массива. Если &lt;em&gt;порядок&lt;/em&gt; равен &lt;a href=&quot;#c.NPY_FORTRANORDER&quot;&gt; &lt;code&gt;NPY_FORTRANORDER&lt;/code&gt; ,&lt;/a&gt; элементы сканируются в порядке Fortran (первое измерение изменяется быстрее всего). Если &lt;em&gt;порядок&lt;/em&gt; равен &lt;a href=&quot;#c.NPY_CORDER&quot;&gt; &lt;code&gt;NPY_CORDER&lt;/code&gt; &lt;/a&gt; , элементы &lt;code&gt;self&lt;/code&gt; сканируются в порядке C (последнее измерение изменяется быстрее всего). Если &lt;em&gt;заказ &lt;/em&gt;&lt;a href=&quot;#c.NPY_ANYORDER&quot;&gt; &lt;code&gt;NPY_ANYORDER&lt;/code&gt; &lt;/a&gt; , то результат &lt;a href=&quot;#c.PyArray_ISFORTRAN&quot;&gt; &lt;code&gt;PyArray_ISFORTRAN&lt;/code&gt; &lt;/a&gt; ( &lt;em&gt;self&lt;/em&gt; ) используется для определения порядка сглаживания.</target>
        </trans-unit>
        <trans-unit id="acb7bf8250a91a19555dbcdb02102524e6c94de7" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;generated/numpy.ndarray.getfield#numpy.ndarray.getfield&quot;&gt;&lt;code&gt;ndarray.getfield&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;dtype&lt;/em&gt;, &lt;em&gt;offset&lt;/em&gt;). This function &lt;a href=&quot;https://docs.python.org/3/c-api/intro.html?reference-count-details&quot;&gt;steals a reference&lt;/a&gt; to &lt;code&gt;PyArray_Descr&lt;/code&gt; and returns a new array of the given &lt;code&gt;dtype&lt;/code&gt; using the data in the current array at a specified &lt;code&gt;offset&lt;/code&gt; in bytes. The &lt;code&gt;offset&lt;/code&gt; plus the itemsize of the new array type must be less than &lt;code&gt;self
-&amp;gt;descr-&amp;gt;elsize&lt;/code&gt; or an error is raised. The same shape and strides as the original array are used. Therefore, this function has the effect of returning a field from a structured array. But, it can also be used to select specific bytes or groups of bytes from any array type.</source>
          <target state="translated">Эквивалентно &lt;a href=&quot;generated/numpy.ndarray.getfield#numpy.ndarray.getfield&quot;&gt; &lt;code&gt;ndarray.getfield&lt;/code&gt; &lt;/a&gt; ( &lt;em&gt;self&lt;/em&gt; , &lt;em&gt;dtype&lt;/em&gt; , &lt;em&gt;offset&lt;/em&gt; ). Эта функция &lt;a href=&quot;https://docs.python.org/3/c-api/intro.html?reference-count-details&quot;&gt;крадет ссылку&lt;/a&gt; на &lt;code&gt;PyArray_Descr&lt;/code&gt; и возвращает новый массив данного &lt;code&gt;dtype&lt;/code&gt; , используя данные в текущем массиве с указанным &lt;code&gt;offset&lt;/code&gt; в байтах. &lt;code&gt;offset&lt;/code&gt; плюс itemsize нового типа массива должен быть меньше , чем &lt;code&gt;self -&amp;gt;descr-&amp;gt;elsize&lt;/code&gt; или возникает ошибка. Используется та же форма и шаги, что и в исходном массиве. Следовательно, эта функция возвращает поле из структурированного массива. Но его также можно использовать для выбора определенных байтов или групп байтов из любого типа массива.</target>
        </trans-unit>
        <trans-unit id="6e1e5da9cdc7a9b4c6725235e40182f3951d083a" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;generated/numpy.ndarray.max#numpy.ndarray.max&quot;&gt;&lt;code&gt;ndarray.max&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;axis&lt;/em&gt;). Returns the largest element of &lt;em&gt;self&lt;/em&gt; along the given &lt;em&gt;axis&lt;/em&gt;. When the result is a single element, returns a numpy scalar instead of an ndarray.</source>
          <target state="translated">Эквивалентен &lt;a href=&quot;generated/numpy.ndarray.max#numpy.ndarray.max&quot;&gt; &lt;code&gt;ndarray.max&lt;/code&gt; &lt;/a&gt; ( &lt;em&gt;self&lt;/em&gt; , &lt;em&gt;axis&lt;/em&gt; ). Возвращает самый большой элемент &lt;em&gt;self&lt;/em&gt; по заданной &lt;em&gt;оси&lt;/em&gt; . Когда результатом является один элемент, возвращает скаляр numpy вместо ndarray.</target>
        </trans-unit>
        <trans-unit id="bdd01120eccb02f99889760c9ef36e279a9f9ea8" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;generated/numpy.ndarray.mean#numpy.ndarray.mean&quot;&gt;&lt;code&gt;ndarray.mean&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;axis&lt;/em&gt;, &lt;em&gt;rtype&lt;/em&gt;). Returns the mean of the elements along the given &lt;em&gt;axis&lt;/em&gt;, using the enumerated type &lt;em&gt;rtype&lt;/em&gt; as the data type to sum in. Default sum behavior is obtained using &lt;a href=&quot;c-api.dtype#c.NPY_NOTYPE&quot;&gt;&lt;code&gt;NPY_NOTYPE&lt;/code&gt;&lt;/a&gt; for &lt;em&gt;rtype&lt;/em&gt;.</source>
          <target state="translated">Эквивалентен &lt;a href=&quot;generated/numpy.ndarray.mean#numpy.ndarray.mean&quot;&gt; &lt;code&gt;ndarray.mean&lt;/code&gt; &lt;/a&gt; ( &lt;em&gt;self&lt;/em&gt; , &lt;em&gt;axis&lt;/em&gt; , &lt;em&gt;rtype&lt;/em&gt; ). Возвращает среднее значение элементов по заданной &lt;em&gt;оси&lt;/em&gt; , используя перечислимый тип &lt;em&gt;rtype&lt;/em&gt; в качестве типа данных для суммирования. Поведение суммы по умолчанию получается с использованием &lt;a href=&quot;c-api.dtype#c.NPY_NOTYPE&quot;&gt; &lt;code&gt;NPY_NOTYPE&lt;/code&gt; &lt;/a&gt; для &lt;em&gt;rtype&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="9e276f562081b61880c79febde9752c6b4583d12" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;generated/numpy.ndarray.min#numpy.ndarray.min&quot;&gt;&lt;code&gt;ndarray.min&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;axis&lt;/em&gt;). Return the smallest element of &lt;em&gt;self&lt;/em&gt; along the given &lt;em&gt;axis&lt;/em&gt;. When the result is a single element, returns a numpy scalar instead of an ndarray.</source>
          <target state="translated">Эквивалентен &lt;a href=&quot;generated/numpy.ndarray.min#numpy.ndarray.min&quot;&gt; &lt;code&gt;ndarray.min&lt;/code&gt; &lt;/a&gt; ( &lt;em&gt;self&lt;/em&gt; , &lt;em&gt;axis&lt;/em&gt; ). Вернуть наименьший элемент &lt;em&gt;себя&lt;/em&gt; по заданной &lt;em&gt;оси&lt;/em&gt; . Когда результатом является один элемент, возвращает скаляр numpy вместо ndarray.</target>
        </trans-unit>
        <trans-unit id="e792db3a62a29831ce03976f5ea2350fba5a323b" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;generated/numpy.ndarray.nonzero#numpy.ndarray.nonzero&quot;&gt;&lt;code&gt;ndarray.nonzero&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;). Returns a tuple of index arrays that select elements of &lt;em&gt;self&lt;/em&gt; that are nonzero. If (nd= &lt;a href=&quot;#c.PyArray_NDIM&quot;&gt;&lt;code&gt;PyArray_NDIM&lt;/code&gt;&lt;/a&gt; ( &lt;code&gt;self&lt;/code&gt; ))==1, then a single index array is returned. The index arrays have data type &lt;a href=&quot;c-api.dtype#c.NPY_INTP&quot;&gt;&lt;code&gt;NPY_INTP&lt;/code&gt;&lt;/a&gt;. If a tuple is returned (nd</source>
          <target state="translated">Эквивалентно &lt;a href=&quot;generated/numpy.ndarray.nonzero#numpy.ndarray.nonzero&quot;&gt; &lt;code&gt;ndarray.nonzero&lt;/code&gt; &lt;/a&gt; ( &lt;em&gt;self&lt;/em&gt; ). Возвращает кортеж индексных массивов, которые выбирают элементы &lt;em&gt;self&lt;/em&gt; , отличные от нуля. Если (nd = &lt;a href=&quot;#c.PyArray_NDIM&quot;&gt; &lt;code&gt;PyArray_NDIM&lt;/code&gt; &lt;/a&gt; ( &lt;code&gt;self&lt;/code&gt; )) == 1, то возвращается единственный индексный массив. Индексные массивы имеют тип данных &lt;a href=&quot;c-api.dtype#c.NPY_INTP&quot;&gt; &lt;code&gt;NPY_INTP&lt;/code&gt; &lt;/a&gt; . Если возвращается кортеж (nd</target>
        </trans-unit>
        <trans-unit id="a70d121c7d953594f404dacb0d342fd3ab8b30ba" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;generated/numpy.ndarray.partition#numpy.ndarray.partition&quot;&gt;&lt;code&gt;ndarray.partition&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;ktharray&lt;/em&gt;, &lt;em&gt;axis&lt;/em&gt;, &lt;em&gt;kind&lt;/em&gt;). Partitions the array so that the values of the element indexed by &lt;em&gt;ktharray&lt;/em&gt; are in the positions they would be if the array is fully sorted and places all elements smaller than the kth before and all elements equal or greater after the kth element. The ordering of all elements within the partitions is undefined. If &lt;em&gt;self&lt;/em&gt;-&amp;gt;descr is a data-type with fields defined, then self-&amp;gt;descr-&amp;gt;names is used to determine the sort order. A comparison where the first field is equal will use the second field and so on. To alter the sort order of a structured array, create a new data-type with a different order of names and construct a view of the array with that new data-type. Returns zero on success and -1 on failure.</source>
          <target state="translated">Эквивалентно &lt;a href=&quot;generated/numpy.ndarray.partition#numpy.ndarray.partition&quot;&gt; &lt;code&gt;ndarray.partition&lt;/code&gt; &lt;/a&gt; ( &lt;em&gt;self&lt;/em&gt; , &lt;em&gt;ktharray&lt;/em&gt; , &lt;em&gt;axis&lt;/em&gt; , &lt;em&gt;kind&lt;/em&gt; ). Разбивает массив таким образом, чтобы значения элемента, проиндексированного &lt;em&gt;ktharray,&lt;/em&gt; находились в тех позициях, которые они были бы, если бы массив был полностью отсортирован, и помещает все элементы, меньшие, чем k-й перед, и все элементы, равные или большие после k-го элемента. Порядок всех элементов в разделах не определен. Если &lt;em&gt;я&lt;/em&gt;-&amp;gt; descr - это тип данных с определенными полями, затем self-&amp;gt; descr-&amp;gt; names используется для определения порядка сортировки. При сравнении, в котором первое поле равно, будет использоваться второе поле и так далее. Чтобы изменить порядок сортировки структурированного массива, создайте новый тип данных с другим порядком имен и создайте представление массива с этим новым типом данных. Возвращает ноль в случае успеха и -1 в случае неудачи.</target>
        </trans-unit>
        <trans-unit id="1404ab20af4a0d50c24ff1ca93cc3a3448c7e38e" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;generated/numpy.ndarray.prod#numpy.ndarray.prod&quot;&gt;&lt;code&gt;ndarray.prod&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;axis&lt;/em&gt;, &lt;em&gt;rtype&lt;/em&gt;). Return 1-d products of elements in &lt;em&gt;self&lt;/em&gt; along &lt;em&gt;axis&lt;/em&gt;. Perform the product after converting data to data type &lt;em&gt;rtype&lt;/em&gt;.</source>
          <target state="translated">Эквивалентен &lt;a href=&quot;generated/numpy.ndarray.prod#numpy.ndarray.prod&quot;&gt; &lt;code&gt;ndarray.prod&lt;/code&gt; &lt;/a&gt; ( &lt;em&gt;self&lt;/em&gt; , &lt;em&gt;axis&lt;/em&gt; , &lt;em&gt;rtype&lt;/em&gt; ). Вернуть 1-е произведения элементов в &lt;em&gt;себя&lt;/em&gt; по &lt;em&gt;оси&lt;/em&gt; . Выполните произведение после преобразования данных в тип данных &lt;em&gt;rtype&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="1100d008c0276fd76e61e9204938c06e2c190cea" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;generated/numpy.ndarray.ptp#numpy.ndarray.ptp&quot;&gt;&lt;code&gt;ndarray.ptp&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;axis&lt;/em&gt;). Return the difference between the largest element of &lt;em&gt;self&lt;/em&gt; along &lt;em&gt;axis&lt;/em&gt; and the smallest element of &lt;em&gt;self&lt;/em&gt; along &lt;em&gt;axis&lt;/em&gt;. When the result is a single element, returns a numpy scalar instead of an ndarray.</source>
          <target state="translated">Эквивалентен &lt;a href=&quot;generated/numpy.ndarray.ptp#numpy.ndarray.ptp&quot;&gt; &lt;code&gt;ndarray.ptp&lt;/code&gt; &lt;/a&gt; ( &lt;em&gt;self&lt;/em&gt; , &lt;em&gt;axis&lt;/em&gt; ). Возврат разницы между самым большим элементом &lt;em&gt;self&lt;/em&gt; вдоль &lt;em&gt;оси&lt;/em&gt; и наименьшим элементом &lt;em&gt;self&lt;/em&gt; вдоль &lt;em&gt;оси&lt;/em&gt; . Когда результатом является один элемент, возвращает скаляр numpy вместо ndarray.</target>
        </trans-unit>
        <trans-unit id="2c16f538cf9a4222086ade1f8bc40148ea4157cd" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;generated/numpy.ndarray.repeat#numpy.ndarray.repeat&quot;&gt;&lt;code&gt;ndarray.repeat&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;op&lt;/em&gt;, &lt;em&gt;axis&lt;/em&gt;). Copy the elements of &lt;em&gt;self&lt;/em&gt;, &lt;em&gt;op&lt;/em&gt; times along the given &lt;em&gt;axis&lt;/em&gt;. Either &lt;em&gt;op&lt;/em&gt; is a scalar integer or a sequence of length &lt;em&gt;self&lt;/em&gt; -&amp;gt;dimensions[ &lt;em&gt;axis&lt;/em&gt; ] indicating how many times to repeat each item along the axis.</source>
          <target state="translated">Эквивалентен &lt;a href=&quot;generated/numpy.ndarray.repeat#numpy.ndarray.repeat&quot;&gt; &lt;code&gt;ndarray.repeat&lt;/code&gt; &lt;/a&gt; ( &lt;em&gt;self&lt;/em&gt; , &lt;em&gt;op&lt;/em&gt; , &lt;em&gt;axis&lt;/em&gt; ). Скопируйте элементы &lt;em&gt;self&lt;/em&gt; , &lt;em&gt;op&lt;/em&gt; раз по заданной &lt;em&gt;оси&lt;/em&gt; . Либо &lt;em&gt;op&lt;/em&gt; - это скалярное целое число, либо последовательность длины &lt;em&gt;self&lt;/em&gt; -&amp;gt; sizes [ &lt;em&gt;axis&lt;/em&gt; ], указывающая, сколько раз повторять каждый элемент вдоль оси.</target>
        </trans-unit>
        <trans-unit id="89f8dce1a3fdb6440169e6117acb2747787948e3" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;generated/numpy.ndarray.reshape#numpy.ndarray.reshape&quot;&gt;&lt;code&gt;ndarray.reshape&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;shape&lt;/em&gt;) where &lt;em&gt;shape&lt;/em&gt; is a sequence. Converts &lt;em&gt;shape&lt;/em&gt; to a &lt;a href=&quot;c-api.types-and-structures#c.PyArray_Dims&quot;&gt;&lt;code&gt;PyArray_Dims&lt;/code&gt;&lt;/a&gt; structure and calls &lt;a href=&quot;#c.PyArray_Newshape&quot;&gt;&lt;code&gt;PyArray_Newshape&lt;/code&gt;&lt;/a&gt; internally. For back-ward compatibility &amp;ndash; Not recommended</source>
          <target state="translated">Эквивалентен &lt;a href=&quot;generated/numpy.ndarray.reshape#numpy.ndarray.reshape&quot;&gt; &lt;code&gt;ndarray.reshape&lt;/code&gt; &lt;/a&gt; ( &lt;em&gt;self&lt;/em&gt; , &lt;em&gt;shape&lt;/em&gt; ), где &lt;em&gt;shape&lt;/em&gt; - последовательность. Обращенные &lt;em&gt;формы&lt;/em&gt; в &lt;a href=&quot;c-api.types-and-structures#c.PyArray_Dims&quot;&gt; &lt;code&gt;PyArray_Dims&lt;/code&gt; &lt;/a&gt; структуру и вызывает &lt;a href=&quot;#c.PyArray_Newshape&quot;&gt; &lt;code&gt;PyArray_Newshape&lt;/code&gt; &lt;/a&gt; внутри. Для обратной совместимости - не рекомендуется</target>
        </trans-unit>
        <trans-unit id="c66cfa86b4fd8c96342e13259600ca57c73356a4" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;generated/numpy.ndarray.resize#numpy.ndarray.resize&quot;&gt;&lt;code&gt;ndarray.resize&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;newshape&lt;/em&gt;, refcheck &lt;code&gt;=&lt;/code&gt;&lt;em&gt;refcheck&lt;/em&gt;, order= fortran ). This function only works on single-segment arrays. It changes the shape of &lt;em&gt;self&lt;/em&gt; inplace and will reallocate the memory for &lt;em&gt;self&lt;/em&gt; if &lt;em&gt;newshape&lt;/em&gt; has a different total number of elements then the old shape. If reallocation is necessary, then &lt;em&gt;self&lt;/em&gt; must own its data, have &lt;em&gt;self&lt;/em&gt; - &lt;code&gt;&amp;gt;base==NULL&lt;/code&gt;, have &lt;em&gt;self&lt;/em&gt; - &lt;code&gt;&amp;gt;weakrefs==NULL&lt;/code&gt;, and (unless refcheck is 0) not be referenced by any other array. The fortran argument can be &lt;a href=&quot;#c.NPY_ANYORDER&quot;&gt;&lt;code&gt;NPY_ANYORDER&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#c.NPY_CORDER&quot;&gt;&lt;code&gt;NPY_CORDER&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&quot;#c.NPY_FORTRANORDER&quot;&gt;&lt;code&gt;NPY_FORTRANORDER&lt;/code&gt;&lt;/a&gt;. It currently has no effect. Eventually it could be used to determine how the resize operation should view the data when constructing a differently-dimensioned array. Returns None on success and NULL on error.</source>
          <target state="translated">Эквивалентно &lt;a href=&quot;generated/numpy.ndarray.resize#numpy.ndarray.resize&quot;&gt; &lt;code&gt;ndarray.resize&lt;/code&gt; &lt;/a&gt; ( &lt;em&gt;self&lt;/em&gt; , &lt;em&gt;newshape&lt;/em&gt; , refcheck &lt;code&gt;=&lt;/code&gt; &lt;em&gt;refcheck&lt;/em&gt; , order = fortran). Эта функция работает только с односегментными массивами. Он изменяет форму &lt;em&gt;себя на месте&lt;/em&gt; и перераспределяет память для &lt;em&gt;себя,&lt;/em&gt; если у &lt;em&gt;новостной формы&lt;/em&gt; другое общее количество элементов, чем у старой формы. Если перераспределение необходимо, тогда &lt;em&gt;self&lt;/em&gt; должен владеть своими данными, иметь &lt;em&gt;self&lt;/em&gt; - &lt;code&gt;&amp;gt;base==NULL&lt;/code&gt; , иметь &lt;em&gt;self&lt;/em&gt; - &lt;code&gt;&amp;gt;weakrefs==NULL&lt;/code&gt; и (если refcheck не равен 0) не ссылаться на какой-либо другой массив. Аргумент fortran может иметь вид &lt;a href=&quot;#c.NPY_ANYORDER&quot;&gt; &lt;code&gt;NPY_ANYORDER&lt;/code&gt; &lt;/a&gt;, &lt;a href=&quot;#c.NPY_CORDER&quot;&gt; &lt;code&gt;NPY_CORDER&lt;/code&gt; &lt;/a&gt; или &lt;a href=&quot;#c.NPY_FORTRANORDER&quot;&gt; &lt;code&gt;NPY_FORTRANORDER&lt;/code&gt; &lt;/a&gt; . В настоящее время это не действует. В конечном итоге его можно было использовать для определения того, как операция изменения размера должна просматривать данные при построении массива с другими размерами. Возвращает None в случае успеха и NULL в случае ошибки.</target>
        </trans-unit>
        <trans-unit id="c35d0fb0b3b672f40f8ed22b6a36b98bc32ccd79" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;generated/numpy.ndarray.round#numpy.ndarray.round&quot;&gt;&lt;code&gt;ndarray.round&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;decimals&lt;/em&gt;, &lt;em&gt;out&lt;/em&gt;). Returns the array with elements rounded to the nearest decimal place. The decimal place is defined as the</source>
          <target state="translated">Эквивалент &lt;a href=&quot;generated/numpy.ndarray.round#numpy.ndarray.round&quot;&gt; &lt;code&gt;ndarray.round&lt;/code&gt; &lt;/a&gt; ( &lt;em&gt;самостоятельно&lt;/em&gt; , &lt;em&gt;десятичные&lt;/em&gt; , &lt;em&gt;вне&lt;/em&gt; ). Возвращает массив с элементами, округленными до ближайшего десятичного знака. Десятичный разряд определяется как</target>
        </trans-unit>
        <trans-unit id="77c91912c2f0496c5da34bf18831db8c3ec272aa" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;generated/numpy.ndarray.searchsorted#numpy.ndarray.searchsorted&quot;&gt;&lt;code&gt;ndarray.searchsorted&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;values&lt;/em&gt;, &lt;em&gt;side&lt;/em&gt;, &lt;em&gt;perm&lt;/em&gt;). Assuming &lt;em&gt;self&lt;/em&gt; is a 1-d array in ascending order, then the output is an array of indices the same shape as &lt;em&gt;values&lt;/em&gt; such that, if the elements in &lt;em&gt;values&lt;/em&gt; were inserted before the indices, the order of &lt;em&gt;self&lt;/em&gt; would be preserved. No checking is done on whether or not self is in ascending order.</source>
          <target state="translated">Эквивалентно &lt;a href=&quot;generated/numpy.ndarray.searchsorted#numpy.ndarray.searchsorted&quot;&gt; &lt;code&gt;ndarray.searchsorted&lt;/code&gt; &lt;/a&gt; ( &lt;em&gt;self&lt;/em&gt; , &lt;em&gt;values&lt;/em&gt; , &lt;em&gt;side&lt;/em&gt; , &lt;em&gt;perm&lt;/em&gt; ). Предполагая, что &lt;em&gt;self&lt;/em&gt; - это одномерный массив в возрастающем порядке, тогда на выходе будет массив индексов той же формы, что и &lt;em&gt;значения&lt;/em&gt; , так что, если бы элементы в &lt;em&gt;values&lt;/em&gt; были вставлены перед индексами, порядок &lt;em&gt;self&lt;/em&gt; был бы сохранен. Не проверяется, находится ли я в порядке возрастания.</target>
        </trans-unit>
        <trans-unit id="129c27494826551cd6d91c742839f2dd3b7a2b39" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;generated/numpy.ndarray.setfield#numpy.ndarray.setfield&quot;&gt;&lt;code&gt;ndarray.setfield&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;val&lt;/em&gt;, &lt;em&gt;dtype&lt;/em&gt;, &lt;em&gt;offset&lt;/em&gt; ). Set the field starting at &lt;em&gt;offset&lt;/em&gt; in bytes and of the given &lt;em&gt;dtype&lt;/em&gt; to &lt;em&gt;val&lt;/em&gt;. The &lt;em&gt;offset&lt;/em&gt; plus &lt;em&gt;dtype&lt;/em&gt; -&amp;gt;elsize must be less than &lt;em&gt;self&lt;/em&gt; -&amp;gt;descr-&amp;gt;elsize or an error is raised. Otherwise, the &lt;em&gt;val&lt;/em&gt; argument is converted to an array and copied into the field pointed to. If necessary, the elements of &lt;em&gt;val&lt;/em&gt; are repeated to fill the destination array, But, the number of elements in the destination must be an integer multiple of the number of elements in &lt;em&gt;val&lt;/em&gt;.</source>
          <target state="translated">Эквивалентен &lt;a href=&quot;generated/numpy.ndarray.setfield#numpy.ndarray.setfield&quot;&gt; &lt;code&gt;ndarray.setfield&lt;/code&gt; &lt;/a&gt; ( &lt;em&gt;self&lt;/em&gt; , &lt;em&gt;val&lt;/em&gt; , &lt;em&gt;dtype&lt;/em&gt; , &lt;em&gt;offset&lt;/em&gt; ). Установите для поля, начинающегося со &lt;em&gt;смещения&lt;/em&gt; в байтах, и заданного типа &lt;em&gt;dtype&lt;/em&gt; значение &lt;em&gt;val&lt;/em&gt; . &lt;em&gt;Смещение&lt;/em&gt; плюс &lt;em&gt;DTYPE&lt;/em&gt; -&amp;gt; elsize должно быть меньше , чем &lt;em&gt;я&lt;/em&gt; -&amp;gt; descr-&amp;gt; elsize или возникает ошибка. В противном случае аргумент &lt;em&gt;val&lt;/em&gt; преобразуется в массив и копируется в указанное поле. Если необходимо, элементы &lt;em&gt;val&lt;/em&gt; повторяются для заполнения целевого массива, но количество элементов в целевом массиве должно быть целым числом, кратным количеству элементов в&lt;em&gt;val&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="329e170888d304760a845c23e2123d83a997ded2" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;generated/numpy.ndarray.sort#numpy.ndarray.sort&quot;&gt;&lt;code&gt;ndarray.sort&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;axis&lt;/em&gt;, &lt;em&gt;kind&lt;/em&gt;). Return an array with the items of &lt;em&gt;self&lt;/em&gt; sorted along &lt;em&gt;axis&lt;/em&gt;. The array is sorted using the algorithm denoted by &lt;em&gt;kind&lt;/em&gt; , which is an integer/enum pointing to the type of sorting algorithms used.</source>
          <target state="translated">Эквивалентен &lt;a href=&quot;generated/numpy.ndarray.sort#numpy.ndarray.sort&quot;&gt; &lt;code&gt;ndarray.sort&lt;/code&gt; &lt;/a&gt; ( &lt;em&gt;self&lt;/em&gt; , &lt;em&gt;axis&lt;/em&gt; , &lt;em&gt;kind&lt;/em&gt; ). Возвращает массив с элементами из &lt;em&gt;себя&lt;/em&gt; отсортированных по &lt;em&gt;оси&lt;/em&gt; . Массив сортируется с использованием алгоритма, обозначенного &lt;em&gt;типом&lt;/em&gt; , который представляет собой целое число / перечисление, указывающее на тип используемых алгоритмов сортировки.</target>
        </trans-unit>
        <trans-unit id="18f23f95a5677bb30c45f3519a8a38c4eb9ab14d" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;generated/numpy.ndarray.squeeze#numpy.ndarray.squeeze&quot;&gt;&lt;code&gt;ndarray.squeeze&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;). Return a new view of &lt;em&gt;self&lt;/em&gt; with all of the dimensions of length 1 removed from the shape.</source>
          <target state="translated">Эквивалентно &lt;a href=&quot;generated/numpy.ndarray.squeeze#numpy.ndarray.squeeze&quot;&gt; &lt;code&gt;ndarray.squeeze&lt;/code&gt; &lt;/a&gt; ( &lt;em&gt;self&lt;/em&gt; ). Верните новый вид &lt;em&gt;себя&lt;/em&gt; со всеми размерами длины 1, удаленными из формы.</target>
        </trans-unit>
        <trans-unit id="f3ea257f6db1c3b5b426fb4027029e9f1b7413a5" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;generated/numpy.ndarray.std#numpy.ndarray.std&quot;&gt;&lt;code&gt;ndarray.std&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;axis&lt;/em&gt;, &lt;em&gt;rtype&lt;/em&gt;). Return the standard deviation using data along &lt;em&gt;axis&lt;/em&gt; converted to data type &lt;em&gt;rtype&lt;/em&gt;.</source>
          <target state="translated">Эквивалентен &lt;a href=&quot;generated/numpy.ndarray.std#numpy.ndarray.std&quot;&gt; &lt;code&gt;ndarray.std&lt;/code&gt; &lt;/a&gt; ( &lt;em&gt;self&lt;/em&gt; , &lt;em&gt;axis&lt;/em&gt; , &lt;em&gt;rtype&lt;/em&gt; ). Верните стандартное отклонение, используя данные по &lt;em&gt;оси,&lt;/em&gt; преобразованные в тип данных &lt;em&gt;rtype&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="4c7387b455871f5d5fed3305db644e74b9628876" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;generated/numpy.ndarray.sum#numpy.ndarray.sum&quot;&gt;&lt;code&gt;ndarray.sum&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;axis&lt;/em&gt;, &lt;em&gt;rtype&lt;/em&gt;). Return 1-d vector sums of elements in &lt;em&gt;self&lt;/em&gt; along &lt;em&gt;axis&lt;/em&gt;. Perform the sum after converting data to data type &lt;em&gt;rtype&lt;/em&gt;.</source>
          <target state="translated">Эквивалентен &lt;a href=&quot;generated/numpy.ndarray.sum#numpy.ndarray.sum&quot;&gt; &lt;code&gt;ndarray.sum&lt;/code&gt; &lt;/a&gt; ( &lt;em&gt;self&lt;/em&gt; , &lt;em&gt;axis&lt;/em&gt; , &lt;em&gt;rtype&lt;/em&gt; ). Возвращает 1-мерные векторные суммы элементов в &lt;em&gt;себе&lt;/em&gt; вдоль &lt;em&gt;оси&lt;/em&gt; . Выполните суммирование после преобразования данных в тип данных &lt;em&gt;rtype&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="9b9ac6ba7775647d994932881b5b117c78bc1d61" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;generated/numpy.ndarray.swapaxes#numpy.ndarray.swapaxes&quot;&gt;&lt;code&gt;ndarray.swapaxes&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;a1&lt;/em&gt;, &lt;em&gt;a2&lt;/em&gt;). The returned array is a new view of the data in &lt;em&gt;self&lt;/em&gt; with the given axes, &lt;em&gt;a1&lt;/em&gt; and &lt;em&gt;a2&lt;/em&gt;, swapped.</source>
          <target state="translated">Эквивалентен &lt;a href=&quot;generated/numpy.ndarray.swapaxes#numpy.ndarray.swapaxes&quot;&gt; &lt;code&gt;ndarray.swapaxes&lt;/code&gt; &lt;/a&gt; ( &lt;em&gt;self&lt;/em&gt; , &lt;em&gt;a1&lt;/em&gt; , &lt;em&gt;a2&lt;/em&gt; ). Возвращенный массив - это новое представление данных в &lt;em&gt;себе&lt;/em&gt; с &lt;em&gt;поменяемыми&lt;/em&gt; местами заданными осями &lt;em&gt;a1&lt;/em&gt; и &lt;em&gt;a2&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="526d5a8267bf48a76f6e4bef39106e81c90185a6" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;generated/numpy.ndarray.take#numpy.ndarray.take&quot;&gt;&lt;code&gt;ndarray.take&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;indices&lt;/em&gt;, &lt;em&gt;axis&lt;/em&gt;, &lt;em&gt;ret&lt;/em&gt;, &lt;em&gt;clipmode&lt;/em&gt;) except &lt;em&gt;axis&lt;/em&gt; =None in Python is obtained by setting &lt;em&gt;axis&lt;/em&gt; = &lt;a href=&quot;#c.NPY_MAXDIMS&quot;&gt;&lt;code&gt;NPY_MAXDIMS&lt;/code&gt;&lt;/a&gt; in C. Extract the items from self indicated by the integer-valued &lt;em&gt;indices&lt;/em&gt; along the given &lt;em&gt;axis.&lt;/em&gt; The clipmode argument can be &lt;a href=&quot;#c.NPY_RAISE&quot;&gt;&lt;code&gt;NPY_RAISE&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#c.NPY_WRAP&quot;&gt;&lt;code&gt;NPY_WRAP&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&quot;#c.NPY_CLIP&quot;&gt;&lt;code&gt;NPY_CLIP&lt;/code&gt;&lt;/a&gt; to indicate what to do with out-of-bound indices. The &lt;em&gt;ret&lt;/em&gt; argument can specify an output array rather than having one created internally.</source>
          <target state="translated">Эквивалент &lt;a href=&quot;generated/numpy.ndarray.take#numpy.ndarray.take&quot;&gt; &lt;code&gt;ndarray.take&lt;/code&gt; &lt;/a&gt; ( &lt;em&gt;себя&lt;/em&gt; , &lt;em&gt;индексы&lt;/em&gt; , &lt;em&gt;оси&lt;/em&gt; , &lt;em&gt;RET&lt;/em&gt; , &lt;em&gt;clipmode&lt;/em&gt; ) , за исключением &lt;em&gt;оси&lt;/em&gt; = Ни в Python не будет получен путем установки &lt;em&gt;ось&lt;/em&gt; = &lt;a href=&quot;#c.NPY_MAXDIMS&quot;&gt; &lt;code&gt;NPY_MAXDIMS&lt;/code&gt; &lt;/a&gt; в С. Извлечения элементов из собственных обозначены целочисленных &lt;em&gt;индексов&lt;/em&gt; вдоль заданной &lt;em&gt;оси.&lt;/em&gt; Аргументом clipmode может быть &lt;a href=&quot;#c.NPY_RAISE&quot;&gt; &lt;code&gt;NPY_RAISE&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#c.NPY_WRAP&quot;&gt; &lt;code&gt;NPY_WRAP&lt;/code&gt; &lt;/a&gt; или &lt;a href=&quot;#c.NPY_CLIP&quot;&gt; &lt;code&gt;NPY_CLIP&lt;/code&gt; ,&lt;/a&gt; чтобы указать, что делать с индексами, выходящими за границы. &lt;em&gt;RET&lt;/em&gt; аргумент может указать выходной массив , а не имеющие одну созданные внутри.</target>
        </trans-unit>
        <trans-unit id="3fbb6db45f5065f7d5f46448fca11ee7f459d488" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;generated/numpy.ndarray.tobytes#numpy.ndarray.tobytes&quot;&gt;&lt;code&gt;ndarray.tobytes&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;order&lt;/em&gt;). Return the bytes of this array in a Python string.</source>
          <target state="translated">Эквивалентно &lt;a href=&quot;generated/numpy.ndarray.tobytes#numpy.ndarray.tobytes&quot;&gt; &lt;code&gt;ndarray.tobytes&lt;/code&gt; &lt;/a&gt; ( &lt;em&gt;self&lt;/em&gt; , &lt;em&gt;order&lt;/em&gt; ). Верните байты этого массива в строку Python.</target>
        </trans-unit>
        <trans-unit id="e1487cf1aae9421a58178865b5cc518907b872e6" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;generated/numpy.ndarray.tolist#numpy.ndarray.tolist&quot;&gt;&lt;code&gt;ndarray.tolist&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;). Return a nested Python list from &lt;em&gt;self&lt;/em&gt;.</source>
          <target state="translated">Эквивалентен &lt;a href=&quot;generated/numpy.ndarray.tolist#numpy.ndarray.tolist&quot;&gt; &lt;code&gt;ndarray.tolist&lt;/code&gt; &lt;/a&gt; ( &lt;em&gt;self&lt;/em&gt; ). Вернуть вложенный список Python из &lt;em&gt;себя&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="92f6eaf18a532cc83a7879c0fc5e0cdb9219ac58" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;generated/numpy.ndarray.trace#numpy.ndarray.trace&quot;&gt;&lt;code&gt;ndarray.trace&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;offset&lt;/em&gt;, &lt;em&gt;axis1&lt;/em&gt;, &lt;em&gt;axis2&lt;/em&gt;, &lt;em&gt;rtype&lt;/em&gt;). Return the sum (using &lt;em&gt;rtype&lt;/em&gt; as the data type of summation) over the &lt;em&gt;offset&lt;/em&gt; diagonal elements of the 2-d arrays defined by &lt;em&gt;axis1&lt;/em&gt; and &lt;em&gt;axis2&lt;/em&gt; variables. A positive offset chooses diagonals above the main diagonal. A negative offset selects diagonals below the main diagonal.</source>
          <target state="translated">Эквивалентен &lt;a href=&quot;generated/numpy.ndarray.trace#numpy.ndarray.trace&quot;&gt; &lt;code&gt;ndarray.trace&lt;/code&gt; &lt;/a&gt; ( &lt;em&gt;self&lt;/em&gt; , &lt;em&gt;offset&lt;/em&gt; , &lt;em&gt;axis1&lt;/em&gt; , &lt;em&gt;axis2&lt;/em&gt; , &lt;em&gt;rtype&lt;/em&gt; ). Возвращает сумму (используя &lt;em&gt;rtype&lt;/em&gt; в качестве типа данных суммирования) по &lt;em&gt;смещенным&lt;/em&gt; диагональным элементам &lt;em&gt;двумерных&lt;/em&gt; массивов, определенных переменными &lt;em&gt;axis1&lt;/em&gt; и &lt;em&gt;axis2&lt;/em&gt; . При положительном смещении диагонали выбираются выше главной диагонали. Отрицательное смещение выбирает диагонали ниже главной диагонали.</target>
        </trans-unit>
        <trans-unit id="903dc5f64afb6611725d0b8ef7bd16c3db35ef02" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;generated/numpy.ndarray.transpose#numpy.ndarray.transpose&quot;&gt;&lt;code&gt;ndarray.transpose&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;permute&lt;/em&gt;). Permute the axes of the ndarray object &lt;em&gt;self&lt;/em&gt; according to the data structure &lt;em&gt;permute&lt;/em&gt; and return the result. If &lt;em&gt;permute&lt;/em&gt; is &lt;code&gt;NULL&lt;/code&gt;, then the resulting array has its axes reversed. For example if &lt;em&gt;self&lt;/em&gt; has shape</source>
          <target state="translated">Эквивалентно &lt;a href=&quot;generated/numpy.ndarray.transpose#numpy.ndarray.transpose&quot;&gt; &lt;code&gt;ndarray.transpose&lt;/code&gt; &lt;/a&gt; ( &lt;em&gt;self&lt;/em&gt; , &lt;em&gt;permute&lt;/em&gt; ). Переставьте оси объекта ndarray &lt;em&gt;self в&lt;/em&gt; соответствии с &lt;em&gt;перестановкой&lt;/em&gt; структуры данных и верните результат. Если &lt;em&gt;permute&lt;/em&gt; равен &lt;code&gt;NULL&lt;/code&gt; , то оси результирующего массива меняются местами. Например, если у &lt;em&gt;себя&lt;/em&gt; есть форма</target>
        </trans-unit>
        <trans-unit id="2e84dfaf00361747bc32ce6d08fe80d8b155279f" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;generated/numpy.ndarray.view#numpy.ndarray.view&quot;&gt;&lt;code&gt;ndarray.view&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;dtype&lt;/em&gt;). Return a new view of the array &lt;em&gt;self&lt;/em&gt; as possibly a different data-type, &lt;em&gt;dtype&lt;/em&gt;, and different array subclass &lt;em&gt;ptype&lt;/em&gt;.</source>
          <target state="translated">Эквивалентно &lt;a href=&quot;generated/numpy.ndarray.view#numpy.ndarray.view&quot;&gt; &lt;code&gt;ndarray.view&lt;/code&gt; &lt;/a&gt; ( &lt;em&gt;self&lt;/em&gt; , &lt;em&gt;dtype&lt;/em&gt; ). Вернуть новое представление массива &lt;em&gt;self&lt;/em&gt; как, возможно, другого типа данных, &lt;em&gt;dtype&lt;/em&gt; и другого подкласса массива &lt;em&gt;ptype&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="c80f2487a92354ad196d90ca737086d6a28cb501" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;https://docs.python.org/dev/c-api/init.html#c.Py_BEGIN_ALLOW_THREADS&quot;&gt;&lt;code&gt;Py_BEGIN_ALLOW_THREADS&lt;/code&gt;&lt;/a&gt; except it uses &lt;code&gt;NPY_ALLOW_THREADS&lt;/code&gt; to determine if the macro if replaced with white-space or not.</source>
          <target state="translated">Эквивалентен &lt;a href=&quot;https://docs.python.org/dev/c-api/init.html#c.Py_BEGIN_ALLOW_THREADS&quot;&gt; &lt;code&gt;Py_BEGIN_ALLOW_THREADS&lt;/code&gt; ,&lt;/a&gt; за исключением того, что он использует &lt;code&gt;NPY_ALLOW_THREADS&lt;/code&gt; , чтобы определить, заменен ли макрос пробелом или нет.</target>
        </trans-unit>
        <trans-unit id="657a5eba5419e2937f0d7b0877025c3f2a8bf379" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;https://docs.python.org/dev/c-api/init.html#c.Py_END_ALLOW_THREADS&quot;&gt;&lt;code&gt;Py_END_ALLOW_THREADS&lt;/code&gt;&lt;/a&gt; except it uses &lt;code&gt;NPY_ALLOW_THREADS&lt;/code&gt; to determine if the macro if replaced with white-space or not.</source>
          <target state="translated">Эквивалентен &lt;a href=&quot;https://docs.python.org/dev/c-api/init.html#c.Py_END_ALLOW_THREADS&quot;&gt; &lt;code&gt;Py_END_ALLOW_THREADS&lt;/code&gt; ,&lt;/a&gt; за исключением того, что он использует &lt;code&gt;NPY_ALLOW_THREADS&lt;/code&gt; , чтобы определить, заменен ли макрос пробелом или нет.</target>
        </trans-unit>
        <trans-unit id="821886e91092ad64682392ad985ffcb281eaf4b3" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;1/2 * (np.exp(x) + np.exp(-x))&lt;/code&gt; and &lt;code&gt;np.cos(1j*x)&lt;/code&gt;.</source>
          <target state="translated">Эквивалентно &lt;code&gt;1/2 * (np.exp(x) + np.exp(-x))&lt;/code&gt; и &lt;code&gt;np.cos(1j*x)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6cedbe2e2d0fc9bc98c2a4058eb21de10f0ba961" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;1/2 * (np.exp(x) - np.exp(-x))&lt;/code&gt; or &lt;code&gt;-1j * np.sin(1j*x)&lt;/code&gt;.</source>
          <target state="translated">Эквивалентно &lt;code&gt;1/2 * (np.exp(x) - np.exp(-x))&lt;/code&gt; или &lt;code&gt;-1j * np.sin(1j*x)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="65cabfa0a0b1ab314bf5ad313943ea0a61c9f913" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;a.copy(order='K')&lt;/code&gt;.</source>
          <target state="translated">Эквивалентно &lt;code&gt;a.copy(order='K')&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4a8b0df6f8f30decfdb8712f593677bd0361c0ef" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;divmod(x, 1)&lt;/code&gt; for positive &lt;code&gt;x&lt;/code&gt; with the return values switched.</source>
          <target state="translated">Эквивалентен &lt;code&gt;divmod(x, 1)&lt;/code&gt; для положительного &lt;code&gt;x&lt;/code&gt; с переключенными возвращаемыми значениями.</target>
        </trans-unit>
        <trans-unit id="3f28125a3d825d23c8591cf7b44d136f5206aec6" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;m[::-1,...]&lt;/code&gt;. Does not require the array to be two-dimensional.</source>
          <target state="translated">Эквивалентно &lt;code&gt;m[::-1,...]&lt;/code&gt; . Не требует, чтобы массив был двумерным.</target>
        </trans-unit>
        <trans-unit id="158b7bdd2f113f05d23975a3a9ae7c4cbbee72c4" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;np.asarray(self)&lt;/code&gt;.</source>
          <target state="translated">Эквивалентен &lt;code&gt;np.asarray(self)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7b757950b99b3fb5a49cac119260ff6b59afd089" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;np.asarray(x).ravel()&lt;/code&gt;</source>
          <target state="translated">Эквивалентен &lt;code&gt;np.asarray(x).ravel()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="01b942f822242874c950f31737a64908f9f10037" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;np.sin(x)/np.cos(x)&lt;/code&gt; element-wise.</source>
          <target state="translated">&lt;code&gt;np.sin(x)/np.cos(x)&lt;/code&gt; эквивалентен np.sin (x) /np.cos (x) .</target>
        </trans-unit>
        <trans-unit id="e03e98ed258ef214f7093f680237951ada6cdb9f" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;np.sinh(x)/np.cosh(x)&lt;/code&gt; or &lt;code&gt;-1j * np.tan(1j*x)&lt;/code&gt;.</source>
          <target state="translated">Эквивалентно &lt;code&gt;np.sinh(x)/np.cosh(x)&lt;/code&gt; или &lt;code&gt;-1j * np.tan(1j*x)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b6b5ff4ad03763736f9b2a4f6770ab65b1c73219" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;np.transpose(self)&lt;/code&gt; if &lt;code&gt;self&lt;/code&gt; is real-valued.</source>
          <target state="translated">Эквивалентно &lt;code&gt;np.transpose(self)&lt;/code&gt; если &lt;code&gt;self&lt;/code&gt; имеет реальные значения.</target>
        </trans-unit>
        <trans-unit id="75b818defe3ad1876ebfb087b965f01d49fa2ec9" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;sqrt(x1**2 + x2**2)&lt;/code&gt;, element-wise. If &lt;code&gt;x1&lt;/code&gt; or &lt;code&gt;x2&lt;/code&gt; is scalar_like (i.e., unambiguously cast-able to a scalar type), it is broadcast for use with each element of the other argument. (See Examples)</source>
          <target state="translated">Поэлементно эквивалентно &lt;code&gt;sqrt(x1**2 + x2**2)&lt;/code&gt; . Если &lt;code&gt;x1&lt;/code&gt; или &lt;code&gt;x2&lt;/code&gt; являются скалярными_подобными (т. Е. Однозначно допускают приведение к скалярному типу), они передаются для использования с каждым элементом другого аргумента. (См. Примеры)</target>
        </trans-unit>
        <trans-unit id="00df9c133fe8747499700e75effeb0cd5d136ccc" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;x.copy()&lt;/code&gt;, but only defined for types that support arithmetic.</source>
          <target state="translated">Эквивалентен &lt;code&gt;x.copy()&lt;/code&gt; , но определен только для типов, поддерживающих арифметику.</target>
        </trans-unit>
        <trans-unit id="23adb20441299c90dbd1e383cfab76bf7d2274b8" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;x1 - x2&lt;/code&gt; in terms of array broadcasting.</source>
          <target state="translated">Эквивалентен &lt;code&gt;x1 - x2&lt;/code&gt; с точки зрения широковещательной передачи массива.</target>
        </trans-unit>
        <trans-unit id="2c304ff74936613f3d12e0fc5cde4c506dd3f3ab" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;x1&lt;/code&gt; * &lt;code&gt;x2&lt;/code&gt; in terms of array broadcasting.</source>
          <target state="translated">Эквивалентно &lt;code&gt;x1&lt;/code&gt; * &lt;code&gt;x2&lt;/code&gt; с точки зрения широковещательной передачи массива.</target>
        </trans-unit>
        <trans-unit id="98520850afe8056507d9d642ea9323b3ed72e130" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;x1&lt;/code&gt; + &lt;code&gt;x2&lt;/code&gt; in terms of array broadcasting.</source>
          <target state="translated">Эквивалентен &lt;code&gt;x1&lt;/code&gt; + &lt;code&gt;x2&lt;/code&gt; с точки зрения широковещательной передачи массива.</target>
        </trans-unit>
        <trans-unit id="202bf1615636b8e0a84392691bc084a70b43390b" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;em&gt;self&lt;/em&gt;.put(&lt;em&gt;values&lt;/em&gt;, &lt;em&gt;indices&lt;/em&gt;, &lt;em&gt;clipmode&lt;/em&gt; ). Put &lt;em&gt;values&lt;/em&gt; into &lt;em&gt;self&lt;/em&gt; at the corresponding (flattened) &lt;em&gt;indices&lt;/em&gt;. If &lt;em&gt;values&lt;/em&gt; is too small it will be repeated as necessary.</source>
          <target state="translated">Эквивалентно &lt;em&gt;self&lt;/em&gt; .put ( &lt;em&gt;значения&lt;/em&gt; , &lt;em&gt;индексы&lt;/em&gt; , &lt;em&gt;режим клипа&lt;/em&gt; ). Поместите &lt;em&gt;значения&lt;/em&gt; в &lt;em&gt;self&lt;/em&gt; по соответствующим (сглаженным) &lt;em&gt;индексам&lt;/em&gt; . Если &lt;em&gt;значения&lt;/em&gt; слишком малы, он будет повторяться по мере необходимости.</target>
        </trans-unit>
        <trans-unit id="65d607762120cf690bb00c590b16fa127fb75062" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;em&gt;self&lt;/em&gt;.ravel(&lt;em&gt;order&lt;/em&gt;). Same basic functionality as &lt;a href=&quot;#c.PyArray_Flatten&quot;&gt;&lt;code&gt;PyArray_Flatten&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;order&lt;/em&gt;) except if &lt;em&gt;order&lt;/em&gt; is 0 and &lt;em&gt;self&lt;/em&gt; is C-style contiguous, the shape is altered but no copy is performed.</source>
          <target state="translated">Эквивалентно &lt;em&gt;self&lt;/em&gt; .ravel ( &lt;em&gt;заказ&lt;/em&gt; ). Те же базовые функции, что и &lt;a href=&quot;#c.PyArray_Flatten&quot;&gt; &lt;code&gt;PyArray_Flatten&lt;/code&gt; &lt;/a&gt; ( &lt;em&gt;self&lt;/em&gt; , &lt;em&gt;order&lt;/em&gt; ), за исключением случаев, когда &lt;em&gt;order&lt;/em&gt; равен 0, а &lt;em&gt;self&lt;/em&gt; является смежным в стиле C, форма изменяется, но копирование не выполняется.</target>
        </trans-unit>
        <trans-unit id="9032a6cc40438a50e150a4a41ff47d4fe89a4820" translate="yes" xml:space="preserve">
          <source>Equivalent to PyArray_CanCastTypeTo(fromtype, totype, NPY_SAFE_CASTING).</source>
          <target state="translated">Эквивалент PyArray_CanCastTypeTo(fromtype,totype,NPY_SAFE_CASTING).</target>
        </trans-unit>
        <trans-unit id="aa1dee2d3e2220598a3bbd05e1af8c95afb8286e" translate="yes" xml:space="preserve">
          <source>Equivalent to Python&amp;rsquo;s &lt;code&gt;%&lt;/code&gt; operator.</source>
          <target state="translated">Эквивалентно оператору &lt;code&gt;%&lt;/code&gt; Python .</target>
        </trans-unit>
        <trans-unit id="c543b869fe6bab79a3a934117c7c6a1eff863d6f" translate="yes" xml:space="preserve">
          <source>Equivalent to Python&amp;rsquo;s &lt;code&gt;//&lt;/code&gt; operator.</source>
          <target state="translated">Эквивалентно оператору &lt;code&gt;//&lt;/code&gt; Python .</target>
        </trans-unit>
        <trans-unit id="731025cc785b584c28e327dc6f1d60cad5cb1eb2" translate="yes" xml:space="preserve">
          <source>Equivalent to but faster than &lt;code&gt;np.maximum(a_min, np.minimum(a, a_max))&lt;/code&gt;. No check is performed to ensure &lt;code&gt;a_min &amp;lt; a_max&lt;/code&gt;.</source>
          <target state="translated">Эквивалентно, но быстрее, чем &lt;code&gt;np.maximum(a_min, np.minimum(a, a_max))&lt;/code&gt; . Проверка не выполняется, чтобы гарантировать, что &lt;code&gt;a_min &amp;lt; a_max&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6b2f298705887fc3f13bb047301aaf8328f81dca" translate="yes" xml:space="preserve">
          <source>Equivalent to but faster than &lt;code&gt;np.minimum(a_max, np.maximum(a, a_min))&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e127cc159cef630175cb2a2528435fea3e7fcdb3" translate="yes" xml:space="preserve">
          <source>Equivalent to calling &lt;code&gt;$ nosetests &amp;lt;argv&amp;gt; &amp;lt;file_to_run&amp;gt;&lt;/code&gt; from the command line</source>
          <target state="translated">Эквивалентно вызову &lt;code&gt;$ nosetests &amp;lt;argv&amp;gt; &amp;lt;file_to_run&amp;gt;&lt;/code&gt; из командной строки</target>
        </trans-unit>
        <trans-unit id="ed8f3be106058d41aa3036c07045c7a5df9a7239" translate="yes" xml:space="preserve">
          <source>Equivalent to creating a copy of the array and applying the MaskedArray &lt;code&gt;sort()&lt;/code&gt; method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b847d0d31d2133c0201a061723b9aa92d8890f7" translate="yes" xml:space="preserve">
          <source>Equivalent to either NPY_INT or NPY_LONGLONG, depending on the platform.</source>
          <target state="translated">Эквивалент NPY_INT или NPY_LONGLONG,в зависимости от платформы.</target>
        </trans-unit>
        <trans-unit id="85f38ed4c0f6096936fc4b84fb6a21d19adcc1cb" translate="yes" xml:space="preserve">
          <source>Equivalent to either NPY_UINT or NPY_ULONGLONG, depending on the platform.</source>
          <target state="translated">Эквивалент NPY_UINT или NPY_ULONGLONG,в зависимости от платформы.</target>
        </trans-unit>
        <trans-unit id="d656dbe889cfc08e9f09fa23957b7de58cae8caa" translate="yes" xml:space="preserve">
          <source>Equivalent to m[:,::-1]. Requires the array to be at least 2-D.</source>
          <target state="translated">Эквивалент m[:,::-1].Требуется,чтобы массив был как минимум 2-D.</target>
        </trans-unit>
        <trans-unit id="1215aa39e41289b1c51c145e05d1743101aa9773" translate="yes" xml:space="preserve">
          <source>Equivalent to running:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a910d755d7e89acbf27b19fb05f069771ab0e7b" translate="yes" xml:space="preserve">
          <source>Equivalent to the Python &lt;code&gt;%&lt;/code&gt; operator.</source>
          <target state="translated">Эквивалентно оператору Python &lt;code&gt;%&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d371f28bfea1e852f448381bb4f0bdfccaa7149e" translate="yes" xml:space="preserve">
          <source>Equivalent to:</source>
          <target state="translated">Эквивалентно:</target>
        </trans-unit>
        <trans-unit id="f2c299359dd358c2f6f22a22ce8b45b901e994e8" translate="yes" xml:space="preserve">
          <source>Equivalently use the &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray&quot;&gt;&lt;code&gt;MaskedArray&lt;/code&gt;&lt;/a&gt;&lt;code&gt;mask&lt;/code&gt; attribute.</source>
          <target state="translated">Эквивалентно используйте &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray&quot;&gt; &lt;code&gt;MaskedArray&lt;/code&gt; &lt;/a&gt; &lt;code&gt;mask&lt;/code&gt; MaskedArray .</target>
        </trans-unit>
        <trans-unit id="6eed85d2c6463174f53200b994de55fedca2fe50" translate="yes" xml:space="preserve">
          <source>Equivalently use the &lt;code&gt;MaskedArray&lt;/code&gt;&lt;code&gt;data&lt;/code&gt; attribute.</source>
          <target state="translated">&lt;code&gt;MaskedArray&lt;/code&gt; используйте атрибут &lt;code&gt;data&lt;/code&gt; MaskedArray .</target>
        </trans-unit>
        <trans-unit id="e59ba61683ec6d73dab0ba426c13a6a7d9ed31cf" translate="yes" xml:space="preserve">
          <source>Equivalently, eliminating the inner loop, the last two lines would be:</source>
          <target state="translated">Эквивалентно,устраняя внутреннюю петлю,последние две линии были бы:</target>
        </trans-unit>
        <trans-unit id="6b59734e1b8f67d36df303549c4673ff4f6c8d66" translate="yes" xml:space="preserve">
          <source>Equivalently, eliminating the inner loop, this can be expressed as:</source>
          <target state="translated">Эквивалентно,устраняя внутренний цикл,это можно выразить так:</target>
        </trans-unit>
        <trans-unit id="28b75128748a47d2bb367541f76250db5dd9b6a0" translate="yes" xml:space="preserve">
          <source>Equivalently:</source>
          <target state="translated">Equivalently:</target>
        </trans-unit>
        <trans-unit id="149658b77c9d6e6cef1bb293ac32b781ccfe7dbd" translate="yes" xml:space="preserve">
          <source>Eric Wieser</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="73631d7f0356fdbdeaa36f8e5dbad89c6aa15dc4" translate="yes" xml:space="preserve">
          <source>Error handling</source>
          <target state="translated">обработка ошибок</target>
        </trans-unit>
        <trans-unit id="5f577c8bef8739558c43df8e8796bc8e5a825a61" translate="yes" xml:space="preserve">
          <source>Error objects</source>
          <target state="translated">Ошибки объектов</target>
        </trans-unit>
        <trans-unit id="f13df400826d5582075c86f7280e918d94d2f9f5" translate="yes" xml:space="preserve">
          <source>Error type changes</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4884820cd63fe6870fd18f5bb40f96cacf7c1253" translate="yes" xml:space="preserve">
          <source>Errors result if the second argument is also supplied when x is a scalar input, if first and second arguments have different shapes, or if the first argument has complex values</source>
          <target state="translated">Ошибки возникают,если второй аргумент также передан,когда x является скалярным входом,если первый и второй аргументы имеют разную форму,или если первый аргумент имеет сложные значения</target>
        </trans-unit>
        <trans-unit id="68e944c31c80a964e18589df952c8e941c618fb2" translate="yes" xml:space="preserve">
          <source>Errors result if the second argument is also supplied when x is a scalar input, if first and second arguments have different shapes, or if the first argument has complex values.</source>
          <target state="translated">Ошибки возникают,если второй аргумент также поставляется,когда x является скалярным входом,если первый и второй аргументы имеют разную форму,или если первый аргумент имеет сложные значения.</target>
        </trans-unit>
        <trans-unit id="6896dc5d66baa055255d6a61e0f3010c1fcb944f" translate="yes" xml:space="preserve">
          <source>Errors result if the second argument is supplied when the first argument is a scalar, or if the first and second arguments have different shapes.</source>
          <target state="translated">Ошибки возникают,если второй аргумент передан,когда первый аргумент является скаляром,или если первый и второй аргументы имеют разную форму.</target>
        </trans-unit>
        <trans-unit id="e6308f5d5324d30901fdba46e76a6baf1ab30827" translate="yes" xml:space="preserve">
          <source>Establish a timeline for mediation to complete, ideally within two weeks.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e5c90765bd01e407f47b56e1714c9f9bd1ace4b" translate="yes" xml:space="preserve">
          <source>Estimate a covariance matrix, given data and weights.</source>
          <target state="translated">Оцените ковариационную матрицу,заданные данные и веса.</target>
        </trans-unit>
        <trans-unit id="3ff0c8c72ff670edbc5bdbae93aa2dbd2e54c4c0" translate="yes" xml:space="preserve">
          <source>Estimate the covariance matrix.</source>
          <target state="translated">Оцените ковариационную матрицу.</target>
        </trans-unit>
        <trans-unit id="2e86acb34f53f4c550f3dcf28b42823f0f59d900" translate="yes" xml:space="preserve">
          <source>Estimator based on leave-one-out cross-validation estimate of the integrated squared error. Can be regarded as a generalization of Scott&amp;rsquo;s rule.</source>
          <target state="translated">Оценщик, основанный на перекрестной проверке единичного исключения интегрированной квадратичной ошибки. Можно рассматривать как обобщение правила Скотта.</target>
        </trans-unit>
        <trans-unit id="35592e888d12a9934594d9f1f111830a7b9f7f37" translate="yes" xml:space="preserve">
          <source>Estimator does not take variability into account, only data size. Commonly overestimates number of bins required.</source>
          <target state="translated">Оценщик не учитывает вариабельность,а только размер данных.Обычно завышает количество требуемых бункеров.</target>
        </trans-unit>
        <trans-unit id="da87f1093e8c246b1f6d85fea3650000b6da3790" translate="yes" xml:space="preserve">
          <source>Euler&amp;rsquo;s constant, base of natural logarithms, Napier&amp;rsquo;s constant.</source>
          <target state="translated">Константа Эйлера, основание натурального логарифма, постоянная Напье.</target>
        </trans-unit>
        <trans-unit id="f91dd3dbbfae685abb68bc410da02d957a011629" translate="yes" xml:space="preserve">
          <source>Evaluate a 2-D Chebyshev series at points (x, y).</source>
          <target state="translated">Оценить двухмерную чебышевскую серию в точках (x,y).</target>
        </trans-unit>
        <trans-unit id="e05e0d192839700194b0291808ce8475fe0d0cc1" translate="yes" xml:space="preserve">
          <source>Evaluate a 2-D Chebyshev series on the Cartesian product of x and y.</source>
          <target state="translated">Оценить двухмерную чебышевскую серию по декартовому продукту x и y.</target>
        </trans-unit>
        <trans-unit id="7249c2fe23f2e17738db2110e9c2474dc3a27187" translate="yes" xml:space="preserve">
          <source>Evaluate a 2-D Hermite series at points (x, y).</source>
          <target state="translated">Оцените 2-D серии &quot;Эрмита&quot; в точках (x,y).</target>
        </trans-unit>
        <trans-unit id="12ed956c99b6390def2dd7ee918ef9474cc02f06" translate="yes" xml:space="preserve">
          <source>Evaluate a 2-D Hermite series on the Cartesian product of x and y.</source>
          <target state="translated">Оценить двухмерную эрмитажную серию на декартовом изделии x и y.</target>
        </trans-unit>
        <trans-unit id="cedce799e74482d1942c64f4cd11a5b3fd98c128" translate="yes" xml:space="preserve">
          <source>Evaluate a 2-D HermiteE series at points (x, y).</source>
          <target state="translated">Оцените 2-D серии HermiteE в точках (x,y).</target>
        </trans-unit>
        <trans-unit id="48cc948294af1d7f259543794e3f125d854efce7" translate="yes" xml:space="preserve">
          <source>Evaluate a 2-D HermiteE series on the Cartesian product of x and y.</source>
          <target state="translated">Оцените 2-мерную серию HermiteE на декартовом изделии x и y.</target>
        </trans-unit>
        <trans-unit id="338d5b747397dce60dd29055f57344efa1d37666" translate="yes" xml:space="preserve">
          <source>Evaluate a 2-D Laguerre series at points (x, y).</source>
          <target state="translated">Оцените двухмерную серию Лагер в точках (x,y).</target>
        </trans-unit>
        <trans-unit id="4a829f126487a9ec9a923ab666b31db182581736" translate="yes" xml:space="preserve">
          <source>Evaluate a 2-D Laguerre series on the Cartesian product of x and y.</source>
          <target state="translated">Оцените серию 2-D Laguerre на декартовом изделии x и y.</target>
        </trans-unit>
        <trans-unit id="bb447e6da0b73bad544e19cbcbc6052261416eb9" translate="yes" xml:space="preserve">
          <source>Evaluate a 2-D Legendre series at points (x, y).</source>
          <target state="translated">Оцените двухмерную серию Legendre в точках (x,y).</target>
        </trans-unit>
        <trans-unit id="7373a9e22eb3236ef35b254cc0cb7ed7d29c6948" translate="yes" xml:space="preserve">
          <source>Evaluate a 2-D Legendre series on the Cartesian product of x and y.</source>
          <target state="translated">Оцените двухмерную серию Legendre на декартовом изделии x и y.</target>
        </trans-unit>
        <trans-unit id="a527503bfcf8c4cb30f6f6943d6775ba7732cdef" translate="yes" xml:space="preserve">
          <source>Evaluate a 2-D polynomial at points (x, y).</source>
          <target state="translated">Оцените двухмерный полином в точках (x,y).</target>
        </trans-unit>
        <trans-unit id="03726da2d6f02abab8a254ba40a2a300ecaef683" translate="yes" xml:space="preserve">
          <source>Evaluate a 2-D polynomial on the Cartesian product of x and y.</source>
          <target state="translated">Оцените двухмерный полином на декартовом продукте x и y.</target>
        </trans-unit>
        <trans-unit id="9029d2c825f46990756a36847b1a1b6ef93e7f31" translate="yes" xml:space="preserve">
          <source>Evaluate a 3-D Chebyshev series at points (x, y, z).</source>
          <target state="translated">Оценить трехмерный чебышевский ряд в точках (x,y,z).</target>
        </trans-unit>
        <trans-unit id="6e0bda3c65d8c3458e685987ef115c2f03e1ce48" translate="yes" xml:space="preserve">
          <source>Evaluate a 3-D Chebyshev series on the Cartesian product of x, y, and z.</source>
          <target state="translated">Оценить трехмерную чебышевскую серию по декартовому изделию x,y и z.</target>
        </trans-unit>
        <trans-unit id="ae23b9ad402238d53a7767ef4d1d0feecad8d46a" translate="yes" xml:space="preserve">
          <source>Evaluate a 3-D Hermite series at points (x, y, z).</source>
          <target state="translated">Оцените 3-D ряд &quot;Эрмита&quot; в точках (x,y,z).</target>
        </trans-unit>
        <trans-unit id="1fa86ea2fa2a78cb282ebd3e58571d4035e81572" translate="yes" xml:space="preserve">
          <source>Evaluate a 3-D Hermite series on the Cartesian product of x, y, and z.</source>
          <target state="translated">Оценить трехмерную серию &quot;Эрмита&quot; на декартовом изделии x,y и z.</target>
        </trans-unit>
        <trans-unit id="e0e36a6aa699aa19c71e1fd7089481c08a161992" translate="yes" xml:space="preserve">
          <source>Evaluate a 3-D HermiteE series on the Cartesian product of x, y, and z.</source>
          <target state="translated">Оцените 3-D серию HermiteE на декартовом изделии x,y и z.</target>
        </trans-unit>
        <trans-unit id="645e8b8ce98d2275a7fb6f40acce5d53b7f2ad81" translate="yes" xml:space="preserve">
          <source>Evaluate a 3-D Hermite_e series at points (x, y, z).</source>
          <target state="translated">Оценить 3-D ряд Hermite_e в точках (x,y,z).</target>
        </trans-unit>
        <trans-unit id="ea580f96650cb24e9fc6eb589c30aba361084e3d" translate="yes" xml:space="preserve">
          <source>Evaluate a 3-D Laguerre series at points (x, y, z).</source>
          <target state="translated">Оцените трехмерную серию Лагер в точках (x,y,z).</target>
        </trans-unit>
        <trans-unit id="345ed8afbed95aea3201f6d8df2e9d955fe4ee9d" translate="yes" xml:space="preserve">
          <source>Evaluate a 3-D Laguerre series on the Cartesian product of x, y, and z.</source>
          <target state="translated">Оцените серию 3-D Laguerre на декартовом изделии x,y и z.</target>
        </trans-unit>
        <trans-unit id="fc1af478b3c58299201cb5fd893a359ec10739ca" translate="yes" xml:space="preserve">
          <source>Evaluate a 3-D Legendre series at points (x, y, z).</source>
          <target state="translated">Оцените трехмерную серию Легенды в точках (x,y,z).</target>
        </trans-unit>
        <trans-unit id="888774bb82f3f8de5edab168d25dbd0a2eb3d033" translate="yes" xml:space="preserve">
          <source>Evaluate a 3-D Legendre series on the Cartesian product of x, y, and z.</source>
          <target state="translated">Оцените трехмерную серию Legendre на декартовом изделии x,y и z.</target>
        </trans-unit>
        <trans-unit id="e8846df08e194f124fe8cded1c782376715e8f39" translate="yes" xml:space="preserve">
          <source>Evaluate a 3-D polynomial at points (x, y, z).</source>
          <target state="translated">Оцените трехмерный полином в точках (x,y,z).</target>
        </trans-unit>
        <trans-unit id="33f78fc3c5ae1454f9df0431d3f3fda38023ac26" translate="yes" xml:space="preserve">
          <source>Evaluate a 3-D polynomial on the Cartesian product of x, y and z.</source>
          <target state="translated">Оцените трехмерный полином на декартовом продукте x,y и z.</target>
        </trans-unit>
        <trans-unit id="8b4e7acfc43ebffbd9c6285f10ac1b60b175795c" translate="yes" xml:space="preserve">
          <source>Evaluate a Chebyshev series at points x.</source>
          <target state="translated">Оценить чебышевскую серию в точках x.</target>
        </trans-unit>
        <trans-unit id="1f4ce01843c1515b967b600cb8fa4018d3436eaa" translate="yes" xml:space="preserve">
          <source>Evaluate a Laguerre series at points x.</source>
          <target state="translated">Оцените серию Лагер в точках x.</target>
        </trans-unit>
        <trans-unit id="161f6a7aae0d5d7f196e5ee0e04ba73d7963b76b" translate="yes" xml:space="preserve">
          <source>Evaluate a Legendre series at points x.</source>
          <target state="translated">Оцените серию Легенды в точках x.</target>
        </trans-unit>
        <trans-unit id="1cc49d22e70eea61f6bdc96018100e105aba00e0" translate="yes" xml:space="preserve">
          <source>Evaluate a piecewise-defined function.</source>
          <target state="translated">Оцените функцию,определяемую по частям.</target>
        </trans-unit>
        <trans-unit id="79a283e785c7b9ab6cbfe6dbfe59b713502d0afb" translate="yes" xml:space="preserve">
          <source>Evaluate a polynomial at points x.</source>
          <target state="translated">Оцените полином в точках x.</target>
        </trans-unit>
        <trans-unit id="ac86c84a106ffc30d8eceed0ff68761b61ebad9a" translate="yes" xml:space="preserve">
          <source>Evaluate a polynomial at specific values.</source>
          <target state="translated">Оцените полином при определенных значениях.</target>
        </trans-unit>
        <trans-unit id="283714fe4f49f84ab071c16c98a04aac5c0eb13d" translate="yes" xml:space="preserve">
          <source>Evaluate a polynomial specified by its roots at points x.</source>
          <target state="translated">Оценить многочлен,заданный его корнями в точках x.</target>
        </trans-unit>
        <trans-unit id="5ae76cb25d3ddcb8fd7f5add4137cfe2c33287a6" translate="yes" xml:space="preserve">
          <source>Evaluate an Hermite series at points x.</source>
          <target state="translated">Оцените серию &quot;Эрмита&quot; в точках x.</target>
        </trans-unit>
        <trans-unit id="ce1ba49b7053d6908dd1d4b7a38524a5c4ffc2df" translate="yes" xml:space="preserve">
          <source>Evaluate an HermiteE series at points x.</source>
          <target state="translated">Оцените серию HermiteE в точках x.</target>
        </trans-unit>
        <trans-unit id="a389fe7d0ca7745a323c209ce5b023a9e30716fa" translate="yes" xml:space="preserve">
          <source>Evaluate the polynomial at</source>
          <target state="translated">Оцените полиноминал на</target>
        </trans-unit>
        <trans-unit id="201867eba810e127d20356b4920cc833601a5f27" translate="yes" xml:space="preserve">
          <source>Evaluates TRUE as long as the iterator has not looped through all of the elements, otherwise it evaluates FALSE.</source>
          <target state="translated">Оценивает TRUE до тех пор,пока итератор не пройдет через все элементы,в противном случае он оценивает FALSE.</target>
        </trans-unit>
        <trans-unit id="a61e7944eeb541b39ec48ef4572671aa9245dfe1" translate="yes" xml:space="preserve">
          <source>Evaluates TRUE as long as the multi-iterator has not looped through all of the elements (of the broadcasted result), otherwise it evaluates FALSE.</source>
          <target state="translated">Оценивает TRUE до тех пор,пока мультилитератор не пройдет через все элементы (транслируемый результат),в противном случае он оценивает FALSE.</target>
        </trans-unit>
        <trans-unit id="22e5fc7652637561dc1ca3671ce7888c08020803" translate="yes" xml:space="preserve">
          <source>Evaluates a Chebyshev series.</source>
          <target state="translated">Оценивает чебышевскую серию.</target>
        </trans-unit>
        <trans-unit id="8f5b426162065bbed8197ac088255c41cba4b070" translate="yes" xml:space="preserve">
          <source>Evaluates a Hermite series.</source>
          <target state="translated">Оценивает серию &quot;Эрмита&quot;.</target>
        </trans-unit>
        <trans-unit id="df7f15c01da2df8b851fc9f6e1e067fbbad7da62" translate="yes" xml:space="preserve">
          <source>Evaluates a Laguerre series.</source>
          <target state="translated">Оценивает серию Лагер.</target>
        </trans-unit>
        <trans-unit id="24200a16cfb4d36b211f0c64c8db3868f1aa7d7b" translate="yes" xml:space="preserve">
          <source>Evaluates a Legendre series.</source>
          <target state="translated">Оценивает серию &quot;Легенда&quot;.</target>
        </trans-unit>
        <trans-unit id="85ee46dc575694a88add8fcac6da5ac9ea0ec2c1" translate="yes" xml:space="preserve">
          <source>Evaluates a polynomial.</source>
          <target state="translated">Оценивает полиноминал.</target>
        </trans-unit>
        <trans-unit id="c6780dad55d1f852632365f7570aa643328d5b06" translate="yes" xml:space="preserve">
          <source>Evaluates as True if arrays &lt;em&gt;a1&lt;/em&gt; and &lt;em&gt;a2&lt;/em&gt; have the same shape.</source>
          <target state="translated">Вычисляется как Истина, если массивы &lt;em&gt;a1&lt;/em&gt; и &lt;em&gt;a2&lt;/em&gt; имеют одинаковую форму.</target>
        </trans-unit>
        <trans-unit id="14b73bad8268092556c3d59c6262a1db866e29f2" translate="yes" xml:space="preserve">
          <source>Evaluates as true if &lt;code&gt;a&lt;/code&gt; is FORTRAN ordered.</source>
          <target state="translated">Оценивается как истина, если &lt;code&gt;a&lt;/code&gt; заказан на FORTRAN.</target>
        </trans-unit>
        <trans-unit id="74face1b8e76f520379a33453af827275b42370d" translate="yes" xml:space="preserve">
          <source>Evaluates as true if &lt;code&gt;a&lt;/code&gt; is a contiguous array. Equivalent to &lt;code&gt;(PyArray_ISCONTIGUOUS(a))&lt;/code&gt;.</source>
          <target state="translated">Оценивает как верно , если представляет собой непрерывный массив. Эквивалентен &lt;code&gt;(PyArray_ISCONTIGUOUS(a))&lt;/code&gt; . &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6a92de714017736a8a012563cdae53ed5c18d733" translate="yes" xml:space="preserve">
          <source>Evaluates as true if &lt;code&gt;a&lt;/code&gt; is non-&lt;code&gt;NULL&lt;/code&gt; and can be cast to a &lt;code&gt;PyArrayObject*&lt;/code&gt;.</source>
          <target state="translated">Вычисляет как истину, если &lt;code&gt;a&lt;/code&gt; не &lt;code&gt;NULL&lt;/code&gt; и может быть приведено к &lt;code&gt;PyArrayObject*&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="30b857f72fdd592a4e93e214be9f6a2a22f1daa5" translate="yes" xml:space="preserve">
          <source>Evaluates as true if &lt;em&gt;obj&lt;/em&gt; is a data-type object ( &lt;a href=&quot;c-api.types-and-structures#c.PyArray_Descr&quot;&gt;&lt;code&gt;PyArray_Descr *&lt;/code&gt;&lt;/a&gt; ).</source>
          <target state="translated">Оценивается как истина, если &lt;em&gt;obj&lt;/em&gt; является объектом типа данных ( &lt;a href=&quot;c-api.types-and-structures#c.PyArray_Descr&quot;&gt; &lt;code&gt;PyArray_Descr *&lt;/code&gt; &lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="1b0b459a4df746d063d9691e5dca8206407e50e5" translate="yes" xml:space="preserve">
          <source>Evaluates as true if &lt;em&gt;obj&lt;/em&gt; is a data-type object ( &lt;a href=&quot;types-and-structures#c.PyArray_Descr&quot;&gt;&lt;code&gt;PyArray_Descr *&lt;/code&gt;&lt;/a&gt; ).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01d60164442fc0f55a5557baa1dde2ec4ee3a192" translate="yes" xml:space="preserve">
          <source>Evaluates as true if the data buffer of &lt;code&gt;a&lt;/code&gt; uses native byte order. Equivalent to &lt;code&gt;(PyArray_ISNOTSWAPPED(a))&lt;/code&gt;.</source>
          <target state="translated">Оценивает , как верно , если данные буфера в &lt;code&gt;a&lt;/code&gt; использования родной порядок байтов. Эквивалентен &lt;code&gt;(PyArray_ISNOTSWAPPED(a))&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="dcbfc3fc7cd5c92daad9c6700316991a65012cae" translate="yes" xml:space="preserve">
          <source>Evaluates pyfunc over input arrays using broadcasting rules of numpy.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="88a80c85f7d09b073fbd515eb093798e576dcd94" translate="yes" xml:space="preserve">
          <source>Evaluates the Einstein summation convention on the operands.</source>
          <target state="translated">Оценивает итоговый съезд Эйнштейна по оперным спектаклям.</target>
        </trans-unit>
        <trans-unit id="09f56994a692d463245ca900188d259358a1a1e3" translate="yes" xml:space="preserve">
          <source>Evaluates the lowest cost contraction order for an einsum expression by considering the creation of intermediate arrays.</source>
          <target state="translated">Оценивает наименьший стоимостной порядок сжатия для выражения инсума,рассматривая создание промежуточных массивов.</target>
        </trans-unit>
        <trans-unit id="a4fdb9cdb108616be69434eab1761cc78b88d33b" translate="yes" xml:space="preserve">
          <source>Evaluates to a pointer of type &lt;code&gt;void*&lt;/code&gt; that points to the data buffer of &lt;code&gt;a&lt;/code&gt;, assuming &lt;code&gt;a&lt;/code&gt; can be cast to a &lt;code&gt;PyArrayObject*&lt;/code&gt;.</source>
          <target state="translated">Вычисляет указатель типа &lt;code&gt;void*&lt;/code&gt; который указывает на буфер данных объекта &lt;code&gt;a&lt;/code&gt; , предполагая, что &lt;code&gt;a&lt;/code&gt; может быть приведено к &lt;code&gt;PyArrayObject*&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5b165cdcba7dabc88d6d0700bab2cea35959b8e6" translate="yes" xml:space="preserve">
          <source>Evaluates to an array of type &lt;code&gt;npy_intp&lt;/code&gt; and length &lt;code&gt;array_numdims(a)&lt;/code&gt;, giving the lengths of all of the dimensions of &lt;code&gt;a&lt;/code&gt;, assuming &lt;code&gt;a&lt;/code&gt; can be cast to a &lt;code&gt;PyArrayObject*&lt;/code&gt;.</source>
          <target state="translated">Вычисляет массив типа &lt;code&gt;npy_intp&lt;/code&gt; и length &lt;code&gt;array_numdims(a)&lt;/code&gt; , давая длины всех измерений &lt;code&gt;a&lt;/code&gt; , предполагая, что &lt;code&gt;a&lt;/code&gt; может быть &lt;code&gt;PyArrayObject*&lt;/code&gt; в PyArrayObject * .</target>
        </trans-unit>
        <trans-unit id="4d18aba4418a76811df39bd817fcca0ecc3daf26" translate="yes" xml:space="preserve">
          <source>Evaluates to an array of type &lt;code&gt;npy_intp&lt;/code&gt; and length &lt;code&gt;array_numdims(a)&lt;/code&gt;, giving the stridess of all of the dimensions of &lt;code&gt;a&lt;/code&gt;, assuming &lt;code&gt;a&lt;/code&gt; can be cast to a &lt;code&gt;PyArrayObject*&lt;/code&gt;. A stride is the distance in bytes between an element and its immediate neighbor along the same axis.</source>
          <target state="translated">Вычисляет массив типа &lt;code&gt;npy_intp&lt;/code&gt; и длины &lt;code&gt;array_numdims(a)&lt;/code&gt; , давая последовательность всех измерений &lt;code&gt;a&lt;/code&gt; , предполагая, что &lt;code&gt;a&lt;/code&gt; может быть приведено к &lt;code&gt;PyArrayObject*&lt;/code&gt; . Шаг - это расстояние в байтах между элементом и его ближайшим соседом по той же оси.</target>
        </trans-unit>
        <trans-unit id="ee0a95426dfe5b7eb47ffd5ae2f4fb51edb35193" translate="yes" xml:space="preserve">
          <source>Evaluates to the &lt;code&gt;i&lt;/code&gt;-th dimension size of &lt;code&gt;a&lt;/code&gt;, assuming &lt;code&gt;a&lt;/code&gt; can be cast to a &lt;code&gt;PyArrayObject*&lt;/code&gt;.</source>
          <target state="translated">Вычисляет размер &lt;code&gt;i&lt;/code&gt; -го измерения &lt;code&gt;a&lt;/code&gt; , предполагая, что &lt;code&gt;a&lt;/code&gt; может быть приведено к &lt;code&gt;PyArrayObject*&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5d4d289826f9e7f76dff23ce9b5a0d1ae92ad3cc" translate="yes" xml:space="preserve">
          <source>Evaluates to the &lt;code&gt;i&lt;/code&gt;-th stride of &lt;code&gt;a&lt;/code&gt;, assuming &lt;code&gt;a&lt;/code&gt; can be cast to a &lt;code&gt;PyArrayObject*&lt;/code&gt;.</source>
          <target state="translated">Вычисляет &lt;code&gt;i&lt;/code&gt; -й шаг &lt;code&gt;a&lt;/code&gt; , предполагая, что &lt;code&gt;a&lt;/code&gt; может быть приведено к &lt;code&gt;PyArrayObject*&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="32b35e339f75424281676b07ad9e28b079acb58f" translate="yes" xml:space="preserve">
          <source>Evaluates to the integer data type code of &lt;code&gt;a&lt;/code&gt;, assuming &lt;code&gt;a&lt;/code&gt; can be cast to a &lt;code&gt;PyArrayObject*&lt;/code&gt;.</source>
          <target state="translated">Вычисляет код целочисленного типа данных &lt;code&gt;a&lt;/code&gt; , предполагая, что &lt;code&gt;a&lt;/code&gt; может быть приведен к &lt;code&gt;PyArrayObject*&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="60ab5981a7770a6202629fec1405f5cf8e6b68cf" translate="yes" xml:space="preserve">
          <source>Evaluates to the integer number of dimensions of &lt;code&gt;a&lt;/code&gt;, assuming &lt;code&gt;a&lt;/code&gt; can be cast to a &lt;code&gt;PyArrayObject*&lt;/code&gt;.</source>
          <target state="translated">Вычисляет целое число измерений &lt;code&gt;a&lt;/code&gt; , предполагая, что &lt;code&gt;a&lt;/code&gt; может быть приведено к &lt;code&gt;PyArrayObject*&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0be0f4e7a59afdff5acbdbf74f20f94ceb3fdc16" translate="yes" xml:space="preserve">
          <source>Evaluates true if &lt;em&gt;arr&lt;/em&gt; is C-style contiguous.</source>
          <target state="translated">Возвращает истину, если &lt;em&gt;arr&lt;/em&gt; является смежным в стиле C.</target>
        </trans-unit>
        <trans-unit id="ccd3cb113f37e222d005c24c43bbeb4bb385e088" translate="yes" xml:space="preserve">
          <source>Evaluates true if &lt;em&gt;arr&lt;/em&gt; is Fortran-style contiguous and &lt;em&gt;not&lt;/em&gt; C-style contiguous. &lt;a href=&quot;#c.PyArray_IS_F_CONTIGUOUS&quot;&gt;&lt;code&gt;PyArray_IS_F_CONTIGUOUS&lt;/code&gt;&lt;/a&gt; is the correct way to test for Fortran-style contiguity.</source>
          <target state="translated">Возвращает истину, если &lt;em&gt;arr&lt;/em&gt; является смежным в стиле Фортрана, а &lt;em&gt;не в&lt;/em&gt; стиле C. &lt;a href=&quot;#c.PyArray_IS_F_CONTIGUOUS&quot;&gt; &lt;code&gt;PyArray_IS_F_CONTIGUOUS&lt;/code&gt; &lt;/a&gt; - это правильный способ проверки смежности в стиле Fortran.</target>
        </trans-unit>
        <trans-unit id="299ed12a95038cc7c47da499ceb2b1bb9bee7088" translate="yes" xml:space="preserve">
          <source>Evaluates true if &lt;em&gt;arr&lt;/em&gt; is Fortran-style contiguous.</source>
          <target state="translated">Возвращает истину, если &lt;em&gt;arr&lt;/em&gt; является смежным в стиле Фортрана.</target>
        </trans-unit>
        <trans-unit id="0c6d7ddd3ec484ead393ec310ff7dd53898345cc" translate="yes" xml:space="preserve">
          <source>Evaluates true if &lt;em&gt;op&lt;/em&gt; is a Python object whose type is a sub-type of &lt;a href=&quot;c-api.types-and-structures#c.PyArray_Type&quot;&gt;&lt;code&gt;PyArray_Type&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Вычисляет истину, если &lt;em&gt;op&lt;/em&gt; является объектом Python, тип которого является &lt;a href=&quot;c-api.types-and-structures#c.PyArray_Type&quot;&gt; &lt;code&gt;PyArray_Type&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8d47b6abc57e8489e373d14442e0e135d79d490a" translate="yes" xml:space="preserve">
          <source>Evaluates true if &lt;em&gt;op&lt;/em&gt; is a Python object whose type is a sub-type of &lt;a href=&quot;types-and-structures#c.PyArray_Type&quot;&gt;&lt;code&gt;PyArray_Type&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eda799e9981a95fbdf277bb7b4cac9dbe1897388" translate="yes" xml:space="preserve">
          <source>Evaluates true if &lt;em&gt;op&lt;/em&gt; is a Python object with type &lt;a href=&quot;c-api.types-and-structures#c.PyArray_Type&quot;&gt;&lt;code&gt;PyArray_Type&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Вычисляет истину, если &lt;em&gt;op&lt;/em&gt; является объектом Python с типом &lt;a href=&quot;c-api.types-and-structures#c.PyArray_Type&quot;&gt; &lt;code&gt;PyArray_Type&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b99992949fa52eb31a616aa72ce3d2db9c377b8a" translate="yes" xml:space="preserve">
          <source>Evaluates true if &lt;em&gt;op&lt;/em&gt; is a Python object with type &lt;a href=&quot;types-and-structures#c.PyArray_Type&quot;&gt;&lt;code&gt;PyArray_Type&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6eeb9c0e570ee6c3d7212996fe6c19be5c590a98" translate="yes" xml:space="preserve">
          <source>Evaluates true if &lt;em&gt;op&lt;/em&gt; is a Python scalar object (see &lt;a href=&quot;#c.PyArray_IsPythonScalar&quot;&gt;&lt;code&gt;PyArray_IsPythonScalar&lt;/code&gt;&lt;/a&gt;), an array scalar (an instance of a sub-type of &lt;code&gt;PyGenericArr_Type&lt;/code&gt;) or an instance of a sub-type of &lt;a href=&quot;c-api.types-and-structures#c.PyArray_Type&quot;&gt;&lt;code&gt;PyArray_Type&lt;/code&gt;&lt;/a&gt; whose dimensionality is 0.</source>
          <target state="translated">Вычисляет истину, если &lt;em&gt;op&lt;/em&gt; является скалярным объектом Python (см. &lt;a href=&quot;#c.PyArray_IsPythonScalar&quot;&gt; &lt;code&gt;PyArray_IsPythonScalar&lt;/code&gt; &lt;/a&gt; ), скаляром массива (экземпляром &lt;code&gt;PyGenericArr_Type&lt;/code&gt; ) или экземпляром &lt;a href=&quot;c-api.types-and-structures#c.PyArray_Type&quot;&gt; &lt;code&gt;PyArray_Type&lt;/code&gt; &lt;/a&gt; , размерность которого равна 0.</target>
        </trans-unit>
        <trans-unit id="77128428ecc736c262cee4d932684f9895a30acc" translate="yes" xml:space="preserve">
          <source>Evaluates true if &lt;em&gt;op&lt;/em&gt; is a Python scalar object (see &lt;a href=&quot;#c.PyArray_IsPythonScalar&quot;&gt;&lt;code&gt;PyArray_IsPythonScalar&lt;/code&gt;&lt;/a&gt;), an array scalar (an instance of a sub-type of &lt;code&gt;PyGenericArr_Type&lt;/code&gt;) or an instance of a sub-type of &lt;a href=&quot;types-and-structures#c.PyArray_Type&quot;&gt;&lt;code&gt;PyArray_Type&lt;/code&gt;&lt;/a&gt; whose dimensionality is 0.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="67ae1d1c2d9114996b7543dee8f883c75689b0de" translate="yes" xml:space="preserve">
          <source>Evaluates true if &lt;em&gt;op&lt;/em&gt; is a builtin Python scalar object (int, float, complex, bytes, str, long, bool).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="782aad878c58725282c24466a66a6d37025e0309" translate="yes" xml:space="preserve">
          <source>Evaluates true if &lt;em&gt;op&lt;/em&gt; is a builtin Python scalar object (int, float, complex, str, unicode, long, bool).</source>
          <target state="translated">Вычисляет истину, если &lt;em&gt;op&lt;/em&gt; является встроенным скалярным объектом Python (int, float, complex, str, unicode, long, bool).</target>
        </trans-unit>
        <trans-unit id="f7b432815e26220931657feceb0900b1d3b25457" translate="yes" xml:space="preserve">
          <source>Evaluates true if &lt;em&gt;op&lt;/em&gt; is an array iterator (or instance of a subclass of the array iterator type).</source>
          <target state="translated">Вычисляет истину, если &lt;em&gt;op&lt;/em&gt; является итератором массива (или экземпляром подкласса типа итератора массива).</target>
        </trans-unit>
        <trans-unit id="72e9df6c71cba94b804e10a331ae768c03dc3136" translate="yes" xml:space="preserve">
          <source>Evaluates true if &lt;em&gt;op&lt;/em&gt; is an instance of (a subclass of) &lt;a href=&quot;c-api.types-and-structures#c.PyArray_Type&quot;&gt;&lt;code&gt;PyArray_Type&lt;/code&gt;&lt;/a&gt; and has 0 dimensions.</source>
          <target state="translated">Вычисляет истину, если &lt;em&gt;op&lt;/em&gt; является экземпляром (подклассом) &lt;a href=&quot;c-api.types-and-structures#c.PyArray_Type&quot;&gt; &lt;code&gt;PyArray_Type&lt;/code&gt; &lt;/a&gt; и имеет 0 измерений.</target>
        </trans-unit>
        <trans-unit id="a92e36e0c44fee9b890a2256c6136f6838cd352e" translate="yes" xml:space="preserve">
          <source>Evaluates true if &lt;em&gt;op&lt;/em&gt; is an instance of (a subclass of) &lt;a href=&quot;types-and-structures#c.PyArray_Type&quot;&gt;&lt;code&gt;PyArray_Type&lt;/code&gt;&lt;/a&gt; and has 0 dimensions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5906e8dd00d0a1adb4ea6aa8b5091429c7f25bb2" translate="yes" xml:space="preserve">
          <source>Evaluates true if &lt;em&gt;op&lt;/em&gt; is an instance of &lt;code&gt;Py{cls}ArrType_Type&lt;/code&gt;.</source>
          <target state="translated">Вычисляет истину, если &lt;em&gt;op&lt;/em&gt; является экземпляром &lt;code&gt;Py{cls}ArrType_Type&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4fb6fa662c78b1650cad28ec8017fe594278de63" translate="yes" xml:space="preserve">
          <source>Evaluates true if &lt;em&gt;op&lt;/em&gt; is an instance of a builtin numeric type (int, float, complex, long, bool)</source>
          <target state="translated">Вычисляет истину, если &lt;em&gt;op&lt;/em&gt; является экземпляром встроенного числового типа (int, float, complex, long, bool)</target>
        </trans-unit>
        <trans-unit id="ab21393a2ba887799bdff9d28c50be01d0b70f5b" translate="yes" xml:space="preserve">
          <source>Evaluates true if &lt;em&gt;op&lt;/em&gt; is either a Python scalar object (see &lt;a href=&quot;#c.PyArray_IsPythonScalar&quot;&gt;&lt;code&gt;PyArray_IsPythonScalar&lt;/code&gt;&lt;/a&gt;) or an array scalar (an instance of a sub- type of &lt;code&gt;PyGenericArr_Type&lt;/code&gt; ).</source>
          <target state="translated">Вычисляет истину, если &lt;em&gt;op&lt;/em&gt; является либо скалярным объектом Python (см. &lt;a href=&quot;#c.PyArray_IsPythonScalar&quot;&gt; &lt;code&gt;PyArray_IsPythonScalar&lt;/code&gt; &lt;/a&gt; ), либо скаляром массива (экземпляром &lt;code&gt;PyGenericArr_Type&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="cf7b1413b57bbc99790ccf42c73ff86cedf1427a" translate="yes" xml:space="preserve">
          <source>Evaluates true if &lt;em&gt;op&lt;/em&gt; is either an array scalar (an instance of a sub-type of &lt;code&gt;PyGenericArr_Type&lt;/code&gt; ), or an instance of (a sub-class of) &lt;a href=&quot;c-api.types-and-structures#c.PyArray_Type&quot;&gt;&lt;code&gt;PyArray_Type&lt;/code&gt;&lt;/a&gt; whose dimensionality is 0.</source>
          <target state="translated">Вычисляет истину, если &lt;em&gt;op&lt;/em&gt; является либо скаляром массива (экземпляр &lt;code&gt;PyGenericArr_Type&lt;/code&gt; ), либо экземпляром (подклассом) &lt;a href=&quot;c-api.types-and-structures#c.PyArray_Type&quot;&gt; &lt;code&gt;PyArray_Type&lt;/code&gt; &lt;/a&gt; , размерность которого равна 0.</target>
        </trans-unit>
        <trans-unit id="5912b104b67fdb86cc53730cfe7f9447f1497a17" translate="yes" xml:space="preserve">
          <source>Evaluates true if &lt;em&gt;op&lt;/em&gt; is either an array scalar (an instance of a sub-type of &lt;code&gt;PyGenericArr_Type&lt;/code&gt; ), or an instance of (a sub-class of) &lt;a href=&quot;types-and-structures#c.PyArray_Type&quot;&gt;&lt;code&gt;PyArray_Type&lt;/code&gt;&lt;/a&gt; whose dimensionality is 0.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="82908b45216f6f64aa572e8d9614febf36cdc646" translate="yes" xml:space="preserve">
          <source>Evaluates true if the data area of &lt;em&gt;arr&lt;/em&gt; can be written to</source>
          <target state="translated">Вычисляет истину, если область данных &lt;em&gt;arr&lt;/em&gt; может быть записана в</target>
        </trans-unit>
        <trans-unit id="a6798bac58d14b80f66da409bb3101b7acf52c78" translate="yes" xml:space="preserve">
          <source>Evaluates true if the data area of &lt;em&gt;arr&lt;/em&gt; consists of a single (C-style or Fortran-style) contiguous segment.</source>
          <target state="translated">Возвращает истину, если область данных &lt;em&gt;arr&lt;/em&gt; состоит из одного непрерывного сегмента (в стиле C или Fortran).</target>
        </trans-unit>
        <trans-unit id="52d051a4856042792e3562a8cf85f0b04c4a4af1" translate="yes" xml:space="preserve">
          <source>Evaluates true if the data area of &lt;em&gt;arr&lt;/em&gt; is C-style contiguous, aligned, and in machine byte-order.</source>
          <target state="translated">Вычисляет истину, если область данных &lt;em&gt;arr&lt;/em&gt; является непрерывной, выровненной и в машинном порядке байтов в стиле C.</target>
        </trans-unit>
        <trans-unit id="e202a99f33c9bfd2e1c5ac0fa0b8a81399b57105" translate="yes" xml:space="preserve">
          <source>Evaluates true if the data area of &lt;em&gt;arr&lt;/em&gt; is C-style contiguous, and &lt;a href=&quot;#c.PyArray_ISBEHAVED&quot;&gt;&lt;code&gt;PyArray_ISBEHAVED&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;arr&lt;/em&gt;) is true.</source>
          <target state="translated">Вычисляет истину, если область данных &lt;em&gt;arr&lt;/em&gt; является смежной в стиле C, а &lt;a href=&quot;#c.PyArray_ISBEHAVED&quot;&gt; &lt;code&gt;PyArray_ISBEHAVED&lt;/code&gt; &lt;/a&gt; ( &lt;em&gt;arr&lt;/em&gt; ) истинно.</target>
        </trans-unit>
        <trans-unit id="effc549b6cbff87555006675e1c79c18e43a5365" translate="yes" xml:space="preserve">
          <source>Evaluates true if the data area of &lt;em&gt;arr&lt;/em&gt; is Fortran-style contiguous and &lt;a href=&quot;#c.PyArray_ISBEHAVED&quot;&gt;&lt;code&gt;PyArray_ISBEHAVED&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;arr&lt;/em&gt;) is true.</source>
          <target state="translated">Вычисляет истину, если область данных &lt;em&gt;arr&lt;/em&gt; является смежной в стиле Фортрана, а &lt;a href=&quot;#c.PyArray_ISBEHAVED&quot;&gt; &lt;code&gt;PyArray_ISBEHAVED&lt;/code&gt; &lt;/a&gt; ( &lt;em&gt;arr&lt;/em&gt; ) истинно.</target>
        </trans-unit>
        <trans-unit id="8df904ca22ec2803d50d17cdbf121eedc6d72400" translate="yes" xml:space="preserve">
          <source>Evaluates true if the data area of &lt;em&gt;arr&lt;/em&gt; is Fortran-style contiguous, aligned, and in machine byte-order &lt;strong&gt;.&lt;/strong&gt;</source>
          <target state="translated">Вычисляет истину, если область данных &lt;em&gt;arr&lt;/em&gt; является смежной, выровненной и в машинном порядке байтов в стиле Фортрана &lt;strong&gt;.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7a1b64683aef87f7f1b4257764cf4227296d827e" translate="yes" xml:space="preserve">
          <source>Evaluates true if the data area of &lt;em&gt;arr&lt;/em&gt; is aligned and in machine byte-order.</source>
          <target state="translated">Возвращает истину, если область данных &lt;em&gt;arr&lt;/em&gt; выровнена и в машинном порядке байтов.</target>
        </trans-unit>
        <trans-unit id="f7f20e7e1e5772639b1f7c4eb4bff4d2800f8c2a" translate="yes" xml:space="preserve">
          <source>Evaluates true if the data area of &lt;em&gt;arr&lt;/em&gt; is aligned and writeable and in machine byte-order according to its descriptor.</source>
          <target state="translated">Вычисляет истину, если область данных &lt;em&gt;arr&lt;/em&gt; выровнена и доступна для записи и в машинном порядке байтов в соответствии с ее дескриптором.</target>
        </trans-unit>
        <trans-unit id="e474d3b13b1be737b699dd99e94b826acd4340ff" translate="yes" xml:space="preserve">
          <source>Evaluates true if the data area of &lt;em&gt;arr&lt;/em&gt; is properly aligned on the machine.</source>
          <target state="translated">Возвращает истину, если область данных &lt;em&gt;arr&lt;/em&gt; правильно выровнена на машине.</target>
        </trans-unit>
        <trans-unit id="2fa74bf1ebb6946b1363906270140aeda279cf9f" translate="yes" xml:space="preserve">
          <source>Evaluates true if the data area of the ndarray &lt;em&gt;m&lt;/em&gt; is &lt;strong&gt;not&lt;/strong&gt; in machine byte-order according to the array&amp;rsquo;s data-type descriptor.</source>
          <target state="translated">Вычисляет истину, если область данных ndarray &lt;em&gt;m &lt;/em&gt;&lt;strong&gt;не&lt;/strong&gt; находится в машинном порядке байтов в соответствии с дескриптором типа данных массива.</target>
        </trans-unit>
        <trans-unit id="3267c071decd2c90623cf8528c8e4938c54505e6" translate="yes" xml:space="preserve">
          <source>Evaluates true if the data area of the ndarray &lt;em&gt;m&lt;/em&gt; is in machine byte-order according to the array&amp;rsquo;s data-type descriptor.</source>
          <target state="translated">Вычисляет истину, если область данных ndarray &lt;em&gt;m&lt;/em&gt; находится в машинном порядке байтов в соответствии с дескриптором типа данных массива.</target>
        </trans-unit>
        <trans-unit id="74157d4f0e365e7c26ee7ae56617ac39f0fc6cb5" translate="yes" xml:space="preserve">
          <source>Evaluation:</source>
          <target state="translated">Evaluation:</target>
        </trans-unit>
        <trans-unit id="bfed403a77ac8bf381d674a3abfc57ba60883a8b" translate="yes" xml:space="preserve">
          <source>Even for contiguous arrays a stride for a given dimension &lt;code&gt;arr.strides[dim]&lt;/code&gt; may be &lt;em&gt;arbitrary&lt;/em&gt; if &lt;code&gt;arr.shape[dim] == 1&lt;/code&gt; or the array has no elements. It does &lt;em&gt;not&lt;/em&gt; generally hold that &lt;code&gt;self.strides[-1] == self.itemsize&lt;/code&gt; for C-style contiguous arrays or &lt;code&gt;self.strides[0] == self.itemsize&lt;/code&gt; for Fortran-style contiguous arrays is true.</source>
          <target state="translated">Даже для смежных массивов шаг для данного измерения &lt;code&gt;arr.strides[dim]&lt;/code&gt; может быть &lt;em&gt;произвольным,&lt;/em&gt; если &lt;code&gt;arr.shape[dim] == 1&lt;/code&gt; или массив не имеет элементов. Обычно &lt;em&gt;не&lt;/em&gt; считается, что &lt;code&gt;self.strides[-1] == self.itemsize&lt;/code&gt; для непрерывных массивов в стиле C или &lt;code&gt;self.strides[0] == self.itemsize&lt;/code&gt; для непрерывных массивов в стиле Fortran истинно.</target>
        </trans-unit>
        <trans-unit id="1298a53951ccd9aa53bf4ad3ab74e5154ee53b89" translate="yes" xml:space="preserve">
          <source>Even for contiguous arrays a stride for a given dimension &lt;code&gt;arr.strides[dim]&lt;/code&gt; may be &lt;em&gt;arbitrary&lt;/em&gt; if &lt;code&gt;arr.shape[dim] == 1&lt;/code&gt; or the array has no elements. It does &lt;em&gt;not&lt;/em&gt; generally hold that &lt;code&gt;self.strides[-1] == self.itemsize&lt;/code&gt; for C-style contiguous arrays or &lt;code&gt;self.strides[0] == self.itemsize&lt;/code&gt; for Fortran-style contiguous arrays is true. The correct way to access the &lt;code&gt;itemsize&lt;/code&gt; of an array from the C API is &lt;code&gt;PyArray_ITEMSIZE(arr)&lt;/code&gt;.</source>
          <target state="translated">Даже для смежных массивов шаг для данного измерения &lt;code&gt;arr.strides[dim]&lt;/code&gt; может быть &lt;em&gt;произвольным,&lt;/em&gt; если &lt;code&gt;arr.shape[dim] == 1&lt;/code&gt; или массив не имеет элементов. Обычно &lt;em&gt;не&lt;/em&gt; считается, что &lt;code&gt;self.strides[-1] == self.itemsize&lt;/code&gt; для непрерывных массивов в стиле C или &lt;code&gt;self.strides[0] == self.itemsize&lt;/code&gt; для непрерывных массивов в стиле Fortran истинно. Правильный способ доступа к &lt;code&gt;itemsize&lt;/code&gt; элементов массива из C API - &lt;code&gt;PyArray_ITEMSIZE(arr)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f9827d8888420fb8aa22f4344271feb523136ca5" translate="yes" xml:space="preserve">
          <source>Even though 0 occurs twice in the list of indices, the 0th element is only incremented once. This is because Python requires &amp;ldquo;a+=1&amp;rdquo; to be equivalent to &amp;ldquo;a = a + 1&amp;rdquo;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e92024a025e8d5da08f38acb277e2e10c54a8e1a" translate="yes" xml:space="preserve">
          <source>Even though the image is not as sharp, using a small number of &lt;code&gt;k&lt;/code&gt; singular values (compared to the original set of 768 values), we can recover many of the distinguishing features from this image.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c17cc6a8778f1a9a25e4a2f86caa32ef74f1e599" translate="yes" xml:space="preserve">
          <source>Even when the input array is two-dimensional:</source>
          <target state="translated">Даже если входной массив двумерный:</target>
        </trans-unit>
        <trans-unit id="42a0931fb2d7f42f3ac87c5b18547abf5d77fe06" translate="yes" xml:space="preserve">
          <source>Evenly round to the given number of decimals.</source>
          <target state="translated">Равномерно по заданному числу десятичных знаков.</target>
        </trans-unit>
        <trans-unit id="a19e0ffd5cc3d9a3df8ad933c77e6bea9dd169fb" translate="yes" xml:space="preserve">
          <source>Evenly spaced numbers with careful handling of endpoints.</source>
          <target state="translated">Равномерно распределенные числа при бережном обращении с конечными точками.</target>
        </trans-unit>
        <trans-unit id="1b950907a8c83b7ddb21092298e5404983c4a665" translate="yes" xml:space="preserve">
          <source>Eventually, expect to &lt;code&gt;__array_function__&lt;/code&gt; to always be enabled.</source>
          <target state="translated">В конце концов, ожидайте, что &lt;code&gt;__array_function__&lt;/code&gt; всегда будет включен.</target>
        </trans-unit>
        <trans-unit id="581f2179fc03c06bcc3dcff4b3f8f2a107464b3a" translate="yes" xml:space="preserve">
          <source>Every Python module, extension module, or subpackage in the SciPy package directory should have a corresponding &lt;code&gt;test_&amp;lt;name&amp;gt;.py&lt;/code&gt; file. Pytest examines these files for test methods (named test*) and test classes (named Test*).</source>
          <target state="translated">Каждый модуль Python, модуль расширения или подпакет в каталоге пакета SciPy должен иметь соответствующий &lt;code&gt;test_&amp;lt;name&amp;gt;.py&lt;/code&gt; . Pytest проверяет эти файлы на предмет методов тестирования (с именем test *) и тестовых классов (с именем Test *).</target>
        </trans-unit>
        <trans-unit id="8b7039d02f9e55e5e4b1540b84794daa8aa48877" translate="yes" xml:space="preserve">
          <source>Every module should have a docstring at the very top of the file. The module&amp;rsquo;s docstring may extend over multiple lines. If your docstring does extend over multiple lines, the closing three quotation marks must be on a line by itself, preferably preceded by a blank line.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fae734cbfb45b3c7fcea4a1b93bd51caeedc12aa" translate="yes" xml:space="preserve">
          <source>Every ufunc calculation involves some overhead related to setting up the calculation. The practical significance of this overhead is that even though the actual calculation of the ufunc is very fast, you will be able to write array and type-specific code that will work faster for small arrays than the ufunc. In particular, using ufuncs to perform many calculations on 0-D arrays will be slower than other Python-based solutions (the silently-imported scalarmath module exists precisely to give array scalars the look-and-feel of ufunc based calculations with significantly reduced overhead).</source>
          <target state="translated">Каждое вычисление ufunc предполагает некоторые накладные расходы,связанные с настройкой вычисления.Практическая значимость этих накладных расходов заключается в том,что,несмотря на то,что вычисление ufunc происходит очень быстро,вы сможете написать код,специфичный для массивов и типов,который будет работать быстрее для маленьких массивов,чем ufunc.В частности,использование ufuncs для выполнения многих вычислений на 0-D массивах будет медленнее,чем другие решения на базе Python (беззвучно импортируемый модуль scalarmath существует именно для того,чтобы обеспечить скалярам массивов внешний вид вычислений,основанных на ufunc,со значительно меньшими накладными расходами).</target>
        </trans-unit>
        <trans-unit id="0f01ed56a1e32a05e5ef96e4d779f34784af9a96" translate="yes" xml:space="preserve">
          <source>Example</source>
          <target state="translated">Example</target>
        </trans-unit>
        <trans-unit id="6dcd3f46d09547b62bf07ba9b2943c95d53ddae3" translate="yes" xml:space="preserve">
          <source>Example 1</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="30643b2e1a03cdc521bd995bce3101935a638007" translate="yes" xml:space="preserve">
          <source>Example 1: Matrix creation from a string</source>
          <target state="translated">Пример 1:Создание матрицы из строки</target>
        </trans-unit>
        <trans-unit id="1c56ea49918b9baed94cf4bc0ee9f324efc8841a" translate="yes" xml:space="preserve">
          <source>Example 2</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce3d11c2b2ea882cbd46aab60dee035848945f1a" translate="yes" xml:space="preserve">
          <source>Example 2: Matrix creation from nested sequence</source>
          <target state="translated">Пример 2:Создание матрицы из вложенной последовательности</target>
        </trans-unit>
        <trans-unit id="fbf4dab701189a344fa5ab06d7b87c11a74e3da0" translate="yes" xml:space="preserve">
          <source>Example 3</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a618a4143ae0244c26c66d93ae5ab076865eca3" translate="yes" xml:space="preserve">
          <source>Example 3: Matrix creation from an array</source>
          <target state="translated">Пример 3:Создание матрицы из массива</target>
        </trans-unit>
        <trans-unit id="f4cd3ef194759e6a1bf205a2958b720d8edb10da" translate="yes" xml:space="preserve">
          <source>Example 4</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cbc410822099cff77c866f8b10c2e48ca12a1afc" translate="yes" xml:space="preserve">
          <source>Example Non-ufunc extension</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="97f8c7c900cba2f392e5e38662fe498a8f56646a" translate="yes" xml:space="preserve">
          <source>Example NumPy ufunc for one dtype</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b8809483f5fc6a5c010269d8adf002c5725f0e9b" translate="yes" xml:space="preserve">
          <source>Example NumPy ufunc with multiple arguments/return values</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="66ef9bf28d21feb518a571e273d9e8fce03143d5" translate="yes" xml:space="preserve">
          <source>Example NumPy ufunc with multiple dtypes</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="14395f9293b35a0e404c1a51a85116a67b48bdc5" translate="yes" xml:space="preserve">
          <source>Example NumPy ufunc with structured array dtype arguments</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f8172515c31d6aac1029b5cb8f7b23a7b399484c" translate="yes" xml:space="preserve">
          <source>Example Rendered</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b501c037bbc988735c2c33076d9ac8bcdd035dcd" translate="yes" xml:space="preserve">
          <source>Example Source</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a0d4f43d7d9bdb2a4af703ab58a4be1e4d7fae7" translate="yes" xml:space="preserve">
          <source>Example illustrating a common use of &lt;a href=&quot;#numpy.linalg.qr&quot;&gt;&lt;code&gt;qr&lt;/code&gt;&lt;/a&gt;: solving of least squares problems</source>
          <target state="translated">Пример, иллюстрирующий общее использование &lt;a href=&quot;#numpy.linalg.qr&quot;&gt; &lt;code&gt;qr&lt;/code&gt; &lt;/a&gt; : решение задач наименьших квадратов</target>
        </trans-unit>
        <trans-unit id="63135172667b6a87b3380fb1464ecfa4e93bae96" translate="yes" xml:space="preserve">
          <source>Example npymath.ini modified for cross-compilation:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b9b4c475cb57be9cefc272ad9e58398f1d4a72d" translate="yes" xml:space="preserve">
          <source>Example of ellipsis use:</source>
          <target state="translated">Пример использования эллипсиса:</target>
        </trans-unit>
        <trans-unit id="663d5de84d17f73904544fdaa7818c43c339aab6" translate="yes" xml:space="preserve">
          <source>Example of the &lt;em&gt;axis&lt;/em&gt; argument</source>
          <target state="translated">Пример аргумента &lt;em&gt;оси&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="441193d28defb7b45677223f2e8385cc1771ef57" translate="yes" xml:space="preserve">
          <source>Example showing broadcast of scalar_like argument:</source>
          <target state="translated">Пример,показывающий трансляцию скалярного_подобного аргумента:</target>
        </trans-unit>
        <trans-unit id="c63737abd7347a7ae582cb9fbdf37d6c0e5b251e" translate="yes" xml:space="preserve">
          <source>Example:</source>
          <target state="translated">Example:</target>
        </trans-unit>
        <trans-unit id="eb01bf04c9a0e8a71c45816513df424f1c7ffedb" translate="yes" xml:space="preserve">
          <source>Examples</source>
          <target state="translated">Examples</target>
        </trans-unit>
        <trans-unit id="5ac5a296d96aa3e1af1d332eed81649776f6a783" translate="yes" xml:space="preserve">
          <source>Examples include ctypes, SWIG and Cython (which wraps C and C++) and f2py (which wraps Fortran).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4fdbf34a4034d36b34a713099fb629e7144865e3" translate="yes" xml:space="preserve">
          <source>Examples of formats that cannot be read directly but for which it is not hard to convert are those formats supported by libraries like PIL (able to read and write many image formats such as jpg, png, etc).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f4f2c02f27681846f10b4ebe60fe1c291af3908e" translate="yes" xml:space="preserve">
          <source>Examples of using Numba, Cython, CFFI</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb3447b632f6a431215776dcf254a01001a40c4f" translate="yes" xml:space="preserve">
          <source>Examples:</source>
          <target state="translated">Examples:</target>
        </trans-unit>
        <trans-unit id="f7651c4bad19b71b6cb07d324b05afde4b46e15c" translate="yes" xml:space="preserve">
          <source>Exceeded max_work.</source>
          <target state="translated">Превышенное значение max_work.</target>
        </trans-unit>
        <trans-unit id="b4a918f3b3ebec530b94769e489c47c784e700d0" translate="yes" xml:space="preserve">
          <source>Except for splitting from the right, &lt;a href=&quot;#numpy.char.rsplit&quot;&gt;&lt;code&gt;rsplit&lt;/code&gt;&lt;/a&gt; behaves like &lt;a href=&quot;numpy.char.split#numpy.char.split&quot;&gt;&lt;code&gt;split&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">За исключением разделения справа, &lt;a href=&quot;#numpy.char.rsplit&quot;&gt; &lt;code&gt;rsplit&lt;/code&gt; &lt;/a&gt; ведет себя как &lt;a href=&quot;numpy.char.split#numpy.char.split&quot;&gt; &lt;code&gt;split&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="50cf8f9b1990e86989de06e0c8538067135c84c5" translate="yes" xml:space="preserve">
          <source>Except for the handling of missing data this function does the same as &lt;a href=&quot;numpy.corrcoef#numpy.corrcoef&quot;&gt;&lt;code&gt;numpy.corrcoef&lt;/code&gt;&lt;/a&gt;. For more details and examples, see &lt;a href=&quot;numpy.corrcoef#numpy.corrcoef&quot;&gt;&lt;code&gt;numpy.corrcoef&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">За исключением обработки отсутствующих данных, эта функция делает то же, что и &lt;a href=&quot;numpy.corrcoef#numpy.corrcoef&quot;&gt; &lt;code&gt;numpy.corrcoef&lt;/code&gt; &lt;/a&gt; . Для получения дополнительных сведений и примеров см. &lt;a href=&quot;numpy.corrcoef#numpy.corrcoef&quot;&gt; &lt;code&gt;numpy.corrcoef&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="fcfc562b386cd345086d419126e4274f3e7274f0" translate="yes" xml:space="preserve">
          <source>Except for the handling of missing data this function does the same as &lt;a href=&quot;numpy.cov#numpy.cov&quot;&gt;&lt;code&gt;numpy.cov&lt;/code&gt;&lt;/a&gt;. For more details and examples, see &lt;a href=&quot;numpy.cov#numpy.cov&quot;&gt;&lt;code&gt;numpy.cov&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">За исключением обработки недостающих данных, эта функция работает так же, как &lt;a href=&quot;numpy.cov#numpy.cov&quot;&gt; &lt;code&gt;numpy.cov&lt;/code&gt; &lt;/a&gt; . Для получения дополнительных сведений и примеров см. &lt;a href=&quot;numpy.cov#numpy.cov&quot;&gt; &lt;code&gt;numpy.cov&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="596913a65e41737843ee5c2dbdb338f87062d44f" translate="yes" xml:space="preserve">
          <source>Exception: if &lt;code&gt;&amp;lt;modulename&amp;gt;&lt;/code&gt; contains a substring &lt;code&gt;__user__&lt;/code&gt;, then the corresponding &lt;code&gt;python module&lt;/code&gt; block describes the signatures of so-called call-back functions (see &lt;a href=&quot;python-usage#call-back-arguments&quot;&gt;Call-back arguments&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd3dfbe79fda3a9d92de67b1bd4f1dc9f60ab723" translate="yes" xml:space="preserve">
          <source>Exceptions</source>
          <target state="translated">Exceptions</target>
        </trans-unit>
        <trans-unit id="356b80b4376a84cb81f1eaec6f12177c31c9684b" translate="yes" xml:space="preserve">
          <source>Excessive profanity. Please avoid swearwords; people differ greatly in their sensitivity to swearing.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d9b4ae599e40c23f9e1e3a0e96ba44f45767d0e8" translate="yes" xml:space="preserve">
          <source>Execute &lt;code&gt;f2py&lt;/code&gt; without any options to get an up-to-date list of available options.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="26e6ce501ea40e3a3a4030f941745cb2ec376d8c" translate="yes" xml:space="preserve">
          <source>Execute &lt;code&gt;func1d(a, *args)&lt;/code&gt; where &lt;code&gt;func1d&lt;/code&gt; operates on 1-D arrays and &lt;code&gt;a&lt;/code&gt; is a 1-D slice of &lt;code&gt;arr&lt;/code&gt; along &lt;code&gt;axis&lt;/code&gt;.</source>
          <target state="translated">Выполните &lt;code&gt;func1d(a, *args)&lt;/code&gt; где &lt;code&gt;func1d&lt;/code&gt; работает с одномерными массивами, а &lt;code&gt;a&lt;/code&gt; - одномерный срез &lt;code&gt;arr&lt;/code&gt; вдоль &lt;code&gt;axis&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cf7ed2655aaf6ca10ebe34c9fc51e6d32e46bc68" translate="yes" xml:space="preserve">
          <source>Execute &lt;code&gt;func1d(a, *args, **kwargs)&lt;/code&gt; where &lt;code&gt;func1d&lt;/code&gt; operates on 1-D arrays and &lt;code&gt;a&lt;/code&gt; is a 1-D slice of &lt;code&gt;arr&lt;/code&gt; along &lt;code&gt;axis&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a2cece8ace64c3475d26ff85f2c7434847f99f4d" translate="yes" xml:space="preserve">
          <source>Execute a command in a sub-process.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cbd62d234a86ea4d63bc3019c94a352e75700653" translate="yes" xml:space="preserve">
          <source>Existing array to use for output. If not given, returns a default copy of a.</source>
          <target state="translated">Существующий массив для вывода.Если не задано,возвращает копию по умолчанию.</target>
        </trans-unit>
        <trans-unit id="49efde5e22ecb6838665120a39ab53a2bd9e68ce" translate="yes" xml:space="preserve">
          <source>Existing arrays are not copied:</source>
          <target state="translated">Существующие массивы не копируются:</target>
        </trans-unit>
        <trans-unit id="49afcf31d80f21e8d0b1602a5dec36d208fe71f8" translate="yes" xml:space="preserve">
          <source>Expand the shape of an array.</source>
          <target state="translated">Расширьте форму массива.</target>
        </trans-unit>
        <trans-unit id="ffcf950230f953a0aa6e82e09f28f2ca5a3b9124" translate="yes" xml:space="preserve">
          <source>Expectation of interval, must be &amp;gt;= 0. A sequence of expectation intervals must be broadcastable over the requested size.</source>
          <target state="translated">Ожидание интервала должно быть&amp;gt; = 0. Последовательность ожидаемых интервалов должна транслироваться в пределах запрошенного размера.</target>
        </trans-unit>
        <trans-unit id="b78dbac20462df52109f148c03ffe8d871381643" translate="yes" xml:space="preserve">
          <source>Expected type</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf1e24ddaed54869cdb52d8afc4913163a237789" translate="yes" xml:space="preserve">
          <source>Expects a 1-D &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray&quot;&gt;&lt;code&gt;MaskedArray&lt;/code&gt;&lt;/a&gt;, returns None if all values are masked.</source>
          <target state="translated">Ожидает 1-D &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray&quot;&gt; &lt;code&gt;MaskedArray&lt;/code&gt; &lt;/a&gt; , возвращает None, если все значения замаскированы.</target>
        </trans-unit>
        <trans-unit id="436d6ba04e28ca54111c317cd8c5730750821416" translate="yes" xml:space="preserve">
          <source>Experimental Windows 64 bits support</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1bb6e6265dd9bdb6a18fab53ed1eab48ecc15430" translate="yes" xml:space="preserve">
          <source>Expired deprecations</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="308f613122797fe7bbf7289f6c7ded6a9a215476" translate="yes" xml:space="preserve">
          <source>Explained without fancy indexing, this is equivalent to the following use of &lt;a href=&quot;numpy.ndindex#numpy.ndindex&quot;&gt;&lt;code&gt;ndindex&lt;/code&gt;&lt;/a&gt;, which sets each of &lt;code&gt;ii&lt;/code&gt;, &lt;code&gt;jj&lt;/code&gt;, and &lt;code&gt;kk&lt;/code&gt; to a tuple of indices:</source>
          <target state="translated">Объясняя это без причудливой индексации, это эквивалентно следующему использованию &lt;a href=&quot;numpy.ndindex#numpy.ndindex&quot;&gt; &lt;code&gt;ndindex&lt;/code&gt; &lt;/a&gt; , который устанавливает для каждого из &lt;code&gt;ii&lt;/code&gt; , &lt;code&gt;jj&lt;/code&gt; и &lt;code&gt;kk&lt;/code&gt; набор индексов:</target>
        </trans-unit>
        <trans-unit id="b32ef340ea4702fd5f41dbe4001671d76174ef71" translate="yes" xml:space="preserve">
          <source>Explanation</source>
          <target state="translated">Explanation</target>
        </trans-unit>
        <trans-unit id="70888d5de72e21e66f15d3b4da0b71ef035227ca" translate="yes" xml:space="preserve">
          <source>Explanation of &lt;code&gt;out&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c1cbb49be518437de30818cb1c73f87724317b3" translate="yes" xml:space="preserve">
          <source>Explanation of anonymous return value of type &lt;code&gt;type&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="21e720a46ab84c7db649aa1af73527c035249fc0" translate="yes" xml:space="preserve">
          <source>Explanation of parameters passed to a generator&amp;rsquo;s &lt;code&gt;.send()&lt;/code&gt; method, formatted as for Parameters, above. Since, like for Yields and Returns, a single object is always passed to the method, this may describe either the single parameter, or positional arguments passed as a tuple. If a docstring includes Receives it must also include Yields.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed24536543d63881e8b2573801bfcc470ea854c5" translate="yes" xml:space="preserve">
          <source>Explanation of return value named &lt;code&gt;describe&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="084a31a8f3e785c2c2a6e821453dbd829b121e68" translate="yes" xml:space="preserve">
          <source>Explanation of the returned values and their types. Similar to the &lt;strong&gt;Parameters&lt;/strong&gt; section, except the name of each return value is optional. The type of each return value is always required:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d6a974dcdac50109739458b5d455115ab1bc92d" translate="yes" xml:space="preserve">
          <source>Explanation of the yielded values and their types. This is relevant to generators only. Similar to the &lt;strong&gt;Returns&lt;/strong&gt; section in that the name of each value is optional, but the type of each value is always required:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a9375f321c90af9af48e6e3fb9835073a5901dfe" translate="yes" xml:space="preserve">
          <source>Explanations</source>
          <target state="translated">Explanations</target>
        </trans-unit>
        <trans-unit id="83ab7f45afecc2791323d368cde7b157fa580ff5" translate="yes" xml:space="preserve">
          <source>Explicit constructor call - as in &lt;code&gt;MySubClass(params)&lt;/code&gt;. This is the usual route to Python instance creation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7239478231860a1fad923ee0b23fbd1cf944cc01" translate="yes" xml:space="preserve">
          <source>Exploring your repository</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f2a8ab3710ac4db36fc8b2f6b13aa845d130b020" translate="yes" xml:space="preserve">
          <source>Exponent of the smallest (most negative) power of &lt;code&gt;ibeta&lt;/code&gt; that, added to 1.0, gives something different from 1.0</source>
          <target state="translated">Показатель наименьшей (самой отрицательной) степени &lt;code&gt;ibeta&lt;/code&gt; который, добавленный к 1.0, дает нечто отличное от 1.0</target>
        </trans-unit>
        <trans-unit id="b6c379526da851c2c188007fc0f60f969489df7a" translate="yes" xml:space="preserve">
          <source>Exponent of the smallest power of &lt;code&gt;ibeta&lt;/code&gt; that, subtracted from 1.0, gives something different from 1.0.</source>
          <target state="translated">Показатель наименьшей степени &lt;code&gt;ibeta&lt;/code&gt; , вычитаемый из 1,0, дает нечто отличное от 1,0.</target>
        </trans-unit>
        <trans-unit id="4b6764a081f01f39974a118ba6996f7bb9dae570" translate="yes" xml:space="preserve">
          <source>Exponentials</source>
          <target state="translated">Exponentials</target>
        </trans-unit>
        <trans-unit id="3ce964226c06687afb0e1cd2608b915c6e2ae80f" translate="yes" xml:space="preserve">
          <source>Exponents and logarithms</source>
          <target state="translated">Экспонаты и логарифмы</target>
        </trans-unit>
        <trans-unit id="6816711cea53eaf2821d868455dd2b74af82fbfc" translate="yes" xml:space="preserve">
          <source>Extended Precision</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c0c674d20d95b51b6a4e4dd52d4e269a50723636" translate="yes" xml:space="preserve">
          <source>Extended array wrapping mechanism for ufuncs</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4be9a4abd6d7c8083fc1a7bf9004e653250a9ba5" translate="yes" xml:space="preserve">
          <source>Extending</source>
          <target state="translated">Extending</target>
        </trans-unit>
        <trans-unit id="11f9e57877f87be0cc6660ad6431454b1ce0dd15" translate="yes" xml:space="preserve">
          <source>Extending numpy.random via Cython</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="853464b537e82bc933ba7340602eb65117de87c5" translate="yes" xml:space="preserve">
          <source>Extending via CFFI</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d370bc918c56f5c33646a1857c72f909913490c1" translate="yes" xml:space="preserve">
          <source>Extending via Numba</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="800827a3cd2ee901ad8ec499c46ac0ff69445548" translate="yes" xml:space="preserve">
          <source>Extending via Numba and CFFI</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b8df212e6d243492be0344c26fa93a5ac0e105d8" translate="yes" xml:space="preserve">
          <source>Extends &lt;a href=&quot;#c.NpyIter_MultiNew&quot;&gt;&lt;code&gt;NpyIter_MultiNew&lt;/code&gt;&lt;/a&gt; with several advanced options providing more control over broadcasting and buffering.</source>
          <target state="translated">Расширяет &lt;a href=&quot;#c.NpyIter_MultiNew&quot;&gt; &lt;code&gt;NpyIter_MultiNew&lt;/code&gt; &lt;/a&gt; несколькими расширенными параметрами, обеспечивающими больший контроль над широковещательной передачей и буферизацией.</target>
        </trans-unit>
        <trans-unit id="1071c16401775941686162869b5dcd9b3809f3d7" translate="yes" xml:space="preserve">
          <source>Extension (class in numpy.distutils.core)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="85e3302475f159bce563240760503f1c4aa91903" translate="yes" xml:space="preserve">
          <source>Extension modules that need to compile against NumPy should use this function to locate the appropriate include directory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f48f1027b2aaccf449a26fbdeefabcf146890c52" translate="yes" xml:space="preserve">
          <source>Extension modules were discussed in &lt;a href=&quot;c-info.how-to-extend#writing-an-extension&quot;&gt;Writing an extension module&lt;/a&gt;. The most basic way to interface with compiled code is to write an extension module and construct a module method that calls the compiled code. For improved readability, your method should take advantage of the &lt;code&gt;PyArg_ParseTuple&lt;/code&gt; call to convert between Python objects and C data-types. For standard C data-types there is probably already a built-in converter. For others you may need to write your own converter and use the &lt;code&gt;&quot;O&amp;amp;&quot;&lt;/code&gt; format string which allows you to specify a function that will be used to perform the conversion from the Python object to whatever C-structures are needed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c018e97c181cd9c183fd3a91a81ef0772a1542dd" translate="yes" xml:space="preserve">
          <source>Extension name.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="656bcfe284e2da39c77d4fdab55b16ad3c654719" translate="yes" xml:space="preserve">
          <source>Extensions</source>
          <target state="translated">Extensions</target>
        </trans-unit>
        <trans-unit id="27a37d04136a1c128f059ba2a96a979d4da85562" translate="yes" xml:space="preserve">
          <source>External &lt;code&gt;nose&lt;/code&gt; plugins are usable by &lt;code&gt;numpy.testing.Tester&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="730550afb5b9c93a998c435ea0c0d79790c3f92e" translate="yes" xml:space="preserve">
          <source>External Links:</source>
          <target state="translated">Внешние ссылки:</target>
        </trans-unit>
        <trans-unit id="ae23cb438f3e53ca3afef0a03ebcc1785000e0ee" translate="yes" xml:space="preserve">
          <source>External member: Thomas Caswell</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f5695baec527125ed849fab25176346709bcdc26" translate="yes" xml:space="preserve">
          <source>Extra arguments to be used in the function call. Default is no extra arguments.</source>
          <target state="translated">Дополнительные аргументы для использования при вызове функции.По умолчанию дополнительные аргументы не используются.</target>
        </trans-unit>
        <trans-unit id="7f681966048a97639927ca7899e8b79125b2db1c" translate="yes" xml:space="preserve">
          <source>Extra command line arguments to pass to the compiler.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca14953b246ceea670453a567006ae580503bb4e" translate="yes" xml:space="preserve">
          <source>Extra command line arguments to pass to the fortran77 compiler.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6295d4fda810b14243403cdc434ad1cb27dc0759" translate="yes" xml:space="preserve">
          <source>Extra command line arguments to pass to the fortran90 compiler.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7475cdd2c7bf2da401a59201928f6e438e74c2c4" translate="yes" xml:space="preserve">
          <source>Extra data to be passed to the 1-d vector loops or &lt;code&gt;NULL&lt;/code&gt; if no extra-data is needed. This C-array must be the same size ( &lt;em&gt;i.e.&lt;/em&gt; ntypes) as the functions array. &lt;code&gt;NULL&lt;/code&gt; is used if extra_data is not needed. Several C-API calls for UFuncs are just 1-d vector loops that make use of this extra data to receive a pointer to the actual function to call.</source>
          <target state="translated">Дополнительные данные для передачи в 1-мерные векторные циклы или &lt;code&gt;NULL&lt;/code&gt; , если дополнительные данные не требуются. Этот C-массив должен иметь тот же размер ( &lt;em&gt;т.е.&lt;/em&gt; ntypes), что и массив функций. &lt;code&gt;NULL&lt;/code&gt; используется, если extra_data не требуется. Несколько вызовов C-API для UFuncs представляют собой просто одномерные векторные циклы, которые используют эти дополнительные данные для получения указателя на фактическую функцию для вызова.</target>
        </trans-unit>
        <trans-unit id="76b524fa169ed9d7419720ac2e63f1800fb02fd6" translate="yes" xml:space="preserve">
          <source>Extra features in NumPy Distutils</source>
          <target state="translated">Дополнительные функции в дистилляторах NumPy</target>
        </trans-unit>
        <trans-unit id="0ba9e867255fe2b4e1a52a57cb3c07e37658da6a" translate="yes" xml:space="preserve">
          <source>Extra gotchas - custom &lt;code&gt;__del__&lt;/code&gt; methods and ndarray.base</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e4b908b04be2629c5ae91c968b91dbf4fa38bfee" translate="yes" xml:space="preserve">
          <source>Extract a diagonal or construct a diagonal array.</source>
          <target state="translated">Извлечь диагональ или построить диагональный массив.</target>
        </trans-unit>
        <trans-unit id="8f2f355e8dba1681289d909a9095fc402d801e4a" translate="yes" xml:space="preserve">
          <source>Extract the diagonal (requires explicit form):</source>
          <target state="translated">Извлеките диагональ (требуется явная форма):</target>
        </trans-unit>
        <trans-unit id="e69f20e9f683920d3fb4329abd951e878b1f9372" translate="yes" xml:space="preserve">
          <source>F</source>
          <target state="translated">F</target>
        </trans-unit>
        <trans-unit id="00b194f535090973445600575106dc4bd4b91c15" translate="yes" xml:space="preserve">
          <source>F &amp;amp; C order preserved, otherwise most similar order</source>
          <target state="translated">Сохранен порядок F&amp;amp;C, в остальном наиболее похожий порядок</target>
        </trans-unit>
        <trans-unit id="3a82a1967b0685fff927bd0da5e7638582e5ea69" translate="yes" xml:space="preserve">
          <source>F order</source>
          <target state="translated">порядок F</target>
        </trans-unit>
        <trans-unit id="c79b9dbc4a93112f31ab2f13620d941f25753284" translate="yes" xml:space="preserve">
          <source>F order if input is F and not C, otherwise C order</source>
          <target state="translated">F порядок,если вводится F,а не C,в противном случае C порядок</target>
        </trans-unit>
        <trans-unit id="f2a180292b361263e635ced3b9691c0e12c80c50" translate="yes" xml:space="preserve">
          <source>F2PY Users Guide and Reference Manual</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b399d8776a2242967c58643767ca90dfddcac38" translate="yes" xml:space="preserve">
          <source>F2PY can be used either as a command line tool &lt;code&gt;f2py&lt;/code&gt; or as a Python module &lt;code&gt;numpy.f2py&lt;/code&gt;. While we try to install the command line tool as part of the numpy setup, some platforms like Windows make it difficult to reliably put the executable on the &lt;code&gt;PATH&lt;/code&gt;. We will refer to &lt;code&gt;f2py&lt;/code&gt; in this document but you may have to run it as a module:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="792c6defec01dbafd2bb97ac5636c97cd76fd00b" translate="yes" xml:space="preserve">
          <source>F2PY compiles all sources and builds an extension module containing the wrappers. In building extension modules, F2PY uses &lt;code&gt;numpy_distutils&lt;/code&gt; that supports a number of Fortran 77/90/95 compilers, including Gnu, Intel, Sun Fortre, SGI MIPSpro, Absoft, NAG, Compaq etc. compilers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="92e93ef7e35d0de4b606056f7c05a7e7f8e0fa7b" translate="yes" xml:space="preserve">
          <source>F2PY directive has the following form:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c802734ec43042e46fc429c3bbb7f9b7a790ab48" translate="yes" xml:space="preserve">
          <source>F2PY directives</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b9c3fd91761103aa57848e2e22375fdb641f2ae9" translate="yes" xml:space="preserve">
          <source>F2PY generated interface is very flexible with respect to call-back arguments. For each call-back argument an additional optional argument &lt;code&gt;&amp;lt;name&amp;gt;_extra_args&lt;/code&gt; is introduced by F2PY. This argument can be used to pass extra arguments to user provided call-back arguments.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99f6bbe236422250760ea03e1afee2f05419e0cf" translate="yes" xml:space="preserve">
          <source>F2PY generated wrapper functions accept (almost) any Python object as a string argument, &lt;code&gt;str&lt;/code&gt; is applied for non-string objects. Exceptions are NumPy arrays that must have type code &lt;code&gt;'c'&lt;/code&gt; or &lt;code&gt;'1'&lt;/code&gt; when used as string arguments.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f8ac895bc25eb576f465fead8da56c16856e681e" translate="yes" xml:space="preserve">
          <source>F2PY generates wrappers to &lt;code&gt;common&lt;/code&gt; blocks defined in a routine signature block. Common blocks are visible by all Fortran codes linked with the current extension module, but not to other extension modules (this restriction is due to how Python imports shared libraries). In Python, the F2PY wrappers to &lt;code&gt;common&lt;/code&gt; blocks are &lt;code&gt;fortran&lt;/code&gt; type objects that have (dynamic) attributes related to data members of common blocks. When accessed, these attributes return as NumPy array objects (multidimensional arrays are Fortran-contiguous) that directly link to data members in common blocks. Data members can be changed by direct assignment or by in-place changes to the corresponding array objects.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="818e71d7199268e4ad0bb28a90c9ec7b67e6a73f" translate="yes" xml:space="preserve">
          <source>F2PY generates wrappers to all entry names using the signature of the routine block.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="86d8d5f0414d9a23442dad9a8767153d6dc63973" translate="yes" xml:space="preserve">
          <source>F2PY has basic support for Fortran 90 module allocatable arrays.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="70ca3b53756dbec8defd4dadba9010e32a75e058" translate="yes" xml:space="preserve">
          <source>F2PY implements basic compatibility checks between related arguments in order to avoid any unexpected crashes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d254f0a276a232e34acfb47e3326523f334f058d" translate="yes" xml:space="preserve">
          <source>F2PY may lower cases also in C expressions when scanning Fortran codes (see &lt;code&gt;--[no]-lower&lt;/code&gt; option).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec756cae82276f06410c3a4d2b35a06f369bcafa" translate="yes" xml:space="preserve">
          <source>F2PY provides &lt;code&gt;intent(inplace)&lt;/code&gt; attribute that would modify the attributes of an input array so that any changes made by Fortran routine will be effective also in input argument. For example, if one specifies &lt;code&gt;intent(inplace) a&lt;/code&gt; (see below, how), then the example above would read:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fca2006682a608b9e1b2b53bb3bb49e7143a70f2" translate="yes" xml:space="preserve">
          <source>F2PY reads a signature file and writes a Python C/API module containing Fortran/C/Python bindings.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="33d34cb52e571436cd929620cb006187918c3090" translate="yes" xml:space="preserve">
          <source>F2PY supports calling Python functions from Fortran or C codes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a50f97135d3a00f9c97ae354c1ab19960a6943cf" translate="yes" xml:space="preserve">
          <source>F2Py Guide</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="db0e0f2556443edbd8b7072d8289833837b00763" translate="yes" xml:space="preserve">
          <source>F2py allows you to automatically construct an extension module that interfaces to routines in Fortran 77/90/95 code. It has the ability to parse Fortran 77/90/95 code and automatically generate Python signatures for the subroutines it encounters, or you can guide how the subroutine interfaces with Python by constructing an interface-definition-file (or modifying the f2py-produced one).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf8300dc1be4d8761c3816eeb71051b6b621dd6e" translate="yes" xml:space="preserve">
          <source>FFT</source>
          <target state="translated">FFT</target>
        </trans-unit>
        <trans-unit id="ca600c25350318c92a93eef893cdd109ac18c10d" translate="yes" xml:space="preserve">
          <source>FFT (Fast Fourier Transform) refers to a way the discrete Fourier Transform (DFT) can be calculated efficiently, by using symmetries in the calculated terms. The symmetry is highest when &lt;code&gt;n&lt;/code&gt; is a power of 2, and the transform is therefore most efficient for these sizes.</source>
          <target state="translated">БПФ (быстрое преобразование Фурье) относится к способу эффективного вычисления дискретного преобразования Фурье (ДПФ) с использованием симметрии в вычисляемых условиях. Симметрия наивысшая, когда &lt;code&gt;n&lt;/code&gt; является степенью 2, и поэтому преобразование наиболее эффективно для этих размеров.</target>
        </trans-unit>
        <trans-unit id="1e904f6af52956913c4ff703c15d71d4683c8dd0" translate="yes" xml:space="preserve">
          <source>F_CONTIGUOUS / F / FORTRAN</source>
          <target state="translated">F_CONTIGUOUS/F/FORTRAN</target>
        </trans-unit>
        <trans-unit id="10ba031202732234b30a39bc920cbaa6d821ef6b" translate="yes" xml:space="preserve">
          <source>F_CONTIGUOUS and not C_CONTIGUOUS.</source>
          <target state="translated">F_CONTIGUOUS,а не C_CONTIGUOUS.</target>
        </trans-unit>
        <trans-unit id="542219cc1d690d05adfbb2e51a8b3ccb1985fddc" translate="yes" xml:space="preserve">
          <source>F_CONTIGUOUS or C_CONTIGUOUS (one-segment test).</source>
          <target state="translated">F_CONTIGUOUS или C_CONTIGUOUS (односегментный тест).</target>
        </trans-unit>
        <trans-unit id="85c6c271be69ba94867c22f54f57654f454c41b4" translate="yes" xml:space="preserve">
          <source>Factor the matrix &lt;code&gt;a&lt;/code&gt; as &lt;em&gt;qr&lt;/em&gt;, where &lt;code&gt;q&lt;/code&gt; is orthonormal and &lt;code&gt;r&lt;/code&gt; is upper-triangular.</source>
          <target state="translated">Разложите матрицу &lt;code&gt;a&lt;/code&gt; на &lt;em&gt;множители&lt;/em&gt; как &lt;em&gt;qr&lt;/em&gt; , где &lt;code&gt;q&lt;/code&gt; ортонормировано, а &lt;code&gt;r&lt;/code&gt; верхнетреугольное.</target>
        </trans-unit>
        <trans-unit id="fb318cde14ee94b6e5d32ac7d527c0788644b0e1" translate="yes" xml:space="preserve">
          <source>Fail unless an exception of class exception_class and with message that matches expected_regexp is thrown by callable when invoked with arguments args and keyword arguments kwargs.</source>
          <target state="translated">Fail,если только при вызове с аргументами arguments args и keyword аргументами kwargs не будет брошено вызываемое исключение класса exception_class с сообщением,совпадающим с ожидаемым_regexp.</target>
        </trans-unit>
        <trans-unit id="021d84299e2248496708e7d1e546ad6c2c18b0ba" translate="yes" xml:space="preserve">
          <source>Fail unless an exception of class exception_class is thrown by callable when invoked with arguments args and keyword arguments kwargs.</source>
          <target state="translated">Отказ,если только при вызове с аргументами аргументов аргументов аргументов и ключевых слов kwargs не брошено исключение класса exception_class с помощью вызываемого параметра.</target>
        </trans-unit>
        <trans-unit id="88591071684d50acd16039be01f0c08d81ea457a" translate="yes" xml:space="preserve">
          <source>Fail unless an exception of class exception_class is thrown by callable when invoked with arguments args and keyword arguments kwargs. If a different type of exception is thrown, it will not be caught, and the test case will be deemed to have suffered an error, exactly as for an unexpected exception.</source>
          <target state="translated">Отказ,если только при вызове с аргументами аргументов аргументов аргументов и ключевых слов kwargs не брошено исключение класса exception_class с помощью вызываемого параметра.Если брошено исключение другого типа,то оно не будет перехвачено,а тестовый случай будет считаться ошибочным,точно так же,как и для неожиданного исключения.</target>
        </trans-unit>
        <trans-unit id="719788786f4bf9fa2ee26b39d5371d0a438935c3" translate="yes" xml:space="preserve">
          <source>Fail unless the given callable throws the specified warning.</source>
          <target state="translated">Невозможно,если только данный вызываемый абонент не бросит указанное предупреждение.</target>
        </trans-unit>
        <trans-unit id="552c13b4b3257ae89f519cb962e935c59da9aa88" translate="yes" xml:space="preserve">
          <source>Fanaticism consists of redoubling your efforts when you have forgotten your aim. &amp;mdash; &lt;em&gt;George Santayana&lt;/em&gt;</source>
          <target state="translated">Фанатизм состоит в удвоении ваших усилий, когда вы забыли свою цель. - &lt;em&gt;Джордж Сантаяна&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="c67baf5f0ace8714e24d83b916518b08cd541740" translate="yes" xml:space="preserve">
          <source>Fast element-wise operations, called a &lt;a href=&quot;#term-ufunc&quot;&gt;ufunc&lt;/a&gt;, operate on arrays.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a35d6e8cdee3fab38ad9c3056a80a39fdb1d90ea" translate="yes" xml:space="preserve">
          <source>Faster version of &lt;a href=&quot;#numpy.base_repr&quot;&gt;&lt;code&gt;base_repr&lt;/code&gt;&lt;/a&gt; for base 2.</source>
          <target state="translated">Более быстрая версия &lt;a href=&quot;#numpy.base_repr&quot;&gt; &lt;code&gt;base_repr&lt;/code&gt; &lt;/a&gt; для базы 2.</target>
        </trans-unit>
        <trans-unit id="450b0ab74bf6b08b6fed235cfac5fd255dd761eb" translate="yes" xml:space="preserve">
          <source>Fasttake and fastputmask slots are deprecated and NULL&amp;rsquo;ed</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad565d9d01d0e0bf91fd6a8532f6d81613338901" translate="yes" xml:space="preserve">
          <source>Feature</source>
          <target state="translated">Feature</target>
        </trans-unit>
        <trans-unit id="fc338f87a058158eb824b53705961801516a9460" translate="yes" xml:space="preserve">
          <source>Features</source>
          <target state="translated">Features</target>
        </trans-unit>
        <trans-unit id="cba8e75130f021ad02ee54a4acd20b3b023d217d" translate="yes" xml:space="preserve">
          <source>Fernando Perez&amp;rsquo; git page - &lt;a href=&quot;http://www.fperez.org/py4science/git.html&quot;&gt;Fernando&amp;rsquo;s git page&lt;/a&gt; - many links and tips</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c6f34280b7f890c09c370b6ae106bab782a8ea7" translate="yes" xml:space="preserve">
          <source>Field Access</source>
          <target state="translated">Доступ на местах</target>
        </trans-unit>
        <trans-unit id="783edc3ed85699bf943ebb957a288a27bf6fa548" translate="yes" xml:space="preserve">
          <source>Field Titles</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f20e66b17a6eb7c2baf1ab68337d91eaf6f4f80" translate="yes" xml:space="preserve">
          <source>Figure</source>
          <target state="translated">Figure</target>
        </trans-unit>
        <trans-unit id="6810ab68c484c234e459c4fd42ee6ddebf48e9df" translate="yes" xml:space="preserve">
          <source>File bug reports or feature requests, and make contributions (e.g. code patches), by opening a &amp;ldquo;new issue&amp;rdquo; on GitHub:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="373ecfdf236324d2c0d2c0966daa4376bd84ecc7" translate="yes" xml:space="preserve">
          <source>File extensions</source>
          <target state="translated">Расширения файлов</target>
        </trans-unit>
        <trans-unit id="d09479e812c08194a796ba5cf0534018f31d75df" translate="yes" xml:space="preserve">
          <source>File like object that the output is written to, default is &lt;code&gt;stdout&lt;/code&gt;. The object has to be opened in &amp;lsquo;w&amp;rsquo; or &amp;lsquo;a&amp;rsquo; mode.</source>
          <target state="translated">Файловый объект, в который записывается вывод, по умолчанию - &lt;code&gt;stdout&lt;/code&gt; . Объект должен быть открыт в режиме &amp;laquo;w&amp;raquo; или &amp;laquo;a&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="87eae4c8fed58e613f33763392061f9f060bfb3a" translate="yes" xml:space="preserve">
          <source>File mode.</source>
          <target state="translated">Файловый режим.</target>
        </trans-unit>
        <trans-unit id="fd757708817417e6d160c4d854e159b642dde015" translate="yes" xml:space="preserve">
          <source>File name or file object to read.</source>
          <target state="translated">Имя файла или объект файла для чтения.</target>
        </trans-unit>
        <trans-unit id="a9cb7966c21c4ba3f863696ad8ce671f4f627493" translate="yes" xml:space="preserve">
          <source>File object.</source>
          <target state="translated">Файловый объект.</target>
        </trans-unit>
        <trans-unit id="4a94520c92dda87c31025fbdcee94cc740835e3c" translate="yes" xml:space="preserve">
          <source>File on disk is unchanged:</source>
          <target state="translated">Файл на диске не изменяется:</target>
        </trans-unit>
        <trans-unit id="0031f1b0b3ec78263f049edb5bf2d9bd62cb7daa" translate="yes" xml:space="preserve">
          <source>File or filename to which the data is saved. If file is a file-object, then the filename is unchanged. If file is a string or Path, a &lt;code&gt;.npy&lt;/code&gt; extension will be appended to the file name if it does not already have one.</source>
          <target state="translated">Файл или имя файла, в котором сохраняются данные. Если файл является файлом-объектом, то имя файла не изменяется. Если файл представляет собой строку или путь, к имени файла будет добавлено расширение &lt;code&gt;.npy&lt;/code&gt; , если его еще нет.</target>
        </trans-unit>
        <trans-unit id="1eb6e34596962a0a844dec399c9d41368523ad02" translate="yes" xml:space="preserve">
          <source>File or filename to which the data is saved. If file is a file-object, then the filename is unchanged. If file is a string or Path, a &lt;code&gt;.npy&lt;/code&gt; extension will be appended to the filename if it does not already have one.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e820f26629f1b163437a25da45907f2a0bdeef89" translate="yes" xml:space="preserve">
          <source>File, filename, list, or generator to read. If the filename extension is &lt;code&gt;gz&lt;/code&gt; or &lt;a href=&quot;https://docs.python.org/dev/library/bz2.html#module-bz2&quot;&gt;&lt;code&gt;bz2&lt;/code&gt;&lt;/a&gt;, the file is first decompressed. Note that generators must return byte strings in Python 3k. The strings in a list or produced by a generator are treated as lines.</source>
          <target state="translated">Файл, имя файла, список или генератор для чтения. Если расширение имени файла - &lt;code&gt;gz&lt;/code&gt; или &lt;a href=&quot;https://docs.python.org/dev/library/bz2.html#module-bz2&quot;&gt; &lt;code&gt;bz2&lt;/code&gt; &lt;/a&gt; , файл сначала распаковывается. Обратите внимание, что в Python 3k генераторы должны возвращать байтовые строки. Строки в списке или созданные генератором рассматриваются как строки.</target>
        </trans-unit>
        <trans-unit id="fab43e32c1dfae0973539d24c1436cb574228947" translate="yes" xml:space="preserve">
          <source>File, filename, list, or generator to read. If the filename extension is &lt;code&gt;gz&lt;/code&gt; or &lt;a href=&quot;https://docs.python.org/dev/library/bz2.html#module-bz2&quot;&gt;&lt;code&gt;bz2&lt;/code&gt;&lt;/a&gt;, the file is first decompressed. Note that generators must return byte strings. The strings in a list or produced by a generator are treated as lines.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="822b222e1d15e367e3952f91b983db03e9a7813a" translate="yes" xml:space="preserve">
          <source>File, filename, or generator to read. If the filename extension is &lt;code&gt;.gz&lt;/code&gt; or &lt;code&gt;.bz2&lt;/code&gt;, the file is first decompressed. Note that generators should return byte strings for Python 3k.</source>
          <target state="translated">Файл, имя файла или генератор для чтения. Если расширение имени файла - &lt;code&gt;.gz&lt;/code&gt; или &lt;code&gt;.bz2&lt;/code&gt; , файл сначала распаковывается. Обратите внимание, что генераторы должны возвращать байтовые строки для Python 3k.</target>
        </trans-unit>
        <trans-unit id="7c2d62ffff5fbd690a9400522b7a8e17b68bb40c" translate="yes" xml:space="preserve">
          <source>File, filename, or generator to read. If the filename extension is &lt;code&gt;.gz&lt;/code&gt; or &lt;code&gt;.bz2&lt;/code&gt;, the file is first decompressed. Note that generators should return byte strings.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c13aad6dcb77e8786c02dc6c8f0cc3a100a87f10" translate="yes" xml:space="preserve">
          <source>File-like object to write the output to. If omitted, use a pager.</source>
          <target state="translated">Файлоподобный объект для записи вывода.Если он опущен,используйте пейджер.</target>
        </trans-unit>
        <trans-unit id="3b5057522ae1af734e89a0b5dfbff160729789a2" translate="yes" xml:space="preserve">
          <source>Filename extension if &lt;code&gt;source_fn&lt;/code&gt; is not provided. The extension tells which fortran standard is used. The default is &lt;code&gt;f&lt;/code&gt;, which implies F77 standard.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="529e452aa227b660fcf372199a15e8d7d5c2906a" translate="yes" xml:space="preserve">
          <source>Filename or file object to read.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cafc76c090d17de83480422080a28bd0d7fd39f0" translate="yes" xml:space="preserve">
          <source>Fill a newly created array with a single value obj at all locations in the structure with object data-types. No checking is performed but &lt;em&gt;arr&lt;/em&gt; must be of data-type &lt;a href=&quot;c-api.dtype#c.NPY_OBJECT&quot;&gt;&lt;code&gt;NPY_OBJECT&lt;/code&gt;&lt;/a&gt; and be single-segment and uninitialized (no previous objects in position). Use &lt;code&gt;PyArray_DECREF&lt;/code&gt; (&lt;em&gt;arr&lt;/em&gt;) if you need to decrement all the items in the object array prior to calling this function.</source>
          <target state="translated">Заполните вновь созданный массив одним значением obj во всех местах структуры с типами данных объекта. Проверка не выполняется, но &lt;em&gt;arr&lt;/em&gt; должен иметь тип данных &lt;a href=&quot;c-api.dtype#c.NPY_OBJECT&quot;&gt; &lt;code&gt;NPY_OBJECT&lt;/code&gt; ,&lt;/a&gt; быть односегментным и неинициализированным (без предыдущих объектов в позиции). Используйте &lt;code&gt;PyArray_DECREF&lt;/code&gt; ( &lt;em&gt;arr&lt;/em&gt; ), если вам нужно уменьшить все элементы в массиве объектов перед вызовом этой функции.</target>
        </trans-unit>
        <trans-unit id="bb9c4c9e7ee887e06f557b25790d19437a193098" translate="yes" xml:space="preserve">
          <source>Fill a newly created array with a single value obj at all locations in the structure with object data-types. No checking is performed but &lt;em&gt;arr&lt;/em&gt; must be of data-type &lt;a href=&quot;dtype#c.NPY_OBJECT&quot;&gt;&lt;code&gt;NPY_OBJECT&lt;/code&gt;&lt;/a&gt; and be single-segment and uninitialized (no previous objects in position). Use &lt;code&gt;PyArray_DECREF&lt;/code&gt; (&lt;em&gt;arr&lt;/em&gt;) if you need to decrement all the items in the object array prior to calling this function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2dddc689c840b0f704b5fbfeacd8ef3c5403555f" translate="yes" xml:space="preserve">
          <source>Fill in a new Python type-object structure with pointers to new functions that will over-ride the default behavior while leaving any function that should remain the same unfilled (or NULL). The tp_name element should be different.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="522f873213d8106cc0a4bcd37cf77275093b44ed" translate="yes" xml:space="preserve">
          <source>Fill in the tp_base member of the new type-object structure with a pointer to the (main) parent type object. For multiple-inheritance, also fill in the tp_bases member with a tuple containing all of the parent objects in the order they should be used to define inheritance. Remember, all parent-types must have the same C-structure for multiple inheritance to work properly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b5a170286ef4b261aa8d713f55afdd2bfdd31a79" translate="yes" xml:space="preserve">
          <source>Fill out the release note &lt;code&gt;doc/release/1.14.5-notes.rst&lt;/code&gt; calling out significant changes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="260366fdf73d36b977576943b4aedf90420566c3" translate="yes" xml:space="preserve">
          <source>Fill the array pointed to by &lt;em&gt;obj&lt;/em&gt; &amp;mdash;which must be a (subclass of) ndarray&amp;mdash;with the contents of &lt;em&gt;val&lt;/em&gt; (evaluated as a byte). This macro calls memset, so obj must be contiguous.</source>
          <target state="translated">Заполните массив, на который указывает &lt;em&gt;obj,&lt;/em&gt; который должен быть (подклассом) ndarray, содержимым &lt;em&gt;val&lt;/em&gt; (оценивается как байт). Этот макрос вызывает memset, поэтому obj должен быть непрерывным.</target>
        </trans-unit>
        <trans-unit id="1cc72d434ca66ec2855e95222b47cf34ee62d6a9" translate="yes" xml:space="preserve">
          <source>Fill the array with a scalar value.</source>
          <target state="translated">Заполните массив скалярным значением.</target>
        </trans-unit>
        <trans-unit id="a5d5966e608173a9667b1c1fac892e66538c72e9" translate="yes" xml:space="preserve">
          <source>Fill the array, &lt;em&gt;arr&lt;/em&gt;, with the given scalar object, &lt;em&gt;obj&lt;/em&gt;. The object is first converted to the data type of &lt;em&gt;arr&lt;/em&gt;, and then copied into every location. A -1 is returned if an error occurs, otherwise 0 is returned.</source>
          <target state="translated">Заполните массив &lt;em&gt;arr&lt;/em&gt; заданным скалярным объектом &lt;em&gt;obj&lt;/em&gt; . Объект сначала преобразуется в тип данных &lt;em&gt;arr&lt;/em&gt; , а затем копируется во все места. В случае ошибки возвращается -1, в противном случае возвращается 0.</target>
        </trans-unit>
        <trans-unit id="7bee882405d3a5e1e28b315ab4a7baab2498c486" translate="yes" xml:space="preserve">
          <source>Fill the main diagonal of the given array of any dimensionality.</source>
          <target state="translated">Заполните главную диагональ заданного массива любой размерности.</target>
        </trans-unit>
        <trans-unit id="b0054199bd21115b17143e2277b55874769f1942" translate="yes" xml:space="preserve">
          <source>Fill value.</source>
          <target state="translated">Заполните значение.</target>
        </trans-unit>
        <trans-unit id="b3edc087fa7c92433208963d028502658cb11c3c" translate="yes" xml:space="preserve">
          <source>Filling a masked array</source>
          <target state="translated">Заполнение маскированного массива</target>
        </trans-unit>
        <trans-unit id="b16b1c014bc041df050e0baec2b30b9a58147141" translate="yes" xml:space="preserve">
          <source>Filling in the missing data</source>
          <target state="translated">Заполнение недостающих данных</target>
        </trans-unit>
        <trans-unit id="f534a9943c59ee88bfbaa91a174f38f23a434db7" translate="yes" xml:space="preserve">
          <source>Filling value used to pad missing data on the shorter arrays.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4473d8b6f530a08d5d328b58cdecfd819be6ec67" translate="yes" xml:space="preserve">
          <source>Filling value. A consistency test is performed to make sure the value is compatible with the dtype of &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">Начальная стоимость. Выполняется проверка согласованности, чтобы убедиться, что значение совместимо с dtype &lt;code&gt;a&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="13227282778cd8d20999d32a512e651e3ee07193" translate="yes" xml:space="preserve">
          <source>Filling value. Default is None.</source>
          <target state="translated">Заправочная стоимость.По умолчанию нет.</target>
        </trans-unit>
        <trans-unit id="6c1d42d50fc7e4074f490614ad1bcf00ba471b76" translate="yes" xml:space="preserve">
          <source>Fills &lt;code&gt;nop&lt;/code&gt; flags. Sets &lt;code&gt;outreadflags[i]&lt;/code&gt; to 1 if &lt;code&gt;op[i]&lt;/code&gt; can be read from, and to 0 if not.</source>
          <target state="translated">Заполняет флаги &lt;code&gt;nop&lt;/code&gt; . Устанавливает &lt;code&gt;outreadflags[i]&lt;/code&gt; в 1, если &lt;code&gt;op[i]&lt;/code&gt; можно читать, и в 0, если нет.</target>
        </trans-unit>
        <trans-unit id="749d04ce696c047f8e1f31d9e0905d115c8ee6f7" translate="yes" xml:space="preserve">
          <source>Fills &lt;code&gt;nop&lt;/code&gt; flags. Sets &lt;code&gt;outwriteflags[i]&lt;/code&gt; to 1 if &lt;code&gt;op[i]&lt;/code&gt; can be written to, and to 0 if not.</source>
          <target state="translated">Заполняет флаги &lt;code&gt;nop&lt;/code&gt; . Устанавливает &lt;code&gt;outwriteflags[i]&lt;/code&gt; в 1, если в &lt;code&gt;op[i]&lt;/code&gt; можно записывать, и в 0, если нет.</target>
        </trans-unit>
        <trans-unit id="488079b1696f7e1612a42c6bc0389bc81283467e" translate="yes" xml:space="preserve">
          <source>Fills fields from output with fields from input, with support for nested structures.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d3ad1e9024ff38aba4d75bcdff8761b89757502" translate="yes" xml:space="preserve">
          <source>Filter deprecation warnings while running the test suite.</source>
          <target state="translated">Фильтруйте предупреждения об ослаблении фильтра во время работы набора тестов.</target>
        </trans-unit>
        <trans-unit id="53d64090d55b3e9e6c51d2a5eb3eec10a8e6734d" translate="yes" xml:space="preserve">
          <source>Filters added inside the context manager will be discarded again when leaving it. Upon entering all filters defined outside a context will be applied automatically.</source>
          <target state="translated">Фильтры,добавленные внутри контекстного менеджера,при выходе из него будут снова отбрасываться.При вводе всех фильтров,определенных вне контекстного менеджера,они будут применены автоматически.</target>
        </trans-unit>
        <trans-unit id="1f7718a6ac69fd3c4dc296189cd48158349007af" translate="yes" xml:space="preserve">
          <source>Final output manipulation</source>
          <target state="translated">Манипулирование конечным выводом</target>
        </trans-unit>
        <trans-unit id="f8cf825450130b603f61a294cd870952ff541ac0" translate="yes" xml:space="preserve">
          <source>Finally make a pull request using Github. Make sure it is against the maintenance branch and not master, Github will usually suggest you make the pull request against master.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba468d0ce6c90f05fb67a4c2a63c164ebea004bd" translate="yes" xml:space="preserve">
          <source>Finally, &lt;code&gt;Configuration&lt;/code&gt; has &lt;code&gt;.todict()&lt;/code&gt; method that returns all the configuration data as a dictionary suitable for passing on to the &lt;code&gt;setup(..)&lt;/code&gt; function.</source>
          <target state="translated">Наконец, в &lt;code&gt;Configuration&lt;/code&gt; есть &lt;code&gt;.todict()&lt;/code&gt; который возвращает все данные конфигурации в виде словаря, подходящего для передачи в функцию &lt;code&gt;setup(..)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="889c8c42cccc1d124561a48d8ca41abb6ac29d7b" translate="yes" xml:space="preserve">
          <source>Finally, a data type can describe items that are themselves arrays of items of another data type. These sub-arrays must, however, be of a fixed size.</source>
          <target state="translated">Наконец,тип данных может описывать элементы,которые сами по себе являются массивами элементов другого типа данных.Однако эти подмассивы должны иметь фиксированный размер.</target>
        </trans-unit>
        <trans-unit id="aa9d6cc4ce78cfcc5632e894bf62475be204d2f2" translate="yes" xml:space="preserve">
          <source>Finally, build an extension module using &lt;code&gt;f2py -c -m foo calculate.f&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c4822ed4109421c2e3621bdd61e51416dfd1386" translate="yes" xml:space="preserve">
          <source>Finally, build the extension module using &lt;code&gt;f2py -c callback2.pyf callback.f&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="591676022a4d7afed7631e7209e11f88a0c70ca2" translate="yes" xml:space="preserve">
          <source>Finally, if you are only interested in testing a subset of SciPy, for example, the &lt;code&gt;integrate&lt;/code&gt; module, use the following:</source>
          <target state="translated">Наконец, если вас интересует только тестирование подмножества SciPy, например, модуля &lt;code&gt;integrate&lt;/code&gt; , используйте следующее:</target>
        </trans-unit>
        <trans-unit id="7ffdd7c64bfdacea7dacfdba32a5f08b8fc22860" translate="yes" xml:space="preserve">
          <source>Finally, if you detect a typo or an error in the documentation, or would like to suggest a different approach, you can also open an issue or submit a pull request with your suggestion. Keep in mind that changes fixing grammatical/spelling errors are welcome but not necessarily the highest priority. &amp;ldquo;Grammatical correctness&amp;rdquo; often gets confused with &amp;ldquo;style&amp;rdquo; which can result in unfruitful discussions that don&amp;rsquo;t necessarily improve anything. Changes that modify wording or rearrange phrasing without changing the technical content are discouraged. If you think that a different wording improves clarity, you should open an issue as noted above, but again, changes along these lines very often tend to be highly subjective and not necessarily do much to improve the quality of the documentation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3cd9ab198daaf3fb255075968e2a8d87bc37a3b9" translate="yes" xml:space="preserve">
          <source>Finally, it is emphasized that &lt;code&gt;v&lt;/code&gt; consists of the &lt;em&gt;right&lt;/em&gt; (as in right-hand side) eigenvectors of &lt;code&gt;a&lt;/code&gt;. A vector &lt;code&gt;y&lt;/code&gt; satisfying &lt;code&gt;dot(y.T, a) = z * y.T&lt;/code&gt; for some number &lt;code&gt;z&lt;/code&gt; is called a &lt;em&gt;left&lt;/em&gt; eigenvector of &lt;code&gt;a&lt;/code&gt;, and, in general, the left and right eigenvectors of a matrix are not necessarily the (perhaps conjugate) transposes of each other.</source>
          <target state="translated">Наконец, следует подчеркнуть , что &lt;code&gt;v&lt;/code&gt; состоит из &lt;em&gt;права&lt;/em&gt; (как и в правой части) собственные векторы . Вектор &lt;code&gt;y&lt;/code&gt; , удовлетворяющий &lt;code&gt;dot(y.T, a) = z * y.T&lt;/code&gt; для некоторого числа &lt;code&gt;z&lt;/code&gt; , называется &lt;em&gt;левым&lt;/em&gt; собственным вектором &lt;code&gt;a&lt;/code&gt; , и, как правило, левый и правый собственные векторы матрицы не обязательно являются (возможно, сопряженными) транспонами каждого Другой. &lt;code&gt;a&lt;/code&gt; &lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="d65f378e68ed6a19a18dfdea402e5e3481327cbe" translate="yes" xml:space="preserve">
          <source>Finally, it is emphasized that &lt;code&gt;v&lt;/code&gt; consists of the &lt;em&gt;right&lt;/em&gt; (as in right-hand side) eigenvectors of &lt;code&gt;a&lt;/code&gt;. A vector &lt;code&gt;y&lt;/code&gt; satisfying &lt;code&gt;y.T @ a = z * y.T&lt;/code&gt; for some number &lt;code&gt;z&lt;/code&gt; is called a &lt;em&gt;left&lt;/em&gt; eigenvector of &lt;code&gt;a&lt;/code&gt;, and, in general, the left and right eigenvectors of a matrix are not necessarily the (perhaps conjugate) transposes of each other.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7cc16b6bd7f60859052f3d3e721d3a31f9f6a180" translate="yes" xml:space="preserve">
          <source>Finally, now you are confident this tag correctly defines the source code that you released you can push the tag and release commit up to github:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6153981fb1186c6a6c180fa5791ae775d104d070" translate="yes" xml:space="preserve">
          <source>Finally, remove the backup branch upon a successful rebase:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="98d9a64e4784c058720be52ad39c03d39a9fcbd1" translate="yes" xml:space="preserve">
          <source>Finally, specific entries can be masked and/or unmasked by assigning to the mask a sequence of booleans:</source>
          <target state="translated">Наконец,определенные записи могут быть замаскированы и/или размаскированы,назначив маске последовательность булеонов:</target>
        </trans-unit>
        <trans-unit id="4d63661f6815f6c84ea80e3487b297638030ca91" translate="yes" xml:space="preserve">
          <source>Finally, the committee will make a report to the NumPy Steering Council (as well as the NumPy core team in the event of an ongoing resolution, such as a ban).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d4ee797bc2c97cc8f17d94ef802f458cb35c39bc" translate="yes" xml:space="preserve">
          <source>Finally, the decision is made about how to execute the looping mechanism to ensure that all elements of the input arrays are combined to produce the output arrays of the correct type. The options for loop execution are one-loop (for contiguous, aligned, and correct data type), strided-loop (for non-contiguous but still aligned and correct data type), and a buffered loop (for mis-aligned or incorrect data type situations). Depending on which execution method is called for, the loop is then setup and computed.</source>
          <target state="translated">Наконец,принимается решение о том,как выполнить петлевой механизм для обеспечения того,чтобы все элементы входных массивов были объединены для получения выходных массивов правильного типа.Варианты выполнения цикла-одноконтурный цикл (для выравнивания,выравнивания и правильного типа данных),петлевой цикл (для не выравнивания,но выравнивания и правильного типа данных)и буферизованный цикл (для ситуаций с неправильным выравниванием или неправильным типом данных).В зависимости от того,какой метод выполнения вызывается,цикл настраивается и вычисляется.</target>
        </trans-unit>
        <trans-unit id="75d671d62eb366ddccfcb1e2724191d1a472b131" translate="yes" xml:space="preserve">
          <source>Finally, the two functions to be exported by the interface can be written simply as:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f06dcc2f32047bb203bf95d18ff9fb7501e8c9e4" translate="yes" xml:space="preserve">
          <source>Finally, to obtain the full approximated image, we need to reassemble these matrices into the approximation. Now, note that</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3616e9f1dcf861efd823c12b4478a31e6b82b402" translate="yes" xml:space="preserve">
          <source>Financial functions</source>
          <target state="translated">Финансовые функции</target>
        </trans-unit>
        <trans-unit id="e6c50d99742741634b01369176b77e9bcc5af665" translate="yes" xml:space="preserve">
          <source>Financial interests, such as investments, employment or contracting work, outside of The Project that may influence their work on The Project.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eddebdeca9f674c3a8bdff9147a750bce04b0b48" translate="yes" xml:space="preserve">
          <source>Find a candidate who can serve as a mediator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="75334f040026f76d3eebb8839bcb303508014551" translate="yes" xml:space="preserve">
          <source>Find a domain suitable for a polynomial or Chebyshev series defined at the values supplied.</source>
          <target state="translated">Найдите домен,подходящий для полиномиальной или чебышевской серии,определенной по заданным значениям.</target>
        </trans-unit>
        <trans-unit id="c2a6e9c15d888c380a37d1831fa7891adeb9bb51" translate="yes" xml:space="preserve">
          <source>Find contiguous unmasked data in a masked array along the given axis.</source>
          <target state="translated">Поиск смежных размаскированных данных в массиве по заданной оси.</target>
        </trans-unit>
        <trans-unit id="a4ea5a445ce3dee9c559f1f1b3b7f52dca61477d" translate="yes" xml:space="preserve">
          <source>Find elements in a sorted array.</source>
          <target state="translated">Поиск элементов в отсортированном массиве.</target>
        </trans-unit>
        <trans-unit id="48cd38efe59f33f3a5f798ed6a4cf4880d549aa4" translate="yes" xml:space="preserve">
          <source>Find elements in sorted array.</source>
          <target state="translated">Поиск элементов в отсортированном массиве.</target>
        </trans-unit>
        <trans-unit id="f6a5d00a32b708a9fb964c2d1da18b0ebb9fba20" translate="yes" xml:space="preserve">
          <source>Find indices where elements of v should be inserted in a to maintain order.</source>
          <target state="translated">Найти индексы,в которых элементы v должны быть вставлены в порядке.</target>
        </trans-unit>
        <trans-unit id="18d914d41d09d92c97e462c896bc6019f8705e89" translate="yes" xml:space="preserve">
          <source>Find indices where elements should be inserted to maintain order.</source>
          <target state="translated">Поиск индексов,в которые следует вставлять элементы для поддержания порядка.</target>
        </trans-unit>
        <trans-unit id="9f16fd78492b0e655d9646c090e0277fb4bab8b3" translate="yes" xml:space="preserve">
          <source>Find more information about &lt;a href=&quot;../reference/arrays.indexing#arrays-indexing&quot;&gt;newaxis here&lt;/a&gt; and &lt;code&gt;expand_dims&lt;/code&gt; at &lt;a href=&quot;../reference/generated/numpy.expand_dims#numpy.expand_dims&quot;&gt;&lt;code&gt;expand_dims&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4372485b0452a2bbbc2898c490d8eaeffc724caf" translate="yes" xml:space="preserve">
          <source>Find the coefficients of a polynomial with a given sequence of roots.</source>
          <target state="translated">Найти коэффициенты многочлена с заданной последовательностью корней.</target>
        </trans-unit>
        <trans-unit id="faa2e8dff7b7635f67ecf147d005df15f99ba737" translate="yes" xml:space="preserve">
          <source>Find the coefficients of a polynomial with the given sequence of roots.</source>
          <target state="translated">Найти коэффициенты многочлена с заданной последовательностью корней.</target>
        </trans-unit>
        <trans-unit id="4eb3d9e0549601789e7c859dc2344bd2a9cd19fd" translate="yes" xml:space="preserve">
          <source>Find the derivative of order &lt;code&gt;m&lt;/code&gt;.</source>
          <target state="translated">Найдите производную порядка &lt;code&gt;m&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d4ef9328264dc057bcc77daf8eddd203dc0e44a3" translate="yes" xml:space="preserve">
          <source>Find the duplicates in a structured array along a given key</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b2e68d5137b01880925e686f099633be3e06dde" translate="yes" xml:space="preserve">
          <source>Find the indices into a sorted array &lt;code&gt;a&lt;/code&gt; such that, if the corresponding elements in &lt;code&gt;v&lt;/code&gt; were inserted before the indices, the order of &lt;code&gt;a&lt;/code&gt; would be preserved.</source>
          <target state="translated">Найдите индексы в отсортированном массиве &lt;code&gt;a&lt;/code&gt; так , чтобы, если соответствующие элементы в &lt;code&gt;v&lt;/code&gt; были вставлены перед индексами, порядок &lt;code&gt;a&lt;/code&gt; был бы сохранен.</target>
        </trans-unit>
        <trans-unit id="7a9d95dd2166bd57167eb2521a394d4c2313d8ed" translate="yes" xml:space="preserve">
          <source>Find the indices of array elements that are non-zero, grouped by element.</source>
          <target state="translated">Найти индексы ненулевых элементов массива,сгруппированных по элементам.</target>
        </trans-unit>
        <trans-unit id="2515b150e246a2efffb14706325a36534baa7e52" translate="yes" xml:space="preserve">
          <source>Find the indices of the first and last unmasked values along an axis.</source>
          <target state="translated">Поиск индексов первого и последнего размаскированных значений по оси.</target>
        </trans-unit>
        <trans-unit id="696f121ac590832370778adcb2254fdcf409cf46" translate="yes" xml:space="preserve">
          <source>Find the indices of the first and last unmasked values.</source>
          <target state="translated">Найти индексы первого и последнего размаскированных значений.</target>
        </trans-unit>
        <trans-unit id="8c77cbf79b427711a4234d92c8cd55031f045a5a" translate="yes" xml:space="preserve">
          <source>Find the intersection of two arrays.</source>
          <target state="translated">Найдите пересечение двух массивов.</target>
        </trans-unit>
        <trans-unit id="1d747b61a4dca9ab1a6c9357e1706a93f4e98f6e" translate="yes" xml:space="preserve">
          <source>Find the product of two polynomials.</source>
          <target state="translated">Найдите продукт из двух полиномов.</target>
        </trans-unit>
        <trans-unit id="f141aa841d4a25a7614625f7b95555f03b44cb1f" translate="yes" xml:space="preserve">
          <source>Find the roots:</source>
          <target state="translated">Найди корни:</target>
        </trans-unit>
        <trans-unit id="e641c4ed98de6b655c0148c1b174236bccd25db9" translate="yes" xml:space="preserve">
          <source>Find the set difference of two arrays.</source>
          <target state="translated">Найдите разницу между двумя массивами.</target>
        </trans-unit>
        <trans-unit id="1d47458289ee93eb8b76d9bd5fb051fb0ed38ef9" translate="yes" xml:space="preserve">
          <source>Find the set exclusive-or of two arrays.</source>
          <target state="translated">Найдите эксклюзивный набор или два массива.</target>
        </trans-unit>
        <trans-unit id="40c6faf7e08f7eff45fa7f2fb510420c1dd0653b" translate="yes" xml:space="preserve">
          <source>Find the sum of two polynomials.</source>
          <target state="translated">Найдите сумму двух полиномов.</target>
        </trans-unit>
        <trans-unit id="bc296de5854442d0290915421679a6d44da683c5" translate="yes" xml:space="preserve">
          <source>Find the union of two arrays.</source>
          <target state="translated">Найди объединение двух массивов.</target>
        </trans-unit>
        <trans-unit id="1c2a1d48695ed18506cd6bf1d2bc59c3cfb89875" translate="yes" xml:space="preserve">
          <source>Find the unique elements of an array.</source>
          <target state="translated">Найти уникальные элементы массива.</target>
        </trans-unit>
        <trans-unit id="3c5a640c918941c9e6a6ecbfe984c3f4bfbed0d7" translate="yes" xml:space="preserve">
          <source>Finding help</source>
          <target state="translated">Помощь в поиске</target>
        </trans-unit>
        <trans-unit id="5b7033e44afb091d2adc537dc898dc007a565a8f" translate="yes" xml:space="preserve">
          <source>Finding masked data</source>
          <target state="translated">Поиск замаскированных данных</target>
        </trans-unit>
        <trans-unit id="3f98684f09d3dc8ddcf467b643533c39f6675211" translate="yes" xml:space="preserve">
          <source>Finds the data type of smallest size and kind to which &lt;em&gt;type1&lt;/em&gt; and &lt;em&gt;type2&lt;/em&gt; may be safely converted. This function is symmetric and associative. A string or unicode result will be the proper size for storing the max value of the input types converted to a string or unicode.</source>
          <target state="translated">Находит тип данных наименьшего размера и типа, в который можно безопасно преобразовать &lt;em&gt;type1&lt;/em&gt; и &lt;em&gt;type2&lt;/em&gt; . Эта функция симметрична и ассоциативна. Результат в виде строки или юникода будет подходящим размером для хранения максимального значения типов ввода, преобразованных в строку или юникод.</target>
        </trans-unit>
        <trans-unit id="ce819b28621d52328ceb9faf1bacb0b89098499a" translate="yes" xml:space="preserve">
          <source>Finds the polynomial resulting from the multiplication of the two input polynomials. Each input must be either a poly1d object or a 1D sequence of polynomial coefficients, from highest to lowest degree.</source>
          <target state="translated">Находит полином,полученный в результате умножения двух входных полиномов.Каждый вход должен быть либо поли1d объектом,либо 1D последовательностью полиномиальных коэффициентов,от высшей до низшей степени.</target>
        </trans-unit>
        <trans-unit id="1b46b96bf59323c910259f84d4d30f9baf994f09" translate="yes" xml:space="preserve">
          <source>Finish the Release Note</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7f34df28a801d8ac2bf79f8d990420b3ba51454a" translate="yes" xml:space="preserve">
          <source>First adjusts the date to fall on a valid day according to the &lt;code&gt;roll&lt;/code&gt; rule, then applies offsets to the given dates counted in valid days.</source>
          <target state="translated">Сначала настраивает дату, чтобы она приходилась на действительный день в соответствии с правилом &lt;code&gt;roll&lt;/code&gt; , затем применяет смещения к указанным датам, подсчитанным в действительных днях.</target>
        </trans-unit>
        <trans-unit id="3d783583ca6eea2b3fefbcfe238ea095a9cef1e3" translate="yes" xml:space="preserve">
          <source>First argument.</source>
          <target state="translated">Первый аргумент.</target>
        </trans-unit>
        <trans-unit id="b0d88798d2f2c8c94dabdac74a6e61e0c6a796bf" translate="yes" xml:space="preserve">
          <source>First array</source>
          <target state="translated">Первый массив</target>
        </trans-unit>
        <trans-unit id="6ac9adbced8bb3d28582fadcfc79411667f91541" translate="yes" xml:space="preserve">
          <source>First array elements raised to powers from second array, element-wise.</source>
          <target state="translated">Первые элементы массива,поднятые на питание из второго массива,по элементам.</target>
        </trans-unit>
        <trans-unit id="2e663054d84a3a5ee1c34a1c08db3c0840bbd3a5" translate="yes" xml:space="preserve">
          <source>First axis.</source>
          <target state="translated">Первая ось.</target>
        </trans-unit>
        <trans-unit id="683b791e072100a372b3bb52b18b0195b72f135d" translate="yes" xml:space="preserve">
          <source>First data type.</source>
          <target state="translated">Первый тип данных.</target>
        </trans-unit>
        <trans-unit id="380b7446c9b92904f875ef654f53dbe5211d262c" translate="yes" xml:space="preserve">
          <source>First fork NumPy into your account, as from &lt;a href=&quot;gitwash/development_setup#forking&quot;&gt;Making your own copy (fork) of NumPy&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c696689a14b681bedf220e6fcb537947492362e7" translate="yes" xml:space="preserve">
          <source>First input vector. Input is flattened if not already 1-dimensional.</source>
          <target state="translated">Первый входной вектор.Входной вектор сплющенный,если еще не 1-мерный.</target>
        </trans-unit>
        <trans-unit id="4da5db5b8e385a1ee882571360fd0091e5988af4" translate="yes" xml:space="preserve">
          <source>First mode, &lt;code&gt;buffer&lt;/code&gt; is None:</source>
          <target state="translated">Первый режим, &lt;code&gt;buffer&lt;/code&gt; отсутствует:</target>
        </trans-unit>
        <trans-unit id="79fb79c693534cb9180b2dc2b3dd92f6526ad678" translate="yes" xml:space="preserve">
          <source>First of all, if confused or uncertain, definitely look at the Examples - in its full generality, this function is less simple than it might seem from the following code description (below ndi = &lt;code&gt;numpy.lib.index_tricks&lt;/code&gt;):</source>
          <target state="translated">Прежде всего, если вы запутались или сомневаетесь, обязательно посмотрите Примеры - в общем, эта функция менее проста, чем может показаться из следующего описания кода (ниже &lt;code&gt;numpy.lib.index_tricks&lt;/code&gt; = numpy.lib.index_tricks ):</target>
        </trans-unit>
        <trans-unit id="9507aadaef3c19b4ad781014173284bb4bf64a4d" translate="yes" xml:space="preserve">
          <source>First one-dimensional input array.</source>
          <target state="translated">Первый одномерный входной массив.</target>
        </trans-unit>
        <trans-unit id="563237e589c4b3a10445b43e30dbcdf140e6cad9" translate="yes" xml:space="preserve">
          <source>First we need a polynomial class and a polynomial instance to play with. The classes can be imported directly from the polynomial package or from the module of the relevant type. Here we import from the package and use the conventional Polynomial class because of its familiarity:</source>
          <target state="translated">Для начала нам нужен класс полинома и экземпляр полинома.Классы могут быть импортированы непосредственно из полиномиального пакета или из модуля соответствующего типа.Здесь мы импортируем из пакета и используем обычный класс полинома из-за его известности:</target>
        </trans-unit>
        <trans-unit id="b0f42fa2b5b73e0d242583740b22144cb029b3bc" translate="yes" xml:space="preserve">
          <source>First you follow the instructions for &lt;a href=&quot;#forking&quot;&gt;Making your own copy (fork) of NumPy&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a78e460dd4b928f74942152fb57a017ad1190035" translate="yes" xml:space="preserve">
          <source>First, change/check the following variables in &lt;code&gt;pavement.py&lt;/code&gt; depending on the release version:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5de2ca0c3525a19f6ce453df437f39312ae63f64" translate="yes" xml:space="preserve">
          <source>First, fetch new commits from the &lt;code&gt;upstream&lt;/code&gt; repository:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb7560a3397ca22e9994a5b8700ca3649fe54f4e" translate="yes" xml:space="preserve">
          <source>First, let&amp;rsquo;s check for the shape of the data in our array. Since this image is two-dimensional (the pixels in the image form a rectangle), we might expect a two-dimensional array to represent it (a matrix). However, using the &lt;code&gt;shape&lt;/code&gt; property of this NumPy array gives us a different result:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e842f4efdaf87bde11917dd06d4d96aa743693a2" translate="yes" xml:space="preserve">
          <source>First, merge or rebase on the target branch.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d50e07ef0974f6c61f9887836f0cd195c4b8ffe" translate="yes" xml:space="preserve">
          <source>First, we create a signature file from &lt;code&gt;fib1.f&lt;/code&gt; by running</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b5747b08f0749ca8d3f849c4ccb46feb2a535fd" translate="yes" xml:space="preserve">
          <source>First, we solve for</source>
          <target state="translated">Во-первых,мы решаем для</target>
        </trans-unit>
        <trans-unit id="2db03d669f6d38f72ba0afd2d06c9fa6852bb990" translate="yes" xml:space="preserve">
          <source>First, you need to make the branch you will work on. This needs to be based on the older version of NumPy (not master):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b876747d103212266850792bf08c2d985fdb7ec" translate="yes" xml:space="preserve">
          <source>Fisher, R.A,, A.S. Corbet, and C.B. Williams. 1943. The relation between the number of species and the number of individuals in a random sample of an animal population. Journal of Animal Ecology, 12:42-58.</source>
          <target state="translated">Фишер,Р.А.,А.С.Корбет и К.Б.Уильямс.1943.Соотношение между числом видов и числом особей в случайной выборке популяции животных.Журнал экологии животных,12:42-58.</target>
        </trans-unit>
        <trans-unit id="1c009756385026adf817423fdf3347327b7bcadd" translate="yes" xml:space="preserve">
          <source>Fit a line, &lt;code&gt;y = mx + c&lt;/code&gt;, through some noisy data-points:</source>
          <target state="translated">Проведите линию &lt;code&gt;y = mx + c&lt;/code&gt; через несколько зашумленных точек данных:</target>
        </trans-unit>
        <trans-unit id="04b6a58e5360946679575e2105b73e661e63702d" translate="yes" xml:space="preserve">
          <source>Fit a polynomial &lt;code&gt;p(x) = p[0] * x**deg + ... + p[deg]&lt;/code&gt; of degree &lt;code&gt;deg&lt;/code&gt; to points &lt;code&gt;(x, y)&lt;/code&gt;. Returns a vector of coefficients &lt;code&gt;p&lt;/code&gt; that minimises the squared error in the order &lt;code&gt;deg&lt;/code&gt;, &lt;code&gt;deg-1&lt;/code&gt;, &amp;hellip; &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">Подобрать многочлен &lt;code&gt;p(x) = p[0] * x**deg + ... + p[deg]&lt;/code&gt; степени &lt;code&gt;deg&lt;/code&gt; к точкам &lt;code&gt;(x, y)&lt;/code&gt; . Возвращает вектор коэффициентов &lt;code&gt;p&lt;/code&gt; , который минимизирует квадрат ошибки в порядке &lt;code&gt;deg&lt;/code&gt; , &lt;code&gt;deg-1&lt;/code&gt; ,&amp;hellip; &lt;code&gt;0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c63bb8e80d7458f568a44355aa0204375070cb16" translate="yes" xml:space="preserve">
          <source>Fits using Chebyshev series are usually better conditioned than fits using power series, but much can depend on the distribution of the sample points and the smoothness of the data. If the quality of the fit is inadequate splines may be a good alternative.</source>
          <target state="translated">Подгонки с использованием чебышевских серий обычно лучше обусловлены,чем подгонки с использованием силовых серий,но многое может зависеть от распределения точек выборки и гладкости данных.Если качество подгонки неудовлетворительное,то хорошей альтернативой могут быть сплайны.</target>
        </trans-unit>
        <trans-unit id="aed614e2e664ebb51dcf5d13afb77c7acb23c65a" translate="yes" xml:space="preserve">
          <source>Fits using Hermite series are probably most useful when the data can be approximated by &lt;code&gt;sqrt(w(x)) * p(x)&lt;/code&gt;, where &lt;code&gt;w(x)&lt;/code&gt; is the Hermite weight. In that case the weight &lt;code&gt;sqrt(w(x[i]))&lt;/code&gt; should be used together with data values &lt;code&gt;y[i]/sqrt(w(x[i]))&lt;/code&gt;. The weight function is available as &lt;a href=&quot;numpy.polynomial.hermite.hermweight#numpy.polynomial.hermite.hermweight&quot;&gt;&lt;code&gt;hermweight&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ac350719f356e32b4a5aa08bc22f253d0d0c702" translate="yes" xml:space="preserve">
          <source>Fits using Hermite series are probably most useful when the data can be approximated by &lt;code&gt;sqrt(w(x)) * p(x)&lt;/code&gt;, where &lt;code&gt;w(x)&lt;/code&gt; is the Hermite weight. In that case the weight &lt;code&gt;sqrt(w(x[i])&lt;/code&gt; should be used together with data values &lt;code&gt;y[i]/sqrt(w(x[i])&lt;/code&gt;. The weight function is available as &lt;a href=&quot;numpy.polynomial.hermite.hermweight#numpy.polynomial.hermite.hermweight&quot;&gt;&lt;code&gt;hermweight&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Подборы с использованием ряда Эрмита, вероятно, наиболее полезны, когда данные могут быть аппроксимированы как &lt;code&gt;sqrt(w(x)) * p(x)&lt;/code&gt; , где &lt;code&gt;w(x)&lt;/code&gt; - это вес Эрмита. В этом случае вес &lt;code&gt;sqrt(w(x[i])&lt;/code&gt; должен использоваться вместе со значениями данных &lt;code&gt;y[i]/sqrt(w(x[i])&lt;/code&gt; . Весовая функция доступна как &lt;a href=&quot;numpy.polynomial.hermite.hermweight#numpy.polynomial.hermite.hermweight&quot;&gt; &lt;code&gt;hermweight&lt;/code&gt; )&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2a56ae26ef02f4f89e7f11d94ca2c9c2304108b1" translate="yes" xml:space="preserve">
          <source>Fits using HermiteE series are probably most useful when the data can be approximated by &lt;code&gt;sqrt(w(x)) * p(x)&lt;/code&gt;, where &lt;code&gt;w(x)&lt;/code&gt; is the HermiteE weight. In that case the weight &lt;code&gt;sqrt(w(x[i]))&lt;/code&gt; should be used together with data values &lt;code&gt;y[i]/sqrt(w(x[i]))&lt;/code&gt;. The weight function is available as &lt;a href=&quot;numpy.polynomial.hermite_e.hermeweight#numpy.polynomial.hermite_e.hermeweight&quot;&gt;&lt;code&gt;hermeweight&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="676d43f6371871e1abab21b58a8b9ef9e5c444e9" translate="yes" xml:space="preserve">
          <source>Fits using HermiteE series are probably most useful when the data can be approximated by &lt;code&gt;sqrt(w(x)) * p(x)&lt;/code&gt;, where &lt;code&gt;w(x)&lt;/code&gt; is the HermiteE weight. In that case the weight &lt;code&gt;sqrt(w(x[i])&lt;/code&gt; should be used together with data values &lt;code&gt;y[i]/sqrt(w(x[i])&lt;/code&gt;. The weight function is available as &lt;a href=&quot;numpy.polynomial.hermite_e.hermeweight#numpy.polynomial.hermite_e.hermeweight&quot;&gt;&lt;code&gt;hermeweight&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Подборы с использованием серии HermiteE, вероятно, наиболее полезны, когда данные можно аппроксимировать с помощью &lt;code&gt;sqrt(w(x)) * p(x)&lt;/code&gt; , где &lt;code&gt;w(x)&lt;/code&gt; - это вес HermiteE. В этом случае вес &lt;code&gt;sqrt(w(x[i])&lt;/code&gt; должен использоваться вместе со значениями данных &lt;code&gt;y[i]/sqrt(w(x[i])&lt;/code&gt; . Весовая функция доступна как &lt;a href=&quot;numpy.polynomial.hermite_e.hermeweight#numpy.polynomial.hermite_e.hermeweight&quot;&gt; &lt;code&gt;hermeweight&lt;/code&gt; )&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ce120ffeca412ba96243f730c358ebc5c1bfbf99" translate="yes" xml:space="preserve">
          <source>Fits using Laguerre series are probably most useful when the data can be approximated by &lt;code&gt;sqrt(w(x)) * p(x)&lt;/code&gt;, where &lt;code&gt;w(x)&lt;/code&gt; is the Laguerre weight. In that case the weight &lt;code&gt;sqrt(w(x[i]))&lt;/code&gt; should be used together with data values &lt;code&gt;y[i]/sqrt(w(x[i]))&lt;/code&gt;. The weight function is available as &lt;a href=&quot;numpy.polynomial.laguerre.lagweight#numpy.polynomial.laguerre.lagweight&quot;&gt;&lt;code&gt;lagweight&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a6ad2d45b7ba84d02856af83a31db48500b6c521" translate="yes" xml:space="preserve">
          <source>Fits using Laguerre series are probably most useful when the data can be approximated by &lt;code&gt;sqrt(w(x)) * p(x)&lt;/code&gt;, where &lt;code&gt;w(x)&lt;/code&gt; is the Laguerre weight. In that case the weight &lt;code&gt;sqrt(w(x[i])&lt;/code&gt; should be used together with data values &lt;code&gt;y[i]/sqrt(w(x[i])&lt;/code&gt;. The weight function is available as &lt;a href=&quot;numpy.polynomial.laguerre.lagweight#numpy.polynomial.laguerre.lagweight&quot;&gt;&lt;code&gt;lagweight&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Подборы с использованием ряда Лагерра, вероятно, наиболее полезны, когда данные могут быть аппроксимированы с помощью &lt;code&gt;sqrt(w(x)) * p(x)&lt;/code&gt; , где &lt;code&gt;w(x)&lt;/code&gt; - вес Лагерра. В этом случае вес &lt;code&gt;sqrt(w(x[i])&lt;/code&gt; должен использоваться вместе со значениями данных &lt;code&gt;y[i]/sqrt(w(x[i])&lt;/code&gt; . Весовая функция доступна как &lt;a href=&quot;numpy.polynomial.laguerre.lagweight#numpy.polynomial.laguerre.lagweight&quot;&gt; &lt;code&gt;lagweight&lt;/code&gt; )&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a49cebd2c0a64b6ed696a25d8e9c66d10c8d54a0" translate="yes" xml:space="preserve">
          <source>Fits using Legendre series are usually better conditioned than fits using power series, but much can depend on the distribution of the sample points and the smoothness of the data. If the quality of the fit is inadequate splines may be a good alternative.</source>
          <target state="translated">Подгонки с использованием серии Legendre обычно лучше,чем подгонки с использованием серии Power,но многое может зависеть от распределения точек выборки и гладкости данных.Если качество подгонки неудовлетворительное,то хорошей альтернативой могут быть сплайны.</target>
        </trans-unit>
        <trans-unit id="5165daf49b08b1322899a60f534d050a344807b1" translate="yes" xml:space="preserve">
          <source>Fitting</source>
          <target state="translated">Fitting</target>
        </trans-unit>
        <trans-unit id="5e51f96db68dc8fabd62d003884216322595fc6f" translate="yes" xml:space="preserve">
          <source>Fitting is the reason that the &lt;code&gt;domain&lt;/code&gt; and &lt;code&gt;window&lt;/code&gt; attributes are part of the convenience classes. To illustrate the problem, the values of the Chebyshev polynomials up to degree 5 are plotted below.</source>
          <target state="translated">Подгонка является причиной того, что атрибуты &lt;code&gt;domain&lt;/code&gt; и &lt;code&gt;window&lt;/code&gt; являются частью вспомогательных классов. Для иллюстрации проблемы ниже приведены значения полиномов Чебышева до степени 5.</target>
        </trans-unit>
        <trans-unit id="a882b40f9b004c60f42b6ed77cd0d0cb856640fe" translate="yes" xml:space="preserve">
          <source>Fix for PPC long double floating point information</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="919c4e1e9eb76e3cc1d2c2a8e361176acc1a9a4a" translate="yes" xml:space="preserve">
          <source>Fix regression in matmul (&lt;code&gt;@&lt;/code&gt; operator) for boolean types</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f0d59fd522286a2d4031174470931df04c244c1" translate="yes" xml:space="preserve">
          <source>Fix swig bug in &lt;code&gt;numpy.i&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f95e31f1005ee116c93848080ddafc6a63474e8a" translate="yes" xml:space="preserve">
          <source>Fix to financial.npv</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe4ad4288a37cfec787d6b9ab856b537a200ab81" translate="yes" xml:space="preserve">
          <source>Fixed &lt;code&gt;eigh&lt;/code&gt; and &lt;code&gt;cholesky&lt;/code&gt; methods in &lt;code&gt;numpy.random.multivariate_normal&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4fa2ab2730080c4d8658ad57247e52d05152019e" translate="yes" xml:space="preserve">
          <source>Fixed stride displacement from the beginning of an axis? Default is 0. Needs to be &amp;gt;=0.</source>
          <target state="translated">Исправлено смещение шага от начала оси? По умолчанию 0. Должно быть&amp;gt; = 0.</target>
        </trans-unit>
        <trans-unit id="cb2453cbdd88f7c5dbf744844c92b0eb5d9399b7" translate="yes" xml:space="preserve">
          <source>Fixed the jumping implementation in &lt;code&gt;MT19937.jumped&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8028cdac733fedf53d18c62ba8dde19dd4874832" translate="yes" xml:space="preserve">
          <source>Fixes Merged</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="988fef1858095167d23aba7f3c43fc27915118e8" translate="yes" xml:space="preserve">
          <source>Fixing Warnings</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="35076585aaced59b92c591cb61ebdef18acdfe9a" translate="yes" xml:space="preserve">
          <source>Flag checking</source>
          <target state="translated">проверка флагов</target>
        </trans-unit>
        <trans-unit id="a59933a6089d6095752a4cce71d3ac903e7e62ac" translate="yes" xml:space="preserve">
          <source>Flag indicating the return a legacy tuple state when the BitGenerator is MT19937.</source>
          <target state="translated">Флаг,указывающий на возврат кортежа в старое состояние,когда BitGenerator имеет MT19937.</target>
        </trans-unit>
        <trans-unit id="ed451b4de2e9f4e89792baf70b0beefe2ddce512" translate="yes" xml:space="preserve">
          <source>Flag indicating to return a legacy tuple state when the BitGenerator is MT19937, instead of a dict.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9eae779d408b29132a4d17f05274c96311b19164" translate="yes" xml:space="preserve">
          <source>Flag indicating whether a tuple &lt;code&gt;(result, sum of weights)&lt;/code&gt; should be returned as output (True), or just the result (False). Default is False.</source>
          <target state="translated">Флаг, указывающий, должен ли кортеж &lt;code&gt;(result, sum of weights)&lt;/code&gt; возвращаться как результат (True) или только результат (False). По умолчанию - False.</target>
        </trans-unit>
        <trans-unit id="cba3c052d7e9a9fd1a29828876ef83802ed53ad9" translate="yes" xml:space="preserve">
          <source>Flag to determine whether to mark test as deprecated or not. If the condition is a callable, it is used at runtime to dynamically make the decision. Default is True.</source>
          <target state="translated">Флаг для определения того,следует ли маркировать тест как устаревший или нет.Если условие является вызываемым,то оно используется во время выполнения для динамического принятия решения.По умолчанию установлено значение True.</target>
        </trans-unit>
        <trans-unit id="fc63716a41208b1dbc0ebbf61137c2d0ff0fbfd4" translate="yes" xml:space="preserve">
          <source>Flag to determine whether to mark the decorated test as a known failure (if True) or not (if False).</source>
          <target state="translated">Флаг для определения того,следует ли маркировать декорированный тест как известную неудачу (если Верно)или нет (если Ложно).</target>
        </trans-unit>
        <trans-unit id="3a36aef11ecfbbf2d82d57b5084b3ab96e773b04" translate="yes" xml:space="preserve">
          <source>Flag to determine whether to skip the decorated test.</source>
          <target state="translated">Флаг,чтобы определить,стоит ли пропустить декорированный тест.</target>
        </trans-unit>
        <trans-unit id="75e57359674e825c88bcaaa1bf354a5ba42abc10" translate="yes" xml:space="preserve">
          <source>Flag-like constants</source>
          <target state="translated">флагманские константы</target>
        </trans-unit>
        <trans-unit id="684f757afc22b26a0ad180a11e58599da12d805b" translate="yes" xml:space="preserve">
          <source>Flags indicating how the memory pointed to by data is to be interpreted. Possible flags are &lt;a href=&quot;c-api.array#c.NPY_ARRAY_C_CONTIGUOUS&quot;&gt;&lt;code&gt;NPY_ARRAY_C_CONTIGUOUS&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;c-api.array#c.NPY_ARRAY_F_CONTIGUOUS&quot;&gt;&lt;code&gt;NPY_ARRAY_F_CONTIGUOUS&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;c-api.array#c.NPY_ARRAY_OWNDATA&quot;&gt;&lt;code&gt;NPY_ARRAY_OWNDATA&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;c-api.array#c.NPY_ARRAY_ALIGNED&quot;&gt;&lt;code&gt;NPY_ARRAY_ALIGNED&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;c-api.array#c.NPY_ARRAY_WRITEABLE&quot;&gt;&lt;code&gt;NPY_ARRAY_WRITEABLE&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;c-api.array#c.NPY_ARRAY_WRITEBACKIFCOPY&quot;&gt;&lt;code&gt;NPY_ARRAY_WRITEBACKIFCOPY&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;c-api.array#c.NPY_ARRAY_UPDATEIFCOPY&quot;&gt;&lt;code&gt;NPY_ARRAY_UPDATEIFCOPY&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Флаги, указывающие, как следует интерпретировать память, на которую указывают данные. Возможные флаги: &lt;a href=&quot;c-api.array#c.NPY_ARRAY_C_CONTIGUOUS&quot;&gt; &lt;code&gt;NPY_ARRAY_C_CONTIGUOUS&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;c-api.array#c.NPY_ARRAY_F_CONTIGUOUS&quot;&gt; &lt;code&gt;NPY_ARRAY_F_CONTIGUOUS&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;c-api.array#c.NPY_ARRAY_OWNDATA&quot;&gt; &lt;code&gt;NPY_ARRAY_OWNDATA&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;c-api.array#c.NPY_ARRAY_ALIGNED&quot;&gt; &lt;code&gt;NPY_ARRAY_ALIGNED&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;c-api.array#c.NPY_ARRAY_WRITEABLE&quot;&gt; &lt;code&gt;NPY_ARRAY_WRITEABLE&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;c-api.array#c.NPY_ARRAY_WRITEBACKIFCOPY&quot;&gt; &lt;code&gt;NPY_ARRAY_WRITEBACKIFCOPY&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;c-api.array#c.NPY_ARRAY_UPDATEIFCOPY&quot;&gt; &lt;code&gt;NPY_ARRAY_UPDATEIFCOPY&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a25e18657a4cd94e4091eda9ea0dfb9fbc2878ec" translate="yes" xml:space="preserve">
          <source>Flags that may be passed in &lt;code&gt;flags&lt;/code&gt; are any combination of the global and per-operand flags documented in &lt;a href=&quot;#c.NpyIter_MultiNew&quot;&gt;&lt;code&gt;NpyIter_MultiNew&lt;/code&gt;&lt;/a&gt;, except for &lt;a href=&quot;#c.NPY_ITER_ALLOCATE&quot;&gt;&lt;code&gt;NPY_ITER_ALLOCATE&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Флаги, которые могут быть переданы в &lt;code&gt;flags&lt;/code&gt; , представляют собой любую комбинацию глобальных флагов и флагов для каждого операнда, задокументированных в &lt;a href=&quot;#c.NpyIter_MultiNew&quot;&gt; &lt;code&gt;NpyIter_MultiNew&lt;/code&gt; &lt;/a&gt; , за исключением &lt;a href=&quot;#c.NPY_ITER_ALLOCATE&quot;&gt; &lt;code&gt;NPY_ITER_ALLOCATE&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="edc811e4e9d890d1a74c59122b943f93451db31b" translate="yes" xml:space="preserve">
          <source>Flags that may be passed in &lt;code&gt;flags&lt;/code&gt;, applying to the whole iterator, are:</source>
          <target state="translated">Флаги, которые могут быть переданы во &lt;code&gt;flags&lt;/code&gt; , применительно ко всему итератору:</target>
        </trans-unit>
        <trans-unit id="e576896ed3787e8ae91c02c3fee7275b55ae4f5d" translate="yes" xml:space="preserve">
          <source>Flags that may be passed in &lt;code&gt;op_flags[i]&lt;/code&gt;, where &lt;code&gt;0 &amp;lt;= i &amp;lt; nop&lt;/code&gt;:</source>
          <target state="translated">Флаги, которые могут быть переданы в &lt;code&gt;op_flags[i]&lt;/code&gt; , где &lt;code&gt;0 &amp;lt;= i &amp;lt; nop&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="0902dde9b75159ba7b0f6af69bd12aa3aed3ab46" translate="yes" xml:space="preserve">
          <source>Flags to control the behavior of the iterator.</source>
          <target state="translated">Флаги для контроля поведения итератора.</target>
        </trans-unit>
        <trans-unit id="1bbaad527fcacc3d77ae0f546c2f20b2e4ef2d71" translate="yes" xml:space="preserve">
          <source>Flat Iterator indexing</source>
          <target state="translated">Плоская индексация итератора</target>
        </trans-unit>
        <trans-unit id="ca0541280577eeacfb45501ad1950007e690905f" translate="yes" xml:space="preserve">
          <source>Flat array iterator.</source>
          <target state="translated">Плоский итератор массива.</target>
        </trans-unit>
        <trans-unit id="3f8292fdeb383ecef90303832ffb1117799af185" translate="yes" xml:space="preserve">
          <source>Flat iteration</source>
          <target state="translated">Плоская итерация</target>
        </trans-unit>
        <trans-unit id="666002e8705384831180e281fa74a843e3206b27" translate="yes" xml:space="preserve">
          <source>Flat iterator object to iterate over arrays.</source>
          <target state="translated">Плоский объект итератора для итераций по массивам.</target>
        </trans-unit>
        <trans-unit id="7d04e81220d975aa709532a3862f6c1a6f4a3f05" translate="yes" xml:space="preserve">
          <source>Flatten a structured data-type description.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec4ad130c0f4e03f5e84c5e86d9264a95dc6c3f6" translate="yes" xml:space="preserve">
          <source>Flattened version of this function.</source>
          <target state="translated">Плоская версия этой функции.</target>
        </trans-unit>
        <trans-unit id="21fe615f2b66ecf8096308ee67f646d6664a1077" translate="yes" xml:space="preserve">
          <source>Flip an array horizontally (axis=1).</source>
          <target state="translated">Переверните массив по горизонтали (ось=1).</target>
        </trans-unit>
        <trans-unit id="7849c3ad46cd56097aefd350ce5a24872c1a9619" translate="yes" xml:space="preserve">
          <source>Flip an array horizontally.</source>
          <target state="translated">Переверните массив горизонтально.</target>
        </trans-unit>
        <trans-unit id="a25cec9261711d7c64f4f0328d27630ff4251008" translate="yes" xml:space="preserve">
          <source>Flip an array vertically (axis=0).</source>
          <target state="translated">Переверните массив по вертикали (ось=0).</target>
        </trans-unit>
        <trans-unit id="58f1196dc69384b1c0ff7122abf54115c6fe24e6" translate="yes" xml:space="preserve">
          <source>Flip an array vertically.</source>
          <target state="translated">Переверните массив вертикально.</target>
        </trans-unit>
        <trans-unit id="054ba7b0cd3f0b3aa1e4b17f975a52c4e03f8b87" translate="yes" xml:space="preserve">
          <source>Flip array in the left/right direction.</source>
          <target state="translated">Переверните массив в направлении влево/вправо.</target>
        </trans-unit>
        <trans-unit id="a71aa214a7a981c7e5292f4c8603043e9a55d042" translate="yes" xml:space="preserve">
          <source>Flip array in the up/down direction.</source>
          <target state="translated">Перевернуть массив в направлении вверх/вниз.</target>
        </trans-unit>
        <trans-unit id="d6b601389a5cfb7f115ef7332083ae3431e4e4e3" translate="yes" xml:space="preserve">
          <source>Flip the entries in each column in the up/down direction. Rows are preserved, but appear in a different order than before.</source>
          <target state="translated">Переверните записи в каждом столбце в направлении вверх/вниз.Строки сохраняются,но появляются в другом порядке,чем раньше.</target>
        </trans-unit>
        <trans-unit id="f14bb6de935d5a8cea7f1dc6e4323a38f4e11462" translate="yes" xml:space="preserve">
          <source>Flip the entries in each row in the left/right direction. Columns are preserved, but appear in a different order than before.</source>
          <target state="translated">Переверните записи в каждой строке влево/вправо.Столбцы сохраняются,но появляются в другом порядке,чем раньше.</target>
        </trans-unit>
        <trans-unit id="a806413f7b898c72fd5e92970c2a0a0a31830c28" translate="yes" xml:space="preserve">
          <source>Float printing now uses &amp;ldquo;dragon4&amp;rdquo; algorithm for shortest decimal representation</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a7d4f9efa22847d513f86cb336f4d917bb3ff00" translate="yes" xml:space="preserve">
          <source>Float type code to coerce input array &lt;code&gt;a&lt;/code&gt;. If &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt; is one of the &amp;lsquo;int&amp;rsquo; dtypes, it is replaced with float64.</source>
          <target state="translated">Код типа с плавающей запятой для приведения входного массива &lt;code&gt;a&lt;/code&gt; . Если &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt; является одним из dtypes 'int', он заменяется на float64.</target>
        </trans-unit>
        <trans-unit id="01625a6e71519a2c19afcda12e2e9da94df799dc" translate="yes" xml:space="preserve">
          <source>Floating functions</source>
          <target state="translated">Плавающие функции</target>
        </trans-unit>
        <trans-unit id="0c47a1b436ef0cc135c28b0dd8fa381311e23c7a" translate="yes" xml:space="preserve">
          <source>Floating point</source>
          <target state="translated">Плавающая запятая</target>
        </trans-unit>
        <trans-unit id="1229245ed91cf5c1f6662011b64e640e64679fd2" translate="yes" xml:space="preserve">
          <source>Floating point classification</source>
          <target state="translated">Классификация с плавающей запятой</target>
        </trans-unit>
        <trans-unit id="82951541de1b33acb443a62a7f1b908de9e19ba0" translate="yes" xml:space="preserve">
          <source>Floating point error handling</source>
          <target state="translated">Обработка ошибок с плавающей запятой</target>
        </trans-unit>
        <trans-unit id="dbe05d916add7aed11140c3ac753c505841f4681" translate="yes" xml:space="preserve">
          <source>Floating point number &lt;code&gt;beta**minexp&lt;/code&gt; (the smallest [in magnitude] usable floating value).</source>
          <target state="translated">Число с плавающей запятой &lt;code&gt;beta**minexp&lt;/code&gt; (наименьшее [по величине] используемое плавающее значение).</target>
        </trans-unit>
        <trans-unit id="1fd86bfd9f81a559ed8b4c9674c5d1f9e823b143" translate="yes" xml:space="preserve">
          <source>Floating point precision can be set:</source>
          <target state="translated">Точность с плавающей точкой может быть установлена:</target>
        </trans-unit>
        <trans-unit id="481d82b2ccb68e7d8e1fe5eda973bb77f53833f0" translate="yes" xml:space="preserve">
          <source>Floating point precision. Defaults to &lt;code&gt;numpy.get_printoptions()['precision']&lt;/code&gt;.</source>
          <target state="translated">Точность с плавающей запятой. По умолчанию &lt;code&gt;numpy.get_printoptions()['precision']&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6770ad9e8703a79e53fa3beb7d8e8f53215f921c" translate="yes" xml:space="preserve">
          <source>Floating point routines</source>
          <target state="translated">Программы с плавающей точкой</target>
        </trans-unit>
        <trans-unit id="a8d35036268d7e5fa8b38b4abd4d049aeafa51d6" translate="yes" xml:space="preserve">
          <source>Floating point scalars implement &lt;code&gt;as_integer_ratio&lt;/code&gt; to match the builtin float</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bbb20a81d8b5780d9de2483bc5cafd120d0cd965" translate="yes" xml:space="preserve">
          <source>Floating point values are not demoted to integers, and complex values are not demoted to floats.</source>
          <target state="translated">Значения с плавающей точкой не понижаются до целых чисел,а сложные значения не понижаются до плавающих.</target>
        </trans-unit>
        <trans-unit id="2a6aa48e3a6c80756547c7551fe79b07bb4f3a1c" translate="yes" xml:space="preserve">
          <source>Floating values between -1 and 1. This is a scalar if &lt;code&gt;x&lt;/code&gt; is a scalar.</source>
          <target state="translated">Плавающие значения от -1 до 1. Это скаляр, если &lt;code&gt;x&lt;/code&gt; - скаляр.</target>
        </trans-unit>
        <trans-unit id="e6f0281f3f5728d7cb1a3465fbf569e0196bf3cd" translate="yes" xml:space="preserve">
          <source>Floating-point number &lt;code&gt;beta**machep&lt;/code&gt; (floating point precision)</source>
          <target state="translated">Число с плавающей запятой &lt;code&gt;beta**machep&lt;/code&gt; (точность с плавающей запятой)</target>
        </trans-unit>
        <trans-unit id="f8899b4f72c4b482d21d27616c70625d6596dd90" translate="yes" xml:space="preserve">
          <source>Floating-point number &lt;code&gt;beta**negep&lt;/code&gt;.</source>
          <target state="translated">Число с плавающей запятой &lt;code&gt;beta**negep&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2eae9dc4dc291f4562016bea57ea67a7a3b1f88f" translate="yes" xml:space="preserve">
          <source>Floating-point numbers:</source>
          <target state="translated">Числа с плавающей точкой:</target>
        </trans-unit>
        <trans-unit id="55734ad7ec5ec7776c0a844d3df4e815b482074b" translate="yes" xml:space="preserve">
          <source>Floats uniformly distributed over &lt;code&gt;[0, 1)&lt;/code&gt;.</source>
          <target state="translated">Поплавки равномерно распределены на &lt;code&gt;[0, 1)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9c505c67e9b4dbb54495e1dc42c80f1a7a1c454f" translate="yes" xml:space="preserve">
          <source>Floor divide self by other in-place.</source>
          <target state="translated">Пол делится на другой на месте.</target>
        </trans-unit>
        <trans-unit id="1ddc7d58e45f89f16199c2075dcd43275a50c059" translate="yes" xml:space="preserve">
          <source>Floor division, &amp;lsquo;//&amp;rsquo;, is the division operator for the polynomial classes, polynomials are treated like integers in this regard. For Python versions &amp;lt; 3.x the &amp;lsquo;/&amp;rsquo; operator maps to &amp;lsquo;//&amp;rsquo;, as it does for Python, for later versions the &amp;lsquo;/&amp;rsquo; will only work for division by scalars. At some point it will be deprecated:</source>
          <target state="translated">Деление этажа, '//', является оператором деления для классов полиномов, в этом отношении полиномы рассматриваются как целые числа. Для версий Python &amp;lt;3.x оператор '/' отображается на '//', как и для Python, для более поздних версий '/' будет работать только для деления на скаляры. В какой-то момент он станет устаревшим:</target>
        </trans-unit>
        <trans-unit id="977e7ae24b1ce53baf0769e85a5d553c0c1ba1a9" translate="yes" xml:space="preserve">
          <source>Following each integration the result is &lt;em&gt;multiplied&lt;/em&gt; by &lt;code&gt;scl&lt;/code&gt; before the integration constant is added. (Default: 1)</source>
          <target state="translated">После каждого интегрирования результат &lt;em&gt;умножается&lt;/em&gt; на &lt;code&gt;scl&lt;/code&gt; перед добавлением константы интегрирования. (По умолчанию: 1)</target>
        </trans-unit>
        <trans-unit id="0edda5efdca0ba777ab89777b73ae8abb0ac8170" translate="yes" xml:space="preserve">
          <source>Following the header comes the array data. If the dtype contains Python objects (i.e. &lt;code&gt;dtype.hasobject is True&lt;/code&gt;), then the data is a Python pickle of the array. Otherwise the data is the contiguous (either C- or Fortran-, depending on &lt;code&gt;fortran_order&lt;/code&gt;) bytes of the array. Consumers can figure out the number of bytes by multiplying the number of elements given by the shape (noting that &lt;code&gt;shape=()&lt;/code&gt; means there is 1 element) by &lt;code&gt;dtype.itemsize&lt;/code&gt;.</source>
          <target state="translated">После заголовка идет массив данных. Если dtype содержит объекты Python (т. &lt;code&gt;dtype.hasobject is True&lt;/code&gt; ), то данные представляют собой расслоение массива Python. В противном случае данные представляют собой непрерывные (либо C-, либо Fortran-, в зависимости от &lt;code&gt;fortran_order&lt;/code&gt; ) байты массива. Потребители могут вычислить количество байтов, умножив количество элементов, заданных формой (учитывая, что &lt;code&gt;shape=()&lt;/code&gt; означает, что существует 1 элемент) на &lt;code&gt;dtype.itemsize&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ec0c3b76630fd745381cc215a284820af75a683a" translate="yes" xml:space="preserve">
          <source>Footnotes</source>
          <target state="translated">Footnotes</target>
        </trans-unit>
        <trans-unit id="1e3737ce90be5e40d3542337b2a16d0ddfea15fe" translate="yes" xml:space="preserve">
          <source>For 18 of the 21 types this number is fixed by the data-type. For the flexible data-types, this number can be anything.</source>
          <target state="translated">Для 18 из 21 типа это число фиксируется типом данных.Для гибких типов данных это число может быть любым.</target>
        </trans-unit>
        <trans-unit id="6fe31cdcb6c6646809088d5903655d52a55d450e" translate="yes" xml:space="preserve">
          <source>For 2-D arrays it is the matrix product:</source>
          <target state="translated">Для 2-D массивов это матричный продукт:</target>
        </trans-unit>
        <trans-unit id="3f962aedbf83ef9d65d44b9e69490919cc79f9a0" translate="yes" xml:space="preserve">
          <source>For 2-D mixed with 1-D, the result is the usual.</source>
          <target state="translated">Для 2-D,смешанных с 1-D,результат будет обычным.</target>
        </trans-unit>
        <trans-unit id="249d7389fa64403ab6c1fc03103e6db107907e49" translate="yes" xml:space="preserve">
          <source>For 8-bit strings, this method is locale-dependent.</source>
          <target state="translated">Для 8-битных строк этот метод является локально зависимым.</target>
        </trans-unit>
        <trans-unit id="e34d3054bfe352b99ce08082d1411334b317ca53" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt; one-dimensional, this is equivalent to:</source>
          <target state="translated">Для одномерных &lt;code&gt;A&lt;/code&gt; и &lt;code&gt;B&lt;/code&gt; это эквивалентно:</target>
        </trans-unit>
        <trans-unit id="a6fa074fdf944e6525f90fb53e3868628cc3a171" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;a.view(some_dtype)&lt;/code&gt;, if &lt;code&gt;some_dtype&lt;/code&gt; has a different number of bytes per entry than the previous dtype (for example, converting a regular array to a structured array), then the behavior of the view cannot be predicted just from the superficial appearance of &lt;code&gt;a&lt;/code&gt; (shown by &lt;code&gt;print(a)&lt;/code&gt;). It also depends on exactly how &lt;code&gt;a&lt;/code&gt; is stored in memory. Therefore if &lt;code&gt;a&lt;/code&gt; is C-ordered versus fortran-ordered, versus defined as a slice or transpose, etc., the view may give different results.</source>
          <target state="translated">Для &lt;code&gt;a.view(some_dtype)&lt;/code&gt; , если &lt;code&gt;some_dtype&lt;/code&gt; имеет другое количество байтов на запись, чем предыдущий dtype (например, преобразование обычного массива в структурированный массив), то поведение представления не может быть предсказано только по внешнему виду of &lt;code&gt;a&lt;/code&gt; (показано &lt;code&gt;print(a)&lt;/code&gt; ). Это также зависит от того, как именно хранится в памяти. Поэтому, если &lt;code&gt;a&lt;/code&gt; является C-упорядоченным по сравнению с упорядоченным по формуле, по сравнению с определением как срез или транспонирование и т. Д., Представление может давать разные результаты. &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e46f2d6f5fe5e7ec999c5f95aef2596fb69e222c" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;array&lt;/code&gt;, &lt;strong&gt;``*`` means element-wise multiplication&lt;/strong&gt;, while &lt;strong&gt;``@`` means matrix multiplication&lt;/strong&gt;; they have associated functions &lt;code&gt;multiply()&lt;/code&gt; and &lt;code&gt;dot()&lt;/code&gt;. (Before python 3.5, &lt;code&gt;@&lt;/code&gt; did not exist and one had to use &lt;code&gt;dot()&lt;/code&gt; for matrix multiplication).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3105b82282a4b74064eec805ba7d2c290a53d304" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;array&lt;/code&gt;, the &lt;strong&gt;vector shapes 1xN, Nx1, and N are all different things&lt;/strong&gt;. Operations like &lt;code&gt;A[:,1]&lt;/code&gt; return a one-dimensional array of shape N, not a two-dimensional array of shape Nx1. Transpose on a one-dimensional &lt;code&gt;array&lt;/code&gt; does nothing.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="272593adff1434bde1d4cd33b0346e0c6d20e042" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;e, E&lt;/code&gt; and &lt;code&gt;f&lt;/code&gt; specifiers, the number of digits to print after the decimal point.</source>
          <target state="translated">Для спецификаторов &lt;code&gt;e, E&lt;/code&gt; и &lt;code&gt;f&lt;/code&gt; - количество печатаемых цифр после десятичной точки.</target>
        </trans-unit>
        <trans-unit id="a8b87fa4bee96c31297a2faf4474562d50259437" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;g&lt;/code&gt; and &lt;code&gt;G&lt;/code&gt;, the maximum number of significant digits.</source>
          <target state="translated">Для &lt;code&gt;g&lt;/code&gt; и &lt;code&gt;G&lt;/code&gt; максимальное количество значащих цифр.</target>
        </trans-unit>
        <trans-unit id="d98628f7394ff0daa3811e58311c01f9a29ca826" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;matrix&lt;/code&gt;, &lt;strong&gt;``*`` means matrix multiplication&lt;/strong&gt;, and for element-wise multiplication one has to use the &lt;code&gt;multiply()&lt;/code&gt; function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="637ce924b991228068be8a9a9fc01722cca48f39" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;matrix&lt;/code&gt;, &lt;strong&gt;one-dimensional arrays are always upconverted to 1xN or Nx1 matrices&lt;/strong&gt; (row or column vectors). &lt;code&gt;A[:,1]&lt;/code&gt; returns a two-dimensional matrix of shape Nx1.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f16f572df2de5dbe71ab6b482a26aade3788153" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;s&lt;/code&gt;, the maximum number of characters.</source>
          <target state="translated">Для &lt;code&gt;s&lt;/code&gt; максимальное количество символов.</target>
        </trans-unit>
        <trans-unit id="99d20f637f3a6e1d55b90d0390d938da13e44f35" translate="yes" xml:space="preserve">
          <source>For C code, see the &lt;a href=&quot;style_guide#style-guide&quot;&gt;numpy-c-style-guide&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="96de2b474663e4b27c100d387c234e173e9360ba" translate="yes" xml:space="preserve">
          <source>For NumPy &amp;gt;= 1.10.0 a view of &lt;code&gt;a&lt;/code&gt; is always returned. For earlier NumPy versions a view of &lt;code&gt;a&lt;/code&gt; is returned only if the order of the axes is changed, otherwise the input array is returned.</source>
          <target state="translated">Для NumPy&amp;gt; = 1.10.0 вид всегда возвращается. Для более ранних версий NumPy представление &lt;code&gt;a&lt;/code&gt; возвращается только при изменении порядка осей, в противном случае возвращается входной массив. &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="187181bc029dad6f61070b7f6592eecd79b97aa5" translate="yes" xml:space="preserve">
          <source>For NumPy &amp;gt;= 1.10.0, if &lt;code&gt;a&lt;/code&gt; is an ndarray, then a view of &lt;code&gt;a&lt;/code&gt; is returned; otherwise a new array is created. For earlier NumPy versions a view of &lt;code&gt;a&lt;/code&gt; is returned only if the order of the axes is changed, otherwise the input array is returned.</source>
          <target state="translated">Для NumPy&amp;gt; = 1.10.0, если &lt;code&gt;a&lt;/code&gt; является ndarray, то возвращается представление &lt;code&gt;a&lt;/code&gt; ; в противном случае создается новый массив. Для более ранних версий NumPy представление &lt;code&gt;a&lt;/code&gt; возвращается только при изменении порядка осей, в противном случае возвращается входной массив.</target>
        </trans-unit>
        <trans-unit id="54f70af9beed617bc137c199798e6f21c9093a8c" translate="yes" xml:space="preserve">
          <source>For Python, the preferred way of handling contiguous (or technically, &lt;em&gt;strided&lt;/em&gt;) blocks of homogeneous data is with NumPy, which provides full object-oriented access to multidimensial arrays of data. Therefore, the most logical Python interface for the &lt;code&gt;rms&lt;/code&gt; function would be (including doc string):</source>
          <target state="translated">Для Python предпочтительным способом обработки смежных (или технически &lt;em&gt;разделенных&lt;/em&gt; ) блоков однородных данных является NumPy, который обеспечивает полный объектно-ориентированный доступ к многомерным массивам данных. Следовательно, наиболее логичным интерфейсом Python для функции &lt;code&gt;rms&lt;/code&gt; будет (включая строку документа):</target>
        </trans-unit>
        <trans-unit id="55f9e5f045d92376c7d38dda0f2622f9b6352be6" translate="yes" xml:space="preserve">
          <source>For a 1-D array this has no effect, as a transposed vector is simply the same vector. To convert a 1-D array into a 2D column vector, an additional dimension must be added. &lt;code&gt;np.atleast2d(a).T&lt;/code&gt; achieves this, as does &lt;code&gt;a[:, np.newaxis]&lt;/code&gt;. For a 2-D array, this is a standard matrix transpose. For an n-D array, if axes are given, their order indicates how the axes are permuted (see Examples). If axes are not provided and &lt;code&gt;a.shape = (i[0], i[1], ... i[n-2], i[n-1])&lt;/code&gt;, then &lt;code&gt;a.transpose().shape = (i[n-1], i[n-2], ... i[1], i[0])&lt;/code&gt;.</source>
          <target state="translated">Для одномерного массива это не имеет никакого эффекта, поскольку транспонированный вектор - это просто тот же вектор. Чтобы преобразовать одномерный массив в двухмерный вектор-столбец, необходимо добавить дополнительное измерение. &lt;code&gt;np.atleast2d(a).T&lt;/code&gt; достигает этого, как и &lt;code&gt;a[:, np.newaxis]&lt;/code&gt; . Для двумерного массива это стандартное транспонирование матрицы. Для массива nD, если указаны оси, их порядок указывает, как оси переставляются (см. Примеры). Если оси не &lt;code&gt;a.shape = (i[0], i[1], ... i[n-2], i[n-1])&lt;/code&gt; и a.shape = (i [0], i [1], ... i [n-2], i [n-1]) , то &lt;code&gt;a.transpose().shape = (i[n-1], i[n-2], ... i[1], i[0])&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9c37103fe1630ecb51bfbc7a903129e1d60dd7ed" translate="yes" xml:space="preserve">
          <source>For a 1D array, &lt;code&gt;a.tolist()&lt;/code&gt; is almost the same as &lt;code&gt;list(a)&lt;/code&gt;, except that &lt;code&gt;tolist&lt;/code&gt; changes numpy scalars to Python scalars:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d3f2a60e0b01b84231d8024aebcc5e084e0ba27d" translate="yes" xml:space="preserve">
          <source>For a 1D array, &lt;code&gt;a.tolist()&lt;/code&gt; is almost the same as &lt;code&gt;list(a)&lt;/code&gt;:</source>
          <target state="translated">Для одномерного массива &lt;code&gt;a.tolist()&lt;/code&gt; почти то же самое, что &lt;code&gt;list(a)&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="cf0f7c81098fcc87863f3be5d59395a987825914" translate="yes" xml:space="preserve">
          <source>For a complete discussion of creation methods for masked arrays please see section &lt;a href=&quot;#maskedarray-generic-constructing&quot;&gt;Constructing masked arrays&lt;/a&gt;.</source>
          <target state="translated">Полное обсуждение методов создания маскированных массивов см. В разделе &amp;laquo; &lt;a href=&quot;#maskedarray-generic-constructing&quot;&gt;Создание маскированных массивов&amp;raquo;&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0bdfc3356f177e5d7773cb796069c781e6c3ff20" translate="yes" xml:space="preserve">
          <source>For a description of the &lt;code&gt;.npy&lt;/code&gt; format, see &lt;a href=&quot;numpy.lib.format#module-numpy.lib.format&quot;&gt;&lt;code&gt;numpy.lib.format&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Для описания &lt;code&gt;.npy&lt;/code&gt; формата см &lt;a href=&quot;numpy.lib.format#module-numpy.lib.format&quot;&gt; &lt;code&gt;numpy.lib.format&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="197692467968599b779c0574e1302cadc5d30a4f" translate="yes" xml:space="preserve">
          <source>For a full description of these options, see &lt;a href=&quot;numpy.set_printoptions#numpy.set_printoptions&quot;&gt;&lt;code&gt;set_printoptions&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Полное описание этих параметров см . В разделе &lt;a href=&quot;numpy.set_printoptions#numpy.set_printoptions&quot;&gt; &lt;code&gt;set_printoptions&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b040ed436e354a6dfab8e28023d68c6eed7a06c2" translate="yes" xml:space="preserve">
          <source>For a function that returns a 1D array, the number of dimensions in &lt;code&gt;outarr&lt;/code&gt; is the same as &lt;code&gt;arr&lt;/code&gt;.</source>
          <target state="translated">Для функции, возвращающей одномерный массив, количество измерений в &lt;code&gt;outarr&lt;/code&gt; такое же, как и в &lt;code&gt;arr&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9409ae5300d15907687b38139959611e06963f16" translate="yes" xml:space="preserve">
          <source>For a function that returns a higher dimensional array, those dimensions are inserted in place of the &lt;code&gt;axis&lt;/code&gt; dimension.</source>
          <target state="translated">Для функции, которая возвращает массив более высоких измерений, эти измерения вставляются вместо измерения &lt;code&gt;axis&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="17b694669442e700bd635063d9a03b4ef4365eec" translate="yes" xml:space="preserve">
          <source>For a more detailed discussion, read on and follow the links at the bottom of this page.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7adc015d596be980abdfb7f52ddd54b20d9ed4e4" translate="yes" xml:space="preserve">
          <source>For a multi-dimensional array, accumulate is applied along only one axis (axis zero by default; see Examples below) so repeated use is necessary if one wants to accumulate over multiple axes.</source>
          <target state="translated">Для многомерного массива накопление применяется только по одной оси (по умолчанию нулевая ось;см.примеры ниже),поэтому повторное использование необходимо,если необходимо накопление по нескольким осям.</target>
        </trans-unit>
        <trans-unit id="4a70a58adc76a39cce5a267ab70438cf75b9572e" translate="yes" xml:space="preserve">
          <source>For a non-trivial signature, &lt;code&gt;dimensions&lt;/code&gt; will also contain the sizes of the core dimensions as well, starting at the second entry. Only one size is provided for each unique dimension name and the sizes are given according to the first occurrence of a dimension name in the signature.</source>
          <target state="translated">Для нетривиальной подписи &lt;code&gt;dimensions&lt;/code&gt; также будут содержать размеры основных размеров, начиная со второй записи. Для каждого уникального имени измерения предоставляется только один размер, и размеры даются в соответствии с первым появлением имени измерения в подписи.</target>
        </trans-unit>
        <trans-unit id="8218bd5d7a6649aa63226e5b622d4b8efad4dc34" translate="yes" xml:space="preserve">
          <source>For a one-dimensional array, accumulate produces results equivalent to:</source>
          <target state="translated">Для одномерного массива накопление дает результаты,эквивалентные:</target>
        </trans-unit>
        <trans-unit id="0424b9224931152a35a50c93d8cc0ece880de71a" translate="yes" xml:space="preserve">
          <source>For a one-sided t-test, how far out in the distribution does the t statistic appear?</source>
          <target state="translated">Для одностороннего t-теста,насколько далеко в распределении появляется t-статистика?</target>
        </trans-unit>
        <trans-unit id="3911c3b2407712ae47f85ee3fb1ac557138ff00b" translate="yes" xml:space="preserve">
          <source>For a possible future loop selector with a different signature.</source>
          <target state="translated">Для возможного будущего селектора циклов с другой сигнатурой.</target>
        </trans-unit>
        <trans-unit id="c991a419f14da45f93fac679b2b79a552dc6a583" translate="yes" xml:space="preserve">
          <source>For a simple example, consider taking the sum of all elements in an array.</source>
          <target state="translated">В качестве простого примера рассмотрим взятие суммы всех элементов в массиве.</target>
        </trans-unit>
        <trans-unit id="65b58d63b284139c1918d1c4f188a0cdc07b3bf2" translate="yes" xml:space="preserve">
          <source>For advanced assignments, there is in general no guarantee for the iteration order. This means that if an element is set more than once, it is not possible to predict the final result.</source>
          <target state="translated">При выполнении расширенных заданий,как правило,нет гарантии на порядок итераций.Это означает,что если элемент задан более одного раза,невозможно предсказать конечный результат.</target>
        </trans-unit>
        <trans-unit id="d08105fb315fdfa97977e494fc0f07ee6275d676" translate="yes" xml:space="preserve">
          <source>For all of these macros &lt;em&gt;arr&lt;/em&gt; must be an instance of a (subclass of) &lt;a href=&quot;c-api.types-and-structures#c.PyArray_Type&quot;&gt;&lt;code&gt;PyArray_Type&lt;/code&gt;&lt;/a&gt;, but no checking is done.</source>
          <target state="translated">Для всех этих макросов &lt;em&gt;arr&lt;/em&gt; должен быть экземпляром (подклассом) &lt;a href=&quot;c-api.types-and-structures#c.PyArray_Type&quot;&gt; &lt;code&gt;PyArray_Type&lt;/code&gt; &lt;/a&gt; , но проверка не выполняется.</target>
        </trans-unit>
        <trans-unit id="e1f0a94de943c1efcc57e0ced39bb6353a416723" translate="yes" xml:space="preserve">
          <source>For all of these macros &lt;em&gt;arr&lt;/em&gt; must be an instance of a (subclass of) &lt;a href=&quot;types-and-structures#c.PyArray_Type&quot;&gt;&lt;code&gt;PyArray_Type&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="24c98e7efdd0450f6d403ff7e88bf2f5b1a932b5" translate="yes" xml:space="preserve">
          <source>For all-NaN slices or slices with zero degrees of freedom, NaN is returned and a &lt;code&gt;RuntimeWarning&lt;/code&gt; is raised.</source>
          <target state="translated">Для срезов, содержащих все NaN, или срезов с нулевыми степенями свободы, возвращается NaN и возникает &lt;code&gt;RuntimeWarning&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b523336c8d394d1599c127fd9600cfe28ac8e406" translate="yes" xml:space="preserve">
          <source>For all-NaN slices, NaN is returned and a &lt;code&gt;RuntimeWarning&lt;/code&gt; is raised.</source>
          <target state="translated">Для срезов, &lt;code&gt;RuntimeWarning&lt;/code&gt; NaN, возвращается NaN и возникает RuntimeWarning .</target>
        </trans-unit>
        <trans-unit id="cdcb9c3fa272c68c7dc5e676247f2291a44c1673" translate="yes" xml:space="preserve">
          <source>For an accompanying example, see &lt;a href=&quot;#example&quot;&gt;example.py&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f544bc19358af783f5828a5e5053cd2cf057f05c" translate="yes" xml:space="preserve">
          <source>For an array &lt;code&gt;a&lt;/code&gt; with &lt;code&gt;a.ndim &amp;gt;= 2&lt;/code&gt;, the diagonal is the list of locations with indices &lt;code&gt;a[i, ..., i]&lt;/code&gt; all identical. This function modifies the input array in-place, it does not return a value.</source>
          <target state="translated">Для массива &lt;code&gt;a&lt;/code&gt; с &lt;code&gt;a.ndim &amp;gt;= 2&lt;/code&gt; диагональ - это список местоположений с одинаковыми индексами &lt;code&gt;a[i, ..., i]&lt;/code&gt; . Эта функция изменяет входной массив на месте, она не возвращает значение.</target>
        </trans-unit>
        <trans-unit id="3aca4d8fb9611bde95449f6380639b52b005e231" translate="yes" xml:space="preserve">
          <source>For an array a with two axes, transpose(a) gives the matrix transpose.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="836b756b5d814f029c077f0578ba6c0e58a3c672" translate="yes" xml:space="preserve">
          <source>For an array with rank greater than 1, some of the padding of later axes is calculated from padding of previous axes. This is easiest to think about with a rank 2 array where the corners of the padded array are calculated by using padded values from the first axis.</source>
          <target state="translated">Для массива,имеющего ранг больше 1,часть набивки более поздних осей вычисляется из набивки предыдущих осей.Об этом легче всего думать при использовании массива 2-го ранга,в котором углы массива с подкладкой рассчитываются с помощью значений подкладки от первой оси.</target>
        </trans-unit>
        <trans-unit id="6e96c6b0d98bc68cbd820a41e54b4b8abe37a921" translate="yes" xml:space="preserve">
          <source>For an even number of input points, &lt;code&gt;A[n//2]&lt;/code&gt; represents the sum of the values at the positive and negative Nyquist frequencies, as the two are aliased together. See &lt;a href=&quot;../routines.fft#module-numpy.fft&quot;&gt;&lt;code&gt;numpy.fft&lt;/code&gt;&lt;/a&gt; for details.</source>
          <target state="translated">Для четного числа входных точек &lt;code&gt;A[n//2]&lt;/code&gt; представляет собой сумму значений на положительной и отрицательной частотах Найквиста, так как они накладываются друг на друга. См. &lt;a href=&quot;../routines.fft#module-numpy.fft&quot;&gt; &lt;code&gt;numpy.fft&lt;/code&gt; &lt;/a&gt; для подробностей.</target>
        </trans-unit>
        <trans-unit id="57743d92673c43f581b946774bebcebd154a8f73" translate="yes" xml:space="preserve">
          <source>For an example, see &lt;a href=&quot;numpy.lib.arrayterator#numpy.lib.Arrayterator&quot;&gt;&lt;code&gt;Arrayterator&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Для примера см. &lt;a href=&quot;numpy.lib.arrayterator#numpy.lib.Arrayterator&quot;&gt; &lt;code&gt;Arrayterator&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8c782854d522cc47b6ef0aa24c79c91b4278be4a" translate="yes" xml:space="preserve">
          <source>For an optional array argument, all its dimensions must be bounded.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6fe48c8702effa07c62fb464257e567d9ddc8002" translate="yes" xml:space="preserve">
          <source>For any index combination, including slicing and axis insertion, &lt;code&gt;a[indices]&lt;/code&gt; is the same as &lt;code&gt;a[np.index_exp[indices]]&lt;/code&gt; for any array &lt;code&gt;a&lt;/code&gt;. However, &lt;code&gt;np.index_exp[indices]&lt;/code&gt; can be used anywhere in Python code and returns a tuple of slice objects that can be used in the construction of complex index expressions.</source>
          <target state="translated">Для любой комбинации индексов, включая нарезку и вставку оси, &lt;code&gt;a[indices]&lt;/code&gt; index ] совпадает с &lt;code&gt;a[np.index_exp[indices]]&lt;/code&gt; для любого массива &lt;code&gt;a&lt;/code&gt; . Однако &lt;code&gt;np.index_exp[indices]&lt;/code&gt; может использоваться где угодно в коде Python и возвращает кортеж объектов-срезов, которые можно использовать при построении сложных индексных выражений.</target>
        </trans-unit>
        <trans-unit id="befc2c9b3e9174a0e95946cae12589b779a18421" translate="yes" xml:space="preserve">
          <source>For array methods that take an &lt;code&gt;axis&lt;/code&gt; keyword, it defaults to None. If axis is None, then the array is treated as a 1-D array. Any other value for &lt;code&gt;axis&lt;/code&gt; represents the dimension along which the operation should proceed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec5bdb26c08f7af1b31abb9fd2aadbeeef092f4f" translate="yes" xml:space="preserve">
          <source>For array methods that take an &lt;em&gt;axis&lt;/em&gt; keyword, it defaults to &lt;code&gt;None&lt;/code&gt;. If axis is &lt;em&gt;None&lt;/em&gt;, then the array is treated as a 1-D array. Any other value for &lt;em&gt;axis&lt;/em&gt; represents the dimension along which the operation should proceed.</source>
          <target state="translated">Для методов массива, которые принимают ключевое слово &lt;em&gt;оси&lt;/em&gt; , по умолчанию используется значение &lt;code&gt;None&lt;/code&gt; . Если ось &lt;em&gt;None&lt;/em&gt; , то массив рассматривается как одномерный массив. Любое другое значение &lt;em&gt;оси&lt;/em&gt; представляет размер, по которому должна продолжаться операция.</target>
        </trans-unit>
        <trans-unit id="d57067c37de796c57ab86aba446833670680acd2" translate="yes" xml:space="preserve">
          <source>For array methods that take an &lt;em&gt;axis&lt;/em&gt; keyword, it defaults to &lt;em&gt;None&lt;/em&gt;. If axis is &lt;em&gt;None&lt;/em&gt;, then the array is treated as a 1-D array. Any other value for &lt;em&gt;axis&lt;/em&gt; represents the dimension along which the operation should proceed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dcba10981a70013794c3901be17ecdedebc27a1a" translate="yes" xml:space="preserve">
          <source>For backward compatibility and as a standard &amp;ldquo;container &amp;ldquo;class, the UserArray from Numeric has been brought over to NumPy and named &lt;a href=&quot;generated/numpy.lib.user_array.container#numpy.lib.user_array.container&quot;&gt;&lt;code&gt;numpy.lib.user_array.container&lt;/code&gt;&lt;/a&gt; The container class is a Python class whose self.array attribute is an ndarray. Multiple inheritance is probably easier with numpy.lib.user_array.container than with the ndarray itself and so it is included by default. It is not documented here beyond mentioning its existence because you are encouraged to use the ndarray class directly if you can.</source>
          <target state="translated">Для обратной совместимости и в качестве стандартного &amp;laquo;контейнерного&amp;raquo; класса UserArray из Numeric был перенесен в NumPy и назван &lt;a href=&quot;generated/numpy.lib.user_array.container#numpy.lib.user_array.container&quot;&gt; &lt;code&gt;numpy.lib.user_array.container&lt;/code&gt; &lt;/a&gt; . Контейнерный класс - это класс Python, атрибут self.array которого является ndarray. Множественное наследование, вероятно, проще с numpy.lib.user_array.container, чем с самим ndarray, поэтому он включен по умолчанию. Здесь он не документируется, кроме упоминания о его существовании, потому что вам рекомендуется использовать класс ndarray напрямую, если вы можете.</target>
        </trans-unit>
        <trans-unit id="1756e23a025872fd532e8ba6c08bb9a4085acd5e" translate="yes" xml:space="preserve">
          <source>For backward compatibility with Python 2 the &lt;code&gt;S&lt;/code&gt; and &lt;code&gt;a&lt;/code&gt; typestrings remain zero-terminated bytes and &lt;code&gt;np.string_&lt;/code&gt; continues to map to &lt;code&gt;np.bytes_&lt;/code&gt;. To use actual strings in Python 3 use &lt;code&gt;U&lt;/code&gt; or &lt;code&gt;np.unicode_&lt;/code&gt;. For signed bytes that do not need zero-termination &lt;code&gt;b&lt;/code&gt; or &lt;code&gt;i1&lt;/code&gt; can be used.</source>
          <target state="translated">Для обратной совместимости с Python 2 строки &lt;code&gt;S&lt;/code&gt; и &lt;code&gt;a&lt;/code&gt; остаются завершающимися байтами, а &lt;code&gt;np.string_&lt;/code&gt; продолжает отображаться на &lt;code&gt;np.bytes_&lt;/code&gt; . Чтобы использовать фактические строки в Python 3, используйте &lt;code&gt;U&lt;/code&gt; или &lt;code&gt;np.unicode_&lt;/code&gt; . Для подписанных байтов, которые не нуждаются в завершении нуля, можно использовать &lt;code&gt;b&lt;/code&gt; или &lt;code&gt;i1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2f4c86851229c177d560fbdf1b8fb4dd2c3ff306" translate="yes" xml:space="preserve">
          <source>For backward compatible legacy reasons, we cannot change this. See &lt;code&gt;random-quick-start&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c77dfb74768b5914a720e322bd9c4f4d3188beb4" translate="yes" xml:space="preserve">
          <source>For backwards compatibility, datetime64 still parses timezone offsets, which it handles by converting to UTC. However, the resulting datetime is timezone naive:</source>
          <target state="translated">Для обратной совместимости datetime64 по-прежнему анализирует смещения часового пояса,которые он обрабатывает путем преобразования в UTC.Тем не менее,полученное в результате время является наивным часовым поясом:</target>
        </trans-unit>
        <trans-unit id="1c64f15e60882d9539499a036901b91bc24bc19f" translate="yes" xml:space="preserve">
          <source>For backwards compatibility, the form (str, array of 624 uints, int) is also accepted although it is missing some information about the cached Gaussian value: &lt;code&gt;state = ('MT19937', keys, pos)&lt;/code&gt;.</source>
          <target state="translated">Для обратной совместимости форма (str, array of 624 uints, int) также принимается, хотя в ней отсутствует некоторая информация о кэшированном гауссовском значении: &lt;code&gt;state = ('MT19937', keys, pos)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4eb2208bc27c7545536cb93635c9264ced09a6ad" translate="yes" xml:space="preserve">
          <source>For bandlimited interpolation of discrete-time signals, the ideal interpolation kernel is proportional to the sinc function.</source>
          <target state="translated">Для интерполяции дискретных сигналов в диапазоне времени идеальное интерполяционное ядро пропорционально функции sinc.</target>
        </trans-unit>
        <trans-unit id="0640d05a7ef317b56adcd70bde409c84daf4b12d" translate="yes" xml:space="preserve">
          <source>For buffered loops, care must be taken to copy and cast data before the loop function is called because the underlying loop expects aligned data of the correct data-type (including byte-order). The buffered loop must handle this copying and casting prior to calling the loop function on chunks no greater than the user-specified bufsize.</source>
          <target state="translated">Для буферизованных циклов необходимо позаботиться о копировании и приведении в соответствие данных до вызова функции цикла,так как базовый цикл ожидает выравнивания данных правильного типа (включая порядок байт).Буферизованный цикл должен обрабатывать это копирование и приведение в соответствие перед вызовом функции цикла на кусочках не больше,чем указанная пользователем bufsize.</target>
        </trans-unit>
        <trans-unit id="cb4713bd95be47f513cc79d1a6764009b9a70f10" translate="yes" xml:space="preserve">
          <source>For building NumPy, you&amp;rsquo;ll need a recent version of Cython.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="78ea569e34a0a0f36b8d0d5224e34f847b3cf085" translate="yes" xml:space="preserve">
          <source>For clarity it is useful to provide some examples of the type description and corresponding &lt;a href=&quot;#__array_interface__&quot;&gt;&lt;code&gt;__array_interface__&lt;/code&gt;&lt;/a&gt; &amp;lsquo;descr&amp;rsquo; entries. Thanks to Scott Gilbert for these examples:</source>
          <target state="translated">Для ясности полезно предоставить несколько примеров описания типа и соответствующих &lt;a href=&quot;#__array_interface__&quot;&gt; &lt;code&gt;__array_interface__&lt;/code&gt; &lt;/a&gt; 'descr'. Спасибо Скотту Гилберту за эти примеры:</target>
        </trans-unit>
        <trans-unit id="cf57e9a465ef336bb9e191a7bcc71c622dd7e36c" translate="yes" xml:space="preserve">
          <source>For clearly intentional breaches, report those to the Code of Conduct committee (see below). For possibly unintentional breaches, you may reply to the person and point out this code of conduct (either in public or in private, whatever is most appropriate). If you would prefer not to do that, please feel free to report to the Code of Conduct Committee directly, or ask the Committee for advice, in confidence.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f79e4e860ac02f7665b97a2330e074b2889f9891" translate="yes" xml:space="preserve">
          <source>For comparison and general edification of the reader we provide a simple implementation of a C extension of logit that uses no numpy.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="90d52548b7d82f8c08562b9cefe270c672ec6067" translate="yes" xml:space="preserve">
          <source>For comparison with the other methods to be discussed. Here is another example of a function that filters a two-dimensional array of double precision floating-point numbers using a fixed averaging filter. The advantage of using Fortran to index into multi-dimensional arrays should be clear from this example.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aefcdcec95bb0a9f49c3ea43d81c147b480f4a1a" translate="yes" xml:space="preserve">
          <source>For complete documentation of the types of floating-point exceptions and treatment options, see &lt;a href=&quot;numpy.seterr#numpy.seterr&quot;&gt;&lt;code&gt;seterr&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Полную документацию о типах исключений с плавающей запятой и вариантах обработки см. В &lt;a href=&quot;numpy.seterr#numpy.seterr&quot;&gt; &lt;code&gt;seterr&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f6638e7aa649639c70b61a262d3fcb528e530dcc" translate="yes" xml:space="preserve">
          <source>For completeness, we&amp;rsquo;ll also add the &amp;lsquo;external_loop&amp;rsquo; and &amp;lsquo;buffered&amp;rsquo; flags, as these are what you will typically want for performance reasons.</source>
          <target state="translated">Для полноты картины мы также добавим флаги external_loop и buffered, так как это то, что вам обычно нужно по соображениям производительности.</target>
        </trans-unit>
        <trans-unit id="823eefe35591ae1ef0928dcf4115410e8d28b81a" translate="yes" xml:space="preserve">
          <source>For complex arguments, &lt;code&gt;x = a + ib&lt;/code&gt;, we can write</source>
          <target state="translated">Для сложных аргументов, &lt;code&gt;x = a + ib&lt;/code&gt; , мы можем написать</target>
        </trans-unit>
        <trans-unit id="00d19b01697a76f9042f9abe787cb066622b4409" translate="yes" xml:space="preserve">
          <source>For complex dtypes, the above is applied to each of the real and imaginary components of &lt;code&gt;x&lt;/code&gt; separately.</source>
          <target state="translated">Для сложных типов dtypes вышеупомянутое применяется к каждой из действительных и мнимых компонентов &lt;code&gt;x&lt;/code&gt; отдельно.</target>
        </trans-unit>
        <trans-unit id="7aabc240767fa8c38770aded9994dbfb9309fc85" translate="yes" xml:space="preserve">
          <source>For complex inputs, the &lt;a href=&quot;#numpy.sign&quot;&gt;&lt;code&gt;sign&lt;/code&gt;&lt;/a&gt; function returns &lt;code&gt;sign(x.real) + 0j if x.real != 0 else sign(x.imag) + 0j&lt;/code&gt;.</source>
          <target state="translated">Для сложных входных данных функция &lt;a href=&quot;#numpy.sign&quot;&gt; &lt;code&gt;sign&lt;/code&gt; &lt;/a&gt; возвращает &lt;code&gt;sign(x.real) + 0j if x.real != 0 else sign(x.imag) + 0j&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="37a57514466afa09fc7538317ff0a405ada2d56e" translate="yes" xml:space="preserve">
          <source>For complex-valued input, &lt;a href=&quot;#numpy.arccos&quot;&gt;&lt;code&gt;arccos&lt;/code&gt;&lt;/a&gt; is a complex analytic function that has branch cuts &lt;code&gt;[-inf, -1]&lt;/code&gt; and &lt;code&gt;[1, inf]&lt;/code&gt; and is continuous from above on the former and from below on the latter.</source>
          <target state="translated">Для комплексных входных данных &lt;a href=&quot;#numpy.arccos&quot;&gt; &lt;code&gt;arccos&lt;/code&gt; &lt;/a&gt; - это комплексная аналитическая функция, которая имеет разрезы ветвей &lt;code&gt;[-inf, -1]&lt;/code&gt; и &lt;code&gt;[1, inf]&lt;/code&gt; и является непрерывной сверху для первого и снизу для второго.</target>
        </trans-unit>
        <trans-unit id="ff44215d073bf2342406439d430f9b3eb5cc308c" translate="yes" xml:space="preserve">
          <source>For complex-valued input, &lt;a href=&quot;#numpy.arccosh&quot;&gt;&lt;code&gt;arccosh&lt;/code&gt;&lt;/a&gt; is a complex analytical function that has a branch cut &lt;code&gt;[-inf, 1]&lt;/code&gt; and is continuous from above on it.</source>
          <target state="translated">Для комплексных входных данных &lt;a href=&quot;#numpy.arccosh&quot;&gt; &lt;code&gt;arccosh&lt;/code&gt; &lt;/a&gt; - это сложная аналитическая функция, которая имеет отрезок ветви &lt;code&gt;[-inf, 1]&lt;/code&gt; и является непрерывной сверху вниз .</target>
        </trans-unit>
        <trans-unit id="64f377fde8ecd4efebbb4d5831dcc8bc678877a9" translate="yes" xml:space="preserve">
          <source>For complex-valued input, &lt;a href=&quot;#numpy.arcsin&quot;&gt;&lt;code&gt;arcsin&lt;/code&gt;&lt;/a&gt; is a complex analytic function that has, by convention, the branch cuts [-inf, -1] and [1, inf] and is continuous from above on the former and from below on the latter.</source>
          <target state="translated">Для комплексных входных данных &lt;a href=&quot;#numpy.arcsin&quot;&gt; &lt;code&gt;arcsin&lt;/code&gt; &lt;/a&gt; - это комплексная аналитическая функция, которая по соглашению имеет ветвь, отсекающую [-inf, -1] и [1, inf], и непрерывна сверху на первом и снизу на втором.</target>
        </trans-unit>
        <trans-unit id="57038706eece9d133e1f92cf4c0e30653094f94f" translate="yes" xml:space="preserve">
          <source>For complex-valued input, &lt;a href=&quot;#numpy.arctan&quot;&gt;&lt;code&gt;arctan&lt;/code&gt;&lt;/a&gt; is a complex analytic function that has [&lt;code&gt;1j, infj&lt;/code&gt;] and [&lt;code&gt;-1j, -infj&lt;/code&gt;] as branch cuts, and is continuous from the left on the former and from the right on the latter.</source>
          <target state="translated">Для комплексных входных данных &lt;a href=&quot;#numpy.arctan&quot;&gt; &lt;code&gt;arctan&lt;/code&gt; &lt;/a&gt; - это комплексная аналитическая функция, которая имеет [ &lt;code&gt;1j, infj&lt;/code&gt; ] и [ &lt;code&gt;-1j, -infj&lt;/code&gt; ] как сечения ветвей, и непрерывна слева в первом случае и справа во втором.</target>
        </trans-unit>
        <trans-unit id="4c701e0e2c7136fbf8b3d11659944481b8208402" translate="yes" xml:space="preserve">
          <source>For complex-valued input, &lt;a href=&quot;#numpy.arctanh&quot;&gt;&lt;code&gt;arctanh&lt;/code&gt;&lt;/a&gt; is a complex analytical function that has branch cuts &lt;code&gt;[-1, -inf]&lt;/code&gt; and &lt;code&gt;[1, inf]&lt;/code&gt; and is continuous from above on the former and from below on the latter.</source>
          <target state="translated">Для комплексных входных данных &lt;a href=&quot;#numpy.arctanh&quot;&gt; &lt;code&gt;arctanh&lt;/code&gt; &lt;/a&gt; - это сложная аналитическая функция, которая имеет &lt;code&gt;[-1, -inf]&lt;/code&gt; ветвей [-1, -inf] и &lt;code&gt;[1, inf]&lt;/code&gt; и является непрерывной сверху на первом и снизу на втором.</target>
        </trans-unit>
        <trans-unit id="159e5638a9f1467d3dd2785cf39347fd2d548d9f" translate="yes" xml:space="preserve">
          <source>For complex-valued input, &lt;a href=&quot;#numpy.log&quot;&gt;&lt;code&gt;log&lt;/code&gt;&lt;/a&gt; is a complex analytical function that has a branch cut &lt;code&gt;[-inf, 0]&lt;/code&gt; and is continuous from above on it. &lt;a href=&quot;#numpy.log&quot;&gt;&lt;code&gt;log&lt;/code&gt;&lt;/a&gt; handles the floating-point negative zero as an infinitesimal negative number, conforming to the C99 standard.</source>
          <target state="translated">Для комплексных входных данных &lt;a href=&quot;#numpy.log&quot;&gt; &lt;code&gt;log&lt;/code&gt; &lt;/a&gt; - это сложная аналитическая функция, которая имеет отрезок ветви &lt;code&gt;[-inf, 0]&lt;/code&gt; и является непрерывной сверху вниз . &lt;a href=&quot;#numpy.log&quot;&gt; &lt;code&gt;log&lt;/code&gt; &lt;/a&gt; обрабатывает отрицательный ноль с плавающей запятой как бесконечно малое отрицательное число, соответствующее стандарту C99.</target>
        </trans-unit>
        <trans-unit id="5ba7031abf7f62c036d84ca3e657ff0bbe63c9b4" translate="yes" xml:space="preserve">
          <source>For complex-valued input, &lt;a href=&quot;#numpy.log10&quot;&gt;&lt;code&gt;log10&lt;/code&gt;&lt;/a&gt; is a complex analytical function that has a branch cut &lt;code&gt;[-inf, 0]&lt;/code&gt; and is continuous from above on it. &lt;a href=&quot;#numpy.log10&quot;&gt;&lt;code&gt;log10&lt;/code&gt;&lt;/a&gt; handles the floating-point negative zero as an infinitesimal negative number, conforming to the C99 standard.</source>
          <target state="translated">Для комплексных входных данных &lt;a href=&quot;#numpy.log10&quot;&gt; &lt;code&gt;log10&lt;/code&gt; &lt;/a&gt; - это сложная аналитическая функция, которая имеет отрезок ветви &lt;code&gt;[-inf, 0]&lt;/code&gt; и является непрерывной сверху вниз . &lt;a href=&quot;#numpy.log10&quot;&gt; &lt;code&gt;log10&lt;/code&gt; &lt;/a&gt; обрабатывает отрицательный ноль с плавающей запятой как бесконечно малое отрицательное число в соответствии со стандартом C99.</target>
        </trans-unit>
        <trans-unit id="1d03218ffbd2a27086f21639f1e5d2c57e1fdb96" translate="yes" xml:space="preserve">
          <source>For complex-valued input, &lt;a href=&quot;#numpy.log1p&quot;&gt;&lt;code&gt;log1p&lt;/code&gt;&lt;/a&gt; is a complex analytical function that has a branch cut &lt;code&gt;[-inf, -1]&lt;/code&gt; and is continuous from above on it. &lt;a href=&quot;#numpy.log1p&quot;&gt;&lt;code&gt;log1p&lt;/code&gt;&lt;/a&gt; handles the floating-point negative zero as an infinitesimal negative number, conforming to the C99 standard.</source>
          <target state="translated">Для комплексных входных данных &lt;a href=&quot;#numpy.log1p&quot;&gt; &lt;code&gt;log1p&lt;/code&gt; &lt;/a&gt; - это сложная аналитическая функция, которая имеет отрезок ветви &lt;code&gt;[-inf, -1]&lt;/code&gt; и является непрерывной сверху вниз . &lt;a href=&quot;#numpy.log1p&quot;&gt; &lt;code&gt;log1p&lt;/code&gt; &lt;/a&gt; обрабатывает отрицательный ноль с плавающей запятой как бесконечно малое отрицательное число, соответствующее стандарту C99.</target>
        </trans-unit>
        <trans-unit id="714b21ba8fb7b3f93db097558f921f5a3cc7d7e7" translate="yes" xml:space="preserve">
          <source>For complex-valued input, &lt;a href=&quot;#numpy.log2&quot;&gt;&lt;code&gt;log2&lt;/code&gt;&lt;/a&gt; is a complex analytical function that has a branch cut &lt;code&gt;[-inf, 0]&lt;/code&gt; and is continuous from above on it. &lt;a href=&quot;#numpy.log2&quot;&gt;&lt;code&gt;log2&lt;/code&gt;&lt;/a&gt; handles the floating-point negative zero as an infinitesimal negative number, conforming to the C99 standard.</source>
          <target state="translated">Для комплексных входных данных &lt;a href=&quot;#numpy.log2&quot;&gt; &lt;code&gt;log2&lt;/code&gt; &lt;/a&gt; - это сложная аналитическая функция, которая имеет отрезок ветви &lt;code&gt;[-inf, 0]&lt;/code&gt; и является непрерывной сверху вниз . &lt;a href=&quot;#numpy.log2&quot;&gt; &lt;code&gt;log2&lt;/code&gt; &lt;/a&gt; обрабатывает отрицательный ноль с плавающей запятой как бесконечно малое отрицательное число, соответствующее стандарту C99.</target>
        </trans-unit>
        <trans-unit id="a557bc2da4dcaaf761d30f4619e8e0d4a2f4e8f4" translate="yes" xml:space="preserve">
          <source>For complex-valued input, &lt;a href=&quot;numpy.arccos#numpy.arccos&quot;&gt;&lt;code&gt;arccos&lt;/code&gt;&lt;/a&gt; is a complex analytical function that has branch cuts &lt;code&gt;[1j, infj]&lt;/code&gt; and &lt;code&gt;[-1j, -infj]&lt;/code&gt; and is continuous from the right on the former and from the left on the latter.</source>
          <target state="translated">Для комплексных входных данных &lt;a href=&quot;numpy.arccos#numpy.arccos&quot;&gt; &lt;code&gt;arccos&lt;/code&gt; &lt;/a&gt; - это сложная аналитическая функция, которая имеет &lt;code&gt;[1j, infj]&lt;/code&gt; ветвей [1j, infj] и &lt;code&gt;[-1j, -infj]&lt;/code&gt; и непрерывна справа в первом и слева во втором.</target>
        </trans-unit>
        <trans-unit id="3c5f909f0d078490d8b615f107e16ec3bc3a188b" translate="yes" xml:space="preserve">
          <source>For computing the ULP difference, this API does not differentiate between various representations of NAN (ULP difference between 0x7fc00000 and 0xffc00000 is zero).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e81428e8e562739a6cb03d81d7a49ece97991e48" translate="yes" xml:space="preserve">
          <source>For consistency with histogram, an array of pre-computed bins is passed through unmodified:</source>
          <target state="translated">Для согласованности с гистограммой массив предварительно вычисленных бинов проходит через немодифицированный:</target>
        </trans-unit>
        <trans-unit id="67034429080fa2a52e171f0ea36b0dba67f26dbe" translate="yes" xml:space="preserve">
          <source>For convenience and backward compatibility, a single &lt;a href=&quot;legacy#numpy.random.RandomState&quot;&gt;&lt;code&gt;RandomState&lt;/code&gt;&lt;/a&gt; instance&amp;rsquo;s methods are imported into the numpy.random namespace, see &lt;a href=&quot;legacy#legacy&quot;&gt;Legacy Random Generation&lt;/a&gt; for the complete list.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eed4c585fafb6282979d170d7fc49312f2240470" translate="yes" xml:space="preserve">
          <source>For convenience and backward compatibility, a single &lt;a href=&quot;legacy#numpy.random.mtrand.RandomState&quot;&gt;&lt;code&gt;RandomState&lt;/code&gt;&lt;/a&gt; instance&amp;rsquo;s methods are imported into the numpy.random namespace, see &lt;a href=&quot;legacy#legacy&quot;&gt;Legacy Random Generation&lt;/a&gt; for the complete list.</source>
          <target state="translated">Для удобства и обратной совместимости методы одного экземпляра &lt;a href=&quot;legacy#numpy.random.mtrand.RandomState&quot;&gt; &lt;code&gt;RandomState&lt;/code&gt; &lt;/a&gt; импортируются в пространство имен numpy.random, полный список см. В разделе &amp;laquo; &lt;a href=&quot;legacy#legacy&quot;&gt;Устаревшая случайная генерация&amp;raquo;&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5d0d8cd3e47bac7d4c34c5ffeca248e53bd90070" translate="yes" xml:space="preserve">
          <source>For convenience, viewing an ndarray as type &lt;code&gt;np.recarray&lt;/code&gt; will automatically convert to &lt;code&gt;np.record&lt;/code&gt; datatype, so the dtype can be left out of the view:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="96d19661d614c330e3a9e7e16801d7b1d4abdea7" translate="yes" xml:space="preserve">
          <source>For data types that are always the same size (such as long), this holds the size of the data type. For flexible data types where different arrays can have a different elementsize, this should be 0.</source>
          <target state="translated">Для типов данных,которые всегда имеют одинаковый размер (например,длинный),это означает размер типа данных.Для гибких типов данных,где разные массивы могут иметь разный размер элементов,это должно быть 0.</target>
        </trans-unit>
        <trans-unit id="88871b72e212455bd0a3305f24c658a9086cd65b" translate="yes" xml:space="preserve">
          <source>For data types that describe sub-arrays:</source>
          <target state="translated">Для типов данных,описывающих подмассивы:</target>
        </trans-unit>
        <trans-unit id="665e908efd043172f3a61d4025a859ec2c83aba8" translate="yes" xml:space="preserve">
          <source>For definition of the DFT and conventions used.</source>
          <target state="translated">Для определения БПД и используемых конвенций.</target>
        </trans-unit>
        <trans-unit id="ec4950c0b9d4572d83c373887e2dc02d9903faa1" translate="yes" xml:space="preserve">
          <source>For detailed info on testing, see &lt;a href=&quot;../dev/development_environment#testing-builds&quot;&gt;Testing builds&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb5f8bb3afe673736236ecca5864cdc9f7fc37e1" translate="yes" xml:space="preserve">
          <source>For developers of NumPy: do not instantiate this at the module level. The initial calculation of these parameters is expensive and negatively impacts import times. These objects are cached, so calling &lt;code&gt;finfo()&lt;/code&gt; repeatedly inside your functions is not a problem.</source>
          <target state="translated">Для разработчиков NumPy: не создавайте его на уровне модуля. Первоначальный расчет этих параметров является дорогостоящим и отрицательно влияет на время импорта. Эти объекты кэшируются, поэтому &lt;code&gt;finfo()&lt;/code&gt; вызов finfo () внутри ваших функций не является проблемой.</target>
        </trans-unit>
        <trans-unit id="83549bc3ff37e9fd5f340310941a033ae7a10e48" translate="yes" xml:space="preserve">
          <source>For development, you can set up an in-place build so that changes made to &lt;code&gt;.py&lt;/code&gt; files have effect without rebuild. First, run:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c58f9c7b61fa3d8a2763dc4a797daee41cc03eb8" translate="yes" xml:space="preserve">
          <source>For each distinct core dimension, a set of &lt;code&gt;UFUNC_CORE_DIM*&lt;/code&gt; flags</source>
          <target state="translated">Для каждого отдельного основного измерения набор флагов &lt;code&gt;UFUNC_CORE_DIM*&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="396b05c439db2438a9382de672b6fa8e95c31893" translate="yes" xml:space="preserve">
          <source>For each distinct core dimension, the possible &lt;a href=&quot;c-api.generalized-ufuncs#frozen&quot;&gt;frozen&lt;/a&gt; size if &lt;code&gt;UFUNC_CORE_DIM_SIZE_INFERRED&lt;/code&gt; is 0</source>
          <target state="translated">Для каждого отдельного измерения сердечника, возможное &lt;a href=&quot;c-api.generalized-ufuncs#frozen&quot;&gt;замороженного&lt;/a&gt; размер , если &lt;code&gt;UFUNC_CORE_DIM_SIZE_INFERRED&lt;/code&gt; 0</target>
        </trans-unit>
        <trans-unit id="69d98b78325a9c10a5d66de529392752b9338931" translate="yes" xml:space="preserve">
          <source>For each distinct core dimension, the possible &lt;a href=&quot;generalized-ufuncs#frozen&quot;&gt;frozen&lt;/a&gt; size if &lt;code&gt;UFUNC_CORE_DIM_SIZE_INFERRED&lt;/code&gt; is 0</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb98f2bacd6f2ddd2321b31d6e02518d57ef1a01" translate="yes" xml:space="preserve">
          <source>For each element in &lt;code&gt;a&lt;/code&gt;, return a copy of the string where all characters occurring in the optional argument &lt;code&gt;deletechars&lt;/code&gt; are removed, and the remaining characters have been mapped through the given translation table.</source>
          <target state="translated">Для каждого элемента в &lt;code&gt;a&lt;/code&gt; вернуть копию строки, где все символы, встречающиеся в необязательном аргументе &lt;code&gt;deletechars&lt;/code&gt; , удалены, а оставшиеся символы были отображены через данную таблицу перевода.</target>
        </trans-unit>
        <trans-unit id="6fd82d55a1666ac371b70f835404bd2254f11112" translate="yes" xml:space="preserve">
          <source>For each element in &lt;code&gt;a&lt;/code&gt;, return a copy of the string with all occurrences of substring &lt;code&gt;old&lt;/code&gt; replaced by &lt;code&gt;new&lt;/code&gt;.</source>
          <target state="translated">Для каждого элемента в &lt;code&gt;a&lt;/code&gt; вернуть копию строки со всеми вхождениями &lt;code&gt;old&lt;/code&gt; подстроки, замененной на &lt;code&gt;new&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a0072392849c4a29d135980cb1732127fb7c8293" translate="yes" xml:space="preserve">
          <source>For each element in &lt;code&gt;a&lt;/code&gt;, return a copy with the leading and trailing characters removed.</source>
          <target state="translated">Для каждого элемента в &lt;code&gt;a&lt;/code&gt; вернуть копию с удаленными начальными и конечными символами.</target>
        </trans-unit>
        <trans-unit id="ce017fa2090bd21769500e23616f51df45b2cf16" translate="yes" xml:space="preserve">
          <source>For each element in &lt;code&gt;a&lt;/code&gt;, return a copy with the leading characters removed.</source>
          <target state="translated">Для каждого элемента в &lt;code&gt;a&lt;/code&gt; вернуть копию с удаленными ведущими символами.</target>
        </trans-unit>
        <trans-unit id="bcc8c5cf0a4ab8429da79ab635d524c5cd68a8b9" translate="yes" xml:space="preserve">
          <source>For each element in &lt;code&gt;a&lt;/code&gt;, return a copy with the trailing characters removed.</source>
          <target state="translated">Для каждого элемента в &lt;code&gt;a&lt;/code&gt; вернуть копию с удаленными завершающими символами.</target>
        </trans-unit>
        <trans-unit id="b48d2d67a82f24a073bc0fd48d1c7c812f1f1bea" translate="yes" xml:space="preserve">
          <source>For each element in &lt;code&gt;a&lt;/code&gt;, return a list of the lines in the element, breaking at line boundaries.</source>
          <target state="translated">Для каждого элемента в &lt;code&gt;a&lt;/code&gt; вернуть список строк в элементе с разрывами на границах строк.</target>
        </trans-unit>
        <trans-unit id="d96129628d06f13e5afb8f18fe53cee0a045c865" translate="yes" xml:space="preserve">
          <source>For each element in &lt;code&gt;a&lt;/code&gt;, return a list of the words in the string, using &lt;code&gt;sep&lt;/code&gt; as the delimiter string.</source>
          <target state="translated">Для каждого элемента в &lt;code&gt;a&lt;/code&gt; вернуть список слов в строке, используя &lt;code&gt;sep&lt;/code&gt; в качестве строки-разделителя.</target>
        </trans-unit>
        <trans-unit id="53321b75d28930691a06237aff36907b43cca790" translate="yes" xml:space="preserve">
          <source>For each element in &lt;code&gt;a&lt;/code&gt;, return the highest index in the string where substring &lt;code&gt;sub&lt;/code&gt; is found, such that &lt;code&gt;sub&lt;/code&gt; is contained within [&lt;code&gt;start&lt;/code&gt;, &lt;code&gt;end&lt;/code&gt;].</source>
          <target state="translated">Для каждого элемента в , возвращают самый высокий индекс в строке , где подстроки &lt;code&gt;sub&lt;/code&gt; найден, таким образом, что к &lt;code&gt;sub&lt;/code&gt; содержится в [ &lt;code&gt;start&lt;/code&gt; , &lt;code&gt;end&lt;/code&gt; ]. &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e01fe9cacbc57867bf7b4b4ec2f69fefe5c4a037" translate="yes" xml:space="preserve">
          <source>For each element in &lt;code&gt;a&lt;/code&gt;, split the element as the first occurrence of &lt;code&gt;sep&lt;/code&gt;, and return 3 strings containing the part before the separator, the separator itself, and the part after the separator. If the separator is not found, return 3 strings containing the string itself, followed by two empty strings.</source>
          <target state="translated">Для каждого элемента в &lt;code&gt;a&lt;/code&gt; разделите элемент как первое вхождение &lt;code&gt;sep&lt;/code&gt; и верните 3 строки, содержащие часть перед разделителем, сам разделитель и часть после разделителя. Если разделитель не найден, верните 3 строки, содержащие саму строку, за которыми следуют две пустые строки.</target>
        </trans-unit>
        <trans-unit id="7288d8c0ac4641f453c7b03f986690cbb92d91ab" translate="yes" xml:space="preserve">
          <source>For each element in &lt;code&gt;a&lt;/code&gt;, split the element as the last occurrence of &lt;code&gt;sep&lt;/code&gt;, and return 3 strings containing the part before the separator, the separator itself, and the part after the separator. If the separator is not found, return 3 strings containing the string itself, followed by two empty strings.</source>
          <target state="translated">Для каждого элемента в &lt;code&gt;a&lt;/code&gt; разделите элемент как последнее вхождение &lt;code&gt;sep&lt;/code&gt; и верните 3 строки, содержащие часть перед разделителем, сам разделитель и часть после разделителя. Если разделитель не найден, верните 3 строки, содержащие саму строку, за которыми следуют две пустые строки.</target>
        </trans-unit>
        <trans-unit id="b2be6980f0e55faed04690c7996e6d49756d7224" translate="yes" xml:space="preserve">
          <source>For each element in &lt;code&gt;self&lt;/code&gt;, return True if there are only decimal characters in the element.</source>
          <target state="translated">Для каждого элемента в &lt;code&gt;self&lt;/code&gt; верните True, если в элементе есть только десятичные символы.</target>
        </trans-unit>
        <trans-unit id="b59ff6bcceb7225ac9cadb07484ec0465abb9c2a" translate="yes" xml:space="preserve">
          <source>For each element in &lt;code&gt;self&lt;/code&gt;, return True if there are only numeric characters in the element.</source>
          <target state="translated">Для каждого элемента в &lt;code&gt;self&lt;/code&gt; верните True, если в элементе есть только числовые символы.</target>
        </trans-unit>
        <trans-unit id="9058afe727e5f02cb1c2a82daba2773477e47ab5" translate="yes" xml:space="preserve">
          <source>For each element in &lt;code&gt;self&lt;/code&gt;, return a copy of the string where all characters occurring in the optional argument &lt;code&gt;deletechars&lt;/code&gt; are removed, and the remaining characters have been mapped through the given translation table.</source>
          <target state="translated">Для каждого элемента в &lt;code&gt;self&lt;/code&gt; вернуть копию строки, в которой все символы, встречающиеся в необязательном аргументе &lt;code&gt;deletechars&lt;/code&gt; , удалены, а оставшиеся символы были отображены через данную таблицу перевода.</target>
        </trans-unit>
        <trans-unit id="ef526a1c4bb908663ee9a7ed64b48415ce75d7c1" translate="yes" xml:space="preserve">
          <source>For each element in &lt;code&gt;self&lt;/code&gt;, return a copy of the string with all occurrences of substring &lt;code&gt;old&lt;/code&gt; replaced by &lt;code&gt;new&lt;/code&gt;.</source>
          <target state="translated">Для каждого элемента в &lt;code&gt;self&lt;/code&gt; вернуть копию строки со всеми вхождениями подстроки &lt;code&gt;old&lt;/code&gt; , замененной на &lt;code&gt;new&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9e51c79c7e0159f28fc2312e8504acece61be2e0" translate="yes" xml:space="preserve">
          <source>For each element in &lt;code&gt;self&lt;/code&gt;, return a copy of the string with uppercase characters converted to lowercase and vice versa.</source>
          <target state="translated">Для каждого элемента в &lt;code&gt;self&lt;/code&gt; вернуть копию строки с прописными буквами, преобразованными в строчные, и наоборот.</target>
        </trans-unit>
        <trans-unit id="563e89160eca98fee13c4e654d4638943cb7ede0" translate="yes" xml:space="preserve">
          <source>For each element in &lt;code&gt;self&lt;/code&gt;, return a copy with the leading and trailing characters removed.</source>
          <target state="translated">Для каждого элемента в &lt;code&gt;self&lt;/code&gt; вернуть копию с удаленными начальными и конечными символами.</target>
        </trans-unit>
        <trans-unit id="a46f8951acf83f33ee77a16371dbcf5fcea54c99" translate="yes" xml:space="preserve">
          <source>For each element in &lt;code&gt;self&lt;/code&gt;, return a copy with the leading characters removed.</source>
          <target state="translated">Для каждого элемента в &lt;code&gt;self&lt;/code&gt; верните копию с удаленными ведущими символами.</target>
        </trans-unit>
        <trans-unit id="c528552cf6666391ba164c6c98e3136c037ac0d0" translate="yes" xml:space="preserve">
          <source>For each element in &lt;code&gt;self&lt;/code&gt;, return a copy with the trailing characters removed.</source>
          <target state="translated">Для каждого элемента в &lt;code&gt;self&lt;/code&gt; верните копию с удаленными завершающими символами.</target>
        </trans-unit>
        <trans-unit id="f3c87a7be827172789e8630db0faa9be334e4260" translate="yes" xml:space="preserve">
          <source>For each element in &lt;code&gt;self&lt;/code&gt;, return a list of the lines in the element, breaking at line boundaries.</source>
          <target state="translated">Для каждого элемента в &lt;code&gt;self&lt;/code&gt; вернуть список строк в элементе с разрывом на границах строк.</target>
        </trans-unit>
        <trans-unit id="3ca0a78fe28a9ed4242353e9fcde6e632b8bffa9" translate="yes" xml:space="preserve">
          <source>For each element in &lt;code&gt;self&lt;/code&gt;, return a list of the words in the string, using &lt;code&gt;sep&lt;/code&gt; as the delimiter string.</source>
          <target state="translated">Для каждого элемента в &lt;code&gt;self&lt;/code&gt; вернуть список слов в строке, используя &lt;code&gt;sep&lt;/code&gt; в качестве строки разделителя.</target>
        </trans-unit>
        <trans-unit id="41b923cc154e9a0efebee6038be59b5d66a9e904" translate="yes" xml:space="preserve">
          <source>For each element in &lt;code&gt;self&lt;/code&gt;, return a titlecased version of the string: words start with uppercase characters, all remaining cased characters are lowercase.</source>
          <target state="translated">Для каждого элемента в &lt;code&gt;self&lt;/code&gt; вернуть версию строки с заглавными буквами: слова начинаются с заглавных букв, все оставшиеся символы в регистре - строчные.</target>
        </trans-unit>
        <trans-unit id="a4fdbaa4039cefb583d1742ab7a44dc37da553da" translate="yes" xml:space="preserve">
          <source>For each element in &lt;code&gt;self&lt;/code&gt;, return the highest index in the string where substring &lt;code&gt;sub&lt;/code&gt; is found, such that &lt;code&gt;sub&lt;/code&gt; is contained within [&lt;code&gt;start&lt;/code&gt;, &lt;code&gt;end&lt;/code&gt;].</source>
          <target state="translated">Для каждого элемента в &lt;code&gt;self&lt;/code&gt; , вернуть самый высокий индекс в строке , где подстроки &lt;code&gt;sub&lt;/code&gt; найден, таким образом, что к &lt;code&gt;sub&lt;/code&gt; содержится в [ &lt;code&gt;start&lt;/code&gt; , &lt;code&gt;end&lt;/code&gt; ].</target>
        </trans-unit>
        <trans-unit id="66977f41b0aa64aabf235a79a75dcf6b6472f8b1" translate="yes" xml:space="preserve">
          <source>For each element, return True if there are only decimal characters in the element.</source>
          <target state="translated">Для каждого элемента верните True,если в элементе есть только десятичные символы.</target>
        </trans-unit>
        <trans-unit id="b1bf891f44f7ba1a69d9acfd1c67a586b04384f4" translate="yes" xml:space="preserve">
          <source>For each element, return True if there are only numeric characters in the element.</source>
          <target state="translated">Для каждого элемента верните True,если в элементе только числовые символы.</target>
        </trans-unit>
        <trans-unit id="de1f34aa0e69ee353932bddbc1b5178f2575078b" translate="yes" xml:space="preserve">
          <source>For each element, return the lowest index in the string where substring &lt;code&gt;sub&lt;/code&gt; is found, such that &lt;code&gt;sub&lt;/code&gt; is contained in the range [&lt;code&gt;start&lt;/code&gt;, &lt;code&gt;end&lt;/code&gt;].</source>
          <target state="translated">Для каждого элемента, вернуть самый низкий индекс в строке , где подстрока &lt;code&gt;sub&lt;/code&gt; найдено, таким образом, что к &lt;code&gt;sub&lt;/code&gt; содержатся в диапазоне [ &lt;code&gt;start&lt;/code&gt; , &lt;code&gt;end&lt;/code&gt; ].</target>
        </trans-unit>
        <trans-unit id="2d0516f761ea835ae249621609400fab8f420640" translate="yes" xml:space="preserve">
          <source>For each element, return the lowest index in the string where substring &lt;code&gt;sub&lt;/code&gt; is found.</source>
          <target state="translated">Для каждого элемента вернуть наименьший индекс в строке, где находится подстрока &lt;code&gt;sub&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1a1da4bbdbc0f0985083d16493c494b0cdbca1db" translate="yes" xml:space="preserve">
          <source>For efficient memory alignment, &lt;code&gt;np.longdouble&lt;/code&gt; is usually stored padded with zero bits, either to 96 or 128 bits. Which is more efficient depends on hardware and development environment; typically on 32-bit systems they are padded to 96 bits, while on 64-bit systems they are typically padded to 128 bits. &lt;code&gt;np.longdouble&lt;/code&gt; is padded to the system default; &lt;code&gt;np.float96&lt;/code&gt; and &lt;code&gt;np.float128&lt;/code&gt; are provided for users who want specific padding. In spite of the names, &lt;code&gt;np.float96&lt;/code&gt; and &lt;code&gt;np.float128&lt;/code&gt; provide only as much precision as &lt;code&gt;np.longdouble&lt;/code&gt;, that is, 80 bits on most x86 machines and 64 bits in standard Windows builds.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="42afabee0f54dc6a738be8285f1c8adb1a389c2c" translate="yes" xml:space="preserve">
          <source>For events with an expected separation</source>
          <target state="translated">Для событий с ожидаемым отделением</target>
        </trans-unit>
        <trans-unit id="69f5ea3c2094e2e0d29f615dbd5f1be3db9e9635" translate="yes" xml:space="preserve">
          <source>For example &lt;a href=&quot;arrays.indexing#arrays-indexing&quot;&gt;slicing&lt;/a&gt; can produce views of the array:</source>
          <target state="translated">Например, &lt;a href=&quot;arrays.indexing#arrays-indexing&quot;&gt;нарезка&lt;/a&gt; может создавать представления массива:</target>
        </trans-unit>
        <trans-unit id="6ba61c52342c8ca357f9b025f520786b1e36f952" translate="yes" xml:space="preserve">
          <source>For example suppose the source directory contains fun/foo.dat and fun/bar/car.dat:</source>
          <target state="translated">Например,предположим,что исходный каталог содержит fun/foo.dat и fun/bar/car.dat:</target>
        </trans-unit>
        <trans-unit id="1b62eba4a89119c28458eb16bfa619aca8aa8969" translate="yes" xml:space="preserve">
          <source>For example you might make a startup script that looks like this (Note: this is just an example, not a statement of &amp;ldquo;best practices&amp;rdquo;):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="290de80d5fc36b01dd67ceeb09359da7bf8e0291" translate="yes" xml:space="preserve">
          <source>For example, &lt;a href=&quot;bit_generators/mt19937#numpy.random.MT19937&quot;&gt;&lt;code&gt;MT19937&lt;/code&gt;&lt;/a&gt; has a state consisting of 624 &lt;code&gt;uint32&lt;/code&gt; integers. A naive way to take a 32-bit integer seed would be to just set the last element of the state to the 32-bit seed and leave the rest 0s. This is a valid state for &lt;a href=&quot;bit_generators/mt19937#numpy.random.MT19937&quot;&gt;&lt;code&gt;MT19937&lt;/code&gt;&lt;/a&gt;, but not a good one. The Mersenne Twister algorithm &lt;a href=&quot;http://www.math.sci.hiroshima-u.ac.jp/~m-mat/MT/MT2002/emt19937ar.html&quot;&gt;suffers if there are too many 0s&lt;/a&gt;. Similarly, two adjacent 32-bit integer seeds (i.e. &lt;code&gt;12345&lt;/code&gt; and &lt;code&gt;12346&lt;/code&gt;) would produce very similar streams.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c528a73750dc2b0ea8c9a4908a64744d7d47416a" translate="yes" xml:space="preserve">
          <source>For example, &lt;a href=&quot;bit_generators/mt19937#numpy.random.mt19937.MT19937&quot;&gt;&lt;code&gt;MT19937&lt;/code&gt;&lt;/a&gt; has a state consisting of 624 &lt;code&gt;uint32&lt;/code&gt; integers. A naive way to take a 32-bit integer seed would be to just set the last element of the state to the 32-bit seed and leave the rest 0s. This is a valid state for &lt;a href=&quot;bit_generators/mt19937#numpy.random.mt19937.MT19937&quot;&gt;&lt;code&gt;MT19937&lt;/code&gt;&lt;/a&gt;, but not a good one. The Mersenne Twister algorithm &lt;a href=&quot;http://www.math.sci.hiroshima-u.ac.jp/~m-mat/MT/MT2002/emt19937ar.html&quot;&gt;suffers if there are too many 0s&lt;/a&gt;. Similarly, two adjacent 32-bit integer seeds (i.e. &lt;code&gt;12345&lt;/code&gt; and &lt;code&gt;12346&lt;/code&gt;) would produce very similar streams.</source>
          <target state="translated">Например, &lt;a href=&quot;bit_generators/mt19937#numpy.random.mt19937.MT19937&quot;&gt; &lt;code&gt;MT19937&lt;/code&gt; &lt;/a&gt; имеет состояние, состоящее из 624 целых чисел &lt;code&gt;uint32&lt;/code&gt; . Наивный способ получить 32-битное целочисленное начальное число - просто установить последний элемент состояния в 32-битное начальное число и оставить остальные нули. Это допустимое состояние для &lt;a href=&quot;bit_generators/mt19937#numpy.random.mt19937.MT19937&quot;&gt; &lt;code&gt;MT19937&lt;/code&gt; &lt;/a&gt; , но не очень хорошее. Алгоритм Мерсенна Твистера &lt;a href=&quot;http://www.math.sci.hiroshima-u.ac.jp/~m-mat/MT/MT2002/emt19937ar.html&quot;&gt;страдает, если имеется слишком много нулей&lt;/a&gt; . Точно так же два соседних 32-битных целых числа (т.е. &lt;code&gt;12345&lt;/code&gt; и &lt;code&gt;12346&lt;/code&gt; ) будут создавать очень похожие потоки.</target>
        </trans-unit>
        <trans-unit id="c92ea12ee3f0aa3697d45f7df6d6af24fc7fd6b1" translate="yes" xml:space="preserve">
          <source>For example, F2PY generates from</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="30f8823abb19bf71600d2b51cdc69b652a8cdb6f" translate="yes" xml:space="preserve">
          <source>For example, I might be working on a computer with a little-endian CPU - such as an Intel Pentium, but I have loaded some data from a file written by a computer that is big-endian. Let&amp;rsquo;s say I have loaded 4 bytes from a file written by a Sun (big-endian) computer. I know that these 4 bytes represent two 16-bit integers. On a big-endian machine, a two-byte integer is stored with the Most Significant Byte (MSB) first, and then the Least Significant Byte (LSB). Thus the bytes are, in memory order:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="214075869a9c515ee07024b57bc4ea923a1819de" translate="yes" xml:space="preserve">
          <source>For example, a 2x2 array &lt;code&gt;A&lt;/code&gt; is Fortran-contiguous if its elements are stored in memory in the following order:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e8f7cf41730b21d0b9a823684d400d6bc79bd0dc" translate="yes" xml:space="preserve">
          <source>For example, a function &lt;code&gt;myrange(n)&lt;/code&gt; generated from the following signature</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="32bc5e66732d4344162eb54fb50c625865f9eafb" translate="yes" xml:space="preserve">
          <source>For example, add.accumulate() is equivalent to np.cumsum().</source>
          <target state="translated">Например,add.accumulate()эквивалентна np.cumsum().</target>
        </trans-unit>
        <trans-unit id="9a8d227d278d37b6250f8f06b0e4ddba59ee6707" translate="yes" xml:space="preserve">
          <source>For example, add.reduce() is equivalent to sum().</source>
          <target state="translated">Например,add.reduce()эквивалентна sum().</target>
        </trans-unit>
        <trans-unit id="10dea8dee68a389bd052fd52669dfbae04bf6a1e" translate="yes" xml:space="preserve">
          <source>For example, calculating 3*a, where a is an array of 32-bit floats, intuitively should result in a 32-bit float output. If the 3 is a 32-bit integer, the NumPy rules indicate it can&amp;rsquo;t convert losslessly into a 32-bit float, so a 64-bit float should be the result type. By examining the value of the constant, &amp;lsquo;3&amp;rsquo;, we see that it fits in an 8-bit integer, which can be cast losslessly into the 32-bit float.</source>
          <target state="translated">Например, вычисление 3 * a, где a - это массив 32-битных чисел с плавающей запятой, интуитивно должно привести к выходу 32-битных чисел с плавающей запятой. Если 3 - 32-битное целое число, правила NumPy указывают, что оно не может преобразовать без потерь в 32-битное число с плавающей запятой, поэтому типом результата должно быть 64-битное число с плавающей запятой. Изучая значение константы &amp;laquo;3&amp;raquo;, мы видим, что она подходит для 8-битного целого числа, которое можно без потерь преобразовать в 32-битное число с плавающей запятой.</target>
        </trans-unit>
        <trans-unit id="e896d341feb39ad2e94789a2fa3a61f98c1ab6de" translate="yes" xml:space="preserve">
          <source>For example, consider a ufunc with signature &lt;code&gt;(i,j),(i)-&amp;gt;()&lt;/code&gt;. In this case, &lt;code&gt;args&lt;/code&gt; will contain three pointers to the data of the input/output arrays &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;b&lt;/code&gt;, &lt;code&gt;c&lt;/code&gt;. Furthermore, &lt;code&gt;dimensions&lt;/code&gt; will be &lt;code&gt;[N, I, J]&lt;/code&gt; to define the size of &lt;code&gt;N&lt;/code&gt; of the loop and the sizes &lt;code&gt;I&lt;/code&gt; and &lt;code&gt;J&lt;/code&gt; for the core dimensions &lt;code&gt;i&lt;/code&gt; and &lt;code&gt;j&lt;/code&gt;. Finally, &lt;code&gt;steps&lt;/code&gt; will be &lt;code&gt;[a_N, b_N, c_N, a_i, a_j, b_i]&lt;/code&gt;, containing all necessary strides.</source>
          <target state="translated">Например, рассмотрим ufunc с сигнатурой &lt;code&gt;(i,j),(i)-&amp;gt;()&lt;/code&gt; . В этом случае &lt;code&gt;args&lt;/code&gt; будет содержать три указателя на данные массивов ввода / вывода &lt;code&gt;a&lt;/code&gt; , &lt;code&gt;b&lt;/code&gt; , &lt;code&gt;c&lt;/code&gt; . Кроме того, &lt;code&gt;dimensions&lt;/code&gt; будут &lt;code&gt;[N, I, J]&lt;/code&gt; для определения размера &lt;code&gt;N&lt;/code&gt; петли и размеров &lt;code&gt;I&lt;/code&gt; и &lt;code&gt;J&lt;/code&gt; для размеров сердечника &lt;code&gt;i&lt;/code&gt; и &lt;code&gt;j&lt;/code&gt; . Наконец, &lt;code&gt;steps&lt;/code&gt; будут &lt;code&gt;[a_N, b_N, c_N, a_i, a_j, b_i]&lt;/code&gt; , содержащие все необходимые шаги.</target>
        </trans-unit>
        <trans-unit id="dcfa362f844d8235742ab06beea7b0f26a111d9a" translate="yes" xml:space="preserve">
          <source>For example, consider the following Python code:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="65c761c5136870def0974489fd65a1f38ad92d78" translate="yes" xml:space="preserve">
          <source>For example, for functions like &lt;code&gt;log&lt;/code&gt; with branch cuts, the versions in this module provide the mathematically valid answers in the complex plane:</source>
          <target state="translated">Например, для таких функций, как &lt;code&gt;log&lt;/code&gt; с разрезами ветвей, версии этого модуля предоставляют математически верные ответы в комплексной плоскости:</target>
        </trans-unit>
        <trans-unit id="1ae012c1a0fdd5d83c39490663637fce0836fd8c" translate="yes" xml:space="preserve">
          <source>For example, here is a typical source generator function:</source>
          <target state="translated">Например,вот типичная функция генератора источника:</target>
        </trans-unit>
        <trans-unit id="5f16b11fb1616884a1f7f0284cf2a3ad3bd24f37" translate="yes" xml:space="preserve">
          <source>For example, if &lt;code&gt;a&lt;/code&gt; is a 3x3 array:</source>
          <target state="translated">Например, если &lt;code&gt;a&lt;/code&gt; - это массив 3x3:</target>
        </trans-unit>
        <trans-unit id="7e1eba6b832e945c1e4ddb165d50f426b3bfee26" translate="yes" xml:space="preserve">
          <source>For example, if an iterator was created with a single array as its input, and it was possible to rearrange all its axes and then collapse it into a single strided iteration, this would return a view that is a one-dimensional array.</source>
          <target state="translated">Например,если бы итератор был создан с одним массивом в качестве входа,и можно было бы перестроить все его оси,а затем свернуть его в одну продольную итерацию,то это вернуло бы представление,которое является одномерным массивом.</target>
        </trans-unit>
        <trans-unit id="a7f0071af46179382458b34ec09b89b95e091389" translate="yes" xml:space="preserve">
          <source>For example, if we choose</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ff87dba0f6e77925be276fcef4c7c831b8ea504" translate="yes" xml:space="preserve">
          <source>For example, if we want to import only the first and the last columns, we can use &lt;code&gt;usecols=(0, -1)&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd3d9bd14f229a7eb91aaf840c6ac1f84467537b" translate="yes" xml:space="preserve">
          <source>For example, if you create this array:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="16f1b7e404a82b7d866b4be0ca94013f93955314" translate="yes" xml:space="preserve">
          <source>For example, if you create this function:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d4336a303ad0f6a2b1bcee09892c8545dcc3ff9f" translate="yes" xml:space="preserve">
          <source>For example, if you start with this array:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="302f8b44862add9c44dd094ba5ef88c857733962" translate="yes" xml:space="preserve">
          <source>For example, if you want your sub-class or duck-type to be compatible with numpy&amp;rsquo;s &lt;code&gt;sum&lt;/code&gt; function, the method signature for this object&amp;rsquo;s &lt;code&gt;sum&lt;/code&gt; method should be the following:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="77b454223ff8bed8a9b0c67509f246c5fba091e9" translate="yes" xml:space="preserve">
          <source>For example, on a (typical linux x64 gcc) system, the numpy &lt;code&gt;complex64&lt;/code&gt; datatype is implemented as &lt;code&gt;struct { float real, imag; }&lt;/code&gt;. This has &amp;ldquo;true&amp;rdquo; alignment of 4 and &amp;ldquo;uint&amp;rdquo; alignment of 8 (equal to the true alignment of &lt;code&gt;uint64&lt;/code&gt;).</source>
          <target state="translated">Например, в системе (типичная для Linux x64 gcc) тип данных numpy &lt;code&gt;complex64&lt;/code&gt; реализован как &lt;code&gt;struct { float real, imag; }&lt;/code&gt; . Это имеет &amp;laquo;истинное&amp;raquo; выравнивание 4 и выравнивание &amp;laquo;uint&amp;raquo; 8 (равно истинному выравниванию &lt;code&gt;uint64&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="4ae14922ef64a97a2775a05d3077ba74da55d933" translate="yes" xml:space="preserve">
          <source>For example, the coordinates of a point in 3D space &lt;code&gt;[1,&amp;nbsp;2,&amp;nbsp;1]&lt;/code&gt; has one axis. That axis has 3 elements in it, so we say it has a length of 3. In the example pictured below, the array has 2 axes. The first axis has a length of 2, the second axis has a length of 3.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a172b13cb31313d38b209503a58e68588770858e" translate="yes" xml:space="preserve">
          <source>For example, this is the mean square error formula (a central formula used in supervised machine learning models that deal with regression):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0368fcdf7406da31a66eddfd11e72598360ada41" translate="yes" xml:space="preserve">
          <source>For example, using a 2-D boolean array of shape (2,3) with four True elements to select rows from a 3-D array of shape (2,3,5) results in a 2-D result of shape (4,5):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="54b9b1c9d703092f2621c55a5b2cd1e1eddf85b5" translate="yes" xml:space="preserve">
          <source>For example, you can create an array from a regular Python list or tuple using the &lt;code&gt;array&lt;/code&gt; function. The type of the resulting array is deduced from the type of the elements in the sequences.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3fad2cb39c870a9de4b9e44ed99144a88481e6ec" translate="yes" xml:space="preserve">
          <source>For example, you can plot a 1D array like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="390c0f644804c3940d2b75b4dff6f12c284b252d" translate="yes" xml:space="preserve">
          <source>For example, you may have an array like this one:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d24b595e5b1e7c226dfee05c7297047fa32fe9c1" translate="yes" xml:space="preserve">
          <source>For example, you might well want to be able to shorten &lt;code&gt;git checkout&lt;/code&gt; to &lt;code&gt;git co&lt;/code&gt;. Or you may want to alias &lt;code&gt;git diff --color-words&lt;/code&gt; (which gives a nicely formatted output of the diff) to &lt;code&gt;git wdiff&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="059c3e8cce263b2945a18ac90b2637e10a8026b1" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b82f8996b94b3076d2602f80a0b8a902b3a3586" translate="yes" xml:space="preserve">
          <source>For examples, see the various functions.</source>
          <target state="translated">Например,см.различные функции.</target>
        </trans-unit>
        <trans-unit id="13b2e9c534395e7c5f78b138c5b0b5d135b327e2" translate="yes" xml:space="preserve">
          <source>For finite values, isclose uses the following equation to test whether two floating point values are equivalent.</source>
          <target state="translated">Для конечных значений isclose использует следующее уравнение для проверки эквивалентности двух значений с плавающей точкой.</target>
        </trans-unit>
        <trans-unit id="e9eda33d9c06cab528c6194c742df4404b1ba711" translate="yes" xml:space="preserve">
          <source>For fixed format Fortran codes, &lt;code&gt;&amp;lt;comment char&amp;gt;&lt;/code&gt; must be at the first column of a file, of course. For free format Fortran codes, F2PY directives can appear anywhere in a file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d62c0e35a11ece55b5adf0e9c849759b322d0ed9" translate="yes" xml:space="preserve">
          <source>For floating point arguments, the length of the result is &lt;code&gt;ceil((stop - start)/step)&lt;/code&gt;. Because of floating point overflow, this rule may result in the last element of &lt;code&gt;out&lt;/code&gt; being greater than &lt;code&gt;stop&lt;/code&gt;.</source>
          <target state="translated">Для аргументов с плавающей запятой длина результата равна &lt;code&gt;ceil((stop - start)/step)&lt;/code&gt; . Из-за переполнения с плавающей запятой это правило может привести к тому, что последний элемент &lt;code&gt;out&lt;/code&gt; будет больше, чем &lt;code&gt;stop&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e9208c67472507d398cb8a93a13859f9ce375088" translate="yes" xml:space="preserve">
          <source>For floating point numbers the numerical precision of sum (and &lt;code&gt;np.add.reduce&lt;/code&gt;) is in general limited by directly adding each number individually to the result causing rounding errors in every step. However, often numpy will use a numerically better approach (partial pairwise summation) leading to improved precision in many use-cases. This improved precision is always provided when no &lt;code&gt;axis&lt;/code&gt; is given. When &lt;code&gt;axis&lt;/code&gt; is given, it will depend on which axis is summed. Technically, to provide the best speed possible, the improved precision is only used when the summation is along the fast axis in memory. Note that the exact precision may vary depending on other parameters. In contrast to NumPy, Python&amp;rsquo;s &lt;code&gt;math.fsum&lt;/code&gt; function uses a slower but more precise approach to summation. Especially when summing a large number of lower precision floating point numbers, such as &lt;code&gt;float32&lt;/code&gt;, numerical errors can become significant. In such cases it can be advisable to use &lt;code&gt;dtype=&amp;rdquo;float64&amp;rdquo;&lt;/code&gt; to use a higher precision for the output.</source>
          <target state="translated">Для чисел с плавающей запятой числовая точность суммы (и &lt;code&gt;np.add.reduce&lt;/code&gt; ) обычно ограничивается прямым добавлением каждого числа отдельно к результату, вызывая ошибки округления на каждом шаге. Однако часто numpy будет использовать численно лучший подход (частичное попарное суммирование), что приведет к повышению точности во многих случаях использования. Эта улучшенная точность всегда обеспечивается, когда &lt;code&gt;axis&lt;/code&gt; не указана. Когда указана &lt;code&gt;axis&lt;/code&gt; , это будет зависеть от того, какая ось суммируется. Технически, чтобы обеспечить наилучшую возможную скорость, улучшенная точность используется только тогда, когда суммирование выполняется по быстрой оси в памяти. Обратите внимание, что точная точность может варьироваться в зависимости от других параметров. В отличие от NumPy, в Python &lt;code&gt;math.fsum&lt;/code&gt; функция использует более медленный, но более точный подход к суммированию. Численные ошибки могут стать значительными, особенно при суммировании большого количества чисел с плавающей запятой низкой точности, таких как &lt;code&gt;float32&lt;/code&gt; . В таких случаях можно &lt;code&gt;dtype=&amp;rdquo;float64&amp;rdquo;&lt;/code&gt; использовать dtype = &amp;rdquo;float64&amp;rdquo;, чтобы использовать более высокую точность вывода.</target>
        </trans-unit>
        <trans-unit id="f41c623cdcb4a0e7f4eb2e6a140ca19a3b6cef7a" translate="yes" xml:space="preserve">
          <source>For floating-point input, the &lt;em&gt;std&lt;/em&gt; is computed using the same precision the input has. Depending on the input data, this can cause the results to be inaccurate, especially for float32 (see example below). Specifying a higher-accuracy accumulator using the &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt; keyword can alleviate this issue.</source>
          <target state="translated">Для ввода с плавающей запятой &lt;em&gt;std&lt;/em&gt; вычисляется с той же точностью, что и ввод. В зависимости от входных данных это может привести к неточности результатов, особенно для float32 (см. Пример ниже). Указание аккумулятора более высокой точности с помощью &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt; слова dtype может решить эту проблему.</target>
        </trans-unit>
        <trans-unit id="effdce45ed2fe7c4c7447e7c5d6ed579806ca2bd" translate="yes" xml:space="preserve">
          <source>For floating-point input, the variance is computed using the same precision the input has. Depending on the input data, this can cause the results to be inaccurate, especially for &lt;code&gt;float32&lt;/code&gt; (see example below). Specifying a higher-accuracy accumulator using the &lt;code&gt;dtype&lt;/code&gt; keyword can alleviate this issue.</source>
          <target state="translated">Для ввода с плавающей запятой дисперсия вычисляется с той же точностью, что и ввод. В зависимости от входных данных это может привести к неточности результатов, особенно для &lt;code&gt;float32&lt;/code&gt; (см. Пример ниже). Указание аккумулятора более высокой точности с помощью &lt;code&gt;dtype&lt;/code&gt; слова dtype может решить эту проблему.</target>
        </trans-unit>
        <trans-unit id="d9b2341f620f885d0f8ab294ce3abbf3b1a90c60" translate="yes" xml:space="preserve">
          <source>For full documentation, see &lt;a href=&quot;numpy.searchsorted#numpy.searchsorted&quot;&gt;&lt;code&gt;numpy.searchsorted&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">Для полной документации см. &lt;a href=&quot;numpy.searchsorted#numpy.searchsorted&quot;&gt; &lt;code&gt;numpy.searchsorted&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="8407df90b73fe86cd7253f98195431a6f813b267" translate="yes" xml:space="preserve">
          <source>For further details, consult the numpy reference documentation on array indexing.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="77c711733607bfc1bae041078b86f27ea8766c29" translate="yes" xml:space="preserve">
          <source>For further information, see &lt;a href=&quot;numpy.memmap#numpy.memmap&quot;&gt;&lt;code&gt;memmap&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Для получения дополнительной информации см. &lt;a href=&quot;numpy.memmap#numpy.memmap&quot;&gt; &lt;code&gt;memmap&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e11475a277ae3113deb33326346ecfc8620fa4bf" translate="yes" xml:space="preserve">
          <source>For general resources for learning &lt;a href=&quot;https://git-scm.com/&quot;&gt;git&lt;/a&gt; see &lt;a href=&quot;git_resources#git-resources&quot;&gt;Additional Git Resources&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e32d40cffc64e1d0297c17e549d89391273d13d" translate="yes" xml:space="preserve">
          <source>For help in printing, the following strings are defined as the correct format specifier in printf and related commands.</source>
          <target state="translated">Для справки при печати следующие строки определяются как правильный спецификатор формата в командах printf и связанных с ними командах.</target>
        </trans-unit>
        <trans-unit id="489d6f9ad36355f45e025471f49df88064ca87ee" translate="yes" xml:space="preserve">
          <source>For higher dimensional arrays summing a single axis can be done with ellipsis:</source>
          <target state="translated">Для более объемных массивов суммирование одной оси может быть выполнено с помощью эллипсиса:</target>
        </trans-unit>
        <trans-unit id="6a424dcac51ca8b201228fd393c244dbeb8c5216" translate="yes" xml:space="preserve">
          <source>For i in &lt;code&gt;range(len(indices))&lt;/code&gt;, &lt;a href=&quot;#numpy.ufunc.reduceat&quot;&gt;&lt;code&gt;reduceat&lt;/code&gt;&lt;/a&gt; computes &lt;code&gt;ufunc.reduce(a[indices[i]:indices[i+1]])&lt;/code&gt;, which becomes the i-th generalized &amp;ldquo;row&amp;rdquo; parallel to &lt;code&gt;axis&lt;/code&gt; in the final result (i.e., in a 2-D array, for example, if &lt;code&gt;axis = 0&lt;/code&gt;, it becomes the i-th row, but if &lt;code&gt;axis = 1&lt;/code&gt;, it becomes the i-th column). There are three exceptions to this:</source>
          <target state="translated">Для ввода в &lt;code&gt;range(len(indices))&lt;/code&gt; , &lt;a href=&quot;#numpy.ufunc.reduceat&quot;&gt; &lt;code&gt;reduceat&lt;/code&gt; &lt;/a&gt; Вычисляет &lt;code&gt;ufunc.reduce(a[indices[i]:indices[i+1]])&lt;/code&gt; , который становится г-го обобщенную &amp;laquo;строка&amp;raquo; параллельно &lt;code&gt;axis&lt;/code&gt; в конечном итоге (т. е. в двумерном массиве, например, если &lt;code&gt;axis = 0&lt;/code&gt; , она становится i-й строкой, но если &lt;code&gt;axis = 1&lt;/code&gt; , она становится i-м столбцом). Из этого есть три исключения:</target>
        </trans-unit>
        <trans-unit id="3e2d688963af310435591977ab9e45596586b894" translate="yes" xml:space="preserve">
          <source>For initializing an array &lt;code&gt;&amp;lt;array name&amp;gt;&lt;/code&gt;, F2PY generates a loop over all indices and dimensions that executes the following pseudo-statement:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="05f651225304ab9158ee3f9e677f8c577d092edf" translate="yes" xml:space="preserve">
          <source>For input arrays that are smaller than the specified buffer size, copies are made of all non-contiguous, mis-aligned, or out-of- byteorder arrays to ensure that for small arrays, a single loop is used. Then, array iterators are created for all the input arrays and the resulting collection of iterators is broadcast to a single shape.</source>
          <target state="translated">Для входных массивов,размер которых меньше указанного буфера,копии делаются из всех несмежных,выровненных или не выровненных по порядку,чтобы для малых массивов использовался один цикл.Затем для всех входных массивов создаются итераторы массива и результирующая коллекция итераторов транслируется в единую форму.</target>
        </trans-unit>
        <trans-unit id="0c7b69e69466d27c81eb277802b5fd2ba93ef1f2" translate="yes" xml:space="preserve">
          <source>For instructions on building for source package, see &lt;a href=&quot;building&quot;&gt;Building from source&lt;/a&gt;. This information is useful mainly for advanced users.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="37dbe6dc0691b61b379d0a2afb8134a45871395a" translate="yes" xml:space="preserve">
          <source>For integer arguments with absolute value larger than 1 the result is always zero because of the way Python handles integer division. For integer zero the result is an overflow.</source>
          <target state="translated">Для целочисленных аргументов с абсолютным значением больше 1 результат всегда равен нулю из-за того,как Python обрабатывает целочисленное деление.Для целого числа zero результатом является переполнение.</target>
        </trans-unit>
        <trans-unit id="117e2f99abde5ef34211f008976cf994cee261a9" translate="yes" xml:space="preserve">
          <source>For integer input the return values are floats.</source>
          <target state="translated">Для целочисленного ввода возвращаемые значения являются плавающими.</target>
        </trans-unit>
        <trans-unit id="51f2302ae3afa42e90f16f1c35bbd2af61213570" translate="yes" xml:space="preserve">
          <source>For integer specifiers (eg. &lt;code&gt;d,i,o,x&lt;/code&gt;), the minimum number of digits.</source>
          <target state="translated">Для целочисленных спецификаторов (например, &lt;code&gt;d,i,o,x&lt;/code&gt; ) минимальное количество цифр.</target>
        </trans-unit>
        <trans-unit id="7401aba5507b33d4914d20070660b9faa95209c3" translate="yes" xml:space="preserve">
          <source>For integer types, exact equality is used, in the same way as &lt;a href=&quot;numpy.ma.masked_equal#numpy.ma.masked_equal&quot;&gt;&lt;code&gt;masked_equal&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Для целочисленных типов используется точное равенство, так же, как и &lt;a href=&quot;numpy.ma.masked_equal#numpy.ma.masked_equal&quot;&gt; &lt;code&gt;masked_equal&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1e54c6af26706ff283ff28256c72b54eb26fbc6b" translate="yes" xml:space="preserve">
          <source>For integers, the fill value will be different in general to the result of &lt;code&gt;masked_equal&lt;/code&gt;.</source>
          <target state="translated">Для целых чисел значение заполнения будет отличаться от результата &lt;code&gt;masked_equal&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7d049cee37488c14a6b5c65b1da77ab9e42f2daa" translate="yes" xml:space="preserve">
          <source>For matrices that are not square or that (for negative powers) cannot be inverted numerically.</source>
          <target state="translated">Для матриц,которые не являются квадратными или которые (для отрицательных степеней)не могут быть инвертированы численно.</target>
        </trans-unit>
        <trans-unit id="582e5fdc5986730f5cfb2129f1c085cdd20f4ef0" translate="yes" xml:space="preserve">
          <source>For monotonically _increasing_ &lt;code&gt;bins&lt;/code&gt;, the following are equivalent:</source>
          <target state="translated">Для монотонно _increasing_ &lt;code&gt;bins&lt;/code&gt; , следующие условия эквивалентны:</target>
        </trans-unit>
        <trans-unit id="83fdf15871a7264e4f60e9ab78a977dea92e1a03" translate="yes" xml:space="preserve">
          <source>For more detailed documentation.</source>
          <target state="translated">Для более подробной документации.</target>
        </trans-unit>
        <trans-unit id="37ae37abcab4e25dbfe5d8b108d91993462a8cf5" translate="yes" xml:space="preserve">
          <source>For more details, see &lt;a href=&quot;numpy.random.mtrand.randomstate.set_state#numpy.random.mtrand.RandomState.set_state&quot;&gt;&lt;code&gt;set_state&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Для получения дополнительной информации см. &lt;a href=&quot;numpy.random.mtrand.randomstate.set_state#numpy.random.mtrand.RandomState.set_state&quot;&gt; &lt;code&gt;set_state&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="51a8eedb7d395c27948e4922d0fabc18aafcf5ff" translate="yes" xml:space="preserve">
          <source>For more details, see &lt;a href=&quot;numpy.random.set_state#numpy.random.set_state&quot;&gt;&lt;code&gt;set_state&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8f7f38b00189236c28757faab4aba491a5544afa" translate="yes" xml:space="preserve">
          <source>For more details, see &lt;code&gt;linalg.lstsq&lt;/code&gt;.</source>
          <target state="translated">Подробнее см. &lt;code&gt;linalg.lstsq&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e8a8f4e50fa887cbbddc19a83dfdf91655b33341" translate="yes" xml:space="preserve">
          <source>For more extensive information, see &lt;a href=&quot;../reference/testing#testing-guidelines&quot;&gt;Testing Guidelines&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="95cf6089ff82991425d6efdc0504169843591543" translate="yes" xml:space="preserve">
          <source>For more help on this function please see section 1.8 (Keyword Parameters for Extension Functions) of the Extending and Embedding tutorial in the Python documentation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="61db67fed17b10d2110b06ec89aa13d261ade260" translate="yes" xml:space="preserve">
          <source>For more information on dictionaries, read the &lt;a href=&quot;https://docs.python.org/tutorial/&quot;&gt;Python tutorial&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="03f4a148b39366545cf97da19167eb00139c5efc" translate="yes" xml:space="preserve">
          <source>For more information on the qr factorization, see for example: &lt;a href=&quot;https://en.wikipedia.org/wiki/QR_factorization&quot;&gt;https://en.wikipedia.org/wiki/QR_factorization&lt;/a&gt;</source>
          <target state="translated">Для получения дополнительной информации о факторизации qr см., Например: &lt;a href=&quot;https://en.wikipedia.org/wiki/QR_factorization&quot;&gt;https://en.wikipedia.org/wiki/QR_factorization&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="17921f717812e3320e8a7f42f4f17f79981316f9" translate="yes" xml:space="preserve">
          <source>For more information see:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3985651be63157e0b3fd0f006d48347a4d4ad484" translate="yes" xml:space="preserve">
          <source>For more information, a way to suppress the warning, and an example of &lt;a href=&quot;#numpy.RankWarning&quot;&gt;&lt;code&gt;RankWarning&lt;/code&gt;&lt;/a&gt; being issued, see &lt;a href=&quot;numpy.polyfit#numpy.polyfit&quot;&gt;&lt;code&gt;polyfit&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Для получения дополнительной информации, способа подавления предупреждения и примера &lt;a href=&quot;#numpy.RankWarning&quot;&gt; &lt;code&gt;RankWarning&lt;/code&gt; &lt;/a&gt; см. &lt;a href=&quot;numpy.polyfit#numpy.polyfit&quot;&gt; &lt;code&gt;polyfit&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8581f2666047bb23a92c8e690d1acad362013f23" translate="yes" xml:space="preserve">
          <source>For more information, read the section on lists in the &lt;a href=&quot;https://docs.python.org/tutorial/&quot;&gt;Python tutorial&lt;/a&gt;. For a mapping type (key-value), see &lt;em&gt;dictionary&lt;/em&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c4cae020b6b04928ab8186f1d73c1c26eba4002" translate="yes" xml:space="preserve">
          <source>For more information, refer to the &lt;a href=&quot;../index#module-numpy&quot;&gt;&lt;code&gt;numpy&lt;/code&gt;&lt;/a&gt; module and examine the methods and attributes of an array.</source>
          <target state="translated">Для получения дополнительной информации обратитесь к модулю &lt;a href=&quot;../index#module-numpy&quot;&gt; &lt;code&gt;numpy&lt;/code&gt; &lt;/a&gt; и изучите методы и атрибуты массива.</target>
        </trans-unit>
        <trans-unit id="d0fe83d89b7a0207c98cafeb4a0d87c2838e97b1" translate="yes" xml:space="preserve">
          <source>For more information, see &lt;a href=&quot;https://docs.python.org/3/extending/building.html&quot;&gt;Building C and C++ Extensions&lt;/a&gt; Python documentation for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa1433baa3f08eec4628310de483f3180d604e64" translate="yes" xml:space="preserve">
          <source>For more information, see &lt;a href=&quot;https://www.kernel.org/pub/software/scm/git/docs/git-push.html&quot;&gt;git push&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b974edc2834bd1e574341abd9ce885d0e7a2979b" translate="yes" xml:space="preserve">
          <source>For more information, see F2Py source code &lt;code&gt;numpy/f2py/capi_maps.py&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b32b573b8f00ce30b3419ec834d75448d214948d" translate="yes" xml:space="preserve">
          <source>For negative numbers, if width is not given, a minus sign is added to the front. If width is given, the two&amp;rsquo;s complement of the number is returned, with respect to that width.</source>
          <target state="translated">Для отрицательных чисел, если ширина не указана, спереди добавляется знак минус. Если задана ширина, возвращается двойное дополнение числа по отношению к этой ширине.</target>
        </trans-unit>
        <trans-unit id="5fc06ff1428a67551e7039c42cd5b569afbb759c" translate="yes" xml:space="preserve">
          <source>For non-Hermitian normal matrices the SciPy function &lt;a href=&quot;https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.schur.html#scipy.linalg.schur&quot;&gt;&lt;code&gt;scipy.linalg.schur&lt;/code&gt;&lt;/a&gt; is preferred because the matrix &lt;code&gt;v&lt;/code&gt; is guaranteed to be unitary, which is not the case when using &lt;a href=&quot;#numpy.linalg.eig&quot;&gt;&lt;code&gt;eig&lt;/code&gt;&lt;/a&gt;. The Schur factorization produces an upper triangular matrix rather than a diagonal matrix, but for normal matrices only the diagonal of the upper triangular matrix is needed, the rest is roundoff error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e6d9fefb02ae78e90327bf08c7741fd4d7aad3c" translate="yes" xml:space="preserve">
          <source>For one-dimensional arrays these notions coincide.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a2721282deb17b4500d92138a510cdb4754bcd3" translate="yes" xml:space="preserve">
          <source>For operations which are either not commutative or not associative, doing a reduction over multiple axes is not well-defined. The ufuncs do not currently raise an exception in this case, but will likely do so in the future.</source>
          <target state="translated">Для операций,которые не являются коммутационными или не ассоциативными,выполнение редукции по нескольким осям не имеет четкого определения.В настоящее время уфункции не вызывают исключений в данном случае,но,скорее всего,сделают это в будущем.</target>
        </trans-unit>
        <trans-unit id="cce08ac0d595dc1fc36977f113db0494cd013706" translate="yes" xml:space="preserve">
          <source>For other keyword-only arguments, see the &lt;a href=&quot;../ufuncs#ufuncs-kwargs&quot;&gt;ufunc docs&lt;/a&gt;.</source>
          <target state="translated">Для других аргументов, &lt;a href=&quot;../ufuncs#ufuncs-kwargs&quot;&gt;содержащих&lt;/a&gt; только ключевые слова, см. Документацию ufunc .</target>
        </trans-unit>
        <trans-unit id="0c08ef249ec6e440d6a8f4e999cc7fb84e271c54" translate="yes" xml:space="preserve">
          <source>For our example, we&amp;rsquo;ll create a sum of squares function. To start, let&amp;rsquo;s implement this function in straightforward Python. We want to support an &amp;lsquo;axis&amp;rsquo; parameter similar to the numpy &lt;a href=&quot;generated/numpy.sum#numpy.sum&quot;&gt;&lt;code&gt;sum&lt;/code&gt;&lt;/a&gt; function, so we will need to construct a list for the &lt;code&gt;op_axes&lt;/code&gt; parameter. Here&amp;rsquo;s how this looks.</source>
          <target state="translated">В нашем примере мы создадим функцию суммы квадратов. Для начала давайте реализуем эту функцию на простом Python. Мы хотим поддерживать параметр оси, аналогичный функции numpy &lt;a href=&quot;generated/numpy.sum#numpy.sum&quot;&gt; &lt;code&gt;sum&lt;/code&gt; &lt;/a&gt; , поэтому нам нужно будет создать список для параметра &lt;code&gt;op_axes&lt;/code&gt; . Вот как это выглядит.</target>
        </trans-unit>
        <trans-unit id="1bfec23fd3b5a8e4feecb9f5b43f562b252ee813" translate="yes" xml:space="preserve">
          <source>For paragraphs, indentation is significant and indicates indentation in the output. New paragraphs are marked with a blank line.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f8e34004cd49470f698985ea088603e79d6737af" translate="yes" xml:space="preserve">
          <source>For pickling.</source>
          <target state="translated">Для маринования.</target>
        </trans-unit>
        <trans-unit id="45d056f2d6dc25af69ffd36f748681cb1b37bcb7" translate="yes" xml:space="preserve">
          <source>For positive integers &lt;code&gt;n&lt;/code&gt;, the power is computed by repeated matrix squarings and matrix multiplications. If &lt;code&gt;n == 0&lt;/code&gt;, the identity matrix of the same shape as M is returned. If &lt;code&gt;n &amp;lt; 0&lt;/code&gt;, the inverse is computed and then raised to the &lt;code&gt;abs(n)&lt;/code&gt;.</source>
          <target state="translated">Для положительных целых чисел &lt;code&gt;n&lt;/code&gt; мощность вычисляется повторным возведением в квадрат матрицы и умножением матриц. Если &lt;code&gt;n == 0&lt;/code&gt; , возвращается единичная матрица той же формы, что и M. Если &lt;code&gt;n &amp;lt; 0&lt;/code&gt; , вычисляется обратное, а затем увеличивается до &lt;code&gt;abs(n)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2868f608509a0fb880318bfa1ea537e24b697cca" translate="yes" xml:space="preserve">
          <source>For private use, NumPy also constructs a &lt;code&gt;config.h&lt;/code&gt; in the NumPy include directory, which is not exported by NumPy (that is a python extension which use the numpy C API will not see those symbols), to avoid namespace pollution.</source>
          <target state="translated">Для частного использования NumPy также создает &lt;code&gt;config.h&lt;/code&gt; в каталоге включения NumPy, который не экспортируется NumPy (это расширение python, которое использует numpy C API, не будет видеть эти символы), чтобы избежать загрязнения пространства имен.</target>
        </trans-unit>
        <trans-unit id="3cba0cef0ecc3bf15466cf0b613737ac43d7cf46" translate="yes" xml:space="preserve">
          <source>For random samples from</source>
          <target state="translated">Для случайных образцов из</target>
        </trans-unit>
        <trans-unit id="3b14ea0275a3817032fbdd7fbc1e7bdb06b2af67" translate="yes" xml:space="preserve">
          <source>For real-valued input data types, &lt;a href=&quot;#numpy.arccos&quot;&gt;&lt;code&gt;arccos&lt;/code&gt;&lt;/a&gt; always returns real output. For each value that cannot be expressed as a real number or infinity, it yields &lt;code&gt;nan&lt;/code&gt; and sets the &lt;code&gt;invalid&lt;/code&gt; floating point error flag.</source>
          <target state="translated">Для типов входных данных с действительным &lt;a href=&quot;#numpy.arccos&quot;&gt; &lt;code&gt;arccos&lt;/code&gt; &lt;/a&gt; всегда возвращает реальный результат. Для каждого значения, которое не может быть выражено как действительное число или бесконечность, он возвращает &lt;code&gt;nan&lt;/code&gt; и устанавливает флаг ошибки &lt;code&gt;invalid&lt;/code&gt; плавающей запятой.</target>
        </trans-unit>
        <trans-unit id="f985096374044eb3c8f423921e1ca43a25a0a64a" translate="yes" xml:space="preserve">
          <source>For real-valued input data types, &lt;a href=&quot;#numpy.arccosh&quot;&gt;&lt;code&gt;arccosh&lt;/code&gt;&lt;/a&gt; always returns real output. For each value that cannot be expressed as a real number or infinity, it yields &lt;code&gt;nan&lt;/code&gt; and sets the &lt;code&gt;invalid&lt;/code&gt; floating point error flag.</source>
          <target state="translated">Для типов входных данных с &lt;a href=&quot;#numpy.arccosh&quot;&gt; &lt;code&gt;arccosh&lt;/code&gt; &lt;/a&gt; всегда возвращает реальный результат. Для каждого значения, которое не может быть выражено как действительное число или бесконечность, он возвращает &lt;code&gt;nan&lt;/code&gt; и устанавливает флаг ошибки &lt;code&gt;invalid&lt;/code&gt; плавающей запятой.</target>
        </trans-unit>
        <trans-unit id="1bd6dae91050b378f422d64d0fd3d06caee7dc76" translate="yes" xml:space="preserve">
          <source>For real-valued input data types, &lt;a href=&quot;#numpy.arcsinh&quot;&gt;&lt;code&gt;arcsinh&lt;/code&gt;&lt;/a&gt; always returns real output. For each value that cannot be expressed as a real number or infinity, it returns &lt;code&gt;nan&lt;/code&gt; and sets the &lt;code&gt;invalid&lt;/code&gt; floating point error flag.</source>
          <target state="translated">Для типов входных данных с &lt;a href=&quot;#numpy.arcsinh&quot;&gt; &lt;code&gt;arcsinh&lt;/code&gt; &lt;/a&gt; всегда возвращает реальный результат. Для каждого значения, которое не может быть выражено как действительное число или бесконечность, он возвращает &lt;code&gt;nan&lt;/code&gt; и устанавливает флаг ошибки &lt;code&gt;invalid&lt;/code&gt; плавающей запятой.</target>
        </trans-unit>
        <trans-unit id="f1a3e2a79ac88302cd49ced01b5ae36cb593f786" translate="yes" xml:space="preserve">
          <source>For real-valued input data types, &lt;a href=&quot;#numpy.arctan&quot;&gt;&lt;code&gt;arctan&lt;/code&gt;&lt;/a&gt; always returns real output. For each value that cannot be expressed as a real number or infinity, it yields &lt;code&gt;nan&lt;/code&gt; and sets the &lt;code&gt;invalid&lt;/code&gt; floating point error flag.</source>
          <target state="translated">Для типов входных данных с действительным &lt;a href=&quot;#numpy.arctan&quot;&gt; &lt;code&gt;arctan&lt;/code&gt; &lt;/a&gt; всегда возвращает реальный результат. Для каждого значения, которое не может быть выражено как действительное число или бесконечность, он возвращает &lt;code&gt;nan&lt;/code&gt; и устанавливает флаг ошибки &lt;code&gt;invalid&lt;/code&gt; плавающей запятой.</target>
        </trans-unit>
        <trans-unit id="4e59a4a7e10620a1dcf06247438f5e136a0933eb" translate="yes" xml:space="preserve">
          <source>For real-valued input data types, &lt;a href=&quot;#numpy.arctanh&quot;&gt;&lt;code&gt;arctanh&lt;/code&gt;&lt;/a&gt; always returns real output. For each value that cannot be expressed as a real number or infinity, it yields &lt;code&gt;nan&lt;/code&gt; and sets the &lt;code&gt;invalid&lt;/code&gt; floating point error flag.</source>
          <target state="translated">Для типов входных данных с &lt;a href=&quot;#numpy.arctanh&quot;&gt; &lt;code&gt;arctanh&lt;/code&gt; &lt;/a&gt; всегда возвращает реальный результат. Для каждого значения, которое не может быть выражено как действительное число или бесконечность, он возвращает &lt;code&gt;nan&lt;/code&gt; и устанавливает флаг ошибки &lt;code&gt;invalid&lt;/code&gt; плавающей запятой.</target>
        </trans-unit>
        <trans-unit id="00463e3d9bf72a8660310a707c972e6c6b2f2a87" translate="yes" xml:space="preserve">
          <source>For real-valued input data types, &lt;a href=&quot;#numpy.log&quot;&gt;&lt;code&gt;log&lt;/code&gt;&lt;/a&gt; always returns real output. For each value that cannot be expressed as a real number or infinity, it yields &lt;code&gt;nan&lt;/code&gt; and sets the &lt;code&gt;invalid&lt;/code&gt; floating point error flag.</source>
          <target state="translated">Для типов входных данных с действительным знаком &lt;a href=&quot;#numpy.log&quot;&gt; &lt;code&gt;log&lt;/code&gt; &lt;/a&gt; всегда возвращает реальный результат. Для каждого значения, которое не может быть выражено как действительное число или бесконечность, возвращается &lt;code&gt;nan&lt;/code&gt; и устанавливается флаг ошибки &lt;code&gt;invalid&lt;/code&gt; плавающей запятой.</target>
        </trans-unit>
        <trans-unit id="1dd401d005377ef79add082427bec36bd76d7d40" translate="yes" xml:space="preserve">
          <source>For real-valued input data types, &lt;a href=&quot;#numpy.log10&quot;&gt;&lt;code&gt;log10&lt;/code&gt;&lt;/a&gt; always returns real output. For each value that cannot be expressed as a real number or infinity, it yields &lt;code&gt;nan&lt;/code&gt; and sets the &lt;code&gt;invalid&lt;/code&gt; floating point error flag.</source>
          <target state="translated">Для типов входных данных с действительным &lt;a href=&quot;#numpy.log10&quot;&gt; &lt;code&gt;log10&lt;/code&gt; &lt;/a&gt; всегда возвращает действительный результат. Для каждого значения, которое не может быть выражено как действительное число или бесконечность, он возвращает &lt;code&gt;nan&lt;/code&gt; и устанавливает флаг ошибки &lt;code&gt;invalid&lt;/code&gt; плавающей запятой.</target>
        </trans-unit>
        <trans-unit id="18c562bcbaf668e2b82c801663121e7d15eaaa37" translate="yes" xml:space="preserve">
          <source>For real-valued input data types, &lt;a href=&quot;#numpy.log1p&quot;&gt;&lt;code&gt;log1p&lt;/code&gt;&lt;/a&gt; always returns real output. For each value that cannot be expressed as a real number or infinity, it yields &lt;code&gt;nan&lt;/code&gt; and sets the &lt;code&gt;invalid&lt;/code&gt; floating point error flag.</source>
          <target state="translated">Для типов входных данных с &lt;a href=&quot;#numpy.log1p&quot;&gt; &lt;code&gt;log1p&lt;/code&gt; &lt;/a&gt; всегда возвращает реальный вывод. Для каждого значения, которое не может быть выражено как действительное число или бесконечность, он возвращает &lt;code&gt;nan&lt;/code&gt; и устанавливает флаг ошибки &lt;code&gt;invalid&lt;/code&gt; плавающей запятой.</target>
        </trans-unit>
        <trans-unit id="cb65926ba3df7c570cfbf88879b3b9d563294100" translate="yes" xml:space="preserve">
          <source>For real-valued input data types, &lt;a href=&quot;#numpy.log2&quot;&gt;&lt;code&gt;log2&lt;/code&gt;&lt;/a&gt; always returns real output. For each value that cannot be expressed as a real number or infinity, it yields &lt;code&gt;nan&lt;/code&gt; and sets the &lt;code&gt;invalid&lt;/code&gt; floating point error flag.</source>
          <target state="translated">Для типов входных данных с &lt;a href=&quot;#numpy.log2&quot;&gt; &lt;code&gt;log2&lt;/code&gt; &lt;/a&gt; всегда возвращает действительный вывод. Для каждого значения, которое не может быть выражено как действительное число или бесконечность, он возвращает &lt;code&gt;nan&lt;/code&gt; и устанавливает флаг ошибки &lt;code&gt;invalid&lt;/code&gt; плавающей запятой.</target>
        </trans-unit>
        <trans-unit id="5a691d6f039d37de2f424c2292fd24a2e8849ab5" translate="yes" xml:space="preserve">
          <source>For real-valued input data types, &lt;em&gt;arcsin&lt;/em&gt; always returns real output. For each value that cannot be expressed as a real number or infinity, it yields &lt;code&gt;nan&lt;/code&gt; and sets the &lt;code&gt;invalid&lt;/code&gt; floating point error flag.</source>
          <target state="translated">Для типов входных данных с действительным &lt;em&gt;знаком arcsin&lt;/em&gt; всегда возвращает действительный вывод. Для каждого значения, которое не может быть выражено как действительное число или бесконечность, он возвращает &lt;code&gt;nan&lt;/code&gt; и устанавливает флаг ошибки &lt;code&gt;invalid&lt;/code&gt; плавающей запятой.</target>
        </trans-unit>
        <trans-unit id="ac8dda629e47802177efe000a2d093f5e016a0cb" translate="yes" xml:space="preserve">
          <source>For real-valued input, &lt;a href=&quot;#numpy.log1p&quot;&gt;&lt;code&gt;log1p&lt;/code&gt;&lt;/a&gt; is accurate also for &lt;code&gt;x&lt;/code&gt; so small that &lt;code&gt;1 + x == 1&lt;/code&gt; in floating-point accuracy.</source>
          <target state="translated">Для ввода с &lt;a href=&quot;#numpy.log1p&quot;&gt; &lt;code&gt;log1p&lt;/code&gt; &lt;/a&gt; является точным также для &lt;code&gt;x&lt;/code&gt; настолько малого, что &lt;code&gt;1 + x == 1&lt;/code&gt; в точности с плавающей точкой.</target>
        </trans-unit>
        <trans-unit id="8718e777159adb99e6030aa86f73aaa6419d14ea" translate="yes" xml:space="preserve">
          <source>For repeatability and readability, the dictionary keys are sorted in alphabetic order. This is for convenience only. A writer SHOULD implement this if possible. A reader MUST NOT depend on this.</source>
          <target state="translated">Для повторяемости и удобочитаемости клавиши словаря отсортированы в алфавитном порядке.Это делается только для удобства.Писатель ДОЛЖЕН по возможности реализовать это.Читатель НЕ ДОЛЖЕН от этого зависеть.</target>
        </trans-unit>
        <trans-unit id="6bd239911d468099089301c7ec88d5d1667469b6" translate="yes" xml:space="preserve">
          <source>For reshape, resize, and transpose, the single tuple argument may be replaced with &lt;code&gt;n&lt;/code&gt; integers which will be interpreted as an n-tuple.</source>
          <target state="translated">Для изменения формы, изменения размера и транспонирования единственный аргумент кортежа может быть заменен &lt;code&gt;n&lt;/code&gt; целыми числами, которые будут интерпретироваться как n-кортеж.</target>
        </trans-unit>
        <trans-unit id="6fe957d6ccb5cf28dddb483265ed8d862961930a" translate="yes" xml:space="preserve">
          <source>For scalar &lt;code&gt;a&lt;/code&gt;, returns the data type with the smallest size and smallest scalar kind which can hold its value.</source>
          <target state="translated">Для скаляра &lt;code&gt;a&lt;/code&gt; возвращает тип данных с наименьшим размером и наименьшим типом скаляра, который может содержать его значение.</target>
        </trans-unit>
        <trans-unit id="22863dbfbfce9a1b2c0c06d8e441eed6ee432e4b" translate="yes" xml:space="preserve">
          <source>For scalar &lt;code&gt;a&lt;/code&gt;, returns the data type with the smallest size and smallest scalar kind which can hold its value. For non-scalar array &lt;code&gt;a&lt;/code&gt;, returns the vector&amp;rsquo;s dtype unmodified.</source>
          <target state="translated">Для скаляра &lt;code&gt;a&lt;/code&gt; возвращает тип данных с наименьшим размером и наименьшим типом скаляра, который может содержать его значение. Для нескалярного массива &lt;code&gt;a&lt;/code&gt; возвращает dtype вектора без изменений.</target>
        </trans-unit>
        <trans-unit id="5642e4133974cc82494c6e2e1a04d4f6b4435c53" translate="yes" xml:space="preserve">
          <source>For several methods, an optional &lt;em&gt;out&lt;/em&gt; argument can also be provided and the result will be placed into the output array given. The &lt;em&gt;out&lt;/em&gt; argument must be an &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt; and have the same number of elements. It can have a different data type in which case casting will be performed.</source>
          <target state="translated">Для некоторых методов также может быть предоставлен необязательный аргумент &lt;em&gt;out,&lt;/em&gt; и результат будет помещен в указанный выходной массив. &lt;em&gt;Из&lt;/em&gt; аргументов должны быть &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt; и имеют одинаковое число элементов. Он может иметь другой тип данных, в этом случае будет выполнено приведение.</target>
        </trans-unit>
        <trans-unit id="b0753b0fcbeca94ce7630240e047138c854a65dd" translate="yes" xml:space="preserve">
          <source>For signed integer inputs, the two&amp;rsquo;s complement is returned. In a two&amp;rsquo;s-complement system negative numbers are represented by the two&amp;rsquo;s complement of the absolute value. This is the most common method of representing signed integers on computers &lt;a href=&quot;#rde927b304c4f-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt;. A N-bit two&amp;rsquo;s-complement system can represent every integer in the range</source>
          <target state="translated">Для целочисленных входов со знаком возвращается два дополнения. В системе с дополнением до двух отрицательные числа представлены дополнением до двух абсолютного значения. Это наиболее распространенный метод представления целых чисел со знаком на компьютерах &lt;a href=&quot;#rde927b304c4f-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt; . N-битная система с дополнением до двух может представлять каждое целое число в диапазоне</target>
        </trans-unit>
        <trans-unit id="8a7f873acfba66a72d1ce69253d776c71ca10e17" translate="yes" xml:space="preserve">
          <source>For simplicity we give a ufunc for a single dtype, the &amp;lsquo;f8&amp;rsquo; double. As in the previous section, we first give the .c file and then the setup.py file used to create the module containing the ufunc.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1790f111eccdfcb9badd8e72bbfbae78adf5ee18" translate="yes" xml:space="preserve">
          <source>For standard library functions:</source>
          <target state="translated">Для стандартных библиотечных функций:</target>
        </trans-unit>
        <trans-unit id="e58c1a1b97b83acb57ac2ac307ed0d7c16b3baf7" translate="yes" xml:space="preserve">
          <source>For structured arrays, all fields are combined, with masked values ignored. The result is masked if all fields were masked, with self and other considered equal only if both were fully masked.</source>
          <target state="translated">Для структурированных массивов все поля объединяются,при этом значения масок игнорируются.Результат маскируется,если все поля были замаскированы,при этом Я и другие считаются равными только в том случае,если оба были полностью замаскированы.</target>
        </trans-unit>
        <trans-unit id="60753f45a63d90af610aa65f98fdd4ce690bf30a" translate="yes" xml:space="preserve">
          <source>For structured datatypes with no fields this function now returns False.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="54b403ec15e745ce9b0d408a4253b0a3db036c37" translate="yes" xml:space="preserve">
          <source>For structured types, a structured scalar is returned, with each field the default fill value for its type.</source>
          <target state="translated">Для структурированных типов возвращается структурированный скаляр,для каждого поля которого заполняется значение по умолчанию.</target>
        </trans-unit>
        <trans-unit id="7c0b7d9c35a991bbf7b4be3304607a91761fd2e6" translate="yes" xml:space="preserve">
          <source>For subarray types, the fill value is an array of the same size containing the default scalar fill value.</source>
          <target state="translated">Для типов подмассивов значение заливки-это массив такого же размера,содержащий значение скалярной заливки по умолчанию.</target>
        </trans-unit>
        <trans-unit id="fa1668cc4f1ad2127afa574513a965e4f8de0bd1" translate="yes" xml:space="preserve">
          <source>For tall matrices in NumPy version up to 1.6.2, the diagonal &amp;ldquo;wrapped&amp;rdquo; after N columns. You can have this behavior with this option. This affects only tall matrices.</source>
          <target state="translated">Для высоких матриц в версии NumPy до 1.6.2 диагональ &amp;laquo;оборачивается&amp;raquo; после N столбцов. Вы можете получить такое поведение с помощью этой опции. Это касается только высоких матриц.</target>
        </trans-unit>
        <trans-unit id="15797574f39fa9a94e6a6ba0f1322211577809c1" translate="yes" xml:space="preserve">
          <source>For tests with a result that is random or platform-dependent, mark the output as such:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="571561584fb9de04ee089fbe39a5ff6d6bc01c7a" translate="yes" xml:space="preserve">
          <source>For the explicit constructor call, our subclass will need to create a new ndarray instance of its own class. In practice this means that we, the authors of the code, will need to make a call to &lt;code&gt;ndarray.__new__(MySubClass,...)&lt;/code&gt;, a class-hierarchy prepared call to &lt;code&gt;super(MySubClass, cls).__new__(cls, ...)&lt;/code&gt;, or do view casting of an existing array (see below)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="18e3d7bba1f8f57e3e3d0698a1673d2f7dbd0218" translate="yes" xml:space="preserve">
          <source>For the first run, we threw 3 times 1, 4 times 2, etc. For the second, we threw 2 times 1, 4 times 2, etc.</source>
          <target state="translated">За первый заезд мы бросали 3 раза 1,4 раза 2 и т.д.Во втором-2 раза 1,4 раза 2 и т.д.</target>
        </trans-unit>
        <trans-unit id="72f9e5e8e38fa061436e99d12c2a915135e47ac9" translate="yes" xml:space="preserve">
          <source>For the following methods there are also corresponding functions in &lt;a href=&quot;index#module-numpy&quot;&gt;&lt;code&gt;numpy&lt;/code&gt;&lt;/a&gt;: &lt;a href=&quot;generated/numpy.all#numpy.all&quot;&gt;&lt;code&gt;all&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;generated/numpy.any#numpy.any&quot;&gt;&lt;code&gt;any&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;generated/numpy.argmax#numpy.argmax&quot;&gt;&lt;code&gt;argmax&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;generated/numpy.argmin#numpy.argmin&quot;&gt;&lt;code&gt;argmin&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;generated/numpy.argpartition#numpy.argpartition&quot;&gt;&lt;code&gt;argpartition&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;generated/numpy.argsort#numpy.argsort&quot;&gt;&lt;code&gt;argsort&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;generated/numpy.choose#numpy.choose&quot;&gt;&lt;code&gt;choose&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;generated/numpy.clip#numpy.clip&quot;&gt;&lt;code&gt;clip&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;generated/numpy.compress#numpy.compress&quot;&gt;&lt;code&gt;compress&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;generated/numpy.copy#numpy.copy&quot;&gt;&lt;code&gt;copy&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;generated/numpy.cumprod#numpy.cumprod&quot;&gt;&lt;code&gt;cumprod&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;generated/numpy.cumsum#numpy.cumsum&quot;&gt;&lt;code&gt;cumsum&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;generated/numpy.diagonal#numpy.diagonal&quot;&gt;&lt;code&gt;diagonal&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;generated/numpy.imag#numpy.imag&quot;&gt;&lt;code&gt;imag&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;generated/numpy.amax#numpy.amax&quot;&gt;&lt;code&gt;max&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;generated/numpy.mean#numpy.mean&quot;&gt;&lt;code&gt;mean&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;generated/numpy.amin#numpy.amin&quot;&gt;&lt;code&gt;min&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;generated/numpy.nonzero#numpy.nonzero&quot;&gt;&lt;code&gt;nonzero&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;generated/numpy.partition#numpy.partition&quot;&gt;&lt;code&gt;partition&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;generated/numpy.prod#numpy.prod&quot;&gt;&lt;code&gt;prod&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;generated/numpy.ptp#numpy.ptp&quot;&gt;&lt;code&gt;ptp&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;generated/numpy.put#numpy.put&quot;&gt;&lt;code&gt;put&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;generated/numpy.ravel#numpy.ravel&quot;&gt;&lt;code&gt;ravel&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;generated/numpy.real#numpy.real&quot;&gt;&lt;code&gt;real&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;generated/numpy.repeat#numpy.repeat&quot;&gt;&lt;code&gt;repeat&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;generated/numpy.reshape#numpy.reshape&quot;&gt;&lt;code&gt;reshape&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;generated/numpy.around#numpy.around&quot;&gt;&lt;code&gt;round&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;generated/numpy.searchsorted#numpy.searchsorted&quot;&gt;&lt;code&gt;searchsorted&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;generated/numpy.sort#numpy.sort&quot;&gt;&lt;code&gt;sort&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;generated/numpy.squeeze#numpy.squeeze&quot;&gt;&lt;code&gt;squeeze&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;generated/numpy.std#numpy.std&quot;&gt;&lt;code&gt;std&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;generated/numpy.sum#numpy.sum&quot;&gt;&lt;code&gt;sum&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;generated/numpy.swapaxes#numpy.swapaxes&quot;&gt;&lt;code&gt;swapaxes&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;generated/numpy.take#numpy.take&quot;&gt;&lt;code&gt;take&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;generated/numpy.trace#numpy.trace&quot;&gt;&lt;code&gt;trace&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;generated/numpy.transpose#numpy.transpose&quot;&gt;&lt;code&gt;transpose&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;generated/numpy.var#numpy.var&quot;&gt;&lt;code&gt;var&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Для следующих методов имеются также соответствующие функции в &lt;a href=&quot;index#module-numpy&quot;&gt; &lt;code&gt;numpy&lt;/code&gt; &lt;/a&gt; : &lt;a href=&quot;generated/numpy.all#numpy.all&quot;&gt; &lt;code&gt;all&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;generated/numpy.any#numpy.any&quot;&gt; &lt;code&gt;any&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;generated/numpy.argmax#numpy.argmax&quot;&gt; &lt;code&gt;argmax&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;generated/numpy.argmin#numpy.argmin&quot;&gt; &lt;code&gt;argmin&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;generated/numpy.argpartition#numpy.argpartition&quot;&gt; &lt;code&gt;argpartition&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;generated/numpy.argsort#numpy.argsort&quot;&gt; &lt;code&gt;argsort&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;generated/numpy.choose#numpy.choose&quot;&gt; &lt;code&gt;choose&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;generated/numpy.clip#numpy.clip&quot;&gt; &lt;code&gt;clip&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;generated/numpy.compress#numpy.compress&quot;&gt; &lt;code&gt;compress&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;generated/numpy.copy#numpy.copy&quot;&gt; &lt;code&gt;copy&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;generated/numpy.cumprod#numpy.cumprod&quot;&gt; &lt;code&gt;cumprod&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;generated/numpy.cumsum#numpy.cumsum&quot;&gt; &lt;code&gt;cumsum&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;generated/numpy.diagonal#numpy.diagonal&quot;&gt; &lt;code&gt;diagonal&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;generated/numpy.imag#numpy.imag&quot;&gt; &lt;code&gt;imag&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;generated/numpy.amax#numpy.amax&quot;&gt; &lt;code&gt;max&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;generated/numpy.mean#numpy.mean&quot;&gt; &lt;code&gt;mean&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;generated/numpy.amin#numpy.amin&quot;&gt; &lt;code&gt;min&lt;/code&gt; &lt;/a&gt; , отличен от &lt;a href=&quot;generated/numpy.nonzero#numpy.nonzero&quot;&gt; &lt;code&gt;nonzero&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;generated/numpy.partition#numpy.partition&quot;&gt; &lt;code&gt;partition&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;generated/numpy.prod#numpy.prod&quot;&gt; &lt;code&gt;prod&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;generated/numpy.ptp#numpy.ptp&quot;&gt; &lt;code&gt;ptp&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;generated/numpy.put#numpy.put&quot;&gt; &lt;code&gt;put&lt;/code&gt; &lt;/a&gt; ,&lt;a href=&quot;generated/numpy.ravel#numpy.ravel&quot;&gt; &lt;code&gt;ravel&lt;/code&gt; &lt;/a&gt; ,&lt;a href=&quot;generated/numpy.real#numpy.real&quot;&gt; &lt;code&gt;real&lt;/code&gt; &lt;/a&gt; ,&lt;a href=&quot;generated/numpy.repeat#numpy.repeat&quot;&gt; &lt;code&gt;repeat&lt;/code&gt; &lt;/a&gt; ,&lt;a href=&quot;generated/numpy.reshape#numpy.reshape&quot;&gt; &lt;code&gt;reshape&lt;/code&gt; &lt;/a&gt; ,&lt;a href=&quot;generated/numpy.around#numpy.around&quot;&gt; &lt;code&gt;round&lt;/code&gt; &lt;/a&gt; ,&lt;a href=&quot;generated/numpy.searchsorted#numpy.searchsorted&quot;&gt; &lt;code&gt;searchsorted&lt;/code&gt; &lt;/a&gt; ,&lt;a href=&quot;generated/numpy.sort#numpy.sort&quot;&gt; &lt;code&gt;sort&lt;/code&gt; &lt;/a&gt; ,&lt;a href=&quot;generated/numpy.squeeze#numpy.squeeze&quot;&gt; &lt;code&gt;squeeze&lt;/code&gt; &lt;/a&gt; ,&lt;a href=&quot;generated/numpy.std#numpy.std&quot;&gt; &lt;code&gt;std&lt;/code&gt; &lt;/a&gt; ,&lt;a href=&quot;generated/numpy.sum#numpy.sum&quot;&gt; &lt;code&gt;sum&lt;/code&gt; &lt;/a&gt; ,&lt;a href=&quot;generated/numpy.swapaxes#numpy.swapaxes&quot;&gt; &lt;code&gt;swapaxes&lt;/code&gt; &lt;/a&gt; ,&lt;a href=&quot;generated/numpy.take#numpy.take&quot;&gt; &lt;code&gt;take&lt;/code&gt; &lt;/a&gt; ,&lt;a href=&quot;generated/numpy.trace#numpy.trace&quot;&gt; &lt;code&gt;trace&lt;/code&gt; &lt;/a&gt; ,&lt;a href=&quot;generated/numpy.transpose#numpy.transpose&quot;&gt; &lt;code&gt;transpose&lt;/code&gt; &lt;/a&gt; ,&lt;a href=&quot;generated/numpy.var#numpy.var&quot;&gt; &lt;code&gt;var&lt;/code&gt; &lt;/a&gt; . равномерный , реальный , повтор , изменение формы , округление , сортировка по поиску , сортировка , сжатие , стандартное, сумма , обмены осями , взять , трассировать , транспонировать , var .</target>
        </trans-unit>
        <trans-unit id="1f398fd04d9f322afdba477002ec5cde7b5d2d1b" translate="yes" xml:space="preserve">
          <source>For the general case, the iteration works by keeping track of a list of coordinate counters in the iterator object. At each iteration, the last coordinate counter is increased (starting from 0). If this counter is smaller than one less than the size of the array in that dimension (a pre-computed and stored value), then the counter is increased and the dataptr member is increased by the strides in that dimension and the macro ends. If the end of a dimension is reached, the counter for the last dimension is reset to zero and the dataptr is moved back to the beginning of that dimension by subtracting the strides value times one less than the number of elements in that dimension (this is also pre-computed and stored in the backstrides member of the iterator object). In this case, the macro does not end, but a local dimension counter is decremented so that the next-to-last dimension replaces the role that the last dimension played and the previously-described tests are executed again on the next-to-last dimension. In this way, the dataptr is adjusted appropriately for arbitrary striding.</source>
          <target state="translated">Для общего случая итерация работает по списку счетчиков координат в объекте итератора.При каждой итерации увеличивается последний счетчик координат (начиная с 0).Если этот счетчик меньше на единицу меньше,чем размер массива в этом измерении (предварительно вычисленное и сохраненное значение),то счетчик увеличивается,а член dataaptr увеличивается на шаги в этом измерении и макрос заканчивается.При достижении конца измерения счетчик последнего измерения сбрасывается на ноль,а датаптр перемещается обратно в начало этого измерения путем вычитания значения шага на единицу меньше,чем количество элементов в этом измерении (это также предварительно вычисленное и сохраненное в обратных шагах значение члена итератора).В этом случае макрос не заканчивается,а локальный счетчик размерностей декрементируется таким образом,что предпоследняя размерность заменяет роль,которую играла последняя размерность,а ранее описанные тесты выполняются снова на предпоследней размерности.Таким образом,датаптр корректируется соответствующим образом для произвольного шага.</target>
        </trans-unit>
        <trans-unit id="a106ff191577f5e49df4ba4a5b92a5dff872216c" translate="yes" xml:space="preserve">
          <source>For the most part, the rules for dispatch with &lt;code&gt;__array_function__&lt;/code&gt; match those for &lt;code&gt;__array_ufunc__&lt;/code&gt;. In particular:</source>
          <target state="translated">По большей части правила отправки с &lt;code&gt;__array_function__&lt;/code&gt; соответствуют &lt;code&gt;__array_ufunc__&lt;/code&gt; для __array_ufunc__ . В частности:</target>
        </trans-unit>
        <trans-unit id="4180b0d2e31dfed11719fe695b4c67afcfef466f" translate="yes" xml:space="preserve">
          <source>For the parameter types, be as precise as possible. Below are a few examples of parameters and their types.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5aabe002787ac5ab3c2a4862f3aa6c788cd300e2" translate="yes" xml:space="preserve">
          <source>For the typenum macros, the argument is an integer representing an enumerated array data type. For the array type checking macros the argument must be a &lt;a href=&quot;https://docs.python.org/dev/c-api/structures.html#c.PyObject&quot;&gt;&lt;code&gt;PyObject *&lt;/code&gt;&lt;/a&gt; that can be directly interpreted as a &lt;a href=&quot;c-api.types-and-structures#c.PyArrayObject&quot;&gt;&lt;code&gt;PyArrayObject *&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Для макросов typenum аргументом является целое число, представляющее тип данных перечислимого массива. Для макросов проверки типа массива аргумент должен быть &lt;a href=&quot;https://docs.python.org/dev/c-api/structures.html#c.PyObject&quot;&gt; &lt;code&gt;PyObject *&lt;/code&gt; ,&lt;/a&gt; который может быть напрямую интерпретирован как &lt;a href=&quot;c-api.types-and-structures#c.PyArrayObject&quot;&gt; &lt;code&gt;PyArrayObject *&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="62fce29176d606bc6dce1d1603810532e05edeb2" translate="yes" xml:space="preserve">
          <source>For the typenum macros, the argument is an integer representing an enumerated array data type. For the array type checking macros the argument must be a &lt;a href=&quot;https://docs.python.org/dev/c-api/structures.html#c.PyObject&quot;&gt;&lt;code&gt;PyObject *&lt;/code&gt;&lt;/a&gt; that can be directly interpreted as a &lt;a href=&quot;types-and-structures#c.PyArrayObject&quot;&gt;&lt;code&gt;PyArrayObject *&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d3c40fa5c98be8aa15b70b390891bf28a170212" translate="yes" xml:space="preserve">
          <source>For these reasons it is advisable to avoid &lt;code&gt;as_strided&lt;/code&gt; when possible.</source>
          <target state="translated">По этим причинам рекомендуется по возможности избегать &lt;code&gt;as_strided&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="eb33fc8c29e1bd562bffb815c2697c66a036bae2" translate="yes" xml:space="preserve">
          <source>For these reasons, NumPy provides an API to work with npy_half values accessible by including &amp;lt;numpy/halffloat.h&amp;gt; and linking to &amp;lsquo;npymath&amp;rsquo;. For functions that are not provided directly, such as the arithmetic operations, the preferred method is to convert to float or double and back again, as in the following example.</source>
          <target state="translated">По этим причинам NumPy предоставляет API для работы со значениями npy_half, доступными при включении &amp;lt;numpy / halffloat.h&amp;gt; и ссылке на npymath. Для функций, которые не предоставляются напрямую, таких как арифметические операции, предпочтительным методом является преобразование в float или double и обратно, как в следующем примере.</target>
        </trans-unit>
        <trans-unit id="684c1e70d951c1d84a7330eb5d5d620e2e0f3ef5" translate="yes" xml:space="preserve">
          <source>For this example we will only handle the method &lt;code&gt;__call__&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c5b0d8b34011752e4113aaa6a6fce2b3c78d19e5" translate="yes" xml:space="preserve">
          <source>For this function to work on sub-classes of ndarray, they must define &lt;a href=&quot;numpy.sum#numpy.sum&quot;&gt;&lt;code&gt;sum&lt;/code&gt;&lt;/a&gt; with the kwarg &lt;code&gt;keepdims&lt;/code&gt;</source>
          <target state="translated">Чтобы эта функция работала с подклассами ndarray, они должны определить &lt;a href=&quot;numpy.sum#numpy.sum&quot;&gt; &lt;code&gt;sum&lt;/code&gt; &lt;/a&gt; с помощью kwarg &lt;code&gt;keepdims&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="bffe6d0d22813c5a9e09a6444b12ab5f734f3a30" translate="yes" xml:space="preserve">
          <source>For this reason it is possible to use the output from the np.nonzero() function directly as an index since it always returns a tuple of index arrays.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c7b38cff3c38a7296ea244a6f149ab3fa89299cb" translate="yes" xml:space="preserve">
          <source>For this reason, it is equivalent to (but faster than) the following use of &lt;a href=&quot;numpy.apply_along_axis#numpy.apply_along_axis&quot;&gt;&lt;code&gt;apply_along_axis&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">По этой причине это эквивалентно (но быстрее) следующему использованию &lt;a href=&quot;numpy.apply_along_axis#numpy.apply_along_axis&quot;&gt; &lt;code&gt;apply_along_axis&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="77bbee921f7bbec73ea6da64c3957049942fe48c" translate="yes" xml:space="preserve">
          <source>For this sample array</source>
          <target state="translated">Для этого образца массива</target>
        </trans-unit>
        <trans-unit id="ef360ecaea0bceb4141bc860c62269adcea43126" translate="yes" xml:space="preserve">
          <source>For two dimensional arrays, the return will be two arrays ordered by axis. In this example the first array stands for the gradient in rows and the second one in columns direction:</source>
          <target state="translated">Для двухмерных массивов возвратом будут два массива,упорядоченных по осям.В данном примере первый массив обозначает градиент в строках,а второй-в направлении столбцов:</target>
        </trans-unit>
        <trans-unit id="5688be18895d1ed44e4e4ac9ea5a009f3d8f644d" translate="yes" xml:space="preserve">
          <source>For ufuncs dynamically created from python functions, this member holds a reference to the underlying Python function.</source>
          <target state="translated">Для уфункций,динамически создаваемых из питоновых функций,этот член содержит ссылку на лежащую в основе питоновскую функцию.</target>
        </trans-unit>
        <trans-unit id="f51d3a13e3a61d2cfd5f82478bfc77249b90c3e8" translate="yes" xml:space="preserve">
          <source>For ufuncs, it is hoped to eventually deprecate this method in favour of &lt;a href=&quot;#numpy.class.__array_ufunc__&quot;&gt;&lt;code&gt;__array_ufunc__&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Для ufuncs ожидается, что в конечном итоге этот метод будет устаревшим в пользу &lt;a href=&quot;#numpy.class.__array_ufunc__&quot;&gt; &lt;code&gt;__array_ufunc__&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3fec4c12c09d2caf632487f32e741d15fde50a70" translate="yes" xml:space="preserve">
          <source>For unpickling.</source>
          <target state="translated">За распаковку.</target>
        </trans-unit>
        <trans-unit id="f5a617d92aada34c5b1b91d32c80426c8f059f29" translate="yes" xml:space="preserve">
          <source>For unsigned integer arrays, the results will also be unsigned. This should not be surprising, as the result is consistent with calculating the difference directly:</source>
          <target state="translated">Для беззнаковых целочисленных массивов результаты также будут беззнаковыми.Это не должно удивлять,так как результат согласуется с прямым вычислением разницы:</target>
        </trans-unit>
        <trans-unit id="6e4eba9645d784baff280ba41b2a35d0eb68b9c9" translate="yes" xml:space="preserve">
          <source>For us, what consensus means is that we entrust &lt;em&gt;everyone&lt;/em&gt; with the right to veto any change if they feel it necessary. While this may sound like a recipe for obstruction and pain, this is not what happens. Instead, we find that most people take this responsibility seriously, and only invoke their veto when they judge that a serious problem is being ignored, and that their veto is necessary to protect the project. And in practice, it turns out that such vetoes are almost never formally invoked, because their mere possibility ensures that Contributors are motivated from the start to find some solution that everyone can live with &amp;ndash; thus accomplishing our goal of ensuring that all interested perspectives are taken into account.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b61801e49c04aeb574dfd6c0384db9e70e2d05c" translate="yes" xml:space="preserve">
          <source>For use if one has reason to manually (re-)set the internal state of the bit generator used by the RandomState instance. By default, RandomState uses the &amp;ldquo;Mersenne Twister&amp;rdquo;&lt;a href=&quot;#r0933ec43c7c9-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt; pseudo-random number generating algorithm.</source>
          <target state="translated">Используется, если есть причина вручную (повторно) установить внутреннее состояние генератора битов, используемого экземпляром RandomState. По умолчанию RandomState использует алгоритм генерации псевдослучайных чисел &amp;laquo;Mersenne Twister&amp;raquo; &lt;a href=&quot;#r0933ec43c7c9-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="897febe53ee6bd5d25313858b98b8601f29d1bc3" translate="yes" xml:space="preserve">
          <source>For use if one has reason to manually (re-)set the internal state of the bit generator used by the RandomState instance. By default, RandomState uses the &amp;ldquo;Mersenne Twister&amp;rdquo;&lt;a href=&quot;#rd62dfb5ffa26-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt; pseudo-random number generating algorithm.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea29248ff311f62cfdcca5534fc099ca5bcc6b8e" translate="yes" xml:space="preserve">
          <source>For use if one has reason to manually (re-)set the internal state of the bit generator used by the RandomState instance. By default, RandomState uses the &amp;ldquo;Mersenne Twister&amp;rdquo;&lt;a href=&quot;#rf0f3f75f485b-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt; pseudo-random number generating algorithm.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="23f7c1942ce335813533514ab6d97be522e99c17" translate="yes" xml:space="preserve">
          <source>For use with &lt;a href=&quot;#c.NPY_ITER_ALLOCATE&quot;&gt;&lt;code&gt;NPY_ITER_ALLOCATE&lt;/code&gt;&lt;/a&gt;, this flag disables allocating an array subtype for the output, forcing it to be a straight ndarray.</source>
          <target state="translated">Для использования с &lt;a href=&quot;#c.NPY_ITER_ALLOCATE&quot;&gt; &lt;code&gt;NPY_ITER_ALLOCATE&lt;/code&gt; &lt;/a&gt; этот флаг отключает выделение подтипа массива для вывода, заставляя его быть прямым ndarray.</target>
        </trans-unit>
        <trans-unit id="4f63cfae8856e0c1b4c745d806a5044a1d2050ad" translate="yes" xml:space="preserve">
          <source>For use with &lt;a href=&quot;https://docs.python.org/dev/c-api/arg.html#c.PyArg_ParseTuple&quot;&gt;&lt;code&gt;PyArg_ParseTuple&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">Для использования с &lt;a href=&quot;https://docs.python.org/dev/c-api/arg.html#c.PyArg_ParseTuple&quot;&gt; &lt;code&gt;PyArg_ParseTuple&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="703ab6c203bc4f7c082f6639ec9949c363231487" translate="yes" xml:space="preserve">
          <source>For use with &lt;code&gt;PyArg_ParseTuple&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8cb254f53813d4f5ed5d47fcd78786e6b4efd30e" translate="yes" xml:space="preserve">
          <source>For values exactly halfway between rounded decimal values, NumPy rounds to the nearest even value. Thus 1.5 and 2.5 round to 2.0, -0.5 and 0.5 round to 0.0, etc.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="30f0a5ecb33fee954cb51300dbd6244641e9062e" translate="yes" xml:space="preserve">
          <source>For values exactly halfway between rounded decimal values, NumPy rounds to the nearest even value. Thus 1.5 and 2.5 round to 2.0, -0.5 and 0.5 round to 0.0, etc. Results may also be surprising due to the inexact representation of decimal fractions in the IEEE floating point standard &lt;a href=&quot;#r907366b089c1-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt; and errors introduced when scaling by powers of ten.</source>
          <target state="translated">Для значений точно посередине округленных десятичных значений NumPy округляет до ближайшего четного значения. Таким образом, 1,5 и 2,5 округляются до 2,0, -0,5 и 0,5 округляются до 0,0 и т. Д. Результаты также могут быть удивительными из-за неточного представления десятичных дробей в стандарте IEEE с плавающей запятой &lt;a href=&quot;#r907366b089c1-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt; и ошибок, возникающих при масштабировании по степеням десяти.</target>
        </trans-unit>
        <trans-unit id="a7513a1115d30c3b715a3ca9a5ba6b73db8ad275" translate="yes" xml:space="preserve">
          <source>For values of &lt;code&gt;ord &amp;lt; 1&lt;/code&gt;, the result is, strictly speaking, not a mathematical &amp;lsquo;norm&amp;rsquo;, but it may still be useful for various numerical purposes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b8df8eb2541671de725aa87916abd483ac03487" translate="yes" xml:space="preserve">
          <source>For values of &lt;code&gt;ord &amp;lt;= 0&lt;/code&gt;, the result is, strictly speaking, not a mathematical &amp;lsquo;norm&amp;rsquo;, but it may still be useful for various numerical purposes.</source>
          <target state="translated">Для значений &lt;code&gt;ord &amp;lt;= 0&lt;/code&gt; результат, строго говоря, не является математической &amp;laquo;нормой&amp;raquo;, но все же может быть полезен для различных численных целей.</target>
        </trans-unit>
        <trans-unit id="d6c5fe59c42bb96e8794f338a14a9afba25af3e6" translate="yes" xml:space="preserve">
          <source>For vectors (1-D arrays) it computes the ordinary inner-product:</source>
          <target state="translated">Для векторов (1-D массивов)вычисляет обычный внутренний продукт:</target>
        </trans-unit>
        <trans-unit id="f31afbaa8abd3ce58c5bf83aec637268a269a63d" translate="yes" xml:space="preserve">
          <source>For vectors &lt;code&gt;x1&lt;/code&gt;, &lt;code&gt;x2&lt;/code&gt;,&amp;hellip;, &amp;lsquo;xn&amp;rsquo; with lengths &lt;code&gt;Ni=len(xi)&lt;/code&gt; , return &lt;code&gt;(N1, N2, N3,...Nn)&lt;/code&gt; shaped arrays if indexing=&amp;rsquo;ij&amp;rsquo; or &lt;code&gt;(N2, N1, N3,...Nn)&lt;/code&gt; shaped arrays if indexing=&amp;rsquo;xy&amp;rsquo; with the elements of &lt;code&gt;xi&lt;/code&gt; repeated to fill the matrix along the first dimension for &lt;code&gt;x1&lt;/code&gt;, the second for &lt;code&gt;x2&lt;/code&gt; and so on.</source>
          <target state="translated">Для векторов &lt;code&gt;x1&lt;/code&gt; , &lt;code&gt;x2&lt;/code&gt; ,&amp;hellip;, 'xn' с длинами &lt;code&gt;Ni=len(xi)&lt;/code&gt; вернуть массивы в форме &lt;code&gt;(N1, N2, N3,...Nn)&lt;/code&gt; если индексирование = 'ij' или &lt;code&gt;(N2, N1, N3,...Nn)&lt;/code&gt; если indexing = 'xy' с повторением элементов &lt;code&gt;xi&lt;/code&gt; , чтобы заполнить матрицу по первому измерению для &lt;code&gt;x1&lt;/code&gt; , второму для &lt;code&gt;x2&lt;/code&gt; и так далее.</target>
        </trans-unit>
        <trans-unit id="51b960f61f40e8cc6aeabaf2a1735fbc2b9ac25d" translate="yes" xml:space="preserve">
          <source>For view casting and new-from-template, the equivalent of &lt;code&gt;ndarray.__new__(MySubClass,...&lt;/code&gt; is called, at the C level.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f6242c0a79a41aa81490f6fd1ec86280110a2af" translate="yes" xml:space="preserve">
          <source>Force a cast to the output type even if it cannot be done safely. Without this flag, a data cast will occur only if it can be done safely, otherwise an error is raised.</source>
          <target state="translated">Принудите литье к выходному типу,даже если это не может быть сделано безопасно.Без этого флага приведение данных произойдет только в том случае,если это можно сделать безопасно,в противном случае ошибка будет поднята.</target>
        </trans-unit>
        <trans-unit id="d3ec8aad2bec1b3220d7b727c3bf434f0d55bc18" translate="yes" xml:space="preserve">
          <source>Force the mask to hard.</source>
          <target state="translated">Заставь маску закрепиться.</target>
        </trans-unit>
        <trans-unit id="cd0355317a1ab931fccb7ea5788f7a01c8683490" translate="yes" xml:space="preserve">
          <source>Force the mask to soft.</source>
          <target state="translated">Заставь маску размягчиться.</target>
        </trans-unit>
        <trans-unit id="46e07bf1dcba4f22fb0998d98afd707eecb583d3" translate="yes" xml:space="preserve">
          <source>Format Version 1.0</source>
          <target state="translated">Формат Версия 1.0</target>
        </trans-unit>
        <trans-unit id="9c5ba690bca66f9b43bf7dce492a8ecc14116342" translate="yes" xml:space="preserve">
          <source>Format Version 2.0</source>
          <target state="translated">Формат Версия 2.0</target>
        </trans-unit>
        <trans-unit id="6d476621018ad05f5efc66b66f9628e71614d77b" translate="yes" xml:space="preserve">
          <source>Format Version 3.0</source>
          <target state="translated">Формат Версия 3.0</target>
        </trans-unit>
        <trans-unit id="082aa72e2e80659bc0dafa9d8a6a53207113bd45" translate="yes" xml:space="preserve">
          <source>Format a floating-point scalar as a decimal string in positional notation.</source>
          <target state="translated">Форматирование скаляра с плавающей точкой в виде десятичной строки в позиционной нотации.</target>
        </trans-unit>
        <trans-unit id="63ec1825c81674406abf9c065439398606f8e9c4" translate="yes" xml:space="preserve">
          <source>Format a floating-point scalar as a decimal string in scientific notation.</source>
          <target state="translated">Отформатируйте скаляр с плавающей точкой в виде десятичной строки в научной нотации.</target>
        </trans-unit>
        <trans-unit id="2ba865544cbf6ad122958e97b9cb7e6ee2fca0ce" translate="yes" xml:space="preserve">
          <source>Format string for text file output. Each entry in the array is formatted to text by first converting it to the closest Python type, and then using &amp;ldquo;format&amp;rdquo; % item.</source>
          <target state="translated">Строка формата для вывода текстового файла. Каждая запись в массиве форматируется в текст, сначала преобразуя ее в ближайший тип Python, а затем используя элемент &amp;laquo;format&amp;raquo;%.</target>
        </trans-unit>
        <trans-unit id="a3b7bf2b2380c4418912a52f4b2af945c3ac0459" translate="yes" xml:space="preserve">
          <source>Formatting issues</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e5a92b78c74fdad3772b95c0bef006808c6f5062" translate="yes" xml:space="preserve">
          <source>Fornberg B. (1988) Generation of Finite Difference Formulas on Arbitrarily Spaced Grids, Mathematics of Computation 51, no. 184 : 699-706. &lt;a href=&quot;http://www.ams.org/journals/mcom/1988-51-184/S0025-5718-1988-0935077-0/S0025-5718-1988-0935077-0.pdf&quot;&gt;PDF&lt;/a&gt;.</source>
          <target state="translated">Форнберг Б. (1988) Построение конечно-разностных формул на произвольно расположенных сетках, Математика вычислений 51, вып. 184: 699-706. &lt;a href=&quot;http://www.ams.org/journals/mcom/1988-51-184/S0025-5718-1988-0935077-0/S0025-5718-1988-0935077-0.pdf&quot;&gt;PDF&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d1cc558102f286f771795f2da7cbcbf5ba1b6328" translate="yes" xml:space="preserve">
          <source>Fortran 90 module data</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b62f0c388a951d6d6803e4d2dc48f368bb1a5685" translate="yes" xml:space="preserve">
          <source>Fortran assumed shape array and size function support in &lt;code&gt;numpy.f2py&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b756e1ed184faeae9981dd9378f750e8c6c0e04f" translate="yes" xml:space="preserve">
          <source>Fortran files</source>
          <target state="translated">Файлы Fortran</target>
        </trans-unit>
        <trans-unit id="443b7dd908046f637f8adbdcefe50ee302b6f087" translate="yes" xml:space="preserve">
          <source>Fortran order if all the inputs are Fortran, C otherwise.</source>
          <target state="translated">Заказ Fortran,если все входы-Fortran,C,в противном случае.</target>
        </trans-unit>
        <trans-unit id="0dbb13a4208640c43e953aa1ecfe0492f9b453d1" translate="yes" xml:space="preserve">
          <source>Fortran order.</source>
          <target state="translated">Заказ Фортрана.</target>
        </trans-unit>
        <trans-unit id="458144d44956123a91798b5242d7c298d549eb1b" translate="yes" xml:space="preserve">
          <source>Fortran source of module / subroutine to compile</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e6b7af163ec1d9df45d457b3365dd7a8bb154117" translate="yes" xml:space="preserve">
          <source>Fortran to Python Interface Generator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c97ded998a0ca595e9b4695a113a861855f88705" translate="yes" xml:space="preserve">
          <source>Fortran-contiguous arrays when data is stored column-wise, i.e. indexing of data as stored in memory starts from the lowest dimension;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3c103a2ce4fa5c4bdfbfca73532b43fd7c1242b6" translate="yes" xml:space="preserve">
          <source>Fortran-order</source>
          <target state="translated">Fortran-order</target>
        </trans-unit>
        <trans-unit id="01f074f9b2b7da2704c7bf16c64348fbe5aff689" translate="yes" xml:space="preserve">
          <source>Fortran/C routine signatures</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa529d42774f0768730f12bc0880f9965a988000" translate="yes" xml:space="preserve">
          <source>Forward bytes from a subprocess call to the console, without attempting to decode them.</source>
          <target state="translated">Переадресация байтов из вызова подпроцесса на консоль,без попыток их декодирования.</target>
        </trans-unit>
        <trans-unit id="ececb946a3ffd8fb7cf57101d577f7acf1341e58" translate="yes" xml:space="preserve">
          <source>Forward port changes in the release branch to release notes and release scripts, if any, to master branch.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2982346b57dba0536f8cd38d08e71e22e03b5068" translate="yes" xml:space="preserve">
          <source>Four values of the output are invalid: the first one comes from taking the square root of a negative number, the second from the division by zero, and the last two where the inputs were masked.</source>
          <target state="translated">Четыре значения выхода недействительны:первое происходит от получения квадратного корня отрицательного числа,второе-от деления на ноль,а два последних-от маскировки входов.</target>
        </trans-unit>
        <trans-unit id="f163a620e6be53409bc7d6c8a56980a06cc8552e" translate="yes" xml:space="preserve">
          <source>Fourier analysis is fundamentally a method for expressing a function as a sum of periodic components, and for recovering the function from those components. When both the function and its Fourier transform are replaced with discretized counterparts, it is called the discrete Fourier transform (DFT). The DFT has become a mainstay of numerical computing in part because of a very fast algorithm for computing it, called the Fast Fourier Transform (FFT), which was known to Gauss (1805) and was brought to light in its current form by Cooley and Tukey &lt;a href=&quot;#rfb1dc64dd6a5-ct&quot; id=&quot;id1&quot;&gt;[CT]&lt;/a&gt;. Press et al. &lt;a href=&quot;#rfb1dc64dd6a5-nr&quot; id=&quot;id2&quot;&gt;[NR]&lt;/a&gt; provide an accessible introduction to Fourier analysis and its applications.</source>
          <target state="translated">По сути, анализ Фурье - это метод выражения функции как суммы периодических компонентов и восстановления функции из этих компонентов. Когда и функция, и ее преобразование Фурье заменяются дискретными аналогами, это называется дискретным преобразованием Фурье (ДПФ). ДПФ стало опорой численных вычислений отчасти из-за очень быстрого алгоритма для его вычисления, называемого быстрым преобразованием Фурье (БПФ), которое было известно Гауссу (1805 г.) и в его нынешней форме было обнаружено Кули и Тьюки &lt;a href=&quot;#rfb1dc64dd6a5-ct&quot; id=&quot;id1&quot;&gt;[CT]&lt;/a&gt; . Press et al. &lt;a href=&quot;#rfb1dc64dd6a5-nr&quot; id=&quot;id2&quot;&gt;[NR]&lt;/a&gt; предоставляют доступное введение в анализ Фурье и его приложения.</target>
        </trans-unit>
        <trans-unit id="69fe683adb41f9ba1a3873187fd6c76482148e01" translate="yes" xml:space="preserve">
          <source>Fourier transform of &lt;code&gt;a&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
