<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="numpy">
    <body>
      <group id="numpy">
        <trans-unit id="55427a60a4bc7584f941291fc8f1c78e3b48892c" translate="yes" xml:space="preserve">
          <source>Fourteen C macros and fifteen C functions that can be used to write specialized typemaps, extensions, or inlined functions that handle cases not covered by the provided typemaps. Note that the macros and functions are coded specifically to work with the NumPy C/API regardless of NumPy version number, both before and after the deprecation of some aspects of the API after version 1.6.</source>
          <target state="translated">Четырнадцать макросов C и пятнадцать функций C,которые могут быть использованы для написания специализированных типовых карт,расширений или встраиваемых функций,которые обрабатывают случаи,не охваченные предоставленными типовыми картами.Обратите внимание,что макросы и функции закодированы специально для работы с NumPy C/API независимо от номера версии NumPy,как до,так и после удаления некоторых аспектов API после версии 1.6.</target>
        </trans-unit>
        <trans-unit id="a55119325a9e50ab95a500e00074b97b1b9e36d5" translate="yes" xml:space="preserve">
          <source>Fractional part of &lt;code&gt;x&lt;/code&gt;. This is a scalar if &lt;code&gt;x&lt;/code&gt; is a scalar.</source>
          <target state="translated">Дробная часть &lt;code&gt;x&lt;/code&gt; . Это скаляр, если &lt;code&gt;x&lt;/code&gt; - скаляр.</target>
        </trans-unit>
        <trans-unit id="3ef0af518168c89e00d0d671000eff79ef6d0866" translate="yes" xml:space="preserve">
          <source>Francis Hunt and Paul Johnson, On the Pareto Distribution of Sourceforge projects.</source>
          <target state="translated">Фрэнсис Хант и Пол Джонсон,&quot;О распределении проектов Sourceforge в Парето&quot;.</target>
        </trans-unit>
        <trans-unit id="1702d7b8bdd07fbea0c5cab99e1759e69160609f" translate="yes" xml:space="preserve">
          <source>Frequency bins for given FFT parameters.</source>
          <target state="translated">Бинты частоты для заданных параметров БПФ.</target>
        </trans-unit>
        <trans-unit id="8c7beab7a6d84d3a1004bcc75ccd72648a4866a0" translate="yes" xml:space="preserve">
          <source>Frobenius norm</source>
          <target state="translated">норма Фробения</target>
        </trans-unit>
        <trans-unit id="b496ebf456418bea6f72b4dd532369d14b955f9b" translate="yes" xml:space="preserve">
          <source>From Dalgaard page 83 &lt;a href=&quot;#r755c9bae090e-1&quot; id=&quot;id3&quot;&gt;[1]&lt;/a&gt;, suppose the daily energy intake for 11 women in kilojoules (kJ) is:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aeadfde385f544a91cc8eaeeffa0c5ba93e6dc7d" translate="yes" xml:space="preserve">
          <source>From Dalgaard page 83 &lt;a href=&quot;#r89f5270d198b-1&quot; id=&quot;id3&quot;&gt;[1]&lt;/a&gt;, suppose the daily energy intake for 11 women in kilojoules (kJ) is:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ddb8d23120bc74b1cfb060aa5332c0996e661cf6" translate="yes" xml:space="preserve">
          <source>From Dalgaard page 83 &lt;a href=&quot;#r9f872b3c913b-1&quot; id=&quot;id3&quot;&gt;[1]&lt;/a&gt;, suppose the daily energy intake for 11 women in kilojoules (kJ) is:</source>
          <target state="translated">На странице 83 &lt;a href=&quot;#r9f872b3c913b-1&quot; id=&quot;id3&quot;&gt;[1]&lt;/a&gt; Далгаарда предположим, что ежедневное потребление энергии для 11 женщин в килоджоулей (кДж) составляет:</target>
        </trans-unit>
        <trans-unit id="449b24b6007276ad9bb465db2968bb8f2f82cb23" translate="yes" xml:space="preserve">
          <source>From Dalgaard page 83 &lt;a href=&quot;#rb7c952f3992e-1&quot; id=&quot;id3&quot;&gt;[1]&lt;/a&gt;, suppose the daily energy intake for 11 women in kilojoules (kJ) is:</source>
          <target state="translated">На странице 83 &lt;a href=&quot;#rb7c952f3992e-1&quot; id=&quot;id3&quot;&gt;[1]&lt;/a&gt; Далгаарда предположим, что ежедневное потребление энергии для 11 женщин в килоджоулей (кДж) составляет:</target>
        </trans-unit>
        <trans-unit id="e91799328361ed7f1f3c997458139cffb3209540" translate="yes" xml:space="preserve">
          <source>From a 4x3 array the corner elements should be selected using advanced indexing. Thus all elements for which the column is one of &lt;code&gt;[0, 2]&lt;/code&gt; and the row is one of &lt;code&gt;[0, 3]&lt;/code&gt; need to be selected. To use advanced indexing one needs to select all elements &lt;em&gt;explicitly&lt;/em&gt;. Using the method explained previously one could write:</source>
          <target state="translated">Из массива 4x3 угловые элементы следует выбирать с помощью расширенной индексации. Таким образом &lt;code&gt;[0, 3]&lt;/code&gt; необходимо выбрать все элементы, для которых столбец является одним из &lt;code&gt;[0, 2]&lt;/code&gt; а строка - одним из [0, 3] . Чтобы использовать расширенное индексирование, необходимо &lt;em&gt;явно&lt;/em&gt; выделить все элементы . Используя метод, описанный ранее, можно написать:</target>
        </trans-unit>
        <trans-unit id="a91be0fd97aa12da8097d28986c00ba2a4f3a53c" translate="yes" xml:space="preserve">
          <source>From a Fortran routine signature F2PY generates a Python/C extension function that has the following signature:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f43663857b3b074086e6a5458d7eeb8cc710716c" translate="yes" xml:space="preserve">
          <source>From a date and time:</source>
          <target state="translated">От даты и времени:</target>
        </trans-unit>
        <trans-unit id="b27ac815b804369e0e908095a8f60fb839b9ffbc" translate="yes" xml:space="preserve">
          <source>From an array, select all rows which sum up to less or equal two:</source>
          <target state="translated">Из массива выберите все строки,сумма которых меньше или равна двум:</target>
        </trans-unit>
        <trans-unit id="0b1e37af40ab4883a1e4a8a3dc83bcc94bb649dc" translate="yes" xml:space="preserve">
          <source>From each row, a specific element should be selected. The row index is just &lt;code&gt;[0, 1, 2]&lt;/code&gt; and the column index specifies the element to choose for the corresponding row, here &lt;code&gt;[0, 1, 0]&lt;/code&gt;. Using both together the task can be solved using advanced indexing:</source>
          <target state="translated">Из каждой строки следует выбрать определенный элемент. Индекс строки равен &lt;code&gt;[0, 1, 2]&lt;/code&gt; а индекс столбца определяет элемент, который следует выбрать для соответствующей строки, здесь &lt;code&gt;[0, 1, 0]&lt;/code&gt; . Используя оба вместе, задачу можно решить с помощью расширенного индексирования:</target>
        </trans-unit>
        <trans-unit id="2bdc929241ee7611d7ce8654d5c0e7a97c5922e2" translate="yes" xml:space="preserve">
          <source>From existing data</source>
          <target state="translated">На основании имеющихся данных</target>
        </trans-unit>
        <trans-unit id="1978da17047230ecfb709900d093fe2bc00bb2a8" translate="yes" xml:space="preserve">
          <source>From now on &lt;a href=&quot;https://git-scm.com/&quot;&gt;git&lt;/a&gt; will know that &lt;code&gt;my-new-feature&lt;/code&gt; is related to the &lt;code&gt;my-new-feature&lt;/code&gt; branch in your own &lt;a href=&quot;https://github.com/numpy/numpy&quot;&gt;github&lt;/a&gt; repo. Subsequent push calls are then simplified to the following:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d7dc9b3626b3cb541c458a7c7758c637090adb4" translate="yes" xml:space="preserve">
          <source>From other objects</source>
          <target state="translated">От других объектов</target>
        </trans-unit>
        <trans-unit id="5dce71950093c2ccd6198a0075dc3e5ee84cb7ec" translate="yes" xml:space="preserve">
          <source>From scratch</source>
          <target state="translated">С нуля</target>
        </trans-unit>
        <trans-unit id="374969a1bf6cf09ab316c531b85ee98729ec817d" translate="yes" xml:space="preserve">
          <source>From the command line:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e8689c1f53f242e3e2ed351ba13d4443b972a335" translate="yes" xml:space="preserve">
          <source>From the output above, we can see that every value in &lt;code&gt;img[:,:,0]&lt;/code&gt; is an integer value between 0 and 255, representing the level of red in each corresponding image pixel (keep in mind that this might be different if you use your own image instead of &lt;a href=&quot;https://docs.scipy.org/doc/scipy/reference/generated/scipy.misc.face.html#scipy.misc.face&quot;&gt;&lt;code&gt;scipy.misc.face&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="487083148a4854e5ec264b4e7603e6d383b8513e" translate="yes" xml:space="preserve">
          <source>From time to time you may want to pull down the latest code. Do this with:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="541d68d9d4a26a74b3b1aec38602641c99c42b4f" translate="yes" xml:space="preserve">
          <source>Full broadcasting support for &lt;code&gt;np.cross&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f6cd09bf0f40761ab28ccaa4cab2a4c6c336752" translate="yes" xml:space="preserve">
          <source>Full indirect sort</source>
          <target state="translated">Полный косвенный сорт</target>
        </trans-unit>
        <trans-unit id="b5dd204ac7b63984bfca215999235cdddc1cbe34" translate="yes" xml:space="preserve">
          <source>Full indirect sort.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d106cfe968d6ee1cdc60bee01550735688b85f7" translate="yes" xml:space="preserve">
          <source>Full sort.</source>
          <target state="translated">Полный сорт.</target>
        </trans-unit>
        <trans-unit id="733bce60654becd4d4e1700d743ab7573d5f2742" translate="yes" xml:space="preserve">
          <source>Full sorting</source>
          <target state="translated">Полная сортировка</target>
        </trans-unit>
        <trans-unit id="b375e36a5e2c847719599e1c9bc607f532495b26" translate="yes" xml:space="preserve">
          <source>Function &lt;code&gt;median&lt;/code&gt; used with &lt;code&gt;overwrite_input&lt;/code&gt; only partially sorts array</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b35686e8529228454146ad9f9eb6c40fa0abbf7c" translate="yes" xml:space="preserve">
          <source>Function and macro call style: &lt;code&gt;foo(a, b, c)&lt;/code&gt;, no space before the open paren, no spaces inside the parens, no spaces before commas, one space after each comma.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f14045db7fd843c69383648cf94f75fb3d176a15" translate="yes" xml:space="preserve">
          <source>Function call</source>
          <target state="translated">Вызов функции</target>
        </trans-unit>
        <trans-unit id="5fafc2ca93d61a962accac1563a05d9b48e0a23a" translate="yes" xml:space="preserve">
          <source>Function decorator to apply certain suppressions to a whole function.</source>
          <target state="translated">Декоратор функций для применения определенных подавлений к целой функции.</target>
        </trans-unit>
        <trans-unit id="1ace8a404ff1b1cae179e78198d969ee763553f5" translate="yes" xml:space="preserve">
          <source>Function definition style: function name in column 1, outermost curly braces in column 1, blank line after local variable declarations:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eaf873f24ebe960e5f8ab96d1bf1dafec8236126" translate="yes" xml:space="preserve">
          <source>Function documentation</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6611eada8817f5f656a38dbcf1f891cb71be30b3" translate="yes" xml:space="preserve">
          <source>Function operating on ndarrays.</source>
          <target state="translated">Функция,работающая на ndarrays.</target>
        </trans-unit>
        <trans-unit id="7fb4f2de4dfb1639014358c3b7015d9c6a5f5d6b" translate="yes" xml:space="preserve">
          <source>Function pointer from &lt;a href=&quot;#c.NpyIter_GetIterNext&quot;&gt;&lt;code&gt;NpyIter_GetIterNext&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">Указатель на функцию из &lt;a href=&quot;#c.NpyIter_GetIterNext&quot;&gt; &lt;code&gt;NpyIter_GetIterNext&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="636b3b392dcabee45d972282bc714f124a2984ee" translate="yes" xml:space="preserve">
          <source>Function that converts a float array to float. Default is &lt;a href=&quot;https://docs.python.org/dev/library/functions.html#float&quot;&gt;&lt;code&gt;float&lt;/code&gt;&lt;/a&gt;. Note that this does not seem to do anything useful in the current implementation.</source>
          <target state="translated">Функция, преобразующая массив с плавающей запятой в плавающий. По умолчанию - &lt;a href=&quot;https://docs.python.org/dev/library/functions.html#float&quot;&gt; &lt;code&gt;float&lt;/code&gt; &lt;/a&gt; . Обратите внимание, что это, похоже, не делает ничего полезного в текущей реализации.</target>
        </trans-unit>
        <trans-unit id="25f491198ced438a979dee0c06f7b99f4c27522c" translate="yes" xml:space="preserve">
          <source>Function that converts a float or float array to an integer or integer array. Default is &lt;a href=&quot;https://docs.python.org/dev/library/functions.html#int&quot;&gt;&lt;code&gt;int&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Функция, которая преобразует массив с плавающей точкой или с плавающей запятой в целочисленный или целочисленный массив. По умолчанию &lt;a href=&quot;https://docs.python.org/dev/library/functions.html#int&quot;&gt; &lt;code&gt;int&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c1c65cb38bc5533518bfad836c738613691b12bd" translate="yes" xml:space="preserve">
          <source>Function that converts a single float to a string. Default is &lt;code&gt;lambda v:'%24.16e' %v&lt;/code&gt;.</source>
          <target state="translated">Функция, преобразующая одиночное число с плавающей запятой в строку. По умолчанию &lt;code&gt;lambda v:'%24.16e' %v&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="49e035248ad61f94c49b3411ced40a15d03e994b" translate="yes" xml:space="preserve">
          <source>Function that converts an integer or integer array to a float or float array. Default is &lt;a href=&quot;https://docs.python.org/dev/library/functions.html#float&quot;&gt;&lt;code&gt;float&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Функция, преобразующая целочисленный или целочисленный массив в массив с плавающей или плавающей запятой. По умолчанию - &lt;a href=&quot;https://docs.python.org/dev/library/functions.html#float&quot;&gt; &lt;code&gt;float&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="81aebc7824dc558f5740b2294a8d328bfb265c12" translate="yes" xml:space="preserve">
          <source>Function to apply on the &amp;ldquo;field&amp;rdquo; dimension. This function must support an &lt;code&gt;axis&lt;/code&gt; argument, like np.mean, np.sum, etc.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7cdbff65d2dcd6dbb1f176839d343d5cd6740b77" translate="yes" xml:space="preserve">
          <source>Function to be used to pretty print arrays. The function should expect a single array argument and return a string of the representation of the array. If None, the function is reset to the default NumPy function to print arrays.</source>
          <target state="translated">Функция,используемая для красивых массивов печати.Функция должна ожидать единственный аргумент массива и возвращать строку представления массива.Если None,то для печати массивов функция сбрасывается в функцию NumPy по умолчанию.</target>
        </trans-unit>
        <trans-unit id="2e5428e59d421faf071ea47a590fb561ece5a39d" translate="yes" xml:space="preserve">
          <source>Function to calculate only the edges of the bins used by the &lt;a href=&quot;generated/numpy.histogram#numpy.histogram&quot;&gt;&lt;code&gt;histogram&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">Функция для вычисления только краев интервалов, используемых функцией &lt;a href=&quot;generated/numpy.histogram#numpy.histogram&quot;&gt; &lt;code&gt;histogram&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ecfa9e590ef0d3ed65da85a7cdda1af66b824ea3" translate="yes" xml:space="preserve">
          <source>Function to calculate only the edges of the bins used by the &lt;a href=&quot;numpy.histogram#numpy.histogram&quot;&gt;&lt;code&gt;histogram&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">Функция для вычисления только краев интервалов, используемых функцией &lt;a href=&quot;numpy.histogram#numpy.histogram&quot;&gt; &lt;code&gt;histogram&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3daae79264ded053c68caf5a77aad1db49558306" translate="yes" xml:space="preserve">
          <source>Function to call upon floating-point errors (&amp;lsquo;call&amp;rsquo;-mode) or object whose &amp;lsquo;write&amp;rsquo; method is used to log such message (&amp;lsquo;log&amp;rsquo;-mode).</source>
          <target state="translated">Функция для вызова при ошибках с плавающей запятой (режим &amp;laquo;call&amp;raquo;) или объект, чей метод &amp;laquo;записи&amp;raquo; используется для регистрации такого сообщения (режим &amp;laquo;журнала&amp;raquo;).</target>
        </trans-unit>
        <trans-unit id="936e3c682ce34cc0f0f7b3b6776919fc933d5fe1" translate="yes" xml:space="preserve">
          <source>Function which returns a masked inner loop for the ufunc</source>
          <target state="translated">Функция,которая возвращает маскированный внутренний цикл для ufunc.</target>
        </trans-unit>
        <trans-unit id="deb4e042b9d6249db97e6680ab8276b237985bd9" translate="yes" xml:space="preserve">
          <source>Functional programming</source>
          <target state="translated">Функциональное программирование</target>
        </trans-unit>
        <trans-unit id="2b961dea1dc0c60ddf9a2c8e9d090f6f7d082483" translate="yes" xml:space="preserve">
          <source>Functions</source>
          <target state="translated">Functions</target>
        </trans-unit>
        <trans-unit id="5a31942f8f4b1c24c2cf2f6e11f8f96977c918a6" translate="yes" xml:space="preserve">
          <source>Functions For Iteration</source>
          <target state="translated">Функции для итерации</target>
        </trans-unit>
        <trans-unit id="c9d64db1884b2fd4f353a105874e4c3957322b65" translate="yes" xml:space="preserve">
          <source>Functions and Methods Overview</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf6da2fb68f3db64f0a7a53228a8721f52f6134f" translate="yes" xml:space="preserve">
          <source>Functions available from numpy.ma.testutils have changed</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b7916ccc48b7ce0f25ff69e01c25e39ce11de03b" translate="yes" xml:space="preserve">
          <source>Functions implementing internal features. Not all of these function pointers must be defined for a given type. The required members are &lt;code&gt;nonzero&lt;/code&gt;, &lt;code&gt;copyswap&lt;/code&gt;, &lt;code&gt;copyswapn&lt;/code&gt;, &lt;code&gt;setitem&lt;/code&gt;, &lt;code&gt;getitem&lt;/code&gt;, and &lt;code&gt;cast&lt;/code&gt;. These are assumed to be non- &lt;code&gt;NULL&lt;/code&gt; and &lt;code&gt;NULL&lt;/code&gt; entries will cause a program crash. The other functions may be &lt;code&gt;NULL&lt;/code&gt; which will just mean reduced functionality for that data-type. (Also, the nonzero function will be filled in with a default function if it is &lt;code&gt;NULL&lt;/code&gt; when you register a user-defined data-type).</source>
          <target state="translated">Функции, реализующие внутренние функции. Не все эти указатели на функции должны быть определены для данного типа. Обязательными членами являются &lt;code&gt;nonzero&lt;/code&gt; , &lt;code&gt;copyswap&lt;/code&gt; , &lt;code&gt;copyswapn&lt;/code&gt; , &lt;code&gt;setitem&lt;/code&gt; , &lt;code&gt;getitem&lt;/code&gt; и &lt;code&gt;cast&lt;/code&gt; . Предполагается, что они не являются &lt;code&gt;NULL&lt;/code&gt; , и записи &lt;code&gt;NULL&lt;/code&gt; вызовут сбой программы. Другие функции могут иметь &lt;code&gt;NULL&lt;/code&gt; что будет означать только ограниченную функциональность для этого типа данных. (Кроме того, ненулевая функция будет заполнена функцией по умолчанию, если она имеет &lt;code&gt;NULL&lt;/code&gt; когда вы регистрируете определяемый пользователем тип данных).</target>
        </trans-unit>
        <trans-unit id="f48c175b4673c0bc456bc9f1ba654da2d9542a5c" translate="yes" xml:space="preserve">
          <source>Functions in &lt;code&gt;numpy.random&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="516c584b732d36ebda7d25fae38b326dc6d202ae" translate="yes" xml:space="preserve">
          <source>Functions in numpy.random</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c724fd9678ed45fd313d6c7db38a089943643ca5" translate="yes" xml:space="preserve">
          <source>Functions may be listed without descriptions, and this is preferable if the functionality is clear from the function name:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="786d8b1defa125829799bc249caf1adda1184b6a" translate="yes" xml:space="preserve">
          <source>Functions returning an index along an axis, like &lt;a href=&quot;numpy.argsort#numpy.argsort&quot;&gt;&lt;code&gt;argsort&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;numpy.argpartition#numpy.argpartition&quot;&gt;&lt;code&gt;argpartition&lt;/code&gt;&lt;/a&gt;, produce suitable indices for this function.</source>
          <target state="translated">Функции, возвращающие индекс по оси, такие как &lt;a href=&quot;numpy.argsort#numpy.argsort&quot;&gt; &lt;code&gt;argsort&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;numpy.argpartition#numpy.argpartition&quot;&gt; &lt;code&gt;argpartition&lt;/code&gt; &lt;/a&gt; , создают подходящие индексы для этой функции.</target>
        </trans-unit>
        <trans-unit id="7961218e053edec8b5fc62ef3005af10a3415803" translate="yes" xml:space="preserve">
          <source>Functions that are also in the numpy namespace and return matrices</source>
          <target state="translated">Функции,которые также находятся в нумерованном пространстве имён и возвратных матрицах</target>
        </trans-unit>
        <trans-unit id="95335a3a51e2f80868a95521fb5668b275263818" translate="yes" xml:space="preserve">
          <source>Functions that don&amp;rsquo;t accept keyword arguments should be written as:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f7888c5dcdff069b34a3486459892edd2f262c97" translate="yes" xml:space="preserve">
          <source>Functions with keyword arguments</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6020fb8e5272b3356bebe72ae19a144383754b4e" translate="yes" xml:space="preserve">
          <source>Functions without keyword arguments</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6dad1764839322eb03eab6b07936a589482f90c1" translate="yes" xml:space="preserve">
          <source>Fundraising</source>
          <target state="translated">Fundraising</target>
        </trans-unit>
        <trans-unit id="6da76886d65d87e4650f5c14ec791f8c2f676112" translate="yes" xml:space="preserve">
          <source>Further explanation of the &lt;code&gt;fmt&lt;/code&gt; parameter (&lt;code&gt;%[flag]width[.precision]specifier&lt;/code&gt;):</source>
          <target state="translated">Дальнейшее объяснение параметра &lt;code&gt;fmt&lt;/code&gt; ( &lt;code&gt;%[flag]width[.precision]specifier&lt;/code&gt; ):</target>
        </trans-unit>
        <trans-unit id="3abcbfb793b7e40f09b0f5479b45936952f0ec59" translate="yes" xml:space="preserve">
          <source>Further improvements to &lt;code&gt;ctypes&lt;/code&gt; support in &lt;code&gt;np.ctypeslib&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b7e1185b0b79852815db7f42a86a47fec5e9990" translate="yes" xml:space="preserve">
          <source>Further improvements to &lt;code&gt;ctypes&lt;/code&gt; support in &lt;code&gt;numpy.ctypeslib&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e44c8b638baa470dbb5f127964c092cc77ea465" translate="yes" xml:space="preserve">
          <source>Further reading</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fad9659f7e2980db9b405ad20b3c5294ccc96416" translate="yes" xml:space="preserve">
          <source>Further, note how &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; are combined:</source>
          <target state="translated">Кроме того, обратите внимание, как комбинируются &lt;code&gt;x&lt;/code&gt; и &lt;code&gt;y&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="9af0aaaf4de03972531671e0eb9bb87000ba4e1d" translate="yes" xml:space="preserve">
          <source>Furthermore, arrays created with this function often contain self overlapping memory, so that two elements are identical. Vectorized write operations on such arrays will typically be unpredictable. They may even give different results for small, large, or transposed arrays. Since writing to these arrays has to be tested and done with great care, you may want to use &lt;code&gt;writeable=False&lt;/code&gt; to avoid accidental write operations.</source>
          <target state="translated">Более того, массивы, созданные с помощью этой функции, часто содержат самоперекрывающуюся память, поэтому два элемента идентичны. Векторизованные операции записи в такие массивы обычно непредсказуемы. Они могут даже давать разные результаты для маленьких, больших или транспонированных массивов. Поскольку запись в эти массивы должна быть проверена и выполняться с большой осторожностью, вы можете использовать &lt;code&gt;writeable=False&lt;/code&gt; , чтобы избежать случайных операций записи.</target>
        </trans-unit>
        <trans-unit id="12143faa25aabfe7fe468016abec86297c6fcf15" translate="yes" xml:space="preserve">
          <source>Furthermore, numpy now provides a new function &lt;a href=&quot;#numpy.lib.recfunctions.structured_to_unstructured&quot;&gt;&lt;code&gt;numpy.lib.recfunctions.structured_to_unstructured&lt;/code&gt;&lt;/a&gt; which is a safer and more efficient alternative for users who wish to convert structured arrays to unstructured arrays, as the view above is often indeded to do. This function allows safe conversion to an unstructured type taking into account padding, often avoids a copy, and also casts the datatypes as needed, unlike the view. Code such as:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f84a7ca85b2fada9bdf949e608abf006366bb0e" translate="yes" xml:space="preserve">
          <source>Furthermore, the callback function is of the same type as before, &lt;code&gt;void (*foo)(char **args, intp *dimensions, intp *steps, void *func)&lt;/code&gt;. When invoked, &lt;code&gt;args&lt;/code&gt; is a list of length &lt;code&gt;nargs&lt;/code&gt; containing the data of all input/output arguments. For a scalar elementary function, &lt;code&gt;steps&lt;/code&gt; is also of length &lt;code&gt;nargs&lt;/code&gt;, denoting the strides used for the arguments. &lt;code&gt;dimensions&lt;/code&gt; is a pointer to a single integer defining the size of the axis to be looped over.</source>
          <target state="translated">Кроме того, функция обратного вызова имеет тот же тип, что и раньше, &lt;code&gt;void (*foo)(char **args, intp *dimensions, intp *steps, void *func)&lt;/code&gt; . При вызове, &lt;code&gt;args&lt;/code&gt; список длины &lt;code&gt;nargs&lt;/code&gt; , содержащих данные всех входных / выходных параметров. Для скалярной элементарной функции &lt;code&gt;steps&lt;/code&gt; также имеют длину &lt;code&gt;nargs&lt;/code&gt; , обозначающую шаги, используемые для аргументов. &lt;code&gt;dimensions&lt;/code&gt; - это указатель на одно целое число, определяющее размер оси, по которой будет проходить цикл.</target>
        </trans-unit>
        <trans-unit id="c462e5cfdac7c4df78636f70346d506c3e424749" translate="yes" xml:space="preserve">
          <source>Furthermore, using the &lt;code&gt;ndim&lt;/code&gt; property of this array, we can see that</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="22552b8bf29fce0c52d5fcd39548010b9e76338c" translate="yes" xml:space="preserve">
          <source>Future Changes</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="acb0dc3b9f8b3f5bdca8fc1d87183e1bba912790" translate="yes" xml:space="preserve">
          <source>Future changes</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b7285e0cef5e4daf805eb913ea140d9a03dc8d07" translate="yes" xml:space="preserve">
          <source>Future value</source>
          <target state="translated">Будущая стоимость</target>
        </trans-unit>
        <trans-unit id="0d44fa727f9b3f4d912a98a3e170b462f52557e6" translate="yes" xml:space="preserve">
          <source>Future value (default = 0)</source>
          <target state="translated">Будущее значение (по умолчанию=0)</target>
        </trans-unit>
        <trans-unit id="ba4092807d491bea64803fff0c7e477eac372847" translate="yes" xml:space="preserve">
          <source>Future values. If all input is scalar, returns a scalar float. If any input is array_like, returns future values for each input element. If multiple inputs are array_like, they all must have the same shape.</source>
          <target state="translated">Будущие ценности.Если все входные данные являются скалярными,возвращается скалярный плавающий диск.Если любой вход является массивом_подобным,возвращает будущие значения для каждого входного элемента.Если несколько входов похожи на массив_,то все они должны иметь одинаковую форму.</target>
        </trans-unit>
        <trans-unit id="722af3dc654f5b03462276f1ddc84a2ecf2baa12" translate="yes" xml:space="preserve">
          <source>Future very uncertain: it&amp;rsquo;s the only part of Scipy not ported to Python 3 and is effectively deprecated in favor of Cython.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d739c24bbd3b77640efa7aa653675284eae750ca" translate="yes" xml:space="preserve">
          <source>FutureWarning to changed behavior</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a6cee77152a751b028de81f7755bdc87bacc5925" translate="yes" xml:space="preserve">
          <source>FutureWarnings</source>
          <target state="translated">FutureWarnings</target>
        </trans-unit>
        <trans-unit id="a36a6718f54524d846894fb04b5b885b4e43e63b" translate="yes" xml:space="preserve">
          <source>G</source>
          <target state="translated">G</target>
        </trans-unit>
        <trans-unit id="2f44d78e0bf8d58385fdcde50f5d5e7baff3d944" translate="yes" xml:space="preserve">
          <source>G. H. Golub and C. F. Van Loan, &lt;em&gt;Matrix Computations&lt;/em&gt;, Baltimore, MD, Johns Hopkins University Press, 1985, pg. 15</source>
          <target state="translated">Голубь Г. и Ван Лоан, &lt;em&gt;Матричные вычисления&lt;/em&gt; , Балтимор, Мэриленд, издательство Университета Джона Хопкинса, 1985, стр. 15</target>
        </trans-unit>
        <trans-unit id="cbd53064adb7ff38d27c336291f9eaba7270aacd" translate="yes" xml:space="preserve">
          <source>G. Strang, &amp;ldquo;Linear Algebra and Its Applications, 2nd Edition,&amp;rdquo; Academic Press, pg. 182, 1980.</source>
          <target state="translated">Г. Стрэнг, &amp;laquo;Линейная алгебра и ее приложения, 2-е издание&amp;raquo;, Academic Press, стр. 182, 1980 г.</target>
        </trans-unit>
        <trans-unit id="0fee945837fcad5efdf449e24366c4e1f7b65d37" translate="yes" xml:space="preserve">
          <source>G. Strang, &lt;em&gt;Linear Algebra and Its Applications&lt;/em&gt;, 2nd Ed., Orlando, FL, Academic Press, Inc., 1980, Various pp.</source>
          <target state="translated">Г. Стрэнг, &lt;em&gt;Линейная алгебра и ее приложения&lt;/em&gt; , 2-е изд., Орландо, Флорида, Academic Press, Inc., 1980, стр.</target>
        </trans-unit>
        <trans-unit id="4d62050a6efa830b0646c86cf65d2a276c097206" translate="yes" xml:space="preserve">
          <source>G. Strang, &lt;em&gt;Linear Algebra and Its Applications&lt;/em&gt;, 2nd Ed., Orlando, FL, Academic Press, Inc., 1980, pg. 22.</source>
          <target state="translated">Г. Стрэнг, &lt;em&gt;Линейная алгебра и ее приложения&lt;/em&gt; , 2-е изд., Орландо, Флорида, Academic Press, Inc., 1980, стр. 22.</target>
        </trans-unit>
        <trans-unit id="8a5685424a4a906ee371dfacdea6a5b47dc7b3ff" translate="yes" xml:space="preserve">
          <source>G. Strang, &lt;em&gt;Linear Algebra and Its Applications&lt;/em&gt;, 2nd Ed., Orlando, FL, Academic Press, Inc., 1980, pg. 222.</source>
          <target state="translated">Г. Стрэнг, &lt;em&gt;Линейная алгебра и ее приложения&lt;/em&gt; , 2-е изд., Орландо, Флорида, Academic Press, Inc., 1980, стр. 222.</target>
        </trans-unit>
        <trans-unit id="db937a0ed23b9cf712fadda8ce2d53e90fb3fb34" translate="yes" xml:space="preserve">
          <source>G. Strang, &lt;em&gt;Linear Algebra and Its Applications&lt;/em&gt;, 2nd Ed., Orlando, FL, Academic Press, Inc., 1980, pp. 139-142.</source>
          <target state="translated">Г. Стрэнг, &lt;em&gt;Линейная алгебра и ее приложения&lt;/em&gt; , 2-е изд., Орландо, Флорида, Academic Press, Inc., 1980, стр. 139&amp;ndash;142.</target>
        </trans-unit>
        <trans-unit id="d923f5047de7db54bb0494345e02c3e60011f631" translate="yes" xml:space="preserve">
          <source>G. Strang, &lt;em&gt;Linear Algebra and Its Applications&lt;/em&gt;, Orlando, FL, Academic Press, Inc., 1980, pg. 285.</source>
          <target state="translated">Г. Стрэнг, &lt;em&gt;Линейная алгебра и ее приложения&lt;/em&gt; , Орландо, Флорида, Academic Press, Inc., 1980, стр. 285.</target>
        </trans-unit>
        <trans-unit id="2fe46435d8800606efbbb4738ea49577e004f01c" translate="yes" xml:space="preserve">
          <source>GUfuncs on empty arrays and NpyIter axis removal</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e8a5e73fba8665db50a8e3577ecf8eb28b80e421" translate="yes" xml:space="preserve">
          <source>Gammas</source>
          <target state="translated">Gammas</target>
        </trans-unit>
        <trans-unit id="027498996e260dbd9c33778f3168019dfde3d4cc" translate="yes" xml:space="preserve">
          <source>Gauss-Chebyshev quadrature.</source>
          <target state="translated">Квадраты Гаусса-Чебышева.</target>
        </trans-unit>
        <trans-unit id="372d4c8be97b59c2965354454eaf80e844e74e50" translate="yes" xml:space="preserve">
          <source>Gauss-Hermite quadrature.</source>
          <target state="translated">Квадраты Гаусса-Хермита.</target>
        </trans-unit>
        <trans-unit id="90aa100cf157ec594ce20f650ca9a1d9019f03be" translate="yes" xml:space="preserve">
          <source>Gauss-HermiteE quadrature.</source>
          <target state="translated">Квадраты Гаусса-Хермита.</target>
        </trans-unit>
        <trans-unit id="9d10f081127b50e1f17e0a5c3971976017840cbe" translate="yes" xml:space="preserve">
          <source>Gauss-Laguerre quadrature.</source>
          <target state="translated">Квадратура Гаусса-Лагера.</target>
        </trans-unit>
        <trans-unit id="88f1f37c698b12eaffdc9bbccbc77d8b6246ccd8" translate="yes" xml:space="preserve">
          <source>Gauss-Legendre quadrature.</source>
          <target state="translated">Квадратура Гаусса-Легенды.</target>
        </trans-unit>
        <trans-unit id="9239ee2cda84eca4c3440e2a7b50148af67da3d4" translate="yes" xml:space="preserve">
          <source>General</source>
          <target state="translated">General</target>
        </trans-unit>
        <trans-unit id="0cffb2d4275e42dba57746961ea67052aaeef334" translate="yes" xml:space="preserve">
          <source>General Broadcasting Rules</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a2ff3c8e4686a4c021328dd784ede1cb72d7755f" translate="yes" xml:space="preserve">
          <source>General Purpose Equivalents</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d731fc16d10c539de3eb06ab7ca854e8f4dd60e" translate="yes" xml:space="preserve">
          <source>General check of Python Type</source>
          <target state="translated">Общая проверка типа питона</target>
        </trans-unit>
        <trans-unit id="1b31f308f2ce85a33700b95c3da21fcb018ed716" translate="yes" xml:space="preserve">
          <source>General purpose exception class, derived from Python&amp;rsquo;s exception.Exception class, programmatically raised in linalg functions when a Linear Algebra-related condition would prevent further correct execution of the function.</source>
          <target state="translated">Класс исключения общего назначения, производный от класса Python exception.Exception, программно вызываемый в функциях linalg, когда условие, связанное с линейной алгеброй, препятствует дальнейшему правильному выполнению функции.</target>
        </trans-unit>
        <trans-unit id="6a5d5977ff7dabeb26104f13133251775857ac24" translate="yes" xml:space="preserve">
          <source>Generalised matrix product, using second last dimension of &lt;code&gt;b&lt;/code&gt;.</source>
          <target state="translated">Обобщенное матричное произведение с использованием второго последнего измерения &lt;code&gt;b&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="172636dd07a5cf344fc718f14e5f8bac9163a8d1" translate="yes" xml:space="preserve">
          <source>Generalized &lt;code&gt;flip&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d7eab60b5c5966c3521dbaae99dc8efbf97f6cb" translate="yes" xml:space="preserve">
          <source>Generalized Ufuncs will now unlock the GIL</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9332c2d546d63dda92dba61cafe3df82f0dd8b19" translate="yes" xml:space="preserve">
          <source>Generalized Universal Function API</source>
          <target state="translated">Обобщенный универсальный API функции</target>
        </trans-unit>
        <trans-unit id="e299d19ac7292c1bf7156bae2d6dd21bd9fba291" translate="yes" xml:space="preserve">
          <source>Generalized axis support for median and percentile</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="04b50941190dd87fa655dc29ac5df20dd7d7c66f" translate="yes" xml:space="preserve">
          <source>Generalized function class.</source>
          <target state="translated">Обобщенный класс функции.</target>
        </trans-unit>
        <trans-unit id="1a1bc0e8d9d246a721e301167a79c68d6cdef5b2" translate="yes" xml:space="preserve">
          <source>Generalized ufunc signatures now allow fixed-size dimensions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d2d28b03b171fb860aee83a82f532e58c4e9fba3" translate="yes" xml:space="preserve">
          <source>Generalized ufunc signatures now allow flexible dimensions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0046ab62e86cdc207bdc51ed66f39ae439778565" translate="yes" xml:space="preserve">
          <source>Generalized ufuncs</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="66a042cdeb42f3ae672017ab4c672646772ccf00" translate="yes" xml:space="preserve">
          <source>Generalized ufuncs are used internally in many linalg functions, and in the testing suite; the examples below are taken from these. For ufuncs that operate on scalars, the signature is &lt;code&gt;None&lt;/code&gt;, which is equivalent to &amp;lsquo;()&amp;rsquo; for every argument.</source>
          <target state="translated">Обобщенные ufuncs используются внутри многих функций linalg и в наборе тестирования; приведенные ниже примеры взяты из них. Для ufuncs, которые работают со скалярами, подпись &lt;code&gt;None&lt;/code&gt; , что эквивалентно '()' для каждого аргумента.</target>
        </trans-unit>
        <trans-unit id="b0078c3e5a20e2fad81f2acb827abe758030ac9d" translate="yes" xml:space="preserve">
          <source>Generalized ufuncs are used internally in many linalg functions, and in the testing suite; the examples below are taken from these. For ufuncs that operate on scalars, the signature is None, which is equivalent to &amp;lsquo;()&amp;rsquo; for every argument.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf9c0fe98002f4322da923b10684f6d5d099ff33" translate="yes" xml:space="preserve">
          <source>Generalized ufuncs now accept &lt;code&gt;axes&lt;/code&gt;, &lt;code&gt;axis&lt;/code&gt; and &lt;code&gt;keepdims&lt;/code&gt; arguments</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d96ae300222cf76379f354819a4df06d3fbfa490" translate="yes" xml:space="preserve">
          <source>Generalized universal function signature, e.g., &lt;code&gt;(m,n),(n)-&amp;gt;(m)&lt;/code&gt; for vectorized matrix-vector multiplication. If provided, &lt;code&gt;pyfunc&lt;/code&gt; will be called with (and expected to return) arrays with shapes given by the size of corresponding core dimensions. By default, &lt;code&gt;pyfunc&lt;/code&gt; is assumed to take scalars as input and output.</source>
          <target state="translated">Обобщенная универсальная сигнатура функции, например, &lt;code&gt;(m,n),(n)-&amp;gt;(m)&lt;/code&gt; для векторизованного умножения матрицы на вектор. Если предоставлено, &lt;code&gt;pyfunc&lt;/code&gt; будет вызываться с (и должен возвращать) массивы с формами, заданными размером соответствующих основных размеров. По умолчанию предполагается , что &lt;code&gt;pyfunc&lt;/code&gt; принимает скаляры в качестве ввода и вывода.</target>
        </trans-unit>
        <trans-unit id="4bdfd56723e2a4630d0aa40f0eab7e7e821379e3" translate="yes" xml:space="preserve">
          <source>Generally speaking, what is returned when index arrays are used is an array with the same shape as the index array, but with the type and values of the array being indexed. As an example, we can use a multidimensional index array instead:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2257faa28ea2af0838b36329ac81b4299b5a11a1" translate="yes" xml:space="preserve">
          <source>Generally, the file needs to be generated during the build, since it needs some information known at build time only (e.g. prefix). This is mostly automatic if one uses the &lt;a href=&quot;#numpy.distutils.misc_util.Configuration&quot;&gt;&lt;code&gt;Configuration&lt;/code&gt;&lt;/a&gt; method &lt;code&gt;add_npy_pkg_config&lt;/code&gt;. Assuming we have a template file foo.ini.in as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="57b3bfe4a96aaf1f0210aadbf43dc393e3a362c6" translate="yes" xml:space="preserve">
          <source>Generally, the file needs to be generated during the build, since it needs some information known at build time only (e.g. prefix). This is mostly automatic if one uses the &lt;code&gt;Configuration&lt;/code&gt; method &lt;code&gt;add_npy_pkg_config&lt;/code&gt;. Assuming we have a template file foo.ini.in as follows:</source>
          <target state="translated">Как правило, файл необходимо сгенерировать во время сборки, поскольку ему нужна некоторая информация, известная только во время сборки (например, префикс). В основном это происходит автоматически, если используется метод &lt;code&gt;Configuration&lt;/code&gt; &lt;code&gt;add_npy_pkg_config&lt;/code&gt; . Предположим, у нас есть файл шаблона foo.ini.in следующим образом:</target>
        </trans-unit>
        <trans-unit id="ba56532a4a3fb8146e876e1d3659dfdac724a189" translate="yes" xml:space="preserve">
          <source>Generate a 1 by 3 array with 3 different lower bounds</source>
          <target state="translated">Сгенерировать массив 1 на 3 с 3 различными нижними границами</target>
        </trans-unit>
        <trans-unit id="3724c74e69c85b7924eab36b9e17078ea85e817c" translate="yes" xml:space="preserve">
          <source>Generate a 1 x 3 array with 3 different upper bounds</source>
          <target state="translated">Генерация массива 1 x 3 с 3 различными верхними границами</target>
        </trans-unit>
        <trans-unit id="c78b4920f6305013e33283131f3991e4d5dda157" translate="yes" xml:space="preserve">
          <source>Generate a 2 by 4 array using broadcasting with dtype of uint8</source>
          <target state="translated">Сгенерировать массив 2 на 4,используя широковещательное вещание с типом uint8.</target>
        </trans-unit>
        <trans-unit id="52ec8bca285ae5da030ea4680d276692f61c3804" translate="yes" xml:space="preserve">
          <source>Generate a 2 x 4 array of ints between 0 and 4, inclusive:</source>
          <target state="translated">Генерируйте массив 2 x 4 дюймов от 0 до 4 включительно:</target>
        </trans-unit>
        <trans-unit id="9e541c44f7aa5d7ed7acb09f3c0fe019e268af5e" translate="yes" xml:space="preserve">
          <source>Generate a Chebyshev series with given roots.</source>
          <target state="translated">Генерируйте чебышевскую серию с заданными корнями.</target>
        </trans-unit>
        <trans-unit id="0c791c1439e16e2fd0efb50c6644249b5b3eebb5" translate="yes" xml:space="preserve">
          <source>Generate a Hermite series with given roots.</source>
          <target state="translated">Создать серию &quot;Эрмита&quot; с заданными корнями.</target>
        </trans-unit>
        <trans-unit id="8bd121a27d585c3734742539ee143a52ac9b73de" translate="yes" xml:space="preserve">
          <source>Generate a HermiteE series with given roots.</source>
          <target state="translated">Создать серию HermiteE с заданными корнями.</target>
        </trans-unit>
        <trans-unit id="a9d697582320e7c884bbfd6a03995e4b278f2c74" translate="yes" xml:space="preserve">
          <source>Generate a Laguerre series with given roots.</source>
          <target state="translated">Создать серию Laguerre с заданными корнями.</target>
        </trans-unit>
        <trans-unit id="9fd152ea5ebdb08e6cd481a5737f68bdf9d18ad6" translate="yes" xml:space="preserve">
          <source>Generate a Legendre series with given roots.</source>
          <target state="translated">Создайте серию &quot;Легенда&quot; с заданными корнями.</target>
        </trans-unit>
        <trans-unit id="67cead80b0965ee4736c5f23fba251df4f3ebe37" translate="yes" xml:space="preserve">
          <source>Generate a Vandermonde matrix.</source>
          <target state="translated">Генерируйте на матрице Вандермонда.</target>
        </trans-unit>
        <trans-unit id="f4b901c2336926f254f07d1ab7b60e0386e5b58c" translate="yes" xml:space="preserve">
          <source>Generate a monic polynomial with given roots.</source>
          <target state="translated">Генерируйте моно-полиноминал с заданными корнями.</target>
        </trans-unit>
        <trans-unit id="2e173a5f3c2204af8ef7b9a77d34afee8c360a27" translate="yes" xml:space="preserve">
          <source>Generate a non-uniform random sample from np.arange(5) of size 3 without replacement:</source>
          <target state="translated">Генерация неоднородной случайной выборки из np.arange(5)размера 3 без замены:</target>
        </trans-unit>
        <trans-unit id="3b032abdb8bc3ee596986f951aad13aeb29eff03" translate="yes" xml:space="preserve">
          <source>Generate a non-uniform random sample from np.arange(5) of size 3:</source>
          <target state="translated">Генерируйте неоднородную случайную выборку из np.arange(5)размера 3:</target>
        </trans-unit>
        <trans-unit id="15beef8541c11b005861875826a071b16faf6c61" translate="yes" xml:space="preserve">
          <source>Generate a single integer</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="22ecb4243c3f96a98ea55b6a9b74781792dce996" translate="yes" xml:space="preserve">
          <source>Generate a uniform random sample from np.arange(5) of size 3 without replacement:</source>
          <target state="translated">Генерировать однородную случайную выборку из np.arange(5)размера 3 без замены:</target>
        </trans-unit>
        <trans-unit id="7e7e8cdcfbc5d1d81d3a8108edeaf14a80335951" translate="yes" xml:space="preserve">
          <source>Generate a uniform random sample from np.arange(5) of size 3:</source>
          <target state="translated">Генерировать однородную случайную выборку из np.arange(5)размера 3:</target>
        </trans-unit>
        <trans-unit id="382b425e693319395299c741c143ce2398939efe" translate="yes" xml:space="preserve">
          <source>Generate and install a npy-pkg config file from a template.</source>
          <target state="translated">Сгенерировать и установить npy-pkg конфигурационный файл из шаблона.</target>
        </trans-unit>
        <trans-unit id="19a90f1dba170779ac0befe5afd3d6d9c884c6d1" translate="yes" xml:space="preserve">
          <source>Generate config.py file containing system_info information used during building the package.</source>
          <target state="translated">Сгенерировать файл config.py,содержащий информацию system_info,используемую при сборке пакета.</target>
        </trans-unit>
        <trans-unit id="34c49c62f8886e09ca6e64b9c96074bf60926d62" translate="yes" xml:space="preserve">
          <source>Generate package __config__.py file containing system_info information used during building the package.</source>
          <target state="translated">Сгенерировать файл пакета __config__.py,содержащий информацию о системе_info,используемую при сборке пакета.</target>
        </trans-unit>
        <trans-unit id="14952923eed9a754d36fbf7d9df88e59880c6dad" translate="yes" xml:space="preserve">
          <source>Generate package __svn_version__.py file from SVN revision number, it will be removed after python exits but will be available when sdist, etc commands are executed.</source>
          <target state="translated">Сгенерируйте файл пакета __svn_version__.py из номера ревизии SVN,он будет удален после выхода из python,но будет доступен при выполнении sdist и т.д.команд.</target>
        </trans-unit>
        <trans-unit id="60ff5f05cec532a7f8f7d819baeeb92b41c5296d" translate="yes" xml:space="preserve">
          <source>Generate random uint64 numbers in closed interval [off, off + rng].</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c8045f4bbe378a7866506cc0ecb5d877bf5eaf96" translate="yes" xml:space="preserve">
          <source>Generate the README files</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7412730131bc368e3c0dcb289c20fbf2554245c4" translate="yes" xml:space="preserve">
          <source>Generate variates from a multivariate hypergeometric distribution.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3cd9212c9f1d53d55d853a3b264e1b6b858f35fd" translate="yes" xml:space="preserve">
          <source>Generates a random sample from a given 1-D array</source>
          <target state="translated">Генерирует случайную выборку из заданного 1-D массива.</target>
        </trans-unit>
        <trans-unit id="d332ac6845c5273c1195174ec786fa2289b9b752" translate="yes" xml:space="preserve">
          <source>Generating author/pr lists</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="150ce9aa76a74d0a43ead917a8c785193ed877b1" translate="yes" xml:space="preserve">
          <source>Generating index arrays</source>
          <target state="translated">Генерирующие индексные массивы</target>
        </trans-unit>
        <trans-unit id="4bc72cf76a431fc1b67a969426c355ba5d2b3044" translate="yes" xml:space="preserve">
          <source>Generating random numbers</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a0d1bad0186174ecfcdc9782f2116277b7b05e0" translate="yes" xml:space="preserve">
          <source>Generator (class in numpy.random)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2bb174c2f425e0d1a36b6da19833f5708052f5b2" translate="yes" xml:space="preserve">
          <source>Generator.beta()</source>
          <target state="translated">Generator.beta()</target>
        </trans-unit>
        <trans-unit id="5c54211367d38fc1c657f1a2b11682aa7073f8a0" translate="yes" xml:space="preserve">
          <source>Generator.binomial()</source>
          <target state="translated">Generator.binomial()</target>
        </trans-unit>
        <trans-unit id="d222082a3e85bc085f3813830709c1091b870201" translate="yes" xml:space="preserve">
          <source>Generator.bit_generator</source>
          <target state="translated">Generator.bit_generator</target>
        </trans-unit>
        <trans-unit id="ccf1aa45703830ef34744bdb91c5ee84eb339af2" translate="yes" xml:space="preserve">
          <source>Generator.bytes()</source>
          <target state="translated">Generator.bytes()</target>
        </trans-unit>
        <trans-unit id="a1e223f39e59656efb6dcd2b450fd1f3d11e0f5b" translate="yes" xml:space="preserve">
          <source>Generator.chisquare()</source>
          <target state="translated">Generator.chisquare()</target>
        </trans-unit>
        <trans-unit id="a2cf011c29fcb364a340b0b0739ed3940f0415ce" translate="yes" xml:space="preserve">
          <source>Generator.choice()</source>
          <target state="translated">Generator.choice()</target>
        </trans-unit>
        <trans-unit id="acb19d66e8b5e00bd8ab9eaa938d00f3718515fe" translate="yes" xml:space="preserve">
          <source>Generator.dirichlet()</source>
          <target state="translated">Generator.dirichlet()</target>
        </trans-unit>
        <trans-unit id="81c841ae15f138b1059c14b8ebc34f2ceb6506da" translate="yes" xml:space="preserve">
          <source>Generator.exponential()</source>
          <target state="translated">Generator.exponential()</target>
        </trans-unit>
        <trans-unit id="ceb6ee1b51ecd1875248d0ca388e0fb1daabb181" translate="yes" xml:space="preserve">
          <source>Generator.f()</source>
          <target state="translated">Generator.f()</target>
        </trans-unit>
        <trans-unit id="9a5544f1f1d846a0215be8277752788b52f5d5ae" translate="yes" xml:space="preserve">
          <source>Generator.gamma()</source>
          <target state="translated">Generator.gamma()</target>
        </trans-unit>
        <trans-unit id="cb698152656074b26c2b514594b6841ba98646e0" translate="yes" xml:space="preserve">
          <source>Generator.geometric()</source>
          <target state="translated">Generator.geometric()</target>
        </trans-unit>
        <trans-unit id="fbe271ee0cdf14a0b127e97b8a754332b21122bf" translate="yes" xml:space="preserve">
          <source>Generator.gumbel()</source>
          <target state="translated">Generator.gumbel()</target>
        </trans-unit>
        <trans-unit id="1bb4c4773f6c2e362f6bdc12b4738edbd30f23d2" translate="yes" xml:space="preserve">
          <source>Generator.hypergeometric()</source>
          <target state="translated">Generator.hypergeometric()</target>
        </trans-unit>
        <trans-unit id="c50dbdf77399f33f0754452bd827d7d9972e1f6e" translate="yes" xml:space="preserve">
          <source>Generator.integers()</source>
          <target state="translated">Generator.integers()</target>
        </trans-unit>
        <trans-unit id="2ac6ee43d1992ed473a404e92103ad981ee56dd8" translate="yes" xml:space="preserve">
          <source>Generator.laplace()</source>
          <target state="translated">Generator.laplace()</target>
        </trans-unit>
        <trans-unit id="9a01e0244542efabb99865e59014bd47d50fe182" translate="yes" xml:space="preserve">
          <source>Generator.logistic()</source>
          <target state="translated">Generator.logistic()</target>
        </trans-unit>
        <trans-unit id="c320801600fb9c31cc3d790a76584f303a266f0d" translate="yes" xml:space="preserve">
          <source>Generator.lognormal()</source>
          <target state="translated">Generator.lognormal()</target>
        </trans-unit>
        <trans-unit id="2133a52d0f531222ffd5b10595265bd407d65eae" translate="yes" xml:space="preserve">
          <source>Generator.logseries()</source>
          <target state="translated">Generator.logseries()</target>
        </trans-unit>
        <trans-unit id="3fb5b968b7c3c6e4334e366ce81b7d1c72dd0587" translate="yes" xml:space="preserve">
          <source>Generator.multinomial()</source>
          <target state="translated">Generator.multinomial()</target>
        </trans-unit>
        <trans-unit id="ee77530caf29c96157f8b247c28bc2729509bc1f" translate="yes" xml:space="preserve">
          <source>Generator.multivariate_normal()</source>
          <target state="translated">Generator.multivariate_normal()</target>
        </trans-unit>
        <trans-unit id="e4accfbbf5411ba4e6ed6190c6c4a4f347889476" translate="yes" xml:space="preserve">
          <source>Generator.negative_binomial()</source>
          <target state="translated">Generator.negative_binomial()</target>
        </trans-unit>
        <trans-unit id="f5c86d9e1ec54b1f6ceef69c6b35acbc51980bb9" translate="yes" xml:space="preserve">
          <source>Generator.noncentral_chisquare()</source>
          <target state="translated">Generator.noncentral_chisquare()</target>
        </trans-unit>
        <trans-unit id="4ffb9eb22957bfe4ccb8d5eb67072da9ed2c8fe8" translate="yes" xml:space="preserve">
          <source>Generator.noncentral_f()</source>
          <target state="translated">Generator.noncentral_f()</target>
        </trans-unit>
        <trans-unit id="155766b36ed963438beae39d25dc848285e67bec" translate="yes" xml:space="preserve">
          <source>Generator.normal()</source>
          <target state="translated">Generator.normal()</target>
        </trans-unit>
        <trans-unit id="b6ff7a92707e2ef9f9f69eb28c0f2a89afd2fb30" translate="yes" xml:space="preserve">
          <source>Generator.pareto()</source>
          <target state="translated">Generator.pareto()</target>
        </trans-unit>
        <trans-unit id="76efb5ddfe9997620fd07ade2a0e0cee44bb8c62" translate="yes" xml:space="preserve">
          <source>Generator.permutation()</source>
          <target state="translated">Generator.permutation()</target>
        </trans-unit>
        <trans-unit id="7a00012743deaf56311a785e2b3c42ad040930cb" translate="yes" xml:space="preserve">
          <source>Generator.poisson()</source>
          <target state="translated">Generator.poisson()</target>
        </trans-unit>
        <trans-unit id="9ebe8ebc29357762dc172bd7a50a6d2bbec0bbc0" translate="yes" xml:space="preserve">
          <source>Generator.power()</source>
          <target state="translated">Generator.power()</target>
        </trans-unit>
        <trans-unit id="760d539be436a9fd5786ef5406b94bdadd320519" translate="yes" xml:space="preserve">
          <source>Generator.random()</source>
          <target state="translated">Generator.random()</target>
        </trans-unit>
        <trans-unit id="4fe55f2eb5b58a57536abac4e6392ebd311bfe6e" translate="yes" xml:space="preserve">
          <source>Generator.rayleigh()</source>
          <target state="translated">Generator.rayleigh()</target>
        </trans-unit>
        <trans-unit id="3fff1d63fa4122d609dcfb229ec0499ef08a14a7" translate="yes" xml:space="preserve">
          <source>Generator.shuffle()</source>
          <target state="translated">Generator.shuffle()</target>
        </trans-unit>
        <trans-unit id="9b1634a618bfbc7c72035711945372ce07c3fe19" translate="yes" xml:space="preserve">
          <source>Generator.standard_cauchy()</source>
          <target state="translated">Generator.standard_cauchy()</target>
        </trans-unit>
        <trans-unit id="34db4ce80b61d7d21ff61b89aa2d2d63aa910f5c" translate="yes" xml:space="preserve">
          <source>Generator.standard_exponential()</source>
          <target state="translated">Generator.standard_exponential()</target>
        </trans-unit>
        <trans-unit id="34031ad3432250f012a4d89407bba35b84a16c3c" translate="yes" xml:space="preserve">
          <source>Generator.standard_gamma()</source>
          <target state="translated">Generator.standard_gamma()</target>
        </trans-unit>
        <trans-unit id="87dab3cf1af1d204bcf4e1ac664f4ea0ea2557c9" translate="yes" xml:space="preserve">
          <source>Generator.standard_normal()</source>
          <target state="translated">Generator.standard_normal()</target>
        </trans-unit>
        <trans-unit id="f906f6a0afddbf8cdbe07f5b8f0720c2656e3a0d" translate="yes" xml:space="preserve">
          <source>Generator.standard_t()</source>
          <target state="translated">Generator.standard_t()</target>
        </trans-unit>
        <trans-unit id="b0b2b3ce2c0360b1a89e482830d2d3c0cbab9581" translate="yes" xml:space="preserve">
          <source>Generator.triangular()</source>
          <target state="translated">Generator.triangular()</target>
        </trans-unit>
        <trans-unit id="ab3025f762e986dfbed9abf7722d638afcbcac65" translate="yes" xml:space="preserve">
          <source>Generator.uniform()</source>
          <target state="translated">Generator.uniform()</target>
        </trans-unit>
        <trans-unit id="41234839ae9e6c31f86b35be70f95dd2edfdb45f" translate="yes" xml:space="preserve">
          <source>Generator.vonmises()</source>
          <target state="translated">Generator.vonmises()</target>
        </trans-unit>
        <trans-unit id="524f7ff03bcd2538def6c2fcd08d18e053cd0a0d" translate="yes" xml:space="preserve">
          <source>Generator.wald()</source>
          <target state="translated">Generator.wald()</target>
        </trans-unit>
        <trans-unit id="e7d43ca17b95d21950576674e14eac05300d6600" translate="yes" xml:space="preserve">
          <source>Generator.weibull()</source>
          <target state="translated">Generator.weibull()</target>
        </trans-unit>
        <trans-unit id="425fdb323ea262485eeead85528e77951596ac23" translate="yes" xml:space="preserve">
          <source>Generator.zipf()</source>
          <target state="translated">Generator.zipf()</target>
        </trans-unit>
        <trans-unit id="b9790b2a609e0a0a9945eb7f9ff37cc7c5acb58d" translate="yes" xml:space="preserve">
          <source>Generators should be documented just as functions are documented. The only difference is that one should use the &lt;strong&gt;Yields&lt;/strong&gt; section instead of the &lt;strong&gt;Returns&lt;/strong&gt; section. Support for the &lt;strong&gt;Yields&lt;/strong&gt; section was added in &lt;a href=&quot;https://github.com/numpy/numpydoc&quot;&gt;numpydoc&lt;/a&gt; version 0.6.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df5e162e441d1aa68e920c4da50498c7a00cc1ca" translate="yes" xml:space="preserve">
          <source>Generators: Objects that transform sequences of random bits from a BitGenerator into sequences of numbers that follow a specific probability distribution (such as uniform, Normal or Binomial) within a specified interval.</source>
          <target state="translated">Генераторы:Объекты,преобразующие последовательности случайных битов из BitGenerator в последовательности чисел,которые следуют за определенным распределением вероятностей (например,равномерным,нормальным или биномиальным)в пределах заданного интервала.</target>
        </trans-unit>
        <trans-unit id="fcca6d928c0647f440353ba62ca89c9a77b6389a" translate="yes" xml:space="preserve">
          <source>Generic Python-exception-derived object raised by linalg functions.</source>
          <target state="translated">Общий объект,полученный на питоне,поднятый функциями линаляга.</target>
        </trans-unit>
        <trans-unit id="37f5365cdbef14515226dcd384583192170cc525" translate="yes" xml:space="preserve">
          <source>Generic functions</source>
          <target state="translated">Общие функции</target>
        </trans-unit>
        <trans-unit id="36687e3d4c6e89be61413141c9001bd1269ea61f" translate="yes" xml:space="preserve">
          <source>Generic types</source>
          <target state="translated">Общие типы</target>
        </trans-unit>
        <trans-unit id="4725fc543850e19ff2039cda197dd7e9e18cc3b7" translate="yes" xml:space="preserve">
          <source>Get a Python object of a builtin type from the ndarray, &lt;em&gt;arr&lt;/em&gt;, at the location pointed to by itemptr. Return &lt;code&gt;NULL&lt;/code&gt; on failure.</source>
          <target state="translated">Получите объект Python встроенного типа из массива ndarray, &lt;em&gt;arr&lt;/em&gt; , в месте, на которое указывает itemptr. В случае неудачи вернуть &lt;code&gt;NULL&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="89bba80c206cb8084a11e65d5dc5c897b6a8a686" translate="yes" xml:space="preserve">
          <source>Get a copy of the iterator as a 1-D array.</source>
          <target state="translated">Получить копию итератора в виде одномерного массива.</target>
        </trans-unit>
        <trans-unit id="f7e3ab2dfabd54e64b9ac5580bc305e9c24165dc" translate="yes" xml:space="preserve">
          <source>Get a copy of the iterator in its current state.</source>
          <target state="translated">Получите копию итератора в его текущем состоянии.</target>
        </trans-unit>
        <trans-unit id="87b8e4a6c47eabed3fcd4c264f91d248484dbd8e" translate="yes" xml:space="preserve">
          <source>Get floating point status. A pointer to a local variable is passed in to prevent aggressive compiler optimizations from reodering this function call relative to the code setting the status, which could lead to incorrect results.</source>
          <target state="translated">Получить статус с плавающей точкой.Передается указатель на локальную переменную,чтобы предотвратить переопределение агрессивных оптимизаций компилятора при вызове этой функции относительно кода,устанавливающего статус,что может привести к некорректным результатам.</target>
        </trans-unit>
        <trans-unit id="c919c3aaf29bde2f7fadef95afc3436e547fc4bb" translate="yes" xml:space="preserve">
          <source>Get floating point status. A pointer to a local variable is passed in to prevent aggressive compiler optimizations from reordering this function call relative to the code setting the status, which could lead to incorrect results.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b27b9509ff4121a0e1b9f0986d9920de57d819f0" translate="yes" xml:space="preserve">
          <source>Get floating point status. Returns a bitmask with following possible flags:</source>
          <target state="translated">Получить статус с плавающей точкой.Возвращает битовую маску со следующими возможными флагами:</target>
        </trans-unit>
        <trans-unit id="ddfceaf39034459b039832aa5e0f88a5294c648e" translate="yes" xml:space="preserve">
          <source>Get help information for a function, class, or module.</source>
          <target state="translated">Получить справочную информацию для функции,класса или модуля.</target>
        </trans-unit>
        <trans-unit id="ec25cf47cdd55b9b521bbdadbef69d3ea1d8e5a4" translate="yes" xml:space="preserve">
          <source>Get information about the step size of a date or time type.</source>
          <target state="translated">Получить информацию о размере шага типа дата или время.</target>
        </trans-unit>
        <trans-unit id="d0d9c57e1b16aa99fa5d9ab014f87b4ec73ded17" translate="yes" xml:space="preserve">
          <source>Get number of parallel build jobs set by the &amp;ndash;parallel command line argument of setup.py If the command did not receive a setting the environment variable NPY_NUM_BUILD_JOBS is checked. If that is unset, return the number of processors on the system, with a maximum of 8 (to prevent overloading the system if there a lot of CPUs).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="693a41351204b667429ed1f8f87172706e8b4a91" translate="yes" xml:space="preserve">
          <source>Get or set the PRNG state</source>
          <target state="translated">Получить или установить PRNG состояние</target>
        </trans-unit>
        <trans-unit id="09c0240016b842d9be6c9625e5a572e040565a6a" translate="yes" xml:space="preserve">
          <source>Get or set the mask of the array if it has no named fields.</source>
          <target state="translated">Получить или установить маску массива,если у него нет именованных полей.</target>
        </trans-unit>
        <trans-unit id="0a74bcddcc3142595e265c6f91c54ba0941f6e3f" translate="yes" xml:space="preserve">
          <source>Get or set the mask of the array if it has no named fields. For structured arrays, returns a ndarray of booleans where entries are &lt;code&gt;True&lt;/code&gt; if &lt;strong&gt;all&lt;/strong&gt; the fields are masked, &lt;code&gt;False&lt;/code&gt; otherwise:</source>
          <target state="translated">Получить или установить маску массива, если в нем нет именованных полей. Для структурированных массивов возвращает ndarray логических значений, где записи имеют значение &lt;code&gt;True&lt;/code&gt; , если &lt;strong&gt;все&lt;/strong&gt; поля замаскированы, и &lt;code&gt;False&lt;/code&gt; в противном случае:</target>
        </trans-unit>
        <trans-unit id="c0ab6b2bea51cfebc1977ab8830dcd90e5d8f56d" translate="yes" xml:space="preserve">
          <source>Get resources information.</source>
          <target state="translated">Получить информацию о ресурсах.</target>
        </trans-unit>
        <trans-unit id="7d41ad59188f890aeb1ed8209e30d553a33f1536" translate="yes" xml:space="preserve">
          <source>Get the Python values used for ufunc processing from the thread-local storage area unless the defaults have been set in which case the name lookup is bypassed. The name is placed as a string in the first element of &lt;em&gt;*errobj&lt;/em&gt;. The second element is the looked-up function to call on error callback. The value of the looked-up buffer-size to use is passed into &lt;em&gt;bufsize&lt;/em&gt;, and the value of the error mask is placed into &lt;em&gt;errmask&lt;/em&gt;.</source>
          <target state="translated">Получите значения Python, используемые для обработки ufunc, из области локального хранилища потока, если не были установлены значения по умолчанию, и в этом случае поиск имени игнорируется. Имя помещается в виде строки в первый элемент &lt;em&gt;* errobj&lt;/em&gt; . Второй элемент - это функция поиска для вызова обратного вызова ошибки. Значение &lt;em&gt;искомого&lt;/em&gt; размера буфера для использования передается в &lt;em&gt;bufsize&lt;/em&gt; , а значение маски ошибок помещается в &lt;em&gt;errmask&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="b42cef4d77cbf66bab7c534b082e6107163dee92" translate="yes" xml:space="preserve">
          <source>Get the current way of handling floating-point errors.</source>
          <target state="translated">Получите текущий способ обработки ошибок с плавающей запятой.</target>
        </trans-unit>
        <trans-unit id="1ad2852f86c694e329d03e73d07b76a105a8cebc" translate="yes" xml:space="preserve">
          <source>Get the local copy of the code</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="695f3e243afdf261b45538304791ad040f8d34f0" translate="yes" xml:space="preserve">
          <source>Get the number of dimensions of an array</source>
          <target state="translated">Получить количество размеров массива</target>
        </trans-unit>
        <trans-unit id="38abfcd88f93b84356fd5ce9430a9a3bce6aa97e" translate="yes" xml:space="preserve">
          <source>Get the shape of the array and a pointer to its actual data.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="47b4332f0fd288d9a8660cb9b90eb2d70399cb30" translate="yes" xml:space="preserve">
          <source>Getitem/setitem/copyswap function: Similar to ufuncs, these functions generally have two code paths. If &lt;code&gt;ALIGNED&lt;/code&gt; is False they will use a code path that buffers the arguments so they are true-aligned.</source>
          <target state="translated">Функция Getitem / setitem / copyswap: Подобно ufuncs, эти функции обычно имеют два пути кода. Если &lt;code&gt;ALIGNED&lt;/code&gt; имеет значение False, они будут использовать путь кода, который буферизует аргументы, чтобы они были выровнены по истине.</target>
        </trans-unit>
        <trans-unit id="be9042cc4b8d1c2a38a88090c5bbf827e249e726" translate="yes" xml:space="preserve">
          <source>Gets an array of strides which are fixed, or will not change during the entire iteration. For strides that may change, the value NPY_MAX_INTP is placed in the stride.</source>
          <target state="translated">Получает массив шага,который фиксирован или не будет изменяться в течение всей итерации.Для шага,который может измениться,в шаге устанавливается значение NPY_MAX_INTP.</target>
        </trans-unit>
        <trans-unit id="30fc1fed71b9648bc39ebe85c632c9c96d68765c" translate="yes" xml:space="preserve">
          <source>Gets the &lt;code&gt;iterindex&lt;/code&gt; of the iterator, which is an index matching the iteration order of the iterator.</source>
          <target state="translated">Получает &lt;code&gt;iterindex&lt;/code&gt; итератора, который является индексом, соответствующим порядку итерации итератора.</target>
        </trans-unit>
        <trans-unit id="c9217aeddd13f7d6ea905e46252fcb27732c6211" translate="yes" xml:space="preserve">
          <source>Gets the &lt;code&gt;iterindex&lt;/code&gt; sub-range that is being iterated. If &lt;a href=&quot;#c.NPY_ITER_RANGED&quot;&gt;&lt;code&gt;NPY_ITER_RANGED&lt;/code&gt;&lt;/a&gt; was not specified, this always returns the range &lt;code&gt;[0, NpyIter_IterSize(iter))&lt;/code&gt;.</source>
          <target state="translated">Получает &lt;code&gt;iterindex&lt;/code&gt; поддиапазон iterindex . Если &lt;a href=&quot;#c.NPY_ITER_RANGED&quot;&gt; &lt;code&gt;NPY_ITER_RANGED&lt;/code&gt; &lt;/a&gt; не указан, это всегда возвращает диапазон &lt;code&gt;[0, NpyIter_IterSize(iter))&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b29099a868ef51a061ab01f34d141a4b26e68b87" translate="yes" xml:space="preserve">
          <source>Gets the array of data pointers directly into the arrays (never into the buffers), corresponding to iteration index 0.</source>
          <target state="translated">Получает массив указателей данных непосредственно в массивы (никогда в буферы),соответствующий итерационному индексу 0.</target>
        </trans-unit>
        <trans-unit id="ad1880ff271cb91c83bb908e9bec8d5e682e13f9" translate="yes" xml:space="preserve">
          <source>Gets the array of strides for the specified axis. Requires that the iterator be tracking a multi-index, and that buffering not be enabled.</source>
          <target state="translated">Получает массив шага для указанной оси.Требует,чтобы итератор отслеживал мультииндекс,и чтобы буферизация не была включена.</target>
        </trans-unit>
        <trans-unit id="cbcc80db035da4f014fe2b35abfcfb7fdf954c8c" translate="yes" xml:space="preserve">
          <source>Gets the bit generator instance used by the generator</source>
          <target state="translated">Получает экземпляр генератора битов,используемый генератором.</target>
        </trans-unit>
        <trans-unit id="d159fd31101fbca3940d95031521a0aa1cca2dba" translate="yes" xml:space="preserve">
          <source>Getting at ndarray memory and accessing elements of the ndarray</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a46b1f79c63a304cb32357fb767b2f9f13f63b7" translate="yes" xml:space="preserve">
          <source>Getting extra Fortran 77 compiler options from source</source>
          <target state="translated">Получение дополнительных опций компилятора Fortran 77 из исходных текстов</target>
        </trans-unit>
        <trans-unit id="40231bcdbc4a93a29a6d8b82096fcd17f9064444" translate="yes" xml:space="preserve">
          <source>Getting started with Git development</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="16e47f4c54647389b910573011e6826ea1e0a912" translate="yes" xml:space="preserve">
          <source>Git Basics</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dfff37d55b9830b2f87d05fbf99d4f09fbfa666c" translate="yes" xml:space="preserve">
          <source>Git configuration</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c5717316487921ed9c21d808282281daa39b5a4" translate="yes" xml:space="preserve">
          <source>Git for development</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="62cbb73206931d6c5b9ae31c184bc49486ee1eb6" translate="yes" xml:space="preserve">
          <source>Git will then immediately bring up an editor for editing the commit message. After revising it, we get the output:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fed2b47c2eb6fcb9566d8e5b338ef20c663258ac" translate="yes" xml:space="preserve">
          <source>Give a new shape to an array without changing its data.</source>
          <target state="translated">Придание новой формы массиву без изменения его данных.</target>
        </trans-unit>
        <trans-unit id="a577ea656c2f3aa2b8af6ec81a5f57008704a3bb" translate="yes" xml:space="preserve">
          <source>Give a new shape to the array without changing its data.</source>
          <target state="translated">Придание новой формы массиву без изменения его данных.</target>
        </trans-unit>
        <trans-unit id="5633a94c306e1317df951f106e430c35db17233f" translate="yes" xml:space="preserve">
          <source>Given a sequence of a polynomial&amp;rsquo;s zeros:</source>
          <target state="translated">Дана последовательность нулей полинома:</target>
        </trans-unit>
        <trans-unit id="4cc543f62ec648afbd60f8c46e36515054ff8b40" translate="yes" xml:space="preserve">
          <source>Given a sequence of arrays (&lt;em&gt;sort_keys&lt;/em&gt;) of the same shape, return an array of indices (similar to &lt;a href=&quot;#c.PyArray_ArgSort&quot;&gt;&lt;code&gt;PyArray_ArgSort&lt;/code&gt;&lt;/a&gt; (&amp;hellip;)) that would sort the arrays lexicographically. A lexicographic sort specifies that when two keys are found to be equal, the order is based on comparison of subsequent keys. A merge sort (which leaves equal entries unmoved) is required to be defined for the types. The sort is accomplished by sorting the indices first using the first &lt;em&gt;sort_key&lt;/em&gt; and then using the second &lt;em&gt;sort_key&lt;/em&gt; and so forth. This is equivalent to the lexsort(&lt;em&gt;sort_keys&lt;/em&gt;, &lt;em&gt;axis&lt;/em&gt;) Python command. Because of the way the merge-sort works, be sure to understand the order the &lt;em&gt;sort_keys&lt;/em&gt; must be in (reversed from the order you would use when comparing two elements).</source>
          <target state="translated">Учитывая последовательность массивов ( &lt;em&gt;sort_keys&lt;/em&gt; ) одинаковой формы, верните массив индексов (аналогичный &lt;a href=&quot;#c.PyArray_ArgSort&quot;&gt; &lt;code&gt;PyArray_ArgSort&lt;/code&gt; &lt;/a&gt; (&amp;hellip;)), который будет лексикографически сортировать массивы. Лексикографическая сортировка указывает, что, когда два ключа оказываются равными, порядок основан на сравнении последующих ключей. Для типов требуется определить сортировку слиянием (при которой одинаковые записи остаются неизменными). Сортировка выполняется путем сортировки индексов сначала с помощью первого &lt;em&gt;ключа sort_key,&lt;/em&gt; затем с помощью второго &lt;em&gt;ключа sort_key&lt;/em&gt; и так далее. Это эквивалентно команде Python lexsort ( &lt;em&gt;sort_keys&lt;/em&gt; , &lt;em&gt;axis&lt;/em&gt; ). Из-за того, как работает сортировка слиянием, убедитесь, что вы понимаете порядок &lt;em&gt;sort_keys&lt;/em&gt; должны быть в порядке (обратном порядке, который вы использовали бы при сравнении двух элементов).</target>
        </trans-unit>
        <trans-unit id="675ac4930884c9f7a3554ad9fd66c39834a06013" translate="yes" xml:space="preserve">
          <source>Given a set of conditions and corresponding functions, evaluate each function on the input data wherever its condition is true.</source>
          <target state="translated">Учитывая набор условий и соответствующих функций,оцените каждую функцию на входных данных,где бы ни было ее состояние.</target>
        </trans-unit>
        <trans-unit id="9104557d433ccbecbd40d5b471167b269afd4924" translate="yes" xml:space="preserve">
          <source>Given a shape of, for example, &lt;code&gt;(m,n,k)&lt;/code&gt;, &lt;code&gt;m*n*k&lt;/code&gt; samples are generated, and packed in an &lt;code&gt;m&lt;/code&gt;-by-&lt;code&gt;n&lt;/code&gt;-by-&lt;code&gt;k&lt;/code&gt; arrangement. Because each sample is &lt;code&gt;N&lt;/code&gt;-dimensional, the output shape is &lt;code&gt;(m,n,k,N)&lt;/code&gt;. If no shape is specified, a single (&lt;code&gt;N&lt;/code&gt;-D) sample is returned.</source>
          <target state="translated">При заданной форме, например, &lt;code&gt;(m,n,k)&lt;/code&gt; , создается &lt;code&gt;m*n*k&lt;/code&gt; выборок и упаковывается в компоновку &lt;code&gt;m&lt;/code&gt; &amp;times; &lt;code&gt;n&lt;/code&gt; &amp;times; &lt;code&gt;k&lt;/code&gt; . Поскольку каждый образец является &lt;code&gt;N&lt;/code&gt; - мерным, форма вывода будет &lt;code&gt;(m,n,k,N)&lt;/code&gt; . Если форма не указана, возвращается один ( &lt;code&gt;N&lt;/code&gt; -D) образец.</target>
        </trans-unit>
        <trans-unit id="cd43bd0b568c4a20eb55e09b56aec26e4bcf57e8" translate="yes" xml:space="preserve">
          <source>Given a square array object:</source>
          <target state="translated">Учитывая объект квадратного массива:</target>
        </trans-unit>
        <trans-unit id="c727e55b5284efd4b0f949a20f79f07a731a7def" translate="yes" xml:space="preserve">
          <source>Given a square matrix &lt;code&gt;a&lt;/code&gt;, return the matrix &lt;code&gt;ainv&lt;/code&gt; satisfying &lt;code&gt;dot(a, ainv) = dot(ainv, a) = eye(a.shape[0])&lt;/code&gt;.</source>
          <target state="translated">Для квадратной матрицы &lt;code&gt;a&lt;/code&gt; верните матрицу &lt;code&gt;ainv&lt;/code&gt; , удовлетворяющую условию &lt;code&gt;dot(a, ainv) = dot(ainv, a) = eye(a.shape[0])&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fc3ba91f03af5d3e0b135a4d459d0b8c153beab2" translate="yes" xml:space="preserve">
          <source>Given a vector &lt;code&gt;V&lt;/code&gt; of length &lt;code&gt;N&lt;/code&gt;, the &lt;code&gt;q&lt;/code&gt;-th percentile of &lt;code&gt;V&lt;/code&gt; is the value &lt;code&gt;q/100&lt;/code&gt; of the way from the minimum to the maximum in a sorted copy of &lt;code&gt;V&lt;/code&gt;. The values and distances of the two nearest neighbors as well as the &lt;code&gt;interpolation&lt;/code&gt; parameter will determine the percentile if the normalized ranking does not match the location of &lt;code&gt;q&lt;/code&gt; exactly. This function is the same as the median if &lt;code&gt;q=50&lt;/code&gt;, the same as the minimum if &lt;code&gt;q=0&lt;/code&gt; and the same as the maximum if &lt;code&gt;q=100&lt;/code&gt;.</source>
          <target state="translated">Принимая во внимание вектора &lt;code&gt;V&lt;/code&gt; длины &lt;code&gt;N&lt;/code&gt; , тем &lt;code&gt;q&lt;/code&gt; -го процентиль &lt;code&gt;V&lt;/code&gt; имеет значение &lt;code&gt;q/100&lt;/code&gt; в стороне от минимума до максимума в отсортированной копии &lt;code&gt;V&lt;/code&gt; . Значения и расстояния двух ближайших соседей, а также параметр &lt;code&gt;interpolation&lt;/code&gt; будут определять процентиль, если нормализованное ранжирование не соответствует точно местоположению &lt;code&gt;q&lt;/code&gt; . Эта функция такая же, как медиана, если &lt;code&gt;q=50&lt;/code&gt; , такая же, как минимум, если &lt;code&gt;q=0&lt;/code&gt; , и такая же как максимум, если &lt;code&gt;q=100&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1966cedf9ce61fd3a211e32f4abbb9573112f3e8" translate="yes" xml:space="preserve">
          <source>Given a vector &lt;code&gt;V&lt;/code&gt; of length &lt;code&gt;N&lt;/code&gt;, the median of &lt;code&gt;V&lt;/code&gt; is the middle value of a sorted copy of &lt;code&gt;V&lt;/code&gt;, &lt;code&gt;V_sorted&lt;/code&gt; - i e., &lt;code&gt;V_sorted[(N-1)/2]&lt;/code&gt;, when &lt;code&gt;N&lt;/code&gt; is odd, and the average of the two middle values of &lt;code&gt;V_sorted&lt;/code&gt; when &lt;code&gt;N&lt;/code&gt; is even.</source>
          <target state="translated">Для вектора &lt;code&gt;V&lt;/code&gt; длины &lt;code&gt;N&lt;/code&gt; , медиана &lt;code&gt;V&lt;/code&gt; является средним значением отсортированной копии &lt;code&gt;V&lt;/code&gt; , &lt;code&gt;V_sorted&lt;/code&gt; - т.е., &lt;code&gt;V_sorted[(N-1)/2]&lt;/code&gt; , когда &lt;code&gt;N&lt;/code&gt; нечетно, и среднее значение два средних значения &lt;code&gt;V_sorted&lt;/code&gt; , когда &lt;code&gt;N&lt;/code&gt; четно.</target>
        </trans-unit>
        <trans-unit id="a11a60c1be0b2a1a4251da19f3ebb410f0917d80" translate="yes" xml:space="preserve">
          <source>Given a vector &lt;code&gt;V&lt;/code&gt; of length &lt;code&gt;N&lt;/code&gt;, the median of &lt;code&gt;V&lt;/code&gt; is the middle value of a sorted copy of &lt;code&gt;V&lt;/code&gt;, &lt;code&gt;V_sorted&lt;/code&gt; - i.e., &lt;code&gt;V_sorted[(N-1)/2]&lt;/code&gt;, when &lt;code&gt;N&lt;/code&gt; is odd and the average of the two middle values of &lt;code&gt;V_sorted&lt;/code&gt; when &lt;code&gt;N&lt;/code&gt; is even.</source>
          <target state="translated">Учитывая вектор &lt;code&gt;V&lt;/code&gt; длины &lt;code&gt;N&lt;/code&gt; , медиана &lt;code&gt;V&lt;/code&gt; является средним значением отсортированной копии &lt;code&gt;V&lt;/code&gt; , &lt;code&gt;V_sorted&lt;/code&gt; , то есть &lt;code&gt;V_sorted[(N-1)/2]&lt;/code&gt; , когда &lt;code&gt;N&lt;/code&gt; нечетное и среднее из двух средних значений. из &lt;code&gt;V_sorted&lt;/code&gt; , когда &lt;code&gt;N&lt;/code&gt; является четным.</target>
        </trans-unit>
        <trans-unit id="d76c2715df60bdab25092c54104462a6d39f23bb" translate="yes" xml:space="preserve">
          <source>Given a vector &lt;code&gt;V&lt;/code&gt; of length &lt;code&gt;N&lt;/code&gt;, the q-th percentile of &lt;code&gt;V&lt;/code&gt; is the value &lt;code&gt;q/100&lt;/code&gt; of the way from the minimum to the maximum in a sorted copy of &lt;code&gt;V&lt;/code&gt;. The values and distances of the two nearest neighbors as well as the &lt;code&gt;interpolation&lt;/code&gt; parameter will determine the percentile if the normalized ranking does not match the location of &lt;code&gt;q&lt;/code&gt; exactly. This function is the same as the median if &lt;code&gt;q=50&lt;/code&gt;, the same as the minimum if &lt;code&gt;q=0&lt;/code&gt; and the same as the maximum if &lt;code&gt;q=100&lt;/code&gt;.</source>
          <target state="translated">Принимая во внимание вектора &lt;code&gt;V&lt;/code&gt; длинами &lt;code&gt;N&lt;/code&gt; , Q-й процентиль &lt;code&gt;V&lt;/code&gt; является значение &lt;code&gt;q/100&lt;/code&gt; в стороне от минимума до максимума в отсортированной копии &lt;code&gt;V&lt;/code&gt; . Значения и расстояния двух ближайших соседей, а также параметр &lt;code&gt;interpolation&lt;/code&gt; будут определять процентиль, если нормализованное ранжирование не соответствует точно местоположению &lt;code&gt;q&lt;/code&gt; . Эта функция такая же, как медиана, если &lt;code&gt;q=50&lt;/code&gt; , такая же, как минимум, если &lt;code&gt;q=0&lt;/code&gt; , и такая же как максимум, если &lt;code&gt;q=100&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="dfd59ffc41fbed91404c5101ddfa184c5392006b" translate="yes" xml:space="preserve">
          <source>Given a vector &lt;code&gt;V&lt;/code&gt; of length &lt;code&gt;N&lt;/code&gt;, the q-th quantile of &lt;code&gt;V&lt;/code&gt; is the value &lt;code&gt;q&lt;/code&gt; of the way from the minimum to the maximum in a sorted copy of &lt;code&gt;V&lt;/code&gt;. The values and distances of the two nearest neighbors as well as the &lt;code&gt;interpolation&lt;/code&gt; parameter will determine the quantile if the normalized ranking does not match the location of &lt;code&gt;q&lt;/code&gt; exactly. This function is the same as the median if &lt;code&gt;q=0.5&lt;/code&gt;, the same as the minimum if &lt;code&gt;q=0.0&lt;/code&gt; and the same as the maximum if &lt;code&gt;q=1.0&lt;/code&gt;.</source>
          <target state="translated">Принимая во внимание вектора &lt;code&gt;V&lt;/code&gt; длинами &lt;code&gt;N&lt;/code&gt; , Q-й квантиль &lt;code&gt;V&lt;/code&gt; является значение &lt;code&gt;q&lt;/code&gt; пути от минимума до максимума в отсортированной копии &lt;code&gt;V&lt;/code&gt; . Значения и расстояния двух ближайших соседей, а также параметр &lt;code&gt;interpolation&lt;/code&gt; будут определять квантиль, если нормализованное ранжирование не соответствует точно местоположению &lt;code&gt;q&lt;/code&gt; . Эта функция такая же, как медиана, если &lt;code&gt;q=0.5&lt;/code&gt; , такая же, как минимум, если &lt;code&gt;q=0.0&lt;/code&gt; и такая же как максимум, если &lt;code&gt;q=1.0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="97afe1ab394be8a96329790e96c805504acf970b" translate="yes" xml:space="preserve">
          <source>Given a vector &lt;code&gt;V&lt;/code&gt; with &lt;code&gt;N&lt;/code&gt; non masked values, the median of &lt;code&gt;V&lt;/code&gt; is the middle value of a sorted copy of &lt;code&gt;V&lt;/code&gt; (&lt;code&gt;Vs&lt;/code&gt;) - i.e. &lt;code&gt;Vs[(N-1)/2]&lt;/code&gt;, when &lt;code&gt;N&lt;/code&gt; is odd, or &lt;code&gt;{Vs[N/2 - 1] + Vs[N/2]}/2&lt;/code&gt; when &lt;code&gt;N&lt;/code&gt; is even.</source>
          <target state="translated">Для вектора &lt;code&gt;V&lt;/code&gt; с &lt;code&gt;N&lt;/code&gt; немаскированными значениями медиана &lt;code&gt;V&lt;/code&gt; является средним значением отсортированной копии &lt;code&gt;V&lt;/code&gt; ( &lt;code&gt;Vs&lt;/code&gt; ), то есть &lt;code&gt;Vs[(N-1)/2]&lt;/code&gt; , когда &lt;code&gt;N&lt;/code&gt; нечетно, или &lt;code&gt;{Vs[N/2 - 1] + Vs[N/2]}/2&lt;/code&gt; когда &lt;code&gt;N&lt;/code&gt; четно.</target>
        </trans-unit>
        <trans-unit id="2f958084a15b1cea997fb4f3882497b30e2d92da" translate="yes" xml:space="preserve">
          <source>Given a window length &lt;code&gt;n&lt;/code&gt; and a sample spacing &lt;code&gt;d&lt;/code&gt;:</source>
          <target state="translated">Учитывая длину окна &lt;code&gt;n&lt;/code&gt; и интервал выборки &lt;code&gt;d&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="3cf50be3014d334ce381b3182c6e22be99505ba7" translate="yes" xml:space="preserve">
          <source>Given an &amp;ldquo;index&amp;rdquo; array (&lt;code&gt;a&lt;/code&gt;) of integers and a sequence of &lt;code&gt;n&lt;/code&gt; arrays (&lt;code&gt;choices&lt;/code&gt;), &lt;code&gt;a&lt;/code&gt; and each choice array are first broadcast, as necessary, to arrays of a common shape; calling these &lt;em&gt;Ba&lt;/em&gt; and &lt;em&gt;Bchoices[i], i = 0,&amp;hellip;,n-1&lt;/em&gt; we have that, necessarily, &lt;code&gt;Ba.shape == Bchoices[i].shape&lt;/code&gt; for each &lt;code&gt;i&lt;/code&gt;. Then, a new array with shape &lt;code&gt;Ba.shape&lt;/code&gt; is created as follows:</source>
          <target state="translated">Дан &amp;laquo;индексный&amp;raquo; массив ( &lt;code&gt;a&lt;/code&gt; ) целых чисел и последовательность из &lt;code&gt;n&lt;/code&gt; массивов ( &lt;code&gt;choices&lt;/code&gt; ), &lt;code&gt;a&lt;/code&gt; и каждый массив выбора сначала транслируются, если необходимо, в массивы общей формы; назвав эти &lt;em&gt;Ba&lt;/em&gt; и &lt;em&gt;Bchoices [i], i = 0,&amp;hellip;, n-1,&lt;/em&gt; мы обязательно получим, что &lt;code&gt;Ba.shape == Bchoices[i].shape&lt;/code&gt; для каждого &lt;code&gt;i&lt;/code&gt; . Затем создается новый массив с формой &lt;code&gt;Ba.shape&lt;/code&gt; следующим образом:</target>
        </trans-unit>
        <trans-unit id="182d11d96136738a2da66eeca81246c173e18b8d" translate="yes" xml:space="preserve">
          <source>Given an array of integers and a set of n choice arrays, this method will create a new array that merges each of the choice arrays. Where a value in &lt;code&gt;a&lt;/code&gt; is i, the new array will have the value that choices[i] contains in the same place.</source>
          <target state="translated">Учитывая массив целых чисел и набор из n массивов выбора, этот метод создаст новый массив, который объединяет каждый из массивов выбора. Если значение в &lt;code&gt;a&lt;/code&gt; равно i, новый массив будет иметь значение, которое choices [i] содержит в том же месте.</target>
        </trans-unit>
        <trans-unit id="e37e450d620d60b14cee7269755ab57ba8f06da4" translate="yes" xml:space="preserve">
          <source>Given an interval, values outside the interval are clipped to the interval edges. For example, if an interval of &lt;code&gt;[0, 1]&lt;/code&gt; is specified, values smaller than 0 become 0, and values larger than 1 become 1.</source>
          <target state="translated">При заданном интервале значения за пределами интервала обрезаются по краям интервала. Например, если указан интервал &lt;code&gt;[0, 1]&lt;/code&gt; , значения меньше 0 становятся 0, а значения больше 1 становятся 1.</target>
        </trans-unit>
        <trans-unit id="38e44e10395d6cbc3f11e11b2660a79eed5fd62a" translate="yes" xml:space="preserve">
          <source>Given multiple sorting keys, which can be interpreted as columns in a spreadsheet, lexsort returns an array of integer indices that describes the sort order by multiple columns. The last key in the sequence is used for the primary sort order, the second-to-last key for the secondary sort order, and so on. The keys argument must be a sequence of objects that can be converted to arrays of the same shape. If a 2D array is provided for the keys argument, it&amp;rsquo;s rows are interpreted as the sorting keys and sorting is according to the last row, second last row etc.</source>
          <target state="translated">При наличии нескольких ключей сортировки, которые можно интерпретировать как столбцы в электронной таблице, lexsort возвращает массив целочисленных индексов, описывающих порядок сортировки по нескольким столбцам. Последний ключ в последовательности используется для первичного порядка сортировки, предпоследний ключ для вторичного порядка сортировки и т. Д. Аргумент keys должен быть последовательностью объектов, которые можно преобразовать в массивы той же формы. Если для аргумента ключей предоставляется двухмерный массив, его строки интерпретируются как ключи сортировки, а сортировка выполняется в соответствии с последней строкой, второй последней строкой и т. Д.</target>
        </trans-unit>
        <trans-unit id="67d67e5173e989786e884148ab1ee5c292352200" translate="yes" xml:space="preserve">
          <source>Given the &amp;ldquo;legs&amp;rdquo; of a right triangle, return its hypotenuse.</source>
          <target state="translated">Учитывая &amp;laquo;катеты&amp;raquo; прямоугольного треугольника, верните его гипотенузу.</target>
        </trans-unit>
        <trans-unit id="65f0e0f7ab08e6e7d473538fe0c4ef0f86fa2404" translate="yes" xml:space="preserve">
          <source>Given the above, we intend to deprecate &lt;code&gt;matrix&lt;/code&gt; eventually.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd7a5a167593ffa963306f804bdee09ec39e8fd9" translate="yes" xml:space="preserve">
          <source>Given the shape of an array, an &lt;a href=&quot;#numpy.ndindex&quot;&gt;&lt;code&gt;ndindex&lt;/code&gt;&lt;/a&gt; instance iterates over the N-dimensional index of the array. At each iteration a tuple of indices is returned, the last dimension is iterated over first.</source>
          <target state="translated">Учитывая форму массива, экземпляр &lt;a href=&quot;#numpy.ndindex&quot;&gt; &lt;code&gt;ndindex&lt;/code&gt; &lt;/a&gt; выполняет итерацию по N-мерному индексу массива. На каждой итерации возвращается кортеж индексов, последнее измерение повторяется по первому.</target>
        </trans-unit>
        <trans-unit id="6d84cece4ac6198159f79505d6fa6346cdc3c584" translate="yes" xml:space="preserve">
          <source>Given two &lt;em&gt;n&lt;/em&gt; -length arrays of integers, &lt;em&gt;l1&lt;/em&gt;, and &lt;em&gt;l2&lt;/em&gt;, return 1 if the lists are identical; otherwise, return 0.</source>
          <target state="translated">Для двух массивов целых чисел длиной &lt;em&gt;n&lt;/em&gt; , &lt;em&gt;l1&lt;/em&gt; и &lt;em&gt;l2&lt;/em&gt; , вернуть 1, если списки идентичны; в противном случае верните 0.</target>
        </trans-unit>
        <trans-unit id="b4d93ad7919330e367279622118fac9cd99eb66a" translate="yes" xml:space="preserve">
          <source>Given two array_like objects, check that the shape is equal and all elements of the first object are strictly smaller than those of the second object. An exception is raised at shape mismatch or incorrectly ordered values. Shape mismatch does not raise if an object has zero dimension. In contrast to the standard usage in numpy, NaNs are compared, no assertion is raised if both objects have NaNs in the same positions.</source>
          <target state="translated">Учитывая два объекта array_like,проверьте,что форма одинакова и все элементы первого объекта строго меньше элементов второго объекта.Исключение поднимается при несоответствии формы или неправильно упорядоченных значениях.Несоответствие формы не возникает,если объект имеет нулевую размерность.В отличие от стандартного использования в numpy,NaNs сравниваются,утверждение не поднимается,если оба объекта имеют NaNs в одинаковых позициях.</target>
        </trans-unit>
        <trans-unit id="33ed5b3e4d203313d72bfb61344b0ef20252735e" translate="yes" xml:space="preserve">
          <source>Given two array_like objects, check that the shape is equal and all elements of these objects are equal (but see the Notes for the special handling of a scalar). An exception is raised at shape mismatch or conflicting values. In contrast to the standard usage in numpy, NaNs are compared like numbers, no assertion is raised if both objects have NaNs in the same positions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="90fdf131a8e234662a4baf7342d5cbfdd8815673" translate="yes" xml:space="preserve">
          <source>Given two array_like objects, check that the shape is equal and all elements of these objects are equal. An exception is raised at shape mismatch or conflicting values. In contrast to the standard usage in numpy, NaNs are compared like numbers, no assertion is raised if both objects have NaNs in the same positions.</source>
          <target state="translated">Учитывая два объекта array_like,проверьте,что форма одинакова и все элементы этих объектов равны.Исключение поднимается при несовпадении формы или конфликтующих значениях.В отличие от стандартного использования в нумерации,NaNs сравниваются как числа,утверждение не поднимается,если оба объекта имеют NaNs в одинаковых позициях.</target>
        </trans-unit>
        <trans-unit id="03c045ae56fa8df86b5ce72f657667f3cc594e54" translate="yes" xml:space="preserve">
          <source>Given two numbers, check that they are approximately equal. Approximately equal is defined as the number of significant digits that agree.</source>
          <target state="translated">Учитывая два числа,проверьте,что они примерно равны.Приблизительно равное определяется как количество значащих цифр,которые совпадают.</target>
        </trans-unit>
        <trans-unit id="d9d002c83204235df23caf3ec14f4354842036c7" translate="yes" xml:space="preserve">
          <source>Given two objects (scalars, lists, tuples, dictionaries or numpy arrays), check that all elements of these objects are equal. An exception is raised at the first conflicting values.</source>
          <target state="translated">Учитывая два объекта (скаляры,списки,кортежи,словари или нумерованные массивы),проверьте,что все элементы этих объектов равны.Исключение поднимается при первых конфликтующих значениях.</target>
        </trans-unit>
        <trans-unit id="9d61f0f6669477d0eddf6043188e0f420dad8728" translate="yes" xml:space="preserve">
          <source>Given two polynomials &lt;code&gt;a1&lt;/code&gt; and &lt;code&gt;a2&lt;/code&gt;, returns &lt;code&gt;a1 - a2&lt;/code&gt;. &lt;code&gt;a1&lt;/code&gt; and &lt;code&gt;a2&lt;/code&gt; can be either array_like sequences of the polynomials&amp;rsquo; coefficients (including coefficients equal to zero), or &lt;a href=&quot;numpy.poly1d#numpy.poly1d&quot;&gt;&lt;code&gt;poly1d&lt;/code&gt;&lt;/a&gt; objects.</source>
          <target state="translated">Для двух полиномов &lt;code&gt;a1&lt;/code&gt; и &lt;code&gt;a2&lt;/code&gt; возвращает &lt;code&gt;a1 - a2&lt;/code&gt; . &lt;code&gt;a1&lt;/code&gt; и &lt;code&gt;a2&lt;/code&gt; могут быть либо array_like последовательностями коэффициентов полиномов (включая коэффициенты, равные нулю), либо объектами &lt;a href=&quot;numpy.poly1d#numpy.poly1d&quot;&gt; &lt;code&gt;poly1d&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8737cb46ba6778426f460962013153a76a798f04" translate="yes" xml:space="preserve">
          <source>Given two tensors, &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt;, and an array_like object containing two array_like objects, &lt;code&gt;(a_axes, b_axes)&lt;/code&gt;, sum the products of &lt;code&gt;a&lt;/code&gt;&amp;rsquo;s and &lt;code&gt;b&lt;/code&gt;&amp;rsquo;s elements (components) over the axes specified by &lt;code&gt;a_axes&lt;/code&gt; and &lt;code&gt;b_axes&lt;/code&gt;. The third argument can be a single non-negative integer_like scalar, &lt;code&gt;N&lt;/code&gt;; if it is such, then the last &lt;code&gt;N&lt;/code&gt; dimensions of &lt;code&gt;a&lt;/code&gt; and the first &lt;code&gt;N&lt;/code&gt; dimensions of &lt;code&gt;b&lt;/code&gt; are summed over.</source>
          <target state="translated">Учитывая два тензора, &lt;code&gt;a&lt;/code&gt; и &lt;code&gt;b&lt;/code&gt; , и объект array_like, содержащий два объекта array_like, &lt;code&gt;(a_axes, b_axes)&lt;/code&gt; , просуммируйте произведения элементов (компонентов) &lt;code&gt;a&lt;/code&gt; &amp;rsquo;s и &lt;code&gt;b&lt;/code&gt; &amp;rsquo; s по осям, заданным &lt;code&gt;a_axes&lt;/code&gt; и &lt;code&gt;b_axes&lt;/code&gt; . Третий аргумент может быть единственным неотрицательным целочисленным скаляром &lt;code&gt;N&lt;/code&gt; ; если это так, то суммируются последние &lt;code&gt;N&lt;/code&gt; измерений &lt;code&gt;a&lt;/code&gt; и первые &lt;code&gt;N&lt;/code&gt; измерений &lt;code&gt;b&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1bcbaa6d418fa3c95df027de6ff9d3bb5387a091" translate="yes" xml:space="preserve">
          <source>Given two vectors, &lt;code&gt;a = [a0, a1, ..., aM]&lt;/code&gt; and &lt;code&gt;b = [b0, b1, ..., bN]&lt;/code&gt;, the outer product &lt;a href=&quot;#r14e6c54b746b-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt; is:</source>
          <target state="translated">Для двух векторов &lt;code&gt;a = [a0, a1, ..., aM]&lt;/code&gt; и &lt;code&gt;b = [b0, b1, ..., bN]&lt;/code&gt; внешнее произведение &lt;a href=&quot;#r14e6c54b746b-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt; будет:</target>
        </trans-unit>
        <trans-unit id="3854728349ae7af32452ae7e4400a155448f9794" translate="yes" xml:space="preserve">
          <source>Given two vectors, &lt;code&gt;a = [a0, a1, ..., aM]&lt;/code&gt; and &lt;code&gt;b = [b0, b1, ..., bN]&lt;/code&gt;, the outer product &lt;a href=&quot;#r863504129d6e-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt; is:</source>
          <target state="translated">Для двух векторов &lt;code&gt;a = [a0, a1, ..., aM]&lt;/code&gt; и &lt;code&gt;b = [b0, b1, ..., bN]&lt;/code&gt; внешнее произведение &lt;a href=&quot;#r863504129d6e-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt; будет:</target>
        </trans-unit>
        <trans-unit id="80ea28027215a4aa397564db3b7818bf4ec592b8" translate="yes" xml:space="preserve">
          <source>Given two vectors, &lt;code&gt;a = [a0, a1, ..., aM]&lt;/code&gt; and &lt;code&gt;b = [b0, b1, ..., bN]&lt;/code&gt;, the outer product &lt;a href=&quot;#rf0d57dd5badd-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt; is:</source>
          <target state="translated">Для двух векторов &lt;code&gt;a = [a0, a1, ..., aM]&lt;/code&gt; и &lt;code&gt;b = [b0, b1, ..., bN]&lt;/code&gt; внешнее произведение &lt;a href=&quot;#rf0d57dd5badd-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt; будет:</target>
        </trans-unit>
        <trans-unit id="4975cd64a92e88880758085eef7772db2bdb4f4d" translate="yes" xml:space="preserve">
          <source>Given:</source>
          <target state="translated">Given:</target>
        </trans-unit>
        <trans-unit id="882e099811dae6ac151e6bf8446fa672be3c6225" translate="yes" xml:space="preserve">
          <source>Gives a list of the names to exclude, such as &lt;code&gt;return&lt;/code&gt;, &lt;code&gt;file&lt;/code&gt;, &lt;code&gt;print&lt;/code&gt;&amp;hellip; If one of the input name is part of this list, an underscore character (&lt;code&gt;'_'&lt;/code&gt;) will be appended to it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8020f30b057521f3745170a52c99adab4537c734" translate="yes" xml:space="preserve">
          <source>Gives a new shape to an array without changing its data.</source>
          <target state="translated">Придает новую форму массиву без изменения его данных.</target>
        </trans-unit>
        <trans-unit id="1175f81a358d9e3f38210901aaa9e95baea2d5bc" translate="yes" xml:space="preserve">
          <source>Gives a string combining all the characters that must be deleted from the name. By default, invalid characters are &lt;code&gt;~!@#$%^&amp;amp;*()-=+~\|]}[{';:
/?.&amp;gt;,&amp;lt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f6df81d1943f224253f7e8824d4f6d90b5a6fd6" translate="yes" xml:space="preserve">
          <source>Glantz, Stanton A. &amp;ldquo;Primer of Biostatistics.&amp;rdquo;, McGraw-Hill, Fifth Edition, 2002.</source>
          <target state="translated">Гланц, Стэнтон А. &amp;laquo;Учебник по биостатистике&amp;raquo;, McGraw-Hill, Fifth Edition, 2002.</target>
        </trans-unit>
        <trans-unit id="98ce8e321806dbb3b91df4ce336400b327d82b05" translate="yes" xml:space="preserve">
          <source>Global State</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7427cf697be16a4ec1d916910128a59d920125e7" translate="yes" xml:space="preserve">
          <source>Glossary</source>
          <target state="translated">Glossary</target>
        </trans-unit>
        <trans-unit id="b5455baaf8bb77490bac48f282fc705e080b078c" translate="yes" xml:space="preserve">
          <source>Go to &lt;a href=&quot;https://github.com/numpy/numpy&quot;&gt;https://github.com/numpy/numpy&lt;/a&gt; and click the &amp;ldquo;fork&amp;rdquo; button to create your own copy of the project.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e307ec71f941bf50bb0ca58211aaf38b07c21cec" translate="yes" xml:space="preserve">
          <source>Go to &lt;a href=&quot;https://github.com/numpy/numpy/releases&quot;&gt;https://github.com/numpy/numpy/releases&lt;/a&gt;, there should be a &lt;code&gt;v1.14.5
tag&lt;/code&gt;, click on it and hit the edit button for that tag. There are two ways to add files, using an editable text window and as binary uploads.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a55f17953adb4e53b1ccccc7c663a01a1165b91" translate="yes" xml:space="preserve">
          <source>Go to GitHub. The new branch will show up with a green Pull Request button. Make sure the title and message are clear, concise, and self- explanatory. Then click the button to submit it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="69980c4426505922b99957185231ede61f777564" translate="yes" xml:space="preserve">
          <source>Go to github and make a PR.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a46869e8de50d59c9c1645cda5ce89ba58d2c65a" translate="yes" xml:space="preserve">
          <source>Go to the &lt;a href=&quot;https://www.numpy.org&quot;&gt;NumPy&lt;/a&gt; github home at &lt;a href=&quot;https://github.com/numpy/numpy&quot;&gt;NumPy github&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb3f0c82f9a531318bc29fd46c7f891f5c55b9a1" translate="yes" xml:space="preserve">
          <source>Good for wrapping large (many functions) existing C libraries</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="69bb06bd200ddbdceda42084b415b9a92259f61a" translate="yes" xml:space="preserve">
          <source>Google offers two free &lt;a href=&quot;https://developers.google.com/tech-writing&quot;&gt;Technical Writing Courses&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="823619e079c311b099f1d0e427a584eafcd6ed06" translate="yes" xml:space="preserve">
          <source>Governance</source>
          <target state="translated">Governance</target>
        </trans-unit>
        <trans-unit id="99a7f06ad80d74e23ee701e64001d24ce844ca07" translate="yes" xml:space="preserve">
          <source>Gradient is calculated only along the given axis or axes The default (axis = None) is to calculate the gradient for all the axes of the input array. axis may be negative, in which case it counts from the last to the first axis.</source>
          <target state="translated">Градиент рассчитывается только вдоль данной оси или осей По умолчанию (ось=Нет)градиент рассчитывается для всех осей входного массива.Ось может быть отрицательной,в этом случае градиент отсчитывается от последней к первой оси.</target>
        </trans-unit>
        <trans-unit id="61aa58c2b09a3034acae73f52494d42574c0ca1c" translate="yes" xml:space="preserve">
          <source>Gradient is calculated using N-th order accurate differences at the boundaries. Default: 1.</source>
          <target state="translated">Градиент рассчитывается с использованием точных разностей N-го порядка на границах.По умолчанию:1.</target>
        </trans-unit>
        <trans-unit id="ea0fcf87d2287941521d49f814fee6c705ce244c" translate="yes" xml:space="preserve">
          <source>Graphical illustration of &lt;code&gt;endpoint&lt;/code&gt; parameter:</source>
          <target state="translated">Графическая иллюстрация параметра &lt;code&gt;endpoint&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="bb4d80637c2066c9e7bffa72841d8f27a47b292b" translate="yes" xml:space="preserve">
          <source>Graphical illustration:</source>
          <target state="translated">Графическая иллюстрация:</target>
        </trans-unit>
        <trans-unit id="4a52fe6ab66ec52ee6bfd51d48518f7de2e194f9" translate="yes" xml:space="preserve">
          <source>Greater consistency in &lt;code&gt;assert_almost_equal&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="55d14a2a20cf23aef24c6cf5ba97cf49567e1739" translate="yes" xml:space="preserve">
          <source>Greedy &lt;a href=&quot;#numpy.einsum&quot;&gt;&lt;code&gt;einsum&lt;/code&gt;&lt;/a&gt; (faster optimal path approximation): ~160ms</source>
          <target state="translated">Жадный &lt;a href=&quot;#numpy.einsum&quot;&gt; &lt;code&gt;einsum&lt;/code&gt; &lt;/a&gt; (более быстрое приближение оптимального пути): ~ 160 мс</target>
        </trans-unit>
        <trans-unit id="f6534be852374768c36e7beef74b1f4199fef68a" translate="yes" xml:space="preserve">
          <source>Grid-shaped arrays of evenly spaced numbers in N-dimensions.</source>
          <target state="translated">Сетчатые массивы равномерно распределенных чисел в N-размерах.</target>
        </trans-unit>
        <trans-unit id="d291656cb315e59b3437432c3e771768a130826d" translate="yes" xml:space="preserve">
          <source>Group 1</source>
          <target state="translated">Группа 1</target>
        </trans-unit>
        <trans-unit id="374327355d21f90b289f6f435aa2da5d797f0ae6" translate="yes" xml:space="preserve">
          <source>Group 2</source>
          <target state="translated">Группа 2</target>
        </trans-unit>
        <trans-unit id="f5ac35811e25f377d3ea665e7f41177582e5b116" translate="yes" xml:space="preserve">
          <source>Guaranteeing safe aligned access for ufuncs/setitem/casting code</source>
          <target state="translated">Гарантия безопасного выровненного доступа для кода ufuncs/setitem/casting</target>
        </trans-unit>
        <trans-unit id="f454c80c182290ac641c3ab02a9edcdbe149e617" translate="yes" xml:space="preserve">
          <source>Guide to writing Tutorials (TODO)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d49ac2fe6a93b218baff7cae5e0e60393e7661a" translate="yes" xml:space="preserve">
          <source>Guide to writing reference (API) documentation: the numpydoc docstring guide</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="141d1d74d8a6b3e7a7f1418ef539a53ce746ef34" translate="yes" xml:space="preserve">
          <source>Guidelines</source>
          <target state="translated">Guidelines</target>
        </trans-unit>
        <trans-unit id="fefaa04c360e4a9e3930a2840029cc9f56039f5f" translate="yes" xml:space="preserve">
          <source>Gumbel, E. J., &amp;ldquo;Statistics of Extremes,&amp;rdquo; New York: Columbia University Press, 1958.</source>
          <target state="translated">Гамбел, Э. Дж., &amp;laquo;Статистика крайностей&amp;raquo;, Нью-Йорк: издательство Колумбийского университета, 1958.</target>
        </trans-unit>
        <trans-unit id="7cf184f4c67ad58283ecb19349720b0cae756829" translate="yes" xml:space="preserve">
          <source>H</source>
          <target state="translated">H</target>
        </trans-unit>
        <trans-unit id="a23a715b33c5262fe3d1b937504a94f4b675a4b6" translate="yes" xml:space="preserve">
          <source>H() (numpy.matrix property)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b40b37f0341f572e1998e910b25532a92af5b558" translate="yes" xml:space="preserve">
          <source>Hack away! See &lt;a href=&quot;#editing-workflow&quot;&gt;below&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ecd57d6fb3350fcd694b91496d526594622dbb6" translate="yes" xml:space="preserve">
          <source>Half precision float: sign bit, 5 bits exponent, 10 bits mantissa</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c895f403bde1ed69e17f92c19862768cc5f5de8d" translate="yes" xml:space="preserve">
          <source>Half-precision functions</source>
          <target state="translated">Функции полуточной точности</target>
        </trans-unit>
        <trans-unit id="188b61888bd344a019188c5ddd9af8e491599b6a" translate="yes" xml:space="preserve">
          <source>Hand-generated wrappers</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="636dbc8830ea645ecf6015e1f4a6dd1accda26f4" translate="yes" xml:space="preserve">
          <source>Handled by &lt;a href=&quot;#c.NpyIter_MultiNew&quot;&gt;&lt;code&gt;NpyIter_MultiNew&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">Обрабатывается &lt;a href=&quot;#c.NpyIter_MultiNew&quot;&gt; &lt;code&gt;NpyIter_MultiNew&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="7178628eaa2183565412d3981a3508d31193d4b5" translate="yes" xml:space="preserve">
          <source>Handling complex numbers</source>
          <target state="translated">Обработка комплексных номеров</target>
        </trans-unit>
        <trans-unit id="0294f5e8c997832af6154aa5a34d3bc487dacc89" translate="yes" xml:space="preserve">
          <source>Handling of higher-dimensional arrays (ndim &amp;gt; 2)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="29536b0ea00b813744dd07cc20d7e2d652df9775" translate="yes" xml:space="preserve">
          <source>Handling of vectors (one-dimensional arrays)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="210d84fcc7fb5c4b75800916312424c57f881c7b" translate="yes" xml:space="preserve">
          <source>Handling the &lt;code&gt;fill_value&lt;/code&gt;</source>
          <target state="translated">Обработка &lt;code&gt;fill_value&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7e59976d95e4c0283fbcfa38c1a2f893c3bfd15d" translate="yes" xml:space="preserve">
          <source>Handling the mask</source>
          <target state="translated">Обращение с маской</target>
        </trans-unit>
        <trans-unit id="78dcc8157bbf5d134fc488651952052da7016437" translate="yes" xml:space="preserve">
          <source>Hard-coded dimensions, data-buffer-then-dimensions specification, and dimensions-then-data-buffer specification.</source>
          <target state="translated">Жестко заданные размеры,спецификация буфера данных,спецификация буфера данных.</target>
        </trans-unit>
        <trans-unit id="edfcf418a2bb124e6b8ce652d8bb7600c0be7269" translate="yes" xml:space="preserve">
          <source>Hardness of the mask</source>
          <target state="translated">Твердость маски</target>
        </trans-unit>
        <trans-unit id="a06e8ccba0be0394ad2df2eedd04a51d1a1039c5" translate="yes" xml:space="preserve">
          <source>Has no effect, do not use.</source>
          <target state="translated">Не имеет эффекта,не используется.</target>
        </trans-unit>
        <trans-unit id="4669500ffada7a9acbed3d1bf7fceec5a930f074" translate="yes" xml:space="preserve">
          <source>Has the same shape as &lt;code&gt;element&lt;/code&gt;. The values &lt;code&gt;element[isin]&lt;/code&gt; are in &lt;code&gt;test_elements&lt;/code&gt;.</source>
          <target state="translated">Имеет ту же форму, что и &lt;code&gt;element&lt;/code&gt; . Элемент values &lt;code&gt;element[isin]&lt;/code&gt; находится в &lt;code&gt;test_elements&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2d794659e95706af6481a92a9285f876ae1c7d63" translate="yes" xml:space="preserve">
          <source>Have a look at the &lt;a href=&quot;https://github.com/numpy/numpy&quot;&gt;github&lt;/a&gt; install help pages available from &lt;a href=&quot;https://help.github.com&quot;&gt;github help&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ab4d88ad951423d45baeab75192e5801e748751" translate="yes" xml:space="preserve">
          <source>Have a shared library.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d944005e31393bd466d7655b38df2b420878ca75" translate="yes" xml:space="preserve">
          <source>Having a shared library</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f62bdff9b904bdda1a1ed9ed602657769f3345fd" translate="yes" xml:space="preserve">
          <source>Having compiled code also means that importing NumPy from the development sources needs some additional steps, which are explained below. For the rest of this chapter we assume that you have set up your git repo as described in &lt;a href=&quot;gitwash/index#using-git&quot;&gt;Git for development&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce7b6e9a18227e2359efe8c98f693affe997e690" translate="yes" xml:space="preserve">
          <source>Heckert, N. A. and Filliben, James J. &amp;ldquo;NIST Handbook 148: Dataplot Reference Manual, Volume 2: Let Subcommands and Library Functions&amp;rdquo;, National Institute of Standards and Technology Handbook Series, June 2003. &lt;a href=&quot;https://www.itl.nist.gov/div898/software/dataplot/refman2/auxillar/powpdf.pdf&quot;&gt;https://www.itl.nist.gov/div898/software/dataplot/refman2/auxillar/powpdf.pdf&lt;/a&gt;</source>
          <target state="translated">Хекерт, Н. А. и Филлибен, Джеймс Дж. &amp;laquo;Справочник NIST 148: Справочное руководство по Dataplot, Том 2: Подкоманды Let и библиотечные функции&amp;raquo;, Серия справочников Национального института стандартов и технологий, июнь 2003 г. &lt;a href=&quot;https://www.itl.nist.gov/div898/software/dataplot/refman2/auxillar/powpdf.pdf&quot;&gt;https: //www.itl.nist. gov / div898 / программное обеспечение / dataplot / refman2 / auxillar / powpdf.pdf&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f25b2d1977ec1a7cc15a3fe3ee364cef6feeebb6" translate="yes" xml:space="preserve">
          <source>Help increase engagement in good discussion practice: try to identify where discussion may have broken down and provide actionable information, pointers and resources that can lead to positive change on these points.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="334c16fc9ac63595f080f7bbcdf324a43ffd5267" translate="yes" xml:space="preserve">
          <source>Helper Functions</source>
          <target state="translated">Функции помощника</target>
        </trans-unit>
        <trans-unit id="3cffecba0fc696fb0b452757e50e8d2d6aa15660" translate="yes" xml:space="preserve">
          <source>Helper for pickle.</source>
          <target state="translated">Помощник для огурцов.</target>
        </trans-unit>
        <trans-unit id="8e0ce1fc0fa49364a15481aa8d6e74b5ad646a8c" translate="yes" xml:space="preserve">
          <source>Helper routines</source>
          <target state="translated">Порядок действий помощника</target>
        </trans-unit>
        <trans-unit id="591b0ee67a75bdd05c2441f5d821e72ac5abd9ff" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;&amp;lt;fortran files&amp;gt;&lt;/code&gt; may also contain signature files. Among other options (see below), the following options can be used in this mode:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ad119f3969c50ae36c69dfd7a8f2258a296a9e4" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;x&lt;/code&gt; is a one-dimensional array of length two whose datatype is a structure with three fields: 1. A string of length 10 or less named &amp;lsquo;name&amp;rsquo;, 2. a 32-bit integer named &amp;lsquo;age&amp;rsquo;, and 3. a 32-bit float named &amp;lsquo;weight&amp;rsquo;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="05d939cfc36f7e101c6969543d3aa4fc112af1c5" translate="yes" xml:space="preserve">
          <source>Here appropriately means at least two tabs. It isn&amp;rsquo;t necessary to line everything up with the opening parenthesis of the function call.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="41762c3a1457e94bd62a7f7522c1df055434f548" translate="yes" xml:space="preserve">
          <source>Here are examples of shapes that do not broadcast:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f2d508ec85c3c97b5a1229502e255e40023669a" translate="yes" xml:space="preserve">
          <source>Here are several examples of custom weekmask values. These examples specify the &amp;ldquo;busday&amp;rdquo; default of Monday through Friday being valid days.</source>
          <target state="translated">Вот несколько примеров пользовательских значений недельной маски. В этих примерах указывается, что рабочий день по умолчанию с понедельника по пятницу является действительным днем.</target>
        </trans-unit>
        <trans-unit id="4cc8d83645ead10353d3c11cd3d81d28f5fe4bc7" translate="yes" xml:space="preserve">
          <source>Here are some examples of signatures:</source>
          <target state="translated">Вот несколько примеров подписей:</target>
        </trans-unit>
        <trans-unit id="c7c80754b6ccbe7d6353c18ee79360b34170e3a5" translate="yes" xml:space="preserve">
          <source>Here are some more examples:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="edcf4d32cc0d6364c8d8b907e9c3e1d6fd286f96" translate="yes" xml:space="preserve">
          <source>Here are the date units:</source>
          <target state="translated">Вот единицы даты:</target>
        </trans-unit>
        <trans-unit id="fcedd65241f400ab6b9cead2ae708d4ee0595afe" translate="yes" xml:space="preserve">
          <source>Here brackets &lt;code&gt;[]&lt;/code&gt; indicate an optional part, dots &lt;code&gt;...&lt;/code&gt; indicate one or more of a previous part. So, &lt;code&gt;[]...&lt;/code&gt; reads zero or more of a previous part.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a598f6524593a5ce80868abd4ad9058d26e6370" translate="yes" xml:space="preserve">
          <source>Here is a class that takes a standard ndarray that already exists, casts as our type, and adds an extra attribute.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e64dc50ed3c98bebd079533bedfe8d3d04f0a87" translate="yes" xml:space="preserve">
          <source>Here is a conversion table for which functions to use with the new iterator:</source>
          <target state="translated">Ниже приведена таблица преобразования,для каких функций использовать новый итератор:</target>
        </trans-unit>
        <trans-unit id="ae703a87217d209b99ae68f8790ce06f1f882b70" translate="yes" xml:space="preserve">
          <source>Here is a list of some useful NumPy functions and methods names ordered in categories. See &lt;a href=&quot;../reference/routines#routines&quot;&gt;Routines&lt;/a&gt; for the full list.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c2fbbb0f1468c183a40201806e4aca9dcb3c7060" translate="yes" xml:space="preserve">
          <source>Here is a simple copy function using the iterator. The &lt;code&gt;order&lt;/code&gt; parameter is used to control the memory layout of the allocated result, typically &lt;a href=&quot;array#c.NPY_KEEPORDER&quot;&gt;&lt;code&gt;NPY_KEEPORDER&lt;/code&gt;&lt;/a&gt; is desired.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f499cb9c92d0a44a206fb77f5f29cb1c19da659" translate="yes" xml:space="preserve">
          <source>Here is a simple copy function using the iterator. The &lt;code&gt;order&lt;/code&gt; parameter is used to control the memory layout of the allocated result, typically &lt;a href=&quot;c-api.array#c.NPY_KEEPORDER&quot;&gt;&lt;code&gt;NPY_KEEPORDER&lt;/code&gt;&lt;/a&gt; is desired.</source>
          <target state="translated">Вот простая функция копирования с использованием итератора. Параметр &lt;code&gt;order&lt;/code&gt; используется для управления расположением памяти выделенного результата, обычно &lt;a href=&quot;c-api.array#c.NPY_KEEPORDER&quot;&gt; &lt;code&gt;NPY_KEEPORDER&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="955a08b4bff95343601789d2bf6e0369ccf3f1b3" translate="yes" xml:space="preserve">
          <source>Here is a useful idiom for getting contiguous copies instead of non-contiguous views.</source>
          <target state="translated">Вот полезная идиома для получения сопрягаемых копий вместо не сопрягаемых представлений.</target>
        </trans-unit>
        <trans-unit id="9908262441b7f09837e1f501a21d5cc69908d615" translate="yes" xml:space="preserve">
          <source>Here is an example function which operates like a &amp;ldquo;lambda&amp;rdquo; ufunc:</source>
          <target state="translated">Вот пример функции, которая работает как &amp;laquo;лямбда&amp;raquo; ufunc:</target>
        </trans-unit>
        <trans-unit id="1e3d31fc803b806643f783a13be59435e8ec2879" translate="yes" xml:space="preserve">
          <source>Here is an example outer product function:</source>
          <target state="translated">Вот пример функции внешнего продукта:</target>
        </trans-unit>
        <trans-unit id="3e01528c46f09f5f5d5be27407d90af619b21250" translate="yes" xml:space="preserve">
          <source>Here is how the variables above are used:</source>
          <target state="translated">Вот как используются вышеперечисленные переменные:</target>
        </trans-unit>
        <trans-unit id="1637a3171b3e141604dedb2e68519a7e5432d5d7" translate="yes" xml:space="preserve">
          <source>Here is how they can be used with a sample array:</source>
          <target state="translated">Вот как их можно использовать с массивом примеров:</target>
        </trans-unit>
        <trans-unit id="b9c4a8ea1157853e06ffc2f25fe3f9b079de55b6" translate="yes" xml:space="preserve">
          <source>Here is how we might write an &lt;code&gt;iter_add&lt;/code&gt; function, using the Python iterator protocol:</source>
          <target state="translated">Вот как мы могли бы написать функцию &lt;code&gt;iter_add&lt;/code&gt; , используя протокол итератора Python:</target>
        </trans-unit>
        <trans-unit id="82ebceae19f8e179d652196db8007bed9b016e84" translate="yes" xml:space="preserve">
          <source>Here is part of a Cython module named &lt;code&gt;add.pyx&lt;/code&gt; which implements the complex addition functions we previously implemented using f2py:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f27fb417254a59c4a73469e0d501f40b87bdc16a" translate="yes" xml:space="preserve">
          <source>Here is shown a modified version of the previous Fortran code, save it as &lt;code&gt;fib3.f&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="26ce084ba97f0fb601f4ee822ae6a8abc564ba7d" translate="yes" xml:space="preserve">
          <source>Here is the same function, but following the C-style pattern:</source>
          <target state="translated">Здесь та же самая функция,но по шаблону в стиле С:</target>
        </trans-unit>
        <trans-unit id="d4daff3ad7f47434c82a5051360f6f8f9147bcdd" translate="yes" xml:space="preserve">
          <source>Here the 4th and 5th rows are selected from the indexed array and combined to make a 2-D array.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="879104127602f2f170c22fa52acd13e1c1a2bd91" translate="yes" xml:space="preserve">
          <source>Here the &lt;code&gt;newaxis&lt;/code&gt; index operator inserts a new axis into &lt;code&gt;a&lt;/code&gt;, making it a two-dimensional &lt;code&gt;4x1&lt;/code&gt; array. Combining the &lt;code&gt;4x1&lt;/code&gt; array with &lt;code&gt;b&lt;/code&gt;, which has shape &lt;code&gt;(3,)&lt;/code&gt;, yields a &lt;code&gt;4x3&lt;/code&gt; array.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="386e95414daee162c67ba2f23612c05957e9c9fa" translate="yes" xml:space="preserve">
          <source>Here the newaxis index operator inserts a new axis into &lt;code&gt;a&lt;/code&gt;, making it a two-dimensional 4x1 array. &lt;a href=&quot;#figure-4&quot;&gt;Figure 4&lt;/a&gt; illustrates the stretching of both arrays to produce the desired 4x3 output array.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="948564e37f936b7d719e03a725d3b08432712a65" translate="yes" xml:space="preserve">
          <source>Here we give a list of short and useful tips.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a43ab7c4c94ff9df3968be0c3da83726730e60b3" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s the listing of sum_squares.pyx:</source>
          <target state="translated">Вот список sum_squares.pyx:</target>
        </trans-unit>
        <trans-unit id="4f05498cc571c5e0811d261874316f4fcd69c560" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s the short summary, complete TOC links are below:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="30babd25e27e87a901a32627496afe119a238cc9" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;x&lt;/code&gt; is a dictionary mapping keys to values, in this case the integer 1 to the string &amp;ldquo;one&amp;rdquo;, and the string &amp;ldquo;two&amp;rdquo; to the list &lt;code&gt;[1, 2]&lt;/code&gt;. The values may be accessed using their corresponding keys:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1bb0a1675e1ab72957846b002b2ccbd5daaee32d" translate="yes" xml:space="preserve">
          <source>Here, I&amp;rsquo;ve used the built-in enumerate iterator to return the iterator index as well as the value.</source>
          <target state="translated">Здесь я использовал встроенный итератор перечисления, чтобы вернуть индекс итератора, а также значение.</target>
        </trans-unit>
        <trans-unit id="423ebc2c2e7601fe55f4484a7fb3dc69ce69a81b" translate="yes" xml:space="preserve">
          <source>Here, U is drawn from the uniform distribution over (0,1].</source>
          <target state="translated">Здесь U берется из равномерного распределения по (0,1].</target>
        </trans-unit>
        <trans-unit id="b81e3c833ac1c20cf33999c717a7683fc509fd53" translate="yes" xml:space="preserve">
          <source>Here, you grabbed a section of your array from index position 3 through index position 8.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9958f2320c4c020dbe0ba918682ede328e6342d6" translate="yes" xml:space="preserve">
          <source>Hermite</source>
          <target state="translated">Hermite</target>
        </trans-unit>
        <trans-unit id="3e97b960fb6669c7ce3d868bc1ee39fbd840fc5f" translate="yes" xml:space="preserve">
          <source>Hermite (class in numpy.polynomial.hermite)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="666fe7ebc09d7395dcf2297ae16799bfb275707b" translate="yes" xml:space="preserve">
          <source>Hermite Class</source>
          <target state="translated">эрмитажный класс</target>
        </trans-unit>
        <trans-unit id="78bcd4fcaaa0c27a38e217337ec719b8d794b08b" translate="yes" xml:space="preserve">
          <source>Hermite Module, &amp;ldquo;Physicists&amp;rsquo;&amp;rdquo; (&lt;code&gt;numpy.polynomial.hermite&lt;/code&gt;)</source>
          <target state="translated">Модуль Эрмита, &amp;laquo;Физики&amp;raquo; ( &lt;code&gt;numpy.polynomial.hermite&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="20e36a23caee8661ea5087eb6b2833159c8b55f9" translate="yes" xml:space="preserve">
          <source>Hermite Module, &amp;ldquo;Physicists&amp;rsquo;&amp;rdquo; (numpy.polynomial.hermite)</source>
          <target state="translated">Модуль Эрмита, &amp;laquo;Физики&amp;raquo; (numpy.polynomial.hermite)</target>
        </trans-unit>
        <trans-unit id="4e51cfc7050a81e8b6b2247a7d2dcbdd5d5665a8" translate="yes" xml:space="preserve">
          <source>Hermite Module, “Physicists’” (numpy.polynomial.hermite)</source>
          <target state="translated">Эрмитажный модуль,&quot;Физики&quot; (нумпи.полиномиальный.гермит)</target>
        </trans-unit>
        <trans-unit id="7e732e7a329c7f9da3eef2d091dd68d62fa1ae1a" translate="yes" xml:space="preserve">
          <source>Hermite Series, &amp;ldquo;Physicists&amp;rdquo; (&lt;code&gt;numpy.polynomial.hermite&lt;/code&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d4d4eab91a42ee672e761807e2ccfac51f95da47" translate="yes" xml:space="preserve">
          <source>Hermite Series, &amp;ldquo;Physicists&amp;rdquo; (numpy.polynomial.hermite)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="321f1ab84f3ad6f4602b6463648250d7c017db66" translate="yes" xml:space="preserve">
          <source>Hermite coefficients in order of increasing degree, i.e, &lt;code&gt;(1, 2, 3)&lt;/code&gt; gives &lt;code&gt;1*H_0(x) + 2*H_1(X) + 3*H_2(x)&lt;/code&gt;.</source>
          <target state="translated">Коэффициенты Эрмита в порядке возрастания степени, то есть &lt;code&gt;(1, 2, 3)&lt;/code&gt; дает &lt;code&gt;1*H_0(x) + 2*H_1(X) + 3*H_2(x)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="030c6d9cd5a3996624a5dedd47cce0a8b255a2e1" translate="yes" xml:space="preserve">
          <source>Hermite coefficients ordered from low to high. If &lt;code&gt;y&lt;/code&gt; was 2-D, the coefficients for the data in column k of &lt;code&gt;y&lt;/code&gt; are in column &lt;code&gt;k&lt;/code&gt;.</source>
          <target state="translated">Коэффициенты Эрмита упорядочены по возрастанию. Если &lt;code&gt;y&lt;/code&gt; было 2-D, коэффициенты для данных в столбце k &lt;code&gt;y&lt;/code&gt; находятся в столбце &lt;code&gt;k&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fdaeee3c1bfcab3d833e2cd601bbef119c7ca375" translate="yes" xml:space="preserve">
          <source>Hermite series</source>
          <target state="translated">эрмитажный сериал</target>
        </trans-unit>
        <trans-unit id="5d7c6da49173b96e3654eaebdb82df4267a07cd8" translate="yes" xml:space="preserve">
          <source>Hermite series coefficients of the integral.</source>
          <target state="translated">Коэффициенты эрмитарного ряда интеграла.</target>
        </trans-unit>
        <trans-unit id="f178c08ed0e44e86c3dcdcdd94165f4d2159704d" translate="yes" xml:space="preserve">
          <source>Hermite series of power.</source>
          <target state="translated">Эрмита.</target>
        </trans-unit>
        <trans-unit id="4b1ee605707018d73fef71e944f33b064cb30198" translate="yes" xml:space="preserve">
          <source>Hermite series of the derivative.</source>
          <target state="translated">Эрмитская серия производной.</target>
        </trans-unit>
        <trans-unit id="f3b525d4a933addff05d89e23fb102c4771100af" translate="yes" xml:space="preserve">
          <source>Hermite series whose graph is a straight line.</source>
          <target state="translated">Эрмита,чей график представляет собой прямую линию.</target>
        </trans-unit>
        <trans-unit id="f15ba129dfce798b05af2ecf87c4c56e141a51c6" translate="yes" xml:space="preserve">
          <source>Hermite weight function</source>
          <target state="translated">функция веса эрмита</target>
        </trans-unit>
        <trans-unit id="e91ac76ec50377772a4d0a0fad317ac36bda67d9" translate="yes" xml:space="preserve">
          <source>Hermite.__call__()</source>
          <target state="translated">Hermite.__call__()</target>
        </trans-unit>
        <trans-unit id="e00caea2e8b760013383648bd7a0c8356ad2d21a" translate="yes" xml:space="preserve">
          <source>Hermite.basis()</source>
          <target state="translated">Hermite.basis()</target>
        </trans-unit>
        <trans-unit id="510f491be62b2a7e3419873aabcc929cba4aad0a" translate="yes" xml:space="preserve">
          <source>Hermite.cast()</source>
          <target state="translated">Hermite.cast()</target>
        </trans-unit>
        <trans-unit id="0bbb26adb9485391c59073a0150f1aeb28250175" translate="yes" xml:space="preserve">
          <source>Hermite.convert()</source>
          <target state="translated">Hermite.convert()</target>
        </trans-unit>
        <trans-unit id="46e59fa3efb39aa8de99b77595a66c5aca6f95af" translate="yes" xml:space="preserve">
          <source>Hermite.copy()</source>
          <target state="translated">Hermite.copy()</target>
        </trans-unit>
        <trans-unit id="150883af29979fdad32a1485afaa265ae485116d" translate="yes" xml:space="preserve">
          <source>Hermite.cutdeg()</source>
          <target state="translated">Hermite.cutdeg()</target>
        </trans-unit>
        <trans-unit id="6e3addaaf8a990d63bd9644e879a45bfaaa3d048" translate="yes" xml:space="preserve">
          <source>Hermite.degree()</source>
          <target state="translated">Hermite.degree()</target>
        </trans-unit>
        <trans-unit id="1898e27484be79666c2d0d0671ff99bb73c61fb0" translate="yes" xml:space="preserve">
          <source>Hermite.deriv()</source>
          <target state="translated">Hermite.deriv()</target>
        </trans-unit>
        <trans-unit id="74d98daf1082d857dc8043ef7d611943987bcbf6" translate="yes" xml:space="preserve">
          <source>Hermite.domain</source>
          <target state="translated">Hermite.domain</target>
        </trans-unit>
        <trans-unit id="69a9477b050cf5e84517bc3ba4b2540b289809dd" translate="yes" xml:space="preserve">
          <source>Hermite.fit()</source>
          <target state="translated">Hermite.fit()</target>
        </trans-unit>
        <trans-unit id="ee377bb8277d3cc87539518382039049d3434ab2" translate="yes" xml:space="preserve">
          <source>Hermite.fromroots()</source>
          <target state="translated">Hermite.fromroots()</target>
        </trans-unit>
        <trans-unit id="f3d364e431135afb3032332cc59ddec1d0087c65" translate="yes" xml:space="preserve">
          <source>Hermite.has_samecoef()</source>
          <target state="translated">Hermite.has_samecoef()</target>
        </trans-unit>
        <trans-unit id="4f5a15af827e1a34e56c335924bc117f06d9550b" translate="yes" xml:space="preserve">
          <source>Hermite.has_samedomain()</source>
          <target state="translated">Hermite.has_samedomain()</target>
        </trans-unit>
        <trans-unit id="5c6b35ea3f6249366ad14a64bf61b1e2f4ef3fa2" translate="yes" xml:space="preserve">
          <source>Hermite.has_sametype()</source>
          <target state="translated">Hermite.has_sametype()</target>
        </trans-unit>
        <trans-unit id="51595f8a76f511b51c25db7ca6799c30af573ff1" translate="yes" xml:space="preserve">
          <source>Hermite.has_samewindow()</source>
          <target state="translated">Hermite.has_samewindow()</target>
        </trans-unit>
        <trans-unit id="fae0683eb07169c7856c805873bd384998f4ce23" translate="yes" xml:space="preserve">
          <source>Hermite.identity()</source>
          <target state="translated">Hermite.identity()</target>
        </trans-unit>
        <trans-unit id="6d7f1a135c9fd7bdb20e45551f21a01a1b98749d" translate="yes" xml:space="preserve">
          <source>Hermite.integ()</source>
          <target state="translated">Hermite.integ()</target>
        </trans-unit>
        <trans-unit id="87c4ac5818fcc034b0a86594470677888839404b" translate="yes" xml:space="preserve">
          <source>Hermite.linspace()</source>
          <target state="translated">Hermite.linspace()</target>
        </trans-unit>
        <trans-unit id="e4e8e042f2bff68022c1506a796ae1f2b1a45e62" translate="yes" xml:space="preserve">
          <source>Hermite.mapparms()</source>
          <target state="translated">Hermite.mapparms()</target>
        </trans-unit>
        <trans-unit id="dd2d324dc15bd07b8d8eba7c1b9a303c6e61cbe9" translate="yes" xml:space="preserve">
          <source>Hermite.roots()</source>
          <target state="translated">Hermite.roots()</target>
        </trans-unit>
        <trans-unit id="357de88ac6a59383fa4db68dc02a30a97aa55b31" translate="yes" xml:space="preserve">
          <source>Hermite.trim()</source>
          <target state="translated">Hermite.trim()</target>
        </trans-unit>
        <trans-unit id="ded6de456aef1c9f3f0dbb030eecbec360a2a3d9" translate="yes" xml:space="preserve">
          <source>Hermite.truncate()</source>
          <target state="translated">Hermite.truncate()</target>
        </trans-unit>
        <trans-unit id="bfa82105a95ddf719538cbbbc2136f5bdc652b85" translate="yes" xml:space="preserve">
          <source>HermiteE</source>
          <target state="translated">HermiteE</target>
        </trans-unit>
        <trans-unit id="213b3add1699deb17fd0362b28ee9eaa1e08297e" translate="yes" xml:space="preserve">
          <source>HermiteE (class in numpy.polynomial.hermite_e)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6628b3304670336395ae6732f06085678ac90c72" translate="yes" xml:space="preserve">
          <source>HermiteE Class</source>
          <target state="translated">Класс &quot;Эрмитаж</target>
        </trans-unit>
        <trans-unit id="da640bfdcf0affcdb1cb3e699294b822aff50f4d" translate="yes" xml:space="preserve">
          <source>HermiteE Module, &amp;ldquo;Probabilists&amp;rsquo;&amp;rdquo; (&lt;code&gt;numpy.polynomial.hermite_e&lt;/code&gt;)</source>
          <target state="translated">Модуль HermiteE, &amp;laquo;Вероятностные&amp;raquo; ( &lt;code&gt;numpy.polynomial.hermite_e&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="93c34719e313928a50611a43ea25a148a84b264b" translate="yes" xml:space="preserve">
          <source>HermiteE Module, &amp;ldquo;Probabilists&amp;rsquo;&amp;rdquo; (numpy.polynomial.hermite_e)</source>
          <target state="translated">Модуль HermiteE, &amp;laquo;Вероятностные&amp;raquo; (numpy.polynomial.hermite_e)</target>
        </trans-unit>
        <trans-unit id="56f6680ec7b317dd6ae3f4dbb7e9720ab2e6af02" translate="yes" xml:space="preserve">
          <source>HermiteE Module, “Probabilists’” (numpy.polynomial.hermite_e)</source>
          <target state="translated">Модуль HermiteE,&quot;Вероятности&quot; (numpy.polynomial.hermite_e)</target>
        </trans-unit>
        <trans-unit id="a7da5893b105551d489e12a654065cc1aa5b0de0" translate="yes" xml:space="preserve">
          <source>HermiteE Series, &amp;ldquo;Probabilists&amp;rdquo; (&lt;code&gt;numpy.polynomial.hermite_e&lt;/code&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01652b3974c2bf789bf8511d4ddd036a45eab615" translate="yes" xml:space="preserve">
          <source>HermiteE Series, &amp;ldquo;Probabilists&amp;rdquo; (numpy.polynomial.hermite_e)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7090e745bd4427b0619b5249b32836cf9e710c91" translate="yes" xml:space="preserve">
          <source>HermiteE coefficients in order of increasing degree, i.e, &lt;code&gt;(1, 2, 3)&lt;/code&gt; gives &lt;code&gt;1*He_0(x) + 2*He_1(X) + 3*He_2(x)&lt;/code&gt;.</source>
          <target state="translated">Коэффициенты HermiteE в порядке возрастания, то есть &lt;code&gt;(1, 2, 3)&lt;/code&gt; дает &lt;code&gt;1*He_0(x) + 2*He_1(X) + 3*He_2(x)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8fdce93a022f8c8da6190fdc0f7e0fa2783e7c6d" translate="yes" xml:space="preserve">
          <source>HermiteE series</source>
          <target state="translated">серия HermiteE</target>
        </trans-unit>
        <trans-unit id="f8a256fa19026169a866b5809900fc5fb915e807" translate="yes" xml:space="preserve">
          <source>HermiteE weight function.</source>
          <target state="translated">Весовая функция HermiteE.</target>
        </trans-unit>
        <trans-unit id="f2a1b68f303ab3a67abc7b2e4c4c8451183b7095" translate="yes" xml:space="preserve">
          <source>HermiteE.__call__()</source>
          <target state="translated">HermiteE.__call__()</target>
        </trans-unit>
        <trans-unit id="45c27d16e911c80a7d363f3c39ba54997fd020cd" translate="yes" xml:space="preserve">
          <source>HermiteE.basis()</source>
          <target state="translated">HermiteE.basis()</target>
        </trans-unit>
        <trans-unit id="b45b6525bda44ccf736a4ef59137ed1b81c51100" translate="yes" xml:space="preserve">
          <source>HermiteE.cast()</source>
          <target state="translated">HermiteE.cast()</target>
        </trans-unit>
        <trans-unit id="4ddefc1ce033e171e5d4661134688bd82e8bc5af" translate="yes" xml:space="preserve">
          <source>HermiteE.convert()</source>
          <target state="translated">HermiteE.convert()</target>
        </trans-unit>
        <trans-unit id="002903a3a64a57beced04a1c5706dd609af411f5" translate="yes" xml:space="preserve">
          <source>HermiteE.copy()</source>
          <target state="translated">HermiteE.copy()</target>
        </trans-unit>
        <trans-unit id="b24cf643ce7571c11b38beb07f1dba60d0898965" translate="yes" xml:space="preserve">
          <source>HermiteE.cutdeg()</source>
          <target state="translated">HermiteE.cutdeg()</target>
        </trans-unit>
        <trans-unit id="564634c0d69d527c3b8fbcf352579c91cc6babc0" translate="yes" xml:space="preserve">
          <source>HermiteE.degree()</source>
          <target state="translated">HermiteE.degree()</target>
        </trans-unit>
        <trans-unit id="b0998c48dfd3e6da9f8d9a094fe9026de37d9068" translate="yes" xml:space="preserve">
          <source>HermiteE.deriv()</source>
          <target state="translated">HermiteE.deriv()</target>
        </trans-unit>
        <trans-unit id="e3b7e4ce40140bfad9d15417ff37a5918c3d9ee7" translate="yes" xml:space="preserve">
          <source>HermiteE.domain</source>
          <target state="translated">HermiteE.domain</target>
        </trans-unit>
        <trans-unit id="b9a9cf1e6530dd58c8fe754b4c5e909f051929ea" translate="yes" xml:space="preserve">
          <source>HermiteE.fit()</source>
          <target state="translated">HermiteE.fit()</target>
        </trans-unit>
        <trans-unit id="4a10eb67a6e8118b67d08f9c1672e5c1ef31f7e7" translate="yes" xml:space="preserve">
          <source>HermiteE.fromroots()</source>
          <target state="translated">HermiteE.fromroots()</target>
        </trans-unit>
        <trans-unit id="f215586092039a3f249d19a38ef5f2e5c8b9fe46" translate="yes" xml:space="preserve">
          <source>HermiteE.has_samecoef()</source>
          <target state="translated">HermiteE.has_samecoef()</target>
        </trans-unit>
        <trans-unit id="e303961ece2b00de2ea59d3add859f3b9afba3be" translate="yes" xml:space="preserve">
          <source>HermiteE.has_samedomain()</source>
          <target state="translated">HermiteE.has_samedomain()</target>
        </trans-unit>
        <trans-unit id="56c531828abb17c1fa8561b9e8274772104c7875" translate="yes" xml:space="preserve">
          <source>HermiteE.has_sametype()</source>
          <target state="translated">HermiteE.has_sametype()</target>
        </trans-unit>
        <trans-unit id="f597206a0348307571c5766a04f0329e0e5977a6" translate="yes" xml:space="preserve">
          <source>HermiteE.has_samewindow()</source>
          <target state="translated">HermiteE.has_samewindow()</target>
        </trans-unit>
        <trans-unit id="edecbdf0322d9c36d15b82f596749f9baa998818" translate="yes" xml:space="preserve">
          <source>HermiteE.identity()</source>
          <target state="translated">HermiteE.identity()</target>
        </trans-unit>
        <trans-unit id="50879495edc6ec638987e4aab2fb5c3ff2693ffc" translate="yes" xml:space="preserve">
          <source>HermiteE.integ()</source>
          <target state="translated">HermiteE.integ()</target>
        </trans-unit>
        <trans-unit id="7644c7d4879b67345881eccc21f74f5ac1d76221" translate="yes" xml:space="preserve">
          <source>HermiteE.linspace()</source>
          <target state="translated">HermiteE.linspace()</target>
        </trans-unit>
        <trans-unit id="71240e92395878a17c98ad6cabf8e728e1e375a7" translate="yes" xml:space="preserve">
          <source>HermiteE.mapparms()</source>
          <target state="translated">HermiteE.mapparms()</target>
        </trans-unit>
        <trans-unit id="918dc10943107e5fa1f93651ccb4cc1d4ca399a0" translate="yes" xml:space="preserve">
          <source>HermiteE.roots()</source>
          <target state="translated">HermiteE.roots()</target>
        </trans-unit>
        <trans-unit id="6c5620ec0bf2dc54449e61b049184a2294791751" translate="yes" xml:space="preserve">
          <source>HermiteE.trim()</source>
          <target state="translated">HermiteE.trim()</target>
        </trans-unit>
        <trans-unit id="8b9f703c9558cb71c68ad02c3049b60b8b59198b" translate="yes" xml:space="preserve">
          <source>HermiteE.truncate()</source>
          <target state="translated">HermiteE.truncate()</target>
        </trans-unit>
        <trans-unit id="a2691f3b6c74bc9be228ebe1bfd4aaa8b167edac" translate="yes" xml:space="preserve">
          <source>Hermite_e series coefficients of the integral.</source>
          <target state="translated">Коэффициенты ряда Hermite_e интеграла.</target>
        </trans-unit>
        <trans-unit id="cb6305ebb37efa97b74f55f04adb878c2cfd6823" translate="yes" xml:space="preserve">
          <source>Hermitian (symmetric if all elements are real), positive-definite input matrix.</source>
          <target state="translated">Гермитский (симметричный,если все элементы вещественные),входная матрица с положительным значением.</target>
        </trans-unit>
        <trans-unit id="559550c9b0251579dbef6add2f3cc35db020af9a" translate="yes" xml:space="preserve">
          <source>Hermitian FFTs</source>
          <target state="translated">БПФ Гермициана</target>
        </trans-unit>
        <trans-unit id="d6600c2342a8053253425f9846737e2bf29ea82c" translate="yes" xml:space="preserve">
          <source>Hermitian or real symmetric matrices whose eigenvalues and eigenvectors are to be computed.</source>
          <target state="translated">Гермитовые или реальные симметричные матрицы,собственные значения и собственные векторы которых должны быть вычислены.</target>
        </trans-unit>
        <trans-unit id="2e330e11eac48710d52dc39e422ecae197585b4d" translate="yes" xml:space="preserve">
          <source>High-order polynomials may oscillate wildly:</source>
          <target state="translated">Полиномы высокого порядка могут дико колебаться:</target>
        </trans-unit>
        <trans-unit id="4be99f1c1557117aa5c64902eb10d5b0886a0d69" translate="yes" xml:space="preserve">
          <source>Higher dimensions</source>
          <target state="translated">Более высокие размеры</target>
        </trans-unit>
        <trans-unit id="1f9c9c4e9b69dcd6586dbf80815cf3c44f18d220" translate="yes" xml:space="preserve">
          <source>Highlights</source>
          <target state="translated">Highlights</target>
        </trans-unit>
        <trans-unit id="00b07925679220cb801f1a4855d71039bbcccecc" translate="yes" xml:space="preserve">
          <source>Hiroshi Haramoto, Makoto Matsumoto, Takuji Nishimura, Fran&amp;ccedil;ois Panneton, Pierre L&amp;rsquo;Ecuyer, &amp;ldquo;Efficient Jump Ahead for F2-Linear Random Number Generators&amp;rdquo;, INFORMS JOURNAL ON COMPUTING, Vol. 20, No. 3, Summer 2008, pp. 385-390.</source>
          <target state="translated">Хироши Харамото, Макото Мацумото, Такудзи Нисимура, Франсуа Паннетон, Пьер Л'Экуайер, &amp;laquo;Эффективный прыжок вперед для F2-линейных генераторов случайных чисел&amp;raquo;, INFORMS JOURNAL ON COMPUTING, Vol. 20, № 3, лето 2008 г., стр. 385-390.</target>
        </trans-unit>
        <trans-unit id="5fb511a742639c34c53d07c644e43f8a516d0a8b" translate="yes" xml:space="preserve">
          <source>Hiroshi Haramoto, Makoto Matsumoto, and Pierre L&amp;rsquo;Ecuyer, &amp;ldquo;A Fast Jump Ahead Algorithm for Linear Recurrences in a Polynomial Space&amp;rdquo;, Sequences and Their Applications - SETA, 290&amp;ndash;298, 2008.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f16459104f92ab6b38aa265adb4ecbfc3768e303" translate="yes" xml:space="preserve">
          <source>Histogram</source>
          <target state="translated">Histogram</target>
        </trans-unit>
        <trans-unit id="9f573dd516c5fae818d100652937d22c8be8a33c" translate="yes" xml:space="preserve">
          <source>Histograms</source>
          <target state="translated">Histograms</target>
        </trans-unit>
        <trans-unit id="4ae9938f95b0f1ddca2c84e6c590258bb6c7a2fc" translate="yes" xml:space="preserve">
          <source>Historically, NumPy has provided a special matrix type, &lt;code&gt;np.matrix&lt;/code&gt;, which is a subclass of ndarray which makes binary operations linear algebra operations. You may see it used in some existing code instead of &lt;code&gt;np.array&lt;/code&gt;. So, which one to use?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="08c95aa82b69eff297d0839c133733de00ba649c" translate="yes" xml:space="preserve">
          <source>Hit the &lt;code&gt;{Publish,Update} release&lt;/code&gt; button at the bottom.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34329cbed12573fba3127f8cc749498a60eadbb9" translate="yes" xml:space="preserve">
          <source>Hook in &lt;code&gt;numpy/__init__.py&lt;/code&gt; to run distribution-specific checks</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="02f07bc7a75153468adfa0658b0fd2c34d3ff7ae" translate="yes" xml:space="preserve">
          <source>Horner&amp;rsquo;s scheme &lt;a href=&quot;#r138ee7027ddf-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt; is used to evaluate the polynomial. Even so, for polynomials of high degree the values may be inaccurate due to rounding errors. Use carefully.</source>
          <target state="translated">Схема Горнера &lt;a href=&quot;#r138ee7027ddf-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt; используется для вычисления полинома. Даже в этом случае для многочленов высокой степени значения могут быть неточными из-за ошибок округления. Используйте осторожно.</target>
        </trans-unit>
        <trans-unit id="a0bb6d60bdafa1c8cd27af7d704ca6a159830aba" translate="yes" xml:space="preserve">
          <source>How Tos</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="37544ef44c5ec43acf39ee75fa75aed3630c67b7" translate="yes" xml:space="preserve">
          <source>How can we pass our custom array type through this function? Numpy allows a class to indicate that it would like to handle computations in a custom-defined way through the interfaces &lt;code&gt;__array_ufunc__&lt;/code&gt; and &lt;code&gt;__array_function__&lt;/code&gt;. Let&amp;rsquo;s take one at a time, starting with &lt;code&gt;_array_ufunc__&lt;/code&gt;. This method covers &lt;a href=&quot;../reference/ufuncs#ufuncs&quot;&gt;Universal functions (ufunc)&lt;/a&gt;, a class of functions that includes, for example, &lt;a href=&quot;../reference/generated/numpy.multiply#numpy.multiply&quot;&gt;&lt;code&gt;numpy.multiply&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../reference/generated/numpy.sin#numpy.sin&quot;&gt;&lt;code&gt;numpy.sin&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6fb47cd6d16a30a926efe82eaad98fb5865139f5" translate="yes" xml:space="preserve">
          <source>How do we construct a 2D array from a list of equally-sized row vectors? In MATLAB this is quite easy: if &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; are two vectors of the same length you only need do &lt;code&gt;m=[x;y]&lt;/code&gt;. In NumPy this works via the functions &lt;code&gt;column_stack&lt;/code&gt;, &lt;code&gt;dstack&lt;/code&gt;, &lt;code&gt;hstack&lt;/code&gt; and &lt;code&gt;vstack&lt;/code&gt;, depending on the dimension in which the stacking is to be done. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c6749c478409711ffa23534cffe66364ec264e6" translate="yes" xml:space="preserve">
          <source>How do we know when consensus has been achieved? In principle, this is rather difficult, since consensus is defined by the absence of vetos, which requires us to somehow prove a negative. In practice, we use a combination of our best judgement (e.g., a simple and uncontroversial bug fix posted on GitHub and reviewed by a core developer is probably fine) and best efforts (e.g., all substantive API changes must be posted to the mailing list in order to give the broader community a chance to catch any problems and suggest improvements; we assume that anyone who cares enough about NumPy to invoke their veto right should be on the mailing list). If no-one bothers to comment on the mailing list after a few days, then it&amp;rsquo;s probably fine. And worst case, if a change is more controversial than expected, or a crucial critique is delayed because someone was on vacation, then it&amp;rsquo;s no big deal: we apologize for misjudging the situation, &lt;a href=&quot;http://producingoss.com/en/producingoss.html#version-control-relaxation&quot;&gt;back up, and sort things out&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d2fbb3731558c54237c322aa799a621ca3c7d2a1" translate="yes" xml:space="preserve">
          <source>How do you know the shape and size of an array?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="45e254592757b5e545a9eb104e6529f78a4c37d7" translate="yes" xml:space="preserve">
          <source>How many bytes needed to jump from the end of a dimension back to its beginning. Note that &lt;code&gt;backstrides[k] == strides[k] *
dims_m1[k]&lt;/code&gt;, but it is stored here as an optimization.</source>
          <target state="translated">Сколько байтов нужно для перехода от конца измерения к его началу. Обратите внимание, что &lt;code&gt;backstrides[k] == strides[k] * dims_m1[k]&lt;/code&gt; , но он сохраняется здесь как оптимизация.</target>
        </trans-unit>
        <trans-unit id="50be7c0770c6ecdb4f48559d001a760ebacd49cf" translate="yes" xml:space="preserve">
          <source>How many trials succeeded after a single run?</source>
          <target state="translated">Сколько испытаний увенчалось успехом после одного прогона?</target>
        </trans-unit>
        <trans-unit id="b58aa8864964e56b91e5cf3a16abe6db4861d007" translate="yes" xml:space="preserve">
          <source>How numpy handles numerical exceptions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="769ef91e51259c0af4889f9e0ba44a7641bc888d" translate="yes" xml:space="preserve">
          <source>How the committee will respond to reports</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a9fac3d5f2ed22d26d8e65434409a64b568a19a" translate="yes" xml:space="preserve">
          <source>How to Prepare a Release</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f2421f501c3d9da50b64e18ac9aabab538f44d78" translate="yes" xml:space="preserve">
          <source>How to access the docstring for more information</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="acdb5801edd59835ce1589b37b87df7e5921dc32" translate="yes" xml:space="preserve">
          <source>How to check the ABI of BLAS/LAPACK libraries</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7aec4c512fe995b8565d4654ce7ac7f7406a4e3f" translate="yes" xml:space="preserve">
          <source>How to contribute to the NumPy documentation</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f9221bbb4c993e17b159a09a015a8cfb26163b6a" translate="yes" xml:space="preserve">
          <source>How to contribute to this documentation (user and API)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b16ba9588c01309cec829be39d4d7fa37da2d3d4" translate="yes" xml:space="preserve">
          <source>How to convert a 1D array into a 2D array (how to add a new axis to an array)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="767132203b56ed5a732938158524dc8930f4e863" translate="yes" xml:space="preserve">
          <source>How to create a basic array</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="484181d716d9291c06f7d7ef08909d7d6fab3e0a" translate="yes" xml:space="preserve">
          <source>How to create an array from existing data</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9cc4cf70f5442751464e426079ad36aeb36f19be" translate="yes" xml:space="preserve">
          <source>How to do common tasks with NumPy</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0cf433e8cb198db7bf7c955d6715ae5e9750b810" translate="yes" xml:space="preserve">
          <source>How to extend NumPy</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="666793dffdb7a87d947a14c2cbc94401669fb6a1" translate="yes" xml:space="preserve">
          <source>How to get unique items and counts</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="85f78c1b7c6c2daa9f22d71b7624a2bf3c525a6f" translate="yes" xml:space="preserve">
          <source>How to import NumPy</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f492f4c3e2bb0aa4c599fef867f4b321aedf559" translate="yes" xml:space="preserve">
          <source>How to read and write data using NumPy</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="25e26bd806025536efd64003099ee09d64aa0000" translate="yes" xml:space="preserve">
          <source>How to reverse an array</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a0ae6b713025a426e1208163ee26bcb0e742b0a" translate="yes" xml:space="preserve">
          <source>How to save and load NumPy objects</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="41cd522ba4633ce6d4277a1ec4fd27e9f6066b5f" translate="yes" xml:space="preserve">
          <source>How to treat dates that do not fall on a valid day. The default is &amp;lsquo;raise&amp;rsquo;.</source>
          <target state="translated">Как относиться к свиданиям, не приходящимся на действительный день. По умолчанию - &amp;laquo;рейз&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="32eab6d31082447f7e78feb7ff06453c5204497b" translate="yes" xml:space="preserve">
          <source>How to use an array iterator on a C-level is explained more fully in later sections. Typically, you do not need to concern yourself with the internal structure of the iterator object, and merely interact with it through the use of the macros &lt;a href=&quot;array#c.PyArray_ITER_NEXT&quot;&gt;&lt;code&gt;PyArray_ITER_NEXT&lt;/code&gt;&lt;/a&gt; (it), &lt;a href=&quot;array#c.PyArray_ITER_GOTO&quot;&gt;&lt;code&gt;PyArray_ITER_GOTO&lt;/code&gt;&lt;/a&gt; (it, dest), or &lt;a href=&quot;array#c.PyArray_ITER_GOTO1D&quot;&gt;&lt;code&gt;PyArray_ITER_GOTO1D&lt;/code&gt;&lt;/a&gt; (it, index). All of these macros require the argument &lt;em&gt;it&lt;/em&gt; to be a &lt;a href=&quot;#c.PyArrayIterObject&quot;&gt;&lt;code&gt;PyArrayIterObject *&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="031b673efec683dbe6f1648f1b6820d5445558f5" translate="yes" xml:space="preserve">
          <source>How to use an array iterator on a C-level is explained more fully in later sections. Typically, you do not need to concern yourself with the internal structure of the iterator object, and merely interact with it through the use of the macros &lt;a href=&quot;c-api.array#c.PyArray_ITER_NEXT&quot;&gt;&lt;code&gt;PyArray_ITER_NEXT&lt;/code&gt;&lt;/a&gt; (it), &lt;a href=&quot;c-api.array#c.PyArray_ITER_GOTO&quot;&gt;&lt;code&gt;PyArray_ITER_GOTO&lt;/code&gt;&lt;/a&gt; (it, dest), or &lt;a href=&quot;c-api.array#c.PyArray_ITER_GOTO1D&quot;&gt;&lt;code&gt;PyArray_ITER_GOTO1D&lt;/code&gt;&lt;/a&gt; (it, index). All of these macros require the argument &lt;em&gt;it&lt;/em&gt; to be a &lt;a href=&quot;#c.PyArrayIterObject&quot;&gt;&lt;code&gt;PyArrayIterObject *&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Как использовать итератор массива на уровне C более подробно объясняется в следующих разделах. Как правило, вам не нужно беспокоиться о внутренней структуре объекта итератора, а просто взаимодействовать с ним с помощью макросов &lt;a href=&quot;c-api.array#c.PyArray_ITER_NEXT&quot;&gt; &lt;code&gt;PyArray_ITER_NEXT&lt;/code&gt; &lt;/a&gt; (it), &lt;a href=&quot;c-api.array#c.PyArray_ITER_GOTO&quot;&gt; &lt;code&gt;PyArray_ITER_GOTO&lt;/code&gt; &lt;/a&gt; (it, dest) или &lt;a href=&quot;c-api.array#c.PyArray_ITER_GOTO1D&quot;&gt; &lt;code&gt;PyArray_ITER_GOTO1D&lt;/code&gt; &lt;/a&gt; (it, index). Все эти макросы требуют аргумент , &lt;em&gt;что&lt;/em&gt; , чтобы быть &lt;a href=&quot;#c.PyArrayIterObject&quot;&gt; &lt;code&gt;PyArrayIterObject *&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9bcd1bde0a6ac509c8c0a0f1ece3cf8687c68de6" translate="yes" xml:space="preserve">
          <source>How to write docstrings in the numpydoc format</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a2e4974ddfecbf0d517a464e620b926746339cbe" translate="yes" xml:space="preserve">
          <source>However, F2PY provides a hook to overcome this difficulty, namely, users can define their own &amp;lt;Fortran type&amp;gt; to &amp;lt;C type&amp;gt; maps. For example, if Fortran 90 code contains:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1fba89386b8ecb89961d14d41f66fbec5ccd1d21" translate="yes" xml:space="preserve">
          <source>However, array scalars are immutable, so none of the array scalar attributes are settable.</source>
          <target state="translated">Однако скаляры массивов являются неизменными,поэтому ни один из атрибутов скаляра массива не может быть установлен.</target>
        </trans-unit>
        <trans-unit id="1e80ea7cc9443be2dc987f1f00e1482c24f952ab" translate="yes" xml:space="preserve">
          <source>However, for a 2D array, &lt;code&gt;tolist&lt;/code&gt; applies recursively:</source>
          <target state="translated">Однако для 2D-массива &lt;code&gt;tolist&lt;/code&gt; применяется рекурсивно:</target>
        </trans-unit>
        <trans-unit id="015eddccae9844f7be37e7464bfea1ad89cd5089" translate="yes" xml:space="preserve">
          <source>However, if editing Fortran codes is acceptable, then the generation of an intermediate signature file can be skipped in most cases. Namely, F2PY specific attributes can be inserted directly to Fortran source codes using the so-called F2PY directive. A F2PY directive defines special comment lines (starting with &lt;code&gt;Cf2py&lt;/code&gt;, for example) which are ignored by Fortran compilers but F2PY interprets them as normal lines.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b575af53d48fbf01519f17fa75457eb6160cea6e" translate="yes" xml:space="preserve">
          <source>However, if one wants to perform an operation on each element in the array, one can use the &lt;code&gt;flat&lt;/code&gt; attribute which is an &lt;a href=&quot;https://docs.python.org/tutorial/classes.html#iterators&quot;&gt;iterator&lt;/a&gt; over all the elements of the array:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="538a59374ec076485a1ecbe77f4b8f8bcaeb6930" translate="yes" xml:space="preserve">
          <source>However, if the step length is a &lt;strong&gt;complex number&lt;/strong&gt; (e.g. 5j), then the integer part of its magnitude is interpreted as specifying the number of points to create between the start and stop values, where the stop value &lt;strong&gt;is inclusive&lt;/strong&gt;.</source>
          <target state="translated">Однако, если длина шага является &lt;strong&gt;комплексным числом&lt;/strong&gt; (например, 5j), то целая часть его величины интерпретируется как указание количества точек, которые необходимо создать между начальным и конечным значениями, где конечное значение &lt;strong&gt;включено&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="c7b350918e2c3c187f55b17296e6170af94589d5" translate="yes" xml:space="preserve">
          <source>However, it also provides a filter mechanism to work around &lt;a href=&quot;https://bugs.python.org/issue4180&quot;&gt;https://bugs.python.org/issue4180&lt;/a&gt;.</source>
          <target state="translated">Однако он также предоставляет механизм фильтрации для обхода &lt;a href=&quot;https://bugs.python.org/issue4180&quot;&gt;https://bugs.python.org/issue4180&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8a0d3e8aabdd09f6d1c5b5cc067196fd48077165" translate="yes" xml:space="preserve">
          <source>However, on Windows accessing an attribute of the &lt;code&gt;cdll&lt;/code&gt; method will load the first DLL by that name found in the current directory or on the PATH. Loading the absolute path name requires a little finesse for cross-platform work since the extension of shared libraries varies. There is a &lt;code&gt;ctypes.util.find_library&lt;/code&gt; utility available that can simplify the process of finding the library to load but it is not foolproof. Complicating matters, different platforms have different default extensions used by shared libraries (e.g. .dll &amp;ndash; Windows, .so &amp;ndash; Linux, .dylib &amp;ndash; Mac OS X). This must also be taken into account if you are using ctypes to wrap code that needs to work on several platforms.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="72730352a2b8f129f65e5ce4d2975cad73414281" translate="yes" xml:space="preserve">
          <source>However, since the indexing arrays above just repeat themselves, broadcasting can be used (compare operations such as &lt;code&gt;rows[:, np.newaxis] + columns&lt;/code&gt;) to simplify this:</source>
          <target state="translated">Однако, поскольку индексирующие массивы выше просто повторяются, можно использовать широковещательную &lt;code&gt;rows[:, np.newaxis] + columns&lt;/code&gt; (операции сравнения, такие как строки [:, np.newaxis] + columns ), чтобы упростить это:</target>
        </trans-unit>
        <trans-unit id="5598df37564d4f9b7b446978966b782318a91f69" translate="yes" xml:space="preserve">
          <source>However, the Council&amp;rsquo;s primary responsibility is to facilitate the ordinary community-based decision making procedure described above. If we ever have to step in and formally override the community for the health of the Project, then we will do so, but we will consider reaching this point to indicate a failure in our leadership.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="148e0e3942c54a4e1382c28056e669f5ec70ca70" translate="yes" xml:space="preserve">
          <source>However, the recommended way to get changes made by Fortran subroutine back to Python is to use &lt;code&gt;intent(out)&lt;/code&gt; attribute. It is more efficient and a cleaner solution.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="076196cf7f29cbacc06332dc3a19baa5b6deb43a" translate="yes" xml:space="preserve">
          <source>However, there are ways (see below) how to &amp;ldquo;teach&amp;rdquo; F2PY about the true intentions (among other things) of function arguments; and then F2PY is able to generate more Pythonic (more explicit, easier to use, and less error prone) wrappers to Fortran functions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="517b2fc5c448904cbaf5099f9fa2e17572271c41" translate="yes" xml:space="preserve">
          <source>However, this class is not run directly. Rather, it serves as a base class to several other python classes, each one specific to a particular data type. The &lt;code&gt;VectorTestCase&lt;/code&gt; class stores two strings for typing information:</source>
          <target state="translated">Однако этот класс не запускается напрямую. Скорее, он служит базовым классом для нескольких других классов Python, каждый из которых относится к определенному типу данных. Класс &lt;code&gt;VectorTestCase&lt;/code&gt; хранит две строки для ввода информации:</target>
        </trans-unit>
        <trans-unit id="2a6f4657816e90073e4efa70d32c1dabe823c21d" translate="yes" xml:space="preserve">
          <source>However, we can not do this by putting &lt;code&gt;i&lt;/code&gt; and &lt;code&gt;j&lt;/code&gt; into an array, because this array will be interpreted as indexing the first dimension of a.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d0b3b9f48e63d95c45789879b62e0b7dfb5a4009" translate="yes" xml:space="preserve">
          <source>However, when the list of indices contains repetitions, the assignment is done several times, leaving behind the last value:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="baf7f433a664b8146a9906ca7ff1abe3cab252ff" translate="yes" xml:space="preserve">
          <source>Hyperbolic cosine, element-wise.</source>
          <target state="translated">Гиперболический косинус,по элементам.</target>
        </trans-unit>
        <trans-unit id="f3ed3aadb3c9adb061d870e136cd1453348e8c73" translate="yes" xml:space="preserve">
          <source>Hyperbolic functions</source>
          <target state="translated">гиперболические функции</target>
        </trans-unit>
        <trans-unit id="b87cce3c91c3e9d2649c00af3ce0c941c00a9a8f" translate="yes" xml:space="preserve">
          <source>Hyperbolic sine, element-wise.</source>
          <target state="translated">Гиперболический синус,по элементам.</target>
        </trans-unit>
        <trans-unit id="ca73ab65568cd125c2d27a22bbd9e863c10b675d" translate="yes" xml:space="preserve">
          <source>I</source>
          <target state="translated">I</target>
        </trans-unit>
        <trans-unit id="32232530b1100268522739a98df9e054ce98ef4f" translate="yes" xml:space="preserve">
          <source>I() (numpy.matrix property)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c586011e018241bf43412c51ec75d78e1897bbe7" translate="yes" xml:space="preserve">
          <source>I. N. Bronshtein, K. A. Semendyayev, and K. A. Hirsch (Eng. trans. Ed.), &lt;em&gt;Handbook of Mathematics&lt;/em&gt;, New York, Van Nostrand Reinhold Co., 1985, pg. 720.</source>
          <target state="translated">Бронштейн И.Н., Семендяев К.А., Хирш К.А. (англ. Пер. Ред.), &lt;em&gt;Справочник по математике&lt;/em&gt; , Нью-Йорк, Van Nostrand Reinhold Co., 1985, стр. 720.</target>
        </trans-unit>
        <trans-unit id="447fb9923a27f15d934b8afdf5c0a4f010eb6dd4" translate="yes" xml:space="preserve">
          <source>I/O with NumPy</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="afc08020472b5f8bfb4430d0521200fb31b0b681" translate="yes" xml:space="preserve">
          <source>IEEE 754 Floating Point Special Values</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ee225f319b80c76b05dae881594a3894bf4661e" translate="yes" xml:space="preserve">
          <source>IEEE 754 floating point representation of (positive) infinity.</source>
          <target state="translated">IEEE 754 представление с плавающей точкой (положительной)бесконечности.</target>
        </trans-unit>
        <trans-unit id="ff3e6480ff45af971d6b3762d77291c710637eb0" translate="yes" xml:space="preserve">
          <source>IEEE 754 floating point representation of Not a Number (NaN).</source>
          <target state="translated">IEEE 754 представление с плавающей точкой не числа (NaN).</target>
        </trans-unit>
        <trans-unit id="824566ddb199752efcc7660bd7d421e1b2678da4" translate="yes" xml:space="preserve">
          <source>IEEE 754 floating point representation of negative infinity.</source>
          <target state="translated">IEEE 754 представление с плавающей точкой отрицательной бесконечности.</target>
        </trans-unit>
        <trans-unit id="2e340e10314a130edadd8cad9f96f416538b858d" translate="yes" xml:space="preserve">
          <source>IEEE 754 floating point representation of negative zero.</source>
          <target state="translated">IEEE 754 представление с плавающей точкой отрицательного нуля.</target>
        </trans-unit>
        <trans-unit id="b287f77a659c8b69b20168ee840f1a54628cc862" translate="yes" xml:space="preserve">
          <source>IEEE 754 floating point representation of positive zero.</source>
          <target state="translated">IEEE 754 представление с плавающей точкой положительного нуля.</target>
        </trans-unit>
        <trans-unit id="72cabc0c250f4a292eec84ba99be92816a937afe" translate="yes" xml:space="preserve">
          <source>INSTALL.rst.txt</source>
          <target state="translated">INSTALL.rst.txt</target>
        </trans-unit>
        <trans-unit id="ab585ec9c005c8ff11ee6135d8e5382d325fbd66" translate="yes" xml:space="preserve">
          <source>IO compatibility with large files</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e274113d3320e2ddaa1955ecaa00f8ecd732ab0e" translate="yes" xml:space="preserve">
          <source>IO performance improvements</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="401e5d8be22ba7ec21a65d4ac42f63626cf30eac" translate="yes" xml:space="preserve">
          <source>ISO/IEC standard 9899:1999, &amp;ldquo;Programming language C.&amp;rdquo;</source>
          <target state="translated">Стандарт ISO / IEC 9899: 1999, &amp;laquo;Язык программирования C.&amp;raquo;</target>
        </trans-unit>
        <trans-unit id="a192903ac36265b2268a1b63fb4343f1bc34ccf1" translate="yes" xml:space="preserve">
          <source>ISeedSequence.generate_state()</source>
          <target state="translated">ISeedSequence.generate_state()</target>
        </trans-unit>
        <trans-unit id="7817ae1e33233084a2765c4156676391d76c8dd8" translate="yes" xml:space="preserve">
          <source>ISpawnableSeedSequence.generate_state()</source>
          <target state="translated">ISpawnableSeedSequence.generate_state()</target>
        </trans-unit>
        <trans-unit id="266493f5f6f829a5601662541a1f5723f1a321cc" translate="yes" xml:space="preserve">
          <source>ISpawnableSeedSequence.spawn()</source>
          <target state="translated">ISpawnableSeedSequence.spawn()</target>
        </trans-unit>
        <trans-unit id="08673d1ddebe80d6502dff08e88d404531dbe20b" translate="yes" xml:space="preserve">
          <source>Identifies the benchmarks to run. This can be a string to pass to the nosetests executable with the &amp;lsquo;-A&amp;rsquo; option, or one of several special values. Special values are:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2938dea7757a31542d1346c3f1074719ce51ad4d" translate="yes" xml:space="preserve">
          <source>Identifies the tests to run. This can be a string to pass to the nosetests executable with the &amp;lsquo;-A&amp;rsquo; option, or one of several special values. Special values are:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="84791116b8cc2df6bbeaf0d85f3bf0937f9761c0" translate="yes" xml:space="preserve">
          <source>Identify the commit hash of the release, e.g. 1b2e1d63ff.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="111e795804fa7bde03948ba63ec2cb3f6f402b39" translate="yes" xml:space="preserve">
          <source>Identity function.</source>
          <target state="translated">Функция идентификации.</target>
        </trans-unit>
        <trans-unit id="ef2cb61738111c3044b6a344dba03012a1f3066b" translate="yes" xml:space="preserve">
          <source>If &amp;lsquo;inner&amp;rsquo;, returns the elements common to both r1 and r2. If &amp;lsquo;outer&amp;rsquo;, returns the common elements as well as the elements of r1 not in r2 and the elements of not in r2. If &amp;lsquo;leftouter&amp;rsquo;, returns the common elements and the elements of r1 not in r2.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c9a8c69d524e3737d8a52d7c063a710ab1820ab4" translate="yes" xml:space="preserve">
          <source>If &amp;lsquo;left&amp;rsquo;, the index of the first suitable location found is given. If &amp;lsquo;right&amp;rsquo;, return the last such index. If there is no suitable index, return either 0 or N (where N is the length of &lt;code&gt;a&lt;/code&gt;).</source>
          <target state="translated">Если &amp;laquo;влево&amp;raquo;, дается индекс первого найденного подходящего местоположения. Если &amp;laquo;правильно&amp;raquo;, вернуть последний такой индекс. Если подходящего индекса нет, верните либо 0, либо N (где N - длина &lt;code&gt;a&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="0b2ac55fdba7a6077870f65fb651eb209decd3f7" translate="yes" xml:space="preserve">
          <source>If &amp;lsquo;out&amp;rsquo; is None (the default), a uninitialized return array is created. The output array is then filled with the results of the ufunc in the places that the broadcast &amp;lsquo;where&amp;rsquo; is True. If &amp;lsquo;where&amp;rsquo; is the scalar True (the default), then this corresponds to the entire output being filled. Note that outputs not explicitly filled are left with their uninitialized values.</source>
          <target state="translated">Если out - None (по умолчанию), создается неинициализированный возвращаемый массив. Затем выходной массив заполняется результатами ufunc в тех местах, где широковещательная передача where имеет значение True. Если &amp;laquo;где&amp;raquo; является скалярным значением True (по умолчанию), то это соответствует заполнению всего вывода. Обратите внимание, что для выходов, не заполненных явно, остаются неинициализированные значения.</target>
        </trans-unit>
        <trans-unit id="b221bc8f0d9f3564598fa735c4c298856c0dd2e9" translate="yes" xml:space="preserve">
          <source>If -1/NULL values are passed to &lt;code&gt;oa_ndim&lt;/code&gt;, &lt;code&gt;op_axes&lt;/code&gt;, &lt;code&gt;itershape&lt;/code&gt;, and &lt;code&gt;buffersize&lt;/code&gt;, it is equivalent to &lt;a href=&quot;#c.NpyIter_MultiNew&quot;&gt;&lt;code&gt;NpyIter_MultiNew&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Если значения -1 / NULL передаются в &lt;code&gt;oa_ndim&lt;/code&gt; , &lt;code&gt;op_axes&lt;/code&gt; , &lt;code&gt;itershape&lt;/code&gt; и &lt;code&gt;buffersize&lt;/code&gt; , это эквивалентно &lt;a href=&quot;#c.NpyIter_MultiNew&quot;&gt; &lt;code&gt;NpyIter_MultiNew&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="07ab4829841dadccaa2d85de36af5f3925367c25" translate="yes" xml:space="preserve">
          <source>If 64-bit integers are still too small the result may be cast to a floating point number. Floating point numbers offer a larger, but inexact, range of possible values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="79d46b4b066a6ba67bd08b99b0faa98132c0c54b" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;#c.NO_IMPORT_ARRAY&quot;&gt;&lt;code&gt;NO_IMPORT_ARRAY&lt;/code&gt;&lt;/a&gt; is #defined, regardless of whether &lt;a href=&quot;#c.PY_ARRAY_UNIQUE_SYMBOL&quot;&gt;&lt;code&gt;PY_ARRAY_UNIQUE_SYMBOL&lt;/code&gt;&lt;/a&gt; is, the C-API is declared to be &lt;code&gt;extern void**&lt;/code&gt;, so it is expected to be defined in another compilation unit.</source>
          <target state="translated">Если &lt;a href=&quot;#c.NO_IMPORT_ARRAY&quot;&gt; &lt;code&gt;NO_IMPORT_ARRAY&lt;/code&gt; &lt;/a&gt; имеет значение #defined, независимо от того, является ли значение &lt;a href=&quot;#c.PY_ARRAY_UNIQUE_SYMBOL&quot;&gt; &lt;code&gt;PY_ARRAY_UNIQUE_SYMBOL&lt;/code&gt; &lt;/a&gt; , C-API объявляется как &lt;code&gt;extern void**&lt;/code&gt; , поэтому ожидается, что он будет определен в другом модуле компиляции.</target>
        </trans-unit>
        <trans-unit id="f636b5861ee4fae57e7d457d50fef770ecd7b810" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;#c.NpyIter_RemoveMultiIndex&quot;&gt;&lt;code&gt;NpyIter_RemoveMultiIndex&lt;/code&gt;&lt;/a&gt; was called, you may want to enable the flag &lt;a href=&quot;#c.NPY_ITER_EXTERNAL_LOOP&quot;&gt;&lt;code&gt;NPY_ITER_EXTERNAL_LOOP&lt;/code&gt;&lt;/a&gt;. This flag is not permitted together with &lt;a href=&quot;#c.NPY_ITER_MULTI_INDEX&quot;&gt;&lt;code&gt;NPY_ITER_MULTI_INDEX&lt;/code&gt;&lt;/a&gt;, so this function is provided to enable the feature after &lt;a href=&quot;#c.NpyIter_RemoveMultiIndex&quot;&gt;&lt;code&gt;NpyIter_RemoveMultiIndex&lt;/code&gt;&lt;/a&gt; is called. This function also resets the iterator to its initial state.</source>
          <target state="translated">Если был вызван &lt;a href=&quot;#c.NpyIter_RemoveMultiIndex&quot;&gt; &lt;code&gt;NpyIter_RemoveMultiIndex&lt;/code&gt; &lt;/a&gt; , вы можете включить флаг &lt;a href=&quot;#c.NPY_ITER_EXTERNAL_LOOP&quot;&gt; &lt;code&gt;NPY_ITER_EXTERNAL_LOOP&lt;/code&gt; &lt;/a&gt; . Этот флаг не разрешен вместе с &lt;a href=&quot;#c.NPY_ITER_MULTI_INDEX&quot;&gt; &lt;code&gt;NPY_ITER_MULTI_INDEX&lt;/code&gt; &lt;/a&gt; , поэтому эта функция предоставляется для включения функции после &lt;a href=&quot;#c.NpyIter_RemoveMultiIndex&quot;&gt; &lt;code&gt;NpyIter_RemoveMultiIndex&lt;/code&gt; &lt;/a&gt; . Эта функция также сбрасывает итератор в исходное состояние.</target>
        </trans-unit>
        <trans-unit id="1cac2a31adf2200c294f5c075bb6c153e55fa5a2" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;#c.PY_ARRAY_UNIQUE_SYMBOL&quot;&gt;&lt;code&gt;PY_ARRAY_UNIQUE_SYMBOL&lt;/code&gt;&lt;/a&gt; is #defined, but &lt;a href=&quot;#c.NO_IMPORT_ARRAY&quot;&gt;&lt;code&gt;NO_IMPORT_ARRAY&lt;/code&gt;&lt;/a&gt; is not, the C-API is declared to be &lt;code&gt;void**&lt;/code&gt;, so that it will also be visible to other compilation units.</source>
          <target state="translated">Если &lt;a href=&quot;#c.PY_ARRAY_UNIQUE_SYMBOL&quot;&gt; &lt;code&gt;PY_ARRAY_UNIQUE_SYMBOL&lt;/code&gt; &lt;/a&gt; имеет значение #defined, а &lt;a href=&quot;#c.NO_IMPORT_ARRAY&quot;&gt; &lt;code&gt;NO_IMPORT_ARRAY&lt;/code&gt; &lt;/a&gt; - нет, C-API объявляется &lt;code&gt;void**&lt;/code&gt; , поэтому он также будет виден другим модулям компиляции.</target>
        </trans-unit>
        <trans-unit id="f0fe9dfd78027e91a1bff4d801d8eb87a4610a71" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray.fill_value&quot;&gt;&lt;code&gt;fill_value&lt;/code&gt;&lt;/a&gt; is not specified, but &lt;a href=&quot;numpy.ma.maskedarray.dtype#numpy.ma.MaskedArray.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt; is specified (and is not an ndarray sub-class), the &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray.fill_value&quot;&gt;&lt;code&gt;fill_value&lt;/code&gt;&lt;/a&gt; of the MaskedArray will be reset. If neither &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray.fill_value&quot;&gt;&lt;code&gt;fill_value&lt;/code&gt;&lt;/a&gt; nor &lt;a href=&quot;numpy.ma.maskedarray.dtype#numpy.ma.MaskedArray.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt; are specified (or if &lt;a href=&quot;numpy.ma.maskedarray.dtype#numpy.ma.MaskedArray.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt; is an ndarray sub-class), then the fill value is preserved. Finally, if &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray.fill_value&quot;&gt;&lt;code&gt;fill_value&lt;/code&gt;&lt;/a&gt; is specified, but &lt;a href=&quot;numpy.ma.maskedarray.dtype#numpy.ma.MaskedArray.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt; is not, the fill value is set to the specified value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b6b83b00b9ce96c4a5e91132daa4d55535f9e96d" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt; is set, array is copied only if dtype does not match:</source>
          <target state="translated">Если установлен &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt; , массив копируется, только если dtype не совпадает:</target>
        </trans-unit>
        <trans-unit id="4fc8bcfc9864193d76a4195dd238fe6624ed9a71" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;numpy.indices#numpy.indices&quot;&gt;&lt;code&gt;indices&lt;/code&gt;&lt;/a&gt; is not one dimensional, the output also has these dimensions.</source>
          <target state="translated">Если &lt;a href=&quot;numpy.indices#numpy.indices&quot;&gt; &lt;code&gt;indices&lt;/code&gt; &lt;/a&gt; не одномерные, выходные данные также имеют эти измерения.</target>
        </trans-unit>
        <trans-unit id="6ede9f1a1e5701156394dbca76c84f8a340a9cea" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;numpy.ma.masked_array.fill_value#numpy.ma.masked_array.fill_value&quot;&gt;&lt;code&gt;fill_value&lt;/code&gt;&lt;/a&gt; is not specified, but &lt;a href=&quot;numpy.ma.masked_array.dtype#numpy.ma.masked_array.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt; is specified (and is not an ndarray sub-class), the &lt;a href=&quot;numpy.ma.masked_array.fill_value#numpy.ma.masked_array.fill_value&quot;&gt;&lt;code&gt;fill_value&lt;/code&gt;&lt;/a&gt; of the MaskedArray will be reset. If neither &lt;a href=&quot;numpy.ma.masked_array.fill_value#numpy.ma.masked_array.fill_value&quot;&gt;&lt;code&gt;fill_value&lt;/code&gt;&lt;/a&gt; nor &lt;a href=&quot;numpy.ma.masked_array.dtype#numpy.ma.masked_array.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt; are specified (or if &lt;a href=&quot;numpy.ma.masked_array.dtype#numpy.ma.masked_array.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt; is an ndarray sub-class), then the fill value is preserved. Finally, if &lt;a href=&quot;numpy.ma.masked_array.fill_value#numpy.ma.masked_array.fill_value&quot;&gt;&lt;code&gt;fill_value&lt;/code&gt;&lt;/a&gt; is specified, but &lt;a href=&quot;numpy.ma.masked_array.dtype#numpy.ma.masked_array.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt; is not, the fill value is set to the specified value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d5ce8d43810f8659a3ffbe656fd3c96f0228399" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;numpy.matrix.data#numpy.matrix.data&quot;&gt;&lt;code&gt;data&lt;/code&gt;&lt;/a&gt; is a string, it is interpreted as a matrix with commas or spaces separating columns, and semicolons separating rows.</source>
          <target state="translated">Если &lt;a href=&quot;numpy.matrix.data#numpy.matrix.data&quot;&gt; &lt;code&gt;data&lt;/code&gt; &lt;/a&gt; являются строкой, они интерпретируются как матрица с запятыми или пробелами, разделяющими столбцы, и точками с запятой, разделяющими строки.</target>
        </trans-unit>
        <trans-unit id="006799ea3355b83be37fd21ad89f661aac343125" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;numpy.matrix.data#numpy.matrix.data&quot;&gt;&lt;code&gt;data&lt;/code&gt;&lt;/a&gt; is already an &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt;, then this flag determines whether the data is copied (the default), or whether a view is constructed.</source>
          <target state="translated">Если &lt;a href=&quot;numpy.matrix.data#numpy.matrix.data&quot;&gt; &lt;code&gt;data&lt;/code&gt; &lt;/a&gt; уже являются &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt; , то этот флаг определяет, копируются ли данные (по умолчанию) или создается представление.</target>
        </trans-unit>
        <trans-unit id="f12c5c9464a76ef6881e238c0f45cc6cb56cab96" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&amp;lt;filename.pyf&amp;gt;&lt;/code&gt; is specified as &lt;code&gt;stdout&lt;/code&gt; then signatures are send to standard output instead of a file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="22e7424cfa201c4ec783e98a6da198e97606627a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&amp;lt;fortran files&amp;gt;&lt;/code&gt; contains a signature file, then a source for an extension module is constructed, all Fortran and C sources are compiled, and finally all object and library files are linked to the extension module &lt;code&gt;&amp;lt;modulename&amp;gt;.so&lt;/code&gt; which is saved into the current directory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="207fbf09fcd7223478aec74725e5d0380117e758" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&amp;lt;fortran files&amp;gt;&lt;/code&gt; does not contain a signature file, then an extension module is constructed by scanning all Fortran source codes for routine signatures.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b197e7232928483bec23ab77c22b02eb5eeb910" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;A.ndim &amp;gt; d&lt;/code&gt;, &lt;code&gt;reps&lt;/code&gt; is promoted to &lt;code&gt;A&lt;/code&gt;.ndim by pre-pending 1&amp;rsquo;s to it. Thus for an &lt;code&gt;A&lt;/code&gt; of shape (2, 3, 4, 5), a &lt;code&gt;reps&lt;/code&gt; of (2, 2) is treated as (1, 1, 2, 2).</source>
          <target state="translated">Если &lt;code&gt;A.ndim &amp;gt; d&lt;/code&gt; , &lt;code&gt;reps&lt;/code&gt; повышается до &lt;code&gt;A&lt;/code&gt; .ndim путем предварительной установки 1. Таким образом, для &lt;code&gt;A&lt;/code&gt; формы (2, 3, 4, 5) &lt;code&gt;reps&lt;/code&gt; (2, 2) рассматриваются как (1, 1, 2, 2).</target>
        </trans-unit>
        <trans-unit id="dbe88f61ce8f631b9b28c692a7753b41fb5fe9e4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;A.ndim &amp;lt; d&lt;/code&gt;, &lt;code&gt;A&lt;/code&gt; is promoted to be d-dimensional by prepending new axes. So a shape (3,) array is promoted to (1, 3) for 2-D replication, or shape (1, 1, 3) for 3-D replication. If this is not the desired behavior, promote &lt;code&gt;A&lt;/code&gt; to d-dimensions manually before calling this function.</source>
          <target state="translated">Если &lt;code&gt;A.ndim &amp;lt; d&lt;/code&gt; , &lt;code&gt;A&lt;/code&gt; становится d-мерным путем добавления новых осей. Таким образом, массив shape (3,) повышается до (1, 3) для 2-D репликации или shape (1, 1, 3) для 3-D репликации. Если это нежелательное поведение, перед вызовом этой функции продвиньте &lt;code&gt;A&lt;/code&gt; до размеров d вручную.</target>
        </trans-unit>
        <trans-unit id="7f85c71b217560bd561bde5602b4923ab34868ad" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;False&lt;/code&gt;, the result will contain the number of samples in each bin. If &lt;code&gt;True&lt;/code&gt;, the result is the value of the probability &lt;em&gt;density&lt;/em&gt; function at the bin, normalized such that the &lt;em&gt;integral&lt;/em&gt; over the range is 1. Note that the sum of the histogram values will not be equal to 1 unless bins of unity width are chosen; it is not a probability &lt;em&gt;mass&lt;/em&gt; function.</source>
          <target state="translated">Если &lt;code&gt;False&lt;/code&gt; , результат будет содержать количество образцов в каждой ячейке. Если &lt;code&gt;True&lt;/code&gt; , результатом будет значение функции &lt;em&gt;плотности&lt;/em&gt; вероятности в интервале , нормализованное таким образом, что &lt;em&gt;интеграл&lt;/em&gt; по диапазону равен 1. Обратите внимание, что сумма значений гистограммы не будет равна 1, если не выбраны интервалы с единичной шириной; это не функция &lt;em&gt;массы&lt;/em&gt; вероятности .</target>
        </trans-unit>
        <trans-unit id="ca7cba1e4456723daee790d09bd9b4e007a0b7f8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;None&lt;/code&gt; (default), all constants are assumed to be zero. If &lt;code&gt;m = 1&lt;/code&gt;, a single scalar can be given instead of a list.</source>
          <target state="translated">Если &lt;code&gt;None&lt;/code&gt; (по умолчанию), предполагается, что все константы равны нулю. Если &lt;code&gt;m = 1&lt;/code&gt; , вместо списка можно указать один скаляр.</target>
        </trans-unit>
        <trans-unit id="aec21489ec4d901f1aa321dc3743c87fb290d768" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;True&lt;/code&gt;, swap bytes in-place, default is &lt;code&gt;False&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;True&lt;/code&gt; , поменять байты местами, по умолчанию - &lt;code&gt;False&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f2e3fbb074311bdb46e2b67afbf7fb14e162de56" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;True&lt;/code&gt;, the cutoff of &lt;code&gt;precision&lt;/code&gt; digits refers to the total number of digits after the decimal point, including leading zeros. If &lt;code&gt;False&lt;/code&gt;, &lt;code&gt;precision&lt;/code&gt; refers to the total number of significant digits, before or after the decimal point, ignoring leading zeros.</source>
          <target state="translated">Если &lt;code&gt;True&lt;/code&gt; , отсечка цифр &lt;code&gt;precision&lt;/code&gt; относится к общему количеству цифр после десятичной точки, включая ведущие нули. Если &lt;code&gt;False&lt;/code&gt; , &lt;code&gt;precision&lt;/code&gt; относится к общему количеству значащих цифр до или после десятичной точки, игнорируя ведущие нули.</target>
        </trans-unit>
        <trans-unit id="a29f76a184d9fb35f364bb63d222c84be040ac5b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;True&lt;/code&gt;, then cache the first function call that determines the number of outputs if &lt;code&gt;otypes&lt;/code&gt; is not provided.</source>
          <target state="translated">Если &lt;code&gt;True&lt;/code&gt; , то &lt;code&gt;otypes&lt;/code&gt; первый вызов функции, который определяет количество выходов, если otypes не предоставлено.</target>
        </trans-unit>
        <trans-unit id="7faac3985b746b05ac26d42bd00cce4fcc2669d4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;True&lt;/code&gt;, use a digit-generation strategy which gives the shortest representation which uniquely identifies the floating-point number from other values of the same type, by judicious rounding. If &lt;code&gt;precision&lt;/code&gt; was omitted, print all necessary digits, otherwise digit generation is cut off after &lt;code&gt;precision&lt;/code&gt; digits and the remaining value is rounded. If &lt;code&gt;False&lt;/code&gt;, digits are generated as if printing an infinite-precision value and stopping after &lt;code&gt;precision&lt;/code&gt; digits, rounding the remaining value.</source>
          <target state="translated">Если &lt;code&gt;True&lt;/code&gt; , используйте стратегию генерации цифр, которая дает кратчайшее представление, которое однозначно идентифицирует число с плавающей запятой от других значений того же типа путем разумного округления. Если &lt;code&gt;precision&lt;/code&gt; была опущена, выведите все необходимые цифры, в противном случае генерация цифр обрезается после цифр &lt;code&gt;precision&lt;/code&gt; а оставшееся значение округляется. Если &lt;code&gt;False&lt;/code&gt; , цифры генерируются так, как будто печатаются значения бесконечной точности и останавливаются после цифр &lt;code&gt;precision&lt;/code&gt; , округляя оставшееся значение.</target>
        </trans-unit>
        <trans-unit id="d46a903cfc558730b35e63368d27aca2360607f1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;True&lt;/code&gt;, use a digit-generation strategy which gives the shortest representation which uniquely identifies the floating-point number from other values of the same type, by judicious rounding. If &lt;code&gt;precision&lt;/code&gt; was omitted, print out all necessary digits, otherwise digit generation is cut off after &lt;code&gt;precision&lt;/code&gt; digits and the remaining value is rounded. If &lt;code&gt;False&lt;/code&gt;, digits are generated as if printing an infinite-precision value and stopping after &lt;code&gt;precision&lt;/code&gt; digits, rounding the remaining value.</source>
          <target state="translated">Если &lt;code&gt;True&lt;/code&gt; , используйте стратегию генерации цифр, которая дает кратчайшее представление, которое однозначно идентифицирует число с плавающей запятой от других значений того же типа путем разумного округления. Если &lt;code&gt;precision&lt;/code&gt; была опущена, распечатайте все необходимые цифры, в противном случае генерация цифр обрезается после цифр &lt;code&gt;precision&lt;/code&gt; а оставшееся значение округляется. Если &lt;code&gt;False&lt;/code&gt; , цифры генерируются так, как будто печатаются значения бесконечной точности и останавливаются после цифр &lt;code&gt;precision&lt;/code&gt; , округляя оставшееся значение.</target>
        </trans-unit>
        <trans-unit id="e630a68b772e53281799a75b2daa484538be6573" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;V = chebvander2d(x, y, [xdeg, ydeg])&lt;/code&gt;, then the columns of &lt;code&gt;V&lt;/code&gt; correspond to the elements of a 2-D coefficient array &lt;code&gt;c&lt;/code&gt; of shape (xdeg + 1, ydeg + 1) in the order</source>
          <target state="translated">Если &lt;code&gt;V = chebvander2d(x, y, [xdeg, ydeg])&lt;/code&gt; , то столбцы &lt;code&gt;V&lt;/code&gt; соответствуют элементам двумерного массива коэффициентов &lt;code&gt;c&lt;/code&gt; формы (xdeg + 1, ydeg + 1) в порядке</target>
        </trans-unit>
        <trans-unit id="8cbfd70f5cc4a9c80c1b3f4ac628ba80decf75d4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;V = chebvander3d(x, y, z, [xdeg, ydeg, zdeg])&lt;/code&gt;, then the columns of &lt;code&gt;V&lt;/code&gt; correspond to the elements of a 3-D coefficient array &lt;code&gt;c&lt;/code&gt; of shape (xdeg + 1, ydeg + 1, zdeg + 1) in the order</source>
          <target state="translated">Если &lt;code&gt;V = chebvander3d(x, y, z, [xdeg, ydeg, zdeg])&lt;/code&gt; , то столбцы &lt;code&gt;V&lt;/code&gt; соответствуют элементам массива трехмерных коэффициентов &lt;code&gt;c&lt;/code&gt; формы (xdeg + 1, ydeg + 1, zdeg + 1) в порядке</target>
        </trans-unit>
        <trans-unit id="00bfc10fc177e8c4f7b6b34693c411592fe272c6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;V = hermevander2d(x, y, [xdeg, ydeg])&lt;/code&gt;, then the columns of &lt;code&gt;V&lt;/code&gt; correspond to the elements of a 2-D coefficient array &lt;code&gt;c&lt;/code&gt; of shape (xdeg + 1, ydeg + 1) in the order</source>
          <target state="translated">Если &lt;code&gt;V = hermevander2d(x, y, [xdeg, ydeg])&lt;/code&gt; , то столбцы &lt;code&gt;V&lt;/code&gt; соответствуют элементам двумерного массива коэффициентов &lt;code&gt;c&lt;/code&gt; формы (xdeg + 1, ydeg + 1) в порядке</target>
        </trans-unit>
        <trans-unit id="a7c811e070f694575d65f49ba72909eaec417a6f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;V = hermevander3d(x, y, z, [xdeg, ydeg, zdeg])&lt;/code&gt;, then the columns of &lt;code&gt;V&lt;/code&gt; correspond to the elements of a 3-D coefficient array &lt;code&gt;c&lt;/code&gt; of shape (xdeg + 1, ydeg + 1, zdeg + 1) in the order</source>
          <target state="translated">Если &lt;code&gt;V = hermevander3d(x, y, z, [xdeg, ydeg, zdeg])&lt;/code&gt; , то столбцы &lt;code&gt;V&lt;/code&gt; соответствуют элементам массива трехмерных коэффициентов &lt;code&gt;c&lt;/code&gt; формы (xdeg + 1, ydeg + 1, zdeg + 1) в порядке</target>
        </trans-unit>
        <trans-unit id="262fc8f05dc54d641c4705041f46d8b6c771c1fb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;V = hermvander2d(x, y, [xdeg, ydeg])&lt;/code&gt;, then the columns of &lt;code&gt;V&lt;/code&gt; correspond to the elements of a 2-D coefficient array &lt;code&gt;c&lt;/code&gt; of shape (xdeg + 1, ydeg + 1) in the order</source>
          <target state="translated">Если &lt;code&gt;V = hermvander2d(x, y, [xdeg, ydeg])&lt;/code&gt; , то столбцы &lt;code&gt;V&lt;/code&gt; соответствуют элементам двумерного массива коэффициентов &lt;code&gt;c&lt;/code&gt; формы (xdeg + 1, ydeg + 1) в порядке</target>
        </trans-unit>
        <trans-unit id="066ad3b1f4c835bc91d8b4d1ca954772c0457a46" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;V = hermvander3d(x, y, z, [xdeg, ydeg, zdeg])&lt;/code&gt;, then the columns of &lt;code&gt;V&lt;/code&gt; correspond to the elements of a 3-D coefficient array &lt;code&gt;c&lt;/code&gt; of shape (xdeg + 1, ydeg + 1, zdeg + 1) in the order</source>
          <target state="translated">Если &lt;code&gt;V = hermvander3d(x, y, z, [xdeg, ydeg, zdeg])&lt;/code&gt; , то столбцы &lt;code&gt;V&lt;/code&gt; соответствуют элементам массива &lt;code&gt;c&lt;/code&gt; трехмерных коэффициентов формы (xdeg + 1, ydeg + 1, zdeg + 1) в порядке</target>
        </trans-unit>
        <trans-unit id="6596fc02b05eb1b57c388bcee28f45c0fa647e79" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;V = lagvander2d(x, y, [xdeg, ydeg])&lt;/code&gt;, then the columns of &lt;code&gt;V&lt;/code&gt; correspond to the elements of a 2-D coefficient array &lt;code&gt;c&lt;/code&gt; of shape (xdeg + 1, ydeg + 1) in the order</source>
          <target state="translated">Если &lt;code&gt;V = lagvander2d(x, y, [xdeg, ydeg])&lt;/code&gt; , то столбцы &lt;code&gt;V&lt;/code&gt; соответствуют элементам двумерного массива коэффициентов &lt;code&gt;c&lt;/code&gt; формы (xdeg + 1, ydeg + 1) в порядке</target>
        </trans-unit>
        <trans-unit id="658f3ceb580a0341f1c8e14be933e5829c9b95b9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;V = lagvander3d(x, y, z, [xdeg, ydeg, zdeg])&lt;/code&gt;, then the columns of &lt;code&gt;V&lt;/code&gt; correspond to the elements of a 3-D coefficient array &lt;code&gt;c&lt;/code&gt; of shape (xdeg + 1, ydeg + 1, zdeg + 1) in the order</source>
          <target state="translated">Если &lt;code&gt;V = lagvander3d(x, y, z, [xdeg, ydeg, zdeg])&lt;/code&gt; , то столбцы &lt;code&gt;V&lt;/code&gt; соответствуют элементам массива трехмерных коэффициентов &lt;code&gt;c&lt;/code&gt; формы (xdeg + 1, ydeg + 1, zdeg + 1) в порядке</target>
        </trans-unit>
        <trans-unit id="102bddd53317314797d80d0b03e0de44ee8eec62" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;V = legvander2d(x, y, [xdeg, ydeg])&lt;/code&gt;, then the columns of &lt;code&gt;V&lt;/code&gt; correspond to the elements of a 2-D coefficient array &lt;code&gt;c&lt;/code&gt; of shape (xdeg + 1, ydeg + 1) in the order</source>
          <target state="translated">Если &lt;code&gt;V = legvander2d(x, y, [xdeg, ydeg])&lt;/code&gt; , то столбцы &lt;code&gt;V&lt;/code&gt; соответствуют элементам двумерного массива коэффициентов &lt;code&gt;c&lt;/code&gt; формы (xdeg + 1, ydeg + 1) в порядке</target>
        </trans-unit>
        <trans-unit id="f9e4383801f2b61b08f9300b1b7fdf17e1c3f488" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;V = legvander3d(x, y, z, [xdeg, ydeg, zdeg])&lt;/code&gt;, then the columns of &lt;code&gt;V&lt;/code&gt; correspond to the elements of a 3-D coefficient array &lt;code&gt;c&lt;/code&gt; of shape (xdeg + 1, ydeg + 1, zdeg + 1) in the order</source>
          <target state="translated">Если &lt;code&gt;V = legvander3d(x, y, z, [xdeg, ydeg, zdeg])&lt;/code&gt; , то столбцы &lt;code&gt;V&lt;/code&gt; соответствуют элементам массива трехмерных коэффициентов &lt;code&gt;c&lt;/code&gt; формы (xdeg + 1, ydeg + 1, zdeg + 1) в порядке</target>
        </trans-unit>
        <trans-unit id="c691cf5dd3bcc26326919122a716b1456743d83e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;V = polyvander2d(x, y, [xdeg, ydeg])&lt;/code&gt;, then the columns of &lt;code&gt;V&lt;/code&gt; correspond to the elements of a 2-D coefficient array &lt;code&gt;c&lt;/code&gt; of shape (xdeg + 1, ydeg + 1) in the order</source>
          <target state="translated">Если &lt;code&gt;V = polyvander2d(x, y, [xdeg, ydeg])&lt;/code&gt; , то столбцы &lt;code&gt;V&lt;/code&gt; соответствуют элементам двумерного массива коэффициентов &lt;code&gt;c&lt;/code&gt; формы (xdeg + 1, ydeg + 1) в порядке</target>
        </trans-unit>
        <trans-unit id="3795a0fc387856e1a4fb9463ff23e8e2dc033c86" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;V = polyvander3d(x, y, z, [xdeg, ydeg, zdeg])&lt;/code&gt;, then the columns of &lt;code&gt;V&lt;/code&gt; correspond to the elements of a 3-D coefficient array &lt;code&gt;c&lt;/code&gt; of shape (xdeg + 1, ydeg + 1, zdeg + 1) in the order</source>
          <target state="translated">Если &lt;code&gt;V = polyvander3d(x, y, z, [xdeg, ydeg, zdeg])&lt;/code&gt; , то столбцы &lt;code&gt;V&lt;/code&gt; соответствуют элементам массива трехмерных коэффициентов &lt;code&gt;c&lt;/code&gt; формы (xdeg + 1, ydeg + 1, zdeg + 1) в порядке</target>
        </trans-unit>
        <trans-unit id="f8959bef2f1f180cd1904ca3003b3eeaecf0bbcb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a.fill_value == b.fill_value&lt;/code&gt;, return the fill value, otherwise return None.</source>
          <target state="translated">Если &lt;code&gt;a.fill_value == b.fill_value&lt;/code&gt; , вернуть значение заполнения, иначе вернуть None.</target>
        </trans-unit>
        <trans-unit id="8f6e1a60280ed3603677c79dbcdebfa7ff398c42" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a.ndim &amp;gt; 2&lt;/code&gt;, then the dimensions specified by &lt;code&gt;axis1&lt;/code&gt; and &lt;code&gt;axis2&lt;/code&gt; are removed, and a new axis inserted at the end corresponding to the diagonal.</source>
          <target state="translated">Если &lt;code&gt;a.ndim &amp;gt; 2&lt;/code&gt; , то размеры, указанные в параметрах &lt;code&gt;axis1&lt;/code&gt; и &lt;code&gt;axis2&lt;/code&gt; , удаляются, и новая ось вставляется в конце, соответствующем диагонали.</target>
        </trans-unit>
        <trans-unit id="64c4131bb0fe8a413fc2bc1ebe219f3e36ea1e9b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a.ndim&lt;/code&gt; is 0, then since the depth of the nested list is 0, it will not be a list at all, but a simple Python scalar.</source>
          <target state="translated">Если &lt;code&gt;a.ndim&lt;/code&gt; равно 0, то, поскольку глубина вложенного списка равна 0, это будет вовсе не список, а простой скаляр Python.</target>
        </trans-unit>
        <trans-unit id="355d7bac3059f5072f60fecea5ae0b7d9ef0b74d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a.shape&lt;/code&gt; is (5,1), &lt;code&gt;b.shape&lt;/code&gt; is (1,6), &lt;code&gt;c.shape&lt;/code&gt; is (6,) and &lt;code&gt;d.shape&lt;/code&gt; is () so that &lt;em&gt;d&lt;/em&gt; is a scalar, then &lt;em&gt;a&lt;/em&gt;, &lt;em&gt;b&lt;/em&gt;, &lt;em&gt;c&lt;/em&gt;, and &lt;em&gt;d&lt;/em&gt; are all broadcastable to dimension (5,6); and</source>
          <target state="translated">Если &lt;code&gt;a.shape&lt;/code&gt; равно (5,1), &lt;code&gt;b.shape&lt;/code&gt; равно (1,6), &lt;code&gt;c.shape&lt;/code&gt; равно (6,) и &lt;code&gt;d.shape&lt;/code&gt; равно (), так что &lt;em&gt;d&lt;/em&gt; является скаляром, то &lt;em&gt;a&lt;/em&gt; , &lt;em&gt;b&lt;/em&gt; , &lt;em&gt;c&lt;/em&gt; , и &lt;em&gt;d&lt;/em&gt; все транслируются в размер (5,6); и</target>
        </trans-unit>
        <trans-unit id="61914428b3107b079ee31cfc27e080d8a722c6a3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; are nonscalar, their last dimensions must match.</source>
          <target state="translated">Если &lt;code&gt;a&lt;/code&gt; и &lt;code&gt;b&lt;/code&gt; нескалярные, их последние измерения должны совпадать.</target>
        </trans-unit>
        <trans-unit id="b4f4e526a35a19438379df1f3dbff9a3882d194d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a&lt;/code&gt; and each choice array are not all broadcastable to the same shape.</source>
          <target state="translated">Если &lt;code&gt;a&lt;/code&gt; и каждый массив выбора не все транслируются в одну и ту же форму.</target>
        </trans-unit>
        <trans-unit id="6714bc3434562dda36e8035d926f1d408c7a5936" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a&lt;/code&gt; does not own its own data or references or views to it exist, and the data memory must be changed. PyPy only: will always raise if the data memory must be changed, since there is no reliable way to determine if references or views to it exist.</source>
          <target state="translated">Если &lt;code&gt;a&lt;/code&gt; не владеет своими собственными данными, либо существуют ссылки или представления на него, необходимо изменить память данных. Только PyPy: всегда будет увеличиваться, если необходимо изменить память данных, поскольку нет надежного способа определить, существуют ли ссылки или представления на нее.</target>
        </trans-unit>
        <trans-unit id="d46ad13c1a8181bf81ec49d29f19d0a4e8222929" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a&lt;/code&gt; has more than two dimensions, then broadcasting rules apply, as explained in &lt;a href=&quot;../routines.linalg#routines-linalg-broadcasting&quot;&gt;Linear algebra on several matrices at once&lt;/a&gt;. This means that SVD is working in &amp;ldquo;stacked&amp;rdquo; mode: it iterates over all indices of the first &lt;code&gt;a.ndim - 2&lt;/code&gt; dimensions and for each combination SVD is applied to the last two indices. The matrix &lt;code&gt;a&lt;/code&gt; can be reconstructed from the decomposition with either &lt;code&gt;(u * s[..., None, :]) @ vh&lt;/code&gt; or &lt;code&gt;u @ (s[..., None] * vh)&lt;/code&gt;. (The &lt;code&gt;@&lt;/code&gt; operator can be replaced by the function &lt;code&gt;np.matmul&lt;/code&gt; for python versions below 3.5.)</source>
          <target state="translated">Если &lt;code&gt;a&lt;/code&gt; имеет более двух измерений, тогда применяются правила широковещательной передачи, как описано в &lt;a href=&quot;../routines.linalg#routines-linalg-broadcasting&quot;&gt;Линейной алгебре, для нескольких матриц одновременно&lt;/a&gt; . Это означает, что SVD работает в &amp;laquo;сложенном&amp;raquo; режиме: он выполняет итерацию по всем индексам первого &lt;code&gt;a.ndim - 2&lt;/code&gt; и для каждой комбинации SVD применяется к последним двум индексам. Матрица &lt;code&gt;a&lt;/code&gt; может быть восстановлена ​​из разложения с помощью &lt;code&gt;(u * s[..., None, :]) @ vh&lt;/code&gt; или &lt;code&gt;u @ (s[..., None] * vh)&lt;/code&gt; . (Оператор &lt;code&gt;@&lt;/code&gt; может быть заменен функцией &lt;code&gt;np.matmul&lt;/code&gt; для версий Python ниже 3.5.)</target>
        </trans-unit>
        <trans-unit id="0f5e97c2878caebdac54716045091816869ce6d1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a&lt;/code&gt; has more than two dimensions, then the axes specified by axis1 and axis2 are used to determine the 2-D sub-arrays whose traces are returned. The shape of the resulting array is the same as that of &lt;code&gt;a&lt;/code&gt; with &lt;code&gt;axis1&lt;/code&gt; and &lt;code&gt;axis2&lt;/code&gt; removed.</source>
          <target state="translated">Если &lt;code&gt;a&lt;/code&gt; имеет более двух измерений, то оси, указанные в параметрах axis1 и axis2, используются для определения двумерных подмассивов, трассы которых возвращаются. Форма результирующего массива одно и то же, что и с &lt;code&gt;axis1&lt;/code&gt; и &lt;code&gt;axis2&lt;/code&gt; удалены. &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1b46ead587370435670ac4bc03b81d9c95e42b33" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a&lt;/code&gt; is 1-D, the function &lt;code&gt;ufunc.accumulate(a)&lt;/code&gt; is the same as &lt;code&gt;ufunc.reduceat(a, indices)[::2]&lt;/code&gt; where &lt;a href=&quot;numpy.indices#numpy.indices&quot;&gt;&lt;code&gt;indices&lt;/code&gt;&lt;/a&gt; is &lt;code&gt;range(len(array) - 1)&lt;/code&gt; with a zero placed in every other element: &lt;code&gt;indices = zeros(2 * len(a) - 1)&lt;/code&gt;, &lt;code&gt;indices[1::2] = range(1, len(a))&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;a&lt;/code&gt; 1-D, функция &lt;code&gt;ufunc.accumulate(a)&lt;/code&gt; совпадает с &lt;code&gt;ufunc.reduceat(a, indices)[::2]&lt;/code&gt; где &lt;a href=&quot;numpy.indices#numpy.indices&quot;&gt; &lt;code&gt;indices&lt;/code&gt; &lt;/a&gt; - это &lt;code&gt;range(len(array) - 1)&lt;/code&gt; с нулем, помещенным в каждый другой элемент: &lt;code&gt;indices = zeros(2 * len(a) - 1)&lt;/code&gt; , &lt;code&gt;indices[1::2] = range(1, len(a))&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7b8db921b8261a5150c028a4a52e2a78422e254b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a&lt;/code&gt; is 2-D, returns the diagonal of &lt;code&gt;a&lt;/code&gt; with the given offset, i.e., the collection of elements of the form &lt;code&gt;a[i, i+offset]&lt;/code&gt;. If &lt;code&gt;a&lt;/code&gt; has more than two dimensions, then the axes specified by &lt;code&gt;axis1&lt;/code&gt; and &lt;code&gt;axis2&lt;/code&gt; are used to determine the 2-D sub-array whose diagonal is returned. The shape of the resulting array can be determined by removing &lt;code&gt;axis1&lt;/code&gt; and &lt;code&gt;axis2&lt;/code&gt; and appending an index to the right equal to the size of the resulting diagonals.</source>
          <target state="translated">Если &lt;code&gt;a&lt;/code&gt; 2-D, возвращает диагональ &lt;code&gt;a&lt;/code&gt; с заданным смещением, т. Е. Набор элементов формы &lt;code&gt;a[i, i+offset]&lt;/code&gt; . Если &lt;code&gt;a&lt;/code&gt; имеет более двух измерений, то оси, указанные в параметрах &lt;code&gt;axis1&lt;/code&gt; и &lt;code&gt;axis2&lt;/code&gt; , используются для определения двумерного подмассива , диагональ которого возвращается. Форму полученного массива можно определить, удалив &lt;code&gt;axis1&lt;/code&gt; и &lt;code&gt;axis2&lt;/code&gt; и добавив справа индекс, равный размеру полученных диагоналей.</target>
        </trans-unit>
        <trans-unit id="016f6a15e05ea7909f939f7c56abdd96bd940bcc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a&lt;/code&gt; is 2-D, the sum along its diagonal with the given offset is returned, i.e., the sum of elements &lt;code&gt;a[i,i+offset]&lt;/code&gt; for all i.</source>
          <target state="translated">Если &lt;code&gt;a&lt;/code&gt; 2-D, возвращается сумма по его диагонали с заданным смещением, то есть сумма элементов &lt;code&gt;a[i,i+offset]&lt;/code&gt; для всех i.</target>
        </trans-unit>
        <trans-unit id="821330dbafd930ef241f18ef291a677b001e3d1c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a&lt;/code&gt; is 2-D, the sum along the diagonal is returned. If &lt;code&gt;a&lt;/code&gt; has larger dimensions, then an array of sums along diagonals is returned.</source>
          <target state="translated">Если &lt;code&gt;a&lt;/code&gt; 2-D, возвращается сумма по диагонали. Если имеет большие размеры, то массив сумм вдоль диагоналей возвращается. &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="20e0991e165d15052f7414c1d9067709a6741ba8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a&lt;/code&gt; is 2-D, then a 1-D array containing the diagonal and of the same type as &lt;code&gt;a&lt;/code&gt; is returned unless &lt;code&gt;a&lt;/code&gt; is a &lt;a href=&quot;numpy.matrix#numpy.matrix&quot;&gt;&lt;code&gt;matrix&lt;/code&gt;&lt;/a&gt;, in which case a 1-D array rather than a (2-D) &lt;a href=&quot;numpy.matrix#numpy.matrix&quot;&gt;&lt;code&gt;matrix&lt;/code&gt;&lt;/a&gt; is returned in order to maintain backward compatibility.</source>
          <target state="translated">Если 2-Д, а затем 1-D массив А , содержащий диагонали и того же типа , как возвращается , если не является &lt;a href=&quot;numpy.matrix#numpy.matrix&quot;&gt; &lt;code&gt;matrix&lt;/code&gt; &lt;/a&gt; , в этом случае 1-D массив , а не (2-D) , &lt;a href=&quot;numpy.matrix#numpy.matrix&quot;&gt; &lt;code&gt;matrix&lt;/code&gt; &lt;/a&gt; возвращается для сохранения обратной совместимости. &lt;code&gt;a&lt;/code&gt; &lt;code&gt;a&lt;/code&gt; &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="65772464bb82fc9b6e011b51f1c71a9673e3a5fb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a&lt;/code&gt; is a &lt;code&gt;matrix&lt;/code&gt; object (as opposed to an &lt;code&gt;ndarray&lt;/code&gt;), then so are all the return values.</source>
          <target state="translated">Если &lt;code&gt;a&lt;/code&gt; является &lt;code&gt;matrix&lt;/code&gt; объектом (в отличие от &lt;code&gt;ndarray&lt;/code&gt; ), то все возвращаемые значения также.</target>
        </trans-unit>
        <trans-unit id="cea4b92a7534a3149383f752281c310050f705b1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a&lt;/code&gt; is a reference to &lt;code&gt;b&lt;/code&gt;, then &lt;code&gt;(a is b) == True&lt;/code&gt;. Therefore, &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; are different names for the same Python object.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="edeed84f3c81e9ebf31ecd438474825302f801e2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a&lt;/code&gt; is a subclass of &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray&quot;&gt;&lt;code&gt;MaskedArray&lt;/code&gt;&lt;/a&gt;, its class is conserved. No copy is performed if the input is already an &lt;code&gt;ndarray&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;a&lt;/code&gt; является подклассом &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray&quot;&gt; &lt;code&gt;MaskedArray&lt;/code&gt; &lt;/a&gt; , его класс сохраняется. Копирование не выполняется, если ввод уже является &lt;code&gt;ndarray&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="79b3d97ca6a58beeb5178bade7556181ec643eb5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a&lt;/code&gt; is an N-D array and &lt;code&gt;b&lt;/code&gt; is a 1-D array, it is a sum product over the last axis of &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;a&lt;/code&gt; является массивом ND, а &lt;code&gt;b&lt;/code&gt; - одномерным массивом, это произведение суммы по последней оси &lt;code&gt;a&lt;/code&gt; и &lt;code&gt;b&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="41bd115d2530c0df6f893d58055a4e7bbeb51a86" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a&lt;/code&gt; is an N-D array and &lt;code&gt;b&lt;/code&gt; is an M-D array (where &lt;code&gt;M&amp;gt;=2&lt;/code&gt;), it is a sum product over the last axis of &lt;code&gt;a&lt;/code&gt; and the second-to-last axis of &lt;code&gt;b&lt;/code&gt;:</source>
          <target state="translated">Если &lt;code&gt;a&lt;/code&gt; - массив ND, а &lt;code&gt;b&lt;/code&gt; - массив MD (где &lt;code&gt;M&amp;gt;=2&lt;/code&gt; ), это сумма произведения по последней оси &lt;code&gt;a&lt;/code&gt; и предпоследней оси &lt;code&gt;b&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="e2d3d6c358f256f08097a63c0a16dbce473bc638" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a&lt;/code&gt; is complex the complex conjugate is taken before calculation of the dot product.</source>
          <target state="translated">Если &lt;code&gt;a&lt;/code&gt; является комплексным, комплексное сопряжение берется перед вычислением скалярного произведения.</target>
        </trans-unit>
        <trans-unit id="eccde6fba477d4d0328834eeb9139f4c209a7f8b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a&lt;/code&gt; is not a &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray&quot;&gt;&lt;code&gt;MaskedArray&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;a&lt;/code&gt; itself is returned. If &lt;code&gt;a&lt;/code&gt; is a &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray&quot;&gt;&lt;code&gt;MaskedArray&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;fill_value&lt;/code&gt; is None, &lt;code&gt;fill_value&lt;/code&gt; is set to &lt;code&gt;a.fill_value&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;a&lt;/code&gt; не является &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray&quot;&gt; &lt;code&gt;MaskedArray&lt;/code&gt; &lt;/a&gt; , возвращается сам &lt;code&gt;a&lt;/code&gt; . Если &lt;code&gt;a&lt;/code&gt; - &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray&quot;&gt; &lt;code&gt;MaskedArray&lt;/code&gt; ,&lt;/a&gt; а &lt;code&gt;fill_value&lt;/code&gt; - None, &lt;code&gt;fill_value&lt;/code&gt; устанавливается в &lt;code&gt;a.fill_value&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7ac306a4eb2b5b20798f61a7b119dddd329017ce" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a&lt;/code&gt; is not square or inversion fails.</source>
          <target state="translated">Если &lt;code&gt;a&lt;/code&gt; не квадрат или инверсия не выполняется.</target>
        </trans-unit>
        <trans-unit id="dc36615c1be692990452f6adc2c02bec7979d9d1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a&lt;/code&gt; is real, the type of &lt;code&gt;a&lt;/code&gt; is used for the output. If &lt;code&gt;a&lt;/code&gt; has complex elements, the returned type is float.</source>
          <target state="translated">Если &lt;code&gt;a&lt;/code&gt; действительно, для вывода используется тип &lt;code&gt;a&lt;/code&gt; . Если у &lt;code&gt;a&lt;/code&gt; есть сложные элементы, возвращаемый тип - float.</target>
        </trans-unit>
        <trans-unit id="49742c1cee8e9efafb1c7fbbe431a8e95469bbc0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a&lt;/code&gt; is singular or not &amp;lsquo;square&amp;rsquo; (in the above sense).</source>
          <target state="translated">Если &lt;code&gt;a&lt;/code&gt; - единственное число или не &amp;laquo;квадрат&amp;raquo; (в указанном выше смысле).</target>
        </trans-unit>
        <trans-unit id="2e9b74892f6f35d0326c1dc235300557d874f5a4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a&lt;/code&gt; is singular or not square.</source>
          <target state="translated">Если &lt;code&gt;a&lt;/code&gt; - единичный или не квадратный.</target>
        </trans-unit>
        <trans-unit id="ceece9b2545779310cb6355ec10529e551268898" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;align=False&lt;/code&gt;, this method produces a &amp;ldquo;packed&amp;rdquo; memory layout in which each field starts at the byte the previous field ended, and any padding bytes are removed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="460932656f30d1ee879c1ced09e2eca3e1ff623d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;align=True&lt;/code&gt; is set, numpy will pad the structure in the same way many C compilers would pad a C-struct. Aligned structures can give a performance improvement in some cases, at the cost of increased datatype size. Padding bytes are inserted between fields such that each field&amp;rsquo;s byte offset will be a multiple of that field&amp;rsquo;s alignment, which is usually equal to the field&amp;rsquo;s size in bytes for simple datatypes, see &lt;a href=&quot;../reference/c-api/types-and-structures#c.PyArray_Descr.alignment&quot;&gt;&lt;code&gt;PyArray_Descr.alignment&lt;/code&gt;&lt;/a&gt;. The structure will also have trailing padding added so that its itemsize is a multiple of the largest field&amp;rsquo;s alignment.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b8c190caa583967ef3d50f42e6abb370b98e8c8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;align=True&lt;/code&gt;, this methods produces an &amp;ldquo;aligned&amp;rdquo; memory layout in which each field&amp;rsquo;s offset is a multiple of its alignment, and the total itemsize is a multiple of the largest alignment, by adding padding bytes as needed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="18f554f1ca3b0160e94e964322795aa916ef0365" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;arr&lt;/code&gt; doesn&amp;rsquo;t have a shape attribute (i.e. not an ndarray)</source>
          <target state="translated">Если &lt;code&gt;arr&lt;/code&gt; не имеет атрибута shape (т.е. не ndarray)</target>
        </trans-unit>
        <trans-unit id="6f94c014869b41cb6e3e090bab6cec3fc3652e46" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;axes&lt;/code&gt; is larger than the last axis of &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;axes&lt;/code&gt; больше, чем последняя ось &lt;code&gt;a&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fb5967cac1f9c838f629289b9701f4f5d967c63e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;axis&lt;/code&gt; is 0, only rows are masked.</source>
          <target state="translated">Если &lt;code&gt;axis&lt;/code&gt; 0, маскируются только строки.</target>
        </trans-unit>
        <trans-unit id="e77d1c339b65acf6a89a949d1d50328c8561be33" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;axis&lt;/code&gt; is 1 or -1, only columns are masked.</source>
          <target state="translated">Если &lt;code&gt;axis&lt;/code&gt; 1 или -1, маскируются только столбцы.</target>
        </trans-unit>
        <trans-unit id="527dba2aee917b7e820a9015382f439872829fc2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;axis&lt;/code&gt; is None, rows &lt;em&gt;and&lt;/em&gt; columns are masked.</source>
          <target state="translated">Если &lt;code&gt;axis&lt;/code&gt; None, строки &lt;em&gt;и&lt;/em&gt; столбцы маскируются.</target>
        </trans-unit>
        <trans-unit id="1c5e761c4a44d3d8422fc68aeed03dd9853a0a7f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;axis&lt;/code&gt; is None, the result is a scalar. Otherwise, if &lt;code&gt;axis&lt;/code&gt; is given and the array is at least 2-D, the result is a masked array with dimension one smaller than the array on which &lt;a href=&quot;#numpy.ma.masked_array.mini&quot;&gt;&lt;code&gt;mini&lt;/code&gt;&lt;/a&gt; is called.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="042bc001a4914cd7d0d232c6f0fb346989909740" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;axis&lt;/code&gt; is an integer, it specifies the axis of &lt;code&gt;x&lt;/code&gt; along which to compute the vector norms. If &lt;code&gt;axis&lt;/code&gt; is a 2-tuple, it specifies the axes that hold 2-D matrices, and the matrix norms of these matrices are computed. If &lt;code&gt;axis&lt;/code&gt; is None then either a vector norm (when &lt;code&gt;x&lt;/code&gt; is 1-D) or a matrix norm (when &lt;code&gt;x&lt;/code&gt; is 2-D) is returned.</source>
          <target state="translated">Если &lt;code&gt;axis&lt;/code&gt; является целым числом, она указывает ось &lt;code&gt;x&lt;/code&gt; , по которой вычисляются векторные нормы. Если &lt;code&gt;axis&lt;/code&gt; является двумерным кортежем, она определяет оси, которые содержат двумерные матрицы, и вычисляются матричные нормы этих матриц. Если &lt;code&gt;axis&lt;/code&gt; None, то возвращается либо векторная норма (когда &lt;code&gt;x&lt;/code&gt; равно 1-D), либо матричная норма (когда &lt;code&gt;x&lt;/code&gt; равно 2-D).</target>
        </trans-unit>
        <trans-unit id="bfadfc7eb4a4188168e39022bbb71c1c25d02efa" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;axis&lt;/code&gt; is an integer, it specifies the axis of &lt;code&gt;x&lt;/code&gt; along which to compute the vector norms. If &lt;code&gt;axis&lt;/code&gt; is a 2-tuple, it specifies the axes that hold 2-D matrices, and the matrix norms of these matrices are computed. If &lt;code&gt;axis&lt;/code&gt; is None then either a vector norm (when &lt;code&gt;x&lt;/code&gt; is 1-D) or a matrix norm (when &lt;code&gt;x&lt;/code&gt; is 2-D) is returned. The default is None.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="523d86ecb59b40a9d925f2a1e78fa6cb76926a2b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;axis&lt;/code&gt; is given, the number of varargs must equal the number of axes. Default: 1.</source>
          <target state="translated">Если указана &lt;code&gt;axis&lt;/code&gt; , количество переменных должно равняться количеству осей. По умолчанию: 1.</target>
        </trans-unit>
        <trans-unit id="86e33ec8c24f94e2430b0659a5ab81a91a91d564" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;axis&lt;/code&gt; is larger than the last axis of &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;axis&lt;/code&gt; больше последней оси &lt;code&gt;a&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b10999639108c4b4999de59d1e8da7d5676f431c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;axis&lt;/code&gt; is not &lt;code&gt;None&lt;/code&gt;, and an axis being squeezed is not of length 1</source>
          <target state="translated">Если &lt;code&gt;axis&lt;/code&gt; не равна &lt;code&gt;None&lt;/code&gt; , а длина сжимаемой оси не равна 1</target>
        </trans-unit>
        <trans-unit id="048ac1275e643db0f79c87e34405c76349afe0b6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;axis&lt;/code&gt; is not None, and an axis being squeezed is not of length 1</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="62e5f5a4f466db64bba565371ecaf3c0accbb2cc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;b = a[:100]&lt;/code&gt; is used instead, &lt;code&gt;a&lt;/code&gt; is referenced by &lt;code&gt;b&lt;/code&gt; and will persist in memory even if &lt;code&gt;del a&lt;/code&gt; is executed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b1ba1d797cf86b71e14a5b8da31b21199908a909" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;b&lt;/code&gt; is a matrix, then all array results are returned as matrices.</source>
          <target state="translated">Если &lt;code&gt;b&lt;/code&gt; является матрицей, то все результаты массива возвращаются как матрицы.</target>
        </trans-unit>
        <trans-unit id="ca0b482dcb07a6085a21a5bc1b0dde224b2f172c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;bins&lt;/code&gt; is a string from the list below, &lt;a href=&quot;#numpy.histogram_bin_edges&quot;&gt;&lt;code&gt;histogram_bin_edges&lt;/code&gt;&lt;/a&gt; will use the method chosen to calculate the optimal bin width and consequently the number of bins (see &lt;code&gt;Notes&lt;/code&gt; for more detail on the estimators) from the data that falls within the requested range. While the bin width will be optimal for the actual data in the range, the number of bins will be computed to fill the entire range, including the empty portions. For visualisation, using the &amp;lsquo;auto&amp;rsquo; option is suggested. Weighted data is not supported for automated bin size selection.</source>
          <target state="translated">Если &lt;code&gt;bins&lt;/code&gt; - это строка из списка ниже, &lt;a href=&quot;#numpy.histogram_bin_edges&quot;&gt; &lt;code&gt;histogram_bin_edges&lt;/code&gt; &lt;/a&gt; будет использовать метод, выбранный для вычисления оптимальной ширины ячейки и, следовательно, количества ячеек (см. &lt;code&gt;Notes&lt;/code&gt; для получения более подробной информации об оценках) из данных, которые попадают в запрошенный диапазон. Хотя ширина бункера будет оптимальной для фактических данных в диапазоне, количество бинов будет вычислено для заполнения всего диапазона, включая пустые части. Для визуализации предлагается использовать опцию &amp;laquo;авто&amp;raquo;. Взвешенные данные не поддерживаются для автоматического выбора размера корзины.</target>
        </trans-unit>
        <trans-unit id="b70a91ff0eb4c89d18a81d985f393eb13ac7933f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;bins&lt;/code&gt; is a string, it defines the method used to calculate the optimal bin width, as defined by &lt;a href=&quot;numpy.histogram_bin_edges#numpy.histogram_bin_edges&quot;&gt;&lt;code&gt;histogram_bin_edges&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Если &lt;code&gt;bins&lt;/code&gt; является строкой, она определяет метод, используемый для вычисления оптимальной ширины ячейки, как определено в &lt;a href=&quot;numpy.histogram_bin_edges#numpy.histogram_bin_edges&quot;&gt; &lt;code&gt;histogram_bin_edges&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="cbffbf31546ec9af5b6fd778dfc3e0a7e49fc75c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;bins&lt;/code&gt; is an int, it defines the number of equal-width bins in the given range (10, by default). If &lt;code&gt;bins&lt;/code&gt; is a sequence, it defines a monotonically increasing array of bin edges, including the rightmost edge, allowing for non-uniform bin widths.</source>
          <target state="translated">Если &lt;code&gt;bins&lt;/code&gt; имеет тип int, он определяет количество интервалов одинаковой ширины в заданном диапазоне (по умолчанию 10). Если &lt;code&gt;bins&lt;/code&gt; представляют собой последовательность, она определяет монотонно увеличивающийся массив краев бункеров , включая крайний правый край, что позволяет использовать неоднородную ширину бинов.</target>
        </trans-unit>
        <trans-unit id="b4024bb04b779936a7803a2173c03bd8c96f6ec1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;bins&lt;/code&gt; is an int, it defines the number of equal-width bins in the given range (10, by default). If &lt;code&gt;bins&lt;/code&gt; is a sequence, it defines the bin edges, including the rightmost edge, allowing for non-uniform bin widths.</source>
          <target state="translated">Если &lt;code&gt;bins&lt;/code&gt; имеет тип int, он определяет количество интервалов одинаковой ширины в заданном диапазоне (по умолчанию 10). Если &lt;code&gt;bins&lt;/code&gt; представляют собой последовательность, она определяет края ячейки, включая крайний правый край, с учетом неравномерной ширины ячейки.</target>
        </trans-unit>
        <trans-unit id="f3d0d1457dc2c27ebf07eb8b8d37fdfe4b5b5f86" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;bins&lt;/code&gt; is not monotonic.</source>
          <target state="translated">Если &lt;code&gt;bins&lt;/code&gt; не монотонны.</target>
        </trans-unit>
        <trans-unit id="f1d57ef4cb7d5156a4314b6ea06d7045fe52a5fa" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;buffer&lt;/code&gt; is None, then only &lt;a href=&quot;numpy.ndarray.shape#numpy.ndarray.shape&quot;&gt;&lt;code&gt;shape&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt;, and &lt;code&gt;order&lt;/code&gt; are used.</source>
          <target state="translated">Если &lt;code&gt;buffer&lt;/code&gt; равен None, то используются только &lt;a href=&quot;numpy.ndarray.shape#numpy.ndarray.shape&quot;&gt; &lt;code&gt;shape&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt; и &lt;code&gt;order&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="eb00c687c7393dfd8dae48855df788062a7f7eb4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;buffer&lt;/code&gt; is None, then only &lt;a href=&quot;numpy.shape#numpy.shape&quot;&gt;&lt;code&gt;shape&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt;, and &lt;code&gt;order&lt;/code&gt; are used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a3f34c748ade1a438e4af494b9939bb52d6b65ae" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;buffer&lt;/code&gt; is an object exposing the buffer interface, then all keywords are interpreted.</source>
          <target state="translated">Если &lt;code&gt;buffer&lt;/code&gt; - это объект, предоставляющий интерфейс буфера, то интерпретируются все ключевые слова.</target>
        </trans-unit>
        <trans-unit id="f67df360e18cb83b99203eea7e5b2b66896eaba4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;buffersize&lt;/code&gt; is zero, a default buffer size is used, otherwise it specifies how big of a buffer to use. Buffers which are powers of 2 such as 4096 or 8192 are recommended.</source>
          <target state="translated">Если &lt;code&gt;buffersize&lt;/code&gt; равен нулю, используется размер буфера по умолчанию, в противном случае он определяет размер используемого буфера. Рекомендуются буферы со степенью двойки, например 4096 или 8192.</target>
        </trans-unit>
        <trans-unit id="beb58b828353ed80b8e0bbe892a75cbfcebae43d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;c&lt;/code&gt; has fewer than 3 dimensions, ones are implicitly appended to its shape to make it 3-D. The shape of the result will be c.shape[3:] + x.shape.</source>
          <target state="translated">Если &lt;code&gt;c&lt;/code&gt; имеет менее трех измерений, к его форме неявно добавляются единицы, чтобы сделать его трехмерным. Форма результата будет c.shape [3:] + x.shape.</target>
        </trans-unit>
        <trans-unit id="f7c13f789159cee3609188e9f6918f23db3edd6c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;c&lt;/code&gt; has fewer than three dimensions, ones are implicitly appended to its shape to make it 3-D. The shape of the result will be c.shape[3:] + x.shape + y.shape + z.shape.</source>
          <target state="translated">Если &lt;code&gt;c&lt;/code&gt; имеет менее трех измерений, к его форме неявно добавляются единицы, чтобы сделать его трехмерным. Форма результата будет c.shape [3:] + x.shape + y.shape + z.shape.</target>
        </trans-unit>
        <trans-unit id="210c7187323274ff624491c071d18c59ba05eaa3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;c&lt;/code&gt; has fewer than two dimensions, ones are implicitly appended to its shape to make it 2-D. The shape of the result will be c.shape[2:] + x.shape + y.shape.</source>
          <target state="translated">Если &lt;code&gt;c&lt;/code&gt; имеет менее двух измерений, к его форме неявно добавляются единицы, чтобы сделать его двумерным. Форма результата будет c.shape [2:] + x.shape + y.shape.</target>
        </trans-unit>
        <trans-unit id="4b9c82b7f7444c244d3d87499e2e6abb52d1e818" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;c&lt;/code&gt; has fewer than two dimensions, ones are implicitly appended to its shape to make it 2-D. The shape of the result will be c.shape[2:] + x.shape.</source>
          <target state="translated">Если &lt;code&gt;c&lt;/code&gt; имеет менее двух измерений, к его форме неявно добавляются единицы, чтобы сделать его двумерным. Форма результата будет c.shape [2:] + x.shape.</target>
        </trans-unit>
        <trans-unit id="b813783672e3b8b110dcc3caed6943e29c499cf7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;c&lt;/code&gt; is a 1-D array a one is implicitly appended to its shape to make it 2-D. The shape of the result will be c.shape[2:] + x.shape.</source>
          <target state="translated">Если &lt;code&gt;c&lt;/code&gt; - одномерный массив, к его форме неявно добавляется единица, чтобы сделать его двумерным. Форма результата будет c.shape [2:] + x.shape.</target>
        </trans-unit>
        <trans-unit id="9b697950a550c5d2ac6bfd1a90d0ee0cf3873621" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;c&lt;/code&gt; is a 1-D array of coefficients of length &lt;code&gt;n + 1&lt;/code&gt; and &lt;code&gt;V&lt;/code&gt; is the array &lt;code&gt;V = hermevander(x, n)&lt;/code&gt;, then &lt;code&gt;np.dot(V, c)&lt;/code&gt; and &lt;code&gt;hermeval(x, c)&lt;/code&gt; are the same up to roundoff. This equivalence is useful both for least squares fitting and for the evaluation of a large number of HermiteE series of the same degree and sample points.</source>
          <target state="translated">Если &lt;code&gt;c&lt;/code&gt; - &lt;code&gt;V = hermevander(x, n)&lt;/code&gt; массив коэффициентов длины &lt;code&gt;n + 1&lt;/code&gt; а &lt;code&gt;V&lt;/code&gt; - массив V = hermevander (x, n) , то &lt;code&gt;np.dot(V, c)&lt;/code&gt; и &lt;code&gt;hermeval(x, c)&lt;/code&gt; совпадают с точностью до округлять. Эта эквивалентность полезна как для аппроксимации методом наименьших квадратов, так и для оценки большого количества серий HermiteE с одинаковой степенью и точками выборки.</target>
        </trans-unit>
        <trans-unit id="8795163ae21f93104b677b1ca18c8738fd9a209a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;c&lt;/code&gt; is a 1-D array of coefficients of length &lt;code&gt;n + 1&lt;/code&gt; and &lt;code&gt;V&lt;/code&gt; is the array &lt;code&gt;V = hermvander(x, n)&lt;/code&gt;, then &lt;code&gt;np.dot(V, c)&lt;/code&gt; and &lt;code&gt;hermval(x, c)&lt;/code&gt; are the same up to roundoff. This equivalence is useful both for least squares fitting and for the evaluation of a large number of Hermite series of the same degree and sample points.</source>
          <target state="translated">Если &lt;code&gt;c&lt;/code&gt; - &lt;code&gt;V = hermvander(x, n)&lt;/code&gt; массив коэффициентов длины &lt;code&gt;n + 1&lt;/code&gt; а &lt;code&gt;V&lt;/code&gt; - массив V = hermvander (x, n) , то &lt;code&gt;np.dot(V, c)&lt;/code&gt; и &lt;code&gt;hermval(x, c)&lt;/code&gt; одинаковы с точностью до округлять. Эта эквивалентность полезна как для аппроксимации методом наименьших квадратов, так и для оценки большого количества серий Эрмита с одинаковой степенью и точками выборки.</target>
        </trans-unit>
        <trans-unit id="41e4b417db13b3be059bf5b8693dedddbf2d39c8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;c&lt;/code&gt; is a 1-D array of coefficients of length &lt;code&gt;n + 1&lt;/code&gt; and &lt;code&gt;V&lt;/code&gt; is the array &lt;code&gt;V = lagvander(x, n)&lt;/code&gt;, then &lt;code&gt;np.dot(V, c)&lt;/code&gt; and &lt;code&gt;lagval(x, c)&lt;/code&gt; are the same up to roundoff. This equivalence is useful both for least squares fitting and for the evaluation of a large number of Laguerre series of the same degree and sample points.</source>
          <target state="translated">Если &lt;code&gt;c&lt;/code&gt; - &lt;code&gt;V = lagvander(x, n)&lt;/code&gt; массив коэффициентов длины &lt;code&gt;n + 1&lt;/code&gt; а &lt;code&gt;V&lt;/code&gt; - массив V = lagvander (x, n) , то &lt;code&gt;np.dot(V, c)&lt;/code&gt; и &lt;code&gt;lagval(x, c)&lt;/code&gt; одинаковы с точностью до округлять. Эта эквивалентность полезна как для аппроксимации методом наименьших квадратов, так и для оценки большого количества рядов Лагерра с одинаковой степенью и точками выборки.</target>
        </trans-unit>
        <trans-unit id="a1b597f29a3697113f705d9c197e77e09839d912" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;c&lt;/code&gt; is a 1-D array of coefficients of length &lt;code&gt;n + 1&lt;/code&gt; and &lt;code&gt;V&lt;/code&gt; is the array &lt;code&gt;V = legvander(x, n)&lt;/code&gt;, then &lt;code&gt;np.dot(V, c)&lt;/code&gt; and &lt;code&gt;legval(x, c)&lt;/code&gt; are the same up to roundoff. This equivalence is useful both for least squares fitting and for the evaluation of a large number of Legendre series of the same degree and sample points.</source>
          <target state="translated">Если &lt;code&gt;c&lt;/code&gt; - &lt;code&gt;V = legvander(x, n)&lt;/code&gt; массив коэффициентов длины &lt;code&gt;n + 1&lt;/code&gt; а &lt;code&gt;V&lt;/code&gt; - массив V = legvander (x, n) , то &lt;code&gt;np.dot(V, c)&lt;/code&gt; и &lt;code&gt;legval(x, c)&lt;/code&gt; одинаковы с точностью до округлять. Эта эквивалентность полезна как для аппроксимации методом наименьших квадратов, так и для оценки большого числа рядов Лежандра с одинаковой степенью и точками выборки.</target>
        </trans-unit>
        <trans-unit id="b7f0c7e082f8807f04eefbe2acbae592bdec65ca" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;c&lt;/code&gt; is a 1-D array of coefficients of length &lt;code&gt;n + 1&lt;/code&gt; and &lt;code&gt;V&lt;/code&gt; is the matrix &lt;code&gt;V = chebvander(x, n)&lt;/code&gt;, then &lt;code&gt;np.dot(V, c)&lt;/code&gt; and &lt;code&gt;chebval(x, c)&lt;/code&gt; are the same up to roundoff. This equivalence is useful both for least squares fitting and for the evaluation of a large number of Chebyshev series of the same degree and sample points.</source>
          <target state="translated">Если &lt;code&gt;c&lt;/code&gt; - &lt;code&gt;V = chebvander(x, n)&lt;/code&gt; массив коэффициентов длины &lt;code&gt;n + 1&lt;/code&gt; а &lt;code&gt;V&lt;/code&gt; - матрица V = chebvander (x, n) , то &lt;code&gt;np.dot(V, c)&lt;/code&gt; и &lt;code&gt;chebval(x, c)&lt;/code&gt; совпадают с точностью до округлять. Эта эквивалентность полезна как для аппроксимации методом наименьших квадратов, так и для оценки большого количества рядов Чебышева одинаковой степени и точек выборки.</target>
        </trans-unit>
        <trans-unit id="4e382928aa8d32a6b35f8adca3a6cffe61170326" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;c&lt;/code&gt; is a 1-D array of coefficients of length &lt;code&gt;n + 1&lt;/code&gt; and &lt;code&gt;V&lt;/code&gt; is the matrix &lt;code&gt;V = polyvander(x, n)&lt;/code&gt;, then &lt;code&gt;np.dot(V, c)&lt;/code&gt; and &lt;code&gt;polyval(x, c)&lt;/code&gt; are the same up to roundoff. This equivalence is useful both for least squares fitting and for the evaluation of a large number of polynomials of the same degree and sample points.</source>
          <target state="translated">Если &lt;code&gt;c&lt;/code&gt; - &lt;code&gt;V = polyvander(x, n)&lt;/code&gt; массив коэффициентов длины &lt;code&gt;n + 1&lt;/code&gt; а &lt;code&gt;V&lt;/code&gt; - матрица V = polyvander (x, n) , то &lt;code&gt;np.dot(V, c)&lt;/code&gt; и &lt;code&gt;polyval(x, c)&lt;/code&gt; одинаковы с точностью до округлять. Эта эквивалентность полезна как для аппроксимации методом наименьших квадратов, так и для оценки большого количества многочленов одной степени и точек выборки.</target>
        </trans-unit>
        <trans-unit id="8e80660168c2556d80131aae5098ce463a202c8f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;c&lt;/code&gt; is a 1-D array, then &lt;code&gt;p(x)&lt;/code&gt; will have the same shape as &lt;code&gt;x&lt;/code&gt;. If &lt;code&gt;c&lt;/code&gt; is multidimensional, then the shape of the result depends on the value of &lt;code&gt;tensor&lt;/code&gt;. If &lt;code&gt;tensor&lt;/code&gt; is true the shape will be c.shape[1:] + x.shape. If &lt;code&gt;tensor&lt;/code&gt; is false the shape will be c.shape[1:]. Note that scalars have shape (,).</source>
          <target state="translated">Если &lt;code&gt;c&lt;/code&gt; - одномерный массив, то &lt;code&gt;p(x)&lt;/code&gt; будет иметь ту же форму, что и &lt;code&gt;x&lt;/code&gt; . Если &lt;code&gt;c&lt;/code&gt; многомерна, то форма результата зависит от значения &lt;code&gt;tensor&lt;/code&gt; . Если &lt;code&gt;tensor&lt;/code&gt; истинен, форма будет c.shape [1:] + x.shape. Если &lt;code&gt;tensor&lt;/code&gt; ложен, форма будет c.shape [1:]. Обратите внимание, что скаляры имеют форму (,).</target>
        </trans-unit>
        <trans-unit id="0a3728daa3b2e189e758d347ca0d72357650db3c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;c&lt;/code&gt; is of length &lt;code&gt;n + 1&lt;/code&gt;, this function returns the value</source>
          <target state="translated">Если &lt;code&gt;c&lt;/code&gt; имеет длину &lt;code&gt;n + 1&lt;/code&gt; , эта функция возвращает значение</target>
        </trans-unit>
        <trans-unit id="e3ad7dc6a355dfc8a1c8aa46843f5488897fd4ce" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;c&lt;/code&gt; is of length &lt;code&gt;n + 1&lt;/code&gt;, this function returns the value:</source>
          <target state="translated">Если &lt;code&gt;c&lt;/code&gt; имеет длину &lt;code&gt;n + 1&lt;/code&gt; , эта функция возвращает значение:</target>
        </trans-unit>
        <trans-unit id="6a970efb45caa036763049ac1a92ee21b5440b3b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;check(..)&lt;/code&gt; is not used then F2PY generates few standard checks (e.g. in a case of an array argument, check for the proper shape and size) automatically. Use &lt;code&gt;check()&lt;/code&gt; to disable checks generated by F2PY.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce30f3388eee45516fb0d109b2a57581be93d2fa" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;cmp_op&lt;/code&gt; is not valid.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3791f18c578dee37c08b1f05312986ce4a1234a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;condition&lt;/code&gt; is boolean:</source>
          <target state="translated">Если &lt;code&gt;condition&lt;/code&gt; логическое:</target>
        </trans-unit>
        <trans-unit id="945ce76f24a4c673d6aa37d9ae7569a5f68abd37" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;data&lt;/code&gt; is provided, it must stay alive for the life of the array. One way to manage this is through &lt;a href=&quot;#c.PyArray_SetBaseObject&quot;&gt;&lt;code&gt;PyArray_SetBaseObject&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">Если &lt;code&gt;data&lt;/code&gt; предоставлены, они должны оставаться активными в течение всего срока службы массива. Один из способов справиться с этим - через &lt;a href=&quot;#c.PyArray_SetBaseObject&quot;&gt; &lt;code&gt;PyArray_SetBaseObject&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="58463c629975ec8a9511dbc013fc3e05064ff197" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;device&lt;/code&gt; does not have a &lt;code&gt;write()&lt;/code&gt; or &lt;code&gt;flush()&lt;/code&gt; method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="799e69512e3ae47752ad1a4389491bce54790cbb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;dtype&lt;/code&gt; is &lt;code&gt;None&lt;/code&gt;, these arguments are passed to &lt;a href=&quot;numpy.format_parser#numpy.format_parser&quot;&gt;&lt;code&gt;numpy.format_parser&lt;/code&gt;&lt;/a&gt; to construct a dtype. See that function for detailed documentation</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb15e22b2a7d43231c255a7fc2569fdb2ab36892" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;dtype&lt;/code&gt; is &lt;code&gt;None&lt;/code&gt;, these arguments are passed to &lt;a href=&quot;numpy.format_parser#numpy.format_parser&quot;&gt;&lt;code&gt;numpy.format_parser&lt;/code&gt;&lt;/a&gt; to construct a dtype. See that function for detailed documentation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="68051abdc74ce34a8cd57f65aadeda23f8c9fb89" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;dtype&lt;/code&gt; isn&amp;rsquo;t &lt;code&gt;NULL&lt;/code&gt;, then it requires that data type. If copying is allowed, it will make a temporary copy if the data is castable. If &lt;a href=&quot;#c.NPY_ITER_UPDATEIFCOPY&quot;&gt;&lt;code&gt;NPY_ITER_UPDATEIFCOPY&lt;/code&gt;&lt;/a&gt; is enabled, it will also copy the data back with another cast upon iterator destruction.</source>
          <target state="translated">Если &lt;code&gt;dtype&lt;/code&gt; не &lt;code&gt;NULL&lt;/code&gt; , то ему требуется этот тип данных. Если копирование разрешено, будет создана временная копия, если данные могут быть преобразованы. Если &lt;a href=&quot;#c.NPY_ITER_UPDATEIFCOPY&quot;&gt; &lt;code&gt;NPY_ITER_UPDATEIFCOPY&lt;/code&gt; &lt;/a&gt; включен, он также скопирует данные обратно с другим приведением после разрушения итератора.</target>
        </trans-unit>
        <trans-unit id="760548f2e1b1246d013e160a44370e64f44dc286" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;enddates&lt;/code&gt; specifies a date value that is earlier than the corresponding &lt;code&gt;begindates&lt;/code&gt; date value, the count will be negative.</source>
          <target state="translated">Если &lt;code&gt;enddates&lt;/code&gt; указывает значение даты, которое раньше, чем соответствующее &lt;code&gt;begindates&lt;/code&gt; даты beginindates , счет будет отрицательным.</target>
        </trans-unit>
        <trans-unit id="417859000cee8d29cc7044346e37933b08a0f1c4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;fieldname&lt;/code&gt; is the empty string &lt;code&gt;''&lt;/code&gt;, the field will be given a default name of the form &lt;code&gt;f#&lt;/code&gt;, where &lt;code&gt;#&lt;/code&gt; is the integer index of the field, counting from 0 from the left:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea2d55579b57bf31daf1f1c848f07e4ba4a33873" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;fortranname&lt;/code&gt; statement is used without &lt;code&gt;&amp;lt;actual Fortran/C routine name&amp;gt;&lt;/code&gt; then a dummy wrapper is generated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb4a6b4dd2e4a7b67147341a42f6c8197722c973" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;indices_or_sections&lt;/code&gt; is a 1-D array of sorted integers, the entries indicate where along &lt;code&gt;axis&lt;/code&gt; the array is split. For example, &lt;code&gt;[2, 3]&lt;/code&gt; would, for &lt;code&gt;axis=0&lt;/code&gt;, result in</source>
          <target state="translated">Если &lt;code&gt;indices_or_sections&lt;/code&gt; представляет собой одномерный массив отсортированных целых чисел, записи указывают, где вдоль &lt;code&gt;axis&lt;/code&gt; массив разбивается. Например, &lt;code&gt;[2, 3]&lt;/code&gt; для &lt;code&gt;axis=0&lt;/code&gt; приведет к</target>
        </trans-unit>
        <trans-unit id="750e535a910db315f0680626cd7e38f07dd476ee" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;indices_or_sections&lt;/code&gt; is an integer, N, the array will be divided into N equal arrays along &lt;code&gt;axis&lt;/code&gt;. If such a split is not possible, an error is raised.</source>
          <target state="translated">Если &lt;code&gt;indices_or_sections&lt;/code&gt; является целым числом N, массив будет разделен на N равных массивов по &lt;code&gt;axis&lt;/code&gt; . Если такое разделение невозможно, возникает ошибка.</target>
        </trans-unit>
        <trans-unit id="c2fbdd32f871ea7c6656b8280d919dff6251170e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;indices_or_sections&lt;/code&gt; is given as an integer, but a split does not result in equal division.</source>
          <target state="translated">Если &lt;code&gt;indices_or_sections&lt;/code&gt; задано как целое число, но разделение не приводит к равному разделению.</target>
        </trans-unit>
        <trans-unit id="64c4e0e507acd8c3f4b71cfa7cf2cf1d38b76639" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;intent(c)&lt;/code&gt; is used as a statement but without an entity declaration list, then F2PY adds the &lt;code&gt;intent(c)&lt;/code&gt; attribute to all arguments.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="820239142587f3701cc156b154b6624dd5007ecf" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;intent(copy)&lt;/code&gt; or &lt;code&gt;intent(overwrite)&lt;/code&gt; is used, then an additional optional argument is introduced with a name &lt;code&gt;overwrite_&amp;lt;argument name&amp;gt;&lt;/code&gt; and a default value 0 or 1, respectively.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c296e3258dbc49519e8602388ede880a24772142" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;k &amp;gt; l&lt;/code&gt;, then only &lt;code&gt;x_1, ..., x_l&lt;/code&gt; are set.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="271207c6144fe7ced9054709b41446a9de60c700" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;k &amp;lt; l&lt;/code&gt;, then &lt;code&gt;y_{k + 1}, ..., y_l&lt;/code&gt; are ignored.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e99e0454406f9add7ef291687419a1330612a513" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;legacy&lt;/code&gt; is False, or the BitGenerator is not MT19937, then state is returned as a dictionary.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce1a7ad82e3cfecd360d23c388ed9b15e3542af6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;legacy&lt;/code&gt; is False, or the BitGenerator is not NT19937, then state is returned as a dictionary.</source>
          <target state="translated">Если &lt;code&gt;legacy&lt;/code&gt; имеет значение False или BitGenerator не NT19937, то состояние возвращается в виде словаря.</target>
        </trans-unit>
        <trans-unit id="146abcde4c240659f226130b295dbaf50c55deac" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;m &amp;lt; 0&lt;/code&gt;, &lt;code&gt;len(k) &amp;gt; m&lt;/code&gt;, &lt;code&gt;np.ndim(lbnd) != 0&lt;/code&gt;, or &lt;code&gt;np.ndim(scl) != 0&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;m &amp;lt; 0&lt;/code&gt; , &lt;code&gt;len(k) &amp;gt; m&lt;/code&gt; , &lt;code&gt;np.ndim(lbnd) != 0&lt;/code&gt; или &lt;code&gt;np.ndim(scl) != 0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2c2df004cd887df3e646568cfffdf17b3ac0ffbf" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;m &amp;lt; 1&lt;/code&gt;, &lt;code&gt;len(k) &amp;gt; m&lt;/code&gt;, &lt;code&gt;np.ndim(lbnd) != 0&lt;/code&gt;, or &lt;code&gt;np.ndim(scl) != 0&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;m &amp;lt; 1&lt;/code&gt; , &lt;code&gt;len(k) &amp;gt; m&lt;/code&gt; , &lt;code&gt;np.ndim(lbnd) != 0&lt;/code&gt; или &lt;code&gt;np.ndim(scl) != 0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e220ffcadc52e486b28727579ddc1e86ad96fbcc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;m1&lt;/code&gt; and &lt;code&gt;m2&lt;/code&gt; have different flexible dtypes.</source>
          <target state="translated">Если &lt;code&gt;m1&lt;/code&gt; и &lt;code&gt;m2&lt;/code&gt; имеют разные гибкие типы d.</target>
        </trans-unit>
        <trans-unit id="0cda2eb48aaf0ad93b34e30066de3169d0688cac" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;m&lt;/code&gt; has a single column then that column is returned as the single row of a matrix. Otherwise &lt;code&gt;m&lt;/code&gt; is returned. The returned matrix is always either &lt;code&gt;m&lt;/code&gt; itself or a view into &lt;code&gt;m&lt;/code&gt;. Supplying an axis keyword argument will not affect the returned matrix but it may cause an error to be raised.</source>
          <target state="translated">Если &lt;code&gt;m&lt;/code&gt; имеет единственный столбец, то этот столбец возвращается как единственная строка матрицы. В противном случае возвращается &lt;code&gt;m&lt;/code&gt; . Возвращенная матрица всегда либо сама &lt;code&gt;m&lt;/code&gt; , либо представление в &lt;code&gt;m&lt;/code&gt; . Предоставление аргумента ключевого слова оси не повлияет на возвращаемую матрицу, но может вызвать ошибку.</target>
        </trans-unit>
        <trans-unit id="d089e6b20e99bc8aa35211116381511548d1fc6f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;maxsplit&lt;/code&gt; is given, at most &lt;code&gt;maxsplit&lt;/code&gt; splits are done, the rightmost ones.</source>
          <target state="translated">Если &lt;code&gt;maxsplit&lt;/code&gt; выполняется не более &lt;code&gt;maxsplit&lt;/code&gt; ,а самые правые .</target>
        </trans-unit>
        <trans-unit id="f3a2beabba4d5e799494083ff0f67c424eaf8432" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;maxsplit&lt;/code&gt; is given, at most &lt;code&gt;maxsplit&lt;/code&gt; splits are done.</source>
          <target state="translated">Если &lt;code&gt;maxsplit&lt;/code&gt; выполняется не более &lt;code&gt;maxsplit&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6e310688fa6d65057ce51d85bd5439d15eeafd62" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;n + p &amp;lt;= m&lt;/code&gt; then &lt;code&gt;gun(a_1, ..., a_n, e_1, ..., e_p)&lt;/code&gt; is called.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="75d4baac79ac0ec79605a8d87c557699bd33432f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;n + p&lt;/code&gt; is less than the number of required arguments to &lt;code&gt;gun&lt;/code&gt; then an exception is raised.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a6773ebb7a73c0cf9641c3fc6c53898d5654dcdd" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;n&lt;/code&gt; is even, &lt;code&gt;A[-1]&lt;/code&gt; contains the term representing both positive and negative Nyquist frequency (+fs/2 and -fs/2), and must also be purely real. If &lt;code&gt;n&lt;/code&gt; is odd, there is no term at fs/2; &lt;code&gt;A[-1]&lt;/code&gt; contains the largest positive frequency (fs/2*(n-1)/n), and is complex in the general case.</source>
          <target state="translated">Если &lt;code&gt;n&lt;/code&gt; четно, &lt;code&gt;A[-1]&lt;/code&gt; содержит член, представляющий как положительную, так и отрицательную частоту Найквиста (+ fs / 2 и -fs / 2), и также должен быть чисто реальным. Если &lt;code&gt;n&lt;/code&gt; нечетное, в fs / 2 нет члена; &lt;code&gt;A[-1]&lt;/code&gt; содержит наибольшую положительную частоту (fs / 2 * (n-1) / n) и является комплексным в общем случае.</target>
        </trans-unit>
        <trans-unit id="d002795222f44b6308a6ac63aedd1a3723557506" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;names&lt;/code&gt; is True, the field names are read from the first line after the first &lt;code&gt;skip_header&lt;/code&gt; lines. This line can optionally be proceeded by a comment delimiter. If &lt;code&gt;names&lt;/code&gt; is a sequence or a single-string of comma-separated names, the names will be used to define the field names in a structured dtype. If &lt;code&gt;names&lt;/code&gt; is None, the names of the dtype fields will be used, if any.</source>
          <target state="translated">Если для &lt;code&gt;names&lt;/code&gt; установлено значение True, имена полей считываются с первой строки после первых строк &lt;code&gt;skip_header&lt;/code&gt; . Эта строка может быть продолжена разделителем комментария. Если &lt;code&gt;names&lt;/code&gt; представляют собой последовательность или одну строку имен, разделенных запятыми, имена будут использоваться для определения имен полей в структурированном dtype. Если &lt;code&gt;names&lt;/code&gt; не None, будут использованы имена полой DTYPE, если таковые имеются.</target>
        </trans-unit>
        <trans-unit id="07b76e3a08f68e2d41d08bcc90944dfb38bf1854" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;names=None&lt;/code&gt; but a structured dtype is expected, names are defined with the standard NumPy default of &lt;code&gt;&quot;f%i&quot;&lt;/code&gt;, yielding names like &lt;code&gt;f0&lt;/code&gt;, &lt;code&gt;f1&lt;/code&gt; and so forth:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d8d4bbddf580197e193ef2ab5f3260ca263687d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;obj.flags&lt;/code&gt; has &lt;a href=&quot;#c.NPY_ARRAY_WRITEBACKIFCOPY&quot;&gt;&lt;code&gt;NPY_ARRAY_WRITEBACKIFCOPY&lt;/code&gt;&lt;/a&gt; or (deprecated) &lt;a href=&quot;#c.NPY_ARRAY_UPDATEIFCOPY&quot;&gt;&lt;code&gt;NPY_ARRAY_UPDATEIFCOPY&lt;/code&gt;&lt;/a&gt;, this function clears the flags, &lt;code&gt;DECREF&lt;/code&gt; s &lt;code&gt;obj-&amp;gt;base&lt;/code&gt; and makes it writeable, and sets &lt;code&gt;obj-&amp;gt;base&lt;/code&gt; to NULL. In contrast to &lt;a href=&quot;#c.PyArray_DiscardWritebackIfCopy&quot;&gt;&lt;code&gt;PyArray_DiscardWritebackIfCopy&lt;/code&gt;&lt;/a&gt; it makes no attempt to copy the data from &lt;code&gt;obj-&amp;gt;base&lt;/code&gt; This undoes &lt;a href=&quot;#c.PyArray_SetWritebackIfCopyBase&quot;&gt;&lt;code&gt;PyArray_SetWritebackIfCopyBase&lt;/code&gt;&lt;/a&gt;. Usually this is called after an error when you are finished with &lt;code&gt;obj&lt;/code&gt;, just before &lt;code&gt;Py_DECREF(obj)&lt;/code&gt;. It may be called multiple times, or with &lt;code&gt;NULL&lt;/code&gt; input.</source>
          <target state="translated">Если &lt;code&gt;obj.flags&lt;/code&gt; имеет &lt;a href=&quot;#c.NPY_ARRAY_WRITEBACKIFCOPY&quot;&gt; &lt;code&gt;NPY_ARRAY_WRITEBACKIFCOPY&lt;/code&gt; &lt;/a&gt; или (устаревшее) &lt;a href=&quot;#c.NPY_ARRAY_UPDATEIFCOPY&quot;&gt; &lt;code&gt;NPY_ARRAY_UPDATEIFCOPY&lt;/code&gt; &lt;/a&gt; , эта функция очищает флаги, &lt;code&gt;DECREF&lt;/code&gt; s &lt;code&gt;obj-&amp;gt;base&lt;/code&gt; и делает его доступным для записи, и устанавливает &lt;code&gt;obj-&amp;gt;base&lt;/code&gt; в NULL. В отличие от &lt;a href=&quot;#c.PyArray_DiscardWritebackIfCopy&quot;&gt; &lt;code&gt;PyArray_DiscardWritebackIfCopy&lt;/code&gt; ,&lt;/a&gt; он не пытается скопировать данные из &lt;code&gt;obj-&amp;gt;base&lt;/code&gt; . Это отменяет &lt;a href=&quot;#c.PyArray_SetWritebackIfCopyBase&quot;&gt; &lt;code&gt;PyArray_SetWritebackIfCopyBase&lt;/code&gt; &lt;/a&gt; . Обычно это вызывается после ошибки, когда вы закончили работу с &lt;code&gt;obj&lt;/code&gt; , непосредственно перед &lt;code&gt;Py_DECREF(obj)&lt;/code&gt; . Его можно вызывать несколько раз или вводить &lt;code&gt;NULL&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8f43e6f1e973bd0d462747acc6303f4251ae23b1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;obj.flags&lt;/code&gt; has &lt;a href=&quot;#c.NPY_ARRAY_WRITEBACKIFCOPY&quot;&gt;&lt;code&gt;NPY_ARRAY_WRITEBACKIFCOPY&lt;/code&gt;&lt;/a&gt; or (deprecated) &lt;a href=&quot;#c.NPY_ARRAY_UPDATEIFCOPY&quot;&gt;&lt;code&gt;NPY_ARRAY_UPDATEIFCOPY&lt;/code&gt;&lt;/a&gt;, this function clears the flags, &lt;code&gt;DECREF&lt;/code&gt; s &lt;code&gt;obj-&amp;gt;base&lt;/code&gt; and makes it writeable, and sets &lt;code&gt;obj-&amp;gt;base&lt;/code&gt; to NULL. It then copies &lt;code&gt;obj-&amp;gt;data&lt;/code&gt; to &lt;code&gt;obj-&amp;gt;base-&amp;gt;data&lt;/code&gt;, and returns the error state of the copy operation. This is the opposite of &lt;a href=&quot;#c.PyArray_SetWritebackIfCopyBase&quot;&gt;&lt;code&gt;PyArray_SetWritebackIfCopyBase&lt;/code&gt;&lt;/a&gt;. Usually this is called once you are finished with &lt;code&gt;obj&lt;/code&gt;, just before &lt;code&gt;Py_DECREF(obj)&lt;/code&gt;. It may be called multiple times, or with &lt;code&gt;NULL&lt;/code&gt; input. See also &lt;a href=&quot;#c.PyArray_DiscardWritebackIfCopy&quot;&gt;&lt;code&gt;PyArray_DiscardWritebackIfCopy&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Если &lt;code&gt;obj.flags&lt;/code&gt; имеет &lt;a href=&quot;#c.NPY_ARRAY_WRITEBACKIFCOPY&quot;&gt; &lt;code&gt;NPY_ARRAY_WRITEBACKIFCOPY&lt;/code&gt; &lt;/a&gt; или (устаревшее) &lt;a href=&quot;#c.NPY_ARRAY_UPDATEIFCOPY&quot;&gt; &lt;code&gt;NPY_ARRAY_UPDATEIFCOPY&lt;/code&gt; &lt;/a&gt; , эта функция очищает флаги, &lt;code&gt;DECREF&lt;/code&gt; s &lt;code&gt;obj-&amp;gt;base&lt;/code&gt; и делает его доступным для записи, и устанавливает &lt;code&gt;obj-&amp;gt;base&lt;/code&gt; в NULL. Затем он копирует &lt;code&gt;obj-&amp;gt;data&lt;/code&gt; в &lt;code&gt;obj-&amp;gt;base-&amp;gt;data&lt;/code&gt; и возвращает состояние ошибки операции копирования. Это противоположность &lt;a href=&quot;#c.PyArray_SetWritebackIfCopyBase&quot;&gt; &lt;code&gt;PyArray_SetWritebackIfCopyBase&lt;/code&gt; &lt;/a&gt; . Обычно это вызывается после завершения работы с &lt;code&gt;obj&lt;/code&gt; , непосредственно перед &lt;code&gt;Py_DECREF(obj)&lt;/code&gt; . Его можно вызывать несколько раз или вводить &lt;code&gt;NULL&lt;/code&gt; . См. Также &lt;a href=&quot;#c.PyArray_DiscardWritebackIfCopy&quot;&gt; &lt;code&gt;PyArray_DiscardWritebackIfCopy&lt;/code&gt; &lt;/a&gt;,</target>
        </trans-unit>
        <trans-unit id="19e346c07517b41525b586a4ff8685ed9ba6dbe8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;obj.ndim == x.ndim&lt;/code&gt;, &lt;code&gt;x[obj]&lt;/code&gt; returns a 1-dimensional array filled with the elements of &lt;em&gt;x&lt;/em&gt; corresponding to the &lt;code&gt;True&lt;/code&gt; values of &lt;em&gt;obj&lt;/em&gt;. The search order will be &lt;a href=&quot;../glossary#term-row-major&quot;&gt;row-major&lt;/a&gt;, C-style. If &lt;em&gt;obj&lt;/em&gt; has &lt;code&gt;True&lt;/code&gt; values at entries that are outside of the bounds of &lt;em&gt;x&lt;/em&gt;, then an index error will be raised. If &lt;em&gt;obj&lt;/em&gt; is smaller than &lt;em&gt;x&lt;/em&gt; it is identical to filling it with &lt;code&gt;False&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b9effe7f71bd1a595880c87c20422da0870723e1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;obj.ndim == x.ndim&lt;/code&gt;, &lt;code&gt;x[obj]&lt;/code&gt; returns a 1-dimensional array filled with the elements of &lt;em&gt;x&lt;/em&gt; corresponding to the &lt;code&gt;True&lt;/code&gt; values of &lt;em&gt;obj&lt;/em&gt;. The search order will be &lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/glossary.html#term-row-major&quot;&gt;row-major&lt;/a&gt;, C-style. If &lt;em&gt;obj&lt;/em&gt; has &lt;code&gt;True&lt;/code&gt; values at entries that are outside of the bounds of &lt;em&gt;x&lt;/em&gt;, then an index error will be raised. If &lt;em&gt;obj&lt;/em&gt; is smaller than &lt;em&gt;x&lt;/em&gt; it is identical to filling it with &lt;code&gt;False&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;obj.ndim == x.ndim&lt;/code&gt; , &lt;code&gt;x[obj]&lt;/code&gt; возвращает одномерный массив, заполненный элементами &lt;em&gt;x,&lt;/em&gt; соответствующими &lt;code&gt;True&lt;/code&gt; значениям &lt;em&gt;obj&lt;/em&gt; . Порядок поиска будет &lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/glossary.html#term-row-major&quot;&gt;строковым&lt;/a&gt; , в стиле C. Если &lt;em&gt;obj&lt;/em&gt; имеет значения &lt;code&gt;True&lt;/code&gt; в записях, которые находятся за пределами &lt;em&gt;x&lt;/em&gt; , то возникает ошибка индекса. Если &lt;em&gt;obj&lt;/em&gt; меньше &lt;em&gt;x,&lt;/em&gt; это идентично заполнению его значением &lt;code&gt;False&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0cb8b5f8682e528917b9dad63d5ce0f0a15864d5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;obj&lt;/code&gt; isn&amp;rsquo;t a suitable numeric type.</source>
          <target state="translated">Если &lt;code&gt;obj&lt;/code&gt; не подходит для числового типа.</target>
        </trans-unit>
        <trans-unit id="bd67812cd1998c40abb29425bc518b926e6b0841" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;op&lt;/code&gt; implements any part of the array interface, then &lt;code&gt;out&lt;/code&gt; will contain a new reference to the newly created ndarray using the interface or &lt;code&gt;out&lt;/code&gt; will contain &lt;code&gt;NULL&lt;/code&gt; if an error during conversion occurs. Otherwise, out will contain a borrowed reference to &lt;a href=&quot;https://docs.python.org/dev/c-api/object.html#c.Py_NotImplemented&quot;&gt;&lt;code&gt;Py_NotImplemented&lt;/code&gt;&lt;/a&gt; and no error condition is set.</source>
          <target state="translated">Если &lt;code&gt;op&lt;/code&gt; реализует какую-либо часть интерфейса массива, тогда &lt;code&gt;out&lt;/code&gt; будет содержать новую ссылку на вновь созданный ndarray с использованием интерфейса, или &lt;code&gt;out&lt;/code&gt; будет содержать &lt;code&gt;NULL&lt;/code&gt; , если во время преобразования произойдет ошибка. В противном случае out будет содержать заимствованную ссылку на &lt;a href=&quot;https://docs.python.org/dev/c-api/object.html#c.Py_NotImplemented&quot;&gt; &lt;code&gt;Py_NotImplemented&lt;/code&gt; ,&lt;/a&gt; и условие ошибки не будет установлено.</target>
        </trans-unit>
        <trans-unit id="12f75ca0900af5198142d436cbdd5e1ee389cfd4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;op&lt;/code&gt; implements any part of the array interface, then &lt;code&gt;out&lt;/code&gt; will contain a new reference to the newly created ndarray using the interface or &lt;code&gt;out&lt;/code&gt; will contain &lt;code&gt;NULL&lt;/code&gt; if an error during conversion occurs. Otherwise, out will contain a borrowed reference to Py_NotImplemented and no error condition is set. This version allows setting of the dtype in the part of the array interface that looks for the &lt;a href=&quot;../arrays.classes#numpy.class.__array__&quot;&gt;&lt;code&gt;__array__&lt;/code&gt;&lt;/a&gt; attribute. &lt;code&gt;context&lt;/code&gt; is unused.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="98dbfb53c5754a6749d968f5df5fe9eebecd4ff8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;op&lt;/code&gt; implements any part of the array interface, then &lt;code&gt;out&lt;/code&gt; will contain a new reference to the newly created ndarray using the interface or &lt;code&gt;out&lt;/code&gt; will contain &lt;code&gt;NULL&lt;/code&gt; if an error during conversion occurs. Otherwise, out will contain a borrowed reference to Py_NotImplemented and no error condition is set. This version allows setting of the type and context in the part of the array interface that looks for the &lt;a href=&quot;arrays.classes#numpy.class.__array__&quot;&gt;&lt;code&gt;__array__&lt;/code&gt;&lt;/a&gt; attribute.</source>
          <target state="translated">Если &lt;code&gt;op&lt;/code&gt; реализует какую-либо часть интерфейса массива, то &lt;code&gt;out&lt;/code&gt; будет содержать новую ссылку на вновь созданный ndarray с использованием интерфейса, или &lt;code&gt;out&lt;/code&gt; будет содержать &lt;code&gt;NULL&lt;/code&gt; , если во время преобразования произойдет ошибка. В противном случае out будет содержать заимствованную ссылку на Py_NotImplemented, и условие ошибки не будет установлено. Эта версия позволяет устанавливать тип и контекст в той части интерфейса массива, которая ищет атрибут &lt;a href=&quot;arrays.classes#numpy.class.__array__&quot;&gt; &lt;code&gt;__array__&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ed83570f54caf00535275cbf2433364d3dc43b7b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;op&lt;/code&gt; is already (C-style) contiguous and well-behaved then just return a reference, otherwise return a (contiguous and well-behaved) copy of the array. The parameter op must be a (sub-class of an) ndarray and no checking for that is done.</source>
          <target state="translated">Если &lt;code&gt;op&lt;/code&gt; уже (в стиле C) является смежным и хорошо себя ведет, тогда просто верните ссылку, в противном случае верните (непрерывную и хорошо управляемую) копию массива. Параметр op должен быть (подклассом) ndarray, и проверка на это не производится.</target>
        </trans-unit>
        <trans-unit id="3efc82f6eb8962f2bbdd61dd48e5d36f40ab01fd" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;op_dtypes&lt;/code&gt; isn&amp;rsquo;t &lt;code&gt;NULL&lt;/code&gt;, it specifies a data type or &lt;code&gt;NULL&lt;/code&gt; for each &lt;code&gt;op[i]&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;op_dtypes&lt;/code&gt; не &lt;code&gt;NULL&lt;/code&gt; , он указывает тип данных или &lt;code&gt;NULL&lt;/code&gt; для каждого &lt;code&gt;op[i]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="49913a9d3761c3c5184d0fb1b55beebafb026c1c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;otypes&lt;/code&gt; is not specified, then a call to the function with the first argument will be used to determine the number of outputs. The results of this call will be cached if &lt;code&gt;cache&lt;/code&gt; is &lt;code&gt;True&lt;/code&gt; to prevent calling the function twice. However, to implement the cache, the original function must be wrapped which will slow down subsequent calls, so only do this if your function is expensive.</source>
          <target state="translated">Если &lt;code&gt;otypes&lt;/code&gt; не указан, то вызов функции с первым аргументом будет использоваться для определения количества выходов. Результаты этого вызова будут кэшироваться, если &lt;code&gt;cache&lt;/code&gt; имеет значение &lt;code&gt;True&lt;/code&gt; , чтобы предотвратить повторный вызов функции. Однако для реализации кеширования исходная функция должна быть обернута, что замедлит последующие вызовы, поэтому делайте это только в том случае, если ваша функция дорогая.</target>
        </trans-unit>
        <trans-unit id="6567b2686e797d9822a7bbf895363486cc94afc9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;out&lt;/code&gt; is None, return a new array containing the standard deviation, otherwise return a reference to the output array.</source>
          <target state="translated">Если &lt;code&gt;out&lt;/code&gt; равно None, вернуть новый массив, содержащий стандартное отклонение, в противном случае вернуть ссылку на выходной массив.</target>
        </trans-unit>
        <trans-unit id="089152cfcf81b924028fc82e4f2ab4321cd32c01" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;out&lt;/code&gt; is None, return a new array containing the standard deviation, otherwise return a reference to the output array. If ddof is &amp;gt;= the number of non-NaN elements in a slice or the slice contains only NaNs, then the result for that slice is NaN.</source>
          <target state="translated">Если &lt;code&gt;out&lt;/code&gt; равно None, вернуть новый массив, содержащий стандартное отклонение, в противном случае вернуть ссылку на выходной массив. Если ddof равен&amp;gt; = количеству элементов, отличных от NaN, в срезе или срез содержит только NaN, то результатом для этого среза будет NaN.</target>
        </trans-unit>
        <trans-unit id="a3cf56d56f9711ddb9fe165ac4a15d1c897a7d62" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;out&lt;/code&gt; is None, return a new array containing the variance, otherwise return a reference to the output array. If ddof is &amp;gt;= the number of non-NaN elements in a slice or the slice contains only NaNs, then the result for that slice is NaN.</source>
          <target state="translated">Если &lt;code&gt;out&lt;/code&gt; равен None, вернуть новый массив, содержащий дисперсию, в противном случае вернуть ссылку на выходной массив. Если ddof равен&amp;gt; = количеству элементов, отличных от NaN, в срезе или срез содержит только NaN, то результатом для этого среза будет NaN.</target>
        </trans-unit>
        <trans-unit id="bd3ed46fb1ad18e3f54a87922d109c78bc224796" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;out&lt;/code&gt; is provided, the function writes the result into it, and returns a reference to &lt;code&gt;out&lt;/code&gt;. (See Examples)</source>
          <target state="translated">Если &lt;code&gt;out&lt;/code&gt; , функция записывает в него результат и возвращает ссылку на &lt;code&gt;out&lt;/code&gt; . (См. Примеры)</target>
        </trans-unit>
        <trans-unit id="d0b860961bc5b4a4c45189c0fd4de5c2d61f1ab4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;out=None&lt;/code&gt;, returns a new array containing the mean values, otherwise a reference to the output array is returned.</source>
          <target state="translated">Если &lt;code&gt;out=None&lt;/code&gt; , возвращается новый массив, содержащий средние значения, в противном случае возвращается ссылка на выходной массив.</target>
        </trans-unit>
        <trans-unit id="d2bfee9ac0986058c6155b92fa93c7a62c8953a4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;out=None&lt;/code&gt;, returns a new array containing the mean values, otherwise a reference to the output array is returned. Nan is returned for slices that contain only NaNs.</source>
          <target state="translated">Если &lt;code&gt;out=None&lt;/code&gt; , возвращает новый массив, содержащий средние значения, в противном случае возвращается ссылка на выходной массив. Nan возвращается для срезов, содержащих только NaN.</target>
        </trans-unit>
        <trans-unit id="64277711f0130f08ef89a03256433633c6256165" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;out=None&lt;/code&gt;, returns a new array containing the variance; otherwise, a reference to the output array is returned.</source>
          <target state="translated">Если &lt;code&gt;out=None&lt;/code&gt; , возвращает новый массив, содержащий дисперсию; в противном случае возвращается ссылка на выходной массив.</target>
        </trans-unit>
        <trans-unit id="9b1c9c61ff9f1ab4238c3c9129f3c3d7264b97ee" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;output&lt;/code&gt; not supplied then source code is printed to screen (sys.stdout). File object must be created with either write &amp;lsquo;w&amp;rsquo; or append &amp;lsquo;a&amp;rsquo; modes.</source>
          <target state="translated">Если &lt;code&gt;output&lt;/code&gt; не предоставлен, исходный код выводится на экран (sys.stdout). Файловый объект должен быть создан с использованием режимов записи 'w' или добавления 'a'.</target>
        </trans-unit>
        <trans-unit id="710d73ebab70d58eff0ea577b59d52767457dc24" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;p &amp;gt; m&lt;/code&gt; then &lt;code&gt;gun(e_1, ..., e_m)&lt;/code&gt; is called.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ffd83286f9552326735c9e9997d8b928bd7d08a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;p &amp;lt;= m &amp;lt; n + p&lt;/code&gt; then &lt;code&gt;gun(a_1, ..., a_q, e_1, ..., e_p)&lt;/code&gt; is called, here &lt;code&gt;q=m-p&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="16e928ca77781f5fb31deca2051e51b1031bced3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;p == 0&lt;/code&gt; then &lt;code&gt;gun(a_1, ..., a_q)&lt;/code&gt; is called, here &lt;code&gt;q = min(m, n)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="04c444cb5aa197d63b68cfea78d90d29188a9456" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;p&lt;/code&gt; is of length N, this function returns the value:</source>
          <target state="translated">Если &lt;code&gt;p&lt;/code&gt; имеет длину N, эта функция возвращает значение:</target>
        </trans-unit>
        <trans-unit id="fe3f05df5768add8f656a94f10e13fc6943b0c1b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;p&lt;/code&gt; is the returned series, then &lt;code&gt;p(x) == x&lt;/code&gt; for all values of x.</source>
          <target state="translated">Если &lt;code&gt;p&lt;/code&gt; - возвращаемый ряд, то &lt;code&gt;p(x) == x&lt;/code&gt; для всех значений x.</target>
        </trans-unit>
        <trans-unit id="f5468a2ba10e85782ab3beca18220db469f1d944" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;path&lt;/code&gt; is an URL, it will be downloaded, stored in the &lt;a href=&quot;numpy.datasource#numpy.DataSource&quot;&gt;&lt;code&gt;DataSource&lt;/code&gt;&lt;/a&gt; directory and opened from there.</source>
          <target state="translated">Если &lt;code&gt;path&lt;/code&gt; является URL-адресом, он будет загружен, сохранен в каталоге &lt;a href=&quot;numpy.datasource#numpy.DataSource&quot;&gt; &lt;code&gt;DataSource&lt;/code&gt; &lt;/a&gt; и открыт оттуда.</target>
        </trans-unit>
        <trans-unit id="24260df7d2aad1e014a4c9af35e7ef7678f51548" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;path&lt;/code&gt; is an URL, then &lt;a href=&quot;#numpy.DataSource.abspath&quot;&gt;&lt;code&gt;abspath&lt;/code&gt;&lt;/a&gt; will return either the location the file exists locally or the location it would exist when opened using the &lt;a href=&quot;numpy.datasource.open#numpy.DataSource.open&quot;&gt;&lt;code&gt;open&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">Если &lt;code&gt;path&lt;/code&gt; является URL-адресом, то &lt;a href=&quot;#numpy.DataSource.abspath&quot;&gt; &lt;code&gt;abspath&lt;/code&gt; &lt;/a&gt; вернет либо местоположение файла, существующее локально, либо местоположение, в котором он будет существовать при открытии с использованием метода &lt;a href=&quot;numpy.datasource.open#numpy.DataSource.open&quot;&gt; &lt;code&gt;open&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9e52fcae8c89336b9d76db6bc95e2d2ecd5abb9e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;q&lt;/code&gt; is a single percentile and &lt;code&gt;axis=None&lt;/code&gt;, then the result is a scalar. If multiple percentiles are given, first axis of the result corresponds to the percentiles. The other axes are the axes that remain after the reduction of &lt;code&gt;a&lt;/code&gt;. If the input contains integers or floats smaller than &lt;code&gt;float64&lt;/code&gt;, the output data-type is &lt;code&gt;float64&lt;/code&gt;. Otherwise, the output data-type is the same as that of the input. If &lt;code&gt;out&lt;/code&gt; is specified, that array is returned instead.</source>
          <target state="translated">Если &lt;code&gt;q&lt;/code&gt; является одним процентилем и &lt;code&gt;axis=None&lt;/code&gt; , то результат является скаляром. Если дано несколько процентилей, первая ось результата соответствует процентилям. Остальные оси - это оси, которые остаются после уменьшения &lt;code&gt;a&lt;/code&gt; . Если входные данные содержат целые числа или числа с плавающей &lt;code&gt;float64&lt;/code&gt; , меньшие, чем float64 , тип выходных данных - &lt;code&gt;float64&lt;/code&gt; . В противном случае тип выходных данных такой же, как и у входных. Если указан &lt;code&gt;out&lt;/code&gt; , вместо этого возвращается этот массив.</target>
        </trans-unit>
        <trans-unit id="4219d6c9d1025bc747faeaba10649824d1b4aa46" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;q&lt;/code&gt; is a single percentile and &lt;code&gt;axis=None&lt;/code&gt;, then the result is a scalar. If multiple quantiles are given, first axis of the result corresponds to the quantiles. The other axes are the axes that remain after the reduction of &lt;code&gt;a&lt;/code&gt;. If the input contains integers or floats smaller than &lt;code&gt;float64&lt;/code&gt;, the output data-type is &lt;code&gt;float64&lt;/code&gt;. Otherwise, the output data-type is the same as that of the input. If &lt;code&gt;out&lt;/code&gt; is specified, that array is returned instead.</source>
          <target state="translated">Если &lt;code&gt;q&lt;/code&gt; является одним процентилем и &lt;code&gt;axis=None&lt;/code&gt; , то результат является скаляром. Если задано несколько квантилей, первая ось результата соответствует квантилям. Остальные оси - это оси, которые остаются после уменьшения &lt;code&gt;a&lt;/code&gt; . Если входные данные содержат целые числа или числа с плавающей &lt;code&gt;float64&lt;/code&gt; , меньшие, чем float64 , тип выходных данных - &lt;code&gt;float64&lt;/code&gt; . В противном случае тип выходных данных такой же, как и у входных. Если указан &lt;code&gt;out&lt;/code&gt; , вместо этого возвращается этот массив.</target>
        </trans-unit>
        <trans-unit id="adb7c2f1dd4ba6f271e782ab821bd6ce35c48378" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;q&lt;/code&gt; is a single quantile and &lt;code&gt;axis=None&lt;/code&gt;, then the result is a scalar. If multiple quantiles are given, first axis of the result corresponds to the quantiles. The other axes are the axes that remain after the reduction of &lt;code&gt;a&lt;/code&gt;. If the input contains integers or floats smaller than &lt;code&gt;float64&lt;/code&gt;, the output data-type is &lt;code&gt;float64&lt;/code&gt;. Otherwise, the output data-type is the same as that of the input. If &lt;code&gt;out&lt;/code&gt; is specified, that array is returned instead.</source>
          <target state="translated">Если &lt;code&gt;q&lt;/code&gt; - это единичный квантиль и &lt;code&gt;axis=None&lt;/code&gt; , то результатом будет скаляр. Если задано несколько квантилей, первая ось результата соответствует квантилям. Остальные оси - это оси, которые остаются после уменьшения &lt;code&gt;a&lt;/code&gt; . Если входные данные содержат целые числа или числа с плавающей &lt;code&gt;float64&lt;/code&gt; , меньшие, чем float64 , тип выходных данных - &lt;code&gt;float64&lt;/code&gt; . В противном случае тип выходных данных такой же, как и у входных. Если указан &lt;code&gt;out&lt;/code&gt; , вместо этого возвращается этот массив.</target>
        </trans-unit>
        <trans-unit id="9da6831f27b77e8b6677e8aad5c341d985befa99" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;r&lt;/code&gt; is a 1-D array, then &lt;code&gt;p(x)&lt;/code&gt; will have the same shape as &lt;code&gt;x&lt;/code&gt;. If &lt;code&gt;r&lt;/code&gt; is multidimensional, then the shape of the result depends on the value of &lt;code&gt;tensor&lt;/code&gt;. If &lt;code&gt;tensor is ``True`&lt;/code&gt; the shape will be r.shape[1:] + x.shape; that is, each polynomial is evaluated at every value of &lt;code&gt;x&lt;/code&gt;. If &lt;code&gt;tensor&lt;/code&gt; is &lt;code&gt;False&lt;/code&gt;, the shape will be r.shape[1:]; that is, each polynomial is evaluated only for the corresponding broadcast value of &lt;code&gt;x&lt;/code&gt;. Note that scalars have shape (,).</source>
          <target state="translated">Если &lt;code&gt;r&lt;/code&gt; - одномерный массив, то &lt;code&gt;p(x)&lt;/code&gt; будет иметь ту же форму, что и &lt;code&gt;x&lt;/code&gt; . Если &lt;code&gt;r&lt;/code&gt; многомерно, то форма результата зависит от значения &lt;code&gt;tensor&lt;/code&gt; . Если &lt;code&gt;tensor is ``True`&lt;/code&gt; форма будет иметь вид r.shape [1:] + x.shape; то есть каждый полином оценивается при каждом значении &lt;code&gt;x&lt;/code&gt; . Если &lt;code&gt;tensor&lt;/code&gt; равен &lt;code&gt;False&lt;/code&gt; , форма будет r.shape [1:]; то есть каждый полином оценивается только для соответствующего широковещательного значения &lt;code&gt;x&lt;/code&gt; . Обратите внимание, что скаляры имеют форму (,).</target>
        </trans-unit>
        <trans-unit id="16d6bbf3ace149a532102c10ab8ede2738b896bf" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;r&lt;/code&gt; is of length &lt;code&gt;N&lt;/code&gt;, this function returns the value</source>
          <target state="translated">Если &lt;code&gt;r&lt;/code&gt; имеет длину &lt;code&gt;N&lt;/code&gt; , эта функция возвращает значение</target>
        </trans-unit>
        <trans-unit id="6bc06c8f2ea0c3500f46f216948ca646bd403c39" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;rep&lt;/code&gt; is an instance of a scalar dtype, True is returned. If not, False is returned.</source>
          <target state="translated">Если &lt;code&gt;rep&lt;/code&gt; является экземпляром скалярного типа dtype, возвращается True. В противном случае возвращается False.</target>
        </trans-unit>
        <trans-unit id="caf6ef0eb6bbcb3c4e7a4a5b04998bc1341e6eb1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;reps&lt;/code&gt; has length &lt;code&gt;d&lt;/code&gt;, the result will have dimension of &lt;code&gt;max(d, A.ndim)&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;reps&lt;/code&gt; имеют длину &lt;code&gt;d&lt;/code&gt; , результат будет иметь размерность &lt;code&gt;max(d, A.ndim)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="15d930e73a09a54bb69273b247bbe9349e70a0c0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;rowvar&lt;/code&gt; is True (default), then each row represents a variable, with observations in the columns. Otherwise, the relationship is transposed: each column represents a variable, while the rows contain observations.</source>
          <target state="translated">Если &lt;code&gt;rowvar&lt;/code&gt; имеет значение True (по умолчанию), то каждая строка представляет переменную с наблюдениями в столбцах. В противном случае связь транспонируется: каждый столбец представляет переменную, а строки содержат наблюдения.</target>
        </trans-unit>
        <trans-unit id="0e485a675b3c010a2a7eedd59e29811b56d30eeb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;s&lt;/code&gt; and &lt;code&gt;axes&lt;/code&gt; have different length, or &lt;code&gt;axes&lt;/code&gt; not given and &lt;code&gt;len(s) != 2&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;s&lt;/code&gt; и &lt;code&gt;axes&lt;/code&gt; имеют разную длину или &lt;code&gt;axes&lt;/code&gt; не указаны и &lt;code&gt;len(s) != 2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b1a95f9d4c94712a6711035b0d38ca6007922134" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;s&lt;/code&gt; and &lt;code&gt;axes&lt;/code&gt; have different length.</source>
          <target state="translated">Если &lt;code&gt;s&lt;/code&gt; и &lt;code&gt;axes&lt;/code&gt; имеют разную длину.</target>
        </trans-unit>
        <trans-unit id="7c3cc7c092c11cc91fc3de1425949e6b1c9585a0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;sctype&lt;/code&gt; is an object for which the type can not be inferred.</source>
          <target state="translated">Если &lt;code&gt;sctype&lt;/code&gt; - это объект, для которого нельзя вывести тип.</target>
        </trans-unit>
        <trans-unit id="9a8f382549c758d89f2c430b015281fc763e47f9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;seed&lt;/code&gt; is not a &lt;a href=&quot;bit_generators/generated/numpy.random.bitgenerator#numpy.random.BitGenerator&quot;&gt;&lt;code&gt;BitGenerator&lt;/code&gt;&lt;/a&gt; or a &lt;a href=&quot;#numpy.random.Generator&quot;&gt;&lt;code&gt;Generator&lt;/code&gt;&lt;/a&gt;, a new &lt;a href=&quot;bit_generators/generated/numpy.random.bitgenerator#numpy.random.BitGenerator&quot;&gt;&lt;code&gt;BitGenerator&lt;/code&gt;&lt;/a&gt; is instantiated. This function does not manage a default global instance.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0aeaeba3f41f378516fdce780d9277e8a4ccfffb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;self.shape[k] == 1&lt;/code&gt; then for any legal index &lt;code&gt;index[k] == 0&lt;/code&gt;. This means that in the formula for the offset</source>
          <target state="translated">Если &lt;code&gt;self.shape[k] == 1&lt;/code&gt; то для любого допустимого индекса &lt;code&gt;index[k] == 0&lt;/code&gt; . Это означает, что в формуле смещения</target>
        </trans-unit>
        <trans-unit id="5df5fe3df9ec97e65980a43dfd1884e4e357c660" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;self&lt;/code&gt; is non-singular, &lt;code&gt;ret&lt;/code&gt; is such that &lt;code&gt;ret * self&lt;/code&gt; == &lt;code&gt;self * ret&lt;/code&gt; == &lt;code&gt;np.matrix(np.eye(self[0,:].size))&lt;/code&gt; all return &lt;code&gt;True&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e5eb20061bb0d5a1e031a6a1b5daa75d4a16cad" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;self&lt;/code&gt; is non-singular, &lt;code&gt;ret&lt;/code&gt; is such that &lt;code&gt;ret * self&lt;/code&gt; == &lt;code&gt;self * ret&lt;/code&gt; == &lt;code&gt;np.matrix(np.eye(self[0,:].size)&lt;/code&gt; all return &lt;code&gt;True&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;self&lt;/code&gt; не единственное число, &lt;code&gt;ret&lt;/code&gt; таково, что &lt;code&gt;ret * self&lt;/code&gt; == &lt;code&gt;self * ret&lt;/code&gt; == &lt;code&gt;np.matrix(np.eye(self[0,:].size)&lt;/code&gt; все возвращают &lt;code&gt;True&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b27bb431dc045601d86e73a474de86c64d035384" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;self&lt;/code&gt; is singular.</source>
          <target state="translated">Если &lt;code&gt;self&lt;/code&gt; - единственное число.</target>
        </trans-unit>
        <trans-unit id="a097af1908df1ac936bba64c59e9507a0eb901d2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;sep&lt;/code&gt; is not specified or &lt;code&gt;None&lt;/code&gt;, any whitespace string is a separator.</source>
          <target state="translated">Если &lt;code&gt;sep&lt;/code&gt; не указан или &lt;code&gt;None&lt;/code&gt; , любая строка с пробелами является разделителем.</target>
        </trans-unit>
        <trans-unit id="6b286f3e58c7b02612a4551d6a9dcb5406b09f75" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;sep&lt;/code&gt; is not specified or None, any whitespace string is a separator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="768a6e9085deaf336653d5c9857ddf9b254027d0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;shape&lt;/code&gt; has length one i.e. &lt;code&gt;(N,)&lt;/code&gt;, or is a scalar &lt;code&gt;N&lt;/code&gt;, &lt;code&gt;out&lt;/code&gt; becomes a single row matrix of shape &lt;code&gt;(1,N)&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;shape&lt;/code&gt; имеет длину один, т.е. &lt;code&gt;(N,)&lt;/code&gt; , или является скаляром &lt;code&gt;N&lt;/code&gt; , &lt;code&gt;out&lt;/code&gt; становится матрицей с одной строкой формы &lt;code&gt;(1,N)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="afe85dc9a909b4503b3e7da810ec90771fac4a7a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;sources&lt;/code&gt; does not contain a signature files, then F2PY is used to scan Fortran source files for routine signatures to construct the wrappers to Fortran codes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d3a0815985e487dc8833e6a9544cd8f4d19132e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;tol&lt;/code&gt; &amp;lt; 0</source>
          <target state="translated">Если &lt;code&gt;tol&lt;/code&gt; &amp;lt;0</target>
        </trans-unit>
        <trans-unit id="6cf15e83c2fdf72b1f29bfc75044966bd6bc1399" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;v&lt;/code&gt; is a 2-D array, return a copy of its &lt;code&gt;k&lt;/code&gt;-th diagonal. If &lt;code&gt;v&lt;/code&gt; is a 1-D array, return a 2-D array with &lt;code&gt;v&lt;/code&gt; on the &lt;code&gt;k&lt;/code&gt;-th diagonal.</source>
          <target state="translated">Если &lt;code&gt;v&lt;/code&gt; - двумерный массив, вернуть копию его &lt;code&gt;k&lt;/code&gt; -й диагонали. Если &lt;code&gt;v&lt;/code&gt; является 1-мерным массивом, вернуть 2-мерный массив с &lt;code&gt;v&lt;/code&gt; на &lt;code&gt;k&lt;/code&gt; -й диагонали.</target>
        </trans-unit>
        <trans-unit id="8349a8e04c4275fccf8d4c40bdfe6166a838f29e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;v&lt;/code&gt; is longer than &lt;code&gt;a&lt;/code&gt;, the arrays are swapped before computation.</source>
          <target state="translated">Если &lt;code&gt;v&lt;/code&gt; больше &lt;code&gt;a&lt;/code&gt; , перед вычислением массивы меняются местами.</target>
        </trans-unit>
        <trans-unit id="bfdbe84100978bde6f35b9bd48d4f5ad4bf72c8d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;values&lt;/code&gt; is not the same size as &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;mask&lt;/code&gt; then it will repeat. This gives behavior different from &lt;code&gt;a[mask] = values&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;values&lt;/code&gt; не то же размера , как и &lt;code&gt;mask&lt;/code&gt; то он будет повторяться. Это дает поведение, отличное от &lt;code&gt;a[mask] = values&lt;/code&gt; . &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="54792a3abbf75ac3395cbad014c19ac2ff1595e1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;values&lt;/code&gt; is smaller than &lt;code&gt;a&lt;/code&gt; it is repeated:</source>
          <target state="translated">Если &lt;code&gt;values&lt;/code&gt; меньше, чем &lt;code&gt;a&lt;/code&gt; , он повторяется:</target>
        </trans-unit>
        <trans-unit id="d3b50be1f74d03f550d5fd9dbbf8a888d565797b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x2&lt;/code&gt; is a scalar, its sign will be copied to all elements of &lt;code&gt;x1&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;x2&lt;/code&gt; - скаляр, его знак будет скопирован для всех элементов &lt;code&gt;x1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b5f780e2f5cb497ee27a4b50260d939ccb5e1976" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is a list or tuple, it is converted to an ndarray, otherwise it is left unchanged and treated as a scalar. In either case, &lt;code&gt;x&lt;/code&gt; or its elements must support addition and multiplication with with themselves and with the elements of &lt;code&gt;c&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;x&lt;/code&gt; является списком или кортежем, он преобразуется в ndarray, в противном случае он остается неизменным и рассматривается как скаляр. В любом случае &lt;code&gt;x&lt;/code&gt; или его элементы должны поддерживать сложение и умножение с самими собой и с элементами &lt;code&gt;c&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e9289f94a42ce2a055130aa0322c6aa21e4c7a12" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is a list or tuple, it is converted to an ndarray, otherwise it is left unchanged and treated as a scalar. In either case, &lt;code&gt;x&lt;/code&gt; or its elements must support addition and multiplication with with themselves and with the elements of &lt;code&gt;r&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;x&lt;/code&gt; является списком или кортежем, он преобразуется в ndarray, в противном случае он остается неизменным и рассматривается как скаляр. В любом случае &lt;code&gt;x&lt;/code&gt; или его элементы должны поддерживать сложение и умножение с самими собой и с элементами &lt;code&gt;r&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0f3c93ccc6b110d8957f1eff605f32da46911a50" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is a multi-dimensional array, it is only shuffled along its first index.</source>
          <target state="translated">Если &lt;code&gt;x&lt;/code&gt; - многомерный массив, он перемещается только по первому индексу.</target>
        </trans-unit>
        <trans-unit id="10902731cd32fb924a9fa6246d242dab230b11a1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is a poly1d instance, the result is the composition of the two polynomials, i.e., &lt;code&gt;x&lt;/code&gt; is &amp;ldquo;substituted&amp;rdquo; in &lt;code&gt;p&lt;/code&gt; and the simplified result is returned. In addition, the type of &lt;code&gt;x&lt;/code&gt; - array_like or poly1d - governs the type of the output: &lt;code&gt;x&lt;/code&gt; array_like =&amp;gt; &lt;code&gt;values&lt;/code&gt; array_like, &lt;code&gt;x&lt;/code&gt; a poly1d object =&amp;gt; &lt;code&gt;values&lt;/code&gt; is also.</source>
          <target state="translated">Если &lt;code&gt;x&lt;/code&gt; является экземпляром poly1d, результатом является композиция двух многочленов, т. Е. &lt;code&gt;x&lt;/code&gt; &amp;laquo;подставляется&amp;raquo; в &lt;code&gt;p&lt;/code&gt; , и возвращается упрощенный результат. Кроме того, тип &lt;code&gt;x&lt;/code&gt; - array_like или poly1d - определяет тип вывода: &lt;code&gt;x&lt;/code&gt; array_like =&amp;gt; &lt;code&gt;values&lt;/code&gt; array_like, &lt;code&gt;x&lt;/code&gt; a poly1d object =&amp;gt; &lt;code&gt;values&lt;/code&gt; также.</target>
        </trans-unit>
        <trans-unit id="d6a5280b73875b8ad0b036e2ed1535be94a86966" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is a sequence, then &lt;code&gt;p(x)&lt;/code&gt; is returned for each element of &lt;code&gt;x&lt;/code&gt;. If &lt;code&gt;x&lt;/code&gt; is another polynomial then the composite polynomial &lt;code&gt;p(x(t))&lt;/code&gt; is returned.</source>
          <target state="translated">Если &lt;code&gt;x&lt;/code&gt; - последовательность, то &lt;code&gt;p(x)&lt;/code&gt; возвращается для каждого элемента &lt;code&gt;x&lt;/code&gt; . Если &lt;code&gt;x&lt;/code&gt; - другой многочлен, то возвращается составной многочлен &lt;code&gt;p(x(t))&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e418b1b9672c946b1ca5e8afc3125fd05c313b38" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is a subtype of &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt; the return value will be of the same type.</source>
          <target state="translated">Если &lt;code&gt;x&lt;/code&gt; является подтипом &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; ,&lt;/a&gt; возвращаемое значение будет того же типа.</target>
        </trans-unit>
        <trans-unit id="2f55968163fb644f21e767c8ca56c7265582f682" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is an integer, randomly permute &lt;code&gt;np.arange(x)&lt;/code&gt;. If &lt;code&gt;x&lt;/code&gt; is an array, make a copy and shuffle the elements randomly.</source>
          <target state="translated">Если &lt;code&gt;x&lt;/code&gt; - целое число, случайным образом переставьте &lt;code&gt;np.arange(x)&lt;/code&gt; . Если &lt;code&gt;x&lt;/code&gt; - массив, сделайте копию и случайным образом перемешайте элементы.</target>
        </trans-unit>
        <trans-unit id="8675c9efb1c5ad5afa002d06cb6dcceef7c6f2a3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is inexact, NaN is replaced by zero or by the user defined value in &lt;a href=&quot;../constants#numpy.nan&quot;&gt;&lt;code&gt;nan&lt;/code&gt;&lt;/a&gt; keyword, infinity is replaced by the largest finite floating point values representable by &lt;code&gt;x.dtype&lt;/code&gt; or by the user defined value in &lt;code&gt;posinf&lt;/code&gt; keyword and -infinity is replaced by the most negative finite floating point values representable by &lt;code&gt;x.dtype&lt;/code&gt; or by the user defined value in &lt;code&gt;neginf&lt;/code&gt; keyword.</source>
          <target state="translated">Если &lt;code&gt;x&lt;/code&gt; неточен, NaN заменяется нулем или определенным пользователем значением в ключевом слове &lt;a href=&quot;../constants#numpy.nan&quot;&gt; &lt;code&gt;nan&lt;/code&gt; &lt;/a&gt; , бесконечность заменяется наибольшими конечными значениями с плавающей запятой, представленными &lt;code&gt;x.dtype&lt;/code&gt; или определенным пользователем значением в &lt;code&gt;posinf&lt;/code&gt; слове posinf, а -infinity заменяется на самые отрицательные конечные значения с плавающей запятой, представленные &lt;code&gt;x.dtype&lt;/code&gt; или пользовательским значением в &lt;code&gt;neginf&lt;/code&gt; слове neginf .</target>
        </trans-unit>
        <trans-unit id="a12bcfaac2b6a0d5eb775110eb5d113a7ffcf89b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is not inexact, then no replacements are made.</source>
          <target state="translated">Если &lt;code&gt;x&lt;/code&gt; не является неточным, то замены не производятся.</target>
        </trans-unit>
        <trans-unit id="dab92b609c96bcdc43f19efa69fe1680ecbcb0cf" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is of a signed integer type, then the output type is the default platform integer:</source>
          <target state="translated">Если &lt;code&gt;x&lt;/code&gt; имеет целочисленный тип со знаком, то тип вывода - это целое число платформы по умолчанию:</target>
        </trans-unit>
        <trans-unit id="9b8211170506c6269c7986617b768331c6cb9374" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;xp&lt;/code&gt; and &lt;code&gt;fp&lt;/code&gt; have different length If &lt;code&gt;xp&lt;/code&gt; or &lt;code&gt;fp&lt;/code&gt; are not 1-D sequences If &lt;code&gt;period == 0&lt;/code&gt;</source>
          <target state="translated">Если &lt;code&gt;xp&lt;/code&gt; и &lt;code&gt;fp&lt;/code&gt; имеют разную длину Если &lt;code&gt;xp&lt;/code&gt; или &lt;code&gt;fp&lt;/code&gt; не являются одномерными последовательностями Если &lt;code&gt;period == 0&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3c2455250a9da7702638a12b7e54e59f4d21fc53" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;arr&lt;/em&gt; is an array, returns its data type descriptor, but if &lt;em&gt;arr&lt;/em&gt; is an array scalar (has 0 dimensions), it finds the data type of smallest size to which the value may be converted without overflow or truncation to an integer.</source>
          <target state="translated">Если &lt;em&gt;arr&lt;/em&gt; является массивом, возвращает его дескриптор типа данных, но если &lt;em&gt;arr&lt;/em&gt; является скаляром массива (имеет 0 измерений), он находит тип данных наименьшего размера, в который значение может быть преобразовано без переполнения или усечения до целого числа.</target>
        </trans-unit>
        <trans-unit id="a70ed9437e4a5163189d25b472581eabce8d5ceb" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;axis&lt;/em&gt; is &lt;em&gt;None&lt;/em&gt; (the default), the array is treated as a 1-D array and the operation is performed over the entire array. This behavior is also the default if self is a 0-dimensional array or array scalar. (An array scalar is an instance of the types/classes float32, float64, etc., whereas a 0-dimensional array is an ndarray instance containing precisely one array scalar.)</source>
          <target state="translated">Если &lt;em&gt;ось&lt;/em&gt; не является &lt;em&gt;None&lt;/em&gt; (по умолчанию), массив рассматривается как массив 1-D и операция выполняется в течение всего массива. Это поведение также используется по умолчанию, если self является 0-мерным массивом или скаляром массива. (Скаляр массива - это экземпляр типов / классов float32, float64 и т. Д., Тогда как 0-мерный массив - это экземпляр ndarray, содержащий ровно один скаляр массива.)</target>
        </trans-unit>
        <trans-unit id="9235232429102d093beb5f545c26b8fef229f79b" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;axis&lt;/em&gt; is an integer, then the operation is done over the given axis (for each 1-D subarray that can be created along the given axis).</source>
          <target state="translated">Если &lt;em&gt;ось&lt;/em&gt; является целым числом, то операция выполняется над данной осью (для каждого одномерного подмассива, который может быть создан вдоль данной оси).</target>
        </trans-unit>
        <trans-unit id="1b1a4ec186584bdfde20daf47a6283f1daa2a542" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;data&lt;/em&gt; is &lt;code&gt;NULL&lt;/code&gt;, then new unitinialized memory will be allocated and &lt;em&gt;flags&lt;/em&gt; can be non-zero to indicate a Fortran-style contiguous array. Use &lt;a href=&quot;#c.PyArray_FILLWBYTE&quot;&gt;&lt;code&gt;PyArray_FILLWBYTE&lt;/code&gt;&lt;/a&gt; to initialize the memory.</source>
          <target state="translated">Если &lt;em&gt;data&lt;/em&gt; имеет &lt;code&gt;NULL&lt;/code&gt; , тогда будет выделена новая единичная память, а &lt;em&gt;флаги&lt;/em&gt; могут быть ненулевыми, чтобы указать непрерывный массив в стиле Fortran. Используйте &lt;a href=&quot;#c.PyArray_FILLWBYTE&quot;&gt; &lt;code&gt;PyArray_FILLWBYTE&lt;/code&gt; &lt;/a&gt; для инициализации памяти.</target>
        </trans-unit>
        <trans-unit id="b7bd71ee3411fe6c23b731a500527ae1ac46e705" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;data&lt;/em&gt; is not &lt;code&gt;NULL&lt;/code&gt;, then it is assumed to point to the memory to be used for the array and the &lt;em&gt;flags&lt;/em&gt; argument is used as the new flags for the array (except the state of &lt;a href=&quot;#c.NPY_ARRAY_OWNDATA&quot;&gt;&lt;code&gt;NPY_ARRAY_OWNDATA&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#c.NPY_ARRAY_WRITEBACKIFCOPY&quot;&gt;&lt;code&gt;NPY_ARRAY_WRITEBACKIFCOPY&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#c.NPY_ARRAY_UPDATEIFCOPY&quot;&gt;&lt;code&gt;NPY_ARRAY_UPDATEIFCOPY&lt;/code&gt;&lt;/a&gt; flags of the new array will be reset).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b3854bd1e23682951d79d6393e1c1b2b19835be" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;data&lt;/em&gt; is not &lt;code&gt;NULL&lt;/code&gt;, then it is assumed to point to the memory to be used for the array and the &lt;em&gt;flags&lt;/em&gt; argument is used as the new flags for the array (except the state of &lt;code&gt;NPY_OWNDATA&lt;/code&gt;, &lt;a href=&quot;#c.NPY_ARRAY_WRITEBACKIFCOPY&quot;&gt;&lt;code&gt;NPY_ARRAY_WRITEBACKIFCOPY&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#c.NPY_ARRAY_UPDATEIFCOPY&quot;&gt;&lt;code&gt;NPY_ARRAY_UPDATEIFCOPY&lt;/code&gt;&lt;/a&gt; flags of the new array will be reset).</source>
          <target state="translated">Если &lt;em&gt;данные&lt;/em&gt; не &lt;code&gt;NULL&lt;/code&gt; , то предполагается, что они указывают на память, которая будет использоваться для массива, и аргумент &lt;em&gt;flags&lt;/em&gt; используется в качестве новых флагов для массива (кроме состояния &lt;code&gt;NPY_OWNDATA&lt;/code&gt; , &lt;a href=&quot;#c.NPY_ARRAY_WRITEBACKIFCOPY&quot;&gt; &lt;code&gt;NPY_ARRAY_WRITEBACKIFCOPY&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;#c.NPY_ARRAY_UPDATEIFCOPY&quot;&gt; &lt;code&gt;NPY_ARRAY_UPDATEIFCOPY&lt;/code&gt; &lt;/a&gt; флагов нового массива будут быть сброшенным).</target>
        </trans-unit>
        <trans-unit id="9cebbbbcc1739892f8b12e053651c131570cd283" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;descr&lt;/em&gt; is NULL, the data type of &lt;em&gt;prototype&lt;/em&gt; is used.</source>
          <target state="translated">Если &lt;em&gt;descr&lt;/em&gt; равно NULL, используется тип данных &lt;em&gt;прототипа&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="aec9506a456027cf0203832745240a439d9ff187" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;dtype&lt;/em&gt; is &lt;code&gt;NULL&lt;/code&gt;, then the returned array will have the same data type as &lt;em&gt;self&lt;/em&gt;. The new data-type must be consistent with the size of &lt;em&gt;self&lt;/em&gt;. Either the itemsizes must be identical, or &lt;em&gt;self&lt;/em&gt; must be single-segment and the total number of bytes must be the same. In the latter case the dimensions of the returned array will be altered in the last (or first for Fortran-style contiguous arrays) dimension. The data area of the returned array and self is exactly the same.</source>
          <target state="translated">Если &lt;em&gt;dtype&lt;/em&gt; равен &lt;code&gt;NULL&lt;/code&gt; , то возвращаемый массив будет иметь тот же тип данных, что и &lt;em&gt;self&lt;/em&gt; . Новый тип данных должен соответствовать размеру &lt;em&gt;self&lt;/em&gt; . Либо размеры элементов должны быть идентичны, либо элементы &lt;em&gt;self&lt;/em&gt; должны быть односегментными и общее количество байтов должно быть одинаковым. В последнем случае размеры возвращаемого массива будут изменены в последнем (или первом для непрерывных массивов в стиле Фортран) измерении. Область данных возвращаемого массива и self точно такая же.</target>
        </trans-unit>
        <trans-unit id="b00215400909f507a463937ff52555cace4d8945" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;op&lt;/em&gt; is already an array, but does not satisfy the requirements, then a copy is made (which will satisfy the requirements). If this flag is present and a copy (of an object that is already an array) must be made, then the corresponding &lt;a href=&quot;#c.NPY_ARRAY_WRITEBACKIFCOPY&quot;&gt;&lt;code&gt;NPY_ARRAY_WRITEBACKIFCOPY&lt;/code&gt;&lt;/a&gt; flag is set in the returned copy and &lt;em&gt;op&lt;/em&gt; is made to be read-only. You must be sure to call &lt;a href=&quot;#c.PyArray_ResolveWritebackIfCopy&quot;&gt;&lt;code&gt;PyArray_ResolveWritebackIfCopy&lt;/code&gt;&lt;/a&gt; to copy the contents back into &lt;em&gt;op&lt;/em&gt; and the &lt;em&gt;op&lt;/em&gt; array will be made writeable again. If &lt;em&gt;op&lt;/em&gt; is not writeable to begin with, or if it is not already an array, then an error is raised.</source>
          <target state="translated">Если &lt;em&gt;op&lt;/em&gt; уже является массивом, но не удовлетворяет требованиям, создается копия (которая удовлетворяет требованиям). Если этот флаг присутствует и должна быть сделана копия (объекта, который уже является массивом), то в возвращаемой копии устанавливается соответствующий флаг &lt;a href=&quot;#c.NPY_ARRAY_WRITEBACKIFCOPY&quot;&gt; &lt;code&gt;NPY_ARRAY_WRITEBACKIFCOPY&lt;/code&gt; ,и операция&lt;/a&gt;&lt;em&gt; op&lt;/em&gt; становится доступной только для чтения. Вы должны обязательно вызвать &lt;a href=&quot;#c.PyArray_ResolveWritebackIfCopy&quot;&gt; &lt;code&gt;PyArray_ResolveWritebackIfCopy&lt;/code&gt; ,&lt;/a&gt; чтобы скопировать содержимое обратно в &lt;em&gt;op,&lt;/em&gt; и массив &lt;em&gt;op&lt;/em&gt; снова станет доступным для записи. Если &lt;em&gt;op&lt;/em&gt; не может быть записан с самого начала или если он еще не является массивом, возникает ошибка.</target>
        </trans-unit>
        <trans-unit id="2b3d523872c6239b2b47533fe932fb9b935c7ec9" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;permute&lt;/em&gt; is &lt;code&gt;NULL&lt;/code&gt;, the shape of the result is</source>
          <target state="translated">Если &lt;em&gt;перестановка&lt;/em&gt; равна &lt;code&gt;NULL&lt;/code&gt; , форма результата будет</target>
        </trans-unit>
        <trans-unit id="864a2871c8455778be67517dc3e9f63ae59a60fb" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;subok&lt;/em&gt; is 1, the newly created array will use the sub-type of &lt;em&gt;prototype&lt;/em&gt; to create the new array, otherwise it will create a base-class array.</source>
          <target state="translated">Если &lt;em&gt;subok&lt;/em&gt; равен 1, вновь созданный массив будет использовать подтип &lt;em&gt;прототипа&lt;/em&gt; для создания нового массива, в противном случае он создаст массив базового класса.</target>
        </trans-unit>
        <trans-unit id="d7c8774de40710ea170a99b3d842fc0b2a6f66b4" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;subtype&lt;/em&gt; is of an array subclass instead of the base &lt;a href=&quot;c-api.types-and-structures#c.PyArray_Type&quot;&gt;&lt;code&gt;&amp;amp;PyArray_Type&lt;/code&gt;&lt;/a&gt;, then &lt;em&gt;obj&lt;/em&gt; is the object to pass to the &lt;a href=&quot;arrays.classes#numpy.class.__array_finalize__&quot;&gt;&lt;code&gt;__array_finalize__&lt;/code&gt;&lt;/a&gt; method of the subclass.</source>
          <target state="translated">Если &lt;em&gt;подтип&lt;/em&gt; относится к подклассу массива, а не к базовому &lt;a href=&quot;c-api.types-and-structures#c.PyArray_Type&quot;&gt; &lt;code&gt;&amp;amp;PyArray_Type&lt;/code&gt; &lt;/a&gt; , тогда &lt;em&gt;obj&lt;/em&gt; является объектом, передаваемым методу &lt;a href=&quot;arrays.classes#numpy.class.__array_finalize__&quot;&gt; &lt;code&gt;__array_finalize__&lt;/code&gt; &lt;/a&gt; подкласса.</target>
        </trans-unit>
        <trans-unit id="3703a88bcd847e1448a723a502192b0e8fa8fa65" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;subtype&lt;/em&gt; is of an array subclass instead of the base &lt;a href=&quot;types-and-structures#c.PyArray_Type&quot;&gt;&lt;code&gt;&amp;amp;PyArray_Type&lt;/code&gt;&lt;/a&gt;, then &lt;em&gt;obj&lt;/em&gt; is the object to pass to the &lt;a href=&quot;../arrays.classes#numpy.class.__array_finalize__&quot;&gt;&lt;code&gt;__array_finalize__&lt;/code&gt;&lt;/a&gt; method of the subclass.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c808aeb714f46484081440736a2f659eda1cb00f" translate="yes" xml:space="preserve">
          <source>If A = qr such that q is orthonormal (which is always possible via Gram-Schmidt), then &lt;code&gt;x = inv(r) * (q.T) * b&lt;/code&gt;. (In numpy practice, however, we simply use &lt;a href=&quot;numpy.linalg.lstsq#numpy.linalg.lstsq&quot;&gt;&lt;code&gt;lstsq&lt;/code&gt;&lt;/a&gt;.)</source>
          <target state="translated">Если A = qr такое, что q ортонормировано (что всегда возможно по Граму-Шмидту), то &lt;code&gt;x = inv(r) * (q.T) * b&lt;/code&gt; . (Однако на практике мы просто используем &lt;a href=&quot;numpy.linalg.lstsq#numpy.linalg.lstsq&quot;&gt; &lt;code&gt;lstsq&lt;/code&gt; &lt;/a&gt; .)</target>
        </trans-unit>
        <trans-unit id="a5523a2784c429b6ba47e45d47c8a0bb942c669e" translate="yes" xml:space="preserve">
          <source>If False, a view into the original arrays are returned in order to conserve memory. Default is True. Please note that &lt;code&gt;sparse=False, copy=False&lt;/code&gt; will likely return non-contiguous arrays. Furthermore, more than one element of a broadcast array may refer to a single memory location. If you need to write to the arrays, make copies first.</source>
          <target state="translated">Если значение равно False, для экономии памяти возвращается представление исходных массивов. По умолчанию True. Обратите внимание, что &lt;code&gt;sparse=False, copy=False&lt;/code&gt; , скорее всего, вернет несмежные массивы. Кроме того, более одного элемента массива широковещательной рассылки могут относиться к одной ячейке памяти. Если вам нужно записать в массивы, сначала сделайте копии.</target>
        </trans-unit>
        <trans-unit id="343caea52a4d2f3f220c6f641bc3ef525fc8ff10" translate="yes" xml:space="preserve">
          <source>If False, reference count will not be checked. Default is True.</source>
          <target state="translated">Если Фальшивка,подсчет ссылок не будет проверен.По умолчанию-Истина.</target>
        </trans-unit>
        <trans-unit id="cc82a0ba7e27b536a6fe2ae6adeaa5a186566e3c" translate="yes" xml:space="preserve">
          <source>If False, the default, returns the number of samples in each bin. If True, returns the probability &lt;em&gt;density&lt;/em&gt; function at the bin, &lt;code&gt;bin_count / sample_count / bin_area&lt;/code&gt;.</source>
          <target state="translated">Если значение по умолчанию равно False, возвращается количество образцов в каждой ячейке. Если True, возвращает функцию &lt;em&gt;плотности&lt;/em&gt; вероятности в &lt;code&gt;bin_count / sample_count / bin_area&lt;/code&gt; , bin_count / sample_count / bin_area .</target>
        </trans-unit>
        <trans-unit id="023ffe5319599a1faa2198b591752fc4467344db" translate="yes" xml:space="preserve">
          <source>If False, the default, returns the number of samples in each bin. If True, returns the probability &lt;em&gt;density&lt;/em&gt; function at the bin, &lt;code&gt;bin_count / sample_count / bin_volume&lt;/code&gt;.</source>
          <target state="translated">Если значение по умолчанию равно False, возвращается количество образцов в каждой ячейке. Если True, возвращает функцию &lt;em&gt;плотности&lt;/em&gt; вероятности в &lt;code&gt;bin_count / sample_count / bin_volume&lt;/code&gt; , bin_count / sample_count / bin_volume .</target>
        </trans-unit>
        <trans-unit id="fff9762cd2d96487b93950bfb4f1067d252f526d" translate="yes" xml:space="preserve">
          <source>If GitHub indicates that the branch of your Pull Request can no longer be merged automatically, you have to incorporate changes that have been made since you started into your branch. Our recommended way to do this is to &lt;a href=&quot;development_workflow#rebasing-on-master&quot;&gt;rebase on master&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a65d3c4015ca8415c134fa3b89bccc8e92003c36" translate="yes" xml:space="preserve">
          <source>If K = min(M, N), then</source>
          <target state="translated">Если K=мин(M,N),то</target>
        </trans-unit>
        <trans-unit id="c8fe35dc8be08c32dcc7a321c29a26e840a0b0cb" translate="yes" xml:space="preserve">
          <source>If None, the index is into the flattened array, otherwise along the specified axis</source>
          <target state="translated">Если None,то индекс находится в сплющенном массиве,в противном случае вдоль указанной оси.</target>
        </trans-unit>
        <trans-unit id="b2ed776381411dcc06237a74c5e85611ae70c52e" translate="yes" xml:space="preserve">
          <source>If None, then the path is assumed to be the local path plus the subpackage_name. If a setup.py file is not found in the subpackage_path, then a default configuration is used.</source>
          <target state="translated">Если None,то предполагается,что это локальный путь плюс имя_субпакета.Если файл setup.py не найден в пути subpackage_path,то используется конфигурация по умолчанию.</target>
        </trans-unit>
        <trans-unit id="7f68badbcb18a0e633a2cc1aee70bc74cc566792" translate="yes" xml:space="preserve">
          <source>If None, use a MaskType instance. Otherwise, use a new datatype with the same fields as &lt;code&gt;dtype&lt;/code&gt;, converted to boolean types.</source>
          <target state="translated">Если None, используйте экземпляр MaskType. В противном случае используйте новый тип данных с теми же полями, что и &lt;code&gt;dtype&lt;/code&gt; , преобразованный в логические типы.</target>
        </trans-unit>
        <trans-unit id="858f084d421de6a09702f1940e95232bb37adf96" translate="yes" xml:space="preserve">
          <source>If Python &lt;code&gt;None&lt;/code&gt; object is used as a required argument, the argument is treated as optional. That is, in the case of array argument, the memory is allocated. And if &lt;code&gt;&amp;lt;init_expr&amp;gt;&lt;/code&gt; is given, the corresponding initialization is carried out.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b88b29f182ab4a1e89998e5d778c700419477eb5" translate="yes" xml:space="preserve">
          <source>If SVD computation does not converge.</source>
          <target state="translated">Если вычисления SVD не сходятся.</target>
        </trans-unit>
        <trans-unit id="1c8e91eba4c31b07d056c5e107cd3dbd66e73c1f" translate="yes" xml:space="preserve">
          <source>If True (default) make a copy of &lt;code&gt;a&lt;/code&gt; in the result. If False modify &lt;code&gt;a&lt;/code&gt; in place and return a view.</source>
          <target state="translated">Если True ( по умолчанию) сделайте копию в результате. Если False, измените &lt;code&gt;a&lt;/code&gt; на месте и верните представление. &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5f05298246a514cfbe30605192f5c3eec0c39e89" translate="yes" xml:space="preserve">
          <source>If True (default), &lt;code&gt;u&lt;/code&gt; and &lt;code&gt;vh&lt;/code&gt; have the shapes &lt;code&gt;(..., M, M)&lt;/code&gt; and &lt;code&gt;(..., N, N)&lt;/code&gt;, respectively. Otherwise, the shapes are &lt;code&gt;(..., M, K)&lt;/code&gt; and &lt;code&gt;(..., K, N)&lt;/code&gt;, respectively, where &lt;code&gt;K = min(M, N)&lt;/code&gt;.</source>
          <target state="translated">Если True (по умолчанию), &lt;code&gt;u&lt;/code&gt; и &lt;code&gt;vh&lt;/code&gt; имеют формы &lt;code&gt;(..., M, M)&lt;/code&gt; и &lt;code&gt;(..., N, N)&lt;/code&gt; соответственно. В противном случае формы будут &lt;code&gt;(..., M, K)&lt;/code&gt; и &lt;code&gt;(..., K, N)&lt;/code&gt; соответственно, где &lt;code&gt;K = min(M, N)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b7193bd03fb8a4044e82de41b9072ea59ef18024" translate="yes" xml:space="preserve">
          <source>If True (default), the function for pretty printing (&lt;code&gt;__repr__&lt;/code&gt;) is set, if False the function that returns the default string representation (&lt;code&gt;__str__&lt;/code&gt;) is set.</source>
          <target state="translated">Если True (по умолчанию), устанавливается функция красивой печати ( &lt;code&gt;__repr__&lt;/code&gt; ), если False, устанавливается функция, возвращающая строковое представление по умолчанию ( &lt;code&gt;__str__&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="303e2928545dd79ae7d3ee948a353e0207edca4f" translate="yes" xml:space="preserve">
          <source>If True a sparse grid is returned in order to conserve memory. Default is False.</source>
          <target state="translated">В случае True возвращается разреженная сетка для сохранения памяти.По умолчанию-Ложь.</target>
        </trans-unit>
        <trans-unit id="963fdb4eb1744c24416dda1302569ec977b1039b" translate="yes" xml:space="preserve">
          <source>If True, &lt;code&gt;M&lt;/code&gt; is assumed to be Hermitian (symmetric if real-valued), enabling a more efficient method for finding singular values. Defaults to False.</source>
          <target state="translated">Если True, &lt;code&gt;M&lt;/code&gt; считается эрмитовым (симметричным, если действительное значение), что позволяет использовать более эффективный метод поиска сингулярных значений. По умолчанию False.</target>
        </trans-unit>
        <trans-unit id="7ff6382ed5c39a63563e9ed1fd085cab5037a2b5" translate="yes" xml:space="preserve">
          <source>If True, &lt;code&gt;a&lt;/code&gt; is assumed to be Hermitian (symmetric if real-valued), enabling a more efficient method for finding singular values. Defaults to False.</source>
          <target state="translated">Если True, предполагается , что &lt;code&gt;a&lt;/code&gt; является эрмитовым (симметричным, если имеет действительное значение), что позволяет использовать более эффективный метод поиска сингулярных значений. По умолчанию False.</target>
        </trans-unit>
        <trans-unit id="e36b410b04f66dbee1ad8585d5ab761e08ac7f58" translate="yes" xml:space="preserve">
          <source>If True, &lt;code&gt;c_or_r&lt;/code&gt; specifies the polynomial&amp;rsquo;s roots; the default is False.</source>
          <target state="translated">Если True, &lt;code&gt;c_or_r&lt;/code&gt; определяет корни многочлена; по умолчанию - False.</target>
        </trans-unit>
        <trans-unit id="d928194afbe2c2b929bfedb481313d712d7c8b8b" translate="yes" xml:space="preserve">
          <source>If True, &lt;code&gt;stop&lt;/code&gt; is the last sample. Otherwise, it is not included. Default is True.</source>
          <target state="translated">Если True, &lt;code&gt;stop&lt;/code&gt; - это последняя выборка. В противном случае он не включается. По умолчанию True.</target>
        </trans-unit>
        <trans-unit id="7b47be5e3a5ad40d6f18921eb27fcceb85292f89" translate="yes" xml:space="preserve">
          <source>If True, NaNs will compare equal.</source>
          <target state="translated">Если Правда,то NaNs будут сравнивать равные.</target>
        </trans-unit>
        <trans-unit id="cf238e83938a09d87961a742f48c2f2620eb27d1" translate="yes" xml:space="preserve">
          <source>If True, align the fields by padding as the C-compiler would. Default is False.</source>
          <target state="translated">Если параметр True,выровняйте поля с помощью набивки,как это делал бы С-компилятор.По умолчанию False.</target>
        </trans-unit>
        <trans-unit id="9aac1833ab9bd35419c20a57ebf8fcbcb3fe9e5b" translate="yes" xml:space="preserve">
          <source>If True, also repack nested structures.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fac02997269b77136285be7a5e579ac29dadfffd" translate="yes" xml:space="preserve">
          <source>If True, also return the indices of &lt;code&gt;ar&lt;/code&gt; (along the specified axis, if provided, or in the flattened array) that result in the unique array.</source>
          <target state="translated">Если True, также возвращают индексы &lt;code&gt;ar&lt;/code&gt; (вдоль указанной оси, если они есть, или в сглаженном массиве), которые приводят к уникальному массиву.</target>
        </trans-unit>
        <trans-unit id="5ba4a4047dcee50611d5129a3a15323121b0e960" translate="yes" xml:space="preserve">
          <source>If True, also return the indices of the unique array (for the specified axis, if provided) that can be used to reconstruct &lt;code&gt;ar&lt;/code&gt;.</source>
          <target state="translated">Если True, также верните индексы уникального массива (для указанной оси, если он предоставлен), который можно использовать для восстановления &lt;code&gt;ar&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="399ee9e74026589c23b2445da8094594d73ae5dd" translate="yes" xml:space="preserve">
          <source>If True, also return the number of times each unique item appears in &lt;code&gt;ar&lt;/code&gt;.</source>
          <target state="translated">Если True, также верните количество раз, когда каждый уникальный элемент появляется в &lt;code&gt;ar&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="66852352128b1c7e34ad7789302cdfe6ede485bb" translate="yes" xml:space="preserve">
          <source>If True, always print floating point numbers using fixed point notation, in which case numbers equal to zero in the current precision will print as zero. If False, then scientific notation is used when absolute value of the smallest number is &amp;lt; 1e-4 or the ratio of the maximum absolute value to the minimum is &amp;gt; 1e3. The default is False.</source>
          <target state="translated">Если True, всегда печатайте числа с плавающей запятой, используя запись с фиксированной запятой, и в этом случае числа, равные нулю с текущей точностью, будут печататься как ноль. Если False, то используется научная нотация, когда абсолютное значение наименьшего числа &amp;lt;1e-4 или отношение максимального абсолютного значения к минимальному&amp;gt; 1e3. По умолчанию - False.</target>
        </trans-unit>
        <trans-unit id="cbca430a42a0182aa9ea6441a3957e8ab3c8a25b" translate="yes" xml:space="preserve">
          <source>If True, always returns a tuple.</source>
          <target state="translated">Если Правда,всегда возвращает кортеж.</target>
        </trans-unit>
        <trans-unit id="7f126462d85653c6dda1dce20f661e9fd87395a7" translate="yes" xml:space="preserve">
          <source>If True, an exception is raised if an inconsistency is detected in the number of columns. If False, a warning is emitted and the offending lines are skipped.</source>
          <target state="translated">Если Истина,то при обнаружении несоответствия в количестве столбцов повышается исключение.Если False,выдается предупреждение и пропускаются линии нарушения.</target>
        </trans-unit>
        <trans-unit id="00dd94f809ecdc81e9a20bf00165ace3a76e2409" translate="yes" xml:space="preserve">
          <source>If True, do not raise errors for invalid values.</source>
          <target state="translated">Если параметр True,не допускайте ошибок для недействительных значений.</target>
        </trans-unit>
        <trans-unit id="75ba0a561e02b7ed5e7fa180639d41ec79419f2b" translate="yes" xml:space="preserve">
          <source>If True, field names are case sensitive. If False or &amp;lsquo;upper&amp;rsquo;, field names are converted to upper case. If &amp;lsquo;lower&amp;rsquo;, field names are converted to lower case.</source>
          <target state="translated">Если True, имена полей чувствительны к регистру. Если &quot;Ложь&quot; или &quot;верхний&quot;, имена полей преобразуются в верхний регистр. Если &amp;laquo;ниже&amp;raquo;, имена полей преобразуются в нижний регистр.</target>
        </trans-unit>
        <trans-unit id="d130bfc0ef6421a7c1dc4437f4b7a0f3775ccf94" translate="yes" xml:space="preserve">
          <source>If True, fields in the dst for which there was no matching field in the src are filled with the value 0 (zero). This was the behavior of numpy &amp;lt;= 1.13. If False, those fields are not modified.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d57971ed0ca8f21d400e58c76703f43cbfc417c" translate="yes" xml:space="preserve">
          <source>If True, masked values are propagated pair-wise: if a value is masked in &lt;code&gt;x&lt;/code&gt;, the corresponding value is masked in &lt;code&gt;y&lt;/code&gt;. If False, raises a &lt;code&gt;ValueError&lt;/code&gt; exception when some values are missing.</source>
          <target state="translated">Если True, замаскированные значения распространяются попарно: если значение замаскировано в &lt;code&gt;x&lt;/code&gt; , соответствующее значение замаскировано в &lt;code&gt;y&lt;/code&gt; . Если False, вызывает исключение &lt;code&gt;ValueError&lt;/code&gt; , когда некоторые значения отсутствуют.</target>
        </trans-unit>
        <trans-unit id="73add7a762002fef273e9b4ffea7ca56d1fceed2" translate="yes" xml:space="preserve">
          <source>If True, masked values are propagated pair-wise: if a value is masked in &lt;code&gt;x&lt;/code&gt;, the corresponding value is masked in &lt;code&gt;y&lt;/code&gt;. If False, raises an exception. Because &lt;code&gt;bias&lt;/code&gt; is deprecated, this argument needs to be treated as keyword only to avoid a warning.</source>
          <target state="translated">Если True, замаскированные значения распространяются попарно: если значение замаскировано в &lt;code&gt;x&lt;/code&gt; , соответствующее значение замаскировано в &lt;code&gt;y&lt;/code&gt; . Если False, вызывает исключение. Поскольку &lt;code&gt;bias&lt;/code&gt; не рекомендуется, этот аргумент следует рассматривать как ключевое слово только во избежание предупреждения.</target>
        </trans-unit>
        <trans-unit id="3151423c1b8495757a74a9c40933465afccfc94a" translate="yes" xml:space="preserve">
          <source>If True, report coverage of NumPy code. Default is False. (This requires the &lt;a href=&quot;https://nedbatchelder.com/code/modules/coveragehtml&quot;&gt;coverage module&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3f2788b0d6fce7deb3124b031af49411eebfd85f" translate="yes" xml:space="preserve">
          <source>If True, return (&lt;code&gt;samples&lt;/code&gt;, &lt;code&gt;step&lt;/code&gt;), where &lt;code&gt;step&lt;/code&gt; is the spacing between samples.</source>
          <target state="translated">Если True, вернуть ( &lt;code&gt;samples&lt;/code&gt; , &lt;code&gt;step&lt;/code&gt; ), где &lt;code&gt;step&lt;/code&gt; - интервал между выборками.</target>
        </trans-unit>
        <trans-unit id="1ec0fbd07daef19f7914b14e4eca0f4fd562cd19" translate="yes" xml:space="preserve">
          <source>If True, return a masked array. If False, return a regular array.</source>
          <target state="translated">Если значение True,верните массив,замаскированный под маску.Если False,вернуть обычный массив.</target>
        </trans-unit>
        <trans-unit id="6adea9a68fb349bf8bb3df130607e9340ead5b74" translate="yes" xml:space="preserve">
          <source>If True, run doctests in module. Default is False.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="23ec8ba9608d7abff50b6dc8fd3f7629dafcce5d" translate="yes" xml:space="preserve">
          <source>If True, specifies that the decorated callable is a test. If False, specifies that the decorated callable is not a test. Default is True.</source>
          <target state="translated">Если Верно,укажите,что декорированный позывной является тестом.Если False,указывает,что декорированная позывная не является тестом.Default is True.</target>
        </trans-unit>
        <trans-unit id="392d55a0a9d04db7b0ca9f8c7072e4cdcc499491" translate="yes" xml:space="preserve">
          <source>If True, subclasses are preserved.</source>
          <target state="translated">Если Правда,подклассы сохраняются.</target>
        </trans-unit>
        <trans-unit id="8d750c3ba08e3d89b81f148fbacf7cfd56b0a5f8" translate="yes" xml:space="preserve">
          <source>If True, the axes which are reduced are left in the result as dimensions with size one. With this option, the result will broadcast correctly against the original &lt;code&gt;arr&lt;/code&gt;.</source>
          <target state="translated">Если True, уменьшенные оси останутся в результате как размеры с размером один. С этой опцией результат будет транслироваться правильно относительно исходного &lt;code&gt;arr&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b2006dd9c76a3ff3a106ec273dd3c8e1e765c752" translate="yes" xml:space="preserve">
          <source>If True, the conflicting values are appended to the error message.</source>
          <target state="translated">Если значение True,то конфликтующие значения добавляются к сообщению об ошибке.</target>
        </trans-unit>
        <trans-unit id="d8ba5d3712bb2ee2efcfc81e8a867c710618acda" translate="yes" xml:space="preserve">
          <source>If True, the indices which correspond to the intersection of the two arrays are returned. The first instance of a value is used if there are multiple. Default is False.</source>
          <target state="translated">Если значение True,возвращаются индексы,соответствующие пересечению двух массивов.Первый экземпляр значения используется,если их несколько.По умолчанию False.</target>
        </trans-unit>
        <trans-unit id="796c55d79196f76e9a5e82ed451d32129c18b457" translate="yes" xml:space="preserve">
          <source>If True, the input arrays are both assumed to be unique, which can speed up the calculation. Default is False.</source>
          <target state="translated">Если значение True,то предполагается,что оба входных массива уникальны,что может ускорить вычисление.По умолчанию-False.</target>
        </trans-unit>
        <trans-unit id="4faadc5e6554004b31ce5928d5d80bd241c02388" translate="yes" xml:space="preserve">
          <source>If True, the iterator was created with either the &lt;code&gt;c_index&lt;/code&gt; or the &lt;code&gt;f_index&lt;/code&gt; flag, and the property &lt;a href=&quot;numpy.nditer.index#numpy.nditer.index&quot;&gt;&lt;code&gt;index&lt;/code&gt;&lt;/a&gt; can be used to retrieve it.</source>
          <target state="translated">Если True, итератор был создан с &lt;code&gt;c_index&lt;/code&gt; или &lt;code&gt;f_index&lt;/code&gt; , и &lt;a href=&quot;numpy.nditer.index#numpy.nditer.index&quot;&gt; &lt;code&gt;index&lt;/code&gt; &lt;/a&gt; свойства может использоваться для его получения.</target>
        </trans-unit>
        <trans-unit id="78e99fe24c914b8497fc3d013aec906afbe03579" translate="yes" xml:space="preserve">
          <source>If True, the iterator was created with the &lt;code&gt;delay_bufalloc&lt;/code&gt; flag, and no reset() function was called on it yet.</source>
          <target state="translated">Если True, итератор был создан с флагом &lt;code&gt;delay_bufalloc&lt;/code&gt; , и для него еще не вызывалась функция reset ().</target>
        </trans-unit>
        <trans-unit id="78a4539bda923dafd78fad0e5fb97c6b43556f2b" translate="yes" xml:space="preserve">
          <source>If True, the iterator was created with the &lt;code&gt;multi_index&lt;/code&gt; flag, and the property &lt;a href=&quot;numpy.nditer.multi_index#numpy.nditer.multi_index&quot;&gt;&lt;code&gt;multi_index&lt;/code&gt;&lt;/a&gt; can be used to retrieve it.</source>
          <target state="translated">Если True, итератор был создан с флагом &lt;code&gt;multi_index&lt;/code&gt; , и свойство &lt;a href=&quot;numpy.nditer.multi_index#numpy.nditer.multi_index&quot;&gt; &lt;code&gt;multi_index&lt;/code&gt; &lt;/a&gt; можно использовать для его получения.</target>
        </trans-unit>
        <trans-unit id="f4229174699f5726402f68c65f4921612f023a93" translate="yes" xml:space="preserve">
          <source>If True, the returned array is transposed, so that arguments may be unpacked using &lt;code&gt;x, y, z = loadtxt(...)&lt;/code&gt;</source>
          <target state="translated">Если True, возвращаемый массив транспонируется, так что аргументы могут быть распакованы с помощью &lt;code&gt;x, y, z = loadtxt(...)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b9bf7edcd483311b9596b9cc1a4efa43974ee453" translate="yes" xml:space="preserve">
          <source>If True, the returned array is transposed, so that arguments may be unpacked using &lt;code&gt;x, y, z = loadtxt(...)&lt;/code&gt;. When used with a structured data-type, arrays are returned for each field. Default is False.</source>
          <target state="translated">Если True, возвращаемый массив транспонируется, так что аргументы могут быть распакованы с использованием &lt;code&gt;x, y, z = loadtxt(...)&lt;/code&gt; . При использовании со структурированным типом данных для каждого поля возвращаются массивы. По умолчанию - False.</target>
        </trans-unit>
        <trans-unit id="d43fcdb1c52440e31bff4cb2f390cb23f384392a" translate="yes" xml:space="preserve">
          <source>If True, the shape of the coefficient array is extended with ones on the right, one for each dimension of &lt;code&gt;x&lt;/code&gt;. Scalars have dimension 0 for this action. The result is that every column of coefficients in &lt;code&gt;c&lt;/code&gt; is evaluated for every element of &lt;code&gt;x&lt;/code&gt;. If False, &lt;code&gt;x&lt;/code&gt; is broadcast over the columns of &lt;code&gt;c&lt;/code&gt; for the evaluation. This keyword is useful when &lt;code&gt;c&lt;/code&gt; is multidimensional. The default value is True.</source>
          <target state="translated">Если True, форма массива коэффициентов расширяется единицами справа, по одному для каждого измерения &lt;code&gt;x&lt;/code&gt; . Скаляры имеют размерность 0 для этого действия. В результате каждый столбец коэффициентов в &lt;code&gt;c&lt;/code&gt; оценивается для каждого элемента &lt;code&gt;x&lt;/code&gt; . Если False, &lt;code&gt;x&lt;/code&gt; транслируется по столбцам &lt;code&gt;c&lt;/code&gt; для оценки. Это ключевое слово полезно, когда &lt;code&gt;c&lt;/code&gt; многомерна. Значение по умолчанию верно.</target>
        </trans-unit>
        <trans-unit id="959391ebb6591b28733d37c72b179dc2ae1393e8" translate="yes" xml:space="preserve">
          <source>If True, the shape of the roots array is extended with ones on the right, one for each dimension of &lt;code&gt;x&lt;/code&gt;. Scalars have dimension 0 for this action. The result is that every column of coefficients in &lt;code&gt;r&lt;/code&gt; is evaluated for every element of &lt;code&gt;x&lt;/code&gt;. If False, &lt;code&gt;x&lt;/code&gt; is broadcast over the columns of &lt;code&gt;r&lt;/code&gt; for the evaluation. This keyword is useful when &lt;code&gt;r&lt;/code&gt; is multidimensional. The default value is True.</source>
          <target state="translated">Если True, форма массива корней расширяется единицами справа, по одному для каждого измерения &lt;code&gt;x&lt;/code&gt; . Скаляры имеют размерность 0 для этого действия. В результате каждый столбец коэффициентов в &lt;code&gt;r&lt;/code&gt; оценивается для каждого элемента &lt;code&gt;x&lt;/code&gt; . Если False, &lt;code&gt;x&lt;/code&gt; транслируется по столбцам &lt;code&gt;r&lt;/code&gt; для оценки. Это ключевое слово полезно, когда &lt;code&gt;r&lt;/code&gt; многомерно. Значение по умолчанию верно.</target>
        </trans-unit>
        <trans-unit id="6f56bb6f69c7a79b2fcb0eba261866b1784e5a91" translate="yes" xml:space="preserve">
          <source>If True, the spaces at the end of Strings are removed before the comparison.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="201e227337fd7a8180e5a7ed35ba4fd5fc02b88e" translate="yes" xml:space="preserve">
          <source>If True, the values in the returned array are inverted (that is, False where an element of &lt;code&gt;ar1&lt;/code&gt; is in &lt;code&gt;ar2&lt;/code&gt; and True otherwise). Default is False. &lt;code&gt;np.in1d(a, b, invert=True)&lt;/code&gt; is equivalent to (but is faster than) &lt;code&gt;np.invert(in1d(a, b))&lt;/code&gt;.</source>
          <target state="translated">Если True, значения в возвращаемом массиве инвертируются (то есть False, если элемент &lt;code&gt;ar1&lt;/code&gt; находится в &lt;code&gt;ar2&lt;/code&gt; , и True в противном случае). По умолчанию - False. &lt;code&gt;np.in1d(a, b, invert=True)&lt;/code&gt; эквивалентен (но быстрее) &lt;code&gt;np.invert(in1d(a, b))&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="259b3152dca6c438bfe50af972160ce0a4a1de26" translate="yes" xml:space="preserve">
          <source>If True, the values in the returned array are inverted, as if calculating &lt;code&gt;element not in test_elements&lt;/code&gt;. Default is False. &lt;code&gt;np.isin(a, b, invert=True)&lt;/code&gt; is equivalent to (but faster than) &lt;code&gt;np.invert(np.isin(a, b))&lt;/code&gt;.</source>
          <target state="translated">Если True, значения в возвращаемом массиве инвертируются, как будто вычисляемый &lt;code&gt;element not in test_elements&lt;/code&gt; . По умолчанию - False. &lt;code&gt;np.isin(a, b, invert=True)&lt;/code&gt; эквивалентен (но быстрее) &lt;code&gt;np.invert(np.isin(a, b))&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="945e8f6a0cee215b87f641fdb7d3287ee26a3bd1" translate="yes" xml:space="preserve">
          <source>If True, then allow the input array &lt;code&gt;a&lt;/code&gt; to be modified by intermediate calculations, to save memory. In this case, the contents of the input &lt;code&gt;a&lt;/code&gt; after this function completes is undefined.</source>
          <target state="translated">Если True, то разрешить изменение входного массива &lt;code&gt;a&lt;/code&gt; с помощью промежуточных вычислений для экономии памяти. В этом случае содержимое ввода &lt;code&gt;a&lt;/code&gt; после завершения этой функции не определено.</target>
        </trans-unit>
        <trans-unit id="efffbf4abfcfd3dab70b2b5adf8fd6ea45c7060a" translate="yes" xml:space="preserve">
          <source>If True, then allow use of memory of input array (a) for calculations. The input array will be modified by the call to median. This will save memory when you do not need to preserve the contents of the input array. Treat the input as undefined, but it will probably be fully or partially sorted. Default is False. Note that, if &lt;code&gt;overwrite_input&lt;/code&gt; is True, and the input is not already an &lt;code&gt;ndarray&lt;/code&gt;, an error will be raised.</source>
          <target state="translated">Если True, то разрешить использование памяти входного массива (a) для вычислений. Входной массив будет изменен вызовом median. Это сэкономит память, когда вам не нужно сохранять содержимое входного массива. Считайте ввод неопределенным, но он, вероятно, будет полностью или частично отсортирован. По умолчанию - False. Обратите внимание: если &lt;code&gt;overwrite_input&lt;/code&gt; имеет значение True, а вход еще не является &lt;code&gt;ndarray&lt;/code&gt; , возникнет ошибка.</target>
        </trans-unit>
        <trans-unit id="453475060bdf9f6ca07ca2a9d367c0c72b7c7341" translate="yes" xml:space="preserve">
          <source>If True, then allow use of memory of input array &lt;code&gt;a&lt;/code&gt; for calculations. The input array will be modified by the call to &lt;a href=&quot;#numpy.median&quot;&gt;&lt;code&gt;median&lt;/code&gt;&lt;/a&gt;. This will save memory when you do not need to preserve the contents of the input array. Treat the input as undefined, but it will probably be fully or partially sorted. Default is False. If &lt;code&gt;overwrite_input&lt;/code&gt; is &lt;code&gt;True&lt;/code&gt; and &lt;code&gt;a&lt;/code&gt; is not already an &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt;, an error will be raised.</source>
          <target state="translated">Если True, то разрешить использование памяти входного массива &lt;code&gt;a&lt;/code&gt; для вычислений. Входной массив будет изменен вызовом &lt;a href=&quot;#numpy.median&quot;&gt; &lt;code&gt;median&lt;/code&gt; &lt;/a&gt; . Это сэкономит память, когда вам не нужно сохранять содержимое входного массива. Считайте ввод неопределенным, но он, вероятно, будет полностью или частично отсортирован. По умолчанию - False. Если &lt;code&gt;overwrite_input&lt;/code&gt; имеет значение &lt;code&gt;True&lt;/code&gt; , а &lt;code&gt;a&lt;/code&gt; еще не является &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt; , возникнет ошибка.</target>
        </trans-unit>
        <trans-unit id="bf48ed6030d0efc488f7b3086097c6ad325b803d" translate="yes" xml:space="preserve">
          <source>If True, then allow use of memory of input array &lt;code&gt;a&lt;/code&gt; for calculations. The input array will be modified by the call to &lt;a href=&quot;numpy.median#numpy.median&quot;&gt;&lt;code&gt;median&lt;/code&gt;&lt;/a&gt;. This will save memory when you do not need to preserve the contents of the input array. Treat the input as undefined, but it will probably be fully or partially sorted. Default is False. If &lt;code&gt;overwrite_input&lt;/code&gt; is &lt;code&gt;True&lt;/code&gt; and &lt;code&gt;a&lt;/code&gt; is not already an &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt;, an error will be raised.</source>
          <target state="translated">Если True, то разрешить использование памяти входного массива &lt;code&gt;a&lt;/code&gt; для вычислений. Входной массив будет изменен вызовом &lt;a href=&quot;numpy.median#numpy.median&quot;&gt; &lt;code&gt;median&lt;/code&gt; &lt;/a&gt; . Это сэкономит память, когда вам не нужно сохранять содержимое входного массива. Считайте ввод неопределенным, но он, вероятно, будет полностью или частично отсортирован. По умолчанию - False. Если &lt;code&gt;overwrite_input&lt;/code&gt; имеет значение &lt;code&gt;True&lt;/code&gt; , а &lt;code&gt;a&lt;/code&gt; еще не является &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt; , возникнет ошибка.</target>
        </trans-unit>
        <trans-unit id="727bb21e15aa63ae35b6dc8fc80a632c45207cf3" translate="yes" xml:space="preserve">
          <source>If True, then sub-classes will be passed-through (default), otherwise the returned array will be forced to be a base-class array.</source>
          <target state="translated">Если переменная имеет значение True,то подклассы будут проходить через (по умолчанию),в противном случае возвращаемый массив будет вынужден быть массивом базового класса.</target>
        </trans-unit>
        <trans-unit id="4ceb06545ceed82d0fd2c4e74fddc1a8387d729b" translate="yes" xml:space="preserve">
          <source>If True, then sub-classes will be passed-through, otherwise the returned array will be forced to be a base-class array (default).</source>
          <target state="translated">Если значение True,то будут проходить подклассы,в противном случае возвращаемый массив будет вынужден быть массивом базового класса (по умолчанию).</target>
        </trans-unit>
        <trans-unit id="7931866e33bf18d405c7c9da5047f41db3dc88c3" translate="yes" xml:space="preserve">
          <source>If True, then sub-classes will be passed-through, otherwise the returned array will be forced to be a base-class array (defaults to False).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9752fe228ae3462d649576fdb0cd4757647ae348" translate="yes" xml:space="preserve">
          <source>If True, then sub-classes will be passed-through, otherwise the returned arrays will be forced to be a base-class array (default).</source>
          <target state="translated">Если параметр True,то будут проходить подклассы,в противном случае возвращаемые массивы будут вынуждены быть массивами базового класса (по умолчанию).</target>
        </trans-unit>
        <trans-unit id="066838f1ffe5aa12c7d71f9b1de32afdb88ee10e" translate="yes" xml:space="preserve">
          <source>If True, then the newly created array will use the sub-class type of &amp;lsquo;a&amp;rsquo;, otherwise it will be a base-class array. Defaults to True.</source>
          <target state="translated">Если True, то вновь созданный массив будет использовать тип подкласса 'a', в противном случае это будет массив базового класса. По умолчанию True.</target>
        </trans-unit>
        <trans-unit id="9ba9655ceab858d8e0fbfbe35222ace33db08fb2" translate="yes" xml:space="preserve">
          <source>If [array, array], the bin edges in each dimension (x_edges, y_edges = bins).</source>
          <target state="translated">Если [массив,массив],то рёбра бина в каждом измерении (x_края,y_края=бины).</target>
        </trans-unit>
        <trans-unit id="74d7f2b29106e8ca088ed3ddc192d60c869742ea" translate="yes" xml:space="preserve">
          <source>If [int, int], the number of bins in each dimension (nx, ny = bins).</source>
          <target state="translated">Если [int,int],то количество бинов в каждом измерении (nx,ny=бины).</target>
        </trans-unit>
        <trans-unit id="63952cde8568ab7ec41b2ac80ecf7fdc353a6855" translate="yes" xml:space="preserve">
          <source>If __svn_version__.py existed before, nothing is done.</source>
          <target state="translated">Если __svn_version_.py существовала раньше,то ничего не делается.</target>
        </trans-unit>
        <trans-unit id="2973727add43998ece2695a952786574b37deff8" translate="yes" xml:space="preserve">
          <source>If a &amp;lt; 1.</source>
          <target state="translated">Если &amp;lt;1.</target>
        </trans-unit>
        <trans-unit id="d6288450796b9bb41fb24a4a3b5f478c44715bdc" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;python module&lt;/code&gt; block contains two or more &lt;code&gt;common&lt;/code&gt; blocks with the same name, the variables from the additional declarations are appended. The types of variables in &lt;code&gt;&amp;lt;shortentitydecl&amp;gt;&lt;/code&gt; are defined using &lt;code&gt;&amp;lt;argument type declarations&amp;gt;&lt;/code&gt;. Note that the corresponding &lt;code&gt;&amp;lt;argument type declarations&amp;gt;&lt;/code&gt; may contain array specifications; then you don&amp;rsquo;t need to specify these in &lt;code&gt;&amp;lt;shortentitydecl&amp;gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="949f92ee120b49054523e5f48bcc0be73d87cf4a" translate="yes" xml:space="preserve">
          <source>If a Council member becomes inactive in the project for a period of one year, they will be considered for removal from the Council. Before removal, inactive Member will be approached to see if they plan on returning to active participation. If not they will be removed immediately upon a Council vote. If they plan on returning to active participation soon, they will be given a grace period of one year. If they don&amp;rsquo;t return to active participation within that time period they will be removed by vote of the Council without further grace period. All former Council members can be considered for membership again at any time in the future, like any other Project Contributor. Retired Council members will be listed on the project website, acknowledging the period during which they were active in the Council.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f5ac51d599581ab3e8a496c55fdc29ce07640e8" translate="yes" xml:space="preserve">
          <source>If a F2PY generated wrapper function expects the following call-back argument:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c5279f6f16ca5cb6814a2ac00854340dc9cd2fbb" translate="yes" xml:space="preserve">
          <source>If a class (ndarray subclass or not) having the &lt;a href=&quot;#numpy.class.__array__&quot;&gt;&lt;code&gt;__array__&lt;/code&gt;&lt;/a&gt; method is used as the output object of an &lt;a href=&quot;ufuncs#ufuncs-output-type&quot;&gt;ufunc&lt;/a&gt;, results will be written to the object returned by &lt;a href=&quot;#numpy.class.__array__&quot;&gt;&lt;code&gt;__array__&lt;/code&gt;&lt;/a&gt;. Similar conversion is done on input arrays.</source>
          <target state="translated">Если класс (подкласс ndarray или нет), имеющий метод &lt;a href=&quot;#numpy.class.__array__&quot;&gt; &lt;code&gt;__array__&lt;/code&gt; ,&lt;/a&gt; используется как выходной объект &lt;a href=&quot;ufuncs#ufuncs-output-type&quot;&gt;ufunc&lt;/a&gt; , результаты будут записаны в объект, возвращаемый &lt;a href=&quot;#numpy.class.__array__&quot;&gt; &lt;code&gt;__array__&lt;/code&gt; &lt;/a&gt; . Аналогичное преобразование выполняется для входных массивов.</target>
        </trans-unit>
        <trans-unit id="874568bcf37ebe0e2a8a8d54069b92c02f85f23a" translate="yes" xml:space="preserve">
          <source>If a class defines the &lt;a href=&quot;#numpy.class.__array_ufunc__&quot;&gt;&lt;code&gt;__array_ufunc__&lt;/code&gt;&lt;/a&gt; method, this disables the &lt;a href=&quot;#numpy.class.__array_wrap__&quot;&gt;&lt;code&gt;__array_wrap__&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#numpy.class.__array_prepare__&quot;&gt;&lt;code&gt;__array_prepare__&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#numpy.class.__array_priority__&quot;&gt;&lt;code&gt;__array_priority__&lt;/code&gt;&lt;/a&gt; mechanism described below for ufuncs (which may eventually be deprecated).</source>
          <target state="translated">Если класс определяет метод &lt;a href=&quot;#numpy.class.__array_ufunc__&quot;&gt; &lt;code&gt;__array_ufunc__&lt;/code&gt; &lt;/a&gt; , это отключает &lt;a href=&quot;#numpy.class.__array_wrap__&quot;&gt; &lt;code&gt;__array_wrap__&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#numpy.class.__array_prepare__&quot;&gt; &lt;code&gt;__array_prepare__&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#numpy.class.__array_priority__&quot;&gt; &lt;code&gt;__array_priority__&lt;/code&gt; &lt;/a&gt; , описанный ниже для ufuncs (который в конечном итоге может быть устаревшим).</target>
        </trans-unit>
        <trans-unit id="0577aaede06ac434e631d772788e0f369a956f02" translate="yes" xml:space="preserve">
          <source>If a compile-time fixed buffer is being used (both flags &lt;a href=&quot;#c.NPY_ITER_BUFFERED&quot;&gt;&lt;code&gt;NPY_ITER_BUFFERED&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#c.NPY_ITER_EXTERNAL_LOOP&quot;&gt;&lt;code&gt;NPY_ITER_EXTERNAL_LOOP&lt;/code&gt;&lt;/a&gt;), the inner size may be used as a signal as well. The size is guaranteed to become zero when &lt;code&gt;iternext()&lt;/code&gt; returns false, enabling the following loop construct. Note that if you use this construct, you should not pass &lt;a href=&quot;#c.NPY_ITER_GROWINNER&quot;&gt;&lt;code&gt;NPY_ITER_GROWINNER&lt;/code&gt;&lt;/a&gt; as a flag, because it will cause larger sizes under some circumstances.</source>
          <target state="translated">Если используется фиксированный буфер времени компиляции (оба флага &lt;a href=&quot;#c.NPY_ITER_BUFFERED&quot;&gt; &lt;code&gt;NPY_ITER_BUFFERED&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;#c.NPY_ITER_EXTERNAL_LOOP&quot;&gt; &lt;code&gt;NPY_ITER_EXTERNAL_LOOP&lt;/code&gt; &lt;/a&gt; ), внутренний размер также может использоваться как сигнал. Размер гарантированно станет нулевым, когда &lt;code&gt;iternext()&lt;/code&gt; вернет false, что позволяет использовать следующую конструкцию цикла. Обратите внимание: если вы используете эту конструкцию, вы не должны передавать &lt;a href=&quot;#c.NPY_ITER_GROWINNER&quot;&gt; &lt;code&gt;NPY_ITER_GROWINNER&lt;/code&gt; &lt;/a&gt; в качестве флага, потому что при некоторых обстоятельствах это приведет к увеличению размеров.</target>
        </trans-unit>
        <trans-unit id="9d666b71ab2db0f6cb052dc4a309c02e840cf132" translate="yes" xml:space="preserve">
          <source>If a dimension is given as -1 in a reshaping operation, the other dimensions are automatically calculated:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="769025cc778c9102b36d6a70ef7aed0a8fe51c05" translate="yes" xml:space="preserve">
          <source>If a field name in the required_dtype does not exist in the input array, that field is created and set to 0 in the output array.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a3ce99d9611a27292277b44f279f72466bca938" translate="yes" xml:space="preserve">
          <source>If a field whose dtype object has this attribute is retrieved, then the extra dimensions implied by &lt;em&gt;shape&lt;/em&gt; are tacked on to the end of the retrieved array.</source>
          <target state="translated">Если поле, DTYPE объект имеет этот атрибут извлекается, то дополнительные размеры подразумеваемых &lt;em&gt;форм&lt;/em&gt; являются пристегивается к концу возвращенного массива.</target>
        </trans-unit>
        <trans-unit id="aa639d13854427042e288c4d7a227d11cd8e9453" translate="yes" xml:space="preserve">
          <source>If a file &lt;code&gt;&amp;lt;filename&amp;gt;&lt;/code&gt; does not exist, the &lt;code&gt;include&lt;/code&gt; statement is ignored. Otherwise, the file &lt;code&gt;&amp;lt;filename&amp;gt;&lt;/code&gt; is included to a signature file. &lt;code&gt;include&lt;/code&gt; statements can be used in any part of a signature file, also outside the Fortran/C routine signature blocks.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="24439780a6864c35956999c18798d43f08d60388" translate="yes" xml:space="preserve">
          <source>If a formatter is specified for a certain type, the &lt;code&gt;precision&lt;/code&gt; keyword is ignored for that type.</source>
          <target state="translated">Если для определенного типа указано средство форматирования, ключевое слово &lt;code&gt;precision&lt;/code&gt; игнорируется для этого типа.</target>
        </trans-unit>
        <trans-unit id="687f359e5176c0f016578fb6a4154929ee305cd5" translate="yes" xml:space="preserve">
          <source>If a given array does not satisfy the specified restrictions.</source>
          <target state="translated">Если заданный массив не удовлетворяет указанным ограничениям.</target>
        </trans-unit>
        <trans-unit id="0f9748bf845ac9d150692dd01c4e3cac7093889e" translate="yes" xml:space="preserve">
          <source>If a is a matrix object, then the return value is a matrix as well:</source>
          <target state="translated">Если a-это объект матрицы,то возвращаемое значение также является матрицей:</target>
        </trans-unit>
        <trans-unit id="8ca1d1baf4aebfbd38dd688686cce7228cb6bc88" translate="yes" xml:space="preserve">
          <source>If a is an int and less than zero, if a or p are not 1-dimensional, if a is an array-like of size 0, if p is not a vector of probabilities, if a and p have different lengths, or if replace=False and the sample size is greater than the population size</source>
          <target state="translated">Если a является int и меньше нуля,если a или p не являются одномерными,если a является массивом размера 0,если p не является вектором вероятностей,если a и p имеют разную длину,или если replace=False и размер выборки больше,чем размер популяции</target>
        </trans-unit>
        <trans-unit id="45d749c722fde2f54ef7349c75a2d911b0caf469" translate="yes" xml:space="preserve">
          <source>If a is an int and less than zero, if p is not 1-dimensional, if a is array-like with a size 0, if p is not a vector of probabilities, if a and p have different lengths, or if replace=False and the sample size is greater than the population size.</source>
          <target state="translated">Если a является int и меньше нуля,если p не является 1-мерным,если a является массивом с размером 0,если p не является вектором вероятностей,если a и p имеют разную длину,или если replace=False и размер выборки больше,чем размер популяции.</target>
        </trans-unit>
        <trans-unit id="6a821a28e324f16f0f4bf4708058f9a3d079d082" translate="yes" xml:space="preserve">
          <source>If a list of strings, each string should represent a dtype. If array_like, the character representation of the array dtype is used.</source>
          <target state="translated">Если список строк,то каждая строка должна представлять собой dtype.Если array_like,то используется символьное представление типа массива d.</target>
        </trans-unit>
        <trans-unit id="f0978a6e619ec2d43693907e27d2eb435814d97e" translate="yes" xml:space="preserve">
          <source>If a report doesn&amp;rsquo;t contain enough information, the committee will obtain all relevant data before acting. The committee is empowered to act on the Steering Council&amp;rsquo;s behalf in contacting any individuals involved to get a more complete account of events.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="63795a6ab48fcba94623b51f8a7753fc963d4b8e" translate="yes" xml:space="preserve">
          <source>If a scalar dtype, the corresponding string character is returned. If an object, &lt;a href=&quot;#numpy.sctype2char&quot;&gt;&lt;code&gt;sctype2char&lt;/code&gt;&lt;/a&gt; tries to infer its scalar type and then return the corresponding string character.</source>
          <target state="translated">Если скалярный dtype, возвращается соответствующий строковый символ. Если объект, &lt;a href=&quot;#numpy.sctype2char&quot;&gt; &lt;code&gt;sctype2char&lt;/code&gt; &lt;/a&gt; пытается вывести его скалярный тип, а затем вернуть соответствующий строковый символ.</target>
        </trans-unit>
        <trans-unit id="98a2233adc7ab93848107f159b490659bfa27e57" translate="yes" xml:space="preserve">
          <source>If a scalar value is passed in.</source>
          <target state="translated">Если передается скалярное значение.</target>
        </trans-unit>
        <trans-unit id="15bc103dab402117d3913395fb8b40bbeeb0b897" translate="yes" xml:space="preserve">
          <source>If a second argument is supplied the result is stored there. If the type of that array is a numeric type the result is represented as zeros and ones, if the type is boolean then as False and True. The return value &lt;code&gt;out&lt;/code&gt; is then a reference to that array.</source>
          <target state="translated">Если указан второй аргумент, результат сохраняется там. Если тип этого массива - числовой тип, результат представлен как нули и единицы, если тип логический, то как False и True. Возвращаемое значение &lt;code&gt;out&lt;/code&gt; затем ссылка на этот массив.</target>
        </trans-unit>
        <trans-unit id="342304e655e812ee2a83e5789793e22172924b42" translate="yes" xml:space="preserve">
          <source>If a second argument is supplied the result is stored there. The return value &lt;code&gt;out&lt;/code&gt; is then a reference to that array.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ceb1ddfcab0f3cbec5d42431c301b1cc28fccf65" translate="yes" xml:space="preserve">
          <source>If a zero dimensional array is present in the index &lt;em&gt;and&lt;/em&gt; it is a full integer index the result will be a &lt;em&gt;scalar&lt;/em&gt; and not a zero dimensional array. (Advanced indexing is not triggered.)</source>
          <target state="translated">Если в индексе присутствует нулевой массив, &lt;em&gt;и&lt;/em&gt; это полный целочисленный индекс, результатом будет &lt;em&gt;скаляр,&lt;/em&gt; а не нулевой массив. (Расширенное индексирование не запускается.)</target>
        </trans-unit>
        <trans-unit id="64c5c963ea9794eafa3b89f1dd216c6a8ebfd684" translate="yes" xml:space="preserve">
          <source>If actual and desired are not equal up to specified precision.</source>
          <target state="translated">Если фактические и желаемые не совпадают с заданной точностью.</target>
        </trans-unit>
        <trans-unit id="39bbb6143ab84f37b65c3d7880c2778b652d186d" translate="yes" xml:space="preserve">
          <source>If actual and desired are not equal.</source>
          <target state="translated">Если фактические и желаемые не равны.</target>
        </trans-unit>
        <trans-unit id="fcebdf6acdb7662938a429c761fa5ad9e5471b67" translate="yes" xml:space="preserve">
          <source>If actual and desired objects are not equal.</source>
          <target state="translated">Если фактические и желаемые объекты не совпадают.</target>
        </trans-unit>
        <trans-unit id="8aa394119b239dde7365c85e156833625438bfa9" translate="yes" xml:space="preserve">
          <source>If all &lt;code&gt;__array_function__&lt;/code&gt; methods return &lt;code&gt;NotImplemented&lt;/code&gt;, NumPy will raise &lt;code&gt;TypeError&lt;/code&gt;.</source>
          <target state="translated">Если все методы &lt;code&gt;__array_function__&lt;/code&gt; возвращают &lt;code&gt;NotImplemented&lt;/code&gt; , NumPy вызовет &lt;code&gt;TypeError&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="454ac4064cbf860208005757a60b81b3482b89cb" translate="yes" xml:space="preserve">
          <source>If all of the commits are related, create a merge commit:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="85985aaa1b2d2d353f8a23ec019a6f4085543d14" translate="yes" xml:space="preserve">
          <source>If all proposals for resolving some issue are vetoed, then the status quo wins by default.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eab8ea3dfbb5bbbb71e7908ef2deef22ffee42c7" translate="yes" xml:space="preserve">
          <source>If all the arrays are 1-D, &lt;a href=&quot;#numpy.where&quot;&gt;&lt;code&gt;where&lt;/code&gt;&lt;/a&gt; is equivalent to:</source>
          <target state="translated">Если все массивы 1-D, &lt;a href=&quot;#numpy.where&quot;&gt; &lt;code&gt;where&lt;/code&gt; &lt;/a&gt; эквивалентно:</target>
        </trans-unit>
        <trans-unit id="4680fc5e031229cdb3ef2e322dccd91736ba09de" translate="yes" xml:space="preserve">
          <source>If all values are masked, return None. Otherwise, return a list of two tuples, corresponding to the indices of the first and last unmasked values respectively.</source>
          <target state="translated">Если все значения замаскированы,верните Нет.В противном случае верните список из двух кортежей,соответствующих индексам первого и последнего размаскированных значений соответственно.</target>
        </trans-unit>
        <trans-unit id="517ad1e00b3a93fbecfebfae5c6590d4c6fe64a9" translate="yes" xml:space="preserve">
          <source>If an argument has no &lt;code&gt;&amp;lt;argument type declaration&amp;gt;&lt;/code&gt;, its type is determined by applying &lt;code&gt;implicit&lt;/code&gt; rules to its name.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a0b2100814d2bab89059c0f2bc3adff904ee9a6" translate="yes" xml:space="preserve">
          <source>If an array has a very small or very large determinant, then a call to &lt;a href=&quot;numpy.linalg.det#numpy.linalg.det&quot;&gt;&lt;code&gt;det&lt;/code&gt;&lt;/a&gt; may overflow or underflow. This routine is more robust against such issues, because it computes the logarithm of the determinant rather than the determinant itself.</source>
          <target state="translated">Если массив имеет очень маленький или очень большой определитель, то вызов &lt;a href=&quot;numpy.linalg.det#numpy.linalg.det&quot;&gt; &lt;code&gt;det&lt;/code&gt; &lt;/a&gt; может переполниться или опуститься. Эта процедура более устойчива к таким проблемам, поскольку вычисляет логарифм определителя, а не сам определитель.</target>
        </trans-unit>
        <trans-unit id="089dc283ee6bf525b9e1357cb2890636154add48" translate="yes" xml:space="preserve">
          <source>If an array has no elements (&lt;code&gt;self.size == 0&lt;/code&gt;) there is no legal index and the strides are never used. Any array with no elements may be considered C-style and Fortran-style contiguous.</source>
          <target state="translated">Если в массиве нет элементов ( &lt;code&gt;self.size == 0&lt;/code&gt; ), нет легального индекса и шаги никогда не используются. Любой массив без элементов может считаться смежным в стиле C и Fortran.</target>
        </trans-unit>
        <trans-unit id="c5c598efb3988281532c1be87569879df34d1935" translate="yes" xml:space="preserve">
          <source>If an array is created using a data-type describing a sub-array, the dimensions of the sub-array are appended to the shape of the array when the array is created. Sub-arrays in a field of a structured type behave differently, see &lt;a href=&quot;arrays.indexing#arrays-indexing-fields&quot;&gt;Field Access&lt;/a&gt;.</source>
          <target state="translated">Если массив создается с использованием типа данных, описывающего суб-массив, размеры суб-массива добавляются к форме массива при создании массива. Подмассивы в поле структурированного типа ведут себя по-разному, см. &lt;a href=&quot;arrays.indexing#arrays-indexing-fields&quot;&gt;Доступ к полю&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="bf36df6b09764d99c53b04e05c8fe53411949d03" translate="yes" xml:space="preserve">
          <source>If an array is created with this method, simply adding &amp;lsquo;itemsize&amp;rsquo; for each iteration will traverse the new array matching the iterator.</source>
          <target state="translated">Если массив создается с помощью этого метода, простое добавление &amp;laquo;itemsize&amp;raquo; для каждой итерации будет проходить по новому массиву, соответствующему итератору.</target>
        </trans-unit>
        <trans-unit id="1497d51c68c81f921994ed240661dbb7879d05a8" translate="yes" xml:space="preserve">
          <source>If an array is too large to be printed, NumPy automatically skips the central part of the array and only prints the corners:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5e8325ebccad64f5436323a863f272d5f091c76c" translate="yes" xml:space="preserve">
          <source>If an element of &lt;code&gt;axes&lt;/code&gt; is larger than than the number of axes of &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">Если элемент &lt;code&gt;axes&lt;/code&gt; больше, чем количество осей &lt;code&gt;a&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bc51d7d23e7dc12f32f8e1785a950a943342d4c8" translate="yes" xml:space="preserve">
          <source>If an index exceeds the dimension of the array along &lt;code&gt;axis&lt;/code&gt;, an empty sub-array is returned correspondingly.</source>
          <target state="translated">Если индекс превышает размер массива по &lt;code&gt;axis&lt;/code&gt; , соответственно возвращается пустой подмассив.</target>
        </trans-unit>
        <trans-unit id="d50315439445c5e53d7c5cb2eca5a37deb22722b" translate="yes" xml:space="preserve">
          <source>If an input has a dimension size of 1 in its shape, the first data entry in that dimension will be used for all calculations along that dimension. In other words, the stepping machinery of the &lt;a href=&quot;../glossary#term-ufunc&quot;&gt;ufunc&lt;/a&gt; will simply not step along that dimension (the &lt;a href=&quot;arrays.ndarray#memory-layout&quot;&gt;stride&lt;/a&gt; will be 0 for that dimension).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99fec5dbaf9a5723fb1db21784554641e2d086b8" translate="yes" xml:space="preserve">
          <source>If an input has a dimension size of 1 in its shape, the first data entry in that dimension will be used for all calculations along that dimension. In other words, the stepping machinery of the &lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/glossary.html#term-ufunc&quot;&gt;ufunc&lt;/a&gt; will simply not step along that dimension (the &lt;a href=&quot;arrays.ndarray#memory-layout&quot;&gt;stride&lt;/a&gt; will be 0 for that dimension).</source>
          <target state="translated">Если входные данные имеют размерный размер 1 в своей форме, первая запись данных в этом измерении будет использоваться для всех вычислений по этому измерению. Другими словами, шаговый механизм &lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/glossary.html#term-ufunc&quot;&gt;ufunc&lt;/a&gt; просто не будет шагать по этому измерению ( &lt;a href=&quot;arrays.ndarray#memory-layout&quot;&gt;шаг&lt;/a&gt; будет равен 0 для этого измерения).</target>
        </trans-unit>
        <trans-unit id="981216fcb80286728db3aa0467d4b1e8a655fef5" translate="yes" xml:space="preserve">
          <source>If an ndarray, a random sample is generated from its elements. If an int, the random sample is generated as if a were np.arange(a)</source>
          <target state="translated">Если андаррей,случайная выборка генерируется из его элементов.Если int,случайная выборка генерируется как np.arange(a).</target>
        </trans-unit>
        <trans-unit id="6bcff738f855376346fed2a54471feef4ca0479d" translate="yes" xml:space="preserve">
          <source>If an ndarray, a random sample is generated from its elements. If an int, the random sample is generated from np.arange(a).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b055403a11a75cdadf358d2e4b16e4aaac100a0a" translate="yes" xml:space="preserve">
          <source>If an object is provided, its write method should take one argument, a string.</source>
          <target state="translated">Если предоставляется объект,то его метод записи должен принимать один аргумент,строку.</target>
        </trans-unit>
        <trans-unit id="c6eb2fb826e8cbc6182574444dd579783c5b9225" translate="yes" xml:space="preserve">
          <source>If any input is array_like, &lt;code&gt;pv&lt;/code&gt; returns an array of equal shape. Let&amp;rsquo;s compare different interest rates in the example above:</source>
          <target state="translated">Если какой-либо ввод - array_like, &lt;code&gt;pv&lt;/code&gt; возвращает массив одинаковой формы. Давайте сравним разные процентные ставки в приведенном выше примере:</target>
        </trans-unit>
        <trans-unit id="ffa8ae9c8e4ca204b853aaf38ee0943c2276d1c9" translate="yes" xml:space="preserve">
          <source>If any input is array_like, returns an array of equal shape. Let&amp;rsquo;s compare different interest rates from the example above.</source>
          <target state="translated">Если какой-либо ввод - array_like, возвращает массив одинаковой формы. Давайте сравним разные процентные ставки из приведенного выше примера.</target>
        </trans-unit>
        <trans-unit id="dce7db3f12e1e92b36fcbe9af677f929557b423e" translate="yes" xml:space="preserve">
          <source>If any read/write overlap exists, this flag ensures the result of the operation is the same as if all operands were copied. In cases where copies would need to be made, &lt;strong&gt;the result of the computation may be undefined without this flag!&lt;/strong&gt;</source>
          <target state="translated">Если существует какое-либо перекрытие чтения / записи, этот флаг гарантирует, что результат операции будет таким же, как если бы все операнды были скопированы. В случаях, когда необходимо сделать копии, &lt;strong&gt;результат вычисления может быть неопределенным без этого флага!&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="3e0c40f81e19502941982ef1a412a173673233b4" translate="yes" xml:space="preserve">
          <source>If any value in &lt;code&gt;alpha&lt;/code&gt; is less than or equal to zero</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a8f0d595ba6a3701f0ba4d0bf45fa3cd44ca9ce" translate="yes" xml:space="preserve">
          <source>If any value in alpha is less than or equal to zero</source>
          <target state="translated">Если любое значение в альфа-альфе меньше или равно нулю.</target>
        </trans-unit>
        <trans-unit id="bc219d3a8300527c6efa92537ff8d0dcdb1108df" translate="yes" xml:space="preserve">
          <source>If any write operand has overlap with any read operand, eliminate all overlap by making temporary copies (enabling UPDATEIFCOPY for write operands, if necessary). A pair of operands has overlap if there is a memory address that contains data common to both arrays.</source>
          <target state="translated">Если любой операнд записи имеет перекрытие с любым операндом чтения,устраните все перекрытия,сделав временные копии (включите UPDATEIFCOPY для операндов записи,если необходимо).Пара операндов имеет наложение,если есть адрес памяти,который содержит данные,общие для обоих массивов.</target>
        </trans-unit>
        <trans-unit id="2a45557faccf378e4b524258e3744f14e01d0549" translate="yes" xml:space="preserve">
          <source>If argument consists exclusively of int dtypes.</source>
          <target state="translated">Если аргумент состоит исключительно из int dtypes.</target>
        </trans-unit>
        <trans-unit id="c785d849c18fc327cf9bee37bc11741d006f8fa7" translate="yes" xml:space="preserve">
          <source>If arguments are passed in with no keywords, the corresponding variable names, in the &lt;code&gt;.npz&lt;/code&gt; file, are &amp;lsquo;arr_0&amp;rsquo;, &amp;lsquo;arr_1&amp;rsquo;, etc. If keyword arguments are given, the corresponding variable names, in the &lt;code&gt;.npz&lt;/code&gt; file will match the keyword names.</source>
          <target state="translated">Если аргументы передаются без ключевых слов, соответствующие имена переменных в файле &lt;code&gt;.npz&lt;/code&gt; будут 'arr_0', 'arr_1' и т. Д. Если указаны аргументы ключевых слов, соответствующие имена переменных в файле &lt;code&gt;.npz&lt;/code&gt; будут соответствовать имена ключевых слов.</target>
        </trans-unit>
        <trans-unit id="3d1c7a0f1e977aad5bcdfcdc2989a2f748b0274f" translate="yes" xml:space="preserve">
          <source>If array_like, the bin edges for the two dimensions (x_edges=y_edges=bins).</source>
          <target state="translated">Если array_like,то рёбра бина для двух измерений (x_edges=y_edges=bins).</target>
        </trans-unit>
        <trans-unit id="8ad413f7fc8dfff3a6c2ee36c2613993e6279848" translate="yes" xml:space="preserve">
          <source>If at least one of &lt;code&gt;a&lt;/code&gt; or &lt;code&gt;b&lt;/code&gt; is a non-string array</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b3c56f840baa3a689fec388e92d6ba86ff952aa7" translate="yes" xml:space="preserve">
          <source>If at some point an existing Institutional Partner stops having any contributing employees, then a one year grace period commences. If at the end of this one year period they continue not to have any contributing employees, then their Institutional Partnership will lapse, and resuming it will require going through the normal process for new Partnerships.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a90d0b3d22bdc0f93b285a7398aa4703fe73214" translate="yes" xml:space="preserve">
          <source>If axis is 0, only rows are suppressed.</source>
          <target state="translated">Если ось равна 0,то подавляются только ряды.</target>
        </trans-unit>
        <trans-unit id="0782bc28993b5f00e72a0af1dcec69356d31839c" translate="yes" xml:space="preserve">
          <source>If axis is 1 or -1, only columns are suppressed.</source>
          <target state="translated">Если ось 1 или -1,то подавляются только столбцы.</target>
        </trans-unit>
        <trans-unit id="9506a7c18a807c059cd952ed93d5c51207a2a07d" translate="yes" xml:space="preserve">
          <source>If axis is None, both rows and columns are suppressed.</source>
          <target state="translated">Если ось Нет,то обе строки и столбцы подавляются.</target>
        </trans-unit>
        <trans-unit id="c5149a1f08013bd4c50d9514785f4f44208d1f0b" translate="yes" xml:space="preserve">
          <source>If axis is a tuple of ints, a product is performed on all of the axes specified in the tuple instead of a single axis or all the axes as before.</source>
          <target state="translated">Если ось является кортежом из интв,то вместо одной оси или всех осей,как и прежде,выполняется произведение по всем осям,указанным в кортеже.</target>
        </trans-unit>
        <trans-unit id="8de953aea1cde5c7cd7a932c7c1cd638dd5b48f8" translate="yes" xml:space="preserve">
          <source>If axis is a tuple of ints, a sum is performed on all of the axes specified in the tuple instead of a single axis or all the axes as before.</source>
          <target state="translated">Если ось является кортежом из буквенных индексов,то вместо одной оси или всех осей,как и прежде,выполняется сумма по всем осям,указанным в кортеже.</target>
        </trans-unit>
        <trans-unit id="b7d9ad0b67d074ec073be5ef4e15eeecb68acdae" translate="yes" xml:space="preserve">
          <source>If axis is a tuple of ints, averaging is performed on all of the axes specified in the tuple instead of a single axis or all the axes as before.</source>
          <target state="translated">Если ось-кортеж из интов,то усреднение выполняется по всем осям,указанным в кортеже,а не по одной оси или по всем осям,как раньше.</target>
        </trans-unit>
        <trans-unit id="288d1e6c0a612db41ca8d2410d35c52a79ba7795" translate="yes" xml:space="preserve">
          <source>If axis is a tuple of ints, flipping is performed on all of the axes specified in the tuple.</source>
          <target state="translated">Если ось является кортежом из буквенных дюймов,то перевертывание выполняется по всем указанным в кортеже осям.</target>
        </trans-unit>
        <trans-unit id="4a67a427d1a7cbcfc229fb55b05bdd5b239d1bd3" translate="yes" xml:space="preserve">
          <source>If both &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; are 1-D arrays, it is inner product of vectors (without complex conjugation).</source>
          <target state="translated">Если и &lt;code&gt;a&lt;/code&gt; , и &lt;code&gt;b&lt;/code&gt; являются одномерными массивами, это внутреннее произведение векторов (без комплексного сопряжения).</target>
        </trans-unit>
        <trans-unit id="c28be53ff292bd7a51506b92f27ed7a94fd2ec15" translate="yes" xml:space="preserve">
          <source>If both &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; are 2-D arrays, it is matrix multiplication, but using &lt;a href=&quot;numpy.matmul#numpy.matmul&quot;&gt;&lt;code&gt;matmul&lt;/code&gt;&lt;/a&gt; or &lt;code&gt;a @ b&lt;/code&gt; is preferred.</source>
          <target state="translated">Если и &lt;code&gt;a&lt;/code&gt; , и &lt;code&gt;b&lt;/code&gt; являются двумерными массивами, это умножение матриц, но использование &lt;a href=&quot;numpy.matmul#numpy.matmul&quot;&gt; &lt;code&gt;matmul&lt;/code&gt; &lt;/a&gt; или &lt;code&gt;a @ b&lt;/code&gt; предпочтительнее.</target>
        </trans-unit>
        <trans-unit id="194f3cee9e7df2b602bf5ba80d6118fb502e2eaf" translate="yes" xml:space="preserve">
          <source>If both &lt;code&gt;formats&lt;/code&gt; and &lt;code&gt;dtype&lt;/code&gt; are None, then this will auto-detect formats. Use list of tuples rather than list of lists for faster processing.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="368fd1e825cc7f1439018ab086e3ca74379697e1" translate="yes" xml:space="preserve">
          <source>If both &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; are &lt;code&gt;NULL&lt;/code&gt;, then return &lt;a href=&quot;#c.PyArray_Nonzero&quot;&gt;&lt;code&gt;PyArray_Nonzero&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;condition&lt;/em&gt;). Otherwise, both &lt;em&gt;x&lt;/em&gt; and &lt;em&gt;y&lt;/em&gt; must be given and the object returned is shaped like &lt;em&gt;condition&lt;/em&gt; and has elements of &lt;em&gt;x&lt;/em&gt; and &lt;em&gt;y&lt;/em&gt; where &lt;em&gt;condition&lt;/em&gt; is respectively True or False.</source>
          <target state="translated">Если и &lt;code&gt;x&lt;/code&gt; , и &lt;code&gt;y&lt;/code&gt; равны &lt;code&gt;NULL&lt;/code&gt; , вернуть &lt;a href=&quot;#c.PyArray_Nonzero&quot;&gt; &lt;code&gt;PyArray_Nonzero&lt;/code&gt; &lt;/a&gt; ( &lt;em&gt;условие&lt;/em&gt; ). В противном случае должны быть указаны как &lt;em&gt;x, так&lt;/em&gt; и &lt;em&gt;y&lt;/em&gt; , а возвращаемый объект имеет форму &lt;em&gt;condition&lt;/em&gt; и имеет элементы &lt;em&gt;x&lt;/em&gt; и &lt;em&gt;y,&lt;/em&gt; где &lt;em&gt;condition&lt;/em&gt; соответственно True или False.</target>
        </trans-unit>
        <trans-unit id="7d34c61041bcc07e55093729fc859031c36d6999" translate="yes" xml:space="preserve">
          <source>If both arguments are 2-D they are multiplied like conventional matrices.</source>
          <target state="translated">Если оба аргумента 2-D,то они умножаются как обычные матрицы.</target>
        </trans-unit>
        <trans-unit id="bf26496158ed7aff00fe3f64e66aa6a508289463" translate="yes" xml:space="preserve">
          <source>If both positive and negative infinity are present, the sum will be Not A Number (NaN).</source>
          <target state="translated">Если присутствует и положительная,и отрицательная бесконечность,то сумма будет не A Number (NaN).</target>
        </trans-unit>
        <trans-unit id="c6be65ffe7d2b7c519b021c7a585a65d749c5cc8" translate="yes" xml:space="preserve">
          <source>If both the name and type are specified, the &lt;strong&gt;Returns&lt;/strong&gt; section takes the same form as the &lt;strong&gt;Parameters&lt;/strong&gt; section:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="10140359cb73a0890a92d9b94e958a4d9feb7bea" translate="yes" xml:space="preserve">
          <source>If both the name and type are specified, the &lt;strong&gt;Yields&lt;/strong&gt; section takes the same form as the &lt;strong&gt;Returns&lt;/strong&gt; section:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d89fb74ad22e53fe87d261e5d40a2d4a0331e92" translate="yes" xml:space="preserve">
          <source>If called with all arguments other than the warning class omitted, may be used as a context manager:</source>
          <target state="translated">При вызове со всеми аргументами,кроме пропущенных классов предупреждений,может быть использован в качестве контекстного менеджера:</target>
        </trans-unit>
        <trans-unit id="e1f9fb2b578de1420ef1d4182da3c75ca58e3552" translate="yes" xml:space="preserve">
          <source>If complex input returns a real array if complex parts are close to zero.</source>
          <target state="translated">Если сложный вход возвращает реальный массив,если сложные части близки к нулю.</target>
        </trans-unit>
        <trans-unit id="4ec7acf826794e4e37207136e102eb50e7632b5f" translate="yes" xml:space="preserve">
          <source>If computation does not converge.</source>
          <target state="translated">Если вычисления не сходятся.</target>
        </trans-unit>
        <trans-unit id="66501fc9abcadb23835ebb60ef928268453bb410" translate="yes" xml:space="preserve">
          <source>If condition is a &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray&quot;&gt;&lt;code&gt;MaskedArray&lt;/code&gt;&lt;/a&gt;, missing values are considered as &lt;code&gt;False&lt;/code&gt;.</source>
          <target state="translated">Если условием является &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray&quot;&gt; &lt;code&gt;MaskedArray&lt;/code&gt; &lt;/a&gt; , отсутствующие значения считаются &lt;code&gt;False&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9bd71f3d3293e73ba78bbdd8102f9b41323ceaaa" translate="yes" xml:space="preserve">
          <source>If copy is False and one of the inputs is &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.nomask&quot;&gt;&lt;code&gt;nomask&lt;/code&gt;&lt;/a&gt;, return a view of the other input mask. Defaults to False.</source>
          <target state="translated">Если copy имеет значение False и один из входов - &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.nomask&quot;&gt; &lt;code&gt;nomask&lt;/code&gt; &lt;/a&gt; , вернуть представление другой маски ввода. По умолчанию False.</target>
        </trans-unit>
        <trans-unit id="6d1cb15d43c2ba3971e5b54fc0a9bc261de3fb39" translate="yes" xml:space="preserve">
          <source>If data is passed to &lt;a href=&quot;#c.PyArray_NewFromDescr&quot;&gt;&lt;code&gt;PyArray_NewFromDescr&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#c.PyArray_New&quot;&gt;&lt;code&gt;PyArray_New&lt;/code&gt;&lt;/a&gt;, this memory must not be deallocated until the new array is deleted. If this data came from another Python object, this can be accomplished using &lt;a href=&quot;https://docs.python.org/dev/c-api/refcounting.html#c.Py_INCREF&quot;&gt;&lt;code&gt;Py_INCREF&lt;/code&gt;&lt;/a&gt; on that object and setting the base member of the new array to point to that object. If strides are passed in they must be consistent with the dimensions, the itemsize, and the data of the array.</source>
          <target state="translated">Если данные передаются в &lt;a href=&quot;#c.PyArray_NewFromDescr&quot;&gt; &lt;code&gt;PyArray_NewFromDescr&lt;/code&gt; &lt;/a&gt; или &lt;a href=&quot;#c.PyArray_New&quot;&gt; &lt;code&gt;PyArray_New&lt;/code&gt; &lt;/a&gt; , эту память нельзя освобождать, пока не будет удален новый массив. Если эти данные поступили из другого объекта Python, это можно сделать с помощью &lt;a href=&quot;https://docs.python.org/dev/c-api/refcounting.html#c.Py_INCREF&quot;&gt; &lt;code&gt;Py_INCREF&lt;/code&gt; &lt;/a&gt; для этого объекта и установки базового члена нового массива, указывающего на этот объект. Если передаются шаги, они должны соответствовать размерам, размеру элементов и данным массива.</target>
        </trans-unit>
        <trans-unit id="8cd71bec9bf23486f57ed709deb2da7e823cdd37" translate="yes" xml:space="preserve">
          <source>If defined, the axis of &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;b&lt;/code&gt; and &lt;code&gt;c&lt;/code&gt; that defines the vector(s) and cross product(s). Overrides &lt;code&gt;axisa&lt;/code&gt;, &lt;code&gt;axisb&lt;/code&gt; and &lt;code&gt;axisc&lt;/code&gt;.</source>
          <target state="translated">Если определено, оси &lt;code&gt;a&lt;/code&gt; , &lt;code&gt;b&lt;/code&gt; и &lt;code&gt;c&lt;/code&gt; , определяющие вектор (ы) и перекрестное произведение (я). Переопределяет &lt;code&gt;axisa&lt;/code&gt; , &lt;code&gt;axisb&lt;/code&gt; и &lt;code&gt;axisc&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="13711ea532b05dfaebf7f20551317865f1c997fe" translate="yes" xml:space="preserve">
          <source>If dtype is not supplied, this specifies the field names for the output dtype, in order. The field dtypes will be the same as the input array.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d0ca2bca36fd3ca611fb59e9f429be6ca1dfcef" translate="yes" xml:space="preserve">
          <source>If either &lt;code&gt;a&lt;/code&gt; or &lt;code&gt;b&lt;/code&gt; is 0-D (scalar), it is equivalent to &lt;a href=&quot;numpy.multiply#numpy.multiply&quot;&gt;&lt;code&gt;multiply&lt;/code&gt;&lt;/a&gt; and using &lt;code&gt;numpy.multiply(a, b)&lt;/code&gt; or &lt;code&gt;a * b&lt;/code&gt; is preferred.</source>
          <target state="translated">Если &lt;code&gt;a&lt;/code&gt; или &lt;code&gt;b&lt;/code&gt; равно 0-D (скаляр), это эквивалентно &lt;a href=&quot;numpy.multiply#numpy.multiply&quot;&gt; &lt;code&gt;multiply&lt;/code&gt; &lt;/a&gt; и использование &lt;code&gt;numpy.multiply(a, b)&lt;/code&gt; или &lt;code&gt;a * b&lt;/code&gt; является предпочтительным.</target>
        </trans-unit>
        <trans-unit id="849e7230439a12b395b3d9d948e074f889418b25" translate="yes" xml:space="preserve">
          <source>If either argument is N-D, N &amp;gt; 2, it is treated as a stack of matrices residing in the last two indexes and broadcast accordingly.</source>
          <target state="translated">Если любой из аргументов равен ND, N&amp;gt; 2, он обрабатывается как стек матриц, находящихся в последних двух индексах, и транслируется соответственно.</target>
        </trans-unit>
        <trans-unit id="cc8e18e241d0267fb4cce88d0332bc823b722b5a" translate="yes" xml:space="preserve">
          <source>If either array contains one or more NaNs, False is returned. Infs are treated as equal if they are in the same place and of the same sign in both arrays.</source>
          <target state="translated">Если любой из массивов содержит один или несколько NaN,возвращается False.Инфы считаются равными,если они находятся в одном и том же месте и имеют один и тот же знак в обоих массивах.</target>
        </trans-unit>
        <trans-unit id="281de8e5c6dae1e0aea9ae6d89d002bae88a2963" translate="yes" xml:space="preserve">
          <source>If element has complex type with zero complex part, the return value for that element is True.</source>
          <target state="translated">Если элемент имеет сложный тип с нулевой комплексной частью,возвращаемое значение для этого элемента равно True.</target>
        </trans-unit>
        <trans-unit id="5d17dff94d5eaef97820ea5c6ea029508947d3b9" translate="yes" xml:space="preserve">
          <source>If factoring fails.</source>
          <target state="translated">Если факторинг провалится.</target>
        </trans-unit>
        <trans-unit id="d31081e35606566d9542bf752ae043c7bb856921" translate="yes" xml:space="preserve">
          <source>If file is a string or a path-like object then that file is opened, else it is assumed to be a file object. The file object must support random access (i.e. it must have tell and seek methods).</source>
          <target state="translated">Если файл является строковым или похожим на патч-объект,то этот файл открывается,в противном случае предполагается,что он является файловым объектом.Файловый объект должен поддерживать случайный доступ (т.е.он должен иметь методы tell и seek).</target>
        </trans-unit>
        <trans-unit id="c92c0b980c98427841fd06fc2e90c17e3f8c8cf4" translate="yes" xml:space="preserve">
          <source>If filters are added and the &lt;code&gt;module&lt;/code&gt; keyword is given, the warning registry of this module will additionally be cleared when applying it, entering the context, or exiting it. This could cause warnings to appear a second time after leaving the context if they were configured to be printed once (default) and were already printed before the context was entered.</source>
          <target state="translated">Если фильтры добавлены и задано ключевое слово &lt;code&gt;module&lt;/code&gt; , реестр предупреждений этого модуля будет дополнительно очищен при его применении, входе в контекст или выходе из него. Это могло вызвать появление предупреждений во второй раз после выхода из контекста, если они были настроены на печать один раз (по умолчанию) и уже были напечатаны до входа в контекст.</target>
        </trans-unit>
        <trans-unit id="aa86a09a4bd6f04a9393e4d4dd4d45d0b7a047d8" translate="yes" xml:space="preserve">
          <source>If formats is None, then this will auto-detect formats. Use list of tuples rather than list of lists for faster processing.</source>
          <target state="translated">Если формат None,то это приведет к автоопределению форматов.Для более быстрой обработки используйте список кортежей,а не список списков.</target>
        </trans-unit>
        <trans-unit id="9c65522b5d0c56fc6284329915c9ff282e0a064e" translate="yes" xml:space="preserve">
          <source>If given and not &lt;code&gt;False&lt;/code&gt;, return not just the estimate but also its covariance matrix. By default, the covariance are scaled by chi2/sqrt(N-dof), i.e., the weights are presumed to be unreliable except in a relative sense and everything is scaled such that the reduced chi2 is unity. This scaling is omitted if &lt;code&gt;cov='unscaled'&lt;/code&gt;, as is relevant for the case that the weights are 1/sigma**2, with sigma known to be a reliable estimate of the uncertainty.</source>
          <target state="translated">Если задано, а не &lt;code&gt;False&lt;/code&gt; , вернуть не только оценку, но и ее ковариационную матрицу. По умолчанию ковариация масштабируется по chi2 / sqrt (N-dof), т. Е. Веса считаются ненадежными, за исключением относительного значения, и все масштабируется таким образом, что уменьшенная chi2 равна единице. Это масштабирование опускается, если &lt;code&gt;cov='unscaled'&lt;/code&gt; , что актуально для случая, когда веса равны 1 / сигма ** 2, при этом сигма, как известно, является надежной оценкой неопределенности.</target>
        </trans-unit>
        <trans-unit id="4a01bcc692f66d3a6d58bd9dd10d9c51e6240bfa" translate="yes" xml:space="preserve">
          <source>If given, any string of the form &lt;code&gt;@key@&lt;/code&gt; will be replaced by &lt;code&gt;subst_dict[key]&lt;/code&gt; in the template file when installed. The install prefix is always available through the variable &lt;code&gt;@prefix@&lt;/code&gt;, since the install prefix is not easy to get reliably from setup.py.</source>
          <target state="translated">Если задано, любая строка вида &lt;code&gt;@key@&lt;/code&gt; будет заменена на &lt;code&gt;subst_dict[key]&lt;/code&gt; в файле шаблона при установке. Префикс установки всегда доступен через переменную &lt;code&gt;@prefix@&lt;/code&gt; , так как префикс установки нелегко надежно получить из setup.py.</target>
        </trans-unit>
        <trans-unit id="f229986316849fc58c19699184e093af0322102f" translate="yes" xml:space="preserve">
          <source>If given, should be a sequence of additional directories where to look for npy-pkg-config files. Those directories are searched prior to the NumPy directory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="282b0a219b18c48a317e72503d2100cde36f84f8" translate="yes" xml:space="preserve">
          <source>If given, the array must be of the form &lt;code&gt;[beg, end]&lt;/code&gt;, where &lt;code&gt;beg&lt;/code&gt; and &lt;code&gt;end&lt;/code&gt; are the endpoints of the domain. If None is given then the class domain is used. The default is None.</source>
          <target state="translated">Если задан, массив должен иметь форму &lt;code&gt;[beg, end]&lt;/code&gt; , где &lt;code&gt;beg&lt;/code&gt; in и &lt;code&gt;end&lt;/code&gt; - конечные точки домена. Если задано None, то используется домен класса. По умолчанию - Нет.</target>
        </trans-unit>
        <trans-unit id="0dd507ea0f76e3b5e94e32d9b92c028c04854d11" translate="yes" xml:space="preserve">
          <source>If given, the resulting array must be if the form &lt;code&gt;[beg, end]&lt;/code&gt;, where &lt;code&gt;beg&lt;/code&gt; and &lt;code&gt;end&lt;/code&gt; are the endpoints of the window. If None is given then the class window is used. The default is None.</source>
          <target state="translated">Если задан, результирующий массив должен иметь форму &lt;code&gt;[beg, end]&lt;/code&gt; , где &lt;code&gt;beg&lt;/code&gt; in и &lt;code&gt;end&lt;/code&gt; - конечные точки окна. Если задано None, используется окно класса. По умолчанию - Нет.</target>
        </trans-unit>
        <trans-unit id="d16d5189bfa0fff58db67c1477d4b5ae0a2a03f6" translate="yes" xml:space="preserve">
          <source>If given, this is returned for objects whose types can not be determined. If not given, None is returned for those objects.</source>
          <target state="translated">Если дано,то это возвращается для объектов,типы которых не могут быть определены.Если не указано,то для этих объектов возвращается None.</target>
        </trans-unit>
        <trans-unit id="4c9471fb7a9f3abaf682e7276b2ee9a3f16f1ed9" translate="yes" xml:space="preserve">
          <source>If input array &lt;code&gt;a&lt;/code&gt; is not 2D.</source>
          <target state="translated">Если входной массив &lt;code&gt;a&lt;/code&gt; не 2D.</target>
        </trans-unit>
        <trans-unit id="03697161ee2c8ff90aa05356bdc85cfdd7ffe30e" translate="yes" xml:space="preserve">
          <source>If input is complex with all imaginary parts close to zero, return real parts.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f96f22e66784df0c0e7c7e7a77f909c0ac407de2" translate="yes" xml:space="preserve">
          <source>If input is the wrong shape (the input must be a 1-D or square 2-D array).</source>
          <target state="translated">Если вход неправильной формы (вход должен быть 1-D или квадратным 2-D массивом).</target>
        </trans-unit>
        <trans-unit id="c9a78f52b99ab1c1f8aad79c5f4b73ab06b85a94" translate="yes" xml:space="preserve">
          <source>If instead, we replace our &lt;code&gt;super&lt;/code&gt; call with &lt;code&gt;getattr(ufunc, method)&lt;/code&gt;, we effectively do &lt;code&gt;np.add(a.view(np.ndarray), b)&lt;/code&gt;. Again, &lt;code&gt;B.__array_ufunc__&lt;/code&gt; will be called, but now it sees an &lt;code&gt;ndarray&lt;/code&gt; as the other argument. Likely, it will know how to handle this, and return a new instance of the &lt;code&gt;B&lt;/code&gt; class to us. Our example class is not set up to handle this, but it might well be the best approach if, e.g., one were to re-implement &lt;code&gt;MaskedArray&lt;/code&gt; using &lt;code&gt;__array_ufunc__&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="570a12b7ce63be7a2ce71fba3d8c9da77deb9d9d" translate="yes" xml:space="preserve">
          <source>If int, the number of bins for the two dimensions (nx=ny=bins).</source>
          <target state="translated">Если int,то количество бинов для двух измерений (nx=ny=bins).</target>
        </trans-unit>
        <trans-unit id="f4fb4d5bcb48df147e2cef0a0ea5928ac8067b9e" translate="yes" xml:space="preserve">
          <source>If it becomes necessary for the Steering Council to produce a formal decision, then they will use a form of the &lt;a href=&quot;https://www.apache.org/foundation/voting.html&quot;&gt;Apache Foundation voting process&lt;/a&gt;. This is a formalized version of consensus, in which +1 votes indicate agreement, -1 votes are vetoes (and must be accompanied with a rationale, as above), and one can also vote fractionally (e.g. -0.5, +0.5) if one wishes to express an opinion without registering a full veto. These numeric votes are also often used informally as a way of getting a general sense of people&amp;rsquo;s feelings on some issue, and should not normally be taken as formal votes. A formal vote only occurs if explicitly declared, and if this does occur then the vote should be held open for long enough to give all interested Council Members a chance to respond &amp;ndash; at least one week.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46b4bbe660909db346ad59c7951f05bdd8332431" translate="yes" xml:space="preserve">
          <source>If it is necessary to explain a private method (use with care!), it can be referred to in the &lt;strong&gt;Extended Summary&lt;/strong&gt; or the &lt;strong&gt;Notes&lt;/strong&gt; section. Do not list private methods in the &lt;strong&gt;methods&lt;/strong&gt; section.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c2941a8c3ef7e42aa1704dd826466efd7a289a13" translate="yes" xml:space="preserve">
          <source>If it is not necessary to specify a keyword argument, use &lt;code&gt;optional&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="14206cf495608dab3bc0c9563f466018da9e1b11" translate="yes" xml:space="preserve">
          <source>If it went wrong, recovery is again possible as explained &lt;a href=&quot;#recovering-from-mess-up&quot;&gt;above&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a1bd74933e0b346982972b3334dd2af53c8b3cb" translate="yes" xml:space="preserve">
          <source>If keyword arguments are given, then filenames are taken from the keywords. If arguments are passed in with no keywords, then stored file names are arr_0, arr_1, etc.</source>
          <target state="translated">Если заданы аргументы ключевых слов,то имена файлов берутся из ключевых слов.Если аргументы передаются без ключевых слов,то имена файлов хранятся в виде arr_0,arr_1 и т.д.</target>
        </trans-unit>
        <trans-unit id="a05e5457e182b0de28998599a17f81c2384bc52a" translate="yes" xml:space="preserve">
          <source>If keyword arguments are given, then filenames are taken from the keywords. If arguments are passed in with no keywords, then stored filenames are arr_0, arr_1, etc.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="68f5690b1b20b80392957d2cc602580121727a3e" translate="yes" xml:space="preserve">
          <source>If list depths are mismatched - for instance, &lt;code&gt;[[a, b], c]&lt;/code&gt; is illegal, and should be spelt &lt;code&gt;[[a, b], [c]]&lt;/code&gt;</source>
          <target state="translated">Если глубины списка не совпадают - например, &lt;code&gt;[[a, b], c]&lt;/code&gt; недопустимо и должно быть написано &lt;code&gt;[[a, b], [c]]&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f609da24233a507af66f8b7969941dc9c31d8838" translate="yes" xml:space="preserve">
          <source>If lists are empty - for instance, &lt;code&gt;[[a, b], []]&lt;/code&gt;</source>
          <target state="translated">Если списки пустые - например, &lt;code&gt;[[a, b], []]&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c0fa6317253cb5f3105874e72d36c2e7ed1eb2af" translate="yes" xml:space="preserve">
          <source>If multi-dimension input, returns a new ndarray of indices to the minimum values along the given axis. Otherwise, returns a scalar of index to the minimum values along the given axis.</source>
          <target state="translated">При многомерном вводе возвращает новый указатель индексов к минимальным значениям вдоль данной оси.В противном случае возвращает скаляр индексов к минимальным значениям вдоль данной оси.</target>
        </trans-unit>
        <trans-unit id="3be2da634ae4e1a50b6a61b6e2a72b4b4858161d" translate="yes" xml:space="preserve">
          <source>If necessary, will be flattened before the differences are taken.</source>
          <target state="translated">При необходимости,будет сглажена до того,как будут сняты разногласия.</target>
        </trans-unit>
        <trans-unit id="301925ec926932bb64f4f4002e984f88f86a2131" translate="yes" xml:space="preserve">
          <source>If needed create a new C-structure to handle each instance of your type. A typical C-structure would be:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0a3c8652ca0e3dccf381651d80f187b5ac1a5a74" translate="yes" xml:space="preserve">
          <source>If neither is defined, the C-API is declared to be &lt;code&gt;static void**&lt;/code&gt;, so it is only visible within the compilation unit that #includes numpy/arrayobject.h.</source>
          <target state="translated">Если ни один из них не определен, C-API объявляется как &lt;code&gt;static void**&lt;/code&gt; , поэтому он виден только внутри модуля компиляции, который #includes numpy / arrayobject.h.</target>
        </trans-unit>
        <trans-unit id="853b03d065feffbc6ac6731a7bbb396016c51c2b" translate="yes" xml:space="preserve">
          <source>If no &lt;code&gt;__array_function__&lt;/code&gt; methods exists, NumPy will default to calling its own implementation, intended for use on NumPy arrays. This case arises, for example, when all array-like arguments are Python numbers or lists. (NumPy arrays do have a &lt;code&gt;__array_function__&lt;/code&gt; method, given below, but it always returns &lt;code&gt;NotImplemented&lt;/code&gt; if any argument other than a NumPy array subclass implements &lt;code&gt;__array_function__&lt;/code&gt;.)</source>
          <target state="translated">Если методов &lt;code&gt;__array_function__&lt;/code&gt; не существует, NumPy по умолчанию будет вызывать свою собственную реализацию, предназначенную для использования в массивах NumPy. Этот случай возникает, например, когда все аргументы, подобные массиву, являются числами или списками Python. (Массивы NumPy имеют метод &lt;code&gt;__array_function__&lt;/code&gt; , указанный ниже, но он всегда возвращает &lt;code&gt;NotImplemented&lt;/code&gt; , если какой-либо аргумент, кроме подкласса массива NumPy, реализует &lt;code&gt;__array_function__&lt;/code&gt; .)</target>
        </trans-unit>
        <trans-unit id="9e9935f1dd70f7a86b993ae6eeed6ce9464e1229" translate="yes" xml:space="preserve">
          <source>If no &lt;code&gt;intent(in | inout | out | hide)&lt;/code&gt; is specified, &lt;code&gt;intent(in)&lt;/code&gt; is assumed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="505142361ce7d844b31c251e5147e86fce3849fd" translate="yes" xml:space="preserve">
          <source>If none of the inputs overrides the ufunc, then all output arrays will be passed to the &lt;a href=&quot;arrays.classes#numpy.class.__array_prepare__&quot;&gt;&lt;code&gt;__array_prepare__&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;arrays.classes#numpy.class.__array_wrap__&quot;&gt;&lt;code&gt;__array_wrap__&lt;/code&gt;&lt;/a&gt; methods of the input (besides &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarrays&lt;/code&gt;&lt;/a&gt;, and scalars) that defines it &lt;strong&gt;and&lt;/strong&gt; has the highest &lt;a href=&quot;arrays.classes#numpy.class.__array_priority__&quot;&gt;&lt;code&gt;__array_priority__&lt;/code&gt;&lt;/a&gt; of any other input to the universal function. The default &lt;a href=&quot;arrays.classes#numpy.class.__array_priority__&quot;&gt;&lt;code&gt;__array_priority__&lt;/code&gt;&lt;/a&gt; of the ndarray is 0.0, and the default &lt;a href=&quot;arrays.classes#numpy.class.__array_priority__&quot;&gt;&lt;code&gt;__array_priority__&lt;/code&gt;&lt;/a&gt; of a subtype is 0.0. Matrices have &lt;a href=&quot;arrays.classes#numpy.class.__array_priority__&quot;&gt;&lt;code&gt;__array_priority__&lt;/code&gt;&lt;/a&gt; equal to 10.0.</source>
          <target state="translated">Если ни один из входов не переопределяет ufunc, тогда все выходные массивы будут &lt;a href=&quot;arrays.classes#numpy.class.__array_wrap__&quot;&gt; &lt;code&gt;__array_wrap__&lt;/code&gt; &lt;/a&gt; методам ввода &lt;a href=&quot;arrays.classes#numpy.class.__array_prepare__&quot;&gt; &lt;code&gt;__array_prepare__&lt;/code&gt; &lt;/a&gt; и __array_wrap__ (помимо &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarrays&lt;/code&gt; &lt;/a&gt; и скаляров), которые определяют его &lt;strong&gt;и&lt;/strong&gt; имеют наивысший &lt;a href=&quot;arrays.classes#numpy.class.__array_priority__&quot;&gt; &lt;code&gt;__array_priority__&lt;/code&gt; &lt;/a&gt; среди всех других входных данных универсальной функции. Значение по умолчанию &lt;a href=&quot;arrays.classes#numpy.class.__array_priority__&quot;&gt; &lt;code&gt;__array_priority__&lt;/code&gt; &lt;/a&gt; для ndarray равно 0,0, а значение по умолчанию &lt;a href=&quot;arrays.classes#numpy.class.__array_priority__&quot;&gt; &lt;code&gt;__array_priority__&lt;/code&gt; &lt;/a&gt; для подтипа - 0,0. Матрицы имеют &lt;a href=&quot;arrays.classes#numpy.class.__array_priority__&quot;&gt; &lt;code&gt;__array_priority__&lt;/code&gt; &lt;/a&gt; равное 10.0.</target>
        </trans-unit>
        <trans-unit id="96625db984c22cd52ed20b5b293895185469b2c4" translate="yes" xml:space="preserve">
          <source>If not &lt;code&gt;None&lt;/code&gt; normalization is by &lt;code&gt;(N - ddof)&lt;/code&gt;, where &lt;code&gt;N&lt;/code&gt; is the number of observations; this overrides the value implied by &lt;code&gt;bias&lt;/code&gt;. The default value is &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="translated">Если нет &lt;code&gt;None&lt;/code&gt; нормализация по &lt;code&gt;(N - ddof)&lt;/code&gt; , где &lt;code&gt;N&lt;/code&gt; есть число наблюдений; это отменяет значение, подразумеваемое &lt;code&gt;bias&lt;/code&gt; . Значение по умолчанию - &lt;code&gt;None&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e98fcdb4d2a9bfdfbe2eeae9c39d82ef88da39fa" translate="yes" xml:space="preserve">
          <source>If not &lt;code&gt;None&lt;/code&gt; the default value implied by &lt;code&gt;bias&lt;/code&gt; is overridden. Note that &lt;code&gt;ddof=1&lt;/code&gt; will return the unbiased estimate, even if both &lt;code&gt;fweights&lt;/code&gt; and &lt;code&gt;aweights&lt;/code&gt; are specified, and &lt;code&gt;ddof=0&lt;/code&gt; will return the simple average. See the notes for the details. The default value is &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="translated">Если не &lt;code&gt;None&lt;/code&gt; Значение по умолчанию подразумевается &lt;code&gt;bias&lt;/code&gt; отменяется. Обратите внимание, что &lt;code&gt;ddof=1&lt;/code&gt; вернет несмещенную оценку, даже если &lt;code&gt;fweights&lt;/code&gt; как fweights, так и &lt;code&gt;aweights&lt;/code&gt; , а &lt;code&gt;ddof=0&lt;/code&gt; вернет простое среднее. См. Примечания для деталей. Значение по умолчанию - &lt;code&gt;None&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fcf87e157fa41fe29ae78434e407f9e7ee68fcea" translate="yes" xml:space="preserve">
          <source>If not None, the keys should indicate the type(s) that the respective formatting function applies to. Callables should return a string. Types that are not specified (by their corresponding keys) are handled by the default formatters. Individual types for which a formatter can be set are:</source>
          <target state="translated">Если нет None,то клавиши должны указывать тип(ы),к которым применяется соответствующая функция форматирования.Вызовные таблицы должны возвращать строку.Типы,которые не указаны (соответствующими ключами),обрабатываются форматировщиками по умолчанию.Индивидуальными являются типы,для которых может быть задано форматирование:</target>
        </trans-unit>
        <trans-unit id="bb477c8d5a32ba9dc9b4018fd2f3af6fa9009c49" translate="yes" xml:space="preserve">
          <source>If not None, the specified domain is used instead of that of the calling instance. It should be of the form &lt;code&gt;[beg,end]&lt;/code&gt;. The default is None which case the class domain is used.</source>
          <target state="translated">Если не None, указанный домен используется вместо домена вызывающего экземпляра. Он должен иметь форму &lt;code&gt;[beg,end]&lt;/code&gt; начало , конец] . Значение по умолчанию - Нет, в этом случае используется домен класса.</target>
        </trans-unit>
        <trans-unit id="9fd5a8f72ea35597060cfb26a58e00837b4119cd" translate="yes" xml:space="preserve">
          <source>If not None, then memory-map the file, using the given mode (see &lt;a href=&quot;numpy.memmap#numpy.memmap&quot;&gt;&lt;code&gt;numpy.memmap&lt;/code&gt;&lt;/a&gt; for a detailed description of the modes). A memory-mapped array is kept on disk. However, it can be accessed and sliced like any ndarray. Memory mapping is especially useful for accessing small fragments of large files without reading the entire file into memory.</source>
          <target state="translated">Если не None, тогда карта памяти файла с использованием данного режима (см. &lt;a href=&quot;numpy.memmap#numpy.memmap&quot;&gt; &lt;code&gt;numpy.memmap&lt;/code&gt; &lt;/a&gt; для подробного описания режимов). Массив с отображением памяти хранится на диске. Однако к нему можно получить доступ и нарезать, как любой ndarray. Отображение памяти особенно полезно для доступа к небольшим фрагментам больших файлов без чтения всего файла в память.</target>
        </trans-unit>
        <trans-unit id="1dde66b48fa13cf03c30ed219d07e5b09a8bd837" translate="yes" xml:space="preserve">
          <source>If obj is an ndarray (&lt;a href=&quot;../reference/c-api/types-and-structures#c.PyArrayObject&quot;&gt;&lt;code&gt;PyArrayObject *&lt;/code&gt;&lt;/a&gt;), then the data-area of the ndarray is pointed to by the void* pointer &lt;a href=&quot;../reference/c-api/array#c.PyArray_DATA&quot;&gt;&lt;code&gt;PyArray_DATA&lt;/code&gt;&lt;/a&gt; (obj) or the char* pointer &lt;a href=&quot;../reference/c-api/array#c.PyArray_BYTES&quot;&gt;&lt;code&gt;PyArray_BYTES&lt;/code&gt;&lt;/a&gt; (obj). Remember that (in general) this data-area may not be aligned according to the data-type, it may represent byte-swapped data, and/or it may not be writeable. If the data area is aligned and in native byte-order, then how to get at a specific element of the array is determined only by the array of npy_intp variables, &lt;a href=&quot;../reference/c-api/array#c.PyArray_STRIDES&quot;&gt;&lt;code&gt;PyArray_STRIDES&lt;/code&gt;&lt;/a&gt; (obj). In particular, this c-array of integers shows how many &lt;strong&gt;bytes&lt;/strong&gt; must be added to the current element pointer to get to the next element in each dimension. For arrays less than 4-dimensions there are &lt;code&gt;PyArray_GETPTR{k}&lt;/code&gt; (obj, &amp;hellip;) macros where {k} is the integer 1, 2, 3, or 4 that make using the array strides easier. The arguments &amp;hellip;. represent {k} non- negative integer indices into the array. For example, suppose &lt;code&gt;E&lt;/code&gt; is a 3-dimensional ndarray. A (void*) pointer to the element &lt;code&gt;E[i,j,k]&lt;/code&gt; is obtained as &lt;a href=&quot;../reference/c-api/array#c.PyArray_GETPTR3&quot;&gt;&lt;code&gt;PyArray_GETPTR3&lt;/code&gt;&lt;/a&gt; (E, i, j, k).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9280c1d0944bd8756c1f5111dc408efcc4ac592a" translate="yes" xml:space="preserve">
          <source>If offsets were specified using the optional &lt;code&gt;offsets&lt;/code&gt; key in the dictionary-based dtype specification, setting &lt;code&gt;align=True&lt;/code&gt; will check that each field&amp;rsquo;s offset is a multiple of its size and that the itemsize is a multiple of the largest field size, and raise an exception if not.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e8ee117c63f729e22bf227e3e07bb22de12fa90" translate="yes" xml:space="preserve">
          <source>If one argument: a scalar, only used in case &lt;code&gt;a&lt;/code&gt; is of size 1. If two arguments: the last argument is the value to be set and must be a scalar, the first argument specifies a single array element location. It is either an int or a tuple.</source>
          <target state="translated">Если один аргумент: скаляр, используется только в том случае, &lt;code&gt;a&lt;/code&gt; размер a равен 1. Если два аргумента: последний аргумент - это значение, которое необходимо установить, и должен быть скаляром, первый аргумент указывает расположение одного элемента массива. Это либо целое число, либо кортеж.</target>
        </trans-unit>
        <trans-unit id="57c6aeb84d68fcc852763a7a13de57615e4d20cf" translate="yes" xml:space="preserve">
          <source>If one does need to invoke a formal veto, then it should consist of:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="071afc2f1bb001ecc847b5f0833d4155cd8fca5d" translate="yes" xml:space="preserve">
          <source>If one of the commands breaks in the middle, which is not uncommon, you may need to selectively upload the remaining files because PyPI does not allow the same file to be uploaded twice. The source file should be uploaded last to avoid synchronization problems if pip users access the files while this is in process. Note that PyPI only allows a single source distribution, here we have chosen the zip archive.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6981fed895201194d2f8c788e92aaa4d462ed21a" translate="yes" xml:space="preserve">
          <source>If one of the input or output arguments has a &lt;a href=&quot;#numpy.class.__array_ufunc__&quot;&gt;&lt;code&gt;__array_ufunc__&lt;/code&gt;&lt;/a&gt; method, it is executed &lt;em&gt;instead&lt;/em&gt; of the ufunc. If more than one of the arguments implements &lt;a href=&quot;#numpy.class.__array_ufunc__&quot;&gt;&lt;code&gt;__array_ufunc__&lt;/code&gt;&lt;/a&gt;, they are tried in the order: subclasses before superclasses, inputs before outputs, otherwise left to right. The first routine returning something other than &lt;a href=&quot;https://docs.python.org/dev/library/constants.html#NotImplemented&quot;&gt;&lt;code&gt;NotImplemented&lt;/code&gt;&lt;/a&gt; determines the result. If all of the &lt;a href=&quot;#numpy.class.__array_ufunc__&quot;&gt;&lt;code&gt;__array_ufunc__&lt;/code&gt;&lt;/a&gt; operations return &lt;a href=&quot;https://docs.python.org/dev/library/constants.html#NotImplemented&quot;&gt;&lt;code&gt;NotImplemented&lt;/code&gt;&lt;/a&gt;, a &lt;a href=&quot;https://docs.python.org/dev/library/exceptions.html#TypeError&quot;&gt;&lt;code&gt;TypeError&lt;/code&gt;&lt;/a&gt; is raised.</source>
          <target state="translated">Если один из входных или выходных аргументов имеет метод &lt;a href=&quot;#numpy.class.__array_ufunc__&quot;&gt; &lt;code&gt;__array_ufunc__&lt;/code&gt; &lt;/a&gt; , он выполняется &lt;em&gt;вместо&lt;/em&gt; ufunc. Если несколько аргументов реализуют &lt;a href=&quot;#numpy.class.__array_ufunc__&quot;&gt; &lt;code&gt;__array_ufunc__&lt;/code&gt; &lt;/a&gt; , они проверяются в следующем порядке: подклассы перед суперклассами, входы перед выходами, в противном случае слева направо. Первая подпрограмма, возвращающая что-то иное, чем &lt;a href=&quot;https://docs.python.org/dev/library/constants.html#NotImplemented&quot;&gt; &lt;code&gt;NotImplemented&lt;/code&gt; ,&lt;/a&gt; определяет результат. Если все &lt;a href=&quot;#numpy.class.__array_ufunc__&quot;&gt; &lt;code&gt;__array_ufunc__&lt;/code&gt; &lt;/a&gt; операции возвращают &lt;a href=&quot;https://docs.python.org/dev/library/constants.html#NotImplemented&quot;&gt; &lt;code&gt;NotImplemented&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;https://docs.python.org/dev/library/exceptions.html#TypeError&quot;&gt; &lt;code&gt;TypeError&lt;/code&gt; &lt;/a&gt; поднимается.</target>
        </trans-unit>
        <trans-unit id="078513303dc00f49a54bb48b4a05d01efff2507a" translate="yes" xml:space="preserve">
          <source>If one or more elements differ by more than &lt;code&gt;maxulp&lt;/code&gt;.</source>
          <target state="translated">Если один или несколько элементов отличаются более чем на &lt;code&gt;maxulp&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="00b891e47fe38237c020d297bb43b5693729c6dd" translate="yes" xml:space="preserve">
          <source>If one throws a die repeatedly until the third time a &amp;ldquo;1&amp;rdquo; appears, then the probability distribution of the number of non-&amp;ldquo;1&amp;rdquo;s that appear before the third &amp;ldquo;1&amp;rdquo; is a negative binomial distribution.</source>
          <target state="translated">Если бросать кубик несколько раз до тех пор, пока в третий раз не появится цифра &amp;laquo;1&amp;raquo;, то распределение вероятностей количества не- &amp;laquo;1&amp;raquo;, которые появляются перед третьей &amp;laquo;1&amp;raquo;, является отрицательным биномиальным распределением.</target>
        </trans-unit>
        <trans-unit id="f25e55ccd77b879343ce3ca049a9d0e4b78987e8" translate="yes" xml:space="preserve">
          <source>If one uses the same dimension name in multiple locations, this enforces the same size of the corresponding dimensions.</source>
          <target state="translated">Если в нескольких местах используется одно и то же имя размера,то в этом случае применяется один и тот же размер соответствующих размеров.</target>
        </trans-unit>
        <trans-unit id="341d0c5af878a988a0ac05e9410e510da00aae4c" translate="yes" xml:space="preserve">
          <source>If operand flags &lt;code&gt;&amp;ldquo;writeonly&amp;rdquo;&lt;/code&gt; or &lt;code&gt;&amp;ldquo;readwrite&amp;rdquo;&lt;/code&gt; are used the operands may be views into the original data with the &lt;code&gt;WRITEBACKIFCOPY&lt;/code&gt; flag. In this case &lt;a href=&quot;#numpy.nditer&quot;&gt;&lt;code&gt;nditer&lt;/code&gt;&lt;/a&gt; must be used as a context manager or the &lt;a href=&quot;numpy.nditer.close#numpy.nditer.close&quot;&gt;&lt;code&gt;nditer.close&lt;/code&gt;&lt;/a&gt; method must be called before using the result. The temporary data will be written back to the original data when the &lt;code&gt;__exit__&lt;/code&gt; function is called but not before:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d0e3c2e03d57620541ba508399723e46a30af16" translate="yes" xml:space="preserve">
          <source>If operand flags &lt;code&gt;&amp;ldquo;writeonly&amp;rdquo;&lt;/code&gt; or &lt;code&gt;&amp;ldquo;readwrite&amp;rdquo;&lt;/code&gt; are used the operands may be views into the original data with the &lt;code&gt;WRITEBACKIFCOPY&lt;/code&gt; flag. In this case nditer must be used as a context manager or the nditer.close method must be called before using the result. The temporary data will be written back to the original data when the &lt;code&gt;__exit__&lt;/code&gt; function is called but not before:</source>
          <target state="translated">Если используются флаги операндов &lt;code&gt;&amp;ldquo;writeonly&amp;rdquo;&lt;/code&gt; или &lt;code&gt;&amp;ldquo;readwrite&amp;rdquo;&lt;/code&gt; , операнды могут быть &lt;code&gt;WRITEBACKIFCOPY&lt;/code&gt; в исходных данных с флагом WRITEBACKIFCOPY . В этом случае nditer необходимо использовать в качестве диспетчера контекста или перед использованием результата необходимо вызвать метод nditer.close. Временные данные будут записаны обратно в исходные данные при &lt;code&gt;__exit__&lt;/code&gt; функции __exit__, но не раньше:</target>
        </trans-unit>
        <trans-unit id="6bcdbb4b2db72f15cd471674f6106b51d73bea1c" translate="yes" xml:space="preserve">
          <source>If our array has more than two dimensions, then the SVD can be applied to all axes at once. However, the linear algebra functions in NumPy expect to see an array of the form &lt;code&gt;(N, M, M)&lt;/code&gt;, where the first axis represents the number of matrices.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7979a86d632f406a43fda9a7bbc242f0b6aa48c1" translate="yes" xml:space="preserve">
          <source>If out is given and does not have a mask attribute, the mask of a is lost!</source>
          <target state="translated">Если выдан аут и не имеет атрибута маски,то маска утеряна!</target>
        </trans-unit>
        <trans-unit id="540ba134ebef3a60b12504ba1dddaea7cf0cec06" translate="yes" xml:space="preserve">
          <source>If passed a single ndarray or scalar (a nested list of depth 0), this is returned unmodified (and not copied).</source>
          <target state="translated">Если передан одиночный ндаррей или скаляр (вложенный список глубины 0),то он возвращается немодифицированным (и не копируется).</target>
        </trans-unit>
        <trans-unit id="96808216b5aaeeafcea0d1c6dd5a1e0894eaaeca" translate="yes" xml:space="preserve">
          <source>If positive int_like arguments are provided, &lt;a href=&quot;#numpy.random.mtrand.RandomState.randn&quot;&gt;&lt;code&gt;randn&lt;/code&gt;&lt;/a&gt; generates an array of shape &lt;code&gt;(d0, d1, ..., dn)&lt;/code&gt;, filled with random floats sampled from a univariate &amp;ldquo;normal&amp;rdquo; (Gaussian) distribution of mean 0 and variance 1. A single float randomly sampled from the distribution is returned if no argument is provided.</source>
          <target state="translated">Если предоставлены положительные аргументы типа &lt;a href=&quot;#numpy.random.mtrand.RandomState.randn&quot;&gt; &lt;code&gt;randn&lt;/code&gt; &lt;/a&gt; , randn генерирует массив формы &lt;code&gt;(d0, d1, ..., dn)&lt;/code&gt; , заполненный случайными числами с плавающей запятой, выбранными из одномерного &amp;laquo;нормального&amp;raquo; (гауссовского) распределения среднего 0 и дисперсии 1. Одно значение с плавающей запятой. Если аргумент не указан, возвращается случайная выборка из распределения.</target>
        </trans-unit>
        <trans-unit id="6cd43f42d93868c2f881ad2d0e04b27cc3b3d230" translate="yes" xml:space="preserve">
          <source>If positive int_like arguments are provided, &lt;a href=&quot;#numpy.random.randn&quot;&gt;&lt;code&gt;randn&lt;/code&gt;&lt;/a&gt; generates an array of shape &lt;code&gt;(d0, d1, ..., dn)&lt;/code&gt;, filled with random floats sampled from a univariate &amp;ldquo;normal&amp;rdquo; (Gaussian) distribution of mean 0 and variance 1. A single float randomly sampled from the distribution is returned if no argument is provided.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bfcb0d73efeb90f5b4e3ce5ebdfcfa5192159dee" translate="yes" xml:space="preserve">
          <source>If positive int_like arguments are provided, &lt;a href=&quot;numpy.random.randn#numpy.random.randn&quot;&gt;&lt;code&gt;randn&lt;/code&gt;&lt;/a&gt; generates an array of shape &lt;code&gt;(d0, d1, ..., dn)&lt;/code&gt;, filled with random floats sampled from a univariate &amp;ldquo;normal&amp;rdquo; (Gaussian) distribution of mean 0 and variance 1. A single float randomly sampled from the distribution is returned if no argument is provided.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="55be54163f14c3cf436fe9e5956719fe1ba33eba" translate="yes" xml:space="preserve">
          <source>If provided, forces the calculation to use the data type specified. Note that you may have to also give a more liberal &lt;code&gt;casting&lt;/code&gt; parameter to allow the conversions. Default is None.</source>
          <target state="translated">Если задан, заставляет расчет использовать указанный тип данных. Обратите внимание, что вам, возможно, придется указать более либеральный параметр &lt;code&gt;casting&lt;/code&gt; чтобы разрешить преобразования. По умолчанию нет.</target>
        </trans-unit>
        <trans-unit id="e083348afe334fd6151280febab9e53c63ddbb1c" translate="yes" xml:space="preserve">
          <source>If provided, is a list of ints or None for each operands. The list of axes for an operand is a mapping from the dimensions of the iterator to the dimensions of the operand. A value of -1 can be placed for entries, causing that dimension to be treated as &lt;a href=&quot;../constants#numpy.newaxis&quot;&gt;&lt;code&gt;newaxis&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Если предоставлено, это список целых чисел или None для каждого операнда. Список осей для операнда - это отображение размеров итератора на размеры операнда. Для записей можно &lt;a href=&quot;../constants#numpy.newaxis&quot;&gt; &lt;code&gt;newaxis&lt;/code&gt; &lt;/a&gt; значение -1, в результате чего это измерение будет рассматриваться как новая ось .</target>
        </trans-unit>
        <trans-unit id="b5d381c2d7955b7fd1c70c985e306d9e2f555e38" translate="yes" xml:space="preserve">
          <source>If provided, one above the largest (signed) integer to be drawn from the distribution (see above for behavior if &lt;code&gt;high=None&lt;/code&gt;). If array-like, must contain integer values</source>
          <target state="translated">Если предоставлено, одно число выше наибольшего (подписанного) целого числа, которое будет извлечено из распределения (см. Поведение выше, если &lt;code&gt;high=None&lt;/code&gt; ). Если подобен массиву, должен содержать целочисленные значения</target>
        </trans-unit>
        <trans-unit id="95838d6d878826fc55d5a3e35ced6032cc48a529" translate="yes" xml:space="preserve">
          <source>If provided, the calculation is done into this array.</source>
          <target state="translated">Если это предусмотрено,то вычисление производится в этом массиве.</target>
        </trans-unit>
        <trans-unit id="af1a016b36ff8a1ba521445122b451501db1dbf6" translate="yes" xml:space="preserve">
          <source>If provided, the destination to place the result. The shape must be correct, matching that of what concatenate would have returned if no out argument were specified.</source>
          <target state="translated">Если предусмотрено,пункт назначения для размещения результата.Форма должна быть правильной,соответствующей тому,что конкатенат возвращал бы,если бы не был указан внешний аргумент.</target>
        </trans-unit>
        <trans-unit id="c1c663fe8abb225f988d791716021ba47f8cdb72" translate="yes" xml:space="preserve">
          <source>If provided, the destination to place the result. The shape must be correct, matching that of what stack would have returned if no out argument were specified.</source>
          <target state="translated">Если предусмотрено,пункт назначения для размещения результата.Форма должна быть правильной,совпадающей с тем,что возвращал бы стек,если бы не был указан аргумент out.</target>
        </trans-unit>
        <trans-unit id="f5316b9b72a00d5e03e3e99cc76713f526033f92" translate="yes" xml:space="preserve">
          <source>If provided, the largest (signed) integer to be drawn from the distribution (see above for behavior if &lt;code&gt;high=None&lt;/code&gt;).</source>
          <target state="translated">Если предоставлено, наибольшее (со знаком) целое число, которое будет извлечено из распределения (см. Поведение выше, если &lt;code&gt;high=None&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="95c405f27ca318550aa8a5e9d68fd036459e5597" translate="yes" xml:space="preserve">
          <source>If provided, the result will be inserted into this array. It should be of the appropriate shape and &lt;code&gt;dtype&lt;/code&gt;.</source>
          <target state="translated">Если указано, результат будет вставлен в этот массив. Он должен быть соответствующей формы и &lt;code&gt;dtype&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5aa5842b82d356df663381019439d99b6de6d45f" translate="yes" xml:space="preserve">
          <source>If provided, the result will be inserted into this array. It should be of the appropriate shape and dtype.</source>
          <target state="translated">Если это предусмотрено,то результат будет вставлен в этот массив.Он должен иметь соответствующую форму и тип d.</target>
        </trans-unit>
        <trans-unit id="cb7c8c85e64a3a49b66549989ff45cf1e28fbfc9" translate="yes" xml:space="preserve">
          <source>If provided, the result will be inserted into this array. It should be of the appropriate shape and dtype. Note that &lt;code&gt;out&lt;/code&gt; is always buffered if &lt;code&gt;mode=&amp;rsquo;raise&amp;rsquo;&lt;/code&gt;; use other modes for better performance.</source>
          <target state="translated">Если указано, результат будет вставлен в этот массив. Он должен быть соответствующей формы и типа. Обратите внимание, что &lt;code&gt;out&lt;/code&gt; всегда буферизуется, если &lt;code&gt;mode=&amp;rsquo;raise&amp;rsquo;&lt;/code&gt; ; используйте другие режимы для повышения производительности.</target>
        </trans-unit>
        <trans-unit id="81a5da5dc747b4213d85b5feaae67db0441d8c96" translate="yes" xml:space="preserve">
          <source>If provided, the result will be placed in this array. It should be of the appropriate shape and dtype. Note that &lt;code&gt;out&lt;/code&gt; is always buffered if &lt;code&gt;mode=&amp;rsquo;raise&amp;rsquo;&lt;/code&gt;; use other modes for better performance.</source>
          <target state="translated">Если указано, результат будет помещен в этот массив. Он должен быть соответствующей формы и типа. Обратите внимание, что &lt;code&gt;out&lt;/code&gt; всегда буферизуется, если &lt;code&gt;mode=&amp;rsquo;raise&amp;rsquo;&lt;/code&gt; ; используйте другие режимы для повышения производительности.</target>
        </trans-unit>
        <trans-unit id="930ff5cfb0e50021c5f5a8e94b02d45dd7e7a78b" translate="yes" xml:space="preserve">
          <source>If provided, this array is filled with the result.</source>
          <target state="translated">Если это предусмотрено,то этот массив заполняется результатом.</target>
        </trans-unit>
        <trans-unit id="11fa623532ff8e1a6968612e0395b44c20331e38" translate="yes" xml:space="preserve">
          <source>If set to False, the returned array will always be readonly. Otherwise it will be writable if the original array was. It is advisable to set this to False if possible (see Notes).</source>
          <target state="translated">Если установлено значение False,возвращаемый массив всегда будет только для чтения.В противном случае он будет доступен для записи,если исходный массив был.Рекомендуется по возможности устанавливать значение False (см.Примечания).</target>
        </trans-unit>
        <trans-unit id="2bff5e445257625fab4df9171fbb5cbef9e23081" translate="yes" xml:space="preserve">
          <source>If set to the string &lt;code&gt;&amp;lsquo;1.13&amp;rsquo;&lt;/code&gt; enables 1.13 legacy printing mode. This approximates numpy 1.13 print output by including a space in the sign position of floats and different behavior for 0d arrays. If set to &lt;code&gt;False&lt;/code&gt;, disables legacy mode. Unrecognized strings will be ignored with a warning for forward compatibility.</source>
          <target state="translated">Если установлено значение &lt;code&gt;&amp;lsquo;1.13&amp;rsquo;&lt;/code&gt; включается устаревший режим печати 1.13. Это приближает вывод numpy 1.13 на печать, включая пробел в позиции знака с плавающей запятой и различное поведение для массивов 0d. Если установлено значение &lt;code&gt;False&lt;/code&gt; , устаревший режим отключается. Нераспознанные строки будут проигнорированы с предупреждением для прямой совместимости.</target>
        </trans-unit>
        <trans-unit id="fe72d8f764239876f5476ff64d033c4aa157117d" translate="yes" xml:space="preserve">
          <source>If slice notation is used, the syntax &lt;code&gt;start:stop:step&lt;/code&gt; is equivalent to &lt;code&gt;np.arange(start, stop, step)&lt;/code&gt; inside of the brackets. However, if &lt;code&gt;step&lt;/code&gt; is an imaginary number (i.e. 100j) then its integer portion is interpreted as a number-of-points desired and the start and stop are inclusive. In other words &lt;code&gt;start:stop:stepj&lt;/code&gt; is interpreted as &lt;code&gt;np.linspace(start, stop, step, endpoint=1)&lt;/code&gt; inside of the brackets. After expansion of slice notation, all comma separated sequences are concatenated together.</source>
          <target state="translated">Если используется нотация среза, синтаксис &lt;code&gt;start:stop:step&lt;/code&gt; эквивалентен &lt;code&gt;np.arange(start, stop, step)&lt;/code&gt; внутри скобок. Однако, если &lt;code&gt;step&lt;/code&gt; является мнимым числом (например, 100j), то его целая часть интерпретируется как желаемое количество точек, а начало и конец включены. Другими словами &lt;code&gt;start:stop:stepj&lt;/code&gt; интерпретируется как &lt;code&gt;np.linspace(start, stop, step, endpoint=1)&lt;/code&gt; внутри скобок. После расширения нотации срезов все последовательности, разделенные запятыми, объединяются вместе.</target>
        </trans-unit>
        <trans-unit id="81a87ade0c2eb6eb2f3e1b57567f9837157177e2" translate="yes" xml:space="preserve">
          <source>If some of the singular values of &lt;code&gt;V&lt;/code&gt; are so small that they are neglected (and &lt;code&gt;full&lt;/code&gt; == &lt;code&gt;False&lt;/code&gt;), a &lt;code&gt;RankWarning&lt;/code&gt; will be raised. This means that the coefficient values may be poorly determined. Fitting to a lower order polynomial will usually get rid of the warning (but may not be what you want, of course; if you have independent reason(s) for choosing the degree which isn&amp;rsquo;t working, you may have to: a) reconsider those reasons, and/or b) reconsider the quality of your data). The &lt;code&gt;rcond&lt;/code&gt; parameter can also be set to a value smaller than its default, but the resulting fit may be spurious and have large contributions from roundoff error.</source>
          <target state="translated">Если некоторые из сингулярных значений &lt;code&gt;V&lt;/code&gt; настолько малы, что ими пренебрегают (и &lt;code&gt;full&lt;/code&gt; == &lt;code&gt;False&lt;/code&gt; ), будет &lt;code&gt;RankWarning&lt;/code&gt; . Это означает, что значения коэффициентов могут быть плохо определены. Подбор полинома более низкого порядка обычно избавляет от предупреждения (но, конечно, это может быть не то, что вам нужно; если у вас есть независимые причины для выбора степени, которая не работает, вам, возможно, придется: a) пересмотреть эти причины и / или б) пересмотреть качество ваших данных). Параметр &lt;code&gt;rcond&lt;/code&gt; также может быть установлен на значение меньшее, чем значение по умолчанию, но полученное соответствие может быть ложным и иметь большой вклад из-за ошибки округления.</target>
        </trans-unit>
        <trans-unit id="279580d9404d9230f24c863b3bff92a3996533c2" translate="yes" xml:space="preserve">
          <source>If some of the singular values of &lt;code&gt;V&lt;/code&gt; are so small that they are neglected, then a &lt;code&gt;RankWarning&lt;/code&gt; will be issued. This means that the coefficient values may be poorly determined. Using a lower order fit will usually get rid of the warning. The &lt;code&gt;rcond&lt;/code&gt; parameter can also be set to a value smaller than its default, but the resulting fit may be spurious and have large contributions from roundoff error.</source>
          <target state="translated">Если некоторые из сингулярных значений &lt;code&gt;V&lt;/code&gt; настолько малы, что ими пренебрегают, будет выдано &lt;code&gt;RankWarning&lt;/code&gt; . Это означает, что значения коэффициентов могут быть плохо определены. Использование подгонки более низкого порядка обычно избавляет от предупреждения. Параметр &lt;code&gt;rcond&lt;/code&gt; также может быть установлен на значение меньшее, чем значение по умолчанию, но полученное соответствие может быть ложным и иметь большой вклад из-за ошибки округления.</target>
        </trans-unit>
        <trans-unit id="965baa6e6f17f07c36f67c069da20d4c8b056bfe" translate="yes" xml:space="preserve">
          <source>If sparse is False:</source>
          <target state="translated">Если скудный-это Ложь:</target>
        </trans-unit>
        <trans-unit id="d3cfaef438df28358b3d4e747b777d350c839464" translate="yes" xml:space="preserve">
          <source>If sparse is True:</source>
          <target state="translated">Если малое-это правда:</target>
        </trans-unit>
        <trans-unit id="da499c4730990d0eca07f07d81ecedd5eee01e35" translate="yes" xml:space="preserve">
          <source>If sparse is set to true, the grid will be returned in a sparse representation.</source>
          <target state="translated">Если разреженное значение установлено в true,то сетка будет возвращена в разреженном представлении.</target>
        </trans-unit>
        <trans-unit id="a0b2e0085e9bacd8c444b0a0e2e8508a5f8b81ab" translate="yes" xml:space="preserve">
          <source>If specified, all the fields will be changed to the provided byte-order. Otherwise, the default byte-order is used. For all available string specifiers, see &lt;a href=&quot;numpy.dtype.newbyteorder#numpy.dtype.newbyteorder&quot;&gt;&lt;code&gt;dtype.newbyteorder&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Если указано, все поля будут изменены в указанном порядке байтов. В противном случае используется порядок байтов по умолчанию. Все доступные спецификаторы строк см. В &lt;a href=&quot;numpy.dtype.newbyteorder#numpy.dtype.newbyteorder&quot;&gt; &lt;code&gt;dtype.newbyteorder&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="524227865d52e8b4442de30061c3ce0262f46831" translate="yes" xml:space="preserve">
          <source>If specified, it must be a tuple or list which contains a permutation of [0,1,..,N-1] where N is the number of axes of a. The i&amp;rsquo;th axis of the returned array will correspond to the axis numbered &lt;code&gt;axes[i]&lt;/code&gt; of the input. If not specified, defaults to &lt;code&gt;range(a.ndim)[::-1]&lt;/code&gt;, which reverses the order of the axes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f824fc5934f1c56555b7168823af2d5da98b5dab" translate="yes" xml:space="preserve">
          <source>If state is a dictionary, it is directly set using the BitGenerators &lt;code&gt;state&lt;/code&gt; property.</source>
          <target state="translated">Если состояние является словарем, оно устанавливается напрямую с помощью свойства &lt;code&gt;state&lt;/code&gt; BitGenerators .</target>
        </trans-unit>
        <trans-unit id="8bed509b136f4d80f9b83488488a97c842996d12" translate="yes" xml:space="preserve">
          <source>If steps 1 and 2 are done correctly, compiling the release should not give a warning &amp;ldquo;API mismatch detect at the beginning of the build&amp;rdquo;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ebc779ce22e3bc8704e258c3f6aa49989598231f" translate="yes" xml:space="preserve">
          <source>If the (deprecated) &lt;a href=&quot;#c.NPY_ARRAY_UPDATEIFCOPY&quot;&gt;&lt;code&gt;NPY_ARRAY_UPDATEIFCOPY&lt;/code&gt;&lt;/a&gt; or the &lt;a href=&quot;#c.NPY_ARRAY_WRITEBACKIFCOPY&quot;&gt;&lt;code&gt;NPY_ARRAY_WRITEBACKIFCOPY&lt;/code&gt;&lt;/a&gt; flags are set, it has a different meaning, namely base is the array into which the current array will be copied upon copy resolution. This overloading of the base property for two functions is likely to change in a future version of NumPy.</source>
          <target state="translated">Если (устарело) &lt;a href=&quot;#c.NPY_ARRAY_UPDATEIFCOPY&quot;&gt; &lt;code&gt;NPY_ARRAY_UPDATEIFCOPY&lt;/code&gt; &lt;/a&gt; флаги NPY_ARRAY_UPDATEIFCOPY или &lt;a href=&quot;#c.NPY_ARRAY_WRITEBACKIFCOPY&quot;&gt; &lt;code&gt;NPY_ARRAY_WRITEBACKIFCOPY&lt;/code&gt; &lt;/a&gt; , они имеют другое значение, а именно base - это массив, в который будет скопирован текущий массив при разрешении копирования. Эта перегрузка базового свойства для двух функций, вероятно, изменится в будущей версии NumPy.</target>
        </trans-unit>
        <trans-unit id="cfe3d233f0d1b6d420d00f98b03a5ffbba4bbec2" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;../reference/arrays.classes#numpy.class.__array_finalize__&quot;&gt;&lt;code&gt;__array_finalize__&lt;/code&gt;&lt;/a&gt; attribute is a CObject, then the pointer must be a pointer to a function with the signature:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b7883df78258ee376bc6906db165b3539bd009bc" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;../reference/arrays.classes#numpy.class.__array_finalize__&quot;&gt;&lt;code&gt;__array_finalize__&lt;/code&gt;&lt;/a&gt; attribute is not None nor a CObject, then it must be a Python method that takes the parent array as an argument (which could be None if there is no parent), and returns nothing. Errors in this method will be caught and handled.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="35bc1249e520730be2802640a0588a9755304660" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt; object is a structured array the &lt;a href=&quot;../glossary#term-field&quot;&gt;fields&lt;/a&gt; of the array can be accessed by indexing the array with strings, dictionary-like.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f501c2023177671c00839603f74082e5dd3d055" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt; object is a structured array the &lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/glossary.html#term-field&quot;&gt;fields&lt;/a&gt; of the array can be accessed by indexing the array with strings, dictionary-like.</source>
          <target state="translated">Если объект &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt; является структурированным массивом, доступ к &lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/glossary.html#term-field&quot;&gt;полям&lt;/a&gt; массива можно получить, индексируя массив строками, как в словаре.</target>
        </trans-unit>
        <trans-unit id="0646be9a4620b324160297ec7386ae7d381a6d92" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;order&lt;/code&gt; keyword argument is specified. This behaviour is a bug in NumPy.</source>
          <target state="translated">Если указан аргумент ключевого слова &lt;code&gt;order&lt;/code&gt; . Такое поведение является ошибкой в ​​NumPy.</target>
        </trans-unit>
        <trans-unit id="95474ba24abf246463d023b7d37164eff549d001" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;width&lt;/code&gt; value is insufficient, it will be ignored, and &lt;code&gt;num&lt;/code&gt; will be returned in binary (&lt;code&gt;num&lt;/code&gt; &amp;gt; 0) or two&amp;rsquo;s complement (&lt;code&gt;num&lt;/code&gt; &amp;lt; 0) form with its width equal to the minimum number of bits needed to represent the number in the designated form. This behavior is deprecated and will later raise an error.</source>
          <target state="translated">Если значение &lt;code&gt;width&lt;/code&gt; недостаточное, оно будет проигнорировано, а &lt;code&gt;num&lt;/code&gt; будет возвращено в двоичной форме ( &lt;code&gt;num&lt;/code&gt; &amp;gt; 0) или в форме дополнения до двух ( &lt;code&gt;num&lt;/code&gt; &amp;lt;0) с шириной, равной минимальному количеству битов, необходимых для представления числа в обозначенная форма. Такое поведение устарело и позже вызовет ошибку.</target>
        </trans-unit>
        <trans-unit id="e55f68c7edc654033798e55316d9b9691f5ca17e" translate="yes" xml:space="preserve">
          <source>If the API has changed, increment the C_API_VERSION in setup_common.py. The API is unchanged only if any code compiled against the current API will be backward compatible with the last released NumPy version. Any changes to C structures or additions to the public interface will make the new API not backward compatible.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="846345b681ee07e5dd05c26de91938c5750e96ed" translate="yes" xml:space="preserve">
          <source>If the C_API_VERSION in the first step has changed, or if the hash of the API has changed, the cversions.txt file needs to be updated. To check the hash, run the script numpy/core/cversions.py and note the API hash that is printed. If that hash does not match the last hash in numpy/core/code_generators/cversions.txt the hash has changed. Using both the appropriate C_API_VERSION and hash, add a new entry to cversions.txt. If the API version was not changed, but the hash differs, you will need to comment out the previous entry for that API version. For instance, in NumPy 1.9 annotations were added, which changed the hash, but the API was the same as in 1.8. The hash serves as a check for API changes, but it is not definitive.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="307258bcc851f5976aadd2f56343dad80fcf2a38" translate="yes" xml:space="preserve">
          <source>If the PR relates to any issues, you can add the text &lt;code&gt;xref gh-xxxx&lt;/code&gt; where &lt;code&gt;xxxx&lt;/code&gt; is the number of the issue to github comments. Likewise, if the PR solves an issue, replace the &lt;code&gt;xref&lt;/code&gt; with &lt;code&gt;closes&lt;/code&gt;, &lt;code&gt;fixes&lt;/code&gt; or any of the other flavors &lt;a href=&quot;https://help.github.com/en/articles/closing-issues-using-keywords&quot;&gt;github accepts&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="049594537957d0705cc457b562940a40a3ed3347" translate="yes" xml:space="preserve">
          <source>If the SVD computation does not converge.</source>
          <target state="translated">Если вычисления SVD не сходятся.</target>
        </trans-unit>
        <trans-unit id="532b7abf588e485b512986621b48cdfb34aabd33" translate="yes" xml:space="preserve">
          <source>If the Sphinx build issues a warning of the form &lt;code&gt;WARNING: Unknown target name: &quot;example&quot;&lt;/code&gt;, then that is what is happening. To avoid this problem, use the inline hyperlink form:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64f36babe99dcf796b7778a9ef584cf09c04cb03" translate="yes" xml:space="preserve">
          <source>If the accessed field is a sub-array, the dimensions of the sub-array are appended to the shape of the result.</source>
          <target state="translated">Если поле доступа является подмассивом,то размеры подмассива добавляются к форме результата.</target>
        </trans-unit>
        <trans-unit id="7e63ccdf53ce8ac8b2fb2a0fbc4aad1e23cbc4dc" translate="yes" xml:space="preserve">
          <source>If the accessed field is a subarray, the dimensions of the subarray are appended to the shape of the result:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba28bd784223a2a08bea18d126c6d98be59cd057" translate="yes" xml:space="preserve">
          <source>If the accumulator is too small, overflow occurs:</source>
          <target state="translated">Если аккумулятор слишком мал,происходит переполнение:</target>
        </trans-unit>
        <trans-unit id="f2dce957332c62c691a49ddcc68e31de7ff97f8b" translate="yes" xml:space="preserve">
          <source>If the array has no mask, the address of &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.nomask&quot;&gt;&lt;code&gt;nomask&lt;/code&gt;&lt;/a&gt; is returned. This address is typically not close to the data in memory:</source>
          <target state="translated">Если у массива нет маски, возвращается адрес &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.nomask&quot;&gt; &lt;code&gt;nomask&lt;/code&gt; &lt;/a&gt; . Этот адрес обычно не близок к данным в памяти:</target>
        </trans-unit>
        <trans-unit id="0e4bd5d4fdacecd1895716db48cb1cac490ae19c" translate="yes" xml:space="preserve">
          <source>If the array is not compatible with the new shape according to NumPy&amp;rsquo;s broadcasting rules.</source>
          <target state="translated">Если массив несовместим с новой формой в соответствии с правилами вещания NumPy.</target>
        </trans-unit>
        <trans-unit id="1b3a1026c96ba9547fc879c6163e5467ed414876" translate="yes" xml:space="preserve">
          <source>If the axis argument isn&amp;rsquo;t passed, your 2D array will be flattened.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9556db7609e9b52c8da71258e9ebc1e23d97b8b8" translate="yes" xml:space="preserve">
          <source>If the buffer has data that is not in machine byte-order, this should be specified as part of the data-type, e.g.:</source>
          <target state="translated">Если в буфере есть данные,которые не находятся в машинном байт-ордере,то это должно быть указано в составе типа данных,например</target>
        </trans-unit>
        <trans-unit id="707be1af574eabd0a2204881f5336941a1d0fb1f" translate="yes" xml:space="preserve">
          <source>If the columns have names, we can also select which columns to import by giving their name to the &lt;code&gt;usecols&lt;/code&gt; argument, either as a sequence of strings or a comma-separated string:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a9172eee727e3bc5966a060de8a7a54e3be2870d" translate="yes" xml:space="preserve">
          <source>If the common data type is known ahead of time, don&amp;rsquo;t use this flag. Instead, set the requested dtype for all the operands.</source>
          <target state="translated">Если общий тип данных известен заранее, не используйте этот флаг. Вместо этого установите запрошенный dtype для всех операндов.</target>
        </trans-unit>
        <trans-unit id="c0b42d9b2195e628dbcfcb8e55fe0f75a169d8db" translate="yes" xml:space="preserve">
          <source>If the condition is a callable, it is used at runtime to dynamically make the decision. This is useful for tests that may require costly imports, to delay the cost until the test suite is actually executed.</source>
          <target state="translated">Если условие является вызываемым,то оно используется во время выполнения для динамического принятия решения.Это полезно для тестов,которые могут потребовать дорогостоящего импорта,чтобы задержать стоимость до тех пор,пока тестовый набор не будет фактически выполнен.</target>
        </trans-unit>
        <trans-unit id="da8929bf843323251f47496e7bd27572472297dd" translate="yes" xml:space="preserve">
          <source>If the conversion is not possible</source>
          <target state="translated">Если преобразование невозможно</target>
        </trans-unit>
        <trans-unit id="bf41eeaf999250f9cdaa16bd479da6c16a96c8f5" translate="yes" xml:space="preserve">
          <source>If the ctypes module is not available, then the ctypes attribute of array objects still returns something useful, but ctypes objects are not returned and errors may be raised instead. In particular, the object will still have the &lt;code&gt;as_parameter&lt;/code&gt; attribute which will return an integer equal to the data attribute.</source>
          <target state="translated">Если модуль ctypes недоступен, то атрибут ctypes объектов массива по-прежнему возвращает что-то полезное, но объекты ctypes не возвращаются, и вместо этого могут возникать ошибки. В частности, объект по-прежнему будет иметь атрибут &lt;code&gt;as_parameter&lt;/code&gt; , который вернет целое число, равное атрибуту данных.</target>
        </trans-unit>
        <trans-unit id="882469c86c3e266d61a4e68ca724a4e1e6d70bb9" translate="yes" xml:space="preserve">
          <source>If the current domain is the interval &lt;code&gt;[l1, r1]&lt;/code&gt; and the window is &lt;code&gt;[l2, r2]&lt;/code&gt;, then the linear mapping function &lt;code&gt;L&lt;/code&gt; is defined by the equations:</source>
          <target state="translated">Если текущая область - это интервал &lt;code&gt;[l1, r1]&lt;/code&gt; а окно - &lt;code&gt;[l2, r2]&lt;/code&gt; , то функция линейного отображения &lt;code&gt;L&lt;/code&gt; определяется уравнениями:</target>
        </trans-unit>
        <trans-unit id="74cde2bcb160b06069d73cce52e519943212158c" translate="yes" xml:space="preserve">
          <source>If the data type is &lt;a href=&quot;../glossary#term-structured-data-type&quot;&gt;structured data type&lt;/a&gt;, an aggregate of other data types, (&lt;em&gt;e.g.&lt;/em&gt;, describing an array item consisting of an integer and a float),</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b7e4177a6acaf9fb51b7f55a4c29b9a1f7f66006" translate="yes" xml:space="preserve">
          <source>If the data type is &lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/glossary.html#term-structured-data-type&quot;&gt;structured data type&lt;/a&gt;, an aggregate of other data types, (&lt;em&gt;e.g.&lt;/em&gt;, describing an array item consisting of an integer and a float),</source>
          <target state="translated">Если тип данных является &lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/glossary.html#term-structured-data-type&quot;&gt;структурированным типом данных&lt;/a&gt; , совокупностью других типов данных ( &lt;em&gt;например&lt;/em&gt; , описывающий элемент массива, состоящий из целого числа и числа с плавающей запятой),</target>
        </trans-unit>
        <trans-unit id="0cecddf950b77d1003b9474189d29ff0bfdb6282" translate="yes" xml:space="preserve">
          <source>If the data type is a sub-array, what is its shape and data type.</source>
          <target state="translated">Если тип данных является подмассивом,то какова его форма и тип данных.</target>
        </trans-unit>
        <trans-unit id="5b7ff57105753a62bcfc1055c91f35344e435758" translate="yes" xml:space="preserve">
          <source>If the decomposition fails, for example, if &lt;code&gt;a&lt;/code&gt; is not positive-definite.</source>
          <target state="translated">Если разложение не удается, например, если &lt;code&gt;a&lt;/code&gt; не является положительно определенным.</target>
        </trans-unit>
        <trans-unit id="ee52413e2abf8d484ea3208ee7d3358a43d8e634" translate="yes" xml:space="preserve">
          <source>If the default value is passed, then &lt;code&gt;keepdims&lt;/code&gt; will not be passed through to the &lt;a href=&quot;#numpy.all&quot;&gt;&lt;code&gt;all&lt;/code&gt;&lt;/a&gt; method of sub-classes of &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt;, however any non-default value will be. If the sub-class&amp;rsquo; method does not implement &lt;code&gt;keepdims&lt;/code&gt; any exceptions will be raised.</source>
          <target state="translated">Если передается значение по умолчанию, то &lt;code&gt;keepdims&lt;/code&gt; не будет передаваться &lt;a href=&quot;#numpy.all&quot;&gt; &lt;code&gt;all&lt;/code&gt; &lt;/a&gt; методу подклассов &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt; , однако любое значение, отличное от значения по умолчанию, будет. Если метод подкласса не реализует &lt;code&gt;keepdims&lt;/code&gt; , будут возникать исключения.</target>
        </trans-unit>
        <trans-unit id="206ca5be0da6c825b1f0142de708ea22958f4d55" translate="yes" xml:space="preserve">
          <source>If the default value is passed, then &lt;code&gt;keepdims&lt;/code&gt; will not be passed through to the &lt;a href=&quot;#numpy.amax&quot;&gt;&lt;code&gt;amax&lt;/code&gt;&lt;/a&gt; method of sub-classes of &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt;, however any non-default value will be. If the sub-class&amp;rsquo; method does not implement &lt;code&gt;keepdims&lt;/code&gt; any exceptions will be raised.</source>
          <target state="translated">Если значение по умолчанию будет принято, то &lt;code&gt;keepdims&lt;/code&gt; не будет проходить через к &lt;a href=&quot;#numpy.amax&quot;&gt; &lt;code&gt;amax&lt;/code&gt; &lt;/a&gt; методе подклассов &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt; , однако любое значение не по умолчанию будет. Если метод подкласса не реализует &lt;code&gt;keepdims&lt;/code&gt; , будут возникать исключения.</target>
        </trans-unit>
        <trans-unit id="f05780b3efb83cb7999e12324775e7fa0e8c55fe" translate="yes" xml:space="preserve">
          <source>If the default value is passed, then &lt;code&gt;keepdims&lt;/code&gt; will not be passed through to the &lt;a href=&quot;#numpy.amin&quot;&gt;&lt;code&gt;amin&lt;/code&gt;&lt;/a&gt; method of sub-classes of &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt;, however any non-default value will be. If the sub-class&amp;rsquo; method does not implement &lt;code&gt;keepdims&lt;/code&gt; any exceptions will be raised.</source>
          <target state="translated">Если передается значение по умолчанию, то &lt;code&gt;keepdims&lt;/code&gt; не будут передаваться в метод &lt;a href=&quot;#numpy.amin&quot;&gt; &lt;code&gt;amin&lt;/code&gt; &lt;/a&gt; подклассов &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt; , однако любое значение, отличное от значения по умолчанию, будет. Если метод подкласса не реализует &lt;code&gt;keepdims&lt;/code&gt; , будут возникать исключения.</target>
        </trans-unit>
        <trans-unit id="4bb758877f868372bd36b970799d233d6c9b6b2e" translate="yes" xml:space="preserve">
          <source>If the default value is passed, then &lt;code&gt;keepdims&lt;/code&gt; will not be passed through to the &lt;a href=&quot;#numpy.any&quot;&gt;&lt;code&gt;any&lt;/code&gt;&lt;/a&gt; method of sub-classes of &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt;, however any non-default value will be. If the sub-class&amp;rsquo; method does not implement &lt;code&gt;keepdims&lt;/code&gt; any exceptions will be raised.</source>
          <target state="translated">Если передается значение по умолчанию, то &lt;code&gt;keepdims&lt;/code&gt; не будет передаваться в &lt;a href=&quot;#numpy.any&quot;&gt; &lt;code&gt;any&lt;/code&gt; &lt;/a&gt; метод подклассов &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt; , однако любое значение, не являющееся значением по умолчанию, будет. Если метод подкласса не реализует &lt;code&gt;keepdims&lt;/code&gt; , будут возникать исключения.</target>
        </trans-unit>
        <trans-unit id="4f36bf742dff79ee7a2535335e60a655538367af" translate="yes" xml:space="preserve">
          <source>If the default value is passed, then &lt;code&gt;keepdims&lt;/code&gt; will not be passed through to the &lt;a href=&quot;#numpy.ma.var&quot;&gt;&lt;code&gt;var&lt;/code&gt;&lt;/a&gt; method of sub-classes of &lt;code&gt;ndarray&lt;/code&gt;, however any non-default value will be. If the sub-class&amp;rsquo; method does not implement &lt;code&gt;keepdims&lt;/code&gt; any exceptions will be raised.</source>
          <target state="translated">Если передается значение по умолчанию, то &lt;code&gt;keepdims&lt;/code&gt; не будет передаваться в метод &lt;a href=&quot;#numpy.ma.var&quot;&gt; &lt;code&gt;var&lt;/code&gt; &lt;/a&gt; подклассов &lt;code&gt;ndarray&lt;/code&gt; , однако любое значение, отличное от значения по умолчанию, будет. Если метод подкласса не реализует &lt;code&gt;keepdims&lt;/code&gt; , будут возникать исключения.</target>
        </trans-unit>
        <trans-unit id="e936312beb89ed94ea31f46b832a3128132ea8c3" translate="yes" xml:space="preserve">
          <source>If the default value is passed, then &lt;code&gt;keepdims&lt;/code&gt; will not be passed through to the &lt;a href=&quot;#numpy.mean&quot;&gt;&lt;code&gt;mean&lt;/code&gt;&lt;/a&gt; method of sub-classes of &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt;, however any non-default value will be. If the sub-class&amp;rsquo; method does not implement &lt;code&gt;keepdims&lt;/code&gt; any exceptions will be raised.</source>
          <target state="translated">Если передается значение по умолчанию, то &lt;code&gt;keepdims&lt;/code&gt; не будет передаваться &lt;a href=&quot;#numpy.mean&quot;&gt; &lt;code&gt;mean&lt;/code&gt; &lt;/a&gt; методу подклассов &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt; , однако любое значение, отличное от значения по умолчанию, будет. Если метод подкласса не реализует &lt;code&gt;keepdims&lt;/code&gt; , будут возникать исключения.</target>
        </trans-unit>
        <trans-unit id="cccfcc112e296f9db67affb5426a407a1e1b1ab3" translate="yes" xml:space="preserve">
          <source>If the default value is passed, then &lt;code&gt;keepdims&lt;/code&gt; will not be passed through to the &lt;a href=&quot;#numpy.prod&quot;&gt;&lt;code&gt;prod&lt;/code&gt;&lt;/a&gt; method of sub-classes of &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt;, however any non-default value will be. If the sub-class&amp;rsquo; method does not implement &lt;code&gt;keepdims&lt;/code&gt; any exceptions will be raised.</source>
          <target state="translated">Если передается значение по умолчанию, то &lt;code&gt;keepdims&lt;/code&gt; не будут передаваться методу &lt;a href=&quot;#numpy.prod&quot;&gt; &lt;code&gt;prod&lt;/code&gt; &lt;/a&gt; подклассов &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt; , однако любое значение, отличное от значения по умолчанию, будет. Если метод подкласса не реализует &lt;code&gt;keepdims&lt;/code&gt; , будут возникать исключения.</target>
        </trans-unit>
        <trans-unit id="f6aec8996590d19051796274c83c4f7439695ce8" translate="yes" xml:space="preserve">
          <source>If the default value is passed, then &lt;code&gt;keepdims&lt;/code&gt; will not be passed through to the &lt;a href=&quot;#numpy.ptp&quot;&gt;&lt;code&gt;ptp&lt;/code&gt;&lt;/a&gt; method of sub-classes of &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt;, however any non-default value will be. If the sub-class&amp;rsquo; method does not implement &lt;code&gt;keepdims&lt;/code&gt; any exceptions will be raised.</source>
          <target state="translated">Если передается значение по умолчанию, то &lt;code&gt;keepdims&lt;/code&gt; не будет передаваться в метод &lt;a href=&quot;#numpy.ptp&quot;&gt; &lt;code&gt;ptp&lt;/code&gt; &lt;/a&gt; подклассов &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt; , однако любое значение, отличное от значения по умолчанию, будет. Если метод подкласса не реализует &lt;code&gt;keepdims&lt;/code&gt; , будут возникать исключения.</target>
        </trans-unit>
        <trans-unit id="04b4fba4bb9497e64959763e9e88bb419b385930" translate="yes" xml:space="preserve">
          <source>If the default value is passed, then &lt;code&gt;keepdims&lt;/code&gt; will not be passed through to the &lt;a href=&quot;#numpy.std&quot;&gt;&lt;code&gt;std&lt;/code&gt;&lt;/a&gt; method of sub-classes of &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt;, however any non-default value will be. If the sub-class&amp;rsquo; method does not implement &lt;code&gt;keepdims&lt;/code&gt; any exceptions will be raised.</source>
          <target state="translated">Если передается значение по умолчанию, то &lt;code&gt;keepdims&lt;/code&gt; не будут передаваться в метод &lt;a href=&quot;#numpy.std&quot;&gt; &lt;code&gt;std&lt;/code&gt; &lt;/a&gt; подклассов &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt; , однако любое значение, отличное от значения по умолчанию, будет. Если метод подкласса не реализует &lt;code&gt;keepdims&lt;/code&gt; , будут возникать исключения.</target>
        </trans-unit>
        <trans-unit id="3ec6e98470abd2d3a8abe5e8029889dd09ba623f" translate="yes" xml:space="preserve">
          <source>If the default value is passed, then &lt;code&gt;keepdims&lt;/code&gt; will not be passed through to the &lt;a href=&quot;#numpy.sum&quot;&gt;&lt;code&gt;sum&lt;/code&gt;&lt;/a&gt; method of sub-classes of &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt;, however any non-default value will be. If the sub-class&amp;rsquo; method does not implement &lt;code&gt;keepdims&lt;/code&gt; any exceptions will be raised.</source>
          <target state="translated">Если передается значение по умолчанию, то &lt;code&gt;keepdims&lt;/code&gt; не будут переданы в метод &lt;a href=&quot;#numpy.sum&quot;&gt; &lt;code&gt;sum&lt;/code&gt; &lt;/a&gt; подклассов &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt; , однако любое значение, отличное от значения по умолчанию, будет. Если метод подкласса не реализует &lt;code&gt;keepdims&lt;/code&gt; , будут возникать исключения.</target>
        </trans-unit>
        <trans-unit id="2d09798a597d9e0c839ab8917b5d5016554acbc8" translate="yes" xml:space="preserve">
          <source>If the default value is passed, then &lt;code&gt;keepdims&lt;/code&gt; will not be passed through to the &lt;a href=&quot;#numpy.var&quot;&gt;&lt;code&gt;var&lt;/code&gt;&lt;/a&gt; method of sub-classes of &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt;, however any non-default value will be. If the sub-class&amp;rsquo; method does not implement &lt;code&gt;keepdims&lt;/code&gt; any exceptions will be raised.</source>
          <target state="translated">Если передается значение по умолчанию, то &lt;code&gt;keepdims&lt;/code&gt; не будет передаваться в метод &lt;a href=&quot;#numpy.var&quot;&gt; &lt;code&gt;var&lt;/code&gt; &lt;/a&gt; подклассов &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt; , однако любое значение, отличное от значения по умолчанию, будет. Если метод подкласса не реализует &lt;code&gt;keepdims&lt;/code&gt; , будут возникать исключения.</target>
        </trans-unit>
        <trans-unit id="83795d27b8fbf6727fc73ba1d3ba1433b7f48097" translate="yes" xml:space="preserve">
          <source>If the default value is passed, then &lt;code&gt;keepdims&lt;/code&gt; will not be passed through to the &lt;a href=&quot;numpy.ma.var#numpy.ma.var&quot;&gt;&lt;code&gt;var&lt;/code&gt;&lt;/a&gt; method of sub-classes of &lt;code&gt;ndarray&lt;/code&gt;, however any non-default value will be. If the sub-class&amp;rsquo; method does not implement &lt;code&gt;keepdims&lt;/code&gt; any exceptions will be raised.</source>
          <target state="translated">Если передается значение по умолчанию, то &lt;code&gt;keepdims&lt;/code&gt; не будет передаваться в метод &lt;a href=&quot;numpy.ma.var#numpy.ma.var&quot;&gt; &lt;code&gt;var&lt;/code&gt; &lt;/a&gt; подклассов &lt;code&gt;ndarray&lt;/code&gt; , однако любое значение, отличное от значения по умолчанию, будет. Если метод подкласса не реализует &lt;code&gt;keepdims&lt;/code&gt; , будут возникать исключения.</target>
        </trans-unit>
        <trans-unit id="f36f9bb6a297ac4fc949ef700d42398954026ba5" translate="yes" xml:space="preserve">
          <source>If the dimension of &lt;code&gt;a&lt;/code&gt; is less than 2.</source>
          <target state="translated">Если размер &lt;code&gt;a&lt;/code&gt; меньше 2.</target>
        </trans-unit>
        <trans-unit id="a923921d01ae62bb1aaf773e7e11bc37201f68aa" translate="yes" xml:space="preserve">
          <source>If the discontinuity in &lt;code&gt;p&lt;/code&gt; is smaller than &lt;code&gt;pi&lt;/code&gt;, but larger than &lt;code&gt;discont&lt;/code&gt;, no unwrapping is done because taking the 2*pi complement would only make the discontinuity larger.</source>
          <target state="translated">Если разрыв в &lt;code&gt;p&lt;/code&gt; меньше, чем &lt;code&gt;pi&lt;/code&gt; , но больше, чем &lt;code&gt;discont&lt;/code&gt; , разворачивание не производится, потому что взятие дополнения 2 * pi только увеличило бы разрыв.</target>
        </trans-unit>
        <trans-unit id="dd1746ba40294ba18df6698853992dfa2b70977c" translate="yes" xml:space="preserve">
          <source>If the dtypes of two void structured arrays are equal, testing the equality of the arrays will result in a boolean array with the dimensions of the original arrays, with elements set to &lt;code&gt;True&lt;/code&gt; where all fields of the corresponding structures are equal. Structured dtypes are equal if the field names, dtypes and titles are the same, ignoring endianness, and the fields are in the same order:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="769e103ab2e97d0544e3e9203d0c4335be336adf" translate="yes" xml:space="preserve">
          <source>If the eigenvalue computation does not converge.</source>
          <target state="translated">Если вычисление собственного значения не сходится.</target>
        </trans-unit>
        <trans-unit id="18adc01c0eaa64bd3fe6f5b836944558dd579c54" translate="yes" xml:space="preserve">
          <source>If the element you&amp;rsquo;re looking for doesn&amp;rsquo;t exist in the array, then the returned array of indices will be empty. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae5f5ebbdda43d87574658252f8456304a3e6d83" translate="yes" xml:space="preserve">
          <source>If the file contains pickle data, then whatever object is stored in the pickle is returned.</source>
          <target state="translated">Если файл содержит данные о пикуле,то возвращается объект,сохраненный в пикулете.</target>
        </trans-unit>
        <trans-unit id="52f9285704aeec7c0050eb73ae0eedae9e536c15" translate="yes" xml:space="preserve">
          <source>If the file is a &lt;code&gt;.npy&lt;/code&gt; file, then a single array is returned.</source>
          <target state="translated">Если файл является файлом &lt;code&gt;.npy&lt;/code&gt; , возвращается единственный массив.</target>
        </trans-unit>
        <trans-unit id="c850dbbea34f89942e452ade066952afb4aff87b" translate="yes" xml:space="preserve">
          <source>If the file is a &lt;code&gt;.npz&lt;/code&gt; file, the returned value supports the context manager protocol in a similar fashion to the open function:</source>
          <target state="translated">Если файл является файлом &lt;code&gt;.npz&lt;/code&gt; , возвращаемое значение поддерживает протокол диспетчера контекста аналогично функции open:</target>
        </trans-unit>
        <trans-unit id="6dd34773e8e6fce245333f3661e9174ce50590a5" translate="yes" xml:space="preserve">
          <source>If the file is a &lt;code&gt;.npz&lt;/code&gt; file, then a dictionary-like object is returned, containing &lt;code&gt;{filename: array}&lt;/code&gt; key-value pairs, one for each file in the archive.</source>
          <target state="translated">Если файл является файлом &lt;code&gt;.npz&lt;/code&gt; , то возвращается объект, подобный словарю, содержащий пары ключ-значение &lt;code&gt;{filename: array}&lt;/code&gt; , по одной для каждого файла в архиве.</target>
        </trans-unit>
        <trans-unit id="3eb136618e35fc45bcfb6109a519b0397c62a7f3" translate="yes" xml:space="preserve">
          <source>If the filename ends in &lt;code&gt;.gz&lt;/code&gt;, the file is automatically saved in compressed gzip format. &lt;a href=&quot;numpy.loadtxt#numpy.loadtxt&quot;&gt;&lt;code&gt;loadtxt&lt;/code&gt;&lt;/a&gt; understands gzipped files transparently.</source>
          <target state="translated">Если имя файла заканчивается на &lt;code&gt;.gz&lt;/code&gt; , файл автоматически сохраняется в сжатом формате gzip. &lt;a href=&quot;numpy.loadtxt#numpy.loadtxt&quot;&gt; &lt;code&gt;loadtxt&lt;/code&gt; &lt;/a&gt; понимает файлы с gzip'нутыми прозрачно.</target>
        </trans-unit>
        <trans-unit id="3cd5e67735dce4fe85460703c53dc9836515a450" translate="yes" xml:space="preserve">
          <source>If the first argument is 1-D it is treated as a row vector. If the last argument is 1-D it is treated as a column vector. The other arguments must be 2-D.</source>
          <target state="translated">Если первым аргументом является 1-D,то он рассматривается как строковый вектор.Если последним аргументом является 1-D,то он обрабатывается как вектор столбца.Остальные аргументы должны быть 2-D.</target>
        </trans-unit>
        <trans-unit id="02ed5193bd3dcf84d786340881fcb3d577ef57f7" translate="yes" xml:space="preserve">
          <source>If the first argument is 1-D it is treated as row vector. If the last argument is 1-D it is treated as column vector. The other arguments must be 2-D.</source>
          <target state="translated">Если первым аргументом является 1-D,то он обрабатывается как строковый вектор.Если последним аргументом является 1-D,то он обрабатывается как вектор столбца.Остальные аргументы должны быть 2-D.</target>
        </trans-unit>
        <trans-unit id="0a74c0a74431c3bd3b43bf07934fe3d61fd80338" translate="yes" xml:space="preserve">
          <source>If the first argument is 1-D, it is promoted to a matrix by prepending a 1 to its dimensions. After matrix multiplication the prepended 1 is removed.</source>
          <target state="translated">Если первым аргументом является 1-D,то он переходит в матрицу,преобразуя 1 в ее размеры.После умножения матрицы префикс 1 удаляется.</target>
        </trans-unit>
        <trans-unit id="89db4e5dab2cb1ce35a7fb31edd3413095e85f3c" translate="yes" xml:space="preserve">
          <source>If the first argument is a tuple, other arguments are ignored:</source>
          <target state="translated">Если первым аргументом является кортеж,другие аргументы игнорируются:</target>
        </trans-unit>
        <trans-unit id="727e22f05290aaa6c2959157d7df0bc582e3c538" translate="yes" xml:space="preserve">
          <source>If the following equation is element-wise True, then &lt;a href=&quot;#numpy.ma.allclose&quot;&gt;&lt;code&gt;allclose&lt;/code&gt;&lt;/a&gt; returns True:</source>
          <target state="translated">Если следующее уравнение поэлементно &lt;a href=&quot;#numpy.ma.allclose&quot;&gt; &lt;code&gt;allclose&lt;/code&gt; &lt;/a&gt; , то allclose возвращает True:</target>
        </trans-unit>
        <trans-unit id="94cbab458f248cbb972811c2359461201e9861d5" translate="yes" xml:space="preserve">
          <source>If the following equation is element-wise True, then allclose returns True.</source>
          <target state="translated">Если следующее уравнение является element-wise True,то Allclose возвращает True.</target>
        </trans-unit>
        <trans-unit id="1386561a26e41c95c312db50b7ef52259e4517da" translate="yes" xml:space="preserve">
          <source>If the given strings are equal, &lt;a href=&quot;#numpy.testing.assert_string_equal&quot;&gt;&lt;code&gt;assert_string_equal&lt;/code&gt;&lt;/a&gt; does nothing. If they are not equal, an AssertionError is raised, and the diff between the strings is shown.</source>
          <target state="translated">Если указанные строки равны, &lt;a href=&quot;#numpy.testing.assert_string_equal&quot;&gt; &lt;code&gt;assert_string_equal&lt;/code&gt; &lt;/a&gt; ничего не делает. Если они не равны, возникает ошибка AssertionError и отображается разница между строками.</target>
        </trans-unit>
        <trans-unit id="f5f5e437a85f1a89c55d54e0a09b57161df68a13" translate="yes" xml:space="preserve">
          <source>If the header file that contains the prototype for &lt;code&gt;double dot()&lt;/code&gt; also contains other prototypes that you want to wrap, so that you need to &lt;code&gt;%include&lt;/code&gt; this header file, then you will also need a &lt;code&gt;%ignore
dot;&lt;/code&gt; directive, placed after the &lt;code&gt;%rename&lt;/code&gt; and before the &lt;code&gt;%include&lt;/code&gt; directives. Or, if the function in question is a class method, you will want to use &lt;code&gt;%extend&lt;/code&gt; rather than &lt;code&gt;%inline&lt;/code&gt; in addition to &lt;code&gt;%ignore&lt;/code&gt;.</source>
          <target state="translated">Если файл заголовка, содержащий прототип для &lt;code&gt;double dot()&lt;/code&gt; также содержит другие прототипы, которые вы хотите обернуть, так что вам нужно &lt;code&gt;%include&lt;/code&gt; этот файл заголовка, тогда вам также понадобится &lt;code&gt;%ignore dot;&lt;/code&gt; после директивы &lt;code&gt;%rename&lt;/code&gt; и перед директивами &lt;code&gt;%include&lt;/code&gt; . Или, если рассматриваемая функция является методом класса, вы захотите использовать &lt;code&gt;%extend&lt;/code&gt; вместо &lt;code&gt;%inline&lt;/code&gt; в дополнение к &lt;code&gt;%ignore&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7e4a3d5e2d4e2e2a3ebb889979e38306c67da7f4" translate="yes" xml:space="preserve">
          <source>If the index arrays do not have the same shape, there is an attempt to broadcast them to the same shape. If they cannot be broadcast to the same shape, an exception is raised:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f745354786d48a61873aeb74a86c334de5c7a7b4" translate="yes" xml:space="preserve">
          <source>If the index expression contains comma separated arrays, then stack them along their first axis.</source>
          <target state="translated">Если выражение индекса содержит массивы,разделенные запятыми,то укладывайте их по первой оси.</target>
        </trans-unit>
        <trans-unit id="34ad012e6ac2224c1d99e1fa90fb54c844437b0d" translate="yes" xml:space="preserve">
          <source>If the index expression contains slice notation or scalars then create a 1-D array with a range indicated by the slice notation.</source>
          <target state="translated">Если индексное выражение содержит нотацию среза или скаляры,то создается 1-D массив с диапазоном,указанным нотацией среза.</target>
        </trans-unit>
        <trans-unit id="70dea339f55810f6be3e1b0c9e7aefd88107ebbf" translate="yes" xml:space="preserve">
          <source>If the input &lt;code&gt;a&lt;/code&gt; contains an imaginary part, it is silently discarded.</source>
          <target state="translated">Если вход &lt;code&gt;a&lt;/code&gt; содержит мнимую часть, она автоматически отбрасывается.</target>
        </trans-unit>
        <trans-unit id="4637e99d70ef2c1cb40679370ac10807b840a3f4" translate="yes" xml:space="preserve">
          <source>If the input file does not exist or cannot be read.</source>
          <target state="translated">Если входной файл не существует или не может быть прочитан.</target>
        </trans-unit>
        <trans-unit id="bbf06b38d2758769a67207876edd570ca41378d4" translate="yes" xml:space="preserve">
          <source>If the input has a integer type the function is equivalent to np.max.</source>
          <target state="translated">Если вход имеет целочисленный тип,то функция эквивалентна np.max.</target>
        </trans-unit>
        <trans-unit id="7895a434c9eeafd563766c2013458a9eca1c5fea" translate="yes" xml:space="preserve">
          <source>If the input has a integer type the function is equivalent to np.min.</source>
          <target state="translated">Если вход имеет целочисленный тип,то функция эквивалентна np.min.</target>
        </trans-unit>
        <trans-unit id="b307c09a45c4aabb639976a619f0171d6a01d0dd" translate="yes" xml:space="preserve">
          <source>If the input is 2d and axis is specified, the result is a list of lists.</source>
          <target state="translated">Если вход 2d и указана ось,то в результате получается список списков.</target>
        </trans-unit>
        <trans-unit id="7ed38fa8c8d2f0a335bd5a040aeda16b9d1b796e" translate="yes" xml:space="preserve">
          <source>If the input is not 1-dimensional, or contains elements with negative values, or if &lt;code&gt;minlength&lt;/code&gt; is negative.</source>
          <target state="translated">Если входные данные не одномерные, или содержат элементы с отрицательными значениями, или если &lt;code&gt;minlength&lt;/code&gt; отрицательное значение.</target>
        </trans-unit>
        <trans-unit id="10296cda117e24158759559beefea304129412f0" translate="yes" xml:space="preserve">
          <source>If the input parameter &lt;code&gt;n&lt;/code&gt; is larger than the size of the input, the input is padded by appending zeros at the end. Even though this is the common approach, it might lead to surprising results. If a different padding is desired, it must be performed before calling &lt;a href=&quot;#numpy.fft.ifft&quot;&gt;&lt;code&gt;ifft&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Если входной параметр &lt;code&gt;n&lt;/code&gt; больше, чем размер входных данных, входные данные дополняются добавлением нулей в конце. Несмотря на то, что это обычный подход, он может привести к неожиданным результатам. Если требуется другое заполнение, его необходимо выполнить перед вызовом &lt;a href=&quot;#numpy.fft.ifft&quot;&gt; &lt;code&gt;ifft&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3fc060b3dda78a5634929550749227bb1804a61d" translate="yes" xml:space="preserve">
          <source>If the inputs are ndarrays, then np.greater is equivalent to &amp;lsquo;&amp;gt;&amp;rsquo;.</source>
          <target state="translated">Если входные данные - ndarrays, то np.greater эквивалентно '&amp;gt;'.</target>
        </trans-unit>
        <trans-unit id="36e6b94197e7b6e49557830166101a92fecb27ad" translate="yes" xml:space="preserve">
          <source>If the inputs or dtype are complex, the output will follow a logarithmic spiral in the complex plane. (There are an infinite number of spirals passing through two points; the output will follow the shortest such path.)</source>
          <target state="translated">Если входы или тип d являются сложными,то выход будет следовать логарифмической спирали в комплексной плоскости.(Существует бесконечное количество спиралей,проходящих через две точки;выход будет идти по кратчайшему такому пути).</target>
        </trans-unit>
        <trans-unit id="ce8f1e8f63cbe617564d9cd3d7c5c8bc3e2530ae" translate="yes" xml:space="preserve">
          <source>If the iterator is buffered, returns the size of the buffer being used, otherwise returns 0.</source>
          <target state="translated">Если итератор буферизован,возвращает размер используемого буфера,в противном случае возвращает 0.</target>
        </trans-unit>
        <trans-unit id="f3c918834625c8823bdade73b25f11346749b818" translate="yes" xml:space="preserve">
          <source>If the iterator is tracking a multi-index, this strips support for them, and does further iterator optimizations that are possible if multi-indices are not needed. This function also resets the iterator to its initial state.</source>
          <target state="translated">Если итератор отслеживает мультииндекс,то этот полоска поддерживает его,и делает дальнейшие оптимизации итератора,которые возможны,если мультииндексы не нужны.Эта функция также сбрасывает итератор в начальное состояние.</target>
        </trans-unit>
        <trans-unit id="7df15990c36906ed5503360d9305db9b7bfe762b" translate="yes" xml:space="preserve">
          <source>If the last dimension of &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; has different size.</source>
          <target state="translated">Если последний размер &lt;code&gt;a&lt;/code&gt; и &lt;code&gt;b&lt;/code&gt; имеет разный размер.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
