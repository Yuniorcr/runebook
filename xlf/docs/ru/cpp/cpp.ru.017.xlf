<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="cpp">
    <body>
      <group id="cpp">
        <trans-unit id="7e427ab8b4862191565a1a29a01d981f9c08b30f" translate="yes" xml:space="preserve">
          <source>Increment and decrement</source>
          <target state="translated">Инкремент и декремент</target>
        </trans-unit>
        <trans-unit id="cfe414b6ddcaa8292d016a5a3592ec3f7ea7fada" translate="yes" xml:space="preserve">
          <source>Increment and decrement operators are overloaded for many standard library types. In particular, every &lt;a href=&quot;../named_req/iterator&quot;&gt;LegacyIterator&lt;/a&gt; overloads operator++ and every &lt;a href=&quot;../named_req/bidirectionaliterator&quot;&gt;LegacyBidirectionalIterator&lt;/a&gt; overloads operator--, even if those operators are no-ops for the particular iterator.</source>
          <target state="translated">Операторы увеличения и уменьшения перегружены для многих стандартных типов библиотек. В частности, каждый &lt;a href=&quot;../named_req/iterator&quot;&gt;LegacyIterator&lt;/a&gt; перегружает оператор ++ и каждый &lt;a href=&quot;../named_req/bidirectionaliterator&quot;&gt;LegacyBidirectionalIterator&lt;/a&gt; перегружает оператор - даже если эти операторы не выполняются для конкретного итератора.</target>
        </trans-unit>
        <trans-unit id="f17d70be0f16733c0dc8c67eabfb624d43b60216" translate="yes" xml:space="preserve">
          <source>Increment/decrement operators</source>
          <target state="translated">Операторы инкремента/декремента</target>
        </trans-unit>
        <trans-unit id="cc787748953bd4e94e67cc95ac787d4d3cfb9a68" translate="yes" xml:space="preserve">
          <source>Increment/decrement operators increment or decrement the value of the object.</source>
          <target state="translated">Операторы инкремента/декрементации увеличивают или уменьшают значение объекта.</target>
        </trans-unit>
        <trans-unit id="0f9b5e452f10a6b34da1fb48e02ee30bd5033db1" translate="yes" xml:space="preserve">
          <source>Incrementable</source>
          <target state="translated">Incrementable</target>
        </trans-unit>
        <trans-unit id="cc5ea811af56aeeaf46a0c9737e89031c9af2a17" translate="yes" xml:space="preserve">
          <source>Increments given iterator &lt;code&gt;it&lt;/code&gt; by &lt;code&gt;n&lt;/code&gt; elements.</source>
          <target state="translated">Приращение дано итератор &lt;code&gt;it&lt;/code&gt; по &lt;code&gt;n&lt;/code&gt; элементов.</target>
        </trans-unit>
        <trans-unit id="e3348f80bc84ba16802159a506f193e84a80b03d" translate="yes" xml:space="preserve">
          <source>Increments or decrements the iterator.</source>
          <target state="translated">Увеличивает или укажет итератор.</target>
        </trans-unit>
        <trans-unit id="84c43591c7009c31f153f3e91418e222e8d0fdab" translate="yes" xml:space="preserve">
          <source>Increments or decrements the iterator. Inverse operations are applied to the underlying operator because of the reverse order.</source>
          <target state="translated">Увеличивает или укажет итератор.Обратные операции применяются к базовому оператору из-за обратного ордера.</target>
        </trans-unit>
        <trans-unit id="39764a20978ad7b2e0a6b9bd65f20bac9b65b929" translate="yes" xml:space="preserve">
          <source>Increments or decrements the number of ticks for this duration.</source>
          <target state="translated">Увеличивает или уменьшает количество тиков за эту продолжительность.</target>
        </trans-unit>
        <trans-unit id="910224cadb5c448e8d25dd0213abaae95c58e5ea" translate="yes" xml:space="preserve">
          <source>Index into the array pointed to by the stored pointer.</source>
          <target state="translated">Индекс в массив,на который указывает хранимый указатель.</target>
        </trans-unit>
        <trans-unit id="9d3b08115f1b71f8141facbb6d5edfd271773b19" translate="yes" xml:space="preserve">
          <source>Indicated by a trailing &lt;code&gt;...&lt;/code&gt;(other than one introducing a pack expansion)(since C++11) following the parameter-list of a &lt;a href=&quot;function&quot;&gt;function declaration&lt;/a&gt;.</source>
          <target state="translated">Обозначается завершающим &lt;code&gt;...&lt;/code&gt; (кроме того, который вводит расширение пакета) (начиная с C ++ 11) после списка параметров &lt;a href=&quot;function&quot;&gt;объявления функции&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d49ada4a4f9e6394d6c031cdd3db87968627070f" translate="yes" xml:space="preserve">
          <source>Indicated by using the following syntax for a parameter in the parameter-list of a &lt;a href=&quot;function&quot;&gt;function declaration&lt;/a&gt;.</source>
          <target state="translated">Обозначается с помощью следующего синтаксиса для параметра в списке параметров &lt;a href=&quot;function&quot;&gt;объявления функции&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1712d2e8f937518e01b0931bd205206ed1a8017a" translate="yes" xml:space="preserve">
          <source>Indicates if the match results are ready (valid) or not.</source>
          <target state="translated">Показывает,готовы ли результаты матча (действительны)или нет.</target>
        </trans-unit>
        <trans-unit id="05d56af25aa45704ec160c601a10df5e1c115f08" translate="yes" xml:space="preserve">
          <source>Indicates if this match was successful</source>
          <target state="translated">Показывает,было ли это совпадение успешным</target>
        </trans-unit>
        <trans-unit id="fb13d85a03c61cb1a77aee405db444e1e7dd0d1e" translate="yes" xml:space="preserve">
          <source>Indicates that dependency chain in release-consume &lt;code&gt;&lt;a href=&quot;../../atomic/memory_order&quot;&gt;std::memory_order&lt;/a&gt;&lt;/code&gt; propagates in and out of the function, which allows the compiler to skip unnecessary memory fence instructions.</source>
          <target state="translated">Указывает, что цепочка зависимостей в выпуске-потреблении &lt;code&gt;&lt;a href=&quot;../../atomic/memory_order&quot;&gt;std::memory_order&lt;/a&gt;&lt;/code&gt; распространяется внутри и вне функции, что позволяет компилятору пропускать ненужные инструкции по ограничению памяти.</target>
        </trans-unit>
        <trans-unit id="b1eef975978a88d290550921db3dd4b23de6ed3c" translate="yes" xml:space="preserve">
          <source>Indicates that the fall through from the previous case label is intentional and should not be diagnosed by a compiler that warns on fallthrough.</source>
          <target state="translated">Указывает на то,что падение с предыдущей метки случая является преднамеренным и не должно диагностироваться компилятором,который предупреждает о падении.</target>
        </trans-unit>
        <trans-unit id="07a894f6f65f599ff826de67eb639e25aa960be1" translate="yes" xml:space="preserve">
          <source>Indicates that the function definition should be optimized for invocation from a &lt;a href=&quot;../transactional_memory&quot;&gt;synchronized statement&lt;/a&gt;.</source>
          <target state="translated">Указывает, что определение функции должно быть оптимизировано для вызова из &lt;a href=&quot;../transactional_memory&quot;&gt;синхронизированного оператора&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="404bc23b0c3c1dc2dde1e96665adb2a133cb2f1a" translate="yes" xml:space="preserve">
          <source>Indicates that the function definition should be optimized for invocation from a &lt;a href=&quot;../transactional_memory&quot;&gt;synchronized statement&lt;/a&gt;. In particular, it avoids serializing synchronized blocks that make a call to a function that is transaction-safe for the majority of calls, but not for all calls.</source>
          <target state="translated">Указывает, что определение функции должно быть оптимизировано для вызова из &lt;a href=&quot;../transactional_memory&quot;&gt;синхронизированного оператора&lt;/a&gt; . В частности, он избегает сериализации синхронизированных блоков, которые делают вызов функции, которая безопасна для транзакций для большинства вызовов, но не для всех вызовов.</target>
        </trans-unit>
        <trans-unit id="3763a0ac1424ab7603605b2e6e73c73516778f16" translate="yes" xml:space="preserve">
          <source>Indicates that the function does not return.</source>
          <target state="translated">Указывает на то,что функция не возвращается.</target>
        </trans-unit>
        <trans-unit id="aadf5ff318f6e9ff51544f26ee3de70c127e4ff5" translate="yes" xml:space="preserve">
          <source>Indicates that the name or entity declared with this attribute is &lt;a href=&quot;https://en.wikipedia.org/wiki/Deprecation&quot;&gt;deprecated&lt;/a&gt;, that is, the use is allowed, but discouraged for some reason.</source>
          <target state="translated">Указывает, что имя или сущность, объявленные с этим атрибутом, &lt;a href=&quot;https://en.wikipedia.org/wiki/Deprecation&quot;&gt;устарели&lt;/a&gt; , то есть использование разрешено, но по какой-то причине не рекомендуется.</target>
        </trans-unit>
        <trans-unit id="eb1d4e9c5ff0d33dedb5c76e1e3e0a72c774ec1e" translate="yes" xml:space="preserve">
          <source>Indicates that the use of the name or entity declared with this attribute is allowed, but discouraged for some reason. Compilers typically issue warnings on such uses. The string-literal, if specified, is usually included in the warnings.</source>
          <target state="translated">Указывает на то,что использование имени или сущности,объявленной с данным атрибутом,разрешено,но по каким-то причинам запрещено.Как правило,компиляторы выдают предупреждения о таком использовании.Строково-литературный,если он указан,обычно включается в предупреждения.</target>
        </trans-unit>
        <trans-unit id="1b877dccdb68430deec81ae5c7d0c2899c1a04b6" translate="yes" xml:space="preserve">
          <source>Indicates that this data member need not have an address distinct from all other non-static data members of its class.</source>
          <target state="translated">Указывает на то,что этот член данных не обязательно должен иметь адрес,отличный от всех других нестатических членов его класса.</target>
        </trans-unit>
        <trans-unit id="6a97cea227e92a547c1dd0162d3c17f7d0180b0c" translate="yes" xml:space="preserve">
          <source>Indicates that this data member need not have an address distinct from all other non-static data members of its class. This means that if the member has an empty type (e.g. stateless Allocator), the compiler may optimise it to occupy no space, just like if it were an &lt;a href=&quot;../ebo&quot;&gt;empty base&lt;/a&gt;. If the member is not empty, any tail padding in it may be also reused to store other data members.</source>
          <target state="translated">Указывает, что этот член данных не должен иметь адрес, отличный от всех других нестатических членов данных своего класса. Это означает, что если элемент имеет пустой тип (например, Allocator без сохранения состояния), компилятор может оптимизировать его, чтобы он не занимал места, как если бы он был &lt;a href=&quot;../ebo&quot;&gt;пустой базой&lt;/a&gt; . Если элемент не пустой, любой хвостовой отступ в нем также может быть повторно использован для хранения других элементов данных.</target>
        </trans-unit>
        <trans-unit id="7e16e5df080d66d35fd0fc9ce14ca2cddaaf531e" translate="yes" xml:space="preserve">
          <source>Indicates the endianness of all &lt;a href=&quot;../language/type-id&quot;&gt;scalar types&lt;/a&gt;:</source>
          <target state="translated">Указывает на порядковый номер всех &lt;a href=&quot;../language/type-id&quot;&gt;скалярных типов&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="b7ced8b89669e17290208433d069c305c4668cd4" translate="yes" xml:space="preserve">
          <source>Indirect access</source>
          <target state="translated">Косвенный доступ</target>
        </trans-unit>
        <trans-unit id="945f4467f9e3980b9bc435c192be55e1cdba33ac" translate="yes" xml:space="preserve">
          <source>Indirect callable concepts</source>
          <target state="translated">непрямые вызываемые понятия</target>
        </trans-unit>
        <trans-unit id="615d0df84a8bde5c3b3b45942556ad9ee41f5c88" translate="yes" xml:space="preserve">
          <source>IndirectRelation</source>
          <target state="translated">IndirectRelation</target>
        </trans-unit>
        <trans-unit id="a517704fa906449a7f15a8ece89573834bd716d4" translate="yes" xml:space="preserve">
          <source>IndirectStrictWeakOrder</source>
          <target state="translated">IndirectStrictWeakOrder</target>
        </trans-unit>
        <trans-unit id="4fd88b3054ecad93f1a95a527c3891631b31f23d" translate="yes" xml:space="preserve">
          <source>IndirectUnaryInvocableIndirectRegularUnaryInvocable</source>
          <target state="translated">IndirectUnaryInvocableIndirectRegularUnaryInvocable</target>
        </trans-unit>
        <trans-unit id="d4d035f7c30e113629f27edd40bf70e82d6284b2" translate="yes" xml:space="preserve">
          <source>IndirectUnaryPredicate</source>
          <target state="translated">IndirectUnaryPredicate</target>
        </trans-unit>
        <trans-unit id="1ba4d5bf8c849bf8c04b9c6e21cc8e1df44157c8" translate="yes" xml:space="preserve">
          <source>Indirection through a pointer that became invalid in this manner and passing it to a deallocation function (double-delete) is undefined behavior. Any other use is implementation-defined.</source>
          <target state="translated">Индримация через указатель,который таким образом стал недействительным,и передача его в функцию дилокации (double-delete)является неопределенным поведением.Любое другое использование является реализацией.</target>
        </trans-unit>
        <trans-unit id="fc6c8e1f0dc3858c691ccb1300793e524ab1874b" translate="yes" xml:space="preserve">
          <source>Indirection through an invalid pointer value and passing an invalid pointer value to a deallocation function have undefined behavior. Any other use of an invalid pointer value has implementation-defined behavior.</source>
          <target state="translated">Индерентификация через некорректное значение указателя и передача некорректного значения указателя в функцию дилокации имеют неопределённое поведение.Любое другое использование недействительного значения указателя имеет реализацию-определенное поведение.</target>
        </trans-unit>
        <trans-unit id="caa250f6b40fd31e6e435ad3ec42b55df8c15198" translate="yes" xml:space="preserve">
          <source>IndirectlyComparable</source>
          <target state="translated">IndirectlyComparable</target>
        </trans-unit>
        <trans-unit id="79246d49d2de7bde0e84161dfa390e35ead80dbb" translate="yes" xml:space="preserve">
          <source>IndirectlyCopyable</source>
          <target state="translated">IndirectlyCopyable</target>
        </trans-unit>
        <trans-unit id="c1b4de1846b6ae50bbf1bb567d1c5423353b3f7c" translate="yes" xml:space="preserve">
          <source>IndirectlyCopyableStorable</source>
          <target state="translated">IndirectlyCopyableStorable</target>
        </trans-unit>
        <trans-unit id="4f10a919177009406f024b0a5f8b598cade73a1d" translate="yes" xml:space="preserve">
          <source>IndirectlyMovable</source>
          <target state="translated">IndirectlyMovable</target>
        </trans-unit>
        <trans-unit id="be4b7238e8cf0d8749bb2f509a225195d878018a" translate="yes" xml:space="preserve">
          <source>IndirectlyMovableStorable</source>
          <target state="translated">IndirectlyMovableStorable</target>
        </trans-unit>
        <trans-unit id="1fb085c0bd571e7f0dafcbf700d51d838a32da50" translate="yes" xml:space="preserve">
          <source>IndirectlySwappable</source>
          <target state="translated">IndirectlySwappable</target>
        </trans-unit>
        <trans-unit id="b5f6e97cd4faf7045970097d59a8c5be90de03ff" translate="yes" xml:space="preserve">
          <source>Inexact result</source>
          <target state="translated">Неточный результат</target>
        </trans-unit>
        <trans-unit id="98df9b88a5e801dd458f9dea0b5eb524b074282a" translate="yes" xml:space="preserve">
          <source>Infinite loop without side-effects</source>
          <target state="translated">Бесконечный цикл без побочных эффектов</target>
        </trans-unit>
        <trans-unit id="8f1b65e86ba58e7d09ad5b638567441248d44fd1" translate="yes" xml:space="preserve">
          <source>Informally &quot;A is more specialized than B&quot; means &quot;A accepts a subset of the types that B accepts&quot;.</source>
          <target state="translated">В неофициальном порядке &quot;А является более специализированным,чем В&quot; означает &quot;А принимает подмножество типов,которые принимает В&quot;.</target>
        </trans-unit>
        <trans-unit id="8e26416412a250dc41f16163d325bfe0d9375649" translate="yes" xml:space="preserve">
          <source>Informally &quot;A is more specialized than B&quot; means &quot;A accepts fewer types than B&quot;.</source>
          <target state="translated">В неофициальном порядке &quot;А является более специализированным,чем В&quot; означает &quot;А принимает меньше типов,чем В&quot;.</target>
        </trans-unit>
        <trans-unit id="837818b163877df19b00b59309303eba5812d227" translate="yes" xml:space="preserve">
          <source>Informally, an object is odr-used if its value is read (unless it is a compile time constant) or written, its address is taken, or a reference is bound to it; a reference is odr-used if it is used and its referent is not known at compile time; and a function is odr-used if a function call to it is made or its address is taken. If an object, a reference or a function is odr-used, its definition must exist somewhere in the program; a violation of that is usually a link-time error.</source>
          <target state="translated">Информально,объект используется в odr-пользовании,если его значение прочитано (если только он не является константой времени компиляции)или записано,его адрес взят или к нему привязана ссылка;ссылка используется в odr-пользовании,если она используется и ее референт неизвестен во время компиляции;и функция используется в odr-пользовании,если к ней произведен вызов функции или взят ее адрес.Если объект,ссылка или функция используются в режиме odr,их определение должно существовать где-то в программе;нарушение этого правила обычно является ошибкой во времени компиляции.</target>
        </trans-unit>
        <trans-unit id="c6ae6b7147966f4caadf3becb3a298c96ec40912" translate="yes" xml:space="preserve">
          <source>Informally, two types are</source>
          <target state="translated">В неофициальном порядке,два типа</target>
        </trans-unit>
        <trans-unit id="37bbacc3d1827431eb0e90015863e8cd1f6d09b3" translate="yes" xml:space="preserve">
          <source>Informs the compiler that the dependency tree started by an &lt;code&gt;&lt;a href=&quot;memory_order&quot;&gt;std::memory_order_consume&lt;/a&gt;&lt;/code&gt; atomic load operation does not extend past the return value of &lt;code&gt;std::kill_dependency&lt;/code&gt;; that is, the argument does not carry a dependency into the return value.</source>
          <target state="translated">Информирует компилятор о том, что дерево зависимостей, запущенное с помощью &lt;code&gt;&lt;a href=&quot;memory_order&quot;&gt;std::memory_order_consume&lt;/a&gt;&lt;/code&gt; атомарной загрузки std :: memory_order_consume , не выходит за пределы возвращаемого значения &lt;code&gt;std::kill_dependency&lt;/code&gt; ; то есть аргумент не несет зависимости в возвращаемое значение.</target>
        </trans-unit>
        <trans-unit id="e9f0d94767eeb4fdf66bcb63f83f831a24817f3f" translate="yes" xml:space="preserve">
          <source>Informs the garbage collector or leak detector that the specified memory region (&lt;code&gt;n&lt;/code&gt; bytes beginning at the byte pointed to by &lt;code&gt;p&lt;/code&gt;) contains no traceable pointers. If any part of the region is within an allocated object, the entire region must be contained in the same object.</source>
          <target state="translated">Сообщает сборщику мусора или детектору утечки, что указанная область памяти ( &lt;code&gt;n&lt;/code&gt; байтов, начинающаяся с байта, на который указывает &lt;code&gt;p&lt;/code&gt; ) не содержит отслеживаемых указателей. Если какая-либо часть региона находится внутри выделенного объекта, вся область должна содержаться в одном и том же объекте.</target>
        </trans-unit>
        <trans-unit id="6b00d875f974811886ac196dcb915203f177f6a1" translate="yes" xml:space="preserve">
          <source>Informs the implementation that the object &lt;code&gt;ptr&lt;/code&gt; points to is aligned to at least &lt;code&gt;N&lt;/code&gt;. The implementation may use this information to generate more efficient code, but it might only make this assumption if the object is accessed via the return value of &lt;code&gt;assume_aligned&lt;/code&gt;.</source>
          <target state="translated">Информирует реализации , что объект &lt;code&gt;ptr&lt;/code&gt; указывает на выровнен по меньшей мере , &lt;code&gt;N&lt;/code&gt; . Реализация может использовать эту информацию для генерации более эффективного кода, но она может сделать это предположение, только если доступ к объекту осуществляется через возвращаемое значение &lt;code&gt;assume_aligned&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fdaddb9ce367c2ca746a97cc24d2e8817a51f27d" translate="yes" xml:space="preserve">
          <source>Inheritance</source>
          <target state="translated">Inheritance</target>
        </trans-unit>
        <trans-unit id="24e63953e4f041a3bb4ac3148f230860861e7ff3" translate="yes" xml:space="preserve">
          <source>Inheritance diagram.</source>
          <target state="translated">Диаграмма наследования.</target>
        </trans-unit>
        <trans-unit id="43a9b1d67674ea8718fc711a00f7bb00fbb4c4df" translate="yes" xml:space="preserve">
          <source>Inherited copy and move constructors are not included in the list of candidate functions when constructing a derived class object.</source>
          <target state="translated">Унаследованные конструкторы копирования и перемещения не включаются в список функций-кандидатов при построении объекта производного класса.</target>
        </trans-unit>
        <trans-unit id="8f06971d5187bb5c21be32f180285afdb914b12b" translate="yes" xml:space="preserve">
          <source>Inherited from &lt;a href=&quot;../../../types/integral_constant&quot;&gt; std::integral_constant&lt;/a&gt;</source>
          <target state="translated">Наследуется от &lt;a href=&quot;../../../types/integral_constant&quot;&gt;std :: integra_constant&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f30304d5307d8a19e13fb3ed0a2bac9d82e0a424" translate="yes" xml:space="preserve">
          <source>Inherited from &lt;a href=&quot;../../error/exception&quot;&gt; std::exception&lt;/a&gt;</source>
          <target state="translated">Наследуется от &lt;a href=&quot;../../error/exception&quot;&gt;std :: exception&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="01fe97cbbb0941b6f2a72d6bcbf5bf30c49dc7b1" translate="yes" xml:space="preserve">
          <source>Inherited from &lt;a href=&quot;../../error/runtime_error/runtime_error&quot;&gt; std::runtime_error&lt;/a&gt;</source>
          <target state="translated">Наследуется от &lt;a href=&quot;../../error/runtime_error/runtime_error&quot;&gt;std :: runtime_error&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="179a5175974c4d0f1231cb42168b0c03c785293b" translate="yes" xml:space="preserve">
          <source>Inherited from &lt;a href=&quot;../../error/system_error&quot;&gt; std::system_error&lt;/a&gt;</source>
          <target state="translated">Наследуется от &lt;a href=&quot;../../error/system_error&quot;&gt;std :: system_error&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="7a80e3d34750b628e39956fcaf30d5d8a1ed24f4" translate="yes" xml:space="preserve">
          <source>Inherited from &lt;a href=&quot;../../types/integral_constant&quot;&gt; std::integral_constant&lt;/a&gt;</source>
          <target state="translated">Наследуется от &lt;a href=&quot;../../types/integral_constant&quot;&gt;std :: integra_constant&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="dc3357171bb4abff2c5bcfa928f18def082a907c" translate="yes" xml:space="preserve">
          <source>Inherited from &lt;a href=&quot;../error/exception&quot;&gt; std::exception&lt;/a&gt;</source>
          <target state="translated">Наследуется от &lt;a href=&quot;../error/exception&quot;&gt;std :: exception&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="30b72f9cdb58e5970783c671d3934c33faeb1623" translate="yes" xml:space="preserve">
          <source>Inherited from &lt;a href=&quot;../error/logic_error/logic_error&quot;&gt; std::logic_error&lt;/a&gt;</source>
          <target state="translated">Наследуется от &lt;a href=&quot;../error/logic_error/logic_error&quot;&gt;std :: logic_error&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="957863018da5b123ab6f6ee5e33f1ffffd93019e" translate="yes" xml:space="preserve">
          <source>Inherited from &lt;a href=&quot;../error/runtime_error/runtime_error&quot;&gt; std::runtime_error&lt;/a&gt;</source>
          <target state="translated">Наследуется от &lt;a href=&quot;../error/runtime_error/runtime_error&quot;&gt;std :: runtime_error&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="4810ddaa7ee3800c8518272cbd3eab0a576e08e1" translate="yes" xml:space="preserve">
          <source>Inherited from &lt;a href=&quot;../error/system_error&quot;&gt; std::system_error&lt;/a&gt;</source>
          <target state="translated">Наследуется от &lt;a href=&quot;../error/system_error&quot;&gt;std :: system_error&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="8f42576c785a3be8154970999da87190cb9371f9" translate="yes" xml:space="preserve">
          <source>Inherited from &lt;a href=&quot;../exception&quot;&gt; std::exception&lt;/a&gt;</source>
          <target state="translated">Наследуется от &lt;a href=&quot;../exception&quot;&gt;std :: exception&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="1ff5d17ac32734b6c4b40b6f4b8d2dbbce7f1b33" translate="yes" xml:space="preserve">
          <source>Inherited from &lt;a href=&quot;../types/integral_constant&quot;&gt; std::integral_constant&lt;/a&gt;</source>
          <target state="translated">Наследуется от &lt;a href=&quot;../types/integral_constant&quot;&gt;std :: integra_constant&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="64a89d3879a72da7c6ee665cb1868939227a129a" translate="yes" xml:space="preserve">
          <source>Inherited from &lt;a href=&quot;../utility/pair&quot;&gt; std::pair&lt;/a&gt;</source>
          <target state="translated">Наследуется от &lt;a href=&quot;../utility/pair&quot;&gt;std :: pair&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ad227e6a5a2991b9ae2118d21b1ded53643ffeb6" translate="yes" xml:space="preserve">
          <source>Inherited from &lt;a href=&quot;bad_alloc&quot;&gt; std::bad_alloc&lt;/a&gt;</source>
          <target state="translated">Наследуется от &lt;a href=&quot;bad_alloc&quot;&gt;std :: bad_alloc&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="0640747e62ff14ba1b29b108a996ca8f524d1b5a" translate="yes" xml:space="preserve">
          <source>Inherited from &lt;a href=&quot;basic_ios&quot;&gt; std::basic_ios&lt;/a&gt;</source>
          <target state="translated">Наследуется от &lt;a href=&quot;basic_ios&quot;&gt;std :: basic_ios&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="de0c89b89174954a9f92de2b010f4eba6cf65be6" translate="yes" xml:space="preserve">
          <source>Inherited from &lt;a href=&quot;basic_istream&quot;&gt; std::basic_istream&lt;/a&gt;</source>
          <target state="translated">Наследуется от &lt;a href=&quot;basic_istream&quot;&gt;std :: basic_istream&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="5294336a5cb08c884f1c1c77c83e45be59fa6ba0" translate="yes" xml:space="preserve">
          <source>Inherited from &lt;a href=&quot;basic_ostream&quot;&gt; std::basic_ostream&lt;/a&gt;</source>
          <target state="translated">Наследуется от &lt;a href=&quot;basic_ostream&quot;&gt;std :: basic_ostream&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="9055f46788224b7f31bcf6f24250ff5d47695175" translate="yes" xml:space="preserve">
          <source>Inherited from &lt;a href=&quot;basic_streambuf&quot;&gt; std::basic_streambuf&lt;/a&gt;</source>
          <target state="translated">Наследуется от &lt;a href=&quot;basic_streambuf&quot;&gt;std :: basic_streambuf&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="538de0fbed9b76df7a6ab5144cdd294244e05923" translate="yes" xml:space="preserve">
          <source>Inherited from &lt;a href=&quot;codecvt&quot;&gt; std::codecvt&lt;/a&gt;</source>
          <target state="translated">Наследуется от &lt;a href=&quot;codecvt&quot;&gt;std :: codecvt&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="691ededb623378951567ffd0bfa980099fbe3761" translate="yes" xml:space="preserve">
          <source>Inherited from &lt;a href=&quot;codecvt_base&quot;&gt; std::codecvt_base&lt;/a&gt;</source>
          <target state="translated">Наследуется от &lt;a href=&quot;codecvt_base&quot;&gt;std :: codecvt_base&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="55051117752349a92484d2d68e1536f7ba751ac6" translate="yes" xml:space="preserve">
          <source>Inherited from &lt;a href=&quot;collate&quot;&gt; std::collate&lt;/a&gt;</source>
          <target state="translated">Наследуется от &lt;a href=&quot;collate&quot;&gt;std :: collate&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="646bf27bfd425c0266f785460d8846b085490446" translate="yes" xml:space="preserve">
          <source>Inherited from &lt;a href=&quot;exception&quot;&gt; std::exception&lt;/a&gt;</source>
          <target state="translated">Наследуется от &lt;a href=&quot;exception&quot;&gt;std :: exception&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="2b1e16a440f913fb0c212304822e1171df74e082" translate="yes" xml:space="preserve">
          <source>Inherited from &lt;a href=&quot;integral_constant&quot;&gt; std::integral_constant&lt;/a&gt;</source>
          <target state="translated">Наследуется от &lt;a href=&quot;integral_constant&quot;&gt;std :: integra_constant&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="3d307388b240b50355fd55953eea3dcf640dd433" translate="yes" xml:space="preserve">
          <source>Inherited from &lt;a href=&quot;ios_base&quot;&gt; std::ios_base&lt;/a&gt;</source>
          <target state="translated">Наследуется от &lt;a href=&quot;ios_base&quot;&gt;std :: ios_base&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e507c076782fb8eb8b54d375f2f956f7369f545d" translate="yes" xml:space="preserve">
          <source>Inherited from &lt;a href=&quot;messages&quot;&gt; std::messages&lt;/a&gt;</source>
          <target state="translated">Наследуется от &lt;a href=&quot;messages&quot;&gt;std :: messages&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f67af012ab32d51632e38d03380caedc6cb1fd11" translate="yes" xml:space="preserve">
          <source>Inherited from &lt;a href=&quot;money_base&quot;&gt;std::money_base&lt;/a&gt;</source>
          <target state="translated">Наследуется от &lt;a href=&quot;money_base&quot;&gt;std :: money_base&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="88842694e8b959006d435b6cad10e7a20f4f86fe" translate="yes" xml:space="preserve">
          <source>Inherited from &lt;a href=&quot;moneypunct&quot;&gt; std::moneypunct&lt;/a&gt;</source>
          <target state="translated">Наследуется от &lt;a href=&quot;moneypunct&quot;&gt;std :: moneypunct&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="4d17a29ada80f7d12d7692d7e6aaa8521d515613" translate="yes" xml:space="preserve">
          <source>Inherited from &lt;a href=&quot;numpunct&quot;&gt; std::numpunct&lt;/a&gt;</source>
          <target state="translated">Наследуется от &lt;a href=&quot;numpunct&quot;&gt;std :: numpunct&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="96f6c2f33d9e5a486e8905be371715ec2d5e0e4c" translate="yes" xml:space="preserve">
          <source>Inherited from &lt;a href=&quot;runtime_error/runtime_error&quot;&gt; std::runtime_error&lt;/a&gt;</source>
          <target state="translated">Наследуется от &lt;a href=&quot;runtime_error/runtime_error&quot;&gt;std :: runtime_error&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="7efc4c44fcbc8224af5b604f6ea179f896007df5" translate="yes" xml:space="preserve">
          <source>Inherited from &lt;a href=&quot;time_get&quot;&gt; std::time_get&lt;/a&gt;</source>
          <target state="translated">Наследуется от &lt;a href=&quot;time_get&quot;&gt;std :: time_get&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="6fda6ad022c33ce0f5b1400e8f343ad50076eeb0" translate="yes" xml:space="preserve">
          <source>Inherited from &lt;a href=&quot;time_put&quot;&gt; std::time_put&lt;/a&gt;</source>
          <target state="translated">Наследуется от &lt;a href=&quot;time_put&quot;&gt;std :: time_put&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e7135edcc0660dff5ef07a7531f5a314d1a14345" translate="yes" xml:space="preserve">
          <source>Inherited from std::ctype&amp;lt;CharT&amp;gt;</source>
          <target state="translated">Наследуется от std :: ctype &amp;lt;CharT&amp;gt;</target>
        </trans-unit>
        <trans-unit id="96606dedfe0d1180adfbb7cf5dc6b000d690eeaa" translate="yes" xml:space="preserve">
          <source>Inherited from std::ctype&amp;lt;char&amp;gt;</source>
          <target state="translated">Наследуется от std :: ctype &amp;lt;char&amp;gt;</target>
        </trans-unit>
        <trans-unit id="6835bd4de94e4c8ff9fa81f21f0a45e937163c89" translate="yes" xml:space="preserve">
          <source>Inherited from std::ctype_base</source>
          <target state="translated">Унаследованный от std::ctype_base</target>
        </trans-unit>
        <trans-unit id="2a9684185e4ab4b7acc08548b265978c0ac9b665" translate="yes" xml:space="preserve">
          <source>Inherited from std::messages_base</source>
          <target state="translated">Унаследованный от std::messages_base</target>
        </trans-unit>
        <trans-unit id="ec11a5942722961cf6c8bf90cef0c0ab7cbfd804" translate="yes" xml:space="preserve">
          <source>Inherited from std::time_base</source>
          <target state="translated">Унаследованный от std::time_base</target>
        </trans-unit>
        <trans-unit id="a162155e80acef2e40d64da7fae4b6cef737ccc3" translate="yes" xml:space="preserve">
          <source>Inheriting constructors</source>
          <target state="translated">Унаследовавшие конструкторы</target>
        </trans-unit>
        <trans-unit id="ed212d227256484af63b60ae12f72487723786d7" translate="yes" xml:space="preserve">
          <source>Inheriting from empty base classes usually does not increase the size of a class due to &lt;a href=&quot;../language/ebo&quot;&gt;empty base optimization&lt;/a&gt;.</source>
          <target state="translated">Наследование от пустых базовых классов обычно не увеличивает размер класса из-за &lt;a href=&quot;../language/ebo&quot;&gt;оптимизации&lt;/a&gt; пустых базовых классов .</target>
        </trans-unit>
        <trans-unit id="19682bdb9185a5fa9d763d414d0443d3a0bc2456" translate="yes" xml:space="preserve">
          <source>Init</source>
          <target state="translated">Init</target>
        </trans-unit>
        <trans-unit id="68fa16ffd48f366e4fa8d57fea78ff03fcab0191" translate="yes" xml:space="preserve">
          <source>Initialization</source>
          <target state="translated">Initialization</target>
        </trans-unit>
        <trans-unit id="f6e1e46e4baf5716e3220f3484c1af85b95e71c8" translate="yes" xml:space="preserve">
          <source>Initialization by constructor</source>
          <target state="translated">Инициализация конструктором</target>
        </trans-unit>
        <trans-unit id="d0105ebd75116f796a8152546a960d90f6068ea4" translate="yes" xml:space="preserve">
          <source>Initialization of &lt;a href=&quot;../language/storage_duration#Static_local_variables&quot;&gt;function-local statics&lt;/a&gt; is guaranteed to occur only once even when called from multiple threads, and may be more efficient than the equivalent code using &lt;code&gt;std::call_once&lt;/code&gt;.</source>
          <target state="translated">Инициализация &lt;a href=&quot;../language/storage_duration#Static_local_variables&quot;&gt;функционально-локальной статики&lt;/a&gt; гарантированно происходит только один раз, даже если она вызывается из нескольких потоков, и может быть более эффективной, чем эквивалентный код, использующий &lt;code&gt;std::call_once&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d91f501eae2c832f1b0b7e4d4973d0855f66060e" translate="yes" xml:space="preserve">
          <source>Initialization order</source>
          <target state="translated">Приказ о инициализации</target>
        </trans-unit>
        <trans-unit id="49fb3cd233b01d2f3fca6d231ff8868b279e8d64" translate="yes" xml:space="preserve">
          <source>Initialization to all bits zero does not guarantee that a floating-point or a pointer would be initialized to 0.0 and the null pointer value, respectively (although that is true on all common platforms).</source>
          <target state="translated">Инициализация на все биты нуля не гарантирует,что плавающая точка или указатель будут инициализированы на 0.0 и значение нулевого указателя соответственно (хотя это верно на всех распространенных платформах).</target>
        </trans-unit>
        <trans-unit id="6ea9d5c7645589c136d59cd57df44af49ce9783f" translate="yes" xml:space="preserve">
          <source>Initialization with a &lt;a href=&quot;../../language/string_literal&quot;&gt;string literal&lt;/a&gt; that contains embedded &lt;code&gt;'\0'&lt;/code&gt; characters uses the overload (5), which stops at the first null character. This can be avoided by specifying a different constructor or by using &lt;a href=&quot;operator_q__q_s&quot;&gt;&lt;code&gt;operator&quot;&quot;s&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">При инициализации &lt;a href=&quot;../../language/string_literal&quot;&gt;строковым литералом&lt;/a&gt; , содержащим вложенные символы &lt;code&gt;'\0'&lt;/code&gt; используется перегрузка (5), которая останавливается на первом нулевом символе. Этого можно избежать, указав другой конструктор или используя &lt;a href=&quot;operator_q__q_s&quot;&gt; &lt;code&gt;operator&quot;&quot;s&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="a8b6090f523a6604aaf83ad226d272f3e664763f" translate="yes" xml:space="preserve">
          <source>Initializer lists</source>
          <target state="translated">Списки инициализаторов</target>
        </trans-unit>
        <trans-unit id="5205b0ca0f0fefcfe68c33103c2c9c1ce338c249" translate="yes" xml:space="preserve">
          <source>Initializer lists may be implemented as a pair of pointers or pointer and length. Copying a &lt;code&gt;std::initializer_list&lt;/code&gt; does not copy the underlying objects.</source>
          <target state="translated">Списки инициализатора могут быть реализованы в виде пары указателей или указателя и длины. Копирование &lt;code&gt;std::initializer_list&lt;/code&gt; не копирует базовые объекты.</target>
        </trans-unit>
        <trans-unit id="4cd615dbf08a4b7ea3976db14aee644d6937efce" translate="yes" xml:space="preserve">
          <source>Initializes an aggregate from braced-init-list.</source>
          <target state="translated">Инициализирует агрегат из списка &quot;Брэйд-иннит&quot;.</target>
        </trans-unit>
        <trans-unit id="44dcbda2c857e660e975019d6dd123883526dd75" translate="yes" xml:space="preserve">
          <source>Initializes an object from another object.</source>
          <target state="translated">Инициализирует объект с другого объекта.</target>
        </trans-unit>
        <trans-unit id="0d3ed04db9734c04b00626e83cd3a554c91216b4" translate="yes" xml:space="preserve">
          <source>Initializes an object from braced-init-list.</source>
          <target state="translated">Инициализирует объект из списка скрепленных фигур.</target>
        </trans-unit>
        <trans-unit id="b28ee811ef30d6e7a7f950db96ff44c9ab341ca0" translate="yes" xml:space="preserve">
          <source>Initializes an object from explicit set of constructor arguments.</source>
          <target state="translated">Инициализирует объект из явного набора аргументов конструктора.</target>
        </trans-unit>
        <trans-unit id="3612fbe04b3d4f902d2d49989872e1c625ef8e37" translate="yes" xml:space="preserve">
          <source>Initializes exposition-only data member &lt;code&gt;bound_&lt;/code&gt; with &lt;code&gt;bound&lt;/code&gt;.</source>
          <target state="translated">Инициализирует элемент данных только для экспозиции &lt;code&gt;bound_&lt;/code&gt; with &lt;code&gt;bound&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e582f41fbe9142faa1edac6dc025f737e0f1efef" translate="yes" xml:space="preserve">
          <source>Initializes exposition-only data member &lt;code&gt;current_&lt;/code&gt; with &lt;code&gt;current&lt;/code&gt; and exposition-only data members &lt;code&gt;parent_&lt;/code&gt; with &lt;code&gt;addressof(parent)&lt;/code&gt;.</source>
          <target state="translated">Инициализирует элемент данных только для экспозиции &lt;code&gt;current_&lt;/code&gt; с элементами данных &lt;code&gt;current&lt;/code&gt; и только для экспозиции &lt;code&gt;parent_&lt;/code&gt; с &lt;code&gt;addressof(parent)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="687eeb5c76107cbf76d277e107912b3a093ddbf0" translate="yes" xml:space="preserve">
          <source>Initializes exposition-only data member &lt;code&gt;end_&lt;/code&gt; with &lt;code&gt;parent&lt;/code&gt;.</source>
          <target state="translated">Инициализирует элемент данных только для экспозиции &lt;code&gt;end_&lt;/code&gt; с &lt;code&gt;parent&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="45a2d2edd8a0c33265b1f7964c619dbe931e75f5" translate="yes" xml:space="preserve">
          <source>Initializes exposition-only data member &lt;code&gt;value_&lt;/code&gt; with &lt;code&gt;value&lt;/code&gt;. This value will be returned by operator* and incremented by operator++</source>
          <target state="translated">Инициализирует элемент данных только для экспозиции &lt;code&gt;value_&lt;/code&gt; со &lt;code&gt;value&lt;/code&gt; . Это значение будет возвращено оператором * и увеличено оператором ++</target>
        </trans-unit>
        <trans-unit id="3ed19383d0a866bf81dc2a8bf40d1563412b85cf" translate="yes" xml:space="preserve">
          <source>Initializes the</source>
          <target state="translated">Инициализирует</target>
        </trans-unit>
        <trans-unit id="a8d332dbed9d2af60e29bd52e5cde6a80c7ad53b" translate="yes" xml:space="preserve">
          <source>Initializes the default-constructed atomic object &lt;code&gt;obj&lt;/code&gt; with the value &lt;code&gt;desired&lt;/code&gt;. The function is not atomic: concurrent access from another thread, even through an atomic operation, is a data race.</source>
          <target state="translated">Инициализирует построенный по умолчанию атомарный объект &lt;code&gt;obj&lt;/code&gt; с &lt;code&gt;desired&lt;/code&gt; значением . Функция не атомарна: параллельный доступ из другого потока, даже через атомарную операцию, является гонкой данных.</target>
        </trans-unit>
        <trans-unit id="e49e9f39572d1033a19aeb243a49b9e378d309f2" translate="yes" xml:space="preserve">
          <source>Initializes the internal instance of the comparator to &lt;code&gt;c&lt;/code&gt;.</source>
          <target state="translated">Инициализирует внутренний экземпляр компаратора &lt;code&gt;c&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a51259c3c84f8a09271df7eb1d4694a4b3224cee" translate="yes" xml:space="preserve">
          <source>Initializes the iterator to point to the same value as &lt;code&gt;it&lt;/code&gt; points.</source>
          <target state="translated">Инициализирует итератор, чтобы он указывал на то же значение, на которое &lt;code&gt;it&lt;/code&gt; указывает.</target>
        </trans-unit>
        <trans-unit id="398735e9fedddd7f0aacad1eb358f7b46a4ac840" translate="yes" xml:space="preserve">
          <source>Injected class name</source>
          <target state="translated">Имя класса впрыскивания</target>
        </trans-unit>
        <trans-unit id="7bb9ce0cdba5a821d492b917cf5fb720a0f90bd9" translate="yes" xml:space="preserve">
          <source>Inline assembly</source>
          <target state="translated">интернет-монтаж</target>
        </trans-unit>
        <trans-unit id="4f9c73f65355a3ed7fedd216f2992cf3deebb61c" translate="yes" xml:space="preserve">
          <source>Inline assembly for Itanium-based HP-UX</source>
          <target state="translated">Внутренняя сборка для HP-UX на основе итания</target>
        </trans-unit>
        <trans-unit id="e51e51dc5c1aa8a193565e7fce22f1c142ed7d5c" translate="yes" xml:space="preserve">
          <source>Inline const variables at namespace scope have &lt;a href=&quot;storage_duration&quot;&gt;external linkage&lt;/a&gt; by default (unlike the non-inline non-volatile const-qualified variables).</source>
          <target state="translated">Встроенные константные переменные в области пространства имен по умолчанию имеют &lt;a href=&quot;storage_duration&quot;&gt;внешнюю связь&lt;/a&gt; (в отличие от непостоянных энергонезависимых переменных, соответствующих константам).</target>
        </trans-unit>
        <trans-unit id="49bfb486d3b3c3cb304f4493385555eb5b8a098a" translate="yes" xml:space="preserve">
          <source>Inline namespaces</source>
          <target state="translated">Пространства имен в Интернете</target>
        </trans-unit>
        <trans-unit id="00b64c52a93228b3beba41ea40e5bd41acc77e53" translate="yes" xml:space="preserve">
          <source>Inline variables</source>
          <target state="translated">Inline переменные</target>
        </trans-unit>
        <trans-unit id="7be4e5da3a5437427b26df1ed281ec5d61782f49" translate="yes" xml:space="preserve">
          <source>Inline variables eliminate the main obstacle to packaging C++ code as header-only libraries.</source>
          <target state="translated">Встроенные переменные устраняют основное препятствие для упаковки Си++кода в виде только заголовочных библиотек.</target>
        </trans-unit>
        <trans-unit id="b568d47f2e244743b1fd7472db836ef9769c21f8" translate="yes" xml:space="preserve">
          <source>Input</source>
          <target state="translated">Input</target>
        </trans-unit>
        <trans-unit id="c05e081250483115acb3291c729e966cb6237c5d" translate="yes" xml:space="preserve">
          <source>Input/Output</source>
          <target state="translated">Input/Output</target>
        </trans-unit>
        <trans-unit id="249f397392db7fe682a1d1ecc1a52c8e40ceb983" translate="yes" xml:space="preserve">
          <source>Input/output</source>
          <target state="translated">Input/output</target>
        </trans-unit>
        <trans-unit id="cb5679ee6b70828884e48e829adaa69eeff5975a" translate="yes" xml:space="preserve">
          <source>Input/output library</source>
          <target state="translated">Библиотека ввода/вывода</target>
        </trans-unit>
        <trans-unit id="23a1c2b90e7720bee1275126fc61ab157f7fb4f4" translate="yes" xml:space="preserve">
          <source>Input/output manipulators</source>
          <target state="translated">Входные/выходные манипуляторы</target>
        </trans-unit>
        <trans-unit id="2dd11dbfca0e0084817673f0057830adc2def0af" translate="yes" xml:space="preserve">
          <source>InputIterator</source>
          <target state="translated">InputIterator</target>
        </trans-unit>
        <trans-unit id="5ce3b480664c159e1d12685b429698048d6ea3d0" translate="yes" xml:space="preserve">
          <source>InputRange</source>
          <target state="translated">InputRange</target>
        </trans-unit>
        <trans-unit id="2626e21603d8fe73a7e6ad428ec1925d9f5ce790" translate="yes" xml:space="preserve">
          <source>Insert an object of type &lt;code&gt;T&lt;/code&gt;, constructed with &lt;code&gt;&lt;a href=&quot;../utility/forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;Args&amp;gt;(args)&lt;/code&gt; before &lt;code&gt;p&lt;/code&gt;</source>
          <target state="translated">Вставьте объект типа &lt;code&gt;T&lt;/code&gt; , созданный с помощью &lt;code&gt;&lt;a href=&quot;../utility/forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;Args&amp;gt;(args)&lt;/code&gt; перед &lt;code&gt;p&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="bd0f39cfbd64e0b854da8b25dafdd19e3e5f4946" translate="yes" xml:space="preserve">
          <source>Insertion caused rehash</source>
          <target state="translated">Вставка вызвала повторную запись</target>
        </trans-unit>
        <trans-unit id="dd68ac29c94054b522d28e6c6323109f3d58ed57" translate="yes" xml:space="preserve">
          <source>Insertion changed capacity</source>
          <target state="translated">Вставка измененная емкость</target>
        </trans-unit>
        <trans-unit id="90792df8b1ed4fcb7ea818e84aee0085187c66dc" translate="yes" xml:space="preserve">
          <source>Insertion or removal of elements - linear O(n)</source>
          <target state="translated">Вставка или снятие элементов-линейное O(n)</target>
        </trans-unit>
        <trans-unit id="8dd87d390aed8473e28b99fc188dddac51d8f873" translate="yes" xml:space="preserve">
          <source>Insertion or removal of elements - linear in the distance to the end of the vector O(n)</source>
          <target state="translated">Вставка или удаление элементов-линейный на расстоянии до конца вектора O(n)</target>
        </trans-unit>
        <trans-unit id="a9f7998ac9050fd1635baf4429d529d9a7bb0521" translate="yes" xml:space="preserve">
          <source>Insertion or removal of elements at the end - amortized constant O(1)</source>
          <target state="translated">Вставка или удаление элементов на конце-амортизированная константа O(1)</target>
        </trans-unit>
        <trans-unit id="89dc0ff756b3d85bb1be7c9942ebc7011ccf494e" translate="yes" xml:space="preserve">
          <source>Insertion or removal of elements at the end or beginning - constant O(1)</source>
          <target state="translated">Вставка или удаление элементов в конце или начале-постоянная O(1)</target>
        </trans-unit>
        <trans-unit id="40dbe6b4bec47b9cf461b0137ff76c424defca97" translate="yes" xml:space="preserve">
          <source>Inserts &lt;code&gt;n&lt;/code&gt; copies of &lt;code&gt;t&lt;/code&gt; before &lt;code&gt;p&lt;/code&gt;</source>
          <target state="translated">Вставляет &lt;code&gt;n&lt;/code&gt; копий &lt;code&gt;t&lt;/code&gt; перед &lt;code&gt;p&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c32005ed652dab6de9fb37a37722957c3e2724e8" translate="yes" xml:space="preserve">
          <source>Inserts &lt;code&gt;value&lt;/code&gt; into the associated stream, then inserts the delimiter, if one was specified at construction time.</source>
          <target state="translated">Вставляет &lt;code&gt;value&lt;/code&gt; в связанный поток, затем вставляет разделитель, если он был указан во время построения.</target>
        </trans-unit>
        <trans-unit id="459fe20a1ffd7a6cd82618f9958505d8f6d74257" translate="yes" xml:space="preserve">
          <source>Inserts a character or a character string.</source>
          <target state="translated">Вставляет символ или строку символов.</target>
        </trans-unit>
        <trans-unit id="1292e82dd313319fd90a6127a6a0b0fa41ee3b4b" translate="yes" xml:space="preserve">
          <source>Inserts a copy of &lt;code&gt;rv&lt;/code&gt; before &lt;code&gt;p&lt;/code&gt;, possibly using move semantics</source>
          <target state="translated">Вставляет копию &lt;code&gt;rv&lt;/code&gt; перед &lt;code&gt;p&lt;/code&gt; , возможно используя семантику перемещения</target>
        </trans-unit>
        <trans-unit id="080a7d3105b387ca72b759dd0ac8cbe8daf7bece" translate="yes" xml:space="preserve">
          <source>Inserts a copy of &lt;code&gt;t&lt;/code&gt; before &lt;code&gt;p&lt;/code&gt;</source>
          <target state="translated">Вставляет копию &lt;code&gt;t&lt;/code&gt; перед &lt;code&gt;p&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="dddeb94b4972c7384daa43582f102c411ce2464e" translate="yes" xml:space="preserve">
          <source>Inserts a new element into a position after the specified position in the container. The element is constructed in-place, i.e. no copy or move operations are performed. The constructor of the element is called with exactly the same arguments, as supplied to the function.</source>
          <target state="translated">Вставляет новый элемент в положение после указанного положения в контейнере.Элемент строится на месте,т.е.операции копирования и перемещения не выполняются.Конструктор элемента вызывается с точно такими же аргументами,как и в функции.</target>
        </trans-unit>
        <trans-unit id="ca770757036e4fe2be6c21dfdc40521b78bb495b" translate="yes" xml:space="preserve">
          <source>Inserts a new element into the container as close as possible to the position just before &lt;code&gt;hint&lt;/code&gt;. The element is constructed in-place, i.e. no copy or move operations are performed.</source>
          <target state="translated">Вставляет новый элемент в контейнер как можно ближе к позиции непосредственно перед &lt;code&gt;hint&lt;/code&gt; . Элемент создается на месте, то есть операции копирования или перемещения не выполняются.</target>
        </trans-unit>
        <trans-unit id="0c894839e77e9ab81555b68a4eab970743f5cf11" translate="yes" xml:space="preserve">
          <source>Inserts a new element into the container constructed in-place with the given &lt;code&gt;args&lt;/code&gt; .</source>
          <target state="translated">Вставляет новый элемент в контейнер, созданный на месте с заданными &lt;code&gt;args&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2ebf2c045edb5580cda64f0fcb67ffe1f644265e" translate="yes" xml:space="preserve">
          <source>Inserts a new element into the container constructed in-place with the given &lt;code&gt;args&lt;/code&gt; if there is no element with the key in the container.</source>
          <target state="translated">Вставляет новый элемент в контейнер, созданный на месте с заданными &lt;code&gt;args&lt;/code&gt; если в контейнере нет элемента с ключом.</target>
        </trans-unit>
        <trans-unit id="764a3843820016f0a301fc81d7090ba832667367" translate="yes" xml:space="preserve">
          <source>Inserts a new element into the container directly before &lt;code&gt;pos&lt;/code&gt;. The element is constructed through &lt;code&gt;&lt;a href=&quot;../../memory/allocator_traits/construct&quot;&gt;std::allocator_traits::construct&lt;/a&gt;&lt;/code&gt;, which typically uses placement-new to construct the element in-place at a location provided by the container. The arguments &lt;code&gt;args...&lt;/code&gt; are forwarded to the constructor as &lt;code&gt;&lt;a href=&quot;../../utility/forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;Args&amp;gt;(args)...&lt;/code&gt;.</source>
          <target state="translated">Вставляет новый элемент в контейнер непосредственно перед &lt;code&gt;pos&lt;/code&gt; . Элемент создается с помощью &lt;code&gt;&lt;a href=&quot;../../memory/allocator_traits/construct&quot;&gt;std::allocator_traits::construct&lt;/a&gt;&lt;/code&gt; , который обычно использует place-new для создания элемента на месте в местоположении, предоставленном контейнером. Аргументы &lt;code&gt;args...&lt;/code&gt; пересылаются конструктору &lt;code&gt;&lt;a href=&quot;../../utility/forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;Args&amp;gt;(args)...&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9cf81cb318be0807a9f9dfa69a27e14ef4b04921" translate="yes" xml:space="preserve">
          <source>Inserts a new element to the beginning of the container. The element is constructed through &lt;code&gt;&lt;a href=&quot;../../memory/allocator_traits/construct&quot;&gt;std::allocator_traits::construct&lt;/a&gt;&lt;/code&gt;, which typically uses placement-new to construct the element in-place at the location provided by the container. The arguments &lt;code&gt;args...&lt;/code&gt; are forwarded to the constructor as &lt;code&gt;&lt;a href=&quot;../../utility/forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;Args&amp;gt;(args)...&lt;/code&gt;.</source>
          <target state="translated">Вставляет новый элемент в начало контейнера. Элемент создается с помощью &lt;code&gt;&lt;a href=&quot;../../memory/allocator_traits/construct&quot;&gt;std::allocator_traits::construct&lt;/a&gt;&lt;/code&gt; , который обычно использует place-new для создания элемента на месте в местоположении, предоставленном контейнером. Аргументы &lt;code&gt;args...&lt;/code&gt; передаются в конструктор как &lt;code&gt;&lt;a href=&quot;../../utility/forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;Args&amp;gt;(args)...&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="de2a91ea3a0922ba9fd2c6820a52603ceaf2bfd4" translate="yes" xml:space="preserve">
          <source>Inserts a new element to the container as close as possible to the position just before &lt;code&gt;hint&lt;/code&gt;. The element is constructed in-place, i.e. no copy or move operations are performed.</source>
          <target state="translated">Вставляет новый элемент в контейнер как можно ближе к позиции непосредственно перед &lt;code&gt;hint&lt;/code&gt; . Элемент создается на месте, то есть операции копирования или перемещения не выполняются.</target>
        </trans-unit>
        <trans-unit id="d62b4192e275e6e5464e704bf2f2c06f78857362" translate="yes" xml:space="preserve">
          <source>Inserts a new element to the container, using &lt;code&gt;hint&lt;/code&gt; as a suggestion where the element should go. The element is constructed in-place, i.e. no copy or move operations are performed.</source>
          <target state="translated">Вставляет новый элемент в контейнер, используя &lt;code&gt;hint&lt;/code&gt; в качестве подсказки, куда должен идти элемент. Элемент создается на месте, то есть операции копирования или перемещения не выполняются.</target>
        </trans-unit>
        <trans-unit id="06b953e63c9c91232d7dddd7cd152b54414e60b1" translate="yes" xml:space="preserve">
          <source>Inserts a newline character into the output sequence &lt;code&gt;os&lt;/code&gt; and flushes it as if by calling &lt;code&gt;os.put(os.widen('\n'))&lt;/code&gt; followed by &lt;code&gt;os.flush()&lt;/code&gt;.</source>
          <target state="translated">Вставляет символ новой строки в выходную последовательность &lt;code&gt;os&lt;/code&gt; и сбрасывает его, как если бы вызывал &lt;code&gt;os.put(os.widen('\n'))&lt;/code&gt; а затем &lt;code&gt;os.flush()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5f4e0eed677f446544f8308f60d7118157395fd2" translate="yes" xml:space="preserve">
          <source>Inserts a null character into the output sequence &lt;code&gt;os&lt;/code&gt; as if by calling &lt;code&gt;os.put(CharT())&lt;/code&gt;.</source>
          <target state="translated">Вставляет нулевой символ в выходную последовательность &lt;code&gt;os&lt;/code&gt; , как будто вызывая &lt;code&gt;os.put(CharT())&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3be6541a3cdc8be869ffb1e36075af35ad2d9e5f" translate="yes" xml:space="preserve">
          <source>Inserts a textual representation of &lt;code&gt;d&lt;/code&gt; into &lt;code&gt;os&lt;/code&gt;. The behavior is undefined if &lt;code&gt;CharT&lt;/code&gt; is neither &lt;code&gt;char&lt;/code&gt; or &lt;code&gt;wchar_t&lt;/code&gt;, or if &lt;code&gt;Rep&lt;/code&gt; is neither a floating-point type nor a integral type with conversion rank equal to or greater than &lt;code&gt;short&lt;/code&gt;.</source>
          <target state="translated">Вставляет текстовое представление &lt;code&gt;d&lt;/code&gt; в &lt;code&gt;os&lt;/code&gt; . Поведение не определено, если &lt;code&gt;CharT&lt;/code&gt; не является ни &lt;code&gt;char&lt;/code&gt; , ни &lt;code&gt;wchar_t&lt;/code&gt; , или если &lt;code&gt;Rep&lt;/code&gt; не является ни типом с плавающей точкой, ни целочисленным типом с рангом преобразования, равным или большим чем &lt;code&gt;short&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3b309639bb23b684cc4e6d27b3891dbc4686b983" translate="yes" xml:space="preserve">
          <source>Inserts a textual representation of &lt;code&gt;r&lt;/code&gt; into &lt;code&gt;os&lt;/code&gt;. The exact format is unspecified.</source>
          <target state="translated">Вставляет текстовое представление &lt;code&gt;r&lt;/code&gt; в &lt;code&gt;os&lt;/code&gt; . Точный формат не указан.</target>
        </trans-unit>
        <trans-unit id="16b3b45d0513a34bfe5cb9a485fed3fcd636a919" translate="yes" xml:space="preserve">
          <source>Inserts characters into the string.</source>
          <target state="translated">Вставляет символы в строку.</target>
        </trans-unit>
        <trans-unit id="0b8fe07029996680c6a7a04171ab4c8c1f427b51" translate="yes" xml:space="preserve">
          <source>Inserts copies of elements in &lt;code&gt;[i, j)&lt;/code&gt; before &lt;code&gt;p&lt;/code&gt;</source>
          <target state="translated">Вставляет копии элементов в &lt;code&gt;[i, j)&lt;/code&gt; перед &lt;code&gt;p&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4f550772dfe95225e7aadcf101fd0fcec8c748a7" translate="yes" xml:space="preserve">
          <source>Inserts data into the stream.</source>
          <target state="translated">Вставляет данные в поток.</target>
        </trans-unit>
        <trans-unit id="eba77933a2e344cf988fd3ca6a623ff9d2ff92d0" translate="yes" xml:space="preserve">
          <source>Inserts element(s) into the container, if the container doesn't already contain an element with an equivalent key.</source>
          <target state="translated">Вставляет элемент(ы)в контейнер,если контейнер еще не содержит элемента с эквивалентным ключом.</target>
        </trans-unit>
        <trans-unit id="ccd9e30db577ad68c0e1422c4c4a79f885e3e582" translate="yes" xml:space="preserve">
          <source>Inserts element(s) into the container.</source>
          <target state="translated">Вставляет элемент(ы)в контейнер.</target>
        </trans-unit>
        <trans-unit id="1a4eb8d141fa15817e7fa53f7d0ceee266ac871a" translate="yes" xml:space="preserve">
          <source>Inserts elements after the specified position in the container.</source>
          <target state="translated">Вставляет элементы после указанного положения в контейнер.</target>
        </trans-unit>
        <trans-unit id="8ad0a7fe7ffe735c0e8d1f3247c2284b472ecf85" translate="yes" xml:space="preserve">
          <source>Inserts elements at the specified location in the container.</source>
          <target state="translated">Вставляет элементы в указанное место в контейнере.</target>
        </trans-unit>
        <trans-unit id="e3538cf079d871f7078cd6d2626f91c5fe3217d1" translate="yes" xml:space="preserve">
          <source>Inserts or extracts a bitset from a character stream.</source>
          <target state="translated">Вставляет или извлекает битсет из потока символов.</target>
        </trans-unit>
        <trans-unit id="436cbc44494163237fbc2dae7c0dbecac89e17a0" translate="yes" xml:space="preserve">
          <source>Inserts the element at the position &lt;code&gt;last-1&lt;/code&gt; into the</source>
          <target state="translated">Вставляет элемент в позиции &lt;code&gt;last-1&lt;/code&gt; в</target>
        </trans-unit>
        <trans-unit id="de7c44cdab798ba02a3b54672adb89734e298e3e" translate="yes" xml:space="preserve">
          <source>Inserts the given value &lt;code&gt;value&lt;/code&gt; to the container.</source>
          <target state="translated">Вставляет заданное значение &lt;code&gt;value&lt;/code&gt; для контейнера.</target>
        </trans-unit>
        <trans-unit id="da42294637fdcfd28f56598c14c33d9cc2c56bd5" translate="yes" xml:space="preserve">
          <source>Inserts the value of the pointer managed by &lt;code&gt;p&lt;/code&gt; into the output stream &lt;code&gt;os&lt;/code&gt;.</source>
          <target state="translated">Вставляет значение указателя, управляемого &lt;code&gt;p&lt;/code&gt; , в выходной поток &lt;code&gt;os&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="27f20e401e741fb3278e97286227b847ff4a5a37" translate="yes" xml:space="preserve">
          <source>Inserts the value of the pointer stored in ptr into the output stream os.</source>
          <target state="translated">Вставляет значение указателя,сохраненное в ptr,в выходной поток os.</target>
        </trans-unit>
        <trans-unit id="cc4361d50be18c5e552170a7006899011cb13d66" translate="yes" xml:space="preserve">
          <source>Inside a &lt;a href=&quot;../language/constraints&quot;&gt; requirements&lt;/a&gt; for type requirements (since C++20)</source>
          <target state="translated">Внутри &lt;a href=&quot;../language/constraints&quot;&gt;требования&lt;/a&gt; к требованиям типа (начиная с C ++ 20)</target>
        </trans-unit>
        <trans-unit id="600f1274eac8f378c8f16ed6ad8ee46ff4edfb74" translate="yes" xml:space="preserve">
          <source>Inside a class definition, the keyword &lt;a href=&quot;../keywords/static&quot;&gt;&lt;code&gt;static&lt;/code&gt;&lt;/a&gt; declares members that are not bound to class instances.</source>
          <target state="translated">Внутри определения класса ключевое слово &lt;a href=&quot;../keywords/static&quot;&gt; &lt;code&gt;static&lt;/code&gt; &lt;/a&gt; объявляет члены, которые не связаны с экземплярами класса.</target>
        </trans-unit>
        <trans-unit id="03675817cd2b928d6905ad0345e0c7efd3baeea5" translate="yes" xml:space="preserve">
          <source>Inside a declaration or a definition of a template, &lt;code&gt;typename&lt;/code&gt; can be used to declare that a &lt;a href=&quot;../language/dependent_name&quot;&gt;dependent qualified name&lt;/a&gt; is a type.</source>
          <target state="translated">В объявлении или определении шаблона можно использовать &lt;code&gt;typename&lt;/code&gt; , чтобы объявить, что &lt;a href=&quot;../language/dependent_name&quot;&gt;зависимое квалифицированное имя&lt;/a&gt; является типом.</target>
        </trans-unit>
        <trans-unit id="c75e28d40b1ee1647f206ce29f91a72118f77dcb" translate="yes" xml:space="preserve">
          <source>Inside a declaration or a definition of a template,(until C++11)&lt;code&gt;typename&lt;/code&gt; can be used before a non-dependent qualified type name. It has no effect in this case.</source>
          <target state="translated">Внутри объявления или определения шаблона (до C ++ 11) можно использовать &lt;code&gt;typename&lt;/code&gt; перед независимым квалифицированным именем типа. Это не имеет никакого эффекта в этом случае.</target>
        </trans-unit>
        <trans-unit id="6cd46b31dc66a09cb27a8b94558ff90367369cb8" translate="yes" xml:space="preserve">
          <source>Inside a template definition, &lt;code&gt;template&lt;/code&gt; can be used to declare that a &lt;a href=&quot;../language/dependent_name&quot;&gt;dependent name&lt;/a&gt; is a template.</source>
          <target state="translated">Внутри определения шаблона, &lt;code&gt;template&lt;/code&gt; может использоваться для объявления, что &lt;a href=&quot;../language/dependent_name&quot;&gt;зависимое имя&lt;/a&gt; является шаблоном.</target>
        </trans-unit>
        <trans-unit id="350b4808c73cf8468a6f363916c30c4a397b3dc5" translate="yes" xml:space="preserve">
          <source>Inside class definition</source>
          <target state="translated">Внутреннее определение класса</target>
        </trans-unit>
        <trans-unit id="6b5698bf0daa42ff37c1cd0dca09d5b7656e92d2" translate="yes" xml:space="preserve">
          <source>Inside the definition of a &lt;a href=&quot;templates&quot;&gt;template&lt;/a&gt; (both &lt;a href=&quot;class_template&quot;&gt;class template&lt;/a&gt; and &lt;a href=&quot;function_template&quot;&gt;function template&lt;/a&gt;), the meaning of some constructs may differ from one instantiation to another. In particular, types and expressions may depend on types of type template parameters and values of non-type template parameters.</source>
          <target state="translated">Внутри определения &lt;a href=&quot;templates&quot;&gt;шаблона&lt;/a&gt; (как &lt;a href=&quot;class_template&quot;&gt;шаблон класса&lt;/a&gt; и &lt;a href=&quot;function_template&quot;&gt;шаблон функции&lt;/a&gt; ), смысл некоторых конструкций может отличаться от одного экземпляра к другому. В частности, типы и выражения могут зависеть от типов параметров шаблона типа и значений нетипичных параметров шаблона.</target>
        </trans-unit>
        <trans-unit id="29bb12e4f618840806749020bc50cf4a005ce46d" translate="yes" xml:space="preserve">
          <source>Inspects the declared type of an entity or the type and value category of an expression.</source>
          <target state="translated">Рассматривает объявленный тип сущности или тип и категорию значения выражения.</target>
        </trans-unit>
        <trans-unit id="55e8d92a13e25eb28d03d82349c3f32ae5b1856b" translate="yes" xml:space="preserve">
          <source>Instances of this class may also hold the special distinct value that does not represent any thread. Once a thread has finished, the value of &lt;code&gt;std::thread::id&lt;/code&gt; may be reused by another thread.</source>
          <target state="translated">Экземпляры этого класса могут также содержать особое отдельное значение, которое не представляет какой-либо поток. После завершения потока значение &lt;code&gt;std::thread::id&lt;/code&gt; может быть повторно использовано другим потоком.</target>
        </trans-unit>
        <trans-unit id="0323fe82517b3deef4dcc33c2202e8572f5af700" translate="yes" xml:space="preserve">
          <source>Instead of being defined by specific types, each category of iterator is defined by the operations that can be performed on it. This definition means that any type that supports the necessary operations can be used as an iterator -- for example, a pointer supports all of the operations required by &lt;a href=&quot;named_req/randomaccessiterator&quot;&gt;LegacyRandomAccessIterator&lt;/a&gt;, so a pointer can be used anywhere a &lt;a href=&quot;named_req/randomaccessiterator&quot;&gt;LegacyRandomAccessIterator&lt;/a&gt; is expected.</source>
          <target state="translated">Вместо того, чтобы быть определенным определенными типами, каждая категория итератора определяется операциями, которые могут быть выполнены над ним. Это определение означает, что любой тип, который поддерживает необходимые операции, может использоваться в качестве итератора - например, указатель поддерживает все операции, требуемые &lt;a href=&quot;named_req/randomaccessiterator&quot;&gt;LegacyRandomAccessIterator&lt;/a&gt; , поэтому указатель можно использовать везде, &lt;a href=&quot;named_req/randomaccessiterator&quot;&gt;где&lt;/a&gt; ожидается LegacyRandomAccessIterator .</target>
        </trans-unit>
        <trans-unit id="b12082e6b05d3b9bc176ff98ba66b29e9e0b12fe" translate="yes" xml:space="preserve">
          <source>Instead of creating copies of files, create hardlinks that resolve to the same files as the originals</source>
          <target state="translated">Вместо того,чтобы создавать копии файлов,создавайте жесткие ссылки,которые разрешают использовать те же файлы,что и оригиналы.</target>
        </trans-unit>
        <trans-unit id="78afece0e04a5cf908cc483529a4871648680f1b" translate="yes" xml:space="preserve">
          <source>Instead of creating copies of files, create symlinks pointing to the originals. Note: the source path must be an absolute path unless the destination path is in the current directory.</source>
          <target state="translated">Вместо того,чтобы создавать копии файлов,создавайте сим-ссылки,указывающие на оригиналы.Замечание:путь к источнику должен быть абсолютным,если только путь назначения не находится в текущей директории.</target>
        </trans-unit>
        <trans-unit id="cfaebf91cdac75d382847870cf98c644ae8839f0" translate="yes" xml:space="preserve">
          <source>Instead of using the overload (2) together with new, it is often a better idea to use &lt;code&gt;&lt;a href=&quot;make_unique&quot;&gt;std::make_unique&amp;lt;T&amp;gt;&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Вместо того, чтобы использовать перегрузку (2) вместе с new, часто лучше использовать &lt;code&gt;&lt;a href=&quot;make_unique&quot;&gt;std::make_unique&amp;lt;T&amp;gt;&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="15df2d5892f1c21a31c35b32a3d847ba47bdff20" translate="yes" xml:space="preserve">
          <source>Instructs the regular expression engine to make matching faster, with the potential cost of making construction slower. For example, this might mean converting a non-deterministic FSA to a deterministic FSA.</source>
          <target state="translated">Инструктирует движок регулярных выражений,чтобы сделать совпадение быстрее,с потенциальной стоимостью сделать строительство медленнее.Например,это может означать преобразование недетерминистического FSA в детерминистический FSA.</target>
        </trans-unit>
        <trans-unit id="d29911b1bd2caeb5ec80c99646811291a26cf594" translate="yes" xml:space="preserve">
          <source>IntType</source>
          <target state="translated">IntType</target>
        </trans-unit>
        <trans-unit id="876569ad85ebaf17d9149dea5706aba22e882fe8" translate="yes" xml:space="preserve">
          <source>Integer types</source>
          <target state="translated">Целочисленные типы</target>
        </trans-unit>
        <trans-unit id="d19f3662fc5d3aa69996dfa0c88356fda0d60fc4" translate="yes" xml:space="preserve">
          <source>Integer value corresponding to the contents of &lt;code&gt;str&lt;/code&gt; on success. If the converted value falls out of range of corresponding return type, range error occurs and &lt;code&gt;&lt;a href=&quot;../../types/climits&quot;&gt;LONG_MAX&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../../types/climits&quot;&gt;LONG_MIN&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../../types/climits&quot;&gt;LLONG_MAX&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../../types/climits&quot;&gt;LLONG_MIN&lt;/a&gt;&lt;/code&gt; is returned. If no conversion can be performed, &lt;code&gt;​0​&lt;/code&gt; is returned.</source>
          <target state="translated">Целочисленное значение, соответствующее содержимому &lt;code&gt;str&lt;/code&gt; в случае успеха. Если преобразованное значение выходит за пределы диапазона соответствующего возвращаемого типа, возникает ошибка диапазона и &lt;code&gt;&lt;a href=&quot;../../types/climits&quot;&gt;LONG_MAX&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../../types/climits&quot;&gt;LONG_MIN&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../../types/climits&quot;&gt;LLONG_MAX&lt;/a&gt;&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;../../types/climits&quot;&gt;LLONG_MIN&lt;/a&gt;&lt;/code&gt; . Если преобразование не может быть выполнено, &lt;code&gt;​0​&lt;/code&gt; возвращается.</target>
        </trans-unit>
        <trans-unit id="1da9ae4426444f430bd1d7493a5b5250c7cfec29" translate="yes" xml:space="preserve">
          <source>Integer value corresponding to the contents of &lt;code&gt;str&lt;/code&gt; on success. If the converted value falls out of range of corresponding return type, range error occurs and &lt;code&gt;&lt;a href=&quot;../../types/climits&quot;&gt;ULONG_MAX&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../../types/climits&quot;&gt;ULLONG_MAX&lt;/a&gt;&lt;/code&gt; is returned. If no conversion can be performed, &lt;code&gt;​0​&lt;/code&gt; is returned.</source>
          <target state="translated">Целочисленное значение, соответствующее содержимому &lt;code&gt;str&lt;/code&gt; в случае успеха. Если преобразованное значение выходит за пределы диапазона соответствующего возвращаемого типа, возникает ошибка диапазона и &lt;code&gt;&lt;a href=&quot;../../types/climits&quot;&gt;ULONG_MAX&lt;/a&gt;&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;../../types/climits&quot;&gt;ULLONG_MAX&lt;/a&gt;&lt;/code&gt; . Если преобразование не может быть выполнено, &lt;code&gt;​0​&lt;/code&gt; возвращается.</target>
        </trans-unit>
        <trans-unit id="52e4539e8037f8f852f5856d00606b776679d442" translate="yes" xml:space="preserve">
          <source>Integer value corresponding to the contents of &lt;code&gt;str&lt;/code&gt; on success. If the converted value falls out of range of corresponding return type, range error occurs and &lt;code&gt;&lt;a href=&quot;../../types/integer&quot;&gt;INTMAX_MAX&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../../types/integer&quot;&gt;INTMAX_MIN&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../../types/integer&quot;&gt;UINTMAX_MAX&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;​0​&lt;/code&gt; is returned, as appropriate. If no conversion can be performed, &lt;code&gt;​0​&lt;/code&gt; is returned.</source>
          <target state="translated">Целочисленное значение, соответствующее содержимому &lt;code&gt;str&lt;/code&gt; в случае успеха. Если преобразованное значение выпадает из диапазона соответствующих возвращаемого типа, диапазон ошибки возникают и &lt;code&gt;&lt;a href=&quot;../../types/integer&quot;&gt;INTMAX_MAX&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../../types/integer&quot;&gt;INTMAX_MIN&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../../types/integer&quot;&gt;UINTMAX_MAX&lt;/a&gt;&lt;/code&gt; , или &lt;code&gt;​0​&lt;/code&gt; , возвращаются, в зависимости от обстоятельств. Если преобразование не может быть выполнено, &lt;code&gt;​0​&lt;/code&gt; возвращается.</target>
        </trans-unit>
        <trans-unit id="21098bb738833ee0f4f792151a59d559da8ec6b0" translate="yes" xml:space="preserve">
          <source>Integer value corresponding to the contents of &lt;code&gt;str&lt;/code&gt; on success. If the converted value falls out of range of corresponding return type, the return value is undefined. If no conversion can be performed, &lt;code&gt;​0​&lt;/code&gt; is returned.</source>
          <target state="translated">Целочисленное значение, соответствующее содержимому &lt;code&gt;str&lt;/code&gt; в случае успеха. Если преобразованное значение выпадает из диапазона соответствующего возвращаемого типа, возвращаемое значение не определено. Если преобразование не может быть выполнено, &lt;code&gt;​0​&lt;/code&gt; возвращается.</target>
        </trans-unit>
        <trans-unit id="e3b59c9f1c26e320e172cac39695e68589e740a0" translate="yes" xml:space="preserve">
          <source>Integral</source>
          <target state="translated">Integral</target>
        </trans-unit>
        <trans-unit id="b825f7aa91a4416d2a86fdbf6d9049ea6b2d615d" translate="yes" xml:space="preserve">
          <source>Integral constant expression</source>
          <target state="translated">Интегральное постоянное выражение</target>
        </trans-unit>
        <trans-unit id="1f4e6183969d6ec80ad6d2f378b3a85f029c653b" translate="yes" xml:space="preserve">
          <source>Integral conversions</source>
          <target state="translated">Интегральные преобразования</target>
        </trans-unit>
        <trans-unit id="320e2752aea495aec73f84035d1bb6ef868679ad" translate="yes" xml:space="preserve">
          <source>Integral promotion</source>
          <target state="translated">Интегральное продвижение</target>
        </trans-unit>
        <trans-unit id="270f2235f730fd6efca2aa9d17f0dc702810f771" translate="yes" xml:space="preserve">
          <source>Intel C++ Inline Assembly</source>
          <target state="translated">Интеллектуальная онлайн-сборка Intel C++</target>
        </trans-unit>
        <trans-unit id="48e94a1cde254c1213e9904ae2fa6aec7a82e049" translate="yes" xml:space="preserve">
          <source>Inter-thread happens-before</source>
          <target state="translated">Взаимодействие между резьбами происходит-до того,как</target>
        </trans-unit>
        <trans-unit id="fbefd7a4bdb4b3775050f8fe665496f4fc106f7d" translate="yes" xml:space="preserve">
          <source>Inter-thread synchronization and memory ordering determine how</source>
          <target state="translated">Межпотоковая синхронизация и упорядочение памяти определяют,как</target>
        </trans-unit>
        <trans-unit id="e341892f1cc87078f7d5e926c1138ccb82e90235" translate="yes" xml:space="preserve">
          <source>Internal Compiler Error</source>
          <target state="translated">Внутренняя ошибка компилятора</target>
        </trans-unit>
        <trans-unit id="8db0e387b648322ee87a237498c06354600d50c6" translate="yes" xml:space="preserve">
          <source>Internal extensible array</source>
          <target state="translated">Внутренний расширяемый массив</target>
        </trans-unit>
        <trans-unit id="3eec2f184115efd5c87c5ee6ebf0d6b3a9c071ab" translate="yes" xml:space="preserve">
          <source>Internally, a locale object is implemented as-if it is a reference-counted pointer to an array (indexed by &lt;code&gt;&lt;a href=&quot;locale/id&quot;&gt;std::locale::id&lt;/a&gt;&lt;/code&gt;) of reference-counted pointers to facets: copying a locale only copies one pointer and increments several reference counts. To maintain the standard C++ library thread safety guarantees (operations on different objects are always thread-safe), both the locale reference count and each facet reference count are updated in thread-safe manner, similar to &lt;code&gt;&lt;a href=&quot;../memory/shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Внутренне объект локали реализован так, как если бы он был указателем с подсчетом ссылок на массив (индексируемый &lt;code&gt;&lt;a href=&quot;locale/id&quot;&gt;std::locale::id&lt;/a&gt;&lt;/code&gt; ) указателей с подсчетом ссылок на фасеты: при копировании локали копируется только один указатель и увеличивается несколько ссылок на счет. Чтобы поддерживать стандартные гарантии безопасности потоков библиотеки C ++ (операции над различными объектами всегда потокобезопасны), и счетчик ссылок на локаль, и счетчик ссылок на каждый фасет обновляются потокобезопасным способом, аналогично &lt;code&gt;&lt;a href=&quot;../memory/shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9dac1e92729539ac11d8cad38e7bddd13ef84d39" translate="yes" xml:space="preserve">
          <source>Internally, the character is converted to &lt;code&gt;unsigned char&lt;/code&gt; just before being written.</source>
          <target state="translated">Внутренне, символ преобразуется в &lt;code&gt;unsigned char&lt;/code&gt; непосредственно перед написанием.</target>
        </trans-unit>
        <trans-unit id="1a300aede5a38ab0ed12e3cbf6171db92a06f041" translate="yes" xml:space="preserve">
          <source>Internally, the elements are not sorted in any particular order, but organized into buckets. Which bucket an element is placed into depends entirely on the hash of its key. This allows fast access to individual elements, since once the hash is computed, it refers to the exact bucket the element is placed into.</source>
          <target state="translated">Внутри элементы отсортированы не в каком-то определенном порядке,а организованы в ведра.В какое ведро помещается элемент,полностью зависит от хэша его ключа.Это позволяет быстро получить доступ к отдельным элементам,так как после вычисления хэша он относится к точному ведру,в которое укладывается элемент.</target>
        </trans-unit>
        <trans-unit id="8e3d09a97f93ab12396f4f53a23484c5868af0eb" translate="yes" xml:space="preserve">
          <source>Internally, the elements are not sorted in any particular order, but organized into buckets. Which bucket an element is placed into depends entirely on the hash of its value. This allows fast access to individual elements, since once a hash is computed, it refers to the exact bucket the element is placed into.</source>
          <target state="translated">Внутри элементы отсортированы не в каком-то определенном порядке,а организованы в ведра.В какое ведро помещается элемент,полностью зависит от хэша его стоимости.Это позволяет быстро получить доступ к отдельным элементам,так как после вычисления хэша,он относится к точному ведру,в которое укладывается элемент.</target>
        </trans-unit>
        <trans-unit id="1d351577d1e15db8313b9f13fd0274b045e4b3f2" translate="yes" xml:space="preserve">
          <source>Internally, the elements are not sorted in any particular order, but organized into buckets. Which bucket an element is placed into depends entirely on the hash of its value. This allows fast access to individual elements, since once hash is computed, it refers to the exact bucket the element is placed into.</source>
          <target state="translated">Внутри элементы отсортированы не в каком-то определенном порядке,а организованы в ведра.В какое ведро помещается элемент,полностью зависит от хэша его стоимости.Это позволяет быстро получить доступ к отдельным элементам,так как после вычисления хэша он относится к точному ведру,в которое укладывается элемент.</target>
        </trans-unit>
        <trans-unit id="4000ac517f025eca6a922c089403bb09186f8d96" translate="yes" xml:space="preserve">
          <source>International monetary numeric formatting parameters</source>
          <target state="translated">Международные параметры денежно-кредитного числового форматирования</target>
        </trans-unit>
        <trans-unit id="a8ae931d734dc08b103a3cda5b6a5d402a381387" translate="yes" xml:space="preserve">
          <source>Interpolation operations</source>
          <target state="translated">интерполяционные работы</target>
        </trans-unit>
        <trans-unit id="0f1ee1e93c2e9e3ff3649d6745a31dd59c9090f7" translate="yes" xml:space="preserve">
          <source>Interprets a floating point value in a byte string pointed to by &lt;code&gt;str&lt;/code&gt;.</source>
          <target state="translated">Интерпретирует значение с плавающей запятой в байтовой строке, на которую указывает &lt;code&gt;str&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c521564a7a070d90bbed7e76e298ba2e2b938b7a" translate="yes" xml:space="preserve">
          <source>Interprets a floating point value in a string &lt;code&gt;str&lt;/code&gt;.</source>
          <target state="translated">Интерпретирует значение с плавающей запятой в строке &lt;code&gt;str&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bc48cbadb6a84efbed23317d93156122ffd8c740" translate="yes" xml:space="preserve">
          <source>Interprets a floating point value in a wide string pointed to by &lt;code&gt;str&lt;/code&gt;.</source>
          <target state="translated">Интерпретирует значение с плавающей запятой в широкой строке, на которую указывает &lt;code&gt;str&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ad9f4a5a657fd23f774f0701ca42e9ed82c97178" translate="yes" xml:space="preserve">
          <source>Interprets a signed integer value in the string &lt;code&gt;str&lt;/code&gt;.</source>
          <target state="translated">Интерпретирует целочисленное значение со знаком в строке &lt;code&gt;str&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9a608036eb59f94001912ca3733a0c15c944b183" translate="yes" xml:space="preserve">
          <source>Interprets an integer value in a byte string pointed to by &lt;code&gt;nptr&lt;/code&gt;.</source>
          <target state="translated">Интерпретирует целочисленное значение в байтовой строке, на которую указывает &lt;code&gt;nptr&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="566cf8ed0ac571b4f2aa3ca75d488875487baeb4" translate="yes" xml:space="preserve">
          <source>Interprets an integer value in a byte string pointed to by &lt;code&gt;str&lt;/code&gt;.</source>
          <target state="translated">Интерпретирует целочисленное значение в байтовой строке, на которую указывает &lt;code&gt;str&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cc2bd5d023e90da3e1640fc0f66845e22f6c8508" translate="yes" xml:space="preserve">
          <source>Interprets an integer value in a wide string pointed to by &lt;code&gt;str&lt;/code&gt;.</source>
          <target state="translated">Интерпретирует целочисленное значение в широкой строке, на которую указывает &lt;code&gt;str&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="042a224facaad3cdf57ba7458290bd20ddbab9ab" translate="yes" xml:space="preserve">
          <source>Interprets an unsigned integer value in a byte string pointed to by &lt;code&gt;str&lt;/code&gt;.</source>
          <target state="translated">Интерпретирует целое число без знака в байтовой строке, на которую указывает &lt;code&gt;str&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="65b433c8b60cb3b8c5443581467dc0f6ae5b6523" translate="yes" xml:space="preserve">
          <source>Interprets an unsigned integer value in a wide string pointed to by &lt;code&gt;nptr&lt;/code&gt;.</source>
          <target state="translated">Интерпретирует целочисленное значение без знака в широкой строке, на которую указывает &lt;code&gt;nptr&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="148c33b3cec53bcad46f4795046e389f68465431" translate="yes" xml:space="preserve">
          <source>Interprets an unsigned integer value in a wide string pointed to by &lt;code&gt;str&lt;/code&gt;.</source>
          <target state="translated">Интерпретирует целочисленное значение без знака в широкой строке, на которую указывает &lt;code&gt;str&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="aabb8c7d3ca13ab71a2338fd76d6fca5fd94220c" translate="yes" xml:space="preserve">
          <source>Interprets an unsigned integer value in the string &lt;code&gt;str&lt;/code&gt;.</source>
          <target state="translated">Интерпретирует целое число без знака в строке &lt;code&gt;str&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9aa738055f64e3e6394c5784c7988113147a1c1a" translate="yes" xml:space="preserve">
          <source>Interrupted function</source>
          <target state="translated">Прерывистая функция</target>
        </trans-unit>
        <trans-unit id="dded3e7aba46e073c03bff678699e36b51e2c4a9" translate="yes" xml:space="preserve">
          <source>Introduces a name that is defined elsewhere into the declarative region where this using-declaration appears.</source>
          <target state="translated">Вводит имя,которое определено в другом месте в декларативную область,где появляется данное использование-декларация.</target>
        </trans-unit>
        <trans-unit id="d63eba892386df3bd9064d08a9292099f5ee5b9f" translate="yes" xml:space="preserve">
          <source>Introduces implementation-defined attributes for types, objects, code, etc.  &lt;code&gt;[[&lt;/code&gt;</source>
          <target state="translated">Вводит определяемые реализацией атрибуты для типов, объектов, кода и т. Д. &lt;code&gt;[[&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="45ff4427a9f1fb0c18cbcdf6b26d6a2d22f2df2f" translate="yes" xml:space="preserve">
          <source>Invalid argument</source>
          <target state="translated">Недействительный аргумент</target>
        </trans-unit>
        <trans-unit id="1383c7b39080e5234bcaae9c303e96b402357694" translate="yes" xml:space="preserve">
          <source>Invalid non-zero alignments, such as &lt;code&gt;alignas(3)&lt;/code&gt; are ill-formed.</source>
          <target state="translated">Неправильные ненулевые выравнивания, такие как &lt;code&gt;alignas(3)&lt;/code&gt; имеют неправильную форму .</target>
        </trans-unit>
        <trans-unit id="86c96ba7411037b346432868bfdb3e867290952c" translate="yes" xml:space="preserve">
          <source>Invalid scalar</source>
          <target state="translated">недействительный скаляр</target>
        </trans-unit>
        <trans-unit id="b6b99ba962e359de15e0e27fd677ea67331c95bc" translate="yes" xml:space="preserve">
          <source>Invalid seek</source>
          <target state="translated">Недействительный поиск</target>
        </trans-unit>
        <trans-unit id="41fc9b91f0fee77d14d8c449a0016aae8b1ef082" translate="yes" xml:space="preserve">
          <source>Invalidated</source>
          <target state="translated">Invalidated</target>
        </trans-unit>
        <trans-unit id="5184a57889a8a3581992c2997ad61b14585f2ce0" translate="yes" xml:space="preserve">
          <source>Invalidates any references, pointers, or iterators referring to contained elements. Any past-the-end iterator remains valid.</source>
          <target state="translated">Недействительность любых ссылок,указателей или итераторов,относящихся к содержащимся элементам.Любой прошедший итератор остается действительным.</target>
        </trans-unit>
        <trans-unit id="7c48efeaf38e5bc872433889acf9dca25ee7978e" translate="yes" xml:space="preserve">
          <source>Invalidates any references, pointers, or iterators referring to contained elements. Any past-the-end iterators are also invalidated.</source>
          <target state="translated">Недействительность любых ссылок,указателей или итераторов,относящихся к содержащимся элементам.Любые прошедшие итераторы также недействительны.</target>
        </trans-unit>
        <trans-unit id="84523b9994334aa4168c1ce7715701ecd8e7c500" translate="yes" xml:space="preserve">
          <source>Invalidates any references, pointers, or iterators referring to contained elements. May also invalidate past-the-end iterators.</source>
          <target state="translated">Недействительность любых ссылок,указателей или итераторов,относящихся к содержащимся элементам.Может также сделать недействительными прошлые итераторы.</target>
        </trans-unit>
        <trans-unit id="900eb067daacf1fc2f277185d1c086ea7646a1aa" translate="yes" xml:space="preserve">
          <source>Invalidates iterators and references at or after the point of the erase, including the &lt;code&gt;&lt;a href=&quot;end&quot;&gt;end()&lt;/a&gt;&lt;/code&gt; iterator.</source>
          <target state="translated">Делает недействительными итераторы и ссылки в или после точки удаления, включая итератор &lt;code&gt;&lt;a href=&quot;end&quot;&gt;end()&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="57cfa38621b674967383a26be5a5ea85e99b30e4" translate="yes" xml:space="preserve">
          <source>Invalidation notes</source>
          <target state="translated">Инвалидационные примечания</target>
        </trans-unit>
        <trans-unit id="4b1ed8b8c1a0fe2800fdf2738e1f7cc4d2d7cef2" translate="yes" xml:space="preserve">
          <source>Inverse cosine (or arc cosine) is a multivalued function and requires a branch cut on the complex plane. The branch cut is conventionally placed at the line segments (-&amp;infin;,-1) and (1,&amp;infin;) of the real axis.  The mathematical definition of the principal value of arc cosine is acos z =</source>
          <target state="translated">Обратный косинус (или арккосинус) - это многозначная функция, для которой требуется разрез ветвей на комплексной плоскости. Отрезок ветки обычно размещают на отрезках (-&amp;infin;, -1) и (1, &amp;infin;) действительной оси. Математическое определение главного значения арккосинуса: acos z =</target>
        </trans-unit>
        <trans-unit id="92db73712a1ea6cdea29021a66a4e0d10b6b003b" translate="yes" xml:space="preserve">
          <source>Inverse hyperbolic cosine is a multivalued function and requires a branch cut on the complex plane. The branch cut is conventionally placed at the line segment (-&amp;infin;,+1) of the real axis.</source>
          <target state="translated">Обратный гиперболический косинус является многозначной функцией и требует разреза ветвей на комплексной плоскости. Отрезок ветки традиционно размещают на отрезке (-&amp;infin;, + 1) действительной оси.</target>
        </trans-unit>
        <trans-unit id="3ff0648a78636309b1cc12a67a5c7841a27e8966" translate="yes" xml:space="preserve">
          <source>Inverse hyperbolic sine is a multivalued function and requires a branch cut on the complex plane. The branch cut is conventionally placed at the line segments (-</source>
          <target state="translated">Обратный гиперболический синус является многозначной функцией и требует среза ветки на комплексной плоскости.Отрезок ветви условно располагается на отрезках линии (-</target>
        </trans-unit>
        <trans-unit id="60cf8f72dc186c6f4b4743734e8e8ed4cb1bd30a" translate="yes" xml:space="preserve">
          <source>Inverse hyperbolic tangent is a multivalued function and requires a branch cut on the complex plane. The branch cut is conventionally placed at the line segmentd (-&amp;infin;,-1] and [+1,+&amp;infin;) of the real axis.  The mathematical definition of the principal value of the inverse hyperbolic tangent is atanh z =</source>
          <target state="translated">Обратный гиперболический тангенс является многозначной функцией и требует разреза ветвей на комплексной плоскости. Отрезок ветки обычно размещают на отрезке прямой (-&amp;infin;, -1] и [+ 1, + &amp;infin;) действительной оси. Математическое определение главной величины обратной гиперболической касательной имеет вид atanh z =</target>
        </trans-unit>
        <trans-unit id="ff28b3449f26b28c2a2ed73fffb64ba03b0e2959" translate="yes" xml:space="preserve">
          <source>Inverse sine (or arc sine) is a multivalued function and requires a branch cut on the complex plane. The branch cut is conventionally placed at the line segments (-&amp;infin;,-1) and (1,&amp;infin;) of the real axis.</source>
          <target state="translated">Обратный синус (или дуговой синус) - это многозначная функция, для которой требуется срез ответвления на комплексной плоскости. Отрезок ветки обычно размещают на отрезках (-&amp;infin;, -1) и (1, &amp;infin;) действительной оси.</target>
        </trans-unit>
        <trans-unit id="8a394149a1f48f15fcf530168253dbecfeb4322f" translate="yes" xml:space="preserve">
          <source>Inverse tangent (or arc tangent) is a multivalued function and requires a branch cut on the complex plane. The branch cut is conventionally placed at the line segments (-&amp;infin;i,-i) and (+i,+&amp;infin;i) of the imaginary axis.  The mathematical definition of the principal value of inverse tangent is atan z = -</source>
          <target state="translated">Обратная касательная (или арктангенс) является многозначной функцией и требует разрезания ветвей на комплексной плоскости. Отрезок ветки обычно размещают на отрезках (-&amp;infin;i, -i) и (+ i, + &amp;infin;i) мнимой оси. Математическое определение главной величины обратной касательной: atan z = -</target>
        </trans-unit>
        <trans-unit id="e22b4961b86c756eeda2aa9b446c8173116dbbc7" translate="yes" xml:space="preserve">
          <source>Inverts the referenced bit.</source>
          <target state="translated">Инвертирует указанный бит.</target>
        </trans-unit>
        <trans-unit id="08fcf3f000c798d1019b77985f2565bd9131f8e3" translate="yes" xml:space="preserve">
          <source>InvocableRegularInvocable</source>
          <target state="translated">InvocableRegularInvocable</target>
        </trans-unit>
        <trans-unit id="d4f9cb47dbcc2422f0bd9a0424a0965a711f4fe4" translate="yes" xml:space="preserve">
          <source>Invoke the &lt;a href=&quot;../../named_req/callable&quot;&gt;Callable&lt;/a&gt; object &lt;code&gt;f&lt;/code&gt; with the parameters &lt;code&gt;args&lt;/code&gt;. As by &lt;code&gt;INVOKE(&lt;a href=&quot;../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;F&amp;gt;(f), &lt;a href=&quot;../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;Args&amp;gt;(args)...)&lt;/code&gt;.</source>
          <target state="translated">Вызов &lt;a href=&quot;../../named_req/callable&quot;&gt;Callable&lt;/a&gt; объекта &lt;code&gt;f&lt;/code&gt; с параметрами &lt;code&gt;args&lt;/code&gt; . Как и в случае &lt;code&gt;INVOKE(&lt;a href=&quot;../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;F&amp;gt;(f), &lt;a href=&quot;../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;Args&amp;gt;(args)...)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="43a887b06ff69b20968832ea3de0f894899ed0b1" translate="yes" xml:space="preserve">
          <source>Invoke the &lt;a href=&quot;../named_req/callable&quot;&gt;Callable&lt;/a&gt; object &lt;code&gt;f&lt;/code&gt; with a tuple of arguments.</source>
          <target state="translated">Вызов &lt;a href=&quot;../named_req/callable&quot;&gt;отзывной&lt;/a&gt; объекта &lt;code&gt;f&lt;/code&gt; с кортежем аргументов.</target>
        </trans-unit>
        <trans-unit id="a0f26292e2434ecd2054e3f89ad01624a3592aac" translate="yes" xml:space="preserve">
          <source>Invokes &lt;code&gt;b.seed()&lt;/code&gt;.</source>
          <target state="translated">Вызывает &lt;code&gt;b.seed()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="533e38b5b781a7cf4c13a2c009ad69bee4e181ab" translate="yes" xml:space="preserve">
          <source>Invokes &lt;code&gt;b.seed(q)&lt;/code&gt;.</source>
          <target state="translated">Вызывает &lt;code&gt;b.seed(q)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c8de535373bc28162e3e7e5c533ad8d22bcee959" translate="yes" xml:space="preserve">
          <source>Invokes &lt;code&gt;b.seed(s)&lt;/code&gt;.</source>
          <target state="translated">Вызывает &lt;code&gt;b.seed(s)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="43efae5b116e5f3d09b4e59697f462efb6558f1d" translate="yes" xml:space="preserve">
          <source>Invokes implementation-defined behaviour if not &lt;code&gt;&lt;a href=&quot;../io/streamoff&quot;&gt;std::streamoff&lt;/a&gt;&lt;/code&gt; when &lt;code&gt;X&lt;/code&gt; is used as the traits template parameter in input/output classes.</source>
          <target state="translated">Вызывает поведение, определяемое реализацией, если не &lt;code&gt;&lt;a href=&quot;../io/streamoff&quot;&gt;std::streamoff&lt;/a&gt;&lt;/code&gt; когда &lt;code&gt;X&lt;/code&gt; используется в качестве параметра шаблона признаков в классах ввода / вывода.</target>
        </trans-unit>
        <trans-unit id="fed12ee3ef79fc236fc9bb3fd94d2fb99592217c" translate="yes" xml:space="preserve">
          <source>Invokes implementation-defined behaviour if this type is not &lt;code&gt;&lt;a href=&quot;../io/fpos&quot;&gt;std::streampos&lt;/a&gt;&lt;/code&gt; when &lt;code&gt;X&lt;/code&gt; is used as the traits template parameter in input/output classes</source>
          <target state="translated">Вызывает поведение, определяемое реализацией, если этот тип не является &lt;code&gt;&lt;a href=&quot;../io/fpos&quot;&gt;std::streampos&lt;/a&gt;&lt;/code&gt; когда &lt;code&gt;X&lt;/code&gt; используется в качестве параметра шаблона признаков в классах ввода / вывода</target>
        </trans-unit>
        <trans-unit id="10839e4e143f807b60e96a2d95d532d052d717e3" translate="yes" xml:space="preserve">
          <source>Invokes the stored callable function target with the parameters &lt;code&gt;args&lt;/code&gt;.</source>
          <target state="translated">Вызывает сохраненную функцию вызываемой функции с параметрами &lt;code&gt;args&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b3c06b4bbdf7388ea26ca66d81ec0d37bcc14b0f" translate="yes" xml:space="preserve">
          <source>Invoking over Incomplete Types</source>
          <target state="translated">Приглашение к неполным типам</target>
        </trans-unit>
        <trans-unit id="d82b06adf1a876d702b6a3905d8d56b51827e40e" translate="yes" xml:space="preserve">
          <source>Is a directory</source>
          <target state="translated">Это каталог</target>
        </trans-unit>
        <trans-unit id="3dfd81af531e4d3b7128a14d5c41e637a26dc974" translate="yes" xml:space="preserve">
          <source>It can also be called using member function call syntax:</source>
          <target state="translated">Он также может быть вызван с помощью синтаксиса вызова функции-член:</target>
        </trans-unit>
        <trans-unit id="09e1f9f748059f808777769884d3dc5b93769167" translate="yes" xml:space="preserve">
          <source>It can also be used to detect validity of an expression:</source>
          <target state="translated">Она также может быть использована для определения достоверности выражения:</target>
        </trans-unit>
        <trans-unit id="3ee5198972c83e32aa4a5a28496aa84dc1d7e5c4" translate="yes" xml:space="preserve">
          <source>It can be used to specify additional constraints in terms of local parameters. The constraint-expression must be satisfied by the substituted template arguments, if any. Substitution of template arguments into a nested requirement causes substitution into the constraint-expression only to the extent needed to determine whether the constraint-expression is satisfied.</source>
          <target state="translated">Он может быть использован для указания дополнительных ограничений с точки зрения локальных параметров.Выражение-ограничение должно удовлетворяться подставленными аргументами шаблона,если таковые имеются.Подстановка аргументов шаблона во вложенное требование вызывает подстановку в выражение-ограничение только в той степени,в какой это необходимо для определения соответствия выражению-ограничению.</target>
        </trans-unit>
        <trans-unit id="619583a1fc7588b9b8e425ca17f621a35be87edb" translate="yes" xml:space="preserve">
          <source>It can be used with a named variable:</source>
          <target state="translated">Она может быть использована с именованной переменной:</target>
        </trans-unit>
        <trans-unit id="dc95ed9cfcbc19e43b1a73cbe3345e11d2c4b4b0" translate="yes" xml:space="preserve">
          <source>It can be used within a function template's &lt;a href=&quot;noexcept_spec&quot;&gt; noexcept specifier&lt;/a&gt; to declare that the function will throw exceptions for some types but not others.</source>
          <target state="translated">Его можно использовать в &lt;a href=&quot;noexcept_spec&quot;&gt;спецификаторе noexcept&lt;/a&gt; шаблона функции, чтобы объявить, что функция будет выдавать исключения для некоторых типов, но не для других.</target>
        </trans-unit>
        <trans-unit id="1095ba2835f4490f22e5cd2104e56ec80a11aef2" translate="yes" xml:space="preserve">
          <source>It consists of a collection of</source>
          <target state="translated">Она состоит из коллекции</target>
        </trans-unit>
        <trans-unit id="a6dfca72e61bb66f5282dc9be56b501edd0e1c20" translate="yes" xml:space="preserve">
          <source>It consists of a count of ticks of type &lt;code&gt;Rep&lt;/code&gt; and a tick period, where the tick period is a compile-time rational constant representing the number of seconds from one tick to the next.</source>
          <target state="translated">Он состоит из числа тиков типа &lt;code&gt;Rep&lt;/code&gt; и периода тиков , где период тиков - это рациональная постоянная времени компиляции, представляющая количество секунд от одного тика до следующего.</target>
        </trans-unit>
        <trans-unit id="8fe8176ea54439a7ccb802fb9944ca38d007f40a" translate="yes" xml:space="preserve">
          <source>It has the same &lt;a href=&quot;access&quot;&gt;access&lt;/a&gt; as the corresponding base constructor. It is &lt;code&gt;constexpr&lt;/code&gt; if the user-defined constructor would have satisfied &lt;code&gt;constexpr&lt;/code&gt; constructor requirements. It is deleted if the corresponding base constructor is deleted or if a defaulted default constructor would be deleted (except that the construction of the base whose constructor is being inherited doesn't count). An inheriting constructor cannot be explicitly instantiated or explicitly specialized.</source>
          <target state="translated">Он имеет тот же &lt;a href=&quot;access&quot;&gt;доступ,&lt;/a&gt; что и соответствующий базовый конструктор. Это &lt;code&gt;constexpr&lt;/code&gt; , если определяемый пользователем конструктор удовлетворял &lt;code&gt;constexpr&lt;/code&gt; требованиям конструктора constexpr . Он удаляется, если удаляется соответствующий базовый конструктор или удаляется конструктор по умолчанию по умолчанию (за исключением того, что конструкция базы, конструктор которой наследуется, не учитывается). Наследующий конструктор не может быть явно создан или явно специализирован.</target>
        </trans-unit>
        <trans-unit id="0ac2d8ef890218e1971697be578d263616be6031" translate="yes" xml:space="preserve">
          <source>It indicates that a the function definition should be optimized for invocation from a &lt;code&gt;synchronized&lt;/code&gt; statement. In particular, it avoids serializing synchronized blocks that make a call to a function that is transaction-safe for the majority of calls, but not for all calls (e.g. hash table insertion that may have to rehash, allocator that may have to request a new block, a simple function that may rarely log).</source>
          <target state="translated">Это указывает на то, что определение функции должно быть оптимизировано для вызова из &lt;code&gt;synchronized&lt;/code&gt; оператора. В частности, он избегает сериализации синхронизированных блоков, которые делают вызов функции, которая безопасна для транзакций для большинства вызовов, но не для всех вызовов (например, вставка хеш-таблицы, для которой может потребоваться перефразировка, распределитель, который может запросить новый блок, простая функция, которая может редко регистрироваться).</target>
        </trans-unit>
        <trans-unit id="31f0bb20de8e96b8260678ddcc2cec2269507d64" translate="yes" xml:space="preserve">
          <source>It is a non-binding request to reduce &lt;code&gt;&lt;a href=&quot;capacity&quot;&gt;capacity()&lt;/a&gt;&lt;/code&gt; to &lt;code&gt;&lt;a href=&quot;size&quot;&gt;size()&lt;/a&gt;&lt;/code&gt;. It depends on the implementation if the request is fulfilled.</source>
          <target state="translated">Это необязательный запрос на уменьшение &lt;code&gt;&lt;a href=&quot;capacity&quot;&gt;capacity()&lt;/a&gt;&lt;/code&gt; до &lt;code&gt;&lt;a href=&quot;size&quot;&gt;size()&lt;/a&gt;&lt;/code&gt; . Это зависит от реализации, если запрос выполнен.</target>
        </trans-unit>
        <trans-unit id="2d5740434b4376cbb133c18052ef3ec7113f5eaf" translate="yes" xml:space="preserve">
          <source>It is a non-binding request to reduce &lt;code&gt;&lt;a href=&quot;capacity&quot;&gt;capacity()&lt;/a&gt;&lt;/code&gt; to &lt;code&gt;&lt;a href=&quot;size&quot;&gt;size()&lt;/a&gt;&lt;/code&gt;. It depends on the implementation whether the request is fulfilled.</source>
          <target state="translated">Это необязательный запрос на уменьшение &lt;code&gt;&lt;a href=&quot;capacity&quot;&gt;capacity()&lt;/a&gt;&lt;/code&gt; до &lt;code&gt;&lt;a href=&quot;size&quot;&gt;size()&lt;/a&gt;&lt;/code&gt; . От реализации зависит, будет ли выполнен запрос.</target>
        </trans-unit>
        <trans-unit id="4b00903590e8f552a1ace12bc5841762223d788d" translate="yes" xml:space="preserve">
          <source>It is a non-binding request to reduce the memory usage without changing the size of the sequence. It depends on the implementation whether the request is fulfilled.</source>
          <target state="translated">Это необязывающий запрос на уменьшение использования памяти без изменения размера последовательности.Это зависит от реализации,будет ли запрос выполнен.</target>
        </trans-unit>
        <trans-unit id="d97fe75aaa98f7e001c2ef2b3b758e21ceb5c984" translate="yes" xml:space="preserve">
          <source>It is allowed for the same declaration to be found more than once:</source>
          <target state="translated">Одно и то же заявление может быть найдено несколько раз:</target>
        </trans-unit>
        <trans-unit id="7acda9ca39c15e684583b5939db44164abbca690" translate="yes" xml:space="preserve">
          <source>It is an error if &lt;code&gt;p&lt;/code&gt; does not refer to a symbolic link.</source>
          <target state="translated">Это ошибка, если &lt;code&gt;p&lt;/code&gt; не ссылается на символическую ссылку.</target>
        </trans-unit>
        <trans-unit id="4ac6d6c59239a9e9a0945510352b875d15d0c303" translate="yes" xml:space="preserve">
          <source>It is equivalent to.</source>
          <target state="translated">Это эквивалентно.</target>
        </trans-unit>
        <trans-unit id="dd397495d30164a47687cc68d3ee3debb8de228e" translate="yes" xml:space="preserve">
          <source>It is implementation-defined whether &lt;code&gt;rand()&lt;/code&gt; is thread-safe.</source>
          <target state="translated">Это зависит от реализации, является ли &lt;code&gt;rand()&lt;/code&gt; поточно-ориентированным.</target>
        </trans-unit>
        <trans-unit id="84efe53047a466556350dca48b226733f419c2a9" translate="yes" xml:space="preserve">
          <source>It is implementation-defined whether any &lt;a href=&quot;../language/objects#Alignment&quot;&gt;extended alignment&lt;/a&gt; is supported.</source>
          <target state="translated">Это определяется реализацией, поддерживается ли какое-либо &lt;a href=&quot;../language/objects#Alignment&quot;&gt;расширенное выравнивание&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f3b9b360dbecc9ae1960b9e40b3f44904781af81" translate="yes" xml:space="preserve">
          <source>It is implementation-defined whether dynamic initialization happens-before the first statement of the main function (for statics) or the initial function of the thread (for thread-locals), or deferred to happen after.</source>
          <target state="translated">Реализация определяется тем,происходит ли динамическая инициализация-перед первым оператором основной функции (для статики)или начальной функции потока (для потоков-локалов),или отложена на потом.</target>
        </trans-unit>
        <trans-unit id="61a3a1813d80165d2df5ab50673ad21ec5aecc5a" translate="yes" xml:space="preserve">
          <source>It is implementation-defined which scalar types satisfy this trait, but unsigned(until C++20) integer types that do not use padding bits are guaranteed to have unique object representations.</source>
          <target state="translated">Реализация определяет,какие скалярные типы удовлетворяют данному трейту,но беззнаковые (до C++20)целочисленные типы,не использующие подбитые биты,гарантированно имеют уникальные объектные представления.</target>
        </trans-unit>
        <trans-unit id="f452c9b19e8125eb753da2303a095249683e2189" translate="yes" xml:space="preserve">
          <source>It is important to remember this rule while ordering the header files of a translation unit. For more examples of the interplay between function overloads and function specializations, expand below:</source>
          <target state="translated">Важно помнить это правило при заказе заголовочных файлов модуля перевода.Для получения более подробных примеров взаимодействия между перегрузками функций и специализацией функций,развернитесь ниже:</target>
        </trans-unit>
        <trans-unit id="84f7f9e6e1a9d37badb5dd8311ca6a0bc6dbdb31" translate="yes" xml:space="preserve">
          <source>It is intended that &lt;code&gt;Copyable&amp;lt;T&amp;gt;&lt;/code&gt; also requires &lt;code&gt;std::&lt;a href=&quot;assignable&quot;&gt;Assignable&lt;/a&gt;&amp;lt;T&amp;amp;, const T&amp;gt;&lt;/code&gt; (assignment from const rvalue) and &lt;code&gt;std::&lt;a href=&quot;assignable&quot;&gt;Assignable&lt;/a&gt;&amp;lt;T&amp;amp;, T&amp;amp;&amp;gt;&lt;/code&gt; (assignment from non-const lvalue) to be satisfied.</source>
          <target state="translated">Предполагается, что &lt;code&gt;Copyable&amp;lt;T&amp;gt;&lt;/code&gt; также требует выполнения &lt;code&gt;std::&lt;a href=&quot;assignable&quot;&gt;Assignable&lt;/a&gt;&amp;lt;T&amp;amp;, const T&amp;gt;&lt;/code&gt; (назначение из const rvalue) и &lt;code&gt;std::&lt;a href=&quot;assignable&quot;&gt;Assignable&lt;/a&gt;&amp;lt;T&amp;amp;, T&amp;amp;&amp;gt;&lt;/code&gt; (назначение из неконстантного lvalue).</target>
        </trans-unit>
        <trans-unit id="e89c6edc67ab990f4dbf2f94411a54a2785ae48a" translate="yes" xml:space="preserve">
          <source>It is legal to pass a pointer to a &lt;code&gt;va_list&lt;/code&gt; object to another function and then use that object after the function returns.</source>
          <target state="translated">Разрешается передавать указатель на объект &lt;code&gt;va_list&lt;/code&gt; другой функции, а затем использовать этот объект после возврата из функции.</target>
        </trans-unit>
        <trans-unit id="600fa81257e98fe2222f530f6041ece9a9c792cf" translate="yes" xml:space="preserve">
          <source>It is not guaranteed that immediately after setting the write time, the value returned by (1) is the same as what was passed as the argument to (2) because the file system's time may be more granular than &lt;code&gt;file_time_type&lt;/code&gt;.</source>
          <target state="translated">Не гарантируется, что сразу после установки времени записи значение, возвращаемое (1), совпадает с тем, которое было передано в качестве аргумента (2), потому что время файловой системы может быть более &lt;code&gt;file_time_type&lt;/code&gt; чем file_time_type .</target>
        </trans-unit>
        <trans-unit id="19e7f91c42b80c040f054b6d4d2717f7558a91ea" translate="yes" xml:space="preserve">
          <source>It is not possible to change the precedence, grouping, or number of operands of operators.</source>
          <target state="translated">Невозможно изменить приоритет,группировку или количество операндов операторов.</target>
        </trans-unit>
        <trans-unit id="d6f058ae02644804095fa603da188cdda6b78a90" translate="yes" xml:space="preserve">
          <source>It is not possible to query the current output format.</source>
          <target state="translated">Невозможно запросить текущий формат вывода.</target>
        </trans-unit>
        <trans-unit id="ab4860699c3e4136650eba42ced4751e96f60a0f" translate="yes" xml:space="preserve">
          <source>It is not user-provided (meaning, it is implicitly-defined or defaulted);</source>
          <target state="translated">Она не предоставляется пользователем (имеется в виду,что она неявно определена или дефолт);</target>
        </trans-unit>
        <trans-unit id="97be44c3bf3295b1767f75794d7dfeb5ea6fcc99" translate="yes" xml:space="preserve">
          <source>It is only safe to invoke the destructor if all threads have been notified. It is not required that they have exited their respective wait functions: some threads may still be waiting to reacquire the associated lock, or may be waiting to be scheduled to run after reacquiring it.</source>
          <target state="translated">Вызов деструктора безопасен только в том случае,если все потоки были уведомлены.При этом не требуется,чтобы они покинули свои функции ожидания:некоторые нити могут все еще ждать повторного обращения к соответствующему замку,или могут ждать его запуска по расписанию после повторного обращения к нему.</target>
        </trans-unit>
        <trans-unit id="e70768e4115e7101bd5fd956648b5b4a1a7b7407" translate="yes" xml:space="preserve">
          <source>It is permitted to call &lt;code&gt;shared_from_this&lt;/code&gt; only on a previously shared object, i.e. on an object managed by &lt;code&gt;&lt;a href=&quot;../shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&lt;/code&gt; (in particular, &lt;code&gt;shared_from_this&lt;/code&gt; cannot be called during construction of &lt;code&gt;*this&lt;/code&gt;).</source>
          <target state="translated">Разрешается вызывать &lt;code&gt;shared_from_this&lt;/code&gt; только для ранее совместно используемого объекта, т. &lt;code&gt;shared_from_this&lt;/code&gt; Для объекта, управляемого &lt;code&gt;&lt;a href=&quot;../shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&lt;/code&gt; (в частности, shared_from_this нельзя вызвать во время создания &lt;code&gt;*this&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="e237c9465035935c40984d4ba69fc9854677f449" translate="yes" xml:space="preserve">
          <source>It is permitted to call &lt;code&gt;shared_from_this&lt;/code&gt; only on a previously shared object, i.e. on an object managed by &lt;code&gt;&lt;a href=&quot;shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt;. Otherwise the behavior is undefined(until C++17)&lt;code&gt;&lt;a href=&quot;bad_weak_ptr&quot;&gt;std::bad_weak_ptr&lt;/a&gt;&lt;/code&gt; is thrown (by the shared_ptr constructor from a default-constructed &lt;code&gt;weak_this&lt;/code&gt;)(since C++17).</source>
          <target state="translated">Разрешается вызывать &lt;code&gt;shared_from_this&lt;/code&gt; только для ранее общего объекта, то есть для объекта, управляемого &lt;code&gt;&lt;a href=&quot;shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt; . В противном случае поведение не определено (до C ++ 17), &lt;code&gt;&lt;a href=&quot;bad_weak_ptr&quot;&gt;std::bad_weak_ptr&lt;/a&gt;&lt;/code&gt; (с помощью конструктора shared_ptr, созданного по умолчанию &lt;code&gt;weak_this&lt;/code&gt; ) (начиная с C ++ 17).</target>
        </trans-unit>
        <trans-unit id="87374d898360b164d7d485ca958f9b4f6331b966" translate="yes" xml:space="preserve">
          <source>It is permitted to form references to references through type manipulations in templates or typedefs, in which case the</source>
          <target state="translated">Разрешается формировать ссылки на ссылки посредством манипуляций с типами в шаблонах или типовых файлах,и в этом случае</target>
        </trans-unit>
        <trans-unit id="c212dba4876364523e05a1fc0269ee84b6e501a5" translate="yes" xml:space="preserve">
          <source>It is possible to construct &lt;code&gt;std::gslice&lt;/code&gt; objects that select some indices more than once: if the above example used the strides &lt;code&gt;{1,1,1} &lt;/code&gt;, the indices would have been &lt;code&gt;{3, 4, 5, 4, 5, 6, ...} &lt;/code&gt;. Such gslices may only be used as arguments to the const version of &lt;code&gt;std::valarray::operator[]&lt;/code&gt;, otherwise the behavior is undefined.</source>
          <target state="translated">Можно &lt;code&gt;std::gslice&lt;/code&gt; объекты std :: gslice, которые выбирают несколько индексов более одного раза: если в приведенном выше примере используются шаги &lt;code&gt;{1,1,1} &lt;/code&gt; , индексы были бы &lt;code&gt;{3, 4, 5, 4, 5, 6, ...} &lt;/code&gt; . Такие gslices могут использоваться только в качестве аргументов для &lt;code&gt;std::valarray::operator[]&lt;/code&gt; версии std :: valarray :: operator [] , в противном случае поведение не определено.</target>
        </trans-unit>
        <trans-unit id="4ede96757c156e593ca1e3cea610558948eb5cc8" translate="yes" xml:space="preserve">
          <source>It is possible to execute &lt;code&gt;delete this;&lt;/code&gt;, if the program can guarantee that the object was allocated by &lt;code&gt;new&lt;/code&gt;, however, this renders every pointer to the deallocated object invalid, including the &lt;code&gt;this&lt;/code&gt; pointer itself: after &lt;code&gt;delete this;&lt;/code&gt; returns, such member function cannot refer to a member of a class (since this involves an implicit dereference of &lt;code&gt;this&lt;/code&gt;) and no other member function may be called. This is used, for example, in the member function of the control block of &lt;code&gt;&lt;a href=&quot;../memory/shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&lt;/code&gt; responsible for decrementing the reference count, when the last reference to the managed object goes out of scope.</source>
          <target state="translated">Можно выполнить &lt;code&gt;delete this;&lt;/code&gt; Если программа может гарантировать, что объект был выделен &lt;code&gt;new&lt;/code&gt; , это делает каждый указатель на освобожденный объект недействительным, включая сам указатель &lt;code&gt;this&lt;/code&gt; : после &lt;code&gt;delete this;&lt;/code&gt; возвращает, такая функция-член не может ссылаться на члена класса (поскольку это подразумевает неявную разыменование &lt;code&gt;this&lt;/code&gt; ), и никакая другая функция-член не может быть вызвана. Это используется, например, в функции-члене управляющего блока &lt;code&gt;&lt;a href=&quot;../memory/shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&lt;/code&gt; ответственного за уменьшение счетчика ссылок, когда последняя ссылка на управляемый объект выходит из области видимости.</target>
        </trans-unit>
        <trans-unit id="4f49e2aea7f63f794694b0764f8e62bb0888805b" translate="yes" xml:space="preserve">
          <source>It is safe, and in fact, preferable in generic code, to use deduction to forwarding reference, &lt;code&gt;for (auto&amp;amp;&amp;amp; var : sequence)&lt;/code&gt;.</source>
          <target state="translated">Безопасно и, на самом деле, предпочтительно в универсальном коде использовать вычет для пересылки ссылки &lt;code&gt;for (auto&amp;amp;&amp;amp; var : sequence)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6f58e92744c1e3c6d83adcd0474626686db527bd" translate="yes" xml:space="preserve">
          <source>It is said that a converting constructor specifies an implicit conversion from the types of its arguments (if any) to the type of its class. Note that non-explicit &lt;a href=&quot;cast_operator&quot;&gt;user-defined conversion function&lt;/a&gt; also specifies an implicit conversion.</source>
          <target state="translated">Говорят, что конвертирующий конструктор определяет неявное преобразование типов своих аргументов (если они есть) в тип своего класса. Обратите внимание, что неявная &lt;a href=&quot;cast_operator&quot;&gt;пользовательская функция преобразования&lt;/a&gt; также определяет неявное преобразование.</target>
        </trans-unit>
        <trans-unit id="edfaaadef05ca0b8cdce0f012fc27fee94079175" translate="yes" xml:space="preserve">
          <source>It is the programmer's responsibility to ensure that &lt;code&gt;std::string_view&lt;/code&gt; does not outlive the pointed-to character array:</source>
          <target state="translated">Программист обязан убедиться, что &lt;code&gt;std::string_view&lt;/code&gt; не переживает массив указанных символов:</target>
        </trans-unit>
        <trans-unit id="a4d949d7d8bd7c5ac1b3559c799fce0b606f5cea" translate="yes" xml:space="preserve">
          <source>It is the programmer's responsibility to ensure that the &lt;code&gt;&lt;a href=&quot;basic_regex&quot;&gt;std::basic_regex&lt;/a&gt;&lt;/code&gt; object passed to the iterator's constructor outlives the iterator. Because the iterator stores a &lt;code&gt;&lt;a href=&quot;regex_iterator&quot;&gt;std::regex_iterator&lt;/a&gt;&lt;/code&gt; which stores a pointer to the regex, incrementing the iterator after the regex was destroyed results in undefined behavior.</source>
          <target state="translated">Программист несет ответственность за то, &lt;code&gt;&lt;a href=&quot;basic_regex&quot;&gt;std::basic_regex&lt;/a&gt;&lt;/code&gt; объект std :: basic_regex, переданный в конструктор итератора, пережил итератор. Поскольку итератор хранит &lt;code&gt;&lt;a href=&quot;regex_iterator&quot;&gt;std::regex_iterator&lt;/a&gt;&lt;/code&gt; котором хранится указатель на регулярное выражение, приращение итератора после уничтожения регулярного выражения приводит к неопределенному поведению.</target>
        </trans-unit>
        <trans-unit id="5d0ef4a8a26d0c98d105421ede3ede0ed4125959" translate="yes" xml:space="preserve">
          <source>It is the programmer's responsibility to ensure that the &lt;code&gt;&lt;a href=&quot;basic_regex&quot;&gt;std::basic_regex&lt;/a&gt;&lt;/code&gt; object passed to the iterator's constructor outlives the iterator. Because the iterator stores a pointer to the regex, incrementing the iterator after the regex was destroyed accesses a dangling pointer.</source>
          <target state="translated">Программист несет ответственность за то, &lt;code&gt;&lt;a href=&quot;basic_regex&quot;&gt;std::basic_regex&lt;/a&gt;&lt;/code&gt; объект std :: basic_regex, переданный в конструктор итератора, пережил итератор. Поскольку итератор хранит указатель на регулярное выражение, приращение итератора после того, как регулярное выражение было уничтожено, обращается к висячему указателю.</target>
        </trans-unit>
        <trans-unit id="8ae84d20cf6f06aca28cb06cdba2bd625fad38b1" translate="yes" xml:space="preserve">
          <source>It is undefined behavior to reuse storage that is or was occupied by a const complete object of static, thread-local, or automatic storage duration because such objects may be stored in read-only memory.</source>
          <target state="translated">Повторное использование хранилища,занятого или занятого константным полным объектом статического,потокового или автоматического хранения,является неопределенным поведением,так как такие объекты могут храниться в памяти,доступной только для чтения.</target>
        </trans-unit>
        <trans-unit id="48d04478371a33f8869a2e04a1a90a78036dbfec" translate="yes" xml:space="preserve">
          <source>It is unspecified how the implementation makes these adjustments. This means that a compiler may call an implementation-specific search function, in which case a user-defined specialization of &lt;code&gt;regex_search&lt;/code&gt; will not be called.</source>
          <target state="translated">Не указано, как реализация вносит эти коррективы. Это означает, что компилятор может вызвать специфическую для реализации функцию поиска, и в этом случае пользовательская специализация &lt;code&gt;regex_search&lt;/code&gt; не будет вызвана.</target>
        </trans-unit>
        <trans-unit id="f7589f89a7b5d81e1f9bfdc1b0ceb532d0fc8435" translate="yes" xml:space="preserve">
          <source>It is unspecified when the past-the-end iterator is invalidated.</source>
          <target state="translated">Он не указан,когда итератор прошлых лет признан недействительным.</target>
        </trans-unit>
        <trans-unit id="326b1cd1f8d02d7684396bd886d2e1c17251cc10" translate="yes" xml:space="preserve">
          <source>It is unspecified whether &lt;code&gt;&amp;lt;utility&amp;gt;&lt;/code&gt; is actually included when the standard library functions perform the swap, so the user-provided &lt;code&gt;swap()&lt;/code&gt; should not expect it to be included.</source>
          <target state="translated">Не определено, действительно ли включена &lt;code&gt;&amp;lt;utility&amp;gt;&lt;/code&gt; , когда стандартные функции библиотеки выполняют обмен, поэтому предоставляемый пользователем метод &lt;code&gt;swap()&lt;/code&gt; не должен ожидать его включения.</target>
        </trans-unit>
        <trans-unit id="c08baf030a373796ca075a1cddf067e089df15bb" translate="yes" xml:space="preserve">
          <source>It is unspecified whether library versions of &lt;code&gt;operator new&lt;/code&gt; make any calls to &lt;code&gt;&lt;a href=&quot;../c/malloc&quot;&gt;std::malloc&lt;/a&gt;&lt;/code&gt;or &lt;code&gt;&lt;a href=&quot;../c/aligned_alloc&quot;&gt;std::aligned_alloc&lt;/a&gt;&lt;/code&gt;(since C++17).</source>
          <target state="translated">Не определено, делают ли библиотечные версии &lt;code&gt;operator new&lt;/code&gt; какие-либо вызовы &lt;code&gt;&lt;a href=&quot;../c/malloc&quot;&gt;std::malloc&lt;/a&gt;&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;../c/aligned_alloc&quot;&gt;std::aligned_alloc&lt;/a&gt;&lt;/code&gt; (начиная с C ++ 17).</target>
        </trans-unit>
        <trans-unit id="a4ad188c2e57b182fa5e3f165eb2ba5d04005026" translate="yes" xml:space="preserve">
          <source>It is unspecified whether the destructor for the object referred to by &lt;code&gt;typeid&lt;/code&gt; is executed at the end of the program.</source>
          <target state="translated">Не определено, выполняется ли деструктор для объекта, на который ссылается &lt;code&gt;typeid&lt;/code&gt; , в конце программы.</target>
        </trans-unit>
        <trans-unit id="ba80c2d544e0bc888b885567b5eaf901bde4dfd1" translate="yes" xml:space="preserve">
          <source>It is unspecified whether virtual base class subobjects that are accessible through more than one path in the inheritance lattice, are assigned more than once by the implicitly-defined copy assignment operator (same applies to &lt;a href=&quot;move_operator&quot;&gt;move assignment&lt;/a&gt;).</source>
          <target state="translated">Не определено, присваиваются ли субобъекты виртуального базового класса, которые доступны по нескольким путям в решетке наследования, более одного раза с помощью неявно определенного оператора назначения копирования (то же самое относится к &lt;a href=&quot;move_operator&quot;&gt;назначению перемещения&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="95593cbb778289249ae714a71b756ce2cf19a0ff" translate="yes" xml:space="preserve">
          <source>It is unspecified whether virtual base class subobjects that are accessible through more than one path in the inheritance lattice, are assigned more than once by the implicitly-defined move assignment operator (same applies to &lt;a href=&quot;as_operator&quot;&gt;copy assignment&lt;/a&gt;).</source>
          <target state="translated">Не определено, назначаются ли субобъекты виртуального базового класса, которые доступны по нескольким путям в решетке наследования, более одного раза с помощью неявно определенного оператора назначения перемещения (то же самое относится и к &lt;a href=&quot;as_operator&quot;&gt;назначению копирования&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="923b1d52d8265df676c6882541dea0ee1c7e5835" translate="yes" xml:space="preserve">
          <source>It is unspecified whether virtual base subobjects are compared more than once.</source>
          <target state="translated">Не определено,сравнивались ли виртуальные базовые подобъекты более одного раза.</target>
        </trans-unit>
        <trans-unit id="b0253dc9c61d1b681c7e56bf36a208e187bd7459" translate="yes" xml:space="preserve">
          <source>It is up to the program to ensure that the alignment assumption actually holds. A call to &lt;code&gt;assume_aligned&lt;/code&gt; does not cause the compiler to verify or enforce this.</source>
          <target state="translated">Программа должна гарантировать, что предположение о выравнивании действительно выполняется. Вызов &lt;code&gt;assume_aligned&lt;/code&gt; не заставляет компилятор проверить или применить это.</target>
        </trans-unit>
        <trans-unit id="c454768f7ee08c8dd39602a9d383338c66d1c6a9" translate="yes" xml:space="preserve">
          <source>It is used to represent offsets from stream positions (values of type &lt;code&gt;&lt;a href=&quot;fpos&quot;&gt;std::fpos&lt;/a&gt;&lt;/code&gt;). A &lt;code&gt;std::streamoff&lt;/code&gt; value of &lt;code&gt;-1&lt;/code&gt; is also used to represent error conditions by some of the I/O library functions.</source>
          <target state="translated">Он используется для представления смещений от позиций потока (значения типа &lt;code&gt;&lt;a href=&quot;fpos&quot;&gt;std::fpos&lt;/a&gt;&lt;/code&gt; ). &lt;code&gt;std::streamoff&lt;/code&gt; значение &lt;code&gt;-1&lt;/code&gt; также используется для представления ошибочных условий некоторые из I / O функции библиотеки.</target>
        </trans-unit>
        <trans-unit id="dc825523729ab0100d6865928993fc1eba1d20c0" translate="yes" xml:space="preserve">
          <source>It may be thrown by the member functions of &lt;code&gt;&lt;a href=&quot;../../utility/bitset&quot;&gt;std::bitset&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../../string/basic_string&quot;&gt;std::basic_string&lt;/a&gt;&lt;/code&gt;, by &lt;code&gt;&lt;a href=&quot;../../string/basic_string/stol&quot;&gt;std::stoi&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../../string/basic_string/stof&quot;&gt;std::stod&lt;/a&gt;&lt;/code&gt; families of functions, and by the bounds-checked member access functions (e.g. &lt;code&gt;&lt;a href=&quot;../../container/vector/at&quot;&gt;std::vector::at&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../../container/map/at&quot;&gt;std::map::at&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">Это может быть выброшены функциями членов &lt;code&gt;&lt;a href=&quot;../../utility/bitset&quot;&gt;std::bitset&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;../../string/basic_string&quot;&gt;std::basic_string&lt;/a&gt;&lt;/code&gt; , по &lt;code&gt;&lt;a href=&quot;../../string/basic_string/stol&quot;&gt;std::stoi&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;../../string/basic_string/stof&quot;&gt;std::stod&lt;/a&gt;&lt;/code&gt; семействам функций, а также функции доступа члена с контролем границ (например , &lt;code&gt;&lt;a href=&quot;../../container/vector/at&quot;&gt;std::vector::at&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;../../container/map/at&quot;&gt;std::map::at&lt;/a&gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="e6c4c0849336c6395a555e7802361736a0a0c377" translate="yes" xml:space="preserve">
          <source>It may not be monotonic: on most systems, the system time can be adjusted at any moment. It is the only C++ clock that has the ability to map its time points to C-style time, and, therefore, to be displayed(until C++20).</source>
          <target state="translated">Он может быть не монотонным:на большинстве систем время системы можно настроить в любой момент.Это единственные часы C++,которые имеют возможность сопоставлять свое время с временем в стиле C и,следовательно,отображаться (до C++20).</target>
        </trans-unit>
        <trans-unit id="4ff81608e3ae9cd2b8502e188922f1126aed8496" translate="yes" xml:space="preserve">
          <source>It must have a &lt;code&gt;constexpr&lt;/code&gt; constructor that takes some implementation-defined literal type.</source>
          <target state="translated">Он должен иметь конструктор &lt;code&gt;constexpr&lt;/code&gt; , который принимает определенный литеральный тип реализации.</target>
        </trans-unit>
        <trans-unit id="a342065b388bf8640367f4a9dd97692d21114f7f" translate="yes" xml:space="preserve">
          <source>It owns the allocated memory and frees it on destruction, even if &lt;code&gt;deallocate&lt;/code&gt; has not been called for some of the allocated blocks.</source>
          <target state="translated">Он владеет выделенной памятью и освобождает ее при уничтожении, даже если для некоторых из выделенных блоков не было &lt;code&gt;deallocate&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="747d8a8f672f5ac61ae339d4eb41b3ce9338913c" translate="yes" xml:space="preserve">
          <source>It provides a way to seed a large number of random number engines or to seed a generator that requires a lot of entropy, given a small seed or a poorly distributed initial seed sequence.</source>
          <target state="translated">Он обеспечивает способ посеять большое количество двигателей с случайными числами или посеять генератор,требующий много энтропии,учитывая небольшое количество семян или плохо распределенную начальную последовательность семян.</target>
        </trans-unit>
        <trans-unit id="85a990d0ad9f04a8b78c0432369377fa53e60519" translate="yes" xml:space="preserve">
          <source>It provides the guarantee that all output made to the same final destination buffer (std::cout in the examples above) will be free of data races and will not be interleaved or garbled in any way, as long as every write to the that final destination buffer is made through (possibly different) instances of &lt;code&gt;std::basic_osyncstream&lt;/code&gt;.</source>
          <target state="translated">Это обеспечивает гарантию того, что все выходные данные, сделанные в один и тот же конечный буфер назначения (std :: cout в приведенных выше примерах), не будут содержать скачки данных и не будут чередоваться или искажаться каким-либо образом, до тех пор, пока каждая запись в этот финал целевой буфер &lt;code&gt;std::basic_osyncstream&lt;/code&gt; через (возможно, разные) экземпляры std :: basic_osyncstream .</target>
        </trans-unit>
        <trans-unit id="0cdae659e4031c70f43c202403b0e9b266332015" translate="yes" xml:space="preserve">
          <source>It returns the iterator itself, which makes it possible to use code such as &lt;code&gt;*iter = value&lt;/code&gt; to output (insert) the value into the underlying container.</source>
          <target state="translated">Он возвращает сам итератор, что позволяет использовать код, такой как &lt;code&gt;*iter = value&lt;/code&gt; для вывода (вставки) значения в базовый контейнер.</target>
        </trans-unit>
        <trans-unit id="4e71ff091467aa53e4a20b3c8e2eb730c31146dd" translate="yes" xml:space="preserve">
          <source>It returns the iterator itself, which makes it possible to use code such as &lt;code&gt;*iter = value&lt;/code&gt; to output (insert) the value into the underlying stream.</source>
          <target state="translated">Он возвращает сам итератор, что позволяет использовать код, такой как &lt;code&gt;*iter = value&lt;/code&gt; для вывода (вставки) значения в базовый поток.</target>
        </trans-unit>
        <trans-unit id="3bcdb39cfdb013b01f34aa6003e5bc508f218b9f" translate="yes" xml:space="preserve">
          <source>It's unspecified if these functions zero out the fields in &lt;code&gt;*t&lt;/code&gt; that they do not set directly: portable programs should initialize every field to zero before calling &lt;code&gt;get()&lt;/code&gt;.</source>
          <target state="translated">Не определено, если эти функции обнуляют поля в &lt;code&gt;*t&lt;/code&gt; , которые они не устанавливают напрямую: переносимые программы должны инициализировать каждое поле до нуля перед вызовом &lt;code&gt;get()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="091b8d78ec3176b66348479ab0a7eba113756aa7" translate="yes" xml:space="preserve">
          <source>Iter</source>
          <target state="translated">Iter</target>
        </trans-unit>
        <trans-unit id="eaad30c6c7239ee4988afc79198142d6357df99b" translate="yes" xml:space="preserve">
          <source>Iteration statements</source>
          <target state="translated">итерационные заявления</target>
        </trans-unit>
        <trans-unit id="3e6a261991d848c9d7f1a6f775a1646474ac0d8e" translate="yes" xml:space="preserve">
          <source>Iteration statements repeatedly execute some code.</source>
          <target state="translated">Итерационные заявления многократно исполняют некоторый код.</target>
        </trans-unit>
        <trans-unit id="bae8809b2429231a50c28ba87cecc038aac88855" translate="yes" xml:space="preserve">
          <source>Iterator</source>
          <target state="translated">Iterator</target>
        </trans-unit>
        <trans-unit id="4dee12b442c04cdb4820f91dbc5c57a6bfcea0f2" translate="yes" xml:space="preserve">
          <source>Iterator adaptors</source>
          <target state="translated">адаптеры итератора</target>
        </trans-unit>
        <trans-unit id="4d118461fd53be5789511318e9a62fde653cd961" translate="yes" xml:space="preserve">
          <source>Iterator associated types</source>
          <target state="translated">Типы,связанные с итератором</target>
        </trans-unit>
        <trans-unit id="7dfb7f0ff3c8f35daf7e4c6ffdf06bc0e90e799b" translate="yes" xml:space="preserve">
          <source>Iterator categories</source>
          <target state="translated">категории итераторов</target>
        </trans-unit>
        <trans-unit id="4f31e7d075beed31a4d019c7620a3efff3cce0c6" translate="yes" xml:space="preserve">
          <source>Iterator category</source>
          <target state="translated">категория итераторов</target>
        </trans-unit>
        <trans-unit id="45c0e163119730d64e4e88a9e88e486c24564923" translate="yes" xml:space="preserve">
          <source>Iterator category tags carry information that can be used to select the most efficient algorithms for the specific requirement set that is implied by the category.</source>
          <target state="translated">Метки категории итератора содержат информацию,которая может быть использована для выбора наиболее эффективных алгоритмов для конкретного набора требований,которые подразумеваются категорией.</target>
        </trans-unit>
        <trans-unit id="1f22a4cac482679567538d501753a8d2f46eb0e0" translate="yes" xml:space="preserve">
          <source>Iterator concepts</source>
          <target state="translated">концепции итераторов</target>
        </trans-unit>
        <trans-unit id="740d1be15d7c47c82fc9496173a7a69a59de33d0" translate="yes" xml:space="preserve">
          <source>Iterator customization points</source>
          <target state="translated">точки настройки итератора</target>
        </trans-unit>
        <trans-unit id="e2f44595e956bf36ac4508978a8443a14cf70b6e" translate="yes" xml:space="preserve">
          <source>Iterator following the last removed element. If the iterator &lt;code&gt;pos&lt;/code&gt; refers to the last element, the &lt;code&gt;&lt;a href=&quot;end&quot;&gt;end()&lt;/a&gt;&lt;/code&gt; iterator is returned.</source>
          <target state="translated">Итератор, следующий за последним удаленным элементом. Если итератор &lt;code&gt;pos&lt;/code&gt; ссылается на последний элемент, возвращается итератор &lt;code&gt;&lt;a href=&quot;end&quot;&gt;end()&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0451248583f78c974b012649cf5f233b3518219f" translate="yes" xml:space="preserve">
          <source>Iterator in the destination range, pointing at the last element moved.</source>
          <target state="translated">Итератор в диапазоне назначения,указывающий на последний сдвинутый элемент.</target>
        </trans-unit>
        <trans-unit id="40bd84a12b0a1ba291337eb5470a260a83e5f5e0" translate="yes" xml:space="preserve">
          <source>Iterator in the destination range, pointing past the last element copied if &lt;code&gt;count&amp;gt;0&lt;/code&gt; or &lt;code&gt;result&lt;/code&gt; otherwise.</source>
          <target state="translated">Итератор в целевом диапазоне, указывающий за последним скопированным элементом, если &lt;code&gt;count&amp;gt;0&lt;/code&gt; или &lt;code&gt;result&lt;/code&gt; иначе.</target>
        </trans-unit>
        <trans-unit id="ca76fdc86a85ddcf65acd3db20c917b98cafb8cc" translate="yes" xml:space="preserve">
          <source>Iterator invalidation</source>
          <target state="translated">признание недействительности итератора</target>
        </trans-unit>
        <trans-unit id="281878789a9bcc6f2d63b03ac4ff75d8b3e62807" translate="yes" xml:space="preserve">
          <source>Iterator library</source>
          <target state="translated">библиотека итераторов</target>
        </trans-unit>
        <trans-unit id="03896d2a57195b9fd730686c9c0802a354747640" translate="yes" xml:space="preserve">
          <source>Iterator one past the last element assigned if &lt;code&gt;count &amp;gt; 0&lt;/code&gt;, &lt;code&gt;first&lt;/code&gt; otherwise.</source>
          <target state="translated">Итератор один за последним назначенным элементом, если &lt;code&gt;count &amp;gt; 0&lt;/code&gt; , &lt;code&gt;first&lt;/code&gt; иначе.</target>
        </trans-unit>
        <trans-unit id="daf74fe0d4457d50bd01e94a09fc1b13a7e9ff50" translate="yes" xml:space="preserve">
          <source>Iterator one past the last element assigned if &lt;code&gt;count&amp;gt;0&lt;/code&gt;, &lt;code&gt;first&lt;/code&gt; otherwise.</source>
          <target state="translated">Итератор один за последним назначенным элементом, если &lt;code&gt;count&amp;gt;0&lt;/code&gt; , &lt;code&gt;first&lt;/code&gt; иначе.</target>
        </trans-unit>
        <trans-unit id="2663ac3786b007e1d7f5bd8a7c0213e70730b1d7" translate="yes" xml:space="preserve">
          <source>Iterator operations</source>
          <target state="translated">итераторные операции</target>
        </trans-unit>
        <trans-unit id="f4dd65c96326a21c8c14e8530698df94d1156bd2" translate="yes" xml:space="preserve">
          <source>Iterator operations (e.g. incrementing an iterator) read, but do not modify the underlying container, and may be executed concurrently with operations on other iterators on the same container, with the const member functions, or reads from the elements. Container operations that invalidate any iterators modify the container and cannot be executed concurrently with any operations on existing iterators even if those iterators are not invalidated.</source>
          <target state="translated">Операции итератора (например,инкремент итератора)считываются,но не изменяют лежащий в основе контейнера,и могут выполняться одновременно с операциями над другими итераторами на том же контейнере,с функциями члена const,или считываются с элементов.Контейнерные операции,которые делают недействительными любые итераторы,изменяют контейнер и не могут выполняться одновременно с любыми операциями над существующими итераторами,даже если эти итераторы не являются недействительными.</target>
        </trans-unit>
        <trans-unit id="d40f4ce641e0ed75eeba005dc0c9d3144fe2cd68" translate="yes" xml:space="preserve">
          <source>Iterator past the end of the constructed range.</source>
          <target state="translated">Итератор мимо конца построенного диапазона.</target>
        </trans-unit>
        <trans-unit id="13fa518a2303933b7f035ca34918a1466f897682" translate="yes" xml:space="preserve">
          <source>Iterator pointing one past the last character in &lt;code&gt;[beg, end)&lt;/code&gt; that was parsed successfully.</source>
          <target state="translated">Итератор, указывающий один за последним символом в &lt;code&gt;[beg, end)&lt;/code&gt; который был успешно проанализирован.</target>
        </trans-unit>
        <trans-unit id="8307d2d53c29a25c0e984348242a9471e3ee81a1" translate="yes" xml:space="preserve">
          <source>Iterator pointing one past the last character in &lt;code&gt;[beg, end)&lt;/code&gt; that was recognized as a part of a valid date.</source>
          <target state="translated">Итератор, указывающий один за последним символом в &lt;code&gt;[beg, end)&lt;/code&gt; который был признан частью действительной даты.</target>
        </trans-unit>
        <trans-unit id="f64d4fa39c12455a17caddb09b8107c7a4df881a" translate="yes" xml:space="preserve">
          <source>Iterator pointing one past the last character in &lt;code&gt;[beg, end)&lt;/code&gt; that was recognized as a part of a valid month name.</source>
          <target state="translated">Итератор, указывающий один за последним символом в &lt;code&gt;[beg, end)&lt;/code&gt; который был распознан как часть действительного названия месяца.</target>
        </trans-unit>
        <trans-unit id="31e9b344102f3edc337a21ee322aadf820b9757e" translate="yes" xml:space="preserve">
          <source>Iterator pointing one past the last character in &lt;code&gt;[beg, end)&lt;/code&gt; that was recognized as a part of a valid weekname.</source>
          <target state="translated">Итератор, указывающий один за последним символом в &lt;code&gt;[beg, end)&lt;/code&gt; который был распознан как часть действительного имени недели.</target>
        </trans-unit>
        <trans-unit id="31207a4529bcf9380d04c9069cc1655551460207" translate="yes" xml:space="preserve">
          <source>Iterator pointing one past the last character in &lt;code&gt;[beg, end)&lt;/code&gt; that was recognized as a part of a valid year.</source>
          <target state="translated">Итератор, указывающий на один символ после последнего символа в &lt;code&gt;[beg, end)&lt;/code&gt; который был признан частью действительного года.</target>
        </trans-unit>
        <trans-unit id="7f09da5861ec2d1af9b0e94d0a6f97c745163842" translate="yes" xml:space="preserve">
          <source>Iterator pointing one past the last character that was produced .</source>
          <target state="translated">Итератор,указывающий на последний созданный персонаж.</target>
        </trans-unit>
        <trans-unit id="2cbfd446fa55ac919f1565a7433ab297897ff7cd" translate="yes" xml:space="preserve">
          <source>Iterator pointing to the emplaced element.</source>
          <target state="translated">Итератор,указывающий на установленный элемент.</target>
        </trans-unit>
        <trans-unit id="3f31d65a0a3b3c0a3916fdb12c528f4639b09cbb" translate="yes" xml:space="preserve">
          <source>Iterator pointing to the first element that is</source>
          <target state="translated">Итератор,указывающий на первый элемент,который является</target>
        </trans-unit>
        <trans-unit id="be0840eb05b1b352b3e742ca7bea27adaa5d7b17" translate="yes" xml:space="preserve">
          <source>Iterator pointing to the first element that is not</source>
          <target state="translated">Итератор,указывающий на первый элемент,который не является</target>
        </trans-unit>
        <trans-unit id="e185fa2c4bb3e71229767b9d27a937494c54ba69" translate="yes" xml:space="preserve">
          <source>Iterator primitives</source>
          <target state="translated">итераторские примитивы</target>
        </trans-unit>
        <trans-unit id="10484316b5b2a8004d6321237a6c2d261f03e5f9" translate="yes" xml:space="preserve">
          <source>Iterator tags</source>
          <target state="translated">метки итератора</target>
        </trans-unit>
        <trans-unit id="ae607ca99d952a6e9f09c84027726aaa7bfec65b" translate="yes" xml:space="preserve">
          <source>Iterator to an element with key equivalent to &lt;code&gt;key&lt;/code&gt;. If no such element is found, past-the-end (see &lt;code&gt;&lt;a href=&quot;end&quot;&gt;end()&lt;/a&gt;&lt;/code&gt;) iterator is returned.</source>
          <target state="translated">Итератор элемента с ключом, эквивалентным &lt;code&gt;key&lt;/code&gt; . Если такой элемент не найден, возвращается итератор конца-конца (см. &lt;code&gt;&lt;a href=&quot;end&quot;&gt;end()&lt;/a&gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="9278ea56b5788d570f426ec7cbcb9a565e893cd1" translate="yes" xml:space="preserve">
          <source>Iterator to one past the last element of &lt;code&gt;a&lt;/code&gt;</source>
          <target state="translated">Итератор одному мимо последнего элемента &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b813a67f31fb479727b79b93d1bb1438b02ec92e" translate="yes" xml:space="preserve">
          <source>Iterator to one past the last value in the numeric array.</source>
          <target state="translated">Итератор к одному последнему значению в числовом массиве.</target>
        </trans-unit>
        <trans-unit id="b07ec936a0496c6833779c2921debff842152dd7" translate="yes" xml:space="preserve">
          <source>Iterator to the beginning of last occurrence of the sequence &lt;code&gt;[s_first, s_last)&lt;/code&gt; in range &lt;code&gt;[first, last)&lt;/code&gt;.</source>
          <target state="translated">Итератор до начала последнего появления последовательности &lt;code&gt;[s_first, s_last)&lt;/code&gt; в диапазоне &lt;code&gt;[first, last)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cea2fc59b7d3bb9197c3cb893d4095461e65324e" translate="yes" xml:space="preserve">
          <source>Iterator to the beginning of the found sequence in the range &lt;code&gt;[first, last)&lt;/code&gt;. If no such sequence is found, &lt;code&gt;last&lt;/code&gt; is returned.</source>
          <target state="translated">Итератор для начала найденной последовательности в диапазоне &lt;code&gt;[first, last)&lt;/code&gt; . Если такая последовательность не найдена, возвращается &lt;code&gt;last&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b99865a2f5ee2de11db467c05b05ecda3a38125e" translate="yes" xml:space="preserve">
          <source>Iterator to the element before the first element.</source>
          <target state="translated">Итератор к элементу перед первым элементом.</target>
        </trans-unit>
        <trans-unit id="aacd4e93e79a35d8d4d88a56fccd361ca76b515c" translate="yes" xml:space="preserve">
          <source>Iterator to the element following the last element.</source>
          <target state="translated">Итератор к элементу,следующему за последним элементом.</target>
        </trans-unit>
        <trans-unit id="d47c96b870ac902b9cfccfbc43f02d3063565e47" translate="yes" xml:space="preserve">
          <source>Iterator to the element past the last element copied.</source>
          <target state="translated">Итератор к последнему скопированному элементу.</target>
        </trans-unit>
        <trans-unit id="96509680368807f6fc1a0194dd4883b178732836" translate="yes" xml:space="preserve">
          <source>Iterator to the element past the last element exchanged in the range beginning with &lt;code&gt;first2&lt;/code&gt;.</source>
          <target state="translated">Итератор для элемента после последнего обмененного элемента в диапазоне, начинающемся с &lt;code&gt;first2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7a39ffa9063e11b7b654f129a912184da2ac6267" translate="yes" xml:space="preserve">
          <source>Iterator to the element past the last element moved.</source>
          <target state="translated">Итератор к элементу,мимо которого переместился последний элемент.</target>
        </trans-unit>
        <trans-unit id="1b5d7dd5569e766929089fcefe6c58bc9d731aa5" translate="yes" xml:space="preserve">
          <source>Iterator to the element past the last element written.</source>
          <target state="translated">Итератор к последнему написанному элементу.</target>
        </trans-unit>
        <trans-unit id="6bea32d087ab585bed1f7fe96375cf86af1211fa" translate="yes" xml:space="preserve">
          <source>Iterator to the element past the last sub-match.</source>
          <target state="translated">Итератор к элементу,прошедшему после последнего субматча.</target>
        </trans-unit>
        <trans-unit id="60a6218c749d504f60e9f3fa5bf31fa53f0671ac" translate="yes" xml:space="preserve">
          <source>Iterator to the first element in the range &lt;code&gt;[first, last)&lt;/code&gt; that is equal to an element from the range &lt;code&gt;[s_first; s_last)&lt;/code&gt;. If no such element is found, &lt;code&gt;last&lt;/code&gt; is returned.</source>
          <target state="translated">Итератор первого элемента в диапазоне &lt;code&gt;[first, last)&lt;/code&gt; который равен элементу из диапазона &lt;code&gt;[s_first; s_last)&lt;/code&gt; . Если такой элемент не найден, возвращается &lt;code&gt;last&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="744169b8a1b971b02107d9fd30c4e5ed51e12ef8" translate="yes" xml:space="preserve">
          <source>Iterator to the first element of &lt;code&gt;a&lt;/code&gt;</source>
          <target state="translated">Итератора к первому элементу &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e5fdfe83ec17cb438ffef8507e749f160d782415" translate="yes" xml:space="preserve">
          <source>Iterator to the first element of the second group.</source>
          <target state="translated">Итератор к первому элементу второй группы.</target>
        </trans-unit>
        <trans-unit id="1cbe4199bf321f6884c70afda2be99aff476ac84" translate="yes" xml:space="preserve">
          <source>Iterator to the first element satisfying the condition or &lt;code&gt;last&lt;/code&gt; if no such element is found.</source>
          <target state="translated">Итератор первого элемента, удовлетворяющего условию, или &lt;code&gt;last&lt;/code&gt; если такой элемент не найден.</target>
        </trans-unit>
        <trans-unit id="d4b75fadcd5e3ebde98aa445d8daad03877fd6a8" translate="yes" xml:space="preserve">
          <source>Iterator to the first element.</source>
          <target state="translated">Итератор к первому элементу.</target>
        </trans-unit>
        <trans-unit id="55aa966d43052a99cbd2f2b66a9a360393c342eb" translate="yes" xml:space="preserve">
          <source>Iterator to the first sub-match.</source>
          <target state="translated">Итератор первого субматча.</target>
        </trans-unit>
        <trans-unit id="5580fefb10d0046c754d643bd5733ccca8b1345e" translate="yes" xml:space="preserve">
          <source>Iterator to the first value in the numeric array.</source>
          <target state="translated">Итератор к первому значению в числовом массиве.</target>
        </trans-unit>
        <trans-unit id="ea592c537962f37901180bcbeecea954bf89d9fa" translate="yes" xml:space="preserve">
          <source>Iterator to the greatest element in the range &lt;code&gt;[first, last)&lt;/code&gt;. If several elements in the range are equivalent to the greatest element, returns the iterator to the first such element. Returns &lt;code&gt;last&lt;/code&gt; if the range is empty.</source>
          <target state="translated">Итератор для наибольшего элемента в диапазоне &lt;code&gt;[first, last)&lt;/code&gt; . Если несколько элементов в диапазоне эквивалентны наибольшему элементу, возвращается итератор к первому такому элементу. Возвращает &lt;code&gt;last&lt;/code&gt; если диапазон пуст.</target>
        </trans-unit>
        <trans-unit id="cab09d343a65548dadf0705016f36b2bc1aec5ff" translate="yes" xml:space="preserve">
          <source>Iterator to the smallest element in the range &lt;code&gt;[first, last)&lt;/code&gt;. If several elements in the range are equivalent to the smallest element, returns the iterator to the first such element. Returns &lt;code&gt;last&lt;/code&gt; if the range is empty.</source>
          <target state="translated">Итератор для наименьшего элемента в диапазоне &lt;code&gt;[first, last)&lt;/code&gt; . Если несколько элементов в диапазоне эквивалентны наименьшему элементу, возвращается итератор к первому такому элементу. Возвращает &lt;code&gt;last&lt;/code&gt; если диапазон пуст.</target>
        </trans-unit>
        <trans-unit id="909a5f0dfd8c3a4ef79cd1458e2b5fb136ad7fae" translate="yes" xml:space="preserve">
          <source>Iterators</source>
          <target state="translated">Iterators</target>
        </trans-unit>
        <trans-unit id="162032b2b677de764fe8e5f27091a7c4e6a44150" translate="yes" xml:space="preserve">
          <source>Iterators and references to the erased element are invalidated. If the element is the last element in the container, the past-the-end iterator is also invalidated. Other references and iterators are not affected.</source>
          <target state="translated">Итераторы и ссылки на стертый элемент недействительны.Если элемент является последним элементом в контейнере,то итератор в прошлом также аннулируется.Другие ссылки и итераторы не затрагиваются.</target>
        </trans-unit>
        <trans-unit id="e582a97f0f7104a2e13358f17facd4235fcb6d40" translate="yes" xml:space="preserve">
          <source>Iterators and references to the erased element are invalidated. It is unspecified whether the past-the-end iterator is invalidated if the element is the last element in the container. Other references and iterators are not affected.</source>
          <target state="translated">Итераторы и ссылки на стертый элемент недействительны.Не определено,будет ли итератор прошлых итераторов признан недействительным,если элемент является последним в контейнере.Другие ссылки и итераторы не затрагиваются.</target>
        </trans-unit>
        <trans-unit id="4c5b6d9e93629888dbe6bf92a0305e9d1ac53f56" translate="yes" xml:space="preserve">
          <source>Iterators and references to the erased element are invalidated. It is unspecified whether the past-the-end iterator is invalidated. Other references and iterators are not affected.</source>
          <target state="translated">Итераторы и ссылки на стертый элемент недействительны.Не определено,является ли итератор прошлых лет недействительным.Другие ссылки и итераторы не затрагиваются.</target>
        </trans-unit>
        <trans-unit id="420aea18856c45985924dcd36529cee071e75fd3" translate="yes" xml:space="preserve">
          <source>Iterators and references to the erased element are invalidated. The past-the-end iterator is also invalidated. Other references and iterators are not affected.</source>
          <target state="translated">Итераторы и ссылки на стертый элемент недействительны.Прошлый итератор также недействителен.Другие ссылки и итераторы не затрагиваются.</target>
        </trans-unit>
        <trans-unit id="f88e8afffd84ac565f746527f36f9909c4f45150" translate="yes" xml:space="preserve">
          <source>Iterators are not dereferenceable if.</source>
          <target state="translated">Итераторы не могут быть использованы,если...</target>
        </trans-unit>
        <trans-unit id="05eeb7b671baac73a3dc80180a6545670e55373f" translate="yes" xml:space="preserve">
          <source>Iterators for which the behavior of the expression &lt;code&gt;*i&lt;/code&gt; is defined are called</source>
          <target state="translated">Итераторы, для которых определяется поведение выражения &lt;code&gt;*i&lt;/code&gt; , называются</target>
        </trans-unit>
        <trans-unit id="6d7e7b94342bc88f5dc26254b6ed839ec8bfb385" translate="yes" xml:space="preserve">
          <source>Iterators library</source>
          <target state="translated">библиотека итераторов</target>
        </trans-unit>
        <trans-unit id="7987698c6d69adbd970dfb91d269e601291f3c2e" translate="yes" xml:space="preserve">
          <source>Iterators that fall into one of the above categories and also meet the requirements of &lt;a href=&quot;named_req/contiguousiterator&quot;&gt;LegacyContiguousIterator&lt;/a&gt; are called contiguous iterators.</source>
          <target state="translated">Итераторы, которые попадают в одну из вышеуказанных категорий, а также отвечают требованиям &lt;a href=&quot;named_req/contiguousiterator&quot;&gt;LegacyContiguousIterator&lt;/a&gt; , называются непрерывными итераторами.</target>
        </trans-unit>
        <trans-unit id="c0510377d9129680624a5c7430c75a54b51eeddb" translate="yes" xml:space="preserve">
          <source>Iterators that fall into one of the above categories and also meet the requirements of &lt;a href=&quot;named_req/outputiterator&quot;&gt;LegacyOutputIterator&lt;/a&gt; are called mutable iterators.</source>
          <target state="translated">Итераторы, которые попадают в одну из вышеуказанных категорий, а также отвечают требованиям &lt;a href=&quot;named_req/outputiterator&quot;&gt;LegacyOutputIterator&lt;/a&gt; , называются изменяемыми итераторами.</target>
        </trans-unit>
        <trans-unit id="58668e7669fd564d99db5d581fcdb6a5618440b5" translate="yes" xml:space="preserve">
          <source>J</source>
          <target state="translated">J</target>
        </trans-unit>
        <trans-unit id="273fff5103ab0399a739b1cec1bc3d252efc223f" translate="yes" xml:space="preserve">
          <source>JAPANESE INDUSTRIAL STANDARD SYMBOL - IDEOGRAPHIC NUMBER ZERO</source>
          <target state="translated">СИМВОЛ ЯПОНСКОГО ПРОМЫШЛЕННОГО СТАНДАРТА-ИДЕОГРАФИЧЕСКОЕ ЧИСЛО НОЛЬ</target>
        </trans-unit>
        <trans-unit id="6c943af0faee20a16a4d1c5eaf93012533909700" translate="yes" xml:space="preserve">
          <source>Jacobi amplitude (a value of floating-point or integral type, measured in radians)</source>
          <target state="translated">Якоби амплитуда (значение плавающей точки или интегрального типа,измеренное в радианах)</target>
        </trans-unit>
        <trans-unit id="bdfb777e0387993e2e3d113ac36512201456491d" translate="yes" xml:space="preserve">
          <source>Jump statements</source>
          <target state="translated">Прыжковые заявления</target>
        </trans-unit>
        <trans-unit id="bb520de1f12d4fa9ce54eeee10e58e891322ab58" translate="yes" xml:space="preserve">
          <source>Jump statements unconditionally transfer flow control.</source>
          <target state="translated">Прыжковые заявления безоговорочно передают управление потоком.</target>
        </trans-unit>
        <trans-unit id="dcbf88c31714264b514798a7ba1a0f7ac134056f" translate="yes" xml:space="preserve">
          <source>Just as with a traditional loop, a &lt;a href=&quot;break&quot;&gt; break statement&lt;/a&gt; can be used to exit the loop early and a &lt;a href=&quot;continue&quot;&gt; continue statement&lt;/a&gt; can be used to restart the loop with the next element.</source>
          <target state="translated">Как и в случае с традиционным циклом, оператор &lt;a href=&quot;break&quot;&gt;break&lt;/a&gt; можно использовать для раннего выхода из цикла, а оператор &lt;a href=&quot;continue&quot;&gt;continue&lt;/a&gt; можно использовать для перезапуска цикла со следующим элементом.</target>
        </trans-unit>
        <trans-unit id="36d6db48eace81a33b705adbb64b285f0559048e" translate="yes" xml:space="preserve">
          <source>Just before becoming the end-of-sequence iterator, a &lt;code&gt;std::regex_token_iterator&lt;/code&gt; may become a</source>
          <target state="translated">Непосредственно перед тем, как стать итератором конца последовательности, &lt;code&gt;std::regex_token_iterator&lt;/code&gt; может стать</target>
        </trans-unit>
        <trans-unit id="c59dd0c7462928fa236b7f578176acd87d90eab2" translate="yes" xml:space="preserve">
          <source>Just like &lt;code&gt;&lt;a href=&quot;../utility/functional/function&quot;&gt;std::function&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;std::packaged_task&lt;/code&gt; is a polymorphic, allocator-aware container: the stored callable target may be allocated on heap or with a provided allocator.</source>
          <target state="translated">Так же, как &lt;code&gt;&lt;a href=&quot;../utility/functional/function&quot;&gt;std::function&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;std::packaged_task&lt;/code&gt; является полиморфным контейнером, учитывающим распределение: сохраненная вызываемая цель может быть выделена в куче или с помощью предоставленного распределителя.</target>
        </trans-unit>
        <trans-unit id="31d4b9f30362c85a4f4a427bba244a69e9b807a9" translate="yes" xml:space="preserve">
          <source>Just like in &lt;a href=&quot;classes&quot;&gt;struct&lt;/a&gt; declaration, the default member access in a union is &lt;a href=&quot;access&quot;&gt;public&lt;/a&gt;.</source>
          <target state="translated">Как и в объявлении &lt;a href=&quot;classes&quot;&gt;структуры&lt;/a&gt; , доступ к члену по умолчанию в объединении является &lt;a href=&quot;access&quot;&gt;открытым&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="74e2c21175f1eb09564bc31283c20889926ace69" translate="yes" xml:space="preserve">
          <source>Just like with members of primary templates, they only need to be defined if used in the program.</source>
          <target state="translated">Как и в случае с членами первичных шаблонов,их нужно определять только в том случае,если они используются в программе.</target>
        </trans-unit>
        <trans-unit id="a7ee38bb7be4fc44198cb2685d9601dcf2b9f569" translate="yes" xml:space="preserve">
          <source>K</source>
          <target state="translated">K</target>
        </trans-unit>
        <trans-unit id="0f2005c51f34f60847d9627b7dadf8093b2d0c22" translate="yes" xml:space="preserve">
          <source>K), GNSUM(op, a</source>
          <target state="translated">К),ГНСУМ (операция,а)...</target>
        </trans-unit>
        <trans-unit id="237e3ecc9a063e55a6f9fd6d2f03d4b8adf12c9a" translate="yes" xml:space="preserve">
          <source>K), GSUM(op, b</source>
          <target state="translated">К),ГГУМ (операция,б).</target>
        </trans-unit>
        <trans-unit id="7e6d3d8f6e5c6078631d54fbfd4b0dea03e2e179" translate="yes" xml:space="preserve">
          <source>Keep the existing file, without reporting an error.</source>
          <target state="translated">Сохраняйте существующий файл,не сообщая об ошибке.</target>
        </trans-unit>
        <trans-unit id="f530db58b3e5088dc7412c6d2298ba3f8456bdeb" translate="yes" xml:space="preserve">
          <source>Keywords</source>
          <target state="translated">Keywords</target>
        </trans-unit>
        <trans-unit id="d160e0986aca4714714a16f29ec605af90be704d" translate="yes" xml:space="preserve">
          <source>L</source>
          <target state="translated">L</target>
        </trans-unit>
        <trans-unit id="6f7fcc18225d37208291e381d4c7a5f47bd1ba73" translate="yes" xml:space="preserve">
          <source>LANGUAGE TAG (U+E0001) - VARIATION SELECTOR-256 (U+E01EF)</source>
          <target state="translated">ЯЗЫКОВОЙ ТЕГ (U+E0001)-СЕЛЕКТОР ВАРИАНТОВ-256 (U+E01EF)</target>
        </trans-unit>
        <trans-unit id="503ecf5371128a4d54cb093dfb32e39ad03cc18f" translate="yes" xml:space="preserve">
          <source>LATIN CAPITAL LETTER A WITH GRAVE - LATIN CAPITAL LETTER O WITH DIAERESIS</source>
          <target state="translated">ЛАТИНСКАЯ ЗАГЛАВНАЯ БУКВА A С МОГИЛОЙ-ЛАТИНСКАЯ ЗАГЛАВНАЯ БУКВА O С ДИАЕРЕЗОМ</target>
        </trans-unit>
        <trans-unit id="cb668f2f6c1dafcf47fe99fa01b751c3e0263d0b" translate="yes" xml:space="preserve">
          <source>LATIN CAPITAL LETTER O WITH STROKE - LATIN SMALL LETTER O WITH DIAERESIS</source>
          <target state="translated">ЛАТИНСКАЯ ЗАГЛАВНАЯ БУКВА O С ШТРИХОМ-ЛАТИНСКАЯ МАЛЕНЬКАЯ БУКВА O С ДИАЕРЕЗОМ</target>
        </trans-unit>
        <trans-unit id="b2be5f99f56a223f3c293b996a761c0efa14627e" translate="yes" xml:space="preserve">
          <source>LATIN SMALL LETTER O WITH STROKE - CANADIAN SYLLABICS BLACKFOOT W</source>
          <target state="translated">ЛАТИНСКАЯ МАЛЕНЬКАЯ БУКВА O С ШТРИХОМ-КАНАДСКИЙ СЛОГ BLACKFOOT W</target>
        </trans-unit>
        <trans-unit id="b4da84710b41fc09dd78f93b82fe6010bab5fd27" translate="yes" xml:space="preserve">
          <source>LC_ALLLC_COLLATELC_CTYPELC_MONETARYLC_NUMERICLC_TIME</source>
          <target state="translated">LC_ALLLC_COLLATELC_CTYPELC_MONETARYLC_NUMERICLC_TIME</target>
        </trans-unit>
        <trans-unit id="823feb18075201a2009bf899a2b4bee49397d8df" translate="yes" xml:space="preserve">
          <source>LC_TIME</source>
          <target state="translated">LC_TIME</target>
        </trans-unit>
        <trans-unit id="3fd1097fbc5a624096c5064ce332869e38dcdca6" translate="yes" xml:space="preserve">
          <source>LEFT-TO-RIGHT EMBEDDING - RIGHT-TO-LEFT OVERRIDE</source>
          <target state="translated">ЛЕВОСТОРОННЕЕ ВСТРАИВАНИЕ-ПРАВО-ЛЕВОСТОРОННЕЕ ВСТРАИВАНИЕ</target>
        </trans-unit>
        <trans-unit id="0ada04f560eef4501438475ec6acb0a8112461d2" translate="yes" xml:space="preserve">
          <source>LINEAR B SYLLABLE B008 A - CHEESE WEDGE (U+1F9C0)</source>
          <target state="translated">ЛИНЕЙНЫЙ B СЛОГ B008 A-СЫРНЫЙ КЛИН (U+1F9C0)</target>
        </trans-unit>
        <trans-unit id="65a740810ab447ffb984bd6fdf5448611bcca5d2" translate="yes" xml:space="preserve">
          <source>LLP64</source>
          <target state="translated">LLP64</target>
        </trans-unit>
        <trans-unit id="7ec33462cf14446f400924757e3fbb4271e0e95e" translate="yes" xml:space="preserve">
          <source>LLVM libc++ stores 1 less member: it maintains the rdbuf pointer as a void* member of ios_base.</source>
          <target state="translated">В LLVM libc++на 1 член меньше:указатель rdbuf сохраняется как void*член ios_base.</target>
        </trans-unit>
        <trans-unit id="bee2cfeb49f65a60be1386935bbd919b5ec97964" translate="yes" xml:space="preserve">
          <source>LP32</source>
          <target state="translated">LP32</target>
        </trans-unit>
        <trans-unit id="6cb8b2a9a5c6dacaca21f4343040021510d35c97" translate="yes" xml:space="preserve">
          <source>LP64</source>
          <target state="translated">LP64</target>
        </trans-unit>
        <trans-unit id="886ea7c4764552dcb2bbbe1db0b81daf2c0b4980" translate="yes" xml:space="preserve">
          <source>LWG 103</source>
          <target state="translated">РГ 103</target>
        </trans-unit>
        <trans-unit id="9de8fb82db7ea881cdd4818eeacc5cb88103d780" translate="yes" xml:space="preserve">
          <source>LWG 2021</source>
          <target state="translated">LWG 2021</target>
        </trans-unit>
        <trans-unit id="706cd71dbc70f54b74c9e4ca12893e72483f65ac" translate="yes" xml:space="preserve">
          <source>LWG 2048</source>
          <target state="translated">LWG 2048</target>
        </trans-unit>
        <trans-unit id="389f244b561a8b2e450ab0c1b620aab9c04f7844" translate="yes" xml:space="preserve">
          <source>LWG 2063</source>
          <target state="translated">LWG 2063</target>
        </trans-unit>
        <trans-unit id="31dc00d2b0f8ffb9c931311abf894031771bb886" translate="yes" xml:space="preserve">
          <source>LWG 2067</source>
          <target state="translated">LWG 2067</target>
        </trans-unit>
        <trans-unit id="deb8bac4bda6e7ac7927ac3f217096d074e4651c" translate="yes" xml:space="preserve">
          <source>LWG 2101</source>
          <target state="translated">LWG 2101</target>
        </trans-unit>
        <trans-unit id="96c382be88841f29be2b8476fd6eff0e02b692b5" translate="yes" xml:space="preserve">
          <source>LWG 2111</source>
          <target state="translated">LWG 2111</target>
        </trans-unit>
        <trans-unit id="d6e902d68f062e389836f2f573f3f247e27c9102" translate="yes" xml:space="preserve">
          <source>LWG 2141</source>
          <target state="translated">LWG 2141</target>
        </trans-unit>
        <trans-unit id="723eb1c8bcf878531e1514ce67bc69259241d3c4" translate="yes" xml:space="preserve">
          <source>LWG 2193</source>
          <target state="translated">LWG 2193</target>
        </trans-unit>
        <trans-unit id="810962e6457ba64d5c3482fefe25972a3420fcff" translate="yes" xml:space="preserve">
          <source>LWG 2231</source>
          <target state="translated">LWG 2231</target>
        </trans-unit>
        <trans-unit id="07b5419b2eca5506d8ab14a0d772cee5a0b24141" translate="yes" xml:space="preserve">
          <source>LWG 2316</source>
          <target state="translated">LWG 2316</target>
        </trans-unit>
        <trans-unit id="234d204a978e35929b3a3e894af0d8b867af1065" translate="yes" xml:space="preserve">
          <source>LWG 2377</source>
          <target state="translated">LWG 2377</target>
        </trans-unit>
        <trans-unit id="0de14022bde80593834d413238d25e72ecbcc411" translate="yes" xml:space="preserve">
          <source>LWG 2396</source>
          <target state="translated">LWG 2396</target>
        </trans-unit>
        <trans-unit id="98c9816aa981f67350096307bddd08234109379b" translate="yes" xml:space="preserve">
          <source>LWG 2408</source>
          <target state="translated">LWG 2408</target>
        </trans-unit>
        <trans-unit id="88897052b0b54ca7be3e73d84b0b00921d9e552c" translate="yes" xml:space="preserve">
          <source>LWG 2420</source>
          <target state="translated">LWG 2420</target>
        </trans-unit>
        <trans-unit id="4df86d5ce11e282b81c2bbb5175527f98652fcef" translate="yes" xml:space="preserve">
          <source>LWG 2422</source>
          <target state="translated">LWG 2422</target>
        </trans-unit>
        <trans-unit id="84b18947260bfe1f0a5996d405140bb230ae0767" translate="yes" xml:space="preserve">
          <source>LWG 2441</source>
          <target state="translated">LWG 2441</target>
        </trans-unit>
        <trans-unit id="cbfcae2a308f80ed1c6f7b0aa1df94fb40aaf739" translate="yes" xml:space="preserve">
          <source>LWG 2442</source>
          <target state="translated">LWG 2442</target>
        </trans-unit>
        <trans-unit id="39d7d59672fbad6538e7af83c470ceced5e98772" translate="yes" xml:space="preserve">
          <source>LWG 2444</source>
          <target state="translated">LWG 2444</target>
        </trans-unit>
        <trans-unit id="64c015ca6fb365162de4d9802c96ff79810e3eba" translate="yes" xml:space="preserve">
          <source>LWG 2456</source>
          <target state="translated">LWG 2456</target>
        </trans-unit>
        <trans-unit id="479bc2ddf5e751a671056d086c6f5edd270c71fa" translate="yes" xml:space="preserve">
          <source>LWG 2458</source>
          <target state="translated">LWG 2458</target>
        </trans-unit>
        <trans-unit id="1edc38665e8899d906240e69ba2477977706ba89" translate="yes" xml:space="preserve">
          <source>LWG 2459</source>
          <target state="translated">LWG 2459</target>
        </trans-unit>
        <trans-unit id="6be2a0368db7a8aa977aee824cc855ad8d6cb8b3" translate="yes" xml:space="preserve">
          <source>LWG 2460</source>
          <target state="translated">LWG 2460</target>
        </trans-unit>
        <trans-unit id="40c67758d05b4454663ae12087f93b2294a7887e" translate="yes" xml:space="preserve">
          <source>LWG 2485</source>
          <target state="translated">LWG 2485</target>
        </trans-unit>
        <trans-unit id="ef5117f94807e8fa3fd3d6d510e7ee4f699f4b23" translate="yes" xml:space="preserve">
          <source>LWG 2510</source>
          <target state="translated">LWG 2510</target>
        </trans-unit>
        <trans-unit id="5f130db76eea1dbe14493e67e4a16dbe505a9e2e" translate="yes" xml:space="preserve">
          <source>LWG 2550</source>
          <target state="translated">LWG 2550</target>
        </trans-unit>
        <trans-unit id="ca02fd1a836a738f855f4be277ea46227c2c6ff3" translate="yes" xml:space="preserve">
          <source>LWG 2554</source>
          <target state="translated">LWG 2554</target>
        </trans-unit>
        <trans-unit id="41e9bbe3caae10f06305c082750ab7abc56ee095" translate="yes" xml:space="preserve">
          <source>LWG 2556</source>
          <target state="translated">LWG 2556</target>
        </trans-unit>
        <trans-unit id="a7fa4024fcd73ba7048d1081eb12cb834158b7ab" translate="yes" xml:space="preserve">
          <source>LWG 2597</source>
          <target state="translated">LWG 2597</target>
        </trans-unit>
        <trans-unit id="f677e3426681f881a680fe99e83000652b32a988" translate="yes" xml:space="preserve">
          <source>LWG 2682</source>
          <target state="translated">LWG 2682</target>
        </trans-unit>
        <trans-unit id="81d82ea92f45eea83f18af5577cc2d919bfe90d4" translate="yes" xml:space="preserve">
          <source>LWG 270</source>
          <target state="translated">LWG 270</target>
        </trans-unit>
        <trans-unit id="8e573b1dfb07e6658a7360ffdc338e9b3f93b49f" translate="yes" xml:space="preserve">
          <source>LWG 2735</source>
          <target state="translated">LWG 2735</target>
        </trans-unit>
        <trans-unit id="227dbdd98899cadd424a56e2f7d7d6a78f38856f" translate="yes" xml:space="preserve">
          <source>LWG 2739</source>
          <target state="translated">LWG 2739</target>
        </trans-unit>
        <trans-unit id="9eb33f94aa6faf46b0eb2f66260ee186604d4a50" translate="yes" xml:space="preserve">
          <source>LWG 2782</source>
          <target state="translated">LWG 2782</target>
        </trans-unit>
        <trans-unit id="d920e722f9f2beb6d3d46c97d699d7aca6281fdd" translate="yes" xml:space="preserve">
          <source>LWG 2783</source>
          <target state="translated">LWG 2783</target>
        </trans-unit>
        <trans-unit id="63dbc60824b85913f49c89b16c9025b3daf3402a" translate="yes" xml:space="preserve">
          <source>LWG 2843</source>
          <target state="translated">LWG 2843</target>
        </trans-unit>
        <trans-unit id="fdaad41a94231184e89d21323eb4df5beb258d0e" translate="yes" xml:space="preserve">
          <source>LWG 2870</source>
          <target state="translated">LWG 2870</target>
        </trans-unit>
        <trans-unit id="63de5c8018c8f07659e2254629b4ebfecbdf0e68" translate="yes" xml:space="preserve">
          <source>LWG 2901</source>
          <target state="translated">LWG 2901</target>
        </trans-unit>
        <trans-unit id="65a38639ef5dfa6b953951bf416dbef1b06d2565" translate="yes" xml:space="preserve">
          <source>LWG 2935</source>
          <target state="translated">LWG 2935</target>
        </trans-unit>
        <trans-unit id="8df8d07f79de7eff959bd46fc88293ce52ce6252" translate="yes" xml:space="preserve">
          <source>LWG 2936</source>
          <target state="translated">LWG 2936</target>
        </trans-unit>
        <trans-unit id="6af1a8a4fbc321bb616e82f22c084066312fc066" translate="yes" xml:space="preserve">
          <source>LWG 2937</source>
          <target state="translated">LWG 2937</target>
        </trans-unit>
        <trans-unit id="620d7168575a023def1c823681197877ef6db868" translate="yes" xml:space="preserve">
          <source>LWG 2942</source>
          <target state="translated">LWG 2942</target>
        </trans-unit>
        <trans-unit id="6ec364c67d40cf80dd78cca2c8063943882a4782" translate="yes" xml:space="preserve">
          <source>LWG 2945</source>
          <target state="translated">LWG 2945</target>
        </trans-unit>
        <trans-unit id="584b1cd1ca53e0a10c9c53d113a6c1b03f94da27" translate="yes" xml:space="preserve">
          <source>LWG 2946</source>
          <target state="translated">LWG 2946</target>
        </trans-unit>
        <trans-unit id="2092ab29c8ec4efb56008c5dbf84dd1a89910f85" translate="yes" xml:space="preserve">
          <source>LWG 2955</source>
          <target state="translated">LWG 2955</target>
        </trans-unit>
        <trans-unit id="db6b4c474d2b187cadd86c637f7b9a707deded5a" translate="yes" xml:space="preserve">
          <source>LWG 2956</source>
          <target state="translated">LWG 2956</target>
        </trans-unit>
        <trans-unit id="6651b628d955dbc375211fd9965b95e7828c0930" translate="yes" xml:space="preserve">
          <source>LWG 2969</source>
          <target state="translated">LWG 2969</target>
        </trans-unit>
        <trans-unit id="f25beb31bbd789f502c7039a906832b4193e490b" translate="yes" xml:space="preserve">
          <source>LWG 2974</source>
          <target state="translated">LWG 2974</target>
        </trans-unit>
        <trans-unit id="03b6470838ea079e5b35bdd7f4c0a4324f5be97c" translate="yes" xml:space="preserve">
          <source>LWG 2975</source>
          <target state="translated">LWG 2975</target>
        </trans-unit>
        <trans-unit id="00b1711427feb1cdc052a19c3dd5ba1f5d784d54" translate="yes" xml:space="preserve">
          <source>LWG 2979</source>
          <target state="translated">LWG 2979</target>
        </trans-unit>
        <trans-unit id="03245fa5249a80c9e88d330bdbed3d5b0efd3c1a" translate="yes" xml:space="preserve">
          <source>LWG 2980</source>
          <target state="translated">LWG 2980</target>
        </trans-unit>
        <trans-unit id="8e27ede83edeebcb833e56711cf9e85bad9f6a81" translate="yes" xml:space="preserve">
          <source>LWG 2981</source>
          <target state="translated">LWG 2981</target>
        </trans-unit>
        <trans-unit id="3094306bb363791eae0c331ba69cdfa31cd03bd2" translate="yes" xml:space="preserve">
          <source>LWG 2989</source>
          <target state="translated">LWG 2989</target>
        </trans-unit>
        <trans-unit id="b88afb71ca72f3a5b4d7ca39bd5f6d7740d1ca6c" translate="yes" xml:space="preserve">
          <source>LWG 2993</source>
          <target state="translated">LWG 2993</target>
        </trans-unit>
        <trans-unit id="d940e3b0bc4c6c07c3b76d624ad35c4b1995863f" translate="yes" xml:space="preserve">
          <source>LWG 3000</source>
          <target state="translated">LWG 3000</target>
        </trans-unit>
        <trans-unit id="4efd58af92ed99b44892eea2a6474d567bd785e3" translate="yes" xml:space="preserve">
          <source>LWG 3001</source>
          <target state="translated">LWG 3001</target>
        </trans-unit>
        <trans-unit id="1061d475efae99eb0cd73389f5cc7edb38d2b547" translate="yes" xml:space="preserve">
          <source>LWG 3012</source>
          <target state="translated">LWG 3012</target>
        </trans-unit>
        <trans-unit id="0007b14636a9f8886845093dd4fceab33f240906" translate="yes" xml:space="preserve">
          <source>LWG 3013</source>
          <target state="translated">LWG 3013</target>
        </trans-unit>
        <trans-unit id="66844fe2413d66059e9dfcdf2de2b069f47bdc1a" translate="yes" xml:space="preserve">
          <source>LWG 3014</source>
          <target state="translated">LWG 3014</target>
        </trans-unit>
        <trans-unit id="c6e63f6d84c4a00806bd3c82b03223958cc3e8ef" translate="yes" xml:space="preserve">
          <source>LWG 3024</source>
          <target state="translated">LWG 3024</target>
        </trans-unit>
        <trans-unit id="d4a638b7c5508bb67a4aa7d1d18ad719debb7ef5" translate="yes" xml:space="preserve">
          <source>LWG 3025</source>
          <target state="translated">LWG 3025</target>
        </trans-unit>
        <trans-unit id="633b0245721ec6f09845623cc66b7d4cd4a42726" translate="yes" xml:space="preserve">
          <source>LWG 3065</source>
          <target state="translated">LWG 3065</target>
        </trans-unit>
        <trans-unit id="172b1343747b38d1683b7b9b0e7208f82799b40e" translate="yes" xml:space="preserve">
          <source>LWG 3074</source>
          <target state="translated">LWG 3074</target>
        </trans-unit>
        <trans-unit id="fec86e1855b1d157821d7f496304297f01df2663" translate="yes" xml:space="preserve">
          <source>LWG 3075</source>
          <target state="translated">LWG 3075</target>
        </trans-unit>
        <trans-unit id="ad4916674d38c8cbc53c0d10cb3a10d32caa2e0f" translate="yes" xml:space="preserve">
          <source>LWG 3076</source>
          <target state="translated">LWG 3076</target>
        </trans-unit>
        <trans-unit id="3e2a83c594fad4b9e122e8313412c496da714783" translate="yes" xml:space="preserve">
          <source>LWG 3096</source>
          <target state="translated">LWG 3096</target>
        </trans-unit>
        <trans-unit id="b8a6836406e247baec45da221ee2d125a3cbeda4" translate="yes" xml:space="preserve">
          <source>L_tmpnam</source>
          <target state="translated">L_tmpnam</target>
        </trans-unit>
        <trans-unit id="2228985493d9e43e461c7be5525529248735ad9c" translate="yes" xml:space="preserve">
          <source>Labels</source>
          <target state="translated">Labels</target>
        </trans-unit>
        <trans-unit id="ef93e00ee616b79b01a6a513b42f7bef6875e5e6" translate="yes" xml:space="preserve">
          <source>Labels (&lt;a href=&quot;goto&quot;&gt;goto targets&lt;/a&gt;, &lt;code&gt;case&lt;/code&gt; labels, and &lt;code&gt;default:&lt;/code&gt;) appearing in a substatement of a constexpr if can only be referenced (by &lt;a href=&quot;switch&quot;&gt;switch&lt;/a&gt; or &lt;a href=&quot;goto&quot;&gt;goto&lt;/a&gt;) in the same substatement.</source>
          <target state="translated">Этикетки ( &lt;a href=&quot;goto&quot;&gt;GOTO цель&lt;/a&gt; , &lt;code&gt;case&lt;/code&gt; метки, и по &lt;code&gt;default:&lt;/code&gt; ) появляется в подоператоре о наличии constexpr , если можно ссылаться только ( с помощью &lt;a href=&quot;switch&quot;&gt;переключателя&lt;/a&gt; или &lt;a href=&quot;goto&quot;&gt;Goto&lt;/a&gt; ) в том же подоператоре.</target>
        </trans-unit>
        <trans-unit id="4192545e02bafef39c99c48279c9d025ce9cc37d" translate="yes" xml:space="preserve">
          <source>Laguerre polynomials</source>
          <target state="translated">Полиномиальная лагуэр</target>
        </trans-unit>
        <trans-unit id="a7a791f6abd60dc5a353ea53ddfb3ee7c9745d37" translate="yes" xml:space="preserve">
          <source>Lambda capture</source>
          <target state="translated">Захват лямбды</target>
        </trans-unit>
        <trans-unit id="1d382614f838c28eb61834675bae6d432fff0445" translate="yes" xml:space="preserve">
          <source>Lambda capture of *this by value as [=,*this]</source>
          <target state="translated">Захват лямбды *это по значению как [=,*это]</target>
        </trans-unit>
        <trans-unit id="7bd97cf3e71e6cfe2f11b11baf163207e4fee010" translate="yes" xml:space="preserve">
          <source>Lambda captures</source>
          <target state="translated">Захваты Лямбды</target>
        </trans-unit>
        <trans-unit id="ad760081fe95ad36f1148cf3a82266f36a17d08b" translate="yes" xml:space="preserve">
          <source>Lambda expressions</source>
          <target state="translated">выражения лямбда</target>
        </trans-unit>
        <trans-unit id="29608c2c063008f0167b6a128fd16e27d0f6f38e" translate="yes" xml:space="preserve">
          <source>Lambda expressions (since C++11)</source>
          <target state="translated">Выражения Lambda (начиная с C++11)</target>
        </trans-unit>
        <trans-unit id="b7d5884df6b1a928d6d7c3491a4a743a3e414bb2" translate="yes" xml:space="preserve">
          <source>Lambda-expressions are not allowed in &lt;a href=&quot;expressions#Unevaluated_expressions&quot;&gt;unevaluated expressions&lt;/a&gt;, &lt;a href=&quot;template_parameters&quot;&gt;template arguments&lt;/a&gt;, &lt;a href=&quot;type_alias&quot;&gt;alias declarations&lt;/a&gt;, &lt;a href=&quot;typedef&quot;&gt;typedef declarations&lt;/a&gt;, and anywhere in a function (or function template) declaration except the function body and the function's &lt;a href=&quot;default_arguments&quot;&gt;default arguments&lt;/a&gt;.</source>
          <target state="translated">Лямбда-выражения не допускаются в &lt;a href=&quot;expressions#Unevaluated_expressions&quot;&gt;невычисленных выражениях&lt;/a&gt; , &lt;a href=&quot;template_parameters&quot;&gt;аргументах шаблона&lt;/a&gt; , &lt;a href=&quot;type_alias&quot;&gt;декларациях псевдонимов&lt;/a&gt; , &lt;a href=&quot;typedef&quot;&gt;TYPEDEF деклараций&lt;/a&gt; , а где - нибудь в функции (или шаблон функции) декларации , за исключением функции тела и функцию по &lt;a href=&quot;default_arguments&quot;&gt;аргументам по умолчанию&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="89b86ab0e66f527166d98df92ddbcf5416ed58f6" translate="yes" xml:space="preserve">
          <source>Language</source>
          <target state="translated">Language</target>
        </trans-unit>
        <trans-unit id="677b369051c8d8b22e38c70e8f452a88713342b3" translate="yes" xml:space="preserve">
          <source>Language feature-testing macros</source>
          <target state="translated">Макросы тестирования языковых функций</target>
        </trans-unit>
        <trans-unit id="2c4c5fa97a894aab5c689757f00ca2ff05f31ca9" translate="yes" xml:space="preserve">
          <source>Language features</source>
          <target state="translated">Языковые характеристики</target>
        </trans-unit>
        <trans-unit id="9ca65a6a550090403c1994a3813c60f37d61983a" translate="yes" xml:space="preserve">
          <source>Language linkage</source>
          <target state="translated">Языковая связь</target>
        </trans-unit>
        <trans-unit id="b4444821bc7114c255e706d9193016c8234ee05f" translate="yes" xml:space="preserve">
          <source>Language specifications can only appear in &lt;a href=&quot;scope#Namespace_scope&quot;&gt;namespace scope&lt;/a&gt;.</source>
          <target state="translated">Спецификации языка могут появляться только в области &lt;a href=&quot;scope#Namespace_scope&quot;&gt;имен&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e794492ee652fe942ec624908ae4ef64d0ff8202" translate="yes" xml:space="preserve">
          <source>Language support</source>
          <target state="translated">Языковая поддержка</target>
        </trans-unit>
        <trans-unit id="cc8615e79210c7c7a5e9fe165da74603db62e518" translate="yes" xml:space="preserve">
          <source>Language support libraries provide classes and functions that interact closely with language features and support common language idioms.</source>
          <target state="translated">Библиотеки языковой поддержки предоставляют классы и функции,которые тесно взаимодействуют с особенностями языка и поддерживают общие языковые идиомы.</target>
        </trans-unit>
        <trans-unit id="972ad8d8a50397ba8c02433ed8f048eeb4074b85" translate="yes" xml:space="preserve">
          <source>Layout</source>
          <target state="translated">Layout</target>
        </trans-unit>
        <trans-unit id="5c7c4bf8885640694e2c9d84d334b33834362e92" translate="yes" xml:space="preserve">
          <source>Leap seconds are not inserted into GPS. Thus, every time a leap second is inserted into UTC, UTC falls another second behind GPS. As of December 2017, UTC is 18 seconds behind GPS, reflecting the 18 leap seconds inserted between 1980 and 2017. Thus, 2018-01-01 00:00:00 UTC is equivalent to 2018-01-01 00:00:18 GPS. GPS is a constant 19 seconds behind &lt;a href=&quot;tai_clock&quot;&gt;TAI&lt;/a&gt;.</source>
          <target state="translated">Дополнительные секунды не вставляются в GPS. Таким образом, каждый раз, когда в UTC вставляется дополнительная секунда, UTC отстает еще на одну секунду от GPS. По состоянию на декабрь 2017 года UTC отстает от GPS на 18 секунд, что отражает 18 високосных секунд, вставленных между 1980 и 2017 годами. Таким образом, 2018-01-01 00:00:00 UTC эквивалентно 2018-01-01 00:00:18 GPS , GPS на 19 секунд меньше, чем &lt;a href=&quot;tai_clock&quot;&gt;TAI&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="611855b599edd2fe82347140d615a27b9df0aac3" translate="yes" xml:space="preserve">
          <source>Leap seconds are not inserted into TAI. Thus, every time a leap second is inserted into UTC, UTC falls another second behind TAI. As of December 2017, UTC is 37 seconds behind TAI, reflecting the 10-second initial offset and the 27 leap seconds inserted between 1958 and 2017. Thus, 2018-01-01 00:00:00 UTC is equivalent to 2018-01-01 00:00:37 TAI.</source>
          <target state="translated">Прыжковые секунды не вставляются в TAI.Таким образом,каждый раз,когда в UTC вставляется прыжковая секунда,UTC отстает от TAI еще на одну секунду.По состоянию на декабрь 2017 года,UTC отстает от TAI на 37 секунд,что отражает 10-секундное начальное смещение и 27 прыжковых секунд,введенных между 1958 и 2017 годами.Таким образом,2018-01-01 00:00:00 UTC эквивалентно 2018-01-01 00:00:37 TAI.</target>
        </trans-unit>
        <trans-unit id="bf56ec55d59d151077b04a3c3b2a260fcafe6e19" translate="yes" xml:space="preserve">
          <source>Leaves the &lt;code&gt;&lt;a href=&quot;capacity&quot;&gt;capacity()&lt;/a&gt;&lt;/code&gt; of the vector unchanged (note: the standard's restriction on the changes to capacity is in the specification of &lt;code&gt;vector::reserve&lt;/code&gt;, see &lt;a href=&quot;http://stackoverflow.com/a/18467916&quot;&gt;[1]&lt;/a&gt;).</source>
          <target state="translated">Оставляет &lt;code&gt;&lt;a href=&quot;capacity&quot;&gt;capacity()&lt;/a&gt;&lt;/code&gt; вектора неизменной (примечание: ограничение стандарта на изменения емкости указано в спецификации &lt;code&gt;vector::reserve&lt;/code&gt; , см. &lt;a href=&quot;http://stackoverflow.com/a/18467916&quot;&gt;[1]&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="86e0813490cdee81f22682268815667b06f5c776" translate="yes" xml:space="preserve">
          <source>Leaves the &lt;code&gt;&lt;a href=&quot;capacity&quot;&gt;capacity()&lt;/a&gt;&lt;/code&gt; of the vector unchanged (note: the standard's restriction on the changes to capacity is in the specification of &lt;code&gt;vector::reserve&lt;/code&gt;, see &lt;a href=&quot;https://stackoverflow.com/a/18467916&quot;&gt;[1]&lt;/a&gt;).</source>
          <target state="translated">Оставляет &lt;code&gt;&lt;a href=&quot;capacity&quot;&gt;capacity()&lt;/a&gt;&lt;/code&gt; вектора неизменной (примечание: стандартное ограничение на изменение емкости содержится в спецификации &lt;code&gt;vector::reserve&lt;/code&gt; , см. &lt;a href=&quot;https://stackoverflow.com/a/18467916&quot;&gt;[1]&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="741a41d00730604d24e69761626a739d511f27fa" translate="yes" xml:space="preserve">
          <source>Leaving a synchronized block by any means (reaching the end, executing goto, break, continue, or return, or throwing an exception) exits the block and synchronizes-with the next block in the single total order if the exited block was an outer block. The behavior is undefined if &lt;code&gt;&lt;a href=&quot;../utility/program/longjmp&quot;&gt;std::longjmp&lt;/a&gt;&lt;/code&gt; is used to exit a synchronized block.</source>
          <target state="translated">Выход из синхронизированного блока любым способом (достижение конца, выполнение goto, break, continue или return или выбрасывание исключения) выходит из блока и синхронизируется со следующим блоком в едином общем порядке, если выходной блок был внешним блоком , Поведение не определено, если &lt;code&gt;&lt;a href=&quot;../utility/program/longjmp&quot;&gt;std::longjmp&lt;/a&gt;&lt;/code&gt; используется для выхода из синхронизированного блока.</target>
        </trans-unit>
        <trans-unit id="31d6213c56c41b4cc125420dcc2b33093d12c123" translate="yes" xml:space="preserve">
          <source>Leaving an atomic block by any means other than exception (reaching the end, goto, break, continue, return) commits the transaction. The behavior is undefined if &lt;code&gt;&lt;a href=&quot;../utility/program/longjmp&quot;&gt;std::longjmp&lt;/a&gt;&lt;/code&gt; is used to exit an atomic block.</source>
          <target state="translated">Выход из атомарного блока любым способом, кроме исключения (достижение конца, переход, разрыв, продолжение, возврат), фиксирует транзакцию. Поведение не определено, если &lt;code&gt;&lt;a href=&quot;../utility/program/longjmp&quot;&gt;std::longjmp&lt;/a&gt;&lt;/code&gt; используется для выхода из атомарного блока.</target>
        </trans-unit>
        <trans-unit id="bdffb77ae44e48c63c181cf7541184b7bfe75b59" translate="yes" xml:space="preserve">
          <source>Left-to-right</source>
          <target state="translated">Left-to-right</target>
        </trans-unit>
        <trans-unit id="f644f1aaae2b85733ad956d52e9d411a359c5caf" translate="yes" xml:space="preserve">
          <source>LegacyBidirectionalIterator</source>
          <target state="translated">LegacyBidirectionalIterator</target>
        </trans-unit>
        <trans-unit id="c4a5b29b136f2ede2a2531477e7bb3c2ca5abf2b" translate="yes" xml:space="preserve">
          <source>LegacyBidirectionalIterator is a LegacyBidirectionalIterator that additionally satisfies the &lt;a href=&quot;outputiterator&quot;&gt;LegacyOutputIterator&lt;/a&gt; requirements.</source>
          <target state="translated">LegacyBidirectionalIterator - это LegacyBidirectionalIterator, который дополнительно удовлетворяет требованиям &lt;a href=&quot;outputiterator&quot;&gt;LegacyOutputIterator&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c0fa292844214f93eb7bc4d960957ba473ff303f" translate="yes" xml:space="preserve">
          <source>LegacyContiguousIterator</source>
          <target state="translated">LegacyContiguousIterator</target>
        </trans-unit>
        <trans-unit id="abba9ce1b1082ec030ac0427b7a1d0e517041d2c" translate="yes" xml:space="preserve">
          <source>LegacyForwardIterator</source>
          <target state="translated">LegacyForwardIterator</target>
        </trans-unit>
        <trans-unit id="096905dbdfa46128b8feb9520f8a815491bb23e6" translate="yes" xml:space="preserve">
          <source>LegacyForwardIterator is a LegacyForwardIterator that additionally satisfies the &lt;a href=&quot;outputiterator&quot;&gt;LegacyOutputIterator&lt;/a&gt; requirements.</source>
          <target state="translated">LegacyForwardIterator - это LegacyForwardIterator, который дополнительно удовлетворяет требованиям &lt;a href=&quot;outputiterator&quot;&gt;LegacyOutputIterator&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9bdad701a59fe021a9f0ea8f1e2907f8e0e60476" translate="yes" xml:space="preserve">
          <source>LegacyInputIterator</source>
          <target state="translated">LegacyInputIterator</target>
        </trans-unit>
        <trans-unit id="585fe456965ba38488a01543309716171330d718" translate="yes" xml:space="preserve">
          <source>LegacyIterator</source>
          <target state="translated">LegacyIterator</target>
        </trans-unit>
        <trans-unit id="3cdb555f844cd2dc50f1ef7c5652c1f890df1f87" translate="yes" xml:space="preserve">
          <source>LegacyIterator is the base set of requirements used by other iterator types: &lt;a href=&quot;inputiterator&quot;&gt;LegacyInputIterator&lt;/a&gt;, &lt;a href=&quot;outputiterator&quot;&gt;LegacyOutputIterator&lt;/a&gt;, &lt;a href=&quot;forwarditerator&quot;&gt;LegacyForwardIterator&lt;/a&gt;, &lt;a href=&quot;bidirectionaliterator&quot;&gt;LegacyBidirectionalIterator&lt;/a&gt;, and &lt;a href=&quot;randomaccessiterator&quot;&gt;LegacyRandomAccessIterator&lt;/a&gt;. Iterators can be thought of as an abstraction of pointers.</source>
          <target state="translated">LegacyIterator - это базовый набор требований, используемых другими типами итераторов: &lt;a href=&quot;inputiterator&quot;&gt;LegacyInputIterator&lt;/a&gt; , &lt;a href=&quot;outputiterator&quot;&gt;LegacyOutputIterator&lt;/a&gt; , &lt;a href=&quot;forwarditerator&quot;&gt;LegacyForwardIterator&lt;/a&gt; , &lt;a href=&quot;bidirectionaliterator&quot;&gt;LegacyBidirectionalIterator&lt;/a&gt; и &lt;a href=&quot;randomaccessiterator&quot;&gt;LegacyRandomAccessIterator&lt;/a&gt; . Итераторы можно рассматривать как абстракцию указателей.</target>
        </trans-unit>
        <trans-unit id="6e768ef221583d1c5e44ef0573554b7ccf685e09" translate="yes" xml:space="preserve">
          <source>LegacyOutputIterator</source>
          <target state="translated">LegacyOutputIterator</target>
        </trans-unit>
        <trans-unit id="8fa47f5539d2203c38a39fce4c4b0ef195c146d3" translate="yes" xml:space="preserve">
          <source>LegacyRandomAccessIterator</source>
          <target state="translated">LegacyRandomAccessIterator</target>
        </trans-unit>
        <trans-unit id="742f0b2803ca04b5223bb318425b08421d148103" translate="yes" xml:space="preserve">
          <source>LegacyRandomAccessIterator is a LegacyRandomAccessIterator that additionally satisfies the &lt;a href=&quot;outputiterator&quot;&gt;LegacyOutputIterator&lt;/a&gt; requirements.</source>
          <target state="translated">LegacyRandomAccessIterator - это LegacyRandomAccessIterator, который дополнительно удовлетворяет требованиям &lt;a href=&quot;outputiterator&quot;&gt;LegacyOutputIterator&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5846955db6bef539707c3590c701613c5f0cf50f" translate="yes" xml:space="preserve">
          <source>Legend</source>
          <target state="translated">Legend</target>
        </trans-unit>
        <trans-unit id="5d59dd3a73ef773d7095755185b08a856862f59c" translate="yes" xml:space="preserve">
          <source>Legendre polynomials</source>
          <target state="translated">Полиномиальная Легенда</target>
        </trans-unit>
        <trans-unit id="7906417f7e9cebe12726504e25b8c0b72bf1f772" translate="yes" xml:space="preserve">
          <source>LessThanComparable</source>
          <target state="translated">LessThanComparable</target>
        </trans-unit>
        <trans-unit id="274ae48acc8830f71730c0873d33a6285228a9de" translate="yes" xml:space="preserve">
          <source>Let &lt;code&gt;CMP(x,y)&lt;/code&gt; be &lt;code&gt;1&lt;/code&gt; if &lt;code&gt;x &amp;gt; y&lt;/code&gt;, &lt;code&gt;-1&lt;/code&gt; if &lt;code&gt;x &amp;lt; y&lt;/code&gt;, and &lt;code&gt;0&lt;/code&gt; otherwise. For any &lt;code&gt;t1&lt;/code&gt; and &lt;code&gt;t2&lt;/code&gt;, the product of &lt;code&gt;CMP(lerp(a, b, t2), lerp(a, b, t1))&lt;/code&gt;, &lt;code&gt;CMP(t2, t1)&lt;/code&gt;, and &lt;code&gt;CMP(b, a)&lt;/code&gt; is non-negative. (That is, &lt;code&gt;lerp&lt;/code&gt; is monotonic.).</source>
          <target state="translated">Пусть &lt;code&gt;CMP(x,y)&lt;/code&gt; будет &lt;code&gt;1&lt;/code&gt; , если &lt;code&gt;x &amp;gt; y&lt;/code&gt; , &lt;code&gt;-1&lt;/code&gt; , если &lt;code&gt;x &amp;lt; y&lt;/code&gt; , и &lt;code&gt;0&lt;/code&gt; в противном случае. Для любых &lt;code&gt;t1&lt;/code&gt; и &lt;code&gt;t2&lt;/code&gt; произведение &lt;code&gt;CMP(lerp(a, b, t2), lerp(a, b, t1))&lt;/code&gt; , &lt;code&gt;CMP(t2, t1)&lt;/code&gt; и &lt;code&gt;CMP(b, a)&lt;/code&gt; неотрицательно. (То есть &lt;code&gt;lerp&lt;/code&gt; монотонен .)</target>
        </trans-unit>
        <trans-unit id="12941d0eb9ed4aeacc52d5f00426e066fee74e7d" translate="yes" xml:space="preserve">
          <source>Let &lt;code&gt;P&lt;/code&gt; equal the precision if nonzero, &lt;code&gt;6&lt;/code&gt; if the precision is not specified, or &lt;code&gt;1&lt;/code&gt; if the precision is &lt;code&gt;​0​&lt;/code&gt;. Then, if a conversion with style &lt;code&gt;E&lt;/code&gt; would have an exponent of &lt;code&gt;X&lt;/code&gt;:</source>
          <target state="translated">Пусть &lt;code&gt;P&lt;/code&gt; равна точность , если отлична от нуля, &lt;code&gt;6&lt;/code&gt; , если точность не указана, или &lt;code&gt;1&lt;/code&gt; , если точность равна &lt;code&gt;​0​&lt;/code&gt; . Тогда, если преобразование со стилем &lt;code&gt;E&lt;/code&gt; будет иметь показатель степени &lt;code&gt;X&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="1d96618afd4263ec0d73d199a2618f5e147e9e73" translate="yes" xml:space="preserve">
          <source>Let &lt;code&gt;U&lt;/code&gt; be &lt;code&gt;&lt;a href=&quot;../../types/remove_cv&quot;&gt;std::remove_cv_t&lt;/a&gt;&amp;lt;&lt;a href=&quot;../../types/remove_reference&quot;&gt;std::remove_reference_t&lt;/a&gt;&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">Пусть &lt;code&gt;U&lt;/code&gt; будет &lt;code&gt;&lt;a href=&quot;../../types/remove_cv&quot;&gt;std::remove_cv_t&lt;/a&gt;&amp;lt;&lt;a href=&quot;../../types/remove_reference&quot;&gt;std::remove_reference_t&lt;/a&gt;&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="32d8483331780e895e2e6534b1cf368ac9e20d64" translate="yes" xml:space="preserve">
          <source>Let &lt;code&gt;Y&lt;/code&gt; be &lt;code&gt;typename &lt;a href=&quot;../shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&amp;lt;T&amp;gt;::element_type&lt;/code&gt;, then the resulting &lt;code&gt;&lt;a href=&quot;../shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&lt;/code&gt;'s stored pointer will be obtained by evaluating, respectively:</source>
          <target state="translated">Пусть &lt;code&gt;Y&lt;/code&gt; будет &lt;code&gt;typename &lt;a href=&quot;../shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&amp;lt;T&amp;gt;::element_type&lt;/code&gt; , тогда результирующий сохраненный указатель &lt;code&gt;&lt;a href=&quot;../shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&lt;/code&gt; будет получен путем оценки, соответственно:</target>
        </trans-unit>
        <trans-unit id="7bf1f858e1bdfaa71eed61b027d72a6d348da6cc" translate="yes" xml:space="preserve">
          <source>Let &lt;code&gt;fn&lt;/code&gt; be the call wrapper returned by a call to &lt;code&gt;std::mem_fn&lt;/code&gt; with a pointer to member &lt;code&gt;pm&lt;/code&gt;. Then the expression &lt;code&gt;fn(t, a2, ..., aN)&lt;/code&gt; is equivalent to &lt;code&gt;INVOKE(pm, t, a2, ..., aN)&lt;/code&gt;, where</source>
          <target state="translated">Пусть &lt;code&gt;fn&lt;/code&gt; будет оболочкой вызова, возвращаемой вызовом &lt;code&gt;std::mem_fn&lt;/code&gt; с указателем на член &lt;code&gt;pm&lt;/code&gt; . Тогда выражение &lt;code&gt;fn(t, a2, ..., aN)&lt;/code&gt; эквивалентно &lt;code&gt;INVOKE(pm, t, a2, ..., aN)&lt;/code&gt; , где</target>
        </trans-unit>
        <trans-unit id="4affff119284bd8c17502a7b4ba9cddc4335375c" translate="yes" xml:space="preserve">
          <source>Let &lt;code&gt;since_midnight&lt;/code&gt; be the stored duration:</source>
          <target state="translated">Пусть &lt;code&gt;since_midnight&lt;/code&gt; будет сохраненной продолжительностью:</target>
        </trans-unit>
        <trans-unit id="81727cefad0e4f620e16d3a8ef618ac5d109ea3a" translate="yes" xml:space="preserve">
          <source>Let's consider now those cases employing argument-dependent lookup (i.e., we use the more common call format &lt;code&gt;f(t)&lt;/code&gt;).</source>
          <target state="translated">Рассмотрим теперь те случаи, в которых используется аргумент-зависимый поиск (т. Е. Мы используем более распространенный формат вызовов &lt;code&gt;f(t)&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="41a116dfc9200f26422a8e9d5e49911e4bc90a0d" translate="yes" xml:space="preserve">
          <source>Letters in the integer literals are case-insensitive: &lt;code&gt;0xDeAdBeEfU&lt;/code&gt; and &lt;code&gt;0XdeadBEEFu&lt;/code&gt; represent the same number (one exception is the long-long-suffix, which is either &lt;code&gt;ll&lt;/code&gt; or &lt;code&gt;LL&lt;/code&gt;, never &lt;code&gt;lL&lt;/code&gt; or &lt;code&gt;Ll&lt;/code&gt;).</source>
          <target state="translated">Буквы в целочисленных литералах нечувствительны к регистру: &lt;code&gt;0xDeAdBeEfU&lt;/code&gt; и &lt;code&gt;0XdeadBEEFu&lt;/code&gt; представляют одно и то же число (одно исключение - это длинный-длинный-суффикс, который равен либо &lt;code&gt;ll&lt;/code&gt; , либо &lt;code&gt;LL&lt;/code&gt; , а не &lt;code&gt;lL&lt;/code&gt; или &lt;code&gt;Ll&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="4e3f5ccac8e611393a344b1488ebf8b88e0bab4b" translate="yes" xml:space="preserve">
          <source>Lexicographical comparison is a operation with the following properties:</source>
          <target state="translated">Лексикографическое сравнение-это операция со следующими свойствами:</target>
        </trans-unit>
        <trans-unit id="7273c76d82ab971497c1735a342d6d033382649f" translate="yes" xml:space="preserve">
          <source>Lexicographically compares two ranges &lt;code&gt;[first1, last1)&lt;/code&gt; and &lt;code&gt;[first2, last2)&lt;/code&gt; using three-way comparison and produces a result of the strongest applicable comparison category type.</source>
          <target state="translated">Лексикографически сравнивает два диапазона &lt;code&gt;[first1, last1)&lt;/code&gt; и &lt;code&gt;[first2, last2)&lt;/code&gt; с использованием трехстороннего сравнения и выдает результат наиболее сильного применимого типа категории сравнения.</target>
        </trans-unit>
        <trans-unit id="67a093b5f3afa1ec9d50b3d089465752e5b76f7f" translate="yes" xml:space="preserve">
          <source>Library Fundamentals TS</source>
          <target state="translated">Библиотечные основы ТС</target>
        </trans-unit>
        <trans-unit id="6b5e123be926567d010847ac064936336ad593ea" translate="yes" xml:space="preserve">
          <source>Library Fundamentals TS v2</source>
          <target state="translated">Библиотечные основы TS v2</target>
        </trans-unit>
        <trans-unit id="e2667d1d4071efd5b07b3f89a3f29b6be4e37f9e" translate="yes" xml:space="preserve">
          <source>Library feature-test macros</source>
          <target state="translated">Библиотечные функционально-тестовые макросы</target>
        </trans-unit>
        <trans-unit id="d181f5a9fb0d9e7127fc14e913193f77a0078f2d" translate="yes" xml:space="preserve">
          <source>Library feature-test macros (C++20)</source>
          <target state="translated">Библиотечные функционально-тестовые макросы (C++20)</target>
        </trans-unit>
        <trans-unit id="1ca30982b1bbf9fa6a34598686144ccd0b751409" translate="yes" xml:space="preserve">
          <source>Library features</source>
          <target state="translated">Особенности библиотеки</target>
        </trans-unit>
        <trans-unit id="09e12a24dc663d40201c5b3eab12424fb6edc742" translate="yes" xml:space="preserve">
          <source>Library support</source>
          <target state="translated">Библиотечное обслуживание</target>
        </trans-unit>
        <trans-unit id="08957d8442d6c53a0376743b1046564066c5beb9" translate="yes" xml:space="preserve">
          <source>Library types</source>
          <target state="translated">Типы библиотек</target>
        </trans-unit>
        <trans-unit id="541a37e25273e2d6d7d8ea77a193f781a3f90323" translate="yes" xml:space="preserve">
          <source>Library-wide</source>
          <target state="translated">Library-wide</target>
        </trans-unit>
        <trans-unit id="e791557e003ef45d34d52d1fde8fc7381122402d" translate="yes" xml:space="preserve">
          <source>Library-wide definitions</source>
          <target state="translated">Библиотечные определения</target>
        </trans-unit>
        <trans-unit id="8d05a85e0ee31a873e2f15997f3ffa7b057cefff" translate="yes" xml:space="preserve">
          <source>Licensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.</source>
          <target state="translated">Лицензия Creative Commons Attribution-ShareAlike Unported License v3.0.</target>
        </trans-unit>
        <trans-unit id="8d33f31baff91c27917dcfcd7222cc394cee13fd" translate="yes" xml:space="preserve">
          <source>Lifetime</source>
          <target state="translated">Lifetime</target>
        </trans-unit>
        <trans-unit id="fcab1aea1859e79acfdb16f5548fc5e8f346103c" translate="yes" xml:space="preserve">
          <source>Lifetime management overhead: pImpl (as well as OO factory) place the implementation object on the heap, which imposes significant runtime overhead at construction and destruction. This may be partially offset by custom allocators, since allocation size for pImpl (but not OO factory) is known at compile time.</source>
          <target state="translated">Управление сроком службы накладных расходов:pImpl (а также OO завод)размещает объект реализации на куче,что накладывает значительные накладные расходы при строительстве и разрушении.Это может быть частично компенсировано пользовательскими аллокаторами,так как размер аллокатора для pImpl (но не OO фабрика)известен во время компиляции.</target>
        </trans-unit>
        <trans-unit id="ce83a9e6e299b9deac4e3b17e7674a70743eba46" translate="yes" xml:space="preserve">
          <source>Lifetime of a &lt;a href=&quot;reference&quot;&gt;reference&lt;/a&gt; is exactly its storage duration.</source>
          <target state="translated">Время жизни &lt;a href=&quot;reference&quot;&gt;ссылки&lt;/a&gt; в точности соответствует продолжительности ее хранения.</target>
        </trans-unit>
        <trans-unit id="aa1c59351fb4e3a194ae9298bc34b5f343ca9a77" translate="yes" xml:space="preserve">
          <source>Lifetime of a member of a &lt;a href=&quot;union&quot;&gt;union&lt;/a&gt; begins when that member is made active</source>
          <target state="translated">Срок жизни члена &lt;a href=&quot;union&quot;&gt;профсоюза&lt;/a&gt; начинается, когда этот член становится активным</target>
        </trans-unit>
        <trans-unit id="bfaa411f86a50808036a50484d4f059e87177ec8" translate="yes" xml:space="preserve">
          <source>Lifetime of a temporary</source>
          <target state="translated">Время жизни временного</target>
        </trans-unit>
        <trans-unit id="b06c7b4fe84d7d3832ffd284a1596b4ff15c6d2b" translate="yes" xml:space="preserve">
          <source>Lifetime of an object is equal to or is nested within the lifetime of its storage, see &lt;a href=&quot;storage_duration&quot;&gt;storage duration&lt;/a&gt;.</source>
          <target state="translated">Срок службы объекта равен или вложен в срок его хранения, см. &lt;a href=&quot;storage_duration&quot;&gt;Продолжительность хранения&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="51e3b5d26b2a87dc97df037e11067c891e623490" translate="yes" xml:space="preserve">
          <source>Lifetimes of member objects and base subobjects begin and end following &lt;a href=&quot;constructor#Initialization_order&quot;&gt;class initialization order&lt;/a&gt;.</source>
          <target state="translated">Время жизни объектов-членов и базовых подобъектов начинается и заканчивается в следующем &lt;a href=&quot;constructor#Initialization_order&quot;&gt;порядке инициализации класса&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1332053b53e77535f34952c3e92e4a52a83ed6ef" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;&lt;a href=&quot;make_shared&quot;&gt;std::make_shared&lt;/a&gt;&lt;/code&gt;, this function typically performs only one allocation, and places both the &lt;code&gt;T&lt;/code&gt; object and the control block in the allocated memory block (the standard recommends but does not require this, all known implementations do this). A copy of &lt;code&gt;alloc&lt;/code&gt; is stored as part of the control block so that it can be used to deallocate it once both shared and weak reference counts reach zero.</source>
          <target state="translated">Как и &lt;code&gt;&lt;a href=&quot;make_shared&quot;&gt;std::make_shared&lt;/a&gt;&lt;/code&gt; , эта функция обычно выполняет только одно выделение и помещает как объект &lt;code&gt;T&lt;/code&gt; ,так и блок управления в выделенный блок памяти (стандарт рекомендует, но не требует этого, все известные реализации делают это). Копия &lt;code&gt;alloc&lt;/code&gt; хранится как часть управляющего блока, так что ее можно использовать для ее освобождения, когда количество общих и слабых ссылок достигнет нуля.</target>
        </trans-unit>
        <trans-unit id="fb0723405e133e81ce558a6f85e371f734d41854" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;&lt;a href=&quot;shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&lt;/code&gt;, a typical implementation of &lt;code&gt;weak_ptr&lt;/code&gt; stores two pointers:</source>
          <target state="translated">Как и &lt;code&gt;&lt;a href=&quot;shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&lt;/code&gt; , типичная реализация &lt;code&gt;weak_ptr&lt;/code&gt; хранит два указателя:</target>
        </trans-unit>
        <trans-unit id="70ffb5a0c307ec17f33f7f7369b3ef25ef794da7" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;char&lt;/code&gt; and &lt;code&gt;unsigned char&lt;/code&gt;, it can be used to access raw memory occupied by other objects (&lt;a href=&quot;../language/objects&quot;&gt;object representation&lt;/a&gt;), but unlike those types, it is not a character type and is not an arithmetic type. A byte is only a collection of bits, and the only operators defined for it are the bitwise ones.</source>
          <target state="translated">Как и &lt;code&gt;char&lt;/code&gt; и &lt;code&gt;unsigned char&lt;/code&gt; , его можно использовать для доступа к необработанной памяти, занятой другими объектами ( &lt;a href=&quot;../language/objects&quot;&gt;представление объектов&lt;/a&gt; ), но в отличие от этих типов, это не символьный тип и не арифметический тип. Байт - это только набор битов, и для него определены только битовые операторы.</target>
        </trans-unit>
        <trans-unit id="a0e7b4ff05a45ce92b546002d8fc2f4e84c6ea38" translate="yes" xml:space="preserve">
          <source>Like a hard link, a symbolic link allows a file to have multiple logical names. The presence of a hard link guarantees the existence of a file, even after the original name has been removed. A symbolic link provides no such assurance; in fact, the file named by the &lt;code&gt;target&lt;/code&gt; argument need not exist when the link is created. A symbolic link can cross file system boundaries.</source>
          <target state="translated">Как и жесткая ссылка, символическая ссылка позволяет файлу иметь несколько логических имен. Наличие жесткой ссылки гарантирует существование файла даже после удаления исходного имени. Символическая ссылка не дает такой гарантии; фактически, файл, названный &lt;code&gt;target&lt;/code&gt; аргументом, не должен существовать при создании ссылки. Символическая ссылка может пересекать границы файловой системы.</target>
        </trans-unit>
        <trans-unit id="8cc2c9ed197596f0e8ca54e8df4a5e29bc4bbde4" translate="yes" xml:space="preserve">
          <source>Like a reference, a structured binding is an alias to an existing object. Unlike a reference, the type of a structured binding does not have to be a reference type.</source>
          <target state="translated">Как и ссылка,структурированная привязка-это псевдоним к существующему объекту.В отличие от ссылки,тип структурированной привязки не обязательно должен быть типом ссылки.</target>
        </trans-unit>
        <trans-unit id="067a7fb7f8bc363ab9405d15f7f42f52d531593e" translate="yes" xml:space="preserve">
          <source>Like all other functions from &lt;a href=&quot;../../header/cctype&quot;&gt;&lt;code&gt;&amp;lt;cctype&amp;gt;&lt;/code&gt;&lt;/a&gt;, the behavior of &lt;code&gt;std::isalnum&lt;/code&gt; is undefined if the argument's value is neither representable as &lt;code&gt;unsigned char&lt;/code&gt; nor equal to &lt;code&gt;EOF&lt;/code&gt;. To use these functions safely with plain &lt;code&gt;char&lt;/code&gt;s (or &lt;code&gt;signed char&lt;/code&gt;s), the argument should first be converted to &lt;code&gt;unsigned char&lt;/code&gt;:</source>
          <target state="translated">Как и все другие функции из &lt;a href=&quot;../../header/cctype&quot;&gt; &lt;code&gt;&amp;lt;cctype&amp;gt;&lt;/code&gt; &lt;/a&gt; , поведение &lt;code&gt;std::isalnum&lt;/code&gt; не определено, если значение аргумента не может быть представлено как &lt;code&gt;unsigned char&lt;/code&gt; и равно &lt;code&gt;EOF&lt;/code&gt; . Чтобы безопасно использовать эти функции с обычными &lt;code&gt;char&lt;/code&gt; (или &lt;code&gt;signed char&lt;/code&gt; ), аргумент должен быть сначала преобразован в &lt;code&gt;unsigned char&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="1f83c5788970238d8dce9e165785dcf50fdef59c" translate="yes" xml:space="preserve">
          <source>Like all other functions from &lt;a href=&quot;../../header/cctype&quot;&gt;&lt;code&gt;&amp;lt;cctype&amp;gt;&lt;/code&gt;&lt;/a&gt;, the behavior of &lt;code&gt;std::isalpha&lt;/code&gt; is undefined if the argument's value is neither representable as &lt;code&gt;unsigned char&lt;/code&gt; nor equal to &lt;code&gt;EOF&lt;/code&gt;. To use these functions safely with plain &lt;code&gt;char&lt;/code&gt;s (or &lt;code&gt;signed char&lt;/code&gt;s), the argument should first be converted to &lt;code&gt;unsigned char&lt;/code&gt;:</source>
          <target state="translated">Как и все другие функции из &lt;a href=&quot;../../header/cctype&quot;&gt; &lt;code&gt;&amp;lt;cctype&amp;gt;&lt;/code&gt; &lt;/a&gt; , поведение &lt;code&gt;std::isalpha&lt;/code&gt; не определено, если значение аргумента не может быть представлено как &lt;code&gt;unsigned char&lt;/code&gt; и равно &lt;code&gt;EOF&lt;/code&gt; . Чтобы безопасно использовать эти функции с обычными &lt;code&gt;char&lt;/code&gt; (или &lt;code&gt;signed char&lt;/code&gt; ), аргумент должен быть сначала преобразован в &lt;code&gt;unsigned char&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="02650958be1dd2146a9becd39224244d381efde4" translate="yes" xml:space="preserve">
          <source>Like all other functions from &lt;a href=&quot;../../header/cctype&quot;&gt;&lt;code&gt;&amp;lt;cctype&amp;gt;&lt;/code&gt;&lt;/a&gt;, the behavior of &lt;code&gt;std::isblank&lt;/code&gt; is undefined if the argument's value is neither representable as &lt;code&gt;unsigned char&lt;/code&gt; nor equal to &lt;code&gt;EOF&lt;/code&gt;. To use these functions safely with plain &lt;code&gt;char&lt;/code&gt;s (or &lt;code&gt;signed char&lt;/code&gt;s), the argument should first be converted to &lt;code&gt;unsigned char&lt;/code&gt;:</source>
          <target state="translated">Как и все другие функции из &lt;a href=&quot;../../header/cctype&quot;&gt; &lt;code&gt;&amp;lt;cctype&amp;gt;&lt;/code&gt; &lt;/a&gt; , поведение &lt;code&gt;std::isblank&lt;/code&gt; не определено, если значение аргумента не может быть представлено как &lt;code&gt;unsigned char&lt;/code&gt; и равно &lt;code&gt;EOF&lt;/code&gt; . Чтобы безопасно использовать эти функции с обычными &lt;code&gt;char&lt;/code&gt; (или &lt;code&gt;signed char&lt;/code&gt; ), аргумент должен быть сначала преобразован в &lt;code&gt;unsigned char&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="0340210c2f7ce33d0ebf0f6392410ac886edccce" translate="yes" xml:space="preserve">
          <source>Like all other functions from &lt;a href=&quot;../../header/cctype&quot;&gt;&lt;code&gt;&amp;lt;cctype&amp;gt;&lt;/code&gt;&lt;/a&gt;, the behavior of &lt;code&gt;std::iscntrl&lt;/code&gt; is undefined if the argument's value is neither representable as &lt;code&gt;unsigned char&lt;/code&gt; nor equal to &lt;code&gt;EOF&lt;/code&gt;. To use these functions safely with plain &lt;code&gt;char&lt;/code&gt;s (or &lt;code&gt;signed char&lt;/code&gt;s), the argument should first be converted to &lt;code&gt;unsigned char&lt;/code&gt;:</source>
          <target state="translated">Как и все другие функции из &lt;a href=&quot;../../header/cctype&quot;&gt; &lt;code&gt;&amp;lt;cctype&amp;gt;&lt;/code&gt; &lt;/a&gt; , поведение &lt;code&gt;std::iscntrl&lt;/code&gt; не определено, если значение аргумента не может быть представлено как &lt;code&gt;unsigned char&lt;/code&gt; и равно &lt;code&gt;EOF&lt;/code&gt; . Чтобы безопасно использовать эти функции с обычными &lt;code&gt;char&lt;/code&gt; (или &lt;code&gt;signed char&lt;/code&gt; ), аргумент должен быть сначала преобразован в &lt;code&gt;unsigned char&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="2dd464fdeabb59a1a5f506eb7ecd2b3abdac9a22" translate="yes" xml:space="preserve">
          <source>Like all other functions from &lt;a href=&quot;../../header/cctype&quot;&gt;&lt;code&gt;&amp;lt;cctype&amp;gt;&lt;/code&gt;&lt;/a&gt;, the behavior of &lt;code&gt;std::isdigit&lt;/code&gt; is undefined if the argument's value is neither representable as &lt;code&gt;unsigned char&lt;/code&gt; nor equal to &lt;code&gt;EOF&lt;/code&gt;. To use these functions safely with plain &lt;code&gt;char&lt;/code&gt;s (or &lt;code&gt;signed char&lt;/code&gt;s), the argument should first be converted to &lt;code&gt;unsigned char&lt;/code&gt;:</source>
          <target state="translated">Как и все другие функции из &lt;a href=&quot;../../header/cctype&quot;&gt; &lt;code&gt;&amp;lt;cctype&amp;gt;&lt;/code&gt; &lt;/a&gt; , поведение &lt;code&gt;std::isdigit&lt;/code&gt; не определено, если значение аргумента не может быть представлено как &lt;code&gt;unsigned char&lt;/code&gt; и равно &lt;code&gt;EOF&lt;/code&gt; . Чтобы безопасно использовать эти функции с обычными &lt;code&gt;char&lt;/code&gt; (или &lt;code&gt;signed char&lt;/code&gt; ), аргумент должен быть сначала преобразован в &lt;code&gt;unsigned char&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="7dda039594fc889284a6c61532474b72fdbd1f81" translate="yes" xml:space="preserve">
          <source>Like all other functions from &lt;a href=&quot;../../header/cctype&quot;&gt;&lt;code&gt;&amp;lt;cctype&amp;gt;&lt;/code&gt;&lt;/a&gt;, the behavior of &lt;code&gt;std::isgraph&lt;/code&gt; is undefined if the argument's value is neither representable as &lt;code&gt;unsigned char&lt;/code&gt; nor equal to &lt;code&gt;EOF&lt;/code&gt;. To use these functions safely with plain &lt;code&gt;char&lt;/code&gt;s (or &lt;code&gt;signed char&lt;/code&gt;s), the argument should first be converted to &lt;code&gt;unsigned char&lt;/code&gt;:</source>
          <target state="translated">Как и все другие функции из &lt;a href=&quot;../../header/cctype&quot;&gt; &lt;code&gt;&amp;lt;cctype&amp;gt;&lt;/code&gt; &lt;/a&gt; , поведение &lt;code&gt;std::isgraph&lt;/code&gt; не определено, если значение аргумента не может быть представлено как &lt;code&gt;unsigned char&lt;/code&gt; и равно &lt;code&gt;EOF&lt;/code&gt; . Чтобы безопасно использовать эти функции с обычными &lt;code&gt;char&lt;/code&gt; (или &lt;code&gt;signed char&lt;/code&gt; ), аргумент должен быть сначала преобразован в &lt;code&gt;unsigned char&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="e6241819c2a6db7cd413177f3e7eb9b7229e9f1f" translate="yes" xml:space="preserve">
          <source>Like all other functions from &lt;a href=&quot;../../header/cctype&quot;&gt;&lt;code&gt;&amp;lt;cctype&amp;gt;&lt;/code&gt;&lt;/a&gt;, the behavior of &lt;code&gt;std::islower&lt;/code&gt; is undefined if the argument's value is neither representable as &lt;code&gt;unsigned char&lt;/code&gt; nor equal to &lt;code&gt;EOF&lt;/code&gt;. To use these functions safely with plain &lt;code&gt;char&lt;/code&gt;s (or &lt;code&gt;signed char&lt;/code&gt;s), the argument should first be converted to &lt;code&gt;unsigned char&lt;/code&gt;:</source>
          <target state="translated">Как и все другие функции из &lt;a href=&quot;../../header/cctype&quot;&gt; &lt;code&gt;&amp;lt;cctype&amp;gt;&lt;/code&gt; &lt;/a&gt; , поведение &lt;code&gt;std::islower&lt;/code&gt; не определено, если значение аргумента не может быть представлено как &lt;code&gt;unsigned char&lt;/code&gt; и равно &lt;code&gt;EOF&lt;/code&gt; . Чтобы безопасно использовать эти функции с обычными &lt;code&gt;char&lt;/code&gt; (или &lt;code&gt;signed char&lt;/code&gt; ), аргумент должен быть сначала преобразован в &lt;code&gt;unsigned char&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="7ccc47ed9fcd07aec0dbec6222f54d9803cf130c" translate="yes" xml:space="preserve">
          <source>Like all other functions from &lt;a href=&quot;../../header/cctype&quot;&gt;&lt;code&gt;&amp;lt;cctype&amp;gt;&lt;/code&gt;&lt;/a&gt;, the behavior of &lt;code&gt;std::isprint&lt;/code&gt; is undefined if the argument's value is neither representable as &lt;code&gt;unsigned char&lt;/code&gt; nor equal to &lt;code&gt;EOF&lt;/code&gt;. To use these functions safely with plain &lt;code&gt;char&lt;/code&gt;s (or &lt;code&gt;signed char&lt;/code&gt;s), the argument should first be converted to &lt;code&gt;unsigned char&lt;/code&gt;:</source>
          <target state="translated">Как и все другие функции из &lt;a href=&quot;../../header/cctype&quot;&gt; &lt;code&gt;&amp;lt;cctype&amp;gt;&lt;/code&gt; &lt;/a&gt; , поведение &lt;code&gt;std::isprint&lt;/code&gt; не определено, если значение аргумента не может быть представлено как &lt;code&gt;unsigned char&lt;/code&gt; и равно &lt;code&gt;EOF&lt;/code&gt; . Чтобы безопасно использовать эти функции с обычными &lt;code&gt;char&lt;/code&gt; (или &lt;code&gt;signed char&lt;/code&gt; ), аргумент должен быть сначала преобразован в &lt;code&gt;unsigned char&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="411696ff296361e95ad61309fa87bc8c79319127" translate="yes" xml:space="preserve">
          <source>Like all other functions from &lt;a href=&quot;../../header/cctype&quot;&gt;&lt;code&gt;&amp;lt;cctype&amp;gt;&lt;/code&gt;&lt;/a&gt;, the behavior of &lt;code&gt;std::ispunct&lt;/code&gt; is undefined if the argument's value is neither representable as &lt;code&gt;unsigned char&lt;/code&gt; nor equal to &lt;code&gt;EOF&lt;/code&gt;. To use these functions safely with plain &lt;code&gt;char&lt;/code&gt;s (or &lt;code&gt;signed char&lt;/code&gt;s), the argument should first be converted to &lt;code&gt;unsigned char&lt;/code&gt;:</source>
          <target state="translated">Как и все другие функции из &lt;a href=&quot;../../header/cctype&quot;&gt; &lt;code&gt;&amp;lt;cctype&amp;gt;&lt;/code&gt; &lt;/a&gt; , поведение &lt;code&gt;std::ispunct&lt;/code&gt; не определено, если значение аргумента не может быть представлено как &lt;code&gt;unsigned char&lt;/code&gt; и равно &lt;code&gt;EOF&lt;/code&gt; . Чтобы безопасно использовать эти функции с обычными &lt;code&gt;char&lt;/code&gt; (или &lt;code&gt;signed char&lt;/code&gt; ), аргумент должен быть сначала преобразован в &lt;code&gt;unsigned char&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="a2bc2b3471f087c8466e836925f03b3603558f3f" translate="yes" xml:space="preserve">
          <source>Like all other functions from &lt;a href=&quot;../../header/cctype&quot;&gt;&lt;code&gt;&amp;lt;cctype&amp;gt;&lt;/code&gt;&lt;/a&gt;, the behavior of &lt;code&gt;std::isspace&lt;/code&gt; is undefined if the argument's value is neither representable as &lt;code&gt;unsigned char&lt;/code&gt; nor equal to &lt;code&gt;EOF&lt;/code&gt;. To use these functions safely with plain &lt;code&gt;char&lt;/code&gt;s (or &lt;code&gt;signed char&lt;/code&gt;s), the argument should first be converted to &lt;code&gt;unsigned char&lt;/code&gt;:</source>
          <target state="translated">Как и все другие функции из &lt;a href=&quot;../../header/cctype&quot;&gt; &lt;code&gt;&amp;lt;cctype&amp;gt;&lt;/code&gt; &lt;/a&gt; , поведение &lt;code&gt;std::isspace&lt;/code&gt; не определено, если значение аргумента не может быть представлено как &lt;code&gt;unsigned char&lt;/code&gt; и равно &lt;code&gt;EOF&lt;/code&gt; . Чтобы безопасно использовать эти функции с обычными &lt;code&gt;char&lt;/code&gt; (или &lt;code&gt;signed char&lt;/code&gt; ), аргумент должен быть сначала преобразован в &lt;code&gt;unsigned char&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="395c220484621ffd75d1964f6130a00ce4ddab49" translate="yes" xml:space="preserve">
          <source>Like all other functions from &lt;a href=&quot;../../header/cctype&quot;&gt;&lt;code&gt;&amp;lt;cctype&amp;gt;&lt;/code&gt;&lt;/a&gt;, the behavior of &lt;code&gt;std::isupper&lt;/code&gt; is undefined if the argument's value is neither representable as &lt;code&gt;unsigned char&lt;/code&gt; nor equal to &lt;code&gt;EOF&lt;/code&gt;. To use these functions safely with plain &lt;code&gt;char&lt;/code&gt;s (or &lt;code&gt;signed char&lt;/code&gt;s), the argument should first be converted to &lt;code&gt;unsigned char&lt;/code&gt;:</source>
          <target state="translated">Как и все другие функции из &lt;a href=&quot;../../header/cctype&quot;&gt; &lt;code&gt;&amp;lt;cctype&amp;gt;&lt;/code&gt; &lt;/a&gt; , поведение &lt;code&gt;std::isupper&lt;/code&gt; не определено, если значение аргумента не может быть представлено как &lt;code&gt;unsigned char&lt;/code&gt; и равно &lt;code&gt;EOF&lt;/code&gt; . Чтобы безопасно использовать эти функции с обычными &lt;code&gt;char&lt;/code&gt; (или &lt;code&gt;signed char&lt;/code&gt; ), аргумент должен быть сначала преобразован в &lt;code&gt;unsigned char&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="cb2c7e80bd4929826427f19fc7c64d9e9ff5d018" translate="yes" xml:space="preserve">
          <source>Like all other functions from &lt;a href=&quot;../../header/cctype&quot;&gt;&lt;code&gt;&amp;lt;cctype&amp;gt;&lt;/code&gt;&lt;/a&gt;, the behavior of &lt;code&gt;std::isxdigit&lt;/code&gt; is undefined if the argument's value is neither representable as &lt;code&gt;unsigned char&lt;/code&gt; nor equal to &lt;code&gt;EOF&lt;/code&gt;. To use these functions safely with plain &lt;code&gt;char&lt;/code&gt;s (or &lt;code&gt;signed char&lt;/code&gt;s), the argument should first be converted to &lt;code&gt;unsigned char&lt;/code&gt;:</source>
          <target state="translated">Как и все другие функции из &lt;a href=&quot;../../header/cctype&quot;&gt; &lt;code&gt;&amp;lt;cctype&amp;gt;&lt;/code&gt; &lt;/a&gt; , поведение &lt;code&gt;std::isxdigit&lt;/code&gt; не определено, если значение аргумента не может быть представлено как &lt;code&gt;unsigned char&lt;/code&gt; и равно &lt;code&gt;EOF&lt;/code&gt; . Чтобы безопасно использовать эти функции с обычными &lt;code&gt;char&lt;/code&gt; (или &lt;code&gt;signed char&lt;/code&gt; ), аргумент должен быть сначала преобразован в &lt;code&gt;unsigned char&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="ff408cea9c029c8dab319c58cbd0c36f0d4045fe" translate="yes" xml:space="preserve">
          <source>Like all other functions from &lt;a href=&quot;../../header/cctype&quot;&gt;&lt;code&gt;&amp;lt;cctype&amp;gt;&lt;/code&gt;&lt;/a&gt;, the behavior of &lt;code&gt;std::tolower&lt;/code&gt; is undefined if the argument's value is neither representable as &lt;code&gt;unsigned char&lt;/code&gt; nor equal to &lt;code&gt;EOF&lt;/code&gt;. To use these functions safely with plain &lt;code&gt;char&lt;/code&gt;s (or &lt;code&gt;signed char&lt;/code&gt;s), the argument should first be converted to &lt;code&gt;unsigned char&lt;/code&gt;:</source>
          <target state="translated">Как и все другие функции из &lt;a href=&quot;../../header/cctype&quot;&gt; &lt;code&gt;&amp;lt;cctype&amp;gt;&lt;/code&gt; &lt;/a&gt; , поведение &lt;code&gt;std::tolower&lt;/code&gt; не определено, если значение аргумента не может быть представлено как &lt;code&gt;unsigned char&lt;/code&gt; и равно &lt;code&gt;EOF&lt;/code&gt; . Чтобы безопасно использовать эти функции с обычными &lt;code&gt;char&lt;/code&gt; (или &lt;code&gt;signed char&lt;/code&gt; ), аргумент должен быть сначала преобразован в &lt;code&gt;unsigned char&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="c3e68c1eaec4b4e283489b5c67ab059adf32011f" translate="yes" xml:space="preserve">
          <source>Like all other functions from &lt;a href=&quot;../../header/cctype&quot;&gt;&lt;code&gt;&amp;lt;cctype&amp;gt;&lt;/code&gt;&lt;/a&gt;, the behavior of &lt;code&gt;std::toupper&lt;/code&gt; is undefined if the argument's value is neither representable as &lt;code&gt;unsigned char&lt;/code&gt; nor equal to &lt;code&gt;EOF&lt;/code&gt;. To use these functions safely with plain &lt;code&gt;char&lt;/code&gt;s (or &lt;code&gt;signed char&lt;/code&gt;s), the argument should first be converted to &lt;code&gt;unsigned char&lt;/code&gt;:</source>
          <target state="translated">Как и все другие функции из &lt;a href=&quot;../../header/cctype&quot;&gt; &lt;code&gt;&amp;lt;cctype&amp;gt;&lt;/code&gt; &lt;/a&gt; , поведение &lt;code&gt;std::toupper&lt;/code&gt; не определено, если значение аргумента не может быть представлено как &lt;code&gt;unsigned char&lt;/code&gt; и равно &lt;code&gt;EOF&lt;/code&gt; . Чтобы безопасно использовать эти функции с обычными &lt;code&gt;char&lt;/code&gt; (или &lt;code&gt;signed char&lt;/code&gt; ), аргумент должен быть сначала преобразован в &lt;code&gt;unsigned char&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="277019aab45ab5f935fb6e92f8f5746e4c25daa8" translate="yes" xml:space="preserve">
          <source>Like any template declaration, an alias template can only be declared at class scope or namespace scope.</source>
          <target state="translated">Как и любое объявление шаблона,шаблон псевдонима может быть объявлен только в области видимости класса или в области видимости пространства имен.</target>
        </trans-unit>
        <trans-unit id="ca47c4b0c6ddc7644bfef7979156876bc8446bd5" translate="yes" xml:space="preserve">
          <source>Like class prvalues, array prvalues convert to xvalues by &lt;a href=&quot;implicit_cast#Temporary_materialization&quot;&gt;temporary materialization&lt;/a&gt; when evaluated.</source>
          <target state="translated">Как и значения класса prval, значения массива преобразуются в значения x посредством &lt;a href=&quot;implicit_cast#Temporary_materialization&quot;&gt;временной материализации&lt;/a&gt; при оценке.</target>
        </trans-unit>
        <trans-unit id="0347742fa713e18c4beb5d442719947cba761472" translate="yes" xml:space="preserve">
          <source>Like language references, constness is shallow for &lt;code&gt;atomic_ref&lt;/code&gt; - it is possible to modify the referenced value through a &lt;code&gt;const&lt;/code&gt;&lt;code&gt;atomic_ref&lt;/code&gt; object.</source>
          <target state="translated">Как и в случае со ссылками на язык, constness невелика для &lt;code&gt;atomic_ref&lt;/code&gt; - можно изменить указанное значение через объект &lt;code&gt;const&lt;/code&gt; &lt;code&gt;atomic_ref&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7a2c18bbb70b4975f8de70e1d0f45d8ebbaac4a9" translate="yes" xml:space="preserve">
          <source>Like other classes, class templates have an injected-class-name. The injected-class-name can be used as a template-name or a type-name.</source>
          <target state="translated">Как и другие классы,шаблоны классов имеют инжекторное имя класса.Имя инжектируемого класса может быть использовано в качестве имени шаблона или имени типа.</target>
        </trans-unit>
        <trans-unit id="7a6e90ef50926b9b7275d89708dfc849a157f540" translate="yes" xml:space="preserve">
          <source>Like other members, injected-class-names are inherited. In the presence of private or protected inheritance, the injected-class-name of an indirect base class might end up being inaccessible in a derived class.</source>
          <target state="translated">Как и другие члены,имена инъекционных классов наследуются.При наличии закрытого или защищенного наследования инъектированные имена классов косвенного базисного класса могут оказаться недоступными в производном классе.</target>
        </trans-unit>
        <trans-unit id="f6f1d175f286f2d5f07aef906a2e3bc134ab3f16" translate="yes" xml:space="preserve">
          <source>Like other streambuf classes, &lt;code&gt;std::basic_syncbuf&lt;/code&gt; is normally only accessed through the corresponding stream, &lt;a href=&quot;basic_osyncstream&quot;&gt;&lt;code&gt;std::osyncstream&lt;/code&gt;&lt;/a&gt;, not directly.</source>
          <target state="translated">Как и другие классы streambuf, &lt;code&gt;std::basic_syncbuf&lt;/code&gt; обычно доступен только через соответствующий поток &lt;a href=&quot;basic_osyncstream&quot;&gt; &lt;code&gt;std::osyncstream&lt;/code&gt; &lt;/a&gt; , а не напрямую.</target>
        </trans-unit>
        <trans-unit id="bd2d3509f0729065894ca6384a10fe999c819fe7" translate="yes" xml:space="preserve">
          <source>Likewise, function-try-block of the &lt;a href=&quot;main_function&quot;&gt;main() function&lt;/a&gt; does not catch the exceptions thrown from the constructors and destructors of &lt;a href=&quot;storage_duration&quot;&gt;static&lt;/a&gt; objects (except for the constructors of function-local statics).</source>
          <target state="translated">Аналогично, функция-try-block функции &lt;a href=&quot;main_function&quot;&gt;main ()&lt;/a&gt; не перехватывает исключения, генерируемые конструкторами и деструкторами &lt;a href=&quot;storage_duration&quot;&gt;статических&lt;/a&gt; объектов (за исключением конструкторов функционально-локальной статики).</target>
        </trans-unit>
        <trans-unit id="ab6af34df8147c6b3a0969fea41e698ff89bc410" translate="yes" xml:space="preserve">
          <source>Likewise, the 16-digit string &lt;code&gt;9007199254740993&lt;/code&gt; does not survive text-&amp;gt;double-&amp;gt;text roundtrip, becoming &lt;code&gt;9007199254740992&lt;/code&gt;: the 64-bit IEEE 754 type double guarantees this roundtrip only for 15 decimal digits.</source>
          <target state="translated">Аналогично, 16-значная строка &lt;code&gt;9007199254740993&lt;/code&gt; не сохраняется в цикле text- &amp;gt; double-&amp;gt; text roundtrip, превращаясь в &lt;code&gt;9007199254740992&lt;/code&gt; : 64-разрядный тип IEEE 754 double гарантирует этот цикл туда и обратно только для 15 десятичных цифр.</target>
        </trans-unit>
        <trans-unit id="28d080135c0996528be81f65c40eb528ec429cbe" translate="yes" xml:space="preserve">
          <source>Likewise, the inequality operator is typically implemented in terms of &lt;code&gt;operator==&lt;/code&gt;:</source>
          <target state="translated">Аналогично, оператор неравенства обычно реализуется в терминах &lt;code&gt;operator==&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="9d8bc984a49e87697786db72d2563a91679f73c6" translate="yes" xml:space="preserve">
          <source>Limits of floating point types</source>
          <target state="translated">Пределы типов с плавающей точкой</target>
        </trans-unit>
        <trans-unit id="68c715c0e0c866487981ad26eed257940f23ee03" translate="yes" xml:space="preserve">
          <source>Limits of integer types</source>
          <target state="translated">Пределы целочисленных типов</target>
        </trans-unit>
        <trans-unit id="15ff631ff253c68efadbbe156b2dbda674f664c6" translate="yes" xml:space="preserve">
          <source>Limits of other integer types</source>
          <target state="translated">Пределы других целочисленных типов</target>
        </trans-unit>
        <trans-unit id="af502f2b37eea07ed9083c7daf40f34553f6fccd" translate="yes" xml:space="preserve">
          <source>Linear</source>
          <target state="translated">Linear</target>
        </trans-unit>
        <trans-unit id="d663d9eccd3592374d465e1969446c41d66c8a96" translate="yes" xml:space="preserve">
          <source>Linear in &lt;code&gt;&lt;a href=&quot;../iterator/distance&quot;&gt;std::distance&lt;/a&gt;(first,last)&lt;/code&gt;.</source>
          <target state="translated">Линейный в &lt;code&gt;&lt;a href=&quot;../iterator/distance&quot;&gt;std::distance&lt;/a&gt;(first,last)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5ee30c8aafcff81625dfef38a2177634d49c1eed" translate="yes" xml:space="preserve">
          <source>Linear in &lt;code&gt;count&lt;/code&gt;.</source>
          <target state="translated">Линейный по &lt;code&gt;count&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="dd2f30444814df4f83cd7413476e4b0fd89443cb" translate="yes" xml:space="preserve">
          <source>Linear in &lt;code&gt;n&lt;/code&gt;.</source>
          <target state="translated">Линейный по &lt;code&gt;n&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b7bbb05054f896c8a5f8b773dacbef4017beeded" translate="yes" xml:space="preserve">
          <source>Linear in &lt;code&gt;rcount&lt;/code&gt;.</source>
          <target state="translated">Линейный в &lt;code&gt;rcount&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1a961c5a00bbaee66696314d28a309bcc73bf9a0" translate="yes" xml:space="preserve">
          <source>Linear in size of the container.</source>
          <target state="translated">Линейный размер контейнера.</target>
        </trans-unit>
        <trans-unit id="47e94bceda1e4178a1dbb6f4ff6dcd1259ef8d37" translate="yes" xml:space="preserve">
          <source>Linear in the difference between the current size and &lt;code&gt;count&lt;/code&gt;.</source>
          <target state="translated">Линейная разница между текущим размером и &lt;code&gt;count&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c0ba0eb11bb040b4fe1f3679f71ea7620138693f" translate="yes" xml:space="preserve">
          <source>Linear in the difference between the current size and &lt;code&gt;count&lt;/code&gt;. Additional complexity possible due to list traversal to reach the first element to erase/the end position to insert.</source>
          <target state="translated">Линейная разница между текущим размером и &lt;code&gt;count&lt;/code&gt; . Дополнительная сложность возможна из-за обхода списка для достижения первого удаляемого элемента / конечной позиции для вставки.</target>
        </trans-unit>
        <trans-unit id="baaef666d55118a41c333430f0a97ec79990b1cb" translate="yes" xml:space="preserve">
          <source>Linear in the difference between the current size and &lt;code&gt;count&lt;/code&gt;. Additional complexity possible due to reallocation if capacity is less than &lt;code&gt;count&lt;/code&gt;.</source>
          <target state="translated">Линейная разница между текущим размером и &lt;code&gt;count&lt;/code&gt; . Дополнительная сложность возможна из-за перераспределения, если емкость меньше, чем &lt;code&gt;count&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="61fc9e3129ac082fe227ebd6080874ba58bf854d" translate="yes" xml:space="preserve">
          <source>Linear in the distance between &lt;code&gt;first&lt;/code&gt; and &lt;code&gt;last&lt;/code&gt;.</source>
          <target state="translated">Линейный на расстоянии между &lt;code&gt;first&lt;/code&gt; и &lt;code&gt;last&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5120f8d10505c4347d98aef0265d53cc5b14811e" translate="yes" xml:space="preserve">
          <source>Linear in the distance between &lt;code&gt;pos&lt;/code&gt; and end of the container.</source>
          <target state="translated">Линейный по расстоянию между &lt;code&gt;pos&lt;/code&gt; и концом контейнера.</target>
        </trans-unit>
        <trans-unit id="e00c01e410d339ff063543b8db6c55336a7eb35e" translate="yes" xml:space="preserve">
          <source>Linear in the length of the underlying character sequence.</source>
          <target state="translated">Линейная длина последовательности символов.</target>
        </trans-unit>
        <trans-unit id="daef509e105270395b1f8ee55aa3597f2d32c098" translate="yes" xml:space="preserve">
          <source>Linear in the lesser of the distances between &lt;code&gt;pos&lt;/code&gt; and either of the ends of the container.</source>
          <target state="translated">Линейный по меньшему из расстояний между &lt;code&gt;pos&lt;/code&gt; и любым из концов контейнера.</target>
        </trans-unit>
        <trans-unit id="f9e42220f12301a5a104063cb40d7e22a40f20c0" translate="yes" xml:space="preserve">
          <source>Linear in the number of sub-matches.</source>
          <target state="translated">Линейный по количеству субматчей.</target>
        </trans-unit>
        <trans-unit id="c5ddd8aed976c4d32ca29544bac6a99205868cfe" translate="yes" xml:space="preserve">
          <source>Linear in the size of the bucket &lt;code&gt;n&lt;/code&gt;.</source>
          <target state="translated">Линейный по размеру ковш &lt;code&gt;n&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="320de548d4905427a59ae55bf65f8ed7ea812394" translate="yes" xml:space="preserve">
          <source>Linear in the size of the container adaptor.</source>
          <target state="translated">Линейный размер адаптера для контейнера.</target>
        </trans-unit>
        <trans-unit id="58a053e51fd6f7ec6e1969382ddb0c636fee3c4d" translate="yes" xml:space="preserve">
          <source>Linear in the size of the container, i.e., the number of elements.</source>
          <target state="translated">Линейный размер контейнера,т.е.количество элементов.</target>
        </trans-unit>
        <trans-unit id="9e42d6edd168f206c67991730a76dd86d7fd13ac" translate="yes" xml:space="preserve">
          <source>Linear in the size of the container.</source>
          <target state="translated">Линейный размер контейнера.</target>
        </trans-unit>
        <trans-unit id="d098f3f0fdf3fe294ef9db9875c8f3ba39748928" translate="yes" xml:space="preserve">
          <source>Linear in the size of the numeric array.</source>
          <target state="translated">Линейный по размеру числового массива.</target>
        </trans-unit>
        <trans-unit id="39f6b3d4e54ae45f608cfae2731dfa12f1a130f4" translate="yes" xml:space="preserve">
          <source>Linear in the size of the string</source>
          <target state="translated">Линейный размер строки</target>
        </trans-unit>
        <trans-unit id="d34b2255c2e995e02e21a14b3a4851ac5882aba2" translate="yes" xml:space="preserve">
          <source>Linear in the size of the string, although existing implementations operate in constant time.</source>
          <target state="translated">Линейный размер строки,хотя существующие реализации работают в постоянном времени.</target>
        </trans-unit>
        <trans-unit id="2f4742601a668a97966b78c0c256da0091787c9f" translate="yes" xml:space="preserve">
          <source>Linear in the size of the string.</source>
          <target state="translated">Линейный размер строки.</target>
        </trans-unit>
        <trans-unit id="d504b6d983be80c3da82ac77491361a106de8dd6" translate="yes" xml:space="preserve">
          <source>Linear in the size of the strings.</source>
          <target state="translated">Линейный размер струн.</target>
        </trans-unit>
        <trans-unit id="c67c2146b42dc18f8ac7602e8c37c39d0d1a88f4" translate="yes" xml:space="preserve">
          <source>Linear in the size of the views.</source>
          <target state="translated">Линейный по размеру вид.</target>
        </trans-unit>
        <trans-unit id="353a3b1efc1c504f1131664f1c9da4bb8225908a" translate="yes" xml:space="preserve">
          <source>Linear interpolation</source>
          <target state="translated">Линейная интерполяция</target>
        </trans-unit>
        <trans-unit id="2eb90c9fc96f9c707142bd2df66bbb959c695585" translate="yes" xml:space="preserve">
          <source>Linear.</source>
          <target state="translated">Linear.</target>
        </trans-unit>
        <trans-unit id="bd2f979972802ff1d01a873d1a8e13284150ffe8" translate="yes" xml:space="preserve">
          <source>Linear: the number of calls to the destructor of T is the same as the number of elements erased, the assignment operator of T is called the number of times equal to the number of elements in the vector after the erased elements.</source>
          <target state="translated">Линейный:количество обращений к деструктору T равно количеству стертых элементов,оператор присваивания T называется количеством раз,равным количеству элементов в векторе после стертых элементов.</target>
        </trans-unit>
        <trans-unit id="4ee1b770c5760a0a6cf5b30f78ae338fd8baa73a" translate="yes" xml:space="preserve">
          <source>Linear: the number of calls to the destructor of T is the same as the number of elements erased, the number of calls to the assignment operator of T is no more than the lesser of the number of elements before the erased elements and the number of elements after the erased elements.</source>
          <target state="translated">Линейный:количество обращений к деструктору T равно количеству стертых элементов,количество обращений к оператору присваивания T не больше,чем меньшее количество элементов до стертых элементов и количество элементов после стертых элементов.</target>
        </trans-unit>
        <trans-unit id="8f51211d5882b7b1d7f5bacb8c562304994eec22" translate="yes" xml:space="preserve">
          <source>Link has been severed</source>
          <target state="translated">Ссылка была разорвана</target>
        </trans-unit>
        <trans-unit id="b27dc31140950c016978fcb4c144b7b2d3cbc47c" translate="yes" xml:space="preserve">
          <source>Linkage</source>
          <target state="translated">Linkage</target>
        </trans-unit>
        <trans-unit id="55ecf80e85b7d19bbe4096b1255534070ebf5b46" translate="yes" xml:space="preserve">
          <source>Linkage specification</source>
          <target state="translated">Спецификация связи</target>
        </trans-unit>
        <trans-unit id="44da027a7d61f0dfd1784a90d378229ab9cfb71e" translate="yes" xml:space="preserve">
          <source>List initialization is performed in the following situations:</source>
          <target state="translated">Инициализация списка выполняется в следующих ситуациях:</target>
        </trans-unit>
        <trans-unit id="7094bd5e681efcce9038e6d995bf2d060fc85079" translate="yes" xml:space="preserve">
          <source>List operations</source>
          <target state="translated">Перечисленные операции</target>
        </trans-unit>
        <trans-unit id="00863cc84a92ec056c8a5802850de22482d7a20f" translate="yes" xml:space="preserve">
          <source>List-initialization</source>
          <target state="translated">List-initialization</target>
        </trans-unit>
        <trans-unit id="54a3b43bb92df32d485a7093803f903e36c579fd" translate="yes" xml:space="preserve">
          <source>Lists the exceptions that a function might directly or indirectly throw.</source>
          <target state="translated">Перечисляет исключения,которые функция может прямо или косвенно бросить.</target>
        </trans-unit>
        <trans-unit id="88f0bff43cf350627f446597dc555fcbb10deccb" translate="yes" xml:space="preserve">
          <source>Literal constant expression</source>
          <target state="translated">Буквальное постоянное выражение</target>
        </trans-unit>
        <trans-unit id="a7c8f6e22e4cf98d224c691373983e8bb4a14cd5" translate="yes" xml:space="preserve">
          <source>Literal operators</source>
          <target state="translated">Буквальные операторы</target>
        </trans-unit>
        <trans-unit id="793829f43d6401d24000acee9b0edc1896c5c837" translate="yes" xml:space="preserve">
          <source>Literal type that extends string literals:</source>
          <target state="translated">Буквенный тип,который расширяет строковые литералы:</target>
        </trans-unit>
        <trans-unit id="2304c62e8f7798124c1dc52b057e7762191e4112" translate="yes" xml:space="preserve">
          <source>LiteralType</source>
          <target state="translated">LiteralType</target>
        </trans-unit>
        <trans-unit id="c7ba7dcf662374aafe652b03d75cb8f6024519d9" translate="yes" xml:space="preserve">
          <source>Literals</source>
          <target state="translated">Literals</target>
        </trans-unit>
        <trans-unit id="b85acf10db8d6b17de3526edb467be756ff163a4" translate="yes" xml:space="preserve">
          <source>Literals are the tokens of a C++ program that represent constant values embedded in the source code.</source>
          <target state="translated">Буквы-это лексемы программы на Си++,представляющие собой константные значения,встроенные в исходный код.</target>
        </trans-unit>
        <trans-unit id="207b5847d31f577b34ce5944ce67366ee6a9f77d" translate="yes" xml:space="preserve">
          <source>Loads the data from locations, defined by &lt;code&gt;vlist&lt;/code&gt;,, converts them to wide string equivalents and writes the results to a variety of sinks.</source>
          <target state="translated">Загружает данные из местоположений, определенных &lt;code&gt;vlist&lt;/code&gt; , преобразует их в широкие строковые эквиваленты и записывает результаты в различные приемники.</target>
        </trans-unit>
        <trans-unit id="306845665660271f5edceb9cf305119d107a9b6d" translate="yes" xml:space="preserve">
          <source>Loads the data from the given locations, converts them to character string equivalents and writes the results to a variety of sinks.</source>
          <target state="translated">Загружает данные из заданных мест,преобразует их в эквиваленты символьных строк и записывает результаты в различные поглотители.</target>
        </trans-unit>
        <trans-unit id="b98547f12140b861f02fc92da40524e3b426e7b6" translate="yes" xml:space="preserve">
          <source>Loads the data from the given locations, converts them to wide string equivalents and writes the results to a variety of sinks.</source>
          <target state="translated">Загружает данные из заданных мест,преобразует их в широкие строковые эквиваленты и записывает результаты в различные раковины.</target>
        </trans-unit>
        <trans-unit id="7bea89bc2ce48c930dc7395bbdbef3f7216a1506" translate="yes" xml:space="preserve">
          <source>Loads the data from the locations, defined by &lt;code&gt;vlist&lt;/code&gt;, converts them to character string equivalents and writes the results to a variety of sinks.</source>
          <target state="translated">Загружает данные из местоположений, определенных &lt;code&gt;vlist&lt;/code&gt; , преобразует их в эквиваленты символьных строк и записывает результаты в различные приемники.</target>
        </trans-unit>
        <trans-unit id="3efe7e57b877b99e83abee299be618072a6caad5" translate="yes" xml:space="preserve">
          <source>Loads the execution context &lt;code&gt;env&lt;/code&gt; saved by a previous call to &lt;code&gt;&lt;a href=&quot;setjmp&quot;&gt;setjmp&lt;/a&gt;&lt;/code&gt;. This function does not return. Control is transferred to the call site of the macro &lt;code&gt;&lt;a href=&quot;setjmp&quot;&gt;setjmp&lt;/a&gt;&lt;/code&gt; that set up &lt;code&gt;env&lt;/code&gt;. That &lt;code&gt;&lt;a href=&quot;setjmp&quot;&gt;setjmp&lt;/a&gt;&lt;/code&gt; then returns the value, passed as the &lt;code&gt;status&lt;/code&gt;.</source>
          <target state="translated">Загружает &lt;code&gt;env&lt;/code&gt; контекста выполнения, сохраненный предыдущим вызовом &lt;code&gt;&lt;a href=&quot;setjmp&quot;&gt;setjmp&lt;/a&gt;&lt;/code&gt; . Эта функция не возвращает. Управление передается на сайт вызова макроса &lt;code&gt;&lt;a href=&quot;setjmp&quot;&gt;setjmp&lt;/a&gt;&lt;/code&gt; , который устанавливает &lt;code&gt;env&lt;/code&gt; . Затем этот &lt;code&gt;&lt;a href=&quot;setjmp&quot;&gt;setjmp&lt;/a&gt;&lt;/code&gt; возвращает значение, переданное как &lt;code&gt;status&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f3f3766d936a084f7885a89b74bff964f93af54b" translate="yes" xml:space="preserve">
          <source>Local classes</source>
          <target state="translated">местные классы</target>
        </trans-unit>
        <trans-unit id="4aae5a412706d04afcfacf152e9fb5c7502dd7b9" translate="yes" xml:space="preserve">
          <source>Local classes cannot define &lt;a href=&quot;friend&quot;&gt;friend functions&lt;/a&gt; inside the class definition</source>
          <target state="translated">Локальные классы не могут определять &lt;a href=&quot;friend&quot;&gt;дружественные функции&lt;/a&gt; внутри определения класса</target>
        </trans-unit>
        <trans-unit id="537fd817534a9d16da0662978fafc67944474038" translate="yes" xml:space="preserve">
          <source>Local classes cannot have &lt;a href=&quot;friend#Template_friends&quot;&gt;friend templates&lt;/a&gt;</source>
          <target state="translated">У локальных классов не может быть &lt;a href=&quot;friend#Template_friends&quot;&gt;шаблонов друзей&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="25934a3163283e7417a8ccb81533f8c6db7c89fa" translate="yes" xml:space="preserve">
          <source>Local classes other than &lt;a href=&quot;lambda&quot;&gt;closure types&lt;/a&gt;(since C++14) cannot have member templates</source>
          <target state="translated">Локальные классы, кроме &lt;a href=&quot;lambda&quot;&gt;типов закрытия&lt;/a&gt; (начиная с C ++ 14), не могут иметь шаблонов элементов</target>
        </trans-unit>
        <trans-unit id="0b64c37e179f49fcbc2cadc0fb2d42cd79c4fdd9" translate="yes" xml:space="preserve">
          <source>Local monetary numeric formatting parameters</source>
          <target state="translated">Локальные параметры денежно-цифрового форматирования</target>
        </trans-unit>
        <trans-unit id="9ac34b8bf1cd18f9b339db9b7d7bfbe70142b73d" translate="yes" xml:space="preserve">
          <source>Local variables are not allowed in default arguments  unless used in unevaluated context(since C++14):</source>
          <target state="translated">Локальные переменные не допускаются в аргументах по умолчанию,если только они не используются в неоцененном контексте (начиная с C++14):</target>
        </trans-unit>
        <trans-unit id="8970f0e691a0a23a47517698017c997507efd496" translate="yes" xml:space="preserve">
          <source>Locale</source>
          <target state="translated">Locale</target>
        </trans-unit>
        <trans-unit id="6c3524ddb4dbd6e55cdddfdad87f91e490674af0" translate="yes" xml:space="preserve">
          <source>Locale-independent unicode conversion facets</source>
          <target state="translated">Локально-независимые грани преобразования юникода</target>
        </trans-unit>
        <trans-unit id="9e57020d7e664c3bc1f3a56095434c59ad016632" translate="yes" xml:space="preserve">
          <source>Locale-specific facet categories</source>
          <target state="translated">Категории локальных граней</target>
        </trans-unit>
        <trans-unit id="a222060e32289bf6910ac4a07a10733be500bd99" translate="yes" xml:space="preserve">
          <source>Locales</source>
          <target state="translated">Locales</target>
        </trans-unit>
        <trans-unit id="3a0f6d00aea8688a68e6b8a0597983687499bda4" translate="yes" xml:space="preserve">
          <source>Locales and facets</source>
          <target state="translated">Локали и аспекты</target>
        </trans-unit>
        <trans-unit id="d2ba11823ed33de4da4e31b0eebe19082e18127d" translate="yes" xml:space="preserve">
          <source>Localization library</source>
          <target state="translated">Библиотека локализации</target>
        </trans-unit>
        <trans-unit id="c07f512f68e601c83a418f3dad591a2645430943" translate="yes" xml:space="preserve">
          <source>Localization utilities</source>
          <target state="translated">Локализационные утилиты</target>
        </trans-unit>
        <trans-unit id="dc8dbeb23836a69ebeafc222497183282817c913" translate="yes" xml:space="preserve">
          <source>Localizations</source>
          <target state="translated">Localizations</target>
        </trans-unit>
        <trans-unit id="d71da9d4cb1a804d59d89b1825a9880a0942d7ab" translate="yes" xml:space="preserve">
          <source>Locates the first character in the character array &lt;code&gt;[beg, end)&lt;/code&gt; that does not satisfy the classification mask &lt;code&gt;m&lt;/code&gt;, that is, the first character &lt;code&gt;c&lt;/code&gt; such that &lt;code&gt;table()[(unsigned char)c] &amp;amp; m&lt;/code&gt; would return &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">Находит первый символ в массиве символов &lt;code&gt;[beg, end)&lt;/code&gt; , который не удовлетворяет маске классификации &lt;code&gt;m&lt;/code&gt; , то есть первый символ &lt;code&gt;c&lt;/code&gt; такой, что &lt;code&gt;table()[(unsigned char)c] &amp;amp; m&lt;/code&gt; возвращает &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="357cdcce80e8002095e52999c10401e1457183fd" translate="yes" xml:space="preserve">
          <source>Locates the first character in the character array &lt;code&gt;[beg, end)&lt;/code&gt; that satisfies the classification mask &lt;code&gt;m&lt;/code&gt;, that is, the first character &lt;code&gt;c&lt;/code&gt; such that &lt;code&gt;table()[(unsigned char) c] &amp;amp; m&lt;/code&gt; would return &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">Находит первый символ в массиве символов &lt;code&gt;[beg, end)&lt;/code&gt; который удовлетворяет маске классификации &lt;code&gt;m&lt;/code&gt; , то есть первый символ &lt;code&gt;c&lt;/code&gt; такой, что &lt;code&gt;table()[(unsigned char) c] &amp;amp; m&lt;/code&gt; возвращает &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="31e9f816605eb9508f673fc28eb1f9b42210f44e" translate="yes" xml:space="preserve">
          <source>Locates the first occurrence of wide character &lt;code&gt;ch&lt;/code&gt; in the initial &lt;code&gt;count&lt;/code&gt; wide characters of the wide character array pointed to by &lt;code&gt;ptr&lt;/code&gt;.</source>
          <target state="translated">Находит первое вхождение широких символов &lt;code&gt;ch&lt;/code&gt; в начальном &lt;code&gt;count&lt;/code&gt; широких символов в массив широких символов , на которую указывает &lt;code&gt;ptr&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="14fbab694e4672e756dc11003aa78ae825a8fc71" translate="yes" xml:space="preserve">
          <source>Lock freedom</source>
          <target state="translated">Свобода блокировки</target>
        </trans-unit>
        <trans-unit id="ee78ba28c676d3bfd6bbd0d0ac4dc1adaedada08" translate="yes" xml:space="preserve">
          <source>Lockable</source>
          <target state="translated">Lockable</target>
        </trans-unit>
        <trans-unit id="d1d6079f6b5f44c82f4e240cfc0156faa4fc5b60" translate="yes" xml:space="preserve">
          <source>Locking</source>
          <target state="translated">Locking</target>
        </trans-unit>
        <trans-unit id="89301c33d91c56fca51d422389610ec0003774ae" translate="yes" xml:space="preserve">
          <source>Locks the associated mutex in shared mode. Effectively calls &lt;code&gt;mutex()-&amp;gt;lock_shared()&lt;/code&gt;.</source>
          <target state="translated">Блокирует связанный мьютекс в режиме совместного использования. Эффективно вызывает &lt;code&gt;mutex()-&amp;gt;lock_shared()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0e4c226b5fbb2b899205fcb0ab7e1977150757b6" translate="yes" xml:space="preserve">
          <source>Locks the associated mutex. Effectively calls &lt;code&gt;mutex()-&amp;gt;lock()&lt;/code&gt;.</source>
          <target state="translated">Блокирует связанный мьютекс. Эффективно вызывает &lt;code&gt;mutex()-&amp;gt;lock()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bdeef0016a6ddc17439dd3082bbe560063b4040e" translate="yes" xml:space="preserve">
          <source>Locks the given &lt;a href=&quot;../named_req/lockable&quot;&gt;Lockable&lt;/a&gt; objects &lt;code&gt;lock1&lt;/code&gt;, &lt;code&gt;lock2&lt;/code&gt;, &lt;code&gt;...&lt;/code&gt;, &lt;code&gt;lockn&lt;/code&gt; using a deadlock avoidance algorithm to avoid deadlock.</source>
          <target state="translated">Замки данный &lt;a href=&quot;../named_req/lockable&quot;&gt;Lockable&lt;/a&gt; объекты &lt;code&gt;lock1&lt;/code&gt; , &lt;code&gt;lock2&lt;/code&gt; , &lt;code&gt;...&lt;/code&gt; , &lt;code&gt;lockn&lt;/code&gt; с помощью алгоритма избегания тупикового , чтобы избежать тупика.</target>
        </trans-unit>
        <trans-unit id="07953af6eaa80da971053dc23bda5d5c2a2e5a5c" translate="yes" xml:space="preserve">
          <source>Locks the mutex. If another thread has already locked the mutex, a call to &lt;code&gt;lock&lt;/code&gt; will block execution until the lock is acquired.</source>
          <target state="translated">Блокирует мьютекс. Если другой поток уже заблокировал мьютекс, вызов &lt;code&gt;lock&lt;/code&gt; заблокирует выполнение, пока блокировка не будет получена.</target>
        </trans-unit>
        <trans-unit id="9b108190806dbf643b285b25368b99531689061b" translate="yes" xml:space="preserve">
          <source>Logarithmic in the size of the container in general, but amortized constant if the new element is inserted just before &lt;code&gt;hint&lt;/code&gt;.</source>
          <target state="translated">Логарифмический размер контейнера в целом, но амортизированная константа, если новый элемент вставляется непосредственно перед &lt;code&gt;hint&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e9067460d73ae825ba6714018f7615492aa47865" translate="yes" xml:space="preserve">
          <source>Logarithmic in the size of the container plus linear in the number of the elements found.</source>
          <target state="translated">Логарифмический по размеру контейнера плюс линейный по количеству найденных элементов.</target>
        </trans-unit>
        <trans-unit id="5e5188bc43c4d9b70c9cf627bba80326dacae4d7" translate="yes" xml:space="preserve">
          <source>Logarithmic in the size of the container.</source>
          <target state="translated">Логарифмический по размеру контейнера.</target>
        </trans-unit>
        <trans-unit id="73b7130da3c78f3712cf8aced2ce52c3b3bb17f4" translate="yes" xml:space="preserve">
          <source>Logarithmic number of comparisons plus the complexity of &lt;code&gt;Container::emplace_back&lt;/code&gt;.</source>
          <target state="translated">Логарифмическое число сравнений плюс сложность &lt;code&gt;Container::emplace_back&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="58b1b6caf7fe5a42c100cf12c95e7a3c6866c24d" translate="yes" xml:space="preserve">
          <source>Logarithmic number of comparisons plus the complexity of &lt;code&gt;Container::pop_back&lt;/code&gt;.</source>
          <target state="translated">Логарифмическое количество сравнений плюс сложность &lt;code&gt;Container::pop_back&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1c3cf65301fe13dbcf804ac556fa2da47b162343" translate="yes" xml:space="preserve">
          <source>Logarithmic number of comparisons plus the complexity of &lt;code&gt;Container::push_back&lt;/code&gt;.</source>
          <target state="translated">Логарифмическое количество сравнений плюс сложность &lt;code&gt;Container::push_back&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c5d5c5fb2a8798e4f962780fba63386de96b07b6" translate="yes" xml:space="preserve">
          <source>Logical AND</source>
          <target state="translated">Логический И</target>
        </trans-unit>
        <trans-unit id="e9b0aefdf7ed2c67abbfc572bbc5743979450674" translate="yes" xml:space="preserve">
          <source>Logical OR</source>
          <target state="translated">Логическое ИЛИ</target>
        </trans-unit>
        <trans-unit id="ab411408fbd29ad68b53700b2e7826c03e6703f0" translate="yes" xml:space="preserve">
          <source>Logical operations</source>
          <target state="translated">Логические операции</target>
        </trans-unit>
        <trans-unit id="4654c9b2b818a080fc48b5bd5a47f40691d6eb0d" translate="yes" xml:space="preserve">
          <source>Logical operator type traits</source>
          <target state="translated">Логические признаки типа оператора</target>
        </trans-unit>
        <trans-unit id="a5da835bb3de6e8855950138a28dea23921e5aaa" translate="yes" xml:space="preserve">
          <source>Logical operators</source>
          <target state="translated">Логические операторы</target>
        </trans-unit>
        <trans-unit id="7015ab4fc4ea24735dbe884238cc1b54bf915eca" translate="yes" xml:space="preserve">
          <source>Lookup</source>
          <target state="translated">Lookup</target>
        </trans-unit>
        <trans-unit id="9df7d9cefaf31feb4f6b24d79bad8d071fcb03de" translate="yes" xml:space="preserve">
          <source>Lookup rules</source>
          <target state="translated">правила поиска</target>
        </trans-unit>
        <trans-unit id="cab4a2117d8f9c8117e26920652c300561edd076" translate="yes" xml:space="preserve">
          <source>Low level memory management</source>
          <target state="translated">Управление памятью низкого уровня</target>
        </trans-unit>
        <trans-unit id="bd3740e01fb4f11441f7e643cef68b3881c9e618" translate="yes" xml:space="preserve">
          <source>Low-level memory management utilities</source>
          <target state="translated">Утилиты управления памятью низкого уровня</target>
        </trans-unit>
        <trans-unit id="3769a18de297ff08768c9476ca9be5fa9f7cb3ea" translate="yes" xml:space="preserve">
          <source>Lowercase version of &lt;code&gt;ch&lt;/code&gt; or unmodified &lt;code&gt;ch&lt;/code&gt; if no lowercase version is listed in the current C locale.</source>
          <target state="translated">Строчная версия &lt;code&gt;ch&lt;/code&gt; или немодифицированная &lt;code&gt;ch&lt;/code&gt; , если в текущей локали C нет строчной версии.</target>
        </trans-unit>
        <trans-unit id="befc5b417a1ee8ed446b10341ff5e771b51fffbc" translate="yes" xml:space="preserve">
          <source>Lvalue and rvalue references</source>
          <target state="translated">Ссылки на ценность и стоимость</target>
        </trans-unit>
        <trans-unit id="3327811a28b6dc92897c7bd726a6ee4cb5edaa0f" translate="yes" xml:space="preserve">
          <source>Lvalue references</source>
          <target state="translated">Ссылки на ценности</target>
        </trans-unit>
        <trans-unit id="a213708ed1a0d723b5b6a805c274cf9bff5d1146" translate="yes" xml:space="preserve">
          <source>Lvalue references can be used to alias an existing object (optionally with different cv-qualification):</source>
          <target state="translated">Ссылки на значение могут быть использованы для псевдонима существующего объекта (опционально с различной cv-квалификацией):</target>
        </trans-unit>
        <trans-unit id="08f35d31d723fb0a56bd4bcfd14b0053b8eb609f" translate="yes" xml:space="preserve">
          <source>Lvalue to rvalue conversion</source>
          <target state="translated">Преобразование стоимости в стоимость</target>
        </trans-unit>
        <trans-unit id="43e928199e03709bb299f1077cb46f632464d9e4" translate="yes" xml:space="preserve">
          <source>Lvalue to rvalue conversion (e.g. function call to a function that takes a value).</source>
          <target state="translated">Преобразование значения в значение (например,вызов функции,которая принимает значение).</target>
        </trans-unit>
        <trans-unit id="41bc669bb535a7e446d5f35250e723d4b222463a" translate="yes" xml:space="preserve">
          <source>M, ..., a</source>
          <target state="translated">М,...</target>
        </trans-unit>
        <trans-unit id="5de4e334f963f744c52ad0d25e83c8a8e959ae90" translate="yes" xml:space="preserve">
          <source>M, ..., b</source>
          <target state="translated">М,...,б</target>
        </trans-unit>
        <trans-unit id="a06f1b8f093c7cc11caa03599d07adbc807edfe6" translate="yes" xml:space="preserve">
          <source>MACRON</source>
          <target state="translated">MACRON</target>
        </trans-unit>
        <trans-unit id="850947f3d010de98ad370f2f73bc49ca69c2b7c5" translate="yes" xml:space="preserve">
          <source>MATH_ERRNO</source>
          <target state="translated">MATH_ERRNO</target>
        </trans-unit>
        <trans-unit id="74b7d4ceae8b4d3f14a2b48ce0dd4a45027ad623" translate="yes" xml:space="preserve">
          <source>MATH_ERRNO, MATH_ERREXCEPT, math_errhandling</source>
          <target state="translated">MATH_ERRNO,MATH_ERREXCEPT,math_errrhandling</target>
        </trans-unit>
        <trans-unit id="0b26b4988457eebaa5d41abd9af85e69645b9b63" translate="yes" xml:space="preserve">
          <source>MB_CUR_MAX</source>
          <target state="translated">MB_CUR_MAX</target>
        </trans-unit>
        <trans-unit id="6bfcb6f4e22f270971b8066d4c18f2a3c153409a" translate="yes" xml:space="preserve">
          <source>MB_LEN_MAX</source>
          <target state="translated">MB_LEN_MAX</target>
        </trans-unit>
        <trans-unit id="a3de7ac6ae1a36761d2bb7db4fb097d2d59a0d43" translate="yes" xml:space="preserve">
          <source>MIDDLE DOT - MASCULINE ORDINAL INDICATOR</source>
          <target state="translated">СРЕДНЯЯ ТОЧКА-МУЖСКОЙ ПОРЯДКОВЫЙ ИНДИКАТОР</target>
        </trans-unit>
        <trans-unit id="0beb871a186f42594bcfbcc8916c8146ec93832e" translate="yes" xml:space="preserve">
          <source>MOESI protocol</source>
          <target state="translated">протокол MOESI</target>
        </trans-unit>
        <trans-unit id="1240ae02c583b36398d148ddc49074ea0ee43ffd" translate="yes" xml:space="preserve">
          <source>MSVC function &lt;code&gt;&lt;a href=&quot;http://msdn.microsoft.com/en-us/library/e9b52ceh.aspx&quot;&gt;_control87()&lt;/a&gt;&lt;/code&gt; enables trapping of the floating-point exceptions, which generates a hardware exception, which can be converted to C++ exceptions with &lt;code&gt;&lt;a href=&quot;http://msdn.microsoft.com/en-us/library/5z4bw5h5.aspx&quot;&gt;_set_se_translator&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Функция MSVC &lt;code&gt;&lt;a href=&quot;http://msdn.microsoft.com/en-us/library/e9b52ceh.aspx&quot;&gt;_control87()&lt;/a&gt;&lt;/code&gt; позволяет перехватывать исключения с плавающей запятой, которые генерируют аппаратное исключение, которое можно преобразовать в исключения C ++ с помощью &lt;code&gt;&lt;a href=&quot;http://msdn.microsoft.com/en-us/library/5z4bw5h5.aspx&quot;&gt;_set_se_translator&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2d7ac97eaf33ec3cf9c03bd404689cfd6e8e46fe" translate="yes" xml:space="preserve">
          <source>MSVC function &lt;code&gt;&lt;a href=&quot;https://msdn.microsoft.com/en-us/library/e9b52ceh.aspx&quot;&gt;_control87()&lt;/a&gt;&lt;/code&gt; enables trapping of the floating-point exceptions, which generates a hardware exception, which can be converted to C++ exceptions with &lt;code&gt;&lt;a href=&quot;https://msdn.microsoft.com/en-us/library/5z4bw5h5.aspx&quot;&gt;_set_se_translator&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Функция MSVC &lt;code&gt;&lt;a href=&quot;https://msdn.microsoft.com/en-us/library/e9b52ceh.aspx&quot;&gt;_control87()&lt;/a&gt;&lt;/code&gt; включает перехват исключений с плавающей запятой, что создает аппаратное исключение, которое можно преобразовать в исключения C ++ с помощью &lt;code&gt;&lt;a href=&quot;https://msdn.microsoft.com/en-us/library/5z4bw5h5.aspx&quot;&gt;_set_se_translator&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b9d6fc761949b6e88739a8a2fe091585d2e12ec1" translate="yes" xml:space="preserve">
          <source>Macro (and function) that saves (and jumps) to an execution context</source>
          <target state="translated">Макро (и функция),которая сохраняет (и прыгает)в контекст выполнения</target>
        </trans-unit>
        <trans-unit id="54b23dc205b8e1437102e969e0df1e0a65dc7096" translate="yes" xml:space="preserve">
          <source>Macro Constants</source>
          <target state="translated">Макроконстанты</target>
        </trans-unit>
        <trans-unit id="fc1086b9f1dd6c6f26d36bd306a911dfb2aafce8" translate="yes" xml:space="preserve">
          <source>Macro constants</source>
          <target state="translated">Макроконстанты</target>
        </trans-unit>
        <trans-unit id="2f38b57c7b725c5c9e818e78c55ee7bbba8563a8" translate="yes" xml:space="preserve">
          <source>Macro containing the last error number</source>
          <target state="translated">Макро,содержащий последний номер ошибки</target>
        </trans-unit>
        <trans-unit id="5b3a11a44726526a8271fd69a51140ab465210aa" translate="yes" xml:space="preserve">
          <source>Macro name</source>
          <target state="translated">Название макроса</target>
        </trans-unit>
        <trans-unit id="899bd694d29ace1be956ab35177075021977560b" translate="yes" xml:space="preserve">
          <source>Macros</source>
          <target state="translated">Macros</target>
        </trans-unit>
        <trans-unit id="f314f8acf113225093359e0691186dc638458d3f" translate="yes" xml:space="preserve">
          <source>Macros for data types</source>
          <target state="translated">Макросы для типов данных</target>
        </trans-unit>
        <trans-unit id="ac71fe79e397b89328648d619d9408673bd60d02" translate="yes" xml:space="preserve">
          <source>Main classes</source>
          <target state="translated">Основные классы</target>
        </trans-unit>
        <trans-unit id="e4ac70ee360a262794e6e975e302e13279210903" translate="yes" xml:space="preserve">
          <source>Main function</source>
          <target state="translated">Главная задача</target>
        </trans-unit>
        <trans-unit id="99859e4cd4b9cce2f83ab42dc587698a3602b044" translate="yes" xml:space="preserve">
          <source>Maintenance overhead</source>
          <target state="translated">Техническое обслуживание накладных расходов</target>
        </trans-unit>
        <trans-unit id="b74e5fa51321d77a94a62fd68d1ad7b564b98a8d" translate="yes" xml:space="preserve">
          <source>Make &lt;a href=&quot;language/noexcept_spec&quot;&gt;exception specifications&lt;/a&gt; be part of the type system</source>
          <target state="translated">Сделать &lt;a href=&quot;language/noexcept_spec&quot;&gt;спецификации исключений&lt;/a&gt; частью системы типов</target>
        </trans-unit>
        <trans-unit id="6c08c5931ae98077d74c2fcd13d3f199daa1d289" translate="yes" xml:space="preserve">
          <source>Makes &lt;code&gt;f&lt;/code&gt; the new global &lt;code&gt;&lt;a href=&quot;unexpected_handler&quot;&gt;std::unexpected_handler&lt;/a&gt;&lt;/code&gt; and returns the previously installed &lt;code&gt;&lt;a href=&quot;unexpected_handler&quot;&gt;std::unexpected_handler&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Делает &lt;code&gt;f&lt;/code&gt; нового глобального &lt;code&gt;&lt;a href=&quot;unexpected_handler&quot;&gt;std::unexpected_handler&lt;/a&gt;&lt;/code&gt; и возвращает ранее установленный &lt;code&gt;&lt;a href=&quot;unexpected_handler&quot;&gt;std::unexpected_handler&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="65917fbeb3c6129587b44cf1b845bea5476e82d9" translate="yes" xml:space="preserve">
          <source>Makes &lt;code&gt;f&lt;/code&gt; the new global terminate handler function and returns the previously installed &lt;code&gt;&lt;a href=&quot;terminate_handler&quot;&gt;std::terminate_handler&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Делает &lt;code&gt;f&lt;/code&gt; новый глобальный обработчик прекращает функцию и возвращает ранее установленный &lt;code&gt;&lt;a href=&quot;terminate_handler&quot;&gt;std::terminate_handler&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b87d9c9486d3bcd72b7d0fe8b4ab7ceb6d812eec" translate="yes" xml:space="preserve">
          <source>Makes &lt;code&gt;new_p&lt;/code&gt; the new global new-handler function and returns the previously installed new-handler.</source>
          <target state="translated">Создает &lt;code&gt;new_p&lt;/code&gt; новую глобальную функцию нового обработчика и возвращает ранее установленный новый обработчик.</target>
        </trans-unit>
        <trans-unit id="ec8c940401a44da0f32dd9b030215fd134a7013f" translate="yes" xml:space="preserve">
          <source>Makes the most recently extracted character available again.</source>
          <target state="translated">Снова становится доступен самый последний извлеченный персонаж.</target>
        </trans-unit>
        <trans-unit id="96fe058e3a49999026b621bd5db51a5c913b4002" translate="yes" xml:space="preserve">
          <source>Making &lt;code&gt;&lt;a href=&quot;memory/owner_less&quot;&gt;std::owner_less&lt;/a&gt;&lt;/code&gt; more flexible (&lt;a href=&quot;memory/owner_less_void&quot;&gt;&lt;code&gt;std::owner_less&amp;lt;void&amp;gt;&lt;/code&gt;&lt;/a&gt;)</source>
          <target state="translated">Создание &lt;code&gt;&lt;a href=&quot;memory/owner_less&quot;&gt;std::owner_less&lt;/a&gt;&lt;/code&gt; более гибкий ( &lt;a href=&quot;memory/owner_less_void&quot;&gt; &lt;code&gt;std::owner_less&amp;lt;void&amp;gt;&lt;/code&gt; &lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="0c16d51463aefe216e81a0bd813cbff2e451ca3d" translate="yes" xml:space="preserve">
          <source>Making a virtual call to a pure virtual function from a constructor or the destructor of the abstract class is undefined behavior (regardless of whether it has a definition or not).</source>
          <target state="translated">Виртуальный вызов чистой виртуальной функции из конструктора или деструктора абстрактного класса является неопределенным поведением (независимо от того,имеет ли он определение или нет).</target>
        </trans-unit>
        <trans-unit id="6b8f8ae2577f5b38158790bbc573b214aa51aaaa" translate="yes" xml:space="preserve">
          <source>Making non-modifying sequence operations more robust (two-range overloads for &lt;code&gt;&lt;a href=&quot;algorithm/mismatch&quot;&gt;std::mismatch&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;algorithm/equal&quot;&gt;std::equal&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;algorithm/is_permutation&quot;&gt;std::is_permutation&lt;/a&gt;&lt;/code&gt;)</source>
          <target state="translated">Делая немодифицирующие последовательности операций более устойчивыми ( &lt;code&gt;&lt;a href=&quot;algorithm/is_permutation&quot;&gt;std::is_permutation&lt;/a&gt;&lt;/code&gt; перегрузки для &lt;code&gt;&lt;a href=&quot;algorithm/mismatch&quot;&gt;std::mismatch&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;algorithm/equal&quot;&gt;std::equal&lt;/a&gt;&lt;/code&gt; и std :: is_permutation )</target>
        </trans-unit>
        <trans-unit id="093902494fcace52d152c76c43c81becca401b50" translate="yes" xml:space="preserve">
          <source>Manages format flags.</source>
          <target state="translated">Управляет флагами формата.</target>
        </trans-unit>
        <trans-unit id="9b66e0ff5e969314f7b51fc9d7ca3a9cf4a3c17f" translate="yes" xml:space="preserve">
          <source>Manages the associated distribution parameter set.</source>
          <target state="translated">Управляет соответствующим набором параметров распределения.</target>
        </trans-unit>
        <trans-unit id="f62964b0cba3090f15f7c7c169b11e039cc6021f" translate="yes" xml:space="preserve">
          <source>Manages the associated stream buffer.</source>
          <target state="translated">Управляет ассоциированным буфером потока.</target>
        </trans-unit>
        <trans-unit id="aa5c32a8e138595d4766f2b368480e3dea10b879" translate="yes" xml:space="preserve">
          <source>Manages the contents of the underlying string object.</source>
          <target state="translated">Управляет содержимым объекта базовой строки.</target>
        </trans-unit>
        <trans-unit id="57d385100206298ef30b732a8a74a273e12fee69" translate="yes" xml:space="preserve">
          <source>Manages the file position state.</source>
          <target state="translated">Управляет состоянием позиции файла.</target>
        </trans-unit>
        <trans-unit id="4b0c6baba7868d541df5a1d3ef12c5d69bb016de" translate="yes" xml:space="preserve">
          <source>Manages the fill character used to pad the output conversions to the specified field width.</source>
          <target state="translated">Управляет символом заливки,используемым для подкладки выходных преобразований до заданной ширины поля.</target>
        </trans-unit>
        <trans-unit id="fc74e82d452fdfbe907a8fe1326c0b7d7df02587" translate="yes" xml:space="preserve">
          <source>Manages the floating-point rounding direction.</source>
          <target state="translated">Управляет направлением округления с плавающей точкой.</target>
        </trans-unit>
        <trans-unit id="0e6eaddb68bc270047cd5aa7f3b44d9637620333" translate="yes" xml:space="preserve">
          <source>Manages the maximum load factor (number of elements per bucket). The container automatically increases the number of buckets if the load factor exceeds this threshold.</source>
          <target state="translated">Управляет максимальным коэффициентом нагрузки (количество элементов на ковш).Контейнер автоматически увеличивает количество ковшей,если коэффициент нагрузки превышает этот порог.</target>
        </trans-unit>
        <trans-unit id="daa55aac6e6edc66679c2eb334f89dce6b539bde" translate="yes" xml:space="preserve">
          <source>Manages the minimum number of characters to generate on certain output operations and the maximum number of characters to generate on certain input operations.</source>
          <target state="translated">Управляет минимальным количеством символов для генерации на определенных операциях вывода и максимальным количеством символов для генерации на определенных операциях ввода.</target>
        </trans-unit>
        <trans-unit id="9111786b8ae1322461661a6b8d566d1d3675a5ed" translate="yes" xml:space="preserve">
          <source>Manages the precision (i.e. how many digits are generated) of floating point output performed by &lt;code&gt;&lt;a href=&quot;../../locale/num_put/put&quot;&gt;std::num_put::do_put&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Управляет точностью (т. &lt;code&gt;&lt;a href=&quot;../../locale/num_put/put&quot;&gt;std::num_put::do_put&lt;/a&gt;&lt;/code&gt; цифр генерируется) выходных данных с плавающей запятой, выполняемых std :: num_put :: do_put .</target>
        </trans-unit>
        <trans-unit id="887d2a92b7896a60b0850785e37481b9b04bbad8" translate="yes" xml:space="preserve">
          <source>Manages the status of the floating-point environment.</source>
          <target state="translated">Управляет состоянием среды с плавающей точкой.</target>
        </trans-unit>
        <trans-unit id="25d259883659a20164c7acf68339bc48d8362b03" translate="yes" xml:space="preserve">
          <source>Manages the tied stream. A tied stream is an output stream which is synchronized with the sequence controlled by the stream buffer (&lt;code&gt;&lt;a href=&quot;rdbuf&quot;&gt;rdbuf()&lt;/a&gt;&lt;/code&gt;), that is, &lt;code&gt;flush()&lt;/code&gt; is called on the tied stream before any input/output operation on &lt;code&gt;*this&lt;/code&gt;.</source>
          <target state="translated">Управляет связанным потоком. Связанный поток - это выходной поток, который синхронизируется с последовательностью, управляемой буфером потока ( &lt;code&gt;&lt;a href=&quot;rdbuf&quot;&gt;rdbuf()&lt;/a&gt;&lt;/code&gt; ), то есть &lt;code&gt;flush()&lt;/code&gt; вызывается в связанном потоке перед любой операцией ввода-вывода &lt;code&gt;*this&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e42c0bcf36c095bb9efb82dcb299ae099631d5a9" translate="yes" xml:space="preserve">
          <source>Manipulators</source>
          <target state="translated">Manipulators</target>
        </trans-unit>
        <trans-unit id="aa5986c6a9620c6b6e1856b7e2e600fe262ff7db" translate="yes" xml:space="preserve">
          <source>Manipulators are helper functions that make it possible to control input/output streams using &lt;code&gt;operator&amp;lt;&amp;lt;&lt;/code&gt; or &lt;code&gt;operator&amp;gt;&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">Манипуляторы - это вспомогательные функции, которые позволяют управлять потоками ввода / вывода с помощью &lt;code&gt;operator&amp;lt;&amp;lt;&lt;/code&gt; или &lt;code&gt;operator&amp;gt;&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0ce8863df9e71406305b90f9ea018e8bb9b2e809" translate="yes" xml:space="preserve">
          <source>Many classes in the standard library overload &lt;code&gt;operator()&lt;/code&gt; to be used as function objects.</source>
          <target state="translated">Многие классы в стандартной библиотеке &lt;code&gt;operator()&lt;/code&gt; перегрузки () используются в качестве объектов функций.</target>
        </trans-unit>
        <trans-unit id="0edc88ddffd739223885d2fe9cd8f80ed597ff78" translate="yes" xml:space="preserve">
          <source>Many compilers also implement the non-standard &lt;a href=&quot;impl&quot;&gt;&lt;code&gt;pragma&lt;/code&gt;&lt;/a&gt;&lt;code&gt;#pragma once&lt;/code&gt; with similar effects: it disables processing of a file if the same file (where file identity is determined in OS-specific way) has already been included.</source>
          <target state="translated">Многие компиляторы также реализуют нестандартную &lt;a href=&quot;impl&quot;&gt; &lt;code&gt;pragma&lt;/code&gt; &lt;/a&gt; &lt;code&gt;#pragma once&lt;/code&gt; с похожими эффектами: она отключает обработку файла, если тот же файл (где идентификация файла определяется для ОС) уже включен.</target>
        </trans-unit>
        <trans-unit id="6f405e95e132707ef26ac64e6bc3fe82236e30e2" translate="yes" xml:space="preserve">
          <source>Many compilers issue &quot;strict aliasing&quot; warnings in such cases, even though technically such constructs run afoul of something other than the paragraph commonly known as the &quot;strict aliasing rule&quot;.</source>
          <target state="translated">Многие компиляторы выдают предупреждения &quot;строгого наложения&quot; в таких случаях,даже если технически такие конструкции сталкиваются с чем-то отличным от абзаца,известного как &quot;правило строгого наложения&quot;.</target>
        </trans-unit>
        <trans-unit id="e9f40adecaac3afe40b8b2e36b992f8de08d6cdf" translate="yes" xml:space="preserve">
          <source>Many implementations also provide &lt;a href=&quot;https://en.wikipedia.org/wiki/Total_order#Strict_total_order&quot;&gt;strict total ordering&lt;/a&gt; of pointers of random origin, e.g. if they are implemented as addresses within continuous virtual address space. Those implementations that do not (e.g. where not all bits of the pointer are part of a memory address and have to be ignored for comparison, or an additional calculation is required or otherwise pointer and integer is not a 1 to 1 relationship), provide a specialization of &lt;code&gt;&lt;a href=&quot;../utility/functional/less&quot;&gt;std::less&lt;/a&gt;&lt;/code&gt; for pointers that has that guarantee. This makes it possible to use all pointers of random origin as keys in standard associative containers such as &lt;code&gt;&lt;a href=&quot;../container/set&quot;&gt;std::set&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../container/map&quot;&gt;std::map&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Многие реализации также обеспечивают &lt;a href=&quot;https://en.wikipedia.org/wiki/Total_order#Strict_total_order&quot;&gt;строгое полное упорядочение&lt;/a&gt; указателей случайного происхождения, например, если они реализованы как адреса в непрерывном виртуальном адресном пространстве. Те реализации, которые не (например, где не все биты указателя являются частью адреса памяти и должны игнорироваться для сравнения, или требуется дополнительное вычисление, или иначе указатель и целое число не являются отношением 1 к 1), обеспечивают специализация &lt;code&gt;&lt;a href=&quot;../utility/functional/less&quot;&gt;std::less&lt;/a&gt;&lt;/code&gt; для указателей с такой гарантией. Это позволяет использовать все указатели случайного происхождения в качестве ключей в стандартных ассоциативных контейнерах, таких как &lt;code&gt;&lt;a href=&quot;../container/set&quot;&gt;std::set&lt;/a&gt;&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;../container/map&quot;&gt;std::map&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6df4f43ab58f853f38804bd87ed02d4813b8bfca" translate="yes" xml:space="preserve">
          <source>Many implementations do not update the get area in &lt;code&gt;seekpos()&lt;/code&gt;, delegating to &lt;code&gt;&lt;a href=&quot;../basic_streambuf/underflow&quot;&gt;underflow()&lt;/a&gt;&lt;/code&gt; that is called by the next &lt;code&gt;&lt;a href=&quot;../basic_streambuf/sgetc&quot;&gt;sgetc()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Многие реализации не обновляют область попадают в &lt;code&gt;seekpos()&lt;/code&gt; , делегируя &lt;code&gt;&lt;a href=&quot;../basic_streambuf/underflow&quot;&gt;underflow()&lt;/a&gt;&lt;/code&gt; , который вызывается следующей &lt;code&gt;&lt;a href=&quot;../basic_streambuf/sgetc&quot;&gt;sgetc()&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f68fed89e22619f36d034e4ae6b5e591f90adb28" translate="yes" xml:space="preserve">
          <source>Many low-level OS APIs for directory traversal retrieve file attributes along with the next directory entry. The constructors and the non-const member functions of &lt;code&gt;directory_iterator&lt;/code&gt; store these attributes, if any, in the pointed-to &lt;a href=&quot;../directory_entry&quot;&gt;&lt;code&gt;directory_entry&lt;/code&gt;&lt;/a&gt; without calling &lt;a href=&quot;refresh&quot;&gt;&lt;code&gt;directory_entry::refresh&lt;/code&gt;&lt;/a&gt;, which makes it possible to examine the attributes of the directory entries as they are being iterated over, without making additional system calls.</source>
          <target state="translated">Многие низкоуровневые API-интерфейсы ОС для обхода каталога извлекают атрибуты файла вместе со следующей записью каталога. Конструкторы и неконстантные функции-члены &lt;code&gt;directory_iterator&lt;/code&gt; сохраняют эти атрибуты, если таковые имеются, в указанном &lt;a href=&quot;../directory_entry&quot;&gt; &lt;code&gt;directory_entry&lt;/code&gt; &lt;/a&gt; без вызова &lt;a href=&quot;refresh&quot;&gt; &lt;code&gt;directory_entry::refresh&lt;/code&gt; &lt;/a&gt; , что позволяет исследовать атрибуты записей каталога во время их итерации, без дополнительных системных звонков.</target>
        </trans-unit>
        <trans-unit id="039f47ebbed9ac7270772eb78d294ff20051a865" translate="yes" xml:space="preserve">
          <source>Many low-level OS APIs for directory traversal retrieve file attributes along with the next directory entry. The constructors and the non-const member functions of &lt;code&gt;directory_iterator&lt;/code&gt; store these attributes, if any, in the pointed-to &lt;a href=&quot;../directory_entry&quot;&gt;&lt;code&gt;directory_entry&lt;/code&gt;&lt;/a&gt; without calling &lt;strong&gt;&lt;code&gt;directory_entry::refresh&lt;/code&gt;&lt;/strong&gt;, which makes it possible to examine the attributes of the directory entries as they are being iterated over, without making additional system calls.</source>
          <target state="translated">Многие низкоуровневые API-интерфейсы ОС для обхода каталога извлекают атрибуты файла вместе со следующей записью каталога. Конструкторы и неконстантные функции-члены &lt;code&gt;directory_iterator&lt;/code&gt; сохраняют эти атрибуты, если таковые имеются, в указанном &lt;a href=&quot;../directory_entry&quot;&gt; &lt;code&gt;directory_entry&lt;/code&gt; &lt;/a&gt; без вызова &lt;strong&gt; &lt;code&gt;directory_entry::refresh&lt;/code&gt; &lt;/strong&gt; , что позволяет исследовать атрибуты записей каталога во время их итерации, без дополнительных системных звонков.</target>
        </trans-unit>
        <trans-unit id="3ed89c2f28cb830995daa3a7b4042d44d35eeacb" translate="yes" xml:space="preserve">
          <source>Many low-level OS APIs for directory traversal retrieve file attributes along with the next directory entry. The constructors and the non-const member functions of &lt;code&gt;directory_iterator&lt;/code&gt; store these attributes, if any, in the pointed-to &lt;a href=&quot;directory_entry&quot;&gt;&lt;code&gt;directory_entry&lt;/code&gt;&lt;/a&gt; without calling &lt;a href=&quot;directory_entry/refresh&quot;&gt;&lt;code&gt;directory_entry::refresh&lt;/code&gt;&lt;/a&gt;, which makes it possible to examine the attributes of the directory entries as they are being iterated over, without making additional system calls.</source>
          <target state="translated">Многие низкоуровневые API-интерфейсы ОС для обхода каталога извлекают атрибуты файла вместе со следующей записью каталога. Конструкторы и неконстантные функции-члены &lt;code&gt;directory_iterator&lt;/code&gt; сохраняют эти атрибуты, если таковые имеются, в указанном &lt;a href=&quot;directory_entry&quot;&gt; &lt;code&gt;directory_entry&lt;/code&gt; &lt;/a&gt; без вызова &lt;a href=&quot;directory_entry/refresh&quot;&gt; &lt;code&gt;directory_entry::refresh&lt;/code&gt; &lt;/a&gt; , что позволяет исследовать атрибуты записей каталога во время их итерации, без дополнительных системных звонков.</target>
        </trans-unit>
        <trans-unit id="e5aebdb8c7063bd86b2ac2bb9180c0f2ca620fad" translate="yes" xml:space="preserve">
          <source>Many standard library functions (for example, many algorithms) expect their arguments to satisfy Swappable, which means that any time the standard library performs a swap, it uses the equivalent of &lt;code&gt;using &lt;a href=&quot;../algorithm/swap&quot;&gt;std::swap&lt;/a&gt;; swap(t, u);&lt;/code&gt;.</source>
          <target state="translated">Многие стандартные библиотечные функции (например, многие алгоритмы) ожидают, что их аргументы удовлетворят Swappable, что означает, что каждый раз, когда стандартная библиотека выполняет свопинг, она использует эквивалент &lt;code&gt;using &lt;a href=&quot;../algorithm/swap&quot;&gt;std::swap&lt;/a&gt;; swap(t, u);&lt;/code&gt; ,</target>
        </trans-unit>
        <trans-unit id="5121f00841245e1a12c2ae4fef43200d5c0249fe" translate="yes" xml:space="preserve">
          <source>Many standard library functions expect their arguments to satisfy ValueSwappable, which means that any time the standard library performs a swap, it uses the equivalent of &lt;code&gt;using &lt;a href=&quot;../algorithm/swap&quot;&gt;std::swap&lt;/a&gt;; swap(*iter1, *iter2);&lt;/code&gt;.</source>
          <target state="translated">Многие стандартные библиотечные функции ожидают, что их аргументы удовлетворят ValueSwappable, что означает, что всякий раз, когда стандартная библиотека выполняет своп, она использует эквивалент &lt;code&gt;using &lt;a href=&quot;../algorithm/swap&quot;&gt;std::swap&lt;/a&gt;; swap(*iter1, *iter2);&lt;/code&gt; ,</target>
        </trans-unit>
        <trans-unit id="afe6902aeefe49078fe8050bd00528c238507028" translate="yes" xml:space="preserve">
          <source>Maps the wide character &lt;code&gt;wc&lt;/code&gt; using the current C locale's LC_CTYPE mapping category identified by &lt;code&gt;desc&lt;/code&gt;.</source>
          <target state="translated">Сопоставляет широкий символ &lt;code&gt;wc&lt;/code&gt; , используя категорию отображения текущей локали C LC_CTYPE, обозначенную &lt;code&gt;desc&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4077ecc006514db344c55f8c4fad2c745c0130ce" translate="yes" xml:space="preserve">
          <source>Marks a declaration, a group of declarations, or another module as exported by the current module.</source>
          <target state="translated">Помечает декларацию,группу деклараций или другой модуль,экспортируемый текущим модулем.</target>
        </trans-unit>
        <trans-unit id="b756154598ee707bf908cd000d9935386991975f" translate="yes" xml:space="preserve">
          <source>Matches a literal &lt;code&gt;%&lt;/code&gt; character.</source>
          <target state="translated">Соответствует буквальному символу &lt;code&gt;%&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="72f947b49a5a8e988f9298c168a0e3f58111d4e5" translate="yes" xml:space="preserve">
          <source>Matches one whitespace character.</source>
          <target state="translated">Совпадает с одним пробелом персонажа.</target>
        </trans-unit>
        <trans-unit id="fcfacbcdbc0dc12100a2ddcea744584b78974f4f" translate="yes" xml:space="preserve">
          <source>Matches zero or one whitespace character.</source>
          <target state="translated">Совпадает с нулем или одним пробелом.</target>
        </trans-unit>
        <trans-unit id="a188c6effe4bde401e7ad28544fc6e87a9daffac" translate="yes" xml:space="preserve">
          <source>Matching of &lt;a href=&quot;language/template_parameters#Template_template_arguments&quot;&gt;template template-arguments&lt;/a&gt;</source>
          <target state="translated">Сопоставление &lt;a href=&quot;language/template_parameters#Template_template_arguments&quot;&gt;шаблона с аргументами шаблона&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="20eb57cf8e0dada9d1ba105b859145de9af95dd7" translate="yes" xml:space="preserve">
          <source>Mathematical definition of hyperbolic cosine is cosh z =</source>
          <target state="translated">Математическое определение гиперболического косинуса-cosh z =</target>
        </trans-unit>
        <trans-unit id="26750d755fd0345482bcbffe431aa399db954d60" translate="yes" xml:space="preserve">
          <source>Mathematical definition of hyperbolic sine is sinh z =</source>
          <target state="translated">Математическое определение гиперболического синуса-синх z =</target>
        </trans-unit>
        <trans-unit id="e84aec3fc0130942848a9f7d933b06ea09b78dbd" translate="yes" xml:space="preserve">
          <source>Mathematical definition of hyperbolic tangent is tanh z =</source>
          <target state="translated">Математическое определение гиперболического тангенса-танх z =</target>
        </trans-unit>
        <trans-unit id="cdb41af16e4d375b018b261d1a2817a89b9975b7" translate="yes" xml:space="preserve">
          <source>Mathematical functions and types</source>
          <target state="translated">Математические функции и типы</target>
        </trans-unit>
        <trans-unit id="e69584469298924788f58d14e045618717167ab1" translate="yes" xml:space="preserve">
          <source>Mathematical special functions</source>
          <target state="translated">Математические специальные функции</target>
        </trans-unit>
        <trans-unit id="86c50200efef0be47369777679929f798cf2e81a" translate="yes" xml:space="preserve">
          <source>Mathematical special functions for C++17</source>
          <target state="translated">Специальные математические функции для C++17</target>
        </trans-unit>
        <trans-unit id="5d307dd0d56fc9ce2efcd46807c5cc26c88385c1" translate="yes" xml:space="preserve">
          <source>Mathematics argument out of domain of function</source>
          <target state="translated">Математический аргумент вне области функции</target>
        </trans-unit>
        <trans-unit id="f8777efcd5a7cb7cda3c0f39eeda95994a1a15e9" translate="yes" xml:space="preserve">
          <source>Maxcode</source>
          <target state="translated">Maxcode</target>
        </trans-unit>
        <trans-unit id="d3dc367122aa7293e5afbfae55b89a3439308677" translate="yes" xml:space="preserve">
          <source>Maximum number of buckets.</source>
          <target state="translated">Максимальное количество ведер.</target>
        </trans-unit>
        <trans-unit id="149a459f54b376ce18459ec98c8686438b039d4d" translate="yes" xml:space="preserve">
          <source>Maximum number of characters.</source>
          <target state="translated">Максимальное количество символов.</target>
        </trans-unit>
        <trans-unit id="40479cd9e5c70abfcec7f229a5343100ee1e982b" translate="yes" xml:space="preserve">
          <source>Maximum number of elements.</source>
          <target state="translated">Максимальное количество элементов.</target>
        </trans-unit>
        <trans-unit id="74c9f71fbcac6b3790990dc6749cb13cfcb51bec" translate="yes" xml:space="preserve">
          <source>Maximum number of submatches.</source>
          <target state="translated">Максимальное количество субматчей.</target>
        </trans-unit>
        <trans-unit id="c386253a5eac67332c4d54f0c89f27e31946d1fa" translate="yes" xml:space="preserve">
          <source>May also throw &lt;code&gt;&lt;a href=&quot;../../memory/new/bad_alloc&quot;&gt;std::bad_alloc&lt;/a&gt;&lt;/code&gt; if additional memory required for internal data structures cannot be allocated.</source>
          <target state="translated">Может также &lt;code&gt;&lt;a href=&quot;../../memory/new/bad_alloc&quot;&gt;std::bad_alloc&lt;/a&gt;&lt;/code&gt; если дополнительная память, необходимая для внутренних структур данных, не может быть выделена.</target>
        </trans-unit>
        <trans-unit id="3b12ceeda37fe6a0712324b0b075665414e87d72" translate="yes" xml:space="preserve">
          <source>May appear in the declaration of a non-static &lt;a href=&quot;data_members&quot;&gt;class members&lt;/a&gt; of non-reference non-const type:</source>
          <target state="translated">Может появиться в объявлении нестатических &lt;a href=&quot;data_members&quot;&gt;членов класса&lt;/a&gt; неконстантного неконстантного типа:</target>
        </trans-unit>
        <trans-unit id="b266289267f1b69728db3ede6cf1835744b3fe8f" translate="yes" xml:space="preserve">
          <source>May be compiled as (&lt;a href=&quot;https://gcc.godbolt.org/z/6itUO1&quot;&gt;demo&lt;/a&gt;).</source>
          <target state="translated">Может быть скомпилировано как ( &lt;a href=&quot;https://gcc.godbolt.org/z/6itUO1&quot;&gt;демо&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="6c7f6ea88007fac3556846ed6f0bd902e3dfa12f" translate="yes" xml:space="preserve">
          <source>May be compiled as (&lt;a href=&quot;https://godbolt.org/z/QYZvsl&quot;&gt;demo&lt;/a&gt;).</source>
          <target state="translated">Может быть скомпилировано как ( &lt;a href=&quot;https://godbolt.org/z/QYZvsl&quot;&gt;демо&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="70f7c1e91932b1a70687c4ebae101b3db1ba5098" translate="yes" xml:space="preserve">
          <source>May be compiled as (&lt;a href=&quot;https://godbolt.org/z/e2bC84&quot;&gt;demo&lt;/a&gt;).</source>
          <target state="translated">Может быть скомпилировано как ( &lt;a href=&quot;https://godbolt.org/z/e2bC84&quot;&gt;демо&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="17b2c58fc2da61849ab101eba953459e4980b963" translate="yes" xml:space="preserve">
          <source>May only be applied to a &lt;a href=&quot;../statements#Expression_statements&quot;&gt;null statement&lt;/a&gt; to create a</source>
          <target state="translated">Может применяться только к &lt;a href=&quot;../statements#Expression_statements&quot;&gt;пустому оператору&lt;/a&gt; для создания</target>
        </trans-unit>
        <trans-unit id="5b24b967e2517fdf19db9e1d07428b9424c7e88d" translate="yes" xml:space="preserve">
          <source>May throw &lt;code&gt;&lt;a href=&quot;../../error/system_error&quot;&gt;std::system_error&lt;/a&gt;&lt;/code&gt;, may also propagate exceptions thrown by &lt;a href=&quot;../unique_lock/lock&quot;&gt;&lt;code&gt;lock.lock()&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../unique_lock/unlock&quot;&gt;&lt;code&gt;lock.unlock()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Может генерировать &lt;code&gt;&lt;a href=&quot;../../error/system_error&quot;&gt;std::system_error&lt;/a&gt;&lt;/code&gt; , также может распространять исключения, &lt;a href=&quot;../unique_lock/lock&quot;&gt; &lt;code&gt;lock.lock()&lt;/code&gt; &lt;/a&gt; или &lt;a href=&quot;../unique_lock/unlock&quot;&gt; &lt;code&gt;lock.unlock()&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="82f82cbc23b684cfee57e315e7faddcf81a5e024" translate="yes" xml:space="preserve">
          <source>May throw &lt;code&gt;&lt;a href=&quot;../../error/system_error&quot;&gt;std::system_error&lt;/a&gt;&lt;/code&gt;, may also propagate exceptions thrown by &lt;code&gt;lock.lock()&lt;/code&gt; or &lt;code&gt;lock.unlock()&lt;/code&gt;.</source>
          <target state="translated">Может генерировать &lt;code&gt;&lt;a href=&quot;../../error/system_error&quot;&gt;std::system_error&lt;/a&gt;&lt;/code&gt; , также может распространять исключения, &lt;code&gt;lock.lock()&lt;/code&gt; или &lt;code&gt;lock.unlock()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2c170df4323127a54ff75977e5aea172641a66b1" translate="yes" xml:space="preserve">
          <source>May throw &lt;code&gt;&lt;a href=&quot;../../io/ios_base/failure&quot;&gt;std::ios_base::failure&lt;/a&gt;&lt;/code&gt; if an exception is thrown during output.</source>
          <target state="translated">Может &lt;code&gt;&lt;a href=&quot;../../io/ios_base/failure&quot;&gt;std::ios_base::failure&lt;/a&gt;&lt;/code&gt; если во время вывода выдается исключение.</target>
        </trans-unit>
        <trans-unit id="9537e9cfb9ff89dce06742cc44b6f80d289fe969" translate="yes" xml:space="preserve">
          <source>May throw &lt;code&gt;&lt;a href=&quot;../../io/ios_base/failure&quot;&gt;std::ios_base::failure&lt;/a&gt;&lt;/code&gt; on stream errors.</source>
          <target state="translated">Может &lt;code&gt;&lt;a href=&quot;../../io/ios_base/failure&quot;&gt;std::ios_base::failure&lt;/a&gt;&lt;/code&gt; в потоке ошибок.</target>
        </trans-unit>
        <trans-unit id="74e16b22a77e8236ce676f4f2f124c10d8901a2b" translate="yes" xml:space="preserve">
          <source>May throw &lt;code&gt;&lt;a href=&quot;../../memory/new/bad_alloc&quot;&gt;std::bad_alloc&lt;/a&gt;&lt;/code&gt; from the &lt;code&gt;&lt;a href=&quot;../basic_string&quot;&gt;std::string&lt;/a&gt;&lt;/code&gt; constructor.</source>
          <target state="translated">Может бросить &lt;code&gt;&lt;a href=&quot;../../memory/new/bad_alloc&quot;&gt;std::bad_alloc&lt;/a&gt;&lt;/code&gt; из конструктора &lt;code&gt;&lt;a href=&quot;../basic_string&quot;&gt;std::string&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cab3d4a6660b25cecf735f777424ba412487e934" translate="yes" xml:space="preserve">
          <source>May throw &lt;code&gt;&lt;a href=&quot;../../memory/new/bad_alloc&quot;&gt;std::bad_alloc&lt;/a&gt;&lt;/code&gt; from the &lt;code&gt;&lt;a href=&quot;../basic_string&quot;&gt;std::wstring&lt;/a&gt;&lt;/code&gt; constructor.</source>
          <target state="translated">Может бросить &lt;code&gt;&lt;a href=&quot;../../memory/new/bad_alloc&quot;&gt;std::bad_alloc&lt;/a&gt;&lt;/code&gt; из конструктора &lt;code&gt;&lt;a href=&quot;../basic_string&quot;&gt;std::wstring&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="962f83e06ea50e04d31c9f8437b97c5191adb569" translate="yes" xml:space="preserve">
          <source>May throw &lt;code&gt;&lt;a href=&quot;../../memory/new/bad_alloc&quot;&gt;std::bad_alloc&lt;/a&gt;&lt;/code&gt; from the the &lt;code&gt;&lt;a href=&quot;../../string/basic_string&quot;&gt;std::string&lt;/a&gt;&lt;/code&gt; constructor.</source>
          <target state="translated">Может &lt;code&gt;&lt;a href=&quot;../../memory/new/bad_alloc&quot;&gt;std::bad_alloc&lt;/a&gt;&lt;/code&gt; из конструктора &lt;code&gt;&lt;a href=&quot;../../string/basic_string&quot;&gt;std::string&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6f18fce82e50be7509279d8759683168fd690cfd" translate="yes" xml:space="preserve">
          <source>May throw &lt;code&gt;&lt;a href=&quot;../../memory/new/bad_alloc&quot;&gt;std::bad_alloc&lt;/a&gt;&lt;/code&gt; if memory allocation fails.</source>
          <target state="translated">Может &lt;code&gt;&lt;a href=&quot;../../memory/new/bad_alloc&quot;&gt;std::bad_alloc&lt;/a&gt;&lt;/code&gt; случае сбоя выделения памяти.</target>
        </trans-unit>
        <trans-unit id="eb0efb1fe6c128b1e051773ebaffa4603c205e9c" translate="yes" xml:space="preserve">
          <source>May throw &lt;code&gt;&lt;a href=&quot;../../memory/new/bad_alloc&quot;&gt;std::bad_alloc&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Может бросить &lt;code&gt;&lt;a href=&quot;../../memory/new/bad_alloc&quot;&gt;std::bad_alloc&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3ba6e5262639e253495b627007f9b05da37e203d" translate="yes" xml:space="preserve">
          <source>May throw &lt;code&gt;&lt;a href=&quot;../ios_base/failure&quot;&gt;std::ios_base::failure&lt;/a&gt;&lt;/code&gt; if &lt;code&gt;exceptions()&amp;amp;badbit!=0&lt;/code&gt;.</source>
          <target state="translated">Может &lt;code&gt;&lt;a href=&quot;../ios_base/failure&quot;&gt;std::ios_base::failure&lt;/a&gt;&lt;/code&gt; если &lt;code&gt;exceptions()&amp;amp;badbit!=0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f1533fcb442ebdf84b8b8136c017750a808b170e" translate="yes" xml:space="preserve">
          <source>May throw &lt;code&gt;&lt;a href=&quot;../ios_base/failure&quot;&gt;std::ios_base::failure&lt;/a&gt;&lt;/code&gt; in case of failure, if &lt;code&gt;exceptions() &amp;amp; failbit != 0&lt;/code&gt;.</source>
          <target state="translated">Может &lt;code&gt;&lt;a href=&quot;../ios_base/failure&quot;&gt;std::ios_base::failure&lt;/a&gt;&lt;/code&gt; в случае сбоя, если &lt;code&gt;exceptions() &amp;amp; failbit != 0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="aaa5c6b529feaa58739bd67ba50e2fb2001b4fb7" translate="yes" xml:space="preserve">
          <source>May throw &lt;code&gt;&lt;a href=&quot;../memory/new/bad_alloc&quot;&gt;std::bad_alloc&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Может бросить &lt;code&gt;&lt;a href=&quot;../memory/new/bad_alloc&quot;&gt;std::bad_alloc&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="88e82c73c9f5acd5341c52abeb46b516d79c0a4c" translate="yes" xml:space="preserve">
          <source>May throw &lt;code&gt;&lt;a href=&quot;../new/bad_alloc&quot;&gt;std::bad_alloc&lt;/a&gt;&lt;/code&gt; if the system cannot allocate memory required to track reachable objects.</source>
          <target state="translated">Может &lt;code&gt;&lt;a href=&quot;../new/bad_alloc&quot;&gt;std::bad_alloc&lt;/a&gt;&lt;/code&gt; если система не может выделить память, необходимую для отслеживания достижимых объектов.</target>
        </trans-unit>
        <trans-unit id="50334b4e66ee014f5ce48f4fae49d65f13d9afac" translate="yes" xml:space="preserve">
          <source>May throw &lt;code&gt;&lt;a href=&quot;../new/bad_alloc&quot;&gt;std::bad_alloc&lt;/a&gt;&lt;/code&gt; or any exception thrown by the constructor of &lt;code&gt;T&lt;/code&gt;. If an exception is thrown, the functions have no effect. If an exception is thrown during the construction of the array, already-initialized elements are destroyed in reverse order.(since C++20).</source>
          <target state="translated">Может бросить &lt;code&gt;&lt;a href=&quot;../new/bad_alloc&quot;&gt;std::bad_alloc&lt;/a&gt;&lt;/code&gt; или любое исключение , брошенное конструктором &lt;code&gt;T&lt;/code&gt; . Если выдается исключение, функции не действуют. Если во время создания массива возникает исключение, уже инициализированные элементы уничтожаются в обратном порядке (начиная с C ++ 20).</target>
        </trans-unit>
        <trans-unit id="fdfbbb46059a0d2dcd9098fe9a358cdc6c64a4b0" translate="yes" xml:space="preserve">
          <source>May throw &lt;code&gt;&lt;a href=&quot;../new/bad_alloc&quot;&gt;std::bad_alloc&lt;/a&gt;&lt;/code&gt; or any exception thrown by the constructor of &lt;code&gt;T&lt;/code&gt;. If an exception is thrown, this function has no effect.</source>
          <target state="translated">Может бросить &lt;code&gt;&lt;a href=&quot;../new/bad_alloc&quot;&gt;std::bad_alloc&lt;/a&gt;&lt;/code&gt; или любое исключение , брошенное конструктором &lt;code&gt;T&lt;/code&gt; . Если выдается исключение, эта функция не действует.</target>
        </trans-unit>
        <trans-unit id="3490986d7e9db538d6473a2861a95a9c29b566de" translate="yes" xml:space="preserve">
          <source>May throw &lt;code&gt;&lt;a href=&quot;failure&quot;&gt;std::ios_base::failure&lt;/a&gt;&lt;/code&gt; when setting the badbit.</source>
          <target state="translated">Может выбрасывать &lt;code&gt;&lt;a href=&quot;failure&quot;&gt;std::ios_base::failure&lt;/a&gt;&lt;/code&gt; при установке бадбита.</target>
        </trans-unit>
        <trans-unit id="55d3334b217863c436b19298f8ac48b6aa3046e7" translate="yes" xml:space="preserve">
          <source>May throw &lt;code&gt;&lt;a href=&quot;regex_error&quot;&gt;std::regex_error&lt;/a&gt;&lt;/code&gt; to indicate an &lt;a href=&quot;error_type&quot;&gt;error condition&lt;/a&gt;.</source>
          <target state="translated">Может &lt;code&gt;&lt;a href=&quot;regex_error&quot;&gt;std::regex_error&lt;/a&gt;&lt;/code&gt; чтобы указать состояние &lt;a href=&quot;error_type&quot;&gt;ошибки&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a2aac967544933ac46c56aad850b11b876e778a6" translate="yes" xml:space="preserve">
          <source>May throw any exception thrown by the constructor of &lt;code&gt;T&lt;/code&gt;, typically including &lt;code&gt;&lt;a href=&quot;new/bad_alloc&quot;&gt;std::bad_alloc&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Может вызвать любое исключение, &lt;code&gt;&lt;a href=&quot;new/bad_alloc&quot;&gt;std::bad_alloc&lt;/a&gt;&lt;/code&gt; конструктором &lt;code&gt;T&lt;/code&gt; , обычно включая std :: bad_alloc .</target>
        </trans-unit>
        <trans-unit id="295aca95b34c6da649adb7e8f83289b1503b3665" translate="yes" xml:space="preserve">
          <source>May throw any exceptions thrown by &lt;code&gt;&lt;a href=&quot;../../memory/allocator_traits&quot;&gt;std::allocator_traits&lt;/a&gt;&amp;lt;Allocator&amp;gt;::allocate()&lt;/code&gt;, such as &lt;code&gt;&lt;a href=&quot;../../memory/new/bad_alloc&quot;&gt;std::bad_alloc&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Может генерировать любые исключения, выданные &lt;code&gt;&lt;a href=&quot;../../memory/allocator_traits&quot;&gt;std::allocator_traits&lt;/a&gt;&amp;lt;Allocator&amp;gt;::allocate()&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;../../memory/new/bad_alloc&quot;&gt;std::bad_alloc&lt;/a&gt;&lt;/code&gt; () , например std :: bad_alloc .</target>
        </trans-unit>
        <trans-unit id="1d89ff13f4c0ab3dc3033aad665ca0c8a7d4a1d6" translate="yes" xml:space="preserve">
          <source>May throw any exceptions thrown by the call to &lt;code&gt;allocate_object&lt;/code&gt; or the constructor of &lt;code&gt;U&lt;/code&gt;.</source>
          <target state="translated">Может бросить все исключения , брошенные вызов &lt;code&gt;allocate_object&lt;/code&gt; или конструктором &lt;code&gt;U&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cdf7c3ace6d1c50a2a552ed9dfc67f2851b5de5c" translate="yes" xml:space="preserve">
          <source>May throw any exceptions thrown by the call to &lt;code&gt;resource()-&amp;gt;allocate&lt;/code&gt;.</source>
          <target state="translated">Может генерировать любые исключения, вызванные вызовом &lt;code&gt;resource()-&amp;gt;allocate&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="19cd7d185cfd95a703e62d43597e9ae28e0646e5" translate="yes" xml:space="preserve">
          <source>Meaning</source>
          <target state="translated">Meaning</target>
        </trans-unit>
        <trans-unit id="014505538b8bc36d85ed833b2d3a182aea673970" translate="yes" xml:space="preserve">
          <source>Meaningless C headers</source>
          <target state="translated">Бессмысленные заголовки С</target>
        </trans-unit>
        <trans-unit id="6853c98a6f4358bbfed1b3b9c81d308649299b0f" translate="yes" xml:space="preserve">
          <source>Member</source>
          <target state="translated">Member</target>
        </trans-unit>
        <trans-unit id="d880b0db33396f09e94ad458e37bf499710140d0" translate="yes" xml:space="preserve">
          <source>Member access</source>
          <target state="translated">Доступ для участников</target>
        </trans-unit>
        <trans-unit id="b14800487e886a905875d25619be005b0bb88353" translate="yes" xml:space="preserve">
          <source>Member access does not affect visibility: names of private and privately-inherited members are visible and considered by overload resolution, implicit conversions to inaccessible base classes are still considered, etc. Member access check is the last step after any given language construct is interpreted. The intent of this rule is that replacing any &lt;code&gt;private&lt;/code&gt; with &lt;code&gt;public&lt;/code&gt; never alters the behavior of the program.</source>
          <target state="translated">Доступ к элементу не влияет на видимость: имена частных и унаследованных частным образом элементов видны и учитываются при разрешении перегрузки, все еще рассматриваются неявные преобразования в недоступные базовые классы и т. Д. Проверка доступа к элементу является последним этапом после интерпретации любой данной языковой конструкции. Цель этого правила состоит в том, что замена любого &lt;code&gt;private&lt;/code&gt; на &lt;code&gt;public&lt;/code&gt; никогда не изменяет поведение программы.</target>
        </trans-unit>
        <trans-unit id="cf9ba14f65379b3cac2135b4415ee8ccd2ae4dbf" translate="yes" xml:space="preserve">
          <source>Member access operators</source>
          <target state="translated">Операторы доступа пользователей</target>
        </trans-unit>
        <trans-unit id="0dbd252428ccbd0d975da572dc34df0626898460" translate="yes" xml:space="preserve">
          <source>Member alias templates</source>
          <target state="translated">Шаблоны псевдонимов членов</target>
        </trans-unit>
        <trans-unit id="c618f84bc8f235803205b6351cb60f5fe7b25f6f" translate="yes" xml:space="preserve">
          <source>Member classes</source>
          <target state="translated">Классы для участников</target>
        </trans-unit>
        <trans-unit id="53b558837f61bee946a0dd1ce0e5906eb1fbb225" translate="yes" xml:space="preserve">
          <source>Member constant</source>
          <target state="translated">константа Члена</target>
        </trans-unit>
        <trans-unit id="11178f71158bbe4d9b5ae241f21a139cf3506414" translate="yes" xml:space="preserve">
          <source>Member constants</source>
          <target state="translated">константы членов</target>
        </trans-unit>
        <trans-unit id="14511f9334df9fc1bdabba7170aa8468f6d02cfd" translate="yes" xml:space="preserve">
          <source>Member function</source>
          <target state="translated">функция участника</target>
        </trans-unit>
        <trans-unit id="e7d2a79cda830630ecf28efb73b93f5d64c726ea" translate="yes" xml:space="preserve">
          <source>Member function &lt;code&gt;operator()&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;operator()&lt;/code&gt; функции-члена ()</target>
        </trans-unit>
        <trans-unit id="9d34638b7646acd7bec35ca244b9f93a8a851424" translate="yes" xml:space="preserve">
          <source>Member function definition</source>
          <target state="translated">Определение функции члена</target>
        </trans-unit>
        <trans-unit id="08497771fff890fda9af78587c591fe51ef91e55" translate="yes" xml:space="preserve">
          <source>Member function table</source>
          <target state="translated">Функциональная таблица участника</target>
        </trans-unit>
        <trans-unit id="55bb0b5562e8411fcb96bbac022a9f6ac7ea4d1b" translate="yes" xml:space="preserve">
          <source>Member function templates</source>
          <target state="translated">Шаблоны функций участника</target>
        </trans-unit>
        <trans-unit id="b217f7514e4e69fd38aa7c54a821e91e41f619c3" translate="yes" xml:space="preserve">
          <source>Member functions</source>
          <target state="translated">Функции членов</target>
        </trans-unit>
        <trans-unit id="980cb8724fcd1049e2076cf5101d5771adc84b3d" translate="yes" xml:space="preserve">
          <source>Member functions (including virtual member functions) can be called from member initializers, but the behavior is undefined if not all direct bases are initialized at that point.</source>
          <target state="translated">Членские функции (в том числе и виртуальные членские функции)могут быть вызваны из инициализаторов членов,но поведение не определено,если в этот момент инициализируются не все прямые базы.</target>
        </trans-unit>
        <trans-unit id="de7182652ce370c94f7c684b95c200a783818dee" translate="yes" xml:space="preserve">
          <source>Member functions of a local class have no linkage</source>
          <target state="translated">Членские функции локального класса не имеют связи</target>
        </trans-unit>
        <trans-unit id="d5d511dbaf6e4bdbdd2335cea43d07a07ffcc20d" translate="yes" xml:space="preserve">
          <source>Member functions of a local class have to be defined entirely inside the class body</source>
          <target state="translated">Членские функции локального класса должны быть определены полностью внутри тела класса</target>
        </trans-unit>
        <trans-unit id="0656eb615cbde62fa5517f8cf8a8d9f0cd48715c" translate="yes" xml:space="preserve">
          <source>Member initialization</source>
          <target state="translated">инициализация члена</target>
        </trans-unit>
        <trans-unit id="0b96269b9ecb978e0c0b9cfaf7fa59a36ac1af38" translate="yes" xml:space="preserve">
          <source>Member initializers and aggregates</source>
          <target state="translated">Инициализаторы и агрегаты членов</target>
        </trans-unit>
        <trans-unit id="19bedac337c4148b66c642456a9ebdfc9f5a6c88" translate="yes" xml:space="preserve">
          <source>Member lifetime</source>
          <target state="translated">срок службы члена</target>
        </trans-unit>
        <trans-unit id="d2fbdd7c0d6a0fe8e113aa296a28047ef253149d" translate="yes" xml:space="preserve">
          <source>Member name</source>
          <target state="translated">имя участника</target>
        </trans-unit>
        <trans-unit id="74fa726e3f14b875e371e46176a78863344d0e2a" translate="yes" xml:space="preserve">
          <source>Member name lookup</source>
          <target state="translated">Поиск имени пользователя</target>
        </trans-unit>
        <trans-unit id="fde74c71ca6b1383761e00548de51dddc150302d" translate="yes" xml:space="preserve">
          <source>Member object</source>
          <target state="translated">возражающий участник</target>
        </trans-unit>
        <trans-unit id="d4037494affff8e1187b4614057e3d3856936fa0" translate="yes" xml:space="preserve">
          <source>Member objects</source>
          <target state="translated">объекты-участники</target>
        </trans-unit>
        <trans-unit id="7c1c4577121db570224d4e6d1b453b5fee33ebf0" translate="yes" xml:space="preserve">
          <source>Member of a class template outside of template</source>
          <target state="translated">Член шаблона класса вне шаблона</target>
        </trans-unit>
        <trans-unit id="fcf850420e837ff3777a4510c350a70dc493bb17" translate="yes" xml:space="preserve">
          <source>Member of object</source>
          <target state="translated">Член объекта</target>
        </trans-unit>
        <trans-unit id="4300f5098631ebd1c4cf89699b5b4370fc4f18ee" translate="yes" xml:space="preserve">
          <source>Member or a member template may be nested within many enclosing class templates. In an explicit specialization for such a member, there's a &lt;code&gt;template&amp;lt;&amp;gt;&lt;/code&gt; for every enclosing class template that is explicitly specialized.</source>
          <target state="translated">Элемент или шаблон участника может быть вложен во многие шаблоны классов. В явной специализации для такого члена есть &lt;code&gt;template&amp;lt;&amp;gt;&lt;/code&gt; для каждого включающего шаблона класса, который явно специализирован.</target>
        </trans-unit>
        <trans-unit id="f2fae0c7a45f97c1ebd785be8d844ad4e439ae3c" translate="yes" xml:space="preserve">
          <source>Member specification</source>
          <target state="translated">Спецификация участника</target>
        </trans-unit>
        <trans-unit id="87b9dbba6959e8f157ca46a3351b964abfdee42b" translate="yes" xml:space="preserve">
          <source>Member templates</source>
          <target state="translated">Шаблоны участников</target>
        </trans-unit>
        <trans-unit id="d7ae56afa08fe3824c2cd242b7909d3e66c1ecc3" translate="yes" xml:space="preserve">
          <source>Member type</source>
          <target state="translated">тип члена</target>
        </trans-unit>
        <trans-unit id="55c0692816e400cc9f1e8bcd75e4a14f74352890" translate="yes" xml:space="preserve">
          <source>Member type &lt;code&gt;result_type&lt;/code&gt;</source>
          <target state="translated">Тип &lt;code&gt;result_type&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="22c15de225ed427b7d10b0a6ea94574676a92b6e" translate="yes" xml:space="preserve">
          <source>Member types</source>
          <target state="translated">типы членов</target>
        </trans-unit>
        <trans-unit id="2a9c2afdee2bf076807c340c63de865c0262cc04" translate="yes" xml:space="preserve">
          <source>Member types and constants</source>
          <target state="translated">Типы членов и константы</target>
        </trans-unit>
        <trans-unit id="8e74c7d99d2202da874a715a8b5fbfbc2b8cb4db" translate="yes" xml:space="preserve">
          <source>Member variable templates</source>
          <target state="translated">Шаблоны переменных членства</target>
        </trans-unit>
        <trans-unit id="1cb449c1126609b4b41e1d87f65f0d7cd19b49b9" translate="yes" xml:space="preserve">
          <source>Members</source>
          <target state="translated">Members</target>
        </trans-unit>
        <trans-unit id="84f16231bc3f47eb66803d5355786879bfe2e29d" translate="yes" xml:space="preserve">
          <source>Members identical to std::optional</source>
          <target state="translated">Члены идентичны std::опционально</target>
        </trans-unit>
        <trans-unit id="8441142a0e7debda365fc2602acee6048f15bbbe" translate="yes" xml:space="preserve">
          <source>Members of &lt;a href=&quot;union&quot;&gt;anonymous unions&lt;/a&gt; cannot be captured.</source>
          <target state="translated">Члены &lt;a href=&quot;union&quot;&gt;анонимных союзов&lt;/a&gt; не могут быть захвачены.</target>
        </trans-unit>
        <trans-unit id="02c67b9d74374d2cbad42e0e00560d1e26c88740" translate="yes" xml:space="preserve">
          <source>Members of an anonymous union are injected in the enclosing scope (and must not conflict with other names declared there).</source>
          <target state="translated">Членам анонимного союза впрыскивают инъекции в прилагаемый объем (и они не должны противоречить другим заявленным в нем именам).</target>
        </trans-unit>
        <trans-unit id="b8b5ab3d00ea4a372f20b27f763c84738411ec47" translate="yes" xml:space="preserve">
          <source>Members of an inline namespace are treated as if they are members of the enclosing namespace in many situations (listed below). This property is transitive: if a namespace N contains an inline namespace M, which in turn contains an inline namespace O, then the members of O can be used as though they were members of M or N.</source>
          <target state="translated">Во многих ситуациях (см.ниже)члены строкового пространства имён рассматриваются так,как если бы они были членами строкового пространства имён (см.ниже).Это свойство является переходным:если пространство имён N содержит встроенное пространство имён M,которое,в свою очередь,содержит встроенное пространство имён O,то члены O могут быть использованы,как если бы они были членами M или N.</target>
        </trans-unit>
        <trans-unit id="8586c2e60536f02fc22562f8abc3249a46b2b677" translate="yes" xml:space="preserve">
          <source>Members of array type cannot deduce their size from member initializers:</source>
          <target state="translated">Члены типа массива не могут вывести свой размер из инициализаторов членов:</target>
        </trans-unit>
        <trans-unit id="7ab44845744014b08b5a156f5657ab462609baf4" translate="yes" xml:space="preserve">
          <source>Members of partial specializations</source>
          <target state="translated">Члены частичной специализации</target>
        </trans-unit>
        <trans-unit id="208131f2e00ae33985ce221300cd22605d845623" translate="yes" xml:space="preserve">
          <source>Members of partial specializations are not related to the members of the primary template.</source>
          <target state="translated">Члены частичной специализации не связаны с членами первичного шаблона.</target>
        </trans-unit>
        <trans-unit id="856df469166bb63fb5a5f500f0b2fd7e30149e12" translate="yes" xml:space="preserve">
          <source>Members of specializations</source>
          <target state="translated">Специализации</target>
        </trans-unit>
        <trans-unit id="177c4eb396c6113e03b1ec47971bf87273b4f749" translate="yes" xml:space="preserve">
          <source>Members of the current instantiation may be both dependent and non-dependent.</source>
          <target state="translated">Члены нынешней инстанциии могут быть как зависимыми,так и не зависимыми.</target>
        </trans-unit>
        <trans-unit id="9e686f3fba635d862001096dc688423be262661a" translate="yes" xml:space="preserve">
          <source>Members of unknown specialization are always dependent, and are looked up and bound at the point of instantiation as all dependent names (see above).</source>
          <target state="translated">Члены неизвестной специализации всегда являются зависимыми,и их имена просматриваются и связываются в точке инстанцирования,как и все зависимые имена (см.выше).</target>
        </trans-unit>
        <trans-unit id="b61b70edbe3a97caa2ecb5ac100b7aca209a1cba" translate="yes" xml:space="preserve">
          <source>Memory allocation</source>
          <target state="translated">Распределение памяти</target>
        </trans-unit>
        <trans-unit id="c839b2598611d3f060e76b276a742153340abc1c" translate="yes" xml:space="preserve">
          <source>Memory is released back to the upstream resource even if &lt;code&gt;deallocate&lt;/code&gt; has not been called for some of the allocated blocks.</source>
          <target state="translated">Память высвобождается обратно в восходящий ресурс, даже если для некоторых из выделенных блоков не было &lt;code&gt;deallocate&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bdea69651115220379a7626fdc86765943dcd523" translate="yes" xml:space="preserve">
          <source>Memory leaks</source>
          <target state="translated">Утечка памяти</target>
        </trans-unit>
        <trans-unit id="f8b9af79a08c4c809a8587ce76e5d96c65e611a2" translate="yes" xml:space="preserve">
          <source>Memory location</source>
          <target state="translated">Местоположение памяти</target>
        </trans-unit>
        <trans-unit id="1c5536b98ab016fe61807564b4a34c80211a7613" translate="yes" xml:space="preserve">
          <source>Memory management</source>
          <target state="translated">Управление памятью</target>
        </trans-unit>
        <trans-unit id="ab97ff6f2dba5d3f1cd5aeb9b43d517c7ff39baa" translate="yes" xml:space="preserve">
          <source>Memory model</source>
          <target state="translated">Модель памяти</target>
        </trans-unit>
        <trans-unit id="9c23e8bd787dd8370f724a94edc52271e09548bc" translate="yes" xml:space="preserve">
          <source>Memory model and data races</source>
          <target state="translated">Модель памяти и гонки данных</target>
        </trans-unit>
        <trans-unit id="6b03cc66f3ec38d27d0315d16067b31e093e9aea" translate="yes" xml:space="preserve">
          <source>Memory order</source>
          <target state="translated">Порядок памяти</target>
        </trans-unit>
        <trans-unit id="650d40654b9659dd0612cce810ff5fea98b79081" translate="yes" xml:space="preserve">
          <source>Memory resources</source>
          <target state="translated">Ресурсы памяти</target>
        </trans-unit>
        <trans-unit id="4203c5ba750ba970dd9f023b43c81a0fd337c099" translate="yes" xml:space="preserve">
          <source>Memory resources implement memory allocation strategies that can be used by &lt;code&gt;&lt;a href=&quot;memory/polymorphic_allocator&quot;&gt;std::pmr::polymorphic_allocator&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Ресурсы памяти реализуют стратегии выделения памяти, которые могут использоваться &lt;code&gt;&lt;a href=&quot;memory/polymorphic_allocator&quot;&gt;std::pmr::polymorphic_allocator&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a26524a9138484663e1a18b861e087f36fe4484a" translate="yes" xml:space="preserve">
          <source>Memory synchronization ordering</source>
          <target state="translated">Заказ синхронизации памяти</target>
        </trans-unit>
        <trans-unit id="813e99320a4c03b9ad6cec6f1e925a0b781749db" translate="yes" xml:space="preserve">
          <source>Mergeable</source>
          <target state="translated">Mergeable</target>
        </trans-unit>
        <trans-unit id="e8960ff445c6c6fffe8acbabe2366e4cbf4abc97" translate="yes" xml:space="preserve">
          <source>Merges two consecutive sorted ranges &lt;code&gt;[first, middle)&lt;/code&gt; and &lt;code&gt;[middle, last)&lt;/code&gt; into one sorted range &lt;code&gt;[first, last)&lt;/code&gt;. For equivalent elements in the original two ranges, the elements from the first range (preserving their original order) precede the elements from the second range (preserving their original order).</source>
          <target state="translated">Объединяет два последовательных отсортированных диапазона &lt;code&gt;[first, middle)&lt;/code&gt; и &lt;code&gt;[middle, last)&lt;/code&gt; в один отсортированный диапазон &lt;code&gt;[first, last)&lt;/code&gt; . Для эквивалентных элементов в исходных двух диапазонах элементы из первого диапазона (сохраняя их первоначальный порядок) предшествуют элементам из второго диапазона (сохраняя их первоначальный порядок).</target>
        </trans-unit>
        <trans-unit id="348e4e60780310e575bfb01a962f7cd5abae550b" translate="yes" xml:space="preserve">
          <source>Merges two sorted lists into one. The lists should be sorted into ascending order.</source>
          <target state="translated">Соединяет два отсортированных списка в один.Списки должны быть отсортированы в порядке возрастания.</target>
        </trans-unit>
        <trans-unit id="62e4dd6599b3076f4c7e24d143d22cfe633e9e61" translate="yes" xml:space="preserve">
          <source>Merges two sorted ranges &lt;code&gt;[first1, last1)&lt;/code&gt; and &lt;code&gt;[first2, last2)&lt;/code&gt; into one sorted range beginning at &lt;code&gt;d_first&lt;/code&gt;.</source>
          <target state="translated">Объединяет два отсортированных диапазона &lt;code&gt;[first1, last1)&lt;/code&gt; и &lt;code&gt;[first2, last2)&lt;/code&gt; в один отсортированный диапазон, начиная с &lt;code&gt;d_first&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="be990907531784c554a9a73c087e598fb1ce6368" translate="yes" xml:space="preserve">
          <source>Message too large</source>
          <target state="translated">Сообщение слишком большое</target>
        </trans-unit>
        <trans-unit id="461fdb47a2520c8a10c99484faf4d44d448c8df5" translate="yes" xml:space="preserve">
          <source>Metafunctions and detection idiom</source>
          <target state="translated">Метафункции и идиома обнаружения</target>
        </trans-unit>
        <trans-unit id="07195d88dee403459dfced037630ce1c768e14de" translate="yes" xml:space="preserve">
          <source>Metaprogramming and type traits</source>
          <target state="translated">Метапрограммирование и черты типа</target>
        </trans-unit>
        <trans-unit id="7e4ac6803c9159c694f63d089cb06b2519c16aba" translate="yes" xml:space="preserve">
          <source>Methods</source>
          <target state="translated">Methods</target>
        </trans-unit>
        <trans-unit id="932b125ec81f14231f7250288b48b92b461a8de5" translate="yes" xml:space="preserve">
          <source>Methods and operators</source>
          <target state="translated">Методы и операторы</target>
        </trans-unit>
        <trans-unit id="67dd111ccc6d0d86efc4c55e49ca364b9cb96922" translate="yes" xml:space="preserve">
          <source>Microsoft Visual Studio stores just those three members.</source>
          <target state="translated">В Microsoft Visual Studio хранятся только эти три члена.</target>
        </trans-unit>
        <trans-unit id="47dddb5186287e21994356577aa0866b4c1d8ea3" translate="yes" xml:space="preserve">
          <source>Microsoft also extends the specification of fflush by defining its effects on an input stream: in Visual Studio 2013 and prior, it &lt;a href=&quot;https://docs.microsoft.com/en-us/previous-versions/visualstudio/visual-studio-2013/9yky46tz(v=vs.120)&quot;&gt;discarded the input buffer&lt;/a&gt;, in Visual Studio 2015 and newer, it &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/9yky46tz.aspx&quot;&gt;has no effect, buffers are retained&lt;/a&gt;.</source>
          <target state="translated">Microsoft также расширяет спецификацию fflush, определяя ее влияние на поток ввода: в Visual Studio 2013 и более ранних &lt;a href=&quot;https://docs.microsoft.com/en-us/previous-versions/visualstudio/visual-studio-2013/9yky46tz(v=vs.120)&quot;&gt;версиях&lt;/a&gt; он отбрасывал входной буфер , в Visual Studio 2015 и новее он &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/9yky46tz.aspx&quot;&gt;не действует, буферы сохраняются&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b1e6ca7ba44f07ef77ced3289ef9027ae3985768" translate="yes" xml:space="preserve">
          <source>Minimal incomplete type support for standard containers</source>
          <target state="translated">Минимальная неполная поддержка типа для стандартных контейнеров</target>
        </trans-unit>
        <trans-unit id="039230108efa19823a7b4883634eb496fa5690f9" translate="yes" xml:space="preserve">
          <source>Minimum/maximum operations</source>
          <target state="translated">Минимальные/максимальные операции</target>
        </trans-unit>
        <trans-unit id="5f2cbd107037ed23248e5058a7a64cd6bae05468" translate="yes" xml:space="preserve">
          <source>Miscellaneous</source>
          <target state="translated">Miscellaneous</target>
        </trans-unit>
        <trans-unit id="9f352649528dbc4b941a3c142ba8ef1c7ced2ff5" translate="yes" xml:space="preserve">
          <source>Miscellaneous algorithms and math</source>
          <target state="translated">Различные алгоритмы и математика</target>
        </trans-unit>
        <trans-unit id="7d1b5fe97a66d6423d5658882ed141e544353f5f" translate="yes" xml:space="preserve">
          <source>Miscellaneous transformations</source>
          <target state="translated">Различные преобразования</target>
        </trans-unit>
        <trans-unit id="acace02a8a5c263c4d1a277ad3914f44e1003ded" translate="yes" xml:space="preserve">
          <source>Miscellanous</source>
          <target state="translated">Miscellanous</target>
        </trans-unit>
        <trans-unit id="b2168739b0a770dbc449ab787b7f9985648b3334" translate="yes" xml:space="preserve">
          <source>Mixed categories</source>
          <target state="translated">Смешанные категории</target>
        </trans-unit>
        <trans-unit id="781cc7f1a888cc264c3daec6aa247cc3fa4f8d16" translate="yes" xml:space="preserve">
          <source>Mixing &lt;code&gt;auto&lt;/code&gt; variables and functions in one declaration, as in &lt;code&gt;auto f() -&amp;gt; int, i = 0;&lt;/code&gt; is not allowed.</source>
          <target state="translated">Смешивание &lt;code&gt;auto&lt;/code&gt; переменных и функций в одном объявлении, как в &lt;code&gt;auto f() -&amp;gt; int, i = 0;&lt;/code&gt; не допускается.</target>
        </trans-unit>
        <trans-unit id="a7b93d2128e820f861fc8dfccd9f5521e89ad21f" translate="yes" xml:space="preserve">
          <source>Mode</source>
          <target state="translated">Mode</target>
        </trans-unit>
        <trans-unit id="c8d28082b4fc6c7b86480f164e10796d9ee93fa2" translate="yes" xml:space="preserve">
          <source>Modification of the element denoted by this iterator is permitted, but results in undefined behavior if the resulting value does not satisfy the filter's predicate.</source>
          <target state="translated">Модификация элемента,обозначенного данным итератором,разрешена,но приводит к неопределенному поведению,если результирующее значение не удовлетворяет предикату фильтра.</target>
        </trans-unit>
        <trans-unit id="fde60483a8643008b46b560bb3120711a8d791b9" translate="yes" xml:space="preserve">
          <source>Modification order</source>
          <target state="translated">Порядок изменения</target>
        </trans-unit>
        <trans-unit id="f7d91c2034d3989f0f9d751cdc240eeaa5a1f0bd" translate="yes" xml:space="preserve">
          <source>Modified first or last element</source>
          <target state="translated">Измененный первый или последний элемент</target>
        </trans-unit>
        <trans-unit id="5ae95629e2c8d41b6f08c30afaaf87f67a8aeb67" translate="yes" xml:space="preserve">
          <source>Modified middle only</source>
          <target state="translated">Только модифицированная середина</target>
        </trans-unit>
        <trans-unit id="3a7ea294bf33134dce4b142b8b7182de29b978b2" translate="yes" xml:space="preserve">
          <source>Modifiers</source>
          <target state="translated">Modifiers</target>
        </trans-unit>
        <trans-unit id="4ab3cf9c369166302907228f36238db8a9f5670f" translate="yes" xml:space="preserve">
          <source>Modifies the default formatting for floating-point input/output.</source>
          <target state="translated">Изменяет форматирование по умолчанию для ввода/вывода с плавающей точкой.</target>
        </trans-unit>
        <trans-unit id="15f0dab11aac15b6b8ac3cdd786afb259b8c6d63" translate="yes" xml:space="preserve">
          <source>Modifies the default numeric base for integer I/O.</source>
          <target state="translated">Изменяет числовую базу по умолчанию для целочисленных входов/выходов.</target>
        </trans-unit>
        <trans-unit id="e948b2b964fb2481f64aff925d09ed89d0d5aac5" translate="yes" xml:space="preserve">
          <source>Modifies the default positioning of the fill characters. &lt;code&gt;left&lt;/code&gt; and &lt;code&gt;right&lt;/code&gt; apply to any output, &lt;code&gt;internal&lt;/code&gt; applies to integer, floating-point, and monetary output. Has no effect on input.</source>
          <target state="translated">Изменяет расположение символов заливки по умолчанию. &lt;code&gt;left&lt;/code&gt; и &lt;code&gt;right&lt;/code&gt; применяются к любому выводу, &lt;code&gt;internal&lt;/code&gt; применяются к целочисленному, с плавающей запятой и денежному выводу. Не влияет на ввод.</target>
        </trans-unit>
        <trans-unit id="4f0803b14853f0ca1c462262bd06651312d6fd2a" translate="yes" xml:space="preserve">
          <source>Modifies the integer type. Can be mixed in any order. Only one of each group can be present in type name.</source>
          <target state="translated">Изменяет целочисленный тип.Может смешиваться в любом порядке.В названии типа может присутствовать только одна из каждой группы.</target>
        </trans-unit>
        <trans-unit id="d554ea1e6c13dd8a9b9dcc293f7edfd4d7e0bab2" translate="yes" xml:space="preserve">
          <source>Modifies the point in time &lt;code&gt;*this&lt;/code&gt; represents by one tick of the &lt;code&gt;duration&lt;/code&gt;.</source>
          <target state="translated">Изменяет момент времени &lt;code&gt;*this&lt;/code&gt; представляет собой один тик &lt;code&gt;duration&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ac257bedb96e8a5ed9f2d761616b185ecd321a9f" translate="yes" xml:space="preserve">
          <source>Modifies the time point &lt;code&gt;*this&lt;/code&gt; represents by the duration &lt;code&gt;dy&lt;/code&gt; or &lt;code&gt;dm&lt;/code&gt;.</source>
          <target state="translated">Изменяет момент времени &lt;code&gt;*this&lt;/code&gt; представляет продолжительность &lt;code&gt;dy&lt;/code&gt; или &lt;code&gt;dm&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0109c0f778cd7e5d5f58cdb0bef696d2ed4bfbeb" translate="yes" xml:space="preserve">
          <source>Modifies the time point by the given duration.</source>
          <target state="translated">Изменяет временную точку на заданную длительность.</target>
        </trans-unit>
        <trans-unit id="b99643bd9f016aabf23ffef5df0d85745e624465" translate="yes" xml:space="preserve">
          <source>Modifying sequence operations</source>
          <target state="translated">Изменение последовательности операций</target>
        </trans-unit>
        <trans-unit id="2b3cc44d73da07886ee8baef1ee867321f0ada02" translate="yes" xml:space="preserve">
          <source>Modifying the object references through the returned pointer is undefined behavior.</source>
          <target state="translated">Изменение ссылок на объекты через возвращаемый указатель является неопределенным поведением.</target>
        </trans-unit>
        <trans-unit id="ebfc8aea76355cffda7dc26e5f6ffed8b15e2998" translate="yes" xml:space="preserve">
          <source>Modifying the string returned by &lt;code&gt;getenv&lt;/code&gt; invokes undefined behavior.</source>
          <target state="translated">Изменение строки, возвращаемой &lt;code&gt;getenv&lt;/code&gt; , вызывает неопределенное поведение.</target>
        </trans-unit>
        <trans-unit id="04e9462c0ff02bb9032b92abd45881a3c7e15fb7" translate="yes" xml:space="preserve">
          <source>Modules</source>
          <target state="translated">Modules</target>
        </trans-unit>
        <trans-unit id="5c27456bde155168271b9f0d0a03593e3d004434" translate="yes" xml:space="preserve">
          <source>Modules (since C++20)</source>
          <target state="translated">Модули (с C++20)</target>
        </trans-unit>
        <trans-unit id="87aa2b5a478fd2bc39c2606c02ad3374b1b33a57" translate="yes" xml:space="preserve">
          <source>Modules are orthogonal to &lt;a href=&quot;namespace&quot;&gt;namespaces&lt;/a&gt;.</source>
          <target state="translated">Модули ортогональны &lt;a href=&quot;namespace&quot;&gt;пространствам имен&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="15b644db7c27b8824e56787512daf5e002e08b35" translate="yes" xml:space="preserve">
          <source>Modules help divide large amounts of code into logical parts.</source>
          <target state="translated">Модули помогают разделить большое количество кода на логические части.</target>
        </trans-unit>
        <trans-unit id="ba486ce8a0bc9ff868847c4d17e3966a68af4067" translate="yes" xml:space="preserve">
          <source>Monetary numeric formatting parameters</source>
          <target state="translated">Параметры денежно-цифрового форматирования</target>
        </trans-unit>
        <trans-unit id="082bc378cd60e17a38d99898b21955299c5b60c8" translate="yes" xml:space="preserve">
          <source>Month</source>
          <target state="translated">Month</target>
        </trans-unit>
        <trans-unit id="8a88993f3238117d849d456cb7e4e84ee89d728a" translate="yes" xml:space="preserve">
          <source>Month, day, year (american) order</source>
          <target state="translated">Месяц,день,год (американский)заказ</target>
        </trans-unit>
        <trans-unit id="d08db9b01ebe6924d7a1bf996c9b0ed0b4fab126" translate="yes" xml:space="preserve">
          <source>More formally, &lt;code&gt;nth_element&lt;/code&gt; partially sorts the range &lt;code&gt;[first, last)&lt;/code&gt; in ascending order so that the condition &lt;code&gt;!(*j &amp;lt; *i)&lt;/code&gt; (for (1-2), or &lt;code&gt;comp(*j, *i) == false&lt;/code&gt; for (3-4)) is met for any &lt;code&gt;i&lt;/code&gt; in the range &lt;code&gt;[first, nth)&lt;/code&gt; and for any &lt;code&gt;j&lt;/code&gt; in the range &lt;code&gt;[nth, last)&lt;/code&gt;. The element placed in the &lt;code&gt;nth&lt;/code&gt; position is exactly the element that would occur in this position if the range was fully sorted.</source>
          <target state="translated">Более формально, &lt;code&gt;nth_element&lt;/code&gt; частично сортирует диапазон &lt;code&gt;[first, last)&lt;/code&gt; в порядке возрастания, так что условие &lt;code&gt;!(*j &amp;lt; *i)&lt;/code&gt; (для (1-2) или &lt;code&gt;comp(*j, *i) == false&lt;/code&gt; для ( 3-4)) выполняется для любого &lt;code&gt;i&lt;/code&gt; в диапазоне &lt;code&gt;[first, nth)&lt;/code&gt; и для любого &lt;code&gt;j&lt;/code&gt; в диапазоне &lt;code&gt;[nth, last)&lt;/code&gt; . Элемент, помещенный в &lt;code&gt;nth&lt;/code&gt; позицию, является именно тем элементом, который появился бы в этой позиции, если бы диапазон был полностью отсортирован.</target>
        </trans-unit>
        <trans-unit id="8ad85aba1e03e90f4ea308da91cb434da83f1201" translate="yes" xml:space="preserve">
          <source>More generally, a declaration that appears in any namespace scope and introduces a name using an unqualified identifier always introduces a member into the namespace it's in and not to any other namespace. The exceptions are explicit instantiations and explicit specializations of a primary template that is defined in an inline namespace: because they do not introduce a new name, they may use unqualified-id in an enclosing namespace.</source>
          <target state="translated">В более общем плане,заявление,которое появляется в любом пространстве имён и вводит имя с использованием безоговорочного идентификатора,всегда вводит члена в пространство имён,в котором он находится,а не в любое другое пространство имён.Исключениями являются явные инстанцинации и явные специализации первичного шаблона,который определяется в пространстве имен:поскольку они не вводят новое имя,они могут использовать unqualified-id в закрывающемся пространстве имен.</target>
        </trans-unit>
        <trans-unit id="aced5c6bdae8930320b0a84e8806de43ea20de7e" translate="yes" xml:space="preserve">
          <source>More importantly, when a function has both rvalue reference and lvalue reference &lt;a href=&quot;overload_resolution&quot;&gt;overloads&lt;/a&gt;, the rvalue reference overload binds to rvalues (including both prvalues and xvalues), while the lvalue reference overload binds to lvalues:</source>
          <target state="translated">Что еще более важно, когда функция имеет как &lt;a href=&quot;overload_resolution&quot;&gt;перегруженные&lt;/a&gt; ссылки на rvalue, так и ссылки на lvalue, перегруженная ссылка на rvalue связывается с rvalue (включая как prvalues ​​и xvalues), в то время как ссылочная перегрузка lvalue связывается с lvalue:</target>
        </trans-unit>
        <trans-unit id="042cb75d428b075638d2d6b2981b93fb7100eec4" translate="yes" xml:space="preserve">
          <source>More precisely,</source>
          <target state="translated">Точнее,</target>
        </trans-unit>
        <trans-unit id="12d2d8c92f9d4fd32f5f1106d05e584341d60749" translate="yes" xml:space="preserve">
          <source>More precisely, if &lt;code&gt;T&lt;/code&gt; is an object type, then &lt;code&gt;CopyConstructible&amp;lt;T&amp;gt;&lt;/code&gt; is satisfied only if given.</source>
          <target state="translated">Точнее, если &lt;code&gt;T&lt;/code&gt; является типом объекта, то &lt;code&gt;CopyConstructible&amp;lt;T&amp;gt;&lt;/code&gt; выполняется только в том случае, если он задан.</target>
        </trans-unit>
        <trans-unit id="390ebcb02784fc921ce7255ea43ab7b5c0c22766" translate="yes" xml:space="preserve">
          <source>More precisely, if &lt;code&gt;T&lt;/code&gt; is an object type, then &lt;code&gt;MoveConstructible&amp;lt;T&amp;gt;&lt;/code&gt; is satisfied only if given.</source>
          <target state="translated">Точнее, если &lt;code&gt;T&lt;/code&gt; является типом объекта, тогда &lt;code&gt;MoveConstructible&amp;lt;T&amp;gt;&lt;/code&gt; выполняется только в том случае, если он задан.</target>
        </trans-unit>
        <trans-unit id="abf4cfe7b468de981e652ab471007fe1cf184911" translate="yes" xml:space="preserve">
          <source>Moreover, if a class is</source>
          <target state="translated">Более того,если класс</target>
        </trans-unit>
        <trans-unit id="155edc9b15c11dc21e1b4548edbad4e1215c059f" translate="yes" xml:space="preserve">
          <source>Moreover, the specialization has to be more specialized than the primary template.</source>
          <target state="translated">Кроме того,специализация должна быть более специализированной,чем основной шаблон.</target>
        </trans-unit>
        <trans-unit id="efb9a37b6f75f2498f990faf5ad9f0869a407c15" translate="yes" xml:space="preserve">
          <source>Most algorithms have overloads that accept execution policies. The standard library algorithms support several &lt;a href=&quot;algorithm/execution_policy_tag_t&quot;&gt;execution policies&lt;/a&gt;, and the library provides corresponding execution policy types and objects. Users may select an execution policy statically by invoking a parallel algorithm with an &lt;a href=&quot;algorithm/execution_policy_tag&quot;&gt;execution policy object&lt;/a&gt; of the corresponding type.</source>
          <target state="translated">Большинство алгоритмов имеют перегрузки, которые принимают политики выполнения. Стандартные библиотечные алгоритмы поддерживают несколько &lt;a href=&quot;algorithm/execution_policy_tag_t&quot;&gt;политик выполнения&lt;/a&gt; , а библиотека предоставляет соответствующие типы и объекты политики выполнения. Пользователи могут выбирать политику выполнения статически, вызывая параллельный алгоритм с &lt;a href=&quot;algorithm/execution_policy_tag&quot;&gt;объектом политики&lt;/a&gt; выполнения соответствующего типа.</target>
        </trans-unit>
        <trans-unit id="cc6a96c2bf79396b900217be397fde454fb98507" translate="yes" xml:space="preserve">
          <source>Most concepts in the standard library impose both syntactic and semantic requirements. In general, only the syntactic requirements can be checked by the compiler. If a semantic requirement is not met at the point of use, the program is ill-formed, no diagnostic required.</source>
          <target state="translated">Большинство концепций стандартной библиотеки предъявляют как синтаксические,так и семантические требования.В целом,только синтаксические требования могут быть проверены компилятором.Если семантическое требование не выполняется в месте использования,программа плохо сформирована,диагностика не требуется.</target>
        </trans-unit>
        <trans-unit id="781816a1d277bbc9eb1433baedd102171fdafd77" translate="yes" xml:space="preserve">
          <source>Most containers have at least several member functions in common, and share functionalities. Which container is the best for the particular application depends not only on the offered functionality, but also on its efficiency for different workloads.</source>
          <target state="translated">Большинство контейнеров имеют,по крайней мере,несколько общих функций и имеют общие функции.Какой контейнер лучше всего подходит для конкретного приложения,зависит не только от предлагаемой функциональности,но и от его эффективности для различных рабочих нагрузок.</target>
        </trans-unit>
        <trans-unit id="e62a8c15144afd6bef7aa39651c138fe6e1aae25" translate="yes" xml:space="preserve">
          <source>Most multibyte character encodings use single-byte codes to represent the characters from the ASCII character set. This function may be used to convert such characters to &lt;code&gt;wchar_t&lt;/code&gt;.</source>
          <target state="translated">В большинстве многобайтовых кодировок символов используются однобайтовые коды для представления символов из набора символов ASCII. Эта функция может использоваться для преобразования таких символов в &lt;code&gt;wchar_t&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2c598cbf439c8837b1ca206b16302fc6a8e671f8" translate="yes" xml:space="preserve">
          <source>Most of the classes are templated, so they can be adapted to any basic character type. Separate typedefs are provided for the most common basic character types (&lt;code&gt;char&lt;/code&gt; and &lt;code&gt;wchar_t&lt;/code&gt;). The classes are organized into the following hierarchy:</source>
          <target state="translated">Большинство классов являются шаблонными, поэтому их можно адаптировать к любому базовому типу символов. Отдельные определения типов предоставляются для наиболее распространенных базовых типов символов ( &lt;code&gt;char&lt;/code&gt; и &lt;code&gt;wchar_t&lt;/code&gt; ). Классы организованы в следующую иерархию:</target>
        </trans-unit>
        <trans-unit id="096ace82e91d90831e1c4645b3d45c6185c05537" translate="yes" xml:space="preserve">
          <source>Most statements in a typical C++ program are expression statements, such as assignments or function calls.</source>
          <target state="translated">Большинство выражений в типичной программе на Си++-это выражения,такие как присваивания или вызовы функций.</target>
        </trans-unit>
        <trans-unit id="a2333535991c67ef2e86e131a8535fb756804d7f" translate="yes" xml:space="preserve">
          <source>Movable</source>
          <target state="translated">Movable</target>
        </trans-unit>
        <trans-unit id="0a9ed9691d6eeb1d4822ae73e0c5eadefaad241c" translate="yes" xml:space="preserve">
          <source>Move assignment operator</source>
          <target state="translated">Оператор задания перемещения</target>
        </trans-unit>
        <trans-unit id="47bc76102bfdfe08b85837682799b53a220e67af" translate="yes" xml:space="preserve">
          <source>Move assignment operator. Replaces the contents with those of &lt;code&gt;other&lt;/code&gt; using move semantics.</source>
          <target state="translated">Оператор назначения перемещения. Заменяет содержимое &lt;code&gt;other&lt;/code&gt; используя семантику перемещения.</target>
        </trans-unit>
        <trans-unit id="9faeffa8862f7a244a0700c0596d5af7fc217adc" translate="yes" xml:space="preserve">
          <source>Move assignment operators typically &quot;steal&quot; the resources held by the argument (e.g. pointers to dynamically-allocated objects, file descriptors, TCP sockets, I/O streams, running threads, etc.), rather than make copies of them, and leave the argument in some valid but otherwise indeterminate state. For example, move-assigning from a &lt;code&gt;&lt;a href=&quot;../string/basic_string&quot;&gt;std::string&lt;/a&gt;&lt;/code&gt; or from a &lt;code&gt;&lt;a href=&quot;../container/vector&quot;&gt;std::vector&lt;/a&gt;&lt;/code&gt; may result in the argument being left empty. This is not, however, a guarantee. A move assignment is less, not more restrictively defined than ordinary assignment; where ordinary assignment must leave two copies of data at completion, move assignment is required to leave only one.</source>
          <target state="translated">Операторы присваивания перемещения обычно &amp;laquo;крадут&amp;raquo; ресурсы, удерживаемые аргументом (например, указатели на динамически распределяемые объекты, файловые дескрипторы, сокеты TCP, потоки ввода-вывода, запущенные потоки и т. Д.), А не делают их копии и оставляют аргумент в каком-то действительном, но в остальном неопределенном состоянии. Например, перемещение-присваивание из &lt;code&gt;&lt;a href=&quot;../string/basic_string&quot;&gt;std::string&lt;/a&gt;&lt;/code&gt; или из &lt;code&gt;&lt;a href=&quot;../container/vector&quot;&gt;std::vector&lt;/a&gt;&lt;/code&gt; может привести к тому, что аргумент останется пустым. Это, однако, не гарантия. Назначение перемещения меньше, не более ограничено, чем обычное назначение; если при обычном назначении необходимо оставить две копии данных по завершении, назначение перемещения должно оставить только одну.</target>
        </trans-unit>
        <trans-unit id="389a7c6fdc797b8f1865d27d1759a2d438b0f975" translate="yes" xml:space="preserve">
          <source>Move assigns the file stream &lt;code&gt;other&lt;/code&gt; to &lt;code&gt;*this&lt;/code&gt;, effectively move-assigning both the &lt;code&gt;&lt;a href=&quot;../basic_iostream&quot;&gt;std::basic_iostream&lt;/a&gt;&lt;/code&gt; base class and the associated &lt;code&gt;&lt;a href=&quot;../basic_filebuf&quot;&gt;std::basic_filebuf&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Move назначает поток файлов, &lt;code&gt;other&lt;/code&gt; от &lt;code&gt;*this&lt;/code&gt; , эффективно назначая перемещение как базовому классу &lt;code&gt;&lt;a href=&quot;../basic_iostream&quot;&gt;std::basic_iostream&lt;/a&gt;&lt;/code&gt; и связанному с ним &lt;code&gt;&lt;a href=&quot;../basic_filebuf&quot;&gt;std::basic_filebuf&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="24f428bf7dd6f1e0c847ba71b49720a8f401e750" translate="yes" xml:space="preserve">
          <source>Move assigns the file stream &lt;code&gt;other&lt;/code&gt; to &lt;code&gt;*this&lt;/code&gt;, effectively move-assigning both the &lt;code&gt;&lt;a href=&quot;../basic_istream&quot;&gt;std::basic_istream&lt;/a&gt;&lt;/code&gt; base class and the associated &lt;code&gt;&lt;a href=&quot;../basic_filebuf&quot;&gt;std::basic_filebuf&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Move назначает поток файлов, &lt;code&gt;other&lt;/code&gt; от &lt;code&gt;*this&lt;/code&gt; , эффективно назначая перемещение как базовому классу &lt;code&gt;&lt;a href=&quot;../basic_istream&quot;&gt;std::basic_istream&lt;/a&gt;&lt;/code&gt; и связанному с ним &lt;code&gt;&lt;a href=&quot;../basic_filebuf&quot;&gt;std::basic_filebuf&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="16356f1d24da83c00f7fba21a216c445c97ce389" translate="yes" xml:space="preserve">
          <source>Move assigns the file stream &lt;code&gt;other&lt;/code&gt; to &lt;code&gt;*this&lt;/code&gt;, effectively move-assigning both the &lt;code&gt;&lt;a href=&quot;../basic_ostream&quot;&gt;std::basic_ostream&lt;/a&gt;&lt;/code&gt; base class and the associated &lt;code&gt;&lt;a href=&quot;../basic_filebuf&quot;&gt;std::basic_filebuf&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Move назначает поток файла, &lt;code&gt;other&lt;/code&gt; от &lt;code&gt;*this&lt;/code&gt; , эффективно назначая перемещение как базовому классу &lt;code&gt;&lt;a href=&quot;../basic_ostream&quot;&gt;std::basic_ostream&lt;/a&gt;&lt;/code&gt; и связанному с ним &lt;code&gt;&lt;a href=&quot;../basic_filebuf&quot;&gt;std::basic_filebuf&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="33ed75bd9ae7d7e710f7cb59e2701e5a3f320cb2" translate="yes" xml:space="preserve">
          <source>Move assigns the string stream &lt;code&gt;other&lt;/code&gt; to &lt;code&gt;*this&lt;/code&gt;, effectively move-assigning both the &lt;code&gt;&lt;a href=&quot;../basic_iostream&quot;&gt;std::basic_iostream&lt;/a&gt;&lt;/code&gt; base class and the associated &lt;code&gt;&lt;a href=&quot;../basic_stringbuf&quot;&gt;std::basic_stringbuf&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Move назначает строковый поток, &lt;code&gt;other&lt;/code&gt; от &lt;code&gt;*this&lt;/code&gt; , эффективно назначая &lt;code&gt;&lt;a href=&quot;../basic_iostream&quot;&gt;std::basic_iostream&lt;/a&gt;&lt;/code&gt; базовому классу std :: basic_iostream, так и связанному с ним &lt;code&gt;&lt;a href=&quot;../basic_stringbuf&quot;&gt;std::basic_stringbuf&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8b304cb7e35b160ac11b6e6da6fcb29cbf8bd2ea" translate="yes" xml:space="preserve">
          <source>Move assigns the string stream &lt;code&gt;other&lt;/code&gt; to &lt;code&gt;*this&lt;/code&gt;, effectively move-assigning both the &lt;code&gt;&lt;a href=&quot;../basic_istream&quot;&gt;std::basic_istream&lt;/a&gt;&lt;/code&gt; base class and the associated &lt;code&gt;&lt;a href=&quot;../basic_stringbuf&quot;&gt;std::basic_stringbuf&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Move назначает строковый поток, &lt;code&gt;other&lt;/code&gt; от &lt;code&gt;*this&lt;/code&gt; , эффективно назначая &lt;code&gt;&lt;a href=&quot;../basic_istream&quot;&gt;std::basic_istream&lt;/a&gt;&lt;/code&gt; базовому классу std :: basic_istream, так и связанному с ним &lt;code&gt;&lt;a href=&quot;../basic_stringbuf&quot;&gt;std::basic_stringbuf&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="49accf919a08e0856fd5c2205f087017e46e4554" translate="yes" xml:space="preserve">
          <source>Move assigns the string stream &lt;code&gt;other&lt;/code&gt; to &lt;code&gt;*this&lt;/code&gt;, effectively move-assigning both the &lt;code&gt;&lt;a href=&quot;../basic_ostream&quot;&gt;std::basic_ostream&lt;/a&gt;&lt;/code&gt; base class and the associated &lt;code&gt;&lt;a href=&quot;../basic_stringbuf&quot;&gt;std::basic_stringbuf&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Move назначает строковый поток, &lt;code&gt;other&lt;/code&gt; от &lt;code&gt;*this&lt;/code&gt; , эффективно назначая перемещение как базовому классу &lt;code&gt;&lt;a href=&quot;../basic_ostream&quot;&gt;std::basic_ostream&lt;/a&gt;&lt;/code&gt; и связанному с ним &lt;code&gt;&lt;a href=&quot;../basic_stringbuf&quot;&gt;std::basic_stringbuf&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f3459363ce95b7b8d213432c0b3912511b7bb422" translate="yes" xml:space="preserve">
          <source>Move constructor</source>
          <target state="translated">Конструктор движения</target>
        </trans-unit>
        <trans-unit id="dabcb34f032395075663b5ab1b4ca93fa1b421af" translate="yes" xml:space="preserve">
          <source>Move constructor of &lt;code&gt;A&lt;/code&gt; must not throw exceptions</source>
          <target state="translated">Конструктор Move &lt;code&gt;A&lt;/code&gt; не должен вызывать исключения</target>
        </trans-unit>
        <trans-unit id="76c87719ef4631d051ec31847319db90f2a38c3c" translate="yes" xml:space="preserve">
          <source>Move constructors</source>
          <target state="translated">Конструкторы движения</target>
        </trans-unit>
        <trans-unit id="2a326707754a17c67859bb0d4a68df79e51ee6cb" translate="yes" xml:space="preserve">
          <source>Move constructors are usually noexcept, since otherwise they are unusable in any code that provides strong exception guarantee.</source>
          <target state="translated">Конструкторы движений,как правило,не являются исключением,так как в противном случае они непригодны в любом коде,который предоставляет сильную гарантию исключения.</target>
        </trans-unit>
        <trans-unit id="81267231da879e100dbc03825b8c3e0a2957c4a3" translate="yes" xml:space="preserve">
          <source>Move constructors obtain their instances of allocators by move-constructing from the allocator belonging to the old container.</source>
          <target state="translated">Конструкторы-перемещенцы получают свои экземпляры аллокаторов путем перемещения-конструкции из аллокатора,принадлежащего старому контейнеру.</target>
        </trans-unit>
        <trans-unit id="137fb2f17f31808cc157fa054ef5ad4347edeebc" translate="yes" xml:space="preserve">
          <source>Move constructors typically &quot;steal&quot; the resources held by the argument (e.g. pointers to dynamically-allocated objects, file descriptors, TCP sockets, I/O streams, running threads, etc.) rather than make copies of them, and leave the argument in some valid but otherwise indeterminate state. For example, moving from a &lt;code&gt;&lt;a href=&quot;../string/basic_string&quot;&gt;std::string&lt;/a&gt;&lt;/code&gt; or from a &lt;code&gt;&lt;a href=&quot;../container/vector&quot;&gt;std::vector&lt;/a&gt;&lt;/code&gt; may result in the argument being left empty. However, this behavior should not be relied upon. For some types, such as &lt;code&gt;&lt;a href=&quot;../memory/unique_ptr&quot;&gt;std::unique_ptr&lt;/a&gt;&lt;/code&gt;, the moved-from state is fully specified.</source>
          <target state="translated">Обычно конструкторы перемещения &amp;laquo;крадут&amp;raquo; ресурсы, содержащиеся в аргументе (например, указатели на динамически размещаемые объекты, файловые дескрипторы, сокеты TCP, потоки ввода-вывода, запущенные потоки и т. Д.), А не копируют их и оставляют аргумент в какое-то действительное, но в остальном неопределенное состояние. Например, перемещение из &lt;code&gt;&lt;a href=&quot;../string/basic_string&quot;&gt;std::string&lt;/a&gt;&lt;/code&gt; или из &lt;code&gt;&lt;a href=&quot;../container/vector&quot;&gt;std::vector&lt;/a&gt;&lt;/code&gt; может привести к тому, что аргумент останется пустым. Однако на это поведение нельзя полагаться. Для некоторых типов, таких как &lt;code&gt;&lt;a href=&quot;../memory/unique_ptr&quot;&gt;std::unique_ptr&lt;/a&gt;&lt;/code&gt; , состояние перемещения полностью указано.</target>
        </trans-unit>
        <trans-unit id="a87e8b5e582f2bbe391df33ee67064ce26cb64b8" translate="yes" xml:space="preserve">
          <source>Move semantics make it possible to safely transfer resource ownership between objects, across scopes, and in and out of threads, while maintaining resource safety.</source>
          <target state="translated">Семантика перемещения позволяет безопасно передавать право собственности на ресурсы между объектами,в различных диапазонах,а также внутри и вне потоков,сохраняя при этом безопасность ресурсов.</target>
        </trans-unit>
        <trans-unit id="539161ece173c055968a1a1de35756020b668502" translate="yes" xml:space="preserve">
          <source>Move-assignment will replace the allocator only if &lt;code&gt;&lt;a href=&quot;../memory/allocator_traits&quot;&gt;std::allocator_traits&lt;/a&gt;&amp;lt;allocator_type&amp;gt;::propagate_on_container_move_assignment::value&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;</source>
          <target state="translated">Перемещение-назначение заменит распределитель, только если &lt;code&gt;&lt;a href=&quot;../memory/allocator_traits&quot;&gt;std::allocator_traits&lt;/a&gt;&amp;lt;allocator_type&amp;gt;::propagate_on_container_move_assignment::value&lt;/code&gt; равно &lt;code&gt;true&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2a2b02d69358e93089fbaa89a49b928011b4e236" translate="yes" xml:space="preserve">
          <source>Move-assigns a synchronized output stream:</source>
          <target state="translated">Move-assigns синхронизированный выходной поток:</target>
        </trans-unit>
        <trans-unit id="729a0dfe5f81eedccb7e27b2fac2b5add97556cb" translate="yes" xml:space="preserve">
          <source>MoveAssignable</source>
          <target state="translated">MoveAssignable</target>
        </trans-unit>
        <trans-unit id="502c9efbaad373888b5ccbb225e0b2b8dcc695c1" translate="yes" xml:space="preserve">
          <source>MoveConstructible</source>
          <target state="translated">MoveConstructible</target>
        </trans-unit>
        <trans-unit id="47b28d1ca8cc2963e3c114ddac02f3738d7266e5" translate="yes" xml:space="preserve">
          <source>MoveInsertable</source>
          <target state="translated">MoveInsertable</target>
        </trans-unit>
        <trans-unit id="0cba8c550dfeac021edea6a142972a2b3c4254ac" translate="yes" xml:space="preserve">
          <source>Moves elements from another &lt;code&gt;forward_list&lt;/code&gt; to &lt;code&gt;*this&lt;/code&gt;.</source>
          <target state="translated">Перемещает элементы из другого &lt;code&gt;forward_list&lt;/code&gt; в &lt;code&gt;*this&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f642e2f2760b86f5ae81c771704418f0a85fea71" translate="yes" xml:space="preserve">
          <source>Moves or renames the filesystem object identified by &lt;code&gt;old_p&lt;/code&gt; to &lt;code&gt;new_p&lt;/code&gt; as if by the POSIX &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/rename.html&quot;&gt;rename&lt;/a&gt;:</source>
          <target state="translated">Перемещает или переименовывает объект файловой системы, идентифицируемый &lt;code&gt;old_p&lt;/code&gt; , в &lt;code&gt;new_p&lt;/code&gt; , как будто &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/rename.html&quot;&gt;переименовывает&lt;/a&gt; POSIX :</target>
        </trans-unit>
        <trans-unit id="f8c4f952db4952b742d95751551e39d3d9452537" translate="yes" xml:space="preserve">
          <source>Moves or renames the filesystem object identified by &lt;code&gt;old_p&lt;/code&gt; to &lt;code&gt;new_p&lt;/code&gt; as if by the POSIX &lt;a href=&quot;https://pubs.opengroup.org/onlinepubs/9699919799/functions/rename.html&quot;&gt;rename&lt;/a&gt;:</source>
          <target state="translated">Перемещает или переименовывает объект файловой системы, идентифицированный &lt;code&gt;old_p&lt;/code&gt; , в &lt;code&gt;new_p&lt;/code&gt; , как если бы это было &lt;a href=&quot;https://pubs.opengroup.org/onlinepubs/9699919799/functions/rename.html&quot;&gt;переименованием&lt;/a&gt; POSIX :</target>
        </trans-unit>
        <trans-unit id="78f6470d9b55060017967677bfa10f722a11ccd6" translate="yes" xml:space="preserve">
          <source>Moves the elements from the range &lt;code&gt;[first, last)&lt;/code&gt;, to another range ending at &lt;code&gt;d_last&lt;/code&gt;. The elements are moved in reverse order (the last element is moved first), but their relative order is preserved.</source>
          <target state="translated">Перемещает элементы из диапазона &lt;code&gt;[first, last)&lt;/code&gt; в другой диапазон, заканчивающийся на &lt;code&gt;d_last&lt;/code&gt; . Элементы перемещаются в обратном порядке (последний элемент перемещается первым), но их относительный порядок сохраняется.</target>
        </trans-unit>
        <trans-unit id="502b5aeda54563820fc7b31c565eaaa6bcbf6e12" translate="yes" xml:space="preserve">
          <source>Moves the end of the view back by &lt;code&gt;n&lt;/code&gt; characters.</source>
          <target state="translated">Перемещает конец представления назад на &lt;code&gt;n&lt;/code&gt; символов.</target>
        </trans-unit>
        <trans-unit id="e55336fdb98f11cedfd0e48efbdbb786db1d30e0" translate="yes" xml:space="preserve">
          <source>Moves the file position indicator to the beginning of the given file stream.</source>
          <target state="translated">Перемещает индикатор положения файла в начало данного файлового потока.</target>
        </trans-unit>
        <trans-unit id="2fd746e8e68c6c51da4d2e5d3dd279e473ac3ff3" translate="yes" xml:space="preserve">
          <source>Moves the iterator one level up in the directory hierarchy. Invalidates all copies of the previous value of &lt;code&gt;*this&lt;/code&gt;.</source>
          <target state="translated">Перемещает итератор на один уровень вверх в иерархии каталогов. Делает недействительными все копии предыдущего значения &lt;code&gt;*this&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="725b5a475515852bdc56678fa33e316b36e459ef" translate="yes" xml:space="preserve">
          <source>Moves the start of the view forward by &lt;code&gt;n&lt;/code&gt; characters.</source>
          <target state="translated">Перемещает начало просмотра вперед на &lt;code&gt;n&lt;/code&gt; символов.</target>
        </trans-unit>
        <trans-unit id="7135dfbadfa84a70be0103c96edea84447561b3b" translate="yes" xml:space="preserve">
          <source>Multibyte/wide character conversion</source>
          <target state="translated">Многобайтовое/широкоугольное преобразование символов</target>
        </trans-unit>
        <trans-unit id="737f5043d52ad9a5bf99e386e8ced8ff5c737ec0" translate="yes" xml:space="preserve">
          <source>Multibyte/wide character conversions</source>
          <target state="translated">Многобайтовые/широкоугольные преобразования символов</target>
        </trans-unit>
        <trans-unit id="b816bfbe5973e3f1a932359a517a19fd4cc2d3aa" translate="yes" xml:space="preserve">
          <source>Multicharacter literals were inherited by C from the B programming language. Although not specified by the C or C++ standard, compilers implement multicharacter literals as specified in B: the values of each char in the literal initialize successive bytes of the resulting integer, in big-endian zero-padded right-adjusted order, e.g. the value of &lt;code&gt;'\1'&lt;/code&gt; is &lt;code&gt;0x00000001&lt;/code&gt; and the value of &lt;code&gt;'\1\2\3\4'&lt;/code&gt; is &lt;code&gt;0x01020304&lt;/code&gt;.</source>
          <target state="translated">Литералы с множеством символов были унаследованы C от языка программирования B. Хотя это и не указано в стандарте C или C ++, компиляторы реализуют литералы с несколькими символами, как указано в B: значения каждого символа в литерале инициализируют последовательные байты полученного целого числа в порядке с правильной подстановкой нуля с прямым порядком байтов, например, значением из &lt;code&gt;'\1'&lt;/code&gt; является &lt;code&gt;0x00000001&lt;/code&gt; , а значение &lt;code&gt;'\1\2\3\4'&lt;/code&gt; есть &lt;code&gt;0x01020304&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="00762e90f2d0e1fc656e0809cb403c7716fbb355" translate="yes" xml:space="preserve">
          <source>Multidimensional arrays</source>
          <target state="translated">Многомерные массивы</target>
        </trans-unit>
        <trans-unit id="cf133c71b3c2efeaae5de6091eefa30415ff9388" translate="yes" xml:space="preserve">
          <source>Multimap is an associative container that contains a sorted list of key-value pairs, while permitting multiple entries with the same key. Sorting is done according to the comparison function &lt;code&gt;Compare&lt;/code&gt;, applied to the keys. Search, insertion, and removal operations have logarithmic complexity.</source>
          <target state="translated">Multimap - это ассоциативный контейнер, который содержит отсортированный список пар ключ-значение и разрешает несколько записей с одним и тем же ключом. Сортировка производится по функции сравнения &lt;code&gt;Compare&lt;/code&gt; , примененной к клавишам. Операции поиска, вставки и удаления имеют логарифмическую сложность.</target>
        </trans-unit>
        <trans-unit id="d93c4759f084c66474a537bb4779321a39600e76" translate="yes" xml:space="preserve">
          <source>Multipass guarantee</source>
          <target state="translated">Многопроходная гарантия</target>
        </trans-unit>
        <trans-unit id="8b79533d9d6f933b934e06befaa830db21925807" translate="yes" xml:space="preserve">
          <source>Multiple adjacent bit fields are usually packed together (although this behavior is implementation-defined):</source>
          <target state="translated">Несколько соседних битовых полей обычно упаковываются вместе (хотя такое поведение и определяется реализацией):</target>
        </trans-unit>
        <trans-unit id="8aba9a4022dc2b5b9217a1e0bae22b4f22da6f84" translate="yes" xml:space="preserve">
          <source>Multiple copy elisions may be chained to eliminate multiple copies.</source>
          <target state="translated">Многократные элиминации могут быть прикованы цепью,чтобы исключить несколько копий.</target>
        </trans-unit>
        <trans-unit id="ba8252d9e78468463f91fd69124355d767e70b19" translate="yes" xml:space="preserve">
          <source>Multiple functions in the same scope may have the same name, as long as their parameter lists and, for member functions, cv/ref qualifications are different. This is known as &lt;a href=&quot;overload_resolution&quot;&gt;function overloading&lt;/a&gt;. Function declarations that differ only in the return type and the noexcept specification(since C++17) cannot be overloaded.</source>
          <target state="translated">Несколько функций в одной и той же области действия могут иметь одно и то же имя, если их списки параметров и для функций-членов квалификации cv / ref различны. Это известно как &lt;a href=&quot;overload_resolution&quot;&gt;перегрузка функций&lt;/a&gt; . Объявления функций, которые отличаются только типом возврата и спецификацией noexcept (начиная с C ++ 17), не могут быть перегружены.</target>
        </trans-unit>
        <trans-unit id="19da41d50ad4d265081c36d7f4e65700ca15e75b" translate="yes" xml:space="preserve">
          <source>Multiple namespace blocks with the same name are allowed. All declarations within those blocks are declared in the named scope.</source>
          <target state="translated">Допускается использование нескольких блоков с одним и тем же именем.Все объявления внутри этих блоков объявляются в именованном пространстве.</target>
        </trans-unit>
        <trans-unit id="0ad5548e15a3586c8d471050a4ce94a8e1a22844" translate="yes" xml:space="preserve">
          <source>Multiple overloads of &lt;code&gt;f()&lt;/code&gt; declared before the</source>
          <target state="translated">Множественные перегрузки функции &lt;code&gt;f()&lt;/code&gt; объявлены перед</target>
        </trans-unit>
        <trans-unit id="7732a546fbb87f09193f1be1a7646b62b57f3a87" translate="yes" xml:space="preserve">
          <source>Multiple threads may use &lt;code&gt;fetch_sub&lt;/code&gt; to concurrently process an indexed container.</source>
          <target state="translated">Несколько потоков могут использовать &lt;code&gt;fetch_sub&lt;/code&gt; для одновременной обработки индексированного контейнера.</target>
        </trans-unit>
        <trans-unit id="98b77f5ad932fcd3f371127c2c40dc5f446e3196" translate="yes" xml:space="preserve">
          <source>Multiplication of the largest subnormal number by the number one machine epsilon greater than 1.0 gives the tiny value 0x0.fffffffffffff8p-1022 before rounding, but normal value 1p-1022 after rounding. The implementation used to execute this test (IBM Power7) detects tinyness before rounding.</source>
          <target state="translated">Умножение наибольшего субнормального числа на эпсилон номер один машины больше 1,0 дает крошечное значение 0x0.fffffffffff8p-1022 до округления,но нормальное значение 1p-1022 после округления.Реализация,используемая для выполнения этого теста (IBM Power7),обнаруживает жесткость перед округлением.</target>
        </trans-unit>
        <trans-unit id="3385a32109aa5346add0ca1e71e6f6b9c5a102b4" translate="yes" xml:space="preserve">
          <source>Multiplication, division, and remainder</source>
          <target state="translated">Умножение,деление и остаток</target>
        </trans-unit>
        <trans-unit id="2e1863d77d06e578e88a57a55375c7c7a23d1f8f" translate="yes" xml:space="preserve">
          <source>Multiplicative operators</source>
          <target state="translated">Мультипликативные операторы</target>
        </trans-unit>
        <trans-unit id="4ababc1f5e400d86b62ba5912633f6b986ca9b90" translate="yes" xml:space="preserve">
          <source>Must return a &lt;code&gt;Type&amp;amp;&lt;/code&gt;, and afterwards, &lt;code&gt;p&lt;/code&gt; is equivalent to &lt;code&gt;nullptr&lt;/code&gt;</source>
          <target state="translated">Должен вернуть &lt;code&gt;Type&amp;amp;&lt;/code&gt; , а затем &lt;code&gt;p&lt;/code&gt; эквивалентно &lt;code&gt;nullptr&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b01214e920406c4416e08d1f978fb4406baa93f9" translate="yes" xml:space="preserve">
          <source>Must return a value that is contextually convertible to bool.</source>
          <target state="translated">Нужно вернуть значение,которое контекстуально конвертируется в шерсть.</target>
        </trans-unit>
        <trans-unit id="8d217e2a97fe63fa480adebe696bb142ffa30b17" translate="yes" xml:space="preserve">
          <source>Mutable is used to specify that the member does not affect the externally visible state of the class (as often used for mutexes, memo caches, lazy evaluation, and access instrumentation).</source>
          <target state="translated">Mutable используется для указания,что член не влияет на внешне видимое состояние класса (как часто используется для мьютексов,кэш-памяток,ленивых оценок и инструментов доступа).</target>
        </trans-unit>
        <trans-unit id="bd2b0f087b02e413546a53c4f93f4cdf1581cc30" translate="yes" xml:space="preserve">
          <source>Mutex</source>
          <target state="translated">Mutex</target>
        </trans-unit>
        <trans-unit id="bcf81f2350a4ddaf862acb054f396be56471328b" translate="yes" xml:space="preserve">
          <source>Mutex, the sole type in &lt;code&gt;MutexTypes...&lt;/code&gt;</source>
          <target state="translated">Mutex, единственный тип в &lt;code&gt;MutexTypes...&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="623593159179e7d5bbf03c1ec57146a2c9e50ba8" translate="yes" xml:space="preserve">
          <source>MutexTypes</source>
          <target state="translated">MutexTypes</target>
        </trans-unit>
        <trans-unit id="bd89464f515bc7c1945f885ef807721ee91c256b" translate="yes" xml:space="preserve">
          <source>Mutual exclusion</source>
          <target state="translated">Взаимное исключение</target>
        </trans-unit>
        <trans-unit id="07e8ae8c3cca7c116c9e3ce24998de394a271a66" translate="yes" xml:space="preserve">
          <source>Mutual exclusion algorithms prevent multiple threads from simultaneously accessing shared resources. This prevents data races and provides support for synchronization between threads.</source>
          <target state="translated">Алгоритмы взаимного исключения предотвращают одновременный доступ нескольких потоков к общим ресурсам.Это предотвращает гонки данных и обеспечивает поддержку синхронизации между потоками.</target>
        </trans-unit>
        <trans-unit id="353bddf63f102523e0e94e44ec2f4291ad09b7ae" translate="yes" xml:space="preserve">
          <source>Mutual exclusion locks, such as &lt;code&gt;&lt;a href=&quot;../thread/mutex&quot;&gt;std::mutex&lt;/a&gt;&lt;/code&gt; or &lt;a href=&quot;atomic_flag&quot;&gt;atomic spinlock&lt;/a&gt;, are an example of release-acquire synchronization: when the lock is released by thread A and acquired by thread B, everything that took place in the critical section (before the release) in the context of thread A has to be visible to thread B (after the acquire) which is executing the same critical section.</source>
          <target state="translated">Блокировки взаимного исключения, такие как &lt;code&gt;&lt;a href=&quot;../thread/mutex&quot;&gt;std::mutex&lt;/a&gt;&lt;/code&gt; или &lt;a href=&quot;atomic_flag&quot;&gt;атомарная спин-блокировка&lt;/a&gt; , являются примером синхронизации освобождения-захвата: когда блокировка освобождается потоком A и приобретается потоком B, все, что происходило в критической секции (до выпуска) в контексте потока A должен быть виден поток B (после получения), который выполняет тот же критический раздел.</target>
        </trans-unit>
        <trans-unit id="b51a60734da64be0e618bacbea2865a8a7dcd669" translate="yes" xml:space="preserve">
          <source>N</source>
          <target state="translated">N</target>
        </trans-unit>
        <trans-unit id="ba50285183f637f345b41123255cc7bf40eee6e3" translate="yes" xml:space="preserve">
          <source>N applications of &lt;code&gt;operator/=(path(&quot;..&quot;))&lt;/code&gt;, followed by</source>
          <target state="translated">N приложений &lt;code&gt;operator/=(path(&quot;..&quot;))&lt;/code&gt; , за которым следует</target>
        </trans-unit>
        <trans-unit id="55893568e7cbf1b7a6b29a66a2452f93270c34d9" translate="yes" xml:space="preserve">
          <source>N may be any permutation of a1, ..., aN and</source>
          <target state="translated">N может быть любой перестановкой a1,...,aN и</target>
        </trans-unit>
        <trans-unit id="1250d9586efc9d80cc6c7239aa2177dcff4d7295" translate="yes" xml:space="preserve">
          <source>N op I))))</source>
          <target state="translated">N в I)))</target>
        </trans-unit>
        <trans-unit id="7f15122e3dfe9680a6663ac72323d5f09c66970e" translate="yes" xml:space="preserve">
          <source>N&amp;minus;1 op (E</source>
          <target state="translated">N &amp;minus; 1 op (E</target>
        </trans-unit>
        <trans-unit id="8613cc7937238f206e33227381780a70bc3d7fb9" translate="yes" xml:space="preserve">
          <source>N)</source>
          <target state="translated">N)</target>
        </trans-unit>
        <trans-unit id="8b19c15f1ccf07bf3626b4a8b2548d375ec3fa3f" translate="yes" xml:space="preserve">
          <source>N) is defined as follows:</source>
          <target state="translated">N)определяется следующим образом:</target>
        </trans-unit>
        <trans-unit id="a100c474d11fd67b64c08abc7f23a4a2f4cc1e66" translate="yes" xml:space="preserve">
          <source>N)) for any K where 1 &amp;lt; K+1 = M &amp;le; N</source>
          <target state="translated">N)) для любого K, где 1 &amp;lt;K + 1 = M &amp;le; N</target>
        </trans-unit>
        <trans-unit id="77952d1fe50f676e5e862f5a754bb0d05488449e" translate="yes" xml:space="preserve">
          <source>N)) where</source>
          <target state="translated">N)где</target>
        </trans-unit>
        <trans-unit id="d983d30d3a24dc6620175e14187869fa136530fc" translate="yes" xml:space="preserve">
          <source>N)))</source>
          <target state="translated">N)))</target>
        </trans-unit>
        <trans-unit id="31329860809c98077449f6ad92ec9504b89cb28b" translate="yes" xml:space="preserve">
          <source>N*log(size()+N)), where N is &lt;code&gt;source.size()&lt;/code&gt;.</source>
          <target state="translated">N * log (size () + N)), где N - &lt;code&gt;source.size()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c264d85396033becba7559b9702cd4354a3b890f" translate="yes" xml:space="preserve">
          <source>N-1 op E</source>
          <target state="translated">N-1 на E</target>
        </trans-unit>
        <trans-unit id="39b94b742092e3ba7ac4ebd9524bb1c81f255b00" translate="yes" xml:space="preserve">
          <source>N3922</source>
          <target state="translated">N3922</target>
        </trans-unit>
        <trans-unit id="3978b69456fb978edbba4310d37fe1c6ecb893f4" translate="yes" xml:space="preserve">
          <source>N4387</source>
          <target state="translated">N4387</target>
        </trans-unit>
        <trans-unit id="c44f384c13dc675d729b43652997307ca17e8a2b" translate="yes" xml:space="preserve">
          <source>N&lt;sup&gt;2&lt;/sup&gt;</source>
          <target state="translated">N&lt;sup&gt;2&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="d82a19a46f2f7da0f84cb56740a41e0148eda5c1" translate="yes" xml:space="preserve">
          <source>NAN</source>
          <target state="translated">NAN</target>
        </trans-unit>
        <trans-unit id="f0d1c3c27252776cf6fab5b297dd84293196ad68" translate="yes" xml:space="preserve">
          <source>NRVO</source>
          <target state="translated">NRVO</target>
        </trans-unit>
        <trans-unit id="3ad6166ad6b1dfdf3797d9216ac661a1daea38f8" translate="yes" xml:space="preserve">
          <source>NRVO was mandatory in constant expressions</source>
          <target state="translated">NRVO было обязательным в константных выражениях</target>
        </trans-unit>
        <trans-unit id="065e03753f6454aa1d90a1883ea3bf51044f5c10" translate="yes" xml:space="preserve">
          <source>NTTP</source>
          <target state="translated">NTTP</target>
        </trans-unit>
        <trans-unit id="85476691293312e0eddef863daabeefe9aa5acfc" translate="yes" xml:space="preserve">
          <source>NUL-terminated.</source>
          <target state="translated">NUL-terminated.</target>
        </trans-unit>
        <trans-unit id="eef19c54306daa69eda49c0272623bdb5e2b341f" translate="yes" xml:space="preserve">
          <source>NULL</source>
          <target state="translated">NULL</target>
        </trans-unit>
        <trans-unit id="7929777f461a9c2e7071443c14f9e07d070abdd6" translate="yes" xml:space="preserve">
          <source>NaN values never compare equal to themselves or to other NaN values. Copying a NaN is not required, by IEEE-754, to preserve its bit representation (sign and &lt;a href=&quot;nan.2&quot;&gt;payload&lt;/a&gt;), though most implementation do.</source>
          <target state="translated">Значения NaN никогда не сравниваются равными им или другими значениями NaN. В IEEE-754 копирование NaN не требуется для сохранения его битового представления (знак и &lt;a href=&quot;nan.2&quot;&gt;полезная нагрузка&lt;/a&gt; ), хотя в большинстве реализаций это делается.</target>
        </trans-unit>
        <trans-unit id="709a23220f2c3d64d1e1d6d18c4d5280f8d82fca" translate="yes" xml:space="preserve">
          <source>Name</source>
          <target state="translated">Name</target>
        </trans-unit>
        <trans-unit id="e11bc388c83c1b8b82ae73a235837ab0ef1b8869" translate="yes" xml:space="preserve">
          <source>Name lookup</source>
          <target state="translated">Поиск имени</target>
        </trans-unit>
        <trans-unit id="b6bc7d50b342a34806ee88ab2690eb319c435c81" translate="yes" xml:space="preserve">
          <source>Name lookup and binding are different for</source>
          <target state="translated">Поиск имени и привязка отличаются для</target>
        </trans-unit>
        <trans-unit id="480387aa2ed9cd405fb53a80e0ad8ef0f482feba" translate="yes" xml:space="preserve">
          <source>Name lookup is the procedure by which a &lt;a href=&quot;name&quot;&gt;name&lt;/a&gt;, when encountered in a program, is associated with the &lt;a href=&quot;declarations&quot;&gt;declaration&lt;/a&gt; that introduced it.</source>
          <target state="translated">Поиск имени - это процедура, с помощью которой &lt;a href=&quot;name&quot;&gt;имя&lt;/a&gt; , встречающееся в программе, связывается с &lt;a href=&quot;declarations&quot;&gt;объявлением,&lt;/a&gt; которое его ввело.</target>
        </trans-unit>
        <trans-unit id="5ca9e948abdb518c09be2641fab9cc9d573e48a4" translate="yes" xml:space="preserve">
          <source>Name lookup rules make it impractical to declare operators in global or user-defined namespace that operate on types from the std namespace, e.g. a custom &lt;code&gt;operator&amp;gt;&amp;gt;&lt;/code&gt; or &lt;code&gt;operator+&lt;/code&gt; for &lt;code&gt;&lt;a href=&quot;../container/vector&quot;&gt;std::vector&lt;/a&gt;&lt;/code&gt; or for &lt;code&gt;&lt;a href=&quot;../utility/pair&quot;&gt;std::pair&lt;/a&gt;&lt;/code&gt; (unless the element types of the vector/pair are user-defined types, which would add their namespace to ADL). Such operators would not be looked up from template instantiations, such as the standard library algorithms. See &lt;a href=&quot;dependent_name&quot;&gt;dependent names&lt;/a&gt; for further details.</source>
          <target state="translated">Правила поиска имен делают нецелесообразным объявлять операторы в глобальном или определяемом пользователем пространстве имен, которые работают с типами из пространства имен std, например, пользовательский &lt;code&gt;operator&amp;gt;&amp;gt;&lt;/code&gt; или &lt;code&gt;operator+&lt;/code&gt; для &lt;code&gt;&lt;a href=&quot;../container/vector&quot;&gt;std::vector&lt;/a&gt;&lt;/code&gt; или для &lt;code&gt;&lt;a href=&quot;../utility/pair&quot;&gt;std::pair&lt;/a&gt;&lt;/code&gt; (кроме случаев, когда типы элементов вектор / пара являются пользовательскими типами, которые добавили бы их пространство имен в ADL). Такие операторы не будут рассматриваться в экземплярах шаблонов, таких как стандартные библиотечные алгоритмы. Смотрите &lt;a href=&quot;dependent_name&quot;&gt;зависимые имена&lt;/a&gt; для получения дополнительной информации.</target>
        </trans-unit>
        <trans-unit id="3013f39113916e6419f8088ed3c67869df636b9d" translate="yes" xml:space="preserve">
          <source>Named Return Value Optimization</source>
          <target state="translated">Оптимизация возвратной стоимости</target>
        </trans-unit>
        <trans-unit id="f44438b5a472bd21faa49423e23b1eb88ebdfc5f" translate="yes" xml:space="preserve">
          <source>Named requirements</source>
          <target state="translated">Названные требования</target>
        </trans-unit>
        <trans-unit id="5d20b518c977a68ada4a25be86f69791473df0e8" translate="yes" xml:space="preserve">
          <source>Named sets of such requirements are called</source>
          <target state="translated">Названные наборы таких требований называются</target>
        </trans-unit>
        <trans-unit id="3feb744677b698e301be638132eacb767a8d61ef" translate="yes" xml:space="preserve">
          <source>Named sockets are UNIX domain sockets constructed with &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/socket.html&quot;&gt;socket&lt;/a&gt; and &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/bind.html&quot;&gt;bind&lt;/a&gt; POSIX APIs, which may be used for advanced interprocess communication. In particular, they may be used to transport open file descriptors from one running process to another.</source>
          <target state="translated">Именованные сокеты - это доменные сокеты UNIX, созданные с помощью API-интерфейсов POSIX для &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/socket.html&quot;&gt;сокетов&lt;/a&gt; и &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/bind.html&quot;&gt;связывания&lt;/a&gt; , которые могут использоваться для расширенного межпроцессного взаимодействия. В частности, они могут использоваться для переноса дескрипторов открытых файлов из одного запущенного процесса в другой.</target>
        </trans-unit>
        <trans-unit id="a97e72293967c371e645dc4966907494004b6512" translate="yes" xml:space="preserve">
          <source>Named sockets are UNIX domain sockets constructed with &lt;a href=&quot;https://pubs.opengroup.org/onlinepubs/9699919799/functions/socket.html&quot;&gt;socket&lt;/a&gt; and &lt;a href=&quot;https://pubs.opengroup.org/onlinepubs/9699919799/functions/bind.html&quot;&gt;bind&lt;/a&gt; POSIX APIs, which may be used for advanced interprocess communication. In particular, they may be used to transport open file descriptors from one running process to another.</source>
          <target state="translated">Именованные сокеты - это сокеты домена UNIX, созданные с помощью API-интерфейсов &lt;a href=&quot;https://pubs.opengroup.org/onlinepubs/9699919799/functions/socket.html&quot;&gt;socket&lt;/a&gt; и &lt;a href=&quot;https://pubs.opengroup.org/onlinepubs/9699919799/functions/bind.html&quot;&gt;bind&lt;/a&gt; POSIX, которые могут использоваться для расширенного межпроцессного взаимодействия. В частности, они могут использоваться для передачи дескрипторов открытых файлов от одного запущенного процесса к другому.</target>
        </trans-unit>
        <trans-unit id="2b7c08c3ab75f37e2da656c1aab228f5f3a793b1" translate="yes" xml:space="preserve">
          <source>Names</source>
          <target state="translated">Names</target>
        </trans-unit>
        <trans-unit id="c9b864b84da76323cdde2ab3f20373514e5220f1" translate="yes" xml:space="preserve">
          <source>Names and identifiers</source>
          <target state="translated">Имена и идентификаторы</target>
        </trans-unit>
        <trans-unit id="5dba54e935821f929da3325c377d095d8e0b34ed" translate="yes" xml:space="preserve">
          <source>Names at the top-level namespace scope (file scope in C) that are &lt;code&gt;const&lt;/code&gt; and not &lt;code&gt;extern&lt;/code&gt; have external linkage in C, but internal linkage in C++.</source>
          <target state="translated">Имена в объеме пространства имен верхнего уровня (в области видимости файла C) , которые являются &lt;code&gt;const&lt;/code&gt; , а не &lt;code&gt;extern&lt;/code&gt; имеют внешнее связывание в C, но внутреннее связывание в C ++.</target>
        </trans-unit>
        <trans-unit id="3063d4cd8cda973d2c9e30f2ca7be83f7c01f92d" translate="yes" xml:space="preserve">
          <source>Names encountered in a program are associated with the declarations that introduced them using &lt;a href=&quot;lookup&quot;&gt;name lookup&lt;/a&gt;. Each name is only valid within a part of the program called its &lt;a href=&quot;scope&quot;&gt;scope&lt;/a&gt;. Some names have &lt;a href=&quot;storage_duration&quot;&gt;linkage&lt;/a&gt; which makes them refer to the same entities when they appear in different scopes or translation units.</source>
          <target state="translated">Имена, встречающиеся в программе, связаны с объявлениями, которые вводили их, используя &lt;a href=&quot;lookup&quot;&gt;поиск по имени&lt;/a&gt; . Каждое имя действительно только в той части программы, которая называется &lt;a href=&quot;scope&quot;&gt;областью действия&lt;/a&gt; . Некоторые имена имеют &lt;a href=&quot;storage_duration&quot;&gt;связь,&lt;/a&gt; которая заставляет их ссылаться на одни и те же объекты, когда они появляются в разных областях или единицах перевода.</target>
        </trans-unit>
        <trans-unit id="8a9aa2bab33fd05a2da5d335efe4a2e09b164f3c" translate="yes" xml:space="preserve">
          <source>Names introduced by &lt;a href=&quot;friend&quot;&gt;friend&lt;/a&gt; declarations within a non-local class X become members of the innermost enclosing namespace of X, but they do not become visible to ordinary &lt;a href=&quot;lookup&quot;&gt;name lookup&lt;/a&gt; (neither &lt;a href=&quot;unqualified_lookup&quot;&gt;unqualified&lt;/a&gt; nor &lt;a href=&quot;qualified_lookup&quot;&gt;qualified&lt;/a&gt;) unless a matching declaration is provided at namespace scope, either before or after the class definition. Such name may be found through &lt;a href=&quot;adl&quot;&gt;ADL&lt;/a&gt; which considers both namespaces and classes.</source>
          <target state="translated">Имена, введенные объявлениями &lt;a href=&quot;friend&quot;&gt;друзей&lt;/a&gt; в нелокальном классе X, становятся членами внутреннего вложенного пространства имен X, но они не становятся видимыми для обычного &lt;a href=&quot;lookup&quot;&gt;поиска имен&lt;/a&gt; (ни &lt;a href=&quot;unqualified_lookup&quot;&gt;неквалифицированного,&lt;/a&gt; ни &lt;a href=&quot;qualified_lookup&quot;&gt;квалифицированного&lt;/a&gt; ), если в области пространства имен не предоставлено соответствующее объявление или после определения класса. Такое имя можно найти через &lt;a href=&quot;adl&quot;&gt;ADL,&lt;/a&gt; который учитывает как пространства имен, так и классы.</target>
        </trans-unit>
        <trans-unit id="c1935b005dc184ad84620c13afec466318085ca9" translate="yes" xml:space="preserve">
          <source>Names introduced into a namespace scope by a using-declaration can be used just like any other names, including qualified lookup from other scopes:</source>
          <target state="translated">Имена,вводимые в область пространства имен посредством use-declaration,могут использоваться так же,как и любые другие имена,включая квалифицированный поиск в других областях:</target>
        </trans-unit>
        <trans-unit id="abc354041c1ad60236f2a24daaf11e19bd038ee8" translate="yes" xml:space="preserve">
          <source>Names of &lt;a href=&quot;../language/reference&quot;&gt;rvalue reference&lt;/a&gt; variables are &lt;a href=&quot;../language/value_category&quot;&gt;lvalues&lt;/a&gt; and have to be converted to &lt;a href=&quot;../language/value_category&quot;&gt;xvalues&lt;/a&gt; to be bound to the function overloads that accept rvalue reference parameters, which is why &lt;a href=&quot;../language/move_constructor&quot;&gt;move constructors&lt;/a&gt; and &lt;a href=&quot;../language/move_operator&quot;&gt;move assignment operators&lt;/a&gt; typically use &lt;code&gt;std::move&lt;/code&gt;:</source>
          <target state="translated">Имена &lt;a href=&quot;../language/reference&quot;&gt;ссылочных&lt;/a&gt; переменных rvalue являются &lt;a href=&quot;../language/value_category&quot;&gt;lvalues&lt;/a&gt; и должны быть преобразованы в &lt;a href=&quot;../language/value_category&quot;&gt;xvalue&lt;/a&gt; для привязки к перегрузкам функций, которые принимают ссылочные параметры rvalue, поэтому &lt;a href=&quot;../language/move_constructor&quot;&gt;конструкторы &lt;/a&gt;&lt;a href=&quot;../language/move_operator&quot;&gt;перемещения&lt;/a&gt; и операторы присваивания перемещения обычно используют &lt;code&gt;std::move&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="db1e5452b458ffc1ce5b7de086a71fa73749c0e6" translate="yes" xml:space="preserve">
          <source>Names of &lt;code&gt;thread_local&lt;/code&gt; variables with internal or external linkage referred from different scopes may refer to the same or to different instances depending on whether the code is executing in the same or in different threads.</source>
          <target state="translated">Имена переменных &lt;code&gt;thread_local&lt;/code&gt; с внутренней или внешней связью, на которые ссылаются разные области, могут относиться к одному и тому же или к разным экземплярам в зависимости от того, выполняется ли код в одном и том же или в разных потоках.</target>
        </trans-unit>
        <trans-unit id="e8dae2c410db83e5bd98bf3a1359488efbedbb6b" translate="yes" xml:space="preserve">
          <source>Names of any class members can only be used in four contexts:</source>
          <target state="translated">Имена любых членов класса могут использоваться только в четырех контекстах:</target>
        </trans-unit>
        <trans-unit id="b43957c55d7ffebeb7c1698dd30daec7bfa5f9cc" translate="yes" xml:space="preserve">
          <source>Names that appear in expression-list or brace-init-list are evaluated in scope of the constructor:</source>
          <target state="translated">Имена,которые появляются в expression-list или brace-init-list,оцениваются в рамках конструктора:</target>
        </trans-unit>
        <trans-unit id="68a7b15b97ad42eb5d4cb110e1e2208e8db49ff3" translate="yes" xml:space="preserve">
          <source>Namespace &lt;code&gt;std::regex_constants&lt;/code&gt;</source>
          <target state="translated">Пространство имен &lt;code&gt;std::regex_constants&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="69aee25fb2b7251f96c077bac9928b36b2f0092d" translate="yes" xml:space="preserve">
          <source>Namespace alias</source>
          <target state="translated">Псевдоним пространства имён</target>
        </trans-unit>
        <trans-unit id="15feeecb0e0bd445b4ec4c17a571fe55224d4791" translate="yes" xml:space="preserve">
          <source>Namespace aliases</source>
          <target state="translated">Псевдонимы пространства имён</target>
        </trans-unit>
        <trans-unit id="9d3514105c3b51acfe33dab56a9ad9112ffd5783" translate="yes" xml:space="preserve">
          <source>Namespace aliases allow the programmer to define an alternate name for a namespace.</source>
          <target state="translated">Псевдонимы пространства имен позволяют программисту определить альтернативное имя для пространства имен.</target>
        </trans-unit>
        <trans-unit id="e8ea1a0aa60760b378411518c66664dc0aebf042" translate="yes" xml:space="preserve">
          <source>Namespace declaration</source>
          <target state="translated">Декларация пространства имён</target>
        </trans-unit>
        <trans-unit id="1a0de11ba24e7fe94cf87f5c813cc5958139da55" translate="yes" xml:space="preserve">
          <source>Namespace definition</source>
          <target state="translated">Определение пространства имён</target>
        </trans-unit>
        <trans-unit id="7abe5aadb217584bf97533759728f989dd4a7122" translate="yes" xml:space="preserve">
          <source>Namespace definitions are only allowed at namespace scope, including the global scope.</source>
          <target state="translated">Определения пространства имён допускаются только в пределах пространства имён,в том числе в глобальном масштабе.</target>
        </trans-unit>
        <trans-unit id="b2fb3696d13cbe0ff41f03594167b5ebd95c58c5" translate="yes" xml:space="preserve">
          <source>Namespace members</source>
          <target state="translated">Участники пространства имён</target>
        </trans-unit>
        <trans-unit id="6ef4650b141111ec251678ed3bf718413e6ab572" translate="yes" xml:space="preserve">
          <source>Namespace scope</source>
          <target state="translated">Область применения пространства имён</target>
        </trans-unit>
        <trans-unit id="98cc70f9e7340456a64ac9fdf7b1eede2f30a8e3" translate="yes" xml:space="preserve">
          <source>Namespace-scope anonymous unions must be declared static unless they appear in an unnamed namespace.</source>
          <target state="translated">Анонимные союзы в пространстве имён должны быть объявлены статическими,если только они не появляются в безымянном пространстве имён.</target>
        </trans-unit>
        <trans-unit id="be09a63bd1995e99cd22064cdc39a4bae464033d" translate="yes" xml:space="preserve">
          <source>Namespaces</source>
          <target state="translated">Namespaces</target>
        </trans-unit>
        <trans-unit id="6ade31b5444def27ab30c5c64abc17a78b593fc9" translate="yes" xml:space="preserve">
          <source>Namespaces provide a method for preventing name conflicts in large projects.</source>
          <target state="translated">Пространства имен обеспечивают метод предотвращения конфликтов имен в больших проектах.</target>
        </trans-unit>
        <trans-unit id="8655490bdfd99b50e55540721bde65050a10ca66" translate="yes" xml:space="preserve">
          <source>Narrow and wide orientation</source>
          <target state="translated">Узкая и широкая ориентация</target>
        </trans-unit>
        <trans-unit id="d6f5cbdcb5ba2c44829f73b263418c7c018a552d" translate="yes" xml:space="preserve">
          <source>Narrow character</source>
          <target state="translated">Узкий характер</target>
        </trans-unit>
        <trans-unit id="00612e7ff2b16d807e5421756762dc8ce833f708" translate="yes" xml:space="preserve">
          <source>Narrow/multibyte character</source>
          <target state="translated">Узкий/мультибайтовый характер</target>
        </trans-unit>
        <trans-unit id="02ec8760336fb09c698a2687c11d370174266ee2" translate="yes" xml:space="preserve">
          <source>Narrowing conversions</source>
          <target state="translated">Сужающиеся преобразования</target>
        </trans-unit>
        <trans-unit id="aa2311a58a83585cb18d67d0ab7bfd5d14fb5130" translate="yes" xml:space="preserve">
          <source>Narrowing is always successful and is always reversible (by calling &lt;code&gt;&lt;a href=&quot;widen&quot;&gt;widen()&lt;/a&gt;&lt;/code&gt;) for all characters from the basic source character set (latin letters, digits, and punctuations required to write a C++ program).</source>
          <target state="translated">Сужение всегда успешно и всегда обратимо (вызывая &lt;code&gt;&lt;a href=&quot;widen&quot;&gt;widen()&lt;/a&gt;&lt;/code&gt; ) для всех символов из основного исходного набора символов (латинские буквы, цифры и знаки препинания, необходимые для написания программы на C ++).</target>
        </trans-unit>
        <trans-unit id="d58074e0c552f383bd0ec261612a709f3413f4a1" translate="yes" xml:space="preserve">
          <source>Narrowing of any digit character guarantees that if the result is subtracted from the character literal &lt;code&gt;'0'&lt;/code&gt;, the difference equals the digit value of the original character.</source>
          <target state="translated">Сужение любого символа цифры гарантирует, что если результат вычитается из буквального символа &lt;code&gt;'0'&lt;/code&gt; , разница равна значению цифры исходного символа.</target>
        </trans-unit>
        <trans-unit id="8dbe486ad6ba7275ed9b6d093c1f795836a5e22a" translate="yes" xml:space="preserve">
          <source>Narrowing, if successful, preserves all character classification categories known to &lt;code&gt;&lt;a href=&quot;is&quot;&gt;is()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Сужение, в случае успеха, сохраняет все известные категории классификации символов &lt;code&gt;&lt;a href=&quot;is&quot;&gt;is()&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6a4742e8a9730fb2d9ea65a3e7a57cdd49ba4360" translate="yes" xml:space="preserve">
          <source>Narrows a wide character &lt;code&gt;c&lt;/code&gt; if its multibyte character equivalent in the initial shift state is a single byte.</source>
          <target state="translated">Сужает широкий символ &lt;code&gt;c&lt;/code&gt; , если его многобайтовый символ, эквивалентный в начальном состоянии сдвига, является одним байтом.</target>
        </trans-unit>
        <trans-unit id="e856674ce1f8ad1d8b857f019d9b05cec7538227" translate="yes" xml:space="preserve">
          <source>Native handle</source>
          <target state="translated">оригинальная ручка</target>
        </trans-unit>
        <trans-unit id="db030e0b7158dfda8f21b860c6287b6a5341fd7b" translate="yes" xml:space="preserve">
          <source>Native pathname format</source>
          <target state="translated">собственный формат патнамента</target>
        </trans-unit>
        <trans-unit id="ca5b116732b30e4ee615a6e0c70fc845595ecbca" translate="yes" xml:space="preserve">
          <source>Nearest integer floating point operations</source>
          <target state="translated">Ближайшие операции с плавающей точкой с целочисленными числами</target>
        </trans-unit>
        <trans-unit id="dfaab505f47d58982ff129c9d7d12a74d6eb3cc8" translate="yes" xml:space="preserve">
          <source>Negative value if &lt;code&gt;lhs&lt;/code&gt; appears before &lt;code&gt;rhs&lt;/code&gt; in lexicographical order.</source>
          <target state="translated">Отрицательное значение, если &lt;code&gt;lhs&lt;/code&gt; появляется перед &lt;code&gt;rhs&lt;/code&gt; в лексикографическом порядке.</target>
        </trans-unit>
        <trans-unit id="87491531316873a8136087161a4d5513bf956b22" translate="yes" xml:space="preserve">
          <source>Negative value if &lt;code&gt;lhs&lt;/code&gt; is</source>
          <target state="translated">Отрицательное значение , если &lt;code&gt;lhs&lt;/code&gt; является</target>
        </trans-unit>
        <trans-unit id="273543511f403081caee3e55984dd6ca3f79876b" translate="yes" xml:space="preserve">
          <source>Negative value if &lt;code&gt;s1&lt;/code&gt; is</source>
          <target state="translated">Отрицательное значение , если &lt;code&gt;s1&lt;/code&gt; является</target>
        </trans-unit>
        <trans-unit id="ceca0034b729fc521079379a02d62ac4de8dc88a" translate="yes" xml:space="preserve">
          <source>Negative value if the first differing byte (reinterpreted as &lt;code&gt;unsigned char&lt;/code&gt;) in &lt;code&gt;lhs&lt;/code&gt; is less than the corresponding byte in &lt;code&gt;rhs&lt;/code&gt;.</source>
          <target state="translated">Отрицательное значение, если первый различающийся байт (переосмысленный как &lt;code&gt;unsigned char&lt;/code&gt; ) в &lt;code&gt;lhs&lt;/code&gt; меньше соответствующего байта в &lt;code&gt;rhs&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="282e0a77a7206269a1ec03af267a85cf22416793" translate="yes" xml:space="preserve">
          <source>Negative value if the value of the first differing wide character in &lt;code&gt;lhs&lt;/code&gt; is less than the value of the corresponding wide character in &lt;code&gt;rhs&lt;/code&gt;: &lt;code&gt;lhs&lt;/code&gt; precedes &lt;code&gt;rhs&lt;/code&gt; in lexicographical order.</source>
          <target state="translated">Отрицательное значение, если значение первого различающегося широкого символа в &lt;code&gt;lhs&lt;/code&gt; меньше, чем значение соответствующего широкого символа в &lt;code&gt;rhs&lt;/code&gt; : &lt;code&gt;lhs&lt;/code&gt; предшествует &lt;code&gt;rhs&lt;/code&gt; в лексикографическом порядке.</target>
        </trans-unit>
        <trans-unit id="f8dce9bcbeee998252a5f32963f3424cf3f7e0d3" translate="yes" xml:space="preserve">
          <source>Negators</source>
          <target state="translated">Negators</target>
        </trans-unit>
        <trans-unit id="f7a7b461a2da4ad85b1265cf9c4d04f21c5ffddb" translate="yes" xml:space="preserve">
          <source>Nested allocator class</source>
          <target state="translated">Вложенный класс аллокатора</target>
        </trans-unit>
        <trans-unit id="25e8c5172b7e5d7b584594533302eddfd95e8bc0" translate="yes" xml:space="preserve">
          <source>Nested class declarations obey &lt;a href=&quot;access&quot;&gt;member access&lt;/a&gt; specifiers, a private member class cannot be named outside the scope of the enclosing class, although objects of that class may be manipulated:</source>
          <target state="translated">Вложенные объявления классов подчиняются спецификаторам &lt;a href=&quot;access&quot;&gt;доступа членов&lt;/a&gt; , закрытый класс-член не может быть назван вне области действия включающего класса, хотя объектами этого класса можно манипулировать:</target>
        </trans-unit>
        <trans-unit id="65046fcf73f5e6ac3773f70ea1badbd965d975c0" translate="yes" xml:space="preserve">
          <source>Nested classes</source>
          <target state="translated">Вложенные классы</target>
        </trans-unit>
        <trans-unit id="1b5839fbae7339935c12e6b4b66fd2e922b275ad" translate="yes" xml:space="preserve">
          <source>Nested classes can be forward-declared and later defined, either within the same enclosing class body, or outside of it:</source>
          <target state="translated">Вложенные классы могут быть объявлены вперед и определены позже,либо в пределах одного и того же тела вложенного класса,либо вне его:</target>
        </trans-unit>
        <trans-unit id="64808f48e8bd759c2c2b1d7832534e1bd54d3712" translate="yes" xml:space="preserve">
          <source>Nested requirements</source>
          <target state="translated">Вложенные требования</target>
        </trans-unit>
        <trans-unit id="ea849e260b8735345217e4f53f113c9fcde5b394" translate="yes" xml:space="preserve">
          <source>Network is down</source>
          <target state="translated">Сеть не работает</target>
        </trans-unit>
        <trans-unit id="72752d57c3c282cc523b7154bbf54840e4683a46" translate="yes" xml:space="preserve">
          <source>Network unreachable</source>
          <target state="translated">Сеть недоступна</target>
        </trans-unit>
        <trans-unit id="80c3052d33ccdee15ffaaa110c5c39072495fe63" translate="yes" xml:space="preserve">
          <source>Never</source>
          <target state="translated">Never</target>
        </trans-unit>
        <trans-unit id="3c4e963fe5e99296e8a4ab9dc3cfa9311f0e21c6" translate="yes" xml:space="preserve">
          <source>New operators such as &lt;code&gt;**&lt;/code&gt;, &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt;, or &lt;code&gt;&amp;amp;|&lt;/code&gt; cannot be created.</source>
          <target state="translated">Новые операторы, такие как &lt;code&gt;**&lt;/code&gt; , &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; или &lt;code&gt;&amp;amp;|&lt;/code&gt; не может быть создано.</target>
        </trans-unit>
        <trans-unit id="ede4611858dc430c3ea6396ebc14993ab64f79d1" translate="yes" xml:space="preserve">
          <source>New-expressions are allowed to elide or combine allocations made through replaceable allocation functions. In case of elision, the storage may be provided by the compiler without making the call to an allocation function (this also permits optimizing out unused new-expression). In case of combining, the allocation made by a new-expression E1 may be extended to provide additional storage for another new-expression E2 if all of the following is true:</source>
          <target state="translated">Новым выражениям разрешается исключать или объединять назначения,сделанные с помощью сменных функций распределения.В случае elision,хранилище может быть предоставлено компилятором без вызова функции выделения (это также позволяет оптимизировать неиспользуемые выражения).В случае объединения,выделение,сделанное новым выражением E1,может быть расширено для обеспечения дополнительного хранилища для другого нового выражения E2,если все нижеследующее верно:</target>
        </trans-unit>
        <trans-unit id="493d0f0040b36ea8241324dced2e890dfb4b6119" translate="yes" xml:space="preserve">
          <source>Newer &quot;Minimum standard&quot;, recommended by Park, Miller, and Stockmeyer in 1993.</source>
          <target state="translated">Новый &quot;Минимальный стандарт&quot;,рекомендованный Парком,Миллером и Стокмайером в 1993 году.</target>
        </trans-unit>
        <trans-unit id="79ac146d5b7ee7fd72cce1790f7da1b8a2f032a2" translate="yes" xml:space="preserve">
          <source>Newlines are kept, and it's unspecified whether non-newline whitespace sequences may be collapsed into single space characters.</source>
          <target state="translated">Новые строки сохраняются,и неясно,могут ли не новострочные последовательности пробельных символов разбиваться на однопробелые.</target>
        </trans-unit>
        <trans-unit id="de67bdd002151bf79b109ea669e76942392196e1" translate="yes" xml:space="preserve">
          <source>Niebloids</source>
          <target state="translated">Niebloids</target>
        </trans-unit>
        <trans-unit id="816c52fd2bdd94a63cd0944823a6c0aa9384c103" translate="yes" xml:space="preserve">
          <source>No</source>
          <target state="translated">No</target>
        </trans-unit>
        <trans-unit id="f130b9c617343f8c039eb502e65e2bfe55e02212" translate="yes" xml:space="preserve">
          <source>No STREAM resources</source>
          <target state="translated">Нет СТРИМ-ресурсов</target>
        </trans-unit>
        <trans-unit id="7dd7bd839e3806d4920233a25bbd072dba9f30a1" translate="yes" xml:space="preserve">
          <source>No additional synchronization guarantees other than what's already provided by shared state.</source>
          <target state="translated">Никаких дополнительных гарантий синхронизации,кроме того,что уже предоставлено общим государством.</target>
        </trans-unit>
        <trans-unit id="6bcc62e49c9ca3ab05ca96f0f3e27fde373feffa" translate="yes" xml:space="preserve">
          <source>No bounds checking is performed: the behavior is undefined if &lt;code&gt;pos &amp;gt;= size()&lt;/code&gt;.</source>
          <target state="translated">Проверка границ не выполняется: поведение не определено, если &lt;code&gt;pos &amp;gt;= size()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e792e65ee8a80fd8989ad1b66325f180ccd8b365" translate="yes" xml:space="preserve">
          <source>No buffer space available</source>
          <target state="translated">Нет буферного пространства</target>
        </trans-unit>
        <trans-unit id="099e11888438840a8566c983d5b1e6de2dad8524" translate="yes" xml:space="preserve">
          <source>No child processes</source>
          <target state="translated">Детские процессы</target>
        </trans-unit>
        <trans-unit id="8959031a2aef1c7c15f7657b554e13b4559478e9" translate="yes" xml:space="preserve">
          <source>No destructors for automatic objects are called. If replacing of &lt;code&gt;std::longjmp&lt;/code&gt; with &lt;code&gt;throw&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;setjmp&quot;&gt;setjmp&lt;/a&gt;&lt;/code&gt; with &lt;code&gt;catch&lt;/code&gt; would execute a non-trivial destructor for any automatic object, the behavior of such &lt;code&gt;std::longjmp&lt;/code&gt; is undefined.</source>
          <target state="translated">Деструкторы для автоматических объектов не называются. Если замена &lt;code&gt;std::longjmp&lt;/code&gt; на &lt;code&gt;throw&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;setjmp&quot;&gt;setjmp&lt;/a&gt;&lt;/code&gt; на &lt;code&gt;catch&lt;/code&gt; будет выполнять нетривиальный деструктор для любого автоматического объекта, поведение такого &lt;code&gt;std::longjmp&lt;/code&gt; не определено.</target>
        </trans-unit>
        <trans-unit id="b7ad248d7445e862eb6d5aac0fef62ca217cfdbf" translate="yes" xml:space="preserve">
          <source>No elements are copied or moved, only the internal pointers of the container nodes are repointed. All pointers and references to the transferred elements remain valid, but now refer into &lt;code&gt;*this&lt;/code&gt;, not into &lt;code&gt;source&lt;/code&gt;.</source>
          <target state="translated">Элементы не копируются и не перемещаются, только внутренние указатели узлов контейнера переопределяются. Все указатели и ссылки на переданные элементы остаются действительными, но теперь ссылаются на &lt;code&gt;*this&lt;/code&gt; , а не на &lt;code&gt;source&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a9ae4f5756c09ebfc4d7b62cc8ca55e5eb9ed890" translate="yes" xml:space="preserve">
          <source>No elements are copied or moved, only the internal pointers of the container nodes are repointed. All pointers and references to the transferred elements remain valid, but now refer into &lt;code&gt;*this&lt;/code&gt;, not into &lt;code&gt;source&lt;/code&gt;. Iterators referring to the transferred elements and all iterators referring to &lt;code&gt;*this&lt;/code&gt; are invalidated.</source>
          <target state="translated">Элементы не копируются и не перемещаются, только внутренние указатели узлов контейнера переопределяются. Все указатели и ссылки на переданные элементы остаются действительными, но теперь ссылаются на &lt;code&gt;*this&lt;/code&gt; , а не на &lt;code&gt;source&lt;/code&gt; . Итераторы, ссылающиеся на переданные элементы, и все итераторы, ссылающиеся на &lt;code&gt;*this&lt;/code&gt; , становятся недействительными.</target>
        </trans-unit>
        <trans-unit id="cc3224dd2db8f1be53245ed8d7053751754bb987" translate="yes" xml:space="preserve">
          <source>No elements are copied or moved, only the internal pointers of the list nodes are re-pointed. The behavior is undefined if: &lt;code&gt;get_allocator() != other.get_allocator()&lt;/code&gt;. No iterators or references become invalidated, the iterators to moved elements remain valid, but now refer into &lt;code&gt;*this&lt;/code&gt;, not into &lt;code&gt;other&lt;/code&gt;.</source>
          <target state="translated">Элементы не копируются и не перемещаются, только внутренние указатели узлов списка перенаправляются. Поведение не определено, если: &lt;code&gt;get_allocator() != other.get_allocator()&lt;/code&gt; . Никакие итераторы или ссылки не становятся недействительными, итераторы для перемещенных элементов остаются действительными, но теперь ссылаются на &lt;code&gt;*this&lt;/code&gt; , а не на &lt;code&gt;other&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a446797facd648759f6798d6324eb89c747b63a0" translate="yes" xml:space="preserve">
          <source>No elements are copied. &lt;code&gt;pos&lt;/code&gt; must be either a deferenceable valid iterator into &lt;code&gt;*this&lt;/code&gt; or the &lt;code&gt;&lt;a href=&quot;before_begin&quot;&gt;before_begin()&lt;/a&gt;&lt;/code&gt; iterator (in particular, &lt;code&gt;&lt;a href=&quot;end&quot;&gt;end()&lt;/a&gt;&lt;/code&gt; is not a valid argument for &lt;code&gt;pos&lt;/code&gt;). The behavior is undefined if &lt;code&gt;get_allocator() != other.get_allocator()&lt;/code&gt;. No iterators or references become invalidated, the iterators to the moved elements now refer into &lt;code&gt;*this&lt;/code&gt;, not into &lt;code&gt;other&lt;/code&gt;.</source>
          <target state="translated">Элементы не копируются. &lt;code&gt;pos&lt;/code&gt; должен быть либо достойным действительным итератором в &lt;code&gt;*this&lt;/code&gt; , либо итератором &lt;code&gt;&lt;a href=&quot;before_begin&quot;&gt;before_begin()&lt;/a&gt;&lt;/code&gt; (в частности, &lt;code&gt;&lt;a href=&quot;end&quot;&gt;end()&lt;/a&gt;&lt;/code&gt; не является допустимым аргументом для &lt;code&gt;pos&lt;/code&gt; ). Поведение не определено, если &lt;code&gt;get_allocator() != other.get_allocator()&lt;/code&gt; . Никакие итераторы или ссылки не становятся недействительными, итераторы перемещенных элементов теперь ссылаются на &lt;code&gt;*this&lt;/code&gt; , а не на &lt;code&gt;other&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="978b5fdcd4067d166cd18666eaf43106a672a214" translate="yes" xml:space="preserve">
          <source>No elements are copied. The container &lt;code&gt;other&lt;/code&gt; becomes empty after the operation. The function does nothing if &lt;code&gt;other&lt;/code&gt; refers to the same object as &lt;code&gt;*this&lt;/code&gt;. If &lt;code&gt;get_allocator() != other.get_allocator()&lt;/code&gt;, the behavior is undefined. No iterators or references become invalidated, except that the iterators of moved elements now refer into &lt;code&gt;*this&lt;/code&gt;, not into &lt;code&gt;other&lt;/code&gt;. The first version uses &lt;code&gt;operator&amp;lt;&lt;/code&gt; to compare the elements, the second version uses the given comparison function &lt;code&gt;comp&lt;/code&gt;.</source>
          <target state="translated">Элементы не копируются. Контейнер &lt;code&gt;other&lt;/code&gt; становится пустым после операции. Функция ничего не делает, если &lt;code&gt;other&lt;/code&gt; ссылаются на тот же объект, что и &lt;code&gt;*this&lt;/code&gt; . Если &lt;code&gt;get_allocator() != other.get_allocator()&lt;/code&gt; , поведение не определено. Никакие итераторы или ссылки не становятся недействительными, за исключением того, что итераторы перемещенных элементов теперь ссылаются на &lt;code&gt;*this&lt;/code&gt; , а не на &lt;code&gt;other&lt;/code&gt; . Первая версия использует &lt;code&gt;operator&amp;lt;&lt;/code&gt; для сравнения элементов, вторая версия использует заданную функцию сравнения &lt;code&gt;comp&lt;/code&gt; .</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
