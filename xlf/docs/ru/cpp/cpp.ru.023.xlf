<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="cpp">
    <body>
      <group id="cpp">
        <trans-unit id="1cefc4c9c8c79e1f5ffc310e3b76ce47f7f95b53" translate="yes" xml:space="preserve">
          <source>The type of the underlying container to use to store the elements. The container must satisfy the requirements of &lt;a href=&quot;../named_req/sequencecontainer&quot;&gt;SequenceContainer&lt;/a&gt;, and its iterators must satisfy the requirements of &lt;a href=&quot;../named_req/randomaccessiterator&quot;&gt;LegacyRandomAccessIterator&lt;/a&gt;. Additionally, it must provide the following functions with the usual semantics:</source>
          <target state="translated">Тип нижележащего контейнера, используемого для хранения элементов. Контейнер должен удовлетворять требованиям &lt;a href=&quot;../named_req/sequencecontainer&quot;&gt;SequenceContainer&lt;/a&gt; , а его итераторы должны удовлетворять требованиям &lt;a href=&quot;../named_req/randomaccessiterator&quot;&gt;LegacyRandomAccessIterator&lt;/a&gt; . Кроме того, он должен обеспечивать следующие функции с обычной семантикой:</target>
        </trans-unit>
        <trans-unit id="42baf44de229b353e2dc10d945c14ad4f7f1e2dd" translate="yes" xml:space="preserve">
          <source>The type of the underlying container to use to store the elements. The container must satisfy the requirements of &lt;a href=&quot;../named_req/sequencecontainer&quot;&gt;SequenceContainer&lt;/a&gt;. Additionally, it must provide the following functions with the usual semantics:</source>
          <target state="translated">Тип нижележащего контейнера, используемого для хранения элементов. Контейнер должен удовлетворять требованиям &lt;a href=&quot;../named_req/sequencecontainer&quot;&gt;SequenceContainer&lt;/a&gt; . Кроме того, он должен обеспечивать следующие функции с обычной семантикой:</target>
        </trans-unit>
        <trans-unit id="4b1400789f4da2eef8d9f804a8241c3f62471b09" translate="yes" xml:space="preserve">
          <source>The type produced when specializing an alias template is not allowed to directly or indirectly make use of its own type:</source>
          <target state="translated">Тип,полученный при специализации шаблона псевдонима,не допускается прямо или косвенно использовать собственный тип:</target>
        </trans-unit>
        <trans-unit id="447849d54c1d67d6b61329201208de7c3155cd27" translate="yes" xml:space="preserve">
          <source>The type representing all floating-point status flags collectively</source>
          <target state="translated">Тип,представляющий все флаги статуса с плавающей точкой,в совокупности</target>
        </trans-unit>
        <trans-unit id="66cad8bd68a6349c324c8b818f25bd23910481f3" translate="yes" xml:space="preserve">
          <source>The type representing the entire floating-point environment</source>
          <target state="translated">Тип,представляющий всю среду с плавающей точкой.</target>
        </trans-unit>
        <trans-unit id="e0d3b983420a08441dc26163e85fa14573af6da4" translate="yes" xml:space="preserve">
          <source>The type trait template &lt;code&gt;regex_traits&lt;/code&gt; supplies &lt;code&gt;&lt;a href=&quot;basic_regex&quot;&gt;std::basic_regex&lt;/a&gt;&lt;/code&gt; with the set of types and functions necessary to operate on the type &lt;code&gt;CharT&lt;/code&gt;.</source>
          <target state="translated">Шаблон &lt;code&gt;regex_traits&lt;/code&gt; типа regex_traits предоставляет &lt;code&gt;&lt;a href=&quot;basic_regex&quot;&gt;std::basic_regex&lt;/a&gt;&lt;/code&gt; набор типов и функций, необходимых для работы с типом &lt;code&gt;CharT&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a7ff3701335c6b61f893828424d0d4397e6f94e7" translate="yes" xml:space="preserve">
          <source>The type, value, and value category of the result of the comma expression are exactly the type, value, and value category of the second operand, &lt;code&gt;E2&lt;/code&gt;. If &lt;code&gt;E2&lt;/code&gt; is a temporary expression(since C++17), the result of the expression is that temporary expression(since C++17). If &lt;code&gt;E2&lt;/code&gt; is a bit-field, the result is a bit-field.</source>
          <target state="translated">Тип, значение и категория значения результата выражения с запятой в точности соответствуют типу, значению и категории значения второго операнда &lt;code&gt;E2&lt;/code&gt; . Если &lt;code&gt;E2&lt;/code&gt; является временным выражением (начиная с C ++ 17), результатом выражения будет это временное выражение (начиная с C ++ 17). Если &lt;code&gt;E2&lt;/code&gt; является битовым полем, результатом является битовое поле.</target>
        </trans-unit>
        <trans-unit id="201b401441e563392e93db134426f0b5823a14fe" translate="yes" xml:space="preserve">
          <source>The type-based overloads (5-12) fail to compile if the types &lt;code&gt;T&lt;/code&gt; and &lt;code&gt;U&lt;/code&gt; are the same.</source>
          <target state="translated">Перегрузки на основе типов (5-12) не компилируются, если типы &lt;code&gt;T&lt;/code&gt; и &lt;code&gt;U&lt;/code&gt; совпадают.</target>
        </trans-unit>
        <trans-unit id="a8ad5442d02de3fb2204cec5285533422e5d8a60" translate="yes" xml:space="preserve">
          <source>The typedef-names are aliases for existing types, and are not declarations of new types. Typedef cannot be used to change the meaning of an existing type name (including a typedef-name). Once declared, a typedef-name may only be redeclared to refer to the same type again. Typedef names are only in effect in the scope where they are visible: different functions or class declarations may define identically-named types with different meaning.</source>
          <target state="translated">Типизированные имена являются псевдонимами для существующих типов и не являются объявлениями новых типов.Typedef не может использоваться для изменения значения имени существующего типа (включая имя типа).После объявления,имя типа может быть заново заявлено только для того,чтобы вновь обратиться к одному и тому же типу.Имена типов действуют только в области видимости:различные функции или объявления классов могут определять одноименные типы с различным значением.</target>
        </trans-unit>
        <trans-unit id="208a0dcd155f30aca58e4747af4e8c084fcc2a94" translate="yes" xml:space="preserve">
          <source>The typeid expression is an &lt;a href=&quot;value_category&quot;&gt;lvalue expression&lt;/a&gt; which refers to an object with &lt;a href=&quot;static&quot;&gt;static storage duration&lt;/a&gt;, of the polymorphic type &lt;code&gt;const &lt;a href=&quot;../types/type_info&quot;&gt;std::type_info&lt;/a&gt;&lt;/code&gt; or of some type derived from it.</source>
          <target state="translated">Выражение typeid - это &lt;a href=&quot;value_category&quot;&gt;выражение lvalue,&lt;/a&gt; которое ссылается на объект со &lt;a href=&quot;static&quot;&gt;статической продолжительностью хранения&lt;/a&gt; , полиморфного типа &lt;code&gt;const &lt;a href=&quot;../types/type_info&quot;&gt;std::type_info&lt;/a&gt;&lt;/code&gt; или некоторого производного от него типа.</target>
        </trans-unit>
        <trans-unit id="7e208b7b23417d25a7cf6cca148a35ee8446742b" translate="yes" xml:space="preserve">
          <source>The types &lt;code&gt;TC::rep&lt;/code&gt;, &lt;code&gt;TC::duration&lt;/code&gt;, and &lt;code&gt;TC::time_point&lt;/code&gt; satisfy the requirements of &lt;a href=&quot;equalitycomparable&quot;&gt;EqualityComparable&lt;/a&gt;, &lt;a href=&quot;lessthancomparable&quot;&gt;LessThanComparable&lt;/a&gt;, &lt;a href=&quot;defaultconstructible&quot;&gt;DefaultConstructible&lt;/a&gt;, &lt;a href=&quot;copyconstructible&quot;&gt;CopyConstructible&lt;/a&gt;, &lt;a href=&quot;copyassignable&quot;&gt;CopyAssignable&lt;/a&gt;, &lt;a href=&quot;destructible&quot;&gt;Destructible&lt;/a&gt;, and &lt;a href=&quot;numerictype&quot;&gt;NumericType&lt;/a&gt;.</source>
          <target state="translated">Типы &lt;code&gt;TC::rep&lt;/code&gt; , &lt;code&gt;TC::duration&lt;/code&gt; и &lt;code&gt;TC::time_point&lt;/code&gt; удовлетворяют требованиям &lt;a href=&quot;equalitycomparable&quot;&gt;EqualityComparable&lt;/a&gt; , &lt;a href=&quot;lessthancomparable&quot;&gt;LessThanComparable&lt;/a&gt; , &lt;a href=&quot;defaultconstructible&quot;&gt;DefaultConstructible&lt;/a&gt; , &lt;a href=&quot;copyconstructible&quot;&gt;CopyConstructible&lt;/a&gt; , &lt;a href=&quot;copyassignable&quot;&gt;CopyAssignable&lt;/a&gt; , &lt;a href=&quot;destructible&quot;&gt;Destructible&lt;/a&gt; и &lt;a href=&quot;numerictype&quot;&gt;NumericType&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="61760bebb6411fc7a1b89f4a6a4d2b47b837a78f" translate="yes" xml:space="preserve">
          <source>The types &lt;code&gt;Type1&lt;/code&gt; and &lt;code&gt;Type2&lt;/code&gt; must be such that an object of type &lt;code&gt;BidirIt&lt;/code&gt; can be dereferenced and then implicitly converted to both of them. ​</source>
          <target state="translated">Типы &lt;code&gt;Type1&lt;/code&gt; и &lt;code&gt;Type2&lt;/code&gt; должны быть такими, чтобы объект типа &lt;code&gt;BidirIt&lt;/code&gt; мог быть разыменован, а затем неявно преобразован в оба из них.</target>
        </trans-unit>
        <trans-unit id="10efac4cd9ec3d4ae0fd700440a7ab91e4529fc8" translate="yes" xml:space="preserve">
          <source>The types &lt;code&gt;Type1&lt;/code&gt; and &lt;code&gt;Type2&lt;/code&gt; must be such that an object of type &lt;code&gt;ForwardIt&lt;/code&gt; can be dereferenced and then implicitly converted to both of them. ​</source>
          <target state="translated">Типы &lt;code&gt;Type1&lt;/code&gt; и &lt;code&gt;Type2&lt;/code&gt; должны быть такими, чтобы объект типа &lt;code&gt;ForwardIt&lt;/code&gt; мог быть разыменован, а затем неявно преобразован в оба из них.</target>
        </trans-unit>
        <trans-unit id="cfb5cffb02876fdfc335e83f9d620b313612c1b0" translate="yes" xml:space="preserve">
          <source>The types &lt;code&gt;Type1&lt;/code&gt; and &lt;code&gt;Type2&lt;/code&gt; must be such that an object of type &lt;code&gt;InputIt&lt;/code&gt; can be dereferenced and then implicitly converted to both of them. ​</source>
          <target state="translated">Типы &lt;code&gt;Type1&lt;/code&gt; и &lt;code&gt;Type2&lt;/code&gt; должны быть такими, чтобы объект типа &lt;code&gt;InputIt&lt;/code&gt; мог быть разыменован, а затем неявно преобразован в оба из них.</target>
        </trans-unit>
        <trans-unit id="3c179ed315abab6c17ee556701b26c5d282772f2" translate="yes" xml:space="preserve">
          <source>The types &lt;code&gt;Type1&lt;/code&gt; and &lt;code&gt;Type2&lt;/code&gt; must be such that an object of type &lt;code&gt;RandomIt&lt;/code&gt; can be dereferenced and then implicitly converted to both of them. ​</source>
          <target state="translated">Типы &lt;code&gt;Type1&lt;/code&gt; и &lt;code&gt;Type2&lt;/code&gt; должны быть такими, чтобы объект типа &lt;code&gt;RandomIt&lt;/code&gt; мог быть разыменован, а затем неявно преобразован в оба из них.</target>
        </trans-unit>
        <trans-unit id="193be796c5e76cc692dcacf4d03a9c74c36dcc11" translate="yes" xml:space="preserve">
          <source>The types &lt;code&gt;Type1&lt;/code&gt; and &lt;code&gt;Type2&lt;/code&gt; must be such that an object of type &lt;code&gt;T&lt;/code&gt; can be implicitly converted to both &lt;code&gt;Type1&lt;/code&gt; and &lt;code&gt;Type2&lt;/code&gt;, and an object of type &lt;code&gt;ForwardIt&lt;/code&gt; can be dereferenced and then implicitly converted to both &lt;code&gt;Type1&lt;/code&gt; and &lt;code&gt;Type2&lt;/code&gt;. ​</source>
          <target state="translated">Типы &lt;code&gt;Type1&lt;/code&gt; и &lt;code&gt;Type2&lt;/code&gt; должны быть такими, чтобы объект типа &lt;code&gt;T&lt;/code&gt; мог быть неявно преобразован как в &lt;code&gt;Type1&lt;/code&gt; ,так и в &lt;code&gt;Type2&lt;/code&gt; , а объект типа &lt;code&gt;ForwardIt&lt;/code&gt; может быть разыменован, а затем неявно преобразован в оба типа: &lt;code&gt;Type1&lt;/code&gt; и &lt;code&gt;Type2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f4447fe84d3b9ebfd730e495965e02d0c7f2a157" translate="yes" xml:space="preserve">
          <source>The types &lt;code&gt;Type1&lt;/code&gt; and &lt;code&gt;Type2&lt;/code&gt; must be such that an object of type &lt;code&gt;T&lt;/code&gt; can be implicitly converted to both of them. ​</source>
          <target state="translated">Типы &lt;code&gt;Type1&lt;/code&gt; и &lt;code&gt;Type2&lt;/code&gt; должны быть такими, чтобы объект типа &lt;code&gt;T&lt;/code&gt; мог быть неявно преобразован в них обоих.</target>
        </trans-unit>
        <trans-unit id="55aca5b917e7d46505eef0c5864d5092e23045de" translate="yes" xml:space="preserve">
          <source>The types &lt;code&gt;Type1&lt;/code&gt; and &lt;code&gt;Type2&lt;/code&gt; must be such that an object of type &lt;code&gt;forward_list&amp;lt;T,Allocator&amp;gt;::const_iterator&lt;/code&gt; can be dereferenced and then implicitly converted to both of them. ​</source>
          <target state="translated">Типы &lt;code&gt;Type1&lt;/code&gt; и &lt;code&gt;Type2&lt;/code&gt; должны быть такими, чтобы объект типа &lt;code&gt;forward_list&amp;lt;T,Allocator&amp;gt;::const_iterator&lt;/code&gt; мог быть разыменован, а затем неявно преобразован в оба из них.</target>
        </trans-unit>
        <trans-unit id="c2c308d3a55373567a39aa9cf81fb0182d8c2878" translate="yes" xml:space="preserve">
          <source>The types &lt;code&gt;Type1&lt;/code&gt; and &lt;code&gt;Type2&lt;/code&gt; must be such that an object of type &lt;code&gt;iterator_traits&amp;lt;InputIt&amp;gt;::value_type&lt;/code&gt; can be implicitly converted to both of them. The type &lt;code&gt;Ret&lt;/code&gt; must be such that an object of type &lt;code&gt;OutputIt&lt;/code&gt; can be dereferenced and assigned a value of type &lt;code&gt;Ret&lt;/code&gt;. ​</source>
          <target state="translated">Типы &lt;code&gt;Type1&lt;/code&gt; и &lt;code&gt;Type2&lt;/code&gt; должны быть такими, чтобы объект типа &lt;code&gt;iterator_traits&amp;lt;InputIt&amp;gt;::value_type&lt;/code&gt; мог быть неявно преобразован в оба из них. Тип &lt;code&gt;Ret&lt;/code&gt; должен быть таким, чтобы объект типа &lt;code&gt;OutputIt&lt;/code&gt; мог быть разыменован и ему было присвоено значение типа &lt;code&gt;Ret&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="86218894e5a217ad2ba71c5d5b88c13c7c91af26" translate="yes" xml:space="preserve">
          <source>The types &lt;code&gt;Type1&lt;/code&gt; and &lt;code&gt;Type2&lt;/code&gt; must be such that an object of type &lt;code&gt;list&amp;lt;T,Allocator&amp;gt;::const_iterator&lt;/code&gt; can be dereferenced and then implicitly converted to both of them. ​</source>
          <target state="translated">Типы &lt;code&gt;Type1&lt;/code&gt; и &lt;code&gt;Type2&lt;/code&gt; должны быть такими, чтобы объект &lt;code&gt;list&amp;lt;T,Allocator&amp;gt;::const_iterator&lt;/code&gt; типов &amp;lt;T, Allocator&amp;gt; :: const_iterator мог быть разыменован, а затем неявно преобразован в оба из них.</target>
        </trans-unit>
        <trans-unit id="255e7b7cb8a9a07dcebb8ff409c528b78435bb0c" translate="yes" xml:space="preserve">
          <source>The types &lt;code&gt;Type1&lt;/code&gt; and &lt;code&gt;Type2&lt;/code&gt; must be such that objects of types &lt;code&gt;ForwardIt1&lt;/code&gt; and &lt;code&gt;ForwardIt2&lt;/code&gt; can be dereferenced and then implicitly converted to &lt;code&gt;Type1&lt;/code&gt; and &lt;code&gt;Type2&lt;/code&gt; respectively. ​</source>
          <target state="translated">Типы &lt;code&gt;Type1&lt;/code&gt; и &lt;code&gt;Type2&lt;/code&gt; должны быть такими, чтобы объекты типов &lt;code&gt;ForwardIt1&lt;/code&gt; и &lt;code&gt;ForwardIt2&lt;/code&gt; могли быть разыменованы, а затем неявно преобразованы в &lt;code&gt;Type1&lt;/code&gt; и &lt;code&gt;Type2&lt;/code&gt; соответственно.</target>
        </trans-unit>
        <trans-unit id="8bf40db03397e57c92c014d425524b6be371768c" translate="yes" xml:space="preserve">
          <source>The types &lt;code&gt;Type1&lt;/code&gt; and &lt;code&gt;Type2&lt;/code&gt; must be such that objects of types &lt;code&gt;InputIt1&lt;/code&gt; and &lt;code&gt;InputIt2&lt;/code&gt; can be dereferenced and then implicitly converted to &lt;code&gt;Type1&lt;/code&gt; and &lt;code&gt;Type2&lt;/code&gt; respectively. The type &lt;code&gt;Ret&lt;/code&gt; must be such that an object of type &lt;code&gt;OutputIt&lt;/code&gt; can be dereferenced and assigned a value of type &lt;code&gt;Ret&lt;/code&gt;. ​</source>
          <target state="translated">Типы &lt;code&gt;Type1&lt;/code&gt; и &lt;code&gt;Type2&lt;/code&gt; должны быть такими, чтобы объекты типов &lt;code&gt;InputIt1&lt;/code&gt; и &lt;code&gt;InputIt2&lt;/code&gt; могли быть разыменованы, а затем неявно преобразованы в &lt;code&gt;Type1&lt;/code&gt; и &lt;code&gt;Type2&lt;/code&gt; соответственно. Тип &lt;code&gt;Ret&lt;/code&gt; должен быть таким, чтобы объект типа &lt;code&gt;OutputIt&lt;/code&gt; мог быть разыменован и ему было присвоено значение типа &lt;code&gt;Ret&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ea66afd749f321b8a7fbd2dfec0b25993b20d429" translate="yes" xml:space="preserve">
          <source>The types &lt;code&gt;Type1&lt;/code&gt; and &lt;code&gt;Type2&lt;/code&gt; must be such that objects of types &lt;code&gt;InputIt1&lt;/code&gt; and &lt;code&gt;InputIt2&lt;/code&gt; can be dereferenced and then implicitly converted to &lt;code&gt;Type1&lt;/code&gt; and &lt;code&gt;Type2&lt;/code&gt; respectively. The type &lt;code&gt;Ret&lt;/code&gt; must be such that an object of type &lt;code&gt;Type3&lt;/code&gt; can be assigned a value of type &lt;code&gt;Ret&lt;/code&gt;. ​</source>
          <target state="translated">Типы &lt;code&gt;Type1&lt;/code&gt; и &lt;code&gt;Type2&lt;/code&gt; должны быть такими, чтобы объекты типов &lt;code&gt;InputIt1&lt;/code&gt; и &lt;code&gt;InputIt2&lt;/code&gt; могли быть разыменованы, а затем неявно преобразованы в &lt;code&gt;Type1&lt;/code&gt; и &lt;code&gt;Type2&lt;/code&gt; соответственно. Тип &lt;code&gt;Ret&lt;/code&gt; должен быть таким, чтобы объекту типа &lt;code&gt;Type3&lt;/code&gt; можно было присвоить значение типа &lt;code&gt;Ret&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="697ca99a8e5d22b550dc1162bfdf3113cb87ca5b" translate="yes" xml:space="preserve">
          <source>The types &lt;code&gt;Type1&lt;/code&gt; and &lt;code&gt;Type2&lt;/code&gt; must be such that objects of types &lt;code&gt;InputIt1&lt;/code&gt; and &lt;code&gt;InputIt2&lt;/code&gt; can be dereferenced and then implicitly converted to &lt;code&gt;Type1&lt;/code&gt; and &lt;code&gt;Type2&lt;/code&gt; respectively. ​</source>
          <target state="translated">Типы &lt;code&gt;Type1&lt;/code&gt; и &lt;code&gt;Type2&lt;/code&gt; должны быть такими, чтобы объекты типов &lt;code&gt;InputIt1&lt;/code&gt; и &lt;code&gt;InputIt2&lt;/code&gt; могли быть разыменованы, а затем неявно преобразованы в &lt;code&gt;Type1&lt;/code&gt; и &lt;code&gt;Type2&lt;/code&gt; соответственно.</target>
        </trans-unit>
        <trans-unit id="c5097f11a8110609e26afb57ed62da129a5503cf" translate="yes" xml:space="preserve">
          <source>The types &lt;code&gt;Type1&lt;/code&gt; and &lt;code&gt;Type2&lt;/code&gt; must be such that objects of types &lt;code&gt;InputIt1&lt;/code&gt; and &lt;code&gt;InputIt2&lt;/code&gt; can be dereferenced and then implicitly converted to both &lt;code&gt;Type1&lt;/code&gt; and &lt;code&gt;Type2&lt;/code&gt;. ​</source>
          <target state="translated">Типы &lt;code&gt;Type1&lt;/code&gt; и &lt;code&gt;Type2&lt;/code&gt; должны быть такими, чтобы объекты типов &lt;code&gt;InputIt1&lt;/code&gt; и &lt;code&gt;InputIt2&lt;/code&gt; могли быть разыменованы, а затем неявно преобразованы как в &lt;code&gt;Type1&lt;/code&gt; ,так и в &lt;code&gt;Type2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8c30caab1908aa629ad3fea15c152763576c8875" translate="yes" xml:space="preserve">
          <source>The types &lt;code&gt;Type1&lt;/code&gt; and &lt;code&gt;Type2&lt;/code&gt; must be such that objects of types &lt;code&gt;T&lt;/code&gt; and &lt;code&gt;Type3&lt;/code&gt; can be implicitly converted to &lt;code&gt;Type1&lt;/code&gt; and &lt;code&gt;Type2&lt;/code&gt; respectively. The type &lt;code&gt;Ret&lt;/code&gt; must be such that an object of type &lt;code&gt;T&lt;/code&gt; can be assigned a value of type &lt;code&gt;Ret&lt;/code&gt;. ​</source>
          <target state="translated">Типы &lt;code&gt;Type1&lt;/code&gt; и &lt;code&gt;Type2&lt;/code&gt; должны быть такими, чтобы объекты типов &lt;code&gt;T&lt;/code&gt; и &lt;code&gt;Type3&lt;/code&gt; могли быть неявно преобразованы в &lt;code&gt;Type1&lt;/code&gt; и &lt;code&gt;Type2&lt;/code&gt; соответственно. Тип &lt;code&gt;Ret&lt;/code&gt; должен быть таким, чтобы объекту типа &lt;code&gt;T&lt;/code&gt; можно было присвоить значение типа &lt;code&gt;Ret&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="50e24e2bc41cc279e1a3c9515fef0b78775237a9" translate="yes" xml:space="preserve">
          <source>The types in the parameter pack &lt;code&gt;T&lt;/code&gt; shall each be a complete type, (possibly cv-qualified) &lt;code&gt;void&lt;/code&gt;, or an array of unknown bound. Otherwise, the behavior is undefined.</source>
          <target state="translated">Каждый из типов в пакете параметров &lt;code&gt;T&lt;/code&gt; должен быть полным типом (возможно cv-квалифицированным) &lt;code&gt;void&lt;/code&gt; или массивом неизвестной границы. В противном случае поведение не определено.</target>
        </trans-unit>
        <trans-unit id="fa81b9c4cb4ce5f942c1234f0bfa8aee24861f94" translate="yes" xml:space="preserve">
          <source>The types of the placeholder objects are &lt;a href=&quot;../../named_req/defaultconstructible&quot;&gt;DefaultConstructible&lt;/a&gt; and &lt;a href=&quot;../../named_req/copyconstructible&quot;&gt;CopyConstructible&lt;/a&gt;, their default copy/move constructors do not throw exceptions, and for any placeholder &lt;code&gt;_N&lt;/code&gt;, the type &lt;code&gt;&lt;a href=&quot;is_placeholder&quot;&gt;std::is_placeholder&lt;/a&gt;&amp;lt;decltype(_N)&amp;gt;&lt;/code&gt; is defined and is derived from &lt;code&gt;&lt;a href=&quot;../../types/integral_constant&quot;&gt;std::integral_constant&lt;/a&gt;&amp;lt;int, N&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;../../named_req/copyconstructible&quot;&gt;Типами&lt;/a&gt; объектов-заполнителей являются &lt;a href=&quot;../../named_req/defaultconstructible&quot;&gt;DefaultConstructible&lt;/a&gt; и CopyConstructible , их конструкторы копирования / перемещения по умолчанию не &lt;code&gt;_N&lt;/code&gt; исключения, и для любого заполнителя _N тип &lt;code&gt;&lt;a href=&quot;is_placeholder&quot;&gt;std::is_placeholder&lt;/a&gt;&amp;lt;decltype(_N)&amp;gt;&lt;/code&gt; определен и является производным от &lt;code&gt;&lt;a href=&quot;../../types/integral_constant&quot;&gt;std::integral_constant&lt;/a&gt;&amp;lt;int, N&amp;gt;&lt;/code&gt; integra_constant &amp;lt;int, N&amp;gt; .</target>
        </trans-unit>
        <trans-unit id="75478ba3404fb0cfdef1c92955897a42cd9e34cf" translate="yes" xml:space="preserve">
          <source>The types used to determine the order depend on the context:</source>
          <target state="translated">Типы,используемые для определения порядка,зависят от контекста:</target>
        </trans-unit>
        <trans-unit id="81e4b2422bd4fd5cd5d02082af7aa37f47bd2430" translate="yes" xml:space="preserve">
          <source>The typical implementation of &lt;code&gt;istrstream&lt;/code&gt; holds only one non-derived data member: an object of type &lt;code&gt;&lt;a href=&quot;strstreambuf&quot;&gt;std::strstreambuf&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Типичная реализация &lt;code&gt;istrstream&lt;/code&gt; содержит только один элемент данных, не являющийся производным: объект типа &lt;code&gt;&lt;a href=&quot;strstreambuf&quot;&gt;std::strstreambuf&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="48a376de82dbe48c2684a6707ba9148135410249" translate="yes" xml:space="preserve">
          <source>The typical implementation of &lt;code&gt;ostrstream&lt;/code&gt; holds only one non-derived data member: an object of type &lt;code&gt;&lt;a href=&quot;strstreambuf&quot;&gt;std::strstreambuf&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Типичная реализация &lt;code&gt;ostrstream&lt;/code&gt; содержит только один непроизведенный элемент данных: объект типа &lt;code&gt;&lt;a href=&quot;strstreambuf&quot;&gt;std::strstreambuf&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4926fe384c3bbd6e8ecfe4635962d969889b9270" translate="yes" xml:space="preserve">
          <source>The typical implementation of &lt;code&gt;strstream&lt;/code&gt; holds only one non-derived data member: an object of type &lt;code&gt;&lt;a href=&quot;strstreambuf&quot;&gt;std::strstreambuf&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Типичная реализация &lt;code&gt;strstream&lt;/code&gt; содержит только один непроизведенный элемент данных: объект типа &lt;code&gt;&lt;a href=&quot;strstreambuf&quot;&gt;std::strstreambuf&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8b6e26a516b34b7af57fc7012be60e25328df076" translate="yes" xml:space="preserve">
          <source>The unary arithmetic operator expressions have the form.</source>
          <target state="translated">Выражения унарных арифметических операторов имеют форму.</target>
        </trans-unit>
        <trans-unit id="b22b858c0fd42effe64ef379a02aba7e1e499dac" translate="yes" xml:space="preserve">
          <source>The unary operator &lt;code&gt;co_await&lt;/code&gt; suspends a coroutine and returns control to the caller. Its operand is an expression whose type must either define &lt;code&gt;operator co_await&lt;/code&gt;, or be convertible to such type by means of the current coroutine's &lt;code&gt;Promise::await_transform&lt;/code&gt;.</source>
          <target state="translated">Унарный оператор &lt;code&gt;co_await&lt;/code&gt; приостанавливает сопрограмму и возвращает управление вызывающей стороне. Его операндом является выражение, тип которого должен либо определять &lt;code&gt;operator co_await&lt;/code&gt; , либо быть конвертируемым в такой тип с помощью &lt;code&gt;Promise::await_transform&lt;/code&gt; текущей сопрограммы .</target>
        </trans-unit>
        <trans-unit id="36a5614de76d4b58b628c43d48b3afb8e58937c2" translate="yes" xml:space="preserve">
          <source>The unary predicate type must define a member type, &lt;code&gt;argument_type&lt;/code&gt;, that is convertible to the predicate's parameter type. The unary function objects obtained from &lt;code&gt;&lt;a href=&quot;ref&quot;&gt;std::ref&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;ref&quot;&gt;std::cref&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;negate&quot;&gt;std::negate&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;logical_not&quot;&gt;std::logical_not&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;mem_fn&quot;&gt;std::mem_fn&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;function&quot;&gt;std::function&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../hash&quot;&gt;std::hash&lt;/a&gt;&lt;/code&gt;, or from another call to &lt;code&gt;&lt;a href=&quot;not1&quot;&gt;std::not1&lt;/a&gt;&lt;/code&gt; have this type defined, as are function objects derived from the deprecated &lt;code&gt;&lt;a href=&quot;unary_function&quot;&gt;std::unary_function&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Унарный тип предиката должен определять тип члена, &lt;code&gt;argument_type&lt;/code&gt; , который можно преобразовать в тип параметра предиката. Унарные функции объектов получены из &lt;code&gt;&lt;a href=&quot;ref&quot;&gt;std::ref&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;ref&quot;&gt;std::cref&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;negate&quot;&gt;std::negate&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;logical_not&quot;&gt;std::logical_not&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;mem_fn&quot;&gt;std::mem_fn&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;function&quot;&gt;std::function&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../hash&quot;&gt;std::hash&lt;/a&gt;&lt;/code&gt; , или из другого вызова &lt;code&gt;&lt;a href=&quot;not1&quot;&gt;std::not1&lt;/a&gt;&lt;/code&gt; этот тип определен так же, как и объекты функций, производные от устаревшей функции &lt;code&gt;&lt;a href=&quot;unary_function&quot;&gt;std::unary_function&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7c177ac717f26cdcf71092d833a69d98891213b9" translate="yes" xml:space="preserve">
          <source>The unary predicate type must define a member type, &lt;code&gt;argument_type&lt;/code&gt;, that is convertible to the predicate's parameter type. The unary function objects obtained from &lt;code&gt;&lt;a href=&quot;ref&quot;&gt;std::ref&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;ref&quot;&gt;std::cref&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;negate&quot;&gt;std::negate&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;logical_not&quot;&gt;std::logical_not&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;mem_fn&quot;&gt;std::mem_fn&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;function&quot;&gt;std::function&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../hash&quot;&gt;std::hash&lt;/a&gt;&lt;/code&gt;, or from another call to &lt;code&gt;std::not1&lt;/code&gt; have this type defined, as are function objects derived from the deprecated &lt;code&gt;&lt;a href=&quot;unary_function&quot;&gt;std::unary_function&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Унарный тип предиката должен определять тип члена, &lt;code&gt;argument_type&lt;/code&gt; , который можно преобразовать в тип параметра предиката. Унарные функции объектов получены из &lt;code&gt;&lt;a href=&quot;ref&quot;&gt;std::ref&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;ref&quot;&gt;std::cref&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;negate&quot;&gt;std::negate&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;logical_not&quot;&gt;std::logical_not&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;mem_fn&quot;&gt;std::mem_fn&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;function&quot;&gt;std::function&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../hash&quot;&gt;std::hash&lt;/a&gt;&lt;/code&gt; , или из другого вызова &lt;code&gt;std::not1&lt;/code&gt; этот тип определен так же, как и объекты функций, производные от устаревшей функции &lt;code&gt;&lt;a href=&quot;unary_function&quot;&gt;std::unary_function&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9a8868abcc7899aa017c841a57e1f892c57cdec6" translate="yes" xml:space="preserve">
          <source>The underlying array is a &lt;a href=&quot;../language/implicit_cast#Temporary_materialization&quot;&gt;temporary&lt;/a&gt; array of type &lt;code&gt;const T[N]&lt;/code&gt;, in which each element is &lt;a href=&quot;../language/copy_initialization&quot;&gt;copy-initialized&lt;/a&gt; (except that narrowing conversions are invalid) from the corresponding element of the original initializer list. The lifetime of the underlying array is the same as any other &lt;a href=&quot;../language/lifetime#Temporary_object_lifetime&quot;&gt;temporary object&lt;/a&gt;, except that initializing an initializer_list object from the array extends the lifetime of the array exactly like &lt;a href=&quot;../language/reference_initialization#Lifetime_of_a_temporary&quot;&gt;binding a reference to a temporary&lt;/a&gt; (with the same exceptions, such as for initializing a non-static class member). The underlying array may be allocated in read-only memory.</source>
          <target state="translated">Базовый массив представляет собой &lt;a href=&quot;../language/implicit_cast#Temporary_materialization&quot;&gt;временный&lt;/a&gt; массив типа &lt;code&gt;const T[N]&lt;/code&gt; , в котором каждый элемент &lt;a href=&quot;../language/copy_initialization&quot;&gt;инициализируется копией&lt;/a&gt; (за исключением того, что сужающие преобразования недопустимы) из соответствующего элемента исходного списка инициализатора. Время жизни базового массива такое же, как у любого другого &lt;a href=&quot;../language/lifetime#Temporary_object_lifetime&quot;&gt;временного объекта&lt;/a&gt; , за исключением того, что инициализация объекта initializer_list из массива продлевает время жизни массива точно так же, как &lt;a href=&quot;../language/reference_initialization#Lifetime_of_a_temporary&quot;&gt;привязка ссылки к временному&lt;/a&gt; (с теми же исключениями, например, для инициализации не член класса). Базовый массив может быть размещен в постоянной памяти.</target>
        </trans-unit>
        <trans-unit id="4eb3a7f051a86b23a775a499c1446a22117e43f7" translate="yes" xml:space="preserve">
          <source>The underlying array is not guaranteed to exist after the lifetime of the original initializer list object has ended. The storage for &lt;code&gt;std::initializer_list&lt;/code&gt; is unspecified (i.e. it could be automatic, temporary, or static read-only memory, depending on the situation).</source>
          <target state="translated">Базовый массив не гарантированно существует после окончания времени жизни исходного объекта списка инициализаторов. Хранилище для &lt;code&gt;std::initializer_list&lt;/code&gt; не указано (т. Е. Это может быть автоматическая, временная или статическая постоянная память, в зависимости от ситуации).</target>
        </trans-unit>
        <trans-unit id="7eadf4d50d87bb977c930c01738a9f8d29a30fb0" translate="yes" xml:space="preserve">
          <source>The underlying engine.</source>
          <target state="translated">Подвижный двигатель.</target>
        </trans-unit>
        <trans-unit id="97e77189c09808726f0123e32d74be4afcdbd112" translate="yes" xml:space="preserve">
          <source>The underlying iterator is assigned the value of the underlying iterator of &lt;code&gt;other&lt;/code&gt;, i.e. &lt;code&gt;other.base()&lt;/code&gt;.</source>
          <target state="translated">Базовому итератору присваивается значение базового итератора &lt;code&gt;other&lt;/code&gt; , т.е. &lt;code&gt;other.base()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b646602f4defaa19568e9e4e03c04b49576b8ef7" translate="yes" xml:space="preserve">
          <source>The underlying iterator.</source>
          <target state="translated">Итератор,лежащий в основе.</target>
        </trans-unit>
        <trans-unit id="79cf0218a59dc2d4dbf82fe2261c98e6c65758c3" translate="yes" xml:space="preserve">
          <source>The unevaluated operands are considered to be</source>
          <target state="translated">Неоцененные операнды рассматриваются как</target>
        </trans-unit>
        <trans-unit id="979a12b00a42a8fc276019493ceedcb85eb1918e" translate="yes" xml:space="preserve">
          <source>The unformatted input functions &lt;a href=&quot;../basic_istream/get&quot;&gt;&lt;code&gt;basic_istream::get&lt;/code&gt;&lt;/a&gt; if they fails to extract any characters.</source>
          <target state="translated">&lt;a href=&quot;../basic_istream/get&quot;&gt; &lt;code&gt;basic_istream::get&lt;/code&gt; &lt;/a&gt; входные функции basic_istream :: get, если они не могут извлечь какие-либо символы.</target>
        </trans-unit>
        <trans-unit id="abe9991ee5e0486321d659e85ed0325fe1bbb797" translate="yes" xml:space="preserve">
          <source>The unformatted input functions &lt;a href=&quot;../basic_istream/read&quot;&gt;&lt;code&gt;basic_istream::read&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../basic_istream/get&quot;&gt;&lt;code&gt;basic_istream::get&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../basic_istream/peek&quot;&gt;&lt;code&gt;basic_istream::peek&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;../basic_istream/getline&quot;&gt;&lt;code&gt;basic_istream::getline&lt;/code&gt;&lt;/a&gt;, when reaching the end of the stream.</source>
          <target state="translated">&lt;a href=&quot;../basic_istream/read&quot;&gt; &lt;code&gt;basic_istream::read&lt;/code&gt; &lt;/a&gt; входные функции basic_istream :: read , &lt;a href=&quot;../basic_istream/get&quot;&gt; &lt;code&gt;basic_istream::get&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../basic_istream/peek&quot;&gt; &lt;code&gt;basic_istream::peek&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;../basic_istream/getline&quot;&gt; &lt;code&gt;basic_istream::getline&lt;/code&gt; &lt;/a&gt; при достижении конца потока.</target>
        </trans-unit>
        <trans-unit id="e384fd665d52aa51e3748fff4ef48a28e7937c70" translate="yes" xml:space="preserve">
          <source>The union is only as big as necessary to hold its largest data member. The other data members are allocated in the same bytes as part of that largest member. The details of that allocation are implementation-defined, and it's undefined behavior to read from the member of the union that wasn't most recently written. Many compilers implement, as a non-standard language extension, the ability to read inactive members of a union.</source>
          <target state="translated">Профсоюз только настолько велик,насколько это необходимо для того,чтобы удержать своего самого крупного участника.Остальные члены данных распределяются по тем же байтам,что и самый крупный член.Детали этого распределения определяются реализацией,и не определено поведение члена профсоюза,которое не было написано совсем недавно.Многие компиляторы реализуют,как нестандартное языковое расширение,возможность чтения неактивных членов профсоюза.</target>
        </trans-unit>
        <trans-unit id="e952952a6e837db3083d43ddef77a18d33df5f91" translate="yes" xml:space="preserve">
          <source>The unordered associative containers &lt;code&gt;&lt;a href=&quot;../container/unordered_set&quot;&gt;std::unordered_set&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../container/unordered_multiset&quot;&gt;std::unordered_multiset&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../container/unordered_map&quot;&gt;std::unordered_map&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../container/unordered_multimap&quot;&gt;std::unordered_multimap&lt;/a&gt;&lt;/code&gt; use specializations of the template &lt;code&gt;std::hash&lt;/code&gt; as the default hash function.</source>
          <target state="translated">Неупорядоченные ассоциативные контейнеры &lt;code&gt;&lt;a href=&quot;../container/unordered_set&quot;&gt;std::unordered_set&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../container/unordered_multiset&quot;&gt;std::unordered_multiset&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../container/unordered_map&quot;&gt;std::unordered_map&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../container/unordered_multimap&quot;&gt;std::unordered_multimap&lt;/a&gt;&lt;/code&gt; используют специализации шаблона &lt;code&gt;std::hash&lt;/code&gt; в качестве хэш-функции по умолчанию.</target>
        </trans-unit>
        <trans-unit id="fb9ee6c51de186554c2e06f60fe8377ba45da283" translate="yes" xml:space="preserve">
          <source>The upper bound of the largest range beginning at &lt;code&gt;first&lt;/code&gt; in which the elements are sorted in ascending order. That is, the last iterator &lt;code&gt;it&lt;/code&gt; for which range &lt;code&gt;[first, it)&lt;/code&gt; is sorted.</source>
          <target state="translated">Верхняя граница наибольшего начала диапазона на &lt;code&gt;first&lt;/code&gt; , в котором элементы сортируются в порядке возрастания. То есть, последний итератор &lt;code&gt;it&lt;/code&gt; , для которого в диапазоне &lt;code&gt;[first, it)&lt;/code&gt; сортируется.</target>
        </trans-unit>
        <trans-unit id="153cc2e9c85ca94fbb56ca3af1786c3042753255" translate="yes" xml:space="preserve">
          <source>The upper bound of the largest range beginning at &lt;code&gt;first&lt;/code&gt; which is a</source>
          <target state="translated">Верхняя граница самого большого диапазона, начинающегося &lt;code&gt;first&lt;/code&gt; который является</target>
        </trans-unit>
        <trans-unit id="0a7c6b2e95b8914f758d75e392b6d55f793089e4" translate="yes" xml:space="preserve">
          <source>The use of the class key &lt;code&gt;union&lt;/code&gt; results in a &lt;a href=&quot;union&quot;&gt;union definition&lt;/a&gt;, which defines a class that holds only one of its data members at a time.</source>
          <target state="translated">Использование ключевых классов &lt;code&gt;union&lt;/code&gt; приводит к &lt;a href=&quot;union&quot;&gt;определению союза&lt;/a&gt; , который определяет класс , который содержит только один из его элементов данных одновременно.</target>
        </trans-unit>
        <trans-unit id="7c930b3ae6f3ca4c4f3a29eb336a3a8321980de8" translate="yes" xml:space="preserve">
          <source>The user-defined callback function is not allowed to throw exceptions.</source>
          <target state="translated">Определенная пользователем функция обратного вызова не разрешает бросать исключения.</target>
        </trans-unit>
        <trans-unit id="7440e695d7d2b47e772a3f0ba0922c8f1015cfd1" translate="yes" xml:space="preserve">
          <source>The user-defined conversion functions are considered to be members of the</source>
          <target state="translated">Определенные пользователем функции преобразования рассматриваются как члены</target>
        </trans-unit>
        <trans-unit id="a2449ea9418355b1634632974372ad5423959cfe" translate="yes" xml:space="preserve">
          <source>The using-directive &lt;code&gt;using namespace std;&lt;/code&gt; at any namespace scope introduces every name from the namespace &lt;code&gt;std&lt;/code&gt; into the global namespace (since the global namespace is the nearest namespace that contains both &lt;code&gt;std&lt;/code&gt; and any user-declared namespace), which may lead to undesirable name collisions. This, and other using directives are generally considered bad practice at file scope of a header file.</source>
          <target state="translated">Директива &lt;code&gt;using namespace std;&lt;/code&gt; в любой области имен пространство вводит каждое имя из пространства имен &lt;code&gt;std&lt;/code&gt; в глобальное пространство имен (поскольку глобальное пространство имен является ближайшим пространством имен, которое содержит как &lt;code&gt;std&lt;/code&gt; ,так и любое объявленное пользователем пространство имен), что может привести к нежелательным конфликтам имен. Эта и другие директивы использования обычно считаются плохой практикой в ​​области заголовка файла.</target>
        </trans-unit>
        <trans-unit id="a0a29bcf7f924ca3c9afb16892af9ad80008618f" translate="yes" xml:space="preserve">
          <source>The usual rules for reference-binding to temporaries (including lifetime-extension) apply if a ref-operator is present and the expression is a prvalue. In those cases the hidden variable &lt;code&gt;&lt;i&gt;e&lt;/i&gt;&lt;/code&gt; is a reference that binds to the temporary variable &lt;a href=&quot;implicit_cast#Temporary_materialization&quot;&gt;materialized&lt;/a&gt; from the prvalue expression, extending its lifetime. As usual, the binding will fail if &lt;code&gt;&lt;i&gt;e&lt;/i&gt;&lt;/code&gt; is a non-const lvalue reference:</source>
          <target state="translated">Обычные правила для привязки ссылок к временным файлам (включая продление времени жизни) применяются, если присутствует оператор ref и выражение является prvalue. В этих случаях скрытая переменная &lt;code&gt;&lt;i&gt;e&lt;/i&gt;&lt;/code&gt; является ссылкой, которая связывается с временной переменной, &lt;a href=&quot;implicit_cast#Temporary_materialization&quot;&gt;материализованной&lt;/a&gt; из выражения prvalue, продлевая ее время жизни. Как обычно, привязка не будет выполнена, если &lt;code&gt;&lt;i&gt;e&lt;/i&gt;&lt;/code&gt; является неконстантной ссылкой на lvalue:</target>
        </trans-unit>
        <trans-unit id="d143db4cb73d031e48783561f534e5977a6951dc" translate="yes" xml:space="preserve">
          <source>The utility functions &lt;code&gt;std::make_obj_using_allocator&lt;/code&gt;, and &lt;code&gt;std::uninitialized_construct_using_allocator&lt;/code&gt; may be used to explicitly create an object following the above protocol, and &lt;code&gt;std::uses_allocator_construction_args&lt;/code&gt; can be used to prepare the argument list that matches the flavor of uses-allocator construction expected by the type.</source>
          <target state="translated">&lt;code&gt;std::make_obj_using_allocator&lt;/code&gt; функции std :: make_obj_using_allocator и &lt;code&gt;std::uninitialized_construct_using_allocator&lt;/code&gt; могут использоваться для явного создания объекта в соответствии с указанным выше протоколом, а &lt;code&gt;std::uses_allocator_construction_args&lt;/code&gt; может использоваться для подготовки списка аргументов, который соответствует виду конструкции util -allocator, ожидаемого тип.</target>
        </trans-unit>
        <trans-unit id="fe1efdbf774195a43f57a666949496b9864e4331" translate="yes" xml:space="preserve">
          <source>The valid values (inherited from &lt;code&gt;&lt;a href=&quot;../time_base&quot;&gt;std::time_base&lt;/a&gt;&lt;/code&gt;) are:</source>
          <target state="translated">Допустимые значения (унаследованные от &lt;code&gt;&lt;a href=&quot;../time_base&quot;&gt;std::time_base&lt;/a&gt;&lt;/code&gt; ):</target>
        </trans-unit>
        <trans-unit id="ea8585806be7732f5b1559533a0afabee4e31468" translate="yes" xml:space="preserve">
          <source>The value &lt;code&gt;false&lt;/code&gt; (the default) indicates that any flush will be postponed until a call to emit.</source>
          <target state="translated">Значение &lt;code&gt;false&lt;/code&gt; (по умолчанию) означает, что любая очистка будет отложена до вызова.</target>
        </trans-unit>
        <trans-unit id="bec74bfd762b8f94824661d08795516a39875971" translate="yes" xml:space="preserve">
          <source>The value &lt;code&gt;std::codecvt_base::partial&lt;/code&gt; is used to indicate that either the destination range is too short to receive the results of the conversion or the input is truncated in the middle of an otherwise valid multibyte character.</source>
          <target state="translated">Значение &lt;code&gt;std::codecvt_base::partial&lt;/code&gt; используется для указания того, что либо диапазон назначения слишком короткий, чтобы получить результаты преобразования, либо вход обрезан в середине другого действительного многобайтового символа.</target>
        </trans-unit>
        <trans-unit id="b59da2ec2014ac9c518b1aadf220e6d3e58b2e01" translate="yes" xml:space="preserve">
          <source>The value &lt;code&gt;true&lt;/code&gt; makes flushes apply immediately.</source>
          <target state="translated">Значение &lt;code&gt;true&lt;/code&gt; заставляет сбрасываться немедленно.</target>
        </trans-unit>
        <trans-unit id="b297662cf0a9d877fef1ea088b887dc762885510" translate="yes" xml:space="preserve">
          <source>The value category of a function call expression is lvalue if the function returns an lvalue reference or an rvalue reference to function, is an xvalue if the function returns an rvalue reference to object, and is a prvalue otherwise. If the function call expression is a prvalue of object type, it must have complete type except when the prvalue is not materialized, such as(since C++17) when used as the operand of &lt;a href=&quot;decltype&quot;&gt;decltype&lt;/a&gt; (or as the right operand of a &lt;a href=&quot;operator_other#Built-in_comma_operator&quot;&gt;built-in comma operator expression&lt;/a&gt; that is the operand of &lt;code&gt;decltype&lt;/code&gt;).</source>
          <target state="translated">Категория значения выражения вызова функции - lvalue, если функция возвращает ссылку на lvalue или ссылку на rvalue на функцию, - это значение xvalue, если функция возвращает ссылку на rvalue на объект, и в противном случае - значение prvalue. Если выражение вызова функции является prvalue типа объекта, оно должно иметь полный тип, кроме случаев, когда prvalue не материализовано, например (начиная с C ++ 17), когда используется как операнд типа &lt;a href=&quot;decltype&quot;&gt;decl&lt;/a&gt; (или как правый операнд &lt;a href=&quot;operator_other#Built-in_comma_operator&quot;&gt;встроенного -в выражении оператора запятой,&lt;/a&gt; который является операндом типа &lt;code&gt;decltype&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="67e47b55490dd997d102458418a048c6890cf272" translate="yes" xml:space="preserve">
          <source>The value comparison function object.</source>
          <target state="translated">Объект функции сравнения значений.</target>
        </trans-unit>
        <trans-unit id="e3315b1caebdb1fc309be2d0ec78502282dc56fc" translate="yes" xml:space="preserve">
          <source>The value computed by the three-argument version of this function is the distance of the point &lt;code&gt;(x,y,z)&lt;/code&gt; from the origin &lt;code&gt;(0,0,0)&lt;/code&gt;.</source>
          <target state="translated">Значение, вычисляемое версией этой функции с тремя аргументами, является расстоянием между точкой &lt;code&gt;(x,y,z)&lt;/code&gt; и началом координат &lt;code&gt;(0,0,0)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f316342cf5de6fdab5febb1bc73226832477d458" translate="yes" xml:space="preserve">
          <source>The value computed by the two-argument version of this function is the length of the hypotenuse of a right-angled triangle with sides of length &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;, or the distance of the point &lt;code&gt;(x,y)&lt;/code&gt; from the origin &lt;code&gt;(0,0)&lt;/code&gt;, or the magnitude of a complex number &lt;code&gt;x+&lt;i&gt;i&lt;/i&gt;y&lt;/code&gt;.</source>
          <target state="translated">Значение, вычисляемое версией этой функции с двумя аргументами, представляет собой длину гипотенузы прямоугольного треугольника со сторонами длины &lt;code&gt;x&lt;/code&gt; и &lt;code&gt;y&lt;/code&gt; или расстояние от точки &lt;code&gt;(x,y)&lt;/code&gt; до начала координат &lt;code&gt;(0,0)&lt;/code&gt; , или величина комплексного числа &lt;code&gt;x+&lt;i&gt;i&lt;/i&gt;y&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7044fe5027fd6004978c59ea869f2af588568b11" translate="yes" xml:space="preserve">
          <source>The value held previously by the atomic object pointed to by &lt;code&gt;obj&lt;/code&gt;.</source>
          <target state="translated">Значение, которое ранее содержал атомный объект, на который указывает &lt;code&gt;obj&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5b53ba13c1b7ad772fd50ae6d7f505fae71221a4" translate="yes" xml:space="preserve">
          <source>The value immediately preceding the effects of this function in the &lt;a href=&quot;../memory_order#Modification_order&quot;&gt;modification order&lt;/a&gt; of &lt;code&gt;*this&lt;/code&gt;.</source>
          <target state="translated">Значение , непосредственно предшествующий эффект этой функции в &lt;a href=&quot;../memory_order#Modification_order&quot;&gt;порядке модификации&lt;/a&gt; из &lt;code&gt;*this&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="21ba436ae4d60c1b3df6f313a5e847a739f28e04" translate="yes" xml:space="preserve">
          <source>The value immediately preceding the effects of this function in the &lt;a href=&quot;memory_order#Modification_order&quot;&gt;modification order&lt;/a&gt; of &lt;code&gt;*obj&lt;/code&gt;.</source>
          <target state="translated">Значение , непосредственно предшествующий эффект этой функции в &lt;a href=&quot;memory_order#Modification_order&quot;&gt;порядке модификации&lt;/a&gt; от &lt;code&gt;*obj&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2ad12bc074bf532e8969a9847c8c0936a889cc81" translate="yes" xml:space="preserve">
          <source>The value obtained is the number of successes in a sequence of t yes/no experiments, each of which succeeds with probability p.</source>
          <target state="translated">Полученное значение представляет собой количество успешных результатов в последовательности t да/нет экспериментов,каждый из которых успешен с вероятностью p.</target>
        </trans-unit>
        <trans-unit id="33a4fa47add8b297d431d6dce6cb94e9aeac4af7" translate="yes" xml:space="preserve">
          <source>The value obtained is the probability of exactly i occurrences of a random event if the expected,</source>
          <target state="translated">Полученное значение является вероятностью ровно i случайного события,если оно ожидается,</target>
        </trans-unit>
        <trans-unit id="873f84075d8ee3fa467aeba44e733298e1a32864" translate="yes" xml:space="preserve">
          <source>The value obtained is the time/distance until the next random event if random events occur at constant rate &amp;lambda; per unit of time/distance. For example, this distribution describes the time between the clicks of a Geiger counter or the distance between point mutations in a DNA strand.</source>
          <target state="translated">Полученное значение представляет собой время / расстояние до следующего случайного события, если случайные события происходят с постоянной скоростью &amp;lambda; на единицу времени / расстояния. Например, это распределение описывает время между щелчками счетчика Гейгера или расстояние между точечными мутациями в цепи ДНК.</target>
        </trans-unit>
        <trans-unit id="baf914d043e381313277e30f951edd923276b030" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::digits10&lt;/code&gt; is the number of base-10 digits that can be represented by the type &lt;code&gt;T&lt;/code&gt; without change, that is, any number with this many significant decimal digits can be converted to a value of type &lt;code&gt;T&lt;/code&gt; and back to decimal form, without change due to rounding or overflow. For base-&lt;a href=&quot;radix&quot;&gt;radix&lt;/a&gt; types, it is the value of &lt;a href=&quot;digits&quot;&gt;digits&lt;/a&gt; (&lt;code&gt;digits-1&lt;/code&gt; for floating-point types) multiplied by log</source>
          <target state="translated">Значение &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::digits10&lt;/code&gt; - это число цифр из 10 оснований, которые могут быть представлены типом &lt;code&gt;T&lt;/code&gt; без изменений, то есть любое число с таким количеством значащих десятичных цифр может быть преобразовано в значение введите &lt;code&gt;T&lt;/code&gt; и вернитесь к десятичной форме, без изменений из-за округления или переполнения. Для типов с базовым &lt;a href=&quot;radix&quot;&gt;основанием&lt;/a&gt; это значение &lt;a href=&quot;digits&quot;&gt;цифр&lt;/a&gt; ( &lt;code&gt;digits-1&lt;/code&gt; для типов с плавающей запятой), умноженное на log</target>
        </trans-unit>
        <trans-unit id="c32d6df5f25bd1c67469d66fa412b07db9fb23e7" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::digits&lt;/code&gt; is the number of digits in base-&lt;a href=&quot;radix&quot;&gt;radix&lt;/a&gt; that can be represented by the type &lt;code&gt;T&lt;/code&gt; without change. For integer types, this is the number of bits not counting the sign bit and the padding bits (if any). For floating-point types, this is the number of digits in the mantissa.</source>
          <target state="translated">Значение &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::digits&lt;/code&gt; - это количество цифр в базовом &lt;a href=&quot;radix&quot;&gt;радиксе,&lt;/a&gt; которое может быть представлено типом &lt;code&gt;T&lt;/code&gt; без изменений. Для целочисленных типов это количество битов, не считая знакового бита и битов заполнения (если есть). Для типов с плавающей запятой это количество цифр в мантиссе.</target>
        </trans-unit>
        <trans-unit id="0efce6844d5328b9d552d5e22fa416002bf69dda" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::has_denorm&lt;/code&gt; identifies the floating-point types that support &lt;a href=&quot;https://en.wikipedia.org/wiki/Denormal_number&quot;&gt;subnormal values&lt;/a&gt;.</source>
          <target state="translated">Значение &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::has_denorm&lt;/code&gt; идентифицирует типы с плавающей точкой, которые поддерживают &lt;a href=&quot;https://en.wikipedia.org/wiki/Denormal_number&quot;&gt;субнормальные значения&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="818565d8873864260ed4bd3755ec119254a0a789" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::has_denorm_loss&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; for all floating-point types &lt;code&gt;T&lt;/code&gt; that detect loss of precision when creating a subnormal number as denormalization loss rather than as inexact result (see below).</source>
          <target state="translated">Значение &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::has_denorm_loss&lt;/code&gt; это &lt;code&gt;true&lt;/code&gt; для всех типов с плавающей точкой &lt;code&gt;T&lt;/code&gt; , которые обнаруживают потерю точности при создании ряда субнормального как потери денормализации , а не в результате неточной (см ниже).</target>
        </trans-unit>
        <trans-unit id="49fe53c8f4920123566acbcd270a4d7a6cb8ff5d" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::has_infinity&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; for all types &lt;code&gt;T&lt;/code&gt; capable of representing the positive infinity as a distinct special value. This constant is meaningful for all floating-point types and is guaranteed to be &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::is_iec559 == true&lt;/code&gt;.</source>
          <target state="translated">Значение &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::has_infinity&lt;/code&gt; имеет значение &lt;code&gt;true&lt;/code&gt; для всех типов &lt;code&gt;T&lt;/code&gt; , способных представлять положительную бесконечность как отдельное специальное значение. Эта константа имеет смысл для всех типов с плавающей точкой и гарантированно будет &lt;code&gt;true&lt;/code&gt; если &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::is_iec559 == true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="72efab69a379a3baec3c747ef72e6384302c8f11" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::has_quiet_NaN&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; for all types &lt;code&gt;T&lt;/code&gt; capable of representing the special value &quot;Quiet &lt;a href=&quot;https://en.wikipedia.org/wiki/NaN&quot;&gt;Not-A-Number&lt;/a&gt;&quot;. This constant is meaningful for all floating-point types and is guaranteed to be &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::is_iec559 == true&lt;/code&gt;.</source>
          <target state="translated">Значение &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::has_quiet_NaN&lt;/code&gt; имеет значение &lt;code&gt;true&lt;/code&gt; для всех типов &lt;code&gt;T&lt;/code&gt; , способных представлять специальное значение &quot;Quiet &lt;a href=&quot;https://en.wikipedia.org/wiki/NaN&quot;&gt;Not-A-Number&lt;/a&gt; &quot;. Эта константа имеет смысл для всех типов с плавающей точкой и гарантированно будет &lt;code&gt;true&lt;/code&gt; если &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::is_iec559 == true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="13d78c72e37aa6610d8da4c27392455c38353258" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::has_signaling_NaN&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; for all types &lt;code&gt;T&lt;/code&gt; capable of representing the special value &quot;Signaling &lt;a href=&quot;https://en.wikipedia.org/wiki/NaN&quot;&gt;Not-A-Number&lt;/a&gt;&quot;. This constant is meaningful for all floating-point types and is guaranteed to be &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::is_iec559 == true&lt;/code&gt;.</source>
          <target state="translated">Значение &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::has_signaling_NaN&lt;/code&gt; имеет значение &lt;code&gt;true&lt;/code&gt; для всех типов &lt;code&gt;T&lt;/code&gt; , способных представлять специальное значение &quot;Signaling &lt;a href=&quot;https://en.wikipedia.org/wiki/NaN&quot;&gt;Not-A-Number&lt;/a&gt; &quot;. Эта константа имеет смысл для всех типов с плавающей точкой и гарантированно будет &lt;code&gt;true&lt;/code&gt; если &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::is_iec559 == true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f98212fab0bd1fe8a4594e818456712a7e96f5af" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::is_bounded&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; for all arithmetic types &lt;code&gt;T&lt;/code&gt; that represent a finite set of values. While all fundamental types are bounded, this constant would be &lt;code&gt;false&lt;/code&gt; in a specialization of &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&lt;/code&gt; for a library-provided arbitrary precision arithmetic type.</source>
          <target state="translated">Значение &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::is_bounded&lt;/code&gt; является &lt;code&gt;true&lt;/code&gt; для всех арифметических типов &lt;code&gt;T&lt;/code&gt; , которые представляют конечный набор значений. Хотя все основные типы ограничены, эта константа будет &lt;code&gt;false&lt;/code&gt; в специализации &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&lt;/code&gt; для арифметического типа с произвольной точностью, предоставляемого библиотекой.</target>
        </trans-unit>
        <trans-unit id="a3bc9c048c67471591b1728199b12d7c643bc09a" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::is_exact&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; for all arithmetic types &lt;code&gt;T&lt;/code&gt; that use exact representation.</source>
          <target state="translated">Значение &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::is_exact&lt;/code&gt; является &lt;code&gt;true&lt;/code&gt; для всех арифметических типов &lt;code&gt;T&lt;/code&gt; , которые используют точное представление.</target>
        </trans-unit>
        <trans-unit id="0de1e0807da9a49f5b6ab2b0b1d4bdf3282315d4" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::is_iec559&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; for all floating-point types &lt;code&gt;T&lt;/code&gt; which fulfill the requirements of IEC 559 (&lt;a href=&quot;https://en.wikipedia.org/wiki/IEEE_754-2008&quot;&gt;IEEE 754&lt;/a&gt;) standard. If &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::is_iec559&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, then &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::has_infinity&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::has_quiet_NaN&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::has_signaling_NaN&lt;/code&gt; are also &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">Значение &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::is_iec559&lt;/code&gt; это &lt;code&gt;true&lt;/code&gt; для всех типов с плавающей точкой &lt;code&gt;T&lt;/code&gt; , которые отвечают требованиям IEC 559 ( &lt;a href=&quot;https://en.wikipedia.org/wiki/IEEE_754-2008&quot;&gt;IEEE 754&lt;/a&gt; ) стандарта. Если &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::is_iec559&lt;/code&gt; имеет значение &lt;code&gt;true&lt;/code&gt; , тогда &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::has_infinity&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::has_quiet_NaN&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::has_signaling_NaN&lt;/code&gt; также являются &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d5566e2270326a63be00f7caa114991c2e742497" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::is_integer&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; for all integer arithmetic types &lt;code&gt;T&lt;/code&gt; and &lt;code&gt;false&lt;/code&gt; otherwise. This constant is meaningful for all specializations.</source>
          <target state="translated">Значение &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::is_integer&lt;/code&gt; является &lt;code&gt;true&lt;/code&gt; для всех целочисленных арифметических типов &lt;code&gt;T&lt;/code&gt; и &lt;code&gt;false&lt;/code&gt; противном случае. Эта константа имеет смысл для всех специализаций.</target>
        </trans-unit>
        <trans-unit id="658be2ec18bfcdb89b874906fd0e9a2788a963dc" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::is_modulo&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; for all arithmetic types &lt;code&gt;T&lt;/code&gt; that are possible to (until C++11)handle overflows with modulo arithmetic, that is, if the result of addition, subtraction, multiplication, or division of this type would fall outside the range &lt;code&gt;[min(), max()]&lt;/code&gt;, the value returned by such operation differs from the expected value by a multiple of &lt;code&gt;max()-min()+1&lt;/code&gt;.</source>
          <target state="translated">Значение &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::is_modulo&lt;/code&gt; имеет значение &lt;code&gt;true&lt;/code&gt; для всех арифметических типов &lt;code&gt;T&lt;/code&gt; , которые возможны (до C ++ 11) для обработки переполнений по арифметике по модулю, то есть, если в результате сложения, вычитания, умножения, или если деление этого типа выйдет за пределы диапазона &lt;code&gt;[min(), max()]&lt;/code&gt; , значение, возвращаемое такой операцией, отличается от ожидаемого значения, кратного &lt;code&gt;max()-min()+1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="31c7c70df24e3cc025f30c7660467183acd0bc12" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::is_signed&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; for all signed arithmetic types &lt;code&gt;T&lt;/code&gt; and &lt;code&gt;false&lt;/code&gt; for the unsigned types. This constant is meaningful for all specializations.</source>
          <target state="translated">Значение &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::is_signed&lt;/code&gt; имеет значение &lt;code&gt;true&lt;/code&gt; для всех арифметических типов со знаком &lt;code&gt;T&lt;/code&gt; и &lt;code&gt;false&lt;/code&gt; для типов без знака. Эта константа имеет смысл для всех специализаций.</target>
        </trans-unit>
        <trans-unit id="c387cb47b15566bbeed0c9ac97ac7422cc757b9c" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::is_specialized&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; for all &lt;code&gt;T&lt;/code&gt; for which there exists a specialization of &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Значение &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::is_specialized&lt;/code&gt; имеет значение &lt;code&gt;true&lt;/code&gt; для всех &lt;code&gt;T&lt;/code&gt; , для которых существует специализация &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7a6c251458907976d9505f9f19b57f15d678ee8d" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::max_digits10&lt;/code&gt; is the number of base-10 digits that are necessary to uniquely represent all distinct values of the type &lt;code&gt;T&lt;/code&gt;, such as necessary for serialization/deserialization to text. This constant is meaningful for all floating-point types.</source>
          <target state="translated">Значение &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::max_digits10&lt;/code&gt; - это число из 10 цифр, которые необходимы для уникального представления всех различных значений типа &lt;code&gt;T&lt;/code&gt; , например, необходимых для сериализации / десериализации в текст. Эта константа имеет смысл для всех типов с плавающей точкой.</target>
        </trans-unit>
        <trans-unit id="95ede15e1ccfe9c08910652785a578f9aff770fc" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::max_exponent10&lt;/code&gt; is the largest positive number &lt;code&gt;n&lt;/code&gt; such that 10n</source>
          <target state="translated">Значение &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::max_exponent10&lt;/code&gt; является наибольшим положительным числом &lt;code&gt;n&lt;/code&gt; таким, что 10n</target>
        </trans-unit>
        <trans-unit id="4428910011b11510b83f35d9325633de507bd21f" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::max_exponent&lt;/code&gt; is the largest positive number &lt;code&gt;n&lt;/code&gt; such that rn-1</source>
          <target state="translated">Значение &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::max_exponent&lt;/code&gt; является наибольшим положительным числом &lt;code&gt;n&lt;/code&gt; таким, что rn-1</target>
        </trans-unit>
        <trans-unit id="3a8e50309322655b0b34d76c3ee924a26b2a1631" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::min_exponent10&lt;/code&gt; is the lowest negative number &lt;code&gt;n&lt;/code&gt; such that 10n</source>
          <target state="translated">Значение &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::min_exponent10&lt;/code&gt; является наименьшим отрицательным числом &lt;code&gt;n&lt;/code&gt; таким, что 10n</target>
        </trans-unit>
        <trans-unit id="d7d35efd9d6ad828da236c558d6eb68513df2887" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::min_exponent&lt;/code&gt; is the lowest negative number &lt;code&gt;n&lt;/code&gt; such that rn-1</source>
          <target state="translated">Значение &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::min_exponent&lt;/code&gt; является наименьшим отрицательным числом &lt;code&gt;n&lt;/code&gt; таким, что rn-1</target>
        </trans-unit>
        <trans-unit id="67d3622bd53f05bb8c505d5f1632f3a6e465c7e7" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::radix&lt;/code&gt; is the base of the number system used in the representation of the type. It is 2 for all binary numeric types, but it may be, for example, 10 for IEEE 754 &lt;a href=&quot;https://en.wikipedia.org/wiki/Decimal64_floating-point_format&quot;&gt;decimal floating-point types&lt;/a&gt; or for third-party &lt;a href=&quot;https://en.wikipedia.org/wiki/Binary-coded_decimal&quot;&gt;binary-coded decimal&lt;/a&gt; integers. This constant is meaningful for all specializations.</source>
          <target state="translated">Значение &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::radix&lt;/code&gt; является базой системы счисления, используемой в представлении типа. Это 2 для всех двоичных числовых типов, но это может быть, например, 10 для &lt;a href=&quot;https://en.wikipedia.org/wiki/Decimal64_floating-point_format&quot;&gt;десятичных типов с плавающей запятой&lt;/a&gt; IEEE 754 или для сторонних &lt;a href=&quot;https://en.wikipedia.org/wiki/Binary-coded_decimal&quot;&gt;двоичных десятичных&lt;/a&gt; целых чисел. Эта константа имеет смысл для всех специализаций.</target>
        </trans-unit>
        <trans-unit id="ad3e3b6d189c403f77654a78e8b8fce06565fd64" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::round_style&lt;/code&gt; identifies the rounding style used by the floating-point type &lt;code&gt;T&lt;/code&gt; whenever a value that is not one of the exactly repesentable values of &lt;code&gt;T&lt;/code&gt; is stored in an object of that type.</source>
          <target state="translated">Значение &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::round_style&lt;/code&gt; идентифицирует стиль округления, используемый типом &lt;code&gt;T&lt;/code&gt; с плавающей точкой, всякий раз, когда значение, не являющееся одним из точно представимых значений &lt;code&gt;T&lt;/code&gt; , сохраняется в объекте этого типа.</target>
        </trans-unit>
        <trans-unit id="929804192ce1c0c75b72779392cd6ef40eb4db5c" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::tinyness_before&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; for all floating-point types &lt;code&gt;T&lt;/code&gt; that test results of floating-point expressions for underflow before rounding.</source>
          <target state="translated">Значение &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::tinyness_before&lt;/code&gt; имеет значение &lt;code&gt;true&lt;/code&gt; для всех типов &lt;code&gt;T&lt;/code&gt; с плавающей запятой, которые проверяют результаты выражений с плавающей запятой на предмет опустошения перед округлением.</target>
        </trans-unit>
        <trans-unit id="f1ed74039ebf1d42dca61166c833be8f6cd7f491" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::traps&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; for all arithmetic types &lt;code&gt;T&lt;/code&gt; that have at least one value that, if used as an argument to an arithmetic operation, will generate a &lt;a href=&quot;https://en.wikipedia.org/wiki/Trap_(computing)&quot;&gt;trap&lt;/a&gt;.</source>
          <target state="translated">Значение &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::traps&lt;/code&gt; является &lt;code&gt;true&lt;/code&gt; для всех арифметических типов &lt;code&gt;T&lt;/code&gt; , которые имеют хотя бы одно значение, которое, если оно используется в качестве аргумента для арифметической операции, будет генерировать &lt;a href=&quot;https://en.wikipedia.org/wiki/Trap_(computing)&quot;&gt;ловушку&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7772c8f78a06c27107be30f83bed9d48e68fe602" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;T(rv)&lt;/code&gt; is equivalent to the value of &lt;code&gt;rv&lt;/code&gt; before the initialization.</source>
          <target state="translated">Значение &lt;code&gt;T(rv)&lt;/code&gt; эквивалентно значению &lt;code&gt;rv&lt;/code&gt; до инициализации.</target>
        </trans-unit>
        <trans-unit id="e603736762efe81e0cad9751283ad8e5a1c288ee" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;T(v)&lt;/code&gt; is equivalent to the value of &lt;code&gt;v&lt;/code&gt;.</source>
          <target state="translated">Значение &lt;code&gt;T(v)&lt;/code&gt; эквивалентно значению &lt;code&gt;v&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d8ede44778ad8d0c527731cf4a992de2cbbc6337" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;a &amp;gt;&amp;gt; b&lt;/code&gt; is a/2b</source>
          <target state="translated">Значение &lt;code&gt;a &amp;gt;&amp;gt; b&lt;/code&gt; равно a / 2b</target>
        </trans-unit>
        <trans-unit id="0e75326e3adb574a4a577f0c6f90eb22555c8d18" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;a &amp;lt;&amp;lt; b&lt;/code&gt; is the unique value congruent to a * 2b</source>
          <target state="translated">Значение &lt;code&gt;a &amp;lt;&amp;lt; b&lt;/code&gt; является уникальным значением, равным a * 2b</target>
        </trans-unit>
        <trans-unit id="74363b0d87e71eb3303d92bd255f435d2a3c664f" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;base&lt;/code&gt; if successful, zero otherwise.</source>
          <target state="translated">Значение &lt;code&gt;base&lt;/code&gt; случае успеха, ноль в противном случае.</target>
        </trans-unit>
        <trans-unit id="56ee130795a5dbf75897c6a6783296c3ad1b779f" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;errno&lt;/code&gt; is &lt;code&gt;​0​&lt;/code&gt; at program startup, and although library functions are allowed to write positive integers to &lt;code&gt;errno&lt;/code&gt; whether or not an error occurred, library functions never store &lt;code&gt;​0​&lt;/code&gt; in &lt;code&gt;errno&lt;/code&gt;.</source>
          <target state="translated">Значение &lt;code&gt;errno&lt;/code&gt; является &lt;code&gt;​0​&lt;/code&gt; при запуске программы, и хотя библиотечные функции могут писать целые положительные числа в &lt;code&gt;errno&lt;/code&gt; или не произошла ошибка, библиотечные функции никогда не хранить &lt;code&gt;​0​&lt;/code&gt; в &lt;code&gt;errno&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="da2294d8108c3a6f801f89b03514268af0f31351" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;math_errhandling&lt;/code&gt; indicates the type of error handling that is performed by the floating-point operators and &lt;a href=&quot;../math&quot;&gt;functions&lt;/a&gt;:</source>
          <target state="translated">Значение &lt;code&gt;math_errhandling&lt;/code&gt; указывает тип обработки ошибок, которая выполняется операторами и &lt;a href=&quot;../math&quot;&gt;функциями&lt;/a&gt; с плавающей точкой :</target>
        </trans-unit>
        <trans-unit id="7588ffd7a3be6d286f7a94c5cb61054a64fe7ac0" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;required_alignment&lt;/code&gt; is the required alignment for an object to be referenced by an atomic reference, which is at least &lt;code&gt;alignof(T)&lt;/code&gt;.</source>
          <target state="translated">Значение &lt;code&gt;required_alignment&lt;/code&gt; является обязательным выравниванием для объекта, на который должна ссылаться атомная ссылка, которая является, по крайней мере, &lt;code&gt;alignof(T)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a34573176a6c9f015786e0ff510ba4a79a46897b" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;t&lt;/code&gt; is equivalent to the value of &lt;code&gt;v&lt;/code&gt;.</source>
          <target state="translated">Значение &lt;code&gt;t&lt;/code&gt; эквивалентно значению &lt;code&gt;v&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="236ee56b867559bead4e59b54a4e12b218879b5a" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;u&lt;/code&gt; is equivalent to the value of &lt;code&gt;rv&lt;/code&gt; before the initialization.</source>
          <target state="translated">Значение &lt;code&gt;u&lt;/code&gt; эквивалентно значению &lt;code&gt;rv&lt;/code&gt; до инициализации.</target>
        </trans-unit>
        <trans-unit id="29aad058a8f1625b999d87663e4e7194ff6bfb72" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;u&lt;/code&gt; is equivalent to the value of &lt;code&gt;v&lt;/code&gt;.</source>
          <target state="translated">Значение &lt;code&gt;u&lt;/code&gt; эквивалентно значению &lt;code&gt;v&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c88528c3373936092717d4d0ad525f88f8c4c725" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;v&lt;/code&gt; is unchanged.</source>
          <target state="translated">Значение &lt;code&gt;v&lt;/code&gt; не изменяется.</target>
        </trans-unit>
        <trans-unit id="1e00c73d0ffbf3ea2f54f0b446263ab8f6d39011" translate="yes" xml:space="preserve">
          <source>The value of the &lt;code&gt;std::contract_violation&lt;/code&gt; argument passed to the violation handler is otherwise implementation-defined.</source>
          <target state="translated">В противном случае значение аргумента &lt;code&gt;std::contract_violation&lt;/code&gt; передаваемое обработчику нарушения, определяется реализацией.</target>
        </trans-unit>
        <trans-unit id="50fc3e65512141062b28f772c21ab1b1ae455710" translate="yes" xml:space="preserve">
          <source>The value of the atomic variable before the call.</source>
          <target state="translated">Значение атомарной переменной перед вызовом.</target>
        </trans-unit>
        <trans-unit id="a3e86cc39cfa2d8064dc4c87f48911c38b5823b0" translate="yes" xml:space="preserve">
          <source>The value of the character pointed to by the</source>
          <target state="translated">Значение персонажа,на который указывает</target>
        </trans-unit>
        <trans-unit id="a2c309bf2bbc046c6f48e885d2ea4de4c5bf6803" translate="yes" xml:space="preserve">
          <source>The value of the character that was pointed to by the</source>
          <target state="translated">Значение персонажа,на который указывал</target>
        </trans-unit>
        <trans-unit id="1d70250e3d2b884af86af7d39be631bda55177ff" translate="yes" xml:space="preserve">
          <source>The value of the character that was read and consumed in case of success, or &lt;code&gt;Traits::eof()&lt;/code&gt; in case of failure.</source>
          <target state="translated">Значение символа, который был прочитан и использован в случае успеха, или &lt;code&gt;Traits::eof()&lt;/code&gt; в случае ошибки.</target>
        </trans-unit>
        <trans-unit id="8f39527ddfa65bb2b87383657aeac9ba9fbcb938" translate="yes" xml:space="preserve">
          <source>The value of the device entropy, or zero if not applicable.</source>
          <target state="translated">Значение энтропии устройства,или ноль,если не применимо.</target>
        </trans-unit>
        <trans-unit id="9650465fffa6e1c6a542896eedb2d7c139c42b4e" translate="yes" xml:space="preserve">
          <source>The value of the exponent returned by &lt;code&gt;std::ilogb&lt;/code&gt; is always 1 less than the exponent retuned by &lt;code&gt;&lt;a href=&quot;frexp&quot;&gt;std::frexp&lt;/a&gt;&lt;/code&gt; because of the different normalization requirements: for the exponent &lt;code&gt;e&lt;/code&gt; returned by &lt;code&gt;std::ilogb&lt;/code&gt;, |arg*r-e</source>
          <target state="translated">Значение показателя, возвращаемого &lt;code&gt;std::ilogb&lt;/code&gt; , всегда на 1 меньше, чем показатель, &lt;code&gt;&lt;a href=&quot;frexp&quot;&gt;std::frexp&lt;/a&gt;&lt;/code&gt; из-за различных требований нормализации: для показателя &lt;code&gt;e&lt;/code&gt; , возвращаемого &lt;code&gt;std::ilogb&lt;/code&gt; , | arg * re</target>
        </trans-unit>
        <trans-unit id="296087b3564287e313cec1b7f024f1690f7740f9" translate="yes" xml:space="preserve">
          <source>The value of the exponent returned by &lt;code&gt;std::logb&lt;/code&gt; is always 1 less than the exponent retuned by &lt;code&gt;&lt;a href=&quot;frexp&quot;&gt;std::frexp&lt;/a&gt;&lt;/code&gt; because of the different normalization requirements: for the exponent &lt;code&gt;e&lt;/code&gt; returned by &lt;code&gt;std::logb&lt;/code&gt;, |arg*r-e</source>
          <target state="translated">Значение показателя, возвращаемого &lt;code&gt;std::logb&lt;/code&gt; , всегда на 1 меньше, чем показатель, &lt;code&gt;&lt;a href=&quot;frexp&quot;&gt;std::frexp&lt;/a&gt;&lt;/code&gt; из-за различных требований нормализации: для показателя &lt;code&gt;e&lt;/code&gt; , возвращаемого &lt;code&gt;std::logb&lt;/code&gt; , | arg * re</target>
        </trans-unit>
        <trans-unit id="1875dc13670139d279ca0c0bbdce2d158a5cdbab" translate="yes" xml:space="preserve">
          <source>The value of the next character. If the input sequence has been exhausted, &lt;code&gt;Traits::eof()&lt;/code&gt; is returned.</source>
          <target state="translated">Значение следующего символа. Если входная последовательность исчерпана, &lt;code&gt;Traits::eof()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="753fa9ec46bd8acaa1bc2b9508919ca2004c1c39" translate="yes" xml:space="preserve">
          <source>The value of the parameter is passed to the object at the construction time and stored within the object. Whenever the function object is invoked though &lt;code&gt;operator()&lt;/code&gt;, the stored value is passed as one of the arguments, the other argument is passed as an argument of &lt;code&gt;operator()&lt;/code&gt;. The resulting function object is an unary function.</source>
          <target state="translated">Значение параметра передается объекту во время строительства и сохраняется в объекте. Всякий раз, когда объект функции вызывается через &lt;code&gt;operator()&lt;/code&gt; , сохраненное значение передается как один из аргументов, другой аргумент передается как аргумент &lt;code&gt;operator()&lt;/code&gt; . Полученный объект функции является унарной функцией.</target>
        </trans-unit>
        <trans-unit id="fba7a209e09ccfdda21dc54ae2df8a504208cb4c" translate="yes" xml:space="preserve">
          <source>The value of the referenced object before the call.</source>
          <target state="translated">Значение объекта,на который делается ссылка,перед вызовом.</target>
        </trans-unit>
        <trans-unit id="579ea98c704ce031e4e668b7afec012ffc8fd162" translate="yes" xml:space="preserve">
          <source>The value of the referenced object, immediately preceding the effects of this function.</source>
          <target state="translated">Значение объекта,на который делается ссылка,непосредственно предшествующее эффекту этой функции.</target>
        </trans-unit>
        <trans-unit id="7e259073fe670a628dfb34370ab4b87683b659c4" translate="yes" xml:space="preserve">
          <source>The value of this constant is consistent with both the macro &lt;code&gt;ATOMIC_xxx_LOCK_FREE&lt;/code&gt;, where defined, with the member function &lt;code&gt;is_lock_free&lt;/code&gt; and non-member function &lt;code&gt;&lt;a href=&quot;../atomic_is_lock_free&quot;&gt;std::atomic_is_lock_free&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Значение этой константы соответствует как макросу &lt;code&gt;ATOMIC_xxx_LOCK_FREE&lt;/code&gt; , где он определен, так и функции- &lt;code&gt;is_lock_free&lt;/code&gt; и функции, не являющейся членом &lt;code&gt;&lt;a href=&quot;../atomic_is_lock_free&quot;&gt;std::atomic_is_lock_free&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="50845a026f496d39a63c3b0808c04361d0c8d58a" translate="yes" xml:space="preserve">
          <source>The value of this constant is consistent with the result of member function &lt;code&gt;is_lock_free&lt;/code&gt;.</source>
          <target state="translated">Значение этой константы согласуется с результатом функции-члена &lt;code&gt;is_lock_free&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3403e199b11ef7fa0931fa58eddb8861252d4576" translate="yes" xml:space="preserve">
          <source>The value of type &lt;code&gt;char_type&lt;/code&gt; to use as the decimal separator. The standard specializations of &lt;code&gt;std::numpunct&lt;/code&gt; return &lt;code&gt;'.'&lt;/code&gt; and &lt;code&gt;L'.'&lt;/code&gt;.</source>
          <target state="translated">Значение типа &lt;code&gt;char_type&lt;/code&gt; для использования в качестве десятичного разделителя. Стандартные специализации &lt;code&gt;std::numpunct&lt;/code&gt; возвращают &lt;code&gt;'.'&lt;/code&gt; и &lt;code&gt;L'.'&lt;/code&gt; ,</target>
        </trans-unit>
        <trans-unit id="d17479026d3ea907d688db9d63f82d0f2b54dabe" translate="yes" xml:space="preserve">
          <source>The value or reference, if any, returned by the above call to &lt;code&gt;Container::emplace_back&lt;/code&gt;.</source>
          <target state="translated">Значение или ссылка, если таковые имеются, возвращаются вышеуказанным вызовом &lt;code&gt;Container::emplace_back&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c811b075e6e49eb2c35eb490d71ce4d51653f77f" translate="yes" xml:space="preserve">
          <source>The value previously held by the flag pointed to by &lt;code&gt;p&lt;/code&gt;.</source>
          <target state="translated">Значение, ранее сохраненное флагом, на которое указывает &lt;code&gt;p&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2e567269120efb53b09110c26a8c4b9df966cef5" translate="yes" xml:space="preserve">
          <source>The value represented by the digit &lt;code&gt;c&lt;/code&gt; in base &lt;code&gt;I&lt;/code&gt; if the character &lt;code&gt;c&lt;/code&gt; is a valid digit in base &lt;code&gt;I&lt;/code&gt;</source>
          <target state="translated">Значение, представленное цифрой &lt;code&gt;c&lt;/code&gt; в базе &lt;code&gt;I&lt;/code&gt; , если символ &lt;code&gt;c&lt;/code&gt; является действительной цифрой в базе &lt;code&gt;I&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6f109c11a81bea0070c0d68dbb9891509f2180fe" translate="yes" xml:space="preserve">
          <source>The value represents the number of failures in a series of independent yes/no trials (each succeeds with probability p), before exactly k successes occur.</source>
          <target state="translated">Значение представляет собой количество неудач в серии независимых испытаний &quot;да/нет&quot; (каждое успешно с вероятностью p),прежде чем произойдет ровно k успешных испытаний.</target>
        </trans-unit>
        <trans-unit id="8e434c235337a8e747f5dea3bd883fac3c017159" translate="yes" xml:space="preserve">
          <source>The value represents the number of yes/no trials (each succeeding with probability p) which are necessary to obtain a single success.</source>
          <target state="translated">Значение представляет собой число &quot;да/нет&quot; (каждое из них с вероятностью p),которые необходимы для получения одного успеха.</target>
        </trans-unit>
        <trans-unit id="bf46f4d3ca59d9f0505163079a8aeb0e0dc873f3" translate="yes" xml:space="preserve">
          <source>The value returned by &lt;code&gt;clock()&lt;/code&gt; may wrap around on some implementations. For example, on a machine with 32-bit &lt;code&gt;&lt;a href=&quot;clock_t&quot;&gt;std::clock_t&lt;/a&gt;&lt;/code&gt;, it wraps after 2147 seconds or 36 minutes.</source>
          <target state="translated">Значение, возвращаемое функцией &lt;code&gt;clock()&lt;/code&gt; может использоваться в некоторых реализациях. Например, на компьютере с 32-битным &lt;code&gt;&lt;a href=&quot;clock_t&quot;&gt;std::clock_t&lt;/a&gt;&lt;/code&gt; он переносится через 2147 секунд или 36 минут.</target>
        </trans-unit>
        <trans-unit id="ad4cdd680a12e6dfddb5ab5b51fcd6bb72586940" translate="yes" xml:space="preserve">
          <source>The value returned by &lt;code&gt;f&lt;/code&gt;.</source>
          <target state="translated">Значение, возвращаемое &lt;code&gt;f&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2f06ccf9b4233e6226d4ee4962b6bec1aa785187" translate="yes" xml:space="preserve">
          <source>The value returned by the called function.</source>
          <target state="translated">Значение,возвращаемое вызываемой функцией.</target>
        </trans-unit>
        <trans-unit id="601b8abd8b6436ee946fa9803b76f69133a0a540" translate="yes" xml:space="preserve">
          <source>The value returned by this conversion function is a pointer to a function with C++ &lt;a href=&quot;language_linkage&quot;&gt;language linkage&lt;/a&gt; that, when invoked, has the same effect as invoking the closure object's function call operator directly.</source>
          <target state="translated">Значение, возвращаемое этой функцией преобразования, является указателем на функцию со &lt;a href=&quot;language_linkage&quot;&gt;связью языка&lt;/a&gt; C ++, которая при вызове имеет тот же эффект, что и непосредственный вызов оператора вызова функции объекта замыкания.</target>
        </trans-unit>
        <trans-unit id="fdd035144b0ab851484c1c365e56cbd1dcc1b54a" translate="yes" xml:space="preserve">
          <source>The value returned shall be independent of the case of the characters in the sequence.</source>
          <target state="translated">Возвращаемое значение не должно зависеть от случая символов в последовательности.</target>
        </trans-unit>
        <trans-unit id="b7fb32b3c03551e69bd2a36e0056ba4535fa1910" translate="yes" xml:space="preserve">
          <source>The value that is held by the atomic object pointed to by &lt;code&gt;obj&lt;/code&gt;.</source>
          <target state="translated">Значение, которое содержится в атомарном объекте, указанном объектом &lt;code&gt;obj&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="833d5a34e8e09458e1d01611adfdc9d19f4256ea" translate="yes" xml:space="preserve">
          <source>The value that results from assigning or initializing a signed bit field with a value out of range, or from incrementing a signed bit field past its range.</source>
          <target state="translated">Значение,которое получается в результате присвоения или инициализации подписанного битового поля со значением вне диапазона,или в результате инкрементирования подписанного битового поля за пределы его диапазона.</target>
        </trans-unit>
        <trans-unit id="da945c5370b89f1c8352311f12a54ddba345a51b" translate="yes" xml:space="preserve">
          <source>The value type of &lt;code&gt;RandomIt1&lt;/code&gt; must be &lt;a href=&quot;../../named_req/defaultconstructible&quot;&gt;DefaultConstructible&lt;/a&gt;, &lt;a href=&quot;../../named_req/copyconstructible&quot;&gt;CopyConstructible&lt;/a&gt; and &lt;a href=&quot;../../named_req/copyassignable&quot;&gt;CopyAssignable&lt;/a&gt;.</source>
          <target state="translated">Тип значения &lt;code&gt;RandomIt1&lt;/code&gt; должен быть &lt;a href=&quot;../../named_req/defaultconstructible&quot;&gt;DefaultConstructible&lt;/a&gt; , &lt;a href=&quot;../../named_req/copyconstructible&quot;&gt;CopyConstructible&lt;/a&gt; и &lt;a href=&quot;../../named_req/copyassignable&quot;&gt;CopyAssignable&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="cf2f9d6307fbcb0677baa700e9f0dbc912c45998" translate="yes" xml:space="preserve">
          <source>The value zero (for integral, floating-point, and unscoped enumeration) and the null pointer and the null pointer-to-member values become &lt;code&gt;false&lt;/code&gt;. All other values become &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">Нулевое значение (для целочисленного, с плавающей точкой и перечисления с незаданной областью), а также нулевой указатель и нулевые значения указателя на элемент становятся &lt;code&gt;false&lt;/code&gt; . Все остальные ценности становятся &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7ba8effa4c27f0ba732998c45f3421c98781d70d" translate="yes" xml:space="preserve">
          <source>The values in the returned struct may differ from those supplied to the constructor in the following ways:</source>
          <target state="translated">Значения в возвращаемой структуре могут отличаться от поставляемых конструктору следующим образом:</target>
        </trans-unit>
        <trans-unit id="7a76aed414f920671ac2d5636063f80c02930b91" translate="yes" xml:space="preserve">
          <source>The values of &lt;code&gt;p_sep_by_space&lt;/code&gt;, &lt;code&gt;n_sep_by_space&lt;/code&gt;, &lt;code&gt;int_p_sep_by_space&lt;/code&gt;, &lt;code&gt;int_n_sep_by_space&lt;/code&gt; are interpreted as follows:</source>
          <target state="translated">Значения &lt;code&gt;p_sep_by_space&lt;/code&gt; , &lt;code&gt;n_sep_by_space&lt;/code&gt; , &lt;code&gt;int_p_sep_by_space&lt;/code&gt; , &lt;code&gt;int_n_sep_by_space&lt;/code&gt; интерпретируются следующим образом:</target>
        </trans-unit>
        <trans-unit id="77672f917a9b339a086c2698e191450e19cf6727" translate="yes" xml:space="preserve">
          <source>The values of &lt;code&gt;p_sign_posn&lt;/code&gt;, &lt;code&gt;n_sign_posn&lt;/code&gt;, &lt;code&gt;int_p_sign_posn&lt;/code&gt;, &lt;code&gt;int_n_sign_posn&lt;/code&gt; are interpreted as follows:</source>
          <target state="translated">Значения &lt;code&gt;p_sign_posn&lt;/code&gt; , &lt;code&gt;n_sign_posn&lt;/code&gt; , &lt;code&gt;int_p_sign_posn&lt;/code&gt; , &lt;code&gt;int_n_sign_posn&lt;/code&gt; интерпретируются следующим образом:</target>
        </trans-unit>
        <trans-unit id="33abc0ae5b48791fecb22e74c9f73d03bb18aa24" translate="yes" xml:space="preserve">
          <source>The values of the member typedefs are as follows.</source>
          <target state="translated">Значения шрифтов членов следующие.</target>
        </trans-unit>
        <trans-unit id="e9fe6d1f76a572b29a8d3484a98866cb41ec603b" translate="yes" xml:space="preserve">
          <source>The values of these macros (except for &lt;code&gt;__FILE__&lt;/code&gt; and &lt;code&gt;__LINE__&lt;/code&gt;) remain constant throughout the translation unit. Attempts to redefine or undefine these macros result in undefined behavior.</source>
          <target state="translated">Значения этих макросов (за исключением &lt;code&gt;__FILE__&lt;/code&gt; и &lt;code&gt;__LINE__&lt;/code&gt; ) остаются постоянными во всем блоке перевода. Попытки переопределить или отменить эти макросы приводят к неопределенному поведению.</target>
        </trans-unit>
        <trans-unit id="98bfbbcd22ae41d5573869cfcb9522362b10fb4c" translate="yes" xml:space="preserve">
          <source>The version of this function provided in the standard library specializations of &lt;code&gt;&lt;a href=&quot;../regex_traits&quot;&gt;std::regex_traits&lt;/a&gt;&lt;/code&gt; does the following:</source>
          <target state="translated">Версия этой функции, предоставленная в стандартных библиотеках специализаций &lt;code&gt;&lt;a href=&quot;../regex_traits&quot;&gt;std::regex_traits&lt;/a&gt;&lt;/code&gt; делает следующее:</target>
        </trans-unit>
        <trans-unit id="a622961aafca050ec72f078b30740b239e4cfd26" translate="yes" xml:space="preserve">
          <source>The versions (1-4) are implicitly declared in each translation unit even if the &lt;code&gt;&amp;lt;new&amp;gt;&lt;/code&gt; header is not included. Versions (1-8) are</source>
          <target state="translated">Версии (1-4) неявно объявляются в каждой единице перевода, даже если заголовок &lt;code&gt;&amp;lt;new&amp;gt;&lt;/code&gt; не включен. Версии (1-8)</target>
        </trans-unit>
        <trans-unit id="b0b7d7c2aa828b9a641d26b6867ec8872ed88500" translate="yes" xml:space="preserve">
          <source>The weak forms ((1) and (3)) of the functions are allowed to fail spuriously, that is, act as if &lt;code&gt;*obj != *expected&lt;/code&gt; even if they are equal. When a compare-and-exchange is in a loop, the weak version will yield better performance on some platforms.</source>
          <target state="translated">Слабые формы ((1) и (3)) функций допускаются сбои, то есть действуют так, как если бы &lt;code&gt;*obj != *expected&lt;/code&gt; даже если они равны. Когда цикл сравнения и обмена находится в цикле, слабая версия даст лучшую производительность на некоторых платформах.</target>
        </trans-unit>
        <trans-unit id="053ece5439dd03785d396cff64f13b7779aae0c4" translate="yes" xml:space="preserve">
          <source>The weak forms (1-2) of the functions are allowed to fail spuriously, that is, act as if &lt;code&gt;*this != expected&lt;/code&gt; even if they are equal. When a compare-and-exchange is in a loop, the weak version will yield better performance on some platforms.</source>
          <target state="translated">Слабым формам (1-2) функций разрешается внезапно выходить из строя, то есть действовать так, как если бы &lt;code&gt;*this != expected&lt;/code&gt; даже если они равны. Когда цикл сравнения и обмена находится в цикле, слабая версия даст лучшую производительность на некоторых платформах.</target>
        </trans-unit>
        <trans-unit id="61282ad563d58ac6dca223420c82a6fda52cb8a1" translate="yes" xml:space="preserve">
          <source>The weakest alignment (the smallest alignment requirement) is the alignment of &lt;code&gt;char&lt;/code&gt;, &lt;code&gt;signed char&lt;/code&gt;, and &lt;code&gt;unsigned char&lt;/code&gt;, which equals 1; the largest</source>
          <target state="translated">Самым слабым выравниванием (наименьшим требованием выравнивания) является выравнивание &lt;code&gt;char&lt;/code&gt; , &lt;code&gt;signed char&lt;/code&gt; и &lt;code&gt;unsigned char&lt;/code&gt; , равное 1; самый большой</target>
        </trans-unit>
        <trans-unit id="6636ab7a40ed20b3758bf9d6aa3f53a69dfb3fd6" translate="yes" xml:space="preserve">
          <source>The weekday value stored in &lt;code&gt;*this&lt;/code&gt;.</source>
          <target state="translated">Значение дня недели, хранящееся в &lt;code&gt;*this&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="147c41b97d63a5ff943a4dff64e656850433bca6" translate="yes" xml:space="preserve">
          <source>The whitespace skipping is performed by the constructor of &lt;code&gt;&lt;a href=&quot;../basic_istream/sentry&quot;&gt;std::basic_istream::sentry&lt;/a&gt;&lt;/code&gt;, which reads and discards the characters classified as whitespace by the &lt;code&gt;&lt;a href=&quot;../../locale/ctype&quot;&gt;std::ctype&lt;/a&gt;&lt;/code&gt; facet of the stream's imbued locale.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../basic_istream/sentry&quot;&gt;std::basic_istream::sentry&lt;/a&gt;&lt;/code&gt; пробелов выполняется конструктором std :: basic_istream :: sentry , который считывает и отбрасывает символы, классифицированные как пробелы по фасету &lt;code&gt;&lt;a href=&quot;../../locale/ctype&quot;&gt;std::ctype&lt;/a&gt;&lt;/code&gt; пропускаемой локали потока.</target>
        </trans-unit>
        <trans-unit id="28861a2e9cac8a64e7e6c9de02d8f4ad1d432f65" translate="yes" xml:space="preserve">
          <source>The width property of the stream will be reset to zero (meaning &quot;unspecified&quot;) if any of the following functions are called:</source>
          <target state="translated">Свойство width (ширина)потока сбрасывается к нулю (имеется в виду &quot;неуточнено&quot;)при вызове любой из следующих функций:</target>
        </trans-unit>
        <trans-unit id="75482b7330efd238856a66fa9534aa457b8aac86" translate="yes" xml:space="preserve">
          <source>The written character, converted to &lt;code&gt;int_type&lt;/code&gt; with &lt;code&gt;Traits::to_int_type(ch)&lt;/code&gt; on success.</source>
          <target state="translated">Письменный символ, преобразованный в &lt;code&gt;int_type&lt;/code&gt; с &lt;code&gt;Traits::to_int_type(ch)&lt;/code&gt; в случае успеха.</target>
        </trans-unit>
        <trans-unit id="1270ca56a41a6e7f02e1f97ce0b715f2fb7199a2" translate="yes" xml:space="preserve">
          <source>The year value stored in &lt;code&gt;*this&lt;/code&gt;.</source>
          <target state="translated">Значение года хранится в &lt;code&gt;*this&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d323f4076e0841438d41510cd53cbcfb9286a841" translate="yes" xml:space="preserve">
          <source>Then &lt;code&gt;replacement&lt;/code&gt; is appended as if by &lt;code&gt;operator+=(replacement)&lt;/code&gt;.</source>
          <target state="translated">Затем &lt;code&gt;replacement&lt;/code&gt; добавляется, как если бы &lt;code&gt;operator+=(replacement)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="373a08cad37838d1afc67f2d26d81125cf6dd627" translate="yes" xml:space="preserve">
          <source>Then &lt;code&gt;std::launder(p)&lt;/code&gt; returns a value of type &lt;code&gt;T*&lt;/code&gt; that points to the object &lt;code&gt;X&lt;/code&gt;. Otherwise, the behavior is undefined.</source>
          <target state="translated">Тогда &lt;code&gt;std::launder(p)&lt;/code&gt; возвращает значение типа &lt;code&gt;T*&lt;/code&gt; , что указывает на объект &lt;code&gt;X&lt;/code&gt; . В противном случае поведение не определено.</target>
        </trans-unit>
        <trans-unit id="a8cef55836d6512dfe4dc252602d2fb2a942c56d" translate="yes" xml:space="preserve">
          <source>Then converts the argument &lt;code&gt;dir&lt;/code&gt; to a value &lt;code&gt;whence&lt;/code&gt; of type &lt;code&gt;int&lt;/code&gt; as follows:</source>
          <target state="translated">Затем преобразует аргумент &lt;code&gt;dir&lt;/code&gt; до значения , &lt;code&gt;whence&lt;/code&gt; типа &lt;code&gt;int&lt;/code&gt; следующим образом :</target>
        </trans-unit>
        <trans-unit id="d114c31b8c85d68931469ea5e0153732743033d0" translate="yes" xml:space="preserve">
          <source>Then for the expression &lt;code&gt;w1 == w2&lt;/code&gt; and &lt;code&gt;w1 != w2&lt;/code&gt; either or both objects may be replaced by an</source>
          <target state="translated">Тогда для выражения &lt;code&gt;w1 == w2&lt;/code&gt; и &lt;code&gt;w1 != w2&lt;/code&gt; любой или оба объекта могут быть заменены на</target>
        </trans-unit>
        <trans-unit id="5664e9f77aa6963c92dfdd8b0b7e6f96d1c31677" translate="yes" xml:space="preserve">
          <source>Then performs move-assignment by moving all contents from &lt;code&gt;other&lt;/code&gt;, including the temporary storage, the wrapped stream pointer, policy, and all other state (such as the mutex pointer). After move, &lt;code&gt;other&lt;/code&gt; is not associated with a stream, and &lt;code&gt;other.get_wrapped()==nullptr&lt;/code&gt;. The put area member pointers of the base class &lt;code&gt;&lt;a href=&quot;../basic_streambuf&quot;&gt;std::basic_streambuf&lt;/a&gt;&lt;/code&gt; of &lt;code&gt;other&lt;/code&gt; are guaranteed to be null. Destroying a moved-from &lt;code&gt;other&lt;/code&gt; will not produce any output.</source>
          <target state="translated">Затем выполняет назначение перемещения, перемещая все содержимое из &lt;code&gt;other&lt;/code&gt; , включая временное хранилище, указатель обернутого потока, политику и все другие состояния (например, указатель мьютекса). После перемещения &lt;code&gt;other&lt;/code&gt; не ассоциируется с потоком, а &lt;code&gt;other.get_wrapped()==nullptr&lt;/code&gt; . Указатели на члены области размещения базового класса &lt;code&gt;&lt;a href=&quot;../basic_streambuf&quot;&gt;std::basic_streambuf&lt;/a&gt;&lt;/code&gt; для &lt;code&gt;other&lt;/code&gt; гарантированно будут нулевыми. Уничтожение перемещенного &lt;code&gt;other&lt;/code&gt; не даст никакого результата.</target>
        </trans-unit>
        <trans-unit id="688a34f8e387e542a111a325ed5ac02b72fbb6e9" translate="yes" xml:space="preserve">
          <source>Then repositions the file pointer, as if by calling &lt;code&gt;&lt;a href=&quot;../c/fsetpos&quot;&gt;std::fsetpos()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Затем перемещает указатель файла, как будто вызывая &lt;code&gt;&lt;a href=&quot;../c/fsetpos&quot;&gt;std::fsetpos()&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7c6cd6761eff74a4e8721e60e098e84a0745d88f" translate="yes" xml:space="preserve">
          <source>Then stores each character from the resulting sequence (the contents of &lt;code&gt;str&lt;/code&gt; plus padding) to the output stream &lt;code&gt;os&lt;/code&gt; as if by calling &lt;code&gt;os.rdbuf()-&amp;gt;sputn(seq, n)&lt;/code&gt;, where &lt;code&gt;n=&lt;a href=&quot;../../algorithm/max&quot;&gt;std::max&lt;/a&gt;(os.width(), str.size())&lt;/code&gt;.</source>
          <target state="translated">Затем сохраняет каждый символ из результирующей последовательности (содержимое &lt;code&gt;str&lt;/code&gt; плюс заполнение) в выходной поток &lt;code&gt;os&lt;/code&gt; , как если бы он вызывал &lt;code&gt;os.rdbuf()-&amp;gt;sputn(seq, n)&lt;/code&gt; , где &lt;code&gt;n=&lt;a href=&quot;../../algorithm/max&quot;&gt;std::max&lt;/a&gt;(os.width(), str.size())&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="89dd54897998475390b292a027e7346fd0e80fba" translate="yes" xml:space="preserve">
          <source>Then stores each character from the resulting sequence (the contents of &lt;code&gt;v&lt;/code&gt; plus padding) to the output stream &lt;code&gt;os&lt;/code&gt; as if by calling &lt;code&gt;os.rdbuf()-&amp;gt;sputn(seq, n)&lt;/code&gt;, where &lt;code&gt;n=&lt;a href=&quot;../../algorithm/max&quot;&gt;std::max&lt;/a&gt;(os.width(), str.size())&lt;/code&gt;.</source>
          <target state="translated">Затем сохраняет каждый символ из результирующей последовательности (содержимое &lt;code&gt;v&lt;/code&gt; плюс padding) в выходной поток &lt;code&gt;os&lt;/code&gt; , как если бы он вызывал &lt;code&gt;os.rdbuf()-&amp;gt;sputn(seq, n)&lt;/code&gt; , где &lt;code&gt;n=&lt;a href=&quot;../../algorithm/max&quot;&gt;std::max&lt;/a&gt;(os.width(), str.size())&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b71560ffb9f745af8a0de8c02270fff34828d1a4" translate="yes" xml:space="preserve">
          <source>Then template-1 is more specialized than template-2. If the conditions above are true after switching template order, than template-2 is more specialized than template-1. Otherwise, neither template is more specialized than the other. In case of a tie, if one function template has a trailing parameter pack and the other does not, the one with the omitted parameter is considered to be more specialized than the one with the empty parameter pack.</source>
          <target state="translated">Тогда шаблон-1 более специализирован,чем шаблон-2.Если вышеприведенные условия верны после переключения порядка шаблонов,то шаблон-2 более специализирован,чем шаблон-1.В противном случае ни один из шаблонов не является более специализированным,чем другой.В случае ничьей,если шаблон одной функции имеет пакет параметров трейлинга,а другой нет,то шаблон с опущенным параметром считается более специализированным,чем шаблон с пустым пакетом параметров.</target>
        </trans-unit>
        <trans-unit id="d3271caf912e95526fbf0f4e50e8dacc62c22392" translate="yes" xml:space="preserve">
          <source>Then the function behaves as &lt;a href=&quot;../../named_req/unformattedinputfunction&quot;&gt;UnformattedInputFunction&lt;/a&gt;. After constructing and checking the sentry object, if any &lt;code&gt;ios_base::iostate&lt;/code&gt; flags are set, the function sets &lt;code&gt;failbit&lt;/code&gt; and returns. Otherwise, calls &lt;code&gt;rdbuf()-&amp;gt;sungetc()&lt;/code&gt;.</source>
          <target state="translated">Тогда функция ведет себя как &lt;a href=&quot;../../named_req/unformattedinputfunction&quot;&gt;UnformattedInputFunction&lt;/a&gt; . После создания и проверки объекта &lt;code&gt;ios_base::iostate&lt;/code&gt; , если установлены какие- либо флаги ios_base :: iostate , функция устанавливает &lt;code&gt;failbit&lt;/code&gt; и возвращает. В противном случае вызывает &lt;code&gt;rdbuf()-&amp;gt;sungetc()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="36f34a067b6d5809ad8db68785a0d829422e3317" translate="yes" xml:space="preserve">
          <source>Then this function in the class &lt;code&gt;Derived&lt;/code&gt; is also</source>
          <target state="translated">Тогда эта функция в классе &lt;code&gt;Derived&lt;/code&gt; также</target>
        </trans-unit>
        <trans-unit id="7f48f8e860002b0a6fca10b3b58cdef248ff8167" translate="yes" xml:space="preserve">
          <source>Then, &lt;code&gt;awaiter.await_ready()&lt;/code&gt; is called (this is a short-cut to avoid the cost of suspension if it's known that the result is ready or can be completed synchronously). If its result, contextually-converted to bool is &lt;code&gt;false&lt;/code&gt; then.</source>
          <target state="translated">Затем &lt;code&gt;awaiter.await_ready()&lt;/code&gt; (это сокращение, чтобы избежать затрат на приостановку, если известно, что результат готов или может быть выполнен синхронно). Если его результат, контекстно-преобразованный в bool, тогда &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8f56bc35fde57e5d45735f7118718bf8634008b7" translate="yes" xml:space="preserve">
          <source>Then, a dot character is appended to the generic-format view of the pathname, if &lt;code&gt;replacement&lt;/code&gt; is not empty or does not begin with a dot character.</source>
          <target state="translated">Затем символ точки добавляется к представлению общего формата пути, если &lt;code&gt;replacement&lt;/code&gt; не пуста или не начинается с символа точки.</target>
        </trans-unit>
        <trans-unit id="7a8ce560ef479ac7bd437cfaae9fee813911dce4" translate="yes" xml:space="preserve">
          <source>Then, closes the file as if by calling &lt;code&gt;&lt;a href=&quot;../c/fclose&quot;&gt;std::fclose()&lt;/a&gt;&lt;/code&gt;, regardless of whether any of the preceding calls succeeded or failed.</source>
          <target state="translated">Затем закрывает файл, как если бы он вызывал &lt;code&gt;&lt;a href=&quot;../c/fclose&quot;&gt;std::fclose()&lt;/a&gt;&lt;/code&gt; , независимо от того, был ли какой-либо из предыдущих вызовов успешным или неудачным.</target>
        </trans-unit>
        <trans-unit id="bb70360ec88c4bb9dac2644a98645695f52f42d5" translate="yes" xml:space="preserve">
          <source>Then, for the expressions &lt;code&gt;p1 == p2&lt;/code&gt;, &lt;code&gt;p1 != p2&lt;/code&gt;, &lt;code&gt;p1 &amp;lt; p2&lt;/code&gt;&lt;code&gt;p1 &amp;lt;= p2&lt;/code&gt;, &lt;code&gt;p1 &amp;gt;= p2&lt;/code&gt;, &lt;code&gt;p1 &amp;gt; p2&lt;/code&gt;, &lt;code&gt;p1 - p2&lt;/code&gt;} either or both objects may be replaced by an</source>
          <target state="translated">Тогда для выражений &lt;code&gt;p1 == p2&lt;/code&gt; , &lt;code&gt;p1 != p2&lt;/code&gt; , &lt;code&gt;p1 &amp;lt; p2&lt;/code&gt; &lt;code&gt;p1 &amp;lt;= p2&lt;/code&gt; , &lt;code&gt;p1 &amp;gt;= p2&lt;/code&gt; , &lt;code&gt;p1 &amp;gt; p2&lt;/code&gt; , &lt;code&gt;p1 - p2&lt;/code&gt; } любой или оба объекта могут быть заменены на</target>
        </trans-unit>
        <trans-unit id="03792c753032d7cb9233d55af244f2b35fa6ba5a" translate="yes" xml:space="preserve">
          <source>Then, if &lt;code&gt;seq.size() &amp;lt; out.width()&lt;/code&gt;, adds &lt;code&gt;out.width()-seq.size()&lt;/code&gt; copies of the fill character &lt;code&gt;out.fill()&lt;/code&gt; either at the end of the sequence (if &lt;code&gt;ios_base::left&lt;/code&gt; is set in &lt;code&gt;out.flags()&lt;/code&gt;) or at the beginning of the sequence (in all other cases).</source>
          <target state="translated">Затем, если &lt;code&gt;seq.size() &amp;lt; out.width()&lt;/code&gt; , добавляет &lt;code&gt;out.width()-seq.size()&lt;/code&gt; копии символа заполнения &lt;code&gt;out.fill()&lt;/code&gt; в конце последовательности (если &lt;code&gt;ios_base::left&lt;/code&gt; устанавливается в &lt;code&gt;out.flags()&lt;/code&gt; ) или в начале последовательности (во всех других случаях).</target>
        </trans-unit>
        <trans-unit id="9b66cf1ae7e463d5761dc0c8e4b85c87a42f6ae4" translate="yes" xml:space="preserve">
          <source>Then, if the character encoding is fixed-width (&lt;code&gt;codecvt::encoding()&lt;/code&gt; returns some positive number &lt;code&gt;width&lt;/code&gt;, moves the file pointer as if by &lt;code&gt;&lt;a href=&quot;../c/fseek&quot;&gt;std::fseek&lt;/a&gt;(file, width*off, whence)&lt;/code&gt;.</source>
          <target state="translated">Затем, если кодировка символов имеет фиксированную ширину ( &lt;code&gt;codecvt::encoding()&lt;/code&gt; возвращает некоторую положительную &lt;code&gt;width&lt;/code&gt; числа , перемещает указатель файла как будто с помощью &lt;code&gt;&lt;a href=&quot;../c/fseek&quot;&gt;std::fseek&lt;/a&gt;(file, width*off, whence)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1588837f0abae43644f6a59f2a7e9d05829935b3" translate="yes" xml:space="preserve">
          <source>Then, if the current emit-on-sync policy is &lt;code&gt;true&lt;/code&gt;, makes a call to &lt;a href=&quot;emit&quot;&gt;&lt;code&gt;emit()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Затем, если текущая политика emit-on-sync &lt;code&gt;true&lt;/code&gt; , выполняет вызов &lt;a href=&quot;emit&quot;&gt; &lt;code&gt;emit()&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e328ed3f5e3fe95a687636b98322058fa4cd84c4" translate="yes" xml:space="preserve">
          <source>Then, move-assigns the wrapped &lt;code&gt;std::basic_syncbuf&lt;/code&gt; from the corresponding member of &lt;code&gt;other&lt;/code&gt; (after this move-assignment, &lt;code&gt;other.get_wrapped()&lt;/code&gt; returns a null pointer and destruction of &lt;code&gt;other&lt;/code&gt; produces no output) and &lt;a href=&quot;../basic_ostream/operator=&quot;&gt;move-assigns&lt;/a&gt; the base &lt;code&gt;&lt;a href=&quot;../basic_ostream&quot;&gt;std::basic_ostream&lt;/a&gt;&lt;/code&gt; (this swaps all stream state variables except for &lt;code&gt;rdbuf&lt;/code&gt; between &lt;code&gt;*this&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt;).</source>
          <target state="translated">Затем move-назначает обернутый &lt;code&gt;std::basic_syncbuf&lt;/code&gt; от соответствующего члена &lt;code&gt;other&lt;/code&gt; (после этого move-assignment &lt;code&gt;other.get_wrapped()&lt;/code&gt; возвращает нулевой указатель, а уничтожение &lt;code&gt;other&lt;/code&gt; не приводит к выводу) и &lt;a href=&quot;../basic_ostream/operator=&quot;&gt;move-назначает&lt;/a&gt; базовый &lt;code&gt;&lt;a href=&quot;../basic_ostream&quot;&gt;std::basic_ostream&lt;/a&gt;&lt;/code&gt; (это меняет местами все переменные состояния потока, кроме &lt;code&gt;rdbuf&lt;/code&gt; между &lt;code&gt;*this&lt;/code&gt; и &lt;code&gt;other&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="cac51d51872e9519bbc0bc669f0606d196b2f4a3" translate="yes" xml:space="preserve">
          <source>Then, the awaiter object is obtained, as follows:</source>
          <target state="translated">Затем получается объект ожидания,как показано ниже:</target>
        </trans-unit>
        <trans-unit id="6b9e0d6ed6f7b1751b629f6e3ddc80ecb32c6693" translate="yes" xml:space="preserve">
          <source>Then, whether &lt;code&gt;to&lt;/code&gt; already existed or was just created, iterates over the files contained in &lt;code&gt;from&lt;/code&gt; as if by &lt;code&gt;for (const &lt;a href=&quot;directory_entry&quot;&gt;std::filesystem::directory_entry&lt;/a&gt;&amp;amp; x : &lt;a href=&quot;directory_iterator&quot;&gt;std::filesystem::directory_iterator&lt;/a&gt;(from))&lt;/code&gt; and for each directory entry, recursively calls &lt;code&gt;copy(x.path(), to/x.path().filename(), options | in-recursive-copy)&lt;/code&gt;, where</source>
          <target state="translated">Затем, независимо &lt;code&gt;to&lt;/code&gt; того, существовал он или был только что создан, выполняет итерацию по файлам, содержащимся в &lt;code&gt;from&lt;/code&gt; , как если бы &lt;code&gt;for (const &lt;a href=&quot;directory_entry&quot;&gt;std::filesystem::directory_entry&lt;/a&gt;&amp;amp; x : &lt;a href=&quot;directory_iterator&quot;&gt;std::filesystem::directory_iterator&lt;/a&gt;(from))&lt;/code&gt; и для каждой записи каталога , рекурсивно вызывает &lt;code&gt;copy(x.path(), to/x.path().filename(), options | in-recursive-copy)&lt;/code&gt; , где</target>
        </trans-unit>
        <trans-unit id="e9125d469bb8f6aff93d3721871c0958a43dafdd" translate="yes" xml:space="preserve">
          <source>Then, x1 and x2 are</source>
          <target state="translated">Затем,х1 и х2</target>
        </trans-unit>
        <trans-unit id="c5bb0afc7219a935f5a73b87436c78d57282e9f3" translate="yes" xml:space="preserve">
          <source>Then.</source>
          <target state="translated">Then.</target>
        </trans-unit>
        <trans-unit id="dcb618e3bc4e6760e6d24a1d8c4732cdb2523ec0" translate="yes" xml:space="preserve">
          <source>Theoretical maximum allocation size.</source>
          <target state="translated">Теоретический максимальный размер распределения.</target>
        </trans-unit>
        <trans-unit id="7dcca98b4934dc33e5546547c327611fcc667809" translate="yes" xml:space="preserve">
          <source>There are alternative spellings for several operators and other tokens that use non-ISO646 characters. In all respects of the language, each alternative token behaves exactly the same as its primary token, except for its spelling (the &lt;a href=&quot;../preprocessor/replace&quot;&gt;stringification operator&lt;/a&gt; can make the spelling visible). The two-letter alternative tokens are sometimes called &quot;digraphs&quot;</source>
          <target state="translated">Существуют альтернативные варианты написания для нескольких операторов и других токенов, которые используют символы, отличные от ISO646. Во всех отношениях языка каждый альтернативный токен ведет себя точно так же, как и его основной токен, за исключением его правописания ( &lt;a href=&quot;../preprocessor/replace&quot;&gt;оператор строкового преобразования&lt;/a&gt; может сделать правописание видимым). Двухбуквенные альтернативные токены иногда называют &amp;laquo;орграфами&amp;raquo;</target>
        </trans-unit>
        <trans-unit id="8e6f3eaebb9a3927bc985adcb62df7d15d191025" translate="yes" xml:space="preserve">
          <source>There are compiler extensions that may be used to generate C++ exceptions automatically whenever a floating-point exception is raised:</source>
          <target state="translated">Существуют расширения компилятора,которые могут быть использованы для автоматической генерации исключений Си++всякий раз,когда возникает исключение с плавающей точкой:</target>
        </trans-unit>
        <trans-unit id="3f225f0e74f08c0d0f2caf0e296a39e971ff8239" translate="yes" xml:space="preserve">
          <source>There are five available return types:</source>
          <target state="translated">Существует пять доступных типов возврата:</target>
        </trans-unit>
        <trans-unit id="c8b561cc0eef33e481077a8d77db9eb795dcf585" translate="yes" xml:space="preserve">
          <source>There are five(until C++17)six(since C++17) kinds of iterators: &lt;a href=&quot;named_req/inputiterator&quot;&gt;LegacyInputIterator&lt;/a&gt;, &lt;a href=&quot;named_req/outputiterator&quot;&gt;LegacyOutputIterator&lt;/a&gt;, &lt;a href=&quot;named_req/forwarditerator&quot;&gt;LegacyForwardIterator&lt;/a&gt;, &lt;a href=&quot;named_req/bidirectionaliterator&quot;&gt;LegacyBidirectionalIterator&lt;/a&gt;, &lt;a href=&quot;named_req/randomaccessiterator&quot;&gt;LegacyRandomAccessIterator&lt;/a&gt;, and &lt;a href=&quot;named_req/contiguousiterator&quot;&gt;LegacyContiguousIterator&lt;/a&gt;(since C++17).</source>
          <target state="translated">Существует пять (до C ++ 17) шести (начиная с C ++ 17) типов итераторов: &lt;a href=&quot;named_req/inputiterator&quot;&gt;LegacyInputIterator&lt;/a&gt; , &lt;a href=&quot;named_req/outputiterator&quot;&gt;LegacyOutputIterator&lt;/a&gt; , &lt;a href=&quot;named_req/forwarditerator&quot;&gt;LegacyForwardIterator&lt;/a&gt; , &lt;a href=&quot;named_req/bidirectionaliterator&quot;&gt;LegacyBidirectionalIterator&lt;/a&gt; , &lt;a href=&quot;named_req/randomaccessiterator&quot;&gt;LegacyRandomAccessIterator&lt;/a&gt; и &lt;a href=&quot;named_req/contiguousiterator&quot;&gt;LegacyContiguousIterator&lt;/a&gt; (начиная с C ++ 17).</target>
        </trans-unit>
        <trans-unit id="9778100d7798733f17cf489450cafd2088023fa7" translate="yes" xml:space="preserve">
          <source>There are many different NaN values with different sign bits and payloads, see &lt;code&gt;&lt;a href=&quot;nan.2&quot;&gt;std::nan&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../../types/numeric_limits/quiet_nan&quot;&gt;std::numeric_limits::quiet_NaN&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Существует много разных значений NaN с разными знаковыми битами и полезными нагрузками, см. &lt;code&gt;&lt;a href=&quot;nan.2&quot;&gt;std::nan&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;../../types/numeric_limits/quiet_nan&quot;&gt;std::numeric_limits::quiet_NaN&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7e03334de5cfa0b9f96707c08d7bef755bc11a3c" translate="yes" xml:space="preserve">
          <source>There are many different NaN values, differentiated by their payloads and their sign bits. The contents of the payload and the sign bit of the NaN generated by the macro &lt;code&gt;NAN&lt;/code&gt; are implementation-defined.</source>
          <target state="translated">Существует много различных значений NaN, различающихся по их полезным нагрузкам и знаковым битам. Содержимое полезной нагрузки и знаковый бит NaN, генерируемые макросом &lt;code&gt;NAN&lt;/code&gt; , определяются реализацией.</target>
        </trans-unit>
        <trans-unit id="a956cc8cb0205c1b4676cee813cb10d9f4679af6" translate="yes" xml:space="preserve">
          <source>There are many types for which equality makes sense, but not less-than ordering: a common example are the complex numbers, or any pair of numbers in general:</source>
          <target state="translated">Существует множество типов,для которых равенство имеет смысл,но не менее чем упорядочение:обычным примером являются комплексные числа или любая пара чисел в целом:</target>
        </trans-unit>
        <trans-unit id="694fc92221739aa50089385fa6fdb3ce4ff4a1f6" translate="yes" xml:space="preserve">
          <source>There are no &lt;a href=&quot;data_members#Member_initialization&quot;&gt;default member initializers&lt;/a&gt; for bit fields: &lt;code&gt;int b : 1 = 0;&lt;/code&gt; and &lt;code&gt;int b : 1 {0}&lt;/code&gt; are ill-formed.</source>
          <target state="translated">Для битовых полей по &lt;a href=&quot;data_members#Member_initialization&quot;&gt;умолчанию&lt;/a&gt; нет инициализаторов элементов : &lt;code&gt;int b : 1 = 0;&lt;/code&gt; и &lt;code&gt;int b : 1 {0}&lt;/code&gt; плохо сформированы.</target>
        </trans-unit>
        <trans-unit id="db2de29aa1d33752b78c0dd7d6ec96850ff5a7be" translate="yes" xml:space="preserve">
          <source>There are no arrays of references or arrays of functions.</source>
          <target state="translated">Массивы ссылок или массивы функций отсутствуют.</target>
        </trans-unit>
        <trans-unit id="37439af54c020a64a12e9c758da796ee25c34c35" translate="yes" xml:space="preserve">
          <source>There are no bit field &lt;a href=&quot;value_category&quot;&gt;prvalues&lt;/a&gt;: lvalue-to-rvalue conversion always produces an object of the underlying type of the bit field.</source>
          <target state="translated">&lt;a href=&quot;value_category&quot;&gt;Prvalues&lt;/a&gt; поля битов не существует : преобразование lvalue-в-значение всегда создает объект базового типа поля битов.</target>
        </trans-unit>
        <trans-unit id="f39ab94881006d285c7e811db2e42c17ba7a7d98" translate="yes" xml:space="preserve">
          <source>There are no guarantees as to the quality of the random sequence produced. In the past, some implementations of &lt;code&gt;rand()&lt;/code&gt; have had serious shortcomings in the randomness, distribution and period of the sequence produced (in one well-known example, the low-order bit simply alternated between &lt;code&gt;1&lt;/code&gt; and &lt;code&gt;0&lt;/code&gt; between calls).</source>
          <target state="translated">Нет никаких гарантий относительно качества полученной случайной последовательности. В прошлом некоторые реализации &lt;code&gt;rand()&lt;/code&gt; имели серьезные недостатки в случайности, распределении и периоде создаваемой последовательности (в одном хорошо известном примере бит младшего разряда просто чередовался между &lt;code&gt;1&lt;/code&gt; и &lt;code&gt;0&lt;/code&gt; между вызовами).</target>
        </trans-unit>
        <trans-unit id="991d3d81eb996d06aa3347bc77bacaef91a6483e" translate="yes" xml:space="preserve">
          <source>There are no negative integer literals. Expressions such as &lt;code&gt;-1&lt;/code&gt; apply the &lt;a href=&quot;operator_arithmetic&quot;&gt;unary minus operator&lt;/a&gt; to the value represented by the literal, which may involve implicit type conversions.</source>
          <target state="translated">Там нет отрицательных целочисленных литералов. Такие выражения, как &lt;code&gt;-1&lt;/code&gt; , применяют &lt;a href=&quot;operator_arithmetic&quot;&gt;унарный оператор минус&lt;/a&gt; к значению, представленному литералом, что может включать неявные преобразования типов.</target>
        </trans-unit>
        <trans-unit id="bcb7f46103fbd100a4f9cb6ff99abb2c28199213" translate="yes" xml:space="preserve">
          <source>There are no optional references; a program is ill-formed if it instantiates an &lt;code&gt;optional&lt;/code&gt; with a reference type. Alternatively, an &lt;code&gt;optional&lt;/code&gt; of a &lt;code&gt;&lt;a href=&quot;functional/reference_wrapper&quot;&gt;std::reference_wrapper&lt;/a&gt;&lt;/code&gt; of type &lt;code&gt;T&lt;/code&gt; may be used to hold a reference. In addition, a program is ill-formed if it instantiates an &lt;code&gt;optional&lt;/code&gt; with the tag types &lt;code&gt;&lt;a href=&quot;optional/nullopt_t&quot;&gt;std::nullopt_t&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;in_place&quot;&gt;std::in_place_t&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Там нет дополнительных ссылок; программа плохо сформирована, если она создает &lt;code&gt;optional&lt;/code&gt; объект со ссылочным типом. В качестве альтернативы, по &lt;code&gt;optional&lt;/code&gt; из &lt;code&gt;&lt;a href=&quot;functional/reference_wrapper&quot;&gt;std::reference_wrapper&lt;/a&gt;&lt;/code&gt; типа &lt;code&gt;T&lt;/code&gt; может быть использовано для хранения ссылки. Кроме того, программа плохо сформирована, если она создает &lt;code&gt;optional&lt;/code&gt; экземпляр с типами тегов &lt;code&gt;&lt;a href=&quot;optional/nullopt_t&quot;&gt;std::nullopt_t&lt;/a&gt;&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;in_place&quot;&gt;std::in_place_t&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8419f6809e1cf19b6fb3b6a22f4638d4c5849b20" translate="yes" xml:space="preserve">
          <source>There are no overload for pointers to non-static member, pointers to volatile, or function pointers (other than the ones with signatures accepted by the (10-12) overloads). Attempting to output such objects invokes implicit conversion to &lt;code&gt;bool&lt;/code&gt;, and, for any non-null pointer value, the value &lt;code&gt;1&lt;/code&gt; is printed (unless &lt;code&gt;boolalpha&lt;/code&gt; was set, in which case &lt;code&gt;true&lt;/code&gt; is printed).</source>
          <target state="translated">Не существует перегрузки для указателей на нестатический элемент, указателей на volatile или указателей на функции (кроме тех, чьи сигнатуры приняты перегрузками (10-12)). Попытка вывода таких объектов вызывает неявное преобразование в &lt;code&gt;bool&lt;/code&gt; , и для любого ненулевого значения указателя печатается значение &lt;code&gt;1&lt;/code&gt; (если &lt;code&gt;boolalpha&lt;/code&gt; было установлено boolalpha , в этом случае печатается &lt;code&gt;true&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="3e3662fa8ed3550ea700d26fee022c4ac95bb7d6" translate="yes" xml:space="preserve">
          <source>There are no pointers to &lt;a href=&quot;reference&quot;&gt;references&lt;/a&gt; and there are no pointers to &lt;a href=&quot;bit_field&quot;&gt;bit fields&lt;/a&gt;. Typically, mentions of &quot;pointers&quot; without elaboration do not include pointers to (non-static) members.</source>
          <target state="translated">Нет указателей на &lt;a href=&quot;reference&quot;&gt;ссылки&lt;/a&gt; и нет указателей на &lt;a href=&quot;bit_field&quot;&gt;битовые поля&lt;/a&gt; . Как правило, упоминания &amp;laquo;указателей&amp;raquo; без уточнения не включают указатели на (нестатические) члены.</target>
        </trans-unit>
        <trans-unit id="337c29a8a2b7567bb32c86a4abf4bf2501e7a2ab" translate="yes" xml:space="preserve">
          <source>There are no references to &lt;code&gt;void&lt;/code&gt; and no references to references.</source>
          <target state="translated">Нет ссылок на &lt;code&gt;void&lt;/code&gt; и нет ссылок на ссылки.</target>
        </trans-unit>
        <trans-unit id="1deb84f794c63103b9555294bae8bd9107563871" translate="yes" xml:space="preserve">
          <source>There are no standard complexity guarantees, typical implementations behave similar to &lt;a href=&quot;../../container/vector/insert&quot;&gt;std::vector::insert&lt;/a&gt;.</source>
          <target state="translated">Стандартных гарантий сложности не существует, типичные реализации ведут себя подобно &lt;a href=&quot;../../container/vector/insert&quot;&gt;std :: vector :: insert&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5ef11a32cf3433c799eb8a56e867da73440715a2" translate="yes" xml:space="preserve">
          <source>There are non-member function template equivalents for all member functions of &lt;code&gt;std::atomic&lt;/code&gt;. Those non-member functions may be additionally overloaded for types that are not specializations of &lt;code&gt;std::atomic&lt;/code&gt;, but are able to guarantee atomicity. The only such type in the standard library is &lt;code&gt;&lt;a href=&quot;../memory/shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">Для всех функций-членов &lt;code&gt;std::atomic&lt;/code&gt; эквиваленты шаблонов функций, не являющихся членами . Эти функции, не являющиеся членами, могут быть дополнительно перегружены для типов, которые не являются специализациями &lt;code&gt;std::atomic&lt;/code&gt; , но могут гарантировать атомарность. Единственный такой тип в стандартной библиотеке - это &lt;code&gt;&lt;a href=&quot;../memory/shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7e79772c53f1ce2b7a68f39acb9950fc2f71b6e0" translate="yes" xml:space="preserve">
          <source>There are special rules for unqualified name lookup for class members when virtual inheritance is involved (sometimes referred to as the rules of dominance), see &lt;a href=&quot;unqualified_lookup#Member_function_definition&quot;&gt;unqualified_lookup#Member_function_definition&lt;/a&gt;.</source>
          <target state="translated">Существуют специальные правила для поиска безоговорочного имени для членов класса, когда задействовано виртуальное наследование (иногда называемое правилами доминирования), см. &lt;a href=&quot;unqualified_lookup#Member_function_definition&quot;&gt;Unqualified_lookup # Member_function_definition&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9a402f4ecfc55e94136a1e80cc1d6a5286b19956" translate="yes" xml:space="preserve">
          <source>There are still a few inaccuracies in this section, refer to individual member function pages for more detail.</source>
          <target state="translated">В этом разделе все еще есть несколько неточностей,для более подробной информации обратитесь к страницам,посвященным отдельным функциям членов.</target>
        </trans-unit>
        <trans-unit id="941295990d20765c0666a8c77b5e2c06086eb3fc" translate="yes" xml:space="preserve">
          <source>There are still a few inaccuracies in this section. Refer to individual member function pages for more detail.</source>
          <target state="translated">В этом разделе все еще есть несколько неточностей.Для получения более подробной информации обратитесь к страницам,посвященным отдельным функциям членов.</target>
        </trans-unit>
        <trans-unit id="fbc45885aff604aaea2abb7208dd0c18b8bc3d95" translate="yes" xml:space="preserve">
          <source>There are three conventions of passing an allocator &lt;code&gt;alloc&lt;/code&gt; to a constructor of some type &lt;code&gt;T&lt;/code&gt;:</source>
          <target state="translated">Существует три соглашения о передаче &lt;code&gt;alloc&lt;/code&gt; для конструктора некоторого типа &lt;code&gt;T&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="eb2f200b57b0d8a9c6686c50668bd2b80b8b6b29" translate="yes" xml:space="preserve">
          <source>There are three types of constraints:</source>
          <target state="translated">Существует три типа ограничений:</target>
        </trans-unit>
        <trans-unit id="0f09bbf4176190877beb129c86ae3e9c8e358d71" translate="yes" xml:space="preserve">
          <source>There are three types of null-terminated strings:</source>
          <target state="translated">Существует три типа нуль-терминированных строк:</target>
        </trans-unit>
        <trans-unit id="7c2a33396de83eb35e9628e69e71f05f450481e2" translate="yes" xml:space="preserve">
          <source>There are two distinct kinds of enumerations:</source>
          <target state="translated">Существует два различных вида перечислений:</target>
        </trans-unit>
        <trans-unit id="6f669e5024934effcd4278fb23f0f95ad252bc52" translate="yes" xml:space="preserve">
          <source>There are two exceptions from that:</source>
          <target state="translated">Из этого есть два исключения:</target>
        </trans-unit>
        <trans-unit id="36231641abbbc5cce8b62cf3185cc936bfddd00e" translate="yes" xml:space="preserve">
          <source>There are two kinds of implementations defined by the C++ standard:</source>
          <target state="translated">Существует два вида реализаций,определенных стандартом C++:</target>
        </trans-unit>
        <trans-unit id="e504119c92fe73e0c1cae5141f8e4e4cd1909108" translate="yes" xml:space="preserve">
          <source>There are two versions of &lt;code&gt;std::unique_ptr&lt;/code&gt;:</source>
          <target state="translated">Существует две версии &lt;code&gt;std::unique_ptr&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="31bf78ac4643c55ed74c0dfba62be6194d38f599" translate="yes" xml:space="preserve">
          <source>There can be more than one definition in a program, as long as each definition appears in a different translation unit, of each of the following: class type, enumeration type, inline function with external linkage inline variable with external linkage(since C++17), class template, non-static function template, static data member of a class template, member function of a class template, partial template specialization, &lt;a href=&quot;constraints&quot;&gt;concept&lt;/a&gt;,(since C++20) as long as all of the following is true:</source>
          <target state="translated">В программе может быть несколько определений, если каждое определение отображается в разных единицах перевода, каждого из следующих элементов: тип класса, тип перечисления, встроенная функция со встроенной переменной внешней связи со внешней связью (начиная с C ++) 17), шаблон класса, шаблон нестатической функции, член статических данных шаблона класса, функция-член шаблона класса, частичная специализация шаблона, &lt;a href=&quot;constraints&quot;&gt;концепция&lt;/a&gt; (начиная с C ++ 20), если выполняется все следующее:</target>
        </trans-unit>
        <trans-unit id="3787f2ae99932166a7dcbb82d18d8948ed35d334" translate="yes" xml:space="preserve">
          <source>There exists an atomic object M,</source>
          <target state="translated">Существует атомный объект М,</target>
        </trans-unit>
        <trans-unit id="79c74ac70167e62133877fbfab7ff339ffa4b43b" translate="yes" xml:space="preserve">
          <source>There exists an atomic read Y (with any memory order) in thread B</source>
          <target state="translated">В потоке B существует атомное считывание Y (с любым порядком памяти).</target>
        </trans-unit>
        <trans-unit id="7b325c9ba4bba31055eea3a7f3839a38f5af398a" translate="yes" xml:space="preserve">
          <source>There exists an atomic write X (with any memory order) that modifies M in thread A</source>
          <target state="translated">Существует атомарная запись X (с любым порядком памяти),которая модифицирует M в потоке A</target>
        </trans-unit>
        <trans-unit id="b5311041dd1561f12757a5b111f905e8cf9ceb71" translate="yes" xml:space="preserve">
          <source>There is a &lt;a href=&quot;../../language/eval_order&quot;&gt;sequence point&lt;/a&gt; after the action of each conversion specifier; this permits storing multiple &lt;code&gt;%n&lt;/code&gt; results in the same variable or, as an edge case, printing a string modified by an earlier &lt;code&gt;%n&lt;/code&gt; within the same call.</source>
          <target state="translated">После действия каждого спецификатора преобразования есть &lt;a href=&quot;../../language/eval_order&quot;&gt;точка последовательности&lt;/a&gt; ; это позволяет хранить несколько &lt;code&gt;%n&lt;/code&gt; результатов в одной и той же переменной или, как крайний случай, печатать строку, измененную более ранним &lt;code&gt;%n&lt;/code&gt; в рамках одного и того же вызова.</target>
        </trans-unit>
        <trans-unit id="3baee1a6a7acc4dbecfba1cab14149a6beefecea" translate="yes" xml:space="preserve">
          <source>There is a &lt;a href=&quot;../../language/eval_order&quot;&gt;sequence point&lt;/a&gt; after the action of each conversion specifier; this permits storing multiple fields in the same &quot;sink&quot; variable.</source>
          <target state="translated">После действия каждого спецификатора преобразования есть &lt;a href=&quot;../../language/eval_order&quot;&gt;точка последовательности&lt;/a&gt; ; это позволяет хранить несколько полей в одной и той же переменной-приемнике.</target>
        </trans-unit>
        <trans-unit id="ab3c5acf0d5e4ba77cc962cd2ce83a7c967eb424" translate="yes" xml:space="preserve">
          <source>There is a non-standard function named &lt;code&gt;gamma&lt;/code&gt; in various implementations, but its definition is inconsistent. For example, glibc and 4.2BSD version of &lt;code&gt;gamma&lt;/code&gt; executes &lt;code&gt;lgamma&lt;/code&gt;, but 4.4BSD version of &lt;code&gt;gamma&lt;/code&gt; executes &lt;code&gt;tgamma&lt;/code&gt;.</source>
          <target state="translated">В различных реализациях существует нестандартная функция с именем &lt;code&gt;gamma&lt;/code&gt; , но ее определение противоречиво. Например, Glibc и версия 4.2BSD из &lt;code&gt;gamma&lt;/code&gt; исполняет &lt;code&gt;lgamma&lt;/code&gt; , но 4.4BSD версии &lt;code&gt;gamma&lt;/code&gt; исполняет &lt;code&gt;tgamma&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b9f50508274427b995c9b808fe7d2253e68aed64" translate="yes" xml:space="preserve">
          <source>There is a single total order S on all &lt;code&gt;memory_order_seq_cst&lt;/code&gt; operations, including fences, that satisfies the following constraints:</source>
          <target state="translated">Существует один общий порядок S для всех операций &lt;code&gt;memory_order_seq_cst&lt;/code&gt; , включая заборы, который удовлетворяет следующим ограничениям:</target>
        </trans-unit>
        <trans-unit id="d4002dc28152d428b1e9f887a2afb18cb864b3ff" translate="yes" xml:space="preserve">
          <source>There is a special case for a zero-length array (&lt;code&gt;N == 0&lt;/code&gt;). In that case, &lt;code&gt;array.begin() == array.end()&lt;/code&gt;, which is some unique value. The effect of calling &lt;code&gt;front()&lt;/code&gt; or &lt;code&gt;back()&lt;/code&gt; on a zero-sized array is undefined.</source>
          <target state="translated">Существует особый случай для массива нулевой длины ( &lt;code&gt;N == 0&lt;/code&gt; ). В этом случае &lt;code&gt;array.begin() == array.end()&lt;/code&gt; , которая является уникальным значением. Эффект вызова &lt;code&gt;front()&lt;/code&gt; или &lt;code&gt;back()&lt;/code&gt; для массива нулевого размера не определен.</target>
        </trans-unit>
        <trans-unit id="4c58212f0810e755496085c2333304612a8c9ba1" translate="yes" xml:space="preserve">
          <source>There is an &lt;a href=&quot;implicit_cast&quot;&gt;implicit conversion&lt;/a&gt; from lvalues and rvalues of array type to rvalues of pointer type: it constructs a pointer to the first element of an array. This conversion is used whenever arrays appear in context where arrays are not expected, but pointers are:</source>
          <target state="translated">Существует &lt;a href=&quot;implicit_cast&quot;&gt;неявное преобразование&lt;/a&gt; из lvalues ​​и rvalues ​​типа array в rvalues ​​типа указателя: он создает указатель на первый элемент массива. Это преобразование используется всякий раз, когда массивы появляются в контексте, где массивы не ожидаются, но указатели:</target>
        </trans-unit>
        <trans-unit id="adb96efa8dd15697ca7b238b3ac30f5bc2029721" translate="yes" xml:space="preserve">
          <source>There is no &lt;a href=&quot;../../language/deduction_guide&quot;&gt;class template argument deduction&lt;/a&gt; from pointer type because it is impossible to distinguish a pointer obtained from array and non-array forms of &lt;code&gt;new&lt;/code&gt;.</source>
          <target state="translated">Нет никакого &lt;a href=&quot;../../language/deduction_guide&quot;&gt;вычета аргумента шаблона класса&lt;/a&gt; из типа указателя, потому что невозможно отличить указатель, полученный от массива и не-массивов &lt;code&gt;new&lt;/code&gt; форм .</target>
        </trans-unit>
        <trans-unit id="b717a5566f4d275ca27affef23f0b5a37db23c45" translate="yes" xml:space="preserve">
          <source>There is no alternative spelling (such as &lt;code&gt;eq&lt;/code&gt;) for the equality operator &lt;code&gt;==&lt;/code&gt; because the character &lt;code&gt;=&lt;/code&gt; was present in all supported charsets.</source>
          <target state="translated">Для оператора равенства &lt;code&gt;==&lt;/code&gt; нет альтернативного написания (например, &lt;code&gt;eq&lt;/code&gt; ), потому что символ &lt;code&gt;=&lt;/code&gt; присутствовал во всех поддерживаемых кодировках.</target>
        </trans-unit>
        <trans-unit id="6359bb2da55b35e94c9ad0b9d3423bdf850ab557" translate="yes" xml:space="preserve">
          <source>There is no guarantee that the same &lt;code&gt;&lt;a href=&quot;../types/type_info&quot;&gt;std::type_info&lt;/a&gt;&lt;/code&gt; instance will be referred to by all evaluations of the typeid expression on the same type, although &lt;code&gt;&lt;a href=&quot;../types/type_info/hash_code&quot;&gt;std::type_info::hash_code&lt;/a&gt;&lt;/code&gt; of those type_info objects would be identical, as would be their &lt;code&gt;&lt;a href=&quot;../types/type_index&quot;&gt;std::type_index&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Не гарантируется, что один и тот же экземпляр &lt;code&gt;&lt;a href=&quot;../types/type_info&quot;&gt;std::type_info&lt;/a&gt;&lt;/code&gt; будет использоваться во всех оценках выражения typeid для одного и того же типа, хотя &lt;code&gt;&lt;a href=&quot;../types/type_info/hash_code&quot;&gt;std::type_info::hash_code&lt;/a&gt;&lt;/code&gt; этих объектов type_info будет идентичен, как и их &lt;code&gt;&lt;a href=&quot;../types/type_index&quot;&gt;std::type_index&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="46c70b420b1fd4cd4eb814c6e21ea48fec268ba0" translate="yes" xml:space="preserve">
          <source>There is no move constructor: moving from an object derived from &lt;code&gt;shared_from_this&lt;/code&gt; does not transfer its shared identity.</source>
          <target state="translated">Конструктор перемещения отсутствует: перемещение из объекта, полученного из &lt;code&gt;shared_from_this&lt;/code&gt; , не передает его общую идентичность.</target>
        </trans-unit>
        <trans-unit id="c081f6007cfe842825dd149d42264efa0313278f" translate="yes" xml:space="preserve">
          <source>There is no non-member function equivalent of this static member constant because non-member functions take pointers to atomic types, and therefore aren't as useful in &lt;a href=&quot;../../language/constant_expression&quot;&gt;constant expressions&lt;/a&gt;.</source>
          <target state="translated">Не существует функции, не являющейся членом-эквивалентом этой статической константы-члена, поскольку функции, не являющиеся членами, принимают указатели на атомарные типы и, следовательно, не так полезны в &lt;a href=&quot;../../language/constant_expression&quot;&gt;константных выражениях&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b70d83494235e850b17f2e48a3299bb098ff2e94" translate="yes" xml:space="preserve">
          <source>There is no portable way to define primary sort key in terms of &lt;code&gt;&lt;a href=&quot;../../locale/locale&quot;&gt;std::locale&lt;/a&gt;&lt;/code&gt; since the conversion from the collation key returned by &lt;code&gt;std::collate::transform()&lt;/code&gt; to the primary equivalence key is locale-specific, and if the user replaces the &lt;code&gt;&lt;a href=&quot;../../locale/collate&quot;&gt;std::collate&lt;/a&gt;&lt;/code&gt; facet, that conversion is no longer known to the standard library's &lt;code&gt;&lt;a href=&quot;../regex_traits&quot;&gt;std::regex_traits&lt;/a&gt;&lt;/code&gt;. Standard library specializations of &lt;code&gt;&lt;a href=&quot;../regex_traits&quot;&gt;std::regex_traits&lt;/a&gt;&lt;/code&gt; return an empty string unless the &lt;code&gt;&lt;a href=&quot;../../locale/collate&quot;&gt;std::collate&lt;/a&gt;&lt;/code&gt; facet of the currently-imbued locale was not replaced by the user, and still matches the system-supplied &lt;code&gt;&lt;a href=&quot;../../locale/collate&quot;&gt;std::collate&lt;/a&gt;&lt;/code&gt; facet), in which case &lt;code&gt;&lt;a href=&quot;../../locale/collate_byname&quot;&gt;std::collate_byname&lt;/a&gt;&amp;lt;charT&amp;gt;::transform(first, last)&lt;/code&gt; is executed and the sort key it produces is converted to the expected primary sort key using a locale-specific conversion.</source>
          <target state="translated">Не существует переносимого способа определения первичного ключа сортировки в терминах &lt;code&gt;&lt;a href=&quot;../../locale/locale&quot;&gt;std::locale&lt;/a&gt;&lt;/code&gt; поскольку преобразование ключа сортировки, возвращаемого &lt;code&gt;std::collate::transform()&lt;/code&gt; в первичный ключ эквивалентности зависит от локали, и если пользователь заменяет не &lt;code&gt;&lt;a href=&quot;../../locale/collate&quot;&gt;std::collate&lt;/a&gt;&lt;/code&gt; фаска, что преобразование уже не известно из стандартной библиотеки &lt;code&gt;&lt;a href=&quot;../regex_traits&quot;&gt;std::regex_traits&lt;/a&gt;&lt;/code&gt; . Стандартная библиотека специализации &lt;code&gt;&lt;a href=&quot;../regex_traits&quot;&gt;std::regex_traits&lt;/a&gt;&lt;/code&gt; возвращают пустую строку , если &lt;code&gt;&lt;a href=&quot;../../locale/collate&quot;&gt;std::collate&lt;/a&gt;&lt;/code&gt; граней в настоящий момент проникнут местности не была заменены пользователем, и по- прежнему соответствуют системе поставляется &lt;code&gt;&lt;a href=&quot;../../locale/collate&quot;&gt;std::collate&lt;/a&gt;&lt;/code&gt; фасет), в этом случае &lt;code&gt;&lt;a href=&quot;../../locale/collate_byname&quot;&gt;std::collate_byname&lt;/a&gt;&amp;lt;charT&amp;gt;::transform(first, last)&lt;/code&gt; выполняется, и ключ сортировки, который он производит, преобразуется в ожидаемый первичный ключ сортировки, используя преобразование для конкретной локали.</target>
        </trans-unit>
        <trans-unit id="3f7acf604b21fa7efd6ebb9fae0bd32cd0e76516" translate="yes" xml:space="preserve">
          <source>There is no separate tag for &lt;a href=&quot;../named_req/contiguousiterator&quot;&gt;LegacyContiguousIterator&lt;/a&gt;.</source>
          <target state="translated">Для &lt;a href=&quot;../named_req/contiguousiterator&quot;&gt;LegacyContiguousIterator&lt;/a&gt; нет отдельного тега .</target>
        </trans-unit>
        <trans-unit id="cb42e4a03c1413932f97ef53ea3df59cf6f0618f" translate="yes" xml:space="preserve">
          <source>There is no specialization for C strings. &lt;code&gt;std::hash&amp;lt;const char*&amp;gt;&lt;/code&gt; produces a hash of the value of the pointer (the memory address), it does not examine the contents of any character array.</source>
          <target state="translated">Там нет специализации для C строк. &lt;code&gt;std::hash&amp;lt;const char*&amp;gt;&lt;/code&gt; создает хэш значения указателя (адрес памяти), он не проверяет содержимое любого символьного массива.</target>
        </trans-unit>
        <trans-unit id="932b5b0c5bba8ae4965a8c49c5fcc30eedb86b32" translate="yes" xml:space="preserve">
          <source>There is no standard-compliant way for the user to construct a &lt;code&gt;future_error&lt;/code&gt; prior to C++17. C++11 and C++14 depict an exposition-only public constructor taking a &lt;code&gt;&lt;a href=&quot;../../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&lt;/code&gt;, and some implementations provide such a constructor.</source>
          <target state="translated">Для C ++ 17 не существует стандартного способа для пользователя создать &lt;code&gt;future_error&lt;/code&gt; . C ++ 11 и C ++ 14 изображают открытый конструктор только для экспозиции, принимающий &lt;code&gt;&lt;a href=&quot;../../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&lt;/code&gt; , и некоторые реализации предоставляют такой конструктор.</target>
        </trans-unit>
        <trans-unit id="1a76b382fdb365f1f430efc3fd3ffef21f74d56b" translate="yes" xml:space="preserve">
          <source>There is no way to explicitly specify template arguments to &lt;a href=&quot;operators&quot;&gt;overloaded operators&lt;/a&gt;, &lt;a href=&quot;cast_operator&quot;&gt;conversion functions&lt;/a&gt;, and constructors, because they are called without the use of the function name.</source>
          <target state="translated">Невозможно явно указать аргументы шаблона для &lt;a href=&quot;operators&quot;&gt;перегруженных операторов&lt;/a&gt; , &lt;a href=&quot;cast_operator&quot;&gt;функций преобразования&lt;/a&gt; и конструкторов, поскольку они вызываются без использования имени функции.</target>
        </trans-unit>
        <trans-unit id="cfe1eeb34c7bedb3e0ea6d678c0bd6012a61623b" translate="yes" xml:space="preserve">
          <source>There is one exception: an erasure which deletes the last element of a &lt;code&gt;&lt;a href=&quot;container/deque&quot;&gt;std::deque&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">Есть одно исключение: стирание, которое удаляет последний элемент &lt;code&gt;&lt;a href=&quot;container/deque&quot;&gt;std::deque&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="341db5eb1053e74392cf71602cdbdbaadad998bb" translate="yes" xml:space="preserve">
          <source>There is partial ordering of cv-qualifiers by the order of increasing restrictions. The type can be said</source>
          <target state="translated">Существует частичный заказ cv-квалификаторов в порядке возрастания ограничений.Тип может быть указан</target>
        </trans-unit>
        <trans-unit id="89bd5d5858a6e7136749a6ba025c5ec9f6ed276d" translate="yes" xml:space="preserve">
          <source>There's no way to access the time zone pointer when &lt;code&gt;TimeZonePtr&lt;/code&gt; is a move-only type.</source>
          <target state="translated">Нет способа получить доступ к указателю часового пояса, когда &lt;code&gt;TimeZonePtr&lt;/code&gt; является типом только для перемещения.</target>
        </trans-unit>
        <trans-unit id="e85687808f760523e3241d93ae510041ac781f16" translate="yes" xml:space="preserve">
          <source>Therefore, private members can be transferred to implementation as-is, and push_back can forward to an implementation that does not use T in the interface either:</source>
          <target state="translated">Таким образом,приватные члены могут быть перенесены в реализацию as-is,а push_back может быть перенаправлен в реализацию,которая также не использует T в интерфейсе:</target>
        </trans-unit>
        <trans-unit id="99d6d9ce6d1c6685dc210a906c540e2a567fe084" translate="yes" xml:space="preserve">
          <source>These &lt;a href=&quot;../../language/deduction_guide&quot;&gt;deduction guide&lt;/a&gt; are provided for unordered_map to allow deduction from an iterator range (overloads (1,3-5)) and &lt;code&gt;&lt;a href=&quot;../../utility/initializer_list&quot;&gt;std::initializer_list&lt;/a&gt;&lt;/code&gt; (overloads (2,6-8)). These overloads only participate in overload resolution if &lt;code&gt;InputIt&lt;/code&gt; satisfies &lt;a href=&quot;../../named_req/inputiterator&quot;&gt;LegacyInputIterator&lt;/a&gt;, &lt;code&gt;Alloc&lt;/code&gt; satisfies &lt;a href=&quot;../../named_req/allocator&quot;&gt;Allocator&lt;/a&gt;, neither &lt;code&gt;Hash&lt;/code&gt; nor &lt;code&gt;Pred&lt;/code&gt; satisfy &lt;a href=&quot;../../named_req/allocator&quot;&gt;Allocator&lt;/a&gt;, and &lt;code&gt;Hash&lt;/code&gt; is not an integral type.</source>
          <target state="translated">Это &lt;a href=&quot;../../language/deduction_guide&quot;&gt;руководство&lt;/a&gt; по выводу предусмотрено для unordered_map, чтобы разрешить вывод из диапазона итератора (перегрузки (1,3-5)) и &lt;code&gt;&lt;a href=&quot;../../utility/initializer_list&quot;&gt;std::initializer_list&lt;/a&gt;&lt;/code&gt; (перегрузки (2,6-8)). Эти перегрузки участвуют в разрешении перегрузки, только если &lt;code&gt;InputIt&lt;/code&gt; удовлетворяет &lt;a href=&quot;../../named_req/inputiterator&quot;&gt;LegacyInputIterator&lt;/a&gt; , &lt;code&gt;Alloc&lt;/code&gt; удовлетворяет &lt;a href=&quot;../../named_req/allocator&quot;&gt;Allocator&lt;/a&gt; , ни &lt;code&gt;Hash&lt;/code&gt; , ни &lt;code&gt;Pred&lt;/code&gt; не удовлетворяют &lt;a href=&quot;../../named_req/allocator&quot;&gt;Allocator&lt;/a&gt; , а &lt;code&gt;Hash&lt;/code&gt; не является целочисленным типом.</target>
        </trans-unit>
        <trans-unit id="d838aa17089c69886e8a6da521887bdae3d66e6e" translate="yes" xml:space="preserve">
          <source>These &lt;a href=&quot;../../language/deduction_guide&quot;&gt;deduction guide&lt;/a&gt; are provided for unordered_multimap to allow deduction from an iterator range (overloads (1,3-5)) and &lt;code&gt;&lt;a href=&quot;../../utility/initializer_list&quot;&gt;std::initializer_list&lt;/a&gt;&lt;/code&gt; (overloads (2,6-8)). These overloads only participate in overload resolution if &lt;code&gt;InputIt&lt;/code&gt; satisfies &lt;a href=&quot;../../named_req/inputiterator&quot;&gt;LegacyInputIterator&lt;/a&gt;, &lt;code&gt;Alloc&lt;/code&gt; satisfies &lt;a href=&quot;../../named_req/allocator&quot;&gt;Allocator&lt;/a&gt;, neither &lt;code&gt;Hash&lt;/code&gt; nor &lt;code&gt;Pred&lt;/code&gt; satisfy &lt;a href=&quot;../../named_req/allocator&quot;&gt;Allocator&lt;/a&gt;, and &lt;code&gt;Hash&lt;/code&gt; is not an integral type.</source>
          <target state="translated">Это &lt;a href=&quot;../../language/deduction_guide&quot;&gt;руководство вычета&lt;/a&gt; предоставляется для unordered_multimap разрешить вычет из диапазона итератора (перегрузки (1,3-5)) и &lt;code&gt;&lt;a href=&quot;../../utility/initializer_list&quot;&gt;std::initializer_list&lt;/a&gt;&lt;/code&gt; (перегрузки (2,6-8)). Эти перегрузки участвуют в разрешении перегрузки, только если &lt;code&gt;InputIt&lt;/code&gt; удовлетворяет &lt;a href=&quot;../../named_req/inputiterator&quot;&gt;LegacyInputIterator&lt;/a&gt; , &lt;code&gt;Alloc&lt;/code&gt; удовлетворяет &lt;a href=&quot;../../named_req/allocator&quot;&gt;Allocator&lt;/a&gt; , ни &lt;code&gt;Hash&lt;/code&gt; , ни &lt;code&gt;Pred&lt;/code&gt; не удовлетворяют &lt;a href=&quot;../../named_req/allocator&quot;&gt;Allocator&lt;/a&gt; , а &lt;code&gt;Hash&lt;/code&gt; не является целочисленным типом.</target>
        </trans-unit>
        <trans-unit id="71a2bff7b98f49c9c4e24066b486d0981c520060" translate="yes" xml:space="preserve">
          <source>These &lt;a href=&quot;../../language/deduction_guide&quot;&gt;deduction guides&lt;/a&gt; are provided for &lt;code&gt;&lt;a href=&quot;../priority_queue&quot;&gt;std::priority_queue&lt;/a&gt;&lt;/code&gt; to allow deduction from underlying container type (overloads (1,3)) and from an iterator range (overload (2)) This overload only participates in overload resolution if &lt;code&gt;InputIt&lt;/code&gt; satisfies &lt;a href=&quot;../../named_req/inputiterator&quot;&gt;LegacyInputIterator&lt;/a&gt;, &lt;code&gt;Alloc&lt;/code&gt; satisfies &lt;a href=&quot;../../named_req/allocator&quot;&gt;Allocator&lt;/a&gt;, &lt;code&gt;Comp&lt;/code&gt; does not satisfy &lt;code&gt;Allocator&lt;/code&gt;, &lt;code&gt;Container&lt;/code&gt; does not satisfy &lt;a href=&quot;../../named_req/allocator&quot;&gt;Allocator&lt;/a&gt; and, for overload (3), if &lt;code&gt;&lt;a href=&quot;../../memory/uses_allocator&quot;&gt;std::uses_allocator_v&lt;/a&gt;&amp;lt;Container, Alloc&amp;gt;&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">Эти &lt;a href=&quot;../../language/deduction_guide&quot;&gt;инструкции&lt;/a&gt; по &lt;code&gt;&lt;a href=&quot;../priority_queue&quot;&gt;std::priority_queue&lt;/a&gt;&lt;/code&gt; предусмотрены для std :: priority_queue, чтобы разрешить вывод из базового типа контейнера (перегрузки (1,3)) и из диапазона итератора (перегрузка (2)). Эта перегрузка участвует только в разрешении перегрузки, если &lt;code&gt;InputIt&lt;/code&gt; удовлетворяет &lt;a href=&quot;../../named_req/inputiterator&quot;&gt;LegacyInputIterator&lt;/a&gt; , &lt;code&gt;Alloc&lt;/code&gt; удовлетворяет &lt;a href=&quot;../../named_req/allocator&quot;&gt;Allocator&lt;/a&gt; , &lt;code&gt;Comp&lt;/code&gt; не удовлетворяет &lt;code&gt;Allocator&lt;/code&gt; , &lt;code&gt;Container&lt;/code&gt; не удовлетворяет &lt;a href=&quot;../../named_req/allocator&quot;&gt;Allocator&lt;/a&gt; и, для перегрузки (3), если &lt;code&gt;&lt;a href=&quot;../../memory/uses_allocator&quot;&gt;std::uses_allocator_v&lt;/a&gt;&amp;lt;Container, Alloc&amp;gt;&lt;/code&gt; имеет значение &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8e10d57340ef11936ebd04620951a44a41b981f3" translate="yes" xml:space="preserve">
          <source>These &lt;a href=&quot;../../language/deduction_guide&quot;&gt;deduction guides&lt;/a&gt; are provided for &lt;code&gt;&lt;a href=&quot;../shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&lt;/code&gt; to account for the edge cases missed by the implicit deduction guides.</source>
          <target state="translated">Эти &lt;a href=&quot;../../language/deduction_guide&quot;&gt;руководства&lt;/a&gt; по &lt;code&gt;&lt;a href=&quot;../shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&lt;/code&gt; предоставляются для std :: shared_ptr для учета крайних случаев, пропущенных неявными руководствами по выводам.</target>
        </trans-unit>
        <trans-unit id="12b353145b514386eb3d03070811d07e0bad084c" translate="yes" xml:space="preserve">
          <source>These &lt;a href=&quot;../../language/deduction_guide&quot;&gt;deduction guides&lt;/a&gt; are provided for &lt;code&gt;&lt;a href=&quot;../tuple&quot;&gt;std::tuple&lt;/a&gt;&lt;/code&gt; to account for the edge cases missed by the implicit deduction guides, in particular, non-copyable arguments and array to pointer conversion.</source>
          <target state="translated">Эти &lt;a href=&quot;../../language/deduction_guide&quot;&gt;руководства&lt;/a&gt; по &lt;code&gt;&lt;a href=&quot;../tuple&quot;&gt;std::tuple&lt;/a&gt;&lt;/code&gt; предоставляются для std :: tuple для учета крайних случаев, пропущенных неявными руководствами по выводам, в частности, не копируемых аргументов и преобразования массива в указатель.</target>
        </trans-unit>
        <trans-unit id="0d7729eb7a1438721d7721c8ec45ca17c31eb830" translate="yes" xml:space="preserve">
          <source>These &lt;a href=&quot;../../language/deduction_guide&quot;&gt;deduction guides&lt;/a&gt; are provided for multiset to allow deduction from an iterator range (overloads (1,3)) and &lt;code&gt;&lt;a href=&quot;../../utility/initializer_list&quot;&gt;std::initializer_list&lt;/a&gt;&lt;/code&gt; (overloads (2,4)). These overloads only participate in overload resolution if &lt;code&gt;InputIt&lt;/code&gt; satisfies &lt;a href=&quot;../../named_req/inputiterator&quot;&gt;LegacyInputIterator&lt;/a&gt;, &lt;code&gt;Alloc&lt;/code&gt; satisfies &lt;a href=&quot;../../named_req/allocator&quot;&gt;Allocator&lt;/a&gt;, and &lt;code&gt;Comp&lt;/code&gt; does not satisfy &lt;a href=&quot;../../named_req/allocator&quot;&gt;Allocator&lt;/a&gt;.</source>
          <target state="translated">Эти &lt;a href=&quot;../../language/deduction_guide&quot;&gt;руководства&lt;/a&gt; по выводам предназначены для мультимножества, чтобы разрешить вывод из диапазона итератора (перегрузки (1,3)) и &lt;code&gt;&lt;a href=&quot;../../utility/initializer_list&quot;&gt;std::initializer_list&lt;/a&gt;&lt;/code&gt; (перегрузки (2,4)). Эти перегрузки участвуют в разрешении перегрузки, только если &lt;code&gt;InputIt&lt;/code&gt; удовлетворяет &lt;a href=&quot;../../named_req/inputiterator&quot;&gt;LegacyInputIterator&lt;/a&gt; , &lt;code&gt;Alloc&lt;/code&gt; удовлетворяет &lt;a href=&quot;../../named_req/allocator&quot;&gt;Allocator&lt;/a&gt; , а &lt;code&gt;Comp&lt;/code&gt; не удовлетворяет &lt;a href=&quot;../../named_req/allocator&quot;&gt;Allocator&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="70a6bdbef179c3a4732cac088b62e8b6f4ff8948" translate="yes" xml:space="preserve">
          <source>These &lt;a href=&quot;../../language/deduction_guide&quot;&gt;deduction guides&lt;/a&gt; are provided for queue to allow deduction from underlying container type. This overload only participates in overload resolution if &lt;code&gt;Alloc&lt;/code&gt; satisfies &lt;a href=&quot;../../named_req/allocator&quot;&gt;Allocator&lt;/a&gt;, and &lt;code&gt;Container&lt;/code&gt; does not satisfy &lt;a href=&quot;../../named_req/allocator&quot;&gt;Allocator&lt;/a&gt; and, for overload (2), if &lt;code&gt;&lt;a href=&quot;../../memory/uses_allocator&quot;&gt;std::uses_allocator_v&lt;/a&gt;&amp;lt;Container, Allocator&amp;gt;&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">Эти &lt;a href=&quot;../../language/deduction_guide&quot;&gt;руководства по удержанию&lt;/a&gt; предназначены для очереди, чтобы разрешить вывод из базового типа контейнера. Эта перегрузка участвует только в разрешении перегрузки, если &lt;code&gt;Alloc&lt;/code&gt; удовлетворяет &lt;a href=&quot;../../named_req/allocator&quot;&gt;Allocator&lt;/a&gt; , а &lt;code&gt;Container&lt;/code&gt; не удовлетворяет &lt;a href=&quot;../../named_req/allocator&quot;&gt;Allocator&lt;/a&gt; и, для перегрузки (2), если &lt;code&gt;&lt;a href=&quot;../../memory/uses_allocator&quot;&gt;std::uses_allocator_v&lt;/a&gt;&amp;lt;Container, Allocator&amp;gt;&lt;/code&gt; имеет значение &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5d564ca21e1c30be4928dd9500b875ed1d963057" translate="yes" xml:space="preserve">
          <source>These &lt;a href=&quot;../../language/deduction_guide&quot;&gt;deduction guides&lt;/a&gt; are provided for set to allow deduction from an iterator range (overloads (1,3)) and &lt;code&gt;&lt;a href=&quot;../../utility/initializer_list&quot;&gt;std::initializer_list&lt;/a&gt;&lt;/code&gt; (overloads (2,4)). These overloads only participate in overload resolution if &lt;code&gt;InputIt&lt;/code&gt; satisfies &lt;a href=&quot;../../named_req/inputiterator&quot;&gt;LegacyInputIterator&lt;/a&gt;, &lt;code&gt;Alloc&lt;/code&gt; satisfies &lt;a href=&quot;../../named_req/allocator&quot;&gt;Allocator&lt;/a&gt;, and &lt;code&gt;Comp&lt;/code&gt; does not satisfy &lt;a href=&quot;../../named_req/allocator&quot;&gt;Allocator&lt;/a&gt;.</source>
          <target state="translated">Эти &lt;a href=&quot;../../language/deduction_guide&quot;&gt;руководства по выводу&lt;/a&gt; предназначены для установки, чтобы разрешить вывод из диапазона итератора (перегрузки (1,3)) и &lt;code&gt;&lt;a href=&quot;../../utility/initializer_list&quot;&gt;std::initializer_list&lt;/a&gt;&lt;/code&gt; (перегрузки (2,4)). Эти перегрузки участвуют в разрешении перегрузки, только если &lt;code&gt;InputIt&lt;/code&gt; удовлетворяет &lt;a href=&quot;../../named_req/inputiterator&quot;&gt;LegacyInputIterator&lt;/a&gt; , &lt;code&gt;Alloc&lt;/code&gt; удовлетворяет &lt;a href=&quot;../../named_req/allocator&quot;&gt;Allocator&lt;/a&gt; , а &lt;code&gt;Comp&lt;/code&gt; не удовлетворяет &lt;a href=&quot;../../named_req/allocator&quot;&gt;Allocator&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="13ef785aba459afe56d345cd56062fe469f5d0da" translate="yes" xml:space="preserve">
          <source>These &lt;a href=&quot;../../language/deduction_guide&quot;&gt;deduction guides&lt;/a&gt; are provided for stack to allow deduction from underlying container type. This overload only participates in overload resolution if &lt;code&gt;Alloc&lt;/code&gt; satisfies &lt;a href=&quot;../../named_req/allocator&quot;&gt;Allocator&lt;/a&gt;, and &lt;code&gt;Container&lt;/code&gt; does not satisfy &lt;a href=&quot;../../named_req/allocator&quot;&gt;Allocator&lt;/a&gt; and, for overload (2), if &lt;code&gt;&lt;a href=&quot;../../memory/uses_allocator&quot;&gt;std::uses_allocator_v&lt;/a&gt;&amp;lt;Container, Allocator&amp;gt;&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">Эти &lt;a href=&quot;../../language/deduction_guide&quot;&gt;инструкции&lt;/a&gt; по выводу предусмотрены для стека, чтобы разрешить вывод из базового типа контейнера. Эта перегрузка участвует только в разрешении перегрузки, если &lt;code&gt;Alloc&lt;/code&gt; удовлетворяет &lt;a href=&quot;../../named_req/allocator&quot;&gt;Allocator&lt;/a&gt; , а &lt;code&gt;Container&lt;/code&gt; не удовлетворяет &lt;a href=&quot;../../named_req/allocator&quot;&gt;Allocator&lt;/a&gt; и, для перегрузки (2), если &lt;code&gt;&lt;a href=&quot;../../memory/uses_allocator&quot;&gt;std::uses_allocator_v&lt;/a&gt;&amp;lt;Container, Allocator&amp;gt;&lt;/code&gt; имеет значение &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4dafdd32c659086dffb3edda268826ae9c158e33" translate="yes" xml:space="preserve">
          <source>These &lt;a href=&quot;../../language/deduction_guide&quot;&gt;deduction guides&lt;/a&gt; are provided for unordered_multiset to allow deduction from an iterator range (overloads (1,3,4)) and &lt;code&gt;&lt;a href=&quot;../../utility/initializer_list&quot;&gt;std::initializer_list&lt;/a&gt;&lt;/code&gt; (overloads (2,5.6)). This overload only participates in overload resolution if &lt;code&gt;InputIt&lt;/code&gt; satisfies &lt;a href=&quot;../../named_req/inputiterator&quot;&gt;LegacyInputIterator&lt;/a&gt;, &lt;code&gt;Alloc&lt;/code&gt; satisfies &lt;a href=&quot;../../named_req/allocator&quot;&gt;Allocator&lt;/a&gt;, neither &lt;code&gt;Hash&lt;/code&gt; nor &lt;code&gt;Pred&lt;/code&gt; satisfy &lt;a href=&quot;../../named_req/allocator&quot;&gt;Allocator&lt;/a&gt;, &lt;code&gt;Hash&lt;/code&gt; is not an integral type.</source>
          <target state="translated">Эти &lt;a href=&quot;../../language/deduction_guide&quot;&gt;руководства&lt;/a&gt; по выводу предусмотрены для unordered_multiset, чтобы разрешить вывод из диапазона итератора (перегрузки (1,3,4)) и &lt;code&gt;&lt;a href=&quot;../../utility/initializer_list&quot;&gt;std::initializer_list&lt;/a&gt;&lt;/code&gt; (перегрузки (2,5.6)). Эта перегрузка участвует только в разрешении перегрузки, если &lt;code&gt;InputIt&lt;/code&gt; удовлетворяет &lt;a href=&quot;../../named_req/inputiterator&quot;&gt;LegacyInputIterator&lt;/a&gt; , &lt;code&gt;Alloc&lt;/code&gt; удовлетворяет &lt;a href=&quot;../../named_req/allocator&quot;&gt;Allocator&lt;/a&gt; , ни &lt;code&gt;Hash&lt;/code&gt; , ни &lt;code&gt;Pred&lt;/code&gt; не удовлетворяют &lt;a href=&quot;../../named_req/allocator&quot;&gt;Allocator&lt;/a&gt; , &lt;code&gt;Hash&lt;/code&gt; не является целочисленным типом.</target>
        </trans-unit>
        <trans-unit id="9bb6043ae0763bf108698a03aeb652cc5820df07" translate="yes" xml:space="preserve">
          <source>These &lt;a href=&quot;../../language/deduction_guide&quot;&gt;deduction guides&lt;/a&gt; are provided for unordered_set to allow deduction from an iterator range (overloads (1,3,4)) and &lt;code&gt;&lt;a href=&quot;../../utility/initializer_list&quot;&gt;std::initializer_list&lt;/a&gt;&lt;/code&gt; (overloads (2,5.6)). This overload only participates in overload resolution if &lt;code&gt;InputIt&lt;/code&gt; satisfies &lt;a href=&quot;../../named_req/inputiterator&quot;&gt;LegacyInputIterator&lt;/a&gt;, &lt;code&gt;Alloc&lt;/code&gt; satisfies &lt;a href=&quot;../../named_req/allocator&quot;&gt;Allocator&lt;/a&gt;, neither &lt;code&gt;Hash&lt;/code&gt; nor &lt;code&gt;Pred&lt;/code&gt; satisfy &lt;a href=&quot;../../named_req/allocator&quot;&gt;Allocator&lt;/a&gt;, &lt;code&gt;Hash&lt;/code&gt; is not an integral type.</source>
          <target state="translated">Эти &lt;a href=&quot;../../language/deduction_guide&quot;&gt;руководства&lt;/a&gt; по выводу предоставляются для unordered_set, чтобы разрешить вычет из диапазона итераторов (перегрузки (1,3,4)) и &lt;code&gt;&lt;a href=&quot;../../utility/initializer_list&quot;&gt;std::initializer_list&lt;/a&gt;&lt;/code&gt; (перегрузки (2,5,6)). Эта перегрузка участвует только в разрешении перегрузки, если &lt;code&gt;InputIt&lt;/code&gt; удовлетворяет &lt;a href=&quot;../../named_req/inputiterator&quot;&gt;LegacyInputIterator&lt;/a&gt; , &lt;code&gt;Alloc&lt;/code&gt; удовлетворяет &lt;a href=&quot;../../named_req/allocator&quot;&gt;Allocator&lt;/a&gt; , ни &lt;code&gt;Hash&lt;/code&gt; , ни &lt;code&gt;Pred&lt;/code&gt; не удовлетворяют &lt;a href=&quot;../../named_req/allocator&quot;&gt;Allocator&lt;/a&gt; , &lt;code&gt;Hash&lt;/code&gt; не является целочисленным типом.</target>
        </trans-unit>
        <trans-unit id="998a40ef4627e5e01e4248114651ccad38e51377" translate="yes" xml:space="preserve">
          <source>These &lt;code&gt;operator/&lt;/code&gt; overloads provide a conventional syntax for the creation of Gregorian calendar dates.</source>
          <target state="translated">Эти &lt;code&gt;operator/&lt;/code&gt; перегрузки предоставляют традиционный синтаксис для создания дат григорианского календаря.</target>
        </trans-unit>
        <trans-unit id="74e2c10444921183c350121d5ff7c2b2d260e16b" translate="yes" xml:space="preserve">
          <source>These algorithms cannot be used with associative containers such as &lt;code&gt;&lt;a href=&quot;../container/set&quot;&gt;std::set&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../container/map&quot;&gt;std::map&lt;/a&gt;&lt;/code&gt; because ForwardIt does not dereference to a MoveAssignable type (the keys in these containers are not modifiable).</source>
          <target state="translated">Эти алгоритмы нельзя использовать с ассоциативными контейнерами, такими как &lt;code&gt;&lt;a href=&quot;../container/set&quot;&gt;std::set&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;../container/map&quot;&gt;std::map&lt;/a&gt;&lt;/code&gt; поскольку ForwardIt не обращается к типу MoveAssignable (ключи в этих контейнерах не могут быть изменены).</target>
        </trans-unit>
        <trans-unit id="dc6f538fd8e7e831a029d42e6c3295c5ce6547d3" translate="yes" xml:space="preserve">
          <source>These are the directives defined by the standard. The standard does not define behavior for other directives: they might be ignored, have some useful meaning, or cause a compile-time error. Even if otherwise ignored, they are removed from the source code when the preprocessor is done. A common non-standard extension is the directive &lt;code&gt;#warning&lt;/code&gt; which emits a user-defined message during compilation.</source>
          <target state="translated">Это директивы, определенные стандартом. Стандарт не определяет поведение для других директив: они могут игнорироваться, иметь какое-то полезное значение или вызывать ошибку во время компиляции. Даже если иное игнорируется, они удаляются из исходного кода после завершения препроцессора. Распространенным нестандартным расширением является директива &lt;code&gt;#warning&lt;/code&gt; , которая выдает пользовательское сообщение во время компиляции.</target>
        </trans-unit>
        <trans-unit id="ec4ebc2b939ff4d66f10267f6f032b0dd31634b9" translate="yes" xml:space="preserve">
          <source>These are type categories defined by the core language. They are included here as named requirements only for consistency.</source>
          <target state="translated">Это категории типов,определяемые основным языком.Они включены здесь в качестве названных требований только для согласованности.</target>
        </trans-unit>
        <trans-unit id="41f69a0ad4c5384189f3c5f07ef1de6088dafb43" translate="yes" xml:space="preserve">
          <source>These attributes may be applied to labels and statements (other than declaration-statements). They may not be simultaneously applied to the same label or statement.</source>
          <target state="translated">Эти атрибуты могут быть применены к этикеткам и утверждениям (кроме деклараций-заявок).Они не могут одновременно применяться к одной и той же этикетке или заявлению.</target>
        </trans-unit>
        <trans-unit id="f1b3468a96579cdd8f43ddee81097dc1e729403b" translate="yes" xml:space="preserve">
          <source>These bullets describe situations that cannot arise in C++ and therefore are omitted from the discussion above. In C, aggregate copy and assignment access the aggregate object as a whole. But in C++ such actions are always performed through a member function call, which accesses the individual subobjects rather than the entire object (or, in the case of unions, copies the object representation, i.e., via &lt;code&gt;unsigned char&lt;/code&gt;). See &lt;a href=&quot;http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_active.html#2051&quot;&gt;core issue 2051&lt;/a&gt;.</source>
          <target state="translated">Эти маркеры описывают ситуации, которые не могут возникнуть в C ++, и поэтому не рассматриваются в обсуждении выше. В C совокупное копирование и присвоение обращаются к совокупному объекту в целом. Но в C ++ такие действия всегда выполняются через вызов функции-члена, который обращается к отдельным подобъектам, а не ко всему объекту (или, в случае союзов, копирует представление объекта, т. &lt;code&gt;unsigned char&lt;/code&gt; Через unsigned char ). Смотрите &lt;a href=&quot;http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_active.html#2051&quot;&gt;основной вопрос 2051&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7e2e85ea89bf8851056faa66c86c8a89f763163c" translate="yes" xml:space="preserve">
          <source>These classes encapsulate a regular expression and the results of matching a regular expression within a target sequence of characters.</source>
          <target state="translated">Эти классы инкапсулируют регулярное выражение и результаты сопоставления регулярного выражения в целевой последовательности символов.</target>
        </trans-unit>
        <trans-unit id="5187a740adf841afb17f5f37d5efc0eafaa7fbe7" translate="yes" xml:space="preserve">
          <source>These constants are duplicated from &lt;code&gt;std::regex_constants&lt;/code&gt;:</source>
          <target state="translated">Эти константы дублируются из &lt;code&gt;std::regex_constants&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="19ba3734849d9efa52a071b6c74031883732795a" translate="yes" xml:space="preserve">
          <source>These constants provide a portable way to access the L1 data cache line size.</source>
          <target state="translated">Эти константы обеспечивают портативный способ доступа к размеру линии кэша данных L1.</target>
        </trans-unit>
        <trans-unit id="5aeef84fd68b04dfd62540295b4e58ffbc1ad7c5" translate="yes" xml:space="preserve">
          <source>These constructors additionally do not participate in overload resolution if the expression &lt;code&gt;d(ptr)&lt;/code&gt; is not well-formed, or if &lt;code&gt;&lt;a href=&quot;../../types/is_move_constructible&quot;&gt;std::is_move_constructible&lt;/a&gt;&amp;lt;D&amp;gt;::value&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">Эти конструкторы дополнительно не участвуют в разрешении перегрузки, если выражение &lt;code&gt;d(ptr)&lt;/code&gt; не правильно сформировано или если &lt;code&gt;&lt;a href=&quot;../../types/is_move_constructible&quot;&gt;std::is_move_constructible&lt;/a&gt;&amp;lt;D&amp;gt;::value&lt;/code&gt; равно &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2cd12e66c1b571e2605eacf313edfc5ca3855042" translate="yes" xml:space="preserve">
          <source>These constructors are typically called by the constructors of &lt;code&gt;&lt;a href=&quot;../strstream&quot;&gt;std::strstream&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Эти конструкторы обычно вызываются конструкторами &lt;code&gt;&lt;a href=&quot;../strstream&quot;&gt;std::strstream&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7ee89583b6197fe5f3d8e0eab3b74e26c4d4069c" translate="yes" xml:space="preserve">
          <source>These conversions are purely lexical. They do not check that the paths exist, do not follow symlinks, and do not access the filesystem at all. For symlink-following counterparts of &lt;code&gt;lexically_relative&lt;/code&gt; and &lt;code&gt;lexically_proximate&lt;/code&gt;, see &lt;a href=&quot;../relative&quot;&gt;&lt;code&gt;relative&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../relative&quot;&gt;&lt;code&gt;proximate&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Эти преобразования являются чисто лексическими. Они не проверяют существование путей, не следуют по символическим ссылкам и вообще не обращаются к файловой системе. Для следующих за &lt;code&gt;lexically_relative&lt;/code&gt; аналогов lexically_relative и &lt;code&gt;lexically_proximate&lt;/code&gt; , смотрите &lt;a href=&quot;../relative&quot;&gt; &lt;code&gt;relative&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;../relative&quot;&gt; &lt;code&gt;proximate&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3b066eecc1428c4afc05b8473b0ce8b6682781dc" translate="yes" xml:space="preserve">
          <source>These conversions model the type conversion applied to all function arguments when passed by value.</source>
          <target state="translated">Эти приведения моделируют приведение типа,применяемое ко всем аргументам функции при передаче по значению.</target>
        </trans-unit>
        <trans-unit id="1f828b6e7c5612d3683245cf9a5d3fa76a3dbee3" translate="yes" xml:space="preserve">
          <source>These fictional constructors are public members of the hypothetical class type. They are explicit if the guide was formed from an explicit constructor. If overload resolution fails, the program is ill-formed. Otherwise, the return type of the selected &lt;code&gt;F&lt;/code&gt; template specialization becomes the deduced class template specialization.</source>
          <target state="translated">Эти вымышленные конструкторы являются открытыми членами гипотетического типа класса. Они явные, если руководство было сформировано из явного конструктора. Если не удается разрешить перегрузку, программа работает некорректно. В противном случае возвращаемый тип выбранной специализации &lt;code&gt;F&lt;/code&gt; - шаблона становится выведенной специализацией шаблона класса.</target>
        </trans-unit>
        <trans-unit id="9e1185e2ec5ad6dc826827fc0bc8b26aeb766d26" translate="yes" xml:space="preserve">
          <source>These function templates are not visible to ordinary &lt;a href=&quot;../../language/unqualified_lookup&quot;&gt;unqualified&lt;/a&gt; or &lt;a href=&quot;../../language/qualified_lookup&quot;&gt;qualified lookup&lt;/a&gt; , and can only be found by &lt;a href=&quot;../../language/adl&quot;&gt;argument-dependent lookup&lt;/a&gt; when &lt;code&gt;&lt;a href=&quot;../path&quot;&gt;std::filesystem::path&lt;/a&gt;&lt;/code&gt; is an associated class of the arguments. This prevents undesirable conversions in the presence of a &lt;code&gt;using namespace std::filesystem;&lt;/code&gt;</source>
          <target state="translated">Эти шаблоны функций не видны для обычного &lt;a href=&quot;../../language/unqualified_lookup&quot;&gt;неквалифицированного&lt;/a&gt; или &lt;a href=&quot;../../language/qualified_lookup&quot;&gt;квалифицированного поиска&lt;/a&gt; , и могут быть найдены только в &lt;a href=&quot;../../language/adl&quot;&gt;зависимости&lt;/a&gt; от аргументов, когда &lt;code&gt;&lt;a href=&quot;../path&quot;&gt;std::filesystem::path&lt;/a&gt;&lt;/code&gt; является ассоциированным классом аргументов. Это предотвращает нежелательные преобразования в присутствии &lt;code&gt;using namespace std::filesystem;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="043baecb502250e4140c666b26e06dd43b796356" translate="yes" xml:space="preserve">
          <source>These function templates are optional: an implementation may choose to instead provide &lt;code&gt;to_sys&lt;/code&gt; and &lt;code&gt;from_sys&lt;/code&gt;.</source>
          <target state="translated">Эти шаблоны функций являются необязательными: реализация может вместо этого предоставить &lt;code&gt;to_sys&lt;/code&gt; и &lt;code&gt;from_sys&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f7805c9adadba15da9ce1789282d1fdeae7db0ab" translate="yes" xml:space="preserve">
          <source>These function templates are optional: an implementation may choose to instead provide &lt;code&gt;to_utc&lt;/code&gt; and &lt;code&gt;from_utc&lt;/code&gt;.</source>
          <target state="translated">Эти шаблоны функций являются необязательными: реализация может вместо этого предоставить &lt;code&gt;to_utc&lt;/code&gt; и &lt;code&gt;from_utc&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7487a9c951b04abd0ea64aae0657bd6c80e75211" translate="yes" xml:space="preserve">
          <source>These function templates behave as if they.</source>
          <target state="translated">Эти шаблоны функций ведут себя так,как будто они есть.</target>
        </trans-unit>
        <trans-unit id="419d5c3b82807fda6edd67b01bc6da49f1a27023" translate="yes" xml:space="preserve">
          <source>These functions are defined in terms of member functions of &lt;code&gt;&lt;a href=&quot;atomic&quot;&gt;std::atomic&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">Эти функции определены в терминах функций-членов &lt;code&gt;&lt;a href=&quot;atomic&quot;&gt;std::atomic&lt;/a&gt;&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="706bfb2aebd27a90d3a3878dfe394992ff31ffb1" translate="yes" xml:space="preserve">
          <source>These functions are not visible to ordinary &lt;a href=&quot;../../language/unqualified_lookup&quot;&gt;unqualified&lt;/a&gt; or &lt;a href=&quot;../../language/qualified_lookup&quot;&gt;qualified lookup&lt;/a&gt; , and can only be found by &lt;a href=&quot;../../language/adl&quot;&gt;argument-dependent lookup&lt;/a&gt; when &lt;code&gt;&lt;a href=&quot;../path&quot;&gt;std::filesystem::path&lt;/a&gt;&lt;/code&gt; is an associated class of the arguments. This prevents undesirable conversions in the presence of a &lt;code&gt;using namespace std::filesystem;&lt;/code&gt;</source>
          <target state="translated">Эти функции не видны обычному &lt;a href=&quot;../../language/unqualified_lookup&quot;&gt;неквалифицированному&lt;/a&gt; или &lt;a href=&quot;../../language/qualified_lookup&quot;&gt;квалифицированному поиску&lt;/a&gt; , и их можно найти только путем &lt;a href=&quot;../../language/adl&quot;&gt;поиска, зависящего&lt;/a&gt; от аргументов, когда &lt;code&gt;&lt;a href=&quot;../path&quot;&gt;std::filesystem::path&lt;/a&gt;&lt;/code&gt; является ассоциированным классом аргументов. Это предотвращает нежелательные преобразования в присутствии &lt;code&gt;using namespace std::filesystem;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2f3e6ab375e463f1612d61a87d214ea836c037d5" translate="yes" xml:space="preserve">
          <source>These functions are not visible to ordinary &lt;a href=&quot;../../language/unqualified_lookup&quot;&gt;unqualified&lt;/a&gt; or &lt;a href=&quot;../../language/qualified_lookup&quot;&gt;qualified lookup&lt;/a&gt;, and can only be found by &lt;a href=&quot;../../language/adl&quot;&gt;argument-dependent lookup&lt;/a&gt; when &lt;code&gt;std::basic_string_view&amp;lt;CharT, Traits&amp;gt;&lt;/code&gt; is an associated class of the arguments.</source>
          <target state="translated">Эти функции невидимы для обычного &lt;a href=&quot;../../language/unqualified_lookup&quot;&gt;неквалифицированного&lt;/a&gt; или &lt;a href=&quot;../../language/qualified_lookup&quot;&gt;квалифицированного поиска&lt;/a&gt; , и их можно найти только путем &lt;a href=&quot;../../language/adl&quot;&gt;поиска, зависящего&lt;/a&gt; от аргумента, когда &lt;code&gt;std::basic_string_view&amp;lt;CharT, Traits&amp;gt;&lt;/code&gt; является связанным классом аргументов.</target>
        </trans-unit>
        <trans-unit id="71d3bc1bc9cc67bb93448628acb0478629973b75" translate="yes" xml:space="preserve">
          <source>These functions are not visible to ordinary &lt;a href=&quot;../../language/unqualified_lookup&quot;&gt;unqualified&lt;/a&gt; or &lt;a href=&quot;../../language/qualified_lookup&quot;&gt;qualified lookup&lt;/a&gt;, and can only be found by &lt;a href=&quot;../../language/adl&quot;&gt;argument-dependent lookup&lt;/a&gt; when &lt;code&gt;std::span&amp;lt;T, Extent&amp;gt;&lt;/code&gt; is an associated class of the arguments.</source>
          <target state="translated">Эти функции невидимы для обычного &lt;a href=&quot;../../language/unqualified_lookup&quot;&gt;неквалифицированного&lt;/a&gt; или &lt;a href=&quot;../../language/qualified_lookup&quot;&gt;квалифицированного поиска&lt;/a&gt; , и их можно найти только путем &lt;a href=&quot;../../language/adl&quot;&gt;поиска, зависящего&lt;/a&gt; от аргументов, когда &lt;code&gt;std::span&amp;lt;T, Extent&amp;gt;&lt;/code&gt; является ассоциированным классом аргументов.</target>
        </trans-unit>
        <trans-unit id="9cafa0c4c816e506567effd571a10a76ae52acd3" translate="yes" xml:space="preserve">
          <source>These functions are not visible to ordinary &lt;a href=&quot;../language/unqualified_lookup&quot;&gt;unqualified&lt;/a&gt; or &lt;a href=&quot;../language/qualified_lookup&quot;&gt;qualified lookup&lt;/a&gt;, and can only be found by &lt;a href=&quot;../language/adl&quot;&gt;argument-dependent lookup&lt;/a&gt; when &lt;code&gt;std::ranges::empty_view&amp;lt;T&amp;gt;&lt;/code&gt; is an associated class of the arguments.</source>
          <target state="translated">Эти функции не видны обычному &lt;a href=&quot;../language/unqualified_lookup&quot;&gt;неквалифицированному&lt;/a&gt; или &lt;a href=&quot;../language/qualified_lookup&quot;&gt;квалифицированному поиску&lt;/a&gt; и могут быть найдены только путем &lt;a href=&quot;../language/adl&quot;&gt;поиска, зависящего&lt;/a&gt; от аргументов, когда &lt;code&gt;std::ranges::empty_view&amp;lt;T&amp;gt;&lt;/code&gt; является ассоциированным классом аргументов.</target>
        </trans-unit>
        <trans-unit id="13ae74af435260e5a8fc58a9b3b8f8b649c48761" translate="yes" xml:space="preserve">
          <source>These functions are not visible to ordinary &lt;a href=&quot;../language/unqualified_lookup&quot;&gt;unqualified&lt;/a&gt; or &lt;a href=&quot;../language/qualified_lookup&quot;&gt;qualified lookup&lt;/a&gt;, and can only be found by &lt;a href=&quot;../language/adl&quot;&gt;argument-dependent lookup&lt;/a&gt; when &lt;code&gt;std::ranges::ref_view&amp;lt;R&amp;gt;&lt;/code&gt; is an associated class of the arguments.</source>
          <target state="translated">Эти функции не видны обычному &lt;a href=&quot;../language/unqualified_lookup&quot;&gt;неквалифицированному&lt;/a&gt; или &lt;a href=&quot;../language/qualified_lookup&quot;&gt;квалифицированному поиску&lt;/a&gt; , и их можно найти только путем &lt;a href=&quot;../language/adl&quot;&gt;поиска, зависящего&lt;/a&gt; от аргументов, когда &lt;code&gt;std::ranges::ref_view&amp;lt;R&amp;gt;&lt;/code&gt; является ассоциированным классом аргументов.</target>
        </trans-unit>
        <trans-unit id="96489aaabbabce3adba15d3840295fb8191f8911" translate="yes" xml:space="preserve">
          <source>These functions are provided to make &lt;code&gt;span&lt;/code&gt; rvalues work with &lt;code&gt;std::ranges::begin&lt;/code&gt; and &lt;code&gt;std::ranges::end&lt;/code&gt;, which reject rvalue arguments by default in order to prevent dangling iterator.</source>
          <target state="translated">Эти функции предназначены для того, чтобы заставить значения r &lt;code&gt;span&lt;/code&gt; работать с &lt;code&gt;std::ranges::begin&lt;/code&gt; range :: begin и &lt;code&gt;std::ranges::end&lt;/code&gt; , которые по умолчанию отклоняют аргументы rvalue во избежание зависания итератора.</target>
        </trans-unit>
        <trans-unit id="5f45f69461ef9381b69148d33ccefcd3eafb9116" translate="yes" xml:space="preserve">
          <source>These functions are provided to make &lt;code&gt;string_view&lt;/code&gt; rvalues work with &lt;code&gt;std::ranges::begin&lt;/code&gt; and &lt;code&gt;std::ranges::end&lt;/code&gt;, which reject rvalue arguments by default in order to prevent dangling iterator.</source>
          <target state="translated">Эти функции предназначены для того, чтобы &lt;code&gt;string_view&lt;/code&gt; string_view работали с &lt;code&gt;std::ranges::begin&lt;/code&gt; range :: begin и &lt;code&gt;std::ranges::end&lt;/code&gt; , которые по умолчанию отклоняют аргументы rvalue во избежание зависания итератора.</target>
        </trans-unit>
        <trans-unit id="be2ae68f22369098426dd815dea838deb2f9b140" translate="yes" xml:space="preserve">
          <source>These functions are typically implemented using mutexes, stored in a global hash table where the pointer value is used as the key.</source>
          <target state="translated">Эти функции обычно реализуются с помощью мьютексов,хранящихся в глобальной хэш-таблице,где в качестве ключа используется значение указателя.</target>
        </trans-unit>
        <trans-unit id="326f105b45787866cfe222f982d0d9e27243f9ff" translate="yes" xml:space="preserve">
          <source>These functions are used to apply the regular expression encapsulated in a regex to a target sequence of characters.</source>
          <target state="translated">Эти функции используются для применения регулярного выражения,заключенного в регекс,к целевой последовательности символов.</target>
        </trans-unit>
        <trans-unit id="7585335f42669921d2b1bf3e543316f127948a1e" translate="yes" xml:space="preserve">
          <source>These functions do not participate in overload resolution (or, for the copy assignment operator, is defined as deleted) if any required assignment operation is invalid or if there is a size mismatch. Specifically:</source>
          <target state="translated">Эти функции не участвуют в разрешении перегрузки (или,для оператора присваивания копии,определяется как удаленная),если любая требуемая операция присваивания недействительна или если есть несоответствие размеров.В частности:</target>
        </trans-unit>
        <trans-unit id="d30d68da83412d7ae98ce606334319e3d70b73d8" translate="yes" xml:space="preserve">
          <source>These functions do not participate in overload resolution (or, for the copy assignment operator, is defined as deleted) if any required assignment operation is invalid. Specifically:</source>
          <target state="translated">Эти функции не участвуют в разрешении перегрузки (или,для оператора присваивания копии,определяется как удаленная),если любая необходимая операция присваивания недействительна.В частности:</target>
        </trans-unit>
        <trans-unit id="cafe750e84a77bd66ed9b0e48c90443f0b94fd28" translate="yes" xml:space="preserve">
          <source>These functions do not throw exceptions.</source>
          <target state="translated">Эти функции не бросают исключений.</target>
        </trans-unit>
        <trans-unit id="6ee20f7717337989ef84b3eb0d3af4c0f3efbcb1" translate="yes" xml:space="preserve">
          <source>These functions effectively yield an approximation of the meaning of the argument path &lt;code&gt;p&lt;/code&gt; in an environment where &lt;code&gt;*this&lt;/code&gt; is the starting directory.</source>
          <target state="translated">Эти функции эффективно дают приближение значения пути аргумента &lt;code&gt;p&lt;/code&gt; в среде, где &lt;code&gt;*this&lt;/code&gt; начальный каталог.</target>
        </trans-unit>
        <trans-unit id="b7da2559e16d851f64895f9b8ce4e64008d143d3" translate="yes" xml:space="preserve">
          <source>These functions provide access to the program-wide time zone database.</source>
          <target state="translated">Эти функции обеспечивают доступ к базе данных часовых поясов всей программы.</target>
        </trans-unit>
        <trans-unit id="e5ab52d07da85043f4b5804364445cb1d17fd3ed" translate="yes" xml:space="preserve">
          <source>These functions take a result of 3-way comparison and convert it to the result of one of the six relational operators.</source>
          <target state="translated">Эти функции берут результат 3-позиционного сравнения и преобразуют его в результат одного из шести реляционных операторов.</target>
        </trans-unit>
        <trans-unit id="09dc533f744ccd968da17e107b1a623a70147eb2" translate="yes" xml:space="preserve">
          <source>These functions were deprecated in favor of the specializations of the &lt;code&gt;&lt;a href=&quot;../../atomic/atomic&quot;&gt;std::atomic&lt;/a&gt;&lt;/code&gt; template: &lt;code&gt;&lt;a href=&quot;../../atomic/atomic&quot;&gt;std::atomic&lt;/a&gt;&amp;lt;&lt;a href=&quot;../shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&amp;gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../../atomic/atomic&quot;&gt;std::atomic&lt;/a&gt;&amp;lt;&lt;a href=&quot;../weak_ptr&quot;&gt;std::weak_ptr&lt;/a&gt;&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">Эти функции устарели в пользу специализаций шаблона &lt;code&gt;&lt;a href=&quot;../../atomic/atomic&quot;&gt;std::atomic&lt;/a&gt;&lt;/code&gt; : &lt;code&gt;&lt;a href=&quot;../../atomic/atomic&quot;&gt;std::atomic&lt;/a&gt;&amp;lt;&lt;a href=&quot;../shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&amp;gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;../../atomic/atomic&quot;&gt;std::atomic&lt;/a&gt;&amp;lt;&lt;a href=&quot;../weak_ptr&quot;&gt;std::weak_ptr&lt;/a&gt;&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e8ebef2701474b9ea6a2624b079221ae9fed097b" translate="yes" xml:space="preserve">
          <source>These hashes equal the hashes of corresponding &lt;code&gt;&lt;a href=&quot;../basic_string&quot;&gt;std::basic_string&lt;/a&gt;&lt;/code&gt; classes: If S is one of the standard basic_string types, SV is the corresponding string view type, and s is an object of type S, then &lt;code&gt;&lt;a href=&quot;../../utility/hash&quot;&gt;std::hash&lt;/a&gt;&amp;lt;S&amp;gt;()(s) == &lt;a href=&quot;../../utility/hash&quot;&gt;std::hash&lt;/a&gt;&amp;lt;SV&amp;gt;()(SV(s))&lt;/code&gt;.</source>
          <target state="translated">Эти хэши равны хешам соответствующих классов &lt;code&gt;&lt;a href=&quot;../basic_string&quot;&gt;std::basic_string&lt;/a&gt;&lt;/code&gt; : если S - один из стандартных типов basic_string, SV - соответствующий тип строкового представления, а s - объект типа S, тогда &lt;code&gt;&lt;a href=&quot;../../utility/hash&quot;&gt;std::hash&lt;/a&gt;&amp;lt;S&amp;gt;()(s) == &lt;a href=&quot;../../utility/hash&quot;&gt;std::hash&lt;/a&gt;&amp;lt;SV&amp;gt;()(SV(s))&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="04c0518ba136c51c78f2d27b7888f66813a53b9f" translate="yes" xml:space="preserve">
          <source>These hashes equal the hashes of corresponding &lt;code&gt;&lt;a href=&quot;../basic_string_view&quot;&gt;std::basic_string_view&lt;/a&gt;&lt;/code&gt; classes: If S is one of these string types, SV is the corresponding string view type, and s is an object of type S, then &lt;code&gt;&lt;a href=&quot;../../utility/hash&quot;&gt;std::hash&lt;/a&gt;&amp;lt;S&amp;gt;()(s) == &lt;a href=&quot;../../utility/hash&quot;&gt;std::hash&lt;/a&gt;&amp;lt;SV&amp;gt;()(SV(s))&lt;/code&gt;.</source>
          <target state="translated">Эти хэши равны хешам соответствующих классов &lt;code&gt;&lt;a href=&quot;../basic_string_view&quot;&gt;std::basic_string_view&lt;/a&gt;&lt;/code&gt; : если S является одним из этих строковых типов, SV является соответствующим типом строкового представления, а s является объектом типа S, тогда &lt;code&gt;&lt;a href=&quot;../../utility/hash&quot;&gt;std::hash&lt;/a&gt;&amp;lt;S&amp;gt;()(s) == &lt;a href=&quot;../../utility/hash&quot;&gt;std::hash&lt;/a&gt;&amp;lt;SV&amp;gt;()(SV(s))&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="378bbcb4a72a73dada77e96ee58fc0765cdcf81d" translate="yes" xml:space="preserve">
          <source>These headers are allowed to also declare the same names in the &lt;code&gt;std&lt;/code&gt; namespace, and the corresponding &lt;code&gt;cxxx&lt;/code&gt; headers are allowed to also declare the same names in the global namespace: including &amp;lt;cstdlib&amp;gt; definitely provides &lt;code&gt;&lt;a href=&quot;memory/c/malloc&quot;&gt;std::malloc&lt;/a&gt;&lt;/code&gt; and may also provide &lt;code&gt;::malloc&lt;/code&gt;. Including &amp;lt;stdlib.h&amp;gt; definitely provides &lt;code&gt;::malloc&lt;/code&gt; and may also provide &lt;code&gt;&lt;a href=&quot;memory/c/malloc&quot;&gt;std::malloc&lt;/a&gt;&lt;/code&gt;. This applies even to functions and function overloads that are not part of C standard library.</source>
          <target state="translated">Эти заголовки могут также объявлять одинаковые имена в пространстве имен &lt;code&gt;std&lt;/code&gt; , а соответствующие заголовки &lt;code&gt;cxxx&lt;/code&gt; также могут объявлять одинаковые имена в глобальном пространстве имен: в том числе &amp;lt;cstdlib&amp;gt; определенно предоставляет &lt;code&gt;&lt;a href=&quot;memory/c/malloc&quot;&gt;std::malloc&lt;/a&gt;&lt;/code&gt; и может также предоставлять &lt;code&gt;::malloc&lt;/code&gt; , Включение &amp;lt;stdlib.h&amp;gt; определенно обеспечивает &lt;code&gt;::malloc&lt;/code&gt; и может также обеспечить &lt;code&gt;&lt;a href=&quot;memory/c/malloc&quot;&gt;std::malloc&lt;/a&gt;&lt;/code&gt; . Это относится даже к функциям и перегрузкам функций, которые не являются частью стандартной библиотеки C.</target>
        </trans-unit>
        <trans-unit id="9c301ca8ee91cc2dc03b93b934d87b55d872e6ac" translate="yes" xml:space="preserve">
          <source>These member types are required to be obtained by inheriting from &lt;code&gt;&lt;a href=&quot;../iterator/iterator&quot;&gt;std::iterator&lt;/a&gt;&amp;lt;&lt;a href=&quot;../iterator/iterator_tags&quot;&gt;std::output_iterator_tag&lt;/a&gt;, void, void, void, void&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">Эти типы элементов должны быть получены путем наследования от &lt;code&gt;&lt;a href=&quot;../iterator/iterator&quot;&gt;std::iterator&lt;/a&gt;&amp;lt;&lt;a href=&quot;../iterator/iterator_tags&quot;&gt;std::output_iterator_tag&lt;/a&gt;, void, void, void, void&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="269f91543a7d747d3318687896f196744a919ccf" translate="yes" xml:space="preserve">
          <source>These member types are required to be obtained by inheriting from &lt;code&gt;&lt;a href=&quot;iterator&quot;&gt;std::iterator&lt;/a&gt;&amp;lt; &lt;a href=&quot;iterator_traits&quot;&gt;std::iterator_traits&lt;/a&gt;&amp;lt;Iter&amp;gt;::iterator_category&lt;br/&gt; , &lt;a href=&quot;iterator_traits&quot;&gt;std::iterator_traits&lt;/a&gt;&amp;lt;Iter&amp;gt;::value_type&lt;br/&gt; , &lt;a href=&quot;iterator_traits&quot;&gt;std::iterator_traits&lt;/a&gt;&amp;lt;Iter&amp;gt;::difference_type&lt;br/&gt; , &lt;a href=&quot;iterator_traits&quot;&gt;std::iterator_traits&lt;/a&gt;&amp;lt;Iter&amp;gt;::pointer&lt;br/&gt; , &lt;a href=&quot;iterator_traits&quot;&gt;std::iterator_traits&lt;/a&gt;&amp;lt;Iter&amp;gt;::reference&lt;br/&gt; &amp;gt;&lt;/code&gt;.</source>
          <target state="translated">Эти типы элементов должны быть получены путем наследования от &lt;code&gt;&lt;a href=&quot;iterator&quot;&gt;std::iterator&lt;/a&gt;&amp;lt; &lt;a href=&quot;iterator_traits&quot;&gt;std::iterator_traits&lt;/a&gt;&amp;lt;Iter&amp;gt;::iterator_category&lt;br/&gt; , &lt;a href=&quot;iterator_traits&quot;&gt;std::iterator_traits&lt;/a&gt;&amp;lt;Iter&amp;gt;::value_type&lt;br/&gt; , &lt;a href=&quot;iterator_traits&quot;&gt;std::iterator_traits&lt;/a&gt;&amp;lt;Iter&amp;gt;::difference_type&lt;br/&gt; , &lt;a href=&quot;iterator_traits&quot;&gt;std::iterator_traits&lt;/a&gt;&amp;lt;Iter&amp;gt;::pointer&lt;br/&gt; , &lt;a href=&quot;iterator_traits&quot;&gt;std::iterator_traits&lt;/a&gt;&amp;lt;Iter&amp;gt;::reference&lt;br/&gt; &amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b52b486a05c84f8a4581d34abd369500f9977646" translate="yes" xml:space="preserve">
          <source>These member types are required to be obtained by inheriting from &lt;code&gt;&lt;a href=&quot;iterator&quot;&gt;std::iterator&lt;/a&gt;&amp;lt;&lt;a href=&quot;iterator_tags&quot;&gt;std::input_iterator_tag&lt;/a&gt;, CharT, Traits::off_type, /* unspecified, usually CharT* */, CharT&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">Эти типы элементов должны быть получены путем наследования от &lt;code&gt;&lt;a href=&quot;iterator&quot;&gt;std::iterator&lt;/a&gt;&amp;lt;&lt;a href=&quot;iterator_tags&quot;&gt;std::input_iterator_tag&lt;/a&gt;, CharT, Traits::off_type, /* unspecified, usually CharT* */, CharT&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a01f1d5ca0fbf0d6be5d6ec44fedf3a57f36c70d" translate="yes" xml:space="preserve">
          <source>These member types are required to be obtained by inheriting from &lt;code&gt;&lt;a href=&quot;iterator&quot;&gt;std::iterator&lt;/a&gt;&amp;lt;&lt;a href=&quot;iterator_tags&quot;&gt;std::input_iterator_tag&lt;/a&gt;, T, Distance, const T*, const T&amp;amp;&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">Эти типы элементов должны быть получены путем наследования от &lt;code&gt;&lt;a href=&quot;iterator&quot;&gt;std::iterator&lt;/a&gt;&amp;lt;&lt;a href=&quot;iterator_tags&quot;&gt;std::input_iterator_tag&lt;/a&gt;, T, Distance, const T*, const T&amp;amp;&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ae3da083cb674670645135b104ff6e1e31af7384" translate="yes" xml:space="preserve">
          <source>These member types are required to be obtained by inheriting from &lt;code&gt;&lt;a href=&quot;iterator&quot;&gt;std::iterator&lt;/a&gt;&amp;lt;&lt;a href=&quot;iterator_tags&quot;&gt;std::output_iterator_tag&lt;/a&gt;, void, void, void, void&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">Эти типы элементов должны быть получены путем наследования от &lt;code&gt;&lt;a href=&quot;iterator&quot;&gt;std::iterator&lt;/a&gt;&amp;lt;&lt;a href=&quot;iterator_tags&quot;&gt;std::output_iterator_tag&lt;/a&gt;, void, void, void, void&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6dd91df6ca3cc382c9fe0e450bbf5c087b01c8bc" translate="yes" xml:space="preserve">
          <source>These non-member functions enable the use of &lt;code&gt;directory_iterator&lt;/code&gt;s with range-based for loops.</source>
          <target state="translated">Эти функции, не являющиеся членами, позволяют использовать &lt;code&gt;directory_iterator&lt;/code&gt; с циклами for на основе диапазона.</target>
        </trans-unit>
        <trans-unit id="d44ff77d7541183f5d7e43423582626b5049a546" translate="yes" xml:space="preserve">
          <source>These non-member functions enable the use of &lt;code&gt;recursive_directory_iterator&lt;/code&gt;s with range-based for loops.</source>
          <target state="translated">Эти функции, не являющиеся членами, позволяют использовать &lt;code&gt;recursive_directory_iterator&lt;/code&gt; с циклами for на основе диапазона.</target>
        </trans-unit>
        <trans-unit id="f216125f2ad7bca05acbed754c42e867a1a09cab" translate="yes" xml:space="preserve">
          <source>These non-member functions provide a generic interface for containers, plain arrays, and &lt;code&gt;&lt;a href=&quot;utility/initializer_list&quot;&gt;std::initializer_list&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Эти функции, не являющиеся членами, предоставляют общий интерфейс для контейнеров, простых массивов и &lt;code&gt;&lt;a href=&quot;utility/initializer_list&quot;&gt;std::initializer_list&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b6245e0fb4125a31e0f987895270819c57ced919" translate="yes" xml:space="preserve">
          <source>These objects are guaranteed to be initialized during or before the first time an object of type &lt;code&gt;&lt;a href=&quot;ios_base/init&quot;&gt;std::ios_base::Init&lt;/a&gt;&lt;/code&gt; is constructed and are available for use in the constructors and destructors of static objects with &lt;a href=&quot;../language/initialization#Non-local_variables&quot;&gt;ordered initialization&lt;/a&gt; (as long as &lt;code&gt;&amp;lt;iostream&amp;gt;&lt;/code&gt; is included before the object is defined).</source>
          <target state="translated">Эти объекты гарантированно инициализируются во время или перед первым созданием объекта типа &lt;code&gt;&lt;a href=&quot;ios_base/init&quot;&gt;std::ios_base::Init&lt;/a&gt;&lt;/code&gt; и доступны для использования в конструкторах и деструкторах статических объектов с &lt;a href=&quot;../language/initialization#Non-local_variables&quot;&gt;упорядоченной инициализацией&lt;/a&gt; (если &lt;code&gt;&amp;lt;iostream&amp;gt;&lt;/code&gt; является включается до определения объекта).</target>
        </trans-unit>
        <trans-unit id="e1ea5b16593fd62c406fa74578d8a51e69297d84" translate="yes" xml:space="preserve">
          <source>These operators are declared in the namespace &lt;code&gt;std::literals::chrono_literals&lt;/code&gt;, where both &lt;code&gt;literals&lt;/code&gt; and &lt;code&gt;chrono_literals&lt;/code&gt; are inline namespaces. Access to these operators can be gained with &lt;code&gt;using namespace std::literals&lt;/code&gt;, &lt;code&gt;using namespace std::chrono_literals&lt;/code&gt;, and &lt;code&gt;using namespace std::literals::chrono_literals&lt;/code&gt;.</source>
          <target state="translated">Эти операторы объявляются в пространстве имен &lt;code&gt;std::literals::chrono_literals&lt;/code&gt; , где оба &lt;code&gt;literals&lt;/code&gt; и &lt;code&gt;chrono_literals&lt;/code&gt; являются встроенными пространствами имен. Доступ к этим операторам может быть получен с &lt;code&gt;using namespace std::literals&lt;/code&gt; , &lt;code&gt;using namespace std::chrono_literals&lt;/code&gt; и &lt;code&gt;using namespace std::literals::chrono_literals&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c775ca0f064f8efbb0eebd72489c895fca0cd5d9" translate="yes" xml:space="preserve">
          <source>These operators are declared in the namespace &lt;code&gt;std::literals::complex_literals&lt;/code&gt;, where both &lt;code&gt;literals&lt;/code&gt; and &lt;code&gt;complex_literals&lt;/code&gt; are inline namespaces. Access to these operators can be gained with &lt;code&gt;using namespace std::literals&lt;/code&gt;, &lt;code&gt;using namespace std::complex_literals&lt;/code&gt;, and &lt;code&gt;using namespace std::literals::complex_literals&lt;/code&gt;.</source>
          <target state="translated">Эти операторы объявляются в пространстве имен &lt;code&gt;std::literals::complex_literals&lt;/code&gt; , где оба &lt;code&gt;literals&lt;/code&gt; и &lt;code&gt;complex_literals&lt;/code&gt; являются встроенными пространствами имен. Доступ к этим операторам может быть получен с &lt;code&gt;using namespace std::literals&lt;/code&gt; , &lt;code&gt;using namespace std::complex_literals&lt;/code&gt; и &lt;code&gt;using namespace std::literals::complex_literals&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="23ceae8d0ac1ad1f53f34bde5fef4212a07b1d5a" translate="yes" xml:space="preserve">
          <source>These operators are declared in the namespace &lt;code&gt;std::literals::string_literals&lt;/code&gt;, where both &lt;code&gt;literals&lt;/code&gt; and &lt;code&gt;string_literals&lt;/code&gt; are inline namespaces. Access to these operators can be gained with &lt;code&gt;using namespace std::literals&lt;/code&gt;, &lt;code&gt;using namespace std::string_literals&lt;/code&gt;, and &lt;code&gt;using namespace std::literals::string_literals&lt;/code&gt;.</source>
          <target state="translated">Эти операторы объявляются в пространстве имен &lt;code&gt;std::literals::string_literals&lt;/code&gt; , где оба &lt;code&gt;literals&lt;/code&gt; и &lt;code&gt;string_literals&lt;/code&gt; являются встроенными пространствами имен. Доступ к этим операторам может быть получен с &lt;code&gt;using namespace std::literals&lt;/code&gt; , &lt;code&gt;using namespace std::string_literals&lt;/code&gt; и &lt;code&gt;using namespace std::literals::string_literals&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="37f431af515778abb156bc8a341491c98c563acc" translate="yes" xml:space="preserve">
          <source>These operators are declared in the namespace &lt;code&gt;std::literals::string_view_literals&lt;/code&gt;, where both &lt;code&gt;literals&lt;/code&gt; and &lt;code&gt;string_view_literals&lt;/code&gt; are inline namespaces. Access to these operators can be gained with &lt;code&gt;using namespace std::literals&lt;/code&gt;, &lt;code&gt;using namespace std::string_view_literals&lt;/code&gt;, and &lt;code&gt;using namespace std::literals::string_view_literals&lt;/code&gt;.</source>
          <target state="translated">Эти операторы объявляются в пространстве имен &lt;code&gt;std::literals::string_view_literals&lt;/code&gt; , где оба &lt;code&gt;literals&lt;/code&gt; и &lt;code&gt;string_view_literals&lt;/code&gt; являются встроенными пространствами имен. Доступ к этим операторам может быть получен с &lt;code&gt;using namespace std::literals&lt;/code&gt; , &lt;code&gt;using namespace std::string_view_literals&lt;/code&gt; и &lt;code&gt;using namespace std::literals::string_view_literals&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="be85bd7cbe4be2517bbbe6791661ad5c07a4cbe3" translate="yes" xml:space="preserve">
          <source>These operators are sometimes implemented as &lt;a href=&quot;friend&quot;&gt;friend functions&lt;/a&gt;.</source>
          <target state="translated">Эти операторы иногда реализуются как &lt;a href=&quot;friend&quot;&gt;дружественные функции&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="71b614f00aac3b3aedb1ef8cf1ee4d989be39411" translate="yes" xml:space="preserve">
          <source>These operators were not &lt;code&gt;constexpr&lt;/code&gt; in C++11, this was corrected in C++14.</source>
          <target state="translated">Эти операторы не были &lt;code&gt;constexpr&lt;/code&gt; в C ++ 11, это было исправлено в C ++ 14.</target>
        </trans-unit>
        <trans-unit id="86bd9326b779710e8e7e30da617be0d3ac76c4df" translate="yes" xml:space="preserve">
          <source>These overloads do not participate in overload resolution unless the following conditions are met:</source>
          <target state="translated">Эти перегрузки не участвуют в разрешении перегрузок,если не выполняются следующие условия:</target>
        </trans-unit>
        <trans-unit id="e48cfeb3277137050ec5b9718b8d37fe7f54cb7e" translate="yes" xml:space="preserve">
          <source>These overloads only participate in overload resolution if &lt;code&gt;&lt;a href=&quot;../../types/is_default_constructible&quot;&gt;std::is_default_constructible&lt;/a&gt;&amp;lt;Deleter&amp;gt;::value&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; and &lt;code&gt;Deleter&lt;/code&gt; is not a pointer type.</source>
          <target state="translated">Эти перегрузки участвуют в разрешении перегрузки, только если &lt;code&gt;&lt;a href=&quot;../../types/is_default_constructible&quot;&gt;std::is_default_constructible&lt;/a&gt;&amp;lt;Deleter&amp;gt;::value&lt;/code&gt; имеет значение &lt;code&gt;true&lt;/code&gt; , а &lt;code&gt;Deleter&lt;/code&gt; не является типом указателя.</target>
        </trans-unit>
        <trans-unit id="88f134a2bed08d434e838bcdda34ccb397f8eca8" translate="yes" xml:space="preserve">
          <source>These overloads only participate in overload resolution if the corresponding &lt;code&gt;from_stream&lt;/code&gt; expression is well-formed.</source>
          <target state="translated">Эти перегрузки участвуют только в разрешении перегрузки, если соответствующее выражение &lt;code&gt;from_stream&lt;/code&gt; правильно сформировано.</target>
        </trans-unit>
        <trans-unit id="a2d116b1f38656e4ef14e8e4c82c85d94f84a468" translate="yes" xml:space="preserve">
          <source>These overloads only participate in overload resolution if.</source>
          <target state="translated">Эти перегрузки участвуют в разрешении перегрузки только в том случае,если.</target>
        </trans-unit>
        <trans-unit id="78f7dc8ed866031cd5d45fb8e30c10dc7cab0d38" translate="yes" xml:space="preserve">
          <source>These pair-wise comparisons are applied to all viable functions. If exactly one viable function is better than all others, overload resolution succeeds and this function is called. Otherwise, compilation fails.</source>
          <target state="translated">Эти парные сравнения применяются ко всем жизнеспособным функциям.Если ровно одна жизнеспособная функция лучше всех остальных,то разрешение перегрузки удается и эта функция вызывается.В противном случае,компиляция не удастся.</target>
        </trans-unit>
        <trans-unit id="87d3e33f926d43ebf3e0bc3d2ed5785d5f7e359f" translate="yes" xml:space="preserve">
          <source>These pointer arithmetic operators allow pointers to satisfy the &lt;a href=&quot;../named_req/randomaccessiterator&quot;&gt;LegacyRandomAccessIterator&lt;/a&gt; requirements.</source>
          <target state="translated">Эти арифметические операторы указателей позволяют указателям удовлетворять требованиям &lt;a href=&quot;../named_req/randomaccessiterator&quot;&gt;LegacyRandomAccessIterator&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="91cc6d32c62a3af187353d24cb8355a046134850" translate="yes" xml:space="preserve">
          <source>These specializations make it possible to use &lt;code&gt;&lt;a href=&quot;basic_regex&quot;&gt;std::basic_regex&lt;/a&gt;&amp;lt;char&amp;gt;&lt;/code&gt; (aka &lt;code&gt;&lt;a href=&quot;basic_regex&quot;&gt;std::regex&lt;/a&gt;&lt;/code&gt;) and &lt;code&gt;&lt;a href=&quot;basic_regex&quot;&gt;std::basic_regex&lt;/a&gt;&amp;lt;wchar_t&amp;gt;&lt;/code&gt; (aka &lt;code&gt;&lt;a href=&quot;basic_regex&quot;&gt;std::wregex&lt;/a&gt;&lt;/code&gt;). To use &lt;code&gt;&lt;a href=&quot;basic_regex&quot;&gt;std::basic_regex&lt;/a&gt;&lt;/code&gt; with other character types (for example, &lt;code&gt;char32_t&lt;/code&gt;), a user-provided trait class must be used.</source>
          <target state="translated">Эти специализации позволяют использовать &lt;code&gt;&lt;a href=&quot;basic_regex&quot;&gt;std::basic_regex&lt;/a&gt;&amp;lt;char&amp;gt;&lt;/code&gt; (он же &lt;code&gt;&lt;a href=&quot;basic_regex&quot;&gt;std::regex&lt;/a&gt;&lt;/code&gt; ) и &lt;code&gt;&lt;a href=&quot;basic_regex&quot;&gt;std::basic_regex&lt;/a&gt;&amp;lt;wchar_t&amp;gt;&lt;/code&gt; (он же &lt;code&gt;&lt;a href=&quot;basic_regex&quot;&gt;std::wregex&lt;/a&gt;&lt;/code&gt; ). Чтобы использовать &lt;code&gt;&lt;a href=&quot;basic_regex&quot;&gt;std::basic_regex&lt;/a&gt;&lt;/code&gt; с другими типами символов (например, &lt;code&gt;char32_t&lt;/code&gt; ), необходимо использовать предоставленный пользователем класс характеристик.</target>
        </trans-unit>
        <trans-unit id="8fb1d3f8496237287e2630d9516276eb8186eeef" translate="yes" xml:space="preserve">
          <source>These transformation traits were required</source>
          <target state="translated">Эти черты трансформации были необходимы</target>
        </trans-unit>
        <trans-unit id="25f1f4bdd72a09c080801d8fffb8ec4bf62a753c" translate="yes" xml:space="preserve">
          <source>These two alias templates are used by some &lt;a href=&quot;../algorithm/ranges&quot;&gt;constrained algorithms&lt;/a&gt; to avoid returning potentially dangling iterators or views.</source>
          <target state="translated">Эти два шаблона псевдонимов используются некоторыми &lt;a href=&quot;../algorithm/ranges&quot;&gt;ограниченными алгоритмами,&lt;/a&gt; чтобы избежать возврата потенциально висящих итераторов или представлений.</target>
        </trans-unit>
        <trans-unit id="c7a8b1fbd19de341e5ad49bc78a2acbfda770aec" translate="yes" xml:space="preserve">
          <source>These type transformations honor reference collapse rules:</source>
          <target state="translated">Эти типовые преобразования соблюдают правила падения ссылок:</target>
        </trans-unit>
        <trans-unit id="dbcace5dd757886bde993d55984f6189eef2a5ad" translate="yes" xml:space="preserve">
          <source>These values are constants, and do not reflect the changes to the rounding made by &lt;code&gt;&lt;a href=&quot;../../numeric/fenv/feround&quot;&gt;std::fesetround&lt;/a&gt;&lt;/code&gt;. The changed values may be obtained from &lt;code&gt;&lt;a href=&quot;../climits/flt_rounds&quot;&gt;FLT_ROUNDS&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../../numeric/fenv/feround&quot;&gt;std::fegetround&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Эти значения являются константами и не отражают изменения округления, сделанные &lt;code&gt;&lt;a href=&quot;../../numeric/fenv/feround&quot;&gt;std::fesetround&lt;/a&gt;&lt;/code&gt; . Измененные значения могут быть получены из &lt;code&gt;&lt;a href=&quot;../climits/flt_rounds&quot;&gt;FLT_ROUNDS&lt;/a&gt;&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;../../numeric/fenv/feround&quot;&gt;std::fegetround&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ce671f14cf50f53efd465a7781656ad990f4484e" translate="yes" xml:space="preserve">
          <source>They are commonly used as a convenient shortcut for long or deeply-nested namespaces.</source>
          <target state="translated">Они обычно используются в качестве удобных ярлыков для длинных или глубоко вложенных именных пространств.</target>
        </trans-unit>
        <trans-unit id="0c8a84aed3ced580611d15354b0869a722fa11d7" translate="yes" xml:space="preserve">
          <source>They are used to specify locking strategies for &lt;code&gt;&lt;a href=&quot;lock_guard&quot;&gt;std::lock_guard&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;unique_lock&quot;&gt;std::unique_lock&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;shared_lock&quot;&gt;std::shared_lock&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Они используются для указания стратегий блокировки для &lt;code&gt;&lt;a href=&quot;lock_guard&quot;&gt;std::lock_guard&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;unique_lock&quot;&gt;std::unique_lock&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;shared_lock&quot;&gt;std::shared_lock&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="11cfa3f63f9b9843169a75987765b90b1df36aef" translate="yes" xml:space="preserve">
          <source>They can also be used to implement pass-by-reference semantics in function calls:</source>
          <target state="translated">Они также могут быть использованы для реализации семантики pass-by-reference в вызовах функций:</target>
        </trans-unit>
        <trans-unit id="404264233979032de1c13fb29f764da6094435a2" translate="yes" xml:space="preserve">
          <source>Third version</source>
          <target state="translated">третий вариант</target>
        </trans-unit>
        <trans-unit id="674677ba31e30e4e6af559bc6fc67687b54c0a70" translate="yes" xml:space="preserve">
          <source>This &lt;a href=&quot;../../language/deduction_guide&quot;&gt;deduction guide&lt;/a&gt; is provided for &lt;code&gt;&lt;a href=&quot;../basic_regex&quot;&gt;std::basic_regex&lt;/a&gt;&lt;/code&gt; to allow deduction from an iterator range.</source>
          <target state="translated">Это &lt;a href=&quot;../../language/deduction_guide&quot;&gt;руководство&lt;/a&gt; по &lt;code&gt;&lt;a href=&quot;../basic_regex&quot;&gt;std::basic_regex&lt;/a&gt;&lt;/code&gt; предусмотрено для std :: basic_regex, чтобы разрешить вывод из диапазона итератора.</target>
        </trans-unit>
        <trans-unit id="4c01d9032d07a333deef547c5311682cb32b0369" translate="yes" xml:space="preserve">
          <source>This &lt;a href=&quot;../../language/deduction_guide&quot;&gt;deduction guide&lt;/a&gt; is provided for &lt;code&gt;&lt;a href=&quot;../valarray&quot;&gt;std::valarray&lt;/a&gt;&lt;/code&gt; to allow deduction from array and size (note that deduction from pointer and size is covered by the implicit guides).</source>
          <target state="translated">Это &lt;a href=&quot;../../language/deduction_guide&quot;&gt;руководство&lt;/a&gt; по &lt;code&gt;&lt;a href=&quot;../valarray&quot;&gt;std::valarray&lt;/a&gt;&lt;/code&gt; предоставляется для std :: valarray, чтобы разрешить вывод из массива и размера (обратите внимание, что вывод из указателя и размера охватывается неявными направляющими).</target>
        </trans-unit>
        <trans-unit id="080faae34fcef190f2de9f444682b5ad95d98c79" translate="yes" xml:space="preserve">
          <source>This &lt;a href=&quot;../../language/deduction_guide&quot;&gt;deduction guide&lt;/a&gt; is provided for deque to allow deduction from an iterator range. This overload only participates in overload resolution if &lt;code&gt;InputIt&lt;/code&gt; satisfies &lt;a href=&quot;../../named_req/inputiterator&quot;&gt;LegacyInputIterator&lt;/a&gt; and &lt;code&gt;Alloc&lt;/code&gt; satisfies &lt;a href=&quot;../../named_req/allocator&quot;&gt;Allocator&lt;/a&gt;.</source>
          <target state="translated">Это &lt;a href=&quot;../../language/deduction_guide&quot;&gt;руководство&lt;/a&gt; по выводу предназначено для deque, чтобы разрешить вывод из диапазона итератора. Эта перегрузка участвует только в разрешении перегрузки, если &lt;code&gt;InputIt&lt;/code&gt; удовлетворяет &lt;a href=&quot;../../named_req/inputiterator&quot;&gt;LegacyInputIterator,&lt;/a&gt; а &lt;code&gt;Alloc&lt;/code&gt; удовлетворяет &lt;a href=&quot;../../named_req/allocator&quot;&gt;Allocator&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1a6452884a208e722e9625cf9199c504d50511f4" translate="yes" xml:space="preserve">
          <source>This &lt;a href=&quot;../../language/deduction_guide&quot;&gt;deduction guide&lt;/a&gt; is provided for forward_list to allow deduction from an iterator range. This overload only participates in overload resolution if &lt;code&gt;InputIt&lt;/code&gt; satisfies &lt;a href=&quot;../../named_req/inputiterator&quot;&gt;LegacyInputIterator&lt;/a&gt; and &lt;code&gt;Alloc&lt;/code&gt; satisfies &lt;a href=&quot;../../named_req/allocator&quot;&gt;Allocator&lt;/a&gt;.</source>
          <target state="translated">Это &lt;a href=&quot;../../language/deduction_guide&quot;&gt;руководство&lt;/a&gt; по выводу предоставляется для forward_list, чтобы разрешить вывод из диапазона итератора. Эта перегрузка участвует только в разрешении перегрузки, если &lt;code&gt;InputIt&lt;/code&gt; удовлетворяет &lt;a href=&quot;../../named_req/inputiterator&quot;&gt;LegacyInputIterator,&lt;/a&gt; а &lt;code&gt;Alloc&lt;/code&gt; удовлетворяет &lt;a href=&quot;../../named_req/allocator&quot;&gt;Allocator&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="491ded200502330a3077bffc8f20aba48e33a32f" translate="yes" xml:space="preserve">
          <source>This &lt;a href=&quot;../../language/deduction_guide&quot;&gt;deduction guide&lt;/a&gt; is provided for list to allow deduction from an iterator range. This overload only participates in overload resolution if &lt;code&gt;InputIt&lt;/code&gt; satisfies &lt;a href=&quot;../../named_req/inputiterator&quot;&gt;LegacyInputIterator&lt;/a&gt; and &lt;code&gt;Alloc&lt;/code&gt; satisfies &lt;a href=&quot;../../named_req/allocator&quot;&gt;Allocator&lt;/a&gt;.</source>
          <target state="translated">Это &lt;a href=&quot;../../language/deduction_guide&quot;&gt;руководство по выводу&lt;/a&gt; предоставлено для списка, чтобы разрешить вывод из диапазона итератора. Эта перегрузка участвует только в разрешении перегрузки, если &lt;code&gt;InputIt&lt;/code&gt; удовлетворяет &lt;a href=&quot;../../named_req/inputiterator&quot;&gt;LegacyInputIterator,&lt;/a&gt; а &lt;code&gt;Alloc&lt;/code&gt; удовлетворяет &lt;a href=&quot;../../named_req/allocator&quot;&gt;Allocator&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d250c6703a67ce4010a480cdc0512de03c8d6af8" translate="yes" xml:space="preserve">
          <source>This &lt;a href=&quot;../../language/deduction_guide&quot;&gt;deduction guide&lt;/a&gt; is provided for map to allow deduction from an iterator range (overloads (1,3)) and &lt;code&gt;&lt;a href=&quot;../../utility/initializer_list&quot;&gt;std::initializer_list&lt;/a&gt;&lt;/code&gt; (overloads (2,4)). These overloads only participate in overload resolution if &lt;code&gt;InputIt&lt;/code&gt; satisfies &lt;a href=&quot;../../named_req/inputiterator&quot;&gt;LegacyInputIterator&lt;/a&gt;, &lt;code&gt;Alloc&lt;/code&gt; satisfies &lt;a href=&quot;../../named_req/allocator&quot;&gt;Allocator&lt;/a&gt;, and &lt;code&gt;Comp&lt;/code&gt; does not satisfy &lt;a href=&quot;../../named_req/allocator&quot;&gt;Allocator&lt;/a&gt;.</source>
          <target state="translated">Это &lt;a href=&quot;../../language/deduction_guide&quot;&gt;руководство по выводу&lt;/a&gt; предоставляется для карты, чтобы разрешить вывод из диапазона итератора (перегрузки (1,3)) и &lt;code&gt;&lt;a href=&quot;../../utility/initializer_list&quot;&gt;std::initializer_list&lt;/a&gt;&lt;/code&gt; (перегрузки (2,4)). Эти перегрузки участвуют в разрешении перегрузки, только если &lt;code&gt;InputIt&lt;/code&gt; удовлетворяет &lt;a href=&quot;../../named_req/inputiterator&quot;&gt;LegacyInputIterator&lt;/a&gt; , &lt;code&gt;Alloc&lt;/code&gt; удовлетворяет &lt;a href=&quot;../../named_req/allocator&quot;&gt;Allocator&lt;/a&gt; , а &lt;code&gt;Comp&lt;/code&gt; не удовлетворяет &lt;a href=&quot;../../named_req/allocator&quot;&gt;Allocator&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="472f8efb63db0b27b39e33719d752a5b58fa4ac0" translate="yes" xml:space="preserve">
          <source>This &lt;a href=&quot;../../language/deduction_guide&quot;&gt;deduction guide&lt;/a&gt; is provided for multimap to allow deduction from an iterator range (overloads (1,3)) and &lt;code&gt;&lt;a href=&quot;../../utility/initializer_list&quot;&gt;std::initializer_list&lt;/a&gt;&lt;/code&gt; (overloads (2,4)). These overloads only participate in overload resolution if &lt;code&gt;InputIt&lt;/code&gt; satisfies &lt;a href=&quot;../../named_req/inputiterator&quot;&gt;LegacyInputIterator&lt;/a&gt;, &lt;code&gt;Alloc&lt;/code&gt; satisfies &lt;a href=&quot;../../named_req/allocator&quot;&gt;Allocator&lt;/a&gt;, and &lt;code&gt;Comp&lt;/code&gt; does not satisfy &lt;a href=&quot;../../named_req/allocator&quot;&gt;Allocator&lt;/a&gt;.</source>
          <target state="translated">Это &lt;a href=&quot;../../language/deduction_guide&quot;&gt;руководство&lt;/a&gt; по выводу предназначено для мультикарты, чтобы разрешить вывод из диапазона итератора (перегрузки (1,3)) и &lt;code&gt;&lt;a href=&quot;../../utility/initializer_list&quot;&gt;std::initializer_list&lt;/a&gt;&lt;/code&gt; (перегрузки (2,4)). Эти перегрузки участвуют в разрешении перегрузки, только если &lt;code&gt;InputIt&lt;/code&gt; удовлетворяет &lt;a href=&quot;../../named_req/inputiterator&quot;&gt;LegacyInputIterator&lt;/a&gt; , &lt;code&gt;Alloc&lt;/code&gt; удовлетворяет &lt;a href=&quot;../../named_req/allocator&quot;&gt;Allocator&lt;/a&gt; , а &lt;code&gt;Comp&lt;/code&gt; не удовлетворяет &lt;a href=&quot;../../named_req/allocator&quot;&gt;Allocator&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="404371bbe2687bcdbddb8c17f22af8568b34d514" translate="yes" xml:space="preserve">
          <source>This &lt;a href=&quot;../../language/deduction_guide&quot;&gt;deduction guide&lt;/a&gt; is provided for vector to allow deduction from an iterator range. This overload only participates in overload resolution if &lt;code&gt;InputIt&lt;/code&gt; satisfies &lt;a href=&quot;../../named_req/inputiterator&quot;&gt;LegacyInputIterator&lt;/a&gt; and &lt;code&gt;Alloc&lt;/code&gt; satisfies &lt;a href=&quot;../../named_req/allocator&quot;&gt;Allocator&lt;/a&gt;.</source>
          <target state="translated">Это &lt;a href=&quot;../../language/deduction_guide&quot;&gt;руководство по вычету&lt;/a&gt; предоставляется для вектора, чтобы разрешить вычет из диапазона итератора. Эта перегрузка участвует только в разрешении перегрузки, если &lt;code&gt;InputIt&lt;/code&gt; удовлетворяет &lt;a href=&quot;../../named_req/inputiterator&quot;&gt;LegacyInputIterator,&lt;/a&gt; а &lt;code&gt;Alloc&lt;/code&gt; удовлетворяет &lt;a href=&quot;../../named_req/allocator&quot;&gt;Allocator&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9d19a67c2a590fb3edea166f3993c75495030081" translate="yes" xml:space="preserve">
          <source>This &lt;a href=&quot;cast_operator&quot;&gt;user-defined conversion function&lt;/a&gt; is only defined if the capture list of the lambda-expression is empty. It is a public, constexpr,(since C++17) non-virtual, non-explicit, const noexcept(since C++14) member function of the closure object. It is an &lt;a href=&quot;consteval&quot;&gt;immediate function&lt;/a&gt; if the function call operator of the lambda is an immediate function.(since C++20).</source>
          <target state="translated">Эта &lt;a href=&quot;cast_operator&quot;&gt;определяемая пользователем функция преобразования определяется&lt;/a&gt; только в том случае, если список захвата лямбда-выражения пуст. Это открытая, constexpr, (начиная с C ++ 17) не виртуальная, не явная, const noexcept (начиная с C ++ 14) функция-член объекта замыкания. Это &lt;a href=&quot;consteval&quot;&gt;немедленная функция,&lt;/a&gt; если оператор вызова функции лямбды является непосредственной функцией (начиная с C ++ 20).</target>
        </trans-unit>
        <trans-unit id="9dd4d9a7e5470c751564a0b43d9bb48488ca73ae" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;operator&amp;lt;&amp;lt;&lt;/code&gt; is primarily intended for debugging use. For control over formatting, use &lt;code&gt;std::chrono::format&lt;/code&gt;.</source>
          <target state="translated">Этот &lt;code&gt;operator&amp;lt;&amp;lt;&lt;/code&gt; в первую очередь предназначен для использования при отладке. Для контроля над форматированием используйте &lt;code&gt;std::chrono::format&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bdeeb8bd8306a58bb3de2426d5fca261070137d1" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;operator&amp;lt;&amp;lt;&lt;/code&gt; is primarily intended for debugging use. When used with non-default stream flags, the output may be surprising:</source>
          <target state="translated">Этот &lt;code&gt;operator&amp;lt;&amp;lt;&lt;/code&gt; в первую очередь предназначен для использования при отладке. При использовании с флагами потока не по умолчанию вывод может быть неожиданным:</target>
        </trans-unit>
        <trans-unit id="45d5bafe4e82677bb34e8489531cf8b9395463b2" translate="yes" xml:space="preserve">
          <source>This algorithm is a more general form of &lt;code&gt;&lt;a href=&quot;lower_bound&quot;&gt;std::lower_bound&lt;/a&gt;&lt;/code&gt;, which can be expressed in terms of &lt;code&gt;std::partition_point&lt;/code&gt; with the predicate &lt;code&gt;[&amp;amp;](auto const&amp;amp; e) { return e &amp;lt; value; });&lt;/code&gt;.</source>
          <target state="translated">Этот алгоритм является более общей формой &lt;code&gt;&lt;a href=&quot;lower_bound&quot;&gt;std::lower_bound&lt;/a&gt;&lt;/code&gt; , которая может быть выражена через &lt;code&gt;std::partition_point&lt;/code&gt; с помощью предиката &lt;code&gt;[&amp;amp;](auto const&amp;amp; e) { return e &amp;lt; value; });&lt;/code&gt; ,</target>
        </trans-unit>
        <trans-unit id="823f5a9d51f4a4e6c775e32f3efd9551b4b6ecbf" translate="yes" xml:space="preserve">
          <source>This algorithm is different from &lt;code&gt;&lt;a href=&quot;../utility/pair/make_pair&quot;&gt;std::make_pair&lt;/a&gt;(&lt;a href=&quot;min_element&quot;&gt;std::min_element&lt;/a&gt;(), &lt;a href=&quot;max_element&quot;&gt;std::max_element&lt;/a&gt;())&lt;/code&gt;, not only in efficiency, but also in that this algorithm finds the</source>
          <target state="translated">Этот алгоритм отличается от &lt;code&gt;&lt;a href=&quot;../utility/pair/make_pair&quot;&gt;std::make_pair&lt;/a&gt;(&lt;a href=&quot;min_element&quot;&gt;std::min_element&lt;/a&gt;(), &lt;a href=&quot;max_element&quot;&gt;std::max_element&lt;/a&gt;())&lt;/code&gt; не только эффективностью, но и тем, что этот алгоритм находит</target>
        </trans-unit>
        <trans-unit id="25bb18b7071a3878825d2611ae20fefcf112dcd2" translate="yes" xml:space="preserve">
          <source>This algorithm performs a similar task as &lt;code&gt;&lt;a href=&quot;merge&quot;&gt;std::merge&lt;/a&gt;&lt;/code&gt; does. Both consume two sorted input ranges and produce a sorted output with elements from both inputs. The difference between these two algorithms is with handling values from both input ranges which compare equivalent (see notes on &lt;a href=&quot;../named_req/lessthancomparable&quot;&gt;LessThanComparable&lt;/a&gt;). If any equivalent values appeared &lt;code&gt;n&lt;/code&gt; times in the first range and &lt;code&gt;m&lt;/code&gt; times in the second, &lt;code&gt;std::merge&lt;/code&gt; would output all &lt;code&gt;n+m&lt;/code&gt; occurrences whereas &lt;code&gt;std::set_union&lt;/code&gt; would output &lt;code&gt;&lt;a href=&quot;max&quot;&gt;std::max&lt;/a&gt;(n, m)&lt;/code&gt; ones only. So &lt;code&gt;std::merge&lt;/code&gt; outputs exactly &lt;code&gt;&lt;a href=&quot;../iterator/distance&quot;&gt;std::distance&lt;/a&gt;(first1, last1) + &lt;a href=&quot;../iterator/distance&quot;&gt;std::distance&lt;/a&gt;(first2, last2)&lt;/code&gt; values and &lt;code&gt;std::set_union&lt;/code&gt; may produce less.</source>
          <target state="translated">Этот алгоритм выполняет ту же задачу, что и &lt;code&gt;&lt;a href=&quot;merge&quot;&gt;std::merge&lt;/a&gt;&lt;/code&gt; . Оба потребляют два отсортированных входных диапазона и производят отсортированный вывод с элементами из обоих входов. Разница между этими двумя алгоритмами заключается в обработке значений из обоих входных диапазонов, которые сравнивают эквивалент (см. Примечания к &lt;a href=&quot;../named_req/lessthancomparable&quot;&gt;LessThanComparable&lt;/a&gt; ). Если какие-либо эквивалентные значения появляются &lt;code&gt;n&lt;/code&gt; раз в первом диапазоне и &lt;code&gt;m&lt;/code&gt; раз во втором, &lt;code&gt;std::merge&lt;/code&gt; выдаст все &lt;code&gt;n+m&lt;/code&gt; вхождений, тогда как &lt;code&gt;std::set_union&lt;/code&gt; выдаст только &lt;code&gt;&lt;a href=&quot;max&quot;&gt;std::max&lt;/a&gt;(n, m)&lt;/code&gt; . Таким образом, &lt;code&gt;std::merge&lt;/code&gt; выводит в точности &lt;code&gt;&lt;a href=&quot;../iterator/distance&quot;&gt;std::distance&lt;/a&gt;(first1, last1) + &lt;a href=&quot;../iterator/distance&quot;&gt;std::distance&lt;/a&gt;(first2, last2)&lt;/code&gt; и &lt;code&gt;std::set_union&lt;/code&gt; могут выдавать меньше.</target>
        </trans-unit>
        <trans-unit id="7d29fc2206a5224dabc98e893d9a9b64464432d3" translate="yes" xml:space="preserve">
          <source>This algorithm performs a similar task as &lt;code&gt;&lt;a href=&quot;set_union&quot;&gt;std::set_union&lt;/a&gt;&lt;/code&gt; does. Both consume two sorted input ranges and produce a sorted output with elements from both inputs. The difference between these two algorithms is with handling values from both input ranges which compare equivalent (see notes on &lt;a href=&quot;../named_req/lessthancomparable&quot;&gt;LessThanComparable&lt;/a&gt;). If any equivalent values appeared &lt;code&gt;n&lt;/code&gt; times in the first range and &lt;code&gt;m&lt;/code&gt; times in the second, &lt;code&gt;std::merge&lt;/code&gt; would output all &lt;code&gt;n+m&lt;/code&gt; occurrences whereas &lt;code&gt;std::set_union&lt;/code&gt; would output &lt;code&gt;&lt;a href=&quot;max&quot;&gt;std::max&lt;/a&gt;(n, m)&lt;/code&gt; ones only. So &lt;code&gt;std::merge&lt;/code&gt; outputs exactly &lt;code&gt;&lt;a href=&quot;../iterator/distance&quot;&gt;std::distance&lt;/a&gt;(first1, last1) + &lt;a href=&quot;../iterator/distance&quot;&gt;std::distance&lt;/a&gt;(first2, last2)&lt;/code&gt; values and &lt;code&gt;std::set_union&lt;/code&gt; may produce fewer.</source>
          <target state="translated">Этот алгоритм выполняет &lt;code&gt;&lt;a href=&quot;set_union&quot;&gt;std::set_union&lt;/a&gt;&lt;/code&gt; же задачу, что и std :: set_union . Оба потребляют два отсортированных входных диапазона и производят отсортированный вывод с элементами из обоих входов. Разница между этими двумя алгоритмами заключается в обработке значений из обоих входных диапазонов, которые сравнивают эквивалент (см. Примечания к &lt;a href=&quot;../named_req/lessthancomparable&quot;&gt;LessThanComparable&lt;/a&gt; ). Если какие-либо эквивалентные значения появляются &lt;code&gt;n&lt;/code&gt; раз в первом диапазоне и &lt;code&gt;m&lt;/code&gt; раз во втором, &lt;code&gt;std::merge&lt;/code&gt; выдаст все &lt;code&gt;n+m&lt;/code&gt; вхождений, тогда как &lt;code&gt;std::set_union&lt;/code&gt; выдаст только &lt;code&gt;&lt;a href=&quot;max&quot;&gt;std::max&lt;/a&gt;(n, m)&lt;/code&gt; . Таким образом, &lt;code&gt;std::merge&lt;/code&gt; выводит в точности &lt;code&gt;&lt;a href=&quot;../iterator/distance&quot;&gt;std::distance&lt;/a&gt;(first1, last1) + &lt;a href=&quot;../iterator/distance&quot;&gt;std::distance&lt;/a&gt;(first2, last2)&lt;/code&gt; и &lt;code&gt;std::set_union&lt;/code&gt; могут выдавать меньше.</target>
        </trans-unit>
        <trans-unit id="67039572a7b1266afd41cb596fd8e9903073b309" translate="yes" xml:space="preserve">
          <source>This allows &lt;a href=&quot;move_constructor&quot;&gt;move constructors&lt;/a&gt;, &lt;a href=&quot;move_operator&quot;&gt;move assignment&lt;/a&gt; operators, and other move-aware functions (e.g. &lt;code&gt;&lt;a href=&quot;../container/vector/push_back&quot;&gt;std::vector::push_back()&lt;/a&gt;&lt;/code&gt;) to be automatically selected when suitable.</source>
          <target state="translated">Это позволяет &lt;a href=&quot;move_constructor&quot;&gt;перемещение конструкторов&lt;/a&gt; , &lt;a href=&quot;move_operator&quot;&gt;присвоения движения&lt;/a&gt; операторов и другие вселения знают функции (например , &lt;code&gt;&lt;a href=&quot;../container/vector/push_back&quot;&gt;std::vector::push_back()&lt;/a&gt;&lt;/code&gt; ) , который будет выбраны автоматически , когда подходит.</target>
        </trans-unit>
        <trans-unit id="6b23439395d3de2ec476135a3b042e5160bd72c2" translate="yes" xml:space="preserve">
          <source>This allows objects of small class types, such as &lt;code&gt;&lt;a href=&quot;../numeric/complex&quot;&gt;std::complex&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;std::span&lt;/code&gt;, to be passed to or returned from functions in registers.</source>
          <target state="translated">Это позволяет объектам небольших типов классов, таким как &lt;code&gt;&lt;a href=&quot;../numeric/complex&quot;&gt;std::complex&lt;/a&gt;&lt;/code&gt; или &lt;code&gt;std::span&lt;/code&gt; , передаваться или возвращаться из функций в регистрах.</target>
        </trans-unit>
        <trans-unit id="1ba1397263db3733d0fec3f4eee183f7dd40c32d" translate="yes" xml:space="preserve">
          <source>This also makes it possible to capture by const reference, with &lt;code&gt;&amp;amp;cr = &lt;a href=&quot;../utility/as_const&quot;&gt;std::as_const&lt;/a&gt;(x)&lt;/code&gt; or similar.</source>
          <target state="translated">Это также позволяет захватывать по константной ссылке, с &lt;code&gt;&amp;amp;cr = &lt;a href=&quot;../utility/as_const&quot;&gt;std::as_const&lt;/a&gt;(x)&lt;/code&gt; или подобным.</target>
        </trans-unit>
        <trans-unit id="b270e0b13927c9c7d55e1dcef0f35f6860aa9231" translate="yes" xml:space="preserve">
          <source>This applies even to variants of non-class types:</source>
          <target state="translated">Это относится даже к вариантам неклассовых типов:</target>
        </trans-unit>
        <trans-unit id="c7b69ba009614b0512956cea74a4d37944d632b2" translate="yes" xml:space="preserve">
          <source>This applies to the members of the class template: unless the member is used in the program, it is not instantiated, and does not require a definition.</source>
          <target state="translated">Это относится к членам шаблона класса:если член не используется в программе,он не инстанцируется и не требует определения.</target>
        </trans-unit>
        <trans-unit id="afda8940351e810bc83ac7a0844c6ee697d190f3" translate="yes" xml:space="preserve">
          <source>This attribute applies to the name of the function being declared in function declarations only. The behavior is undefined if the function with this attribute actually returns.</source>
          <target state="translated">Данный атрибут применяется только к имени функции,декларируемой в объявлениях функций.Поведение не определено,если функция с данным атрибутом действительно возвращается.</target>
        </trans-unit>
        <trans-unit id="a6310c0c875c2cc4202df04650e9b8684a1ea09d" translate="yes" xml:space="preserve">
          <source>This attribute can appear in the declaration of the following entities:</source>
          <target state="translated">Данный атрибут может появиться в объявлении следующих сущностей:</target>
        </trans-unit>
        <trans-unit id="48e9f5d2fd561ba7f787f00554eb0339866d9697" translate="yes" xml:space="preserve">
          <source>This attribute is allowed in declarations of the following names or entities:</source>
          <target state="translated">Данный атрибут разрешен в декларациях следующих названий или сущностей:</target>
        </trans-unit>
        <trans-unit id="bc9a88af611a842f4ad52d91eb1d0dc9725b08e4" translate="yes" xml:space="preserve">
          <source>This attribute may appear in two situations:</source>
          <target state="translated">Этот атрибут может появиться в двух ситуациях:</target>
        </trans-unit>
        <trans-unit id="492617afde39ac181a5c63ce324178dcbd2c9236" translate="yes" xml:space="preserve">
          <source>This attribute must appear on the first declaration of a function or one of its parameters in any translation unit. If it is not used on the first declaration of a function or one of its parameters in another translation unit, the program is ill-formed; no diagnostic required.</source>
          <target state="translated">Этот атрибут должен появляться при первом объявлении функции или одного из ее параметров в любом модуле трансляции.Если он не используется на первом объявлении функции или одного из ее параметров в другом модуле трансляции,то программа плохо сформирована;диагностика не требуется.</target>
        </trans-unit>
        <trans-unit id="da819209a9e30721dffd50c194d372495640b66c" translate="yes" xml:space="preserve">
          <source>This class defines the type of objects thrown as exceptions to report errors from the regular expressions library.</source>
          <target state="translated">Данный класс определяет тип объектов,выбрасываемых в качестве исключений для сообщения об ошибках из библиотеки регулярных выражений.</target>
        </trans-unit>
        <trans-unit id="d05fe9ff7a9efe7a6be4213effba38b5678ca3d8" translate="yes" xml:space="preserve">
          <source>This class is designed for use as key in associative containers, both ordered and unordered.</source>
          <target state="translated">Данный класс предназначен для использования в качестве ключа в ассоциативных контейнерах,как упорядоченных,так и неупорядоченных.</target>
        </trans-unit>
        <trans-unit id="c77922f02193571f4c08570b0423206a1a325b4d" translate="yes" xml:space="preserve">
          <source>This class is used to ensure that the default C++ streams (&lt;code&gt;&lt;a href=&quot;../cin&quot;&gt;std::cin&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../cout&quot;&gt;std::cout&lt;/a&gt;&lt;/code&gt;, etc.) are properly initialized and destructed. The class tracks how many instances of it are created and initializes the C++ streams when the first instance is constructed as well as flushes the output streams when the last instance is destructed.</source>
          <target state="translated">Этот класс используется для обеспечения правильной инициализации и уничтожения потоков C ++ по умолчанию ( &lt;code&gt;&lt;a href=&quot;../cin&quot;&gt;std::cin&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../cout&quot;&gt;std::cout&lt;/a&gt;&lt;/code&gt; и т. Д.). Класс отслеживает, сколько его экземпляров создано, и инициализирует потоки C ++ при создании первого экземпляра, а также сбрасывает выходные потоки при разрушении последнего экземпляра.</target>
        </trans-unit>
        <trans-unit id="4782fa86482a6f5000533d5566f5443e1b31c285" translate="yes" xml:space="preserve">
          <source>This class template is the preferred comparison predicate when building associative containers with &lt;code&gt;&lt;a href=&quot;shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;weak_ptr&quot;&gt;std::weak_ptr&lt;/a&gt;&lt;/code&gt; as keys, that is,</source>
          <target state="translated">Этот шаблон класса является предпочтительным предикатом сравнения при создании ассоциативных контейнеров с &lt;code&gt;&lt;a href=&quot;shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;weak_ptr&quot;&gt;std::weak_ptr&lt;/a&gt;&lt;/code&gt; качестве ключей, то есть</target>
        </trans-unit>
        <trans-unit id="d4129ee928b19fe777216b3fc0a11eb88a14da35" translate="yes" xml:space="preserve">
          <source>This class template makes the implicit character conversion functionality of &lt;code&gt;&lt;a href=&quot;../io/basic_filebuf&quot;&gt;std::basic_filebuf&lt;/a&gt;&lt;/code&gt; available for any &lt;code&gt;&lt;a href=&quot;../io/basic_streambuf&quot;&gt;std::basic_streambuf&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Этот шаблон класса делает функцию неявного преобразования символов &lt;code&gt;&lt;a href=&quot;../io/basic_filebuf&quot;&gt;std::basic_filebuf&lt;/a&gt;&lt;/code&gt; доступной для любого &lt;code&gt;&lt;a href=&quot;../io/basic_streambuf&quot;&gt;std::basic_streambuf&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="67af0e94f21d7e3028f080552ccfa30f81f3903f" translate="yes" xml:space="preserve">
          <source>This classification allows the following errors to be detected at the point of template definition (rather than instantiation):</source>
          <target state="translated">Такая классификация позволяет обнаружить следующие ошибки в точке определения шаблона (а не его конкретизации):</target>
        </trans-unit>
        <trans-unit id="58ce9513b35dc96e87c0d70ac154af849efb1443" translate="yes" xml:space="preserve">
          <source>This constructor does not participate in overload resolution if &lt;code&gt;std::decay_t&amp;lt;Function&amp;gt;&lt;/code&gt; is the same type as &lt;code&gt;&lt;a href=&quot;../thread&quot;&gt;std::thread&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Этот конструктор не участвует в разрешении перегрузки, если &lt;code&gt;std::decay_t&amp;lt;Function&amp;gt;&lt;/code&gt; того же типа, что и &lt;code&gt;&lt;a href=&quot;../thread&quot;&gt;std::thread&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a905969e8e69e6e88d275ad307f8717581731297" translate="yes" xml:space="preserve">
          <source>This constructor has the same effect as &lt;code&gt;deque(static_cast&amp;lt;size_type&amp;gt;(first), static_cast&amp;lt;value_type&amp;gt;(last), a)&lt;/code&gt; if &lt;code&gt;InputIt&lt;/code&gt; is an integral type.</source>
          <target state="translated">Этот конструктор имеет тот же эффект, что и &lt;code&gt;deque(static_cast&amp;lt;size_type&amp;gt;(first), static_cast&amp;lt;value_type&amp;gt;(last), a)&lt;/code&gt; если &lt;code&gt;InputIt&lt;/code&gt; является целочисленным типом.</target>
        </trans-unit>
        <trans-unit id="7a2d779c18396eab1ee0e06cc486a3335e7edd14" translate="yes" xml:space="preserve">
          <source>This constructor has the same effect as &lt;code&gt;forward_list(static_cast&amp;lt;size_type&amp;gt;(first), static_cast&amp;lt;value_type&amp;gt;(last), a)&lt;/code&gt; if &lt;code&gt;InputIt&lt;/code&gt; is an integral type.</source>
          <target state="translated">Этот конструктор имеет тот же эффект, что и &lt;code&gt;forward_list(static_cast&amp;lt;size_type&amp;gt;(first), static_cast&amp;lt;value_type&amp;gt;(last), a)&lt;/code&gt; если &lt;code&gt;InputIt&lt;/code&gt; является целочисленным типом.</target>
        </trans-unit>
        <trans-unit id="11411ad8214fe6e6c7202887522fc136fe3e90db" translate="yes" xml:space="preserve">
          <source>This constructor has the same effect as &lt;code&gt;list(static_cast&amp;lt;size_type&amp;gt;(first), static_cast&amp;lt;value_type&amp;gt;(last), a)&lt;/code&gt; if &lt;code&gt;InputIt&lt;/code&gt; is an integral type.</source>
          <target state="translated">Этот конструктор имеет тот же эффект, что и &lt;code&gt;list(static_cast&amp;lt;size_type&amp;gt;(first), static_cast&amp;lt;value_type&amp;gt;(last), a)&lt;/code&gt; если &lt;code&gt;InputIt&lt;/code&gt; является целочисленным типом.</target>
        </trans-unit>
        <trans-unit id="d0215f7826bd287562237b0c5f6bbd13fcaf0661" translate="yes" xml:space="preserve">
          <source>This constructor has the same effect as &lt;code&gt;vector(static_cast&amp;lt;size_type&amp;gt;(first), static_cast&amp;lt;value_type&amp;gt;(last), a)&lt;/code&gt; if &lt;code&gt;InputIt&lt;/code&gt; is an integral type.</source>
          <target state="translated">Этот конструктор имеет тот же эффект, что и &lt;code&gt;vector(static_cast&amp;lt;size_type&amp;gt;(first), static_cast&amp;lt;value_type&amp;gt;(last), a)&lt;/code&gt; если &lt;code&gt;InputIt&lt;/code&gt; является целочисленным типом.</target>
        </trans-unit>
        <trans-unit id="16d9b8332d1923e6161015fdc9a2cff3bdfaa0b6" translate="yes" xml:space="preserve">
          <source>This constructor is &lt;code&gt;constexpr&lt;/code&gt; if every operation it performs is &lt;code&gt;constexpr&lt;/code&gt;. For the empty tuple &lt;code&gt;&lt;a href=&quot;../tuple&quot;&gt;std::tuple&lt;/a&gt;&amp;lt;&amp;gt;&lt;/code&gt;, it is &lt;code&gt;constexpr&lt;/code&gt;.</source>
          <target state="translated">Этот конструктор является &lt;code&gt;constexpr&lt;/code&gt; , если каждая выполняемая им операция является &lt;code&gt;constexpr&lt;/code&gt; . Для пустого кортежа &lt;code&gt;&lt;a href=&quot;../tuple&quot;&gt;std::tuple&lt;/a&gt;&amp;lt;&amp;gt;&lt;/code&gt; это &lt;code&gt;constexpr&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="39b96837fbee6ff8b11f2afbe55d19be8b5237f0" translate="yes" xml:space="preserve">
          <source>This constructor is &lt;code&gt;explicit&lt;/code&gt; if and only if &lt;code&gt;&lt;a href=&quot;../../types/is_convertible&quot;&gt;std::is_convertible&lt;/a&gt;&amp;lt;const Ti&amp;amp;, Ti&amp;gt;::value&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt; for at least one &lt;code&gt;i&lt;/code&gt;.</source>
          <target state="translated">Этот конструктор является &lt;code&gt;explicit&lt;/code&gt; тогда и только тогда, когда &lt;code&gt;&lt;a href=&quot;../../types/is_convertible&quot;&gt;std::is_convertible&lt;/a&gt;&amp;lt;const Ti&amp;amp;, Ti&amp;gt;::value&lt;/code&gt; имеет значение &lt;code&gt;false&lt;/code&gt; по крайней мере для одного &lt;code&gt;i&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="533bf2fceb953a9339da3a3efe2403151289bf62" translate="yes" xml:space="preserve">
          <source>This constructor is &lt;code&gt;explicit&lt;/code&gt; if and only if &lt;code&gt;&lt;a href=&quot;../../types/is_convertible&quot;&gt;std::is_convertible_v&lt;/a&gt;&amp;lt;U&amp;amp;&amp;amp;, T&amp;gt;&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">Этот конструктор является &lt;code&gt;explicit&lt;/code&gt; тогда и только тогда, когда &lt;code&gt;&lt;a href=&quot;../../types/is_convertible&quot;&gt;std::is_convertible_v&lt;/a&gt;&amp;lt;U&amp;amp;&amp;amp;, T&amp;gt;&lt;/code&gt; равно &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="956eea7f4a03a0995417ca7671e86890da8c691a" translate="yes" xml:space="preserve">
          <source>This constructor is &lt;code&gt;explicit&lt;/code&gt; if and only if &lt;code&gt;&lt;a href=&quot;../../types/is_convertible&quot;&gt;std::is_convertible_v&lt;/a&gt;&amp;lt;U1&amp;amp;&amp;amp;, first_type&amp;gt;&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../../types/is_convertible&quot;&gt;std::is_convertible_v&lt;/a&gt;&amp;lt;U2&amp;amp;&amp;amp;, second_type&amp;gt;&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">Этот конструктор является &lt;code&gt;explicit&lt;/code&gt; тогда и только тогда, когда &lt;code&gt;&lt;a href=&quot;../../types/is_convertible&quot;&gt;std::is_convertible_v&lt;/a&gt;&amp;lt;U1&amp;amp;&amp;amp;, first_type&amp;gt;&lt;/code&gt; равно &lt;code&gt;false&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;../../types/is_convertible&quot;&gt;std::is_convertible_v&lt;/a&gt;&amp;lt;U2&amp;amp;&amp;amp;, second_type&amp;gt;&lt;/code&gt; равно &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="00d14d163d5ca5d7a526cb55477d4d3d44718aa1" translate="yes" xml:space="preserve">
          <source>This constructor is &lt;code&gt;explicit&lt;/code&gt; if and only if &lt;code&gt;&lt;a href=&quot;../../types/is_convertible&quot;&gt;std::is_convertible_v&lt;/a&gt;&amp;lt;const U&amp;amp;, T&amp;gt;&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">Этот конструктор является &lt;code&gt;explicit&lt;/code&gt; тогда и только тогда, когда &lt;code&gt;&lt;a href=&quot;../../types/is_convertible&quot;&gt;std::is_convertible_v&lt;/a&gt;&amp;lt;const U&amp;amp;, T&amp;gt;&lt;/code&gt; равно &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="703819705f083463e0d7af074684609042e9b532" translate="yes" xml:space="preserve">
          <source>This constructor is &lt;code&gt;explicit&lt;/code&gt; if and only if &lt;code&gt;&lt;a href=&quot;../../types/is_convertible&quot;&gt;std::is_convertible_v&lt;/a&gt;&amp;lt;const U1&amp;amp;, first_type&amp;gt;&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../../types/is_convertible&quot;&gt;std::is_convertible_v&lt;/a&gt;&amp;lt;const U2&amp;amp;, second_type&amp;gt;&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">Этот конструктор является &lt;code&gt;explicit&lt;/code&gt; тогда и только тогда, когда &lt;code&gt;&lt;a href=&quot;../../types/is_convertible&quot;&gt;std::is_convertible_v&lt;/a&gt;&amp;lt;const U1&amp;amp;, first_type&amp;gt;&lt;/code&gt; равен &lt;code&gt;false&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;../../types/is_convertible&quot;&gt;std::is_convertible_v&lt;/a&gt;&amp;lt;const U2&amp;amp;, second_type&amp;gt;&lt;/code&gt; равен &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b2d388bc3de25d32e823ab3902c5cb2c7f0bb128" translate="yes" xml:space="preserve">
          <source>This constructor is &lt;code&gt;explicit&lt;/code&gt; if and only if &lt;code&gt;&lt;a href=&quot;../../types/is_convertible&quot;&gt;std::is_convertible_v&lt;/a&gt;&amp;lt;const first_type&amp;amp;, first_type&amp;gt;&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../../types/is_convertible&quot;&gt;std::is_convertible_v&lt;/a&gt;&amp;lt;const second_type&amp;amp;, second_type&amp;gt;&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">Этот конструктор является &lt;code&gt;explicit&lt;/code&gt; тогда и только тогда, когда &lt;code&gt;&lt;a href=&quot;../../types/is_convertible&quot;&gt;std::is_convertible_v&lt;/a&gt;&amp;lt;const first_type&amp;amp;, first_type&amp;gt;&lt;/code&gt; равен &lt;code&gt;false&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;../../types/is_convertible&quot;&gt;std::is_convertible_v&lt;/a&gt;&amp;lt;const second_type&amp;amp;, second_type&amp;gt;&lt;/code&gt; равен &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7c083a7d9073cd96386cc41c8aa08c4631002fa1" translate="yes" xml:space="preserve">
          <source>This constructor is &lt;code&gt;explicit&lt;/code&gt; if and only if either &lt;code&gt;first_type&lt;/code&gt; or &lt;code&gt;second_type&lt;/code&gt; is not implicitly default-constructible.</source>
          <target state="translated">Этот конструктор является &lt;code&gt;explicit&lt;/code&gt; тогда и только тогда, когда &lt;code&gt;first_type&lt;/code&gt; или &lt;code&gt;second_type&lt;/code&gt; неявно не конструируются по умолчанию.</target>
        </trans-unit>
        <trans-unit id="9e3f4b55350fb3f6d920bcec2b1f50c5260e2934" translate="yes" xml:space="preserve">
          <source>This constructor is ill-formed if &lt;code&gt;Deleter&lt;/code&gt; is of pointer or reference type.</source>
          <target state="translated">Этот конструктор плохо сформирован, если &lt;code&gt;Deleter&lt;/code&gt; имеет указатель или ссылочный тип.</target>
        </trans-unit>
        <trans-unit id="8f4ffe9c6a9e19f1b0de1f70aa1c6912c5d13790" translate="yes" xml:space="preserve">
          <source>This constructor only participates in overload resolution if &lt;code&gt;InputIt&lt;/code&gt; satisfies &lt;a href=&quot;../../named_req/inputiterator&quot;&gt;LegacyInputIterator&lt;/a&gt;.</source>
          <target state="translated">Этот конструктор участвует только в разрешении перегрузки, если &lt;code&gt;InputIt&lt;/code&gt; удовлетворяет &lt;a href=&quot;../../named_req/inputiterator&quot;&gt;LegacyInputIterator&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6429d3c8a00cca9524476fd5e7bc85b284721fa1" translate="yes" xml:space="preserve">
          <source>This constructor only participates in overload resolution if all of the following is true:</source>
          <target state="translated">Этот конструктор участвует в разрешении перегрузки только в том случае,если все нижеследующее верно:</target>
        </trans-unit>
        <trans-unit id="5189004f2798523a38b087278bd624f438a82960" translate="yes" xml:space="preserve">
          <source>This constructor participates in overload resolution if and only if &lt;code&gt;&lt;a href=&quot;../../types/is_constructible&quot;&gt;std::is_constructible_v&lt;/a&gt;&amp;lt;first_type, U1&amp;amp;&amp;amp;&amp;gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../../types/is_constructible&quot;&gt;std::is_constructible_v&lt;/a&gt;&amp;lt;second_type, U2&amp;amp;&amp;amp;&amp;gt;&lt;/code&gt; are both &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">Этот конструктор участвует в разрешении перегрузки, если и только если &lt;code&gt;&lt;a href=&quot;../../types/is_constructible&quot;&gt;std::is_constructible_v&lt;/a&gt;&amp;lt;first_type, U1&amp;amp;&amp;amp;&amp;gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;../../types/is_constructible&quot;&gt;std::is_constructible_v&lt;/a&gt;&amp;lt;second_type, U2&amp;amp;&amp;amp;&amp;gt;&lt;/code&gt; оба имеют значение &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4726fe3e137ecc9cfdc444c3524298098da680a8" translate="yes" xml:space="preserve">
          <source>This constructor participates in overload resolution if and only if &lt;code&gt;&lt;a href=&quot;../../types/is_constructible&quot;&gt;std::is_constructible_v&lt;/a&gt;&amp;lt;first_type, const U1&amp;amp;&amp;gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../../types/is_constructible&quot;&gt;std::is_constructible_v&lt;/a&gt;&amp;lt;second_type, const U2&amp;amp;&amp;gt;&lt;/code&gt; are both &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">Этот конструктор участвует в разрешении перегрузки, если и только если &lt;code&gt;&lt;a href=&quot;../../types/is_constructible&quot;&gt;std::is_constructible_v&lt;/a&gt;&amp;lt;first_type, const U1&amp;amp;&amp;gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;../../types/is_constructible&quot;&gt;std::is_constructible_v&lt;/a&gt;&amp;lt;second_type, const U2&amp;amp;&amp;gt;&lt;/code&gt; имеют значение &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b97d7fbb9211117804e8e5c015e20e35239347ae" translate="yes" xml:space="preserve">
          <source>This constructor participates in overload resolution if and only if &lt;code&gt;&lt;a href=&quot;../../types/is_copy_constructible&quot;&gt;std::is_copy_constructible_v&lt;/a&gt;&amp;lt;first_type&amp;gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../../types/is_copy_constructible&quot;&gt;std::is_copy_constructible_v&lt;/a&gt;&amp;lt;second_type&amp;gt;&lt;/code&gt; are both &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">Этот конструктор участвует в разрешении перегрузки тогда и только тогда, когда &lt;code&gt;&lt;a href=&quot;../../types/is_copy_constructible&quot;&gt;std::is_copy_constructible_v&lt;/a&gt;&amp;lt;first_type&amp;gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;../../types/is_copy_constructible&quot;&gt;std::is_copy_constructible_v&lt;/a&gt;&amp;lt;second_type&amp;gt;&lt;/code&gt; имеют значение &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="efe7ac6a6eaa86bb5c97cb1a9afabf3305f77bd2" translate="yes" xml:space="preserve">
          <source>This constructor participates in overload resolution if and only if &lt;code&gt;&lt;a href=&quot;../../types/is_default_constructible&quot;&gt;std::is_default_constructible_v&lt;/a&gt;&amp;lt;first_type&amp;gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../../types/is_default_constructible&quot;&gt;std::is_default_constructible_v&lt;/a&gt;&amp;lt;second_type&amp;gt;&lt;/code&gt; are both &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">Этот конструктор участвует в разрешении перегрузки тогда и только тогда, когда &lt;code&gt;&lt;a href=&quot;../../types/is_default_constructible&quot;&gt;std::is_default_constructible_v&lt;/a&gt;&amp;lt;first_type&amp;gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;../../types/is_default_constructible&quot;&gt;std::is_default_constructible_v&lt;/a&gt;&amp;lt;second_type&amp;gt;&lt;/code&gt; оба имеют значение &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a9636e46cd99b7aa6a5346c674ec8170c547d2f3" translate="yes" xml:space="preserve">
          <source>This container is an aggregate type with the same semantics as a struct holding a &lt;a href=&quot;../language/array&quot;&gt;C-style array&lt;/a&gt;&lt;code&gt;T[N]&lt;/code&gt; as its only non-static data member. Unlike a C-style array, it doesn't decay to &lt;code&gt;T*&lt;/code&gt; automatically. As an aggregate type, it can be initialized with &lt;a href=&quot;../language/aggregate_initialization&quot;&gt;aggregate-initialization&lt;/a&gt; given at most &lt;code&gt;N&lt;/code&gt; initializers that are convertible to &lt;code&gt;T&lt;/code&gt;: &lt;code&gt;std::array&amp;lt;int, 3&amp;gt; a = {1,2,3};&lt;/code&gt;.</source>
          <target state="translated">Этот контейнер является агрегатным типом с той же семантикой, что и структура, содержащая &lt;a href=&quot;../language/array&quot;&gt;массив в стиле C &lt;/a&gt; &lt;code&gt;T[N]&lt;/code&gt; как его единственный нестатический элемент данных. В отличие от массива в стиле C, он не распадается на &lt;code&gt;T*&lt;/code&gt; автоматически. Как агрегатный тип, он может быть инициализирован с помощью &lt;a href=&quot;../language/aggregate_initialization&quot;&gt;агрегатной инициализации,&lt;/a&gt; заданной максимум для &lt;code&gt;N&lt;/code&gt; инициализаторов, которые могут быть преобразованы в &lt;code&gt;T&lt;/code&gt; : &lt;code&gt;std::array&amp;lt;int, 3&amp;gt; a = {1,2,3};&lt;/code&gt; ,</target>
        </trans-unit>
        <trans-unit id="2bf0aa51a2fd1da025ddbd712b50083980038a0d" translate="yes" xml:space="preserve">
          <source>This conversion models the act of reading a value from a memory location into a CPU register.</source>
          <target state="translated">Это преобразование моделирует акт чтения значения из ячейки памяти в регистр процессора.</target>
        </trans-unit>
        <trans-unit id="486e8ea678d2260d566d72fdb476e2364e350e4a" translate="yes" xml:space="preserve">
          <source>This declaration may declare &lt;a href=&quot;static&quot;&gt;static&lt;/a&gt; and non-static &lt;a href=&quot;data_members&quot;&gt;data members&lt;/a&gt; and &lt;a href=&quot;member_functions&quot;&gt;member functions&lt;/a&gt;, member &lt;a href=&quot;typedef&quot;&gt;typedefs&lt;/a&gt;, member &lt;a href=&quot;enum&quot;&gt;enumerations&lt;/a&gt;, and &lt;a href=&quot;nested_classes&quot;&gt;nested classes&lt;/a&gt;. It may also be a &lt;a href=&quot;friend&quot;&gt;friend declaration&lt;/a&gt;.</source>
          <target state="translated">Это объявление может объявлять &lt;a href=&quot;static&quot;&gt;статические&lt;/a&gt; и нестатические &lt;a href=&quot;data_members&quot;&gt;члены&lt;/a&gt; - данные и &lt;a href=&quot;member_functions&quot;&gt;функции-&lt;/a&gt; члены, определения &lt;a href=&quot;typedef&quot;&gt;типов&lt;/a&gt; членов, &lt;a href=&quot;enum&quot;&gt;перечисления&lt;/a&gt; членов и &lt;a href=&quot;nested_classes&quot;&gt;вложенные классы&lt;/a&gt; . Это также может быть &lt;a href=&quot;friend&quot;&gt;объявление друга&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="790f40ee47446044b6d23c3286797ccea1e6e155" translate="yes" xml:space="preserve">
          <source>This declaration must declare a constructor, destructor, or user-defined type &lt;a href=&quot;cast_operator&quot;&gt;conversion function&lt;/a&gt;. It can only be used as part of a &lt;a href=&quot;templates&quot;&gt;template declaration&lt;/a&gt;, &lt;a href=&quot;template_specialization&quot;&gt;explicit specialization&lt;/a&gt;, or explicit instantiation.</source>
          <target state="translated">Это объявление должно объявлять конструктор, деструктор или пользовательскую &lt;a href=&quot;cast_operator&quot;&gt;функцию преобразования&lt;/a&gt; типов . Он может использоваться только как часть &lt;a href=&quot;templates&quot;&gt;объявления шаблона&lt;/a&gt; , &lt;a href=&quot;template_specialization&quot;&gt;явной специализации&lt;/a&gt; или явной реализации.</target>
        </trans-unit>
        <trans-unit id="b21c4afc7d9f44a231494182ce929f3873dbd60e" translate="yes" xml:space="preserve">
          <source>This definition is treated as a definition of a namespace with unique name and a</source>
          <target state="translated">Это определение рассматривается как определение пространства имен с уникальным именем и a</target>
        </trans-unit>
        <trans-unit id="f5d805f6f41052ad913a678cd3a3f6f56d5cd6ca" translate="yes" xml:space="preserve">
          <source>This destruction is empty: the members of this &lt;code&gt;basic_streambuf&lt;/code&gt; (the pointers and the locale) are destructed in accordance with the usual object destruction sequence after this destructor returns. However, since it is declared public virtual, it allows the objects that are derived from &lt;code&gt;std::basic_streambuf&lt;/code&gt; to be deleted through a pointer to base class.</source>
          <target state="translated">Это уничтожение пусто: члены этого &lt;code&gt;basic_streambuf&lt;/code&gt; (указатели и локаль) уничтожаются в соответствии с обычной последовательностью уничтожения объектов после возвращения этого деструктора. Однако, поскольку он объявлен как общедоступный виртуальный, он позволяет удалять объекты, производные от &lt;code&gt;std::basic_streambuf&lt;/code&gt; , через указатель на базовый класс.</target>
        </trans-unit>
        <trans-unit id="566d630222759bb1a22c3aebcb32a3363161c684" translate="yes" xml:space="preserve">
          <source>This destructor does not perform any operation on the underlying stream buffer (&lt;code&gt;rdbuf()&lt;/code&gt;): the destructors of the derived streams such as &lt;code&gt;&lt;a href=&quot;../basic_fstream&quot;&gt;std::basic_fstream&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../basic_stringstream&quot;&gt;std::basic_stringstream&lt;/a&gt;&lt;/code&gt; are responsible for calling the destructors of the stream buffers.</source>
          <target state="translated">Этот деструктор не выполняет никаких операций с нижележащим буфером потока ( &lt;code&gt;rdbuf()&lt;/code&gt; ): деструкторы производных потоков, такие как &lt;code&gt;&lt;a href=&quot;../basic_fstream&quot;&gt;std::basic_fstream&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;../basic_stringstream&quot;&gt;std::basic_stringstream&lt;/a&gt;&lt;/code&gt; , отвечают за вызов деструкторов потоковых буферов.</target>
        </trans-unit>
        <trans-unit id="131f49f893678b58d7f7539c38777963fe7160b1" translate="yes" xml:space="preserve">
          <source>This destructor does not perform any operation on the underlying streambuffer (&lt;code&gt;rdbuf()&lt;/code&gt;): the destructors of the derived input streams such as &lt;code&gt;&lt;a href=&quot;../basic_ifstream&quot;&gt;std::basic_ifstream&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../basic_istringstream&quot;&gt;std::basic_istringstream&lt;/a&gt;&lt;/code&gt; are responsible for calling the destructors of the streambuffers.</source>
          <target state="translated">Этот деструктор не выполняет никаких операций с нижележащим потоковым буфером ( &lt;code&gt;rdbuf()&lt;/code&gt; ): деструкторы производных входных потоков, такие как &lt;code&gt;&lt;a href=&quot;../basic_ifstream&quot;&gt;std::basic_ifstream&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;../basic_istringstream&quot;&gt;std::basic_istringstream&lt;/a&gt;&lt;/code&gt; , отвечают за вызов деструкторов потоковых буферов.</target>
        </trans-unit>
        <trans-unit id="1b99959c6ca09f07071faff9ad3d0e8aafb11452" translate="yes" xml:space="preserve">
          <source>This destructor is &lt;code&gt;virtual&lt;/code&gt; because the base class destructor, &lt;a href=&quot;../ios_base/~ios_base&quot;&gt;&lt;code&gt;ios_base::~ios_base&lt;/code&gt;&lt;/a&gt; is virtual.</source>
          <target state="translated">Этот деструктор является &lt;code&gt;virtual&lt;/code&gt; поскольку деструктор базового класса &lt;a href=&quot;../ios_base/~ios_base&quot;&gt; &lt;code&gt;ios_base::~ios_base&lt;/code&gt; &lt;/a&gt; является виртуальным.</target>
        </trans-unit>
        <trans-unit id="e7593a44c2d3c23ae4a80ac5cc6624863832641b" translate="yes" xml:space="preserve">
          <source>This destructor is trivial if &lt;code&gt;&lt;a href=&quot;../../types/is_destructible&quot;&gt;std::is_trivially_destructible_v&lt;/a&gt;&amp;lt;T_i&amp;gt;&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; for all &lt;code&gt;T_i&lt;/code&gt; in &lt;code&gt;Types...&lt;/code&gt;</source>
          <target state="translated">Этот деструктор тривиален, если &lt;code&gt;&lt;a href=&quot;../../types/is_destructible&quot;&gt;std::is_trivially_destructible_v&lt;/a&gt;&amp;lt;T_i&amp;gt;&lt;/code&gt; имеет значение &lt;code&gt;true&lt;/code&gt; для всех &lt;code&gt;Types...&lt;/code&gt; &lt;code&gt;T_i&lt;/code&gt; в типах ...</target>
        </trans-unit>
        <trans-unit id="6df8c5501bb72be0811f778d216bdc599b74a410" translate="yes" xml:space="preserve">
          <source>This destructor is typically called by the destructor of &lt;code&gt;&lt;a href=&quot;../strstream&quot;&gt;std::strstream&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Этот деструктор обычно вызывается деструктором &lt;code&gt;&lt;a href=&quot;../strstream&quot;&gt;std::strstream&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bb5e9bde864785c69be529012ab31825d767db62" translate="yes" xml:space="preserve">
          <source>This directive is used by some automatic code generation tools which produce C++ source files from a file written in another language. In that case, &lt;code&gt;#line&lt;/code&gt; directives may be inserted in the generated C++ file referencing line numbers and the file name of the original (human-editable) source file.</source>
          <target state="translated">Эта директива используется некоторыми инструментами автоматической генерации кода, которые создают исходные файлы C ++ из файла, написанного на другом языке. В этом случае директивы &lt;code&gt;#line&lt;/code&gt; могут быть вставлены в сгенерированный файл C ++, ссылаясь на номера строк и имя файла исходного (редактируемого человеком) исходного файла.</target>
        </trans-unit>
        <trans-unit id="2160c0fc9b1d6f99749583e4a431b1db823b687a" translate="yes" xml:space="preserve">
          <source>This element acts as a placeholder; attempting to access it results in undefined behavior.</source>
          <target state="translated">Этот элемент действует как заполнитель;попытка доступа к нему приводит к неопределенному поведению.</target>
        </trans-unit>
        <trans-unit id="e1d92326ee038395416fb47c3929e52bba4b4b4a" translate="yes" xml:space="preserve">
          <source>This example demonistrates how to apply monetary formatting rules of another language without changing the rest of the locale.</source>
          <target state="translated">Этот пример демонистрирует,как применять правила монетарного форматирования на другом языке без изменения остальной локали.</target>
        </trans-unit>
        <trans-unit id="699b77b3a2b284060799465bf0aef3eb6c604dfb" translate="yes" xml:space="preserve">
          <source>This example demonistrates how to apply numeric punctuation rules of another language without changing the rest of the locale.</source>
          <target state="translated">Этот пример демонистрирует,как применять правила числовой пунктуации другого языка без изменения остальной локали.</target>
        </trans-unit>
        <trans-unit id="03a8f1b5ffb01757d8be09e129dc569a5400d2fc" translate="yes" xml:space="preserve">
          <source>This example demonstrates a situation where sequential ordering is necessary. Any other ordering may trigger the assert because it would be possible for the threads &lt;code&gt;c&lt;/code&gt; and &lt;code&gt;d&lt;/code&gt; to observe changes to the atomics &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; in opposite order.</source>
          <target state="translated">Этот пример демонстрирует ситуацию, когда необходимо последовательное упорядочение. Любое другое упорядочение может инициировать утверждение, потому что потоки &lt;code&gt;c&lt;/code&gt; и &lt;code&gt;d&lt;/code&gt; могли бы наблюдать изменения в атомиках &lt;code&gt;x&lt;/code&gt; и &lt;code&gt;y&lt;/code&gt; в противоположном порядке.</target>
        </trans-unit>
        <trans-unit id="6c12e1f3885c29be2bfca0cfe53639bf6159022e" translate="yes" xml:space="preserve">
          <source>This example demonstrates dependency-ordered synchronization for pointer-mediated publication: the integer data is not related to the pointer to string by a data-dependency relationship, thus its value is undefined in the consumer.</source>
          <target state="translated">В данном примере показана синхронизация по зависимостям для публикации,опосредованной указателем:целочисленные данные не связаны с указателем на строку зависимостю от данных,поэтому их значение у потребителя не определено.</target>
        </trans-unit>
        <trans-unit id="6b01d954af477e04c266f80ede6e5280ccdc0a60" translate="yes" xml:space="preserve">
          <source>This example demonstrates perfect forwarding of the parameter(s) to the argument of the constructor of class &lt;code&gt;T&lt;/code&gt;. Also, perfect forwarding of parameter packs is demonstrated.</source>
          <target state="translated">Этот пример демонстрирует прекрасную пересылку параметра (ей) аргумент конструктора класса &lt;code&gt;T&lt;/code&gt; . Также демонстрируется идеальная пересылка пакетов параметров.</target>
        </trans-unit>
        <trans-unit id="41d2d00ba30c148282801448fd5c841e57daf05e" translate="yes" xml:space="preserve">
          <source>This example demonstrates reading a GB18030-encoded file using the codecvt facet from a GB18030-aware locale.</source>
          <target state="translated">Этот пример демонстрирует чтение файла в кодировке GB18030 с использованием граней кодека из локали GB18030.</target>
        </trans-unit>
        <trans-unit id="4d303a5fae16ce79fa6d0c697ce2d0fc19b5301e" translate="yes" xml:space="preserve">
          <source>This example demonstrates the Euler's identity ei&amp;pi;</source>
          <target state="translated">Этот пример демонстрирует тождество Эйлера</target>
        </trans-unit>
        <trans-unit id="076b866beacb08cccde9a7cbeb026a03c41cdec2" translate="yes" xml:space="preserve">
          <source>This example demonstrates the difference between clock() time and real time.</source>
          <target state="translated">Этот пример демонстрирует разницу между временем с помощью функции clock()и реальным временем.</target>
        </trans-unit>
        <trans-unit id="ec322c19fb258d9310f125341429ba2dbaa4630e" translate="yes" xml:space="preserve">
          <source>This example displays information about the execution time of a function call:</source>
          <target state="translated">В данном примере отображается информация о времени выполнения вызова функции:</target>
        </trans-unit>
        <trans-unit id="b6a1d0dea16b8362b800d36d34e475e44374f92b" translate="yes" xml:space="preserve">
          <source>This example measures the execution time of a function.</source>
          <target state="translated">В данном примере измеряется время выполнения функции.</target>
        </trans-unit>
        <trans-unit id="f9f8065b3b5128d3a408cb9f21a45bf456306b8f" translate="yes" xml:space="preserve">
          <source>This example prints current time using the &quot;C&quot; locale with the time_put facet replaced by various time_put_byname facets.</source>
          <target state="translated">В этом примере текущее время печатается с использованием локали &quot;С&quot;,при этом грань time_put заменяется разными гранями time_put_byname.</target>
        </trans-unit>
        <trans-unit id="4b380662a79a86a43a8e6ddbc4fae89b7137cd02" translate="yes" xml:space="preserve">
          <source>This example shows a 10 seconds block.</source>
          <target state="translated">В этом примере показан 10-секундный блок.</target>
        </trans-unit>
        <trans-unit id="68e2616f4fe4dbb587d170dace9a4de7c97af570" translate="yes" xml:space="preserve">
          <source>This example shows how &lt;code&gt;lock&lt;/code&gt; and &lt;code&gt;unlock&lt;/code&gt; can be used to protect shared data.</source>
          <target state="translated">В этом примере показано, как &lt;code&gt;lock&lt;/code&gt; и &lt;code&gt;unlock&lt;/code&gt; могут использоваться для защиты общих данных.</target>
        </trans-unit>
        <trans-unit id="b265f51b6f5d54fac0a395f6360e177b329bb440" translate="yes" xml:space="preserve">
          <source>This example shows how &lt;code&gt;promise&amp;lt;int&amp;gt;&lt;/code&gt; can be used as signals between threads.</source>
          <target state="translated">Этот пример показывает, как &lt;code&gt;promise&amp;lt;int&amp;gt;&lt;/code&gt; может использоваться в качестве сигналов между потоками.</target>
        </trans-unit>
        <trans-unit id="7e9ee0c7c7b464f5720460296151cb05bd7054a5" translate="yes" xml:space="preserve">
          <source>This example shows how &lt;code&gt;promise&amp;lt;void&amp;gt;&lt;/code&gt; can be used as signals between threads.</source>
          <target state="translated">Этот пример показывает, как &lt;code&gt;promise&amp;lt;void&amp;gt;&lt;/code&gt; может использоваться в качестве сигналов между потоками.</target>
        </trans-unit>
        <trans-unit id="9cc1e77d4a4ec9dcaa9ce1202b289473c0fe3f32" translate="yes" xml:space="preserve">
          <source>This example shows how a &lt;code&gt;mutex&lt;/code&gt; can be used to protect a &lt;code&gt;&lt;a href=&quot;../container/map&quot;&gt;std::map&lt;/a&gt;&lt;/code&gt; shared between two threads.</source>
          <target state="translated">В этом примере показано, как &lt;code&gt;mutex&lt;/code&gt; может использоваться для защиты &lt;code&gt;&lt;a href=&quot;../container/map&quot;&gt;std::map&lt;/a&gt;&lt;/code&gt; совместно используемой двумя потоками.</target>
        </trans-unit>
        <trans-unit id="648fa6a16a6dcfeed9894c57ffbd6224f1ffea42" translate="yes" xml:space="preserve">
          <source>This example shows how to define several custom duration types and convert between types:</source>
          <target state="translated">Этот пример показывает,как определить несколько пользовательских типов продолжительности и конвертировать между типами:</target>
        </trans-unit>
        <trans-unit id="0af6770609a4caa5cf880a836ce6717cfed6d527" translate="yes" xml:space="preserve">
          <source>This example shows how to pass a lambda to a generic algorithm and how objects resulting from a lambda declaration can be stored in &lt;code&gt;&lt;a href=&quot;../utility/functional/function&quot;&gt;std::function&lt;/a&gt;&lt;/code&gt; objects.</source>
          <target state="translated">В этом примере показано, как передать лямбду в общий алгоритм и как объекты, являющиеся результатом лямбда-объявления, могут храниться в объектах &lt;code&gt;&lt;a href=&quot;../utility/functional/function&quot;&gt;std::function&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ccfdcc1737a5e9e6732e2a5414a8ae4ca8c5cc92" translate="yes" xml:space="preserve">
          <source>This example shows how to use a namespace to create a class that already has been named in the &lt;code&gt;std&lt;/code&gt; namespace.</source>
          <target state="translated">В этом примере показано, как использовать пространство имен для создания класса, который уже был назван в пространстве имен &lt;code&gt;std&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4812778eaab911430b4291ca314167dcaef2c221" translate="yes" xml:space="preserve">
          <source>This exception is thrown by &lt;code&gt;&lt;a href=&quot;../../utility/bitset/bitset&quot;&gt;std::bitset::bitset&lt;/a&gt;&lt;/code&gt;, and the &lt;code&gt;&lt;a href=&quot;../../string/basic_string/stol&quot;&gt;std::stoi&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../../string/basic_string/stof&quot;&gt;std::stof&lt;/a&gt;&lt;/code&gt; families of functions.</source>
          <target state="translated">Это исключение вызывается &lt;code&gt;&lt;a href=&quot;../../utility/bitset/bitset&quot;&gt;std::bitset::bitset&lt;/a&gt;&lt;/code&gt; и семействами функций &lt;code&gt;&lt;a href=&quot;../../string/basic_string/stol&quot;&gt;std::stoi&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;../../string/basic_string/stof&quot;&gt;std::stof&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a6233e2c685f108dd3cbe5ebed91c5d014b2b2b2" translate="yes" xml:space="preserve">
          <source>This exception is thrown by &lt;code&gt;std::chrono::time_zone::to_sys&lt;/code&gt; and functions that call it (such as the constructors of &lt;code&gt;std::chrono::zoned_time&lt;/code&gt; that takes a &lt;code&gt;std::chrono::local_time&lt;/code&gt;).</source>
          <target state="translated">Это исключение &lt;code&gt;std::chrono::time_zone::to_sys&lt;/code&gt; и вызывающими его функциями (такими как конструкторы &lt;code&gt;std::chrono::zoned_time&lt;/code&gt; которые принимают &lt;code&gt;std::chrono::local_time&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="d06332298cae245fc7de591665ed289988d734a8" translate="yes" xml:space="preserve">
          <source>This exception is thrown by member functions of &lt;code&gt;&lt;a href=&quot;../../string/basic_string&quot;&gt;std::basic_string&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../../container/vector/reserve&quot;&gt;std::vector::reserve&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Это исключение &lt;code&gt;&lt;a href=&quot;../../string/basic_string&quot;&gt;std::basic_string&lt;/a&gt;&lt;/code&gt; функциями-членами std :: basic_string и &lt;code&gt;&lt;a href=&quot;../../container/vector/reserve&quot;&gt;std::vector::reserve&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="61d73663b9152dc36fe73750ad1a87fd639e49c2" translate="yes" xml:space="preserve">
          <source>This feature is used in template metaprogramming.</source>
          <target state="translated">Эта функция используется при метапрограммировании шаблонов.</target>
        </trans-unit>
        <trans-unit id="ebe57327a03912c16a8791570ac9fd18d3a3f421" translate="yes" xml:space="preserve">
          <source>This form automatically provides &lt;a href=&quot;exceptions&quot;&gt;strong exception guarantee&lt;/a&gt;, but prohibits resource reuse.</source>
          <target state="translated">Эта форма автоматически предоставляет &lt;a href=&quot;exceptions&quot;&gt;строгую гарантию исключений&lt;/a&gt; , но запрещает повторное использование ресурсов.</target>
        </trans-unit>
        <trans-unit id="a5c081dc7229ad13536ca7204c599487bcfa19aa" translate="yes" xml:space="preserve">
          <source>This function (for double argument) behaves as if (except for the freedom to not raise &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INEXACT&lt;/a&gt;&lt;/code&gt;) implemented by the following code:</source>
          <target state="translated">Эта функция (для двойного аргумента) ведет себя так, как будто (за исключением свободы не вызывать &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INEXACT&lt;/a&gt;&lt;/code&gt; ), реализованной следующим кодом:</target>
        </trans-unit>
        <trans-unit id="6a68eec804ec3c10883600f6bcfaeb90b1f9c1d6" translate="yes" xml:space="preserve">
          <source>This function and the related types are deprecated as of C++11 in favor of the more general &lt;code&gt;&lt;a href=&quot;function&quot;&gt;std::function&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;ref&quot;&gt;std::ref&lt;/a&gt;&lt;/code&gt;, both of which create callable adapter-compatible function objects from plain functions.</source>
          <target state="translated">Начиная с C ++ 11 эта функция и связанные с ней типы устарели в пользу более общих &lt;code&gt;&lt;a href=&quot;function&quot;&gt;std::function&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;ref&quot;&gt;std::ref&lt;/a&gt;&lt;/code&gt; , которые создают вызываемые адаптером совместимые функциональные объекты из простых функций.</target>
        </trans-unit>
        <trans-unit id="8855f9b9dc1d262207716dd8128c053ea2ad8bb0" translate="yes" xml:space="preserve">
          <source>This function and the related types were deprecated in C++11 and removed in C++17 in favor of the more general &lt;code&gt;&lt;a href=&quot;mem_fn&quot;&gt;std::mem_fn&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;bind&quot;&gt;std::bind&lt;/a&gt;&lt;/code&gt;, both of which create callable adapter-compatible function objects from member functions.</source>
          <target state="translated">Эта функция и связанные с ней типы устарели в C ++ 11 и удалены в C ++ 17 в пользу более общих &lt;code&gt;&lt;a href=&quot;mem_fn&quot;&gt;std::mem_fn&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;bind&quot;&gt;std::bind&lt;/a&gt;&lt;/code&gt; , оба из которых создают вызываемые адаптером совместимые функциональные объекты из функций-членов.</target>
        </trans-unit>
        <trans-unit id="9d11c6f40fc460580b4545f369d83a5f3011308f" translate="yes" xml:space="preserve">
          <source>This function attempts to allocate a temporary buffer equal in size to the sequence to be sorted. If the allocation fails, the less efficient algorithm is chosen.</source>
          <target state="translated">Данная функция пытается выделить временный буфер,равный по размеру сортируемой последовательности.В случае неудачного выделения выбирается менее эффективный алгоритм.</target>
        </trans-unit>
        <trans-unit id="0dc2280353aa9f39b639bbe5806d955bd65f2c7d" translate="yes" xml:space="preserve">
          <source>This function attempts to allocate a temporary buffer. If the allocation fails, the less efficient algorithm is chosen.</source>
          <target state="translated">Эта функция пытается выделить временный буфер.Если выделение не удается,выбирается менее эффективный алгоритм.</target>
        </trans-unit>
        <trans-unit id="56dabe59df1e13c9e7227a371ae542e03583d74a" translate="yes" xml:space="preserve">
          <source>This function behaves as if implemented as follows:</source>
          <target state="translated">Эта функция ведет себя так,как если бы она была реализована следующим образом:</target>
        </trans-unit>
        <trans-unit id="e024c278b12913b9314d8bc74236e17366fbdd60" translate="yes" xml:space="preserve">
          <source>This function behaves as if it reads the characters sequentially and stops as soon as a matching character is found: if the array pointed to by &lt;code&gt;ptr&lt;/code&gt; is smaller than &lt;code&gt;count&lt;/code&gt;, but the match is found within the array, the behavior is well-defined.</source>
          <target state="translated">Эта функция ведет себя так, как будто она читает символы последовательно и останавливается, как только найден соответствующий символ: если массив, на который указывает &lt;code&gt;ptr&lt;/code&gt; , меньше чем &lt;code&gt;count&lt;/code&gt; , но совпадение найдено в массиве, поведение четко определено.</target>
        </trans-unit>
        <trans-unit id="70a20794d71c34f9a147e7b2e7b15ccb7dd382d5" translate="yes" xml:space="preserve">
          <source>This function can be used when implementing &lt;a href=&quot;../language/move_operator&quot;&gt;move assignment operators&lt;/a&gt; and &lt;a href=&quot;../language/move_constructor&quot;&gt;move constructors&lt;/a&gt;:</source>
          <target state="translated">Эта функция может быть использована при выполнении &lt;a href=&quot;../language/move_operator&quot;&gt;операторов присваивания движения&lt;/a&gt; и &lt;a href=&quot;../language/move_constructor&quot;&gt;перемещение конструкторов&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="074233c87f0a8381f8c33e772677b1882b2b89cc" translate="yes" xml:space="preserve">
          <source>This function can make a write position available if the stringbuf is open for output (&lt;code&gt;mode &amp;amp; ios_base::out) != 0&lt;/code&gt;): in this case, it reallocates (or initially allocates) the buffer big enough to hold the entire current buffer plus at least one more character. If the stringbuf is also open for input (&lt;code&gt;(mode &amp;amp; ios_base::in) != 0&lt;/code&gt;), then &lt;code&gt;overflow&lt;/code&gt; also increases the size of the get area by moving &lt;code&gt;egptr()&lt;/code&gt; to point just past the new write position.</source>
          <target state="translated">Эта функция может сделать позицию записи доступной, если stringbuf открыт для вывода ( &lt;code&gt;mode &amp;amp; ios_base::out) != 0&lt;/code&gt; ): в этом случае она перераспределяет (или изначально выделяет) буфер, достаточно большой, чтобы вместить весь текущий буфер плюс хотя бы еще один персонаж. Если stringbuf также открыт для ввода ( &lt;code&gt;(mode &amp;amp; ios_base::in) != 0&lt;/code&gt; ), то &lt;code&gt;overflow&lt;/code&gt; также увеличивает размер области получения, перемещая &lt;code&gt;egptr()&lt;/code&gt; чтобы указывать сразу после новой позиции записи.</target>
        </trans-unit>
        <trans-unit id="80dad3848a318d7ecb43c15430bc70acc0b353eb" translate="yes" xml:space="preserve">
          <source>This function detects the sign bit of zeroes, infinities, and NaNs. Along with &lt;code&gt;&lt;a href=&quot;copysign&quot;&gt;std::copysign&lt;/a&gt;&lt;/code&gt;, std::signbit is one of the only two portable ways to examine the sign of a NaN.</source>
          <target state="translated">Эта функция обнаруживает знаковый бит нулей, бесконечностей и NaN. Наряду с &lt;code&gt;&lt;a href=&quot;copysign&quot;&gt;std::copysign&lt;/a&gt;&lt;/code&gt; , std :: signbit является одним из двух переносимых способов проверки знака NaN.</target>
        </trans-unit>
        <trans-unit id="8e1aa01daec415e7f5af69e6b0d04848557bd2e6" translate="yes" xml:space="preserve">
          <source>This function does not call constructors or initialize memory in any way. There are no ready-to-use smart pointers that could guarantee that the matching deallocation function is called. The preferred method of memory allocation in C++ is using RAII-ready functions &lt;code&gt;&lt;a href=&quot;../unique_ptr/make_unique&quot;&gt;std::make_unique&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../shared_ptr/make_shared&quot;&gt;std::make_shared&lt;/a&gt;&lt;/code&gt;, container constructors, etc, and, in low-level library code, &lt;a href=&quot;../../language/new&quot;&gt;new-expression&lt;/a&gt;.</source>
          <target state="translated">Эта функция не вызывает конструкторы и не инициализирует память каким-либо образом. Не существует готовых к использованию интеллектуальных указателей, которые могли бы гарантировать вызов соответствующей функции освобождения. Предпочтительным методом выделения памяти в C ++ является использование готовых к RAII функций &lt;code&gt;&lt;a href=&quot;../unique_ptr/make_unique&quot;&gt;std::make_unique&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../shared_ptr/make_shared&quot;&gt;std::make_shared&lt;/a&gt;&lt;/code&gt; , конструкторов контейнеров и т. Д., А в низкоуровневом коде библиотеки - &lt;a href=&quot;../../language/new&quot;&gt;new-expression&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d4587b2ca7a4f0c1305b825fddf8669b0a594052" translate="yes" xml:space="preserve">
          <source>This function does not commit any changes to the filesystem.</source>
          <target state="translated">Эта функция не фиксирует никаких изменений в файловой системе.</target>
        </trans-unit>
        <trans-unit id="9a9157bc8e19134921e346295ad23635f0edc637" translate="yes" xml:space="preserve">
          <source>This function does not participate in overload resolution unless &lt;code&gt;&lt;a href=&quot;../../types/is_swappable&quot;&gt;std::is_swappable&lt;/a&gt;&amp;lt;D&amp;gt;::value&lt;/code&gt; is true.</source>
          <target state="translated">Эта функция не участвует в разрешении перегрузки, если только &lt;code&gt;&lt;a href=&quot;../../types/is_swappable&quot;&gt;std::is_swappable&lt;/a&gt;&amp;lt;D&amp;gt;::value&lt;/code&gt; имеет значение true.</target>
        </trans-unit>
        <trans-unit id="34f86c4c962be5f53b674478758ba7b4aac25784" translate="yes" xml:space="preserve">
          <source>This function does not participate in overload resolution unless &lt;code&gt;&lt;a href=&quot;../../types/is_swappable&quot;&gt;std::is_swappable_v&lt;/a&gt;&amp;lt;Ti&amp;gt;&lt;/code&gt; is true for all i from 0 to &lt;code&gt;sizeof...(Types)&lt;/code&gt;.</source>
          <target state="translated">Эта функция не участвует в разрешении перегрузки, если только &lt;code&gt;&lt;a href=&quot;../../types/is_swappable&quot;&gt;std::is_swappable_v&lt;/a&gt;&amp;lt;Ti&amp;gt;&lt;/code&gt; является истинным для всех i от 0 до &lt;code&gt;sizeof...(Types)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="430ec4ee0ab3ae68ef199618d00c231487c566a4" translate="yes" xml:space="preserve">
          <source>This function does not participate in overload resolution unless &lt;code&gt;&lt;a href=&quot;../../types/is_swappable&quot;&gt;std::is_swappable_v&lt;/a&gt;&amp;lt;first_type&amp;gt; &amp;amp;&amp;amp; &lt;a href=&quot;../../types/is_swappable&quot;&gt;std::is_swappable_v&lt;/a&gt;&amp;lt;second_type&amp;gt;&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">Эта функция не участвует в разрешении перегрузки, если только &lt;code&gt;&lt;a href=&quot;../../types/is_swappable&quot;&gt;std::is_swappable_v&lt;/a&gt;&amp;lt;first_type&amp;gt; &amp;amp;&amp;amp; &lt;a href=&quot;../../types/is_swappable&quot;&gt;std::is_swappable_v&lt;/a&gt;&amp;lt;second_type&amp;gt;&lt;/code&gt; имеет значение &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="93f49364b5d0b6ce3643e79ff41e9aa02af91573" translate="yes" xml:space="preserve">
          <source>This function exploits the signature compatibility between hinted insert for associative containers (such as &lt;code&gt;&lt;a href=&quot;../../container/set/insert&quot;&gt;std::set::insert&lt;/a&gt;&lt;/code&gt;) and positional insert for sequential containers (such as &lt;code&gt;&lt;a href=&quot;../../container/vector/insert&quot;&gt;std::vector::insert&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">Эта функция использует совместимость сигнатур между подсказкой вставки для ассоциативных контейнеров (например, &lt;code&gt;&lt;a href=&quot;../../container/set/insert&quot;&gt;std::set::insert&lt;/a&gt;&lt;/code&gt; ) и позиционной вставкой для последовательных контейнеров (например, &lt;code&gt;&lt;a href=&quot;../../container/vector/insert&quot;&gt;std::vector::insert&lt;/a&gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="77f1becd52cdb4bb82d9005b4cfb7fd4243343b4" translate="yes" xml:space="preserve">
          <source>This function has no effect. Memory used by a &lt;code&gt;monotonic_buffer_resource&lt;/code&gt;, as its name indicates, increases monotonically until the resource is destroyed.</source>
          <target state="translated">Эта функция не имеет никакого эффекта. Память, используемая ресурсом &lt;code&gt;monotonic_buffer_resource&lt;/code&gt; , как указывает его имя, монотонно увеличивается, пока ресурс не будет уничтожен.</target>
        </trans-unit>
        <trans-unit id="003c7fca2e592f4d453e6d2795ce41a60cc8ae9a" translate="yes" xml:space="preserve">
          <source>This function is allowed to fail spuriously and return &lt;code&gt;false&lt;/code&gt; even if the mutex is not currenly exclusively locked by any other thread.</source>
          <target state="translated">Эта функция допускает случайные сбои и возвращает &lt;code&gt;false&lt;/code&gt; , даже если мьютекс не заблокирован в данный момент исключительно каким-либо другим потоком.</target>
        </trans-unit>
        <trans-unit id="4aff8f3ce667147891a0800fe1ffe344229b2457" translate="yes" xml:space="preserve">
          <source>This function is allowed to fail spuriously and return &lt;code&gt;false&lt;/code&gt; even if the mutex is not currently locked by any other thread.</source>
          <target state="translated">Эта функция допускает случайный сбой и возвращает &lt;code&gt;false&lt;/code&gt; , даже если мьютекс в данный момент не заблокирован каким-либо другим потоком.</target>
        </trans-unit>
        <trans-unit id="581170c63a0c34f4d8ef486e52f25f659195a185" translate="yes" xml:space="preserve">
          <source>This function is an &lt;a href=&quot;consteval&quot;&gt;immediate function&lt;/a&gt; if the function call operator (or specialization, for generic lambdas) is an immediate function.</source>
          <target state="translated">Эта функция является &lt;a href=&quot;consteval&quot;&gt;непосредственной функцией,&lt;/a&gt; если оператор вызова функции (или специализация для универсальных лямбд) является непосредственной функцией.</target>
        </trans-unit>
        <trans-unit id="7d1b9d31c1cd20909db730ecb0adb4933d6936b7" translate="yes" xml:space="preserve">
          <source>This function is called (through &lt;code&gt;&lt;a href=&quot;../allocator_traits&quot;&gt;std::allocator_traits&lt;/a&gt;&lt;/code&gt;) by any allocator-aware object, such as &lt;code&gt;&lt;a href=&quot;../../container/vector&quot;&gt;std::pmr::vector&lt;/a&gt;&lt;/code&gt; (or another &lt;code&gt;&lt;a href=&quot;../../container/vector&quot;&gt;std::vector&lt;/a&gt;&lt;/code&gt; that was given a &lt;code&gt;std::std::polymorphic_allocator&lt;/code&gt; as the allocator to use).</source>
          <target state="translated">Эта функция вызывается (через &lt;code&gt;&lt;a href=&quot;../allocator_traits&quot;&gt;std::allocator_traits&lt;/a&gt;&lt;/code&gt; ) любым объектом, распознающим распределитель, таким как &lt;code&gt;&lt;a href=&quot;../../container/vector&quot;&gt;std::pmr::vector&lt;/a&gt;&lt;/code&gt; (или другим &lt;code&gt;&lt;a href=&quot;../../container/vector&quot;&gt;std::vector&lt;/a&gt;&lt;/code&gt; которому в качестве распределителя используется &lt;code&gt;std::std::polymorphic_allocator&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="f22521ea8de0d211401620c2c0ceeebcc98c2413" translate="yes" xml:space="preserve">
          <source>This function is called (through &lt;code&gt;&lt;a href=&quot;../allocator_traits&quot;&gt;std::allocator_traits&lt;/a&gt;&lt;/code&gt;) by any allocator-aware object, such as &lt;code&gt;&lt;a href=&quot;../../container/vector&quot;&gt;std::vector&lt;/a&gt;&lt;/code&gt;, that was given a &lt;code&gt;&lt;a href=&quot;../scoped_allocator_adaptor&quot;&gt;std::scoped_allocator_adaptor&lt;/a&gt;&lt;/code&gt; as the allocator to use. Since &lt;code&gt;inner_allocator&lt;/code&gt; is itself an instance of &lt;code&gt;&lt;a href=&quot;../scoped_allocator_adaptor&quot;&gt;std::scoped_allocator_adaptor&lt;/a&gt;&lt;/code&gt;, this function will also be called when the allocator-aware objects constructed through this function start constructing their own members.</source>
          <target state="translated">Эта функция вызывается (через &lt;code&gt;&lt;a href=&quot;../allocator_traits&quot;&gt;std::allocator_traits&lt;/a&gt;&lt;/code&gt; ) любым объектом, осведомленным о распределении, таким как &lt;code&gt;&lt;a href=&quot;../../container/vector&quot;&gt;std::vector&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../scoped_allocator_adaptor&quot;&gt;std::scoped_allocator_adaptor&lt;/a&gt;&lt;/code&gt; в качестве распределителя назначен std :: scoped_allocator_adaptor . Поскольку &lt;code&gt;inner_allocator&lt;/code&gt; сам по себе является экземпляром &lt;code&gt;&lt;a href=&quot;../scoped_allocator_adaptor&quot;&gt;std::scoped_allocator_adaptor&lt;/a&gt;&lt;/code&gt; , эта функция также будет вызываться, когда объекты, осведомленные о распределителе, созданные с помощью этой функции, начнут создавать свои собственные члены.</target>
        </trans-unit>
        <trans-unit id="1604a10d0bd65894de0fdd375bd44a25850704e0" translate="yes" xml:space="preserve">
          <source>This function is called automatically when swapping &lt;code&gt;&lt;a href=&quot;../basic_fstream&quot;&gt;std::fstream&lt;/a&gt;&lt;/code&gt; objects, it is rarely necessary to call it directly.</source>
          <target state="translated">Эта функция вызывается автоматически при &lt;code&gt;&lt;a href=&quot;../basic_fstream&quot;&gt;std::fstream&lt;/a&gt;&lt;/code&gt; объектов std :: fstream , редко требуется вызывать ее напрямую.</target>
        </trans-unit>
        <trans-unit id="0e78d40edd5ecace775e3b468b3346c7031f470e" translate="yes" xml:space="preserve">
          <source>This function is called automatically when swapping &lt;code&gt;&lt;a href=&quot;../basic_stringstream&quot;&gt;std::stringstream&lt;/a&gt;&lt;/code&gt; objects, it is rarely necessary to call it directly.</source>
          <target state="translated">Эта функция вызывается автоматически при обмене объектами &lt;code&gt;&lt;a href=&quot;../basic_stringstream&quot;&gt;std::stringstream&lt;/a&gt;&lt;/code&gt; , редко нужно вызывать ее напрямую.</target>
        </trans-unit>
        <trans-unit id="c4734f8a6748c0cb4415534ce967c7c8880cdda2" translate="yes" xml:space="preserve">
          <source>This function is called by &lt;code&gt;std::basic_filebuf::close()&lt;/code&gt; and in other situations when finalizing a state-dependent multibyte character sequence.</source>
          <target state="translated">Эта функция вызывается &lt;code&gt;std::basic_filebuf::close()&lt;/code&gt; и в других ситуациях при финализации зависимой от состояния последовательности многобайтовых символов.</target>
        </trans-unit>
        <trans-unit id="32de367add154511d8a09e86e9af636ea74ff7b5" translate="yes" xml:space="preserve">
          <source>This function is called by the constructor of &lt;code&gt;&lt;a href=&quot;../../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&lt;/code&gt; when given an &lt;code&gt;&lt;a href=&quot;../future_errc&quot;&gt;std::future_errc&lt;/a&gt;&lt;/code&gt; argument.</source>
          <target state="translated">Эта функция вызывается конструктором &lt;code&gt;&lt;a href=&quot;../../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&lt;/code&gt; при &lt;code&gt;&lt;a href=&quot;../future_errc&quot;&gt;std::future_errc&lt;/a&gt;&lt;/code&gt; аргумента std :: future_errc .</target>
        </trans-unit>
        <trans-unit id="cbcb817100be7c6ebcd72951487118723a0a15af" translate="yes" xml:space="preserve">
          <source>This function is called by the copy constructors of all standard library containers. It allows the allocator used by the constructor's argument to become aware that the container is being copied and modify state if necessary.</source>
          <target state="translated">Эта функция вызывается конструкторами копирования всех стандартных контейнеров библиотек.Она позволяет аллокатору,используемому аргументом конструктора,узнать,что контейнер копируется,и при необходимости изменить его состояние.</target>
        </trans-unit>
        <trans-unit id="bfb34e88abba67d43669caa31797e35aed808cba" translate="yes" xml:space="preserve">
          <source>This function is called by the destructor of basic_fstream when the stream object goes out of scope and is not usually invoked directly.</source>
          <target state="translated">Эта функция вызывается деструктором basic_fstream,когда объект потока выходит за рамки видимости и обычно не вызывается напрямую.</target>
        </trans-unit>
        <trans-unit id="9586654e6d5f24f563ef041033abacd3e6aaef3e" translate="yes" xml:space="preserve">
          <source>This function is called by the destructor of basic_ifstream when the stream object goes out of scope and is not usually invoked directly.</source>
          <target state="translated">Эта функция вызывается деструктором basic_ifstream,когда объект потока выходит за рамки видимости и обычно не вызывается напрямую.</target>
        </trans-unit>
        <trans-unit id="0b0b9fa6d17fdf350f225d78773a873a4f6a210f" translate="yes" xml:space="preserve">
          <source>This function is called by the destructor of basic_ofstream when the stream object goes out of scope and is not usually invoked directly.</source>
          <target state="translated">Эта функция вызывается деструктором basic_ofstream,когда объект потока выходит за рамки видимости и обычно не вызывается напрямую.</target>
        </trans-unit>
        <trans-unit id="ae182d564b01a9cc3f1cbb5dd2383b385c515a22" translate="yes" xml:space="preserve">
          <source>This function is constexpr if the function call operator (or specialization, for generic lambdas) is constexpr.</source>
          <target state="translated">Эта функция является constexpr,если оператор вызова функции (или специализации,для родовых лямбд)является constexpr.</target>
        </trans-unit>
        <trans-unit id="6cb839c1449d28abb8b1ad7d5627544f12403184" translate="yes" xml:space="preserve">
          <source>This function is designed to be called multiple times to obtain successive tokens from the same string.</source>
          <target state="translated">Эта функция предназначена для многократного вызова для получения последовательных токенов из одной и той же строки.</target>
        </trans-unit>
        <trans-unit id="db0f3821e4deee5da8554e13cdcbbb92c017d0a9" translate="yes" xml:space="preserve">
          <source>This function is designed to be called multiples times to obtain successive tokens from the same string.</source>
          <target state="translated">Эта функция предназначена для того,чтобы вызывать кратные числа для получения последовательных токенов из одной и той же строки.</target>
        </trans-unit>
        <trans-unit id="776743886aba3fc5ea926a51a096528c0531353d" translate="yes" xml:space="preserve">
          <source>This function is destructive: it writes the &lt;code&gt;'\0'&lt;/code&gt; characters in the elements of the string &lt;code&gt;str&lt;/code&gt;. In particular, a &lt;a href=&quot;../../language/string_literal&quot;&gt;string literal&lt;/a&gt; cannot be used as the first argument of &lt;code&gt;strtok&lt;/code&gt;.</source>
          <target state="translated">Эта функция деструктивна: она записывает символы &lt;code&gt;'\0'&lt;/code&gt; в элементах строки &lt;code&gt;str&lt;/code&gt; . В частности, &lt;a href=&quot;../../language/string_literal&quot;&gt;строковый литерал&lt;/a&gt; нельзя использовать в качестве первого аргумента &lt;code&gt;strtok&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="aaae01573deddc58b640a93ca69e57c3af20acb3" translate="yes" xml:space="preserve">
          <source>This function is destructive: it writes the &lt;code&gt;L'\0'&lt;/code&gt; characters in the elements of the string &lt;code&gt;str&lt;/code&gt;. In particular, a wide string literal cannot be used as the first argument of &lt;code&gt;std::wcstok&lt;/code&gt;.</source>
          <target state="translated">Эта функция деструктивна: она записывает символы &lt;code&gt;L'\0'&lt;/code&gt; в элементах строки &lt;code&gt;str&lt;/code&gt; . В частности, широкий строковый литерал не может использоваться в качестве первого аргумента &lt;code&gt;std::wcstok&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ae117e98847c242edb80799fb082fc22f8c51c75" translate="yes" xml:space="preserve">
          <source>This function is different from a typical &lt;code&gt;overflow()&lt;/code&gt; which moves the contents of the buffer to the associated character sequence because for a &lt;code&gt;&lt;a href=&quot;../basic_stringbuf&quot;&gt;std::basic_stringbuf&lt;/a&gt;&lt;/code&gt;, the buffer and the associated sequence are one and the same.</source>
          <target state="translated">Эта функция отличается от типичного &lt;code&gt;overflow()&lt;/code&gt; который перемещает содержимое буфера в связанную символьную последовательность, потому что для &lt;code&gt;&lt;a href=&quot;../basic_stringbuf&quot;&gt;std::basic_stringbuf&lt;/a&gt;&lt;/code&gt; буфер и связанная последовательность являются одинаковыми.</target>
        </trans-unit>
        <trans-unit id="bf7eaed7da997c4b5d39d94135b3ff5c00bc6632" translate="yes" xml:space="preserve">
          <source>This function is equivalent to the call &lt;code&gt;&lt;a href=&quot;mbrtowc&quot;&gt;std::mbrtowc&lt;/a&gt;(nullptr, s, n, ps?ps:&amp;amp;internal)&lt;/code&gt; for some hidden object &lt;code&gt;internal&lt;/code&gt; of type &lt;code&gt;&lt;a href=&quot;mbstate_t&quot;&gt;std::mbstate_t&lt;/a&gt;&lt;/code&gt;, except that the expression &lt;code&gt;ps&lt;/code&gt; is evaluated only once.</source>
          <target state="translated">Эта функция эквивалентна вызову &lt;code&gt;&lt;a href=&quot;mbrtowc&quot;&gt;std::mbrtowc&lt;/a&gt;(nullptr, s, n, ps?ps:&amp;amp;internal)&lt;/code&gt; для некоторого скрытого объекта &lt;code&gt;internal&lt;/code&gt; типа &lt;code&gt;&lt;a href=&quot;mbstate_t&quot;&gt;std::mbstate_t&lt;/a&gt;&lt;/code&gt; , за исключением того, что выражение &lt;code&gt;ps&lt;/code&gt; вычисляется только один раз.</target>
        </trans-unit>
        <trans-unit id="9101f15eeb95d6b33b0fdb8d4808ce7c08cccbd4" translate="yes" xml:space="preserve">
          <source>This function is equivalent to the call &lt;code&gt;&lt;a href=&quot;mbtowc&quot;&gt;std::mbtowc&lt;/a&gt;((wchar_t*)0, s, n)&lt;/code&gt;, except that conversion state of &lt;code&gt;&lt;a href=&quot;mbtowc&quot;&gt;std::mbtowc&lt;/a&gt;&lt;/code&gt; is unaffected.</source>
          <target state="translated">Эта функция эквивалентна вызову &lt;code&gt;&lt;a href=&quot;mbtowc&quot;&gt;std::mbtowc&lt;/a&gt;((wchar_t*)0, s, n)&lt;/code&gt; , за исключением того, что состояние преобразования &lt;code&gt;&lt;a href=&quot;mbtowc&quot;&gt;std::mbtowc&lt;/a&gt;&lt;/code&gt; не изменяется .</target>
        </trans-unit>
        <trans-unit id="1963bc98196193cc320458fc455ddd3e328dde8a" translate="yes" xml:space="preserve">
          <source>This function is infrequently used directly by application code. Instead, one of the non-member comparison operators are used.</source>
          <target state="translated">Эта функция редко используется непосредственно кодом приложения.Вместо нее используется один из не членских операторов сравнения.</target>
        </trans-unit>
        <trans-unit id="403f2759a06c2803350631fa5d221bae46fd2b6b" translate="yes" xml:space="preserve">
          <source>This function is inherently racy if the managed object is shared among threads. In particular, a false result may become stale before it can be used. A true result is reliable.</source>
          <target state="translated">Эта функция по своей природе является радужной,если управляемый объект совместно используется потоками.В частности,ложный результат может просрочиться до того,как его можно будет использовать.Истинный результат является надежным.</target>
        </trans-unit>
        <trans-unit id="452207e6d60059763d001256a30bc736ba869131" translate="yes" xml:space="preserve">
          <source>This function is intended to replace &lt;code&gt;&lt;a href=&quot;bind&quot;&gt;std::bind&lt;/a&gt;&lt;/code&gt;. Unlike std::bind, it does not support arbitrary argument rearrangement and has no special treatment for nested bind-expressions. On the other hand, it pays attention to the value category of the call wrapper object and propagates exception specification of the underlying call operator.</source>
          <target state="translated">Эта функция предназначена для замены &lt;code&gt;&lt;a href=&quot;bind&quot;&gt;std::bind&lt;/a&gt;&lt;/code&gt; . В отличие от std :: bind, он не поддерживает произвольную перестановку аргументов и не имеет специальной обработки для вложенных выражений связывания. С другой стороны, он обращает внимание на категорию значений объекта оболочки вызова и распространяет спецификацию исключений основного оператора вызова.</target>
        </trans-unit>
        <trans-unit id="bc919d55a6f87a71a7f9eff45b45a6e0e62a8ce5" translate="yes" xml:space="preserve">
          <source>This function is not expected to be called directly: it is called through &lt;a href=&quot;../basic_osyncstream/get_wrapped&quot;&gt;&lt;code&gt;std::basic_osyncstream::get_wrapped&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Эта функция не должна вызываться напрямую: она вызывается через &lt;a href=&quot;../basic_osyncstream/get_wrapped&quot;&gt; &lt;code&gt;std::basic_osyncstream::get_wrapped&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="57e7dd85f600e213ae40f7d97225e1e1697e505f" translate="yes" xml:space="preserve">
          <source>This function is not fully implemented in some standard libraries. For example, &lt;a href=&quot;https://github.com/llvm-mirror/libcxx/blob/master/src/random.cpp#L174&quot;&gt;LLVM libc++&lt;/a&gt; always returns zero even though the device is non-deterministic. In comparison, Microsoft Visual C++ implementation always returns 32, and &lt;a href=&quot;https://github.com/boostorg/random/blob/master/src/random_device.cpp#L242&quot;&gt;boost.random&lt;/a&gt; returns 10.</source>
          <target state="translated">Эта функция не полностью реализована в некоторых стандартных библиотеках. Например, &lt;a href=&quot;https://github.com/llvm-mirror/libcxx/blob/master/src/random.cpp#L174&quot;&gt;LLVM libc ++&lt;/a&gt; всегда возвращает ноль, даже если устройство недетерминировано. Для сравнения, реализация Microsoft Visual C ++ всегда возвращает 32, а &lt;a href=&quot;https://github.com/boostorg/random/blob/master/src/random_device.cpp#L242&quot;&gt;boost.random&lt;/a&gt; возвращает 10.</target>
        </trans-unit>
        <trans-unit id="bf2280640237c525c2d62eefb26aff9f2856c11f" translate="yes" xml:space="preserve">
          <source>This function is not locale-sensitive and pays no attention to the values of the &lt;code&gt;wchar_t&lt;/code&gt; objects it copies: nulls as well as invalid characters are copied too.</source>
          <target state="translated">Эта функция не зависит от локали и не обращает внимания на значения копируемых ею объектов &lt;code&gt;wchar_t&lt;/code&gt; : копируются как нулевые, так и недопустимые символы.</target>
        </trans-unit>
        <trans-unit id="67fe14d7992c12e6d5c157b600ec2cde52ad0774" translate="yes" xml:space="preserve">
          <source>This function is not locale-sensitive and pays no attention to the values of the &lt;code&gt;wchar_t&lt;/code&gt; objects it examines: nulls as well as invalid wide characters are compared too.</source>
          <target state="translated">Эта функция не чувствительна к локали и не обращает внимания на значения проверяемых ею объектов &lt;code&gt;wchar_t&lt;/code&gt; : сравниваются как нулевые, так и недопустимые широкие символы.</target>
        </trans-unit>
        <trans-unit id="9c3cb718222d314cabd06a082b4892a3a4ab3e26" translate="yes" xml:space="preserve">
          <source>This function is not locale-sensitive and pays no attention to the values of the &lt;code&gt;wchar_t&lt;/code&gt; objects it writes: nulls as well as invalid wide characters are written too.</source>
          <target state="translated">Эта функция не зависит от локали и не обращает внимания на значения записываемых ею объектов &lt;code&gt;wchar_t&lt;/code&gt; : также записываются как нулевые, так и недопустимые широкие символы.</target>
        </trans-unit>
        <trans-unit id="cc19c16caa38c36df06e04a2db5301e73e2f5836" translate="yes" xml:space="preserve">
          <source>This function is not locale-sensitive, unlike &lt;code&gt;&lt;a href=&quot;wcscoll&quot;&gt;std::wcscoll&lt;/a&gt;&lt;/code&gt;, and the order may not be meaningful when characters from different Unicode blocks are used together or when the order of code units does not match collation order.</source>
          <target state="translated">Эта функция не чувствительна к локали, в отличие от &lt;code&gt;&lt;a href=&quot;wcscoll&quot;&gt;std::wcscoll&lt;/a&gt;&lt;/code&gt; , и порядок может не иметь смысла, когда символы из разных блоков Unicode используются вместе или когда порядок единиц кода не соответствует порядку сортировки.</target>
        </trans-unit>
        <trans-unit id="743f719e1c7876947aef41d3da4d327b2152c1ab" translate="yes" xml:space="preserve">
          <source>This function is not overloaded for the types &lt;code&gt;signed char&lt;/code&gt; or &lt;code&gt;unsigned char&lt;/code&gt;, unlike the formatted &lt;a href=&quot;operator_ltlt2&quot;&gt;operator&amp;lt;&amp;lt;&lt;/a&gt;</source>
          <target state="translated">Эта функция не перегружена для типов &lt;code&gt;signed char&lt;/code&gt; или &lt;code&gt;unsigned char&lt;/code&gt; , в отличие от отформатированного &lt;a href=&quot;operator_ltlt2&quot;&gt;оператора &amp;lt;&amp;lt;&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d3b72d4451a67b0f8e9ff04bab97998d9cac5a6e" translate="yes" xml:space="preserve">
          <source>This function is not required to be sensitive to the sign of zero, although some implementations additionally enforce that if one argument is +0 and the other is -0, then +0 is returned.</source>
          <target state="translated">Эта функция не обязана быть чувствительной к знаку нуля,хотя в некоторых реализациях дополнительно предписывается,что если один аргумент +0,а другой -0,то возвращается +0.</target>
        </trans-unit>
        <trans-unit id="1e7653f07d484a2f1a2819f2a881f15b3743184c" translate="yes" xml:space="preserve">
          <source>This function is not required to be sensitive to the sign of zero, although some implementations additionally enforce that if one argument is +0 and the other is -0, then -0 is returned.</source>
          <target state="translated">Эта функция не обязана быть чувствительной к знаку нуля,хотя в некоторых реализациях дополнительно предписывается,что если один аргумент +0,а другой -0,то возвращается -0.</target>
        </trans-unit>
        <trans-unit id="63ff1f7a80d3a2498f6c2c57080a31e1fe86d34e" translate="yes" xml:space="preserve">
          <source>This function is not required to be thread-safe. Another call to getenv, as well as a call to the POSIX functions &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/setenv.html&quot;&gt;setenv()&lt;/a&gt;, &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/unsetenv.html&quot;&gt;unsetenv()&lt;/a&gt;, and &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/putenv.html&quot;&gt;putenv()&lt;/a&gt; may invalidate the pointer returned by a previous call or modify the string obtained from a previous call.</source>
          <target state="translated">Эта функция не обязана быть поточно-ориентированной. Другой вызов getenv, а также вызов функций POSIX &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/setenv.html&quot;&gt;setenv ()&lt;/a&gt; , &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/unsetenv.html&quot;&gt;unsetenv ()&lt;/a&gt; и &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/putenv.html&quot;&gt;putenv ()&lt;/a&gt; могут сделать недействительным указатель, возвращенный предыдущим вызовом, или изменить строку, полученную из предыдущего вызова.</target>
        </trans-unit>
        <trans-unit id="f78d178d130886a2b5afb503f15940c3ad73bbf9" translate="yes" xml:space="preserve">
          <source>This function is not subject to any errors specified in &lt;code&gt;&lt;a href=&quot;math_errhandling&quot;&gt;math_errhandling&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Эта функция не подвержена ошибкам, указанным в &lt;code&gt;&lt;a href=&quot;math_errhandling&quot;&gt;math_errhandling&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a2abffafc50a2795cbfb3627bf5fb2f042437061" translate="yes" xml:space="preserve">
          <source>This function is not subject to any of the error conditions specified in &lt;code&gt;&lt;a href=&quot;math_errhandling&quot;&gt;math_errhandling&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Эта функция не зависит от условий ошибки, указанных в &lt;code&gt;&lt;a href=&quot;math_errhandling&quot;&gt;math_errhandling&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e653a40d5b5f3d4ecc32e287a36ac0f0a3489976" translate="yes" xml:space="preserve">
          <source>This function is not subject to any of the errors specified in &lt;code&gt;&lt;a href=&quot;math_errhandling&quot;&gt;math_errhandling&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Эта функция не подвержена ошибкам, указанным в &lt;code&gt;&lt;a href=&quot;math_errhandling&quot;&gt;math_errhandling&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="da22a8cee5382549c532104db50c4ef68f7574e4" translate="yes" xml:space="preserve">
          <source>This function is not visible to ordinary &lt;a href=&quot;../../language/unqualified_lookup&quot;&gt;unqualified&lt;/a&gt; or &lt;a href=&quot;../../language/qualified_lookup&quot;&gt;qualified lookup&lt;/a&gt;, and can only be found by &lt;a href=&quot;../../language/adl&quot;&gt;argument-dependent lookup&lt;/a&gt; when &lt;code&gt;&lt;a href=&quot;../path&quot;&gt;std::filesystem::path&lt;/a&gt;&lt;/code&gt; is an associated class of the arguments. This prevents undesirable conversions in the presence of a &lt;code&gt;using namespace std::filesystem;&lt;/code&gt;</source>
          <target state="translated">Эта функция невидима для обычного &lt;a href=&quot;../../language/unqualified_lookup&quot;&gt;неквалифицированного&lt;/a&gt; или &lt;a href=&quot;../../language/qualified_lookup&quot;&gt;квалифицированного поиска&lt;/a&gt; , и ее можно найти только путем &lt;a href=&quot;../../language/adl&quot;&gt;поиска, зависящего&lt;/a&gt; от аргументов, когда &lt;code&gt;&lt;a href=&quot;../path&quot;&gt;std::filesystem::path&lt;/a&gt;&lt;/code&gt; является ассоциированным классом аргументов. Это предотвращает нежелательные преобразования в присутствии &lt;code&gt;using namespace std::filesystem;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="356a2955e71eb2ff664ad638e29c0c881711ba2c" translate="yes" xml:space="preserve">
          <source>This function is optional, it may return &lt;code&gt;no_order&lt;/code&gt; in every case.</source>
          <target state="translated">Эта функция является необязательной, она может возвращать &lt;code&gt;no_order&lt;/code&gt; в каждом случае.</target>
        </trans-unit>
        <trans-unit id="ffa5bc6979d4d788a32f52d1a8c3d6238bb88fba" translate="yes" xml:space="preserve">
          <source>This function is optional. If not implemented, this function returns &lt;code&gt;​0​&lt;/code&gt; (since the base class version &lt;code&gt;std::basic_streambuf::showmanyc&lt;/code&gt; gets called).</source>
          <target state="translated">Эта функция не является обязательной. Если не реализована эта функция возвращает &lt;code&gt;​0​&lt;/code&gt; (так как базовый класс версии &lt;code&gt;std::basic_streambuf::showmanyc&lt;/code&gt; вызывается).</target>
        </trans-unit>
        <trans-unit id="94f083987e438e8f45398655d60ea441662342f7" translate="yes" xml:space="preserve">
          <source>This function is protected virtual, it may only be called through &lt;code&gt;pubsetbuf()&lt;/code&gt; or from member functions of a user-defined class derived from &lt;code&gt;std::basic_filebuf&lt;/code&gt;.</source>
          <target state="translated">Эта функция защищена виртуально, ее можно вызывать только через &lt;code&gt;pubsetbuf()&lt;/code&gt; или из функций-членов пользовательского класса, производного от &lt;code&gt;std::basic_filebuf&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e90def3890bd5c122a703d2eae4d728a21e862ac" translate="yes" xml:space="preserve">
          <source>This function is protected virtual, it may only be called through &lt;code&gt;pubsetbuf()&lt;/code&gt; or from member functions of a user-defined class derived from &lt;code&gt;std::basic_stringbuf&lt;/code&gt;.</source>
          <target state="translated">Эта функция защищена виртуально, ее можно вызывать только через &lt;code&gt;pubsetbuf()&lt;/code&gt; или из функций-членов пользовательского класса, производного от &lt;code&gt;std::basic_stringbuf&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b7f492276aa00c278aeca31b34dc935f13689be2" translate="yes" xml:space="preserve">
          <source>This function is protected virtual, it may only be called through &lt;code&gt;pubsetbuf()&lt;/code&gt; or from member functions of a user-defined class derived from &lt;code&gt;std::strstreambuf&lt;/code&gt;.</source>
          <target state="translated">Эта функция защищена виртуально, ее можно вызывать только через &lt;code&gt;pubsetbuf()&lt;/code&gt; или из функций-членов пользовательского класса, производного от &lt;code&gt;std::strstreambuf&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="503edf2bb2eb0295ac5dcd3fad68fe3498303d2a" translate="yes" xml:space="preserve">
          <source>This function is provided for compatibility with C. If the compatibility is not required, &lt;code&gt;&lt;a href=&quot;atomic&quot;&gt;std::atomic&lt;/a&gt;&lt;/code&gt; may be initialized through their non-default constructors.</source>
          <target state="translated">Эта функция предназначена для совместимости с C. Если совместимость не требуется, &lt;code&gt;&lt;a href=&quot;atomic&quot;&gt;std::atomic&lt;/a&gt;&lt;/code&gt; может быть инициализирован через их конструкторы не по умолчанию.</target>
        </trans-unit>
        <trans-unit id="0233eac438664696f470dcb4a6305de8bdfaa672" translate="yes" xml:space="preserve">
          <source>This function is thread-safe (calling it from multiple threads does not introduce a data race) as long as no other function modifies the host environment. In particular, the POSIX functions &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/setenv.html&quot;&gt;setenv()&lt;/a&gt;, &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/unsetenv.html&quot;&gt;unsetenv()&lt;/a&gt;, and &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/putenv.html&quot;&gt;putenv()&lt;/a&gt; would introduce a data race if called without synchronization.</source>
          <target state="translated">Эта функция является поточно-ориентированной (ее вызов из нескольких потоков не приводит к гонке данных), если никакая другая функция не изменяет среду хоста. В частности, функции POSIX &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/setenv.html&quot;&gt;setenv ()&lt;/a&gt; , &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/unsetenv.html&quot;&gt;unsetenv ()&lt;/a&gt; и &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/putenv.html&quot;&gt;putenv ()&lt;/a&gt; вводят гонку данных при вызове без синхронизации.</target>
        </trans-unit>
        <trans-unit id="a752e45b1c1e76a0bf7ba715c5f6c403c0eed278" translate="yes" xml:space="preserve">
          <source>This function is thread-safe. Every call to &lt;code&gt;std::pmr::set_default_resource&lt;/code&gt;</source>
          <target state="translated">Эта функция является поточно-ориентированной. Каждый вызов &lt;code&gt;std::pmr::set_default_resource&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a166d5bd1c79123ccec86898cc471f7c6a1e389e" translate="yes" xml:space="preserve">
          <source>This function is thread-safe. Every call to &lt;code&gt;std::set_new_handler&lt;/code&gt;</source>
          <target state="translated">Эта функция является поточно-ориентированной. Каждый вызов &lt;code&gt;std::set_new_handler&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0f8d53be444102a8285b0653a05c85e675ae55c4" translate="yes" xml:space="preserve">
          <source>This function is thread-safe. Every call to &lt;code&gt;std::set_terminate&lt;/code&gt;</source>
          <target state="translated">Эта функция является поточно-ориентированной. Каждый вызов &lt;code&gt;std::set_terminate&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2c7aea13c02b97924864411502ae4053e055e059" translate="yes" xml:space="preserve">
          <source>This function is thread-safe. Every call to &lt;code&gt;std::set_unexpected&lt;/code&gt;</source>
          <target state="translated">Эта функция является поточно-ориентированной. Каждый вызов &lt;code&gt;std::set_unexpected&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="12d270b8becf9b193ce734289e056a679cfdfc26" translate="yes" xml:space="preserve">
          <source>This function is thread-safe. Previous call to &lt;code&gt;&lt;a href=&quot;set_default_resource&quot;&gt;std::pmr::set_default_resource&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">Эта функция является поточно-ориентированной. Предыдущий вызов &lt;code&gt;&lt;a href=&quot;set_default_resource&quot;&gt;std::pmr::set_default_resource&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b1ab230cef40ffc4e792b092936b1dc96c9a5607" translate="yes" xml:space="preserve">
          <source>This function is thread-safe. Previous call to &lt;code&gt;&lt;a href=&quot;set_new_handler&quot;&gt;std::set_new_handler&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">Эта функция является поточно-ориентированной. Предыдущий вызов &lt;code&gt;&lt;a href=&quot;set_new_handler&quot;&gt;std::set_new_handler&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="419521c15e45c9bfd4ee0de0dfa28aaf76875995" translate="yes" xml:space="preserve">
          <source>This function is thread-safe. Prior call to &lt;code&gt;&lt;a href=&quot;set_terminate&quot;&gt;std::set_terminate&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">Эта функция является поточно-ориентированной. Предыдущий вызов &lt;code&gt;&lt;a href=&quot;set_terminate&quot;&gt;std::set_terminate&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="991dd801c88141cd8662fd187f9759911775d74d" translate="yes" xml:space="preserve">
          <source>This function is thread-safe. Prior call to &lt;code&gt;std::set_unexpected&lt;/code&gt;</source>
          <target state="translated">Эта функция является поточно-ориентированной. Предыдущий вызов &lt;code&gt;std::set_unexpected&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b2b7ba4b79851f8176eac8ec16e5a1575927b2d7" translate="yes" xml:space="preserve">
          <source>This function is thread-safe; concurrent access by multiple threads does not result in a data race.(since C++14).</source>
          <target state="translated">Эта функция является потокобезопасной,одновременный доступ нескольких потоков не приводит к гонке данных (начиная с C++14).</target>
        </trans-unit>
        <trans-unit id="6c9ad1a43ed57cf75b0c052d412e9c8c3e821c79" translate="yes" xml:space="preserve">
          <source>This function is typically accessed through &lt;code&gt;std::basic_stringstream::str()&lt;/code&gt;.</source>
          <target state="translated">Эта функция обычно доступна через &lt;code&gt;std::basic_stringstream::str()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8638be2f7c43a80edc7dee020c03393b731e9858" translate="yes" xml:space="preserve">
          <source>This function is typically called by &lt;code&gt;&lt;a href=&quot;../basic_fstream/is_open&quot;&gt;std::basic_fstream::is_open()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Эта функция обычно вызывается функцией &lt;code&gt;&lt;a href=&quot;../basic_fstream/is_open&quot;&gt;std::basic_fstream::is_open()&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="db17dd608d932664bed4bd45648d18848b7cdb88" translate="yes" xml:space="preserve">
          <source>This function is typically called through the &lt;code&gt;&lt;a href=&quot;../strstream&quot;&gt;std::strstream&lt;/a&gt;&lt;/code&gt; interface.</source>
          <target state="translated">Эта функция обычно вызывается через интерфейс &lt;code&gt;&lt;a href=&quot;../strstream&quot;&gt;std::strstream&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6b70e23981de2eddfb5cf1b279f2272ffbaab4c5" translate="yes" xml:space="preserve">
          <source>This function is used by the standard library containers when inserting, copying, or moving elements.</source>
          <target state="translated">Эта функция используется стандартными контейнерами библиотек при вставке,копировании или перемещении элементов.</target>
        </trans-unit>
        <trans-unit id="1c6ccf8ad1ccab32debfac40525ef074436c2ec6" translate="yes" xml:space="preserve">
          <source>This function is used when making multiple locale-dependent comparisons using the same string or set of strings, because it is more efficient to use &lt;code&gt;std::strxfrm&lt;/code&gt; to transform all the strings just once, and subsequently compare the transformed strings with &lt;code&gt;&lt;a href=&quot;strcmp&quot;&gt;std::strcmp&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Эта функция используется при выполнении нескольких зависимых от локали сравнений с использованием одной и той же строки или набора строк, поскольку более эффективно использовать &lt;code&gt;std::strxfrm&lt;/code&gt; для преобразования всех строк только один раз, а затем сравнивать преобразованные строки с помощью &lt;code&gt;&lt;a href=&quot;strcmp&quot;&gt;std::strcmp&lt;/a&gt;&lt;/code&gt; ,</target>
        </trans-unit>
        <trans-unit id="ca9d1d936d9fcef21052e9b31a8d09c354e45148" translate="yes" xml:space="preserve">
          <source>This function is used when making multiple locale-dependent comparisons using the same wide string or set of wide strings, because it is more efficient to use &lt;code&gt;std::wcsxfrm&lt;/code&gt; to transform all the strings just once, and subsequently compare the transformed wide strings with &lt;code&gt;&lt;a href=&quot;wcscmp&quot;&gt;std::wcscmp&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Эта функция используется при выполнении нескольких зависимых от локали сравнений с использованием одной и той же широкой строки или набора широких строк, поскольку более эффективно использовать &lt;code&gt;std::wcsxfrm&lt;/code&gt; для преобразования всех строк только один раз, а затем сравнивать преобразованные широкие строки с &lt;code&gt;&lt;a href=&quot;wcscmp&quot;&gt;std::wcscmp&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5926d0f12bf7b7909e57150c062279d2ee706942" translate="yes" xml:space="preserve">
          <source>This function is useful in generic programming, since it uses &lt;code&gt;&amp;lt;&lt;/code&gt; and &lt;code&gt;==&lt;/code&gt; as fallbacks when &lt;code&gt;&amp;lt;=&amp;gt;&lt;/code&gt; is not available.</source>
          <target state="translated">Эта функция полезна в универсальном программировании, поскольку она использует &lt;code&gt;&amp;lt;&lt;/code&gt; и &lt;code&gt;==&lt;/code&gt; как запасные варианты, когда &lt;code&gt;&amp;lt;=&amp;gt;&lt;/code&gt; недоступно.</target>
        </trans-unit>
        <trans-unit id="be58b3707f3fcdf36615b4d19faec6a6dc05f29c" translate="yes" xml:space="preserve">
          <source>This function is useful when implementing periodic functions with the period exactly representable as a floating-point value: when calculating sin(&amp;pi;x) for a very large &lt;code&gt;x&lt;/code&gt;, calling &lt;code&gt;&lt;a href=&quot;sin&quot;&gt;std::sin&lt;/a&gt;&lt;/code&gt; directly may result in a large error, but if the function argument is first reduced with &lt;code&gt;std::remquo&lt;/code&gt;, the low-order bits of the quotient may be used to determine the sign and the octant of the result within the period, while the remainder may be used to calculate the value with high precision.</source>
          <target state="translated">Эта функция полезна при реализации периодических функций с точным представлением периода в виде значения с плавающей запятой: при вычислении sin (&amp;pi;x) для очень большого &lt;code&gt;x&lt;/code&gt; прямой вызов &lt;code&gt;&lt;a href=&quot;sin&quot;&gt;std::sin&lt;/a&gt;&lt;/code&gt; может привести к большой ошибке, но если аргумент функции сначала уменьшается с помощью &lt;code&gt;std::remquo&lt;/code&gt; , младшие биты отношения могут использоваться для определения знака и октанта результата в течение периода, в то время как остаток может использоваться для вычисления значения с высокой точностью.</target>
        </trans-unit>
        <trans-unit id="9314ee2e726c67b60305538d50add991082d26bc" translate="yes" xml:space="preserve">
          <source>This function is usually case-insensitive.</source>
          <target state="translated">Эта функция обычно не чувствительна к регистру.</target>
        </trans-unit>
        <trans-unit id="6c9ee1f3188431817a670ceef41258274cd55d11" translate="yes" xml:space="preserve">
          <source>This function may be used as an alternative to &lt;code&gt;&lt;a href=&quot;../shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&amp;lt;T&amp;gt;(new T(args...))&lt;/code&gt;. The trade-offs are:</source>
          <target state="translated">Эта функция может использоваться как альтернатива &lt;code&gt;&lt;a href=&quot;../shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&amp;lt;T&amp;gt;(new T(args...))&lt;/code&gt; . Компромиссы:</target>
        </trans-unit>
        <trans-unit id="0255ee7edd077c96e23883d7db760fc3da2e3d71" translate="yes" xml:space="preserve">
          <source>This function may be used e.g. in the implementation of &lt;code&gt;&lt;a href=&quot;../../io/basic_streambuf/underflow&quot;&gt;std::basic_filebuf::underflow&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../../io/basic_streambuf/overflow&quot;&gt;std::basic_filebuf::overflow&lt;/a&gt;&lt;/code&gt; to use bulk character copy instead of calling &lt;code&gt;&lt;a href=&quot;in&quot;&gt;std::codecvt::in&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;out&quot;&gt;std::codecvt::out&lt;/a&gt;&lt;/code&gt; if it is known that the locale imbued in the &lt;code&gt;&lt;a href=&quot;../../io/basic_filebuf&quot;&gt;std::basic_filebuf&lt;/a&gt;&lt;/code&gt; does not perform any conversions.</source>
          <target state="translated">Эта функция может быть использована, например, в реализации &lt;code&gt;&lt;a href=&quot;../../io/basic_streambuf/underflow&quot;&gt;std::basic_filebuf::underflow&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;../../io/basic_streambuf/overflow&quot;&gt;std::basic_filebuf::overflow&lt;/a&gt;&lt;/code&gt; для использования объемной копии символов вместо вызова &lt;code&gt;&lt;a href=&quot;in&quot;&gt;std::codecvt::in&lt;/a&gt;&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;out&quot;&gt;std::codecvt::out&lt;/a&gt;&lt;/code&gt; если она Известно, что локаль, &lt;code&gt;&lt;a href=&quot;../../io/basic_filebuf&quot;&gt;std::basic_filebuf&lt;/a&gt;&lt;/code&gt; в std :: basic_filebuf , не выполняет никаких преобразований.</target>
        </trans-unit>
        <trans-unit id="332c6aa9bcea925b9a927e3ad7173bbcf6a2f86d" translate="yes" xml:space="preserve">
          <source>This function may be used in the beginning of a subroutine that must hide the floating-point exceptions it may raise from the caller. If only some exceptions must be suppressed, while others must be reported, the non-stop mode is usually ended with a call to &lt;code&gt;&lt;a href=&quot;feupdateenv&quot;&gt;std::feupdateenv&lt;/a&gt;&lt;/code&gt; after clearing the unwanted exceptions.</source>
          <target state="translated">Эта функция может использоваться в начале подпрограммы, которая должна скрывать исключения с плавающей запятой, которые она может вызывать у вызывающей стороны. Если необходимо исключить только некоторые исключения, а о других необходимо сообщить, то режим без остановок обычно &lt;code&gt;&lt;a href=&quot;feupdateenv&quot;&gt;std::feupdateenv&lt;/a&gt;&lt;/code&gt; вызовом std :: feupdateenv после очистки нежелательных исключений.</target>
        </trans-unit>
        <trans-unit id="653f6e88a7890bf08216060f0a91617ba728c746" translate="yes" xml:space="preserve">
          <source>This function may be used to end the non-stop mode established by an earlier call to &lt;code&gt;&lt;a href=&quot;feholdexcept&quot;&gt;std::feholdexcept&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Эта функция может использоваться для завершения режима нон-стоп, установленного более ранним вызовом &lt;code&gt;&lt;a href=&quot;feholdexcept&quot;&gt;std::feholdexcept&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="23b1aaf9597250b14a85a5f063ebcaa36211aeee" translate="yes" xml:space="preserve">
          <source>This function may be used to output object representations, i.e. binary output.</source>
          <target state="translated">Эта функция может быть использована для вывода объектного представления,т.е.двоичного выхода.</target>
        </trans-unit>
        <trans-unit id="856950bcb4c9f3dcc5895c41de9e090f268e6ccd" translate="yes" xml:space="preserve">
          <source>This function may block for longer than &lt;code&gt;sleep_duration&lt;/code&gt; due to scheduling or resource contention delays.</source>
          <target state="translated">Эта функция может блокироваться дольше, чем &lt;code&gt;sleep_duration&lt;/code&gt; , из-за задержек планирования или конфликта ресурсов.</target>
        </trans-unit>
        <trans-unit id="6c2d0b323f5f9df1da55d663b9642600ad42960c" translate="yes" xml:space="preserve">
          <source>This function may block for longer than &lt;code&gt;timeout_duration&lt;/code&gt; due to scheduling or resource contention delays.</source>
          <target state="translated">Эта функция может блокироваться дольше, чем &lt;code&gt;timeout_duration&lt;/code&gt; , из-за задержек планирования или конфликта ресурсов.</target>
        </trans-unit>
        <trans-unit id="88aa144342c719b2d0cf02f7ae6cd001dc8b8b1c" translate="yes" xml:space="preserve">
          <source>This function may implement selection sampling or reservoir sampling.</source>
          <target state="translated">Эта функция может реализовывать отбор проб или отбор проб из резервуара.</target>
        </trans-unit>
        <trans-unit id="f6b6f1463d12ffb2bc42127132a8ac643fc238fe" translate="yes" xml:space="preserve">
          <source>This function may not be thread-safe.</source>
          <target state="translated">Эта функция может быть небезопасной для потока.</target>
        </trans-unit>
        <trans-unit id="a4a88b9d5b7b6f8931799bf82d9c71dd06343e4a" translate="yes" xml:space="preserve">
          <source>This function may only be used after &lt;code&gt;stream&lt;/code&gt; has been associated with an open file, but before any other operation (other than a failed call to &lt;code&gt;&lt;a href=&quot;setbuf&quot;&gt;std::setbuf&lt;/a&gt;&lt;/code&gt;/&lt;code&gt;std::setvbuf&lt;/code&gt;).</source>
          <target state="translated">Эта функция может использоваться только после того, как &lt;code&gt;stream&lt;/code&gt; был связан с открытым файлом, но перед любой другой операцией (кроме неудачного вызова &lt;code&gt;&lt;a href=&quot;setbuf&quot;&gt;std::setbuf&lt;/a&gt;&lt;/code&gt; / &lt;code&gt;std::setvbuf&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="19731f6b76843a49446fd5784cfb942c7dfca160" translate="yes" xml:space="preserve">
          <source>This function may only be used after &lt;code&gt;stream&lt;/code&gt; has been associated with an open file, but before any other operation (other than a failed call to &lt;code&gt;std::setbuf&lt;/code&gt;/&lt;code&gt;std::setvbuf&lt;/code&gt;).</source>
          <target state="translated">Эта функция может использоваться только после того, как &lt;code&gt;stream&lt;/code&gt; был связан с открытым файлом, но перед любой другой операцией (кроме неудачного вызова &lt;code&gt;std::setbuf&lt;/code&gt; / &lt;code&gt;std::setvbuf&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="717983186dc4c6865ae3eed7bfe5f5461be1682a" translate="yes" xml:space="preserve">
          <source>This function moves the &lt;code&gt;src&lt;/code&gt; pointer to the end of the converted multibyte string. This doesn't happen if &lt;code&gt;dst==&lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Эта функция перемещает указатель &lt;code&gt;src&lt;/code&gt; в конец преобразованной многобайтовой строки. Этого не происходит, если &lt;code&gt;dst==&lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="53568c58dccc50911b4df0d8fe32be0fd89e385d" translate="yes" xml:space="preserve">
          <source>This function never modifies the file, only the get area of the in-memory buffer.</source>
          <target state="translated">Эта функция никогда не модифицирует файл,а только область get в буфере in-memory.</target>
        </trans-unit>
        <trans-unit id="a3149df38d014eb7ad815af8ec580ac7ae565936" translate="yes" xml:space="preserve">
          <source>This function object provides owner-based (as opposed to value-based) mixed-type ordering of both &lt;code&gt;&lt;a href=&quot;weak_ptr&quot;&gt;std::weak_ptr&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&lt;/code&gt;. The order is such that two smart pointers compare equivalent only if they are both empty or if they share ownership, even if the values of the raw pointers obtained by &lt;code&gt;get()&lt;/code&gt; are different (e.g. because they point at different subobjects within the same object).</source>
          <target state="translated">Этот функциональный объект обеспечивает основанное на владельце (в отличие от основанного на значениях) упорядочение смешанного типа как &lt;code&gt;&lt;a href=&quot;weak_ptr&quot;&gt;std::weak_ptr&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&lt;/code&gt; . Порядок таков, что два интеллектуальных указателя сравнивают эквивалент, только если они оба пусты или если они совместно используют владельца, даже если значения необработанных указателей, полученных с помощью &lt;code&gt;get()&lt;/code&gt; , отличаются (например, потому что они указывают на разные подобъекты в одном и том же объекте) ,</target>
        </trans-unit>
        <trans-unit id="501340bd50fbe27100db1419cc8b73a966d53dac" translate="yes" xml:space="preserve">
          <source>This function only reports the stream state as reported by the most recent I/O operation, it does not examine the associated data source. For example, if the most recent I/O was a &lt;code&gt;&lt;a href=&quot;fgetc&quot;&gt;std::fgetc&lt;/a&gt;&lt;/code&gt;, which returned the last byte of a file, &lt;code&gt;std::feof&lt;/code&gt; returns zero. The next &lt;code&gt;&lt;a href=&quot;fgetc&quot;&gt;std::fgetc&lt;/a&gt;&lt;/code&gt; fails and changes the stream state to</source>
          <target state="translated">Эта функция только сообщает о состоянии потока в соответствии с самой последней операцией ввода-вывода, но не проверяет связанный источник данных. Например, если последний ввод-вывод был &lt;code&gt;&lt;a href=&quot;fgetc&quot;&gt;std::fgetc&lt;/a&gt;&lt;/code&gt; , который возвратил последний байт файла, &lt;code&gt;std::feof&lt;/code&gt; возвращает ноль. Следующий &lt;code&gt;&lt;a href=&quot;fgetc&quot;&gt;std::fgetc&lt;/a&gt;&lt;/code&gt; завершается ошибкой и изменяет состояние потока на</target>
        </trans-unit>
        <trans-unit id="7ad9af23b2df5c7bd59daf117807cb419335155c" translate="yes" xml:space="preserve">
          <source>This function only reports the stream state as set by the most recent I/O operation; it does not examine the associated data source. For example, if the most recent I/O was a &lt;a href=&quot;../basic_istream/get&quot;&gt;&lt;code&gt;get()&lt;/code&gt;&lt;/a&gt; which returned the last byte of a file, &lt;code&gt;eof()&lt;/code&gt; returns &lt;code&gt;false&lt;/code&gt;. The next &lt;code&gt;get()&lt;/code&gt; fails to read anything and sets the &lt;code&gt;eofbit&lt;/code&gt;. Only then does &lt;code&gt;eof()&lt;/code&gt; return &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">Эта функция только сообщает о состоянии потока, установленном самой последней операцией ввода-вывода; он не проверяет связанный источник данных. Например, если последний ввод-вывод был &lt;a href=&quot;../basic_istream/get&quot;&gt; &lt;code&gt;get()&lt;/code&gt; &lt;/a&gt; который возвратил последний байт файла, &lt;code&gt;eof()&lt;/code&gt; возвращает &lt;code&gt;false&lt;/code&gt; . Следующий &lt;code&gt;get()&lt;/code&gt; не может ничего прочитать и устанавливает &lt;code&gt;eofbit&lt;/code&gt; . Только тогда &lt;code&gt;eof()&lt;/code&gt; возвращает &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="982c99a7d72d510dc31dfb3379380b9b994f3b5b" translate="yes" xml:space="preserve">
          <source>This function reads &lt;a href=&quot;../../language/objects&quot;&gt;object representations&lt;/a&gt;, not the object values, and is typically only meaningful for trivially-copyable objects with no padding. For example, &lt;code&gt;memcmp()&lt;/code&gt; between two objects of type &lt;code&gt;&lt;a href=&quot;../basic_string&quot;&gt;std::string&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../../container/vector&quot;&gt;std::vector&lt;/a&gt;&lt;/code&gt; will not compare their contents, and &lt;code&gt;memcmp()&lt;/code&gt; between two objects of type &lt;code&gt;struct{char c; int n;}&lt;/code&gt; will compare the padding bytes whose values may differ when the values of &lt;code&gt;c&lt;/code&gt; and &lt;code&gt;n&lt;/code&gt; are the same.</source>
          <target state="translated">Эта функция читает &lt;a href=&quot;../../language/objects&quot;&gt;представления объекта&lt;/a&gt; , а не значения объекта, и обычно имеет смысл только для тривиально копируемых объектов без заполнения. Например, &lt;code&gt;memcmp()&lt;/code&gt; между двумя объектами типа &lt;code&gt;&lt;a href=&quot;../basic_string&quot;&gt;std::string&lt;/a&gt;&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;../../container/vector&quot;&gt;std::vector&lt;/a&gt;&lt;/code&gt; не будет сравнивать их содержимое, а &lt;code&gt;memcmp()&lt;/code&gt; между двумя объектами типа &lt;code&gt;struct{char c; int n;}&lt;/code&gt; будет сравнивать байты заполнения, значения которых могут отличаться, если значения &lt;code&gt;c&lt;/code&gt; и &lt;code&gt;n&lt;/code&gt; совпадают.</target>
        </trans-unit>
        <trans-unit id="3b2572fd11a91d196e72bf228b8fdec17f7a295e" translate="yes" xml:space="preserve">
          <source>This function returns &lt;code&gt;true&lt;/code&gt; immediately after construction or an increment. Recursion can be disabled via &lt;code&gt;&lt;a href=&quot;disable_recursion_pending&quot;&gt;disable_recursion_pending()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Эта функция возвращает &lt;code&gt;true&lt;/code&gt; сразу после построения или приращения. Рекурсию можно отключить с помощью &lt;code&gt;&lt;a href=&quot;disable_recursion_pending&quot;&gt;disable_recursion_pending()&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="36528001254a3bd82486f8ac96e239eda107e919" translate="yes" xml:space="preserve">
          <source>This function returns a pointer to static data and is not thread-safe. In addition, it modifies the static &lt;code&gt;&lt;a href=&quot;tm&quot;&gt;std::tm&lt;/a&gt;&lt;/code&gt; object which may be shared with &lt;code&gt;&lt;a href=&quot;gmtime&quot;&gt;std::gmtime&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;localtime&quot;&gt;std::localtime&lt;/a&gt;&lt;/code&gt;. POSIX marks this function obsolete and recommends &lt;code&gt;&lt;a href=&quot;strftime&quot;&gt;std::strftime&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">Эта функция возвращает указатель на статические данные и не является поточно-ориентированной. Кроме того, он изменяет статический объект &lt;code&gt;&lt;a href=&quot;tm&quot;&gt;std::tm&lt;/a&gt;&lt;/code&gt; который может использоваться совместно с &lt;code&gt;&lt;a href=&quot;gmtime&quot;&gt;std::gmtime&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;localtime&quot;&gt;std::localtime&lt;/a&gt;&lt;/code&gt; . POSIX помечает эту функцию как устаревшую и рекомендует вместо &lt;code&gt;&lt;a href=&quot;strftime&quot;&gt;std::strftime&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b1f290d85406220b6b3adbcd72ba71618d9d4c4a" translate="yes" xml:space="preserve">
          <source>This function returns a pointer to static data and is not thread-safe. POSIX marks this function obsolete and recommends &lt;code&gt;&lt;a href=&quot;strftime&quot;&gt;std::strftime&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">Эта функция возвращает указатель на статические данные и не является поточно-ориентированной. POSIX помечает эту функцию как устаревшую и рекомендует вместо &lt;code&gt;&lt;a href=&quot;strftime&quot;&gt;std::strftime&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2c08549c92d5f75cd55b61fde267f92bfcf2bd81" translate="yes" xml:space="preserve">
          <source>This function template does not participate in overload resolution unless &lt;code&gt;&lt;a href=&quot;../../types/is_move_constructible&quot;&gt;std::is_move_constructible_v&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../../types/is_swappable&quot;&gt;std::is_swappable_v&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt; are both &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">Этот шаблон функции не участвует в разрешении перегрузки, если только &lt;code&gt;&lt;a href=&quot;../../types/is_move_constructible&quot;&gt;std::is_move_constructible_v&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;../../types/is_swappable&quot;&gt;std::is_swappable_v&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt; оба не равны &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e017cba1b1d7f0a849984253cc947eb2d5f913c0" translate="yes" xml:space="preserve">
          <source>This function template is &lt;code&gt;constexpr&lt;/code&gt; if and only if each of &lt;code&gt;To&lt;/code&gt;, &lt;code&gt;From&lt;/code&gt; and the types of all subobjects of &lt;code&gt;To&lt;/code&gt; and &lt;code&gt;From&lt;/code&gt;:</source>
          <target state="translated">Этот шаблон функции является &lt;code&gt;constexpr&lt;/code&gt; , если и только если каждый из &lt;code&gt;To&lt;/code&gt; , &lt;code&gt;From&lt;/code&gt; и типы всех подобъектов &lt;code&gt;To&lt;/code&gt; и &lt;code&gt;From&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="d23f50db250e473fa7ba998015f5ef4335528d35" translate="yes" xml:space="preserve">
          <source>This function was deprecated in C++17 and removed in C++20 because &lt;code&gt;&lt;a href=&quot;use_count&quot;&gt;use_count&lt;/a&gt;&lt;/code&gt; is only an approximation in multithreaded environment (see Notes in &lt;code&gt;&lt;a href=&quot;use_count&quot;&gt;use_count&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">Эта функция устарела в C ++ 17 и удалена в C ++ 20, потому что &lt;code&gt;&lt;a href=&quot;use_count&quot;&gt;use_count&lt;/a&gt;&lt;/code&gt; является лишь приближением в многопоточной среде (см. Примечания в &lt;code&gt;&lt;a href=&quot;use_count&quot;&gt;use_count&lt;/a&gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="c95a6c84f8a7a3d63141f96f96d764fc5141f797" translate="yes" xml:space="preserve">
          <source>This function was introduced for use with the fully-specialized allocator &lt;code&gt;std::polymorphic_allocator&amp;lt;&amp;gt;&lt;/code&gt;, but it may be useful in any specialization as a shortcut to avoid having to rebind from &lt;code&gt;std::polymorphic_allocator&amp;lt;T&amp;gt;&lt;/code&gt; to &lt;code&gt;std::polymorphic_allocator&amp;lt;U&amp;gt;&lt;/code&gt;, and having to call &lt;code&gt;allocate&lt;/code&gt;, &lt;code&gt;construct&lt;/code&gt;, and &lt;code&gt;deallocate&lt;/code&gt; individually.</source>
          <target state="translated">Эта функция была введена для использования с полностью специализированным распределителем &lt;code&gt;std::polymorphic_allocator&amp;lt;&amp;gt;&lt;/code&gt; , но она может быть полезна для любой специализации в качестве ярлыка, чтобы избежать необходимости повторного связывания с &lt;code&gt;std::polymorphic_allocator&amp;lt;T&amp;gt;&lt;/code&gt; в &lt;code&gt;std::polymorphic_allocator&amp;lt;U&amp;gt;&lt;/code&gt; и необходимость вызывать &lt;code&gt;allocate&lt;/code&gt; , &lt;code&gt;construct&lt;/code&gt; и &lt;code&gt;deallocate&lt;/code&gt; отдельности.</target>
        </trans-unit>
        <trans-unit id="cdecbddba7a122a33bb2e1a5f3720fe34c7dff59" translate="yes" xml:space="preserve">
          <source>This function was introduced for use with the fully-specialized allocator &lt;code&gt;std::polymorphic_allocator&amp;lt;&amp;gt;&lt;/code&gt;, but it may be useful in any specialization as a shortcut to avoid having to rebind from &lt;code&gt;std::polymorphic_allocator&amp;lt;T&amp;gt;&lt;/code&gt; to &lt;code&gt;std::polymorphic_allocator&amp;lt;U&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">Эта функция была введена для использования с полностью специализированным распределителем &lt;code&gt;std::polymorphic_allocator&amp;lt;&amp;gt;&lt;/code&gt; , но она может быть полезна для любой специализации в качестве ярлыка, чтобы избежать необходимости повторного связывания с &lt;code&gt;std::polymorphic_allocator&amp;lt;T&amp;gt;&lt;/code&gt; в &lt;code&gt;std::polymorphic_allocator&amp;lt;U&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2ae120608bb11c2db86fc6eaad00ab05ea738813" translate="yes" xml:space="preserve">
          <source>This function was introduced for use with the fully-specialized allocator &lt;code&gt;std::polymorphic_allocator&amp;lt;&amp;gt;&lt;/code&gt;, but it may be useful in any specialization.</source>
          <target state="translated">Эта функция была введена для использования с полностью специализированным распределителем &lt;code&gt;std::polymorphic_allocator&amp;lt;&amp;gt;&lt;/code&gt; , но она может быть полезна в любой специализации.</target>
        </trans-unit>
        <trans-unit id="afc3c5ff95ee968755d1d67223367b55662ab586" translate="yes" xml:space="preserve">
          <source>This function's analog for byte strings is &lt;code&gt;&lt;a href=&quot;../byte/strncpy&quot;&gt;std::strncpy&lt;/a&gt;&lt;/code&gt;, not &lt;code&gt;&lt;a href=&quot;../byte/strcpy&quot;&gt;std::strcpy&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Аналог этой функции для байтовых строк: &lt;code&gt;&lt;a href=&quot;../byte/strncpy&quot;&gt;std::strncpy&lt;/a&gt;&lt;/code&gt; , а не &lt;code&gt;&lt;a href=&quot;../byte/strcpy&quot;&gt;std::strcpy&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a2cb86dd21cb66b4b0098463876ae7c777232781" translate="yes" xml:space="preserve">
          <source>This function, if defined, is the inverse of &lt;code&gt;pointer_to&lt;/code&gt;, and exists as the customization point to be called by &lt;a href=&quot;../to_address&quot;&gt;&lt;code&gt;std::to_address&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Эта функция, если она определена, является обратной по отношению к &lt;code&gt;pointer_to&lt;/code&gt; и существует как точка настройки, вызываемая &lt;a href=&quot;../to_address&quot;&gt; &lt;code&gt;std::to_address&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2345f7fbcd183e468d0ac0a235350d0b6c2895ee" translate="yes" xml:space="preserve">
          <source>This functions invalidates all pointers and references to elements in the array.</source>
          <target state="translated">Данная функция делает недействительными все указатели и ссылки на элементы в массиве.</target>
        </trans-unit>
        <trans-unit id="5e4969b70b796f9ee282c9f3e8a0064ce14f7b5c" translate="yes" xml:space="preserve">
          <source>This header contains forward declarations for the &lt;a href=&quot;../io&quot;&gt;Input/output&lt;/a&gt; library.</source>
          <target state="translated">Этот заголовок содержит предварительные объявления для библиотеки &lt;a href=&quot;../io&quot;&gt;ввода / вывода&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a9faf08967a6670c687da4edbcf69fb38e394a6f" translate="yes" xml:space="preserve">
          <source>This header is for &lt;a href=&quot;../string/byte&quot;&gt;C-style null-terminated byte strings&lt;/a&gt;.</source>
          <target state="translated">Этот заголовок для &lt;a href=&quot;../string/byte&quot;&gt;C-стиль завершающего нуля строки байт&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="15d0710db508b245029a9ef7a8057846c8c18ceb" translate="yes" xml:space="preserve">
          <source>This header is part of the &lt;a href=&quot;../algorithm&quot;&gt;algorithm&lt;/a&gt; library.</source>
          <target state="translated">Этот заголовок является частью библиотеки &lt;a href=&quot;../algorithm&quot;&gt;алгоритмов&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="58c127bf99321a87db0770e187db96005473b488" translate="yes" xml:space="preserve">
          <source>This header is part of the &lt;a href=&quot;../atomic&quot;&gt;atomic operations&lt;/a&gt; library.</source>
          <target state="translated">Этот заголовок является частью библиотеки &lt;a href=&quot;../atomic&quot;&gt;атомарных операций&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e7de3a818aa933f4120df06f08cef712f022314a" translate="yes" xml:space="preserve">
          <source>This header is part of the &lt;a href=&quot;../chrono&quot;&gt;date and time&lt;/a&gt; library.</source>
          <target state="translated">Этот заголовок является частью библиотеки &lt;a href=&quot;../chrono&quot;&gt;даты и времени&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7df038a6142795810cf58cc3edc5892a6604ef81" translate="yes" xml:space="preserve">
          <source>This header is part of the &lt;a href=&quot;../chrono/c&quot;&gt;C-style date and time&lt;/a&gt; library.</source>
          <target state="translated">Этот заголовок является частью библиотеки &lt;a href=&quot;../chrono/c&quot;&gt;даты и времени в стиле C.&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="fc145a04217e02f635144bea666233647838e7fd" translate="yes" xml:space="preserve">
          <source>This header is part of the &lt;a href=&quot;../concepts&quot;&gt;concepts&lt;/a&gt; library.</source>
          <target state="translated">Этот заголовок является частью библиотеки &lt;a href=&quot;../concepts&quot;&gt;понятий&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="920e039f9619877e9581d36218e4eb4ba48fec2f" translate="yes" xml:space="preserve">
          <source>This header is part of the &lt;a href=&quot;../container&quot;&gt;container&lt;/a&gt; library.</source>
          <target state="translated">Этот заголовок является частью библиотеки &lt;a href=&quot;../container&quot;&gt;контейнеров&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="acbb3dd4e1d46d22f68d17b978a7136be93e2436" translate="yes" xml:space="preserve">
          <source>This header is part of the &lt;a href=&quot;../container&quot;&gt;containers&lt;/a&gt; library.</source>
          <target state="translated">Этот заголовок является частью библиотеки &lt;a href=&quot;../container&quot;&gt;контейнеров&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6b732c1d1cd4791f71bccf52bcce002f80d4d61f" translate="yes" xml:space="preserve">
          <source>This header is part of the &lt;a href=&quot;../error&quot;&gt;error handling&lt;/a&gt; library.</source>
          <target state="translated">Этот заголовок является частью библиотеки &lt;a href=&quot;../error&quot;&gt;обработки ошибок&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d135ae9415d668b3740baa8d1c6202b3114e61db" translate="yes" xml:space="preserve">
          <source>This header is part of the &lt;a href=&quot;../filesystem&quot;&gt;filesystem support&lt;/a&gt; library.</source>
          <target state="translated">Этот заголовок является частью библиотеки &lt;a href=&quot;../filesystem&quot;&gt;поддержки файловой системы&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a2b0a9ff42b16169188356ee975f844196e0ec79" translate="yes" xml:space="preserve">
          <source>This header is part of the &lt;a href=&quot;../io&quot;&gt;Input/Output&lt;/a&gt; library.</source>
          <target state="translated">Этот заголовок является частью библиотеки &lt;a href=&quot;../io&quot;&gt;ввода / вывода&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b25ea2a66813773c5a403aa1ec3e976f8574b721" translate="yes" xml:space="preserve">
          <source>This header is part of the &lt;a href=&quot;../io&quot;&gt;Input/output&lt;/a&gt; library.</source>
          <target state="translated">Этот заголовок является частью библиотеки &lt;a href=&quot;../io&quot;&gt;ввода / вывода&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0686693c4046ba7c301b43bc07e6f7bdc8f026ab" translate="yes" xml:space="preserve">
          <source>This header is part of the &lt;a href=&quot;../io&quot;&gt;input/output&lt;/a&gt; library.</source>
          <target state="translated">Этот заголовок является частью библиотеки &lt;a href=&quot;../io&quot;&gt;ввода / вывода&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5dc95614835592456bfaab6702f6224650e49b18" translate="yes" xml:space="preserve">
          <source>This header is part of the &lt;a href=&quot;../io/c&quot;&gt;C-style input/output&lt;/a&gt; library.</source>
          <target state="translated">Этот заголовок является частью библиотеки &lt;a href=&quot;../io/c&quot;&gt;ввода / вывода в стиле C.&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="741ade6dc30c88b9370c305e6f3e63644225b886" translate="yes" xml:space="preserve">
          <source>This header is part of the &lt;a href=&quot;../io/manip&quot;&gt;Input/output manipulators&lt;/a&gt; library.</source>
          <target state="translated">Этот заголовок является частью библиотеки &lt;a href=&quot;../io/manip&quot;&gt;манипуляторов ввода / вывода&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7cb909214b55ea54c4a3636e2ff95e66a61c1e7b" translate="yes" xml:space="preserve">
          <source>This header is part of the &lt;a href=&quot;../iterator&quot;&gt;iterator&lt;/a&gt; library.</source>
          <target state="translated">Этот заголовок является частью библиотеки &lt;a href=&quot;../iterator&quot;&gt;итераторов&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="09eabf0e3af531f8459c8a3e9d34d078049d494f" translate="yes" xml:space="preserve">
          <source>This header is part of the &lt;a href=&quot;../locale&quot;&gt;Localization&lt;/a&gt; library.</source>
          <target state="translated">Этот заголовок является частью библиотеки &lt;a href=&quot;../locale&quot;&gt;локализации&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e0027a344c3001e03b17fff554e048e844e18b05" translate="yes" xml:space="preserve">
          <source>This header is part of the &lt;a href=&quot;../locale&quot;&gt;localization&lt;/a&gt; library.</source>
          <target state="translated">Этот заголовок является частью библиотеки &lt;a href=&quot;../locale&quot;&gt;локализации&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1909ccb2df983190ad8b340b81a78cddcac0bc66" translate="yes" xml:space="preserve">
          <source>This header is part of the &lt;a href=&quot;../memory&quot;&gt;dynamic memory management&lt;/a&gt; library, in particular provides &lt;a href=&quot;../memory/new&quot;&gt;low level memory management&lt;/a&gt; features.</source>
          <target state="translated">Этот заголовок является частью библиотеки &lt;a href=&quot;../memory&quot;&gt;динамического управления памятью&lt;/a&gt; , в частности обеспечивает функции &lt;a href=&quot;../memory/new&quot;&gt;управления памятью низкого уровня&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="923f654a5fb3f2b4a9e337168f6734bf9fb2d4f9" translate="yes" xml:space="preserve">
          <source>This header is part of the &lt;a href=&quot;../memory&quot;&gt;dynamic memory management&lt;/a&gt; library.</source>
          <target state="translated">Этот заголовок является частью библиотеки &lt;a href=&quot;../memory&quot;&gt;динамического управления памятью&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="dbf3371c4bdf5d7b9e212f0bbd00a12907e1875c" translate="yes" xml:space="preserve">
          <source>This header is part of the &lt;a href=&quot;../numeric&quot;&gt;numeric&lt;/a&gt; library.</source>
          <target state="translated">Этот заголовок является частью &lt;a href=&quot;../numeric&quot;&gt;числовой&lt;/a&gt; библиотеки.</target>
        </trans-unit>
        <trans-unit id="83d799881dc970620d81655aaa5b6c445cc22101" translate="yes" xml:space="preserve">
          <source>This header is part of the &lt;a href=&quot;../numeric/fenv&quot;&gt;floating-point environment&lt;/a&gt; library.</source>
          <target state="translated">Этот заголовок является частью библиотеки &lt;a href=&quot;../numeric/fenv&quot;&gt;среды&lt;/a&gt; с плавающей точкой .</target>
        </trans-unit>
        <trans-unit id="5ec3ff74347947b9a2d2ce7512f774f5d52354a7" translate="yes" xml:space="preserve">
          <source>This header is part of the &lt;a href=&quot;../numeric/random&quot;&gt;pseudo-random number generation&lt;/a&gt; library.</source>
          <target state="translated">Этот заголовок является частью библиотеки &lt;a href=&quot;../numeric/random&quot;&gt;генерации псевдослучайных чисел&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="732e0c7c47f9d69b203e65c610a0bfd158dff524" translate="yes" xml:space="preserve">
          <source>This header is part of the &lt;a href=&quot;../numeric/ratio&quot;&gt;compile-time rational arithmetic&lt;/a&gt; library.</source>
          <target state="translated">Этот заголовок является частью &lt;a href=&quot;../numeric/ratio&quot;&gt;рациональной арифметической&lt;/a&gt; библиотеки времени компиляции .</target>
        </trans-unit>
        <trans-unit id="c1ad47862381ddb91c08db8090600c5d4bf4e4dc" translate="yes" xml:space="preserve">
          <source>This header is part of the &lt;a href=&quot;../ranges&quot;&gt;ranges&lt;/a&gt; library.</source>
          <target state="translated">Этот заголовок является частью библиотеки &lt;a href=&quot;../ranges&quot;&gt;диапазонов&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d97fc3d50637471b41b3efb43e5a6b0e3a2b4a01" translate="yes" xml:space="preserve">
          <source>This header is part of the &lt;a href=&quot;../regex&quot;&gt;regular expressions&lt;/a&gt; library.</source>
          <target state="translated">Этот заголовок является частью библиотеки &lt;a href=&quot;../regex&quot;&gt;регулярных выражений&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a2342c5c0987e5fec030e1218936937ec44df653" translate="yes" xml:space="preserve">
          <source>This header is part of the &lt;a href=&quot;../string&quot;&gt;strings&lt;/a&gt; library.</source>
          <target state="translated">Этот заголовок является частью библиотеки &lt;a href=&quot;../string&quot;&gt;строк&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="92a5be8272a47414f0e0bdc904667ee202af3267" translate="yes" xml:space="preserve">
          <source>This header is part of the &lt;a href=&quot;../string/byte&quot;&gt;null-terminated byte strings&lt;/a&gt; library.</source>
          <target state="translated">Этот заголовок является частью библиотеки &lt;a href=&quot;../string/byte&quot;&gt;байтовых строк&lt;/a&gt; с нулевым символом в конце .</target>
        </trans-unit>
        <trans-unit id="15b12e7c5f34f001bead642c260ad11a6ffaa39d" translate="yes" xml:space="preserve">
          <source>This header is part of the &lt;a href=&quot;../string/multibyte&quot;&gt;null-terminated multibyte strings&lt;/a&gt; library.</source>
          <target state="translated">Этот заголовок является частью библиотеки &lt;a href=&quot;../string/multibyte&quot;&gt;многобайтовых строк&lt;/a&gt; с нулевым символом в конце .</target>
        </trans-unit>
        <trans-unit id="2c42908621e154cf0ec843b46350efa2d0035aee" translate="yes" xml:space="preserve">
          <source>This header is part of the &lt;a href=&quot;../string/wide&quot;&gt;C-style null-terminated wide strings&lt;/a&gt; library.</source>
          <target state="translated">Этот заголовок является частью библиотеки &lt;a href=&quot;../string/wide&quot;&gt;широких строк с нулевым символом в конце в стиле C.&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="1fa75679068a99053300a010d141f6d8edb54561" translate="yes" xml:space="preserve">
          <source>This header is part of the &lt;a href=&quot;../thread&quot;&gt;thread support&lt;/a&gt; library.</source>
          <target state="translated">Этот заголовок является частью библиотеки &lt;a href=&quot;../thread&quot;&gt;поддержки потоков&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5d0c64faa54ec66b25a58a11c78064009bdd8b01" translate="yes" xml:space="preserve">
          <source>This header is part of the &lt;a href=&quot;../types&quot;&gt;type support&lt;/a&gt; library, in particular it's part of the &lt;a href=&quot;../types/climits&quot;&gt;C numeric limits interface&lt;/a&gt;.</source>
          <target state="translated">Этот заголовок является частью &lt;a href=&quot;../types&quot;&gt;поддержки типа&lt;/a&gt; библиотеки, в частности , это часть &lt;a href=&quot;../types/climits&quot;&gt;интерфейса числовых пределов C&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="65d3f063deae384355d6746093849a4b449165a4" translate="yes" xml:space="preserve">
          <source>This header is part of the &lt;a href=&quot;../types&quot;&gt;type support&lt;/a&gt; library, providing &lt;a href=&quot;../types/integer&quot;&gt;fixed width integer types&lt;/a&gt; and part of &lt;a href=&quot;../types/climits&quot;&gt;C numeric limits interface&lt;/a&gt;.</source>
          <target state="translated">Этот заголовок является частью &lt;a href=&quot;../types&quot;&gt;опорного типа&lt;/a&gt; библиотеки, обеспечивая &lt;a href=&quot;../types/integer&quot;&gt;фиксированную ширину целочисленных типов&lt;/a&gt; и часть &lt;a href=&quot;../types/climits&quot;&gt;интерфейса числовых пределов C&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="436886a411e9e8d5ffe11352a732faef34f88757" translate="yes" xml:space="preserve">
          <source>This header is part of the &lt;a href=&quot;../types&quot;&gt;type support&lt;/a&gt; library.</source>
          <target state="translated">Этот заголовок является частью библиотеки &lt;a href=&quot;../types&quot;&gt;поддержки типов&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7edf0c9c8e7cef800a48133a201ddbc070132a48" translate="yes" xml:space="preserve">
          <source>This header is part of the &lt;a href=&quot;../types&quot;&gt;types support&lt;/a&gt; library.</source>
          <target state="translated">Этот заголовок является частью библиотеки &lt;a href=&quot;../types&quot;&gt;поддержки типов&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="58facb47ff5cf9d880e42e8852e016436ed3f78a" translate="yes" xml:space="preserve">
          <source>This header is part of the &lt;a href=&quot;../utility&quot;&gt;general utility&lt;/a&gt; library.</source>
          <target state="translated">Этот заголовок является частью &lt;a href=&quot;../utility&quot;&gt;общей служебной&lt;/a&gt; библиотеки.</target>
        </trans-unit>
        <trans-unit id="31843b16c0e12afb62de520dcdac5733f6cee8c2" translate="yes" xml:space="preserve">
          <source>This header is part of the &lt;a href=&quot;../utility&quot;&gt;utility&lt;/a&gt; library.</source>
          <target state="translated">Этот заголовок является частью &lt;a href=&quot;../utility&quot;&gt;служебной&lt;/a&gt; библиотеки.</target>
        </trans-unit>
        <trans-unit id="b3ee827480d7d8d279e03c27c6ed6cca87cad739" translate="yes" xml:space="preserve">
          <source>This header is part of the &lt;a href=&quot;../utility#Language_support&quot;&gt;language support&lt;/a&gt; library.</source>
          <target state="translated">Этот заголовок является частью библиотеки &lt;a href=&quot;../utility#Language_support&quot;&gt;языковой поддержки&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a4ff4d258bc17960105e2ea2601ffd3a5889df5f" translate="yes" xml:space="preserve">
          <source>This header is part of the &lt;a href=&quot;../utility/functional&quot;&gt;function objects&lt;/a&gt; library and provides the standard &lt;a href=&quot;../utility/hash&quot;&gt;hash function&lt;/a&gt;.</source>
          <target state="translated">Этот заголовок является частью библиотеки &lt;a href=&quot;../utility/functional&quot;&gt;объектов функций&lt;/a&gt; и предоставляет стандартную &lt;a href=&quot;../utility/hash&quot;&gt;хеш-функцию&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9ac972c91cec61981b8a812ec6acfd57ff806586" translate="yes" xml:space="preserve">
          <source>This header is part of the &lt;a href=&quot;../utility/program&quot;&gt;program support&lt;/a&gt; library.</source>
          <target state="translated">Этот заголовок является частью библиотеки &lt;a href=&quot;../utility/program&quot;&gt;поддержки программ&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e22299e67c4b7f2d10a4eb976dbfff224a6c2122" translate="yes" xml:space="preserve">
          <source>This header is part of the null-terminated &lt;a href=&quot;../string/wide&quot;&gt;wide&lt;/a&gt; and &lt;a href=&quot;../string/multibyte&quot;&gt;multibyte&lt;/a&gt; strings libraries. It also provides some &lt;a href=&quot;../io/c&quot;&gt;C-style I/O&lt;/a&gt; functions and conversion from &lt;a href=&quot;../chrono/c&quot;&gt;C-style Date&lt;/a&gt;.</source>
          <target state="translated">Этот заголовок является частью библиотеки &lt;a href=&quot;../string/wide&quot;&gt;широких&lt;/a&gt; и &lt;a href=&quot;../string/multibyte&quot;&gt;многобайтовых&lt;/a&gt; строк с нулевым символом в конце . Она также предоставляет некоторые &lt;a href=&quot;../io/c&quot;&gt;O C-стиля ввода /&lt;/a&gt; функции и преобразование из &lt;a href=&quot;../chrono/c&quot;&gt;C-стиля Дата&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d0be451883776fa4f5f243412345fc9b51386469" translate="yes" xml:space="preserve">
          <source>This header provides miscellaneous utilities. Symbols defined here are used by several library components.</source>
          <target state="translated">В этом заголовке содержатся различные утилиты.Определенные здесь символы используются несколькими компонентами библиотеки.</target>
        </trans-unit>
        <trans-unit id="3d8521103b2fed33ffe104b06e729876d4b7f2c8" translate="yes" xml:space="preserve">
          <source>This header provides support for &lt;a href=&quot;../utility/variadic&quot;&gt;C-style variadic functions&lt;/a&gt;.</source>
          <target state="translated">Этот заголовок обеспечивает поддержку &lt;a href=&quot;../utility/variadic&quot;&gt;C-тип функции переменного числа&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1f5444765226ce0bdb5af9dadf8c355721e6f565" translate="yes" xml:space="preserve">
          <source>This header supplies implementation-dependent information about the standard library (such as implementation-specific library version macros).</source>
          <target state="translated">Этот заголовок содержит зависящую от реализации информацию о стандартной библиотеке (например,макросы версии библиотеки,зависящей от реализации).</target>
        </trans-unit>
        <trans-unit id="e3d2a98c9481a36d1f279d320f5b70a26a7e3330" translate="yes" xml:space="preserve">
          <source>This header was originally in the C standard library as &lt;code&gt;&amp;lt;assert.h&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">Этот заголовок изначально был в стандартной библиотеке C как &lt;code&gt;&amp;lt;assert.h&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9a392d9aa2ebe01e48b3d01961d845f5d0588e04" translate="yes" xml:space="preserve">
          <source>This header was originally in the C standard library as &lt;code&gt;&amp;lt;complex.h&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">Этот заголовок изначально был в стандартной библиотеке C как &lt;code&gt;&amp;lt;complex.h&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="21d14ed988bc023e0af2e53864603e6cda2885be" translate="yes" xml:space="preserve">
          <source>This header was originally in the C standard library as &lt;code&gt;&amp;lt;ctype.h&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">Этот заголовок изначально был в стандартной библиотеке C как &lt;code&gt;&amp;lt;ctype.h&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="68c78f91644f281b447ad60cdbb1634c09a9119a" translate="yes" xml:space="preserve">
          <source>This header was originally in the C standard library as &lt;code&gt;&amp;lt;errno.h&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">Этот заголовок изначально был в стандартной библиотеке C как &lt;code&gt;&amp;lt;errno.h&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="02e483f5fd629df3b87fff596e49a80d8b8c0425" translate="yes" xml:space="preserve">
          <source>This header was originally in the C standard library as &lt;code&gt;&amp;lt;fenv.h&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">Этот заголовок изначально был в стандартной библиотеке C как &lt;code&gt;&amp;lt;fenv.h&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e6e03bbb8695dbcceecc16e98c0e964b5fefd852" translate="yes" xml:space="preserve">
          <source>This header was originally in the C standard library as &lt;code&gt;&amp;lt;float.h&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">Этот заголовок изначально был в стандартной библиотеке C как &lt;code&gt;&amp;lt;float.h&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d59783125b891e429043f2f2d5f576fd72a06c1c" translate="yes" xml:space="preserve">
          <source>This header was originally in the C standard library as &lt;code&gt;&amp;lt;inttypes.h&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">Этот заголовок изначально был в стандартной библиотеке C как &lt;code&gt;&amp;lt;inttypes.h&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="02fccbdf35494b28df2accdc8d41b5a89580c3c0" translate="yes" xml:space="preserve">
          <source>This header was originally in the C standard library as &lt;code&gt;&amp;lt;iso646.h&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">Этот заголовок изначально был в стандартной библиотеке C как &lt;code&gt;&amp;lt;iso646.h&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="db14ba2bad874c7dde2374ac32527f2c381efc33" translate="yes" xml:space="preserve">
          <source>This header was originally in the C standard library as &lt;code&gt;&amp;lt;limits.h&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">Этот заголовок изначально был в стандартной библиотеке C как &lt;code&gt;&amp;lt;limits.h&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="53af078bd74b84f0423e1e9211b917adea77b920" translate="yes" xml:space="preserve">
          <source>This header was originally in the C standard library as &lt;code&gt;&amp;lt;locale.h&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">Этот заголовок изначально был в стандартной библиотеке C как &lt;code&gt;&amp;lt;locale.h&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4fc6197b328bad98f05fff68010e58025c14a9b1" translate="yes" xml:space="preserve">
          <source>This header was originally in the C standard library as &lt;code&gt;&amp;lt;math.h&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">Этот заголовок изначально был в стандартной библиотеке C как &lt;code&gt;&amp;lt;math.h&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="98d8ce7d2ea217c30464e6a8895e55e50e6eb6dd" translate="yes" xml:space="preserve">
          <source>This header was originally in the C standard library as &lt;code&gt;&amp;lt;setjmp.h&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">Этот заголовок изначально был в стандартной библиотеке C как &lt;code&gt;&amp;lt;setjmp.h&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4db152ded5e9f8b82696d238d20533a05044bdc8" translate="yes" xml:space="preserve">
          <source>This header was originally in the C standard library as &lt;code&gt;&amp;lt;signal.h&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">Этот заголовок изначально был в стандартной библиотеке C как &lt;code&gt;&amp;lt;signal.h&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="dbf2ebc0d4f0372f0d23dcfc1ff48e2cc5e172fa" translate="yes" xml:space="preserve">
          <source>This header was originally in the C standard library as &lt;code&gt;&amp;lt;stdalign.h&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">Этот заголовок изначально был в стандартной библиотеке C как &lt;code&gt;&amp;lt;stdalign.h&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="552c8fb5c454bd957020620ff32c98f913c6ec6f" translate="yes" xml:space="preserve">
          <source>This header was originally in the C standard library as &lt;code&gt;&amp;lt;stdarg.h&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">Этот заголовок изначально был в стандартной библиотеке C как &lt;code&gt;&amp;lt;stdarg.h&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f1fc778831b537c9627fb3177ad740d51c764464" translate="yes" xml:space="preserve">
          <source>This header was originally in the C standard library as &lt;code&gt;&amp;lt;stdbool.h&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">Этот заголовок изначально был в стандартной библиотеке C как &lt;code&gt;&amp;lt;stdbool.h&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ea55cad81c5a499ab61c2f336f793e79c2cde22b" translate="yes" xml:space="preserve">
          <source>This header was originally in the C standard library as &lt;code&gt;&amp;lt;stddef.h&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">Этот заголовок изначально был в стандартной библиотеке C как &lt;code&gt;&amp;lt;stddef.h&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c4e4679e2a1edfcea3588f047e41db14f9335c2e" translate="yes" xml:space="preserve">
          <source>This header was originally in the C standard library as &lt;code&gt;&amp;lt;stdint.h&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">Этот заголовок изначально был в стандартной библиотеке C как &lt;code&gt;&amp;lt;stdint.h&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b100c9fc2e0568f0798665b7418667c38edba953" translate="yes" xml:space="preserve">
          <source>This header was originally in the C standard library as &lt;code&gt;&amp;lt;stdio.h&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">Этот заголовок изначально был в стандартной библиотеке C как &lt;code&gt;&amp;lt;stdio.h&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f9724180e3c20c4e3ccde319664bad3907db8ef2" translate="yes" xml:space="preserve">
          <source>This header was originally in the C standard library as &lt;code&gt;&amp;lt;stdlib.h&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">Этот заголовок изначально был в стандартной библиотеке C как &lt;code&gt;&amp;lt;stdlib.h&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6d57c16a998701ee531191c284ccfc0598fb9ad8" translate="yes" xml:space="preserve">
          <source>This header was originally in the C standard library as &lt;code&gt;&amp;lt;string.h&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">Этот заголовок изначально был в стандартной библиотеке C как &lt;code&gt;&amp;lt;string.h&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="aeb4dad38844729f6a773adfa6b26a2500e3724e" translate="yes" xml:space="preserve">
          <source>This header was originally in the C standard library as &lt;code&gt;&amp;lt;tgmath.h&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">Этот заголовок изначально был в стандартной библиотеке C как &lt;code&gt;&amp;lt;tgmath.h&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="78466c124900e096d16d9eac15396f90464c889b" translate="yes" xml:space="preserve">
          <source>This header was originally in the C standard library as &lt;code&gt;&amp;lt;time.h&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">Этот заголовок изначально был в стандартной библиотеке C как &lt;code&gt;&amp;lt;time.h&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1bc1e66e0693def74a913c9f83e9fd4b6579b986" translate="yes" xml:space="preserve">
          <source>This header was originally in the C standard library as &lt;code&gt;&amp;lt;uchar.h&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">Этот заголовок изначально был в стандартной библиотеке C как &lt;code&gt;&amp;lt;uchar.h&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a2e4ff735f64305108a77807fb191c4cc62d9e14" translate="yes" xml:space="preserve">
          <source>This header was originally in the C standard library as &lt;code&gt;&amp;lt;wchar.h&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">Этот заголовок изначально был в стандартной библиотеке C как &lt;code&gt;&amp;lt;wchar.h&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="16d7a74374a4accebff96ae1f6f2de097d3b0cae" translate="yes" xml:space="preserve">
          <source>This header was originally in the C standard library as &lt;code&gt;&amp;lt;wctype.h&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">Этот заголовок изначально был в стандартной библиотеке C как &lt;code&gt;&amp;lt;wctype.h&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="aedb64fc9e75ef3b36a2ef43e03fc20db3e03e5b" translate="yes" xml:space="preserve">
          <source>This holds for every objects &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; that are not aliases of one another.</source>
          <target state="translated">Это верно для всех объектов &lt;code&gt;a&lt;/code&gt; и &lt;code&gt;b&lt;/code&gt; , которые не являются псевдонимами друг друга.</target>
        </trans-unit>
        <trans-unit id="05ebbbf417474068cc1404af21d2b363f30ea1c1" translate="yes" xml:space="preserve">
          <source>This implies that the class has no &lt;a href=&quot;../language/virtual&quot;&gt;virtual functions&lt;/a&gt; or &lt;a href=&quot;../language/derived_class#Virtual_base_classes&quot;&gt;virtual base classes&lt;/a&gt;.</source>
          <target state="translated">Это подразумевает, что у класса нет &lt;a href=&quot;../language/virtual&quot;&gt;виртуальных функций&lt;/a&gt; или &lt;a href=&quot;../language/derived_class#Virtual_base_classes&quot;&gt;виртуальных базовых классов&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2f0ae52b3b410d1e9be7d3f883c6f57fc4873c3a" translate="yes" xml:space="preserve">
          <source>This includes &lt;a href=&quot;type-id&quot;&gt;integral types&lt;/a&gt;, &lt;a href=&quot;pointer&quot;&gt;pointer types&lt;/a&gt;, &lt;a href=&quot;pointer#Pointers_to_members&quot;&gt;pointer to member type&lt;/a&gt;, &lt;code&gt;&lt;a href=&quot;../types/nullptr_t&quot;&gt;std::nullptr_t&lt;/a&gt;&lt;/code&gt;, as well as enumeration types with no custom &lt;code&gt;operator&amp;lt;=&amp;gt;&lt;/code&gt; overload, but excludes floating-point types.</source>
          <target state="translated">Это включает в себя &lt;a href=&quot;type-id&quot;&gt;целочисленные типы&lt;/a&gt; , типы &lt;a href=&quot;pointer&quot;&gt;указателей&lt;/a&gt; , &lt;a href=&quot;pointer#Pointers_to_members&quot;&gt;указатель на тип члена&lt;/a&gt; , &lt;code&gt;&lt;a href=&quot;../types/nullptr_t&quot;&gt;std::nullptr_t&lt;/a&gt;&lt;/code&gt; , а также типы перечисления без перегрузки пользовательского &lt;code&gt;operator&amp;lt;=&amp;gt;&lt;/code&gt; , но исключая типы с плавающей точкой.</target>
        </trans-unit>
        <trans-unit id="d9b2e0a6f64a6667926bbe46e5290f95959e8907" translate="yes" xml:space="preserve">
          <source>This information is provided via specializations of the &lt;code&gt;numeric_limits&lt;/code&gt; template. The standard library makes available specializations for all arithmetic types:</source>
          <target state="translated">Эта информация предоставляется через специализации шаблона &lt;code&gt;numeric_limits&lt;/code&gt; . Стандартная библиотека делает доступными специализации для всех арифметических типов:</target>
        </trans-unit>
        <trans-unit id="30fa8f162edae84e00655c850b76032946d786f6" translate="yes" xml:space="preserve">
          <source>This is a &lt;a href=&quot;https://en.cppreference.com/mwiki/index.php?title=cpp/iterator/BidirectionalIterator&amp;amp;action=edit&amp;amp;redlink=1&quot;&gt;&lt;code&gt;BidirectionalIterator&lt;/code&gt;&lt;/a&gt; if &lt;code&gt;V&lt;/code&gt; models &lt;a href=&quot;bidirectionalrange&quot;&gt;&lt;code&gt;BidirectionalRange&lt;/code&gt;&lt;/a&gt;, a &lt;a href=&quot;https://en.cppreference.com/mwiki/index.php?title=cpp/iterator/ForwardIterator&amp;amp;action=edit&amp;amp;redlink=1&quot;&gt;&lt;code&gt;ForwardIterator&lt;/code&gt;&lt;/a&gt; if &lt;code&gt;V&lt;/code&gt; models &lt;a href=&quot;forwardrange&quot;&gt;&lt;code&gt;ForwardRange&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;https://en.cppreference.com/mwiki/index.php?title=cpp/iterator/InputIterator&amp;amp;action=edit&amp;amp;redlink=1&quot;&gt;&lt;code&gt;InputIterator&lt;/code&gt;&lt;/a&gt; otherwise.</source>
          <target state="translated">Это &lt;a href=&quot;https://en.cppreference.com/mwiki/index.php?title=cpp/iterator/BidirectionalIterator&amp;amp;action=edit&amp;amp;redlink=1&quot;&gt; &lt;code&gt;BidirectionalIterator&lt;/code&gt; ,&lt;/a&gt; если &lt;code&gt;V&lt;/code&gt; моделирует &lt;a href=&quot;bidirectionalrange&quot;&gt; &lt;code&gt;BidirectionalRange&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;https://en.cppreference.com/mwiki/index.php?title=cpp/iterator/ForwardIterator&amp;amp;action=edit&amp;amp;redlink=1&quot;&gt; &lt;code&gt;ForwardIterator&lt;/code&gt; ,&lt;/a&gt; если &lt;code&gt;V&lt;/code&gt; моделирует &lt;a href=&quot;forwardrange&quot;&gt; &lt;code&gt;ForwardRange&lt;/code&gt; &lt;/a&gt; , и &lt;a href=&quot;https://en.cppreference.com/mwiki/index.php?title=cpp/iterator/InputIterator&amp;amp;action=edit&amp;amp;redlink=1&quot;&gt; &lt;code&gt;InputIterator&lt;/code&gt; в&lt;/a&gt; противном случае.</target>
        </trans-unit>
        <trans-unit id="8b29d4dc98b35c7b6aae2a923e6c330c4c737570" translate="yes" xml:space="preserve">
          <source>This is a &lt;a href=&quot;https://en.cppreference.com/mwiki/index.php?title=cpp/iterator/RandomAccessIterator&amp;amp;action=edit&amp;amp;redlink=1&quot;&gt;&lt;code&gt;RandomAccessIterator&lt;/code&gt;&lt;/a&gt; if &lt;code&gt;W&lt;/code&gt; models _Advanceable, a &lt;a href=&quot;https://en.cppreference.com/mwiki/index.php?title=cpp/iterator/BidirectionalIterator&amp;amp;action=edit&amp;amp;redlink=1&quot;&gt;&lt;code&gt;BidirectionalIterator&lt;/code&gt;&lt;/a&gt; if &lt;code&gt;W&lt;/code&gt; models _Decrementable, a &lt;a href=&quot;https://en.cppreference.com/mwiki/index.php?title=cpp/iterator/ForwardIterator&amp;amp;action=edit&amp;amp;redlink=1&quot;&gt;&lt;code&gt;ForwardIterator&lt;/code&gt;&lt;/a&gt; if &lt;code&gt;W&lt;/code&gt; models &lt;a href=&quot;https://en.cppreference.com/mwiki/index.php?title=cpp/iterator/Incrementable&amp;amp;action=edit&amp;amp;redlink=1&quot;&gt;&lt;code&gt;Incrementable&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;https://en.cppreference.com/mwiki/index.php?title=cpp/iterator/InputIterator&amp;amp;action=edit&amp;amp;redlink=1&quot;&gt;&lt;code&gt;InputIterator&lt;/code&gt;&lt;/a&gt; otherwise.</source>
          <target state="translated">Это &lt;a href=&quot;https://en.cppreference.com/mwiki/index.php?title=cpp/iterator/RandomAccessIterator&amp;amp;action=edit&amp;amp;redlink=1&quot;&gt; &lt;code&gt;RandomAccessIterator&lt;/code&gt; ,&lt;/a&gt; если &lt;code&gt;W&lt;/code&gt; моделирует _Advanceable, &lt;a href=&quot;https://en.cppreference.com/mwiki/index.php?title=cpp/iterator/BidirectionalIterator&amp;amp;action=edit&amp;amp;redlink=1&quot;&gt; &lt;code&gt;BidirectionalIterator&lt;/code&gt; ,&lt;/a&gt; если &lt;code&gt;W&lt;/code&gt; моделирует _Decrementable, &lt;a href=&quot;https://en.cppreference.com/mwiki/index.php?title=cpp/iterator/ForwardIterator&amp;amp;action=edit&amp;amp;redlink=1&quot;&gt; &lt;code&gt;ForwardIterator&lt;/code&gt; ,&lt;/a&gt; если &lt;code&gt;W&lt;/code&gt; моделирует &lt;a href=&quot;https://en.cppreference.com/mwiki/index.php?title=cpp/iterator/Incrementable&amp;amp;action=edit&amp;amp;redlink=1&quot;&gt; &lt;code&gt;Incrementable&lt;/code&gt; &lt;/a&gt; , и &lt;a href=&quot;https://en.cppreference.com/mwiki/index.php?title=cpp/iterator/InputIterator&amp;amp;action=edit&amp;amp;redlink=1&quot;&gt; &lt;code&gt;InputIterator&lt;/code&gt; в&lt;/a&gt; противном случае.</target>
        </trans-unit>
        <trans-unit id="ab311fc847c477a15d5b1d9860db2b6b4cc68c90" translate="yes" xml:space="preserve">
          <source>This is a copy of the the private mutable &lt;code&gt;weak_ptr&lt;/code&gt; member that is part of &lt;code&gt;enable_shared_from_this&lt;/code&gt;.</source>
          <target state="translated">Это копия закрытого изменяемого члена &lt;code&gt;weak_ptr&lt;/code&gt; , который является частью &lt;code&gt;enable_shared_from_this&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9c2a70dd0a39c1457e77f347c24e87c6d5cad7cb" translate="yes" xml:space="preserve">
          <source>This is a list of reserved keywords in C++. Since they are used by the language, these keywords are not available for re-definition or overloading.</source>
          <target state="translated">Это список зарезервированных ключевых слов на C++.Так как они используются языком,эти ключевые слова недоступны для переопределения или перегрузки.</target>
        </trans-unit>
        <trans-unit id="317fe1d241fce7e8d40b91008c64f80e35d56f6c" translate="yes" xml:space="preserve">
          <source>This is a low-level data structure; typical conversions from &lt;code&gt;local_time&lt;/code&gt; to &lt;code&gt;sys_time&lt;/code&gt; will use it implicitly rather than explicitly.</source>
          <target state="translated">Это низкоуровневая структура данных; типичные преобразования из &lt;code&gt;local_time&lt;/code&gt; в &lt;code&gt;sys_time&lt;/code&gt; будут использовать его не явно, а явно.</target>
        </trans-unit>
        <trans-unit id="06fb932be30caede5a481a8189299e404a6d4974" translate="yes" xml:space="preserve">
          <source>This is a reference of the core C++ language constructs.</source>
          <target state="translated">Это ссылка на основные конструкции языка Си++.</target>
        </trans-unit>
        <trans-unit id="e31b548ee1fbca7fa6d3494affb746a0a1a2457c" translate="yes" xml:space="preserve">
          <source>This is a special value equal to the largest value representable by the type &lt;code&gt;std::size_t&lt;/code&gt;, used as the return type of &lt;code&gt;index()&lt;/code&gt; when &lt;code&gt;valueless_by_exception()&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">Это специальное значение, равное наибольшему значению, представляемому типом &lt;code&gt;std::size_t&lt;/code&gt; , используемое в качестве возвращаемого типа &lt;code&gt;index()&lt;/code&gt; когда &lt;code&gt;valueless_by_exception()&lt;/code&gt; имеет значение &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a39c0c855473751858895d7068c8ca7b082d5f62" translate="yes" xml:space="preserve">
          <source>This is a special value equal to the maximum value representable by the type &lt;code&gt;size_type&lt;/code&gt;. The exact meaning depends on context, but it is generally used either as end of string indicator by the functions that expect a string index or as the error indicator by the functions that return a string index.</source>
          <target state="translated">Это специальное значение, равное максимальному значению, представляемому типом &lt;code&gt;size_type&lt;/code&gt; . Точное значение зависит от контекста, но обычно оно используется либо как индикатор конца строки функциями, которые ожидают индекс строки, либо как индикатор ошибки функциями, которые возвращают индекс строки.</target>
        </trans-unit>
        <trans-unit id="8ef208e1bc26501dbfeecb667b7796cbd9eef4a6" translate="yes" xml:space="preserve">
          <source>This is a special value equal to the maximum value representable by the type &lt;code&gt;size_type&lt;/code&gt;. The exact meaning depends on context, but it is generally used either as end of view indicator by the functions that expect a view index or as the error indicator by the functions that return a view index.</source>
          <target state="translated">Это специальное значение, равное максимальному значению, представляемому типом &lt;code&gt;size_type&lt;/code&gt; . Точное значение зависит от контекста, но обычно оно используется либо как индикатор конца представления функциями, которые ожидают индекс представления, либо как индикатор ошибки функциями, которые возвращают индекс представления.</target>
        </trans-unit>
        <trans-unit id="2d9f89f3207c56d0f6ab075de354388d63d28553" translate="yes" xml:space="preserve">
          <source>This is a specialized allocator-aware container. It can only be default created, obtained from &lt;code&gt;&lt;a href=&quot;regex_iterator&quot;&gt;std::regex_iterator&lt;/a&gt;&lt;/code&gt;, or modified by &lt;code&gt;&lt;a href=&quot;regex_search&quot;&gt;std::regex_search&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;regex_match&quot;&gt;std::regex_match&lt;/a&gt;&lt;/code&gt;. Because &lt;code&gt;std::match_results&lt;/code&gt; holds &lt;code&gt;&lt;a href=&quot;sub_match&quot;&gt;std::sub_match&lt;/a&gt;&lt;/code&gt;es, each of which is a pair of iterators into the original character sequence that was matched, it's undefined behavior to examine &lt;code&gt;std::match_results&lt;/code&gt; if the original character sequence was destroyed or iterators to it were invalidated for other reasons.</source>
          <target state="translated">Это специализированный контейнер с поддержкой распределителя. Он может быть создан только по умолчанию, получен из &lt;code&gt;&lt;a href=&quot;regex_iterator&quot;&gt;std::regex_iterator&lt;/a&gt;&lt;/code&gt; или изменен с помощью &lt;code&gt;&lt;a href=&quot;regex_search&quot;&gt;std::regex_search&lt;/a&gt;&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;regex_match&quot;&gt;std::regex_match&lt;/a&gt;&lt;/code&gt; . Поскольку &lt;code&gt;std::match_results&lt;/code&gt; содержит &lt;code&gt;&lt;a href=&quot;sub_match&quot;&gt;std::sub_match&lt;/a&gt;&lt;/code&gt; es, каждый из которых представляет собой пару итераторов в исходную последовательность символов, которая была сопоставлена, то неопределенное поведение - проверять &lt;code&gt;std::match_results&lt;/code&gt; если исходная последовательность символов была уничтожена или итераторы к ней были признан недействительным по другим причинам.</target>
        </trans-unit>
        <trans-unit id="dcbd4929cfc88985415e596c60e165a57a093570" translate="yes" xml:space="preserve">
          <source>This is an I/O manipulator, it may be called with an expression such as &lt;code&gt;out &amp;lt;&amp;lt; std::fixed&lt;/code&gt; for any &lt;code&gt;out&lt;/code&gt; of type &lt;code&gt;&lt;a href=&quot;../basic_ostream&quot;&gt;std::basic_ostream&lt;/a&gt;&lt;/code&gt; or with an expression such as &lt;code&gt;in &amp;gt;&amp;gt; std::scientific&lt;/code&gt; for any &lt;code&gt;in&lt;/code&gt; of type &lt;code&gt;&lt;a href=&quot;../basic_istream&quot;&gt;std::basic_istream&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Это I / O манипулятором, его можно назвать с выражением таких как &lt;code&gt;out &amp;lt;&amp;lt; std::fixed&lt;/code&gt; для любого &lt;code&gt;out&lt;/code&gt; типа &lt;code&gt;&lt;a href=&quot;../basic_ostream&quot;&gt;std::basic_ostream&lt;/a&gt;&lt;/code&gt; или с выражением таких как &lt;code&gt;in &amp;gt;&amp;gt; std::scientific&lt;/code&gt; для любого &lt;code&gt;in&lt;/code&gt; из тип &lt;code&gt;&lt;a href=&quot;../basic_istream&quot;&gt;std::basic_istream&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="937bf19df4c0af79385dda35f013197f369e8f37" translate="yes" xml:space="preserve">
          <source>This is an I/O manipulator, it may be called with an expression such as &lt;code&gt;out &amp;lt;&amp;lt; std::noskipws&lt;/code&gt; for any &lt;code&gt;out&lt;/code&gt; of type &lt;code&gt;&lt;a href=&quot;../basic_ostream&quot;&gt;std::basic_ostream&lt;/a&gt;&lt;/code&gt; or with an expression such as &lt;code&gt;in &amp;gt;&amp;gt; std::noskipws&lt;/code&gt; for any &lt;code&gt;in&lt;/code&gt; of type &lt;code&gt;&lt;a href=&quot;../basic_istream&quot;&gt;std::basic_istream&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Это I / O манипулятором, его можно назвать с выражением таких как &lt;code&gt;out &amp;lt;&amp;lt; std::noskipws&lt;/code&gt; для любого &lt;code&gt;out&lt;/code&gt; типа &lt;code&gt;&lt;a href=&quot;../basic_ostream&quot;&gt;std::basic_ostream&lt;/a&gt;&lt;/code&gt; или с выражением таких как &lt;code&gt;in &amp;gt;&amp;gt; std::noskipws&lt;/code&gt; для любого &lt;code&gt;in&lt;/code&gt; из тип &lt;code&gt;&lt;a href=&quot;../basic_istream&quot;&gt;std::basic_istream&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b42315a6cd8a7f333df8749952b733651d2fec90" translate="yes" xml:space="preserve">
          <source>This is an I/O manipulator, it may be called with an expression such as &lt;code&gt;out &amp;lt;&amp;lt; std::showbase&lt;/code&gt; for any &lt;code&gt;out&lt;/code&gt; of type &lt;code&gt;&lt;a href=&quot;../basic_ostream&quot;&gt;std::basic_ostream&lt;/a&gt;&lt;/code&gt; or with an expression such as &lt;code&gt;in &amp;gt;&amp;gt; std::showbase&lt;/code&gt; for any &lt;code&gt;in&lt;/code&gt; of type &lt;code&gt;&lt;a href=&quot;../basic_istream&quot;&gt;std::basic_istream&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Это I / O манипулятором, его можно назвать с выражением такого как &lt;code&gt;out &amp;lt;&amp;lt; std::showbase&lt;/code&gt; для любого &lt;code&gt;out&lt;/code&gt; типа &lt;code&gt;&lt;a href=&quot;../basic_ostream&quot;&gt;std::basic_ostream&lt;/a&gt;&lt;/code&gt; или с выражением такой как &lt;code&gt;in &amp;gt;&amp;gt; std::showbase&lt;/code&gt; для любого &lt;code&gt;in&lt;/code&gt; из тип &lt;code&gt;&lt;a href=&quot;../basic_istream&quot;&gt;std::basic_istream&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="70463fd9c90aded7947bc0ce3158695492cf938d" translate="yes" xml:space="preserve">
          <source>This is an I/O manipulator, it may be called with an expression such as &lt;code&gt;out &amp;lt;&amp;lt; std::showpoint&lt;/code&gt; for any &lt;code&gt;out&lt;/code&gt; of type &lt;code&gt;&lt;a href=&quot;../basic_ostream&quot;&gt;std::basic_ostream&lt;/a&gt;&lt;/code&gt; or with an expression such as &lt;code&gt;in &amp;gt;&amp;gt; std::showpoint&lt;/code&gt; for any &lt;code&gt;in&lt;/code&gt; of type &lt;code&gt;&lt;a href=&quot;../basic_istream&quot;&gt;std::basic_istream&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Это I / O манипулятором, его можно назвать с выражением такого как &lt;code&gt;out &amp;lt;&amp;lt; std::showpoint&lt;/code&gt; для любого &lt;code&gt;out&lt;/code&gt; типа &lt;code&gt;&lt;a href=&quot;../basic_ostream&quot;&gt;std::basic_ostream&lt;/a&gt;&lt;/code&gt; или с таким выражением, как &lt;code&gt;in &amp;gt;&amp;gt; std::showpoint&lt;/code&gt; для любого &lt;code&gt;in&lt;/code&gt; из тип &lt;code&gt;&lt;a href=&quot;../basic_istream&quot;&gt;std::basic_istream&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bf76b611f62f218dd5340fb19c1a0b0493038e0e" translate="yes" xml:space="preserve">
          <source>This is an I/O manipulator, it may be called with an expression such as &lt;code&gt;out &amp;lt;&amp;lt; std::showpos&lt;/code&gt; for any &lt;code&gt;out&lt;/code&gt; of type &lt;code&gt;&lt;a href=&quot;../basic_ostream&quot;&gt;std::basic_ostream&lt;/a&gt;&lt;/code&gt; or with an expression such as &lt;code&gt;in &amp;gt;&amp;gt; std::showpos&lt;/code&gt; for any &lt;code&gt;in&lt;/code&gt; of type &lt;code&gt;&lt;a href=&quot;../basic_istream&quot;&gt;std::basic_istream&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Это I / O манипулятором, его можно назвать с выражением таких как &lt;code&gt;out &amp;lt;&amp;lt; std::showpos&lt;/code&gt; для любого &lt;code&gt;out&lt;/code&gt; типа &lt;code&gt;&lt;a href=&quot;../basic_ostream&quot;&gt;std::basic_ostream&lt;/a&gt;&lt;/code&gt; или с выражением таких как &lt;code&gt;in &amp;gt;&amp;gt; std::showpos&lt;/code&gt; для любого &lt;code&gt;in&lt;/code&gt; из тип &lt;code&gt;&lt;a href=&quot;../basic_istream&quot;&gt;std::basic_istream&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4b963cb12fe265e17a4ede1e827c0c6875636dad" translate="yes" xml:space="preserve">
          <source>This is an I/O manipulator, it may be called with an expression such as &lt;code&gt;out &amp;lt;&amp;lt; std::unitbuf&lt;/code&gt; for any &lt;code&gt;out&lt;/code&gt; of type &lt;code&gt;&lt;a href=&quot;../basic_ostream&quot;&gt;std::basic_ostream&lt;/a&gt;&lt;/code&gt; or with an expression such as &lt;code&gt;in &amp;gt;&amp;gt; std::unitbuf&lt;/code&gt; for any &lt;code&gt;in&lt;/code&gt; of type &lt;code&gt;&lt;a href=&quot;../basic_istream&quot;&gt;std::basic_istream&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Это I / O манипулятором, его можно назвать с выражением такого как &lt;code&gt;out &amp;lt;&amp;lt; std::unitbuf&lt;/code&gt; для любого &lt;code&gt;out&lt;/code&gt; типа &lt;code&gt;&lt;a href=&quot;../basic_ostream&quot;&gt;std::basic_ostream&lt;/a&gt;&lt;/code&gt; или с таким выражением, как &lt;code&gt;in &amp;gt;&amp;gt; std::unitbuf&lt;/code&gt; для любого &lt;code&gt;in&lt;/code&gt; из тип &lt;code&gt;&lt;a href=&quot;../basic_istream&quot;&gt;std::basic_istream&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="dc0de5a017268c93f9adb1760286b7389369587a" translate="yes" xml:space="preserve">
          <source>This is an I/O manipulator, it may be called with an expression such as &lt;code&gt;out &amp;lt;&amp;lt; std::uppercase&lt;/code&gt; for any &lt;code&gt;out&lt;/code&gt; of type &lt;code&gt;&lt;a href=&quot;../basic_ostream&quot;&gt;std::basic_ostream&lt;/a&gt;&lt;/code&gt; or with an expression such as &lt;code&gt;in &amp;gt;&amp;gt; std::uppercase&lt;/code&gt; for any &lt;code&gt;in&lt;/code&gt; of type &lt;code&gt;&lt;a href=&quot;../basic_istream&quot;&gt;std::basic_istream&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Это I / O манипулятором, его можно назвать с выражением такого как &lt;code&gt;out &amp;lt;&amp;lt; std::uppercase&lt;/code&gt; для любого &lt;code&gt;out&lt;/code&gt; типа &lt;code&gt;&lt;a href=&quot;../basic_ostream&quot;&gt;std::basic_ostream&lt;/a&gt;&lt;/code&gt; или с таким выражением, как &lt;code&gt;in &amp;gt;&amp;gt; std::uppercase&lt;/code&gt; для любого &lt;code&gt;in&lt;/code&gt; из тип &lt;code&gt;&lt;a href=&quot;../basic_istream&quot;&gt;std::basic_istream&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="daf2205ff27f5d190edd20850443509692eb70e0" translate="yes" xml:space="preserve">
          <source>This is an I/O manipulator. It may be called with an expression such as &lt;code&gt;out &amp;lt;&amp;lt; std::hex&lt;/code&gt; for any &lt;code&gt;out&lt;/code&gt; of type &lt;code&gt;&lt;a href=&quot;../basic_ostream&quot;&gt;std::basic_ostream&lt;/a&gt;&lt;/code&gt; or with an expression such as &lt;code&gt;in &amp;gt;&amp;gt; std::hex&lt;/code&gt; for any &lt;code&gt;in&lt;/code&gt; of type &lt;code&gt;&lt;a href=&quot;../basic_istream&quot;&gt;std::basic_istream&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Это манипулятор ввода / вывода. Он может быть вызван с помощью выражения, такого как &lt;code&gt;out &amp;lt;&amp;lt; std::hex&lt;/code&gt; для любого типа &lt;code&gt;out&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;../basic_ostream&quot;&gt;std::basic_ostream&lt;/a&gt;&lt;/code&gt; или с выражением, таким как &lt;code&gt;in &amp;gt;&amp;gt; std::hex&lt;/code&gt; для любого типа &lt;code&gt;in&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;../basic_istream&quot;&gt;std::basic_istream&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c9f3502e7e7df95e12c9da2ae171edd9ba6a04db" translate="yes" xml:space="preserve">
          <source>This is an I/O manipulator. It may be called with an expression such as &lt;code&gt;out &amp;lt;&amp;lt; std::left&lt;/code&gt; for any &lt;code&gt;out&lt;/code&gt; of type &lt;code&gt;&lt;a href=&quot;../basic_ostream&quot;&gt;std::basic_ostream&lt;/a&gt;&lt;/code&gt; or with an expression such as &lt;code&gt;in &amp;gt;&amp;gt; std::left&lt;/code&gt; for any &lt;code&gt;in&lt;/code&gt; of type &lt;code&gt;&lt;a href=&quot;../basic_istream&quot;&gt;std::basic_istream&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Это манипулятор ввода / вывода. Он может быть вызван с помощью выражения, такого как &lt;code&gt;out &amp;lt;&amp;lt; std::left&lt;/code&gt; для любого типа &lt;code&gt;out&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;../basic_ostream&quot;&gt;std::basic_ostream&lt;/a&gt;&lt;/code&gt; или с выражением, таким как &lt;code&gt;in &amp;gt;&amp;gt; std::left&lt;/code&gt; для любого типа &lt;code&gt;in&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;../basic_istream&quot;&gt;std::basic_istream&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4c0b02e3721ebe7f5ac3c4b5ffc6c0f2d28f4fc9" translate="yes" xml:space="preserve">
          <source>This is an N:M conversion facet, and cannot be used with &lt;code&gt;&lt;a href=&quot;../io/basic_filebuf&quot;&gt;std::basic_filebuf&lt;/a&gt;&lt;/code&gt; (which only permits 1:N conversions, such as UTF-32/UTF-8, between the internal and the external encodings). This facet can be used with &lt;code&gt;&lt;a href=&quot;wstring_convert&quot;&gt;std::wstring_convert&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Это аспект преобразования N: M, и его нельзя использовать с &lt;code&gt;&lt;a href=&quot;../io/basic_filebuf&quot;&gt;std::basic_filebuf&lt;/a&gt;&lt;/code&gt; (который разрешает только преобразования 1: N, такие как UTF-32 / UTF-8, между внутренним и внешним кодировками). Этот фасет можно использовать с &lt;code&gt;&lt;a href=&quot;wstring_convert&quot;&gt;std::wstring_convert&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8f532dd6dda7ce4e7fef9024ca6a90c38fdddd97" translate="yes" xml:space="preserve">
          <source>This is an input-only I/O manipulator, it may be called with an expression such as &lt;code&gt;in &amp;gt;&amp;gt; std::ws&lt;/code&gt; for any &lt;code&gt;in&lt;/code&gt; of type &lt;code&gt;&lt;a href=&quot;../basic_istream&quot;&gt;std::basic_istream&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Это манипулятор только для ввода ввода / вывода, она может быть вызвана с выражением , такой как &lt;code&gt;in &amp;gt;&amp;gt; std::ws&lt;/code&gt; для любого &lt;code&gt;in&lt;/code&gt; типа &lt;code&gt;&lt;a href=&quot;../basic_istream&quot;&gt;std::basic_istream&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e42acc2eabf231ad6ab330a8662f12700cd267a5" translate="yes" xml:space="preserve">
          <source>This is an output-only I/O manipulator, it may be called with an expression such as &lt;code&gt;out &amp;lt;&amp;lt; std::emit_on_flush&lt;/code&gt; for any &lt;code&gt;out&lt;/code&gt; of type &lt;code&gt;&lt;a href=&quot;../basic_ostream&quot;&gt;std::basic_ostream&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Это Манипулятор только для вывода ввода / вывода, она может быть вызвана с выражением , такие как &lt;code&gt;out &amp;lt;&amp;lt; std::emit_on_flush&lt;/code&gt; для любого &lt;code&gt;out&lt;/code&gt; типа &lt;code&gt;&lt;a href=&quot;../basic_ostream&quot;&gt;std::basic_ostream&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="60e12fb0d661bde8d9b081c1cd879d866b874d0f" translate="yes" xml:space="preserve">
          <source>This is an output-only I/O manipulator, it may be called with an expression such as &lt;code&gt;out &amp;lt;&amp;lt; std::endl&lt;/code&gt; for any &lt;code&gt;out&lt;/code&gt; of type &lt;code&gt;&lt;a href=&quot;../basic_ostream&quot;&gt;std::basic_ostream&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Это Манипулятор только для вывода ввода / вывода, она может быть вызвана с выражением , такие как &lt;code&gt;out &amp;lt;&amp;lt; std::endl&lt;/code&gt; , для любого &lt;code&gt;out&lt;/code&gt; типа &lt;code&gt;&lt;a href=&quot;../basic_ostream&quot;&gt;std::basic_ostream&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="651708b37cd7ae8cdbb511a6453c7ac66edb7063" translate="yes" xml:space="preserve">
          <source>This is an output-only I/O manipulator, it may be called with an expression such as &lt;code&gt;out &amp;lt;&amp;lt; std::ends&lt;/code&gt; for any &lt;code&gt;out&lt;/code&gt; of type &lt;code&gt;&lt;a href=&quot;../basic_ostream&quot;&gt;std::basic_ostream&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Это Манипулятор только для вывода ввода / вывода, она может быть вызвана с выражением , такие как &lt;code&gt;out &amp;lt;&amp;lt; std::ends&lt;/code&gt; для любого &lt;code&gt;out&lt;/code&gt; типа &lt;code&gt;&lt;a href=&quot;../basic_ostream&quot;&gt;std::basic_ostream&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cb0b93b12bb860d769cac7587fe1bddc043d0e17" translate="yes" xml:space="preserve">
          <source>This is an output-only I/O manipulator, it may be called with an expression such as &lt;code&gt;out &amp;lt;&amp;lt; std::flush&lt;/code&gt; for any &lt;code&gt;out&lt;/code&gt; of type &lt;code&gt;&lt;a href=&quot;../basic_ostream&quot;&gt;std::basic_ostream&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Это манипулятором только для вывода I / O, это можно назвать с выражением таких как &lt;code&gt;out &amp;lt;&amp;lt; std::flush&lt;/code&gt; для любого &lt;code&gt;out&lt;/code&gt; типа &lt;code&gt;&lt;a href=&quot;../basic_ostream&quot;&gt;std::basic_ostream&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="297f17cae564feba63e3617363eb17ca7ff29374" translate="yes" xml:space="preserve">
          <source>This is an output-only I/O manipulator, it may be called with an expression such as &lt;code&gt;out &amp;lt;&amp;lt; std::flush_emit&lt;/code&gt; for any &lt;code&gt;out&lt;/code&gt; of type &lt;code&gt;&lt;a href=&quot;../basic_ostream&quot;&gt;std::basic_ostream&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Это Манипулятор только для вывода ввода / вывода, она может быть вызвана с выражением , такие как &lt;code&gt;out &amp;lt;&amp;lt; std::flush_emit&lt;/code&gt; для любого &lt;code&gt;out&lt;/code&gt; типа &lt;code&gt;&lt;a href=&quot;../basic_ostream&quot;&gt;std::basic_ostream&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="042aa022f3538e0380d9238f1617babc4f91044d" translate="yes" xml:space="preserve">
          <source>This is done by calling &lt;code&gt;basic_iostream&amp;lt;CharT, Traits&amp;gt;::swap(other)&lt;/code&gt; and &lt;code&gt;rdbuf()-&amp;gt;swap(other.rdbuf())&lt;/code&gt;.</source>
          <target state="translated">Это делается путем вызова &lt;code&gt;basic_iostream&amp;lt;CharT, Traits&amp;gt;::swap(other)&lt;/code&gt; и &lt;code&gt;rdbuf()-&amp;gt;swap(other.rdbuf())&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6d1a687deef64a2de24aab2940536db537dc7c30" translate="yes" xml:space="preserve">
          <source>This is done by calling &lt;code&gt;basic_istream&amp;lt;CharT, Traits&amp;gt;::swap(other)&lt;/code&gt; and &lt;code&gt;rdbuf()-&amp;gt;swap(other.rdbuf())&lt;/code&gt;.</source>
          <target state="translated">Это делается путем вызова &lt;code&gt;basic_istream&amp;lt;CharT, Traits&amp;gt;::swap(other)&lt;/code&gt; и &lt;code&gt;rdbuf()-&amp;gt;swap(other.rdbuf())&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8519863f445ff4dc4073c63885010fc835c9d17f" translate="yes" xml:space="preserve">
          <source>This is done by calling &lt;code&gt;basic_ostream&amp;lt;CharT, Traits&amp;gt;::swap(other)&lt;/code&gt; and &lt;code&gt;rdbuf()-&amp;gt;swap(other.rdbuf())&lt;/code&gt;.</source>
          <target state="translated">Это делается путем вызова &lt;code&gt;basic_ostream&amp;lt;CharT, Traits&amp;gt;::swap(other)&lt;/code&gt; и &lt;code&gt;rdbuf()-&amp;gt;swap(other.rdbuf())&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="36ff5f6b7bbdd8db83afcceb063e1cc859a416c7" translate="yes" xml:space="preserve">
          <source>This is done by calling&lt;code&gt;basic_iostream&amp;lt;CharT, Traits&amp;gt;::swap(other)&lt;/code&gt; and &lt;code&gt;rdbuf()-&amp;gt;swap(*other.rdbuf())&lt;/code&gt;.</source>
          <target state="translated">Это делается путем вызова &lt;code&gt;basic_iostream&amp;lt;CharT, Traits&amp;gt;::swap(other)&lt;/code&gt; и &lt;code&gt;rdbuf()-&amp;gt;swap(*other.rdbuf())&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="82ad146be2cb4f18f794320cb99236e3f0e5a7de" translate="yes" xml:space="preserve">
          <source>This is done by calling&lt;code&gt;basic_istream&amp;lt;CharT, Traits&amp;gt;::swap(other)&lt;/code&gt; and &lt;code&gt;rdbuf()-&amp;gt;swap(*other.rdbuf())&lt;/code&gt;.</source>
          <target state="translated">Это делается путем вызова &lt;code&gt;basic_istream&amp;lt;CharT, Traits&amp;gt;::swap(other)&lt;/code&gt; и &lt;code&gt;rdbuf()-&amp;gt;swap(*other.rdbuf())&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="786b3029313db82a7b7425ea04d749d77cb88554" translate="yes" xml:space="preserve">
          <source>This is done by calling&lt;code&gt;basic_ostream&amp;lt;CharT, Traits&amp;gt;::swap(other)&lt;/code&gt; and &lt;code&gt;rdbuf()-&amp;gt;swap(*other.rdbuf())&lt;/code&gt;.</source>
          <target state="translated">Это делается путем вызова &lt;code&gt;basic_ostream&amp;lt;CharT, Traits&amp;gt;::swap(other)&lt;/code&gt; и &lt;code&gt;rdbuf()-&amp;gt;swap(*other.rdbuf())&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="acd8409ce8140988c0f9cd5273c17f072a8e1133" translate="yes" xml:space="preserve">
          <source>This is no longer allowed in C++17. Instead the array form &lt;code&gt;&lt;a href=&quot;../shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&amp;lt;T[]&amp;gt;&lt;/code&gt; should be used.</source>
          <target state="translated">Это больше не разрешено в C ++ 17. Вместо этого следует использовать форму массива &lt;code&gt;&lt;a href=&quot;../shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&amp;lt;T[]&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="873c5086291117573f8d6d6edce6a8a27dcea191" translate="yes" xml:space="preserve">
          <source>This is the case only for futures that were not default-constructed or moved from (i.e. returned by &lt;code&gt;&lt;a href=&quot;../promise/get_future&quot;&gt;std::promise::get_future()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../packaged_task/get_future&quot;&gt;std::packaged_task::get_future()&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../async&quot;&gt;std::async()&lt;/a&gt;&lt;/code&gt;) until the first time &lt;code&gt;&lt;a href=&quot;get&quot;&gt;get()&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;share&quot;&gt;share()&lt;/a&gt;&lt;/code&gt; is called.</source>
          <target state="translated">Это относится только к фьючерсам, которые не были построены по умолчанию или не были перемещены (т.е. возвращены &lt;code&gt;&lt;a href=&quot;../promise/get_future&quot;&gt;std::promise::get_future()&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../packaged_task/get_future&quot;&gt;std::packaged_task::get_future()&lt;/a&gt;&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;../async&quot;&gt;std::async()&lt;/a&gt;&lt;/code&gt; ) до первого время &lt;code&gt;&lt;a href=&quot;get&quot;&gt;get()&lt;/a&gt;&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;share&quot;&gt;share()&lt;/a&gt;&lt;/code&gt; вызывается.</target>
        </trans-unit>
        <trans-unit id="cf0f969d26a72355354c117d383b2d725eed3830" translate="yes" xml:space="preserve">
          <source>This is the case only for futures that were not default-constructed or moved from. Unlike &lt;code&gt;&lt;a href=&quot;../future&quot;&gt;std::future&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;std::shared_future&lt;/code&gt;'s shared state is not invalidated when &lt;code&gt;get()&lt;/code&gt; is called.</source>
          <target state="translated">Это относится только к фьючерсам, которые не были построены по умолчанию или перемещены из. В отличие от &lt;code&gt;&lt;a href=&quot;../future&quot;&gt;std::future&lt;/a&gt;&lt;/code&gt; , совместно используемое состояние &lt;code&gt;std::shared_future&lt;/code&gt; не аннулируется при вызове &lt;code&gt;get()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="654479f728093b995df666411bdb28aa8834e6ea" translate="yes" xml:space="preserve">
          <source>This is the class returned by the &lt;a href=&quot;../language/typeid&quot;&gt; typeid&lt;/a&gt; operator.</source>
          <target state="translated">Это класс, возвращаемый оператором &lt;a href=&quot;../language/typeid&quot;&gt;typeid&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a54fb420dbec256007f5b5fe39b66f1e973e225c" translate="yes" xml:space="preserve">
          <source>This is the class returned by the &lt;a href=&quot;language/typeid&quot;&gt; typeid&lt;/a&gt; operator.</source>
          <target state="translated">Это класс, возвращаемый оператором &lt;a href=&quot;language/typeid&quot;&gt;typeid&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b68e57b066a7bc6709ae7f2c462030b2b3f61772" translate="yes" xml:space="preserve">
          <source>This is the continuous counterpart of &lt;code&gt;&lt;a href=&quot;geometric_distribution&quot;&gt;std::geometric_distribution&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Это непрерывный аналог &lt;code&gt;&lt;a href=&quot;geometric_distribution&quot;&gt;std::geometric_distribution&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4bd023e111f5d2be5d722aa1cd31d0bb87464c42" translate="yes" xml:space="preserve">
          <source>This is the initialization performed when a variable is constructed with an empty initializer.</source>
          <target state="translated">Это инициализация,выполняемая при построении переменной с пустым инициализатором.</target>
        </trans-unit>
        <trans-unit id="e592a74f67ac1f9613e037ec54f2110302e91afd" translate="yes" xml:space="preserve">
          <source>This is the initialization performed when a variable is constructed with no initializer.</source>
          <target state="translated">Это инициализация,выполняемая при построении переменной без инициализатора.</target>
        </trans-unit>
        <trans-unit id="df01ca6b36b691a562048440349e8dc25830ccb7" translate="yes" xml:space="preserve">
          <source>This is the iterator returned by member functions &lt;code&gt;rbegin()&lt;/code&gt; and &lt;code&gt;rend()&lt;/code&gt; of the standard library containers.</source>
          <target state="translated">Это итератор, возвращаемый функциями- &lt;code&gt;rbegin()&lt;/code&gt; и &lt;code&gt;rend()&lt;/code&gt; стандартных контейнеров библиотеки.</target>
        </trans-unit>
        <trans-unit id="f5ad9a77cced8620a8dd7901ec2fb07df1c2718e" translate="yes" xml:space="preserve">
          <source>This is the only publicly accessible and defined constructor.</source>
          <target state="translated">Это единственный общедоступный и определенный конструктор.</target>
        </trans-unit>
        <trans-unit id="678d1fe5005da438d1e76e438f6b694064724ab0" translate="yes" xml:space="preserve">
          <source>This is the only way to initialize &lt;code&gt;&lt;a href=&quot;atomic_flag&quot;&gt;std::atomic_flag&lt;/a&gt;&lt;/code&gt; to a definite value: the value held after any other initialization is unspecified.</source>
          <target state="translated">Это единственный способ инициализировать &lt;code&gt;&lt;a href=&quot;atomic_flag&quot;&gt;std::atomic_flag&lt;/a&gt;&lt;/code&gt; определенным значением: значение, сохраненное после любой другой инициализации, не указано.</target>
        </trans-unit>
        <trans-unit id="812af2a36c3f95774b9b7221df53591bbffef4a8" translate="yes" xml:space="preserve">
          <source>This is typically possible for the characters from the ASCII character set, since most multibyte encodings (such as UTF-8) use single bytes to encode those characters.</source>
          <target state="translated">Обычно это возможно для символов из набора ASCII символов,так как большинство многобайтных кодировок (таких как UTF-8)используют для кодирования одни байты.</target>
        </trans-unit>
        <trans-unit id="4d2e82e79a4c00e49cbeb6cd456e401a3f7c67b6" translate="yes" xml:space="preserve">
          <source>This is used to capture move-only types with a capture such as &lt;code&gt;x = std::move(x)&lt;/code&gt;.</source>
          <target state="translated">Это используется для захвата только для перемещения типов с захватом, таким как &lt;code&gt;x = std::move(x)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0d03b82ce1e09a94b53a9663441cf142803eed2e" translate="yes" xml:space="preserve">
          <source>This is used, for example, by &lt;code&gt;&lt;a href=&quot;../container/vector/resize&quot;&gt;std::vector::resize&lt;/a&gt;&lt;/code&gt;, which may have to allocate new storage and then move or copy elements from old storage to new storage. If an exception occurs during this operation, &lt;code&gt;&lt;a href=&quot;../container/vector/resize&quot;&gt;std::vector::resize&lt;/a&gt;&lt;/code&gt; undoes everything it did to this point, which is only possible if &lt;code&gt;std::move_if_noexcept&lt;/code&gt; was used to decide whether to use move construction or copy construction. (unless copy constructor is not available, in which case move constructor is used either way and the strong exception guarantee may be waived).</source>
          <target state="translated">Это используется, например, &lt;code&gt;&lt;a href=&quot;../container/vector/resize&quot;&gt;std::vector::resize&lt;/a&gt;&lt;/code&gt; , которому может потребоваться выделить новое хранилище, а затем переместить или скопировать элементы из старого хранилища в новое хранилище. Если во время этой операции возникает исключение, &lt;code&gt;&lt;a href=&quot;../container/vector/resize&quot;&gt;std::vector::resize&lt;/a&gt;&lt;/code&gt; отменяет все, что было сделано до этого момента, что возможно только в том случае, если &lt;code&gt;std::move_if_noexcept&lt;/code&gt; использовалось для принятия решения, использовать ли конструкцию перемещения или конструкцию копирования. (если конструктор копирования недоступен, в этом случае конструктор перемещения используется в любом случае и гарантия строгого исключения может быть отменена).</target>
        </trans-unit>
        <trans-unit id="65497cbcaeca38825fa3feca97f3678010e28f07" translate="yes" xml:space="preserve">
          <source>This lookup with the reversed arguments order makes it possible to write just one &lt;code&gt;operatror&amp;lt;=&amp;gt;(&lt;a href=&quot;../string/basic_string&quot;&gt;std::string&lt;/a&gt;, const char*)&lt;/code&gt; to generate all comparisons between &lt;code&gt;&lt;a href=&quot;../string/basic_string&quot;&gt;std::string&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;const char*&lt;/code&gt;, both ways. See &lt;a href=&quot;default_comparisons&quot;&gt;default comparisons&lt;/a&gt; for more detail.</source>
          <target state="translated">Этот поиск в обратном порядке аргументов позволяет написать только один &lt;code&gt;operatror&amp;lt;=&amp;gt;(&lt;a href=&quot;../string/basic_string&quot;&gt;std::string&lt;/a&gt;, const char*)&lt;/code&gt; для генерации всех сравнений между &lt;code&gt;&lt;a href=&quot;../string/basic_string&quot;&gt;std::string&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;const char*&lt;/code&gt; в обоих направлениях. Смотрите &lt;a href=&quot;default_comparisons&quot;&gt;сравнение&lt;/a&gt; по умолчанию для более подробной информации.</target>
        </trans-unit>
        <trans-unit id="7c00bd2988f8e6fd1c69153710829dd41df339f1" translate="yes" xml:space="preserve">
          <source>This macro is primarily provided for compatibility with C; it behaves the same as the constructor of &lt;code&gt;&lt;a href=&quot;atomic&quot;&gt;std::atomic&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Этот макрос в первую очередь предназначен для совместимости с C; он ведет себя так же, как конструктор &lt;code&gt;&lt;a href=&quot;atomic&quot;&gt;std::atomic&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="69dae22caf55af4023255754b9c726f9f5527dad" translate="yes" xml:space="preserve">
          <source>This makes it possible to introduce new integer types (e.g. SafeInt) that enjoy the same existing calling conventions as their underlying integer types, even on ABIs that penalize passing/returning structures by value.</source>
          <target state="translated">Это позволяет вводить новые целые типы (например,SafeInt),которые имеют те же действующие соглашения по вызову,что и лежащие в их основе целые типы,даже в случае с ABI,которые наказывают передающие/возвращающие структуры по значению.</target>
        </trans-unit>
        <trans-unit id="1fced9487368a0914863ecd65a116e588baecbc7" translate="yes" xml:space="preserve">
          <source>This makes it possible to move out of an object in scope that is no longer needed:</source>
          <target state="translated">Это позволяет выйти из объекта в области видимости,который больше не нужен:</target>
        </trans-unit>
        <trans-unit id="9c4ec0eda49a5a6eec06bfb350abc5e50dec706c" translate="yes" xml:space="preserve">
          <source>This manipulator is typically used with &lt;code&gt;&lt;a href=&quot;../ostrstream&quot;&gt;std::ostrstream&lt;/a&gt;&lt;/code&gt;, when the associated output buffer needs to be null-terminated to be processed as a C string.</source>
          <target state="translated">Этот манипулятор обычно используется с &lt;code&gt;&lt;a href=&quot;../ostrstream&quot;&gt;std::ostrstream&lt;/a&gt;&lt;/code&gt; , когда связанный выходной буфер должен заканчиваться нулем, чтобы быть обработанным как строка C.</target>
        </trans-unit>
        <trans-unit id="0d033cddb2872a1515d402a6be03415f6aa84c5a" translate="yes" xml:space="preserve">
          <source>This manipulator may be used to produce a line of output immediately, e.g. when displaying output from a long-running process, logging activity of multiple threads or logging activity of a program that may crash unexpectedly. An explicit flush of &lt;code&gt;&lt;a href=&quot;../cout&quot;&gt;std::cout&lt;/a&gt;&lt;/code&gt; is also necessary before a call to &lt;code&gt;&lt;a href=&quot;../../utility/program/system&quot;&gt;std::system&lt;/a&gt;&lt;/code&gt;, if the spawned process performs any screen I/O. In most other usual interactive I/O scenarios, &lt;code&gt;std::endl&lt;/code&gt; is redundant when used with &lt;code&gt;&lt;a href=&quot;../cout&quot;&gt;std::cout&lt;/a&gt;&lt;/code&gt; because any input from &lt;code&gt;&lt;a href=&quot;../cin&quot;&gt;std::cin&lt;/a&gt;&lt;/code&gt;, output to &lt;code&gt;&lt;a href=&quot;../cerr&quot;&gt;std::cerr&lt;/a&gt;&lt;/code&gt;, or program termination forces a call to &lt;code&gt;&lt;a href=&quot;../cout&quot;&gt;std::cout&lt;/a&gt;.flush()&lt;/code&gt;. Use of &lt;code&gt;std::endl&lt;/code&gt; in place of &lt;code&gt;'\n'&lt;/code&gt;, encouraged by some sources, may significantly degrade output performance.</source>
          <target state="translated">Этот манипулятор может быть использован для немедленной выдачи строки вывода, например, при отображении вывода из продолжительного процесса, регистрации активности нескольких потоков или активности программы, которая может неожиданно завершиться аварийно. Явная очистка &lt;code&gt;&lt;a href=&quot;../cout&quot;&gt;std::cout&lt;/a&gt;&lt;/code&gt; также необходима перед вызовом &lt;code&gt;&lt;a href=&quot;../../utility/program/system&quot;&gt;std::system&lt;/a&gt;&lt;/code&gt; , если порожденный процесс выполняет какой-либо экранный ввод-вывод. В большинстве других обычных интерактивных сценариев ввода / вывода &lt;code&gt;std::endl&lt;/code&gt; является избыточным при использовании с &lt;code&gt;&lt;a href=&quot;../cout&quot;&gt;std::cout&lt;/a&gt;&lt;/code&gt; потому что любой ввод из &lt;code&gt;&lt;a href=&quot;../cin&quot;&gt;std::cin&lt;/a&gt;&lt;/code&gt; , вывод в &lt;code&gt;&lt;a href=&quot;../cerr&quot;&gt;std::cerr&lt;/a&gt;&lt;/code&gt; или завершение программы вызывает вызов &lt;code&gt;&lt;a href=&quot;../cout&quot;&gt;std::cout&lt;/a&gt;.flush()&lt;/code&gt; . Использование &lt;code&gt;std::endl&lt;/code&gt; вместо &lt;code&gt;'\n'&lt;/code&gt; , что поощряется некоторыми источниками, может значительно снизить производительность.</target>
        </trans-unit>
        <trans-unit id="c4f2d1bbb43a26f1c14fa7b3e243baca9ad4d3dc" translate="yes" xml:space="preserve">
          <source>This manipulator may be used to produce an incomplete line of output immediately, e.g. when displaying output from a long-running process, logging activity of multiple threads or logging activity of a program that may crash unexpectedly. An explicit flush of &lt;code&gt;&lt;a href=&quot;../cout&quot;&gt;std::cout&lt;/a&gt;&lt;/code&gt; is also necessary before a call to &lt;code&gt;&lt;a href=&quot;../../utility/program/system&quot;&gt;std::system&lt;/a&gt;&lt;/code&gt;, if the spawned process performs any screen I/O (a common example is &lt;code&gt;&lt;a href=&quot;../../utility/program/system&quot;&gt;std::system&lt;/a&gt;(&quot;pause&quot;)&lt;/code&gt; on Windows). In most other usual interactive I/O scenarios, &lt;code&gt;&lt;a href=&quot;endl&quot;&gt;std::endl&lt;/a&gt;&lt;/code&gt; is redundant when used with &lt;code&gt;&lt;a href=&quot;../cout&quot;&gt;std::cout&lt;/a&gt;&lt;/code&gt; because any input from &lt;code&gt;&lt;a href=&quot;../cin&quot;&gt;std::cin&lt;/a&gt;&lt;/code&gt;, output to &lt;code&gt;&lt;a href=&quot;../cerr&quot;&gt;std::cerr&lt;/a&gt;&lt;/code&gt;, or program termination forces a call to &lt;code&gt;&lt;a href=&quot;../cout&quot;&gt;std::cout&lt;/a&gt;.flush()&lt;/code&gt;.</source>
          <target state="translated">Этот манипулятор может быть использован для немедленного создания неполной строки вывода, например, при отображении вывода из длительно выполняющегося процесса, регистрации активности нескольких потоков или активности программы, которая может неожиданно завершить работу. Явная очистка &lt;code&gt;&lt;a href=&quot;../cout&quot;&gt;std::cout&lt;/a&gt;&lt;/code&gt; также необходима перед вызовом &lt;code&gt;&lt;a href=&quot;../../utility/program/system&quot;&gt;std::system&lt;/a&gt;&lt;/code&gt; , если порожденный процесс выполняет какой-либо экранный ввод-вывод (общий пример - &lt;code&gt;&lt;a href=&quot;../../utility/program/system&quot;&gt;std::system&lt;/a&gt;(&quot;pause&quot;)&lt;/code&gt; в Windows). В большинстве других обычных интерактивных сценариев ввода / вывода &lt;code&gt;&lt;a href=&quot;endl&quot;&gt;std::endl&lt;/a&gt;&lt;/code&gt; является избыточным при использовании с &lt;code&gt;&lt;a href=&quot;../cout&quot;&gt;std::cout&lt;/a&gt;&lt;/code&gt; потому что любой ввод из &lt;code&gt;&lt;a href=&quot;../cin&quot;&gt;std::cin&lt;/a&gt;&lt;/code&gt; , вывод в &lt;code&gt;&lt;a href=&quot;../cerr&quot;&gt;std::cerr&lt;/a&gt;&lt;/code&gt; или завершение программы вызывает вызов &lt;code&gt;&lt;a href=&quot;../cout&quot;&gt;std::cout&lt;/a&gt;.flush()&lt;/code&gt; ,</target>
        </trans-unit>
        <trans-unit id="b8bc45ac3ed46d59a0178ef3c27e45979eabda25" translate="yes" xml:space="preserve">
          <source>This may be used to avoid unnecessary &lt;code&gt;&lt;a href=&quot;memory_order&quot;&gt;std::memory_order_acquire&lt;/a&gt;&lt;/code&gt; fences when the dependency chain leaves function scope (and the function does not have the &lt;code&gt;[[&lt;a href=&quot;../language/attributes/carries_dependency&quot;&gt;carries_dependency&lt;/a&gt;]]&lt;/code&gt; attribute).</source>
          <target state="translated">Это может быть использовано, чтобы избежать ненужных ограждений &lt;code&gt;&lt;a href=&quot;memory_order&quot;&gt;std::memory_order_acquire&lt;/a&gt;&lt;/code&gt; когда цепочка зависимостей выходит из области действия функции (а функция не имеет атрибута &lt;code&gt;[[&lt;a href=&quot;../language/attributes/carries_dependency&quot;&gt;carries_dependency&lt;/a&gt;]]&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="56eb878738bcafe0dda45a9b25b2771a66434232" translate="yes" xml:space="preserve">
          <source>This may happen if the pointer is assigned to:</source>
          <target state="translated">Это может произойти,если указатель назначен:</target>
        </trans-unit>
        <trans-unit id="263227da37307b0a3267455a4c633b69bc493839" translate="yes" xml:space="preserve">
          <source>This means that &lt;code&gt;match[i].position()&lt;/code&gt; gives the offset from the beginning of the target sequence, which is often not the same as the offset from the sequence passed in the call to &lt;code&gt;regex_search&lt;/code&gt;.</source>
          <target state="translated">Это означает, что &lt;code&gt;match[i].position()&lt;/code&gt; дает смещение от начала целевой последовательности, которое часто не совпадает со смещением от последовательности, переданной в вызове &lt;code&gt;regex_search&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2cdccbba38d49dbd4067105548f38475359bb552" translate="yes" xml:space="preserve">
          <source>This means that in a conforming implementation, including this header has no effect.</source>
          <target state="translated">Это означает,что при соответствующей реализации,включая этот заголовок,никакого эффекта не имеет.</target>
        </trans-unit>
        <trans-unit id="558bc6404fe9a7280ef6a558ff20ea8606c413a8" translate="yes" xml:space="preserve">
          <source>This means that there are no aliases in the elements and this property can be used to perform some kinds of optimization.</source>
          <target state="translated">Это означает,что в элементах нет псевдонимов,и это свойство может быть использовано для выполнения некоторых видов оптимизации.</target>
        </trans-unit>
        <trans-unit id="81b15552e359daa797fa96a9d36a5f3772826f69" translate="yes" xml:space="preserve">
          <source>This mechanism makes it possible to use template operators, since there is no syntax to specify template arguments for an operator other than by re-writing it as a function call expression.</source>
          <target state="translated">Данный механизм позволяет использовать шаблонные операторы,так как синтаксис для указания аргументов шаблона для оператора отсутствует,кроме как путем его перезаписи в качестве выражения вызова функции.</target>
        </trans-unit>
        <trans-unit id="baabe2e811ea477176a6b1ba57aacf61a6c0bf94" translate="yes" xml:space="preserve">
          <source>This mechanism makes it possible to use template operators, since there is no syntax to specify template arguments for an operator other than by re-writing it as a function call expression:</source>
          <target state="translated">Данный механизм позволяет использовать шаблонные операторы,так как синтаксис для указания аргументов шаблона для оператора отсутствует,кроме как путем его перезаписи в качестве выражения вызова функции:</target>
        </trans-unit>
        <trans-unit id="631b5699cc80fd8b4a70a5399e59151e856f7a18" translate="yes" xml:space="preserve">
          <source>This member function is protected: it is called by the constructors of the derived stream classes &lt;code&gt;&lt;a href=&quot;../basic_istream&quot;&gt;std::basic_istream&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../basic_ostream&quot;&gt;std::basic_ostream&lt;/a&gt;&lt;/code&gt; once the associated stream buffer is known. Until this function is called, every member function (including the destructor) of the default-constructed &lt;code&gt;&lt;a href=&quot;../basic_ios&quot;&gt;std::basic_ios&lt;/a&gt;&lt;/code&gt; invokes undefined behavior. Note that &lt;code&gt;basic_ios&lt;/code&gt; is a virtual base class, and therefore its constructor is not called by the constructors of those directly derived classes, which is why two-stage initialization is necessary.</source>
          <target state="translated">Эта функция-член защищена: она вызывается конструкторами производных потоковых классов &lt;code&gt;&lt;a href=&quot;../basic_istream&quot;&gt;std::basic_istream&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;../basic_ostream&quot;&gt;std::basic_ostream&lt;/a&gt;&lt;/code&gt; только ассоциированный буфер потока известен. До &lt;code&gt;&lt;a href=&quot;../basic_ios&quot;&gt;std::basic_ios&lt;/a&gt;&lt;/code&gt; этой функции каждая функция-член (включая деструктор) сконструированного по умолчанию std :: basic_ios вызывает неопределенное поведение. Обратите внимание, что &lt;code&gt;basic_ios&lt;/code&gt; - это виртуальный базовый класс, и, следовательно, его конструктор не вызывается конструкторами этих непосредственно производных классов, поэтому необходима двухэтапная инициализация.</target>
        </trans-unit>
        <trans-unit id="9ff0b24c8b1bcff91c847b5b05e80e90bc1f2ed8" translate="yes" xml:space="preserve">
          <source>This member function is protected: it is called by the move constructors of the derived streams such as &lt;code&gt;&lt;a href=&quot;../basic_ofstream&quot;&gt;std::basic_ofstream&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../basic_istringstream&quot;&gt;std::basic_istringstream&lt;/a&gt;&lt;/code&gt;, as the final step after constructing the base class and after moving the stream buffer: only the most derived stream class knows how to correctly move the stream buffer, but &lt;code&gt;&lt;a href=&quot;../basic_ios&quot;&gt;std::basic_ios&lt;/a&gt;&lt;/code&gt; needs to be made aware of the stream's new location so that its public member functions can access it.</source>
          <target state="translated">Эта функция-член защищена: она вызывается конструкторами перемещения производных потоков, такими как &lt;code&gt;&lt;a href=&quot;../basic_ofstream&quot;&gt;std::basic_ofstream&lt;/a&gt;&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;../basic_istringstream&quot;&gt;std::basic_istringstream&lt;/a&gt;&lt;/code&gt; , как последний шаг после создания базового класса и после перемещения буфера потока: только самый производный поток Класс знает, как правильно перемещать буфер потока, но &lt;code&gt;&lt;a href=&quot;../basic_ios&quot;&gt;std::basic_ios&lt;/a&gt;&lt;/code&gt; необходимо знать о новом местоположении потока, чтобы его открытые функции-члены могли получить к нему доступ.</target>
        </trans-unit>
        <trans-unit id="9c3c6a60b1284f57464c304d4f49e3141a9265a5" translate="yes" xml:space="preserve">
          <source>This member function is protected: it is called by the protected move constructors of the derived stream classes &lt;code&gt;&lt;a href=&quot;../basic_ostream&quot;&gt;std::basic_ostream&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../basic_istream&quot;&gt;std::basic_istream&lt;/a&gt;&lt;/code&gt;, which, in turn, are called by the public move constructors of the further derived stream classes such as &lt;code&gt;&lt;a href=&quot;../basic_ofstream&quot;&gt;std::basic_ofstream&lt;/a&gt;&lt;/code&gt;, which know how to correctly move the associated streambuffer.</source>
          <target state="translated">Эта функция-член защищена: она вызывается конструкторами защищенного перемещения производных потоковых классов &lt;code&gt;&lt;a href=&quot;../basic_ostream&quot;&gt;std::basic_ostream&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;../basic_istream&quot;&gt;std::basic_istream&lt;/a&gt;&lt;/code&gt; , которые, в свою очередь, вызываются открытыми конструкторами перемещения других производных потоковых классов, таких как &lt;code&gt;&lt;a href=&quot;../basic_ofstream&quot;&gt;std::basic_ofstream&lt;/a&gt;&lt;/code&gt; , который знает, как правильно перемещать связанный потоковый буфер.</target>
        </trans-unit>
        <trans-unit id="6018aedea85c8af7152a8d08f9289d2de94a185f" translate="yes" xml:space="preserve">
          <source>This member function is protected: it is called by the swap member functions of the derived stream classes &lt;code&gt;&lt;a href=&quot;../basic_stringstream&quot;&gt;std::basic_stringstream&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../basic_fstream&quot;&gt;std::basic_fstream&lt;/a&gt;&lt;/code&gt;, which know how to correctly swap the associated stream buffers.</source>
          <target state="translated">Эта функция-член защищена: ее вызывают функции-члены подкачки производных потоковых классов &lt;code&gt;&lt;a href=&quot;../basic_stringstream&quot;&gt;std::basic_stringstream&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;../basic_fstream&quot;&gt;std::basic_fstream&lt;/a&gt;&lt;/code&gt; , которые знают, как правильно поменять соответствующие буферы потока.</target>
        </trans-unit>
        <trans-unit id="194eca0c3ce225b7c17b35f16086bbd18ea24522" translate="yes" xml:space="preserve">
          <source>This metafunction is a convenient way to leverage &lt;a href=&quot;../language/sfinae&quot;&gt;SFINAE&lt;/a&gt; to conditionally remove functions from &lt;a href=&quot;../language/overload_resolution&quot;&gt;overload resolution&lt;/a&gt; based on type traits and to provide separate function overloads and specializations for different type traits. &lt;code&gt;std::enable_if&lt;/code&gt; can be used as an additional function argument (not applicable to operator overloads), as a return type (not applicable to constructors and destructors), or as a class template or function template parameter.</source>
          <target state="translated">Эта метафункция является удобным способом использования &lt;a href=&quot;../language/sfinae&quot;&gt;SFINAE&lt;/a&gt; для условного удаления функций из &lt;a href=&quot;../language/overload_resolution&quot;&gt;разрешения перегрузки&lt;/a&gt; на основе признаков типа и для предоставления отдельных перегрузок функций и специализаций для признаков различных типов. &lt;code&gt;std::enable_if&lt;/code&gt; может использоваться в качестве дополнительного аргумента функции (неприменимо к перегрузкам операторов), в качестве возвращаемого типа (неприменимо к конструкторам и деструкторам) или в качестве шаблона класса или параметра шаблона функции.</target>
        </trans-unit>
        <trans-unit id="a1422282434c61f7b9a780c953c50b153fde9dfb" translate="yes" xml:space="preserve">
          <source>This metafunction is used in template metaprogramming to detect ill-formed types in SFINAE context:</source>
          <target state="translated">Эта метафункция используется в шаблоном метапрограммировании для обнаружения плохо сформированных типов в контексте SFINAE:</target>
        </trans-unit>
        <trans-unit id="1a68dc4a214d5a2f0c86986f5fcbb662600bbbaa" translate="yes" xml:space="preserve">
          <source>This only applies if the arithmetic is two's complement which is only required for the &lt;a href=&quot;../types/integer&quot;&gt;exact-width integer types&lt;/a&gt;. Note, however, that at the moment all platforms with a C++ compiler use two's complement arithmetic</source>
          <target state="translated">Это применимо только в том случае, если арифметика является дополнением к двум, что требуется только для &lt;a href=&quot;../types/integer&quot;&gt; целочисленных типов точной шириной&lt;/a&gt; . Обратите внимание, однако, что на данный момент все платформы с компилятором C ++ используют арифметику с двумя дополнениями</target>
        </trans-unit>
        <trans-unit id="28bba53040cc59e4ebfb5e6b23947d5f3e555523" translate="yes" xml:space="preserve">
          <source>This operation</source>
          <target state="translated">Эта операция</target>
        </trans-unit>
        <trans-unit id="ee376cb133ce3fa6134bf19377f3a3fc9a03d186" translate="yes" xml:space="preserve">
          <source>This operation is commonly implemented in hardware as &lt;a href=&quot;https://en.wikipedia.org/wiki/Multiply%E2%80%93accumulate_operation&quot;&gt;fused multiply-add&lt;/a&gt; CPU instruction. If supported by hardware, the appropriate &lt;code&gt;FP_FAST_FMA*&lt;/code&gt; macros are expected to be defined, but many implementations make use of the CPU instruction even when the macros are not defined.</source>
          <target state="translated">Эта операция обычно реализуется на аппаратном уровне как &lt;a href=&quot;https://en.wikipedia.org/wiki/Multiply%E2%80%93accumulate_operation&quot;&gt;объединенная&lt;/a&gt; инструкция процессора с многократным добавлением . Если поддерживается аппаратным обеспечением, соответствующий &lt;code&gt;FP_FAST_FMA*&lt;/code&gt; макросы будут определены, но во многих реализациях используется команда CPU, даже если макросы не определены.</target>
        </trans-unit>
        <trans-unit id="677f69ad7dd084269c9619b79f0d75fdd900458e" translate="yes" xml:space="preserve">
          <source>This operation is stable: for equivalent elements in the two lists, the elements from &lt;code&gt;*this&lt;/code&gt; shall always precede the elements from &lt;code&gt;other&lt;/code&gt;, and the order of equivalent elements of &lt;code&gt;*this&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt; does not change.</source>
          <target state="translated">Эта операция стабильна: для эквивалентных элементов в двух списках элементы из &lt;code&gt;*this&lt;/code&gt; всегда должны предшествовать элементам из &lt;code&gt;other&lt;/code&gt; , и порядок эквивалентных элементов &lt;code&gt;*this&lt;/code&gt; и &lt;code&gt;other&lt;/code&gt; не меняется.</target>
        </trans-unit>
        <trans-unit id="e1a54e7ed923b5cbda29b41bb3cef5210c3e3c16" translate="yes" xml:space="preserve">
          <source>This operator does not check whether the optional contains a value! You can do so manually by using &lt;code&gt;&lt;a href=&quot;operator_bool&quot;&gt;has_value()&lt;/a&gt;&lt;/code&gt; or simply &lt;code&gt;&lt;a href=&quot;operator_bool&quot;&gt;operator bool()&lt;/a&gt;&lt;/code&gt;. Alternatively, if checked access is needed, &lt;code&gt;&lt;a href=&quot;value&quot;&gt;value()&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;value_or&quot;&gt;value_or()&lt;/a&gt;&lt;/code&gt; may be used.</source>
          <target state="translated">Этот оператор не проверяет, содержит ли необязательное значение! Вы можете сделать это вручную, используя &lt;code&gt;&lt;a href=&quot;operator_bool&quot;&gt;has_value()&lt;/a&gt;&lt;/code&gt; или просто &lt;code&gt;&lt;a href=&quot;operator_bool&quot;&gt;operator bool()&lt;/a&gt;&lt;/code&gt; . В качестве альтернативы, если требуется проверенный доступ, можно использовать &lt;code&gt;&lt;a href=&quot;value&quot;&gt;value()&lt;/a&gt;&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;value_or&quot;&gt;value_or()&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="76837e505361cd0d1e62fe926fca10a41668aadc" translate="yes" xml:space="preserve">
          <source>This operator is declared in the namespace &lt;code&gt;std::literals::chrono_literals&lt;/code&gt;, where both &lt;code&gt;literals&lt;/code&gt; and &lt;code&gt;chrono_literals&lt;/code&gt; are inline namespaces. Access to this operator can be gained with &lt;code&gt;using namespace std::literals&lt;/code&gt;, &lt;code&gt;using namespace std::chrono_literals&lt;/code&gt;, and &lt;code&gt;using namespace std::literals::chrono_literals&lt;/code&gt;.</source>
          <target state="translated">Этот оператор объявлен в пространстве имен &lt;code&gt;std::literals::chrono_literals&lt;/code&gt; , где оба &lt;code&gt;literals&lt;/code&gt; и &lt;code&gt;chrono_literals&lt;/code&gt; являются встроенными пространствами имен. Доступ к этому оператору может быть получен с &lt;code&gt;using namespace std::literals&lt;/code&gt; , &lt;code&gt;using namespace std::chrono_literals&lt;/code&gt; и &lt;code&gt;using namespace std::literals::chrono_literals&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c90a4015c270f47b35bf150eaa6f8ff8b7041fe0" translate="yes" xml:space="preserve">
          <source>This operator makes it possible to use streams and functions that return references to streams as loop conditions, resulting in the idiomatic C++ input loops such as &lt;code&gt;while(stream &amp;gt;&amp;gt; value) {...}&lt;/code&gt; or &lt;code&gt;while(getline(stream, string)){...}&lt;/code&gt;. Such loops execute the loop's body only if the input operation succeeded.</source>
          <target state="translated">Этот оператор позволяет использовать потоки и функции, которые возвращают ссылки на потоки в качестве условий цикла, что приводит к идиоматическим циклам ввода C ++, таким как &lt;code&gt;while(stream &amp;gt;&amp;gt; value) {...}&lt;/code&gt; или &lt;code&gt;while(getline(stream, string)){...}&lt;/code&gt; . Такие циклы выполняют тело цикла, только если операция ввода прошла успешно.</target>
        </trans-unit>
        <trans-unit id="70eb80993771f43d98c8f63a162d2abf81c3b412" translate="yes" xml:space="preserve">
          <source>This order determines the order in which constraints are instantiated when checking for satisfaction.</source>
          <target state="translated">Этот порядок определяет порядок,в котором ограничения конкретизируются при проверке на предмет удовлетворенности.</target>
        </trans-unit>
        <trans-unit id="ebf5e8fbc6ec56b576aeb159cdeac4bba0a41f70" translate="yes" xml:space="preserve">
          <source>This ordering is used to make shared and weak pointers usable as keys in associative containers, typically through &lt;code&gt;&lt;a href=&quot;../owner_less&quot;&gt;std::owner_less&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Этот порядок используется для использования общих и слабых указателей в качестве ключей в ассоциативных контейнерах, обычно через &lt;code&gt;&lt;a href=&quot;../owner_less&quot;&gt;std::owner_less&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e1a82251ba96a19d119ca9bfa58e9f2f497a9f62" translate="yes" xml:space="preserve">
          <source>This overload does not subtract the parsed offset (if any) from the parsed timestamp, unlike the &lt;code&gt;from_stream&lt;/code&gt; overloads for the &lt;code&gt;time_point&lt;/code&gt; of other clocks.</source>
          <target state="translated">Эта перегрузка не вычитает проанализированное смещение (если оно есть) из проанализированной метки времени, в отличие от перегрузок &lt;code&gt;from_stream&lt;/code&gt; для точки &lt;code&gt;time_point&lt;/code&gt; других часов.</target>
        </trans-unit>
        <trans-unit id="4bf7c4e2eb5387c99cb1a1ffeb6f0e5e88754a17" translate="yes" xml:space="preserve">
          <source>This overload doesn't participate in overload resolution if &lt;code&gt;std::unique_ptr&amp;lt;Y, Deleter&amp;gt;::pointer&lt;/code&gt; is not</source>
          <target state="translated">Эта перегрузка не участвует в разрешении перегрузки, если &lt;code&gt;std::unique_ptr&amp;lt;Y, Deleter&amp;gt;::pointer&lt;/code&gt; is</target>
        </trans-unit>
        <trans-unit id="bc6f7584722885d728d6854cb8736855f9270a48" translate="yes" xml:space="preserve">
          <source>This overload has the same effect as overload (1) if &lt;code&gt;InputIt&lt;/code&gt; is an integral type.</source>
          <target state="translated">Эта перегрузка имеет тот же эффект, что и перегрузка (1), если &lt;code&gt;InputIt&lt;/code&gt; является целочисленным типом.</target>
        </trans-unit>
        <trans-unit id="1fa4602d949f8f6973ff6fea1f4b9e68fc722e4c" translate="yes" xml:space="preserve">
          <source>This overload has the same effect as overload (3) if &lt;code&gt;InputIt&lt;/code&gt; is an integral type.</source>
          <target state="translated">Эта перегрузка имеет тот же эффект, что и перегрузка (3), если &lt;code&gt;InputIt&lt;/code&gt; является целочисленным типом.</target>
        </trans-unit>
        <trans-unit id="7a8485de9a7d7bca2cd829541418ca26242baca3" translate="yes" xml:space="preserve">
          <source>This overload has the same effect as overload (6) if &lt;code&gt;InputIt&lt;/code&gt; is an integral type.</source>
          <target state="translated">Эта перегрузка имеет тот же эффект, что и перегрузка (6), если &lt;code&gt;InputIt&lt;/code&gt; является целочисленным типом.</target>
        </trans-unit>
        <trans-unit id="70e5d40a020e1e29942bf932764b7fdcf68a80bf" translate="yes" xml:space="preserve">
          <source>This overload is necessary because &lt;code&gt;&lt;a href=&quot;../initializer_list&quot;&gt;std::initializer_list&lt;/a&gt;&lt;/code&gt; does not have a member function &lt;code&gt;rbegin&lt;/code&gt;. No overload is needed for &lt;code&gt;&lt;a href=&quot;../../iterator/rbegin&quot;&gt;std::crbegin&lt;/a&gt;&lt;/code&gt; because it is implemented in terms of &lt;code&gt;&lt;a href=&quot;../../iterator/rbegin&quot;&gt;std::rbegin&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Эта перегрузка необходима, потому что &lt;code&gt;&lt;a href=&quot;../initializer_list&quot;&gt;std::initializer_list&lt;/a&gt;&lt;/code&gt; не имеет функции-члена &lt;code&gt;rbegin&lt;/code&gt; . Для &lt;code&gt;&lt;a href=&quot;../../iterator/rbegin&quot;&gt;std::crbegin&lt;/a&gt;&lt;/code&gt; перегрузка не требуется, поскольку она реализована в терминах &lt;code&gt;&lt;a href=&quot;../../iterator/rbegin&quot;&gt;std::rbegin&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ade89453e12ddb644d64137481026bf6616fd814" translate="yes" xml:space="preserve">
          <source>This overload is necessary because &lt;code&gt;&lt;a href=&quot;../initializer_list&quot;&gt;std::initializer_list&lt;/a&gt;&lt;/code&gt; does not have a member function &lt;code&gt;rend&lt;/code&gt;. No overload is needed for &lt;code&gt;&lt;a href=&quot;../../iterator/rend&quot;&gt;std::crend&lt;/a&gt;&lt;/code&gt; because it is implemented in terms of &lt;code&gt;&lt;a href=&quot;../../iterator/rend&quot;&gt;std::rend&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Эта перегрузка необходима, потому что &lt;code&gt;&lt;a href=&quot;../initializer_list&quot;&gt;std::initializer_list&lt;/a&gt;&lt;/code&gt; не имеет функции-члена &lt;code&gt;rend&lt;/code&gt; . Для &lt;code&gt;&lt;a href=&quot;../../iterator/rend&quot;&gt;std::crend&lt;/a&gt;&lt;/code&gt; перегрузка не требуется, поскольку она реализована в терминах &lt;code&gt;&lt;a href=&quot;../../iterator/rend&quot;&gt;std::rend&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="83116be95b91d59c09d4b41fc31292dca9c27808" translate="yes" xml:space="preserve">
          <source>This overload makes it possible to forward a result of an expression (such as function call), which may be rvalue or lvalue, as the original value category of a forwarding reference argument.</source>
          <target state="translated">Эта перегрузка позволяет пересылать результат выражения (например,вызов функции),которым может быть rvalue или lvalue,в качестве категории исходного значения пересылаемого аргумента ссылок.</target>
        </trans-unit>
        <trans-unit id="814368a4e79aa44fdd2b8a96b22ebf135a87ef17" translate="yes" xml:space="preserve">
          <source>This overload may be used to ignore spurious awakenings while waiting for a specific condition to become true.  Note that &lt;code&gt;lock&lt;/code&gt; must be acquired before entering this method, and it is reacquired after &lt;code&gt;wait(lock)&lt;/code&gt; exits, which means that &lt;code&gt;lock&lt;/code&gt; can be used to guard access to &lt;code&gt;pred()&lt;/code&gt;.</source>
          <target state="translated">Эта перегрузка может использоваться для игнорирования ложных пробуждений во время ожидания выполнения определенного условия. Обратите внимание, что &lt;code&gt;lock&lt;/code&gt; должна быть получена до входа в этот метод, и она восстанавливается после выхода из режима &lt;code&gt;wait(lock)&lt;/code&gt; , что означает, что &lt;code&gt;lock&lt;/code&gt; можно использовать для защиты доступа к &lt;code&gt;pred()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7a8eb3282f5afae84e29833c36cc610e1de569a0" translate="yes" xml:space="preserve">
          <source>This overload may be used to ignore spurious wakeups.</source>
          <target state="translated">Эта перегрузка может быть использована для игнорирования поддельных пробуждений.</target>
        </trans-unit>
        <trans-unit id="7c7c9be7921bc5aca3e14ee52c3bb2b260dbf024" translate="yes" xml:space="preserve">
          <source>This overload only participates in overload resolution if</source>
          <target state="translated">Эта перегрузка участвует в разрешении перегрузки только в том случае,если</target>
        </trans-unit>
        <trans-unit id="337c9fa9042558efca853cc7d8b71cfcdf68fa7c" translate="yes" xml:space="preserve">
          <source>This overload only participates in overload resolution if &lt;code&gt;&lt;a href=&quot;../../types/is_default_constructible&quot;&gt;std::is_default_constructible&lt;/a&gt;&amp;lt;Deleter&amp;gt;::value&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; and &lt;code&gt;Deleter&lt;/code&gt; is not a pointer type. The program is ill-formed if this constructor is selected by &lt;a href=&quot;../../language/deduction_guide&quot;&gt;class template argument deduction&lt;/a&gt;.</source>
          <target state="translated">Эта перегрузка участвует только в разрешении перегрузки, если &lt;code&gt;&lt;a href=&quot;../../types/is_default_constructible&quot;&gt;std::is_default_constructible&lt;/a&gt;&amp;lt;Deleter&amp;gt;::value&lt;/code&gt; имеет значение &lt;code&gt;true&lt;/code&gt; и &lt;code&gt;Deleter&lt;/code&gt; не является типом указателя. Программа плохо сформирована, если этот конструктор выбран путем &lt;a href=&quot;../../language/deduction_guide&quot;&gt;вывода аргумента шаблона класса&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="bdb1577a846fa638ef9c34146d7b837c8cfaff57" translate="yes" xml:space="preserve">
          <source>This overload only participates in overload resolution if &lt;code&gt;&lt;a href=&quot;../../types/is_default_constructible&quot;&gt;std::is_default_constructible&lt;/a&gt;&amp;lt;Ti&amp;gt;::value&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; for all &lt;code&gt;i&lt;/code&gt;</source>
          <target state="translated">Эта перегрузка участвует только в разрешении перегрузки, если &lt;code&gt;&lt;a href=&quot;../../types/is_default_constructible&quot;&gt;std::is_default_constructible&lt;/a&gt;&amp;lt;Ti&amp;gt;::value&lt;/code&gt; имеет значение &lt;code&gt;true&lt;/code&gt; для всех &lt;code&gt;i&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a2aee11b4d79b3a5270ceef56a825350cf5c37c2" translate="yes" xml:space="preserve">
          <source>This overload only participates in overload resolution if &lt;code&gt;&lt;a href=&quot;../../types/is_swappable&quot;&gt;std::is_swappable&lt;/a&gt;&amp;lt;Container&amp;gt;::value&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../../types/is_swappable&quot;&gt;std::is_swappable&lt;/a&gt;&amp;lt;Compare&amp;gt;::value&lt;/code&gt; are both &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">Эта перегрузка участвует только в разрешении перегрузки, если &lt;code&gt;&lt;a href=&quot;../../types/is_swappable&quot;&gt;std::is_swappable&lt;/a&gt;&amp;lt;Container&amp;gt;::value&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;../../types/is_swappable&quot;&gt;std::is_swappable&lt;/a&gt;&amp;lt;Compare&amp;gt;::value&lt;/code&gt; оба имеют значение &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f2c027e2ce963431b11c8b99a81bfd995a2cc23b" translate="yes" xml:space="preserve">
          <source>This overload only participates in overload resolution if &lt;code&gt;&lt;a href=&quot;../../types/is_swappable&quot;&gt;std::is_swappable&lt;/a&gt;&amp;lt;Container&amp;gt;::value&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">Эта перегрузка участвует только в разрешении перегрузки, если &lt;code&gt;&lt;a href=&quot;../../types/is_swappable&quot;&gt;std::is_swappable&lt;/a&gt;&amp;lt;Container&amp;gt;::value&lt;/code&gt; - &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="687473bac79368096aa9ed3ccf13fad71a9af81b" translate="yes" xml:space="preserve">
          <source>This overload only participates in overload resolution if &lt;code&gt;&lt;a href=&quot;is_integral&quot;&gt;std::is_integral_v&lt;/a&gt;&amp;lt;IntegerType&amp;gt;&lt;/code&gt; is true.</source>
          <target state="translated">Эта перегрузка участвует только в разрешении перегрузки, если &lt;code&gt;&lt;a href=&quot;is_integral&quot;&gt;std::is_integral_v&lt;/a&gt;&amp;lt;IntegerType&amp;gt;&lt;/code&gt; имеет значение true.</target>
        </trans-unit>
        <trans-unit id="1224a3aab62459562f6b5317091c0ef8684c06e6" translate="yes" xml:space="preserve">
          <source>This overload only participates in overload resolution if &lt;code&gt;InputIt&lt;/code&gt; qualifies as &lt;a href=&quot;../../named_req/inputiterator&quot;&gt;LegacyInputIterator&lt;/a&gt;, to avoid ambiguity with the overload (3).</source>
          <target state="translated">Эта перегрузка участвует только в разрешении перегрузки, если &lt;code&gt;InputIt&lt;/code&gt; квалифицируется как &lt;a href=&quot;../../named_req/inputiterator&quot;&gt;LegacyInputIterator&lt;/a&gt; , чтобы избежать неоднозначности с перегрузкой (3).</target>
        </trans-unit>
        <trans-unit id="4a089419777f0efe565129e644b4712117969f47" translate="yes" xml:space="preserve">
          <source>This overload only participates in overload resolution if &lt;code&gt;InputIt&lt;/code&gt; qualifies as an &lt;a href=&quot;../../named_req/inputiterator&quot;&gt;LegacyInputIterator&lt;/a&gt;.</source>
          <target state="translated">Эта перегрузка участвует только в разрешении перегрузки, если &lt;code&gt;InputIt&lt;/code&gt; квалифицируется как &lt;a href=&quot;../../named_req/inputiterator&quot;&gt;LegacyInputIterator&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a09d792b815aa7158d605c39a17d568db1e73837" translate="yes" xml:space="preserve">
          <source>This overload only participates in overload resolution if &lt;code&gt;InputIt&lt;/code&gt; satisfies &lt;a href=&quot;../../named_req/inputiterator&quot;&gt;LegacyInputIterator&lt;/a&gt;, to avoid ambiguity with the overload (2).</source>
          <target state="translated">Эта перегрузка участвует только в разрешении перегрузки, если &lt;code&gt;InputIt&lt;/code&gt; удовлетворяет &lt;a href=&quot;../../named_req/inputiterator&quot;&gt;LegacyInputIterator&lt;/a&gt; , чтобы избежать неоднозначности с перегрузкой (2).</target>
        </trans-unit>
        <trans-unit id="f321cae2fd6e4fe1eb7c60fdcbc221e29351732f" translate="yes" xml:space="preserve">
          <source>This overload only participates in overload resolution if &lt;code&gt;InputIt&lt;/code&gt; satisfies &lt;a href=&quot;../../named_req/inputiterator&quot;&gt;LegacyInputIterator&lt;/a&gt;.</source>
          <target state="translated">Эта перегрузка участвует только в разрешении перегрузки, если &lt;code&gt;InputIt&lt;/code&gt; удовлетворяет &lt;a href=&quot;../../named_req/inputiterator&quot;&gt;LegacyInputIterator&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="84fbda8e9476b834f4eff0a23e019d728cbe538b" translate="yes" xml:space="preserve">
          <source>This overload only participates in overload resolution if &lt;code&gt;N == 0&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../../types/is_swappable&quot;&gt;std::is_swappable&lt;/a&gt;&amp;lt;T&amp;gt;::value&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">Эта перегрузка участвует только в разрешении перегрузки, если &lt;code&gt;N == 0&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;../../types/is_swappable&quot;&gt;std::is_swappable&lt;/a&gt;&amp;lt;T&amp;gt;::value&lt;/code&gt; - &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5843b6cae5eeb5b966317747e078206da1c4f50c" translate="yes" xml:space="preserve">
          <source>This overload only participates in overload resolution if &lt;code&gt;T&lt;/code&gt; is an unsigned integer type (that is, &lt;code&gt;unsigned char&lt;/code&gt;, &lt;code&gt;unsigned short&lt;/code&gt;, &lt;code&gt;unsigned int&lt;/code&gt;, &lt;code&gt;unsigned long&lt;/code&gt;, &lt;code&gt;unsigned long long&lt;/code&gt;, or an extended unsigned integer type).</source>
          <target state="translated">Эта перегрузка участвует только в разрешении перегрузки , если &lt;code&gt;T&lt;/code&gt; является беззнаковым целочисленный тип (то есть &lt;code&gt;unsigned char&lt;/code&gt; , &lt;code&gt;unsigned short&lt;/code&gt; , &lt;code&gt;unsigned int&lt;/code&gt; , &lt;code&gt;unsigned long&lt;/code&gt; , &lt;code&gt;unsigned long long&lt;/code&gt; , или расширенное целое число без знака типа).</target>
        </trans-unit>
        <trans-unit id="c6e60dbde6c8fbc3507ef1d94ecfd0c08c022a59" translate="yes" xml:space="preserve">
          <source>This overload only participates in overload resolution if &lt;code&gt;U&lt;/code&gt; is not a specialization of &lt;code&gt;&lt;a href=&quot;../../utility/pair&quot;&gt;std::pair&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Эта перегрузка участвует только в разрешении перегрузки, если &lt;code&gt;U&lt;/code&gt; не является специализацией &lt;code&gt;&lt;a href=&quot;../../utility/pair&quot;&gt;std::pair&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="29384bbe452ccd42b0340a2c398a159c418dc484" translate="yes" xml:space="preserve">
          <source>This overload only participates in overload resolution if &lt;code&gt;is_move_constructible_v&amp;lt;T_i&amp;gt;&lt;/code&gt; and &lt;code&gt;is_swappable_v&amp;lt;T_i&amp;gt;&lt;/code&gt; are both true for all &lt;code&gt;T_i&lt;/code&gt; in &lt;code&gt;Types...&lt;/code&gt;</source>
          <target state="translated">Эта перегрузка участвует только в разрешении перегрузки, если &lt;code&gt;is_move_constructible_v&amp;lt;T_i&amp;gt;&lt;/code&gt; и &lt;code&gt;is_swappable_v&amp;lt;T_i&amp;gt;&lt;/code&gt; верны для всех &lt;code&gt;T_i&lt;/code&gt; в &lt;code&gt;Types...&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="dc0ee950915984baafe9981e2de7fbbd58afb03e" translate="yes" xml:space="preserve">
          <source>This overload only participates in overload resolution if &lt;code&gt;os &amp;lt;&amp;lt; p.get()&lt;/code&gt; is a valid expression.</source>
          <target state="translated">Эта перегрузка участвует только в разрешении перегрузки, если &lt;code&gt;os &amp;lt;&amp;lt; p.get()&lt;/code&gt; является допустимым выражением.</target>
        </trans-unit>
        <trans-unit id="213ea4feb3d364f895c517e5bb074dd31d585156" translate="yes" xml:space="preserve">
          <source>This overload only participates in overload resolution if &lt;code&gt;sizeof(To) == sizeof(From)&lt;/code&gt; and both &lt;code&gt;To&lt;/code&gt; and &lt;code&gt;From&lt;/code&gt; are &lt;a href=&quot;../named_req/triviallycopyable&quot;&gt;TriviallyCopyable&lt;/a&gt; types.</source>
          <target state="translated">Эта перегрузка участвует только в разрешении перегрузки, если &lt;code&gt;sizeof(To) == sizeof(From)&lt;/code&gt; и &lt;code&gt;To&lt;/code&gt; и &lt;code&gt;From&lt;/code&gt; являются типами &lt;a href=&quot;../named_req/triviallycopyable&quot;&gt;TriviallyCopyable&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="114c800d36b0c72a9adfc7fc9888fa4bbb2bb7e2" translate="yes" xml:space="preserve">
          <source>This overload only participates in overload resolution if &lt;code&gt;sizeof...(Types) &amp;gt;= 1&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../../types/is_copy_constructible&quot;&gt;std::is_copy_constructible&lt;/a&gt;&amp;lt;Ti&amp;gt;::value&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; for all &lt;code&gt;i&lt;/code&gt;.</source>
          <target state="translated">Эта перегрузка участвует только в разрешении перегрузки, если &lt;code&gt;sizeof...(Types) &amp;gt;= 1&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;../../types/is_copy_constructible&quot;&gt;std::is_copy_constructible&lt;/a&gt;&amp;lt;Ti&amp;gt;::value&lt;/code&gt; имеют значение &lt;code&gt;true&lt;/code&gt; для всех &lt;code&gt;i&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="47f721ed5d5ad88fd42fa2395ca7086485e17473" translate="yes" xml:space="preserve">
          <source>This overload only participates in overload resolution if &lt;code&gt;sizeof...(Types) == 2&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../../types/is_constructible&quot;&gt;std::is_constructible&lt;/a&gt;&amp;lt;T0, U1&amp;amp;&amp;amp;&amp;gt;::value&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../../types/is_constructible&quot;&gt;std::is_constructible&lt;/a&gt;&amp;lt;T1, U2&amp;amp;&amp;amp;&amp;gt;::value&lt;/code&gt; are both &lt;code&gt;true&lt;/code&gt;</source>
          <target state="translated">Эта перегрузка участвует только в разрешении перегрузки, если &lt;code&gt;sizeof...(Types) == 2&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;../../types/is_constructible&quot;&gt;std::is_constructible&lt;/a&gt;&amp;lt;T0, U1&amp;amp;&amp;amp;&amp;gt;::value&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;../../types/is_constructible&quot;&gt;std::is_constructible&lt;/a&gt;&amp;lt;T1, U2&amp;amp;&amp;amp;&amp;gt;::value&lt;/code&gt; оба имеют значение &lt;code&gt;true&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2f1425caf63dd41a44a75daddc54c5b669d9e819" translate="yes" xml:space="preserve">
          <source>This overload only participates in overload resolution if &lt;code&gt;sizeof...(Types) == 2&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../../types/is_constructible&quot;&gt;std::is_constructible&lt;/a&gt;&amp;lt;T0,const U1&amp;amp;&amp;gt;::value&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../../types/is_constructible&quot;&gt;std::is_constructible&lt;/a&gt;&amp;lt;T1, const U2&amp;amp;&amp;gt;::value&lt;/code&gt; are both &lt;code&gt;true&lt;/code&gt;</source>
          <target state="translated">Эта перегрузка участвует только в разрешении перегрузки, если &lt;code&gt;sizeof...(Types) == 2&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;../../types/is_constructible&quot;&gt;std::is_constructible&lt;/a&gt;&amp;lt;T0,const U1&amp;amp;&amp;gt;::value&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;../../types/is_constructible&quot;&gt;std::is_constructible&lt;/a&gt;&amp;lt;T1, const U2&amp;amp;&amp;gt;::value&lt;/code&gt; оба имеют значение &lt;code&gt;true&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="db813f0c83ff1627df30808c046963cca19b044a" translate="yes" xml:space="preserve">
          <source>This overload only participates in overload resolution if &lt;code&gt;sizeof...(Types) == sizeof...(UTypes)&lt;/code&gt; and &lt;code&gt;sizeof...(Types) &amp;gt;= 1&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../../types/is_constructible&quot;&gt;std::is_constructible&lt;/a&gt;&amp;lt;Ti, Ui&amp;amp;&amp;amp;&amp;gt;::value&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; for all &lt;code&gt;i&lt;/code&gt;.</source>
          <target state="translated">Эта перегрузка участвует только в разрешении перегрузки, если &lt;code&gt;sizeof...(Types) == sizeof...(UTypes)&lt;/code&gt; и &lt;code&gt;sizeof...(Types) &amp;gt;= 1&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;../../types/is_constructible&quot;&gt;std::is_constructible&lt;/a&gt;&amp;lt;Ti, Ui&amp;amp;&amp;amp;&amp;gt;::value&lt;/code&gt; равно &lt;code&gt;true&lt;/code&gt; для всех &lt;code&gt;i&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bfc7e8a0241026e6c0b8875fd31fd121edcd01be" translate="yes" xml:space="preserve">
          <source>This overload only participates in overload resolution if &lt;code&gt;std::chrono::treat_as_floating_point_v&amp;lt;typename Duration::rep&amp;gt;&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt; and &lt;code&gt;Duration(1) &amp;lt; &lt;a href=&quot;../duration&quot;&gt;std::chrono::days&lt;/a&gt;(1)&lt;/code&gt;.</source>
          <target state="translated">Эта перегрузка участвует только в разрешении перегрузки, если &lt;code&gt;std::chrono::treat_as_floating_point_v&amp;lt;typename Duration::rep&amp;gt;&lt;/code&gt; имеет значение &lt;code&gt;false&lt;/code&gt; и &lt;code&gt;Duration(1) &amp;lt; &lt;a href=&quot;../duration&quot;&gt;std::chrono::days&lt;/a&gt;(1)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bea87dfd18560dbaabd48c593a450285fb991964" translate="yes" xml:space="preserve">
          <source>This page describes the core language feature adopted for C++20. For named type requirements used in the specification of the standard library, see &lt;a href=&quot;../named_req&quot;&gt;named requirements&lt;/a&gt;. For the Concepts TS version of this feature, see &lt;a href=&quot;http://en.cppreference.com/w/cpp/experimental/constraints&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">На этой странице описана базовая функция языка, принятая для C ++ 20. Требования к именованным типам, используемые в спецификации стандартной библиотеки, см. В разделе &lt;a href=&quot;../named_req&quot;&gt;именованные требования&lt;/a&gt; . Для версии Concepts TS этой функции, смотрите &lt;a href=&quot;http://en.cppreference.com/w/cpp/experimental/constraints&quot;&gt;здесь&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="88455b072941af9e8a59177f52c213a26676d97c" translate="yes" xml:space="preserve">
          <source>This partial code fragment illustrates how &lt;code&gt;notify_all_at_thread_exit&lt;/code&gt; can be used to avoid accessing data that depends on thread locals while those thread locals are in the process of being destructed:</source>
          <target state="translated">Этот фрагмент кода показывает, как можно использовать &lt;code&gt;notify_all_at_thread_exit&lt;/code&gt; , чтобы избежать доступа к данным, которые зависят от локальных потоков, в то время как эти локальные потоки находятся в процессе разрушения:</target>
        </trans-unit>
        <trans-unit id="7c5fecf341fbcf23eb1c8bab2cc52b3d4ac7b65d" translate="yes" xml:space="preserve">
          <source>This problem may be worked around using init-statement:</source>
          <target state="translated">Эта проблема может быть решена с помощью инит-формулировки:</target>
        </trans-unit>
        <trans-unit id="6fb590b83ec483a8b56a2365c3f69fb2ed4d882e" translate="yes" xml:space="preserve">
          <source>This process is called</source>
          <target state="translated">Этот процесс называется</target>
        </trans-unit>
        <trans-unit id="a7c693f3363fc29f57e0a818f5fcc2fa68ec620d" translate="yes" xml:space="preserve">
          <source>This program determines the longest substring that is simultaneously found at the very beginning of the given string and at the very end of it, in reverse order (possibly overlapping).</source>
          <target state="translated">Эта программа определяет самую длинную подстроку,которая одновременно находится в самом начале заданной строки и в самом ее конце,в обратном порядке (возможно,в перекрытии).</target>
        </trans-unit>
        <trans-unit id="eafef78a966daecd6d7bcd73bf31b0e1e5ad496e" translate="yes" xml:space="preserve">
          <source>This program simulates throwing 6-sided dice.</source>
          <target state="translated">Эта программа имитирует бросание 6-сторонних костей.</target>
        </trans-unit>
        <trans-unit id="2ea85151fe97fd5e5b0aa44d16e405ebe318a32c" translate="yes" xml:space="preserve">
          <source>This protected virtual function is called by the public functions &lt;a href=&quot;../basic_streambuf/sungetc&quot;&gt;&lt;code&gt;basic_streambuf::sungetc&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../basic_streambuf/sputbackc&quot;&gt;&lt;code&gt;basic_streambuf::sputbackc&lt;/code&gt;&lt;/a&gt; (which, in turn, are called by &lt;a href=&quot;../basic_istream/unget&quot;&gt;&lt;code&gt;basic_istream::unget&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../basic_istream/putback&quot;&gt;&lt;code&gt;basic_istream::putback&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">Эта защищенная виртуальная функция вызывается открытыми функциями &lt;a href=&quot;../basic_streambuf/sungetc&quot;&gt; &lt;code&gt;basic_streambuf::sungetc&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;../basic_streambuf/sputbackc&quot;&gt; &lt;code&gt;basic_streambuf::sputbackc&lt;/code&gt; &lt;/a&gt; (которые, в свою очередь, вызываются &lt;a href=&quot;../basic_istream/unget&quot;&gt; &lt;code&gt;basic_istream::unget&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;../basic_istream/putback&quot;&gt; &lt;code&gt;basic_istream::putback&lt;/code&gt; &lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="996fa56c79f2b555734e9e9593669a195ee9fc8b" translate="yes" xml:space="preserve">
          <source>This protected virtual function is called by the public functions &lt;code&gt;&lt;a href=&quot;sungetc&quot;&gt;sungetc()&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;sputbackc&quot;&gt;sputbackc()&lt;/a&gt;&lt;/code&gt; (which, in turn, are called by &lt;a href=&quot;../basic_istream/unget&quot;&gt;&lt;code&gt;basic_istream::unget&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../basic_istream/putback&quot;&gt;&lt;code&gt;basic_istream::putback&lt;/code&gt;&lt;/a&gt;) when either:</source>
          <target state="translated">Эта защищенная виртуальная функция вызывается открытыми функциями &lt;code&gt;&lt;a href=&quot;sungetc&quot;&gt;sungetc()&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;sputbackc&quot;&gt;sputbackc()&lt;/a&gt;&lt;/code&gt; (которые, в свою очередь, вызываются &lt;a href=&quot;../basic_istream/unget&quot;&gt; &lt;code&gt;basic_istream::unget&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;../basic_istream/putback&quot;&gt; &lt;code&gt;basic_istream::putback&lt;/code&gt; &lt;/a&gt; ), когда либо:</target>
        </trans-unit>
        <trans-unit id="01f04b9a6bf8f295e5a70f9d8714851ba0b2aba1" translate="yes" xml:space="preserve">
          <source>This regenerates the hash table.</source>
          <target state="translated">Это восстанавливает хэш-стол.</target>
        </trans-unit>
        <trans-unit id="2062b86cfcefc181f616f82dcb480679b9c947da" translate="yes" xml:space="preserve">
          <source>This rule also appears in the C++ Core Guidelines as &lt;a href=&quot;https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#Rc-zero&quot;&gt;C.20: If you can avoid defining default operations, do&lt;/a&gt;.</source>
          <target state="translated">Это правило также появляется в C ++ Core Guidelines как &lt;a href=&quot;https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#Rc-zero&quot;&gt;C.20: если вы можете избежать определения операций по умолчанию, сделайте&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4ac284d6084ae4faac12c7c88cba2efd5c565f23" translate="yes" xml:space="preserve">
          <source>This rule applies during overload resolution of function templates: When &lt;a href=&quot;function_template#Template_argument_substitution&quot;&gt;substituting&lt;/a&gt; the explicitly specified or &lt;a href=&quot;template_argument_deduction&quot;&gt;deduced type&lt;/a&gt; for the template parameter fails, the specialization is discarded from the &lt;a href=&quot;overload_resolution&quot;&gt;overload set&lt;/a&gt; instead of causing a compile error.</source>
          <target state="translated">Это правило применяется во время разрешения перегрузки шаблонов функций: при неудачной &lt;a href=&quot;function_template#Template_argument_substitution&quot;&gt;замене&lt;/a&gt; явно заданного или &lt;a href=&quot;template_argument_deduction&quot;&gt;выведенного типа&lt;/a&gt; для параметра шаблона специализация отбрасывается из &lt;a href=&quot;overload_resolution&quot;&gt;набора перегрузок.&lt;/a&gt; а не вызывает ошибку компиляции.</target>
        </trans-unit>
        <trans-unit id="d7cbe3e2801d332154dbf0acb579c831d5324d92" translate="yes" xml:space="preserve">
          <source>This rule enables type-based alias analysis, in which a compiler assumes that the value read through a glvalue of one type is not modified by a write to a glvalue of a different type (subject to the exceptions noted above).</source>
          <target state="translated">Данное правило позволяет проводить типовой анализ псевдонимов,при котором компилятор предполагает,что значение,прочитанное через клеймо одного типа,не изменяется при записи на клеймо другого типа (с учетом исключений,отмеченных выше).</target>
        </trans-unit>
        <trans-unit id="0ed01ea49dcd8fc7a8834c7e1f6f57d09b9ceaaf" translate="yes" xml:space="preserve">
          <source>This section provides definitions for the specific terminology and the concepts used when describing the C++ programming language.</source>
          <target state="translated">В этом разделе даны определения конкретной терминологии и понятий,используемых при описании языка программирования Си++.</target>
        </trans-unit>
        <trans-unit id="28ad28e60d5a5cc2b8a106dc95cfe732a7105f9e" translate="yes" xml:space="preserve">
          <source>This specialization of &lt;code&gt;&lt;a href=&quot;../../../memory/uses_allocator&quot;&gt;std::uses_allocator&lt;/a&gt;&lt;/code&gt; informs other library components that all objects of type &lt;code&gt;&lt;a href=&quot;../function&quot;&gt;std::function&lt;/a&gt;&lt;/code&gt; support</source>
          <target state="translated">Эта специализация &lt;code&gt;&lt;a href=&quot;../../../memory/uses_allocator&quot;&gt;std::uses_allocator&lt;/a&gt;&lt;/code&gt; сообщает другим компонентам библиотеки, что все объекты типа &lt;code&gt;&lt;a href=&quot;../function&quot;&gt;std::function&lt;/a&gt;&lt;/code&gt; поддерживают</target>
        </trans-unit>
        <trans-unit id="8c6b990eab9edf93292f6979537f3edb00a094bd" translate="yes" xml:space="preserve">
          <source>This specialization of &lt;code&gt;&lt;a href=&quot;../../error/error_code/is_error_code_enum&quot;&gt;std::is_error_code_enum&lt;/a&gt;&lt;/code&gt; informs other library components that values of type &lt;code&gt;&lt;a href=&quot;../io_errc&quot;&gt;std::io_errc&lt;/a&gt;&lt;/code&gt; are enumerations that hold error codes, which makes them implicitly convertible and assignable to objects of type &lt;code&gt;&lt;a href=&quot;../../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Эта специализация &lt;code&gt;&lt;a href=&quot;../../error/error_code/is_error_code_enum&quot;&gt;std::is_error_code_enum&lt;/a&gt;&lt;/code&gt; сообщает другим компонентам библиотеки, что значения типа &lt;code&gt;&lt;a href=&quot;../io_errc&quot;&gt;std::io_errc&lt;/a&gt;&lt;/code&gt; являются перечислениями, которые содержат коды ошибок, что делает их неявно конвертируемыми и назначаемыми объектам типа &lt;code&gt;&lt;a href=&quot;../../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bdc8c9de3fc6d0e6ce5408d37d8e773fda6b9547" translate="yes" xml:space="preserve">
          <source>This specialization of &lt;code&gt;&lt;a href=&quot;../../memory/uses_allocator&quot;&gt;std::uses_allocator&lt;/a&gt;&lt;/code&gt; informs other library components that tuples support</source>
          <target state="translated">Эта специализация &lt;code&gt;&lt;a href=&quot;../../memory/uses_allocator&quot;&gt;std::uses_allocator&lt;/a&gt;&lt;/code&gt; информирует другие библиотечные компоненты, которые поддерживают кортежи</target>
        </trans-unit>
        <trans-unit id="038a0d1d441b9b41c30e5117e6ae3ac1df058c8d" translate="yes" xml:space="preserve">
          <source>This specialization of &lt;code&gt;&lt;a href=&quot;ctype&quot;&gt;std::ctype&lt;/a&gt;&lt;/code&gt; encapsulates character classification features for type &lt;code&gt;char&lt;/code&gt;. Unlike general-purpose &lt;code&gt;&lt;a href=&quot;ctype&quot;&gt;std::ctype&lt;/a&gt;&lt;/code&gt;, which uses virtual functions, this specialization uses table lookup to classify characters (which is generally faster).</source>
          <target state="translated">Эта специализация &lt;code&gt;&lt;a href=&quot;ctype&quot;&gt;std::ctype&lt;/a&gt;&lt;/code&gt; инкапсулирует особенности классификации символов для типа &lt;code&gt;char&lt;/code&gt; . В отличие от универсального &lt;code&gt;&lt;a href=&quot;ctype&quot;&gt;std::ctype&lt;/a&gt;&lt;/code&gt; , который использует виртуальные функции, эта специализация использует поиск в таблице для классификации символов (что обычно быстрее).</target>
        </trans-unit>
        <trans-unit id="fe9803ffee86bd599903f2123e0bb2aa07aae79a" translate="yes" xml:space="preserve">
          <source>This specialization of &lt;code&gt;&lt;a href=&quot;ctype_byname&quot;&gt;std::ctype_byname&lt;/a&gt;&lt;/code&gt; encapsulates character classification features for type &lt;code&gt;char&lt;/code&gt;. Like its base class &lt;code&gt;std::ctype&amp;lt;char&amp;gt;&lt;/code&gt; and unlike general-purpose &lt;code&gt;&lt;a href=&quot;ctype_byname&quot;&gt;std::ctype_byname&lt;/a&gt;&lt;/code&gt;, table lookup is used to classify characters.</source>
          <target state="translated">Эта специализация &lt;code&gt;&lt;a href=&quot;ctype_byname&quot;&gt;std::ctype_byname&lt;/a&gt;&lt;/code&gt; включает функции классификации символов для типа &lt;code&gt;char&lt;/code&gt; . Как и его базовый класс &lt;code&gt;std::ctype&amp;lt;char&amp;gt;&lt;/code&gt; и в отличие от общего назначения &lt;code&gt;&lt;a href=&quot;ctype_byname&quot;&gt;std::ctype_byname&lt;/a&gt;&lt;/code&gt; , поиск по таблице используется для классификации символов.</target>
        </trans-unit>
        <trans-unit id="3ddf81e9b15f2fdf0bb22d822a3952f3ead8b84b" translate="yes" xml:space="preserve">
          <source>This specification may appear only on lambda-declarator or on a function declarator that is the top-level(until C++17) declarator of a function, variable, or non-static data member, whose type is a function type, a pointer to function type, a reference to function type, a pointer to member function type. It may appear on the declarator of a parameter or on the declarator of a return type.</source>
          <target state="translated">Эта спецификация может появляться только на лямбда-деклараторе или на деклараторе функции,который является декларатором верхнего уровня (до C++17)функции,переменной или нестатическим членом данных,типом которого является тип функции,указатель на тип функции,ссылка на тип функции,указатель на тип член-функции.Он может появиться на деклараторе параметра или на деклараторе возвращаемого типа.</target>
        </trans-unit>
        <trans-unit id="95164148c00adc35d63c91ae48d3bfe549e3eabc" translate="yes" xml:space="preserve">
          <source>This swap function is protected: it is called by the swap member functions of the derived stream classes such as &lt;code&gt;&lt;a href=&quot;../basic_ofstream&quot;&gt;std::basic_ofstream&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../basic_istringstream&quot;&gt;std::basic_istringstream&lt;/a&gt;&lt;/code&gt;, which know how to correctly swap the associated streambuffers.</source>
          <target state="translated">Эта функция подкачки защищена: она вызывается функциями-членами подкачки производных потоковых классов, таких как &lt;code&gt;&lt;a href=&quot;../basic_ofstream&quot;&gt;std::basic_ofstream&lt;/a&gt;&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;../basic_istringstream&quot;&gt;std::basic_istringstream&lt;/a&gt;&lt;/code&gt; , которые знают, как правильно поменять связанные потоковые буферы.</target>
        </trans-unit>
        <trans-unit id="203ee242898fb95403122a811df27a6f5e11668f" translate="yes" xml:space="preserve">
          <source>This syntax for variadic arguments was introduced in 1983 C++ without the comma before the ellipsis. When C89 adopted function prototypes from C++, it replaced the syntax with one requiring the comma. For compatibility, C++98 accepts both C++-style &lt;code&gt;f(int n...)&lt;/code&gt; and C-style &lt;code&gt;f(int n, ...)&lt;/code&gt;.</source>
          <target state="translated">Этот синтаксис для переменных аргументов был введен в C ++ в 1983 году без запятой перед многоточием. Когда C89 принял прототипы функций из C ++, он заменил синтаксис тем, который требует запятой. Для совместимости, C ++ 98 принимает как F ++ в стиле C &lt;code&gt;f(int n...)&lt;/code&gt; и в стиле C &lt;code&gt;f(int n, ...)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="90ab5c64e037f5bd0606d3f5a893f7a9a8254324" translate="yes" xml:space="preserve">
          <source>This technical specification is supported by GCC as of version 6.1 (requires &lt;code&gt;-fgnu-tm&lt;/code&gt; to enable). An older variant of this specification was &lt;a href=&quot;http://www-users.cs.umn.edu/~boutcher/stm/&quot;&gt;supported in GCC&lt;/a&gt; as of 4.7.</source>
          <target state="translated">Эта техническая спецификация поддерживается GCC &lt;code&gt;-fgnu-tm&lt;/code&gt; версии 6.1 ( для включения требуется -fgnu-tm ). Более старый вариант этой спецификации был &lt;a href=&quot;http://www-users.cs.umn.edu/~boutcher/stm/&quot;&gt;поддержан в GCC&lt;/a&gt; с 4.7.</target>
        </trans-unit>
        <trans-unit id="419df6ad5807d184b62cd3a9400a351c6d85612c" translate="yes" xml:space="preserve">
          <source>This technique is used to construct C++ library interfaces with stable ABI and to reduce compile-time dependencies.</source>
          <target state="translated">Данная методика используется для построения интерфейсов библиотеки C++со стабильным ABI и уменьшения зависимостей от времени компиляции.</target>
        </trans-unit>
        <trans-unit id="a685713d9d750fdc943f666575768010c6772551" translate="yes" xml:space="preserve">
          <source>This template may be specialized for a user-defined type &lt;code&gt;T&lt;/code&gt; to implement &lt;a href=&quot;../../named_req/unarytypetrait&quot;&gt;UnaryTypeTrait&lt;/a&gt; with</source>
          <target state="translated">Этот шаблон может быть специализирован для пользовательского типа &lt;code&gt;T&lt;/code&gt; для реализации &lt;a href=&quot;../../named_req/unarytypetrait&quot;&gt;UnaryTypeTrait&lt;/a&gt; с</target>
        </trans-unit>
        <trans-unit id="25830dd69fe1f966afb7508601b149f9651d15fd" translate="yes" xml:space="preserve">
          <source>This template may be specialized for a user-defined type to indicate that the type is eligible for &lt;code&gt;&lt;a href=&quot;../error_code&quot;&gt;std::error_code&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../error_condition&quot;&gt;std::error_condition&lt;/a&gt;&lt;/code&gt; automatic conversions.</source>
          <target state="translated">Этот шаблон может быть специализирован для определенного пользователем типа, чтобы указать, что этот тип подходит для автоматического преобразования &lt;code&gt;&lt;a href=&quot;../error_code&quot;&gt;std::error_code&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;../error_condition&quot;&gt;std::error_condition&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="921636ccd7ae628df6b1d450ba1978e54fd38c56" translate="yes" xml:space="preserve">
          <source>This template may be specialized for a user-defined type to indicate that the type is eligible for &lt;code&gt;&lt;a href=&quot;../error_condition&quot;&gt;std::error_condition&lt;/a&gt;&lt;/code&gt; automatic conversions.</source>
          <target state="translated">Этот шаблон может быть специализирован для определенного пользователем типа, чтобы указать, что этот тип подходит для автоматического преобразования &lt;code&gt;&lt;a href=&quot;../error_condition&quot;&gt;std::error_condition&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f8d9894e4d5b931e86a98ac460a720072feb42c9" translate="yes" xml:space="preserve">
          <source>This trait does not check anything outside the immediate context of the assignment expression: if the use of &lt;code&gt;T&lt;/code&gt; or &lt;code&gt;U&lt;/code&gt; would trigger template specializations, generation of implicitly-defined special member functions etc, and those have errors, the actual assignment may not compile even if &lt;code&gt;std::is_assignable&amp;lt;T,U&amp;gt;::value&lt;/code&gt; compiles and evaluates to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">Эта черта не проверяет ничего вне непосредственного контекста выражения присваивания: если использование &lt;code&gt;T&lt;/code&gt; или &lt;code&gt;U&lt;/code&gt; вызовет специализации шаблона, генерацию неявно определенных специальных функций-членов и т. Д., И те, которые имеют ошибки, фактическое присваивание может не скомпилироваться, даже если &lt;code&gt;std::is_assignable&amp;lt;T,U&amp;gt;::value&lt;/code&gt; компилируется и оценивается как &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="eb8840cec417013032e8555b42ffbfcba15618b0" translate="yes" xml:space="preserve">
          <source>This trait does not check anything outside the immediate context of the swap expressions: if the use of &lt;code&gt;T&lt;/code&gt; or &lt;code&gt;U&lt;/code&gt; would trigger template specializations, generation of implicitly-defined special member functions etc, and those have errors, the actual swap may not compile even if &lt;code&gt;std::is_swappable_with&amp;lt;T,U&amp;gt;::value&lt;/code&gt; compiles and evaluates to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">Эта черта не проверяет ничего вне непосредственного контекста выражений подкачки: если использование &lt;code&gt;T&lt;/code&gt; или &lt;code&gt;U&lt;/code&gt; вызовет специализации шаблона, генерацию неявно определенных специальных функций-членов и т. Д., И в них есть ошибки, фактический своп может не скомпилироваться, даже если &lt;code&gt;std::is_swappable_with&amp;lt;T,U&amp;gt;::value&lt;/code&gt; компилируется и оценивается как &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="98c54288dcf9d77d236eeecd6daa6884dc0b5970" translate="yes" xml:space="preserve">
          <source>This trait was introduced to make it possible to determine whether a type can be correctly hashed by hashing its object representation as a byte array.</source>
          <target state="translated">Этот признак был введен для того,чтобы можно было определить,может ли тип быть корректно хэширован путем хэширования его объектного представления в виде массива байтов.</target>
        </trans-unit>
        <trans-unit id="aea90bedb8f6381211ab3408991531636fb5ffc1" translate="yes" xml:space="preserve">
          <source>This type can be specialized if the representation &lt;code&gt;Rep&lt;/code&gt; requires a specific implementation to return these duration objects.</source>
          <target state="translated">Этот тип может быть специализированным, если представление &lt;code&gt;Rep&lt;/code&gt; требует конкретной реализации для возврата этих объектов продолжительности.</target>
        </trans-unit>
        <trans-unit id="0087c0a1dcbf0b0f0625fe12349f4e248d5e9491" translate="yes" xml:space="preserve">
          <source>This type represents available options that control the behavior of the &lt;a href=&quot;copy&quot;&gt;&lt;code&gt;copy()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;copy_file&quot;&gt;&lt;code&gt;copy_file()&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">Этот тип представляет доступные параметры, которые управляют поведением функций &lt;a href=&quot;copy&quot;&gt; &lt;code&gt;copy()&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;copy_file&quot;&gt; &lt;code&gt;copy_file()&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9e417e5db45320da2073da483bb3a5847a750f26" translate="yes" xml:space="preserve">
          <source>This type represents available options that control the behavior of the &lt;a href=&quot;directory_iterator&quot;&gt;&lt;code&gt;directory_iterator&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;recursive_directory_iterator&quot;&gt;&lt;code&gt;recursive_directory_iterator&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Этот тип представляет доступные параметры, которые управляют поведением &lt;a href=&quot;directory_iterator&quot;&gt; &lt;code&gt;directory_iterator&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;recursive_directory_iterator&quot;&gt; &lt;code&gt;recursive_directory_iterator&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ed15c087ab4da8efef6f8cef5da62d8cc51d1d4d" translate="yes" xml:space="preserve">
          <source>This type represents available options that control the behavior of the function &lt;a href=&quot;permissions&quot;&gt;&lt;code&gt;permissions()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Этот тип представляет доступные параметры, которые управляют поведением функции &lt;a href=&quot;permissions&quot;&gt; &lt;code&gt;permissions()&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="19b6990a7534cc1c45af33110b91b0350924b0e8" translate="yes" xml:space="preserve">
          <source>This type represents file access permissions. &lt;code&gt;perms&lt;/code&gt; satisfies the requirements of &lt;a href=&quot;../named_req/bitmasktype&quot;&gt;BitmaskType&lt;/a&gt; (which means the bitwise operators &lt;code&gt;operator&amp;amp;&lt;/code&gt;, &lt;code&gt;operator|&lt;/code&gt;, &lt;code&gt;operator^&lt;/code&gt;, &lt;code&gt;operator~&lt;/code&gt;, &lt;code&gt;operator&amp;amp;=&lt;/code&gt;, &lt;code&gt;operator|=&lt;/code&gt;, and &lt;code&gt;operator^=&lt;/code&gt; are defined for this type).</source>
          <target state="translated">Этот тип представляет права доступа к файлу. &lt;code&gt;perms&lt;/code&gt; удовлетворяет требованиям &lt;a href=&quot;../named_req/bitmasktype&quot;&gt;BitmaskType&lt;/a&gt; (что означает, что для этого типа определены побитовые операторы &lt;code&gt;operator&amp;amp;&lt;/code&gt; , &lt;code&gt;operator|&lt;/code&gt; , &lt;code&gt;operator^&lt;/code&gt; , &lt;code&gt;operator~&lt;/code&gt; , &lt;code&gt;operator&amp;amp;=&lt;/code&gt; , &lt;code&gt;operator|=&lt;/code&gt; и &lt;code&gt;operator^=&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="157a64e0ec4c85a12b01b53324ef0dcdfb157238" translate="yes" xml:space="preserve">
          <source>This type requirement is deprecated in the C++ standard. All of its uses have been replaced by the more refined type requirements, such as &lt;a href=&quot;trivialtype&quot;&gt;TrivialType&lt;/a&gt;.</source>
          <target state="translated">Это требование типа не рекомендуется в стандарте C ++. Все его применения были заменены более уточненными требованиями к типу, такими как &lt;a href=&quot;trivialtype&quot;&gt;TrivialType&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="23b4cbf67168a660a04e5a36fcd5bf13a48ffa59" translate="yes" xml:space="preserve">
          <source>This type trait is used by &lt;code&gt;&lt;a href=&quot;../utility/tuple&quot;&gt;std::tuple&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;scoped_allocator_adaptor&quot;&gt;std::scoped_allocator_adaptor&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;polymorphic_allocator&quot;&gt;std::pmr::polymorphic_allocator&lt;/a&gt;&lt;/code&gt;. It may also be used by custom allocators or wrapper types to determine whether the object or member being constructed is itself capable of using an allocator (e.g. is a container), in which case an allocator should be passed to its constructor.</source>
          <target state="translated">Эта черта типа используется в &lt;code&gt;&lt;a href=&quot;../utility/tuple&quot;&gt;std::tuple&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;scoped_allocator_adaptor&quot;&gt;std::scoped_allocator_adaptor&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;polymorphic_allocator&quot;&gt;std::pmr::polymorphic_allocator&lt;/a&gt;&lt;/code&gt; . Он также может использоваться пользовательскими распределителями или типами-обертками для определения, способен ли конструируемый объект или элемент сам использовать распределитель (например, контейнер), и в этом случае распределитель должен быть передан его конструктору.</target>
        </trans-unit>
        <trans-unit id="99d2afd28d674bc31d956763a004b7cd9b730d51" translate="yes" xml:space="preserve">
          <source>This type trait may be specialized for user-provided types that may be used as iterators. The standard library provides two partial specializations for pointer types T*, which makes it possible to use all iterator-based algorithms with raw pointers.</source>
          <target state="translated">Данный признак типа может быть специализирован для предоставляемых пользователем типов,которые могут быть использованы в качестве итераторов.Стандартная библиотека предоставляет две частичные специализации для типов указателей T*,что позволяет использовать все алгоритмы,основанные на итераторах с сырыми указателями.</target>
        </trans-unit>
        <trans-unit id="c5c25f5c1d60bf97a090f5b80fe5a2c0ab183ce7" translate="yes" xml:space="preserve">
          <source>This type trait predates the &lt;a href=&quot;../language/alignof&quot;&gt;alignof keyword&lt;/a&gt;, which can be used to obtain the same value with less verbosity.</source>
          <target state="translated">Этот тип черты предшествует &lt;a href=&quot;../language/alignof&quot;&gt;ключевому слову alignof&lt;/a&gt; , которое можно использовать для получения того же значения с меньшей детализацией.</target>
        </trans-unit>
        <trans-unit id="e0410ce23d7ebcff7e3be952fdf86650da4cb323" translate="yes" xml:space="preserve">
          <source>This value typically reflects the theoretical limit on the size of the container, at most &lt;code&gt;std::numeric_limits&amp;lt;difference_type&amp;gt;::max()&lt;/code&gt;. At runtime, the size of the container may be limited to a value smaller than &lt;code&gt;max_size()&lt;/code&gt; by the amount of RAM available.</source>
          <target state="translated">Это значение обычно отражает теоретический предел размера контейнера, не более &lt;code&gt;std::numeric_limits&amp;lt;difference_type&amp;gt;::max()&lt;/code&gt; . Во время выполнения размер контейнера может быть ограничен значением, меньшим, чем &lt;code&gt;max_size()&lt;/code&gt; , на количество доступной оперативной памяти.</target>
        </trans-unit>
        <trans-unit id="277c3ad089ba0f3cf12d3db7126822c9d80a4896" translate="yes" xml:space="preserve">
          <source>This variable has block scope and static storage duration:</source>
          <target state="translated">Эта переменная имеет блок-объект и статическую длительность хранения:</target>
        </trans-unit>
        <trans-unit id="fae180c729e28c3be7b371f92b90451d0013d47d" translate="yes" xml:space="preserve">
          <source>Those data members that correspond to captures without initializers are &lt;a href=&quot;direct_initialization&quot;&gt;direct-initialized&lt;/a&gt; when the lambda-expression is evaluated. Those that correspond to captures with initializers are initialized as the initializer requires (could be copy- or direct-initialization). If an array is captured, array elements are direct-initialized in increasing index order. The order in which the data members are initialized is the order in which they are declared (which is unspecified).</source>
          <target state="translated">Те элементы данных, которые соответствуют перехватам без инициализаторов, инициализируются &lt;a href=&quot;direct_initialization&quot;&gt;напрямую&lt;/a&gt; при вычислении лямбда-выражения. Те, которые соответствуют перехватам с инициализаторами, инициализируются так, как этого требует инициализатор (может быть копирование или прямая инициализация). Если массив захвачен, элементы массива инициализируются напрямую в порядке возрастания индекса. Порядок, в котором элементы данных инициализируются, является порядком, в котором они объявлены (который не указан).</target>
        </trans-unit>
        <trans-unit id="f4a567a9b52d0caa922bc0235781e01fdf5d4c89" translate="yes" xml:space="preserve">
          <source>Thousands separator and decimal point characters are inserted as required by &lt;code&gt;mp.grouping()&lt;/code&gt;, &lt;code&gt;mp.frac_digits()&lt;/code&gt;, &lt;code&gt;mp.decimal_point()&lt;/code&gt;, and &lt;code&gt;mp.thousands_sep()&lt;/code&gt;, and the resulting string is placed in the output sequence where &lt;code&gt;&lt;a href=&quot;../money_base&quot;&gt;value&lt;/a&gt;&lt;/code&gt; appears in the formatting pattern.</source>
          <target state="translated">Символы разделителя тысяч и десятичной запятой вставляются в соответствии с требованиями &lt;code&gt;mp.grouping()&lt;/code&gt; , &lt;code&gt;mp.frac_digits()&lt;/code&gt; , &lt;code&gt;mp.decimal_point()&lt;/code&gt; и &lt;code&gt;mp.thousands_sep()&lt;/code&gt; , и полученная строка помещается в выходную последовательность, где &lt;code&gt;&lt;a href=&quot;../money_base&quot;&gt;value&lt;/a&gt;&lt;/code&gt; появляется в шаблон форматирования.</target>
        </trans-unit>
        <trans-unit id="d0cef5deb223649da3c92e68bafacf5c8ccd785e" translate="yes" xml:space="preserve">
          <source>Thread safety</source>
          <target state="translated">Безопасность резьбы</target>
        </trans-unit>
        <trans-unit id="604ac3e54d45a1053374b3b32afdb7b25fbf1ed4" translate="yes" xml:space="preserve">
          <source>Thread support</source>
          <target state="translated">Поддержка резьбы</target>
        </trans-unit>
        <trans-unit id="e2d8ff11421f3eaf1af17a9be19957f5569bce89" translate="yes" xml:space="preserve">
          <source>Thread support library</source>
          <target state="translated">Библиотека поддержки нитей</target>
        </trans-unit>
        <trans-unit id="bb12e8aaaecc434fd51e448fe7669bced1bdd107" translate="yes" xml:space="preserve">
          <source>Threads</source>
          <target state="translated">Threads</target>
        </trans-unit>
        <trans-unit id="e7a80c12335015336479b7097a8b8db3ed660872" translate="yes" xml:space="preserve">
          <source>Threads and data races</source>
          <target state="translated">Нитки и информационные гонки</target>
        </trans-unit>
        <trans-unit id="c1492359cb9886c9909e1a4316a9b1847c65e9e9" translate="yes" xml:space="preserve">
          <source>Threads begin execution immediately upon construction of the associated thread object (pending any OS scheduling delays), starting at the top-level function provided as a &lt;a href=&quot;thread/thread&quot;&gt;constructor argument&lt;/a&gt;. The return value of the top-level function is ignored and if it terminates by throwing an exception, &lt;code&gt;&lt;a href=&quot;../error/terminate&quot;&gt;std::terminate&lt;/a&gt;&lt;/code&gt; is called. The top-level function may communicate its return value or an exception to the caller via &lt;code&gt;&lt;a href=&quot;promise&quot;&gt;std::promise&lt;/a&gt;&lt;/code&gt; or by modifying shared variables (which may require synchronization, see &lt;code&gt;&lt;a href=&quot;mutex&quot;&gt;std::mutex&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../atomic/atomic&quot;&gt;std::atomic&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">Потоки начинают выполнение сразу после создания связанного объекта потока (в ожидании любых задержек планирования ОС), начиная с функции верхнего уровня, предоставленной в качестве &lt;a href=&quot;thread/thread&quot;&gt;аргумента конструктора&lt;/a&gt; . Возвращаемое значение функции верхнего уровня игнорируется, и если оно завершается выдачей исключения, вызывается &lt;code&gt;&lt;a href=&quot;../error/terminate&quot;&gt;std::terminate&lt;/a&gt;&lt;/code&gt; . Функция верхнего уровня может передавать свое возвращаемое значение или исключение вызывающей стороне через &lt;code&gt;&lt;a href=&quot;promise&quot;&gt;std::promise&lt;/a&gt;&lt;/code&gt; или путем изменения общих переменных (что может потребовать синхронизации, см. &lt;code&gt;&lt;a href=&quot;mutex&quot;&gt;std::mutex&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;../atomic/atomic&quot;&gt;std::atomic&lt;/a&gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="f4eb730a2ea2fcff234ce55322a48d3d91657b7e" translate="yes" xml:space="preserve">
          <source>Threads enable programs to execute across several processor cores.</source>
          <target state="translated">Потоки позволяют выполнять программы на нескольких ядрах процессора.</target>
        </trans-unit>
        <trans-unit id="a246e49f5181769dcbe8963551805985ea8e8c89" translate="yes" xml:space="preserve">
          <source>Three conditions where &lt;code&gt;std::bad_array_new_length&lt;/code&gt; should be thrown:</source>
          <target state="translated">Три условия, при &lt;code&gt;std::bad_array_new_length&lt;/code&gt; должно быть выброшено std :: bad_array_new_length :</target>
        </trans-unit>
        <trans-unit id="b9e36378830759894e6fe278bd9aa261b8ff8830" translate="yes" xml:space="preserve">
          <source>Three-way comparison</source>
          <target state="translated">Трехстороннее сравнение</target>
        </trans-unit>
        <trans-unit id="762d1a20f1e0eccc439b6c76140f77d0e64ffbd4" translate="yes" xml:space="preserve">
          <source>Three-way comparison can be automatically generated for class types, see &lt;a href=&quot;default_comparisons&quot;&gt;default comparisons&lt;/a&gt;.</source>
          <target state="translated">Трехстороннее сравнение может быть автоматически сгенерировано для типов классов, см. &lt;a href=&quot;default_comparisons&quot;&gt;Сравнение по умолчанию&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="89dc893d701abc8f17f1b70a529a23fb35201ff0" translate="yes" xml:space="preserve">
          <source>Throughout the standard library, bitwise shift operators are commonly overloaded with I/O stream (&lt;code&gt;&lt;a href=&quot;../io/ios_base&quot;&gt;std::ios_base&lt;/a&gt;&amp;amp;&lt;/code&gt; or one of the classes derived from it) as both the left operand and return type. Such operators are known as</source>
          <target state="translated">Во всей стандартной библиотеке операторы побитового сдвига обычно перегружаются потоком ввода-вывода ( &lt;code&gt;&lt;a href=&quot;../io/ios_base&quot;&gt;std::ios_base&lt;/a&gt;&amp;amp;&lt;/code&gt; или одним из производных от него классов) как левый операнд, так и возвращаемый тип. Такие операторы известны как</target>
        </trans-unit>
        <trans-unit id="f13c54f785e2da5ceb32427977752efac6c1f5cc" translate="yes" xml:space="preserve">
          <source>Throw any exception thrown by the currently installed &lt;code&gt;&lt;a href=&quot;unexpected_handler&quot;&gt;std::unexpected_handler&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Бросить любое исключение, выбрасываемое в настоящее время установленным &lt;code&gt;&lt;a href=&quot;unexpected_handler&quot;&gt;std::unexpected_handler&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0ab6516c23d4a4cf955f60f3139340567e17455c" translate="yes" xml:space="preserve">
          <source>Throwing an exception is used to signal errors from functions, where &quot;errors&quot; are typically limited to only the following&lt;sup id=&quot;cite_ref-1&quot;&gt;&lt;a href=&quot;exceptions#cite_note-1&quot;&gt;[1]&lt;/a&gt;&lt;/sup&gt;&lt;sup id=&quot;cite_ref-2&quot;&gt;&lt;a href=&quot;exceptions#cite_note-2&quot;&gt;[2]&lt;/a&gt;&lt;/sup&gt;&lt;sup id=&quot;cite_ref-3&quot;&gt;&lt;a href=&quot;exceptions#cite_note-3&quot;&gt;[3]&lt;/a&gt;&lt;/sup&gt;:</source>
          <target state="translated">Выдача исключения используется для сигнализации об ошибках от функций, где &amp;laquo;ошибки&amp;raquo; обычно ограничиваются только следующими &lt;sup id=&quot;cite_ref-1&quot;&gt;&lt;a href=&quot;exceptions#cite_note-1&quot;&gt;[1] &lt;/a&gt;&lt;/sup&gt;&lt;sup id=&quot;cite_ref-2&quot;&gt;&lt;a href=&quot;exceptions#cite_note-2&quot;&gt;[2] &lt;/a&gt;&lt;/sup&gt;&lt;sup id=&quot;cite_ref-3&quot;&gt;&lt;a href=&quot;exceptions#cite_note-3&quot;&gt;[3]&lt;/a&gt;&lt;/sup&gt; :</target>
        </trans-unit>
        <trans-unit id="7c890cb1e360c745fea29256ca1365d6a4c1baf1" translate="yes" xml:space="preserve">
          <source>Throws &lt;code&gt;&lt;a href=&quot;../../error/length_error/length_error&quot;&gt;std::length_error&lt;/a&gt;&lt;/code&gt; if &lt;code&gt;n &amp;gt; SIZE_MAX / sizeof(T)&lt;/code&gt;; may also any exceptions thrown by the call to &lt;code&gt;resource()-&amp;gt;allocate&lt;/code&gt;.</source>
          <target state="translated">Выдает &lt;code&gt;&lt;a href=&quot;../../error/length_error/length_error&quot;&gt;std::length_error&lt;/a&gt;&lt;/code&gt; если &lt;code&gt;n &amp;gt; SIZE_MAX / sizeof(T)&lt;/code&gt; ; также могут возникать любые исключения, вызванные вызовом &lt;code&gt;resource()-&amp;gt;allocate&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ef7207c238414b15063664465aad815055211c96" translate="yes" xml:space="preserve">
          <source>Throws &lt;code&gt;&lt;a href=&quot;../../error/length_error/length_error&quot;&gt;std::length_error&lt;/a&gt;&lt;/code&gt; if &lt;code&gt;new_cap&lt;/code&gt; is greater than &lt;code&gt;&lt;a href=&quot;max_size&quot;&gt;max_size()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Выдает &lt;code&gt;&lt;a href=&quot;../../error/length_error/length_error&quot;&gt;std::length_error&lt;/a&gt;&lt;/code&gt; если &lt;code&gt;new_cap&lt;/code&gt; больше, чем &lt;code&gt;&lt;a href=&quot;max_size&quot;&gt;max_size()&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="31e238d5140b17c25d7cced51cc7d8f65270714a" translate="yes" xml:space="preserve">
          <source>Throws &lt;code&gt;&lt;a href=&quot;../../error/length_error/length_error&quot;&gt;std::length_error&lt;/a&gt;&lt;/code&gt; if the length of the constructed string would exceed &lt;code&gt;&lt;a href=&quot;max_size&quot;&gt;max_size()&lt;/a&gt;&lt;/code&gt; (for example, if &lt;code&gt;count &amp;gt; max_size()&lt;/code&gt; for (2)). Calls to &lt;code&gt;Allocator::allocate&lt;/code&gt; may throw.</source>
          <target state="translated">Выдает &lt;code&gt;&lt;a href=&quot;../../error/length_error/length_error&quot;&gt;std::length_error&lt;/a&gt;&lt;/code&gt; если длина построенной строки будет превышать &lt;code&gt;&lt;a href=&quot;max_size&quot;&gt;max_size()&lt;/a&gt;&lt;/code&gt; (например, если &lt;code&gt;count &amp;gt; max_size()&lt;/code&gt; для (2)). Вызовы &lt;code&gt;Allocator::allocate&lt;/code&gt; могут генерировать.</target>
        </trans-unit>
        <trans-unit id="5bd5e3a71ffb663ec4af5da4ee91146199c73db9" translate="yes" xml:space="preserve">
          <source>Throws &lt;code&gt;&lt;a href=&quot;../../error/out_of_range/out_of_range&quot;&gt;std::out_of_range&lt;/a&gt;&lt;/code&gt; if &lt;code&gt;pos &amp;gt;= size()&lt;/code&gt;.</source>
          <target state="translated">Выдает &lt;code&gt;&lt;a href=&quot;../../error/out_of_range/out_of_range&quot;&gt;std::out_of_range&lt;/a&gt;&lt;/code&gt; если &lt;code&gt;pos &amp;gt;= size()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0988508382bdadbf64519b871fd4199f1f7e88db" translate="yes" xml:space="preserve">
          <source>Throws &lt;code&gt;&lt;a href=&quot;../../error/runtime_error/runtime_error&quot;&gt;std::runtime_error&lt;/a&gt;&lt;/code&gt; if no such &lt;code&gt;time_zone&lt;/code&gt; can be found.</source>
          <target state="translated">Выдает &lt;code&gt;&lt;a href=&quot;../../error/runtime_error/runtime_error&quot;&gt;std::runtime_error&lt;/a&gt;&lt;/code&gt; если такой &lt;code&gt;time_zone&lt;/code&gt; может быть найден.</target>
        </trans-unit>
        <trans-unit id="0b00d37fc6c817e49da501c1d4283379499ed17c" translate="yes" xml:space="preserve">
          <source>Throws &lt;code&gt;&lt;a href=&quot;../../error/system_error&quot;&gt;std::system_error&lt;/a&gt;&lt;/code&gt; when errors occur, including errors from the underlying operating system that would prevent &lt;code&gt;lock&lt;/code&gt; from meeting its specifications. The mutex is not locked in the case of any exception being thrown.</source>
          <target state="translated">Выдает &lt;code&gt;&lt;a href=&quot;../../error/system_error&quot;&gt;std::system_error&lt;/a&gt;&lt;/code&gt; при возникновении ошибок, в том числе ошибок базовой операционной системы, которые не позволяют &lt;code&gt;lock&lt;/code&gt; соответствовать ее спецификациям. Мьютекс не блокируется в случае возникновения какого-либо исключения.</target>
        </trans-unit>
        <trans-unit id="442b654cd69e928843823a7f4be327a06a469dea" translate="yes" xml:space="preserve">
          <source>Throws &lt;code&gt;&lt;a href=&quot;../error/system_error&quot;&gt;std::system_error&lt;/a&gt;&lt;/code&gt; with error condition &lt;code&gt;&lt;a href=&quot;../error/errc&quot;&gt;std::errc::resource_unavailable_try_again&lt;/a&gt;&lt;/code&gt; if the launch policy equals &lt;code&gt;&lt;a href=&quot;launch&quot;&gt;std::launch::async&lt;/a&gt;&lt;/code&gt; and the implementation is unable to start a new thread (if the policy is &lt;code&gt;async|deferred&lt;/code&gt; or has additional bits set, it will fall back to deferred or the implementation-defined policies in this case), or &lt;code&gt;&lt;a href=&quot;../memory/new/bad_alloc&quot;&gt;std::bad_alloc&lt;/a&gt;&lt;/code&gt; if memory for the internal data structures could not be allocated.</source>
          <target state="translated">Выдает &lt;code&gt;&lt;a href=&quot;../error/system_error&quot;&gt;std::system_error&lt;/a&gt;&lt;/code&gt; с условием ошибки &lt;code&gt;&lt;a href=&quot;../error/errc&quot;&gt;std::errc::resource_unavailable_try_again&lt;/a&gt;&lt;/code&gt; если политика запуска равна &lt;code&gt;&lt;a href=&quot;launch&quot;&gt;std::launch::async&lt;/a&gt;&lt;/code&gt; и реализация не может запустить новый поток (если политика &lt;code&gt;async|deferred&lt;/code&gt; или установлены дополнительные биты , в этом случае он обратится к отложенным или определенным реализацией политикам) или &lt;code&gt;&lt;a href=&quot;../memory/new/bad_alloc&quot;&gt;std::bad_alloc&lt;/a&gt;&lt;/code&gt; если память для внутренних структур данных не может быть выделена.</target>
        </trans-unit>
        <trans-unit id="7fd45fe2a76b5c26edcf480fd318099061d96452" translate="yes" xml:space="preserve">
          <source>Throws &lt;code&gt;&lt;a href=&quot;../ios_base/failure&quot;&gt;std::ios_base::failure&lt;/a&gt;&lt;/code&gt; if &lt;code&gt;operator&amp;gt;&amp;gt;&lt;/code&gt; or &lt;code&gt;operator&amp;lt;&amp;lt;&lt;/code&gt; throws.</source>
          <target state="translated">Выдает &lt;code&gt;&lt;a href=&quot;../ios_base/failure&quot;&gt;std::ios_base::failure&lt;/a&gt;&lt;/code&gt; если &lt;code&gt;operator&amp;gt;&amp;gt;&lt;/code&gt; throws &amp;gt;&amp;gt; или &lt;code&gt;operator&amp;lt;&amp;lt;&lt;/code&gt; throws.</target>
        </trans-unit>
        <trans-unit id="61e7abab0e5d103b8f9ee327388ae0a478e7343f" translate="yes" xml:space="preserve">
          <source>Throws &lt;code&gt;&lt;a href=&quot;../new/bad_alloc&quot;&gt;std::bad_alloc&lt;/a&gt;&lt;/code&gt; if allocation fails.</source>
          <target state="translated">Выдает &lt;code&gt;&lt;a href=&quot;../new/bad_alloc&quot;&gt;std::bad_alloc&lt;/a&gt;&lt;/code&gt; случае неудачного размещения.</target>
        </trans-unit>
        <trans-unit id="610b978856ae75c3eef4b6f3051d9b89a88b02ba" translate="yes" xml:space="preserve">
          <source>Throws &lt;code&gt;&lt;a href=&quot;bad_variant_access&quot;&gt;std::bad_variant_access&lt;/a&gt;&lt;/code&gt; if any variant in &lt;code&gt;vars&lt;/code&gt; is &lt;a href=&quot;valueless_by_exception&quot;&gt;&lt;code&gt;valueless_by_exception&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Выдает &lt;code&gt;&lt;a href=&quot;bad_variant_access&quot;&gt;std::bad_variant_access&lt;/a&gt;&lt;/code&gt; если любой вариант в &lt;code&gt;vars&lt;/code&gt; является &lt;a href=&quot;valueless_by_exception&quot;&gt; &lt;code&gt;valueless_by_exception&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2ccf84cf2370a76be5d96fc6954ac7aa274274a8" translate="yes" xml:space="preserve">
          <source>Throws an exception if storage of the requested size and alignment cannot be obtained.</source>
          <target state="translated">Выбрасывает исключение,если хранение запрашиваемого размера и выравнивание не может быть получено.</target>
        </trans-unit>
        <trans-unit id="78d4655bb8c331d30d35c5dca21382a3023d8907" translate="yes" xml:space="preserve">
          <source>Throws an implementation-defined exception derived from &lt;code&gt;&lt;a href=&quot;../../../error/exception&quot;&gt;std::exception&lt;/a&gt;&lt;/code&gt; if a random number could not be generated.</source>
          <target state="translated">Выдает определяемое реализацией исключение, полученное из &lt;code&gt;&lt;a href=&quot;../../../error/exception&quot;&gt;std::exception&lt;/a&gt;&lt;/code&gt; если случайное число не может быть сгенерировано.</target>
        </trans-unit>
        <trans-unit id="c71eb890289859862d506be6577481a6155d7187" translate="yes" xml:space="preserve">
          <source>Throws an implementation-defined exceptions derived from &lt;code&gt;&lt;a href=&quot;../../../error/exception&quot;&gt;std::exception&lt;/a&gt;&lt;/code&gt; on failure.</source>
          <target state="translated">Выдает определяемые реализацией исключения, полученные из &lt;code&gt;&lt;a href=&quot;../../../error/exception&quot;&gt;std::exception&lt;/a&gt;&lt;/code&gt; при сбое.</target>
        </trans-unit>
        <trans-unit id="7035dd91c99b009a7736d3114cd02d3205a59146" translate="yes" xml:space="preserve">
          <source>Throws any exception thrown by &lt;code&gt;T&lt;/code&gt;'s constructor. If an exception is thrown, the previously contained object (if any) has been destroyed, and &lt;code&gt;*this&lt;/code&gt; does not contain a value.</source>
          <target state="translated">Выдает любое исключение , брошенное &lt;code&gt;T&lt;/code&gt; конструктора &amp;laquo;s. Если выдается исключение, ранее содержащийся объект (если есть) был уничтожен, и &lt;code&gt;*this&lt;/code&gt; не содержит значения.</target>
        </trans-unit>
        <trans-unit id="c4b5347955a68d7b49fb60df96bc4c1fe1be392e" translate="yes" xml:space="preserve">
          <source>Throws any exception thrown by the constructor of &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">Выдает исключение какого - либо брошенное конструктор &lt;code&gt;T&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="62b00b9bd5afe726c1c402b63375bc4866d56f7c" translate="yes" xml:space="preserve">
          <source>Throws no exceptions, unless the construction of &lt;code&gt;fd&lt;/code&gt; throws.</source>
          <target state="translated">Броски без исключений, если только не строит броски &lt;code&gt;fd&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2e4fed0e085b765b71b25a3a55fd75c68b497a32" translate="yes" xml:space="preserve">
          <source>Throws no exceptions.</source>
          <target state="translated">Не выбрасывает исключений.</target>
        </trans-unit>
        <trans-unit id="c77dbbe1f17eaa70afe33271369b7e39a68c956a" translate="yes" xml:space="preserve">
          <source>Throws nothing unless calling &lt;code&gt;allocate()&lt;/code&gt; on the upstream memory resource throws.</source>
          <target state="translated">Ничего не генерирует, если только не вызывать &lt;code&gt;allocate()&lt;/code&gt; для вышестоящих ресурсов памяти.</target>
        </trans-unit>
        <trans-unit id="3473cebcbcfaf057526db12532a7e05950b9a394" translate="yes" xml:space="preserve">
          <source>Throws nothing.</source>
          <target state="translated">Ничего не бросает.</target>
        </trans-unit>
        <trans-unit id="d36a7251aa285e37e60059fda10d55905771330c" translate="yes" xml:space="preserve">
          <source>Throws only if an operation on &lt;code&gt;dest&lt;/code&gt; throws.</source>
          <target state="translated">Бросает, только если операция с &lt;code&gt;dest&lt;/code&gt; бросает.</target>
        </trans-unit>
        <trans-unit id="1ec2a611e5f00a6feb428658f1aa68f1b6da7754" translate="yes" xml:space="preserve">
          <source>Throws the previously captured exception object, referred to by the exception pointer &lt;code&gt;p&lt;/code&gt;.</source>
          <target state="translated">Выдает ранее захваченный объект исключения, на который ссылается указатель исключения &lt;code&gt;p&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bcec7ea351c0f526e56ea2d8f983f85ec1b9038a" translate="yes" xml:space="preserve">
          <source>Thus, replacing the throwing single object deallocation functions (1,3) is sufficient to handle all deallocations.</source>
          <target state="translated">Таким образом,замены бросающих функций разведения одного объекта (1,3)достаточно для обработки всех разделений.</target>
        </trans-unit>
        <trans-unit id="c43feecba43a30ac9fc0c134e6e8cb0382c660f2" translate="yes" xml:space="preserve">
          <source>Time manipulation</source>
          <target state="translated">Манипулирование временем</target>
        </trans-unit>
        <trans-unit id="6a48c0a81754a0e5cd402f2b5b7b65e0802b3ae0" translate="yes" xml:space="preserve">
          <source>Time of day</source>
          <target state="translated">Время суток</target>
        </trans-unit>
        <trans-unit id="848d63dd0e0417a6a6d0653d6feba98b946a8d6e" translate="yes" xml:space="preserve">
          <source>Time point</source>
          <target state="translated">Временная точка</target>
        </trans-unit>
        <trans-unit id="99536a3f0c0c578df6810c5e30a06d3b2da45179" translate="yes" xml:space="preserve">
          <source>Time point (a &lt;code&gt;&lt;a href=&quot;../system_clock&quot;&gt;std::chrono::sys_time&lt;/a&gt;&amp;lt;duration&amp;gt;&lt;/code&gt;)</source>
          <target state="translated">Момент времени ( &lt;code&gt;&lt;a href=&quot;../system_clock&quot;&gt;std::chrono::sys_time&lt;/a&gt;&amp;lt;duration&amp;gt;&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="b99a31f7aded92da84e5f21bdba7429ff03b583d" translate="yes" xml:space="preserve">
          <source>Time point family</source>
          <target state="translated">Семья Time point</target>
        </trans-unit>
        <trans-unit id="3e17e972e7d70a2b0ea19965e0edbbdd317996ef" translate="yes" xml:space="preserve">
          <source>Time since epoch as a &lt;code&gt;&lt;a href=&quot;time_t&quot;&gt;std::time_t&lt;/a&gt;&lt;/code&gt; object on success or &lt;code&gt;-1&lt;/code&gt; if &lt;code&gt;time&lt;/code&gt; cannot be represented as a &lt;code&gt;&lt;a href=&quot;time_t&quot;&gt;std::time_t&lt;/a&gt;&lt;/code&gt; object.</source>
          <target state="translated">Время с начала эпохи как объект &lt;code&gt;&lt;a href=&quot;time_t&quot;&gt;std::time_t&lt;/a&gt;&lt;/code&gt; при успехе или &lt;code&gt;-1&lt;/code&gt; , если &lt;code&gt;time&lt;/code&gt; не может быть представлено как объект &lt;code&gt;&lt;a href=&quot;time_t&quot;&gt;std::time_t&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="baff479affe7646bf932c42ec983a595bbc4b1cf" translate="yes" xml:space="preserve">
          <source>Time tracking (e.g. &lt;code&gt;&lt;a href=&quot;chrono/time_point&quot;&gt;std::chrono::time_point&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;chrono/duration&quot;&gt;std::chrono::duration&lt;/a&gt;&lt;/code&gt;), C-style date and time (e.g. &lt;code&gt;&lt;a href=&quot;chrono/c/time&quot;&gt;std::time&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;chrono/c/clock&quot;&gt;std::clock&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">Отслеживание времени (например, &lt;code&gt;&lt;a href=&quot;chrono/time_point&quot;&gt;std::chrono::time_point&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;chrono/duration&quot;&gt;std::chrono::duration&lt;/a&gt;&lt;/code&gt; ), дата и время в стиле C (например, &lt;code&gt;&lt;a href=&quot;chrono/c/time&quot;&gt;std::time&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;chrono/c/clock&quot;&gt;std::clock&lt;/a&gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="eea79afd832854a3b24153b928ee9c62c7457dbe" translate="yes" xml:space="preserve">
          <source>Time zone</source>
          <target state="translated">Часовой пояс</target>
        </trans-unit>
        <trans-unit id="932d3e6f9a587b1ed93ccda36b7118239840479f" translate="yes" xml:space="preserve">
          <source>Time zone pointer (denoted &lt;code&gt;zone&lt;/code&gt;)</source>
          <target state="translated">Указатель часового пояса (обозначенный &lt;code&gt;zone&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="40349a8ed2b426d8558214c08ff878c9b7836d5c" translate="yes" xml:space="preserve">
          <source>TimedLockable</source>
          <target state="translated">TimedLockable</target>
        </trans-unit>
        <trans-unit id="7a1979526d24991a3fdc66189422c80b7c9499d1" translate="yes" xml:space="preserve">
          <source>TimedMutex</source>
          <target state="translated">TimedMutex</target>
        </trans-unit>
        <trans-unit id="3d854366021896ce0345060f9138ad581720da11" translate="yes" xml:space="preserve">
          <source>To access the variadic arguments from the function body, the following library facilities are provided:</source>
          <target state="translated">Для доступа к вариантным аргументам из тела функции предоставляются следующие библиотечные средства:</target>
        </trans-unit>
        <trans-unit id="2c3649f8d8e3f7fb8fa9a2e0b81692c7c0d56f26" translate="yes" xml:space="preserve">
          <source>To avoid data races, once a shared pointer is passed to any of these functions, it cannot be accessed non-atomically. In particular, you cannot dereference such a shared_ptr without first atomically loading it into another shared_ptr object, and then dereferencing through the second object.</source>
          <target state="translated">Чтобы избежать гонок данных,после передачи общего указателя в любую из этих функций,к нему нельзя получить доступ неатомически.В частности,нельзя разыменовать такой shared_ptr,не загрузив его сначала атоматически в другой объект shared_ptr,а затем разыменовав его через второй объект.</target>
        </trans-unit>
        <trans-unit id="7c35636471d229cbd245a9382f85e9b6dce24337" translate="yes" xml:space="preserve">
          <source>To avoid these quirks, &lt;code&gt;result_of&lt;/code&gt; is often used with reference types as &lt;code&gt;F&lt;/code&gt; and &lt;code&gt;Args...&lt;/code&gt;. For example:</source>
          <target state="translated">Чтобы избежать этих причуд, &lt;code&gt;result_of&lt;/code&gt; часто используется с ссылочными типами , как &lt;code&gt;F&lt;/code&gt; и &lt;code&gt;Args...&lt;/code&gt; . Например:</target>
        </trans-unit>
        <trans-unit id="9af4209978b81d53f6e3f0d4dfaa5d56a5095a25" translate="yes" xml:space="preserve">
          <source>To avoid unnecessary copying of the exception object and object slicing, the best practice for catch clauses is to catch by reference.&lt;sup id=&quot;cite_ref-10&quot;&gt;&lt;a href=&quot;exceptions#cite_note-10&quot;&gt;[10]&lt;/a&gt;&lt;/sup&gt;&lt;sup id=&quot;cite_ref-11&quot;&gt;&lt;a href=&quot;exceptions#cite_note-11&quot;&gt;[11]&lt;/a&gt;&lt;/sup&gt;&lt;sup id=&quot;cite_ref-12&quot;&gt;&lt;a href=&quot;exceptions#cite_note-12&quot;&gt;[12]&lt;/a&gt;&lt;/sup&gt;&lt;sup id=&quot;cite_ref-13&quot;&gt;&lt;a href=&quot;exceptions#cite_note-13&quot;&gt;[13]&lt;/a&gt;&lt;/sup&gt;</source>
          <target state="translated">Чтобы избежать ненужного копирования объекта исключения и нарезки объектов, рекомендуется использовать предложения catch для отсылки по ссылке. &lt;sup id=&quot;cite_ref-10&quot;&gt;&lt;a href=&quot;exceptions#cite_note-10&quot;&gt;[10] &lt;/a&gt;&lt;/sup&gt;&lt;sup id=&quot;cite_ref-11&quot;&gt;&lt;a href=&quot;exceptions#cite_note-11&quot;&gt;[11] &lt;/a&gt;&lt;/sup&gt;&lt;sup id=&quot;cite_ref-12&quot;&gt;&lt;a href=&quot;exceptions#cite_note-12&quot;&gt;[12] &lt;/a&gt;&lt;/sup&gt;&lt;sup id=&quot;cite_ref-13&quot;&gt;&lt;a href=&quot;exceptions#cite_note-13&quot;&gt;[13]&lt;/a&gt;&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="32227a48661c43cebdc36000ab948c6c4f0e7732" translate="yes" xml:space="preserve">
          <source>To be included in the set of viable functions, the candidate function must satisfy the following:</source>
          <target state="translated">Для того чтобы быть включенным в набор жизнеспособных функций,функция кандидата должна удовлетворять следующим требованиям:</target>
        </trans-unit>
        <trans-unit id="1d9269c47d9ba025b6ff347184af6dae00b4781f" translate="yes" xml:space="preserve">
          <source>To call the function,</source>
          <target state="translated">Чтобы вызвать функцию,</target>
        </trans-unit>
        <trans-unit id="3e00e2418f0d13b96de319ccb14e33b157fe6ecf" translate="yes" xml:space="preserve">
          <source>To compile a call to a function template, the compiler has to decide between non-template overloads, template overloads, and the specializations of the template overloads.</source>
          <target state="translated">Чтобы скомпилировать вызов шаблона функции,компилятору приходится выбирать между нешаблонными перегрузками,перегрузками шаблона и специализацией перегрузок шаблона.</target>
        </trans-unit>
        <trans-unit id="648fa0a42ad74259537f74f99862470566d205e4" translate="yes" xml:space="preserve">
          <source>To convert a reference or a pointer to a cv-qualified type to a reference or pointer to a</source>
          <target state="translated">Чтобы преобразовать ссылку или указатель в cv-квалифицированный тип в ссылку или указатель в</target>
        </trans-unit>
        <trans-unit id="479a613a1f4b0b411389efeda8d5cbee450b5792" translate="yes" xml:space="preserve">
          <source>To create a distribution over the closed interval [a,b], &lt;code&gt;&lt;a href=&quot;../../math/nextafter&quot;&gt;std::nextafter&lt;/a&gt;(b, &lt;a href=&quot;../../../types/numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;RealType&amp;gt;::max())&lt;/code&gt; may be used as the second parameter.</source>
          <target state="translated">Чтобы создать распределение по закрытому интервалу [a, b], в качестве второго параметра можно использовать &lt;code&gt;&lt;a href=&quot;../../math/nextafter&quot;&gt;std::nextafter&lt;/a&gt;(b, &lt;a href=&quot;../../../types/numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;RealType&amp;gt;::max())&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d960d66e52b0039243dd579fef5b5e0189abe40c" translate="yes" xml:space="preserve">
          <source>To create a distribution over the closed interval [a,b], &lt;code&gt;&lt;a href=&quot;../math/nextafter&quot;&gt;std::nextafter&lt;/a&gt;(b, &lt;a href=&quot;../../types/numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;RealType&amp;gt;::max())&lt;/code&gt; may be used as the second parameter.</source>
          <target state="translated">Чтобы создать распределение по закрытому интервалу [a, b], в качестве второго параметра можно использовать &lt;code&gt;&lt;a href=&quot;../math/nextafter&quot;&gt;std::nextafter&lt;/a&gt;(b, &lt;a href=&quot;../../types/numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;RealType&amp;gt;::max())&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="99e393ae840d4dfdfd8ab0ea9c4989b21f3b3380" translate="yes" xml:space="preserve">
          <source>To declare a variadic function, an ellipsis is used as the last parameter, e.g. &lt;code&gt;int printf(const char* format, ...);&lt;/code&gt;. See &lt;a href=&quot;../language/variadic_arguments&quot;&gt;Variadic arguments&lt;/a&gt; for additional detail on the syntax, automatic argument conversions and the alternatives.</source>
          <target state="translated">Чтобы объявить переменную функцию, в качестве последнего параметра используется многоточие, например, &lt;code&gt;int printf(const char* format, ...);&lt;/code&gt; , Посмотрите &lt;a href=&quot;../language/variadic_arguments&quot;&gt;Variadic аргументы&lt;/a&gt; для дополнительной информации о синтаксисе, автоматическом преобразовании аргументов и альтернативах.</target>
        </trans-unit>
        <trans-unit id="22cd3be1d2fb287ce824540ee1391a62cb561144" translate="yes" xml:space="preserve">
          <source>To ensure that the program benefits from the optimizations enabled by &lt;code&gt;assume_aligned&lt;/code&gt;, it is important to access the object via its return value:</source>
          <target state="translated">Чтобы гарантировать, что программа извлекает выгоду из оптимизаций, включенных &lt;code&gt;assume_aligned&lt;/code&gt; , важно получить доступ к объекту через его возвращаемое значение:</target>
        </trans-unit>
        <trans-unit id="525fd31bb668048344f8a31de0c1142305eb7415" translate="yes" xml:space="preserve">
          <source>To generate enough entropy, &lt;code&gt;generate_canonical()&lt;/code&gt; will call &lt;code&gt;g()&lt;/code&gt; exactly k times, where \(k = max(1, \lceil \frac{b}{log_2 R} \rceil)\)k = max(1, &amp;lceil; b / log</source>
          <target state="translated">Чтобы сгенерировать достаточно энтропии, &lt;code&gt;generate_canonical()&lt;/code&gt; будет вызывать &lt;code&gt;g()&lt;/code&gt; ровно k раз, где \ (k = max (1, \ lceil \ frac {b} {log_2 R} \ rceil) \) k = max (1, &amp;lceil; b / журнал</target>
        </trans-unit>
        <trans-unit id="2c0e3e28251239ee8bfb2240bdd1fc0f1ed54c3c" translate="yes" xml:space="preserve">
          <source>To grant access to additional functions or classes to protected or private members, a &lt;a href=&quot;friend&quot;&gt;friendship declaration&lt;/a&gt; may be used.</source>
          <target state="translated">Чтобы предоставить доступ к дополнительным функциям или классам защищенным или закрытым членам, можно использовать &lt;a href=&quot;friend&quot;&gt;объявление&lt;/a&gt; о дружбе .</target>
        </trans-unit>
        <trans-unit id="878939687f32a6c24537c7a73b290843588b7164" translate="yes" xml:space="preserve">
          <source>To initialize a pointer to null or to assign the null value to an existing pointer, the null pointer literal &lt;code&gt;nullptr&lt;/code&gt;, the null pointer constant &lt;code&gt;&lt;a href=&quot;../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt;, or the &lt;a href=&quot;implicit_cast&quot;&gt;implicit conversion&lt;/a&gt; from the integer value &lt;code&gt;​0​&lt;/code&gt; may be used.</source>
          <target state="translated">Для того, чтобы инициализировать указатель на нуль или присвоить нулевое значение в существующем указатель, указатель нулевого буквальный &lt;code&gt;nullptr&lt;/code&gt; , указатель нулевой константа &lt;code&gt;&lt;a href=&quot;../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt; , или &lt;a href=&quot;implicit_cast&quot;&gt;неявное преобразование&lt;/a&gt; из целочисленного значения &lt;code&gt;​0​&lt;/code&gt; может быть использовано.</target>
        </trans-unit>
        <trans-unit id="e3122235602ec384e5e6446cb56e5141efaef34c" translate="yes" xml:space="preserve">
          <source>To iterate over the current directory, construct the iterator as &lt;code&gt;directory_iterator(&quot;.&quot;)&lt;/code&gt; instead of &lt;code&gt;directory_iterator(&quot;&quot;)&lt;/code&gt;.</source>
          <target state="translated">Чтобы выполнить итерацию по текущему каталогу, создайте итератор как &lt;code&gt;directory_iterator(&quot;.&quot;)&lt;/code&gt; Вместо &lt;code&gt;directory_iterator(&quot;&quot;)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="724317f9ed9523d1d5aa4de4bf63c61feb5cf73f" translate="yes" xml:space="preserve">
          <source>To make ADL examine a user-defined namespace, either &lt;code&gt;std::vector&lt;/code&gt; should be replaced by a user-defined class or its element type should be a user-defined class:</source>
          <target state="translated">Чтобы заставить ADL проверять пользовательское пространство имен, либо &lt;code&gt;std::vector&lt;/code&gt; следует заменить пользовательским классом, либо его тип элемента должен быть пользовательским классом:</target>
        </trans-unit>
        <trans-unit id="9dacb8ab35ec1963dda5bb3c402d87f89eb9adc7" translate="yes" xml:space="preserve">
          <source>To make strong exception guarantee possible, user-defined move constructors should not throw exceptions. For example, &lt;code&gt;&lt;a href=&quot;../container/vector&quot;&gt;std::vector&lt;/a&gt;&lt;/code&gt; relies on &lt;code&gt;&lt;a href=&quot;../utility/move_if_noexcept&quot;&gt;std::move_if_noexcept&lt;/a&gt;&lt;/code&gt; to choose between move and copy when the elements need to be relocated.</source>
          <target state="translated">Чтобы сделать возможным строгое исключение, пользовательские конструкторы перемещения не должны генерировать исключения. Например, &lt;code&gt;&lt;a href=&quot;../container/vector&quot;&gt;std::vector&lt;/a&gt;&lt;/code&gt; использует &lt;code&gt;&lt;a href=&quot;../utility/move_if_noexcept&quot;&gt;std::move_if_noexcept&lt;/a&gt;&lt;/code&gt; для выбора между перемещением и копированием, когда необходимо переместить элементы.</target>
        </trans-unit>
        <trans-unit id="fbaf135ff4214aca3306677fb2ad01282f0bd0a8" translate="yes" xml:space="preserve">
          <source>To match a template template argument &lt;code&gt;A&lt;/code&gt; to a template template parameter &lt;code&gt;P&lt;/code&gt;, each of the template parameters of &lt;code&gt;A&lt;/code&gt; must match corresponding template parameters of &lt;code&gt;P&lt;/code&gt; exactly(until C++17)&lt;code&gt;P&lt;/code&gt; must be at least as specialized as &lt;code&gt;A&lt;/code&gt;(since C++17). If &lt;code&gt;P&lt;/code&gt;'s parameter list includes a &lt;a href=&quot;parameter_pack&quot;&gt;parameter pack&lt;/a&gt;, zero or more template parameters (or parameter packs) from &lt;code&gt;A&lt;/code&gt;'s template parameter list are matched by it.</source>
          <target state="translated">Чтобы сопоставить аргумент шаблона шаблона &lt;code&gt;A&lt;/code&gt; с параметром шаблона шаблона &lt;code&gt;P&lt;/code&gt; , каждый из параметров шаблона &lt;code&gt;A&lt;/code&gt; должен точно соответствовать соответствующим параметрам шаблона &lt;code&gt;P&lt;/code&gt; (до C ++ 17). &lt;code&gt;P&lt;/code&gt; должен быть по крайней мере таким же специализированным, как &lt;code&gt;A&lt;/code&gt; (поскольку C ++ 17). Если список параметров &lt;code&gt;P&lt;/code&gt; включает в себя &lt;a href=&quot;parameter_pack&quot;&gt;пакет&lt;/a&gt; параметров, ему сопоставляются ноль или более параметров шаблона (или пакетов параметров) из списка параметров шаблона &lt;code&gt;A&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1653fef798170fad22ce8f246671d9967ebf88bf" translate="yes" xml:space="preserve">
          <source>To provide multidimensional array access semantics, e.g. to implement a 3D array access &lt;code&gt;a[i][j][k] = x;&lt;/code&gt;, operator[] has to return a reference to a 2D plane, which has to have its own operator[] which returns a reference to a 1D row, which has to have operator[] which returns a reference to the element. To avoid this complexity, some libraries opt for overloading &lt;code&gt;operator()&lt;/code&gt; instead, so that 3D access expressions have the Fortran-like syntax &lt;code&gt;a(i, j, k) = x;&lt;/code&gt;</source>
          <target state="translated">Для обеспечения семантики доступа к многомерному массиву, например, для реализации доступа к трехмерному массиву &lt;code&gt;a[i][j][k] = x;&lt;/code&gt; , operator [] должен возвращать ссылку на 2D-плоскость, которая должна иметь свой собственный оператор [], который возвращает ссылку на одномерную строку, которая должна иметь оператор [], который возвращает ссылку на элемент. Чтобы избежать этой сложности, некоторые библиотеки вместо этого выбирают перегрузку &lt;code&gt;operator()&lt;/code&gt; , чтобы выражения трехмерного доступа имели Fortran-подобный синтаксис &lt;code&gt;a(i, j, k) = x;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="106dedcf05132b51eabb9b06f962997250951fc9" translate="yes" xml:space="preserve">
          <source>To refer to a static member &lt;code&gt;m&lt;/code&gt; of class &lt;code&gt;T&lt;/code&gt;, two forms may be used: qualified name &lt;code&gt;T::m&lt;/code&gt; or member access expression &lt;code&gt;E.m&lt;/code&gt; or &lt;code&gt;E-&amp;gt;m&lt;/code&gt;, where &lt;code&gt;E&lt;/code&gt; is an expression that evaluates to &lt;code&gt;T&lt;/code&gt; or &lt;code&gt;T*&lt;/code&gt; respectively. When in the same class scope, the qualification is unnecessary:</source>
          <target state="translated">Для ссылки на статический член &lt;code&gt;m&lt;/code&gt; класса &lt;code&gt;T&lt;/code&gt; можно использовать две формы: квалифицированное имя &lt;code&gt;T::m&lt;/code&gt; или выражение доступа к члену &lt;code&gt;E.m&lt;/code&gt; или &lt;code&gt;E-&amp;gt;m&lt;/code&gt; , где &lt;code&gt;E&lt;/code&gt; - это выражение, которое оценивается как &lt;code&gt;T&lt;/code&gt; или &lt;code&gt;T*&lt;/code&gt; соответственно. Когда в той же области видимости класса, квалификация не нужна:</target>
        </trans-unit>
        <trans-unit id="3726bd5210fa66b99d1405f1d23513ff4e9a847a" translate="yes" xml:space="preserve">
          <source>To reopen an existing namespace (formally, to be an</source>
          <target state="translated">Чтобы заново открыть существующее пространство имен (формально,чтобы быть</target>
        </trans-unit>
        <trans-unit id="6766595568bdee575215126dcd221dc1330e2532" translate="yes" xml:space="preserve">
          <source>To replace the managed object while supplying a new deleter as well, move assignment operator may be used.</source>
          <target state="translated">Для замены управляемого объекта при поставке нового удалителя также может использоваться оператор назначения перемещения.</target>
        </trans-unit>
        <trans-unit id="f22138cc2032a2d9e0e8461eb5887bb980094c3c" translate="yes" xml:space="preserve">
          <source>To satisfy this requirement, types that do not have built-in &lt;a href=&quot;../language/operator_comparison&quot;&gt;comparison operators&lt;/a&gt; have to provide a &lt;a href=&quot;../language/operators&quot;&gt;user-defined operator==&lt;/a&gt;.</source>
          <target state="translated">Чтобы удовлетворить это требование, типы, которые не имеют встроенных &lt;a href=&quot;../language/operator_comparison&quot;&gt;операторов сравнения,&lt;/a&gt; должны предоставлять &lt;a href=&quot;../language/operators&quot;&gt;пользовательский оператор ==&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="129c710e9009508a2e1a7fdb48457bda967c930d" translate="yes" xml:space="preserve">
          <source>To satisfy this requirement, types that do not have built-in &lt;a href=&quot;../language/operator_comparison&quot;&gt;comparison operators&lt;/a&gt; have to provide a &lt;a href=&quot;../language/operators#Relational_operators&quot;&gt;user-defined operator&amp;lt;&lt;/a&gt;</source>
          <target state="translated">Чтобы удовлетворить это требование, типы, которые не имеют встроенных &lt;a href=&quot;../language/operator_comparison&quot;&gt;операторов сравнения,&lt;/a&gt; должны предоставлять &lt;a href=&quot;../language/operators#Relational_operators&quot;&gt;пользовательский оператор &amp;lt;&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="17417ca14266e537b698e5e14276654d4c17a975" translate="yes" xml:space="preserve">
          <source>To satisfy thread safety requirements, the reference counters are typically incremented using an equivalent of &lt;code&gt;&lt;a href=&quot;../atomic/atomic/fetch_add&quot;&gt;std::atomic::fetch_add&lt;/a&gt;&lt;/code&gt; with &lt;code&gt;&lt;a href=&quot;../atomic/memory_order&quot;&gt;std::memory_order_relaxed&lt;/a&gt;&lt;/code&gt; (decrementing requires stronger ordering to safely destroy the control block).</source>
          <target state="translated">Чтобы удовлетворить требования безопасности потока, счетчики ссылок обычно увеличиваются с использованием эквивалента &lt;code&gt;&lt;a href=&quot;../atomic/atomic/fetch_add&quot;&gt;std::atomic::fetch_add&lt;/a&gt;&lt;/code&gt; с &lt;code&gt;&lt;a href=&quot;../atomic/memory_order&quot;&gt;std::memory_order_relaxed&lt;/a&gt;&lt;/code&gt; (уменьшение требует более строгого порядка для безопасного уничтожения блока управления).</target>
        </trans-unit>
        <trans-unit id="8878bda84316e640272f36cf3fc4a73005bafae8" translate="yes" xml:space="preserve">
          <source>To simplify management of dynamically-allocated objects, the result of a new-expression is often stored in a</source>
          <target state="translated">Чтобы упростить управление динамически расположенными объектами,результат нового выражения часто хранится в</target>
        </trans-unit>
        <trans-unit id="72759510b678f958968f4cb0b51ad3056400cce9" translate="yes" xml:space="preserve">
          <source>To test the last two conditions, compilers may first perform a trial constant evaluation of the initializers. It is not recommended to depend on the result in this case.</source>
          <target state="translated">Для проверки последних двух условий компиляторы могут сначала выполнить пробную постоянную оценку инициализаторов.В этом случае не рекомендуется зависеть от результата.</target>
        </trans-unit>
        <trans-unit id="2ef767a66957791708ed92649c40f252de18b675" translate="yes" xml:space="preserve">
          <source>Tobject&lt;code&gt; (&lt;/code&gt;arg1, arg2, ...&lt;code&gt;);&lt;/code&gt;</source>
          <target state="translated">Tobject &lt;code&gt; (&lt;/code&gt; arg1, arg2, ... &lt;code&gt;);&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1fd5e6c8eaf332caffe8f6fbe44a90cd7d1b98a0" translate="yes" xml:space="preserve">
          <source>Tobject&lt;code&gt; {&lt;/code&gt;&lt;code&gt;.&lt;/code&gt;designator&lt;code&gt;=&lt;/code&gt;arg1&lt;code&gt;,&lt;/code&gt;&lt;code&gt;.&lt;/code&gt;designator&lt;code&gt;{&lt;/code&gt;arg2&lt;code&gt;} &lt;/code&gt;... &lt;code&gt;};&lt;/code&gt;</source>
          <target state="translated">Tobject &lt;code&gt; {&lt;/code&gt; &lt;code&gt;.&lt;/code&gt; Обозначение &lt;code&gt;=&lt;/code&gt; арг1 &lt;code&gt;,&lt;/code&gt; &lt;code&gt;.&lt;/code&gt; указатель &lt;code&gt;{&lt;/code&gt; arg2 &lt;code&gt;} &lt;/code&gt; ... &lt;code&gt;};&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8524224705b06e86014d7113489a9fa766f785d6" translate="yes" xml:space="preserve">
          <source>Tobject&lt;code&gt; {&lt;/code&gt;arg1, arg2, ...&lt;code&gt;};&lt;/code&gt;</source>
          <target state="translated">Tobject &lt;code&gt; {&lt;/code&gt; arg1, arg2, ... &lt;code&gt;};&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1fa04374ca1b3d5854920daae3a860b764cf4bc1" translate="yes" xml:space="preserve">
          <source>Tobject&lt;code&gt;( &lt;/code&gt;arg1, arg2, ...&lt;code&gt;);&lt;/code&gt;</source>
          <target state="translated">Tobject &lt;code&gt;( &lt;/code&gt; arg1, arg2, ... &lt;code&gt;);&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ad21f03c3b6e98547a57e446e234ea4a3bc549c4" translate="yes" xml:space="preserve">
          <source>Tobject&lt;code&gt;( &lt;/code&gt;arg&lt;code&gt;);&lt;/code&gt;</source>
          <target state="translated">Tobject &lt;code&gt;( &lt;/code&gt; arg &lt;code&gt;);&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="73dc4cf67a69ee8abf0145c5834683df2e89c44e" translate="yes" xml:space="preserve">
          <source>Tobject&lt;code&gt;;&lt;/code&gt;</source>
          <target state="translated">Tobject&lt;code&gt;;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8be85a4e1d42709d6cc3339f92d0ed646df7afbf" translate="yes" xml:space="preserve">
          <source>Tobject&lt;code&gt;= {&lt;/code&gt;arg1, arg2, ...&lt;code&gt;};&lt;/code&gt;</source>
          <target state="translated">Tobject &lt;code&gt;= {&lt;/code&gt; arg1, arg2, ... &lt;code&gt;};&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="749c4b6dafadee83198511f34995fe4793451e2c" translate="yes" xml:space="preserve">
          <source>Tobject&lt;code&gt;=&lt;/code&gt;&lt;code&gt; {&lt;/code&gt;&lt;code&gt;.&lt;/code&gt;designator&lt;code&gt;=&lt;/code&gt;arg1&lt;code&gt;,&lt;/code&gt;&lt;code&gt;.&lt;/code&gt;designator&lt;code&gt;{&lt;/code&gt;arg2&lt;code&gt;} &lt;/code&gt;... &lt;code&gt;};&lt;/code&gt;</source>
          <target state="translated">Tobject &lt;code&gt;=&lt;/code&gt; &lt;code&gt; {&lt;/code&gt; &lt;code&gt;.&lt;/code&gt; Обозначение &lt;code&gt;=&lt;/code&gt; арг1 &lt;code&gt;,&lt;/code&gt; &lt;code&gt;.&lt;/code&gt; указатель &lt;code&gt;{&lt;/code&gt; arg2 &lt;code&gt;} &lt;/code&gt; ... &lt;code&gt;};&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="66d34b7b6a63046c11e32cb28d0bfdc320edb9c6" translate="yes" xml:space="preserve">
          <source>Tobject&lt;code&gt;=&lt;/code&gt;&lt;code&gt;{&lt;/code&gt;other&lt;code&gt;} &lt;/code&gt;&lt;code&gt;;&lt;/code&gt;</source>
          <target state="translated">Tobject &lt;code&gt;=&lt;/code&gt; &lt;code&gt;{&lt;/code&gt; другое &lt;code&gt;} &lt;/code&gt; &lt;code&gt;;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ca0bdecf7ffe3b07ea0bd6237e1e29b32609b1b3" translate="yes" xml:space="preserve">
          <source>Tobject&lt;code&gt;=&lt;/code&gt;other&lt;code&gt;;&lt;/code&gt;</source>
          <target state="translated">Tobject&lt;code&gt;=&lt;/code&gt;other&lt;code&gt;;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="709755aaf5485c722f9b0e75a1395ff736803b24" translate="yes" xml:space="preserve">
          <source>Tobject&lt;code&gt;{ &lt;/code&gt;arg1, arg2, ...&lt;code&gt;};&lt;/code&gt;</source>
          <target state="translated">Tobject &lt;code&gt;{ &lt;/code&gt; arg1, arg2, ... &lt;code&gt;};&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="61782cc12972859d36df728c91f3cae207b1187e" translate="yes" xml:space="preserve">
          <source>Tobject&lt;code&gt;{ &lt;/code&gt;arg&lt;code&gt;};&lt;/code&gt;</source>
          <target state="translated">Tobject &lt;code&gt;{ &lt;/code&gt; arg &lt;code&gt;};&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f01015bfa0f56ac60d1e5a7cf450991d276e29b7" translate="yes" xml:space="preserve">
          <source>Tobject&lt;code&gt;{};&lt;/code&gt;</source>
          <target state="translated">Tobject&lt;code&gt;{};&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ddb24f2589165d45d6ccb527543d8886fc657afc" translate="yes" xml:space="preserve">
          <source>Together with identifiers they are known as</source>
          <target state="translated">Вместе с идентификаторами они известны как</target>
        </trans-unit>
        <trans-unit id="3eff2f682c2bec3252c55e73a2e17235c924d9ac" translate="yes" xml:space="preserve">
          <source>Toggles each &lt;code&gt;bool&lt;/code&gt; in the vector (replaces with its opposite value).</source>
          <target state="translated">Переключает каждый &lt;code&gt;bool&lt;/code&gt; в векторе (заменяет его на противоположное значение).</target>
        </trans-unit>
        <trans-unit id="f77fbd9a82d243179f6ff219e1e46df3d7caa6d5" translate="yes" xml:space="preserve">
          <source>Too many files open in system</source>
          <target state="translated">Слишком много файлов открыто в системе</target>
        </trans-unit>
        <trans-unit id="2e0d2eef3cc8719301cd02a8aeecb9e956e88cf1" translate="yes" xml:space="preserve">
          <source>Too many levels of symbolic links</source>
          <target state="translated">Слишком много уровней символических связей</target>
        </trans-unit>
        <trans-unit id="4113b4c9ebd053469430304ab17dc16ea1d01df9" translate="yes" xml:space="preserve">
          <source>Too many links</source>
          <target state="translated">Слишком много ссылок</target>
        </trans-unit>
        <trans-unit id="171702bf2e722b21f3bd6c8ccb2927b1ba5f9e5e" translate="yes" xml:space="preserve">
          <source>Total ordering relation opposite to &lt;code&gt;a &amp;lt; b&lt;/code&gt;</source>
          <target state="translated">Общее отношение порядка напротив &lt;code&gt;a &amp;lt; b&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="00914541a4417609db5b497e533746eecb783cd5" translate="yes" xml:space="preserve">
          <source>Total sequential ordering requires a full memory fence CPU instruction on all multi-core systems. This may become a performance bottleneck since it forces the affected memory accesses to propagate to every core.</source>
          <target state="translated">Для полного последовательного заказа требуется полная инструкция ЦПУ ограждения памяти на всех многоядерных системах.Это может стать узким местом в производительности,так как заставляет пострадавшие доступы к памяти распространяться на каждое ядро.</target>
        </trans-unit>
        <trans-unit id="dad674e48704a92597b8a13244ba1d8ca29324b7" translate="yes" xml:space="preserve">
          <source>Trade-offs</source>
          <target state="translated">Trade-offs</target>
        </trans-unit>
        <trans-unit id="ef3b5b7a3bf5164b6e6ee23c058ba72528930808" translate="yes" xml:space="preserve">
          <source>Trade-offs / usage notes</source>
          <target state="translated">Компромиссы/указания по использованию</target>
        </trans-unit>
        <trans-unit id="7cf26da75debf6bbf1e4104795dc48892c4d5484" translate="yes" xml:space="preserve">
          <source>Trailing return type, useful if the return type depends on argument names, such as &lt;code&gt;template &amp;lt;class T, class U&amp;gt; auto add(T t, U u) -&amp;gt; decltype(t + u);&lt;/code&gt; or is complicated, such as in &lt;code&gt;auto fpif(int)-&amp;gt;int(*)(int)&lt;/code&gt;</source>
          <target state="translated">Конечный тип возвращаемого значения, полезно, если тип возвращаемого значения зависит от имен аргументов, таких как &lt;code&gt;template &amp;lt;class T, class U&amp;gt; auto add(T t, U u) -&amp;gt; decltype(t + u);&lt;/code&gt; или сложный, например, в &lt;code&gt;auto fpif(int)-&amp;gt;int(*)(int)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d1a616085a1a99a58e14bafaa350abc6783a3160" translate="yes" xml:space="preserve">
          <source>Traits</source>
          <target state="translated">Traits</target>
        </trans-unit>
        <trans-unit id="cd91d96e3393ae0f62bad1c5ed125449050e450f" translate="yes" xml:space="preserve">
          <source>Transaction-safe functions</source>
          <target state="translated">Транзакционные функции</target>
        </trans-unit>
        <trans-unit id="79ed6ec4dd6c977b5231ac5a3a3185c0bc9188fd" translate="yes" xml:space="preserve">
          <source>Transaction-safe virtual functions</source>
          <target state="translated">Виртуальные функции,обеспечивающие безопасность операций</target>
        </trans-unit>
        <trans-unit id="28bf6d401ae77b97e36abdf2221c6cfe2e85fc1e" translate="yes" xml:space="preserve">
          <source>Transactional memory</source>
          <target state="translated">Операционная память</target>
        </trans-unit>
        <trans-unit id="76f8221e9e089679019e2f0fa532136f150e6dc7" translate="yes" xml:space="preserve">
          <source>Transactional memory is a concurrency synchronization mechanism that combines groups of statements in transactions, that are.</source>
          <target state="translated">Транзакционная память-это механизм синхронизации параллельных транзакций,который объединяет группы операторов в транзакциях.</target>
        </trans-unit>
        <trans-unit id="6b317497e33c505c0091e508e0f819e953607bb9" translate="yes" xml:space="preserve">
          <source>Transfers control to one of the several statements, depending on the value of a condition.</source>
          <target state="translated">Переводит управление в одно из нескольких положений,в зависимости от значения условия.</target>
        </trans-unit>
        <trans-unit id="3ae0e89e8b68942479d9172eed374b0285eee3cc" translate="yes" xml:space="preserve">
          <source>Transfers control unconditionally.</source>
          <target state="translated">Трансферы контролируют безоговорочно.</target>
        </trans-unit>
        <trans-unit id="1f702e1322ae9e879ee08e3f62c5bdb1e12300d8" translate="yes" xml:space="preserve">
          <source>Transfers elements from one list to another.</source>
          <target state="translated">Переводит элементы из одного списка в другой.</target>
        </trans-unit>
        <trans-unit id="3de309422c516a3c7cf8622a78d8e35f6e1be1eb" translate="yes" xml:space="preserve">
          <source>Transfers the shared state of &lt;code&gt;*this&lt;/code&gt;, if any, to a &lt;code&gt;&lt;a href=&quot;../shared_future&quot;&gt;std::shared_future&lt;/a&gt;&lt;/code&gt; object. Multiple &lt;code&gt;&lt;a href=&quot;../shared_future&quot;&gt;std::shared_future&lt;/a&gt;&lt;/code&gt; objects may reference the same shared state, which is not possible with &lt;code&gt;&lt;a href=&quot;../future&quot;&gt;std::future&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Передает общее состояние &lt;code&gt;*this&lt;/code&gt; , если оно есть, в объект &lt;code&gt;&lt;a href=&quot;../shared_future&quot;&gt;std::shared_future&lt;/a&gt;&lt;/code&gt; . Несколько объектов &lt;code&gt;&lt;a href=&quot;../shared_future&quot;&gt;std::shared_future&lt;/a&gt;&lt;/code&gt; могут ссылаться на одно и то же общее состояние, что невозможно в &lt;code&gt;&lt;a href=&quot;../future&quot;&gt;std::future&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="17a159e3083a2a40c26d036cc1b99d55a3a0d7c4" translate="yes" xml:space="preserve">
          <source>Transform the elements of the output range according to the following algorithm:</source>
          <target state="translated">Преобразовывайте элементы выходного диапазона по следующему алгоритму:</target>
        </trans-unit>
        <trans-unit id="0d2ad20c7dacbba2fdbdd4ce378e8828c433c3a1" translate="yes" xml:space="preserve">
          <source>TransformationTrait</source>
          <target state="translated">TransformationTrait</target>
        </trans-unit>
        <trans-unit id="7bfde37a73ea6090d21989590088e7aade736914" translate="yes" xml:space="preserve">
          <source>TransformationTraits Redux</source>
          <target state="translated">TransformationTrait Redux</target>
        </trans-unit>
        <trans-unit id="4ce48d092354c3cfaf58f19e47f595e8893390a1" translate="yes" xml:space="preserve">
          <source>Transforms each element in the range &lt;code&gt;[first, last)&lt;/code&gt; with &lt;code&gt;unary_op&lt;/code&gt;, then computes an exclusive prefix sum operation using &lt;code&gt;binary_op&lt;/code&gt; over the resulting range, with &lt;code&gt;init&lt;/code&gt; as the initial value, and writes the results to the range beginning at &lt;code&gt;d_first&lt;/code&gt;. &quot;exclusive&quot; means that the i-th input element is not included in the i-th sum.</source>
          <target state="translated">Преобразует каждый элемент в диапазоне &lt;code&gt;[first, last)&lt;/code&gt; с помощью &lt;code&gt;unary_op&lt;/code&gt; , затем вычисляет исключительную операцию суммирования префикса, используя &lt;code&gt;binary_op&lt;/code&gt; в результирующем диапазоне, с &lt;code&gt;init&lt;/code&gt; в качестве начального значения, и записывает результаты в диапазон, начинающийся с &lt;code&gt;d_first&lt;/code&gt; . &amp;laquo;исключительный&amp;raquo; означает, что i-й элемент ввода не включен в i-ю сумму.</target>
        </trans-unit>
        <trans-unit id="76499db2839b046f9ef84418dd0b227738ab59b2" translate="yes" xml:space="preserve">
          <source>Transforms each element in the range &lt;code&gt;[first, last)&lt;/code&gt; with &lt;code&gt;unary_op&lt;/code&gt;, then computes an inclusive prefix sum operation using &lt;code&gt;binary_op&lt;/code&gt; over the resulting range, optionally with &lt;code&gt;init&lt;/code&gt; as the initial value, and writes the results to the range beginning at &lt;code&gt;d_first&lt;/code&gt;. &quot;inclusive&quot; means that the i-th input element is included in the i-th sum.</source>
          <target state="translated">Преобразует каждый элемент в диапазоне &lt;code&gt;[first, last)&lt;/code&gt; с помощью &lt;code&gt;unary_op&lt;/code&gt; , затем вычисляет операцию суммирования префиксного значения с использованием &lt;code&gt;binary_op&lt;/code&gt; над результирующим диапазоном, необязательно с &lt;code&gt;init&lt;/code&gt; в качестве начального значения, и записывает результаты в диапазон, начинающийся с &lt;code&gt;d_first&lt;/code&gt; . &amp;laquo;включительно&amp;raquo; означает, что i-й элемент ввода включен в i-ю сумму.</target>
        </trans-unit>
        <trans-unit id="1c65f6d1ba0f638d5024c5624db7ea27406001c1" translate="yes" xml:space="preserve">
          <source>Transforms the null-terminated byte string pointed to by &lt;code&gt;src&lt;/code&gt; into the implementation-defined form such that comparing two transformed strings with &lt;code&gt;&lt;a href=&quot;strcmp&quot;&gt;std::strcmp&lt;/a&gt;&lt;/code&gt; gives the same result as comparing the original strings with &lt;code&gt;&lt;a href=&quot;strcoll&quot;&gt;std::strcoll&lt;/a&gt;&lt;/code&gt;, in the current C locale.</source>
          <target state="translated">Преобразует байтовую строку с нулевым символом в конце, на которую указывает &lt;code&gt;src&lt;/code&gt; , в форму, определяемую реализацией, так что сравнение двух преобразованных строк с помощью &lt;code&gt;&lt;a href=&quot;strcmp&quot;&gt;std::strcmp&lt;/a&gt;&lt;/code&gt; дает тот же результат, что и сравнение исходных строк с помощью &lt;code&gt;&lt;a href=&quot;strcoll&quot;&gt;std::strcoll&lt;/a&gt;&lt;/code&gt; в текущей локали языка C.</target>
        </trans-unit>
        <trans-unit id="b23c453442ba4c19cf270e32634b19b7e31b8f29" translate="yes" xml:space="preserve">
          <source>Transforms the null-terminated wide string pointed to by &lt;code&gt;src&lt;/code&gt; into the implementation-defined form such that comparing two transformed strings with &lt;code&gt;&lt;a href=&quot;wcscmp&quot;&gt;std::wcscmp&lt;/a&gt;&lt;/code&gt; gives the same result as comparing the original strings with &lt;code&gt;&lt;a href=&quot;wcscoll&quot;&gt;std::wcscoll&lt;/a&gt;&lt;/code&gt;, in the current C locale.</source>
          <target state="translated">Преобразует широкую строку с нулевым символом в конце, на которую указывает &lt;code&gt;src&lt;/code&gt; , в форму, определяемую реализацией, так что сравнение двух преобразованных строк с помощью &lt;code&gt;&lt;a href=&quot;wcscmp&quot;&gt;std::wcscmp&lt;/a&gt;&lt;/code&gt; дает тот же результат, что и сравнение исходных строк с помощью &lt;code&gt;&lt;a href=&quot;wcscoll&quot;&gt;std::wcscoll&lt;/a&gt;&lt;/code&gt; в текущей локали языка C.</target>
        </trans-unit>
        <trans-unit id="e9473bce26df240bf7fc3c05c82131b0eac3181d" translate="yes" xml:space="preserve">
          <source>Transforms the range &lt;code&gt;[first, last)&lt;/code&gt; into the next permutation from the set of all permutations that are lexicographically ordered with respect to &lt;code&gt;operator&amp;lt;&lt;/code&gt; or &lt;code&gt;comp&lt;/code&gt;. Returns &lt;code&gt;true&lt;/code&gt; if such permutation exists, otherwise transforms the range into the first permutation (as if by &lt;code&gt;std::sort(first, last)&lt;/code&gt;) and returns &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">Преобразует диапазон &lt;code&gt;[first, last)&lt;/code&gt; в следующую перестановку из набора всех перестановок, которые лексикографически упорядочены относительно &lt;code&gt;operator&amp;lt;&lt;/code&gt; или &lt;code&gt;comp&lt;/code&gt; . Возвращает &lt;code&gt;true&lt;/code&gt; , если такая перестановка существует, в противном случае преобразует диапазон в первую перестановку (как если бы это было с помощью &lt;code&gt;std::sort(first, last)&lt;/code&gt; ) и возвращает &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fb941d77364b3c591f0e4eb102ebc186c04f6079" translate="yes" xml:space="preserve">
          <source>Transforms the range &lt;code&gt;[first, last)&lt;/code&gt; into the previous permutation from the set of all permutations that are lexicographically ordered with respect to &lt;code&gt;operator&amp;lt;&lt;/code&gt; or &lt;code&gt;comp&lt;/code&gt;. Returns &lt;code&gt;true&lt;/code&gt; if such permutation exists, otherwise transforms the range into the last permutation (as if by &lt;code&gt;std::sort(first, last); std::reverse(first, last);&lt;/code&gt;) and returns &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">Преобразует диапазон &lt;code&gt;[first, last)&lt;/code&gt; в предыдущую перестановку из набора всех перестановок, которые лексикографически упорядочены относительно &lt;code&gt;operator&amp;lt;&lt;/code&gt; или &lt;code&gt;comp&lt;/code&gt; . Возвращает &lt;code&gt;true&lt;/code&gt; , если такая перестановка существует, в противном случае преобразует диапазон в последнюю перестановку (как если бы это было с помощью &lt;code&gt;std::sort(first, last); std::reverse(first, last);&lt;/code&gt; ) и возвращает &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5c2ca105c8eba32a022ebfb50e700557700476d5" translate="yes" xml:space="preserve">
          <source>Translation units, instantiation units, and library components needed to satisfy external references are collected into a program image which contains information needed for execution in its execution environment.</source>
          <target state="translated">Модули перевода,инстанцирования и библиотечные компоненты,необходимые для удовлетворения внешних ссылок,собираются в образ программы,который содержит информацию,необходимую для выполнения в ее среде исполнения.</target>
        </trans-unit>
        <trans-unit id="7d38d008dd097b51dab00ca0d0265de5ece13e59" translate="yes" xml:space="preserve">
          <source>Transparent operator functors (&lt;code&gt;std::less&amp;lt;&amp;gt;&lt;/code&gt; et al)</source>
          <target state="translated">Прозрачные операторные функторы ( &lt;code&gt;std::less&amp;lt;&amp;gt;&lt;/code&gt; et al)</target>
        </trans-unit>
        <trans-unit id="f559c0b6272ddc2453ea357e3fd076a9c199929c" translate="yes" xml:space="preserve">
          <source>Tries to lock each of the given &lt;a href=&quot;../named_req/lockable&quot;&gt;Lockable&lt;/a&gt; objects &lt;code&gt;lock1&lt;/code&gt;, &lt;code&gt;lock2&lt;/code&gt;, &lt;code&gt;...&lt;/code&gt;, &lt;code&gt;lockn&lt;/code&gt; by calling &lt;code&gt;try_lock&lt;/code&gt; in order beginning with the first.</source>
          <target state="translated">Старается , чтобы зафиксировать каждый из данного &lt;a href=&quot;../named_req/lockable&quot;&gt;запираемый&lt;/a&gt; объектов &lt;code&gt;lock1&lt;/code&gt; , &lt;code&gt;lock2&lt;/code&gt; , &lt;code&gt;...&lt;/code&gt; , &lt;code&gt;lockn&lt;/code&gt; по телефону &lt;code&gt;try_lock&lt;/code&gt; в начале порядка с первым.</target>
        </trans-unit>
        <trans-unit id="c4193e3be0c6f62e0de2fa977aca25d7c84cd476" translate="yes" xml:space="preserve">
          <source>Tries to lock the associated mutex in shared mode without blocking. Effectively calls &lt;code&gt;mutex()-&amp;gt;try_lock_shared()&lt;/code&gt;.</source>
          <target state="translated">Пытается заблокировать связанный мьютекс в режиме совместного использования без блокировки. Эффективно вызывает &lt;code&gt;mutex()-&amp;gt;try_lock_shared()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="445a39a47a50a54d92796a9b19a41f46bc55486e" translate="yes" xml:space="preserve">
          <source>Tries to lock the associated mutex in shared mode. Blocks until specified &lt;code&gt;timeout_duration&lt;/code&gt; has elapsed or the lock is acquired, whichever comes first. On successful lock acquisition returns &lt;code&gt;true&lt;/code&gt;, otherwise returns &lt;code&gt;false&lt;/code&gt;. Effectively calls &lt;code&gt;mutex()-&amp;gt;try_lock_shared_for(timeout_duration)&lt;/code&gt;.</source>
          <target state="translated">Пытается заблокировать связанный мьютекс в режиме совместного использования. Блокируется до истечения указанного времени &lt;code&gt;timeout_duration&lt;/code&gt; или до получения блокировки, в зависимости от того, что наступит раньше. При успешном получении блокировки возвращает &lt;code&gt;true&lt;/code&gt; , в противном случае возвращает &lt;code&gt;false&lt;/code&gt; . Эффективно вызывает &lt;code&gt;mutex()-&amp;gt;try_lock_shared_for(timeout_duration)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5d62e4c34ffec7ca2a5475cc557db13010bc5bb6" translate="yes" xml:space="preserve">
          <source>Tries to lock the associated mutex in shared mode. Blocks until specified &lt;code&gt;timeout_time&lt;/code&gt; has been reached or the lock is acquired, whichever comes first. On successful lock acquisition returns &lt;code&gt;true&lt;/code&gt;, otherwise returns &lt;code&gt;false&lt;/code&gt;. May block for longer than until &lt;code&gt;timeout_time&lt;/code&gt; has been reached.</source>
          <target state="translated">Пытается заблокировать связанный мьютекс в режиме совместного использования. Блокируется до достижения указанного времени &lt;code&gt;timeout_time&lt;/code&gt; или получения блокировки, в зависимости от того, что наступит раньше. При успешном получении блокировки возвращает &lt;code&gt;true&lt;/code&gt; , в противном случае возвращает &lt;code&gt;false&lt;/code&gt; . Может блокироваться дольше, чем до &lt;code&gt;timeout_time&lt;/code&gt; времени ожидания .</target>
        </trans-unit>
        <trans-unit id="04ec6c6d28a28396ea8160dff620c7f0dfdc1cb4" translate="yes" xml:space="preserve">
          <source>Tries to lock the associated mutex without blocking. Effectively calls &lt;code&gt;mutex()-&amp;gt;try_lock()&lt;/code&gt;.</source>
          <target state="translated">Пытается заблокировать связанный мьютекс без блокировки. Эффективно вызывает &lt;code&gt;mutex()-&amp;gt;try_lock()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6391979884d59018323155d5442d884835e91f04" translate="yes" xml:space="preserve">
          <source>Tries to lock the associated mutex. Blocks until specified &lt;code&gt;timeout_duration&lt;/code&gt; has elapsed or the lock is acquired, whichever comes first. On successful lock acquisition returns &lt;code&gt;true&lt;/code&gt;, otherwise returns &lt;code&gt;false&lt;/code&gt;. Effectively calls &lt;code&gt;mutex()-&amp;gt;try_lock_for(timeout_duration)&lt;/code&gt;.</source>
          <target state="translated">Пытается заблокировать связанный мьютекс. Блокируется до истечения указанного времени &lt;code&gt;timeout_duration&lt;/code&gt; или до получения блокировки, в зависимости от того, что наступит раньше. При успешном получении блокировки возвращает &lt;code&gt;true&lt;/code&gt; , в противном случае возвращает &lt;code&gt;false&lt;/code&gt; . Эффективно вызывает &lt;code&gt;mutex()-&amp;gt;try_lock_for(timeout_duration)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9a394eb5a6a96eb4cd0cc26ea32b6b9f1cd9d182" translate="yes" xml:space="preserve">
          <source>Tries to lock the associated mutex. Blocks until specified &lt;code&gt;timeout_time&lt;/code&gt; has been reached or the lock is acquired, whichever comes first. On successful lock acquisition returns &lt;code&gt;true&lt;/code&gt;, otherwise returns &lt;code&gt;false&lt;/code&gt;. May block for longer than until &lt;code&gt;timeout_time&lt;/code&gt; has been reached.</source>
          <target state="translated">Пытается заблокировать связанный мьютекс. Блокируется до достижения указанного времени &lt;code&gt;timeout_time&lt;/code&gt; или получения блокировки, в зависимости от того, что наступит раньше. При успешном получении блокировки возвращает &lt;code&gt;true&lt;/code&gt; , в противном случае возвращает &lt;code&gt;false&lt;/code&gt; . Может блокироваться дольше, чем до &lt;code&gt;timeout_time&lt;/code&gt; времени ожидания .</target>
        </trans-unit>
        <trans-unit id="72f71ef27869580f57937ef46f54e56b64d5c90b" translate="yes" xml:space="preserve">
          <source>Tries to lock the mutex in shared mode. Blocks until specified &lt;code&gt;timeout_duration&lt;/code&gt; has elapsed or the shared lock is acquired, whichever comes first. On successful lock acquisition returns &lt;code&gt;true&lt;/code&gt;, otherwise returns &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">Пытается заблокировать мьютекс в режиме совместного использования. Блокируется до истечения указанного времени &lt;code&gt;timeout_duration&lt;/code&gt; или получения общей блокировки, в зависимости от того, что наступит раньше. При успешном получении блокировки возвращает &lt;code&gt;true&lt;/code&gt; , в противном случае возвращает &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="df7a6fe3b4499e718fdf154332580ad7e0556935" translate="yes" xml:space="preserve">
          <source>Tries to lock the mutex in shared mode. Blocks until specified &lt;code&gt;timeout_time&lt;/code&gt; has been reached or the lock is acquired, whichever comes first. On successful lock acquisition returns &lt;code&gt;true&lt;/code&gt;, otherwise returns &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">Пытается заблокировать мьютекс в режиме совместного использования. Блокируется до достижения указанного времени &lt;code&gt;timeout_time&lt;/code&gt; или получения блокировки, в зависимости от того, что наступит раньше. При успешном получении блокировки возвращает &lt;code&gt;true&lt;/code&gt; , в противном случае возвращает &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b6575b72289c55a38b072b5941884cdd93486461" translate="yes" xml:space="preserve">
          <source>Tries to lock the mutex in shared mode. Returns immediately. On successful lock acquisition returns &lt;code&gt;true&lt;/code&gt;, otherwise returns &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">Пытается заблокировать мьютекс в режиме совместного использования. Возвращается немедленно. При успешном получении блокировки возвращает &lt;code&gt;true&lt;/code&gt; , в противном случае возвращает &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="aaf4054705ad98c056fff4ec6d5fb719dbed8bab" translate="yes" xml:space="preserve">
          <source>Tries to lock the mutex. Blocks until specified &lt;code&gt;timeout_duration&lt;/code&gt; has elapsed or the lock is acquired, whichever comes first. On successful lock acquisition returns &lt;code&gt;true&lt;/code&gt;, otherwise returns &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">Пытается заблокировать мьютекс. Блокируется до истечения указанного времени &lt;code&gt;timeout_duration&lt;/code&gt; или до получения блокировки, в зависимости от того, что наступит раньше. При успешном получении блокировки возвращает &lt;code&gt;true&lt;/code&gt; , в противном случае возвращает &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2674b35e9268fb4c504fe5e2d2bb178899b976f5" translate="yes" xml:space="preserve">
          <source>Tries to lock the mutex. Blocks until specified &lt;code&gt;timeout_time&lt;/code&gt; has been reached or the lock is acquired, whichever comes first. On successful lock acquisition returns &lt;code&gt;true&lt;/code&gt;, otherwise returns &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">Пытается заблокировать мьютекс. Блокируется до достижения указанного времени &lt;code&gt;timeout_time&lt;/code&gt; или получения блокировки, в зависимости от того, что наступит раньше. При успешном получении блокировки возвращает &lt;code&gt;true&lt;/code&gt; , в противном случае возвращает &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e62eb4cb137d58a9975627d408c2d834c1eb07b2" translate="yes" xml:space="preserve">
          <source>Tries to lock the mutex. Returns immediately. On successful lock acquisition returns &lt;code&gt;true&lt;/code&gt;, otherwise returns &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">Пытается заблокировать мьютекс. Возвращается немедленно. При успешном получении блокировки возвращает &lt;code&gt;true&lt;/code&gt; , в противном случае возвращает &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b9e4c026492c440bf32166e0789393487d03b254" translate="yes" xml:space="preserve">
          <source>Trigonometric functions</source>
          <target state="translated">тригонометрические функции</target>
        </trans-unit>
        <trans-unit id="e719a16c184c9946c83f511d812044089e2e21c9" translate="yes" xml:space="preserve">
          <source>Trigraph</source>
          <target state="translated">Trigraph</target>
        </trans-unit>
        <trans-unit id="624b7d0a9acb19117360ca1ff7b46aba679ee393" translate="yes" xml:space="preserve">
          <source>Trigraphs (removed in C++17)</source>
          <target state="translated">Триграфы (удалены на C++17)</target>
        </trans-unit>
        <trans-unit id="69f8428973485177159d95cfc6a7d68111da93c3" translate="yes" xml:space="preserve">
          <source>Trivial copy assignment operator</source>
          <target state="translated">Оператор назначения тривиальной копии</target>
        </trans-unit>
        <trans-unit id="16966819b78d2f2d7ddd3b34badb4de1f0eb65b0" translate="yes" xml:space="preserve">
          <source>Trivial copy constructor</source>
          <target state="translated">тривиальный конструктор копирования</target>
        </trans-unit>
        <trans-unit id="488ca1baf6cc68b8aa948384e1e53809bfb207a8" translate="yes" xml:space="preserve">
          <source>Trivial default constructor</source>
          <target state="translated">тривиальный конструктор по умолчанию</target>
        </trans-unit>
        <trans-unit id="1418411e56b71fbadd57e0c387a8ef7df89b350e" translate="yes" xml:space="preserve">
          <source>Trivial destructor</source>
          <target state="translated">тривиальный разрушитель</target>
        </trans-unit>
        <trans-unit id="763ea1f3e981b84a927acd942aec71e9eacc4358" translate="yes" xml:space="preserve">
          <source>Trivial move assignment operator</source>
          <target state="translated">оператор распределения тривиальных перемещений</target>
        </trans-unit>
        <trans-unit id="3f57a92cdd79d69c213d32b4b4bd7fbcb0c55720" translate="yes" xml:space="preserve">
          <source>Trivial move constructor</source>
          <target state="translated">тривиальный транспортный конструктор</target>
        </trans-unit>
        <trans-unit id="80e20b4c9b75f288215983370eace6b3830f2454" translate="yes" xml:space="preserve">
          <source>TrivialClock</source>
          <target state="translated">TrivialClock</target>
        </trans-unit>
        <trans-unit id="ca5b69f8f16141b8ecbd3e5d55417b7f08e4df66" translate="yes" xml:space="preserve">
          <source>TrivialType</source>
          <target state="translated">TrivialType</target>
        </trans-unit>
        <trans-unit id="739bada034f0d62036e7eca3d1c171b7fb2990b4" translate="yes" xml:space="preserve">
          <source>TriviallyCopyable</source>
          <target state="translated">TriviallyCopyable</target>
        </trans-unit>
        <trans-unit id="2c34bab22f35dd84ab5cbfaaab89a66cdb64744f" translate="yes" xml:space="preserve">
          <source>Try blocks</source>
          <target state="translated">Испытательные блоки</target>
        </trans-unit>
        <trans-unit id="ac5f250a73945a1c4524cddeb6862a489849434a" translate="yes" xml:space="preserve">
          <source>Try blocks provide the ability to catch exceptions thrown when executing other statements.</source>
          <target state="translated">Триб блоки дают возможность перехватывать исключения,брошенные при выполнении других утверждений.</target>
        </trans-unit>
        <trans-unit id="44a77a68bb962e7ff3fb9dc11c9de3319527edbe" translate="yes" xml:space="preserve">
          <source>Tt&lt;code&gt;=&lt;/code&gt;&lt;code&gt;{} &lt;/code&gt;&lt;code&gt;;&lt;/code&gt;</source>
          <target state="translated">Tt &lt;code&gt;=&lt;/code&gt; &lt;code&gt;{} &lt;/code&gt; &lt;code&gt;;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="dc53d2c6ca548777a6fc9b944e807c006a2c9d96" translate="yes" xml:space="preserve">
          <source>Two &lt;code&gt;match_results&lt;/code&gt; are equal if the following conditions are met:</source>
          <target state="translated">Два &lt;code&gt;match_results&lt;/code&gt; равны, если выполняются следующие условия:</target>
        </trans-unit>
        <trans-unit id="d1e05e300f7cf45c9afa0f4cbce3042b969f9a51" translate="yes" xml:space="preserve">
          <source>Two &lt;code&gt;memory_resource&lt;/code&gt;s compare equal if and only if memory allocated from one &lt;code&gt;memory_resource&lt;/code&gt; can be deallocated from the other and vice versa.</source>
          <target state="translated">Два &lt;code&gt;memory_resource&lt;/code&gt; сравниваются равными, если и только если память, выделенная из одного &lt;code&gt;memory_resource&lt;/code&gt; , может быть освобождена от другого и наоборот.</target>
        </trans-unit>
        <trans-unit id="18e2cfdfc01b97bd020c553267d7b3079b8d27e3" translate="yes" xml:space="preserve">
          <source>Two accesses to the same object of type &lt;code&gt;volatile &lt;a href=&quot;sig_atomic_t&quot;&gt;std::sig_atomic_t&lt;/a&gt;&lt;/code&gt; do not result in a data race if both occur in the same thread, even if one or more occurs in a signal handler. For each signal handler invocation, evaluations performed by the thread invoking a signal handler can be divided into two groups A and B, such that no evaluations in B</source>
          <target state="translated">Два доступа к одному и тому же объекту типа &lt;code&gt;volatile &lt;a href=&quot;sig_atomic_t&quot;&gt;std::sig_atomic_t&lt;/a&gt;&lt;/code&gt; не приводят к гонке данных, если оба происходят в одном и том же потоке, даже если один или несколько происходит в обработчике сигнала. Для каждого вызова обработчика сигнала оценки, выполняемые потоком, вызывающим обработчик сигнала, могут быть разделены на две группы A и B, так что в B нет оценок.</target>
        </trans-unit>
        <trans-unit id="af211090fdec69c271770be6c158a8a93a7a9156" translate="yes" xml:space="preserve">
          <source>Two atomic constraints are considered</source>
          <target state="translated">Рассмотрены два атомных ограничения</target>
        </trans-unit>
        <trans-unit id="281cdcd9fceacdd0a42e26b288d042b3cef41c39" translate="yes" xml:space="preserve">
          <source>Two consecutive left square bracket tokens (&lt;code&gt;[[&lt;/code&gt;) may only appear when introducing an attribute-specifier or inside an attribute argument.</source>
          <target state="translated">Два последовательных маркера левой квадратной скобки ( &lt;code&gt;[[&lt;/code&gt; ) могут появляться только при представлении спецификатора атрибута или внутри аргумента атрибута.</target>
        </trans-unit>
        <trans-unit id="60290606d4c62d76f3da7e32e693534176b08979" translate="yes" xml:space="preserve">
          <source>Two convenience typedefs are provided by the standard library.</source>
          <target state="translated">Стандартная библиотека предоставляет два удобных шрифта.</target>
        </trans-unit>
        <trans-unit id="7aa31cc07dd369014ec64e33766626d690657b52" translate="yes" xml:space="preserve">
          <source>Two empty ranges are lexicographically</source>
          <target state="translated">Два пустых диапазона лексикографически</target>
        </trans-unit>
        <trans-unit id="6b78b90a2edac1ec50aec2ddead8be1711dcb40b" translate="yes" xml:space="preserve">
          <source>Two expressions involving template parameters are called</source>
          <target state="translated">Называются два выражения с параметрами шаблона</target>
        </trans-unit>
        <trans-unit id="401bc70a8b4f3d2ca441828fbf93f9236de2257b" translate="yes" xml:space="preserve">
          <source>Two function templates are considered</source>
          <target state="translated">Рассматриваются два шаблона функций</target>
        </trans-unit>
        <trans-unit id="9a61fe0c1252c74ede2b7eafa0a43c49b8412afe" translate="yes" xml:space="preserve">
          <source>Two functions with the same name and the same parameter list in the same namespace cannot have two different language linkages (note, however, that linkage of a parameter may permit such overloading, as in the case of &lt;code&gt;&lt;a href=&quot;../algorithm/qsort&quot;&gt;std::qsort&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../algorithm/bsearch&quot;&gt;std::bsearch&lt;/a&gt;&lt;/code&gt;). Likewise, two variables in the same namespace cannot have two different language linkages.</source>
          <target state="translated">Две функции с одинаковым именем и одним и тем же списком параметров в одном и том же пространстве имен не могут иметь двух разных языковых связей (однако обратите внимание, что связывание параметра может допускать такую ​​перегрузку, как в случае &lt;code&gt;&lt;a href=&quot;../algorithm/qsort&quot;&gt;std::qsort&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;../algorithm/bsearch&quot;&gt;std::bsearch&lt;/a&gt;&lt;/code&gt; ). Аналогично, две переменные в одном и том же пространстве имен не могут иметь двух разных языковых связей.</target>
        </trans-unit>
        <trans-unit id="4eb187c84dda2874b690bed58603b32136278ed1" translate="yes" xml:space="preserve">
          <source>Two global basic_istream objects are provided by the standard library.</source>
          <target state="translated">Стандартная библиотека предоставляет два глобальных объекта basic_istream.</target>
        </trans-unit>
        <trans-unit id="c90f6f3b7bfcc952e158fda77bf6551f5a0e53dd" translate="yes" xml:space="preserve">
          <source>Two instances of &lt;code&gt;std::exception_ptr&lt;/code&gt; compare equal only if they are both null or both point at the same exception object.</source>
          <target state="translated">Два экземпляра &lt;code&gt;std::exception_ptr&lt;/code&gt; сравниваются равными, только если они оба равны NULL или оба указывают на один и тот же объект исключения.</target>
        </trans-unit>
        <trans-unit id="88171adec9acfe4a9d538ee2177a7d8b88253347" translate="yes" xml:space="preserve">
          <source>Two lists of contract conditions are the same if they contain the same contract conditions in the same order. Two contract conditions are the same if they are the same kind of contract condition and have the same contract-level and the same predicate. Two predicates are the same if they would satisfy the &lt;a href=&quot;../definition#One_Definition_Rule&quot;&gt;one-definition rule&lt;/a&gt; were they to appear in function definitions, except for the renaming of function and template parameters and return value identifiers (if any).</source>
          <target state="translated">Два списка условий договора одинаковы, если они содержат одинаковые условия договора в одном и том же порядке. Два условия контракта одинаковы, если они относятся к одному и тому же виду контракта и имеют одинаковый уровень контракта и один и тот же предикат. Два предиката одинаковы, если они удовлетворяли бы &lt;a href=&quot;../definition#One_Definition_Rule&quot;&gt;правилу одного определения,&lt;/a&gt; если бы они появлялись в определениях функций, за исключением переименования параметров функции и шаблона и идентификаторов возвращаемого значения (если они есть).</target>
        </trans-unit>
        <trans-unit id="0977497139bae8229d1cacd7b1fe5a5dee1adc52" translate="yes" xml:space="preserve">
          <source>Two objects</source>
          <target state="translated">Два объекта</target>
        </trans-unit>
        <trans-unit id="86ee35dfa9a139a871795ed018153e9a56ec14e3" translate="yes" xml:space="preserve">
          <source>Two objects of this type can be dereferenced and the resulting values can be swapped using unqualified function call &lt;code&gt;swap()&lt;/code&gt; in the context where both &lt;code&gt;&lt;a href=&quot;../algorithm/swap&quot;&gt;std::swap&lt;/a&gt;&lt;/code&gt; and the user-defined &lt;code&gt;swap()&lt;/code&gt;s are visible.</source>
          <target state="translated">Два объекта этого типа могут быть разыменованы, и результирующие значения можно поменять местами, используя неквалифицированный вызов функции &lt;code&gt;swap()&lt;/code&gt; в контексте, где видны как &lt;code&gt;&lt;a href=&quot;../algorithm/swap&quot;&gt;std::swap&lt;/a&gt;&lt;/code&gt; и определяемые пользователем &lt;code&gt;swap()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e1ee0382cebdb37edb5b66d39ad57ccf190aa34e" translate="yes" xml:space="preserve">
          <source>Two paths are considered to resolve to the same file system entity if the two candidate entities the paths resolve to are located on the same device at the same location. For POSIX, this means that the &lt;code&gt;st_dev&lt;/code&gt; and &lt;code&gt;st_ino&lt;/code&gt; members of their POSIX &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/sys_stat.h.html&quot;&gt;stat structure&lt;/a&gt;, obtained as if by POSIX &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/stat.html&quot;&gt;stat&lt;/a&gt;, are equal.</source>
          <target state="translated">Считается, что два пути разрешаются к одному и тому же объекту файловой системы, если два объекта-кандидата, к которым разрешаются пути, расположены на одном и том же устройстве в одном месте. Для POSIX это означает, что члены &lt;code&gt;st_dev&lt;/code&gt; и &lt;code&gt;st_ino&lt;/code&gt; их &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/sys_stat.h.html&quot;&gt;структуры stat&lt;/a&gt; POSIX , полученные как бы &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/stat.html&quot;&gt;stat&lt;/a&gt; POSIX , равны.</target>
        </trans-unit>
        <trans-unit id="437b76b7571ce600be5aa3f3e921a20de1e39123" translate="yes" xml:space="preserve">
          <source>Two ranges are compared element by element.</source>
          <target state="translated">Два диапазона сравниваются по элементам.</target>
        </trans-unit>
        <trans-unit id="8ec06cfed5aca5636f6337ef590ec50fe665f57a" translate="yes" xml:space="preserve">
          <source>Two ranges are considered equal if they have the same number of elements and, for every iterator &lt;code&gt;i&lt;/code&gt; in the range &lt;code&gt;[first1,last1)&lt;/code&gt;, &lt;code&gt;*i&lt;/code&gt; equals &lt;code&gt;*(first2 + (i - first1))&lt;/code&gt;. The overloads (1,2,5,6) use &lt;code&gt;operator==&lt;/code&gt; to determine if two elements are equal, whereas overloads (3,4,7,8) use the given binary predicate &lt;code&gt;p&lt;/code&gt;.</source>
          <target state="translated">Два диапазона считаются равными , если они имеют одинаковое количество элементов и, для каждого итератора &lt;code&gt;i&lt;/code&gt; в диапазоне &lt;code&gt;[first1,last1)&lt;/code&gt; , &lt;code&gt;*i&lt;/code&gt; равен &lt;code&gt;*(first2 + (i - first1))&lt;/code&gt; . Перегрузки (1,2,5,6) используют &lt;code&gt;operator==&lt;/code&gt; чтобы определить, равны ли два элемента, тогда как перегрузки (3,4,7,8) используют заданный двоичный предикат &lt;code&gt;p&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1f3d6e085b1a690a184f8a241caaace1cd422427" translate="yes" xml:space="preserve">
          <source>Two specializations are provided by the standard library.</source>
          <target state="translated">Стандартная библиотека предоставляет две специализации.</target>
        </trans-unit>
        <trans-unit id="9ea29714490f77c2342f60db455484af8982a069" translate="yes" xml:space="preserve">
          <source>Two specializations for common character types are also defined:</source>
          <target state="translated">Также определены две специализации для общих типов символов:</target>
        </trans-unit>
        <trans-unit id="395a556fd3ef9112d9577c9ebc5df6fd4309e718" translate="yes" xml:space="preserve">
          <source>Two specializations for common character types are also provided:</source>
          <target state="translated">Также предусмотрены две специализации для общих типов символов:</target>
        </trans-unit>
        <trans-unit id="abc68b66bf994ad49ab50a82c81510a0ae793170" translate="yes" xml:space="preserve">
          <source>Two specializations for common character types are defined:</source>
          <target state="translated">Определены две специализации для общих типов символов:</target>
        </trans-unit>
        <trans-unit id="644226c6c6857e7526a3f749326009205374c9cd" translate="yes" xml:space="preserve">
          <source>Two specializations of &lt;code&gt;&lt;a href=&quot;types/integral_constant&quot;&gt;std::integral_constant&lt;/a&gt;&lt;/code&gt; for the type &lt;code&gt;bool&lt;/code&gt; are provided:</source>
          <target state="translated">Предусмотрены две специализации &lt;code&gt;&lt;a href=&quot;types/integral_constant&quot;&gt;std::integral_constant&lt;/a&gt;&lt;/code&gt; для типа &lt;code&gt;bool&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="38cc0b6c98f9bf0b6f230727bb0b37ccdc3ce423" translate="yes" xml:space="preserve">
          <source>Two specializations of &lt;code&gt;std::regex_traits&lt;/code&gt; are defined by the standard library:</source>
          <target state="translated">Две специализации &lt;code&gt;std::regex_traits&lt;/code&gt; определяются стандартной библиотекой:</target>
        </trans-unit>
        <trans-unit id="1c45317442511240ca7c73c4b544304cf52c5c50" translate="yes" xml:space="preserve">
          <source>Two standalone (locale-independent) full specializations and two partial specializations are provided by the standard library:</source>
          <target state="translated">Две автономные (локально независимые)полные специализации и две частичные специализации предоставляются стандартной библиотекой:</target>
        </trans-unit>
        <trans-unit id="f02ffd61fc180d1f64496b8d587f3d5cce7df2b7" translate="yes" xml:space="preserve">
          <source>Two standalone (locale-independent) specializations are provided by the standard library:</source>
          <target state="translated">Стандартная библиотека предоставляет две самостоятельные (локально-независимые)специализации:</target>
        </trans-unit>
        <trans-unit id="2cf5b83a88ef7188b905ff555b89323fdaa04f77" translate="yes" xml:space="preserve">
          <source>Two standard-layout non-union class types are called</source>
          <target state="translated">Называются два типа несоюзных классов в стандартной компоновке.</target>
        </trans-unit>
        <trans-unit id="1b0ea8abccf06468ba7e2e711860c3d383b65c96" translate="yes" xml:space="preserve">
          <source>Two standard-layout non-union class types may have a</source>
          <target state="translated">Два стандартных типа несоюзного класса могут иметь</target>
        </trans-unit>
        <trans-unit id="2034537c92fce35c44c1810a5621d0a63f6246c5" translate="yes" xml:space="preserve">
          <source>Two standard-layout unions are called</source>
          <target state="translated">Два стандартных союза называются</target>
        </trans-unit>
        <trans-unit id="cb0d34718d67d002a55c599c7fb017311e7a205d" translate="yes" xml:space="preserve">
          <source>Two strings are equal if both the size of &lt;code&gt;lhs&lt;/code&gt; and &lt;code&gt;rhs&lt;/code&gt; are equal and each character in &lt;code&gt;lhs&lt;/code&gt; has equivalent character in &lt;code&gt;rhs&lt;/code&gt; at the same position.</source>
          <target state="translated">Две строки равны, если оба размера &lt;code&gt;lhs&lt;/code&gt; и &lt;code&gt;rhs&lt;/code&gt; равны и каждый символ в &lt;code&gt;lhs&lt;/code&gt; имеет эквивалентный символ в &lt;code&gt;rhs&lt;/code&gt; в одной и той же позиции.</target>
        </trans-unit>
        <trans-unit id="d818143c3e7668e852c1ed4b1bfcf0387a3c91b0" translate="yes" xml:space="preserve">
          <source>Two typedefs for the common case where &lt;code&gt;T&lt;/code&gt; is &lt;code&gt;bool&lt;/code&gt; are provided:</source>
          <target state="translated">Предусмотрено два определения типа для общего случая, когда &lt;code&gt;T&lt;/code&gt; - &lt;code&gt;bool&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="ab704f0a65282b62f2101424e6b2f0abfc336948" translate="yes" xml:space="preserve">
          <source>Two views are equal if both the size of &lt;code&gt;lhs&lt;/code&gt; and &lt;code&gt;rhs&lt;/code&gt; are equal and each character in &lt;code&gt;lhs&lt;/code&gt; has an equivalent character in &lt;code&gt;rhs&lt;/code&gt; at the same position.</source>
          <target state="translated">Два представления равны, если оба размера &lt;code&gt;lhs&lt;/code&gt; и &lt;code&gt;rhs&lt;/code&gt; равны и каждый символ в &lt;code&gt;lhs&lt;/code&gt; имеет эквивалентный символ в &lt;code&gt;rhs&lt;/code&gt; в одной и той же позиции.</target>
        </trans-unit>
        <trans-unit id="e4adb4f5d7d971d5f33d8bf32d6573b59f4c2c1c" translate="yes" xml:space="preserve">
          <source>Two-way comparison</source>
          <target state="translated">двустороннее сравнение</target>
        </trans-unit>
        <trans-unit id="3deb7456519697ecf4eefc455516c969a3681bae" translate="yes" xml:space="preserve">
          <source>Type</source>
          <target state="translated">Type</target>
        </trans-unit>
        <trans-unit id="7d5b0442ddd6e6a3b47c1fb7cfdb53626e952034" translate="yes" xml:space="preserve">
          <source>Type SFINAE</source>
          <target state="translated">Тип СФИНА</target>
        </trans-unit>
        <trans-unit id="c78ea93e5901f3567162bc1f5cabf9c0cb321ce8" translate="yes" xml:space="preserve">
          <source>Type U is swappable with type T if, for any object u of type U and any object t of type T,</source>
          <target state="translated">Тип U может быть заменен типом T,если для любого объекта u типа U и любого объекта t типа T,</target>
        </trans-unit>
        <trans-unit id="ba8b607d229159b7de176502ebe44f1a8317de01" translate="yes" xml:space="preserve">
          <source>Type alias</source>
          <target state="translated">Псевдоним типа</target>
        </trans-unit>
        <trans-unit id="5e72885576f31f0e1d9c64866f5a1621945f1d64" translate="yes" xml:space="preserve">
          <source>Type alias is a name that refers to a previously defined type (similar to &lt;a href=&quot;typedef&quot;&gt;typedef&lt;/a&gt;).</source>
          <target state="translated">Псевдоним типа - это имя, которое ссылается на ранее определенный тип (аналогично &lt;a href=&quot;typedef&quot;&gt;typedef&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="1722c89a494d0f4cd3e0c044b1bcfcd056571bad" translate="yes" xml:space="preserve">
          <source>Type alias, alias template (since C++11)</source>
          <target state="translated">Введите псевдоним,шаблон псевдонима (начиная с C++11).</target>
        </trans-unit>
        <trans-unit id="58cf557846d7f65d34e8a92739eef2665164fad4" translate="yes" xml:space="preserve">
          <source>Type aliases</source>
          <target state="translated">Псевдонимы типа</target>
        </trans-unit>
        <trans-unit id="cd126df756f5f399b0ed73a4824b22f02643ea98" translate="yes" xml:space="preserve">
          <source>Type aliases are provided for &lt;code&gt;bool&lt;/code&gt; and all integral types listed above, as follows:</source>
          <target state="translated">Псевдонимы типов предоставляются для &lt;code&gt;bool&lt;/code&gt; и всех перечисленных выше целых типов следующим образом:</target>
        </trans-unit>
        <trans-unit id="0621d5c6fbe8bcf7d94a8aeaee4b8e9171cf0f16" translate="yes" xml:space="preserve">
          <source>Type aliasing</source>
          <target state="translated">Наложение спектров</target>
        </trans-unit>
        <trans-unit id="6c1aa9cebe6e183271d6415c7410657e8ccc6473" translate="yes" xml:space="preserve">
          <source>Type classification</source>
          <target state="translated">Классификация типов</target>
        </trans-unit>
        <trans-unit id="faebe1b53837fa610eefb9f421b0013abc2c2ee3" translate="yes" xml:space="preserve">
          <source>Type deduction does not consider implicit conversions (other than type adjustments listed above): that's the job for &lt;a href=&quot;overload_resolution&quot;&gt;overload resolution&lt;/a&gt;, which happens later.</source>
          <target state="translated">Вывод типа не учитывает неявные преобразования (кроме корректировок типа, перечисленных выше): это работа по &lt;a href=&quot;overload_resolution&quot;&gt;разрешению перегрузки&lt;/a&gt; , которая происходит позже.</target>
        </trans-unit>
        <trans-unit id="6b6c1979aa63474d39a31dd947373aa3f5876803" translate="yes" xml:space="preserve">
          <source>Type identification</source>
          <target state="translated">Идентификация типа</target>
        </trans-unit>
        <trans-unit id="8e2511e093ef713b765be9963ac67a42b99f36a7" translate="yes" xml:space="preserve">
          <source>Type modification templates create new type definitions by applying modifications on a template parameter. The resulting type can then be accessed through &lt;code&gt;type&lt;/code&gt; member typedef.</source>
          <target state="translated">Шаблоны модификации типов создают новые определения типов, применяя изменения к параметру шаблона. Затем к результирующему типу можно получить доступ через член &lt;code&gt;type&lt;/code&gt; typedef.</target>
        </trans-unit>
        <trans-unit id="077701eb2407963fce08e9b207dd8581a8385722" translate="yes" xml:space="preserve">
          <source>Type modifications</source>
          <target state="translated">Изменения типа</target>
        </trans-unit>
        <trans-unit id="476a2ca549c0288e513cdd3a95b50bf4cb76b469" translate="yes" xml:space="preserve">
          <source>Type naming</source>
          <target state="translated">Наименование типа</target>
        </trans-unit>
        <trans-unit id="2885fa4c886876dbf27aa8c6e61e019d3364b3e1" translate="yes" xml:space="preserve">
          <source>Type operations</source>
          <target state="translated">Типовые операции</target>
        </trans-unit>
        <trans-unit id="d05a5058829543344892b6ea903ebf7acc0cbacb" translate="yes" xml:space="preserve">
          <source>Type properties</source>
          <target state="translated">Типовые свойства</target>
        </trans-unit>
        <trans-unit id="712780a85df08fbd996eeeec1c3d3e6e3b629d3c" translate="yes" xml:space="preserve">
          <source>Type relationships</source>
          <target state="translated">Типовые отношения</target>
        </trans-unit>
        <trans-unit id="c4153f3895b73933a5c58c3f766c82d580c4d612" translate="yes" xml:space="preserve">
          <source>Type requirements</source>
          <target state="translated">Типовые требования</target>
        </trans-unit>
        <trans-unit id="5c3dec20e8df5a43918b8faf39633e46723561db" translate="yes" xml:space="preserve">
          <source>Type specifier</source>
          <target state="translated">Спецификатор типа</target>
        </trans-unit>
        <trans-unit id="ebdbe0be2297808a43109ed1cd29e12d3786ec7d" translate="yes" xml:space="preserve">
          <source>Type support</source>
          <target state="translated">Типовая поддержка</target>
        </trans-unit>
        <trans-unit id="d99c924b5e5c496d209cd1138d79fd4d82ae89bd" translate="yes" xml:space="preserve">
          <source>Type support (basic types, RTTI, type traits)</source>
          <target state="translated">Поддержка типов (основные типы,RTTI,трейты типа)</target>
        </trans-unit>
        <trans-unit id="86913cb67681548c98606e442d98428c1ae65742" translate="yes" xml:space="preserve">
          <source>Type template parameter</source>
          <target state="translated">Тип шаблона параметр</target>
        </trans-unit>
        <trans-unit id="4a285087e3a01a1f61420542eebe3d7ad0cbe7d5" translate="yes" xml:space="preserve">
          <source>Type template parameter cannot be deduced from the type of a function default argument:</source>
          <target state="translated">Параметр Type template не может быть выведен из типа аргумента функции по умолчанию:</target>
        </trans-unit>
        <trans-unit id="b3802db54ebe40c4f9d8e147e5ec66e48e2b252c" translate="yes" xml:space="preserve">
          <source>Type traits</source>
          <target state="translated">Типовые черты</target>
        </trans-unit>
        <trans-unit id="2824df384c0d515b0957ced6c76365b01bfeb9fa" translate="yes" xml:space="preserve">
          <source>Type traits (since C++11)</source>
          <target state="translated">Черты типа (начиная с C++11)</target>
        </trans-unit>
        <trans-unit id="fb365f218572167960956b20fa3e4a8fab51cd73" translate="yes" xml:space="preserve">
          <source>Type traits defines a compile-time template-based interface to query or modify the properties of types.</source>
          <target state="translated">Трейты типов определяют шаблонный интерфейс компиляции для запроса или изменения свойств типов.</target>
        </trans-unit>
        <trans-unit id="d26fb74bad254a05310c922f3a48638fd66d9e0c" translate="yes" xml:space="preserve">
          <source>Type traits variable templates (&lt;code&gt;&lt;a href=&quot;types/is_void&quot;&gt;std::is_void_v&lt;/a&gt;&lt;/code&gt;, etc)</source>
          <target state="translated">Шаблоны переменных типа traits ( &lt;code&gt;&lt;a href=&quot;types/is_void&quot;&gt;std::is_void_v&lt;/a&gt;&lt;/code&gt; и т. Д.)</target>
        </trans-unit>
        <trans-unit id="1ce3ad96399788f64f133fb490b5f7a722f3d935" translate="yes" xml:space="preserve">
          <source>Type-dependent expressions</source>
          <target state="translated">Типовые зависимости выражений</target>
        </trans-unit>
        <trans-unit id="9923b968817bae672aedebaea069d1e0f05c3d5f" translate="yes" xml:space="preserve">
          <source>Type-id</source>
          <target state="translated">Type-id</target>
        </trans-unit>
        <trans-unit id="ca804ab74bf9fa2667ceb8c95926b696eb69be50" translate="yes" xml:space="preserve">
          <source>Typedefs</source>
          <target state="translated">Typedefs</target>
        </trans-unit>
        <trans-unit id="6b028941a936328652669d0fdcfadace96df8cb3" translate="yes" xml:space="preserve">
          <source>Typedefs and specializations</source>
          <target state="translated">Типедефы и специализации</target>
        </trans-unit>
        <trans-unit id="93b9e289e2842469d001eccf7ad5d79f3c302dc9" translate="yes" xml:space="preserve">
          <source>Types</source>
          <target state="translated">Types</target>
        </trans-unit>
        <trans-unit id="14a6b912930173876d4ddc87ab0ee1e78929d71f" translate="yes" xml:space="preserve">
          <source>Types allowed for integer literals</source>
          <target state="translated">Типы,допустимые для целочисленных букв</target>
        </trans-unit>
        <trans-unit id="0aebd15ac247c772915a487e8beaa6ae702bbaf4" translate="yes" xml:space="preserve">
          <source>Types are grouped in various categories based on their properties:</source>
          <target state="translated">Типы сгруппированы в различные категории в зависимости от их свойств:</target>
        </trans-unit>
        <trans-unit id="432f7a9995f3c47c26ea06ac5e31bfbd1ce7f343" translate="yes" xml:space="preserve">
          <source>Types defined in all function definitions are also the same in all translation units.</source>
          <target state="translated">Типы,определенные во всех определениях функций,также одинаковы во всех единицах перевода.</target>
        </trans-unit>
        <trans-unit id="f4721af617a03c18f8008b522a45437293348f79" translate="yes" xml:space="preserve">
          <source>Types of lookup</source>
          <target state="translated">Виды поиска</target>
        </trans-unit>
        <trans-unit id="7b0613fc7fabdfb018b52d357936b837a2cab911" translate="yes" xml:space="preserve">
          <source>Types that do not have names often need to be referred to in C++ programs; the syntax for that is known as</source>
          <target state="translated">Типы,которые не имеют названий,часто нуждаются в упоминании в программах на Си++;синтаксис для этого известен как</target>
        </trans-unit>
        <trans-unit id="b2566175d7363d465c10ed984db01277b4e1b9cf" translate="yes" xml:space="preserve">
          <source>Types without a move constructor, but with a copy constructor that accepts &lt;code&gt;const T&amp;amp;&lt;/code&gt; arguments, satisfy &lt;code&gt;std::is_move_constructible&lt;/code&gt;.</source>
          <target state="translated">Типы без конструктора перемещения, но с конструктором копирования, который принимает аргументы &lt;code&gt;const T&amp;amp;&lt;/code&gt; , удовлетворяют &lt;code&gt;std::is_move_constructible&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="70739c5bd846379403ad7504d3db0427e14c707a" translate="yes" xml:space="preserve">
          <source>Types...</source>
          <target state="translated">Types...</target>
        </trans-unit>
        <trans-unit id="fbbef98f2687c637a775659b0dc25c3eaf7a67c3" translate="yes" xml:space="preserve">
          <source>Typical declaration of a copy assignment operator when &lt;a href=&quot;operators#Assignment_operator&quot;&gt;copy-and-swap idiom&lt;/a&gt; can be used.</source>
          <target state="translated">Типичное объявление оператора присваивания копии, когда можно использовать &lt;a href=&quot;operators#Assignment_operator&quot;&gt;идиому копирования и замены&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="918b3549bbd396e01bbb7e6f14e565a830f15731" translate="yes" xml:space="preserve">
          <source>Typical declaration of a copy assignment operator when copy-and-swap idiom cannot be used (non-swappable type or degraded performance).</source>
          <target state="translated">Типичное объявление оператора присваивания копии,когда идиома копирования и замены не может быть использована (тип не подлежащий замене или ухудшенная производительность).</target>
        </trans-unit>
        <trans-unit id="f8ce748f05c8c5befc02b9aebb0d8d634d05750d" translate="yes" xml:space="preserve">
          <source>Typical declaration of a copy constructor.</source>
          <target state="translated">Типичное объявление копировального конструктора.</target>
        </trans-unit>
        <trans-unit id="73cd36e771bfce67068d8e880baa5998fadf8c14" translate="yes" xml:space="preserve">
          <source>Typical declaration of a move assignment operator.</source>
          <target state="translated">Типичное объявление оператора задания перемещения.</target>
        </trans-unit>
        <trans-unit id="21fff4e24aeaedc99f5d443b9c3e1bb3e8fe60f0" translate="yes" xml:space="preserve">
          <source>Typical declaration of a move constructor.</source>
          <target state="translated">Типичная декларация конструктора движения.</target>
        </trans-unit>
        <trans-unit id="d37091da1e22a1f61c981f61d556e4bc6ba5eecd" translate="yes" xml:space="preserve">
          <source>Typical implementation holds an instance of a &lt;code&gt;std::scoped_allocator_adaptor&amp;lt;InnerAllocs...&amp;gt;&lt;/code&gt; as a member object.</source>
          <target state="translated">Типичная реализация содержит экземпляр &lt;code&gt;std::scoped_allocator_adaptor&amp;lt;InnerAllocs...&amp;gt;&lt;/code&gt; в качестве объекта-члена.</target>
        </trans-unit>
        <trans-unit id="06d4cc727848bd1fdf903e8119b98940ee7e586c" translate="yes" xml:space="preserve">
          <source>Typical implementation holds member constants corresponding to all values of fmtflags, iostate, openmode, and seekdir shown below, member variables to maintain current precision, width, and formatting flags, the exception mask, the buffer error state, a resizeable container holding the callbacks, the currently imbued locale, the private storage, and a static integer variable for xalloc().</source>
          <target state="translated">Типичная реализация содержит константы-члены,соответствующие всем значениям fmtflags,iostate,openmode и seekdir,показанным ниже,переменные-члены для поддержания текущей точности,ширины и флагов форматирования,маску исключения,состояние ошибки буфера,изменяемый размер контейнера,содержащего обратные вызовы,текущую встроенную локаль,приватное хранилище и статическую целочисленную переменную для xalloc().</target>
        </trans-unit>
        <trans-unit id="588a768f54b40d99ef1543297e7072645cb90743" translate="yes" xml:space="preserve">
          <source>Typical implementation of &lt;code&gt;std::basic_osyncstream&lt;/code&gt; holds only one member: the wrapped &lt;code&gt;std::basic_syncbuf&lt;/code&gt;.</source>
          <target state="translated">Типичная реализация &lt;code&gt;std::basic_osyncstream&lt;/code&gt; содержит только один член: обернутый &lt;code&gt;std::basic_syncbuf&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a9aa2b00209f5ddcdf5c18ed5a9a504d20d2daca" translate="yes" xml:space="preserve">
          <source>Typical implementation of &lt;code&gt;std::basic_syncbuf&lt;/code&gt; holds a pointer to the wrapped &lt;code&gt;&lt;a href=&quot;basic_streambuf&quot;&gt;std::basic_streambuf&lt;/a&gt;&lt;/code&gt;, a boolean flag indicating whether the buffer will transmit its contents to the wrapped buffer on sync (flush), a boolean flag indicating a pending flush when the policy is to not emit on sync, an internal buffer that uses &lt;code&gt;Allocator&lt;/code&gt; (such as std::string), and a pointer to a mutex used to synchronize emit between multiple threads accessing the same wrapped stream buffer (these mutexes may be in a hash map with pointers to basic_streambuf objects used as keys).</source>
          <target state="translated">Типичная реализация &lt;code&gt;std::basic_syncbuf&lt;/code&gt; содержит указатель на обернутый &lt;code&gt;&lt;a href=&quot;basic_streambuf&quot;&gt;std::basic_streambuf&lt;/a&gt;&lt;/code&gt; , логический флаг, указывающий, будет ли буфер передавать свое содержимое в обернутый буфер при синхронизации (сброс), логический флаг, указывающий на ожидающий сброс, когда политика чтобы не излучать при синхронизации, внутренний буфер, который использует &lt;code&gt;Allocator&lt;/code&gt; (например, std :: string), и указатель на мьютекс, используемый для синхронизации излучения между несколькими потоками, обращающимися к одному и тому же буферу потоковых оболочек (эти мьютексы могут находиться в хэш-карте с указатели на объекты basic_streambuf, используемые в качестве ключей).</target>
        </trans-unit>
        <trans-unit id="7250127c92df894b58e56d580f5f517195bd7d5f" translate="yes" xml:space="preserve">
          <source>Typical implementation of a &lt;code&gt;std::strstreambuf&lt;/code&gt; holds four private data members:</source>
          <target state="translated">Типичная реализация &lt;code&gt;std::strstreambuf&lt;/code&gt; содержит четыре частных члена данных:</target>
        </trans-unit>
        <trans-unit id="ef6d40404da26e1e6eadc90e2e0a92c1349c9710" translate="yes" xml:space="preserve">
          <source>Typical implementation of the &lt;code&gt;std::basic_streambuf&lt;/code&gt; base class holds only the six &lt;code&gt;CharT*&lt;/code&gt; pointers and a copy of &lt;code&gt;&lt;a href=&quot;../locale/locale&quot;&gt;std::locale&lt;/a&gt;&lt;/code&gt; as data members. In addition, implementations may keep cached copies of locale facets, which are invalidated whenever &lt;code&gt;imbue()&lt;/code&gt; is called. The concrete buffers such as &lt;code&gt;&lt;a href=&quot;basic_filebuf&quot;&gt;std::basic_filebuf&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;basic_stringbuf&quot;&gt;std::basic_stringbuf&lt;/a&gt;&lt;/code&gt; are derived from &lt;code&gt;std::basic_streambuf&lt;/code&gt;.</source>
          <target state="translated">Типичная реализация базового класса &lt;code&gt;std::basic_streambuf&lt;/code&gt; содержит только шесть указателей &lt;code&gt;CharT*&lt;/code&gt; и копию &lt;code&gt;&lt;a href=&quot;../locale/locale&quot;&gt;std::locale&lt;/a&gt;&lt;/code&gt; качестве членов данных. Кроме того, реализации могут хранить кэшированные копии фасетов локали, которые становятся недействительными при каждом вызове &lt;code&gt;imbue()&lt;/code&gt; . Конкретные буферы, такие как &lt;code&gt;&lt;a href=&quot;basic_filebuf&quot;&gt;std::basic_filebuf&lt;/a&gt;&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;basic_stringbuf&quot;&gt;std::basic_stringbuf&lt;/a&gt;&lt;/code&gt; являются производными от &lt;code&gt;std::basic_streambuf&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7cd7cae1a881bd65509f3fc54f4e619c9e90350a" translate="yes" xml:space="preserve">
          <source>Typical implementations either.</source>
          <target state="translated">Типичные реализации тоже.</target>
        </trans-unit>
        <trans-unit id="9e133aef83ccff0d4f3491a9890dd2084b61042d" translate="yes" xml:space="preserve">
          <source>Typical implementations of &lt;code&gt;std::basic_stringbuf&lt;/code&gt; hold an object of type &lt;code&gt;&lt;a href=&quot;../string/basic_string&quot;&gt;std::basic_string&lt;/a&gt;&lt;/code&gt; or equivalent resizeable sequence container directly as a data member and use it as both the controlled character sequence (the array where the six pointers of &lt;code&gt;&lt;a href=&quot;basic_streambuf&quot;&gt;std::basic_streambuf&lt;/a&gt;&lt;/code&gt; are pointing to) and as the associated character sequence (the source of characters for all input operations and the target for the output).</source>
          <target state="translated">Типичные реализации &lt;code&gt;std::basic_stringbuf&lt;/code&gt; содержат объект типа &lt;code&gt;&lt;a href=&quot;../string/basic_string&quot;&gt;std::basic_string&lt;/a&gt;&lt;/code&gt; или эквивалентный контейнер последовательности с изменяемым размером непосредственно в качестве члена данных и используют его как управляемую последовательность символов (массив, на &lt;code&gt;&lt;a href=&quot;basic_streambuf&quot;&gt;std::basic_streambuf&lt;/a&gt;&lt;/code&gt; указывают шесть указателей std :: basic_streambuf ) ) и как связанная последовательность символов (источник символов для всех операций ввода и цель для вывода).</target>
        </trans-unit>
        <trans-unit id="68f2d8f77480725b5e25bbfbe1250bd18f26ff6c" translate="yes" xml:space="preserve">
          <source>Typical implementations use hardware transactional memory where supported and to the limits that it is available (e.g. until the changeset is saturated) and fall back to software transactional memory, usually implemented with optimistic concurrency: if another transaction updated some of the variables used by a transaction, it is silently retried. For that reason, retriable transactions (&quot;atomic blocks&quot;) can only call transaction-safe functions.</source>
          <target state="translated">Типичные реализации используют аппаратную транзакционную память там,где она поддерживается,и до тех пределов,пока она доступна (например,до тех пор,пока changeset не будет насыщен),и возвращаются в программную транзакционную память,обычно реализованную с оптимистическим параллелизмом:если другая транзакция обновила некоторые из переменных,используемых транзакцией,то она беззвучно перепроверяется.По этой причине возвращаемые транзакции (&quot;атомные блоки&quot;)могут вызывать только функции,обеспечивающие безопасность транзакций.</target>
        </trans-unit>
        <trans-unit id="1b555741394ae9339e15f18c3b6d7121a3052b4c" translate="yes" xml:space="preserve">
          <source>Typical use cases for this ordering involve read access to rarely written concurrent data structures (routing tables, configuration, security policies, firewall rules, etc) and publisher-subscriber situations with pointer-mediated publication, that is, when the producer publishes a pointer through which the consumer can access information: there is no need to make everything else the producer wrote to memory visible to the consumer (which may be an expensive operation on weakly-ordered architectures). An example of such scenario is &lt;a href=&quot;https://en.wikipedia.org/wiki/Read-copy-update&quot;&gt;rcu_dereference&lt;/a&gt;.</source>
          <target state="translated">Типичные случаи использования этого порядка включают доступ на чтение к редко записанным параллельным структурам данных (таблицы маршрутизации, конфигурации, политики безопасности, правила брандмауэра и т. Д.) И ситуации подписчик-издатель с публикацией, опосредованной указателем, то есть когда производитель публикует указатель через который потребитель может получить доступ к информации: нет необходимости делать все остальное, что производитель записывал в память, видимым для потребителя (что может быть дорогой операцией на слабо упорядоченных архитектурах). Примером такого сценария является &lt;a href=&quot;https://en.wikipedia.org/wiki/Read-copy-update&quot;&gt;rcu_dereference&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="dcc9e60517620bd3f403ef0a6408dee8d18e7887" translate="yes" xml:space="preserve">
          <source>Typical use for relaxed memory ordering is incrementing counters, such as the reference counters of &lt;code&gt;&lt;a href=&quot;../memory/shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&lt;/code&gt;, since this only requires atomicity, but not ordering or synchronization (note that decrementing the shared_ptr counters requires acquire-release synchronization with the destructor).</source>
          <target state="translated">Типичное использование для упорядоченного упорядочения памяти - это увеличивающиеся счетчики, такие как счетчики ссылок &lt;code&gt;&lt;a href=&quot;../memory/shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&lt;/code&gt; , поскольку для этого требуется только атомарность, но не упорядочение или синхронизация (обратите внимание, что уменьшение счетчиков shared_ptr требует синхронизации получения-освобождения с деструктором).</target>
        </trans-unit>
        <trans-unit id="d1c41b285173ad8718230a87a1a5d2d17b3b7903" translate="yes" xml:space="preserve">
          <source>Typical use of iword storage is to pass information (e.g. custom formatting flags) from user-defined I/O manipulators to user-defined &lt;code&gt;operator&amp;lt;&amp;lt;&lt;/code&gt; and &lt;code&gt;operator&amp;gt;&amp;gt;&lt;/code&gt; or to user-defined formatting facets imbued into standard streams.</source>
          <target state="translated">Типичное использование хранилища iword - это передача информации (например, пользовательских флагов форматирования) из пользовательских манипуляторов ввода / вывода в пользовательский &lt;code&gt;operator&amp;lt;&amp;lt;&lt;/code&gt; и &lt;code&gt;operator&amp;gt;&amp;gt;&lt;/code&gt; или в пользовательские аспекты форматирования, внедренные в стандартные потоки.</target>
        </trans-unit>
        <trans-unit id="a0c7297f2b0ebce4780a49bd855246e6cc47d6d3" translate="yes" xml:space="preserve">
          <source>Typical uses of &lt;code&gt;std::launder&lt;/code&gt; include:</source>
          <target state="translated">Типичные области применения &lt;code&gt;std::launder&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="f88c003eb42b9ea1375635c3ec171fc7d9d436f1" translate="yes" xml:space="preserve">
          <source>Typically called by the appropriate constructors of &lt;code&gt;std::basic_osyncstream&lt;/code&gt;.</source>
          <target state="translated">Обычно &lt;code&gt;std::basic_osyncstream&lt;/code&gt; соответствующими конструкторами std :: basic_osyncstream .</target>
        </trans-unit>
        <trans-unit id="b96ee3f3e487127e3b6fea8c21cfa2b830940d4d" translate="yes" xml:space="preserve">
          <source>Typically called by the constructor of &lt;code&gt;&lt;a href=&quot;../basic_fstream&quot;&gt;std::basic_fstream&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Обычно &lt;code&gt;&lt;a href=&quot;../basic_fstream&quot;&gt;std::basic_fstream&lt;/a&gt;&lt;/code&gt; конструктором std :: basic_fstream .</target>
        </trans-unit>
        <trans-unit id="47bd33f18f5f8634e7375df48b7f7fb6bccdec60" translate="yes" xml:space="preserve">
          <source>Typically called by the constructor of &lt;code&gt;&lt;a href=&quot;../basic_stringstream&quot;&gt;std::basic_stringstream&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Обычно &lt;code&gt;&lt;a href=&quot;../basic_stringstream&quot;&gt;std::basic_stringstream&lt;/a&gt;&lt;/code&gt; конструктором std :: basic_stringstream .</target>
        </trans-unit>
        <trans-unit id="3d635d5eec3d8618476f770fe4d864ab867b778b" translate="yes" xml:space="preserve">
          <source>Typically called by the destructor of &lt;code&gt;&lt;a href=&quot;../basic_fstream&quot;&gt;std::basic_fstream&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Обычно &lt;code&gt;&lt;a href=&quot;../basic_fstream&quot;&gt;std::basic_fstream&lt;/a&gt;&lt;/code&gt; деструктором std :: basic_fstream .</target>
        </trans-unit>
        <trans-unit id="f750e5d2112c892940c039aca52de35a7711eef8" translate="yes" xml:space="preserve">
          <source>Typically, once &lt;code&gt;operator&amp;lt;&lt;/code&gt; is provided, the other relational operators are implemented in terms of &lt;code&gt;operator&amp;lt;&lt;/code&gt;.</source>
          <target state="translated">Как правило, после предоставления &lt;code&gt;operator&amp;lt;&lt;/code&gt; другие реляционные операторы реализуются в терминах &lt;code&gt;operator&amp;lt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="41f3db6f3ed64eb215d6838b5f2754196444b79e" translate="yes" xml:space="preserve">
          <source>U+00A8</source>
          <target state="translated">U+00A8</target>
        </trans-unit>
        <trans-unit id="853cbdaa93204f86fe9e28c7fa4f0cdff4d3b9bc" translate="yes" xml:space="preserve">
          <source>U+00AA</source>
          <target state="translated">U+00AA</target>
        </trans-unit>
        <trans-unit id="dd5c9cc4b863c82bc928546a1f85d66803a8211b" translate="yes" xml:space="preserve">
          <source>U+00AD</source>
          <target state="translated">U+00AD</target>
        </trans-unit>
        <trans-unit id="5b12a6b1423f6d50cbadc422ccde7e82e285061a" translate="yes" xml:space="preserve">
          <source>U+00AF</source>
          <target state="translated">U+00AF</target>
        </trans-unit>
        <trans-unit id="7b152417fcfe4c5eb703ff0a0c4980c4a5bdcc7f" translate="yes" xml:space="preserve">
          <source>U+00B2 - U+00B5</source>
          <target state="translated">U+00B2-U+00B5</target>
        </trans-unit>
        <trans-unit id="a000abf8eda220f3b5a2485e895780d87238cc05" translate="yes" xml:space="preserve">
          <source>U+00B7 - U+00BA</source>
          <target state="translated">U+00B7-U+00BA</target>
        </trans-unit>
        <trans-unit id="3e0f991583121de4997412ddc791f2cce64673ed" translate="yes" xml:space="preserve">
          <source>U+00BC - U+00BE</source>
          <target state="translated">U+00BC-U+00BE</target>
        </trans-unit>
        <trans-unit id="8da270e5988e53f6a16cfbbffdc343231a853e7f" translate="yes" xml:space="preserve">
          <source>U+00C0 - U+00D6</source>
          <target state="translated">U+00C0-U+00D6</target>
        </trans-unit>
        <trans-unit id="21a7086c2d62117c31f8128dd2f55f8f6e915e24" translate="yes" xml:space="preserve">
          <source>U+00D8 - U+00F6</source>
          <target state="translated">U+00D8-U+00F6</target>
        </trans-unit>
        <trans-unit id="bf28cde9daefd91ebc927ccb81f1551b46c4d078" translate="yes" xml:space="preserve">
          <source>U+00F8 - U+167F</source>
          <target state="translated">U+00F8-U+167F</target>
        </trans-unit>
        <trans-unit id="a317fb85190fd3c7b724d3aedb81fe25713813f0" translate="yes" xml:space="preserve">
          <source>U+0300 - U+036F</source>
          <target state="translated">U+0300-U+036F</target>
        </trans-unit>
        <trans-unit id="820e59791c5dbc98084a89fd4c68a5caddd9a3e8" translate="yes" xml:space="preserve">
          <source>U+10000 - U+1FFFD</source>
          <target state="translated">U+10000-U+1FFFD</target>
        </trans-unit>
        <trans-unit id="172792565a185595c59af72f4ae5f6a9a6e9ad8f" translate="yes" xml:space="preserve">
          <source>U+1681 - U+180D</source>
          <target state="translated">U+1681-U+180D</target>
        </trans-unit>
        <trans-unit id="d84a34f5a6d7a409f7d9c6df8ad6471fbc79b9b0" translate="yes" xml:space="preserve">
          <source>U+180F - U+1FFF</source>
          <target state="translated">U+180F-U+1FFF</target>
        </trans-unit>
        <trans-unit id="f3c3d44148796e35a5035d711e351a1697c2759f" translate="yes" xml:space="preserve">
          <source>U+1DC0 - U+1DFF</source>
          <target state="translated">U+1DC0-U+1DFF</target>
        </trans-unit>
        <trans-unit id="330cb234316d66348fc89aff6e84b6015dadcf43" translate="yes" xml:space="preserve">
          <source>U+20000 - U+2FFFD</source>
          <target state="translated">U+20000-U+2FFFD</target>
        </trans-unit>
        <trans-unit id="5b3b9b21095522acbe168717fae555c1cfa7a1f4" translate="yes" xml:space="preserve">
          <source>U+200B - U+200D</source>
          <target state="translated">U+200B-U+200D</target>
        </trans-unit>
        <trans-unit id="3214f797fec510b86bf1cbf6434d683974a2248a" translate="yes" xml:space="preserve">
          <source>U+202A - U+202E</source>
          <target state="translated">У+202А-У+202Е</target>
        </trans-unit>
        <trans-unit id="e97d49eff3295448f03d9e228444cd7f9a6734e9" translate="yes" xml:space="preserve">
          <source>U+203F - U+2040</source>
          <target state="translated">203F-2040</target>
        </trans-unit>
        <trans-unit id="0c09a7a1795e4fec0be94dc7e91b80a0bf26947f" translate="yes" xml:space="preserve">
          <source>U+2054</source>
          <target state="translated">U+2054</target>
        </trans-unit>
        <trans-unit id="cdc2d82bb3995d9b19eb2ac346b26a7a77b2e28c" translate="yes" xml:space="preserve">
          <source>U+2060 - U+218F</source>
          <target state="translated">U+2060-U+218F</target>
        </trans-unit>
        <trans-unit id="dc13f074c0cd31a6bc8af3c06df64a92b1be84c7" translate="yes" xml:space="preserve">
          <source>U+20D0 - U+20FF</source>
          <target state="translated">20D0-20FF</target>
        </trans-unit>
        <trans-unit id="46981b50f5cdfcf424f38b4b3c8b461b58872a28" translate="yes" xml:space="preserve">
          <source>U+2460 - U+24FF</source>
          <target state="translated">U+2460-U+24FF</target>
        </trans-unit>
        <trans-unit id="8e2adfcb84ba00df4ef947391a6eab237e18db97" translate="yes" xml:space="preserve">
          <source>U+2776 - U+2793</source>
          <target state="translated">U+2776-U+2793</target>
        </trans-unit>
        <trans-unit id="0ef4d0c6e728306dc714d1b3534d9c4ee993dccf" translate="yes" xml:space="preserve">
          <source>U+2C00 - U+2DFF</source>
          <target state="translated">U+2C00-U+2DFF</target>
        </trans-unit>
        <trans-unit id="acd49fd22f227c59f753777c2766efc982471a9a" translate="yes" xml:space="preserve">
          <source>U+2E80 - U+2FFF</source>
          <target state="translated">U+2E80-U+2FFFF</target>
        </trans-unit>
        <trans-unit id="e220b857ae2172b856a1a2e9b7ea31ff3edb4b96" translate="yes" xml:space="preserve">
          <source>U+30000 - U+3FFFD</source>
          <target state="translated">U+30000-U+3FFFD</target>
        </trans-unit>
        <trans-unit id="311cc5830e93c014a42f3cfe3f333942cdff5c89" translate="yes" xml:space="preserve">
          <source>U+3004 - U+3007</source>
          <target state="translated">U+3004-U+3007</target>
        </trans-unit>
        <trans-unit id="3518418be013a416f360fbc05bd7961da58adcba" translate="yes" xml:space="preserve">
          <source>U+3021 - U+302F</source>
          <target state="translated">U+3021-U+302F</target>
        </trans-unit>
        <trans-unit id="22bc0729fee97afe351038d4206a56bdf37b8cc5" translate="yes" xml:space="preserve">
          <source>U+3031 - U+D7FF</source>
          <target state="translated">U+3031-U+D7FF</target>
        </trans-unit>
        <trans-unit id="75623274217241111dd8aadc0414c3684e3527d1" translate="yes" xml:space="preserve">
          <source>U+40000 - U+4FFFD</source>
          <target state="translated">U+40000-U+4FFFD</target>
        </trans-unit>
        <trans-unit id="ad684b1e2d51f2021e6096ff323c755de9835267" translate="yes" xml:space="preserve">
          <source>U+50000 - U+5FFFD</source>
          <target state="translated">U+50000-U+5FFFD</target>
        </trans-unit>
        <trans-unit id="f48e64f1d20e3e1aa5cf849c51bec6aec208261d" translate="yes" xml:space="preserve">
          <source>U+60000 - U+6FFFD</source>
          <target state="translated">U+60000-U+6FFFD</target>
        </trans-unit>
        <trans-unit id="27a70a77fa9d62033c98d2e43a4e257bfcba0a32" translate="yes" xml:space="preserve">
          <source>U+70000 - U+7FFFD</source>
          <target state="translated">U+70000-U+7FFFD</target>
        </trans-unit>
        <trans-unit id="e47ee2f5ce5c5823a3427abfdcb793008f1f9afa" translate="yes" xml:space="preserve">
          <source>U+80000 - U+8FFFD</source>
          <target state="translated">U+80000-U+8FFFD</target>
        </trans-unit>
        <trans-unit id="ae42c9725173d1af60cd9ee4fec2a5e915a289c9" translate="yes" xml:space="preserve">
          <source>U+90000 - U+9FFFD</source>
          <target state="translated">U+90000-U+9FFFD</target>
        </trans-unit>
        <trans-unit id="a29e4d5dbda0a54f8aba629dfae926d4d31c7fa4" translate="yes" xml:space="preserve">
          <source>U+A0000 - U+AFFFD</source>
          <target state="translated">U+A0000-U+AFFFD</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
