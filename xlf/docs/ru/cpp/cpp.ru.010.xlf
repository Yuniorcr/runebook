<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="cpp">
    <body>
      <group id="cpp">
        <trans-unit id="5de0dced78d11272f963c83043ebca189594c138" translate="yes" xml:space="preserve">
          <source>A member of a class &lt;code&gt;T&lt;/code&gt; cannot use &lt;code&gt;T&lt;/code&gt; as its name if the member is a static data member, a member function, a member type, a member template , an enumerator of an unscoped enumeration, a member of a member anonymous union. However, a non-static data member may use the name &lt;code&gt;T&lt;/code&gt; as long as there are no user-declared constructors.</source>
          <target state="translated">Член класса &lt;code&gt;T&lt;/code&gt; не может использовать &lt;code&gt;T&lt;/code&gt; в качестве своего имени, если он является статическим членом данных, функцией-членом, типом элемента, шаблоном элемента, перечислителем перечисления с незаданной областью, членом анонимного объединения-члена. Однако нестатический член данных может использовать имя &lt;code&gt;T&lt;/code&gt; , если нет объявленных пользователем конструкторов.</target>
        </trans-unit>
        <trans-unit id="b4ca9ae096395091286ce2f97b84c334ccf6644c" translate="yes" xml:space="preserve">
          <source>A member or a member template of a class template may be explicitly specialized for a given implicit instantiation of the class template, even if the member or member template is defined in the class template definition.</source>
          <target state="translated">Шаблон-член или шаблон-член шаблона класса может быть явно специализирован для заданного неявного воплощения шаблона класса,даже если шаблон-член или шаблон-член определен в определении шаблона класса.</target>
        </trans-unit>
        <trans-unit id="3cc4194447e3feb7759961528ba2acc170fa12c7" translate="yes" xml:space="preserve">
          <source>A modifiable lvalue may be used as the left-hand operand of the built-in assignment and compound assignment operators.</source>
          <target state="translated">Модифицируемое значение l может использоваться как левый операнд встроенных операторов назначения и составных операторов назначения.</target>
        </trans-unit>
        <trans-unit id="8c00f6a72efb6556fa9292b04ea6629a5f0cab13" translate="yes" xml:space="preserve">
          <source>A more convenient way to construct a &lt;code&gt;month_day&lt;/code&gt; is with &lt;code&gt;operator/&lt;/code&gt;, e.g., &lt;code&gt;&lt;a href=&quot;../month&quot;&gt;std::chrono::April&lt;/a&gt;/1&lt;/code&gt;.</source>
          <target state="translated">Более удобный способ построить &lt;code&gt;month_day&lt;/code&gt; - использовать &lt;code&gt;operator/&lt;/code&gt; , например, &lt;code&gt;&lt;a href=&quot;../month&quot;&gt;std::chrono::April&lt;/a&gt;/1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e596eb0f0194c2c2e4167ab358138e5b60c14287" translate="yes" xml:space="preserve">
          <source>A more convenient way to construct a &lt;code&gt;month_day_last&lt;/code&gt; is with &lt;code&gt;operator/&lt;/code&gt;, e.g., &lt;code&gt;&lt;a href=&quot;../month&quot;&gt;std::chrono::April&lt;/a&gt;/&lt;a href=&quot;../last_spec&quot;&gt;std::chrono::last&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Более удобный способ построить &lt;code&gt;month_day_last&lt;/code&gt; с помощью &lt;code&gt;operator/&lt;/code&gt; , например, &lt;code&gt;&lt;a href=&quot;../month&quot;&gt;std::chrono::April&lt;/a&gt;/&lt;a href=&quot;../last_spec&quot;&gt;std::chrono::last&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1a8c5116dd01717b8a1f75b9620c596b6f5367a7" translate="yes" xml:space="preserve">
          <source>A more convenient way to construct a &lt;code&gt;month_weekday&lt;/code&gt; is with &lt;code&gt;operator/&lt;/code&gt;, e.g., &lt;code&gt;&lt;a href=&quot;../month&quot;&gt;std::chrono::April&lt;/a&gt;/&lt;a href=&quot;../weekday&quot;&gt;std::chrono::Sunday&lt;/a&gt;[2]&lt;/code&gt;.</source>
          <target state="translated">Более удобный способ построить &lt;code&gt;month_weekday&lt;/code&gt; - использовать &lt;code&gt;operator/&lt;/code&gt; , например, &lt;code&gt;&lt;a href=&quot;../month&quot;&gt;std::chrono::April&lt;/a&gt;/&lt;a href=&quot;../weekday&quot;&gt;std::chrono::Sunday&lt;/a&gt;[2]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4752a9f37cdb6658a9a8728cdd2291f0b5ec64d6" translate="yes" xml:space="preserve">
          <source>A more convenient way to construct a &lt;code&gt;month_weekday_last&lt;/code&gt; is with &lt;code&gt;operator/&lt;/code&gt;, e.g., &lt;code&gt;&lt;a href=&quot;../month&quot;&gt;std::chrono::April&lt;/a&gt;/&lt;a href=&quot;../weekday&quot;&gt;std::chrono::Sunday&lt;/a&gt;[&lt;a href=&quot;../last_spec&quot;&gt;std::chrono::last&lt;/a&gt;]&lt;/code&gt;.</source>
          <target state="translated">Более удобный способ построить &lt;code&gt;month_weekday_last&lt;/code&gt; с помощью &lt;code&gt;operator/&lt;/code&gt; , например, &lt;code&gt;&lt;a href=&quot;../month&quot;&gt;std::chrono::April&lt;/a&gt;/&lt;a href=&quot;../weekday&quot;&gt;std::chrono::Sunday&lt;/a&gt;[&lt;a href=&quot;../last_spec&quot;&gt;std::chrono::last&lt;/a&gt;]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7327a074e15b5c31502879c12e39a884355916ba" translate="yes" xml:space="preserve">
          <source>A more convenient way to construct a &lt;code&gt;weekday_indexed&lt;/code&gt; is with &lt;code&gt;weekday&lt;/code&gt;'s &lt;code&gt;operator[]&lt;/code&gt;, i.e., &lt;code&gt;wd[index]&lt;/code&gt;.</source>
          <target state="translated">Более удобный способ построить &lt;code&gt;weekday_indexed&lt;/code&gt; это с &lt;code&gt;weekday&lt;/code&gt; &amp;laquo;s &lt;code&gt;operator[]&lt;/code&gt; , то есть, &lt;code&gt;wd[index]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c209a7c3ca3ab0475649b12caaff743d2fbd1dd1" translate="yes" xml:space="preserve">
          <source>A more convenient way to construct a &lt;code&gt;weekday_last&lt;/code&gt; is with &lt;code&gt;weekday&lt;/code&gt;'s &lt;code&gt;operator[]&lt;/code&gt;, i.e., &lt;code&gt;wd[&lt;a href=&quot;../last_spec&quot;&gt;std::chrono::last&lt;/a&gt;]&lt;/code&gt;.</source>
          <target state="translated">Более удобный способ построить &lt;code&gt;weekday_last&lt;/code&gt; есть с &lt;code&gt;weekday&lt;/code&gt; &amp;laquo;с &lt;code&gt;operator[]&lt;/code&gt; , то есть, &lt;code&gt;wd[&lt;a href=&quot;../last_spec&quot;&gt;std::chrono::last&lt;/a&gt;]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="653ca78a80e72fd3496d4da44b432d7ef45908d8" translate="yes" xml:space="preserve">
          <source>A more convenient way to construct a &lt;code&gt;year_month&lt;/code&gt; is with &lt;code&gt;operator/&lt;/code&gt;, e.g., &lt;code&gt;2007y/&lt;a href=&quot;../month&quot;&gt;std::chrono::April&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Более удобный способ построить &lt;code&gt;year_month&lt;/code&gt; - использовать &lt;code&gt;operator/&lt;/code&gt; , например, &lt;code&gt;2007y/&lt;a href=&quot;../month&quot;&gt;std::chrono::April&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6f1d73be6c54e98a146e6c453de6dea68f79b357" translate="yes" xml:space="preserve">
          <source>A move assignment operator of class &lt;code&gt;T&lt;/code&gt; is a non-template &lt;a href=&quot;member_functions&quot;&gt;non-static member function&lt;/a&gt; with the name &lt;code&gt;operator=&lt;/code&gt; that takes exactly one parameter of type &lt;code&gt;T&amp;amp;&amp;amp;&lt;/code&gt;, &lt;code&gt;const T&amp;amp;&amp;amp;&lt;/code&gt;, &lt;code&gt;volatile T&amp;amp;&amp;amp;&lt;/code&gt;, or &lt;code&gt;const volatile T&amp;amp;&amp;amp;&lt;/code&gt;.</source>
          <target state="translated">Оператор присваивания перемещения класса &lt;code&gt;T&lt;/code&gt; - это не шаблонная &lt;a href=&quot;member_functions&quot;&gt;нестатическая функция-член&lt;/a&gt; с &lt;code&gt;operator=&lt;/code&gt; name =, которая принимает ровно один параметр типа &lt;code&gt;T&amp;amp;&amp;amp;&lt;/code&gt; , &lt;code&gt;const T&amp;amp;&amp;amp;&lt;/code&gt; , &lt;code&gt;volatile T&amp;amp;&amp;amp;&lt;/code&gt; или &lt;code&gt;const volatile T&amp;amp;&amp;amp;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7677c3fc7a7f1b5d05a4ba8d65de62c8c77ad6c9" translate="yes" xml:space="preserve">
          <source>A move constructor of class &lt;code&gt;T&lt;/code&gt; is a non-template &lt;a href=&quot;constructor&quot;&gt;constructor&lt;/a&gt; whose first parameter is &lt;code&gt;T&amp;amp;&amp;amp;&lt;/code&gt;, &lt;code&gt;const T&amp;amp;&amp;amp;&lt;/code&gt;, &lt;code&gt;volatile T&amp;amp;&amp;amp;&lt;/code&gt;, or &lt;code&gt;const volatile T&amp;amp;&amp;amp;&lt;/code&gt;, and either there are no other parameters, or the rest of the parameters all have default values.</source>
          <target state="translated">Конструктор перемещения класса &lt;code&gt;T&lt;/code&gt; - это не шаблонный &lt;a href=&quot;constructor&quot;&gt;конструктор&lt;/a&gt; , первым параметром которого является &lt;code&gt;T&amp;amp;&amp;amp;&lt;/code&gt; , &lt;code&gt;const T&amp;amp;&amp;amp;&lt;/code&gt; , &lt;code&gt;volatile T&amp;amp;&amp;amp;&lt;/code&gt; или &lt;code&gt;const volatile T&amp;amp;&amp;amp;&lt;/code&gt; , и либо нет других параметров, либо все остальные параметры имеют значения по умолчанию.</target>
        </trans-unit>
        <trans-unit id="16af80cf4cdc5acb425ed5fb5f2a532dceaaf925" translate="yes" xml:space="preserve">
          <source>A multibyte character string is layout-compatible with null-terminated byte string (NTBS), that is, can be stored, copied, and examined using the same facilities, except for calculating the number of characters. If the correct locale is in effect, I/O functions also handle multibyte strings. Multibyte strings can be converted to and from wide strings using the &lt;code&gt;&lt;a href=&quot;../locale/codecvt&quot;&gt;std::codecvt&lt;/a&gt;&lt;/code&gt; member functions, &lt;code&gt;&lt;a href=&quot;../locale/wstring_convert&quot;&gt;std::wstring_convert&lt;/a&gt;&lt;/code&gt;, or the following locale-dependent conversion functions:</source>
          <target state="translated">Многобайтовая символьная строка совместима с макетом с байтовой строкой с нулевым символом в конце (NTBS), то есть может храниться, копироваться и проверяться с использованием тех же средств, за исключением вычисления количества символов. Если действует правильный языковой стандарт, функции ввода-вывода также обрабатывают многобайтовые строки. Многобайтовые строки можно преобразовывать в широкие строки и из них, используя функции-члены &lt;code&gt;&lt;a href=&quot;../locale/codecvt&quot;&gt;std::codecvt&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../locale/wstring_convert&quot;&gt;std::wstring_convert&lt;/a&gt;&lt;/code&gt; или следующие зависящие от локали функции преобразования:</target>
        </trans-unit>
        <trans-unit id="d98fb2bdc836fccaa6d115487be59107743d4bcc" translate="yes" xml:space="preserve">
          <source>A name declared non-deprecated may be redeclared deprecated. A name declared deprecated cannot be un-deprecated by redeclaring it without this attribute.</source>
          <target state="translated">Имя,объявленное не устаревшим,может быть заново объявлено устаревшим.Имя,объявленное устаревшим,не может быть устаревшим путем переименования без этого атрибута.</target>
        </trans-unit>
        <trans-unit id="9645e04714e8aeab4e16fb75044a74252ed38005" translate="yes" xml:space="preserve">
          <source>A name first declared in a friend declaration within class or class template X becomes a member of the innermost enclosing namespace of X, but is not visible for lookup (except argument-dependent lookup that considers X) unless a matching declaration at the namespace scope is provided - see &lt;a href=&quot;namespace#Namespaces&quot;&gt;namespaces&lt;/a&gt; for details.</source>
          <target state="translated">Имя, впервые объявленное в объявлении друга в классе или шаблоне класса X, становится членом внутреннего вложенного пространства имен X, но не отображается для поиска (кроме поиска, зависящего от аргумента, который учитывает X), если только соответствующее объявление в области пространства имен не является при условии - см. &lt;a href=&quot;namespace#Namespaces&quot;&gt; пространства имен&lt;/a&gt; для деталей.</target>
        </trans-unit>
        <trans-unit id="3933fe1919f27704fb38fb769004562260d8099c" translate="yes" xml:space="preserve">
          <source>A name is classified as a member of the current instantiation if it is.</source>
          <target state="translated">Имя классифицируется в качестве члена текущей инстанциии,если оно является таковым.</target>
        </trans-unit>
        <trans-unit id="9ddc18654271b83daffe509c6b14c3572df5edd8" translate="yes" xml:space="preserve">
          <source>A name that denotes object, reference, function, type, template, namespace, or value, may have</source>
          <target state="translated">Имя,обозначающее объект,ссылку,функцию,тип,шаблон,пространство имен или значение,может иметь следующие характеристики</target>
        </trans-unit>
        <trans-unit id="853d1578fabbd2c82d82a0fe09f5702733aba960" translate="yes" xml:space="preserve">
          <source>A name that is accessible through multiple paths in the inheritance graph has the access of the path with the most access:</source>
          <target state="translated">Имя,доступное через несколько путей в графе наследования,имеет доступ к пути с наибольшим доступом:</target>
        </trans-unit>
        <trans-unit id="6e45514825dadadd15b3e67c603ee32f7155b58a" translate="yes" xml:space="preserve">
          <source>A name that is private according to unqualified &lt;a href=&quot;lookup&quot;&gt;name lookup&lt;/a&gt;, may be accessible through qualified name lookup:</source>
          <target state="translated">Имя, которое является частным в соответствии с неквалифицированным &lt;a href=&quot;lookup&quot;&gt; поиском без определения имени&lt;/a&gt; , может быть доступно через поиск подходящего имени:</target>
        </trans-unit>
        <trans-unit id="39b86d73926de6a377e6b550b9b013a7e40df60f" translate="yes" xml:space="preserve">
          <source>A namespace member that was declared within a namespace body may be defined or redeclared outside of it using explicit qualification.</source>
          <target state="translated">Член пространства имен,который был объявлен в теле пространства имен,может быть определен или повторно объявлен вне его с помощью явной квалификации.</target>
        </trans-unit>
        <trans-unit id="039345001a9866dd339fc34b017f987d45772976" translate="yes" xml:space="preserve">
          <source>A narrow character string is created as if by a call to &lt;code&gt;&lt;a href=&quot;../../io/c/fprintf&quot;&gt;std::printf&lt;/a&gt;(spec, v)&lt;/code&gt; in the &quot;C&quot; locale, where &lt;code&gt;spec&lt;/code&gt; is the chosen conversion specifier.</source>
          <target state="translated">Узкая символьная строка создается как бы при вызове &lt;code&gt;&lt;a href=&quot;../../io/c/fprintf&quot;&gt;std::printf&lt;/a&gt;(spec, v)&lt;/code&gt; в локали &quot;C&quot;, где &lt;code&gt;spec&lt;/code&gt; - это выбранный спецификатор преобразования.</target>
        </trans-unit>
        <trans-unit id="105e80128937d46ea748308c3640f225aa1f1163" translate="yes" xml:space="preserve">
          <source>A negative value of &lt;code&gt;time-&amp;gt;tm_isdst&lt;/code&gt; causes &lt;code&gt;mktime&lt;/code&gt; to attempt to determine if Daylight Saving Time was in effect.</source>
          <target state="translated">Отрицательное значение &lt;code&gt;time-&amp;gt;tm_isdst&lt;/code&gt; заставляет &lt;code&gt;mktime&lt;/code&gt; попытаться определить, действует ли переход на летнее время.</target>
        </trans-unit>
        <trans-unit id="93b6295b9130f095206e2ffbf6e1a198ffb81cdb" translate="yes" xml:space="preserve">
          <source>A nested requirement has the form.</source>
          <target state="translated">Вложенное требование имеет форму.</target>
        </trans-unit>
        <trans-unit id="aab04a416d50d68103518e61edffcc3d876b52d0" translate="yes" xml:space="preserve">
          <source>A new &lt;code&gt;std::scoped_allocator_adaptor&lt;/code&gt; object, constructed from correctly copied allocators.</source>
          <target state="translated">Новый объект &lt;code&gt;std::scoped_allocator_adaptor&lt;/code&gt; , созданный из правильно скопированных распределителей.</target>
        </trans-unit>
        <trans-unit id="b3fea0735582c1d92ba9ca4265c504066694d506" translate="yes" xml:space="preserve">
          <source>A newly constructed object of type &lt;code&gt;pos_type&lt;/code&gt; which stores the resulting file position, or &lt;code&gt;pos_type(off_type(-1))&lt;/code&gt; on failure.</source>
          <target state="translated">Вновь созданный объект типа &lt;code&gt;pos_type&lt;/code&gt; ,в котором хранится результирующая позиция файла, или &lt;code&gt;pos_type(off_type(-1))&lt;/code&gt; при ошибке .</target>
        </trans-unit>
        <trans-unit id="7812e17881f85045a11332d843939ff143d1510b" translate="yes" xml:space="preserve">
          <source>A newly opened stream has no orientation. The first call to &lt;code&gt;std::fwide&lt;/code&gt; or to any I/O function establishes the orientation: wide I/O function makes the stream wide-oriented, narrow I/O function makes the stream narrow-oriented. Once set, orientation can only be changed with &lt;code&gt;&lt;a href=&quot;c/freopen&quot;&gt;std::freopen&lt;/a&gt;&lt;/code&gt;. Narrow I/O functions cannot be called on a wide-oriented stream, wide I/O functions cannot be called on a narrow-oriented stream. Wide I/O functions convert between wide and multibyte characters as if by calling &lt;code&gt;&lt;a href=&quot;../string/multibyte/mbrtowc&quot;&gt;std::mbrtowc&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../string/multibyte/wcrtomb&quot;&gt;std::wcrtomb&lt;/a&gt;&lt;/code&gt;. Unlike the multibyte character strings that are valid in a program, multibyte characters in the file may contain embedded nulls and do not have to begin or end in the initial shift state.</source>
          <target state="translated">Вновь открытый поток не имеет ориентации. Первый вызов &lt;code&gt;std::fwide&lt;/code&gt; или любой другой функции ввода / вывода устанавливает ориентацию: широкая функция ввода / вывода делает поток ориентированным на широкие, а узкая функция ввода / вывода делает поток узким направлением. После установки ориентация может быть изменена только с помощью &lt;code&gt;&lt;a href=&quot;c/freopen&quot;&gt;std::freopen&lt;/a&gt;&lt;/code&gt; . Узкие функции ввода / вывода не могут быть вызваны в узко ориентированном потоке, широкие функции ввода / вывода не могут быть вызваны в узкоориентированном потоке. Широкие функции ввода / вывода преобразуются между широкими и многобайтовыми символами, как если бы они &lt;code&gt;&lt;a href=&quot;../string/multibyte/mbrtowc&quot;&gt;std::mbrtowc&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;../string/multibyte/wcrtomb&quot;&gt;std::wcrtomb&lt;/a&gt;&lt;/code&gt; . В отличие от многобайтовых символьных строк, допустимых в программе, многобайтовые символы в файле могут содержать встроенные нули и не должны начинаться или заканчиваться в начальном состоянии сдвига.</target>
        </trans-unit>
        <trans-unit id="869a3424851c79242efec3e07d77e356612111d6" translate="yes" xml:space="preserve">
          <source>A noexcept-specification of a function is considered to be</source>
          <target state="translated">Считается,что функция,за исключением спецификации,имеет следующие характеристики</target>
        </trans-unit>
        <trans-unit id="6aee1e7c886fbccbfdc8526a802aa2e4e5e0f970" translate="yes" xml:space="preserve">
          <source>A non-class non-array prvalue cannot be &lt;a href=&quot;cv&quot;&gt;cv-qualified&lt;/a&gt;. (Note: a function call or cast expression may result in a prvalue of non-class cv-qualified type, but the cv-qualifier is immediately stripped out.)</source>
          <target state="translated">Не-класс не-массив prvalue не может быть &lt;a href=&quot;cv&quot;&gt; cv-квалифицированным&lt;/a&gt; . (Примечание: вызов функции или выражение приведения может привести к значению типа неквалифицированного cv, но квалификатор cv немедленно удаляется.)</target>
        </trans-unit>
        <trans-unit id="9c16e8da66b88facf18bcff094f8898640478943" translate="yes" xml:space="preserve">
          <source>A non-const rvalue of type &lt;code&gt;X::node_type&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;X::node_type&lt;/code&gt; типа X :: node_type</target>
        </trans-unit>
        <trans-unit id="cbfbc01b79d14846f146d50d1446c4035f6cd1b8" translate="yes" xml:space="preserve">
          <source>A non-explicit constructor that accepts an argument of type (possibly const) &lt;code&gt;&lt;a href=&quot;streamoff&quot;&gt;std::streamoff&lt;/a&gt;&lt;/code&gt;, which stores that offset and and value-initializes the state object. This constructor must also accept the special value &lt;code&gt;&lt;a href=&quot;streamoff&quot;&gt;std::streamoff&lt;/a&gt;(-1)&lt;/code&gt;: the &lt;code&gt;std::fpos&lt;/code&gt; constructed in this manner is returned by some stream operations to indicate errors.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;streamoff&quot;&gt;std::streamoff&lt;/a&gt;&lt;/code&gt; конструктор, который принимает аргумент типа (возможно, const) std :: streamoff , который хранит это смещение и и инициализирует значение объекта состояния. Этот конструктор также должен принимать специальное значение &lt;code&gt;&lt;a href=&quot;streamoff&quot;&gt;std::streamoff&lt;/a&gt;(-1)&lt;/code&gt; : сконструированный таким образом &lt;code&gt;std::fpos&lt;/code&gt; возвращается некоторыми операциями потока для указания ошибок.</target>
        </trans-unit>
        <trans-unit id="7c5f2f406d4c6d5a6be68be9a352e598e29e63cd" translate="yes" xml:space="preserve">
          <source>A non-member function definition may appear at namespace scope only (there are no nested functions). A &lt;a href=&quot;member_functions&quot;&gt;member function&lt;/a&gt; definition may also appear in the body of a &lt;a href=&quot;class&quot;&gt;class definition&lt;/a&gt;. They have the following syntax:</source>
          <target state="translated">Определение функции, не являющейся членом, может появляться только в области имен (нет вложенных функций). Определение &lt;a href=&quot;member_functions&quot;&gt;функции-члена&lt;/a&gt; может также появиться в теле&lt;a href=&quot;class&quot;&gt; класса&lt;/a&gt; . У них есть следующий синтаксис:</target>
        </trans-unit>
        <trans-unit id="a8537e5e8c50ad3a4da6590cf63b9c692c279951" translate="yes" xml:space="preserve">
          <source>A non-placement allocation or deallocation function for a class is odr-used by the definition of a constructor of that class.</source>
          <target state="translated">Функция неместного распределения или разделения для класса используется по определению конструктора этого класса.</target>
        </trans-unit>
        <trans-unit id="54709ac99fdc50ecc6383b09c5e6260c6f17f5a9" translate="yes" xml:space="preserve">
          <source>A non-placement deallocation function for a class is odr-used by the definition of the destructor of that class, or by being selected by the lookup at the point of definition of a virtual destructor</source>
          <target state="translated">Функция неместного размещения деструктора для класса используется либо по определению деструктора данного класса,либо по выбору при поиске в точке определения виртуального деструктора</target>
        </trans-unit>
        <trans-unit id="57427d16d98090f308df82f3319c4bb23d4b400e" translate="yes" xml:space="preserve">
          <source>A non-static member function can be declared with a const, volatile, or const volatile qualifier (this qualifier appears after the parameter list in the &lt;a href=&quot;function&quot;&gt;function declaration&lt;/a&gt;). Differently cv-qualified functions have different types and so may overload each other.</source>
          <target state="translated">Нестатическая функция-член может быть объявлена ​​с помощью квалификатора const, volatile или const volatile (этот классификатор появляется после списка параметров в &lt;a href=&quot;function&quot;&gt;объявлении функции&lt;/a&gt; ). По-разному cv-квалифицированные функции имеют разные типы и поэтому могут перегружать друг друга.</target>
        </trans-unit>
        <trans-unit id="6269d14f99ea7d83ea3dec1f28326b8c6d5c5ecd" translate="yes" xml:space="preserve">
          <source>A non-static member function can be declared with no ref-qualifier, with an lvalue ref-qualifier (the token &lt;code&gt;&amp;amp;&lt;/code&gt; after the parameter list) or the rvalue ref-qualifier (the token &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; after the parameter list). During &lt;a href=&quot;overload_resolution&quot;&gt;overload resolution&lt;/a&gt;, non-static cv-qualified member function of class X is treated as follows:</source>
          <target state="translated">Нестатическая функция-член может быть объявлена ​​без квалификатора ref, с помощью ref-квалификатора lvalue (токен &lt;code&gt;&amp;amp;&lt;/code&gt; после списка параметров) или ref-квалификатора rvalue (токен &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; после списка параметров). Во время &lt;a href=&quot;overload_resolution&quot;&gt;разрешения перегрузки&lt;/a&gt; нестатическая cv-квалифицированная функция-член класса X обрабатывается следующим образом:</target>
        </trans-unit>
        <trans-unit id="c58ef98b1f97443f7f30d89e9dea4b508149bdcf" translate="yes" xml:space="preserve">
          <source>A non-static member function is a function that is declared in a &lt;a href=&quot;class&quot;&gt;member specification&lt;/a&gt; of a class without a &lt;a href=&quot;static&quot;&gt;static&lt;/a&gt; or &lt;a href=&quot;friend&quot;&gt;friend&lt;/a&gt; specifier.</source>
          <target state="translated">Нестатическая функция-член - это функция, которая объявлена ​​в &lt;a href=&quot;class&quot;&gt;спецификации члена&lt;/a&gt; класса без &lt;a href=&quot;static&quot;&gt;статики&lt;/a&gt; или &lt;a href=&quot;friend&quot;&gt;друга&lt;/a&gt; спецификатора.</target>
        </trans-unit>
        <trans-unit id="327b4ee07e641d05a96006e2735a0db3601ea014" translate="yes" xml:space="preserve">
          <source>A non-static member function may be declared</source>
          <target state="translated">Функция нестатического члена может быть объявлена</target>
        </trans-unit>
        <trans-unit id="8309388308c23f79d7667a2481e8485faf7c4b76" translate="yes" xml:space="preserve">
          <source>A non-static member function of class X may be called.</source>
          <target state="translated">Может быть вызвана нестатическая функция-член класса X.</target>
        </trans-unit>
        <trans-unit id="3dd8b8cff9d7f40f60c773d5633d2a93e250abe4" translate="yes" xml:space="preserve">
          <source>A non-template function is always distinct from a template specialization with the same type. Specializations of different function templates are always distinct from each other even if they have the same type. Two function templates with the same return type and the same parameter list are distinct and can be distinguished with explicit template argument list.</source>
          <target state="translated">Нешаблонная функция всегда отличается от шаблонной специализации одним и тем же типом.Специализации различных шаблонов функций всегда отличаются друг от друга,даже если они имеют один и тот же тип.Два шаблона функций с одним и тем же типом возврата и одним и тем же списком параметров отличаются друг от друга и могут быть отличены явным списком аргументов шаблона.</target>
        </trans-unit>
        <trans-unit id="ec8d1e0238ca169189cb132939968a32e225940d" translate="yes" xml:space="preserve">
          <source>A non-template member function and a template member function with the same name may be declared. In case of conflict (when some template specialization matches the non-template function signature exactly), use of that name and type refers to the non-template member unless an explicit template argument list is supplied.</source>
          <target state="translated">Может быть объявлена функция,не являющаяся членом шаблона,и функция,являющаяся членом шаблона,с тем же именем.В случае конфликта (когда некоторая специализация шаблона точно совпадает с сигнатурой нешаблонной функции),использование этого имени и типа относится к нешаблону-членов,если только не предоставлен явный список аргументов шаблона.</target>
        </trans-unit>
        <trans-unit id="1d14804af608dab04a2318dab2393b02651d54c9" translate="yes" xml:space="preserve">
          <source>A notable implementation where &lt;code&gt;std::random_device&lt;/code&gt; is deterministic is MinGW (&lt;a href=&quot;https://sourceforge.net/p/mingw-w64/bugs/338/&quot;&gt;bug 338&lt;/a&gt;), although replacement implementations exist, such as &lt;a href=&quot;https://github.com/euloanty/mingw-std-random_device&quot;&gt;mingw-std-random_device&lt;/a&gt;.</source>
          <target state="translated">Известной реализацией, в которой &lt;code&gt;std::random_device&lt;/code&gt; является детерминированной, является MinGW ( &lt;a href=&quot;https://sourceforge.net/p/mingw-w64/bugs/338/&quot;&gt;ошибка 338&lt;/a&gt; ), хотя существуют &lt;a href=&quot;https://github.com/euloanty/mingw-std-random_device&quot;&gt;альтернативные&lt;/a&gt; реализации, такие как mingw-std-random_device .</target>
        </trans-unit>
        <trans-unit id="d97541bdffeb4e63b35a3a02617d21fc06220467" translate="yes" xml:space="preserve">
          <source>A null pointer constant may be &lt;a href=&quot;../language/implicit_cast&quot;&gt;implicitly converted&lt;/a&gt; to any pointer type; such conversion results in the null pointer value of that type. If a null pointer constant has integer type, it may be converted to a prvalue of type &lt;code&gt;&lt;a href=&quot;nullptr_t&quot;&gt;std::nullptr_t&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Константа нулевого указателя может быть &lt;a href=&quot;../language/implicit_cast&quot;&gt;неявно преобразована&lt;/a&gt; в любой тип указателя; такое преобразование приводит к нулевому значению указателя этого типа. Если константа нулевого указателя имеет целочисленный тип, она может быть преобразована в значение типа &lt;code&gt;&lt;a href=&quot;nullptr_t&quot;&gt;std::nullptr_t&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f1572c78e938eb0e97af4e78573d5ecf38073eb0" translate="yes" xml:space="preserve">
          <source>A null-terminated byte string (NTBS) is a sequence of nonzero bytes followed by a byte with value zero (the terminating null character). Each byte in a byte string encodes one character of some character set. For example, the character array &lt;code&gt;{'\x63', '\x61', '\x74', '\0'}&lt;/code&gt; is an NTBS holding the string &lt;code&gt;&quot;cat&quot;&lt;/code&gt; in ASCII encoding.</source>
          <target state="translated">Строка байтов с нулевым символом в конце (NTBS) представляет собой последовательность ненулевых байтов, за которыми следует байт со значением ноль (завершающий нулевой символ). Каждый байт в строке байтов кодирует один символ некоторого набора символов. Например, массив символов &lt;code&gt;{'\x63', '\x61', '\x74', '\0'}&lt;/code&gt; является NTBS, содержащим строку &lt;code&gt;&quot;cat&quot;&lt;/code&gt; в кодировке ASCII.</target>
        </trans-unit>
        <trans-unit id="3b3fe15454343ce4cbfa8b2d64edd72623154c83" translate="yes" xml:space="preserve">
          <source>A null-terminated multibyte string (NTMBS), or &quot;multibyte string&quot;, is a sequence of nonzero bytes followed by a byte with value zero (the terminating null character).</source>
          <target state="translated">Нулевая многобайтная строка (NTMBS),или &quot;многобайтная строка&quot;,представляет собой последовательность ненулевых байтов,за которыми следует байт со значением нуля (оканчивающийся нулевой символ).</target>
        </trans-unit>
        <trans-unit id="d3f369b83e123d7a5137bbdf57df583877994fe3" translate="yes" xml:space="preserve">
          <source>A null-terminated wide string is a sequence of valid wide characters, ending with a null character.</source>
          <target state="translated">Нулевая терминированная широкая строка-это последовательность допустимых широких символов,заканчивающаяся нулевым символом.</target>
        </trans-unit>
        <trans-unit id="f262d7c58008e0145d059876c3647b11a00b98dc" translate="yes" xml:space="preserve">
          <source>A numeric array containing elements with values obtained by applying corresponding operator to the values in &lt;code&gt;*this&lt;/code&gt;.</source>
          <target state="translated">Числовой массив, содержащий элементы со значениями, полученными путем применения соответствующего оператора к значениям в &lt;code&gt;*this&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="477cf9e2034b21d56b53532edeb5fa0ff54341d3" translate="yes" xml:space="preserve">
          <source>A numeric array containing the results of computation of inverse tangent.</source>
          <target state="translated">Числовой массив,содержащий результаты вычисления обратного касательного.</target>
        </trans-unit>
        <trans-unit id="d991ad4854aaf7bce85259a803aef1efb1b7db52" translate="yes" xml:space="preserve">
          <source>A numeric array containing the results of exponentiation.</source>
          <target state="translated">Числовой массив,содержащий результаты экспонентирования.</target>
        </trans-unit>
        <trans-unit id="2b3cfb0c9df6711008dfe1dd42137fa47903d378" translate="yes" xml:space="preserve">
          <source>A numeric array of &lt;code&gt;bool&lt;/code&gt; containing comparison results of corresponding elements.</source>
          <target state="translated">Числовой массив &lt;code&gt;bool&lt;/code&gt; , содержащий результаты сравнения соответствующих элементов.</target>
        </trans-unit>
        <trans-unit id="bd2bad531f6152b88c43bb2fbb72d8dcd8b7df39" translate="yes" xml:space="preserve">
          <source>A numeric value &lt;code&gt;n&lt;/code&gt; can be converted to a byte value using &lt;code&gt;std::byte{n}&lt;/code&gt;, due to C++17 relaxed enum class initialization rules.</source>
          <target state="translated">Числовое значение &lt;code&gt;n&lt;/code&gt; может быть преобразовано в байтовое значение с помощью &lt;code&gt;std::byte{n}&lt;/code&gt; , благодаря C ++ 17 правилам инициализации класса enum.</target>
        </trans-unit>
        <trans-unit id="c9a28ea00b0028d881fe812f3c217cb4fc954bd0" translate="yes" xml:space="preserve">
          <source>A pack expansion may appear inside the parentheses of a &lt;a href=&quot;direct_initialization&quot;&gt;direct initializer&lt;/a&gt;, a &lt;a href=&quot;explicit_cast&quot;&gt;function-style cast&lt;/a&gt;, and other contexts (&lt;a href=&quot;constructor&quot;&gt;member initializer&lt;/a&gt;, &lt;a href=&quot;new&quot;&gt;new-expression&lt;/a&gt;, etc) in which case the rules are identical to the rules for a function call expression above.</source>
          <target state="translated">Расширение пакета может появляться в круглых скобках &lt;a href=&quot;direct_initialization&quot;&gt;прямого инициализатора&lt;/a&gt; , приведения в &lt;a href=&quot;explicit_cast&quot;&gt;стиле функции&lt;/a&gt; и других контекстов ( &lt;a href=&quot;constructor&quot;&gt;инициализатор члена&lt;/a&gt; , &lt;a href=&quot;new&quot;&gt;новое выражение&lt;/a&gt; и т. Д.), И в этом случае правила идентичны правилам для выражения вызова функции выше.</target>
        </trans-unit>
        <trans-unit id="2677c415425384fd8d2e20b4d33138e46186a2e0" translate="yes" xml:space="preserve">
          <source>A pack expansion may appear inside the parentheses of a function call operator, in which case the largest expression or braced-init-list to the left of the ellipsis is the pattern that is expanded.</source>
          <target state="translated">В скобках оператора вызова функции может появиться расширение пакета,в этом случае наибольшим выражением или скобкой слева от эллипса будет расширенный шаблон.</target>
        </trans-unit>
        <trans-unit id="e1ace690cd25f5f4ab9e5665bb9125a09841bb96" translate="yes" xml:space="preserve">
          <source>A pack expansion may designate the list of base classes in a &lt;a href=&quot;class&quot;&gt;class declaration&lt;/a&gt;. Typically, this also means that the constructor needs to use a pack expansion in the &lt;a href=&quot;constructor&quot;&gt;member initializer list&lt;/a&gt; to call the constructors of these bases:</source>
          <target state="translated">Расширение пакета может обозначать список базовых классов в &lt;a href=&quot;class&quot;&gt;объявлении класса&lt;/a&gt; . Как правило, это также означает, что конструктор должен использовать расширение пакета в &lt;a href=&quot;constructor&quot;&gt;списке инициализатора члена&lt;/a&gt; для вызова конструкторов этих баз:</target>
        </trans-unit>
        <trans-unit id="d479119249c5408ac797bae6fd07fa8962b62780" translate="yes" xml:space="preserve">
          <source>A pair of iterators to the first and one past last positions in [first, last) where a subsequence that compares equal to [pat_first, pat_last) as defined by &lt;code&gt;pred&lt;/code&gt; is located, or a pair of copies of &lt;code&gt;last&lt;/code&gt; otherwise.</source>
          <target state="translated">Пара итераторы к первому и одной прошлым последним позициям в [первый, последний) , где подпоследовательность , который сравнивает равен [pat_first, pat_last) , как определено &lt;code&gt;pred&lt;/code&gt; находится, или пары копий в &lt;code&gt;last&lt;/code&gt; в противном случае.</target>
        </trans-unit>
        <trans-unit id="92fbc534b58c32d1abb15ac3dd6e84d9ec347ad8" translate="yes" xml:space="preserve">
          <source>A pair whose first element is an iterator to the element past the last element moved in the source range, and whose second element is an iterator to the element past the last element moved in the destination range.</source>
          <target state="translated">Пара,первый элемент которой является итератором к элементу,прошедшему мимо последнего элемента,перемещенного в диапазоне источника,а второй-итератором к элементу,прошедшему мимо последнего элемента,перемещенного в диапазоне назначения.</target>
        </trans-unit>
        <trans-unit id="2e2beaabd453f4099778dc9501c74c786e364ee1" translate="yes" xml:space="preserve">
          <source>A parameter declaration in a function declaration that isn't a definition</source>
          <target state="translated">Декларация параметров в декларации функции,которая не является определением</target>
        </trans-unit>
        <trans-unit id="0076d34b706ead6a1662fb14d4690ea4e30b8030" translate="yes" xml:space="preserve">
          <source>A parameter pack may appear in the capture clause of a &lt;a href=&quot;lambda&quot;&gt;lambda&lt;/a&gt; expression.</source>
          <target state="translated">Пакет параметров может появиться в предложении захвата &lt;a href=&quot;lambda&quot;&gt;лямбды&lt;/a&gt; выражения.</target>
        </trans-unit>
        <trans-unit id="9b45675f6742158d4e1ce1e4e41d58001eb61fb1" translate="yes" xml:space="preserve">
          <source>A path can be</source>
          <target state="translated">Путь может быть</target>
        </trans-unit>
        <trans-unit id="8d3919f5b58d9be3b1d118858e1954d6017bb744" translate="yes" xml:space="preserve">
          <source>A path of execution is deemed to include a label if and only if it contains a jump to that label:</source>
          <target state="translated">Считается,что путь выполнения включает метку,если и только если он содержит переход к этой метке:</target>
        </trans-unit>
        <trans-unit id="cc3d18d57e43e7c1a9f4ffb652c5171bd83b4d2f" translate="yes" xml:space="preserve">
          <source>A pattern consisting of a sign with no digits following it is treated as pattern that did not match anything.</source>
          <target state="translated">Образец,состоящий из знака без цифр,следующий за ним,рассматривается как образец,который ни с чем не совпадает.</target>
        </trans-unit>
        <trans-unit id="8746ca0afe0288d6db6ce87470f68b70a4fdf43e" translate="yes" xml:space="preserve">
          <source>A pattern followed by an ellipsis, in which the name of at least one parameter pack appears at least once, is</source>
          <target state="translated">Шаблон,за которым следует эллипсис,в котором имя по крайней мере одного пакета параметров появляется хотя бы один раз,имеет следующие значения</target>
        </trans-unit>
        <trans-unit id="9ca2d1d59088c7c3b22db69dff86c0c2b3191b10" translate="yes" xml:space="preserve">
          <source>A placeholder type specifier may appear in the following contexts:</source>
          <target state="translated">Спецификатор типа заполнителя может появиться в следующих контекстах:</target>
        </trans-unit>
        <trans-unit id="cbee5c61daad736bbf4e77a8621940e9b34e3473" translate="yes" xml:space="preserve">
          <source>A plain integer is accepted if its meaning is unambiguous from the types of other operands: &lt;code&gt;2005y/4/5&lt;/code&gt; is allowed, but &lt;code&gt;5/April/2005&lt;/code&gt; is not.</source>
          <target state="translated">Простое целое число принимается, если его значение однозначно от типов других операндов: &lt;code&gt;2005y/4/5&lt;/code&gt; разрешено, но &lt;code&gt;5/April/2005&lt;/code&gt; - нет.</target>
        </trans-unit>
        <trans-unit id="fec8de0bf924bd134d73493ee3f200fd0ba8a2d5" translate="yes" xml:space="preserve">
          <source>A pointer declaration is any simple declaration whose &lt;a href=&quot;declarations&quot;&gt;declarator&lt;/a&gt; has the form.</source>
          <target state="translated">Объявление указателя любое простое заявление которого &lt;a href=&quot;declarations&quot;&gt;описатель&lt;/a&gt; имеет форму.</target>
        </trans-unit>
        <trans-unit id="e616d2d8a65fe8ffec77841c511375e1b8f9b0c3" translate="yes" xml:space="preserve">
          <source>A pointer or a reference to the current element.</source>
          <target state="translated">Указатель или ссылка на текущий элемент.</target>
        </trans-unit>
        <trans-unit id="76ac2aea4079c4a955b7660eae02edd433a9fd7c" translate="yes" xml:space="preserve">
          <source>A pointer or reference to the current match.</source>
          <target state="translated">Указатель или ссылка на текущее совпадение.</target>
        </trans-unit>
        <trans-unit id="ab95db86866612e103ecab472411fe9d5d6b7a23" translate="yes" xml:space="preserve">
          <source>A pointer that points to an object</source>
          <target state="translated">Указатель,указывающий на объект</target>
        </trans-unit>
        <trans-unit id="4c96343afd2f0777da9cdc63088d337b0fc36123" translate="yes" xml:space="preserve">
          <source>A pointer to (possibly &lt;a href=&quot;cv&quot;&gt;cv&lt;/a&gt;-qualified) &lt;code&gt;void&lt;/code&gt; cannot be dereferenced. Pointers to other incomplete types can be dereferenced, but the resulting lvalue can only be used in contexts that allow an lvalue of incomplete type, e.g. when initializing a reference.</source>
          <target state="translated">Указатель на (возможно, &lt;a href=&quot;cv&quot;&gt;cv-&lt;/a&gt; квалифицированный) &lt;code&gt;void&lt;/code&gt; не может быть разыменован. Указатели на другие неполные типы могут быть разыменованы, но результирующее lvalue может использоваться только в контекстах, которые допускают lvalue неполного типа, например, при инициализации ссылки.</target>
        </trans-unit>
        <trans-unit id="d01181d4498df4cf0f8003b09ba8e09b3c553181" translate="yes" xml:space="preserve">
          <source>A pointer to &lt;code&gt;void&lt;/code&gt; cannot be deleted because it is not a pointer to a complete object type.</source>
          <target state="translated">Указатель на &lt;code&gt;void&lt;/code&gt; нельзя удалить, поскольку он не является указателем на полный тип объекта.</target>
        </trans-unit>
        <trans-unit id="9f73f5e3d4de4e157b8dccf9da808fedaf2b59de" translate="yes" xml:space="preserve">
          <source>A pointer to a standard-layout class may be converted (with reinterpret_cast) to a pointer to its first non-static data member and vice versa.</source>
          <target state="translated">Указатель на класс стандартной раскладки может быть преобразован (с помощью reinterpret_cast)в указатель на его первый нестатический член данных и наоборот.</target>
        </trans-unit>
        <trans-unit id="705e66bb80cbfe8e2e8b61352ddc175ed95890e9" translate="yes" xml:space="preserve">
          <source>A pointer to allocated storage of at least &lt;code&gt;bytes&lt;/code&gt; bytes in size, aligned to the specified &lt;code&gt;alignment&lt;/code&gt; if such alignment is supported, and to &lt;code&gt;alignof(&lt;a href=&quot;../../types/max_align_t&quot;&gt;std::max_align_t&lt;/a&gt;)&lt;/code&gt; otherwise.</source>
          <target state="translated">Указатель на выделенное хранилище размером не менее &lt;code&gt;bytes&lt;/code&gt; байтах, выровненное по указанному &lt;code&gt;alignment&lt;/code&gt; если такое выравнивание поддерживается, и к &lt;code&gt;alignof(&lt;a href=&quot;../../types/max_align_t&quot;&gt;std::max_align_t&lt;/a&gt;)&lt;/code&gt; в противном случае.</target>
        </trans-unit>
        <trans-unit id="a9e5f21a34ce522aab5ca357e2281d794f6f56ab" translate="yes" xml:space="preserve">
          <source>A pointer to an element of an array satisfies all requirements of LegacyContiguousIterator.</source>
          <target state="translated">Указатель на элемент массива удовлетворяет всем требованиям LegacyContiguousIterator.</target>
        </trans-unit>
        <trans-unit id="2dabfa7c1aee6ff19a8d014db29f4e03389ef1ab" translate="yes" xml:space="preserve">
          <source>A pointer to an element of an array satisfies all requirements of LegacyRandomAccessIterator.</source>
          <target state="translated">Указатель на элемент массива удовлетворяет всем требованиям LegacyRandomAccessIterator.</target>
        </trans-unit>
        <trans-unit id="bf53771350311775a7859918261dd7a4cabe6a6f" translate="yes" xml:space="preserve">
          <source>A pointer to an object of standard-layout class type can be &lt;a href=&quot;reinterpret_cast&quot;&gt;reinterpret_cast&lt;/a&gt; to pointer to its first non-static non-bitfield data member (if it has non-static data members) or otherwise any of its base class subobjects (if it has any), and vice versa. In other words, padding is not allowed before the first data member of a standard-layout type. Note that &lt;a href=&quot;reinterpret_cast#Type_aliasing&quot;&gt;strict aliasing&lt;/a&gt; rules still apply to the result of such cast.</source>
          <target state="translated">Указатель на объект типа класса стандартной компоновки может быть &lt;a href=&quot;reinterpret_cast&quot;&gt;reinterpret_cast&lt;/a&gt; для указания на его первый нестатический элемент данных, не являющийся битовым полем (если он имеет нестатические члены-данные), или иным образом любой из его подобъектов базового класса (если он имеет какой-либо ), и наоборот. Другими словами, заполнение недопустимо перед первым элементом данных типа стандартной компоновки. Обратите внимание, что &lt;a href=&quot;reinterpret_cast#Type_aliasing&quot;&gt;строгие&lt;/a&gt; правила псевдонимов все еще применяются к результату такого приведения.</target>
        </trans-unit>
        <trans-unit id="c433adb64c0845bb1339f1da97f3f437a44c4418" translate="yes" xml:space="preserve">
          <source>A pointer to function can be initialized with an address of a non-member function or a static member function. Because of the &lt;a href=&quot;implicit_cast&quot;&gt;function-to-pointer&lt;/a&gt; implicit conversion, the address-of operator is optional:</source>
          <target state="translated">Указатель на функцию можно инициализировать с помощью адреса функции, не являющейся членом или статической функции-члена. Из &lt;a href=&quot;implicit_cast&quot;&gt;-за&lt;/a&gt; неявного преобразования функции в указатель оператор address-of является необязательным:</target>
        </trans-unit>
        <trans-unit id="fee552ad23a470ee0488c57dc099836dec669c19" translate="yes" xml:space="preserve">
          <source>A pointer to function can be used as the left-hand operand of the &lt;a href=&quot;operator_other&quot;&gt;function call operator&lt;/a&gt;, this invokes the pointed-to function:</source>
          <target state="translated">Указатель на функцию можно использовать в качестве левого операнда &lt;a href=&quot;operator_other&quot;&gt;оператора вызова функции&lt;/a&gt; , это вызывает указанную функцию:</target>
        </trans-unit>
        <trans-unit id="099c10c4969aca0ed60f063fd0510673f35f2754" translate="yes" xml:space="preserve">
          <source>A pointer to function may be initialized from an overload set which may include functions, function template specializations, and function templates, if only one overload matches the type of the pointer (see &lt;a href=&quot;overloaded_address&quot;&gt;address of an overloaded function&lt;/a&gt; for more detail):</source>
          <target state="translated">Указатель на функцию может быть инициализирован из набора перегрузок, который может включать функции, специализации шаблонов функций и шаблоны функций, если только одна перегрузка соответствует типу указателя ( более подробно см. &lt;a href=&quot;overloaded_address&quot;&gt;Адрес перегруженной функции&lt;/a&gt; ):</target>
        </trans-unit>
        <trans-unit id="8f1bfae7aedabc69e7b7058df026de700a35db9f" translate="yes" xml:space="preserve">
          <source>A pointer to non-array object is treated as a pointer to the first element of an array with size 1.</source>
          <target state="translated">Указатель на не массивный объект рассматривается как указатель на первый элемент массива с размером 1.</target>
        </trans-unit>
        <trans-unit id="cb38a2b02a68bb7fc07ad522e4391fd787512883" translate="yes" xml:space="preserve">
          <source>A pointer to non-static member function &lt;code&gt;f&lt;/code&gt; which is a member of class &lt;code&gt;C&lt;/code&gt; can be initialized with the expression &lt;code&gt;&amp;amp;C::f&lt;/code&gt; exactly. Expressions such as &lt;code&gt;&amp;amp;(C::f)&lt;/code&gt; or &lt;code&gt;&amp;amp;f&lt;/code&gt; inside C's member function do not form pointers to member functions.</source>
          <target state="translated">Указатель на нестатическую функцию-член &lt;code&gt;f&lt;/code&gt; , которая является членом класса &lt;code&gt;C&lt;/code&gt; , может быть точно инициализирован выражением &lt;code&gt;&amp;amp;C::f&lt;/code&gt; . Такие выражения, как &lt;code&gt;&amp;amp;(C::f)&lt;/code&gt; или &lt;code&gt;&amp;amp;f&lt;/code&gt; внутри функции-члена C, не образуют указатели на функции-члены.</target>
        </trans-unit>
        <trans-unit id="53cf9e67e880a7f25905f2424504dd5b25bc02f1" translate="yes" xml:space="preserve">
          <source>A pointer to non-static member object &lt;code&gt;m&lt;/code&gt; which is a member of class &lt;code&gt;C&lt;/code&gt; can be initialized with the expression &lt;code&gt;&amp;amp;C::m&lt;/code&gt; exactly. Expressions such as &lt;code&gt;&amp;amp;(C::m)&lt;/code&gt; or &lt;code&gt;&amp;amp;m&lt;/code&gt; inside C's member function do not form pointers to members.</source>
          <target state="translated">Указатель на нестатический членский объект &lt;code&gt;m&lt;/code&gt; , который является членом класса &lt;code&gt;C&lt;/code&gt; , может быть точно инициализирован выражением &lt;code&gt;&amp;amp;C::m&lt;/code&gt; . Такие выражения, как &lt;code&gt;&amp;amp;(C::m)&lt;/code&gt; или &lt;code&gt;&amp;amp;m&lt;/code&gt; внутри функции-члена C, не образуют указатели на члены.</target>
        </trans-unit>
        <trans-unit id="4605388fefbc6745ad5fb4ab3501853f9b2e59ca" translate="yes" xml:space="preserve">
          <source>A pointer to object can be initialized with the return value of the &lt;a href=&quot;operator_member_access&quot;&gt;address-of operator&lt;/a&gt; applied to any expression of object type, including another pointer type:</source>
          <target state="translated">Указатель на объект может быть инициализирован возвращаемым значением &lt;a href=&quot;operator_member_access&quot;&gt;оператора address-of,&lt;/a&gt; примененным к любому выражению типа объекта, включая другой тип указателя:</target>
        </trans-unit>
        <trans-unit id="cb0b45c2fb8692553e4131bcd61d0db96c449b86" translate="yes" xml:space="preserve">
          <source>A pointer to the &lt;code&gt;std::chrono::time_zone&lt;/code&gt; in this database that represents the local time zone of the computer.</source>
          <target state="translated">Указатель на &lt;code&gt;std::chrono::time_zone&lt;/code&gt; в этой базе данных, который представляет местный часовой пояс компьютера.</target>
        </trans-unit>
        <trans-unit id="109ab033a06ddd191eedf4e6243ebdbfa781c50d" translate="yes" xml:space="preserve">
          <source>A pointer to the &lt;code&gt;std::chrono::time_zone&lt;/code&gt; in this database that represents the time zone designated by &lt;code&gt;tz_name&lt;/code&gt;.</source>
          <target state="translated">Указатель на &lt;code&gt;std::chrono::time_zone&lt;/code&gt; в этой базе данных, который представляет часовой пояс, обозначенный как &lt;code&gt;tz_name&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7186294424331f7f2da77bb5b939c2393a738e08" translate="yes" xml:space="preserve">
          <source>A pointer to the allocated and constructed object.</source>
          <target state="translated">Указатель на выделенный и построенный объект.</target>
        </trans-unit>
        <trans-unit id="90fab4aff09dede56fdb6d84059c3624b3b99e4c" translate="yes" xml:space="preserve">
          <source>A pointer to the allocated storage.</source>
          <target state="translated">Указатель на выделенное хранилище.</target>
        </trans-unit>
        <trans-unit id="84ca1216b138fa1171353f37562e84b5694e8e55" translate="yes" xml:space="preserve">
          <source>A pointer to the beginning of the sequence.</source>
          <target state="translated">Указатель на начало последовательности.</target>
        </trans-unit>
        <trans-unit id="34743a200c5640f215061cfae8958c69a6b3ced4" translate="yes" xml:space="preserve">
          <source>A pointer to the block of memory containing the elements of the container.</source>
          <target state="translated">Указатель на блок памяти,содержащий элементы контейнера.</target>
        </trans-unit>
        <trans-unit id="a8d3f2979c65ac771376f7686ffa1017464bd622" translate="yes" xml:space="preserve">
          <source>A pointer to the first character in the range specified by &lt;code&gt;[p, p + count)&lt;/code&gt; that compares equal to &lt;code&gt;ch&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt; if not found.</source>
          <target state="translated">Указатель на первый символ в диапазоне, указанном &lt;code&gt;[p, p + count)&lt;/code&gt; который сравнивается равным &lt;code&gt;ch&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt; , если не найден.</target>
        </trans-unit>
        <trans-unit id="85748d7d2f8b08c1130cce69c2693bdbf36686d5" translate="yes" xml:space="preserve">
          <source>A pointer to the first element in the classification table (which an array of size &lt;code&gt;std::ctype&amp;lt;char&amp;gt;::table_size&lt;/code&gt;).</source>
          <target state="translated">Указатель на первый элемент в таблице классификации (который является массивом размера &lt;code&gt;std::ctype&amp;lt;char&amp;gt;::table_size&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="6d6f48b5d05090c0288e98d43d8a863e8b2c04b8" translate="yes" xml:space="preserve">
          <source>A pointer to the owned deleter or &lt;code&gt;nullptr&lt;/code&gt;. The returned pointer is valid at least as long as there remains at least one &lt;code&gt;shared_ptr&lt;/code&gt; instance that owns it.</source>
          <target state="translated">Указатель на принадлежащем Deleter или &lt;code&gt;nullptr&lt;/code&gt; . Возвращенный указатель действителен, по крайней мере, до тех пор, пока остается хотя бы один экземпляр &lt;code&gt;shared_ptr&lt;/code&gt; , которому он принадлежит.</target>
        </trans-unit>
        <trans-unit id="b50fe0059480635f66a814d6c4000336f99ae375" translate="yes" xml:space="preserve">
          <source>A pointer to the stored function if &lt;code&gt;target_type() == typeid(T)&lt;/code&gt;, otherwise a null pointer.</source>
          <target state="translated">Указатель на сохраненную функцию, если &lt;code&gt;target_type() == typeid(T)&lt;/code&gt; , в противном случае - нулевой указатель.</target>
        </trans-unit>
        <trans-unit id="fe7ecdbac553ec91128d6f72f68f35f00624e049" translate="yes" xml:space="preserve">
          <source>A pointer to the underlying character array.</source>
          <target state="translated">Указатель на лежащий в основе символьного массива.</target>
        </trans-unit>
        <trans-unit id="890ea029c831a738d852daab1692736f467e7a47" translate="yes" xml:space="preserve">
          <source>A pointer to the underlying character storage.</source>
          <target state="translated">Указатель на хранилище символов.</target>
        </trans-unit>
        <trans-unit id="7a202c804155efff22e9a4e471438c6dbf2d98d3" translate="yes" xml:space="preserve">
          <source>A possible implementation of this class is.</source>
          <target state="translated">Возможна реализация этого класса.</target>
        </trans-unit>
        <trans-unit id="bc77f50c4833701227ea3422c38b612aa4fdfe9d" translate="yes" xml:space="preserve">
          <source>A possible use for &lt;code&gt;std::condition_variable_any&lt;/code&gt; with custom &lt;a href=&quot;../named_req/lockable&quot;&gt;Lockable&lt;/a&gt; types is to provide convenient interruptible waits: the custom lock operation would both lock the associated mutex as expected, and also perform the necessary setup to notify this condition variable when the interrupting signal is received.&lt;sup id=&quot;cite_ref-1&quot;&gt;&lt;a href=&quot;condition_variable_any#cite_note-1&quot;&gt;[1]&lt;/a&gt;&lt;/sup&gt;</source>
          <target state="translated">Возможное использование &lt;code&gt;std::condition_variable_any&lt;/code&gt; с пользовательскими типами &lt;a href=&quot;../named_req/lockable&quot;&gt;Lockable&lt;/a&gt; - обеспечить удобные прерывания ожидания: пользовательская операция блокировки будет блокировать связанный мьютекс, как ожидается, а также выполнить необходимую настройку, чтобы уведомить эту переменную условия при получении сигнала прерывания. &lt;sup id=&quot;cite_ref-1&quot;&gt;&lt;a href=&quot;condition_variable_any#cite_note-1&quot;&gt;[1]&lt;/a&gt;&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="0c4ca9f04ce9075912ba0b19bfb872f73c52baa7" translate="yes" xml:space="preserve">
          <source>A possibly const value of type &lt;code&gt;X::key_compare&lt;/code&gt;</source>
          <target state="translated">Возможно постоянное значение типа &lt;code&gt;X::key_compare&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7916eb952414b9a1c31b5a2dafada3b876f5ad6e" translate="yes" xml:space="preserve">
          <source>A precondition of this function is that &lt;code&gt;[first, n_first)&lt;/code&gt; and &lt;code&gt;[n_first, last)&lt;/code&gt; are valid ranges.</source>
          <target state="translated">Предварительным условием этой функции является то, что &lt;code&gt;[first, n_first)&lt;/code&gt; и &lt;code&gt;[n_first, last)&lt;/code&gt; являются допустимыми диапазонами.</target>
        </trans-unit>
        <trans-unit id="b6b696e16fd55d74c0cbd8840d4be4cbde76e009" translate="yes" xml:space="preserve">
          <source>A primitive static vector class, demonstrating creation, access, and destruction of objects in aligned storage.</source>
          <target state="translated">Примитивный статический векторный класс,демонстрирующий создание,доступ и уничтожение объектов в выровненном хранилище.</target>
        </trans-unit>
        <trans-unit id="9f03356025d9d886dc6751b026e010eaa4c75c65" translate="yes" xml:space="preserve">
          <source>A priority queue is a container adaptor that provides constant time lookup of the largest (by default) element, at the expense of logarithmic insertion and extraction.</source>
          <target state="translated">Очередь приоритетов-это контейнерный адаптер,обеспечивающий постоянный поиск по времени самого большого (по умолчанию)элемента за счет логарифмической вставки и извлечения.</target>
        </trans-unit>
        <trans-unit id="aa89f91f3d3f3e8b505f31100bf86fa2ca7b655c" translate="yes" xml:space="preserve">
          <source>A private member of a class can only be accessed by the members and friends of that class, regardless of whether the members are on the same or different instances:</source>
          <target state="translated">Доступ к закрытому члену класса возможен только членам и друзьям этого класса,независимо от того,находятся ли члены в одном и том же или в разных экземплярах:</target>
        </trans-unit>
        <trans-unit id="da9d03016a24905e53207d2ba428a1b8e9a9aaf7" translate="yes" xml:space="preserve">
          <source>A program is not required to call the destructor of an object to end its lifetime if the object is &lt;a href=&quot;destructor#Trivial_destructor&quot;&gt;trivially-destructible&lt;/a&gt; or if the program does not rely on the side effects of the destructor. However, if a program ends the lifetime of an non-trivial object explicitly, it must ensure that a new object of the same type is constructed in-place (e.g. via placement new) before the destructor may be called implicitly, i.e. due to scope exit or exception for automatic objects, due to thread exit for thread-local objects, or due to program exit for static objects; otherwise the behavior is undefined.</source>
          <target state="translated">Программе не требуется вызывать деструктор объекта, чтобы закончить его время жизни, если объект является &lt;a href=&quot;destructor#Trivial_destructor&quot;&gt;тривиально разрушаемым&lt;/a&gt; или если программа не полагается на побочные эффекты деструктора. Однако, если программа явно завершает время жизни нетривиального объекта, она должна убедиться, что новый объект того же типа создан на месте (например, посредством размещения нового), прежде чем деструктор может быть вызван неявно, то есть из-за области видимости. выход или исключение для автоматических объектов, из-за выхода потока для локальных объектов потока или из-за выхода программы для статических объектов; в противном случае поведение не определено.</target>
        </trans-unit>
        <trans-unit id="03089f15ead7ca5ed65d816afebaddda671b3974" translate="yes" xml:space="preserve">
          <source>A program may be translated with one of three</source>
          <target state="translated">Программа может быть переведена с помощью одного из трех</target>
        </trans-unit>
        <trans-unit id="66c3ecf22ff81745bed14260f746ab81e7c0d0a2" translate="yes" xml:space="preserve">
          <source>A program may be translated with one of two</source>
          <target state="translated">Программа может быть переведена с помощью одного из двух</target>
        </trans-unit>
        <trans-unit id="5a764d00cd6118dc37146370c6388538e41d1085" translate="yes" xml:space="preserve">
          <source>A program may not specialize &lt;code&gt;basic_common_reference&lt;/code&gt; on the third or fourth parameters, nor may it specialize &lt;code&gt;common_reference&lt;/code&gt; itself. A program that adds specializations in violation of these rules has undefined behavior.</source>
          <target state="translated">Программа не может специализировать &lt;code&gt;basic_common_reference&lt;/code&gt; на третьем или четвертом параметрах, а также не может специализироваться на самой &lt;code&gt;common_reference&lt;/code&gt; . Программа, которая добавляет специализации в нарушение этих правил, имеет неопределенное поведение.</target>
        </trans-unit>
        <trans-unit id="17328f55bfa3f5f5c88fbe4c9f98cf4b5f272bc0" translate="yes" xml:space="preserve">
          <source>A program may specialize &lt;code&gt;basic_common_reference&amp;lt;T, U, TQual, UQual&amp;gt;&lt;/code&gt; on the first two parameters &lt;code&gt;T&lt;/code&gt; and &lt;code&gt;U&lt;/code&gt; if &lt;code&gt;&lt;a href=&quot;is_same&quot;&gt;std::is_same&lt;/a&gt;&amp;lt;T, &lt;a href=&quot;decay&quot;&gt;std::decay_t&lt;/a&gt;&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;is_same&quot;&gt;std::is_same&lt;/a&gt;&amp;lt;U, &lt;a href=&quot;decay&quot;&gt;std::decay_t&lt;/a&gt;&amp;lt;U&amp;gt;&amp;gt;&lt;/code&gt; are both true and at least one of them depends on a program-defined type.</source>
          <target state="translated">Программа может специализировать &lt;code&gt;basic_common_reference&amp;lt;T, U, TQual, UQual&amp;gt;&lt;/code&gt; для первых двух параметров &lt;code&gt;T&lt;/code&gt; и &lt;code&gt;U&lt;/code&gt; , если &lt;code&gt;&lt;a href=&quot;is_same&quot;&gt;std::is_same&lt;/a&gt;&amp;lt;T, &lt;a href=&quot;decay&quot;&gt;std::decay_t&lt;/a&gt;&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;is_same&quot;&gt;std::is_same&lt;/a&gt;&amp;lt;U, &lt;a href=&quot;decay&quot;&gt;std::decay_t&lt;/a&gt;&amp;lt;U&amp;gt;&amp;gt;&lt;/code&gt; оба имеют значение true, и хотя бы один из них зависит от типа, определенного программой.</target>
        </trans-unit>
        <trans-unit id="8e61a356e3234eed06fa2f0f5dee899601ee82c6" translate="yes" xml:space="preserve">
          <source>A program may specialize &lt;code&gt;clock_time_conversion&lt;/code&gt; if at least one of the template parameters is a user-defined clock type.</source>
          <target state="translated">Программа может специализировать &lt;code&gt;clock_time_conversion&lt;/code&gt; , если хотя бы один из параметров шаблона является определяемым пользователем типом часов.</target>
        </trans-unit>
        <trans-unit id="97b63352c2d736a021395385f10f9bb467d6e3fd" translate="yes" xml:space="preserve">
          <source>A program shall contain a global function named &lt;code&gt;main&lt;/code&gt;, which is the designated start of the program. It shall have one of the following forms:</source>
          <target state="translated">Программа должна содержать глобальную функцию с именем &lt;code&gt;main&lt;/code&gt; , которая является назначенным началом программы. Он должен иметь одну из следующих форм:</target>
        </trans-unit>
        <trans-unit id="5437280a6191901c16079ac8f80aff7f070d8c2f" translate="yes" xml:space="preserve">
          <source>A program that adds &lt;code&gt;common_type&lt;/code&gt; specializations in violation of these rules has undefined behavior.</source>
          <target state="translated">Программа, которая добавляет специализации &lt;code&gt;common_type&lt;/code&gt; в нарушение этих правил, имеет неопределенное поведение.</target>
        </trans-unit>
        <trans-unit id="7fee44e17e3a13581354a330d85e96728e00f4bd" translate="yes" xml:space="preserve">
          <source>A protected member of a class &lt;code&gt;Base&lt;/code&gt; can only be accessed.</source>
          <target state="translated">Доступ к защищенному члену класса &lt;code&gt;Base&lt;/code&gt; возможен только.</target>
        </trans-unit>
        <trans-unit id="87b080a926e158a236034e081054063e31488155" translate="yes" xml:space="preserve">
          <source>A prvalue cannot be &lt;a href=&quot;objects#Polymorphic_objects&quot;&gt;polymorphic&lt;/a&gt;: the &lt;a href=&quot;type-id#Dynamic_type&quot;&gt;dynamic type&lt;/a&gt; of the object it identifies is always the type of the expression.</source>
          <target state="translated">Значение prvalue не может быть &lt;a href=&quot;objects#Polymorphic_objects&quot;&gt;полиморфным&lt;/a&gt; : &lt;a href=&quot;type-id#Dynamic_type&quot;&gt;динамический тип&lt;/a&gt; идентифицируемого объекта всегда является типом выражения.</target>
        </trans-unit>
        <trans-unit id="948c7440ba50ed3eb424033ba764365ffa6afd0f" translate="yes" xml:space="preserve">
          <source>A prvalue cannot have &lt;a href=&quot;abstract_class&quot;&gt;abstract class type&lt;/a&gt; or an array thereof.</source>
          <target state="translated">Prvalue не может иметь &lt;a href=&quot;abstract_class&quot;&gt;абстрактный тип класса&lt;/a&gt; или его массив.</target>
        </trans-unit>
        <trans-unit id="9922e8eeb154c6c0744ee9e4ba026d8fb5b557df" translate="yes" xml:space="preserve">
          <source>A prvalue cannot have &lt;a href=&quot;type-id#Incomplete_type&quot;&gt;incomplete type&lt;/a&gt; (except for type void, see below, or when used in &lt;a href=&quot;decltype&quot;&gt;decltype specifier&lt;/a&gt;)</source>
          <target state="translated">Значение типа prvalue не может быть &lt;a href=&quot;type-id#Incomplete_type&quot;&gt;неполным&lt;/a&gt; (за исключением типа void, см. Ниже или при использовании в &lt;a href=&quot;decltype&quot;&gt;спецификаторе decltype&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="89adcc7246c411786e22055f1d4bc6dc797ab523" translate="yes" xml:space="preserve">
          <source>A prvalue of integer or unscoped enumeration type can be converted to a prvalue of any floating-point type. If the value cannot be represented correctly, it is implementation defined whether the closest higher or the closest lower representable value will be selected, although if IEEE arithmetic is supported, rounding defaults &lt;a href=&quot;../numeric/fenv/fe_round&quot;&gt;to nearest&lt;/a&gt;. If the value cannot fit into the destination type, the behavior is undefined. If the source type is &lt;code&gt;bool&lt;/code&gt;, the value &lt;code&gt;false&lt;/code&gt; is converted to zero, and the value &lt;code&gt;true&lt;/code&gt; is converted to one.</source>
          <target state="translated">Значение типа нумерации типа integer или unscoped может быть преобразовано в значение типа с плавающей запятой. Если значение не может быть представлено правильно, это определяется реализацией, будет ли выбрано самое близкое более высокое или самое близкое нижнее представимое значение, хотя, если поддерживается арифметика IEEE, округление по умолчанию &lt;a href=&quot;../numeric/fenv/fe_round&quot;&gt;до ближайшего&lt;/a&gt; . Если значение не может вписаться в тип назначения, поведение не определено. Если тип источника - &lt;code&gt;bool&lt;/code&gt; , значение &lt;code&gt;false&lt;/code&gt; преобразуется в ноль, а значение &lt;code&gt;true&lt;/code&gt; преобразуется в единицу.</target>
        </trans-unit>
        <trans-unit id="1cc331b941fd7c1d4179b58d5442419123db000e" translate="yes" xml:space="preserve">
          <source>A prvalue of type pointer to member of cv-qualified type &lt;code&gt;T&lt;/code&gt; in class &lt;code&gt;X&lt;/code&gt; can be converted to a prvalue pointer to member of more cv-qualified type &lt;code&gt;T&lt;/code&gt; in class &lt;code&gt;X&lt;/code&gt;.</source>
          <target state="translated">Prvalue указателя типа члену CV-квалифицированного типа &lt;code&gt;T&lt;/code&gt; в классе &lt;code&gt;X&lt;/code&gt; может быть преобразован в указатель на prvalue членом более квалифицированного CV-типа &lt;code&gt;T&lt;/code&gt; в классе &lt;code&gt;X&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f3def19238902e53ffc0e7c4199b58d0948a3fce" translate="yes" xml:space="preserve">
          <source>A prvalue of type pointer to non-throwing member function can be converted to a prvalue pointer to potentially-throwing member function.</source>
          <target state="translated">Значение указателя типа к неперебрасывающей функции-члену может быть преобразовано в указатель на значение,которое может быть преобразовано в потенциально перебрасывающую функцию-члену.</target>
        </trans-unit>
        <trans-unit id="e4ca3c60807a21440fb680870f4faa7d3f0b6ab5" translate="yes" xml:space="preserve">
          <source>A prvalue pointer to a (optionally cv-qualified) derived class type can be converted to a prvalue pointer to its (identically cv-qualified) base class. If the base class is inaccessible or ambiguous, the conversion is ill-formed (won't compile). The result of the conversion is a pointer to the base class subobject within the pointed-to object. The null pointer value is converted to the null pointer value of the destination type.</source>
          <target state="translated">Указатель на значение принтера к (опционально cv-qualified)производному типу класса может быть преобразован в указатель на значение принтера к его (идентичному cv-qualified)базовому классу.Если базовый класс недоступен или неоднозначен,то преобразование происходит плохо (не будет компилироваться).Результатом преобразования является указатель на подобъект базового класса внутри указанного объекта.Нулевое значение указателя преобразуется в нулевое значение указателя типа назначения.</target>
        </trans-unit>
        <trans-unit id="b68c522f33b2f282c51184b2111938ab2a45c6a2" translate="yes" xml:space="preserve">
          <source>A pseudo-random number in [&lt;code&gt;min()&lt;/code&gt;, &lt;code&gt;max()&lt;/code&gt;].</source>
          <target state="translated">Псевдослучайное число в [ &lt;code&gt;min()&lt;/code&gt; , &lt;code&gt;max()&lt;/code&gt; ].</target>
        </trans-unit>
        <trans-unit id="518c2995944086d5bc64a89e68ef8ff2eda028d4" translate="yes" xml:space="preserve">
          <source>A public member of a class is accessible everywhere.</source>
          <target state="translated">Общественный член класса доступен везде.</target>
        </trans-unit>
        <trans-unit id="a237039e9334b0659fe3de5e7abb2fcf04116a22" translate="yes" xml:space="preserve">
          <source>A pure virtual function is a &lt;a href=&quot;virtual&quot;&gt;virtual function&lt;/a&gt; whose &lt;a href=&quot;function&quot;&gt;declarator&lt;/a&gt; has the following syntax:</source>
          <target state="translated">Чистая виртуальная функция - это &lt;a href=&quot;virtual&quot;&gt;виртуальная функция, у&lt;/a&gt; которой &lt;a href=&quot;function&quot;&gt;объявитель&lt;/a&gt; имеет следующий синтаксис:</target>
        </trans-unit>
        <trans-unit id="d2a131b189a54243081396040bed210dca58fe18" translate="yes" xml:space="preserve">
          <source>A qualified name that appears in</source>
          <target state="translated">Квалифицированное имя,которое появляется в</target>
        </trans-unit>
        <trans-unit id="f00c1c26af032f164f98a00ceb65858c99c608e2" translate="yes" xml:space="preserve">
          <source>A qualified name that is used as a &lt;a href=&quot;declarations#Specifiers&quot;&gt;declaration specifier&lt;/a&gt; in the (top-level) decl-specifier-seq of:</source>
          <target state="translated">Полное имя, которое используется в качестве &lt;a href=&quot;declarations#Specifiers&quot;&gt;спецификатора объявления&lt;/a&gt; в (на верхнем уровне) decl-specier-seq из:</target>
        </trans-unit>
        <trans-unit id="234e75018942daa7d9ddc6b7ab239081b75bbb61" translate="yes" xml:space="preserve">
          <source>A random number distribution post-processes the output of a URBG in such a way that resulting output is distributed according to a defined statistical probability density function.</source>
          <target state="translated">Пост-процесс распределения случайных чисел обрабатывает вывод URBG таким образом,что результирующий вывод распределяется в соответствии с определенной статистической функцией плотности вероятности.</target>
        </trans-unit>
        <trans-unit id="63c005a6e5fbfc7dc8af621e2d17685667135352" translate="yes" xml:space="preserve">
          <source>A random number engine is a function object returning unsigned integer values such that each value in the range of possible results has (ideally) equal probability.</source>
          <target state="translated">Движок случайных чисел-это объект функции,возвращающий беззнаковые целочисленные значения таким образом,что каждое значение в диапазоне возможных результатов имеет (в идеале)равную вероятность.</target>
        </trans-unit>
        <trans-unit id="218114a7bf5a72fb79f4bcfba1ca863f66fc080d" translate="yes" xml:space="preserve">
          <source>A random number generator may satisfy &lt;code&gt;Invocable&lt;/code&gt; but cannot satisfy &lt;code&gt;RegularInvocable&lt;/code&gt; (&lt;a href=&quot;https://xkcd.com/221/&quot;&gt;comical&lt;/a&gt;&lt;a href=&quot;http://dilbert.com/strip/2001-10-25&quot;&gt;ones&lt;/a&gt; excluded).</source>
          <target state="translated">Генератор случайных чисел может удовлетворить &lt;code&gt;Invocable&lt;/code&gt; , но не может удовлетворить &lt;code&gt;RegularInvocable&lt;/code&gt; ( &lt;a href=&quot;https://xkcd.com/221/&quot;&gt;комичные из &lt;/a&gt;&lt;a href=&quot;http://dilbert.com/strip/2001-10-25&quot;&gt;них&lt;/a&gt; исключены).</target>
        </trans-unit>
        <trans-unit id="c8740cda35197e3b7986bfb9d3958a23da53121b" translate="yes" xml:space="preserve">
          <source>A random number uniformly distributed in [&lt;code&gt;min()&lt;/code&gt;, &lt;code&gt;max()&lt;/code&gt;].</source>
          <target state="translated">Случайное число, равномерно распределенное в [ &lt;code&gt;min()&lt;/code&gt; , &lt;code&gt;max()&lt;/code&gt; ].</target>
        </trans-unit>
        <trans-unit id="c6c8fb5e09b78d7ba8993d92c01b80b6ecf577e7" translate="yes" xml:space="preserve">
          <source>A range adaptor that returns a &lt;a href=&quot;view&quot;&gt;&lt;code&gt;View&lt;/code&gt;&lt;/a&gt; that includes all elements of its &lt;a href=&quot;range&quot;&gt;&lt;code&gt;Range&lt;/code&gt;&lt;/a&gt; argument.</source>
          <target state="translated">Адаптер диапазона , который возвращает &lt;a href=&quot;view&quot;&gt; &lt;code&gt;View&lt;/code&gt; &lt;/a&gt; , который включает в себя все элементы своего &lt;a href=&quot;range&quot;&gt; &lt;code&gt;Range&lt;/code&gt; &lt;/a&gt; аргумента.</target>
        </trans-unit>
        <trans-unit id="4b161bf3c0670ce52a5c8049eec7a861c20295c5" translate="yes" xml:space="preserve">
          <source>A raw pointer of the type &lt;code&gt;element_type*&lt;/code&gt; that references the same memory location as the argument &lt;code&gt;p&lt;/code&gt;.</source>
          <target state="translated">Необработанный указатель типа &lt;code&gt;element_type*&lt;/code&gt; который ссылается на ту же область памяти, что и аргумент &lt;code&gt;p&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a987fe5116d16dac6c986d15e44866f1f2950023" translate="yes" xml:space="preserve">
          <source>A read-modify-write operation with this memory order is both an</source>
          <target state="translated">Операция чтения-модификации-записи с этим порядком памяти является одновременно и</target>
        </trans-unit>
        <trans-unit id="e3862e525cd9728a75bb86198e817c0be834e74b" translate="yes" xml:space="preserve">
          <source>A reference is required to be initialized to refer to a valid object or function: see &lt;a href=&quot;reference_initialization&quot;&gt;reference initialization&lt;/a&gt;.</source>
          <target state="translated">Ссылка должна быть инициализирована для ссылки на действительный объект или функцию: см. &lt;a href=&quot;reference_initialization&quot;&gt;Инициализацию ссылки&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b8168313a358c53144732f59b7b55f79bc0d83aa" translate="yes" xml:space="preserve">
          <source>A reference to &lt;code&gt;OuterAlloc&lt;/code&gt;.</source>
          <target state="translated">Ссылка на &lt;code&gt;OuterAlloc&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="804797fdb54fd58e448bcbbb5edeb1965dd46ac6" translate="yes" xml:space="preserve">
          <source>A reference to &lt;code&gt;T&lt;/code&gt; can be initialized with an object of type &lt;code&gt;T&lt;/code&gt;, a function of type &lt;code&gt;T&lt;/code&gt;, or an object implicitly convertible to &lt;code&gt;T&lt;/code&gt;. Once initialized, a reference cannot be changed to refer to another object.</source>
          <target state="translated">Ссылка на &lt;code&gt;T&lt;/code&gt; может быть инициализирована с объектом типа &lt;code&gt;T&lt;/code&gt; , в зависимости от типа &lt;code&gt;T&lt;/code&gt; или объект неявно , конвертируемого в &lt;code&gt;T&lt;/code&gt; . После инициализации ссылка не может быть изменена для ссылки на другой объект.</target>
        </trans-unit>
        <trans-unit id="96effaa229108956b87eaa0ef7506c4b68779cfb" translate="yes" xml:space="preserve">
          <source>A reference to the &lt;code&gt;Ith&lt;/code&gt; element of &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">Ссылка на &lt;code&gt;Ith&lt;/code&gt; элемент . &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="fed9a57692255e9193120495f8b304740d5643ee" translate="yes" xml:space="preserve">
          <source>A reference to the &lt;code&gt;Ith&lt;/code&gt; element of &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="translated">Ссылка на &lt;code&gt;Ith&lt;/code&gt; элемент &lt;code&gt;s&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8587a8972573baad1abe654df486c02df1c78add" translate="yes" xml:space="preserve">
          <source>A reference to the &lt;code&gt;idx&lt;/code&gt;-th element of the array, i.e., &lt;code&gt;get()[idx]&lt;/code&gt;</source>
          <target state="translated">Ссылка на &lt;code&gt;idx&lt;/code&gt; -й элемент массива, т.е. &lt;code&gt;get()[idx]&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="36d8ef7aa332a08ad1749e9a36b2ab00fe12b221" translate="yes" xml:space="preserve">
          <source>A reference to the &lt;code&gt;idx&lt;/code&gt;-th element of the sequence, i.e., &lt;code&gt;data()[idx]&lt;/code&gt;</source>
          <target state="translated">Ссылка на &lt;code&gt;idx&lt;/code&gt; -й элемент последовательности, т.е. &lt;code&gt;data()[idx]&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="af1efc2484e454ad9728eae87f942a799f403462" translate="yes" xml:space="preserve">
          <source>A reference to the back element.</source>
          <target state="translated">Ссылка на задний элемент.</target>
        </trans-unit>
        <trans-unit id="932b2a1f1d48ceff1483626d393c48deb6ec133d" translate="yes" xml:space="preserve">
          <source>A reference to the contained value.</source>
          <target state="translated">Ссылка на содержащееся значение.</target>
        </trans-unit>
        <trans-unit id="8de78a95776c196427cb50ef2308786df9feaa77" translate="yes" xml:space="preserve">
          <source>A reference to the element at relative location, that is, &lt;code&gt;base()[-n-1]&lt;/code&gt;.</source>
          <target state="translated">Ссылка на элемент в относительном местоположении, то есть &lt;code&gt;base()[-n-1]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ed2f64858c4b136043374a81f773f2bb47825288" translate="yes" xml:space="preserve">
          <source>A reference to the element.</source>
          <target state="translated">Ссылка на элемент.</target>
        </trans-unit>
        <trans-unit id="1b47ff083eea09f7ebfc57e29aa6a19dcffb7f4b" translate="yes" xml:space="preserve">
          <source>A reference to the first element.</source>
          <target state="translated">Ссылка на первый элемент.</target>
        </trans-unit>
        <trans-unit id="a0df3de2b33596434eabf885b30512aa4bd9a7f7" translate="yes" xml:space="preserve">
          <source>A reference to the inner allocator, which is itself a &lt;code&gt;std::scoped_allocator_adaptor&lt;/code&gt;.</source>
          <target state="translated">Ссылка на внутренний распределитель, который сам по себе является &lt;code&gt;std::scoped_allocator_adaptor&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6d12739b00cf675a6ba691cc42cc3b54b7c86c25" translate="yes" xml:space="preserve">
          <source>A reference to the inserted element.</source>
          <target state="translated">Ссылка на вставленный элемент.</target>
        </trans-unit>
        <trans-unit id="9b728bf8ae3f8f1afb3d2c134ee7f6175d648f5b" translate="yes" xml:space="preserve">
          <source>A reference to the new contained object.</source>
          <target state="translated">Ссылка на новый содержащийся объект.</target>
        </trans-unit>
        <trans-unit id="695dad725bff816bf70ec1a1e915658d83c47722" translate="yes" xml:space="preserve">
          <source>A reference to the new contained value.</source>
          <target state="translated">Ссылка на новое содержащееся значение.</target>
        </trans-unit>
        <trans-unit id="1f840389ee6e69a00e4361ae4f5b87b0602e4e15" translate="yes" xml:space="preserve">
          <source>A reference to the selected element of &lt;code&gt;t&lt;/code&gt;.</source>
          <target state="translated">Ссылка на выбранный элемент &lt;code&gt;t&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="215a738f7f92427350a124e8545beaf159690b56" translate="yes" xml:space="preserve">
          <source>A reference to the static object of unspecified runtime type, derived from &lt;code&gt;&lt;a href=&quot;../../error/error_category&quot;&gt;std::error_category&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Ссылка на статический объект неопределенного типа времени выполнения, полученный из &lt;code&gt;&lt;a href=&quot;../../error/error_category&quot;&gt;std::error_category&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2dce474f5e611fdd344ca6f78607a960539b8d24" translate="yes" xml:space="preserve">
          <source>A reference to the static object of unspecified runtime type, derived from &lt;code&gt;&lt;a href=&quot;../error/error_category&quot;&gt;std::error_category&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Ссылка на статический объект неопределенного типа времени выполнения, полученный из &lt;code&gt;&lt;a href=&quot;../error/error_category&quot;&gt;std::error_category&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="52beb0ba5b037a0cd1d9ec162abace30f7074fd0" translate="yes" xml:space="preserve">
          <source>A reference to the static object of unspecified runtime type, derived from &lt;code&gt;&lt;a href=&quot;error_category&quot;&gt;std::error_category&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Ссылка на статический объект неопределенного типа времени выполнения, полученный из &lt;code&gt;&lt;a href=&quot;error_category&quot;&gt;std::error_category&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b9ad010ef7d281736e175c6e04e6e45d80ea96e8" translate="yes" xml:space="preserve">
          <source>A reference to the stream, i.e., &lt;code&gt;os&lt;/code&gt;.</source>
          <target state="translated">Ссылка на поток, т.е. &lt;code&gt;os&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b519975029bcddb7935a1938c71b85de5a9aa395" translate="yes" xml:space="preserve">
          <source>A reference to this &lt;code&gt;day&lt;/code&gt; after modification.</source>
          <target state="translated">Ссылка на этот &lt;code&gt;day&lt;/code&gt; после внесения изменений.</target>
        </trans-unit>
        <trans-unit id="fd1b8fb4c67bb93024d4c080ffbd107e8a00646c" translate="yes" xml:space="preserve">
          <source>A reference to this &lt;code&gt;month&lt;/code&gt; after modification.</source>
          <target state="translated">Ссылка на этот &lt;code&gt;month&lt;/code&gt; после внесения изменений.</target>
        </trans-unit>
        <trans-unit id="77d42f71b8ba36af0d80129ce3320e59f448b88f" translate="yes" xml:space="preserve">
          <source>A reference to this &lt;code&gt;weekday&lt;/code&gt; after modification.</source>
          <target state="translated">Ссылка на этот &lt;code&gt;weekday&lt;/code&gt; после внесения изменений.</target>
        </trans-unit>
        <trans-unit id="30e2b7de4724355804f01b061a5218dcca673f33" translate="yes" xml:space="preserve">
          <source>A reference to this &lt;code&gt;year&lt;/code&gt; after modification.</source>
          <target state="translated">Ссылка на этот &lt;code&gt;year&lt;/code&gt; после модификации.</target>
        </trans-unit>
        <trans-unit id="c42d3cc108e10a5c0d961e89275a7b7e304370ef" translate="yes" xml:space="preserve">
          <source>A reference to this duration after modification.</source>
          <target state="translated">Ссылка на эту продолжительность после модификации.</target>
        </trans-unit>
        <trans-unit id="477f7a0da5713d89a4c5a2b12679f4b4532b6576" translate="yes" xml:space="preserve">
          <source>A reference variable declaration is any simple declaration whose &lt;a href=&quot;declarations&quot;&gt;declarator&lt;/a&gt; has the form.</source>
          <target state="translated">Объявление ссылочной переменной - это любое простое объявление, у которого &lt;a href=&quot;declarations&quot;&gt;объявитель&lt;/a&gt; имеет форму.</target>
        </trans-unit>
        <trans-unit id="071394746753f76fda55bbb1f2d7273768e4c96d" translate="yes" xml:space="preserve">
          <source>A release fence F in thread A synchronizes-with atomic &lt;a href=&quot;memory_order&quot;&gt;acquire operation&lt;/a&gt; Y in thread B, if.</source>
          <target state="translated">Разделительный забор F в потоке A синхронизирует с атомарной &lt;a href=&quot;memory_order&quot;&gt;операцией получения&lt;/a&gt; Y в потоке B, если.</target>
        </trans-unit>
        <trans-unit id="6aafba41a946d2b0a19753067d04e0ec8318ec66" translate="yes" xml:space="preserve">
          <source>A release fence FA in thread A synchronizes-with an acquire fence FB in thread B, if.</source>
          <target state="translated">Освобождающий забор FA в потоке A синхронизируется-с приобретаемым забором FB в потоке B,если.</target>
        </trans-unit>
        <trans-unit id="00a2a5eb93eeb9be0332c1c8673603beb7ab0223" translate="yes" xml:space="preserve">
          <source>A safely-derived copy of &lt;code&gt;p&lt;/code&gt;.</source>
          <target state="translated">Безопасно полученная копия &lt;code&gt;p&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="34d713d3ce9641e15f0083875fa82da7295cd6d0" translate="yes" xml:space="preserve">
          <source>A searcher suitable for use with the &lt;a href=&quot;https://en.cppreference.com/mwiki/index.php?title=cpp/named_req/Searcher&amp;amp;action=edit&amp;amp;redlink=1&quot;&gt;Searcher&lt;/a&gt; overload of &lt;code&gt;&lt;a href=&quot;../../algorithm/search&quot;&gt;std::search&lt;/a&gt;&lt;/code&gt; that implements the &lt;a href=&quot;https://en.wikipedia.org/wiki/Boyer%E2%80%93Moore%E2%80%93Horspool_algorithm&quot;&gt;Boyer-Moore-Horspool string searching algorithm&lt;/a&gt;.</source>
          <target state="translated">Искатель, подходящий для использования с перегрузкой &lt;a href=&quot;https://en.cppreference.com/mwiki/index.php?title=cpp/named_req/Searcher&amp;amp;action=edit&amp;amp;redlink=1&quot;&gt;Searcher&lt;/a&gt; от &lt;code&gt;&lt;a href=&quot;../../algorithm/search&quot;&gt;std::search&lt;/a&gt;&lt;/code&gt; которая реализует &lt;a href=&quot;https://en.wikipedia.org/wiki/Boyer%E2%80%93Moore%E2%80%93Horspool_algorithm&quot;&gt;алгоритм поиска строк Бойера-Мура-Хорспула&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a4aca9528474448c3c240ea5a50dac0f70fee741" translate="yes" xml:space="preserve">
          <source>A searcher suitable for use with the &lt;a href=&quot;https://en.cppreference.com/mwiki/index.php?title=cpp/named_req/Searcher&amp;amp;action=edit&amp;amp;redlink=1&quot;&gt;Searcher&lt;/a&gt; overload of &lt;code&gt;&lt;a href=&quot;../../algorithm/search&quot;&gt;std::search&lt;/a&gt;&lt;/code&gt; that implements the &lt;a href=&quot;https://en.wikipedia.org/wiki/Boyer%E2%80%93Moore_string_search_algorithm&quot;&gt;Boyer-Moore string searching algorithm&lt;/a&gt;.</source>
          <target state="translated">Искатель, подходящий для использования с перегрузкой &lt;a href=&quot;https://en.cppreference.com/mwiki/index.php?title=cpp/named_req/Searcher&amp;amp;action=edit&amp;amp;redlink=1&quot;&gt;Searcher&lt;/a&gt; от &lt;code&gt;&lt;a href=&quot;../../algorithm/search&quot;&gt;std::search&lt;/a&gt;&lt;/code&gt; которая реализует &lt;a href=&quot;https://en.wikipedia.org/wiki/Boyer%E2%80%93Moore_string_search_algorithm&quot;&gt;алгоритм поиска строк Бойера-Мура&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7c73f721b6023bb7d94aabb383e7afe39aad3eff" translate="yes" xml:space="preserve">
          <source>A separate stored pointer is necessary to ensure that converting a &lt;code&gt;shared_ptr&lt;/code&gt; to &lt;code&gt;weak_ptr&lt;/code&gt; and then back works correctly, even for aliased &lt;code&gt;shared_ptr&lt;/code&gt;s. It is not possible to access the stored pointer in a &lt;code&gt;weak_ptr&lt;/code&gt; without locking it into a &lt;code&gt;shared_ptr&lt;/code&gt;.</source>
          <target state="translated">Отдельный сохраненный указатель необходим, чтобы гарантировать, что преобразование &lt;code&gt;shared_ptr&lt;/code&gt; в &lt;code&gt;weak_ptr&lt;/code&gt; и затем обратно работает правильно, даже для псевдонимов &lt;code&gt;shared_ptr&lt;/code&gt; . Невозможно получить доступ к сохраненному указателю в &lt;code&gt;weak_ptr&lt;/code&gt; без блокировки его в &lt;code&gt;shared_ptr&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="25e507c2060a3cafdcda35e0bc4aa2552b49e574" translate="yes" xml:space="preserve">
          <source>A sequence of characters that represents the collating element consisting of the character sequence designated by the iterator range &lt;code&gt;[F1, F2)&lt;/code&gt; otherwise</source>
          <target state="translated">Последовательность символов, представляющая элемент сортировки, состоящий из последовательности символов, обозначенной диапазоном итератора &lt;code&gt;[F1, F2)&lt;/code&gt; противном случае</target>
        </trans-unit>
        <trans-unit id="3a4ef167623ed9faf9a94eff09dae4f596aaaa70" translate="yes" xml:space="preserve">
          <source>A simple declaration is a statement that introduces, creates, and optionally initializes one or several identifiers, typically variables.</source>
          <target state="translated">Простая декларация-это утверждение,которое вводит,создает и опционально инициализирует один или несколько идентификаторов,типичных для переменных.</target>
        </trans-unit>
        <trans-unit id="555b8933650b3bb84b4b7b35f14e9c321630ac4d" translate="yes" xml:space="preserve">
          <source>A simple requirement is an arbitrary expression statement. It asserts that the expression is valid. The expression is an unevaluated operand; only language correctness is checked.</source>
          <target state="translated">Простым требованием является утверждение произвольного выражения.Оно утверждает,что данное выражение является действительным.Выражение является неоцененным операндом;проверяется только корректность языка.</target>
        </trans-unit>
        <trans-unit id="3a6977f0304e9c21ebecd390f1670f86c4119c3c" translate="yes" xml:space="preserve">
          <source>A simple-template-id that names a class template specialization names a class.</source>
          <target state="translated">Простой шаблон,который называет специализацию шаблона класса,называет класс.</target>
        </trans-unit>
        <trans-unit id="8fa198408b5d0cb7b3044995aa1b61b2fdf97bfa" translate="yes" xml:space="preserve">
          <source>A sorted &lt;code&gt;&lt;a href=&quot;../container/vector&quot;&gt;std::vector&lt;/a&gt;&amp;lt;&lt;a href=&quot;link&quot;&gt;std::chrono::link&lt;/a&gt;&amp;gt;&lt;/code&gt; containing description of alternative names of time zones (links)</source>
          <target state="translated">Сортированный &lt;code&gt;&lt;a href=&quot;../container/vector&quot;&gt;std::vector&lt;/a&gt;&amp;lt;&lt;a href=&quot;link&quot;&gt;std::chrono::link&lt;/a&gt;&amp;gt;&lt;/code&gt; содержащий описание альтернативных названий часовых поясов (ссылки)</target>
        </trans-unit>
        <trans-unit id="457d45e0af075f01765307d373a69c2a8d94815f" translate="yes" xml:space="preserve">
          <source>A sorted &lt;code&gt;&lt;a href=&quot;../container/vector&quot;&gt;std::vector&lt;/a&gt;&amp;lt;&lt;a href=&quot;time_zone&quot;&gt;std::chrono::time_zone&lt;/a&gt;&amp;gt;&lt;/code&gt; containing description of time zones</source>
          <target state="translated">Отсортированный &lt;code&gt;&lt;a href=&quot;../container/vector&quot;&gt;std::vector&lt;/a&gt;&amp;lt;&lt;a href=&quot;time_zone&quot;&gt;std::chrono::time_zone&lt;/a&gt;&amp;gt;&lt;/code&gt; содержащее описание часовых поясов</target>
        </trans-unit>
        <trans-unit id="967914ef26dbd68948b66b13d60e30b85ed85a3c" translate="yes" xml:space="preserve">
          <source>A sorted &lt;code&gt;&lt;a href=&quot;../container/vector&quot;&gt;std::vector&lt;/a&gt;&amp;lt;std::chrono::leaps&amp;gt;&lt;/code&gt; containing description of leap seconds</source>
          <target state="translated">Сортированный &lt;code&gt;&lt;a href=&quot;../container/vector&quot;&gt;std::vector&lt;/a&gt;&amp;lt;std::chrono::leaps&amp;gt;&lt;/code&gt; содержащий описание високосных секунд</target>
        </trans-unit>
        <trans-unit id="eee524fe2ac982c4dd9f9a32a0c582f50eef3782" translate="yes" xml:space="preserve">
          <source>A span &lt;code&gt;r&lt;/code&gt; that is a view over the first &lt;code&gt;Count&lt;/code&gt; elements of &lt;code&gt;*this&lt;/code&gt;, such that &lt;code&gt;r.data() == this-&amp;gt;data() &amp;amp;&amp;amp; r.size() == Count&lt;/code&gt;.</source>
          <target state="translated">Интервал &lt;code&gt;r&lt;/code&gt; , который представляет собой представление первых элементов &lt;code&gt;Count&lt;/code&gt; в &lt;code&gt;*this&lt;/code&gt; , так что &lt;code&gt;r.data() == this-&amp;gt;data() &amp;amp;&amp;amp; r.size() == Count&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="65c54f136c4760893800380e5b0c393d21d23647" translate="yes" xml:space="preserve">
          <source>A span &lt;code&gt;r&lt;/code&gt; that is a view over the last &lt;code&gt;Count&lt;/code&gt; elements of &lt;code&gt;*this&lt;/code&gt;, such that &lt;code&gt;r.data() == this-&amp;gt;data() + (this-&amp;gt;size() - Count) &amp;amp;&amp;amp; r.size() == Count&lt;/code&gt;.</source>
          <target state="translated">Диапазон &lt;code&gt;r&lt;/code&gt; , представляющий последние элементы &lt;code&gt;Count&lt;/code&gt; в &lt;code&gt;*this&lt;/code&gt; , так что &lt;code&gt;r.data() == this-&amp;gt;data() + (this-&amp;gt;size() - Count) &amp;amp;&amp;amp; r.size() == Count&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5074592fbba4772cb532096c90f531b3f380c17b" translate="yes" xml:space="preserve">
          <source>A specialization of &lt;code&gt;&lt;a href=&quot;../numeric/ratio/ratio&quot;&gt;std::ratio&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">Специализация &lt;code&gt;&lt;a href=&quot;../numeric/ratio/ratio&quot;&gt;std::ratio&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9ee495551d56b04a23dc52fb815bb43b2e18e8c4" translate="yes" xml:space="preserve">
          <source>A specialization of &lt;code&gt;conjunction&lt;/code&gt; does not necessarily inherit from either &lt;code&gt;&lt;a href=&quot;integral_constant&quot;&gt;std::true_type&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;integral_constant&quot;&gt;std::false_type&lt;/a&gt;&lt;/code&gt;: it simply inherits from the first &lt;code&gt;B&lt;/code&gt; whose &lt;code&gt;::value&lt;/code&gt;, explicitly converted to bool, is false, or from the very last &lt;code&gt;B&lt;/code&gt; when all of them convert to true. For example, &lt;code&gt;std::conjunction&amp;lt;&lt;a href=&quot;integral_constant&quot;&gt;std::integral_constant&lt;/a&gt;&amp;lt;int, 2&amp;gt;, &lt;a href=&quot;integral_constant&quot;&gt;std::integral_constant&lt;/a&gt;&amp;lt;int, 4&amp;gt;&amp;gt;::value&lt;/code&gt; is &lt;code&gt;4&lt;/code&gt;.</source>
          <target state="translated">Специализация &lt;code&gt;conjunction&lt;/code&gt; не обязательно наследуется ни от &lt;code&gt;&lt;a href=&quot;integral_constant&quot;&gt;std::true_type&lt;/a&gt;&lt;/code&gt; ни от &lt;code&gt;&lt;a href=&quot;integral_constant&quot;&gt;std::false_type&lt;/a&gt;&lt;/code&gt; : она просто наследует от первого &lt;code&gt;B&lt;/code&gt; , чье &lt;code&gt;::value&lt;/code&gt; , явно преобразованное в bool, является ложным, или от самого последнего &lt;code&gt;B&lt;/code&gt; , когда все они преобразовать в истину. Например, &lt;code&gt;std::conjunction&amp;lt;&lt;a href=&quot;integral_constant&quot;&gt;std::integral_constant&lt;/a&gt;&amp;lt;int, 2&amp;gt;, &lt;a href=&quot;integral_constant&quot;&gt;std::integral_constant&lt;/a&gt;&amp;lt;int, 4&amp;gt;&amp;gt;::value&lt;/code&gt; равно &lt;code&gt;4&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f9e9b49b2bead30b9efc6f23cbdc32fd0fd8ce60" translate="yes" xml:space="preserve">
          <source>A specialization of &lt;code&gt;disjunction&lt;/code&gt; does not necessarily inherit from of either &lt;code&gt;&lt;a href=&quot;integral_constant&quot;&gt;std::true_type&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;integral_constant&quot;&gt;std::false_type&lt;/a&gt;&lt;/code&gt;: it simply inherits from the first &lt;code&gt;B&lt;/code&gt; whose &lt;code&gt;::value&lt;/code&gt;, explicitly converted to &lt;code&gt;bool&lt;/code&gt;, is true, or from the very last B when all of them convert to false. For example, &lt;code&gt;std::disjunction&amp;lt;&lt;a href=&quot;integral_constant&quot;&gt;std::integral_constant&lt;/a&gt;&amp;lt;int, 2&amp;gt;, &lt;a href=&quot;integral_constant&quot;&gt;std::integral_constant&lt;/a&gt;&amp;lt;int, 4&amp;gt;&amp;gt;::value&lt;/code&gt; is &lt;code&gt;2&lt;/code&gt;.</source>
          <target state="translated">Специализация &lt;code&gt;disjunction&lt;/code&gt; не обязательно наследуется от &lt;code&gt;&lt;a href=&quot;integral_constant&quot;&gt;std::true_type&lt;/a&gt;&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;integral_constant&quot;&gt;std::false_type&lt;/a&gt;&lt;/code&gt; : она просто наследует от первого &lt;code&gt;B&lt;/code&gt; , чье &lt;code&gt;::value&lt;/code&gt; , явно преобразованное в &lt;code&gt;bool&lt;/code&gt; , является истиной, или от самого последнего B, когда все они превращаются в ложные. Например, &lt;code&gt;std::disjunction&amp;lt;&lt;a href=&quot;integral_constant&quot;&gt;std::integral_constant&lt;/a&gt;&amp;lt;int, 2&amp;gt;, &lt;a href=&quot;integral_constant&quot;&gt;std::integral_constant&lt;/a&gt;&amp;lt;int, 4&amp;gt;&amp;gt;::value&lt;/code&gt; равно &lt;code&gt;2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9f9e5d495b1b862008c29e72aac873442799f4b0" translate="yes" xml:space="preserve">
          <source>A specialization of &lt;code&gt;std::greater&lt;/code&gt; for any pointer type yields a strict total order, even if the built-in &lt;code&gt;operator&amp;gt;&lt;/code&gt; does not. The strict total order is consistent among specializations of &lt;code&gt;&lt;a href=&quot;less&quot;&gt;std::less&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;std::greater&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;less_equal&quot;&gt;std::less_equal&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;greater_equal&quot;&gt;std::greater_equal&lt;/a&gt;&lt;/code&gt; for that pointer type, and is also consistent with the partial order imposed by the corresponding built-in operators (&lt;code&gt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;=&lt;/code&gt; and &lt;code&gt;&amp;gt;=&lt;/code&gt;).</source>
          <target state="translated">Специализация &lt;code&gt;std::greater&lt;/code&gt; для любого типа указателя дает строгий общий порядок, даже если встроенный &lt;code&gt;operator&amp;gt;&lt;/code&gt; не делает. Строгий общий порядок согласован среди специализаций &lt;code&gt;&lt;a href=&quot;less&quot;&gt;std::less&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;std::greater&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;less_equal&quot;&gt;std::less_equal&lt;/a&gt;&lt;/code&gt; , std :: less_equal и &lt;code&gt;&lt;a href=&quot;greater_equal&quot;&gt;std::greater_equal&lt;/a&gt;&lt;/code&gt; для этого типа указателя, а также согласуется с частичным порядком, налагаемым соответствующими встроенными операторами ( &lt;code&gt;&amp;lt;&lt;/code&gt; , &lt;code&gt;&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;=&lt;/code&gt; и &lt;code&gt;&amp;gt;=&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="4d8a4b2d55428dedbd5dbf627f7b5d8550161022" translate="yes" xml:space="preserve">
          <source>A specialization of &lt;code&gt;std::greater_equal&lt;/code&gt; for any pointer type yields a strict total order, even if the built-in &lt;code&gt;operator&amp;gt;=&lt;/code&gt; does not. The strict total order is consistent among specializations of &lt;code&gt;&lt;a href=&quot;less&quot;&gt;std::less&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;greater&quot;&gt;std::greater&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;less_equal&quot;&gt;std::less_equal&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;std::greater_equal&lt;/code&gt; for that pointer type, and is also consistent with the partial order imposed by the corresponding built-in operators (&lt;code&gt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;=&lt;/code&gt; and &lt;code&gt;&amp;gt;=&lt;/code&gt;).</source>
          <target state="translated">Специализация &lt;code&gt;std::greater_equal&lt;/code&gt; для любого типа указателя дает строгий общий порядок, даже если встроенный &lt;code&gt;operator&amp;gt;=&lt;/code&gt; этого не делает. Строгий общий порядок согласован среди специализаций &lt;code&gt;&lt;a href=&quot;less&quot;&gt;std::less&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;greater&quot;&gt;std::greater&lt;/a&gt;&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;less_equal&quot;&gt;std::less_equal&lt;/a&gt;&lt;/code&gt; , std :: less_equal и &lt;code&gt;std::greater_equal&lt;/code&gt; для этого типа указателя, а также согласуется с частичным порядком, налагаемым соответствующими встроенными операторами ( &lt;code&gt;&amp;lt;&lt;/code&gt; , &lt;code&gt;&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;=&lt;/code&gt; и &lt;code&gt;&amp;gt;=&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="475b3cfac8883fd0a588f09dae13ae24eea6b2df" translate="yes" xml:space="preserve">
          <source>A specialization of &lt;code&gt;std::less&lt;/code&gt; for any pointer type yields a strict total order, even if the built-in &lt;code&gt;operator&amp;lt;&lt;/code&gt; does not. The strict total order is consistent among specializations of &lt;code&gt;std::less&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;greater&quot;&gt;std::greater&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;less_equal&quot;&gt;std::less_equal&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;greater_equal&quot;&gt;std::greater_equal&lt;/a&gt;&lt;/code&gt; for that pointer type, and is also consistent with the partial order imposed by the corresponding built-in operators (&lt;code&gt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;=&lt;/code&gt; and &lt;code&gt;&amp;gt;=&lt;/code&gt;).</source>
          <target state="translated">Специализация &lt;code&gt;std::less&lt;/code&gt; для любого типа указателя дает строгий общий порядок, даже если встроенный &lt;code&gt;operator&amp;lt;&lt;/code&gt; не делает. Строгий общий порядок согласован среди специализаций &lt;code&gt;std::less&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;greater&quot;&gt;std::greater&lt;/a&gt;&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;less_equal&quot;&gt;std::less_equal&lt;/a&gt;&lt;/code&gt; , std :: less_equal и &lt;code&gt;&lt;a href=&quot;greater_equal&quot;&gt;std::greater_equal&lt;/a&gt;&lt;/code&gt; для этого типа указателя, а также согласуется с частичным порядком, налагаемым соответствующими встроенными операторами ( &lt;code&gt;&amp;lt;&lt;/code&gt; , &lt;code&gt;&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;=&lt;/code&gt; и &lt;code&gt;&amp;gt;=&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="5040d1c9db6502c777c18889e5250a72b8267c2f" translate="yes" xml:space="preserve">
          <source>A specialization of &lt;code&gt;std::less_equal&lt;/code&gt; for any pointer type yields a strict total order, even if the built-in &lt;code&gt;operator&amp;lt;=&lt;/code&gt; does not. The strict total order is consistent among specializations of &lt;code&gt;&lt;a href=&quot;less&quot;&gt;std::less&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;greater&quot;&gt;std::greater&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;std::less_equal&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;greater_equal&quot;&gt;std::greater_equal&lt;/a&gt;&lt;/code&gt; for that pointer type, and is also consistent with the partial order imposed by the corresponding built-in operators (&lt;code&gt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;=&lt;/code&gt; and &lt;code&gt;&amp;gt;=&lt;/code&gt;).</source>
          <target state="translated">Специализация &lt;code&gt;std::less_equal&lt;/code&gt; для любого типа указателя дает строгий общий порядок, даже если встроенный &lt;code&gt;operator&amp;lt;=&lt;/code&gt; этого не делает. Строгий общий порядок согласован среди специализаций &lt;code&gt;&lt;a href=&quot;less&quot;&gt;std::less&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;greater&quot;&gt;std::greater&lt;/a&gt;&lt;/code&gt; &lt;code&gt;std::less_equal&lt;/code&gt; , std :: less_equal и &lt;code&gt;&lt;a href=&quot;greater_equal&quot;&gt;std::greater_equal&lt;/a&gt;&lt;/code&gt; для этого типа указателя, а также согласуется с частичным порядком, налагаемым соответствующими встроенными операторами ( &lt;code&gt;&amp;lt;&lt;/code&gt; , &lt;code&gt;&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;=&lt;/code&gt; и &lt;code&gt;&amp;gt;=&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="92e25a120740f5ad5adbba2aabed8d933eb3d5e4" translate="yes" xml:space="preserve">
          <source>A spinlock mutex can be implemented in userspace using an atomic exchange operation, similar to &lt;code&gt;&lt;a href=&quot;atomic_flag_test_and_set&quot;&gt;std::atomic_flag_test_and_set&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">Мьютекс спин-блокировки может быть реализован в пользовательском пространстве с помощью операции атомарного обмена, аналогичной &lt;code&gt;&lt;a href=&quot;atomic_flag_test_and_set&quot;&gt;std::atomic_flag_test_and_set&lt;/a&gt;&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="9515057fe6328dc05919c4cf02d9006061787a0c" translate="yes" xml:space="preserve">
          <source>A spinlock mutex can be implemented in userspace using an atomic_flag.</source>
          <target state="translated">Мьютекс spinlock может быть реализован в пользовательском пространстве с помощью atomic_flag.</target>
        </trans-unit>
        <trans-unit id="901d05a2e6ec5ffbcf6b01e787bf262ebced94a5" translate="yes" xml:space="preserve">
          <source>A standard conversion sequence consists of the following, in this order:</source>
          <target state="translated">Стандартная последовательность преобразования состоит в следующем порядке:</target>
        </trans-unit>
        <trans-unit id="d4c338c0450a24104d97679430b5532160d82771" translate="yes" xml:space="preserve">
          <source>A static assert declaration may appear at namespace and block scope (as a &lt;a href=&quot;declarations&quot;&gt;block declaration&lt;/a&gt;) and inside a class body (as a &lt;a href=&quot;class&quot;&gt;member declaration&lt;/a&gt;).</source>
          <target state="translated">Статическое объявление утверждения может появляться в пространстве имен и области блока (как &lt;a href=&quot;declarations&quot;&gt;объявление блока&lt;/a&gt; ) и внутри тела класса (как &lt;a href=&quot;class&quot;&gt;объявление члена&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="f33f270773f2dc3de0fd0352e32cf33418d9b8c0" translate="yes" xml:space="preserve">
          <source>A static data member may be declared &lt;a href=&quot;inline&quot;&gt;&lt;code&gt;inline&lt;/code&gt;&lt;/a&gt;. An inline static data member can be defined in the class definition and may specify an initializer. It does not need an out-of-class definition:</source>
          <target state="translated">Статический член данных может быть объявлен &lt;a href=&quot;inline&quot;&gt; &lt;code&gt;inline&lt;/code&gt; &lt;/a&gt; . Встроенный статический член данных может быть определен в определении класса и может указывать инициализатор. Это не нуждается во внеклассном определении:</target>
        </trans-unit>
        <trans-unit id="5da97780b140e6a47935295d4e1ee4870bfe1e89" translate="yes" xml:space="preserve">
          <source>A static member variable (but not a namespace-scope variable) declared &lt;code&gt;constexpr&lt;/code&gt; is implicitly an inline variable.</source>
          <target state="translated">Статическая переменная-член (но не переменная пространства имен), объявленная &lt;code&gt;constexpr&lt;/code&gt; , неявно является встроенной переменной.</target>
        </trans-unit>
        <trans-unit id="4b6d0fdd7d7607c01a896d9094690fc14c51a0b3" translate="yes" xml:space="preserve">
          <source>A steady clock is used to measure the duration. This function may block for longer than &lt;code&gt;timeout_duration&lt;/code&gt; due to scheduling or resource contention delays.</source>
          <target state="translated">Постоянные часы используются для измерения продолжительности. Эта функция может блокироваться дольше, чем &lt;code&gt;timeout_duration&lt;/code&gt; , из-за задержек планирования или конфликта ресурсов.</target>
        </trans-unit>
        <trans-unit id="78127daba885f04d8c232a3a0e396aee55e69e02" translate="yes" xml:space="preserve">
          <source>A store operation with this memory order performs the</source>
          <target state="translated">Операция хранения с этим порядком памяти выполняет</target>
        </trans-unit>
        <trans-unit id="c6bc48899775e9a6c5f0a1a15785f5ee33b9cf7b" translate="yes" xml:space="preserve">
          <source>A string describing the given error condition.</source>
          <target state="translated">Строка,описывающая данное состояние ошибки.</target>
        </trans-unit>
        <trans-unit id="46b19b69118bd315cdfc683d15a6fa75436b64bc" translate="yes" xml:space="preserve">
          <source>A string literal is not necessarily a C string: if a string literal has embedded null characters, it represents an array which contains more than one string.</source>
          <target state="translated">Строковый литерал не обязательно является строкой на языке C:если в строковый литерал встроены нулевые символы,то он представляет собой массив,содержащий более одной строки.</target>
        </trans-unit>
        <trans-unit id="1550cc2a5436eb99f071dfa4dcf0dd47ccf4c825" translate="yes" xml:space="preserve">
          <source>A string view representing the entire contents of the string.</source>
          <target state="translated">Строковое представление,представляющее все содержимое строки.</target>
        </trans-unit>
        <trans-unit id="32570ac03b4c2c47cffb2bbc021cc0ca86dcc629" translate="yes" xml:space="preserve">
          <source>A structured binding declaration first introduces a uniquely-named variable (here denoted by &lt;code&gt;&lt;i&gt;e&lt;/i&gt;&lt;/code&gt;) to hold the value of the initializer, as follows:</source>
          <target state="translated">Декларация структурированной привязки сначала вводит переменную с уникальным именем (здесь она обозначается как &lt;code&gt;&lt;i&gt;e&lt;/i&gt;&lt;/code&gt; ) для хранения значения инициализатора следующим образом:</target>
        </trans-unit>
        <trans-unit id="144f71d00798ee052aabd4ddb5c24678262a6ae1" translate="yes" xml:space="preserve">
          <source>A structured binding declaration introduces all identifiers in the identifier-list as names in the surrounding scope and binds them to subobjects or elements of the object denoted by expression. The bindings so introduced are called</source>
          <target state="translated">Структурированная обязательная декларация вводит все идентификаторы в список идентификаторов как имена в окружающем пространстве применения и связывает их с подобъектами или элементами объекта,обозначенными выражением.Вводимые таким образом привязки называются</target>
        </trans-unit>
        <trans-unit id="835974f7bef28e4dff1c1ff405518b0bb98087eb" translate="yes" xml:space="preserve">
          <source>A structured binding declaration then performs the binding in one of three possible ways, depending on &lt;code&gt;&lt;i&gt;E&lt;/i&gt;&lt;/code&gt;:</source>
          <target state="translated">Затем объявление структурированной привязки выполняет привязку одним из трех возможных способов, в зависимости от &lt;code&gt;&lt;i&gt;E&lt;/i&gt;&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="5ebdd31b80b554a53c87eaf8af1247d0cf95b1cf" translate="yes" xml:space="preserve">
          <source>A subobject is</source>
          <target state="translated">Подобъект</target>
        </trans-unit>
        <trans-unit id="7a0f0cf82fd7a9695235dbab61201c1151c693d9" translate="yes" xml:space="preserve">
          <source>A successful call to &lt;code&gt;operator()&lt;/code&gt; synchronizes with a call to any member function of a &lt;code&gt;&lt;a href=&quot;../future&quot;&gt;std::future&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../shared_future&quot;&gt;std::shared_future&lt;/a&gt;&lt;/code&gt; that share their shared state with &lt;code&gt;*this&lt;/code&gt;.</source>
          <target state="translated">Успешный вызов &lt;code&gt;operator()&lt;/code&gt; синхронизируется с вызовом любой функции-члена &lt;code&gt;&lt;a href=&quot;../future&quot;&gt;std::future&lt;/a&gt;&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;../shared_future&quot;&gt;std::shared_future&lt;/a&gt;&lt;/code&gt; которые делятся своим общим состоянием с &lt;code&gt;*this&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5e5e13088bac64880bbd1d92f74dea1c546eae32" translate="yes" xml:space="preserve">
          <source>A successful call to &lt;code&gt;ungetc&lt;/code&gt; clears the end of file status flag &lt;code&gt;&lt;a href=&quot;feof&quot;&gt;std::feof&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Успешный вызов &lt;code&gt;ungetc&lt;/code&gt; очищает флаг статуса файла &lt;code&gt;&lt;a href=&quot;feof&quot;&gt;std::feof&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2f18b9828e8cbe5f820c7f00f14018c93e63c261" translate="yes" xml:space="preserve">
          <source>A successful call to &lt;code&gt;ungetc&lt;/code&gt; on a binary stream decrements the stream position indicator by one (the behavior is indeterminate if the stream position indicator was zero).</source>
          <target state="translated">Успешный вызов &lt;code&gt;ungetc&lt;/code&gt; в двоичном потоке уменьшает индикатор положения потока на единицу (поведение не определено, если индикатор положения потока был равен нулю).</target>
        </trans-unit>
        <trans-unit id="ca4337b8d12737a6a022afbf7eb03368caa77b5b" translate="yes" xml:space="preserve">
          <source>A successful call to &lt;code&gt;ungetc&lt;/code&gt; on a text stream modifies the stream position indicator in unspecified manner but guarantees that after all pushed-back characters are retrieved with a read operation, the stream position indicator is equal to its value before &lt;code&gt;ungetc&lt;/code&gt;.</source>
          <target state="translated">Успешный вызов &lt;code&gt;ungetc&lt;/code&gt; в текстовом потоке изменяет указатель положения потока неопределенным образом, но гарантирует, что после того, как все задние символы будут получены с помощью операции чтения, указатель положения потока будет равен его значению перед &lt;code&gt;ungetc&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a28d7859e6f4fcb6db1df05cff06566fff5a4e72" translate="yes" xml:space="preserve">
          <source>A successful call to &lt;code&gt;ungetwc&lt;/code&gt; clears the end of file status flag &lt;code&gt;feof&lt;/code&gt;.</source>
          <target state="translated">Успешный вызов &lt;code&gt;ungetwc&lt;/code&gt; очищает конец статус файла флаг &lt;code&gt;feof&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="96bde972d314cd8969488c09d04edcb68d3e8cec" translate="yes" xml:space="preserve">
          <source>A successful call to &lt;code&gt;ungetwc&lt;/code&gt; on a stream (whether text or binary) modifies the stream position indicator in unspecified manner but guarantees that after all pushed-back wide characters are retrieved with a read operation, the stream position indicator is equal to its value before &lt;code&gt;ungetwc&lt;/code&gt;.</source>
          <target state="translated">Успешный вызов &lt;code&gt;ungetwc&lt;/code&gt; в потоке (текстовом или двоичном) изменяет индикатор положения потока неопределенным образом, но гарантирует, что после того, как все задние широкие символы будут получены с помощью операции чтения, индикатор положения потока будет равен его значению перед &lt;code&gt;ungetwc&lt;/code&gt; ,</target>
        </trans-unit>
        <trans-unit id="4438ef6f7a0682bb256998449673a26881f7a072" translate="yes" xml:space="preserve">
          <source>A template argument for a template template parameter must be an &lt;a href=&quot;name#In_expressions&quot;&gt;id-expression&lt;/a&gt; which names a class template or a template alias.</source>
          <target state="translated">Аргумент шаблона для параметра шаблона должен быть выражением &lt;a href=&quot;name#In_expressions&quot;&gt;id,&lt;/a&gt; которое называет шаблон класса или псевдоним шаблона.</target>
        </trans-unit>
        <trans-unit id="0cbe97ed8a5079b18bed67f0b987c6e75304c3a6" translate="yes" xml:space="preserve">
          <source>A template argument for a type template parameter must be a &lt;a href=&quot;type-id#Type_naming&quot;&gt;type-id&lt;/a&gt;, which may name an incomplete type:</source>
          <target state="translated">Аргумент шаблона для параметра шаблона типа должен быть &lt;a href=&quot;type-id#Type_naming&quot;&gt;идентификатором типа&lt;/a&gt; , который может называть неполный тип:</target>
        </trans-unit>
        <trans-unit id="b77575f13c55d5afb76807a44c03b42f3be5cca3" translate="yes" xml:space="preserve">
          <source>A template defined in the &lt;code&gt;&amp;lt;type_traits&amp;gt;&lt;/code&gt; header may be instantiated with an incomplete type unless otherwise specified, notwithstanding the general prohibition against instantiating standard library templates with incomplete types.</source>
          <target state="translated">Шаблон, определенный в заголовке &lt;code&gt;&amp;lt;type_traits&amp;gt;&lt;/code&gt; , может быть создан с неполным типом, если не указано иное, несмотря на общий запрет на создание экземпляров стандартных шаблонов библиотек с неполными типами.</target>
        </trans-unit>
        <trans-unit id="3db9cfde6b359f0a7eac7446ebfcb7cabe3498b5" translate="yes" xml:space="preserve">
          <source>A template friend declaration can name a member of a class template A, which can be either a member function or a member type (the type must use &lt;a href=&quot;elaborated_type_specifier&quot;&gt;elaborated-type-specifier&lt;/a&gt;). Such declaration is only well-formed if the last component in its nested-name-specifier (the name to the left of the last &lt;code&gt;::&lt;/code&gt;) is a simple-template-id (template name followed by argument list in angle brackets) that names the class template. The template parameters of such template friend declaration must be deducible from the simple-template-id.</source>
          <target state="translated">Объявление друга шаблона может называть члена шаблона класса A, который может быть либо функцией-членом, либо типом члена (тип должен использовать &lt;a href=&quot;elaborated_type_specifier&quot;&gt;уточненный спецификатор типа&lt;/a&gt; ). Такое объявление корректно формируется, только если последний компонент в его спецификаторе nested-name-name (имя слева от last &lt;code&gt;::&lt;/code&gt; ) представляет собой simple-template-id (имя шаблона, за которым следует список аргументов в угловых скобках), которое называет шаблон класса. Параметры шаблона такой декларации друга шаблона должны быть выведены из simple-template-id.</target>
        </trans-unit>
        <trans-unit id="b8cbfd05ed876a96f58d914b20aab64f29b86a74" translate="yes" xml:space="preserve">
          <source>A template is a C++ entity that defines one of the following:</source>
          <target state="translated">Шаблон-это сущность C++,которая определяет одно из следующего:</target>
        </trans-unit>
        <trans-unit id="59d81713cfdc4799ddf46175f8d61401bcd90683" translate="yes" xml:space="preserve">
          <source>A template parameter of the form &lt;code&gt;class Foo&lt;/code&gt; is not an unnamed non-type template parameter of type &lt;code&gt;Foo&lt;/code&gt;, even if otherwise &lt;code&gt;class Foo&lt;/code&gt; is an &lt;a href=&quot;elaborated_type_specifier&quot;&gt;elaborated type specifier&lt;/a&gt; and &lt;code&gt;class Foo x;&lt;/code&gt; declares &lt;code&gt;x&lt;/code&gt; to be of type &lt;code&gt;Foo&lt;/code&gt;.</source>
          <target state="translated">Параметр шаблона &lt;code&gt;class Foo&lt;/code&gt; формы Foo не является неназванным параметрическим параметром типа &lt;code&gt;Foo&lt;/code&gt; , даже если в противном случае &lt;code&gt;class Foo&lt;/code&gt; представляет собой &lt;a href=&quot;elaborated_type_specifier&quot;&gt;разработанный спецификатор типа,&lt;/a&gt; а &lt;code&gt;class Foo x;&lt;/code&gt; объявляет, что &lt;code&gt;x&lt;/code&gt; имеет тип &lt;code&gt;Foo&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d85241f2bc54602e57c2582a6ecab6b9f660f5f6" translate="yes" xml:space="preserve">
          <source>A template parameter pack is a template parameter that accepts zero or more template arguments (non-types, types, or templates). A function parameter pack is a function parameter that accepts zero or more function arguments.</source>
          <target state="translated">Пакет параметров шаблона-это параметр шаблона,который принимает нулевой или более аргументов шаблона (не типы,типы или шаблоны).Пакет параметров функции-это параметр функции,который принимает нулевой или более аргументов функции.</target>
        </trans-unit>
        <trans-unit id="eb2fa05aae2cb5737143f68053260c6a62f41e74" translate="yes" xml:space="preserve">
          <source>A template parameter pack that is explicitly specified may be extended by template argument deduction if there are additional arguments:</source>
          <target state="translated">Пакет параметров шаблона,который явно указан,может быть расширен вычетом аргументов шаблона при наличии дополнительных аргументов:</target>
        </trans-unit>
        <trans-unit id="f41dfabc2328a29181220b5113304c48aad61703" translate="yes" xml:space="preserve">
          <source>A template specialization that was declared but not defined can be used just like any other &lt;a href=&quot;incomplete_type&quot;&gt;incomplete type&lt;/a&gt; (e.g. pointers and references to it may be used).</source>
          <target state="translated">Специализация шаблона, которая была объявлена, но не определена, может использоваться точно так же, как любой другой &lt;a href=&quot;incomplete_type&quot;&gt;неполный тип&lt;/a&gt; (например, могут использоваться указатели и ссылки на него).</target>
        </trans-unit>
        <trans-unit id="344b2caa5e5fe345b5eddc1d5d915de3d6be2db2" translate="yes" xml:space="preserve">
          <source>A template with at least one parameter pack is called a</source>
          <target state="translated">Шаблон с хотя бы одним пакетом параметров называется</target>
        </trans-unit>
        <trans-unit id="673816c6497404faf247ef589f1b122b3a14f807" translate="yes" xml:space="preserve">
          <source>A template-id is only valid if.</source>
          <target state="translated">Шаблон-ид действителен только в том случае,если.</target>
        </trans-unit>
        <trans-unit id="10655830c19a77e3e63f7c59d226efb3c807b9e8" translate="yes" xml:space="preserve">
          <source>A template-id that names an alias template specialization names a type.</source>
          <target state="translated">Шаблон-макет,который называет специализацию шаблона псевдонима,называет тип.</target>
        </trans-unit>
        <trans-unit id="df2b079308f3eca647407b9397b352dc670c7a81" translate="yes" xml:space="preserve">
          <source>A template-id that names an function template specialization names a function.</source>
          <target state="translated">Шаблон-ид,который называет специализацию шаблона функции,называет функцию.</target>
        </trans-unit>
        <trans-unit id="3c85feec0c63ebeca50f678f352ffcc3928d1b88" translate="yes" xml:space="preserve">
          <source>A templated entity (or, in some sources, &quot;temploid&quot;) is any entity that is defined (or, for a lambda-expression, created) within a template definition. All of the following are templated entities:</source>
          <target state="translated">Шаблонированная сущность (или,в некоторых источниках,&quot;темплоид&quot;)-это любая сущность,которая определена (или,для лямбда-выражения,создана)в рамках определения шаблона.Все нижеперечисленные сущности являются шаблонами:</target>
        </trans-unit>
        <trans-unit id="97a674e12e96df448607046bf1ea74819514e29d" translate="yes" xml:space="preserve">
          <source>A temporary object of type &lt;code&gt;T&lt;/code&gt; is &lt;a href=&quot;../language/value_initialization&quot;&gt;value-initialized&lt;/a&gt; or &lt;a href=&quot;../language/aggregate_initialization&quot;&gt;aggregate-initialized&lt;/a&gt;.</source>
          <target state="translated">Временный объект типа &lt;code&gt;T&lt;/code&gt; является &lt;a href=&quot;../language/value_initialization&quot;&gt;значением инициализируется&lt;/a&gt; или &lt;a href=&quot;../language/aggregate_initialization&quot;&gt;агрегатно-инициализирован&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="33f18c53306de042e4c98fc4f2ec71d92fc7452f" translate="yes" xml:space="preserve">
          <source>A test for self-reset, i.e. whether &lt;code&gt;ptr&lt;/code&gt; points to an object already managed by &lt;code&gt;*this&lt;/code&gt;, is not performed, except where provided as a compiler extension or as a debugging assert. Note that code such as &lt;code&gt;p.reset(p.release())&lt;/code&gt; does not involve self-reset, only code like &lt;code&gt;p.reset(p.get())&lt;/code&gt; does.</source>
          <target state="translated">Проверка на самовосстановление, т.е. на то, указывает ли &lt;code&gt;ptr&lt;/code&gt; на объект, уже управляемый &lt;code&gt;*this&lt;/code&gt; , не выполняется, за исключением случаев, когда это предусмотрено в качестве расширения компилятора или в качестве отладочного утверждения. Обратите внимание, что такой код, как &lt;code&gt;p.reset(p.release())&lt;/code&gt; , не включает самовозврат, а только код, подобный &lt;code&gt;p.reset(p.get())&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="69a493f42c2d5d0a3d7b1e06a1285a10bdbe7061" translate="yes" xml:space="preserve">
          <source>A thread is said to</source>
          <target state="translated">Сказано,что нить</target>
        </trans-unit>
        <trans-unit id="ba9c13c0f9167e54bcbaf88e115f4167e83660c0" translate="yes" xml:space="preserve">
          <source>A thread may call &lt;code&gt;lock&lt;/code&gt; on a recursive mutex repeatedly. Ownership will only be released after the thread makes a matching number of calls to &lt;code&gt;unlock&lt;/code&gt;.</source>
          <target state="translated">Поток может повторно вызывать &lt;code&gt;lock&lt;/code&gt; рекурсивного мьютекса. Право собственности будет освобождено только после того, как поток сделает соответствующее количество вызовов, чтобы &lt;code&gt;unlock&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7f432eae50bd789012a099dcf2a13f431564693f" translate="yes" xml:space="preserve">
          <source>A thread may call &lt;code&gt;try_lock&lt;/code&gt; on a recursive mutex repeatedly. Successful calls to &lt;code&gt;try_lock&lt;/code&gt; increment the ownsership count: the mutex will only be released after the thread makes a matching number of calls to &lt;code&gt;&lt;a href=&quot;unlock&quot;&gt;unlock&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;try_lock&lt;/code&gt; может повторно вызывать try_lock для рекурсивного мьютекса. Успешные вызовы &lt;code&gt;try_lock&lt;/code&gt; увеличивают число собственных пользователей: мьютекс будет освобожден только после того, как поток сделает соответствующее количество вызовов для &lt;code&gt;&lt;a href=&quot;unlock&quot;&gt;unlock&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="37671f46b069e4bce5a6c704520d4965568d9f60" translate="yes" xml:space="preserve">
          <source>A thread may call &lt;code&gt;try_lock_for&lt;/code&gt; on a recursive mutex repeatedly. Successful calls to &lt;code&gt;try_lock_for&lt;/code&gt; increment the ownership count: the mutex will only be released after the thread makes a matching number of calls to &lt;code&gt;&lt;a href=&quot;unlock&quot;&gt;unlock&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;try_lock_for&lt;/code&gt; может повторно вызывать try_lock_for для рекурсивного мьютекса. Успешные вызовы &lt;code&gt;try_lock_for&lt;/code&gt; увеличивают количество владельцев: мьютекс будет освобожден только после того, как поток сделает соответствующее количество вызовов для &lt;code&gt;&lt;a href=&quot;unlock&quot;&gt;unlock&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="892016f3791df53a75393a4054de36f6670ede74" translate="yes" xml:space="preserve">
          <source>A thread may call &lt;code&gt;try_lock_until&lt;/code&gt; on a recursive mutex repeatedly. Successful calls to &lt;code&gt;try_lock_until&lt;/code&gt; increment the ownership count: the mutex will only be released after the thread makes a matching number of calls to &lt;code&gt;&lt;a href=&quot;unlock&quot;&gt;unlock&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;try_lock_until&lt;/code&gt; может повторно вызывать try_lock_until для рекурсивного мьютекса. Успешные вызовы &lt;code&gt;try_lock_until&lt;/code&gt; увеличивают счетчик владения: мьютекс будет освобожден только после того, как поток сделает соответствующее количество вызовов для &lt;code&gt;&lt;a href=&quot;unlock&quot;&gt;unlock&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6b4560e93294ed5a9703378d1e170be75de3f418" translate="yes" xml:space="preserve">
          <source>A thread object does not have an associated thread (and is safe to destroy) after.</source>
          <target state="translated">После этого у объекта нити нет связанной нити (и его можно безопасно уничтожить).</target>
        </trans-unit>
        <trans-unit id="bac126fd4b2160e8de884ee506093cb6e1453d7a" translate="yes" xml:space="preserve">
          <source>A thread of execution is a flow of control within a program that begins with the invocation of a top-level function by &lt;code&gt;&lt;a href=&quot;../thread/thread/thread&quot;&gt;std::thread::thread&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../thread/async&quot;&gt;std::async&lt;/a&gt;&lt;/code&gt;, or other means.</source>
          <target state="translated">Поток выполнения - это поток управления в программе, который начинается с вызова функции верхнего уровня с помощью &lt;code&gt;&lt;a href=&quot;../thread/thread/thread&quot;&gt;std::thread::thread&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../thread/async&quot;&gt;std::async&lt;/a&gt;&lt;/code&gt; или другими средствами.</target>
        </trans-unit>
        <trans-unit id="13fb085a74dd9fd867bcbeeeed6c63aa5ff60cd7" translate="yes" xml:space="preserve">
          <source>A thread that has finished executing code, but has not yet been joined is still considered an active thread of execution and is therefore joinable.</source>
          <target state="translated">Поток,который закончил выполнение кода,но еще не был присоединен,все еще считается активным потоком выполнения и,следовательно,является присоединяемым.</target>
        </trans-unit>
        <trans-unit id="d83b1a24d6c356fdf4f8f81bf30022c94f556e0c" translate="yes" xml:space="preserve">
          <source>A time point is a duration of time that has passed since the epoch of a specific clock.</source>
          <target state="translated">Точка времени-это продолжительность времени,прошедшего с эпохи определенных часов.</target>
        </trans-unit>
        <trans-unit id="842ecf6d69cdbeaddd28ab48c6e44b247497210b" translate="yes" xml:space="preserve">
          <source>A time point representing the current time.</source>
          <target state="translated">Точка времени,представляющая текущее время.</target>
        </trans-unit>
        <trans-unit id="482e88b6e7ea3206c3e62b40431b9801a98e659f" translate="yes" xml:space="preserve">
          <source>A trailing template-argument can be left unspecified in an explicit instantiation of a function template specialization or of a member function template specialization if it can be &lt;a href=&quot;template_argument_deduction&quot;&gt;deduced&lt;/a&gt; from the function parameter.</source>
          <target state="translated">Конечный шаблон-аргумент может быть оставлен неуказанным в явном экземпляре специализации шаблона функции или специализации шаблона функции-члена, если он может быть &lt;a href=&quot;template_argument_deduction&quot;&gt;выведен&lt;/a&gt; из параметра функции.</target>
        </trans-unit>
        <trans-unit id="1744e51348fac7204c6560fe5f680fd02436a4e6" translate="yes" xml:space="preserve">
          <source>A translation unit that includes a standard library header may not &lt;code&gt;#define&lt;/code&gt; or &lt;code&gt;#undef&lt;/code&gt; names declared in any standard library header.</source>
          <target state="translated">Модуль перевода, который включает стандартный заголовок библиотеки, может не &lt;code&gt;#undef&lt;/code&gt; имен &lt;code&gt;#define&lt;/code&gt; или #undef, объявленных в любом стандартном заголовке библиотеки.</target>
        </trans-unit>
        <trans-unit id="e8a16a40cb320ca82f7aab312a29ceda1b14f739" translate="yes" xml:space="preserve">
          <source>A translation unit that uses any part of the standard library may not &lt;code&gt;#define&lt;/code&gt; or &lt;code&gt;#undef&lt;/code&gt; names lexically identical to:</source>
          <target state="translated">Модуль перевода, который использует любую часть стандартной библиотеки, не &lt;code&gt;#undef&lt;/code&gt; имен &lt;code&gt;#define&lt;/code&gt; или #undef лексически идентичны:</target>
        </trans-unit>
        <trans-unit id="d317f7a0ab3e788267489e0fc1532ddec6c12c38" translate="yes" xml:space="preserve">
          <source>A trivial copy assignment operator makes a copy of the object representation as if by &lt;code&gt;&lt;a href=&quot;../string/byte/memmove&quot;&gt;std::memmove&lt;/a&gt;&lt;/code&gt;. All data types compatible with the C language (POD types) are trivially copy-assignable.</source>
          <target state="translated">Оператор присваивания тривиальной копии создает копию представления объекта, как будто с помощью &lt;code&gt;&lt;a href=&quot;../string/byte/memmove&quot;&gt;std::memmove&lt;/a&gt;&lt;/code&gt; . Все типы данных, совместимые с языком C (типы POD), легко назначаются для копирования.</target>
        </trans-unit>
        <trans-unit id="dd6abf8a66d91871c0f211e838354255f118cc43" translate="yes" xml:space="preserve">
          <source>A trivial copy constructor for a non-union class effectively copies every scalar subobject (including, recursively, subobject of subobjects and so forth) of the argument and performs no other action. However, padding bytes need not be copied, and even the object representations of the copied subobjects need not be the same as long as their values are identical.</source>
          <target state="translated">Тривиальный конструктор копирования для несоюзного класса эффективно копирует каждый скалярный подобъект (включая,рекурсивно,подобъекты подобъектов и т.д.)аргумента и не выполняет никаких других действий.Однако,байты отступов копировать не нужно,и даже объектные представления скопированных подобъектов не должны быть одинаковыми,пока их значения идентичны.</target>
        </trans-unit>
        <trans-unit id="53f265b51a6ad6bc29b0d13aa314fdd06dcfce6a" translate="yes" xml:space="preserve">
          <source>A trivial default constructor is a constructor that performs no action. All data types compatible with the C language (POD types) are trivially default-constructible. Unlike &lt;a href=&quot;http://en.cppreference.com/w/c/language/object.html#Effective_type&quot;&gt;in C&lt;/a&gt;, however, objects with trivial default constructors cannot be created by simply reinterpreting suitably aligned storage, such as memory allocated with &lt;code&gt;&lt;a href=&quot;../memory/c/malloc&quot;&gt;std::malloc&lt;/a&gt;&lt;/code&gt;: placement-new is required to formally &lt;a href=&quot;objects&quot;&gt;introduce a new object&lt;/a&gt; and avoid potential undefined behavior.</source>
          <target state="translated">Тривиальный конструктор по умолчанию - это конструктор, который не выполняет никаких действий. Все типы данных, совместимые с языком C (типы POD), легко конструируются по умолчанию. Однако, в отличие от &lt;a href=&quot;http://en.cppreference.com/w/c/language/object.html#Effective_type&quot;&gt;C&lt;/a&gt; , объекты с тривиальными конструкторами по умолчанию не могут быть созданы путем простой интерпретации надлежащим образом выровненного хранилища, такого как память, выделенная с помощью &lt;code&gt;&lt;a href=&quot;../memory/c/malloc&quot;&gt;std::malloc&lt;/a&gt;&lt;/code&gt; :place-new, для формального &lt;a href=&quot;objects&quot;&gt;представления нового объекта&lt;/a&gt; и предотвращения возможного неопределенного поведения.</target>
        </trans-unit>
        <trans-unit id="033337ca5c4ad7c5b77be1ecaa5de6acda3c11c8" translate="yes" xml:space="preserve">
          <source>A trivial destructor is a destructor that performs no action. Objects with trivial destructors don't require a delete-expression and may be disposed of by simply deallocating their storage. All data types compatible with the C language (POD types) are trivially destructible.</source>
          <target state="translated">Тривиальный деструктор-это деструктор,который не выполняет никаких действий.Объекты с тривиальными деструкторами не требуют удаления выражений и могут быть утилизированы путем простого разделения их хранения.Все типы данных,совместимые с языком Си (типы POD),являются тривиальными деструкторами.</target>
        </trans-unit>
        <trans-unit id="d79042321968ff405b9eb41b02f03841f248eb8b" translate="yes" xml:space="preserve">
          <source>A trivial move assignment operator performs the same action as the trivial copy assignment operator, that is, makes a copy of the object representation as if by &lt;code&gt;&lt;a href=&quot;../string/byte/memmove&quot;&gt;std::memmove&lt;/a&gt;&lt;/code&gt;. All data types compatible with the C language (POD types) are trivially move-assignable.</source>
          <target state="translated">Оператор присваивания тривиального перемещения выполняет то же действие, что и оператор присваивания тривиального копирования, то есть создает копию представления объекта, как будто с помощью &lt;code&gt;&lt;a href=&quot;../string/byte/memmove&quot;&gt;std::memmove&lt;/a&gt;&lt;/code&gt; . Все типы данных, совместимые с языком C (типы POD), легко назначаются для перемещения.</target>
        </trans-unit>
        <trans-unit id="0ceb73134e634232cb9fed5b06967cd8af551fd6" translate="yes" xml:space="preserve">
          <source>A trivial move constructor is a constructor that performs the same action as the trivial copy constructor, that is, makes a copy of the object representation as if by &lt;code&gt;&lt;a href=&quot;../string/byte/memmove&quot;&gt;std::memmove&lt;/a&gt;&lt;/code&gt;. All data types compatible with the C language (POD types) are trivially movable.</source>
          <target state="translated">Конструктор тривиального перемещения - это конструктор, который выполняет то же действие, что и конструктор тривиального копирования, то есть создает копию представления объекта, как будто с помощью &lt;code&gt;&lt;a href=&quot;../string/byte/memmove&quot;&gt;std::memmove&lt;/a&gt;&lt;/code&gt; . Все типы данных, совместимые с языком C (типы POD), легко переносимы.</target>
        </trans-unit>
        <trans-unit id="4362f0ff877083bd05b03790df742e70f948b72d" translate="yes" xml:space="preserve">
          <source>A try-block is a &lt;a href=&quot;statements&quot;&gt;statement&lt;/a&gt;, and as such, can appear anywhere a statement can appear (that is, as one of the statements in a compound statement, including the function body compound statement). See &lt;a href=&quot;function-try-block&quot;&gt;function-try-block&lt;/a&gt; for the try blocks around function bodies. The following description applies to both try-blocks and &lt;a href=&quot;function-try-block&quot;&gt;function-try-blocks&lt;/a&gt;.</source>
          <target state="translated">Блок try является &lt;a href=&quot;statements&quot;&gt;оператором&lt;/a&gt; и, как таковой, может появляться везде, где может появляться оператор (то есть как один из операторов в составном операторе, включая составной оператор тела функции). Смотрите &lt;a href=&quot;function-try-block&quot;&gt;function-try-block&lt;/a&gt; для блоков try вокруг тел функций. Следующее описание относится как к блоку try, так и к блоку &lt;a href=&quot;function-try-block&quot;&gt;function-try&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="19834a31076ba08c517eaff630de5e748d366c53" translate="yes" xml:space="preserve">
          <source>A type &lt;code&gt;E&lt;/code&gt; satisfying &lt;a href=&quot;uniformrandombitgenerator&quot;&gt;UniformRandomBitGenerator&lt;/a&gt; will additionally satisfy RandomNumberEngine if, given.</source>
          <target state="translated">Тип &lt;code&gt;E&lt;/code&gt; , удовлетворяющий &lt;a href=&quot;uniformrandombitgenerator&quot;&gt;UniformRandomBitGenerator,&lt;/a&gt; будет дополнительно удовлетворять RandomNumberEngine, если он задан.</target>
        </trans-unit>
        <trans-unit id="ca6cf0688a958e8a7bf6dc59cfc4cfb1df147a82" translate="yes" xml:space="preserve">
          <source>A type T is ValueSwappable if.</source>
          <target state="translated">Тип T-ValueSwappable if.</target>
        </trans-unit>
        <trans-unit id="a7bc09bb961fc3d44a04b48c1111a1a318bd62fe" translate="yes" xml:space="preserve">
          <source>A type has</source>
          <target state="translated">Тип A имеет</target>
        </trans-unit>
        <trans-unit id="1816dc600e8b7d025987ab256efe8b9a53ee4eb9" translate="yes" xml:space="preserve">
          <source>A type requirement is the keyword &lt;code&gt;typename&lt;/code&gt; followed by a type name, optionally qualified. The requirement is that the named type is valid: this can be used to verify that a certain named nested type exists, or that a class template specialization names a type, or that an alias template specialization names a type. A type requirement naming a class template specialization does not require the type to be complete.</source>
          <target state="translated">Требование к типу - это ключевое слово &lt;code&gt;typename&lt;/code&gt; , за которым следует имя типа, опционально уточненное. Требуется, чтобы именованный тип был допустимым: это можно использовать для проверки того, что определенный именованный вложенный тип существует, или что специализация шаблона класса называет тип, или что специализация шаблона псевдонима называет тип. Требование типа, указывающее на специализацию шаблона класса, не требует завершения типа.</target>
        </trans-unit>
        <trans-unit id="15ef01c2ad4973128037ff3072f4151a78c62933" translate="yes" xml:space="preserve">
          <source>A type that can hold all valid values of &lt;code&gt;X::char_type&lt;/code&gt; plus &lt;code&gt;X::eof()&lt;/code&gt;</source>
          <target state="translated">Тип, который может содержать все допустимые значения &lt;code&gt;X::char_type&lt;/code&gt; плюс &lt;code&gt;X::eof()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="03ac68cf57c6c426934400170b4271e37c362fbe" translate="yes" xml:space="preserve">
          <source>A typical cause of failure for &lt;code&gt;std::puts&lt;/code&gt; is running out of space on the file system, when &lt;code&gt;stdout&lt;/code&gt; is redirected to a file.</source>
          <target state="translated">Типичная причина сбоя для &lt;code&gt;std::puts&lt;/code&gt; - нехватка места в файловой системе, когда &lt;code&gt;stdout&lt;/code&gt; перенаправляется в файл.</target>
        </trans-unit>
        <trans-unit id="ae95c3cb82eea0b19d5fa37c3903de19a5db5a6a" translate="yes" xml:space="preserve">
          <source>A typical example of such situation is the naive implementation of &lt;code&gt;&lt;a href=&quot;../iterator/reverse_iterator&quot;&gt;std::reverse_iterator&lt;/a&gt;&lt;/code&gt; (derived from the empty base &lt;code&gt;&lt;a href=&quot;../iterator/iterator&quot;&gt;std::iterator&lt;/a&gt;&lt;/code&gt;), which holds the underlying iterator (also derived from &lt;code&gt;&lt;a href=&quot;../iterator/iterator&quot;&gt;std::iterator&lt;/a&gt;&lt;/code&gt;) as its first non-static data member.</source>
          <target state="translated">Типичным примером такой ситуации является наивная реализация &lt;code&gt;&lt;a href=&quot;../iterator/reverse_iterator&quot;&gt;std::reverse_iterator&lt;/a&gt;&lt;/code&gt; (полученная из пустой базы &lt;code&gt;&lt;a href=&quot;../iterator/iterator&quot;&gt;std::iterator&lt;/a&gt;&lt;/code&gt; ), которая содержит лежащий в основе итератор (также полученный из &lt;code&gt;&lt;a href=&quot;../iterator/iterator&quot;&gt;std::iterator&lt;/a&gt;&lt;/code&gt; ) в качестве своего первого нестатического члена данных.</target>
        </trans-unit>
        <trans-unit id="0734374c55a399a52d1410a4e6f7c1c0d057f16d" translate="yes" xml:space="preserve">
          <source>A typical generator's yield_value would store (copy/move or just store the address of, since the argument's lifetime crosses the suspension point inside the co_await) its argument into the generator object and return &lt;code&gt;std::suspend_always&lt;/code&gt;, transferring control to the caller/resumer.</source>
          <target state="translated">Типичное значение yield_value генератора будет хранить (копировать / перемещать или просто сохранять адрес, поскольку время жизни аргумента пересекает точку приостановки внутри co_await) свой аргумент в объект генератора и возвращать &lt;code&gt;std::suspend_always&lt;/code&gt; , передавая управление вызывающей стороне / получателю.</target>
        </trans-unit>
        <trans-unit id="51f160ce423fd83704df3a5cb0174dbe3220c314" translate="yes" xml:space="preserve">
          <source>A typical implementation holds one integer data member (the value) and a pointer to an &lt;code&gt;&lt;a href=&quot;error_category&quot;&gt;std::error_category&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Типичная реализация содержит один целочисленный элемент данных (значение) и указатель на &lt;code&gt;&lt;a href=&quot;error_category&quot;&gt;std::error_category&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1aa218a5c2f20a77c0b0ce98af0029f85ebd7ae1" translate="yes" xml:space="preserve">
          <source>A typical implementation holds only two members: a pointer to &lt;code&gt;T&lt;/code&gt; and a size.</source>
          <target state="translated">Типичная реализация содержит только два члена: указатель на &lt;code&gt;T&lt;/code&gt; и размер.</target>
        </trans-unit>
        <trans-unit id="b1049a0bd6d2b817dcdf4dbacf6924d39c59809b" translate="yes" xml:space="preserve">
          <source>A typical implementation holds only two members: a pointer to constant &lt;code&gt;CharT&lt;/code&gt; and a size.</source>
          <target state="translated">Типичная реализация содержит только два члена: указатель на константу &lt;code&gt;CharT&lt;/code&gt; и размер.</target>
        </trans-unit>
        <trans-unit id="2c4f9d8e2fe4e7c12c1285e532e5570e4bb48e5d" translate="yes" xml:space="preserve">
          <source>A typical implementation of &lt;code&gt;std::basic_fstream&lt;/code&gt; holds only one non-derived data member: an instance of &lt;code&gt;&lt;a href=&quot;basic_filebuf&quot;&gt;std::basic_filebuf&lt;/a&gt;&amp;lt;CharT, Traits&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">Типичная реализация &lt;code&gt;std::basic_fstream&lt;/code&gt; содержит только один непроизведенный элемент данных: экземпляр &lt;code&gt;&lt;a href=&quot;basic_filebuf&quot;&gt;std::basic_filebuf&lt;/a&gt;&amp;lt;CharT, Traits&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b8130838cccfdb668dc1da70d0ff806b7225abc0" translate="yes" xml:space="preserve">
          <source>A typical implementation of &lt;code&gt;std::basic_ifstream&lt;/code&gt; holds only one non-derived data member: an instance of &lt;code&gt;&lt;a href=&quot;basic_filebuf&quot;&gt;std::basic_filebuf&lt;/a&gt;&amp;lt;CharT, Traits&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">Типичная реализация &lt;code&gt;std::basic_ifstream&lt;/code&gt; содержит только один непроизведенный элемент данных: экземпляр &lt;code&gt;&lt;a href=&quot;basic_filebuf&quot;&gt;std::basic_filebuf&lt;/a&gt;&amp;lt;CharT, Traits&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7183d62923a8e947e2f0e103df21cd2904d87891" translate="yes" xml:space="preserve">
          <source>A typical implementation of &lt;code&gt;std::basic_ofstream&lt;/code&gt; holds only one non-derived data member: an instance of &lt;code&gt;&lt;a href=&quot;basic_filebuf&quot;&gt;std::basic_filebuf&lt;/a&gt;&amp;lt;CharT, Traits&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">Типичная реализация &lt;code&gt;std::basic_ofstream&lt;/code&gt; содержит только один непроизведенный элемент данных: экземпляр &lt;code&gt;&lt;a href=&quot;basic_filebuf&quot;&gt;std::basic_filebuf&lt;/a&gt;&amp;lt;CharT, Traits&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="217f99906b2120be1fba7713f69e991a00815576" translate="yes" xml:space="preserve">
          <source>A typical implementation of &lt;code&gt;std::istream_iterator&lt;/code&gt; holds two data members: a pointer to the associated &lt;code&gt;&lt;a href=&quot;../io/basic_istream&quot;&gt;std::basic_istream&lt;/a&gt;&lt;/code&gt; object and the most recently read value of type &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">Типичная реализация &lt;code&gt;std::istream_iterator&lt;/code&gt; держит член два данных: указатель на соответствующий &lt;code&gt;&lt;a href=&quot;../io/basic_istream&quot;&gt;std::basic_istream&lt;/a&gt;&lt;/code&gt; объект и последний считанное значение типа &lt;code&gt;T&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ad3a71fd17c76f0ee62dee1d66ae5633a375fd68" translate="yes" xml:space="preserve">
          <source>A typical implementation of &lt;code&gt;std::regex_iterator&lt;/code&gt; holds the begin and the end iterators for the underlying sequence (two instances of BidirIt), a pointer to the regular expression (&lt;code&gt;const regex_type*&lt;/code&gt;), the match flags (&lt;code&gt;&lt;a href=&quot;match_flag_type&quot;&gt;std::regex_constants::match_flag_type&lt;/a&gt;&lt;/code&gt;), and the current match (&lt;code&gt;&lt;a href=&quot;match_results&quot;&gt;std::match_results&lt;/a&gt;&amp;lt;BidirIt&amp;gt;&lt;/code&gt;).</source>
          <target state="translated">Типичная реализация &lt;code&gt;std::regex_iterator&lt;/code&gt; содержит начальный и конечный итераторы для базовой последовательности (два экземпляра BidirIt), указатель на регулярное выражение ( &lt;code&gt;const regex_type*&lt;/code&gt; ), флаги соответствия ( &lt;code&gt;&lt;a href=&quot;match_flag_type&quot;&gt;std::regex_constants::match_flag_type&lt;/a&gt;&lt;/code&gt; ) и текущее совпадение ( &lt;code&gt;&lt;a href=&quot;match_results&quot;&gt;std::match_results&lt;/a&gt;&amp;lt;BidirIt&amp;gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="5594f6466e9c627a309f191d1d21416131d6dcaa" translate="yes" xml:space="preserve">
          <source>A typical implementation of &lt;code&gt;std::regex_token_iterator&lt;/code&gt; holds the underlying &lt;code&gt;&lt;a href=&quot;regex_iterator&quot;&gt;std::regex_iterator&lt;/a&gt;&lt;/code&gt;, a container (e.g. &lt;code&gt;&lt;a href=&quot;../container/vector&quot;&gt;std::vector&lt;/a&gt;&amp;lt;int&amp;gt;&lt;/code&gt;) of the requested submatch indexes, the internal counter equal to the index of the submatch, a pointer to &lt;code&gt;&lt;a href=&quot;sub_match&quot;&gt;std::sub_match&lt;/a&gt;&lt;/code&gt;, pointing at the current submatch of the current match, and a &lt;code&gt;&lt;a href=&quot;match_results&quot;&gt;std::match_results&lt;/a&gt;&lt;/code&gt; object containing the last non-matched character sequence (used in tokenizer mode).</source>
          <target state="translated">Типичная реализация &lt;code&gt;std::regex_token_iterator&lt;/code&gt; содержит базовый &lt;code&gt;&lt;a href=&quot;regex_iterator&quot;&gt;std::regex_iterator&lt;/a&gt;&lt;/code&gt; , контейнер (например, &lt;code&gt;&lt;a href=&quot;../container/vector&quot;&gt;std::vector&lt;/a&gt;&amp;lt;int&amp;gt;&lt;/code&gt; ) запрошенных индексов соответствия, внутренний счетчик, равный индексу субматча, указатель на &lt;code&gt;&lt;a href=&quot;sub_match&quot;&gt;std::sub_match&lt;/a&gt;&lt;/code&gt; , указывающий на текущее подсовпадение текущего совпадения, и объект &lt;code&gt;&lt;a href=&quot;match_results&quot;&gt;std::match_results&lt;/a&gt;&lt;/code&gt; содержащий последнюю несогласованную последовательность символов (используется в режиме токенизатора).</target>
        </trans-unit>
        <trans-unit id="ec993624f290f31f38642161da480cca7738a5b4" translate="yes" xml:space="preserve">
          <source>A uniform random bit generator is a function object returning unsigned integer values such that each value in the range of possible results has (ideally) equal probability.</source>
          <target state="translated">Генератор равномерных случайных битов-это объект функции,возвращающий беззнаковые целочисленные значения таким образом,что каждое значение в диапазоне возможных результатов имеет (в идеале)равную вероятность.</target>
        </trans-unit>
        <trans-unit id="5b1045e71b04fce292271774a5a72bec6686a37d" translate="yes" xml:space="preserve">
          <source>A union can have member functions (including constructors and destructors), but not virtual functions.</source>
          <target state="translated">Объединение может иметь членские функции (включая конструкторы и деструкторы),но не виртуальные.</target>
        </trans-unit>
        <trans-unit id="a2abfe76729a7513736cb7faa5d5ce5576166784" translate="yes" xml:space="preserve">
          <source>A union cannot have base classes and cannot be used as a base class.</source>
          <target state="translated">Профсоюз не может иметь базовых классов и не может использоваться в качестве базового класса.</target>
        </trans-unit>
        <trans-unit id="d044e7ff18d6370026b7cb48f5515536c724fbdc" translate="yes" xml:space="preserve">
          <source>A union cannot have non-static data members of reference types.</source>
          <target state="translated">Профсоюз не может иметь нестатических данных членов ссылочных типов.</target>
        </trans-unit>
        <trans-unit id="8c914c20794cb64933a85898ab023cc57498cff6" translate="yes" xml:space="preserve">
          <source>A union is a special class type that can hold only one of its non-static &lt;a href=&quot;data_members&quot;&gt;data members&lt;/a&gt; at a time.</source>
          <target state="translated">Объединение - это специальный тип класса, который может одновременно содержать только один из своих нестатических &lt;a href=&quot;data_members&quot;&gt;элементов данных&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b72fa34edde9b7a760e2ca9a63cea91e1b555145" translate="yes" xml:space="preserve">
          <source>A universal character name in a narrow string literal or a 16-bit string literal may map to more than one character, e.g. &lt;code&gt;\U0001f34c&lt;/code&gt; is 4 &lt;code&gt;char&lt;/code&gt; code units in UTF-8 (&lt;code&gt;\xF0\x9F\x8D\x8C&lt;/code&gt;) and 2 &lt;code&gt;char16_t&lt;/code&gt; code units in UTF-16 (&lt;code&gt;\uD83C\uDF4C&lt;/code&gt;).</source>
          <target state="translated">Универсальное имя символа в узком строкового литерала или 16-битным строковый литерал может отображать более одного символа, например , &lt;code&gt;\U0001f34c&lt;/code&gt; является 4 - &lt;code&gt;char&lt;/code&gt; кода единицы в UTF-8 ( &lt;code&gt;\xF0\x9F\x8D\x8C&lt;/code&gt; ) и 2 &lt;code&gt;char16_t&lt;/code&gt; кода единицы в UTF-16 ( &lt;code&gt;\uD83C\uDF4C&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="416c36a6fa82a246cd095bd156c7aaf5425291a8" translate="yes" xml:space="preserve">
          <source>A useful guideline is that the destructor of any base class must be &lt;a href=&quot;https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#discussion-make-base-class-destructors-public-and-virtual-or-protected-and-nonvirtual&quot;&gt;public and virtual or protected and non-virtual&lt;/a&gt;.</source>
          <target state="translated">Полезное правило заключается в том, что деструктор любого базового класса должен быть &lt;a href=&quot;https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#discussion-make-base-class-destructors-public-and-virtual-or-protected-and-nonvirtual&quot;&gt;открытым и виртуальным или защищенным и не виртуальным&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="83e4b1da3b5d3236546ebba09aeb934da81e6f4f" translate="yes" xml:space="preserve">
          <source>A user-defined &lt;a href=&quot;cast_operator&quot;&gt;conversion function&lt;/a&gt; can be a template.</source>
          <target state="translated">Пользовательская &lt;a href=&quot;cast_operator&quot;&gt;функция преобразования&lt;/a&gt; может быть шаблоном.</target>
        </trans-unit>
        <trans-unit id="5d638bfd657359641307f2e7271f6931cb2015b9" translate="yes" xml:space="preserve">
          <source>A user-defined &lt;code&gt;std::unexpected_handler&lt;/code&gt; is expected to either terminate the program or throw an exception. If it throws an exception, one of the following three situations may be encountered:</source>
          <target state="translated">Предполагается, что определяемый пользователем &lt;code&gt;std::unexpected_handler&lt;/code&gt; либо завершит программу, либо выдаст исключение. Если выдается исключение, может возникнуть одна из следующих трех ситуаций:</target>
        </trans-unit>
        <trans-unit id="73f25ff036d8280e869a001e21e48bbeb542c334" translate="yes" xml:space="preserve">
          <source>A user-defined conversion consists of zero or one non-explicit single-argument constructor or non-explicit &lt;a href=&quot;cast_operator&quot;&gt;conversion function&lt;/a&gt; call.</source>
          <target state="translated">Пользовательское преобразование состоит из нуля или одного неявного конструктора с одним аргументом или неявного вызова &lt;a href=&quot;cast_operator&quot;&gt;функции преобразования&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d0e1aabd13d35e1072413a4e56940753290b1935" translate="yes" xml:space="preserve">
          <source>A user-defined conversion function template cannot have a deduced return type.</source>
          <target state="translated">Определенный пользователем шаблон функции преобразования не может иметь вычитаемый тип возврата.</target>
        </trans-unit>
        <trans-unit id="1e6c06935ba93da6b0506db32bcdb2cfcdba4051" translate="yes" xml:space="preserve">
          <source>A user-defined literal is an expression of any of the following forms.</source>
          <target state="translated">Пользовательский литерал-это выражение любой из следующих форм.</target>
        </trans-unit>
        <trans-unit id="3054b1de584f16f3593abd57817b8a39cfd5c191" translate="yes" xml:space="preserve">
          <source>A user-provided &lt;code&gt;Compare&lt;/code&gt; can be supplied to change the ordering, e.g. using &lt;code&gt;std::greater&amp;lt;T&amp;gt;&lt;/code&gt; would cause the smallest element to appear as the &lt;code&gt;&lt;a href=&quot;priority_queue/top&quot;&gt;top()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Предоставленное пользователем &lt;code&gt;Compare&lt;/code&gt; может быть предоставлено для изменения порядка, например, использование &lt;code&gt;std::greater&amp;lt;T&amp;gt;&lt;/code&gt; приведет к тому, что наименьший элемент будет отображаться как &lt;code&gt;&lt;a href=&quot;priority_queue/top&quot;&gt;top()&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="640dc08af4538f2be62eb03eb3dd195df49a90d2" translate="yes" xml:space="preserve">
          <source>A using-declaration also can't be used to introduce the name of a dependent member template as a</source>
          <target state="translated">Использование-декларация также не может быть использована для введения имени шаблона зависимого члена в качестве</target>
        </trans-unit>
        <trans-unit id="4bae902040c5ab2ebd693033e3fed94dda49e2af" translate="yes" xml:space="preserve">
          <source>A using-declaration cannot name a member template specialization (&lt;a href=&quot;templates#template-id&quot;&gt;template-id&lt;/a&gt; is not permitted by the grammar):</source>
          <target state="translated">Объявление-использование не может назвать специализацию &lt;a href=&quot;templates#template-id&quot;&gt;шаблона&lt;/a&gt; элемента ( идентификатор шаблона не разрешен грамматикой):</target>
        </trans-unit>
        <trans-unit id="ef90b2e3eff9b374774e4a806f69699ec8e2d794" translate="yes" xml:space="preserve">
          <source>A using-declaration cannot refer to a namespace, to a scoped enumerator, to a destructor of a base class or to a specialization of a member template for a user-defined conversion function.</source>
          <target state="translated">Использовательно-декларация не может относиться к пространству имён,к отскопированному перечислителю,к деструктору базового класса или к специализации шаблона-членов для пользовательской функции преобразования.</target>
        </trans-unit>
        <trans-unit id="b03fbcaa0bf1071b311fbaae0c5ce6b26d0a8ede" translate="yes" xml:space="preserve">
          <source>A using-declaration with more than one using-declarator is equivalent to a corresponding sequence of using-declarations with one using-declarator.</source>
          <target state="translated">Декларация использования с несколькими использующими-деклараторами эквивалентна соответствующей последовательности использования-деклараций с одним использующим-декларатором.</target>
        </trans-unit>
        <trans-unit id="20d0f9a0bea74c92ad5ff18da1b24cd553bbba2b" translate="yes" xml:space="preserve">
          <source>A valarray with the same size as the parameter.</source>
          <target state="translated">Валаррей того же размера,что и параметр.</target>
        </trans-unit>
        <trans-unit id="9b0aa598587fc3cc855c9c9ccc2c85d04dd3b0d5" translate="yes" xml:space="preserve">
          <source>A valid const iterator to &lt;code&gt;a&lt;/code&gt;</source>
          <target state="translated">Действительный сопзЬ итератор &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="14a30aab0776a047f20feb27371310d867438a4f" translate="yes" xml:space="preserve">
          <source>A valid dereferenceable const iterator to &lt;code&gt;a&lt;/code&gt;</source>
          <target state="translated">Действительный разыменовываемое сопзЬ итератор &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7c5ba5e3ccd5588e225779b9a36ab64c069c240a" translate="yes" xml:space="preserve">
          <source>A valid dereferenceable iterator to &lt;code&gt;a&lt;/code&gt;</source>
          <target state="translated">Действительный разыменовываемый итератор &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="28223fe6cd5ada49f5862218ac60de143b2567db" translate="yes" xml:space="preserve">
          <source>A value equal to 0 if the path is lexicographically equal to the given path.</source>
          <target state="translated">Значение,равное 0,если путь лексикографически равен данному пути.</target>
        </trans-unit>
        <trans-unit id="a50061555eec54932403da5e038843403742ee9c" translate="yes" xml:space="preserve">
          <source>A value equivalent to &lt;code&gt;c&lt;/code&gt;.</source>
          <target state="translated">Значение, эквивалентное &lt;code&gt;c&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="de1ab572a1a705bc1af0966dac1fe26f7ab37241" translate="yes" xml:space="preserve">
          <source>A value greater than 0 if the path is lexicographically greater than the given path.</source>
          <target state="translated">Значение больше 0,если путь лексикографически больше заданного.</target>
        </trans-unit>
        <trans-unit id="59605f92ecf81d222cf73bc53f88e408d0be42bc" translate="yes" xml:space="preserve">
          <source>A value less than 0 if the path is lexicographically less than the given path.</source>
          <target state="translated">Значение меньше 0,если путь лексикографически меньше заданного.</target>
        </trans-unit>
        <trans-unit id="772e15e1bdd5eccbbc37f434f301068fa5b598a7" translate="yes" xml:space="preserve">
          <source>A value less than zero if this sub_match is</source>
          <target state="translated">Значение меньше нуля,если это соответствие sub_match равно</target>
        </trans-unit>
        <trans-unit id="32241575a78d789ffd0a6260e7ef09d51214c2a4" translate="yes" xml:space="preserve">
          <source>A value not equivalent to any valid value of type &lt;code&gt;char_type&lt;/code&gt;.</source>
          <target state="translated">Значение, не эквивалентное действительному значению типа &lt;code&gt;char_type&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6b19e1b2f4ff9e9aafad05b04d18d7cec329645b" translate="yes" xml:space="preserve">
          <source>A value of a floating-point type can also be converted to any complete enumeration type.</source>
          <target state="translated">Значение типа с плавающей точкой также может быть преобразовано в любой полный тип перечисления.</target>
        </trans-unit>
        <trans-unit id="63a22bbd341be0d94948a8da39b757c96e4a822a" translate="yes" xml:space="preserve">
          <source>A value of type &lt;code&gt;&lt;a href=&quot;../../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&lt;/code&gt; that holds the error code number from &lt;code&gt;e&lt;/code&gt; associated with the error category &lt;code&gt;&quot;future&quot;&lt;/code&gt;.</source>
          <target state="translated">Значение типа &lt;code&gt;&lt;a href=&quot;../../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&lt;/code&gt; , содержащее номер кода ошибки от &lt;code&gt;e&lt;/code&gt; , связанный с категорией ошибок &lt;code&gt;&quot;future&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8d689f1f7f9107c84de7e9e6a91164c4d8d448b7" translate="yes" xml:space="preserve">
          <source>A value of type &lt;code&gt;&lt;a href=&quot;../../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&lt;/code&gt; that holds the error code number from &lt;code&gt;e&lt;/code&gt; associated with the error category &lt;code&gt;&quot;iostream&quot;&lt;/code&gt;.</source>
          <target state="translated">Значение типа &lt;code&gt;&lt;a href=&quot;../../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&lt;/code&gt; , содержащее номер кода ошибки от &lt;code&gt;e&lt;/code&gt; , связанный с категорией ошибок &lt;code&gt;&quot;iostream&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d85edc98c1d148807f1167309444da367dce2885" translate="yes" xml:space="preserve">
          <source>A value of type &lt;code&gt;&lt;a href=&quot;../../error/error_condition&quot;&gt;std::error_condition&lt;/a&gt;&lt;/code&gt; that holds the error code number from &lt;code&gt;e&lt;/code&gt; associated with the error category &lt;code&gt;&quot;future&quot;&lt;/code&gt;.</source>
          <target state="translated">Значение типа &lt;code&gt;&lt;a href=&quot;../../error/error_condition&quot;&gt;std::error_condition&lt;/a&gt;&lt;/code&gt; которое содержит номер кода ошибки от &lt;code&gt;e&lt;/code&gt; , связанный с категорией ошибок &lt;code&gt;&quot;future&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="db29599a3ec1300b12f7cddbf4961efd2a438f2c" translate="yes" xml:space="preserve">
          <source>A value of type &lt;code&gt;&lt;a href=&quot;../../error/error_condition&quot;&gt;std::error_condition&lt;/a&gt;&lt;/code&gt; that holds the error code number from &lt;code&gt;e&lt;/code&gt; associated with the error category &lt;code&gt;&quot;iostream&quot;&lt;/code&gt;.</source>
          <target state="translated">Значение типа &lt;code&gt;&lt;a href=&quot;../../error/error_condition&quot;&gt;std::error_condition&lt;/a&gt;&lt;/code&gt; которое содержит номер кода ошибки от &lt;code&gt;e&lt;/code&gt; , связанный с категорией ошибок &lt;code&gt;&quot;iostream&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d4716864d7aecb12710c82c5051f8f56cfc5d9f6" translate="yes" xml:space="preserve">
          <source>A value of type &lt;code&gt;&lt;a href=&quot;../codecvt_base&quot;&gt;std::codecvt_base::result&lt;/a&gt;&lt;/code&gt;, indicating the success status as follows:</source>
          <target state="translated">Значение типа &lt;code&gt;&lt;a href=&quot;../codecvt_base&quot;&gt;std::codecvt_base::result&lt;/a&gt;&lt;/code&gt; , указывающее статус успеха следующим образом:</target>
        </trans-unit>
        <trans-unit id="32fad6cd0042895426d631ee6330654d50fdd26f" translate="yes" xml:space="preserve">
          <source>A value of type &lt;code&gt;&lt;a href=&quot;id&quot;&gt;std::thread::id&lt;/a&gt;&lt;/code&gt; identifying the thread associated with &lt;code&gt;*this&lt;/code&gt;. If there is no thread associated, default constructed &lt;code&gt;&lt;a href=&quot;id&quot;&gt;std::thread::id&lt;/a&gt;&lt;/code&gt; is returned.</source>
          <target state="translated">Значение типа &lt;code&gt;&lt;a href=&quot;id&quot;&gt;std::thread::id&lt;/a&gt;&lt;/code&gt; идентифицирующее поток, связанный с &lt;code&gt;*this&lt;/code&gt; . Если поток не связан, возвращается &lt;code&gt;&lt;a href=&quot;id&quot;&gt;std::thread::id&lt;/a&gt;&lt;/code&gt; умолчанию std :: thread :: id .</target>
        </trans-unit>
        <trans-unit id="4007ab79efb7d58184f823559bcab8f2c0fe4508" translate="yes" xml:space="preserve">
          <source>A value of type &lt;code&gt;X::key_type&lt;/code&gt;</source>
          <target state="translated">Значение типа &lt;code&gt;X::key_type&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="072712158f85df6191a61fbd61f9b1af57edb2a6" translate="yes" xml:space="preserve">
          <source>A value of type &lt;code&gt;X::value_type&lt;/code&gt;</source>
          <target state="translated">Значение типа &lt;code&gt;X::value_type&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c9fa2a7989928288a59b9d1061cab281384dc7d7" translate="yes" xml:space="preserve">
          <source>A value of type &lt;code&gt;dateorder&lt;/code&gt;.</source>
          <target state="translated">Значение типа &lt;code&gt;dateorder&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e52779b1e6c9706944a08739b4d2e94ab73e1ebe" translate="yes" xml:space="preserve">
          <source>A value of type &lt;code&gt;std::chrono::system_clock::time_point&lt;/code&gt; representing &lt;code&gt;t&lt;/code&gt;.</source>
          <target state="translated">Значение типа &lt;code&gt;std::chrono::system_clock::time_point&lt;/code&gt; представляющее &lt;code&gt;t&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="372178480f2f29b6cd4a1502b1b12fa8b61b4a68" translate="yes" xml:space="preserve">
          <source>A value of type &lt;code&gt;std::partial_ordering&lt;/code&gt;, as described above.</source>
          <target state="translated">Значение типа &lt;code&gt;std::partial_ordering&lt;/code&gt; , как описано выше.</target>
        </trans-unit>
        <trans-unit id="f50da534940de9fa538b0344ec2f07e991732fc7" translate="yes" xml:space="preserve">
          <source>A value of type &lt;code&gt;std::strong_equality&lt;/code&gt;, as described above.</source>
          <target state="translated">Значение типа &lt;code&gt;std::strong_equality&lt;/code&gt; , как описано выше.</target>
        </trans-unit>
        <trans-unit id="1240d3098b2313d3e38b4e6524a3981c2caf173b" translate="yes" xml:space="preserve">
          <source>A value of type &lt;code&gt;std::strong_ordering&lt;/code&gt;, as described above.</source>
          <target state="translated">Значение типа &lt;code&gt;std::strong_ordering&lt;/code&gt; , как описано выше.</target>
        </trans-unit>
        <trans-unit id="d920da1ed499cf59fb8f2ff084478f87888ebedf" translate="yes" xml:space="preserve">
          <source>A value of type &lt;code&gt;std::weak_equality&lt;/code&gt;, as described above.</source>
          <target state="translated">Значение типа &lt;code&gt;std::weak_equality&lt;/code&gt; , как описано выше.</target>
        </trans-unit>
        <trans-unit id="84362b6647406e2ba1f03eb0961d6929e28947bb" translate="yes" xml:space="preserve">
          <source>A value of type &lt;code&gt;std::weak_ordering&lt;/code&gt;, as described above.</source>
          <target state="translated">Значение типа &lt;code&gt;std::weak_ordering&lt;/code&gt; , как описано выше.</target>
        </trans-unit>
        <trans-unit id="d92cb041f91a75157fbd95d555f69774c1ab1976" translate="yes" xml:space="preserve">
          <source>A value of type &lt;code&gt;void (*)(int)&lt;/code&gt;. When returned by &lt;code&gt;&lt;a href=&quot;signal&quot;&gt;std::signal&lt;/a&gt;&lt;/code&gt;, indicates that an error has occurred.</source>
          <target state="translated">Значение типа &lt;code&gt;void (*)(int)&lt;/code&gt; . Когда возвращается &lt;code&gt;&lt;a href=&quot;signal&quot;&gt;std::signal&lt;/a&gt;&lt;/code&gt; , указывает, что произошла ошибка.</target>
        </trans-unit>
        <trans-unit id="03d7158f8947427f81b002e1dd1993eed28a9ff7" translate="yes" xml:space="preserve">
          <source>A value such that &lt;code&gt;a&lt;/code&gt; is partitioned with respect to &lt;code&gt;!c(ku, r)&lt;/code&gt;</source>
          <target state="translated">Значение, такое, что &lt;code&gt;a&lt;/code&gt; делится на &lt;code&gt;!c(ku, r)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="450945ae5d73489824ccfb0cd773638c26cd3654" translate="yes" xml:space="preserve">
          <source>A value such that &lt;code&gt;a&lt;/code&gt; is partitioned with respect to &lt;code&gt;c(r, ke)&lt;/code&gt; and &lt;code&gt;!c(ke, r)&lt;/code&gt;, with &lt;code&gt;c(r, ke)&lt;/code&gt; implying &lt;code&gt;!c(ke, r)&lt;/code&gt;</source>
          <target state="translated">Значение, такое, что &lt;code&gt;a&lt;/code&gt; делится на &lt;code&gt;c(r, ke)&lt;/code&gt; и &lt;code&gt;!c(ke, r)&lt;/code&gt; , причем &lt;code&gt;c(r, ke)&lt;/code&gt; подразумевает &lt;code&gt;!c(ke, r)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="66162c2a5d40aef1c22e1f7994ce56c76783a955" translate="yes" xml:space="preserve">
          <source>A value such that &lt;code&gt;a&lt;/code&gt; is partitioned with respect to &lt;code&gt;c(r,kl)&lt;/code&gt;, with &lt;code&gt;r&lt;/code&gt; the key value of &lt;code&gt;e&lt;/code&gt; and &lt;code&gt;e&lt;/code&gt; in &lt;code&gt;a&lt;/code&gt;</source>
          <target state="translated">Значение, такое, что &lt;code&gt;a&lt;/code&gt; разделен относительно &lt;code&gt;c(r,kl)&lt;/code&gt; , где &lt;code&gt;r&lt;/code&gt; - ключевое значение &lt;code&gt;e&lt;/code&gt; и &lt;code&gt;e&lt;/code&gt; в &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a0a71e388e98e2de2ca1e6729afcd2caf02f4c95" translate="yes" xml:space="preserve">
          <source>A value that is identical for all &lt;code&gt;type_info&lt;/code&gt; objects referring to the same type.</source>
          <target state="translated">Значение, идентичное для всех объектов &lt;code&gt;type_info&lt;/code&gt; , относящихся к одному и тому же типу.</target>
        </trans-unit>
        <trans-unit id="79bfc8c0189d75c8cec44ecc8d6396e58c45af93" translate="yes" xml:space="preserve">
          <source>A variable template declaration may appear at class scope, in which case it declares a static data member template. See &lt;a href=&quot;variable_template&quot;&gt;variable templates&lt;/a&gt; for details.</source>
          <target state="translated">Объявление шаблона переменной может появляться в области видимости класса, и в этом случае оно объявляет шаблон члена статических данных. Смотрите &lt;a href=&quot;variable_template&quot;&gt;переменные шаблоны&lt;/a&gt; для деталей.</target>
        </trans-unit>
        <trans-unit id="a00357cf9d6e102b6c1e5ad12063c42c54ad2ce7" translate="yes" xml:space="preserve">
          <source>A variable template defines a family of variables or static data members.</source>
          <target state="translated">Шаблон переменной определяет семейство переменных или статические члены данных.</target>
        </trans-unit>
        <trans-unit id="aff896d1642161992d5991ac4ba8de8003708a52" translate="yes" xml:space="preserve">
          <source>A variable template may be introduced by a template declaration at namespace scope, where declaration declares a variable.</source>
          <target state="translated">Шаблон переменной может быть введен с помощью шаблонного объявления в области пространства имен,где объявление объявляет переменную.</target>
        </trans-unit>
        <trans-unit id="09fc623a5cbacf9a90a9e712a74ec555cda701fd" translate="yes" xml:space="preserve">
          <source>A variadic class template can be instantiated with any number of template arguments:</source>
          <target state="translated">Шаблон переменного класса может быть инстанцирован любым количеством аргументов шаблона:</target>
        </trans-unit>
        <trans-unit id="1fb3820743def9d88fa6123aad6fc9bce3f38a75" translate="yes" xml:space="preserve">
          <source>A variadic function template can be called with any number of function arguments (the template arguments are deduced through &lt;a href=&quot;template_argument_deduction&quot;&gt;template argument deduction&lt;/a&gt;):</source>
          <target state="translated">Шаблон функции variadic может быть вызван с любым количеством аргументов функции (аргументы шаблона выводятся посредством &lt;a href=&quot;template_argument_deduction&quot;&gt;вывода аргумента шаблона&lt;/a&gt; ):</target>
        </trans-unit>
        <trans-unit id="bb6e304c2616213d182d17fab4792e56d3349945" translate="yes" xml:space="preserve">
          <source>A variant is not permitted to hold references, arrays, or the type &lt;code&gt;void&lt;/code&gt;. Empty variants are also ill-formed (&lt;code&gt;std::variant&amp;lt;&lt;a href=&quot;variant/monostate&quot;&gt;std::monostate&lt;/a&gt;&amp;gt;&lt;/code&gt; can be used instead).</source>
          <target state="translated">Вариант не может содержать ссылки, массивы или тип &lt;code&gt;void&lt;/code&gt; . Пустые варианты также плохо сформированы ( вместо них можно использовать &lt;code&gt;std::variant&amp;lt;&lt;a href=&quot;variant/monostate&quot;&gt;std::monostate&lt;/a&gt;&amp;gt;&lt;/code&gt; &amp;lt; std :: monostate &amp;gt; ).</target>
        </trans-unit>
        <trans-unit id="ce4af0ae9360b0d87edd912329cc74243aa60def" translate="yes" xml:space="preserve">
          <source>A variant is permitted to hold the same type more than once, and to hold differently cv-qualified versions of the same type.</source>
          <target state="translated">Допускается,чтобы один и тот же тип использовался более одного раза,а также чтобы один и тот же тип использовался в разных вариантах,удовлетворяющих требованиям cv.</target>
        </trans-unit>
        <trans-unit id="ea9112a4205a8e149b6d870c2538c2387fcc45a2" translate="yes" xml:space="preserve">
          <source>A variant may become valueless in the following situations:</source>
          <target state="translated">Вариант может стать бесполезным в следующих ситуациях:</target>
        </trans-unit>
        <trans-unit id="360ab0f56da776d903fad4cd3c7802b6cff86bff" translate="yes" xml:space="preserve">
          <source>A variant that is valueless by exception is treated as being in an invalid state: &lt;a href=&quot;index&quot;&gt;index&lt;/a&gt; returns &lt;a href=&quot;variant_npos&quot;&gt;variant_npos&lt;/a&gt;, &lt;a href=&quot;get&quot;&gt;get&lt;/a&gt; and &lt;a href=&quot;visit&quot;&gt;visit&lt;/a&gt; throw &lt;a href=&quot;bad_variant_access&quot;&gt;bad_variant_access&lt;/a&gt;.</source>
          <target state="translated">Вариант, который по исключению не имеет значения, обрабатывается как находящийся в недопустимом состоянии: &lt;a href=&quot;index&quot;&gt;индекс&lt;/a&gt; возвращает &lt;a href=&quot;variant_npos&quot;&gt;option_npos&lt;/a&gt; , &lt;a href=&quot;get&quot;&gt;get&lt;/a&gt; и &lt;a href=&quot;visit&quot;&gt;visit&lt;/a&gt; throw &lt;a href=&quot;bad_variant_access&quot;&gt;bad_variant_access&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d13acd0a8aed6cefb7c9972fe8dbd4991eb6d5ec" translate="yes" xml:space="preserve">
          <source>A vector of strings can be sorted according to a non-default locale by using the locale object as comparator:</source>
          <target state="translated">Вектор строк может быть отсортирован по локали не по умолчанию,используя в качестве компаратора объект локали:</target>
        </trans-unit>
        <trans-unit id="c3e281fb8afe5cc3b522bbdd748cec3c0126f3da" translate="yes" xml:space="preserve">
          <source>A very common implementation-defined form of main() has a third argument (in addition to &lt;code&gt;argc&lt;/code&gt; and &lt;code&gt;argv&lt;/code&gt;), of type &lt;code&gt;char*[]&lt;/code&gt;, pointing at &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/exec.html&quot;&gt;an array of pointers to the execution environment variables&lt;/a&gt;.</source>
          <target state="translated">Очень распространенная форма реализации main () имеет третий аргумент (в дополнение к &lt;code&gt;argc&lt;/code&gt; и &lt;code&gt;argv&lt;/code&gt; ) типа &lt;code&gt;char*[]&lt;/code&gt; , указывающий на &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/exec.html&quot;&gt;массив указателей на переменные среды выполнения&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9ec66bbac0bdedd0761cb72a1751288a98eb028c" translate="yes" xml:space="preserve">
          <source>A very common implementation-defined form of main() has a third argument (in addition to &lt;code&gt;argc&lt;/code&gt; and &lt;code&gt;argv&lt;/code&gt;), of type &lt;code&gt;char*[]&lt;/code&gt;, pointing at &lt;a href=&quot;https://pubs.opengroup.org/onlinepubs/9699919799/functions/exec.html&quot;&gt;an array of pointers to the execution environment variables&lt;/a&gt;.</source>
          <target state="translated">Очень распространенная форма main (), определяемая реализацией, имеет третий аргумент (в дополнение к &lt;code&gt;argc&lt;/code&gt; и &lt;code&gt;argv&lt;/code&gt; ) типа &lt;code&gt;char*[]&lt;/code&gt; , указывающий на &lt;a href=&quot;https://pubs.opengroup.org/onlinepubs/9699919799/functions/exec.html&quot;&gt;массив указателей на переменные среды выполнения&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6cef77f8c0ffb4916f8bc0498dc7440820ca8d36" translate="yes" xml:space="preserve">
          <source>A zero-initialized pointer is the null pointer value of its type, even if the value of the null pointer is not integral zero.</source>
          <target state="translated">Нулевой указатель-это значение нулевого указателя своего типа,даже если значение нулевого указателя не является интегральным нулем.</target>
        </trans-unit>
        <trans-unit id="7be129f416228534857a690cd4c38374c5515373" translate="yes" xml:space="preserve">
          <source>A, and B</source>
          <target state="translated">А и Б</target>
        </trans-unit>
        <trans-unit id="a5e35ae614f82259bcebce61eb00073751f2e388" translate="yes" xml:space="preserve">
          <source>A, and B is a &lt;code&gt;memory_order_seq_cst&lt;/code&gt; operation, then X precedes B in S d) if a &lt;code&gt;memory_order_seq_cst&lt;/code&gt; fence X</source>
          <target state="translated">A и B - операция &lt;code&gt;memory_order_seq_cst&lt;/code&gt; , тогда X предшествует B в S d), если &lt;code&gt;memory_order_seq_cst&lt;/code&gt; ограничивает X</target>
        </trans-unit>
        <trans-unit id="48a01a12d57f9009c8dea86e8610f3bdea642dd4" translate="yes" xml:space="preserve">
          <source>A. Williams (2012), &quot;C++ concurrency in action&quot; 9.2.4 Interrupting a wait on std::condition_variable_any</source>
          <target state="translated">A.Уильямс (2012),&quot;С++параллельность в действии&quot; 9.2.4 Прерывание ожидания на std::condition_variable_any</target>
        </trans-unit>
        <trans-unit id="6b4fe715ea89fb871c5a975d173f10a5adf57e7c" translate="yes" xml:space="preserve">
          <source>A1, A2, A3,... is a possibly empty list of arbitrary expressions, except the comma operator is not allowed at the top level to avoid ambiguity.</source>
          <target state="translated">A1,A2,A3,...возможно,пустой список произвольных выражений,за исключением того,что оператор запятая не допускается на верхнем уровне во избежание двусмысленности.</target>
        </trans-unit>
        <trans-unit id="de2c49eaafb50b14e68d760cacef2f0ba0ba8f45" translate="yes" xml:space="preserve">
          <source>ADL</source>
          <target state="translated">ADL</target>
        </trans-unit>
        <trans-unit id="cd5086cb4e7d0efbc40ccb220af4c1d024f33775" translate="yes" xml:space="preserve">
          <source>ADL can find a &lt;a href=&quot;friend&quot;&gt;friend function&lt;/a&gt; (typically, an overloaded operator) that is defined entirely within a class or class template, even if it was never declared at namespace level.</source>
          <target state="translated">ADL может найти функцию &lt;a href=&quot;friend&quot;&gt;друга&lt;/a&gt; (как правило, перегруженный оператор), которая полностью определена внутри класса или шаблона класса, даже если она никогда не была объявлена ​​на уровне пространства имен.</target>
        </trans-unit>
        <trans-unit id="c2f934cb8cab6c1b3af0d4f2fdd824eabafb6bf4" translate="yes" xml:space="preserve">
          <source>AND</source>
          <target state="translated">AND</target>
        </trans-unit>
        <trans-unit id="daf2a98f5077d337e35a18a770cad80d218e9ca5" translate="yes" xml:space="preserve">
          <source>ARABIC LIGATURE NOON WITH JEEM WITH YEH FINAL FORM</source>
          <target state="translated">АРАБСКАЯ ЛИГАТУРА В ПОЛДЕНЬ С ДЖИМОМ В ОКОНЧАТЕЛЬНОЙ ФОРМЕ</target>
        </trans-unit>
        <trans-unit id="5f8c72f94f6217e6dad861d24c88516ef9cd816b" translate="yes" xml:space="preserve">
          <source>ARABIC LIGATURE SALLA USED AS KORANIC STOP SIGN ISOLATED FORM -</source>
          <target state="translated">АРАБСКАЯ ЛИГАТУРА САЛЛА,ИСПОЛЬЗУЕМАЯ В КАЧЕСТВЕ КОРАНИЧЕСКОГО СТОП-СИГНАЛА В ИЗОЛИРОВАННОЙ ФОРМЕ -</target>
        </trans-unit>
        <trans-unit id="af1d8ae2aa108f95b9b57f28478231da2a606638" translate="yes" xml:space="preserve">
          <source>ARABIC LIGATURE TEH WITH JEEM WITH MEEM INITIAL FORM -</source>
          <target state="translated">АРАБСКАЯ ЛИГАТУРА С ДЖИМОМ С МОИМИ ПЕРВОНАЧАЛЬНОЙ ФОРМОЙ -</target>
        </trans-unit>
        <trans-unit id="187459c12cbce645deb52d74f3d6152a7a9a17fc" translate="yes" xml:space="preserve">
          <source>ASCII Chart</source>
          <target state="translated">ASCII-график</target>
        </trans-unit>
        <trans-unit id="6b85275355e86325dde0c35693852c2d7820c750" translate="yes" xml:space="preserve">
          <source>ASCII chart</source>
          <target state="translated">ASCII-график</target>
        </trans-unit>
        <trans-unit id="6ff2c765d8c7f7f1624b70244d10913facb7ae0b" translate="yes" xml:space="preserve">
          <source>ASCII values</source>
          <target state="translated">ASCII-значения</target>
        </trans-unit>
        <trans-unit id="63e21a0c9c10fbf518b0166eb437a67f1ed962cd" translate="yes" xml:space="preserve">
          <source>ATOMIC_FLAG_INIT</source>
          <target state="translated">ATOMIC_FLAG_INIT</target>
        </trans-unit>
        <trans-unit id="0b0620452fea1cd6ef04952a1260146f273e310f" translate="yes" xml:space="preserve">
          <source>ATOMIC_VAR_INIT</source>
          <target state="translated">ATOMIC_VAR_INIT</target>
        </trans-unit>
        <trans-unit id="435b6099910c97d9bc8e078e332560e92819291f" translate="yes" xml:space="preserve">
          <source>Abandons the shared state and destroys the stored task object.</source>
          <target state="translated">Бросает разделяемое состояние и уничтожает хранимый объект задачи.</target>
        </trans-unit>
        <trans-unit id="36e1c539cc780bc605cb01b3fddc5d8db9c3b6ab" translate="yes" xml:space="preserve">
          <source>Abandons the shared state:</source>
          <target state="translated">Бросает общее государство:</target>
        </trans-unit>
        <trans-unit id="e7becc73c7eaff031859fb120395433f96283795" translate="yes" xml:space="preserve">
          <source>Abbreviated function template</source>
          <target state="translated">шаблон сокращённого функционала</target>
        </trans-unit>
        <trans-unit id="019202b59ca73881cfaab35533cb5a7033c39a80" translate="yes" xml:space="preserve">
          <source>Abbreviated function templates can be specialized like all function templates.</source>
          <target state="translated">Шаблоны сокращенных функций могут быть специализированными,как и все шаблоны функций.</target>
        </trans-unit>
        <trans-unit id="fd2f1ad3f3e244485410235abcc0dcd9d528402f" translate="yes" xml:space="preserve">
          <source>Absolute value of &lt;code&gt;d&lt;/code&gt;.</source>
          <target state="translated">Абсолютное значение &lt;code&gt;d&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1b11f0b716439740a7eef7b0954e8e03f2442de7" translate="yes" xml:space="preserve">
          <source>Abstract classes are used to represent general concepts (for example, Shape, Animal), which can be used as base classes for concrete classes (for example, Circle, Dog).</source>
          <target state="translated">Абстрактные классы используются для представления общих понятий (например,Форма,Животное),которые могут быть использованы в качестве базовых классов для конкретных классов (например,Круг,Собака).</target>
        </trans-unit>
        <trans-unit id="496f013275ea0cccdde9e4ce5e27272837e636f5" translate="yes" xml:space="preserve">
          <source>Abstract types cannot be used as parameter types, as function return types, or as the type of an explicit conversion (note this is checked at the point of definition and function call, since at the point of function declaration parameter and return type may be incomplete).</source>
          <target state="translated">Абстрактные типы не могут использоваться как типы параметров,как типы возвращаемых функций или как тип явного приведения (обратите внимание,что это проверяется в точке определения и вызова функции,т.к.в точке объявления функции параметр и тип возвращаемой функции могут быть неполными).</target>
        </trans-unit>
        <trans-unit id="8fda6cf2aae5ca82e8dc635a5cfbd7ff01d1ac31" translate="yes" xml:space="preserve">
          <source>Abstraction</source>
          <target state="translated">Abstraction</target>
        </trans-unit>
        <trans-unit id="fe89f3fca6949588976c79493bd13c9b36f00658" translate="yes" xml:space="preserve">
          <source>Access checking for the names used in &lt;a href=&quot;default_arguments&quot;&gt;default function arguments&lt;/a&gt; as well as in the default &lt;a href=&quot;template_parameters#Default_template_arguments&quot;&gt;template parameters&lt;/a&gt; is performed at the point of declaration, not at the point of use.</source>
          <target state="translated">Проверка доступа для имен, используемых в &lt;a href=&quot;default_arguments&quot;&gt;аргументах функции&lt;/a&gt; по умолчанию, а также в параметрах &lt;a href=&quot;template_parameters#Default_template_arguments&quot;&gt;шаблона&lt;/a&gt; по умолчанию , выполняется в точке объявления, а не в точке использования.</target>
        </trans-unit>
        <trans-unit id="9de67dfb6d06413cdc219824a0f3f88445b9f32c" translate="yes" xml:space="preserve">
          <source>Access out of bounds</source>
          <target state="translated">Доступ вне пределов</target>
        </trans-unit>
        <trans-unit id="64d102e911590ffe48aba24684384d363cf0b36b" translate="yes" xml:space="preserve">
          <source>Access outside of lifetime</source>
          <target state="translated">Доступ вне срока службы</target>
        </trans-unit>
        <trans-unit id="ff2202db9230ee307101c952851e1360ff1ce903" translate="yes" xml:space="preserve">
          <source>Access overhead: In pImpl, each call to a private member function indirects through a pointer. Each access to a public member made by a private member indirects through another pointer. Both indirections cross translation unit boundaries and so can only be optimized out by link-time optimization. Note that OO factory requires indirection across translation units to access both public data and implementation detail, and offers even fewer opportunities for the link time optimizer due to virtual dispatch.</source>
          <target state="translated">Доступ над головой:В pImpl каждый вызов функции приватного участника поступает через указатель.Каждый доступ к публичному пользователю,сделанный частным пользователем через другой указатель.Обе индиректы пересекают границы единиц трансляции и поэтому могут быть оптимизированы только с помощью оптимизации во времени линка.Обратите внимание,что на предприятии OOO для доступа как к открытым данным,так и к деталям реализации,необходима передача через все модули трансляции,и еще меньше возможностей для оптимизатора времени соединения благодаря виртуальной рассылке.</target>
        </trans-unit>
        <trans-unit id="41dcddad26f26d0b23476e3af19f8e0cff1f9f7e" translate="yes" xml:space="preserve">
          <source>Access permissions model &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/sys_stat.h.html&quot;&gt;POSIX permission bits&lt;/a&gt;, and any individual file permissions (as reported by &lt;a href=&quot;status&quot;&gt;status&lt;/a&gt;) are a combination of some of the following bits:</source>
          <target state="translated">&lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/sys_stat.h.html&quot;&gt;Биты&lt;/a&gt; разрешений POSIX модели прав доступа и любые права доступа к отдельным файлам (согласно &lt;a href=&quot;status&quot;&gt;состоянию&lt;/a&gt; ) представляют собой комбинацию некоторых из следующих битов:</target>
        </trans-unit>
        <trans-unit id="ff48fcdd36448626dfca91c0959a95a136068169" translate="yes" xml:space="preserve">
          <source>Access permissions model &lt;a href=&quot;https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/sys_stat.h.html&quot;&gt;POSIX permission bits&lt;/a&gt;, and any individual file permissions (as reported by &lt;a href=&quot;status&quot;&gt;status&lt;/a&gt;) are a combination of some of the following bits:</source>
          <target state="translated">&lt;a href=&quot;https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/sys_stat.h.html&quot;&gt;Биты&lt;/a&gt; разрешений POSIX модели разрешений на доступ и любые индивидуальные права доступа к файлам (в зависимости от &lt;a href=&quot;status&quot;&gt;статуса&lt;/a&gt; ) представляют собой комбинацию некоторых из следующих битов:</target>
        </trans-unit>
        <trans-unit id="b29695d27ada4464e68e5f7e3d3cd693fa6cadcf" translate="yes" xml:space="preserve">
          <source>Access rules for the names of &lt;a href=&quot;virtual&quot;&gt;virtual functions&lt;/a&gt; are checked at the call point using the type of the expression used to denote the object for which the member function is called. The access of the final overrider is ignored.</source>
          <target state="translated">Правила доступа для имен &lt;a href=&quot;virtual&quot;&gt;виртуальных функций&lt;/a&gt; проверяются в точке вызова с использованием типа выражения, используемого для обозначения объекта, для которого вызывается функция-член. Доступ к окончательному переопределению игнорируется.</target>
        </trans-unit>
        <trans-unit id="172f15fcb1759434b4e5cac298998c9f90e5367d" translate="yes" xml:space="preserve">
          <source>Access specifiers</source>
          <target state="translated">Спецификаторы доступа</target>
        </trans-unit>
        <trans-unit id="fd9b61139d61fe4a3ad562d5c3fb1467d5f0fb25" translate="yes" xml:space="preserve">
          <source>Access specifiers give the author of the class the ability to decide which class members are accessible to the users of the class (that is, the</source>
          <target state="translated">Спецификаторы доступа дают автору класса возможность определить,какие члены класса доступны пользователям класса (т.е.</target>
        </trans-unit>
        <trans-unit id="b5f1627a2f9ef35b0cad78d685d46c26ac79a8ba" translate="yes" xml:space="preserve">
          <source>Access to a non-static data member or a call to a non-static member function.</source>
          <target state="translated">Доступ к нестатическим данным или вызов нестатической функции.</target>
        </trans-unit>
        <trans-unit id="1632238dd01e0d2949d4e0ad89257742628b773a" translate="yes" xml:space="preserve">
          <source>Access to pointer passed to realloc</source>
          <target state="translated">Доступ к указателю,переданному realloc</target>
        </trans-unit>
        <trans-unit id="27559787dd122b923d06b7298557d1cd2c568a23" translate="yes" xml:space="preserve">
          <source>Access to the &lt;code&gt;p&lt;/code&gt;'s deleter. If the shared pointer &lt;code&gt;p&lt;/code&gt; owns a deleter of type cv-unqualified &lt;code&gt;Deleter&lt;/code&gt; (e.g. if it was created with one of the constructors that take a deleter as a parameter), then returns a pointer to the deleter. Otherwise, returns a null pointer.</source>
          <target state="translated">Доступ к &lt;code&gt;p&lt;/code&gt; &amp;laquo;S Deleter. Если совместно используемый указатель &lt;code&gt;p&lt;/code&gt; владеет средством удаления типа cv-unqualified &lt;code&gt;Deleter&lt;/code&gt; (например, если он был создан с одним из конструкторов, которые принимают средство удаления в качестве параметра), тогда возвращается указатель на средство удаления. В противном случае возвращает нулевой указатель.</target>
        </trans-unit>
        <trans-unit id="5c1d13d1c544b3feecb6e442b5b9a73c51c6b267" translate="yes" xml:space="preserve">
          <source>Access to the same shared state from multiple threads is safe if each thread does it through its own copy of a &lt;code&gt;shared_future&lt;/code&gt; object.</source>
          <target state="translated">Доступ к одному и тому же общему состоянию из нескольких потоков безопасен, если каждый поток делает это через собственную копию объекта &lt;code&gt;shared_future&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f563d2f693e12ab63ee51309db6c0dd439835d3c" translate="yes" xml:space="preserve">
          <source>Accesses a member of its operand.</source>
          <target state="translated">получает доступ к члену его операнда.</target>
        </trans-unit>
        <trans-unit id="a42b2fe3c4d5fcc9a9d311beb7c3efb130c09b8a" translate="yes" xml:space="preserve">
          <source>Accesses the bit at position &lt;code&gt;pos&lt;/code&gt;. The first version returns the value of the bit, the second version returns an object of type &lt;code&gt;&lt;a href=&quot;reference&quot;&gt;std::bitset::reference&lt;/a&gt;&lt;/code&gt; that allows modification of the value.</source>
          <target state="translated">Доступ к биту в положении &lt;code&gt;pos&lt;/code&gt; . Первая версия возвращает значение бита, вторая версия возвращает объект типа &lt;code&gt;&lt;a href=&quot;reference&quot;&gt;std::bitset::reference&lt;/a&gt;&lt;/code&gt; который позволяет изменять значение.</target>
        </trans-unit>
        <trans-unit id="d60917183a0203e125a2a367082f7e505a1b54cc" translate="yes" xml:space="preserve">
          <source>Accesses the contained value.</source>
          <target state="translated">Доступ к содержащемуся значению.</target>
        </trans-unit>
        <trans-unit id="5ffc054a82694395488926c5d88d20377f2fee4f" translate="yes" xml:space="preserve">
          <source>Accesses the file permissions information.</source>
          <target state="translated">Получает доступ к информации о файловых разрешениях.</target>
        </trans-unit>
        <trans-unit id="0faa3d14d648895a9103231a47e67306cf3658f8" translate="yes" xml:space="preserve">
          <source>Accesses the file type information.</source>
          <target state="translated">Доступ к информации о типе файла.</target>
        </trans-unit>
        <trans-unit id="9ab9ff8b7be4b7d40eb92e8afba99b14b56097f9" translate="yes" xml:space="preserve">
          <source>Accesses the imaginary part of the complex number.</source>
          <target state="translated">получает доступ к воображаемой части комплексного номера.</target>
        </trans-unit>
        <trans-unit id="6c9900004652bab063edd448abb4e13e10ff694e" translate="yes" xml:space="preserve">
          <source>Accesses the index stored in &lt;code&gt;*this&lt;/code&gt;.</source>
          <target state="translated">Доступ к индексу, хранящемуся в &lt;code&gt;*this&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f3c82d4ce7723e142d0946770db58f80f216a936" translate="yes" xml:space="preserve">
          <source>Accesses the name and target of this &lt;code&gt;link&lt;/code&gt; object.</source>
          <target state="translated">Получает доступ к имени и цели этого объекта &lt;code&gt;link&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ad5cf92f478d0439f59cdb4880f47ebacaf46e23" translate="yes" xml:space="preserve">
          <source>Accesses the native handle of &lt;code&gt;*this&lt;/code&gt;.</source>
          <target state="translated">Получает доступ к собственному дескриптору &lt;code&gt;*this&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9d7d833d3713305bce90c91948acf875f0c20ba4" translate="yes" xml:space="preserve">
          <source>Accesses the native path name as a character string.</source>
          <target state="translated">Обращается к нативному имени пути в виде строки символов.</target>
        </trans-unit>
        <trans-unit id="3ae496a866ebcdc4db51cd8794d1e50d8d500069" translate="yes" xml:space="preserve">
          <source>Accesses the pointed-to &lt;a href=&quot;../directory_entry&quot;&gt;&lt;code&gt;directory_entry&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Доступ к указанному &lt;a href=&quot;../directory_entry&quot;&gt; &lt;code&gt;directory_entry&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9823697b16ef01bf1ebfdd504cd02cc048fbff41" translate="yes" xml:space="preserve">
          <source>Accesses the real part of the complex number.</source>
          <target state="translated">Доступ к реальной части номера комплекса.</target>
        </trans-unit>
        <trans-unit id="bbd2d3ce5c26cd90201155a08a10040ce8faa66b" translate="yes" xml:space="preserve">
          <source>Accessibility applies to all names with no regard to their origin, so a name introduced by a &lt;a href=&quot;typedef&quot;&gt;typedef&lt;/a&gt; or &lt;a href=&quot;using_declaration&quot;&gt;using declarations&lt;/a&gt; is checked, not the name it refers to.</source>
          <target state="translated">Доступность применяется ко всем именам независимо от их происхождения, поэтому проверяется имя, введенное &lt;a href=&quot;typedef&quot;&gt;typedef&lt;/a&gt; или &lt;a href=&quot;using_declaration&quot;&gt;использующим объявления&lt;/a&gt; , а не имя, к которому оно относится.</target>
        </trans-unit>
        <trans-unit id="db5f1eeeca9d3c68907d330e642c8ec9d5a0116f" translate="yes" xml:space="preserve">
          <source>Accessing an object using an expression of a type other than the type with which it was created is undefined behavior in many cases, see &lt;a href=&quot;reinterpret_cast#Type_aliasing&quot;&gt;reinterpret_cast&lt;/a&gt; for the list of exceptions and examples.</source>
          <target state="translated">Доступ к объекту с использованием выражения, отличного от типа, с которым он был создан, во многих случаях является неопределенным поведением, см. &lt;a href=&quot;reinterpret_cast#Type_aliasing&quot;&gt;Reinterpret_cast&lt;/a&gt; для списка исключений и примеров.</target>
        </trans-unit>
        <trans-unit id="43edbdec6f4616d56db2ed67623f9b6b877668ea" translate="yes" xml:space="preserve">
          <source>Accessing the variable during initialization from another thread, even through an atomic operation, is a data race (it may happen if the address is immediately passed to another thread with a &lt;code&gt;&lt;a href=&quot;memory_order&quot;&gt;std::memory_order_relaxed&lt;/a&gt;&lt;/code&gt; operation).</source>
          <target state="translated">Доступ к переменной во время инициализации из другого потока, даже через атомарную операцию, является гонкой данных (это может произойти, если адрес немедленно передается другому потоку с помощью операции &lt;code&gt;&lt;a href=&quot;memory_order&quot;&gt;std::memory_order_relaxed&lt;/a&gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="bd21f9aade4e041d6127535e2103b7265328e814" translate="yes" xml:space="preserve">
          <source>Acquire operation</source>
          <target state="translated">Приобрести операцию</target>
        </trans-unit>
        <trans-unit id="336eaf1465ee3c86483dca958f5b3f81e8c35309" translate="yes" xml:space="preserve">
          <source>Acquires ownership of the given mutex &lt;code&gt;m&lt;/code&gt;.</source>
          <target state="translated">Приобретает право собственности на данный мьютекс &lt;code&gt;m&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a0bfcec1da334e9014a69ecff78b70a46245c533" translate="yes" xml:space="preserve">
          <source>Acquires ownership of the given mutexes &lt;code&gt;m&lt;/code&gt;.</source>
          <target state="translated">Приобретает право собственности на данные мьютексы &lt;code&gt;m&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c865fe856f24b54f5a468d814de44d24b3ad8da2" translate="yes" xml:space="preserve">
          <source>Acquires shared ownership of the mutex. If another thread is holding the mutex in exclusive ownership, a call to &lt;code&gt;lock_shared&lt;/code&gt; will block execution until shared ownership can be acquired.</source>
          <target state="translated">Приобретает долевое владение мьютексом. Если другой поток удерживает мьютекс в исключительном владении, вызов &lt;code&gt;lock_shared&lt;/code&gt; будет блокировать выполнение, пока не будет получено общее владение.</target>
        </trans-unit>
        <trans-unit id="116672ae6ceb211b89b5cc24d53045f44bb76b12" translate="yes" xml:space="preserve">
          <source>Acronyms</source>
          <target state="translated">Acronyms</target>
        </trans-unit>
        <trans-unit id="894e0d0ca601136dd7488a48cc4e246850d2e574" translate="yes" xml:space="preserve">
          <source>Action if file</source>
          <target state="translated">Действие,если файл</target>
        </trans-unit>
        <trans-unit id="5405a9d57e6b63ab5821d9588dde26920a308e00" translate="yes" xml:space="preserve">
          <source>Action if file already exists</source>
          <target state="translated">Действие,если файл уже существует</target>
        </trans-unit>
        <trans-unit id="c3c1db410576ecf3d85988b0535501a3dc1d020f" translate="yes" xml:space="preserve">
          <source>Action if file does not exist</source>
          <target state="translated">Действие,если файл не существует</target>
        </trans-unit>
        <trans-unit id="a7817b78f6b68e579f4e4537bfed1875e7ae184f" translate="yes" xml:space="preserve">
          <source>Actual implementations vary:</source>
          <target state="translated">Фактические внедрения варьируются:</target>
        </trans-unit>
        <trans-unit id="3ca7e3d2e4ac34bc514652447560887a72b3f649" translate="yes" xml:space="preserve">
          <source>Adaptors</source>
          <target state="translated">Adaptors</target>
        </trans-unit>
        <trans-unit id="fb414d455da6b9468629ebcfdfce20d9ea740f72" translate="yes" xml:space="preserve">
          <source>Adding constexpr modifiers to &lt;code&gt;&lt;a href=&quot;iterator/reverse_iterator&quot;&gt;std::reverse_iterator&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;iterator/move_iterator&quot;&gt;std::move_iterator&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;container/array&quot;&gt;std::array&lt;/a&gt;&lt;/code&gt; and &lt;a href=&quot;iterator#Container_access&quot;&gt;range access&lt;/a&gt;</source>
          <target state="translated">Добавление модификаторов constexpr в &lt;code&gt;&lt;a href=&quot;iterator/reverse_iterator&quot;&gt;std::reverse_iterator&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;iterator/move_iterator&quot;&gt;std::move_iterator&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;container/array&quot;&gt;std::array&lt;/a&gt;&lt;/code&gt; и &lt;a href=&quot;iterator#Container_access&quot;&gt;range access&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f9c64c7ebe5a611a1f12ffc12fb7a8366d9e1fdc" translate="yes" xml:space="preserve">
          <source>Adding heterogeneous comparison lookup to associative containers</source>
          <target state="translated">Добавление гетерогенного сравнительного поиска в ассоциативные контейнеры</target>
        </trans-unit>
        <trans-unit id="ad005a38d417aa5d21ad05bcc3397517559e1e10" translate="yes" xml:space="preserve">
          <source>Adding heterogeneous comparison lookup to unordered associative containers</source>
          <target state="translated">Добавление гетерогенного сравнительного поиска в неупорядоченные ассоциативные контейнеры</target>
        </trans-unit>
        <trans-unit id="a6dea03cb51c5650f791a12987ca0df26adb5602" translate="yes" xml:space="preserve">
          <source>Adding pre-calculated hash value lookup to unordered associative containers</source>
          <target state="translated">Добавление поиска предварительно рассчитанного хеш-значения в неупорядоченные ассоциативные контейнеры</target>
        </trans-unit>
        <trans-unit id="87ed11c26edf58b14803d392bf82cd48a91e96b8" translate="yes" xml:space="preserve">
          <source>Adding, removing and moving the elements within the list or across several lists does not invalidate the iterators or references. An iterator is invalidated only when the corresponding element is deleted.</source>
          <target state="translated">Добавление,удаление и перемещение элементов внутри списка или по нескольким спискам не делает недействительными итераторы или ссылки.Итератор аннулируется только при удалении соответствующего элемента.</target>
        </trans-unit>
        <trans-unit id="98f2660c67411bcd6814bc7ce1f2e850dfc897be" translate="yes" xml:space="preserve">
          <source>Adding, removing and moving the elements within the list, or across several lists, does not invalidate the iterators currently referring to other elements in the list. However, an iterator or reference referring to an element is invalidated when the corresponding element is removed (via &lt;code&gt;&lt;a href=&quot;forward_list/erase_after&quot;&gt;erase_after&lt;/a&gt;&lt;/code&gt;) from the list.</source>
          <target state="translated">Добавление, удаление и перемещение элементов в списке или в нескольких списках не делает недействительными итераторы, которые в настоящее время ссылаются на другие элементы в списке. Однако итератор или ссылка, ссылающаяся на элемент, становится недействительной, когда соответствующий элемент удаляется (через &lt;code&gt;&lt;a href=&quot;forward_list/erase_after&quot;&gt;erase_after&lt;/a&gt;&lt;/code&gt; ) из списка.</target>
        </trans-unit>
        <trans-unit id="48911a7386b2baa20a76ef9e342562ca04e9c341" translate="yes" xml:space="preserve">
          <source>Addition and subtraction</source>
          <target state="translated">Добавление и вычитание</target>
        </trans-unit>
        <trans-unit id="5c20b1f1d3dccc5fc33df625c9821015eb0d18af" translate="yes" xml:space="preserve">
          <source>Additional basic types and macros</source>
          <target state="translated">Дополнительные основные типы и макросы</target>
        </trans-unit>
        <trans-unit id="dc459b3781fd1c39294a64216e4b94c9615d87b0" translate="yes" xml:space="preserve">
          <source>Additional behavior may be defined by the implementations for file systems which append additional elements (such as alternate data streams or partitioned dataset names) to extensions.</source>
          <target state="translated">Дополнительное поведение может быть определено реализациями для файловых систем,которые добавляют дополнительные элементы (такие как альтернативные потоки данных или имена разделённых наборов данных)к расширениям.</target>
        </trans-unit>
        <trans-unit id="a9a945aa19333f0b54ff5676b6d9de2643f1b76b" translate="yes" xml:space="preserve">
          <source>Additional classifications such as &lt;code&gt;&quot;jdigit&quot;&lt;/code&gt; or &lt;code&gt;&quot;jkanji&quot;&lt;/code&gt; may be provided by system-supplied locales (in which case they are also accessible through &lt;code&gt;&lt;a href=&quot;../../string/wide/wctype&quot;&gt;std::wctype&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">Дополнительные классификации, такие как &lt;code&gt;&quot;jdigit&quot;&lt;/code&gt; или &lt;code&gt;&quot;jkanji&quot;&lt;/code&gt; , могут быть предоставлены системными локалями (в этом случае они также доступны через &lt;code&gt;&lt;a href=&quot;../../string/wide/wctype&quot;&gt;std::wctype&lt;/a&gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="ed64694f365b81d351dbd520c43964630a71e79f" translate="yes" xml:space="preserve">
          <source>Additional concepts can be found in &lt;a href=&quot;algorithm/ranges#Algorithm_concepts_and_utilities&quot;&gt;the algorithms library&lt;/a&gt; and &lt;a href=&quot;ranges#Range_concepts&quot;&gt;the ranges library&lt;/a&gt;.</source>
          <target state="translated">Дополнительные понятия могут быть найдены в &lt;a href=&quot;algorithm/ranges#Algorithm_concepts_and_utilities&quot;&gt;библиотеке алгоритмов&lt;/a&gt; и &lt;a href=&quot;ranges#Range_concepts&quot;&gt;библиотеки диапазонов&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="655988b4d376c12072cf6c9cdb9826fe22ae3e28" translate="yes" xml:space="preserve">
          <source>Additional execution policies may be provided by a standard library implementation (possible future additions may include &lt;code&gt;std::parallel::cuda&lt;/code&gt; and &lt;code&gt;std::parallel::opencl&lt;/code&gt;).</source>
          <target state="translated">Дополнительные политики выполнения могут быть предоставлены стандартной реализацией библиотеки (возможные будущие дополнения могут включать &lt;code&gt;std::parallel::cuda&lt;/code&gt; и &lt;code&gt;std::parallel::opencl&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="0b037de42fdfdd2746ba0eff4076bb78f7f07fda" translate="yes" xml:space="preserve">
          <source>Additional implementation-defined preparation may take place, which may call &lt;code&gt;setstate(failbit)&lt;/code&gt; (which may throw &lt;code&gt;&lt;a href=&quot;../ios_base/failure&quot;&gt;std::ios_base::failure&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">Может происходить дополнительная подготовка, определяемая реализацией, которая может вызывать &lt;code&gt;setstate(failbit)&lt;/code&gt; (который может &lt;code&gt;&lt;a href=&quot;../ios_base/failure&quot;&gt;std::ios_base::failure&lt;/a&gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="96549f1325a6bd11423df1587b53f51b1bda1aee" translate="yes" xml:space="preserve">
          <source>Additional macro constants, with names that begin with &lt;code&gt;LC_&lt;/code&gt; followed by at least one uppercase letter, may be defined in &lt;code&gt;&amp;lt;clocale&amp;gt;&lt;/code&gt;. For example, the POSIX specification requires LC_MESSAGES (which controls &lt;code&gt;&lt;a href=&quot;../io/c/perror&quot;&gt;std::perror&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../string/byte/strerror&quot;&gt;std::strerror&lt;/a&gt;&lt;/code&gt;), ISO/IEC 30112:2014 (&lt;a href=&quot;http://www.open-std.org/JTC1/SC35/WG5/docs/30112d10.pdf&quot;&gt;2014 draft&lt;/a&gt;) additionally defines LC_IDENTIFICATION, LC_XLITERATE, LC_NAME, LC_ADDRESS, LC_TELEPHONE, LC_PAPER, LC_MEASUREMENT, and LC_KEYBOARD, which are supported by the GNU C library (except for LC_XLITERATE).</source>
          <target state="translated">Дополнительные макро-константы, имена которых начинаются с &lt;code&gt;LC_&lt;/code&gt; , за которым следует хотя бы одна заглавная буква, могут быть определены в &lt;code&gt;&amp;lt;clocale&amp;gt;&lt;/code&gt; . Например, спецификация POSIX требует LC_MESSAGES (которая управляет &lt;code&gt;&lt;a href=&quot;../io/c/perror&quot;&gt;std::perror&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;../string/byte/strerror&quot;&gt;std::strerror&lt;/a&gt;&lt;/code&gt; ), ISO / IEC 30112: 2014 ( &lt;a href=&quot;http://www.open-std.org/JTC1/SC35/WG5/docs/30112d10.pdf&quot;&gt;черновик 2014 года&lt;/a&gt; ) дополнительно определяет LC_IDENTIFICATION, LC_XLITERATE, LC_NAME, LC_ADDRESS, LC_TELEPHONE, LC_PAPERBO, LC_MEASUREMENT, LC_MEASUREMENT и LC_MEASUREMENT , которые поддерживаются библиотекой GNU C (за исключением LC_XLITERATE).</target>
        </trans-unit>
        <trans-unit id="99f91b99c0d1f5963361dc127f6dbe9e38bb8903" translate="yes" xml:space="preserve">
          <source>Additional macros that begin with &lt;code&gt;FE_&lt;/code&gt; followed by uppercase letters, and have the type &lt;code&gt;const std::fenv_t*&lt;/code&gt;, may be supported by an implementation.</source>
          <target state="translated">Дополнительные макросы, которые начинаются с &lt;code&gt;FE_&lt;/code&gt; , за которым следуют заглавные буквы и имеют тип &lt;code&gt;const std::fenv_t*&lt;/code&gt; , могут поддерживаться реализацией.</target>
        </trans-unit>
        <trans-unit id="ef3d826dd03b81e684d86b842e89e92269929ee7" translate="yes" xml:space="preserve">
          <source>Additional numeric formats may be accepted by the currently installed C &lt;code&gt;&lt;a href=&quot;../../locale/setlocale&quot;&gt;locale&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Дополнительные числовые форматы могут быть приняты в настоящее время установлена C &lt;code&gt;&lt;a href=&quot;../../locale/setlocale&quot;&gt;locale&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0a5c5be417cfb6cd7d9118d383daf9f4ffd160e0" translate="yes" xml:space="preserve">
          <source>Additional overloads are provided for &lt;code&gt;float&lt;/code&gt;, &lt;code&gt;double&lt;/code&gt;, &lt;code&gt;long double&lt;/code&gt;, and all integer types, which are treated as complex numbers with zero imaginary component.</source>
          <target state="translated">Дополнительные перегрузки предоставляются для типов с &lt;code&gt;float&lt;/code&gt; , &lt;code&gt;double&lt;/code&gt; , &lt;code&gt;long double&lt;/code&gt; и всех целочисленных типов, которые рассматриваются как комплексные числа с нулевым мнимым компонентом.</target>
        </trans-unit>
        <trans-unit id="e8146529cfa6fa203e23e61b37cbdf2d37d4634b" translate="yes" xml:space="preserve">
          <source>Additional rounding modes may be supported by an implementation.</source>
          <target state="translated">Дополнительные режимы округления могут быть поддержаны реализацией.</target>
        </trans-unit>
        <trans-unit id="c51476def7086889d71b363945c5ad2e8649c02e" translate="yes" xml:space="preserve">
          <source>Additional signal names &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/signal.h.html&quot;&gt;are specified by POSIX&lt;/a&gt;.</source>
          <target state="translated">Дополнительные имена сигналов &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/signal.h.html&quot;&gt;указываются POSIX&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b8e3f88a4fb1a893c72eb1c76430bba45d521493" translate="yes" xml:space="preserve">
          <source>Additional signal names &lt;a href=&quot;https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/signal.h.html&quot;&gt;are specified by POSIX&lt;/a&gt;.</source>
          <target state="translated">Дополнительные имена сигналов &lt;a href=&quot;https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/signal.h.html&quot;&gt;указаны в POSIX&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7e1faa5440a863d95ba8c415f20385dfa4af6d4b" translate="yes" xml:space="preserve">
          <source>Additional support</source>
          <target state="translated">Дополнительная поддержка</target>
        </trans-unit>
        <trans-unit id="04f95216581ee9c47e04240f25828352cba16ddc" translate="yes" xml:space="preserve">
          <source>Additionally, &lt;code&gt;&lt;a href=&quot;iterator_traits&quot;&gt;std::iterator_traits&lt;/a&gt;&amp;lt;It&amp;gt;::iterator_&amp;shy;concept&lt;/code&gt; may be used to indicate conformance to the iterator concepts.</source>
          <target state="translated">Кроме того, &lt;code&gt;&lt;a href=&quot;iterator_traits&quot;&gt;std::iterator_traits&lt;/a&gt;&amp;lt;It&amp;gt;::iterator_&amp;shy;concept&lt;/code&gt; может быть использовано для указания соответствия на концепцию итераторов.</target>
        </trans-unit>
        <trans-unit id="f2e0dd9b924004af0072e53510ae5406eb8b489b" translate="yes" xml:space="preserve">
          <source>Additionally, &lt;code&gt;operator==&lt;/code&gt; and &lt;code&gt;operator!=&lt;/code&gt; are provided, either as members or as non-members, as required by &lt;a href=&quot;../named_req/inputiterator&quot;&gt;LegacyInputIterator&lt;/a&gt;.</source>
          <target state="translated">Кроме того, &lt;code&gt;operator==&lt;/code&gt; и &lt;code&gt;operator!=&lt;/code&gt; Предоставляются как члены или не участники, как того требует &lt;a href=&quot;../named_req/inputiterator&quot;&gt;LegacyInputIterator&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ce53b9c5df0fcfe1d1195f17fc25165a98c09650" translate="yes" xml:space="preserve">
          <source>Additionally, O(N) calls to the constructor of &lt;code&gt;value_type&lt;/code&gt;, where N is &lt;code&gt;cont.size()&lt;/code&gt;.</source>
          <target state="translated">Кроме того, O (N) вызывает конструктор &lt;code&gt;value_type&lt;/code&gt; , где N - это &lt;code&gt;cont.size()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7bee97038914dbaf49097462be0b6fa3a27587e0" translate="yes" xml:space="preserve">
          <source>Additionally, a specialization exists for every cv-qualified version of each arithmetic type, identical to the unqualified specialization, e.g. &lt;code&gt;std::numeric_limits&amp;lt;const int&amp;gt;&lt;/code&gt;, &lt;code&gt;std::numeric_limits&amp;lt;volatile int&amp;gt;&lt;/code&gt;, and &lt;code&gt;std::numeric_limits&amp;lt;const volatile int&amp;gt;&lt;/code&gt; are provided and are equivalent to &lt;code&gt;std::numeric_limits&amp;lt;int&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">Кроме того, существует специализация для каждой cv-квалифицированной версии каждого арифметического типа, идентичная неквалифицированной специализации, например, &lt;code&gt;std::numeric_limits&amp;lt;const int&amp;gt;&lt;/code&gt; , &lt;code&gt;std::numeric_limits&amp;lt;volatile int&amp;gt;&lt;/code&gt; и &lt;code&gt;std::numeric_limits&amp;lt;const volatile int&amp;gt;&lt;/code&gt; предоставляются и эквивалентны &lt;code&gt;std::numeric_limits&amp;lt;int&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="234e939fc46f7fc9566afc50a39f23e96624b23f" translate="yes" xml:space="preserve">
          <source>Additionally, an object &lt;code&gt;m&lt;/code&gt; of SharedMutex type supports another mode of ownership: shared. Multiple threads (or, more generally, execution agents) can simultaneously own this mutex in shared mode, but no thread may obtain shared ownership if there is a thread that owns it in exclusive mode and no thread may obtain exclusive ownership if there is a thread that owns it in shared mode. If more than implementation-defined number of threads (no less than 10000) hold a shared lock, another attempt to acquire the mutex in shared mode blocks until the number of shared owners drops down below that threshold.</source>
          <target state="translated">Кроме того, объект &lt;code&gt;m&lt;/code&gt; типа SharedMutex поддерживает другой режим владения: общий. Несколько потоков (или, в более общем смысле, агенты выполнения) могут одновременно владеть этим мьютексом в совместно используемом режиме, но ни один поток не может получить общее владение, если существует поток, которому принадлежит его в исключительном режиме, и ни один поток не может получить исключительное владение, если существует поток который владеет им в режиме совместного использования. Если больше чем определенное реализацией количество потоков (не менее 10000) удерживают общую блокировку, еще одна попытка получить мьютекс в блоках общего режима, пока количество общих владельцев не упадет ниже этого порога.</target>
        </trans-unit>
        <trans-unit id="4c21e2edf0f81a97ef8a624494e0c5a7e8d14423" translate="yes" xml:space="preserve">
          <source>Additionally, an object &lt;code&gt;m&lt;/code&gt; of SharedTimedMutex type supports timed shared operations:</source>
          <target state="translated">Кроме того, объект &lt;code&gt;m&lt;/code&gt; типа SharedTimedMutex поддерживает синхронизированные общие операции:</target>
        </trans-unit>
        <trans-unit id="6981bc51ea468df1e5cb432a395ddfc2e5d78804" translate="yes" xml:space="preserve">
          <source>Additionally, for an object &lt;code&gt;m&lt;/code&gt; of TimedMutex type:</source>
          <target state="translated">Дополнительно для объекта &lt;code&gt;m&lt;/code&gt; типа TimedMutex:</target>
        </trans-unit>
        <trans-unit id="ceefa22c95a1f23f16745529c429d1edf71f2d45" translate="yes" xml:space="preserve">
          <source>Additionally, for every sequence container, the constructor template that takes two input iterators and the member function template overloads of &lt;code&gt;insert()&lt;/code&gt;, &lt;code&gt;append()&lt;/code&gt;, &lt;code&gt;assign()&lt;/code&gt;, &lt;code&gt;replace()&lt;/code&gt; that take two input iterators do not participate in overload resolution if the corresponding template argument does not satisfy &lt;a href=&quot;inputiterator&quot;&gt;LegacyInputIterator&lt;/a&gt;.</source>
          <target state="translated">Кроме того, для каждого контейнера последовательности шаблон конструктора, который принимает два входных итератора, и перегрузки шаблона функции-члена: &lt;code&gt;insert()&lt;/code&gt; , &lt;code&gt;append()&lt;/code&gt; , &lt;code&gt;assign()&lt;/code&gt; , &lt;code&gt;replace()&lt;/code&gt; которые принимают два входных итератора, не участвуют в разрешении перегрузки, если соответствующий аргумент шаблона не удовлетворяет &lt;a href=&quot;inputiterator&quot;&gt;LegacyInputIterator&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="80407204b5613c93f4ff9eeeca0d87435272db5c" translate="yes" xml:space="preserve">
          <source>Additionally, if &lt;code&gt;floatfield != (ios_base::fixed | ios_base::scientific)&lt;/code&gt;, then(since C++11) precision modifier is added, set to &lt;code&gt;str.precision()&lt;/code&gt;</source>
          <target state="translated">Кроме того, если &lt;code&gt;floatfield != (ios_base::fixed | ios_base::scientific)&lt;/code&gt; , то (начиная с C ++ 11) добавляется модификатор точности, устанавливается в &lt;code&gt;str.precision()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="92ec030910d3cd27bfd60a9308eb60d240987aa3" translate="yes" xml:space="preserve">
          <source>Additionally, in order for the type &lt;code&gt;A&lt;/code&gt; to satisfy Allocator.</source>
          <target state="translated">Кроме того, для того, чтобы тип &lt;code&gt;A&lt;/code&gt; удовлетворял Allocator.</target>
        </trans-unit>
        <trans-unit id="e4c633a25d8deae1fd83be48e6f21fc0579f3bfe" translate="yes" xml:space="preserve">
          <source>Additionally, the following constants of this type are defined, which do not represent permissions:</source>
          <target state="translated">Кроме того,определяются следующие константы этого типа,которые не являются разрешениями:</target>
        </trans-unit>
        <trans-unit id="e3b85cc6377c854375953c6897c361f957b07ce5" translate="yes" xml:space="preserve">
          <source>Additionally, the resulting &lt;code&gt;std::atomic&amp;lt;&lt;i&gt;Floating&lt;/i&gt;&amp;gt;&lt;/code&gt; specialization has standard layout, a trivial default constructor, and a trivial destructor.</source>
          <target state="translated">Кроме того, результирующая специализация &lt;code&gt;std::atomic&amp;lt;&lt;i&gt;Floating&lt;/i&gt;&amp;gt;&lt;/code&gt; имеет стандартный макет, тривиальный конструктор по умолчанию и тривиальный деструктор.</target>
        </trans-unit>
        <trans-unit id="e8aaea245aabbd553929a2dc8693fcb475a09d9c" translate="yes" xml:space="preserve">
          <source>Additionally, the resulting &lt;code&gt;std::atomic&amp;lt;&lt;i&gt;Integral&lt;/i&gt;&amp;gt;&lt;/code&gt; specialization has standard layout, a trivial default constructor, and a trivial destructor. Signed integer arithmetic is defined to use two's complement; there are no undefined results.</source>
          <target state="translated">Кроме того, результирующая специализация &lt;code&gt;std::atomic&amp;lt;&lt;i&gt;Integral&lt;/i&gt;&amp;gt;&lt;/code&gt; имеет стандартную компоновку, тривиальный конструктор по умолчанию и тривиальный деструктор. Целочисленная арифметика со знаком определяется с использованием дополнения до двух; нет неопределенных результатов.</target>
        </trans-unit>
        <trans-unit id="ac1d2a76e849b1b5833ee66f2036219c73ed4239" translate="yes" xml:space="preserve">
          <source>Additionally:</source>
          <target state="translated">Additionally:</target>
        </trans-unit>
        <trans-unit id="76be74594d0a3f6f1c23004ef8fbefa453574daa" translate="yes" xml:space="preserve">
          <source>Additive operators</source>
          <target state="translated">Добавочные операторы</target>
        </trans-unit>
        <trans-unit id="ce6e9db4782a94f83450a756f42238c060b97d77" translate="yes" xml:space="preserve">
          <source>Address constant expression</source>
          <target state="translated">выражение адресной константы</target>
        </trans-unit>
        <trans-unit id="38ee922cd750ff4631c23d9b88d00633994c2466" translate="yes" xml:space="preserve">
          <source>Address family not supported</source>
          <target state="translated">Адрес семьи не поддерживается</target>
        </trans-unit>
        <trans-unit id="9e53f7cf7661710ec98f0a6e7a65398f5e81f0be" translate="yes" xml:space="preserve">
          <source>Address in use</source>
          <target state="translated">Адрес в использовании</target>
        </trans-unit>
        <trans-unit id="a645d07371a2ce45ebb0b375f8787a4fc425584d" translate="yes" xml:space="preserve">
          <source>Address not available</source>
          <target state="translated">Адрес не доступен</target>
        </trans-unit>
        <trans-unit id="f282d429f8e10c6e8f6cc685119b79f7b98f8d4a" translate="yes" xml:space="preserve">
          <source>Address of an lvalue may be taken: &lt;code&gt;&amp;amp;++i&lt;/code&gt;&lt;sup id=&quot;cite_ref-1&quot;&gt;&lt;a href=&quot;value_category#cite_note-1&quot;&gt;[1]&lt;/a&gt;&lt;/sup&gt; and &lt;code&gt;&amp;amp;&lt;a href=&quot;../io/manip/endl&quot;&gt;std::endl&lt;/a&gt;&lt;/code&gt; are valid expressions.</source>
          <target state="translated">Можно взять адрес lvalue: &lt;code&gt;&amp;amp;++i&lt;/code&gt; &lt;sup id=&quot;cite_ref-1&quot;&gt;&lt;a href=&quot;value_category#cite_note-1&quot;&gt;[1]&lt;/a&gt;&lt;/sup&gt; и &lt;code&gt;&amp;amp;&lt;a href=&quot;../io/manip/endl&quot;&gt;std::endl&lt;/a&gt;&lt;/code&gt; являются допустимыми выражениями.</target>
        </trans-unit>
        <trans-unit id="1a289481f4bde8e8211ad9ffe17faa98c7f5cb4e" translate="yes" xml:space="preserve">
          <source>Address of an overload set</source>
          <target state="translated">адрес перегрузочного комплекта</target>
        </trans-unit>
        <trans-unit id="b68e9b443504394c722ff5e4129a8d602ab42051" translate="yes" xml:space="preserve">
          <source>Address of an overloaded function</source>
          <target state="translated">Адрес перегруженной функции</target>
        </trans-unit>
        <trans-unit id="50d8d3dd04846c597735fdea066d1202471e00ac" translate="yes" xml:space="preserve">
          <source>Address of an rvalue may not be taken: &lt;code&gt;&amp;amp;int()&lt;/code&gt;, &lt;code&gt;&amp;amp;i++&lt;/code&gt;&lt;sup id=&quot;cite_ref-3&quot;&gt;&lt;a href=&quot;value_category#cite_note-3&quot;&gt;[3]&lt;/a&gt;&lt;/sup&gt;, &lt;code&gt;&amp;amp;42&lt;/code&gt;, and &lt;code&gt;&amp;amp;std::move(x)&lt;/code&gt; are invalid.</source>
          <target state="translated">Адрес значения r не может быть принят: &lt;code&gt;&amp;amp;int()&lt;/code&gt; , &lt;code&gt;&amp;amp;i++&lt;/code&gt; &lt;sup id=&quot;cite_ref-3&quot;&gt;&lt;a href=&quot;value_category#cite_note-3&quot;&gt;[3]&lt;/a&gt;&lt;/sup&gt; , &lt;code&gt;&amp;amp;42&lt;/code&gt; и &lt;code&gt;&amp;amp;std::move(x)&lt;/code&gt; недопустимы.</target>
        </trans-unit>
        <trans-unit id="9377e4719dc070a5dfa0119a44583c6b5ae07578" translate="yes" xml:space="preserve">
          <source>Address-of</source>
          <target state="translated">Address-of</target>
        </trans-unit>
        <trans-unit id="d8e9fb4e567ee2aa8c62d2ac99954b60bc22db70" translate="yes" xml:space="preserve">
          <source>Addressing tuples by type</source>
          <target state="translated">Обращение к кортежам по типу</target>
        </trans-unit>
        <trans-unit id="b0ef7d67a5935e3fe8af11cd7847c8809d95a854" translate="yes" xml:space="preserve">
          <source>Adds or subtracts 1 from the day value.</source>
          <target state="translated">Добавляет или вычитает 1 из дневного значения.</target>
        </trans-unit>
        <trans-unit id="e43efbbed96f261cc9549f2681044676631d009f" translate="yes" xml:space="preserve">
          <source>Adds or subtracts 1 from the month value, reducing the result modulo 12 to an integer in the range [1, 12].</source>
          <target state="translated">Добавляет или вычитает 1 из месячного значения,уменьшая модуль результата 12 до целого числа в диапазоне [1,12].</target>
        </trans-unit>
        <trans-unit id="fa3ef2c3e28e35bbf2cbd5aafea835fc3ea7a3ef" translate="yes" xml:space="preserve">
          <source>Adds or subtracts 1 from the weekday value, reducing the result modulo 7 to an integer in the range [0, 6].</source>
          <target state="translated">Добавляет или вычитает 1 из значения дня недели,уменьшая модуль результата 7 до целого числа в диапазоне [0,6].</target>
        </trans-unit>
        <trans-unit id="640e675cb46fdd695967fccbbef63e0607e284a0" translate="yes" xml:space="preserve">
          <source>Adds or subtracts 1 from the year value.</source>
          <target state="translated">Добавляет или вычитает 1 из значения года.</target>
        </trans-unit>
        <trans-unit id="4153c4972fd500059ef400485fdf85b87aceaa00" translate="yes" xml:space="preserve">
          <source>Adds or subtracts &lt;code&gt;d.count()&lt;/code&gt; days from the day value.</source>
          <target state="translated">Добавляет или вычитает &lt;code&gt;d.count()&lt;/code&gt; дней из значения дня.</target>
        </trans-unit>
        <trans-unit id="678a7c04a10343a84658ffb12634bd9ee9456301" translate="yes" xml:space="preserve">
          <source>Adds or subtracts &lt;code&gt;d.count()&lt;/code&gt; from the weekday value, reducing the result modulo 7 to an integer in the range [0, 6].</source>
          <target state="translated">Добавляет или вычитает &lt;code&gt;d.count()&lt;/code&gt; из значения дня недели, уменьшая результат по модулю 7 до целого числа в диапазоне [0, 6].</target>
        </trans-unit>
        <trans-unit id="3230fc75b04ac3e6ea29e55230fe30dd1c203bfe" translate="yes" xml:space="preserve">
          <source>Adds or subtracts &lt;code&gt;m.count()&lt;/code&gt; from the month value, reducing the result modulo 12 to an integer in the range [1, 12].</source>
          <target state="translated">Добавляет или вычитает &lt;code&gt;m.count()&lt;/code&gt; из значения месяца, уменьшая результат по модулю 12 до целого числа в диапазоне [1, 12].</target>
        </trans-unit>
        <trans-unit id="25e4a09fe7696cac408ac8a894a8ff1b27aa44b2" translate="yes" xml:space="preserve">
          <source>Adds or subtracts &lt;code&gt;y.count()&lt;/code&gt; years from the year value.</source>
          <target state="translated">Добавляет или вычитает &lt;code&gt;y.count()&lt;/code&gt; лет из значения года.</target>
        </trans-unit>
        <trans-unit id="458e4498a6e12a40a95f335b3f81898cfd748b12" translate="yes" xml:space="preserve">
          <source>Adjacent &lt;a href=&quot;string_literal&quot;&gt;string literals&lt;/a&gt; are concatenated.</source>
          <target state="translated">Смежные &lt;a href=&quot;string_literal&quot;&gt;строковые литералы&lt;/a&gt; объединяются.</target>
        </trans-unit>
        <trans-unit id="9932bec15aa8c818ed7b8796dbd6ed7ef02aab26" translate="yes" xml:space="preserve">
          <source>Adopt the Parallelism TS for C++17</source>
          <target state="translated">Принять параллелизм TS для C++17</target>
        </trans-unit>
        <trans-unit id="03e5621c572270086c95471651dc888f07bc2da9" translate="yes" xml:space="preserve">
          <source>Advances &lt;code&gt;e&lt;/code&gt;'s state as if by &lt;code&gt;z&lt;/code&gt; consecutive calls to &lt;code&gt;e()&lt;/code&gt;.</source>
          <target state="translated">Продвигает состояние &lt;code&gt;e&lt;/code&gt; , как если бы &lt;code&gt;z&lt;/code&gt; последовательных вызовов к &lt;code&gt;e()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="135dd9fae6bf561e041334e7723bb57b90c62cf2" translate="yes" xml:space="preserve">
          <source>Advances the input sequence by one character and reads one character.</source>
          <target state="translated">Сдвигает входную последовательность на один символ и считывает один символ.</target>
        </trans-unit>
        <trans-unit id="50499158101997cf6bc049268a358d31d71424e8" translate="yes" xml:space="preserve">
          <source>Advances the internal state by &lt;code&gt;z&lt;/code&gt; times. Equivalent to calling &lt;code&gt;&lt;a href=&quot;operator()&quot;&gt;operator()&lt;/a&gt;&lt;/code&gt;&lt;code&gt;z&lt;/code&gt; times and discarding the result.</source>
          <target state="translated">Продвигает внутреннее состояние на &lt;code&gt;z&lt;/code&gt; раз. Эквивалентно вызову &lt;code&gt;&lt;a href=&quot;operator()&quot;&gt;operator()&lt;/a&gt;&lt;/code&gt; &lt;code&gt;z&lt;/code&gt; раз и отбрасыванию результата.</target>
        </trans-unit>
        <trans-unit id="efa9b27cb8a086b18bbe299b9e1c46a036172d58" translate="yes" xml:space="preserve">
          <source>Advances the internal state by &lt;code&gt;z&lt;/code&gt; times. Equivalent to calling &lt;code&gt;&lt;a href=&quot;operator()&quot;&gt;operator()&lt;/a&gt;&lt;/code&gt;&lt;code&gt;z&lt;/code&gt; times and discarding the result. The state of the underlying engine may be advanced by more than &lt;code&gt;z&lt;/code&gt; times.</source>
          <target state="translated">Продвигает внутреннее состояние на &lt;code&gt;z&lt;/code&gt; раз. Эквивалентно вызову &lt;code&gt;&lt;a href=&quot;operator()&quot;&gt;operator()&lt;/a&gt;&lt;/code&gt; &lt;code&gt;z&lt;/code&gt; раз и отбрасыванию результата. Состояние базового движка может быть улучшено более чем в &lt;code&gt;z&lt;/code&gt; раз.</target>
        </trans-unit>
        <trans-unit id="b9ef5cc9bbd2286407c3e7b628e2c0232b990d29" translate="yes" xml:space="preserve">
          <source>Advances the iterator by calling &lt;code&gt;sbuf_-&amp;gt;sbumpc()&lt;/code&gt; where &lt;code&gt;sbuf_&lt;/code&gt; is the stored pointer to the stream buffer.</source>
          <target state="translated">&lt;code&gt;sbuf_-&amp;gt;sbumpc()&lt;/code&gt; итератор, вызывая sbuf _-&amp;gt; sbumpc (), где &lt;code&gt;sbuf_&lt;/code&gt; - это сохраненный указатель на буфер потока.</target>
        </trans-unit>
        <trans-unit id="141cb43c20eeabe7572fd03d0044e60b4fa23f86" translate="yes" xml:space="preserve">
          <source>Advances the iterator on the next match.</source>
          <target state="translated">Выдвигает итератор на следующий матч.</target>
        </trans-unit>
        <trans-unit id="041d757eb7a9bbdbe12db3d41c780db95f87a90c" translate="yes" xml:space="preserve">
          <source>Advances the iterator on the next sub match.</source>
          <target state="translated">Увеличивает итератор на следующем субматче.</target>
        </trans-unit>
        <trans-unit id="6539ad1eea9dd55e8e95ccfb1b1a314e60e23185" translate="yes" xml:space="preserve">
          <source>Advances the iterator to the next entry. Invalidates all copies of the previous value of &lt;code&gt;*this&lt;/code&gt;.</source>
          <target state="translated">Продвигает итератор к следующей записи. Делает недействительными все копии предыдущего значения &lt;code&gt;*this&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="78b5c8f29ae07de10df28f52834a61b1bdbbd82b" translate="yes" xml:space="preserve">
          <source>Advances the iterator.</source>
          <target state="translated">Увеличивает итератор.</target>
        </trans-unit>
        <trans-unit id="207287a093e89e5bc03f0303474f506b39d8c2b3" translate="yes" xml:space="preserve">
          <source>After &lt;b&gt;erasure&lt;/b&gt;, are...</source>
          <target state="translated">После &lt;b&gt;стирания&lt;/b&gt; ...</target>
        </trans-unit>
        <trans-unit id="4f0adbf879d7bad6224d512c2918e8643c30107f" translate="yes" xml:space="preserve">
          <source>After &lt;b&gt;insertion&lt;/b&gt;, are...</source>
          <target state="translated">После &lt;b&gt;вставки&lt;/b&gt; ...</target>
        </trans-unit>
        <trans-unit id="88341f67098f03a0da3cea31a839663a0bc13b2c" translate="yes" xml:space="preserve">
          <source>After a</source>
          <target state="translated">После</target>
        </trans-unit>
        <trans-unit id="a061077fb09465352c22016448276d1996de8a86" translate="yes" xml:space="preserve">
          <source>After a call to &lt;code&gt;&lt;a href=&quot;str&quot;&gt;str()&lt;/a&gt;&lt;/code&gt;, dynamic streams become frozen automatically. A call to &lt;code&gt;freeze(false)&lt;/code&gt; is required before exiting the scope in which this &lt;code&gt;ostrstream&lt;/code&gt; object was created. otherwise the destructor will leak memory. Also, additional output to a frozen stream may be truncated once it reaches the end of the allocated buffer.</source>
          <target state="translated">После вызова &lt;code&gt;&lt;a href=&quot;str&quot;&gt;str()&lt;/a&gt;&lt;/code&gt; динамические потоки автоматически замораживаются. Вызов &lt;code&gt;freeze(false)&lt;/code&gt; требуется перед выходом из области, в которой был создан этот объект &lt;code&gt;ostrstream&lt;/code&gt; . в противном случае деструктор потеряет память. Кроме того, дополнительный вывод в замороженный поток может быть обрезан, как только он достигнет конца выделенного буфера.</target>
        </trans-unit>
        <trans-unit id="a539ff8b097686cd8f474897e86e0367fc84dba2" translate="yes" xml:space="preserve">
          <source>After a call to &lt;code&gt;&lt;a href=&quot;str&quot;&gt;str()&lt;/a&gt;&lt;/code&gt;, dynamic streams become frozen automatically. A call to &lt;code&gt;freeze(false)&lt;/code&gt; is required before exiting the scope in which this &lt;code&gt;strstream&lt;/code&gt; object was created. otherwise the destructor will leak memory. Also, additional output to a frozen stream may be truncated once it reaches the end of the allocated buffer.</source>
          <target state="translated">После вызова &lt;code&gt;&lt;a href=&quot;str&quot;&gt;str()&lt;/a&gt;&lt;/code&gt; динамические потоки автоматически замораживаются. Вызов &lt;code&gt;freeze(false)&lt;/code&gt; требуется перед выходом из области, в которой был создан этот объект &lt;code&gt;strstream&lt;/code&gt; . в противном случае деструктор потеряет память. Кроме того, дополнительный вывод в замороженный поток может быть обрезан, как только он достигнет конца выделенного буфера.</target>
        </trans-unit>
        <trans-unit id="5eb647e196d16c21c41ab1c8527d9b7e8b2a6ba0" translate="yes" xml:space="preserve">
          <source>After a call to &lt;code&gt;str()&lt;/code&gt;, dynamic streams become frozen. A call to &lt;code&gt;freeze(false)&lt;/code&gt; is required before exiting the scope in which this &lt;code&gt;ostrstream&lt;/code&gt; object was created. otherwise the destructor will leak memory. Also, additional output to a frozen stream may be truncated once it reaches the end of the allocated buffer, which may leave the buffer not null-terminated.</source>
          <target state="translated">После вызова &lt;code&gt;str()&lt;/code&gt; динамические потоки замораживаются. Вызов &lt;code&gt;freeze(false)&lt;/code&gt; требуется перед выходом из области, в которой был создан этот объект &lt;code&gt;ostrstream&lt;/code&gt; . в противном случае деструктор вытечет из памяти. Кроме того, дополнительный вывод в замороженный поток может быть обрезан, как только он достигнет конца выделенного буфера, что может оставить буфер не завершенным нулем.</target>
        </trans-unit>
        <trans-unit id="44cdb0260695b6e760f2d33d6208f4bfff7fe216" translate="yes" xml:space="preserve">
          <source>After a call to &lt;code&gt;str()&lt;/code&gt;, dynamic streams become frozen. A call to &lt;code&gt;freeze(false)&lt;/code&gt; is required before exiting the scope in which this &lt;code&gt;strstream&lt;/code&gt; object was created. otherwise the destructor will leak memory. Also, additional output to a frozen stream may be truncated once it reaches the end of the allocated buffer, which may leave the buffer not null-terminated.</source>
          <target state="translated">После вызова &lt;code&gt;str()&lt;/code&gt; динамические потоки замораживаются. Вызов &lt;code&gt;freeze(false)&lt;/code&gt; требуется перед выходом из области, в которой был создан этот объект &lt;code&gt;strstream&lt;/code&gt; . в противном случае деструктор потеряет память. Кроме того, дополнительный вывод в замороженный поток может быть обрезан, как только он достигнет конца выделенного буфера, что может оставить буфер не завершенным нулем.</target>
        </trans-unit>
        <trans-unit id="b9daa7be1c203f1734014387e6ddd71754a92603" translate="yes" xml:space="preserve">
          <source>After a call to one of these functions, &lt;code&gt;ok()&lt;/code&gt; is always true if no overflow occurred during the operation.</source>
          <target state="translated">После вызова одной из этих функций &lt;code&gt;ok()&lt;/code&gt; всегда имеет значение true, если во время операции не произошло переполнения.</target>
        </trans-unit>
        <trans-unit id="85753ca571347a3ec5bab8ac7f1155da1ea5f3fa" translate="yes" xml:space="preserve">
          <source>After a call to one of these functions, &lt;code&gt;ok()&lt;/code&gt; is always true.</source>
          <target state="translated">После вызова одной из этих функций &lt;code&gt;ok()&lt;/code&gt; всегда имеет значение true.</target>
        </trans-unit>
        <trans-unit id="b0d14c1273920c43e0727fafe465d22e6d51d0cb" translate="yes" xml:space="preserve">
          <source>After all macro expansion and evaluation of &lt;code&gt;defined&lt;/code&gt;and &lt;code&gt;__has_include&lt;/code&gt;(since C++17) expressions, any identifier which is not a &lt;a href=&quot;../language/bool_literal&quot;&gt;boolean literal&lt;/a&gt; is replaced with the number &lt;code&gt;​0​&lt;/code&gt; (this includes identifiers that are lexically keywords, but not alternative tokens like &lt;code&gt;and&lt;/code&gt;).</source>
          <target state="translated">После того, как все макроподстановкам и оценки &lt;code&gt;defined&lt;/code&gt; и &lt;code&gt;__has_include&lt;/code&gt; (так как C ++ 17) выражений, любой идентификатор , который не является &lt;a href=&quot;../language/bool_literal&quot;&gt;булево буквальным&lt;/a&gt; заменяется с номером &lt;code&gt;​0​&lt;/code&gt; (это включает в себя идентификаторы, которые лексически ключевые слова, но не альтернативные маркеры , как &lt;code&gt;and&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="b09013ce3cd67396c7277e3bcafa2ffe1562348b" translate="yes" xml:space="preserve">
          <source>After all static initialization is completed, dynamic initialization of non-local variables occurs in the following situations:</source>
          <target state="translated">После завершения всех статических инициализаций динамическая инициализация нелокальных переменных происходит в следующих ситуациях:</target>
        </trans-unit>
        <trans-unit id="35dd559617a4f18a5460a7d2ed6280a6a78170b4" translate="yes" xml:space="preserve">
          <source>After any call to &lt;code&gt;str()&lt;/code&gt; on a stream with a dynamic buffer, a call to &lt;code&gt;freeze(false)&lt;/code&gt; is required to allow the &lt;code&gt;strstreambuf&lt;/code&gt; destructor to deallocate the buffer when necessary.</source>
          <target state="translated">После любого вызова &lt;code&gt;str()&lt;/code&gt; в потоке с динамическим буфером требуется вызов &lt;code&gt;freeze(false)&lt;/code&gt; чтобы деструктор &lt;code&gt;strstreambuf&lt;/code&gt; мог освободить буфер при необходимости.</target>
        </trans-unit>
        <trans-unit id="1bff9fbc15a1512d56427c0bac69b8131756695d" translate="yes" xml:space="preserve">
          <source>After any call to &lt;code&gt;str()&lt;/code&gt;, a call to &lt;code&gt;freeze(false)&lt;/code&gt; is required to allow the destructor to deallocate the buffer as necessary.</source>
          <target state="translated">После любого вызова &lt;code&gt;str()&lt;/code&gt; требуется вызов &lt;code&gt;freeze(false)&lt;/code&gt; чтобы деструктор мог освободить буфер по мере необходимости.</target>
        </trans-unit>
        <trans-unit id="a783411c667be5aeca25a2e7d260e7d91749c14d" translate="yes" xml:space="preserve">
          <source>After calling &lt;code&gt;detach&lt;/code&gt;&lt;code&gt;*this&lt;/code&gt; no longer owns any thread.</source>
          <target state="translated">После вызова &lt;code&gt;detach&lt;/code&gt; &lt;code&gt;*this&lt;/code&gt; поток больше не принадлежит.</target>
        </trans-unit>
        <trans-unit id="d81c3a85f42719a311033e306e37b8e8b9fb3c51" translate="yes" xml:space="preserve">
          <source>After calling &lt;code&gt;share&lt;/code&gt; on a &lt;code&gt;&lt;a href=&quot;../future&quot;&gt;std::future&lt;/a&gt;&lt;/code&gt;, &lt;a href=&quot;valid&quot;&gt;&lt;code&gt;valid()&lt;/code&gt;&lt;/a&gt;&lt;code&gt;== false&lt;/code&gt;.</source>
          <target state="translated">После вызова &lt;code&gt;share&lt;/code&gt; на &lt;code&gt;&lt;a href=&quot;../future&quot;&gt;std::future&lt;/a&gt;&lt;/code&gt; , &lt;a href=&quot;valid&quot;&gt; &lt;code&gt;valid()&lt;/code&gt; &lt;/a&gt; &lt;code&gt;== false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d8a56377919a429bed8801b85b079d1d09d9b97f" translate="yes" xml:space="preserve">
          <source>After calling the rvalue overloads (2,4,6,8), &lt;code&gt;r&lt;/code&gt; is empty and &lt;code&gt;r.get() == nullptr&lt;/code&gt;, except that &lt;code&gt;r&lt;/code&gt; is not modified for &lt;code&gt;dynamic_pointer_cast&lt;/code&gt;(4) if the &lt;code&gt;dynamic_cast&lt;/code&gt; fails.</source>
          <target state="translated">После вызова перегрузок rvalue (2,4,6,8), &lt;code&gt;r&lt;/code&gt; пусто и &lt;code&gt;r.get() == nullptr&lt;/code&gt; , за исключением того, что &lt;code&gt;r&lt;/code&gt; не модифицируется для &lt;code&gt;dynamic_pointer_cast&lt;/code&gt; (4) в случае сбоя &lt;code&gt;dynamic_cast&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a43ab890db9a9d7fd099d5804cec46453734ffa7" translate="yes" xml:space="preserve">
          <source>After considering every P and A in both directions, if, for each type that was considered,</source>
          <target state="translated">После рассмотрения каждого P и A в обоих направлениях,если для каждого типа,который рассматривался,</target>
        </trans-unit>
        <trans-unit id="cde16484b3a6dce1a5a73f1d71d4d5f94eda1f7f" translate="yes" xml:space="preserve">
          <source>After container move assignment (overload (2)), unless elementwise move assignment is forced by incompatible allocators, references, pointers, and iterators (other than the end iterator) to &lt;code&gt;other&lt;/code&gt; remain valid, but refer to elements that are now in &lt;code&gt;*this&lt;/code&gt;. The current standard makes this guarantee via the blanket statement in &amp;sect;23.2.1[container.requirements.general]/12, and a more direct guarantee is under consideration via &lt;a href=&quot;http://www.open-std.org/JTC1/SC22/WG21/docs/lwg-active.html#2321&quot;&gt;LWG 2321&lt;/a&gt;.</source>
          <target state="translated">После назначения перемещения контейнера (overload (2)), если элементное перемещение не будет принудительно вызвано несовместимыми распределителями, ссылки, указатели и итераторы (кроме конечного итератора), &lt;code&gt;other&lt;/code&gt; остаются действительными, но ссылаются на элементы, которые теперь находятся в &lt;code&gt;*this&lt;/code&gt; . Нынешний стандарт дает эту гарантию через бланкетное заявление в &amp;sect;23.2.1 [container.requirements.general] / 12, а более прямая гарантия рассматривается в &lt;a href=&quot;http://www.open-std.org/JTC1/SC22/WG21/docs/lwg-active.html#2321&quot;&gt;LWG 2321&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1efd3ba5fab7d922cddedab135cbf68623f0fbb3" translate="yes" xml:space="preserve">
          <source>After container move construction (overload (4)), references, pointers, and iterators (other than the end iterator) to &lt;code&gt;other&lt;/code&gt; remain valid, but refer to elements that are now in &lt;code&gt;*this&lt;/code&gt;. The current standard makes this guarantee via the blanket statement in &amp;sect;23.2.1[container.requirements.general]/12, and a more direct guarantee is under consideration via &lt;a href=&quot;http://www.open-std.org/JTC1/SC22/WG21/docs/lwg-active.html#2321&quot;&gt;LWG 2321&lt;/a&gt;.</source>
          <target state="translated">После построения перемещения контейнера (overload (4)) ссылки, указатели и итераторы (кроме конечного итератора) на &lt;code&gt;other&lt;/code&gt; остаются действительными, но ссылаются на элементы, которые теперь находятся в &lt;code&gt;*this&lt;/code&gt; . Нынешний стандарт дает эту гарантию через бланкетное заявление в &amp;sect;23.2.1 [container.requirements.general] / 12, а более прямая гарантия рассматривается в &lt;a href=&quot;http://www.open-std.org/JTC1/SC22/WG21/docs/lwg-active.html#2321&quot;&gt;LWG 2321&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="eaca101a515420f6158015d9049a7c61e1020372" translate="yes" xml:space="preserve">
          <source>After container move construction (overload (6)), references, pointers, and iterators (other than the end iterator) to &lt;code&gt;other&lt;/code&gt; remain valid, but refer to elements that are now in &lt;code&gt;*this&lt;/code&gt;. The current standard makes this guarantee via the blanket statement in &amp;sect;23.2.1[container.requirements.general]/12, and a more direct guarantee is under consideration via &lt;a href=&quot;http://www.open-std.org/JTC1/SC22/WG21/docs/lwg-active.html#2321&quot;&gt;LWG 2321&lt;/a&gt;.</source>
          <target state="translated">После построения перемещения контейнера (overload (6)) ссылки, указатели и итераторы (кроме конечного итератора) на &lt;code&gt;other&lt;/code&gt; остаются действительными, но ссылаются на элементы, которые теперь находятся в &lt;code&gt;*this&lt;/code&gt; . Нынешний стандарт дает эту гарантию через бланкетное заявление в &amp;sect;23.2.1 [container.requirements.general] / 12, а более прямая гарантия рассматривается в &lt;a href=&quot;http://www.open-std.org/JTC1/SC22/WG21/docs/lwg-active.html#2321&quot;&gt;LWG 2321&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1fb3e0e585b7b35a447a3da6d3ae0da5248da92b" translate="yes" xml:space="preserve">
          <source>After encountering the &lt;code&gt;#error&lt;/code&gt; directive, an implementation displays the diagnostic message error_message and renders the program ill-formed (the compilation stops).</source>
          <target state="translated">После обнаружения директивы &lt;code&gt;#error&lt;/code&gt; реализация отображает диагностическое сообщение error_message и визуализирует программу неправильно (компиляция останавливается).</target>
        </trans-unit>
        <trans-unit id="1d2d75b0b4cf172aa9246ff178f69aced36a5e9c" translate="yes" xml:space="preserve">
          <source>After evaluating &lt;code&gt;lhs = rhs&lt;/code&gt;:</source>
          <target state="translated">После оценки &lt;code&gt;lhs = rhs&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="45a5bba2318081758d338e6bc0ad55114ce64350" translate="yes" xml:space="preserve">
          <source>After one of the two templates was transformed as described above, &lt;a href=&quot;template_argument_deduction&quot;&gt;template argument deduction&lt;/a&gt; is executed using the transformed template as the argument template and the original template type of the other template as the parameter template. The process is then repeated using the second template (after transformations) as the argument and the first template in its original form as the parameter.</source>
          <target state="translated">После преобразования одного из двух шаблонов, как описано выше, выполняется &lt;a href=&quot;template_argument_deduction&quot;&gt;вывод аргумента шаблона&lt;/a&gt; с использованием преобразованного шаблона в качестве шаблона аргумента и исходного типа шаблона другого шаблона в качестве шаблона параметра. Затем процесс повторяется с использованием второго шаблона (после преобразований) в качестве аргумента и первого шаблона в исходном виде в качестве параметра.</target>
        </trans-unit>
        <trans-unit id="37697aac1a5eff809b30503e048e426d91ee09c0" translate="yes" xml:space="preserve">
          <source>After seeking to a non-end position in a wide stream, the next call to any output function may render the remainder of the file undefined, e.g. by outputting a multibyte sequence of a different length.</source>
          <target state="translated">После поиска незавершенной позиции в широком потоке,следующий вызов любой выходной функции может сделать оставшуюся часть файла неопределенной,например,путем вывода многобайтовой последовательности различной длины.</target>
        </trans-unit>
        <trans-unit id="6723da668a7284d1e0d9c856af9a4e60e17d6599" translate="yes" xml:space="preserve">
          <source>After substitution, all function parameters of array and function type are adjusted to pointers and all top-level cv-qualifiers are dropped from function parameters (as in a regular &lt;a href=&quot;function#Function_declaration&quot;&gt;function declaration&lt;/a&gt;).</source>
          <target state="translated">После подстановки все параметры функции массива и типа функции подстраиваются под указатели, а все cv-квалификаторы верхнего уровня удаляются из параметров функции (как в обычном &lt;a href=&quot;function#Function_declaration&quot;&gt;объявлении функции&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="799039415462a10354f545fe871b500eacc988ea" translate="yes" xml:space="preserve">
          <source>After that, whether or not an exception was thrown by any destructor, the delete expression invokes the &lt;a href=&quot;../memory/new/operator_delete&quot;&gt; deallocation function&lt;/a&gt;: either &lt;code&gt;&lt;a href=&quot;../memory/new/operator_delete&quot;&gt;operator delete&lt;/a&gt;&lt;/code&gt; (for the first version of the expression) or &lt;code&gt;&lt;a href=&quot;../memory/new/operator_delete&quot;&gt;operator delete&lt;/a&gt;[]&lt;/code&gt; (for the second version of the expression), unless the matching new-expression was combined with another new-expression(since C++14).</source>
          <target state="translated">После этого, независимо от того, было ли исключение вызвано каким-либо деструктором, выражение delete вызывает &lt;a href=&quot;../memory/new/operator_delete&quot;&gt;функцию освобождения&lt;/a&gt; : либо &lt;code&gt;&lt;a href=&quot;../memory/new/operator_delete&quot;&gt;operator delete&lt;/a&gt;&lt;/code&gt; (для первой версии выражения), либо &lt;code&gt;&lt;a href=&quot;../memory/new/operator_delete&quot;&gt;operator delete&lt;/a&gt;[]&lt;/code&gt; (для второй версии выражения), если только соответствующее новое выражение было объединено с другим новым выражением (начиная с C ++ 14).</target>
        </trans-unit>
        <trans-unit id="e0b82e4b58314156b84c6c073fedd13df3c06173" translate="yes" xml:space="preserve">
          <source>After the associated set of classes and namespaces is determined, all declarations found in classes of this set are discarded for the purpose of further ADL processing, except namespace-scoped friend functions and function templates, as stated in point 2 below .</source>
          <target state="translated">После определения связанного набора классов и пространств имен все объявления,найденные в классах этого набора,отбрасываются с целью дальнейшей обработки ADL,за исключением функций-друзей,охватываемых пространством имен,и шаблонов функций,как указано в пункте 2 ниже.</target>
        </trans-unit>
        <trans-unit id="a30be8c196cfecdbad0fc0881a76a52f9af12d23" translate="yes" xml:space="preserve">
          <source>After the call &lt;code&gt;getloc() == loc&lt;/code&gt;.</source>
          <target state="translated">После вызова &lt;code&gt;getloc() == loc&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5b157835cfa6ec4fc0f1fce8dc684fe4a88600d3" translate="yes" xml:space="preserve">
          <source>After the call, the value of &lt;code&gt;t&lt;/code&gt; is the value held by &lt;code&gt;u&lt;/code&gt; before the call, and the value of &lt;code&gt;u&lt;/code&gt; is the value held by &lt;code&gt;t&lt;/code&gt; before the call.</source>
          <target state="translated">После вызова значение &lt;code&gt;t&lt;/code&gt; является значением, удерживаемым &lt;code&gt;u&lt;/code&gt; перед вызовом, а значение &lt;code&gt;u&lt;/code&gt; является значением, удерживаемым &lt;code&gt;t&lt;/code&gt; до вызова.</target>
        </trans-unit>
        <trans-unit id="4cd3511e0d8d14569c23c73c7b91dc33ab8e711e" translate="yes" xml:space="preserve">
          <source>After the definition &lt;code&gt;T u = rv;&lt;/code&gt;, &lt;code&gt;u&lt;/code&gt; is equal to &lt;code&gt;u2&lt;/code&gt;;</source>
          <target state="translated">После определения &lt;code&gt;T u = rv;&lt;/code&gt; , &lt;code&gt;u&lt;/code&gt; равно &lt;code&gt;u2&lt;/code&gt; ;</target>
        </trans-unit>
        <trans-unit id="3d30d64981287500c819b1f90ccbf12490e9f92c" translate="yes" xml:space="preserve">
          <source>After the definition &lt;code&gt;T u = v;&lt;/code&gt;, &lt;code&gt;u&lt;/code&gt; is equal to &lt;code&gt;v&lt;/code&gt;;</source>
          <target state="translated">После определения &lt;code&gt;T u = v;&lt;/code&gt; , &lt;code&gt;u&lt;/code&gt; равно &lt;code&gt;v&lt;/code&gt; ;</target>
        </trans-unit>
        <trans-unit id="0c6c90fd32023a18a6a7da6b1f777294338454a9" translate="yes" xml:space="preserve">
          <source>After the destruction, the smart pointers that shared ownership with &lt;code&gt;*this&lt;/code&gt;, if any, will report a &lt;code&gt;&lt;a href=&quot;use_count&quot;&gt;use_count()&lt;/a&gt;&lt;/code&gt; that is one less than its previous value.</source>
          <target state="translated">После уничтожения умные указатели, которые поделились владением с &lt;code&gt;*this&lt;/code&gt; , если таковые имеются, сообщат о &lt;code&gt;&lt;a href=&quot;use_count&quot;&gt;use_count()&lt;/a&gt;&lt;/code&gt; который на единицу меньше его предыдущего значения.</target>
        </trans-unit>
        <trans-unit id="d2d0310f3096791666afb21ddf68713192d5f5d5" translate="yes" xml:space="preserve">
          <source>After the error condition is reported by a function, additional guarantees may be provided with regards to the state of the program. The following four levels of exception guarantee are generally recognized&lt;sup id=&quot;cite_ref-4&quot;&gt;&lt;a href=&quot;exceptions#cite_note-4&quot;&gt;[4]&lt;/a&gt;&lt;/sup&gt;&lt;sup id=&quot;cite_ref-5&quot;&gt;&lt;a href=&quot;exceptions#cite_note-5&quot;&gt;[5]&lt;/a&gt;&lt;/sup&gt;&lt;sup id=&quot;cite_ref-6&quot;&gt;&lt;a href=&quot;exceptions#cite_note-6&quot;&gt;[6]&lt;/a&gt;&lt;/sup&gt;, which are strict supersets of each other:</source>
          <target state="translated">После того, как функция сообщает о состоянии ошибки, могут быть предоставлены дополнительные гарантии в отношении состояния программы. Следующие четыре уровня гарантии исключения общепризнанны &lt;sup id=&quot;cite_ref-4&quot;&gt;&lt;a href=&quot;exceptions#cite_note-4&quot;&gt;[4] &lt;/a&gt;&lt;/sup&gt;&lt;sup id=&quot;cite_ref-5&quot;&gt;&lt;a href=&quot;exceptions#cite_note-5&quot;&gt;[5] &lt;/a&gt;&lt;/sup&gt;&lt;sup id=&quot;cite_ref-6&quot;&gt;&lt;a href=&quot;exceptions#cite_note-6&quot;&gt;[6]&lt;/a&gt;&lt;/sup&gt; , которые являются строгими надмножествами друг друга:</target>
        </trans-unit>
        <trans-unit id="5b29961c177bd98d620f93782ce1efd7215c74a8" translate="yes" xml:space="preserve">
          <source>After the standard library deallocation function returns, all pointers referring to any part of the deallocated storage become invalid.</source>
          <target state="translated">После возврата стандартной функции разделения библиотек все указатели,ссылающиеся на любую часть разделенного хранилища,становятся недействительными.</target>
        </trans-unit>
        <trans-unit id="d0f96cdce258dfc61390cebc0e99878ba570d5a1" translate="yes" xml:space="preserve">
          <source>After these adjustments, deduction of &lt;code&gt;P&lt;/code&gt; from &lt;code&gt;A&lt;/code&gt; is done following &lt;a href=&quot;template_argument_deduction#Deduction_from_a_type&quot;&gt;template argument deduction from a type&lt;/a&gt;.</source>
          <target state="translated">После этих корректировок вычитание &lt;code&gt;P&lt;/code&gt; из &lt;code&gt;A&lt;/code&gt; выполняется после &lt;a href=&quot;template_argument_deduction#Deduction_from_a_type&quot;&gt;вычитания аргумента шаблона из типа&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2d3d82b04f2207d9d6bcf7a9bbc105dd774ee13b" translate="yes" xml:space="preserve">
          <source>After these transformations, the deduction processes as described below (cf. section &quot;Deduction from type&quot;) and attempts to find such template arguments that would make the deduced &lt;code&gt;A&lt;/code&gt; (that is, &lt;code&gt;P&lt;/code&gt; after adjustments listed above and the substitution of the deduced template parameters) identical to the</source>
          <target state="translated">После этих преобразований вычитание обрабатывает, как описано ниже (см. Раздел &amp;laquo;Вычитание из типа&amp;raquo;), и пытается найти такие аргументы шаблона, которые позволят сделать вывод &lt;code&gt;A&lt;/code&gt; (то есть &lt;code&gt;P&lt;/code&gt; после корректировок, перечисленных выше, и подстановку выведенных параметров шаблона. ) идентично</target>
        </trans-unit>
        <trans-unit id="cbfa05ba4a64164c2c06108c94e66a0d15618966" translate="yes" xml:space="preserve">
          <source>After this call, &lt;code&gt;other&lt;/code&gt; has no associated mutex.</source>
          <target state="translated">После этого вызова &lt;code&gt;other&lt;/code&gt; не имеет ассоциированного мьютекса.</target>
        </trans-unit>
        <trans-unit id="09e6d08a70617f303ffde1bea6a795b13dc7771a" translate="yes" xml:space="preserve">
          <source>After this call, &lt;code&gt;this-&amp;gt;get_id()&lt;/code&gt; is equal to the value of &lt;code&gt;other.get_id()&lt;/code&gt; prior to the call, and &lt;code&gt;other&lt;/code&gt; no longer represents a thread of execution.</source>
          <target state="translated">После этого вызова &lt;code&gt;this-&amp;gt;get_id()&lt;/code&gt; равно значению &lt;code&gt;other.get_id()&lt;/code&gt; до вызова, а &lt;code&gt;other&lt;/code&gt; больше не представляют поток выполнения.</target>
        </trans-unit>
        <trans-unit id="8c87604fd723b0f75058b0139b052da68fd8a53e" translate="yes" xml:space="preserve">
          <source>After this function completes, &lt;a href=&quot;has_path&quot;&gt;&lt;code&gt;has_filename&lt;/code&gt;&lt;/a&gt; returns &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">После завершения этой функции &lt;a href=&quot;has_path&quot;&gt; &lt;code&gt;has_filename&lt;/code&gt; &lt;/a&gt; возвращает &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="af11ceb4dfc69bc2e19a600385c6a2e921b44982" translate="yes" xml:space="preserve">
          <source>After this operation &lt;code&gt;r&lt;/code&gt; is not required to be dereferenceable and any copies of the previous value of &lt;code&gt;r&lt;/code&gt; are no longer required to be dereferenceable or incrementable.</source>
          <target state="translated">После этой операции &lt;code&gt;r&lt;/code&gt; не требует разыменования, и любые копии предыдущего значения &lt;code&gt;r&lt;/code&gt; больше не должны разыменовываться или увеличиваться.</target>
        </trans-unit>
        <trans-unit id="d6b3e4110c978c6c966e175d0fb21c24d0cb55b2" translate="yes" xml:space="preserve">
          <source>After this operation &lt;code&gt;r&lt;/code&gt; is not required to be incrementable and any copies of the previous value of &lt;code&gt;r&lt;/code&gt; are no longer required to be dereferenceable or incrementable.</source>
          <target state="translated">После этой операции &lt;code&gt;r&lt;/code&gt; не требуется увеличивать, и любые копии предыдущего значения &lt;code&gt;r&lt;/code&gt; больше не должны быть разыменованными или увеличиваемыми.</target>
        </trans-unit>
        <trans-unit id="5cb3c3ab15a7948ac9776fc01389be53890f7bf1" translate="yes" xml:space="preserve">
          <source>After this statement the control is transferred to the statement immediately following the enclosing loop or switch. As with any block exit, all automatic storage objects declared in enclosing compound statement or in the condition of a loop/switch are destroyed, in reverse order of construction, before the execution of the first line following the enclosing loop.</source>
          <target state="translated">После этого утверждения управление переходит в это утверждение сразу же после контура подключения или переключателя.Как и в случае с любым выходом блока,все автоматические объекты хранения,объявленные в заявлении оболочки или в состоянии шлейфа/переключателя,уничтожаются в обратном порядке построения,до выполнения первой строки,следующей за шлейфом оболочки.</target>
        </trans-unit>
        <trans-unit id="fd175daec3ba5a5ff832d7613dfb6df9054a3994" translate="yes" xml:space="preserve">
          <source>After this, digit grouping is checked. if the position of any of the thousands separators discarded in Stage 2 does not match the grouping provided by &lt;code&gt;&lt;a href=&quot;../use_facet&quot;&gt;std::use_facet&lt;/a&gt;&amp;lt;&lt;a href=&quot;../numpunct&quot;&gt;std::numpunct&lt;/a&gt;&amp;lt;charT&amp;gt;&amp;gt;(str.getloc()).grouping()&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../../io/ios_base/iostate&quot;&gt;std::ios_base::failbit&lt;/a&gt;&lt;/code&gt; is assigned to &lt;code&gt;err&lt;/code&gt;.</source>
          <target state="translated">После этого проверяется группировка цифр. если позиция любого из разделителей тысяч, отброшенных на этапе 2, не соответствует группировке, предоставленной &lt;code&gt;&lt;a href=&quot;../use_facet&quot;&gt;std::use_facet&lt;/a&gt;&amp;lt;&lt;a href=&quot;../numpunct&quot;&gt;std::numpunct&lt;/a&gt;&amp;lt;charT&amp;gt;&amp;gt;(str.getloc()).grouping()&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../../io/ios_base/iostate&quot;&gt;std::ios_base::failbit&lt;/a&gt;&lt;/code&gt; назначен на &lt;code&gt;err&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7d93b73971332d0c3efd8634484908552ab34c9a" translate="yes" xml:space="preserve">
          <source>Afterwards, &lt;code&gt;p&lt;/code&gt; is equivalent to &lt;code&gt;nullptr&lt;/code&gt;</source>
          <target state="translated">Впоследствии &lt;code&gt;p&lt;/code&gt; эквивалентно &lt;code&gt;nullptr&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="795da143b5dbe81dcf8c6232ccf436d09b14c393" translate="yes" xml:space="preserve">
          <source>Aggregate initialization</source>
          <target state="translated">Совокупная инициализация</target>
        </trans-unit>
        <trans-unit id="32f6926454c3165c26d9dc05c16b8b6e9f95c8bb" translate="yes" xml:space="preserve">
          <source>Aggregate initialization initializes</source>
          <target state="translated">Совокупная инициализация инициализирует</target>
        </trans-unit>
        <trans-unit id="ce0cf7c09d177b646d6d216478f49a68396c308c" translate="yes" xml:space="preserve">
          <source>Aggregates copy/move initialize directly from single-element braced-init-lists of the same type, but non-aggregates consider initializer_list constructors first:</source>
          <target state="translated">Агрегаты copy/move инициализируют непосредственно из одноэлементных списков типа braced-init,но не агрегированные учитывают в первую очередь конструкторы initializer_list:</target>
        </trans-unit>
        <trans-unit id="02f02485ab679a9031f461bdbd3edab48ea42a79" translate="yes" xml:space="preserve">
          <source>Algorithm</source>
          <target state="translated">Algorithm</target>
        </trans-unit>
        <trans-unit id="e8a0f2b8083d5e86992465667615250c3f737a35" translate="yes" xml:space="preserve">
          <source>Algorithm concepts and utilities</source>
          <target state="translated">Алгоритмические концепции и утилиты</target>
        </trans-unit>
        <trans-unit id="b03f71c0b2a6d1e175830b00066b005660a7079a" translate="yes" xml:space="preserve">
          <source>Algorithm utilities</source>
          <target state="translated">Алгоритмические утилиты</target>
        </trans-unit>
        <trans-unit id="67e15eb99dc0e473c962d6a494d00e048e9f6fc6" translate="yes" xml:space="preserve">
          <source>Algorithms</source>
          <target state="translated">Algorithms</target>
        </trans-unit>
        <trans-unit id="6886e87f506cf00f362a34227ad744fd6fcd6652" translate="yes" xml:space="preserve">
          <source>Algorithms library</source>
          <target state="translated">Библиотека алгоритмов</target>
        </trans-unit>
        <trans-unit id="b1d4c8b0854335cb6dc181f5d361a3a9a6c77f1d" translate="yes" xml:space="preserve">
          <source>Algorithms that operate on ranges</source>
          <target state="translated">Алгоритмы,работающие на диапазонах</target>
        </trans-unit>
        <trans-unit id="8d55ef673ad6d9815c8fe83971681410e8111110" translate="yes" xml:space="preserve">
          <source>Alias declarations are &lt;a href=&quot;declarations&quot;&gt;declarations&lt;/a&gt; with the following syntax:</source>
          <target state="translated">Объявления псевдонимов - это &lt;a href=&quot;declarations&quot;&gt;объявления&lt;/a&gt; со следующим синтаксисом:</target>
        </trans-unit>
        <trans-unit id="ac7adb6d456a732926b16ac92fea1efb425fa68c" translate="yes" xml:space="preserve">
          <source>Alias template is a name that refers to a family of types.</source>
          <target state="translated">Шаблон псевдонима-это имя,которое относится к семейству типов.</target>
        </trans-unit>
        <trans-unit id="536ee4b3a1593a51e4e7a02e531109ebfa1e7aa5" translate="yes" xml:space="preserve">
          <source>Alias templates</source>
          <target state="translated">Шаблоны псевдонимов</target>
        </trans-unit>
        <trans-unit id="81fdfe39ee9314fa8adbdd24c8cefa9e67062042" translate="yes" xml:space="preserve">
          <source>Alias templates are never deduced by &lt;a href=&quot;function_template#Template_argument_deduction&quot;&gt;template argument deduction&lt;/a&gt; when deducing a template template parameter.  It is not possible to &lt;a href=&quot;partial_specialization&quot;&gt;partially&lt;/a&gt; or &lt;a href=&quot;template_specialization&quot;&gt;explicitly specialize&lt;/a&gt; an alias template.</source>
          <target state="translated">Шаблоны псевдонимов никогда не выводятся путем &lt;a href=&quot;function_template#Template_argument_deduction&quot;&gt;вывода аргументов шаблона&lt;/a&gt; при выводе параметра шаблона шаблона. Невозможно &lt;a href=&quot;partial_specialization&quot;&gt;частично&lt;/a&gt; или &lt;a href=&quot;template_specialization&quot;&gt;явно специализировать&lt;/a&gt; шаблон псевдонима.</target>
        </trans-unit>
        <trans-unit id="7f8c5176c3f03b97659161923f2b6492f7de7e73" translate="yes" xml:space="preserve">
          <source>Alignment</source>
          <target state="translated">Alignment</target>
        </trans-unit>
        <trans-unit id="a2aba61989bb9dc7a1e9fe034611bf7295de52c9" translate="yes" xml:space="preserve">
          <source>Alignment (as obtained by &lt;code&gt;alignof&lt;/code&gt;) has the type &lt;code&gt;&lt;a href=&quot;../../types/size_t&quot;&gt;std::size_t&lt;/a&gt;&lt;/code&gt;, but placement forms of allocation and deallocation functions that take &lt;code&gt;&lt;a href=&quot;../../types/size_t&quot;&gt;std::size_t&lt;/a&gt;&lt;/code&gt; as an additional parameter are already in use, so this type is used instead.</source>
          <target state="translated">Выравнивание (полученное с помощью &lt;code&gt;alignof&lt;/code&gt; ) имеет тип &lt;code&gt;&lt;a href=&quot;../../types/size_t&quot;&gt;std::size_t&lt;/a&gt;&lt;/code&gt; , но формы размещения функций выделения и освобождения, которые принимают &lt;code&gt;&lt;a href=&quot;../../types/size_t&quot;&gt;std::size_t&lt;/a&gt;&lt;/code&gt; в качестве дополнительного параметра, уже используются, поэтому вместо этого используется этот тип.</target>
        </trans-unit>
        <trans-unit id="1284e78e088763e07d38bdc498c7ac19fcd9faaa" translate="yes" xml:space="preserve">
          <source>Alignment specifier</source>
          <target state="translated">Спецификатор выравнивания</target>
        </trans-unit>
        <trans-unit id="6a72085653e4c5be8c7640c868ef787cbcf063d1" translate="yes" xml:space="preserve">
          <source>All</source>
          <target state="translated">All</target>
        </trans-unit>
        <trans-unit id="c533be78046b2b7438a7f5af4856db7635ad0dde" translate="yes" xml:space="preserve">
          <source>All &lt;a href=&quot;../container&quot;&gt;standard library containers&lt;/a&gt; require that their element type satisfies Erasable.</source>
          <target state="translated">Все &lt;a href=&quot;../container&quot;&gt;стандартные контейнеры библиотеки&lt;/a&gt; требуют, чтобы их тип элемента удовлетворял Erasable.</target>
        </trans-unit>
        <trans-unit id="ad583fce81393d0c4c343ed80041c1cf855fb389" translate="yes" xml:space="preserve">
          <source>All &lt;a href=&quot;../language/pointer#Pointers_to_functions&quot;&gt;pointers to functions&lt;/a&gt; satisfy this requirement.</source>
          <target state="translated">Все &lt;a href=&quot;../language/pointer#Pointers_to_functions&quot;&gt;указатели на функции&lt;/a&gt; удовлетворяют этому требованию.</target>
        </trans-unit>
        <trans-unit id="85e52ab157feeaab3392116ff6342f562d88a7b4" translate="yes" xml:space="preserve">
          <source>All &lt;a href=&quot;objects&quot;&gt;objects&lt;/a&gt; in a program have one of the following storage durations:</source>
          <target state="translated">Все &lt;a href=&quot;objects&quot;&gt;объекты&lt;/a&gt; в программе имеют одну из следующих длительностей хранения:</target>
        </trans-unit>
        <trans-unit id="2be019deb6ca8794e180ab1025f12fa6403846db" translate="yes" xml:space="preserve">
          <source>All &lt;a href=&quot;randomnumberengine&quot;&gt;RandomNumberEngines&lt;/a&gt; satisfy this requirement.</source>
          <target state="translated">Все &lt;a href=&quot;randomnumberengine&quot;&gt;RandomNumberEngines&lt;/a&gt; удовлетворяют этому требованию.</target>
        </trans-unit>
        <trans-unit id="5586b0fcd654b42e2d7df9c2c898d38125873577" translate="yes" xml:space="preserve">
          <source>All &lt;code&gt;const&lt;/code&gt; member functions can be called concurrently by different threads on the same container. In addition, the member functions &lt;code&gt;begin()&lt;/code&gt;, &lt;code&gt;end()&lt;/code&gt;, &lt;code&gt;rbegin()&lt;/code&gt;, &lt;code&gt;rend()&lt;/code&gt;, &lt;code&gt;front()&lt;/code&gt;, &lt;code&gt;back()&lt;/code&gt;, &lt;code&gt;data()&lt;/code&gt;, &lt;code&gt;find()&lt;/code&gt;, &lt;code&gt;lower_bound()&lt;/code&gt;, &lt;code&gt;upper_bound()&lt;/code&gt;, &lt;code&gt;equal_range()&lt;/code&gt;, &lt;code&gt;at()&lt;/code&gt;, and, except in associative containers, &lt;code&gt;operator[]&lt;/code&gt;, behave as &lt;code&gt;const&lt;/code&gt; for the purposes of thread safety (that is, they can also be called concurrently by different threads on the same container). More generally, the C++ standard library functions do not modify objects unless those objects are accessible, directly or indirectly, via the function's non-const arguments, including the this pointer.</source>
          <target state="translated">Все функции-члены &lt;code&gt;const&lt;/code&gt; могут вызываться одновременно разными потоками в одном и том же контейнере. Кроме того, функции-члены &lt;code&gt;begin()&lt;/code&gt; , &lt;code&gt;end()&lt;/code&gt; , &lt;code&gt;rbegin()&lt;/code&gt; , &lt;code&gt;rend()&lt;/code&gt; , &lt;code&gt;front()&lt;/code&gt; , &lt;code&gt;back()&lt;/code&gt; , &lt;code&gt;data()&lt;/code&gt; , &lt;code&gt;find()&lt;/code&gt; , &lt;code&gt;lower_bound()&lt;/code&gt; , &lt;code&gt;upper_bound()&lt;/code&gt; , &lt;code&gt;equal_range()&lt;/code&gt; , &lt;code&gt;at()&lt;/code&gt; и, за исключением ассоциативных контейнеров, &lt;code&gt;operator[]&lt;/code&gt; ведут себя как &lt;code&gt;const&lt;/code&gt; в целях безопасности потоков (то есть они могут также вызываться одновременно разными потоками в одном и том же контейнере). В более общем смысле функции стандартной библиотеки C ++ не изменяют объекты, если эти объекты не доступны, прямо или косвенно, через неконстантные аргументы функции, включая указатель this.</target>
        </trans-unit>
        <trans-unit id="4ce574fe03a26ad67fb18ae15f6d204f756c8e28" translate="yes" xml:space="preserve">
          <source>All &lt;code&gt;const&lt;/code&gt; member functions of &lt;code&gt;&lt;a href=&quot;../valarray&quot;&gt;std::valarray&lt;/a&gt;&lt;/code&gt; are provided.</source>
          <target state="translated">Все &lt;code&gt;const&lt;/code&gt; функции - члены &lt;code&gt;&lt;a href=&quot;../valarray&quot;&gt;std::valarray&lt;/a&gt;&lt;/code&gt; предоставляются.</target>
        </trans-unit>
        <trans-unit id="e4c5afaf4fff1d58306c2cfe530397e8446742a3" translate="yes" xml:space="preserve">
          <source>All &lt;code&gt;emit()&lt;/code&gt; calls transferring characters to the same wrapped stream buffer object appear to execute in a total order, where each &lt;code&gt;emit()&lt;/code&gt; call &lt;a href=&quot;../../atomic/memory_order&quot;&gt;synchronizes-with&lt;/a&gt; subsequent &lt;code&gt;emit()&lt;/code&gt; calls in that total order, even if these calls are made through difference instances of &lt;code&gt;std::basic_syncbuf&lt;/code&gt;/&lt;code&gt;std::basic_osyncstream&lt;/code&gt;. In practice, this means that emit() takes a lock uniquely associated with the wrapped stream object: for example, it could be held in a static hash map where the address of the wrapped stream is used as the key.</source>
          <target state="translated">Все вызовы &lt;code&gt;emit()&lt;/code&gt; передающие символы одному и тому же объекту буфера обернутого потока, по-видимому, выполняются в общем порядке, где каждый вызов &lt;code&gt;emit()&lt;/code&gt; &lt;a href=&quot;../../atomic/memory_order&quot;&gt;синхронизируется с&lt;/a&gt; последующими вызовами &lt;code&gt;emit()&lt;/code&gt; в этом общем порядке, даже если эти вызовы выполняются через экземпляры различий из &lt;code&gt;std::basic_syncbuf&lt;/code&gt; / &lt;code&gt;std::basic_osyncstream&lt;/code&gt; . На практике это означает, что emit () берет блокировку, уникально связанную с объектом обернутого потока: например, он может храниться в статической хэш-карте, где адрес обернутого потока используется в качестве ключа.</target>
        </trans-unit>
        <trans-unit id="08e7989631f4fa0b7b123c5eceab25241a651d43" translate="yes" xml:space="preserve">
          <source>All Function objects defined in &lt;a href=&quot;../header/functional&quot;&gt;&lt;code&gt;&amp;lt;functional&amp;gt;&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">Все объекты Function, определенные в &lt;a href=&quot;../header/functional&quot;&gt; &lt;code&gt;&amp;lt;functional&amp;gt;&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="267678e718109eec99ac63d1e0c78b1e78e6bc72" translate="yes" xml:space="preserve">
          <source>All arithmetic operators compute the result of specific arithmetic operation and returns its result. The arguments are not modified.</source>
          <target state="translated">Все арифметические операторы вычисляют результат конкретной арифметической операции и возвращают его.Аргументы не изменяются.</target>
        </trans-unit>
        <trans-unit id="2196ca16119493aee11e0e86a9a7193062fd552b" translate="yes" xml:space="preserve">
          <source>All atomic types except for &lt;code&gt;&lt;a href=&quot;../atomic_flag&quot;&gt;std::atomic_flag&lt;/a&gt;&lt;/code&gt; may be implemented using mutexes or other locking operations, rather than using the lock-free atomic CPU instructions. Atomic types are also allowed to be</source>
          <target state="translated">Все атомарные типы, кроме &lt;code&gt;&lt;a href=&quot;../atomic_flag&quot;&gt;std::atomic_flag&lt;/a&gt;&lt;/code&gt; могут быть реализованы с использованием мьютексов или других операций блокировки, а не с помощью инструкций атомарного процессора без блокировки. Атомные типы также могут быть</target>
        </trans-unit>
        <trans-unit id="acf874c1ced8a0f3cff5567518c467d553d7b81d" translate="yes" xml:space="preserve">
          <source>All atomic types except for &lt;code&gt;&lt;a href=&quot;atomic_flag&quot;&gt;std::atomic_flag&lt;/a&gt;&lt;/code&gt; may be implemented using mutexes or other locking operations, rather than using the lock-free atomic CPU instructions. Atomic types are also allowed to be</source>
          <target state="translated">Все атомарные типы, кроме &lt;code&gt;&lt;a href=&quot;atomic_flag&quot;&gt;std::atomic_flag&lt;/a&gt;&lt;/code&gt; могут быть реализованы с использованием мьютексов или других операций блокировки, а не с помощью инструкций атомарного процессора без блокировки. Атомные типы также могут быть</target>
        </trans-unit>
        <trans-unit id="1c6a82095fc35876e8565ece289c3317d10e940b" translate="yes" xml:space="preserve">
          <source>All built-in assignment operators return &lt;code&gt;*this&lt;/code&gt;, and most &lt;a href=&quot;operators&quot;&gt;user-defined overloads&lt;/a&gt; also return &lt;code&gt;*this&lt;/code&gt; so that the user-defined operators can be used in the same manner as the built-ins. However, in a user-defined operator overload, any type can be used as return type (including &lt;code&gt;void&lt;/code&gt;).</source>
          <target state="translated">Все встроенные операторы присваивания возвращают &lt;code&gt;*this&lt;/code&gt; , а большинство &lt;a href=&quot;operators&quot;&gt;пользовательских перегрузок&lt;/a&gt; также возвращают &lt;code&gt;*this&lt;/code&gt; , так что пользовательские операторы могут использоваться так же, как встроенные модули. Однако при пользовательской перегрузке оператора любой тип может использоваться в качестве возвращаемого типа (включая &lt;code&gt;void&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="1e3f7702614f1e201b0d2d7ca9cab6129fd842e0" translate="yes" xml:space="preserve">
          <source>All built-in operators return &lt;code&gt;bool&lt;/code&gt;, and most &lt;a href=&quot;operators&quot;&gt;user-defined overloads&lt;/a&gt; also return &lt;code&gt;bool&lt;/code&gt; so that the user-defined operators can be used in the same manner as the built-ins. However, in a user-defined operator overload, any type can be used as return type (including &lt;code&gt;void&lt;/code&gt;).</source>
          <target state="translated">Все встроенные операторы возвращают &lt;code&gt;bool&lt;/code&gt; , и большинство &lt;a href=&quot;operators&quot;&gt;пользовательских перегрузок&lt;/a&gt; также возвращают &lt;code&gt;bool&lt;/code&gt; , так что пользовательские операторы могут использоваться так же, как встроенные. Однако при пользовательской перегрузке оператора любой тип может быть использован в качестве возвращаемого типа (включая &lt;code&gt;void&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="ad44cda1026b661b30b82e23a1cc8e4adc8dad82" translate="yes" xml:space="preserve">
          <source>All built-in operators return values, and most &lt;a href=&quot;operators&quot;&gt;user-defined overloads&lt;/a&gt; also return values so that the user-defined operators can be used in the same manner as the built-ins. However, in a user-defined operator overload, any type can be used as return type (including &lt;code&gt;void&lt;/code&gt;). In particular, stream insertion and stream extraction overloads of &lt;code&gt;operator&amp;lt;&amp;lt;&lt;/code&gt; and &lt;code&gt;operator&amp;gt;&amp;gt;&lt;/code&gt; return &lt;code&gt;T&amp;amp;&lt;/code&gt;.</source>
          <target state="translated">Все встроенные операторы возвращают значения, и большинство &lt;a href=&quot;operators&quot;&gt;пользовательских перегрузок&lt;/a&gt; также возвращают значения, так что пользовательские операторы могут использоваться так же, как встроенные. Однако при пользовательской перегрузке оператора любой тип может быть использован в качестве возвращаемого типа (включая &lt;code&gt;void&lt;/code&gt; ). В частности, перегрузки вставки потока и извлечения потока &lt;code&gt;operator&amp;lt;&amp;lt;&lt;/code&gt; и &lt;code&gt;operator&amp;gt;&amp;gt;&lt;/code&gt; возвращают &lt;code&gt;T&amp;amp;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4c15cf3f5d785f05b074208b892da42654f696fb" translate="yes" xml:space="preserve">
          <source>All comments are removed from the program at &lt;a href=&quot;language/translation_phases&quot;&gt;translation phase 3&lt;/a&gt; by replacing each comment with a single whitespace character.</source>
          <target state="translated">Все комментарии удаляются из программы на &lt;a href=&quot;language/translation_phases&quot;&gt;этапе перевода 3&lt;/a&gt; , заменяя каждый комментарий одним пробелом.</target>
        </trans-unit>
        <trans-unit id="bf78ad8fede01661fec9052125328b1508f2f4d8" translate="yes" xml:space="preserve">
          <source>All comparison operators are short-circuited; they do not access tuple elements beyond what is necessary to determine the result of the comparison.</source>
          <target state="translated">Все операторы сравнения закорочены;они не имеют доступа к элементам кортежа сверх того,что необходимо для определения результата сравнения.</target>
        </trans-unit>
        <trans-unit id="d086b64161b8d9aca02f8348f6309d2102ee1278" translate="yes" xml:space="preserve">
          <source>All comparisons are done via the &lt;code&gt;&lt;a href=&quot;compare&quot;&gt;compare()&lt;/a&gt;&lt;/code&gt; member function (which itself is defined in terms of &lt;code&gt;Traits::compare()&lt;/code&gt;):</source>
          <target state="translated">Все сравнения выполняются с помощью функции-члена &lt;code&gt;&lt;a href=&quot;compare&quot;&gt;compare()&lt;/a&gt;&lt;/code&gt; (которая сама определяется в терминах &lt;code&gt;Traits::compare()&lt;/code&gt; ):</target>
        </trans-unit>
        <trans-unit id="b8289f337cbc9bd64fef53be2978b84bf37ef44f" translate="yes" xml:space="preserve">
          <source>All constants, except for &lt;code&gt;match_default&lt;/code&gt; and &lt;code&gt;format_default&lt;/code&gt;, are bitmask elements. The &lt;code&gt;match_default&lt;/code&gt; and &lt;code&gt;format_default&lt;/code&gt; constants are empty bitmasks.</source>
          <target state="translated">Все константы, кроме &lt;code&gt;match_default&lt;/code&gt; и &lt;code&gt;format_default&lt;/code&gt; , являются элементами битовой маски. Константы &lt;code&gt;match_default&lt;/code&gt; и &lt;code&gt;format_default&lt;/code&gt; являются пустыми битовыми масками.</target>
        </trans-unit>
        <trans-unit id="dc168f2bceb154961bb7ed9909031e74d78d43a5" translate="yes" xml:space="preserve">
          <source>All constructors that take &lt;code&gt;&lt;a href=&quot;../utility/initializer_list&quot;&gt;std::initializer_list&lt;/a&gt;&lt;/code&gt; as the only argument, or as the first argument if the remaining arguments have default values, are examined, and matched by &lt;a href=&quot;overload_resolution&quot;&gt;overload resolution&lt;/a&gt; against a single argument of type &lt;code&gt;&lt;a href=&quot;../utility/initializer_list&quot;&gt;std::initializer_list&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">Все конструкторы, которые принимают &lt;code&gt;&lt;a href=&quot;../utility/initializer_list&quot;&gt;std::initializer_list&lt;/a&gt;&lt;/code&gt; в качестве единственного аргумента или в качестве первого аргумента, если оставшиеся аргументы имеют значения по умолчанию, проверяются и сопоставляются по &lt;a href=&quot;overload_resolution&quot;&gt;разрешению перегрузки&lt;/a&gt; с одним аргументом типа &lt;code&gt;&lt;a href=&quot;../utility/initializer_list&quot;&gt;std::initializer_list&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2bcfde28187d671e9cbf776fb85caf9d73bb4df9" translate="yes" xml:space="preserve">
          <source>All container functions can be called concurrently by different threads on different containers. More generally, the C++ standard library functions do not read objects accessible by other threads unless those objects are directly or indirectly accessible via the function arguments, including the this pointer.</source>
          <target state="translated">Все функции контейнера могут вызываться одновременно разными потоками на разных контейнерах.В более общем плане,функции стандартной библиотеки C++не считывают объекты,доступные другим потокам,если только эти объекты прямо или косвенно не доступны через аргументы функции,включая этот указатель.</target>
        </trans-unit>
        <trans-unit id="36bd3ae32477cc666c63b1b73c2d5eb0bca71c31" translate="yes" xml:space="preserve">
          <source>All conversion specifiers other than &lt;code&gt;[&lt;/code&gt;, &lt;code&gt;c&lt;/code&gt;, and &lt;code&gt;n&lt;/code&gt; consume and discard all leading whitespace characters (determined as if by calling &lt;a href=&quot;../../string/byte/isspace&quot;&gt;&lt;code&gt;isspace&lt;/code&gt;&lt;/a&gt;) before attempting to parse the input. These consumed characters do not count towards the specified maximum field width.</source>
          <target state="translated">Все спецификаторы преобразования, кроме &lt;code&gt;[&lt;/code&gt; , &lt;code&gt;c&lt;/code&gt; и &lt;code&gt;n&lt;/code&gt; , потребляют и отбрасывают все &lt;a href=&quot;../../string/byte/isspace&quot;&gt; &lt;code&gt;isspace&lt;/code&gt; &lt;/a&gt; пробельные символы (определяемые как при вызове isspace ) перед попыткой анализа ввода. Эти использованные символы не учитываются при указании максимальной ширины поля.</target>
        </trans-unit>
        <trans-unit id="a2b014357acb5001a9291cf56269f10b96493516" translate="yes" xml:space="preserve">
          <source>All conversion specifiers other than &lt;code&gt;[&lt;/code&gt;, &lt;code&gt;c&lt;/code&gt;, and &lt;code&gt;n&lt;/code&gt; consume and discard all leading whitespace characters (determined as if by calling &lt;a href=&quot;../../string/wide/iswspace&quot;&gt;&lt;code&gt;iswspace&lt;/code&gt;&lt;/a&gt;) before attempting to parse the input. These consumed characters do not count towards the specified maximum field width.</source>
          <target state="translated">Все спецификаторы преобразования, кроме &lt;code&gt;[&lt;/code&gt; , &lt;code&gt;c&lt;/code&gt; и &lt;code&gt;n&lt;/code&gt; , потребляют и отбрасывают все &lt;a href=&quot;../../string/wide/iswspace&quot;&gt; &lt;code&gt;iswspace&lt;/code&gt; &lt;/a&gt; пробельные символы (определяемые как при вызове iswspace ) перед попыткой анализа ввода. Эти использованные символы не учитываются при указании максимальной ширины поля.</target>
        </trans-unit>
        <trans-unit id="cbea028682ce84815358b5aa6eda3b614cfe993e" translate="yes" xml:space="preserve">
          <source>All custom allocators also must be stateless.</source>
          <target state="translated">Все пользовательские распределители также должны быть лицами без гражданства.</target>
        </trans-unit>
        <trans-unit id="e99bcc0ededa138f077034c407c38f0bfa9cb54b" translate="yes" xml:space="preserve">
          <source>All deallocation functions are &lt;code&gt;noexcept(true)&lt;/code&gt; unless specified otherwise in the declaration.</source>
          <target state="translated">Все функции освобождения имеют значение &lt;code&gt;noexcept(true)&lt;/code&gt; если не указано иное в объявлении.</target>
        </trans-unit>
        <trans-unit id="7590e38178794abe168d1f61e5e605ebedab40ca" translate="yes" xml:space="preserve">
          <source>All direct base classes have trivial destructors</source>
          <target state="translated">Все прямые базовые классы имеют тривиальные деструкторы</target>
        </trans-unit>
        <trans-unit id="d1644548c66e07081be823b1a24493d9cfc6d493" translate="yes" xml:space="preserve">
          <source>All error codes are distinct and non-zero.</source>
          <target state="translated">Все коды ошибок различны и ненулевые.</target>
        </trans-unit>
        <trans-unit id="4eb9393603f7bb0528b986591eb39bc9de40a1c4" translate="yes" xml:space="preserve">
          <source>All evaluations of &lt;code&gt;h(k)&lt;/code&gt;executed within a given execution of a program(since C++14) yield the same result for the same value of &lt;code&gt;k&lt;/code&gt;.</source>
          <target state="translated">Все вычисления &lt;code&gt;h(k)&lt;/code&gt; выполненные в рамках данного выполнения программы (начиная с C ++ 14), дают одинаковый результат для одного и того же значения &lt;code&gt;k&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="615556c95cd2277e3f2551bbe6ac5d7b7503c6b8" translate="yes" xml:space="preserve">
          <source>All exceptions generated by the standard library inherit from &lt;code&gt;std::exception&lt;/code&gt;.</source>
          <target state="translated">Все исключения, сгенерированные стандартной библиотекой, наследуются от &lt;code&gt;std::exception&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="47496370c3026a6d2335b4c07d2899c2bfd0a9f8" translate="yes" xml:space="preserve">
          <source>All existing elements of &lt;code&gt;a&lt;/code&gt; are either move assigned to or destroyed; &lt;code&gt;a&lt;/code&gt; is equal to the value that &lt;code&gt;rv&lt;/code&gt; had before the assignment</source>
          <target state="translated">Все существующие элементы &lt;code&gt;a&lt;/code&gt; либо назначены, либо уничтожены; &lt;code&gt;a&lt;/code&gt; равно значению, которое &lt;code&gt;rv&lt;/code&gt; имел до присвоения</target>
        </trans-unit>
        <trans-unit id="9b1c1c57702fcbfb1474e82ce403b1688060d643" translate="yes" xml:space="preserve">
          <source>All explicit and partial specializations of &lt;code&gt;hash&lt;/code&gt; provided by the standard library are &lt;a href=&quot;../named_req/defaultconstructible&quot;&gt;DefaultConstructible&lt;/a&gt;, &lt;a href=&quot;../named_req/copyassignable&quot;&gt;CopyAssignable&lt;/a&gt;, &lt;a href=&quot;../named_req/swappable&quot;&gt;Swappable&lt;/a&gt; and &lt;a href=&quot;../named_req/destructible&quot;&gt;Destructible&lt;/a&gt;. User-provided specializations of &lt;code&gt;hash&lt;/code&gt; also must meet those requirements.</source>
          <target state="translated">Все явные и частичные специализации &lt;code&gt;hash&lt;/code&gt; , предоставляемые стандартной библиотеке &lt;a href=&quot;../named_req/defaultconstructible&quot;&gt;DefaultConstructible&lt;/a&gt; , &lt;a href=&quot;../named_req/copyassignable&quot;&gt;CopyAssignable&lt;/a&gt; , &lt;a href=&quot;../named_req/swappable&quot;&gt;Swappable&lt;/a&gt; и &lt;a href=&quot;../named_req/destructible&quot;&gt;Destructible&lt;/a&gt; . Пользовательские специализации &lt;code&gt;hash&lt;/code&gt; также должны соответствовать этим требованиям.</target>
        </trans-unit>
        <trans-unit id="d3caef46757d5c781ce31db0ab1b1d011a7c9448" translate="yes" xml:space="preserve">
          <source>All functions accepting an argument of type &lt;code&gt;const &lt;a href=&quot;../valarray&quot;&gt;std::valarray&lt;/a&gt;&amp;amp;&lt;/code&gt; except &lt;a href=&quot;begin2&quot;&gt;&lt;code&gt;begin()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;end2&quot;&gt;&lt;code&gt;end()&lt;/code&gt;&lt;/a&gt;(since C++11) should also accept the replacement type.</source>
          <target state="translated">Все функции, принимающие аргумент типа &lt;code&gt;const &lt;a href=&quot;../valarray&quot;&gt;std::valarray&lt;/a&gt;&amp;amp;&lt;/code&gt; кроме &lt;a href=&quot;begin2&quot;&gt; &lt;code&gt;begin()&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;end2&quot;&gt; &lt;code&gt;end()&lt;/code&gt; &lt;/a&gt; (начиная с C ++ 11), также должны принимать тип замены.</target>
        </trans-unit>
        <trans-unit id="0179673daad25aa9537982f33e1688378d0b8b34" translate="yes" xml:space="preserve">
          <source>All functions accepting two arguments of type &lt;code&gt;const &lt;a href=&quot;../valarray&quot;&gt;std::valarray&lt;/a&gt;&amp;amp;&lt;/code&gt; should accept every combination of &lt;code&gt;const &lt;a href=&quot;../valarray&quot;&gt;std::valarray&lt;/a&gt;&amp;amp;&lt;/code&gt; and the replacement type.</source>
          <target state="translated">Все функции, принимающие два аргумента типа &lt;code&gt;const &lt;a href=&quot;../valarray&quot;&gt;std::valarray&lt;/a&gt;&amp;amp;&lt;/code&gt; должны принимать каждую комбинацию &lt;code&gt;const &lt;a href=&quot;../valarray&quot;&gt;std::valarray&lt;/a&gt;&amp;amp;&lt;/code&gt; и типа замены.</target>
        </trans-unit>
        <trans-unit id="c84866185eebd1e3d3c0bd203de655735b81b728" translate="yes" xml:space="preserve">
          <source>All functions from &lt;a href=&quot;../../types#Type_traits&quot;&gt;&amp;lt;type_traits&amp;gt;&lt;/a&gt;</source>
          <target state="translated">Все функции из &lt;a href=&quot;../../types#Type_traits&quot;&gt;&amp;lt;type_traits&amp;gt;&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="eacdccc0ff89286560bd5447dd6d3e5754738868" translate="yes" xml:space="preserve">
          <source>All implicitly-captured variables must be declared within the</source>
          <target state="translated">Все неявно захваченные переменные должны быть объявлены внутри</target>
        </trans-unit>
        <trans-unit id="ee4038fb61cddc0d5aee00559af689e67143f4cb" translate="yes" xml:space="preserve">
          <source>All implicitly-declared member functions (and inheriting constructors) have exception specifications, selected as follows:</source>
          <target state="translated">Все неявно заявленные функции-члены (и наследующие конструкторы)имеют спецификации исключений,выбранные следующим образом:</target>
        </trans-unit>
        <trans-unit id="73a8920376f49ed06b9320f4b183b14d1b56c59a" translate="yes" xml:space="preserve">
          <source>All instances of &lt;code&gt;std::monostate&lt;/code&gt; compare equal.</source>
          <target state="translated">Все экземпляры &lt;code&gt;std::monostate&lt;/code&gt; сравниваются одинаково.</target>
        </trans-unit>
        <trans-unit id="6f36973910215a95c48be1c361c474c6abda5dfd" translate="yes" xml:space="preserve">
          <source>All iterators and references are invalidated, unless the erased elements are at the end or the beginning of the container, in which case only the iterators and references to the erased elements are invalidated.</source>
          <target state="translated">Все итераторы и ссылки аннулируются,если только стираемые элементы не находятся в конце или начале контейнера,в этом случае аннулируются только итераторы и ссылки на стираемые элементы.</target>
        </trans-unit>
        <trans-unit id="3ff58822fed4cebf575b53176b537d16617bfe40" translate="yes" xml:space="preserve">
          <source>All iterators and references are invalidated. Past-the-end iterator is also invalidated.</source>
          <target state="translated">Все итераторы и ссылки недействительны.Итератор прошлых лет также недействителен.</target>
        </trans-unit>
        <trans-unit id="b6bfeb63a7689b81c8714600b9a0261d56188882" translate="yes" xml:space="preserve">
          <source>All iterators and references remain valid. It is unspecified whether an iterator holding the past-the-end value in this container will refer to this or the other container after the operation.</source>
          <target state="translated">Все итераторы и ссылки остаются в силе.Не определено,будет ли итератор,удерживающий в этом контейнере значение прошлого,относиться к тому или иному контейнеру после операции.</target>
        </trans-unit>
        <trans-unit id="c94adb4871f7b21a7fe1f80a6cb316845a106fd2" translate="yes" xml:space="preserve">
          <source>All iterators and references remain valid. The past-the-end iterator is invalidated.</source>
          <target state="translated">Все итераторы и ссылки остаются в силе.Прошлый итератор недействителен.</target>
        </trans-unit>
        <trans-unit id="ca555a6b3c340c88a2973a4408368f43f4dc4831" translate="yes" xml:space="preserve">
          <source>All iterators, including the past-the-end iterator, are invalidated. No references are invalidated.</source>
          <target state="translated">Все итераторы,включая итератор прошлых лет,признаны недействительными.Никакие ссылки не считаются недействительными.</target>
        </trans-unit>
        <trans-unit id="cf1ebdb0694902a0ff8fae76c426f9dc6a20dead" translate="yes" xml:space="preserve">
          <source>All iterators, including the past-the-end iterator, are invalidated. References are invalidated too, unless &lt;code&gt;pos == begin()&lt;/code&gt; or &lt;code&gt;pos == end()&lt;/code&gt;, in which case they are not invalidated.</source>
          <target state="translated">Все итераторы, включая последний итератор, становятся недействительными. Ссылки также становятся недействительными, если только &lt;code&gt;pos == begin()&lt;/code&gt; или &lt;code&gt;pos == end()&lt;/code&gt; , и в этом случае они не становятся недействительными.</target>
        </trans-unit>
        <trans-unit id="40ad628bf4f34bdc58de5f589d209eea4731620e" translate="yes" xml:space="preserve">
          <source>All iterators, pointers and references to the elements of the container are invalidated.</source>
          <target state="translated">Все итераторы,указатели и ссылки на элементы контейнера недействительны.</target>
        </trans-unit>
        <trans-unit id="94cae0bd78bc02d0cb18bf7254756a408b83ca8f" translate="yes" xml:space="preserve">
          <source>All iterators, pointers and references to the elements of the container are invalidated. The past-the-end iterator is also invalidated.</source>
          <target state="translated">Все итераторы,указатели и ссылки на элементы контейнера недействительны.Прошлый итератор также недействителен.</target>
        </trans-unit>
        <trans-unit id="1aa2eedbbbd254c0a4f9a58cb63ee4b66a5cdbf4" translate="yes" xml:space="preserve">
          <source>All lock and unlock operations on a single mutex occur in a single total order</source>
          <target state="translated">Все операции по блокировке и разблокировке одного мьютекса происходят в одном общем порядке.</target>
        </trans-unit>
        <trans-unit id="178cdfec76dc5f4d6166a9e91517e1f3fec12bff" translate="yes" xml:space="preserve">
          <source>All lock and unlock operations on a single mutex occur in a single total order that can be viewed as &lt;a href=&quot;../atomic/memory_order#Modification_order&quot;&gt;modification order&lt;/a&gt; of an atomic variable: the order is specific to this individual mutex.</source>
          <target state="translated">Все операции блокировки и разблокировки для одного мьютекса выполняются в едином общем порядке, который можно рассматривать как &lt;a href=&quot;../atomic/memory_order#Modification_order&quot;&gt;порядок&lt;/a&gt; изменения атомарной переменной: этот порядок специфичен для этого отдельного мьютекса.</target>
        </trans-unit>
        <trans-unit id="34930fdb8cc73ddd310f600e059433705d8a684e" translate="yes" xml:space="preserve">
          <source>All member functions (including copy constructor and copy assignment) can be called by multiple threads on different instances of &lt;code&gt;shared_ptr&lt;/code&gt; without additional synchronization even if these instances are copies and share ownership of the same object. If multiple threads of execution access the same &lt;code&gt;shared_ptr&lt;/code&gt; without synchronization and any of those accesses uses a non-const member function of &lt;code&gt;shared_ptr&lt;/code&gt; then a data race will occur; the &lt;a href=&quot;shared_ptr/atomic&quot;&gt;shared_ptr overloads of atomic functions&lt;/a&gt; can be used to prevent the data race.</source>
          <target state="translated">Все функции-члены (включая конструктор копирования и назначение копирования) могут быть вызваны несколькими потоками в разных экземплярах &lt;code&gt;shared_ptr&lt;/code&gt; без дополнительной синхронизации, даже если эти экземпляры являются копиями и имеют общее владение одним и тем же объектом. Если несколько потоков выполнения обращаются к одному и тому же &lt;code&gt;shared_ptr&lt;/code&gt; без синхронизации и любой из этих обращений использует неконстантную функцию-член &lt;code&gt;shared_ptr&lt;/code&gt; , тогда произойдет гонка данных; в &lt;a href=&quot;shared_ptr/atomic&quot;&gt;shared_ptr перегруженных атомных функций&lt;/a&gt; можно использовать для предотвращения гонки данных.</target>
        </trans-unit>
        <trans-unit id="35b76e83898bb18b9a2f37898e8607d37cde7935" translate="yes" xml:space="preserve">
          <source>All member functions of all standard library specializations of this template are &lt;code&gt;noexcept&lt;/code&gt; except for the member functions of &lt;a href=&quot;optional/hash&quot;&gt;&lt;code&gt;std::hash&amp;lt;std::optional&amp;gt;&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;variant/hash&quot;&gt;&lt;code&gt;std::hash&amp;lt;std::variant&amp;gt;&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;../memory/unique_ptr/hash&quot;&gt;&lt;code&gt;std::hash&amp;lt;std::unique_ptr&amp;gt;&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">Все функции - члены всех стандартных библиотечных специализаций этого шаблона &lt;code&gt;noexcept&lt;/code&gt; для функций - членов , кроме &lt;a href=&quot;optional/hash&quot;&gt; &lt;code&gt;std::hash&amp;lt;std::optional&amp;gt;&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;variant/hash&quot;&gt; &lt;code&gt;std::hash&amp;lt;std::variant&amp;gt;&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;../memory/unique_ptr/hash&quot;&gt; &lt;code&gt;std::hash&amp;lt;std::unique_ptr&amp;gt;&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="8504e2abc83d5c2fab9fb5538bf231a69f226b05" translate="yes" xml:space="preserve">
          <source>All members are defined at once in the class definition, they cannot be added to an already-defined class (unlike the members of namespaces).</source>
          <target state="translated">Все члены определены сразу в определении класса,они не могут быть добавлены в уже определенный класс (в отличие от членов пространств имён).</target>
        </trans-unit>
        <trans-unit id="5302fa5db09bb78acbca4f2b6c8fda7d03161a35" translate="yes" xml:space="preserve">
          <source>All members of a class (bodies of &lt;a href=&quot;member_functions&quot;&gt;member functions&lt;/a&gt;, initializers of member objects, and the entire &lt;a href=&quot;nested_classes&quot;&gt;nested class definitions&lt;/a&gt;) have access to all names the class can access. A local class within a member function has access to all names the member function can access.</source>
          <target state="translated">Все члены класса (тела &lt;a href=&quot;member_functions&quot;&gt;функций-членов&lt;/a&gt; , инициализаторы объектов-членов и все &lt;a href=&quot;nested_classes&quot;&gt;определения вложенных классов&lt;/a&gt; ) имеют доступ ко всем именам, к которым может обращаться класс. Локальный класс в функции-члене имеет доступ ко всем именам, к которым имеет доступ функция-член.</target>
        </trans-unit>
        <trans-unit id="59ab18ea391c2d9b328f2f7d982b4ad982485409" translate="yes" xml:space="preserve">
          <source>All modifications to any particular atomic variable occur in a total order that is specific to this one atomic variable.</source>
          <target state="translated">Все изменения какой-либо конкретной атомной переменной происходят в суммарном порядке,характерном для этой одной атомной переменной.</target>
        </trans-unit>
        <trans-unit id="d28efff2a0fb864afdef01249aa565cd9c9d0c3a" translate="yes" xml:space="preserve">
          <source>All names introduced by the declarations that appear within namespace-body (including nested namespace definitions) become members of the namespace identifier, whether this namespace definition is the original namespace definition (which introduced identifier), or an extension namespace definition (which &quot;reopened&quot; the already defined namespace).</source>
          <target state="translated">Все имена,вводимые объявлениями,которые появляются внутри пространства имен-тела (включая определения вложенных пространств имен),становятся членами идентификатора пространства имен,независимо от того,является ли это определение пространства имен первоначальным определением пространства имен (которое ввело идентификатор)или расширением пространства имен (которое &quot;заново открыло&quot; уже определенное пространство имен).</target>
        </trans-unit>
        <trans-unit id="b08c863ba714f38d0d860de01117473b44bbbe86" translate="yes" xml:space="preserve">
          <source>All non-local variables with static &lt;a href=&quot;storage_duration&quot;&gt;storage duration&lt;/a&gt; are initialized as part of program startup, before the execution of the &lt;a href=&quot;main_function&quot;&gt;main function&lt;/a&gt; begins (unless deferred, see below). All variables with thread-local storage duration are initialized as part of thread launch, sequenced-before the execution of the thread function begins. For both of these classes of variables, initialization occurs in two distinct stages:</source>
          <target state="translated">Все нелокальные переменные со статической &lt;a href=&quot;storage_duration&quot;&gt;продолжительностью хранения&lt;/a&gt; инициализируются как часть запуска программы до начала выполнения &lt;a href=&quot;main_function&quot;&gt;основной функции&lt;/a&gt; (если не отложено, см. Ниже). Все переменные с локальным временем хранения потока инициализируются как часть запуска потока, упорядочены до начала выполнения функции потока. Для обоих этих классов переменных инициализация происходит в два отдельных этапа:</target>
        </trans-unit>
        <trans-unit id="55481c71bd011e1fe7bc3e43733da57362a61783" translate="yes" xml:space="preserve">
          <source>All non-specialized &lt;code&gt;&lt;a href=&quot;../../atomic/atomic&quot;&gt;std::atomic&lt;/a&gt;&lt;/code&gt; functions are also provided by this specialization, and no additional member functions.</source>
          <target state="translated">Все неспециализированные функции &lt;code&gt;&lt;a href=&quot;../../atomic/atomic&quot;&gt;std::atomic&lt;/a&gt;&lt;/code&gt; также обеспечиваются этой специализацией и не имеют дополнительных функций-членов.</target>
        </trans-unit>
        <trans-unit id="0557b920b1069437438d197127c5136f3ee6adf1" translate="yes" xml:space="preserve">
          <source>All non-static data members and base classes are themselves standard layout types</source>
          <target state="translated">Все нестатические члены данных и базовые классы сами по себе являются стандартными типами компоновки.</target>
        </trans-unit>
        <trans-unit id="e4dcf520b0bb3c172727a71b79681a5d16c241c8" translate="yes" xml:space="preserve">
          <source>All non-static data members have the same &lt;a href=&quot;../language/access&quot;&gt;access control&lt;/a&gt;</source>
          <target state="translated">Все нестатические члены данных имеют одинаковый &lt;a href=&quot;../language/access&quot;&gt;контроль доступа&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="624a5b6de90948456f868c89c51c9329989f3cb3" translate="yes" xml:space="preserve">
          <source>All non-static data members of class type (or array of class type) have trivial destructors</source>
          <target state="translated">Все нестатические члены данных типа класса (или массива типа класса)имеют тривиальные деструкторы</target>
        </trans-unit>
        <trans-unit id="f485616a097e8c940e99a2d2edb5c6f19158253d" translate="yes" xml:space="preserve">
          <source>All of the elements before this new &lt;code&gt;nth&lt;/code&gt; element are less than or equal to the elements after the new &lt;code&gt;nth&lt;/code&gt; element.</source>
          <target state="translated">Все элементы до этого нового &lt;code&gt;nth&lt;/code&gt; элемента меньше или равны элементам после нового &lt;code&gt;nth&lt;/code&gt; элемента.</target>
        </trans-unit>
        <trans-unit id="d5ea57823ac6ced06c326c70fd59fde6fcce0fad" translate="yes" xml:space="preserve">
          <source>All of the iterator categories (except &lt;a href=&quot;named_req/outputiterator&quot;&gt;LegacyOutputIterator&lt;/a&gt; and &lt;a href=&quot;named_req/contiguousiterator&quot;&gt;LegacyContiguousIterator&lt;/a&gt;) can be organized into a hierarchy, where more powerful iterator categories (e.g. &lt;a href=&quot;named_req/randomaccessiterator&quot;&gt;LegacyRandomAccessIterator&lt;/a&gt;) support the operations of less powerful categories (e.g. &lt;a href=&quot;named_req/inputiterator&quot;&gt;LegacyInputIterator&lt;/a&gt;). If an iterator falls into one of these categories and also satisfies the requirements of &lt;a href=&quot;named_req/outputiterator&quot;&gt;LegacyOutputIterator&lt;/a&gt;, then it is called a</source>
          <target state="translated">Все категории итераторов (кроме &lt;a href=&quot;named_req/outputiterator&quot;&gt;LegacyOutputIterator&lt;/a&gt; и &lt;a href=&quot;named_req/contiguousiterator&quot;&gt;LegacyContiguousIterator&lt;/a&gt; ) могут быть организованы в иерархию, где более мощные категории итераторов (например, &lt;a href=&quot;named_req/randomaccessiterator&quot;&gt;LegacyRandomAccessIterator&lt;/a&gt; ) поддерживают операции с менее мощными категориями (например, &lt;a href=&quot;named_req/inputiterator&quot;&gt;LegacyInputIterator&lt;/a&gt; ). Если итератор попадает в одну из этих категорий и также удовлетворяет требованиям &lt;a href=&quot;named_req/outputiterator&quot;&gt;LegacyOutputIterator&lt;/a&gt; , то он называется</target>
        </trans-unit>
        <trans-unit id="f4c48696f28287567f830764d3d2f6d6181a4365" translate="yes" xml:space="preserve">
          <source>All other constructors take an allocator parameter.</source>
          <target state="translated">Все остальные конструкторы принимают параметр аллокатора.</target>
        </trans-unit>
        <trans-unit id="9051dde370d80e8aba9af3637e2fe2a4c637ddb2" translate="yes" xml:space="preserve">
          <source>All pointers are considered valid and may be dereferenced or deallocated</source>
          <target state="translated">Все указатели считаются действительными и могут быть разыменованы или проданы.</target>
        </trans-unit>
        <trans-unit id="06db46d40762e7a049233b69f344ddc40172814b" translate="yes" xml:space="preserve">
          <source>All pointers are considered valid and may be dereferenced or deallocated. A reachability-based leak detector may be active</source>
          <target state="translated">Все указатели считаются действительными и могут быть разыменованы или проданы.Доступный детектор утечки может быть активен</target>
        </trans-unit>
        <trans-unit id="bdcfa55217ac64f8db8a5cf75b2b3e2a7b2b589f" translate="yes" xml:space="preserve">
          <source>All pointers, references, and iterators are invalidated.</source>
          <target state="translated">Все указатели,ссылки и итераторы недействительны.</target>
        </trans-unit>
        <trans-unit id="cae4dbc2c6705f38175037741cbe2272cd9f0a9e" translate="yes" xml:space="preserve">
          <source>All private data members and all private non-virtual member functions are placed in the implementation class. All public, protected, and virtual members remain in the interface class (see &lt;a href=&quot;http://herbsutter.com/gotw/_100/&quot;&gt;GOTW #100&lt;/a&gt; for the discussion of the alternatives).</source>
          <target state="translated">Все частные члены-данные и все частные не виртуальные функции-члены помещаются в класс реализации. Все открытые, защищенные и виртуальные члены остаются в классе интерфейса (см. &lt;a href=&quot;http://herbsutter.com/gotw/_100/&quot;&gt;GOTW # 100&lt;/a&gt; для обсуждения альтернатив).</target>
        </trans-unit>
        <trans-unit id="6ad08b1a1866207c625f156796d23145d807041c" translate="yes" xml:space="preserve">
          <source>All read only operations</source>
          <target state="translated">Все операции только для чтения</target>
        </trans-unit>
        <trans-unit id="51f454bbf261c865ca3eafaca5186949d522a16c" translate="yes" xml:space="preserve">
          <source>All read only operations, &lt;code&gt;&lt;a href=&quot;unordered_map/swap&quot;&gt;swap&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../algorithm/swap&quot;&gt;std::swap&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">Все операции только для чтения, &lt;code&gt;&lt;a href=&quot;unordered_map/swap&quot;&gt;swap&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../algorithm/swap&quot;&gt;std::swap&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0d0ff23cc747ee3f2c2cacda30dad2daf43fc67d" translate="yes" xml:space="preserve">
          <source>All read only operations, &lt;code&gt;&lt;a href=&quot;vector/swap&quot;&gt;swap&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../algorithm/swap&quot;&gt;std::swap&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">Все операции только для чтения, &lt;code&gt;&lt;a href=&quot;vector/swap&quot;&gt;swap&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../algorithm/swap&quot;&gt;std::swap&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="41a67df5b26d67f230c41a225f6f4807b01737d6" translate="yes" xml:space="preserve">
          <source>All references, pointers, and iterators are invalidated, including the end iterator. &lt;code&gt;a.empty() == true&lt;/code&gt;.</source>
          <target state="translated">Все ссылки, указатели и итераторы становятся недействительными, включая конечный итератор. &lt;code&gt;a.empty() == true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="efe67501a1ba3ff0b54181ac0c20ec517abdc3e4" translate="yes" xml:space="preserve">
          <source>All requirements on the iterator types of a &lt;a href=&quot;../named_req/container&quot;&gt;Container&lt;/a&gt; applies to the &lt;code&gt;iterator&lt;/code&gt; and &lt;code&gt;const_iterator&lt;/code&gt; types of &lt;code&gt;basic_string_view&lt;/code&gt; as well.</source>
          <target state="translated">Все требования к типам итераторов &lt;a href=&quot;../named_req/container&quot;&gt;Контейнера&lt;/a&gt; применяются также к типам &lt;code&gt;iterator&lt;/code&gt; и &lt;code&gt;const_iterator&lt;/code&gt; для &lt;code&gt;basic_string_view&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2f7b5a1e5c99b2a9bb4697e1dc9787334111a47c" translate="yes" xml:space="preserve">
          <source>All requirements on the iterator types of a &lt;a href=&quot;../named_req/container&quot;&gt;Container&lt;/a&gt; applies to the &lt;code&gt;iterator&lt;/code&gt; and &lt;code&gt;const_iterator&lt;/code&gt; types of &lt;code&gt;span&lt;/code&gt; as well.</source>
          <target state="translated">Все требования к типам итераторов &lt;a href=&quot;../named_req/container&quot;&gt;Контейнера&lt;/a&gt; применяются также к типам &lt;code&gt;span&lt;/code&gt; &lt;code&gt;iterator&lt;/code&gt; и &lt;code&gt;const_iterator&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="38eb211404e95dd1fe2352aec53428f8cadc5999" translate="yes" xml:space="preserve">
          <source>All resources owned by &lt;code&gt;u&lt;/code&gt; are reclaimed, no exceptions are thrown.</source>
          <target state="translated">Все ресурсы , принадлежащие &lt;code&gt;u&lt;/code&gt; возвращаемые, никаких исключений не выбрасывается.</target>
        </trans-unit>
        <trans-unit id="67f929817d9ab7c1515c103b3dec94699f49b916" translate="yes" xml:space="preserve">
          <source>All restrictions on regular declarations of the same names, hiding, and overloading rules apply to using-declarations:</source>
          <target state="translated">Все ограничения по регулярному объявлению одних и тех же имен,правила сокрытия и перегрузки применяются к объявлениям об использовании:</target>
        </trans-unit>
        <trans-unit id="be8b6e7136fa8d596cfda90d7fa7d28938ef27cd" translate="yes" xml:space="preserve">
          <source>All six relational operators are automatically generated by the compiler if the three-way comparison operator &lt;code&gt;operator&amp;lt;=&amp;gt;&lt;/code&gt; is defined, and that operator, in turn, is generated by the compiler if it is defined as defaulted:</source>
          <target state="translated">Все шесть реляционных операторов автоматически генерируются компилятором, если задан &lt;code&gt;operator&amp;lt;=&amp;gt;&lt;/code&gt; трехстороннего сравнения &amp;lt;=&amp;gt; , и этот оператор, в свою очередь, генерируется компилятором, если он определен как значение по умолчанию:</target>
        </trans-unit>
        <trans-unit id="0d9fb7dc61944bda88f1835dd4562a6f28a100a2" translate="yes" xml:space="preserve">
          <source>All specializations of &lt;code&gt;fpos&lt;/code&gt; meet the &lt;a href=&quot;../named_req/defaultconstructible&quot;&gt;DefaultConstructible&lt;/a&gt;, &lt;a href=&quot;../named_req/copyconstructible&quot;&gt;CopyConstructible&lt;/a&gt;, &lt;a href=&quot;../named_req/copyassignable&quot;&gt;CopyAssignable&lt;/a&gt;, &lt;a href=&quot;../named_req/destructible&quot;&gt;Destructible&lt;/a&gt;, and &lt;a href=&quot;../named_req/equalitycomparable&quot;&gt;EqualityComparable&lt;/a&gt; requirements.</source>
          <target state="translated">Все специализации &lt;code&gt;fpos&lt;/code&gt; соответствуют требованиям &lt;a href=&quot;../named_req/defaultconstructible&quot;&gt;DefaultConstructible&lt;/a&gt; , &lt;a href=&quot;../named_req/copyconstructible&quot;&gt;CopyConstructible&lt;/a&gt; , &lt;a href=&quot;../named_req/copyassignable&quot;&gt;CopyAssignable&lt;/a&gt; , &lt;a href=&quot;../named_req/destructible&quot;&gt;Destructible&lt;/a&gt; и &lt;a href=&quot;../named_req/equalitycomparable&quot;&gt;EqualityComparable&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="672a39cb4d9a7dc48c3d594e3812033e46d14edc" translate="yes" xml:space="preserve">
          <source>All specializations of &lt;code&gt;polymorphic_allocator&lt;/code&gt; meet the &lt;a href=&quot;../named_req/allocator#Allocator_completeness_requirements&quot;&gt;Allocator completeness requirements&lt;/a&gt;.</source>
          <target state="translated">Все специализации &lt;code&gt;polymorphic_allocator&lt;/code&gt; соответствуют требованиям к &lt;a href=&quot;../named_req/allocator#Allocator_completeness_requirements&quot;&gt;полноте Allocator&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="211f03dbec01e5b6570f235c7176b37d2a2a79b5" translate="yes" xml:space="preserve">
          <source>All specializations of &lt;code&gt;shared_ptr&lt;/code&gt; meet the requirements of &lt;a href=&quot;../named_req/copyconstructible&quot;&gt;CopyConstructible&lt;/a&gt;, &lt;a href=&quot;../named_req/copyassignable&quot;&gt;CopyAssignable&lt;/a&gt;, and &lt;a href=&quot;../named_req/lessthancomparable&quot;&gt;LessThanComparable&lt;/a&gt; and are &lt;a href=&quot;../language/implicit_cast&quot;&gt;contextually convertible&lt;/a&gt; to &lt;code&gt;bool&lt;/code&gt;.</source>
          <target state="translated">Все специализации &lt;code&gt;shared_ptr&lt;/code&gt; соответствуют требованиям &lt;a href=&quot;../named_req/copyconstructible&quot;&gt;CopyConstructible&lt;/a&gt; , &lt;a href=&quot;../named_req/copyassignable&quot;&gt;CopyAssignable&lt;/a&gt; и &lt;a href=&quot;../named_req/lessthancomparable&quot;&gt;LessThanComparable&lt;/a&gt; и являются &lt;a href=&quot;../language/implicit_cast&quot;&gt;контекстно-конвертируемыми&lt;/a&gt; в &lt;code&gt;bool&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1031f9406b312c985a6ae796719a2a8d26efc31e" translate="yes" xml:space="preserve">
          <source>All specializations of &lt;code&gt;std::tuple_size&lt;/code&gt; satisfy &lt;a href=&quot;../../named_req/unarytypetrait&quot;&gt;UnaryTypeTrait&lt;/a&gt; with</source>
          <target state="translated">Все специализации &lt;code&gt;std::tuple_size&lt;/code&gt; удовлетворяют &lt;a href=&quot;../../named_req/unarytypetrait&quot;&gt;UnaryTypeTrait&lt;/a&gt; с</target>
        </trans-unit>
        <trans-unit id="743934d87daadcc6d9d31370a3db4d5504aa0fb9" translate="yes" xml:space="preserve">
          <source>All specializations of &lt;code&gt;std::variant_size&lt;/code&gt; satisfy &lt;a href=&quot;../../named_req/unarytypetrait&quot;&gt;UnaryTypeTrait&lt;/a&gt; with</source>
          <target state="translated">Все специализации &lt;code&gt;std::variant_size&lt;/code&gt; удовлетворяют &lt;a href=&quot;../../named_req/unarytypetrait&quot;&gt;UnaryTypeTrait&lt;/a&gt; с</target>
        </trans-unit>
        <trans-unit id="63c53895a6870cc913e144b2578bac2d714b260c" translate="yes" xml:space="preserve">
          <source>All standard containers (&lt;code&gt;&lt;a href=&quot;../container/vector&quot;&gt;std::vector&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../container/list&quot;&gt;std::list&lt;/a&gt;&lt;/code&gt;, etc.) value-initialize their elements when constructed with a single &lt;code&gt;size_type&lt;/code&gt; argument or when grown by a call to &lt;code&gt;resize()&lt;/code&gt;.</source>
          <target state="translated">Все стандартные контейнеры ( &lt;code&gt;&lt;a href=&quot;../container/vector&quot;&gt;std::vector&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../container/list&quot;&gt;std::list&lt;/a&gt;&lt;/code&gt; и т. Д.) Инициализируют свои элементы по &lt;code&gt;size_type&lt;/code&gt; когда они создаются с одним аргументом size_type или когда их выращивает вызов &lt;code&gt;resize()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="358e40d1bfabb9461fdcb4d0a347855e7c412649" translate="yes" xml:space="preserve">
          <source>All standard library containers except &lt;code&gt;&lt;a href=&quot;../container/array&quot;&gt;std::array&lt;/a&gt;&lt;/code&gt; are AllocatorAwareContainers:</source>
          <target state="translated">Все стандартные контейнеры библиотеки, кроме &lt;code&gt;&lt;a href=&quot;../container/array&quot;&gt;std::array&lt;/a&gt;&lt;/code&gt; являются AllocatorAwareContainers:</target>
        </trans-unit>
        <trans-unit id="ffcd9ca742b4542ddb772e7d60b22b2039e3de22" translate="yes" xml:space="preserve">
          <source>All temporary objects are destroyed as the last step in evaluating the full-expression that (lexically) contains the point where they were created, and if multiple temporary objects were created, they are destroyed in the order opposite to the order of creation. This is true even if that evaluation ends in throwing an exception.</source>
          <target state="translated">Все временные объекты уничтожаются на последнем этапе оценки полного выражения,которое (лексически)содержит точку,в которой они были созданы,а если было создано несколько временных объектов,то они уничтожаются в порядке,противоположном порядку создания.Это справедливо даже в том случае,если эта оценка заканчивается бросанием исключения.</target>
        </trans-unit>
        <trans-unit id="32f475507fbff7c599c3fd139abea98403ae6343" translate="yes" xml:space="preserve">
          <source>All these functions invoke &lt;code&gt;&lt;a href=&quot;../../utility/variadic/va_arg&quot;&gt;va_arg&lt;/a&gt;&lt;/code&gt; at least once, the value of &lt;code&gt;arg&lt;/code&gt; is indeterminate after the return. These functions do not invoke &lt;code&gt;&lt;a href=&quot;../../utility/variadic/va_end&quot;&gt;va_end&lt;/a&gt;&lt;/code&gt;, and it must be done by the caller.</source>
          <target state="translated">Все эти функции вызывают &lt;code&gt;&lt;a href=&quot;../../utility/variadic/va_arg&quot;&gt;va_arg&lt;/a&gt;&lt;/code&gt; хотя бы один раз, значение &lt;code&gt;arg&lt;/code&gt; не определено после возврата. Эти функции не вызывают &lt;code&gt;&lt;a href=&quot;../../utility/variadic/va_end&quot;&gt;va_end&lt;/a&gt;&lt;/code&gt; , и это должно быть сделано вызывающей стороной.</target>
        </trans-unit>
        <trans-unit id="176f5f0946a06ebe297b8c8ddf38982989abc5aa" translate="yes" xml:space="preserve">
          <source>All these functions invoke &lt;code&gt;&lt;a href=&quot;../../utility/variadic/va_arg&quot;&gt;va_arg&lt;/a&gt;&lt;/code&gt; at least once, the value of &lt;code&gt;arg&lt;/code&gt; is indeterminate after the return. These functions to not invoke &lt;code&gt;&lt;a href=&quot;../../utility/variadic/va_end&quot;&gt;va_end&lt;/a&gt;&lt;/code&gt;, and it must be done by the caller.</source>
          <target state="translated">Все эти функции вызывают &lt;code&gt;&lt;a href=&quot;../../utility/variadic/va_arg&quot;&gt;va_arg&lt;/a&gt;&lt;/code&gt; хотя бы один раз, значение &lt;code&gt;arg&lt;/code&gt; не определено после возврата. Эти функции не вызывают &lt;code&gt;&lt;a href=&quot;../../utility/variadic/va_end&quot;&gt;va_end&lt;/a&gt;&lt;/code&gt; , и это должно быть сделано вызывающей стороной.</target>
        </trans-unit>
        <trans-unit id="fe267d2b83e7299286bdf1b9c5aac0a7f499c7ed" translate="yes" xml:space="preserve">
          <source>All these functions invoke undefined behavior if &lt;code&gt;p&lt;/code&gt; is a null pointer.</source>
          <target state="translated">Все эти функции вызывают неопределенное поведение, если &lt;code&gt;p&lt;/code&gt; является нулевым указателем.</target>
        </trans-unit>
        <trans-unit id="b0490d0cb63a327b1645f25c31bcc6482c7608ed" translate="yes" xml:space="preserve">
          <source>All these macro constants (except &lt;code&gt;FE_ALL_EXCEPT&lt;/code&gt;) expand to integer constant expressions that are distinct powers of 2, which uniquely identify all supported floating-point exceptions. Each macro is only defined if it is supported.</source>
          <target state="translated">Все эти макро константы (кроме &lt;code&gt;FE_ALL_EXCEPT&lt;/code&gt; ) расширяются до целочисленных константных выражений, которые имеют различные степени 2, которые однозначно идентифицируют все поддерживаемые исключения с плавающей точкой. Каждый макрос определяется только в том случае, если он поддерживается.</target>
        </trans-unit>
        <trans-unit id="18f14072e9d32bbf324c49cf31c0caf2c548ae29" translate="yes" xml:space="preserve">
          <source>All three overloads effectively return &lt;code&gt;&lt;a href=&quot;../basic_string_view&quot;&gt;std::basic_string_view&lt;/a&gt;&amp;lt;CharT, Traits&amp;gt;(data(), size()).ends_with(x);&lt;/code&gt;</source>
          <target state="translated">Все три перегрузки эффективно возвращают &lt;code&gt;&lt;a href=&quot;../basic_string_view&quot;&gt;std::basic_string_view&lt;/a&gt;&amp;lt;CharT, Traits&amp;gt;(data(), size()).ends_with(x);&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3ae0f95f4fd5fb1e59f705f02f6b13547bc8d638" translate="yes" xml:space="preserve">
          <source>All three overloads effectively return &lt;code&gt;&lt;a href=&quot;../basic_string_view&quot;&gt;std::basic_string_view&lt;/a&gt;&amp;lt;CharT, Traits&amp;gt;(data(), size()).starts_with(x);&lt;/code&gt;</source>
          <target state="translated">Все три перегрузки эффективно возвращают &lt;code&gt;&lt;a href=&quot;../basic_string_view&quot;&gt;std::basic_string_view&lt;/a&gt;&amp;lt;CharT, Traits&amp;gt;(data(), size()).starts_with(x);&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="41dbcf1025fbada0bb806a90ae80be55d2ccdbc3" translate="yes" xml:space="preserve">
          <source>All uniform random bit generators meet the &lt;a href=&quot;../named_req/uniformrandombitgenerator&quot;&gt;UniformRandomBitGenerator&lt;/a&gt; requirements. C++20 also defines a &lt;a href=&quot;random/uniformrandombitgenerator&quot;&gt;&lt;code&gt;UniformRandomBitGenerator&lt;/code&gt;&lt;/a&gt; concept.</source>
          <target state="translated">Все унифицированные генераторы случайных битов соответствуют требованиям &lt;a href=&quot;../named_req/uniformrandombitgenerator&quot;&gt;UniformRandomBitGenerator&lt;/a&gt; . C ++ 20 также определяет концепцию &lt;a href=&quot;random/uniformrandombitgenerator&quot;&gt; &lt;code&gt;UniformRandomBitGenerator&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8d23b28c0c5980cc7718a01e280ed03d0685c95f" translate="yes" xml:space="preserve">
          <source>All users have read, write, and execute/search permissions</source>
          <target state="translated">Все пользователи имеют права на чтение,запись и выполнение/поиск.</target>
        </trans-unit>
        <trans-unit id="a57778f1822ccdd378e7db95391c602549921f33" translate="yes" xml:space="preserve">
          <source>All valid permission bits.</source>
          <target state="translated">Все действительные биты разрешения.</target>
        </trans-unit>
        <trans-unit id="49247714c9e6a1264921f2f7061610f5ebfc233f" translate="yes" xml:space="preserve">
          <source>All values are required to be unique except that the values of &lt;code&gt;EOPNOTSUPP&lt;/code&gt; and &lt;code&gt;ENOTSUP&lt;/code&gt; may be identical and the values of &lt;code&gt;EAGAIN&lt;/code&gt; and &lt;code&gt;EWOULDBLOCK&lt;/code&gt; may be identical.</source>
          <target state="translated">Все значения должны быть уникальными, за исключением того, что значения &lt;code&gt;EOPNOTSUPP&lt;/code&gt; и &lt;code&gt;ENOTSUP&lt;/code&gt; могут быть идентичными, а значения &lt;code&gt;EAGAIN&lt;/code&gt; и &lt;code&gt;EWOULDBLOCK&lt;/code&gt; могут быть идентичными.</target>
        </trans-unit>
        <trans-unit id="9c56cddca11b01528f10a9f07f26dc5bec9d8e2f" translate="yes" xml:space="preserve">
          <source>All versions behave as &lt;a href=&quot;../../named_req/unformattedinputfunction&quot;&gt;UnformattedInputFunctions&lt;/a&gt;. After constructing and checking the sentry object, these functions perform the following:</source>
          <target state="translated">Все версии ведут себя как &lt;a href=&quot;../../named_req/unformattedinputfunction&quot;&gt;UnformattedInputFunctions&lt;/a&gt; . После создания и проверки сторожевого объекта эти функции выполняют следующее:</target>
        </trans-unit>
        <trans-unit id="fe817f9833c1ccda48652b1e96a5f243b7b8c465" translate="yes" xml:space="preserve">
          <source>All versions set the value of &lt;code&gt;&lt;a href=&quot;gcount&quot;&gt;gcount()&lt;/a&gt;&lt;/code&gt; to the number of characters extracted.</source>
          <target state="translated">Все версии устанавливают значение &lt;code&gt;&lt;a href=&quot;gcount&quot;&gt;gcount()&lt;/a&gt;&lt;/code&gt; количеству извлеченных символов.</target>
        </trans-unit>
        <trans-unit id="7c49bcb1867689918b55a1779cbc5e6907f7117d" translate="yes" xml:space="preserve">
          <source>All virtual base subobjects are initialized before any non-virtual base subobject, so only the most derived class calls the constructors of the virtual bases in its &lt;a href=&quot;constructor&quot;&gt;member initializer list&lt;/a&gt;:</source>
          <target state="translated">Все виртуальные базовые подобъекты инициализируются перед любым не виртуальным базовым подобъектом, поэтому только самый производный класс вызывает конструкторы виртуальных баз в своем &lt;a href=&quot;constructor&quot;&gt;списке инициализатора члена&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="7b8e5641e2d8cbf1a2bdfdaf4f5a52ae7c538b20" translate="yes" xml:space="preserve">
          <source>Allocate &lt;code&gt;size&lt;/code&gt; bytes of uninitialized storage whose alignment is specified by &lt;code&gt;alignment&lt;/code&gt;. The &lt;code&gt;size&lt;/code&gt; parameter must be an integral multiple of &lt;code&gt;alignment&lt;/code&gt;.</source>
          <target state="translated">Выделите байты &lt;code&gt;size&lt;/code&gt; неинициализированного хранилища, выравнивание которого определяется &lt;code&gt;alignment&lt;/code&gt; . Параметр &lt;code&gt;size&lt;/code&gt; должен быть целым кратным &lt;code&gt;alignment&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3713458c26ce42a8beb1ed61bfb66555a6fd00bb" translate="yes" xml:space="preserve">
          <source>Allocate memory</source>
          <target state="translated">Выделить память</target>
        </trans-unit>
        <trans-unit id="c69536036834933fadf93bcfad2311dd91d4b772" translate="yes" xml:space="preserve">
          <source>Allocate raw aligned memory from the underlying resource</source>
          <target state="translated">Выделять необработанную выровненную память из основного ресурса</target>
        </trans-unit>
        <trans-unit id="8c90ccd007d394557e735c7fe5d3753ec43eedf6" translate="yes" xml:space="preserve">
          <source>Allocates &lt;code&gt;n * sizeof(T)&lt;/code&gt; bytes of uninitialized storage by calling &lt;code&gt;::&lt;a href=&quot;../new/operator_new&quot;&gt;operator new&lt;/a&gt;(&lt;a href=&quot;../../types/size_t&quot;&gt;std::size_t&lt;/a&gt;)&lt;/code&gt;or &lt;code&gt;::&lt;a href=&quot;../new/operator_new&quot;&gt;operator new&lt;/a&gt;(&lt;a href=&quot;../../types/size_t&quot;&gt;std::size_t&lt;/a&gt;, &lt;a href=&quot;../new/align_val_t&quot;&gt;std::align_val_t&lt;/a&gt;)&lt;/code&gt;(since C++17), but it is unspecified when and how this function is called. The pointer &lt;code&gt;hint&lt;/code&gt; may be used to provide locality of reference: the allocator, if supported by the implementation, will attempt to allocate the new memory block as close as possible to &lt;code&gt;hint&lt;/code&gt;.</source>
          <target state="translated">Выделяет &lt;code&gt;n * sizeof(T)&lt;/code&gt; байтов неинициализированной памяти, вызывая &lt;code&gt;::&lt;a href=&quot;../new/operator_new&quot;&gt;operator new&lt;/a&gt;(&lt;a href=&quot;../../types/size_t&quot;&gt;std::size_t&lt;/a&gt;)&lt;/code&gt; или &lt;code&gt;::&lt;a href=&quot;../new/operator_new&quot;&gt;operator new&lt;/a&gt;(&lt;a href=&quot;../../types/size_t&quot;&gt;std::size_t&lt;/a&gt;, &lt;a href=&quot;../new/align_val_t&quot;&gt;std::align_val_t&lt;/a&gt;)&lt;/code&gt; (начиная с C ++ 17), но это не указано, когда и как эта функция вызывается. &lt;code&gt;hint&lt;/code&gt; указателя может использоваться, чтобы обеспечить местность ссылки: распределитель, если поддерживается реализацией, попытается выделить новый блок памяти как можно ближе к &lt;code&gt;hint&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e4fd50aabe78c29ec16f5fd9d57b662c1d7d801a" translate="yes" xml:space="preserve">
          <source>Allocates &lt;code&gt;nbytes&lt;/code&gt; bytes of storage at specified alignment &lt;code&gt;alignment&lt;/code&gt; using the underlying memory resource. Equivalent to &lt;code&gt;return resource()-&amp;gt;allocate(nbytes, alignment);&lt;/code&gt;</source>
          <target state="translated">Распределяет &lt;code&gt;nbytes&lt;/code&gt; байт хранения в указанном выравнивания &lt;code&gt;alignment&lt;/code&gt; , используя основной ресурс памяти. Эквивалентно &lt;code&gt;return resource()-&amp;gt;allocate(nbytes, alignment);&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="575bf26e9df794dbd1383b334ef663788e920b7e" translate="yes" xml:space="preserve">
          <source>Allocates &lt;code&gt;size&lt;/code&gt; bytes of uninitialized storage.</source>
          <target state="translated">Выделяет байты &lt;code&gt;size&lt;/code&gt; неинициализированного хранилища.</target>
        </trans-unit>
        <trans-unit id="deda37c663ffd540f8cba4cf2e2cde12e85c7e4b" translate="yes" xml:space="preserve">
          <source>Allocates and constructs an object</source>
          <target state="translated">Выделяет и конструирует объект</target>
        </trans-unit>
        <trans-unit id="37d6f4ac7e329233b5c6cfd53ae16c6539bab6fd" translate="yes" xml:space="preserve">
          <source>Allocates and constructs an object of type &lt;code&gt;U&lt;/code&gt;.</source>
          <target state="translated">Распределяет и строит объект типа &lt;code&gt;U&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="eec2cf410629d96a9a943a9c58f28ac54a41b535" translate="yes" xml:space="preserve">
          <source>Allocates memory for an array of &lt;code&gt;num&lt;/code&gt; objects of size &lt;code&gt;size&lt;/code&gt; and initializes it to all bits zero.</source>
          <target state="translated">Выделяет память для массива &lt;code&gt;num&lt;/code&gt; объектов размера &lt;code&gt;size&lt;/code&gt; и инициализирует его всеми нулевыми битами.</target>
        </trans-unit>
        <trans-unit id="9d033c92aaed0cd6d702cbb7cedf1b4eeff6647d" translate="yes" xml:space="preserve">
          <source>Allocates raw memory suitable for an object or an array</source>
          <target state="translated">Выделяет необработанную память,подходящую для объекта или массива</target>
        </trans-unit>
        <trans-unit id="cf91bb95384027fe5328e00c00aaeaa013321358" translate="yes" xml:space="preserve">
          <source>Allocates requested number of bytes. These allocation functions are called by &lt;a href=&quot;../../language/new&quot;&gt;new-expressions&lt;/a&gt; to allocate memory in which new object would then be initialized. They may also be called using regular function call syntax.</source>
          <target state="translated">Выделяет запрошенное количество байтов. Эти функции выделения вызываются выражениями &lt;a href=&quot;../../language/new&quot;&gt;new&lt;/a&gt; для выделения памяти, в которой новый объект затем инициализируется. Они также могут быть вызваны с использованием обычного синтаксиса вызова функций.</target>
        </trans-unit>
        <trans-unit id="d2fc2b0dfd842a7e3a00d1f42dd3c72c9a40aeb4" translate="yes" xml:space="preserve">
          <source>Allocates storage for &lt;code&gt;n&lt;/code&gt; objects of type &lt;code&gt;T&lt;/code&gt; using the underlying memory resource. Equivalent to &lt;code&gt;return static_cast&amp;lt;T*&amp;gt;(resource()-&amp;gt;allocate(n * sizeof(T), alignof(T)));&lt;/code&gt;.</source>
          <target state="translated">Выделяет хранилище для &lt;code&gt;n&lt;/code&gt; объектов типа &lt;code&gt;T&lt;/code&gt; , используя базовый ресурс памяти. Эквивалентно &lt;code&gt;return static_cast&amp;lt;T*&amp;gt;(resource()-&amp;gt;allocate(n * sizeof(T), alignof(T)));&lt;/code&gt; ,</target>
        </trans-unit>
        <trans-unit id="ef1e5d4c9fecdb8c77f2367b414e8a2ebe079e5f" translate="yes" xml:space="preserve">
          <source>Allocates storage for &lt;code&gt;n&lt;/code&gt; objects of type &lt;code&gt;U&lt;/code&gt; using the underlying memory resource.</source>
          <target state="translated">Выделяет хранилище для &lt;code&gt;n&lt;/code&gt; объектов типа &lt;code&gt;U&lt;/code&gt; , используя базовый ресурс памяти.</target>
        </trans-unit>
        <trans-unit id="c8d51dfb7cc15d733b905081816cec434af6b924" translate="yes" xml:space="preserve">
          <source>Allocates storage with a size of at least &lt;code&gt;bytes&lt;/code&gt; bytes, aligned to the specified &lt;code&gt;alignment&lt;/code&gt;.</source>
          <target state="translated">Выделяет хранилище размером не менее &lt;code&gt;bytes&lt;/code&gt; байтах, выровненное по указанному &lt;code&gt;alignment&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1719b83d89f242ab75b869949fb55eef6c5d0e25" translate="yes" xml:space="preserve">
          <source>Allocates storage with a size of at least &lt;code&gt;bytes&lt;/code&gt; bytes. The returned storage is aligned to the specified &lt;code&gt;alignment&lt;/code&gt; if such alignment is supported, and to &lt;code&gt;alignof(&lt;a href=&quot;../../types/max_align_t&quot;&gt;std::max_align_t&lt;/a&gt;)&lt;/code&gt; otherwise.</source>
          <target state="translated">Хранение Выделяет с размером по крайней мере &lt;code&gt;bytes&lt;/code&gt; байт. &lt;code&gt;alignof(&lt;a href=&quot;../../types/max_align_t&quot;&gt;std::max_align_t&lt;/a&gt;)&lt;/code&gt; хранилище выравнивается по указанному &lt;code&gt;alignment&lt;/code&gt; если такое выравнивание поддерживается, и выравниванию ( &lt;a href=&quot;../../types/max_align_t&quot;&gt;std :: max_align_t&lt;/a&gt; ) в противном случае.</target>
        </trans-unit>
        <trans-unit id="5fa0c7f2ed7e5ab17575514af95c1b4726f6491b" translate="yes" xml:space="preserve">
          <source>Allocates storage.</source>
          <target state="translated">Распределяет хранение.</target>
        </trans-unit>
        <trans-unit id="a4cd37a2b2f79389364650460bd02f87e623f6b0" translate="yes" xml:space="preserve">
          <source>Allocates uninitialized contiguous storage, which should be sufficient to store up to &lt;code&gt;count&lt;/code&gt; adjacent objects of type &lt;code&gt;T&lt;/code&gt;. The request is non-binding and the implementation may allocate less or more than necessary to store &lt;code&gt;count&lt;/code&gt; adjacent objects.</source>
          <target state="translated">Распределяю неинициализированную непрерывное хранение, которое должно быть достаточно , чтобы хранить до &lt;code&gt;count&lt;/code&gt; смежных объектов типа &lt;code&gt;T&lt;/code&gt; . Запрос не является обязательным, и реализация может выделять меньше или больше, чем необходимо для сохранения &lt;code&gt;count&lt;/code&gt; смежных объектов.</target>
        </trans-unit>
        <trans-unit id="1b5c021aee14bea734803bc4262d3ac794a7f664" translate="yes" xml:space="preserve">
          <source>Allocation</source>
          <target state="translated">Allocation</target>
        </trans-unit>
        <trans-unit id="7e5a93aa2050aa67c4b2a8fa0227ec2d570a5f78" translate="yes" xml:space="preserve">
          <source>Allocation functions</source>
          <target state="translated">Распределительные функции</target>
        </trans-unit>
        <trans-unit id="bcdc03b4788456846d38f2b2c7a10637d4ba865e" translate="yes" xml:space="preserve">
          <source>Allocations requests that exceed the largest block size are served from the</source>
          <target state="translated">Запросы на выделение ассигнований,превышающие по размеру наибольший блок,обслуживаются из</target>
        </trans-unit>
        <trans-unit id="cbf9e75065cafb419b19fb5a13dddefb2735eaa6" translate="yes" xml:space="preserve">
          <source>Allocator</source>
          <target state="translated">Allocator</target>
        </trans-unit>
        <trans-unit id="c26087d42681b7f6e496369e9c820f3e757778ab" translate="yes" xml:space="preserve">
          <source>Allocator completeness requirements</source>
          <target state="translated">Требования к полноте распределения</target>
        </trans-unit>
        <trans-unit id="006db541d4a947093a399166c59d14c227c66a14" translate="yes" xml:space="preserve">
          <source>Allocator for &lt;code&gt;T&lt;/code&gt;</source>
          <target state="translated">Распределитель для &lt;code&gt;T&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a14116cd7defc5cfe1008ae088831e83125981b1" translate="yes" xml:space="preserve">
          <source>Allocator of a type convertible to &lt;code&gt;A&lt;/code&gt;</source>
          <target state="translated">Распределитель типа, конвертируемого в &lt;code&gt;A&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="71d3d89dd86b8060b5c2c3dff2ad831f3f7d33f4" translate="yes" xml:space="preserve">
          <source>Allocator type</source>
          <target state="translated">Тип Распределителя</target>
        </trans-unit>
        <trans-unit id="c5e06a85490c85e6350aa5bd28390e1ead65f231" translate="yes" xml:space="preserve">
          <source>Allocator-aware containers always call &lt;code&gt;&lt;a href=&quot;../memory/allocator_traits&quot;&gt;std::allocator_traits&lt;/a&gt;&amp;lt;A&amp;gt;::construct(m, p, args)&lt;/code&gt; to construct an object of type &lt;code&gt;A&lt;/code&gt; at &lt;code&gt;p&lt;/code&gt; using &lt;code&gt;args&lt;/code&gt;, with &lt;code&gt;m == get_allocator()&lt;/code&gt;. The default &lt;code&gt;construct&lt;/code&gt; in &lt;code&gt;&lt;a href=&quot;../memory/allocator&quot;&gt;std::allocator&lt;/a&gt;&lt;/code&gt; calls &lt;code&gt;::new((void*)p) T(args)&lt;/code&gt;, but specialized allocators may choose a different definition.</source>
          <target state="translated">Контейнеры, поддерживающие &lt;code&gt;&lt;a href=&quot;../memory/allocator_traits&quot;&gt;std::allocator_traits&lt;/a&gt;&amp;lt;A&amp;gt;::construct(m, p, args)&lt;/code&gt; всегда вызывают std :: allocator_traits &amp;lt;A&amp;gt; :: construct (m, p, args) для создания объекта типа &lt;code&gt;A&lt;/code&gt; в &lt;code&gt;p&lt;/code&gt; с использованием &lt;code&gt;args&lt;/code&gt; , с &lt;code&gt;m == get_allocator()&lt;/code&gt; . По умолчанию &lt;code&gt;construct&lt;/code&gt; в &lt;code&gt;&lt;a href=&quot;../memory/allocator&quot;&gt;std::allocator&lt;/a&gt;&lt;/code&gt; вызовов &lt;code&gt;::new((void*)p) T(args)&lt;/code&gt; , но специализированные распределители могут выбрать другое определение.</target>
        </trans-unit>
        <trans-unit id="34acd9339509e4e1e31704ab4c073ecbdafd1f25" translate="yes" xml:space="preserve">
          <source>AllocatorAwareContainer</source>
          <target state="translated">AllocatorAwareContainer</target>
        </trans-unit>
        <trans-unit id="5ceb7c7c9f3657e9513254564292abfe012cfefb" translate="yes" xml:space="preserve">
          <source>Allocators</source>
          <target state="translated">Allocators</target>
        </trans-unit>
        <trans-unit id="629f37bb798c36a67317aa9ec0378bd852ec9f11" translate="yes" xml:space="preserve">
          <source>Allocators are class templates encapsulating memory allocation strategy. This allows generic containers to decouple memory management from the data itself.</source>
          <target state="translated">Распределители-это шаблоны классов,инкапсулирующие стратегию выделения памяти.Это позволяет развязывать управление памятью от самих данных.</target>
        </trans-unit>
        <trans-unit id="095c1a8ff16049f04c3471ba9a37d8292cb9648d" translate="yes" xml:space="preserve">
          <source>Allow constant evaluation for all &lt;a href=&quot;language/template_parameters#Template_non-type_arguments&quot;&gt;non-type template arguments&lt;/a&gt;</source>
          <target state="translated">Разрешить постоянную оценку для всех &lt;a href=&quot;language/template_parameters#Template_non-type_arguments&quot;&gt;нетиповых аргументов шаблона&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="8672315bab526e017a0da6b4db8394d5643bd21c" translate="yes" xml:space="preserve">
          <source>Allow the compiler to optimize for the case where paths of execution including that statement are more or less likely than any alternative path of execution that does not include such a statement.</source>
          <target state="translated">Позвольте компилятору оптимизировать для случая,когда пути выполнения,включая такой оператор,более или менее вероятны,чем любой альтернативный путь выполнения,который не включает такой оператор.</target>
        </trans-unit>
        <trans-unit id="03388373add47a2fa22bbeb6dede9123b781ba3f" translate="yes" xml:space="preserve">
          <source>Allows a function to accept any number of arguments.</source>
          <target state="translated">Позволяет функции принимать любое количество аргументов.</target>
        </trans-unit>
        <trans-unit id="411787b050d38051721728f3a87d5174918b5c69" translate="yes" xml:space="preserve">
          <source>Allows a function to be called without providing one or more trailing arguments.</source>
          <target state="translated">Позволяет вызывать функцию без предоставления одного или нескольких аргументов-трейлингов.</target>
        </trans-unit>
        <trans-unit id="459d9517d5603efba94121b4d2acec3f8491a657" translate="yes" xml:space="preserve">
          <source>Allows any and all code transformations that do not change the observable behavior of the program.</source>
          <target state="translated">Позволяет любые и все преобразования кода,не изменяющие наблюдаемое поведение программы.</target>
        </trans-unit>
        <trans-unit id="f7fd47c92a72794dea3d8bd7149aab52470581d7" translate="yes" xml:space="preserve">
          <source>Allows customizing class and variable(since C++14) templates for a given category of template arguments.</source>
          <target state="translated">Позволяет настраивать шаблоны классов и переменных(начиная с C++14)для заданной категории шаблонных аргументов.</target>
        </trans-unit>
        <trans-unit id="36e28bc484be80710ded433fdd6ceb2b32b730fd" translate="yes" xml:space="preserve">
          <source>Allows customizing the template code for a given set of template arguments.</source>
          <target state="translated">Позволяет настроить код шаблона для заданного набора аргументов шаблона.</target>
        </trans-unit>
        <trans-unit id="a8bf676764b0183a61de1aa7f44f4c55b945bd3c" translate="yes" xml:space="preserve">
          <source>Allows insertion and extraction of quoted strings, such as the ones found in CSV or XML.</source>
          <target state="translated">Позволяет вставлять и извлекать цитируемые строки,например,найденные в CSV или XML.</target>
        </trans-unit>
        <trans-unit id="1433f306e640197740511f48680f25d7413dc2e9" translate="yes" xml:space="preserve">
          <source>Allows integer, floating-point, character, and string literals to produce objects of user-defined type by defining a user-defined suffix.</source>
          <target state="translated">Позволяет целочисленным,с плавающей точкой,символьным и строковым литералам создавать объекты пользовательского типа,определяя пользовательский суффикс.</target>
        </trans-unit>
        <trans-unit id="714a3428d46162788e491e8dc3208e88274f1f2f" translate="yes" xml:space="preserve">
          <source>Allows the size of an empty base subobject to be zero.</source>
          <target state="translated">Позволяет обнулить размер пустого базового подобъекта.</target>
        </trans-unit>
        <trans-unit id="ccb54e9be1a4c6bc9837fefd7cc02f1997a12f3c" translate="yes" xml:space="preserve">
          <source>Allows values of integer type to be used in expressions directly.</source>
          <target state="translated">Позволяет напрямую использовать в выражениях значения целочисленного типа.</target>
        </trans-unit>
        <trans-unit id="9a0c4d0005f924626f07462db95d58f6067b54a8" translate="yes" xml:space="preserve">
          <source>Also because braced-init-list has no type, &lt;a href=&quot;overload_resolution#Implicit_conversion_sequence_in_list-initialization&quot;&gt;special rules for overload resolution&lt;/a&gt; apply when it is used as an argument to an overloaded function call.</source>
          <target state="translated">Кроме того, поскольку braced-init-list не имеет типа, &lt;a href=&quot;overload_resolution#Implicit_conversion_sequence_in_list-initialization&quot;&gt;специальные правила для разрешения перегрузки&lt;/a&gt; применяются, когда они используются в качестве аргумента для вызова перегруженной функции.</target>
        </trans-unit>
        <trans-unit id="3b587e48dc1be81684dc5d496c6af85f6a461578" translate="yes" xml:space="preserve">
          <source>Also provided are the C-style date and time functions, such as &lt;code&gt;&lt;a href=&quot;chrono/c/time_t&quot;&gt;std::time_t&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;chrono/c/difftime&quot;&gt;std::difftime&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;chrono/c/clocks_per_sec&quot;&gt;CLOCKS_PER_SEC&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Также предоставляются функции даты и времени в стиле C, такие как &lt;code&gt;&lt;a href=&quot;chrono/c/time_t&quot;&gt;std::time_t&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;chrono/c/difftime&quot;&gt;std::difftime&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;chrono/c/clocks_per_sec&quot;&gt;CLOCKS_PER_SEC&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="729da59cb6e707c89f461faec986a483c428299a" translate="yes" xml:space="preserve">
          <source>Also, all &lt;a href=&quot;language/name&quot;&gt;identifiers&lt;/a&gt; that contain a double underscore __ in any position and each identifier that begins with an underscore followed by an uppercase letter is always reserved and all identifiers that begin with an underscore are reserved for use as names in the global namespace. See &lt;a href=&quot;language/name&quot;&gt;identifiers&lt;/a&gt; for more details.</source>
          <target state="translated">Кроме того, все &lt;a href=&quot;language/name&quot;&gt;идентификаторы,&lt;/a&gt; которые содержат двойное подчеркивание __ в любой позиции, и каждый идентификатор, начинающийся со знака подчеркивания, за которым следует заглавная буква, всегда зарезервирован, а все идентификаторы, начинающиеся со знака подчеркивания, зарезервированы для использования в качестве имен в глобальном пространстве имен. Смотрите &lt;a href=&quot;language/name&quot;&gt;идентификаторы&lt;/a&gt; для более подробной информации.</target>
        </trans-unit>
        <trans-unit id="8790a9cbd433decb4fdf7491221b8bbc56822f99" translate="yes" xml:space="preserve">
          <source>Also, on some platforms, bit fields are packed left-to-right, on others right-to-left</source>
          <target state="translated">Кроме того,на некоторых платформах битовые поля упаковываются слева направо,на других-справа налево.</target>
        </trans-unit>
        <trans-unit id="5b07b0bdeb35442e306edb6a6d7347901e47e660" translate="yes" xml:space="preserve">
          <source>Also, the standard library functions called with xvalue arguments may assume the argument is the only reference to the object; if it was constructed from an lvalue with &lt;code&gt;std::move&lt;/code&gt;, no aliasing checks are made. In particular, this means that standard library move assignment operators do not have to perform self-assignment checks:</source>
          <target state="translated">Кроме того, стандартные библиотечные функции, вызываемые с аргументами xvalue, могут предполагать, что аргумент является единственной ссылкой на объект; если он был создан из lvalue с помощью &lt;code&gt;std::move&lt;/code&gt; , проверки алиасов не выполняются. В частности, это означает, что стандартные операторы присваивания перемещений библиотеки не должны выполнять проверки самоназначения:</target>
        </trans-unit>
        <trans-unit id="9465911da185e318d4f902c965db53e7bdd827fb" translate="yes" xml:space="preserve">
          <source>Also, unlike the formatted output functions, this function does not set the &lt;code&gt;failbit&lt;/code&gt; on failure.</source>
          <target state="translated">Кроме того, в отличие от форматированных функций вывода, эта функция не устанавливает &lt;code&gt;failbit&lt;/code&gt; при сбое.</target>
        </trans-unit>
        <trans-unit id="3b74e96e489cf616e54374e5e92ff3290101f441" translate="yes" xml:space="preserve">
          <source>Alternative</source>
          <target state="translated">Alternative</target>
        </trans-unit>
        <trans-unit id="2e4d959d6a71905b14d43661b5387037b9b586bd" translate="yes" xml:space="preserve">
          <source>Alternative operator representations</source>
          <target state="translated">Альтернативные представления оператора</target>
        </trans-unit>
        <trans-unit id="c8b93e0cfffeb74171554b62200f1f073639dd68" translate="yes" xml:space="preserve">
          <source>Alternative operator syntax</source>
          <target state="translated">Альтернативный синтаксис оператора</target>
        </trans-unit>
        <trans-unit id="e32467443dfa96c0777ac9526ba4d4884bea25fb" translate="yes" xml:space="preserve">
          <source>Alternative tokens</source>
          <target state="translated">Альтернативные жетоны</target>
        </trans-unit>
        <trans-unit id="3a4be7155bcffba0850c80a370bc5c6b34c37e74" translate="yes" xml:space="preserve">
          <source>Alternatives</source>
          <target state="translated">Alternatives</target>
        </trans-unit>
        <trans-unit id="f33a42489881f94fe215353e72be54816924c644" translate="yes" xml:space="preserve">
          <source>Although &lt;code&gt;&lt;a href=&quot;../error/exception/uncaught_exception&quot;&gt;std::uncaught_exception&lt;/a&gt;&lt;/code&gt; may sometimes be used to detect stack unwinding in progress, it is generally considered bad practice to allow any destructor to terminate by throwing an exception. This functionality is nevertheless used by some libraries, such as &lt;a href=&quot;https://github.com/SOCI/soci&quot;&gt;SOCI&lt;/a&gt; and &lt;a href=&quot;http://galeracluster.com/downloads/&quot;&gt;Galera 3&lt;/a&gt;, which rely on the ability of the destructors of nameless temporaries to throw exceptions at the end of the full expression that constructs the temporary.</source>
          <target state="translated">Хотя &lt;code&gt;&lt;a href=&quot;../error/exception/uncaught_exception&quot;&gt;std::uncaught_exception&lt;/a&gt;&lt;/code&gt; иногда может использоваться для обнаружения процесса раскручивания стека, обычно считается плохой практикой разрешать любому деструктору завершать работу, выдавая исключение. Эта функциональность, тем не менее, используется некоторыми библиотеками, такими как &lt;a href=&quot;https://github.com/SOCI/soci&quot;&gt;SOCI&lt;/a&gt; и &lt;a href=&quot;http://galeracluster.com/downloads/&quot;&gt;Galera 3&lt;/a&gt; , которые полагаются на способность деструкторов безымянных временных объектов генерировать исключения в конце полного выражения, которое создает временное.</target>
        </trans-unit>
        <trans-unit id="ea2b684e4b095592200988c7ab99debb5b70a888" translate="yes" xml:space="preserve">
          <source>Although &lt;code&gt;std::pow&lt;/code&gt; cannot be used to obtain a root of a negative number, &lt;code&gt;&lt;a href=&quot;cbrt&quot;&gt;std::cbrt&lt;/a&gt;&lt;/code&gt; is provided for the common case where &lt;code&gt;exp&lt;/code&gt; is 1/3.</source>
          <target state="translated">Хотя &lt;code&gt;std::pow&lt;/code&gt; не может быть использован для получения корня отрицательного числа, &lt;code&gt;&lt;a href=&quot;cbrt&quot;&gt;std::cbrt&lt;/a&gt;&lt;/code&gt; предусмотрен для общего случая, когда &lt;code&gt;exp&lt;/code&gt; равен 1/3.</target>
        </trans-unit>
        <trans-unit id="b0bbe9c54239a7325e443792536d8b4342054835" translate="yes" xml:space="preserve">
          <source>Although &lt;code&gt;std::scalbn&lt;/code&gt; and &lt;code&gt;std::scalbln&lt;/code&gt; are specified to perform the operation efficiently, on many implementations they are less efficient than multiplication or division by a power of two using arithmetic operators.</source>
          <target state="translated">Хотя &lt;code&gt;std::scalbn&lt;/code&gt; и &lt;code&gt;std::scalbln&lt;/code&gt; определены для эффективного выполнения операции, во многих реализациях они менее эффективны, чем умножение или деление на степень два с использованием арифметических операторов.</target>
        </trans-unit>
        <trans-unit id="3d1825778acdae18596af041fff74b7b10c86289" translate="yes" xml:space="preserve">
          <source>Although &lt;code&gt;std::unique_ptr&amp;lt;T&amp;gt;&lt;/code&gt; with the default deleter may be constructed with &lt;a href=&quot;../../language/incomplete_type&quot;&gt;incomplete type&lt;/a&gt;&lt;code&gt;T&lt;/code&gt;, the type &lt;code&gt;T&lt;/code&gt; must be complete at the point of code where the destructor is called.</source>
          <target state="translated">Хотя &lt;code&gt;std::unique_ptr&amp;lt;T&amp;gt;&lt;/code&gt; со средством удаления по умолчанию может быть создан с &lt;a href=&quot;../../language/incomplete_type&quot;&gt;неполным типом &lt;/a&gt; &lt;code&gt;T&lt;/code&gt; , тип &lt;code&gt;T&lt;/code&gt; должен быть завершен в той точке кода, где вызывается деструктор.</target>
        </trans-unit>
        <trans-unit id="439c84aa6d4f184555f03b26b3fb02df31f3c81c" translate="yes" xml:space="preserve">
          <source>Although a function call can be resolved through ADL even if ordinary lookup finds nothing, a function call to a &lt;a href=&quot;function_template&quot;&gt;function template&lt;/a&gt; with explicitly-specified template arguments requires that there is a declaration of the template found by ordinary lookup (otherwise, it is a syntax error to encounter an unknown name followed by a less-than character).</source>
          <target state="translated">Хотя вызов функции может быть разрешен через ADL, даже если обычный поиск ничего не находит, вызов &lt;a href=&quot;function_template&quot;&gt;функции для шаблона функции&lt;/a&gt; с явно указанными аргументами шаблона требует, чтобы при обычном поиске было объявлено, что шаблон найден (в противном случае это синтаксическая ошибка встретить неизвестное имя, за которым следует символ меньше чем).</target>
        </trans-unit>
        <trans-unit id="f1ebb0e824901f4ec3f02ea57f64d9e4828306f2" translate="yes" xml:space="preserve">
          <source>Although a zero-initialized &lt;code&gt;&lt;a href=&quot;mbstate_t&quot;&gt;std::mbstate_t&lt;/a&gt;&lt;/code&gt; always represents the initial conversion state, there may be other values of &lt;code&gt;&lt;a href=&quot;mbstate_t&quot;&gt;std::mbstate_t&lt;/a&gt;&lt;/code&gt; that also represent the initial conversion state.</source>
          <target state="translated">Хотя инициализированный нулем &lt;code&gt;&lt;a href=&quot;mbstate_t&quot;&gt;std::mbstate_t&lt;/a&gt;&lt;/code&gt; всегда представляет начальное состояние преобразования, могут существовать другие значения &lt;code&gt;&lt;a href=&quot;mbstate_t&quot;&gt;std::mbstate_t&lt;/a&gt;&lt;/code&gt; которые также представляют начальное состояние преобразования.</target>
        </trans-unit>
        <trans-unit id="f708528328b72807fc0654354970ef41ee70cd4b" translate="yes" xml:space="preserve">
          <source>Although arrays cannot be returned from functions by value and cannot be targets of most cast expressions, array &lt;a href=&quot;value_category&quot;&gt;prvalues&lt;/a&gt; may be formed by using a type alias to construct an array temporary using &lt;a href=&quot;explicit_cast&quot;&gt;brace-initialized functional cast&lt;/a&gt;.</source>
          <target state="translated">Хотя массивы не могут быть возвращены из функций по значению и не могут быть целью большинства выражений приведения, значения &lt;a href=&quot;value_category&quot;&gt;значений&lt;/a&gt; массива могут быть сформированы с использованием псевдонима типа для временного создания массива с использованием &lt;a href=&quot;explicit_cast&quot;&gt;инициализированного &lt;/a&gt;фигурным скобками функционального приведения .</target>
        </trans-unit>
        <trans-unit id="1fd9b3c6d07c5655b399e6be4424fee0edae9357" translate="yes" xml:space="preserve">
          <source>Although canonical form of pre-increment/pre-decrement returns a reference, as with any operator overload, the return type is user-defined; for example the overloads of these operators for &lt;code&gt;&lt;a href=&quot;../atomic/atomic&quot;&gt;std::atomic&lt;/a&gt;&lt;/code&gt; return by value.</source>
          <target state="translated">Хотя каноническая форма предварительного увеличения / предварительного уменьшения возвращает ссылку, как и при любой перегрузке оператора, тип возвращаемого значения определяется пользователем; например, перегрузки этих операторов для &lt;code&gt;&lt;a href=&quot;../atomic/atomic&quot;&gt;std::atomic&lt;/a&gt;&lt;/code&gt; возвращаются по значению.</target>
        </trans-unit>
        <trans-unit id="2de2491baa0eb4945c698a40f7cf02c5b5ff7ca9" translate="yes" xml:space="preserve">
          <source>Although decl-specifier-seq implies there can exist &lt;a href=&quot;declarations#Specifiers&quot;&gt;specifiers&lt;/a&gt; other than type specifiers, the only other specifier allowed is &lt;code&gt;register&lt;/code&gt;as well as &lt;code&gt;auto&lt;/code&gt;(until C++11), and it has no effect.</source>
          <target state="translated">Хотя decl-specier-seq подразумевает, что могут существовать &lt;a href=&quot;declarations#Specifiers&quot;&gt;спецификаторы,&lt;/a&gt; отличные от спецификаторов типов, единственный допустимый спецификатор - это &lt;code&gt;register&lt;/code&gt; а также &lt;code&gt;auto&lt;/code&gt; (до C ++ 11), и он не имеет никакого эффекта.</target>
        </trans-unit>
        <trans-unit id="14b7b14235553f3b91083c0b71081ba75f07e98f" translate="yes" xml:space="preserve">
          <source>Although no class is its own base, &lt;code&gt;std::is_base_of&amp;lt;T, T&amp;gt;::value&lt;/code&gt; is true because the intent of the trait is to model the &quot;is-a&quot; relationship, and T is a T. Despite that, &lt;code&gt;std::is_base_of&amp;lt;int, int&amp;gt;::value&lt;/code&gt; is false because only classes participate in the relationship that this trait models.</source>
          <target state="translated">Хотя ни один из классов не является собственной базой, &lt;code&gt;std::is_base_of&amp;lt;T, T&amp;gt;::value&lt;/code&gt; имеет значение true, поскольку целью этой черты является моделирование отношения &quot;is-a&quot;, а T - это T. Несмотря на это, &lt;code&gt;std::is_base_of&amp;lt;int, int&amp;gt;::value&lt;/code&gt; имеет значение false, потому что только классы участвуют в отношениях, которые моделирует эта черта.</target>
        </trans-unit>
        <trans-unit id="119fa9e7db8c27df8ae932b0248b04e4bfefb226" translate="yes" xml:space="preserve">
          <source>Although not defined, this is almost always an integral value holding the number of seconds (not counting leap seconds) since 00:00, Jan 1 1970 UTC, corresponding to &lt;a href=&quot;https://en.wikipedia.org/wiki/Unix_time&quot;&gt; POSIX time&lt;/a&gt;.</source>
          <target state="translated">Хотя это и не определено, это почти всегда интегральное значение, содержащее количество секунд (не считая високосных секунд) с 00:00 1 января 1970 года по Гринвичу, соответствующее &lt;a href=&quot;https://en.wikipedia.org/wiki/Unix_time&quot;&gt;времени POSIX&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ac8975eb41b5df62d74c9b6ae1a1689383a4d797" translate="yes" xml:space="preserve">
          <source>Although references, once initialized, always refer to valid objects or functions, it is possible to create a program where the &lt;a href=&quot;lifetime&quot;&gt;lifetime&lt;/a&gt; of the referred-to object ends, but the reference remains accessible (</source>
          <target state="translated">Хотя ссылки, будучи инициализированными, всегда ссылаются на действительные объекты или функции, можно создать программу, в которой время &lt;a href=&quot;lifetime&quot;&gt;жизни&lt;/a&gt; упомянутого объекта заканчивается, но ссылка остается доступной (</target>
        </trans-unit>
        <trans-unit id="6c367e67cfae5a3c20e167ab56108c7704f6c4ad" translate="yes" xml:space="preserve">
          <source>Although synchronized blocks execute as-if under a global lock, the implementations are expected to examine the code within each block and use optimistic concurrency (backed up by hardware transactional memory where available) for transaction-safe code and minimal locking for non-transaction safe code. When a synchronized block makes a call to a non-inlined function, the compiler may have to drop out of speculative execution and hold a lock around the entire call unless the function is declared &lt;code&gt;transaction_safe&lt;/code&gt; (see below) or the attribute &lt;code&gt;[[optimize_for_synchronized]]&lt;/code&gt; (see below) is used.</source>
          <target state="translated">Хотя синхронизированные блоки выполняются как-будто под глобальной блокировкой, ожидается, что реализации будут проверять код в каждом блоке и использовать оптимистичный параллелизм (поддерживаемый аппаратной транзакционной памятью, где он доступен) для кода, безопасного для транзакций, и минимальную блокировку для обеспечения безопасности без транзакций код. Когда синхронизированный блок делает вызов к не встраиваются функции, компилятор , возможно , придется выпасть из спекулятивного исполнения и держать блокировку вокруг всего вызова , если функция объявлена &lt;code&gt;transaction_safe&lt;/code&gt; (смотри ниже) или атрибут &lt;code&gt;[[optimize_for_synchronized]]&lt;/code&gt; (см. ниже) используется.</target>
        </trans-unit>
        <trans-unit id="dad5173c2001f38e75509fd69dc64ba3e87866b3" translate="yes" xml:space="preserve">
          <source>Although the C standard (to which C++ refers for this function) names this function &quot;arc hyperbolic cosine&quot;, the inverse functions of the hyperbolic functions are the area functions. Their argument is the area of a hyperbolic sector, not an arc. The correct name is &quot;inverse hyperbolic cosine&quot; (used by POSIX) or &quot;area hyperbolic cosine&quot;.</source>
          <target state="translated">Хотя стандарт С (к которому С++относится для этой функции)называет эту функцию &quot;дуговой гиперболический косинус&quot;,обратные функции гиперболических функций являются зональными функциями.Их аргументом является область гиперболического сектора,а не дуга.Правильное название-&quot;обратный гиперболический косинус&quot; (используется POSIX)или &quot;пространственный гиперболический косинус&quot;.</target>
        </trans-unit>
        <trans-unit id="a1733c8cc2a0d050132b6b9364d6944323c32b74" translate="yes" xml:space="preserve">
          <source>Although the C standard (to which C++ refers for this function) names this function &quot;arc hyperbolic sine&quot;, the inverse functions of the hyperbolic functions are the area functions. Their argument is the area of a hyperbolic sector, not an arc. The correct name is &quot;inverse hyperbolic sine&quot; (used by POSIX) or &quot;area hyperbolic sine&quot;.</source>
          <target state="translated">Хотя стандарт С (к которому С++относится для этой функции)называет эту функцию &quot;дуговой гиперболический синус&quot;,обратные функции гиперболических функций являются зональными функциями.Их аргументом является область гиперболического сектора,а не дуга.Правильное название-&quot;обратный гиперболический синус&quot; (используется POSIX)или &quot;пространственный гиперболический синус&quot;.</target>
        </trans-unit>
        <trans-unit id="4277fd8c5f429dde16accb19c538a3e9d0e882ce" translate="yes" xml:space="preserve">
          <source>Although the C standard (to which C++ refers for this function) names this function &quot;arc hyperbolic tangent&quot;, the inverse functions of the hyperbolic functions are the area functions. Their argument is the area of a hyperbolic sector, not an arc. The correct name is &quot;inverse hyperbolic tangent&quot; (used by POSIX) or &quot;area hyperbolic tangent&quot;.</source>
          <target state="translated">Хотя стандарт C (на который ссылается C++для этой функции)называет эту функцию &quot;дуговой гиперболический тангенс&quot;,обратные функции гиперболических функций являются зональными функциями.Их аргументом является область гиперболического сектора,а не дуга.Правильное название-&quot;обратный гиперболический тангенс&quot; (используется POSIX)или &quot;областной гиперболический тангенс&quot;.</target>
        </trans-unit>
        <trans-unit id="91479e7f0ee3ff1337daf6434e5f71cdfdc3c6a6" translate="yes" xml:space="preserve">
          <source>Although the C++ standard names this function &quot;complex arc hyperbolic cosine&quot;, the inverse functions of the hyperbolic functions are the area functions. Their argument is the area of a hyperbolic sector, not an arc. The correct name is &quot;complex inverse hyperbolic cosine&quot;, and, less common, &quot;complex area hyperbolic cosine&quot;.</source>
          <target state="translated">Хотя в стандарте С++эта функция называется &quot;сложным дуговым гиперболическим косинусом&quot;,обратные функции гиперболических функций являются областными функциями.Их аргументом является область гиперболического сектора,а не дуга.Правильное название-&quot;сложный обратный гиперболический косинус&quot; и,реже,&quot;сложный пространственный гиперболический косинус&quot;.</target>
        </trans-unit>
        <trans-unit id="6a7e68fe75439346aeaad1f6906c84e17daadb3b" translate="yes" xml:space="preserve">
          <source>Although the C++ standard names this function &quot;complex arc hyperbolic sine&quot;, the inverse functions of the hyperbolic functions are the area functions. Their argument is the area of a hyperbolic sector, not an arc. The correct name is &quot;complex inverse hyperbolic sine&quot;, and, less common, &quot;complex area hyperbolic sine&quot;.</source>
          <target state="translated">Хотя в стандарте С++эта функция называется &quot;сложный арктический гиперболический синус&quot;,обратные функции гиперболических функций являются областными функциями.Их аргументом является область гиперболического сектора,а не дуга.Правильное название-&quot;сложный обратный гиперболический синус&quot; и,реже,&quot;сложный пространственный гиперболический синус&quot;.</target>
        </trans-unit>
        <trans-unit id="8d2c788effcf0da46c782a95d9a9fd3b66474139" translate="yes" xml:space="preserve">
          <source>Although the C++ standard names this function &quot;complex arc hyperbolic tangent&quot;, the inverse functions of the hyperbolic functions are the area functions. Their argument is the area of a hyperbolic sector, not an arc. The correct name is &quot;complex inverse hyperbolic tangent&quot;, and, less common, &quot;complex area hyperbolic tangent&quot;.</source>
          <target state="translated">Хотя в стандарте C++эта функция называется &quot;сложный дуговой гиперболический тангенс&quot;,обратные функции гиперболических функций являются функциями области.Их аргументом является область гиперболического сектора,а не дуга.Правильное название-&quot;сложный обратный гиперболический тангенс&quot;,и,реже,&quot;сложный областной гиперболический тангенс&quot;.</target>
        </trans-unit>
        <trans-unit id="fd70e10e04c4727c7eb398861b7b422e51e53f42" translate="yes" xml:space="preserve">
          <source>Although the C++11 standard still says &quot;On most machines, this is true for signed integers.&quot;, it is a defect and has been corrected. The exact wording changed from C++03 to C++11 in such a way that the &lt;code&gt;true&lt;/code&gt; value is no longer compatible with &lt;a href=&quot;../../language/operator_arithmetic#Overflows&quot;&gt;undefined behavior on signed integer overflow&lt;/a&gt;. Because of that, the implementations that rely on signed overflow being undefined (for optimization opportunities) now set &lt;code&gt;is_modulo&lt;/code&gt; to &lt;code&gt;false&lt;/code&gt; for signed integers. See for example &lt;a href=&quot;http://gcc.gnu.org/bugzilla/show_bug.cgi?id=22200&quot;&gt;GCC PR 22200&lt;/a&gt;.</source>
          <target state="translated">Хотя стандарт C ++ 11 по-прежнему гласит: &amp;laquo;На большинстве машин это верно для целых чисел со знаком&amp;raquo;, это дефект, который был исправлен. Точная формулировка изменилась с C ++ 03 на C ++ 11 таким образом, что &lt;code&gt;true&lt;/code&gt; значение больше не совместимо с &lt;a href=&quot;../../language/operator_arithmetic#Overflows&quot;&gt;неопределенным поведением при переполнении целых чисел со знаком&lt;/a&gt; . Из-за этого реализации, которые полагаются на неопределенность переполнения со &lt;code&gt;is_modulo&lt;/code&gt; (для возможностей оптимизации), теперь устанавливают для is_modulo значение &lt;code&gt;false&lt;/code&gt; для целых чисел со знаком . См. Например, &lt;a href=&quot;http://gcc.gnu.org/bugzilla/show_bug.cgi?id=22200&quot;&gt;GCC PR 22200&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="73c3fb8cae35d1afdb844e48a3d68c51dd534493" translate="yes" xml:space="preserve">
          <source>Although the C++11 standard still says &quot;On most machines, this is true for signed integers.&quot;, it is a defect and has been corrected. The exact wording changed from C++03 to C++11 in such a way that the &lt;code&gt;true&lt;/code&gt; value is no longer compatible with &lt;a href=&quot;../../language/operator_arithmetic#Overflows&quot;&gt;undefined behavior on signed integer overflow&lt;/a&gt;. Because of that, the implementations that rely on signed overflow being undefined (for optimization opportunities) now set &lt;code&gt;is_modulo&lt;/code&gt; to &lt;code&gt;false&lt;/code&gt; for signed integers. See for example &lt;a href=&quot;https://gcc.gnu.org/bugzilla/show_bug.cgi?id=22200&quot;&gt;GCC PR 22200&lt;/a&gt;.</source>
          <target state="translated">Хотя стандарт C ++ 11 по-прежнему говорит: &amp;laquo;На большинстве машин это верно для целых чисел со знаком&amp;raquo;, это дефект, и он был исправлен. Точная формулировка изменилась с C ++ 03 на C ++ 11 таким образом, что &lt;code&gt;true&lt;/code&gt; значение больше не совместимо с &lt;a href=&quot;../../language/operator_arithmetic#Overflows&quot;&gt;неопределенным поведением при переполнении целого числа со знаком&lt;/a&gt; . Из-за этого реализации, которые полагаются на то, что подписанное переполнение не определено (для возможностей оптимизации), теперь устанавливают &lt;code&gt;is_modulo&lt;/code&gt; в &lt;code&gt;false&lt;/code&gt; для целых чисел со знаком . См., Например, &lt;a href=&quot;https://gcc.gnu.org/bugzilla/show_bug.cgi?id=22200&quot;&gt;GCC PR 22200&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="661de5137e7e9dcc1cb0c7e5d23a45a40d059e70" translate="yes" xml:space="preserve">
          <source>Although the definition uses &lt;code&gt;-1&lt;/code&gt;, &lt;a href=&quot;../basic_string&quot;&gt;&lt;code&gt;size_type&lt;/code&gt;&lt;/a&gt; is an unsigned integer type, and the value of &lt;code&gt;npos&lt;/code&gt; is the largest positive value it can hold, due to &lt;a href=&quot;../../language/implicit_cast#Integral_conversions&quot;&gt;signed-to-unsigned implicit conversion&lt;/a&gt;. This is a portable way to specify the largest value of any unsigned type.</source>
          <target state="translated">Хотя в определении используется &lt;code&gt;-1&lt;/code&gt; , &lt;a href=&quot;../basic_string&quot;&gt; &lt;code&gt;size_type&lt;/code&gt; &lt;/a&gt; - это целочисленный тип без знака, а значение &lt;code&gt;npos&lt;/code&gt; - это наибольшее положительное значение, которое оно может содержать из &lt;a href=&quot;../../language/implicit_cast#Integral_conversions&quot;&gt;-за неявного преобразования&lt;/a&gt; со знаком в без знака . Это портативный способ указать наибольшее значение любого типа без знака.</target>
        </trans-unit>
        <trans-unit id="1abd2f0bb23531226358684e90cc6818e8f8598e" translate="yes" xml:space="preserve">
          <source>Although the expression &lt;code&gt;++c.begin()&lt;/code&gt; often compiles, it is not guaranteed to do so: &lt;code&gt;c.begin()&lt;/code&gt; is an rvalue expression, and there is no &lt;a href=&quot;../named_req/bidirectionaliterator&quot;&gt;LegacyBidirectionalIterator&lt;/a&gt; requirement that specifies that increment of an rvalue is guaranteed to work. In particular, when iterators are implemented as pointers, &lt;code&gt;++c.begin()&lt;/code&gt; does not compile, while &lt;code&gt;std::next(c.begin())&lt;/code&gt; does.</source>
          <target state="translated">Хотя выражение &lt;code&gt;++c.begin()&lt;/code&gt; часто компилируется, это не гарантируется: &lt;code&gt;c.begin()&lt;/code&gt; является выражением rvalue, и не &lt;a href=&quot;../named_req/bidirectionaliterator&quot;&gt;существует&lt;/a&gt; требования LegacyBidirectionalIterator, которое указывает, что приращение значения r будет гарантированно работать. В частности, когда итераторы реализованы в виде указателей, &lt;code&gt;++c.begin()&lt;/code&gt; не компилируется, а &lt;code&gt;std::next(c.begin())&lt;/code&gt; не компилируется .</target>
        </trans-unit>
        <trans-unit id="55ffdbc2010bd6fba5315668a01fc1d2cb4bf01d" translate="yes" xml:space="preserve">
          <source>Although the expression &lt;code&gt;--c.end()&lt;/code&gt; often compiles, it is not guaranteed to do so: &lt;code&gt;c.end()&lt;/code&gt; is an rvalue expression, and there is no iterator requirement that specifies that decrement of an rvalue is guaranteed to work. In particular, when iterators are implemented as pointers, &lt;code&gt;--c.end()&lt;/code&gt; does not compile, while &lt;code&gt;std::prev(c.end())&lt;/code&gt; does.</source>
          <target state="translated">Хотя выражение &lt;code&gt;--c.end()&lt;/code&gt; часто компилируется, это не гарантируется: &lt;code&gt;c.end()&lt;/code&gt; является выражением rvalue, и нет требования итератора, указывающего, что декремент значения r будет гарантированно работать. В частности, когда итераторы реализованы как указатели, &lt;code&gt;--c.end()&lt;/code&gt; не компилируется, а &lt;code&gt;std::prev(c.end())&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="562d3af0d04be2de0b30b637809f27a622e04faf" translate="yes" xml:space="preserve">
          <source>Although the header &lt;code&gt;&amp;lt;cerrno&amp;gt;&lt;/code&gt; is based on the C standard library header &lt;code&gt;errno.h&lt;/code&gt;, the majority of the macros defined by &lt;code&gt;&amp;lt;cerrno&amp;gt;&lt;/code&gt; were adopted by C++ from the POSIX standard, rather than the C standard library.</source>
          <target state="translated">Хотя заголовок &lt;code&gt;&amp;lt;cerrno&amp;gt;&lt;/code&gt; основан на заголовке стандартной библиотеки C &lt;code&gt;errno.h&lt;/code&gt; , большинство макросов, определенных в &lt;code&gt;&amp;lt;cerrno&amp;gt;&lt;/code&gt; , были приняты C ++ из стандарта POSIX, а не из стандартной библиотеки C.</target>
        </trans-unit>
        <trans-unit id="3db5014665fd46dd8e252214316aa47507ad7ef2" translate="yes" xml:space="preserve">
          <source>Although the names generated by &lt;code&gt;std::tmpnam&lt;/code&gt; are difficult to guess, it is possible that a file with that name is created by another process between the moment &lt;code&gt;std::tmpnam&lt;/code&gt; returns and the moment this program attempts to use the returned name to create a file. The standard function &lt;code&gt;&lt;a href=&quot;tmpfile&quot;&gt;std::tmpfile&lt;/a&gt;&lt;/code&gt; and the POSIX function &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/mkdtemp.html&quot;&gt;mkstemp&lt;/a&gt; do not have this problem (creating a unique directory using only the standard C library still requires the use of &lt;code&gt;tmpnam&lt;/code&gt;).</source>
          <target state="translated">Хотя имена, сгенерированные &lt;code&gt;std::tmpnam&lt;/code&gt; , трудно угадать, возможно, что файл с таким именем создается другим процессом между моментом, когда возвращается &lt;code&gt;std::tmpnam&lt;/code&gt; и моментом, когда эта программа пытается использовать возвращенное имя для создания файл. Стандартная функция &lt;code&gt;&lt;a href=&quot;tmpfile&quot;&gt;std::tmpfile&lt;/a&gt;&lt;/code&gt; и POSIX-функция &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/mkdtemp.html&quot;&gt;mkstemp&lt;/a&gt; не имеют этой проблемы (создание уникального каталога с использованием только стандартной библиотеки C по-прежнему требует использования &lt;code&gt;tmpnam&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="9d5994bfdfeb1041b6398f05b2f8f3e33b52a975" translate="yes" xml:space="preserve">
          <source>Although the names generated by &lt;code&gt;std::tmpnam&lt;/code&gt; are difficult to guess, it is possible that a file with that name is created by another process between the moment &lt;code&gt;std::tmpnam&lt;/code&gt; returns and the moment this program attempts to use the returned name to create a file. The standard function &lt;code&gt;&lt;a href=&quot;tmpfile&quot;&gt;std::tmpfile&lt;/a&gt;&lt;/code&gt; and the POSIX function &lt;a href=&quot;https://pubs.opengroup.org/onlinepubs/9699919799/functions/mkdtemp.html&quot;&gt;mkstemp&lt;/a&gt; do not have this problem (creating a unique directory using only the standard C library still requires the use of &lt;code&gt;tmpnam&lt;/code&gt;).</source>
          <target state="translated">Хотя имена, сгенерированные &lt;code&gt;std::tmpnam&lt;/code&gt; , трудно угадать, возможно, что файл с таким именем создается другим процессом между моментом возврата &lt;code&gt;std::tmpnam&lt;/code&gt; и моментом, когда эта программа пытается использовать возвращенное имя для создания файл. Стандартная функция &lt;code&gt;&lt;a href=&quot;tmpfile&quot;&gt;std::tmpfile&lt;/a&gt;&lt;/code&gt; и функция POSIX &lt;a href=&quot;https://pubs.opengroup.org/onlinepubs/9699919799/functions/mkdtemp.html&quot;&gt;mkstemp&lt;/a&gt; не имеют этой проблемы (создание уникального каталога с использованием только стандартной библиотеки C по-прежнему требует использования &lt;code&gt;tmpnam&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="c9f3db27755b0d585a653f2d5f3657aa1f21c81b" translate="yes" xml:space="preserve">
          <source>Although the results of comparing pointers of random origin (e.g. not all pointing to members of the same array) is unspecified, many implementations provide &lt;a href=&quot;https://en.wikipedia.org/wiki/Total_order#Strict_total_order&quot;&gt;strict total ordering&lt;/a&gt; of pointers, e.g. if they are implemented as addresses within continuous virtual address space. Those implementations that do not (e.g. where not all bits of the pointer are part of a memory address and have to be ignored for comparison, or an additional calculation is required or otherwise pointer and integer is not a 1 to 1 relationship), provide a specialization of &lt;code&gt;&lt;a href=&quot;../utility/functional/less&quot;&gt;std::less&lt;/a&gt;&lt;/code&gt; for pointers that has that guarantee. This makes it possible to use all pointers of random origin as keys in standard associative containers such as &lt;code&gt;&lt;a href=&quot;../container/set&quot;&gt;std::set&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../container/map&quot;&gt;std::map&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Хотя результаты сравнения указателей случайного происхождения (например, не все указывают на элементы одного и того же массива) не определены, многие реализации обеспечивают &lt;a href=&quot;https://en.wikipedia.org/wiki/Total_order#Strict_total_order&quot;&gt;строгое полное упорядочение&lt;/a&gt; указателей, например, если они реализованы как адреса в непрерывном виртуальном адресном пространстве. Те реализации, которые не (например, где не все биты указателя являются частью адреса памяти и должны игнорироваться для сравнения, или требуется дополнительное вычисление, или иначе указатель и целое число не являются отношением 1 к 1), обеспечивают специализация &lt;code&gt;&lt;a href=&quot;../utility/functional/less&quot;&gt;std::less&lt;/a&gt;&lt;/code&gt; для указателей с такой гарантией. Это позволяет использовать все указатели случайного происхождения в качестве ключей в стандартных ассоциативных контейнерах, таких как &lt;code&gt;&lt;a href=&quot;../container/set&quot;&gt;std::set&lt;/a&gt;&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;../container/map&quot;&gt;std::map&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a8a747e33a10c6fa21c941b73f1438fc704b6283" translate="yes" xml:space="preserve">
          <source>Although the return type is &lt;code&gt;char*&lt;/code&gt;, modifying the pointed-to characters is undefined behavior.</source>
          <target state="translated">Хотя тип возвращаемого значения - &lt;code&gt;char*&lt;/code&gt; , изменение указанных символов является неопределенным поведением.</target>
        </trans-unit>
        <trans-unit id="1a131648c16bdab1f4ad67b397e73af609dc5ab0" translate="yes" xml:space="preserve">
          <source>Although the return type is not allowed in the declaration of a user-defined conversion function, the decl-specifier-seq of &lt;a href=&quot;declarations#Specifiers&quot;&gt;the declaration grammar&lt;/a&gt; may be present and may include any specifier other than type-specifier or the keyword static, In particular, besides &lt;code&gt;explicit&lt;/code&gt;, the specifiers &lt;a href=&quot;inline&quot;&gt;inline&lt;/a&gt;, &lt;a href=&quot;virtual&quot;&gt;virtual&lt;/a&gt;, &lt;a href=&quot;constexpr&quot;&gt;constexpr&lt;/a&gt;, and &lt;a href=&quot;friend&quot;&gt;friend&lt;/a&gt; are also allowed (note that &lt;code&gt;friend&lt;/code&gt; requires a qualified name: &lt;code&gt;friend A::operator B();&lt;/code&gt;).</source>
          <target state="translated">Хотя возвращаемый тип не разрешен в объявлении пользовательской функции преобразования, может присутствовать decl-specier-seq &lt;a href=&quot;declarations#Specifiers&quot;&gt;грамматики объявления&lt;/a&gt; и может включать любой спецификатор, отличный от спецификатора типа или ключевого слова static. В частности, кроме &lt;code&gt;explicit&lt;/code&gt; также допускаются спецификаторы &lt;a href=&quot;inline&quot;&gt;inline&lt;/a&gt; , &lt;a href=&quot;virtual&quot;&gt;virtual&lt;/a&gt; , &lt;a href=&quot;constexpr&quot;&gt;constexpr&lt;/a&gt; и &lt;a href=&quot;friend&quot;&gt;friend&lt;/a&gt; (обратите внимание, что &lt;code&gt;friend&lt;/code&gt; требует квалифицированного имени: &lt;code&gt;friend A::operator B();&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="d77898594331af7d94d8805113c2ae7cc96df8a5" translate="yes" xml:space="preserve">
          <source>Although the standard requires that this facet works with UCS2 when the size of &lt;code&gt;Elem&lt;/code&gt; is 16 bits, some implementations use UTF-16 instead, making this a non-converting locale. The term &quot;UCS2&quot; was deprecated and removed from the Unicode standard.</source>
          <target state="translated">Хотя стандарт требует, чтобы этот аспект работал с UCS2, когда размер &lt;code&gt;Elem&lt;/code&gt; равен 16 битам, в некоторых реализациях вместо этого используется UTF-16, что делает его неконвертирующим языковым стандартом. Термин &amp;laquo;UCS2&amp;raquo; устарел и удален из стандарта Unicode.</target>
        </trans-unit>
        <trans-unit id="3eafdced96881df5338499ac356a8e8f50b8bc53" translate="yes" xml:space="preserve">
          <source>Although the standard requires that this facet works with UCS2 when the size of &lt;code&gt;Elem&lt;/code&gt; is 16 bits, some implementations use UTF-16 instead. The term &quot;UCS2&quot; was deprecated and removed from the Unicode standard.</source>
          <target state="translated">Хотя стандарт требует, чтобы этот аспект работал с UCS2, когда размер &lt;code&gt;Elem&lt;/code&gt; равен 16 битам, некоторые реализации используют вместо этого UTF-16. Термин &amp;laquo;UCS2&amp;raquo; устарел и удален из стандарта Unicode.</target>
        </trans-unit>
        <trans-unit id="a91bcce893b5de905ecbd22a99a03889cdcc2544" translate="yes" xml:space="preserve">
          <source>Always</source>
          <target state="translated">Always</target>
        </trans-unit>
        <trans-unit id="fe09758345685e241df672635cfac946bfc561d8" translate="yes" xml:space="preserve">
          <source>Always-throwing functions</source>
          <target state="translated">Всегда бросающие функции</target>
        </trans-unit>
        <trans-unit id="4df6b8083eb91bc6a923cb0c4bf5c1ae0e994985" translate="yes" xml:space="preserve">
          <source>Ambiguous and nonexistent local times can occur as a result of time zone transitions (such as daylight saving time). For example, &quot;2016-03-13 02:30:00&quot; does not exist in the &lt;code&gt;&quot;America/New_York&quot;&lt;/code&gt; time zone, while &quot;2016-11-06 01:30:00&quot; in that time zone can correspond to two UTC time points: 2016-11-06 05:30:00 UTC and 2016-11-06 06:30:00 UTC.</source>
          <target state="translated">Неоднозначные и несуществующие локальные времена могут возникать в результате переходов часовых поясов (таких как переход на летнее время). Например, &amp;laquo;2016-03-13 02:30:00&amp;raquo; не существует в часовом поясе &lt;code&gt;&quot;America/New_York&quot;&lt;/code&gt; , а &amp;laquo;2016-11-06 01:30:00&amp;raquo; в этом часовом поясе может соответствовать двум UTC моменты времени: 2016-11-06 05:30:00 UTC и 2016-11-06 06:30:00 UTC.</target>
        </trans-unit>
        <trans-unit id="c067979f83933e6c4d89a2c1e0fb562a0f280310" translate="yes" xml:space="preserve">
          <source>Ambiguous conversion sequences are ranked as user-defined conversion sequences because multiple conversion sequences for an argument can exist only if they involve different user-defined conversions:</source>
          <target state="translated">Неявные последовательности преобразования ранжируются как определяемые пользователем последовательности преобразования,потому что несколько последовательностей преобразования для аргумента могут существовать только в том случае,если они включают различные определяемые пользователем преобразования:</target>
        </trans-unit>
        <trans-unit id="5aa47b263945205f7df82cf554dee097502b0d78" translate="yes" xml:space="preserve">
          <source>Amortized constant number of invocations of &lt;code&gt;g.operator()&lt;/code&gt;.</source>
          <target state="translated">Амортизированное постоянное число вызовов &lt;code&gt;g.operator()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="128bb665ca4a35fff2ef43cce127f6f8f60033b5" translate="yes" xml:space="preserve">
          <source>Amortized constant number of invocations of &lt;code&gt;g&lt;/code&gt;</source>
          <target state="translated">Амортизированное постоянное число вызовов &lt;code&gt;g&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1cbb525f8d6525a8ab447903dfd14ddbdc0818e6" translate="yes" xml:space="preserve">
          <source>Amortized constant on average, worst case linear in the size of the container.</source>
          <target state="translated">Амортизированная константа в среднем,в наихудшем случае линейная в размерах контейнера.</target>
        </trans-unit>
        <trans-unit id="50471dc8ecc10f0a607efbdd965811e70e031a13" translate="yes" xml:space="preserve">
          <source>Amortized constant.</source>
          <target state="translated">Амортизированная константа.</target>
        </trans-unit>
        <trans-unit id="99690d58d4abd10cd0938a7adcb56ded08ef66ad" translate="yes" xml:space="preserve">
          <source>An</source>
          <target state="translated">An</target>
        </trans-unit>
        <trans-unit id="45ea68905c72735578b243d8c992010c73dd2b71" translate="yes" xml:space="preserve">
          <source>An 8-bit binary type can represent any two-digit decimal number exactly, but 3-digit decimal numbers 256..999 cannot be represented. The value of &lt;code&gt;digits10&lt;/code&gt; for an 8-bit type is 2 (&lt;code&gt;8 * &lt;a href=&quot;../../numeric/math/log10&quot;&gt;std::log10&lt;/a&gt;(2)&lt;/code&gt; is 2.41).</source>
          <target state="translated">8-разрядный двоичный тип может точно представлять любое двузначное десятичное число, но нельзя представить трехзначное десятичное число 256..999. Значение &lt;code&gt;digits10&lt;/code&gt; для 8-разрядного типа - 2 ( &lt;code&gt;8 * &lt;a href=&quot;../../numeric/math/log10&quot;&gt;std::log10&lt;/a&gt;(2)&lt;/code&gt; - 2,41).</target>
        </trans-unit>
        <trans-unit id="b70a29f58335fff2ae0f72bb6d64b3b5da9003ef" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;../language/type-id&quot;&gt;arithmetic type&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;../language/type-id&quot;&gt;Арифметический тип&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="807382b205cd61b4e07e059d92477e9e7b450d4d" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;../memory/new/operator_new&quot;&gt;allocation&lt;/a&gt; or deallocation function for a class is odr-used by a &lt;a href=&quot;new&quot;&gt;new expression&lt;/a&gt; appearing in a potentially-evaluated expression</source>
          <target state="translated">&lt;a href=&quot;../memory/new/operator_new&quot;&gt;Распределение&lt;/a&gt; функции или открепление для класса УСО-используемый &lt;a href=&quot;new&quot;&gt;новое выражение&lt;/a&gt; появляющегося в потенциально вычисляемого выражения</target>
        </trans-unit>
        <trans-unit id="8d5b39fd5f28e44fd4cbe7c1a6e4527324fdb198" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;asm&quot;&gt;asm declaration&lt;/a&gt; does not define any entities, but it is classified as a definition.</source>
          <target state="translated">Объявление &lt;a href=&quot;asm&quot;&gt;asm&lt;/a&gt; не определяет никаких сущностей, но классифицируется как определение.</target>
        </trans-unit>
        <trans-unit id="d3db36c93422d5b474b182b8149fdd0c74f76e94" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;attributes&quot;&gt;attribute&lt;/a&gt; sequence attr may appear just before the label (in which case it applies to the label), or just before any statement itself, in which case it applies to the entire statement. A statement may carry multiple labels. Labels (and only labels) have &lt;a href=&quot;scope#Function_scope&quot;&gt;function scope&lt;/a&gt;. Labels are ignored by &lt;a href=&quot;unqualified_lookup&quot;&gt;unqualified lookup&lt;/a&gt;: a label can have the same name as any other entity in the program.</source>
          <target state="translated">&lt;a href=&quot;attributes&quot;&gt;Атрибут&lt;/a&gt; может появиться последовательность атр непосредственно перед метким (в этом случае оно относится к этикетке), или непосредственно перед любым самим заявлением, в этом случае оно относится ко всему заявлению. Выписка может содержать несколько меток. Метки (и только метки) имеют &lt;a href=&quot;scope#Function_scope&quot;&gt;область действия&lt;/a&gt; . Метки игнорируются &lt;a href=&quot;unqualified_lookup&quot;&gt;неквалифицированным поиском&lt;/a&gt; : метка может иметь то же имя, что и любой другой объект в программе.</target>
        </trans-unit>
        <trans-unit id="67d8f4f0c409d53bf6fc239c4572103225de8737" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;class_template#Class_template_instantiation&quot;&gt;explicit instantiation declaration&lt;/a&gt; (an &quot;extern template&quot;)</source>
          <target state="translated">&lt;a href=&quot;class_template#Class_template_instantiation&quot;&gt;Явное объявление конкретизации&lt;/a&gt; ( &amp;laquo;ехЬегп шаблон&amp;raquo;)</target>
        </trans-unit>
        <trans-unit id="e8d07ab60f03237d43aaac774ff0a48905536383" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;declarations&quot;&gt;attribute declaration&lt;/a&gt; (does not define any entities)</source>
          <target state="translated">Объявление &lt;a href=&quot;declarations&quot;&gt;атрибута&lt;/a&gt; (не определяет никаких сущностей)</target>
        </trans-unit>
        <trans-unit id="8250bcb5d0e5dcdf0fb994dd06a03c09d7251e75" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;declarations&quot;&gt;empty declaration&lt;/a&gt; (does not define any entities)</source>
          <target state="translated">&lt;a href=&quot;declarations&quot;&gt;Пустая декларация&lt;/a&gt; (не определяет каких - либо лиц)</target>
        </trans-unit>
        <trans-unit id="1cae5b3ce33128b19eacc0658479be44746e7c43" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;enum&quot;&gt;opaque declaration&lt;/a&gt; of an enumeration</source>
          <target state="translated">&lt;a href=&quot;enum&quot;&gt;Непрозрачная декларация&lt;/a&gt; о перечислении</target>
        </trans-unit>
        <trans-unit id="97e3c29d16d88a0e096a7e69f7173bded9fa122e" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;iterator&quot;&gt;LegacyIterator&lt;/a&gt; whose category and types are the same as &lt;code&gt;X::const_iterator&lt;/code&gt;</source>
          <target state="translated">&lt;a href=&quot;iterator&quot;&gt;LegacyIterator&lt;/a&gt; чья категории и типы такие же , как &lt;code&gt;X::const_iterator&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="cf13631c6d364b349a268bbd81c204b7997b1947" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;iterator&quot;&gt;LegacyIterator&lt;/a&gt; whose category and types are the same as &lt;code&gt;X::iterator&lt;/code&gt;</source>
          <target state="translated">&lt;a href=&quot;iterator&quot;&gt;LegacyIterator&lt;/a&gt; чья категория и тип такие же , как &lt;code&gt;X::iterator&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c036f0c614197c69e50ff0747f60db77d1ca80a7" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;name&quot;&gt;identifier&lt;/a&gt; that names a non-type template parameter of class type &lt;code&gt;T&lt;/code&gt; denotes a static storage duration object of type &lt;code&gt;const T&lt;/code&gt;, called a</source>
          <target state="translated">&lt;a href=&quot;name&quot;&gt;Идентификатор&lt;/a&gt; , который имена параметр шаблона , не тип класс типа &lt;code&gt;T&lt;/code&gt; обозначает статическое хранение длительность объект типа &lt;code&gt;const T&lt;/code&gt; , называется</target>
        </trans-unit>
        <trans-unit id="c6fbfbd5514da52daf4588bb104a4a85d038970e" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;name#In_expressions&quot;&gt;identifier expression&lt;/a&gt; that denotes an immediate function may only appear within a subexpression of an immediate invocation or within an immediate function context. A pointer or reference to an immediate function can be taken but cannot escape constant expression evaluation:</source>
          <target state="translated">&lt;a href=&quot;name#In_expressions&quot;&gt;Выражение идентификатора&lt;/a&gt; , который обозначает непосредственную функцию может появиться только в пределах подвыражения немедленного вызова или в пределах контекста непосредственной функции. Можно взять указатель или ссылку на непосредственную функцию, но не может избежать вычисления константного выражения:</target>
        </trans-unit>
        <trans-unit id="4835e23540157d178506c76dbed3585b131cd6c2" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;template_specialization&quot;&gt;explicit specialization&lt;/a&gt; whose declaration is not a definition.</source>
          <target state="translated">&lt;a href=&quot;template_specialization&quot;&gt;Явная специализация&lt;/a&gt; которого декларация не является определением.</target>
        </trans-unit>
        <trans-unit id="0476037f5a01ed84f4c68efe6578d34ee836c695" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;type_alias&quot;&gt;alias-declaration&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;type_alias&quot;&gt;Псевдоним декларации&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ec273bcf1f66db0db9b6197343f94ba32b5eec31" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;value_category#lvalue&quot;&gt;lvalue&lt;/a&gt; of function type &lt;code&gt;T&lt;/code&gt; can be implicitly converted to a &lt;a href=&quot;value_category#prvalue&quot;&gt;prvalue&lt;/a&gt;&lt;a href=&quot;pointer#Pointers_to_functions&quot;&gt;pointer to that function&lt;/a&gt;. This does not apply to non-static member functions because lvalues that refer to non-static member functions do not exist.</source>
          <target state="translated">&lt;a href=&quot;value_category#lvalue&quot;&gt;- Значение&lt;/a&gt; типа функции &lt;code&gt;T&lt;/code&gt; может быть неявно преобразован в &lt;a href=&quot;value_category#prvalue&quot;&gt;prvalue &lt;/a&gt;&lt;a href=&quot;pointer#Pointers_to_functions&quot;&gt;указатель на эту функцию&lt;/a&gt; . Это не относится к нестатическим функциям-членам, поскольку l-значений, которые ссылаются на нестатические функции-члены, не существует.</target>
        </trans-unit>
        <trans-unit id="7ba6cc034ab70817b81a34ed74af74dd8855a970" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;value_category#lvalue&quot;&gt;lvalue&lt;/a&gt; or &lt;a href=&quot;value_category#rvalue&quot;&gt;rvalue&lt;/a&gt; of type &quot;array of &lt;code&gt;N&lt;/code&gt;&lt;code&gt;T&lt;/code&gt;&quot; or &quot;array of unknown bound of &lt;code&gt;T&lt;/code&gt;&quot; can be implicitly converted to a &lt;a href=&quot;value_category#prvalue&quot;&gt;prvalue&lt;/a&gt; of type &quot;pointer to &lt;code&gt;T&lt;/code&gt;&quot;. If the array is a prvalue, &lt;a href=&quot;implicit_cast#Temporary_materialization&quot;&gt;temporary materialization&lt;/a&gt; occurs.(since C++17) The resulting pointer refers to the first element of the array (see &lt;a href=&quot;array#Array-to-pointer_decay&quot;&gt;array to pointer decay&lt;/a&gt; for details).</source>
          <target state="translated">&lt;a href=&quot;value_category#lvalue&quot;&gt;Именующий&lt;/a&gt; или &lt;a href=&quot;value_category#rvalue&quot;&gt;Rvalue&lt;/a&gt; типа &amp;laquo;массив из &lt;code&gt;N&lt;/code&gt; &lt;code&gt;T&lt;/code&gt; &amp;raquo; или &amp;laquo;массив неизвестного граница &lt;code&gt;T&lt;/code&gt; &amp;raquo; может быть неявно преобразован в &lt;a href=&quot;value_category#prvalue&quot;&gt;prvalue&lt;/a&gt; типа &amp;laquo;указатель на &lt;code&gt;T&lt;/code&gt; &amp;raquo;. Если массив является prvalue, происходит &lt;a href=&quot;implicit_cast#Temporary_materialization&quot;&gt;временная материализация&lt;/a&gt; (начиная с C ++ 17). Результирующий указатель ссылается на первый элемент массива (подробности см. В &lt;a href=&quot;array#Array-to-pointer_decay&quot;&gt;массиве с указателем на затухание&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="3b75a307aa52c5825d1730c4cdd4f9a558685208" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;&lt;a href=&quot;../pair&quot;&gt;std::pair&lt;/a&gt;&lt;/code&gt; object containing the given values.</source>
          <target state="translated">Объект &lt;code&gt;&lt;a href=&quot;../pair&quot;&gt;std::pair&lt;/a&gt;&lt;/code&gt; содержащий заданные значения.</target>
        </trans-unit>
        <trans-unit id="d6c35561be6c0db7de52088fd8b63305b7a7d8f9" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;&lt;a href=&quot;../utility/pair&quot;&gt;std::pair&lt;/a&gt;&lt;/code&gt; holding a pointer to the beginning of the allocated storage and the number of objects that fit in the storage that was actually allocated.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../utility/pair&quot;&gt;std::pair&lt;/a&gt;&lt;/code&gt; держит указатель на начало выделенной памяти и количество объектов , которые соответствуют в хранилище , которое было фактически выделено.</target>
        </trans-unit>
        <trans-unit id="64c0acf093e82ca7c2d56259ef132c09f1d727d8" translate="yes" xml:space="preserve">
          <source>An &lt;strong&gt;AllocatorAwareContainer&lt;/strong&gt; is a &lt;a href=&quot;container&quot;&gt;Container&lt;/a&gt; that holds an instance of an &lt;a href=&quot;allocator&quot;&gt;Allocator&lt;/a&gt; and uses that instance in all its member functions to allocate and deallocate memory and to construct and destroy objects in that memory (such objects may be container elements, nodes, or, for unordered containers, bucket arrays).</source>
          <target state="translated">&lt;strong&gt;AllocatorAwareContainer&lt;/strong&gt; является &lt;a href=&quot;container&quot;&gt;контейнером&lt;/a&gt; , который содержит экземпляр &lt;a href=&quot;allocator&quot;&gt;Allocator&lt;/a&gt; и использует этот экземпляр во всех своих функциях членов по выделению и DEALLOCATE памяти и построить и уничтожать объекты в этой памяти (такие объекты могут быть элементами контейнера, узлы, или, для неупорядоченных контейнеров , ведро массивы).</target>
        </trans-unit>
        <trans-unit id="eaa15e16e5ec0c95afc353328fbb4fb678121869" translate="yes" xml:space="preserve">
          <source>An &lt;strong&gt;AssociativeContainer&lt;/strong&gt; is an ordered &lt;a href=&quot;container&quot;&gt;Container&lt;/a&gt; that provides fast lookup of objects based on keys.</source>
          <target state="translated">&lt;strong&gt;AssociativeContainer&lt;/strong&gt; представляет собой упорядоченный &lt;a href=&quot;container&quot;&gt;контейнер&lt;/a&gt; , который обеспечивает быстрый поиск объектов на основе ключей.</target>
        </trans-unit>
        <trans-unit id="b5c5d4aca5ec3c0868d0e700b371604b1ec448c3" translate="yes" xml:space="preserve">
          <source>An &lt;strong&gt;LegacyInputIterator&lt;/strong&gt; is an &lt;a href=&quot;iterator&quot;&gt;LegacyIterator&lt;/a&gt; that can read from the pointed-to element. LegacyInputIterators only guarantee validity for single pass algorithms: once an LegacyInputIterator &lt;code&gt;i&lt;/code&gt; has been incremented, all copies of its previous value may be invalidated.</source>
          <target state="translated">&lt;strong&gt;LegacyInputIterator&lt;/strong&gt; является &lt;a href=&quot;iterator&quot;&gt;LegacyIterator&lt;/a&gt; , который может читать из заостренного к элементу. LegacyInputIterators гарантируют действительность только для однопроходных алгоритмов: после увеличения LegacyInputIterator &lt;code&gt;i&lt;/code&gt; все копии его предыдущего значения могут быть признаны недействительными.</target>
        </trans-unit>
        <trans-unit id="a021125aae1a0c5f6666fbd70ad3091d5eaf4be5" translate="yes" xml:space="preserve">
          <source>An UnformattedInputFunction is a stream input function that performs the following:</source>
          <target state="translated">Неформатированная функция входа (UnformattedInputFunction)-это функция входа потока,которая выполняет следующие действия:</target>
        </trans-unit>
        <trans-unit id="ce56470376a6a1e9f7a374ada94b689a0ac77bd6" translate="yes" xml:space="preserve">
          <source>An abstract class is a class that either defines or inherits at least one function for which &lt;a href=&quot;virtual&quot;&gt;the final overrider&lt;/a&gt; is pure virtual.</source>
          <target state="translated">Абстрактный класс - это класс, который определяет или наследует хотя бы одну функцию, для которой &lt;a href=&quot;virtual&quot;&gt;конечный переопределитель&lt;/a&gt; является чисто виртуальным.</target>
        </trans-unit>
        <trans-unit id="908b2d8b11e075496d08f7d7d4b01d8354d7a3e1" translate="yes" xml:space="preserve">
          <source>An additional class template &lt;code&gt;auto_ptr_ref&lt;/code&gt; is referred to throughout the documentation. It is an implementation-defined type that holds a reference to &lt;code&gt;auto_ptr&lt;/code&gt;. The implementation is allowed to provide the template with a different name or implement the functions returning it or accepting it as parameter in other ways.</source>
          <target state="translated">Дополнительный шаблон класса &lt;code&gt;auto_ptr_ref&lt;/code&gt; упоминается в документации. Это определенный реализацией тип, который содержит ссылку на &lt;code&gt;auto_ptr&lt;/code&gt; . Реализация может предоставить шаблону другое имя или реализовать функции, возвращающие его или принимающие его в качестве параметра другими способами.</target>
        </trans-unit>
        <trans-unit id="492bf377c49f20efce1a6cebadb795c9f43e068d" translate="yes" xml:space="preserve">
          <source>An additional rule is applied to the deduction in this case: when comparing function parameters &lt;code&gt;P&lt;/code&gt;i and &lt;code&gt;A&lt;/code&gt;i, if any &lt;code&gt;P&lt;/code&gt;i is an rvalue reference to cv-unqualified template parameter (a &quot;forwarding reference&quot;) and the corresponding &lt;code&gt;A&lt;/code&gt;i is an lvalue reference, then &lt;code&gt;P&lt;/code&gt;i is adjusted to the template parameter type (T&amp;amp;&amp;amp; becomes T).</source>
          <target state="translated">В этом случае к вычету применяется дополнительное правило: при сравнении параметров функции &lt;code&gt;P&lt;/code&gt; i и &lt;code&gt;A&lt;/code&gt; i, если какой-либо &lt;code&gt;P&lt;/code&gt; i является ссылочной ссылкой на значение cv-неквалифицированного параметра шаблона (&amp;laquo;ссылка на пересылку&amp;raquo;), а соответствующий &lt;code&gt;A&lt;/code&gt; i является lvalue reference, тогда &lt;code&gt;P&lt;/code&gt; i настраивается на тип параметра шаблона (T &amp;amp;&amp;amp; становится T).</target>
        </trans-unit>
        <trans-unit id="39f1e2f1f4a1f2712c275be633629814179e5046" translate="yes" xml:space="preserve">
          <source>An aggregate class or array may include non-aggregate public bases(since C++17), members, or elements, which are initialized as described above (e.g. copy-initialization from the corresponding initializer clause).</source>
          <target state="translated">Совокупный класс или массив может включать неагрегированные публичные базы (начиная с C++17),члены или элементы,которые инициализируются,как описано выше (например,копирование-инициализация из соответствующего пункта инициализатора).</target>
        </trans-unit>
        <trans-unit id="b197d6cc29c7895c847275964c7060dca3357d57" translate="yes" xml:space="preserve">
          <source>An aggregate is one of the following types:</source>
          <target state="translated">Агрегат является одним из следующих типов:</target>
        </trans-unit>
        <trans-unit id="12db35057383aa0593fc91fb24bea2072f9fc5b7" translate="yes" xml:space="preserve">
          <source>An algorithm to &quot;clamp&quot; a value between a pair of boundary values (&lt;code&gt;&lt;a href=&quot;algorithm/clamp&quot;&gt;std::clamp&lt;/a&gt;&lt;/code&gt;)</source>
          <target state="translated">Алгоритм &amp;laquo;зажима&amp;raquo; значения между парой граничных значений ( &lt;code&gt;&lt;a href=&quot;algorithm/clamp&quot;&gt;std::clamp&lt;/a&gt;&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="6a4c8075a51ee48f2fc8e9678f381d4c2cc5cd9e" translate="yes" xml:space="preserve">
          <source>An allocator that is used to acquire/release memory and to construct/destroy the elements in that memory. The type must meet the requirements of &lt;a href=&quot;../named_req/allocator&quot;&gt;Allocator&lt;/a&gt;. The behavior is undefined if &lt;code&gt;Allocator::value_type&lt;/code&gt; is not the same as &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">Распределитель, который используется для получения / освобождения памяти и для создания / уничтожения элементов в этой памяти. Тип должен соответствовать требованиям &lt;a href=&quot;../named_req/allocator&quot;&gt;Allocator&lt;/a&gt; . Поведение не определено , если &lt;code&gt;Allocator::value_type&lt;/code&gt; не то же самое , как &lt;code&gt;T&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2b7e6c1744a360683380fca88796315c08727ff6" translate="yes" xml:space="preserve">
          <source>An allocator type &lt;code&gt;X&lt;/code&gt; for type &lt;code&gt;T&lt;/code&gt; additionally satisfies the</source>
          <target state="translated">Тип распределителя &lt;code&gt;X&lt;/code&gt; для типа &lt;code&gt;T&lt;/code&gt; дополнительно удовлетворяет</target>
        </trans-unit>
        <trans-unit id="8d97370574b17753b94ede73aa5e362da9eb3aac" translate="yes" xml:space="preserve">
          <source>An arithmetic type or a class emulating an arithmetic type</source>
          <target state="translated">Арифметический тип или класс,эмулирующий арифметический тип.</target>
        </trans-unit>
        <trans-unit id="c52cf5a897774b32a3cc4643437d36a5b1792813" translate="yes" xml:space="preserve">
          <source>An array can also be used as a tuple of &lt;code&gt;N&lt;/code&gt; elements of the same type.</source>
          <target state="translated">Массив также можно использовать в качестве кортежа из &lt;code&gt;N&lt;/code&gt; элементов одного типа.</target>
        </trans-unit>
        <trans-unit id="5ac3648865a50f77bee68245b1bc8d2b8af79b49" translate="yes" xml:space="preserve">
          <source>An array declaration is any simple declaration whose &lt;a href=&quot;declarations&quot;&gt;declarator&lt;/a&gt; has the form.</source>
          <target state="translated">Объявление массива - это любое простое объявление, у которого &lt;a href=&quot;declarations&quot;&gt;объявитель&lt;/a&gt; имеет форму.</target>
        </trans-unit>
        <trans-unit id="f97a7d14a3134d2ce52774abf33446e4a447d088" translate="yes" xml:space="preserve">
          <source>An assignment operator in a class &lt;code&gt;T&lt;/code&gt; that is a member or base of another class &lt;code&gt;U&lt;/code&gt; is odr-used by an implicitly-defined copy-assignment or move-assignment functions of &lt;code&gt;U&lt;/code&gt;.</source>
          <target state="translated">Оператор присваивания в классе &lt;code&gt;T&lt;/code&gt; , который является членом или базой другого класса &lt;code&gt;U&lt;/code&gt; является ODR-используется неявно определенное копирование назначения или переместить-присваивание функций &lt;code&gt;U&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2bc87d164b8e7f6ecde4c668667f3c0239908e17" translate="yes" xml:space="preserve">
          <source>An associative container &lt;code&gt;X&lt;/code&gt; that is either &lt;code&gt;std::map&lt;/code&gt; and &lt;code&gt;std::multimap&lt;/code&gt; additionally supports the expression X::mapped_type, which has a return type of T, with the requirement that &lt;code&gt;T&lt;/code&gt; be &lt;a href=&quot;destructible&quot;&gt;Destructible&lt;/a&gt;, and compile time complexity.</source>
          <target state="translated">Ассоциативный контейнер &lt;code&gt;X&lt;/code&gt; , который является либо &lt;code&gt;std::map&lt;/code&gt; и &lt;code&gt;std::multimap&lt;/code&gt; дополнительно поддерживает выражение X :: mapped_type, который имеет тип возврата Т, с требованием, чтобы &lt;code&gt;T&lt;/code&gt; быть &lt;a href=&quot;destructible&quot;&gt;Разрушаемые&lt;/a&gt; и сложности компиляции времени.</target>
        </trans-unit>
        <trans-unit id="864fa04b4ed98eae74afcfaa9ef56bb780bc69ce" translate="yes" xml:space="preserve">
          <source>An asynchronous operation (created via &lt;code&gt;&lt;a href=&quot;async&quot;&gt;std::async&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;packaged_task&quot;&gt;std::packaged_task&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;promise&quot;&gt;std::promise&lt;/a&gt;&lt;/code&gt;) can provide a &lt;code&gt;std::future&lt;/code&gt; object to the creator of that asynchronous operation.</source>
          <target state="translated">Асинхронная операция (создается с помощью &lt;code&gt;&lt;a href=&quot;async&quot;&gt;std::async&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;packaged_task&quot;&gt;std::packaged_task&lt;/a&gt;&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;promise&quot;&gt;std::promise&lt;/a&gt;&lt;/code&gt; ) может предоставить объект &lt;code&gt;std::future&lt;/code&gt; создателю этой асинхронной операции.</target>
        </trans-unit>
        <trans-unit id="9e8f8230bc284edbfa18713cf06662ed31c603fb" translate="yes" xml:space="preserve">
          <source>An atomic &lt;a href=&quot;memory_order&quot;&gt;release operation&lt;/a&gt; X in thread A synchronizes-with an acquire fence F in thread B, if.</source>
          <target state="translated">Атомный &lt;a href=&quot;memory_order&quot;&gt;Операция освобождения&lt;/a&gt; X в потоке A синхронизируется с ограничителем получения F в потоке B, если.</target>
        </trans-unit>
        <trans-unit id="928fdce82eda51be195710313098b2223ec96c39" translate="yes" xml:space="preserve">
          <source>An atomic constraint consists of an expression &lt;code&gt;E&lt;/code&gt; and a mapping from the template parameters that appear within &lt;code&gt;E&lt;/code&gt; to template arguments involving the template parameters of the constrained entity, called its</source>
          <target state="translated">Атомное ограничение состоит из выражения &lt;code&gt;E&lt;/code&gt; и сопоставления параметров шаблона, отображаемых в &lt;code&gt;E&lt;/code&gt; , с параметрами шаблона, включающими параметры шаблона ограниченного объекта, называемого его</target>
        </trans-unit>
        <trans-unit id="5a79829f8c7b85fe4e4638dfbea954acbd0eda02" translate="yes" xml:space="preserve">
          <source>An atomic operation A on some atomic object M is</source>
          <target state="translated">Атомная операция A на каком-то атомном объекте M-это</target>
        </trans-unit>
        <trans-unit id="5a5310902368573c36e555b627b994b235e68248" translate="yes" xml:space="preserve">
          <source>An attribute can be used almost everywhere in the C++ program, and can be applied to almost everything: to types, to variables, to functions, to names, to code blocks, to entire translation units, although each particular attribute is only valid where it is permitted by the implementation: &lt;code&gt;[[expect_true]]&lt;/code&gt; could be an attribute that can only be used with an &lt;code&gt;if&lt;/code&gt;, and not with a class declaration. &lt;code&gt;[[omp::parallel()]]&lt;/code&gt; could be an attribute that applies to a code block or to a &lt;code&gt;for&lt;/code&gt; loop, but not to the type &lt;code&gt;int&lt;/code&gt;, etc. (note these two attributes are fictional examples, see below for the standard and some non-standard attributes).</source>
          <target state="translated">Атрибут может использоваться почти везде в программе на C ++ и может применяться практически ко всему: к типам, переменным, функциям, именам, блокам кода, целым единицам перевода, хотя каждый конкретный атрибут действителен только там, где он разрешено реализацией: &lt;code&gt;[[expect_true]]&lt;/code&gt; может быть атрибутом, который может использоваться только с &lt;code&gt;if&lt;/code&gt; , но не с объявлением класса. &lt;code&gt;[[omp::parallel()]]&lt;/code&gt; может быть атрибутом, который применяется к блоку кода или для &lt;code&gt;for&lt;/code&gt; циклу , но не к типу &lt;code&gt;int&lt;/code&gt; и т. д. (обратите внимание, что эти два атрибута являются вымышленными примерами, см. ниже стандарт и некоторые нестандартные атрибуты).</target>
        </trans-unit>
        <trans-unit id="3b30276e5eb22d8f2d82beaa0982183267864ede" translate="yes" xml:space="preserve">
          <source>An ellipsis &lt;code&gt;...&lt;/code&gt; may appear at the end of the parameter list; this declares a &lt;a href=&quot;variadic_arguments&quot;&gt;variadic function&lt;/a&gt;:</source>
          <target state="translated">Многоточие &lt;code&gt;...&lt;/code&gt; может появиться в конце списка параметров; это объявляет&lt;a href=&quot;variadic_arguments&quot;&gt; переменную функцию&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="7b28c53044424dbd671a0a292fff9b11ed2f240c" translate="yes" xml:space="preserve">
          <source>An empty path can be obtained by calling &lt;a href=&quot;clear&quot;&gt;&lt;code&gt;clear&lt;/code&gt;&lt;/a&gt; and by default-constructing a &lt;code&gt;path&lt;/code&gt;. It can also be returned by a path decomposition function (such as &lt;a href=&quot;extension&quot;&gt;&lt;code&gt;extension&lt;/code&gt;&lt;/a&gt;) if the corresponding component is not present in the path.</source>
          <target state="translated">Пустой путь можно получить, вызвав &lt;a href=&quot;clear&quot;&gt; &lt;code&gt;clear&lt;/code&gt; &lt;/a&gt; и по умолчанию создавая &lt;code&gt;path&lt;/code&gt; . Он также может быть возвращен функцией разложения пути (например, &lt;a href=&quot;extension&quot;&gt; &lt;code&gt;extension&lt;/code&gt; &lt;/a&gt; ), если соответствующий компонент отсутствует в пути.</target>
        </trans-unit>
        <trans-unit id="2ecc5a9f5ce0682a542e5d3a7d4ffa7f954c9836" translate="yes" xml:space="preserve">
          <source>An empty path is classified as a relative path.</source>
          <target state="translated">Пустой путь классифицируется как относительный.</target>
        </trans-unit>
        <trans-unit id="96c80c138bff7aa336c0c80903e065616c06546c" translate="yes" xml:space="preserve">
          <source>An empty range is lexicographically</source>
          <target state="translated">Пустой диапазон лексикографически</target>
        </trans-unit>
        <trans-unit id="c5d73f72c6721b75502428576903171289a2fc14" translate="yes" xml:space="preserve">
          <source>An empty shared_ptr (where &lt;code&gt;use_count() == 0&lt;/code&gt;) may store a non-null pointer accessible by &lt;code&gt;get()&lt;/code&gt;, e.g. if it were created using the aliasing constructor.</source>
          <target state="translated">Пустой shared_ptr (где &lt;code&gt;use_count() == 0&lt;/code&gt; ) может хранить ненулевой указатель, доступный для &lt;code&gt;get()&lt;/code&gt; , например, если он был создан с использованием конструктора псевдонимов.</target>
        </trans-unit>
        <trans-unit id="bf3e0e6688aa2181023a253a9e87db009478a78e" translate="yes" xml:space="preserve">
          <source>An empty string if the character sequence is not a valid collating element</source>
          <target state="translated">Пустая строка,если последовательность символов не является допустимым элементом коллекции</target>
        </trans-unit>
        <trans-unit id="3d82664471aad182109ca58741b1d45d1271d6cf" translate="yes" xml:space="preserve">
          <source>An enumeration is defined by</source>
          <target state="translated">Перечень определяется</target>
        </trans-unit>
        <trans-unit id="afe5baa45aa238529a9d9f5521326fb55bc4227f" translate="yes" xml:space="preserve">
          <source>An equivalent effect may be achieved with the facilities provided by &lt;code&gt;&lt;a href=&quot;promise&quot;&gt;std::promise&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;packaged_task&quot;&gt;std::packaged_task&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Эквивалентный эффект может быть достигнут с помощью средств, предоставляемых &lt;code&gt;&lt;a href=&quot;promise&quot;&gt;std::promise&lt;/a&gt;&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;packaged_task&quot;&gt;std::packaged_task&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="26b27f109fdc73d104fb47c91bb0233ff5e7c5ad" translate="yes" xml:space="preserve">
          <source>An example of a custom operator&amp;lt;=&amp;gt; that returns &lt;a href=&quot;../utility/compare/strong_ordering&quot;&gt;&lt;code&gt;std::strong_ordering&lt;/code&gt;&lt;/a&gt; is an operator that compares every member of a class, except in order that is different from the default (here: last name first).</source>
          <target state="translated">Примером пользовательского оператора &amp;lt;=&amp;gt;, который возвращает &lt;a href=&quot;../utility/compare/strong_ordering&quot;&gt; &lt;code&gt;std::strong_ordering&lt;/code&gt; &lt;/a&gt; является оператор, который сравнивает каждый член класса, за исключением того, что он отличается от значения по умолчанию (здесь: фамилия первая).</target>
        </trans-unit>
        <trans-unit id="e794383d64707bd6aee1a7ffa3033ac34c3317b6" translate="yes" xml:space="preserve">
          <source>An example of a custom operator&amp;lt;=&amp;gt; that returns &lt;a href=&quot;../utility/compare/weak_ordering&quot;&gt;&lt;code&gt;std::weak_ordering&lt;/code&gt;&lt;/a&gt; is an operator that compares string members of a class in case-insensitive manner: this is different from the default comparison (so a custom operator is required) and it's possible to distinguish two strings that compare equal under this comparison.</source>
          <target state="translated">Примером пользовательского оператора &amp;lt;=&amp;gt;, который возвращает &lt;a href=&quot;../utility/compare/weak_ordering&quot;&gt; &lt;code&gt;std::weak_ordering&lt;/code&gt; &lt;/a&gt; является оператор, который сравнивает строковые члены класса без учета регистра: это отличается от сравнения по умолчанию (поэтому требуется пользовательский оператор), и возможно различать две строки, которые сравниваются равными при этом сравнении.</target>
        </trans-unit>
        <trans-unit id="bc3fdebc617a723576859b7b78597b5a6e61e62e" translate="yes" xml:space="preserve">
          <source>An example of a type that implements LegacyOutputIterator is &lt;a href=&quot;../iterator/ostream_iterator&quot;&gt;std::ostream_iterator&lt;/a&gt;.</source>
          <target state="translated">Примером типа, который реализует LegacyOutputIterator, является &lt;a href=&quot;../iterator/ostream_iterator&quot;&gt;std :: ostream_iterator&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="831c258222c425472a6e48db4facf3170a3cef28" translate="yes" xml:space="preserve">
          <source>An example of an inheritance hierarchy with virtual base classes is the iostreams hierarchy of the standard library: &lt;code&gt;&lt;a href=&quot;../io/basic_istream&quot;&gt;std::istream&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../io/basic_ostream&quot;&gt;std::ostream&lt;/a&gt;&lt;/code&gt; are derived from &lt;code&gt;&lt;a href=&quot;../io/basic_ios&quot;&gt;std::ios&lt;/a&gt;&lt;/code&gt; using virtual inheritance. &lt;code&gt;&lt;a href=&quot;../io/basic_iostream&quot;&gt;std::iostream&lt;/a&gt;&lt;/code&gt; is derived from both &lt;code&gt;&lt;a href=&quot;../io/basic_istream&quot;&gt;std::istream&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../io/basic_ostream&quot;&gt;std::ostream&lt;/a&gt;&lt;/code&gt;, so every instance of &lt;code&gt;&lt;a href=&quot;../io/basic_iostream&quot;&gt;std::iostream&lt;/a&gt;&lt;/code&gt; contains a &lt;code&gt;&lt;a href=&quot;../io/basic_ostream&quot;&gt;std::ostream&lt;/a&gt;&lt;/code&gt; subobject, a &lt;code&gt;&lt;a href=&quot;../io/basic_istream&quot;&gt;std::istream&lt;/a&gt;&lt;/code&gt; subobject, and just one &lt;code&gt;&lt;a href=&quot;../io/basic_ios&quot;&gt;std::ios&lt;/a&gt;&lt;/code&gt; subobject (and, consequently, one &lt;code&gt;&lt;a href=&quot;../io/ios_base&quot;&gt;std::ios_base&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">Примером иерархии наследования с виртуальными базовыми классами является иерархия iostreams стандартной библиотеки: &lt;code&gt;&lt;a href=&quot;../io/basic_istream&quot;&gt;std::istream&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;../io/basic_ostream&quot;&gt;std::ostream&lt;/a&gt;&lt;/code&gt; получены из &lt;code&gt;&lt;a href=&quot;../io/basic_ios&quot;&gt;std::ios&lt;/a&gt;&lt;/code&gt; с использованием виртуального наследования. &lt;code&gt;&lt;a href=&quot;../io/basic_iostream&quot;&gt;std::iostream&lt;/a&gt;&lt;/code&gt; является производным от обоих &lt;code&gt;&lt;a href=&quot;../io/basic_istream&quot;&gt;std::istream&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;../io/basic_ostream&quot;&gt;std::ostream&lt;/a&gt;&lt;/code&gt; , так что каждый экземпляр &lt;code&gt;&lt;a href=&quot;../io/basic_iostream&quot;&gt;std::iostream&lt;/a&gt;&lt;/code&gt; содержит &lt;code&gt;&lt;a href=&quot;../io/basic_ostream&quot;&gt;std::ostream&lt;/a&gt;&lt;/code&gt; субобъектом, A &lt;code&gt;&lt;a href=&quot;../io/basic_istream&quot;&gt;std::istream&lt;/a&gt;&lt;/code&gt; подобъектов, и только один &lt;code&gt;&lt;a href=&quot;../io/basic_ios&quot;&gt;std::ios&lt;/a&gt;&lt;/code&gt; подобъектом ( и, следовательно, один &lt;code&gt;&lt;a href=&quot;../io/ios_base&quot;&gt;std::ios_base&lt;/a&gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="41464d61485a2aac603dadcdf39c0ce3781751e5" translate="yes" xml:space="preserve">
          <source>An example of when such declaration is used is the implementation of &lt;code&gt;&lt;a href=&quot;../types/is_function&quot;&gt;std::is_function&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Примером использования такого объявления является реализация функции &lt;code&gt;&lt;a href=&quot;../types/is_function&quot;&gt;std::is_function&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bdba113faa387d1ab71c87afef4ec469f4cc925c" translate="yes" xml:space="preserve">
          <source>An example where int-returning &lt;code&gt;uncaught_exceptions&lt;/code&gt; is used is the &lt;a href=&quot;http://www.boost.org/doc/libs/release/libs/log/doc/html/index.html&quot;&gt;boost.log&lt;/a&gt; library: the expression &lt;code&gt;BOOST_LOG(logger) &amp;lt;&amp;lt; foo();&lt;/code&gt; first creates a guard object and records the number of uncaught exceptions in its constructor. The output is performed by the guard object's destructor unless foo() throws (in which case the number of uncaught exceptions in the destructor is greater than what the constructor observed).</source>
          <target state="translated">Пример , в котором INT-возвращение &lt;code&gt;uncaught_exceptions&lt;/code&gt; используется является &lt;a href=&quot;http://www.boost.org/doc/libs/release/libs/log/doc/html/index.html&quot;&gt;boost.log&lt;/a&gt; библиотека: выражение &lt;code&gt;BOOST_LOG(logger) &amp;lt;&amp;lt; foo();&lt;/code&gt; сначала создает объект защиты и записывает количество необработанных исключений в его конструкторе. Вывод выполняется деструктором объекта защиты, если только foo () не сгенерирует (в этом случае число необработанных исключений в деструкторе больше, чем наблюдал конструктор).</target>
        </trans-unit>
        <trans-unit id="3c376fdb08a2c546d5e0e5f8f44feb92df5bc392" translate="yes" xml:space="preserve">
          <source>An example where int-returning &lt;code&gt;uncaught_exceptions&lt;/code&gt; is used is the &lt;a href=&quot;https://www.boost.org/doc/libs/release/libs/log/doc/html/index.html&quot;&gt;boost.log&lt;/a&gt; library: the expression &lt;code&gt;BOOST_LOG(logger) &amp;lt;&amp;lt; foo();&lt;/code&gt; first creates a guard object and records the number of uncaught exceptions in its constructor. The output is performed by the guard object's destructor unless foo() throws (in which case the number of uncaught exceptions in the destructor is greater than what the constructor observed).</source>
          <target state="translated">Пример , в котором INT-возвращение &lt;code&gt;uncaught_exceptions&lt;/code&gt; используется является &lt;a href=&quot;https://www.boost.org/doc/libs/release/libs/log/doc/html/index.html&quot;&gt;boost.log&lt;/a&gt; библиотека: выражение &lt;code&gt;BOOST_LOG(logger) &amp;lt;&amp;lt; foo();&lt;/code&gt; сначала создает объект защиты и записывает количество неперехваченных исключений в его конструкторе. Вывод выполняется деструктором охранного объекта, если только foo () не выбрасывает (в этом случае количество неперехваченных исключений в деструкторе больше, чем то, что наблюдал конструктор).</target>
        </trans-unit>
        <trans-unit id="2b085b3ecbb54c70910e25f3896da20b2a187a73" translate="yes" xml:space="preserve">
          <source>An exception can be thrown by a &lt;a href=&quot;throw&quot;&gt;throw-expression&lt;/a&gt;, &lt;a href=&quot;dynamic_cast&quot;&gt;dynamic_cast&lt;/a&gt;, &lt;a href=&quot;typeid&quot;&gt;typeid&lt;/a&gt;, &lt;a href=&quot;new&quot;&gt;new-expression&lt;/a&gt;, &lt;a href=&quot;../memory/new/operator_new&quot;&gt;allocation function&lt;/a&gt;, and any of the standard library functions that are specified to throw exceptions to signal certain error conditions (e.g. &lt;code&gt;&lt;a href=&quot;../container/vector/at&quot;&gt;std::vector::at&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../string/basic_string/substr&quot;&gt;std::string::substr&lt;/a&gt;&lt;/code&gt;, etc).</source>
          <target state="translated">Исключение может быть &lt;a href=&quot;throw&quot;&gt;сгенерировано&lt;/a&gt; с помощью throw-выражения , &lt;a href=&quot;dynamic_cast&quot;&gt;dynamic_cast&lt;/a&gt; , &lt;a href=&quot;typeid&quot;&gt;typeid&lt;/a&gt; , &lt;a href=&quot;new&quot;&gt;new-expression&lt;/a&gt; , &lt;a href=&quot;../memory/new/operator_new&quot;&gt;функции размещения&lt;/a&gt; и любой из стандартных библиотечных функций, которые указаны для выброса исключений для сигнализации определенных условий ошибки (например, &lt;code&gt;&lt;a href=&quot;../container/vector/at&quot;&gt;std::vector::at&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../string/basic_string/substr&quot;&gt;std::string::substr&lt;/a&gt;&lt;/code&gt; и т. д.).</target>
        </trans-unit>
        <trans-unit id="734db5e27654b7a1a090879aa79155ed3b4b2a8b" translate="yes" xml:space="preserve">
          <source>An exception is thrown if &lt;code&gt;*this&lt;/code&gt; has no shared state or &lt;code&gt;get_future&lt;/code&gt; has already been called. To get multiple &quot;pop&quot; ends of the promise-future communication channel, use &lt;code&gt;&lt;a href=&quot;../future/share&quot;&gt;std::future::share&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Исключение &lt;code&gt;get_future&lt;/code&gt; если &lt;code&gt;*this&lt;/code&gt; не имеет общего состояния или get_future уже был вызван. Чтобы получить несколько &amp;laquo;попсовых&amp;raquo; концов канала обещания-будущего, используйте &lt;code&gt;&lt;a href=&quot;../future/share&quot;&gt;std::future::share&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="44db7b4c1aff9b2986166f1068a5b7109c799860" translate="yes" xml:space="preserve">
          <source>An exception is thrown if there is no shared state or the shared state already stores a value or exception.</source>
          <target state="translated">Исключение выбрасывается,если нет общего состояния или если общее состояние уже хранит значение или исключение.</target>
        </trans-unit>
        <trans-unit id="400934141b26ebdcfa01b232809e28da4e1614d3" translate="yes" xml:space="preserve">
          <source>An exception of this type is thrown when a &lt;a href=&quot;../language/dynamic_cast&quot;&gt;&lt;code&gt;dynamic_cast&lt;/code&gt;&lt;/a&gt; to a reference type fails the run-time check (e.g. because the types are not related by inheritance), and also from &lt;code&gt;&lt;a href=&quot;../locale/use_facet&quot;&gt;std::use_facet&lt;/a&gt;&lt;/code&gt; if the requested facet does not exist in the locale.</source>
          <target state="translated">Исключение этого типа генерируется, когда &lt;a href=&quot;../language/dynamic_cast&quot;&gt; &lt;code&gt;dynamic_cast&lt;/code&gt; &lt;/a&gt; для ссылочного типа не проходит проверку во время выполнения (например, потому что типы не связаны наследованием), а также из &lt;code&gt;&lt;a href=&quot;../locale/use_facet&quot;&gt;std::use_facet&lt;/a&gt;&lt;/code&gt; если запрошенный фасет не существует в локали.</target>
        </trans-unit>
        <trans-unit id="3e10eeb3d50b8941ecde1bf2d5b08ad5eba672d1" translate="yes" xml:space="preserve">
          <source>An exception of this type is thrown when a &lt;a href=&quot;../language/typeid&quot;&gt;&lt;code&gt;typeid&lt;/code&gt;&lt;/a&gt; operator is applied to a dereferenced null pointer value of a polymorphic type.</source>
          <target state="translated">Исключение этого типа &lt;a href=&quot;../language/typeid&quot;&gt; &lt;code&gt;typeid&lt;/code&gt; &lt;/a&gt; когда оператор typeid применяется к значению разыменованного нулевого указателя полиморфного типа.</target>
        </trans-unit>
        <trans-unit id="392a7913172c4bf28f4342b2ce3e240403f2f75f" translate="yes" xml:space="preserve">
          <source>An explanatory message for the stored error code and error category.</source>
          <target state="translated">Пояснительное сообщение для сохраненного кода ошибки и категории ошибки.</target>
        </trans-unit>
        <trans-unit id="d5eabc2515cac7175770538d9fd2aca675f84744" translate="yes" xml:space="preserve">
          <source>An explicit instantiation declaration (an extern template) prevents implicit instantiations: the code that would otherwise cause an implicit instantiation has to use the explicit instantiation definition provided somewhere else in the program.</source>
          <target state="translated">Явное объявление инстанцирования (шаблон экстерна)предотвращает неявные инстанцирования:код,который в противном случае вызвал бы неявное инстанцирование,должен использовать явное определение инстанцирования,предоставленное где-нибудь в другом месте программы.</target>
        </trans-unit>
        <trans-unit id="33cd7a0177e9f7ec5c231dde735e35e1a0d3fb00" translate="yes" xml:space="preserve">
          <source>An explicit instantiation declaration (an extern template) skips implicit instantiation step: the code that would otherwise cause an implicit instantiation instead uses the explicit instantiation definition provided elsewhere (resulting in link errors if no such instantiation exists). This can be used to reduce compilation times by explicitly declaring a template instantiation in all but one of the source files using it, and explicitly defining it in the remaining file.</source>
          <target state="translated">Явное объявление инстанцирования (внешний шаблон)пропускает шаг неявной инстанцинации:код,который в противном случае привел бы к неявной инстанцинации,вместо этого использует явное определение инстанцинации,предоставленное в другом месте (что приводит к ошибкам связи,если такой инстанцинации не существует).Это может быть использовано для сокращения времени компиляции,явно объявляя инстанцирование шаблона во всех исходных файлах,кроме одного,использующего его,и явно определяя его в оставшемся файле.</target>
        </trans-unit>
        <trans-unit id="133c2fb50577da662edeff998e62d6b70b901935" translate="yes" xml:space="preserve">
          <source>An explicit instantiation definition forces instantiation of the class, struct, or union they refer to. It may appear in the program anywhere after the template definition, and for a given argument-list, is only allowed to appear once in the entire program.</source>
          <target state="translated">Явное определение конкретизации заставляет конкретизировать класс,структуру или объединение,на которое они ссылаются.Оно может появиться в программе где угодно после определения шаблона,а для заданного списка аргументов-только один раз во всей программе.</target>
        </trans-unit>
        <trans-unit id="c3fb00f7b63425b442d1cc0c31f1edb4322117c1" translate="yes" xml:space="preserve">
          <source>An explicit instantiation definition forces instantiation of the function or member function they refer to. It may appear in the program anywhere after the template definition, and for a given argument-list, is only allowed to appear once in the program.</source>
          <target state="translated">Прямое определение конкретизации заставляет конкретизировать функцию или функцию члена,на которую они ссылаются.Оно может появиться в программе где угодно после определения шаблона,а для заданного списка аргументов-только один раз в программе.</target>
        </trans-unit>
        <trans-unit id="c9c128e72c9b832e8384315ba572027dc359efd3" translate="yes" xml:space="preserve">
          <source>An explicit specialization cannot be a &lt;a href=&quot;friend&quot;&gt;friend declaration&lt;/a&gt;.</source>
          <target state="translated">Явная специализация не может быть &lt;a href=&quot;friend&quot;&gt;декларацией друга&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5a4ebeb793310cf18619b24eeafbc2e6fd5d0c1f" translate="yes" xml:space="preserve">
          <source>An explicit specialization of a function template is inline only if it is declared with the &lt;a href=&quot;inline&quot;&gt;inline specifier&lt;/a&gt; (or defined as deleted), it doesn't matter if the primary template is inline.</source>
          <target state="translated">Явная специализация шаблона функции является встроенной, только если она объявлена ​​с помощью &lt;a href=&quot;inline&quot;&gt;встроенного спецификатора&lt;/a&gt; (или определена как удаленная), не имеет значения, является ли основной шаблон встроенным.</target>
        </trans-unit>
        <trans-unit id="ad7859780f7fda205f962953901c88030d43e65f" translate="yes" xml:space="preserve">
          <source>An explicit specialization of a static data member of a template is a definition if the declaration includes an initializer; otherwise, it is a declaration. These definitions must use braces for default initialization:</source>
          <target state="translated">Явной специализацией статического члена шаблона данных является определение,если в декларацию включен инициализатор,в противном случае-декларация.Эти определения должны использовать фигурные скобки для инициализации по умолчанию:</target>
        </trans-unit>
        <trans-unit id="f5646484a04d1f69f62bdf5309c5a9d249438cc5" translate="yes" xml:space="preserve">
          <source>An expression &lt;code&gt;e&lt;/code&gt; is</source>
          <target state="translated">Выражение &lt;code&gt;e&lt;/code&gt; есть</target>
        </trans-unit>
        <trans-unit id="11f8c98f192821781cccabf62455469b73d17864" translate="yes" xml:space="preserve">
          <source>An expression &lt;code&gt;e&lt;/code&gt; is said to be</source>
          <target state="translated">Выражение &lt;code&gt;e&lt;/code&gt; называется</target>
        </trans-unit>
        <trans-unit id="34f74cee143d788f51fcc25acc797aea92c197b8" translate="yes" xml:space="preserve">
          <source>An expression followed by a semicolon is a statement.</source>
          <target state="translated">Выражение,за которым следует точка с запятой,является заявлением.</target>
        </trans-unit>
        <trans-unit id="f703e5af31c537ec73c27f6089a222ac20a91c8b" translate="yes" xml:space="preserve">
          <source>An expression is</source>
          <target state="translated">Выражение заключается в том,что</target>
        </trans-unit>
        <trans-unit id="c5756e59953f27f7802c2879dfb5bf8b2ef537aa" translate="yes" xml:space="preserve">
          <source>An expression is a sequence of</source>
          <target state="translated">Выражение представляет собой последовательность</target>
        </trans-unit>
        <trans-unit id="8582e3c88de4617441467faab5ff600afdf1bfb6" translate="yes" xml:space="preserve">
          <source>An expression statement without an expression is called a</source>
          <target state="translated">Выражение без выражения называется</target>
        </trans-unit>
        <trans-unit id="ba931ef941c10e68e24584826bf3e7b5e908486f" translate="yes" xml:space="preserve">
          <source>An expression that designates a &lt;a href=&quot;bit_field&quot;&gt;bit field&lt;/a&gt; (e.g. &lt;code&gt;a.m&lt;/code&gt;, where &lt;code&gt;a&lt;/code&gt; is an lvalue of type &lt;code&gt;struct A { int m: 3; }&lt;/code&gt;) is an lvalue expression: it may be used as the left-hand operand of the assignment operator, but its address cannot be taken and a non-const lvalue reference cannot be bound to it. A const lvalue reference can be initialized from a bit-field lvalue, but a temporary copy of the bit-field will be made: it won't bind to the bit field directly.</source>
          <target state="translated">Выражение, которое обозначает &lt;a href=&quot;bit_field&quot;&gt;битовое поле&lt;/a&gt; (например, &lt;code&gt;a.m&lt;/code&gt; , где &lt;code&gt;a&lt;/code&gt; - это lvalue типа &lt;code&gt;struct A { int m: 3; }&lt;/code&gt; ) - это выражение lvalue: оно может использоваться в качестве левого операнда оператора присваивания, но его адрес не может быть взят, и к нему не может быть привязана неконстантная ссылка на значение. Ссылка константного lvalue может быть инициализирована из lvalue битового поля, но будет сделана временная копия битового поля: она не будет привязана к битовому полю напрямую.</target>
        </trans-unit>
        <trans-unit id="95fcc97496d0a23551b56ed465f2ec32a136ce51" translate="yes" xml:space="preserve">
          <source>An identifier can be used &lt;a href=&quot;declarations&quot;&gt;to name&lt;/a&gt; objects, references, functions, enumerators, types, class members, namespaces, templates, template specializations, parameter packs, goto labels, and other entities, with the following exceptions:</source>
          <target state="translated">Идентификатор может использоваться &lt;a href=&quot;declarations&quot;&gt;для именования&lt;/a&gt; объектов, ссылок, функций, перечислителей, типов, членов класса, пространств имен, шаблонов, специализаций шаблонов, пакетов параметров, меток перехода и других объектов, за следующими исключениями:</target>
        </trans-unit>
        <trans-unit id="f6eb1c54d1e440abd120bdddffed4feee0d07b20" translate="yes" xml:space="preserve">
          <source>An identifier that names a variable, a function, specialization of a &lt;a href=&quot;constraints&quot;&gt;concept&lt;/a&gt;,(since C++20) or an enumerator can be used as an &lt;a href=&quot;expressions&quot;&gt;expression&lt;/a&gt;. The result of an expression consisting of just the identifier is the entity named by the identifier. The &lt;a href=&quot;value_category&quot;&gt;value category&lt;/a&gt; of the expression is</source>
          <target state="translated">В качестве &lt;a href=&quot;expressions&quot;&gt;выражения&lt;/a&gt; можно использовать идентификатор, который называет переменную, функцию, специализацию &lt;a href=&quot;constraints&quot;&gt;концепции&lt;/a&gt; (начиная с C ++ 20) или перечислитель . Результатом выражения, состоящего только из идентификатора, является объект, названный идентификатором. &lt;a href=&quot;value_category&quot;&gt;Значение категории&lt;/a&gt; из выражения</target>
        </trans-unit>
        <trans-unit id="2bea22f245aad6a1bbd96dbe721e6bfbb9cba55e" translate="yes" xml:space="preserve">
          <source>An immediate function is a constexpr function, and must satisfy the requirements applicable to &lt;a href=&quot;constexpr&quot;&gt;constexpr functions or constexpr constructors&lt;/a&gt;, as the case may be.</source>
          <target state="translated">Непосредственная функция является функцией constexpr и должна удовлетворять требованиям, применимым к &lt;a href=&quot;constexpr&quot;&gt;функциям constexpr или конструкторам constexpr&lt;/a&gt; , в зависимости от обстоятельств.</target>
        </trans-unit>
        <trans-unit id="252a155693a85c4513362e41870c607628599139" translate="yes" xml:space="preserve">
          <source>An implementation cannot declare additional non-static data members that would occupy storage disjoint from the real and imaginary components, and must ensure that the class template specialization does not contain any padding. The implementation must also ensure that optimizations to array access account for the possibility that a pointer to &lt;code&gt;value_type&lt;/code&gt; may be aliasing a &lt;code&gt;std::complex&lt;/code&gt; specialization or array thereof.</source>
          <target state="translated">Реализация не может объявлять дополнительные нестатические члены-данные, которые занимают хранилище, не связанные с действительными и мнимыми компонентами, и должны гарантировать, что специализация шаблона класса не содержит никаких дополнений. Реализация также должна гарантировать, что оптимизации для доступа к массиву учитывают возможность того, что указатель на &lt;code&gt;value_type&lt;/code&gt; может иметь псевдоним специализации &lt;code&gt;std::complex&lt;/code&gt; или ее массива.</target>
        </trans-unit>
        <trans-unit id="b36215737bc9acc94a1181b9b9fc0edbe7c6e8eb" translate="yes" xml:space="preserve">
          <source>An implementation of &lt;code&gt;operator&amp;gt;&amp;gt;&lt;/code&gt; for a user-defined type.</source>
          <target state="translated">Реализация &lt;code&gt;operator&amp;gt;&amp;gt;&lt;/code&gt; для пользовательского типа.</target>
        </trans-unit>
        <trans-unit id="5f56c2af44fa6aea68d66ab4f981e253c1870786" translate="yes" xml:space="preserve">
          <source>An implementation of &lt;code&gt;operator&amp;lt;&amp;lt;&lt;/code&gt; for a user-defined type.</source>
          <target state="translated">Реализация &lt;code&gt;operator&amp;lt;&amp;lt;&lt;/code&gt; для пользовательского типа.</target>
        </trans-unit>
        <trans-unit id="8e1b5b99aec49dc279b82a189df1e4e71765f759" translate="yes" xml:space="preserve">
          <source>An implementation of the spherical harmonic function is &lt;a href=&quot;http://www.boost.org/doc/libs/1_62_0/libs/math/doc/html/math_toolkit/sf_poly/sph_harm.html&quot;&gt;available in boost.math&lt;/a&gt;, and it reduces to this function when called with the parameter phi set to zero.</source>
          <target state="translated">Реализация функции сферической гармоники &lt;a href=&quot;http://www.boost.org/doc/libs/1_62_0/libs/math/doc/html/math_toolkit/sf_poly/sph_harm.html&quot;&gt;доступна в boost.math&lt;/a&gt; , и она сводится к этой функции при вызове с параметром phi, установленным в ноль.</target>
        </trans-unit>
        <trans-unit id="6ef6f4ff8cf4b3091eca3ca55f5f34c2dba25629" translate="yes" xml:space="preserve">
          <source>An implementation of the spherical harmonic function is &lt;a href=&quot;https://www.boost.org/doc/libs/1_62_0/libs/math/doc/html/math_toolkit/sf_poly/sph_harm.html&quot;&gt;available in boost.math&lt;/a&gt;, and it reduces to this function when called with the parameter phi set to zero.</source>
          <target state="translated">Реализация функции сферической гармоники &lt;a href=&quot;https://www.boost.org/doc/libs/1_62_0/libs/math/doc/html/math_toolkit/sf_poly/sph_harm.html&quot;&gt;доступна в boost.math&lt;/a&gt; , и она сводится к этой функции при вызове с параметром phi, установленным на ноль.</target>
        </trans-unit>
        <trans-unit id="05f3d51d05cc3d2c938b7773b2a75528f0f533a8" translate="yes" xml:space="preserve">
          <source>An implementation of this function is also &lt;a href=&quot;http://www.boost.org/doc/libs/1_60_0/libs/math/doc/html/math_toolkit/ellint/ellint_1.html&quot;&gt;available in boost.math&lt;/a&gt;.</source>
          <target state="translated">Реализация этой функции также &lt;a href=&quot;http://www.boost.org/doc/libs/1_60_0/libs/math/doc/html/math_toolkit/ellint/ellint_1.html&quot;&gt;доступна в boost.math&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e8a80dd8b49b57fd0af28cb5b6f9eab92b003670" translate="yes" xml:space="preserve">
          <source>An implementation of this function is also &lt;a href=&quot;http://www.boost.org/doc/libs/1_60_0/libs/math/doc/html/math_toolkit/ellint/ellint_2.html&quot;&gt;available in boost.math&lt;/a&gt;.</source>
          <target state="translated">Реализация этой функции также &lt;a href=&quot;http://www.boost.org/doc/libs/1_60_0/libs/math/doc/html/math_toolkit/ellint/ellint_2.html&quot;&gt;доступна в boost.math&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="463a45be898237901d9e95795630e24b7725815f" translate="yes" xml:space="preserve">
          <source>An implementation of this function is also &lt;a href=&quot;http://www.boost.org/doc/libs/1_60_0/libs/math/doc/html/math_toolkit/ellint/ellint_3.html&quot;&gt;available in boost.math&lt;/a&gt;.</source>
          <target state="translated">Реализация этой функции также &lt;a href=&quot;http://www.boost.org/doc/libs/1_60_0/libs/math/doc/html/math_toolkit/ellint/ellint_3.html&quot;&gt;доступна в boost.math&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a328d339a02fcd8f09757618757e341adcf6caf4" translate="yes" xml:space="preserve">
          <source>An implementation of this function is also &lt;a href=&quot;http://www.boost.org/doc/libs/1_60_0/libs/math/doc/html/math_toolkit/zetas/zeta.html&quot;&gt;available in boost.math&lt;/a&gt;.</source>
          <target state="translated">Реализация этой функции также &lt;a href=&quot;http://www.boost.org/doc/libs/1_60_0/libs/math/doc/html/math_toolkit/zetas/zeta.html&quot;&gt;доступна в boost.math&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="05afb78eee87d60d6affed2bb5d378e94152fda4" translate="yes" xml:space="preserve">
          <source>An implementation of this function is also &lt;a href=&quot;http://www.boost.org/doc/libs/1_62_0/libs/math/doc/html/math_toolkit/bessel/bessel_first.html&quot;&gt;available in boost.math&lt;/a&gt;.</source>
          <target state="translated">Реализация этой функции также &lt;a href=&quot;http://www.boost.org/doc/libs/1_62_0/libs/math/doc/html/math_toolkit/bessel/bessel_first.html&quot;&gt;доступна в boost.math&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="14e04477fae2c219d4ca4910e671ec277e96650f" translate="yes" xml:space="preserve">
          <source>An implementation of this function is also &lt;a href=&quot;http://www.boost.org/doc/libs/1_62_0/libs/math/doc/html/math_toolkit/bessel/mbessel.html&quot;&gt;available in boost.math&lt;/a&gt;.</source>
          <target state="translated">Реализация этой функции также &lt;a href=&quot;http://www.boost.org/doc/libs/1_62_0/libs/math/doc/html/math_toolkit/bessel/mbessel.html&quot;&gt;доступна в boost.math&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="23aab2406e44d22254e76892b9bb67f949035f8f" translate="yes" xml:space="preserve">
          <source>An implementation of this function is also &lt;a href=&quot;http://www.boost.org/doc/libs/1_62_0/libs/math/doc/html/math_toolkit/bessel/sph_bessel.html&quot;&gt;available in boost.math&lt;/a&gt;.</source>
          <target state="translated">Реализация этой функции также &lt;a href=&quot;http://www.boost.org/doc/libs/1_62_0/libs/math/doc/html/math_toolkit/bessel/sph_bessel.html&quot;&gt;доступна в boost.math&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6d6d6fb65c08ea8df15db6341e3a63d4c3b1cb08" translate="yes" xml:space="preserve">
          <source>An implementation of this function is also &lt;a href=&quot;http://www.boost.org/doc/libs/release/libs/math/doc/html/math_toolkit/ellint/ellint_2.html&quot;&gt;available in boost.math&lt;/a&gt;.</source>
          <target state="translated">Реализация этой функции также &lt;a href=&quot;http://www.boost.org/doc/libs/release/libs/math/doc/html/math_toolkit/ellint/ellint_2.html&quot;&gt;доступна в boost.math&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a8f1f0a1677f6760e20f47ca31a1260d73446bbf" translate="yes" xml:space="preserve">
          <source>An implementation of this function is also &lt;a href=&quot;http://www.boost.org/doc/libs/release/libs/math/doc/html/math_toolkit/ellint/ellint_3.html&quot;&gt;available in boost.math&lt;/a&gt;.</source>
          <target state="translated">Реализация этой функции также &lt;a href=&quot;http://www.boost.org/doc/libs/release/libs/math/doc/html/math_toolkit/ellint/ellint_3.html&quot;&gt;доступна в boost.math&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="172a3359b3bc94067fe1ce4e3994c6fccab63962" translate="yes" xml:space="preserve">
          <source>An implementation of this function is also &lt;a href=&quot;http://www.boost.org/doc/libs/release/libs/math/doc/html/math_toolkit/expint/expint_i.html&quot;&gt;available in boost.math&lt;/a&gt;.</source>
          <target state="translated">Реализация этой функции также &lt;a href=&quot;http://www.boost.org/doc/libs/release/libs/math/doc/html/math_toolkit/expint/expint_i.html&quot;&gt;доступна в boost.math&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c3f9ea786832c07ac6ee8f2a1cf1bab37d07067f" translate="yes" xml:space="preserve">
          <source>An implementation of this function is also &lt;a href=&quot;http://www.boost.org/doc/libs/release/libs/math/doc/html/math_toolkit/sf_beta/beta_function.html&quot;&gt;available in boost.math&lt;/a&gt;.</source>
          <target state="translated">Реализация этой функции также &lt;a href=&quot;http://www.boost.org/doc/libs/release/libs/math/doc/html/math_toolkit/sf_beta/beta_function.html&quot;&gt;доступна в boost.math&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="023d43dc101a8f0e0055a1bbe7ca05f32647f8f2" translate="yes" xml:space="preserve">
          <source>An implementation of this function is also &lt;a href=&quot;http://www.boost.org/doc/libs/release/libs/math/doc/html/math_toolkit/sf_poly/hermite.html&quot;&gt;available in boost.math&lt;/a&gt;.</source>
          <target state="translated">Реализация этой функции также &lt;a href=&quot;http://www.boost.org/doc/libs/release/libs/math/doc/html/math_toolkit/sf_poly/hermite.html&quot;&gt;доступна в boost.math&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1416c6c581d2a16bec76ecd9c479fdd72d0c8646" translate="yes" xml:space="preserve">
          <source>An implementation of this function is also &lt;a href=&quot;http://www.boost.org/doc/libs/release/libs/math/doc/html/math_toolkit/sf_poly/laguerre.html&quot;&gt;available in boost.math&lt;/a&gt;.</source>
          <target state="translated">Реализация этой функции также &lt;a href=&quot;http://www.boost.org/doc/libs/release/libs/math/doc/html/math_toolkit/sf_poly/laguerre.html&quot;&gt;доступна в boost.math&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b7a97e935596f5c5ad772a94c524a08ecf79d480" translate="yes" xml:space="preserve">
          <source>An implementation of this function is also &lt;a href=&quot;http://www.boost.org/doc/libs/release/libs/math/doc/html/math_toolkit/sf_poly/legendre.html&quot;&gt;available in boost.math&lt;/a&gt; as &lt;code&gt;boost::math::legendre_p&lt;/code&gt;, except that the boost.math definition includes the Condon-Shortley phase term.</source>
          <target state="translated">Реализация этой функции также &lt;a href=&quot;http://www.boost.org/doc/libs/release/libs/math/doc/html/math_toolkit/sf_poly/legendre.html&quot;&gt;доступна в boost.math&lt;/a&gt; как &lt;code&gt;boost::math::legendre_p&lt;/code&gt; , за исключением того, что определение boost.math включает фазовый термин Кондона-Шотли.</target>
        </trans-unit>
        <trans-unit id="1b94dc33e3c2677817a24c87c5ae3eefdf3888b7" translate="yes" xml:space="preserve">
          <source>An implementation of this function is also &lt;a href=&quot;http://www.boost.org/doc/libs/release/libs/math/doc/html/math_toolkit/sf_poly/legendre.html&quot;&gt;available in boost.math&lt;/a&gt;.</source>
          <target state="translated">Реализация этой функции также &lt;a href=&quot;http://www.boost.org/doc/libs/release/libs/math/doc/html/math_toolkit/sf_poly/legendre.html&quot;&gt;доступна в boost.math&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a4376b52a3b698d01342890c645e63be771774af" translate="yes" xml:space="preserve">
          <source>An implementation of this function is also &lt;a href=&quot;https://www.boost.org/doc/libs/1_60_0/libs/math/doc/html/math_toolkit/ellint/ellint_1.html&quot;&gt;available in boost.math&lt;/a&gt;.</source>
          <target state="translated">Реализация этой функции также &lt;a href=&quot;https://www.boost.org/doc/libs/1_60_0/libs/math/doc/html/math_toolkit/ellint/ellint_1.html&quot;&gt;доступна в boost.math&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b60467ab6c0631a5664cf0494d5a0ca49e6e52f1" translate="yes" xml:space="preserve">
          <source>An implementation of this function is also &lt;a href=&quot;https://www.boost.org/doc/libs/1_60_0/libs/math/doc/html/math_toolkit/ellint/ellint_2.html&quot;&gt;available in boost.math&lt;/a&gt;.</source>
          <target state="translated">Реализация этой функции также &lt;a href=&quot;https://www.boost.org/doc/libs/1_60_0/libs/math/doc/html/math_toolkit/ellint/ellint_2.html&quot;&gt;доступна в boost.math&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="52edf4f2bf1751043ad31c41a6c11b35f270bfcb" translate="yes" xml:space="preserve">
          <source>An implementation of this function is also &lt;a href=&quot;https://www.boost.org/doc/libs/1_60_0/libs/math/doc/html/math_toolkit/ellint/ellint_3.html&quot;&gt;available in boost.math&lt;/a&gt;.</source>
          <target state="translated">Реализация этой функции также &lt;a href=&quot;https://www.boost.org/doc/libs/1_60_0/libs/math/doc/html/math_toolkit/ellint/ellint_3.html&quot;&gt;доступна в boost.math&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5a7b5eda0bb25aa403ce524620df1896aebc5bcd" translate="yes" xml:space="preserve">
          <source>An implementation of this function is also &lt;a href=&quot;https://www.boost.org/doc/libs/1_60_0/libs/math/doc/html/math_toolkit/zetas/zeta.html&quot;&gt;available in boost.math&lt;/a&gt;.</source>
          <target state="translated">Реализация этой функции также &lt;a href=&quot;https://www.boost.org/doc/libs/1_60_0/libs/math/doc/html/math_toolkit/zetas/zeta.html&quot;&gt;доступна в boost.math&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5aeeb2ecef2e098cd110869669dbedfb641d1e82" translate="yes" xml:space="preserve">
          <source>An implementation of this function is also &lt;a href=&quot;https://www.boost.org/doc/libs/1_62_0/libs/math/doc/html/math_toolkit/bessel/bessel_first.html&quot;&gt;available in boost.math&lt;/a&gt;.</source>
          <target state="translated">Реализация этой функции также &lt;a href=&quot;https://www.boost.org/doc/libs/1_62_0/libs/math/doc/html/math_toolkit/bessel/bessel_first.html&quot;&gt;доступна в boost.math&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b4bbb817d2363546432c72ec47562034e62b930c" translate="yes" xml:space="preserve">
          <source>An implementation of this function is also &lt;a href=&quot;https://www.boost.org/doc/libs/1_62_0/libs/math/doc/html/math_toolkit/bessel/mbessel.html&quot;&gt;available in boost.math&lt;/a&gt;.</source>
          <target state="translated">Реализация этой функции также &lt;a href=&quot;https://www.boost.org/doc/libs/1_62_0/libs/math/doc/html/math_toolkit/bessel/mbessel.html&quot;&gt;доступна в boost.math&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f5bcaa2e77d6da4f3fa4ce84e311bb065df9b7be" translate="yes" xml:space="preserve">
          <source>An implementation of this function is also &lt;a href=&quot;https://www.boost.org/doc/libs/1_62_0/libs/math/doc/html/math_toolkit/bessel/sph_bessel.html&quot;&gt;available in boost.math&lt;/a&gt;.</source>
          <target state="translated">Реализация этой функции также &lt;a href=&quot;https://www.boost.org/doc/libs/1_62_0/libs/math/doc/html/math_toolkit/bessel/sph_bessel.html&quot;&gt;доступна в boost.math&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="583558c1ff06b0561d4406d21632ee55c2b6f356" translate="yes" xml:space="preserve">
          <source>An implementation of this function is also &lt;a href=&quot;https://www.boost.org/doc/libs/release/libs/math/doc/html/math_toolkit/ellint/ellint_2.html&quot;&gt;available in boost.math&lt;/a&gt;.</source>
          <target state="translated">Реализация этой функции также &lt;a href=&quot;https://www.boost.org/doc/libs/release/libs/math/doc/html/math_toolkit/ellint/ellint_2.html&quot;&gt;доступна в boost.math&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2c47a9490a77b892440d4dd4af49e877b2a9df1a" translate="yes" xml:space="preserve">
          <source>An implementation of this function is also &lt;a href=&quot;https://www.boost.org/doc/libs/release/libs/math/doc/html/math_toolkit/ellint/ellint_3.html&quot;&gt;available in boost.math&lt;/a&gt;.</source>
          <target state="translated">Реализация этой функции также &lt;a href=&quot;https://www.boost.org/doc/libs/release/libs/math/doc/html/math_toolkit/ellint/ellint_3.html&quot;&gt;доступна в boost.math&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="659dcb29046fa05710b38a8fb1931ec898ae5519" translate="yes" xml:space="preserve">
          <source>An implementation of this function is also &lt;a href=&quot;https://www.boost.org/doc/libs/release/libs/math/doc/html/math_toolkit/expint/expint_i.html&quot;&gt;available in boost.math&lt;/a&gt;.</source>
          <target state="translated">Реализация этой функции также &lt;a href=&quot;https://www.boost.org/doc/libs/release/libs/math/doc/html/math_toolkit/expint/expint_i.html&quot;&gt;доступна в boost.math&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="bf8d66df175707d6c72a60a41c20ae8c99e0d86e" translate="yes" xml:space="preserve">
          <source>An implementation of this function is also &lt;a href=&quot;https://www.boost.org/doc/libs/release/libs/math/doc/html/math_toolkit/sf_beta/beta_function.html&quot;&gt;available in boost.math&lt;/a&gt;.</source>
          <target state="translated">Реализация этой функции также &lt;a href=&quot;https://www.boost.org/doc/libs/release/libs/math/doc/html/math_toolkit/sf_beta/beta_function.html&quot;&gt;доступна в boost.math&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="39da4171238400ac3f8feb8e52e5f753d1bd1fb7" translate="yes" xml:space="preserve">
          <source>An implementation of this function is also &lt;a href=&quot;https://www.boost.org/doc/libs/release/libs/math/doc/html/math_toolkit/sf_poly/hermite.html&quot;&gt;available in boost.math&lt;/a&gt;.</source>
          <target state="translated">Реализация этой функции также &lt;a href=&quot;https://www.boost.org/doc/libs/release/libs/math/doc/html/math_toolkit/sf_poly/hermite.html&quot;&gt;доступна в boost.math&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="dbdbc8151f3002ecfb8833c5c5c3125beb8e1447" translate="yes" xml:space="preserve">
          <source>An implementation of this function is also &lt;a href=&quot;https://www.boost.org/doc/libs/release/libs/math/doc/html/math_toolkit/sf_poly/laguerre.html&quot;&gt;available in boost.math&lt;/a&gt;.</source>
          <target state="translated">Реализация этой функции также &lt;a href=&quot;https://www.boost.org/doc/libs/release/libs/math/doc/html/math_toolkit/sf_poly/laguerre.html&quot;&gt;доступна в boost.math&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4e14b6f00e0b4e1eb1ae3b23159f9339d5a211c3" translate="yes" xml:space="preserve">
          <source>An implementation of this function is also &lt;a href=&quot;https://www.boost.org/doc/libs/release/libs/math/doc/html/math_toolkit/sf_poly/legendre.html&quot;&gt;available in boost.math&lt;/a&gt; as &lt;code&gt;boost::math::legendre_p&lt;/code&gt;, except that the boost.math definition includes the Condon-Shortley phase term.</source>
          <target state="translated">Реализация этой функции также &lt;a href=&quot;https://www.boost.org/doc/libs/release/libs/math/doc/html/math_toolkit/sf_poly/legendre.html&quot;&gt;доступна в boost.math&lt;/a&gt; как &lt;code&gt;boost::math::legendre_p&lt;/code&gt; , за исключением того, что определение boost.math включает фазовый член Кондона-Шортли.</target>
        </trans-unit>
        <trans-unit id="dde4c238b03e2f7efad8438d5c040e7628566cfd" translate="yes" xml:space="preserve">
          <source>An implementation of this function is also &lt;a href=&quot;https://www.boost.org/doc/libs/release/libs/math/doc/html/math_toolkit/sf_poly/legendre.html&quot;&gt;available in boost.math&lt;/a&gt;.</source>
          <target state="translated">Реализация этой функции также &lt;a href=&quot;https://www.boost.org/doc/libs/release/libs/math/doc/html/math_toolkit/sf_poly/legendre.html&quot;&gt;доступна в boost.math&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6484905546dbda0376c3234e4af32b4774ac948c" translate="yes" xml:space="preserve">
          <source>An incompletely-defined object type can be completed:</source>
          <target state="translated">Недоопределенный тип объекта может быть завершен:</target>
        </trans-unit>
        <trans-unit id="034496cba173d751719f86a31427ebfaf5a3c429" translate="yes" xml:space="preserve">
          <source>An inline namespace is a namespace that uses the optional keyword &lt;code&gt;inline&lt;/code&gt; in its</source>
          <target state="translated">Встроенное пространство имен - это пространство имен, которое использует необязательное ключевое слово &lt;code&gt;inline&lt;/code&gt; в своем</target>
        </trans-unit>
        <trans-unit id="14113ff7972f0e79ae2bcb3f11df635a03888186" translate="yes" xml:space="preserve">
          <source>An instance of &lt;code&gt;&lt;a href=&quot;exception_ptr&quot;&gt;std::exception_ptr&lt;/a&gt;&lt;/code&gt; holding a reference to the copy of &lt;code&gt;e&lt;/code&gt;, or to an instance of &lt;code&gt;&lt;a href=&quot;../memory/new/bad_alloc&quot;&gt;std::bad_alloc&lt;/a&gt;&lt;/code&gt; or to an instance of &lt;code&gt;&lt;a href=&quot;bad_exception&quot;&gt;std::bad_exception&lt;/a&gt;&lt;/code&gt; (see &lt;code&gt;&lt;a href=&quot;current_exception&quot;&gt;std::current_exception&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">Экземпляр &lt;code&gt;&lt;a href=&quot;exception_ptr&quot;&gt;std::exception_ptr&lt;/a&gt;&lt;/code&gt; содержащий ссылку на копию &lt;code&gt;e&lt;/code&gt; , или экземпляр &lt;code&gt;&lt;a href=&quot;../memory/new/bad_alloc&quot;&gt;std::bad_alloc&lt;/a&gt;&lt;/code&gt; или экземпляр &lt;code&gt;&lt;a href=&quot;bad_exception&quot;&gt;std::bad_exception&lt;/a&gt;&lt;/code&gt; (см. Std &lt;code&gt;&lt;a href=&quot;current_exception&quot;&gt;std::current_exception&lt;/a&gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="ba236b1f1a8d82abf0083dac8c36782f2303388c" translate="yes" xml:space="preserve">
          <source>An instance of &lt;code&gt;&lt;a href=&quot;exception_ptr&quot;&gt;std::exception_ptr&lt;/a&gt;&lt;/code&gt; holding a reference to the exception object, or a copy of the exception object, or to an instance of &lt;code&gt;&lt;a href=&quot;../memory/new/bad_alloc&quot;&gt;std::bad_alloc&lt;/a&gt;&lt;/code&gt; or to an instance of &lt;code&gt;&lt;a href=&quot;bad_exception&quot;&gt;std::bad_exception&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Экземпляр &lt;code&gt;&lt;a href=&quot;exception_ptr&quot;&gt;std::exception_ptr&lt;/a&gt;&lt;/code&gt; содержащий ссылку на объект исключения, или копию объекта исключения, либо на экземпляр &lt;code&gt;&lt;a href=&quot;../memory/new/bad_alloc&quot;&gt;std::bad_alloc&lt;/a&gt;&lt;/code&gt; либо на экземпляр &lt;code&gt;&lt;a href=&quot;bad_exception&quot;&gt;std::bad_exception&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4fbb0b241c865dd210a0103cf5d2af8c3a3e8a71" translate="yes" xml:space="preserve">
          <source>An integer greater than zero if the stream is wide-oriented after this call, less than zero if the stream is byte-oriented after this call, and zero if the stream has no orientation.</source>
          <target state="translated">Целое число больше нуля,если поток после этого вызова широко ориентирован,меньше нуля,если поток после этого вызова ориентирован на байты,и ноль,если поток не имеет ориентации.</target>
        </trans-unit>
        <trans-unit id="27a4b795995133a65c00f00e3a5c86747c696bf8" translate="yes" xml:space="preserve">
          <source>An integer literal is a &lt;a href=&quot;expressions#Primary_expressions&quot;&gt;primary expression&lt;/a&gt; of the form.</source>
          <target state="translated">Целочисленный литерал является &lt;a href=&quot;expressions#Primary_expressions&quot;&gt;основным выражением&lt;/a&gt; формы.</target>
        </trans-unit>
        <trans-unit id="22296b3029f90df1ec990b3a781242c55d5beaa6" translate="yes" xml:space="preserve">
          <source>An integer type which can be accessed as an atomic entity even in the presence of asynchronous interrupts made by signals.</source>
          <target state="translated">Целый тип,к которому можно получить доступ как к атомарной сущности даже при наличии асинхронных прерываний по сигналам.</target>
        </trans-unit>
        <trans-unit id="5018516b14deb056aa79dc2efd7d50ff7637de58" translate="yes" xml:space="preserve">
          <source>An invalid (in the current C locale) multibyte character was encountered.</source>
          <target state="translated">Встречался недействительный (в текущей локали C)многобайтовый символ.</target>
        </trans-unit>
        <trans-unit id="6a1cb2e740b1d006f9942d3f948b281b6ec84075" translate="yes" xml:space="preserve">
          <source>An invalid multibyte character (according to the current C locale) was encountered. &lt;code&gt;src&lt;/code&gt; is set to point at the beginning of the first unconverted multibyte character.</source>
          <target state="translated">Обнаружен недопустимый многобайтовый символ (согласно текущей локали C). &lt;code&gt;src&lt;/code&gt; указывает на начало первого не преобразованного многобайтового символа.</target>
        </trans-unit>
        <trans-unit id="e0fbbc7a96cda105d7e43e6ea9e384c88eb8bd01" translate="yes" xml:space="preserve">
          <source>An invalid simple-template-id is a compile-time error, unless it names a function template specialization (in which case &lt;a href=&quot;sfinae&quot;&gt;SFINAE&lt;/a&gt; may apply).</source>
          <target state="translated">Недопустимый простой-шаблон-идентификатор является ошибкой во время компиляции, если он не называет специализацию шаблона функции (в этом случае может применяться &lt;a href=&quot;sfinae&quot;&gt;SFINAE&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="738a0c3fdce4b2a8db1475951201c5a23036b195" translate="yes" xml:space="preserve">
          <source>An invariant of &lt;code&gt;zoned_time&lt;/code&gt; is that it always refers to a valid time zone and represents an existing and unambiguous time point in that time zone. Consistent with this invariant, &lt;code&gt;zoned_time&lt;/code&gt; has no move constructor or move assignment operator; attempts to move a &lt;code&gt;zoned_time&lt;/code&gt; will perform a copy.</source>
          <target state="translated">Инвариант &lt;code&gt;zoned_time&lt;/code&gt; заключается в том, что он всегда ссылается на действительный часовой пояс и представляет существующий и однозначный момент времени в этом часовом поясе. В соответствии с этим инвариантом, &lt;code&gt;zoned_time&lt;/code&gt; не имеет конструктора перемещения или оператора присваивания перемещения; Попытки переместить &lt;code&gt;zoned_time&lt;/code&gt; будут выполнять копию.</target>
        </trans-unit>
        <trans-unit id="ff8ec771a3e408dd089882b2303398b60f16d16a" translate="yes" xml:space="preserve">
          <source>An invocation of an &lt;a href=&quot;consteval&quot;&gt;immediate function&lt;/a&gt; is always evaluated, even in an unevaluated operand.</source>
          <target state="translated">Вызов &lt;a href=&quot;consteval&quot;&gt;непосредственной функции&lt;/a&gt; всегда оценивается, даже в неоцененном операнде.</target>
        </trans-unit>
        <trans-unit id="30e4b56dc9d38cfe9d66956b6e4aed328bf1c204" translate="yes" xml:space="preserve">
          <source>An invocation of an immediate function whose innermost non-block scope is not a &lt;a href=&quot;scope#Function_parameter_scope&quot;&gt;function parameter scope&lt;/a&gt; of an immediate function must produce a constant expression; such an invocation (known as an</source>
          <target state="translated">Вызов непосредственной функции, внутренняя неблокированная область которой не является &lt;a href=&quot;scope#Function_parameter_scope&quot;&gt;областью действия параметра&lt;/a&gt; непосредственной функции, должна создавать константное выражение; такой вызов (известный как</target>
        </trans-unit>
        <trans-unit id="4706ad1f00d621a48d2e07b2a350e165dc71b6e6" translate="yes" xml:space="preserve">
          <source>An iterator pointing at the same object as &lt;code&gt;*this&lt;/code&gt;.</source>
          <target state="translated">Итератор, указывающий на тот же объект, что и &lt;code&gt;*this&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7ef94e98b9aecdcf5a48dda0b6d175cdca4869ff" translate="yes" xml:space="preserve">
          <source>An iterator pointing immediately after the last character produced.</source>
          <target state="translated">Итератор,указывающий сразу после последнего созданного персонажа.</target>
        </trans-unit>
        <trans-unit id="a6f7df894c8448a1c11979a004ebd6ace3d75b98" translate="yes" xml:space="preserve">
          <source>An iterator pointing immediately after the last character recognized as a valid part of the monetary string input.</source>
          <target state="translated">Итератор,указывающий сразу после последнего символа,признанного действительной частью входной денежной строки.</target>
        </trans-unit>
        <trans-unit id="2ae3748a0356e1b6e535e66f5c4ffa0cfaff3539" translate="yes" xml:space="preserve">
          <source>An iterator pointing to the element following the erased element, or &lt;code&gt;end()&lt;/code&gt; if no such element exists.</source>
          <target state="translated">Итератор, указывающий на элемент, следующий за стертым элементом, или &lt;code&gt;end()&lt;/code&gt; если такого элемента не существует.</target>
        </trans-unit>
        <trans-unit id="e831682f27c4215fd3d51adc3ab282760afa70fa" translate="yes" xml:space="preserve">
          <source>An iterator referring to the first &lt;code&gt;std::chrono::tzdb&lt;/code&gt; in the container.</source>
          <target state="translated">Итератор, ссылающийся на первый &lt;code&gt;std::chrono::tzdb&lt;/code&gt; в контейнере.</target>
        </trans-unit>
        <trans-unit id="7a63b694e4a7d314c8d05c5417ebc4bb1f31eb30" translate="yes" xml:space="preserve">
          <source>An iterator to the beginning of &lt;code&gt;c&lt;/code&gt; or &lt;code&gt;array&lt;/code&gt;.</source>
          <target state="translated">Итератор к началу &lt;code&gt;c&lt;/code&gt; или &lt;code&gt;array&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="02479c246c44225a9035a0d45997e83cce8420db" translate="yes" xml:space="preserve">
          <source>An iterator to the end of &lt;code&gt;c&lt;/code&gt; or &lt;code&gt;array&lt;/code&gt;. Note that the end of a container or array is defined as the element following the last valid element.</source>
          <target state="translated">Итератор до конца &lt;code&gt;c&lt;/code&gt; или &lt;code&gt;array&lt;/code&gt; . Обратите внимание, что конец контейнера или массива определяется как элемент, следующий за последним допустимым элементом.</target>
        </trans-unit>
        <trans-unit id="a11a64a7066be12c5192b1c7d9f47275f39b47d8" translate="yes" xml:space="preserve">
          <source>An iterator to the reverse-beginning of &lt;code&gt;c&lt;/code&gt; or &lt;code&gt;array&lt;/code&gt;.</source>
          <target state="translated">Итератор к обратному началу &lt;code&gt;c&lt;/code&gt; или &lt;code&gt;array&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e7197d58fc54a43b495f2accaea0f6922ad829bd" translate="yes" xml:space="preserve">
          <source>An iterator to the reverse-end of &lt;code&gt;c&lt;/code&gt; or &lt;code&gt;array&lt;/code&gt;.</source>
          <target state="translated">Итератор к обратному концу &lt;code&gt;c&lt;/code&gt; или &lt;code&gt;array&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="625c5f2464c30593f74840f1bd907c2068776afc" translate="yes" xml:space="preserve">
          <source>An iterator type whose category, value, difference, pointer and</source>
          <target state="translated">Тип итератора,категория,значение,разница,указатель и</target>
        </trans-unit>
        <trans-unit id="19a75628cf6442d77f6648e9556c5bb263d28280" translate="yes" xml:space="preserve">
          <source>An lvalue may be used to &lt;a href=&quot;reference_initialization&quot;&gt;initialize an lvalue reference&lt;/a&gt;; this associates a new name with the object identified by the expression.</source>
          <target state="translated">Значение lvalue может использоваться для &lt;a href=&quot;reference_initialization&quot;&gt;инициализации ссылки на значение lvalue&lt;/a&gt; ; это связывает новое имя с объектом, идентифицированным выражением.</target>
        </trans-unit>
        <trans-unit id="ca62ca28732e81cc9d1b6aa1ed666a055a48eb41" translate="yes" xml:space="preserve">
          <source>An object can contain other objects, which are called</source>
          <target state="translated">Объект может содержать другие объекты,которые называются</target>
        </trans-unit>
        <trans-unit id="83df7119bca64cfa6a0dedb8658d0ab00a4eaf95" translate="yes" xml:space="preserve">
          <source>An object of class &lt;code&gt;basic_istream::sentry&lt;/code&gt; is constructed in local scope at the beginning of each member function of &lt;code&gt;&lt;a href=&quot;../basic_istream&quot;&gt;std::basic_istream&lt;/a&gt;&lt;/code&gt; that performs input (both formatted and unformatted). Its constructor prepares the input stream: checks if the stream is already in a failed state, flushes the tie()'d output streams, skips leading whitespace unless &lt;code&gt;noskipws&lt;/code&gt; flag is set, and performs other implementation-defined tasks if necessary. All cleanup, if necessary, is performed in the destructor, so that it is guaranteed to happen if exceptions are thrown during input.</source>
          <target state="translated">Объект класса &lt;code&gt;basic_istream::sentry&lt;/code&gt; в локальной области видимости в начале каждой функции-члена &lt;code&gt;&lt;a href=&quot;../basic_istream&quot;&gt;std::basic_istream&lt;/a&gt;&lt;/code&gt; которая выполняет ввод (как отформатированный, так и не отформатированный). Его конструктор подготавливает входной поток: проверяет, находится ли поток уже в состоянии сбоя, сбрасывает выходные потоки tie (), пропускает &lt;code&gt;noskipws&lt;/code&gt; пробелы, если не установлен флаг noskipws , и при необходимости выполняет другие задачи, определенные реализацией. Вся очистка, если необходимо, выполняется в деструкторе, поэтому она гарантированно произойдет, если во время ввода будут выданы исключения.</target>
        </trans-unit>
        <trans-unit id="823634b581a9cede4fd0ccc574bd7fa0bc24d634" translate="yes" xml:space="preserve">
          <source>An object of class &lt;code&gt;basic_ostream::sentry&lt;/code&gt; is constructed in local scope at the beginning of each member function of &lt;code&gt;&lt;a href=&quot;../basic_ostream&quot;&gt;std::basic_ostream&lt;/a&gt;&lt;/code&gt; that performs output (both formatted and unformatted). Its constructor prepares the output stream: checks if the stream is already in a failed state, flushes the tie()'d output streams, and performs other implementation-defined tasks if necessary. Implementation-defined cleanup, as well as flushing of the output stream if necessary, is performed in the destructor, so that it is guaranteed to happen if exceptions are thrown during output.</source>
          <target state="translated">Объект класса &lt;code&gt;basic_ostream::sentry&lt;/code&gt; в локальной области видимости в начале каждой функции-члена &lt;code&gt;&lt;a href=&quot;../basic_ostream&quot;&gt;std::basic_ostream&lt;/a&gt;&lt;/code&gt; которая выполняет вывод (как отформатированный, так и не отформатированный). Его конструктор подготавливает выходной поток: проверяет, находится ли поток в состоянии сбоя, сбрасывает выходные потоки tie () и выполняет другие задачи, определенные реализацией, если это необходимо. В деструкторе выполняется очистка, определяемая реализацией, а также очистка выходного потока, если это необходимо, так что гарантированно произойдет, если во время вывода возникнут исключения.</target>
        </trans-unit>
        <trans-unit id="0455f9161322806dadb1a5a0172793f044ae30ea" translate="yes" xml:space="preserve">
          <source>An object of class &lt;code&gt;std::locale&lt;/code&gt; is an immutable indexed set of immutable facets. Each stream object of the C++ input/output library is associated with an &lt;code&gt;std::locale&lt;/code&gt; object and uses its facets for parsing and formatting of all data. In addition, a locale object is associated with each &lt;code&gt;&lt;a href=&quot;../regex/basic_regex&quot;&gt;std::basic_regex&lt;/a&gt;&lt;/code&gt; object. Locale objects can also be used as predicates that perform string collation with the standard containers and algorithms and can be accessed directly to obtain or modify the facets they hold.</source>
          <target state="translated">Объект класса &lt;code&gt;std::locale&lt;/code&gt; является неизменяемым индексированным набором неизменяемых фасетов. Каждый потоковый объект библиотеки ввода-вывода C ++ связан с объектом &lt;code&gt;std::locale&lt;/code&gt; и использует его фасеты для анализа и форматирования всех данных. Кроме того, объект языкового стандарта связан с каждым объектом &lt;code&gt;&lt;a href=&quot;../regex/basic_regex&quot;&gt;std::basic_regex&lt;/a&gt;&lt;/code&gt; . Объекты локали также могут использоваться в качестве предикатов, которые выполняют сопоставление строк со стандартными контейнерами и алгоритмами, и к ним можно обращаться напрямую для получения или изменения фасетов, которые они содержат.</target>
        </trans-unit>
        <trans-unit id="d66af98d41f06cecefd4af58c7d9c0ca924bcff6" translate="yes" xml:space="preserve">
          <source>An object of the type must be contextually convertible to bool. The effect of this conversion returns false if the value is equivalent to its null value and true otherwise.</source>
          <target state="translated">Объект такого типа должен быть контекстуально конвертирован в шерсть.Эффект этого преобразования возвращает false,если значение эквивалентно его нулевому значению,и true в противном случае.</target>
        </trans-unit>
        <trans-unit id="7bacce28d1059e82c9739033111e220b4d8671d7" translate="yes" xml:space="preserve">
          <source>An object of type &lt;code&gt;&lt;a href=&quot;../../../container/vector&quot;&gt;std::vector&lt;/a&gt;&amp;lt;double&amp;gt;&lt;/code&gt;</source>
          <target state="translated">Объект типа &lt;code&gt;&lt;a href=&quot;../../../container/vector&quot;&gt;std::vector&lt;/a&gt;&amp;lt;double&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f0e2760523dc7073d44af20a277e7f5a90698df4" translate="yes" xml:space="preserve">
          <source>An object of type &lt;code&gt;&lt;a href=&quot;../utility/initializer_list&quot;&gt;std::initializer_list&lt;/a&gt;&lt;/code&gt;&amp;lt;value_type&amp;gt;</source>
          <target state="translated">Объект типа &lt;code&gt;&lt;a href=&quot;../utility/initializer_list&quot;&gt;std::initializer_list&lt;/a&gt;&lt;/code&gt; &amp;lt;value_type&amp;gt;</target>
        </trans-unit>
        <trans-unit id="7bd18a30dbdab573b7c39639752708407fb37b52" translate="yes" xml:space="preserve">
          <source>An object of type &lt;code&gt;To&lt;/code&gt; whose value representation is as described above.</source>
          <target state="translated">Объект типа &lt;code&gt;To&lt;/code&gt; , представление значения которого является таким, как описано выше.</target>
        </trans-unit>
        <trans-unit id="e81f259c6d82e8e50d80fae74008b6a20cb6f607" translate="yes" xml:space="preserve">
          <source>An object of type &lt;code&gt;X::value_compare&lt;/code&gt; constructed out of the comparison object is returned.</source>
          <target state="translated">&lt;code&gt;X::value_compare&lt;/code&gt; объект типа X :: value_compare, созданный из объекта сравнения.</target>
        </trans-unit>
        <trans-unit id="7cce6a193570a048de83246c7b511f63641f001b" translate="yes" xml:space="preserve">
          <source>An object of type &lt;code&gt;std::initializer_list&amp;lt;T&amp;gt;&lt;/code&gt; is a lightweight proxy object that provides access to an array of objects of type &lt;code&gt;const T&lt;/code&gt;.</source>
          <target state="translated">Объект типа &lt;code&gt;std::initializer_list&amp;lt;T&amp;gt;&lt;/code&gt; представляет собой легкий прокси - объект , который обеспечивает доступ к массиву объектов типа &lt;code&gt;const T&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9033aa603f097747fd262291447f23ece9703946" translate="yes" xml:space="preserve">
          <source>An object of type &lt;code&gt;std::once_flag&lt;/code&gt; that is passed to multiple calls to &lt;code&gt;&lt;a href=&quot;call_once&quot;&gt;std::call_once&lt;/a&gt;&lt;/code&gt; allows those calls to coordinate with each other such that only one of the calls will actually run to completion.</source>
          <target state="translated">Объект типа &lt;code&gt;std::once_flag&lt;/code&gt; который передается нескольким вызовам &lt;code&gt;&lt;a href=&quot;call_once&quot;&gt;std::call_once&lt;/a&gt;&lt;/code&gt; позволяет этим вызовам координировать действия друг с другом так, что только один из вызовов фактически будет выполнен до завершения.</target>
        </trans-unit>
        <trans-unit id="3bdae20fade93232b05ba74a9d73283a7dcdf8dd" translate="yes" xml:space="preserve">
          <source>An object of unspecified type such that any value can be assigned to it with no effect. Intended for use with &lt;code&gt;&lt;a href=&quot;tie&quot;&gt;std::tie&lt;/a&gt;&lt;/code&gt; when unpacking a &lt;code&gt;&lt;a href=&quot;../tuple&quot;&gt;std::tuple&lt;/a&gt;&lt;/code&gt;, as a placeholder for the arguments that are not used.</source>
          <target state="translated">Объект неопределенного типа, так что ему может быть присвоено любое значение без эффекта. Предназначен для использования с &lt;code&gt;&lt;a href=&quot;tie&quot;&gt;std::tie&lt;/a&gt;&lt;/code&gt; при распаковке &lt;code&gt;&lt;a href=&quot;../tuple&quot;&gt;std::tuple&lt;/a&gt;&lt;/code&gt; в качестве заполнителя для аргументов, которые не используются.</target>
        </trans-unit>
        <trans-unit id="26b9967510dc89a341fa42ca83cfa44ef6ebf576" translate="yes" xml:space="preserve">
          <source>An object that is not a subobject of another object is called</source>
          <target state="translated">Объект,не являющийся подобъектом другого объекта,называется</target>
        </trans-unit>
        <trans-unit id="858015fdff20dfb1bcca98de775349cd0072b086" translate="yes" xml:space="preserve">
          <source>An object, in C++, is a</source>
          <target state="translated">Объект на C++-это</target>
        </trans-unit>
        <trans-unit id="2f63388a843dce76eb6b22f8810249f3b38a691e" translate="yes" xml:space="preserve">
          <source>An optional object &lt;code&gt;op&lt;/code&gt; may be turned into an empty optional with both &lt;code&gt;op = {};&lt;/code&gt; and &lt;code&gt;op = nullopt;&lt;/code&gt;. The first expression constructs an empty &lt;code&gt;optional&lt;/code&gt; object with &lt;code&gt;{}&lt;/code&gt; and assigns it to &lt;code&gt;op&lt;/code&gt;.</source>
          <target state="translated">Необязательный объектный &lt;code&gt;op&lt;/code&gt; объект может быть превращен в пустой необязательный с помощью обоих &lt;code&gt;op = {};&lt;/code&gt; и &lt;code&gt;op = nullopt;&lt;/code&gt; , Первое выражение создает пустой &lt;code&gt;optional&lt;/code&gt; объект с &lt;code&gt;{}&lt;/code&gt; и присваивает его &lt;code&gt;op&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="eb6a5327aa18d2bb8b350958dde2d290354f8030" translate="yes" xml:space="preserve">
          <source>An out-of-class definition of a member function template must be</source>
          <target state="translated">Внеклассное определение шаблона функции члена должно быть следующим</target>
        </trans-unit>
        <trans-unit id="7a79aaf703db97b5a7b0d58031c37912c2d8149a" translate="yes" xml:space="preserve">
          <source>An output iterator that writes successive elements into an output stream, separating adjacent elements with a delimiter</source>
          <target state="translated">Выходной итератор,который записывает последовательные элементы в выходной поток,разделяя соседние элементы разделителем</target>
        </trans-unit>
        <trans-unit id="7c1bcb6f6b9e1950eeb340e7b5a97c8ee444cb42" translate="yes" xml:space="preserve">
          <source>An output iterator to element past the last element copied.</source>
          <target state="translated">Выходной итератор к элементу,прошедшему мимо последнего скопированного элемента.</target>
        </trans-unit>
        <trans-unit id="dc7304d0df5442d14acbaafb1a4c43fd8d0d9ec3" translate="yes" xml:space="preserve">
          <source>An overload &lt;code&gt;F(T_i)&lt;/code&gt; is only considered if the declaration &lt;code&gt;T_i x[] = { &lt;a href=&quot;../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;T&amp;gt;(t) };&lt;/code&gt; is valid for some invented variable &lt;code&gt;x&lt;/code&gt;;</source>
          <target state="translated">Перегрузка &lt;code&gt;F(T_i)&lt;/code&gt; рассматривается только в том случае, если объявление &lt;code&gt;T_i x[] = { &lt;a href=&quot;../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;T&amp;gt;(t) };&lt;/code&gt; допустимо для некоторой придуманной переменной &lt;code&gt;x&lt;/code&gt; ;</target>
        </trans-unit>
        <trans-unit id="31a89ff54bf0a65e07ec5e6290a30f27bf9c83bf" translate="yes" xml:space="preserve">
          <source>An rvalue can't be used as the left-hand operand of the built-in assignment or compound assignment operators.</source>
          <target state="translated">Значение не может быть использовано в качестве левого операндов встроенных операторов назначения или составных операторов назначения.</target>
        </trans-unit>
        <trans-unit id="df8a77695e43a01d35ff3833e595deae1c70885b" translate="yes" xml:space="preserve">
          <source>An rvalue may be used to &lt;a href=&quot;reference_initialization&quot;&gt;initialize a const lvalue reference&lt;/a&gt;, in which case the lifetime of the object identified by the rvalue is &lt;a href=&quot;reference_initialization#Lifetime_of_a_temporary&quot;&gt;extended&lt;/a&gt; until the scope of the reference ends.</source>
          <target state="translated">Значение r может быть использовано для &lt;a href=&quot;reference_initialization&quot;&gt;инициализации ссылки на постоянное значение&lt;/a&gt; , и в этом случае время жизни объекта, идентифицированного значением, &lt;a href=&quot;reference_initialization#Lifetime_of_a_temporary&quot;&gt;увеличивается&lt;/a&gt; до тех пор, пока не закончится область действия ссылки.</target>
        </trans-unit>
        <trans-unit id="0e072674017d2ac839c66e65b949d44d2466050e" translate="yes" xml:space="preserve">
          <source>An rvalue may be used to &lt;a href=&quot;reference_initialization&quot;&gt;initialize an rvalue reference&lt;/a&gt;, in which case the lifetime of the object identified by the rvalue is &lt;a href=&quot;reference_initialization#Lifetime_of_a_temporary&quot;&gt;extended&lt;/a&gt; until the scope of the reference ends.</source>
          <target state="translated">Значение r может быть использовано для &lt;a href=&quot;reference_initialization&quot;&gt;инициализации ссылки на значение&lt;/a&gt; , в этом случае время жизни объекта, идентифицированного значением, &lt;a href=&quot;reference_initialization#Lifetime_of_a_temporary&quot;&gt;увеличивается&lt;/a&gt; до тех пор, пока не закончится область действия ссылки.</target>
        </trans-unit>
        <trans-unit id="9223b2493a48ecf49ed1c32238f5defa3e17a1e2" translate="yes" xml:space="preserve">
          <source>An rvalue reference to a cv-unqualified template parameter is not a &lt;a href=&quot;template_argument_deduction&quot;&gt;forwarding reference&lt;/a&gt; if that parameter is a class template parameter:</source>
          <target state="translated">Ссылка rvalue на неквалифицированный cv параметр шаблона не является &lt;a href=&quot;template_argument_deduction&quot;&gt;ссылкой переадресации,&lt;/a&gt; если этот параметр является параметром шаблона класса:</target>
        </trans-unit>
        <trans-unit id="06c47888799c4beade0a1c880e7969d048a047e7" translate="yes" xml:space="preserve">
          <source>An rvalue reference to the element at relative location, that is, &lt;code&gt;std::move(base()[n])&lt;/code&gt;.</source>
          <target state="translated">Ссылка rvalue на элемент в относительном местоположении, то есть &lt;code&gt;std::move(base()[n])&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4431ce6b5c54a2464689bcd2649d6be6a6d6edb5" translate="yes" xml:space="preserve">
          <source>Analyzes the character sequence &lt;code&gt;[first,last)&lt;/code&gt; for a pattern described below. If no characters match the pattern or if the value obtained by parsing the matched characters is not representable in the type of &lt;code&gt;value&lt;/code&gt;, &lt;code&gt;value&lt;/code&gt; is unmodified, otherwise the characters matching the pattern are interpreted as a text representation of an arithmetic value, which is stored in &lt;code&gt;value&lt;/code&gt;.</source>
          <target state="translated">Анализирует последовательность символов &lt;code&gt;[first,last)&lt;/code&gt; для шаблона, описанного ниже. Если ни один символ не соответствует шаблону или если значение, полученное путем анализа соответствующих символов, не представляется в типе &lt;code&gt;value&lt;/code&gt; , &lt;code&gt;value&lt;/code&gt; не изменяется, в противном случае символы, соответствующие шаблону, интерпретируются как текстовое представление арифметического значения, которое хранится в &lt;code&gt;value&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2ffd735c77a58f5bee4802f3701c7f6fda3f232e" translate="yes" xml:space="preserve">
          <source>And after evaluation, the value of &lt;code&gt;*p&lt;/code&gt; is equivalent to the value formerly held by &lt;code&gt;rv&lt;/code&gt; (&lt;code&gt;rv&lt;/code&gt; remains valid, but is in an unspecified state.).</source>
          <target state="translated">И после оценки значение &lt;code&gt;*p&lt;/code&gt; эквивалентно значению, ранее сохраненному в &lt;code&gt;rv&lt;/code&gt; ( &lt;code&gt;rv&lt;/code&gt; остается действительным, но находится в неопределенном состоянии.).</target>
        </trans-unit>
        <trans-unit id="a5b3b63e68ab039e5e9a76fb79b51bc5995bb988" translate="yes" xml:space="preserve">
          <source>And after evaluation, the value of &lt;code&gt;*p&lt;/code&gt; is equivalent to the value of &lt;code&gt;v&lt;/code&gt;. The value of &lt;code&gt;v&lt;/code&gt; is unchanged.</source>
          <target state="translated">И после оценки значение &lt;code&gt;*p&lt;/code&gt; эквивалентно значению &lt;code&gt;v&lt;/code&gt; . Значение &lt;code&gt;v&lt;/code&gt; не изменяется.</target>
        </trans-unit>
        <trans-unit id="56b1a77f4fe21b0570e2813c8d454db94a7cb374" translate="yes" xml:space="preserve">
          <source>And if any &lt;a href=&quot;reference_initialization&quot;&gt;reference binding&lt;/a&gt; takes place, it is direct binding (not one that constructs a temporary object)</source>
          <target state="translated">И если имеет место какая-либо &lt;a href=&quot;reference_initialization&quot;&gt;ссылочная привязка&lt;/a&gt; , это прямая привязка (не та, которая создает временный объект)</target>
        </trans-unit>
        <trans-unit id="c4c1b28f8418245c8009d38e2fd06aa2b822e70b" translate="yes" xml:space="preserve">
          <source>And, for every.</source>
          <target state="translated">И,для каждого.</target>
        </trans-unit>
        <trans-unit id="c8cb4cc17edf8c49a6c05da36754f248647a5429" translate="yes" xml:space="preserve">
          <source>And, given.</source>
          <target state="translated">И,учитывая.</target>
        </trans-unit>
        <trans-unit id="78f82f2df8d5e45692f017f6cf128f97529f9a02" translate="yes" xml:space="preserve">
          <source>Anonymous unions</source>
          <target state="translated">Анонимные союзы</target>
        </trans-unit>
        <trans-unit id="f39f69aff078c2dee33a0b3c3af4837d3936bb7c" translate="yes" xml:space="preserve">
          <source>Anonymous unions have further restrictions: they cannot have member functions, cannot have static data members, and all their data members must be public. The only declarations allowed are non-static data members  and &lt;a href=&quot;static_assert&quot;&gt;static_assert&lt;/a&gt; declarations(since C++14).</source>
          <target state="translated">Анонимные объединения имеют дополнительные ограничения: они не могут иметь функции-члены, не могут иметь статические элементы данных, и все их элементы данных должны быть открытыми. Допустимы только объявления нестатических членов данных и объявления &lt;a href=&quot;static_assert&quot;&gt;static_assert&lt;/a&gt; (начиная с C ++ 14).</target>
        </trans-unit>
        <trans-unit id="79c7bbc8f686393ed4d5a563735506c51a1b8513" translate="yes" xml:space="preserve">
          <source>Another use for &lt;code&gt;std::weak_ptr&lt;/code&gt; is to break reference cycles formed by objects managed by &lt;code&gt;&lt;a href=&quot;shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&lt;/code&gt;. If such cycle is orphaned (i,e. there are no outside shared pointers into the cycle), the shared_ptr reference counts cannot reach zero and the memory is leaked. To prevent this, one of the pointers in the cycle can be made weak.</source>
          <target state="translated">Другое использование для &lt;code&gt;std::weak_ptr&lt;/code&gt; - это прерывание ссылочных циклов, образованных объектами, управляемыми &lt;code&gt;&lt;a href=&quot;shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&lt;/code&gt; . Если такой цикл потерян (то есть в цикле нет внешних общих указателей), счетчик ссылок shared_ptr не может достигнуть нуля и утечка памяти. Чтобы предотвратить это, один из указателей в цикле может быть сделан слабым.</target>
        </trans-unit>
        <trans-unit id="899d67ebfae429b08b8eebcf8e8c9e086747304a" translate="yes" xml:space="preserve">
          <source>Another way to test if a floating-point value is NaN is to compare it with itself: &lt;code&gt;bool is_nan(double x) { return x != x; }&lt;/code&gt;</source>
          <target state="translated">Другой способ проверить, является ли значение с плавающей точкой NaN, состоит в сравнении его с самим собой: &lt;code&gt;bool is_nan(double x) { return x != x; }&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1f898bf7d5a8e88530be0282c53c70a4902e14d0" translate="yes" xml:space="preserve">
          <source>Any &lt;a href=&quot;declarations&quot;&gt;simple declarations&lt;/a&gt; are allowed, except.</source>
          <target state="translated">Допускаются любые &lt;a href=&quot;declarations&quot;&gt;простые объявления&lt;/a&gt; , кроме.</target>
        </trans-unit>
        <trans-unit id="b7e1bdbe6a7f8ce733280e2254188bf3b1de8cb1" translate="yes" xml:space="preserve">
          <source>Any &lt;a href=&quot;function&quot;&gt;function declarations&lt;/a&gt; are allowed, with additional syntax elements that are only available for non-static member functions: &lt;a href=&quot;final&quot;&gt;final&lt;/a&gt; and &lt;a href=&quot;override&quot;&gt;override&lt;/a&gt; specifiers, &lt;a href=&quot;abstract_class&quot;&gt;pure-specifiers&lt;/a&gt;, cv-qualifiers, ref-qualifiers, and &lt;a href=&quot;constructor&quot;&gt;member initialization lists&lt;/a&gt;.</source>
          <target state="translated">Разрешены любые &lt;a href=&quot;function&quot;&gt;объявления функций&lt;/a&gt; с дополнительными элементами синтаксиса, которые доступны только для нестатических функций-членов: спецификаторы &lt;a href=&quot;final&quot;&gt;final&lt;/a&gt; и &lt;a href=&quot;override&quot;&gt;override,&lt;/a&gt; спецификаторы &lt;a href=&quot;abstract_class&quot;&gt;pure, спецификаторы&lt;/a&gt; cv, ref-квалификаторы и &lt;a href=&quot;constructor&quot;&gt;списки инициализации членов&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8b49f8c4e0a542030094cffe671da5baa163695a" translate="yes" xml:space="preserve">
          <source>Any additional integral types needed by the typedefs in the header &lt;a href=&quot;../header/cstdint&quot;&gt;&lt;code&gt;&amp;lt;cstdint&amp;gt;&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Любые дополнительные целочисленные типы, необходимые для определения типов в заголовке &lt;a href=&quot;../header/cstdint&quot;&gt; &lt;code&gt;&amp;lt;cstdint&amp;gt;&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f08aea9a890f019823885a1075301ba39bc58d28" translate="yes" xml:space="preserve">
          <source>Any capture may appear only once:</source>
          <target state="translated">Любой захват может появиться только один раз:</target>
        </trans-unit>
        <trans-unit id="a6942cddecd7def2bc3a413a01b71ac46c41eb7d" translate="yes" xml:space="preserve">
          <source>Any character in the buffer which has been initialized, regardless of whether it originated from the string passed in the constructor or was appended by &lt;code&gt;&lt;a href=&quot;overflow&quot;&gt;overflow()&lt;/a&gt;&lt;/code&gt;, is considered to be part of the input sequence.</source>
          <target state="translated">Любой символ в буфере, который был инициализирован, независимо от того, произошел ли он из строки, переданной в конструкторе, или был добавлен через &lt;code&gt;&lt;a href=&quot;overflow&quot;&gt;overflow()&lt;/a&gt;&lt;/code&gt; , считается частью входной последовательности.</target>
        </trans-unit>
        <trans-unit id="6e77be05deb9b5ecac58519844a0e640e7f8ea02" translate="yes" xml:space="preserve">
          <source>Any character sequence, except that it must not contain the closing sequence &lt;code&gt;)&lt;/code&gt;delimiter&lt;code&gt;&quot;&lt;/code&gt;</source>
          <target state="translated">Любая последовательность символов, за исключением того, что она не должна содержать закрывающую последовательность &lt;code&gt;)&lt;/code&gt; разделитель &lt;code&gt;&quot;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e8037bc5cabc21aa1e4b299af2223a57b399d0e7" translate="yes" xml:space="preserve">
          <source>Any class type (whether declared with class-key&lt;code&gt;class&lt;/code&gt; or &lt;code&gt;struct&lt;/code&gt;) may be declared as</source>
          <target state="translated">Любой тип класса (объявленный с классом-ключом &lt;code&gt;class&lt;/code&gt; или &lt;code&gt;struct&lt;/code&gt; ) может быть объявлен как</target>
        </trans-unit>
        <trans-unit id="3f8220613774bb0009e4140293deea0ebc75659a" translate="yes" xml:space="preserve">
          <source>Any declaration with an &lt;code&gt;extern&lt;/code&gt;&lt;a href=&quot;storage_duration&quot;&gt;storage class specifier&lt;/a&gt; or with a &lt;a href=&quot;language_linkage&quot;&gt;language linkage&lt;/a&gt; specifier (such as &lt;code&gt;extern &quot;C&quot;&lt;/code&gt;) without an initializer</source>
          <target state="translated">Любое объявление со &lt;a href=&quot;storage_duration&quot;&gt;спецификатором класса &lt;/a&gt; &lt;code&gt;extern&lt;/code&gt; хранилища или со спецификатором &lt;a href=&quot;language_linkage&quot;&gt;языковой связи&lt;/a&gt; (например, &lt;code&gt;extern &quot;C&quot;&lt;/code&gt; ) без инициализатора</target>
        </trans-unit>
        <trans-unit id="7246de96efdd56306a5b292694e0b51ddecb8395" translate="yes" xml:space="preserve">
          <source>Any entity captured by a lambda (implicitly or explicitly) is odr-used by the lambda-expression (therefore, implicit capture by a nested lambda triggers implicit capture in the enclosing lambda).</source>
          <target state="translated">Любая сущность,захваченная лямбдой (имплицитно или явно),используется неявным выражением лямбды (следовательно,имплицитный захват вложенной лямбдой вызывает имплицитный захват в прилагаемой лямбде).</target>
        </trans-unit>
        <trans-unit id="2989809a7b8d0c13f3bc5dcda54fae5845e8e939" translate="yes" xml:space="preserve">
          <source>Any exception thrown by &lt;code&gt;Clock&lt;/code&gt; or &lt;code&gt;Duration&lt;/code&gt; (clocks and durations provided by the standard library never throw).</source>
          <target state="translated">Любое исключение, выбрасываемое &lt;code&gt;Clock&lt;/code&gt; или &lt;code&gt;Duration&lt;/code&gt; (часы и длительности, предоставляемые стандартной библиотекой, никогда не генерируются).</target>
        </trans-unit>
        <trans-unit id="0155546b454eb352e396af9a9583e45239059529" translate="yes" xml:space="preserve">
          <source>Any exception thrown by clock, time point, or duration during the execution (clocks, time points, and durations provided by the standard library never throw).</source>
          <target state="translated">Любое исключение,брошенное по часам,точкам времени или продолжительности во время исполнения (часы,очки времени и продолжительность,предоставляемые стандартной библиотекой,никогда не бросаются).</target>
        </trans-unit>
        <trans-unit id="c2829040c4ec83947a1f6cbfdec13c1bbc1b434c" translate="yes" xml:space="preserve">
          <source>Any exception thrown by clock, time_point, or duration during the execution (clocks, time points, and durations provided by the standard library never throw).</source>
          <target state="translated">Любое исключение,брошенное часами,временем_точкой или длительностью во время исполнения (часы,очки времени и длительность,предоставляемые стандартной библиотекой,никогда не бросаются).</target>
        </trans-unit>
        <trans-unit id="c01d2aae1c56f6c1e27461994e6f980f695234ee" translate="yes" xml:space="preserve">
          <source>Any exception thrown by the selected constructor of &lt;code&gt;T&lt;/code&gt;. If an exception is thrown, &lt;code&gt;*this&lt;/code&gt; does not contain a value after this call (the previously contained value, if any, had been destroyed).</source>
          <target state="translated">Любое исключение брошено выбранный конструктор &lt;code&gt;T&lt;/code&gt; . Если выдается исключение, &lt;code&gt;*this&lt;/code&gt; не содержит значения после этого вызова (ранее содержащееся значение, если оно было, было уничтожено).</target>
        </trans-unit>
        <trans-unit id="9f5d991a2059cb95872e45c2fc73f5d2c5d644d5" translate="yes" xml:space="preserve">
          <source>Any exception thrown by the selected constructor of the return value &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">Любое исключение брошенного выбранного конструктора возвращаемое значение &lt;code&gt;T&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8272c2eb0b4b3a47c1fd6266b118d8e0b7dc16c2" translate="yes" xml:space="preserve">
          <source>Any exception thrown by the swap of the &lt;code&gt;Compare&lt;/code&gt; objects.</source>
          <target state="translated">Любое исключение, вызванное обменом объектов &lt;code&gt;Compare&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="067dbafb29590e30db3698223b8289c3ba3a81cd" translate="yes" xml:space="preserve">
          <source>Any exception thrown by the swap of the &lt;code&gt;Hash&lt;/code&gt; or &lt;code&gt;KeyEqual&lt;/code&gt; objects.</source>
          <target state="translated">Любое исключение, &lt;code&gt;KeyEqual&lt;/code&gt; объектов &lt;code&gt;Hash&lt;/code&gt; или KeyEqual .</target>
        </trans-unit>
        <trans-unit id="3ee3642fda89a9c4f4d022a23e66f5f0e3c59796" translate="yes" xml:space="preserve">
          <source>Any exceptions thrown by &lt;code&gt;mutex()-&amp;gt;lock()&lt;/code&gt;</source>
          <target state="translated">Любые исключения, &lt;code&gt;mutex()-&amp;gt;lock()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b6634d37c80775a0920996e88d7df6e338b295bf" translate="yes" xml:space="preserve">
          <source>Any exceptions thrown by &lt;code&gt;mutex()-&amp;gt;lock_shared()&lt;/code&gt;</source>
          <target state="translated">Любые исключения, &lt;code&gt;mutex()-&amp;gt;lock_shared()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a87dda0d2400f372bf7fe2820ca303981427bec3" translate="yes" xml:space="preserve">
          <source>Any exceptions thrown by &lt;code&gt;mutex()-&amp;gt;try_lock()&lt;/code&gt; (&lt;a href=&quot;../../named_req/mutex&quot;&gt;Mutex&lt;/a&gt; types do not throw in &lt;code&gt;try_lock&lt;/code&gt;, but a custom &lt;a href=&quot;../../named_req/lockable&quot;&gt;Lockable&lt;/a&gt; might)</source>
          <target state="translated">Любые исключения брошенных &lt;code&gt;mutex()-&amp;gt;try_lock()&lt;/code&gt; ( &lt;a href=&quot;../../named_req/mutex&quot;&gt;Mutex&lt;/a&gt; типы не бросают в &lt;code&gt;try_lock&lt;/code&gt; , но обычай &lt;a href=&quot;../../named_req/lockable&quot;&gt;Lockable&lt;/a&gt; мощи)</target>
        </trans-unit>
        <trans-unit id="655f412d1dcbf9a4b5e59996ea72d45e509cebc3" translate="yes" xml:space="preserve">
          <source>Any exceptions thrown by &lt;code&gt;mutex()-&amp;gt;try_lock_for(timeout_duration)&lt;/code&gt;</source>
          <target state="translated">Любые исключения, &lt;code&gt;mutex()-&amp;gt;try_lock_for(timeout_duration)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7e00b1d47fa13181989c95392d4568f3ce99f9b2" translate="yes" xml:space="preserve">
          <source>Any exceptions thrown by &lt;code&gt;mutex()-&amp;gt;try_lock_shared()&lt;/code&gt;</source>
          <target state="translated">Любые исключения, &lt;code&gt;mutex()-&amp;gt;try_lock_shared()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="fbacb0aafa934213b8105430ca644b8c44fceb18" translate="yes" xml:space="preserve">
          <source>Any exceptions thrown by &lt;code&gt;mutex()-&amp;gt;try_lock_shared_for(timeout_duration)&lt;/code&gt;</source>
          <target state="translated">Любые исключения, &lt;code&gt;mutex()-&amp;gt;try_lock_shared_for(timeout_duration)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="29577e958473f7848749dbde1c0fe41d4d28de86" translate="yes" xml:space="preserve">
          <source>Any exceptions thrown by &lt;code&gt;mutex()-&amp;gt;try_lock_shared_for(timeout_time)&lt;/code&gt;</source>
          <target state="translated">Любые исключения, &lt;code&gt;mutex()-&amp;gt;try_lock_shared_for(timeout_time)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3c13a79f4c3e26012d9358714b624c43671f4909" translate="yes" xml:space="preserve">
          <source>Any exceptions thrown by &lt;code&gt;mutex()-&amp;gt;try_lock_until(timeout_time)&lt;/code&gt;</source>
          <target state="translated">Любые исключения, &lt;code&gt;mutex()-&amp;gt;try_lock_until(timeout_time)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="50c476323ba0569c33a9d73cfd698b2849a0d7de" translate="yes" xml:space="preserve">
          <source>Any exceptions thrown by &lt;code&gt;mutex()-&amp;gt;unlock()&lt;/code&gt;</source>
          <target state="translated">Любые исключения, &lt;code&gt;mutex()-&amp;gt;unlock()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="dde4d98fe163593f45905da9796164d4135b2aa5" translate="yes" xml:space="preserve">
          <source>Any exceptions thrown by &lt;code&gt;mutex()-&amp;gt;unlock_shared()&lt;/code&gt;</source>
          <target state="translated">Любые исключения, &lt;code&gt;mutex()-&amp;gt;unlock_shared()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="46aca186f0d5118e57ea1ec2d858f1e279a474ac" translate="yes" xml:space="preserve">
          <source>Any exceptions thrown by the copy constructors of &lt;code&gt;BinaryPredicate&lt;/code&gt; or &lt;code&gt;ForwardIt&lt;/code&gt;.</source>
          <target state="translated">Любые исключения, &lt;code&gt;BinaryPredicate&lt;/code&gt; конструкторами копирования BinaryPredicate или &lt;code&gt;ForwardIt&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4d35da87105417bd2f8dd9b5f22cbdf22b00eefe" translate="yes" xml:space="preserve">
          <source>Any exceptions thrown by.</source>
          <target state="translated">Любые исключения.</target>
        </trans-unit>
        <trans-unit id="ae8214fbedcd7b7b2c7806d56b17165dfe143da7" translate="yes" xml:space="preserve">
          <source>Any exceptions thrown from iterator operations or the element swap.</source>
          <target state="translated">Любые исключения,выбрасываемые из работы итератора или обмена элементами.</target>
        </trans-unit>
        <trans-unit id="39254fcd3fdb015be0ee13d463da04333fcb57d3" translate="yes" xml:space="preserve">
          <source>Any expression in parentheses is also classified as a primary expression: this guarantees that the parentheses have higher precedence than any operator. Parentheses preserve value, type, and value category.</source>
          <target state="translated">Любое выражение в круглых скобках также классифицируется как первичное:это гарантирует,что круглые скобки имеют больший приоритет,чем любой оператор.Круглые скобки сохраняют значение,тип и категорию значения.</target>
        </trans-unit>
        <trans-unit id="60455d87fc053fc9392b56ddecf2d39bad868244" translate="yes" xml:space="preserve">
          <source>Any instance of &lt;code&gt;optional&amp;lt;T&amp;gt;&lt;/code&gt; at any given point in time either</source>
          <target state="translated">Любой экземпляр &lt;code&gt;optional&amp;lt;T&amp;gt;&lt;/code&gt; в любой данный момент времени либо</target>
        </trans-unit>
        <trans-unit id="d6460fec33d2d5219b69f7a6eebb68fbfc2a92cb" translate="yes" xml:space="preserve">
          <source>Any lvalue or rvalue of this type can be swapped with any lvalue or rvalue of some other type, using unqualified function call &lt;code&gt;swap()&lt;/code&gt; in the context where both &lt;code&gt;&lt;a href=&quot;../algorithm/swap&quot;&gt;std::swap&lt;/a&gt;&lt;/code&gt; and the user-defined &lt;code&gt;swap()&lt;/code&gt;s are visible.</source>
          <target state="translated">Любое lvalue или rvalue этого типа можно поменять местами с любым lvalue или rvalue какого-либо другого типа, используя безусловный вызов функции &lt;code&gt;swap()&lt;/code&gt; в контексте, где видны как &lt;code&gt;&lt;a href=&quot;../algorithm/swap&quot;&gt;std::swap&lt;/a&gt;&lt;/code&gt; и определяемые пользователем &lt;code&gt;swap()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6091484d7bf355dd0cb949cd776657171718f832" translate="yes" xml:space="preserve">
          <source>Any member that could not be determined is set to &lt;code&gt;static_cast&amp;lt;uintmax_t&amp;gt;(-1)&lt;/code&gt;</source>
          <target state="translated">Любой элемент, который не может быть определен, имеет значение &lt;code&gt;static_cast&amp;lt;uintmax_t&amp;gt;(-1)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="74a03ddfcb26a95ca3f318466c08e7e95a815c27" translate="yes" xml:space="preserve">
          <source>Any number of access specifiers may appear within a class, in any order. Member access specifiers may affect class layout: the addresses of non-static &lt;a href=&quot;data_members#Layout&quot;&gt;data members&lt;/a&gt; are only guaranteed to increase in order of declaration for the members with the same access. For &lt;a href=&quot;../named_req/standardlayouttype&quot;&gt;StandardLayoutType&lt;/a&gt;, all non-static data members must have the same access.</source>
          <target state="translated">В классе может появляться любое количество спецификаторов доступа в любом порядке. Спецификаторы доступа к элементам могут влиять на макет класса: адреса элементов нестатических &lt;a href=&quot;data_members#Layout&quot;&gt;данных&lt;/a&gt; гарантированно увеличиваются только в порядке объявления для элементов с таким же доступом. Для &lt;a href=&quot;../named_req/standardlayouttype&quot;&gt;StandardLayoutType&lt;/a&gt; все нестатические члены данных должны иметь одинаковый доступ.</target>
        </trans-unit>
        <trans-unit id="a64cd75ae326e1b045aa2b1398be8083184efecf" translate="yes" xml:space="preserve">
          <source>Any of the following can be fully specialized:</source>
          <target state="translated">Любое из нижеследующего может быть полностью специализированным:</target>
        </trans-unit>
        <trans-unit id="437e7790370da61d174fe4d318acf7c074ede85b" translate="yes" xml:space="preserve">
          <source>Any of the following contexts requires class &lt;code&gt;T&lt;/code&gt; to be complete:</source>
          <target state="translated">Любой из следующих контекстов требует, чтобы класс &lt;code&gt;T&lt;/code&gt; был завершен:</target>
        </trans-unit>
        <trans-unit id="104d110bb41e8701d9fe7c539eb86ce87b612d21" translate="yes" xml:space="preserve">
          <source>Any of the following names declared at namespace scope have external linkage unless the namespace is unnamed or is contained within an unnamed namespace(since C++11):</source>
          <target state="translated">Любое из следующих имен,объявленных в пространстве имён,имеет внешнюю связь,если только пространство имён не является безымянным или не содержится в безымянном пространстве имён (начиная с C++11):</target>
        </trans-unit>
        <trans-unit id="5407990c5239cdd7bd6ef99bf9f9a20fd8e6527f" translate="yes" xml:space="preserve">
          <source>Any of the following names first declared at block scope have external linkage:</source>
          <target state="translated">Любое из следующих имен,впервые объявленных в блоке,имеет внешнюю связь:</target>
        </trans-unit>
        <trans-unit id="3238703010dee73fdace47f181589c27f2e4d0de" translate="yes" xml:space="preserve">
          <source>Any of the six two-way relational operators can be explicitly defaulted. A defaulted relational operator must have the return type &lt;code&gt;bool&lt;/code&gt;.</source>
          <target state="translated">Любой из шести двусторонних реляционных операторов может быть явно задан по умолчанию. Реляционный оператор по умолчанию должен иметь тип возврата &lt;code&gt;bool&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="904ac65505544c6e1c0c9dffcf96e6454f73cb6f" translate="yes" xml:space="preserve">
          <source>Any other combination of encoding prefixes may or may not be supported by the implementation. The result of such a concatenation is implementation-defined.</source>
          <target state="translated">Любая другая комбинация префиксов кодировок может поддерживаться или не поддерживаться реализацией.Результат такого конкатенирования определяется реализацией.</target>
        </trans-unit>
        <trans-unit id="0401aa15a157b543ba80abd41cb54281ed03d456" translate="yes" xml:space="preserve">
          <source>Any preprocessing tokens (macro constants or expressions) are permitted as arguments to &lt;code&gt;#include&lt;/code&gt;and &lt;code&gt;__has_include&lt;/code&gt;(since C++17) as long as they expand to a sequence of characters surrounded by &lt;code&gt;&amp;lt;&lt;/code&gt;&lt;code&gt;&amp;gt;&lt;/code&gt; or &lt;code&gt;&quot;&lt;/code&gt;&lt;code&gt;&quot;&lt;/code&gt;.</source>
          <target state="translated">Любые токены предварительной обработки (макро-константы или выражения) допускаются в качестве аргументов для &lt;code&gt;#include&lt;/code&gt; и &lt;code&gt;__has_include&lt;/code&gt; (начиная с C ++ 17), если они расширяются до последовательности символов, окруженных &lt;code&gt;&amp;lt;&lt;/code&gt; &lt;code&gt;&amp;gt;&lt;/code&gt; или &lt;code&gt;&quot;&lt;/code&gt; &lt;code&gt;&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="52919eaf1eb62c0854fdd694ccfd8a6c2a0705b3" translate="yes" xml:space="preserve">
          <source>Any preprocessing tokens (macro constants or expressions) are permitted as arguments to &lt;code&gt;#line&lt;/code&gt; as long as they expand to a valid decimal integer optionally following a valid character string.</source>
          <target state="translated">Любые токены предварительной обработки (макро константы или выражения) допускаются в качестве аргументов &lt;code&gt;#line&lt;/code&gt; , если они расширяются до действительного десятичного целого числа, необязательно следующего за допустимой символьной строкой.</target>
        </trans-unit>
        <trans-unit id="8a80f56d370810d05ed5b7f500aef83276b2b56b" translate="yes" xml:space="preserve">
          <source>Any random number engine is also a &lt;a href=&quot;uniformrandombitgenerator&quot;&gt;UniformRandomBitGenerator&lt;/a&gt;, and therefore may be plugged into any &lt;a href=&quot;../numeric/random&quot;&gt;random number distribution&lt;/a&gt; in order to obtain a random number (formally, a random variate).</source>
          <target state="translated">Любой механизм случайных чисел также является &lt;a href=&quot;uniformrandombitgenerator&quot;&gt;UniformRandomBitGenerator&lt;/a&gt; и, следовательно, может быть подключен к любому &lt;a href=&quot;../numeric/random&quot;&gt;распределению случайных чисел&lt;/a&gt; , чтобы получить случайное число (формально, случайное изменение).</target>
        </trans-unit>
        <trans-unit id="25328abef95d7bd06cd8ccb115014d680f4af1fb" translate="yes" xml:space="preserve">
          <source>Any reads or writes to a bitset that happen via a &lt;code&gt;std::bitset::reference&lt;/code&gt; potentially read or write to the entire underlying bitset.</source>
          <target state="translated">Любое чтение или запись в набор битов, которые происходят через &lt;code&gt;std::bitset::reference&lt;/code&gt; потенциально могут считывать или записывать весь базовый набор битов.</target>
        </trans-unit>
        <trans-unit id="ce62d6fd6228c7ed0a629a27ad487d906ba0cf6e" translate="yes" xml:space="preserve">
          <source>Any reads or writes to a vector that happen via a &lt;code&gt;&lt;a href=&quot;../vector&quot;&gt;std::vector&lt;/a&gt;&amp;lt;bool&amp;gt;::reference&lt;/code&gt; potentially read or write to the entire underlying vector.</source>
          <target state="translated">Любое чтение или запись в вектор, которые происходят через &lt;code&gt;&lt;a href=&quot;../vector&quot;&gt;std::vector&lt;/a&gt;&amp;lt;bool&amp;gt;::reference&lt;/code&gt; потенциально могут считывать или записывать весь базовый вектор.</target>
        </trans-unit>
        <trans-unit id="79d69f3522c40f28b11ac3de0d09461ee1623eb9" translate="yes" xml:space="preserve">
          <source>Any return value from the function is ignored. If the function throws an exception, &lt;code&gt;&lt;a href=&quot;../../error/terminate&quot;&gt;std::terminate&lt;/a&gt;&lt;/code&gt; is called. In order to pass return values or exceptions back to the calling thread, &lt;code&gt;&lt;a href=&quot;../promise&quot;&gt;std::promise&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../async&quot;&gt;std::async&lt;/a&gt;&lt;/code&gt; may be used.</source>
          <target state="translated">Любое возвращаемое значение из функции игнорируется. Если функция выдает исключение, вызывается &lt;code&gt;&lt;a href=&quot;../../error/terminate&quot;&gt;std::terminate&lt;/a&gt;&lt;/code&gt; . Чтобы передать возвращаемые значения или исключения обратно в вызывающий поток, можно использовать &lt;code&gt;&lt;a href=&quot;../promise&quot;&gt;std::promise&lt;/a&gt;&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;../async&quot;&gt;std::async&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="65591f30b00907d381312a521d81c7b5924c3ee3" translate="yes" xml:space="preserve">
          <source>Any shared state is released. &lt;code&gt;&lt;a href=&quot;valid&quot;&gt;valid()&lt;/a&gt;&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt; after a call to this method.</source>
          <target state="translated">Любое общее состояние освобождается. &lt;code&gt;&lt;a href=&quot;valid&quot;&gt;valid()&lt;/a&gt;&lt;/code&gt; - &lt;code&gt;false&lt;/code&gt; после вызова этого метода.</target>
        </trans-unit>
        <trans-unit id="594a9e7004e035507b2faafb30d5238be37f382a" translate="yes" xml:space="preserve">
          <source>Any statement can be</source>
          <target state="translated">Любое заявление может быть</target>
        </trans-unit>
        <trans-unit id="569389483a39353b7174754570a587d2d30d7a93" translate="yes" xml:space="preserve">
          <source>Any thread can potentially access any object in the program (objects with automatic and thread-local &lt;a href=&quot;storage_duration&quot;&gt;storage duration&lt;/a&gt; may still be accessed by another thread through a pointer or by reference).</source>
          <target state="translated">Любой поток может потенциально получить доступ к любому объекту в программе (объекты с автоматическим и локальным &lt;a href=&quot;storage_duration&quot;&gt;хранением&lt;/a&gt; потока могут все еще быть доступны для другого потока через указатель или по ссылке).</target>
        </trans-unit>
        <trans-unit id="c56361a71bf85ab91f9c4ec67339965aa7d1d832" translate="yes" xml:space="preserve">
          <source>Any thread that intends to wait on &lt;code&gt;std::condition_variable&lt;/code&gt; has to.</source>
          <target state="translated">Любой поток, который намеревается ждать на &lt;code&gt;std::condition_variable&lt;/code&gt; должен.</target>
        </trans-unit>
        <trans-unit id="a27b17e4a874eb86d62efa02b876f52b84cb2492" translate="yes" xml:space="preserve">
          <source>Any two objects with overlapping &lt;a href=&quot;lifetime&quot;&gt;lifetimes&lt;/a&gt; (that are not &lt;a href=&quot;bit_field&quot;&gt;bit fields&lt;/a&gt;) are guaranteed to have different addresses unless one of them is a subobject of another or provides storage for another, or if they are subobjects of different type within the same complete object, and one of them is a subobject of zero size.</source>
          <target state="translated">Любые два объекта с перекрывающимися &lt;a href=&quot;lifetime&quot;&gt;временами жизни&lt;/a&gt; (которые не являются &lt;a href=&quot;bit_field&quot;&gt;битовыми полями&lt;/a&gt; ) гарантированно будут иметь разные адреса, если только один из них не является субобъектом другого или не предоставляет хранилище для другого, или если они не являются субобъектами другого типа в одном и том же законченном объекте, и один из них подобъект нулевого размера.</target>
        </trans-unit>
        <trans-unit id="747805bfa6e2b47c753f371046684998f5739c7b" translate="yes" xml:space="preserve">
          <source>Any use of a pointer that became invalid in this manner, even copying the pointer value into another variable, is undefined behavior.</source>
          <target state="translated">Любое использование указателя,ставшее таким образом недействительным,даже копирование значения указателя в другую переменную,является неопределенным поведением.</target>
        </trans-unit>
        <trans-unit id="edb0075febb6c810a733225d843cfc260a841379" translate="yes" xml:space="preserve">
          <source>Any valid character except the double-quote &lt;code&gt;&quot;&lt;/code&gt;, backslash &lt;code&gt;\&lt;/code&gt;, or new-line character</source>
          <target state="translated">Любой допустимый символ, кроме двойной кавычки &lt;code&gt;&quot;&lt;/code&gt; , обратной косой черты &lt;code&gt;\&lt;/code&gt; или символа новой строки</target>
        </trans-unit>
        <trans-unit id="1b24babb1df893acf8a8a6efb01913ddf0bd9397" translate="yes" xml:space="preserve">
          <source>Appear in any type specifier, including decl-specifier-seq of &lt;a href=&quot;declarations&quot;&gt;declaration grammar&lt;/a&gt;, to specify constness or volatility of the object being declared or of the type being named.</source>
          <target state="translated">Появляются в любом спецификаторе типа, включая decl-specier-seq &lt;a href=&quot;declarations&quot;&gt;грамматики объявления&lt;/a&gt; , чтобы указать постоянство или изменчивость объявляемого объекта или названного типа.</target>
        </trans-unit>
        <trans-unit id="b3cea74b8699d0d5592fcdb76824dfd00b7a1900" translate="yes" xml:space="preserve">
          <source>Appears in a function declaration, enumeration declaration, or class declaration.</source>
          <target state="translated">Появляется в декларации функции,декларации перечисления или декларации класса.</target>
        </trans-unit>
        <trans-unit id="1f41b36bd2867522723d540cbaf10ea09210fdf2" translate="yes" xml:space="preserve">
          <source>Append to a file</source>
          <target state="translated">Добавить в файл</target>
        </trans-unit>
        <trans-unit id="185b3e5c1287dbe88e91911ebf09f0289a09ed1c" translate="yes" xml:space="preserve">
          <source>Append to file</source>
          <target state="translated">Добавить в файл</target>
        </trans-unit>
        <trans-unit id="7727ad0dfc1361a3b9a9f16594166faee13a49d3" translate="yes" xml:space="preserve">
          <source>Appends a &lt;code&gt;T&lt;/code&gt; constructed with &lt;code&gt;&lt;a href=&quot;../utility/forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;Args&amp;gt;(args)...&lt;/code&gt;</source>
          <target state="translated">Добавляет &lt;code&gt;T&lt;/code&gt; , созданный с помощью &lt;code&gt;&lt;a href=&quot;../utility/forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;Args&amp;gt;(args)...&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ffa8f7a6232502ff61b9f355b8192a149bda0bdd" translate="yes" xml:space="preserve">
          <source>Appends a byte string pointed to by &lt;code&gt;src&lt;/code&gt; to a byte string pointed to by &lt;code&gt;dest&lt;/code&gt;. At most &lt;code&gt;count&lt;/code&gt; characters are copied. The resulting byte string is null-terminated.</source>
          <target state="translated">Добавляет строку байтов, на которую указывает &lt;code&gt;src&lt;/code&gt; , к строке байтов, на которую указывает &lt;code&gt;dest&lt;/code&gt; . Максимальное &lt;code&gt;count&lt;/code&gt; символов копируются. Результирующая строка байтов заканчивается нулем.</target>
        </trans-unit>
        <trans-unit id="c89f8ba239ec205d14a709567d6066df8a0d1451" translate="yes" xml:space="preserve">
          <source>Appends a copy of &lt;code&gt;rv&lt;/code&gt;, possibly using move semantics</source>
          <target state="translated">Добавляет копию &lt;code&gt;rv&lt;/code&gt; , возможно, используя семантику перемещения</target>
        </trans-unit>
        <trans-unit id="93a15a35c8298c01ed0b17fc08d04c4607bfeb7b" translate="yes" xml:space="preserve">
          <source>Appends a copy of &lt;code&gt;t&lt;/code&gt;</source>
          <target state="translated">Добавляет копию &lt;code&gt;t&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0749406f25dc8bfe01326e6508ea40f8ccdfe8f5" translate="yes" xml:space="preserve">
          <source>Appends a copy of the character string pointed to by &lt;code&gt;src&lt;/code&gt; to the end of the character string pointed to by &lt;code&gt;dest&lt;/code&gt;. The character &lt;code&gt;src[0]&lt;/code&gt; replaces the null terminator at the end of &lt;code&gt;dest&lt;/code&gt;. The resulting byte string is null-terminated.</source>
          <target state="translated">Добавляет копию строки символов, на которую указывает &lt;code&gt;src&lt;/code&gt; , в конец строки символов, на которую указывает &lt;code&gt;dest&lt;/code&gt; . Символ &lt;code&gt;src[0]&lt;/code&gt; заменяет нулевой терминатор в конце &lt;code&gt;dest&lt;/code&gt; . Результирующая строка байтов заканчивается нулем.</target>
        </trans-unit>
        <trans-unit id="0f3b244f19389096a59b50d552c3a3947e4ec319" translate="yes" xml:space="preserve">
          <source>Appends a copy of the wide string pointed to by &lt;code&gt;src&lt;/code&gt; to the end of the wide string pointed to by &lt;code&gt;dest&lt;/code&gt;. The wide character &lt;code&gt;src[0]&lt;/code&gt; replaces the null terminator at the end of &lt;code&gt;dest&lt;/code&gt;. The resulting wide string is null-terminated.</source>
          <target state="translated">Добавляет копию широкой строки, на которую указывает &lt;code&gt;src&lt;/code&gt; , в конец широкой строки, на которую указывает &lt;code&gt;dest&lt;/code&gt; . Широкий символ &lt;code&gt;src[0]&lt;/code&gt; заменяет нулевой терминатор в конце &lt;code&gt;dest&lt;/code&gt; . Результирующая широкая строка заканчивается нулем.</target>
        </trans-unit>
        <trans-unit id="ee76f2e6383e182374a1ac158b3fb988871f2017" translate="yes" xml:space="preserve">
          <source>Appends a new element to the end of the container. The element is constructed through &lt;code&gt;&lt;a href=&quot;../../memory/allocator_traits/construct&quot;&gt;std::allocator_traits::construct&lt;/a&gt;&lt;/code&gt;, which typically uses placement-new to construct the element in-place at the location provided by the container. The arguments &lt;code&gt;args...&lt;/code&gt; are forwarded to the constructor as &lt;code&gt;&lt;a href=&quot;../../utility/forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;Args&amp;gt;(args)...&lt;/code&gt;.</source>
          <target state="translated">Добавляет новый элемент в конец контейнера. Элемент создается с помощью &lt;code&gt;&lt;a href=&quot;../../memory/allocator_traits/construct&quot;&gt;std::allocator_traits::construct&lt;/a&gt;&lt;/code&gt; , который обычно использует place-new для создания элемента на месте в местоположении, предоставленном контейнером. Аргументы &lt;code&gt;args...&lt;/code&gt; пересылаются конструктору &lt;code&gt;&lt;a href=&quot;../../utility/forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;Args&amp;gt;(args)...&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3769354c56bdf441401d30ffbfd485d11afed226" translate="yes" xml:space="preserve">
          <source>Appends additional characters to the string.</source>
          <target state="translated">Добавляет дополнительные символы к строке.</target>
        </trans-unit>
        <trans-unit id="9435c7778f8168db6ddee793e51647858e33337b" translate="yes" xml:space="preserve">
          <source>Appends at most &lt;code&gt;count&lt;/code&gt; wide characters from the wide string pointed to by &lt;code&gt;src&lt;/code&gt; to the end of the character string pointed to by &lt;code&gt;dest&lt;/code&gt;, stopping if the null terminator is copied. The wide character &lt;code&gt;src[0]&lt;/code&gt; replaces the null terminator at the end of &lt;code&gt;dest&lt;/code&gt;. The null terminator is always appended in the end (so the maximum number of wide characters the function may write is &lt;code&gt;count+1&lt;/code&gt;).</source>
          <target state="translated">Добавляет самое большее &lt;code&gt;count&lt;/code&gt; широких символов из широкой строки, на которую указывает &lt;code&gt;src&lt;/code&gt; , в конец строки символов, на которую указывает &lt;code&gt;dest&lt;/code&gt; , останавливается, если копируется нулевой терминатор. Широкий символ &lt;code&gt;src[0]&lt;/code&gt; заменяет нулевой терминатор в конце &lt;code&gt;dest&lt;/code&gt; . Терминатор NULL всегда добавляется в конце (поэтому максимальное число широких символов, которые может записать функция, равно &lt;code&gt;count+1&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="616d6d1b2db8c5cbc5b78e6729f280f6ef9cde21" translate="yes" xml:space="preserve">
          <source>Appends the character &lt;code&gt;c&lt;/code&gt; to the output character sequence.</source>
          <target state="translated">Добавляет символ &lt;code&gt;c&lt;/code&gt; к выходной последовательности символов.</target>
        </trans-unit>
        <trans-unit id="97e86c02631fb97ad63c305dc2c6744a765ce0c5" translate="yes" xml:space="preserve">
          <source>Appends the character &lt;code&gt;c&lt;/code&gt; to the put area of the buffer, reallocating if possible.</source>
          <target state="translated">Добавляет символ &lt;code&gt;c&lt;/code&gt; в область размещения буфера, перераспределяя, если это возможно.</target>
        </trans-unit>
        <trans-unit id="532328072ae734b050324e7bd55974ecc3a7470f" translate="yes" xml:space="preserve">
          <source>Appends the given character &lt;code&gt;ch&lt;/code&gt; to the end of the string.</source>
          <target state="translated">Добавляет данный символ &lt;code&gt;ch&lt;/code&gt; в конец строки.</target>
        </trans-unit>
        <trans-unit id="cfc483d3db69eff6dcd82b004d3786722b9a1849" translate="yes" xml:space="preserve">
          <source>Appends the given element &lt;code&gt;value&lt;/code&gt; to the end of the container.</source>
          <target state="translated">Дописывает данный элемент &lt;code&gt;value&lt;/code&gt; до конца контейнера.</target>
        </trans-unit>
        <trans-unit id="d2c0fb94e5cddaf445eca7c3640f9ada9fb6e2a7" translate="yes" xml:space="preserve">
          <source>Applied to</source>
          <target state="translated">Применимо к</target>
        </trans-unit>
        <trans-unit id="cbd47fe22d148dd069a031976318ab7fb6d631c4" translate="yes" xml:space="preserve">
          <source>Applies compound assignment operators to each element in the numeric array.</source>
          <target state="translated">Применяет составные операторы присваивания к каждому элементу числового массива.</target>
        </trans-unit>
        <trans-unit id="bc6e0092dfd47ac0f36260b8d91a3704f6cc8726" translate="yes" xml:space="preserve">
          <source>Applies lvalue-to-rvalue, array-to-pointer, and function-to-pointer implicit conversions to the type &lt;code&gt;T&lt;/code&gt;, removes cv-qualifiers, and defines the resulting type as the member typedef &lt;code&gt;type&lt;/code&gt;. Formally:</source>
          <target state="translated">Применяет неявные преобразования lvalue-to-rvalue, array-to-pointer и function-to-pointer к типу &lt;code&gt;T&lt;/code&gt; , удаляет cv-квалификаторы и определяет результирующий тип как &lt;code&gt;type&lt;/code&gt; typedef члена . Формально:</target>
        </trans-unit>
        <trans-unit id="71f4ff319120444a2809431ede654e171b067641" translate="yes" xml:space="preserve">
          <source>Applies the corresponding operation to the referred elements and the elements of &lt;code&gt;other&lt;/code&gt;.</source>
          <target state="translated">Применяет соответствующую операцию к указанным элементам и элементам &lt;code&gt;other&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="27d8e4e4d1d2e00786c12ccc2c42604642524bdd" translate="yes" xml:space="preserve">
          <source>Applies the unary operators to the year value.</source>
          <target state="translated">Применяет унарных операторов к стоимости года.</target>
        </trans-unit>
        <trans-unit id="a0cc3e98fe133b6a125be7a1095a1e4722d59951" translate="yes" xml:space="preserve">
          <source>Applies the visitor &lt;code&gt;vis&lt;/code&gt; to the variants &lt;code&gt;vars&lt;/code&gt;.</source>
          <target state="translated">Относится посетитель по &lt;code&gt;vis&lt;/code&gt; к вариантам &lt;code&gt;vars&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="767013b70c83389088a9d12acdf6717a821be569" translate="yes" xml:space="preserve">
          <source>Applies to the name being declared in a function declaration, which must be the first declaration of the function.</source>
          <target state="translated">Применяется к имени,объявленному в объявлении функции,которое должно быть первым объявлением функции.</target>
        </trans-unit>
        <trans-unit id="0463466b4fbb2abaeda54896e7f772d38769d910" translate="yes" xml:space="preserve">
          <source>Applies to the name being declared in the declaration of a non-static data member that's not a bit field.</source>
          <target state="translated">Применяется к имени,объявленному в декларации нестатического члена данных,которое не является битовым полем.</target>
        </trans-unit>
        <trans-unit id="c80f073f7430ca362ef718e10efb9033f924c369" translate="yes" xml:space="preserve">
          <source>Applies unary operators to each element in the numeric array.</source>
          <target state="translated">Применяет одинарные операторы к каждому элементу числового массива.</target>
        </trans-unit>
        <trans-unit id="4b03880d31fcc803c8ff4f90e7d09f01a683bd9e" translate="yes" xml:space="preserve">
          <source>Apply binary operators to each element of two valarrays, or a valarray and a value.</source>
          <target state="translated">Применяйте двоичные операторы к каждому элементу двух валаров,или валаррей и значение.</target>
        </trans-unit>
        <trans-unit id="68fcd04d7e11c3d0bcd63b86035531ef6f69e2ba" translate="yes" xml:space="preserve">
          <source>Applying &lt;a href=&quot;cv&quot;&gt;cv-qualifiers&lt;/a&gt; to an array type (through typedef or template type manipulation) applies the qualifiers to the element type, but any array type whose elements are of cv-qualified type is considered to have the same cv-qualification.</source>
          <target state="translated">Применение &lt;a href=&quot;cv&quot;&gt;квалификаторов cv&lt;/a&gt; к типу массива (с помощью typedef или манипуляции с типами шаблонов) применяет квалификаторы к типу элемента, но любой тип массива, элементы которого относятся к cv-квалифицированному типу, считается имеющим ту же квалификацию cv.</target>
        </trans-unit>
        <trans-unit id="4da3e84107ea6402ad05595526acce55c364845f" translate="yes" xml:space="preserve">
          <source>Approximate</source>
          <target state="translated">Approximate</target>
        </trans-unit>
        <trans-unit id="09d845a999b4fbc8adffb5aaf317f7912e88b018" translate="yes" xml:space="preserve">
          <source>Approximately (last-first)log(middle-first) applications of &lt;code&gt;cmp&lt;/code&gt;.</source>
          <target state="translated">Примерно (последний-первый) журнал (средний-первый) приложений &lt;code&gt;cmp&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="784f9dcf68eaea0702498dee303485e97ffb2719" translate="yes" xml:space="preserve">
          <source>Approximately &lt;code&gt;N log N&lt;/code&gt; comparisons, where N is the number of elements in the list.</source>
          <target state="translated">Примерно &lt;code&gt;N log N&lt;/code&gt; сравнений, где N - количество элементов в списке.</target>
        </trans-unit>
        <trans-unit id="263ef14d73529c347640508e4c1ee9f8d38a5463" translate="yes" xml:space="preserve">
          <source>Arbitrary variable name</source>
          <target state="translated">Имя произвольной переменной</target>
        </trans-unit>
        <trans-unit id="e35b07545cf742633f94fa34acab673ea47df2c2" translate="yes" xml:space="preserve">
          <source>Args&lt;code&gt;...&lt;/code&gt;args(optional)</source>
          <target state="translated">Args&lt;code&gt;...&lt;/code&gt;args(optional)</target>
        </trans-unit>
        <trans-unit id="ce5e5792e97fe5c7861d6ae9b29cf5a25cc0e70a" translate="yes" xml:space="preserve">
          <source>Argument</source>
          <target state="translated">Argument</target>
        </trans-unit>
        <trans-unit id="b8bc95515466bfd1d5820bfea495f62a49211b2b" translate="yes" xml:space="preserve">
          <source>Argument list too long</source>
          <target state="translated">Слишком длинный список аргументов</target>
        </trans-unit>
        <trans-unit id="def2bf62b424e602e225d5df7086bbc94649ceb1" translate="yes" xml:space="preserve">
          <source>Argument type</source>
          <target state="translated">Тип аргумента</target>
        </trans-unit>
        <trans-unit id="2b55cecef5202fd86c073a0e44fac351439665bc" translate="yes" xml:space="preserve">
          <source>Argument-Dependent Lookup</source>
          <target state="translated">Аргументированный поиск</target>
        </trans-unit>
        <trans-unit id="81b2c9c824baa8fa05c1678ad66e87db4cff58c7" translate="yes" xml:space="preserve">
          <source>Argument-dependent lookup</source>
          <target state="translated">поиск в зависимости от аргументов</target>
        </trans-unit>
        <trans-unit id="ae0999c00edb7da81dc23e3610fb98d912a734a5" translate="yes" xml:space="preserve">
          <source>Argument-dependent lookup makes it possible to use operators defined in a different namespace. Example:</source>
          <target state="translated">Аргументозависимый поиск позволяет использовать операторы,определенные в другом пространстве имён.Пример:</target>
        </trans-unit>
        <trans-unit id="48fb1df93f3daa01db173d8e4c1d5be0610f1c51" translate="yes" xml:space="preserve">
          <source>Argument-dependent lookup, also known as ADL, or Koenig lookup, is the set of rules for looking up the unqualified function names in &lt;a href=&quot;operator_other&quot;&gt;function-call expressions&lt;/a&gt;, including implicit function calls to &lt;a href=&quot;operators&quot;&gt;overloaded operators&lt;/a&gt;. These function names are looked up in the namespaces of their arguments in addition to the scopes and namespaces considered by the usual &lt;a href=&quot;lookup&quot;&gt;unqualified name lookup&lt;/a&gt;.</source>
          <target state="translated">Поиск, зависящий от аргументов, также известный как ADL, или поиск Кенига, представляет собой набор правил для поиска неквалифицированных имен &lt;a href=&quot;operator_other&quot;&gt;функций в выражениях вызовов функций&lt;/a&gt; , включая неявные вызовы функций для &lt;a href=&quot;operators&quot;&gt;перегруженных операторов&lt;/a&gt; . Эти имена функций ищутся в пространствах имен их аргументов в дополнение к областям и пространствам имен, рассматриваемым при обычном &lt;a href=&quot;lookup&quot;&gt;поиске безоговорочного имени&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="45f053dc732762c8c17889da40821807b746247b" translate="yes" xml:space="preserve">
          <source>Arithmetic</source>
          <target state="translated">Arithmetic</target>
        </trans-unit>
        <trans-unit id="6e926e8a15212af2e7d9e38d85b6ff5994219acc" translate="yes" xml:space="preserve">
          <source>Arithmetic comparison operators</source>
          <target state="translated">операторы арифметического сравнения</target>
        </trans-unit>
        <trans-unit id="1fc0feb17ac2848b9f01591a445a367739c560da" translate="yes" xml:space="preserve">
          <source>Arithmetic operations</source>
          <target state="translated">арифметические действия</target>
        </trans-unit>
        <trans-unit id="d077356b7b5076ff62409f2fbd19527762e29c71" translate="yes" xml:space="preserve">
          <source>Arithmetic operators</source>
          <target state="translated">арифметические операторы</target>
        </trans-unit>
        <trans-unit id="ebc8c7691d9a7980369acc634bd9267bcb2e5a9e" translate="yes" xml:space="preserve">
          <source>Arithmetic operators are overloaded for many standard library types.</source>
          <target state="translated">Арифметические операторы перегружены для многих стандартных типов библиотек.</target>
        </trans-unit>
        <trans-unit id="aa83af8c4fc56c37be9ed278bb37886d698b573b" translate="yes" xml:space="preserve">
          <source>Arithmetic type capable of representing the process running time of implementation-defined range and precision.</source>
          <target state="translated">Арифметический тип,способный представлять время выполнения процесса в заданном диапазоне и точность.</target>
        </trans-unit>
        <trans-unit id="8067dbf084d6b81e05c895b3fb91dd4530c4b57b" translate="yes" xml:space="preserve">
          <source>Arithmetic type capable of representing times.</source>
          <target state="translated">Арифметический тип,способный изображать времена.</target>
        </trans-unit>
        <trans-unit id="3a96c27ea8acc41f84ccf2e2e957611cc9d4cd07" translate="yes" xml:space="preserve">
          <source>Arithmetic types</source>
          <target state="translated">арифметические типы</target>
        </trans-unit>
        <trans-unit id="d06d9a0dfd0ee03ff5118df0f82845bdc8d2b4bc" translate="yes" xml:space="preserve">
          <source>Arithmetic types are the built-in types for which the &lt;a href=&quot;../language/operator_arithmetic&quot;&gt;arithmetic operators&lt;/a&gt; (+, -, *, /) are defined (possibly in combination with the usual arithmetic conversions).</source>
          <target state="translated">Арифметические типы - это встроенные типы, для которых определены &lt;a href=&quot;../language/operator_arithmetic&quot;&gt;арифметические операторы&lt;/a&gt; (+, -, *, /) (возможно, в сочетании с обычными арифметическими преобразованиями).</target>
        </trans-unit>
        <trans-unit id="7a080955122add0c1c12baf72d49c4257bf60020" translate="yes" xml:space="preserve">
          <source>Array &lt;a href=&quot;value_category&quot;&gt;xvalues&lt;/a&gt; may be formed directly by accessing an array member of a class rvalue or by using &lt;code&gt;std::move&lt;/code&gt; or another cast or function call that returns an rvalue reference.</source>
          <target state="translated">Массив &lt;a href=&quot;value_category&quot;&gt;xvalues&lt;/a&gt; может быть сформирован непосредственно путем доступа к члену массива из класса RValue или с помощью &lt;code&gt;std::move&lt;/code&gt; или другая литой или вызов функции , которая возвращает ссылку Rvalue.</target>
        </trans-unit>
        <trans-unit id="ee291b10c5dda44d0a9e99115603b2cd5af533b7" translate="yes" xml:space="preserve">
          <source>Array I/O implementations</source>
          <target state="translated">Реализации входов/выходов из массивов</target>
        </trans-unit>
        <trans-unit id="1fac704c74c4d1cd597a85741e932ee6a1399565" translate="yes" xml:space="preserve">
          <source>Array allocation may supply unspecified overhead, which may vary from one call to new to the next. The pointer returned by the new-expression will be offset by that value from the pointer returned by the allocation function. Many implementations use the array overhead to store the number of objects in the array which is used by the &lt;a href=&quot;delete&quot;&gt;&lt;code&gt;delete[]&lt;/code&gt;&lt;/a&gt; expression to call the correct number of destructors. In addition, if the new-expression is used to allocate an array of &lt;code&gt;char&lt;/code&gt;, &lt;code&gt;unsigned char&lt;/code&gt;, or &lt;a href=&quot;../types/byte&quot;&gt;&lt;code&gt;std::byte&lt;/code&gt;&lt;/a&gt;, it may request additional memory from the allocation function if necessary to guarantee correct alignment of objects of all types no larger than the requested array size, if one is later placed into the allocated array.</source>
          <target state="translated">Распределение массива может предоставлять неопределенные накладные расходы, которые могут варьироваться от одного вызова к новому на следующий. Указатель, возвращаемый выражением new, будет смещен на это значение от указателя, возвращенного функцией выделения. Многие реализации используют издержки массива для хранения количества объектов в массиве, которое используется выражением &lt;a href=&quot;delete&quot;&gt; &lt;code&gt;delete[]&lt;/code&gt; &lt;/a&gt; для вызова правильного числа деструкторов. Кроме того, если выражение new используется для выделения массива &lt;code&gt;char&lt;/code&gt; , &lt;code&gt;unsigned char&lt;/code&gt; или &lt;a href=&quot;../types/byte&quot;&gt; &lt;code&gt;std::byte&lt;/code&gt; &lt;/a&gt; , он может запросить дополнительную память из функции выделения, если необходимо гарантировать правильное выравнивание объектов всех типов, не превышающих запрашиваемый размер массива, если он позже помещен в выделенный массив.</target>
        </trans-unit>
        <trans-unit id="19dbfbf61f5e11cabe0b3e7c939480487b44e48e" translate="yes" xml:space="preserve">
          <source>Array and function types may be written in a template declaration, but they are automatically replaced by pointer to object and pointer to function as appropriate.</source>
          <target state="translated">Типы массивов и функций могут быть записаны в шаблонное объявление,но они автоматически заменяются указателем на объект и указателем на функцию соответствующим образом.</target>
        </trans-unit>
        <trans-unit id="3fb125cc9e54d7ed417b90f1b586cad673b24cc3" translate="yes" xml:space="preserve">
          <source>Array declaration</source>
          <target state="translated">Массивная декларация</target>
        </trans-unit>
        <trans-unit id="fa11a0bed9bf8be4aa754cdcc96dcd83617299af" translate="yes" xml:space="preserve">
          <source>Array rvalues</source>
          <target state="translated">Массивные значения</target>
        </trans-unit>
        <trans-unit id="2e4177a778e8e0d4d36e9396b01d0e6f4341b30c" translate="yes" xml:space="preserve">
          <source>Array subscript operator</source>
          <target state="translated">Массивный абонентский оператор</target>
        </trans-unit>
        <trans-unit id="66b8cc3bf902fd9199bad14788d8e22184391a03" translate="yes" xml:space="preserve">
          <source>Array to pointer conversion</source>
          <target state="translated">Преобразование массива в указатель</target>
        </trans-unit>
        <trans-unit id="c0025fd7b0d4a983ce2fa2e1c1b60d86f77fcd32" translate="yes" xml:space="preserve">
          <source>Array version, &lt;code&gt;unique_ptr&amp;lt;T[]&amp;gt;&lt;/code&gt;</source>
          <target state="translated">Версия массива, &lt;code&gt;unique_ptr&amp;lt;T[]&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0d338acd11db4278249951233a983d4b787dc89b" translate="yes" xml:space="preserve">
          <source>Array-oriented access</source>
          <target state="translated">Массивно-ориентированный доступ</target>
        </trans-unit>
        <trans-unit id="78c423e7d10bf3348df8d43bf148cb5827744e5a" translate="yes" xml:space="preserve">
          <source>Array-to-pointer and function-to-pointer conversions are never applied to the value calculated by a discarded-value expression. The lvalue-to-rvalue conversion is applied if and only if the expression is a &lt;a href=&quot;cv&quot;&gt;volatile-qualified&lt;/a&gt; glvalue and has one of the following forms (built-in meaning required, possibly parenthesized).</source>
          <target state="translated">Преобразования массив-указатель и функция-указатель никогда не применяются к значению, вычисленному выражением отброшенного значения. Преобразование lvalue-to-rvalue применяется тогда и только тогда, когда выражение является glvalue с &lt;a href=&quot;cv&quot;&gt;квалификацией&lt;/a&gt; volatile и имеет одну из следующих форм (требуется встроенное значение, возможно заключенное в скобки).</target>
        </trans-unit>
        <trans-unit id="e8874168e3c1df960a01e93b0e01fe86fb6ae2dc" translate="yes" xml:space="preserve">
          <source>Array-to-pointer decay</source>
          <target state="translated">распад массива на указатель</target>
        </trans-unit>
        <trans-unit id="b90cc9bfd23567a2ff5ba1f00e7c63ca6da8755e" translate="yes" xml:space="preserve">
          <source>Arrays</source>
          <target state="translated">Arrays</target>
        </trans-unit>
        <trans-unit id="1376db7bd12df19420984d74ce62a991f95e82b5" translate="yes" xml:space="preserve">
          <source>Arrays can be constructed from any &lt;a href=&quot;types&quot;&gt;fundamental type&lt;/a&gt; (except &lt;code&gt;void&lt;/code&gt;), &lt;a href=&quot;pointer&quot;&gt;pointers&lt;/a&gt;, &lt;a href=&quot;pointer&quot;&gt;pointers to members&lt;/a&gt;, &lt;a href=&quot;classes&quot;&gt;classes&lt;/a&gt;, &lt;a href=&quot;enum&quot;&gt;enumerations&lt;/a&gt;, or from other arrays (in which case the array is said to be multi-dimensional).</source>
          <target state="translated">Массивы могут быть созданы из любого &lt;a href=&quot;types&quot;&gt;фундаментального типа&lt;/a&gt; (кроме &lt;code&gt;void&lt;/code&gt; ), &lt;a href=&quot;pointer&quot;&gt;указателей&lt;/a&gt; , &lt;a href=&quot;pointer&quot;&gt;указателей на члены&lt;/a&gt; , &lt;a href=&quot;classes&quot;&gt;классов&lt;/a&gt; , &lt;a href=&quot;enum&quot;&gt;перечислений&lt;/a&gt; или других массивов (в этом случае массив называется многомерным).</target>
        </trans-unit>
        <trans-unit id="fb1e79ec0101099cc8a59bf9fd30eb4aa15f99db" translate="yes" xml:space="preserve">
          <source>Arrays of character types (&lt;code&gt;char&lt;/code&gt;, &lt;code&gt;signed char&lt;/code&gt;, &lt;code&gt;unsigned char&lt;/code&gt;, &lt;code&gt;char8_t&lt;/code&gt;, &lt;code&gt;char16_t&lt;/code&gt;, &lt;code&gt;char32_t&lt;/code&gt;, &lt;code&gt;wchar_t&lt;/code&gt;) can be initialized from an appropriate &lt;a href=&quot;string_literal&quot;&gt;string literal&lt;/a&gt;, optionally enclosed in braces. Successive characters of the string literal (which includes the implicit terminating null character) initialize the elements of the array. If the size of the array is specified and it is larger than the number of characters in the string literal, the remaining characters are zero-initialized.</source>
          <target state="translated">Массивы типов символов ( &lt;code&gt;char&lt;/code&gt; , &lt;code&gt;signed char&lt;/code&gt; , &lt;code&gt;unsigned char&lt;/code&gt; , &lt;code&gt;char8_t&lt;/code&gt; , &lt;code&gt;char16_t&lt;/code&gt; , &lt;code&gt;char32_t&lt;/code&gt; , &lt;code&gt;wchar_t&lt;/code&gt; ) могут быть инициализированы из соответствующего &lt;a href=&quot;string_literal&quot;&gt;строкового литерала&lt;/a&gt; , необязательно заключены в скобках. Последовательные символы строкового литерала (который включает в себя неявный завершающий нулевой символ) инициализируют элементы массива. Если указан размер массива, превышающий количество символов в строковом литерале, остальные символы инициализируются нулями.</target>
        </trans-unit>
        <trans-unit id="1dad2511cb3cf432d9a23097f1bff2b6f8637192" translate="yes" xml:space="preserve">
          <source>Arrays of unknown bound</source>
          <target state="translated">Массивы неизвестных границ</target>
        </trans-unit>
        <trans-unit id="5cf5ca03aab0034cdf7ff385d06729a538f15f36" translate="yes" xml:space="preserve">
          <source>As a rule, iterators to an array are never invalidated throughout the lifetime of the array. One should take note, however, that during &lt;a href=&quot;array/swap&quot;&gt;swap&lt;/a&gt;, the iterator will continue to point to the same array element, and will thus change its value.</source>
          <target state="translated">Как правило, итераторы массива никогда не становятся недействительными в течение всего времени жизни массива. Следует отметить, однако, что во время &lt;a href=&quot;array/swap&quot;&gt;перестановки&lt;/a&gt; итератор будет продолжать указывать на тот же элемент массива и, таким образом, будет изменять его значение.</target>
        </trans-unit>
        <trans-unit id="614cc5be51bd0fccb31d1106fa599930fafe0ca5" translate="yes" xml:space="preserve">
          <source>As a special case, &lt;code&gt;&lt;a href=&quot;../utility/pair&quot;&gt;std::pair&lt;/a&gt;&lt;/code&gt; is treated as a uses-allocator type even though &lt;code&gt;std::uses_allocator&lt;/code&gt; is false for pairs (unlike e.g. &lt;code&gt;&lt;a href=&quot;../utility/tuple&quot;&gt;std::tuple&lt;/a&gt;&lt;/code&gt;): see pair-specific overloads of &lt;code&gt;std::polymoprhic_allocator::construct&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;scoped_allocator_adaptor/construct&quot;&gt;std::scoped_allocator_adaptor::construct&lt;/a&gt;&lt;/code&gt;(until C++20)&lt;code&gt;std::uses_allocator_construction_args&lt;/code&gt;(since C++20)</source>
          <target state="translated">Как особый случай, &lt;code&gt;&lt;a href=&quot;../utility/pair&quot;&gt;std::pair&lt;/a&gt;&lt;/code&gt; обрабатывается как тип использования-распределителя, даже если &lt;code&gt;std::uses_allocator&lt;/code&gt; имеет значение false для пар (в отличие, например, от &lt;code&gt;&lt;a href=&quot;../utility/tuple&quot;&gt;std::tuple&lt;/a&gt;&lt;/code&gt; ): см. Специфичные для пары перегрузки &lt;code&gt;std::polymoprhic_allocator::construct&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;scoped_allocator_adaptor/construct&quot;&gt;std::scoped_allocator_adaptor::construct&lt;/a&gt;&lt;/code&gt; (до C ++ 20) &lt;code&gt;std::uses_allocator_construction_args&lt;/code&gt; (начиная с C ++ 20)</target>
        </trans-unit>
        <trans-unit id="363835804f732ae2a7518afa5d70079b8f827fb9" translate="yes" xml:space="preserve">
          <source>As a special case, objects can be created in arrays of &lt;code&gt;unsigned char&lt;/code&gt; or &lt;a href=&quot;../types/byte&quot;&gt;&lt;code&gt;std::byte&lt;/code&gt;&lt;/a&gt; (in which case it is said that the array</source>
          <target state="translated">Как особый случай, объекты могут быть созданы в массивах &lt;code&gt;unsigned char&lt;/code&gt; или &lt;a href=&quot;../types/byte&quot;&gt; &lt;code&gt;std::byte&lt;/code&gt; &lt;/a&gt; (в этом случае говорят, что массив</target>
        </trans-unit>
        <trans-unit id="f52724b9ca0301f1d8b93282821a00b036f2d526" translate="yes" xml:space="preserve">
          <source>As above, with &lt;code&gt;eq=key_equal()&lt;/code&gt;</source>
          <target state="translated">Как и выше, с &lt;code&gt;eq=key_equal()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8531b085109b3b3d1377cabf79180d8d388c7ee8" translate="yes" xml:space="preserve">
          <source>As above, with &lt;code&gt;hf=hasher()&lt;/code&gt;</source>
          <target state="translated">Как и выше, с &lt;code&gt;hf=hasher()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="bda77b28e4ca321fc30d59f16b97fba79dbe7581" translate="yes" xml:space="preserve">
          <source>As above, with an unspecified number of buckets</source>
          <target state="translated">Как и выше,с неопределённым количеством ведер</target>
        </trans-unit>
        <trans-unit id="cb4232ed7041310ecc9217dc4e9b0dad693d0afb" translate="yes" xml:space="preserve">
          <source>As an example of the &quot;supported by the implementation&quot; requirement, POSIX function &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/posix_memalign.html&quot;&gt;posix_memalign&lt;/a&gt; accepts any &lt;code&gt;alignment&lt;/code&gt; that is a power of two and a multiple of &lt;code&gt;sizeof(void*)&lt;/code&gt;, and POSIX-based implementations of &lt;code&gt;aligned_alloc&lt;/code&gt; inherit this requirements.</source>
          <target state="translated">В качестве примера требования &amp;laquo;поддерживается реализацией&amp;raquo;, функция POSIX &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/posix_memalign.html&quot;&gt;posix_memalign&lt;/a&gt; принимает любое &lt;code&gt;alignment&lt;/code&gt; которое является степенью двойки и кратным &lt;code&gt;sizeof(void*)&lt;/code&gt; , и основанные на POSIX реализации &lt;code&gt;aligned_alloc&lt;/code&gt; наследуют эти требования.</target>
        </trans-unit>
        <trans-unit id="0a94bbdb2793055475b5f04a01eddcc7f88ab6b4" translate="yes" xml:space="preserve">
          <source>As an example of the &quot;supported by the implementation&quot; requirement, POSIX function &lt;a href=&quot;https://pubs.opengroup.org/onlinepubs/9699919799/functions/posix_memalign.html&quot;&gt;posix_memalign&lt;/a&gt; accepts any &lt;code&gt;alignment&lt;/code&gt; that is a power of two and a multiple of &lt;code&gt;sizeof(void*)&lt;/code&gt;, and POSIX-based implementations of &lt;code&gt;aligned_alloc&lt;/code&gt; inherit this requirements.</source>
          <target state="translated">В качестве примера требования &amp;laquo;поддерживается реализацией&amp;raquo; функция POSIX &lt;a href=&quot;https://pubs.opengroup.org/onlinepubs/9699919799/functions/posix_memalign.html&quot;&gt;posix_memalign&lt;/a&gt; принимает любое &lt;code&gt;alignment&lt;/code&gt; которое является степенью двойки и кратным &lt;code&gt;sizeof(void*)&lt;/code&gt; , а реализации функции &lt;code&gt;aligned_alloc&lt;/code&gt; основе POSIX наследуют это требование.</target>
        </trans-unit>
        <trans-unit id="6dabb20bee356347a72de2e02dded113dd51368a" translate="yes" xml:space="preserve">
          <source>As any other function, a destructor may terminate by throwing an &lt;a href=&quot;exceptions&quot;&gt;exception&lt;/a&gt;(this usually requires it to be explicitly declared &lt;code&gt;noexcept(false)&lt;/code&gt;)(since C++11), however if this destructor happens to be called during &lt;a href=&quot;throw&quot;&gt;stack unwinding&lt;/a&gt;, &lt;code&gt;&lt;a href=&quot;../error/terminate&quot;&gt;std::terminate&lt;/a&gt;&lt;/code&gt; is called instead.</source>
          <target state="translated">Как и любая другая функция, деструктор может завершить работу, выдав &lt;a href=&quot;exceptions&quot;&gt;исключение&lt;/a&gt; (для этого обычно требуется явное объявление &lt;code&gt;noexcept(false)&lt;/code&gt; ) (начиная с C ++ 11), однако, если этот деструктор вызывается при &lt;a href=&quot;throw&quot;&gt;разматывании стека&lt;/a&gt; , &lt;code&gt;&lt;a href=&quot;../error/terminate&quot;&gt;std::terminate&lt;/a&gt;&lt;/code&gt; вместо этого вызывается терминация .</target>
        </trans-unit>
        <trans-unit id="7a66bb24008dddd2f1f26becdeebf04e56826247" translate="yes" xml:space="preserve">
          <source>As defined above.</source>
          <target state="translated">Как определено выше.</target>
        </trans-unit>
        <trans-unit id="a534c811c2d3571f2ae27f157ef19b52a844ad05" translate="yes" xml:space="preserve">
          <source>As described in &lt;a href=&quot;../../named_req/callable&quot;&gt;Callable&lt;/a&gt;, when invoking a pointer to non-static member function or pointer to non-static data member, the first argument has to be a reference or pointer (including, possibly, smart pointer such as &lt;code&gt;&lt;a href=&quot;../../memory/shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../../memory/unique_ptr&quot;&gt;std::unique_ptr&lt;/a&gt;&lt;/code&gt;) to an object whose member will be accessed.</source>
          <target state="translated">Как описано в &lt;a href=&quot;../../named_req/callable&quot;&gt;Callable&lt;/a&gt; , при вызове указателя на нестатическую функцию-член или указателя на нестатический элемент данных первый аргумент должен быть ссылкой или указателем (включая, возможно, умный указатель, такой как &lt;code&gt;&lt;a href=&quot;../../memory/shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;../../memory/unique_ptr&quot;&gt;std::unique_ptr&lt;/a&gt;&lt;/code&gt; ) к объекту, член которого будет доступен.</target>
        </trans-unit>
        <trans-unit id="9ee2578ea146050c5227b8b046d49c6f68518e95" translate="yes" xml:space="preserve">
          <source>As described in &lt;a href=&quot;../memory/new/operator_new&quot;&gt; allocation function&lt;/a&gt;, the C++ program may provide global and class-specific replacements for these functions. If the new-expression begins with the optional &lt;code&gt;::&lt;/code&gt; operator, as in &lt;code&gt;::new T&lt;/code&gt; or &lt;code&gt;::new T[n]&lt;/code&gt;, class-specific replacements will be ignored (the function is &lt;a href=&quot;lookup&quot;&gt;looked up&lt;/a&gt; in global &lt;a href=&quot;scope&quot;&gt;scope&lt;/a&gt;). Otherwise, if &lt;code&gt;T&lt;/code&gt; is a class type, lookup begins in the class scope of &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">Как описано в &lt;a href=&quot;../memory/new/operator_new&quot;&gt;функции выделения&lt;/a&gt; , программа C ++ может предоставлять глобальные и специфичные для класса замены для этих функций. Если выражение new начинается с необязательного оператора &lt;code&gt;::&lt;/code&gt; , как в &lt;code&gt;::new T&lt;/code&gt; или &lt;code&gt;::new T[n]&lt;/code&gt; , специфичные для класса замены игнорируются (функция &lt;a href=&quot;lookup&quot;&gt;ищется&lt;/a&gt; в глобальной &lt;a href=&quot;scope&quot;&gt;области видимости&lt;/a&gt; ). В противном случае, если &lt;code&gt;T&lt;/code&gt; является типом класса, поиск начинается в классе сфере &lt;code&gt;T&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="03fe97a528d16f7fe7e71f5717247af8db4822bd" translate="yes" xml:space="preserve">
          <source>As described in &lt;a href=&quot;explicit_cast&quot;&gt;functional cast&lt;/a&gt;, the syntax &lt;code&gt;T()&lt;/code&gt;(1) is prohibited for arrays, while &lt;code&gt;T{}&lt;/code&gt;(5) is allowed.</source>
          <target state="translated">Как описано в &lt;a href=&quot;explicit_cast&quot;&gt;функциональном приведении&lt;/a&gt; , синтаксис &lt;code&gt;T()&lt;/code&gt; (1) запрещен для массивов, в то время как &lt;code&gt;T{}&lt;/code&gt; (5) разрешен.</target>
        </trans-unit>
        <trans-unit id="f2a24edd45dbf727b01f52b1b2fe43e48097af38" translate="yes" xml:space="preserve">
          <source>As described in &lt;a href=&quot;initialization#Non-local_variables&quot;&gt;non-local initialization&lt;/a&gt;, static and thread-local variables that aren't constant-initialized(since C++14) are zero-initialized before any other initialization takes place. If the definition of a non-class non-local variable has no initializer, then default initialization does nothing, leaving the result of the earlier zero-initialization unmodified.</source>
          <target state="translated">Как описано в &lt;a href=&quot;initialization#Non-local_variables&quot;&gt;нелокальной инициализации&lt;/a&gt; , статические и локальные переменные потока, которые не инициализируются константой (начиная с C ++ 14), инициализируются нулями перед любой другой инициализацией. Если определение нелокальной нелокальной переменной не имеет инициализатора, то инициализация по умолчанию ничего не делает, оставляя результат более ранней инициализации нуля неизмененным.</target>
        </trans-unit>
        <trans-unit id="08d19aea73540a5ba0404cba80c23af9e3c2ceba" translate="yes" xml:space="preserve">
          <source>As described in &lt;code&gt;&lt;a href=&quot;invoke&quot;&gt;std::invoke&lt;/a&gt;&lt;/code&gt;, when invoking a pointer to non-static member function or pointer to non-static data member, the first argument has to be a reference or pointer (including, possibly, smart pointer such as &lt;code&gt;&lt;a href=&quot;../../memory/shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../../memory/unique_ptr&quot;&gt;std::unique_ptr&lt;/a&gt;&lt;/code&gt;) to an object whose member will be accessed.</source>
          <target state="translated">Как описано в &lt;code&gt;&lt;a href=&quot;invoke&quot;&gt;std::invoke&lt;/a&gt;&lt;/code&gt; , при вызове указателя на нестатическую функцию-член или указателя на нестатический элемент данных, первый аргумент должен быть ссылкой или указателем (включая, возможно, умный указатель, такой как &lt;code&gt;&lt;a href=&quot;../../memory/shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;../../memory/unique_ptr&quot;&gt;std::unique_ptr&lt;/a&gt;&lt;/code&gt; ) к объекту, член которого будет доступен.</target>
        </trans-unit>
        <trans-unit id="2b2d6cdbd1b2496e6a2f40aed0a78a511c900aab" translate="yes" xml:space="preserve">
          <source>As discussed in &lt;a href=&quot;lookup&quot;&gt;lookup&lt;/a&gt;, the lookup of a dependent name used in a template is postponed until the template arguments are known, at which time.</source>
          <target state="translated">Как обсуждалось при &lt;a href=&quot;lookup&quot;&gt;поиске&lt;/a&gt; , поиск зависимого имени, используемого в шаблоне, откладывается до тех пор, пока не будут известны аргументы шаблона, и в этот момент.</target>
        </trans-unit>
        <trans-unit id="58e3f3f862eff79aa619bdf804e54d8152b28137" translate="yes" xml:space="preserve">
          <source>As formulated in C++11, the behavior of &lt;code&gt;std::result_of&lt;/code&gt; is undefined when &lt;code&gt;INVOKE(std::declval&amp;lt;F&amp;gt;(), std::declval&amp;lt;ArgTypes&amp;gt;()...)&lt;/code&gt; is ill-formed (e.g. when F is not a callable type at all). C++14 changes that to a &lt;a href=&quot;../language/sfinae&quot;&gt;SFINAE&lt;/a&gt; (when F is not callable, &lt;code&gt;std::result_of&amp;lt;F(ArgTypes...)&amp;gt;&lt;/code&gt; simply doesn't have the &lt;code&gt;type&lt;/code&gt; member).</source>
          <target state="translated">Как сформулировано в C ++ 11, поведение &lt;code&gt;std::result_of&lt;/code&gt; не определено, когда &lt;code&gt;INVOKE(std::declval&amp;lt;F&amp;gt;(), std::declval&amp;lt;ArgTypes&amp;gt;()...)&lt;/code&gt; плохо сформирован (например, когда F вообще не вызываемый тип). C ++ 14 изменяет это на &lt;a href=&quot;../language/sfinae&quot;&gt;SFINAE&lt;/a&gt; (когда F не вызывается, &lt;code&gt;std::result_of&amp;lt;F(ArgTypes...)&amp;gt;&lt;/code&gt; просто не имеет члена &lt;code&gt;type&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="937a4526e972e8900a66eaf74bf3283dd336852b" translate="yes" xml:space="preserve">
          <source>As free (namespace) function</source>
          <target state="translated">Как свободная (пространство имён)функция</target>
        </trans-unit>
        <trans-unit id="ebe6ab533cbf3972cb8d127e93ba520450789106" translate="yes" xml:space="preserve">
          <source>As is the case with &lt;a href=&quot;while&quot;&gt;while&lt;/a&gt; loop, if statement is a single statement (not a compound statement), the scope of variables declared in it is limited to the loop body as if it was a compound statement.</source>
          <target state="translated">Как и в случае с в &lt;a href=&quot;while&quot;&gt;то время&lt;/a&gt; цикла, если утверждение один оператор (не составной оператор), объем переменных , объявленных в нем ограничена телом цикла , как если бы это было составной оператор.</target>
        </trans-unit>
        <trans-unit id="c00d6a8291143d3954d0476db09f338bbdf6a6a6" translate="yes" xml:space="preserve">
          <source>As is the case with &lt;code&gt;typename&lt;/code&gt;, the &lt;code&gt;template&lt;/code&gt; prefix is allowed even if the name is not dependent or the use does not appear in the scope of a template(since C++11).</source>
          <target state="translated">Как и в случае с &lt;code&gt;typename&lt;/code&gt; , префикс &lt;code&gt;template&lt;/code&gt; разрешен, даже если имя не зависит или использование не входит в область действия шаблона (начиная с C ++ 11).</target>
        </trans-unit>
        <trans-unit id="f30e97ae154b85ba90b59b0fc7f3cc9421ecbfce" translate="yes" xml:space="preserve">
          <source>As long as the computation doesn't overflow, (1-3) always return a valid &lt;code&gt;weekday&lt;/code&gt; even if &lt;code&gt;wd.ok()&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">Пока вычисления не переполняются, (1-3) всегда возвращают правильный &lt;code&gt;weekday&lt;/code&gt; даже если &lt;code&gt;wd.ok()&lt;/code&gt; имеет значение &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b2ffc3f13ddf954cdee7f939204ad75111f3eb7d" translate="yes" xml:space="preserve">
          <source>As long as the computation doesn't overflow, (1-3) always return a valid month even if &lt;code&gt;m.ok()&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">Пока вычисления не переполняются, (1-3) всегда возвращает правильный месяц, даже если &lt;code&gt;m.ok()&lt;/code&gt; имеет значение &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="974f4de3b83d59e1f68e4272f20e899a5d37454c" translate="yes" xml:space="preserve">
          <source>As member function</source>
          <target state="translated">Как членская функция</target>
        </trans-unit>
        <trans-unit id="713b3ed5226e8894aaa4433505d652a47c900087" translate="yes" xml:space="preserve">
          <source>As mentioned in &lt;a href=&quot;declarations#Declarators&quot;&gt;Declarations&lt;/a&gt;, the declarator can be followed by a</source>
          <target state="translated">Как указано в &lt;a href=&quot;declarations#Declarators&quot;&gt;декларации&lt;/a&gt; , за декларатором может следовать</target>
        </trans-unit>
        <trans-unit id="49e91975e9ca17802a309ea7799083868c1165b1" translate="yes" xml:space="preserve">
          <source>As non-member function</source>
          <target state="translated">Как не членская функция</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
