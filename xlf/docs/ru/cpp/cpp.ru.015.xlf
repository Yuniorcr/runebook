<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="cpp">
    <body>
      <group id="cpp">
        <trans-unit id="751c68a3471b1c791efaee0a8e7c24ea0c266efd" translate="yes" xml:space="preserve">
          <source>If</source>
          <target state="translated">If</target>
        </trans-unit>
        <trans-unit id="8967e7083aa7ece41be13822051695a635bff07e" translate="yes" xml:space="preserve">
          <source>If &amp;nu;&amp;gt;=128, the behavior is implementation-defined</source>
          <target state="translated">Если &amp;nu;&amp;gt; = 128, поведение определяется реализацией</target>
        </trans-unit>
        <trans-unit id="c861ca152a1a5790f61fc9a7ad6bc1a92ae258c8" translate="yes" xml:space="preserve">
          <source>If (and only if) reallocation takes place, all pointers, references, and iterators are invalidated.</source>
          <target state="translated">Если (и только если)происходит перераспределение,все указатели,ссылки и итераторы аннулируются.</target>
        </trans-unit>
        <trans-unit id="98c199ab16ab809f486bbb3423d179f029c19b26" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;../preprocessor/impl&quot;&gt;&lt;code&gt; #pragma STDC FENV_ACCESS&lt;/code&gt;&lt;/a&gt; is supported and set to &lt;code&gt;ON&lt;/code&gt;, all floating-point arithmetic operators obey the current floating-point &lt;a href=&quot;../numeric/fenv/fe_round&quot;&gt;rounding direction&lt;/a&gt; and report floating-point arithmetic errors as specified in &lt;a href=&quot;../numeric/math/math_errhandling&quot;&gt;&lt;code&gt;math_errhandling&lt;/code&gt;&lt;/a&gt; unless part of a &lt;a href=&quot;initialization#Non-local_variables&quot;&gt;static initializer&lt;/a&gt; (in which case floating-point exceptions are not raised and the rounding mode is to nearest).</source>
          <target state="translated">Если &lt;a href=&quot;../preprocessor/impl&quot;&gt; &lt;code&gt; #pragma STDC FENV_ACCESS&lt;/code&gt; &lt;/a&gt; поддерживается и установлен в значение &lt;code&gt;ON&lt;/code&gt; , все арифметические операторы с плавающей запятой подчиняются текущему &lt;a href=&quot;../numeric/fenv/fe_round&quot;&gt;направлению округления с&lt;/a&gt; плавающей запятой и сообщают об арифметических ошибках с плавающей запятой, как указано в &lt;a href=&quot;../numeric/math/math_errhandling&quot;&gt; &lt;code&gt;math_errhandling&lt;/code&gt; ,&lt;/a&gt; если только они не являются частью &lt;a href=&quot;initialization#Non-local_variables&quot;&gt;статического инициализатора&lt;/a&gt; (в этом случае с плавающей запятой) исключения не возбуждаются и режим округления до ближайшего).</target>
        </trans-unit>
        <trans-unit id="7bb02eee6cd1dc516434df27056595be6a6b00a7" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;copy_initialization&quot;&gt;copy-initialization&lt;/a&gt; of an object of class type requires that a &lt;a href=&quot;cast_operator&quot;&gt;user-defined conversion function&lt;/a&gt; is called to convert the initializer expression of type cv &lt;code&gt;S&lt;/code&gt; to the type cv &lt;code&gt;T&lt;/code&gt; of the object being initialized, the following functions are candidate functions:</source>
          <target state="translated">Если при &lt;a href=&quot;copy_initialization&quot;&gt;инициализации копирования&lt;/a&gt; объекта типа класса требуется, чтобы &lt;a href=&quot;cast_operator&quot;&gt;пользовательская функция преобразования вызывалась&lt;/a&gt; для преобразования выражения инициализатора типа cv &lt;code&gt;S&lt;/code&gt; в тип cv &lt;code&gt;T&lt;/code&gt; инициализируемого объекта, следующие функции являются функциями-кандидатами:</target>
        </trans-unit>
        <trans-unit id="cc788d4e3b334778f8f385fbf8f9f00b88dbcecf" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;goto&quot;&gt;goto&lt;/a&gt; is used to exit a try-block and if any of the destructors of block-scoped automatic variables that are executed by the &lt;code&gt;goto&lt;/code&gt; throw exceptions, those exceptions are caught by the try blocks in which the variables are defined:</source>
          <target state="translated">Если &lt;a href=&quot;goto&quot;&gt;goto&lt;/a&gt; используется для выхода из блока try и если какой-либо из деструкторов автоматических переменных в области блока, которые выполняются исключениями &lt;code&gt;goto&lt;/code&gt; throw, эти исключения перехватываются блоками try, в которых определены переменные:</target>
        </trans-unit>
        <trans-unit id="ad02ee6de1557c2cab77c2034cb247d4122fb981" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;valueless_by_exception&quot;&gt;valueless_by_exception&lt;/a&gt; is true, does nothing. Otherwise, destroys the currently contained value.</source>
          <target state="translated">Если &lt;a href=&quot;valueless_by_exception&quot;&gt;valueless_by_exception&lt;/a&gt; true, ничего не делает. В противном случае уничтожает текущее значение.</target>
        </trans-unit>
        <trans-unit id="22e67fa78b1a05182b627ae99ffd3c2b45940a22" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;!m.ok()&lt;/code&gt;, equivalent to &lt;code&gt;os &amp;lt;&amp;lt; unsigned(m) &amp;lt;&amp;lt; &quot; is not a valid month&quot;;&lt;/code&gt;. Otherwise, forms a &lt;code&gt;std::basic_string&amp;lt;CharT&amp;gt;&lt;/code&gt;&lt;code&gt;s&lt;/code&gt; consisting of the abbreviated month name for the month represented by &lt;code&gt;m&lt;/code&gt;, determined using the locale associated with &lt;code&gt;os&lt;/code&gt;, and inserts &lt;code&gt;s&lt;/code&gt; into &lt;code&gt;os&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;!m.ok()&lt;/code&gt; , эквивалентно &lt;code&gt;os &amp;lt;&amp;lt; unsigned(m) &amp;lt;&amp;lt; &quot; is not a valid month&quot;;&lt;/code&gt; , В противном случае формирует &lt;code&gt;std::basic_string&amp;lt;CharT&amp;gt;&lt;/code&gt; &lt;code&gt;s&lt;/code&gt; , состоящий из сокращенного названия месяца для месяца, представленного &lt;code&gt;m&lt;/code&gt; , определенного с использованием локали, связанной с &lt;code&gt;os&lt;/code&gt; , и вставляет &lt;code&gt;s&lt;/code&gt; в &lt;code&gt;os&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c1a70707db6a348980443d56c9ab0c52464c252f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;!uppercase&lt;/code&gt;, will use conversion specifier &lt;code&gt;%g&lt;/code&gt;</source>
          <target state="translated">Если &lt;code&gt;!uppercase&lt;/code&gt; , будет использовать спецификатор преобразования &lt;code&gt;%g&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1f6dfc884c101654edafd48a800532bba66066cb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;!wd.ok()&lt;/code&gt;, equivalent to &lt;code&gt;os &amp;lt;&amp;lt; unsigned(wd) &amp;lt;&amp;lt; &quot; is not a valid weekday&quot;;&lt;/code&gt;. Otherwise, forms a &lt;code&gt;std::basic_string&amp;lt;CharT&amp;gt;&lt;/code&gt;&lt;code&gt;s&lt;/code&gt; consisting of the abbreviated weekday name for the weekday represented by &lt;code&gt;wd&lt;/code&gt;, determined using the locale associated with &lt;code&gt;os&lt;/code&gt;, and inserts &lt;code&gt;s&lt;/code&gt; into &lt;code&gt;os&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;!wd.ok()&lt;/code&gt; , эквивалентно &lt;code&gt;os &amp;lt;&amp;lt; unsigned(wd) &amp;lt;&amp;lt; &quot; is not a valid weekday&quot;;&lt;/code&gt; , В противном случае формирует &lt;code&gt;std::basic_string&amp;lt;CharT&amp;gt;&lt;/code&gt; &lt;code&gt;s&lt;/code&gt; , состоящий из сокращенного названия дня недели для дня недели, представленного &lt;code&gt;wd&lt;/code&gt; , определенного с помощью локали, связанной с &lt;code&gt;os&lt;/code&gt; , и вставляет &lt;code&gt;s&lt;/code&gt; в &lt;code&gt;os&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fc136d5ecc5ffd29fb88143ae3ce7ad3bfccb312" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;(&lt;a href=&quot;../types/is_destructible&quot;&gt;std::is_trivially_destructible_v&lt;/a&gt;&amp;lt;Types&amp;gt; &amp;amp;&amp;amp; ...)&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, the destructor of &lt;code&gt;tuple&lt;/code&gt; is trivial.</source>
          <target state="translated">Если &lt;code&gt;(&lt;a href=&quot;../types/is_destructible&quot;&gt;std::is_trivially_destructible_v&lt;/a&gt;&amp;lt;Types&amp;gt; &amp;amp;&amp;amp; ...)&lt;/code&gt; имеет значение &lt;code&gt;true&lt;/code&gt; , деструктор &lt;code&gt;tuple&lt;/code&gt; тривиален.</target>
        </trans-unit>
        <trans-unit id="da8cff62887e613aba67b865a9e6d73a9a0208c9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;(os.flags() &amp;amp; &lt;a href=&quot;../ios_base/fmtflags&quot;&gt;std::ios_base::unitbuf&lt;/a&gt;) &amp;amp;&amp;amp; !&lt;a href=&quot;../../error/exception/uncaught_exception&quot;&gt;std::uncaught_exception&lt;/a&gt;() &amp;amp;&amp;amp; os.good())&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, calls &lt;code&gt;os.rdbuf()-&amp;gt;pubsync()&lt;/code&gt;. If that function returns &lt;code&gt;-1&lt;/code&gt;, sets &lt;code&gt;badbit&lt;/code&gt; in &lt;code&gt;os.rdstate()&lt;/code&gt; without propagating an exception.</source>
          <target state="translated">If &lt;code&gt;(os.flags() &amp;amp; &lt;a href=&quot;../ios_base/fmtflags&quot;&gt;std::ios_base::unitbuf&lt;/a&gt;) &amp;amp;&amp;amp; !&lt;a href=&quot;../../error/exception/uncaught_exception&quot;&gt;std::uncaught_exception&lt;/a&gt;() &amp;amp;&amp;amp; os.good())&lt;/code&gt; имеет значение &lt;code&gt;true&lt;/code&gt; , вызывает &lt;code&gt;os.rdbuf()-&amp;gt;pubsync()&lt;/code&gt; . Если эта функция возвращает &lt;code&gt;-1&lt;/code&gt; , устанавливает &lt;code&gt;badbit&lt;/code&gt; в &lt;code&gt;os.rdstate()&lt;/code&gt; без распространения исключения.</target>
        </trans-unit>
        <trans-unit id="cd5e11e3cc0c402b0e9be870090813113d4c62f4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;(unsigned char)c &amp;gt;= &lt;a href=&quot;../ctype&quot;&gt;std::ctype&lt;/a&gt;&amp;lt;char&amp;gt;::table_size&lt;/code&gt;, then an implementation-defined value is substituted instead of &lt;code&gt;table()[(unsigned char)c]&lt;/code&gt;, possibly different for different values of &lt;code&gt;c&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;(unsigned char)c &amp;gt;= &lt;a href=&quot;../ctype&quot;&gt;std::ctype&lt;/a&gt;&amp;lt;char&amp;gt;::table_size&lt;/code&gt; , то вместо &lt;code&gt;table()[(unsigned char)c]&lt;/code&gt; подставляется значение, определенное реализацией , возможно, отличающееся для разных значений &lt;code&gt;c&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="92961dd363bdfb6c745602ae238d61a26e00ce3c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;*a&lt;/code&gt; and &lt;code&gt;*b&lt;/code&gt; refer to the same object, then &lt;code&gt;a&lt;/code&gt; == &lt;code&gt;b&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;*a&lt;/code&gt; и &lt;code&gt;*b&lt;/code&gt; относятся к одному и тому же объекту, то &lt;code&gt;a&lt;/code&gt; == &lt;code&gt;b&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4d8fc3988020f52aa4cd322d347c93e64ecb80c7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;*this&lt;/code&gt; already owns an object and it is the last &lt;code&gt;shared_ptr&lt;/code&gt; owning it, and &lt;code&gt;r&lt;/code&gt; is not the same as &lt;code&gt;*this&lt;/code&gt;, the object is destroyed through the owned deleter.</source>
          <target state="translated">Если &lt;code&gt;*this&lt;/code&gt; уже владеет объектом и является последним &lt;code&gt;shared_ptr&lt;/code&gt; , владеющим им, и &lt;code&gt;r&lt;/code&gt; не совпадает с &lt;code&gt;*this&lt;/code&gt; , объект уничтожается через принадлежащий удалитель.</target>
        </trans-unit>
        <trans-unit id="d91b74584f1eaef50da01b154cf35ae1c060bd65" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;*this&lt;/code&gt; already owns an object and it is the last &lt;code&gt;shared_ptr&lt;/code&gt; owning it, the object is destroyed through the owned deleter.</source>
          <target state="translated">Если &lt;code&gt;*this&lt;/code&gt; уже владеет объектом и является последним &lt;code&gt;shared_ptr&lt;/code&gt; , владеющим им, объект уничтожается через принадлежащее ему средство удаления.</target>
        </trans-unit>
        <trans-unit id="9547dd884045b3da73d2308453755944edbbda07" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;*this&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt; both have dynamic type &lt;code&gt;std::exception&lt;/code&gt; then &lt;code&gt;&lt;a href=&quot;../../string/byte/strcmp&quot;&gt;std::strcmp&lt;/a&gt;(what(), other.what()) == 0&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;*this&lt;/code&gt; и &lt;code&gt;other&lt;/code&gt; оба имеют динамический тип &lt;code&gt;std::exception&lt;/code&gt; тогда &lt;code&gt;&lt;a href=&quot;../../string/byte/strcmp&quot;&gt;std::strcmp&lt;/a&gt;(what(), other.what()) == 0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c9d03bcb4418c0282af6a72fecf7a440fdb5debe" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;*this&lt;/code&gt; contains a value, but &lt;code&gt;other&lt;/code&gt; does not, then the contained value is destroyed by calling its destructor. &lt;code&gt;*this&lt;/code&gt; does not contain a value after the call.</source>
          <target state="translated">Если &lt;code&gt;*this&lt;/code&gt; содержит значение, а &lt;code&gt;other&lt;/code&gt; - нет, то содержащееся значение уничтожается путем вызова его деструктора. &lt;code&gt;*this&lt;/code&gt; не содержит значения после вызова.</target>
        </trans-unit>
        <trans-unit id="a7a277ddff2e8e400ab7cc6265a8854405fc6aff" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;*this&lt;/code&gt; contains a value, destroy that value as if by &lt;code&gt;value().T::~T()&lt;/code&gt;. Otherwise, there are no effects.</source>
          <target state="translated">Если &lt;code&gt;*this&lt;/code&gt; содержит значение, уничтожьте это значение как бы &lt;code&gt;value().T::~T()&lt;/code&gt; . В противном случае, нет никаких эффектов.</target>
        </trans-unit>
        <trans-unit id="3f2f61fd72ae5e884e1a574bf73169287b72c489" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;*this&lt;/code&gt; contains a value, returns a reference to the contained value.</source>
          <target state="translated">Если &lt;code&gt;*this&lt;/code&gt; содержит значение, возвращает ссылку на содержащееся значение.</target>
        </trans-unit>
        <trans-unit id="c59d16b11cfaa885be1c6ecd9266546a41ca8652" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;*this&lt;/code&gt; has an associated mutex ((&lt;code&gt;&lt;a href=&quot;mutex&quot;&gt;mutex()&lt;/a&gt;&lt;/code&gt; returns a non-null pointer) and has acquired ownership of it (&lt;code&gt;owns()&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt;), the mutex is unlocked by calling &lt;code&gt;&lt;a href=&quot;../shared_mutex/unlock_shared&quot;&gt;unlock_shared()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;*this&lt;/code&gt; связан мьютекс (( &lt;code&gt;&lt;a href=&quot;mutex&quot;&gt;mutex()&lt;/a&gt;&lt;/code&gt; возвращает ненулевой указатель) и приобрел владение им ( &lt;code&gt;owns()&lt;/code&gt; возвращает &lt;code&gt;true&lt;/code&gt; ), мьютекс разблокируется путем вызова &lt;code&gt;&lt;a href=&quot;../shared_mutex/unlock_shared&quot;&gt;unlock_shared()&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0082e088403160e49ff73354c8b162b48a36a42a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;*this&lt;/code&gt; has an associated thread (&lt;code&gt;joinable() == true&lt;/code&gt;), &lt;code&gt;&lt;a href=&quot;../../error/terminate&quot;&gt;std::terminate&lt;/a&gt;()&lt;/code&gt; is called.</source>
          <target state="translated">Если &lt;code&gt;*this&lt;/code&gt; связан поток ( &lt;code&gt;joinable() == true&lt;/code&gt; ), вызывается &lt;code&gt;&lt;a href=&quot;../../error/terminate&quot;&gt;std::terminate&lt;/a&gt;()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9144affce378c4381a07accbbe9c5b400c516453" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;*this&lt;/code&gt; is a suffix iterator, sets &lt;code&gt;*this&lt;/code&gt; to an end-of-sequence iterator.</source>
          <target state="translated">Если &lt;code&gt;*this&lt;/code&gt; суффиксный итератор, устанавливает &lt;code&gt;*this&lt;/code&gt; итератор в конце последовательности.</target>
        </trans-unit>
        <trans-unit id="d1c58d5d72435da6477abb6fcff62548ec0974a7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;*this&lt;/code&gt; is the last object referring to the shared state, destroys the shared state. Otherwise does nothing.</source>
          <target state="translated">Если &lt;code&gt;*this&lt;/code&gt; последний объект, ссылающийся на общее состояние, уничтожает общее состояние. В противном случае ничего не делает.</target>
        </trans-unit>
        <trans-unit id="43f3508ad52f8c72c8bffdd8e6f95fe0b279e431" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;*this&lt;/code&gt; owns an object and it is the last &lt;code&gt;shared_ptr&lt;/code&gt; owning it, the object is destroyed through the owned deleter.</source>
          <target state="translated">Если &lt;code&gt;*this&lt;/code&gt; владеет объектом, и это последний &lt;code&gt;shared_ptr&lt;/code&gt; , владеющий им, объект уничтожается через принадлежащее ему средство удаления.</target>
        </trans-unit>
        <trans-unit id="0047e92ce8b32348ae1bf76f7759ee5ab1deddb9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;*this&lt;/code&gt; still has an associated running thread (i.e. &lt;code&gt;joinable() == true&lt;/code&gt;), call &lt;code&gt;&lt;a href=&quot;../../error/terminate&quot;&gt;std::terminate&lt;/a&gt;()&lt;/code&gt;. Otherwise, assigns the state of &lt;code&gt;other&lt;/code&gt; to &lt;code&gt;*this&lt;/code&gt; and sets &lt;code&gt;other&lt;/code&gt; to a default constructed state.</source>
          <target state="translated">Если &lt;code&gt;*this&lt;/code&gt; все еще имеет связанный работающий поток (то есть &lt;code&gt;joinable() == true&lt;/code&gt; ), вызовите &lt;code&gt;&lt;a href=&quot;../../error/terminate&quot;&gt;std::terminate&lt;/a&gt;()&lt;/code&gt; . В противном случае, присваивает состояние &lt;code&gt;other&lt;/code&gt; , чтобы &lt;code&gt;*this&lt;/code&gt; и устанавливает &lt;code&gt;other&lt;/code&gt; в состояние по умолчанию строится.</target>
        </trans-unit>
        <trans-unit id="1c3de47b3604829aa8d6c1f140e9684e3f5dc92f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;--a == --b&lt;/code&gt; then &lt;code&gt;a == b&lt;/code&gt;</source>
          <target state="translated">Если &lt;code&gt;--a == --b&lt;/code&gt; то &lt;code&gt;a == b&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="90fa435f3b59c79cbaeb4963bb4835737f7d7a11" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;::&lt;/code&gt; is followed by the character &lt;code&gt;~&lt;/code&gt; that is in turn followed by an identifier (that is, it specifies a destructor or pseudo-destructor), that identifier is looked up in the same scope as the name on the left hand side of &lt;code&gt;::&lt;/code&gt;</source>
          <target state="translated">Если за &lt;code&gt;::&lt;/code&gt; следует символ &lt;code&gt;~&lt;/code&gt; ,за которым, в свою очередь, следует идентификатор (то есть он указывает деструктор или псевдодеструктор), этот идентификатор ищется в той же области видимости, что и имя в левой части &lt;code&gt;::&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c2a97dc8c387c983d7ce89c28639a1a4934e5f45" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;../../locale/codecvt/always_noconv&quot;&gt;std::codecvt::always_noconv&lt;/a&gt;&lt;/code&gt; is true, the call to &lt;code&gt;&lt;a href=&quot;../../locale/codecvt/out&quot;&gt;std::codecvt::out&lt;/a&gt;&lt;/code&gt; may be skipped.</source>
          <target state="translated">Если &lt;code&gt;&lt;a href=&quot;../../locale/codecvt/always_noconv&quot;&gt;std::codecvt::always_noconv&lt;/a&gt;&lt;/code&gt; имеет значение true, вызов &lt;code&gt;&lt;a href=&quot;../../locale/codecvt/out&quot;&gt;std::codecvt::out&lt;/a&gt;&lt;/code&gt; может быть пропущен.</target>
        </trans-unit>
        <trans-unit id="383dd33e0c7222077e9f39a66a18786b4b4abb6c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;../../memory/allocator_traits&quot;&gt;std::allocator_traits&lt;/a&gt;&amp;lt;Allocator&amp;gt;::propagate_on_container_move_assignment::value&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;, then the allocator is unchanged. Otherwise, after move-assignment, &lt;code&gt;get_allocator()&lt;/code&gt; equals &lt;code&gt;other.get_allocator()&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;&lt;a href=&quot;../../memory/allocator_traits&quot;&gt;std::allocator_traits&lt;/a&gt;&amp;lt;Allocator&amp;gt;::propagate_on_container_move_assignment::value&lt;/code&gt; имеет значение &lt;code&gt;false&lt;/code&gt; , то распределитель не изменяется. В противном случае, после перемещения-назначения &lt;code&gt;get_allocator()&lt;/code&gt; равен &lt;code&gt;other.get_allocator()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="effa1c8a8ecca962a3e2c90eb4b0b4cd886ee427" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;../../memory/allocator_traits&quot;&gt;std::allocator_traits&lt;/a&gt;&amp;lt;allocator_type&amp;gt;::propagate_on_container_swap::value&lt;/code&gt; is true, then the allocators are exchanged using an unqualified call to non-member &lt;code&gt;swap&lt;/code&gt;. Otherwise, they are not swapped (and if &lt;code&gt;get_allocator() != other.get_allocator()&lt;/code&gt;, the behavior is undefined).</source>
          <target state="translated">Если &lt;code&gt;&lt;a href=&quot;../../memory/allocator_traits&quot;&gt;std::allocator_traits&lt;/a&gt;&amp;lt;allocator_type&amp;gt;::propagate_on_container_swap::value&lt;/code&gt; имеет значение true, то распределители обмениваются с использованием безусловного вызова &lt;code&gt;swap&lt;/code&gt; не являющегося членом . В противном случае они не меняются местами (и если &lt;code&gt;get_allocator() != other.get_allocator()&lt;/code&gt; , поведение не определено).</target>
        </trans-unit>
        <trans-unit id="895e0eca3c2f91f7c107010968f8c4eae623b669" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;../../types/climits&quot;&gt;FLT_RADIX&lt;/a&gt;&lt;/code&gt; is 2 (or a power of 2), the returned value is exact, &lt;a href=&quot;../fenv/fe_round&quot;&gt;the current rounding mode&lt;/a&gt; is ignored</source>
          <target state="translated">Если &lt;code&gt;&lt;a href=&quot;../../types/climits&quot;&gt;FLT_RADIX&lt;/a&gt;&lt;/code&gt; равен 2 (или степени 2), возвращаемое значение является точным, &lt;a href=&quot;../fenv/fe_round&quot;&gt;текущий режим округления&lt;/a&gt; игнорируется</target>
        </trans-unit>
        <trans-unit id="1790032c97cf911e15ed06b1a6725dd974239d4c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;../../types/climits&quot;&gt;SIZE_MAX&lt;/a&gt; / sizeof(U) &amp;lt; n&lt;/code&gt;, throws &lt;code&gt;&lt;a href=&quot;../../error/length_error/length_error&quot;&gt;std::length_error&lt;/a&gt;&lt;/code&gt;, otherwise equivalent to &lt;code&gt;return static_cast&amp;lt;U*&amp;gt;(allocate_bytes(n * sizeof(U), alignof(U)) );&lt;/code&gt;</source>
          <target state="translated">Если &lt;code&gt;&lt;a href=&quot;../../types/climits&quot;&gt;SIZE_MAX&lt;/a&gt; / sizeof(U) &amp;lt; n&lt;/code&gt; , выбрасывает &lt;code&gt;&lt;a href=&quot;../../error/length_error/length_error&quot;&gt;std::length_error&lt;/a&gt;&lt;/code&gt; , в противном случае эквивалентно &lt;code&gt;return static_cast&amp;lt;U*&amp;gt;(allocate_bytes(n * sizeof(U), alignof(U)) );&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d5ebe4fc1a8abdaf844d29a3d314c89acaad005a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;../../types/decay&quot;&gt;std::decay_t&lt;/a&gt;&amp;lt;decltype(t1)&amp;gt;&lt;/code&gt; is a specialization of &lt;code&gt;&lt;a href=&quot;reference_wrapper&quot;&gt;std::reference_wrapper&lt;/a&gt;&lt;/code&gt;, then &lt;code&gt;INVOKE(f, t1)&lt;/code&gt; is equivalent to &lt;code&gt;t1.get().*f&lt;/code&gt;</source>
          <target state="translated">Если &lt;code&gt;&lt;a href=&quot;../../types/decay&quot;&gt;std::decay_t&lt;/a&gt;&amp;lt;decltype(t1)&amp;gt;&lt;/code&gt; является специализацией &lt;code&gt;&lt;a href=&quot;reference_wrapper&quot;&gt;std::reference_wrapper&lt;/a&gt;&lt;/code&gt; , то &lt;code&gt;INVOKE(f, t1)&lt;/code&gt; эквивалентно &lt;code&gt;t1.get().*f&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="982ec353c22eb69baf317b330efaf0a7a5e7cce1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;../../types/decay&quot;&gt;std::decay_t&lt;/a&gt;&amp;lt;decltype(t1)&amp;gt;&lt;/code&gt; is a specialization of &lt;code&gt;&lt;a href=&quot;reference_wrapper&quot;&gt;std::reference_wrapper&lt;/a&gt;&lt;/code&gt;, then &lt;code&gt;INVOKE(f, t1, t2, ..., tN)&lt;/code&gt; is equivalent to &lt;code&gt;(t1.get().*f)(t2, ..., tN)&lt;/code&gt;</source>
          <target state="translated">Если &lt;code&gt;&lt;a href=&quot;../../types/decay&quot;&gt;std::decay_t&lt;/a&gt;&amp;lt;decltype(t1)&amp;gt;&lt;/code&gt; является специализацией &lt;code&gt;&lt;a href=&quot;reference_wrapper&quot;&gt;std::reference_wrapper&lt;/a&gt;&lt;/code&gt; , то &lt;code&gt;INVOKE(f, t1, t2, ..., tN)&lt;/code&gt; эквивалентен &lt;code&gt;(t1.get().*f)(t2, ..., tN)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="975228dc0d0d9d407e294a92674384d84c5af876" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;../../types/is_base_of&quot;&gt;std::is_base_of&lt;/a&gt;&amp;lt;T, &lt;a href=&quot;../../types/decay&quot;&gt;std::decay_t&lt;/a&gt;&amp;lt;decltype(t1)&amp;gt;&amp;gt;::value&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, then &lt;code&gt;INVOKE(f, t1)&lt;/code&gt; is equivalent to &lt;code&gt;t1.*f&lt;/code&gt;</source>
          <target state="translated">Если &lt;code&gt;&lt;a href=&quot;../../types/is_base_of&quot;&gt;std::is_base_of&lt;/a&gt;&amp;lt;T, &lt;a href=&quot;../../types/decay&quot;&gt;std::decay_t&lt;/a&gt;&amp;lt;decltype(t1)&amp;gt;&amp;gt;::value&lt;/code&gt; имеет значение &lt;code&gt;true&lt;/code&gt; , тогда &lt;code&gt;INVOKE(f, t1)&lt;/code&gt; эквивалентно &lt;code&gt;t1.*f&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ebb6d3a6dda70443130e44d3d8eef15c8850d72d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;../../types/is_base_of&quot;&gt;std::is_base_of&lt;/a&gt;&amp;lt;T, &lt;a href=&quot;../../types/decay&quot;&gt;std::decay_t&lt;/a&gt;&amp;lt;decltype(t1)&amp;gt;&amp;gt;::value&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, then &lt;code&gt;INVOKE(f, t1, t2, ..., tN)&lt;/code&gt; is equivalent to &lt;code&gt;(t1.*f)(t2, ..., tN)&lt;/code&gt;</source>
          <target state="translated">Если &lt;code&gt;&lt;a href=&quot;../../types/is_base_of&quot;&gt;std::is_base_of&lt;/a&gt;&amp;lt;T, &lt;a href=&quot;../../types/decay&quot;&gt;std::decay_t&lt;/a&gt;&amp;lt;decltype(t1)&amp;gt;&amp;gt;::value&lt;/code&gt; имеет значение &lt;code&gt;true&lt;/code&gt; , то &lt;code&gt;INVOKE(f, t1, t2, ..., tN)&lt;/code&gt; эквивалентно &lt;code&gt;(t1.*f)(t2, ..., tN)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="46e80aaa2cfeed3cb98adbf86549699888d28e48" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;../../types/is_destructible&quot;&gt;std::is_trivially_destructible_v&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, then this destructor is a trivial destructor.</source>
          <target state="translated">Если &lt;code&gt;&lt;a href=&quot;../../types/is_destructible&quot;&gt;std::is_trivially_destructible_v&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt; имеет значение &lt;code&gt;true&lt;/code&gt; , то этот деструктор является тривиальным деструктором.</target>
        </trans-unit>
        <trans-unit id="50c9fd79a84089afcea1735d81a6458257a8ebf2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;../c&quot;&gt;BUFSIZ&lt;/a&gt;&lt;/code&gt; is not the appropriate buffer size, &lt;code&gt;&lt;a href=&quot;setvbuf&quot;&gt;std::setvbuf&lt;/a&gt;&lt;/code&gt; can be used to change it.</source>
          <target state="translated">Если &lt;code&gt;&lt;a href=&quot;../c&quot;&gt;BUFSIZ&lt;/a&gt;&lt;/code&gt; не подходит для размера буфера, &lt;code&gt;&lt;a href=&quot;setvbuf&quot;&gt;std::setvbuf&lt;/a&gt;&lt;/code&gt; может использоваться для его изменения.</target>
        </trans-unit>
        <trans-unit id="3ea3c7ca7ae345831d1c696b26e5dd6650ec9617" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;../c/time_t&quot;&gt;std::time_t&lt;/a&gt;&lt;/code&gt; has lower precision, it is implementation-defined whether the value is rounded or truncated.</source>
          <target state="translated">Если &lt;code&gt;&lt;a href=&quot;../c/time_t&quot;&gt;std::time_t&lt;/a&gt;&lt;/code&gt; имеет более низкую точность, это определяется реализацией, является ли значение округленным или усеченным.</target>
        </trans-unit>
        <trans-unit id="4b20a41ac6a8f6f3b703c2287f3854ec31392c44" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;../concepts/derivedfrom&quot;&gt;DerivedFrom&lt;/a&gt;&amp;lt;T, view_base&amp;gt;&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, &lt;code&gt;enable_view&amp;lt;T&amp;gt;&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;&lt;a href=&quot;../concepts/derivedfrom&quot;&gt;DerivedFrom&lt;/a&gt;&amp;lt;T, view_base&amp;gt;&lt;/code&gt; равно &lt;code&gt;true&lt;/code&gt; , &lt;code&gt;enable_view&amp;lt;T&amp;gt;&lt;/code&gt; равно &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3253a1bdeb3cf6df583da218fc710e43b8aa013f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;../ios_base/openmode&quot;&gt;std::ios_base::in&lt;/a&gt;&lt;/code&gt; is set in &lt;code&gt;which&lt;/code&gt;, attempts to reposition &lt;code&gt;gptr()&lt;/code&gt; (the next pointer in the get area). If &lt;code&gt;&lt;a href=&quot;../ios_base/openmode&quot;&gt;std::ios_base::out&lt;/a&gt;&lt;/code&gt; is set in &lt;code&gt;which&lt;/code&gt;, attempts to reposition &lt;code&gt;pptr()&lt;/code&gt; (the next pointer in the put area). If neither bit is set in &lt;code&gt;which&lt;/code&gt;, the operation fails.</source>
          <target state="translated">Если задано &lt;code&gt;&lt;a href=&quot;../ios_base/openmode&quot;&gt;std::ios_base::in&lt;/a&gt;&lt;/code&gt; в &lt;code&gt;which&lt;/code&gt; предпринимается попытка изменить положение &lt;code&gt;gptr()&lt;/code&gt; (следующий указатель в области получения). Если задано &lt;code&gt;&lt;a href=&quot;../ios_base/openmode&quot;&gt;std::ios_base::out&lt;/a&gt;&lt;/code&gt; в &lt;code&gt;which&lt;/code&gt; предпринимается попытка изменить положение &lt;code&gt;pptr()&lt;/code&gt; (следующий указатель в области размещения). Если ни один бит установлен в &lt;code&gt;which&lt;/code&gt; операция не выполняется.</target>
        </trans-unit>
        <trans-unit id="1cfad288bd7fbccd70e8241c69a8d092c6bd2656" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;../memory/allocator&quot;&gt;std::allocator&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt; or a similar allocator is used, a class does not have to implement a &lt;a href=&quot;../language/move_constructor&quot;&gt;move constructor&lt;/a&gt; to satisfy this type requirement: a &lt;a href=&quot;../language/copy_constructor&quot;&gt;copy constructor&lt;/a&gt; that takes a &lt;code&gt;const T&amp;amp;&lt;/code&gt; argument can bind rvalue expressions. If a MoveInsertable class implements a move constructor, it may also implement &lt;a href=&quot;../utility/move&quot;&gt;move semantics&lt;/a&gt; to take advantage of the fact that the value of &lt;code&gt;rv&lt;/code&gt; after construction is unspecified.</source>
          <target state="translated">Если используется &lt;code&gt;&lt;a href=&quot;../memory/allocator&quot;&gt;std::allocator&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt; или аналогичный распределитель, классу не нужно реализовывать &lt;a href=&quot;../language/move_constructor&quot;&gt;конструктор перемещения&lt;/a&gt; для удовлетворения этого требования типа: &lt;a href=&quot;../language/copy_constructor&quot;&gt;конструктор копирования,&lt;/a&gt; который принимает аргумент &lt;code&gt;const T&amp;amp;&lt;/code&gt; может связывать выражения rvalue. Если класс MoveInsertable реализует конструктор перемещения, он также может реализовывать &lt;a href=&quot;../utility/move&quot;&gt;семантику перемещения,&lt;/a&gt; чтобы воспользоваться тем фактом, что значение &lt;code&gt;rv&lt;/code&gt; после построения не определено.</target>
        </trans-unit>
        <trans-unit id="3e00f15acad4e10cd2ecd0299fd4d8b97a99bb7d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;../types/decay&quot;&gt;std::decay&lt;/a&gt;&amp;lt;T&amp;gt;::type&lt;/code&gt; is a non-final non-union class type that is neither &lt;code&gt;&lt;a href=&quot;nested_exception&quot;&gt;std::nested_exception&lt;/a&gt;&lt;/code&gt; nor derived from &lt;code&gt;&lt;a href=&quot;nested_exception&quot;&gt;std::nested_exception&lt;/a&gt;&lt;/code&gt;, throws an exception of an unspecified type that is publicly derived from both &lt;code&gt;&lt;a href=&quot;nested_exception&quot;&gt;std::nested_exception&lt;/a&gt;&lt;/code&gt; and from &lt;code&gt;&lt;a href=&quot;../types/decay&quot;&gt;std::decay&lt;/a&gt;&amp;lt;T&amp;gt;::type&lt;/code&gt;, and constructed from &lt;code&gt;&lt;a href=&quot;../utility/forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;T&amp;gt;(t)&lt;/code&gt;. The default constructor of the &lt;code&gt;nested_exception&lt;/code&gt; base class calls &lt;code&gt;&lt;a href=&quot;current_exception&quot;&gt;std::current_exception&lt;/a&gt;&lt;/code&gt;, capturing the currently handled exception object, if any, in a &lt;code&gt;&lt;a href=&quot;exception_ptr&quot;&gt;std::exception_ptr&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;&lt;a href=&quot;../types/decay&quot;&gt;std::decay&lt;/a&gt;&amp;lt;T&amp;gt;::type&lt;/code&gt; является неконечным типом класса, не являющимся объединением, который не является ни &lt;code&gt;&lt;a href=&quot;nested_exception&quot;&gt;std::nested_exception&lt;/a&gt;&lt;/code&gt; ни производным от &lt;code&gt;&lt;a href=&quot;nested_exception&quot;&gt;std::nested_exception&lt;/a&gt;&lt;/code&gt; , выдает исключение неуказанного типа, которое публично получено из обоих &lt;code&gt;&lt;a href=&quot;nested_exception&quot;&gt;std::nested_exception&lt;/a&gt;&lt;/code&gt; и из &lt;code&gt;&lt;a href=&quot;../types/decay&quot;&gt;std::decay&lt;/a&gt;&amp;lt;T&amp;gt;::type&lt;/code&gt; , и построенный из &lt;code&gt;&lt;a href=&quot;../utility/forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;T&amp;gt;(t)&lt;/code&gt; . Конструктор по умолчанию базового класса &lt;code&gt;nested_exception&lt;/code&gt; вызывает &lt;code&gt;&lt;a href=&quot;current_exception&quot;&gt;std::current_exception&lt;/a&gt;&lt;/code&gt; , захватывая текущий обработанный объект исключения, если таковой имеется, в &lt;code&gt;&lt;a href=&quot;exception_ptr&quot;&gt;std::exception_ptr&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1ce6265115b5fdfcaa76a7165b74faf9d8dacb2e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;../types/is_base_of&quot;&gt;std::is_base_of&lt;/a&gt;&amp;lt;T, &lt;a href=&quot;../types/remove_reference&quot;&gt;std::remove_reference_t&lt;/a&gt;&amp;lt;decltype(t1)&amp;gt;&amp;gt;::value&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, then &lt;code&gt;INVOKE(f, t1)&lt;/code&gt; is equivalent to &lt;code&gt;t1.*f&lt;/code&gt;</source>
          <target state="translated">Если &lt;code&gt;&lt;a href=&quot;../types/is_base_of&quot;&gt;std::is_base_of&lt;/a&gt;&amp;lt;T, &lt;a href=&quot;../types/remove_reference&quot;&gt;std::remove_reference_t&lt;/a&gt;&amp;lt;decltype(t1)&amp;gt;&amp;gt;::value&lt;/code&gt; имеет значение &lt;code&gt;true&lt;/code&gt; , то &lt;code&gt;INVOKE(f, t1)&lt;/code&gt; эквивалентно &lt;code&gt;t1.*f&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2f34e8cfb2a1707ab37515e5a9bdd7f9c647abe3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;../types/is_base_of&quot;&gt;std::is_base_of&lt;/a&gt;&amp;lt;T, &lt;a href=&quot;../types/remove_reference&quot;&gt;std::remove_reference_t&lt;/a&gt;&amp;lt;decltype(t1)&amp;gt;&amp;gt;::value&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, then &lt;code&gt;INVOKE(f, t1, t2, ..., tN)&lt;/code&gt; is equivalent to &lt;code&gt;(t1.*f)(t2, ..., tN)&lt;/code&gt;</source>
          <target state="translated">Если &lt;code&gt;&lt;a href=&quot;../types/is_base_of&quot;&gt;std::is_base_of&lt;/a&gt;&amp;lt;T, &lt;a href=&quot;../types/remove_reference&quot;&gt;std::remove_reference_t&lt;/a&gt;&amp;lt;decltype(t1)&amp;gt;&amp;gt;::value&lt;/code&gt; имеет значение &lt;code&gt;true&lt;/code&gt; , то &lt;code&gt;INVOKE(f, t1, t2, ..., tN)&lt;/code&gt; эквивалентно &lt;code&gt;(t1.*f)(t2, ..., tN)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6bcb63cc68623b4a13fa5b83d65086795b276b60" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;../types/is_destructible&quot;&gt;std::is_trivially_destructible_v&lt;/a&gt;&amp;lt;T1&amp;gt; &amp;amp;&amp;amp; &lt;a href=&quot;../types/is_destructible&quot;&gt;std::is_trivially_destructible_v&lt;/a&gt;&amp;lt;T2&amp;gt;&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, the destructor of &lt;code&gt;pair&lt;/code&gt; is trivial.</source>
          <target state="translated">Если &lt;code&gt;&lt;a href=&quot;../types/is_destructible&quot;&gt;std::is_trivially_destructible_v&lt;/a&gt;&amp;lt;T1&amp;gt; &amp;amp;&amp;amp; &lt;a href=&quot;../types/is_destructible&quot;&gt;std::is_trivially_destructible_v&lt;/a&gt;&amp;lt;T2&amp;gt;&lt;/code&gt; равно &lt;code&gt;true&lt;/code&gt; , деструктор &lt;code&gt;pair&lt;/code&gt; тривиален.</target>
        </trans-unit>
        <trans-unit id="e1f522d5a7a2b7024a237d287703f33d30c5ccd6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;../unique_ptr&quot;&gt;std::unique_ptr&lt;/a&gt;&amp;lt;Y, D&amp;gt;::pointer&lt;/code&gt; is a pointer to a character type (e.g., when &lt;code&gt;Y&lt;/code&gt; is &lt;code&gt;char&lt;/code&gt; or &lt;code&gt;char[]&lt;/code&gt; or &lt;code&gt;CharT&lt;/code&gt;), this may end up calling the &lt;a href=&quot;../../io/basic_ostream/operator_ltlt2&quot;&gt;overloads of &lt;code&gt;operator&amp;lt;&amp;lt;&lt;/code&gt; for null-terminated character strings&lt;/a&gt; (causing undefined behavior if the pointer does not in fact point to such a string), rather than &lt;a href=&quot;../../io/basic_ostream/operator_ltlt&quot;&gt;the overload for printing the value of the pointer itself&lt;/a&gt;.</source>
          <target state="translated">Если &lt;code&gt;&lt;a href=&quot;../unique_ptr&quot;&gt;std::unique_ptr&lt;/a&gt;&amp;lt;Y, D&amp;gt;::pointer&lt;/code&gt; является указателем на тип символа (например, когда &lt;code&gt;Y&lt;/code&gt; является &lt;code&gt;char&lt;/code&gt; или &lt;code&gt;char[]&lt;/code&gt; или &lt;code&gt;CharT&lt;/code&gt; ), это может в конечном итоге вызвать &lt;a href=&quot;../../io/basic_ostream/operator_ltlt2&quot;&gt;перегрузки &lt;code&gt;operator&amp;lt;&amp;lt;&lt;/code&gt; для завершенного &lt;/a&gt;нулями символьные строки (вызывающие неопределенное поведение, если указатель фактически не указывает на такую ​​строку), а не &lt;a href=&quot;../../io/basic_ostream/operator_ltlt&quot;&gt;перегрузка для печати значения самого указателя&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f98e0f7ef82d28588de46aaf4b7958b9880eea5d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;empty&quot;&gt;empty()&lt;/a&gt;&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt;, the pointer is a non-null pointer that should not be dereferenced.</source>
          <target state="translated">Если &lt;code&gt;&lt;a href=&quot;empty&quot;&gt;empty()&lt;/a&gt;&lt;/code&gt; возвращает &lt;code&gt;true&lt;/code&gt; , указатель является ненулевым указателем, который не должен быть разыменован.</target>
        </trans-unit>
        <trans-unit id="7608858d123991a3d0370b23e31edd9570a303db" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;empty&quot;&gt;empty()&lt;/a&gt;&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt;, the pointer points to a single null character.</source>
          <target state="translated">Если &lt;code&gt;&lt;a href=&quot;empty&quot;&gt;empty()&lt;/a&gt;&lt;/code&gt; возвращает &lt;code&gt;true&lt;/code&gt; , указатель указывает на один нулевой символ.</target>
        </trans-unit>
        <trans-unit id="5881678af232e47a5ff281e340e3ff360633c7fc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;imbue&quot;&gt;imbue()&lt;/a&gt;&lt;/code&gt; has been never called for this object, then the global locale at the time of the call is returned. Otherwise, the locale passed to the last call to &lt;code&gt;&lt;a href=&quot;imbue&quot;&gt;imbue()&lt;/a&gt;&lt;/code&gt; is returned.</source>
          <target state="translated">Если &lt;code&gt;&lt;a href=&quot;imbue&quot;&gt;imbue()&lt;/a&gt;&lt;/code&gt; никогда не вызывался для этого объекта, то возвращается глобальная локаль на момент вызова. В противном случае языковой стандарт передается последнему вызову &lt;code&gt;&lt;a href=&quot;imbue&quot;&gt;imbue()&lt;/a&gt;&lt;/code&gt; возвращается .</target>
        </trans-unit>
        <trans-unit id="8a3196e43b35b6c3a7ee5a0b4c3620496db3d617" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;rdbuf&quot;&gt;rdbuf()&lt;/a&gt;&lt;/code&gt; is a null pointer (i.e. there is no associated stream buffer), then &lt;code&gt;state | badbit&lt;/code&gt; is assigned. May throw an exception.</source>
          <target state="translated">Если &lt;code&gt;&lt;a href=&quot;rdbuf&quot;&gt;rdbuf()&lt;/a&gt;&lt;/code&gt; является нулевым указателем (т. Е. Нет ассоциированного потокового буфера), то &lt;code&gt;state | badbit&lt;/code&gt; назначен. Может бросить исключение.</target>
        </trans-unit>
        <trans-unit id="115f73826b05df3cd915bd8b19cd251d9d51edc4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;str&quot;&gt;str()&lt;/a&gt;&lt;/code&gt; was called on a dynamic ostrstream and &lt;a href=&quot;freeze&quot;&gt;freeze(false)&lt;/a&gt; was not called after that, this destructor leaks memory.</source>
          <target state="translated">Если &lt;code&gt;&lt;a href=&quot;str&quot;&gt;str()&lt;/a&gt;&lt;/code&gt; вызывался для динамического ostrstream, а &lt;a href=&quot;freeze&quot;&gt;freeze (false)&lt;/a&gt; не вызывался после этого, этот деструктор теряет память.</target>
        </trans-unit>
        <trans-unit id="bbdbfef825b7d3601eff06aaad9cae9874a72eb6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;str&quot;&gt;str()&lt;/a&gt;&lt;/code&gt; was called on a dynamic strstream and &lt;a href=&quot;freeze&quot;&gt;freeze(false)&lt;/a&gt; was not called after that, this destructor leaks memory.</source>
          <target state="translated">Если &lt;code&gt;&lt;a href=&quot;str&quot;&gt;str()&lt;/a&gt;&lt;/code&gt; был вызван для динамического strstream, а &lt;a href=&quot;freeze&quot;&gt;freeze (false)&lt;/a&gt; не был вызван после этого, этот деструктор теряет память.</target>
        </trans-unit>
        <trans-unit id="478414339a40be92fc6757b885d21490b9c2c06c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;str&quot;&gt;str()&lt;/a&gt;&lt;/code&gt; was called on a dynamic strstream and &lt;code&gt;&lt;a href=&quot;freeze&quot;&gt;freeze(false)&lt;/a&gt;&lt;/code&gt; was not called after that, this destructor leaks memory.</source>
          <target state="translated">Если &lt;code&gt;&lt;a href=&quot;str&quot;&gt;str()&lt;/a&gt;&lt;/code&gt; был вызван для динамического strstream, а &lt;code&gt;&lt;a href=&quot;freeze&quot;&gt;freeze(false)&lt;/a&gt;&lt;/code&gt; не был вызван после этого, этот деструктор теряет память.</target>
        </trans-unit>
        <trans-unit id="28514525eb04de0df8ae0bd7f4815fcf5c0b385a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;uses_allocator&quot;&gt;std::uses_allocator_v&lt;/a&gt;&amp;lt;T, Alloc&amp;gt;&lt;/code&gt; is false and &lt;code&gt;&lt;a href=&quot;../types/is_constructible&quot;&gt;std::is_constructible_v&lt;/a&gt;&amp;lt;T, Args...&amp;gt;&lt;/code&gt; is true, returns &lt;code&gt;&lt;a href=&quot;../utility/tuple/forward_as_tuple&quot;&gt;std::forward_as_tuple&lt;/a&gt;(&lt;a href=&quot;../utility/forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;Args&amp;gt;(args)...)&lt;/code&gt;</source>
          <target state="translated">Если &lt;code&gt;&lt;a href=&quot;uses_allocator&quot;&gt;std::uses_allocator_v&lt;/a&gt;&amp;lt;T, Alloc&amp;gt;&lt;/code&gt; имеет значение false и &lt;code&gt;&lt;a href=&quot;../types/is_constructible&quot;&gt;std::is_constructible_v&lt;/a&gt;&amp;lt;T, Args...&amp;gt;&lt;/code&gt; имеет значение true, возвращает &lt;code&gt;&lt;a href=&quot;../utility/tuple/forward_as_tuple&quot;&gt;std::forward_as_tuple&lt;/a&gt;(&lt;a href=&quot;../utility/forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;Args&amp;gt;(args)...)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1eaf847410a4fe8abec9f71211445a94385c0d80" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;A::propagate_on_container_copy_assignment::value&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, then &lt;code&gt;A&lt;/code&gt; must satisfy &lt;a href=&quot;copyassignable&quot;&gt;CopyAssignable&lt;/a&gt; and the copy operation must not throw exceptions</source>
          <target state="translated">Если &lt;code&gt;A::propagate_on_container_copy_assignment::value&lt;/code&gt; &lt;a href=&quot;copyassignable&quot;&gt;spreadate_on_container_copy_assignment &lt;/a&gt;:: value имеет значение &lt;code&gt;true&lt;/code&gt; , тогда &lt;code&gt;A&lt;/code&gt; должен удовлетворять CopyAssignable, а операция копирования не должна вызывать исключения</target>
        </trans-unit>
        <trans-unit id="53014a7b4b50d8ae84406194de8be90fc34e0d34" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;A::propagate_on_container_move_assignment::value&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, then &lt;code&gt;A&lt;/code&gt; must satisfy &lt;a href=&quot;moveassignable&quot;&gt;MoveAssignable&lt;/a&gt; and the move operation must not throw exceptions.</source>
          <target state="translated">Если &lt;code&gt;A::propagate_on_container_move_assignment::value&lt;/code&gt; &lt;a href=&quot;moveassignable&quot;&gt;spreadate_on_container_move_assignment &lt;/a&gt;:: value имеет значение &lt;code&gt;true&lt;/code&gt; , тогда &lt;code&gt;A&lt;/code&gt; должен удовлетворять MoveAssignable и операция перемещения не должна генерировать исключения.</target>
        </trans-unit>
        <trans-unit id="39a1f82ebac72503acedbfb5e0cc69d3fea6e2da" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;A::propagate_on_container_swap::value&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, lvalues of &lt;code&gt;A&lt;/code&gt; must be &lt;a href=&quot;swappable&quot;&gt;Swappable&lt;/a&gt; and the swap operation must not throw exceptions</source>
          <target state="translated">Если &lt;code&gt;A::propagate_on_container_swap::value&lt;/code&gt; является &lt;code&gt;true&lt;/code&gt; , lvalues из &lt;code&gt;A&lt;/code&gt; должен быть &lt;a href=&quot;swappable&quot;&gt;Swappable&lt;/a&gt; и операция своп не должны бросать исключения</target>
        </trans-unit>
        <trans-unit id="930ae60370eac3920b61ed4930312cdb72190d0f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;A&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;../memory/allocator&quot;&gt;std::allocator&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt;, then this will call placement-new, as by &lt;code&gt;::new((void*)p) T(rv)&lt;/code&gt;. This effectively requires &lt;code&gt;T&lt;/code&gt; to be move constructible.</source>
          <target state="translated">Если &lt;code&gt;A&lt;/code&gt; - это &lt;code&gt;&lt;a href=&quot;../memory/allocator&quot;&gt;std::allocator&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt; , то это вызовет Placement-new, как и by &lt;code&gt;::new((void*)p) T(rv)&lt;/code&gt; . Это фактически требует, чтобы &lt;code&gt;T&lt;/code&gt; был перемещаемым.</target>
        </trans-unit>
        <trans-unit id="a6edb79bda8a280ffb6fcbbc9ba3defcf2428641" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;A&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;../memory/allocator&quot;&gt;std::allocator&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt;, then this will call placement-new, as by &lt;code&gt;::new((void*)p) T(v)&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;A&lt;/code&gt; - это &lt;code&gt;&lt;a href=&quot;../memory/allocator&quot;&gt;std::allocator&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt; , то это вызовет Placement-new, как и by &lt;code&gt;::new((void*)p) T(v)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="eb858ecd848dc52275e556ff876a7f61bbd34174" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;A&lt;/code&gt; is a reference type, it is replaced by the type referred to</source>
          <target state="translated">Если &lt;code&gt;A&lt;/code&gt; является ссылочным типом, он заменяется указанным типом</target>
        </trans-unit>
        <trans-unit id="b3c213b81227b94ede964107b48a991995b38510" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;A&lt;/code&gt; is cv-qualified, &lt;code&gt;A&lt;/code&gt; is replaced with cv-unqualified version of itself</source>
          <target state="translated">Если &lt;code&gt;A&lt;/code&gt; является cv-квалифицированным, &lt;code&gt;A&lt;/code&gt; заменяется cv-неквалифицированной версией самого себя</target>
        </trans-unit>
        <trans-unit id="5d95d66680ab1fe42693574faecc757445aabf8d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;A&lt;/code&gt; is cv-qualified, the top-level cv-qualifiers are ignored. If &lt;code&gt;A&lt;/code&gt; is a reference type, the referred type is used by deduction.</source>
          <target state="translated">Если &lt;code&gt;A&lt;/code&gt; является cv-квалифицированным, cv-квалификаторы верхнего уровня игнорируются. Если &lt;code&gt;A&lt;/code&gt; является ссылочным типом, указанный тип используется путем вычета.</target>
        </trans-unit>
        <trans-unit id="dbb888d618ec657b4fdce4930acdf4d77c7df288" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;A&lt;/code&gt; was lvalue reference and &lt;code&gt;P&lt;/code&gt; was rvalue reference, A is considered to be more specialized than P</source>
          <target state="translated">Если &lt;code&gt;A&lt;/code&gt; была ссылкой lvalue, а &lt;code&gt;P&lt;/code&gt; была ссылкой rvalue, A считается более специализированным, чем P</target>
        </trans-unit>
        <trans-unit id="a0457548dadf8dfad5e452b8705d672e063c513a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;A&lt;/code&gt; was more cv-qualified than &lt;code&gt;P&lt;/code&gt;, A is considered to be more specialized than P</source>
          <target state="translated">Если &lt;code&gt;A&lt;/code&gt; был более квалифицированным, чем &lt;code&gt;P&lt;/code&gt; , то A считается более специализированным, чем P</target>
        </trans-unit>
        <trans-unit id="164bc5f2461c5b557de9ec3b7a0a95d7ca7b6398" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;B&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, &lt;code&gt;std::enable_if&lt;/code&gt; has a public member typedef &lt;code&gt;type&lt;/code&gt;, equal to &lt;code&gt;T&lt;/code&gt;; otherwise, there is no member typedef.</source>
          <target state="translated">Если &lt;code&gt;B&lt;/code&gt; является &lt;code&gt;true&lt;/code&gt; , &lt;code&gt;std::enable_if&lt;/code&gt; имеет открытый член ЬурейеГо &lt;code&gt;type&lt;/code&gt; , равный &lt;code&gt;T&lt;/code&gt; ; в противном случае, нет члена typedef.</target>
        </trans-unit>
        <trans-unit id="84997cfae0e3bc373338233f13fc51673ecc94bd" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;C&lt;/code&gt; is defined, for each constructor (or constructor template) &lt;code&gt;Ci&lt;/code&gt; declared in the named primary template (if it is defined), a fictional function template &lt;code&gt;Fi&lt;/code&gt;, is constructed, such that</source>
          <target state="translated">Если &lt;code&gt;C&lt;/code&gt; определен, для каждого конструктора (или шаблона конструктора) &lt;code&gt;Ci&lt;/code&gt; , объявленного в названном первичном шаблоне (если он определен), вымышленный шаблон функции &lt;code&gt;Fi&lt;/code&gt; , что</target>
        </trans-unit>
        <trans-unit id="cc1e774dd0f46e4682b7e19d8770ddcc69c901f6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;C&lt;/code&gt; is not defined or does not declare any constructors, an additional fictional function template is added, derived as above from a hypothetical constructor &lt;code&gt;C()&lt;/code&gt;</source>
          <target state="translated">Если &lt;code&gt;C&lt;/code&gt; не определен или не объявляет никаких конструкторов, добавляется дополнительный шаблон вымышленной функции, полученный, как указано выше, из гипотетического конструктора &lt;code&gt;C()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="61f6db7fe67ce601045229a53fee7ef72360c40c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Count&lt;/code&gt; is not &lt;code&gt;std::dynamic_extent&lt;/code&gt;, &lt;code&gt;Count&lt;/code&gt;;</source>
          <target state="translated">Если &lt;code&gt;Count&lt;/code&gt; не является &lt;code&gt;std::dynamic_extent&lt;/code&gt; , &lt;code&gt;Count&lt;/code&gt; ;</target>
        </trans-unit>
        <trans-unit id="e1dc222d7a60755a2201700bb9fa727680a8b6d6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;D&lt;/code&gt; is a reference type and the second overload is chosen, the program is ill-formed.</source>
          <target state="translated">Если &lt;code&gt;D&lt;/code&gt; является ссылочным типом и выбрана вторая перегрузка, программа некорректна.</target>
        </trans-unit>
        <trans-unit id="f9c0db03f2072cdef42cb4c9c11cc3231d111137" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;D&lt;/code&gt; is a reference type, the second overload is defined as deleted. These overloads only participate in overload resolution if &lt;code&gt;&lt;a href=&quot;../../types/is_constructible&quot;&gt;std::is_constructible&lt;/a&gt;&amp;lt;D, decltype(d)&amp;gt;::value&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;. The program is ill-formed if either of these two constructors is selected by &lt;a href=&quot;../../language/deduction_guide&quot;&gt;class template argument deduction&lt;/a&gt;.</source>
          <target state="translated">Если &lt;code&gt;D&lt;/code&gt; является ссылочным типом, вторая перегрузка определяется как удаленная. Эти перегрузки участвуют только в разрешении перегрузки, если &lt;code&gt;&lt;a href=&quot;../../types/is_constructible&quot;&gt;std::is_constructible&lt;/a&gt;&amp;lt;D, decltype(d)&amp;gt;::value&lt;/code&gt; имеет значение &lt;code&gt;true&lt;/code&gt; . Программа некорректна, если любой из этих двух конструкторов выбран путем &lt;a href=&quot;../../language/deduction_guide&quot;&gt;вывода аргумента шаблона класса&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d6d1f97a0f5c5a0f55060c5fcf0db428c8650e18" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Deleter&lt;/code&gt; is a reference type, equivalent to &lt;code&gt;shared_ptr(r.release(), &lt;a href=&quot;../../utility/functional/ref&quot;&gt;std::ref&lt;/a&gt;(r.get_deleter())&lt;/code&gt;. Otherwise, equivalent to &lt;code&gt;shared_ptr(r.release(), r.get_deleter())&lt;/code&gt;</source>
          <target state="translated">Если &lt;code&gt;Deleter&lt;/code&gt; является ссылочным типом, эквивалентным &lt;code&gt;shared_ptr(r.release(), &lt;a href=&quot;../../utility/functional/ref&quot;&gt;std::ref&lt;/a&gt;(r.get_deleter())&lt;/code&gt; . В противном случае эквивалентен &lt;code&gt;shared_ptr(r.release(), r.get_deleter())&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e307062451ff2a7a85e243f182577d712be79ad5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Deleter&lt;/code&gt; is a reference type, requires that &lt;code&gt;std::remove_reference&amp;lt;Deleter&amp;gt;::type&lt;/code&gt; is nothrow-&lt;a href=&quot;../../named_req/copyassignable&quot;&gt;CopyAssignable&lt;/a&gt;.</source>
          <target state="translated">Если &lt;code&gt;Deleter&lt;/code&gt; является ссылочным типом, требует, чтобы &lt;code&gt;std::remove_reference&amp;lt;Deleter&amp;gt;::type&lt;/code&gt; был nothrow- &lt;a href=&quot;../../named_req/copyassignable&quot;&gt;CopyAssignable&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="765f5fc1e61e543452d73e1fb0814a6856e4589a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Deleter&lt;/code&gt; is not a reference type, requires that it is nothrow-&lt;a href=&quot;../../named_req/moveassignable&quot;&gt;MoveAssignable&lt;/a&gt;.</source>
          <target state="translated">Если &lt;code&gt;Deleter&lt;/code&gt; не является ссылочным типом, требуется, чтобы он не был выполнен как &lt;a href=&quot;../../named_req/moveassignable&quot;&gt;MoveAssignable&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1aa2f10aa226cd93b28fcf97d03c1ee958d0bbf0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Derived&lt;/code&gt; is &lt;a href=&quot;objects#Polymorphic_objects&quot;&gt;polymorphic&lt;/a&gt;, such pointer may be used to make &lt;a href=&quot;virtual&quot;&gt;virtual function calls&lt;/a&gt;.</source>
          <target state="translated">Если &lt;code&gt;Derived&lt;/code&gt; является &lt;a href=&quot;objects#Polymorphic_objects&quot;&gt;полиморфным&lt;/a&gt; , такой указатель может использоваться для &lt;a href=&quot;virtual&quot;&gt;вызова виртуальных функций&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3aeb6cf5a7fd827d219cf1ec41be16033ed0d80b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Derived&lt;/code&gt; is derived from &lt;code&gt;Base&lt;/code&gt; or if both are the same non-union class (in both cases ignoring cv-qualification), provides the member constant &lt;code&gt;value&lt;/code&gt; equal to &lt;code&gt;true&lt;/code&gt;. Otherwise &lt;code&gt;value&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;Derived&lt;/code&gt; является производным от &lt;code&gt;Base&lt;/code&gt; или оба являются одним и тем же классом без объединения (в обоих случаях игнорируется квалификация cv), &lt;code&gt;value&lt;/code&gt; константы члена равно &lt;code&gt;true&lt;/code&gt; . В противном случае &lt;code&gt;value&lt;/code&gt; является &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6ebd268ac27013dab52c304d8fe0d856e345f4dd" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;E2&lt;/code&gt; is not a mutable member, the &lt;a href=&quot;cv&quot;&gt;cv-qualification&lt;/a&gt; of the result is the union of the cv-qualifications of &lt;code&gt;E1&lt;/code&gt; and &lt;code&gt;E2&lt;/code&gt;, otherwise (if &lt;code&gt;E2&lt;/code&gt; is a mutable member), it is the union of the volatile-qualifications of &lt;code&gt;E1&lt;/code&gt; and &lt;code&gt;E2&lt;/code&gt;;</source>
          <target state="translated">Если &lt;code&gt;E2&lt;/code&gt; не является изменяемым членом, &lt;a href=&quot;cv&quot;&gt;cv-квалификация&lt;/a&gt; результата представляет собой объединение cv-квалификаций &lt;code&gt;E1&lt;/code&gt; и &lt;code&gt;E2&lt;/code&gt; , в противном случае (если &lt;code&gt;E2&lt;/code&gt; является изменяемым членом), это объединение volatile-квалификаций &lt;code&gt;E1&lt;/code&gt; и &lt;code&gt;E2&lt;/code&gt; ;</target>
        </trans-unit>
        <trans-unit id="1cf4d112436b803bd3d27d42c800897ab593f0ae" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;E&lt;/code&gt; in a &lt;a href=&quot;operator_other#Built-in_function_call_operator&quot;&gt;function call expression&lt;/a&gt;&lt;code&gt;E(args)&lt;/code&gt; has class type cv &lt;code&gt;T&lt;/code&gt;, then.</source>
          <target state="translated">Если &lt;code&gt;E&lt;/code&gt; в &lt;a href=&quot;operator_other#Built-in_function_call_operator&quot;&gt;выражении вызова функции &lt;/a&gt; &lt;code&gt;E(args)&lt;/code&gt; имеет тип класса cv &lt;code&gt;T&lt;/code&gt; , то.</target>
        </trans-unit>
        <trans-unit id="1b8acc70084ea7a5796bb6ffccc7d45f74616a97" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;E&lt;/code&gt; in a &lt;a href=&quot;operator_other#Built-in_function_call_operator&quot;&gt;function call expression&lt;/a&gt;&lt;code&gt;E(args)&lt;/code&gt; names a set of overloaded functions and/or function templates (but not callable objects), the following rules are followed:</source>
          <target state="translated">Если &lt;code&gt;E&lt;/code&gt; в &lt;a href=&quot;operator_other#Built-in_function_call_operator&quot;&gt;выражении вызова функции &lt;/a&gt; &lt;code&gt;E(args)&lt;/code&gt; называет набор перегруженных функций и / или шаблонов функций (но не вызываемых объектов), соблюдаются следующие правила:</target>
        </trans-unit>
        <trans-unit id="8b40eb284409f27422ea732b684b0f26cb4eef16" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;E&lt;/code&gt; is not a polymorphic class type, or if &lt;code&gt;&lt;a href=&quot;nested_exception&quot;&gt;std::nested_exception&lt;/a&gt;&lt;/code&gt; is an inaccessible or ambiguous base class of &lt;code&gt;E&lt;/code&gt;, there is no effect.</source>
          <target state="translated">Если &lt;code&gt;E&lt;/code&gt; не является полиморфным типом класса или &lt;code&gt;&lt;a href=&quot;nested_exception&quot;&gt;std::nested_exception&lt;/a&gt;&lt;/code&gt; является недоступным или неоднозначным базовым классом &lt;code&gt;E&lt;/code&gt; , никакого эффекта не будет.</target>
        </trans-unit>
        <trans-unit id="cfb9795d2d85864a23dfb415d8a0b25b1a06bb2b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;E&lt;/code&gt; specifies a member function, it may be virtual, in which case the final overrider of that function will be called, using dynamic dispatch at runtime.</source>
          <target state="translated">Если &lt;code&gt;E&lt;/code&gt; указывает функцию-член, она может быть виртуальной, и в этом случае будет вызываться окончательный переопределитель этой функции с использованием динамической диспетчеризации во время выполнения.</target>
        </trans-unit>
        <trans-unit id="7460d26bd30ccf50bedaefeb690ddad0b62aa2b3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Hash::transparent_key_equal&lt;/code&gt; exists and names a type, then &lt;code&gt;Hash::transparent_key_equal::is_transparent&lt;/code&gt; must be valid and name a type, and &lt;code&gt;Pred&lt;/code&gt; must be either &lt;code&gt;Hash::transparent_key_equal&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;../utility/functional/equal_to&quot;&gt;std::equal_to&lt;/a&gt;&amp;lt;Key&amp;gt;&lt;/code&gt; (the program is ill-formed otherwise).</source>
          <target state="translated">Если &lt;code&gt;Hash::transparent_key_equal&lt;/code&gt; существует и &lt;code&gt;Hash::transparent_key_equal::is_transparent&lt;/code&gt; имя типу, то Hash :: transparent_key_equal :: is_transparent должен быть действительным и указывать тип, а &lt;code&gt;Pred&lt;/code&gt; должен быть либо &lt;code&gt;Hash::transparent_key_equal&lt;/code&gt; , либо &lt;code&gt;&lt;a href=&quot;../utility/functional/equal_to&quot;&gt;std::equal_to&lt;/a&gt;&amp;lt;Key&amp;gt;&lt;/code&gt; (программа не работает сформировано иначе).</target>
        </trans-unit>
        <trans-unit id="e746872b3f4a32e36e22866e57c3635973587c0c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;InputIt&lt;/code&gt; is an integral type, equivalent to &lt;code&gt;basic_string(static_cast&amp;lt;size_type&amp;gt;(first), static_cast&amp;lt;value_type&amp;gt;(last), a)&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;InputIt&lt;/code&gt; является целочисленным типом, эквивалентным &lt;code&gt;basic_string(static_cast&amp;lt;size_type&amp;gt;(first), static_cast&amp;lt;value_type&amp;gt;(last), a)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="236dbe55a4e3dcd17001ed4b1e01a9528c512d6b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;InputIt&lt;/code&gt; is not &lt;a href=&quot;../named_req/randomaccessiterator&quot;&gt;LegacyRandomAccessIterator&lt;/a&gt;, the behavior is undefined if &lt;code&gt;last&lt;/code&gt; is not reachable from &lt;code&gt;first&lt;/code&gt; by (possibly repeatedly) incrementing &lt;code&gt;first&lt;/code&gt;. If &lt;code&gt;InputIt&lt;/code&gt; is &lt;a href=&quot;../named_req/randomaccessiterator&quot;&gt;LegacyRandomAccessIterator&lt;/a&gt;, the behavior is undefined if &lt;code&gt;last&lt;/code&gt; is not reachable from &lt;code&gt;first&lt;/code&gt; and &lt;code&gt;first&lt;/code&gt; is not reachable from &lt;code&gt;last&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;InputIt&lt;/code&gt; не является &lt;a href=&quot;../named_req/randomaccessiterator&quot;&gt;LegacyRandomAccessIterator&lt;/a&gt; , поведение не определено, если &lt;code&gt;last&lt;/code&gt; не достижимо с &lt;code&gt;first&lt;/code&gt; (возможно, многократно), увеличивая &lt;code&gt;first&lt;/code&gt; . Если &lt;code&gt;InputIt&lt;/code&gt; равен &lt;a href=&quot;../named_req/randomaccessiterator&quot;&gt;LegacyRandomAccessIterator&lt;/a&gt; , поведение не определено, если &lt;code&gt;last&lt;/code&gt; недостижим из &lt;code&gt;first&lt;/code&gt; а &lt;code&gt;first&lt;/code&gt; недостижим из &lt;code&gt;last&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e7c4d085e7ff79e59c030b2b8c81a1702c66b3ca" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;InputIt&lt;/code&gt; satisfies &lt;a href=&quot;../named_req/forwarditerator&quot;&gt;LegacyForwardIterator&lt;/a&gt;, this function rereads the input in order to detect duplicates.</source>
          <target state="translated">Если &lt;code&gt;InputIt&lt;/code&gt; удовлетворяет &lt;a href=&quot;../named_req/forwarditerator&quot;&gt;LegacyForwardIterator&lt;/a&gt; , эта функция перечитывает ввод для обнаружения дубликатов.</target>
        </trans-unit>
        <trans-unit id="c3749207d2ce68de1c41a9f49f0c2035e0f8ee1f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Iter&lt;/code&gt; does not have &lt;code&gt;pointer&lt;/code&gt;, but has all other four member types, then the member types are declared as follows:</source>
          <target state="translated">Если у &lt;code&gt;Iter&lt;/code&gt; нет &lt;code&gt;pointer&lt;/code&gt; , но есть все остальные четыре типа членов, то типы членов объявляются следующим образом:</target>
        </trans-unit>
        <trans-unit id="2654ba55a6d218cab7ca7778bb155b247c0f52ec" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Iter&lt;/code&gt; does not have all five member types &lt;code&gt;difference_type&lt;/code&gt;, &lt;code&gt;value_type&lt;/code&gt;, &lt;code&gt;pointer&lt;/code&gt;, &lt;code&gt;reference&lt;/code&gt;, and &lt;code&gt;iterator_category&lt;/code&gt;, then this template has no members by any of those names (&lt;code&gt;std::iterator_traits&lt;/code&gt; is SFINAE-friendly).</source>
          <target state="translated">Если &lt;code&gt;Iter&lt;/code&gt; не все пять типов членов &lt;code&gt;difference_type&lt;/code&gt; , &lt;code&gt;value_type&lt;/code&gt; , &lt;code&gt;pointer&lt;/code&gt; , &lt;code&gt;reference&lt;/code&gt; , и &lt;code&gt;iterator_category&lt;/code&gt; , тогда этот шаблон не имеет членов от любого из этих имен ( &lt;code&gt;std::iterator_traits&lt;/code&gt; является SFINAE людей).</target>
        </trans-unit>
        <trans-unit id="f45e1c1900c90ccc18a25b3d04a0c5ca7a8286f2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;N&lt;/code&gt; is &lt;code&gt;std::dynamic_extent&lt;/code&gt;, the extent of the returned span &lt;code&gt;S&lt;/code&gt; is also &lt;code&gt;std::dynamic_extent&lt;/code&gt;; otherwise it is &lt;code&gt;sizeof(T) * N&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;N&lt;/code&gt; равно &lt;code&gt;std::dynamic_extent&lt;/code&gt; , экстент возвращаемого диапазона &lt;code&gt;S&lt;/code&gt; также равен &lt;code&gt;std::dynamic_extent&lt;/code&gt; ; в противном случае это &lt;code&gt;sizeof(T) * N&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="347ac408b6a94a1c447cd287529327ba6fa3d9ac" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;NDEBUG&lt;/code&gt; is defined as a macro name at the point in the source code where &lt;code&gt;&amp;lt;cassert&amp;gt;&lt;/code&gt; is included, then &lt;code&gt;assert&lt;/code&gt; does nothing.</source>
          <target state="translated">Если &lt;code&gt;NDEBUG&lt;/code&gt; определен как имя макроса в той точке исходного кода, в &lt;code&gt;&amp;lt;cassert&amp;gt;&lt;/code&gt; включен &amp;lt;cassert&amp;gt; , тогда &lt;code&gt;assert&lt;/code&gt; ничего не делает.</target>
        </trans-unit>
        <trans-unit id="f059b210d4e1ce59a4454923ec15e6398050571e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;NDEBUG&lt;/code&gt; is not defined, then &lt;code&gt;assert&lt;/code&gt; checks if its argument (which must have scalar type) compares equal to zero. If it does, &lt;code&gt;assert&lt;/code&gt; outputs implementation-specific diagnostic information on the standard error output and calls &lt;code&gt;&lt;a href=&quot;../utility/program/abort&quot;&gt;std::abort&lt;/a&gt;&lt;/code&gt;. The diagnostic information is required to include the text of &lt;code&gt;expression&lt;/code&gt;, as well as the values of the standard macros &lt;code&gt;__FILE__&lt;/code&gt;, &lt;code&gt;__LINE__&lt;/code&gt;, and the standard variable &lt;code&gt;__func__&lt;/code&gt;(since C++11).</source>
          <target state="translated">Если &lt;code&gt;NDEBUG&lt;/code&gt; не определен, тогда &lt;code&gt;assert&lt;/code&gt; проверяет, совпадает ли его аргумент (который должен иметь скалярный тип) с нулем. Если это так, &lt;code&gt;assert&lt;/code&gt; выводит диагностическую информацию, специфичную для реализации, на стандартный вывод ошибок и вызывает &lt;code&gt;&lt;a href=&quot;../utility/program/abort&quot;&gt;std::abort&lt;/a&gt;&lt;/code&gt; . Диагностическая информация должна содержать текст &lt;code&gt;expression&lt;/code&gt; , а также значения стандартных макросов &lt;code&gt;__FILE__&lt;/code&gt; , &lt;code&gt;__LINE__&lt;/code&gt; и стандартной переменной &lt;code&gt;__func__&lt;/code&gt; (начиная с C ++ 11).</target>
        </trans-unit>
        <trans-unit id="bf81f02b0ae53877b2da220b99b70dbdc5bf8ca4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;P&lt;/code&gt; has one of the forms that include a function parameter list &lt;code&gt;(T)&lt;/code&gt;, then each parameter &lt;code&gt;P&lt;/code&gt;i from that list is compared with the corresponding argument &lt;code&gt;A&lt;/code&gt;i from &lt;code&gt;A&lt;/code&gt;'s function parameter list. If the last &lt;code&gt;P&lt;/code&gt;i is a pack expansion, then its declarator is compared with each remaining &lt;code&gt;A&lt;/code&gt;i in the parameter type list of &lt;code&gt;A&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;P&lt;/code&gt; имеет одну из форм, которые включают список параметров функции &lt;code&gt;(T)&lt;/code&gt; , то каждый параметр &lt;code&gt;P&lt;/code&gt; i из этого списка сравнивается с соответствующим аргументом &lt;code&gt;A&lt;/code&gt; i из списка параметров функции &lt;code&gt;A&lt;/code&gt; . Если последний &lt;code&gt;P&lt;/code&gt; я это пакет расширение, то его описатель сравнивается с каждым оставшимся &lt;code&gt;A&lt;/code&gt; я в списке параметра типа &lt;code&gt;A&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="03e7b27c0c840fc6ec6677dbe04f78b9c1de1735" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;P&lt;/code&gt; has one of the forms that include a template parameter list &lt;code&gt;&amp;lt;T&amp;gt;&lt;/code&gt; or &lt;code&gt;&amp;lt;I&amp;gt;&lt;/code&gt;, then each element &lt;code&gt;P&lt;/code&gt;i of that template argument list is matched against the corresponding template argument &lt;code&gt;A&lt;/code&gt;i of its &lt;code&gt;A&lt;/code&gt;. If the last &lt;code&gt;P&lt;/code&gt;i is a pack expansion, then its pattern is compared against each remaining argument in the template argument list of &lt;code&gt;A&lt;/code&gt;. A trailing parameter pack that is not otherwise deduced, is deduced to an empty parameter pack.</source>
          <target state="translated">Если &lt;code&gt;P&lt;/code&gt; имеет одну из форм , которые включают в себя список параметров шаблона &lt;code&gt;&amp;lt;T&amp;gt;&lt;/code&gt; или &lt;code&gt;&amp;lt;I&amp;gt;&lt;/code&gt; , то каждый элемент &lt;code&gt;P&lt;/code&gt; я из этого списка аргументов шаблона сравнивается с соответствующим шаблоном аргумента &lt;code&gt;A&lt;/code&gt; я его &lt;code&gt;A&lt;/code&gt; . Если последний &lt;code&gt;P&lt;/code&gt; я это пакет расширение, то его модель сравнивается с каждым оставшимся аргументом в списке аргументов шаблона из &lt;code&gt;A&lt;/code&gt; . Конечный пакет параметров, который не выводится иначе, выводится в пустой пакет параметров.</target>
        </trans-unit>
        <trans-unit id="0f363934a6c954657e01cc4569036680c0791d2e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;P&lt;/code&gt; is a function type, pointer to function type, or pointer to member function type and if &lt;code&gt;A&lt;/code&gt; is a &lt;a href=&quot;overloaded_address&quot;&gt;set of overloaded functions&lt;/a&gt; not containing function templates, template argument deduction is attempted with each overload. If only one succeeds, that successful deduction is used. If none or more than one succeeds, the template parameter is non-deduced context (see below):</source>
          <target state="translated">Если &lt;code&gt;P&lt;/code&gt; является типом функции, указателем на тип функции или указателем на тип функции-члена и если &lt;code&gt;A&lt;/code&gt; является &lt;a href=&quot;overloaded_address&quot;&gt;набором перегруженных функций,&lt;/a&gt; не содержащих шаблонов функций, при каждой перегрузке делается попытка вывода аргумента шаблона. Если только один успешный, то этот успешный вывод используется. Если ни один или больше чем один успешно, параметр шаблона является не выводимым контекстом (см. Ниже):</target>
        </trans-unit>
        <trans-unit id="798c24b5923fa6b7a5b42f42e0bab257c03db984" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;P&lt;/code&gt; is a reference type, it is replaced by the type referred to</source>
          <target state="translated">Если &lt;code&gt;P&lt;/code&gt; является ссылочным типом, он заменяется указанным типом</target>
        </trans-unit>
        <trans-unit id="000d2698f624166e9817ec6b2bf3be4c6abd2d81" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;P&lt;/code&gt; is cv-qualified, &lt;code&gt;P&lt;/code&gt; is replaced with cv-unqualified version of itself</source>
          <target state="translated">Если &lt;code&gt;P&lt;/code&gt; cv-квалифицирован, &lt;code&gt;P&lt;/code&gt; заменяется cv-неквалифицированной версией самого себя</target>
        </trans-unit>
        <trans-unit id="aaad64c2f2873b4fe56c05d24d46c262bd388e7e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;State&lt;/code&gt; is trivially copy constructible, &lt;code&gt;fpos&lt;/code&gt; has a trivial copy constructor. If &lt;code&gt;State&lt;/code&gt; is trivially copy assignable, &lt;code&gt;fpos&lt;/code&gt; has a trivial copy assignment operator. If &lt;code&gt;State&lt;/code&gt; is trivially destructible, &lt;code&gt;fpos&lt;/code&gt; has a trivial destructor.</source>
          <target state="translated">Если &lt;code&gt;State&lt;/code&gt; является тривиально копируемым конструктором копирования, &lt;code&gt;fpos&lt;/code&gt; имеет тривиальный конструктор копирования. Если &lt;code&gt;State&lt;/code&gt; может быть &lt;code&gt;fpos&lt;/code&gt; назначено копированию, fpos имеет оператор тривиального копирования. Если &lt;code&gt;State&lt;/code&gt; тривиально разрушаемо, &lt;code&gt;fpos&lt;/code&gt; имеет тривиальный деструктор.</target>
        </trans-unit>
        <trans-unit id="8dfc67b9e7a073b3ee7a9cff59bc3b6f0015ab5c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T1&lt;/code&gt; and &lt;code&gt;T2&lt;/code&gt; are both reference types, and the</source>
          <target state="translated">Если &lt;code&gt;T1&lt;/code&gt; и &lt;code&gt;T2&lt;/code&gt; оба являются ссылочными типами, и</target>
        </trans-unit>
        <trans-unit id="b4afe72a5e507713bb840e388d5e58f8a34204b3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T1&lt;/code&gt; and &lt;code&gt;T2&lt;/code&gt; are both rvalue reference types: if the simple common reference type of &lt;code&gt;T1 &amp;amp;&lt;/code&gt; and &lt;code&gt;T2 &amp;amp;&lt;/code&gt; (determined according to the previous bullet) exists, then let &lt;code&gt;C&lt;/code&gt; denote that type's corresponding rvalue reference type. If &lt;code&gt;&lt;a href=&quot;is_convertible&quot;&gt;std::is_convertible_v&lt;/a&gt;&amp;lt;T1, C&amp;gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;is_convertible&quot;&gt;std::is_convertible_v&lt;/a&gt;&amp;lt;T2, C&amp;gt;&lt;/code&gt; are both &lt;code&gt;true&lt;/code&gt;, then the simple common reference type of &lt;code&gt;T1&lt;/code&gt; and &lt;code&gt;T2&lt;/code&gt; is &lt;code&gt;C&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;T1&lt;/code&gt; и &lt;code&gt;T2&lt;/code&gt; оба являются ссылочными типами rvalue: если существует простой общий ссылочный тип &lt;code&gt;T1 &amp;amp;&lt;/code&gt; и &lt;code&gt;T2 &amp;amp;&lt;/code&gt; (определенный в соответствии с предыдущим пунктом), то пусть &lt;code&gt;C&lt;/code&gt; обозначает соответствующий ссылочный тип rvalue этого типа. Если &lt;code&gt;&lt;a href=&quot;is_convertible&quot;&gt;std::is_convertible_v&lt;/a&gt;&amp;lt;T1, C&amp;gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;is_convertible&quot;&gt;std::is_convertible_v&lt;/a&gt;&amp;lt;T2, C&amp;gt;&lt;/code&gt; оба &lt;code&gt;true&lt;/code&gt; , то простой общий опорного типа &lt;code&gt;T1&lt;/code&gt; и &lt;code&gt;T2&lt;/code&gt; является &lt;code&gt;C&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="acc4957d82e8a29ddb9310686f84a5c8e80923c0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T1&lt;/code&gt; is &lt;code&gt;&lt;i&gt;cv1&lt;/i&gt; X &amp;amp;&lt;/code&gt; and &lt;code&gt;T2&lt;/code&gt; is &lt;code&gt;&lt;i&gt;cv2&lt;/i&gt; Y &amp;amp;&lt;/code&gt; (i.e., both are lvalue reference types): their simple common reference type is &lt;code&gt;decltype(false? &lt;a href=&quot;../utility/declval&quot;&gt;std::declval&lt;/a&gt;&amp;lt;cv12 X &amp;amp;&amp;gt;() : &lt;a href=&quot;../utility/declval&quot;&gt;std::declval&lt;/a&gt;&amp;lt;cv12 Y &amp;amp;&amp;gt;())&lt;/code&gt;, where</source>
          <target state="translated">Если &lt;code&gt;T1&lt;/code&gt; - это &lt;code&gt;&lt;i&gt;cv1&lt;/i&gt; X &amp;amp;&lt;/code&gt; , а &lt;code&gt;T2&lt;/code&gt; - это &lt;code&gt;&lt;i&gt;cv2&lt;/i&gt; Y &amp;amp;&lt;/code&gt; (т. &lt;i&gt;Е.&lt;/i&gt; Оба являются lvalue ссылочными типами): их простой общий ссылочный тип имеет тип &lt;code&gt;decltype(false? &lt;a href=&quot;../utility/declval&quot;&gt;std::declval&lt;/a&gt;&amp;lt;cv12 X &amp;amp;&amp;gt;() : &lt;a href=&quot;../utility/declval&quot;&gt;std::declval&lt;/a&gt;&amp;lt;cv12 Y &amp;amp;&amp;gt;())&lt;/code&gt; , где</target>
        </trans-unit>
        <trans-unit id="08dbf99d80fdb16cd55d43187dd92a8a606edf58" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; (the template parameter of &lt;code&gt;shared_ptr&lt;/code&gt;) is an array type &lt;code&gt;U[N]&lt;/code&gt;, &lt;code&gt;idx&lt;/code&gt; must be less than &lt;code&gt;N&lt;/code&gt;, otherwise the behavior is undefined.</source>
          <target state="translated">Если &lt;code&gt;T&lt;/code&gt; (параметр шаблона для &lt;code&gt;shared_ptr&lt;/code&gt; ) имеет тип массива &lt;code&gt;U[N]&lt;/code&gt; , &lt;code&gt;idx&lt;/code&gt; должен быть меньше &lt;code&gt;N&lt;/code&gt; , в противном случае поведение не определено.</target>
        </trans-unit>
        <trans-unit id="76e47a93376f512128c0f4db3b70d51d91d300a2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; and &lt;code&gt;U&lt;/code&gt; name the same type (including const/volatile qualifications), provides the member constant &lt;code&gt;value&lt;/code&gt; equal to &lt;code&gt;true&lt;/code&gt;. Otherwise &lt;code&gt;value&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;T&lt;/code&gt; и &lt;code&gt;U&lt;/code&gt; называют один и тот же тип (включая const / volatile квалификации), &lt;code&gt;value&lt;/code&gt; константы члена равно &lt;code&gt;true&lt;/code&gt; . В противном случае &lt;code&gt;value&lt;/code&gt; является &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="38278b1e8c4f34f7f9afed63ddee71b7095445d0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; has a member typedef &lt;code&gt;allocator_type&lt;/code&gt; which is convertible from &lt;code&gt;Alloc&lt;/code&gt;or is an alias of &lt;code&gt;&lt;a href=&quot;http://en.cppreference.com/w/cpp/experimental/erased_type&quot;&gt;std::experimental::erased_type&lt;/a&gt;&lt;/code&gt;(library fundamentals TS), the member constant &lt;code&gt;value&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;. Otherwise &lt;code&gt;value&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;T&lt;/code&gt; имеет элемент ЬурейеГо &lt;code&gt;allocator_type&lt;/code&gt; который является конвертируемым из &lt;code&gt;Alloc&lt;/code&gt; или является псевдонимом &lt;code&gt;&lt;a href=&quot;http://en.cppreference.com/w/cpp/experimental/erased_type&quot;&gt;std::experimental::erased_type&lt;/a&gt;&lt;/code&gt; (библиотека Основы TS), константа состоит &lt;code&gt;value&lt;/code&gt; является &lt;code&gt;true&lt;/code&gt; . В противном случае &lt;code&gt;value&lt;/code&gt; является &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="81aa069be603406651761b390a77246a11143050" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is (possibly cv-qualified) &lt;code&gt;void&lt;/code&gt;, a function type, or an array of unknown bound, &lt;code&gt;value&lt;/code&gt; equals &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;T&lt;/code&gt; (возможно, cv-квалифицированный) &lt;code&gt;void&lt;/code&gt; , тип функции или массив с неизвестной границей, &lt;code&gt;value&lt;/code&gt; равно &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cf221325f890a6ce6f02bee9daee7fe55c23f701" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is &lt;a href=&quot;../named_req/triviallycopyable&quot;&gt;TriviallyCopyable&lt;/a&gt; and if any two objects of type &lt;code&gt;T&lt;/code&gt; with the same value have the same &lt;a href=&quot;../language/objects&quot;&gt;object representation&lt;/a&gt;, provides the member constant &lt;code&gt;value&lt;/code&gt; equal &lt;code&gt;true&lt;/code&gt;. For any other type, &lt;code&gt;value&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;T&lt;/code&gt; является &lt;a href=&quot;../named_req/triviallycopyable&quot;&gt;TriviallyCopyable&lt;/a&gt; и если любые два объекта типа &lt;code&gt;T&lt;/code&gt; с одинаковым значением имеют одинаковое &lt;a href=&quot;../language/objects&quot;&gt;представление объекта&lt;/a&gt; , &lt;code&gt;value&lt;/code&gt; константы члена равно &lt;code&gt;true&lt;/code&gt; . Для любого другого типа &lt;code&gt;value&lt;/code&gt; равно &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cd6768a7a8e61b9b33b46e7ee729a0e3a0f70982" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is &lt;a href=&quot;../named_req/trivialtype&quot;&gt;TrivialType&lt;/a&gt; (that is, a scalar type, a trivially copyable class with a &lt;a href=&quot;../language/default_constructor#Trivial_default_constructor&quot;&gt;trivial default constructor&lt;/a&gt;, or array of such type/class, possibly cv-qualified), provides the member constant &lt;code&gt;value&lt;/code&gt; equal &lt;code&gt;true&lt;/code&gt;. For any other type, &lt;code&gt;value&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;T&lt;/code&gt; - &lt;a href=&quot;../named_req/trivialtype&quot;&gt;TrivialType&lt;/a&gt; (то есть скалярный тип, тривиально копируемый класс с &lt;a href=&quot;../language/default_constructor#Trivial_default_constructor&quot;&gt;тривиальным конструктором по умолчанию&lt;/a&gt; или массив такого типа / класса, возможно, cv-квалифицированный), &lt;code&gt;value&lt;/code&gt; константы члена равно &lt;code&gt;true&lt;/code&gt; . Для любого другого типа &lt;code&gt;value&lt;/code&gt; равно &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1568f85d20b8988df4e7cc3a1520f513dcc3a32c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is a &lt;a href=&quot;../language/derived_class&quot;&gt;derived class&lt;/a&gt; of some base &lt;code&gt;B&lt;/code&gt;, then &lt;code&gt;std::unique_ptr&amp;lt;T&amp;gt;&lt;/code&gt; is &lt;a href=&quot;unique_ptr/unique_ptr&quot;&gt;implicitly convertible&lt;/a&gt; to &lt;code&gt;std::unique_ptr&amp;lt;B&amp;gt;&lt;/code&gt;. The default deleter of the resulting &lt;code&gt;std::unique_ptr&amp;lt;B&amp;gt;&lt;/code&gt; will use &lt;a href=&quot;new/operator_delete&quot;&gt;operator delete&lt;/a&gt; for &lt;code&gt;B&lt;/code&gt;, leading to &lt;a href=&quot;../language/destructor#Virtual_destructors&quot;&gt;undefined behavior&lt;/a&gt; unless the destructor of &lt;code&gt;B&lt;/code&gt; is &lt;a href=&quot;../language/virtual&quot;&gt;virtual&lt;/a&gt;. Note that &lt;code&gt;&lt;a href=&quot;shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&lt;/code&gt; behaves differently: &lt;code&gt;&lt;a href=&quot;shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&amp;lt;B&amp;gt;&lt;/code&gt; will use the &lt;a href=&quot;new/operator_delete&quot;&gt;operator delete&lt;/a&gt; for the type &lt;code&gt;T&lt;/code&gt; and the owned object will be deleted correctly even if the destructor of &lt;code&gt;B&lt;/code&gt; is not &lt;a href=&quot;../language/virtual&quot;&gt;virtual&lt;/a&gt;.</source>
          <target state="translated">Если &lt;code&gt;T&lt;/code&gt; является &lt;a href=&quot;../language/derived_class&quot;&gt;производным классом&lt;/a&gt; некоторой базовой &lt;code&gt;B&lt;/code&gt; , то &lt;code&gt;std::unique_ptr&amp;lt;T&amp;gt;&lt;/code&gt; является &lt;a href=&quot;unique_ptr/unique_ptr&quot;&gt;неявно преобразованы&lt;/a&gt; в &lt;code&gt;std::unique_ptr&amp;lt;B&amp;gt;&lt;/code&gt; . Средство удаления по умолчанию для результирующего &lt;code&gt;std::unique_ptr&amp;lt;B&amp;gt;&lt;/code&gt; будет использовать &lt;a href=&quot;new/operator_delete&quot;&gt;оператор delete&lt;/a&gt; для &lt;code&gt;B&lt;/code&gt; , что приведет к &lt;a href=&quot;../language/destructor#Virtual_destructors&quot;&gt;неопределенному поведению,&lt;/a&gt; если деструктор &lt;code&gt;B&lt;/code&gt; не является &lt;a href=&quot;../language/virtual&quot;&gt;виртуальным&lt;/a&gt; . Обратите внимание, что &lt;code&gt;&lt;a href=&quot;shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&lt;/code&gt; ведет себя по-другому: &lt;code&gt;&lt;a href=&quot;shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&amp;lt;B&amp;gt;&lt;/code&gt; будет использовать &lt;a href=&quot;new/operator_delete&quot;&gt;оператор delete&lt;/a&gt; для типа &lt;code&gt;T&lt;/code&gt; и принадлежащий объект будет удален правильно, даже если деструктор &lt;code&gt;B&lt;/code&gt; не является &lt;a href=&quot;../language/virtual&quot;&gt;виртуальным&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="14d30fb0aa28f637b9fb71d066b29a527b12f2ba" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is a &lt;a href=&quot;../language/objects#Polymorphic_objects&quot;&gt;polymorphic class&lt;/a&gt; (that is, a non-union class that declares or inherits at least one virtual function), provides the member constant &lt;code&gt;value&lt;/code&gt; equal &lt;code&gt;true&lt;/code&gt;. For any other type, &lt;code&gt;value&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;T&lt;/code&gt; является &lt;a href=&quot;../language/objects#Polymorphic_objects&quot;&gt;полиморфным классом&lt;/a&gt; (то есть классом , не являющимся объединением, который объявляет или наследует хотя бы одну виртуальную функцию), &lt;code&gt;value&lt;/code&gt; константы-члена равно &lt;code&gt;true&lt;/code&gt; . Для любого другого типа &lt;code&gt;value&lt;/code&gt; равно &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b9f4f4e6212d0ba8a754d82884bd2c1bd59ed77a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is a &lt;a href=&quot;../language/type-id&quot;&gt;scalar type&lt;/a&gt; (that is a possibly cv-qualified &lt;a href=&quot;is_arithmetic&quot;&gt;arithmetic&lt;/a&gt;, pointer, &lt;a href=&quot;is_member_pointer&quot;&gt;pointer to member&lt;/a&gt;, &lt;a href=&quot;../language/enum&quot;&gt;enumeration&lt;/a&gt;, or &lt;code&gt;&lt;a href=&quot;nullptr_t&quot;&gt;std::nullptr_t&lt;/a&gt;&lt;/code&gt; type), provides the member constant &lt;code&gt;value&lt;/code&gt; equal &lt;code&gt;true&lt;/code&gt;. For any other type, &lt;code&gt;value&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;T&lt;/code&gt; является &lt;a href=&quot;../language/type-id&quot;&gt;скалярным типом&lt;/a&gt; (то есть, возможно, cv-квалифицированной &lt;a href=&quot;is_arithmetic&quot;&gt;арифметикой&lt;/a&gt; , указателем, &lt;a href=&quot;is_member_pointer&quot;&gt;указателем на член&lt;/a&gt; , &lt;a href=&quot;../language/enum&quot;&gt;перечислением&lt;/a&gt; или типом &lt;code&gt;&lt;a href=&quot;nullptr_t&quot;&gt;std::nullptr_t&lt;/a&gt;&lt;/code&gt; ), &lt;code&gt;value&lt;/code&gt; константы члена равно &lt;code&gt;true&lt;/code&gt; . Для любого другого типа &lt;code&gt;value&lt;/code&gt; равно &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="26b317cff4e6b234d366569c6bab42c37da84e1c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is a &lt;a href=&quot;../named_req/podtype&quot;&gt;PODType&lt;/a&gt; (&quot;plain old data type&quot;), that is, both trivial and standard-layout, provides the member constant &lt;code&gt;value&lt;/code&gt; equal &lt;code&gt;true&lt;/code&gt;. For any other type, &lt;code&gt;value&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;T&lt;/code&gt; - это &lt;a href=&quot;../named_req/podtype&quot;&gt;PODType&lt;/a&gt; (&amp;laquo;простой старый тип данных&amp;raquo;), то есть как тривиальный, так и стандартный макет, &lt;code&gt;value&lt;/code&gt; константы члена равно &lt;code&gt;true&lt;/code&gt; . Для любого другого типа &lt;code&gt;value&lt;/code&gt; равно &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="aabad78089db78755c758b0100bec563037cafec" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is a &lt;a href=&quot;../named_req/triviallycopyable&quot;&gt;TriviallyCopyable&lt;/a&gt; type, provides the member constant &lt;code&gt;value&lt;/code&gt; equal &lt;code&gt;true&lt;/code&gt;. For any other type, &lt;code&gt;value&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;T&lt;/code&gt; является типом &lt;a href=&quot;../named_req/triviallycopyable&quot;&gt;TriviallyCopyable&lt;/a&gt; , &lt;code&gt;value&lt;/code&gt; константы члена равно &lt;code&gt;true&lt;/code&gt; . Для любого другого типа &lt;code&gt;value&lt;/code&gt; равно &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="aa4f125d6fcfcc5603d821627566fc4b66114754" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is a class type and the cv-unqualified version of the type of other is &lt;code&gt;T&lt;/code&gt; or a class derived from &lt;code&gt;T&lt;/code&gt;, the &lt;a href=&quot;converting_constructor&quot;&gt;non-explicit constructors&lt;/a&gt; of &lt;code&gt;T&lt;/code&gt; are examined and the best match is selected by overload resolution. The constructor is then called to initialize the object.</source>
          <target state="translated">Если &lt;code&gt;T&lt;/code&gt; является типом класса и резюме-неквалифицированным версия типа другой &lt;code&gt;T&lt;/code&gt; или класс , производный от &lt;code&gt;T&lt;/code&gt; , то &lt;a href=&quot;converting_constructor&quot;&gt;без явных Конструкторы&lt;/a&gt; из &lt;code&gt;T&lt;/code&gt; рассматриваются и лучший матч выбирается разрешение перегрузки. Затем вызывается конструктор для инициализации объекта.</target>
        </trans-unit>
        <trans-unit id="da7735d51b45c0cf73d900692c844b55829fb21a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is a class type that has no default constructor but has a constructor taking &lt;code&gt;&lt;a href=&quot;../utility/initializer_list&quot;&gt;std::initializer_list&lt;/a&gt;&lt;/code&gt;, &lt;a href=&quot;list_initialization&quot;&gt;list-initialization&lt;/a&gt; is performed.</source>
          <target state="translated">Если &lt;code&gt;T&lt;/code&gt; является типом класса, который не имеет конструктора по умолчанию, но имеет конструктор, принимающий &lt;code&gt;&lt;a href=&quot;../utility/initializer_list&quot;&gt;std::initializer_list&lt;/a&gt;&lt;/code&gt; , выполняется инициализация&lt;a href=&quot;list_initialization&quot;&gt; списка&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="bd5fd7b67551be2174ad147f6096e9f4d8ec3b0f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is a class type,</source>
          <target state="translated">Если &lt;code&gt;T&lt;/code&gt; является типом класса,</target>
        </trans-unit>
        <trans-unit id="ec4bcfea7a6b88492eb03ffb2367361b716260ca" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is a class type, &lt;code&gt;T&lt;/code&gt; shall be a complete type; otherwise, the behavior is undefined.</source>
          <target state="translated">Если &lt;code&gt;T&lt;/code&gt; является типом класса, &lt;code&gt;T&lt;/code&gt; должен быть полным типом; в противном случае поведение не определено.</target>
        </trans-unit>
        <trans-unit id="896d68960185cda4dfdf0280d92d7ef716c2b80f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is a class type, and the cv-unqualified version of the type of other is not &lt;code&gt;T&lt;/code&gt; or derived from &lt;code&gt;T&lt;/code&gt;, or if &lt;code&gt;T&lt;/code&gt; is non-class type, but the type of other is a class type, &lt;a href=&quot;implicit_cast&quot;&gt;user-defined conversion sequences&lt;/a&gt; that can convert from the type of other to &lt;code&gt;T&lt;/code&gt; (or to a type derived from T if T is a class type and a conversion function is available) are examined and the best one is selected through overload resolution. The result of the conversion, which is a prvalue temporary(until C++17)prvalue expression(since C++17) if a &lt;a href=&quot;converting_constructor&quot;&gt;converting constructor&lt;/a&gt; was used, is then used to &lt;a href=&quot;direct_initialization&quot;&gt;direct-initialize&lt;/a&gt; the object. The last step is usually &lt;a href=&quot;copy_elision&quot;&gt;optimized out&lt;/a&gt; and the result of the conversion is constructed directly in the memory allocated for the target object, but the appropriate constructor (move or copy) is required to be accessible even though it's not used.(until C++17)</source>
          <target state="translated">Если &lt;code&gt;T&lt;/code&gt; является типом класса, и cv-неквалифицированная версия типа other не является &lt;code&gt;T&lt;/code&gt; или не получена из &lt;code&gt;T&lt;/code&gt; , или если &lt;code&gt;T&lt;/code&gt; не является типом класса, но тип other является типом класса, &lt;a href=&quot;implicit_cast&quot;&gt;определяемые пользователем последовательности преобразования&lt;/a&gt; которые могут конвертировать из типа другой в &lt;code&gt;T&lt;/code&gt; (или в тип, производный от T, если T является типом класса и доступна функция преобразования), и выбирается лучший из них с помощью разрешения перегрузки. Результат преобразования, который является prvalue временным (до C ++ 17) prvalue выражением (начиная с C ++ 17), если использовался &lt;a href=&quot;converting_constructor&quot;&gt;конвертирующий конструктор&lt;/a&gt; , затем используется для &lt;a href=&quot;direct_initialization&quot;&gt;прямой инициализации&lt;/a&gt; объекта. Последний шаг обычно&lt;a href=&quot;copy_elision&quot;&gt;оптимизируется,&lt;/a&gt; и результат преобразования создается непосредственно в памяти, выделенной для целевого объекта, но требуется, чтобы соответствующий конструктор (перемещение или копирование) был доступен, даже если он не используется. (до C ++ 17)</target>
        </trans-unit>
        <trans-unit id="d1e8a1503abd79c3951a5fdc99d54970e61781da" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is a class, it</source>
          <target state="translated">Если &lt;code&gt;T&lt;/code&gt; является классом, это</target>
        </trans-unit>
        <trans-unit id="ed233d36e232baacab8bc15f22e8a539e4afdd7f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is a complete enumeration type, provides a member typedef &lt;code&gt;type&lt;/code&gt; that names the underlying type of &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;T&lt;/code&gt; - полный тип перечисления, предоставляет &lt;code&gt;type&lt;/code&gt; typedef члена, который называет базовый тип &lt;code&gt;T&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8db0456a21c631678465dcec0933012e0ff80219" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is a compound type (that is, array, function, object pointer, function pointer, member object pointer, member function pointer, reference, class, union, or enumeration, including any cv-qualified variants), provides the member constant &lt;code&gt;value&lt;/code&gt; equal &lt;code&gt;true&lt;/code&gt;. For any other type, &lt;code&gt;value&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;T&lt;/code&gt; является составным типом (то есть массив, функция, указатель на объект, указатель на функцию, указатель на объект-член, указатель на функцию-член, ссылку, класс, объединение или перечисление, включая любые cv-квалифицированные варианты), предоставляет &lt;code&gt;value&lt;/code&gt; константы члена равно &lt;code&gt;true&lt;/code&gt; . Для любого другого типа &lt;code&gt;value&lt;/code&gt; равно &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ef33179463348172c7683162235f438e5b4d890a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is a const-qualified type (that is, &lt;code&gt;const&lt;/code&gt;, or &lt;code&gt;const volatile&lt;/code&gt;), provides the member constant &lt;code&gt;value&lt;/code&gt; equal &lt;code&gt;true&lt;/code&gt;. For any other type, &lt;code&gt;value&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;T&lt;/code&gt; является const-квалифицированным типом (то есть &lt;code&gt;const&lt;/code&gt; или &lt;code&gt;const volatile&lt;/code&gt; ), &lt;code&gt;value&lt;/code&gt; константы члена равно &lt;code&gt;true&lt;/code&gt; . Для любого другого типа &lt;code&gt;value&lt;/code&gt; равно &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6bd5fbe7c6f6fa50f124d44f0d758532e44d5237" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is a const-qualified type, it must be a class type with a user-provided default constructor.</source>
          <target state="translated">Если &lt;code&gt;T&lt;/code&gt; является константным типом, это должен быть тип класса с предоставленным пользователем конструктором по умолчанию.</target>
        </trans-unit>
        <trans-unit id="91f7440ceeb8c74be7fd249bfe485e7779ba5401" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is a cv-qualified type, its cv-unqualified version is used for the purpose of default-initialization.</source>
          <target state="translated">Если &lt;code&gt;T&lt;/code&gt; является cv-квалифицированным типом, его cv-неквалифицированная версия используется с целью инициализации по умолчанию.</target>
        </trans-unit>
        <trans-unit id="e52096d9a275548201e72366e41ec09c171ba7e7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is a final class (that is, a class declared with the &lt;a href=&quot;../language/final&quot;&gt;final specifier&lt;/a&gt;), provides the member constant &lt;code&gt;value&lt;/code&gt; equal &lt;code&gt;true&lt;/code&gt;. For any other type, &lt;code&gt;value&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;T&lt;/code&gt; является конечным классом (то есть классом, объявленным с &lt;a href=&quot;../language/final&quot;&gt;конечным спецификатором&lt;/a&gt; ), &lt;code&gt;value&lt;/code&gt; константы члена равно &lt;code&gt;true&lt;/code&gt; . Для любого другого типа &lt;code&gt;value&lt;/code&gt; равно &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d0409542043a949225bfecbaf84bae28f3b1b559" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is a fundamental type (that is, arithmetic type, &lt;code&gt;void&lt;/code&gt;, or &lt;code&gt;nullptr_t&lt;/code&gt;), provides the member constant &lt;code&gt;value&lt;/code&gt; equal &lt;code&gt;true&lt;/code&gt;. For any other type, &lt;code&gt;value&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;T&lt;/code&gt; является фундаментальным типом (то есть арифметическим типом, &lt;code&gt;void&lt;/code&gt; или &lt;code&gt;nullptr_t&lt;/code&gt; ), &lt;code&gt;value&lt;/code&gt; константы члена равно &lt;code&gt;true&lt;/code&gt; . Для любого другого типа &lt;code&gt;value&lt;/code&gt; равно &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="945c7b712dc29eea2b59cbb88e5b35a7559eb2f1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is a literal type, then this destructor is a trivial destructor.</source>
          <target state="translated">Если &lt;code&gt;T&lt;/code&gt; литеральный тип, то этот деструктор является тривиальным деструктором.</target>
        </trans-unit>
        <trans-unit id="64ca21f761a5e7e05def717cd2e2b74081f4cf00" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is a multidimensional array of some type &lt;code&gt;X&lt;/code&gt;, provides the member typedef &lt;code&gt;type&lt;/code&gt; equal to &lt;code&gt;X&lt;/code&gt;, otherwise &lt;code&gt;type&lt;/code&gt; is &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;T&lt;/code&gt; представляет собой многомерный массив некоторого типа &lt;code&gt;X&lt;/code&gt; , обеспечивает элемент ЬурейиХ &lt;code&gt;type&lt;/code&gt; равный &lt;code&gt;X&lt;/code&gt; , в противном случае &lt;code&gt;type&lt;/code&gt; является &lt;code&gt;T&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1b1b0a24554bc1d76e3a383da4b1a44ea0d8546a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is a non-class type, the value contained in the object is produced as the prvalue result. For a class type, this conversion.</source>
          <target state="translated">Если тип &lt;code&gt;T&lt;/code&gt; не является классом, значение, содержащееся в объекте, создается как результат предварительного значения. Для типа класса это преобразование.</target>
        </trans-unit>
        <trans-unit id="69946f1172c363138f6dfe6642850f73c0486b56" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is a non-union class type, &lt;code&gt;T&lt;/code&gt; shall be a complete type; otherwise, the behavior is undefined.</source>
          <target state="translated">Если &lt;code&gt;T&lt;/code&gt; является типом класса, не являющимся объединением, &lt;code&gt;T&lt;/code&gt; должен быть полным типом; в противном случае поведение не определено.</target>
        </trans-unit>
        <trans-unit id="81c8d7a5988a6dccdd619ff7a279df533a7a5150" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is a reference type (lvalue reference or rvalue reference), provides the member constant &lt;code&gt;value&lt;/code&gt; equal &lt;code&gt;true&lt;/code&gt;. For any other type, &lt;code&gt;value&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;T&lt;/code&gt; является ссылочным типом (ссылка lvalue или ссылка rvalue), &lt;code&gt;value&lt;/code&gt; константы члена равно &lt;code&gt;true&lt;/code&gt; . Для любого другого типа &lt;code&gt;value&lt;/code&gt; равно &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8dafe7774d902eba322cf87364d4aea07d531abd" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is a reference type then &lt;code&gt;is_const&amp;lt;T&amp;gt;::value&lt;/code&gt; is always &lt;code&gt;false&lt;/code&gt;. The proper way to check a potentially-reference type for const-ness is to remove the reference: &lt;code&gt;is_const&amp;lt;typename remove_reference&amp;lt;T&amp;gt;::type&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;T&lt;/code&gt; является ссылочным типом, тогда &lt;code&gt;is_const&amp;lt;T&amp;gt;::value&lt;/code&gt; всегда &lt;code&gt;false&lt;/code&gt; . Правильный способ проверить потенциально-ссылочный тип на &lt;code&gt;is_const&amp;lt;typename remove_reference&amp;lt;T&amp;gt;::type&amp;gt;&lt;/code&gt; - удалить ссылку: is_const &amp;lt;typename remove_reference &amp;lt;T&amp;gt; :: type&amp;gt; .</target>
        </trans-unit>
        <trans-unit id="6ea9b4eb9eb04de1f92850f45ff1fddbdaee120f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is a reference type, then provides the member typedef &lt;code&gt;type&lt;/code&gt; which is a pointer to the referred type.</source>
          <target state="translated">Если &lt;code&gt;T&lt;/code&gt; является ссылочным типом, то предоставляет &lt;code&gt;type&lt;/code&gt; typedef члена, который является указателем на упомянутый тип.</target>
        </trans-unit>
        <trans-unit id="2563eff1fa56e4b4ac0532f78126ffeeed82a1f2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is a scalar type, the object's initial value is the integral constant zero &lt;a href=&quot;explicit_cast&quot;&gt;explicitly converted&lt;/a&gt; to &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;T&lt;/code&gt; является скаляром типа, начальное значение объекта является неотъемлемым постоянная нулевым &lt;a href=&quot;explicit_cast&quot;&gt;явно преобразуется&lt;/a&gt; в &lt;code&gt;T&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="87c045c1fc56928cd55cfd53cf91e06e54ae07d5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is a standard layout type (that is, a scalar type, a standard-layout class, or an array of such type/class, possibly cv-qualified), provides the member constant &lt;code&gt;value&lt;/code&gt; equal &lt;code&gt;true&lt;/code&gt;. For any other type, &lt;code&gt;value&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;T&lt;/code&gt; является стандартным типом макета (то есть скалярным типом, классом стандартного макета или массивом такого типа / класса, возможно, cv-квалифицированным), &lt;code&gt;value&lt;/code&gt; константы члена равно &lt;code&gt;true&lt;/code&gt; . Для любого другого типа &lt;code&gt;value&lt;/code&gt; равно &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b944fcc6217049e07d88eb139271e7fb7cc4f093" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is a type with a virtual destructor, provides the member constant &lt;code&gt;value&lt;/code&gt; equal &lt;code&gt;true&lt;/code&gt;. For any other type, &lt;code&gt;value&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;T&lt;/code&gt; является типом с виртуальным деструктором, &lt;code&gt;value&lt;/code&gt; константы члена равно &lt;code&gt;true&lt;/code&gt; . Для любого другого типа &lt;code&gt;value&lt;/code&gt; равно &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d4437c61374698795bc2e7b0a725c5aea0e02d36" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is a union type, the first non-static named data member is zero-initialized and all padding is initialized to zero bits.</source>
          <target state="translated">Если &lt;code&gt;T&lt;/code&gt; является типом объединения, первый нестатический именованный элемент данных инициализируется нулями, а все заполнение инициализируется нулевыми битами.</target>
        </trans-unit>
        <trans-unit id="c4e59ca1d67fedc2671ca4bc2d55bea20110e0a1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is a volatile-qualified type (that is, &lt;code&gt;volatile&lt;/code&gt;, or &lt;code&gt;const volatile&lt;/code&gt;), provides the member constant &lt;code&gt;value&lt;/code&gt; equal &lt;code&gt;true&lt;/code&gt;. For any other type, &lt;code&gt;value&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;T&lt;/code&gt; является типом с квалификацией volatile (то есть &lt;code&gt;volatile&lt;/code&gt; или &lt;code&gt;const volatile&lt;/code&gt; ), &lt;code&gt;value&lt;/code&gt; константы члена равно &lt;code&gt;true&lt;/code&gt; . Для любого другого типа &lt;code&gt;value&lt;/code&gt; равно &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="902b6c9678e19fc91eed33a7ee6f68dcf0f1506d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is an &lt;a href=&quot;../language/abstract_class&quot;&gt;abstract class&lt;/a&gt; (that is, a non-union class that declares or inherits at least one pure virtual function), provides the member constant &lt;code&gt;value&lt;/code&gt; equal &lt;code&gt;true&lt;/code&gt;. For any other type, &lt;code&gt;value&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;T&lt;/code&gt; является &lt;a href=&quot;../language/abstract_class&quot;&gt;абстрактным классом&lt;/a&gt; (то есть классом , не являющимся объединением, который объявляет или наследует хотя бы одну чисто виртуальную функцию), &lt;code&gt;value&lt;/code&gt; константы-члена равно &lt;code&gt;true&lt;/code&gt; . Для любого другого типа &lt;code&gt;value&lt;/code&gt; равно &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ec8806b61c0e95ac652393c60f0f6708ecf1e2f5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is an &lt;a href=&quot;../language/type-id&quot;&gt;object type&lt;/a&gt; (that is any possibly cv-qualified type other than function, reference, or &lt;code&gt;void&lt;/code&gt; types), provides the member constant &lt;code&gt;value&lt;/code&gt; equal &lt;code&gt;true&lt;/code&gt;. For any other type, &lt;code&gt;value&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;T&lt;/code&gt; является &lt;a href=&quot;../language/type-id&quot;&gt;типом объекта&lt;/a&gt; (то есть любым, возможно, cv-квалифицированным типом, кроме типов функций, ссылок или &lt;code&gt;void&lt;/code&gt; ), &lt;code&gt;value&lt;/code&gt; константы члена равно &lt;code&gt;true&lt;/code&gt; . Для любого другого типа &lt;code&gt;value&lt;/code&gt; равно &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f0fb50089c183d77cfb88879ad7a640e825184ad" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is an &lt;a href=&quot;aggregate_initialization&quot;&gt;aggregate type&lt;/a&gt;, &lt;a href=&quot;aggregate_initialization&quot;&gt;aggregate initialization&lt;/a&gt; is performed.</source>
          <target state="translated">Если &lt;code&gt;T&lt;/code&gt; является &lt;a href=&quot;aggregate_initialization&quot;&gt;агрегатным типом&lt;/a&gt; , &lt;a href=&quot;aggregate_initialization&quot;&gt;агрегатная инициализация&lt;/a&gt; выполняется .</target>
        </trans-unit>
        <trans-unit id="aa61f0f59c6b53db0c1c4a6741114952582e2eaf" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is an aggregate type and the initializer list has a single element of the same or derived type (possibly cv-qualified), the object is initialized from that element (by &lt;a href=&quot;copy_initialization&quot;&gt;copy-initialization&lt;/a&gt; for copy-list-initialization, or by &lt;a href=&quot;direct_initialization&quot;&gt;direct-initialization&lt;/a&gt; for direct-list-initialization).</source>
          <target state="translated">Если &lt;code&gt;T&lt;/code&gt; является агрегатным типом, а список инициализаторов содержит один элемент того же или производного типа (возможно, cv-квалифицированный), объект инициализируется из этого элемента (путем &lt;a href=&quot;copy_initialization&quot;&gt;инициализации&lt;/a&gt; копирования для инициализации копирования списка или путем &lt;a href=&quot;direct_initialization&quot;&gt;прямого инициализация&lt;/a&gt; для прямой инициализации списка).</target>
        </trans-unit>
        <trans-unit id="689228bd3413da8a5503b4c482886c287f618b2e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is an arithmetic type (that is, an integral type or a floating-point type) or a &lt;code&gt;cv-qualified&lt;/code&gt; version thereof, provides the member constant &lt;code&gt;value&lt;/code&gt; equal &lt;code&gt;true&lt;/code&gt;. For any other type, &lt;code&gt;value&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;T&lt;/code&gt; является арифметическим типом (то есть целочисленным типом или типом с плавающей запятой) или его &lt;code&gt;cv-qualified&lt;/code&gt; версией, &lt;code&gt;value&lt;/code&gt; константы члена равно &lt;code&gt;true&lt;/code&gt; . Для любого другого типа &lt;code&gt;value&lt;/code&gt; равно &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fbccf0b2c1488a744757cc2db3268bc8b20be41f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is an arithmetic type, provides the member constant &lt;code&gt;value&lt;/code&gt; equal &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;T(-1) &amp;lt; T(0)&lt;/code&gt;: this results in &lt;code&gt;true&lt;/code&gt; for the floating-point types and the signed integer types, and in &lt;code&gt;false&lt;/code&gt; for the unsigned integer types and the type &lt;code&gt;bool&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;T&lt;/code&gt; - арифметический тип, то &lt;code&gt;value&lt;/code&gt; константы члена равно &lt;code&gt;true&lt;/code&gt; , если &lt;code&gt;T(-1) &amp;lt; T(0)&lt;/code&gt; : это приводит к &lt;code&gt;true&lt;/code&gt; для типов с плавающей запятой и целочисленных типов со знаком и к &lt;code&gt;false&lt;/code&gt; для целочисленных типов без знака и типа &lt;code&gt;bool&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fcba9f80c891b0c1e133e1cb6925e4162b876bf7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is an arithmetic type, provides the member constant &lt;code&gt;value&lt;/code&gt; equal &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;T(0) &amp;lt; T(-1)&lt;/code&gt;: this results in &lt;code&gt;true&lt;/code&gt; for the unsigned integer types and the type &lt;code&gt;bool&lt;/code&gt; and in &lt;code&gt;false&lt;/code&gt; for the signed integer types and the floating-point types.</source>
          <target state="translated">Если &lt;code&gt;T&lt;/code&gt; является арифметическим типом, &lt;code&gt;value&lt;/code&gt; константы члена равно &lt;code&gt;true&lt;/code&gt; , если &lt;code&gt;T(0) &amp;lt; T(-1)&lt;/code&gt; : это приводит к &lt;code&gt;true&lt;/code&gt; для целочисленных типов без знака и к типу &lt;code&gt;bool&lt;/code&gt; , и к &lt;code&gt;false&lt;/code&gt; для целочисленных типов со знаком и плавающего числа точечные типы.</target>
        </trans-unit>
        <trans-unit id="c1fc66fc47bed74ebe67e8cc80e0ae9110815b91" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is an array of some type &lt;code&gt;X&lt;/code&gt;, provides the member typedef &lt;code&gt;type&lt;/code&gt; equal to &lt;code&gt;X&lt;/code&gt;, otherwise &lt;code&gt;type&lt;/code&gt; is &lt;code&gt;T&lt;/code&gt;. Note that if T is a multidimensional array, only the first dimension is removed.</source>
          <target state="translated">Если &lt;code&gt;T&lt;/code&gt; является массивом некоторого типа &lt;code&gt;X&lt;/code&gt; , предоставляет &lt;code&gt;type&lt;/code&gt; typedef члена, равный &lt;code&gt;X&lt;/code&gt; , в противном случае &lt;code&gt;type&lt;/code&gt; является &lt;code&gt;T&lt;/code&gt; . Обратите внимание, что если T является многомерным массивом, удаляется только первое измерение.</target>
        </trans-unit>
        <trans-unit id="79fca8c3f06baf2e5727ef4a8e28e151e6f0be48" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is an array type &lt;code&gt;U[N]&lt;/code&gt;, these constructors do not participate in overload resolution if &lt;code&gt;Y(*)[N]&lt;/code&gt; is not convertible to &lt;code&gt;T*&lt;/code&gt;. If &lt;code&gt;T&lt;/code&gt; is an array type &lt;code&gt;U[]&lt;/code&gt;, these constructors do not participate in overload resolution if &lt;code&gt;Y(*)[]&lt;/code&gt; is not convertible to &lt;code&gt;T*&lt;/code&gt;. Otherwise, these constructors do not participate in overload resolution if &lt;code&gt;Y*&lt;/code&gt; is not convertible to &lt;code&gt;T*&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;T&lt;/code&gt; является типом массива &lt;code&gt;U[N]&lt;/code&gt; , эти конструкторы не участвуют в разрешении перегрузки, если &lt;code&gt;Y(*)[N]&lt;/code&gt; не преобразуется в &lt;code&gt;T*&lt;/code&gt; . Если &lt;code&gt;T&lt;/code&gt; является типом массива &lt;code&gt;U[]&lt;/code&gt; , эти конструкторы не участвуют в разрешении перегрузки, если &lt;code&gt;Y(*)[]&lt;/code&gt; не преобразуется в &lt;code&gt;T*&lt;/code&gt; . В противном случае эти конструкторы не участвуют в разрешении перегрузки, если &lt;code&gt;Y*&lt;/code&gt; не преобразуется в &lt;code&gt;T*&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0b5f23983416e1c75433eb3c8db868b92738cbbc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is an array type,</source>
          <target state="translated">Если &lt;code&gt;T&lt;/code&gt; является типом массива,</target>
        </trans-unit>
        <trans-unit id="40f6a482e9f6bb37f7f795348ce26482a687ee2b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is an array type, provides the member constant &lt;code&gt;value&lt;/code&gt; equal to the number of dimensions of the array. For any other type, &lt;code&gt;value&lt;/code&gt; is 0.</source>
          <target state="translated">Если &lt;code&gt;T&lt;/code&gt; является типом массива, обеспечивает &lt;code&gt;value&lt;/code&gt; константы члена, равное количеству измерений массива. Для любого другого типа &lt;code&gt;value&lt;/code&gt; равно 0.</target>
        </trans-unit>
        <trans-unit id="50b11c4cc0a3bc2aa8bbbd2ffae9d6dac98f5145" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is an array type, provides the member constant &lt;code&gt;value&lt;/code&gt; equal to the number of elements along the &lt;code&gt;N&lt;/code&gt;th dimension of the array, if &lt;code&gt;N&lt;/code&gt; is in &lt;code&gt;[0, std::rank&amp;lt;T&amp;gt;::value)&lt;/code&gt;. For any other type, or if &lt;code&gt;T&lt;/code&gt; is array of unknown bound along its first dimension and &lt;code&gt;N&lt;/code&gt; is 0, &lt;code&gt;value&lt;/code&gt; is 0.</source>
          <target state="translated">Если &lt;code&gt;T&lt;/code&gt; является типом массива, обеспечивает &lt;code&gt;value&lt;/code&gt; константы члена, равное количеству элементов вдоль &lt;code&gt;N&lt;/code&gt; - го измерения массива, если &lt;code&gt;N&lt;/code&gt; находится в &lt;code&gt;[0, std::rank&amp;lt;T&amp;gt;::value)&lt;/code&gt; . Для любого другого типа или если &lt;code&gt;T&lt;/code&gt; является массивом неизвестной границы вдоль его первого измерения, а &lt;code&gt;N&lt;/code&gt; равно 0, &lt;code&gt;value&lt;/code&gt; равно 0.</target>
        </trans-unit>
        <trans-unit id="d418fb8b71e5b3d9f326ce97a54075d08f82dec3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is an empty type (that is, a non-union class type with no non-static data members other than bit-fields of size 0, no virtual functions, no virtual base classes, and no non-empty base classes), provides the member constant &lt;code&gt;value&lt;/code&gt; equal &lt;code&gt;true&lt;/code&gt;. For any other type, &lt;code&gt;value&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;T&lt;/code&gt; является пустым типом (то есть типом класса, не являющимся объединением, без нестатических элементов данных, кроме битовых полей размера 0, без виртуальных функций, без виртуальных базовых классов и без непустых базовых классов), обеспечивает постоянное &lt;code&gt;value&lt;/code&gt; члена равным &lt;code&gt;true&lt;/code&gt; . Для любого другого типа &lt;code&gt;value&lt;/code&gt; равно &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="615ee340215311c44d8a0200015cab668b08669e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is an error code enumeration, this template provides the member constant &lt;code&gt;value&lt;/code&gt; equal &lt;code&gt;true&lt;/code&gt;. For any other type, &lt;code&gt;value&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;T&lt;/code&gt; является перечислением кода ошибки, этот шаблон предоставляет &lt;code&gt;value&lt;/code&gt; константы члена, равное &lt;code&gt;true&lt;/code&gt; . Для любого другого типа &lt;code&gt;value&lt;/code&gt; равно &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f00d4c8f60284c8e8a5d4214a2b023ed99513026" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is an error condition enum, this template provides the member constant &lt;code&gt;value&lt;/code&gt; equal &lt;code&gt;true&lt;/code&gt;. For any other type, &lt;code&gt;value&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;T&lt;/code&gt; - перечисление условия ошибки, этот шаблон предоставляет &lt;code&gt;value&lt;/code&gt; константы члена, равное &lt;code&gt;true&lt;/code&gt; . Для любого другого типа &lt;code&gt;value&lt;/code&gt; равно &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="64661dfb24aa2b41c7a58f86cc3e8e06dff1cc46" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is an integral (except bool) or enumeration type, provides the member typedef &lt;code&gt;type&lt;/code&gt; which is the signed integer type corresponding to &lt;code&gt;T&lt;/code&gt;, with the same cv-qualifiers.</source>
          <target state="translated">Если &lt;code&gt;T&lt;/code&gt; является целочисленным (кроме bool) или перечислимым типом, предоставляет &lt;code&gt;type&lt;/code&gt; typedef члена, который является целочисленным типом со &lt;code&gt;T&lt;/code&gt; , соответствующим T , с теми же квалификаторами cv.</target>
        </trans-unit>
        <trans-unit id="f9f1f9d4a2f0ac4a591a53f86518618b379c091c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is an integral (except bool) or enumeration type, provides the member typedef &lt;code&gt;type&lt;/code&gt; which is the unsigned integer type corresponding to &lt;code&gt;T&lt;/code&gt;, with the same cv-qualifiers. The unsigned integer type corresponding to an enumeration type is the unsigned integer type with the smallest &lt;a href=&quot;../language/implicit_cast#Integral_promotion&quot;&gt;rank&lt;/a&gt; having the same &lt;code&gt;sizeof&lt;/code&gt; as the enumeration.</source>
          <target state="translated">Если &lt;code&gt;T&lt;/code&gt; является целочисленным (кроме bool) или перечислимым типом, предоставляет &lt;code&gt;type&lt;/code&gt; typedef члена, который является целочисленным типом без знака, соответствующим &lt;code&gt;T&lt;/code&gt; , с теми же квалификаторами cv. Целочисленный тип без знака, соответствующий типу перечисления, является целочисленным типом без знака с наименьшим &lt;a href=&quot;../language/implicit_cast#Integral_promotion&quot;&gt;рангом,&lt;/a&gt; имеющим тот же &lt;code&gt;sizeof&lt;/code&gt; что и перечисление.</target>
        </trans-unit>
        <trans-unit id="c91459dde93fa1a39419b8fda3571b1d3f2524ff" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is an non-union class type, all base classes and non-static data members are zero-initialized, and all padding is initialized to zero bits. The constructors, if any, are ignored.</source>
          <target state="translated">Если &lt;code&gt;T&lt;/code&gt; является типом класса, не являющимся объединением, все базовые классы и нестатические члены-данные инициализируются нулями, а все заполнение инициализируется нулевыми битами. Конструкторы, если таковые имеются, игнорируются.</target>
        </trans-unit>
        <trans-unit id="c1d5d737127c3f29b041ec54c37e9b91100e0f8f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is an object type, then, for the type &lt;code&gt;U&lt;/code&gt; equal &lt;code&gt;&lt;a href=&quot;remove_all_extents&quot;&gt;std::remove_all_extents&lt;/a&gt;&amp;lt;T&amp;gt;::type&lt;/code&gt;, if the expression &lt;code&gt;&lt;a href=&quot;../utility/declval&quot;&gt;std::declval&lt;/a&gt;&amp;lt;U&amp;amp;&amp;gt;().~U()&lt;/code&gt; is well-formed in unevaluated context, &lt;code&gt;value&lt;/code&gt; equals &lt;code&gt;true&lt;/code&gt;. Otherwise, &lt;code&gt;value&lt;/code&gt; equals &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;T&lt;/code&gt; является типом объекта, то для типа &lt;code&gt;U&lt;/code&gt; , равного &lt;code&gt;&lt;a href=&quot;remove_all_extents&quot;&gt;std::remove_all_extents&lt;/a&gt;&amp;lt;T&amp;gt;::type&lt;/code&gt; , если выражение &lt;code&gt;&lt;a href=&quot;../utility/declval&quot;&gt;std::declval&lt;/a&gt;&amp;lt;U&amp;amp;&amp;gt;().~U()&lt;/code&gt; правильно сформировано в неоцененном контексте, &lt;code&gt;value&lt;/code&gt; равно &lt;code&gt;true&lt;/code&gt; . В противном случае &lt;code&gt;value&lt;/code&gt; равно &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c22afe114b35ac81cf800a1156d7baffcb6d3c14" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is array type, each element is zero-initialized</source>
          <target state="translated">Если &lt;code&gt;T&lt;/code&gt; является типом массива, каждый элемент инициализируется нулями</target>
        </trans-unit>
        <trans-unit id="dea68d51090e5d0f319644a92de20fb3d9b95d47" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is not &lt;a href=&quot;../named_req/triviallycopyable&quot;&gt;TriviallyCopyable&lt;/a&gt;, the program that specializes &lt;code&gt;std::tx_exception&amp;lt;T&amp;gt;&lt;/code&gt; is ill-formed.</source>
          <target state="translated">Если &lt;code&gt;T&lt;/code&gt; не &lt;a href=&quot;../named_req/triviallycopyable&quot;&gt;TriviallyCopyable&lt;/a&gt; , программа, специализирующаяся на &lt;code&gt;std::tx_exception&amp;lt;T&amp;gt;&lt;/code&gt; является некорректной.</target>
        </trans-unit>
        <trans-unit id="73b3d58d3922df960693448a6c809c6309de2344" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is not a standard placeholder type, this template is derived from &lt;code&gt;&lt;a href=&quot;../../types/integral_constant&quot;&gt;std::integral_constant&lt;/a&gt;&amp;lt;int,0&amp;gt;&lt;/code&gt;</source>
          <target state="translated">Если &lt;code&gt;T&lt;/code&gt; не является стандартным типом заполнителя, этот шаблон является производным от &lt;code&gt;&lt;a href=&quot;../../types/integral_constant&quot;&gt;std::integral_constant&lt;/a&gt;&amp;lt;int,0&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5ee1c8ebae98c21b02f68dd05886f8fe92f20e99" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is not const-qualified, then &lt;code&gt;rv&lt;/code&gt;'s resulting state (after the definition/expression is evaluated in either bullets above) is valid but unspecified; otherwise, it is unchanged.</source>
          <target state="translated">Если &lt;code&gt;T&lt;/code&gt; не является константно-квалифицированным, то результирующее состояние &lt;code&gt;rv&lt;/code&gt; (после того, как определение / выражение оценивается в обеих пулях выше) является допустимым, но не определенным; в противном случае оно не изменяется.</target>
        </trans-unit>
        <trans-unit id="615bba93f7cf789b20b52441a5845c09300784e0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is pointer to non-static member object or a pointer to non-static member function, provides the member constant &lt;code&gt;value&lt;/code&gt; equal &lt;code&gt;true&lt;/code&gt;. For any other type, &lt;code&gt;value&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;T&lt;/code&gt; - указатель на нестатический объект-член или указатель на нестатическую функцию-член, &lt;code&gt;value&lt;/code&gt; константы члена равно &lt;code&gt;true&lt;/code&gt; . Для любого другого типа &lt;code&gt;value&lt;/code&gt; равно &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f5ac84ccbccc9198a7ab09ce3b026f6c47e5ff46" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is reference type, nothing is done.</source>
          <target state="translated">Если &lt;code&gt;T&lt;/code&gt; является ссылочным типом, ничего не делается.</target>
        </trans-unit>
        <trans-unit id="2f854a51cba2ddf3f5cc88ad123c5f24a105a0f4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is the type of a standard placeholder (_1, _2, _3, ...), then this template is derived from &lt;code&gt;&lt;a href=&quot;../../types/integral_constant&quot;&gt;std::integral_constant&lt;/a&gt;&amp;lt;int,1&amp;gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../../types/integral_constant&quot;&gt;std::integral_constant&lt;/a&gt;&amp;lt;int,2&amp;gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../../types/integral_constant&quot;&gt;std::integral_constant&lt;/a&gt;&amp;lt;int,3&amp;gt;&lt;/code&gt;, respectively.</source>
          <target state="translated">Если &lt;code&gt;T&lt;/code&gt; является типом стандартного заполнителя (_1, _2, _3, ...), то этот шаблон является производным от &lt;code&gt;&lt;a href=&quot;../../types/integral_constant&quot;&gt;std::integral_constant&lt;/a&gt;&amp;lt;int,1&amp;gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../../types/integral_constant&quot;&gt;std::integral_constant&lt;/a&gt;&amp;lt;int,2&amp;gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../../types/integral_constant&quot;&gt;std::integral_constant&lt;/a&gt;&amp;lt;int,3&amp;gt;&lt;/code&gt; соответственно.</target>
        </trans-unit>
        <trans-unit id="f81cf7e82856e3e7cad5504cd15ee27f838ea825" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is the type produced by a call to &lt;code&gt;&lt;a href=&quot;bind&quot;&gt;std::bind&lt;/a&gt;&lt;/code&gt;, this template is derived from &lt;code&gt;&lt;a href=&quot;../../types/integral_constant&quot;&gt;std::true_type&lt;/a&gt;&lt;/code&gt;. For any other type, this template is derived from &lt;code&gt;&lt;a href=&quot;../../types/integral_constant&quot;&gt;std::false_type&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;T&lt;/code&gt; является типом, полученным при вызове &lt;code&gt;&lt;a href=&quot;bind&quot;&gt;std::bind&lt;/a&gt;&lt;/code&gt; , этот шаблон является производным от &lt;code&gt;&lt;a href=&quot;../../types/integral_constant&quot;&gt;std::true_type&lt;/a&gt;&lt;/code&gt; . Для любого другого типа этот шаблон является производным от &lt;code&gt;&lt;a href=&quot;../../types/integral_constant&quot;&gt;std::false_type&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="51e3546d16456aa08a11e4cc71a3bbf5dec35bfe" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is trivially-destructible, then this destructor is also trivial, so &lt;code&gt;optional&amp;lt;T&amp;gt;&lt;/code&gt; is also trivially-destructible.</source>
          <target state="translated">Если &lt;code&gt;T&lt;/code&gt; тривиально-разрушаемо, то этот деструктор также тривиально, поэтому &lt;code&gt;optional&amp;lt;T&amp;gt;&lt;/code&gt; также тривиально-разрушаем.</target>
        </trans-unit>
        <trans-unit id="d31c04866aa7a4ef595b5ddda4f6ba3e2b023b2f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; models &lt;a href=&quot;../concepts/defaultconstructible&quot;&gt;&lt;code&gt;DefaultConstructible&lt;/code&gt;&lt;/a&gt;, the default constructor of &lt;code&gt;&lt;i&gt;semiregular&lt;/i&gt;&amp;lt;T&amp;gt;&lt;/code&gt; constructs a semiregular wrapper containing a value-initialized &lt;code&gt;T&lt;/code&gt; and is equivalent to:</source>
          <target state="translated">Если &lt;code&gt;T&lt;/code&gt; моделирует &lt;a href=&quot;../concepts/defaultconstructible&quot;&gt; &lt;code&gt;DefaultConstructible&lt;/code&gt; &lt;/a&gt; , конструктор по умолчанию для &lt;code&gt;&lt;i&gt;semiregular&lt;/i&gt;&amp;lt;T&amp;gt;&lt;/code&gt; создает полурегулярную оболочку, содержащую инициализированный значением &lt;code&gt;T&lt;/code&gt; и эквивалентный:</target>
        </trans-unit>
        <trans-unit id="02a86ca705d443044b0fbfb7fbc9ab041d9a2f6e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; names the type &quot;array of &lt;code&gt;U&lt;/code&gt;&quot; or &quot;reference to array of &lt;code&gt;U&lt;/code&gt;&quot;, the member typedef &lt;code&gt;type&lt;/code&gt; is &lt;code&gt;U*&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;T&lt;/code&gt; называет тип &amp;laquo;массив из &lt;code&gt;U&lt;/code&gt; &amp;raquo; или &amp;laquo;ссылка на массив из &lt;code&gt;U&lt;/code&gt; &amp;raquo;, &lt;code&gt;type&lt;/code&gt; typedef члена является &lt;code&gt;U*&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3c2891f9d56d7ae3301606af512c7f8ffc24cd7a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; satisfies all requirements of &lt;a href=&quot;../named_req/literaltype&quot;&gt;LiteralType&lt;/a&gt;, provides the member constant &lt;code&gt;value&lt;/code&gt; equal &lt;code&gt;true&lt;/code&gt;. For any other type, &lt;code&gt;value&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;T&lt;/code&gt; удовлетворяет всем требованиям &lt;a href=&quot;../named_req/literaltype&quot;&gt;LiteralType&lt;/a&gt; , &lt;code&gt;value&lt;/code&gt; константы члена равно &lt;code&gt;true&lt;/code&gt; . Для любого другого типа &lt;code&gt;value&lt;/code&gt; равно &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ac1553fe834dd9a1efb1dfce83c0e4902b9cd37a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; satisfies the &lt;a href=&quot;../named_req/clock&quot;&gt;Clock&lt;/a&gt; requirements, provides the member constant &lt;code&gt;value&lt;/code&gt; equal &lt;code&gt;true&lt;/code&gt;. For any other type, &lt;code&gt;value&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;T&lt;/code&gt; удовлетворяет требованиям &lt;a href=&quot;../named_req/clock&quot;&gt;Clock&lt;/a&gt; , &lt;code&gt;value&lt;/code&gt; константы члена равно &lt;code&gt;true&lt;/code&gt; . Для любого другого типа &lt;code&gt;value&lt;/code&gt; равно &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c87275ecad38359126e4f40cf9ccd9918c5e81e8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt;'s move constructor is not &lt;code&gt;noexcept&lt;/code&gt; and T is not &lt;a href=&quot;../../named_req/copyinsertable&quot;&gt;CopyInsertable&lt;/a&gt; into &lt;code&gt;*this&lt;/code&gt;, vector will use the throwing move constructor. If it throws, the guarantee is waived and the effects are unspecified.</source>
          <target state="translated">Если &lt;code&gt;T&lt;/code&gt; двигаться конструктор &amp;laquo;s не &lt;code&gt;noexcept&lt;/code&gt; и Т не &lt;a href=&quot;../../named_req/copyinsertable&quot;&gt;CopyInsertable&lt;/a&gt; в &lt;code&gt;*this&lt;/code&gt; вектор будет использовать конструктор метание перемещения. Если он выбрасывает, гарантия отменяется, а последствия не уточняются.</target>
        </trans-unit>
        <trans-unit id="407149e5ef249263ab827511e7e341fc16d6fcf6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T_i&lt;/code&gt; is (possibly cv-qualified) &lt;code&gt;bool&lt;/code&gt;, &lt;code&gt;F(T_i)&lt;/code&gt; is only considered if &lt;code&gt;std:remove_cvref_t&amp;lt;T&amp;gt;&lt;/code&gt; is also &lt;code&gt;bool&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;T_i&lt;/code&gt; является (возможно, cv-квалифицированным) &lt;code&gt;bool&lt;/code&gt; , &lt;code&gt;F(T_i)&lt;/code&gt; учитывается, только если &lt;code&gt;std:remove_cvref_t&amp;lt;T&amp;gt;&lt;/code&gt; также является &lt;code&gt;bool&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c4907a3ab559108aaf0ecc4b4c630266b6c2f7d6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;U&lt;/code&gt; or &lt;code&gt;V&lt;/code&gt; is not representable in &lt;code&gt;std::intmax_t&lt;/code&gt;, the program is ill-formed. If &lt;code&gt;Num&lt;/code&gt; or &lt;code&gt;Denom&lt;/code&gt; is not representable in &lt;code&gt;std::intmax_t&lt;/code&gt;, the program is ill-formed unless the implementation yields correct values for &lt;code&gt;U&lt;/code&gt; and &lt;code&gt;V&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;U&lt;/code&gt; или &lt;code&gt;V&lt;/code&gt; не представимы в &lt;code&gt;std::intmax_t&lt;/code&gt; , программа некорректна. Если &lt;code&gt;Num&lt;/code&gt; или &lt;code&gt;Denom&lt;/code&gt; не представим в &lt;code&gt;std::intmax_t&lt;/code&gt; , программа плохо сформированный , если реализация не дает правильные значения &lt;code&gt;U&lt;/code&gt; и &lt;code&gt;V&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1339288b4eceede884dbe475de639d7a8e96920b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;X&lt;/code&gt; is not allocator-aware, the term is defined as if &lt;code&gt;A&lt;/code&gt; were &lt;code&gt;&lt;a href=&quot;../memory/allocator&quot;&gt;std::allocator&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt;, except that no allocator object needs to be created, and user-defined specializations of &lt;code&gt;&lt;a href=&quot;../memory/allocator&quot;&gt;std::allocator&lt;/a&gt;&lt;/code&gt; are not instantiated.</source>
          <target state="translated">Если &lt;code&gt;X&lt;/code&gt; не осведомлен о распределителе, термин определяется так, как если бы &lt;code&gt;A&lt;/code&gt; были &lt;code&gt;&lt;a href=&quot;../memory/allocator&quot;&gt;std::allocator&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt; , за исключением того, что не требуется создавать объект &lt;code&gt;&lt;a href=&quot;../memory/allocator&quot;&gt;std::allocator&lt;/a&gt;&lt;/code&gt; и не создаются экземпляры пользовательских спецификаций std :: allocator .</target>
        </trans-unit>
        <trans-unit id="e215c6bfa230a8fadbd8fa567ff0d1dcc73d9d4e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;X&lt;/code&gt; is not allocator-aware, the term is defined as if &lt;code&gt;A&lt;/code&gt; were &lt;code&gt;std::allocator&amp;lt;T&amp;gt;&lt;/code&gt;, except that no allocator object needs to be created, and user-defined specializations of &lt;code&gt;&lt;a href=&quot;../memory/allocator&quot;&gt;std::allocator&lt;/a&gt;&lt;/code&gt; are not instantiated.</source>
          <target state="translated">Если &lt;code&gt;X&lt;/code&gt; не осведомлен о распределителе, термин определяется так, как если бы &lt;code&gt;A&lt;/code&gt; были &lt;code&gt;std::allocator&amp;lt;T&amp;gt;&lt;/code&gt; , за исключением того, что не требуется создавать объект &lt;code&gt;&lt;a href=&quot;../memory/allocator&quot;&gt;std::allocator&lt;/a&gt;&lt;/code&gt; и не создаются экземпляры пользовательских спецификаций std :: allocator .</target>
        </trans-unit>
        <trans-unit id="708924c7b6f5980aac166862125db725c9025582" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;[s_first, s_last)&lt;/code&gt; is empty or if no such sequence is found, &lt;code&gt;last&lt;/code&gt; is returned.</source>
          <target state="translated">Если &lt;code&gt;[s_first, s_last)&lt;/code&gt; пусто или такая последовательность не найдена, возвращается &lt;code&gt;last&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4de674a59bdc38a4524989e3aa936059b297e948" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;[s_first, s_last)&lt;/code&gt; is empty, &lt;code&gt;first&lt;/code&gt; is returned. (since C++11)</source>
          <target state="translated">Если &lt;code&gt;[s_first, s_last)&lt;/code&gt; пуст, возвращается &lt;code&gt;first&lt;/code&gt; . (начиная с C ++ 11)</target>
        </trans-unit>
        <trans-unit id="ac8a7837d00559195769abe3422b2d4b64b0803f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a &amp;lt; b&lt;/code&gt; and &lt;code&gt;b &amp;lt; c&lt;/code&gt; then &lt;code&gt;a &amp;lt; c&lt;/code&gt;</source>
          <target state="translated">Если &lt;code&gt;a &amp;lt; b&lt;/code&gt; и &lt;code&gt;b &amp;lt; c&lt;/code&gt; то &lt;code&gt;a &amp;lt; c&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d0fbd3756fc442152ea5c157999e136ae32a5c4c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a &amp;lt; b&lt;/code&gt; then &lt;code&gt;!(b &amp;lt; a)&lt;/code&gt;</source>
          <target state="translated">Если &lt;code&gt;a &amp;lt; b&lt;/code&gt; то &lt;code&gt;!(b &amp;lt; a)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ca13a23e17308315822746f838d58d67fdc10969" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a == b&lt;/code&gt; and &lt;code&gt;b == c&lt;/code&gt;, then &lt;code&gt;a == c&lt;/code&gt;</source>
          <target state="translated">Если &lt;code&gt;a == b&lt;/code&gt; и &lt;code&gt;b == c&lt;/code&gt; , то &lt;code&gt;a == c&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="57b477a3ad052ca87058c8d285998bd3826578b9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a == b&lt;/code&gt;, subsequent calls to the &lt;a href=&quot;operator()&quot;&gt;&lt;code&gt;operator()&lt;/code&gt;&lt;/a&gt; overload that does not accept a &lt;code&gt;param_type&lt;/code&gt; object will cause undefined behavior.</source>
          <target state="translated">Если &lt;code&gt;a == b&lt;/code&gt; , последующие вызовы перегрузки &lt;a href=&quot;operator()&quot;&gt; &lt;code&gt;operator()&lt;/code&gt; &lt;/a&gt; , которая не принимает объект &lt;code&gt;param_type&lt;/code&gt; , вызовут неопределенное поведение.</target>
        </trans-unit>
        <trans-unit id="058ec9eda946d2f87a4c67ddd844abb0705335fb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a == b&lt;/code&gt;, then &lt;code&gt;b == a&lt;/code&gt;</source>
          <target state="translated">Если &lt;code&gt;a == b&lt;/code&gt; , то &lt;code&gt;b == a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3e95c4991d153eb49fcdeb67a49f232435c188d8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; compare equal (&lt;code&gt;a == b&lt;/code&gt; is contextually convertible to &lt;code&gt;true&lt;/code&gt;) then either they are both non-dereferenceable or &lt;code&gt;*a&lt;/code&gt; and &lt;code&gt;*b&lt;/code&gt; are references bound to the same object</source>
          <target state="translated">Если &lt;code&gt;a&lt;/code&gt; и &lt;code&gt;b&lt;/code&gt; сравниваются равными ( &lt;code&gt;a == b&lt;/code&gt; контекстуально преобразуется в &lt;code&gt;true&lt;/code&gt; ), то либо они не являются разыменованными, либо &lt;code&gt;*a&lt;/code&gt; и &lt;code&gt;*b&lt;/code&gt; являются ссылками, связанными с одним и тем же объектом</target>
        </trans-unit>
        <trans-unit id="b0965a7f22c182c2dc94b342ec734afedbfb197f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;adjustfield == &lt;a href=&quot;../../io/ios_base/fmtflags&quot;&gt;std::ios_base::internal&lt;/a&gt;&lt;/code&gt; and Stage 1 representation began with 0x or 0X, will pad after the x or X</source>
          <target state="translated">Если &lt;code&gt;adjustfield == &lt;a href=&quot;../../io/ios_base/fmtflags&quot;&gt;std::ios_base::internal&lt;/a&gt;&lt;/code&gt; и представление на этапе 1 началось с 0x или 0X, будет дополняться после x или X</target>
        </trans-unit>
        <trans-unit id="55fb07ae63090e46c1b31757c60deb3993a02ead" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;adjustfield == &lt;a href=&quot;../../io/ios_base/fmtflags&quot;&gt;std::ios_base::internal&lt;/a&gt;&lt;/code&gt; and a sign character occurs in the representation, will pad after the sign</source>
          <target state="translated">Если &lt;code&gt;adjustfield == &lt;a href=&quot;../../io/ios_base/fmtflags&quot;&gt;std::ios_base::internal&lt;/a&gt;&lt;/code&gt; и символ знака встречается в представлении, будет дополняться после знака</target>
        </trans-unit>
        <trans-unit id="df7f9cf85073b22f00c706bbf069fde1413ff653" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;adjustfield == &lt;a href=&quot;../../io/ios_base/fmtflags&quot;&gt;std::ios_base::left&lt;/a&gt;&lt;/code&gt;, will pad after</source>
          <target state="translated">Если &lt;code&gt;adjustfield == &lt;a href=&quot;../../io/ios_base/fmtflags&quot;&gt;std::ios_base::left&lt;/a&gt;&lt;/code&gt; , будет дополняться после</target>
        </trans-unit>
        <trans-unit id="efe26e828a675b79b7ef6061fde6939469a2c778" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;adjustfield == &lt;a href=&quot;../../io/ios_base/fmtflags&quot;&gt;std::ios_base::right&lt;/a&gt;&lt;/code&gt;, will pad before</source>
          <target state="translated">Если &lt;code&gt;adjustfield == &lt;a href=&quot;../../io/ios_base/fmtflags&quot;&gt;std::ios_base::right&lt;/a&gt;&lt;/code&gt; , будет дополняться раньше</target>
        </trans-unit>
        <trans-unit id="6ee5eea45cb84fb94f59a5848a1a90638eee5d0e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;alignof(T)&lt;/code&gt; is not a valid expression, the behavior is undefined.</source>
          <target state="translated">Если &lt;code&gt;alignof(T)&lt;/code&gt; не является допустимым выражением, поведение не определено.</target>
        </trans-unit>
        <trans-unit id="39035be25eaa7a5daa7ee9badf8db195c8f6f1c2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;arg&lt;/code&gt; is &amp;plusmn;&amp;infin;, +&amp;infin; is returned</source>
          <target state="translated">Если &lt;code&gt;arg&lt;/code&gt; равен &amp;plusmn; &amp;infin;, + &amp;infin; возвращается</target>
        </trans-unit>
        <trans-unit id="dc64028dd5e1343ad289a2a638ecad4eabe7dfc5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;arg&lt;/code&gt; is &amp;plusmn;&amp;infin;, &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; is raised and an implementation-defined value is returned</source>
          <target state="translated">Если &lt;code&gt;arg&lt;/code&gt; равен &amp;plusmn; &amp;infin;, &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; повышается и возвращается значение, определенное реализацией</target>
        </trans-unit>
        <trans-unit id="212c6a1d0fbeb2a948b299caf94641bec455cf7b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;arg&lt;/code&gt; is &amp;plusmn;&amp;infin;, it is returned unmodified</source>
          <target state="translated">Если &lt;code&gt;arg&lt;/code&gt; равен &amp;plusmn; &amp;infin;, он возвращается без изменений</target>
        </trans-unit>
        <trans-unit id="3af634b2f314cdb14e21e2e232aa0d848e98f5e8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;arg&lt;/code&gt; is &amp;plusmn;&amp;infin;, it is returned, and an unspecified value is stored in &lt;code&gt;*exp&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;arg&lt;/code&gt; равен &amp;plusmn; &amp;infin;, он возвращается, и неопределенное значение сохраняется в &lt;code&gt;*exp&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2926296a9d3ae122af29b30e2bff2458387535b0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;arg&lt;/code&gt; is &amp;plusmn;&amp;infin;, it is returned, unmodified</source>
          <target state="translated">Если &lt;code&gt;arg&lt;/code&gt; равен &amp;plusmn; &amp;infin;, он возвращается без изменений</target>
        </trans-unit>
        <trans-unit id="dcb585953813ddfd53495aac0adc0c6028656a9c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;arg&lt;/code&gt; is &amp;plusmn;0, &amp;plusmn;&amp;infin;, or NaN, &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; is raised.</source>
          <target state="translated">Если &lt;code&gt;arg&lt;/code&gt; равно &amp;plusmn; 0, &amp;plusmn; &amp;infin; или NaN, &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; повышается.</target>
        </trans-unit>
        <trans-unit id="97a7ce4796bb66aaa2d696b735ad8ca62a0d506b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;arg&lt;/code&gt; is &amp;plusmn;0, -&amp;infin; is returned and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_DIVBYZERO&lt;/a&gt;&lt;/code&gt; is raised.</source>
          <target state="translated">Если &lt;code&gt;arg&lt;/code&gt; равен &amp;plusmn; 0, возвращается -&amp;infin; и значение &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_DIVBYZERO&lt;/a&gt;&lt;/code&gt; повышается.</target>
        </trans-unit>
        <trans-unit id="4c925fdb14d37c5af0412f43389d6420fcbebc31" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;arg&lt;/code&gt; is &amp;plusmn;0, it is returned, unmodified</source>
          <target state="translated">Если &lt;code&gt;arg&lt;/code&gt; равен &amp;plusmn; 0, он возвращается без изменений</target>
        </trans-unit>
        <trans-unit id="b763f3ae25fa4af1639d7559710e6c7dfb77bb58" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;arg&lt;/code&gt; is &amp;plusmn;0, it is returned, unmodified, and &lt;code&gt;0&lt;/code&gt; is stored in &lt;code&gt;*exp&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;arg&lt;/code&gt; равен &amp;plusmn; 0, он возвращается без изменений, а &lt;code&gt;0&lt;/code&gt; сохраняется в &lt;code&gt;*exp&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5f109ac78880a8e0fd5ca3edc07d2d1bf947af61" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;arg&lt;/code&gt; is NaN, &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; is raised and an implementation-defined value is returned</source>
          <target state="translated">Если &lt;code&gt;arg&lt;/code&gt; равен NaN, &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; повышается, и возвращается значение, определенное реализацией</target>
        </trans-unit>
        <trans-unit id="40f86add69087dfb700cacff3b1846927488c73a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;arg&lt;/code&gt; is NaN, NaN is returned</source>
          <target state="translated">Если &lt;code&gt;arg&lt;/code&gt; равен NaN, NaN возвращается</target>
        </trans-unit>
        <trans-unit id="5f68328ad47978170da252aebc348fd2a3ba01b4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;arg&lt;/code&gt; is NaN, NaN is returned, and an unspecified value is stored in &lt;code&gt;*exp&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;arg&lt;/code&gt; равен NaN, возвращается NaN, а неопределенное значение сохраняется в &lt;code&gt;*exp&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1b0e2c569c27377f09ed2aa7f3f01ddd8ab82ed0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;arg&lt;/code&gt; is NaN, NaN is returned.</source>
          <target state="translated">Если &lt;code&gt;arg&lt;/code&gt; равен NaN, NaN возвращается.</target>
        </trans-unit>
        <trans-unit id="b47b8c75e53c96b45595a288fa682cfb71c94c2d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;arg&lt;/code&gt; is a NaN, &lt;code&gt;FP_ILOGBNAN&lt;/code&gt; is returned.</source>
          <target state="translated">Если &lt;code&gt;arg&lt;/code&gt; является NaN, возвращается &lt;code&gt;FP_ILOGBNAN&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="103047025bbc6992cc2c0159391152d1cac0b073" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;arg&lt;/code&gt; is a natural number, &lt;code&gt;std::lgamma(arg)&lt;/code&gt; is the logarithm of the factorial of &lt;code&gt;arg-1&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;arg&lt;/code&gt; натуральное число, &lt;code&gt;std::lgamma(arg)&lt;/code&gt; является логарифмом факториала &lt;code&gt;arg-1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b0d43e3c2f39b7c1f66e9428682a4d9539c507a8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;arg&lt;/code&gt; is a natural number, &lt;code&gt;std::tgamma(arg)&lt;/code&gt; is the factorial of &lt;code&gt;arg-1&lt;/code&gt;. Many implementations calculate the exact integer-domain factorial if the argument is a sufficiently small integer.</source>
          <target state="translated">Если &lt;code&gt;arg&lt;/code&gt; натуральное число, &lt;code&gt;std::tgamma(arg)&lt;/code&gt; является факториалом &lt;code&gt;arg-1&lt;/code&gt; . Многие реализации вычисляют точный факториал целочисленной области, если аргумент является достаточно маленьким целым числом.</target>
        </trans-unit>
        <trans-unit id="2b3d194b382b4cec828f1996e8820c92fc1bc82f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;arg&lt;/code&gt; is infinite, &lt;code&gt;&lt;a href=&quot;../../types/climits&quot;&gt;INT_MAX&lt;/a&gt;&lt;/code&gt; is returned.</source>
          <target state="translated">Если &lt;code&gt;arg&lt;/code&gt; бесконечно, возвращается &lt;code&gt;&lt;a href=&quot;../../types/climits&quot;&gt;INT_MAX&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9e168df92098d4104c20f40ff2c56e9cb3e43970" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;arg&lt;/code&gt; is not a floating-point number, the behavior is unspecified.</source>
          <target state="translated">Если &lt;code&gt;arg&lt;/code&gt; не является числом с плавающей точкой, поведение не определено.</target>
        </trans-unit>
        <trans-unit id="2804f0355d48777b9700b17ec3da3dcca55d9469" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;arg&lt;/code&gt; is not zero, infinite, or NaN, the value returned is exactly equivalent to &lt;code&gt;static_cast&amp;lt;int&amp;gt;(&lt;a href=&quot;logb&quot;&gt;std::logb&lt;/a&gt;(arg))&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;arg&lt;/code&gt; не ноль, бесконечность или NaN, возвращаемое значение точно эквивалентно &lt;code&gt;static_cast&amp;lt;int&amp;gt;(&lt;a href=&quot;logb&quot;&gt;std::logb&lt;/a&gt;(arg))&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="210d2992bbf2bb7d542ddc01b1a18747c781302a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;arg&lt;/code&gt; is zero or is an integer less than zero, a pole error may occur.</source>
          <target state="translated">Если &lt;code&gt;arg&lt;/code&gt; равно нулю или целое число меньше нуля, может возникнуть ошибка полюса.</target>
        </trans-unit>
        <trans-unit id="05dafa4d596b7b6f157f2afaee02072f8d977259" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;arg&lt;/code&gt; is zero or is an integer less than zero, a pole error or a domain error may occur.</source>
          <target state="translated">Если &lt;code&gt;arg&lt;/code&gt; равно нулю или целое число меньше нуля, может возникнуть ошибка полюса или ошибка домена.</target>
        </trans-unit>
        <trans-unit id="c39db051a1df2187c97bcf9b3a8feca13bc7aae3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;arg&lt;/code&gt; is zero, &lt;code&gt;FP_ILOGB0&lt;/code&gt; is returned.</source>
          <target state="translated">Если &lt;code&gt;arg&lt;/code&gt; равен нулю, возвращается &lt;code&gt;FP_ILOGB0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4481c06a081e138b96375d6a39a2024c3db3720a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;arg&lt;/code&gt; is zero, returns zero and stores zero in &lt;code&gt;*exp&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;arg&lt;/code&gt; равен нулю, возвращает ноль и сохраняет ноль в &lt;code&gt;*exp&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="277ca8d97ddf64738fdbd1aa4e973cb1bc8ff33f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;b&lt;/code&gt; is true, the returned bitmask is suitable for matching characters without regard to their case.</source>
          <target state="translated">Если &lt;code&gt;b&lt;/code&gt; равно true, возвращенная битовая маска подходит для сопоставления символов без учета их регистра.</target>
        </trans-unit>
        <trans-unit id="bc2ce27f23e51347316eec1df499f96102e63b30" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;base&lt;/code&gt; is &lt;code&gt;TIME_UTC&lt;/code&gt;, then.</source>
          <target state="translated">Если &lt;code&gt;base&lt;/code&gt; является &lt;code&gt;TIME_UTC&lt;/code&gt; , то.</target>
        </trans-unit>
        <trans-unit id="39772be1360347ea75162c3cf41cc79a0690aefc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;base&lt;/code&gt; is finite and negative and &lt;code&gt;exp&lt;/code&gt; is finite and non-integer, a domain error occurs and a range error may occur.</source>
          <target state="translated">Если &lt;code&gt;base&lt;/code&gt; является конечным и отрицательным, а &lt;code&gt;exp&lt;/code&gt; конечным и нецелым, возникает ошибка домена и может возникать ошибка диапазона.</target>
        </trans-unit>
        <trans-unit id="fcb4bb9772be34cee0a2ea72f8a48a52aed0d515" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;base&lt;/code&gt; is zero and &lt;code&gt;exp&lt;/code&gt; is negative, a domain error or a pole error may occur.</source>
          <target state="translated">Если &lt;code&gt;base&lt;/code&gt; равен нулю, а &lt;code&gt;exp&lt;/code&gt; отрицателен, может возникнуть ошибка домена или ошибка полюса.</target>
        </trans-unit>
        <trans-unit id="8cefb315066ca34b099a440410777215c4c88531" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;base&lt;/code&gt; is zero and &lt;code&gt;exp&lt;/code&gt; is zero, a domain error may occur.</source>
          <target state="translated">Если &lt;code&gt;base&lt;/code&gt; равен нулю, а &lt;code&gt;exp&lt;/code&gt; равен нулю, может возникнуть ошибка домена.</target>
        </trans-unit>
        <trans-unit id="735a9c2b9ccda41b360b2ccc955e4ce336eebbf7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;basefield == 0&lt;/code&gt;, will use conversion specifier &lt;code&gt;%i&lt;/code&gt;</source>
          <target state="translated">Если &lt;code&gt;basefield == 0&lt;/code&gt; , будет использоваться спецификатор преобразования &lt;code&gt;%i&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="72b1b1221364073e1a83ddb04c69595be539a496" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;basefield == hex &amp;amp;&amp;amp; !uppercase&lt;/code&gt;, will use conversion specifier &lt;code&gt;%x&lt;/code&gt;</source>
          <target state="translated">Если &lt;code&gt;basefield == hex &amp;amp;&amp;amp; !uppercase&lt;/code&gt; , будет использоваться спецификатор преобразования &lt;code&gt;%x&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b4a2fc2012f6b4718df5c8bbc44f6bc3ac7c622d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;basefield == hex&lt;/code&gt;, will use conversion specifier &lt;code&gt;%X&lt;/code&gt;</source>
          <target state="translated">Если &lt;code&gt;basefield == hex&lt;/code&gt; , будет использовать спецификатор преобразования &lt;code&gt;%X&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="abc0fd7910d8386906f231979d946d3d6fcf720b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;basefield == oct&lt;/code&gt;, will use conversion specifier &lt;code&gt;%o&lt;/code&gt;</source>
          <target state="translated">Если &lt;code&gt;basefield == oct&lt;/code&gt; , будет использоваться спецификатор преобразования &lt;code&gt;%o&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="dafca5cc04b66da6cecdcb0541cbba62d4fe3fca" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;begin == end&lt;/code&gt;, do nothing. Otherwise,</source>
          <target state="translated">Если &lt;code&gt;begin == end&lt;/code&gt; , ничего не делать. В противном случае,</target>
        </trans-unit>
        <trans-unit id="bc82eb0dcae0fc58deeb2027018fdeadab408395" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;bool(a &amp;lt; b)&lt;/code&gt; and &lt;code&gt;bool(b &amp;lt; c)&lt;/code&gt; are both &lt;code&gt;true&lt;/code&gt;, then &lt;code&gt;bool(a &amp;lt; c)&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;;</source>
          <target state="translated">Если &lt;code&gt;bool(a &amp;lt; b)&lt;/code&gt; и &lt;code&gt;bool(b &amp;lt; c)&lt;/code&gt; оба имеют значение &lt;code&gt;true&lt;/code&gt; , то &lt;code&gt;bool(a &amp;lt; c)&lt;/code&gt; имеет значение &lt;code&gt;true&lt;/code&gt; ;</target>
        </trans-unit>
        <trans-unit id="0c3b57cf400e324fc93a37880e317b6a3f4e7284" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;boolalpha != 0&lt;/code&gt; obtains &lt;code&gt;&lt;a href=&quot;../use_facet&quot;&gt;std::use_facet&lt;/a&gt;&amp;lt;&lt;a href=&quot;../numpunct&quot;&gt;std::numpunct&lt;/a&gt;&amp;lt;charT&amp;gt;&amp;gt;(str.getloc()).truename()&lt;/code&gt; if &lt;code&gt;v == true&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../use_facet&quot;&gt;std::use_facet&lt;/a&gt;&amp;lt;&lt;a href=&quot;../numpunct&quot;&gt;std::numpunct&lt;/a&gt;&amp;lt;charT&amp;gt;&amp;gt;(str.getloc()).falsename()&lt;/code&gt; if &lt;code&gt;v == false&lt;/code&gt;, and outputs each successive character &lt;code&gt;c&lt;/code&gt; of that string to &lt;code&gt;out&lt;/code&gt; with &lt;code&gt;*out++ = c&lt;/code&gt;. No further processing is done in this case, the function returns &lt;code&gt;out&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;boolalpha != 0&lt;/code&gt; получает &lt;code&gt;&lt;a href=&quot;../use_facet&quot;&gt;std::use_facet&lt;/a&gt;&amp;lt;&lt;a href=&quot;../numpunct&quot;&gt;std::numpunct&lt;/a&gt;&amp;lt;charT&amp;gt;&amp;gt;(str.getloc()).truename()&lt;/code&gt; если &lt;code&gt;v == true&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;../use_facet&quot;&gt;std::use_facet&lt;/a&gt;&amp;lt;&lt;a href=&quot;../numpunct&quot;&gt;std::numpunct&lt;/a&gt;&amp;lt;charT&amp;gt;&amp;gt;(str.getloc()).falsename()&lt;/code&gt; если &lt;code&gt;v == false&lt;/code&gt; , и выводит каждый последующий символ &lt;code&gt;c&lt;/code&gt; этой строки в &lt;code&gt;out&lt;/code&gt; с &lt;code&gt;*out++ = c&lt;/code&gt; . Никакой дополнительной обработки не делается в этом случае функция возвращает &lt;code&gt;out&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="209116e8fd40fdecd41f59a58ba5cba05cc96e2d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;boolalpha == 0&lt;/code&gt;, then converts &lt;code&gt;v&lt;/code&gt; to type &lt;code&gt;int&lt;/code&gt; and performs integer output.</source>
          <target state="translated">Если &lt;code&gt;boolalpha == 0&lt;/code&gt; , то конвертирует &lt;code&gt;v&lt;/code&gt; в тип &lt;code&gt;int&lt;/code&gt; и выполняет целочисленный вывод.</target>
        </trans-unit>
        <trans-unit id="701f5d02367a24c659b0e907a89da5f3ee588ad7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;buffer&lt;/code&gt; is a null pointer, resizes the internal buffer to &lt;code&gt;size&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;buffer&lt;/code&gt; является нулевым указателем, &lt;code&gt;size&lt;/code&gt; внутреннего буфера изменяется до размера .</target>
        </trans-unit>
        <trans-unit id="bb7a30a4993475e7a73929ac360a9b27b0b3f966" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;buffer&lt;/code&gt; is not a null pointer, instructs the stream to use the user-provided buffer of size &lt;code&gt;size&lt;/code&gt; beginning at &lt;code&gt;buffer&lt;/code&gt;. The stream must be closed (with &lt;code&gt;fclose&lt;/code&gt;) before the &lt;a href=&quot;../../language/lifetime&quot;&gt;lifetime&lt;/a&gt; of the array pointed to by &lt;code&gt;buffer&lt;/code&gt; ends. The contents of the array after a successful call to &lt;code&gt;setvbuf&lt;/code&gt; are indeterminate and any attempt to use it is undefined behavior.</source>
          <target state="translated">Если &lt;code&gt;buffer&lt;/code&gt; не является нулевым указателем, указывает потоку использовать предоставленный пользователем буфер с размером &lt;code&gt;size&lt;/code&gt; начиная с &lt;code&gt;buffer&lt;/code&gt; . Поток должен быть закрыт (с помощью &lt;code&gt;fclose&lt;/code&gt; ) до окончания &lt;a href=&quot;../../language/lifetime&quot;&gt;срока&lt;/a&gt; действия массива, на который указывает &lt;code&gt;buffer&lt;/code&gt; . Содержимое массива после успешного вызова &lt;code&gt;setvbuf&lt;/code&gt; является неопределенным, и любая попытка использовать его является неопределенным поведением.</target>
        </trans-unit>
        <trans-unit id="a4aa2a51ab02bfef78d16d2394217fe58c759175" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;buffer&lt;/code&gt; is not null, equivalent to &lt;code&gt;&lt;a href=&quot;setvbuf&quot;&gt;std::setvbuf&lt;/a&gt;(stream, buffer, &lt;a href=&quot;../c&quot;&gt;_IOFBF&lt;/a&gt;, &lt;a href=&quot;../c&quot;&gt;BUFSIZ&lt;/a&gt;)&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;buffer&lt;/code&gt; не равен NULL, эквивалентно &lt;code&gt;&lt;a href=&quot;setvbuf&quot;&gt;std::setvbuf&lt;/a&gt;(stream, buffer, &lt;a href=&quot;../c&quot;&gt;_IOFBF&lt;/a&gt;, &lt;a href=&quot;../c&quot;&gt;BUFSIZ&lt;/a&gt;)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fda3355283db2eca141b2739a1e7b6dba9c66231" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;buffer&lt;/code&gt; is null, equivalent to &lt;code&gt;&lt;a href=&quot;setvbuf&quot;&gt;std::setvbuf&lt;/a&gt;(stream, &lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;, &lt;a href=&quot;../c&quot;&gt;_IONBF&lt;/a&gt;, 0)&lt;/code&gt;, which turns off buffering.</source>
          <target state="translated">Если значение &lt;code&gt;buffer&lt;/code&gt; равно нулю, эквивалентно &lt;code&gt;&lt;a href=&quot;setvbuf&quot;&gt;std::setvbuf&lt;/a&gt;(stream, &lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;, &lt;a href=&quot;../c&quot;&gt;_IONBF&lt;/a&gt;, 0)&lt;/code&gt; , что отключает буферизацию.</target>
        </trans-unit>
        <trans-unit id="4dd6d32ffac07b48320fad08007c3cbc378f1ccf" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;c16&lt;/code&gt; is not the final code unit in a 16-bit representation of a wide character, it does not write to the array pointed to by &lt;code&gt;s&lt;/code&gt;, only &lt;code&gt;*ps&lt;/code&gt; is updated.</source>
          <target state="translated">Если &lt;code&gt;c16&lt;/code&gt; не является конечной единицей кода в 16-битном представлении широкого символа, он не записывает в массив, на который указывает &lt;code&gt;s&lt;/code&gt; , обновляется только &lt;code&gt;*ps&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="43266a7e25edde20659efab6eb44b99980e95ed3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;c8&lt;/code&gt; is invalid (does not contribute to a sequence of &lt;code&gt;char8_t&lt;/code&gt; corresponding to a valid multibyte character), the value of the macro &lt;code&gt;&lt;a href=&quot;../../error/errno_macros&quot;&gt;EILSEQ&lt;/a&gt;&lt;/code&gt; is stored in &lt;code&gt;&lt;a href=&quot;../../error/errno&quot;&gt;errno&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;(size_t)(-1)&lt;/code&gt; is returned, and the conversion state is unspecified.</source>
          <target state="translated">Если &lt;code&gt;c8&lt;/code&gt; является недопустимым (не вносит вклад в последовательность &lt;code&gt;char8_t&lt;/code&gt; , соответствующую действительному многобайтовому символу), значение макроса &lt;code&gt;&lt;a href=&quot;../../error/errno_macros&quot;&gt;EILSEQ&lt;/a&gt;&lt;/code&gt; сохраняется в &lt;code&gt;&lt;a href=&quot;../../error/errno&quot;&gt;errno&lt;/a&gt;&lt;/code&gt; , возвращается &lt;code&gt;(size_t)(-1)&lt;/code&gt; и состояние преобразования не определено.</target>
        </trans-unit>
        <trans-unit id="120e5087c8f2519bdf8d8babc3ba6bf88d5575b9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;c8&lt;/code&gt; is not the final UTF-8 code unit in a representation of a code point, the function does not write to the array pointed to by &lt;code&gt;s&lt;/code&gt;, only &lt;code&gt;*ps&lt;/code&gt; is updated.</source>
          <target state="translated">Если &lt;code&gt;c8&lt;/code&gt; не является конечной кодовой единицей UTF-8 в представлении кодовой точки, функция не записывает в массив, на который указывает &lt;code&gt;s&lt;/code&gt; , обновляется только &lt;code&gt;*ps&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e2b9d98d74c329c422daa370d8349ea12b339fed" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;c8&lt;/code&gt; is the null character &lt;code&gt;u8'\0'&lt;/code&gt;, a null byte is stored, preceded by any shift sequence necessary to restore the initial shift state and the conversion state parameter &lt;code&gt;*ps&lt;/code&gt; is updated to represent the initial shift state.</source>
          <target state="translated">Если &lt;code&gt;c8&lt;/code&gt; является нулевым символом &lt;code&gt;u8'\0'&lt;/code&gt; , сохраняется нулевой байт, которому предшествует любая последовательность сдвигов, необходимая для восстановления начального состояния сдвига, и параметр &lt;code&gt;*ps&lt;/code&gt; состояния преобразования обновляется для представления начального состояния сдвига.</target>
        </trans-unit>
        <trans-unit id="9b496091b9a18ce0c88a971b0705f925544a2dcf" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;c&lt;/code&gt; is the end-of-file indicator (&lt;code&gt;traits::eq_int_type(c,traits::eof()) == true&lt;/code&gt;), then there is no character to append. The function does nothing and returns an unspecified value other than &lt;code&gt;traits::eof()&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;c&lt;/code&gt; является индикатором конца файла ( &lt;code&gt;traits::eq_int_type(c,traits::eof()) == true&lt;/code&gt; ), то нет символа для добавления. Функция ничего не делает и возвращает неопределенное значение, кроме &lt;code&gt;traits::eof()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d45180121f410762cee0225f3231172974d6d196" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;c==&lt;a href=&quot;../c&quot;&gt;EOF&lt;/a&gt;&lt;/code&gt;, returns some value other than &lt;code&gt;&lt;a href=&quot;../c&quot;&gt;EOF&lt;/a&gt;&lt;/code&gt;. Otherwise, returns &lt;code&gt;(unsigned char)(c)&lt;/code&gt; on success, &lt;code&gt;&lt;a href=&quot;../c&quot;&gt;EOF&lt;/a&gt;&lt;/code&gt; on failure.</source>
          <target state="translated">Если &lt;code&gt;c==&lt;a href=&quot;../c&quot;&gt;EOF&lt;/a&gt;&lt;/code&gt; , возвращает значение, отличное от &lt;code&gt;&lt;a href=&quot;../c&quot;&gt;EOF&lt;/a&gt;&lt;/code&gt; . В противном случае возвращает &lt;code&gt;(unsigned char)(c)&lt;/code&gt; в случае успеха, &lt;code&gt;&lt;a href=&quot;../c&quot;&gt;EOF&lt;/a&gt;&lt;/code&gt; в случае неудачи.</target>
        </trans-unit>
        <trans-unit id="6b94f81efb67c916047d31de0fff924013dd49d6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;ch&lt;/code&gt; does not equal &lt;code&gt;&lt;a href=&quot;../c&quot;&gt;EOF&lt;/a&gt;&lt;/code&gt;, pushes the character &lt;code&gt;ch&lt;/code&gt; (reinterpreted as &lt;code&gt;unsigned char&lt;/code&gt;) into the input buffer associated with the stream &lt;code&gt;stream&lt;/code&gt; in such a manner than subsequent read operation from &lt;code&gt;stream&lt;/code&gt; will retrieve that character. The external device associated with the stream is not modified.</source>
          <target state="translated">Если &lt;code&gt;ch&lt;/code&gt; не равен &lt;code&gt;&lt;a href=&quot;../c&quot;&gt;EOF&lt;/a&gt;&lt;/code&gt; , вставляет символ &lt;code&gt;ch&lt;/code&gt; (повторно интерпретируемый как &lt;code&gt;unsigned char&lt;/code&gt; ) во входной буфер, связанный с потоком &lt;code&gt;stream&lt;/code&gt; таким образом, что последующая операция чтения из &lt;code&gt;stream&lt;/code&gt; извлечет этот символ. Внешнее устройство, связанное с потоком, не изменяется.</target>
        </trans-unit>
        <trans-unit id="d30189f2e98ef3c7b1c57bfc6a779e2cf97492e8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;ch&lt;/code&gt; does not equal &lt;code&gt;WEOF&lt;/code&gt;, pushes the wide character &lt;code&gt;ch&lt;/code&gt; into the input buffer associated with the stream &lt;code&gt;stream&lt;/code&gt; in such a manner than subsequent read operation from &lt;code&gt;stream&lt;/code&gt; will retrieve that wide character. The external device associated with the stream is not modified.</source>
          <target state="translated">Если &lt;code&gt;ch&lt;/code&gt; не равен &lt;code&gt;WEOF&lt;/code&gt; , выталкивает широкий символ &lt;code&gt;ch&lt;/code&gt; во входной буфер, связанный с потоком &lt;code&gt;stream&lt;/code&gt; таким образом, что последующая операция чтения из &lt;code&gt;stream&lt;/code&gt; извлечет этот широкий символ. Внешнее устройство, связанное с потоком, не изменяется.</target>
        </trans-unit>
        <trans-unit id="f9dcd2adfbf165acf0dba129b8151a07f338a6fc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;ch&lt;/code&gt; equals &lt;code&gt;&lt;a href=&quot;../c&quot;&gt;EOF&lt;/a&gt;&lt;/code&gt;, the operation fails and the stream is not affected.</source>
          <target state="translated">Если &lt;code&gt;ch&lt;/code&gt; равно &lt;code&gt;&lt;a href=&quot;../c&quot;&gt;EOF&lt;/a&gt;&lt;/code&gt; , операция завершается ошибкой и поток не затрагивается.</target>
        </trans-unit>
        <trans-unit id="6a114914a7e8a31a9eee7e4f7ac5bc1b503807f4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;ch&lt;/code&gt; equals &lt;code&gt;WEOF&lt;/code&gt;, the operation fails and the stream is not affected.</source>
          <target state="translated">Если &lt;code&gt;ch&lt;/code&gt; равно &lt;code&gt;WEOF&lt;/code&gt; , операция завершается ошибкой и поток не затрагивается.</target>
        </trans-unit>
        <trans-unit id="eb3d10516cbec80af986272f9e48f6efa09dd2d9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;command&lt;/code&gt; is a null pointer, checks if the host environment has a command processor and returns a nonzero value if and only if the command processor exists.</source>
          <target state="translated">Если &lt;code&gt;command&lt;/code&gt; является нулевым указателем, проверяет, есть ли в хост-среде командный процессор, и возвращает ненулевое значение тогда и только тогда, когда командный процессор существует.</target>
        </trans-unit>
        <trans-unit id="85aea9f0ae028fe2640a672d5e277a7841d76dc6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;comp(a,b)==true&lt;/code&gt; then &lt;code&gt;comp(b,a)==false&lt;/code&gt;</source>
          <target state="translated">Если &lt;code&gt;comp(a,b)==true&lt;/code&gt; то &lt;code&gt;comp(b,a)==false&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4f7a074b5aca822ff123427c78123491180762d7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;comp&lt;/code&gt; indicates two elements as equivalent, their order is unspecified.</source>
          <target state="translated">Если &lt;code&gt;comp&lt;/code&gt; указывает два элемента как эквивалентные, их порядок не указан.</target>
        </trans-unit>
        <trans-unit id="0175bc0a73471ec1cd27562640c1d6735174424d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;copy_options::directories_only&lt;/code&gt; is present in &lt;code&gt;options&lt;/code&gt;, does nothing</source>
          <target state="translated">Если &lt;code&gt;copy_options::directories_only&lt;/code&gt; присутствует в &lt;code&gt;options&lt;/code&gt; , ничего не делает</target>
        </trans-unit>
        <trans-unit id="815d288d8f8c46dcfd1ed95e2c2d74b9bc1cb888" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;copy_options::skip_symlink&lt;/code&gt; is present in &lt;code&gt;options&lt;/code&gt;, does nothing.</source>
          <target state="translated">Если &lt;code&gt;copy_options::skip_symlink&lt;/code&gt; присутствует в &lt;code&gt;options&lt;/code&gt; , ничего не делает.</target>
        </trans-unit>
        <trans-unit id="18daaf9d57908b8b11d5a5ce74779de8f547638e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;count&lt;/code&gt; is &lt;code&gt;​0​&lt;/code&gt;, then &lt;code&gt;dest&lt;/code&gt; is allowed to be a null pointer.</source>
          <target state="translated">Если &lt;code&gt;count&lt;/code&gt; является &lt;code&gt;​0​&lt;/code&gt; , то &lt;code&gt;dest&lt;/code&gt; разрешено быть указателем NULL.</target>
        </trans-unit>
        <trans-unit id="6e56b4ab0e5150566fb64d55ba8a1e8a4d01e821" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;count&lt;/code&gt; is reached before the entire string &lt;code&gt;src&lt;/code&gt; was copied, the resulting character array is not null-terminated.</source>
          <target state="translated">Если &lt;code&gt;count&lt;/code&gt; достигнуто до того, как вся строка &lt;code&gt;src&lt;/code&gt; была скопирована, результирующий массив символов не заканчивается нулем.</target>
        </trans-unit>
        <trans-unit id="3896321b9a85e601977b36e1c20e47272d800cfd" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;count&lt;/code&gt; is reached before the entire string &lt;code&gt;src&lt;/code&gt; was copied, the resulting wide character array is not null-terminated.</source>
          <target state="translated">Если &lt;code&gt;count&lt;/code&gt; достигнуто до того, как была скопирована вся строка &lt;code&gt;src&lt;/code&gt; , результирующий массив широких символов не заканчивается нулем.</target>
        </trans-unit>
        <trans-unit id="06245894aa3eefe9ed953846b24765091a53209d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;count&lt;/code&gt; is zero or negative, &lt;code&gt;first&lt;/code&gt; is returned.</source>
          <target state="translated">Если &lt;code&gt;count&lt;/code&gt; равно нулю или отрицательно, возвращается &lt;code&gt;first&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4f336d1b1de719a5985455a6d30969f36f1d4096" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;count&lt;/code&gt; is zero, strings are considered equal.</source>
          <target state="translated">Если &lt;code&gt;count&lt;/code&gt; равно нулю, строки считаются равными.</target>
        </trans-unit>
        <trans-unit id="3f2e6aaeeb8e09e4e7d2914ab4ee68da289d48f4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;count&lt;/code&gt; is zero, the function does nothing.</source>
          <target state="translated">Если &lt;code&gt;count&lt;/code&gt; равен нулю, функция ничего не делает.</target>
        </trans-unit>
        <trans-unit id="7ad8eda07b3297819cd8064cc3589079cc052fd8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;count&lt;/code&gt; is zero, the function returns a null pointer.</source>
          <target state="translated">Если &lt;code&gt;count&lt;/code&gt; равен нулю, функция возвращает нулевой указатель.</target>
        </trans-unit>
        <trans-unit id="57a3e0d836eef087c17311ab2dbe908db83c04f9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;d_&lt;/code&gt; is a member variable holding the duration (i.e., time since epoch) of this &lt;code&gt;time_point&lt;/code&gt; object,</source>
          <target state="translated">Если &lt;code&gt;d_&lt;/code&gt; является переменной-членом, содержащей длительность (то есть время с начала эпохи) этого объекта &lt;code&gt;time_point&lt;/code&gt; ,</target>
        </trans-unit>
        <trans-unit id="3bbc1c66920a4038f904392405e8bb0f323da835" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;del&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, it is assumed that the array was allocated with &lt;code&gt;new[]&lt;/code&gt;, and the destructor of this facet will call &lt;code&gt;delete[] tbl&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;del&lt;/code&gt; равно &lt;code&gt;true&lt;/code&gt; , предполагается, что массив был выделен с помощью &lt;code&gt;new[]&lt;/code&gt; , и деструктор этого фасета вызовет &lt;code&gt;delete[] tbl&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3f2fea471de8b3d0628642cbd7cd79e507ef237c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;dir&lt;/code&gt; is not &lt;code&gt;&lt;a href=&quot;../ios_base/seekdir&quot;&gt;std::basic_ios::cur&lt;/a&gt;&lt;/code&gt; or the offset &lt;code&gt;off&lt;/code&gt; is not &lt;code&gt;​0​&lt;/code&gt;, and the most resent operation done on this filebuf object was output (that is, either the put buffer is not empty, or the most recently called function was &lt;code&gt;&lt;a href=&quot;../basic_streambuf/overflow&quot;&gt;overflow()&lt;/a&gt;&lt;/code&gt;), then calls &lt;code&gt;std::codecvt::unshift&lt;/code&gt; to determine the unshift sequence necessary, and writes that sequence to the file by calling &lt;code&gt;&lt;a href=&quot;../basic_streambuf/overflow&quot;&gt;overflow()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;dir&lt;/code&gt; не &lt;code&gt;&lt;a href=&quot;../ios_base/seekdir&quot;&gt;std::basic_ios::cur&lt;/a&gt;&lt;/code&gt; или смещение &lt;code&gt;off&lt;/code&gt; не &lt;code&gt;​0​&lt;/code&gt; , а самая операция повторно выполняется на этом filebuf объект был выходной (то есть, либо буфер положить не пустой, или совсем недавно называли функция была &lt;code&gt;&lt;a href=&quot;../basic_streambuf/overflow&quot;&gt;overflow()&lt;/a&gt;&lt;/code&gt; ), затем вызывает &lt;code&gt;std::codecvt::unshift&lt;/code&gt; чтобы определить необходимую последовательность unshift, и записывает эту последовательность в файл, вызывая &lt;code&gt;&lt;a href=&quot;../basic_streambuf/overflow&quot;&gt;overflow()&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="57e5dcca2d6fb73331af4ef11d3a2dcb0d17f4d5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;e&lt;/code&gt; is a class member access expression (&lt;code&gt;e1.e2&lt;/code&gt; or &lt;code&gt;e1-&amp;gt;e2&lt;/code&gt;), the potential results of the object expression e1 is included in the set.</source>
          <target state="translated">Если &lt;code&gt;e&lt;/code&gt; является выражением доступа к члену класса ( &lt;code&gt;e1.e2&lt;/code&gt; или &lt;code&gt;e1-&amp;gt;e2&lt;/code&gt; ), потенциальные результаты выражения объекта e1 включаются в набор.</target>
        </trans-unit>
        <trans-unit id="a611f1da12dbf6983879f4306f9df44390150021" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;e&lt;/code&gt; is a comma expression (&lt;code&gt;e1,e2&lt;/code&gt;), the potential results of &lt;code&gt;e2&lt;/code&gt; are in the set of potential results</source>
          <target state="translated">Если &lt;code&gt;e&lt;/code&gt; является выражением запятой ( &lt;code&gt;e1,e2&lt;/code&gt; ), потенциальные результаты &lt;code&gt;e2&lt;/code&gt; находятся в наборе потенциальных результатов</target>
        </trans-unit>
        <trans-unit id="b272bd28e80dd2ac2a3667aaa761508a1896965d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;e&lt;/code&gt; is a glvalue conditional expression (&lt;code&gt;e1?e2:e3&lt;/code&gt;, where e2 and e3 are glvalues), the union of the potential results of &lt;code&gt;e2&lt;/code&gt; and &lt;code&gt;e3&lt;/code&gt; are both included in the set.</source>
          <target state="translated">Если &lt;code&gt;e&lt;/code&gt; является условным выражением glvalue ( &lt;code&gt;e1?e2:e3&lt;/code&gt; , где e2 и e3 являются значениями glvalue), объединение потенциальных результатов &lt;code&gt;e2&lt;/code&gt; и &lt;code&gt;e3&lt;/code&gt; включается в набор.</target>
        </trans-unit>
        <trans-unit id="2d9fdf08ba2dfa789e82b39c3610d8ef047043a2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;e&lt;/code&gt; is a pointer-to-member access expression (&lt;code&gt;e1.*e2&lt;/code&gt; or &lt;code&gt;e1-&amp;gt;*e2&lt;/code&gt;) whose second operand is a constant expression, the potential results of the object expression e1 are included in the set</source>
          <target state="translated">Если &lt;code&gt;e&lt;/code&gt; является выражением доступа указателя на член ( &lt;code&gt;e1.*e2&lt;/code&gt; или &lt;code&gt;e1-&amp;gt;*e2&lt;/code&gt; ), второй операнд которого является константным выражением, потенциальные результаты выражения объекта e1 включаются в набор</target>
        </trans-unit>
        <trans-unit id="136ae657a0856415b88b024f787e7474c99acad0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;e&lt;/code&gt; is an &lt;a href=&quot;expressions&quot;&gt;id-expression&lt;/a&gt;, the expression &lt;code&gt;e&lt;/code&gt; is its only potential result</source>
          <target state="translated">Если &lt;code&gt;e&lt;/code&gt; является &lt;a href=&quot;expressions&quot;&gt;id-выражением&lt;/a&gt; , выражение &lt;code&gt;e&lt;/code&gt; является его единственным потенциальным результатом.</target>
        </trans-unit>
        <trans-unit id="6a6dd1d96309aaabbc396100ce7a188d685eba16" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;e&lt;/code&gt; is an array subscript expression (&lt;code&gt;e1[e2]&lt;/code&gt;) where one of the operands is an array, the potential results of that operand is included in the set</source>
          <target state="translated">Если &lt;code&gt;e&lt;/code&gt; является выражением индекса массива ( &lt;code&gt;e1[e2]&lt;/code&gt; ), где один из операндов является массивом, потенциальные результаты этого операнда включаются в набор</target>
        </trans-unit>
        <trans-unit id="a6876c60a5df4d3a02319ae4acfd99744e4aad8b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;e&lt;/code&gt; is an expression in parentheses (&lt;code&gt;(e1)&lt;/code&gt;), the potential results of &lt;code&gt;e1&lt;/code&gt; are included in the set</source>
          <target state="translated">Если &lt;code&gt;e&lt;/code&gt; является выражением в скобках ( &lt;code&gt;(e1)&lt;/code&gt; ), потенциальные результаты &lt;code&gt;e1&lt;/code&gt; включаются в набор</target>
        </trans-unit>
        <trans-unit id="af0a58bc0809e3f4c48c7935533640bb84b6d5da" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;eofbit&lt;/code&gt; is set on the stream prior to the call, the construction of the sentry object will set &lt;code&gt;failbit&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;eofbit&lt;/code&gt; установлен в потоке до вызова, то при построении часового объекта будет установлен &lt;code&gt;failbit&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ce0473bb777b78c63cd5012d3ff7b7e662f591ad" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;equiv(a,b)==true&lt;/code&gt; and &lt;code&gt;equiv(b,c)==true&lt;/code&gt;, then &lt;code&gt;equiv(a,c)==true&lt;/code&gt;</source>
          <target state="translated">Если &lt;code&gt;equiv(a,b)==true&lt;/code&gt; и &lt;code&gt;equiv(b,c)==true&lt;/code&gt; , то &lt;code&gt;equiv(a,c)==true&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2ba38a247100280f8e41691728cc66000be9e271" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;equiv(a,b)==true&lt;/code&gt;, then &lt;code&gt;equiv(b,a)==true&lt;/code&gt;</source>
          <target state="translated">Если &lt;code&gt;equiv(a,b)==true&lt;/code&gt; , то &lt;code&gt;equiv(b,a)==true&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="007bad278d6b4bc6d719829636a93a4a9c5a31b7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;exit_code&lt;/code&gt; is &lt;code&gt;0&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;exit_status&quot;&gt;EXIT_SUCCESS&lt;/a&gt;&lt;/code&gt;, an implementation-defined status indicating successful termination is returned to the host environment. If &lt;code&gt;exit_code&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;exit_status&quot;&gt;EXIT_FAILURE&lt;/a&gt;&lt;/code&gt;, an implementation-defined status, indicating</source>
          <target state="translated">Если &lt;code&gt;exit_code&lt;/code&gt; равен &lt;code&gt;0&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;exit_status&quot;&gt;EXIT_SUCCESS&lt;/a&gt;&lt;/code&gt; , определенный статус реализации, указывающий на успешное завершение, возвращается в хост-среду. Если &lt;code&gt;exit_code&lt;/code&gt; - &lt;code&gt;&lt;a href=&quot;exit_status&quot;&gt;EXIT_FAILURE&lt;/a&gt;&lt;/code&gt; , статус, определенный реализацией, указывающий</target>
        </trans-unit>
        <trans-unit id="f710623c293fe447df3d92556a487868ef46a327" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;exp&lt;/code&gt; is 0, then &lt;code&gt;x&lt;/code&gt; is returned, unmodified</source>
          <target state="translated">Если &lt;code&gt;exp&lt;/code&gt; равен 0, то &lt;code&gt;x&lt;/code&gt; возвращается без изменений</target>
        </trans-unit>
        <trans-unit id="fb1e695a18ffeb815e38e42b92e43f2bd57d73e0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;f&lt;/code&gt; is a &lt;a href=&quot;../../language/pointer#Pointers_to_member_functions&quot;&gt;pointer to member function&lt;/a&gt; of class &lt;code&gt;T&lt;/code&gt;:</source>
          <target state="translated">Если &lt;code&gt;f&lt;/code&gt; - &lt;a href=&quot;../../language/pointer#Pointers_to_member_functions&quot;&gt;указатель на функцию-член&lt;/a&gt; класса &lt;code&gt;T&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="4837b4b3957d1d06787bdcfc0793edea20847145" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;fail()==true&lt;/code&gt;, returns &lt;code&gt;pos_type(-1)&lt;/code&gt;. Otherwise, returns &lt;code&gt;rdbuf()-&amp;gt;pubseekoff(0, &lt;a href=&quot;../ios_base/seekdir&quot;&gt;std::ios_base::cur&lt;/a&gt;, &lt;a href=&quot;../ios_base/openmode&quot;&gt;std::ios_base::out&lt;/a&gt;)&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;fail()==true&lt;/code&gt; , возвращает &lt;code&gt;pos_type(-1)&lt;/code&gt; . В противном случае возвращает &lt;code&gt;rdbuf()-&amp;gt;pubseekoff(0, &lt;a href=&quot;../ios_base/seekdir&quot;&gt;std::ios_base::cur&lt;/a&gt;, &lt;a href=&quot;../ios_base/openmode&quot;&gt;std::ios_base::out&lt;/a&gt;)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d0463e8b7f222245f189b3d034b86d7447da42d5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;failed()&lt;/code&gt; returns &lt;code&gt;false&lt;/code&gt;, inserts the character &lt;code&gt;c&lt;/code&gt; into the associated stream buffer by calling &lt;code&gt;pbuf-&amp;gt;sputc(c)&lt;/code&gt;, where &lt;code&gt;pbuf&lt;/code&gt; is the private member of type &lt;code&gt;streambuf_type*&lt;/code&gt;. Otherwise, does nothing.</source>
          <target state="translated">Если &lt;code&gt;failed()&lt;/code&gt; возвращает &lt;code&gt;false&lt;/code&gt; , вставляет символ &lt;code&gt;c&lt;/code&gt; в связанный буфер потока, вызывая &lt;code&gt;pbuf-&amp;gt;sputc(c)&lt;/code&gt; , где &lt;code&gt;pbuf&lt;/code&gt; - закрытый член типа &lt;code&gt;streambuf_type*&lt;/code&gt; . В противном случае ничего не делает.</target>
        </trans-unit>
        <trans-unit id="5400983ef77493ea136e60df816cfe45d2e66859" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;first == last&lt;/code&gt; or &lt;code&gt;first1 == last1&lt;/code&gt;, &lt;code&gt;init&lt;/code&gt; is returned, unmodified.</source>
          <target state="translated">Если &lt;code&gt;first == last&lt;/code&gt; или &lt;code&gt;first1 == last1&lt;/code&gt; , &lt;code&gt;init&lt;/code&gt; возвращается без изменений.</target>
        </trans-unit>
        <trans-unit id="4e003924877b9a466eeb7d707612a5f3ab0c7f79" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;first == last&lt;/code&gt;, this function has no effect and will merely return &lt;code&gt;d_first&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;first == last&lt;/code&gt; , эта функция не действует и просто возвращает &lt;code&gt;d_first&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3800b7d6b3d5edad60afa41413956ee387d068de" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;flags&lt;/code&gt; contains &lt;code&gt;&lt;a href=&quot;match_flag_type&quot;&gt;std::regex_constants::format_first_only&lt;/a&gt;&lt;/code&gt;, only the first match is replaced.</source>
          <target state="translated">Если &lt;code&gt;flags&lt;/code&gt; содержит &lt;code&gt;&lt;a href=&quot;match_flag_type&quot;&gt;std::regex_constants::format_first_only&lt;/a&gt;&lt;/code&gt; , заменяется только первое совпадение.</target>
        </trans-unit>
        <trans-unit id="8971b9fbad479977ae5fffcd5b1ef85254f363f4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;flags&lt;/code&gt; contains &lt;code&gt;&lt;a href=&quot;match_flag_type&quot;&gt;std::regex_constants::format_no_copy&lt;/a&gt;&lt;/code&gt;, the non-matched subsequences are not copied into &lt;code&gt;out&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;flags&lt;/code&gt; содержат &lt;code&gt;&lt;a href=&quot;match_flag_type&quot;&gt;std::regex_constants::format_no_copy&lt;/a&gt;&lt;/code&gt; , непоследовательные подпоследовательности не копируются в &lt;code&gt;out&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="afcd9815060753d019811a5dfbfcd47253700f41" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;floatfield == (&lt;a href=&quot;../../io/ios_base/fmtflags&quot;&gt;std::ios_base::fixed&lt;/a&gt; | &lt;a href=&quot;../../io/ios_base/fmtflags&quot;&gt;std::ios_base::scientific&lt;/a&gt;) &amp;amp;&amp;amp; !uppercase&lt;/code&gt;, will use conversion specifier &lt;code&gt;%a&lt;/code&gt;</source>
          <target state="translated">Если &lt;code&gt;floatfield == (&lt;a href=&quot;../../io/ios_base/fmtflags&quot;&gt;std::ios_base::fixed&lt;/a&gt; | &lt;a href=&quot;../../io/ios_base/fmtflags&quot;&gt;std::ios_base::scientific&lt;/a&gt;) &amp;amp;&amp;amp; !uppercase&lt;/code&gt; , будет использовать спецификатор преобразования &lt;code&gt;%a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a696cef7fabb97b740bacedd6f505fc04deb3ca2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;floatfield == (&lt;a href=&quot;../../io/ios_base/fmtflags&quot;&gt;std::ios_base::fixed&lt;/a&gt; | &lt;a href=&quot;../../io/ios_base/fmtflags&quot;&gt;std::ios_base::scientific&lt;/a&gt;)&lt;/code&gt;, will use conversion specifier &lt;code&gt;%A&lt;/code&gt;</source>
          <target state="translated">Если &lt;code&gt;floatfield == (&lt;a href=&quot;../../io/ios_base/fmtflags&quot;&gt;std::ios_base::fixed&lt;/a&gt; | &lt;a href=&quot;../../io/ios_base/fmtflags&quot;&gt;std::ios_base::scientific&lt;/a&gt;)&lt;/code&gt; , будет использовать спецификатор преобразования &lt;code&gt;%A&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7df1b6bc3f01af8b0302af4f0306bba39947fde8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;floatfield == &lt;a href=&quot;../../io/ios_base/fmtflags&quot;&gt;std::ios_base::fixed&lt;/a&gt;&lt;/code&gt;, will use conversion specifier &lt;code&gt;%f&lt;/code&gt;</source>
          <target state="translated">Если &lt;code&gt;floatfield == &lt;a href=&quot;../../io/ios_base/fmtflags&quot;&gt;std::ios_base::fixed&lt;/a&gt;&lt;/code&gt; , будет использовать спецификатор преобразования &lt;code&gt;%f&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ea893d1e69d7bcb42e6183b8b13629895919af1d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;floatfield == &lt;a href=&quot;../../io/ios_base/fmtflags&quot;&gt;std::ios_base::scientific&lt;/a&gt; &amp;amp;&amp;amp; !uppercase&lt;/code&gt;, will use conversion specifier &lt;code&gt;%e&lt;/code&gt;</source>
          <target state="translated">Если &lt;code&gt;floatfield == &lt;a href=&quot;../../io/ios_base/fmtflags&quot;&gt;std::ios_base::scientific&lt;/a&gt; &amp;amp;&amp;amp; !uppercase&lt;/code&gt; , будет использовать спецификатор преобразования &lt;code&gt;%e&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="479647145b4986f0d7bf8bafb84a155b21c78b60" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;floatfield == &lt;a href=&quot;../../io/ios_base/fmtflags&quot;&gt;std::ios_base::scientific&lt;/a&gt;&lt;/code&gt;, will use conversion specifier &lt;code&gt;%E&lt;/code&gt;</source>
          <target state="translated">Если &lt;code&gt;floatfield == &lt;a href=&quot;../../io/ios_base/fmtflags&quot;&gt;std::ios_base::scientific&lt;/a&gt;&lt;/code&gt; , будет использовать спецификатор преобразования &lt;code&gt;%E&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="305a95ccb899fefeb95b7edf07cbcae48fc8c6b7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;from&lt;/code&gt; and &lt;code&gt;to&lt;/code&gt; are the same file as determined by &lt;code&gt;&lt;a href=&quot;equivalent&quot;&gt;std::filesystem::equivalent&lt;/a&gt;&lt;/code&gt;, reports an error</source>
          <target state="translated">Если &lt;code&gt;from&lt;/code&gt; и &lt;code&gt;to&lt;/code&gt; совпадают с файлом, определенным &lt;code&gt;&lt;a href=&quot;equivalent&quot;&gt;std::filesystem::equivalent&lt;/a&gt;&lt;/code&gt; , выдает ошибку</target>
        </trans-unit>
        <trans-unit id="5981efb911c3a456cb02b7dc34b28f6d5a818dcf" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;from&lt;/code&gt; does not exist, reports an error.</source>
          <target state="translated">Если &lt;code&gt;from&lt;/code&gt; не существует, выдает ошибку.</target>
        </trans-unit>
        <trans-unit id="433f5d85237ac4e480b0d07ce3da6cac640403a2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;from&lt;/code&gt; is a directory, but &lt;code&gt;to&lt;/code&gt; is a regular file, reports an error</source>
          <target state="translated">Если &lt;code&gt;from&lt;/code&gt; является каталогом, а &lt;code&gt;to&lt;/code&gt; является обычным файлом, сообщает об ошибке</target>
        </trans-unit>
        <trans-unit id="77fcdb49cb08776e21d9d86e94d339ee3a5b233d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;from&lt;/code&gt; is a symbolic link, then</source>
          <target state="translated">Если &lt;code&gt;from&lt;/code&gt; является символической ссылкой, то</target>
        </trans-unit>
        <trans-unit id="d60be77b3f79d2ace2289a720e9b7a98142b9a06" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;from_stream&lt;/code&gt; fails to parse everything specified by the format string, or if insufficient information is parsed to specify a complete result, or if parsing discloses contradictory information, &lt;code&gt;is.setstate(&lt;a href=&quot;../../io/ios_base/iostate&quot;&gt;std::ios_base::failbit&lt;/a&gt;)&lt;/code&gt; is called.</source>
          <target state="translated">Если &lt;code&gt;from_stream&lt;/code&gt; не может выполнить синтаксический анализ всего, указанного в строке формата, или если анализируется недостаточная информация для определения полного результата, или если синтаксический анализ обнаруживает противоречивую информацию, &lt;code&gt;is.setstate(&lt;a href=&quot;../../io/ios_base/iostate&quot;&gt;std::ios_base::failbit&lt;/a&gt;)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a9f4f8c173e4f387e8d6984eea14c0c97052549e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;from_stream&lt;/code&gt; fails to parse everything specified by the format string, or if insufficient information is parsed to specify a complete result, or if parsing discloses contradictory information, &lt;code&gt;is.setstate(&lt;a href=&quot;../io/ios_base/iostate&quot;&gt;std::ios_base::failbit&lt;/a&gt;)&lt;/code&gt; is called.</source>
          <target state="translated">Если &lt;code&gt;from_stream&lt;/code&gt; не может выполнить синтаксический анализ всего, указанного в строке формата, или если анализируется недостаточная информация для определения полного результата, или если синтаксический анализ обнаруживает противоречивую информацию, &lt;code&gt;is.setstate(&lt;a href=&quot;../io/ios_base/iostate&quot;&gt;std::ios_base::failbit&lt;/a&gt;)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a0b2248b896ee027fabe63c433625c357d75a244" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;g&lt;/code&gt; is volatile-qualified (i.e., its cv-qualifiers are either &lt;code&gt;volatile&lt;/code&gt; or &lt;code&gt;const volatile&lt;/code&gt;), the behavior is undefined.</source>
          <target state="translated">Если &lt;code&gt;g&lt;/code&gt; квалифицирован как volatile (т.е. его cv-квалификаторы либо &lt;code&gt;volatile&lt;/code&gt; , либо &lt;code&gt;const volatile&lt;/code&gt; ), то поведение не определено.</target>
        </trans-unit>
        <trans-unit id="ec3b72193abe9aedc79922cd71ce4f681ce5bb3e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;get() == nullptr&lt;/code&gt; there are no effects. Otherwise, the owned object is destroyed via &lt;a href=&quot;get_deleter&quot;&gt;&lt;code&gt;get_deleter()&lt;/code&gt;&lt;/a&gt;&lt;a href=&quot;get&quot;&gt;&lt;code&gt;(get())&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Если &lt;code&gt;get() == nullptr&lt;/code&gt; , эффекты отсутствуют. В противном случае принадлежащий объект уничтожается с помощью &lt;a href=&quot;get_deleter&quot;&gt; &lt;code&gt;get_deleter()&lt;/code&gt; &lt;/a&gt;&lt;a href=&quot;get&quot;&gt; &lt;code&gt;(get())&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8cfb0ef527264e13542d3e75250bf692fe5adcb8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;good() == true&lt;/code&gt;, returns the next character as obtained by &lt;code&gt;rdbuf()-&amp;gt;sgetc()&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;good() == true&lt;/code&gt; , возвращает следующий символ, полученный &lt;code&gt;rdbuf()-&amp;gt;sgetc()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d798bdc7a53000bbd5ee8924ceef0cc19c68c7ef" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;has_relative_path()&lt;/code&gt; returns false, the result is a copy of &lt;code&gt;*this&lt;/code&gt; Otherwise, the result is a path whose generic format pathname is the longest prefix of the generic format pathname of &lt;code&gt;*this&lt;/code&gt; that produces one fewer element in its iteration.</source>
          <target state="translated">Если &lt;code&gt;has_relative_path()&lt;/code&gt; возвращает false, результатом является копия &lt;code&gt;*this&lt;/code&gt; . В противном случае результатом является путь, путь общего формата которого является самым длинным префиксом общего пути формата &lt;code&gt;*this&lt;/code&gt; , который создает на одну итерацию меньше элемента.</target>
        </trans-unit>
        <trans-unit id="3dea94fff00231911d476ee1bc47f5dd6bbd2db9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;i == j&lt;/code&gt; and &lt;code&gt;(i, j)&lt;/code&gt; is in the domain of &lt;code&gt;==&lt;/code&gt; then this is equivalent to &lt;code&gt;*j&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;i == j&lt;/code&gt; и &lt;code&gt;(i, j)&lt;/code&gt; находится в области &lt;code&gt;==&lt;/code&gt; , то это эквивалентно &lt;code&gt;*j&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="13008673cd8597a506cf3daa8b3ec63d08a1c87c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;imbue()&lt;/code&gt; has been never called for this object, then the global locale at the time of the call is returned. Otherwise, the locale passed to the last call to &lt;code&gt;imbue()&lt;/code&gt; is returned.</source>
          <target state="translated">Если &lt;code&gt;imbue()&lt;/code&gt; никогда не вызывался для этого объекта, то возвращается глобальный языковой стандарт во время вызова. В противном случае возвращается локаль, переданная последнему вызову &lt;code&gt;imbue()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9f7a6d2892cb99819b50181c82d0ac33627baaf1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;in==end&lt;/code&gt;, Stage 2 is terminated immediately, no further characters are extracted</source>
          <target state="translated">Если &lt;code&gt;in==end&lt;/code&gt; Стадия 2 немедленно завершается, дальнейшие символы не извлекаются</target>
        </trans-unit>
        <trans-unit id="f94d93ea046597d6595e925ae9e6a64c0253802b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;index() == 0&lt;/code&gt;, returns a &lt;code&gt;sys_days&lt;/code&gt; that represents the date 7 days prior to the first &lt;code&gt;weekday()&lt;/code&gt; of the year and month.</source>
          <target state="translated">Если &lt;code&gt;index() == 0&lt;/code&gt; , возвращает &lt;code&gt;sys_days&lt;/code&gt; , который представляет дату за 7 дней до первого &lt;code&gt;weekday()&lt;/code&gt; года и месяца.</target>
        </trans-unit>
        <trans-unit id="b47ea618b12678469ff2fd08038755240643eae1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;is.good()&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;, calls &lt;code&gt;is.setstate(failbit)&lt;/code&gt;(since c++11) and returns. Otherwise, if &lt;code&gt;is.tie()&lt;/code&gt; is not a null pointer, calls &lt;code&gt;is.tie()-&amp;gt;flush()&lt;/code&gt; to synchronize the output sequence with external streams. This call can be suppressed if the put area of &lt;code&gt;is.tie()&lt;/code&gt; is empty. The implementation may defer the call to &lt;code&gt;flush&lt;/code&gt; until a call of &lt;code&gt;is.rdbuf()-&amp;gt;underflow()&lt;/code&gt; occurs. If no such call occurs before the sentry object is destroyed, it may be eliminated entirely.</source>
          <target state="translated">Если &lt;code&gt;is.good()&lt;/code&gt; имеет значение &lt;code&gt;false&lt;/code&gt; , вызывает &lt;code&gt;is.setstate(failbit)&lt;/code&gt; (начиная с c ++ 11) и возвращает. В противном случае, если &lt;code&gt;is.tie()&lt;/code&gt; не является нулевым указателем, вызывается &lt;code&gt;is.tie()-&amp;gt;flush()&lt;/code&gt; для синхронизации выходной последовательности с внешними потоками. Этот вызов может быть подавлен, если область размещения &lt;code&gt;is.tie()&lt;/code&gt; пуста. Реализация может отложить вызов &lt;code&gt;flush&lt;/code&gt; до вызова &lt;code&gt;is.rdbuf()-&amp;gt;underflow()&lt;/code&gt; . Если такого вызова не происходит до уничтожения сторожевого объекта, он может быть полностью исключен.</target>
        </trans-unit>
        <trans-unit id="bbdd95c99548814da982d8d20409a38ef7943968" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;isfinite(t) &amp;amp;&amp;amp; a == b&lt;/code&gt;, the result is equal to &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;isfinite(t) &amp;amp;&amp;amp; a == b&lt;/code&gt; , результат равен &lt;code&gt;a&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4a92eff5b31f025e8461e121aee4c206aa32fb17" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;isfinite(t) || (!isnan(t) &amp;amp;&amp;amp; b-a&amp;nbsp;!= 0)&lt;/code&gt;, the result is not &lt;code&gt;NaN&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;isfinite(t) || (!isnan(t) &amp;amp;&amp;amp; b-a&amp;nbsp;!= 0)&lt;/code&gt; , результат не &lt;code&gt;NaN&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4c5e504a6bd1ecb25be6b144ecd53c96279275a6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;islower&lt;/code&gt; returns a nonzero value, it is guaranteed that &lt;code&gt;iscntrl&lt;/code&gt;, &lt;code&gt;isdigit&lt;/code&gt;, &lt;code&gt;ispunct&lt;/code&gt;, and &lt;code&gt;isspace&lt;/code&gt; return zero for the same character in the same C locale.</source>
          <target state="translated">Если &lt;code&gt;islower&lt;/code&gt; возвращает значение отличное от нуля, то гарантируется , что &lt;code&gt;iscntrl&lt;/code&gt; , &lt;code&gt;isdigit&lt;/code&gt; , &lt;code&gt;ispunct&lt;/code&gt; и &lt;code&gt;isspace&lt;/code&gt; возвращение нулевой для того же символа в том же C локали.</target>
        </trans-unit>
        <trans-unit id="eeb4299451f00a6bbc3cc54d9636ef15cfbc4d81" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;isupper&lt;/code&gt; returns a nonzero value, it is guaranteed that &lt;code&gt;iscntrl&lt;/code&gt;, &lt;code&gt;isdigit&lt;/code&gt;, &lt;code&gt;ispunct&lt;/code&gt;, and &lt;code&gt;isspace&lt;/code&gt; return zero for the same character in the same C locale.</source>
          <target state="translated">Если &lt;code&gt;isupper&lt;/code&gt; возвращает ненулевое значение, то гарантируется , что &lt;code&gt;iscntrl&lt;/code&gt; , &lt;code&gt;isdigit&lt;/code&gt; , &lt;code&gt;ispunct&lt;/code&gt; и &lt;code&gt;isspace&lt;/code&gt; возврат ноль для того же символа в том же C локали.</target>
        </trans-unit>
        <trans-unit id="1cf4537f9c301149e8cc2a31615b3d035dfb3d45" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;lock&lt;/code&gt; is called by a thread that already owns the &lt;code&gt;mutex&lt;/code&gt; in any mode (shared or exclusive), the behavior is undefined.</source>
          <target state="translated">Если &lt;code&gt;lock&lt;/code&gt; вызывается потоком, который уже владеет &lt;code&gt;mutex&lt;/code&gt; в любом режиме (совместно используемом или исключающем), поведение не определено.</target>
        </trans-unit>
        <trans-unit id="1025c2a2787ed452c780e1dcd1489b21d28b0a1d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;lock&lt;/code&gt; is called by a thread that already owns the &lt;code&gt;mutex&lt;/code&gt;, the behavior is undefined: for example, the program</source>
          <target state="translated">Если &lt;code&gt;lock&lt;/code&gt; вызывается потоком, который уже владеет &lt;code&gt;mutex&lt;/code&gt; , поведение не определено: например, программа</target>
        </trans-unit>
        <trans-unit id="9a44d1e0b185f370bee6a94519b229c4dac6e172" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;lock_shared&lt;/code&gt; is called by a thread that already owns the &lt;code&gt;mutex&lt;/code&gt; in any mode (exclusive or shared), the behavior is undefined.</source>
          <target state="translated">Если &lt;code&gt;lock_shared&lt;/code&gt; вызывается потоком, который уже владеет &lt;code&gt;mutex&lt;/code&gt; в любом режиме (исключающем или совместно используемом), поведение не определено.</target>
        </trans-unit>
        <trans-unit id="4b1ebf8b0f2f951edb330b8fa8ae0d36a2cd369c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;member&lt;/code&gt; is a &lt;a href=&quot;../language/static&quot;&gt;static member&lt;/a&gt; or a &lt;a href=&quot;../language/member_functions&quot;&gt;member function&lt;/a&gt;, the behavior is undefined.</source>
          <target state="translated">Если &lt;code&gt;member&lt;/code&gt; является &lt;a href=&quot;../language/static&quot;&gt;статическим членом&lt;/a&gt; или &lt;a href=&quot;../language/member_functions&quot;&gt;функцией-членом&lt;/a&gt; , поведение не определено.</target>
        </trans-unit>
        <trans-unit id="d629e4399641b9530158823e61e45ef4cbd7a6cc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;mode &amp;gt; 0&lt;/code&gt;, attempts to make &lt;code&gt;stream&lt;/code&gt; wide-oriented. If &lt;code&gt;mode &amp;lt; 0&lt;/code&gt;, attempts to make &lt;code&gt;stream&lt;/code&gt; byte-oriented. If &lt;code&gt;mode==0&lt;/code&gt;, only queries the current orientation of the stream.</source>
          <target state="translated">Если &lt;code&gt;mode &amp;gt; 0&lt;/code&gt; , попытка сделать &lt;code&gt;stream&lt;/code&gt; широко ориентированным. Если &lt;code&gt;mode &amp;lt; 0&lt;/code&gt; , пытается сделать &lt;code&gt;stream&lt;/code&gt; ориентированным на байты. Если &lt;code&gt;mode==0&lt;/code&gt; , запрашивает только текущую ориентацию потока.</target>
        </trans-unit>
        <trans-unit id="c3e26d9cac416d20dc7c2b6fc8e45df72eb4d94c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;money_base::space&lt;/code&gt; or &lt;code&gt;money_base::none&lt;/code&gt; is the last element in the &lt;code&gt;&lt;a href=&quot;../money_base&quot;&gt;pattern&lt;/a&gt;&lt;/code&gt;, the parser does not attempt to consume any whitespace after the other components of the monetary value were parsed. Otherwise, one or more whitespace characters are consumed where &lt;code&gt;money_base::space&lt;/code&gt; appears.</source>
          <target state="translated">Если &lt;code&gt;money_base::space&lt;/code&gt; или &lt;code&gt;money_base::none&lt;/code&gt; является последним элементом в &lt;code&gt;&lt;a href=&quot;../money_base&quot;&gt;pattern&lt;/a&gt;&lt;/code&gt; , синтаксический анализатор не пытается использовать любые пробелы после анализа других компонентов денежного значения. В противном случае один или несколько пробельных символов используются там, где появляется &lt;code&gt;money_base::space&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e2acebccacc05bdce0834871463fa8d41cad28a6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;mp.grouping()&lt;/code&gt; does not permit thousands separators, the first separator encountered is treated as a parsing error, otherwise they are treated as optional.</source>
          <target state="translated">Если &lt;code&gt;mp.grouping()&lt;/code&gt; не допускает разделители тысяч, первый обнаруженный разделитель обрабатывается как ошибка синтаксического анализа, в противном случае они рассматриваются как необязательные.</target>
        </trans-unit>
        <trans-unit id="3018443da1f5de49f03fa88048943ced63037aee" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;mp.positive_sign()&lt;/code&gt; (in case positive format pattern is used) or &lt;code&gt;mp.negative_sign()&lt;/code&gt; (in case negative format pattern is used) returns a string with more than one character, the first character returned is placed in the output sequence where &lt;code&gt;&lt;a href=&quot;../money_base&quot;&gt;sign&lt;/a&gt;&lt;/code&gt; appears in the formatting pattern, and the rest of the characters are placed after all other characters, for example, formatting pattern &lt;code&gt;{sign, value, space, symbol}&lt;/code&gt; with units &lt;code&gt;123&lt;/code&gt; and negative_sign of &lt;code&gt;&quot;-&quot;&lt;/code&gt; may result in &lt;code&gt;&quot;-1.23 &amp;euro;&quot;&lt;/code&gt;, while negative_sign of &lt;code&gt;&quot;()&quot;&lt;/code&gt; would generate &lt;code&gt;&quot;(1.23 &amp;euro;)&quot;&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;mp.positive_sign()&lt;/code&gt; (в случае использования шаблона положительного формата) или &lt;code&gt;mp.negative_sign()&lt;/code&gt; (в случае использования шаблона отрицательного формата) возвращает строку с более чем одним символом, первый возвращенный символ помещается в выходную последовательность, где &lt;code&gt;&lt;a href=&quot;../money_base&quot;&gt;sign&lt;/a&gt;&lt;/code&gt; появляется в шаблоне форматирования, а остальные символы располагаются после всех других символов, например, шаблон форматирования &lt;code&gt;{sign, value, space, symbol}&lt;/code&gt; с единицами &lt;code&gt;123&lt;/code&gt; и отрицательный_сигнал &lt;code&gt;&quot;-&quot;&lt;/code&gt; может привести к &lt;code&gt;&quot;-1.23 &amp;euro;&quot;&lt;/code&gt; , в то время как отрицательный знак &lt;code&gt;&quot;()&quot;&lt;/code&gt; сгенерирует &lt;code&gt;&quot;(1.23 &amp;euro;)&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="790ce4186370cb3fc98f05fbcd1efa576fc74ae4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;n &amp;gt; 0 &amp;amp;&amp;amp; n &amp;lt; size()&lt;/code&gt;, a string representing</source>
          <target state="translated">Если &lt;code&gt;n &amp;gt; 0 &amp;amp;&amp;amp; n &amp;lt; size()&lt;/code&gt; , строка, представляющая</target>
        </trans-unit>
        <trans-unit id="c48b8077ed302c34e54734ee208fe448aa9fce59" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;n &amp;gt; 0 &amp;amp;&amp;amp; n &amp;lt; size()&lt;/code&gt;, the length of</source>
          <target state="translated">Если &lt;code&gt;n &amp;gt; 0 &amp;amp;&amp;amp; n &amp;lt; size()&lt;/code&gt; , длина</target>
        </trans-unit>
        <trans-unit id="f48f02b957cf489ffd4062413d130c7d61ac4261" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;n &amp;gt; 0 &amp;amp;&amp;amp; n &amp;lt; size()&lt;/code&gt;, the position of the first character of the</source>
          <target state="translated">Если &lt;code&gt;n &amp;gt; 0 &amp;amp;&amp;amp; n &amp;lt; size()&lt;/code&gt; , позиция первого символа</target>
        </trans-unit>
        <trans-unit id="d0a03be819895b29571bce6f30049ce00d836d67" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;n &amp;gt; 0&lt;/code&gt; and &lt;code&gt;n &amp;lt; size()&lt;/code&gt;, returns a reference to the &lt;code&gt;&lt;a href=&quot;../sub_match&quot;&gt;std::sub_match&lt;/a&gt;&lt;/code&gt; representing the part of the target sequence that was matched by the</source>
          <target state="translated">Если &lt;code&gt;n &amp;gt; 0&lt;/code&gt; и &lt;code&gt;n &amp;lt; size()&lt;/code&gt; , возвращает ссылку на &lt;code&gt;&lt;a href=&quot;../sub_match&quot;&gt;std::sub_match&lt;/a&gt;&lt;/code&gt; представляющую часть целевой последовательности, которая была сопоставлена</target>
        </trans-unit>
        <trans-unit id="c9ebc82c0ecb8a48088d0a25037fb0de7b63320a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;n == 0&lt;/code&gt;, a string representing entire matched expression is returned.</source>
          <target state="translated">Если &lt;code&gt;n == 0&lt;/code&gt; , возвращается строка, представляющая все совпадающее выражение.</target>
        </trans-unit>
        <trans-unit id="793a6257509b6fed6781f48113e3c6c7ee94fe8c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;n == 0&lt;/code&gt;, returns a reference to the &lt;code&gt;&lt;a href=&quot;../sub_match&quot;&gt;std::sub_match&lt;/a&gt;&lt;/code&gt; representing the part of the target sequence matched by the entire matched regular expression.</source>
          <target state="translated">Если &lt;code&gt;n == 0&lt;/code&gt; , возвращает ссылку на &lt;code&gt;&lt;a href=&quot;../sub_match&quot;&gt;std::sub_match&lt;/a&gt;&lt;/code&gt; представляющую часть целевой последовательности, совпадающую со всем соответствующим регулярным выражением.</target>
        </trans-unit>
        <trans-unit id="465490bd86a1fdb5bc7e8b3d057830ae9c3992ab" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;n == 0&lt;/code&gt;, the counted range is valid and empty. Otherwise, the counted range is only valid if n is positive, i is dereferenceable, and &lt;code&gt;[++i, --n)&lt;/code&gt; is a valid counted range.</source>
          <target state="translated">Если &lt;code&gt;n == 0&lt;/code&gt; , подсчитанный диапазон является действительным и пустым. В противном случае подсчитанный диапазон действителен, только если n положительно, i является разыменованным, а &lt;code&gt;[++i, --n)&lt;/code&gt; является допустимым подсчитанным диапазоном.</target>
        </trans-unit>
        <trans-unit id="101f7c47a2904602ca47dee8ebc924745b56a92f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;n == 0&lt;/code&gt;, the length of the entire matched expression is returned.</source>
          <target state="translated">Если &lt;code&gt;n == 0&lt;/code&gt; , длина всего совпадающего выражения возвращается.</target>
        </trans-unit>
        <trans-unit id="25afe120462723241b3dc46cef36ad98b886885e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;n == 0&lt;/code&gt;, the position of the first character of the entire matched expression is returned.</source>
          <target state="translated">Если &lt;code&gt;n == 0&lt;/code&gt; , возвращается позиция первого символа всего сопоставленного выражения.</target>
        </trans-unit>
        <trans-unit id="2c59d6a4ff2080c941bbe2819b072e112c520e00" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;n&lt;/code&gt; is greater or equal than 128, the behavior is implementation-defined</source>
          <target state="translated">Если &lt;code&gt;n&lt;/code&gt; больше или равно 128, поведение определяется реализацией</target>
        </trans-unit>
        <trans-unit id="227f98cc1496f2fc8d051b223cb2a826b5a37aeb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;n&lt;/code&gt; is greater or equal to 128, the behavior is implementation-defined.</source>
          <target state="translated">Если &lt;code&gt;n&lt;/code&gt; больше или равно 128, поведение определяется реализацией.</target>
        </trans-unit>
        <trans-unit id="b0eb7273803ff8b80903c2e9df0d1f3a2350edf8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;n&lt;/code&gt; is greater than the number of elements in the sequence, selects &lt;code&gt;last-first&lt;/code&gt; elements.</source>
          <target state="translated">Если &lt;code&gt;n&lt;/code&gt; больше, чем количество элементов в последовательности, выбираются &lt;code&gt;last-first&lt;/code&gt; элементы.</target>
        </trans-unit>
        <trans-unit id="184888f0f32fc840aab5148b93e76a03075f7c34" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;n&lt;/code&gt; is negative, the iterator is decremented. In this case, &lt;code&gt;InputIt&lt;/code&gt; must meet the requirements of &lt;a href=&quot;../named_req/bidirectionaliterator&quot;&gt;LegacyBidirectionalIterator&lt;/a&gt;, otherwise the behavior is undefined.</source>
          <target state="translated">Если &lt;code&gt;n&lt;/code&gt; отрицательно, итератор уменьшается. В этом случае &lt;code&gt;InputIt&lt;/code&gt; должен соответствовать требованиям &lt;a href=&quot;../named_req/bidirectionaliterator&quot;&gt;LegacyBidirectionalIterator&lt;/a&gt; , в противном случае поведение не определено.</target>
        </trans-unit>
        <trans-unit id="4dfef1823205b211d7bbfb1b78e819c624879b9d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;n&lt;/code&gt; or &lt;code&gt;m&lt;/code&gt; is greater or equal to 128, the behavior is implementation-defined.</source>
          <target state="translated">Если &lt;code&gt;n&lt;/code&gt; или &lt;code&gt;m&lt;/code&gt; больше или равно 128, поведение определяется реализацией.</target>
        </trans-unit>
        <trans-unit id="aad53311f76060eab43c7615e438c48408515bf1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;new_cap&lt;/code&gt; is greater than &lt;code&gt;&lt;a href=&quot;capacity&quot;&gt;capacity()&lt;/a&gt;&lt;/code&gt;, all iterators, including the past-the-end iterator, and all references to the elements are invalidated. Otherwise, no iterators or references are invalidated.</source>
          <target state="translated">Если &lt;code&gt;new_cap&lt;/code&gt; больше, чем Capacity &lt;code&gt;&lt;a href=&quot;capacity&quot;&gt;capacity()&lt;/a&gt;&lt;/code&gt; , все итераторы, в том числе итератор &amp;laquo;за конец&amp;raquo;, и все ссылки на элементы становятся недействительными. В противном случае никакие итераторы или ссылки не будут признаны недействительными.</target>
        </trans-unit>
        <trans-unit id="255c1e92345c2e7929c0df945bb3108b691340d8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;new_cap&lt;/code&gt; is greater than the current &lt;code&gt;&lt;a href=&quot;capacity&quot;&gt;capacity()&lt;/a&gt;&lt;/code&gt;, new storage is allocated, and &lt;code&gt;&lt;a href=&quot;capacity&quot;&gt;capacity()&lt;/a&gt;&lt;/code&gt; is made equal or greater than &lt;code&gt;new_cap&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;new_cap&lt;/code&gt; больше текущей &lt;code&gt;&lt;a href=&quot;capacity&quot;&gt;capacity()&lt;/a&gt;&lt;/code&gt; , выделяется новое хранилище, а &lt;code&gt;&lt;a href=&quot;capacity&quot;&gt;capacity()&lt;/a&gt;&lt;/code&gt; &lt;code&gt;new_cap&lt;/code&gt; равной или большей, чем new_cap .</target>
        </trans-unit>
        <trans-unit id="9b2651e65eddca052bf67c187fdb378c5807dec2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;new_cap&lt;/code&gt; is less than or equal to the current &lt;code&gt;&lt;a href=&quot;capacity&quot;&gt;capacity()&lt;/a&gt;&lt;/code&gt;, there is no effect.</source>
          <target state="translated">Если &lt;code&gt;new_cap&lt;/code&gt; меньше или равен текущей &lt;code&gt;&lt;a href=&quot;capacity&quot;&gt;capacity()&lt;/a&gt;&lt;/code&gt; , эффект отсутствует.</target>
        </trans-unit>
        <trans-unit id="4474adc2275755af141c407f92c0e2fd9a1bdda5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;new_cap&lt;/code&gt; is less than the current &lt;code&gt;&lt;a href=&quot;capacity&quot;&gt;capacity()&lt;/a&gt;&lt;/code&gt;, this is a non-binding shrink request.</source>
          <target state="translated">Если &lt;code&gt;new_cap&lt;/code&gt; меньше текущей &lt;code&gt;&lt;a href=&quot;capacity&quot;&gt;capacity()&lt;/a&gt;&lt;/code&gt; , это необязательный запрос сжатия.</target>
        </trans-unit>
        <trans-unit id="a7e10ae2e285048c1842329a710bd58e4af2b39c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;new_cap&lt;/code&gt; is less than the current &lt;code&gt;&lt;a href=&quot;size&quot;&gt;size()&lt;/a&gt;&lt;/code&gt;, this is a non-binding shrink-to-fit request equivalent to &lt;code&gt;&lt;a href=&quot;shrink_to_fit&quot;&gt;shrink_to_fit()&lt;/a&gt;&lt;/code&gt;(since C++11).</source>
          <target state="translated">Если &lt;code&gt;new_cap&lt;/code&gt; меньше текущего &lt;code&gt;&lt;a href=&quot;size&quot;&gt;size()&lt;/a&gt;&lt;/code&gt; , это необязательный запрос сжатия к размеру, эквивалентный &lt;code&gt;&lt;a href=&quot;shrink_to_fit&quot;&gt;shrink_to_fit()&lt;/a&gt;&lt;/code&gt; (начиная с C ++ 11).</target>
        </trans-unit>
        <trans-unit id="bf95be7cd7ebf5692c3135c92a75c10543f6e749" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;new_filename&lt;/code&gt; exists, the behavior is implementation-defined.</source>
          <target state="translated">Если &lt;code&gt;new_filename&lt;/code&gt; существует, поведение определяется реализацией.</target>
        </trans-unit>
        <trans-unit id="80cb878f6f5866322edb61fa31de1ba01506d28f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;new_size&lt;/code&gt; is zero, the behavior is implementation defined: null pointer may be returned (in which case the old memory block may or may not be freed) or some non-null pointer may be returned that may not be used to access storage.</source>
          <target state="translated">Если &lt;code&gt;new_size&lt;/code&gt; равен нулю, поведение определяется реализацией: нулевой указатель может быть возвращен (в этом случае старый блок памяти может или не может быть освобожден), или может быть возвращен некоторый ненулевой указатель, который может не использоваться для доступа к хранилищу.</target>
        </trans-unit>
        <trans-unit id="2de361cc207e32639639c741794ee2fcb6aa4087" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;noskipws&lt;/code&gt; is zero and &lt;code&gt;is.flags() &amp;amp; ios_base::skipws&lt;/code&gt; is nonzero, the function extracts and discards all whitespace characters until the next available character is not a whitespace character (as determined by the currently imbued locale in &lt;code&gt;is&lt;/code&gt;). If &lt;code&gt;is.rdbuf()-&amp;gt;sbumpc()&lt;/code&gt; or &lt;code&gt;is.rdbuf()-&amp;gt;sgetc()&lt;/code&gt; returns &lt;code&gt;traits::eof()&lt;/code&gt;, the function calls &lt;code&gt;setstate(failbit | eofbit)&lt;/code&gt; (which may throw &lt;code&gt;&lt;a href=&quot;../ios_base/failure&quot;&gt;std::ios_base::failure&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">Если &lt;code&gt;noskipws&lt;/code&gt; равен нулю и &lt;code&gt;is.flags() &amp;amp; ios_base::skipws&lt;/code&gt; отличен от нуля, функция извлекает и отбрасывает все пробельные символы до тех пор, пока следующий доступный символ не будет символом пробела (как определено текущей пропущенной локалью в &lt;code&gt;is&lt;/code&gt; ). Если &lt;code&gt;is.rdbuf()-&amp;gt;sbumpc()&lt;/code&gt; или &lt;code&gt;is.rdbuf()-&amp;gt;sgetc()&lt;/code&gt; возвращает &lt;code&gt;traits::eof()&lt;/code&gt; , функция вызывает &lt;code&gt;setstate(failbit | eofbit)&lt;/code&gt; (которая может &lt;code&gt;&lt;a href=&quot;../ios_base/failure&quot;&gt;std::ios_base::failure&lt;/a&gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="9c309a7e2f969d9c1fa291f40fe3ab598e47bd4e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;obj&lt;/code&gt; was not default-constructed, the behavior is undefined.</source>
          <target state="translated">Если &lt;code&gt;obj&lt;/code&gt; не был создан по умолчанию, поведение не определено.</target>
        </trans-unit>
        <trans-unit id="4e236834fc06642f73e875ff2b0ea5467f35c428" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;old_p&lt;/code&gt; is a directory, then &lt;code&gt;new_p&lt;/code&gt; must be one of:</source>
          <target state="translated">Если &lt;code&gt;old_p&lt;/code&gt; является каталогом, то &lt;code&gt;new_p&lt;/code&gt; должен быть одним из:</target>
        </trans-unit>
        <trans-unit id="769c85f3779db98891c17618ad67c5dc15d9f91f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;old_p&lt;/code&gt; is a non-directory file, then &lt;code&gt;new_p&lt;/code&gt; must be one of:</source>
          <target state="translated">Если &lt;code&gt;old_p&lt;/code&gt; не является каталогом, то &lt;code&gt;new_p&lt;/code&gt; должен быть одним из:</target>
        </trans-unit>
        <trans-unit id="73715913e7ab67a68239322dafae4a19098bf520" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;openmode&lt;/code&gt; is not one of the modes listed, the &lt;code&gt;open()&lt;/code&gt; fails.</source>
          <target state="translated">Если &lt;code&gt;openmode&lt;/code&gt; не является одним из перечисленных режимов, &lt;code&gt;open()&lt;/code&gt; завершается ошибкой.</target>
        </trans-unit>
        <trans-unit id="6e9a3e1afd67e93539e35474985138b3c3deb24f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;opts&lt;/code&gt; is &lt;code&gt;perm_options::add&lt;/code&gt;, the file permissions are set to exactly &lt;code&gt;status(p).permissions() | (prms &amp;amp; perms::mask)&lt;/code&gt; (meaning, any valid bit that is set in &lt;code&gt;prms&lt;/code&gt;, but not in the file's current permissions is added to the file's permissions)</source>
          <target state="translated">Если &lt;code&gt;opts&lt;/code&gt; является &lt;code&gt;perm_options::add&lt;/code&gt; , права доступа к файлам устанавливаются точно &lt;code&gt;status(p).permissions() | (prms &amp;amp; perms::mask)&lt;/code&gt; (то есть любой допустимый бит, который установлен в &lt;code&gt;prms&lt;/code&gt; , но не в текущих разрешениях файла, добавляется к разрешениям файла)</target>
        </trans-unit>
        <trans-unit id="38f8c3a3043f7271f4f818139555edb242b7d47e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;opts&lt;/code&gt; is &lt;code&gt;perm_options::remove&lt;/code&gt;, the file permissions are set to exactly &lt;code&gt;status(p).permissions() &amp;amp; ~(prms &amp;amp; perms::mask)&lt;/code&gt; (meaning, any valid bit that is clear in &lt;code&gt;prms&lt;/code&gt;, but set in the file's current permissions is cleared in the file's permissions)</source>
          <target state="translated">Если &lt;code&gt;opts&lt;/code&gt; является &lt;code&gt;perm_options::remove&lt;/code&gt; , права доступа к файлам устанавливается точно &lt;code&gt;status(p).permissions() &amp;amp; ~(prms &amp;amp; perms::mask)&lt;/code&gt; (то есть, любой действительный бит , что ясно в &lt;code&gt;prms&lt;/code&gt; , но набор в файл - х текущие разрешения очищаются в разрешениях файла)</target>
        </trans-unit>
        <trans-unit id="743b1ea9d394f52e11e3859206c7efdd472d283a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;opts&lt;/code&gt; is &lt;code&gt;perm_options::replace&lt;/code&gt;, file permissions are set to exactly &lt;code&gt;prms &amp;amp; &lt;a href=&quot;perms&quot;&gt;std::filesystem::perms::mask&lt;/a&gt;&lt;/code&gt; (meaning, every valid bit of &lt;code&gt;prms&lt;/code&gt; is applied)</source>
          <target state="translated">Если &lt;code&gt;opts&lt;/code&gt; является &lt;code&gt;perm_options::replace&lt;/code&gt; , права доступа к файлам устанавливаются точно &lt;code&gt;prms &amp;amp; &lt;a href=&quot;perms&quot;&gt;std::filesystem::perms::mask&lt;/a&gt;&lt;/code&gt; (то есть, каждый действительный бит &lt;code&gt;prms&lt;/code&gt; применяется)</target>
        </trans-unit>
        <trans-unit id="4fef9d0f0afa6e8487fa35a14b4387e28190db47" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;os.good()&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;, returns. Otherwise, if &lt;code&gt;os.tie()&lt;/code&gt; is not a null pointer, calls &lt;code&gt;os.tie()-&amp;gt;flush()&lt;/code&gt; to synchronize the output sequence with external streams. During preparation, the constructor may call &lt;code&gt;setstate(failbit)&lt;/code&gt; (which may throw &lt;code&gt;&lt;a href=&quot;../ios_base/failure&quot;&gt;std::ios_base::failure&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">Если &lt;code&gt;os.good()&lt;/code&gt; имеет значение &lt;code&gt;false&lt;/code&gt; , возвращает. В противном случае, если &lt;code&gt;os.tie()&lt;/code&gt; не является нулевым указателем, вызывается &lt;code&gt;os.tie()-&amp;gt;flush()&lt;/code&gt; для синхронизации выходной последовательности с внешними потоками. Во время подготовки конструктор может вызвать &lt;code&gt;setstate(failbit)&lt;/code&gt; (который может &lt;code&gt;&lt;a href=&quot;../ios_base/failure&quot;&gt;std::ios_base::failure&lt;/a&gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="009d318ae78f457dac42968d4c493d6541c60df6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;os.rdbuf()&lt;/code&gt; actually points to a &lt;code&gt;&lt;a href=&quot;../basic_syncbuf&quot;&gt;std::basic_syncbuf&lt;/a&gt;&amp;lt;CharT, Traits, Allocator&amp;gt;&lt;/code&gt;&lt;code&gt;buf&lt;/code&gt;, toggles whether it emits (i.e., transmits data to the underlying stream buffer) when flushed:</source>
          <target state="translated">Если &lt;code&gt;os.rdbuf()&lt;/code&gt; самом деле указывает на &lt;code&gt;&lt;a href=&quot;../basic_syncbuf&quot;&gt;std::basic_syncbuf&lt;/a&gt;&amp;lt;CharT, Traits, Allocator&amp;gt;&lt;/code&gt; &lt;code&gt;buf&lt;/code&gt; , переключает, испускает ли он (т.е. передает данные в базовый буфер потока) при сбросе:</target>
        </trans-unit>
        <trans-unit id="86470d4ce8b2df93a46fea671370851ae460db55" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;other&lt;/code&gt; contains a value, then depending on whether &lt;code&gt;*this&lt;/code&gt; contains a value, the contained value is either &lt;a href=&quot;../../language/direct_initialization&quot;&gt;direct-initialized&lt;/a&gt; or assigned from &lt;code&gt;*other&lt;/code&gt;(2) or &lt;code&gt;std::move(*other)&lt;/code&gt;(3). Note that a moved-from optional still</source>
          <target state="translated">Если &lt;code&gt;other&lt;/code&gt; содержит значение, то в зависимости от того, содержит ли &lt;code&gt;*this&lt;/code&gt; значение, содержащееся в нем значение либо &lt;a href=&quot;../../language/direct_initialization&quot;&gt;инициализируется напрямую,&lt;/a&gt; либо присваивается из &lt;code&gt;*other&lt;/code&gt; (2) или &lt;code&gt;std::move(*other)&lt;/code&gt; (3). Обратите внимание, что необязательный еще</target>
        </trans-unit>
        <trans-unit id="36484744e817604683f9351055f9e29eff44cf5e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;other&lt;/code&gt; contains a value, then depending on whether &lt;code&gt;*this&lt;/code&gt; contains a value, the contained value is either &lt;a href=&quot;../../language/direct_initialization&quot;&gt;direct-initialized&lt;/a&gt; or assigned from &lt;code&gt;*other&lt;/code&gt;(5) or &lt;code&gt;std::move(*other)&lt;/code&gt;(6). Note that a moved-from optional still</source>
          <target state="translated">Если &lt;code&gt;other&lt;/code&gt; содержит значение, то в зависимости от того, содержит ли &lt;code&gt;*this&lt;/code&gt; значение, содержащееся в нем значение либо &lt;a href=&quot;../../language/direct_initialization&quot;&gt;инициализируется напрямую,&lt;/a&gt; либо присваивается из &lt;code&gt;*other&lt;/code&gt; (5) или &lt;code&gt;std::move(*other)&lt;/code&gt; (6). Обратите внимание, что необязательный еще</target>
        </trans-unit>
        <trans-unit id="c8399508478e3a1e9b6988b20831b2cf1587c5e5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;other&lt;/code&gt; refers to the same object as &lt;code&gt;*this&lt;/code&gt;, has no effects. Otherwise, copies the state of the stream &lt;code&gt;other&lt;/code&gt; into &lt;code&gt;*this&lt;/code&gt;. This is done in the following sequence:</source>
          <target state="translated">Если &lt;code&gt;other&lt;/code&gt; относится к тому же объекту, что и &lt;code&gt;*this&lt;/code&gt; , не имеет никаких эффектов. В противном случае копирует состояние потока &lt;code&gt;other&lt;/code&gt; в &lt;code&gt;*this&lt;/code&gt; . Это делается в следующей последовательности:</target>
        </trans-unit>
        <trans-unit id="cde0508aa3c91b841b5bb98037ec418d76d0f467" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;out_stream&lt;/code&gt; is a pointer to the associated &lt;code&gt;&lt;a href=&quot;../../io/basic_ostream&quot;&gt;std::basic_ostream&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;delim&lt;/code&gt; is the delimiter specified at the construction of this object, then the effect is equivalent to.</source>
          <target state="translated">Если &lt;code&gt;out_stream&lt;/code&gt; является указателем на связанный &lt;code&gt;&lt;a href=&quot;../../io/basic_ostream&quot;&gt;std::basic_ostream&lt;/a&gt;&lt;/code&gt; а &lt;code&gt;delim&lt;/code&gt; является разделителем, указанным при построении этого объекта, то эффект эквивалентен.</target>
        </trans-unit>
        <trans-unit id="9a4113e2f36160ea8f8bfa69f1009dc12f90fc93" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;p == 1&lt;/code&gt;, subsequent calls to the &lt;a href=&quot;operator()&quot;&gt;&lt;code&gt;operator()&lt;/code&gt;&lt;/a&gt; overload that does not accept a &lt;code&gt;param_type&lt;/code&gt; object will cause undefined behavior.</source>
          <target state="translated">Если &lt;code&gt;p == 1&lt;/code&gt; , последующие вызовы перегрузки &lt;a href=&quot;operator()&quot;&gt; &lt;code&gt;operator()&lt;/code&gt; &lt;/a&gt; , которая не принимает объект &lt;code&gt;param_type&lt;/code&gt; , вызовут неопределенное поведение.</target>
        </trans-unit>
        <trans-unit id="39fcfc6551db4ea098125222aa584e4d80195a5c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;p&lt;/code&gt; does not exist, reports an error.</source>
          <target state="translated">Если &lt;code&gt;p&lt;/code&gt; не существует, выдает ошибку.</target>
        </trans-unit>
        <trans-unit id="c7e10031a884549bafa7d7b0cdef0c9d208f99c2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;p&lt;/code&gt; does not exist, returns &lt;code&gt;file_status(file_type::not_found)&lt;/code&gt;</source>
          <target state="translated">Если &lt;code&gt;p&lt;/code&gt; не существует, возвращает &lt;code&gt;file_status(file_type::not_found)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="35e83165c214a9475effb2ede4b6d71c2ec296a2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;p&lt;/code&gt; exists but file attributes cannot be determined, e.g. due to lack of permissions, returns &lt;code&gt;file_status(file_type::unknown)&lt;/code&gt;</source>
          <target state="translated">Если &lt;code&gt;p&lt;/code&gt; существует, но атрибуты файла не могут быть определены, например, из-за отсутствия разрешений, возвращает &lt;code&gt;file_status(file_type::unknown)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="284cbde49fd69756d49af77ea69cb915f6cc4f80" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;p&lt;/code&gt; has an implementation-defined file type, returns &lt;code&gt;file_status(file_type::A, prms)&lt;/code&gt; where &lt;code&gt;A&lt;/code&gt; is the implementation-defined &lt;a href=&quot;file_type&quot;&gt;&lt;code&gt;file_type&lt;/code&gt;&lt;/a&gt; constant for that type.</source>
          <target state="translated">Если &lt;code&gt;p&lt;/code&gt; имеет тип файла, определенный реализацией, возвращает &lt;code&gt;file_status(file_type::A, prms)&lt;/code&gt; где &lt;code&gt;A&lt;/code&gt; - это константа, определяемая реализацией &lt;a href=&quot;file_type&quot;&gt; &lt;code&gt;file_type&lt;/code&gt; &lt;/a&gt; для этого типа.</target>
        </trans-unit>
        <trans-unit id="84ba1d9110ba0eaab227ddc535151c53fd9656e5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;p&lt;/code&gt; is a block special file (as if by POSIX &lt;code&gt;S_ISBLK&lt;/code&gt;), returns &lt;code&gt;file_status(file_type::block, prms)&lt;/code&gt;</source>
          <target state="translated">Если &lt;code&gt;p&lt;/code&gt; является специальным файлом блока (как в случае POSIX &lt;code&gt;S_ISBLK&lt;/code&gt; ), возвращает &lt;code&gt;file_status(file_type::block, prms)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a8d7bbe00812399696fe7cc6d0e4fb887d95e2e5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;p&lt;/code&gt; is a character special file (as if by POSIX &lt;code&gt;S_ISCHR&lt;/code&gt;), returns &lt;code&gt;file_status(file_type::character, prms)&lt;/code&gt;</source>
          <target state="translated">Если &lt;code&gt;p&lt;/code&gt; - это специальный символьный файл (как если бы POSIX &lt;code&gt;S_ISCHR&lt;/code&gt; ), возвращает &lt;code&gt;file_status(file_type::character, prms)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5948ebb49968bd5b647e0007b11f05d39ecbae58" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;p&lt;/code&gt; is a directory (as if by POSIX &lt;code&gt;S_ISDIR&lt;/code&gt;), returns &lt;code&gt;file_status(file_type::directory, prms)&lt;/code&gt;</source>
          <target state="translated">Если &lt;code&gt;p&lt;/code&gt; является каталогом (как если бы POSIX &lt;code&gt;S_ISDIR&lt;/code&gt; ), возвращает &lt;code&gt;file_status(file_type::directory, prms)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7098ea96e1e6fe0bd037998b47dc31e8e17fec8b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;p&lt;/code&gt; is a fifo or pipe file (as if by POSIX &lt;code&gt;S_ISFIFO&lt;/code&gt;), returns &lt;code&gt;file_status(file_type::fifo, prms)&lt;/code&gt;</source>
          <target state="translated">Если &lt;code&gt;p&lt;/code&gt; - это файл fifo или pipe (как в случае POSIX &lt;code&gt;S_ISFIFO&lt;/code&gt; ), возвращает &lt;code&gt;file_status(file_type::fifo, prms)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6b2d16f4bd782dbe9f713f31636dbe449e4151e8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;p&lt;/code&gt; is a regular file (as if by POSIX &lt;code&gt;S_ISREG&lt;/code&gt;), returns &lt;code&gt;file_status(file_type::regular, prms)&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;p&lt;/code&gt; является обычным файлом (как если бы POSIX &lt;code&gt;S_ISREG&lt;/code&gt; ), возвращает &lt;code&gt;file_status(file_type::regular, prms)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="dd7f50e30d338262c2966fea6e46450e597e3af6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;p&lt;/code&gt; is a socket (as if by POSIX &lt;code&gt;S_ISSOCK&lt;/code&gt;), returns &lt;code&gt;file_status(file_type::socket, prms)&lt;/code&gt;</source>
          <target state="translated">Если &lt;code&gt;p&lt;/code&gt; является сокетом (как если бы POSIX &lt;code&gt;S_ISSOCK&lt;/code&gt; ), возвращает &lt;code&gt;file_status(file_type::socket, prms)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="249fe3aff7a5aaa72c5e17941aa8c099b4d5e055" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;p&lt;/code&gt; is a symlink, returns &lt;code&gt;file_status(file_type::symlink)&lt;/code&gt;</source>
          <target state="translated">Если &lt;code&gt;p&lt;/code&gt; является символической &lt;code&gt;file_status(file_type::symlink)&lt;/code&gt; , возвращает file_status (file_type :: symlink)</target>
        </trans-unit>
        <trans-unit id="2a1524ab079a206332a561da96374e5f2392e60c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;parm_n&lt;/code&gt; is declared with reference type or with a type not compatible with the type that results from &lt;a href=&quot;../../language/variadic_arguments#Default_conversions&quot;&gt;default argument promotions&lt;/a&gt;, the behavior is undefined.</source>
          <target state="translated">Если &lt;code&gt;parm_n&lt;/code&gt; объявлен с ссылочным типом или с типом, несовместимым с типом, который является результатом &lt;a href=&quot;../../language/variadic_arguments#Default_conversions&quot;&gt;продвижения аргумента по умолчанию&lt;/a&gt; , поведение не определено.</target>
        </trans-unit>
        <trans-unit id="e24b13015ddf20bc0adacae9ec44ca2ad7e04f7e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;path::value_type&lt;/code&gt; is &lt;code&gt;char&lt;/code&gt; and native encoding is UTF-8, constructs a path directly as if by &lt;code&gt;path(source)&lt;/code&gt; or &lt;code&gt;path(first, last)&lt;/code&gt;. Note: this is the typical situation of a POSIX system that uses Unicode, such as Linux.</source>
          <target state="translated">Если &lt;code&gt;path::value_type&lt;/code&gt; - это &lt;code&gt;char&lt;/code&gt; , а нативная кодировка - UTF-8, то путь создается напрямую, как если бы это &lt;code&gt;path(source)&lt;/code&gt; или &lt;code&gt;path(first, last)&lt;/code&gt; . Примечание: это типичная ситуация для системы POSIX, которая использует Unicode, например Linux.</target>
        </trans-unit>
        <trans-unit id="f1467bab99e474a5aa0ae0855c89eab043a29738" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;path::value_type&lt;/code&gt; is &lt;code&gt;char&lt;/code&gt;, conversion, if any, is system-dependent. This is the case on typical POSIX systems (such as Linux), where native encoding is UTF-8 and &lt;code&gt;string()&lt;/code&gt; performs no conversion.</source>
          <target state="translated">Если &lt;code&gt;path::value_type&lt;/code&gt; равен &lt;code&gt;char&lt;/code&gt; , преобразование, если оно есть, зависит от системы. Это имеет место в типичных системах POSIX (таких как Linux), где встроенная кодировка - UTF-8, а &lt;code&gt;string()&lt;/code&gt; выполняет преобразование.</target>
        </trans-unit>
        <trans-unit id="ecd5f9bafd39fb01f214968395060cedf4c94446" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;placement_params&lt;/code&gt; are provided, they are passed to the allocation function as additional arguments. Such allocation functions are known as &quot;placement new&quot;, after the standard allocation function &lt;code&gt;void* &lt;a href=&quot;../memory/new/operator_new&quot;&gt;operator new&lt;/a&gt;(&lt;a href=&quot;../types/size_t&quot;&gt;std::size_t&lt;/a&gt;, void*)&lt;/code&gt;, which simply returns its second argument unchanged. This is used to construct objects in allocated storage:</source>
          <target state="translated">Если &lt;code&gt;placement_params&lt;/code&gt; предусмотрены, они передаются функции распределения в качестве дополнительных аргументов. Такие функции размещения известны как &amp;laquo;размещение нового&amp;raquo; после стандартной функции распределения &lt;code&gt;void* &lt;a href=&quot;../memory/new/operator_new&quot;&gt;operator new&lt;/a&gt;(&lt;a href=&quot;../types/size_t&quot;&gt;std::size_t&lt;/a&gt;, void*)&lt;/code&gt; , который просто возвращает свой второй аргумент без изменений. Это используется для построения объектов в выделенном хранилище:</target>
        </trans-unit>
        <trans-unit id="73eb91c9e150b84ef667442582643acf6c0ee10d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;pos &amp;gt; size()&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../../error/out_of_range/out_of_range&quot;&gt;std::out_of_range&lt;/a&gt;&lt;/code&gt; is thrown.</source>
          <target state="translated">Если &lt;code&gt;pos &amp;gt; size()&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../../error/out_of_range/out_of_range&quot;&gt;std::out_of_range&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d5825465b5dfa7d68d014c8c650a4880927e452b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;pos &amp;gt; str.size()&lt;/code&gt;, this constructor throws &lt;code&gt;&lt;a href=&quot;../../error/out_of_range/out_of_range&quot;&gt;std::out_of_range&lt;/a&gt;&lt;/code&gt;. If any characters examined in &lt;code&gt;str&lt;/code&gt; are not &lt;code&gt;zero&lt;/code&gt; or &lt;code&gt;one&lt;/code&gt;, it throws &lt;code&gt;&lt;a href=&quot;../../error/invalid_argument/invalid_argument&quot;&gt;std::invalid_argument&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;pos &amp;gt; str.size()&lt;/code&gt; , этот конструктор выдает &lt;code&gt;&lt;a href=&quot;../../error/out_of_range/out_of_range&quot;&gt;std::out_of_range&lt;/a&gt;&lt;/code&gt; . Если какие-либо символы, проверенные в &lt;code&gt;str&lt;/code&gt; , не &lt;code&gt;zero&lt;/code&gt; или &lt;code&gt;one&lt;/code&gt; , он выдает &lt;code&gt;&lt;a href=&quot;../../error/invalid_argument/invalid_argument&quot;&gt;std::invalid_argument&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f9cdf4cfe8233d41239dac602c3524239510fa6e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;pos == size()&lt;/code&gt;, a reference to the character with value &lt;code&gt;CharT()&lt;/code&gt; (the null character) is returned.</source>
          <target state="translated">Если &lt;code&gt;pos == size()&lt;/code&gt; , возвращается ссылка на символ со значением &lt;code&gt;CharT()&lt;/code&gt; (нулевой символ).</target>
        </trans-unit>
        <trans-unit id="45d948614cf70d9e5ba39df1cc54e194a17a73da" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;pos&lt;/code&gt; is not a null pointer, then a pointer &lt;code&gt;ptr&lt;/code&gt; - internal to the conversion functions - will receive the address of the first unconverted character in &lt;code&gt;str.c_str()&lt;/code&gt;, and the index of that character will be calculated and stored in &lt;code&gt;*pos&lt;/code&gt;, giving the number of characters that were processed by the conversion.</source>
          <target state="translated">Если &lt;code&gt;pos&lt;/code&gt; не является нулевым указателем, то указатель &lt;code&gt;ptr&lt;/code&gt; - внутренний для функций преобразования - получит адрес первого не &lt;code&gt;str.c_str()&lt;/code&gt; символа в str.c_str () , а индекс этого символа будет вычислен и сохранен в &lt;code&gt;*pos&lt;/code&gt; , давая количество символов, которые были обработаны преобразованием.</target>
        </trans-unit>
        <trans-unit id="f6fea302ec518c538cb888ab49b9e51eb713903c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;pos&lt;/code&gt; is not a null pointer, then a pointer &lt;code&gt;ptr&lt;/code&gt;, internal to the conversion functions, will receive the address of the first unconverted character in &lt;code&gt;str.c_str()&lt;/code&gt;, and the index of that character will be calculated and stored in &lt;code&gt;*pos&lt;/code&gt;, giving the number of characters that were processed by the conversion.</source>
          <target state="translated">Если &lt;code&gt;pos&lt;/code&gt; не является нулевым указателем, то указатель &lt;code&gt;ptr&lt;/code&gt; , внутренний для функций преобразования, получит адрес первого не &lt;code&gt;str.c_str()&lt;/code&gt; символа в str.c_str () , а индекс этого символа будет вычислен и сохранен в &lt;code&gt;*pos&lt;/code&gt; , давая количество символов, которые были обработаны преобразованием.</target>
        </trans-unit>
        <trans-unit id="079f39fe95713c066d5cd5476974d3a17ef66bef" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;pos&lt;/code&gt; is not within the range of the container, an exception of type &lt;code&gt;&lt;a href=&quot;../../error/out_of_range/out_of_range&quot;&gt;std::out_of_range&lt;/a&gt;&lt;/code&gt; is thrown.</source>
          <target state="translated">Если &lt;code&gt;pos&lt;/code&gt; находится вне диапазона контейнера, генерируется исключение типа &lt;code&gt;&lt;a href=&quot;../../error/out_of_range/out_of_range&quot;&gt;std::out_of_range&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="beb7dae20fb8d8052f57f043526ceb062d467b3e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;ps&lt;/code&gt; is not a null pointer, the &lt;code&gt;mbsinit&lt;/code&gt; function determines whether the pointed-to &lt;code&gt;&lt;a href=&quot;mbstate_t&quot;&gt;std::mbstate_t&lt;/a&gt;&lt;/code&gt; object describes the initial conversion state.</source>
          <target state="translated">Если &lt;code&gt;ps&lt;/code&gt; не является нулевым указателем, функция &lt;code&gt;mbsinit&lt;/code&gt; определяет, описывает &lt;code&gt;&lt;a href=&quot;mbstate_t&quot;&gt;std::mbstate_t&lt;/a&gt;&lt;/code&gt; объект- указатель на std :: mbstate_t начальное состояние преобразования.</target>
        </trans-unit>
        <trans-unit id="101e3c4415b14d26fb3724226aa4e6d4501f3aea" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;ptr&lt;/code&gt; is a null pointer, the behavior is the same as calling &lt;code&gt;&lt;a href=&quot;malloc&quot;&gt;std::malloc&lt;/a&gt;&lt;/code&gt;(&lt;code&gt;new_size&lt;/code&gt;).</source>
          <target state="translated">Если &lt;code&gt;ptr&lt;/code&gt; является нулевым указателем, поведение аналогично вызову &lt;code&gt;&lt;a href=&quot;malloc&quot;&gt;std::malloc&lt;/a&gt;&lt;/code&gt; ( &lt;code&gt;new_size&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="75ce63992e734876e2a939cc380b004ef361f5a4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;ptr&lt;/code&gt; is a null pointer, the function does nothing.</source>
          <target state="translated">Если &lt;code&gt;ptr&lt;/code&gt; - нулевой указатель, функция ничего не делает.</target>
        </trans-unit>
        <trans-unit id="f2dc2865c464168b736d26e4f6c5e34da572e57e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;r&lt;/code&gt; is empty, so is the new &lt;code&gt;shared_ptr&lt;/code&gt; (but its stored pointer is not necessarily null). Otherwise, the new &lt;code&gt;shared_ptr&lt;/code&gt; will share ownership with the initial value of &lt;code&gt;r&lt;/code&gt;, except that it is empty if the &lt;code&gt;dynamic_cast&lt;/code&gt; performed by &lt;code&gt;dynamic_pointer_cast&lt;/code&gt; returns a null pointer.</source>
          <target state="translated">Если &lt;code&gt;r&lt;/code&gt; пусто, &lt;code&gt;shared_ptr&lt;/code&gt; новый shared_ptr (но его сохраненный указатель не обязательно равен нулю). В противном случае новый &lt;code&gt;shared_ptr&lt;/code&gt; будет разделять владельца с начальным значением &lt;code&gt;r&lt;/code&gt; , за исключением того, что он пуст, если &lt;code&gt;dynamic_cast&lt;/code&gt; , выполняемый &lt;code&gt;dynamic_pointer_cast&lt;/code&gt; , возвращает нулевой указатель.</target>
        </trans-unit>
        <trans-unit id="b29c481ab6a6599cf423510b090aefb5d2a5a864" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;r&lt;/code&gt; is not null, sets the default memory resource pointer to &lt;code&gt;r&lt;/code&gt;; otherwise, sets the default memory resource pointer to &lt;code&gt;&lt;a href=&quot;new_delete_resource&quot;&gt;std::pmr::new_delete_resource&lt;/a&gt;()&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;r&lt;/code&gt; не нуль, устанавливает указатель ресурса памяти по умолчанию на &lt;code&gt;r&lt;/code&gt; ; в противном случае указатель ресурса памяти по умолчанию устанавливается на &lt;code&gt;&lt;a href=&quot;new_delete_resource&quot;&gt;std::pmr::new_delete_resource&lt;/a&gt;()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="775fd3976f21369f6410f6f3d50cc92d417bb684" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;rand()&lt;/code&gt; is used before any calls to &lt;code&gt;srand()&lt;/code&gt;, &lt;code&gt;rand()&lt;/code&gt; behaves as if it was seeded with &lt;code&gt;srand(1)&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;rand()&lt;/code&gt; используется перед любыми вызовами &lt;code&gt;srand()&lt;/code&gt; , &lt;code&gt;rand()&lt;/code&gt; ведет себя так, как если бы он был &lt;code&gt;srand(1)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3e1109753adbdfe03f2bb121a57562bbd3b95645" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;rdbuf()-&amp;gt;in_avail() &amp;gt; 0&lt;/code&gt;, extracts &lt;code&gt;&lt;a href=&quot;../../algorithm/min&quot;&gt;std::min&lt;/a&gt;(rdbuf()-&amp;gt;in_avail(), count)&lt;/code&gt; characters and stores them into successive locations of the characater array whose first element is pointed to by &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;rdbuf()-&amp;gt;in_avail() &amp;gt; 0&lt;/code&gt; , извлекает &lt;code&gt;&lt;a href=&quot;../../algorithm/min&quot;&gt;std::min&lt;/a&gt;(rdbuf()-&amp;gt;in_avail(), count)&lt;/code&gt; &lt;a href=&quot;../../algorithm/min&quot;&gt;std :: min&lt;/a&gt; (rdbuf () -&amp;gt; in_avail (), count) и сохраняет их в последовательных расположениях массива символов, на первый элемент которого указывает &lt;code&gt;s&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8cb1ced447e9513c6cc2a7656394e6e283081981" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;rdbuf()-&amp;gt;in_avail() == -1&lt;/code&gt;, calls &lt;code&gt;setstate(eofbit)&lt;/code&gt; and extracts no characters.</source>
          <target state="translated">Если &lt;code&gt;rdbuf()-&amp;gt;in_avail() == -1&lt;/code&gt; , вызывает &lt;code&gt;setstate(eofbit)&lt;/code&gt; и не извлекает никаких символов.</target>
        </trans-unit>
        <trans-unit id="1d663866c5ef6d453a0e6e1c3a442d54a0a631ca" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;rdbuf()-&amp;gt;in_avail() == 0&lt;/code&gt;, extracts no characters.</source>
          <target state="translated">Если &lt;code&gt;rdbuf()-&amp;gt;in_avail() == 0&lt;/code&gt; , символы не извлекаются.</target>
        </trans-unit>
        <trans-unit id="0bb9782f82ff3d24467c86f4716084ada4ca990f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;rdbuf()-&amp;gt;sungetc()&lt;/code&gt; returns &lt;code&gt;Traits::eof()&lt;/code&gt;, calls &lt;code&gt;setstate(badbit)&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;rdbuf()-&amp;gt;sungetc()&lt;/code&gt; возвращает &lt;code&gt;Traits::eof()&lt;/code&gt; , вызывает &lt;code&gt;setstate(badbit)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2f7f0c931fb16fc794bc074b32fcde3eb8dce586" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;rdbuf()&lt;/code&gt; is null or if &lt;code&gt;rdbuf-&amp;gt;sputbackc(ch)&lt;/code&gt; returns &lt;code&gt;Traits::eof()&lt;/code&gt;, calls &lt;code&gt;setstate(badbit)&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;rdbuf()&lt;/code&gt; имеет значение null или &lt;code&gt;rdbuf-&amp;gt;sputbackc(ch)&lt;/code&gt; возвращает &lt;code&gt;Traits::eof()&lt;/code&gt; , вызывает &lt;code&gt;setstate(badbit)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8c685f865d646b3c4c7e1a09a3ab4541aca64af5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;rep_&lt;/code&gt; is a member variable holding the number of ticks in a duration object,</source>
          <target state="translated">Если &lt;code&gt;rep_&lt;/code&gt; является переменной-членом, содержащей количество тиков в объекте продолжительности,</target>
        </trans-unit>
        <trans-unit id="dd202d89b0c5b4958bcc3baf6d4f8cc9e4180f5c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;rep_&lt;/code&gt; is a member variable holding the number of ticks in a duration object, and &lt;code&gt;D&lt;/code&gt; is the return type,</source>
          <target state="translated">Если &lt;code&gt;rep_&lt;/code&gt; является переменной-членом, содержащей количество тиков в объекте продолжительности, а &lt;code&gt;D&lt;/code&gt; является типом возврата,</target>
        </trans-unit>
        <trans-unit id="d39a4ad84577a00c15233086e6e7ac8affa4a963" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;rep_&lt;/code&gt; is the member variable holding the number of ticks in this duration object,</source>
          <target state="translated">Если &lt;code&gt;rep_&lt;/code&gt; является переменной-членом, содержащей количество тиков в этом объекте продолжительности,</target>
        </trans-unit>
        <trans-unit id="f2eadcb39ee434e29ef05bd72b2b26a315c2acf9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;s&lt;/code&gt; is a null pointer and &lt;code&gt;n&lt;/code&gt; is zero, the filebuf becomes</source>
          <target state="translated">Если &lt;code&gt;s&lt;/code&gt; - нулевой указатель, а &lt;code&gt;n&lt;/code&gt; - ноль, filebuf становится</target>
        </trans-unit>
        <trans-unit id="9b53eb098a63b3e541f5d769951b6fce364d2e5c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;s&lt;/code&gt; is a null pointer and &lt;code&gt;n&lt;/code&gt; is zero, this function has no effect.</source>
          <target state="translated">Если &lt;code&gt;s&lt;/code&gt; - нулевой указатель, а &lt;code&gt;n&lt;/code&gt; - ноль, эта функция не имеет никакого эффекта.</target>
        </trans-unit>
        <trans-unit id="1972341d22f77196bc1af118f58697bce937d0f6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;s&lt;/code&gt; is a null pointer, resets its internal conversion state to represent the initial shift state and returns &lt;code&gt;​0​&lt;/code&gt; if the current multibyte encoding is not state-dependent (does not use shift sequences) or a non-zero value if the current multibyte encoding is state-dependent (uses shift sequences).</source>
          <target state="translated">Если &lt;code&gt;s&lt;/code&gt; является указателем NULL, сбрасывает его внутреннее состояние преобразования для представления исходного состояния сдвига и возвращает &lt;code&gt;​0​&lt;/code&gt; , если текущая кодировка многобайтовой не зависящее от состояния (не использует сдвиг последовательностей) или значение , отличные от нуля , если ток многобайтового кодирование зависит от состояния (использует сдвиговые последовательности).</target>
        </trans-unit>
        <trans-unit id="c39632bb99f5cb18b879a3b49462f93b75999d15" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;s&lt;/code&gt; is a null pointer, resets the global conversion state and determines whether shift sequences are used.</source>
          <target state="translated">Если &lt;code&gt;s&lt;/code&gt; является нулевым указателем, сбрасывает состояние глобального преобразования и определяет, используются ли последовательности сдвига.</target>
        </trans-unit>
        <trans-unit id="6138f983954415f7151da4086aa9c700eb8d9987" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;s&lt;/code&gt; is a null pointer, the call is equivalent to &lt;code&gt;std::c16rtomb(buf, u'\0', ps)&lt;/code&gt; for some internal buffer &lt;code&gt;buf&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;s&lt;/code&gt; является нулевым указателем, вызов эквивалентен &lt;code&gt;std::c16rtomb(buf, u'\0', ps)&lt;/code&gt; для некоторого внутреннего буфера &lt;code&gt;buf&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9b425a38a00e233a7e79446325b7bf9c1fc117a3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;s&lt;/code&gt; is a null pointer, the call is equivalent to &lt;code&gt;std::c32rtomb(buf, U'\0', ps)&lt;/code&gt; for some internal buffer &lt;code&gt;buf&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;s&lt;/code&gt; является нулевым указателем, вызов эквивалентен &lt;code&gt;std::c32rtomb(buf, U'\0', ps)&lt;/code&gt; для некоторого внутреннего буфера &lt;code&gt;buf&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ed35e82d64bb46cbad184112b5af458797318975" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;s&lt;/code&gt; is a null pointer, the call is equivalent to &lt;code&gt;std::c8rtomb(buf, u8'\0', ps)&lt;/code&gt; for some internal buffer &lt;code&gt;buf&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;s&lt;/code&gt; является нулевым указателем, вызов эквивалентен &lt;code&gt;std::c8rtomb(buf, u8'\0', ps)&lt;/code&gt; для некоторого внутреннего буфера &lt;code&gt;buf&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="12e013f90ae32cdb16251d5b6510a8d8d5565aed" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;s&lt;/code&gt; is a null pointer, the call is equivalent to &lt;code&gt;std::wcrtomb(buf, L'\0', ps)&lt;/code&gt; for some internal buffer &lt;code&gt;buf&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;s&lt;/code&gt; является нулевым указателем, вызов эквивалентен &lt;code&gt;std::wcrtomb(buf, L'\0', ps)&lt;/code&gt; для некоторого внутреннего буфера &lt;code&gt;buf&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b0c98fdcb47a8abb41d844fc8c53f32413a8247d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;s&lt;/code&gt; is a null pointer, the values of &lt;code&gt;n&lt;/code&gt; and &lt;code&gt;pc16&lt;/code&gt; are ignored and the call is equivalent to &lt;code&gt;std::mbrtoc16(&lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;, &quot;&quot;, 1, ps)&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;s&lt;/code&gt; является нулевым указателем, значения &lt;code&gt;n&lt;/code&gt; и &lt;code&gt;pc16&lt;/code&gt; игнорируются, и вызов эквивалентен &lt;code&gt;std::mbrtoc16(&lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;, &quot;&quot;, 1, ps)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f441bdad904ce2a3ae27b238bbd76507e2b519da" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;s&lt;/code&gt; is a null pointer, the values of &lt;code&gt;n&lt;/code&gt; and &lt;code&gt;pc32&lt;/code&gt; are ignored and the call is equivalent to &lt;code&gt;std::mbrtoc32(&lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;, &quot;&quot;, 1, ps)&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;s&lt;/code&gt; является нулевым указателем, значения &lt;code&gt;n&lt;/code&gt; и &lt;code&gt;pc32&lt;/code&gt; игнорируются, и вызов эквивалентен &lt;code&gt;std::mbrtoc32(&lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;, &quot;&quot;, 1, ps)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="92f917820ffd997e9b4bad50e8a1e2f43abff234" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;s&lt;/code&gt; is a null pointer, the values of &lt;code&gt;n&lt;/code&gt; and &lt;code&gt;pc8&lt;/code&gt; are ignored and the call is equivalent to &lt;code&gt;std::mbrtoc8(&lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;, &quot;&quot;, 1, ps)&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;s&lt;/code&gt; является нулевым указателем, значения &lt;code&gt;n&lt;/code&gt; и &lt;code&gt;pc8&lt;/code&gt; игнорируются, и вызов эквивалентен &lt;code&gt;std::mbrtoc8(&lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;, &quot;&quot;, 1, ps)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="002e16b0a8a0300cebc1bd2022bc72e0016d413f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;s&lt;/code&gt; is a null pointer, the values of &lt;code&gt;n&lt;/code&gt; and &lt;code&gt;pwc&lt;/code&gt; are ignored and call is equivalent to &lt;code&gt;std::mbrtowc(&lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;, &quot;&quot;, 1, ps)&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;s&lt;/code&gt; - нулевой указатель, значения &lt;code&gt;n&lt;/code&gt; и &lt;code&gt;pwc&lt;/code&gt; игнорируются, а вызов эквивалентен &lt;code&gt;std::mbrtowc(&lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;, &quot;&quot;, 1, ps)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="387220b12d5b9da678e75cc38f39c0d62fd87341" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;s&lt;/code&gt; is not a null pointer and &lt;code&gt;c16&lt;/code&gt; is the last 16-bit code unit in a valid variable-length encoding of a code point, the function determines the number of bytes necessary to store the multibyte character representation of that code point (including any shift sequences, and taking into account the current multibyte conversion state &lt;code&gt;*ps&lt;/code&gt;), and stores the multibyte character representation in the character array whose first element is pointed to by &lt;code&gt;s&lt;/code&gt;, updating &lt;code&gt;*ps&lt;/code&gt; as necessary. At most &lt;code&gt;MB_CUR_MAX&lt;/code&gt; bytes can be written by this function.</source>
          <target state="translated">Если &lt;code&gt;s&lt;/code&gt; не является нулевым указателем, а &lt;code&gt;c16&lt;/code&gt; является последней 16-битной кодовой единицей в допустимом кодировании с переменной длиной кодовой точки, функция определяет число байтов, необходимое для хранения многобайтового символьного представления этой кодовой точки (включая любые сдвиг последовательностей и с учетом текущего состояния многобайтового преобразования &lt;code&gt;*ps&lt;/code&gt; ) и сохраняет представление многобайтовых символов в массиве символов, на первый элемент которого указывает &lt;code&gt;s&lt;/code&gt; , при необходимости обновляя &lt;code&gt;*ps&lt;/code&gt; . В большинстве &lt;code&gt;MB_CUR_MAX&lt;/code&gt; байт можно записать с помощью этой функции.</target>
        </trans-unit>
        <trans-unit id="8e98391f16286d01eda72c77dda336407bf1f401" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;s&lt;/code&gt; is not a null pointer and &lt;code&gt;c8&lt;/code&gt; is the last code unit in a valid UTF-8 encoding of a code point, the function determines the number of bytes necessary to store the multibyte character representation of that code point (including any shift sequences, and taking into account the current multibyte conversion state &lt;code&gt;*ps&lt;/code&gt;), and stores the multibyte character representation in the character array whose first element is pointed to by &lt;code&gt;s&lt;/code&gt;, updating &lt;code&gt;*ps&lt;/code&gt; as necessary. At most &lt;code&gt;MB_CUR_MAX&lt;/code&gt; bytes can be written by this function.</source>
          <target state="translated">Если &lt;code&gt;s&lt;/code&gt; не является нулевым указателем и &lt;code&gt;c8&lt;/code&gt; является последней единицей кода в допустимом кодировании UTF-8 кодовой точки, функция определяет количество байтов, необходимое для хранения многобайтового символьного представления этой кодовой точки (включая любые последовательности сдвига, и принимая во внимание текущее состояние многобайтового преобразования &lt;code&gt;*ps&lt;/code&gt; ), и сохраняет представление многобайтовых символов в массиве символов, на первый элемент которого указывает &lt;code&gt;s&lt;/code&gt; , при необходимости обновляя &lt;code&gt;*ps&lt;/code&gt; . В большинстве &lt;code&gt;MB_CUR_MAX&lt;/code&gt; байт можно записать с помощью этой функции.</target>
        </trans-unit>
        <trans-unit id="efeff6f4bae9dbe7dacca63bdafb8df5873ba5a0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;s&lt;/code&gt; is not a null pointer, inspects at most &lt;code&gt;n&lt;/code&gt; bytes of the multibyte character string, beginning with the byte pointed to by &lt;code&gt;s&lt;/code&gt; to determine the number of bytes necessary to complete the next multibyte character (including any shift sequences). If the function determines that the next multibyte character in &lt;code&gt;s&lt;/code&gt; is complete and valid, converts it to UTF-8 and stores the first UTf-8 code unit in &lt;code&gt;*pc8&lt;/code&gt; (if &lt;code&gt;pc8&lt;/code&gt; is not null).</source>
          <target state="translated">Если &lt;code&gt;s&lt;/code&gt; не является нулевым указателем, проверяет не более &lt;code&gt;n&lt;/code&gt; байтов многобайтовой символьной строки, начиная с байта, на который указывает &lt;code&gt;s&lt;/code&gt; , чтобы определить количество байтов, необходимое для завершения следующего многобайтового символа (включая любые последовательности сдвига). Если функция определяет, что следующий многобайтовый символ в &lt;code&gt;s&lt;/code&gt; является полным и действительным, преобразует его в UTF-8 и сохраняет первую кодовую единицу UTf-8 в &lt;code&gt;*pc8&lt;/code&gt; (если &lt;code&gt;pc8&lt;/code&gt; не ноль ).</target>
        </trans-unit>
        <trans-unit id="66571e29e3face4617295ef95324bcdf8412d045" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;s&lt;/code&gt; is not a null pointer, inspects at most &lt;code&gt;n&lt;/code&gt; bytes of the multibyte character string, beginning with the byte pointed to by &lt;code&gt;s&lt;/code&gt; to determine the number of bytes necessary to complete the next multibyte character (including any shift sequences). If the function determines that the next multibyte character in &lt;code&gt;s&lt;/code&gt; is complete and valid, converts it to the corresponding 16-bit character and stores it in &lt;code&gt;*pc16&lt;/code&gt; (if &lt;code&gt;pc16&lt;/code&gt; is not null).</source>
          <target state="translated">Если &lt;code&gt;s&lt;/code&gt; не является нулевым указателем, проверяет не более &lt;code&gt;n&lt;/code&gt; байтов многобайтовой символьной строки, начиная с байта, на который указывает &lt;code&gt;s&lt;/code&gt; , чтобы определить количество байтов, необходимое для завершения следующего многобайтового символа (включая любые последовательности сдвига). Если функция определяет, что следующий многобайтовый символ в &lt;code&gt;s&lt;/code&gt; является полным и допустимым, преобразует его в соответствующий 16-разрядный символ и сохраняет его в &lt;code&gt;*pc16&lt;/code&gt; (если &lt;code&gt;pc16&lt;/code&gt; не равен нулю).</target>
        </trans-unit>
        <trans-unit id="e34686814ade46fa92cd32a9d644e0c7a90c8094" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;s&lt;/code&gt; is not a null pointer, inspects at most &lt;code&gt;n&lt;/code&gt; bytes of the multibyte character string, beginning with the byte pointed to by &lt;code&gt;s&lt;/code&gt; to determine the number of bytes necessary to complete the next multibyte character (including any shift sequences). If the function determines that the next multibyte character in &lt;code&gt;s&lt;/code&gt; is complete and valid, converts it to the corresponding 32-bit character and stores it in &lt;code&gt;*pc32&lt;/code&gt; (if &lt;code&gt;pc32&lt;/code&gt; is not null).</source>
          <target state="translated">Если &lt;code&gt;s&lt;/code&gt; не является нулевым указателем, проверяет не более &lt;code&gt;n&lt;/code&gt; байтов многобайтовой символьной строки, начиная с байта, на который указывает &lt;code&gt;s&lt;/code&gt; , чтобы определить количество байтов, необходимое для завершения следующего многобайтового символа (включая любые последовательности сдвига). Если функция определяет, что следующий многобайтовый символ в &lt;code&gt;s&lt;/code&gt; является полным и допустимым, преобразует его в соответствующий 32-разрядный символ и сохраняет его в &lt;code&gt;*pc32&lt;/code&gt; (если &lt;code&gt;pc32&lt;/code&gt; не равен нулю).</target>
        </trans-unit>
        <trans-unit id="2038e0d252e5f18478ed819b27d31e3681ca48d6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;s&lt;/code&gt; is not a null pointer, inspects at most &lt;code&gt;n&lt;/code&gt; bytes of the multibyte character string, beginning with the byte pointed to by &lt;code&gt;s&lt;/code&gt; to determine the number of bytes necessary to complete the next multibyte character (including any shift sequences). If the function determines that the next multibyte character in &lt;code&gt;s&lt;/code&gt; is complete and valid, converts it to the corresponding wide character and stores it in &lt;code&gt;*pwc&lt;/code&gt; (if &lt;code&gt;pwc&lt;/code&gt; is not null).</source>
          <target state="translated">Если &lt;code&gt;s&lt;/code&gt; не является нулевым указателем, он проверяет не более &lt;code&gt;n&lt;/code&gt; байтов строки многобайтовых символов, начиная с байта, на который указывает &lt;code&gt;s&lt;/code&gt; , чтобы определить количество байтов, необходимое для завершения следующего многобайтового символа (включая любые последовательности сдвига). Если функция определяет, что следующий многобайтовый символ в &lt;code&gt;s&lt;/code&gt; является полным и допустимым, преобразует его в соответствующий широкий символ и сохраняет его в &lt;code&gt;*pwc&lt;/code&gt; (если &lt;code&gt;pwc&lt;/code&gt; не равен нулю).</target>
        </trans-unit>
        <trans-unit id="6f4c68687ec93f7e26b9a23cfefd0d3cb05dc64c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;s&lt;/code&gt; is not a null pointer, returns the number of bytes that are contained in the multibyte character or &lt;code&gt;-1&lt;/code&gt; if the first bytes pointed to by &lt;code&gt;s&lt;/code&gt; do not form a valid multibyte character or &lt;code&gt;​0​&lt;/code&gt; if &lt;code&gt;s&lt;/code&gt; is pointing at the null charcter &lt;code&gt;'\0'&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;s&lt;/code&gt; не является указателем NULL, возвращает количество байтов, которые содержатся в многобайтовый или &lt;code&gt;-1&lt;/code&gt; , если первый байт указывает &lt;code&gt;s&lt;/code&gt; не образуют допустимый символ многобайтовую или &lt;code&gt;​0​&lt;/code&gt; , если &lt;code&gt;s&lt;/code&gt; указывает на нулевой charcter &lt;code&gt;'\0'&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9f76e4a5183e8ca08cf45c471464ea38bd49564a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;s&lt;/code&gt; is not a null pointer, returns the number of bytes that are contained in the multibyte representation of &lt;code&gt;wc&lt;/code&gt; or &lt;code&gt;-1&lt;/code&gt; if &lt;code&gt;wc&lt;/code&gt; is not a valid character.</source>
          <target state="translated">Если &lt;code&gt;s&lt;/code&gt; не является нулевым указателем, возвращает количество байтов, которые содержатся в многобайтовом представлении &lt;code&gt;wc&lt;/code&gt; или &lt;code&gt;-1&lt;/code&gt; , если &lt;code&gt;wc&lt;/code&gt; не является допустимым символом.</target>
        </trans-unit>
        <trans-unit id="6d6df3a6410ecce9d2acc8ffd84bf56f540ac991" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;s&lt;/code&gt; is not a null pointer, the function determines the number of bytes necessary to store the multibyte character representation of &lt;code&gt;c32&lt;/code&gt; (including any shift sequences, and taking into account the current multibyte conversion state &lt;code&gt;*ps&lt;/code&gt;), and stores the multibyte character representation in the character array whose first element is pointed to by &lt;code&gt;s&lt;/code&gt;, updating &lt;code&gt;*ps&lt;/code&gt; as necessary. At most &lt;code&gt;MB_CUR_MAX&lt;/code&gt; bytes can be written by this function.</source>
          <target state="translated">Если &lt;code&gt;s&lt;/code&gt; не является нулевым указателем, функция определяет количество байтов, необходимое для хранения многобайтового символьного представления &lt;code&gt;c32&lt;/code&gt; (включая любые последовательности сдвига и с учетом текущего состояния многобайтового преобразования &lt;code&gt;*ps&lt;/code&gt; ), и сохраняет многобайтовое символьное представление в массив символов, на первый элемент которого указывает &lt;code&gt;s&lt;/code&gt; , при необходимости обновляя &lt;code&gt;*ps&lt;/code&gt; . В большинстве &lt;code&gt;MB_CUR_MAX&lt;/code&gt; байт можно записать с помощью этой функции.</target>
        </trans-unit>
        <trans-unit id="a9d1c6974b8b676a8501a6cacc05cdd5f413866d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;s&lt;/code&gt; is not a null pointer, the function determines the number of bytes necessary to store the multibyte character representation of &lt;code&gt;wc&lt;/code&gt; (including any shift sequences, and taking into account the current multibyte conversion state &lt;code&gt;*ps&lt;/code&gt;), and stores the multibyte character representation in the character array whose first element is pointed to by &lt;code&gt;s&lt;/code&gt;, updating &lt;code&gt;*ps&lt;/code&gt; as necessary. At most &lt;code&gt;MB_CUR_MAX&lt;/code&gt; bytes can be written by this function.</source>
          <target state="translated">Если &lt;code&gt;s&lt;/code&gt; не является нулевым указателем, функция определяет количество байтов, необходимое для хранения многобайтового символьного представления &lt;code&gt;wc&lt;/code&gt; (включая любые последовательности сдвига и принимая во внимание текущее состояние многобайтового преобразования &lt;code&gt;*ps&lt;/code&gt; ), и сохраняет многобайтовое символьное представление в массив символов, на первый элемент которого указывает &lt;code&gt;s&lt;/code&gt; , при необходимости обновляя &lt;code&gt;*ps&lt;/code&gt; . В большинстве &lt;code&gt;MB_CUR_MAX&lt;/code&gt; байт можно записать с помощью этой функции.</target>
        </trans-unit>
        <trans-unit id="7823afdead8eb41af529747e83ce1e0afbe2e6fb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;setjmp&lt;/code&gt; appears in any other context, the behavior is undefined.</source>
          <target state="translated">Если &lt;code&gt;setjmp&lt;/code&gt; появляется в любом другом контексте, поведение не определено.</target>
        </trans-unit>
        <trans-unit id="4c03a05548ddb96f3438cfeabf552db044243a9a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;showbase&lt;/code&gt; flag is set in &lt;code&gt;str.flags()&lt;/code&gt;, the currency symbol or currency string is required, if it is not set, the currency symbol is optional.</source>
          <target state="translated">Если &lt;code&gt;showbase&lt;/code&gt; флаг установлен в &lt;code&gt;str.flags()&lt;/code&gt; , символ валюты или валюты строка требуется, если он не установлен, символ валюты не является обязательным.</target>
        </trans-unit>
        <trans-unit id="8969128c7f7485e9cafa97fcadad06ea89f50051" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;size()&lt;/code&gt; is 0, &lt;code&gt;data()&lt;/code&gt; may or may not return a null pointer.</source>
          <target state="translated">Если &lt;code&gt;size()&lt;/code&gt; равен 0, &lt;code&gt;data()&lt;/code&gt; может возвращать или не возвращать нулевой указатель.</target>
        </trans-unit>
        <trans-unit id="5a6ee964cf02ec47b4f466324fac4fa5368b4c54" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;size&lt;/code&gt; is zero, the behavior is implementation defined (null pointer may be returned, or some non-null pointer may be returned that may not be used to access storage).</source>
          <target state="translated">Если &lt;code&gt;size&lt;/code&gt; равен нулю, поведение определяется реализацией (может быть возвращен нулевой указатель или может быть возвращен некоторый ненулевой указатель, который не может использоваться для доступа к хранилищу).</target>
        </trans-unit>
        <trans-unit id="4de52063dd761a69f5fec3a1f793d8ab34506b00" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;size&lt;/code&gt; is zero, the behavior is implementation defined (null pointer may be returned, or some non-null pointer may be returned that may not be used to access storage, but has to be passed to &lt;code&gt;&lt;a href=&quot;free&quot;&gt;std::free&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">Если &lt;code&gt;size&lt;/code&gt; равен нулю, поведение определяется реализацией (может быть возвращен нулевой указатель или может быть возвращен некоторый ненулевой указатель, который не может быть использован для доступа к хранилищу, но должен быть передан в &lt;code&gt;&lt;a href=&quot;free&quot;&gt;std::free&lt;/a&gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="fece348a8ee3d70f7e3352f3e69bf03a082365cd" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;size&lt;/code&gt; or &lt;code&gt;count&lt;/code&gt; is zero, &lt;code&gt;fread&lt;/code&gt; returns zero and performs no other action.</source>
          <target state="translated">Если &lt;code&gt;size&lt;/code&gt; или &lt;code&gt;count&lt;/code&gt; равен нулю, &lt;code&gt;fread&lt;/code&gt; возвращает ноль и не выполняет никаких других действий.</target>
        </trans-unit>
        <trans-unit id="a444353fd5b9d3848488fa96c9629f1e576c66a5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;size&lt;/code&gt; or &lt;code&gt;count&lt;/code&gt; is zero, &lt;code&gt;fwrite&lt;/code&gt; returns zero and performs no other action.</source>
          <target state="translated">Если &lt;code&gt;size&lt;/code&gt; или &lt;code&gt;count&lt;/code&gt; равен нулю, &lt;code&gt;fwrite&lt;/code&gt; возвращает ноль и не выполняет никаких других действий.</target>
        </trans-unit>
        <trans-unit id="62c0f8b2707422825d3dfec002ee726a9c2cbd66" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;sizeof...(InnerAllocs) == 0&lt;/code&gt;, that is, no inner allocators were declared, returns &lt;code&gt;*this&lt;/code&gt;. Otherwise returns a reference to &lt;code&gt;&lt;a href=&quot;../scoped_allocator_adaptor&quot;&gt;std::scoped_allocator_adaptor&lt;/a&gt;&amp;lt;InnerAllocs...&amp;gt;&lt;/code&gt;, that is, a scoped allocator composed of all inner allocators of &lt;code&gt;*this&lt;/code&gt;, with the first inner allocator becoming the outer allocator.</source>
          <target state="translated">Если &lt;code&gt;sizeof...(InnerAllocs) == 0&lt;/code&gt; , то есть внутренние распределители не были объявлены, возвращает &lt;code&gt;*this&lt;/code&gt; . В противном случае возвращает ссылку на &lt;code&gt;&lt;a href=&quot;../scoped_allocator_adaptor&quot;&gt;std::scoped_allocator_adaptor&lt;/a&gt;&amp;lt;InnerAllocs...&amp;gt;&lt;/code&gt; , то есть распределитель области действия, состоящий из всех внутренних распределителей &lt;code&gt;*this&lt;/code&gt; , причем первый внутренний распределитель становится внешним распределителем.</target>
        </trans-unit>
        <trans-unit id="791ac1fc4772ec7b51395220b898af37695b4777" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;sizeof...(T)&lt;/code&gt; is greater than two (i.e., &lt;code&gt;T...&lt;/code&gt; consists of the types &lt;code&gt;T1, T2, R...&lt;/code&gt;), then if &lt;code&gt;std::common_reference_t&amp;lt;T1, T2&amp;gt;&lt;/code&gt; exists, the member &lt;code&gt;type&lt;/code&gt; denotes &lt;code&gt;std::common_reference_t&amp;lt;std::common_reference_t&amp;lt;T1, T2&amp;gt;, R...&amp;gt;&lt;/code&gt; if such a type exists. In all other cases, there is no member &lt;code&gt;type&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;sizeof...(T)&lt;/code&gt; больше двух (т. &lt;code&gt;std::common_reference_t&amp;lt;T1, T2&amp;gt;&lt;/code&gt; &lt;code&gt;T...&lt;/code&gt; состоит из типов &lt;code&gt;T1, T2, R...&lt;/code&gt; ), то если существует std :: common_reference_t &amp;lt;T1, T2&amp;gt; , &lt;code&gt;type&lt;/code&gt; элемента обозначает &lt;code&gt;std::common_reference_t&amp;lt;std::common_reference_t&amp;lt;T1, T2&amp;gt;, R...&amp;gt;&lt;/code&gt; если такой тип существует. Во всех остальных случаях &lt;code&gt;type&lt;/code&gt; члена отсутствует .</target>
        </trans-unit>
        <trans-unit id="ecc26feb6c4b2ae80a7529b5d61cf9ff7a5b097b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;sizeof...(T)&lt;/code&gt; is greater than two (i.e., &lt;code&gt;T...&lt;/code&gt; consists of the types &lt;code&gt;T1, T2, R...&lt;/code&gt;), then if &lt;code&gt;std::common_type&amp;lt;T1, T2&amp;gt;::type&lt;/code&gt; exists, the member &lt;code&gt;type&lt;/code&gt; denotes &lt;code&gt;std::common_type&amp;lt;std::common_type&amp;lt;T1, T2&amp;gt;::type, R...&amp;gt;::type&lt;/code&gt; if such a type exists. In all other cases, there is no member &lt;code&gt;type&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;sizeof...(T)&lt;/code&gt; больше двух (т. &lt;code&gt;std::common_type&amp;lt;T1, T2&amp;gt;::type&lt;/code&gt; &lt;code&gt;T...&lt;/code&gt; состоит из типов &lt;code&gt;T1, T2, R...&lt;/code&gt; ), то если существует std :: common_type &amp;lt;T1, T2&amp;gt; :: type , &lt;code&gt;type&lt;/code&gt; члена обозначает &lt;code&gt;std::common_type&amp;lt;std::common_type&amp;lt;T1, T2&amp;gt;::type, R...&amp;gt;::type&lt;/code&gt; если такой тип существует. Во всех остальных случаях &lt;code&gt;type&lt;/code&gt; члена отсутствует .</target>
        </trans-unit>
        <trans-unit id="78448ef5ca9bbafc2986882ac92ff12c158a9374" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;sizeof...(T)&lt;/code&gt; is one (i.e., &lt;code&gt;T...&lt;/code&gt; contains only one type &lt;code&gt;T0&lt;/code&gt;), the member &lt;code&gt;type&lt;/code&gt; names the same type as &lt;code&gt;T0&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;sizeof...(T)&lt;/code&gt; равен единице (т. Е. &lt;code&gt;T...&lt;/code&gt; содержит только один тип &lt;code&gt;T0&lt;/code&gt; ), &lt;code&gt;type&lt;/code&gt; члена именует тот же тип, что и &lt;code&gt;T0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b493ffdbed7ccd8ccc482ba14060e9c250b436b3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;sizeof...(T)&lt;/code&gt; is one (i.e., &lt;code&gt;T...&lt;/code&gt; contains only one type &lt;code&gt;T0&lt;/code&gt;), the member &lt;code&gt;type&lt;/code&gt; names the same type as &lt;code&gt;std::common_type&amp;lt;T0, T0&amp;gt;::type&lt;/code&gt; if it exists; otherwise there is no member &lt;code&gt;type&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;sizeof...(T)&lt;/code&gt; равен единице (т. &lt;code&gt;std::common_type&amp;lt;T0, T0&amp;gt;::type&lt;/code&gt; &lt;code&gt;T...&lt;/code&gt; содержит только один тип &lt;code&gt;T0&lt;/code&gt; ), &lt;code&gt;type&lt;/code&gt; члена именует тот же тип, что и std :: common_type &amp;lt;T0, T0&amp;gt; :: type, если он существует; в противном случае нет &lt;code&gt;type&lt;/code&gt; члена .</target>
        </trans-unit>
        <trans-unit id="05312f022c61c0809a5b4f6761df43d1433c8e8b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;sizeof...(T)&lt;/code&gt; is two (i.e., &lt;code&gt;T...&lt;/code&gt; contains exactly two types &lt;code&gt;T1&lt;/code&gt; and &lt;code&gt;T2&lt;/code&gt;),</source>
          <target state="translated">Если &lt;code&gt;sizeof...(T)&lt;/code&gt; равен двум (т. Е. &lt;code&gt;T...&lt;/code&gt; содержит ровно два типа &lt;code&gt;T1&lt;/code&gt; и &lt;code&gt;T2&lt;/code&gt; ),</target>
        </trans-unit>
        <trans-unit id="a9203e749bb438b9fb18b3027d7cd1938fde1b9e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;sizeof...(T)&lt;/code&gt; is two (i.e., &lt;code&gt;T...&lt;/code&gt; contains two types &lt;code&gt;T1&lt;/code&gt; and &lt;code&gt;T2&lt;/code&gt;):</source>
          <target state="translated">Если &lt;code&gt;sizeof...(T)&lt;/code&gt; равен двум (т. Е. &lt;code&gt;T...&lt;/code&gt; содержит два типа &lt;code&gt;T1&lt;/code&gt; и &lt;code&gt;T2&lt;/code&gt; ):</target>
        </trans-unit>
        <trans-unit id="003d0981a91b043f4c661755c19594dc3f2d5e31" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;sizeof...(T)&lt;/code&gt; is zero, there is no member &lt;code&gt;type&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;sizeof...(T)&lt;/code&gt; равен нулю, &lt;code&gt;type&lt;/code&gt; члена отсутствует .</target>
        </trans-unit>
        <trans-unit id="6e9a3b7bb26a60d38196ba47db1b4041c4e0a434" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;sizeof...(Types) == 0&lt;/code&gt; or if any of the types in &lt;code&gt;Types&lt;/code&gt; is not a complete object type, the behavior is undefined.</source>
          <target state="translated">Если &lt;code&gt;sizeof...(Types) == 0&lt;/code&gt; или любой из типов в &lt;code&gt;Types&lt;/code&gt; не является полным типом объекта, поведение не определено.</target>
        </trans-unit>
        <trans-unit id="4072b39e3de9b56d51b28e74e4a293634d9f7558" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;sp&lt;/code&gt; was not obtained by calling &lt;code&gt;&lt;a href=&quot;../basic_streambuf/pubseekoff&quot;&gt;seekoff()&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;seekpos()&lt;/code&gt; on the same file, the behavior is undefined.</source>
          <target state="translated">Если &lt;code&gt;sp&lt;/code&gt; не был получен вызовом &lt;code&gt;&lt;a href=&quot;../basic_streambuf/pubseekoff&quot;&gt;seekoff()&lt;/a&gt;&lt;/code&gt; или &lt;code&gt;seekpos()&lt;/code&gt; для того же файла, поведение не определено.</target>
        </trans-unit>
        <trans-unit id="546524cf93679255723e493223804c25db718c37" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;std::abs&lt;/code&gt; is called with an argument of type &lt;code&gt;X&lt;/code&gt; such that &lt;code&gt;&lt;a href=&quot;../../types/is_unsigned&quot;&gt;std::is_unsigned&lt;/a&gt;&amp;lt;X&amp;gt;::value&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; and &lt;code&gt;X&lt;/code&gt; cannot be converted to &lt;code&gt;int&lt;/code&gt; by &lt;a href=&quot;../../language/implicit_cast#Integral_promotion&quot;&gt;integral promotion&lt;/a&gt;, the program is ill-formed.</source>
          <target state="translated">Если &lt;code&gt;std::abs&lt;/code&gt; вызывается с аргументом типа &lt;code&gt;X&lt;/code&gt; , таким образом, что &lt;code&gt;&lt;a href=&quot;../../types/is_unsigned&quot;&gt;std::is_unsigned&lt;/a&gt;&amp;lt;X&amp;gt;::value&lt;/code&gt; имеет значение &lt;code&gt;true&lt;/code&gt; , и &lt;code&gt;X&lt;/code&gt; не может быть преобразован в &lt;code&gt;int&lt;/code&gt; путем &lt;a href=&quot;../../language/implicit_cast#Integral_promotion&quot;&gt;интегрального продвижения&lt;/a&gt; , программа является некорректной.</target>
        </trans-unit>
        <trans-unit id="feba3c26477487c1b1931e01bd15bdc0fb928819" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;std::atomic&amp;lt;T&amp;gt;&lt;/code&gt; has no &lt;code&gt;fetch_and&lt;/code&gt; member (this member is only provided for &lt;a href=&quot;atomic#Specializations_for_integral_types&quot;&gt;integral types&lt;/a&gt;), the program is ill-formed.</source>
          <target state="translated">Если &lt;code&gt;std::atomic&amp;lt;T&amp;gt;&lt;/code&gt; не имеет &lt;code&gt;fetch_and&lt;/code&gt; (этот элемент предоставляется только для &lt;a href=&quot;atomic#Specializations_for_integral_types&quot;&gt;целочисленных типов&lt;/a&gt; ), программа некорректна.</target>
        </trans-unit>
        <trans-unit id="88a445f32dd035df709cb7b01fefe9115a63d211" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;std::atomic&amp;lt;T&amp;gt;&lt;/code&gt; has no &lt;code&gt;fetch_xor&lt;/code&gt; member (this member is only provided for &lt;a href=&quot;atomic#Specializations_for_integral_types&quot;&gt;integral types&lt;/a&gt;), the program is ill-formed.</source>
          <target state="translated">Если &lt;code&gt;std::atomic&amp;lt;T&amp;gt;&lt;/code&gt; не имеет члена &lt;code&gt;fetch_xor&lt;/code&gt; (этот элемент предоставляется только для &lt;a href=&quot;atomic#Specializations_for_integral_types&quot;&gt;целочисленных типов&lt;/a&gt; ), программа некорректна.</target>
        </trans-unit>
        <trans-unit id="def722711403d134b11c7d54af7e5b4d9abce392" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;std::consume_header&lt;/code&gt; is not selected when reading a file beginning with byte order mark, the Unicode character U+FEFF (Zero width non-breaking space) will be read as the first character of the string content.</source>
          <target state="translated">Если при чтении файла, начинающегося с метки порядка байтов, не выбран &lt;code&gt;std::consume_header&lt;/code&gt; , символ Unicode U + FEFF (неразрывный пробел нулевой ширины) будет считываться первым символом содержимого строки.</target>
        </trans-unit>
        <trans-unit id="d3cb249ea0f28d0b2a75ca2a7f403cf2a7474c16" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;std::iterator_traits&amp;lt;Iter&amp;gt;::reference&lt;/code&gt; is a reference, this is the rvalue reference version of the same type. Otherwise (such as if the wrapped iterator returns by value), this is &lt;code&gt;std::iterator_traits&amp;lt;Iter&amp;gt;::reference&lt;/code&gt; unchanged</source>
          <target state="translated">Если &lt;code&gt;std::iterator_traits&amp;lt;Iter&amp;gt;::reference&lt;/code&gt; является ссылкой, это rvalue ссылочная версия того же типа. В противном случае (например, если завернутый итератор возвращается по значению), это &lt;code&gt;std::iterator_traits&amp;lt;Iter&amp;gt;::reference&lt;/code&gt; без изменений</target>
        </trans-unit>
        <trans-unit id="949f1f6e0f15336724ef8f4cda94b4e5b055d867" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;str != &lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt;, the call is treated as the first call to &lt;code&gt;std::wcstok&lt;/code&gt; for this particular wide string. The function searches for the first wide character which is</source>
          <target state="translated">Если &lt;code&gt;str != &lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt; , вызов обрабатывается как первый вызов &lt;code&gt;std::wcstok&lt;/code&gt; для этой конкретной широкой строки. Функция ищет первый широкий символ, который</target>
        </trans-unit>
        <trans-unit id="919d8cd3a8b53f2e18bf07280d97eede84dc299d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;str != &lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt;, the call is treated as the first call to &lt;code&gt;strtok&lt;/code&gt; for this particular string. The function searches for the first character which is</source>
          <target state="translated">Если &lt;code&gt;str != &lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt; , вызов обрабатывается как первый вызов &lt;code&gt;strtok&lt;/code&gt; для этой конкретной строки. Функция ищет первый символ, который</target>
        </trans-unit>
        <trans-unit id="98634ae53f4036b3363ce6cbf8811e0fd64f6b0f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;str == &lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt;, the call is treated as a subsequent calls to &lt;code&gt;std::wcstok&lt;/code&gt;: the function continues from where it left in previous invocation with the same &lt;code&gt;*ptr&lt;/code&gt;. The behavior is the same as if the pointer to the wide character that follows the last detected token is passed as &lt;code&gt;str&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;str == &lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt; , вызов обрабатывается как последующие вызовы &lt;code&gt;std::wcstok&lt;/code&gt; : функция продолжается с того места, где она ушла в предыдущем вызове с тем же &lt;code&gt;*ptr&lt;/code&gt; . Поведение такое же, как если бы указатель на широкий символ, который следует за последним обнаруженным токеном, передается как &lt;code&gt;str&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="66ec70311bf6aedd6bdb60bbe9f819c870804830" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;str == &lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt;, the call is treated as a subsequent calls to &lt;code&gt;strtok&lt;/code&gt;: the function continues from where it left in previous invocation. The behavior is the same as if the previously stored pointer is passed as &lt;code&gt;str&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;str == &lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt; , вызов обрабатывается как последующие вызовы &lt;code&gt;strtok&lt;/code&gt; : функция продолжается с того места, где она ушла в предыдущем вызове. Поведение такое же, как если бы ранее сохраненный указатель был передан как &lt;code&gt;str&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0f00ca1c926f1dd5787b11275ecdbddb1666242a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;str.flags() &amp;amp; str.adjustfield&lt;/code&gt; equals &lt;code&gt;str.internal&lt;/code&gt;, the fill characters are inserted where &lt;code&gt;none&lt;/code&gt; or &lt;code&gt;space&lt;/code&gt; appears in the formatting pattern.</source>
          <target state="translated">Если &lt;code&gt;str.flags() &amp;amp; str.adjustfield&lt;/code&gt; равна &lt;code&gt;str.internal&lt;/code&gt; , символы заполнения вставляются , где &lt;code&gt;none&lt;/code&gt; или &lt;code&gt;space&lt;/code&gt; появляется в шаблон форматирования.</target>
        </trans-unit>
        <trans-unit id="1fa5ee33bcecc47b8c59730282fe17b184cd0916" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;str.flags() &amp;amp; str.showbase&lt;/code&gt; is non-zero (the &lt;code&gt;&lt;a href=&quot;../../io/manip/showbase&quot;&gt;std::showbase&lt;/a&gt;&lt;/code&gt; manipulator was used), then the currency symbol or string is generated by calling &lt;code&gt;mp.curr_symbol()&lt;/code&gt; and placed in the output sequence where &lt;code&gt;&lt;a href=&quot;../money_base&quot;&gt;symbol&lt;/a&gt;&lt;/code&gt; appears in the formatting pattern.</source>
          <target state="translated">Если &lt;code&gt;str.flags() &amp;amp; str.showbase&lt;/code&gt; не равен нулю (использовался манипулятор &lt;code&gt;&lt;a href=&quot;../../io/manip/showbase&quot;&gt;std::showbase&lt;/a&gt;&lt;/code&gt; ), то символ валюты или строка генерируется путем вызова &lt;code&gt;mp.curr_symbol()&lt;/code&gt; и помещается в выходную последовательность, где &lt;code&gt;&lt;a href=&quot;../money_base&quot;&gt;symbol&lt;/a&gt;&lt;/code&gt; появляется в шаблон форматирования.</target>
        </trans-unit>
        <trans-unit id="1f05ec444fc20459f458416318c1d398ea88ac26" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;str.width()&lt;/code&gt; is non-zero (e.g. &lt;code&gt;&lt;a href=&quot;../../io/manip/setw&quot;&gt;std::setw&lt;/a&gt;&lt;/code&gt; was just used) and the number of CharT's after Stage 2 is less than &lt;code&gt;str.width()&lt;/code&gt;, then copies of the &lt;code&gt;fill&lt;/code&gt; character are inserted at the position indicated by padding to bring the length of the sequence to &lt;code&gt;str.width()&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;str.width()&lt;/code&gt; не равен нулю (например, только что использовался &lt;code&gt;&lt;a href=&quot;../../io/manip/setw&quot;&gt;std::setw&lt;/a&gt;&lt;/code&gt; ), а число CharT после этапа 2 меньше, чем &lt;code&gt;str.width()&lt;/code&gt; , тогда копии символа &lt;code&gt;fill&lt;/code&gt; вставляются в позиции, указанной с помощью заполнение, чтобы привести длину последовательности к &lt;code&gt;str.width()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b4dee41190e5faa1ca923bd889668d6289ee307f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;stream&lt;/code&gt; is a null pointer, all open output streams are flushed, including the ones manipulated within library packages or otherwise not directly accessible to the program.</source>
          <target state="translated">Если &lt;code&gt;stream&lt;/code&gt; является нулевым указателем, все открытые выходные потоки сбрасываются, включая те, которые манипулируются в пакетах библиотеки или иным образом не доступны напрямую программе.</target>
        </trans-unit>
        <trans-unit id="86e307545d5f002abef118325d5d3eb89a16b86d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;t &amp;gt;= 0 &amp;amp;&amp;amp; t &amp;lt;= 1&lt;/code&gt;, the result is finite.</source>
          <target state="translated">Если &lt;code&gt;t &amp;gt;= 0 &amp;amp;&amp;amp; t &amp;lt;= 1&lt;/code&gt; , результат конечен.</target>
        </trans-unit>
        <trans-unit id="a189eebdd38827d96375b30f0eca568ef1adf1d7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;t == 0&lt;/code&gt;, the result is equal to &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;t == 0&lt;/code&gt; , результат равен &lt;code&gt;a&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bcbb6f49ce7e941481d92cd71eec73b19dcdaf2a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;t == 1&lt;/code&gt;, the result is equal to &lt;code&gt;b&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;t == 1&lt;/code&gt; , результат равен &lt;code&gt;b&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="35800f7e22639b64ad669cbfd0243c9e80c3180f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;t1&lt;/code&gt; does not satisfy the previous items, then &lt;code&gt;INVOKE(f, t1)&lt;/code&gt; is equivalent to &lt;code&gt;(*t1).*f&lt;/code&gt;</source>
          <target state="translated">Если &lt;code&gt;t1&lt;/code&gt; не удовлетворяет предыдущим элементам, тогда &lt;code&gt;INVOKE(f, t1)&lt;/code&gt; эквивалентно &lt;code&gt;(*t1).*f&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b6f9a950127cdac35950e54e7e7f5e552a16d7cc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;t1&lt;/code&gt; does not satisfy the previous items, then &lt;code&gt;INVOKE(f, t1, t2, ..., tN)&lt;/code&gt; is equivalent to &lt;code&gt;((*t1).*f)(t2, ..., tN)&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;t1&lt;/code&gt; не удовлетворяет предыдущим элементам, то &lt;code&gt;INVOKE(f, t1, t2, ..., tN)&lt;/code&gt; эквивалентно &lt;code&gt;((*t1).*f)(t2, ..., tN)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="996fc7fea5a596a0a7f8caf3724383378f3397b9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;t&lt;/code&gt; and &lt;code&gt;rv&lt;/code&gt; do not refer to the same object , the value of &lt;code&gt;t&lt;/code&gt; is equivalent to the value of &lt;code&gt;rv&lt;/code&gt; before the assignment.</source>
          <target state="translated">Если &lt;code&gt;t&lt;/code&gt; и &lt;code&gt;rv&lt;/code&gt; не ссылаются на один и тот же объект, значение &lt;code&gt;t&lt;/code&gt; эквивалентно значению &lt;code&gt;rv&lt;/code&gt; перед присваиванием.</target>
        </trans-unit>
        <trans-unit id="70f1cc8280f18381cdb55a983658d6c5ccf12f01" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;t&lt;/code&gt; represents a time point during a leap second insertion, the last representable value of &lt;code&gt;sys_time&lt;/code&gt; prior to the insertion of the leap second is returned. In all other cases, &lt;code&gt;utc_clock::from_sys(utc_clock::to_sys(t)) == t&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;t&lt;/code&gt; представляет момент времени во время вставки високосной секунды, возвращается последнее представимое значение &lt;code&gt;sys_time&lt;/code&gt; перед вставкой високосной секунды. Во всех остальных случаях &lt;code&gt;utc_clock::from_sys(utc_clock::to_sys(t)) == t&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="94842a48923ccea749a7b322cc54918cec93ee9e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;tbl&lt;/code&gt; is null, &lt;code&gt;classic_table()&lt;/code&gt; is used by all classification member functions. Otherwise, &lt;code&gt;tbl&lt;/code&gt; must be a pointer to the first element of an array of masks, at least &lt;code&gt;&lt;a href=&quot;../ctype&quot;&gt;std::ctype&lt;/a&gt;&amp;lt;char&amp;gt;::table_size&lt;/code&gt; in size, and that array is used by all of this facet's classification member functions.</source>
          <target state="translated">Если &lt;code&gt;tbl&lt;/code&gt; имеет значение null, &lt;code&gt;classic_table()&lt;/code&gt; используется всеми функциями-членами классификации. В противном случае, &lt;code&gt;tbl&lt;/code&gt; должен быть указателем на первый элемент массива масок, размером не менее &lt;code&gt;&lt;a href=&quot;../ctype&quot;&gt;std::ctype&lt;/a&gt;&amp;lt;char&amp;gt;::table_size&lt;/code&gt; , и этот массив используется всеми функциями-членами классификации этого фасета.</target>
        </trans-unit>
        <trans-unit id="60c9f234140c969280e37d90ead363e725f41fef" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;this-&amp;gt;index() == rhs.index()&lt;/code&gt;, may throw any exception thrown by &lt;code&gt;swap(std::get&amp;lt;i&amp;gt;(*this), std::get&amp;lt;i&amp;gt;(rhs))&lt;/code&gt; with i being index().</source>
          <target state="translated">Если &lt;code&gt;this-&amp;gt;index() == rhs.index()&lt;/code&gt; , может выдать любое исключение, выброшенное с помощью &lt;code&gt;swap(std::get&amp;lt;i&amp;gt;(*this), std::get&amp;lt;i&amp;gt;(rhs))&lt;/code&gt; где i является индексом ().</target>
        </trans-unit>
        <trans-unit id="b62e0ed67d83925a4f019bee274f6aaf3d721d41" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;time_point&lt;/code&gt; has lower precision, it is implementation defined whether the value is rounded or truncated.</source>
          <target state="translated">Если &lt;code&gt;time_point&lt;/code&gt; имеет более низкую точность, то реализация определяется, является ли значение округленным или усеченным.</target>
        </trans-unit>
        <trans-unit id="f39154959538bec12350c40feb86c48847d93013" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;timeout_duration&lt;/code&gt; is less or equal &lt;code&gt;timeout_duration.zero()&lt;/code&gt;, the function behaves like &lt;code&gt;&lt;a href=&quot;try_lock&quot;&gt;try_lock()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;timeout_duration&lt;/code&gt; меньше или равен &lt;code&gt;timeout_duration.zero()&lt;/code&gt; , функция ведет себя как &lt;code&gt;&lt;a href=&quot;try_lock&quot;&gt;try_lock()&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="08ae6a5e709170320f3bb275e55a3ea39cb81509" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;timeout_duration&lt;/code&gt; is less or equal &lt;code&gt;timeout_duration.zero()&lt;/code&gt;, the function behaves like &lt;code&gt;&lt;a href=&quot;try_lock_shared&quot;&gt;try_lock_shared()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;timeout_duration&lt;/code&gt; меньше или равен &lt;code&gt;timeout_duration.zero()&lt;/code&gt; , функция ведет себя как &lt;code&gt;&lt;a href=&quot;try_lock_shared&quot;&gt;try_lock_shared()&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="94988ecccf327007cfe6e9600377b3a54d244a96" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;timeout_time&lt;/code&gt; has already passed, this function behaves like &lt;code&gt;&lt;a href=&quot;try_lock&quot;&gt;try_lock()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;timeout_time&lt;/code&gt; уже прошел, эта функция ведет себя как &lt;code&gt;&lt;a href=&quot;try_lock&quot;&gt;try_lock()&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="91299d6184527b913bd3a4c6c83fcc921365520d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;timeout_time&lt;/code&gt; has already passed, this function behaves like &lt;code&gt;&lt;a href=&quot;try_lock_shared&quot;&gt;try_lock_shared()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;timeout_time&lt;/code&gt; уже прошло, эта функция ведет себя как &lt;code&gt;&lt;a href=&quot;try_lock_shared&quot;&gt;try_lock_shared()&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="985b3af9a0f9c066a712acb80e6a80e55df51846" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;to&lt;/code&gt; does not exist, first executes &lt;code&gt;create_directory(to, from)&lt;/code&gt; (creates the new directory with a copy of the old directory's attributes)</source>
          <target state="translated">Если &lt;code&gt;to&lt;/code&gt; не существует, сначала выполняется &lt;code&gt;create_directory(to, from)&lt;/code&gt; (создает новый каталог с копией атрибутов старого каталога)</target>
        </trans-unit>
        <trans-unit id="869575bcc3b25a2f60e9720ddcdac4374d7f2bc5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;tp&lt;/code&gt; represents a nonexistent time between two UTC &lt;code&gt;time_point&lt;/code&gt;s, those two &lt;code&gt;time_point&lt;/code&gt;s will be the same, and that &lt;code&gt;time_point&lt;/code&gt; will be returned.</source>
          <target state="translated">Если &lt;code&gt;tp&lt;/code&gt; представляет несуществующее время между двумя &lt;code&gt;time_point&lt;/code&gt; времени UTC , эти две &lt;code&gt;time_point&lt;/code&gt; будут одинаковыми, и эта &lt;code&gt;time_point&lt;/code&gt; будет возвращена.</target>
        </trans-unit>
        <trans-unit id="b14c2985a9828fa673de15ad4b5432c7eec337ec" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;try_lock()&lt;/code&gt; succeeds, prior &lt;code&gt;unlock()&lt;/code&gt; operations on the same object</source>
          <target state="translated">Если &lt;code&gt;try_lock()&lt;/code&gt; успешно, предыдущие операции &lt;code&gt;unlock()&lt;/code&gt; над тем же объектом</target>
        </trans-unit>
        <trans-unit id="f68c72d2cc410f03ed4771fd243cfec6c94f974e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;try_lock&lt;/code&gt; is called by a thread that already owns the &lt;code&gt;mutex&lt;/code&gt; in any mode (shared or exclusive), the behavior is undefined.</source>
          <target state="translated">Если &lt;code&gt;try_lock&lt;/code&gt; вызывается потоком, который уже владеет &lt;code&gt;mutex&lt;/code&gt; в любом режиме (совместно используемом или исключающем), поведение не определено.</target>
        </trans-unit>
        <trans-unit id="2bcbd407f9c0eff5a0a0eb82929bbebd2a38ec19" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;try_lock&lt;/code&gt; is called by a thread that already owns the &lt;code&gt;mutex&lt;/code&gt;, the behavior is undefined.</source>
          <target state="translated">Если &lt;code&gt;try_lock&lt;/code&gt; вызывается потоком, которому уже принадлежит &lt;code&gt;mutex&lt;/code&gt; , поведение не определено.</target>
        </trans-unit>
        <trans-unit id="332a65a0871564214a2da39082b39ae682472b5c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;try_lock_for(duration)&lt;/code&gt; succeeds, prior &lt;code&gt;unlock()&lt;/code&gt; operations on the same object</source>
          <target state="translated">Если &lt;code&gt;try_lock_for(duration)&lt;/code&gt; успешен, предыдущие операции &lt;code&gt;unlock()&lt;/code&gt; над тем же объектом</target>
        </trans-unit>
        <trans-unit id="57e45d172606dd71b8ad2f147535c7a9c26b7b2f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;try_lock_for&lt;/code&gt; is called by a thread that already owns the &lt;code&gt;mutex&lt;/code&gt; in any mode (shared or exclusive), the behavior is undefined.</source>
          <target state="translated">Если &lt;code&gt;try_lock_for&lt;/code&gt; вызывается потоком, который уже владеет &lt;code&gt;mutex&lt;/code&gt; в любом режиме (совместно используемом или исключающем), поведение не определено.</target>
        </trans-unit>
        <trans-unit id="e2913e9dfd8101ebfeeca847b3fbb13f36f0e999" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;try_lock_for&lt;/code&gt; is called by a thread that already owns the &lt;code&gt;mutex&lt;/code&gt;, the behavior is undefined.</source>
          <target state="translated">Если &lt;code&gt;try_lock_for&lt;/code&gt; вызывается потоком, который уже владеет &lt;code&gt;mutex&lt;/code&gt; , поведение не определено.</target>
        </trans-unit>
        <trans-unit id="3e3938b542994009b61584f5206da7eb84b567ed" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;try_lock_shared()&lt;/code&gt; succeeds, prior &lt;code&gt;unlock()&lt;/code&gt; operations on the same object</source>
          <target state="translated">Если &lt;code&gt;try_lock_shared()&lt;/code&gt; успешно, предыдущие операции &lt;code&gt;unlock()&lt;/code&gt; над тем же объектом</target>
        </trans-unit>
        <trans-unit id="88e17bb477f3b0dc9840117e325cc5419c64d635" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;try_lock_shared_for(duration)&lt;/code&gt; succeeds, prior &lt;code&gt;unlock()&lt;/code&gt; operations on the same object</source>
          <target state="translated">Если &lt;code&gt;try_lock_shared_for(duration)&lt;/code&gt; успешен, предыдущие операции &lt;code&gt;unlock()&lt;/code&gt; над тем же объектом</target>
        </trans-unit>
        <trans-unit id="3cb436a54d222a2207a53f9e58e0c49e9a0e682d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;try_lock_shared_for&lt;/code&gt; is called by a thread that already owns the &lt;code&gt;mutex&lt;/code&gt; in any mode (shared or exclusive), the behavior is undefined.</source>
          <target state="translated">Если &lt;code&gt;try_lock_shared_for&lt;/code&gt; вызывается потоком, который уже владеет &lt;code&gt;mutex&lt;/code&gt; в любом режиме (совместно используемом или исключающем), поведение не определено.</target>
        </trans-unit>
        <trans-unit id="2b4a06da759220650268238bcf1faa9bc1408f74" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;try_lock_shared_until(time_point)&lt;/code&gt; succeeds, prior &lt;code&gt;unlock()&lt;/code&gt; operations on the same object</source>
          <target state="translated">Если &lt;code&gt;try_lock_shared_until(time_point)&lt;/code&gt; завершается успешно, предыдущие операции &lt;code&gt;unlock()&lt;/code&gt; над тем же объектом</target>
        </trans-unit>
        <trans-unit id="2b919196e38c014769e5a77c9fece0fc9c129522" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;try_lock_shared_until&lt;/code&gt; is called by a thread that already owns the &lt;code&gt;mutex&lt;/code&gt; in any mode (shared or exclusive), the behavior is undefined.</source>
          <target state="translated">Если &lt;code&gt;try_lock_shared_until&lt;/code&gt; вызывается потоком, который уже владеет &lt;code&gt;mutex&lt;/code&gt; в любом режиме (совместно используемом или исключающем), поведение не определено.</target>
        </trans-unit>
        <trans-unit id="bd2e7ac4f22bfd95548a0a07a00613e5cf96f270" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;try_lock_until(time_point)&lt;/code&gt; succeeds, prior &lt;code&gt;unlock()&lt;/code&gt; operations on the same object</source>
          <target state="translated">Если &lt;code&gt;try_lock_until(time_point)&lt;/code&gt; завершается успешно, предыдущие операции &lt;code&gt;unlock()&lt;/code&gt; над тем же объектом</target>
        </trans-unit>
        <trans-unit id="ee385f3e6edb77e1716bf26ec86831203e82ffc6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;try_lock_until&lt;/code&gt; is called by a thread that already owns the &lt;code&gt;mutex&lt;/code&gt; in any mode (shared or exclusive), the behavior is undefined.</source>
          <target state="translated">Если &lt;code&gt;try_lock_until&lt;/code&gt; вызывается потоком, который уже владеет &lt;code&gt;mutex&lt;/code&gt; в любом режиме (совместно используемом или исключающем), поведение не определено.</target>
        </trans-unit>
        <trans-unit id="a43b3e939093abea19b584b116c2b4c2095ef181" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;try_lock_until&lt;/code&gt; is called by a thread that already owns the &lt;code&gt;mutex&lt;/code&gt;, the behavior is undefined.</source>
          <target state="translated">Если &lt;code&gt;try_lock_until&lt;/code&gt; вызывается потоком, который уже владеет &lt;code&gt;mutex&lt;/code&gt; , поведение не определено.</target>
        </trans-unit>
        <trans-unit id="5c29403a2f55f94d0b6bdf83a06a0e7ac5dae5f0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;type&lt;/code&gt; is an array type, all dimensions other than the first must be specified as positive &lt;a href=&quot;constant_expression&quot;&gt;integral constant expression&lt;/a&gt;(until C++14)&lt;a href=&quot;constant_expression&quot;&gt;converted constant expression&lt;/a&gt; of type &lt;code&gt;&lt;a href=&quot;../types/size_t&quot;&gt;std::size_t&lt;/a&gt;&lt;/code&gt;(since C++14), but the first dimension may be any expression convertible to &lt;code&gt;&lt;a href=&quot;../types/size_t&quot;&gt;std::size_t&lt;/a&gt;&lt;/code&gt;. This is the only way to directly create an array with size defined at runtime, such arrays are often referred to as</source>
          <target state="translated">Если &lt;code&gt;type&lt;/code&gt; является типом массива, все измерения, кроме первого, должны быть указаны как положительное &lt;a href=&quot;constant_expression&quot;&gt;целочисленное константное выражение&lt;/a&gt; (до C ++ 14), &lt;a href=&quot;constant_expression&quot;&gt;преобразованное константное выражение&lt;/a&gt; типа &lt;code&gt;&lt;a href=&quot;../types/size_t&quot;&gt;std::size_t&lt;/a&gt;&lt;/code&gt; (начиная с C ++ 14), но первое измерение может быть любым выражением, преобразованным в &lt;code&gt;&lt;a href=&quot;../types/size_t&quot;&gt;std::size_t&lt;/a&gt;&lt;/code&gt; . Это единственный способ напрямую создать массив с размером, определенным во время выполнения, такие массивы часто называют</target>
        </trans-unit>
        <trans-unit id="987dae04e3210104881f78fd36a73b5af3bafb97" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;type&lt;/code&gt; is not a &lt;a href=&quot;../language/data_members#Standard_layout&quot;&gt;standard layout type&lt;/a&gt;, the behavior is undefined(until C++17)use of the &lt;code&gt;offsetof&lt;/code&gt; macro is conditionally-supported(since C++17).</source>
          <target state="translated">Если &lt;code&gt;type&lt;/code&gt; не является &lt;a href=&quot;../language/data_members#Standard_layout&quot;&gt;стандартным типом макета&lt;/a&gt; , поведение не определено (до C ++ 17), использование макроса &lt;code&gt;offsetof&lt;/code&gt; поддерживается условно (начиная с C ++ 17).</target>
        </trans-unit>
        <trans-unit id="8b86993c41ea614db0c1542ae39296df1802bd91" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;typeid&lt;/code&gt; is used on an object under construction or destruction (in a destructor or in a constructor, including constructor's &lt;a href=&quot;constructor&quot;&gt;initializer list&lt;/a&gt; or &lt;a href=&quot;data_members#Member_initialization&quot;&gt;default member initializers&lt;/a&gt;), then the &lt;code&gt;&lt;a href=&quot;../types/type_info&quot;&gt;std::type_info&lt;/a&gt;&lt;/code&gt; object referred to by this &lt;code&gt;typeid&lt;/code&gt; represents the class that is being constructed or destroyed even if it is not the most-derived class.</source>
          <target state="translated">Если &lt;code&gt;typeid&lt;/code&gt; используется в строящемся или разрушаемом объекте (в деструкторе или в конструкторе, включая &lt;a href=&quot;constructor&quot;&gt;список инициализатора&lt;/a&gt; конструктора или &lt;a href=&quot;data_members#Member_initialization&quot;&gt;инициализаторы членов по умолчанию&lt;/a&gt; ), тогда объект &lt;code&gt;&lt;a href=&quot;../types/type_info&quot;&gt;std::type_info&lt;/a&gt;&lt;/code&gt; ссылается этот &lt;code&gt;typeid&lt;/code&gt; , представляет класс, который создается или уничтожен, даже если это не самый производный класс.</target>
        </trans-unit>
        <trans-unit id="2c8bc9e007e9eab3e896a3aaff472ee164636be8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;ungetc&lt;/code&gt; is called more than once without an intervening read or repositioning, it may fail (in other words, a pushback buffer of size 1 is guaranteed, but any larger buffer is implementation-defined). If multiple successful &lt;code&gt;ungetc&lt;/code&gt; were performed, read operations retrieve the pushed-back characters in reverse order of &lt;code&gt;ungetc&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;ungetc&lt;/code&gt; вызывается более одного раза без промежуточного чтения или изменения положения, это может привести к сбою (другими словами, буфер с откатом размера 1 гарантирован, но любой больший буфер определяется реализацией). Если было выполнено несколько успешных &lt;code&gt;ungetc&lt;/code&gt; , операции чтения извлекают символы возврата в обратном порядке &lt;code&gt;ungetc&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b93c880a13d41dd5f02146648e0bcdb941ad4432" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;ungetwc&lt;/code&gt; is called more than once without an intervening read or repositioning, it may fail (in other words, a pushback buffer of size 1 is guaranteed, but any larger buffer is implementation-defined). If multiple successful &lt;code&gt;ungetwc&lt;/code&gt; were performed, read operations retrieve the pushed-back wide characters in reverse order of &lt;code&gt;ungetwc&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;ungetwc&lt;/code&gt; вызывается более одного раза без промежуточного чтения или изменения положения, это может привести к сбою (другими словами, буфер с откатом размера 1 гарантирован, но любой больший буфер определяется реализацией). Если было выполнено несколько успешных &lt;code&gt;ungetwc&lt;/code&gt; , операции чтения извлекают задние широкие символы в обратном порядке &lt;code&gt;ungetwc&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1e79c0c8a7bbdaf2db59b21cc3df9306376d12ba" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;using: namespace&lt;/code&gt; appears in the beginning of an attribute list, no other attributes in the attribute list can specify a namespace: the namespace specified in a using applies to them all:</source>
          <target state="translated">Если &lt;code&gt;using: namespace&lt;/code&gt; появляется в начале списка атрибутов, никакие другие атрибуты в списке атрибутов не могут указывать пространство имен: пространство имен, указанное при использовании, применяется ко всем им:</target>
        </trans-unit>
        <trans-unit id="08c3c3c90c1cbb009889979159acc6ccce066254" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;v.index() != w.index()&lt;/code&gt;, returns &lt;code&gt;false&lt;/code&gt;;</source>
          <target state="translated">Если &lt;code&gt;v.index() != w.index()&lt;/code&gt; , возвращает &lt;code&gt;false&lt;/code&gt; ;</target>
        </trans-unit>
        <trans-unit id="73386b30a8cd9063a65cadd69c4f27f4b4729d4d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;v.index() != w.index()&lt;/code&gt;, returns &lt;code&gt;true&lt;/code&gt;;</source>
          <target state="translated">Если &lt;code&gt;v.index() != w.index()&lt;/code&gt; , возвращает &lt;code&gt;true&lt;/code&gt; ;</target>
        </trans-unit>
        <trans-unit id="60664f03dd91064cc8bcd5281122b9be42c2ecf1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;v.valueless_by_exception()&lt;/code&gt;, returns &lt;code&gt;false&lt;/code&gt;;</source>
          <target state="translated">Если &lt;code&gt;v.valueless_by_exception()&lt;/code&gt; , возвращает &lt;code&gt;false&lt;/code&gt; ;</target>
        </trans-unit>
        <trans-unit id="056416cb18ca600a6a47288399d10085b1d96979" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;v.valueless_by_exception()&lt;/code&gt;, returns &lt;code&gt;true&lt;/code&gt;;</source>
          <target state="translated">Если &lt;code&gt;v.valueless_by_exception()&lt;/code&gt; , возвращает &lt;code&gt;true&lt;/code&gt; ;</target>
        </trans-unit>
        <trans-unit id="c3e0828292e64efc70577bb97a628f74f2c468ae" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;v&lt;/code&gt; compares equivalent to either bound, returns a reference to &lt;code&gt;v&lt;/code&gt;, not the bound.</source>
          <target state="translated">Если &lt;code&gt;v&lt;/code&gt; сравнивает эквивалент с любой границей, возвращает ссылку на &lt;code&gt;v&lt;/code&gt; , а не границу.</target>
        </trans-unit>
        <trans-unit id="75a090849c6c030efd853b2c4e1bec200144bf8e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;va_arg&lt;/code&gt; is called when there are no more arguments in &lt;code&gt;ap&lt;/code&gt;, the behavior is undefined.</source>
          <target state="translated">Если &lt;code&gt;va_arg&lt;/code&gt; вызывается, когда в &lt;code&gt;ap&lt;/code&gt; больше нет аргументов , поведение не определено.</target>
        </trans-unit>
        <trans-unit id="adb7aa1f42112a75264739ee28d6e8827e04fc33" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;w.valueless_by_exception()&lt;/code&gt;, returns &lt;code&gt;false&lt;/code&gt;;</source>
          <target state="translated">Если &lt;code&gt;w.valueless_by_exception()&lt;/code&gt; , возвращает &lt;code&gt;false&lt;/code&gt; ;</target>
        </trans-unit>
        <trans-unit id="1ec2d68dd14c2554d3c630fe1822a69b8ee574f4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;w.valueless_by_exception()&lt;/code&gt;, returns &lt;code&gt;true&lt;/code&gt;;</source>
          <target state="translated">Если &lt;code&gt;w.valueless_by_exception()&lt;/code&gt; , возвращает &lt;code&gt;true&lt;/code&gt; ;</target>
        </trans-unit>
        <trans-unit id="4a2e019de572732991114a4b9ac83594fefd4e00" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;wc&lt;/code&gt; is the null character, the null byte is written to &lt;code&gt;s&lt;/code&gt;, preceded by any shift sequences necessary to restore the initial shift state.</source>
          <target state="translated">Если &lt;code&gt;wc&lt;/code&gt; является нулевым символом, нулевой байт записывается в &lt;code&gt;s&lt;/code&gt; , которому предшествуют любые последовательности сдвигов, необходимые для восстановления начального состояния сдвига.</target>
        </trans-unit>
        <trans-unit id="2df38e58a0b81e321cbdefacc5fbfee02970c44f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;which&lt;/code&gt; includes &lt;code&gt;ios_base::in&lt;/code&gt; and this buffer is open for reading (that is, if &lt;code&gt;((which &amp;amp; ios_base::in) == ios_base::in&lt;/code&gt;), then repositions the read pointer &lt;code&gt;&lt;a href=&quot;../basic_streambuf/gptr&quot;&gt;std::basic_streambuf::gptr&lt;/a&gt;&lt;/code&gt; inside the get area as described below</source>
          <target state="translated">Если , &lt;code&gt;which&lt;/code&gt; включает в себя &lt;code&gt;ios_base::in&lt;/code&gt; и этот буфер открыт для чтения (то есть, если &lt;code&gt;((which &amp;amp; ios_base::in) == ios_base::in&lt;/code&gt; ), а затем перемещает указатель чтения &lt;code&gt;&lt;a href=&quot;../basic_streambuf/gptr&quot;&gt;std::basic_streambuf::gptr&lt;/a&gt;&lt;/code&gt; внутри получить область, как описано ниже</target>
        </trans-unit>
        <trans-unit id="076480d9e864ea3eea8105519a4f861e38abff0c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;which&lt;/code&gt; includes &lt;code&gt;ios_base::in&lt;/code&gt; and this buffer is open for reading, then repositions the read pointer &lt;code&gt;&lt;a href=&quot;../basic_streambuf/gptr&quot;&gt;std::basic_streambuf::gptr&lt;/a&gt;&lt;/code&gt; inside the get area as described below</source>
          <target state="translated">Если , &lt;code&gt;which&lt;/code&gt; включает в себя &lt;code&gt;ios_base::in&lt;/code&gt; и этот буфер открыт для чтения, а затем перемещает указатель чтения &lt;code&gt;&lt;a href=&quot;../basic_streambuf/gptr&quot;&gt;std::basic_streambuf::gptr&lt;/a&gt;&lt;/code&gt; внутри области ПОЛУЧИТЬ , как описано ниже</target>
        </trans-unit>
        <trans-unit id="412981fa397417a50c5b81ce7315076f976f90c1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;which&lt;/code&gt; includes &lt;code&gt;ios_base::out&lt;/code&gt; and this buffer is open for writing (that is, &lt;code&gt;(which &amp;amp; ios_base::out) == ios_base::out&lt;/code&gt;), then repositions the write pointer &lt;code&gt;&lt;a href=&quot;../basic_streambuf/pptr&quot;&gt;std::basic_streambuf::pptr&lt;/a&gt;&lt;/code&gt; inside the put area as described below</source>
          <target state="translated">Если в &lt;code&gt;which&lt;/code&gt; входит &lt;code&gt;ios_base::out&lt;/code&gt; и этот буфер открыт для записи (то есть &lt;code&gt;(which &amp;amp; ios_base::out) == ios_base::out&lt;/code&gt; ), то указатель записи &lt;code&gt;&lt;a href=&quot;../basic_streambuf/pptr&quot;&gt;std::basic_streambuf::pptr&lt;/a&gt;&lt;/code&gt; в область ввода как описано ниже</target>
        </trans-unit>
        <trans-unit id="ebb77a9083ead2007e8eed624a96ab97b1b10e5b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;which&lt;/code&gt; includes &lt;code&gt;ios_base::out&lt;/code&gt; and this buffer is open for writing, then repositions the write pointer &lt;code&gt;&lt;a href=&quot;../basic_streambuf/pptr&quot;&gt;std::basic_streambuf::pptr&lt;/a&gt;&lt;/code&gt; inside the put area as described below</source>
          <target state="translated">Если , &lt;code&gt;which&lt;/code&gt; включает в себя &lt;code&gt;ios_base::out&lt;/code&gt; и этот буфер открыт для записи, а затем перемещает указатель записи &lt;code&gt;&lt;a href=&quot;../basic_streambuf/pptr&quot;&gt;std::basic_streambuf::pptr&lt;/a&gt;&lt;/code&gt; внутри области пут , как описано ниже</target>
        </trans-unit>
        <trans-unit id="32ac61f3d8f163e81b3115553fcd68a7ebccec80" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;which&lt;/code&gt; includes both &lt;code&gt;ios_base::in&lt;/code&gt; and &lt;code&gt;ios_base::out&lt;/code&gt; and the buffer is open for both reading and writing (&lt;code&gt;(which &amp;amp; (ios_base::in|ios_base::out)) ==(ios_base::in|ios_base::out)&lt;/code&gt;), and &lt;code&gt;dir&lt;/code&gt; is either &lt;code&gt;ios_base::beg&lt;/code&gt; or &lt;code&gt;ios_base::end&lt;/code&gt;, then repositions both read and write pointers as described below.</source>
          <target state="translated">Если в &lt;code&gt;which&lt;/code&gt; включены &lt;code&gt;ios_base::in&lt;/code&gt; и &lt;code&gt;ios_base::out&lt;/code&gt; а буфер открыт для чтения и записи ( &lt;code&gt;(which &amp;amp; (ios_base::in|ios_base::out)) ==(ios_base::in|ios_base::out)&lt;/code&gt; ), а &lt;code&gt;dir&lt;/code&gt; - это либо &lt;code&gt;ios_base::beg&lt;/code&gt; либо &lt;code&gt;ios_base::end&lt;/code&gt; , затем перемещает указатели чтения и записи, как описано ниже.</target>
        </trans-unit>
        <trans-unit id="d56bcb44c21f33d202f66d86615b3fd4c47e7a59" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;which&lt;/code&gt; includes both &lt;code&gt;ios_base::in&lt;/code&gt; and &lt;code&gt;ios_base::out&lt;/code&gt; and the buffer is open for both reading and writing, and &lt;code&gt;when&lt;/code&gt; is either &lt;code&gt;ios_base::beg&lt;/code&gt; or &lt;code&gt;ios_base::end&lt;/code&gt;, then repositions both read and write pointers as described below.</source>
          <target state="translated">Если , &lt;code&gt;which&lt;/code&gt; включает в себя как &lt;code&gt;ios_base::in&lt;/code&gt; и &lt;code&gt;ios_base::out&lt;/code&gt; и буфер открыт для чтения и записи, а также, &lt;code&gt;when&lt;/code&gt; это либо &lt;code&gt;ios_base::beg&lt;/code&gt; или &lt;code&gt;ios_base::end&lt;/code&gt; , а затем перемещает чтения и записи указателей , как описано ниже.</target>
        </trans-unit>
        <trans-unit id="9292e4a3413eb133a7f76bc6e4fe74a238c5b8bf" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; are both zero, domain error</source>
          <target state="translated">Если &lt;code&gt;x&lt;/code&gt; и &lt;code&gt;y&lt;/code&gt; равны нулю, ошибка домена</target>
        </trans-unit>
        <trans-unit id="8a5e321969b66fbefa9cdd24eacf386b98fffc2b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; are both zero, range error does not occur either</source>
          <target state="translated">Если &lt;code&gt;x&lt;/code&gt; и &lt;code&gt;y&lt;/code&gt; оба равны нулю, ошибка диапазона также не возникает</target>
        </trans-unit>
        <trans-unit id="1a0e37c7feac7db699e4130a50b199ceedd910f7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is &amp;plusmn;&amp;infin; and &lt;code&gt;y&lt;/code&gt; is not NaN, NaN is returned and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; is raised</source>
          <target state="translated">Если &lt;code&gt;x&lt;/code&gt; есть &amp;plusmn; &amp;infin; и &lt;code&gt;y&lt;/code&gt; не NaN, NaN , возвращается и &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; поднимается</target>
        </trans-unit>
        <trans-unit id="8abb2fb48327f23dca2adde7572dddc2e811ad8b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is &amp;plusmn;&amp;infin;, &amp;plusmn;0 is returned, and &amp;plusmn;&amp;infin; is stored in &lt;code&gt;*iptr&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;x&lt;/code&gt; равен &amp;plusmn; &amp;infin;, возвращается &amp;plusmn; 0, и &amp;plusmn; &amp;infin; сохраняется в &lt;code&gt;*iptr&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3b9e315fe80911902dd03d84688ec8a34941e551" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is &amp;plusmn;&amp;infin;, it is returned, unmodified</source>
          <target state="translated">Если &lt;code&gt;x&lt;/code&gt; равен &amp;plusmn; &amp;infin;, он возвращается без изменений</target>
        </trans-unit>
        <trans-unit id="0d517d0ca1b88b420f9a711836c289f554f6f27a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is &amp;plusmn;0 and &lt;code&gt;y&lt;/code&gt; is not zero, &amp;plusmn;0 is returned</source>
          <target state="translated">Если &lt;code&gt;x&lt;/code&gt; равен &amp;plusmn; 0, а &lt;code&gt;y&lt;/code&gt; не равен нулю, возвращается &amp;plusmn; 0</target>
        </trans-unit>
        <trans-unit id="dcd1a0509c1e6bf68cbedd9162ffec0cc1242173" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is &amp;plusmn;0, &amp;plusmn;0 is returned, and &amp;plusmn;0 is stored in &lt;code&gt;*iptr&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;x&lt;/code&gt; равен &amp;plusmn; 0, возвращается &amp;plusmn; 0 и &amp;plusmn; 0 сохраняется в &lt;code&gt;*iptr&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7cb707c1e458814fee624b6c9deb60721133b5b6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is &amp;plusmn;0, it is returned, unmodified</source>
          <target state="translated">Если &lt;code&gt;x&lt;/code&gt; равен &amp;plusmn; 0, он возвращается без изменений</target>
        </trans-unit>
        <trans-unit id="f41dcbd3d46c8769c4b2fb80c374a0e5c0d62c23" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is &lt;code&gt;&amp;plusmn;0&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; is negative, &lt;code&gt;-&amp;pi;/2&lt;/code&gt; is returned</source>
          <target state="translated">Если &lt;code&gt;x&lt;/code&gt; равен &lt;code&gt;&amp;plusmn;0&lt;/code&gt; а &lt;code&gt;y&lt;/code&gt; отрицательно, возвращается &lt;code&gt;-&amp;pi;/2&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d6968a9e1c046845040fc68d63a376b5e6b8b85a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is &lt;code&gt;&amp;plusmn;0&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; is positive, &lt;code&gt;+&amp;pi;/2&lt;/code&gt; is returned</source>
          <target state="translated">Если &lt;code&gt;x&lt;/code&gt; равен &lt;code&gt;&amp;plusmn;0&lt;/code&gt; а &lt;code&gt;y&lt;/code&gt; положительно, возвращается &lt;code&gt;+&amp;pi;/2&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="742021246f19681537f6e140bb629b64b21e4348" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is &lt;code&gt;+&amp;infin;&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; is finite and negative, &lt;code&gt;-0&lt;/code&gt; is returned</source>
          <target state="translated">Если &lt;code&gt;x&lt;/code&gt; равен &lt;code&gt;+&amp;infin;&lt;/code&gt; , а &lt;code&gt;y&lt;/code&gt; конечен и отрицателен, возвращается &lt;code&gt;-0&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="854f55847c1c8f45111c844b75fe0c4c049cc744" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is &lt;code&gt;+&amp;infin;&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; is finite and positive, &lt;code&gt;+0&lt;/code&gt; is returned</source>
          <target state="translated">Если &lt;code&gt;x&lt;/code&gt; равен &lt;code&gt;+&amp;infin;&lt;/code&gt; и &lt;code&gt;y&lt;/code&gt; конечен и положителен, возвращается &lt;code&gt;+0&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="70312266975b00e8f11c41c1477d3626e83ccaa9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is &lt;code&gt;-&amp;infin;&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; is finite and negative, &lt;code&gt;-&amp;pi;&lt;/code&gt; is returned</source>
          <target state="translated">Если &lt;code&gt;x&lt;/code&gt; равен &lt;code&gt;-&amp;infin;&lt;/code&gt; , а &lt;code&gt;y&lt;/code&gt; конечен и отрицателен, возвращается &lt;code&gt;-&amp;pi;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="adfdc77216731e53faa0611a28dda473ddae36f7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is &lt;code&gt;-&amp;infin;&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; is finite and positive, &lt;code&gt;+&amp;pi;&lt;/code&gt; is returned</source>
          <target state="translated">Если &lt;code&gt;x&lt;/code&gt; равен &lt;code&gt;-&amp;infin;&lt;/code&gt; , а &lt;code&gt;y&lt;/code&gt; конечен и положителен, возвращается &lt;code&gt;+&amp;pi;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c80b06556a1152fcb8c22f136b6473885d57b346" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is NaN, NaN is returned</source>
          <target state="translated">Если &lt;code&gt;x&lt;/code&gt; равен NaN, NaN возвращается</target>
        </trans-unit>
        <trans-unit id="226af42b45e3a0a3b2917fd765deb1015d6b2d9e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is NaN, NaN is returned, and NaN is stored in &lt;code&gt;*iptr&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;x&lt;/code&gt; равен NaN, NaN возвращается, и NaN сохраняется в &lt;code&gt;*iptr&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="86712aaf103771c2d7819baa87af27b031d94ae1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is NaN, then NaN with the sign of &lt;code&gt;y&lt;/code&gt; is returned.</source>
          <target state="translated">Если &lt;code&gt;x&lt;/code&gt; равен NaN, то возвращается NaN со знаком &lt;code&gt;y&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b0446e18a46c6733752844d64ec7ed2bde15bde6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is negative, a domain error may occur</source>
          <target state="translated">Если &lt;code&gt;x&lt;/code&gt; отрицательно, может возникнуть ошибка домена</target>
        </trans-unit>
        <trans-unit id="0d4fee627ff864097e3bcf0e10e6f4e13892a483" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is not zero, calculates the largest integral power of two that is not greater than &lt;code&gt;x&lt;/code&gt;. If &lt;code&gt;x&lt;/code&gt; is zero, returns zero.</source>
          <target state="translated">Если &lt;code&gt;x&lt;/code&gt; не равен нулю, вычисляется наибольшая интегральная степень двух, которая не больше &lt;code&gt;x&lt;/code&gt; . Если &lt;code&gt;x&lt;/code&gt; равен нулю, возвращает ноль.</target>
        </trans-unit>
        <trans-unit id="2a471c8ab6033df659f209b9c95baa221163a386" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is not zero, calculates the number of bits needed to store the value &lt;code&gt;x&lt;/code&gt;, that is, \(1 + \lfloor log_2(x) \rfloor\)1 + floor(log</source>
          <target state="translated">Если &lt;code&gt;x&lt;/code&gt; не равен нулю, вычисляется количество битов, необходимое для хранения значения &lt;code&gt;x&lt;/code&gt; , то есть \ (1 + \ lfloor log_2 (x) \ rfloor \) 1 + floor (log</target>
        </trans-unit>
        <trans-unit id="e48634bd82e2df6f62aec245642cb59777238384" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;y&lt;/code&gt; is &amp;plusmn;&amp;infin; and &lt;code&gt;x&lt;/code&gt; is finite, &lt;code&gt;x&lt;/code&gt; is returned.</source>
          <target state="translated">Если &lt;code&gt;y&lt;/code&gt; равен &amp;plusmn; &amp;infin; и &lt;code&gt;x&lt;/code&gt; конечно, &lt;code&gt;x&lt;/code&gt; возвращается.</target>
        </trans-unit>
        <trans-unit id="a2ddc1042c63e353212b7799d89a1b092aed734a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;y&lt;/code&gt; is &amp;plusmn;0 and &lt;code&gt;x&lt;/code&gt; is not NaN, NaN is returned and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; is raised</source>
          <target state="translated">Если &lt;code&gt;y&lt;/code&gt; равен &amp;plusmn; 0 и &lt;code&gt;x&lt;/code&gt; не является NaN, NaN возвращается и &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; повышается</target>
        </trans-unit>
        <trans-unit id="1c4d4232381ec31f82701b3b12b902639c119342" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;y&lt;/code&gt; is -0, the result is only negative if the implementation supports the signed zero consistently in arithmetic operations.</source>
          <target state="translated">Если &lt;code&gt;y&lt;/code&gt; равно -0, результат будет только отрицательным, если реализация последовательно поддерживает нулевой знак в арифметических операциях.</target>
        </trans-unit>
        <trans-unit id="bb77d357b03480982a5cb3af7fe4d1a54b4629b1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;y&lt;/code&gt; is &lt;code&gt;&amp;plusmn;&amp;infin;&lt;/code&gt; and &lt;code&gt;x&lt;/code&gt; is &lt;code&gt;+&amp;infin;&lt;/code&gt;, &lt;code&gt;&amp;plusmn;&amp;pi;/4&lt;/code&gt; is returned</source>
          <target state="translated">Если &lt;code&gt;y&lt;/code&gt; равно &lt;code&gt;&amp;plusmn;&amp;infin;&lt;/code&gt; а &lt;code&gt;x&lt;/code&gt; равно &lt;code&gt;+&amp;infin;&lt;/code&gt; , возвращается &lt;code&gt;&amp;plusmn;&amp;pi;/4&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c32d4c116dec5e5a3f5f016622351bfcdbb1d9a6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;y&lt;/code&gt; is &lt;code&gt;&amp;plusmn;&amp;infin;&lt;/code&gt; and &lt;code&gt;x&lt;/code&gt; is &lt;code&gt;-&amp;infin;&lt;/code&gt;, &lt;code&gt;&amp;plusmn;3&amp;pi;/4&lt;/code&gt; is returned</source>
          <target state="translated">Если &lt;code&gt;y&lt;/code&gt; равен &lt;code&gt;&amp;plusmn;&amp;infin;&lt;/code&gt; а &lt;code&gt;x&lt;/code&gt; равен &lt;code&gt;-&amp;infin;&lt;/code&gt; , возвращается &lt;code&gt;&amp;plusmn;3&amp;pi;/4&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f2d2be60f0f9dee6ef4e60532e876177666a7509" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;y&lt;/code&gt; is &lt;code&gt;&amp;plusmn;&amp;infin;&lt;/code&gt; and &lt;code&gt;x&lt;/code&gt; is finite, &lt;code&gt;&amp;plusmn;&amp;pi;/2&lt;/code&gt; is returned</source>
          <target state="translated">Если &lt;code&gt;y&lt;/code&gt; равен &lt;code&gt;&amp;plusmn;&amp;infin;&lt;/code&gt; и &lt;code&gt;x&lt;/code&gt; конечно, возвращается &lt;code&gt;&amp;plusmn;&amp;pi;/2&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="04ca9c751f9bab309085f696c5ce7e061eb53bf7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;y&lt;/code&gt; is &lt;code&gt;&amp;plusmn;0&lt;/code&gt; and &lt;code&gt;x&lt;/code&gt; is negative or &lt;code&gt;-0&lt;/code&gt;, &lt;code&gt;&amp;plusmn;&amp;pi;&lt;/code&gt; is returned</source>
          <target state="translated">Если &lt;code&gt;y&lt;/code&gt; равно &lt;code&gt;&amp;plusmn;0&lt;/code&gt; а &lt;code&gt;x&lt;/code&gt; отрицательно или &lt;code&gt;-0&lt;/code&gt; , возвращается &lt;code&gt;&amp;plusmn;&amp;pi;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6c2e024aa12ac316eec5865ba0f65ada4018df50" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;y&lt;/code&gt; is &lt;code&gt;&amp;plusmn;0&lt;/code&gt; and &lt;code&gt;x&lt;/code&gt; is positive or &lt;code&gt;+0&lt;/code&gt;, &lt;code&gt;&amp;plusmn;0&lt;/code&gt; is returned</source>
          <target state="translated">Если &lt;code&gt;y&lt;/code&gt; равно &lt;code&gt;&amp;plusmn;0&lt;/code&gt; а &lt;code&gt;x&lt;/code&gt; положительно или &lt;code&gt;+0&lt;/code&gt; , возвращается &lt;code&gt;&amp;plusmn;0&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="db8ff25a6b35fd58c6e2ad1d8257aa1fdbbc1afa" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;y&lt;/code&gt; is zero, but the domain error does not occur, zero is returned.</source>
          <target state="translated">Если &lt;code&gt;y&lt;/code&gt; равно нулю, но ошибка домена не возникает, возвращается ноль.</target>
        </trans-unit>
        <trans-unit id="934c80b3e977f6c9efabb47ff6836e6a1d4145a6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;y&lt;/code&gt; is zero, pole error does not occur</source>
          <target state="translated">Если &lt;code&gt;y&lt;/code&gt; равен нулю, ошибка полюса не возникает</target>
        </trans-unit>
        <trans-unit id="d5af0b5b04311e67b5c965ddebdd4dcbe743ea19" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;y&lt;/code&gt; is zero, the value stored in &lt;code&gt;*quo&lt;/code&gt; is unspecified.</source>
          <target state="translated">Если &lt;code&gt;y&lt;/code&gt; равно нулю, значение, хранящееся в &lt;code&gt;*quo&lt;/code&gt; , не указано.</target>
        </trans-unit>
        <trans-unit id="687d9b31d16e817da643762a7f7e3d0c38df64e2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z == std::chrono::choose::earliest&lt;/code&gt;, returns the earlier &lt;code&gt;sys_time&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;z == std::chrono::choose::earliest&lt;/code&gt; , возвращает более раннее время &lt;code&gt;sys_time&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="966a406501614a5b1c8f3e06813bd52dd307c0c0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z == std::chrono::choose::latest&lt;/code&gt;, returns the later &lt;code&gt;sys_time&lt;/code&gt;</source>
          <target state="translated">Если &lt;code&gt;z == std::chrono::choose::latest&lt;/code&gt; , возвращает более позднее &lt;code&gt;sys_time&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7157b6daee7178a7db7bf2b7f98b21bf5509b46f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(&amp;plusmn;&amp;infin;,NaN)&lt;/code&gt;, the result is &lt;code&gt;(+&amp;infin;,NaN)&lt;/code&gt;</source>
          <target state="translated">Если &lt;code&gt;z&lt;/code&gt; равен &lt;code&gt;(&amp;plusmn;&amp;infin;,NaN)&lt;/code&gt; , результат равен &lt;code&gt;(+&amp;infin;,NaN)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="647d48a9a025440a82db0559ba003eb986c87f48" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(&amp;plusmn;&amp;infin;,NaN)&lt;/code&gt;, the result is &lt;code&gt;(NaN,&amp;plusmn;&amp;infin;)&lt;/code&gt; (the sign of the imaginary part is unspecified)</source>
          <target state="translated">Если &lt;code&gt;z&lt;/code&gt; равен &lt;code&gt;(&amp;plusmn;&amp;infin;,NaN)&lt;/code&gt; , результат равен &lt;code&gt;(NaN,&amp;plusmn;&amp;infin;)&lt;/code&gt; (знак мнимой части не определен)</target>
        </trans-unit>
        <trans-unit id="5a29bd926acd8a4ed08d36ea492ffa17b0f65b06" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(&amp;plusmn;0,+0)&lt;/code&gt;, the result is &lt;code&gt;(&amp;pi;/2,-0)&lt;/code&gt;</source>
          <target state="translated">Если &lt;code&gt;z&lt;/code&gt; равно &lt;code&gt;(&amp;plusmn;0,+0)&lt;/code&gt; , результат равен &lt;code&gt;(&amp;pi;/2,-0)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d01365aea17ec2d928785c236cc8a0625a50a091" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(&amp;plusmn;0,+0)&lt;/code&gt;, the result is &lt;code&gt;(+0,&amp;pi;/2)&lt;/code&gt;</source>
          <target state="translated">Если &lt;code&gt;z&lt;/code&gt; равно &lt;code&gt;(&amp;plusmn;0,+0)&lt;/code&gt; , результат равен &lt;code&gt;(+0,&amp;pi;/2)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="aca45f2c4af7ce54c221c839224dcc7526370cce" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(&amp;plusmn;0,+0)&lt;/code&gt;, the result is &lt;code&gt;(+0,+0)&lt;/code&gt;</source>
          <target state="translated">Если &lt;code&gt;z&lt;/code&gt; равно &lt;code&gt;(&amp;plusmn;0,+0)&lt;/code&gt; , результат равен &lt;code&gt;(+0,+0)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b21cb1c0525d180376e59f65f141faac479dcda9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(&amp;plusmn;0,+0)&lt;/code&gt;, the result is &lt;code&gt;(1,+0)&lt;/code&gt;</source>
          <target state="translated">Если &lt;code&gt;z&lt;/code&gt; равно &lt;code&gt;(&amp;plusmn;0,+0)&lt;/code&gt; , результат равен &lt;code&gt;(1,+0)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2af12e24fdf73967ee7ab61f7c4d443b37739feb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(&amp;plusmn;0,NaN)&lt;/code&gt;, the result is &lt;code&gt;(&amp;pi;/2,NaN)&lt;/code&gt;</source>
          <target state="translated">Если &lt;code&gt;z&lt;/code&gt; равен &lt;code&gt;(&amp;plusmn;0,NaN)&lt;/code&gt; , результат равен &lt;code&gt;(&amp;pi;/2,NaN)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3b917afe8309bdfdc0889e4ce326dd3daf35a1e2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(+&amp;infin;,+&amp;infin;)&lt;/code&gt;, the result is &lt;code&gt;(&amp;pi;/4,-&amp;infin;)&lt;/code&gt;</source>
          <target state="translated">Если &lt;code&gt;z&lt;/code&gt; равен &lt;code&gt;(+&amp;infin;,+&amp;infin;)&lt;/code&gt; , результат равен &lt;code&gt;(&amp;pi;/4,-&amp;infin;)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="dc20a1d28cbfd032ecdaa31a57f9d5ee6abc083b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(+&amp;infin;,+&amp;infin;)&lt;/code&gt;, the result is &lt;code&gt;(&amp;plusmn;&amp;infin;,NaN)&lt;/code&gt; (the sign of the real part is unspecified) and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; is raised</source>
          <target state="translated">Если &lt;code&gt;z&lt;/code&gt; равно &lt;code&gt;(+&amp;infin;,+&amp;infin;)&lt;/code&gt; , результат равен &lt;code&gt;(&amp;plusmn;&amp;infin;,NaN)&lt;/code&gt; (знак действительной части не определен) и &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; повышается</target>
        </trans-unit>
        <trans-unit id="349b76e235126b678fc00eb96b36b916c8c7d87d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(+&amp;infin;,+&amp;infin;)&lt;/code&gt;, the result is &lt;code&gt;(&amp;plusmn;&amp;infin;,NaN)&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; is raised (the sign of the real part is unspecified)</source>
          <target state="translated">Если &lt;code&gt;z&lt;/code&gt; равно &lt;code&gt;(+&amp;infin;,+&amp;infin;)&lt;/code&gt; , результат равен &lt;code&gt;(&amp;plusmn;&amp;infin;,NaN)&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; повышается (знак действительной части не указан)</target>
        </trans-unit>
        <trans-unit id="6a80692535fb97c3bb378cc0e2235f9e6f89868d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(+&amp;infin;,+&amp;infin;)&lt;/code&gt;, the result is &lt;code&gt;(+&amp;infin;,&amp;pi;/4)&lt;/code&gt;</source>
          <target state="translated">Если &lt;code&gt;z&lt;/code&gt; равен &lt;code&gt;(+&amp;infin;,+&amp;infin;)&lt;/code&gt; , результат равен &lt;code&gt;(+&amp;infin;,&amp;pi;/4)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="992a6280563e8dfa9fd680864cf94914e2af8168" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(+&amp;infin;,+&amp;infin;)&lt;/code&gt;, the result is &lt;code&gt;(+0,&amp;pi;/2)&lt;/code&gt;</source>
          <target state="translated">Если &lt;code&gt;z&lt;/code&gt; равен &lt;code&gt;(+&amp;infin;,+&amp;infin;)&lt;/code&gt; , результат равен &lt;code&gt;(+0,&amp;pi;/2)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="02e1613ba0e3f7e9f51fc7723495ad1862a78f76" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(+&amp;infin;,+&amp;infin;)&lt;/code&gt;, the result is &lt;code&gt;(1,&amp;plusmn;0)&lt;/code&gt; (the sign of the imaginary part is unspecified)</source>
          <target state="translated">Если &lt;code&gt;z&lt;/code&gt; равно &lt;code&gt;(+&amp;infin;,+&amp;infin;)&lt;/code&gt; , результат равен &lt;code&gt;(1,&amp;plusmn;0)&lt;/code&gt; (знак мнимой части не указан)</target>
        </trans-unit>
        <trans-unit id="dc7e1f5800458c8b0514039db23f6f89349f39ac" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(+&amp;infin;,+0)&lt;/code&gt;, the result is &lt;code&gt;(+&amp;infin;,+0)&lt;/code&gt;</source>
          <target state="translated">Если &lt;code&gt;z&lt;/code&gt; равен &lt;code&gt;(+&amp;infin;,+0)&lt;/code&gt; , результат равен &lt;code&gt;(+&amp;infin;,+0)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4153d9975c2c48f8bb5202575acc2cae61f572c5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(+&amp;infin;,NaN)&lt;/code&gt;, the result is &lt;code&gt;(&amp;plusmn;&amp;infin;,NaN)&lt;/code&gt; (the sign of the real part is unspecified)</source>
          <target state="translated">Если &lt;code&gt;z&lt;/code&gt; равен &lt;code&gt;(+&amp;infin;,NaN)&lt;/code&gt; , результат равен &lt;code&gt;(&amp;plusmn;&amp;infin;,NaN)&lt;/code&gt; (знак действительной части не указан)</target>
        </trans-unit>
        <trans-unit id="eedb8eec778280d3bcff49c582c5fed9ffc52c94" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(+&amp;infin;,NaN)&lt;/code&gt;, the result is &lt;code&gt;(+&amp;infin;,NaN)&lt;/code&gt;</source>
          <target state="translated">Если &lt;code&gt;z&lt;/code&gt; равен &lt;code&gt;(+&amp;infin;,NaN)&lt;/code&gt; , результат равен &lt;code&gt;(+&amp;infin;,NaN)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b7210962b1c353ac908b8a5cf3e83977c0e1052f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(+&amp;infin;,NaN)&lt;/code&gt;, the result is &lt;code&gt;(+0,NaN)&lt;/code&gt;</source>
          <target state="translated">Если &lt;code&gt;z&lt;/code&gt; равен &lt;code&gt;(+&amp;infin;,NaN)&lt;/code&gt; , результат равен &lt;code&gt;(+0,NaN)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9373e34e81874d8368cad6f4032f12ba748b7b06" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(+&amp;infin;,NaN)&lt;/code&gt;, the result is &lt;code&gt;(1,&amp;plusmn;0)&lt;/code&gt; (the sign of the imaginary part is unspecified)</source>
          <target state="translated">Если &lt;code&gt;z&lt;/code&gt; равно &lt;code&gt;(+&amp;infin;,NaN)&lt;/code&gt; , результат равен &lt;code&gt;(1,&amp;plusmn;0)&lt;/code&gt; (знак мнимой части не указан)</target>
        </trans-unit>
        <trans-unit id="856848cafe4c0e36a1ad5ce519dc2788d0c24266" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(+&amp;infin;,y)&lt;/code&gt; (for any finite non-zero y), the result is &lt;code&gt;+&amp;infin;cis(y)&lt;/code&gt;</source>
          <target state="translated">Если &lt;code&gt;z&lt;/code&gt; равен &lt;code&gt;(+&amp;infin;,y)&lt;/code&gt; (для любого конечного ненулевого y), результат равен &lt;code&gt;+&amp;infin;cis(y)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="38ca6940a23e8be06d24918b22d707bed394bbfb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(+&amp;infin;,y)&lt;/code&gt; (for any finite nonzero y), the result is &lt;code&gt;+&amp;infin;cis(y)&lt;/code&gt;</source>
          <target state="translated">Если &lt;code&gt;z&lt;/code&gt; равен &lt;code&gt;(+&amp;infin;,y)&lt;/code&gt; (для любого конечного ненулевого y), результат равен &lt;code&gt;+&amp;infin;cis(y)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="60544872fb73c896e74dc8e5fa99009db9780c61" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(+&amp;infin;,y)&lt;/code&gt; (for any finite positive y), the result is &lt;code&gt;(+&amp;infin;,+0)&lt;/code&gt;</source>
          <target state="translated">Если &lt;code&gt;z&lt;/code&gt; равно &lt;code&gt;(+&amp;infin;,y)&lt;/code&gt; (для любого конечного положительного значения y), результат равен &lt;code&gt;(+&amp;infin;,+0)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ff767095e325e1b139eddcef254efda6cab9a363" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(+&amp;infin;,y)&lt;/code&gt; (for any finite positive y), the result is &lt;code&gt;(+0,&amp;pi;/2)&lt;/code&gt;</source>
          <target state="translated">Если &lt;code&gt;z&lt;/code&gt; равно &lt;code&gt;(+&amp;infin;,y)&lt;/code&gt; (для любого конечного положительного значения y), результат равен &lt;code&gt;(+0,&amp;pi;/2)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f8364d367783724c998297e19343a0b6ad6b6639" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(+&amp;infin;,y)&lt;/code&gt; (for any finite positive y), the result is &lt;code&gt;(1,+0)&lt;/code&gt;</source>
          <target state="translated">Если &lt;code&gt;z&lt;/code&gt; равен &lt;code&gt;(+&amp;infin;,y)&lt;/code&gt; (для любого конечного положительного значения y), результат равен &lt;code&gt;(1,+0)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="22be3e2e16abf84434eed428b48e35f8cb791fa2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(+&amp;infin;,y)&lt;/code&gt; (for any positive finite y), the result is &lt;code&gt;(+&amp;infin;,+0)&lt;/code&gt;</source>
          <target state="translated">Если &lt;code&gt;z&lt;/code&gt; равен &lt;code&gt;(+&amp;infin;,y)&lt;/code&gt; (для любого положительного конечного y), результат равен &lt;code&gt;(+&amp;infin;,+0)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d272464f92e06bbc97dc2b60b9f4b305f104403b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(+&amp;infin;,y)&lt;/code&gt; (for any positive finite y), the result is &lt;code&gt;(+0,-&amp;infin;)&lt;/code&gt;</source>
          <target state="translated">Если &lt;code&gt;z&lt;/code&gt; равен &lt;code&gt;(+&amp;infin;,y)&lt;/code&gt; (для любого положительного конечного y), результат равен &lt;code&gt;(+0,-&amp;infin;)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="306394ed21756723034bdce29c6c92e8e8f975e5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(+&amp;infin;,y)&lt;/code&gt; (for any positive finite y), the result is &lt;code&gt;+&amp;infin;cis(y)&lt;/code&gt;</source>
          <target state="translated">Если &lt;code&gt;z&lt;/code&gt; равен &lt;code&gt;(+&amp;infin;,y)&lt;/code&gt; (для любого положительного конечного y), результат равен &lt;code&gt;+&amp;infin;cis(y)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0345ff8887f149be457a2b367cd95f127874bb66" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(+&amp;infin;,y)&lt;/code&gt;, the result is &lt;code&gt;(+&amp;infin;,+0)&lt;/code&gt; for finite positive y</source>
          <target state="translated">Если &lt;code&gt;z&lt;/code&gt; равен &lt;code&gt;(+&amp;infin;,y)&lt;/code&gt; , результат равен &lt;code&gt;(+&amp;infin;,+0)&lt;/code&gt; для конечного положительного значения y</target>
        </trans-unit>
        <trans-unit id="c635e396c397df4cdf68d1595b6463d80b6d5785" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(+0,+&amp;infin;)&lt;/code&gt;, the result is &lt;code&gt;(&amp;plusmn;0,NaN)&lt;/code&gt; (the sign of the real part is unspecified) and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; is raised</source>
          <target state="translated">Если &lt;code&gt;z&lt;/code&gt; равно &lt;code&gt;(+0,+&amp;infin;)&lt;/code&gt; , результат равен &lt;code&gt;(&amp;plusmn;0,NaN)&lt;/code&gt; (знак действительной части не &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; ) и FE_INVALID повышается</target>
        </trans-unit>
        <trans-unit id="7380faae64287df92ea78c0159ffc49274893e26" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(+0,+&amp;infin;)&lt;/code&gt;, the result is &lt;code&gt;(NaN,&amp;plusmn;0)&lt;/code&gt; (the sign of the imaginary part is unspecified) and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; is raised</source>
          <target state="translated">Если &lt;code&gt;z&lt;/code&gt; равно &lt;code&gt;(+0,+&amp;infin;)&lt;/code&gt; , результат равен &lt;code&gt;(NaN,&amp;plusmn;0)&lt;/code&gt; (знак мнимой части не определен) и &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; повышается</target>
        </trans-unit>
        <trans-unit id="36abdae4241c852caca11998cf42433abb16ad9b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(+0,+0)&lt;/code&gt;, the result is &lt;code&gt;(+0,+0)&lt;/code&gt;</source>
          <target state="translated">Если &lt;code&gt;z&lt;/code&gt; равно &lt;code&gt;(+0,+0)&lt;/code&gt; , результат равен &lt;code&gt;(+0,+0)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e2cc8f6469e515605e9eee8a893ab1a721067296" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(+0,+0)&lt;/code&gt;, the result is &lt;code&gt;(-&amp;infin;,+0)&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_DIVBYZERO&lt;/a&gt;&lt;/code&gt; is raised</source>
          <target state="translated">Если &lt;code&gt;z&lt;/code&gt; равно &lt;code&gt;(+0,+0)&lt;/code&gt; , результат равен &lt;code&gt;(-&amp;infin;,+0)&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_DIVBYZERO&lt;/a&gt;&lt;/code&gt; повышается</target>
        </trans-unit>
        <trans-unit id="7ad221569da1d5607bc6299fce77cb0f1118a11f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(+0,+0)&lt;/code&gt;, the result is &lt;code&gt;(1,+0)&lt;/code&gt;</source>
          <target state="translated">Если &lt;code&gt;z&lt;/code&gt; равно &lt;code&gt;(+0,+0)&lt;/code&gt; , результат равен &lt;code&gt;(1,+0)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="01db2d5ca8d8ffef07cf540c0e3df9bf5160209e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(+0,NaN)&lt;/code&gt;, the result is &lt;code&gt;(&amp;plusmn;0,NaN)&lt;/code&gt;</source>
          <target state="translated">Если &lt;code&gt;z&lt;/code&gt; равно &lt;code&gt;(+0,NaN)&lt;/code&gt; , результат равен &lt;code&gt;(&amp;plusmn;0,NaN)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="89130d186050c98271f4a5474781aa4fa940206d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(+0,NaN)&lt;/code&gt;, the result is &lt;code&gt;(+0,NaN)&lt;/code&gt;</source>
          <target state="translated">Если &lt;code&gt;z&lt;/code&gt; равно &lt;code&gt;(+0,NaN)&lt;/code&gt; , результат равен &lt;code&gt;(+0,NaN)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a6a317cdc33ca73c93da608e61b3b7948bfa218f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(+0,NaN)&lt;/code&gt;, the result is &lt;code&gt;(NaN,&amp;plusmn;0)&lt;/code&gt; (the sign of the imaginary part is unspecified)</source>
          <target state="translated">Если &lt;code&gt;z&lt;/code&gt; равно &lt;code&gt;(+0,NaN)&lt;/code&gt; , результат равен &lt;code&gt;(NaN,&amp;plusmn;0)&lt;/code&gt; (знак мнимой части не указан)</target>
        </trans-unit>
        <trans-unit id="57dcd4bc678fdc22d1a23e97a110d173535b6bb8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(+1,+0)&lt;/code&gt;, the result is &lt;code&gt;(+&amp;infin;,+0)&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_DIVBYZERO&lt;/a&gt;&lt;/code&gt; is raised</source>
          <target state="translated">Если &lt;code&gt;z&lt;/code&gt; равен &lt;code&gt;(+1,+0)&lt;/code&gt; , результат равен &lt;code&gt;(+&amp;infin;,+0)&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_DIVBYZERO&lt;/a&gt;&lt;/code&gt; повышается</target>
        </trans-unit>
        <trans-unit id="874f1995c8e575acb11421be6dbde7ae2969a42f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(-&amp;infin;,+&amp;infin;)&lt;/code&gt;, the result is &lt;code&gt;(&amp;plusmn;0,&amp;plusmn;0)&lt;/code&gt; (signs are unspecified)</source>
          <target state="translated">Если &lt;code&gt;z&lt;/code&gt; равен &lt;code&gt;(-&amp;infin;,+&amp;infin;)&lt;/code&gt; , результат равен &lt;code&gt;(&amp;plusmn;0,&amp;plusmn;0)&lt;/code&gt; (знаки не указаны)</target>
        </trans-unit>
        <trans-unit id="6c365d4aa356678ae4b570fb49e375a4b4ceb0dd" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(-&amp;infin;,+&amp;infin;)&lt;/code&gt;, the result is &lt;code&gt;(+&amp;infin;,3&amp;pi;/4)&lt;/code&gt;</source>
          <target state="translated">Если &lt;code&gt;z&lt;/code&gt; равен &lt;code&gt;(-&amp;infin;,+&amp;infin;)&lt;/code&gt; , результат равен &lt;code&gt;(+&amp;infin;,3&amp;pi;/4)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="253435ca3d0567f0dfee4d306973a5da37660409" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(-&amp;infin;,+&amp;infin;)&lt;/code&gt;, the result is &lt;code&gt;(3&amp;pi;/4,-&amp;infin;)&lt;/code&gt;</source>
          <target state="translated">Если &lt;code&gt;z&lt;/code&gt; равен &lt;code&gt;(-&amp;infin;,+&amp;infin;)&lt;/code&gt; , результат равен &lt;code&gt;(3&amp;pi;/4,-&amp;infin;)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="579af3f5ca612edf51749805e68c03351cf80f69" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(-&amp;infin;,NaN)&lt;/code&gt;, the result is &lt;code&gt;(&amp;plusmn;0,&amp;plusmn;0)&lt;/code&gt; (signs are unspecified)</source>
          <target state="translated">Если &lt;code&gt;z&lt;/code&gt; равен &lt;code&gt;(-&amp;infin;,NaN)&lt;/code&gt; , результат равен &lt;code&gt;(&amp;plusmn;0,&amp;plusmn;0)&lt;/code&gt; (знаки не указаны)</target>
        </trans-unit>
        <trans-unit id="e78b08f96f6d2562376b89afa7f88fc21913df8a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(-&amp;infin;,NaN)&lt;/code&gt;, the result is &lt;code&gt;(NaN,&amp;infin;)&lt;/code&gt; (sign of imaginary part unspecified)</source>
          <target state="translated">Если &lt;code&gt;z&lt;/code&gt; равен &lt;code&gt;(-&amp;infin;,NaN)&lt;/code&gt; , результат равен &lt;code&gt;(NaN,&amp;infin;)&lt;/code&gt; (знак мнимой части не указан)</target>
        </trans-unit>
        <trans-unit id="65dfdfd349a76964ed4ba8c2ee003dcba4c70340" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(-&amp;infin;,y)&lt;/code&gt; (for any finite positive y), the result is &lt;code&gt;(+&amp;infin;,&amp;pi;)&lt;/code&gt;</source>
          <target state="translated">Если &lt;code&gt;z&lt;/code&gt; равен &lt;code&gt;(-&amp;infin;,y)&lt;/code&gt; (для любого конечного положительного y), результат равен &lt;code&gt;(+&amp;infin;,&amp;pi;)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ec76329fb7fb62b9dc71b27cfd5913208f8099b5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(-&amp;infin;,y)&lt;/code&gt; (for any finite y), the result is &lt;code&gt;+0cis(y)&lt;/code&gt;</source>
          <target state="translated">Если &lt;code&gt;z&lt;/code&gt; равен &lt;code&gt;(-&amp;infin;,y)&lt;/code&gt; (для любого конечного y), результат равен &lt;code&gt;+0cis(y)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="75ba7cf268eccbdbd782004a0e2520694fb11834" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(-&amp;infin;,y)&lt;/code&gt; (for any positive finite y), the result is &lt;code&gt;(&amp;pi;,-&amp;infin;)&lt;/code&gt;</source>
          <target state="translated">Если &lt;code&gt;z&lt;/code&gt; равен &lt;code&gt;(-&amp;infin;,y)&lt;/code&gt; (для любого положительного конечного y), результат равен &lt;code&gt;(&amp;pi;,-&amp;infin;)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3891fa076b6dcc15dfa77f17c6418c9b728c5090" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(-&amp;infin;,y)&lt;/code&gt; (for any positive finite y), the result is &lt;code&gt;(+&amp;infin;,&amp;pi;)&lt;/code&gt;</source>
          <target state="translated">Если &lt;code&gt;z&lt;/code&gt; равен &lt;code&gt;(-&amp;infin;,y)&lt;/code&gt; (для любого положительного конечного y), результат равен &lt;code&gt;(+&amp;infin;,&amp;pi;)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="56a1f4835fd2810bef4e8bc0c75c1db28c6329f0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(-&amp;infin;,y)&lt;/code&gt;, the result is &lt;code&gt;(+0,+&amp;infin;)&lt;/code&gt; for finite positive y</source>
          <target state="translated">Если &lt;code&gt;z&lt;/code&gt; равен &lt;code&gt;(-&amp;infin;,y)&lt;/code&gt; , результат равен &lt;code&gt;(+0,+&amp;infin;)&lt;/code&gt; для конечного положительного значения y</target>
        </trans-unit>
        <trans-unit id="5e60ca2bf087c1d87278fedd358c4673cece7420" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(-0,+0)&lt;/code&gt;, the result is &lt;code&gt;(-&amp;infin;,&amp;pi;)&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_DIVBYZERO&lt;/a&gt;&lt;/code&gt; is raised</source>
          <target state="translated">Если &lt;code&gt;z&lt;/code&gt; равен &lt;code&gt;(-0,+0)&lt;/code&gt; , результат равен &lt;code&gt;(-&amp;infin;,&amp;pi;)&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_DIVBYZERO&lt;/a&gt;&lt;/code&gt; повышается</target>
        </trans-unit>
        <trans-unit id="89a4a107a9008e545e92be5b1df1c9b5efa21860" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(NaN,+&amp;infin;)&lt;/code&gt;, the result is &lt;code&gt;(&amp;plusmn;&amp;infin;,NaN)&lt;/code&gt; (the sign of the real part is unspecified)</source>
          <target state="translated">Если &lt;code&gt;z&lt;/code&gt; равен &lt;code&gt;(NaN,+&amp;infin;)&lt;/code&gt; , результат равен &lt;code&gt;(&amp;plusmn;&amp;infin;,NaN)&lt;/code&gt; (знак действительной части не указан)</target>
        </trans-unit>
        <trans-unit id="c1290368fb01d308fdca78b212732f24bae238f5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(NaN,+&amp;infin;)&lt;/code&gt;, the result is &lt;code&gt;(&amp;plusmn;0,&amp;pi;/2)&lt;/code&gt; (the sign of the real part is unspecified)</source>
          <target state="translated">Если &lt;code&gt;z&lt;/code&gt; равен &lt;code&gt;(NaN,+&amp;infin;)&lt;/code&gt; , результат равен &lt;code&gt;(&amp;plusmn;0,&amp;pi;/2)&lt;/code&gt; (знак действительной части не указан)</target>
        </trans-unit>
        <trans-unit id="02167beb857a58577bc43d28d09747ed8b716cf0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(NaN,+&amp;infin;)&lt;/code&gt;, the result is &lt;code&gt;(+&amp;infin;,NaN)&lt;/code&gt;</source>
          <target state="translated">Если &lt;code&gt;z&lt;/code&gt; равен &lt;code&gt;(NaN,+&amp;infin;)&lt;/code&gt; , результат равен &lt;code&gt;(+&amp;infin;,NaN)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f227ab1339277464e7e7720ba15b77847f3dc1c1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(NaN,+&amp;infin;)&lt;/code&gt;, the result is &lt;code&gt;(NaN,-&amp;infin;)&lt;/code&gt;</source>
          <target state="translated">Если &lt;code&gt;z&lt;/code&gt; равен &lt;code&gt;(NaN,+&amp;infin;)&lt;/code&gt; , результат равен &lt;code&gt;(NaN,-&amp;infin;)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="03b1fb212963f9bff1e0e7f5ce1396cadd18c663" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(NaN,+0)&lt;/code&gt;, the result is &lt;code&gt;(NaN,&amp;plusmn;0)&lt;/code&gt; (the sign of the imaginary part is unspecified)</source>
          <target state="translated">Если &lt;code&gt;z&lt;/code&gt; равен &lt;code&gt;(NaN,+0)&lt;/code&gt; , результат равен &lt;code&gt;(NaN,&amp;plusmn;0)&lt;/code&gt; (знак мнимой части не указан)</target>
        </trans-unit>
        <trans-unit id="a0cec12a18e653673a21b6afcf4d2893eaec9952" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(NaN,+0)&lt;/code&gt;, the result is &lt;code&gt;(NaN,+0)&lt;/code&gt;</source>
          <target state="translated">Если &lt;code&gt;z&lt;/code&gt; равен &lt;code&gt;(NaN,+0)&lt;/code&gt; , результат равен &lt;code&gt;(NaN,+0)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="48695bc07467a1b54d439f25c1947991dce4e386" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(NaN,+y)&lt;/code&gt; (for any finite non-zero y), the result is &lt;code&gt;(NaN,NaN)&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; may be raised</source>
          <target state="translated">Если &lt;code&gt;z&lt;/code&gt; равен &lt;code&gt;(NaN,+y)&lt;/code&gt; (для любого конечного ненулевого y), результат равен &lt;code&gt;(NaN,NaN)&lt;/code&gt; и значение &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; может быть повышено</target>
        </trans-unit>
        <trans-unit id="12d365d3a5d388624d62c5ea98bf5be25d94d436" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(NaN,NaN)&lt;/code&gt;, the result is &lt;code&gt;(NaN,NaN)&lt;/code&gt;</source>
          <target state="translated">Если &lt;code&gt;z&lt;/code&gt; равен &lt;code&gt;(NaN,NaN)&lt;/code&gt; , результат равен &lt;code&gt;(NaN,NaN)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="43432f0ad9333692ce4de812743b6a8a23d990f9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(NaN,y)&lt;/code&gt; (for any finite nonzero y), the result is &lt;code&gt;(NaN,NaN)&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; may be raised</source>
          <target state="translated">Если &lt;code&gt;z&lt;/code&gt; равен &lt;code&gt;(NaN,y)&lt;/code&gt; (для любого конечного ненулевого y), результат равен &lt;code&gt;(NaN,NaN)&lt;/code&gt; и значение &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; может быть повышено</target>
        </trans-unit>
        <trans-unit id="a74898800da79711b4ca4b837358da0c34309906" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(NaN,y)&lt;/code&gt; (for any finite y), the result is &lt;code&gt;(NaN,NaN)&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; may be raised</source>
          <target state="translated">Если &lt;code&gt;z&lt;/code&gt; равен &lt;code&gt;(NaN,y)&lt;/code&gt; (для любого конечного y), результат равен &lt;code&gt;(NaN,NaN)&lt;/code&gt; и значение &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; может быть повышено</target>
        </trans-unit>
        <trans-unit id="3986c3fa864e6dfc01234c2970facb3af69b5d42" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(NaN,y)&lt;/code&gt; (for any finite y), the result is &lt;code&gt;(NaN,NaN)&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; may be raised.</source>
          <target state="translated">Если &lt;code&gt;z&lt;/code&gt; равен &lt;code&gt;(NaN,y)&lt;/code&gt; (для любого конечного y), результат равен &lt;code&gt;(NaN,NaN)&lt;/code&gt; и значение &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; может быть повышено.</target>
        </trans-unit>
        <trans-unit id="18e3df5ba9c4d12bc748141c867a2ba815fd8273" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(NaN,y)&lt;/code&gt; (for any non-zero y), the result is &lt;code&gt;(NaN,NaN)&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; may be raised</source>
          <target state="translated">Если &lt;code&gt;z&lt;/code&gt; равен &lt;code&gt;(NaN,y)&lt;/code&gt; (для любого ненулевого y), результат равен &lt;code&gt;(NaN,NaN)&lt;/code&gt; и значение &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; может быть повышено</target>
        </trans-unit>
        <trans-unit id="3b8c5fbb845c531633355abb0a0435a2ec8eaaf0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(NaN,y)&lt;/code&gt; (for any nonzero y), the result is &lt;code&gt;(NaN,NaN)&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; may be raised</source>
          <target state="translated">Если &lt;code&gt;z&lt;/code&gt; равен &lt;code&gt;(NaN,y)&lt;/code&gt; (для любого ненулевого y), результат равен &lt;code&gt;(NaN,NaN)&lt;/code&gt; и значение &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; может быть повышено</target>
        </trans-unit>
        <trans-unit id="29a55443041f03e5d510319aa0568a45742e55ea" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(NaN,y)&lt;/code&gt;, the result is &lt;code&gt;(NaN,NaN)&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; may be raised</source>
          <target state="translated">Если &lt;code&gt;z&lt;/code&gt; равен &lt;code&gt;(NaN,y)&lt;/code&gt; , результат равен &lt;code&gt;(NaN,NaN)&lt;/code&gt; и значение &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; может быть повышено.</target>
        </trans-unit>
        <trans-unit id="df2ad89444d23b170108bda8da8ca9ee00ba6c6b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(x,+&amp;infin;)&lt;/code&gt; (for any finite non-zero x), the result is &lt;code&gt;(NaN,NaN)&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; is raised</source>
          <target state="translated">Если &lt;code&gt;z&lt;/code&gt; равен &lt;code&gt;(x,+&amp;infin;)&lt;/code&gt; (для любого конечного ненулевого x), результат равен &lt;code&gt;(NaN,NaN)&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; повышается</target>
        </trans-unit>
        <trans-unit id="e455efcd2e392de8d756291014af13967751bf1e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(x,+&amp;infin;)&lt;/code&gt; (for any finite positive x), the result is &lt;code&gt;(+0,&amp;pi;/2)&lt;/code&gt;</source>
          <target state="translated">Если &lt;code&gt;z&lt;/code&gt; равен &lt;code&gt;(x,+&amp;infin;)&lt;/code&gt; (для любого конечного положительного x), результат равен &lt;code&gt;(+0,&amp;pi;/2)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f2a071dd3e0155d43198db5c9184d3f7c8860d00" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(x,+&amp;infin;)&lt;/code&gt; (for any finite x), the result is &lt;code&gt;(&amp;pi;/2,-&amp;infin;)&lt;/code&gt;</source>
          <target state="translated">Если &lt;code&gt;z&lt;/code&gt; равен &lt;code&gt;(x,+&amp;infin;)&lt;/code&gt; (для любого конечного x), результат равен &lt;code&gt;(&amp;pi;/2,-&amp;infin;)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="85ebcf7fb682a9f3ba15fca2bb16f8628b521d02" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(x,+&amp;infin;)&lt;/code&gt; (for any finite x), the result is &lt;code&gt;(+&amp;infin;,&amp;pi;/2)&lt;/code&gt;</source>
          <target state="translated">Если &lt;code&gt;z&lt;/code&gt; равен &lt;code&gt;(x,+&amp;infin;)&lt;/code&gt; (для любого конечного x), результат равен &lt;code&gt;(+&amp;infin;,&amp;pi;/2)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8a6ecedf7500b1db3b4febd7f8959d0c1390edf6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(x,+&amp;infin;)&lt;/code&gt; (for any finite x), the result is &lt;code&gt;(NaN,NaN)&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; is raised.</source>
          <target state="translated">Если &lt;code&gt;z&lt;/code&gt; равен &lt;code&gt;(x,+&amp;infin;)&lt;/code&gt; (для любого конечного x), результат равен &lt;code&gt;(NaN,NaN)&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; повышается.</target>
        </trans-unit>
        <trans-unit id="c7886e26ae70e5250a1e0be3778e2c07bd58265c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(x,+&amp;infin;)&lt;/code&gt; (for any positive finite x), the result is &lt;code&gt;(+&amp;infin;,&amp;pi;/2)&lt;/code&gt;</source>
          <target state="translated">Если &lt;code&gt;z&lt;/code&gt; равен &lt;code&gt;(x,+&amp;infin;)&lt;/code&gt; (для любого положительного конечного x), результат равен &lt;code&gt;(+&amp;infin;,&amp;pi;/2)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="fa903ae726de223dfc94489d7c3a22ae1b23a345" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(x,+&amp;infin;)&lt;/code&gt; (for any positive finite x), the result is &lt;code&gt;(NaN,NaN)&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; is raised</source>
          <target state="translated">Если &lt;code&gt;z&lt;/code&gt; равен &lt;code&gt;(x,+&amp;infin;)&lt;/code&gt; (для любого положительного конечного x), результат равен &lt;code&gt;(NaN,NaN)&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; повышается</target>
        </trans-unit>
        <trans-unit id="22db9353e8948056621c723acfc1f37d717bc4e2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(x,+&amp;infin;)&lt;/code&gt; (for any&lt;sup id=&quot;cite_ref-1&quot;&gt;&lt;a href=&quot;tanh#cite_note-1&quot;&gt;[1]&lt;/a&gt;&lt;/sup&gt; finite x), the result is &lt;code&gt;(NaN,NaN)&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; is raised</source>
          <target state="translated">Если &lt;code&gt;z&lt;/code&gt; равен &lt;code&gt;(x,+&amp;infin;)&lt;/code&gt; (для любого &lt;sup id=&quot;cite_ref-1&quot;&gt;&lt;a href=&quot;tanh#cite_note-1&quot;&gt;[1]&lt;/a&gt;&lt;/sup&gt; конечного x), результат равен &lt;code&gt;(NaN,NaN)&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; повышается</target>
        </trans-unit>
        <trans-unit id="0dc41eed06a38a2687f77d174ad8f99a0594fb9f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(x,+&amp;infin;)&lt;/code&gt;, the result is &lt;code&gt;(+&amp;infin;,+&amp;infin;)&lt;/code&gt; even if x is NaN</source>
          <target state="translated">Если &lt;code&gt;z&lt;/code&gt; равен &lt;code&gt;(x,+&amp;infin;)&lt;/code&gt; , результат равен &lt;code&gt;(+&amp;infin;,+&amp;infin;)&lt;/code&gt; , даже если x равен NaN</target>
        </trans-unit>
        <trans-unit id="e9108ce5453cd6b3af30a85d4f435185194ec60d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(x,NaN)&lt;/code&gt; (for any finite non-zero x), the result is &lt;code&gt;(NaN,NaN)&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; may be raised</source>
          <target state="translated">Если &lt;code&gt;z&lt;/code&gt; равен &lt;code&gt;(x,NaN)&lt;/code&gt; (для любого конечного ненулевого x), результат равен &lt;code&gt;(NaN,NaN)&lt;/code&gt; и значение &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; может быть повышено</target>
        </trans-unit>
        <trans-unit id="9b6b50afd0ebe3c85bd3492ea56b4593b842689c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(x,NaN)&lt;/code&gt; (for any finite nonzero x), the result is &lt;code&gt;(NaN,NaN)&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; may be raised</source>
          <target state="translated">Если &lt;code&gt;z&lt;/code&gt; равен &lt;code&gt;(x,NaN)&lt;/code&gt; (для любого конечного ненулевого x), результат равен &lt;code&gt;(NaN,NaN)&lt;/code&gt; и значение &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; может быть повышено</target>
        </trans-unit>
        <trans-unit id="204a160d7ec82f80677f4376caef794a23c51075" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(x,NaN)&lt;/code&gt; (for any finite x), the result is &lt;code&gt;(NaN,NaN)&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; may be raised</source>
          <target state="translated">Если &lt;code&gt;z&lt;/code&gt; равен &lt;code&gt;(x,NaN)&lt;/code&gt; (для любого конечного x), результат равен &lt;code&gt;(NaN,NaN)&lt;/code&gt; и значение &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; может быть повышено</target>
        </trans-unit>
        <trans-unit id="6b650f50d0ed443a6d100ac136e84b4b3bd34bc7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(x,NaN)&lt;/code&gt; (for any finite x), the result is &lt;code&gt;(NaN,NaN)&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; may be raised.</source>
          <target state="translated">Если &lt;code&gt;z&lt;/code&gt; равен &lt;code&gt;(x,NaN)&lt;/code&gt; (для любого конечного x), результат равен &lt;code&gt;(NaN,NaN)&lt;/code&gt; и значение &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; может быть повышено.</target>
        </trans-unit>
        <trans-unit id="5d3a8274e24f46eb6d9b27c393f4df139396e5ca" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(x,NaN)&lt;/code&gt; (for any nonzero finite x), the result is &lt;code&gt;(NaN,NaN)&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; may be raised.</source>
          <target state="translated">Если &lt;code&gt;z&lt;/code&gt; равен &lt;code&gt;(x,NaN)&lt;/code&gt; (для любого ненулевого конечного x), результат равен &lt;code&gt;(NaN,NaN)&lt;/code&gt; , и &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; может быть повышен.</target>
        </trans-unit>
        <trans-unit id="d9b70aa5296158a2ccd9b37fee97192ed5754e1d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(x,NaN)&lt;/code&gt; (for any positive finite x), the result is &lt;code&gt;(NaN,NaN)&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; may be raised</source>
          <target state="translated">Если &lt;code&gt;z&lt;/code&gt; равен &lt;code&gt;(x,NaN)&lt;/code&gt; (для любого положительного конечного x), результат равен &lt;code&gt;(NaN,NaN)&lt;/code&gt; и значение &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; может быть повышено</target>
        </trans-unit>
        <trans-unit id="de160560a0670a88a8b2426dbe34cfbd96bd8f64" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(x,NaN)&lt;/code&gt; (for any&lt;sup id=&quot;cite_ref-1&quot;&gt;&lt;a href=&quot;acosh#cite_note-1&quot;&gt;[1]&lt;/a&gt;&lt;/sup&gt; finite x), the result is &lt;code&gt;(NaN,NaN)&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; may be raised.</source>
          <target state="translated">Если &lt;code&gt;z&lt;/code&gt; равен &lt;code&gt;(x,NaN)&lt;/code&gt; (для любого &lt;sup id=&quot;cite_ref-1&quot;&gt;&lt;a href=&quot;acosh#cite_note-1&quot;&gt;[1]&lt;/a&gt;&lt;/sup&gt; конечного x), результат равен &lt;code&gt;(NaN,NaN)&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; может быть повышено.</target>
        </trans-unit>
        <trans-unit id="bd01cea44335f9b94fea310daa7ab95e4c6b7953" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(x,NaN)&lt;/code&gt; (for any&lt;sup id=&quot;cite_ref-2&quot;&gt;&lt;a href=&quot;tanh#cite_note-2&quot;&gt;[2]&lt;/a&gt;&lt;/sup&gt; finite x), the result is &lt;code&gt;(NaN,NaN)&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; may be raised</source>
          <target state="translated">Если &lt;code&gt;z&lt;/code&gt; равен &lt;code&gt;(x,NaN)&lt;/code&gt; (для любого &lt;sup id=&quot;cite_ref-2&quot;&gt;&lt;a href=&quot;tanh#cite_note-2&quot;&gt;[2]&lt;/a&gt;&lt;/sup&gt; конечного x), результат равен &lt;code&gt;(NaN,NaN)&lt;/code&gt; и значение &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; может быть повышено</target>
        </trans-unit>
        <trans-unit id="d668d6a37cc758c14994156de53988e57bc6b406" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(x,NaN)&lt;/code&gt;, the result is &lt;code&gt;(NaN,NaN)&lt;/code&gt; (unless x is &amp;plusmn;&amp;infin;) and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; may be raised</source>
          <target state="translated">Если &lt;code&gt;z&lt;/code&gt; равен &lt;code&gt;(x,NaN)&lt;/code&gt; , результат равен &lt;code&gt;(NaN,NaN)&lt;/code&gt; (если x не равен &amp;plusmn; &amp;infin;) и &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; может быть повышен</target>
        </trans-unit>
        <trans-unit id="074f956a744f2e0d54cbe071efce74d2c8aa0db4" translate="yes" xml:space="preserve">
          <source>If A was transformed from a function parameter pack, deduction fails.(until C++14) it is compared with each remaining parameter type of the parameter template.(since C++14).</source>
          <target state="translated">Если A была преобразована из пакета параметров функции,то вычитание не удается (до C++14),она сравнивается с каждым оставшимся типом параметра в шаблоне параметра (начиная с C++14).</target>
        </trans-unit>
        <trans-unit id="e0371b0116f4a5b56551a65f008047322bafb01e" translate="yes" xml:space="preserve">
          <source>If C is not an initializer-list constructor and the initializer list has a single element of possibly cv-qualified X, the implicit conversion sequence has Exact Match rank. If the initializer list has a single element of possibly cv-qualified type derived from X, the implicit conversion sequence has Conversion rank. (note the difference from aggregates: aggregates initialize directly from single-element init lists before considering &lt;a href=&quot;aggregate_initialization&quot;&gt;aggregate initialization&lt;/a&gt;, non-aggregates consider initializer_list constructors before any other constructors)</source>
          <target state="translated">Если C не является конструктором списка инициализаторов, а список инициализаторов содержит один элемент, возможно, c-квалифицированного X, последовательность неявного преобразования имеет ранг Exact Match. Если список инициализаторов имеет единственный элемент, возможно, cv-квалифицированного типа, полученный из X, последовательность неявного преобразования имеет ранг преобразования. (обратите внимание на отличие от агрегатов: агрегаты инициализируются непосредственно из одноэлементных списков инициализации, прежде чем рассматривать &lt;a href=&quot;aggregate_initialization&quot;&gt;инициализацию агрегатов&lt;/a&gt; , неагрегаты рассматривают конструкторы initializer_list перед любыми другими конструкторами)</target>
        </trans-unit>
        <trans-unit id="d49d7071128c9d18da1c8f640ffd938c2f5bb26f" translate="yes" xml:space="preserve">
          <source>If P is a function parameter pack, the type A of each remaining parameter type of the argument template is compared with the type P of the declarator-id of the function parameter pack. Each comparison deduces template arguments for subsequent positions in the template parameter packs expanded by the function parameter pack.</source>
          <target state="translated">Если P является пакетом параметров функции,то тип A каждого оставшегося типа параметра шаблона аргумента сравнивается с типом P декларатора-ида пакета параметров функции.Каждое сравнение выводит шаблонные аргументы для последующих позиций в шаблонных пакетах параметров,расширенных пакетом параметров функции.</target>
        </trans-unit>
        <trans-unit id="67a08e610ae0b43d5b7d5de3fee248ad08df296b" translate="yes" xml:space="preserve">
          <source>If Stage 2 was terminated by the test &lt;code&gt;in==end&lt;/code&gt;, &lt;code&gt;err|=&lt;a href=&quot;../../io/ios_base/iostate&quot;&gt;std::ios_base::eofbit&lt;/a&gt;&lt;/code&gt; is executed to set the eof bit.</source>
          <target state="translated">Если этап 2 был завершен тестом &lt;code&gt;in==end&lt;/code&gt; , выполняется &lt;code&gt;err|=&lt;a href=&quot;../../io/ios_base/iostate&quot;&gt;std::ios_base::eofbit&lt;/a&gt;&lt;/code&gt; для установки бита eof.</target>
        </trans-unit>
        <trans-unit id="a0a49b47583d28360f42a9c412de856cbcf247f7" translate="yes" xml:space="preserve">
          <source>If Statements with Initializer</source>
          <target state="translated">Если утверждения с инициализатором</target>
        </trans-unit>
        <trans-unit id="95e34bcbaa3c6e3efcc81854651af3ec74c54e09" translate="yes" xml:space="preserve">
          <source>If UTF-8 code unit produced is &lt;code&gt;u8'\0'&lt;/code&gt;, the conversion state &lt;code&gt;*ps&lt;/code&gt; represents the initial shift state.</source>
          <target state="translated">Если полученная единица кода UTF-8 равна &lt;code&gt;u8'\0'&lt;/code&gt; , состояние преобразования &lt;code&gt;*ps&lt;/code&gt; представляет начальное состояние сдвига.</target>
        </trans-unit>
        <trans-unit id="5031b0f6e6a8ffbd0c86254f140591158ac1c1ed" translate="yes" xml:space="preserve">
          <source>If UTF-8 encoding of the multibyte character in &lt;code&gt;*s&lt;/code&gt; consists of more than one UTF-8 code unit, then after the first call to this function, &lt;code&gt;*ps&lt;/code&gt; is updated in such a way that the next call to &lt;code&gt;mbrtoc8&lt;/code&gt; will write out the additional UTF-8 code units, without considering &lt;code&gt;*s&lt;/code&gt;.</source>
          <target state="translated">Если кодирование UTF-8 многобайтового символа в &lt;code&gt;*s&lt;/code&gt; состоит из более чем одной кодовой единицы UTF-8, то после первого вызова этой функции &lt;code&gt;*ps&lt;/code&gt; обновляется таким образом, что следующий вызов &lt;code&gt;mbrtoc8&lt;/code&gt; запишет дополнительные единицы кода UTF-8, без учета &lt;code&gt;*s&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="57e85fdf8664c8892feaa0067e2ab68c323b2c7e" translate="yes" xml:space="preserve">
          <source>If a &lt;a href=&quot;friend&quot;&gt;friend&lt;/a&gt; declaration specifies a default, it must be a friend function definition, and no other declarations of this function are allowed in the translation unit.</source>
          <target state="translated">Если объявление &lt;a href=&quot;friend&quot;&gt;друга&lt;/a&gt; указывает значение по умолчанию, оно должно быть определением функции друга, и никакие другие объявления этой функции не допускаются в модуле перевода.</target>
        </trans-unit>
        <trans-unit id="af125d901495baa7e68ae6bf7e676c729a2e9e7d" translate="yes" xml:space="preserve">
          <source>If a &lt;a href=&quot;lambda&quot;&gt;lambda-expression&lt;/a&gt; appears in a default argument, it cannot explicitly or implicitly capture anything.</source>
          <target state="translated">Если &lt;a href=&quot;lambda&quot;&gt;лямбда-выражение&lt;/a&gt; появляется в аргументе по умолчанию, оно не может явно или неявно захватить что-либо.</target>
        </trans-unit>
        <trans-unit id="a76f53af271b5a909124051c648419560af0ae0d" translate="yes" xml:space="preserve">
          <source>If a &lt;a href=&quot;parameter_pack&quot;&gt;parameter pack&lt;/a&gt; appears as the last &lt;code&gt;P&lt;/code&gt;, then the type &lt;code&gt;P&lt;/code&gt; is matched against the type &lt;code&gt;A&lt;/code&gt; of each remaining argument of the call. Each match deduces the template arguments for the next position in the pack expansion:</source>
          <target state="translated">Если &lt;a href=&quot;parameter_pack&quot;&gt;пакет параметров&lt;/a&gt; появляется как последний &lt;code&gt;P&lt;/code&gt; , то тип &lt;code&gt;P&lt;/code&gt; сопоставляется с типом &lt;code&gt;A&lt;/code&gt; каждого оставшегося аргумента вызова. Каждое совпадение выводит аргументы шаблона для следующей позиции в пакете расширения:</target>
        </trans-unit>
        <trans-unit id="b41eca314d823a30b3d9356e848b0ef641d30e0a" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;choose&lt;/code&gt; is not passed and an ambiguous or nonexistent local time is encountered, a &lt;code&gt;std::chrono::ambiguous_local_time&lt;/code&gt; or &lt;code&gt;std::chrono::nonexistent_local_time&lt;/code&gt; exception (as applicable) will be thrown.</source>
          <target state="translated">Если &lt;code&gt;choose&lt;/code&gt; не пройден и встречается неоднозначное или несуществующее местное время, будет &lt;code&gt;std::chrono::nonexistent_local_time&lt;/code&gt; исключение &lt;code&gt;std::chrono::ambiguous_local_time&lt;/code&gt; или std :: chrono :: nonexistent_local_time (в зависимости от ситуации).</target>
        </trans-unit>
        <trans-unit id="b0232a855656fad38033f04cd7d4e9aba797f804" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;va_list&lt;/code&gt; instance is created, passed to another function, and used via &lt;code&gt;&lt;a href=&quot;va_arg&quot;&gt;va_arg&lt;/a&gt;&lt;/code&gt; in that function, then any subsequent use in the calling function should be preceded by a call to &lt;code&gt;&lt;a href=&quot;va_end&quot;&gt;va_end&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Если экземпляр &lt;code&gt;va_list&lt;/code&gt; создается, передается другой функции и используется через &lt;code&gt;&lt;a href=&quot;va_arg&quot;&gt;va_arg&lt;/a&gt;&lt;/code&gt; в этой функции, то любому последующему использованию в вызывающей функции должен предшествовать вызов &lt;code&gt;&lt;a href=&quot;va_end&quot;&gt;va_end&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="80b021b3e6bb48d6dea03f2d437af9bc0159b35f" translate="yes" xml:space="preserve">
          <source>If a MoveAssignable class implements a move assignment operator, it may also implement &lt;a href=&quot;../utility/move&quot;&gt;move semantics&lt;/a&gt; to take advantage of the fact that the value of &lt;code&gt;rv&lt;/code&gt; after assignment is unspecified.</source>
          <target state="translated">Если класс MoveAssignable реализует оператор присваивания перемещения, он также может реализовывать &lt;a href=&quot;../utility/move&quot;&gt;семантику перемещения,&lt;/a&gt; чтобы использовать тот факт, что значение &lt;code&gt;rv&lt;/code&gt; после присваивания не определено.</target>
        </trans-unit>
        <trans-unit id="50fd9c6db39f2b44036e6dd5cc6b5f20e25a53df" translate="yes" xml:space="preserve">
          <source>If a MoveConstructible class implements a move constructor, it may also implement &lt;a href=&quot;../utility/move&quot;&gt;move semantics&lt;/a&gt; to take advantage of the fact that the value of &lt;code&gt;rv&lt;/code&gt; after construction is unspecified.</source>
          <target state="translated">Если класс MoveConstructible реализует конструктор перемещения, он также может реализовать &lt;a href=&quot;../utility/move&quot;&gt;семантику перемещения,&lt;/a&gt; чтобы воспользоваться тем фактом, что значение &lt;code&gt;rv&lt;/code&gt; после построения не определено.</target>
        </trans-unit>
        <trans-unit id="db6d3d9d7cd4ba49aa12646a4de72f6a71fe9090" translate="yes" xml:space="preserve">
          <source>If a UTF-8 string literal and a wide string literal are side by side, the program is ill-formed.</source>
          <target state="translated">Если рядом находится строковый литерал UTF-8 и широкий строковый литерал,то программа плохо сформирована.</target>
        </trans-unit>
        <trans-unit id="2e7730383bc958aa60b61242e15f22a8a4d39ba2" translate="yes" xml:space="preserve">
          <source>If a call had been made to &lt;a href=&quot;sync&quot;&gt;&lt;code&gt;sync&lt;/code&gt;&lt;/a&gt; since the last call to &lt;code&gt;emit()&lt;/code&gt;, then also flushes the wrapped stream by calling &lt;a href=&quot;../basic_streambuf/pubsync&quot;&gt;&lt;code&gt;pubsync()&lt;/code&gt;&lt;/a&gt; on it.</source>
          <target state="translated">Если вызов был сделан для &lt;a href=&quot;sync&quot;&gt; &lt;code&gt;sync&lt;/code&gt; &lt;/a&gt; с момента последнего вызова &lt;code&gt;emit()&lt;/code&gt; , а затем также промывает обернутый поток, вызвав &lt;a href=&quot;../basic_streambuf/pubsync&quot;&gt; &lt;code&gt;pubsync()&lt;/code&gt; &lt;/a&gt; на нем.</target>
        </trans-unit>
        <trans-unit id="0ea2bfcf7eb556e144def8831349ca368e38aca7" translate="yes" xml:space="preserve">
          <source>If a call to &lt;code&gt;sprintf&lt;/code&gt; or &lt;code&gt;snprintf&lt;/code&gt; causes copying to take place between objects that overlap, the behavior is undefined (e.g. &lt;code&gt;sprintf(buf, &quot;%s text&quot;, buf);&lt;/code&gt;).</source>
          <target state="translated">Если вызов &lt;code&gt;sprintf&lt;/code&gt; или &lt;code&gt;snprintf&lt;/code&gt; вызывает копирование между перекрывающимися объектами, поведение не определено (например, &lt;code&gt;sprintf(buf, &quot;%s text&quot;, buf);&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="c3aa22cbaf61ec140e43d901a3568b282d2888df" translate="yes" xml:space="preserve">
          <source>If a call to &lt;code&gt;try_lock&lt;/code&gt; fails, no further call to &lt;code&gt;try_lock&lt;/code&gt; is performed, &lt;code&gt;unlock&lt;/code&gt; is called for any locked objects and a &lt;code&gt;0&lt;/code&gt;-based index of the object that failed to lock is returned.</source>
          <target state="translated">Если вызов &lt;code&gt;try_lock&lt;/code&gt; неудачен, то дальнейший вызов &lt;code&gt;try_lock&lt;/code&gt; не выполняются, &lt;code&gt;unlock&lt;/code&gt; вызывается для любых заблокированных объектов и &lt;code&gt;0&lt;/code&gt; -На индекса объекта , который не смог замок возвращается.</target>
        </trans-unit>
        <trans-unit id="42b5fe2f519d0b2189f00f6cdee376383897d0d8" translate="yes" xml:space="preserve">
          <source>If a call to &lt;code&gt;try_lock&lt;/code&gt; results in an exception, &lt;code&gt;unlock&lt;/code&gt; is called for any locked objects before rethrowing.</source>
          <target state="translated">Если вызов &lt;code&gt;try_lock&lt;/code&gt; приводит к исключению, для любых заблокированных объектов перед &lt;code&gt;unlock&lt;/code&gt; вызывается разблокировка .</target>
        </trans-unit>
        <trans-unit id="409e5d2187197971805f527baaf18e9e29ae37c9" translate="yes" xml:space="preserve">
          <source>If a call to &lt;code&gt;wrapper()&lt;/code&gt; passes a const lvalue &lt;code&gt;std::string&lt;/code&gt;, then &lt;code&gt;T&lt;/code&gt; is deduced to &lt;code&gt;const std::string&amp;amp;&lt;/code&gt;, and &lt;code&gt;std::forward&lt;/code&gt; ensures that a const lvalue reference is passed to &lt;code&gt;foo&lt;/code&gt;.</source>
          <target state="translated">Если вызов &lt;code&gt;wrapper()&lt;/code&gt; передает const lvalue &lt;code&gt;std::string&lt;/code&gt; , то &lt;code&gt;T&lt;/code&gt; выводится в &lt;code&gt;const std::string&amp;amp;&lt;/code&gt; , а &lt;code&gt;std::forward&lt;/code&gt; гарантирует, что ссылка на const lvalue передается в &lt;code&gt;foo&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="60d636afcff594f21611dd719c9b59be1be77be5" translate="yes" xml:space="preserve">
          <source>If a call to &lt;code&gt;wrapper()&lt;/code&gt; passes a non-const lvalue &lt;code&gt;std::string&lt;/code&gt;, then &lt;code&gt;T&lt;/code&gt; is deduced to &lt;code&gt;std::string&amp;amp;&lt;/code&gt;, and &lt;code&gt;std::forward&lt;/code&gt; ensures that a non-const lvalue reference is passed to &lt;code&gt;foo&lt;/code&gt;.</source>
          <target state="translated">Если вызов &lt;code&gt;wrapper()&lt;/code&gt; передает неконстантное lvalue &lt;code&gt;std::string&lt;/code&gt; , то &lt;code&gt;T&lt;/code&gt; выводится в &lt;code&gt;std::string&amp;amp;&lt;/code&gt; , а &lt;code&gt;std::forward&lt;/code&gt; гарантирует, что неконстантная ссылка lvalue передается в &lt;code&gt;foo&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="531e469ff5d08b04534632e848505259a8c9345f" translate="yes" xml:space="preserve">
          <source>If a call to &lt;code&gt;wrapper()&lt;/code&gt; passes an rvalue &lt;code&gt;std::string&lt;/code&gt;, then &lt;code&gt;T&lt;/code&gt; is deduced to &lt;code&gt;std::string&lt;/code&gt; (not &lt;code&gt;std::string&amp;amp;&lt;/code&gt;, &lt;code&gt;const std::string&amp;amp;&lt;/code&gt;, or &lt;code&gt;std::string&amp;amp;&amp;amp;&lt;/code&gt;), and &lt;code&gt;std::forward&lt;/code&gt; ensures that an rvalue reference is passed to &lt;code&gt;foo&lt;/code&gt;.</source>
          <target state="translated">Если вызов функции &lt;code&gt;wrapper()&lt;/code&gt; передает rvalue &lt;code&gt;std::string&lt;/code&gt; , то &lt;code&gt;T&lt;/code&gt; выводится в &lt;code&gt;std::string&lt;/code&gt; (не &lt;code&gt;std::string&amp;amp;&lt;/code&gt; , &lt;code&gt;const std::string&amp;amp;&lt;/code&gt; или &lt;code&gt;std::string&amp;amp;&amp;amp;&lt;/code&gt; ), и &lt;code&gt;std::forward&lt;/code&gt; обеспечивает что ссылка на rvalue передается в &lt;code&gt;foo&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3db6809411e108c8a32250227388ae4694cdc2d7" translate="yes" xml:space="preserve">
          <source>If a capacity change takes place, all iterators and references, including the past-the-end iterator, are invalidated.</source>
          <target state="translated">При изменении емкости все итераторы и ссылки,включая итератор прошлых лет,считаются недействительными.</target>
        </trans-unit>
        <trans-unit id="91f5ccbd4323fb5f3ed4c55a818cff6f60b92726" translate="yes" xml:space="preserve">
          <source>If a capture list has a capture-default and does not explicitly capture the enclosing object (as &lt;code&gt;this&lt;/code&gt; or &lt;code&gt;*this&lt;/code&gt;) or an automatic variable, it captures it</source>
          <target state="translated">Если список захвата имеет значение захвата по умолчанию и явно не захватывает вмещающий объект (как &lt;code&gt;this&lt;/code&gt; или &lt;code&gt;*this&lt;/code&gt; ) или автоматическую переменную, он захватывает его</target>
        </trans-unit>
        <trans-unit id="7dd621d8a6ec99fac9a316fb824dc230d2630614" translate="yes" xml:space="preserve">
          <source>If a catch-clause for a derived class is placed after the catch-clause for a base class, the derived catch-clause will never be executed.</source>
          <target state="translated">Если причиной для производного класса является catch-clause для базового класса,то производный catch-clause никогда не будет выполнен.</target>
        </trans-unit>
        <trans-unit id="20b89c206d6d992d89351af992dfddfea294ca6c" translate="yes" xml:space="preserve">
          <source>If a class has a public virtual destructor, it can be derived from, and the derived object can be safely deleted through a pointer to the base object (&lt;a href=&quot;http://www.gotw.ca/publications/mill18.htm&quot;&gt;GotW #18&lt;/a&gt;).</source>
          <target state="translated">Если у класса есть общедоступный виртуальный деструктор, он может быть получен из него, и производный объект может быть безопасно удален с помощью указателя на базовый объект ( &lt;a href=&quot;http://www.gotw.ca/publications/mill18.htm&quot;&gt;GotW # 18&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="d189c715668bfca07f195aaf55d2d525ebbeda96" translate="yes" xml:space="preserve">
          <source>If a class requires a user-defined &lt;a href=&quot;destructor&quot;&gt;destructor&lt;/a&gt;, a user-defined &lt;a href=&quot;copy_constructor&quot;&gt;copy constructor&lt;/a&gt;, or a user-defined &lt;a href=&quot;as_operator&quot;&gt;copy assignment operator&lt;/a&gt;, it almost certainly requires all three.</source>
          <target state="translated">Если классу требуется пользовательский &lt;a href=&quot;destructor&quot;&gt;деструктор&lt;/a&gt; , пользовательский &lt;a href=&quot;copy_constructor&quot;&gt;конструктор копирования&lt;/a&gt; или пользовательский &lt;a href=&quot;as_operator&quot;&gt;оператор присваивания копии&lt;/a&gt; , он почти наверняка требует все три.</target>
        </trans-unit>
        <trans-unit id="d0521b23151547cdfdf59688f7fc84d8f6a00c6f" translate="yes" xml:space="preserve">
          <source>If a class template has been declared, but not defined, at the point of instantiation, the instantiation yields an incomplete class type:</source>
          <target state="translated">Если в момент инстанцирования шаблон класса был объявлен,но не определен,то инстанцирование дает неполный тип класса:</target>
        </trans-unit>
        <trans-unit id="5de1ec538e9a507f38c522094bdfc9ac9990681e" translate="yes" xml:space="preserve">
          <source>If a const non-inline(since C++17) static data member or a constexpr static data member(since C++11) is &lt;a href=&quot;definition#ODR-use&quot;&gt;odr-used&lt;/a&gt;, a definition at namespace scope is still required, but it cannot have an initializer. This definition is deprecated for &lt;code&gt;constexpr&lt;/code&gt; data members(since C++17).</source>
          <target state="translated">Если постоянный не встроенный (начиная с C ++ 17) элемент статических данных или член статических данных constexpr (начиная с C ++ 11) используется &lt;a href=&quot;definition#ODR-use&quot;&gt;odr&lt;/a&gt; , определение в области пространства имен все еще требуется, но не может иметь инициализатора. Это определение не рекомендуется для &lt;code&gt;constexpr&lt;/code&gt; данных constexpr (начиная с C ++ 17).</target>
        </trans-unit>
        <trans-unit id="23a184ea03d379e5295d8a06a9fb5d4d84026185" translate="yes" xml:space="preserve">
          <source>If a constexpr if statement appears inside a &lt;a href=&quot;templates#Templated_entity&quot;&gt;templated entity&lt;/a&gt;, and if condition is not &lt;a href=&quot;dependent_name#Value-dependent_expressions&quot;&gt;value-dependent&lt;/a&gt; after instantiation, the discarded statement is not instantiated when the enclosing template is instantiated .</source>
          <target state="translated">Если оператор constexpr if появляется внутри &lt;a href=&quot;templates#Templated_entity&quot;&gt;шаблонной сущности&lt;/a&gt; , и если условие не &lt;a href=&quot;dependent_name#Value-dependent_expressions&quot;&gt;зависит от значения&lt;/a&gt; после создания экземпляра, исключенный оператор не создается при создании экземпляра вмещающего шаблона.</target>
        </trans-unit>
        <trans-unit id="d387511a4c202656145b74050dd24c2d4377d5ea" translate="yes" xml:space="preserve">
          <source>If a constructor template or conversion function template has an &lt;a href=&quot;explicit&quot;&gt;conditional explicit specifier&lt;/a&gt; which happens to be &lt;a href=&quot;dependent_name#Value-dependent_expressions&quot;&gt;value-dependent&lt;/a&gt;, after deduction, if the context requires a candidate that is not explicit and the generated specialization is explicit, it is removed from the candidate set.</source>
          <target state="translated">Если шаблон конструктора или шаблон функции преобразования имеет &lt;a href=&quot;explicit&quot;&gt;условный явный спецификатор,&lt;/a&gt; который оказывается &lt;a href=&quot;dependent_name#Value-dependent_expressions&quot;&gt;зависимым от значения&lt;/a&gt; , то после вывода, если контекст требует не явного кандидата, а сгенерированная специализация явная, он удаляется из набора кандидатов.</target>
        </trans-unit>
        <trans-unit id="e7cac551c36c79f3db2d3cd4de291ee906f04949" translate="yes" xml:space="preserve">
          <source>If a contract condition of a virtual function &lt;code&gt;f&lt;/code&gt; odr-uses &lt;code&gt;*this&lt;/code&gt;, the class of which &lt;code&gt;f&lt;/code&gt; is a direct member must be an unambiguous and accessible base class of any class in which &lt;code&gt;f&lt;/code&gt; is overridden.</source>
          <target state="translated">Если условие контракта виртуальной функции &lt;code&gt;f&lt;/code&gt; odr использует &lt;code&gt;*this&lt;/code&gt; , класс, непосредственным членом которого является &lt;code&gt;f&lt;/code&gt; , должен быть однозначным и доступным базовым классом любого класса, в котором &lt;code&gt;f&lt;/code&gt; переопределяется.</target>
        </trans-unit>
        <trans-unit id="a62eb301fbc04938195faede31c45cafa349ad46" translate="yes" xml:space="preserve">
          <source>If a conversion specification is invalid, the behavior is undefined.</source>
          <target state="translated">Если спецификация преобразования недействительна,поведение не определено.</target>
        </trans-unit>
        <trans-unit id="5705ed552a56d6bfbeab747c83e7be8483a52343" translate="yes" xml:space="preserve">
          <source>If a data race occurs, the behavior of the program is undefined.</source>
          <target state="translated">Если происходит гонка данных,поведение программы не определено.</target>
        </trans-unit>
        <trans-unit id="882bf051762ba2c1ce6191c7588fe5e3cee6567e" translate="yes" xml:space="preserve">
          <source>If a declaration introduces a variable with automatic storage duration, it is initialized when its declaration statement is executed. All automatic variables declared in a block are destroyed on exit from the block (regardless how the block is exited: via &lt;a href=&quot;exceptions&quot;&gt;exception&lt;/a&gt;, &lt;a href=&quot;goto&quot;&gt;goto&lt;/a&gt;, or by reaching its end), in order opposite to their order of initialization.</source>
          <target state="translated">Если в объявлении вводится переменная с автоматическим сроком хранения, она инициализируется при выполнении оператора объявления. Все автоматические переменные, объявленные в блоке, уничтожаются при выходе из блока (независимо от того, как выходит блок: через &lt;a href=&quot;exceptions&quot;&gt;исключение&lt;/a&gt; , &lt;a href=&quot;goto&quot;&gt;goto&lt;/a&gt; или по достижении его конца), в порядке, обратном порядку их инициализации.</target>
        </trans-unit>
        <trans-unit id="43c8efd199427ba6a640175787f51c9fb916e92f" translate="yes" xml:space="preserve">
          <source>If a delegating constructor exits with an exception after the non-delegating constructor successfully completed, the destructor for this object is called.</source>
          <target state="translated">Если делегирующий конструктор выходит с исключением после успешного завершения работы неразрушающего конструктора,вызывается деструктор для этого объекта.</target>
        </trans-unit>
        <trans-unit id="1ac2fdfac54931742b99e44e4aa9aeaa05c1d2d6" translate="yes" xml:space="preserve">
          <source>If a destructor reset the terminate handler during stack unwinding and the unwinding later led to &lt;code&gt;terminate&lt;/code&gt; being called, the handler that was installed at the end of the throw expression is the one that will be called. (note: it was ambiguous whether re-throwing applied the new handlers).</source>
          <target state="translated">Если деструктор сбрасывает обработчик завершения во время разматывания стека и последующее разматывание приводило к вызову &lt;code&gt;terminate&lt;/code&gt; будет вызван обработчик, который был установлен в конце выражения броска. (примечание: было неоднозначно, применил ли re-throwing новые обработчики).</target>
        </trans-unit>
        <trans-unit id="753c6e50ab4e318d953d5637b772a0f352fda59e" translate="yes" xml:space="preserve">
          <source>If a destructor reset the terminate handler during stack unwinding, it is unspecified which handler is called if the unwinding later led to &lt;code&gt;terminate&lt;/code&gt; being called.</source>
          <target state="translated">Если деструктор сбрасывает обработчик завершения во время разматывания стека, то не указано, какой обработчик вызывается, если последующее разматывание привело к &lt;code&gt;terminate&lt;/code&gt; вызова.</target>
        </trans-unit>
        <trans-unit id="482827679143ed383496ea91dbd86707c7632c8b" translate="yes" xml:space="preserve">
          <source>If a destructor reset the unexpected handler during stack unwinding and the unwinding later led to &lt;code&gt;unexpected&lt;/code&gt; being called, the handler that was installed at the end of the throw expression is the one that will be called. (note: it was ambiguous whether re-throwing applied the new handlers).</source>
          <target state="translated">Если деструктор сбрасывал неожиданный обработчик во время разматывания стека, а последующее разматывание приводило к &lt;code&gt;unexpected&lt;/code&gt; вызову, то будет вызван обработчик, который был установлен в конце выражения броска. (примечание: было неоднозначно, применил ли re-throwing новые обработчики).</target>
        </trans-unit>
        <trans-unit id="f833e8b1ca41ece97da3b5dfb8d80f4a17d92a84" translate="yes" xml:space="preserve">
          <source>If a destructor reset the unexpected handler during stack unwinding, it is unspecified which handler is called if the unwinding later led to &lt;code&gt;unexpected&lt;/code&gt; being called.</source>
          <target state="translated">Если деструктор сбрасывает неожиданный обработчик во время разматывания стека, то не указано, какой обработчик вызывается, если последующее разматывание привело к &lt;code&gt;unexpected&lt;/code&gt; вызову .</target>
        </trans-unit>
        <trans-unit id="3b53fae349713df5efc757fb7b33531c67e72c29" translate="yes" xml:space="preserve">
          <source>If a domain error occurs, an implementation-defined value (NaN where supported) is returned.</source>
          <target state="translated">При возникновении ошибки домена возвращается значение,определяемое реализацией (NaN,где поддерживается).</target>
        </trans-unit>
        <trans-unit id="daaa304029da34d0537dff7e88f32d7146eac438" translate="yes" xml:space="preserve">
          <source>If a domain error occurs, an implementation-defined value is returned (NaN where supported).</source>
          <target state="translated">При возникновении ошибки домена возвращается значение,определяемое реализацией (NaN,где поддерживается).</target>
        </trans-unit>
        <trans-unit id="8a2b2a5d22410f7c139500bf2d1ad8bd3daffb21" translate="yes" xml:space="preserve">
          <source>If a domain error occurs, an implementation-defined value is returned.</source>
          <target state="translated">При возникновении ошибки домена возвращается значение,определяемое реализацией.</target>
        </trans-unit>
        <trans-unit id="fc6ec94615e1c6cf0e59aab22eb031064112889e" translate="yes" xml:space="preserve">
          <source>If a file or a directory is deleted or added to the directory tree after the directory iterator has been created, it is unspecified whether the change would be observed through the iterator.</source>
          <target state="translated">Если файл или каталог удаляется или добавляется в дерево каталогов после создания итератора каталогов,неизвестно,будет ли изменение наблюдаться через итератор.</target>
        </trans-unit>
        <trans-unit id="3724f8b6f7d15be8a8f1594573af0e22249ce20e" translate="yes" xml:space="preserve">
          <source>If a file or a directory is deleted or added to the directory tree after the recursive directory iterator has been created, it is unspecified whether the change would be observed through the iterator.</source>
          <target state="translated">Если файл или каталог удаляется или добавляется в дерево каталогов после создания итератора рекурсивного каталога,неизвестно,будет ли изменение наблюдаться через итератор.</target>
        </trans-unit>
        <trans-unit id="39efafdede79fd69777a0e208a3fd4446a9e9cf1" translate="yes" xml:space="preserve">
          <source>If a friend declaration is the first declaration of the function in a translation unit and has a contract condition, that declaration must be a definition and must be the only declaration of the function in the translation unit:</source>
          <target state="translated">Если декларация друга является первым объявлением функции в переводческой единице и имеет договорное условие,то такое объявление должно быть определением и должно быть единственным объявлением функции в переводческой единице:</target>
        </trans-unit>
        <trans-unit id="9348fef8e416c767f68b83ba99d0f25cfef8feda" translate="yes" xml:space="preserve">
          <source>If a function declared nodiscard or a function returning an enumeration or class declared nodiscard by value is called from a &lt;a href=&quot;../expressions#Discarded-value_expressions&quot;&gt;discarded-value expression&lt;/a&gt; other than a cast to void, the compiler is encouraged to issue a warning.</source>
          <target state="translated">Если функция, объявленная как nodiscard, или функция, возвращающая перечисление или класс, объявленный как nodiscard по значению, вызывается из &lt;a href=&quot;../expressions#Discarded-value_expressions&quot;&gt;выражения отброшенного значения,&lt;/a&gt; отличного от преобразования в void, компилятору рекомендуется выдать предупреждение.</target>
        </trans-unit>
        <trans-unit id="0e42988e69c29f9c1e608a2f0ffd727f5c2644ec" translate="yes" xml:space="preserve">
          <source>If a function exits via an exception, &lt;code&gt;&lt;a href=&quot;../../error/terminate&quot;&gt;std::terminate&lt;/a&gt;&lt;/code&gt; is called.</source>
          <target state="translated">Если функция выходит через исключение, вызывается &lt;code&gt;&lt;a href=&quot;../../error/terminate&quot;&gt;std::terminate&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ad964142a18dcc049d042a23d7d71322620a52d8" translate="yes" xml:space="preserve">
          <source>If a function has more than one final overrider, the program is ill-formed:</source>
          <target state="translated">Если функция имеет более одного конечного переопределителя,то программа плохо сформирована:</target>
        </trans-unit>
        <trans-unit id="bafd7cb9d12f56ccf89ae9b7b4d93ed2022e34a5" translate="yes" xml:space="preserve">
          <source>If a function is declared &lt;code&gt;[[optimize_for_synchronized]]&lt;/code&gt; in one translation unit and the same function is declared without &lt;code&gt;[[optimize_for_synchronized]]&lt;/code&gt; in another translation unit, the program is ill-formed; no diagnostic required.</source>
          <target state="translated">Если функция объявлена &lt;code&gt;[[optimize_for_synchronized]]&lt;/code&gt; в одном модуле перевода, и та же функция объявлена ​​без &lt;code&gt;[[optimize_for_synchronized]]&lt;/code&gt; в другом модуле перевода, программа некорректна; Диагностика не требуется.</target>
        </trans-unit>
        <trans-unit id="e3f9e3de669a5122870e6bc1eb5118c628c85194" translate="yes" xml:space="preserve">
          <source>If a function is declared with the specifier &lt;code&gt;final&lt;/code&gt;, and another function attempts to override it, the program is ill-formed:</source>
          <target state="translated">Если функция объявлена ​​со спецификатором &lt;code&gt;final&lt;/code&gt; , и другая функция пытается ее переопределить, программа некорректна:</target>
        </trans-unit>
        <trans-unit id="3888ddb42cb2148d436948685603df58149529f7" translate="yes" xml:space="preserve">
          <source>If a function is declared with the specifier &lt;code&gt;override&lt;/code&gt;, but does not override a virtual function, the program is ill-formed:</source>
          <target state="translated">Если функция объявлена ​​с &lt;code&gt;override&lt;/code&gt; спецификатора , но не переопределяет виртуальную функцию, программа некорректна:</target>
        </trans-unit>
        <trans-unit id="2f9f7412482ccba02363ec8e1d82ccc1ed257746" translate="yes" xml:space="preserve">
          <source>If a function is declared with type &lt;code&gt;T&lt;/code&gt; listed in its exception specification, the function may throw exceptions of that type or a type derived from it.</source>
          <target state="translated">Если функция объявлена ​​с типом &lt;code&gt;T&lt;/code&gt; , указанным в спецификации исключений, она может выдавать исключения этого типа или производного от него типа.</target>
        </trans-unit>
        <trans-unit id="0815633756bffaa6b84ff1cbf11092af43ee34c1" translate="yes" xml:space="preserve">
          <source>If a function or a variable exists in scope with the name identical to the name of a class type, &lt;code&gt;class&lt;/code&gt; can be prepended to the name for disambiguation, resulting in an &lt;a href=&quot;../language/elaborated_type_specifier&quot;&gt;elaborated type specifier&lt;/a&gt;</source>
          <target state="translated">Если в области видимости существует функция или переменная с именем, идентичным имени типа класса, &lt;code&gt;class&lt;/code&gt; может быть добавлен перед именем для устранения неоднозначности, что приводит к &lt;a href=&quot;../language/elaborated_type_specifier&quot;&gt;сложному описателю типа&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="43617584a5c434806ea859f8354d597162e188ea" translate="yes" xml:space="preserve">
          <source>If a function or a variable exists in scope with the name identical to the name of a non-union class type, &lt;code&gt;struct&lt;/code&gt; can be prepended to the name for disambiguation, resulting in an &lt;a href=&quot;../language/elaborated_type_specifier&quot;&gt;elaborated type specifier&lt;/a&gt;</source>
          <target state="translated">Если в области видимости существует функция или переменная с именем, идентичным имени типа класса, не являющегося объединением, &lt;code&gt;struct&lt;/code&gt; может быть добавлена ​​к имени для устранения неоднозначности, что приводит к &lt;a href=&quot;../language/elaborated_type_specifier&quot;&gt;сложному описателю типа&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="33c372b62b38e3e28c4c2d8049dc573ffb3184eb" translate="yes" xml:space="preserve">
          <source>If a function or a variable exists in scope with the name identical to the name of a union type, &lt;code&gt;union&lt;/code&gt; can be prepended to the name for disambiguation, resulting in an &lt;a href=&quot;../language/elaborated_type_specifier&quot;&gt;elaborated type specifier&lt;/a&gt;</source>
          <target state="translated">Если в области видимости существует функция или переменная с именем, идентичным имени типа объединения, для устранения неоднозначности перед ней может быть добавлен &lt;code&gt;union&lt;/code&gt; , что приводит к &lt;a href=&quot;../language/elaborated_type_specifier&quot;&gt;сложному описателю типа.&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="3caf3302d65692054c0bd57d280ffa6d4243e44a" translate="yes" xml:space="preserve">
          <source>If a function overrides more than one function, all of the overridden functions must have the same list of contract conditions; no diagnostic is required if corresponding conditions will always evaluate to the same value.</source>
          <target state="translated">Если функция переопределяет несколько функций,все переопределенные функции должны иметь один и тот же список условий договора;диагностика не требуется,если соответствующие условия всегда будут оцениваться до одного и того же значения.</target>
        </trans-unit>
        <trans-unit id="135a8489da58532d74209fec452fabacfcbf21c6" translate="yes" xml:space="preserve">
          <source>If a function template, variable template, member function template, or member function or static data member of a class template is explicitly instantiated with an explicit instantiation definition, the template definition must be present in the same translation unit.</source>
          <target state="translated">Если шаблон функции,шаблон переменной,шаблон функции-членов или шаблон функции-членов или статических данных шаблона класса явно инстанцирован явным определением инстанцирования,то определение шаблона должно присутствовать в той же единице трансляции.</target>
        </trans-unit>
        <trans-unit id="f8f1e8e53e9248772a5ae660d45da68b260826d4" translate="yes" xml:space="preserve">
          <source>If a function that is not transaction-safe is called through a reference or pointer to a transaction-safe function, the behavior is undefined.</source>
          <target state="translated">Если функция,не являющаяся безопасной для транзакций,вызывается по ссылке или по указателю на функцию,обеспечивающую безопасность транзакций,поведение не определено.</target>
        </trans-unit>
        <trans-unit id="0bde24db3435358d326a5b26dc4f5fb9a3ee4c50" translate="yes" xml:space="preserve">
          <source>If a function uses return type deduction, it cannot be redeclared using the type that it deduces to, or another kind of return type deduction even if it deduces to the same type.</source>
          <target state="translated">Если функция использует вычет типа возврата,она не может быть декларирована заново с использованием типа,к которому вычитается,или другого типа вычета типа возврата,даже если вычитается к тому же самому типу.</target>
        </trans-unit>
        <trans-unit id="26770c3740e0e9cd92c88700d97b6e2c4081721f" translate="yes" xml:space="preserve">
          <source>If a function was introduced by a using-declaration, declaring a function with the same name and parameter list is ill-formed (unless the declaration is for the same function). If a function template was introduced by a using-declaration, declaring a function template with the same name, parameter type list, return type, and template parameter list is ill-formed. Two using-declarations can introduce functions with the same name and parameter list, but if a call to that function is attempted, the program is ill-formed.</source>
          <target state="translated">Если функция была введена путем использования-декларирования,объявление функции с тем же именем и списком параметров является неверным (если только объявление не для той же самой функции).Если шаблон функции был введен путем использования-декларирования,то декларирование шаблона функции с тем же именем,списка типов параметров,возвращаемого типа и списка параметров шаблона выполняется плохо (если только декларирование не выполняется для той же функции).Две декларации использования могут вводить функции с тем же именем и список параметров,но если попытка вызова этой функции предпринята,то программа плохо сформирована.</target>
        </trans-unit>
        <trans-unit id="e751efac5a78fb2353ecab041674493ffe914d58" translate="yes" xml:space="preserve">
          <source>If a function-local (block-scope) static object was destroyed and then that function is called from the destructor of another static object and the control flow passes through the definition of that object (or if it is used indirectly, via pointer or reference), the behavior is undefined.</source>
          <target state="translated">Если уничтожен статический объект-локаль (блок-скоп),а затем эта функция вызывается из деструктора другого статического объекта,и поток управления проходит через определение этого объекта (или если он используется косвенно,по указателю или по ссылке),то поведение не определено.</target>
        </trans-unit>
        <trans-unit id="a5179d5f0b6b560d982bb76be1dd9a627d77214d" translate="yes" xml:space="preserve">
          <source>If a get area exists (e.g. the file was opened for reading), the effect is implementation-defined. Typical implementation may empty out the get area and move the current file position back by the corresponding number of bytes.</source>
          <target state="translated">Если область get существует (например,файл был открыт для чтения),то эффект определяется реализацией.Типичная реализация может опустошить область get и переместить текущую позицию файла обратно на соответствующее количество байт.</target>
        </trans-unit>
        <trans-unit id="5b16daea89246b1eee5a59e08c141c8e46338b5b" translate="yes" xml:space="preserve">
          <source>If a lambda captures the enclosing object (as &lt;code&gt;this&lt;/code&gt; or &lt;code&gt;*this&lt;/code&gt;), either the nearest enclosing function must be a non-static member function or the lambda must be in a &lt;a href=&quot;data_members#Member_initialization&quot;&gt;default member initializer&lt;/a&gt;:</source>
          <target state="translated">Если лямбда захватывает охватывающий объект (как &lt;code&gt;this&lt;/code&gt; или &lt;code&gt;*this&lt;/code&gt; ), либо ближайшая включающая функция должна быть нестатической функцией-членом, либо лямбда должна быть в &lt;a href=&quot;data_members#Member_initialization&quot;&gt;инициализаторе члена по умолчанию&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="cfdecd26d4d9885f6eeae96917954311b903b67d" translate="yes" xml:space="preserve">
          <source>If a lambda expression (or an instantiation of a generic lambda's function call operator) ODR-uses &lt;code&gt;this&lt;/code&gt; or any variable with automatic storage duration, it must be captured by the lambda expression.</source>
          <target state="translated">Если лямбда-выражение (или экземпляр универсального оператора вызова функции лямбда-функции) ODR использует &lt;code&gt;this&lt;/code&gt; или любую переменную с автоматической продолжительностью хранения, оно должно быть захвачено лямбда-выражением.</target>
        </trans-unit>
        <trans-unit id="c9245324f25aa6ef3f3a921517ba752285940aaf" translate="yes" xml:space="preserve">
          <source>If a lambda odr-uses a reference that is captured by reference, it is using the object referred-to by the original reference, not the captured reference itself:</source>
          <target state="translated">Если лямбда odr использует ссылку,которая была захвачена с помощью ссылки,то она использует объект,на который была сделана ссылка,а не саму ссылку:</target>
        </trans-unit>
        <trans-unit id="1da4cd3d4148fc5555feb74d4e942788fe474123" translate="yes" xml:space="preserve">
          <source>If a lambda-expression appears in a &lt;a href=&quot;default_arguments&quot;&gt;default argument&lt;/a&gt;, it cannot explicitly or implicitly capture anything.</source>
          <target state="translated">Если лямбда-выражение появляется в &lt;a href=&quot;default_arguments&quot;&gt;аргументе по умолчанию&lt;/a&gt; , оно не может явно или неявно захватить что-либо.</target>
        </trans-unit>
        <trans-unit id="e34c58387ec074a0a7abef6761392718c559bb60" translate="yes" xml:space="preserve">
          <source>If a member has a default member initializer and also appears in the member initialization list in a constructor, the default member initializer is ignored.</source>
          <target state="translated">Если член имеет инициализатор по умолчанию,а также появляется в списке инициализации члена в конструкторе,инициализатор члена по умолчанию игнорируется.</target>
        </trans-unit>
        <trans-unit id="f6c0536efbdc9b49435039f82fb9fa51a3523c3e" translate="yes" xml:space="preserve">
          <source>If a name is used in a class body before it is declared, and another declaration for that name is in scope, the program is &lt;a href=&quot;ub&quot;&gt;ill-formed, no diagnostic required&lt;/a&gt;.</source>
          <target state="translated">Если имя используется в теле класса до того, как оно объявлено, а другое объявление для этого имени находится в области действия, программа &lt;a href=&quot;ub&quot;&gt;некорректна, диагностика не требуется&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="73b765e29ed3c027cc3bcfba763673a78b12e25b" translate="yes" xml:space="preserve">
          <source>If a narrowing conversion is required, other than from an integral type to a floating point type, the program is ill-formed.</source>
          <target state="translated">Если требуется сужение преобразования,кроме приведения интегрального типа к типу с плавающей точкой,то программа плохо сформирована.</target>
        </trans-unit>
        <trans-unit id="a10165cb0c4c283cd3dc5405e46c820a8e3f7689" translate="yes" xml:space="preserve">
          <source>If a nested lambda &lt;code&gt;m2&lt;/code&gt; captures something that is also captured by the immediately enclosing lambda &lt;code&gt;m1&lt;/code&gt;, then &lt;code&gt;m2&lt;/code&gt;'s capture is transformed as follows:</source>
          <target state="translated">Если вложенная лямбда- &lt;code&gt;m2&lt;/code&gt; захватывает что-то, что также захватывается непосредственно вмещающей лямбда- &lt;code&gt;m1&lt;/code&gt; , то захват &lt;code&gt;m2&lt;/code&gt; преобразуется следующим образом:</target>
        </trans-unit>
        <trans-unit id="35c0cb6d4e19455e10fc3b8d1fea7080305eff39" translate="yes" xml:space="preserve">
          <source>If a new object is created at the address that was occupied by another object, then all pointers, references, and the name of the original object will automatically refer to the new object and, once the lifetime of the new object begins, can be used to manipulate the new object, but only if the following conditions are satisfied:</source>
          <target state="translated">Если новый объект создан по адресу,который был занят другим объектом,то все указатели,ссылки и имя оригинального объекта будут автоматически ссылаться на новый объект и,как только начнется время жизни нового объекта,можно будет использовать для манипулирования новым объектом,но только при соблюдении следующих условий:</target>
        </trans-unit>
        <trans-unit id="040c4b92d07b4519ff12ccd42bcfa061a377c5b4" translate="yes" xml:space="preserve">
          <source>If a non-reference entity is captured by reference, implicitly or explicitly, and the function call operator of the closure object is invoked after the entity's lifetime has ended, undefined behavior occurs. The C++ closures do not extend the lifetimes of the captured references.</source>
          <target state="translated">Если сущность,на которую не делается ссылка,захватывается по ссылке,неявно или явно,и после окончания жизни сущности вызывается оператор вызова функции объекта закрытия,то происходит неопределенное поведение.Закрытие С++не продлевает время жизни захваченных ссылок.</target>
        </trans-unit>
        <trans-unit id="4ceaa0be0f1cb1c411ff6ee0a8d7f52ed257f167" translate="yes" xml:space="preserve">
          <source>If a non-static data member has an &lt;a href=&quot;data_members#Member_initialization&quot;&gt;default member initializer&lt;/a&gt; and also appears in a member initializer list, then member initializer list is executed and the default member initializer is ignored:</source>
          <target state="translated">Если нестатический элемент данных имеет &lt;a href=&quot;data_members#Member_initialization&quot;&gt;инициализатор элемента по умолчанию,&lt;/a&gt; а также появляется в списке инициализатора элемента, выполняется список инициализатора элемента, а инициализатор элемента по умолчанию игнорируется:</target>
        </trans-unit>
        <trans-unit id="0aab394949317f4e8f5352a010f660fb204a47ce" translate="yes" xml:space="preserve">
          <source>If a non-type template parameter is used in the parameter list, and the corresponding template argument is deduced, the type of the deduced template argument ( as specified in its enclosing template parameter list, meaning references are preserved) must match the type of the non-type template parameter exactly, except that cv-qualifiers are dropped, and except where the template argument is deduced from an array bound&amp;mdash;in that case any integral type is allowed, even bool though it would always become true:</source>
          <target state="translated">Если в списке параметров используется нетипичный параметр шаблона, и выводится соответствующий аргумент шаблона, тип выведенного аргумента шаблона (как указано в прилагаемом списке параметров шаблона, то есть ссылки сохраняются) должен соответствовать типу в точности нетипичный параметр шаблона, за исключением того, что cv-квалификаторы отбрасываются, и кроме случаев, когда аргумент шаблона выводится из границы массива - в этом случае допускается любой целочисленный тип, даже bool, хотя он всегда становится истинным:</target>
        </trans-unit>
        <trans-unit id="6a9d189d5910a05ceacbf1d41469dc00391c4252" translate="yes" xml:space="preserve">
          <source>If a pack expansion is nested within another pack expansion, the parameter packs that appear inside the innermost pack expansion are expanded by it, and there must be another pack mentioned in the enclosing pack expansion, but not in the innermost one:</source>
          <target state="translated">Если пакетное расширение вложено в другое пакетное расширение,то пакеты параметров,которые появляются внутри самого внутреннего пакетного расширения,расширяются им,и должна быть другая упаковка,упомянутая в пакете-расширении,но не в самом внутреннем:</target>
        </trans-unit>
        <trans-unit id="0444eb973f9088dccc9bd6e7338a1a6d154f5d7f" translate="yes" xml:space="preserve">
          <source>If a parsing error is encountered, many implementations of this function leave &lt;code&gt;*t&lt;/code&gt; completely untouched.</source>
          <target state="translated">Если возникает ошибка синтаксического анализа, многие реализации этой функции оставляют &lt;code&gt;*t&lt;/code&gt; полностью нетронутыми.</target>
        </trans-unit>
        <trans-unit id="7dfecd9ffd391c85c521dbadb0fe904c065d326a" translate="yes" xml:space="preserve">
          <source>If a parsing error is encountered, most implementations of this function leave &lt;code&gt;*t&lt;/code&gt; unmodified.</source>
          <target state="translated">Если возникает ошибка синтаксического анализа, большинство реализаций этой функции оставляют &lt;code&gt;*t&lt;/code&gt; неизмененным.</target>
        </trans-unit>
        <trans-unit id="dcfd421c1a105975620bdb3e159a6ef656b96d8e" translate="yes" xml:space="preserve">
          <source>If a partial specialization of the member template is explicitly specialized for a given (implicit) specialization of the enclosing class template, the primary member template and its other partial specializations are still considered for this specialization of the enclosing class template.</source>
          <target state="translated">Если частичная специализация шаблона-членов явно специализирована для заданной (неявной)специализации шаблона класса-поставщика,то шаблон первичного члена и другие его частичные специализации все равно рассматриваются для этой специализации шаблона класса-поставщика.</target>
        </trans-unit>
        <trans-unit id="5e69c709c0eda47248b870b79a0045971cbc9fb3" translate="yes" xml:space="preserve">
          <source>If a pointer &lt;code&gt;p&lt;/code&gt;</source>
          <target state="translated">Если указатель &lt;code&gt;p&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="95fa4aab00b2248a193df0012ce51bbbfdcb0a2a" translate="yes" xml:space="preserve">
          <source>If a pole error occurs, &lt;code&gt;&amp;plusmn;HUGE_VAL&lt;/code&gt;, &lt;code&gt;&amp;plusmn;HUGE_VALF&lt;/code&gt;, or &lt;code&gt;&amp;plusmn;HUGE_VALL&lt;/code&gt; is returned (with the correct sign).</source>
          <target state="translated">Если возникает ошибка полюса, &lt;code&gt;&amp;plusmn;HUGE_VAL&lt;/code&gt; , &lt;code&gt;&amp;plusmn;HUGE_VALF&lt;/code&gt; или &lt;code&gt;&amp;plusmn;HUGE_VALL&lt;/code&gt; (с правильным знаком).</target>
        </trans-unit>
        <trans-unit id="88c1375fb3e07154fab82fd39487a150f20a7acc" translate="yes" xml:space="preserve">
          <source>If a pole error occurs, &lt;code&gt;&amp;plusmn;HUGE_VAL&lt;/code&gt;, &lt;code&gt;&amp;plusmn;HUGE_VALF&lt;/code&gt;, or &lt;code&gt;&amp;plusmn;HUGE_VALL&lt;/code&gt; is returned.</source>
          <target state="translated">Если возникает ошибка полюса, &lt;code&gt;&amp;plusmn;HUGE_VAL&lt;/code&gt; , &lt;code&gt;&amp;plusmn;HUGE_VALF&lt;/code&gt; или &lt;code&gt;&amp;plusmn;HUGE_VALL&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="83547df0814e730591b9f631b39a107992bddaca" translate="yes" xml:space="preserve">
          <source>If a pole error occurs, &lt;code&gt;+HUGE_VAL&lt;/code&gt;, &lt;code&gt;+HUGE_VALF&lt;/code&gt;, or &lt;code&gt;+HUGE_VALL&lt;/code&gt; is returned.</source>
          <target state="translated">Если возникает ошибка полюса, &lt;code&gt;+HUGE_VAL&lt;/code&gt; , &lt;code&gt;+HUGE_VALF&lt;/code&gt; или &lt;code&gt;+HUGE_VALL&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="55c8a2c8fff5d682aefd99723282ecf86b260cc3" translate="yes" xml:space="preserve">
          <source>If a pole error occurs, &lt;code&gt;-HUGE_VAL&lt;/code&gt;, &lt;code&gt;-HUGE_VALF&lt;/code&gt;, or &lt;code&gt;-HUGE_VALL&lt;/code&gt; is returned.</source>
          <target state="translated">Если возникает ошибка полюса, возвращается &lt;code&gt;-HUGE_VAL&lt;/code&gt; , &lt;code&gt;-HUGE_VALF&lt;/code&gt; или &lt;code&gt;-HUGE_VALL&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1aad32c287435bd724b2b2cd991a06c95727932d" translate="yes" xml:space="preserve">
          <source>If a pole error or a range error due to overflow occurs, &lt;code&gt;&amp;plusmn;HUGE_VAL&lt;/code&gt;, &lt;code&gt;&amp;plusmn;HUGE_VALF&lt;/code&gt;, or &lt;code&gt;&amp;plusmn;HUGE_VALL&lt;/code&gt; is returned.</source>
          <target state="translated">Если возникает ошибка полюса или ошибка диапазона из-за переполнения, &lt;code&gt;&amp;plusmn;HUGE_VAL&lt;/code&gt; , &lt;code&gt;&amp;plusmn;HUGE_VALF&lt;/code&gt; или &lt;code&gt;&amp;plusmn;HUGE_VALL&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fd506f2079e184fcad156bfb8a88cdf9abf44715" translate="yes" xml:space="preserve">
          <source>If a postcondition &lt;a href=&quot;../definition#ODR-use&quot;&gt;odr-uses&lt;/a&gt; a parameter in its predicate and the function body modifies the value of that parameter directly or indirectly, the behavior is undefined.</source>
          <target state="translated">Если постусловие &lt;a href=&quot;../definition#ODR-use&quot;&gt;odr-использует&lt;/a&gt; параметр в своем предикате и тело функции изменяет значение этого параметра прямо или косвенно, поведение не определено.</target>
        </trans-unit>
        <trans-unit id="d235423e2c4c1707a767d1a11cf327433b3567be" translate="yes" xml:space="preserve">
          <source>If a postcondition is violated, the source location reflected in the &lt;code&gt;std::contract_violation&lt;/code&gt; argument is the source location of the function definition.</source>
          <target state="translated">Если постусловие нарушено, местоположение источника, отраженное в аргументе &lt;code&gt;std::contract_violation&lt;/code&gt; является местоположением источника определения функции.</target>
        </trans-unit>
        <trans-unit id="8288ef9f3911668bdd42ba2bba9a0191080ea46e" translate="yes" xml:space="preserve">
          <source>If a precondition is violated, the source location reflected in the &lt;code&gt;std::contract_violation&lt;/code&gt; argument is implementation-defined.</source>
          <target state="translated">Если предварительное условие нарушается, местоположение источника, отраженное в аргументе &lt;code&gt;std::contract_violation&lt;/code&gt; определяется реализацией.</target>
        </trans-unit>
        <trans-unit id="ef5fcd9d7689008da5f0e4bea11cd119b6efa160" translate="yes" xml:space="preserve">
          <source>If a primary template is a member of another class template, its partial specializations are members of the enclosing class template. If the enclosing template is instantiated, the declaration of each member partial specialization is instantiated as well (the same way declarations, but not definitions, of all other members of a template are instantiated).</source>
          <target state="translated">Если первичный шаблон является членом шаблона другого класса,то его частичные специализации являются членами прилагаемого шаблона класса.Если прилагаемый шаблон инстанцируется,то инстанцируется и заявление о частичной специализации каждого члена класса (таким же образом инстанцируются заявления,но не определения всех других членов шаблона).</target>
        </trans-unit>
        <trans-unit id="18b3bedb6ae9572a6c3106b7d4be5f3ebdfc4df2" translate="yes" xml:space="preserve">
          <source>If a program contains declarations of function templates that are</source>
          <target state="translated">Если программа содержит объявления шаблонов функций,которые являются</target>
        </trans-unit>
        <trans-unit id="87ffbc04e56c0394a3ecec919c439f807e6404bc" translate="yes" xml:space="preserve">
          <source>If a put area exist (e.g. file was opened for writing), first calls &lt;code&gt;overflow(Traits::eof())&lt;/code&gt; to write all pending output to the file, including any unshift sequences.</source>
          <target state="translated">Если существует область размещения (например, файл был открыт для записи), сначала вызывается &lt;code&gt;overflow(Traits::eof())&lt;/code&gt; чтобы записать все ожидающие выходные данные в файл, включая любые последовательности без смещения.</target>
        </trans-unit>
        <trans-unit id="919f0fed96116787f70c42581aa4648db9ff5450" translate="yes" xml:space="preserve">
          <source>If a put area exists (e.g. the file was opened for writing), calls &lt;code&gt;&lt;a href=&quot;../basic_streambuf/overflow&quot;&gt;overflow()&lt;/a&gt;&lt;/code&gt; to write all pending output to the file, then flushes the file as if by calling &lt;code&gt;&lt;a href=&quot;../c/fflush&quot;&gt;std::fflush&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Если область размещения существует (например, файл был открыт для записи), вызывает метод &lt;code&gt;&lt;a href=&quot;../basic_streambuf/overflow&quot;&gt;overflow()&lt;/a&gt;&lt;/code&gt; для записи всех ожидающих результатов в файл, а затем очищает файл, как если бы он вызывал &lt;code&gt;&lt;a href=&quot;../c/fflush&quot;&gt;std::fflush&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="776889337c5b506a958bcb11170f9049bdd28571" translate="yes" xml:space="preserve">
          <source>If a putback position is available in the get area (&lt;code&gt;gptr() &amp;gt; eback()&lt;/code&gt;), and the character &lt;code&gt;c&lt;/code&gt; is equal to the character one position to the left of &lt;code&gt;&lt;a href=&quot;gptr&quot;&gt;gptr()&lt;/a&gt;&lt;/code&gt; (as determined by &lt;code&gt;Traits::eq(c, gptr()[-1])&lt;/code&gt;, then simply decrements the next pointer (&lt;code&gt;&lt;a href=&quot;gptr&quot;&gt;gptr()&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">Если в зоне get доступна позиция возврата ( &lt;code&gt;gptr() &amp;gt; eback()&lt;/code&gt; ), а символ &lt;code&gt;c&lt;/code&gt; равен позиции символа слева от &lt;code&gt;&lt;a href=&quot;gptr&quot;&gt;gptr()&lt;/a&gt;&lt;/code&gt; (как определено в &lt;code&gt;Traits::eq(c, gptr()[-1])&lt;/code&gt; , затем просто уменьшает следующий указатель ( &lt;code&gt;&lt;a href=&quot;gptr&quot;&gt;gptr()&lt;/a&gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="9cb9d7c878f7f8a77860594336867a6041aa5088" translate="yes" xml:space="preserve">
          <source>If a putback position is available in the get area (&lt;code&gt;gptr() &amp;gt; eback()&lt;/code&gt;), then decrements the next pointer (&lt;code&gt;&lt;a href=&quot;gptr&quot;&gt;gptr()&lt;/a&gt;&lt;/code&gt;) and returns the character it now points to.</source>
          <target state="translated">Если в области get доступна позиция возврата ( &lt;code&gt;gptr() &amp;gt; eback()&lt;/code&gt; ), то уменьшается следующий указатель ( &lt;code&gt;&lt;a href=&quot;gptr&quot;&gt;gptr()&lt;/a&gt;&lt;/code&gt; ) и возвращается символ, на который он теперь указывает.</target>
        </trans-unit>
        <trans-unit id="79ac53d959c455debaf74453ed6b72c19ac11dfa" translate="yes" xml:space="preserve">
          <source>If a putback position is not available, then calls &lt;code&gt;&lt;a href=&quot;pbackfail&quot;&gt;pbackfail()&lt;/a&gt;&lt;/code&gt; to back up the input sequence if possible.</source>
          <target state="translated">Если позиция возврата недоступна, тогда вызывается &lt;code&gt;&lt;a href=&quot;pbackfail&quot;&gt;pbackfail()&lt;/a&gt;&lt;/code&gt; для резервного копирования последовательности ввода, если это возможно.</target>
        </trans-unit>
        <trans-unit id="5c9db649e4e6e4c38883de06799ee045378481d1" translate="yes" xml:space="preserve">
          <source>If a range error due to overflow occurs, &lt;code&gt;&amp;plusmn;HUGE_VAL&lt;/code&gt;, &lt;code&gt;&amp;plusmn;HUGE_VALF&lt;/code&gt;, or &lt;code&gt;&amp;plusmn;HUGE_VALL&lt;/code&gt; is returned (with the same sign as &lt;code&gt;from&lt;/code&gt;).</source>
          <target state="translated">Если возникает ошибка диапазона из-за переполнения, &lt;code&gt;&amp;plusmn;HUGE_VAL&lt;/code&gt; , &lt;code&gt;&amp;plusmn;HUGE_VALF&lt;/code&gt; или &lt;code&gt;&amp;plusmn;HUGE_VALL&lt;/code&gt; (с тем же знаком, что и &lt;code&gt;from&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="9842b2827c672e6e4b846cc1f4ef41186aaaf5f3" translate="yes" xml:space="preserve">
          <source>If a range error due to overflow occurs, &lt;code&gt;&amp;plusmn;HUGE_VAL&lt;/code&gt;, &lt;code&gt;&amp;plusmn;HUGE_VALF&lt;/code&gt;, or &lt;code&gt;&amp;plusmn;HUGE_VALL&lt;/code&gt; is returned.</source>
          <target state="translated">Если возникает ошибка диапазона из-за переполнения, &lt;code&gt;&amp;plusmn;HUGE_VAL&lt;/code&gt; , &lt;code&gt;&amp;plusmn;HUGE_VALF&lt;/code&gt; или &lt;code&gt;&amp;plusmn;HUGE_VALL&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9e1bf2f0df7137552a9579d23123773adeb14193" translate="yes" xml:space="preserve">
          <source>If a range error due to overflow occurs, &lt;code&gt;+HUGE_VAL&lt;/code&gt;, &lt;code&gt;+HUGE_VALF&lt;/code&gt;, or &lt;code&gt;+HUGE_VALL&lt;/code&gt; is returned.</source>
          <target state="translated">Если возникает ошибка диапазона из-за переполнения, &lt;code&gt;+HUGE_VAL&lt;/code&gt; , &lt;code&gt;+HUGE_VALF&lt;/code&gt; или &lt;code&gt;+HUGE_VALL&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="55d9e5e2db658de793b6612e1c8dc0adb82837dc" translate="yes" xml:space="preserve">
          <source>If a range error due to underflow occurs, the correct result (after rounding) is returned.</source>
          <target state="translated">При ошибке диапазона из-за недопотока возвращается правильный результат (после округления).</target>
        </trans-unit>
        <trans-unit id="144f2afda2da10823b65a9e4c24a0b3bb37c9913" translate="yes" xml:space="preserve">
          <source>If a range error due to underflow occurs, the correct value (after rounding) is returned.</source>
          <target state="translated">При ошибке диапазона из-за недопотока возвращается правильное значение (после округления).</target>
        </trans-unit>
        <trans-unit id="949156f77460641cf432a3cc1721f1ed036f3731" translate="yes" xml:space="preserve">
          <source>If a range error occurs due to underflow, the correct result (after rounding) is returned.</source>
          <target state="translated">При ошибке диапазона из-за недопотока возвращается правильный результат (после округления).</target>
        </trans-unit>
        <trans-unit id="48f1515a1657338dc5a4774929668cb3a0851098" translate="yes" xml:space="preserve">
          <source>If a range error occurs due to underflow, the correct result (after rounding), that is.</source>
          <target state="translated">Если ошибка диапазона возникает из-за недопотока,то правильный результат (после округления),то есть.</target>
        </trans-unit>
        <trans-unit id="bea570ee8fcad0dd93ebf596f86eddc89718e8ce" translate="yes" xml:space="preserve">
          <source>If a range error occurs due to underflow, the correct result is returned if subnormals are supported.</source>
          <target state="translated">Если из-за недопотока возникает ошибка диапазона,возвращается правильный результат,если поддерживаются субнормальные значения.</target>
        </trans-unit>
        <trans-unit id="4771fa50f8d7229b07b35621538a1aac36cd67a9" translate="yes" xml:space="preserve">
          <source>If a range error occurs due to underflow, the correct result is returned.</source>
          <target state="translated">При ошибке диапазона из-за недопотока возвращается правильный результат.</target>
        </trans-unit>
        <trans-unit id="ccb8e801dc7894cca248dbed67f56627d7cf0cc4" translate="yes" xml:space="preserve">
          <source>If a read or write error occurs, the error indicator (&lt;code&gt;&lt;a href=&quot;ferror&quot;&gt;std::ferror&lt;/a&gt;&lt;/code&gt;)for the stream is set.</source>
          <target state="translated">Если происходит ошибка чтения или записи, устанавливается индикатор ошибки ( &lt;code&gt;&lt;a href=&quot;ferror&quot;&gt;std::ferror&lt;/a&gt;&lt;/code&gt; ) для потока.</target>
        </trans-unit>
        <trans-unit id="e789f3da6463649b436aef5182ff1d2b5da92664" translate="yes" xml:space="preserve">
          <source>If a read or write error occurs, the error indicator for the stream (&lt;code&gt;&lt;a href=&quot;ferror&quot;&gt;std::ferror&lt;/a&gt;&lt;/code&gt;) is set and the file position is unaffected.</source>
          <target state="translated">Если происходит ошибка чтения или записи, устанавливается индикатор ошибки для потока ( &lt;code&gt;&lt;a href=&quot;ferror&quot;&gt;std::ferror&lt;/a&gt;&lt;/code&gt; ) и положение файла не изменяется.</target>
        </trans-unit>
        <trans-unit id="86b3ac21433e164a790502ba1ef0db8db078e961" translate="yes" xml:space="preserve">
          <source>If a requires-expression contains invalid types or expressions in its requirements, and it does not appear within the declaration of a &lt;a href=&quot;templates#Templated_entity&quot;&gt;templated entity&lt;/a&gt;, then the program is ill-formed.</source>
          <target state="translated">Если выражение require содержит недопустимые типы или выражения в своих требованиях, и оно не появляется в объявлении &lt;a href=&quot;templates#Templated_entity&quot;&gt;шаблонной сущности&lt;/a&gt; , то программа является некорректной.</target>
        </trans-unit>
        <trans-unit id="4b01d79ca1850a7a1aa26257022da9a9b9591827" translate="yes" xml:space="preserve">
          <source>If a rewritten candidate is selected by overload resolution for an operator &lt;code&gt;@&lt;/code&gt;, &lt;code&gt;x @ y&lt;/code&gt; is interpreted as the rewritten expression: &lt;code&gt;0 @ (y &amp;lt;=&amp;gt; x)&lt;/code&gt; if the selected candidate is a synthesized candidate with reversed order of parameters, or &lt;code&gt;(x &amp;lt;=&amp;gt; y) @ 0&lt;/code&gt; otherwise, using the selected rewritten &lt;code&gt;operator&amp;lt;=&amp;gt;&lt;/code&gt; candidate.</source>
          <target state="translated">Если переписанный кандидат выбран с помощью разрешения перегрузки для оператора &lt;code&gt;@&lt;/code&gt; , &lt;code&gt;x @ y&lt;/code&gt; интерпретируется как переписанное выражение: &lt;code&gt;0 @ (y &amp;lt;=&amp;gt; x)&lt;/code&gt; если выбранный кандидат является синтезированным кандидатом с обратным порядком параметров, или &lt;code&gt;(x &amp;lt;=&amp;gt; y) @ 0&lt;/code&gt; противном случае, используя выбранный переписанный &lt;code&gt;operator&amp;lt;=&amp;gt;&lt;/code&gt; кандидата.</target>
        </trans-unit>
        <trans-unit id="d146da8681a775135daad12f043cc5018dc0ef5e" translate="yes" xml:space="preserve">
          <source>If a signal handler is executed as a result of a call to &lt;code&gt;&lt;a href=&quot;raise&quot;&gt;std::raise&lt;/a&gt;&lt;/code&gt; (synchronously), then the execution of the handler is</source>
          <target state="translated">Если обработчик сигнала выполняется в результате вызова &lt;code&gt;&lt;a href=&quot;raise&quot;&gt;std::raise&lt;/a&gt;&lt;/code&gt; (синхронно), то выполнение обработчика</target>
        </trans-unit>
        <trans-unit id="3f5eeae6c512283e05fb7f521150bb498afe542b" translate="yes" xml:space="preserve">
          <source>If a standard-layout &lt;a href=&quot;union&quot;&gt;union&lt;/a&gt; holds two (or more) standard-layout classes as members, and these classes have a common initial sequence of data members, it is well-defined to examine any member of that common initial sequence regardless of which member of the union is active.</source>
          <target state="translated">Если &lt;a href=&quot;union&quot;&gt;объединение&lt;/a&gt; стандартной компоновки содержит два (или более) классов стандартной компоновки в качестве членов, и эти классы имеют общую начальную последовательность элементов данных, то вполне разумно исследовать любой элемент этой общей начальной последовательности независимо от того, какой элемент Союз активен.</target>
        </trans-unit>
        <trans-unit id="e3cc007cd990ced3f77a08ffa3521f8f43ea784b" translate="yes" xml:space="preserve">
          <source>If a standard-layout union holds two or more standard-layout structs, it is permitted to inspect the common initial part of them.</source>
          <target state="translated">Если в союзе стандартной компоновки имеются две или более структуры стандартной компоновки,разрешается проверять их общую начальную часть.</target>
        </trans-unit>
        <trans-unit id="9c11517af35c72db9ca494141a4ef3243dbf8700" translate="yes" xml:space="preserve">
          <source>If a static data member is declared &lt;code&gt;constexpr&lt;/code&gt;, it is implicitly &lt;code&gt;inline&lt;/code&gt; and does not need to be redeclared at namespace scope. This redeclaration without an initializer (formerly required as shown above) is still permitted, but is deprecated.</source>
          <target state="translated">Если статический член данных объявляются &lt;code&gt;constexpr&lt;/code&gt; , она неявно &lt;code&gt;inline&lt;/code&gt; и не должна быть повторно объявлена в области видимости пространства имен. Это повторное объявление без инициализатора (ранее требовалось, как показано выше) все еще разрешено, но не рекомендуется.</target>
        </trans-unit>
        <trans-unit id="58d434e5ce1cbd3b6a5b0e91079e4162ccbc510a" translate="yes" xml:space="preserve">
          <source>If a static data member of &lt;a href=&quot;../named_req/literaltype&quot;&gt;LiteralType&lt;/a&gt; is declared &lt;code&gt;constexpr&lt;/code&gt;, it must be initialized with an initializer in which every expression is a constant expression, right inside the class definition:</source>
          <target state="translated">Если статический член данных &lt;a href=&quot;../named_req/literaltype&quot;&gt;LiteralType&lt;/a&gt; объявлен &lt;code&gt;constexpr&lt;/code&gt; , он должен быть инициализирован инициализатором, в котором каждое выражение является константным выражением, прямо внутри определения класса:</target>
        </trans-unit>
        <trans-unit id="6d5250822667240cedf5abd394540f13a00c0bf0" translate="yes" xml:space="preserve">
          <source>If a static data member of integral or enumeration type is declared &lt;code&gt;const&lt;/code&gt; (and not &lt;code&gt;volatile&lt;/code&gt;), it can be initialized with an &lt;a href=&quot;initialization&quot;&gt;initializer&lt;/a&gt; in which every expression is a &lt;a href=&quot;constexpr&quot;&gt;constant expression&lt;/a&gt;, right inside the class definition:</source>
          <target state="translated">Если статический член данных целочисленного или перечислимого типа объявлен как &lt;code&gt;const&lt;/code&gt; (а не как &lt;code&gt;volatile&lt;/code&gt; ), его можно инициализировать &lt;a href=&quot;initialization&quot;&gt;инициализатором,&lt;/a&gt; в котором каждое выражение является &lt;a href=&quot;constexpr&quot;&gt;константным выражением&lt;/a&gt; , прямо внутри определения класса:</target>
        </trans-unit>
        <trans-unit id="12dd0f953c32785837578e88c1ac2b71b7c9df42" translate="yes" xml:space="preserve">
          <source>If a substitution failure would occur in a requires-expression for every possible template argument, the program is ill-formed, no diagnostic required:</source>
          <target state="translated">Если сбой при подстановке произойдет в выражении требований для каждого возможного аргумента шаблона,то программа плохо сформирована,диагностика не требуется:</target>
        </trans-unit>
        <trans-unit id="85a2d46acfcfae4cb4dbacf839e2b8264a66b2a5" translate="yes" xml:space="preserve">
          <source>If a textual representation is written using &lt;code&gt;os &amp;lt;&amp;lt; x&lt;/code&gt; and that representation is restored into the same or a different object &lt;code&gt;y&lt;/code&gt; of the same type using &lt;code&gt;is &amp;gt;&amp;gt; y&lt;/code&gt;, then &lt;code&gt;x==y&lt;/code&gt;.</source>
          <target state="translated">Если текстовое представление написано с использованием &lt;code&gt;os &amp;lt;&amp;lt; x&lt;/code&gt; и это представление восстанавливается в тот же или другой объект &lt;code&gt;y&lt;/code&gt; того же типа, используя &lt;code&gt;is &amp;gt;&amp;gt; y&lt;/code&gt; , то &lt;code&gt;x==y&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="137821a74c9d0d2d1139c4f208ae9d5537a8856a" translate="yes" xml:space="preserve">
          <source>If a thread offers</source>
          <target state="translated">Если нить предлагает</target>
        </trans-unit>
        <trans-unit id="e2107d4d6cd0905d309a488e5a792dc268bd6478" translate="yes" xml:space="preserve">
          <source>If a token matches a user-defined literal syntax and a regular literal syntax, it is assumed to be a regular literal (that is, it's impossible to overload &lt;code&gt;LL&lt;/code&gt; in &lt;code&gt;123LL&lt;/code&gt;).</source>
          <target state="translated">Если токен совпадает с пользовательским литеральным синтаксисом и обычным литеральным синтаксисом, предполагается, что он является обычным литералом (то есть невозможно перегрузить &lt;code&gt;LL&lt;/code&gt; в &lt;code&gt;123LL&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="e7ee443e3c5d2843d1d2376575bce346735adf6d" translate="yes" xml:space="preserve">
          <source>If a type contains both a &lt;code&gt;value_type&lt;/code&gt; member and a &lt;code&gt;element_type&lt;/code&gt; member, then the specializations (5) and (6) are ambiguous.</source>
          <target state="translated">Если тип содержит как элемент &lt;code&gt;value_type&lt;/code&gt; ,так и элемент &lt;code&gt;element_type&lt;/code&gt; , то специализации (5) и (6) неоднозначны.</target>
        </trans-unit>
        <trans-unit id="0fdf3b97165e0c642a71a4a01aa77341934eb9b1" translate="yes" xml:space="preserve">
          <source>If a union contains a non-static data member with a non-trivial &lt;a href=&quot;default_constructor&quot;&gt;default constructor&lt;/a&gt;, the default constructor of the union is deleted by default unless a &lt;a href=&quot;union#Union-like_classes&quot;&gt;variant member&lt;/a&gt; of the union has a default member initializer .</source>
          <target state="translated">Если объединение содержит нестатический элемент данных с нетривиальным &lt;a href=&quot;default_constructor&quot;&gt;конструктором&lt;/a&gt; по умолчанию, конструктор объединения по умолчанию удаляется по умолчанию, если только &lt;a href=&quot;union#Union-like_classes&quot;&gt;вариантный член&lt;/a&gt; объединения не имеет инициализатора элемента по умолчанию.</target>
        </trans-unit>
        <trans-unit id="ed781d9376b4a389124dc536ac979cb50e822257" translate="yes" xml:space="preserve">
          <source>If a union contains a non-static data member with a non-trivial special member function (&lt;a href=&quot;copy_constructor&quot;&gt;copy&lt;/a&gt;/&lt;a href=&quot;move_constructor&quot;&gt;move&lt;/a&gt; constructor, &lt;a href=&quot;as_operator&quot;&gt;copy&lt;/a&gt;/&lt;a href=&quot;move_operator&quot;&gt;move&lt;/a&gt; assignment, or &lt;a href=&quot;destructor&quot;&gt;destructor&lt;/a&gt;), that function is deleted by default in the union and needs to be defined explicitly by the programmer.</source>
          <target state="translated">Если объединение содержит не статический член данных с нетривиальным специальной функцией - члена ( &lt;a href=&quot;copy_constructor&quot;&gt;копия&lt;/a&gt; / &lt;a href=&quot;move_constructor&quot;&gt;перемещением&lt;/a&gt; конструктора, &lt;a href=&quot;as_operator&quot;&gt;копировать&lt;/a&gt; / &lt;a href=&quot;move_operator&quot;&gt;перемещение&lt;/a&gt; отчуждения или &lt;a href=&quot;destructor&quot;&gt;деструктора&lt;/a&gt; ), эта функция будет удалена по умолчанию в союзе и должны быть определена явным образом программист.</target>
        </trans-unit>
        <trans-unit id="099b8ae16a17dd76f9cadbb47f54a708a0db6c1f" translate="yes" xml:space="preserve">
          <source>If a universal character name does not correspond to a code point in ISO/IEC 10646 (the range 0x0-0x10FFFF, inclusive) or if a universal-character-name corresponds to a surrogate code point (the range 0xD800-0xDFFF, inclusive), the program is ill-formed.</source>
          <target state="translated">Если универсальное символьное имя не соответствует кодовой точке в стандарте ISO/IEC 10646 (диапазон 0x0-0x10FFFF,включительно)или если универсальное символьное имя соответствует суррогатной кодовой точке (диапазон 0xD800-0xDFFFF,включительно),то программа плохо сформирована.</target>
        </trans-unit>
        <trans-unit id="05d3d79510e285cdbcce2e730e70fb609e1930e6" translate="yes" xml:space="preserve">
          <source>If a user-defined &lt;code&gt;operator-&amp;gt;&lt;/code&gt; is provided, the &lt;code&gt;operator-&amp;gt;&lt;/code&gt; is called again on the value that it returns, recursively, until an &lt;code&gt;operator-&amp;gt;&lt;/code&gt; is reached that returns a plain pointer. After that, built-in semantics are applied to that pointer.</source>
          <target state="translated">Если задан пользовательский &lt;code&gt;operator-&amp;gt;&lt;/code&gt; , &lt;code&gt;operator-&amp;gt;&lt;/code&gt; вызывается снова для значения, которое он возвращает, рекурсивно, пока не будет достигнут &lt;code&gt;operator-&amp;gt;&lt;/code&gt; который возвращает простой указатель. После этого к этому указателю применяется встроенная семантика.</target>
        </trans-unit>
        <trans-unit id="4afbc606ff35300da34cbcea95316abaecaec363" translate="yes" xml:space="preserve">
          <source>If a using-declaration brings the base class assignment operator into derived class, whose signature happens to match the derived class's copy-assignment or move-assignment operator, that operator is hidden by the implicitly-declared copy/move assignment operator of the derived class. Same applies to a using-declaration that inherits a base class constructor that happens to match the derived class copy/move constructor(since C++11).</source>
          <target state="translated">Если в use-декларацию вводится оператор присваивания базового класса в производный класс,подпись которого случайно совпадает с оператором присваивания копирования или перемещения производного класса,то этот оператор скрывается неявно заявленным оператором присваивания копирования/перемещения производного класса.То же самое относится и к конструктору базового класса,который наследует конструктор производного класса,который случайно совпадает с конструктором copy/move производного класса (начиная с C++11).</target>
        </trans-unit>
        <trans-unit id="f5b571b0ea54c128d0c23143cfd6e47087b60bac" translate="yes" xml:space="preserve">
          <source>If a valid hex digit follows a hex escape in a string literal, it would fail to compile as an invalid escape sequence. String concatenation can be used as a workaround:</source>
          <target state="translated">Если действительная шестнадцатеричная цифра следует за шестнадцатеричным экранированием в строковом литерале,она не будет скомпилирована как некорректная экранирующая последовательность.Конкатенация строк может быть использована в качестве обходного пути:</target>
        </trans-unit>
        <trans-unit id="e40960cc6f868e411ccb39ae2869971ab6ec8fa0" translate="yes" xml:space="preserve">
          <source>If a violation handler exits by throwing an exception and a contract is violated on a call to a function with a non-throwing exception specification, &lt;code&gt;&lt;a href=&quot;../../error/terminate&quot;&gt;std::terminate&lt;/a&gt;&lt;/code&gt; is called:</source>
          <target state="translated">Если обработчик нарушения завершается, вызывая исключение, и нарушается контракт при вызове функции со спецификацией без выброса, вызывается &lt;code&gt;&lt;a href=&quot;../../error/terminate&quot;&gt;std::terminate&lt;/a&gt;&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="89d508127947fb06fdf07d63dd69506781a83552" translate="yes" xml:space="preserve">
          <source>If a virtual function is non-throwing, all declarations, including the definition, of every overrider must be non-throwing as well, unless the overrider is defined as deleted:</source>
          <target state="translated">Если виртуальная функция не бросает,то все объявления,включая определение,каждого переопределителя также должны быть не бросающими,если только переопределитель не определен как удаленный:</target>
        </trans-unit>
        <trans-unit id="a4f25c0ec9b3244cc6b75eca052c2b903d4a3faa" translate="yes" xml:space="preserve">
          <source>If a width specifier is used, matches exactly</source>
          <target state="translated">Если используется спецификатор ширины,то он точно соответствует</target>
        </trans-unit>
        <trans-unit id="ee230d51493f44d873329313db640aba06300254" translate="yes" xml:space="preserve">
          <source>If access-specifier is omitted, it defaults to &lt;code&gt;public&lt;/code&gt; for classes declared with class-key &lt;code&gt;struct&lt;/code&gt; and to &lt;code&gt;private&lt;/code&gt; for classes declared with class-key &lt;code&gt;class&lt;/code&gt;.</source>
          <target state="translated">Если доступ спецификатор опущен, то по умолчанию &lt;code&gt;public&lt;/code&gt; для классов объявлены с классом ключ &lt;code&gt;struct&lt;/code&gt; и &lt;code&gt;private&lt;/code&gt; классов объявлен с классом ключ &lt;code&gt;class&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4bb883e9abe3625b7a86952913a7a8fb72c62f08" translate="yes" xml:space="preserve">
          <source>If after preparation is completed, &lt;code&gt;is.good() == true&lt;/code&gt;, then any subsequent calls to &lt;code&gt;operator bool&lt;/code&gt; will return &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">Если после завершения подготовки &lt;code&gt;is.good() == true&lt;/code&gt; , то любые последующие вызовы &lt;code&gt;operator bool&lt;/code&gt; вернут &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f9cb4a02d9dcd9af6fe36d5a1c910eb0e957522e" translate="yes" xml:space="preserve">
          <source>If all scalar types are big-endian, &lt;code&gt;std::endian::native&lt;/code&gt; equals &lt;code&gt;std::endian::big&lt;/code&gt;</source>
          <target state="translated">Если все скалярные типы имеют тип с прямым порядком байтов, &lt;code&gt;std::endian::native&lt;/code&gt; равно &lt;code&gt;std::endian::big&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d891a5fe804d25c6beb79958744a0d7c5ceede89" translate="yes" xml:space="preserve">
          <source>If all scalar types are little-endian, &lt;code&gt;std::endian::native&lt;/code&gt; equals &lt;code&gt;std::endian::little&lt;/code&gt;</source>
          <target state="translated">Если все скалярные типы с прямым порядком байтов, &lt;code&gt;std::endian::native&lt;/code&gt; равно &lt;code&gt;std::endian::little&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="12d243121b5c4fac9f94b27743279405785142b5" translate="yes" xml:space="preserve">
          <source>If all scalar types have sizeof equal to 1, endianness does not matter and all three values, &lt;code&gt;std::endian::little&lt;/code&gt;, &lt;code&gt;std::endian::big&lt;/code&gt;, and &lt;code&gt;std::endian::native&lt;/code&gt; are the same</source>
          <target state="translated">Если все скалярные типы имеют размер равный 1, порядок байтов не имеет значения, и все три значения: &lt;code&gt;std::endian::little&lt;/code&gt; , &lt;code&gt;std::endian::big&lt;/code&gt; и &lt;code&gt;std::endian::native&lt;/code&gt; одинаковы</target>
        </trans-unit>
        <trans-unit id="fee72b37f3cceab886b744b0079670d877f9da6f" translate="yes" xml:space="preserve">
          <source>If all these requirements are satisfied, the program behaves as if there is only one definition in the entire program. Otherwise, the behavior is undefined.</source>
          <target state="translated">При выполнении всех этих требований программа ведет себя так,как будто во всей программе есть только одно определение.В противном случае поведение будет неопределенным.</target>
        </trans-unit>
        <trans-unit id="36968e9ab5f085f057a3410989745d6fedfc4429" translate="yes" xml:space="preserve">
          <source>If all variable arguments share a common type, a &lt;code&gt;&lt;a href=&quot;../utility/initializer_list&quot;&gt;std::initializer_list&lt;/a&gt;&lt;/code&gt; provides a convenient mechanism (albeit with a different syntax) for accessing variable arguments. In this case however the arguments cannot be modified since &lt;code&gt;&lt;a href=&quot;../utility/initializer_list&quot;&gt;std::initializer_list&lt;/a&gt;&lt;/code&gt; can only provide a const pointer to its elements.</source>
          <target state="translated">Если все переменные аргументы имеют общий тип, &lt;code&gt;&lt;a href=&quot;../utility/initializer_list&quot;&gt;std::initializer_list&lt;/a&gt;&lt;/code&gt; предоставляет удобный механизм (хотя и с другим синтаксисом) для доступа к переменным аргументам. В этом случае, однако, аргументы не могут быть изменены, поскольку &lt;code&gt;&lt;a href=&quot;../utility/initializer_list&quot;&gt;std::initializer_list&lt;/a&gt;&lt;/code&gt; может предоставить только константный указатель на его элементы.</target>
        </trans-unit>
        <trans-unit id="3d9bddcd412f103377a475053cbfe6abb6de8ca4" translate="yes" xml:space="preserve">
          <source>If allocation fails, calls &lt;code&gt;&lt;a href=&quot;../basic_ios&quot;&gt;std::basic_ios&lt;/a&gt;&amp;lt;&amp;gt;::setstate(badbit)&lt;/code&gt; which may throw &lt;code&gt;&lt;a href=&quot;failure&quot;&gt;std::ios_base::failure&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Если распределение завершается неудачно, вызывается &lt;code&gt;&lt;a href=&quot;../basic_ios&quot;&gt;std::basic_ios&lt;/a&gt;&amp;lt;&amp;gt;::setstate(badbit)&lt;/code&gt; который может &lt;code&gt;&lt;a href=&quot;failure&quot;&gt;std::ios_base::failure&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2d22bb8db5e7c03b3a89c230b5d801c2d5d1be4c" translate="yes" xml:space="preserve">
          <source>If allocation fails, the coroutine throws &lt;code&gt;&lt;a href=&quot;../memory/new/bad_alloc&quot;&gt;std::bad_alloc&lt;/a&gt;&lt;/code&gt;, unless the Promise type defines the member function &lt;code&gt;Promise::get_return_object_on_allocation_failure()&lt;/code&gt;. If that member function is defined, allocation uses the &lt;code&gt;nothrow&lt;/code&gt; form of &lt;code&gt;&lt;a href=&quot;../memory/new/operator_new&quot;&gt;operator new&lt;/a&gt;&lt;/code&gt; and on allocation failure, the coroutine immediately returns the object obtained from &lt;code&gt;Promise::get_return_object_on_allocation_failure()&lt;/code&gt; to the caller.</source>
          <target state="translated">Если распределение завершается неудачно, сопрограмма выдает &lt;code&gt;&lt;a href=&quot;../memory/new/bad_alloc&quot;&gt;std::bad_alloc&lt;/a&gt;&lt;/code&gt; , если только тип Promise не определяет функцию-член &lt;code&gt;Promise::get_return_object_on_allocation_failure()&lt;/code&gt; . Если эта функция-член определена, при распределении используется форма &lt;code&gt;nothrow&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;../memory/new/operator_new&quot;&gt;operator new&lt;/a&gt;&lt;/code&gt; и при неудачном размещении сопрограмма немедленно возвращает объект, полученный из &lt;code&gt;Promise::get_return_object_on_allocation_failure()&lt;/code&gt; для вызывающей стороны.</target>
        </trans-unit>
        <trans-unit id="10b291b7c1e1eda28b0d49719b46140dae50f0df" translate="yes" xml:space="preserve">
          <source>If allocation succeeds, returns a pointer to the lowest (first) byte in the allocated memory block that is suitably aligned for any object type.</source>
          <target state="translated">Если выделение прошло успешно,возвращает указатель на младший (первый)байт в блоке выделенной памяти,который подходит для выравнивания для любого типа объектов.</target>
        </trans-unit>
        <trans-unit id="c9ec1b427a47550a259fb9e7cce19a17de85fede" translate="yes" xml:space="preserve">
          <source>If allocation succeeds, returns a pointer to the lowest (first) byte in the allocated memory block that is suitably aligned for any scalar type.</source>
          <target state="translated">Если выделение прошло успешно,возвращает указатель на младший (первый)байт в блоке выделенной памяти,который подходит для любого скалярного типа.</target>
        </trans-unit>
        <trans-unit id="02152ab02c6a07719ce83211d89650966926f11f" translate="yes" xml:space="preserve">
          <source>If an &lt;a href=&quot;inline&quot;&gt;inline&lt;/a&gt; function is declared in different translation units, the accumulated sets of default arguments must be the same at the end of each translation unit.</source>
          <target state="translated">Если &lt;a href=&quot;inline&quot;&gt;встроенная&lt;/a&gt; функция объявлена ​​в разных единицах перевода, накопленные наборы аргументов по умолчанию должны быть одинаковыми в конце каждой единицы перевода.</target>
        </trans-unit>
        <trans-unit id="1551cfc134da3f21c2cecb1326986402690023a3" translate="yes" xml:space="preserve">
          <source>If an &lt;code&gt;optional&amp;lt;T&amp;gt;&lt;/code&gt;</source>
          <target state="translated">Если &lt;code&gt;optional&amp;lt;T&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3b6cc884811a5bc876e80b90a3283051d48412ce" translate="yes" xml:space="preserve">
          <source>If an adaptor takes multiple arguments, these forms are equivalent:</source>
          <target state="translated">Если адаптер принимает несколько аргументов,то эти формы эквивалентны:</target>
        </trans-unit>
        <trans-unit id="e01b1c25d1638defb1bea8fb709196bd2ebf642e" translate="yes" xml:space="preserve">
          <source>If an argument can be interpreted as both a &lt;a href=&quot;type-id&quot;&gt;type-id&lt;/a&gt; and an expression, it is always interpreted as a type-id, even if the corresponding template parameter is non-type:</source>
          <target state="translated">Если аргумент можно интерпретировать как &lt;a href=&quot;type-id&quot;&gt;идентификатор типа&lt;/a&gt; и выражение, он всегда интерпретируется как идентификатор типа, даже если соответствующий параметр шаблона не является типом:</target>
        </trans-unit>
        <trans-unit id="c31ea93038a8a30a4e1fc8e381029269be15af66" translate="yes" xml:space="preserve">
          <source>If an array is so large (greater than &lt;code&gt;&lt;a href=&quot;climits&quot;&gt;PTRDIFF_MAX&lt;/a&gt;&lt;/code&gt; elements, but less than &lt;code&gt;&lt;a href=&quot;climits&quot;&gt;SIZE_MAX&lt;/a&gt;&lt;/code&gt; bytes), that the difference between two pointers may not be representable as &lt;code&gt;std::ptrdiff_t&lt;/code&gt;, the result of subtracting two such pointers is undefined.</source>
          <target state="translated">Если массив такой большой (больше, чем элементы &lt;code&gt;&lt;a href=&quot;climits&quot;&gt;PTRDIFF_MAX&lt;/a&gt;&lt;/code&gt; , но меньше, чем &lt;code&gt;&lt;a href=&quot;climits&quot;&gt;SIZE_MAX&lt;/a&gt;&lt;/code&gt; байты SIZE_MAX ), что различие между двумя указателями не может быть представлено как &lt;code&gt;std::ptrdiff_t&lt;/code&gt; , результат вычитания двух таких указателей не определен.</target>
        </trans-unit>
        <trans-unit id="799e3725591131ec4c78246e418ad8132ce4bd81" translate="yes" xml:space="preserve">
          <source>If an assertion is violated, the source location reflected in the &lt;code&gt;std::contract_violation&lt;/code&gt; argument is the source location of the statement to which the assertion is applied.</source>
          <target state="translated">Если утверждение нарушено, местоположение источника, отраженное в аргументе &lt;code&gt;std::contract_violation&lt;/code&gt; является исходным местоположением оператора, к которому применяется утверждение.</target>
        </trans-unit>
        <trans-unit id="940fbe62d35554fccc76640b50d6adbc0079900c" translate="yes" xml:space="preserve">
          <source>If an atomic store in thread A is tagged &lt;code&gt;memory_order_release&lt;/code&gt; and an atomic load in thread B from the same variable is tagged &lt;code&gt;memory_order_acquire&lt;/code&gt;, all memory writes (non-atomic and relaxed atomic) that</source>
          <target state="translated">Если &lt;code&gt;memory_order_release&lt;/code&gt; хранилище в потоке A помечено memory_order_release, а атомарная загрузка в потоке B из той же переменной помечена &lt;code&gt;memory_order_acquire&lt;/code&gt; , все записи в память ( неатомарные и релаксированные атомарные), которые</target>
        </trans-unit>
        <trans-unit id="cf29cb2a4f015597bd5e89b82f0e88a7976c2e6a" translate="yes" xml:space="preserve">
          <source>If an atomic store in thread A is tagged &lt;code&gt;memory_order_release&lt;/code&gt; and an atomic load in thread B from the same variable is tagged &lt;code&gt;memory_order_consume&lt;/code&gt;, all memory writes (non-atomic and relaxed atomic) that are</source>
          <target state="translated">Если атомарное хранилище в потоке A помечено &lt;code&gt;memory_order_release&lt;/code&gt; , а атомарная загрузка в потоке B из той же переменной помечена &lt;code&gt;memory_order_consume&lt;/code&gt; , все записи в память (не атомарные и релаксированные атомарные), которые</target>
        </trans-unit>
        <trans-unit id="fb35a531d8dbb01db97b20b4045440d69aef50c3" translate="yes" xml:space="preserve">
          <source>If an entity is declared, but not defined in some inner namespace, and then declared through using-declaration in the outer namespace, and then a definition appears in the outer namespace with the same unqualified name, that definition is a member of the outer namespace and conflicts with the using-declration:</source>
          <target state="translated">Если объект объявлен,но не определен в некотором внутреннем пространстве имён,а затем объявлен посредством use-declaration в пространстве внешних имён,а затем в пространстве внешних имён появляется определение с таким же безоговорочным именем,то это определение является членом пространства внешних имён и вступает в конфликт с use-declration:</target>
        </trans-unit>
        <trans-unit id="cc997e2af47722454e317470db77023efe2a1536" translate="yes" xml:space="preserve">
          <source>If an error occurs, the resulting value of the file position indicator for the stream is indeterminate.</source>
          <target state="translated">При возникновении ошибки результирующее значение индикатора положения файла для потока является неопределенным.</target>
        </trans-unit>
        <trans-unit id="6911b84a61e5b6d4a44d583d9d016bd32e93add2" translate="yes" xml:space="preserve">
          <source>If an error occurs, the resulting value of the file position indicator for the stream is indeterminate. If a partial element is read, its value is indeterminate.</source>
          <target state="translated">При возникновении ошибки результирующее значение индикатора положения файла для потока является неопределенным.При считывании частичного элемента его значение является неопределенным.</target>
        </trans-unit>
        <trans-unit id="a220d01f6d39ee26bbdcd1467c8f79348871f6b1" translate="yes" xml:space="preserve">
          <source>If an error occurs, the value of any cached attributes is unspecified.</source>
          <target state="translated">При возникновении ошибки значение любых кэшированных атрибутов не указывается.</target>
        </trans-unit>
        <trans-unit id="9cb826938ccf3fe4b9ff8ed25a48550d29964cf5" translate="yes" xml:space="preserve">
          <source>If an exception is thrown (e.g. by the constructor), the container is left unmodified, as if this function was never called (strong exception guarantee).</source>
          <target state="translated">Если выбрасывается исключение (например,конструктором),контейнер остается немодифицированным,как если бы эта функция никогда не вызывалась (сильная гарантия исключения).</target>
        </trans-unit>
        <trans-unit id="e6b48d12afec14d3a79a0c500c4659180b4eec6c" translate="yes" xml:space="preserve">
          <source>If an exception is thrown (which can be due to &lt;code&gt;Allocator::allocate()&lt;/code&gt; or element copy/move constructor/assignment), this function has no effect (strong exception guarantee).</source>
          <target state="translated">Если выдается исключение (которое может быть связано с &lt;code&gt;Allocator::allocate()&lt;/code&gt; или конструктором / назначением копирования / перемещения элемента), эта функция не имеет никакого эффекта (гарантия строгого исключения).</target>
        </trans-unit>
        <trans-unit id="6b0edabc7639167b7745ce3af46fe3ed92a198db" translate="yes" xml:space="preserve">
          <source>If an exception is thrown and not caught, including exceptions that escape the initial function of &lt;code&gt;&lt;a href=&quot;../thread/thread&quot;&gt;std::thread&lt;/a&gt;&lt;/code&gt;, the main function, and the constructor or destructor of any static or thread-local objects, then &lt;code&gt;&lt;a href=&quot;../error/terminate&quot;&gt;std::terminate&lt;/a&gt;&lt;/code&gt; is called. It is implementation-defined whether any stack unwinding takes place for uncaught exceptions.</source>
          <target state="translated">Если исключение выдается и не перехватывается, включая исключения, которые экранируют начальную функцию &lt;code&gt;&lt;a href=&quot;../thread/thread&quot;&gt;std::thread&lt;/a&gt;&lt;/code&gt; , основную функцию и конструктор или деструктор любых статических или локальных для потока объектов, тогда &lt;code&gt;&lt;a href=&quot;../error/terminate&quot;&gt;std::terminate&lt;/a&gt;&lt;/code&gt; вызывается std :: terminate . Это зависит от реализации, происходит ли разматывание стека для неперехваченных исключений.</target>
        </trans-unit>
        <trans-unit id="6c48ec192ada9dad6ea416b0b9a80403d55d5ef7" translate="yes" xml:space="preserve">
          <source>If an exception is thrown by any operation, the insertion has no effect.</source>
          <target state="translated">Если в результате любой операции выбрасывается исключение,вставка не действует.</target>
        </trans-unit>
        <trans-unit id="74d7d81ca3798adddb2a94c8e751e9f52b51c3b5" translate="yes" xml:space="preserve">
          <source>If an exception is thrown by any operation, this function has no effect (strong exception guarantee).</source>
          <target state="translated">Если в результате любой операции выбрасывается исключение,то эта функция не имеет никакого эффекта (сильная гарантия исключения).</target>
        </trans-unit>
        <trans-unit id="5161835af8a659e8b34603c4018519221f368f0d" translate="yes" xml:space="preserve">
          <source>If an exception is thrown by any operation, this function has no effect.</source>
          <target state="translated">Если в результате какой-либо операции выбрасывается исключение,эта функция не действует.</target>
        </trans-unit>
        <trans-unit id="7330a7b17e421be1c44660348af259ca51b2771d" translate="yes" xml:space="preserve">
          <source>If an exception is thrown during &lt;code&gt;insert_after&lt;/code&gt; there are no effects (strong exception guarantee).</source>
          <target state="translated">Если исключение выдается во время &lt;code&gt;insert_after&lt;/code&gt; выдается исключение, эффекты отсутствуют (гарантия сильного исключения).</target>
        </trans-unit>
        <trans-unit id="edd7ac01fb9845bcf837eeafecc9a3bfcff9c06c" translate="yes" xml:space="preserve">
          <source>If an exception is thrown during the initialization, some objects in &lt;code&gt;[first, last)&lt;/code&gt; are left in a valid but unspecified state, and the objects already constructed are destroyed in an unspecified order.</source>
          <target state="translated">Если во время инициализации возникает исключение, некоторые объекты в &lt;code&gt;[first, last)&lt;/code&gt; остаются в допустимом, но неопределенном состоянии, а уже созданные объекты уничтожаются в неопределенном порядке.</target>
        </trans-unit>
        <trans-unit id="ec0adbbf8914c8a6c4eec4111473b5a13e8599b3" translate="yes" xml:space="preserve">
          <source>If an exception is thrown during the initialization, some objects in the source range are left in a valid but unspecified state, and the objects already constructed are destroyed in an unspecified order.</source>
          <target state="translated">Если при инициализации выбрасывается исключение,то некоторые объекты в исходном диапазоне остаются в действительном,но неуточненном состоянии,а уже построенные объекты уничтожаются в неуточненном порядке.</target>
        </trans-unit>
        <trans-unit id="e9fecf24ed4ce20def8a83e7f8d57995cf139492" translate="yes" xml:space="preserve">
          <source>If an exception is thrown during the initialization, the objects already constructed are destroyed in an unspecified order.</source>
          <target state="translated">Если при инициализации выбрасывается исключение,то уже построенные объекты уничтожаются в неуказанном порядке.</target>
        </trans-unit>
        <trans-unit id="e35211af8694cccb5bdef2a4d7dc7571b7be0615" translate="yes" xml:space="preserve">
          <source>If an exception is thrown for any reason, this function has no effect (strong exception guarantee).</source>
          <target state="translated">Если по какой-либо причине выбрасывается исключение,эта функция не имеет никакого эффекта (сильная гарантия исключения).</target>
        </trans-unit>
        <trans-unit id="7307b2f5ebe1d631c57170aa7d478af487897112" translate="yes" xml:space="preserve">
          <source>If an exception is thrown for any reason, this function has no effect (strong exception guarantee).(since C++11).</source>
          <target state="translated">Если по какой-то причине выбрасывается исключение,то данная функция не имеет никакого эффекта (сильная гарантия исключения).(начиная с C++11).</target>
        </trans-unit>
        <trans-unit id="e6bb71e623e7422ccad975c487b4cc2c5f5da503" translate="yes" xml:space="preserve">
          <source>If an exception is thrown from a constructor or (rare) from a destructor of an object (regardless of the object's storage duration), destructors are called for all fully-constructed non-static non-variant (until C++14)members and base classes, in reverse order of completion of their constructors.  Variant members of union-like classes are only destroyed in the case of unwinding from constructor, and if the active member changed between initialization and destruction, the behavior is undefined.(since C++14).</source>
          <target state="translated">Если исключение выбрасывается из конструктора или (редко)из деструктора объекта (независимо от длительности хранения объекта),то деструкторы вызываются для всех полностью построенных нестатических нестандартных (до С++14)членов и базовых классов в обратном порядке заполнения их конструкторов.Вариантные члены union-подобных классов уничтожаются только в случае отмотки из конструктора,и если активный член изменился между инициализацией и уничтожением,то поведение не определено...(начиная с языка C++14).</target>
        </trans-unit>
        <trans-unit id="2ad1992b7bb0d63f90a28d4087b380a5f34ae1b1" translate="yes" xml:space="preserve">
          <source>If an exception is thrown other than by T's move constructor, there are no effects.</source>
          <target state="translated">Если исключение выбрасывается не конструктором движения Т,то эффектов нет.</target>
        </trans-unit>
        <trans-unit id="0aa3f34d072cd60cd1c35878bea5fd44d2e91e5c" translate="yes" xml:space="preserve">
          <source>If an exception is thrown other than by the copy constructor, move constructor, assignment operator, or move assignment operator of the value type, or if an exception is thrown while &lt;code&gt;emplace&lt;/code&gt; is used to insert a single element at the either end, there are no effects (strong exception guarantee).</source>
          <target state="translated">Если исключение выдается не конструктором копирования, а конструктором перемещения, оператором присваивания или оператором присваивания перемещения типа значения, или если исключение &lt;code&gt;emplace&lt;/code&gt; при использовании emplace используется для вставки одного элемента на любом конце, нет эффекты (гарантия сильного исключения).</target>
        </trans-unit>
        <trans-unit id="e8ab6bfb09942462906da02ee59e1dffd07b24d4" translate="yes" xml:space="preserve">
          <source>If an exception is thrown other than by the copy constructor, move constructor, assignment operator, or move assignment operator of the value type, or if an exception is thrown while &lt;code&gt;emplace&lt;/code&gt; is used to insert a single element at the end and the value type is either &lt;a href=&quot;../../named_req/copyinsertable&quot;&gt;CopyInsertable&lt;/a&gt; or nothrow move constructible, there are no effects (strong exception guarantee).</source>
          <target state="translated">Если исключение выдается не конструктором копирования, не конструктором перемещения, оператором присваивания или оператором присваивания перемещения типа значения, или если исключение &lt;code&gt;emplace&lt;/code&gt; когда emplace используется для вставки одного элемента в конце, а тип значения либо &lt;a href=&quot;../../named_req/copyinsertable&quot;&gt;CopyInsertable&lt;/a&gt; либо nothrow move constructible, эффектов нет (гарантия сильного исключения).</target>
        </trans-unit>
        <trans-unit id="2b1a5d269dbdbb9335cbe2fc340876502acdd2c3" translate="yes" xml:space="preserve">
          <source>If an exception is thrown when inserting a single element at either end, this function has no effect (strong exception guarantee).</source>
          <target state="translated">Если при вставке одного элемента с обоих концов выбрасывается исключение,то эта функция не имеет никакого эффекта (сильная гарантия исключения).</target>
        </trans-unit>
        <trans-unit id="bb38c7fc8ae93e70dfd12f9e670486bb28d436c3" translate="yes" xml:space="preserve">
          <source>If an exception is thrown when inserting a single element at the end, and T is &lt;a href=&quot;../../named_req/copyinsertable&quot;&gt;CopyInsertable&lt;/a&gt; or &lt;code&gt;std::is_nothrow_move_constructible&amp;lt;T&amp;gt;::value&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, there are no effects (strong exception guarantee).</source>
          <target state="translated">Если исключение &lt;a href=&quot;../../named_req/copyinsertable&quot;&gt;выдается&lt;/a&gt; при вставке одного элемента в конце, и T является CopyInsertable или &lt;code&gt;std::is_nothrow_move_constructible&amp;lt;T&amp;gt;::value&lt;/code&gt; равно &lt;code&gt;true&lt;/code&gt; , эффекты отсутствуют (гарантия сильного исключения).</target>
        </trans-unit>
        <trans-unit id="5998c425618742c5b2fb20a25e64116eb53b0228" translate="yes" xml:space="preserve">
          <source>If an exception is thrown, the order of elements in &lt;code&gt;*this&lt;/code&gt; is unspecified.</source>
          <target state="translated">Если выдается исключение, порядок элементов в &lt;code&gt;*this&lt;/code&gt; не определено.</target>
        </trans-unit>
        <trans-unit id="b5d6cabb3aae2ee52d65a4c1ac74ad65e7757f3c" translate="yes" xml:space="preserve">
          <source>If an exception is thrown, the shared lock is not acquired.</source>
          <target state="translated">Если выбрасывается исключение,общий замок не приобретается.</target>
        </trans-unit>
        <trans-unit id="5440918eea68b650c34253d04fa176ac527a4e96" translate="yes" xml:space="preserve">
          <source>If an exception is thrown, there are no effects (strong exception guarantee).</source>
          <target state="translated">Если выбрасывается исключение,то эффектов нет (сильная гарантия исключения).</target>
        </trans-unit>
        <trans-unit id="34d24286b06e2a97113c97c53555bf7644c31051" translate="yes" xml:space="preserve">
          <source>If an exception is thrown, this function has no effect (&lt;a href=&quot;../../language/exceptions&quot;&gt;strong exception guarantee&lt;/a&gt;).</source>
          <target state="translated">Если выброшено исключение, эта функция не действует ( &lt;a href=&quot;../../language/exceptions&quot;&gt;гарантия сильного исключения&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="2bd98e6e41884aadeeb627570c45089a1aee3259" translate="yes" xml:space="preserve">
          <source>If an exception is thrown, this function has no effect (strong exception guarantee), except if the exception comes from the comparison function.</source>
          <target state="translated">Если выбрасывается исключение,то эта функция не имеет никакого эффекта (сильная гарантия исключения),за исключением случая,когда исключение исходит от функции сравнения.</target>
        </trans-unit>
        <trans-unit id="c56964bda95bd497a307eee33dbbbedb399c8d42" translate="yes" xml:space="preserve">
          <source>If an exception is thrown, this function has no effect (strong exception guarantee).</source>
          <target state="translated">Если выбрасывается исключение,то эта функция не имеет никакого эффекта (сильная гарантия исключения).</target>
        </trans-unit>
        <trans-unit id="b1f960da1aad3dc9c4054b8661e9f9da8db12dca" translate="yes" xml:space="preserve">
          <source>If an exception is thrown, this function has no effect (strong exception guarantee). If &lt;code&gt;T&lt;/code&gt;'s move constructor is not &lt;code&gt;noexcept&lt;/code&gt; and is not &lt;a href=&quot;../../named_req/copyinsertable&quot;&gt;CopyInsertable&lt;/a&gt; into &lt;code&gt;*this&lt;/code&gt;, vector will use the throwing move constructor. If it throws, the guarantee is waived and the effects are unspecified.</source>
          <target state="translated">Если выдается исключение, эта функция не действует (гарантия сильного исключения). Если &lt;code&gt;T&lt;/code&gt; двигаться конструктор &amp;laquo;s не &lt;code&gt;noexcept&lt;/code&gt; и не &lt;a href=&quot;../../named_req/copyinsertable&quot;&gt;CopyInsertable&lt;/a&gt; в &lt;code&gt;*this&lt;/code&gt; вектор будет использовать конструктор метание перемещения. Если он выбрасывает, гарантия отменяется, а последствия не уточняются.</target>
        </trans-unit>
        <trans-unit id="3e81fff806c92690d8247fab353f430b076a5ddb" translate="yes" xml:space="preserve">
          <source>If an exception was stored in the shared state referenced by the future (e.g. via a call to &lt;a href=&quot;../promise/set_exception&quot;&gt;&lt;code&gt;std::promise::set_exception()&lt;/code&gt;&lt;/a&gt;) then that exception will be thrown.</source>
          <target state="translated">Если исключение было сохранено в общем состоянии, на которое ссылается будущее (например, посредством вызова &lt;a href=&quot;../promise/set_exception&quot;&gt; &lt;code&gt;std::promise::set_exception()&lt;/code&gt; &lt;/a&gt; ), то это исключение будет выдано .</target>
        </trans-unit>
        <trans-unit id="d0137b7a583c99b14138ba2d912173e858c09f48" translate="yes" xml:space="preserve">
          <source>If an implicitly-declared destructor is not deleted, it is implicitly defined (that is, a function body is generated and compiled) by the compiler when it is &lt;a href=&quot;definition#ODR-use&quot;&gt;odr-used&lt;/a&gt;. This implicitly-defined destructor has an empty body.</source>
          <target state="translated">Если неявно объявленный деструктор не удаляется, он неявно определяется (то есть тело функции генерируется и компилируется) компилятором, когда он используется в &lt;a href=&quot;definition#ODR-use&quot;&gt;odr&lt;/a&gt; . Этот неявно определенный деструктор имеет пустое тело.</target>
        </trans-unit>
        <trans-unit id="5a6f2dbbaa4e8bf97f99dfa70fb418fa8a9f940e" translate="yes" xml:space="preserve">
          <source>If an inline function is declared in different translation units, the accumulated sets of &lt;a href=&quot;default_arguments&quot;&gt;default arguments&lt;/a&gt; must be the same at the end of each translation unit.</source>
          <target state="translated">Если встроенная функция объявлена ​​в разных единицах перевода, накопленные наборы &lt;a href=&quot;default_arguments&quot;&gt;аргументов&lt;/a&gt; по умолчанию должны быть одинаковыми в конце каждой единицы перевода.</target>
        </trans-unit>
        <trans-unit id="b7990c568402acf3a5d1219a03555ac57df4d740" translate="yes" xml:space="preserve">
          <source>If an inline function or variable(since C++17) with external linkage is defined differently in different translation units, the behavior is undefined.</source>
          <target state="translated">Если inline-функция или переменная(начиная с C++17)с внешней связью определена по-разному в разных единицах трансляции,то поведение не определено.</target>
        </trans-unit>
        <trans-unit id="eb3fc767b94cfd5625015f9349fa6a8307905fac" translate="yes" xml:space="preserve">
          <source>If an insertion is performed, the mapped value is &lt;a href=&quot;../../language/value_initialization&quot;&gt;value-initialized&lt;/a&gt; (default-constructed for class types, zero-initialized otherwise) and a reference to it is returned.</source>
          <target state="translated">Если вставка выполняется, сопоставленное &lt;a href=&quot;../../language/value_initialization&quot;&gt;значение инициализируется значением&lt;/a&gt; (создается по умолчанию для типов классов, в противном случае инициализируется нулями) и возвращается ссылка на него.</target>
        </trans-unit>
        <trans-unit id="18180e9058d1e19c0f11fd992aa464bc733a35a8" translate="yes" xml:space="preserve">
          <source>If an insertion occurs and results in a rehashing of the container, all iterators are invalidated. Otherwise iterators are not affected. References are not invalidated. Rehashing occurs only if the new number of elements is greater than &lt;code&gt;max_load_factor()*bucket_count()&lt;/code&gt;.</source>
          <target state="translated">Если вставка происходит и приводит к перефразированию контейнера, все итераторы становятся недействительными. В противном случае итераторы не будут затронуты. Ссылки не являются недействительными. Перефразировка происходит, только если новое количество элементов больше, чем &lt;code&gt;max_load_factor()*bucket_count()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0a574aa99696eb2cfb80cca007e805d644a25910" translate="yes" xml:space="preserve">
          <source>If an instantiation of a template above depends, directly or indirectly, on an incomplete type, and that instantiation could yield a different result if that type were hypothetically completed, the behavior is undefined.</source>
          <target state="translated">Если приведенная выше инстанциация шаблона прямо или косвенно зависит от неполного типа,и эта инстанциация могла бы дать другой результат,если бы этот тип был гипотетически завершен,поведение не определено.</target>
        </trans-unit>
        <trans-unit id="a64bffb3522d60e8b666b70574ce5d49611f5000" translate="yes" xml:space="preserve">
          <source>If an internal operation throws an exception, it is caught and &lt;code&gt;&lt;a href=&quot;../ios_base/iostate&quot;&gt;badbit&lt;/a&gt;&lt;/code&gt; is set. If &lt;code&gt;&lt;a href=&quot;../basic_ios/exceptions&quot;&gt;exceptions()&lt;/a&gt;&lt;/code&gt; is set for &lt;code&gt;badbit&lt;/code&gt;, the exception is rethrown.</source>
          <target state="translated">Если внутренняя операция выдает исключение, оно перехватывается и &lt;code&gt;&lt;a href=&quot;../ios_base/iostate&quot;&gt;badbit&lt;/a&gt;&lt;/code&gt; . Если для &lt;code&gt;badbit&lt;/code&gt; задано &lt;code&gt;&lt;a href=&quot;../basic_ios/exceptions&quot;&gt;exceptions()&lt;/a&gt;&lt;/code&gt; , исключение перебрасывается.</target>
        </trans-unit>
        <trans-unit id="5a642538c4470f54f4f527d91f99d4f6fe81ff66" translate="yes" xml:space="preserve">
          <source>If an operation on traits emits an exception, the behavior is undefined.</source>
          <target state="translated">Если операция по трейтам порождает исключение,поведение не определено.</target>
        </trans-unit>
        <trans-unit id="6e13b70715d8672a431c8a76c567c768c6ee6a7b" translate="yes" xml:space="preserve">
          <source>If an overriding function specifies &lt;a href=&quot;attributes/contract&quot;&gt;contract conditions&lt;/a&gt;, it must specify the same list contract conditions as the functions it overrides; no diagnostic is required if corresponding conditions will always evaluate to the same value. Otherwise, it is considered to have the list of contract conditions from one of its overriden functions; the names in the contract conditions are bound and the semantic constraints are checked at the point where the contract conditions appear.</source>
          <target state="translated">Если переопределяющая функция указывает &lt;a href=&quot;attributes/contract&quot;&gt;условия контракта&lt;/a&gt; , она должна указывать те же условия контракта списка, что и функции, которые она переопределяет; Диагностика не требуется, если соответствующие условия всегда будут иметь одно и то же значение. В противном случае считается, что он содержит список условий контракта из одной из его переопределенных функций; имена в условиях контракта связаны, а семантические ограничения проверяются в точке, где появляются условия контракта.</target>
        </trans-unit>
        <trans-unit id="ea6490ada6b718e0dd1982f5bd44675af661c0e9" translate="yes" xml:space="preserve">
          <source>If any &lt;code&gt;&lt;a href=&quot;../weak_ptr&quot;&gt;std::weak_ptr&lt;/a&gt;&lt;/code&gt; references the control block created by &lt;code&gt;std::make_shared&lt;/code&gt; after the lifetime of all shared owners ended, the memory occupied by &lt;code&gt;T&lt;/code&gt; persists until all weak owners get destroyed as well, which may be undesirable if &lt;code&gt;sizeof(T)&lt;/code&gt; is large.</source>
          <target state="translated">Если какой-либо из &lt;code&gt;&lt;a href=&quot;../weak_ptr&quot;&gt;std::weak_ptr&lt;/a&gt;&lt;/code&gt; ссылается на блок управления, созданный &lt;code&gt;std::make_shared&lt;/code&gt; после окончания времени жизни всех общих владельцев, память, занимаемая &lt;code&gt;T&lt;/code&gt; , сохраняется до тех пор, пока все слабые владельцы не будут уничтожены, что может быть нежелательно, если &lt;code&gt;sizeof(T)&lt;/code&gt; равен большой.</target>
        </trans-unit>
        <trans-unit id="be9fa8a822bab5c2b3736388d805151fa47e91f3" translate="yes" xml:space="preserve">
          <source>If any Ti is not a comparison category type (&lt;a href=&quot;weak_equality&quot;&gt;&lt;code&gt;std::weak_equality&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;strong_equality&quot;&gt;&lt;code&gt;std::strong_equality&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;partial_ordering&quot;&gt;&lt;code&gt;std::partial_ordering&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;weak_ordering&quot;&gt;&lt;code&gt;std::weak_ordering&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;strong_ordering&quot;&gt;&lt;code&gt;std::strong_ordering&lt;/code&gt;&lt;/a&gt;), U is &lt;code&gt;void&lt;/code&gt;.</source>
          <target state="translated">Если какой-либо Ti не относится к типу категории сравнения ( &lt;a href=&quot;weak_equality&quot;&gt; &lt;code&gt;std::weak_equality&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;strong_equality&quot;&gt; &lt;code&gt;std::strong_equality&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;partial_ordering&quot;&gt; &lt;code&gt;std::partial_ordering&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;weak_ordering&quot;&gt; &lt;code&gt;std::weak_ordering&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;strong_ordering&quot;&gt; &lt;code&gt;std::strong_ordering&lt;/code&gt; &lt;/a&gt; ), U является &lt;code&gt;void&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fa759a7594dd95d5f9753141e5b119ba2c2846a0" translate="yes" xml:space="preserve">
          <source>If any argument is NaN, NaN is returned and domain error is not reported</source>
          <target state="translated">Если какой-либо аргумент является NaN,то NaN возвращается и об ошибке домена не сообщается.</target>
        </trans-unit>
        <trans-unit id="7e09a18bf23aa9504f4b8622f9df9a40a3b55dc8" translate="yes" xml:space="preserve">
          <source>If any candidate function is a &lt;a href=&quot;member_functions&quot;&gt;member function&lt;/a&gt; (static or non-static), but not a constructor, it is treated as if it has an extra parameter (</source>
          <target state="translated">Если какая-либо функция-кандидат является функцией- &lt;a href=&quot;member_functions&quot;&gt;членом&lt;/a&gt; (статической или нестатической), но не является конструктором, она обрабатывается так, как если бы она имела дополнительный параметр (</target>
        </trans-unit>
        <trans-unit id="a6bcd0ea08bf821e3fbe550757f07bf7cf22d254" translate="yes" xml:space="preserve">
          <source>If any candidate is a function template, its specializations are generated using &lt;a href=&quot;template_argument_deduction&quot;&gt;template argument deduction&lt;/a&gt;, and such specializations are treated just like non-template functions except where specified otherwise in the tie-breaker rules. If a name refers to one or more function templates and also to a set of overloaded non-template functions, those functions and the specializations generated from the templates are all candidates.</source>
          <target state="translated">Если какой-либо кандидат является шаблоном функции, его специализации генерируются с использованием &lt;a href=&quot;template_argument_deduction&quot;&gt;вывода аргументов шаблона&lt;/a&gt; , и такие специализации обрабатываются так же, как не шаблонные функции, если не указано иное в правилах разрешения конфликтов. Если имя относится к одному или нескольким шаблонам функций, а также к набору перегруженных не шаблонных функций, все эти функции и специализации, сгенерированные из шаблонов, являются кандидатами.</target>
        </trans-unit>
        <trans-unit id="126493e0cbb7819d68c915080c830634b2cac172" translate="yes" xml:space="preserve">
          <source>If any function that is called directly by the stack unwinding mechanism, after initialization of the exception object and before the start of the exception handler, exits with an exception, &lt;code&gt;&lt;a href=&quot;../error/terminate&quot;&gt;std::terminate&lt;/a&gt;&lt;/code&gt; is called. Such functions include &lt;a href=&quot;destructor&quot;&gt;destructors&lt;/a&gt; of objects with automatic storage duration whose scopes are exited, and the copy constructor of the exception object that is called (&lt;a href=&quot;copy_elision&quot;&gt;if not elided&lt;/a&gt;) to initialize catch-by-value arguments.</source>
          <target state="translated">Если какая-либо функция, вызываемая напрямую механизмом разматывания стека, после инициализации объекта исключения и перед запуском обработчика исключения завершается с исключением, вызывается &lt;code&gt;&lt;a href=&quot;../error/terminate&quot;&gt;std::terminate&lt;/a&gt;&lt;/code&gt; . Такие функции включают &lt;a href=&quot;destructor&quot;&gt;деструкторы&lt;/a&gt; объектов с автоматической продолжительностью хранения, области действия которых выходят, и конструктор копирования объекта исключения, который вызывается ( &lt;a href=&quot;copy_elision&quot;&gt;если не исключается&lt;/a&gt; ) для инициализации аргументов по значению.</target>
        </trans-unit>
        <trans-unit id="15dfee2b548c068d0cb9438923992bb46bcca31a" translate="yes" xml:space="preserve">
          <source>If any namespace in the associated set of classes and namespaces directly contains an inline namespace, that inline namespace is added to the set.</source>
          <target state="translated">Если какое-либо пространство имён в связанном наборе классов и пространств имён непосредственно содержит встроенное пространство имён,то это встроенное пространство имён добавляется в набор.</target>
        </trans-unit>
        <trans-unit id="96b81c5fbadca60870db38fc2f9a183bb9b6fdca" translate="yes" xml:space="preserve">
          <source>If any namespace in the associated set of classes and namespaces is an &lt;a href=&quot;namespace&quot;&gt;inline namespace&lt;/a&gt;, its enclosing namespace is also added to the set.</source>
          <target state="translated">Если какое-либо пространство имен в связанном наборе классов и пространств имен является &lt;a href=&quot;namespace&quot;&gt;встроенным пространством имен&lt;/a&gt; , его включающее пространство имен также добавляется в набор.</target>
        </trans-unit>
        <trans-unit id="77bf32371c11f8b0a2f664f75979c288885d06cb" translate="yes" xml:space="preserve">
          <source>If any of the function calls made, including the call to &lt;code&gt;&lt;a href=&quot;../c/fclose&quot;&gt;std::fclose()&lt;/a&gt;&lt;/code&gt;, fails, returns a null pointer. If any of the function calls made throws an exception, the exception is caught and rethrown after calling &lt;code&gt;&lt;a href=&quot;../c/fclose&quot;&gt;std::fclose()&lt;/a&gt;&lt;/code&gt;. If the file is already closed, returns a null pointer right away.</source>
          <target state="translated">Если какой-либо из выполненных вызовов функции, включая вызов &lt;code&gt;&lt;a href=&quot;../c/fclose&quot;&gt;std::fclose()&lt;/a&gt;&lt;/code&gt; , завершается неудачей, возвращается нулевой указатель. Если какой-либо из вызванных вызовов функции выдает исключение, исключение перехватывается и перебрасывается после вызова &lt;code&gt;&lt;a href=&quot;../c/fclose&quot;&gt;std::fclose()&lt;/a&gt;&lt;/code&gt; . Если файл уже закрыт, сразу возвращает нулевой указатель.</target>
        </trans-unit>
        <trans-unit id="96b62f2f876cd9ccd1e029ff20920e414e1372bd" translate="yes" xml:space="preserve">
          <source>If any of the function parameters uses a</source>
          <target state="translated">Если какой-либо из параметров функции использует</target>
        </trans-unit>
        <trans-unit id="2b9407b136cda4e52a8bcbbff35df15df1b4ed8a" translate="yes" xml:space="preserve">
          <source>If any of the operands is a pointer, the following rules apply:</source>
          <target state="translated">Если любой из операндов является указателем,применяются следующие правила:</target>
        </trans-unit>
        <trans-unit id="6bea11d594aa54f1709b6bc92b826adf56fa3383" translate="yes" xml:space="preserve">
          <source>If any of the private members needs to access a public or protected member, a reference or pointer to the interface may be passed to the private function as a parameter. Alternatively, the back-reference may be maintained as part of the implementation class.</source>
          <target state="translated">Если кому-либо из приватных членов требуется доступ к публичному или защищенному члену,то в качестве параметра в приватную функцию может быть передана ссылка или указатель на интерфейс.В качестве альтернативы обратная ссылка может быть сохранена как часть класса реализации.</target>
        </trans-unit>
        <trans-unit id="f4cf008505537dd2a8c50313e658cc2022e63eda" translate="yes" xml:space="preserve">
          <source>If any of these situations occur in a translation unit, the definition of the type must appear in the same translation unit. Otherwise, it is not required.</source>
          <target state="translated">Если какая-либо из этих ситуаций возникает в переводческой единице,определение типа должно появиться в той же переводческой единице.В противном случае оно не требуется.</target>
        </trans-unit>
        <trans-unit id="205c5da68a3eed873a307fa520147b2a4368cf96" translate="yes" xml:space="preserve">
          <source>If any template definition has a &lt;a href=&quot;qualified_lookup&quot;&gt;qualified name&lt;/a&gt; in which the qualifier refers to the</source>
          <target state="translated">Если какое-либо определение шаблона имеет &lt;a href=&quot;qualified_lookup&quot;&gt;квалифицированное имя,&lt;/a&gt; в котором квалификатор ссылается на</target>
        </trans-unit>
        <trans-unit id="a99969c90cd633e5812cf58136c1c690e70c4d05" translate="yes" xml:space="preserve">
          <source>If any template definition has a member acess expression where the object expression is the</source>
          <target state="translated">Если какое-либо определение шаблона имеет выражение-членского доступа,где выражением объекта является</target>
        </trans-unit>
        <trans-unit id="32c3e54b2ab54a4690246c40558fdcba870991e2" translate="yes" xml:space="preserve">
          <source>If any threads are waiting on &lt;code&gt;*this&lt;/code&gt;, calling &lt;code&gt;notify_one&lt;/code&gt; unblocks one of the waiting threads.</source>
          <target state="translated">Если какие-либо потоки ожидают &lt;code&gt;*this&lt;/code&gt; , вызов &lt;code&gt;notify_one&lt;/code&gt; разблокирует один из ожидающих потоков.</target>
        </trans-unit>
        <trans-unit id="7d2a968ab7f2dd81e4eead9cc317c64526456d40" translate="yes" xml:space="preserve">
          <source>If applying &lt;code&gt;&lt;a href=&quot;decay&quot;&gt;std::decay&lt;/a&gt;&lt;/code&gt; to at least one of &lt;code&gt;T1&lt;/code&gt; and &lt;code&gt;T2&lt;/code&gt; produces a different type, the member &lt;code&gt;type&lt;/code&gt; names the same type as &lt;code&gt;std::common_type&amp;lt;&lt;a href=&quot;decay&quot;&gt;std::decay&lt;/a&gt;&amp;lt;T1&amp;gt;::type, &lt;a href=&quot;decay&quot;&gt;std::decay&lt;/a&gt;&amp;lt;T2&amp;gt;::type&amp;gt;::type&lt;/code&gt;, if it exists; if not, there is no member &lt;code&gt;type&lt;/code&gt;.</source>
          <target state="translated">При применении &lt;code&gt;&lt;a href=&quot;decay&quot;&gt;std::decay&lt;/a&gt;&lt;/code&gt; , по меньшей мере , один из &lt;code&gt;T1&lt;/code&gt; и &lt;code&gt;T2&lt;/code&gt; производит другой тип, элемент &lt;code&gt;type&lt;/code&gt; имена и тот же тип , как &lt;code&gt;std::common_type&amp;lt;&lt;a href=&quot;decay&quot;&gt;std::decay&lt;/a&gt;&amp;lt;T1&amp;gt;::type, &lt;a href=&quot;decay&quot;&gt;std::decay&lt;/a&gt;&amp;lt;T2&amp;gt;::type&amp;gt;::type&lt;/code&gt; , если он существует; если нет, то нет &lt;code&gt;type&lt;/code&gt; члена .</target>
        </trans-unit>
        <trans-unit id="08759afad939001ce25641ffda80dd6d474e5c10" translate="yes" xml:space="preserve">
          <source>If arg is NaN, NaN is returned</source>
          <target state="translated">Если аргумент-NaN,то NaN возвращается.</target>
        </trans-unit>
        <trans-unit id="a3fffd54a9398802b03cfe88989a4c46d2ce5774" translate="yes" xml:space="preserve">
          <source>If at least one of the arguments to an operator in an expression has a class type or an enumeration type, both &lt;a href=&quot;expressions#Operators&quot;&gt;builtin operators&lt;/a&gt; and &lt;a href=&quot;operators&quot;&gt;user-defined operator overloads&lt;/a&gt; participate in overload resolution, with the set of candidate functions selected as follows:</source>
          <target state="translated">Если хотя бы один из аргументов оператора в выражении имеет тип класса или тип перечисления, как &lt;a href=&quot;expressions#Operators&quot;&gt;встроенные операторы, так&lt;/a&gt; и &lt;a href=&quot;operators&quot;&gt;пользовательские перегрузки операторов&lt;/a&gt; участвуют в разрешении перегрузки, причем набор функций-кандидатов выбирается следующим образом:</target>
        </trans-unit>
        <trans-unit id="cfa2de104dcda4911fda849d8572dfd8b37d2933" translate="yes" xml:space="preserve">
          <source>If at least one of the deallocation functions is a destroying delete, all non-destroying deletes are ignored.</source>
          <target state="translated">Если хотя бы одна из функций распределения сделок является уничтожающим удалением,то все неуничтожающие удаления игнорируются.</target>
        </trans-unit>
        <trans-unit id="edc900123598455f7b2624a5d0192ef2c77c276f" translate="yes" xml:space="preserve">
          <source>If at least one of the operands is a pointer or pointer-to-member, array-to-pointer conversions, derived-to-base pointer conversions, function pointer conversions, and qualification conversions are applied as necessary to convert both operands to the same pointer type.</source>
          <target state="translated">Если хотя бы один из операндов является указателем или указателем на член,то для приведения обоих операндов к одному и тому же типу указателя применяются преобразования из массива в указатель,преобразования производных в базу,преобразования указателей функций,а также квалификационные преобразования,необходимые для приведения обоих операндов к одному и тому же типу указателя.</target>
        </trans-unit>
        <trans-unit id="8702bce6fb50aa6cb7bc28c668acc4a3e2449f0f" translate="yes" xml:space="preserve">
          <source>If bool_constexpr returns &lt;code&gt;true&lt;/code&gt;, this declaration has no effect. Otherwise a compile-time error is issued, and the text of message, if any, is included in the diagnostic message.</source>
          <target state="translated">Если bool_constexpr возвращает &lt;code&gt;true&lt;/code&gt; , это объявление не имеет никакого эффекта. В противном случае выдается ошибка времени компиляции, и текст сообщения, если таковой имеется, включается в диагностическое сообщение.</target>
        </trans-unit>
        <trans-unit id="72593242b61b146efa6a985e10a179d983cf718b" translate="yes" xml:space="preserve">
          <source>If both &lt;code&gt;*this&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt; contain values, the contained values are exchanged by calling &lt;code&gt;using &lt;a href=&quot;../../algorithm/swap&quot;&gt;std::swap&lt;/a&gt;; swap(**this, *other)&lt;/code&gt;. &lt;code&gt;T&lt;/code&gt; lvalues must satisfy &lt;a href=&quot;../../named_req/swappable&quot;&gt;Swappable&lt;/a&gt;.</source>
          <target state="translated">Если и &lt;code&gt;*this&lt;/code&gt; , и &lt;code&gt;other&lt;/code&gt; содержат значения, содержащиеся в них значения обмениваются путем вызова &lt;code&gt;using &lt;a href=&quot;../../algorithm/swap&quot;&gt;std::swap&lt;/a&gt;; swap(**this, *other)&lt;/code&gt; . &lt;code&gt;T&lt;/code&gt; lvalues должны удовлетворять &lt;a href=&quot;../../named_req/swappable&quot;&gt;Swappable&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9149200a2a016ffa0cff6b7a2b77a8a41a09bef3" translate="yes" xml:space="preserve">
          <source>If both &lt;code&gt;*this&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt; do not contain a value, the function has no effect.</source>
          <target state="translated">Если и &lt;code&gt;*this&lt;/code&gt; , и &lt;code&gt;other&lt;/code&gt; не содержат значения, функция не действует.</target>
        </trans-unit>
        <trans-unit id="51fcf538b4bb73b4d1fbe54dfcf29fa14c9c5798" translate="yes" xml:space="preserve">
          <source>If both &lt;code&gt;Base&lt;/code&gt; and &lt;code&gt;Derived&lt;/code&gt; are non-union class types, and they are not the same type (ignoring cv-qualification), &lt;code&gt;Derived&lt;/code&gt; shall be a &lt;a href=&quot;../language/incomplete_type&quot;&gt;complete type&lt;/a&gt;; otherwise the behavior is undefined.</source>
          <target state="translated">Если и &lt;code&gt;Base&lt;/code&gt; , и &lt;code&gt;Derived&lt;/code&gt; являются типами классов, не являющимися объединениями, и они не относятся к одному и тому же типу (игнорируя квалификацию cv), &lt;code&gt;Derived&lt;/code&gt; должен быть &lt;a href=&quot;../language/incomplete_type&quot;&gt;полным типом&lt;/a&gt; ; в противном случае поведение не определено.</target>
        </trans-unit>
        <trans-unit id="031007df7a4bbbcc69dda82c9142cab39525a5c6" translate="yes" xml:space="preserve">
          <source>If both &lt;code&gt;P&lt;/code&gt; and &lt;code&gt;A&lt;/code&gt; are reference types before, determine which is more cv-qualified (in all other cases, cv-qualificiations are ignored for partial ordering purposes)</source>
          <target state="translated">Если и &lt;code&gt;P&lt;/code&gt; , и &lt;code&gt;A&lt;/code&gt; ранее были ссылочными типами, определите, какой из них более квалифицирован для cv (во всех других случаях квалификация cv игнорируется для целей частичного упорядочения)</target>
        </trans-unit>
        <trans-unit id="0fbe1e336c3df9cfce302d24095585fa919b438e" translate="yes" xml:space="preserve">
          <source>If both &lt;code&gt;m&lt;/code&gt; and &lt;code&gt;n&lt;/code&gt; are zero, returns zero. Otherwise, returns the greatest common divisor of &lt;code&gt;|m|&lt;/code&gt; and &lt;code&gt;|n|&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;m&lt;/code&gt; и &lt;code&gt;n&lt;/code&gt; равны нулю, возвращает ноль. В противном случае возвращает наибольший общий делитель &lt;code&gt;|m|&lt;/code&gt; и &lt;code&gt;|n|&lt;/code&gt; ,</target>
        </trans-unit>
        <trans-unit id="a5805a8f51641bf5a39fc87b226394ea5441b146" translate="yes" xml:space="preserve">
          <source>If both &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; represent valid dates (&lt;code&gt;x.ok() &amp;amp;&amp;amp; y.ok() == true&lt;/code&gt;), the result of the lexicographical comparison is consistent with the calendar order.</source>
          <target state="translated">Если и &lt;code&gt;x&lt;/code&gt; , и &lt;code&gt;y&lt;/code&gt; представляют действительные даты ( &lt;code&gt;x.ok() &amp;amp;&amp;amp; y.ok() == true&lt;/code&gt; ), результат лексикографического сравнения соответствует календарному порядку.</target>
        </trans-unit>
        <trans-unit id="942dbb8422270823dbf96e8d6ddba2211d8b9ddc" translate="yes" xml:space="preserve">
          <source>If both conversion functions and converting constructors can be used to perform some user-defined conversion, the conversion functions and constructors are both considered by &lt;a href=&quot;overload_resolution&quot;&gt;overload resolution&lt;/a&gt; in &lt;a href=&quot;copy_initialization&quot;&gt;copy-initialization&lt;/a&gt; and &lt;a href=&quot;reference_initialization&quot;&gt;reference-initialization&lt;/a&gt; contexts, but only the constructors are considered in &lt;a href=&quot;direct_initialization&quot;&gt;direct-initialization&lt;/a&gt; contexts.</source>
          <target state="translated">Если обе функция преобразования и преобразующие конструкторы могут быть использованы для выполнения некоторого определяемого пользователя преобразования, функция преобразования и конструкторы оба рассматриваются &lt;a href=&quot;overload_resolution&quot;&gt;разрешение перегрузки&lt;/a&gt; в &lt;a href=&quot;copy_initialization&quot;&gt;копировании инициализации&lt;/a&gt; и &lt;a href=&quot;reference_initialization&quot;&gt;референтная инициализация&lt;/a&gt; контекстах, но только Конструкторы рассматриваются в &lt;a href=&quot;direct_initialization&quot;&gt;прямой инициализации&lt;/a&gt; контексте ,</target>
        </trans-unit>
        <trans-unit id="a385931d531ce68f4e5f9578700e55c228573984" translate="yes" xml:space="preserve">
          <source>If both copy and move assignment operators are provided, overload resolution selects the move assignment if the argument is an &lt;a href=&quot;value_category&quot;&gt;&lt;i&gt;rvalue&lt;/i&gt;&lt;/a&gt; (either a &lt;a href=&quot;value_category&quot;&gt;&lt;i&gt;prvalue&lt;/i&gt;&lt;/a&gt; such as a nameless temporary or an &lt;a href=&quot;value_category&quot;&gt;&lt;i&gt;xvalue&lt;/i&gt;&lt;/a&gt; such as the result of &lt;code&gt;std::move&lt;/code&gt;), and selects the copy assignment if the argument is an &lt;a href=&quot;value_category&quot;&gt;&lt;i&gt;lvalue&lt;/i&gt;&lt;/a&gt; (named object or a function/operator returning lvalue reference). If only the copy assignment is provided, all argument categories select it (as long as it takes its argument by value or as reference to const, since rvalues can bind to const references), which makes copy assignment the fallback for move assignment, when move is unavailable.</source>
          <target state="translated">Если предусмотрены как операторы копирования, так и перемещения, разрешение перегрузки выбирает назначение перемещения, если аргумент является значением &lt;a href=&quot;value_category&quot;&gt;&lt;i&gt;rvalue&lt;/i&gt;&lt;/a&gt; (либо &lt;a href=&quot;value_category&quot;&gt;&lt;i&gt;prvalue,&lt;/i&gt;&lt;/a&gt; например, безымянное временное значение, либо &lt;a href=&quot;value_category&quot;&gt;&lt;i&gt;xvalue,&lt;/i&gt;&lt;/a&gt; например, результат &lt;code&gt;std::move&lt;/code&gt; ), и выбирает назначение копирования. если аргумент является &lt;a href=&quot;value_category&quot;&gt;&lt;i&gt;lvalue&lt;/i&gt;&lt;/a&gt; (именованный объект или функция / оператор, возвращающий ссылку на lvalue). Если предоставляется только назначение копирования, все категории аргументов выбирают его (при условии, что он принимает свой аргумент по значению или как ссылку на const, поскольку значения r могут связываться с ссылками const), что делает назначение копии резервным для назначения перемещения при перемещении. недоступен.</target>
        </trans-unit>
        <trans-unit id="0bcac6e95caaa2cc81cc604fdcf629399d168aad" translate="yes" xml:space="preserve">
          <source>If both copy and move constructors are provided and no other constructors are viable, overload resolution selects the move constructor if the argument is an &lt;a href=&quot;value_category&quot;&gt;rvalue&lt;/a&gt; of the same type (an &lt;a href=&quot;value_category&quot;&gt;xvalue&lt;/a&gt; such as the result of &lt;code&gt;std::move&lt;/code&gt; or a &lt;a href=&quot;value_category&quot;&gt;prvalue&lt;/a&gt; such as a nameless temporary(until C++17)), and selects the copy constructor if the argument is an &lt;a href=&quot;value_category&quot;&gt;lvalue&lt;/a&gt; (named object or a function/operator returning lvalue reference). If only the copy constructor is provided, all argument categories select it (as long as it takes a reference to const, since rvalues can bind to const references), which makes copying the fallback for moving, when moving is unavailable.</source>
          <target state="translated">Если предусмотрены конструкторы копирования и перемещения, а другие конструкторы не являются жизнеспособными, разрешение перегрузки выбирает конструктор перемещения, если аргумент является значением &lt;a href=&quot;value_category&quot;&gt;r&lt;/a&gt; того же типа (значением &lt;a href=&quot;value_category&quot;&gt;x,&lt;/a&gt; например, результатом &lt;code&gt;std::move&lt;/code&gt; или значением &lt;a href=&quot;value_category&quot;&gt;prvalue,&lt;/a&gt; например, безымянным. временно (до C ++ 17)) и выбирает конструктор копирования, если аргумент является &lt;a href=&quot;value_category&quot;&gt;lvalue&lt;/a&gt; (именованный объект или функция / оператор, возвращающий ссылку на lvalue). Если предоставляется только конструктор копирования, все категории аргументов выбирают его (при условии, что он принимает ссылку на const, поскольку rvalues ​​может связываться с ссылками на const), что делает копирование запасного варианта для перемещения, когда перемещение недоступно.</target>
        </trans-unit>
        <trans-unit id="60aa98cd9f6dc6c43b3235a9ef70bcb42b49d023" translate="yes" xml:space="preserve">
          <source>If both expression are well-formed, the conversion is ambiguous, and the program is ill-formed.</source>
          <target state="translated">Если оба выражения хорошо сформированы,то преобразование неоднозначно,а программа плохо сформирована.</target>
        </trans-unit>
        <trans-unit id="6e8d82bcd24247033be13b857c411fcd62b8ed61" translate="yes" xml:space="preserve">
          <source>If both of the operands are arrays, three-way comparison is ill-formed except when comparing class members of array type.</source>
          <target state="translated">Если оба операндов являются массивами,то трёхстороннее сравнение происходит плохо,за исключением сравнения членов класса типа массива.</target>
        </trans-unit>
        <trans-unit id="c64fda57212a716e4316cdd7fb2f466fbf4fcafb" translate="yes" xml:space="preserve">
          <source>If both operands are signed or both are unsigned, the operand with lesser</source>
          <target state="translated">Если оба операнда подписаны или оба не подписаны,то операнд с меньшей</target>
        </trans-unit>
        <trans-unit id="63fa8968e2f3efc134b4cba9025b815ed6390596" translate="yes" xml:space="preserve">
          <source>If both operands have arithmetic types, or if one operand has unscoped enumeration type and the other has integral type, the usual arithmetic conversions are applied to the operands, and then.</source>
          <target state="translated">Если оба операнда имеют арифметические типы,или если один операнд имеет непонятный тип перечисления,а другой-интегральный тип,то к операндам применяются обычные арифметические приведения,а затем.</target>
        </trans-unit>
        <trans-unit id="3cb97740b2dc89bf4961cce43d6e24c2e65d1e8e" translate="yes" xml:space="preserve">
          <source>If both operands have the same enumeration type E, the operator yields the result of converting the operands to the underlying type of E and applying &lt;code&gt;&amp;lt;=&amp;gt;&lt;/code&gt; to the converted operands.</source>
          <target state="translated">Если оба операнда имеют одинаковый тип перечисления E, оператор выдает результат преобразования операндов в базовый тип E и применения &lt;code&gt;&amp;lt;=&amp;gt;&lt;/code&gt; к преобразованным операндам.</target>
        </trans-unit>
        <trans-unit id="70c8bba595d6b98224b1253c961bdde354216878" translate="yes" xml:space="preserve">
          <source>If both the &lt;code&gt;&lt;a href=&quot;launch&quot;&gt;std::launch::async&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;launch&quot;&gt;std::launch::deferred&lt;/a&gt;&lt;/code&gt; flags are set in &lt;code&gt;policy&lt;/code&gt;, it is up to the implementation whether to perform asynchronous execution or lazy evaluation.</source>
          <target state="translated">Если в &lt;code&gt;policy&lt;/code&gt; установлены флаги &lt;code&gt;&lt;a href=&quot;launch&quot;&gt;std::launch::async&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;launch&quot;&gt;std::launch::deferred&lt;/a&gt;&lt;/code&gt; , то выполнение зависит от того, выполнять асинхронное выполнение или выполнять отложенную оценку.</target>
        </trans-unit>
        <trans-unit id="65568841562f35d225fc26d418379905f6cfe94d" translate="yes" xml:space="preserve">
          <source>If both the converted value and the precision are &lt;code&gt;​0​&lt;/code&gt; the conversion results in no characters.</source>
          <target state="translated">Если оба преобразованное значение и точность являются &lt;code&gt;​0​&lt;/code&gt; результаты преобразования в каких - либо символов.</target>
        </trans-unit>
        <trans-unit id="575a8782581ff485f4e8203e4d066fcc1e4f258b" translate="yes" xml:space="preserve">
          <source>If both the remainder and the quotient can be represented as objects of the corresponding type (int, long, long long, std::imaxdiv_t, respectively), returns both as an object of type &lt;code&gt;std::div_t&lt;/code&gt;, &lt;code&gt;std::ldiv_t&lt;/code&gt;, &lt;code&gt;std::lldiv_t&lt;/code&gt;, &lt;code&gt;std::imaxdiv_t&lt;/code&gt; defined as follows:</source>
          <target state="translated">Если и остаток, и частное могут быть представлены как объекты соответствующего типа (int, long, long long, std :: imaxdiv_t соответственно), возвращает оба объекта как объект типа &lt;code&gt;std::div_t&lt;/code&gt; , &lt;code&gt;std::ldiv_t&lt;/code&gt; , &lt;code&gt;std::lldiv_t&lt;/code&gt; , &lt;code&gt;std::imaxdiv_t&lt;/code&gt; определяется следующим образом:</target>
        </trans-unit>
        <trans-unit id="fa4b3adcc137d0171dfddcda07618256693fd4ac" translate="yes" xml:space="preserve">
          <source>If c16 is the null wide character &lt;code&gt;u'\0'&lt;/code&gt;, a null byte is stored, preceded by any shift sequence necessary to restore the initial shift state and the conversion state parameter &lt;code&gt;*ps&lt;/code&gt; is updated to represent the initial shift state.</source>
          <target state="translated">Если c16 является широким нулевым символом &lt;code&gt;u'\0'&lt;/code&gt; , сохраняется нулевой байт, которому предшествует любая последовательность сдвигов, необходимая для восстановления начального состояния сдвига, а параметр состояния преобразования &lt;code&gt;*ps&lt;/code&gt; обновляется для представления начального состояния сдвига.</target>
        </trans-unit>
        <trans-unit id="0f25466cdf38f545ddf52bc150f2465947dd2dd7" translate="yes" xml:space="preserve">
          <source>If c32 is the null wide character &lt;code&gt;U'\0'&lt;/code&gt;, a null byte is stored, preceded by any shift sequence necessary to restore the initial shift state and the conversion state parameter &lt;code&gt;*ps&lt;/code&gt; is updated to represent the initial shift state.</source>
          <target state="translated">Если c32 является широким нулевым символом &lt;code&gt;U'\0'&lt;/code&gt; , сохраняется нулевой байт, которому предшествует любая последовательность сдвигов, необходимая для восстановления начального состояния сдвига, а параметр &lt;code&gt;*ps&lt;/code&gt; состояния преобразования обновляется для представления начального состояния сдвига.</target>
        </trans-unit>
        <trans-unit id="2180c8a148a56a1d4c18f8160ac19934198a22be" translate="yes" xml:space="preserve">
          <source>If called during exception handling (typically, in a &lt;code&gt;catch&lt;/code&gt; clause), captures the current exception object and creates an &lt;code&gt;&lt;a href=&quot;exception_ptr&quot;&gt;std::exception_ptr&lt;/a&gt;&lt;/code&gt; that holds either a copy or a reference to that exception object (depending on the implementation). The referenced object remains valid at least as long as there is an &lt;code&gt;exception_ptr&lt;/code&gt; object that refers to it.</source>
          <target state="translated">При вызове во время обработки исключений (как правило, в предложении &lt;code&gt;catch&lt;/code&gt; ) захватывает текущий объект исключения и создает &lt;code&gt;&lt;a href=&quot;exception_ptr&quot;&gt;std::exception_ptr&lt;/a&gt;&lt;/code&gt; который содержит копию или ссылку на этот объект исключения (в зависимости от реализации). Указанный объект остается действительным, по крайней мере, до тех пор, пока существует объект &lt;code&gt;exception_ptr&lt;/code&gt; , который ссылается на него.</target>
        </trans-unit>
        <trans-unit id="f5efa0791c0ccd4598c1223b0ede652827016b2d" translate="yes" xml:space="preserve">
          <source>If class-level &lt;code&gt;operator delete&lt;/code&gt; is a template function, it must have the return type of &lt;code&gt;void&lt;/code&gt;, the first argument &lt;code&gt;void*&lt;/code&gt;, and it must have two or more parameters. In other words, only placement forms can be templates. The specialization of the template operator delete is chosen with &lt;a href=&quot;../../language/template_argument_deduction&quot;&gt;template argument deduction&lt;/a&gt;.</source>
          <target state="translated">Если &lt;code&gt;operator delete&lt;/code&gt; уровня класса delete является функцией шаблона, он должен иметь возвращаемый тип &lt;code&gt;void&lt;/code&gt; , первый аргумент &lt;code&gt;void*&lt;/code&gt; , и он должен иметь два или более параметров. Другими словами, только формы размещения могут быть шаблонами. Специализация оператора шаблона выбирается с &lt;a href=&quot;../../language/template_argument_deduction&quot;&gt;вычетом аргумента шаблона&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="07af41f04d885dcdd7da101bd31c36d13b61ce99" translate="yes" xml:space="preserve">
          <source>If class-level &lt;code&gt;operator new&lt;/code&gt; is a template function, it must have the return type of &lt;code&gt;void*&lt;/code&gt;, the first argument &lt;code&gt;std::size_t&lt;/code&gt;, and it must have two or more parameters. In other words, only placement forms can be templates.</source>
          <target state="translated">Если &lt;code&gt;operator new&lt;/code&gt; уровня класса new является функцией шаблона, он должен иметь возвращаемый тип &lt;code&gt;void*&lt;/code&gt; , первый аргумент &lt;code&gt;std::size_t&lt;/code&gt; и иметь два или более параметров. Другими словами, только формы размещения могут быть шаблонами.</target>
        </trans-unit>
        <trans-unit id="ceee4451276b8b4bcab8ca22c22b303c8fd7055d" translate="yes" xml:space="preserve">
          <source>If concurrent calls to call_once pass different functions &lt;code&gt;f&lt;/code&gt;, it is unspecified which &lt;code&gt;f&lt;/code&gt; will be called. The selected function runs in the same thread as the &lt;code&gt;call_once&lt;/code&gt; invocation it was passed to.</source>
          <target state="translated">Если одновременные вызовы call_once передают разные функции &lt;code&gt;f&lt;/code&gt; , то не определено, какой &lt;code&gt;f&lt;/code&gt; будет вызван. &lt;code&gt;call_once&lt;/code&gt; функция выполняется в том же потоке, что и вызов call_once, которому она была передана.</target>
        </trans-unit>
        <trans-unit id="e0b50d3647e11790677fe9a4c279326685cf8395" translate="yes" xml:space="preserve">
          <source>If condition evaluates to the value that doesn't match any of the &lt;code&gt;case:&lt;/code&gt; labels, and the &lt;code&gt;default:&lt;/code&gt; label is present, control is transferred to the statement labeled with the &lt;code&gt;default:&lt;/code&gt; label.</source>
          <target state="translated">Если условие оценивается как значение, которое не соответствует ни одному из &lt;code&gt;case:&lt;/code&gt; label, и присутствует &lt;code&gt;default:&lt;/code&gt; label, управление передается в оператор, помеченный &lt;code&gt;default:&lt;/code&gt; label.</target>
        </trans-unit>
        <trans-unit id="c5d36a23ea15e574cf486f3e1d5ad8940a574a30" translate="yes" xml:space="preserve">
          <source>If condition evaluates to the value that is equal to the value of one of constant_expressions, then control is transferred to the statement that is labeled with that constant_expression.</source>
          <target state="translated">Если условие вычисляется до значения,равного значению одного из выражений константы_выражения,то управление передается оператору,помеченному этим выражением константы_выражения.</target>
        </trans-unit>
        <trans-unit id="5aa862d229a90e1dcafc139a33ba48261cc1ac13" translate="yes" xml:space="preserve">
          <source>If condition is a declaration such as &lt;code&gt;T t = x&lt;/code&gt;, the declared variable is only in scope in the body of the loop, and is destroyed and recreated on every iteration, in other words, such while loop is equivalent to.</source>
          <target state="translated">Если условие является объявлением, таким как &lt;code&gt;T t = x&lt;/code&gt; , объявленная переменная находится только в области видимости в теле цикла и уничтожается и воссоздается на каждой итерации, другими словами, такой как цикл эквивалентен.</target>
        </trans-unit>
        <trans-unit id="cc5437232ebb64eb1e0a00ed4f6909a6272177e2" translate="yes" xml:space="preserve">
          <source>If control reaches the end of a function with the return type &lt;code&gt;void&lt;/code&gt; (possibly cv-qualified), end of a constructor, end of a destructor, or the end of a &lt;a href=&quot;function-try-block&quot;&gt;function-try-block&lt;/a&gt; for a function with the return type (possibly cv-qualified) &lt;code&gt;void&lt;/code&gt; without encountering a return statement, &lt;code&gt;return;&lt;/code&gt; is executed.</source>
          <target state="translated">Если управление достигает конца функции с возвращаемым типом &lt;code&gt;void&lt;/code&gt; (возможно, cv-qualified), концом конструктора, концом деструктора или концом &lt;a href=&quot;function-try-block&quot;&gt;функции-try-block&lt;/a&gt; для функции с возвращаемым типом (возможно cv -квалифицированный) &lt;code&gt;void&lt;/code&gt; не встречая возврата, &lt;code&gt;return;&lt;/code&gt; выполнен.</target>
        </trans-unit>
        <trans-unit id="62b123ef59b7917fbc8133c9aaa1f1f874506d99" translate="yes" xml:space="preserve">
          <source>If control reaches the end of the &lt;a href=&quot;main_function&quot;&gt;main function&lt;/a&gt;, &lt;code&gt;return 0;&lt;/code&gt; is executed.</source>
          <target state="translated">Если управление достигает конца &lt;a href=&quot;main_function&quot;&gt;основной функции&lt;/a&gt; , &lt;code&gt;return 0;&lt;/code&gt; выполнен.</target>
        </trans-unit>
        <trans-unit id="49147bdd2f3429795748cce29beffb564badb873" translate="yes" xml:space="preserve">
          <source>If cv appears after &lt;code&gt;*&lt;/code&gt; in the pointer declaration, it is part of declarator and applies to the pointer that's being declared.</source>
          <target state="translated">Если cv появляется после &lt;code&gt;*&lt;/code&gt; в объявлении указателя, это часть объявления и применяется к указателю, который объявлен.</target>
        </trans-unit>
        <trans-unit id="4d8f20c7d00a034ba772281f4476c576329d5b6f" translate="yes" xml:space="preserve">
          <source>If cv appears before &lt;code&gt;*&lt;/code&gt; in the pointer declaration, it is part of decl-specifier-seq and applies to the the pointed-to object.</source>
          <target state="translated">Если cv появляется перед &lt;code&gt;*&lt;/code&gt; в объявлении указателя, это является частью decl-specier-seq и применяется к объекту, на который указывает указатель.</target>
        </trans-unit>
        <trans-unit id="dbec49aac99d6e7dc2b90341eae53b09e233425a" translate="yes" xml:space="preserve">
          <source>If declarations &lt;code&gt;D1&lt;/code&gt; and &lt;code&gt;D2&lt;/code&gt; are constrained and D1's associated constraints subsume D2's associated constraints (or if D2 is unconstrained), then D1 is said to be</source>
          <target state="translated">Если объявления &lt;code&gt;D1&lt;/code&gt; и &lt;code&gt;D2&lt;/code&gt; ограничены, а связанные ограничения D1 включают в себя связанные ограничения D2 (или если D2 не ограничен), то говорят, что D1</target>
        </trans-unit>
        <trans-unit id="2411be601f654a07bbdca0b7276e84a7d05756e0" translate="yes" xml:space="preserve">
          <source>If deduction fails , or if deduction succeeds, but the specialization it produces would be invalid (for example, an overloaded operator whose parameters are neither class nor enumeration types),(since C++14) the specialization is not included in the overload set, similar to &lt;a href=&quot;sfinae&quot;&gt;SFINAE&lt;/a&gt;.</source>
          <target state="translated">Если дедукция не удалась или дедукция удалась, но специализация, которую она производит, была бы недопустимой (например, перегруженный оператор, параметры которого не являются ни типом класса, ни типом перечисления), (начиная с C ++ 14) специализация не включена в набор перегрузки , похожий на &lt;a href=&quot;sfinae&quot;&gt;SFINAE&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5007ba94c2b890c9a53ac3f2ede0070a7fe62fea" translate="yes" xml:space="preserve">
          <source>If deduction succeeds in both directions, and the original &lt;code&gt;P&lt;/code&gt; and &lt;code&gt;A&lt;/code&gt; were reference types, then additional tests are made:</source>
          <target state="translated">Если вычет успешен в обоих направлениях, и исходные &lt;code&gt;P&lt;/code&gt; и &lt;code&gt;A&lt;/code&gt; были ссылочными типами, то выполняются дополнительные тесты:</target>
        </trans-unit>
        <trans-unit id="c96fa04a65c71e2fd19130c8575defd3c41edbfb" translate="yes" xml:space="preserve">
          <source>If either &lt;code&gt;M&lt;/code&gt; or &lt;code&gt;N&lt;/code&gt; is not an integer type, or if either is (possibly cv-qualified) &lt;code&gt;bool&lt;/code&gt;, the program is ill-formed.</source>
          <target state="translated">Если либо &lt;code&gt;M&lt;/code&gt; , либо &lt;code&gt;N&lt;/code&gt; не является целочисленным типом, либо если они являются (возможно, cv-квалифицированными) &lt;code&gt;bool&lt;/code&gt; , программа некорректна.</target>
        </trans-unit>
        <trans-unit id="c79ea3237a0ed39b951058e0ae87cf69e04e9f5e" translate="yes" xml:space="preserve">
          <source>If either &lt;code&gt;dest&lt;/code&gt; or &lt;code&gt;src&lt;/code&gt; is a null pointer, the behavior is undefined, even if &lt;code&gt;count&lt;/code&gt; is zero.</source>
          <target state="translated">Если &lt;code&gt;dest&lt;/code&gt; или &lt;code&gt;src&lt;/code&gt; является нулевым указателем, поведение не определено, даже если &lt;code&gt;count&lt;/code&gt; равен нулю.</target>
        </trans-unit>
        <trans-unit id="1250474b9c6ad69852373ae63ef180eb204a2f48" translate="yes" xml:space="preserve">
          <source>If either &lt;code&gt;from&lt;/code&gt; or &lt;code&gt;to&lt;/code&gt; has an implementation-defined &lt;a href=&quot;file_type&quot;&gt;file type&lt;/a&gt;, the effects of this function are implementation-defined.</source>
          <target state="translated">Если &lt;code&gt;from&lt;/code&gt; или &lt;code&gt;to&lt;/code&gt; имеет &lt;a href=&quot;file_type&quot;&gt;тип файла,&lt;/a&gt; определенный реализацией , эффекты этой функции определяются реализацией.</target>
        </trans-unit>
        <trans-unit id="4165a5260d21b11f33113753f30c5f524bccf1ba" translate="yes" xml:space="preserve">
          <source>If either &lt;code&gt;from&lt;/code&gt; or &lt;code&gt;to&lt;/code&gt; is not a regular file, a directory, or a symlink, as determined by &lt;code&gt;&lt;a href=&quot;is_other&quot;&gt;std::filesystem::is_other&lt;/a&gt;&lt;/code&gt;, reports an error</source>
          <target state="translated">Если &lt;code&gt;from&lt;/code&gt; или &lt;code&gt;to&lt;/code&gt; не является обычным файлом, каталог или символическая ссылка, как определено &lt;code&gt;&lt;a href=&quot;is_other&quot;&gt;std::filesystem::is_other&lt;/a&gt;&lt;/code&gt; , сообщает об ошибке</target>
        </trans-unit>
        <trans-unit id="6f243ca5c29fe6335eb0defcad2154158bb206f7" translate="yes" xml:space="preserve">
          <source>If either &lt;code&gt;m&lt;/code&gt; or &lt;code&gt;n&lt;/code&gt; is zero, returns zero. Otherwise, returns the least common multiple of &lt;code&gt;|m|&lt;/code&gt; and &lt;code&gt;|n|&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;m&lt;/code&gt; или &lt;code&gt;n&lt;/code&gt; равно нулю, возвращает ноль. В противном случае возвращает наименьшее общее кратное &lt;code&gt;|m|&lt;/code&gt; и &lt;code&gt;|n|&lt;/code&gt; ,</target>
        </trans-unit>
        <trans-unit id="1dab1eb6195d1939bf5f575a24a97060849eb62a" translate="yes" xml:space="preserve">
          <source>If either &lt;code&gt;p1&lt;/code&gt; or &lt;code&gt;p2&lt;/code&gt; does not exist, an error is reported.</source>
          <target state="translated">Если &lt;code&gt;p1&lt;/code&gt; или &lt;code&gt;p2&lt;/code&gt; не существует, сообщается об ошибке.</target>
        </trans-unit>
        <trans-unit id="192b44dddfe8a0edbf403637b9dc082e8fcbccab" translate="yes" xml:space="preserve">
          <source>If either &lt;code&gt;x&lt;/code&gt; is NaN or &lt;code&gt;y&lt;/code&gt; is NaN, NaN is returned</source>
          <target state="translated">Если &lt;code&gt;x&lt;/code&gt; равен NaN или &lt;code&gt;y&lt;/code&gt; равен NaN, возвращается NaN</target>
        </trans-unit>
        <trans-unit id="5798cb4e0bd7a6d21c2a60a89c9c101a7f709c34" translate="yes" xml:space="preserve">
          <source>If either &lt;code&gt;x&lt;/code&gt; or &lt;code&gt;y&lt;/code&gt; is NaN, NaN is returned</source>
          <target state="translated">Если &lt;code&gt;x&lt;/code&gt; или &lt;code&gt;y&lt;/code&gt; равен NaN, возвращается NaN</target>
        </trans-unit>
        <trans-unit id="777b045843b0ca1ef95a9acf19549cb4d27be21b" translate="yes" xml:space="preserve">
          <source>If either &lt;code&gt;|m|&lt;/code&gt; or &lt;code&gt;|n|&lt;/code&gt; is not representable as a value of type &lt;code&gt;&lt;a href=&quot;../types/common_type&quot;&gt;std::common_type_t&lt;/a&gt;&amp;lt;M, N&amp;gt;&lt;/code&gt;, the behavior is undefined.</source>
          <target state="translated">Если либо &lt;code&gt;|m|&lt;/code&gt; или &lt;code&gt;|n|&lt;/code&gt; не может быть представлено как значение типа &lt;code&gt;&lt;a href=&quot;../types/common_type&quot;&gt;std::common_type_t&lt;/a&gt;&amp;lt;M, N&amp;gt;&lt;/code&gt; , поведение не определено.</target>
        </trans-unit>
        <trans-unit id="b1b8d9bd67fa1ccf8414b0062f383f3be7b83851" translate="yes" xml:space="preserve">
          <source>If either argument is NaN, NaN is returned</source>
          <target state="translated">Если любой из аргументов-NaN,возвращается NaN.</target>
        </trans-unit>
        <trans-unit id="503d04bbbfdfac42a885dc014eabc01dd48a5379" translate="yes" xml:space="preserve">
          <source>If either function is declared despite being unspecified, it is unspecified what its return type is, except that the declaration (although not necessarily the definition) of the function is guaranteed to be legal. This makes it possible to instantiate &lt;code&gt;&lt;a href=&quot;../shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&amp;lt;void&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">Если какая-либо функция объявляется, несмотря на то, что она не указана, она не указывает, какой у нее тип возврата, за исключением того, что объявление (хотя и не обязательно определение) функции гарантированно будет допустимым. Это позволяет создать экземпляр &lt;code&gt;&lt;a href=&quot;../shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&amp;lt;void&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="dea65a53043b826e1ccaac4bd2898d99fa59f1dd" translate="yes" xml:space="preserve">
          <source>If either operand has scoped enumeration type, no conversion is performed: the other operand and the return type must have the same type</source>
          <target state="translated">Если любой из операндов имеет scoped тип перечисления,преобразование не выполняется:другой операнд и возвращаемый тип должны иметь один и тот же тип</target>
        </trans-unit>
        <trans-unit id="4facc3a3dde5ddbefb08336856d6b20eb05ed6dc" translate="yes" xml:space="preserve">
          <source>If either the remainder or the quotient cannot be represented, the behavior is undefined.</source>
          <target state="translated">Если ни остаток,ни коэффициент не могут быть представлены,поведение не определено.</target>
        </trans-unit>
        <trans-unit id="529682e54cfd3160519cd2474a27a6556b3a893e" translate="yes" xml:space="preserve">
          <source>If erasing at begin - only erased elements</source>
          <target state="translated">Если стирание в начале-только стираемые элементы</target>
        </trans-unit>
        <trans-unit id="de5cb8f72cd15ee74ae08d973ff1870dcb3c7c8e" translate="yes" xml:space="preserve">
          <source>If erasing at end - only erased elements and the past-the-end iterator</source>
          <target state="translated">При окончательном стирании-только стираемые элементы и итератор в прошлом</target>
        </trans-unit>
        <trans-unit id="9de48b7003a6c58f9874d3ee61667a92104df825" translate="yes" xml:space="preserve">
          <source>If errors prevent even knowing whether &lt;code&gt;p&lt;/code&gt; exists, the non-throwing overload sets &lt;code&gt;ec&lt;/code&gt; and returns &lt;code&gt;file_status(file_type::none)&lt;/code&gt;, and the throwing overload throws &lt;code&gt;filesystem_error&lt;/code&gt;</source>
          <target state="translated">Если ошибки мешают даже узнать, существует ли &lt;code&gt;p&lt;/code&gt; , перегрузка без выброса устанавливает &lt;code&gt;ec&lt;/code&gt; и возвращает &lt;code&gt;file_status(file_type::none)&lt;/code&gt; , а перегрузка выброса выбрасывает &lt;code&gt;filesystem_error&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3d96531c98aaf0d81f4a8e0e1ddfb0d8bc73bc9f" translate="yes" xml:space="preserve">
          <source>If execution of a function invoked as part of the algorithm throws an exception and &lt;code&gt;ExecutionPolicy&lt;/code&gt; is one of the &lt;a href=&quot;../algorithm/execution_policy_tag_t&quot;&gt;standard policies&lt;/a&gt;, &lt;code&gt;&lt;a href=&quot;../error/terminate&quot;&gt;std::terminate&lt;/a&gt;&lt;/code&gt; is called. For any other &lt;code&gt;ExecutionPolicy&lt;/code&gt;, the behavior is implementation-defined.</source>
          <target state="translated">Если выполнение функции, вызванной как часть алгоритма, вызывает исключение, и &lt;code&gt;ExecutionPolicy&lt;/code&gt; является одной из &lt;a href=&quot;../algorithm/execution_policy_tag_t&quot;&gt;стандартных политик&lt;/a&gt; , вызывается &lt;code&gt;&lt;a href=&quot;../error/terminate&quot;&gt;std::terminate&lt;/a&gt;&lt;/code&gt; . Для любого другого &lt;code&gt;ExecutionPolicy&lt;/code&gt; поведение определяется реализацией.</target>
        </trans-unit>
        <trans-unit id="2f4657ab0e97f8d71eba8e43d00ec9ecedaa739f" translate="yes" xml:space="preserve">
          <source>If execution of a function invoked as part of the algorithm throws an exception and &lt;code&gt;ExecutionPolicy&lt;/code&gt; is one of the &lt;a href=&quot;execution_policy_tag_t&quot;&gt;standard policies&lt;/a&gt;, &lt;code&gt;&lt;a href=&quot;../error/terminate&quot;&gt;std::terminate&lt;/a&gt;&lt;/code&gt; is called. For any other &lt;code&gt;ExecutionPolicy&lt;/code&gt;, the behavior is implementation-defined.</source>
          <target state="translated">Если выполнение функции, вызванной как часть алгоритма, вызывает исключение, и &lt;code&gt;ExecutionPolicy&lt;/code&gt; является одной из &lt;a href=&quot;execution_policy_tag_t&quot;&gt;стандартных политик&lt;/a&gt; , вызывается &lt;code&gt;&lt;a href=&quot;../error/terminate&quot;&gt;std::terminate&lt;/a&gt;&lt;/code&gt; . Для любого другого &lt;code&gt;ExecutionPolicy&lt;/code&gt; поведение определяется реализацией.</target>
        </trans-unit>
        <trans-unit id="9a2f05c159a24f9f71a90bb51a81dc74cfece89a" translate="yes" xml:space="preserve">
          <source>If expr is omitted in the declaration of an array, the type declared is &quot;array of unknown bound of T&quot;, which is a kind of &lt;a href=&quot;incomplete_type&quot;&gt;incomplete type&lt;/a&gt;, except when used in a declaration with an &lt;a href=&quot;aggregate_initialization&quot;&gt;aggregate initializer&lt;/a&gt;:</source>
          <target state="translated">Если expr опущен в объявлении массива, объявленным типом является &amp;laquo;массив неизвестной границы T&amp;raquo;, который является своего рода &lt;a href=&quot;incomplete_type&quot;&gt;неполным типом&lt;/a&gt; , за исключением случаев, когда он используется в объявлении с &lt;a href=&quot;aggregate_initialization&quot;&gt;агрегатным инициализатором&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="d71ce2b38f67adf9252fa0e30106230c2ec3b97c" translate="yes" xml:space="preserve">
          <source>If expression evaluates to a null pointer value, no destructors are called, and the deallocation function is not called.</source>
          <target state="translated">Если выражение вычисляется до нулевого значения указателя,то деструкторы не вызываются,а функция распределения сделок не вызывается.</target>
        </trans-unit>
        <trans-unit id="6030f7d71e85a510bb8fdfa1c9d0573272b5c6c2" translate="yes" xml:space="preserve">
          <source>If expression evaluates to a null pointer value, no destructors are called, and the deallocation function may or may not be called (it's implementation-defined), but the default deallocation functions are guaranteed to do nothing when handed a null pointer.</source>
          <target state="translated">Если выражение вычисляется до значения нулевого указателя,то деструкторы не вызываются,и функция распределения сделок может вызываться или не вызываться (она определяется реализацией),но функции распределения сделок по умолчанию гарантированно ничего не делают при вручении нулевого указателя.</target>
        </trans-unit>
        <trans-unit id="5c393875f487dbcd2dff5fb7351c909c9b7c6ee3" translate="yes" xml:space="preserve">
          <source>If expression evaluates to a pointer to a base class subobject of the object that was allocated with &lt;a href=&quot;new&quot;&gt;new&lt;/a&gt;, the destructor of the base class must be virtual, otherwise the behavior is undefined.</source>
          <target state="translated">Если выражение вычисляется как указатель на подобъект базового класса объекта, который был выделен с помощью &lt;a href=&quot;new&quot;&gt;new&lt;/a&gt; , деструктор базового класса должен быть виртуальным, в противном случае поведение не определено.</target>
        </trans-unit>
        <trans-unit id="1c30833ec734b1a7a3060b4576f5f2e61609aa23" translate="yes" xml:space="preserve">
          <source>If expression has array type &lt;code&gt;A&lt;/code&gt; and no ref-operator is present, then &lt;code&gt;&lt;i&gt;e&lt;/i&gt;&lt;/code&gt; has type</source>
          <target state="translated">Если выражение имеет тип массива &lt;code&gt;A&lt;/code&gt; и отсутствует ref-оператор, то &lt;code&gt;&lt;i&gt;e&lt;/i&gt;&lt;/code&gt; имеет тип</target>
        </trans-unit>
        <trans-unit id="e6b3ab3f640c9298f96902e88e604333b949d1d4" translate="yes" xml:space="preserve">
          <source>If expression is a function call which returns a prvalue of class type or is a &lt;a href=&quot;operator_other&quot;&gt;comma expression&lt;/a&gt; whose right operand is such a function call, a temporary object is not introduced for that prvalue.</source>
          <target state="translated">Если выражение - это вызов функции, который возвращает значение типа класса или &lt;a href=&quot;operator_other&quot;&gt;выражение&lt;/a&gt; с запятой , правым операндом которого является такой вызов функции, временный объект для этого значения не вводится.</target>
        </trans-unit>
        <trans-unit id="fcbd7c68e8be5419186b82db2695d726340da722" translate="yes" xml:space="preserve">
          <source>If expression is a prvalue other than a (possibly parenthesized) &lt;a href=&quot;consteval&quot;&gt;immediate invocation&lt;/a&gt;(since C++20), a temporary object is not &lt;a href=&quot;implicit_cast#Temporary_materialization&quot;&gt;materialized&lt;/a&gt; from that prvalue.</source>
          <target state="translated">Если выражение представляет собой значение, отличное от (возможно, заключенного в скобки) &lt;a href=&quot;consteval&quot;&gt;немедленного вызова&lt;/a&gt; (начиная с C ++ 20), временный объект не &lt;a href=&quot;implicit_cast#Temporary_materialization&quot;&gt;материализуется&lt;/a&gt; из этого значения.</target>
        </trans-unit>
        <trans-unit id="5eb42168b532c7b11548b11828f78705b38da223" translate="yes" xml:space="preserve">
          <source>If expression is a prvalue, the result object is initialized directly by that expression. This does not involve a copy or move constructor when the types match (see &lt;a href=&quot;copy_elision&quot;&gt;copy elision&lt;/a&gt;).</source>
          <target state="translated">Если выражение является значением, результирующий объект инициализируется непосредственно этим выражением. Это не включает конструктор копирования или перемещения, когда типы совпадают (см. &lt;a href=&quot;copy_elision&quot;&gt;Раздел &amp;laquo;Разрешение копирования&amp;raquo;&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="4e15b97975662cad27203429fdb2250f97231751" translate="yes" xml:space="preserve">
          <source>If expression is an lvalue expression that is the (possibly parenthesized) name of an automatic storage duration object declared in the body or as a parameter of the innermost enclosing function or lambda expression, then &lt;a href=&quot;overload_resolution&quot;&gt;overload resolution&lt;/a&gt; to select the constructor to use for initialization of the returned value or, for &lt;code&gt;co_return&lt;/code&gt;, to select the overload of &lt;code&gt;promise.return_value()&lt;/code&gt;(since C++20) is performed</source>
          <target state="translated">Если выражение является выражением lvalue, которое является (возможно, заключенным в скобки) именем объекта длительности автоматического хранения, объявленного в теле или в качестве параметра самой внутренней включающей функции или лямбда-выражения, тогда &lt;a href=&quot;overload_resolution&quot;&gt;разрешите перегрузку,&lt;/a&gt; чтобы выбрать конструктор, который будет использоваться для инициализации объекта. возвращаемое значение или, для &lt;code&gt;co_return&lt;/code&gt; , выбрать перегрузку &lt;code&gt;promise.return_value()&lt;/code&gt; (начиная с C ++ 20)</target>
        </trans-unit>
        <trans-unit id="adc41fc0a93030206f4cdfeba4b6fcb313c8da70" translate="yes" xml:space="preserve">
          <source>If expression is not a null pointer and the &lt;a href=&quot;../memory/new/operator_delete&quot;&gt; deallocation function&lt;/a&gt; is not a destroying delete(since C++20), the &lt;code&gt;delete&lt;/code&gt; expression invokes the &lt;a href=&quot;destructor&quot;&gt;destructor&lt;/a&gt; (if any) for the object that's being destroyed, or for every element of the array being destroyed (proceeding from the last element to the first element of the array).</source>
          <target state="translated">Если выражение не является нулевым указателем и &lt;a href=&quot;../memory/new/operator_delete&quot;&gt;функция освобождения&lt;/a&gt; не является уничтожающим удалением (начиная с C ++ 20), выражение &lt;code&gt;delete&lt;/code&gt; вызывает &lt;a href=&quot;destructor&quot;&gt;деструктор&lt;/a&gt; (если есть) для уничтожаемого объекта или для каждого элемента уничтожаемого массива (исходя из последнего элемента в первый элемент массива).</target>
        </trans-unit>
        <trans-unit id="d68091a3a051bfac77278071ebbbc0e0bd6aacd1" translate="yes" xml:space="preserve">
          <source>If extraction fails (e.g. if a letter was entered where a digit is expected), &lt;code&gt;value&lt;/code&gt; is left unmodified and &lt;code&gt;failbit&lt;/code&gt; is set.</source>
          <target state="translated">Если извлечение завершается неудачно (например, если буква была введена там, где ожидается цифра), &lt;code&gt;value&lt;/code&gt; остается неизменным, и &lt;code&gt;failbit&lt;/code&gt; устанавливается.</target>
        </trans-unit>
        <trans-unit id="88e6442a7bfe1de939efde09d5178c75fe73775c" translate="yes" xml:space="preserve">
          <source>If extraction fails, zero is written to &lt;code&gt;value&lt;/code&gt; and &lt;code&gt;failbit&lt;/code&gt; is set. If extraction results in the value too large or too small to fit in &lt;code&gt;value&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../../types/numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::max()&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../../types/numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::min()&lt;/code&gt; is written and &lt;code&gt;failbit&lt;/code&gt; flag is set.</source>
          <target state="translated">Если извлечение завершается неудачно, в &lt;code&gt;value&lt;/code&gt; записывается ноль, и &lt;code&gt;failbit&lt;/code&gt; устанавливается. Если извлечение приводит к тому, что значение слишком велико или слишком мало, чтобы поместиться в &lt;code&gt;value&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../../types/numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::max()&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;../../types/numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::min()&lt;/code&gt; и &lt;code&gt;failbit&lt;/code&gt; флаг сбоя .</target>
        </trans-unit>
        <trans-unit id="9f80eb0726a214c94ee0e311172def7a79d33bde" translate="yes" xml:space="preserve">
          <source>If feature testing is supported, the features described here are indicated by the macro constant &lt;code&gt;__cpp_transactional_memory&lt;/code&gt; with a value equal or greater &lt;code&gt;201505&lt;/code&gt;.</source>
          <target state="translated">Если поддерживается тестирование функций, описанные здесь функции указываются &lt;code&gt;__cpp_transactional_memory&lt;/code&gt; со значением, равным или большим &lt;code&gt;201505&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7451ef31b492ad560a6bc540d182167c27d069c5" translate="yes" xml:space="preserve">
          <source>If for some &lt;code&gt;c&lt;/code&gt;, &lt;code&gt;X​::​eq_int_type(e, X​::​to_int_type(c))&lt;/code&gt; is true, &lt;code&gt;c&lt;/code&gt;</source>
          <target state="translated">Если для некоторого &lt;code&gt;c&lt;/code&gt; , &lt;code&gt;X​::​eq_int_type(e, X​::​to_int_type(c))&lt;/code&gt; имеет значение true, &lt;code&gt;c&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3824d6a7dbddfd44d6a10b166cb4fa4fdc9aa537" translate="yes" xml:space="preserve">
          <source>If forward declaration appears in local scope, it</source>
          <target state="translated">Если прямое заявление появляется в местном масштабе,то оно</target>
        </trans-unit>
        <trans-unit id="64e89aa46e58a2c727a5922e705eb374f16e676e" translate="yes" xml:space="preserve">
          <source>If implemented, returns the number of characters left to read from the file.</source>
          <target state="translated">Если реализовано,возвращает количество символов,оставшихся для чтения из файла.</target>
        </trans-unit>
        <trans-unit id="1dbd63790122a2d4ba6e64de77bc6208558b4f4f" translate="yes" xml:space="preserve">
          <source>If init-statement is used, the if statement is equivalent to.</source>
          <target state="translated">Если используется инициализированное заявление,то оно эквивалентно.</target>
        </trans-unit>
        <trans-unit id="3828f6a7891b0f54ec954884dcea4fe13ee69fe4" translate="yes" xml:space="preserve">
          <source>If init-statement is used, the switch statement is equivalent to.</source>
          <target state="translated">Если используется инит-выражение,то оператор переключения эквивалентен.</target>
        </trans-unit>
        <trans-unit id="c47d0b28593af3bb521e18dc6a2d3803710c1f80" translate="yes" xml:space="preserve">
          <source>If initialization terminates by throwing an exception (e.g. from the constructor), if new-expression allocated any storage, it calls the appropriate &lt;a href=&quot;../memory/new/operator_delete&quot;&gt;deallocation function&lt;/a&gt;: &lt;code&gt;&lt;a href=&quot;../memory/new/operator_delete&quot;&gt;operator delete&lt;/a&gt;&lt;/code&gt; for non-array &lt;code&gt;type&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../memory/new/operator_delete&quot;&gt;operator delete&lt;/a&gt;[]&lt;/code&gt; for array &lt;code&gt;type&lt;/code&gt;. The deallocation function is looked up in global scope if the new-expression used the &lt;code&gt;::new&lt;/code&gt; syntax, otherwise it is looked up in the scope of &lt;code&gt;T&lt;/code&gt;, if &lt;code&gt;T&lt;/code&gt; is a class type. If the failed allocation function was usual (non-placement), lookup for the deallocation function follows the rules described in &lt;a href=&quot;delete&quot;&gt;delete-expression&lt;/a&gt;. For a failed placement new, all parameter types, except the first, of the matching deallocation function must be identical to the parameters of the placement new. The call to the deallocation function is made the value obtained earlier from the allocation function passed as the first argument, alignment passed as the optional alignment argument(since C++17), and &lt;code&gt;placement_params&lt;/code&gt;, if any, passed as the additional placement arguments. If no deallocation function is found, memory is not deallocated.</source>
          <target state="translated">Если инициализация завершается с помощью исключения (например, из конструктора), если new-expression выделило какое-либо хранилище, оно вызывает соответствующую &lt;a href=&quot;../memory/new/operator_delete&quot;&gt;функцию освобождения&lt;/a&gt; : &lt;code&gt;&lt;a href=&quot;../memory/new/operator_delete&quot;&gt;operator delete&lt;/a&gt;&lt;/code&gt; для &lt;code&gt;type&lt;/code&gt; , не являющегося массивом , &lt;code&gt;&lt;a href=&quot;../memory/new/operator_delete&quot;&gt;operator delete&lt;/a&gt;[]&lt;/code&gt; для &lt;code&gt;type&lt;/code&gt; массива . Функция освобождения ищется в глобальной области видимости, если new-выражение использовало синтаксис &lt;code&gt;::new&lt;/code&gt; , в противном случае она ищется в области видимости &lt;code&gt;T&lt;/code&gt; , если &lt;code&gt;T&lt;/code&gt; является типом класса. Если функция неудачного размещения была обычной (без размещения), поиск функции освобождения следует правилам, описанным в &lt;a href=&quot;delete&quot;&gt;выражении удаления&lt;/a&gt;, При неудачном размещении нового все типы параметров, кроме первого, соответствующей функции освобождения должны быть идентичны параметрам нового размещения. Вызов функции освобождения делается из значения, полученного ранее из функции выделения, переданного в качестве первого аргумента, выравнивания, переданного в качестве необязательного аргумента выравнивания (начиная с C ++ 17), и &lt;code&gt;placement_params&lt;/code&gt; , если они есть, передаются в качестве дополнительных аргументов размещения. Если функция освобождения не найдена, память не освобождается.</target>
        </trans-unit>
        <trans-unit id="25af59fbe30345e9f2749bc57dd4353c2aaf12fb" translate="yes" xml:space="preserve">
          <source>If initializer is a brace-enclosed list of arguments, the array is &lt;a href=&quot;aggregate_initialization&quot;&gt;aggregate-initialized&lt;/a&gt;.</source>
          <target state="translated">Если инициализатор представляет собой заключенный в скобки список аргументов, массив &lt;a href=&quot;aggregate_initialization&quot;&gt;инициализируется агрегатно&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="03cdfead59246b594ac83a38977a55a017d25ad2" translate="yes" xml:space="preserve">
          <source>If initializer is a brace-enclosed list of arguments, the object is &lt;a href=&quot;list_initialization&quot;&gt;list-initialized&lt;/a&gt;.</source>
          <target state="translated">Если инициализатор представляет собой заключенный в скобки список аргументов, объект &lt;a href=&quot;list_initialization&quot;&gt;инициализируется списком&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="cb798be20c8b8f83663a5d3251bd571437d043f9" translate="yes" xml:space="preserve">
          <source>If initializer is a parenthesized list of arguments, the array is &lt;a href=&quot;aggregate_initialization&quot;&gt;aggregate-initialized&lt;/a&gt;.</source>
          <target state="translated">Если инициализатор представляет собой заключенный в скобки список аргументов, массив &lt;a href=&quot;aggregate_initialization&quot;&gt;инициализируется агрегатно&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f352a230f880eaabfec8de9e04e32d41381d1c34" translate="yes" xml:space="preserve">
          <source>If initializer is a parenthesized list of arguments, the object is &lt;a href=&quot;direct_initialization&quot;&gt;direct-initialized&lt;/a&gt;.</source>
          <target state="translated">Если инициализатор представляет собой заключенный в скобки список аргументов, объект &lt;a href=&quot;direct_initialization&quot;&gt;инициализируется напрямую&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b6b9b4663cfe2da6404a6f0c08f1da0645b33d77" translate="yes" xml:space="preserve">
          <source>If initializer is absent, each element is &lt;a href=&quot;default_initialization&quot;&gt;default-initialized&lt;/a&gt;</source>
          <target state="translated">Если инициализатор отсутствует, каждый элемент &lt;a href=&quot;default_initialization&quot;&gt;инициализируется по умолчанию&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="05b0a18ac26e055f0b1b9a9cd56c953cc13ad39f" translate="yes" xml:space="preserve">
          <source>If initializer is absent, the object is &lt;a href=&quot;default_initialization&quot;&gt;default-initialized&lt;/a&gt;.</source>
          <target state="translated">Если инициализатор отсутствует, объект &lt;a href=&quot;default_initialization&quot;&gt;инициализируется по умолчанию&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a4a45120f7db08d564e532f628e9ea01317f74f2" translate="yes" xml:space="preserve">
          <source>If initializer is an empty pair of parentheses, each element is &lt;a href=&quot;value_initialization&quot;&gt;value-initialized&lt;/a&gt;.</source>
          <target state="translated">Если инициализатор представляет собой пустую пару скобок, каждый элемент &lt;a href=&quot;value_initialization&quot;&gt;инициализируется значением&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="19ed0a48a00d9537e7ba64e93a84031252754715" translate="yes" xml:space="preserve">
          <source>If it finds abbreviated name, followed by the characters that are valid for the full name, it continues reading until it consumes all the characters for the full name or finds a character that isn't expected, in which case parsing fails even if the first few characters were a valid abbreviation.</source>
          <target state="translated">Если он находит сокращенное имя,за которым следуют символы,действительные для полного имени,он продолжает чтение до тех пор,пока не заберет все символы для полного имени или не найдет символ,который не ожидается,и в этом случае парсинг будет неудачным,даже если первые несколько символов были действительными аббревиатурами.</target>
        </trans-unit>
        <trans-unit id="c6aab4ab699238bc505d419c37703aa0ef2626a9" translate="yes" xml:space="preserve">
          <source>If it is a non-const xvalue, the object to which it refers is in a valid but unspecified state;</source>
          <target state="translated">Если это неконстантное x-значение,то объект,на который оно ссылается,находится в действительном,но неуказанном состоянии;</target>
        </trans-unit>
        <trans-unit id="a83e8b41c48694346f5c6e5d8a58bf3d4cd145d7" translate="yes" xml:space="preserve">
          <source>If l&amp;ge;128, the behavior is implementation-defined</source>
          <target state="translated">Если l&amp;ge;128, поведение определяется реализацией</target>
        </trans-unit>
        <trans-unit id="095b63a0e4834384f4f2cd6f96c502aa1765c012" translate="yes" xml:space="preserve">
          <source>If lineno is 0 or greater than 32767(until C++11)2147483647(since C++11), the behavior is undefined.</source>
          <target state="translated">Если lineno равен 0 или больше 32767(до C++11)2147483647(начиная с C++11),то поведение не определено.</target>
        </trans-unit>
        <trans-unit id="0ce137b58879463fa5db786928dc6b5433066a3e" translate="yes" xml:space="preserve">
          <source>If lookup finds more than one deallocation function, the function to be called is selected as follows (see &lt;a href=&quot;../memory/new/operator_delete&quot;&gt;deallocation function&lt;/a&gt; for a more detailed description of these functions and their effects):</source>
          <target state="translated">Если при поиске найдено более одной функции освобождения, вызываемая функция выбирается следующим образом (см. &lt;a href=&quot;../memory/new/operator_delete&quot;&gt;Функцию освобождения&lt;/a&gt; для более подробного описания этих функций и их эффектов):</target>
        </trans-unit>
        <trans-unit id="16f6bcbb6edddebfaed64c4a8ff01d6fc6f7b460" translate="yes" xml:space="preserve">
          <source>If members of a union are classes with user-defined constructors and destructors, to switch the active member, explicit destructor and placement new are generally needed:</source>
          <target state="translated">Если членами союза являются классы с определяемыми пользователем конструкторами и деструкторами,то для переключения активного члена,как правило,требуется явный деструктор и размещение нового:</target>
        </trans-unit>
        <trans-unit id="9aaa368e593ef656dfef2f87849d89081dbdfcf4" translate="yes" xml:space="preserve">
          <source>If more than one match is possible, then any match is an acceptable result</source>
          <target state="translated">Если возможно проведение более одного матча,то любой матч-приемлемый результат.</target>
        </trans-unit>
        <trans-unit id="02b8b892d773253c24c7deaa868506ebc598bb0d" translate="yes" xml:space="preserve">
          <source>If more than one preferred functions are found, only preferred functions are considered in the next step.</source>
          <target state="translated">Если найдено несколько предпочтительных функций,на следующем этапе рассматриваются только предпочтительные функции.</target>
        </trans-unit>
        <trans-unit id="cbd23d50b99e7b96b25fd8ee6be5397b6972349c" translate="yes" xml:space="preserve">
          <source>If more than the implementation-defined maximum number of shared owners already locked the mutex in shared mode, &lt;code&gt;lock_shared&lt;/code&gt; blocks execution until the number of shared owners is reduced. The maximum number of owners is guaranteed to be at least 10000.</source>
          <target state="translated">Если больше, чем определенное реализацией максимальное количество общих владельцев, уже заблокировало мьютекс в режиме совместного использования, &lt;code&gt;lock_shared&lt;/code&gt; блокирует выполнение до тех пор, пока количество общих владельцев не уменьшится. Максимальное количество владельцев гарантировано не менее 10000.</target>
        </trans-unit>
        <trans-unit id="f645135ade1dcc39a052821b217283911b76e60d" translate="yes" xml:space="preserve">
          <source>If multiple constructors are viable but none is better than the others, the implicit conversion sequence is the ambiguous conversion sequence.</source>
          <target state="translated">Если несколько конструкторов жизнеспособны,но ни один из них не лучше других,то неявная последовательность преобразования является неоднозначной последовательностью преобразования.</target>
        </trans-unit>
        <trans-unit id="bbd656e7e48d690ef7ac59721f80eafd7184c36a" translate="yes" xml:space="preserve">
          <source>If multiple threads attempt to initialize the same static local variable concurrently, the initialization occurs exactly once (similar behavior can be obtained for arbitrary functions with &lt;code&gt;&lt;a href=&quot;../thread/call_once&quot;&gt;std::call_once&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">Если несколько потоков пытаются инициализировать одну и ту же статическую локальную переменную одновременно, инициализация происходит ровно один раз (аналогичное поведение может быть получено для произвольных функций с помощью &lt;code&gt;&lt;a href=&quot;../thread/call_once&quot;&gt;std::call_once&lt;/a&gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="71891f311caa8357864e30afc2d3a7d5ac7da117" translate="yes" xml:space="preserve">
          <source>If multiple threads of execution access the same &lt;code&gt;&lt;a href=&quot;../shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&lt;/code&gt; object without synchronization and any of those accesses uses a non-const member function of &lt;code&gt;shared_ptr&lt;/code&gt; then a data race will occur unless all such access is performed through an instance of &lt;code&gt;std::atomic&amp;lt;std::shared_ptr&amp;gt;&amp;gt;&lt;/code&gt; (or, deprecated as of C++20, through the &lt;a href=&quot;atomic&quot;&gt;standalone functions&lt;/a&gt; for atomic access to std::shared_ptr).</source>
          <target state="translated">Если несколько потоков выполнения обращаются к одному и тому же объекту &lt;code&gt;&lt;a href=&quot;../shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&lt;/code&gt; без синхронизации и любой из этих обращений использует неконстантную функцию-член &lt;code&gt;shared_ptr&lt;/code&gt; , тогда произойдет гонка данных, если только такой доступ не будет выполнен через экземпляр &lt;code&gt;std::atomic&amp;lt;std::shared_ptr&amp;gt;&amp;gt;&lt;/code&gt; (или устарел, начиная с C ++ 20, через &lt;a href=&quot;atomic&quot;&gt;автономные функции&lt;/a&gt; для атомарного доступа к std :: shared_ptr).</target>
        </trans-unit>
        <trans-unit id="882b5e537cc3e18e7bf36e2a307bc0559f800747" translate="yes" xml:space="preserve">
          <source>If multiple threads of execution access the same &lt;code&gt;&lt;a href=&quot;../shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&lt;/code&gt; object without synchronization and any of those accesses uses a non-const member function of &lt;code&gt;shared_ptr&lt;/code&gt; then a data race will occur unless all such access is performed through these functions, which are overloads of the corresponding atomic access functions (&lt;code&gt;&lt;a href=&quot;../../atomic/atomic_load&quot;&gt;std::atomic_load&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../../atomic/atomic_store&quot;&gt;std::atomic_store&lt;/a&gt;&lt;/code&gt;, etc.).</source>
          <target state="translated">Если несколько потоков выполнения обращаются к одному и тому же объекту &lt;code&gt;&lt;a href=&quot;../shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&lt;/code&gt; без синхронизации и любой из этих обращений использует неконстантную функцию-член &lt;code&gt;shared_ptr&lt;/code&gt; , тогда произойдет гонка данных, если только такой доступ не будет выполнен с помощью этих функций, которые являются перегрузками соответствующие функции атомарного доступа ( &lt;code&gt;&lt;a href=&quot;../../atomic/atomic_load&quot;&gt;std::atomic_load&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../../atomic/atomic_store&quot;&gt;std::atomic_store&lt;/a&gt;&lt;/code&gt; и т. д.).</target>
        </trans-unit>
        <trans-unit id="bd64a01ec402003b9db85651e928cb1f1bbc53d5" translate="yes" xml:space="preserve">
          <source>If multiple threads of execution access the same &lt;code&gt;&lt;a href=&quot;../weak_ptr&quot;&gt;std::weak_ptr&lt;/a&gt;&lt;/code&gt; object without synchronization and any of those accesses uses a non-const member function of &lt;code&gt;weak_ptr&lt;/code&gt; then a data race will occur unless all such access is performed through an instance of &lt;code&gt;std::atomic&amp;lt;std::weak_ptr&amp;gt;&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">Если несколько потоков выполнения обращаются к одному и тому же объекту &lt;code&gt;&lt;a href=&quot;../weak_ptr&quot;&gt;std::weak_ptr&lt;/a&gt;&lt;/code&gt; без синхронизации, и любой из этих доступов использует неконстантную функцию-член &lt;code&gt;weak_ptr&lt;/code&gt; , тогда произойдет гонка данных, если только такой доступ не будет выполнен с помощью экземпляра &lt;code&gt;std::atomic&amp;lt;std::weak_ptr&amp;gt;&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="40f81f722965ce77fe317399aac97f912e696cd4" translate="yes" xml:space="preserve">
          <source>If n&amp;gt;=128, the behavior is implementation-defined</source>
          <target state="translated">Если n&amp;gt; = 128, поведение определяется реализацией</target>
        </trans-unit>
        <trans-unit id="42e3ee0efc70684fde11275bda977b0d1b55fd68" translate="yes" xml:space="preserve">
          <source>If necessary, obtains the status of &lt;code&gt;to&lt;/code&gt;, by no more than a single call to</source>
          <target state="translated">В случае необходимости, получает статус &lt;code&gt;to&lt;/code&gt; , не более чем на один вызов</target>
        </trans-unit>
        <trans-unit id="b0434e8f18603c02eef4062d15cac7f0e1d6bd92" translate="yes" xml:space="preserve">
          <source>If neither &lt;code&gt;*this&lt;/code&gt; nor &lt;code&gt;other&lt;/code&gt; contain a value, the function has no effect.</source>
          <target state="translated">Если ни &lt;code&gt;*this&lt;/code&gt; ни &lt;code&gt;other&lt;/code&gt; не содержит значения, то функция не имеет никакого эффекта.</target>
        </trans-unit>
        <trans-unit id="1e8a7e77e5b17bbba28f9f5bde7a2ff9ba1ac92c" translate="yes" xml:space="preserve">
          <source>If neither &lt;code&gt;&lt;a href=&quot;launch&quot;&gt;std::launch::async&lt;/a&gt;&lt;/code&gt; nor &lt;code&gt;&lt;a href=&quot;launch&quot;&gt;std::launch::deferred&lt;/a&gt;&lt;/code&gt;, nor any implementation-defined policy flag is set in &lt;code&gt;policy&lt;/code&gt;, the behavior is undefined.</source>
          <target state="translated">Если в &lt;code&gt;policy&lt;/code&gt; не заданы ни &lt;code&gt;&lt;a href=&quot;launch&quot;&gt;std::launch::async&lt;/a&gt;&lt;/code&gt; ни &lt;code&gt;&lt;a href=&quot;launch&quot;&gt;std::launch::deferred&lt;/a&gt;&lt;/code&gt; , ни какой-либо определяемый реализацией флаг политики , поведение не определено.</target>
        </trans-unit>
        <trans-unit id="403cdbe454265b3fef8904df0622a89b983cd05c" translate="yes" xml:space="preserve">
          <source>If no captures are specified, the closure type has a defaulted copy assignment operator and a defaulted move assignment operator. Otherwise, it has a deleted copy assignment operator (this includes the case when there is a capture-default, even if it does not actually capture anything).</source>
          <target state="translated">Если не указано ни одного захвата,то тип закрытия имеет оператор назначения копии по умолчанию и оператор назначения движения по умолчанию.В противном случае,у него есть удаленный оператор присваивания копии (это включает в себя случай,когда есть перехват по умолчанию,даже если на самом деле он ничего не перехватывает).</target>
        </trans-unit>
        <trans-unit id="1b35fa3984aaeb3db9a1c2d09a20b6a3e68e64ef" translate="yes" xml:space="preserve">
          <source>If no captures are specified, the closure type has a defaulted default constructor. Otherwise, it has no default constructor (this includes the case when there is a capture-default, even if it does not actually capture anything).</source>
          <target state="translated">Если не указано ни одного захвата,то тип закрытия имеет конструктор по умолчанию по умолчанию по умолчанию.В противном случае,он не имеет конструктора по умолчанию (это включает в себя случай,когда есть захват по умолчанию,даже если на самом деле он ничего не захватывает).</target>
        </trans-unit>
        <trans-unit id="cd433247692a3d2cd8a72c9ba4974a4b61306058" translate="yes" xml:space="preserve">
          <source>If no characters are extracted then &lt;code&gt;std::ios::failbit&lt;/code&gt; is set on &lt;code&gt;is&lt;/code&gt;, which may throw &lt;code&gt;&lt;a href=&quot;../../io/ios_base/failure&quot;&gt;std::ios_base::failure&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Если никакие символы не будут извлечены , то &lt;code&gt;std::ios::failbit&lt;/code&gt; устанавливается на &lt;code&gt;is&lt;/code&gt; , что может бросить &lt;code&gt;&lt;a href=&quot;../../io/ios_base/failure&quot;&gt;std::ios_base::failure&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="69c02d0301239909ac59a990ef2ea5d140fa29fd" translate="yes" xml:space="preserve">
          <source>If no characters are extracted, &lt;code&gt;is.setstate(ios_base::failbit)&lt;/code&gt; is called.</source>
          <target state="translated">Если символы не извлекаются, &lt;code&gt;is.setstate(ios_base::failbit)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9ba27093f4416e619f89024b343671475c2b0970" translate="yes" xml:space="preserve">
          <source>If no characters were extracted, calls &lt;code&gt;setstate(failbit)&lt;/code&gt;.</source>
          <target state="translated">Если никакие символы не были извлечены, вызывает &lt;code&gt;setstate(failbit)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="536ea244a0d993a0064e14e4551396fff4cc9231" translate="yes" xml:space="preserve">
          <source>If no characters were extracted, calls &lt;code&gt;setstate(failbit)&lt;/code&gt;. In any case, if &lt;code&gt;count&amp;gt;0&lt;/code&gt;, a null character (&lt;code&gt;CharT()&lt;/code&gt; is stored in the next successive location of the array.</source>
          <target state="translated">Если никакие символы не были извлечены, вызывает &lt;code&gt;setstate(failbit)&lt;/code&gt; . В любом случае, если &lt;code&gt;count&amp;gt;0&lt;/code&gt; , нулевой символ ( &lt;code&gt;CharT()&lt;/code&gt; сохраняется в следующей последовательной ячейке массива.</target>
        </trans-unit>
        <trans-unit id="878b0f05459600af7530cf7141a045ee2d7f3e8f" translate="yes" xml:space="preserve">
          <source>If no characters were inserted, executes &lt;code&gt;setstate(failbit)&lt;/code&gt;. If an exception was thrown while extracting, sets &lt;code&gt;failbit&lt;/code&gt; and, if &lt;code&gt;failbit&lt;/code&gt; is set in &lt;code&gt;exceptions()&lt;/code&gt;, rethrows the exception.</source>
          <target state="translated">Если никакие символы не были вставлены, выполняется &lt;code&gt;setstate(failbit)&lt;/code&gt; . Если во время извлечения было &lt;code&gt;failbit&lt;/code&gt; исключение, задается бит перехода, а если &lt;code&gt;failbit&lt;/code&gt; установлен в &lt;code&gt;exceptions()&lt;/code&gt; , сбрасывает исключение.</target>
        </trans-unit>
        <trans-unit id="edd868dcc474e443c25a49132bd6419f1abf7cca" translate="yes" xml:space="preserve">
          <source>If no conversion can be performed, &lt;code&gt;​0​&lt;/code&gt; is returned.</source>
          <target state="translated">Если преобразование не может быть выполнено, &lt;code&gt;​0​&lt;/code&gt; возвращается.</target>
        </trans-unit>
        <trans-unit id="530f889d2ad8b60ee918f8e2702b7883b29fb175" translate="yes" xml:space="preserve">
          <source>If no errors occur earg</source>
          <target state="translated">Если ошибки не случаются,уши</target>
        </trans-unit>
        <trans-unit id="a4b69264dcfdc184105c0c5fcdc54a8a79767399" translate="yes" xml:space="preserve">
          <source>If no errors occur ln(1+arg) is returned.</source>
          <target state="translated">При отсутствии ошибок возвращается ln(1+arg).</target>
        </trans-unit>
        <trans-unit id="f3037fe820d838daa891fb3539a8329f215061a7" translate="yes" xml:space="preserve">
          <source>If no errors occur,</source>
          <target state="translated">Если ошибок не происходит,</target>
        </trans-unit>
        <trans-unit id="47e97b549aae51b3c35168920f72ade75b7949f9" translate="yes" xml:space="preserve">
          <source>If no errors occur, &lt;code&gt;base&lt;/code&gt; raised to the power of &lt;code&gt;exp&lt;/code&gt; (or &lt;code&gt;iexp&lt;/code&gt;) (baseexp</source>
          <target state="translated">Если ошибок не возникает, &lt;code&gt;base&lt;/code&gt; возводится в степень &lt;code&gt;exp&lt;/code&gt; (или &lt;code&gt;iexp&lt;/code&gt; ) (baseexp</target>
        </trans-unit>
        <trans-unit id="ef48764b6bc2b922ac28634b1b57e0a32884367d" translate="yes" xml:space="preserve">
          <source>If no errors occur, &lt;code&gt;x&lt;/code&gt; multiplied by 2 to the power of &lt;code&gt;exp&lt;/code&gt; (x&amp;times;2exp</source>
          <target state="translated">Если ошибок нет, &lt;code&gt;x&lt;/code&gt; умножается на 2 до степени &lt;code&gt;exp&lt;/code&gt; (x &amp;times; 2exp</target>
        </trans-unit>
        <trans-unit id="be1997f1a364feb4c59b1137ec5be5c5163c893c" translate="yes" xml:space="preserve">
          <source>If no errors occur, &lt;code&gt;x&lt;/code&gt; multiplied by &lt;code&gt;&lt;a href=&quot;../../types/climits&quot;&gt;FLT_RADIX&lt;/a&gt;&lt;/code&gt; to the power of &lt;code&gt;arg&lt;/code&gt; (x&amp;times;FLT_RADIXexp</source>
          <target state="translated">Если ошибок не возникает, &lt;code&gt;x&lt;/code&gt; умножается на &lt;code&gt;&lt;a href=&quot;../../types/climits&quot;&gt;FLT_RADIX&lt;/a&gt;&lt;/code&gt; до степени &lt;code&gt;arg&lt;/code&gt; (x &amp;times; FLT_RADIXexp</target>
        </trans-unit>
        <trans-unit id="43e9fba55e5f456a3880c2a5f09b14d52ee81371" translate="yes" xml:space="preserve">
          <source>If no errors occur, complex arc cosine of &lt;code&gt;z&lt;/code&gt; is returned, in the range [0 ; &amp;infin;) along the real axis and in the range [&amp;minus;</source>
          <target state="translated">Если ошибок не возникает, возвращается сложный арккосинус &lt;code&gt;z&lt;/code&gt; в диапазоне [0; &amp;infin;) вдоль вещественной оси и в диапазоне [-</target>
        </trans-unit>
        <trans-unit id="3ba083c7eab3d055b75951c25f225f73acff4188" translate="yes" xml:space="preserve">
          <source>If no errors occur, complex arc sine of &lt;code&gt;z&lt;/code&gt; is returned, in the range of a strip unbounded along the imaginary axis and in the interval [&amp;minus;&amp;pi;/2; +&amp;pi;/2] along the real axis.</source>
          <target state="translated">Если ошибок не возникает, возвращается сложный синус &lt;code&gt;z&lt;/code&gt; в диапазоне полосы, неограниченной вдоль мнимой оси, и в интервале [&amp;minus;&amp;pi; / 2; + &amp;pi; / 2] вдоль вещественной оси.</target>
        </trans-unit>
        <trans-unit id="e58f6c458633d11255df6ec72e17d6e0e307082c" translate="yes" xml:space="preserve">
          <source>If no errors occur, complex arc tangent of &lt;code&gt;z&lt;/code&gt; is returned, in the range of a strip unbounded along the imaginary axis and in the interval [&amp;minus;&amp;pi;/2; +&amp;pi;/2] along the real axis.</source>
          <target state="translated">Если ошибок не возникает, возвращается комплексный арктангенс &lt;code&gt;z&lt;/code&gt; в области полосы, неограниченной вдоль мнимой оси, и в интервале [&amp;minus;&amp;pi; / 2; + &amp;pi; / 2] вдоль вещественной оси.</target>
        </trans-unit>
        <trans-unit id="50a8713f4c4c617bedaa7a390ea195b3329dac1c" translate="yes" xml:space="preserve">
          <source>If no errors occur, complex hyperbolic cosine of &lt;code&gt;z&lt;/code&gt; is returned.</source>
          <target state="translated">Если ошибок не возникает, возвращается сложный гиперболический косинус &lt;code&gt;z&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a8e6619163d1ca9fedc0a2bfd79d4c047fbeb277" translate="yes" xml:space="preserve">
          <source>If no errors occur, complex hyperbolic sine of &lt;code&gt;z&lt;/code&gt; is returned.</source>
          <target state="translated">Если ошибок не возникает, возвращается сложный гиперболический синус &lt;code&gt;z&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0204a9004641a330efb33cc1c10a2eb5fe8c95c2" translate="yes" xml:space="preserve">
          <source>If no errors occur, complex hyperbolic tangent of &lt;code&gt;z&lt;/code&gt; is returned.</source>
          <target state="translated">Если ошибок не возникает, возвращается комплексный гиперболический тангенс &lt;code&gt;z&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b37be6aaeb963e74d379aaa690fc0222ec1a8842" translate="yes" xml:space="preserve">
          <source>If no errors occur, returns the absolute value (also known as norm, modulus, or magnitude) of &lt;code&gt;z&lt;/code&gt;.</source>
          <target state="translated">Если ошибок не возникает, возвращает абсолютное значение (также известное как норма, модуль или величина) &lt;code&gt;z&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f7f248bc9527b22f78b886ecb63cf4c8a2bd9c60" translate="yes" xml:space="preserve">
          <source>If no errors occur, returns the fractional part of &lt;code&gt;x&lt;/code&gt; with the same sign as &lt;code&gt;x&lt;/code&gt;. The integral part is put into the value pointed to by &lt;code&gt;iptr&lt;/code&gt;.</source>
          <target state="translated">Если ошибок не возникает, возвращает дробную часть &lt;code&gt;x&lt;/code&gt; с тем же знаком, что и &lt;code&gt;x&lt;/code&gt; . Неотъемлемой частью является значение, на которое указывает &lt;code&gt;iptr&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="dcbbfc79f2b5b688deb79fcd4d7c358c461e6459" translate="yes" xml:space="preserve">
          <source>If no errors occur, returns the phase angle of &lt;code&gt;z&lt;/code&gt; in the interval [&amp;minus;&amp;pi;; &amp;pi;].</source>
          <target state="translated">Если ошибок не возникает, возвращает фазовый угол &lt;code&gt;z&lt;/code&gt; в интервале [&amp;minus;&amp;pi;; &amp;pi;].</target>
        </trans-unit>
        <trans-unit id="af3231d18a9dbafc82193c163f7f7ec4e37b28f7" translate="yes" xml:space="preserve">
          <source>If no errors occur, returns the square root of &lt;code&gt;z&lt;/code&gt;, in the range of the right half-plane, including the imaginary axis ([0; +&amp;infin;) along the real axis and (&amp;minus;&amp;infin;; +&amp;infin;) along the imaginary axis.).</source>
          <target state="translated">Если ошибок не возникает, возвращает квадратный корень из &lt;code&gt;z&lt;/code&gt; в диапазоне правой полуплоскости, включая мнимую ось ([0; + &amp;infin;) вдоль действительной оси и (&amp;minus;&amp;infin;; + &amp;infin;) вдоль мнимой оси. ).</target>
        </trans-unit>
        <trans-unit id="c2564a63d94a5759bfc1f7f8a35fbdfcf9b9d071" translate="yes" xml:space="preserve">
          <source>If no errors occur, returns the value of the spherical Bessel function of the first kind of &lt;code&gt;n&lt;/code&gt; and &lt;code&gt;x&lt;/code&gt;, that is j</source>
          <target state="translated">Если ошибок не возникает, возвращает значение сферической функции Бесселя первого рода &lt;code&gt;n&lt;/code&gt; и &lt;code&gt;x&lt;/code&gt; , то есть j</target>
        </trans-unit>
        <trans-unit id="4739e7b0751e1897ecdce821941cd1dfb83af3ac" translate="yes" xml:space="preserve">
          <source>If no errors occur, returns the value of the spherical Bessel function of the second kind (spherical Neumann function) of &lt;code&gt;n&lt;/code&gt; and &lt;code&gt;x&lt;/code&gt;, that is n</source>
          <target state="translated">Если ошибок не возникает, возвращает значение сферической функции Бесселя второго рода (сферическая функция Неймана) для &lt;code&gt;n&lt;/code&gt; и &lt;code&gt;x&lt;/code&gt; , то есть n</target>
        </trans-unit>
        <trans-unit id="63cd03ce841bb8c36f4907b2d91c123b017f259e" translate="yes" xml:space="preserve">
          <source>If no errors occur, returns the value of the spherical associated Legendre function (that is, spherical harmonic with ϕ = 0) of &lt;code&gt;l&lt;/code&gt;, &lt;code&gt;m&lt;/code&gt;, and &lt;code&gt;&amp;theta;&lt;/code&gt;, where the spherical harmonic function is defined as Ym</source>
          <target state="translated">Если ошибок не возникает, возвращает значение сферической связанной функции Лежандра (то есть сферической гармоники с ϕ = 0) для &lt;code&gt;l&lt;/code&gt; , &lt;code&gt;m&lt;/code&gt; и &lt;code&gt;&amp;theta;&lt;/code&gt; , где сферическая гармоническая функция определяется как Ym</target>
        </trans-unit>
        <trans-unit id="ee22b5df48ca25af069416a0b6aead9e8cfe0766" translate="yes" xml:space="preserve">
          <source>If no errors occur, square root of &lt;code&gt;arg&lt;/code&gt; (&amp;radic;arg), is returned.</source>
          <target state="translated">Если ошибок не возникает, возвращается квадратный корень из &lt;code&gt;arg&lt;/code&gt; (&amp;radic;arg).</target>
        </trans-unit>
        <trans-unit id="d6cd26c82284031b354355d1565d22e205fe8e3d" translate="yes" xml:space="preserve">
          <source>If no errors occur, the arc cosine of &lt;code&gt;arg&lt;/code&gt; (arccos(arg)) in the range [0 , &amp;pi;], is returned.</source>
          <target state="translated">Если ошибок не возникает, возвращается арккосинус &lt;code&gt;arg&lt;/code&gt; (arccos (arg)) в диапазоне [0, &amp;pi;].</target>
        </trans-unit>
        <trans-unit id="039d32b1f2e5bfee4ca5736c63a4206e5274388e" translate="yes" xml:space="preserve">
          <source>If no errors occur, the arc sine of &lt;code&gt;arg&lt;/code&gt; (arcsin(arg)) in the range [-</source>
          <target state="translated">Если ошибок не возникает, дуга синуса &lt;code&gt;arg&lt;/code&gt; (arcsin (arg)) в диапазоне [-</target>
        </trans-unit>
        <trans-unit id="b32613c8b978beac62c696ce2bd93a54bd237edb" translate="yes" xml:space="preserve">
          <source>If no errors occur, the arc tangent of &lt;code&gt;arg&lt;/code&gt; (arctan(arg)) in the range [-</source>
          <target state="translated">Если ошибок не возникает, арктангенс &lt;code&gt;arg&lt;/code&gt; (arctan (arg)) находится в диапазоне [-</target>
        </trans-unit>
        <trans-unit id="c938da3a42fe0590b15c6f8539ff408d3a3b97dd" translate="yes" xml:space="preserve">
          <source>If no errors occur, the arc tangent of &lt;code&gt;y/x&lt;/code&gt; (arctan(</source>
          <target state="translated">Если ошибок не возникает, арктангенс &lt;code&gt;y/x&lt;/code&gt; (arctan (</target>
        </trans-unit>
        <trans-unit id="9d5986c54dce11e1cd1599414757016de12c5f01" translate="yes" xml:space="preserve">
          <source>If no errors occur, the base-</source>
          <target state="translated">Если ошибок не возникает,то база -</target>
        </trans-unit>
        <trans-unit id="be331ea28ae7c2d7b9acf97860d316fce4b87723" translate="yes" xml:space="preserve">
          <source>If no errors occur, the common (base-</source>
          <target state="translated">Если ошибок не возникает,то общая (базовая -</target>
        </trans-unit>
        <trans-unit id="135f7aa5f1c2d4f79725bd744a0dd782f41f3bfa" translate="yes" xml:space="preserve">
          <source>If no errors occur, the complex arc hyperbolic cosine of &lt;code&gt;z&lt;/code&gt; is returned, in the range of a half-strip of nonnegative values along the real axis and in the interval [&amp;minus;i&amp;pi;; +i&amp;pi;] along the imaginary axis.</source>
          <target state="translated">Если ошибок не возникает, возвращается гиперболический косинус комплексной дуги &lt;code&gt;z&lt;/code&gt; в диапазоне полуполосы неотрицательных значений вдоль вещественной оси и в интервале [&amp;minus;i&amp;pi;; + i&amp;pi;] вдоль мнимой оси.</target>
        </trans-unit>
        <trans-unit id="05909577ff3329b64c179e57f5f18c51d7427016" translate="yes" xml:space="preserve">
          <source>If no errors occur, the complex arc hyperbolic sine of &lt;code&gt;z&lt;/code&gt; is returned, in the range of a strip mathematically unbounded along the real axis and in the interval [&amp;minus;i&amp;pi;/2; +i&amp;pi;/2] along the imaginary axis.</source>
          <target state="translated">Если ошибок не возникает, возвращается комплексный дуговой гиперболический синус &lt;code&gt;z&lt;/code&gt; в области полосы, математически неограниченной вдоль вещественной оси и в интервале [&amp;minus;i&amp;pi; / 2; + i&amp;pi; / 2] вдоль мнимой оси.</target>
        </trans-unit>
        <trans-unit id="5e1faa126d0291e9222a13afce04bd8eb0c0cbd7" translate="yes" xml:space="preserve">
          <source>If no errors occur, the complex arc hyperbolic tangent of &lt;code&gt;z&lt;/code&gt; is returned, in the range of a half-strip mathematically unbounded along the real axis and in the interval [&amp;minus;i&amp;pi;/2; +i&amp;pi;/2] along the imaginary axis.</source>
          <target state="translated">Если ошибок не возникает, возвращается комплексная дуговая гиперболическая касательная &lt;code&gt;z&lt;/code&gt; , в диапазоне полуполосы, математически неограниченной вдоль вещественной оси и в интервале [&amp;minus;i&amp;pi; / 2; + i&amp;pi; / 2] вдоль мнимой оси.</target>
        </trans-unit>
        <trans-unit id="b951e541cea44c28eafdd9c54b7c32c1392530f6" translate="yes" xml:space="preserve">
          <source>If no errors occur, the complex cosine of &lt;code&gt;z&lt;/code&gt; is returned.</source>
          <target state="translated">Если ошибок не возникает, возвращается сложный косинус &lt;code&gt;z&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e0170daad51b40b50ab797fcf5f22cc95ede3feb" translate="yes" xml:space="preserve">
          <source>If no errors occur, the complex natural logarithm of &lt;code&gt;z&lt;/code&gt; is returned, in the range of a strip in the interval [&amp;minus;i&amp;pi;, +i&amp;pi;] along the imaginary axis and mathematically unbounded along the real axis.</source>
          <target state="translated">Если ошибок не возникает, возвращается комплексный натуральный логарифм &lt;code&gt;z&lt;/code&gt; в области полосы в интервале [&amp;minus;i&amp;pi;, + i&amp;pi;] вдоль мнимой оси и математически неограниченной вдоль вещественной оси.</target>
        </trans-unit>
        <trans-unit id="e80a11cce80b4f8332e379e29bcd184e31b6ff47" translate="yes" xml:space="preserve">
          <source>If no errors occur, the complex power xy</source>
          <target state="translated">Если ошибки не возникнут,то сложная мощность xy</target>
        </trans-unit>
        <trans-unit id="c05f2e2cc1ed459bdf96a06ef8dbc33e20915e79" translate="yes" xml:space="preserve">
          <source>If no errors occur, the complex sine of &lt;code&gt;z&lt;/code&gt; is returned.</source>
          <target state="translated">Если ошибок не возникает, возвращается сложный синус &lt;code&gt;z&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8f171b9589d9359bfb44bdfa881b4ee93ea77d0c" translate="yes" xml:space="preserve">
          <source>If no errors occur, the complex tangent of &lt;code&gt;z&lt;/code&gt; is returned.</source>
          <target state="translated">Если ошибок не возникает, возвращается комплексный тангенс &lt;code&gt;z&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="35bd7abdcb7f0220128fd880299baf801952dc19" translate="yes" xml:space="preserve">
          <source>If no errors occur, the cosine of &lt;code&gt;arg&lt;/code&gt; (cos(arg)) in the range [-1 ; +1], is returned.</source>
          <target state="translated">Если ошибок не возникает, косинус &lt;code&gt;arg&lt;/code&gt; (cos (arg)) в диапазоне [-1; +1], возвращается.</target>
        </trans-unit>
        <trans-unit id="ff16f514ad4d462d31d6524ed4ea84f4f6bcb390" translate="yes" xml:space="preserve">
          <source>If no errors occur, the cubic root of &lt;code&gt;arg&lt;/code&gt; (3&amp;radic;arg), is returned.</source>
          <target state="translated">Если ошибок не возникает, возвращается кубический корень &lt;code&gt;arg&lt;/code&gt; (3&amp;radic;arg).</target>
        </trans-unit>
        <trans-unit id="1e33cd84b874596d38519b6f05a2e60c9accef6b" translate="yes" xml:space="preserve">
          <source>If no errors occur, the floating point value with the magnitude of &lt;code&gt;x&lt;/code&gt; and the sign of &lt;code&gt;y&lt;/code&gt; is returned.</source>
          <target state="translated">Если ошибок не возникает, возвращается значение с плавающей запятой с величиной &lt;code&gt;x&lt;/code&gt; и знаком &lt;code&gt;y&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="29635dc5075be505f22d8b338419ce3b116238e5" translate="yes" xml:space="preserve">
          <source>If no errors occur, the hyperbolic cosine of &lt;code&gt;arg&lt;/code&gt; (cosh(arg), or</source>
          <target state="translated">Если ошибок не возникает, то гиперболический косинус &lt;code&gt;arg&lt;/code&gt; (cosh (arg) или</target>
        </trans-unit>
        <trans-unit id="084419061d5d22eb194084f72eb3bc99faee2d80" translate="yes" xml:space="preserve">
          <source>If no errors occur, the hyperbolic sine of &lt;code&gt;arg&lt;/code&gt; (sinh(arg), or</source>
          <target state="translated">Если ошибок не возникает, то гиперболический синус &lt;code&gt;arg&lt;/code&gt; (sinh (arg) или</target>
        </trans-unit>
        <trans-unit id="fde1a5cab1da9385208df6463481d983b8d198b8" translate="yes" xml:space="preserve">
          <source>If no errors occur, the hyperbolic tangent of &lt;code&gt;arg&lt;/code&gt; (tanh(arg), or</source>
          <target state="translated">Если ошибок не возникает, используется гиперболический тангенс &lt;code&gt;arg&lt;/code&gt; (tanh (arg) или</target>
        </trans-unit>
        <trans-unit id="3870fee396c73bbc1aab8cee4f9a85c1179be025" translate="yes" xml:space="preserve">
          <source>If no errors occur, the inverse hyperbolic cosine of &lt;code&gt;arg&lt;/code&gt; (cosh-1</source>
          <target state="translated">Если ошибок не возникает, обратный гиперболический косинус &lt;code&gt;arg&lt;/code&gt; (cosh-1</target>
        </trans-unit>
        <trans-unit id="c5db26fbae61f4e34cf5287ffaa5a9d47e53259d" translate="yes" xml:space="preserve">
          <source>If no errors occur, the inverse hyperbolic sine of &lt;code&gt;arg&lt;/code&gt; (sinh-1</source>
          <target state="translated">Если ошибок не возникает, обратный гиперболический синус &lt;code&gt;arg&lt;/code&gt; (sinh-1</target>
        </trans-unit>
        <trans-unit id="f93099d7063e1d7a83038ac66c3c5233ba5f6ece" translate="yes" xml:space="preserve">
          <source>If no errors occur, the inverse hyperbolic tangent of &lt;code&gt;arg&lt;/code&gt; (tanh-1</source>
          <target state="translated">Если ошибок не возникает, обратный гиперболический тангенс &lt;code&gt;arg&lt;/code&gt; (tanh-1</target>
        </trans-unit>
        <trans-unit id="d4744dace8417a9d2afa9a3795c780e70495855c" translate="yes" xml:space="preserve">
          <source>If no errors occur, the largest integer value not greater than &lt;code&gt;arg&lt;/code&gt;, that is &amp;lfloor;arg&amp;rfloor;, is returned.</source>
          <target state="translated">Если ошибок не возникает, возвращается наибольшее целочисленное значение, не превышающее &lt;code&gt;arg&lt;/code&gt; , то есть &amp;laquo;arg&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="3007ffc0d3f619ed4878713babc6bf385e75ed5b" translate="yes" xml:space="preserve">
          <source>If no errors occur, the natural (base-</source>
          <target state="translated">Если ошибки не возникают,то естественные (базовые -</target>
        </trans-unit>
        <trans-unit id="c09a1dd12c5becd1a78d62ef2eba3711b8030fb7" translate="yes" xml:space="preserve">
          <source>If no errors occur, the nearest integer value not greater in magnitude than &lt;code&gt;arg&lt;/code&gt; (in other words, &lt;code&gt;arg&lt;/code&gt; rounded towards zero) is returned.</source>
          <target state="translated">Если ошибок нет, возвращается ближайшее целочисленное значение, не большее по величине, чем &lt;code&gt;arg&lt;/code&gt; (другими словами, &lt;code&gt;arg&lt;/code&gt; , округленное до нуля).</target>
        </trans-unit>
        <trans-unit id="f769b27b09219929833064428bef0734a24648aa" translate="yes" xml:space="preserve">
          <source>If no errors occur, the nearest integer value to &lt;code&gt;arg&lt;/code&gt;, according to the &lt;a href=&quot;../fenv/fe_round&quot;&gt;current rounding mode&lt;/a&gt;, is returned.</source>
          <target state="translated">Если ошибок не возникает, возвращается ближайшее целочисленное значение &lt;code&gt;arg&lt;/code&gt; в соответствии с &lt;a href=&quot;../fenv/fe_round&quot;&gt;текущим режимом округления&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a0256d4c5a80036d6bc9fdb716345ed55c66ea11" translate="yes" xml:space="preserve">
          <source>If no errors occur, the nearest integer value to &lt;code&gt;arg&lt;/code&gt;, rounding halfway cases away from zero, is returned.</source>
          <target state="translated">Если ошибок не возникает, возвращается ближайшее целочисленное значение к &lt;code&gt;arg&lt;/code&gt; , округляющее половину случаев до нуля.</target>
        </trans-unit>
        <trans-unit id="2dcc36013b109d5eaf27751a51321acffdd6a03d" translate="yes" xml:space="preserve">
          <source>If no errors occur, the next representable value of &lt;code&gt;from&lt;/code&gt; in the direction of &lt;code&gt;to&lt;/code&gt;. is returned. If &lt;code&gt;from&lt;/code&gt; equals &lt;code&gt;to&lt;/code&gt;, then &lt;code&gt;to&lt;/code&gt; is returned.</source>
          <target state="translated">Если ошибок не возникает, следующее представимое значение &lt;code&gt;from&lt;/code&gt; в направлении &lt;code&gt;to&lt;/code&gt; . возвращается Если &lt;code&gt;from&lt;/code&gt; равных &lt;code&gt;to&lt;/code&gt; , то &lt;code&gt;to&lt;/code&gt; возвращается.</target>
        </trans-unit>
        <trans-unit id="d0a7b391baa86594c7d0448266a28acb2668a4e8" translate="yes" xml:space="preserve">
          <source>If no errors occur, the sine of &lt;code&gt;arg&lt;/code&gt; (sin(arg)) in the range [-1 ; +1], is returned.</source>
          <target state="translated">Если ошибок не возникает, синус &lt;code&gt;arg&lt;/code&gt; (sin (arg)) в диапазоне [-1; +1], возвращается.</target>
        </trans-unit>
        <trans-unit id="3fa7223cf61583336068c9d91991b4f9bedf8c7c" translate="yes" xml:space="preserve">
          <source>If no errors occur, the smallest integer value not less than &lt;code&gt;arg&lt;/code&gt;, that is &amp;lceil;arg&amp;rceil;, is returned.</source>
          <target state="translated">Если ошибок не возникает, возвращается наименьшее целочисленное значение не менее &lt;code&gt;arg&lt;/code&gt; , то есть &amp;laquo;arg&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="941693082c1c679c39e6797e593c1a748bca9744" translate="yes" xml:space="preserve">
          <source>If no errors occur, the tangent of &lt;code&gt;arg&lt;/code&gt; (tan(arg)) is returned.</source>
          <target state="translated">Если ошибок не возникает, возвращается тангенс &lt;code&gt;arg&lt;/code&gt; (tan (arg)).</target>
        </trans-unit>
        <trans-unit id="8e15bc85bb52009c88f5c69e56b9a2471d950454" translate="yes" xml:space="preserve">
          <source>If no errors occur, the unbiased exponent of &lt;code&gt;arg&lt;/code&gt; is returned as a signed floating-point value.</source>
          <target state="translated">Если ошибок не возникает, несмещенный показатель &lt;code&gt;arg&lt;/code&gt; возвращается как подписанное значение с плавающей точкой.</target>
        </trans-unit>
        <trans-unit id="026d1df8b0b132c32fe387fe762cb8d1ea884358" translate="yes" xml:space="preserve">
          <source>If no errors occur, the unbiased exponent of &lt;code&gt;arg&lt;/code&gt; is returned as a signed int value.</source>
          <target state="translated">Если ошибок не возникает, несмещенный показатель &lt;code&gt;arg&lt;/code&gt; возвращается как значение типа int со знаком.</target>
        </trans-unit>
        <trans-unit id="52dc1f3518fb2bced2d18acc2522443fc278caf6" translate="yes" xml:space="preserve">
          <source>If no errors occur, the value of the gamma function of &lt;code&gt;arg&lt;/code&gt;, that is \(\mathsf{\Gamma}(arg) = \int_0^\infty t^{arg-1} e^{-t} \mathsf{d}t\)&amp;int;&amp;infin;</source>
          <target state="translated">Если ошибок не возникает, значение гамма-функции &lt;code&gt;arg&lt;/code&gt; , то есть \ (\ mathsf {\ Gamma} (arg) = \ int_0 ^ \ infty t ^ {arg-1} e ^ {- t} \ mathsf {d } т \) &amp;int;&amp;infin;</target>
        </trans-unit>
        <trans-unit id="17f4ff9a3637589c23bfc0b873e96c8630ea5296" translate="yes" xml:space="preserve">
          <source>If no errors occur, the value of the logarithm of the gamma function of &lt;code&gt;arg&lt;/code&gt;, that is log</source>
          <target state="translated">Если ошибок не возникает, значение логарифма гамма-функции &lt;code&gt;arg&lt;/code&gt; , то есть log</target>
        </trans-unit>
        <trans-unit id="753b72c485945c6afd5db2fbcdff840651420e76" translate="yes" xml:space="preserve">
          <source>If no errors occur, value of the Riemann zeta function of &lt;code&gt;arg&lt;/code&gt;, &amp;zeta;(arg), defined for the entire real axis:</source>
          <target state="translated">Если ошибок не возникает, значение дзета-функции Римана для &lt;code&gt;arg&lt;/code&gt; , &amp;zeta; (arg), определено для всей действительной оси:</target>
        </trans-unit>
        <trans-unit id="6801efcde3e466144a59b2e13c721de60eb9a8db" translate="yes" xml:space="preserve">
          <source>If no errors occur, value of the associated Laguerre polynomial of &lt;code&gt;x&lt;/code&gt;, that is \((-1)^m \: \frac{ \mathsf{d} ^ m}{ \mathsf{d}x ^ m} \, \mathsf{L}_{n+m}(x)\)(-1)m</source>
          <target state="translated">Если ошибок не возникает, значение связанного полинома Лагерра от &lt;code&gt;x&lt;/code&gt; , то есть \ ((- 1) ^ m \: \ frac {\ mathsf {d} ^ m} {\ mathsf {d} x ^ m} \, \ mathsf {L} _ {п + т} (х) \) (- 1) м</target>
        </trans-unit>
        <trans-unit id="b70f9e16b11c8009277ec11b877f36771c9cba33" translate="yes" xml:space="preserve">
          <source>If no errors occur, value of the associated Legendre polynomial \(\mathsf{P}_n^m\)Pm</source>
          <target state="translated">Если ошибок не возникнет,то значение связанного с ним полинома Legendre \(\mathsf{P}_n^m\)Pm</target>
        </trans-unit>
        <trans-unit id="238d4638a6406e5670a8756021c43a9a89528ae6" translate="yes" xml:space="preserve">
          <source>If no errors occur, value of the beta function of &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;, that is &amp;int;1</source>
          <target state="translated">Если ошибок не возникает, значение бета-функции &lt;code&gt;x&lt;/code&gt; и &lt;code&gt;y&lt;/code&gt; , то есть &amp;int;1</target>
        </trans-unit>
        <trans-unit id="7f29a8300bf4d8be194d411485092bca1cff89a5" translate="yes" xml:space="preserve">
          <source>If no errors occur, value of the complementary error function of &lt;code&gt;arg&lt;/code&gt;, that is</source>
          <target state="translated">Если ошибок не возникает, значение дополнительной функции ошибок &lt;code&gt;arg&lt;/code&gt; , то есть</target>
        </trans-unit>
        <trans-unit id="df9c117eae172dac4ec6d5b52cce8a077d21f8a8" translate="yes" xml:space="preserve">
          <source>If no errors occur, value of the complete elliptic integral of the first kind of &lt;code&gt;k&lt;/code&gt;, that is &lt;code&gt;ellint_1(k,&amp;pi;/2)&lt;/code&gt;, is returned.</source>
          <target state="translated">Если ошибок не возникает, возвращается значение полного эллиптического интеграла первого рода &lt;code&gt;k&lt;/code&gt; , то есть &lt;code&gt;ellint_1(k,&amp;pi;/2)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9cbeea440564c0733c80ec0f91528453bf57997d" translate="yes" xml:space="preserve">
          <source>If no errors occur, value of the complete elliptic integral of the second kind of &lt;code&gt;k&lt;/code&gt;, that is &lt;code&gt;ellint_2(k,&amp;pi;/2)&lt;/code&gt;, is returned.</source>
          <target state="translated">Если ошибок не возникает, возвращается значение полного эллиптического интеграла второго рода &lt;code&gt;k&lt;/code&gt; , то есть &lt;code&gt;ellint_2(k,&amp;pi;/2)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="66c1ee451279e40e8fca9ad9ed4b42f5978e872c" translate="yes" xml:space="preserve">
          <source>If no errors occur, value of the complete elliptic integral of the third kind of &lt;code&gt;k&lt;/code&gt; and &lt;code&gt;&amp;nu;&lt;/code&gt;, that is &lt;code&gt;std::ellint_3(k,&amp;nu;,&amp;pi;/2)&lt;/code&gt;, is returned.</source>
          <target state="translated">Если ошибок не возникает, возвращается значение полного эллиптического интеграла третьего рода &lt;code&gt;k&lt;/code&gt; и &lt;code&gt;&amp;nu;&lt;/code&gt; , то есть &lt;code&gt;std::ellint_3(k,&amp;nu;,&amp;pi;/2)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a66e2b26fcc8bbc9cd86fdf7747135c750049f9c" translate="yes" xml:space="preserve">
          <source>If no errors occur, value of the cylindrical Bessel function of the first kind of &lt;code&gt;&amp;nu;&lt;/code&gt; and &lt;code&gt;x&lt;/code&gt;, that is J</source>
          <target state="translated">Если ошибок не возникает, значение цилиндрической функции Бесселя первого рода &lt;code&gt;&amp;nu;&lt;/code&gt; и &lt;code&gt;x&lt;/code&gt; , то есть J</target>
        </trans-unit>
        <trans-unit id="543182535183bd8bc0773d95ac751d4302a6fe06" translate="yes" xml:space="preserve">
          <source>If no errors occur, value of the cylindrical Neumann function (Bessel function of the second kind) of &lt;code&gt;&amp;nu;&lt;/code&gt; and &lt;code&gt;x&lt;/code&gt;, is returned, that is N</source>
          <target state="translated">Если ошибок не возникает, возвращается значение цилиндрической функции Неймана (функция Бесселя второго рода) &lt;code&gt;&amp;nu;&lt;/code&gt; и &lt;code&gt;x&lt;/code&gt; , то есть N</target>
        </trans-unit>
        <trans-unit id="0658bf24f8b1dde223e35183fc409335d58b1a45" translate="yes" xml:space="preserve">
          <source>If no errors occur, value of the error function of &lt;code&gt;arg&lt;/code&gt;, that is</source>
          <target state="translated">Если ошибок не возникает, значение функции ошибок &lt;code&gt;arg&lt;/code&gt; , то есть</target>
        </trans-unit>
        <trans-unit id="9df1996268d06781fa476369becefdaadd629195" translate="yes" xml:space="preserve">
          <source>If no errors occur, value of the exponential integral of &lt;code&gt;arg&lt;/code&gt;, that is -&amp;int;&amp;infin;</source>
          <target state="translated">Если ошибок не возникает, значение экспоненциального интеграла от &lt;code&gt;arg&lt;/code&gt; , то есть -&amp;int;&amp;infin;</target>
        </trans-unit>
        <trans-unit id="12d4162f2889063b6a7da39429e27d5af98a2241" translate="yes" xml:space="preserve">
          <source>If no errors occur, value of the incomplete elliptic integral of the first kind of &lt;code&gt;k&lt;/code&gt; and &lt;code&gt;&amp;phi;&lt;/code&gt;, that is &amp;int;&amp;phi;</source>
          <target state="translated">Если ошибок не возникает, значение неполного эллиптического интеграла первого рода &lt;code&gt;k&lt;/code&gt; и &lt;code&gt;&amp;phi;&lt;/code&gt; , то есть &amp;int;&amp;phi;</target>
        </trans-unit>
        <trans-unit id="f2687108220b1e44fef928c06fa5038f1e9ca385" translate="yes" xml:space="preserve">
          <source>If no errors occur, value of the incomplete elliptic integral of the second kind of &lt;code&gt;k&lt;/code&gt; and &lt;code&gt;&amp;phi;&lt;/code&gt;, that is &amp;int;&amp;phi;</source>
          <target state="translated">Если ошибок не возникает, значение неполного эллиптического интеграла второго рода &lt;code&gt;k&lt;/code&gt; и &lt;code&gt;&amp;phi;&lt;/code&gt; , то есть &amp;int;&amp;phi;</target>
        </trans-unit>
        <trans-unit id="7ebd0beae76ba7f9e7e5a8530d1366439fe50ddc" translate="yes" xml:space="preserve">
          <source>If no errors occur, value of the incomplete elliptic integral of the third kind of &lt;code&gt;k&lt;/code&gt;, &lt;code&gt;&amp;nu;&lt;/code&gt;, and &lt;code&gt;&amp;phi;&lt;/code&gt;, that is &amp;int;&amp;phi;</source>
          <target state="translated">Если ошибок не возникает, значение неполного эллиптического интеграла третьего рода &lt;code&gt;k&lt;/code&gt; , &lt;code&gt;&amp;nu;&lt;/code&gt; и &lt;code&gt;&amp;phi;&lt;/code&gt; , то есть &amp;int;&amp;phi;</target>
        </trans-unit>
        <trans-unit id="47bf302c79b395741bf53556a6be82fa3fd028e9" translate="yes" xml:space="preserve">
          <source>If no errors occur, value of the irregular modified cylindrical Bessel function (modified Bessel function of the second kind) of &lt;code&gt;&amp;nu;&lt;/code&gt; and &lt;code&gt;x&lt;/code&gt;, is returned, that is K</source>
          <target state="translated">Если ошибок не возникает, возвращается значение нерегулярной модифицированной цилиндрической функции Бесселя (модифицированная функция Бесселя второго рода) &lt;code&gt;&amp;nu;&lt;/code&gt; и &lt;code&gt;x&lt;/code&gt; , то есть K</target>
        </trans-unit>
        <trans-unit id="aea1c8d887f4647bdb33eced1d1223c98eae241d" translate="yes" xml:space="preserve">
          <source>If no errors occur, value of the nonassociated Laguerre polynomial of &lt;code&gt;x&lt;/code&gt;, that is</source>
          <target state="translated">Если ошибок не возникает, значение неассоциированного многочлена Лагерра от &lt;code&gt;x&lt;/code&gt; , то есть</target>
        </trans-unit>
        <trans-unit id="6f5b17abebff553421278dbae1b01fcc098edc8f" translate="yes" xml:space="preserve">
          <source>If no errors occur, value of the order-&lt;code&gt;n&lt;/code&gt; unassociated Legendre polynomial of &lt;code&gt;x&lt;/code&gt;, that is \(\mathsf{P}_n(x) = \frac{1}{2^n n!} \frac{\mathsf{d}^n}{\mathsf{d}x^n} (x^2-1)^n \)</source>
          <target state="translated">Если ошибок не возникает, значение порядкового &lt;code&gt;n&lt;/code&gt; неассоциированного полинома Лежандра от &lt;code&gt;x&lt;/code&gt; , то есть \ (\ mathsf {P} _n (x) = \ frac {1} {2 ^ nn!} \ Frac {\ mathsf {d} ^ n} {\ mathsf {d} x ^ n} (x ^ 2-1) ^ n \)</target>
        </trans-unit>
        <trans-unit id="5fe63011566ab90404ecbc2fc30a86fbf404e9b5" translate="yes" xml:space="preserve">
          <source>If no errors occur, value of the order-&lt;code&gt;n&lt;/code&gt;Hermite polynomial of &lt;code&gt;x&lt;/code&gt;, that is (-1)n</source>
          <target state="translated">Если ошибок не возникает, значение порядка &lt;code&gt;n&lt;/code&gt; полинома Эрмита от &lt;code&gt;x&lt;/code&gt; , то есть (-1) n</target>
        </trans-unit>
        <trans-unit id="521caff23698b2c47666d0e91701aa665925f3de" translate="yes" xml:space="preserve">
          <source>If no errors occur, value of the regular modified cylindrical Bessel function of &lt;code&gt;&amp;nu;&lt;/code&gt; and &lt;code&gt;x&lt;/code&gt;, that is I</source>
          <target state="translated">Если ошибок нет, значение правильной модифицированной цилиндрической функции Бесселя &lt;code&gt;&amp;nu;&lt;/code&gt; и &lt;code&gt;x&lt;/code&gt; , то есть I</target>
        </trans-unit>
        <trans-unit id="031ce73d89df4a56cec229b26ace78aed68d756e" translate="yes" xml:space="preserve">
          <source>If no exception was thrown during input, sets the number of extracted characters (gcount) in the input stream.</source>
          <target state="translated">Если во время ввода не было выброшено ни одного исключения,устанавливает количество извлекаемых символов (gcount)во входном потоке.</target>
        </trans-unit>
        <trans-unit id="4c799e4f486ea142e7186bf650ea8a5b122a9d32" translate="yes" xml:space="preserve">
          <source>If no exception was thrown, returns &lt;code&gt;*this&lt;/code&gt;.</source>
          <target state="translated">Если исключение не было выдано, возвращает &lt;code&gt;*this&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d67368bbb57de9e88e241a4a9a8276ff5bf9165e" translate="yes" xml:space="preserve">
          <source>If no exception was thrown, returns the value specified by the function.</source>
          <target state="translated">Если не было выброшено ни одного исключения,возвращает значение,указанное функцией.</target>
        </trans-unit>
        <trans-unit id="1f75f70449c5d517f16e8db38a32eb7a472a99d1" translate="yes" xml:space="preserve">
          <source>If no initializer is provided, the rules of &lt;a href=&quot;default_initialization&quot;&gt;default initialization&lt;/a&gt; apply.</source>
          <target state="translated">Если инициализатор не предоставлен, применяются правила &lt;a href=&quot;default_initialization&quot;&gt;инициализации&lt;/a&gt; по умолчанию .</target>
        </trans-unit>
        <trans-unit id="51774f7adc99f180db60612981a5526941d80108" translate="yes" xml:space="preserve">
          <source>If no matches are found after all catch-clauses were examined, the exception propagation continues to the containing try-block, as described in &lt;a href=&quot;throw&quot;&gt;throw-expression&lt;/a&gt;. If there are no containing try-blocks left, &lt;code&gt;&lt;a href=&quot;../error/terminate&quot;&gt;std::terminate&lt;/a&gt;&lt;/code&gt; is executed (in this case, it is implementation-defined whether any stack unwinding occurs at all: throwing an uncaught exception is permitted to terminate the program without invoking any destructors).</source>
          <target state="translated">Если совпадения не найдены после того, как были проверены все предложения catch, распространение исключения продолжается до содержащего try-блока, как описано в &lt;a href=&quot;throw&quot;&gt;throw-expression&lt;/a&gt; . Если не осталось ни одного содержащего блока try, выполняется &lt;code&gt;&lt;a href=&quot;../error/terminate&quot;&gt;std::terminate&lt;/a&gt;&lt;/code&gt; (в этом случае определяется, реализована ли вообще какая-либо раскрутка стека: выбрасывание неперехваченного исключения разрешает завершить программу без вызова каких-либо деструкторов).</target>
        </trans-unit>
        <trans-unit id="85ed69b90bb670ce03358daa2e3280ab8a0acaef" translate="yes" xml:space="preserve">
          <source>If no memory could be allocated, or allocated storage is not enough to store a single element of type &lt;code&gt;T&lt;/code&gt;, the &lt;code&gt;first&lt;/code&gt; element of the result is a null pointer and the &lt;code&gt;second&lt;/code&gt; element is zero.</source>
          <target state="translated">Если никакая память не может быть выделена или выделенного хранилища недостаточно для хранения одного элемента типа &lt;code&gt;T&lt;/code&gt; , &lt;code&gt;first&lt;/code&gt; элемент результата является нулевым указателем, а &lt;code&gt;second&lt;/code&gt; элемент равен нулю.</target>
        </trans-unit>
        <trans-unit id="9d359f89a70fe560ca132223fbd242fa45ae36ac" translate="yes" xml:space="preserve">
          <source>If no mismatches are found when the comparison reaches &lt;code&gt;last1&lt;/code&gt; or &lt;code&gt;last2&lt;/code&gt;, whichever happens first, the pair holds the end iterator and the corresponding iterator from the other range.</source>
          <target state="translated">Если нет несоответствий не обнаружено , когда сравнение достигает &lt;code&gt;last1&lt;/code&gt; или &lt;code&gt;last2&lt;/code&gt; , в зависимости от того происходит первое, пара имеет конечный итератор и соответствующий итератор из другого диапазона.</target>
        </trans-unit>
        <trans-unit id="5a80ff055cfd93f4382626d501c63e2d0233080f" translate="yes" xml:space="preserve">
          <source>If no mismatches are found when the comparison reaches &lt;code&gt;last1&lt;/code&gt;, the pair holds &lt;code&gt;last1&lt;/code&gt; and the corresponding iterator from the second range. The behavior is undefined if the second range is shorter than the first range.</source>
          <target state="translated">Если при достижении сравнения &lt;code&gt;last1&lt;/code&gt; несоответствия не обнаружено , пара удерживает &lt;code&gt;last1&lt;/code&gt; и соответствующий итератор из второго диапазона. Поведение не определено, если второй диапазон короче первого диапазона.</target>
        </trans-unit>
        <trans-unit id="781fedf1bc7025a615d3c4ed7f1b4d2a7b74af04" translate="yes" xml:space="preserve">
          <source>If no preferred functions are found, the non-preferred ones are considered in the next step.</source>
          <target state="translated">Если предпочтительные функции не найдены,то на следующем этапе рассматриваются функции,не являющиеся предпочтительными.</target>
        </trans-unit>
        <trans-unit id="212c7248247dc34425f2118c2a6054de49eb5fd9" translate="yes" xml:space="preserve">
          <source>If no such character was found, &lt;code&gt;str&lt;/code&gt; has only one token, and the future calls to &lt;code&gt;strtok&lt;/code&gt; will return a null pointer</source>
          <target state="translated">Если такой символ не найден, &lt;code&gt;str&lt;/code&gt; имеет только один токен, и будущие вызовы &lt;code&gt;strtok&lt;/code&gt; вернут нулевой указатель</target>
        </trans-unit>
        <trans-unit id="e0e3f85b21f0603ccfad7c7630e2e6165f6efad1" translate="yes" xml:space="preserve">
          <source>If no such character was found, there are no tokens in &lt;code&gt;str&lt;/code&gt; at all, and the function returns a null pointer.</source>
          <target state="translated">Если такого символа не найдено, токенов в &lt;code&gt;str&lt;/code&gt; нет вообще, и функция возвращает нулевой указатель.</target>
        </trans-unit>
        <trans-unit id="32d0b18e53a062a7ffa1ce497fbf816f66e2daa5" translate="yes" xml:space="preserve">
          <source>If no such elements are found, &lt;code&gt;last&lt;/code&gt; is returned.</source>
          <target state="translated">Если таких элементов не найдено, возвращается &lt;code&gt;last&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8ef5b0f78fdffa741da1e2a6130af0d51d257860" translate="yes" xml:space="preserve">
          <source>If no such sequence is found, &lt;code&gt;last&lt;/code&gt; is returned.</source>
          <target state="translated">Если такая последовательность не найдена, возвращается &lt;code&gt;last&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="95318ca2ad225ff32e9ddd27aadd58f11c7c9bf8" translate="yes" xml:space="preserve">
          <source>If no such wide character was found, &lt;code&gt;str&lt;/code&gt; has only one token, and future calls to &lt;code&gt;std::wcstok&lt;/code&gt; will return a null pointer</source>
          <target state="translated">Если такой широкий символ не был найден, &lt;code&gt;str&lt;/code&gt; имеет только один токен, и будущие вызовы &lt;code&gt;std::wcstok&lt;/code&gt; вернут нулевой указатель</target>
        </trans-unit>
        <trans-unit id="d9fb4aef6036de9d69cd4d033e352d979c405074" translate="yes" xml:space="preserve">
          <source>If no such wide character was found, there are no tokens in &lt;code&gt;str&lt;/code&gt; at all, and the function returns a null pointer.</source>
          <target state="translated">Если такой широкий символ не был найден, в &lt;code&gt;str&lt;/code&gt; нет никаких токенов , и функция возвращает нулевой указатель.</target>
        </trans-unit>
        <trans-unit id="40ac478406fa04d277853c0748ded82cd0ccce6d" translate="yes" xml:space="preserve">
          <source>If no user-declared constructors of any kind are provided for a class type (&lt;code&gt;struct&lt;/code&gt;, &lt;code&gt;class&lt;/code&gt;, or &lt;code&gt;union&lt;/code&gt;), the compiler will always declare a default constructor as an &lt;code&gt;inline public&lt;/code&gt; member of its class.</source>
          <target state="translated">Если для типа класса ( &lt;code&gt;struct&lt;/code&gt; , &lt;code&gt;class&lt;/code&gt; или &lt;code&gt;union&lt;/code&gt; ) не предоставлено ни одного объявленного пользователем конструктора любого типа , компилятор всегда объявляет конструктор по умолчанию как &lt;code&gt;inline public&lt;/code&gt; член своего класса.</target>
        </trans-unit>
        <trans-unit id="7ad4343e0140e81303cc7ccdcdc20abcd1b3af02" translate="yes" xml:space="preserve">
          <source>If no user-declared destructor is provided for a &lt;a href=&quot;class&quot;&gt;class type&lt;/a&gt; (&lt;code&gt;struct&lt;/code&gt;, &lt;code&gt;class&lt;/code&gt;, or &lt;code&gt;union&lt;/code&gt;), the compiler will always declare a destructor as an &lt;code&gt;inline public&lt;/code&gt; member of its class.</source>
          <target state="translated">Если деструктор, объявленный пользователем, не предоставлен для &lt;a href=&quot;class&quot;&gt;типа класса&lt;/a&gt; ( &lt;code&gt;struct&lt;/code&gt; , &lt;code&gt;class&lt;/code&gt; или &lt;code&gt;union&lt;/code&gt; ), компилятор всегда объявляет деструктор как &lt;code&gt;inline public&lt;/code&gt; член своего класса.</target>
        </trans-unit>
        <trans-unit id="bb4a43dac5ef9eabbbba755dc09ed6605a9c36f6" translate="yes" xml:space="preserve">
          <source>If no user-defined constructors are present and the implicitly-declared default constructor is not trivial, the user may still inhibit the automatic generation of an implicitly-defined default constructor by the compiler with the keyword &lt;code&gt;delete&lt;/code&gt;.</source>
          <target state="translated">Если пользовательские конструкторы отсутствуют, а неявно объявленный конструктор по умолчанию не является тривиальным, пользователь все равно может запретить автоматическую генерацию неявно определенного конструктора по умолчанию компилятором с ключевым словом &lt;code&gt;delete&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="94c428bc493bfd4bf3cb4c40be6d006d6ae9320b" translate="yes" xml:space="preserve">
          <source>If no user-defined copy assignment operators are provided for a class type (&lt;code&gt;struct&lt;/code&gt;, &lt;code&gt;class&lt;/code&gt;, or &lt;code&gt;union&lt;/code&gt;), the compiler will always declare one as an inline public member of the class. This implicitly-declared copy assignment operator has the form &lt;code&gt;T&amp;amp; T::operator=(const T&amp;amp;)&lt;/code&gt; if all of the following is true:</source>
          <target state="translated">Если для типа класса ( &lt;code&gt;struct&lt;/code&gt; , &lt;code&gt;class&lt;/code&gt; или &lt;code&gt;union&lt;/code&gt; ) не заданы определяемые пользователем операторы копирования , компилятор всегда объявляет их как встроенный открытый член класса. Этот неявно объявленный оператор присваивания копии имеет вид &lt;code&gt;T&amp;amp; T::operator=(const T&amp;amp;)&lt;/code&gt; если все следующее верно:</target>
        </trans-unit>
        <trans-unit id="851c19dced47a32ee3f0fdfb9f639786302ce9fb" translate="yes" xml:space="preserve">
          <source>If no user-defined copy constructors are provided for a class type (&lt;code&gt;struct&lt;/code&gt;, &lt;code&gt;class&lt;/code&gt;, or &lt;code&gt;union&lt;/code&gt;), the compiler will always declare a copy constructor as a non-&lt;a href=&quot;explicit&quot;&gt;explicit&lt;/a&gt;&lt;code&gt;inline public&lt;/code&gt; member of its class. This implicitly-declared copy constructor has the form &lt;code&gt;T::T(const T&amp;amp;)&lt;/code&gt; if all of the following are true:</source>
          <target state="translated">Если нет определенного пользователя конструкторы копирования не предусмотрен для типа класса ( &lt;code&gt;struct&lt;/code&gt; , &lt;code&gt;class&lt;/code&gt; , или &lt;code&gt;union&lt;/code&gt; ), компилятор всегда будет объявить конструктор копирования в качестве не- &lt;a href=&quot;explicit&quot;&gt;явного &lt;/a&gt; &lt;code&gt;inline public&lt;/code&gt; члена своего класса. Этот неявно объявленный конструктор копирования имеет форму &lt;code&gt;T::T(const T&amp;amp;)&lt;/code&gt; если все из следующего является истинным:</target>
        </trans-unit>
        <trans-unit id="b4fd8cb3d9cb59c45a27ed26df217a6fe2527317" translate="yes" xml:space="preserve">
          <source>If no user-defined move assignment operators are provided for a class type (&lt;code&gt;struct&lt;/code&gt;, &lt;code&gt;class&lt;/code&gt;, or &lt;code&gt;union&lt;/code&gt;), and all of the following is true:</source>
          <target state="translated">Если для типа класса ( &lt;code&gt;struct&lt;/code&gt; , &lt;code&gt;class&lt;/code&gt; или &lt;code&gt;union&lt;/code&gt; ) не заданы пользовательские операторы присваивания перемещения , и выполняется все следующее:</target>
        </trans-unit>
        <trans-unit id="d13ec6ee9e77a6e3545912f76a282bde870c425b" translate="yes" xml:space="preserve">
          <source>If no user-defined move constructors are provided for a class type (&lt;code&gt;struct&lt;/code&gt;, &lt;code&gt;class&lt;/code&gt;, or &lt;code&gt;union&lt;/code&gt;), and all of the following is true:</source>
          <target state="translated">Если для типа класса ( &lt;code&gt;struct&lt;/code&gt; , &lt;code&gt;class&lt;/code&gt; или &lt;code&gt;union&lt;/code&gt; ) не заданы пользовательские конструкторы перемещения , и все из следующего верно:</target>
        </trans-unit>
        <trans-unit id="12fccd1db64bc403607d3dd62463e20e8242d5d4" translate="yes" xml:space="preserve">
          <source>If non-default allocators are intended to be supported for the allocation of the implementation object, any of the usual allocator awareness patterns may be utilized, including allocator template parameter defaulting to &lt;code&gt;&lt;a href=&quot;../memory/allocator&quot;&gt;std::allocator&lt;/a&gt;&lt;/code&gt; and constructor argument of type &lt;a href=&quot;../memory/memory_resource&quot;&gt;&lt;code&gt;std::pmr::memory_resource*&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Если распределители не по умолчанию предназначены для поддержки для выделения объекта реализации, могут использоваться любые обычные шаблоны осведомленности распределителя, включая параметр шаблона распределителя по умолчанию, равный &lt;code&gt;&lt;a href=&quot;../memory/allocator&quot;&gt;std::allocator&lt;/a&gt;&lt;/code&gt; и аргумент конструктора типа &lt;a href=&quot;../memory/memory_resource&quot;&gt; &lt;code&gt;std::pmr::memory_resource*&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9e7a52425c4552c258484ec30442892b69acfcad" translate="yes" xml:space="preserve">
          <source>If not empty, destroys the contained object.</source>
          <target state="translated">Если не пустой,уничтожает содержащийся в нем объект.</target>
        </trans-unit>
        <trans-unit id="46f7a7c5951af943707abba8135020cebc9f7870" translate="yes" xml:space="preserve">
          <source>If object is a non-bit-field rvalue or a function lvalue, and its type is either &lt;code&gt;T&lt;/code&gt; or derived from &lt;code&gt;T&lt;/code&gt;, equally or less cv-qualified, then the reference is bound to the value of the initializer expression or to its base subobject (after &lt;a href=&quot;implicit_cast#Temporary_materialization&quot;&gt;materializing a temporary&lt;/a&gt; if necessary)(since C++17).</source>
          <target state="translated">Если объект представляет собой не-битовое поле rvalue или функцию lvalue, а его тип является либо &lt;code&gt;T&lt;/code&gt; , либо производным от &lt;code&gt;T&lt;/code&gt; , с равной или меньшей квалификацией cv, то ссылка привязывается к значению выражения инициализатора или его базовому подобъекту (после &lt;a href=&quot;implicit_cast#Temporary_materialization&quot;&gt;материализации временного в&lt;/a&gt; случае необходимости) (начиная с C ++ 17).</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
