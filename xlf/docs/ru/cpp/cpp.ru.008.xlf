<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="cpp">
    <body>
      <group id="cpp">
        <trans-unit id="ebd2ec0b130f71d262d87cd87e080e799f354dca" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;alignof(&lt;/code&gt;type-id&lt;code&gt;)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;alignof(&lt;/code&gt;type-id&lt;code&gt;)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f44e7b7045981421755d118aa1f74107340a7771" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;allocator_type::value_type&lt;/code&gt; must be the same as &lt;code&gt;X::value_type&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;allocator_type::value_type&lt;/code&gt; должен совпадать с &lt;code&gt;X::value_type&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3532ce805aaa10fb133fe6a09e77355516837e45" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;app&lt;/code&gt;, &lt;code&gt;out|app&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;app&lt;/code&gt; , &lt;code&gt;out|app&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="07c827073bf89e714367ae756bf6369538f5f235" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;args&lt;/code&gt;, suitable argument list, which may be empty</source>
          <target state="translated">&lt;code&gt;args&lt;/code&gt; , список подходящих аргументов, который может быть пустым</target>
        </trans-unit>
        <trans-unit id="37d5e9afff11c7d6f1a32d566e8647f07d8068c7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;args&lt;/code&gt;: a function parameter pack with the pattern &lt;code&gt;Arg&amp;amp;&amp;amp;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;args&lt;/code&gt; : пакет параметров функции с шаблоном &lt;code&gt;Arg&amp;amp;&amp;amp;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5badce74e4250cbddfbfaee79d4cc54fac1ff9f6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;argument_type&lt;/code&gt;(deprecated in C++17)</source>
          <target state="translated">&lt;code&gt;argument_type&lt;/code&gt; (устарел в C ++ 17)</target>
        </trans-unit>
        <trans-unit id="2f117061012ddeffdc3050c3b2b1050ec416dac9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;argument_type&lt;/code&gt;(deprecated in C++17)(removed in C++20)</source>
          <target state="translated">&lt;code&gt;argument_type&lt;/code&gt; (устарел в C ++ 17) (удален в C ++ 20)</target>
        </trans-unit>
        <trans-unit id="42c2f18252f2ad115d660eb4fe5d1c943f0deaaa" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;as_writable_bytes&lt;/code&gt; only participates in overload resolution if &lt;code&gt;&lt;a href=&quot;../../types/is_const&quot;&gt;std::is_const_v&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;as_writable_bytes&lt;/code&gt; участвует только в разрешении перегрузки, если &lt;code&gt;&lt;a href=&quot;../../types/is_const&quot;&gt;std::is_const_v&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt; имеет значение &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a33ed179d2cca7162a766f390d4bcea8b632ae99" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;asm (&lt;/code&gt;string_literal&lt;code&gt;)&lt;/code&gt;&lt;code&gt;;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;asm (&lt;/code&gt; string_literal &lt;code&gt;)&lt;/code&gt; &lt;code&gt;;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="81416574a3bdb5b6e662f9881120a34330414456" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;atexit&lt;/code&gt; is thread-safe: calling the function from several threads does not induce a data race.</source>
          <target state="translated">&lt;code&gt;atexit&lt;/code&gt; является потокобезопасным: вызов функции из нескольких потоков не вызывает гонки данных.</target>
        </trans-unit>
        <trans-unit id="82fe65c70980dd8294c7a044920ff6948bb995a4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;atomic_cancel&lt;/code&gt;compound-statement</source>
          <target state="translated">&lt;code&gt;atomic_cancel&lt;/code&gt;compound-statement</target>
        </trans-unit>
        <trans-unit id="718753e51ee58fcc3a9b874bbfc25e05ee87099f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;atomic_cancel&lt;/code&gt;compound-statement.</source>
          <target state="translated">&lt;code&gt;atomic_cancel&lt;/code&gt;compound-statement.</target>
        </trans-unit>
        <trans-unit id="c4bb431c9a8c27ffbcb57f1e2030ffcdaa682589" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;atomic_commit&lt;/code&gt;compound-statement</source>
          <target state="translated">&lt;code&gt;atomic_commit&lt;/code&gt;compound-statement</target>
        </trans-unit>
        <trans-unit id="dc03de8684bde862cdd451c15145d5937d4aa9e8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;atomic_commit&lt;/code&gt;compound-statement.</source>
          <target state="translated">&lt;code&gt;atomic_commit&lt;/code&gt;compound-statement.</target>
        </trans-unit>
        <trans-unit id="9917e2226a40c215ff624d65d369e5d18521d70b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;atomic_noexcept&lt;/code&gt;compound-statement</source>
          <target state="translated">&lt;code&gt;atomic_noexcept&lt;/code&gt;compound-statement</target>
        </trans-unit>
        <trans-unit id="5d7a8f566cfc5ea680fc175590dc8b6fc4e5f7b6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;atomic_noexcept&lt;/code&gt;compound-statement.</source>
          <target state="translated">&lt;code&gt;atomic_noexcept&lt;/code&gt;compound-statement.</target>
        </trans-unit>
        <trans-unit id="84df6b95b4568b36529d65a8fee8565da22271bd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;atomic_thread_fence&lt;/code&gt; imposes stronger synchronization constraints than an atomic store operation with the same &lt;code&gt;&lt;a href=&quot;memory_order&quot;&gt;std::memory_order&lt;/a&gt;&lt;/code&gt;. While an atomic store-release operation prevents all preceding writes from moving past the store-release, an &lt;code&gt;atomic_thread_fence&lt;/code&gt; with &lt;code&gt;memory_order_release&lt;/code&gt; ordering prevents all preceding writes from moving past all subsequent stores.</source>
          <target state="translated">&lt;code&gt;atomic_thread_fence&lt;/code&gt; накладывает более строгие ограничения синхронизации, чем атомная операция хранения с тем же &lt;code&gt;&lt;a href=&quot;memory_order&quot;&gt;std::memory_order&lt;/a&gt;&lt;/code&gt; . В то время как атомарная операция освобождения хранилища предотвращает перемещение всех предыдущих &lt;code&gt;atomic_thread_fence&lt;/code&gt; за &lt;code&gt;memory_order_release&lt;/code&gt; хранилища, atomic_thread_fence с упорядочением memory_order_release предотвращает перемещение всех предыдущих записей мимо всех последующих хранилищ.</target>
        </trans-unit>
        <trans-unit id="d2b8b8d94103c192bc34b9f2294272b3203ef193" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;audit&lt;/code&gt; contract level</source>
          <target state="translated">&lt;code&gt;audit&lt;/code&gt; уровень контракта на аудит</target>
        </trans-unit>
        <trans-unit id="76aee5a355d183a0f5d23e16f44cf76ee2b9d2e6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;auto &amp;amp;&amp;amp; __range =&lt;/code&gt;range_expression&lt;code&gt;;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;auto &amp;amp;&amp;amp; __range =&lt;/code&gt; range_expression &lt;code&gt;;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a9f17e418dc5efb3e325fa889fa484a44b496616" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;auto p = &lt;a href=&quot;../memory/unique_ptr/make_unique&quot;&gt;std::make_unique&lt;/a&gt;&amp;lt;S&amp;gt;(); p-&amp;gt;bar()&lt;/code&gt; calls &lt;code&gt;p.operator-&amp;gt;()&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;auto p = &lt;a href=&quot;../memory/unique_ptr/make_unique&quot;&gt;std::make_unique&lt;/a&gt;&amp;lt;S&amp;gt;(); p-&amp;gt;bar()&lt;/code&gt; вызывает &lt;code&gt;p.operator-&amp;gt;()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="032d85b2fb46f2a33a2e395c59034caf15133db6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;auto&lt;/code&gt; -</source>
          <target state="translated">&lt;code&gt;auto&lt;/code&gt; -</target>
        </trans-unit>
        <trans-unit id="ec4949cdf660704545c46868dec318b7dbf26454" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;auto&lt;/code&gt; placeholder type specifier</source>
          <target state="translated">&lt;code&gt;auto&lt;/code&gt; указатель типа заполнителя</target>
        </trans-unit>
        <trans-unit id="dd355700463adc8e941685a068bf44f8191f5a8e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;auto_ptr&lt;/code&gt; is a smart pointer that manages an object obtained via &lt;a href=&quot;../language/new&quot;&gt;new expression&lt;/a&gt; and deletes that object when &lt;code&gt;auto_ptr&lt;/code&gt; itself is destroyed. It may be used to provide exception safety for dynamically-allocated objects, for passing ownership of dynamically-allocated objects into functions and for returning dynamically-allocated objects from functions.</source>
          <target state="translated">&lt;code&gt;auto_ptr&lt;/code&gt; - это интеллектуальный указатель, который управляет объектом, полученным с помощью &lt;a href=&quot;../language/new&quot;&gt;нового выражения,&lt;/a&gt; и удаляет этот объект, когда сам &lt;code&gt;auto_ptr&lt;/code&gt; уничтожается. Он может использоваться для обеспечения безопасности исключений для динамически распределяемых объектов, для передачи прав собственности на динамически распределяемые объекты в функции и для возврата динамически распределяемых объектов из функций.</target>
        </trans-unit>
        <trans-unit id="83ea9a5c7bd8a0003bfe61072b17683f502bbfcc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;auto_ptr_ref&lt;/code&gt; is an implementation-defined type that holds a reference to &lt;code&gt;auto_ptr&lt;/code&gt;. &lt;code&gt;&lt;a href=&quot;../auto_ptr&quot;&gt;std::auto_ptr&lt;/a&gt;&lt;/code&gt; is implicitly &lt;a href=&quot;operator_auto_ptr&quot;&gt;convertible to&lt;/a&gt; and &lt;a href=&quot;operator=&quot;&gt;assignable from&lt;/a&gt; this type. The implementation is allowed to provide the template with a different name or implement equivalent functionality in other ways.</source>
          <target state="translated">&lt;code&gt;auto_ptr_ref&lt;/code&gt; - это тип, определенный реализацией, который содержит ссылку на &lt;code&gt;auto_ptr&lt;/code&gt; . &lt;code&gt;&lt;a href=&quot;../auto_ptr&quot;&gt;std::auto_ptr&lt;/a&gt;&lt;/code&gt; неявно &lt;a href=&quot;operator_auto_ptr&quot;&gt;конвертируется&lt;/a&gt; и &lt;a href=&quot;operator=&quot;&gt;присваивается из&lt;/a&gt; этого типа. Реализация может предоставлять шаблону другое имя или реализовывать эквивалентную функциональность другими способами.</target>
        </trans-unit>
        <trans-unit id="f1181b079848ad4630e4817e7becf18e0449676f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;available&lt;/code&gt; -- free space available to a non-privileged process (may be equal or less than &lt;code&gt;free&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;available&lt;/code&gt; - свободное пространство доступно для непривилегированного процесса (может быть равно или меньше &lt;code&gt;free&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="193a702a1ece3e62c51179d1fd50a43ed52b5dbc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;awaiter.await_suspend(handle)&lt;/code&gt; is called, where handle is the coroutine handle representing the current coroutine. Inside that function, the suspended coroutine state is observable via that handle, and it's this function's responsibility to schedule it to resume on some executor, or to be destroyed (returning false counts as scheduling)</source>
          <target state="translated">&lt;code&gt;awaiter.await_suspend(handle)&lt;/code&gt; , где handle - это дескриптор сопрограммы, представляющий текущую сопрограмму. Внутри этой функции состояние приостановленной сопрограммы можно наблюдать с помощью этого дескриптора, и эта функция отвечает за планирование ее возобновления на каком-либо исполнителе или уничтожения (возвращая ложные значения в виде планирования)</target>
        </trans-unit>
        <trans-unit id="d025861833dc33a493957293ac40ae06518ca811" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;axiom&lt;/code&gt; contract level</source>
          <target state="translated">&lt;code&gt;axiom&lt;/code&gt; уровень контракта по аксиоме</target>
        </trans-unit>
        <trans-unit id="145025995cddfb0c2c9c5f6b4c119aef67258c74" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;b == a + (b - a)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;b == a + (b - a)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ca7fddee6b98e45102228f555b713744042ea185" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;b.size()&lt;/code&gt; where &lt;code&gt;b&lt;/code&gt; is the largest possible container</source>
          <target state="translated">&lt;code&gt;b.size()&lt;/code&gt; где &lt;code&gt;b&lt;/code&gt; - максимально возможный контейнер</target>
        </trans-unit>
        <trans-unit id="ce50e8c6ef19594e1c432b6f85c1a4b90bf3a38d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;b1 &amp;amp;&amp;amp; b2&lt;/code&gt;, &lt;code&gt;b1 &amp;amp;&amp;amp; bool(b2)&lt;/code&gt; and &lt;code&gt;bool(b1) &amp;amp;&amp;amp; b2&lt;/code&gt; are all equal to &lt;code&gt;bool(b1) &amp;amp;&amp;amp; bool(b2)&lt;/code&gt; and have the same short-circuit evaluation;</source>
          <target state="translated">&lt;code&gt;b1 &amp;amp;&amp;amp; b2&lt;/code&gt; , &lt;code&gt;b1 &amp;amp;&amp;amp; bool(b2)&lt;/code&gt; и &lt;code&gt;bool(b1) &amp;amp;&amp;amp; b2&lt;/code&gt; все равны &lt;code&gt;bool(b1) &amp;amp;&amp;amp; bool(b2)&lt;/code&gt; и имеют одинаковую оценку короткого замыкания;</target>
        </trans-unit>
        <trans-unit id="d123116bc0f09ca3ad761949ce648847c34c92b7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;b1 || b2&lt;/code&gt;, &lt;code&gt;b1 || bool(b2)&lt;/code&gt; and &lt;code&gt;bool(b1) || b2&lt;/code&gt; are all equal to &lt;code&gt;bool(b1) || bool(b2)&lt;/code&gt; and have the same short-circuit evaluation;</source>
          <target state="translated">&lt;code&gt;b1 || b2&lt;/code&gt; , &lt;code&gt;b1 || bool(b2)&lt;/code&gt; и &lt;code&gt;bool(b1) || b2&lt;/code&gt; все равны &lt;code&gt;bool(b1) || bool(b2)&lt;/code&gt; и имеют одинаковую оценку короткого замыкания;</target>
        </trans-unit>
        <trans-unit id="6eac658ea175ac6c07451b1a46e798bdf17973ce" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;b1&lt;/code&gt;, &lt;code&gt;b2&lt;/code&gt;, two lvalues of type &lt;code&gt;const &lt;a href=&quot;../types/remove_reference&quot;&gt;std::remove_reference_t&lt;/a&gt;&amp;lt;B&amp;gt;&lt;/code&gt;,</source>
          <target state="translated">&lt;code&gt;b1&lt;/code&gt; , &lt;code&gt;b2&lt;/code&gt; , два значения типа &lt;code&gt;const &lt;a href=&quot;../types/remove_reference&quot;&gt;std::remove_reference_t&lt;/a&gt;&amp;lt;B&amp;gt;&lt;/code&gt; ,</target>
        </trans-unit>
        <trans-unit id="6412a702062a0e09604a23adde3b60d786050fcd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;b&lt;/code&gt;, a value of type &lt;code&gt;bool&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;b&lt;/code&gt; , значение типа &lt;code&gt;bool&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="514056c1b49ea5088c99f6942670236289b94c07" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;b&lt;/code&gt;, an object of type &lt;code&gt;B&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;b&lt;/code&gt; , объект типа &lt;code&gt;B&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d7b9ab4cd6e6ceb7dce4b20058d3e2f787ff2546" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;back_inserter&lt;/code&gt; is a convenience function template that constructs a &lt;code&gt;&lt;a href=&quot;back_insert_iterator&quot;&gt;std::back_insert_iterator&lt;/a&gt;&lt;/code&gt; for the container &lt;code&gt;c&lt;/code&gt; with the type deduced from the type of the argument.</source>
          <target state="translated">&lt;code&gt;back_inserter&lt;/code&gt; - это шаблон вспомогательной функции, который создает &lt;code&gt;&lt;a href=&quot;back_insert_iterator&quot;&gt;std::back_insert_iterator&lt;/a&gt;&lt;/code&gt; для контейнера &lt;code&gt;c&lt;/code&gt; с типом, выведенным из типа аргумента.</target>
        </trans-unit>
        <trans-unit id="aef2a40fcb800e3d5daaaf24742ed673ba9aa6ae" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;bad_exception&lt;/code&gt; object to initialize with</source>
          <target state="translated">&lt;code&gt;bad_exception&lt;/code&gt; объект bad_exception для инициализации</target>
        </trans-unit>
        <trans-unit id="23fc76c7aa7f5cc34c63b8435077717406faa856" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;basic_ios&lt;/code&gt; accessors</source>
          <target state="translated">&lt;code&gt;basic_ios&lt;/code&gt; аксессоров</target>
        </trans-unit>
        <trans-unit id="991738fdb1ba79201bd3b5fff575043207e9cd52" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;begin()&lt;/code&gt; returns a &lt;a href=&quot;../../iterator&quot;&gt;mutable&lt;/a&gt; or &lt;a href=&quot;../../iterator&quot;&gt;constant&lt;/a&gt; iterator, depending on the constness of &lt;code&gt;*this&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;begin()&lt;/code&gt; Функция begin () возвращает &lt;a href=&quot;../../iterator&quot;&gt;изменяемый&lt;/a&gt; или &lt;a href=&quot;../../iterator&quot;&gt;постоянный&lt;/a&gt; итератор, в зависимости от константности &lt;code&gt;*this&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3b2fabff44652b835a21acf2d98bc9b7da6e6b10" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;begin&lt;/code&gt;, &lt;code&gt;end&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;begin&lt;/code&gt; , &lt;code&gt;end&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="bb7fcec2ec181e4e03c55c4a974329ae46c607c3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;begin[k] = r2&lt;/code&gt;,</source>
          <target state="translated">&lt;code&gt;begin[k] = r2&lt;/code&gt; ,</target>
        </trans-unit>
        <trans-unit id="f62481721c1ee365dcb7f62b2010bbb186f92805" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;beta(x, y)&lt;/code&gt; equals &lt;code&gt;beta(y, x)&lt;/code&gt;  When &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; are positive integers, beta(x,y) equals \(\frac{(x-1)!(y-1)!}{(x+y-1)!}\).</source>
          <target state="translated">&lt;code&gt;beta(x, y)&lt;/code&gt; равна &lt;code&gt;beta(y, x)&lt;/code&gt; Когда &lt;code&gt;x&lt;/code&gt; и &lt;code&gt;y&lt;/code&gt; являются натуральными числами, бета (x, y) равна \ (\ frac {(x-1)! (y-1)!} {(x + у-1)!} \).</target>
        </trans-unit>
        <trans-unit id="604472692ecd3c5f988851b616db9e5f20d83e85" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;bidirectional_iterator_tag&lt;/code&gt; corresponds to &lt;a href=&quot;../named_req/bidirectionaliterator&quot;&gt;LegacyBidirectionalIterator&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;bidirectional_iterator_tag&lt;/code&gt; соответствует &lt;a href=&quot;../named_req/bidirectionaliterator&quot;&gt;LegacyBidirectionalIterator&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="125381ef6ab81d128250226bfde14db875a5b559" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;binary_function&lt;/code&gt; does not define &lt;code&gt;operator()&lt;/code&gt;; it is expected that derived classes will define this. &lt;code&gt;binary_function&lt;/code&gt; provides only three types - &lt;code&gt;first_argument_type&lt;/code&gt;, &lt;code&gt;second_argument_type&lt;/code&gt; and &lt;code&gt;result_type&lt;/code&gt; - defined by the template parameters.</source>
          <target state="translated">&lt;code&gt;binary_function&lt;/code&gt; не определяет &lt;code&gt;operator()&lt;/code&gt; ; ожидается, что производные классы будут определять это. &lt;code&gt;binary_function&lt;/code&gt; предоставляет только три типа - &lt;code&gt;first_argument_type&lt;/code&gt; , &lt;code&gt;second_argument_type&lt;/code&gt; и &lt;code&gt;result_type&lt;/code&gt; - определенные параметрами шаблона.</target>
        </trans-unit>
        <trans-unit id="16e551d920ab702201b563e5755c74ae3279f81b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;binary_function&lt;/code&gt; is a base class for creating function objects with two arguments.</source>
          <target state="translated">&lt;code&gt;binary_function&lt;/code&gt; - это базовый класс для создания объектов функций с двумя аргументами.</target>
        </trans-unit>
        <trans-unit id="ef3776fa71d38eff37d16e4c999b4523cedc63cc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;binary_function&lt;/code&gt; is deprecated in C++11 and removed in C++17.</source>
          <target state="translated">&lt;code&gt;binary_function&lt;/code&gt; устарела в C ++ 11 и удалена в C ++ 17.</target>
        </trans-unit>
        <trans-unit id="fdf831ffca60a5c8451d6a8a5a4b17a971fdc8d7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;binary_negate&lt;/code&gt; is a wrapper function object returning the complement of the binary predicate it holds.</source>
          <target state="translated">&lt;code&gt;binary_negate&lt;/code&gt; - это объект-функция-обертка, возвращающий дополнение двоичного предиката, который он содержит.</target>
        </trans-unit>
        <trans-unit id="8013c54114d282ea5e941f7cdfba99882e44212e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;binary_negate&lt;/code&gt; objects are easily constructed with helper function &lt;code&gt;&lt;a href=&quot;not2&quot;&gt;std::not2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;binary_negate&lt;/code&gt; Объекты binary_negate легко создаются с помощью вспомогательной функции &lt;code&gt;&lt;a href=&quot;not2&quot;&gt;std::not2&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b0a58479ad5dd66246e935f29e88258c7a2b6c98" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;binary_op&lt;/code&gt; shall not invalidate iterators (including the end iterators) or subranges, nor modify elements in the ranges [first, last) or [d_first, d_first + (last - first)). Otherwise, the behavior is undefined.</source>
          <target state="translated">&lt;code&gt;binary_op&lt;/code&gt; не должна делать недействительными итераторы (включая конечные итераторы) или поддиапазоны, а также не изменять элементы в диапазонах [first, last) или [d_first, d_first + (last - first)). В противном случае поведение не определено.</target>
        </trans-unit>
        <trans-unit id="9dc047979d7e3924246308fcb6924a121b70c6a4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;binary|app&lt;/code&gt;, &lt;code&gt;binary|out|app&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;binary|app&lt;/code&gt; , &lt;code&gt;binary|out|app&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0f0eed32cfc737c24a7788ccbca87ffd49f8f11f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;binary|out&lt;/code&gt;, &lt;code&gt;binary|out|trunc&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;binary|out&lt;/code&gt; , &lt;code&gt;binary|out|trunc&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6acb4c2014ee265eae300200f0e5c83e074d4983" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;binary|out|in|app&lt;/code&gt;, &lt;code&gt;binary|in|app&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;binary|out|in|app&lt;/code&gt; , &lt;code&gt;binary|in|app&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b591230d50c861956000b7a76117395374361917" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;bitset&lt;/code&gt; meets the requirements of &lt;a href=&quot;../named_req/copyconstructible&quot;&gt;CopyConstructible&lt;/a&gt; and &lt;a href=&quot;../named_req/copyassignable&quot;&gt;CopyAssignable&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;bitset&lt;/code&gt; соответствует требованиям &lt;a href=&quot;../named_req/copyconstructible&quot;&gt;CopyConstructible&lt;/a&gt; и &lt;a href=&quot;../named_req/copyassignable&quot;&gt;CopyAssignable&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7451240076a835cf07a3a852892863076f665623" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;bool(b1 != b2)&lt;/code&gt;, &lt;code&gt;bool(b1 != bool(b2))&lt;/code&gt;, and &lt;code&gt;bool(bool(b1) != b2)&lt;/code&gt; are all equal to &lt;code&gt;(bool(b1) != bool(b2))&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;bool(b1 != b2)&lt;/code&gt; , &lt;code&gt;bool(b1 != bool(b2))&lt;/code&gt; и &lt;code&gt;bool(bool(b1) != b2)&lt;/code&gt; все равны &lt;code&gt;(bool(b1) != bool(b2))&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0d5690794fcc294f7e0800d3f91cdc1efa41f6d3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;bool(b1 == b2)&lt;/code&gt;, &lt;code&gt;bool(b1 == bool(b2))&lt;/code&gt;, and &lt;code&gt;bool(bool(b1) == b2)&lt;/code&gt; are all equal to &lt;code&gt;(bool(b1) == bool(b2))&lt;/code&gt;;</source>
          <target state="translated">&lt;code&gt;bool(b1 == b2)&lt;/code&gt; , &lt;code&gt;bool(b1 == bool(b2))&lt;/code&gt; и &lt;code&gt;bool(bool(b1) == b2)&lt;/code&gt; все равны &lt;code&gt;(bool(b1) == bool(b2))&lt;/code&gt; ;</target>
        </trans-unit>
        <trans-unit id="0ce05b089af758edd37a80b26957774ddd79e3f7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;bool&lt;/code&gt; - type, capable of holding one of the two values: &lt;a href=&quot;bool_literal&quot;&gt;&lt;code&gt;true&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;bool_literal&quot;&gt;&lt;code&gt;false&lt;/code&gt;&lt;/a&gt;. The value of &lt;code&gt;sizeof(bool)&lt;/code&gt; is implementation defined and might differ from 1.</source>
          <target state="translated">&lt;code&gt;bool&lt;/code&gt; - тип, способный содержать одно из двух значений: &lt;a href=&quot;bool_literal&quot;&gt; &lt;code&gt;true&lt;/code&gt; &lt;/a&gt; или &lt;a href=&quot;bool_literal&quot;&gt; &lt;code&gt;false&lt;/code&gt; &lt;/a&gt; . Значение &lt;code&gt;sizeof(bool)&lt;/code&gt; определяется реализацией и может отличаться от 1.</target>
        </trans-unit>
        <trans-unit id="5d6ea2b6beaddc310f73e08e5cebae9d443418c8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;bool&lt;/code&gt; result of the corresponding relational operation.</source>
          <target state="translated">&lt;code&gt;bool&lt;/code&gt; результат соответствующей реляционной операции.</target>
        </trans-unit>
        <trans-unit id="6dd8657c98c6f75feace5c8bb8c68d633da923ca" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;bool&lt;/code&gt;, &lt;code&gt;char&lt;/code&gt;, &lt;code&gt;short&lt;/code&gt;, and unscoped enumerations are converted to &lt;code&gt;int&lt;/code&gt; or wider integer types as in &lt;a href=&quot;implicit_cast#Integer_promotion&quot;&gt;integer promotion&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;bool&lt;/code&gt; Перечисления bool , &lt;code&gt;char&lt;/code&gt; , &lt;code&gt;short&lt;/code&gt; и unscoped преобразуются в целочисленные типы &lt;code&gt;int&lt;/code&gt; или более широкие, как при &lt;a href=&quot;implicit_cast#Integer_promotion&quot;&gt;целочисленном продвижении&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="7c142d9cd8f4e00ee27b16d8937b7bfc659f09ba" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;bool&lt;/code&gt;, the result is &lt;code&gt;false&lt;/code&gt; if the original value is zero and &lt;code&gt;true&lt;/code&gt; for all other values. For the remaining integral types, the result is the value of the enum if it can be represented by the target type and unspecified otherwise.</source>
          <target state="translated">&lt;code&gt;bool&lt;/code&gt; , результат равен &lt;code&gt;false&lt;/code&gt; , если исходное значение равно нулю, и &lt;code&gt;true&lt;/code&gt; для всех остальных значений. Для остальных целочисленных типов результатом является значение перечисления, если оно может быть представлено целевым типом и не указано иначе.</target>
        </trans-unit>
        <trans-unit id="1704b5f6c511d5e29b31127118c09864980fcfe7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;boyer_moore_horspool_searcher&lt;/code&gt; is &lt;a href=&quot;../../named_req/copyconstructible&quot;&gt;CopyConstructible&lt;/a&gt; and &lt;a href=&quot;../../named_req/copyassignable&quot;&gt;CopyAssignable&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;boyer_moore_horspool_searcher&lt;/code&gt; является &lt;a href=&quot;../../named_req/copyconstructible&quot;&gt;CopyConstructible&lt;/a&gt; и &lt;a href=&quot;../../named_req/copyassignable&quot;&gt;CopyAssignable&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e95a8719b769a84cb4a89872dd1a2fd9dd057945" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;boyer_moore_searcher&lt;/code&gt; is &lt;a href=&quot;../../named_req/copyconstructible&quot;&gt;CopyConstructible&lt;/a&gt; and &lt;a href=&quot;../../named_req/copyassignable&quot;&gt;CopyAssignable&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;boyer_moore_searcher&lt;/code&gt; является &lt;a href=&quot;../../named_req/copyconstructible&quot;&gt;CopyConstructible&lt;/a&gt; и &lt;a href=&quot;../../named_req/copyassignable&quot;&gt;CopyAssignable&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3018cefa81e15a18496ea3ac39a93bdedc72dd92" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;c, d&lt;/code&gt;, values of type &lt;code&gt;CharT&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;c, d&lt;/code&gt; , значения типа &lt;code&gt;CharT&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6f14da71e36259d43be9260b7cd2f545b82b0aa2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;c&lt;/code&gt; on success except if &lt;code&gt;c&lt;/code&gt; was &lt;code&gt;&lt;a href=&quot;../c&quot;&gt;EOF&lt;/a&gt;&lt;/code&gt;, in which case unspecified value other than &lt;code&gt;&lt;a href=&quot;../c&quot;&gt;EOF&lt;/a&gt;&lt;/code&gt; is returned.</source>
          <target state="translated">&lt;code&gt;c&lt;/code&gt; в случае успеха, за исключением случаев, когда &lt;code&gt;c&lt;/code&gt; был &lt;code&gt;&lt;a href=&quot;../c&quot;&gt;EOF&lt;/a&gt;&lt;/code&gt; , и в этом случае возвращается неуказанное значение, отличное от &lt;code&gt;&lt;a href=&quot;../c&quot;&gt;EOF&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6595e0c469c9ea725dee3becc791202e2a799c0e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;c&lt;/code&gt; on success except if &lt;code&gt;c&lt;/code&gt; was &lt;code&gt;Traits::eof()&lt;/code&gt;, in which case &lt;code&gt;Traits::not_eof(c)&lt;/code&gt; is returned.</source>
          <target state="translated">&lt;code&gt;c&lt;/code&gt; в случае успеха, за исключением случаев, когда &lt;code&gt;c&lt;/code&gt; был &lt;code&gt;Traits::eof()&lt;/code&gt; , и в этом случае &lt;code&gt;Traits::not_eof(c)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b7f9b20f1dc860253fa886fac6fad0c25eb76b95" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;c&lt;/code&gt;, a value of type &lt;code&gt;const CharT&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;c&lt;/code&gt; , значение типа &lt;code&gt;const CharT&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e3fb041f39c4cd76a7056dff86c286a069714d0a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;c_str() + i == &lt;a href=&quot;../../memory/addressof&quot;&gt;std::addressof&lt;/a&gt;(operator[](i))&lt;/code&gt; for every &lt;code&gt;i&lt;/code&gt; in &lt;code&gt;[0, size()]&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;c_str() + i == &lt;a href=&quot;../../memory/addressof&quot;&gt;std::addressof&lt;/a&gt;(operator[](i))&lt;/code&gt; для каждого &lt;code&gt;i&lt;/code&gt; в &lt;code&gt;[0, size()]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="89aa3cbc65df52ce608a5e7ac02629217ec8ff46" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;c_str()&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data&quot;&gt;data()&lt;/a&gt;&lt;/code&gt; perform the same function.</source>
          <target state="translated">&lt;code&gt;c_str()&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;data&quot;&gt;data()&lt;/a&gt;&lt;/code&gt; выполняют одну и ту же функцию.</target>
        </trans-unit>
        <trans-unit id="6201ce88486526a9d5a89edff10f9b5e844bcd6c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;c_str()[i] == operator[](i)&lt;/code&gt; for every &lt;code&gt;i&lt;/code&gt; in &lt;code&gt;[0, size())&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;c_str()[i] == operator[](i)&lt;/code&gt; для каждого &lt;code&gt;i&lt;/code&gt; в &lt;code&gt;[0, size())&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="695d6e4e6f82836c536ff6f67b5f20765d596e63" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;canonical&lt;/code&gt; has a spurious &lt;code&gt;base&lt;/code&gt; parameter</source>
          <target state="translated">&lt;code&gt;canonical&lt;/code&gt; имеет ложный &lt;code&gt;base&lt;/code&gt; параметр</target>
        </trans-unit>
        <trans-unit id="e9d778424d09648ae8bb3c55c8adff2c01840148" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;capacity&lt;/code&gt; -- total size of the filesystem, in bytes</source>
          <target state="translated">&lt;code&gt;capacity&lt;/code&gt; - общий размер файловой системы, в байтах</target>
        </trans-unit>
        <trans-unit id="e0aa74fd60235dd91c5b99d21f5b5e7a5710903c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;catalog&lt;/code&gt; was erroneously specified as &lt;code&gt;int&lt;/code&gt; in C++11, this was corrected in &lt;a href=&quot;http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2028&quot;&gt;LWG issue #2028&lt;/a&gt; and included in C++14.</source>
          <target state="translated">&lt;code&gt;catalog&lt;/code&gt; был ошибочно указан как &lt;code&gt;int&lt;/code&gt; в C ++ 11, это было исправлено в &lt;a href=&quot;http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2028&quot;&gt;выпуске LWG № 2028&lt;/a&gt; и включено в C ++ 14.</target>
        </trans-unit>
        <trans-unit id="32b335a992e48a7e39b96c9ecbbec7090251bf77" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;catch (&lt;/code&gt;Tobject&lt;code&gt;)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;catch (&lt;/code&gt; Tobject &lt;code&gt;)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a76c13a4ced6d8aeca096ef03a660eb7e7fa09b7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;catch&lt;/code&gt;&lt;code&gt;(&lt;/code&gt;&lt;code&gt;...&lt;/code&gt;&lt;code&gt;)&lt;/code&gt;compound-statement</source>
          <target state="translated">&lt;code&gt;catch&lt;/code&gt;&lt;code&gt;(&lt;/code&gt;&lt;code&gt;...&lt;/code&gt;&lt;code&gt;)&lt;/code&gt;compound-statement</target>
        </trans-unit>
        <trans-unit id="951bcd9d5950fad26037ec8b382fe18ad9f95445" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;catch&lt;/code&gt;&lt;code&gt;(&lt;/code&gt;attr(optional)type-specifier-seqabstract-declarator(optional)&lt;code&gt;)&lt;/code&gt;compound-statement</source>
          <target state="translated">&lt;code&gt;catch&lt;/code&gt;&lt;code&gt;(&lt;/code&gt;attr(optional)type-specifier-seqabstract-declarator(optional)&lt;code&gt;)&lt;/code&gt;compound-statement</target>
        </trans-unit>
        <trans-unit id="2abc29fe0d27d382c9e9d7ae5c97bad94bc7e7bf" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;catch&lt;/code&gt;&lt;code&gt;(&lt;/code&gt;attr(optional)type-specifier-seqdeclarator&lt;code&gt;)&lt;/code&gt;compound-statement</source>
          <target state="translated">&lt;code&gt;catch&lt;/code&gt;&lt;code&gt;(&lt;/code&gt;attr(optional)type-specifier-seqdeclarator&lt;code&gt;)&lt;/code&gt;compound-statement</target>
        </trans-unit>
        <trans-unit id="265d210565c8bc198c650902495592b14e615308" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;cbegin()&lt;/code&gt; always returns a &lt;a href=&quot;../../iterator&quot;&gt;constant&lt;/a&gt; iterator. It is equivalent to &lt;code&gt;const_cast&amp;lt;const basic_string&amp;amp;&amp;gt;(*this).begin()&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;cbegin()&lt;/code&gt; всегда возвращает &lt;a href=&quot;../../iterator&quot;&gt;постоянный&lt;/a&gt; итератор. Это эквивалентно &lt;code&gt;const_cast&amp;lt;const basic_string&amp;amp;&amp;gt;(*this).begin()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b53fa0f87ce816608c34ff5bb1db059f792f746f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ch&lt;/code&gt; on success, &lt;code&gt;WEOF&lt;/code&gt; on failure.</source>
          <target state="translated">&lt;code&gt;ch&lt;/code&gt; на успехе, &lt;code&gt;WEOF&lt;/code&gt; на неудаче.</target>
        </trans-unit>
        <trans-unit id="5902bdd8082d07b7175e87e8b6552496268cd717" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ch&lt;/code&gt; on success, &lt;code&gt;WEOF&lt;/code&gt; on failure. If an encoding error occurs, &lt;code&gt;&lt;a href=&quot;../../error/errno&quot;&gt;errno&lt;/a&gt;&lt;/code&gt; is set to &lt;code&gt;EILSEQ&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;ch&lt;/code&gt; на успехе, &lt;code&gt;WEOF&lt;/code&gt; на провал. Если возникает ошибка кодирования, &lt;code&gt;&lt;a href=&quot;../../error/errno&quot;&gt;errno&lt;/a&gt;&lt;/code&gt; устанавливается в &lt;code&gt;EILSEQ&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="116b892a6e17f0b2ba65fcd7677fdb425a911eea" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;char16_t&lt;/code&gt; - type for UTF-16 character representation, required to be large enough to represent any UTF-16 code unit (16 bits). It has the same size, signedness, and alignment as &lt;code&gt;&lt;a href=&quot;../types/integer&quot;&gt;std::uint_least16_t&lt;/a&gt;&lt;/code&gt;, but is a distinct type.</source>
          <target state="translated">&lt;code&gt;char16_t&lt;/code&gt; - тип для представления символов UTF-16, который должен быть достаточно большим, чтобы представлять любую кодовую единицу UTF-16 (16 бит). Он имеет тот же размер, подпись и выравнивание, что и &lt;code&gt;&lt;a href=&quot;../types/integer&quot;&gt;std::uint_least16_t&lt;/a&gt;&lt;/code&gt; , но это отдельный тип.</target>
        </trans-unit>
        <trans-unit id="945338457821b46645aa197b8c00ce884b6a5203" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;char16_t&lt;/code&gt; or &lt;code&gt;char32_t&lt;/code&gt;(since C++11)</source>
          <target state="translated">&lt;code&gt;char16_t&lt;/code&gt; или &lt;code&gt;char32_t&lt;/code&gt; (начиная с C ++ 11)</target>
        </trans-unit>
        <trans-unit id="ad9febd37adb97f5e837608e018649d4d054b2ba" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;char32_t&lt;/code&gt; - type for UTF-32 character representation, required to be large enough to represent any UTF-32 code unit (32 bits). It has the same size, signedness, and alignment as &lt;code&gt;&lt;a href=&quot;../types/integer&quot;&gt;std::uint_least32_t&lt;/a&gt;&lt;/code&gt;, but is a distinct type.</source>
          <target state="translated">&lt;code&gt;char32_t&lt;/code&gt; - тип для представления символов UTF-32, должен быть достаточно большим, чтобы представлять любую кодовую единицу UTF-32 (32 бита). Он имеет тот же размер, подпись и выравнивание, что и &lt;code&gt;&lt;a href=&quot;../types/integer&quot;&gt;std::uint_least32_t&lt;/a&gt;&lt;/code&gt; , но это отдельный тип.</target>
        </trans-unit>
        <trans-unit id="2f76727583c7173fe3787d74015da4f9af2fb447" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;char8_t&lt;/code&gt; - type for UTF-8 character representation, required to be large enough to represent any UTF-8 code unit (8 bits). It has the same size, signedness, and alignment as &lt;code&gt;unsigned char&lt;/code&gt; (and. therefore, the same size and alignment as &lt;code&gt;char&lt;/code&gt; and &lt;code&gt;signed char&lt;/code&gt;), but is a distinct type.</source>
          <target state="translated">&lt;code&gt;char8_t&lt;/code&gt; - тип для представления символов UTF-8, должен быть достаточно большим, чтобы представлять любую кодовую единицу UTF-8 (8 бит). Он имеет тот же размер, подпись и выравнивание, что и &lt;code&gt;unsigned char&lt;/code&gt; (и, следовательно, тот же размер и выравнивание, что и &lt;code&gt;char&lt;/code&gt; и &lt;code&gt;signed char&lt;/code&gt; ), но это отдельный тип.</target>
        </trans-unit>
        <trans-unit id="a95fe516a9410a312c1068687b2ef3abb86b13de" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;char8_t&lt;/code&gt;(since C++20)</source>
          <target state="translated">&lt;code&gt;char8_t&lt;/code&gt; (начиная с C ++ 20)</target>
        </trans-unit>
        <trans-unit id="67a29b292971e9727b5bd8ba50bf35dfa62b49ae" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;char&lt;/code&gt; - type for character representation which can be most efficiently processed on the target system (has the same representation and alignment as either &lt;code&gt;signed char&lt;/code&gt; or &lt;code&gt;unsigned char&lt;/code&gt;, but is always a distinct type). &lt;a href=&quot;../string/multibyte&quot;&gt;Multibyte characters strings&lt;/a&gt; use this type to represent code units. The character types are large enough to represent any UTF-8 eight-bit code unit(since C++14). The signedness of &lt;code&gt;char&lt;/code&gt; depends on the compiler and the target platform: the defaults for ARM and PowerPC are typically unsigned, the defaults for x86 and x64 are typically signed.</source>
          <target state="translated">&lt;code&gt;char&lt;/code&gt; - тип для символьного представления, который может быть наиболее эффективно обработан в целевой системе (имеет такое же представление и выравнивание, что и &lt;code&gt;signed char&lt;/code&gt; или &lt;code&gt;unsigned char&lt;/code&gt; , но всегда является отдельным типом). &lt;a href=&quot;../string/multibyte&quot;&gt;Строки многобайтовых символов&lt;/a&gt; используют этот тип для представления единиц кода. Типы символов достаточно велики, чтобы представлять любую восьмибитную кодовую единицу UTF-8 (начиная с C ++ 14). Подпись &lt;code&gt;char&lt;/code&gt; зависит от компилятора и целевой платформы: значения по умолчанию для ARM и PowerPC обычно не подписаны, значения по умолчанию для x86 и x64 обычно подписаны.</target>
        </trans-unit>
        <trans-unit id="025be35fa02ce9330b9d00a12b219b118b301b0b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;char&lt;/code&gt; can be converted to &lt;code&gt;int&lt;/code&gt; or &lt;code&gt;unsigned int&lt;/code&gt; depending on the underlying type: &lt;code&gt;signed char&lt;/code&gt; or &lt;code&gt;unsigned char&lt;/code&gt; (see above);</source>
          <target state="translated">&lt;code&gt;char&lt;/code&gt; может быть преобразован в &lt;code&gt;int&lt;/code&gt; или &lt;code&gt;unsigned int&lt;/code&gt; в зависимости от базового типа: &lt;code&gt;signed char&lt;/code&gt; или &lt;code&gt;unsigned char&lt;/code&gt; (см. выше);</target>
        </trans-unit>
        <trans-unit id="47a3a82c4593fa0959ef8cbe7bf50f291eea94cf" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;char&lt;/code&gt; or &lt;code&gt;wchar_t&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;char&lt;/code&gt; или &lt;code&gt;wchar_t&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9fb8babbd1e77119f20f4cc12d08b49df3573f51" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;char&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;char&lt;/code&gt;).</target>
        </trans-unit>
        <trans-unit id="8902bbe3b62d5a977dd3062a35a69ce055124a21" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;char_traits&amp;lt;char16_t&amp;gt;&lt;/code&gt;(C++11)</source>
          <target state="translated">&lt;code&gt;char_traits&amp;lt;char16_t&amp;gt;&lt;/code&gt;(C++11)</target>
        </trans-unit>
        <trans-unit id="d2dc1a15f34d17da88aad9dde6ec3e69635d3345" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;char_traits&amp;lt;char32_t&amp;gt;&lt;/code&gt;(C++11)</source>
          <target state="translated">&lt;code&gt;char_traits&amp;lt;char32_t&amp;gt;&lt;/code&gt;(C++11)</target>
        </trans-unit>
        <trans-unit id="34589ff4f2cb873608e4f3a38668d00d2387c096" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;char_traits&amp;lt;char8_t&amp;gt;&lt;/code&gt;(C++20)</source>
          <target state="translated">&lt;code&gt;char_traits&amp;lt;char8_t&amp;gt;&lt;/code&gt;(C++20)</target>
        </trans-unit>
        <trans-unit id="bd37483306e249adabda089c75cf31326832d4e1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;chrono&lt;/code&gt; I/O</source>
          <target state="translated">&lt;code&gt;chrono&lt;/code&gt; ввод / вывод</target>
        </trans-unit>
        <trans-unit id="1a4855b8a75e7b38866fc680ea79de08951ccd36" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;cl&lt;/code&gt;, an object of type &lt;code&gt;X::char_class_type&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;cl&lt;/code&gt; , объект типа &lt;code&gt;X::char_class_type&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="57a18910b3fe4f7ebabccebcdfec1c594102f977" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;class-template-name&amp;lt;I&amp;gt;&lt;/code&gt;;</source>
          <target state="translated">&lt;code&gt;class-template-name&amp;lt;I&amp;gt;&lt;/code&gt;;</target>
        </trans-unit>
        <trans-unit id="447e41573e79eb660fb45e428d9831293a2bb516" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;class-template-name&amp;lt;T&amp;gt;&lt;/code&gt;;</source>
          <target state="translated">&lt;code&gt;class-template-name&amp;lt;T&amp;gt;&lt;/code&gt;;</target>
        </trans-unit>
        <trans-unit id="840262bf641c742885644a8867137b23e642ee04" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;clear&lt;/code&gt; invalidates all iterators and references. Because it erases all elements, this technically complies with the rules above.</source>
          <target state="translated">&lt;code&gt;clear&lt;/code&gt; делает недействительными все итераторы и ссылки. Поскольку он стирает все элементы, это технически соответствует приведенным выше правилам.</target>
        </trans-unit>
        <trans-unit id="40837755ab7959ccd1e6e1c575733ddfc3d086ce" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;close()&lt;/code&gt; is typically called through the destructor of &lt;code&gt;&lt;a href=&quot;../basic_filebuf&quot;&gt;std::basic_filebuf&lt;/a&gt;&lt;/code&gt; (which, in turn, is typically called by the destructor of &lt;code&gt;&lt;a href=&quot;../basic_fstream&quot;&gt;std::basic_fstream&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;close()&lt;/code&gt; обычно вызывается через деструктор &lt;code&gt;&lt;a href=&quot;../basic_filebuf&quot;&gt;std::basic_filebuf&lt;/a&gt;&lt;/code&gt; (который, в свою очередь, обычно вызывается деструктором &lt;code&gt;&lt;a href=&quot;../basic_fstream&quot;&gt;std::basic_fstream&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3d9dcf30735aeba307868d3b80bb591d9d12750b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;co_await&lt;/code&gt;expr</source>
          <target state="translated">&lt;code&gt;co_await&lt;/code&gt;expr</target>
        </trans-unit>
        <trans-unit id="b54d011270f4edc60c88fc86547fc85c84bfc825" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;co_return expr&lt;/code&gt; where expr has type void</source>
          <target state="translated">&lt;code&gt;co_return expr&lt;/code&gt; , где expr имеет тип void</target>
        </trans-unit>
        <trans-unit id="b6af45614986a085cc196762b62c12a486df7559" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;co_yield&lt;/code&gt;braced-init-list</source>
          <target state="translated">&lt;code&gt;co_yield&lt;/code&gt;braced-init-list</target>
        </trans-unit>
        <trans-unit id="95154f3d418ab26ed6d327edf5d5ebfec32b9c6e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;co_yield&lt;/code&gt;expr</source>
          <target state="translated">&lt;code&gt;co_yield&lt;/code&gt;expr</target>
        </trans-unit>
        <trans-unit id="6faca95322a3b3d33815965dd2f73dd6ccf68e98" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;common_type&amp;lt;int, int&amp;gt;::type&lt;/code&gt; is &lt;code&gt;int&amp;amp;&amp;amp;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;common_type&amp;lt;int, int&amp;gt;::type&lt;/code&gt; is &lt;code&gt;int&amp;amp;&amp;amp;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4e8493c1deebf8f0e11beacd2cc163a9d752492e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;common_type&lt;/code&gt; is not SFINAE-friendly</source>
          <target state="translated">&lt;code&gt;common_type&lt;/code&gt; не подходит для SFINAE</target>
        </trans-unit>
        <trans-unit id="64efe9a1bf02848912f9333dac7816a88d09c9cd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;common_type&lt;/code&gt; specializations are nearly impossible to write</source>
          <target state="translated">&lt;code&gt;common_type&lt;/code&gt; специализации общего_типа практически невозможно написать</target>
        </trans-unit>
        <trans-unit id="554fb3f88c0ecbe59bb9447e2022926cd7b08560" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;comp(lhs.first, rhs.first)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;comp(lhs.first, rhs.first)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2f2523d45a894bd83c166d7c2f86f45441c477dc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;comp&lt;/code&gt;, an object of type &lt;code&gt;T&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;comp&lt;/code&gt; , объект типа &lt;code&gt;T&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="cdf1059c5241ff6172285cce25a7e15b8a2a809d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;complex&lt;/code&gt;&amp;lt;float&amp;gt;&lt;code&gt;complex&lt;/code&gt;&amp;lt;double&amp;gt;&lt;code&gt;complex&lt;/code&gt;&amp;lt;long double&amp;gt;</source>
          <target state="translated">&lt;code&gt;complex&lt;/code&gt; &amp;lt;float&amp;gt; &lt;code&gt;complex&lt;/code&gt; &amp;lt;double&amp;gt; &lt;code&gt;complex&lt;/code&gt; &amp;lt;long double&amp;gt;</target>
        </trans-unit>
        <trans-unit id="26dc5a3ad5b984fe0791f4d98e3a2ae086ecdace" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;concept&lt;/code&gt;concept-name&lt;code&gt;=&lt;/code&gt;constraint-expression&lt;code&gt;;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;concept&lt;/code&gt;concept-name&lt;code&gt;=&lt;/code&gt;constraint-expression&lt;code&gt;;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="297480fbe0c371720393479054cc75c4eb9efe23" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;condition_variable&lt;/code&gt; is used in combination with a &lt;code&gt;&lt;a href=&quot;mutex&quot;&gt;std::mutex&lt;/a&gt;&lt;/code&gt; to facilitate inter-thread communication.</source>
          <target state="translated">&lt;code&gt;condition_variable&lt;/code&gt; используется в сочетании с &lt;code&gt;&lt;a href=&quot;mutex&quot;&gt;std::mutex&lt;/a&gt;&lt;/code&gt; для облегчения связи между потоками.</target>
        </trans-unit>
        <trans-unit id="ce602ea724c696fc4264247e3f5c11195508073e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;const T&amp;amp;&lt;/code&gt; otherwise (&lt;code&gt;It&lt;/code&gt; is constant),</source>
          <target state="translated">&lt;code&gt;const T&amp;amp;&lt;/code&gt; иначе ( &lt;code&gt;It&lt;/code&gt; постоянно),</target>
        </trans-unit>
        <trans-unit id="a996f39e93f402c926c96e8454425deb9f7fa668" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;const T*&lt;/code&gt; specialization member types</source>
          <target state="translated">&lt;code&gt;const T*&lt;/code&gt; типы членов специализации</target>
        </trans-unit>
        <trans-unit id="8ee674418aeb67071bc8ac00d898ea7ae954fdb3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;const char16_t[]&lt;/code&gt; or &lt;code&gt;const char32_t[]&lt;/code&gt;(since C++11)</source>
          <target state="translated">&lt;code&gt;const char16_t[]&lt;/code&gt; или &lt;code&gt;const char32_t[]&lt;/code&gt; (начиная с C ++ 11)</target>
        </trans-unit>
        <trans-unit id="66f567ad8c4304d5cdef87608b2a1af88972dada" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;const char8_t[]&lt;/code&gt;(since C++20)</source>
          <target state="translated">&lt;code&gt;const char8_t[]&lt;/code&gt; (начиная с C ++ 20)</target>
        </trans-unit>
        <trans-unit id="9eed69b60f79e50e3e0cbc5aa8f6736a3226f411" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;const char[]&lt;/code&gt; or &lt;code&gt;const wchar_t[]&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;const char[]&lt;/code&gt; или &lt;code&gt;const wchar_t[]&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6df32d7fb02903624617eb9d49776e35b4496ecc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;const int (* volatile S::* const)[20]&lt;/code&gt; and &lt;code&gt;int (* const S::* volatile)[20]&lt;/code&gt; are similar;</source>
          <target state="translated">&lt;code&gt;const int (* volatile S::* const)[20]&lt;/code&gt; и &lt;code&gt;int (* const S::* volatile)[20]&lt;/code&gt; похожи;</target>
        </trans-unit>
        <trans-unit id="47f8209f26f85dfd3a4a12e900c44507f02c23a0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;const int (*)(int *)&lt;/code&gt; and &lt;code&gt;int (*)(int *)&lt;/code&gt; are</source>
          <target state="translated">&lt;code&gt;const int (*)(int *)&lt;/code&gt; и &lt;code&gt;int (*)(int *)&lt;/code&gt; являются</target>
        </trans-unit>
        <trans-unit id="52508689cda680f3e3c998354c4471c1de258e53" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;const int * volatile *&lt;/code&gt; and &lt;code&gt;int * * const&lt;/code&gt; are similar;</source>
          <target state="translated">&lt;code&gt;const int * volatile *&lt;/code&gt; и &lt;code&gt;int * * const&lt;/code&gt; похожи;</target>
        </trans-unit>
        <trans-unit id="515e72e3784d234c7642a509460ae78aecf30768" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;const&lt;/code&gt; &amp;lt; &lt;code&gt;const volatile&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;const&lt;/code&gt; &amp;lt; &lt;code&gt;const volatile&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7ecbcb74ecd84607917d5d8459726b7ca1500a93" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;const&lt;/code&gt; - defines that the type is</source>
          <target state="translated">&lt;code&gt;const&lt;/code&gt; - определяет, что тип</target>
        </trans-unit>
        <trans-unit id="849523fe8ba7e5e307622eb0fcdc78dfb1857ae3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;const&lt;/code&gt; Object of type &lt;code&gt;X::hasher&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;const&lt;/code&gt; Объект типа &lt;code&gt;X::hasher&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="eb46134c57f52e5a5e9f17f34016e7e0dde21300" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;const&lt;/code&gt; Object of type &lt;code&gt;X::key_equal&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;const&lt;/code&gt; Объект типа &lt;code&gt;X::key_equal&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3b2f6157e9d655a9fd9e59e89ed7af589e05200b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;const&lt;/code&gt; Object of type &lt;code&gt;X&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;const&lt;/code&gt; Объект типа &lt;code&gt;X&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8fd4e9f1b889fc95d587a6ae498ab55f271be55b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;const&lt;/code&gt; type qualifier</source>
          <target state="translated">&lt;code&gt;const&lt;/code&gt; квалификатор типа const</target>
        </trans-unit>
        <trans-unit id="86870f391072bb2629fd0ebc05f5cc5f658c6111" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;const_cast &amp;lt;&lt;/code&gt;new_type&lt;code&gt;&amp;gt; (&lt;/code&gt;expression&lt;code&gt;)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;const_cast &amp;lt;&lt;/code&gt; new_type &lt;code&gt;&amp;gt; (&lt;/code&gt; выражение &lt;code&gt;)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4df3b2f2a6e041b66d00d0f4162026f7c6293554" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;const_cast&lt;/code&gt; conversion</source>
          <target state="translated">&lt;code&gt;const_cast&lt;/code&gt; преобразование const_cast</target>
        </trans-unit>
        <trans-unit id="73834da188aa4ff3291884a29d89d96fcef4eee4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;const_cast&lt;/code&gt; makes it possible to form a reference or pointer to non-const type that is actually referring to a &lt;a href=&quot;cv&quot;&gt;const object&lt;/a&gt; or a reference or pointer to non-volatile type that is actually referring to a &lt;a href=&quot;cv&quot;&gt;volatile object&lt;/a&gt;. Modifying a const object through a non-const access path and referring to a volatile object through a non-volatile &lt;a href=&quot;value_category#glvalue&quot;&gt;glvalue&lt;/a&gt; results in undefined behavior.</source>
          <target state="translated">&lt;code&gt;const_cast&lt;/code&gt; позволяет сформировать ссылку или указатель на неконстантный тип, который фактически ссылается на &lt;a href=&quot;cv&quot;&gt;объект const,&lt;/a&gt; или ссылку или указатель на энергонезависимый тип, который фактически ссылается на &lt;a href=&quot;cv&quot;&gt;энергозависимый объект&lt;/a&gt; . Изменение const-объекта через неконстантный путь доступа и обращение к энергозависимому объекту через энергонезависимое &lt;a href=&quot;value_category#glvalue&quot;&gt;glvalue&lt;/a&gt; приводит к неопределенному поведению.</target>
        </trans-unit>
        <trans-unit id="1b05714965760fefb084cefcc9d67a2e9e945860" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;const_iterator&lt;/code&gt; to the character following the last character.</source>
          <target state="translated">&lt;code&gt;const_iterator&lt;/code&gt; для символа, следующего за последним символом.</target>
        </trans-unit>
        <trans-unit id="ff3530967d52517c00cc586fba76e43e4a0a499f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;const_iterator&lt;/code&gt; to the first character.</source>
          <target state="translated">&lt;code&gt;const_iterator&lt;/code&gt; для первого символа.</target>
        </trans-unit>
        <trans-unit id="7a75a6dc00b537c7e4ccb590a1cf2062b47a7c48" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;const_pointer&lt;/code&gt;(deprecated in C++17)(removed in C++20)</source>
          <target state="translated">&lt;code&gt;const_pointer&lt;/code&gt; (устарело в C ++ 17) (удалено в C ++ 20)</target>
        </trans-unit>
        <trans-unit id="db5830dbbab3c9f6d28543e44b265d86291893a9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;const_reference&lt;/code&gt; for const a.</source>
          <target state="translated">&lt;code&gt;const_reference&lt;/code&gt; для const a.</target>
        </trans-unit>
        <trans-unit id="697d0afbfbbac7bcabba065341cb16898159a75d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;const_reference&lt;/code&gt;(deprecated in C++17)(removed in C++20)</source>
          <target state="translated">&lt;code&gt;const_reference&lt;/code&gt; (устарело в C ++ 17) (удалено в C ++ 20)</target>
        </trans-unit>
        <trans-unit id="f582d6a3965005d8ce7701813243bbd8179302b0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;const_reverse_iterator&lt;/code&gt; to the character following the last character.</source>
          <target state="translated">&lt;code&gt;const_reverse_iterator&lt;/code&gt; для символа, следующего за последним символом.</target>
        </trans-unit>
        <trans-unit id="d40cb8bf749e11876abefa1600db4e84ee627a91" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;const_reverse_iterator&lt;/code&gt; to the first character.</source>
          <target state="translated">&lt;code&gt;const_reverse_iterator&lt;/code&gt; для первого символа.</target>
        </trans-unit>
        <trans-unit id="997295cc2d3b4a33cc70ee37adc5f4933187cd57" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;consteval&lt;/code&gt; - specifies that a function is an</source>
          <target state="translated">&lt;code&gt;consteval&lt;/code&gt; - указывает, что функция является</target>
        </trans-unit>
        <trans-unit id="f174eb524209ad8a24d7788c23ab74fb724c4c41" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;consteval&lt;/code&gt;: specifies that the function call operator is an &lt;a href=&quot;consteval&quot;&gt;immediate function&lt;/a&gt;. &lt;code&gt;consteval&lt;/code&gt; and &lt;code&gt;constexpr&lt;/code&gt; cannot be used at the same time.</source>
          <target state="translated">&lt;code&gt;consteval&lt;/code&gt; : указывает, что оператор вызова функции является &lt;a href=&quot;consteval&quot;&gt;непосредственной функцией&lt;/a&gt; . &lt;code&gt;consteval&lt;/code&gt; и &lt;code&gt;constexpr&lt;/code&gt; не могут быть использованы одновременно.</target>
        </trans-unit>
        <trans-unit id="60390c6e7c6371a354f2d11599e1853f362f7b67" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;constexpr&lt;/code&gt; - specifies that the value of a variable or function can appear in &lt;a href=&quot;constant_expression&quot;&gt;constant expressions&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;constexpr&lt;/code&gt; - указывает, что значение переменной или функции может появляться в &lt;a href=&quot;constant_expression&quot;&gt;константных выражениях&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="cfd989462cbbec291a71037d602f200cc2b6115d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;constexpr&lt;/code&gt; function template returning the greatest common divisor of two integers</source>
          <target state="translated">&lt;code&gt;constexpr&lt;/code&gt; функции constexpr, возвращающий наибольший общий делитель двух целых</target>
        </trans-unit>
        <trans-unit id="66f79f40a4b87ef73a0f44c9587b2f9522b60936" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;constexpr&lt;/code&gt; function template returning the least common multiple of two integers</source>
          <target state="translated">&lt;code&gt;constexpr&lt;/code&gt; функции constexpr, возвращающий наименьшее общее кратное двух целых</target>
        </trans-unit>
        <trans-unit id="d48f275f501771bc35ea1b933c63b8ca18257d2f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;constexpr&lt;/code&gt; value of type &lt;code&gt;&lt;a href=&quot;../../types/integer&quot;&gt;std::intmax_t&lt;/a&gt;&lt;/code&gt; equal to &lt;code&gt;abs(Denom) / gcd(Num, Denom)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;constexpr&lt;/code&gt; Значение constexpr типа &lt;code&gt;&lt;a href=&quot;../../types/integer&quot;&gt;std::intmax_t&lt;/a&gt;&lt;/code&gt; равно &lt;code&gt;abs(Denom) / gcd(Num, Denom)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="78223edf07f451eab868f42e4d9bfd12755afd42" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;constexpr&lt;/code&gt; value of type &lt;code&gt;&lt;a href=&quot;../../types/integer&quot;&gt;std::intmax_t&lt;/a&gt;&lt;/code&gt; equal to &lt;code&gt;sign(Num) * sign(Denom) * abs(Num) / gcd(Num, Denom)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;constexpr&lt;/code&gt; Значение constexpr типа &lt;code&gt;&lt;a href=&quot;../../types/integer&quot;&gt;std::intmax_t&lt;/a&gt;&lt;/code&gt; равно &lt;code&gt;sign(Num) * sign(Denom) * abs(Num) / gcd(Num, Denom)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4239f3fafdcb184672789e0caaa9b1ac92caab06" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;constexpr&lt;/code&gt;: explicitly specifies that the function call operator is a &lt;a href=&quot;constexpr&quot;&gt;constexpr&lt;/a&gt; function. When this specifier is not present, the function call operator will be &lt;code&gt;constexpr&lt;/code&gt; anyway, if it happens to satisfy all constexpr function requirements</source>
          <target state="translated">&lt;code&gt;constexpr&lt;/code&gt; : явно указывает, что оператор вызова функции является функцией &lt;a href=&quot;constexpr&quot;&gt;constexpr&lt;/a&gt; . Когда этот спецификатор отсутствует, оператор вызова функции все равно будет &lt;code&gt;constexpr&lt;/code&gt; , если он удовлетворяет всем требованиям функции constexpr</target>
        </trans-unit>
        <trans-unit id="c21b845984d62717a898bcc9bb64709bf51e4868" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;container&lt;/code&gt;(protected member object)</source>
          <target state="translated">&lt;code&gt;container&lt;/code&gt; (объект защищенного члена)</target>
        </trans-unit>
        <trans-unit id="6d86df7b769f8c1634520185d4a68bac68fa2fb7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;container&lt;/code&gt;(protected)</source>
          <target state="translated">&lt;code&gt;container&lt;/code&gt;(protected)</target>
        </trans-unit>
        <trans-unit id="2ee4f7675766eb987c78ea16c7ca4abc8bedea9b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;contiguous_iterator_tag&lt;/code&gt; corresponds to &lt;a href=&quot;../named_req/contiguousiterator&quot;&gt;LegacyContiguousIterator&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;contiguous_iterator_tag&lt;/code&gt; соответствует к &lt;a href=&quot;../named_req/contiguousiterator&quot;&gt;LegacyContiguousIterator&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="99de603392e55955fac05bfba02c1711ee23a25b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;copy_options&lt;/code&gt; satisfies the requirements of &lt;a href=&quot;../named_req/bitmasktype&quot;&gt;BitmaskType&lt;/a&gt; (which means the bitwise operators &lt;code&gt;operator&amp;amp;&lt;/code&gt;, &lt;code&gt;operator|&lt;/code&gt;, &lt;code&gt;operator^&lt;/code&gt;, &lt;code&gt;operator~&lt;/code&gt;, &lt;code&gt;operator&amp;amp;=&lt;/code&gt;, &lt;code&gt;operator|=&lt;/code&gt;, and &lt;code&gt;operator^=&lt;/code&gt; are defined for this type). &lt;code&gt;none&lt;/code&gt; represents the empty bitmask; every other enumerator represents a distinct bitmask element.</source>
          <target state="translated">&lt;code&gt;copy_options&lt;/code&gt; удовлетворяет требованиям &lt;a href=&quot;../named_req/bitmasktype&quot;&gt;BitmaskType&lt;/a&gt; (что означает, что для этого типа определены побитовые операторы &lt;code&gt;operator&amp;amp;&lt;/code&gt; , &lt;code&gt;operator|&lt;/code&gt; , &lt;code&gt;operator^&lt;/code&gt; , &lt;code&gt;operator~&lt;/code&gt; , &lt;code&gt;operator&amp;amp;=&lt;/code&gt; , &lt;code&gt;operator|=&lt;/code&gt; и &lt;code&gt;operator^=&lt;/code&gt; ). &lt;code&gt;none&lt;/code&gt; представляет пустую битовую маску; любой другой перечислитель представляет отдельный элемент битовой маски.</target>
        </trans-unit>
        <trans-unit id="0e9c49a708a699991cfa76215085b76622684a55" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;copyfmt()&lt;/code&gt; may be used to save and restore the state of a stream. Boost provides a more fine-grained &lt;a href=&quot;http://www.boost.org/doc/libs/release/libs/io/doc/ios_state.html&quot;&gt;IO state savers&lt;/a&gt; library for the same purpose.</source>
          <target state="translated">&lt;code&gt;copyfmt()&lt;/code&gt; может использоваться для сохранения и восстановления состояния потока. Boost предоставляет более &lt;a href=&quot;http://www.boost.org/doc/libs/release/libs/io/doc/ios_state.html&quot;&gt;детальную&lt;/a&gt; библиотеку хранителей состояния ввода - вывода для той же цели.</target>
        </trans-unit>
        <trans-unit id="67284dc08863291b978ed366654a06f2dfc06c26" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;count-1&lt;/code&gt; characters have been extracted (in which case &lt;code&gt;setstate(failbit)&lt;/code&gt; is executed).</source>
          <target state="translated">&lt;code&gt;count-1&lt;/code&gt; символы count-1 были извлечены (в этом случае &lt;code&gt;setstate(failbit)&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="14c1d900f819911905383fbcb787713b7c0b5161" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;count-1&lt;/code&gt; characters have been stored</source>
          <target state="translated">&lt;code&gt;count-1&lt;/code&gt; символов 1 было сохранено</target>
        </trans-unit>
        <trans-unit id="4370421f845ed887052d082daed02d0e18096fda" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;count&lt;/code&gt; characters were extracted and stored</source>
          <target state="translated">&lt;code&gt;count&lt;/code&gt; символов было извлечено и сохранено</target>
        </trans-unit>
        <trans-unit id="574c30c0681bfef17be02cc120d42b90c22648db" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;count&lt;/code&gt; characters were extracted. This test is disabled in the special case when &lt;code&gt;count&lt;/code&gt; equals &lt;code&gt;&lt;a href=&quot;../../types/numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;&lt;a href=&quot;../streamsize&quot;&gt;std::streamsize&lt;/a&gt;&amp;gt;::max()&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;count&lt;/code&gt; символов было извлечено. Этот тест отключен в особом случае, когда &lt;code&gt;count&lt;/code&gt; равен &lt;code&gt;&lt;a href=&quot;../../types/numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;&lt;a href=&quot;../streamsize&quot;&gt;std::streamsize&lt;/a&gt;&amp;gt;::max()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1ac51d4b143d94e6de0cb20876eeda02db8ba0f4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;count&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;size&quot;&gt;size()&lt;/a&gt;&lt;/code&gt;&lt;code&gt; - index&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;count&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;size&quot;&gt;size()&lt;/a&gt;&lt;/code&gt; &lt;code&gt; - index&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2a25961a22949d5108d96f348e53bd2197bde8ae" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;cptr&lt;/code&gt;, a value of type &lt;code&gt;allocator_traits&amp;lt;A&amp;gt;::const_pointer&lt;/code&gt;, obtained by conversion from &lt;code&gt;ptr&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;cptr&lt;/code&gt; , значение типа &lt;code&gt;allocator_traits&amp;lt;A&amp;gt;::const_pointer&lt;/code&gt; , полученное преобразованием из &lt;code&gt;ptr&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e8df13a1dc06479e30c994b1d8c70e8b5752fc60" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;cs&lt;/code&gt;, an object of type &lt;code&gt;const X::string_type&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;cs&lt;/code&gt; , объект типа &lt;code&gt;const X::string_type&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="762b5aaed1848d4d32f2c16128b1af381c844d8b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;current&lt;/code&gt;(private)</source>
          <target state="translated">&lt;code&gt;current&lt;/code&gt;(private)</target>
        </trans-unit>
        <trans-unit id="ef5daddd507bab168de9ec7cde201b949b2a2274" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;current&lt;/code&gt;(protected)</source>
          <target state="translated">&lt;code&gt;current&lt;/code&gt;(protected)</target>
        </trans-unit>
        <trans-unit id="165cd74ab0314daa74559a33432202810671ce0d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;cv-list T&lt;/code&gt;;</source>
          <target state="translated">&lt;code&gt;cv-list T&lt;/code&gt; ;</target>
        </trans-unit>
        <trans-unit id="c0c4671227f8ea9a45bf577b5a7e4b537aeb1997" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;cvptr&lt;/code&gt;, a value of type &lt;code&gt;allocator_traits&amp;lt;A&amp;gt;::const_void_pointer&lt;/code&gt;, obtained by conversion from &lt;code&gt;cptr&lt;/code&gt; or from &lt;code&gt;vptr&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;cvptr&lt;/code&gt; , значение типа &lt;code&gt;allocator_traits&amp;lt;A&amp;gt;::const_void_pointer&lt;/code&gt; , полученное преобразованием из &lt;code&gt;cptr&lt;/code&gt; или из &lt;code&gt;vptr&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1cd93fe2dba1d9398c3a10408b3a9cc95efd41db" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;d.count()&lt;/code&gt; is formatted using the rules of &lt;code&gt;&lt;a href=&quot;../../string/basic_string/to_string&quot;&gt;std::to_string&lt;/a&gt;&lt;/code&gt;/&lt;code&gt;&lt;a href=&quot;../../string/basic_string/to_wstring&quot;&gt;std::to_wstring&lt;/a&gt;&lt;/code&gt;. In particular, if &lt;code&gt;Rep&lt;/code&gt; is a floating-point type, it is always formatted with 6 digits after the decimal point, and the number of significant digits in the resulting string may be zero if &lt;code&gt;d.count()&lt;/code&gt; is small.</source>
          <target state="translated">&lt;code&gt;d.count()&lt;/code&gt; форматируется с использованием правил &lt;code&gt;&lt;a href=&quot;../../string/basic_string/to_string&quot;&gt;std::to_string&lt;/a&gt;&lt;/code&gt; / &lt;code&gt;&lt;a href=&quot;../../string/basic_string/to_wstring&quot;&gt;std::to_wstring&lt;/a&gt;&lt;/code&gt; . В частности, если &lt;code&gt;Rep&lt;/code&gt; является типом с плавающей точкой, он всегда форматируется с 6 цифрами после десятичной точки, и число значащих цифр в результирующей строке может быть равно нулю, если &lt;code&gt;d.count()&lt;/code&gt; мало.</target>
        </trans-unit>
        <trans-unit id="651f9fdce67570503479d6ae44a4f63b5a121f00" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;d&lt;/code&gt; converted to a duration of type &lt;code&gt;ToDuration&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;d&lt;/code&gt; преобразуется в длительность типа &lt;code&gt;ToDuration&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3556a8cbed18d0c1515390f4058f1738c12097f7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;d&lt;/code&gt; rounded down to a duration of type &lt;code&gt;ToDuration&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;d&lt;/code&gt; округляется до продолжительности типа &lt;code&gt;ToDuration&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a0df75951e723a2a73f0a26e7b0f6523aabc62df" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;d&lt;/code&gt; rounded down to a the next time point using duration of type &lt;code&gt;ToDuration&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;d&lt;/code&gt; округляется до следующего момента времени с использованием длительности типа &lt;code&gt;ToDuration&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="91429683e5e5d73122930f863155680438d3cef5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;d&lt;/code&gt; rounded to nearest time point using duration of type &lt;code&gt;ToDuration&lt;/code&gt;, rounding to even in halfway cases.</source>
          <target state="translated">&lt;code&gt;d&lt;/code&gt; округляется до ближайшей временной точки с использованием длительности типа &lt;code&gt;ToDuration&lt;/code&gt; , округляя до четного в половине случаев.</target>
        </trans-unit>
        <trans-unit id="ddb5d33a92a03c56ccd48c588ed2837d58e323c7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;d&lt;/code&gt; rounded to the nearest duration of type &lt;code&gt;ToDuration&lt;/code&gt;, rounding to even in halfway cases.</source>
          <target state="translated">&lt;code&gt;d&lt;/code&gt; округляется до ближайшей длительности типа &lt;code&gt;ToDuration&lt;/code&gt; , округляя до четного в половине случаев.</target>
        </trans-unit>
        <trans-unit id="16443f163b0e6c80febceec5eec07385daff8273" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;d&lt;/code&gt; rounded up to a duration of type &lt;code&gt;ToDuration&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;d&lt;/code&gt; округляется до продолжительности типа &lt;code&gt;ToDuration&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ba1cb3758fcce4c43dfa0709d08b3a59b9056177" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;d&lt;/code&gt; rounded up to a the next time point using duration of type &lt;code&gt;ToDuration&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;d&lt;/code&gt; округляется до следующего момента времени, используя продолжительность типа &lt;code&gt;ToDuration&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="183399524adf86e2819866b426f01c7672820d48" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;d&lt;/code&gt;, a value of type &lt;code&gt;D&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;d&lt;/code&gt; , значение типа &lt;code&gt;D&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e3bb057ec0cff334c09022fc05ef1585e446c51a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;dangling&lt;/code&gt; is a placeholder type and an empty class type, used together with the template aliases &lt;a href=&quot;safe_iterator_t&quot;&gt;&lt;code&gt;ranges::safe_iterator_t&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;safe_iterator_t&quot;&gt;&lt;code&gt;ranges::safe_subrange_t&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;dangling&lt;/code&gt; - это тип заполнителя и пустой тип класса, используемый вместе с псевдонимами шаблонов &lt;a href=&quot;safe_iterator_t&quot;&gt; &lt;code&gt;ranges::safe_iterator_t&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;safe_iterator_t&quot;&gt; &lt;code&gt;ranges::safe_subrange_t&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="aeed77864ca001a76bddf2e2e61a40c1bd601eac" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;data() + i == &lt;a href=&quot;../../memory/addressof&quot;&gt;std::addressof&lt;/a&gt;(operator[](i))&lt;/code&gt; for every &lt;code&gt;i&lt;/code&gt; in &lt;code&gt;[0, size()]&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;data() + i == &lt;a href=&quot;../../memory/addressof&quot;&gt;std::addressof&lt;/a&gt;(operator[](i))&lt;/code&gt; для каждого &lt;code&gt;i&lt;/code&gt; в &lt;code&gt;[0, size()]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3078b7f1d4c80c1b110d86087c6a9c473662279e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;data()[i] == operator[](i)&lt;/code&gt; for every &lt;code&gt;i&lt;/code&gt; in &lt;code&gt;[0, size())&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;data()[i] == operator[](i)&lt;/code&gt; для каждого &lt;code&gt;i&lt;/code&gt; в &lt;code&gt;[0, size())&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bc8c38fa982e5b5987d2045d9f1de50971e21b72" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;day&lt;/code&gt; is a &lt;a href=&quot;../named_req/triviallycopyable&quot;&gt;TriviallyCopyable&lt;/a&gt;&lt;a href=&quot;../named_req/standardlayouttype&quot;&gt;StandardLayoutType&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;day&lt;/code&gt; - это &lt;a href=&quot;../named_req/triviallycopyable&quot;&gt;TriviallyCopyable &lt;/a&gt;&lt;a href=&quot;../named_req/standardlayouttype&quot;&gt;StandardLayoutType&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2c8d8959ca5d98560b564de242b2ff6597d0895e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;dd&lt;/code&gt; - 2-digit day of the month from &lt;code&gt;timeptr-&amp;gt;tm_mday&lt;/code&gt; as if printed by &lt;code&gt;sprintf&lt;/code&gt; using &lt;code&gt;%2d&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;dd&lt;/code&gt; - двузначный день месяца с &lt;code&gt;timeptr-&amp;gt;tm_mday&lt;/code&gt; , как если бы он был напечатан &lt;code&gt;sprintf&lt;/code&gt; с использованием &lt;code&gt;%2d&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3a4e33e259910ef0f388744164686b75a72316f3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;dd&lt;/code&gt; - the day of the month</source>
          <target state="translated">&lt;code&gt;dd&lt;/code&gt; - день месяца</target>
        </trans-unit>
        <trans-unit id="44934ee72f5258c4f8a1a82e0459ef6eff3639b0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;decay-copy(E)&lt;/code&gt; if the decayed type of &lt;code&gt;E&lt;/code&gt; models &lt;a href=&quot;view&quot;&gt;&lt;code&gt;View&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;decay-copy(E)&lt;/code&gt; если распавшийся тип &lt;code&gt;E&lt;/code&gt; моделирует &lt;a href=&quot;view&quot;&gt; &lt;code&gt;View&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="078d40eeb791c9eab2e7e15d623435c16b5089e9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;decltype (&lt;/code&gt;entity&lt;code&gt;)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;decltype (&lt;/code&gt; сущность &lt;code&gt;)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4cef2572a50bbbe02226f827cb2bf71f7ae07148" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;decltype (&lt;/code&gt;expression&lt;code&gt;)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;decltype (&lt;/code&gt; выражение &lt;code&gt;)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d07aaf3ec110725af7032c41e5d6408aa1442075" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;decltype(x)&lt;/code&gt;, where &lt;code&gt;x&lt;/code&gt; denotes a structured binding, names the</source>
          <target state="translated">&lt;code&gt;decltype(x)&lt;/code&gt; , где &lt;code&gt;x&lt;/code&gt; обозначает структурированную привязку, называет</target>
        </trans-unit>
        <trans-unit id="f1a653258ed2585cc60d039f08f1fbfbf13b7dbc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;decltype&lt;/code&gt; is useful when declaring types that are difficult or impossible to declare using standard notation, like lambda-related types or types that depend on template parameters.</source>
          <target state="translated">&lt;code&gt;decltype&lt;/code&gt; полезен при объявлении типов, которые трудно или невозможно объявить с использованием стандартных обозначений, таких как лямбда-типы или типы, которые зависят от параметров шаблона.</target>
        </trans-unit>
        <trans-unit id="07299d3502543191e52ab8611cc9e0f05b87eaa5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;decltype&lt;/code&gt; specifier</source>
          <target state="translated">&lt;code&gt;decltype&lt;/code&gt; спецификатор</target>
        </trans-unit>
        <trans-unit id="8084031d231829e0e18c517a74547421c9d48533" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;declval&lt;/code&gt; is commonly used in templates where acceptable template parameters may have no constructor in common, but have the same member function whose return type is needed.</source>
          <target state="translated">&lt;code&gt;declval&lt;/code&gt; обычно используется в шаблонах, где приемлемые параметры шаблона могут не иметь общего конструктора, но иметь ту же функцию-член, тип возвращаемого значения которой необходим.</target>
        </trans-unit>
        <trans-unit id="a6dc6c66ff444f92e9f64dbedde3409bfb1824a0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;dec|oct|hex&lt;/code&gt;. Useful for masking operations</source>
          <target state="translated">&lt;code&gt;dec|oct|hex&lt;/code&gt; . Полезно для маскировки</target>
        </trans-unit>
        <trans-unit id="cc2d34009345d5e40053315ffb025faba8832df1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;default_random_engine&lt;/code&gt;(C++11)</source>
          <target state="translated">&lt;code&gt;default_random_engine&lt;/code&gt;(C++11)</target>
        </trans-unit>
        <trans-unit id="fc940c3f86e149b6fb8a0ab49cbd0ccb714b4cb3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;default_searcher&lt;/code&gt; is &lt;a href=&quot;../../named_req/copyconstructible&quot;&gt;CopyConstructible&lt;/a&gt; and &lt;a href=&quot;../../named_req/copyassignable&quot;&gt;CopyAssignable&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;default_searcher&lt;/code&gt; - это &lt;a href=&quot;../../named_req/copyconstructible&quot;&gt;CopyConstructible&lt;/a&gt; и &lt;a href=&quot;../../named_req/copyassignable&quot;&gt;CopyAssignable&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="077c4a7145581b449d92305cc732ff815a9e69ee" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;delete&lt;/code&gt; expression</source>
          <target state="translated">&lt;code&gt;delete&lt;/code&gt; выражение</target>
        </trans-unit>
        <trans-unit id="9a58ce0460f67f92ccc8361cf11684a665c52292" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;delete&lt;/code&gt;&lt;code&gt;delete[]&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;delete&lt;/code&gt;&lt;code&gt;delete[]&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0ed5aed6aee0f8e724cb90f7e02d46ceb3dd3341" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;desired&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;desired&lt;/code&gt;.</target>
        </trans-unit>
        <trans-unit id="96fc1ef1f4ce59d38242b0f4733b4018c5e91675" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;dest&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;dest&lt;/code&gt;.</target>
        </trans-unit>
        <trans-unit id="9c3be877342461a62b3323a91353e1089ee314e5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;difference_type&lt;/code&gt; - a signed integer type that can be used to identify distance between iterators</source>
          <target state="translated">&lt;code&gt;difference_type&lt;/code&gt; - целочисленный тип со знаком, который можно использовать для определения расстояния между итераторами.</target>
        </trans-unit>
        <trans-unit id="8e8722abed6c9126adc03f7ab6341effd317dc53" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;difference_type&lt;/code&gt; is not defined in the primary &lt;code&gt;atomic&lt;/code&gt; template or in the partial specializations for &lt;code&gt;&lt;a href=&quot;../memory/shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../memory/weak_ptr&quot;&gt;std::weak_ptr&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;difference_type&lt;/code&gt; в &lt;code&gt;&lt;a href=&quot;../memory/weak_ptr&quot;&gt;std::weak_ptr&lt;/a&gt;&lt;/code&gt; не определена в первичном &lt;code&gt;atomic&lt;/code&gt; шаблоне или в частичных специализациях для &lt;code&gt;&lt;a href=&quot;../memory/shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&lt;/code&gt; и std :: weak_ptr .</target>
        </trans-unit>
        <trans-unit id="c64a0caf494dd72f874d22b68ca58c859f45ef02" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;difference_type&lt;/code&gt; is not defined in the primary &lt;code&gt;atomic_ref&lt;/code&gt; template.</source>
          <target state="translated">&lt;code&gt;difference_type&lt;/code&gt; в &lt;code&gt;atomic_ref&lt;/code&gt; не определена в первичном шаблоне atomic_ref .</target>
        </trans-unit>
        <trans-unit id="605f6727baefcb30f85c08791de23fffeae36f3b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;difference_type&lt;/code&gt;, the type denoted by &lt;code&gt;&lt;a href=&quot;../iterator/iterator_traits&quot;&gt;std::iterator_traits&lt;/a&gt;&amp;lt;It&amp;gt;::difference_type&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;difference_type&lt;/code&gt; , тип, обозначаемый как &lt;code&gt;&lt;a href=&quot;../iterator/iterator_traits&quot;&gt;std::iterator_traits&lt;/a&gt;&amp;lt;It&amp;gt;::difference_type&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="674eefb4052cba056071a4c1441d7ae046690b63" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;directory_iterator&lt;/code&gt; is a &lt;a href=&quot;../named_req/inputiterator&quot;&gt;LegacyInputIterator&lt;/a&gt; that iterates over the &lt;a href=&quot;directory_entry&quot;&gt;&lt;code&gt;directory_entry&lt;/code&gt;&lt;/a&gt; elements of a directory (but does not visit the subdirectories). The iteration order is unspecified, except that each directory entry is visited only once. The special pathnames dot and dot-dot are skipped.</source>
          <target state="translated">&lt;code&gt;directory_iterator&lt;/code&gt; является &lt;a href=&quot;../named_req/inputiterator&quot;&gt;LegacyInputIterator&lt;/a&gt; , что перебирает &lt;a href=&quot;directory_entry&quot;&gt; &lt;code&gt;directory_entry&lt;/code&gt; &lt;/a&gt; элементов каталога (но не посещает подкаталоги). Порядок итераций не указан, за исключением того, что каждая запись каталога посещается только один раз. Специальные пути и точка-точка пропускаются.</target>
        </trans-unit>
        <trans-unit id="829c4c4ce416288a27de4d058572b018eab9b490" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;directory_options&lt;/code&gt; satisfies the requirements of &lt;a href=&quot;../named_req/bitmasktype&quot;&gt;BitmaskType&lt;/a&gt; (which means the bitwise operators &lt;code&gt;operator&amp;amp;&lt;/code&gt;, &lt;code&gt;operator|&lt;/code&gt;, &lt;code&gt;operator^&lt;/code&gt;, &lt;code&gt;operator~&lt;/code&gt;, &lt;code&gt;operator&amp;amp;=&lt;/code&gt;, &lt;code&gt;operator|=&lt;/code&gt;, and &lt;code&gt;operator^=&lt;/code&gt; are defined for this type). &lt;code&gt;none&lt;/code&gt; represents the empty bitmask; every other enumerator represents a distinct bitmask element.</source>
          <target state="translated">&lt;code&gt;directory_options&lt;/code&gt; удовлетворяет требованиям &lt;a href=&quot;../named_req/bitmasktype&quot;&gt;BitmaskType&lt;/a&gt; (что означает, что для этого типа определены побитовые операторы &lt;code&gt;operator&amp;amp;&lt;/code&gt; , &lt;code&gt;operator|&lt;/code&gt; , &lt;code&gt;operator^&lt;/code&gt; , &lt;code&gt;operator~&lt;/code&gt; , &lt;code&gt;operator&amp;amp;=&lt;/code&gt; , &lt;code&gt;operator|=&lt;/code&gt; и &lt;code&gt;operator^=&lt;/code&gt; ). &lt;code&gt;none&lt;/code&gt; представляет пустую битовую маску; любой другой перечислитель представляет отдельный элемент битовой маски.</target>
        </trans-unit>
        <trans-unit id="2e930479c54dd2256429b8c01c0a013c61557767" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;discard_block_engine&lt;/code&gt; is a pseudo-random number generator adaptor that discards a certain amount of data produced by the base engine. From each block of size &lt;code&gt;P&lt;/code&gt; generated by the base engine, the adaptor keeps only &lt;code&gt;R&lt;/code&gt; numbers, discarding the rest.</source>
          <target state="translated">&lt;code&gt;discard_block_engine&lt;/code&gt; - адаптер генератора псевдослучайных чисел, который отбрасывает определенный объем данных, созданных базовым механизмом. Из каждого блока размера &lt;code&gt;P&lt;/code&gt; , сгенерированного базовым механизмом, адаптер сохраняет только числа &lt;code&gt;R&lt;/code&gt; , отбрасывая остальные.</target>
        </trans-unit>
        <trans-unit id="a7a9857b4458b10f76bad1287594cfca5be13bab" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;double&lt;/code&gt; value corresponding to the contents of &lt;code&gt;str&lt;/code&gt; on success. If the converted value falls out of range of the return type, the return value is undefined. If no conversion can be performed, &lt;code&gt;0.0&lt;/code&gt; is returned.</source>
          <target state="translated">&lt;code&gt;double&lt;/code&gt; значение, соответствующее содержимому &lt;code&gt;str&lt;/code&gt; в случае успеха. Если преобразованное значение выходит за пределы диапазона возвращаемого типа, возвращаемое значение не определено. Если преобразование не может быть выполнено, возвращается &lt;code&gt;0.0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e64f9f04e39c7e554c344fe1b8a940257bb356a8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;double&lt;/code&gt;(C++11)</source>
          <target state="translated">&lt;code&gt;double&lt;/code&gt;(C++11)</target>
        </trans-unit>
        <trans-unit id="0afff59ccefd7da74ebc53ac40b22ad894d74b4f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;duration&lt;/code&gt; to copy from</source>
          <target state="translated">&lt;code&gt;duration&lt;/code&gt; копирования</target>
        </trans-unit>
        <trans-unit id="4281bf65b65452c452d3ec6c674684e06dfd8cbe" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;dynamic_cast &amp;lt;&lt;/code&gt;new_type&lt;code&gt;&amp;gt; (&lt;/code&gt;expression&lt;code&gt;)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;dynamic_cast &amp;lt;&lt;/code&gt; new_type &lt;code&gt;&amp;gt; (&lt;/code&gt; выражение &lt;code&gt;)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8238dbb029f152a176f6c19d54b08e09c4978a6f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;dynamic_cast&lt;/code&gt; conversion</source>
          <target state="translated">&lt;code&gt;dynamic_cast&lt;/code&gt; преобразование</target>
        </trans-unit>
        <trans-unit id="093e05fc743668e8b3ebc73ef075855f8b635caa" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;dynamic_cast&lt;/code&gt; or &lt;code&gt;typeid&lt;/code&gt; expressions.</source>
          <target state="translated">&lt;code&gt;dynamic_cast&lt;/code&gt; или &lt;code&gt;typeid&lt;/code&gt; выражения.</target>
        </trans-unit>
        <trans-unit id="2253736d7af1b4fa986169ef0ac6ea784c56ac02" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;e, f&lt;/code&gt;, values of type &lt;code&gt;X::int_type&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;e, f&lt;/code&gt; , значения типа &lt;code&gt;X::int_type&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="78e0ec35ac993e5d463c1502149eaa544cbb4c65" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;e.get&amp;lt;i&amp;gt;()&lt;/code&gt;, if lookup for the identifier &lt;code&gt;get&lt;/code&gt; in the scope of &lt;code&gt;&lt;i&gt;E&lt;/i&gt;&lt;/code&gt; by class member access lookup finds at least one declaration that is a function template whose first template parameter is a non-type parameter</source>
          <target state="translated">&lt;code&gt;e.get&amp;lt;i&amp;gt;()&lt;/code&gt; , если поиск для идентификатора &lt;code&gt;get&lt;/code&gt; в объеме &lt;code&gt;&lt;i&gt;E&lt;/i&gt;&lt;/code&gt; от членов класса подстановок доступа находок по меньшей мере , одно объявления, которое шаблон функции которого первого шаблон параметр является параметром типа , не</target>
        </trans-unit>
        <trans-unit id="13cd5e6dd0d5f72fe829b7c9c3af3e1387fde400" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;e&lt;/code&gt; has an immediate subexpression that is potentially-throwing</source>
          <target state="translated">&lt;code&gt;e&lt;/code&gt; него есть непосредственное подвыражение, которое может быть</target>
        </trans-unit>
        <trans-unit id="198087d50eb4b71b3034a51e4177330cb59ef362" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;e&lt;/code&gt; if &lt;code&gt;X​::​eq_int_type(e, X​::​eof())&lt;/code&gt; is false</source>
          <target state="translated">&lt;code&gt;e&lt;/code&gt; , если &lt;code&gt;X​::​eq_int_type(e, X​::​eof())&lt;/code&gt; равно false</target>
        </trans-unit>
        <trans-unit id="81a63e0f7a1fa5d3862bbf48583450c2410bc4b2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;e&lt;/code&gt; if &lt;code&gt;e&lt;/code&gt; and</source>
          <target state="translated">&lt;code&gt;e&lt;/code&gt; если &lt;code&gt;e&lt;/code&gt; и</target>
        </trans-unit>
        <trans-unit id="e51930a3435e04d0b1af0277065a00be36f910ed" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;e&lt;/code&gt; is a &lt;a href=&quot;dynamic_cast&quot;&gt;dynamic_cast&lt;/a&gt; that casts a polymorphic reference type</source>
          <target state="translated">&lt;code&gt;e&lt;/code&gt; - это &lt;a href=&quot;dynamic_cast&quot;&gt;dynamic_cast,&lt;/a&gt; который приводит полиморфный ссылочный тип.</target>
        </trans-unit>
        <trans-unit id="cf1fdd68c9dc26bdf66120e899db55f937491e92" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;e&lt;/code&gt; is a &lt;a href=&quot;throw&quot;&gt;throw-expression&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;e&lt;/code&gt; это &lt;a href=&quot;throw&quot;&gt;выражение броска&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="4d29dcac31c9d9d957b9cab2b7e7b0595348049d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;e&lt;/code&gt; is a &lt;a href=&quot;typeid&quot;&gt;typeid&lt;/a&gt; expression applied to a dereferenced pointer to a polymorphic type</source>
          <target state="translated">&lt;code&gt;e&lt;/code&gt; является выражением &lt;a href=&quot;typeid&quot;&gt;typeid,&lt;/a&gt; примененным к разыменованному указателю на полиморфный тип</target>
        </trans-unit>
        <trans-unit id="8525600fecd6ad271a9b35fb4310321803537880" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;e&lt;/code&gt; is a function call to a</source>
          <target state="translated">&lt;code&gt;e&lt;/code&gt; является вызовом функции к</target>
        </trans-unit>
        <trans-unit id="83682ad848127e8d972825cf60b01a4d1ce26671" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;e&lt;/code&gt; makes an implicit call to a</source>
          <target state="translated">&lt;code&gt;e&lt;/code&gt; делает неявный вызов</target>
        </trans-unit>
        <trans-unit id="ad4ed26807ff3a1be89ef12864b69ad7937db687" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;e&lt;/code&gt; | &lt;code&gt;E&lt;/code&gt;exponent-sign(optional)digit-sequence</source>
          <target state="translated">&lt;code&gt;e&lt;/code&gt; | &lt;code&gt;E&lt;/code&gt; знак экспоненты (необязательно)</target>
        </trans-unit>
        <trans-unit id="bf415de3f3608ad294691f55bcab37fd2e95a1f6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;e&lt;/code&gt;, &lt;code&gt;E&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;e&lt;/code&gt; , &lt;code&gt;E&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e8f05f2ec9f57075c86ff42ec6032858ca5f430b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;e&lt;/code&gt;, a non-const value of type &lt;code&gt;E&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;e&lt;/code&gt; , неконстантное значение типа &lt;code&gt;E&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a60fb4aafcf27b03b577305dea2cefe453740828" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;element_type&lt;/code&gt; was not updated for array support</source>
          <target state="translated">&lt;code&gt;element_type&lt;/code&gt; не был обновлен для поддержки массива</target>
        </trans-unit>
        <trans-unit id="a98ac6d89c7ed950198f31905d6401942c23ed46" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;else&lt;/code&gt;statement-false</source>
          <target state="translated">&lt;code&gt;else&lt;/code&gt;statement-false</target>
        </trans-unit>
        <trans-unit id="7a16baeb5992329a7fbbccf120a1ee402b84130c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;emplace&lt;/code&gt; returned &lt;code&gt;reference&lt;/code&gt;, breaking compatibility with pre-C++17 containers</source>
          <target state="translated">&lt;code&gt;emplace&lt;/code&gt; возвращает &lt;code&gt;reference&lt;/code&gt; , нарушая совместимость с контейнерами до C ++ 17</target>
        </trans-unit>
        <trans-unit id="db6a754161971e2f16d66f027bb5654e3ebcb03b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;empty_view&lt;/code&gt; does not reference any element.</source>
          <target state="translated">&lt;code&gt;empty_view&lt;/code&gt; не ссылается ни на один элемент.</target>
        </trans-unit>
        <trans-unit id="f64e8ad0206e4e3d2f71704519756ca7cefcee0a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;empty_view&lt;/code&gt; is always empty.</source>
          <target state="translated">&lt;code&gt;empty_view&lt;/code&gt; всегда пусто</target>
        </trans-unit>
        <trans-unit id="8f61ebafa708b9099b0bae824de3758d80065782" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;enable_shared_from_this&lt;/code&gt; provides the safe alternative to an expression like &lt;code&gt;&lt;a href=&quot;shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&amp;lt;T&amp;gt;(this)&lt;/code&gt;, which is likely to result in &lt;code&gt;this&lt;/code&gt; being destructed more than once by multiple owners that are unaware of each other (see example below).</source>
          <target state="translated">&lt;code&gt;enable_shared_from_this&lt;/code&gt; предоставляет безопасную альтернативу выражению типа &lt;code&gt;&lt;a href=&quot;shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&amp;lt;T&amp;gt;(this)&lt;/code&gt; , что может привести к &lt;code&gt;this&lt;/code&gt; что это будет уничтожено более одного раза несколькими владельцами, которые не знают друг друга (см. пример ниже).</target>
        </trans-unit>
        <trans-unit id="7fc22c384dd5d5d6c09837f18ec1281990d0f5b1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;enum&lt;/code&gt;&lt;code&gt;struct|class&lt;/code&gt;name&lt;code&gt;:&lt;/code&gt;type&lt;code&gt;; &lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;enum&lt;/code&gt;&lt;code&gt;struct|class&lt;/code&gt;name&lt;code&gt;:&lt;/code&gt;type&lt;code&gt;; &lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a69f14aaeaeff8576804f56671474ae6698e5614" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;enum&lt;/code&gt;&lt;code&gt;struct|class&lt;/code&gt;name&lt;code&gt;:&lt;/code&gt;type&lt;code&gt;{&lt;/code&gt;enumerator&lt;code&gt;=&lt;/code&gt;constexpr&lt;code&gt;,&lt;/code&gt;enumerator&lt;code&gt;=&lt;/code&gt;constexpr&lt;code&gt;,&lt;/code&gt; ... &lt;code&gt;} &lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;enum&lt;/code&gt; &lt;code&gt;struct|class&lt;/code&gt; имя класса &lt;code&gt;:&lt;/code&gt; type &lt;code&gt;{&lt;/code&gt; enumerator &lt;code&gt;=&lt;/code&gt; constexpr &lt;code&gt;,&lt;/code&gt; enumerator &lt;code&gt;=&lt;/code&gt; constexpr &lt;code&gt;,&lt;/code&gt; ... &lt;code&gt;} &lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="589810a338b7c285afc57b48cd8c15059b5cd3d7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;enum&lt;/code&gt;&lt;code&gt;struct|class&lt;/code&gt;name&lt;code&gt;; &lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;enum&lt;/code&gt;&lt;code&gt;struct|class&lt;/code&gt;name&lt;code&gt;; &lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8169dce7fb17d2a667303f95f69ac650aef23654" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;enum&lt;/code&gt;&lt;code&gt;struct|class&lt;/code&gt;name&lt;code&gt;{&lt;/code&gt;enumerator&lt;code&gt;=&lt;/code&gt;constexpr&lt;code&gt;,&lt;/code&gt;enumerator&lt;code&gt;=&lt;/code&gt;constexpr&lt;code&gt;,&lt;/code&gt; ... &lt;code&gt;} &lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;enum&lt;/code&gt; &lt;code&gt;struct|class&lt;/code&gt; перечисления | имя класса &lt;code&gt;{&lt;/code&gt; enumerator &lt;code&gt;=&lt;/code&gt; constexpr &lt;code&gt;,&lt;/code&gt; enumerator &lt;code&gt;=&lt;/code&gt; constexpr &lt;code&gt;,&lt;/code&gt; ... &lt;code&gt;} &lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="043981be691aaad7b9a1ca4f78e0ad8575dc953f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;enum&lt;/code&gt;enum-name</source>
          <target state="translated">&lt;code&gt;enum&lt;/code&gt;enum-name</target>
        </trans-unit>
        <trans-unit id="78e25eedb0b1c8ae6d4fd5f14224be78a0b6d564" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;enum&lt;/code&gt;name&lt;code&gt;:&lt;/code&gt;type&lt;code&gt;; &lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;enum&lt;/code&gt;name&lt;code&gt;:&lt;/code&gt;type&lt;code&gt;; &lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3a3de75a82c3a17e225e1e38842fc1d21aac4f9f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;enum&lt;/code&gt;name&lt;code&gt;:&lt;/code&gt;type&lt;code&gt;{&lt;/code&gt;enumerator&lt;code&gt;=&lt;/code&gt;constexpr&lt;code&gt;,&lt;/code&gt;enumerator&lt;code&gt;=&lt;/code&gt;constexpr&lt;code&gt;,&lt;/code&gt; ... &lt;code&gt;} &lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;enum&lt;/code&gt; имя enum &lt;code&gt;:&lt;/code&gt; type &lt;code&gt;{&lt;/code&gt; enumerator &lt;code&gt;=&lt;/code&gt; constexpr &lt;code&gt;,&lt;/code&gt; enumerator &lt;code&gt;=&lt;/code&gt; constexpr &lt;code&gt;,&lt;/code&gt; ... &lt;code&gt;} &lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b76682da4f8719096619c21f6aabdb2802794357" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;enum&lt;/code&gt;name&lt;code&gt;{&lt;/code&gt;enumerator&lt;code&gt;=&lt;/code&gt;constexpr&lt;code&gt;,&lt;/code&gt;enumerator&lt;code&gt;=&lt;/code&gt;constexpr&lt;code&gt;,&lt;/code&gt; ... &lt;code&gt;} &lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;enum&lt;/code&gt; name &lt;code&gt;{&lt;/code&gt; enumerator &lt;code&gt;=&lt;/code&gt; constexpr &lt;code&gt;,&lt;/code&gt; enumerator &lt;code&gt;=&lt;/code&gt; constexpr &lt;code&gt;,&lt;/code&gt; ... &lt;code&gt;} &lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c1ac6f2f35c9b33160a889afd00ee4f0971d409f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;equiv(a, b)&lt;/code&gt;, an expression equivalent to &lt;code&gt;!comp(a, b) &amp;amp;&amp;amp;&amp;nbsp;!comp(b, a)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;equiv(a, b)&lt;/code&gt; , выражение, эквивалентное &lt;code&gt;!comp(a, b) &amp;amp;&amp;amp;&amp;nbsp;!comp(b, a)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="83d7e0123adf6d55ac6129b2b5f6fb366d57c0f4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;errno&lt;/code&gt; is a preprocessor macro used for error indication. It expands to a  static(until C++11) thread-local(since C++11) modifiable lvalue of type &lt;code&gt;int&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;errno&lt;/code&gt; - макрос препроцессора, используемый для индикации ошибок. Он расширяется до статического (до C ++ 11) локально изменяемого потока (начиная с C ++ 11) lvalue типа &lt;code&gt;int&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a1f077484b7276f5bff23fb2d6f374ac5ee833cd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;errnum&lt;/code&gt; is usually acquired from the &lt;code&gt;errno&lt;/code&gt; variable, however the function accepts any value of type &lt;code&gt;int&lt;/code&gt;. The contents of the string are locale-specific.</source>
          <target state="translated">&lt;code&gt;errnum&lt;/code&gt; обычно получается из переменной &lt;code&gt;errno&lt;/code&gt; , однако функция принимает любое значение типа &lt;code&gt;int&lt;/code&gt; . Содержимое строки зависит от локали.</target>
        </trans-unit>
        <trans-unit id="54efe898b5fea0cd8bb94f7f5aa8270dfa1b9f16" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;error_code&lt;/code&gt; overload marked noexcept but can allocate memory</source>
          <target state="translated">&lt;code&gt;error_code&lt;/code&gt; Перегрузка error_code помечена как noexcept, но может выделить память</target>
        </trans-unit>
        <trans-unit id="27bd9b6f4c75a94e86d00cda519a354a4f72f2b3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;error_code&lt;/code&gt; overload of &lt;code&gt;create_directories&lt;/code&gt; marked noexcept but can allocate memory</source>
          <target state="translated">&lt;code&gt;error_code&lt;/code&gt; Перегрузка error_code для &lt;code&gt;create_directories&lt;/code&gt; помечена как noexcept, но может выделить память</target>
        </trans-unit>
        <trans-unit id="52cfd267d1fb93da1a4aedefd71b8e743dbda303" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;error_code&lt;/code&gt; overload of &lt;code&gt;remove_all&lt;/code&gt; marked noexcept but can allocate memory</source>
          <target state="translated">&lt;code&gt;error_code&lt;/code&gt; Перегрузка error_code для &lt;code&gt;remove_all&lt;/code&gt; помечена как noexcept, но может выделить память</target>
        </trans-unit>
        <trans-unit id="5c11ebc0c34134b531bb8050773b25db71f2c59f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;explicit (&lt;/code&gt;expression&lt;code&gt;) &lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;explicit (&lt;/code&gt; выражение &lt;code&gt;) &lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="af93d7f007d90bd5aca4c45c10991cb3a8b1a37c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;explicit&lt;/code&gt;(optional)template-name&lt;code&gt;( &lt;/code&gt;parameter-declaration-clause&lt;code&gt;)&lt;/code&gt;&lt;code&gt;-&amp;gt;&lt;/code&gt;simple-template-id&lt;code&gt;;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;explicit&lt;/code&gt; (необязательное) имя шаблона &lt;code&gt;( &lt;/code&gt; параметр-объявление-предложение &lt;code&gt;)&lt;/code&gt; &lt;code&gt;-&amp;gt;&lt;/code&gt; простой-шаблон-идентификатор &lt;code&gt;;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6fdfdc1de971bdf143d06485bfdc02c7e978ef52" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;explicit&lt;/code&gt;&lt;code&gt;operator&lt;/code&gt;conversion-type-id</source>
          <target state="translated">&lt;code&gt;explicit&lt;/code&gt;&lt;code&gt;operator&lt;/code&gt;conversion-type-id</target>
        </trans-unit>
        <trans-unit id="c3138f3333aae641d3bfc8fedd2f306d422041a0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;export&lt;/code&gt; was an optional modifier which declared the template as</source>
          <target state="translated">&lt;code&gt;export&lt;/code&gt; был необязательным модификатором, который объявил шаблон как</target>
        </trans-unit>
        <trans-unit id="36220c85ab9a339c91c5e30ceb71a2e4c11f8b6e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;export&lt;/code&gt; { declaration-seq(optional) }</source>
          <target state="translated">&lt;code&gt;export&lt;/code&gt; {объявление-seq (необязательно)}</target>
        </trans-unit>
        <trans-unit id="8b62da7283d4c3b18d849cfca6b3d95e1ce92809" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;export&lt;/code&gt;(optional)&lt;code&gt;import&lt;/code&gt;header-nameattribute-specifier-seq(optional);</source>
          <target state="translated">&lt;code&gt;export&lt;/code&gt;(optional)&lt;code&gt;import&lt;/code&gt;header-nameattribute-specifier-seq(optional);</target>
        </trans-unit>
        <trans-unit id="44f4c7ad0f040b74172a809e6d3fb94b2b5dc37b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;export&lt;/code&gt;(optional)&lt;code&gt;import&lt;/code&gt;module-nameattribute-specifier-seq(optional);</source>
          <target state="translated">&lt;code&gt;export&lt;/code&gt;(optional)&lt;code&gt;import&lt;/code&gt;module-nameattribute-specifier-seq(optional);</target>
        </trans-unit>
        <trans-unit id="1f2bebbcbecabffc8bc29480848d5e366f08c912" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;export&lt;/code&gt;(optional)&lt;code&gt;import&lt;/code&gt;module-partitionattribute-specifier-seq(optional);</source>
          <target state="translated">&lt;code&gt;export&lt;/code&gt;(optional)&lt;code&gt;import&lt;/code&gt;module-partitionattribute-specifier-seq(optional);</target>
        </trans-unit>
        <trans-unit id="54d67f80550db94cc293c103d3fc4f35bdb0a8e5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;export&lt;/code&gt;(optional)&lt;code&gt;module&lt;/code&gt;module-namemodule-partition(optional)attribute-specifier-seq(optional);</source>
          <target state="translated">&lt;code&gt;export&lt;/code&gt;(optional)&lt;code&gt;module&lt;/code&gt;module-namemodule-partition(optional)attribute-specifier-seq(optional);</target>
        </trans-unit>
        <trans-unit id="9d8980fe83d7975c2646da89d015605fc7f980e4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;export&lt;/code&gt;&lt;code&gt;template&lt;/code&gt;&lt;code&gt;&amp;lt;&lt;/code&gt;parameter-list&lt;code&gt;&amp;gt;&lt;/code&gt;class-declaration</source>
          <target state="translated">&lt;code&gt;export&lt;/code&gt;&lt;code&gt;template&lt;/code&gt;&lt;code&gt;&amp;lt;&lt;/code&gt;parameter-list&lt;code&gt;&amp;gt;&lt;/code&gt;class-declaration</target>
        </trans-unit>
        <trans-unit id="07ebce777588c91477930df782fcb0bca3595580" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;export&lt;/code&gt;&lt;code&gt;template&lt;/code&gt;&lt;code&gt;&amp;lt;&lt;/code&gt;parameter-list&lt;code&gt;&amp;gt;&lt;/code&gt;declaration</source>
          <target state="translated">&lt;code&gt;export&lt;/code&gt;&lt;code&gt;template&lt;/code&gt;&lt;code&gt;&amp;lt;&lt;/code&gt;parameter-list&lt;code&gt;&amp;gt;&lt;/code&gt;declaration</target>
        </trans-unit>
        <trans-unit id="485ef5eb58313ba3ac975a24caf194cd959679c2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;export&lt;/code&gt;&lt;code&gt;template&lt;/code&gt;&lt;code&gt;&amp;lt;&lt;/code&gt;parameter-list&lt;code&gt;&amp;gt;&lt;/code&gt;function-declaration</source>
          <target state="translated">&lt;code&gt;export&lt;/code&gt;&lt;code&gt;template&lt;/code&gt;&lt;code&gt;&amp;lt;&lt;/code&gt;parameter-list&lt;code&gt;&amp;gt;&lt;/code&gt;function-declaration</target>
        </trans-unit>
        <trans-unit id="5388f146e02862bb30e5065eb61d15826ff0e267" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;export&lt;/code&gt;declaration</source>
          <target state="translated">&lt;code&gt;export&lt;/code&gt;declaration</target>
        </trans-unit>
        <trans-unit id="7454445cf39c47030674769c03a1878c2bc9d18a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;extern &quot;C&quot;&lt;/code&gt; makes it possible to include header files containing declarations of C library functions in a C++ program, but if the same header file is shared with a C program, &lt;code&gt;extern &quot;C&quot;&lt;/code&gt; (which is not allowed in C) must be hidden with an appropriate &lt;a href=&quot;../preprocessor/conditional&quot;&gt;&lt;code&gt; #ifdef&lt;/code&gt;&lt;/a&gt;, typically &lt;a href=&quot;../preprocessor/replace#Predefined_macros&quot;&gt;&lt;code&gt;__cplusplus&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">&lt;code&gt;extern &quot;C&quot;&lt;/code&gt; позволяет включать заголовочные файлы, содержащие объявления функций библиотеки C, в программу C ++, но если тот же файл заголовков используется совместно с программой C, &lt;code&gt;extern &quot;C&quot;&lt;/code&gt; (что не разрешено в C) должен быть скрыт с соответствующим &lt;a href=&quot;../preprocessor/conditional&quot;&gt; &lt;code&gt; #ifdef&lt;/code&gt; &lt;/a&gt; , обычно &lt;a href=&quot;../preprocessor/replace#Predefined_macros&quot;&gt; &lt;code&gt;__cplusplus&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="049b4bcce0935dea35ed60c4ae97bc6e867a7fbc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;extern&lt;/code&gt; -</source>
          <target state="translated">&lt;code&gt;extern&lt;/code&gt; -</target>
        </trans-unit>
        <trans-unit id="5d9a515d675b4e07c00fbc73882cc1c3629012a1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;extern&lt;/code&gt;&lt;code&gt;template&lt;/code&gt;&lt;code&gt;class|struct&lt;/code&gt;template-name&lt;code&gt;&amp;lt;&lt;/code&gt;argument-list&lt;code&gt;&amp;gt;&amp;nbsp;;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;extern&lt;/code&gt;&lt;code&gt;template&lt;/code&gt;&lt;code&gt;class|struct&lt;/code&gt;template-name&lt;code&gt;&amp;lt;&lt;/code&gt;argument-list&lt;code&gt;&amp;gt;&amp;nbsp;;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c255b2cff76b9eb52459bd30442e96150366823c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;extern&lt;/code&gt;&lt;code&gt;template&lt;/code&gt;return-typename&lt;code&gt;&amp;lt;&lt;/code&gt;argument-list&lt;code&gt;&amp;gt;&lt;/code&gt;&lt;code&gt;(&lt;/code&gt;parameter-list&lt;code&gt;)&lt;/code&gt;&lt;code&gt;;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;extern&lt;/code&gt;&lt;code&gt;template&lt;/code&gt;return-typename&lt;code&gt;&amp;lt;&lt;/code&gt;argument-list&lt;code&gt;&amp;gt;&lt;/code&gt;&lt;code&gt;(&lt;/code&gt;parameter-list&lt;code&gt;)&lt;/code&gt;&lt;code&gt;;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1d908e2a396ade66d08b92dca3ffcf19d34c78fe" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;extern&lt;/code&gt;&lt;code&gt;template&lt;/code&gt;return-typename&lt;code&gt;(&lt;/code&gt;parameter-list&lt;code&gt;)&lt;/code&gt;&lt;code&gt;;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;extern&lt;/code&gt;&lt;code&gt;template&lt;/code&gt;return-typename&lt;code&gt;(&lt;/code&gt;parameter-list&lt;code&gt;)&lt;/code&gt;&lt;code&gt;;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="32e0da78131b0ea3faae80e66e7e23d4d6149a24" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;extern&lt;/code&gt;string-literal&lt;code&gt;{&lt;/code&gt;declaration-seq(optional)&lt;code&gt;} &lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;extern&lt;/code&gt;string-literal&lt;code&gt;{&lt;/code&gt;declaration-seq(optional)&lt;code&gt;} &lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="69209b29e1cf199dca3645be1461d158b2a2cfac" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;extern&lt;/code&gt;string-literaldeclaration</source>
          <target state="translated">&lt;code&gt;extern&lt;/code&gt;string-literaldeclaration</target>
        </trans-unit>
        <trans-unit id="f78ec137a973c5ec3dc121582762566259b3af91" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;f F&lt;/code&gt; defines &lt;code&gt;float&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;f F&lt;/code&gt; определяет &lt;code&gt;float&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="03c25b2fab4161ce3c2fbc787a8d6582f759cce7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;f&lt;/code&gt;, &lt;code&gt;F&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;f&lt;/code&gt; , &lt;code&gt;F&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="cad38087acf499649711df7384c393d972c26c38" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;f&lt;/code&gt;, a value of type &lt;code&gt;T&lt;/code&gt; or &lt;code&gt;const T&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;f&lt;/code&gt; , значение типа &lt;code&gt;T&lt;/code&gt; или &lt;code&gt;const T&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="847bf2a4954a4921538a67def8856f447eab86eb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;f&lt;/code&gt;, an object of type &lt;code&gt;T&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;f&lt;/code&gt; , объект типа &lt;code&gt;T&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3e8a397a92f1dba996055e94aedcf5d5313672bd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;false&lt;/code&gt; (the match prefix is empty)</source>
          <target state="translated">&lt;code&gt;false&lt;/code&gt; (префикс совпадения пуст)</target>
        </trans-unit>
        <trans-unit id="fc85e8617ab3828a493182ef70f7ed80805532e2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;false&lt;/code&gt; (the match suffix is empty)</source>
          <target state="translated">&lt;code&gt;false&lt;/code&gt; (суффикс совпадения пуст)</target>
        </trans-unit>
        <trans-unit id="61de516f32c260e7f5fe5a90b1537cd8a9f50ba3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;false&lt;/code&gt; if &lt;code&gt;v&lt;/code&gt; is &lt;code&gt;equivalent&lt;/code&gt; or &lt;code&gt;equal&lt;/code&gt;, and &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;v&lt;/code&gt; is &lt;code&gt;nonequivalent&lt;/code&gt; or &lt;code&gt;nonequal&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;false&lt;/code&gt; , если &lt;code&gt;v&lt;/code&gt; является &lt;code&gt;equivalent&lt;/code&gt; или &lt;code&gt;equal&lt;/code&gt; , и &lt;code&gt;true&lt;/code&gt; , если &lt;code&gt;v&lt;/code&gt; является &lt;code&gt;nonequivalent&lt;/code&gt; или &lt;code&gt;nonequal&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="08f8613034a79e75a5eb4f9cacdde2bd87f6dad6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;false&lt;/code&gt; if &lt;code&gt;v&lt;/code&gt; is &lt;code&gt;equivalent&lt;/code&gt;, and &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;v&lt;/code&gt; is &lt;code&gt;nonequivalent&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;false&lt;/code&gt; , если &lt;code&gt;v&lt;/code&gt; является &lt;code&gt;equivalent&lt;/code&gt; , и &lt;code&gt;true&lt;/code&gt; , если &lt;code&gt;v&lt;/code&gt; является &lt;code&gt;nonequivalent&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e3f984d543664578f98b0890dc56486ff61a964e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;false&lt;/code&gt; if &lt;code&gt;value() == 0&lt;/code&gt;, &lt;code&gt;true&lt;/code&gt; otherwise.</source>
          <target state="translated">&lt;code&gt;false&lt;/code&gt; если &lt;code&gt;value() == 0&lt;/code&gt; , в противном случае - &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="12593eb094b85fbe61ac28dd575bb8383436e121" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;file_clock&lt;/code&gt; meets the &lt;a href=&quot;../named_req/trivialclock&quot;&gt;TrivialClock&lt;/a&gt; requirements.</source>
          <target state="translated">&lt;code&gt;file_clock&lt;/code&gt; соответствует требованиям &lt;a href=&quot;../named_req/trivialclock&quot;&gt;TrivialClock&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="416ddf4cf02b3239ae22a62374699393ea1dfa24" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;file_clock&lt;/code&gt; provides exactly one of the following two pairs of static member functions:</source>
          <target state="translated">&lt;code&gt;file_clock&lt;/code&gt; предоставляет ровно одну из следующих двух пар статических функций-членов:</target>
        </trans-unit>
        <trans-unit id="861ae764ff85f053ef94bbe86ba1da8f51ed8538" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;file_type&lt;/code&gt; defines constants that indicate a type of a file or directory a path refers to. The value of the enumerators are distinct.</source>
          <target state="translated">&lt;code&gt;file_type&lt;/code&gt; определяет константы, которые указывают тип файла или каталога, к которому относится путь. Значения перечислителей различны.</target>
        </trans-unit>
        <trans-unit id="315f3972bbf217124d728f85cd82f43338739a74" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;filename&lt;/code&gt; if &lt;code&gt;filename&lt;/code&gt; was not &lt;code&gt;&lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt;. Otherwise a pointer to an internal static buffer is returned. If no suitable filename can be generated, &lt;code&gt;&lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt; is returned.</source>
          <target state="translated">&lt;code&gt;filename&lt;/code&gt; если &lt;code&gt;filename&lt;/code&gt; не было &lt;code&gt;&lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt; . В противном случае возвращается указатель на внутренний статический буфер. Если подходящее имя файла не может быть сгенерировано, возвращается &lt;code&gt;&lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2f0a388ea10d5b4afdd683236395d3f162dab456" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;filter_view&lt;/code&gt; models the concepts &lt;a href=&quot;bidirectionalrange&quot;&gt;&lt;code&gt;BidirectionalRange&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;forwardrange&quot;&gt;&lt;code&gt;ForwardRange&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;inputrange&quot;&gt;&lt;code&gt;InputRange&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;commonrange&quot;&gt;&lt;code&gt;CommonRange&lt;/code&gt;&lt;/a&gt; when the underlying view &lt;code&gt;V&lt;/code&gt; models respective concepts.</source>
          <target state="translated">&lt;code&gt;filter_view&lt;/code&gt; моделирует концепции &lt;a href=&quot;bidirectionalrange&quot;&gt; &lt;code&gt;BidirectionalRange&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;forwardrange&quot;&gt; &lt;code&gt;ForwardRange&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;inputrange&quot;&gt; &lt;code&gt;InputRange&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;commonrange&quot;&gt; &lt;code&gt;CommonRange&lt;/code&gt; ,&lt;/a&gt; когда базовое представление &lt;code&gt;V&lt;/code&gt; моделирует соответствующие концепции.</target>
        </trans-unit>
        <trans-unit id="f37f86eed243731ca29e87bcda6f57b2623cc211" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;final&lt;/code&gt; is an identifier with a special meaning when used in a member function declaration or class head. In other contexts it is not reserved and may be used to name objects and functions.</source>
          <target state="translated">&lt;code&gt;final&lt;/code&gt; - это идентификатор со специальным значением, когда он используется в объявлении функции-члена или заголовке класса. В других контекстах он не зарезервирован и может использоваться для именования объектов и функций.</target>
        </trans-unit>
        <trans-unit id="15f3cf2d47658fb9c7978dd6f9d53f3eadb64eb5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;first + n&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;first + n&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="46a34ea218c9e779e94050c713fd1986d0e4aba1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;first&lt;/code&gt; may be equal to &lt;code&gt;d_first&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;first&lt;/code&gt; может быть равен &lt;code&gt;d_first&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="60a99992dd9908440e59e9e2f9f3db563bb373c8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;first&lt;/code&gt;, &lt;code&gt;second&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;first&lt;/code&gt; , &lt;code&gt;second&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="518c95550251b1dce01e670f8e121ae364e26a6f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;first_argument_type&lt;/code&gt;(deprecated in C++17)</source>
          <target state="translated">&lt;code&gt;first_argument_type&lt;/code&gt; (устарел в C ++ 17)</target>
        </trans-unit>
        <trans-unit id="a2cf7d2be84b74299c23ec77ba8cdc09ae28eca2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;first_argument_type&lt;/code&gt;(deprecated in C++17)(removed in C++20)</source>
          <target state="translated">&lt;code&gt;first_argument_type&lt;/code&gt; (устарело в C ++ 17) (удалено в C ++ 20)</target>
        </trans-unit>
        <trans-unit id="4efc34975233ec239fcf6e9b4ab9dc49f949f706" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;first_argument_type&lt;/code&gt;(deprecated in c++17)</source>
          <target state="translated">&lt;code&gt;first_argument_type&lt;/code&gt; (устарело в c ++ 17)</target>
        </trans-unit>
        <trans-unit id="bf9da79a9b566df73577ccd300df42a8addf6893" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;float&lt;/code&gt; - single precision floating point type. Usually IEEE-754 32 bit floating point type  &lt;code&gt;double&lt;/code&gt; - double precision floating point type. Usually IEEE-754 64 bit floating point type  &lt;code&gt;long double&lt;/code&gt; - extended precision floating point type. Does not necessarily map to types mandated by IEEE-754. Usually 80-bit x87 floating point type on x86 and x86-64 architectures.</source>
          <target state="translated">&lt;code&gt;float&lt;/code&gt; - тип с плавающей точкой одинарной точности. Обычно IEEE-754 32-битный тип с плавающей запятой &lt;code&gt;double&lt;/code&gt; - тип с плавающей запятой двойной точности. Обычно IEEE-754 64-битный тип с плавающей запятой &lt;code&gt;long double&lt;/code&gt; - тип с плавающей запятой повышенной точности. Не обязательно соответствует типам, предписанным IEEE-754. Обычно 80-битный тип x87 с плавающей точкой на архитектурах x86 и x86-64.</target>
        </trans-unit>
        <trans-unit id="5bc2e8ab17f92697edff68a9e6809baeedd1e915" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;float&lt;/code&gt; arguments are converted to &lt;code&gt;double&lt;/code&gt; as in &lt;a href=&quot;implicit_cast#Floating_point_promotion&quot;&gt;floating-point promotion&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;float&lt;/code&gt; аргументы преобразуются в &lt;code&gt;double&lt;/code&gt; , как в &lt;a href=&quot;implicit_cast#Floating_point_promotion&quot;&gt;плавающей точкой продвижения&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="1b210fa17e7776b83abe5b8a384f92783f3ce9ba" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;format&lt;/code&gt; outputs a format string, replacing any format specifiers or escape sequences in that string with match data from &lt;code&gt;*this&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;format&lt;/code&gt; выводит строку формата, заменяя любые спецификаторы формата или escape-последовательности в этой строке данными соответствия из &lt;code&gt;*this&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a5048c3cbf0c190dd404e79a9563420bf857519e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;forward_iterator_tag&lt;/code&gt; corresponds to &lt;a href=&quot;../named_req/forwarditerator&quot;&gt;LegacyForwardIterator&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;forward_iterator_tag&lt;/code&gt; соответствует &lt;a href=&quot;../named_req/forwarditerator&quot;&gt;LegacyForwardIterator&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="bf9be84bda9d166275c01cfadaa207fc4b41fe58" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;free&lt;/code&gt; -- free space on the filesystem, in bytes</source>
          <target state="translated">&lt;code&gt;free&lt;/code&gt; - свободное место в файловой системе, в байтах</target>
        </trans-unit>
        <trans-unit id="a7afdf1046ea93dac61f053f7d4f8f4ec0b1cf21" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;freopen&lt;/code&gt; is the only way to change the narrow/wide orientation of a stream once it has been established by an I/O operation or by &lt;code&gt;std::fwide&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;freopen&lt;/code&gt; - это единственный способ изменить узкую / широкую ориентацию потока после того, как он был установлен операцией ввода-вывода или &lt;code&gt;std::fwide&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e33960b6ff810b12078cc22f4b31c010c8a5086f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;friend&lt;/code&gt; specifier</source>
          <target state="translated">&lt;code&gt;friend&lt;/code&gt; указатель друга</target>
        </trans-unit>
        <trans-unit id="c14fdb9545dd74cee178f1fad87bbe49e06d83bb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;friend&lt;/code&gt;, &lt;code&gt;inline&lt;/code&gt;, &lt;code&gt;virtual&lt;/code&gt;, or nothing (no return type)</source>
          <target state="translated">&lt;code&gt;friend&lt;/code&gt; , &lt;code&gt;inline&lt;/code&gt; , &lt;code&gt;virtual&lt;/code&gt; или ничего (без возвращаемого типа)</target>
        </trans-unit>
        <trans-unit id="cedf6954f71bbf3380f7b71ce0985a33d71e392f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;friend&lt;/code&gt;elaborated-class-specifier&lt;code&gt;;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;friend&lt;/code&gt;elaborated-class-specifier&lt;code&gt;;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b0d23dd5011162edd99095564a0ee89e9c57636c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;friend&lt;/code&gt;function-declaration</source>
          <target state="translated">&lt;code&gt;friend&lt;/code&gt;function-declaration</target>
        </trans-unit>
        <trans-unit id="0db7504e7cc620e3b7b6ce702f40a98249e2e90c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;friend&lt;/code&gt;function-definition</source>
          <target state="translated">&lt;code&gt;friend&lt;/code&gt;function-definition</target>
        </trans-unit>
        <trans-unit id="520ab55d4d6de951979ebfc33a84a5d921959f87" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;friend&lt;/code&gt;simple-type-specifier&lt;code&gt;;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;friend&lt;/code&gt;simple-type-specifier&lt;code&gt;;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b01fa6400ad6c2440063ed3d0bfd34b0dc273495" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;friend&lt;/code&gt;typename-specifier&lt;code&gt;;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;friend&lt;/code&gt;typename-specifier&lt;code&gt;;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0b512d836d2b7abdabdbdefb44526763ca79643c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;front_inserter&lt;/code&gt; is a convenience function template that constructs a &lt;code&gt;&lt;a href=&quot;front_insert_iterator&quot;&gt;std::front_insert_iterator&lt;/a&gt;&lt;/code&gt; for the container &lt;code&gt;c&lt;/code&gt; with the type deduced from the type of the argument.</source>
          <target state="translated">&lt;code&gt;front_inserter&lt;/code&gt; - это шаблон вспомогательной функции, который создает &lt;code&gt;&lt;a href=&quot;front_insert_iterator&quot;&gt;std::front_insert_iterator&lt;/a&gt;&lt;/code&gt; для контейнера &lt;code&gt;c&lt;/code&gt; с типом, выведенным из типа аргумента.</target>
        </trans-unit>
        <trans-unit id="e04cb834c6dcbe1f873e017d0cfe4f6ed63d0863" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;g()&lt;/code&gt; has amortized constant complexity.</source>
          <target state="translated">&lt;code&gt;g()&lt;/code&gt; амортизирует постоянную сложность.</target>
        </trans-unit>
        <trans-unit id="b6112ef2d798b5d72f641fc2facd4c5152a78700" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;g()&lt;/code&gt; is in the range &lt;code&gt;[G::min(), G::max()]&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;g()&lt;/code&gt; находится в диапазоне &lt;code&gt;[G::min(), G::max()]&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8c8d7022caa34fdc4632fa0b0458578ff40e48b9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;g&lt;/code&gt; is an lvalue in the &lt;code&gt;&lt;a href=&quot;invoke&quot;&gt;std::invoke&lt;/a&gt;&lt;/code&gt; expression if it is an lvalue in the call expression, and is an rvalue otherwise. Thus &lt;code&gt;std::move(g)(call_args...)&lt;/code&gt; can move the bound arguments into the call, where &lt;code&gt;g(call_args...)&lt;/code&gt; would copy.</source>
          <target state="translated">&lt;code&gt;g&lt;/code&gt; является lvalue в выражении &lt;code&gt;&lt;a href=&quot;invoke&quot;&gt;std::invoke&lt;/a&gt;&lt;/code&gt; если оно является lvalue в выражении вызова и в противном случае является rvalue. Таким образом, &lt;code&gt;std::move(g)(call_args...)&lt;/code&gt; может переместить связанные аргументы в вызов, куда &lt;code&gt;g(call_args...)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4edaf06963d1ba18614f939860e2628c44009177" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;g&lt;/code&gt;, &lt;code&gt;G&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;g&lt;/code&gt; , &lt;code&gt;G&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="94f5507af9f623e2eec2ff1fa06a25a71e14ad55" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;g&lt;/code&gt;, &lt;code&gt;g1&lt;/code&gt;, &lt;code&gt;g2&lt;/code&gt;, lvalues of a type satisfying &lt;a href=&quot;uniformrandombitgenerator&quot;&gt;UniformRandomBitGenerator&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;g&lt;/code&gt; , &lt;code&gt;g1&lt;/code&gt; , &lt;code&gt;g2&lt;/code&gt; , l значения типа, удовлетворяющего &lt;a href=&quot;uniformrandombitgenerator&quot;&gt;UniformRandomBitGenerator&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="34b81a135481f308b7ef8efb863ef7ce2a2b732d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;g&lt;/code&gt;, a value of type &lt;code&gt;G&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;g&lt;/code&gt; , значение типа &lt;code&gt;G&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="411215b54d449f9618e7ef52494cb145feee0a20" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;get()&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;get()&lt;/code&gt;.</target>
        </trans-unit>
        <trans-unit id="e2074e08c05eeca723858592a445e1f203b9bdd7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;get_future()&lt;/code&gt; has already been called on a promise with the same shared state as &lt;code&gt;*this&lt;/code&gt;. The error category is set to &lt;a href=&quot;../future_errc&quot;&gt;&lt;code&gt;future_already_retrieved&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;get_future()&lt;/code&gt; уже была вызвана для обещания с тем же общим состоянием, что и &lt;code&gt;*this&lt;/code&gt; . Категория ошибки установлена ​​в &lt;a href=&quot;../future_errc&quot;&gt; &lt;code&gt;future_already_retrieved&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b073fc02d3fb4d433180e83cc3ba037eddccaacd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;get_future&lt;/code&gt; can be called only once for each &lt;code&gt;packaged_task&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;get_future&lt;/code&gt; может быть вызван только один раз для каждого &lt;code&gt;packaged_task&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="91b4b348569fe839c9d79a8973645af16f96667a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;getline&lt;/code&gt; reads characters from an input stream and places them into a string:</source>
          <target state="translated">&lt;code&gt;getline&lt;/code&gt; читает символы из входного потока и помещает их в строку:</target>
        </trans-unit>
        <trans-unit id="ee199872d7cea13b60631d13afd2fba4ed220694" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;goodbit&lt;/code&gt; if &lt;code&gt;sb&lt;/code&gt; is not a null pointer, otherwise &lt;code&gt;badbit&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;goodbit&lt;/code&gt; если &lt;code&gt;sb&lt;/code&gt; не является нулевым указателем, иначе &lt;code&gt;badbit&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f8937a0902728f0df77cdfa6c9d933e0ec25a812" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;gps_clock&lt;/code&gt; meets the &lt;a href=&quot;../named_req/clock&quot;&gt;Clock&lt;/a&gt; requirements. It does not meet the &lt;a href=&quot;../named_req/trivialclock&quot;&gt;TrivialClock&lt;/a&gt; requirements unless the implementation can guarantee that &lt;a href=&quot;gps_clock/now&quot;&gt;&lt;code&gt;now()&lt;/code&gt;&lt;/a&gt; does not throw an exception.</source>
          <target state="translated">&lt;code&gt;gps_clock&lt;/code&gt; соответствует требованиям к &lt;a href=&quot;../named_req/clock&quot;&gt;часам&lt;/a&gt; . Он не соответствует требованиям &lt;a href=&quot;../named_req/trivialclock&quot;&gt;TrivialClock,&lt;/a&gt; если реализация не может гарантировать, что &lt;a href=&quot;gps_clock/now&quot;&gt; &lt;code&gt;now()&lt;/code&gt; &lt;/a&gt; не выдает исключение.</target>
        </trans-unit>
        <trans-unit id="3864519d2183bfb5ce854fe8e1fcb2c7da1679d5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;gslice_array&lt;/code&gt; to initialize with</source>
          <target state="translated">&lt;code&gt;gslice_array&lt;/code&gt; для инициализации с</target>
        </trans-unit>
        <trans-unit id="7ec56ed1681f55a9a6dc88025fbe99be66e31868" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;h&lt;/code&gt;, a value of type &lt;code&gt;T&lt;/code&gt; or &lt;code&gt;const T&lt;/code&gt;, whose argument type is &lt;code&gt;Key&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;h&lt;/code&gt; , значение типа &lt;code&gt;T&lt;/code&gt; или &lt;code&gt;const T&lt;/code&gt; , тип аргумента которого является &lt;code&gt;Key&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="111f616087040965483bbd613b70e0fda243f2e4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;hash_value&lt;/code&gt; originates from the boost.filesystem library where it was used for interoperability with boost.hash (which &lt;a href=&quot;http://www.boost.org/doc/libs/1_60_0/doc/html/hash/reference.html#boost.hash_val_idm45507095703056&quot;&gt;calls hash_value&lt;/a&gt; where available).</source>
          <target state="translated">&lt;code&gt;hash_value&lt;/code&gt; происходит из библиотеки boost.filesystem, где он использовался для взаимодействия с boost.hash (который &lt;a href=&quot;http://www.boost.org/doc/libs/1_60_0/doc/html/hash/reference.html#boost.hash_val_idm45507095703056&quot;&gt;вызывает hash_value,&lt;/a&gt; где он доступен).</target>
        </trans-unit>
        <trans-unit id="27b6941a88dbd576a2a2cc11f8d26dbd015e1a90" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;hasher&lt;/code&gt; and &lt;code&gt;key_equal&lt;/code&gt;&lt;a href=&quot;copyconstructible&quot;&gt;CopyConstructible&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;hasher&lt;/code&gt; и &lt;code&gt;key_equal&lt;/code&gt; &lt;a href=&quot;copyconstructible&quot;&gt;CopyConstructible&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="7aea8deea0bde7eac532953c4c0d7fd1068b7183" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;hasher&lt;/code&gt; and &lt;code&gt;key_equal&lt;/code&gt;&lt;a href=&quot;copyconstructible&quot;&gt;CopyConstructible&lt;/a&gt;, &lt;code&gt;value_type&lt;/code&gt;&lt;a href=&quot;emplaceconstructible&quot;&gt;EmplaceConstructible&lt;/a&gt; into &lt;code&gt;X&lt;/code&gt; from &lt;code&gt;*i&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;hasher&lt;/code&gt; и &lt;code&gt;key_equal&lt;/code&gt; &lt;a href=&quot;copyconstructible&quot;&gt;CopyConstructible&lt;/a&gt; , &lt;code&gt;value_type&lt;/code&gt; &lt;a href=&quot;emplaceconstructible&quot;&gt;EmplaceConstructible&lt;/a&gt; в &lt;code&gt;X&lt;/code&gt; из &lt;code&gt;*i&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ba9369c4408e11b73dd0ee3d4ea2c0ba897e8e08" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;hasher&lt;/code&gt; and &lt;code&gt;key_equal&lt;/code&gt;&lt;a href=&quot;defaultconstructible&quot;&gt;DefaultConstructible&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;hasher&lt;/code&gt; и &lt;code&gt;key_equal&lt;/code&gt; &lt;a href=&quot;defaultconstructible&quot;&gt;DefaultConstructible&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="6cd69adb31cff6805d6e79766c0f05d07992b1b9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;hasher&lt;/code&gt;&lt;a href=&quot;copyconstructible&quot;&gt;CopyConstructible&lt;/a&gt;, &lt;code&gt;key_equal&lt;/code&gt;&lt;a href=&quot;defaultconstructible&quot;&gt;DefaultConstructible&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;hasher&lt;/code&gt; &lt;a href=&quot;copyconstructible&quot;&gt;CopyConstructible&lt;/a&gt; , &lt;code&gt;key_equal&lt;/code&gt; &lt;a href=&quot;defaultconstructible&quot;&gt;DefaultConstructible&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="cfcb282c32b3cd3e320440a37e082cc3cd592510" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;hasher&lt;/code&gt;&lt;a href=&quot;defaultconstructible&quot;&gt;DefaultConstructible&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;hasher&lt;/code&gt;&lt;a href=&quot;defaultconstructible&quot;&gt;DefaultConstructible&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="8a1713b6e25c2f4865d58a7c17a5ad31b4f5bb1f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;hh&lt;/code&gt; - 2-digit hour from &lt;code&gt;timeptr-&amp;gt;tm_hour&lt;/code&gt; as if printed by &lt;code&gt;sprintf&lt;/code&gt; using &lt;code&gt;%.2d&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;hh&lt;/code&gt; - двузначный час из &lt;code&gt;timeptr-&amp;gt;tm_hour&lt;/code&gt; , как если бы он был напечатан &lt;code&gt;sprintf&lt;/code&gt; с использованием &lt;code&gt;%.2d&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="53896df8aca81db5e2f25a4961cb85d988b062dd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;hh&lt;/code&gt; - hours</source>
          <target state="translated">&lt;code&gt;hh&lt;/code&gt; - часы</target>
        </trans-unit>
        <trans-unit id="671fdc3e4d1f215ae1223caeb16c561628665336" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;hours()&lt;/code&gt; returns the integral number of hours &lt;code&gt;since_midnight&lt;/code&gt; is after 00:00:00.</source>
          <target state="translated">&lt;code&gt;hours()&lt;/code&gt; возвращает целое число часов, &lt;code&gt;since_midnight&lt;/code&gt; - после 00:00:00.</target>
        </trans-unit>
        <trans-unit id="c98fc30e60f72693a16df6b71119374088a3b262" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;hypot(x, y)&lt;/code&gt;, &lt;code&gt;hypot(y, x)&lt;/code&gt;, and &lt;code&gt;hypot(x, -y)&lt;/code&gt; are equivalent</source>
          <target state="translated">&lt;code&gt;hypot(x, y)&lt;/code&gt; , &lt;code&gt;hypot(y, x)&lt;/code&gt; и &lt;code&gt;hypot(x, -y)&lt;/code&gt; эквивалентны</target>
        </trans-unit>
        <trans-unit id="78d36c3670a120414836e17fbb363e2dd80744e4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;i == 2&lt;/code&gt; is considered more likely than any other value of &lt;code&gt;i&lt;/code&gt;, but the &lt;code&gt;[[&lt;strong&gt;likely&lt;/strong&gt;]]&lt;/code&gt; has no effect on the &lt;code&gt;i == 1&lt;/code&gt; case even though it falls through the &lt;code&gt;case 2:&lt;/code&gt; label.</source>
          <target state="translated">&lt;code&gt;i == 2&lt;/code&gt; считается более вероятным, чем любое другое значение &lt;code&gt;i&lt;/code&gt; , но &lt;code&gt;[[&lt;strong&gt;likely&lt;/strong&gt;]]&lt;/code&gt; не влияет на случай &lt;code&gt;i == 1&lt;/code&gt; даже если он проходит через &lt;code&gt;case 2:&lt;/code&gt; метка.</target>
        </trans-unit>
        <trans-unit id="b976ac77602b68cce0c449c176cdf386647ac678" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;i&lt;/code&gt; and &lt;code&gt;j&lt;/code&gt;, &lt;a href=&quot;inputiterator&quot;&gt;LegacyInputIterators&lt;/a&gt; such that &lt;code&gt;[i, j)&lt;/code&gt; is a valid range and that the iterators refer to elements implicitly convertible to &lt;code&gt;value_type&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;i&lt;/code&gt; и &lt;code&gt;j&lt;/code&gt; , &lt;a href=&quot;inputiterator&quot;&gt;LegacyInputIterators,&lt;/a&gt; такие что &lt;code&gt;[i, j)&lt;/code&gt; является допустимым диапазоном и что итераторы ссылаются на элементы, неявно преобразуемые в &lt;code&gt;value_type&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4f6d9764f8087379022430768a7a169413bbe17a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;i&lt;/code&gt; and &lt;code&gt;j&lt;/code&gt;, objects of a container's &lt;code&gt;iterator&lt;/code&gt; type,</source>
          <target state="translated">&lt;code&gt;i&lt;/code&gt; и &lt;code&gt;j&lt;/code&gt; , объекты типа &lt;code&gt;iterator&lt;/code&gt; контейнера ,</target>
        </trans-unit>
        <trans-unit id="18e96bffb01e60c107a8239648857167f5c74951" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;i&lt;/code&gt; and &lt;code&gt;j&lt;/code&gt;, values of type &lt;code&gt;It&lt;/code&gt; or &lt;code&gt;const It&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;i&lt;/code&gt; и &lt;code&gt;j&lt;/code&gt; , значения типа &lt;code&gt;It&lt;/code&gt; или &lt;code&gt;const It&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="cbf29f78689bf07a8e6132a8f717ff5fdfca186a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;i&lt;/code&gt;, &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;b&lt;/code&gt;, objects of type &lt;code&gt;It&lt;/code&gt; or &lt;code&gt;const It&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;i&lt;/code&gt; , &lt;code&gt;a&lt;/code&gt; , &lt;code&gt;b&lt;/code&gt; , объекты типа &lt;code&gt;It&lt;/code&gt; или &lt;code&gt;const It&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="18deb471df56ecbe71a4c38845fcc195736a1eb9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;i&lt;/code&gt;, &lt;code&gt;j&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;i&lt;/code&gt; , &lt;code&gt;j&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="03cf4985f5ecbdda5b97e43539f8485780115cd8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;i&lt;/code&gt;, dereferenceable iterator of type &lt;code&gt;It&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;i&lt;/code&gt; , разыменованный итератор типа &lt;code&gt;It&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5cc15c2bb86d65f2fb65ca31cce0e3eed25a4e7a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ib&lt;/code&gt;,&lt;code&gt;ie&lt;/code&gt; are &lt;a href=&quot;inputiterator&quot;&gt;LegacyInputIterators&lt;/a&gt; with a &lt;code&gt;value_type&lt;/code&gt; of unsigned integer values of at least 32 bits.</source>
          <target state="translated">&lt;code&gt;ib&lt;/code&gt; , &lt;code&gt;ie&lt;/code&gt; являются &lt;a href=&quot;inputiterator&quot;&gt;LegacyInputIterators&lt;/a&gt; с &lt;code&gt;value_type&lt;/code&gt; целочисленных значений без знака, по крайней мере, 32 бит.</target>
        </trans-unit>
        <trans-unit id="7f6694aedba6d7abc5755c6543b84050f1f2d24a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;id&lt;/code&gt;(static)</source>
          <target state="translated">&lt;code&gt;id&lt;/code&gt;(static)</target>
        </trans-unit>
        <trans-unit id="388eaffb6c01131dc19ce798454c600802009327" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;if&lt;/code&gt;&lt;code&gt;constexpr&lt;/code&gt;(optional)&lt;code&gt;(&lt;/code&gt;condition&lt;code&gt;)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;if&lt;/code&gt;&lt;code&gt;constexpr&lt;/code&gt;(optional)&lt;code&gt;(&lt;/code&gt;condition&lt;code&gt;)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f1c4f6e56383e839c77c6f0a8ed70ebc070ed02f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ignore&lt;/code&gt; behaves as an &lt;a href=&quot;../../named_req/unformattedinputfunction&quot;&gt;UnformattedInputFunction&lt;/a&gt;. After constructing and checking the sentry object, it extracts characters from the stream and discards them until any one of the following conditions occurs:</source>
          <target state="translated">&lt;code&gt;ignore&lt;/code&gt; ведет себя как &lt;a href=&quot;../../named_req/unformattedinputfunction&quot;&gt;UnformattedInputFunction&lt;/a&gt; . После создания и проверки объекта sentry он извлекает символы из потока и отбрасывает их до тех пор, пока не произойдет одно из следующих условий:</target>
        </trans-unit>
        <trans-unit id="777d6c1fb31ff0cfb09ff85f3f835fca8b105d38" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;il.begin()&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;il.begin()&lt;/code&gt;.</target>
        </trans-unit>
        <trans-unit id="2223610ff829ee9123d368c88fde6fef3651fa54" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;il.end()&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;il.end()&lt;/code&gt;.</target>
        </trans-unit>
        <trans-unit id="c244beea1817d5ff90b031967df2dc1d6efc2cda" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;il&lt;/code&gt; is an &lt;code&gt;&lt;a href=&quot;../utility/initializer_list&quot;&gt;std::initializer_list&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;il&lt;/code&gt; является &lt;code&gt;&lt;a href=&quot;../utility/initializer_list&quot;&gt;std::initializer_list&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="389b8bf8dc4e62dfa9d6e3312fc5c0f1694b19b3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;il&lt;/code&gt;, an object of type &lt;code&gt;&lt;a href=&quot;../utility/initializer_list&quot;&gt;std::initializer_list&lt;/a&gt;&amp;lt;value_type&amp;gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;il&lt;/code&gt; , объект типа &lt;code&gt;&lt;a href=&quot;../utility/initializer_list&quot;&gt;std::initializer_list&lt;/a&gt;&amp;lt;value_type&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="385ae00297d1ac58a35a032dea056ac29f1cd1c8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;in&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;in&lt;/code&gt;.</target>
        </trans-unit>
        <trans-unit id="0ec3fec471c769b0028e361778d1ff16414c77da" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;independent_bits_engine&lt;/code&gt; is a random number engine adaptor that produces random numbers with different number of bits than that of the wrapped engine.</source>
          <target state="translated">&lt;code&gt;independent_bits_engine&lt;/code&gt; - это адаптер движка случайных чисел, который генерирует случайные числа с количеством битов, отличным от числа в упакованном движке.</target>
        </trans-unit>
        <trans-unit id="141398579848ffc093d3d4fe6c88adcc411f38a8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;index&lt;/code&gt; is the user-provided value passed to &lt;code&gt;&lt;a href=&quot;register_callback&quot;&gt;register_callback()&lt;/a&gt;&lt;/code&gt; when registering the function.</source>
          <target state="translated">&lt;code&gt;index&lt;/code&gt; - предоставленное пользователем значение, передаваемое в &lt;code&gt;&lt;a href=&quot;register_callback&quot;&gt;register_callback()&lt;/a&gt;&lt;/code&gt; при регистрации функции.</target>
        </trans-unit>
        <trans-unit id="8aaca78507992147a73d84775d11c42b2e40f9ca" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;indirect_array&lt;/code&gt; to initialize with</source>
          <target state="translated">&lt;code&gt;indirect_array&lt;/code&gt; для инициализации с</target>
        </trans-unit>
        <trans-unit id="da7fbcd8eb53b0869c2ab43c83b782f0fc87e3ba" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;inline&lt;/code&gt; specifier</source>
          <target state="translated">&lt;code&gt;inline&lt;/code&gt; спецификатор</target>
        </trans-unit>
        <trans-unit id="e8b06c80b6a672997e657c88831908a56cf3efd4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;inline&lt;/code&gt;(optional)&lt;code&gt;namespace&lt;/code&gt;attr(optional)&lt;code&gt;{ &lt;/code&gt;namespace-body&lt;code&gt;} &lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;inline&lt;/code&gt; (необязательно) &lt;code&gt;namespace&lt;/code&gt; attr (необязательно) &lt;code&gt;{ &lt;/code&gt; namespace-body &lt;code&gt;} &lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="92fcb6106eac2fa99448f0e0e49f6d7d69e513b4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;inline&lt;/code&gt;(optional)&lt;code&gt;namespace&lt;/code&gt;attr(optional)identifier&lt;code&gt;{ &lt;/code&gt;namespace-body&lt;code&gt;} &lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;inline&lt;/code&gt; (необязательный) идентификатор пространства &lt;code&gt;namespace&lt;/code&gt; attr (необязательный) &lt;code&gt;{ &lt;/code&gt; namespace-body &lt;code&gt;} &lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="cff8c42e8bd2ae405de522be35af9c42f0ef715d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;inline&lt;/code&gt;&lt;code&gt;namespace&lt;/code&gt;ns_name { declarations }</source>
          <target state="translated">&lt;code&gt;inline&lt;/code&gt; &lt;code&gt;namespace&lt;/code&gt; ns_name {объявлений}</target>
        </trans-unit>
        <trans-unit id="116e0fe82c54955cf01a9937cdc1321af775ea37" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;input&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;input&lt;/code&gt;.</target>
        </trans-unit>
        <trans-unit id="3be7a3e01de26a5164dbfd037a805870a7e38ee4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;input_iterator_tag&lt;/code&gt; corresponds to &lt;a href=&quot;../named_req/inputiterator&quot;&gt;LegacyInputIterator&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;input_iterator_tag&lt;/code&gt; соответствует &lt;a href=&quot;../named_req/inputiterator&quot;&gt;LegacyInputIterator&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c74daf231867ea3b60b7c99690e2d6b255ffe413" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;insert_or_assign&lt;/code&gt; returns more information than &lt;code&gt;operator[]&lt;/code&gt; and does not require default-constructibility of the mapped type.</source>
          <target state="translated">&lt;code&gt;insert_or_assign&lt;/code&gt; возвращает больше информации, чем &lt;code&gt;operator[]&lt;/code&gt; и не требует конструктивности по умолчанию отображаемого типа.</target>
        </trans-unit>
        <trans-unit id="443968eb686146e29de33ab24e056f1dd0c65e0e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;insert_return_type&lt;/code&gt;(since C++17)</source>
          <target state="translated">&lt;code&gt;insert_return_type&lt;/code&gt; (начиная с C ++ 17)</target>
        </trans-unit>
        <trans-unit id="241e9902f59ff439ac42d797096feb5ee566294e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;inserter&lt;/code&gt; is a convenience function template that constructs a &lt;code&gt;&lt;a href=&quot;insert_iterator&quot;&gt;std::insert_iterator&lt;/a&gt;&lt;/code&gt; for the container &lt;code&gt;c&lt;/code&gt; and its iterator &lt;code&gt;i&lt;/code&gt; with the type deduced from the type of the argument.</source>
          <target state="translated">&lt;code&gt;inserter&lt;/code&gt; - это шаблон &lt;code&gt;&lt;a href=&quot;insert_iterator&quot;&gt;std::insert_iterator&lt;/a&gt;&lt;/code&gt; функции, который создает std :: insert_iterator для контейнера &lt;code&gt;c&lt;/code&gt; и его итератора &lt;code&gt;i&lt;/code&gt; с типом, выведенным из типа аргумента.</target>
        </trans-unit>
        <trans-unit id="057de6e24b8ab26f37b3b86ecf25cc860351f643" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;int (* const *)(int *)&lt;/code&gt; and &lt;code&gt;int (* volatile *)(int *)&lt;/code&gt; are similar;</source>
          <target state="translated">&lt;code&gt;int (* const *)(int *)&lt;/code&gt; и &lt;code&gt;int (* volatile *)(int *)&lt;/code&gt; похожи;</target>
        </trans-unit>
        <trans-unit id="48ea95fbaba1b0dbd21298dc774cbe17d002f6ec" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;int (*)(int * const)&lt;/code&gt; and &lt;code&gt;int (*)(int *)&lt;/code&gt; are similar (they are the same type);</source>
          <target state="translated">&lt;code&gt;int (*)(int * const)&lt;/code&gt; и &lt;code&gt;int (*)(int *)&lt;/code&gt; похожи (они одного типа);</target>
        </trans-unit>
        <trans-unit id="5d15c0772df0971f9687b78820f226ccd72eecc0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;int (*)(int *)&lt;/code&gt; and &lt;code&gt;int (*)(const int *)&lt;/code&gt; are</source>
          <target state="translated">&lt;code&gt;int (*)(int *)&lt;/code&gt; и &lt;code&gt;int (*)(const int *)&lt;/code&gt; являются</target>
        </trans-unit>
        <trans-unit id="bd850e51b0a74012934879a370718571cb96e6a8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;int (S::*)() const&lt;/code&gt; and &lt;code&gt;int (S::*)()&lt;/code&gt; are</source>
          <target state="translated">&lt;code&gt;int (S::*)() const&lt;/code&gt; и &lt;code&gt;int (S::*)()&lt;/code&gt; являются</target>
        </trans-unit>
        <trans-unit id="4111163b3f8fdbde555a417a0587d2ece9578791" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;int&lt;/code&gt; - basic integer type. The keyword &lt;code&gt;int&lt;/code&gt; may be omitted if any of the modifiers listed below are used. If no length modifiers are present, it's guaranteed to have a width of at least 16 bits. However, on 32/64 bit systems it is almost exclusively guaranteed to have width of at least 32 bits (see below).</source>
          <target state="translated">&lt;code&gt;int&lt;/code&gt; - основной целочисленный тип. Ключевое слово &lt;code&gt;int&lt;/code&gt; может быть опущено, если используется любой из перечисленных ниже модификаторов. Если модификаторы длины отсутствуют, ширина гарантированно должна быть не менее 16 бит. Однако в 32/64-битных системах ширина гарантированно гарантированно составляет 32 бита (см. Ниже).</target>
        </trans-unit>
        <trans-unit id="51b6196d0c7c2679b2d61ea8fbb53b459dd8cb77" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;int&lt;/code&gt;&lt;code&gt;main&lt;/code&gt;&lt;code&gt;()&lt;/code&gt;&lt;code&gt;{&lt;/code&gt;body&lt;code&gt;} &lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;int&lt;/code&gt;&lt;code&gt;main&lt;/code&gt;&lt;code&gt;()&lt;/code&gt;&lt;code&gt;{&lt;/code&gt;body&lt;code&gt;} &lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5d6bb4984004e90cc09875909163eb7f968fca99" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;int&lt;/code&gt;&lt;code&gt;main&lt;/code&gt;&lt;code&gt;(&lt;/code&gt;&lt;code&gt;int&lt;/code&gt;argc&lt;code&gt;,&lt;/code&gt;&lt;code&gt;char&lt;/code&gt;&lt;code&gt;*&lt;/code&gt;argv&lt;code&gt;[]&lt;/code&gt;&lt;code&gt;)&lt;/code&gt;&lt;code&gt;{&lt;/code&gt;body&lt;code&gt;} &lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;int&lt;/code&gt;&lt;code&gt;main&lt;/code&gt;&lt;code&gt;(&lt;/code&gt;&lt;code&gt;int&lt;/code&gt;argc&lt;code&gt;,&lt;/code&gt;&lt;code&gt;char&lt;/code&gt;&lt;code&gt;*&lt;/code&gt;argv&lt;code&gt;[]&lt;/code&gt;&lt;code&gt;)&lt;/code&gt;&lt;code&gt;{&lt;/code&gt;body&lt;code&gt;} &lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f83ac3b4e3ec48699e12339b5892899400cf07fb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;intmax_t*&lt;/code&gt; or &lt;code&gt;uintmax_t*&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;intmax_t*&lt;/code&gt; или &lt;code&gt;uintmax_t*&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e2ee6087049c4a7176433e4088143e7614fdc603" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;io_state&lt;/code&gt;(deprecated)</source>
          <target state="translated">&lt;code&gt;io_state&lt;/code&gt;(deprecated)</target>
        </trans-unit>
        <trans-unit id="4d7cce0f90e17b616e716122aeac71956f548947" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ios&lt;/code&gt; refers to the stream object for which the callback is invoked: &lt;code&gt;*this&lt;/code&gt; is passed as the argument when callbacks are invoked by &lt;code&gt;&lt;a href=&quot;../ios_base&quot;&gt;std::ios_base&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../basic_ios&quot;&gt;std::basic_ios&lt;/a&gt;&lt;/code&gt; member functions.</source>
          <target state="translated">&lt;code&gt;ios&lt;/code&gt; относится к объекту потока, для которого вызывается обратный вызов: &lt;code&gt;*this&lt;/code&gt; передается в качестве аргумента, когда обратные вызовы вызываются &lt;code&gt;&lt;a href=&quot;../ios_base&quot;&gt;std::ios_base&lt;/a&gt;&lt;/code&gt; членами std :: ios_base и &lt;code&gt;&lt;a href=&quot;../basic_ios&quot;&gt;std::basic_ios&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0e2d53cf94b70b8cafca6763310cf0eaf11119a8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;is&lt;/code&gt; (reference to the stream after extraction of consecutive whitespace).</source>
          <target state="translated">&lt;code&gt;is&lt;/code&gt; (ссылка на поток после извлечения последовательных пробелов).</target>
        </trans-unit>
        <trans-unit id="4fedb03004a680c63b22ba8eb8a01ff66fb6f653" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;is&lt;/code&gt;, an input stream</source>
          <target state="translated">&lt;code&gt;is&lt;/code&gt; входной поток</target>
        </trans-unit>
        <trans-unit id="21c5fea12a20a74cfe31d4cc9a804eba03a5a863" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;is&lt;/code&gt;, lvalue of a specialization of &lt;code&gt;&lt;a href=&quot;../io/basic_istream&quot;&gt;std::basic_istream&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;is&lt;/code&gt; значение специализации &lt;code&gt;&lt;a href=&quot;../io/basic_istream&quot;&gt;std::basic_istream&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="41e6679a08145bbcb9389bae0a5f56abbdd4be92" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;is&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;is&lt;/code&gt;.</target>
        </trans-unit>
        <trans-unit id="1e3a41e68a345159b15102972bec9ae1a1f13e75" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;is_always_equal&lt;/code&gt;(C++17)</source>
          <target state="translated">&lt;code&gt;is_always_equal&lt;/code&gt;(C++17)</target>
        </trans-unit>
        <trans-unit id="a2705b3ce1ac51a19c9249b3cf3e6651264796d7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;is_always_equal&lt;/code&gt;(C++17)&lt;code&gt;&lt;a href=&quot;../types/integral_constant&quot;&gt;std::true_type&lt;/a&gt;&lt;/code&gt; if &lt;code&gt;&lt;a href=&quot;allocator_traits&quot;&gt;std::allocator_traits&lt;/a&gt;&amp;lt;A&amp;gt;::is_always_equal::value&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; for every allocator &lt;code&gt;A&lt;/code&gt; among &lt;code&gt;OuterAlloc&lt;/code&gt; and &lt;code&gt;InnerAlloc...&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;is_always_equal&lt;/code&gt; (C ++ 17) &lt;code&gt;&lt;a href=&quot;../types/integral_constant&quot;&gt;std::true_type&lt;/a&gt;&lt;/code&gt; если &lt;code&gt;&lt;a href=&quot;allocator_traits&quot;&gt;std::allocator_traits&lt;/a&gt;&amp;lt;A&amp;gt;::is_always_equal::value&lt;/code&gt; это &lt;code&gt;true&lt;/code&gt; для каждого распределителем &lt;code&gt;A&lt;/code&gt; среди &lt;code&gt;OuterAlloc&lt;/code&gt; и &lt;code&gt;InnerAlloc...&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c2119c35a8f19a347e85544b010ec5ea974fdc00" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;is_always_equal&lt;/code&gt;(since C++17)</source>
          <target state="translated">&lt;code&gt;is_always_equal&lt;/code&gt; (начиная с C ++ 17)</target>
        </trans-unit>
        <trans-unit id="e506b53e2d1fbcb0355850b8a7a5448acee68a81" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;is_modulo&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt; for signed integer types, unless the implementation defines signed integer overflow to wrap.</source>
          <target state="translated">&lt;code&gt;is_modulo&lt;/code&gt; имеет значение &lt;code&gt;false&lt;/code&gt; для целочисленных типов со знаком , если реализация не определяет целочисленное переполнение со знаком для переноса .</target>
        </trans-unit>
        <trans-unit id="a8f90c8c322bbe5a2de9888a255af234a56268a0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;is_modulo&lt;/code&gt; was required to &lt;code&gt;true&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;is_modulo&lt;/code&gt; требовалось к &lt;code&gt;true&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ce8a3e2f016914c87bba189cef2b04d0f35ccc04" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;isdigit&lt;/code&gt; and &lt;code&gt;isxdigit&lt;/code&gt; are the only standard narrow character classification functions that are not affected by the currently installed C locale. although some implementations (e.g. Microsoft in 1252 codepage) may classify additional single-byte characters as digits.</source>
          <target state="translated">&lt;code&gt;isdigit&lt;/code&gt; и &lt;code&gt;isxdigit&lt;/code&gt; являются единственными стандартными функциями классификации узких символов, на которые не влияет установленный в настоящее время языковой стандарт C. хотя некоторые реализации (например, Microsoft в кодировке 1252) могут классифицировать дополнительные однобайтовые символы как цифры.</target>
        </trans-unit>
        <trans-unit id="03ca901dd1c3cf178377939122dcac1b084722d9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;istrstream&lt;/code&gt; has been deprecated since C++98, &lt;code&gt;&lt;a href=&quot;basic_istringstream&quot;&gt;std::istringstream&lt;/a&gt;&lt;/code&gt; and &lt;a href=&quot;http://www.boost.org/doc/libs/release/libs/iostreams/doc/classes/array.html#array_source&quot;&gt;boost::iostreams::array_source&lt;/a&gt; are the recommended replacements.</source>
          <target state="translated">&lt;code&gt;istrstream&lt;/code&gt; с C ++ 98 istrstream устарел, рекомендуется использовать &lt;code&gt;&lt;a href=&quot;basic_istringstream&quot;&gt;std::istringstream&lt;/a&gt;&lt;/code&gt; и &lt;a href=&quot;http://www.boost.org/doc/libs/release/libs/iostreams/doc/classes/array.html#array_source&quot;&gt;boost :: iostreams :: array_source&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="fb5edd0a0de37b0c2018cffd8918604843a5da04" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;iter&lt;/code&gt;(protected member object)</source>
          <target state="translated">&lt;code&gt;iter&lt;/code&gt; (защищенный член-объект)</target>
        </trans-unit>
        <trans-unit id="2f6228c2bf65ab429079525886977a8a82322066" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;iterator_category&lt;/code&gt; - the category of the iterator. Must be one of &lt;a href=&quot;iterator_tags&quot;&gt;iterator category tags&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;iterator_category&lt;/code&gt; - категория итератора. Должен быть одним из &lt;a href=&quot;iterator_tags&quot;&gt;тегов категории итератора&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6c25d10cbb7bd92ac69fb00b2f385e3a959241b6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;iterator_concept&lt;/code&gt;(since C++20)</source>
          <target state="translated">&lt;code&gt;iterator_concept&lt;/code&gt; (начиная с C ++ 20)</target>
        </trans-unit>
        <trans-unit id="f98ae9387f7361a914c5167c81d08f001775f77c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;k&lt;/code&gt;, a value of type convertible to &lt;code&gt;Key&lt;/code&gt; or &lt;code&gt;const Key&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;k&lt;/code&gt; , значение типа, преобразуемого в &lt;code&gt;Key&lt;/code&gt; или &lt;code&gt;const Key&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="256f7f56e4f1142fd96bfebe17b16058836d8603" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;key_compare&lt;/code&gt; for &lt;code&gt;&lt;a href=&quot;../container/set&quot;&gt;std::set&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../container/multiset&quot;&gt;std::multiset&lt;/a&gt;&lt;/code&gt;; an ordering relation over &lt;code&gt;Key&lt;/code&gt; for &lt;code&gt;&lt;a href=&quot;../container/map&quot;&gt;std::map&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../container/multimap&quot;&gt;std::multimap&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;key_compare&lt;/code&gt; для &lt;code&gt;&lt;a href=&quot;../container/set&quot;&gt;std::set&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;../container/multiset&quot;&gt;std::multiset&lt;/a&gt;&lt;/code&gt; ; отношение порядка по &lt;code&gt;Key&lt;/code&gt; для &lt;code&gt;&lt;a href=&quot;../container/map&quot;&gt;std::map&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;../container/multimap&quot;&gt;std::multimap&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1328b6295690f4839bcaa8688257d852878b7ba8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;key_compare&lt;/code&gt; is &lt;a href=&quot;copyconstructible&quot;&gt;CopyConstructible&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;key_compare&lt;/code&gt; является &lt;a href=&quot;copyconstructible&quot;&gt;CopyConstructible&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="9c656810f208efe9d951232e34bfa6d6fa554f88" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;key_compare&lt;/code&gt; is &lt;a href=&quot;copyconstructible&quot;&gt;CopyConstructible&lt;/a&gt; and &lt;code&gt;value_type&lt;/code&gt; is &lt;a href=&quot;emplaceconstructible&quot;&gt;EmplaceConstructible&lt;/a&gt; into &lt;code&gt;X&lt;/code&gt; from &lt;code&gt;*i&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;key_compare&lt;/code&gt; является &lt;a href=&quot;copyconstructible&quot;&gt;CopyConstructible&lt;/a&gt; и &lt;code&gt;value_type&lt;/code&gt; является &lt;a href=&quot;emplaceconstructible&quot;&gt;EmplaceConstructible&lt;/a&gt; в &lt;code&gt;X&lt;/code&gt; от &lt;code&gt;*i&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5e76cf2b2fbf296175b2f81c9c806a60b32c23bb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;key_equal&lt;/code&gt;&lt;a href=&quot;defaultconstructible&quot;&gt;DefaultConstructible&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;key_equal&lt;/code&gt;&lt;a href=&quot;defaultconstructible&quot;&gt;DefaultConstructible&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ebf5299058b9fd564cac587f10aa739cdc1e5bae" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;kittens...&lt;/code&gt;, a set of arguments to &lt;code&gt;purr&lt;/code&gt; that meets the requirements for that operation,</source>
          <target state="translated">&lt;code&gt;kittens...&lt;/code&gt; набор аргументов для &lt;code&gt;purr&lt;/code&gt; который отвечает требованиям для этой операции,</target>
        </trans-unit>
        <trans-unit id="54e81ff78f39fe2d54d46f191d9f15b4b92f3555" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;knuth_b&lt;/code&gt;(C++11)</source>
          <target state="translated">&lt;code&gt;knuth_b&lt;/code&gt;(C++11)</target>
        </trans-unit>
        <trans-unit id="d84ead23b080bf2969278be7d79c70f8f003d56c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;l L&lt;/code&gt; defines &lt;code&gt;long double&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;l L&lt;/code&gt; определяет &lt;code&gt;long double&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a66fbc2abf78618601cc872cf9936b7953fe1e49" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;l&lt;/code&gt; or &lt;code&gt;L&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;l&lt;/code&gt; или &lt;code&gt;L&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="55c1d39a34f823ca69b882713b76e9b26fde79c3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;last_spec&lt;/code&gt; is an empty tag type that is used in conjunction with other calendar types to indicate the last thing in a sequence. Depending on context, it may indicate the last day of a month (as in &lt;code&gt;2018y/February/last&lt;/code&gt;, for last day of February 2018, i.e., 2018-02-28) or the last day of the week in a month (as in &lt;code&gt;2018/February/Sunday[last]&lt;/code&gt;, for last Sunday of February 2018, i.e., 2018-02-25).</source>
          <target state="translated">&lt;code&gt;last_spec&lt;/code&gt; - это пустой тип тега, который используется в сочетании с другими типами календаря для обозначения последней вещи в последовательности. В зависимости от контекста он может указывать последний день месяца (как в &lt;code&gt;2018y/February/last&lt;/code&gt; , последний день февраля 2018, т. Е. 2018-02-28) или последний день недели в месяце (как в &lt;code&gt;2018/February/Sunday[last]&lt;/code&gt; , в последнее воскресенье февраля 2018 года, т. Е. 2018-02-25).</target>
        </trans-unit>
        <trans-unit id="54cc2b77e86abe38449e33cfa9dd560a4abe8ab8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;leap&lt;/code&gt; has a defaulted copy constructor and a defaulted copy assignment operator.</source>
          <target state="translated">&lt;code&gt;leap&lt;/code&gt; есть конструктор копии по умолчанию и оператор присваивания копии по умолчанию.</target>
        </trans-unit>
        <trans-unit id="8764c6aafcb55d7e707f060f26a7ecfcaec7ee50" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;left|right|internal&lt;/code&gt;. Useful for masking operations</source>
          <target state="translated">&lt;code&gt;left|right|internal&lt;/code&gt; . Полезно для маскировки</target>
        </trans-unit>
        <trans-unit id="3774fb54b1cf9a8fe6a2c568734146ef5a21aaa4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lhs.base() - rhs.base()&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;lhs.base() - rhs.base()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="35322d42c0afddc226669dc0d9f53d98ccab2c85" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lhs.empty()&lt;/code&gt; and &lt;code&gt;rhs.empty()&lt;/code&gt;,</source>
          <target state="translated">&lt;code&gt;lhs.empty()&lt;/code&gt; и &lt;code&gt;rhs.empty()&lt;/code&gt; ,</target>
        </trans-unit>
        <trans-unit id="9a06433bb3b1a7b9c84fb97951b411c54c2f9743" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lhs.outer_allocator() == rhs.outer_allocator()&lt;/code&gt;, and</source>
          <target state="translated">&lt;code&gt;lhs.outer_allocator() == rhs.outer_allocator()&lt;/code&gt; и</target>
        </trans-unit>
        <trans-unit id="710766adbf1e5001e6e2a0bf5345bdec2798b4cd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lhs&lt;/code&gt; and &lt;code&gt;rhs&lt;/code&gt; are equivalent only if they are both empty or share ownership.</source>
          <target state="translated">&lt;code&gt;lhs&lt;/code&gt; и &lt;code&gt;rhs&lt;/code&gt; эквивалентны, только если они оба пусты или имеют совместное владение.</target>
        </trans-unit>
        <trans-unit id="1ef7a535d3323c6880222db1587fa5064e3fc340" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lhs&lt;/code&gt; is considered</source>
          <target state="translated">&lt;code&gt;lhs&lt;/code&gt; считается</target>
        </trans-unit>
        <trans-unit id="d74003b8bcf891027bfc27d7536b0e86891ce0a3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lhs&lt;/code&gt; is equal to &lt;code&gt;rcopy&lt;/code&gt;, unless &lt;code&gt;rhs&lt;/code&gt; is a non-const xvalue that refers to &lt;code&gt;lcopy&lt;/code&gt; (i.e., the assignment is a self-move-assignment),</source>
          <target state="translated">&lt;code&gt;lhs&lt;/code&gt; равно &lt;code&gt;rcopy&lt;/code&gt; , если &lt;code&gt;rhs&lt;/code&gt; не является Неконстантным xvalue , что относится к &lt;code&gt;lcopy&lt;/code&gt; (то есть, присвоение является самостоятельным шагом присваивания),</target>
        </trans-unit>
        <trans-unit id="763ce1b85e689b44ff97faf88affdaed11e7d453" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lhs&lt;/code&gt;, an lvalue that refers to an object &lt;code&gt;lcopy&lt;/code&gt; such that &lt;code&gt;decltype((lhs))&lt;/code&gt; is &lt;code&gt;LHS&lt;/code&gt;,</source>
          <target state="translated">&lt;code&gt;lhs&lt;/code&gt; , lvalue, который относится к объекту &lt;code&gt;lcopy&lt;/code&gt; , так что &lt;code&gt;decltype((lhs))&lt;/code&gt; - это &lt;code&gt;LHS&lt;/code&gt; ,</target>
        </trans-unit>
        <trans-unit id="2b8c327f19757863cbf19a339d53e0d5afe33fe5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;linear_congruential_engine&lt;/code&gt; is a random number engine based on &lt;a href=&quot;https://en.wikipedia.org/wiki/Linear_congruential_generator&quot;&gt;Linear congruential generator (LCG)&lt;/a&gt;. A LCG has a state that consists of a single integer.</source>
          <target state="translated">&lt;code&gt;linear_congruential_engine&lt;/code&gt; - механизм случайных чисел, основанный на &lt;a href=&quot;https://en.wikipedia.org/wiki/Linear_congruential_generator&quot;&gt;линейном конгруэнтном генераторе (LCG)&lt;/a&gt; . У LCG есть состояние, которое состоит из единственного целого числа.</target>
        </trans-unit>
        <trans-unit id="0b51e9a8d7e26b4195f2b7e94b0a57bcd4109928" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;link&lt;/code&gt; is not copyable but does have a defaulted move constructor and a defaulted move assignment operator. However, as users have only &lt;code&gt;const&lt;/code&gt; access to &lt;code&gt;link&lt;/code&gt; objects, these functions cannot be called in user code without invoking &lt;a href=&quot;../language/ub&quot;&gt;undefined behavior&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;link&lt;/code&gt; не может быть скопирована, но имеет конструктор перемещения по умолчанию и оператор назначения перемещения по умолчанию. Тем не менее, так как пользователи имеют только &lt;code&gt;const&lt;/code&gt; доступ к &lt;code&gt;link&lt;/code&gt; объектам, эти функции не могут быть вызваны кодом пользователя , не прибегая к &lt;a href=&quot;../language/ub&quot;&gt;неопределенному поведению&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a42862b4b4516aed99ecd46ac714cbc76bcd3114" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ll&lt;/code&gt; or &lt;code&gt;LL&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;ll&lt;/code&gt; или &lt;code&gt;LL&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3fbd2294c8228b0d41a9477a6b9cd59874805d44" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;loc&lt;/code&gt;, an object of type &lt;code&gt;X::locale_type&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;loc&lt;/code&gt; , объект типа &lt;code&gt;X::locale_type&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c8c3052ccaee4a1e8a114c753bca6e29759f1669" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lock()&lt;/code&gt; is usually not called directly: &lt;code&gt;&lt;a href=&quot;../unique_lock&quot;&gt;std::unique_lock&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../lock_guard&quot;&gt;std::lock_guard&lt;/a&gt;&lt;/code&gt; are used to manage exclusive locking.</source>
          <target state="translated">&lt;code&gt;lock()&lt;/code&gt; обычно не вызывается напрямую: &lt;code&gt;&lt;a href=&quot;../unique_lock&quot;&gt;std::unique_lock&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;../lock_guard&quot;&gt;std::lock_guard&lt;/a&gt;&lt;/code&gt; используются для управления эксклюзивной блокировкой.</target>
        </trans-unit>
        <trans-unit id="a075e9526e3f87afdd25b322a41e6af35f3545ed" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lock_shared()&lt;/code&gt; is usually not called directly: &lt;code&gt;&lt;a href=&quot;../shared_lock&quot;&gt;std::shared_lock&lt;/a&gt;&lt;/code&gt; is used to manage shared locking.</source>
          <target state="translated">&lt;code&gt;lock_shared()&lt;/code&gt; обычно не вызывается напрямую: &lt;code&gt;&lt;a href=&quot;../shared_lock&quot;&gt;std::shared_lock&lt;/a&gt;&lt;/code&gt; используется для управления общей блокировкой.</target>
        </trans-unit>
        <trans-unit id="6eed4bda9461a124aae3680bdafdaf2b3b9db713" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;long long int&lt;/code&gt;(since C++11)</source>
          <target state="translated">&lt;code&gt;long long int&lt;/code&gt; (начиная с C ++ 11)</target>
        </trans-unit>
        <trans-unit id="631749813cf9be03983337499d431fda1eace348" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;long long int&lt;/code&gt;(since C++11).</source>
          <target state="translated">&lt;code&gt;long long int&lt;/code&gt; (начиная с C ++ 11).</target>
        </trans-unit>
        <trans-unit id="b0dafe31e5994a5ce21867a198e9a54684dbded6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;long long&lt;/code&gt; - target type will have width of at least 64 bits.</source>
          <target state="translated">&lt;code&gt;long long&lt;/code&gt; - тип цели будет иметь ширину не менее 64 бит.</target>
        </trans-unit>
        <trans-unit id="f620edf133a71d4e25ca283e969ee4c9f3b69ca6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;long&lt;/code&gt; - target type will have width of at least 32 bits.</source>
          <target state="translated">&lt;code&gt;long&lt;/code&gt; - тип цели будет иметь ширину не менее 32 бит.</target>
        </trans-unit>
        <trans-unit id="e6106b1d6be411097b6601fe37141ec083d96cae" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;long&lt;/code&gt; type modifier</source>
          <target state="translated">&lt;code&gt;long&lt;/code&gt; модификатор типа long</target>
        </trans-unit>
        <trans-unit id="6cc7d1a6f4dad505abfccdbfcdd92fac7d853104" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;longjmp&lt;/code&gt; is the mechanism used in C to handle unexpected error conditions where the function cannot return meaningfully. C++ generally uses &lt;a href=&quot;../../language/exceptions&quot;&gt;exception handling&lt;/a&gt; for this purpose.</source>
          <target state="translated">&lt;code&gt;longjmp&lt;/code&gt; - это механизм, используемый в C для обработки непредвиденных ошибок, когда функция не может возвращать значение. C ++ обычно использует &lt;a href=&quot;../../language/exceptions&quot;&gt;обработку исключений&lt;/a&gt; для этой цели.</target>
        </trans-unit>
        <trans-unit id="d25f9f69a8c41a16a4eb7bc6204b6470fddab862" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;make_move_iterator&lt;/code&gt; is a convenience function template that constructs a &lt;code&gt;&lt;a href=&quot;move_iterator&quot;&gt;std::move_iterator&lt;/a&gt;&lt;/code&gt; for the given iterator &lt;code&gt;i&lt;/code&gt; with the type deduced from the type of the argument.</source>
          <target state="translated">&lt;code&gt;make_move_iterator&lt;/code&gt; - это шаблон вспомогательной функции, который создает &lt;code&gt;&lt;a href=&quot;move_iterator&quot;&gt;std::move_iterator&lt;/a&gt;&lt;/code&gt; для данного итератора &lt;code&gt;i&lt;/code&gt; с типом, выведенным из типа аргумента.</target>
        </trans-unit>
        <trans-unit id="67fc72aae3aa997980eef58fc8416c608ee1be9b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;make_reverse_iterator&lt;/code&gt; is a convenience function template that constructs a &lt;code&gt;&lt;a href=&quot;reverse_iterator&quot;&gt;std::reverse_iterator&lt;/a&gt;&lt;/code&gt; for the given iterator &lt;code&gt;i&lt;/code&gt; with the type deduced from the type of the argument.</source>
          <target state="translated">&lt;code&gt;make_reverse_iterator&lt;/code&gt; - это шаблон вспомогательной функции, который создает &lt;code&gt;&lt;a href=&quot;reverse_iterator&quot;&gt;std::reverse_iterator&lt;/a&gt;&lt;/code&gt; для данного итератора &lt;code&gt;i&lt;/code&gt; с типом, выведенным из типа аргумента.</target>
        </trans-unit>
        <trans-unit id="8643df2129d822a941644d9e55fb33513904875c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;mask_array&lt;/code&gt; to initialize with</source>
          <target state="translated">&lt;code&gt;mask_array&lt;/code&gt; для инициализации</target>
        </trans-unit>
        <trans-unit id="6051a265e3eb5ef540cc9e4026f402307e618b2a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;match_flag_type&lt;/code&gt; is a &lt;a href=&quot;../named_req/bitmasktype&quot;&gt;BitmaskType&lt;/a&gt; that specifies additional regular expression matching options.</source>
          <target state="translated">&lt;code&gt;match_flag_type&lt;/code&gt; - это &lt;a href=&quot;../named_req/bitmasktype&quot;&gt;BitmaskType,&lt;/a&gt; который определяет дополнительные параметры сопоставления регулярных выражений.</target>
        </trans-unit>
        <trans-unit id="f7969f5305d2a0f5cda3cd1317fd7c00542f472b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;mersenne_twister_engine&lt;/code&gt; is a random number engine based on &lt;a href=&quot;https://en.wikipedia.org/wiki/Mersenne_twister&quot;&gt;Mersenne Twister&lt;/a&gt; algorithm. It produces high quality unsigned integer random numbers of type &lt;code&gt;UIntType&lt;/code&gt; on the interval [0, 2w</source>
          <target state="translated">&lt;code&gt;mersenne_twister_engine&lt;/code&gt; - это механизм случайных чисел, основанный на алгоритме &lt;a href=&quot;https://en.wikipedia.org/wiki/Mersenne_twister&quot;&gt;Mersenne Twister&lt;/a&gt; . Он производит высококачественные целые случайные числа без знака типа &lt;code&gt;UIntType&lt;/code&gt; на интервале [0, 2w</target>
        </trans-unit>
        <trans-unit id="03e36b86fc41a84634e577bf6c49cf39d160cc8e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;min(&lt;a href=&quot;../../types/size_t&quot;&gt;std::size_t&lt;/a&gt;(st.width()), N) - 1&lt;/code&gt; characters are extracted (if &lt;code&gt;st.width()&lt;/code&gt; is greater than zero)</source>
          <target state="translated">&lt;code&gt;min(&lt;a href=&quot;../../types/size_t&quot;&gt;std::size_t&lt;/a&gt;(st.width()), N) - 1&lt;/code&gt; извлекается 1 символ (если &lt;code&gt;st.width()&lt;/code&gt; больше нуля)</target>
        </trans-unit>
        <trans-unit id="f69ad950aa6cd383a3875964e57fddaa56fac574" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;min&lt;/code&gt; is only meaningful for bounded types and for unbounded unsigned types, that is, types that represent an infinite set of negative values have no meaningful minimum.</source>
          <target state="translated">&lt;code&gt;min&lt;/code&gt; имеет смысл только для ограниченных типов и для неограниченных типов без знака, то есть типы, представляющие бесконечный набор отрицательных значений, не имеют значимого минимума.</target>
        </trans-unit>
        <trans-unit id="11720682258a6e6ea94f82b3b68a01ceca39d154" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;minstd_rand0&lt;/code&gt;(C++11)</source>
          <target state="translated">&lt;code&gt;minstd_rand0&lt;/code&gt;(C++11)</target>
        </trans-unit>
        <trans-unit id="6cd727f122c0fc301841d5b5bc920fce6c61a502" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;minstd_rand&lt;/code&gt;(C++11)</source>
          <target state="translated">&lt;code&gt;minstd_rand&lt;/code&gt;(C++11)</target>
        </trans-unit>
        <trans-unit id="44da149f671c50d09ff780ccb663a27eefb6a8a7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;minutes()&lt;/code&gt; returns the integral number of minutes &lt;code&gt;since_midnight&lt;/code&gt; is after &lt;code&gt;(00:00:00 + hours())&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;minutes()&lt;/code&gt; возвращает целое число минут, &lt;code&gt;since_midnight&lt;/code&gt; после &lt;code&gt;(00:00:00 + hours())&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2e2341fbef188cb5eeb260f3c23e801a73700139" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;mm&lt;/code&gt; - 2-digit minute from &lt;code&gt;timeptr-&amp;gt;tm_min&lt;/code&gt; as if printed by &lt;code&gt;sprintf&lt;/code&gt; using &lt;code&gt;%.2d&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;mm&lt;/code&gt; - двузначная минута от &lt;code&gt;timeptr-&amp;gt;tm_min&lt;/code&gt; , как если бы она была напечатана &lt;code&gt;sprintf&lt;/code&gt; с использованием &lt;code&gt;%.2d&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ad3d933f46f39e052abdb8b71c4dafb32e73d1c3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;mm&lt;/code&gt; - minutes</source>
          <target state="translated">&lt;code&gt;mm&lt;/code&gt; - минуты</target>
        </trans-unit>
        <trans-unit id="61b2a411b1194735f191e01a2375261d7904aadd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;module&lt;/code&gt;; top-level-declaration-seq(optional)</source>
          <target state="translated">&lt;code&gt;module&lt;/code&gt; ; верхний уровень декларация-сл (необязательно)</target>
        </trans-unit>
        <trans-unit id="8ac208616f1198d65bee4d69b943f7ea1ecde749" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;monotonic_buffer_resource&lt;/code&gt; can be constructed with an initial buffer. If there is no initial buffer, or if the buffer is exhausted, additional buffers are obtained from an</source>
          <target state="translated">&lt;code&gt;monotonic_buffer_resource&lt;/code&gt; может быть создан с начальным буфером. Если начальный буфер отсутствует или буфер исчерпан, дополнительные буферы получаются из</target>
        </trans-unit>
        <trans-unit id="5aceb6d7c7df1b4d24df89ff70c7e10f8baf1802" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;monotonic_buffer_resource&lt;/code&gt; is not thread-safe.</source>
          <target state="translated">&lt;code&gt;monotonic_buffer_resource&lt;/code&gt; не является потокобезопасным.</target>
        </trans-unit>
        <trans-unit id="b52eb1c48377fd49827020c8059087d06d4946e7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;month().ok() &amp;amp;&amp;amp; weekday_indexed().ok()&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;month().ok() &amp;amp;&amp;amp; weekday_indexed().ok()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="47cee466ffd7cdb9de816c8c1fcd46074df71a9d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;month().ok() &amp;amp;&amp;amp; weekday_last().ok()&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;month().ok() &amp;amp;&amp;amp; weekday_last().ok()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="daa97aa6666c88ba085bd172ef9069a910588a91" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;month().ok()&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;month().ok()&lt;/code&gt;.</target>
        </trans-unit>
        <trans-unit id="c3c964de040a242a94594eda876807048353a201" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;month&lt;/code&gt; is a &lt;a href=&quot;../named_req/triviallycopyable&quot;&gt;TriviallyCopyable&lt;/a&gt;&lt;a href=&quot;../named_req/standardlayouttype&quot;&gt;StandardLayoutType&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;month&lt;/code&gt; - это &lt;a href=&quot;../named_req/triviallycopyable&quot;&gt;TriviallyCopyable &lt;/a&gt;&lt;a href=&quot;../named_req/standardlayouttype&quot;&gt;StandardLayoutType&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="edc5d1e07f39b981842e107954ae7debbb92ead2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;month_day&lt;/code&gt; is a &lt;a href=&quot;../named_req/triviallycopyable&quot;&gt;TriviallyCopyable&lt;/a&gt;&lt;a href=&quot;../named_req/standardlayouttype&quot;&gt;StandardLayoutType&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;month_day&lt;/code&gt; - это &lt;a href=&quot;../named_req/triviallycopyable&quot;&gt;TriviallyCopyable &lt;/a&gt;&lt;a href=&quot;../named_req/standardlayouttype&quot;&gt;StandardLayoutType&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="721ab309caf01adaf72782284d2873bf3214d819" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;month_day_last&lt;/code&gt; is a &lt;a href=&quot;../named_req/triviallycopyable&quot;&gt;TriviallyCopyable&lt;/a&gt;&lt;a href=&quot;../named_req/standardlayouttype&quot;&gt;StandardLayoutType&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;month_day_last&lt;/code&gt; является &lt;a href=&quot;../named_req/triviallycopyable&quot;&gt;TriviallyCopyable &lt;/a&gt;&lt;a href=&quot;../named_req/standardlayouttype&quot;&gt;StandardLayoutType&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="03f5d76987240a4e54cba6e45b0324fc39727c0f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;month_weekday&lt;/code&gt; is a &lt;a href=&quot;../named_req/triviallycopyable&quot;&gt;TriviallyCopyable&lt;/a&gt;&lt;a href=&quot;../named_req/standardlayouttype&quot;&gt;StandardLayoutType&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;month_weekday&lt;/code&gt; - это &lt;a href=&quot;../named_req/triviallycopyable&quot;&gt;TriviallyCopyable &lt;/a&gt;&lt;a href=&quot;../named_req/standardlayouttype&quot;&gt;StandardLayoutType&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6a16aa97c2bcf582298bbeecd9cf526963d42306" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;month_weekday_last&lt;/code&gt; is a &lt;a href=&quot;../named_req/triviallycopyable&quot;&gt;TriviallyCopyable&lt;/a&gt;&lt;a href=&quot;../named_req/standardlayouttype&quot;&gt;StandardLayoutType&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;month_weekday_last&lt;/code&gt; является &lt;a href=&quot;../named_req/triviallycopyable&quot;&gt;TriviallyCopyable &lt;/a&gt;&lt;a href=&quot;../named_req/standardlayouttype&quot;&gt;StandardLayoutType&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b04124853544caec5fe640efce4338b719310311" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;move_if_noexcept&lt;/code&gt; obtains an rvalue reference to its argument if its move constructor does not throw exceptions or if there is no copy constructor (move-only type), otherwise obtains an lvalue reference to its argument. It is typically used to combine move semantics with strong exception guarantee.</source>
          <target state="translated">&lt;code&gt;move_if_noexcept&lt;/code&gt; получает ссылку на значение rvalue для своего аргумента, если его конструктор перемещения не генерирует исключения или если нет конструктора копирования (тип только для перемещения), в противном случае получает ссылку lvalue на свой аргумент. Обычно используется для объединения семантики перемещения с гарантией строгих исключений.</target>
        </trans-unit>
        <trans-unit id="dcab2982ae60519dfa11b3b8789ca936b139623b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;mt19937&lt;/code&gt;(C++11)</source>
          <target state="translated">&lt;code&gt;mt19937&lt;/code&gt;(C++11)</target>
        </trans-unit>
        <trans-unit id="7711b5ec07f8028b86083b76a35f48f55d22ef28" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;mt19937_64&lt;/code&gt;(C++11)</source>
          <target state="translated">&lt;code&gt;mt19937_64&lt;/code&gt;(C++11)</target>
        </trans-unit>
        <trans-unit id="6d3eef6ccbd823c22c01d70b739ba0f2bfee3dfd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;multiline&lt;/code&gt;(C++17)</source>
          <target state="translated">&lt;code&gt;multiline&lt;/code&gt;(C++17)</target>
        </trans-unit>
        <trans-unit id="9596b73eb0b017538a63ae7bb20302807cf463a7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;mutable&lt;/code&gt; - does not affect storage duration or linkage. See &lt;a href=&quot;cv&quot;&gt;const/volatile&lt;/a&gt; for the explanation.</source>
          <target state="translated">&lt;code&gt;mutable&lt;/code&gt; - не влияет на длительность хранения или связь. Смотрите &lt;a href=&quot;cv&quot;&gt;const / volatile&lt;/a&gt; для объяснения.</target>
        </trans-unit>
        <trans-unit id="6ef657e8a1674cf45aa9164d0e015bb5350196c6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;mutable&lt;/code&gt; - permits modification of the class member declared mutable even if the containing object is declared const.</source>
          <target state="translated">&lt;code&gt;mutable&lt;/code&gt; - разрешает изменение члена класса, объявленного mutable, даже если содержащий объект объявлен как const.</target>
        </trans-unit>
        <trans-unit id="99b6b7266dbef06a872fb4dd7eb9bedc727ccea2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;mutable&lt;/code&gt; specifier</source>
          <target state="translated">&lt;code&gt;mutable&lt;/code&gt; спецификатор</target>
        </trans-unit>
        <trans-unit id="d3224dab8827312710beba51a3e704b17dc0c841" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;mutable&lt;/code&gt; type specifier</source>
          <target state="translated">&lt;code&gt;mutable&lt;/code&gt; спецификатор изменяемого типа</target>
        </trans-unit>
        <trans-unit id="4df916efe552ebd362d8e85d53164a72d1c6e74c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;mutable&lt;/code&gt;: allows body to modify the parameters captured by copy, and to call their non-const member functions</source>
          <target state="translated">&lt;code&gt;mutable&lt;/code&gt; : позволяет body изменять параметры, захваченные копией, и вызывать их неконстантные функции-члены</target>
        </trans-unit>
        <trans-unit id="0be5eed25c0bd5a04f1885d02d6e5cbef563aed2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;mutex&lt;/code&gt; offers exclusive, non-recursive ownership semantics:</source>
          <target state="translated">&lt;code&gt;mutex&lt;/code&gt; предлагает эксклюзивную нерекурсивную семантику владения:</target>
        </trans-unit>
        <trans-unit id="83c65f0571699204cd08bdc45cd8a861d113d0c9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;mutex_type&lt;/code&gt;(if &lt;code&gt;sizeof...(MutexTypes)==1&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;mutex_type&lt;/code&gt; (если &lt;code&gt;sizeof...(MutexTypes)==1&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="e2678c37d2ffbbbaca79109eaaac8e0743f9a1ac" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;n + a&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;n + a&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1df4f23ae577313cfa56d7bed35293c0435e2f57" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;n, i, j&lt;/code&gt;, values of type &lt;code&gt;&lt;a href=&quot;../types/size_t&quot;&gt;std::size_t&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;n, i, j&lt;/code&gt; , значения типа &lt;code&gt;&lt;a href=&quot;../types/size_t&quot;&gt;std::size_t&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3f97ee369c6a99450c231306794325ac21356db4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;n&lt;/code&gt; can be both positive or negative</source>
          <target state="translated">&lt;code&gt;n&lt;/code&gt; может быть как положительным, так и отрицательным</target>
        </trans-unit>
        <trans-unit id="f3865fbe8a147b296b97a18587ebb8451959508c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;n&lt;/code&gt;, a value of type &lt;code&gt;X::size_type&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;n&lt;/code&gt; , значение типа &lt;code&gt;X::size_type&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b3733ce69ea4fb00b43cf5dd8c6fe20f531dd2bf" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;n&lt;/code&gt;, a value of type &lt;code&gt;allocator_traits&amp;lt;A&amp;gt;::size_type&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;n&lt;/code&gt; , значение типа &lt;code&gt;allocator_traits&amp;lt;A&amp;gt;::size_type&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="440dd0a1c40939c6592cd89ff3cbc07504417e0b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;n&lt;/code&gt;, an integer of type &lt;code&gt;difference_type&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;n&lt;/code&gt; , целое число типа &lt;code&gt;difference_type&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="353801c2154651bb24a1e0cbc3079409fcae6183" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;n&lt;/code&gt;, an integral value</source>
          <target state="translated">&lt;code&gt;n&lt;/code&gt; , интегральное значение</target>
        </trans-unit>
        <trans-unit id="931550a878f4982e02bd2763b6cf378a1f759168" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;namespace A::B::inline C { ... }&lt;/code&gt; is equivalent to &lt;code&gt;namespace A::B { inline namespace C { ... } }&lt;/code&gt;. &lt;code&gt;inline&lt;/code&gt; may appear in front of every namespace name except the first: &lt;code&gt;namespace A::inline B::C {}&lt;/code&gt; is equivalent to &lt;code&gt;namespace A { inline namespace B { namespace C {} } }&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;namespace A::B::inline C { ... }&lt;/code&gt; эквивалентно &lt;code&gt;namespace A::B { inline namespace C { ... } }&lt;/code&gt; . &lt;code&gt;inline&lt;/code&gt; может появляться перед каждым именем пространства имен, кроме первого: &lt;code&gt;namespace A::inline B::C {}&lt;/code&gt; эквивалентно &lt;code&gt;namespace A { inline namespace B { namespace C {} } }&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d5f1a83961f9db377d752c83fd741a490a7b4c57" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;namespace&lt;/code&gt; { declarations }</source>
          <target state="translated">&lt;code&gt;namespace&lt;/code&gt; {объявления}</target>
        </trans-unit>
        <trans-unit id="9622ab87c139ab1b29defe9f2aa9a39bec35b7d5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;namespace&lt;/code&gt;alias_name = &lt;code&gt;::&lt;/code&gt;ns_name&lt;code&gt;;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;namespace&lt;/code&gt; alias_name = &lt;code&gt;::&lt;/code&gt; ns_name &lt;code&gt;;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d6d8088f30582e3305ca05a1fa13fddc31666468" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;namespace&lt;/code&gt;alias_name = nested_name&lt;code&gt;::&lt;/code&gt;ns_name&lt;code&gt;;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;namespace&lt;/code&gt; alias_name = nested_name &lt;code&gt;::&lt;/code&gt; ns_name &lt;code&gt;;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6bec759c3dfa6a683cbe5714f88a0000d1d61d31" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;namespace&lt;/code&gt;alias_name = ns_name&lt;code&gt;;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;namespace&lt;/code&gt; alias_name = ns_name &lt;code&gt;;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="bc800922ab5b9a8debe963270907cd8c2afa96a2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;namespace&lt;/code&gt;name&lt;code&gt;=&lt;/code&gt;qualified-namespace&lt;code&gt;;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;namespace&lt;/code&gt;name&lt;code&gt;=&lt;/code&gt;qualified-namespace&lt;code&gt;;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6d1118e7b8e29f999ae87d047d0e161a70da230a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;namespace&lt;/code&gt;ns_name { declarations }</source>
          <target state="translated">&lt;code&gt;namespace&lt;/code&gt; ns_name {объявления}</target>
        </trans-unit>
        <trans-unit id="f6ba9baaa556978003350c542bf864cccb3b0cff" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;namespace&lt;/code&gt;ns_name&lt;code&gt;::&lt;/code&gt;&lt;code&gt;inline&lt;/code&gt;(since C++20)(optional)name { declarations }</source>
          <target state="translated">&lt;code&gt;namespace&lt;/code&gt; ns_name &lt;code&gt;::&lt;/code&gt; &lt;code&gt;inline&lt;/code&gt; (начиная с C ++ 20) (необязательно) name {объявления}</target>
        </trans-unit>
        <trans-unit id="5dcc4cb18db587b8b2ec5a9937617fe8da19fded" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;native_handle_type&lt;/code&gt;(optional)</source>
          <target state="translated">&lt;code&gt;native_handle_type&lt;/code&gt;(optional)</target>
        </trans-unit>
        <trans-unit id="d168126fb676dc5ba1f8da9c420c3b60cc37638c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;new &lt;/code&gt;T</source>
          <target state="translated">&lt;code&gt;new &lt;/code&gt; Т</target>
        </trans-unit>
        <trans-unit id="294bdbf6d4e099fa80b89bb6b29ca56b89bcdbe4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;new &lt;/code&gt;T&lt;code&gt;(&lt;/code&gt;&lt;code&gt;)&lt;/code&gt;(until C++03).</source>
          <target state="translated">&lt;code&gt;new &lt;/code&gt; T &lt;code&gt;(&lt;/code&gt; &lt;code&gt;)&lt;/code&gt; (до C ++ 03).</target>
        </trans-unit>
        <trans-unit id="c507be339e01230b2a2421be72fed9ed3d2ba709" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;new&lt;/code&gt; expression</source>
          <target state="translated">&lt;code&gt;new&lt;/code&gt; выражение</target>
        </trans-unit>
        <trans-unit id="6a49623f29f5f3dc93f2bc1d8e6afd869037d67a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;new&lt;/code&gt;&lt;code&gt;new[]&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;new&lt;/code&gt;&lt;code&gt;new[]&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e1f9ab9b83b0ff1cfbec3fa0f2657bc3efa77e4f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;new&lt;/code&gt;T&lt;code&gt;()&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;new&lt;/code&gt;T&lt;code&gt;()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d30056c5f449d74627c825a4d9dbb67095bac924" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;new&lt;/code&gt;T&lt;code&gt;(&lt;/code&gt;args, ...&lt;code&gt;)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;new&lt;/code&gt; T &lt;code&gt;(&lt;/code&gt; args, ... &lt;code&gt;)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9b9ae2f1a0eabfc0dc5e948662745d5550e3a806" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;new&lt;/code&gt;T&lt;code&gt;{ &lt;/code&gt;arg1, arg2, ...&lt;code&gt;}&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;new&lt;/code&gt; T &lt;code&gt;{ &lt;/code&gt; arg1, arg2, ... &lt;code&gt;}&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="010e3be45f98751f90c9186436cda7920ef235b0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;new&lt;/code&gt;T&lt;code&gt;{}&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;new&lt;/code&gt;T&lt;code&gt;{}&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a84b23a2f738a119793f5305f7d1d6ee1cb7ed8f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;new_p&lt;/code&gt; ends with dot or with dot-dot</source>
          <target state="translated">&lt;code&gt;new_p&lt;/code&gt; заканчивается точкой или точкой</target>
        </trans-unit>
        <trans-unit id="dc967e31638fb13dc7b69a3a369bace3b889e413" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;new_p&lt;/code&gt; names a non-existing directory ending with a directory separator</source>
          <target state="translated">&lt;code&gt;new_p&lt;/code&gt; называет несуществующий каталог, заканчивающийся разделителем каталога</target>
        </trans-unit>
        <trans-unit id="fbd974c99b0ab7a6248a32ef40aa52756bdbd908" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;node_type&lt;/code&gt;(since C++17)</source>
          <target state="translated">&lt;code&gt;node_type&lt;/code&gt; (начиная с C ++ 17)</target>
        </trans-unit>
        <trans-unit id="acc081ae343fc7533936440595e83dc55dd44c03" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;noexcept(&lt;/code&gt;expression&lt;code&gt;)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;noexcept(&lt;/code&gt;expression&lt;code&gt;)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3c24e7cdbea9d139de0946f0b05b56febebba7c1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;noexcept&lt;/code&gt; is an improved version of &lt;a href=&quot;except_spec&quot;&gt;&lt;code&gt;throw()&lt;/code&gt;&lt;/a&gt;, which is deprecated in C++11. Unlike pre-C++17 &lt;a href=&quot;except_spec&quot;&gt;&lt;code&gt;throw()&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;noexcept&lt;/code&gt; will not call &lt;code&gt;&lt;a href=&quot;../error/exception/unexpected&quot;&gt;std::unexpected&lt;/a&gt;&lt;/code&gt; and may or may not unwind the stack, which potentially allows the compiler to implement &lt;code&gt;noexcept&lt;/code&gt; without the runtime overhead of &lt;a href=&quot;except_spec&quot;&gt;&lt;code&gt;throw()&lt;/code&gt;&lt;/a&gt;. As of C++17, &lt;code&gt;throw()&lt;/code&gt; is redefined to be an exact equivalent of &lt;code&gt;noexcept(true)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;noexcept&lt;/code&gt; - улучшенная версия &lt;a href=&quot;except_spec&quot;&gt; &lt;code&gt;throw()&lt;/code&gt; &lt;/a&gt; , которая устарела в C ++ 11. В отличие от &lt;a href=&quot;except_spec&quot;&gt; &lt;code&gt;throw()&lt;/code&gt; &lt;/a&gt; до C ++ 17 , &lt;code&gt;noexcept&lt;/code&gt; не будет вызывать &lt;code&gt;&lt;a href=&quot;../error/exception/unexpected&quot;&gt;std::unexpected&lt;/a&gt;&lt;/code&gt; и может развернуть или не развернуть стек, что потенциально позволяет компилятору реализовать &lt;code&gt;noexcept&lt;/code&gt; без издержек во время выполнения &lt;a href=&quot;except_spec&quot;&gt; &lt;code&gt;throw()&lt;/code&gt; &lt;/a&gt; . Начиная с C ++ 17, &lt;code&gt;throw()&lt;/code&gt; переопределяется как точный эквивалент &lt;code&gt;noexcept(true)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="015e6404e45474d0f4b21fb1a47ce8c5d654560a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;noexcept&lt;/code&gt; operator</source>
          <target state="translated">&lt;code&gt;noexcept&lt;/code&gt; оператора</target>
        </trans-unit>
        <trans-unit id="a1b14049eecc97923d6024027c8c2f7ace1fca8c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;noexcept&lt;/code&gt; specifications</source>
          <target state="translated">&lt;code&gt;noexcept&lt;/code&gt; спецификаций</target>
        </trans-unit>
        <trans-unit id="65ff1fa2e72e419dda4d71ee9e6093765d18540f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;noexcept&lt;/code&gt; specifier</source>
          <target state="translated">&lt;code&gt;noexcept&lt;/code&gt; спецификатора</target>
        </trans-unit>
        <trans-unit id="e1bbd04e13e487469c0bd8e54d5383313ce5238e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;not1&lt;/code&gt; is a helper function to create a function object that returns the complement of the unary predicate function passed. The function object created is of type &lt;code&gt;&lt;a href=&quot;unary_negate&quot;&gt;std::unary_negate&lt;/a&gt;&amp;lt;&lt;a href=&quot;../../concepts/predicate&quot;&gt;Predicate&lt;/a&gt;&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;not1&lt;/code&gt; является вспомогательной функцией для создания объекта функции, который возвращает дополнение переданной функции унарного предиката. Созданный объект функции имеет тип &lt;code&gt;&lt;a href=&quot;unary_negate&quot;&gt;std::unary_negate&lt;/a&gt;&amp;lt;&lt;a href=&quot;../../concepts/predicate&quot;&gt;Predicate&lt;/a&gt;&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1cd72ce45ba072d1b92b5fd8c78ecd167e104d93" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;not2&lt;/code&gt; is a helper function to create a function object that returns the complement of the binary predicate function passed. The function object created is of type &lt;code&gt;&lt;a href=&quot;binary_negate&quot;&gt;std::binary_negate&lt;/a&gt;&amp;lt;&lt;a href=&quot;../../concepts/predicate&quot;&gt;Predicate&lt;/a&gt;&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;not2&lt;/code&gt; является вспомогательной функцией для создания объекта функции, который возвращает дополнение переданной двоичной функции предиката. Созданный объект функции имеет тип &lt;code&gt;&lt;a href=&quot;binary_negate&quot;&gt;std::binary_negate&lt;/a&gt;&amp;lt;&lt;a href=&quot;../../concepts/predicate&quot;&gt;Predicate&lt;/a&gt;&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="02eeb439232745421d8c2bcc11cb50225d202710" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;not_fn&lt;/code&gt; is intended to replace the C++03-era negators &lt;code&gt;&lt;a href=&quot;not1&quot;&gt;std::not1&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;not2&quot;&gt;std::not2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;not_fn&lt;/code&gt; предназначен для замены отрицателей C ++ 03 эпохи &lt;code&gt;&lt;a href=&quot;not1&quot;&gt;std::not1&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;not2&quot;&gt;std::not2&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0f4dcb3230322b63393ab0b70a62509500a82e0b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;notify_all_at_thread_exit&lt;/code&gt; provides a mechanism to notify other threads that a given thread has completely finished, including destroying all &lt;a href=&quot;../keyword/thread_local&quot;&gt;thread_local&lt;/a&gt; objects. It operates as follows:</source>
          <target state="translated">&lt;code&gt;notify_all_at_thread_exit&lt;/code&gt; предоставляет механизм для уведомления других потоков о том, что данный поток полностью завершен, включая уничтожение всех объектов &lt;a href=&quot;../keyword/thread_local&quot;&gt;thread_local&lt;/a&gt; . Он работает следующим образом:</target>
        </trans-unit>
        <trans-unit id="b5fef976c2bc54a725b0f87c8ce3dd90052df0e1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;np != p&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;np != p&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="75c1ce30646d639b7e7202895f501a3da1d7b19a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;np == p&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;np == p&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0cef01ebf9a66a13171933809f6193371fdbd2d4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;nth&lt;/code&gt; may be the end iterator, in this case the function has no effect.</source>
          <target state="translated">&lt;code&gt;nth&lt;/code&gt; может быть конечным итератором, в этом случае функция не действует.</target>
        </trans-unit>
        <trans-unit id="e6bd9eb9e2df463fbc055a140631d32dfae3ee6a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;nth_element&lt;/code&gt; is a partial sorting algorithm that rearranges elements in &lt;code&gt;[first, last)&lt;/code&gt; such that:</source>
          <target state="translated">&lt;code&gt;nth_element&lt;/code&gt; - это алгоритм частичной сортировки, который переставляет элементы в &lt;code&gt;[first, last)&lt;/code&gt; , что:</target>
        </trans-unit>
        <trans-unit id="7f47a446144093bb6aef8760b8abc76c6071fd0d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;o + p&lt;/code&gt; has a type convertible to &lt;code&gt;fpos&amp;lt;State&amp;gt;&lt;/code&gt; and the result of the conversion is equal to &lt;code&gt;p + o&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;o + p&lt;/code&gt; имеет тип, преобразуемый в &lt;code&gt;fpos&amp;lt;State&amp;gt;&lt;/code&gt; а результат преобразования равен &lt;code&gt;p + o&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2eb351964003cae258c50dfe3a35ac417ec19e69" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;o&lt;/code&gt;, a value of some type that is writable to the output iterator (there may be multiple types that are writable, e.g. if &lt;code&gt;operator=&lt;/code&gt; may be a template. There is no notion of &lt;code&gt;value_type&lt;/code&gt; as for the input iterators)</source>
          <target state="translated">&lt;code&gt;o&lt;/code&gt; , значение некоторого типа, которое может быть &lt;code&gt;value_type&lt;/code&gt; в выходной итератор (может быть несколько типов, которые могут быть записаны, например, если &lt;code&gt;operator=&lt;/code&gt; может быть шаблоном. Нет никакого значения value_type, как для входных итераторов)</target>
        </trans-unit>
        <trans-unit id="7906f5cbf1f50d7b47f9b1710c48448bbf1f85a8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ob&lt;/code&gt; is an &lt;a href=&quot;outputiterator&quot;&gt;LegacyOutputIterator&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;ob&lt;/code&gt; является &lt;a href=&quot;outputiterator&quot;&gt;LegacyOutputIterator&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="49c9793bb09dc0351d1b52cd8fbd503e82f4dc95" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;offsetof&lt;/code&gt; cannot be implemented in standard C++ and requires compiler support: &lt;a href=&quot;https://github.com/gcc-mirror/gcc/blob/gcc-7_1_0-release/gcc/ginclude/stddef.h#L416-L417&quot;&gt;GCC&lt;/a&gt;, &lt;a href=&quot;https://github.com/llvm-mirror/clang/blob/release_70/lib/Headers/stddef.h#L120&quot;&gt;LLVM&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;offsetof&lt;/code&gt; не может быть реализован в стандарте C ++ и требует поддержки компилятора: &lt;a href=&quot;https://github.com/gcc-mirror/gcc/blob/gcc-7_1_0-release/gcc/ginclude/stddef.h#L416-L417&quot;&gt;GCC&lt;/a&gt; , &lt;a href=&quot;https://github.com/llvm-mirror/clang/blob/release_70/lib/Headers/stddef.h#L120&quot;&gt;LLVM&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1550d528d81c9513ee291d3d137ea795ea16e22e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;offsetof&lt;/code&gt; throws no exceptions; the expression &lt;code&gt;noexcept(offsetof(type, member))&lt;/code&gt; always evaluates to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;offsetof&lt;/code&gt; не создает исключений; выражение &lt;code&gt;noexcept(offsetof(type, member))&lt;/code&gt; всегда оценивается как &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="10d8e5e2e6c2fc83be27f282f8161832ab2f139d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;old_p&lt;/code&gt; is a directory which is an ancestor of &lt;code&gt;new_p&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;old_p&lt;/code&gt; - это каталог, который является предком &lt;code&gt;new_p&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="71d44d78011719f149c165478becc563edf2889e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;op1&lt;/code&gt; or &lt;code&gt;op2&lt;/code&gt; must not have side effects.</source>
          <target state="translated">&lt;code&gt;op1&lt;/code&gt; или &lt;code&gt;op2&lt;/code&gt; не должны иметь побочных эффектов.</target>
        </trans-unit>
        <trans-unit id="adad2a941f6ab3ecdf96f65d8ae11328f5ae81d9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;op1&lt;/code&gt; or &lt;code&gt;op2&lt;/code&gt; must not invalidate any iterators, including the end iterators, or modify any elements of the range involved.</source>
          <target state="translated">&lt;code&gt;op1&lt;/code&gt; или &lt;code&gt;op2&lt;/code&gt; не должны делать недействительными какие-либо итераторы, включая конечные итераторы, или изменять какие-либо элементы соответствующего диапазона.</target>
        </trans-unit>
        <trans-unit id="112cde45940f65461c5785534ec8f7c430d7e092" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;op&lt;/code&gt; must not have side effects.</source>
          <target state="translated">&lt;code&gt;op&lt;/code&gt; не должно иметь побочных эффектов.</target>
        </trans-unit>
        <trans-unit id="086dc8f46b9d3654c7787174b89cec865eea90f6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;op&lt;/code&gt; must not invalidate any iterators, including the end iterators, nor modify any elements of the range involved, and also *last.</source>
          <target state="translated">&lt;code&gt;op&lt;/code&gt; не должен делать недействительными какие-либо итераторы, включая конечные итераторы, ни изменять какие-либо элементы соответствующего диапазона, а также * last.</target>
        </trans-unit>
        <trans-unit id="9b5370c2bec0e4b78acfaa61dec8cb748135b0c7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;op&lt;/code&gt; must not invalidate any iterators, including the end iterators, or modify any elements of the range involved.</source>
          <target state="translated">&lt;code&gt;op&lt;/code&gt; не должен делать недействительными какие-либо итераторы, включая конечные итераторы, или изменять любые элементы этого диапазона.</target>
        </trans-unit>
        <trans-unit id="495903ba6e724d674ab4a75b0dcf1c8280f57c89" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;op&lt;/code&gt; must not invalidate any iterators, including the end iterators, or modify any elements of the ranges involved.</source>
          <target state="translated">&lt;code&gt;op&lt;/code&gt; не должен делать недействительными какие-либо итераторы, включая конечные итераторы, или изменять любые элементы задействованных диапазонов</target>
        </trans-unit>
        <trans-unit id="43436629c08c4505f761868c26d4a01bac6a1d2a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;open()&lt;/code&gt; is typically called through the constructor or the &lt;code&gt;open()&lt;/code&gt; member function of &lt;code&gt;&lt;a href=&quot;../basic_fstream&quot;&gt;std::basic_fstream&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;open()&lt;/code&gt; обычно вызывается через конструктор или функцию-член &lt;code&gt;open()&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;../basic_fstream&quot;&gt;std::basic_fstream&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7728a14a8b819f8a9d76b6870c043331add54f2c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;open_mode&lt;/code&gt;(deprecated)</source>
          <target state="translated">&lt;code&gt;open_mode&lt;/code&gt;(deprecated)</target>
        </trans-unit>
        <trans-unit id="f764e14352e8d6fb26fb5254da595a18b3bfaeb3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;operator&amp;gt;&amp;gt;&lt;/code&gt;, when called on the return value of &lt;code&gt;&lt;a href=&quot;../io/manip/get_money&quot;&gt;std::get_money&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;operator&amp;gt;&amp;gt;&lt;/code&gt; , когда &lt;code&gt;&lt;a href=&quot;../io/manip/get_money&quot;&gt;std::get_money&lt;/a&gt;&lt;/code&gt; на возвращаемое значение std :: get_money</target>
        </trans-unit>
        <trans-unit id="dca1a1540e1cce4520f29eb1b44ee1c6ca652a14" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;operator&amp;lt;&amp;lt; &lt;/code&gt;, when called on the return value of &lt;code&gt;&lt;a href=&quot;../io/manip/put_money&quot;&gt;std::put_money&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;operator&amp;lt;&amp;lt; &lt;/code&gt; , когда &lt;code&gt;&lt;a href=&quot;../io/manip/put_money&quot;&gt;std::put_money&lt;/a&gt;&lt;/code&gt; на возвращаемое значение std :: put_money</target>
        </trans-unit>
        <trans-unit id="9691a1cc99507551131eb3c4925d3064a98d3083" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;operator&amp;lt;&lt;/code&gt; is a strict weak ordering relation</source>
          <target state="translated">&lt;code&gt;operator&amp;lt;&lt;/code&gt; является строгим строгим отношением порядка</target>
        </trans-unit>
        <trans-unit id="64ed06c8ab9f156add5a77b5c874e04ef517b4db" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;operator*&lt;/code&gt; and &lt;code&gt;operator-&amp;gt;&lt;/code&gt; provide access to the object owned by &lt;code&gt;*this&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;operator*&lt;/code&gt; и &lt;code&gt;operator-&amp;gt;&lt;/code&gt; предоставляют доступ к объекту, принадлежащему &lt;code&gt;*this&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9233aa3b7f89164727a126de9342f35da81a913c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;operator+&lt;/code&gt; and &lt;code&gt;operator-&lt;/code&gt; such that, for an object &lt;code&gt;p&lt;/code&gt; of type (possibly const) &lt;code&gt;fpos&amp;lt;State&amp;gt;&lt;/code&gt; and an object &lt;code&gt;o&lt;/code&gt; of type (possibly const) &lt;code&gt;&lt;a href=&quot;streamoff&quot;&gt;std::streamoff&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;operator+&lt;/code&gt; и &lt;code&gt;operator-&lt;/code&gt; такие, что для объекта &lt;code&gt;p&lt;/code&gt; типа (возможно, const) &lt;code&gt;fpos&amp;lt;State&amp;gt;&lt;/code&gt; и объекта &lt;code&gt;o&lt;/code&gt; типа (возможно, const) &lt;code&gt;&lt;a href=&quot;streamoff&quot;&gt;std::streamoff&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3ee3af128ed53550cbdd7518cd7ca15a1967ff13" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;operator+=&lt;/code&gt; and &lt;code&gt;operator-=&lt;/code&gt; which can accept a (possibly const) &lt;code&gt;&lt;a href=&quot;streamoff&quot;&gt;std::streamoff&lt;/a&gt;&lt;/code&gt; and adds/subtracts it from the stored offset, respectively.</source>
          <target state="translated">&lt;code&gt;operator+=&lt;/code&gt; и &lt;code&gt;operator-=&lt;/code&gt; , которые могут принимать (возможно, const) &lt;code&gt;&lt;a href=&quot;streamoff&quot;&gt;std::streamoff&lt;/a&gt;&lt;/code&gt; и добавлять / вычитать его из сохраненного смещения соответственно.</target>
        </trans-unit>
        <trans-unit id="7de0e0de71209395ce1649bdf944473e9d832ab6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;operator-&lt;/code&gt; which can subtract two objects of type (possibly const) &lt;code&gt;std::fpos&lt;/code&gt; producing an &lt;code&gt;&lt;a href=&quot;streamoff&quot;&gt;std::streamoff&lt;/a&gt;&lt;/code&gt;, such that for two such objects &lt;code&gt;p&lt;/code&gt; and &lt;code&gt;q&lt;/code&gt;, &lt;code&gt;p == q + (p - q)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;operator-&lt;/code&gt; который может вычесть два объекта типа (возможно, const) &lt;code&gt;std::fpos&lt;/code&gt; создающих &lt;code&gt;&lt;a href=&quot;streamoff&quot;&gt;std::streamoff&lt;/a&gt;&lt;/code&gt; , так что для двух таких объектов &lt;code&gt;p&lt;/code&gt; и &lt;code&gt;q&lt;/code&gt; , &lt;code&gt;p == q + (p - q)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="67f0f43b79f175c617cfd759b4bd4ed9e48caca2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;operator.&lt;/code&gt; cannot be overloaded, and for &lt;code&gt;operator-&amp;gt;&lt;/code&gt;, in &lt;a href=&quot;overload_resolution#Call_to_an_overloaded_operator&quot;&gt;overload resolution against user-defined operators&lt;/a&gt;, the built-in operator does not introduce any additional function signatures: built-in &lt;code&gt;operator-&amp;gt;&lt;/code&gt; does not apply if there exists an overloaded &lt;code&gt;operator-&amp;gt;&lt;/code&gt; that is a &lt;a href=&quot;overload_resolution#Viable_functions&quot;&gt;viable function&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;operator.&lt;/code&gt; не может быть перегружен, и для &lt;code&gt;operator-&amp;gt;&lt;/code&gt; в &lt;a href=&quot;overload_resolution#Call_to_an_overloaded_operator&quot;&gt;разрешении перегрузки для пользовательских операторов&lt;/a&gt; встроенный оператор не вводит никаких дополнительных сигнатур функций: встроенный &lt;code&gt;operator-&amp;gt;&lt;/code&gt; не применяется, если существует перегруженный &lt;code&gt;operator-&amp;gt;&lt;/code&gt; тот это &lt;a href=&quot;overload_resolution#Viable_functions&quot;&gt;жизнеспособная функция&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="fbb3ca3c68671c35cfb1ef33d64b5f210f898ea7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;operator&lt;/code&gt;&lt;code&gt;&quot;&quot;&lt;/code&gt;identifier</source>
          <target state="translated">&lt;code&gt;operator&lt;/code&gt;&lt;code&gt;&quot;&quot;&lt;/code&gt;identifier</target>
        </trans-unit>
        <trans-unit id="239e361f041ad35c6ff0532443ae874a6c92e877" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;operator&lt;/code&gt;&lt;code&gt;&quot;&quot;&lt;/code&gt;suffix-identifier</source>
          <target state="translated">&lt;code&gt;operator&lt;/code&gt;&lt;code&gt;&quot;&quot;&lt;/code&gt;suffix-identifier</target>
        </trans-unit>
        <trans-unit id="6999a5c6afb70992d316d3b394d63adc44382529" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;operator&lt;/code&gt;&lt;code&gt;delete []&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;operator&lt;/code&gt; &lt;code&gt;delete []&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="31deec09e57eb86531b56b163c9a128d786f83c3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;operator&lt;/code&gt;&lt;code&gt;delete&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;operator&lt;/code&gt;&lt;code&gt;delete&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="80d9c23f95f593132a04ef27cb5eb947186e566a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;operator&lt;/code&gt;&lt;code&gt;new []&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;operator&lt;/code&gt; &lt;code&gt;new []&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ec719697fcb83b62494cce9f446b2b5a748a0d6c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;operator&lt;/code&gt;&lt;code&gt;new&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;operator&lt;/code&gt;&lt;code&gt;new&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8fbab894de22dc4b06b8900ff94ce982b3de0a6c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;operator&lt;/code&gt;conversion-type-id</source>
          <target state="translated">&lt;code&gt;operator&lt;/code&gt;conversion-type-id</target>
        </trans-unit>
        <trans-unit id="b07d3291d1d4bba2bd2c34bc2cfd3a5561e0e78d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;operator&lt;/code&gt;op</source>
          <target state="translated">&lt;code&gt;operator&lt;/code&gt;op</target>
        </trans-unit>
        <trans-unit id="2909dcdcc0a9cbd2fda55e2078d1128f224c276b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;operator&lt;/code&gt;type</source>
          <target state="translated">&lt;code&gt;operator&lt;/code&gt;type</target>
        </trans-unit>
        <trans-unit id="c4f0d5823ef995b3af1b29584894a58d6ec4b0d9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;operator&lt;/code&gt;user-defined-string-literal(since C++14)</source>
          <target state="translated">&lt;code&gt;operator&lt;/code&gt; определяемый пользователем строковый литерал (начиная с C ++ 14)</target>
        </trans-unit>
        <trans-unit id="fae38b8e726a3b72cca21c5813ed5594e4001192" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;operator=(X&amp;amp;) = default&lt;/code&gt; was non-trivial</source>
          <target state="translated">&lt;code&gt;operator=(X&amp;amp;) = default&lt;/code&gt; было нетривиальным</target>
        </trans-unit>
        <trans-unit id="63dc6a1b69fef825c68e024e1e1431dc194dc2e7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;operator==&lt;/code&gt; and &lt;code&gt;operator!=&lt;/code&gt; that compare two objects of type (possibly const) &lt;code&gt;std::fpos&lt;/code&gt; and returns a value of type convertible to &lt;code&gt;bool&lt;/code&gt;. &lt;code&gt;p != q&lt;/code&gt; is equivalent to &lt;code&gt;!(p == q)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;operator==&lt;/code&gt; и &lt;code&gt;operator!=&lt;/code&gt; которые сравнивают два объекта типа (возможно, const) &lt;code&gt;std::fpos&lt;/code&gt; и возвращают значение типа, преобразуемого в &lt;code&gt;bool&lt;/code&gt; . &lt;code&gt;p != q&lt;/code&gt; эквивалентно &lt;code&gt;!(p == q)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="39d269f4f1f68438431582408bf841c32f549f02" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;operator==&lt;/code&gt; is an equivalence relation</source>
          <target state="translated">&lt;code&gt;operator==&lt;/code&gt; является отношением эквивалентности</target>
        </trans-unit>
        <trans-unit id="3d61c5ee92c0d49653eaa3a52c2d1de7ec7b9420" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;operator==&lt;/code&gt; is defined as defaulted in the definition of &lt;code&gt;T&lt;/code&gt;, and</source>
          <target state="translated">&lt;code&gt;operator==&lt;/code&gt; определяется как значение по умолчанию в определении &lt;code&gt;T&lt;/code&gt; , и</target>
        </trans-unit>
        <trans-unit id="e9356a1e78f8cbfe3d2f7bf66376ed1f93958a16" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;operator[]&lt;/code&gt; is non-const because it inserts the key if it doesn't exist. If this behavior is undesirable or if the container is &lt;code&gt;const&lt;/code&gt;, &lt;a href=&quot;at&quot;&gt;&lt;code&gt;at()&lt;/code&gt;&lt;/a&gt; may be used.</source>
          <target state="translated">&lt;code&gt;operator[]&lt;/code&gt; является константным, потому что он вставляет ключ, если он не существует. Если это поведение нежелательно или контейнер &lt;code&gt;const&lt;/code&gt; , можно использовать &lt;a href=&quot;at&quot;&gt; &lt;code&gt;at()&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="13f08fb543a60dc58a2ea30fbdbededba9bc375e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;operator[]&lt;/code&gt; provides access to elements of an array managed by a &lt;code&gt;unique_ptr&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;operator[]&lt;/code&gt; обеспечивает доступ к элементам массива, управляемым &lt;code&gt;unique_ptr&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="883870465553c6cdc607766b28f6468761a82f6f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;optional&lt;/code&gt; objects whose states to swap</source>
          <target state="translated">&lt;code&gt;optional&lt;/code&gt; объекты, чьи состояния поменять местами</target>
        </trans-unit>
        <trans-unit id="4fbf68b51971745343c3ffd40d040a0e3e1a307b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;opts&lt;/code&gt; is required to have only one of &lt;code&gt;replace&lt;/code&gt;, &lt;code&gt;add&lt;/code&gt;, or &lt;code&gt;remove&lt;/code&gt; to be set.</source>
          <target state="translated">&lt;code&gt;opts&lt;/code&gt; должен быть установлен только один из параметров &lt;code&gt;replace&lt;/code&gt; , &lt;code&gt;add&lt;/code&gt; или &lt;code&gt;remove&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a78e804adbc080203711f861cae5a953da4fc7e7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;order&lt;/code&gt; must be one of &lt;code&gt;&lt;a href=&quot;../memory_order&quot;&gt;std::memory_order_relaxed&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../memory_order&quot;&gt;std::memory_order_consume&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../memory_order&quot;&gt;std::memory_order_acquire&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../memory_order&quot;&gt;std::memory_order_seq_cst&lt;/a&gt;&lt;/code&gt;. Otherwise the behavior is undefined.</source>
          <target state="translated">&lt;code&gt;order&lt;/code&gt; должен быть одним из следующих: &lt;code&gt;&lt;a href=&quot;../memory_order&quot;&gt;std::memory_order_relaxed&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../memory_order&quot;&gt;std::memory_order_consume&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../memory_order&quot;&gt;std::memory_order_acquire&lt;/a&gt;&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;../memory_order&quot;&gt;std::memory_order_seq_cst&lt;/a&gt;&lt;/code&gt; . В противном случае поведение не определено.</target>
        </trans-unit>
        <trans-unit id="7204af3ca4f2aed86069165b606be99f4e2300f4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;order&lt;/code&gt; must be one of &lt;code&gt;&lt;a href=&quot;../memory_order&quot;&gt;std::memory_order_relaxed&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../memory_order&quot;&gt;std::memory_order_release&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../memory_order&quot;&gt;std::memory_order_seq_cst&lt;/a&gt;&lt;/code&gt;. Otherwise the behavior is undefined.</source>
          <target state="translated">&lt;code&gt;order&lt;/code&gt; должен быть одним из следующих: &lt;code&gt;&lt;a href=&quot;../memory_order&quot;&gt;std::memory_order_relaxed&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../memory_order&quot;&gt;std::memory_order_release&lt;/a&gt;&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;../memory_order&quot;&gt;std::memory_order_seq_cst&lt;/a&gt;&lt;/code&gt; . В противном случае поведение не определено.</target>
        </trans-unit>
        <trans-unit id="73445bbb3ca832810ca8e503535082a01a9eeb93" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;os&lt;/code&gt; (reference to the stream after insertion of the null character).</source>
          <target state="translated">&lt;code&gt;os&lt;/code&gt; (ссылка на поток после вставки нулевого символа).</target>
        </trans-unit>
        <trans-unit id="c6b824d3af2a1cc6b8c2142ae1483bc865ef7340" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;os&lt;/code&gt; (reference to the stream after manipulation).</source>
          <target state="translated">&lt;code&gt;os&lt;/code&gt; (ссылка на поток после манипуляции).</target>
        </trans-unit>
        <trans-unit id="032f0b3487a5ca21c992a1f045aefccc97a9be7c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;os&lt;/code&gt;, an output stream</source>
          <target state="translated">&lt;code&gt;os&lt;/code&gt; , выходной поток</target>
        </trans-unit>
        <trans-unit id="52ca514c495ce1aab59e22c682594847bbd20e11" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;os&lt;/code&gt;, lvalue of a specialization of &lt;code&gt;&lt;a href=&quot;../io/basic_ostream&quot;&gt;std::basic_ostream&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;os&lt;/code&gt; , lvalue специализации &lt;code&gt;&lt;a href=&quot;../io/basic_ostream&quot;&gt;std::basic_ostream&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c96784d61f11c38f7f6143a78187f534012c3007" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;os&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;os&lt;/code&gt;.</target>
        </trans-unit>
        <trans-unit id="8498a31a9efd8e8be6b0e17ecaa089beea7bdd90" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ost&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;ost&lt;/code&gt;.</target>
        </trans-unit>
        <trans-unit id="9c689bba213fce99939bdec65d89bcde7dda5e0c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ostrstream&lt;/code&gt; has been deprecated since C++98, &lt;code&gt;&lt;a href=&quot;basic_ostringstream&quot;&gt;std::ostringstream&lt;/a&gt;&lt;/code&gt; and &lt;a href=&quot;http://www.boost.org/doc/libs/release/libs/iostreams/doc/classes/array.html#array_sink&quot;&gt;boost::iostreams::array_sink&lt;/a&gt; are the recommended replacements.</source>
          <target state="translated">&lt;code&gt;ostrstream&lt;/code&gt; устарел с C ++ 98, рекомендуемые замены - &lt;code&gt;&lt;a href=&quot;basic_ostringstream&quot;&gt;std::ostringstream&lt;/a&gt;&lt;/code&gt; и &lt;a href=&quot;http://www.boost.org/doc/libs/release/libs/iostreams/doc/classes/array.html#array_sink&quot;&gt;boost :: iostreams :: array_sink&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f153dff8fd2252b6cece0cbb71dec8fd509cbd1a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;other&lt;/code&gt; is left with no associated file. Note that the base class move assignment swaps all stream state variables (except for &lt;code&gt;rdbuf&lt;/code&gt;) between &lt;code&gt;*this&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;other&lt;/code&gt; осталось без связанного файла. Обратите внимание, что назначение перемещения базового класса меняет местами все переменные состояния потока (кроме &lt;code&gt;rdbuf&lt;/code&gt; ) между &lt;code&gt;*this&lt;/code&gt; и &lt;code&gt;other&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5dfa669a6643570842768d3c8af930a8bded28ca" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;out&lt;/code&gt;, &lt;code&gt;out|trunc&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;out&lt;/code&gt; , &lt;code&gt;out|trunc&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="78ed9da4c97b581673150388516e0e2b9bf414f4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;out&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;out&lt;/code&gt;.</target>
        </trans-unit>
        <trans-unit id="a0234f068508744db144a8f4f24cbb727104a0fe" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;output_iterator_tag&lt;/code&gt; corresponds to &lt;a href=&quot;../named_req/outputiterator&quot;&gt;LegacyOutputIterator&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;output_iterator_tag&lt;/code&gt; соответствует &lt;a href=&quot;../named_req/outputiterator&quot;&gt;LegacyOutputIterator&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="151a095e9390db143eee3847774c0e9cd2500d42" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;out|in|app&lt;/code&gt;, &lt;code&gt;in|app&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;out|in|app&lt;/code&gt; , &lt;code&gt;in|app&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ff0efac0feea602422410e8b7256210660023bdb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;override&lt;/code&gt; is an identifier with a special meaning when used after member function declarators: it's not a reserved keyword otherwise.</source>
          <target state="translated">&lt;code&gt;override&lt;/code&gt; - это идентификатор со специальным значением при использовании после деклараторов функций-членов: в противном случае это не зарезервированное ключевое слово.</target>
        </trans-unit>
        <trans-unit id="b37336d8be8522632aaf92f068edcc5fc1306e8a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;p + o&lt;/code&gt; has type &lt;code&gt;fpos&amp;lt;State&amp;gt;&lt;/code&gt; and stores an offset that is the result of adding &lt;code&gt;o&lt;/code&gt; to the offset of &lt;code&gt;p&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;p + o&lt;/code&gt; имеет тип &lt;code&gt;fpos&amp;lt;State&amp;gt;&lt;/code&gt; и хранит смещение, которое является результатом добавления &lt;code&gt;o&lt;/code&gt; к смещению &lt;code&gt;p&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6c538706b366113c705286df152d776a2ec6aa9b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;p - o&lt;/code&gt; has type &lt;code&gt;fpos&amp;lt;State&amp;gt;&lt;/code&gt; and stores an offset that is the result of subtracting &lt;code&gt;o&lt;/code&gt; from the offset of &lt;code&gt;p&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;p - o&lt;/code&gt; имеет тип &lt;code&gt;fpos&amp;lt;State&amp;gt;&lt;/code&gt; и хранит смещение, которое является результатом вычитания &lt;code&gt;o&lt;/code&gt; из смещения &lt;code&gt;p&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="59ce2be2c428fc29f56c47bde0b8952f2140fde4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;p, q&lt;/code&gt;, values of type &lt;code&gt;const CharT*&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;p, q&lt;/code&gt; , значения типа &lt;code&gt;const CharT*&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0bf18dd04ded5880be160a1161b6bb30895803ed" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;p-&amp;gt;*mp&lt;/code&gt;, the built-in &lt;a href=&quot;operator_member_access#Built-in_pointer-to-member_access_operators&quot;&gt;pointer to member of pointer&lt;/a&gt; expression, where &lt;code&gt;mp&lt;/code&gt; is a pointer to data member;</source>
          <target state="translated">&lt;code&gt;p-&amp;gt;*mp&lt;/code&gt; , встроенный &lt;a href=&quot;operator_member_access#Built-in_pointer-to-member_access_operators&quot;&gt;указатель на член&lt;/a&gt; выражения указателя , где &lt;code&gt;mp&lt;/code&gt; - указатель на член данных;</target>
        </trans-unit>
        <trans-unit id="fd5ab0235afc288a57ad9fbf269861d99aee101e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;p-&amp;gt;*mp&lt;/code&gt;, the built-in &lt;a href=&quot;operator_member_access#Built-in_pointer-to-member_access_operators&quot;&gt;pointer to member of pointer&lt;/a&gt; expression, where &lt;code&gt;mp&lt;/code&gt; is a pointer to member function&lt;sup id=&quot;cite_ref-pmfc_2-3&quot;&gt;&lt;a href=&quot;value_category#cite_note-pmfc-2&quot;&gt;[2]&lt;/a&gt;&lt;/sup&gt;;</source>
          <target state="translated">&lt;code&gt;p-&amp;gt;*mp&lt;/code&gt; , встроенный &lt;a href=&quot;operator_member_access#Built-in_pointer-to-member_access_operators&quot;&gt;указатель на член&lt;/a&gt; выражения указателя , где &lt;code&gt;mp&lt;/code&gt; - указатель на функцию-член &lt;sup id=&quot;cite_ref-pmfc_2-3&quot;&gt;&lt;a href=&quot;value_category#cite_note-pmfc-2&quot;&gt;[2]&lt;/a&gt;&lt;/sup&gt; ;</target>
        </trans-unit>
        <trans-unit id="d647ed0e69a621aee58bfb437764f9f6f57a9644" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;p-&amp;gt;m&lt;/code&gt;, the built-in &lt;a href=&quot;operator_member_access#Built-in_member_access_operators&quot;&gt;member of pointer&lt;/a&gt; expression, except where &lt;code&gt;m&lt;/code&gt; is a member enumerator or a non-static member function;</source>
          <target state="translated">&lt;code&gt;p-&amp;gt;m&lt;/code&gt; , встроенный &lt;a href=&quot;operator_member_access#Built-in_member_access_operators&quot;&gt;член&lt;/a&gt; выражения указателя , за исключением случаев, когда &lt;code&gt;m&lt;/code&gt; является перечислителем члена или нестатической функцией-членом;</target>
        </trans-unit>
        <trans-unit id="decc8a48f2e43780bffcfc24eccfab7b70d4b019" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;p-&amp;gt;m&lt;/code&gt;, the built-in &lt;a href=&quot;operator_member_access#Built-in_member_access_operators&quot;&gt;member of pointer&lt;/a&gt; expression, where &lt;code&gt;m&lt;/code&gt; is a member enumerator or a non-static member function&lt;sup id=&quot;cite_ref-pmfc_2-1&quot;&gt;&lt;a href=&quot;value_category#cite_note-pmfc-2&quot;&gt;[2]&lt;/a&gt;&lt;/sup&gt;;</source>
          <target state="translated">&lt;code&gt;p-&amp;gt;m&lt;/code&gt; - встроенный &lt;a href=&quot;operator_member_access#Built-in_member_access_operators&quot;&gt;член&lt;/a&gt; выражения указателя , где &lt;code&gt;m&lt;/code&gt; - перечислитель-член или нестатическая функция-член &lt;sup id=&quot;cite_ref-pmfc_2-1&quot;&gt;&lt;a href=&quot;value_category#cite_note-pmfc-2&quot;&gt;[2]&lt;/a&gt;&lt;/sup&gt; ;</target>
        </trans-unit>
        <trans-unit id="d91a4e8a8b40a713d9c0c11cc0d6f8157332110a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;p1&lt;/code&gt; and &lt;code&gt;p2&lt;/code&gt;, objects of type &lt;code&gt;X::pointer&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;p1&lt;/code&gt; и &lt;code&gt;p2&lt;/code&gt; , объекты типа &lt;code&gt;X::pointer&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2fdbf1680504d5fe8ef0f07168890765f7a7837e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;p&lt;/code&gt; must have been returned by a prior call to &lt;code&gt;allocate(bytes, alignment)&lt;/code&gt; on a &lt;code&gt;memory_resource&lt;/code&gt; that compares equal to &lt;code&gt;*this&lt;/code&gt;, and the storage it points to must not yet have been deallocated, otherwise the behavior is undefined.</source>
          <target state="translated">&lt;code&gt;p&lt;/code&gt; должен был быть возвращен предыдущим вызовом для &lt;code&gt;allocate(bytes, alignment)&lt;/code&gt; в &lt;code&gt;memory_resource&lt;/code&gt; , который сравнивается равным &lt;code&gt;*this&lt;/code&gt; , а хранилище, на которое он указывает, еще не было освобождено, иначе поведение не определено.</target>
        </trans-unit>
        <trans-unit id="86c9ed195a73935b9716d0c908fe04050917471f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;p&lt;/code&gt; | &lt;code&gt;P&lt;/code&gt;exponent-sign(optional)digit-sequence</source>
          <target state="translated">&lt;code&gt;p&lt;/code&gt; | &lt;code&gt;P&lt;/code&gt; знак экспоненты (необязательно)</target>
        </trans-unit>
        <trans-unit id="d513ab3d55fc832db51ef3c9a24dc140d2150524" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;p&lt;/code&gt;, &lt;code&gt;q2&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;p&lt;/code&gt; , &lt;code&gt;q2&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="eb12774f3eaef9d2fbe7eabc6816979bbcbdac38" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;p&lt;/code&gt;, a (possibly const) value of type &lt;code&gt;P&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;p&lt;/code&gt; , (возможно, const) значение типа &lt;code&gt;P&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="06a9dfc8a3226eb094336f1d83bc095f0f4cc3f3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;p&lt;/code&gt;, a valid const iterator into &lt;code&gt;a&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;p&lt;/code&gt; , действительный Неконстантный итератор в &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="dda70b02c1417aebe7356f487e2312107813a9f5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;p&lt;/code&gt;, a value of type &lt;code&gt;const CharT*&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;p&lt;/code&gt; , значение типа &lt;code&gt;const CharT*&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="bf42ece8a8b704ccc31f7c6d166de57b47e04378" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;path&lt;/code&gt; constructor supports creation from UTF-8 string when the source is a sequence of &lt;code&gt;char8_t&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;path&lt;/code&gt; Конструктор пути поддерживает создание из строки UTF-8, когда источником является последовательность &lt;code&gt;char8_t&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bfe847d99e91df30f9b2b1c997d690f6c9d3e19f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;perm_options&lt;/code&gt; satisfies the requirements of &lt;a href=&quot;../named_req/bitmasktype&quot;&gt;BitmaskType&lt;/a&gt; (which means the bitwise operators &lt;code&gt;operator&amp;amp;&lt;/code&gt;, &lt;code&gt;operator|&lt;/code&gt;, &lt;code&gt;operator^&lt;/code&gt;, &lt;code&gt;operator~&lt;/code&gt;, &lt;code&gt;operator&amp;amp;=&lt;/code&gt;, &lt;code&gt;operator|=&lt;/code&gt;, and &lt;code&gt;operator^=&lt;/code&gt; are defined for this type).</source>
          <target state="translated">&lt;code&gt;perm_options&lt;/code&gt; удовлетворяет требованиям &lt;a href=&quot;../named_req/bitmasktype&quot;&gt;BitmaskType&lt;/a&gt; (что означает, что для этого типа определены побитовые операторы &lt;code&gt;operator&amp;amp;&lt;/code&gt; , &lt;code&gt;operator|&lt;/code&gt; , &lt;code&gt;operator^&lt;/code&gt; , &lt;code&gt;operator~&lt;/code&gt; , &lt;code&gt;operator&amp;amp;=&lt;/code&gt; , &lt;code&gt;operator|=&lt;/code&gt; и &lt;code&gt;operator^=&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="7ee26e88b54b4a023e55266a4a3f22951b680147" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pointer&lt;/code&gt; - defines a pointer to the type iterated over (&lt;code&gt;value_type&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;pointer&lt;/code&gt; - определяет указатель на тип, повторяемый ( &lt;code&gt;value_type&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="e79147d00db804701f1432b2de52a0ee8c9866be" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pointer&lt;/code&gt; is the same type as &lt;code&gt;element_type*&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;pointer&lt;/code&gt; того же типа, что и &lt;code&gt;element_type*&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d4eac86c5a412a3fecf58e540135ae2be1988069" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pointer&lt;/code&gt; is the same type as &lt;code&gt;element_type*&lt;/code&gt; and &lt;code&gt;U&lt;/code&gt; is a pointer type &lt;code&gt;V*&lt;/code&gt; such that &lt;code&gt;V(*)[]&lt;/code&gt; is convertible to &lt;code&gt;element_type(*)[]&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;pointer&lt;/code&gt; того же типа, что и &lt;code&gt;element_type*&lt;/code&gt; а &lt;code&gt;U&lt;/code&gt; - указатель типа &lt;code&gt;V*&lt;/code&gt; , так что &lt;code&gt;V(*)[]&lt;/code&gt; можно преобразовать в &lt;code&gt;element_type(*)[]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7c5d8e68715c162ba85ea985f5b5bb4621395292" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pointer&lt;/code&gt; is the same type as &lt;code&gt;element_type*&lt;/code&gt; and &lt;code&gt;U&lt;/code&gt; is some pointer type &lt;code&gt;V*&lt;/code&gt; such that &lt;code&gt;V(*)[]&lt;/code&gt; is implicitly convertible to &lt;code&gt;element_type(*)[]&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;pointer&lt;/code&gt; того же типа, что и &lt;code&gt;element_type*&lt;/code&gt; а &lt;code&gt;U&lt;/code&gt; - некоторый тип указателя &lt;code&gt;V*&lt;/code&gt; , так что &lt;code&gt;V(*)[]&lt;/code&gt; неявно преобразуется в &lt;code&gt;element_type(*)[]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="56f1ebd031796dfa24a0a58f2845dcb2e9561460" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pointer&lt;/code&gt;(deprecated in C++17)(removed in C++20)</source>
          <target state="translated">&lt;code&gt;pointer&lt;/code&gt; (устарел в C ++ 17) (удален в C ++ 20)</target>
        </trans-unit>
        <trans-unit id="d1061ab44e5f87ced20028c2ff2ad959879b250d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;polymorphic_allocator&lt;/code&gt; does not propagate on container copy assignment, move assignment, or swap. As a result, move assignment of a &lt;code&gt;polymorphic_allocator&lt;/code&gt;-using container can throw, and swapping two &lt;code&gt;polymorphic_allocator&lt;/code&gt;-using containers whose allocators do not compare equal results in undefined behavior.</source>
          <target state="translated">&lt;code&gt;polymorphic_allocator&lt;/code&gt; не распространяется на назначение копии контейнера, назначение перемещения или подкачку. В результате назначение перемещения контейнера, использующего &lt;code&gt;polymorphic_allocator&lt;/code&gt; , может вызвать выброс и поменять местами два контейнера, использующих &lt;code&gt;polymorphic_allocator&lt;/code&gt; , чьи распределители не сравнивают одинаковые результаты в неопределенном поведении.</target>
        </trans-unit>
        <trans-unit id="625f99b6248f4d1722f67a9433f27d568b065d23" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;polymorphic_allocator&lt;/code&gt;s do not propagate on container copy construction.</source>
          <target state="translated">&lt;code&gt;polymorphic_allocator&lt;/code&gt; не распространяется на конструкцию копирования контейнера.</target>
        </trans-unit>
        <trans-unit id="f5e918c456b10043e8203133417d79d51c29c66d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pos&lt;/code&gt;, a value of type &lt;code&gt;X::pos_type&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;pos&lt;/code&gt; , значение типа &lt;code&gt;X::pos_type&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8cb67828ec4d1356afd884c8cf511326963cfbaf" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pos_type(newoff)&lt;/code&gt; on success, &lt;code&gt;pos_type(off_type(-1))&lt;/code&gt; on failure and if pos_type cannot represent the resulting stream position.</source>
          <target state="translated">&lt;code&gt;pos_type(newoff)&lt;/code&gt; в случае успеха, &lt;code&gt;pos_type(off_type(-1))&lt;/code&gt; в случае неудачи и, если pos_type не может представлять результирующую позицию потока.</target>
        </trans-unit>
        <trans-unit id="6498cc9ae3662e3b03086527cb6accd9d3f42543" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pow(&amp;plusmn;0, -&amp;infin;)&lt;/code&gt; returns +&amp;infin; and may raise &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_DIVBYZERO&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;pow(&amp;plusmn;0, -&amp;infin;)&lt;/code&gt; возвращает + &amp;infin; и может повысить &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_DIVBYZERO&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="042e94e352fb34d331cb6fc5334ea7fed3a2d3fb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pow(&amp;plusmn;0, exp)&lt;/code&gt;, where &lt;code&gt;exp&lt;/code&gt; is negative, finite, and is an even integer or a non-integer, returns +&amp;infin; and raises &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_DIVBYZERO&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;pow(&amp;plusmn;0, exp)&lt;/code&gt; , где &lt;code&gt;exp&lt;/code&gt; - отрицательное, конечное и четное целое число или нецелое число, возвращает + &amp;infin; и вызывает &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_DIVBYZERO&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ee4eec21814b8d94f592dabb5cd16ff37f602187" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pow(&amp;plusmn;0, exp)&lt;/code&gt;, where &lt;code&gt;exp&lt;/code&gt; is positive non-integer or a positive even integer, returns +0</source>
          <target state="translated">&lt;code&gt;pow(&amp;plusmn;0, exp)&lt;/code&gt; , где &lt;code&gt;exp&lt;/code&gt; - положительное нецелое число или положительное четное число, возвращает +0</target>
        </trans-unit>
        <trans-unit id="4063720964f4e1762c5635e9b59232784a0d4540" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pow(+&amp;infin;, exp)&lt;/code&gt; returns +&amp;infin; for any positive &lt;code&gt;exp&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;pow(+&amp;infin;, exp)&lt;/code&gt; возвращает + &amp;infin; для любого положительного &lt;code&gt;exp&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="56ebf1acd4f1f0c4a5274430626232999a270b35" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pow(+&amp;infin;, exp)&lt;/code&gt; returns +0 for any negative &lt;code&gt;exp&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;pow(+&amp;infin;, exp)&lt;/code&gt; возвращает +0 для любого отрицательного &lt;code&gt;exp&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="290d8d6e91b01d354bcde6fecd105bc84bb83b5e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pow(+0, exp)&lt;/code&gt;, where &lt;code&gt;exp&lt;/code&gt; is a negative odd integer, returns +&amp;infin; and raises &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_DIVBYZERO&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;pow(+0, exp)&lt;/code&gt; , где &lt;code&gt;exp&lt;/code&gt; - отрицательное нечетное целое число, возвращает + &amp;infin; и вызывает &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_DIVBYZERO&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3878047bc1ba88caaa0d085bfa6aaec4e2ca959f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pow(+0, exp)&lt;/code&gt;, where &lt;code&gt;exp&lt;/code&gt; is a positive odd integer, returns +0</source>
          <target state="translated">&lt;code&gt;pow(+0, exp)&lt;/code&gt; , где &lt;code&gt;exp&lt;/code&gt; - положительное нечетное целое число, возвращает +0</target>
        </trans-unit>
        <trans-unit id="bd1582f9f2bfd41942e34cebc3721377ce599a2f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pow(+1, exp)&lt;/code&gt; returns &lt;code&gt;1&lt;/code&gt; for any &lt;code&gt;exp&lt;/code&gt;, even when &lt;code&gt;exp&lt;/code&gt; is &lt;code&gt;NaN&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;pow(+1, exp)&lt;/code&gt; возвращает &lt;code&gt;1&lt;/code&gt; для любого &lt;code&gt;exp&lt;/code&gt; , даже если &lt;code&gt;exp&lt;/code&gt; равен &lt;code&gt;NaN&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="dc7237a85469de1b40fe31197bdde1ed77eb2948" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pow(-&amp;infin;, exp)&lt;/code&gt; returns +&amp;infin; if &lt;code&gt;exp&lt;/code&gt; is a positive non-integer or even integer</source>
          <target state="translated">&lt;code&gt;pow(-&amp;infin;, exp)&lt;/code&gt; возвращает + &amp;infin;, если &lt;code&gt;exp&lt;/code&gt; является положительным нецелым или даже целым числом</target>
        </trans-unit>
        <trans-unit id="a734c05c169aa85465d6092079877e0218736515" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pow(-&amp;infin;, exp)&lt;/code&gt; returns +0 if &lt;code&gt;exp&lt;/code&gt; is a negative non-integer or even integer</source>
          <target state="translated">&lt;code&gt;pow(-&amp;infin;, exp)&lt;/code&gt; возвращает +0, если &lt;code&gt;exp&lt;/code&gt; является отрицательным нецелым или даже целым числом</target>
        </trans-unit>
        <trans-unit id="700ada9b089696d54cc43eebe2567eaa09e43d01" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pow(-&amp;infin;, exp)&lt;/code&gt; returns -&amp;infin; if &lt;code&gt;exp&lt;/code&gt; is a positive odd integer</source>
          <target state="translated">&lt;code&gt;pow(-&amp;infin;, exp)&lt;/code&gt; возвращает -&amp;infin;, если &lt;code&gt;exp&lt;/code&gt; - положительное нечетное целое число</target>
        </trans-unit>
        <trans-unit id="3c266a9e25ce2048682bdb2a100bbbf6e740ceb5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pow(-&amp;infin;, exp)&lt;/code&gt; returns -0 if &lt;code&gt;exp&lt;/code&gt; is a negative odd integer</source>
          <target state="translated">&lt;code&gt;pow(-&amp;infin;, exp)&lt;/code&gt; возвращает -0, если &lt;code&gt;exp&lt;/code&gt; - отрицательное нечетное целое число</target>
        </trans-unit>
        <trans-unit id="ef3bb65d06173ef9916b6d047828bd8344e86186" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pow(-0, exp)&lt;/code&gt;, where &lt;code&gt;exp&lt;/code&gt; is a negative odd integer, returns -&amp;infin; and raises &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_DIVBYZERO&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;pow(-0, exp)&lt;/code&gt; , где &lt;code&gt;exp&lt;/code&gt; - отрицательное нечетное целое число, возвращает -&amp;infin; и повышает &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_DIVBYZERO&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="50deaa3867ca4b36a7f84a69f7c8fb4bb898765b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pow(-0, exp)&lt;/code&gt;, where &lt;code&gt;exp&lt;/code&gt; is a positive odd integer, returns -0</source>
          <target state="translated">&lt;code&gt;pow(-0, exp)&lt;/code&gt; , где &lt;code&gt;exp&lt;/code&gt; - положительное нечетное целое число, возвращает -0</target>
        </trans-unit>
        <trans-unit id="447e291f802b84fb27f91b3026e77b14323ccb22" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pow(-1, &amp;plusmn;&amp;infin;)&lt;/code&gt; returns &lt;code&gt;1&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;pow(-1, &amp;plusmn;&amp;infin;)&lt;/code&gt; возвращает &lt;code&gt;1&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0c04a0ce7e8f42d74e5388e22f76da75a979a54c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pow(base, &amp;plusmn;0)&lt;/code&gt; returns &lt;code&gt;1&lt;/code&gt; for any &lt;code&gt;base&lt;/code&gt;, even when &lt;code&gt;base&lt;/code&gt; is &lt;code&gt;NaN&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;pow(base, &amp;plusmn;0)&lt;/code&gt; возвращает &lt;code&gt;1&lt;/code&gt; для любого &lt;code&gt;base&lt;/code&gt; , даже если &lt;code&gt;base&lt;/code&gt; равно &lt;code&gt;NaN&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4a71fc23b8b5a698d841d4415831f0fa35d4ddef" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pow(base, +&amp;infin;)&lt;/code&gt; returns +&amp;infin; for any &lt;code&gt;|base|&amp;gt;1&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;pow(base, +&amp;infin;)&lt;/code&gt; возвращает + &amp;infin; для любого &lt;code&gt;|base|&amp;gt;1&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="06fde8b1bde3c2c448f1910dc0f1b60dbb034481" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pow(base, +&amp;infin;)&lt;/code&gt; returns +0 for any &lt;code&gt;|base|&amp;lt;1&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;pow(base, +&amp;infin;)&lt;/code&gt; возвращает +0 для любого &lt;code&gt;|base|&amp;lt;1&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="31af622727a3672337932c35fe9e49310d7fef72" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pow(base, -&amp;infin;)&lt;/code&gt; returns +&amp;infin; for any &lt;code&gt;|base|&amp;lt;1&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;pow(base, -&amp;infin;)&lt;/code&gt; возвращает + &amp;infin; для любого &lt;code&gt;|base|&amp;lt;1&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="49a620a430e4139058cc89942e34ef8005a0253a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pow(base, -&amp;infin;)&lt;/code&gt; returns +0 for any &lt;code&gt;|base|&amp;gt;1&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;pow(base, -&amp;infin;)&lt;/code&gt; возвращает +0 для любого &lt;code&gt;|base|&amp;gt;1&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1f971d5f39b82653837792e77c6f4888a84edec3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pow(base, exp)&lt;/code&gt; returns &lt;code&gt;NaN&lt;/code&gt; and raises &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; if &lt;code&gt;base&lt;/code&gt; is finite and negative and &lt;code&gt;exp&lt;/code&gt; is finite and non-integer.</source>
          <target state="translated">&lt;code&gt;pow(base, exp)&lt;/code&gt; возвращает &lt;code&gt;NaN&lt;/code&gt; и повышает &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; , если &lt;code&gt;base&lt;/code&gt; конечен и отрицателен, а &lt;code&gt;exp&lt;/code&gt; конечен и не целочислен.</target>
        </trans-unit>
        <trans-unit id="9d7cf028e07dd0eaf95da860c70dd83e851c29f8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pow(float, int)&lt;/code&gt; returns &lt;code&gt;float&lt;/code&gt; until C++11 (per overload 4) but returns &lt;code&gt;double&lt;/code&gt; since C++11 (per overload 7).</source>
          <target state="translated">&lt;code&gt;pow(float, int)&lt;/code&gt; возвращает &lt;code&gt;float&lt;/code&gt; до C ++ 11 (на перегрузку 4), но возвращает &lt;code&gt;double&lt;/code&gt; , начиная с C ++ 11 (на перегрузку 7).</target>
        </trans-unit>
        <trans-unit id="1b1fae023fa49e4833b3e21e8841e921d4f06a73" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;printf&lt;/code&gt; family of functions should produce the same sequence using &lt;code&gt;%p&lt;/code&gt; format specifier.</source>
          <target state="translated">&lt;code&gt;printf&lt;/code&gt; Семейство функций printf должно создавать ту же последовательность, используя спецификатор формата &lt;code&gt;%p&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="26d9d6de8db2eb2f8a42e0d3402444909f7380de" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;private&lt;/code&gt; access specifier</source>
          <target state="translated">&lt;code&gt;private&lt;/code&gt; спецификатор частного доступа</target>
        </trans-unit>
        <trans-unit id="d06e845dd87ad90bf1bed9db6304b845f3753b8f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;private&lt;/code&gt;&lt;code&gt;:&lt;/code&gt;member-declarations</source>
          <target state="translated">&lt;code&gt;private&lt;/code&gt;&lt;code&gt;:&lt;/code&gt;member-declarations</target>
        </trans-unit>
        <trans-unit id="7d06457bc1a108ff2b5a3fb6cacd2d0879f1e659" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;private&lt;/code&gt;base_class</source>
          <target state="translated">&lt;code&gt;private&lt;/code&gt;base_class</target>
        </trans-unit>
        <trans-unit id="2be979307e8c4ecb073d5d7f8c2c69f96da8ea58" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;propagate_on_container_copy_assignment&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;../types/integral_constant&quot;&gt;std::true_type&lt;/a&gt;&lt;/code&gt; if &lt;code&gt;&lt;a href=&quot;allocator_traits&quot;&gt;std::allocator_traits&lt;/a&gt;&amp;lt;A&amp;gt;::propagate_on_container_copy_assignment::value&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; for at least one allocator &lt;code&gt;A&lt;/code&gt; among &lt;code&gt;OuterAlloc&lt;/code&gt; and &lt;code&gt;InnerAlloc...&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;propagate_on_container_copy_assignment&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;../types/integral_constant&quot;&gt;std::true_type&lt;/a&gt;&lt;/code&gt; если &lt;code&gt;&lt;a href=&quot;allocator_traits&quot;&gt;std::allocator_traits&lt;/a&gt;&amp;lt;A&amp;gt;::propagate_on_container_copy_assignment::value&lt;/code&gt; это &lt;code&gt;true&lt;/code&gt; , по крайней мере , одним распределителем &lt;code&gt;A&lt;/code&gt; среди &lt;code&gt;OuterAlloc&lt;/code&gt; и &lt;code&gt;InnerAlloc...&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0a45f9401d8e6380fa755c6da39c0c81ec78bc2b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;propagate_on_container_move_assignment&lt;/code&gt;(C++14)</source>
          <target state="translated">&lt;code&gt;propagate_on_container_move_assignment&lt;/code&gt;(C++14)</target>
        </trans-unit>
        <trans-unit id="62f33439d93f9ada7b8d0a92dc1fa3b75c71b2c1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;propagate_on_container_move_assignment&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;../types/integral_constant&quot;&gt;std::true_type&lt;/a&gt;&lt;/code&gt; if &lt;code&gt;&lt;a href=&quot;allocator_traits&quot;&gt;std::allocator_traits&lt;/a&gt;&amp;lt;A&amp;gt;::propagate_on_container_move_assignment::value&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; for at least one allocator &lt;code&gt;A&lt;/code&gt; among &lt;code&gt;OuterAlloc&lt;/code&gt; and &lt;code&gt;InnerAlloc...&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;propagate_on_container_move_assignment&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;../types/integral_constant&quot;&gt;std::true_type&lt;/a&gt;&lt;/code&gt; если &lt;code&gt;&lt;a href=&quot;allocator_traits&quot;&gt;std::allocator_traits&lt;/a&gt;&amp;lt;A&amp;gt;::propagate_on_container_move_assignment::value&lt;/code&gt; это &lt;code&gt;true&lt;/code&gt; , по крайней мере , одним распределителем &lt;code&gt;A&lt;/code&gt; среди &lt;code&gt;OuterAlloc&lt;/code&gt; и &lt;code&gt;InnerAlloc...&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="42e23f2cd472fcc8e748a4059324eaa52062ed17" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;propagate_on_container_swap&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;../types/integral_constant&quot;&gt;std::true_type&lt;/a&gt;&lt;/code&gt; if &lt;code&gt;&lt;a href=&quot;allocator_traits&quot;&gt;std::allocator_traits&lt;/a&gt;&amp;lt;A&amp;gt;::propagate_on_container_swap::value&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; for at least one allocator &lt;code&gt;A&lt;/code&gt; among &lt;code&gt;OuterAlloc&lt;/code&gt; and &lt;code&gt;InnerAlloc...&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;propagate_on_container_swap&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;../types/integral_constant&quot;&gt;std::true_type&lt;/a&gt;&lt;/code&gt; если &lt;code&gt;&lt;a href=&quot;allocator_traits&quot;&gt;std::allocator_traits&lt;/a&gt;&amp;lt;A&amp;gt;::propagate_on_container_swap::value&lt;/code&gt; это &lt;code&gt;true&lt;/code&gt; , по крайней мере , одним распределителем &lt;code&gt;A&lt;/code&gt; среди &lt;code&gt;OuterAlloc&lt;/code&gt; и &lt;code&gt;InnerAlloc...&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a6e3da20abe20ecf600244767a7228b8ec7219b5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;protected&lt;/code&gt; access specifier</source>
          <target state="translated">&lt;code&gt;protected&lt;/code&gt; спецификатор защищенного доступа</target>
        </trans-unit>
        <trans-unit id="0dac7c331aa38c811453a012236db1f4ecc81cc3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;protected&lt;/code&gt;&lt;code&gt;:&lt;/code&gt;member-declarations</source>
          <target state="translated">&lt;code&gt;protected&lt;/code&gt;&lt;code&gt;:&lt;/code&gt;member-declarations</target>
        </trans-unit>
        <trans-unit id="bf5ed0fb019fba1b1e4776c0bc6a3b60f1f50260" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;protected&lt;/code&gt;base_class</source>
          <target state="translated">&lt;code&gt;protected&lt;/code&gt;base_class</target>
        </trans-unit>
        <trans-unit id="d543477baebfc303e229d1b12c5465e379252a52" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pt - d&lt;/code&gt; behaved erratically for unsigned &lt;code&gt;duration&lt;/code&gt;s</source>
          <target state="translated">&lt;code&gt;pt - d&lt;/code&gt; вел себя беспорядочно в течение беззнаковой &lt;code&gt;duration&lt;/code&gt; с</target>
        </trans-unit>
        <trans-unit id="90804637cd522ac07670221ad0bb2db775bb32ba" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ptr&lt;/code&gt;, a value of type &lt;code&gt;allocator_traits&amp;lt;A&amp;gt;::pointer&lt;/code&gt;, obtained by calling &lt;code&gt;allocator_traits&amp;lt;A&amp;gt;::allocate()&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;ptr&lt;/code&gt; , значение типа &lt;code&gt;allocator_traits&amp;lt;A&amp;gt;::pointer&lt;/code&gt; , полученное путем вызова &lt;code&gt;allocator_traits&amp;lt;A&amp;gt;::allocate()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c1816369eba63545ea58a82705ae7b104b2093ee" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ptr&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;ptr&lt;/code&gt;.</target>
        </trans-unit>
        <trans-unit id="98127c9da9e6d997403382be8dae19cbae7b3ddd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;public&lt;/code&gt; access specifier</source>
          <target state="translated">&lt;code&gt;public&lt;/code&gt; спецификатор публичного доступа</target>
        </trans-unit>
        <trans-unit id="c2535c3ba85e352bae5b83bc911fdd83338ce3db" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;public&lt;/code&gt;&lt;code&gt;:&lt;/code&gt;member-declarations</source>
          <target state="translated">&lt;code&gt;public&lt;/code&gt;&lt;code&gt;:&lt;/code&gt;member-declarations</target>
        </trans-unit>
        <trans-unit id="880ecefc2b9aeb88a42626aa4c5046e1af5b36d1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;public&lt;/code&gt;base_class</source>
          <target state="translated">&lt;code&gt;public&lt;/code&gt;base_class</target>
        </trans-unit>
        <trans-unit id="f29797f27b4f5d46325487b01341bb5f6d2c7214" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;purr(kittens...)&lt;/code&gt; may be used in a constant expression if &lt;code&gt;kittens...&lt;/code&gt; can be so used, unless &lt;code&gt;purr&lt;/code&gt; is</source>
          <target state="translated">&lt;code&gt;purr(kittens...)&lt;/code&gt; могут использоваться в постоянном выражении, если &lt;code&gt;kittens...&lt;/code&gt; могут использоваться таким образом, если только &lt;code&gt;purr&lt;/code&gt; не является</target>
        </trans-unit>
        <trans-unit id="e0d0718501a69c7609d845166e16c50475b3cdae" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;purr&lt;/code&gt;, an operation on &lt;code&gt;It&lt;/code&gt; that is required to be supported by MeowIterator,</source>
          <target state="translated">&lt;code&gt;purr&lt;/code&gt; , операция над &lt;code&gt;It&lt;/code&gt; которая должна поддерживаться MeowIterator,</target>
        </trans-unit>
        <trans-unit id="1c67093ec2487091c75ddf44f1541f90c75dca19" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;q1&lt;/code&gt; and &lt;code&gt;q2&lt;/code&gt;, two const iterators into &lt;code&gt;a&lt;/code&gt; such that &lt;code&gt;[q1, q2)&lt;/code&gt; is a valid range</source>
          <target state="translated">&lt;code&gt;q1&lt;/code&gt; и &lt;code&gt;q2&lt;/code&gt; , два константных итераторов в таким образом, что &lt;code&gt;[q1, q2)&lt;/code&gt; является допустимым диапазоном &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="cfc434c5a3d577e8bcb2b5a651536d299f5787e5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;q1&lt;/code&gt;, &lt;code&gt;q2&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;q1&lt;/code&gt; , &lt;code&gt;q2&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="35578f384495877ae734f3d077fa1b9f3901bccf" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;q&lt;/code&gt; is an object of &lt;code&gt;S&lt;/code&gt; and &lt;code&gt;r&lt;/code&gt; is a potentially constant object of &lt;code&gt;S&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;q&lt;/code&gt; является объектом &lt;code&gt;S&lt;/code&gt; и &lt;code&gt;r&lt;/code&gt; является потенциально постоянным объектом &lt;code&gt;S&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4ed03c127fd5c9bdd21111ed8901a64761f9ce66" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;q&lt;/code&gt;, &lt;code&gt;q1&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;q&lt;/code&gt; , &lt;code&gt;q1&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="510143bb4bc0d569aa30b51358da3e4cce321048" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;q&lt;/code&gt;, a lvalue of some type satisfying &lt;a href=&quot;seedsequence&quot;&gt;SeedSequence&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;q&lt;/code&gt; , &lt;a href=&quot;seedsequence&quot;&gt;l-значение&lt;/a&gt; некоторого типа, удовлетворяющее SeedSequence</target>
        </trans-unit>
        <trans-unit id="8126fdcbc449aa27110d9e7e3285749608d7a2cd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;q&lt;/code&gt;, a valid dereferenceable const iterator into &lt;code&gt;a&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;q&lt;/code&gt; , действительный разыменовываемый Неконстантный итератор в &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1ef715c08da87f8dbdf20a665776590c211fc002" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;r&lt;/code&gt; and &lt;code&gt;++r&lt;/code&gt; designate the same iterator object, &lt;code&gt;r&lt;/code&gt; is dereferencable or past-the-end</source>
          <target state="translated">&lt;code&gt;r&lt;/code&gt; и &lt;code&gt;++r&lt;/code&gt; обозначают один и тот же объект итератора, &lt;code&gt;r&lt;/code&gt; - разыменовываемый или устаревший</target>
        </trans-unit>
        <trans-unit id="e4aa33d08f8c0974302181fa64af62a1feb3e5a5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;r&lt;/code&gt; is</source>
          <target state="translated">&lt;code&gt;r&lt;/code&gt; является</target>
        </trans-unit>
        <trans-unit id="46ead29af315ed03ad8d452c8d919f32e38888f0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;r&lt;/code&gt; is dereferencable</source>
          <target state="translated">&lt;code&gt;r&lt;/code&gt; разыменовывается</target>
        </trans-unit>
        <trans-unit id="5d5ac794aec0ac4eeea4af1673a17ee20e884d4a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;r&lt;/code&gt; is incrementable</source>
          <target state="translated">&lt;code&gt;r&lt;/code&gt; увеличивается</target>
        </trans-unit>
        <trans-unit id="39f632268f6c7887230654fc3d3825ae396c158b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;r&lt;/code&gt;, a value of type &lt;code&gt;It&amp;amp;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;r&lt;/code&gt; , значение типа &lt;code&gt;It&amp;amp;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="956d59ddbfc632ab4ded450c800a2bd4f897f931" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;r&lt;/code&gt;, an lvalue of type &lt;code&gt;CharT&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;r&lt;/code&gt; , значение типа &lt;code&gt;CharT&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="80db8cfc9956eb3c1de4af7a53e262df60a93cab" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;r&lt;/code&gt;, an lvalue of type &lt;code&gt;It&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;r&lt;/code&gt; , значение типа &lt;code&gt;It&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d89f7173bffdb7dff443cf98d95ae9c1e5c89f58" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;r&lt;/code&gt;, an lvalue of type &lt;code&gt;T&lt;/code&gt; obtained by the expression &lt;code&gt;*ptr&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;r&lt;/code&gt; - значение типа &lt;code&gt;T&lt;/code&gt; , полученное выражением &lt;code&gt;*ptr&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="349b097a8745964e5528610acb2d276c44b2dfa4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;r&lt;/code&gt;, an lvalue of type &lt;code&gt;X&lt;/code&gt;,</source>
          <target state="translated">&lt;code&gt;r&lt;/code&gt; , значение типа &lt;code&gt;X&lt;/code&gt; ,</target>
        </trans-unit>
        <trans-unit id="2a20f01e1c4c5aeb82b93359a535bd4702ce8246" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;rand()&lt;/code&gt; is not recommended for serious random-number generation needs. It is recommended to use C++11's &lt;a href=&quot;../random&quot;&gt;random number generation&lt;/a&gt; facilities to replace rand().(since C++11).</source>
          <target state="translated">&lt;code&gt;rand()&lt;/code&gt; не рекомендуется для серьезных задач генерации случайных чисел. Для замены rand () рекомендуется использовать средства &lt;a href=&quot;../random&quot;&gt;генерации случайных чисел&lt;/a&gt; в C ++ 11 (начиная с C ++ 11).</target>
        </trans-unit>
        <trans-unit id="63092ad067b962bb744290c3b8860b9cad535111" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;random_access_iterator_tag&lt;/code&gt; corresponds to &lt;a href=&quot;../named_req/randomaccessiterator&quot;&gt;LegacyRandomAccessIterator&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;random_access_iterator_tag&lt;/code&gt; соответствует &lt;a href=&quot;../named_req/randomaccessiterator&quot;&gt;LegacyRandomAccessIterator&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="dc4b04723ffa3c7143c9033f54c289926dd19cca" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ranges::begin(E)&lt;/code&gt; and &lt;code&gt;ranges::begin(t)&lt;/code&gt; are</source>
          <target state="translated">&lt;code&gt;ranges::begin(E)&lt;/code&gt; и &lt;code&gt;ranges::begin(t)&lt;/code&gt; являются</target>
        </trans-unit>
        <trans-unit id="b44969908c2d08c23acc53cd6c178ed7acff3351" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ranges::end(E)&lt;/code&gt; and &lt;code&gt;ranges::end(t)&lt;/code&gt; are</source>
          <target state="translated">&lt;code&gt;ranges::end(E)&lt;/code&gt; и &lt;code&gt;ranges::end(t)&lt;/code&gt; являются</target>
        </trans-unit>
        <trans-unit id="800883fa519bd72070c2a1e0287106b2d0d8562f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ranlux24&lt;/code&gt;(C++11)</source>
          <target state="translated">&lt;code&gt;ranlux24&lt;/code&gt;(C++11)</target>
        </trans-unit>
        <trans-unit id="2d565ea845f27d2bb1fbace67d387f1fca3ecf86" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ranlux24_base&lt;/code&gt;(C++11)</source>
          <target state="translated">&lt;code&gt;ranlux24_base&lt;/code&gt;(C++11)</target>
        </trans-unit>
        <trans-unit id="7d876385690e83f9f74ca8d39f8cb05c887c309e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ranlux48&lt;/code&gt;(C++11)</source>
          <target state="translated">&lt;code&gt;ranlux48&lt;/code&gt;(C++11)</target>
        </trans-unit>
        <trans-unit id="5910f409e209ee99f841ab8f3183517a83eb6098" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ranlux48_base&lt;/code&gt;(C++11)</source>
          <target state="translated">&lt;code&gt;ranlux48_base&lt;/code&gt;(C++11)</target>
        </trans-unit>
        <trans-unit id="69601cbb8b00f423e101d5c4b9fa8eafd68af897" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;rb&lt;/code&gt;,&lt;code&gt;re&lt;/code&gt; are &lt;a href=&quot;outputiterator&quot;&gt;mutable&lt;/a&gt;&lt;a href=&quot;randomaccessiterator&quot;&gt;LegacyRandomAccessIterators&lt;/a&gt; with a &lt;code&gt;value_type&lt;/code&gt; of unsigned integer values of at least 32 bits.</source>
          <target state="translated">&lt;code&gt;rb&lt;/code&gt; , &lt;code&gt;re&lt;/code&gt; являются &lt;a href=&quot;outputiterator&quot;&gt;изменяемыми &lt;/a&gt;&lt;a href=&quot;randomaccessiterator&quot;&gt;LegacyRandomAccessIterators&lt;/a&gt; с &lt;code&gt;value_type&lt;/code&gt; целочисленных значений без знака, по крайней мере, 32 бита.</target>
        </trans-unit>
        <trans-unit id="1f38e682c94bea1b1ea626cf465e65d010cdb40a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;rcopy&lt;/code&gt;, a distinct object that is equal to &lt;code&gt;rhs&lt;/code&gt;,</source>
          <target state="translated">&lt;code&gt;rcopy&lt;/code&gt; , отдельный объект, равный &lt;code&gt;rhs&lt;/code&gt; ,</target>
        </trans-unit>
        <trans-unit id="bfb39847458d7f586b236cc53d450da13c194e64" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;rdbuf()-&amp;gt;sputbackc()&lt;/code&gt; or &lt;code&gt;rdbuf()-&amp;gt;sungetc()&lt;/code&gt; return &lt;code&gt;traits::eof()&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;rdbuf()-&amp;gt;sputbackc()&lt;/code&gt; или &lt;code&gt;rdbuf()-&amp;gt;sungetc()&lt;/code&gt; возвращают &lt;code&gt;traits::eof()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b663b26438681e782f763683bd9154b1ec2d8361" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;rebind&lt;/code&gt;(deprecated in C++17)(removed in C++20)</source>
          <target state="translated">&lt;code&gt;rebind&lt;/code&gt; (устарела в C ++ 17) (удалена в C ++ 20)</target>
        </trans-unit>
        <trans-unit id="0cd838c1a4cc8e60af9a0e537b3692cd18cb8e28" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;recursive_directory_iterator&lt;/code&gt; is an &lt;a href=&quot;../named_req/inputiterator&quot;&gt;LegacyInputIterator&lt;/a&gt; that iterates over the &lt;a href=&quot;directory_entry&quot;&gt;&lt;code&gt;directory_entry&lt;/code&gt;&lt;/a&gt; elements of a directory, and, recursively, over the entries of all subdirectories. The iteration order is unspecified, except that each directory entry is visited only once.</source>
          <target state="translated">&lt;code&gt;recursive_directory_iterator&lt;/code&gt; является &lt;a href=&quot;../named_req/inputiterator&quot;&gt;LegacyInputIterator&lt;/a&gt; , что перебирает &lt;a href=&quot;directory_entry&quot;&gt; &lt;code&gt;directory_entry&lt;/code&gt; &lt;/a&gt; элементы каталога, и, рекурсивно, над записями всех подкаталогов. Порядок итераций не указан, за исключением того, что каждая запись каталога посещается только один раз.</target>
        </trans-unit>
        <trans-unit id="30dc9f28b8f62cbb2bc8ffe10de818246455e131" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;recursive_mutex&lt;/code&gt; offers exclusive, recursive ownership semantics:</source>
          <target state="translated">&lt;code&gt;recursive_mutex&lt;/code&gt; предлагает эксклюзивную рекурсивную семантику владения:</target>
        </trans-unit>
        <trans-unit id="598e7618503b29c6fbb045f594ce4024c5ec9942" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ref_&amp;shy;view&lt;/code&gt; is a &lt;a href=&quot;view&quot;&gt;&lt;code&gt;View&lt;/code&gt;&lt;/a&gt; of the elements of some other &lt;a href=&quot;range&quot;&gt;&lt;code&gt;Range&lt;/code&gt;&lt;/a&gt;. It wraps a reference to that &lt;code&gt;Range&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;ref_&amp;shy;view&lt;/code&gt; является &lt;a href=&quot;view&quot;&gt; &lt;code&gt;View&lt;/code&gt; &lt;/a&gt; элементов некоторого другого &lt;a href=&quot;range&quot;&gt; &lt;code&gt;Range&lt;/code&gt; &lt;/a&gt; . Оборачивает ссылку на этот &lt;code&gt;Range&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2f69b53eb3b26327fb1b3702a93e2c01575ac711" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;reference,&lt;/code&gt; the type denoted by &lt;code&gt;std::iterator_traits&amp;lt;It&amp;gt;::reference&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;reference,&lt;/code&gt; тип, обозначенный как &lt;code&gt;std::iterator_traits&amp;lt;It&amp;gt;::reference&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="60c35e0f46449e1c244042bacc03642577f30615" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;reference&lt;/code&gt; - defines a reference to the type iterated over (&lt;code&gt;value_type&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;reference&lt;/code&gt; - определяет ссылку на тип, повторяемый ( &lt;code&gt;value_type&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="abcf815b721ede9c83eedeb75e9115c1eba2b395" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;reference&lt;/code&gt;(deprecated in C++17)(removed in C++20)</source>
          <target state="translated">&lt;code&gt;reference&lt;/code&gt; (устарела в C ++ 17) (удалена в C ++ 20)</target>
        </trans-unit>
        <trans-unit id="f3666f59f83dac548eb815cb74c9381040b8d908" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;reference&lt;/code&gt;, convertible to &lt;code&gt;value_type&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;reference&lt;/code&gt; , конвертируемая в &lt;code&gt;value_type&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4ac3623e8103740b628f9cb099baaddf8ca2ec66" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;reference&lt;/code&gt;, the type denoted by &lt;code&gt;&lt;a href=&quot;../iterator/iterator_traits&quot;&gt;std::iterator_traits&lt;/a&gt;&amp;lt;It&amp;gt;::reference&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;reference&lt;/code&gt; , тип, обозначенный как &lt;code&gt;&lt;a href=&quot;../iterator/iterator_traits&quot;&gt;std::iterator_traits&lt;/a&gt;&amp;lt;It&amp;gt;::reference&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="85eb9faf32144c3d811f6fc0dc7cab7837909b60" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;refs&lt;/code&gt; is used for resource management: if &lt;code&gt;refs == 0&lt;/code&gt;, the implementation destroys the facet, when the last &lt;code&gt;&lt;a href=&quot;locale&quot;&gt;std::locale&lt;/a&gt;&lt;/code&gt; object holding it is destroyed. Otherwise, the object is not destroyed.</source>
          <target state="translated">&lt;code&gt;refs&lt;/code&gt; используется для управления ресурсами: если &lt;code&gt;refs == 0&lt;/code&gt; , реализация уничтожает фасет, когда уничтожается последний объект &lt;code&gt;&lt;a href=&quot;locale&quot;&gt;std::locale&lt;/a&gt;&lt;/code&gt; содержащий его. В противном случае объект не будет уничтожен.</target>
        </trans-unit>
        <trans-unit id="0770f5fc37f5b2939a35296243da85be1cc805d6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;regex_replace&lt;/code&gt; uses a regular expression to perform substitution on a sequence of characters:</source>
          <target state="translated">&lt;code&gt;regex_replace&lt;/code&gt; использует регулярное выражение для выполнения замены последовательности символов:</target>
        </trans-unit>
        <trans-unit id="3abfeba8a9c538f0cf69429a4f827b597bda06a0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;regex_search&lt;/code&gt; will successfully match any subsequence of the given sequence, whereas &lt;code&gt;&lt;a href=&quot;regex_match&quot;&gt;std::regex_match&lt;/a&gt;&lt;/code&gt; will only return &lt;code&gt;true&lt;/code&gt; if the regular expression matches the</source>
          <target state="translated">&lt;code&gt;regex_search&lt;/code&gt; будет успешно соответствовать любой подпоследовательности данной последовательности, тогда как &lt;code&gt;&lt;a href=&quot;regex_match&quot;&gt;std::regex_match&lt;/a&gt;&lt;/code&gt; вернет &lt;code&gt;true&lt;/code&gt; , только если регулярное выражение соответствует</target>
        </trans-unit>
        <trans-unit id="fd08c8dd3fa527f82569a2f504f2043aa282f84c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;register&lt;/code&gt; -</source>
          <target state="translated">&lt;code&gt;register&lt;/code&gt; -</target>
        </trans-unit>
        <trans-unit id="a4b18bcf26db26f86cb624fc878d8f89231e92b2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;rehash(0)&lt;/code&gt; may be used to force an unconditional rehash, such as after suspension of automatic rehashing by temporarily increasing &lt;code&gt;max_load_factor()&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;rehash(0)&lt;/code&gt; может использоваться для принудительной безусловной перефразировки, например, после приостановки автоматической перефразировки путем временного увеличения &lt;code&gt;max_load_factor()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d303fc5ae6388cc35f1ecf3e0b09b3ec63f9eb2c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;reinterpret_cast &amp;lt;&lt;/code&gt;new_type&lt;code&gt;&amp;gt; (&lt;/code&gt;expression&lt;code&gt;)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;reinterpret_cast &amp;lt;&lt;/code&gt; new_type &lt;code&gt;&amp;gt; (&lt;/code&gt; выражение &lt;code&gt;)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="14460c574491c661c3edad1c4eaa6d0c1d141919" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;reinterpret_cast&lt;/code&gt; conversion</source>
          <target state="translated">&lt;code&gt;reinterpret_cast&lt;/code&gt; преобразование</target>
        </trans-unit>
        <trans-unit id="9fb828870ecbababc828107487f0641b7befa4b6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;requires&lt;/code&gt;&lt;code&gt;(&lt;/code&gt;parameter-list(optional)&lt;code&gt;)&lt;/code&gt;&lt;code&gt;{ &lt;/code&gt;requirement-seq&lt;code&gt;} &lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;requires&lt;/code&gt; &lt;code&gt;(&lt;/code&gt; список параметров (необязательно) &lt;code&gt;)&lt;/code&gt; &lt;code&gt;{ &lt;/code&gt; require-seq &lt;code&gt;} &lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7d54690ec4ac98e1852dca752d039b531cc70949" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;requires&lt;/code&gt;&lt;code&gt;{ &lt;/code&gt;requirement-seq&lt;code&gt;} &lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;requires&lt;/code&gt; &lt;code&gt;{ &lt;/code&gt; требование-последовательность &lt;code&gt;} &lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4effb89389c1532c36384587723fd397983c5c02" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;requires&lt;/code&gt;constraint-expression&lt;code&gt;;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;requires&lt;/code&gt;constraint-expression&lt;code&gt;;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="fdf531d04698e1e674e0df4bfd21bfed4b6ed6b5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;reserve()&lt;/code&gt; cannot be used to reduce the capacity of the container; to that end &lt;code&gt;&lt;a href=&quot;shrink_to_fit&quot;&gt;shrink_to_fit()&lt;/a&gt;&lt;/code&gt; is provided.</source>
          <target state="translated">&lt;code&gt;reserve()&lt;/code&gt; не может быть использован для уменьшения емкости контейнера; для этого предоставляется &lt;code&gt;&lt;a href=&quot;shrink_to_fit&quot;&gt;shrink_to_fit()&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1c317ad0068ea950a562690062c814fdd39b88a3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;reserve()&lt;/code&gt; does not change the size of the vector.</source>
          <target state="translated">&lt;code&gt;reserve()&lt;/code&gt; не меняет размер вектора.</target>
        </trans-unit>
        <trans-unit id="36ee631c57d63311fe1e24caeb9fd6f7f45220bc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;result_type&lt;/code&gt;(deprecated in C++17)</source>
          <target state="translated">&lt;code&gt;result_type&lt;/code&gt; (устарел в C ++ 17)</target>
        </trans-unit>
        <trans-unit id="9f29033a26d7952123ef1720a8d7e5f132e49d5c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;result_type&lt;/code&gt;(deprecated in C++17)(removed in C++20)</source>
          <target state="translated">&lt;code&gt;result_type&lt;/code&gt; (устарел в C ++ 17) (удален в C ++ 20)</target>
        </trans-unit>
        <trans-unit id="ecfcc8cf0eb270aacf613b351daa7c984fd6411a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;result_type&lt;/code&gt;(deprecated in c++17)</source>
          <target state="translated">&lt;code&gt;result_type&lt;/code&gt; (устарел в c ++ 17)</target>
        </trans-unit>
        <trans-unit id="53205186a9d1b9e609da0735d2a91c945832654c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;return { &lt;/code&gt;arg1, arg2, ...&lt;code&gt;}&amp;nbsp;;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;return { &lt;/code&gt; arg1, arg2, ... &lt;code&gt;}&amp;nbsp;;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a7a0e4ff406666b99cf5b53f8b57040d63d0d362" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;return&lt;/code&gt;object&lt;code&gt;;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;return&lt;/code&gt;object&lt;code&gt;;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5dfc017bb05e736eb42027876df7331521a9164f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;return&lt;/code&gt;other&lt;code&gt;;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;return&lt;/code&gt;other&lt;code&gt;;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b72d3a462726fd7091404eb215473552ec092f7d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;reverse_iterator&lt;/code&gt;; &lt;code&gt;const_reverse_iterator&lt;/code&gt; for constant &lt;code&gt;a&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;reverse_iterator&lt;/code&gt; ; &lt;code&gt;const_reverse_iterator&lt;/code&gt; для константы &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="cf468550f1171a88fbcc93509e42cbedafa6fdad" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;rhs.base() - lhs.base()&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;rhs.base() - lhs.base()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="97ca0442554e3e00894e57c816c145d8ef910d43" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;rhs&lt;/code&gt; as determined by the owner-based ordering.</source>
          <target state="translated">&lt;code&gt;rhs&lt;/code&gt; как определено основанным на владельце заказом</target>
        </trans-unit>
        <trans-unit id="0e60c7bec1515be2c2a36930ced4b3085ed7343d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;rhs&lt;/code&gt; if, and only if, &lt;code&gt;rhs&lt;/code&gt; contains a value and &lt;code&gt;lhs&lt;/code&gt; does not.</source>
          <target state="translated">&lt;code&gt;rhs&lt;/code&gt; тогда и только тогда, когда &lt;code&gt;rhs&lt;/code&gt; содержит значение, а &lt;code&gt;lhs&lt;/code&gt; - нет.</target>
        </trans-unit>
        <trans-unit id="c174340582093b0d466d6c3647a1351bb9d3ec1a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;rhs&lt;/code&gt; if, and only if, both &lt;code&gt;lhs&lt;/code&gt; and &lt;code&gt;rhs&lt;/code&gt; do not contain a value.</source>
          <target state="translated">&lt;code&gt;rhs&lt;/code&gt; тогда и только тогда, когда &lt;code&gt;lhs&lt;/code&gt; и &lt;code&gt;rhs&lt;/code&gt; не содержат значения.</target>
        </trans-unit>
        <trans-unit id="565957bc63bd899f43c3c7e99a64361f55afc1d7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;rhs&lt;/code&gt;, &lt;code&gt;false&lt;/code&gt; otherwise.</source>
          <target state="translated">&lt;code&gt;rhs&lt;/code&gt; , &lt;code&gt;false&lt;/code&gt; противном случае.</target>
        </trans-unit>
        <trans-unit id="f801c14939021b1abafe3a8ff39f5b5192b017e2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;rhs&lt;/code&gt;, an expression such that &lt;code&gt;decltype((rhs))&lt;/code&gt; is &lt;code&gt;RHS&lt;/code&gt;,</source>
          <target state="translated">&lt;code&gt;rhs&lt;/code&gt; , выражение такое, что &lt;code&gt;decltype((rhs))&lt;/code&gt; является &lt;code&gt;RHS&lt;/code&gt; ,</target>
        </trans-unit>
        <trans-unit id="06b8452485cd1012fdc37402144dfc5c1fc47e4a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;rhs&lt;/code&gt;, or to the same time point as &lt;code&gt;rhs&lt;/code&gt;, &lt;code&gt;false&lt;/code&gt; otherwise.</source>
          <target state="translated">&lt;code&gt;rhs&lt;/code&gt; или в тот же момент времени, что и &lt;code&gt;rhs&lt;/code&gt; , в противном случае - &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f75d3402a3e508993184ec535748f1aa5f7fd557" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;rhs&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;rhs&lt;/code&gt;.</target>
        </trans-unit>
        <trans-unit id="ba9ce0fa5cec935b2c8522b016d18d19dd1e12ac" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;rv&lt;/code&gt;, a non-const rvalue of type &lt;code&gt;X::value_type&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;rv&lt;/code&gt; , неконстантное значение типа &lt;code&gt;X::value_type&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d23ebc7f5ccc22387d2fcae2190fa7ada5611250" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;rv&lt;/code&gt;, an &lt;a href=&quot;../language/value_category&quot;&gt;rvalue&lt;/a&gt; expression of type &lt;code&gt;T&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;rv&lt;/code&gt; , &lt;a href=&quot;../language/value_category&quot;&gt;rvalue-&lt;/a&gt; выражение типа &lt;code&gt;T&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="03db902365c41636203b9c342c8ba4a53c80e104" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;rv&lt;/code&gt;, an rvalue of type &lt;code&gt;T&lt;/code&gt;, and</source>
          <target state="translated">&lt;code&gt;rv&lt;/code&gt; , значение r типа &lt;code&gt;T&lt;/code&gt; и</target>
        </trans-unit>
        <trans-unit id="184f94c984426654bdbda6329a8491ce29b9b1b0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;s2&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;s2&lt;/code&gt;.</target>
        </trans-unit>
        <trans-unit id="86bfb8d2d1f71afee842e4a2ab03f528b4510a70" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;s&lt;/code&gt;, a value of type &lt;code&gt;CharT*&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;s&lt;/code&gt; , значение типа &lt;code&gt;CharT*&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d0ab2d78e8c406f38df50f0691bde80be6d60c17" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;s&lt;/code&gt;, a value of type &lt;code&gt;T&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;s&lt;/code&gt; , значение типа &lt;code&gt;T&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8db70f70831b4c294a499fa786043548a5c6e2cd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;s&lt;/code&gt;, an object of type &lt;code&gt;X::string_type&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;s&lt;/code&gt; , объект типа &lt;code&gt;X::string_type&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="26ddc407a8dc737f9234973e0a96e43e6529d514" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;scientific|fixed&lt;/code&gt;. Useful for masking operations</source>
          <target state="translated">&lt;code&gt;scientific|fixed&lt;/code&gt; . Полезно для маскировки</target>
        </trans-unit>
        <trans-unit id="3b72e415dad9c30cfbfd7cc356cb8ffee8f09ce7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;scoped_allocator_adaptor&amp;lt;InnerAllocs...&amp;gt;&lt;/code&gt; or, if &lt;code&gt;sizeof...(InnerAllocs) == 0&lt;/code&gt;, &lt;code&gt;scoped_allocator_adaptor&amp;lt;OuterAlloc&amp;gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;scoped_allocator_adaptor&amp;lt;InnerAllocs...&amp;gt;&lt;/code&gt; или, если &lt;code&gt;sizeof...(InnerAllocs) == 0&lt;/code&gt; , &lt;code&gt;scoped_allocator_adaptor&amp;lt;OuterAlloc&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="eb19d02e623ce44c8baceb5958f961c939ef04dc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;second_argument_type&lt;/code&gt;(deprecated in C++17)</source>
          <target state="translated">&lt;code&gt;second_argument_type&lt;/code&gt; (устарел в C ++ 17)</target>
        </trans-unit>
        <trans-unit id="083845aa3ea21544c8ba2547aa3c7c77463199ac" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;second_argument_type&lt;/code&gt;(deprecated in C++17)(removed in C++20)</source>
          <target state="translated">&lt;code&gt;second_argument_type&lt;/code&gt; (устарело в C ++ 17) (удалено в C ++ 20)</target>
        </trans-unit>
        <trans-unit id="f4d51052d4b9993e738ae3d474d50f444db05ed2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;second_argument_type&lt;/code&gt;(deprecated in c++17)</source>
          <target state="translated">&lt;code&gt;second_argument_type&lt;/code&gt; (устарело в c ++ 17)</target>
        </trans-unit>
        <trans-unit id="af796c30ead3a9fdf671d740087f35fb78179325" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;seconds()&lt;/code&gt; returns the integral number of seconds &lt;code&gt;since_midnight&lt;/code&gt; is after &lt;code&gt;(00:00:00 + hours() + minutes())&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;seconds()&lt;/code&gt; возвращает целое число секунд, &lt;code&gt;since_midnight&lt;/code&gt; - после &lt;code&gt;(00:00:00 + hours() + minutes())&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e84262979b83b06a446439fcf9438a7168d791ca" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;seek_dir&lt;/code&gt;(deprecated)</source>
          <target state="translated">&lt;code&gt;seek_dir&lt;/code&gt;(deprecated)</target>
        </trans-unit>
        <trans-unit id="4ef2fc6bec3d3f6ea251d4cfc5eaea77641e1555" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;seekg&lt;/code&gt; behaves as &lt;a href=&quot;../../named_req/unformattedinputfunction&quot;&gt;UnformattedInputFunction&lt;/a&gt;, except that &lt;code&gt;&lt;a href=&quot;gcount&quot;&gt;gcount()&lt;/a&gt;&lt;/code&gt; is not affected. After constructing and checking the sentry object,</source>
          <target state="translated">&lt;code&gt;seekg&lt;/code&gt; ведет себя как &lt;a href=&quot;../../named_req/unformattedinputfunction&quot;&gt;UnformattedInputFunction&lt;/a&gt; , за исключением того, что на &lt;code&gt;&lt;a href=&quot;gcount&quot;&gt;gcount()&lt;/a&gt;&lt;/code&gt; это не влияет. После создания и проверки сторожевого объекта,</target>
        </trans-unit>
        <trans-unit id="3859b43d876458b72bdd19fcf82fc23176f8083f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;seekoff()&lt;/code&gt; is called by &lt;code&gt;std::basic_streambuf::pubseekoff&lt;/code&gt;, which is called by &lt;code&gt;std::basic_istream::seekg&lt;/code&gt;, &lt;code&gt;std::basic_ostream::seekp&lt;/code&gt;, &lt;code&gt;std::basic_istream::tellg&lt;/code&gt;, and &lt;code&gt;std::basic_ostream::tellp&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;seekoff()&lt;/code&gt; вызывается с помощью &lt;code&gt;std::basic_streambuf::pubseekoff&lt;/code&gt; , который вызывается с помощью &lt;code&gt;std::basic_istream::seekg&lt;/code&gt; , &lt;code&gt;std::basic_ostream::seekp&lt;/code&gt; , &lt;code&gt;std::basic_istream::tellg&lt;/code&gt; и &lt;code&gt;std::basic_ostream::tellp&lt;/code&gt; ,</target>
        </trans-unit>
        <trans-unit id="57787c098e93d798111197b309a8dfb0121cf24c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;seekpos()&lt;/code&gt; is called by &lt;code&gt;&lt;a href=&quot;../basic_streambuf/pubseekpos&quot;&gt;std::basic_streambuf::pubseekpos()&lt;/a&gt;&lt;/code&gt;, which is called by the single-argument versions of &lt;code&gt;&lt;a href=&quot;../basic_istream/seekg&quot;&gt;std::basic_istream::seekg()&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../basic_ostream/seekp&quot;&gt;std::basic_ostream::seekp()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;seekpos()&lt;/code&gt; вызывается &lt;code&gt;&lt;a href=&quot;../basic_streambuf/pubseekpos&quot;&gt;std::basic_streambuf::pubseekpos()&lt;/a&gt;&lt;/code&gt; , которая вызывается версиями &lt;code&gt;&lt;a href=&quot;../basic_istream/seekg&quot;&gt;std::basic_istream::seekg()&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;../basic_ostream/seekp&quot;&gt;std::basic_ostream::seekp()&lt;/a&gt;&lt;/code&gt; с одним аргументом .</target>
        </trans-unit>
        <trans-unit id="be1052ab32228a15576834a15d52cfde8554eb29" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;setbuf()&lt;/code&gt; may be called after opening the file, but before any I/O (may crash otherwise). With a user-provided buffer, reading from file reads largest multiples of 4096 that fit in the buffer.</source>
          <target state="translated">&lt;code&gt;setbuf()&lt;/code&gt; может быть вызван после открытия файла, но перед любым вводом / выводом (в противном случае может произойти сбой). С предоставленным пользователем буфером чтение из файла считывает наибольшее число, кратное 4096, которое помещается в буфер.</target>
        </trans-unit>
        <trans-unit id="f6144b5565e83fdf200e5745c534734a6d046f07" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;setbuf()&lt;/code&gt; may be called at any time, even after some I/O took place. Current contents of the buffer, if any, are lost.</source>
          <target state="translated">&lt;code&gt;setbuf()&lt;/code&gt; может быть вызван в любое время, даже после некоторого ввода-вывода. Текущее содержимое буфера, если оно есть, потеряно.</target>
        </trans-unit>
        <trans-unit id="323507d89c10daabb8de88ec6a458b1f6bb35383" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;setbuf()&lt;/code&gt; may only be called when the &lt;code&gt;&lt;a href=&quot;../basic_filebuf&quot;&gt;std::basic_filebuf&lt;/a&gt;&lt;/code&gt; is not associated with a file (has no effect otherwise). With a user-provided buffer, reading from file reads &lt;code&gt;n-1&lt;/code&gt; bytes at a time.</source>
          <target state="translated">&lt;code&gt;setbuf()&lt;/code&gt; может быть вызван только тогда, когда &lt;code&gt;&lt;a href=&quot;../basic_filebuf&quot;&gt;std::basic_filebuf&lt;/a&gt;&lt;/code&gt; не связан с файлом (в противном случае это не имеет никакого эффекта). С предоставленным пользователем буфером чтение из файла считывает &lt;code&gt;n-1&lt;/code&gt; байт за раз.</target>
        </trans-unit>
        <trans-unit id="b741f6475a4db6325d4c2a84af32b33137e4f09c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;share()&lt;/code&gt; requires &lt;code&gt;valid()&lt;/code&gt; to be &lt;code&gt;true&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;share()&lt;/code&gt; требует, чтобы &lt;code&gt;valid()&lt;/code&gt; был &lt;code&gt;true&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a9b9155015e2be62108cf1293fbf94ee9dcaeb29" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;short&lt;/code&gt; - target type will be optimized for space and will have width of at least 16 bits.</source>
          <target state="translated">&lt;code&gt;short&lt;/code&gt; - тип цели будет оптимизирован для пространства и будет иметь ширину не менее 16 бит.</target>
        </trans-unit>
        <trans-unit id="123cd1b0c99105ee84e7c9596d06e3bc090d142a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;short&lt;/code&gt; type modifier</source>
          <target state="translated">&lt;code&gt;short&lt;/code&gt; модификатор короткого типа</target>
        </trans-unit>
        <trans-unit id="00cee6c0e1d6a509e189e8ac023c2419b1eda94d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;shuffle_order_engine&lt;/code&gt; is a random number engine adaptor that shuffles the random numbers generated by the base engine. It maintains a table of size &lt;code&gt;K&lt;/code&gt; and delivers a randomly selected number from that table when requested, replacing it with a number generated by the base engine.</source>
          <target state="translated">&lt;code&gt;shuffle_order_engine&lt;/code&gt; - это адаптер движка случайных чисел, который перемешивает случайные числа, сгенерированные базовым движком. Он поддерживает таблицу размера &lt;code&gt;K&lt;/code&gt; и выдает случайно выбранное число из этой таблицы по запросу, заменяя его числом, сгенерированным базовым механизмом.</target>
        </trans-unit>
        <trans-unit id="91ecdd19dc81d00e8c83ad49e607d64ce37755a4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;signed char*&lt;/code&gt; or &lt;code&gt;unsigned char*&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;signed char*&lt;/code&gt; или &lt;code&gt;unsigned char*&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="99b1822957ab42790e46e37e8a072c0c142570dd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;signed char&lt;/code&gt; - type for signed character representation.</source>
          <target state="translated">&lt;code&gt;signed char&lt;/code&gt; - тип для представления со знаком.</target>
        </trans-unit>
        <trans-unit id="596da374058fd7f0afbd5bbfcab7831fa9ecc192" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;signed char&lt;/code&gt; or &lt;code&gt;signed short&lt;/code&gt; can be converted to &lt;code&gt;int&lt;/code&gt;;</source>
          <target state="translated">&lt;code&gt;signed char&lt;/code&gt; или &lt;code&gt;signed short&lt;/code&gt; может быть преобразован в &lt;code&gt;int&lt;/code&gt; ;</target>
        </trans-unit>
        <trans-unit id="97c41131c74026f6e0bd5d8a010afc2374be4c86" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;signed int*&lt;/code&gt; or &lt;code&gt;unsigned int*&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;signed int*&lt;/code&gt; или &lt;code&gt;unsigned int*&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="390386b58ee200c58393ed79e778468e78146d2d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;signed long long*&lt;/code&gt; or &lt;code&gt;unsigned long long*&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;signed long long*&lt;/code&gt; или &lt;code&gt;unsigned long long*&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c67607f035def4bfabdfda943eebe4134024166f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;signed long*&lt;/code&gt; or &lt;code&gt;unsigned long*&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;signed long*&lt;/code&gt; или &lt;code&gt;unsigned long*&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="cb4277f86bbc8fa4d2dcac6e5b0970f2986f4dbd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;signed short*&lt;/code&gt; or &lt;code&gt;unsigned short*&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;signed short*&lt;/code&gt; или &lt;code&gt;unsigned short*&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1ebc8f89a2a9e50681b4e5e39d16abf9fa7fa81d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;signed&lt;/code&gt; - target type will have signed representation (this is the default if omitted)</source>
          <target state="translated">&lt;code&gt;signed&lt;/code&gt; - у целевого типа будет подписанное представление (по умолчанию, если оно опущено)</target>
        </trans-unit>
        <trans-unit id="fbc6c6b5d94333cdff627e24c708ccae2b37208c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;signed&lt;/code&gt; type modifier</source>
          <target state="translated">&lt;code&gt;signed&lt;/code&gt; модификатор типа</target>
        </trans-unit>
        <trans-unit id="7b7aafb7a506ca43395920321487c82e485d5bc2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;size() == 0&lt;/code&gt; (&lt;code&gt;false&lt;/code&gt; if &lt;code&gt;*this&lt;/code&gt; represents the result of a successful match, &lt;code&gt;true&lt;/code&gt; otherwise).</source>
          <target state="translated">&lt;code&gt;size() == 0&lt;/code&gt; ( &lt;code&gt;false&lt;/code&gt; , если &lt;code&gt;*this&lt;/code&gt; результат успешного совпадения, в противном случае - &lt;code&gt;true&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="a0200f935f43d9ea73514596b9949236ec288429" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;sizeof(&lt;/code&gt;type&lt;code&gt;)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;sizeof(&lt;/code&gt;type&lt;code&gt;)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="74f6283da9a908523be109da51f59eccc8b34ea4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;sizeof(char)&lt;/code&gt;, &lt;code&gt;sizeof(char8_t)&lt;/code&gt;, &lt;code&gt;sizeof(signed char)&lt;/code&gt;, and &lt;code&gt;sizeof(unsigned char)&lt;/code&gt; are always equal to &lt;code&gt;1&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;sizeof(char)&lt;/code&gt; , &lt;code&gt;sizeof(char8_t)&lt;/code&gt; , &lt;code&gt;sizeof(signed char)&lt;/code&gt; знаком) и &lt;code&gt;sizeof(unsigned char)&lt;/code&gt; всегда равны &lt;code&gt;1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f2d407c4db07ea8eef95042a8a76e72dab2cb554" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;sizeof...(&lt;/code&gt;parameter_pack&lt;code&gt;)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;sizeof...(&lt;/code&gt;parameter_pack&lt;code&gt;)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7d8295868555deebe8ffb79d642c5c679c33ab6b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;sizeof...(Types) != 1&lt;/code&gt; or</source>
          <target state="translated">&lt;code&gt;sizeof...(Types) != 1&lt;/code&gt; или</target>
        </trans-unit>
        <trans-unit id="b2dd33a1c9d816423d275199656286347d3db010" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;sizeof...(Types) == sizeof...(UTypes)&lt;/code&gt; and</source>
          <target state="translated">&lt;code&gt;sizeof...(Types) == sizeof...(UTypes)&lt;/code&gt; и</target>
        </trans-unit>
        <trans-unit id="1cdc29f44e0d0eb9ab54a7720438cfdfe2e6fc57" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;sizeof&lt;/code&gt; operator</source>
          <target state="translated">&lt;code&gt;sizeof&lt;/code&gt; оператор sizeof</target>
        </trans-unit>
        <trans-unit id="fdc4b227ac6249bc4fc72287a6944b2440e3ed95" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;sizeof&lt;/code&gt;expression</source>
          <target state="translated">&lt;code&gt;sizeof&lt;/code&gt;expression</target>
        </trans-unit>
        <trans-unit id="e46af83e16a811405d39a5136eed045dbc6877d4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;slice_array&lt;/code&gt; to initialize with</source>
          <target state="translated">&lt;code&gt;slice_array&lt;/code&gt; для инициализации</target>
        </trans-unit>
        <trans-unit id="b2bcdf452501c9b678e966ff76f6fd25eca36018" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;sp&lt;/code&gt; on success or &lt;code&gt;pos_type(off_type(-1))&lt;/code&gt; on failure.</source>
          <target state="translated">&lt;code&gt;sp&lt;/code&gt; в случае успеха или &lt;code&gt;pos_type(off_type(-1))&lt;/code&gt; в случае ошибки.</target>
        </trans-unit>
        <trans-unit id="7d41a831635e74183514711ce5e212aa8540f055" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;space_info.available&lt;/code&gt; is set to &lt;code&gt;f_bavail*f_frsize&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;space_info.available&lt;/code&gt; задано значение &lt;code&gt;f_bavail*f_frsize&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ec90f237c7368e2b51a082ed93cf39569cde5592" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;space_info.capacity&lt;/code&gt; is set as if by &lt;code&gt;f_blocks*f_frsize&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;space_info.capacity&lt;/code&gt; устанавливается как бы &lt;code&gt;f_blocks*f_frsize&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="956d7231f6bf9b016483d7b4a0fed9bae1d5fd31" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;space_info.free&lt;/code&gt; is set to &lt;code&gt;f_bfree*f_frsize&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;space_info.free&lt;/code&gt; имеет значение &lt;code&gt;f_bfree*f_frsize&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8dc60df38163004a901463b4b2e0ee6fa8bba7b4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;srand()&lt;/code&gt; is not guaranteed to be thread-safe.</source>
          <target state="translated">&lt;code&gt;srand()&lt;/code&gt; не гарантированно является потокобезопасным.</target>
        </trans-unit>
        <trans-unit id="8c45e7e857ad07375c7ff6c09de088475818794e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ss&lt;/code&gt; - 2-digit second from &lt;code&gt;timeptr-&amp;gt;tm_sec&lt;/code&gt; as if printed by &lt;code&gt;sprintf&lt;/code&gt; using &lt;code&gt;%.2d&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;ss&lt;/code&gt; - 2-значная секунда из &lt;code&gt;timeptr-&amp;gt;tm_sec&lt;/code&gt; , как если бы она была напечатана &lt;code&gt;sprintf&lt;/code&gt; с использованием &lt;code&gt;%.2d&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4fa4797d7e4e56c30b5cd6e5451aeccf65e0d28b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ss&lt;/code&gt; - seconds</source>
          <target state="translated">&lt;code&gt;ss&lt;/code&gt; - секунды</target>
        </trans-unit>
        <trans-unit id="691d79484e20930f6f97b2512b3af59ec6f01b0b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;st.width() - 1&lt;/code&gt; characters are extracted (if &lt;code&gt;st.width()&lt;/code&gt; is greater than zero)</source>
          <target state="translated">&lt;code&gt;st.width() - 1&lt;/code&gt; извлекается 1 символ (если &lt;code&gt;st.width()&lt;/code&gt; больше нуля)</target>
        </trans-unit>
        <trans-unit id="e6188cc0ce71e5819a7f3d7172eea907c503d273" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;st&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;st&lt;/code&gt;.</target>
        </trans-unit>
        <trans-unit id="6a6533b5d19f97b1c8ec289e396a87c9a7ce3b8e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;state&lt;/code&gt;, a value of type &lt;code&gt;X::state_type&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;state&lt;/code&gt; , значение типа &lt;code&gt;X::state_type&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="137369e42bcf3ba18490493f75c373a147357d4e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;static&lt;/code&gt; -</source>
          <target state="translated">&lt;code&gt;static&lt;/code&gt; -</target>
        </trans-unit>
        <trans-unit id="88b6bbcd3ba3cedf0c70220790b608d1076fb3b6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;static&lt;/code&gt; storage specifier</source>
          <target state="translated">&lt;code&gt;static&lt;/code&gt; спецификатор статического хранилища</target>
        </trans-unit>
        <trans-unit id="900dab33d17ef07271e0d9fbf3a2f564ae5ecbde" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;static&lt;/code&gt;T&lt;code&gt;&amp;amp;&lt;/code&gt;ref&lt;code&gt;= constexpr;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;static&lt;/code&gt; T &lt;code&gt;&amp;amp;&lt;/code&gt; ref &lt;code&gt;= constexpr;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d44865d23521c1a15985e408614ba223370167e4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;static&lt;/code&gt;Tobject&lt;code&gt;;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;static&lt;/code&gt;Tobject&lt;code&gt;;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="22c0c82bde8082dbd01c5219ee5de28b24f391b9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;static&lt;/code&gt;Tobject&lt;code&gt;= constexpr;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;static&lt;/code&gt; Tobject &lt;code&gt;= constexpr;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8a8debab36b3f3b8d43751102d5ff3dbd91d63fc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;static&lt;/code&gt;data_member</source>
          <target state="translated">&lt;code&gt;static&lt;/code&gt;data_member</target>
        </trans-unit>
        <trans-unit id="76b4ce031d77c4b1820cf9a0abbb850a85584a79" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;static&lt;/code&gt;member_function</source>
          <target state="translated">&lt;code&gt;static&lt;/code&gt;member_function</target>
        </trans-unit>
        <trans-unit id="0fe5f8cbf46f1af00de7dfab8a7ed4ac4097a5c4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;static_assert&lt;/code&gt;&lt;code&gt;(&lt;/code&gt;bool_constexpr&lt;code&gt;)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;static_assert&lt;/code&gt;&lt;code&gt;(&lt;/code&gt;bool_constexpr&lt;code&gt;)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="57cfcccf24b9f4cbd3374f6385c918f0ff932eb4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;static_assert&lt;/code&gt;&lt;code&gt;(&lt;/code&gt;bool_constexpr&lt;code&gt;,&lt;/code&gt;message&lt;code&gt;)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;static_assert&lt;/code&gt;&lt;code&gt;(&lt;/code&gt;bool_constexpr&lt;code&gt;,&lt;/code&gt;message&lt;code&gt;)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="87e5ec838bed11e196ddefdb9f84a030cef65a17" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;static_cast &amp;lt;&lt;/code&gt;new_type&lt;code&gt;&amp;gt; (&lt;/code&gt;expression&lt;code&gt;)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;static_cast &amp;lt;&lt;/code&gt; static_cast &amp;lt; new_type &lt;code&gt;&amp;gt; (&lt;/code&gt; выражение &lt;code&gt;)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2a80e989f7fd47ae49da3c00a161119cc065006a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;static_cast&amp;lt;&lt;/code&gt;T&lt;code&gt;&amp;gt;(&lt;/code&gt;other&lt;code&gt;)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;static_cast&amp;lt;&lt;/code&gt;T&lt;code&gt;&amp;gt;(&lt;/code&gt;other&lt;code&gt;)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f748d435919e62b9dbcd85bd69ee07adf73ef2a5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;static_cast&amp;lt;&lt;a href=&quot;../../types/size_t&quot;&gt;std::size_t&lt;/a&gt;&amp;gt;(-1)&lt;/code&gt; if encoding error occurs. Nothing is written to &lt;code&gt;*pwc&lt;/code&gt;, the value &lt;code&gt;&lt;a href=&quot;../../error/errno_macros&quot;&gt;EILSEQ&lt;/a&gt;&lt;/code&gt; is stored in &lt;code&gt;&lt;a href=&quot;../../error/errno&quot;&gt;errno&lt;/a&gt;&lt;/code&gt; and the value of &lt;code&gt;*ps&lt;/code&gt; is left unspecified.</source>
          <target state="translated">&lt;code&gt;static_cast&amp;lt;&lt;a href=&quot;../../types/size_t&quot;&gt;std::size_t&lt;/a&gt;&amp;gt;(-1)&lt;/code&gt; если происходит ошибка кодирования. В &lt;code&gt;*pwc&lt;/code&gt; ничего не записывается , значение &lt;code&gt;&lt;a href=&quot;../../error/errno_macros&quot;&gt;EILSEQ&lt;/a&gt;&lt;/code&gt; сохраняется в &lt;code&gt;&lt;a href=&quot;../../error/errno&quot;&gt;errno&lt;/a&gt;&lt;/code&gt; , а значение &lt;code&gt;*ps&lt;/code&gt; не указывается.</target>
        </trans-unit>
        <trans-unit id="bdf0510fccd0959ccde826256af53acac868200e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;static_cast&amp;lt;&lt;a href=&quot;../../types/size_t&quot;&gt;std::size_t&lt;/a&gt;&amp;gt;(-2)&lt;/code&gt; if the next &lt;code&gt;n&lt;/code&gt; bytes constitute an incomplete, but so far valid, multibyte character. Nothing is written to &lt;code&gt;*pwc&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;static_cast&amp;lt;&lt;a href=&quot;../../types/size_t&quot;&gt;std::size_t&lt;/a&gt;&amp;gt;(-2)&lt;/code&gt; если следующие &lt;code&gt;n&lt;/code&gt; байтов составляют неполный, но пока действительный многобайтовый символ. Ничего не написано &lt;code&gt;*pwc&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3c1bd3ffc2201dd55a94a0eee33a688ba46753ec" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;static_cast&amp;lt;T&amp;amp;&amp;amp;&amp;gt;(t)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;static_cast&amp;lt;T&amp;amp;&amp;amp;&amp;gt;(t)&lt;/code&gt;.</target>
        </trans-unit>
        <trans-unit id="33e6b255bed0b5078515f4b4f2bb5ccdef12194b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;static_cast&amp;lt;To&amp;gt;(fun())&lt;/code&gt; is equal to &lt;code&gt;[]() -&amp;gt; To { return fun(); }()&lt;/code&gt;, and</source>
          <target state="translated">&lt;code&gt;static_cast&amp;lt;To&amp;gt;(fun())&lt;/code&gt; равно &lt;code&gt;[]() -&amp;gt; To { return fun(); }()&lt;/code&gt; и</target>
        </trans-unit>
        <trans-unit id="b1d0930f989e7a9b27263d94d9d956f9a433ac9c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;static_cast&amp;lt;typename &lt;a href=&quot;../types/remove_reference&quot;&gt;std::remove_reference&lt;/a&gt;&amp;lt;T&amp;gt;::type&amp;amp;&amp;amp;&amp;gt;(t)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;static_cast&amp;lt;typename &lt;a href=&quot;../types/remove_reference&quot;&gt;std::remove_reference&lt;/a&gt;&amp;lt;T&amp;gt;::type&amp;amp;&amp;amp;&amp;gt;(t)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4a4a2866542a98e87edaceca4b712cfae49435a3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;static_cast&lt;/code&gt; conversion</source>
          <target state="translated">&lt;code&gt;static_cast&lt;/code&gt; преобразования</target>
        </trans-unit>
        <trans-unit id="d8feda07a6b401eca5278d4cf8ec524b614fd12c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;static_cast&lt;/code&gt; may also be used to disambiguate function overloads by performing a function-to-pointer conversion to specific type, as in.</source>
          <target state="translated">&lt;code&gt;static_cast&lt;/code&gt; также может быть использован для устранения неоднозначности перегрузок функций путем выполнения преобразования функции в указатель в конкретный тип, как в.</target>
        </trans-unit>
        <trans-unit id="baa3bbadf4fb980e424c228048633bb156a9aad1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::&lt;a href=&quot;same&quot;&gt;Same&lt;/a&gt;&amp;lt;T, U&amp;gt;&lt;/code&gt; subsumes &lt;code&gt;std::&lt;a href=&quot;same&quot;&gt;Same&lt;/a&gt;&amp;lt;U, T&amp;gt;&lt;/code&gt; and vice versa.</source>
          <target state="translated">&lt;code&gt;std::&lt;a href=&quot;same&quot;&gt;Same&lt;/a&gt;&amp;lt;T, U&amp;gt;&lt;/code&gt; включает в себя &lt;code&gt;std::&lt;a href=&quot;same&quot;&gt;Same&lt;/a&gt;&amp;lt;U, T&amp;gt;&lt;/code&gt; и наоборот.</target>
        </trans-unit>
        <trans-unit id="ede0befc08584ae7a5fdf3a513d0dcccabc5c6b8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::abs&lt;/code&gt; was erroneously required to have overloads for integer types returning &lt;code&gt;double&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;std::abs&lt;/code&gt; ошибке был вынужден иметь перегрузки для целочисленных типов, возвращающих &lt;code&gt;double&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6c54c3bc37b2a8917b0fc03bd885ff743f102d0e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::accumulate&lt;/code&gt; performs a left fold. In order to perform a right fold, one must reverse the order of the arguments to the binary operator, and use reverse iterators.</source>
          <target state="translated">&lt;code&gt;std::accumulate&lt;/code&gt; выполняет левый сгиб. Чтобы выполнить правильное свертывание, необходимо изменить порядок аргументов в бинарном операторе и использовать обратные итераторы.</target>
        </trans-unit>
        <trans-unit id="bcc2ebd66f6f03846c63c93062450ad4cf220759" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::add_pointer&lt;/code&gt; was required to produce</source>
          <target state="translated">&lt;code&gt;std::add_pointer&lt;/code&gt; был необходим для производства</target>
        </trans-unit>
        <trans-unit id="b1234e7bdd717c6d017d2bb87c22008eb08e0a0e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::allocator_arg&lt;/code&gt; is a constant of type &lt;code&gt;&lt;a href=&quot;allocator_arg_t&quot;&gt;std::allocator_arg_t&lt;/a&gt;&lt;/code&gt; used to disambiguate, at call site, the overloads of the constructors and member functions of allocator-aware objects, such as &lt;code&gt;&lt;a href=&quot;../utility/tuple&quot;&gt;std::tuple&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../utility/functional/function&quot;&gt;std::function&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../thread/packaged_task&quot;&gt;std::packaged_task&lt;/a&gt;&lt;/code&gt;, (until C++17)and &lt;code&gt;&lt;a href=&quot;../thread/promise&quot;&gt;std::promise&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;std::allocator_arg&lt;/code&gt; - это константа типа &lt;code&gt;&lt;a href=&quot;allocator_arg_t&quot;&gt;std::allocator_arg_t&lt;/a&gt;&lt;/code&gt; используемая для устранения неоднозначности на месте вызова перегрузок конструкторов и функций-членов объектов, связанных с распределением, таких как &lt;code&gt;&lt;a href=&quot;../utility/tuple&quot;&gt;std::tuple&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../utility/functional/function&quot;&gt;std::function&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../thread/packaged_task&quot;&gt;std::packaged_task&lt;/a&gt;&lt;/code&gt; , (до C ++ 17) и &lt;code&gt;&lt;a href=&quot;../thread/promise&quot;&gt;std::promise&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3b0e63dff632dcb321d0e56a33d6d39b1b98452a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::allocator_arg_t&lt;/code&gt; is an empty class type used to disambiguate the overloads of constructors and member functions of allocator-aware objects, including &lt;code&gt;&lt;a href=&quot;../utility/tuple&quot;&gt;std::tuple&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../utility/functional/function&quot;&gt;std::function&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../thread/packaged_task&quot;&gt;std::packaged_task&lt;/a&gt;&lt;/code&gt;, (until C++17)and &lt;code&gt;&lt;a href=&quot;../thread/promise&quot;&gt;std::promise&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;std::allocator_arg_t&lt;/code&gt; - это пустой тип класса, используемый для устранения неоднозначности перегрузок конструкторов и функций-членов объектов, связанных с распределением, включая &lt;code&gt;&lt;a href=&quot;../utility/tuple&quot;&gt;std::tuple&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../utility/functional/function&quot;&gt;std::function&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../thread/packaged_task&quot;&gt;std::packaged_task&lt;/a&gt;&lt;/code&gt; , (до C ++ 17) и &lt;code&gt;&lt;a href=&quot;../thread/promise&quot;&gt;std::promise&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0397b262f2892865e4509d76daa0c90a2aad6b66" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::array&lt;/code&gt; is a container that encapsulates fixed size arrays.</source>
          <target state="translated">&lt;code&gt;std::array&lt;/code&gt; - это контейнер, который инкапсулирует массивы фиксированного размера.</target>
        </trans-unit>
        <trans-unit id="47bb28b8cd6bf39d74e4ee0354a8fde98b200ce8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::array&lt;/code&gt; satisfies the requirements of &lt;a href=&quot;../named_req/container&quot;&gt;Container&lt;/a&gt; and &lt;a href=&quot;../named_req/reversiblecontainer&quot;&gt;ReversibleContainer&lt;/a&gt; except that default-constructed array is not empty and that the complexity of swapping is linear, satisfies the requirements of &lt;a href=&quot;../named_req/contiguouscontainer&quot;&gt;ContiguousContainer&lt;/a&gt;,(since C++17) and partially satisfies the requirements of &lt;a href=&quot;../named_req/sequencecontainer&quot;&gt;SequenceContainer&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;std::array&lt;/code&gt; удовлетворяет требованиям &lt;a href=&quot;../named_req/container&quot;&gt;Container&lt;/a&gt; и &lt;a href=&quot;../named_req/reversiblecontainer&quot;&gt;ReversibleContainer,&lt;/a&gt; за исключением того, что построенный по умолчанию массив не является пустым и что сложность замены является линейной, удовлетворяет требованиям &lt;a href=&quot;../named_req/contiguouscontainer&quot;&gt;ContiguousContainer&lt;/a&gt; (начиная с C ++ 17) и частично удовлетворяет требованиям&lt;a href=&quot;../named_req/sequencecontainer&quot;&gt; SequenceContainer&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="76f124fee1f6d404bb5d3c59df3332f4ba0e6997" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::atan2(y, x)&lt;/code&gt; is equivalent to &lt;code&gt;&lt;a href=&quot;../complex/arg&quot;&gt;std::arg&lt;/a&gt;(&lt;a href=&quot;../complex&quot;&gt;std::complex&lt;/a&gt;&amp;lt;double&amp;gt;(x,y))&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;std::atan2(y, x)&lt;/code&gt; эквивалентен &lt;code&gt;&lt;a href=&quot;../complex/arg&quot;&gt;std::arg&lt;/a&gt;(&lt;a href=&quot;../complex&quot;&gt;std::complex&lt;/a&gt;&amp;lt;double&amp;gt;(x,y))&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cbef2b205fea689e577abcebc9dc5b7b84b115b1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::atomic&amp;lt;T&amp;gt;&lt;/code&gt; was permitted for</source>
          <target state="translated">&lt;code&gt;std::atomic&amp;lt;T&amp;gt;&lt;/code&gt; был разрешен для</target>
        </trans-unit>
        <trans-unit id="bb4b933229da7eb89ef0e1d0dba9aa3137507bc9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::atomic&amp;lt;bool&amp;gt;&lt;/code&gt; uses the primary template. It is guaranteed to be a standard layout struct.</source>
          <target state="translated">&lt;code&gt;std::atomic&amp;lt;bool&amp;gt;&lt;/code&gt; использует основной шаблон. Это гарантированно будет стандартной структурой размещения.</target>
        </trans-unit>
        <trans-unit id="4c0b05c455392c723841488c17ad3333763a7b15" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::atomic&amp;lt;char8_t&amp;gt;&lt;/code&gt;(C++20)</source>
          <target state="translated">&lt;code&gt;std::atomic&amp;lt;char8_t&amp;gt;&lt;/code&gt;(C++20)</target>
        </trans-unit>
        <trans-unit id="4a0803b61a969f4a0731b2365b00b3c8c077e75b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::atomic_flag&lt;/code&gt; is an atomic boolean type. Unlike all specializations of &lt;code&gt;&lt;a href=&quot;atomic&quot;&gt;std::atomic&lt;/a&gt;&lt;/code&gt;, it is guaranteed to be lock-free. Unlike &lt;code&gt;&lt;a href=&quot;atomic&quot;&gt;std::atomic&lt;/a&gt;&amp;lt;bool&amp;gt;&lt;/code&gt;, &lt;code&gt;std::atomic_flag&lt;/code&gt; does not provide load or store operations.</source>
          <target state="translated">&lt;code&gt;std::atomic_flag&lt;/code&gt; - это атомный логический тип. В отличие от всех специализаций &lt;code&gt;&lt;a href=&quot;atomic&quot;&gt;std::atomic&lt;/a&gt;&lt;/code&gt; , он гарантированно не блокируется. В отличие от &lt;code&gt;&lt;a href=&quot;atomic&quot;&gt;std::atomic&lt;/a&gt;&amp;lt;bool&amp;gt;&lt;/code&gt; , &lt;code&gt;std::atomic_flag&lt;/code&gt; не обеспечивает операции загрузки или сохранения.</target>
        </trans-unit>
        <trans-unit id="38cbf066238967320059f92fe8d8095dc30f0a6c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::atomic_ref&lt;/code&gt; is &lt;a href=&quot;../named_req/copyconstructible&quot;&gt;CopyConstructible&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;std::atomic_ref&lt;/code&gt; является &lt;a href=&quot;../named_req/copyconstructible&quot;&gt;CopyConstructible&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8c0bec0c1a6726f4ba3ff1919aef2655cc5d1549" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::back_insert_iterator&lt;/code&gt; is an &lt;a href=&quot;../named_req/outputiterator&quot;&gt;LegacyOutputIterator&lt;/a&gt; that appends to a container for which it was constructed. The container's &lt;code&gt;push_back()&lt;/code&gt; member function is called whenever the iterator (whether dereferenced or not) is assigned to. Incrementing the &lt;code&gt;std::back_insert_iterator&lt;/code&gt; is a no-op.</source>
          <target state="translated">&lt;code&gt;std::back_insert_iterator&lt;/code&gt; является &lt;a href=&quot;../named_req/outputiterator&quot;&gt;LegacyOutputIterator,&lt;/a&gt; который добавляет к контейнеру, для которого он был создан. Функция- член контейнера &lt;code&gt;push_back()&lt;/code&gt; вызывается всякий раз, когда назначается итератор (с разыменованным или нет). Приращение в &lt;code&gt;std::back_insert_iterator&lt;/code&gt; является не оп.</target>
        </trans-unit>
        <trans-unit id="1ccbe9f22a72664a5718095af50ed8534ef901f5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::bad_alloc&lt;/code&gt; is the type of the object thrown as exceptions by the &lt;a href=&quot;operator_new&quot;&gt;allocation functions&lt;/a&gt; to report failure to allocate storage.</source>
          <target state="translated">&lt;code&gt;std::bad_alloc&lt;/code&gt; - это тип объекта, выдаваемого в качестве исключений &lt;a href=&quot;operator_new&quot;&gt;функциями выделения&lt;/a&gt; для сообщения о сбое выделения памяти.</target>
        </trans-unit>
        <trans-unit id="f894909b251043c10519cdc9419593fbd42c3929" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::bad_array_new_length&lt;/code&gt; is the type of the object thrown as exceptions by the &lt;a href=&quot;../../language/new&quot;&gt;new-expressions&lt;/a&gt; to report invalid array lengths if.</source>
          <target state="translated">&lt;code&gt;std::bad_array_new_length&lt;/code&gt; - это тип объекта, выдаваемого в качестве исключений &lt;a href=&quot;../../language/new&quot;&gt;новыми выражениями&lt;/a&gt; для сообщения о недопустимой длине массива if.</target>
        </trans-unit>
        <trans-unit id="3cece263d9e71f9d724d7edcfb758b9850990db8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::bad_exception&lt;/code&gt; is the type of the exception thrown by the C++ runtime in the following situations:</source>
          <target state="translated">&lt;code&gt;std::bad_exception&lt;/code&gt; - это тип исключения, выдаваемого средой выполнения C ++ в следующих ситуациях:</target>
        </trans-unit>
        <trans-unit id="326879d3dd40f1fab9d393072c4d721a39f2e130" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::bad_function_call&lt;/code&gt; is the type of the exception thrown by &lt;a href=&quot;function/operator()&quot;&gt; &lt;code&gt;std::function::operator()&lt;/code&gt; &lt;/a&gt; if the function wrapper has no target.</source>
          <target state="translated">&lt;code&gt;std::bad_function_call&lt;/code&gt; - это тип исключения, выдаваемого &lt;a href=&quot;function/operator()&quot;&gt; &lt;code&gt;std::function::operator()&lt;/code&gt; &lt;/a&gt; если обертка функции не имеет цели.</target>
        </trans-unit>
        <trans-unit id="f6aa2069b29e331b758f7a814d4a7763e6d6f81f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::bad_variant_access&lt;/code&gt; is the type of the exception thrown in the following situations:</source>
          <target state="translated">&lt;code&gt;std::bad_variant_access&lt;/code&gt; - это тип исключения, выдаваемого в следующих ситуациях:</target>
        </trans-unit>
        <trans-unit id="36ec4a07aa10ab404e6cd9a170ecee64252fa5a5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::bad_weak_ptr&lt;/code&gt; is the type of the object thrown as exceptions by the constructors of &lt;code&gt;&lt;a href=&quot;shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&lt;/code&gt; that take &lt;code&gt;&lt;a href=&quot;weak_ptr&quot;&gt;std::weak_ptr&lt;/a&gt;&lt;/code&gt; as the argument, when the &lt;code&gt;&lt;a href=&quot;weak_ptr&quot;&gt;std::weak_ptr&lt;/a&gt;&lt;/code&gt; refers to an already deleted object.</source>
          <target state="translated">&lt;code&gt;std::bad_weak_ptr&lt;/code&gt; - это тип объекта, выдаваемого в качестве исключений конструкторами &lt;code&gt;&lt;a href=&quot;shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&lt;/code&gt; которые принимают &lt;code&gt;&lt;a href=&quot;weak_ptr&quot;&gt;std::weak_ptr&lt;/a&gt;&lt;/code&gt; в качестве аргумента, когда &lt;code&gt;&lt;a href=&quot;weak_ptr&quot;&gt;std::weak_ptr&lt;/a&gt;&lt;/code&gt; ссылается на уже удаленный объект.</target>
        </trans-unit>
        <trans-unit id="c6230cfe80f845737eb67452ccf7bbac692f90ce" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::basic_filebuf&lt;/code&gt; is a &lt;code&gt;&lt;a href=&quot;basic_streambuf&quot;&gt;std::basic_streambuf&lt;/a&gt;&lt;/code&gt; whose associated character sequence is a file. Both the input sequence and the output sequence are associated with the same file, and a joint file position is maintained for both operations.</source>
          <target state="translated">&lt;code&gt;std::basic_filebuf&lt;/code&gt; - это &lt;code&gt;&lt;a href=&quot;basic_streambuf&quot;&gt;std::basic_streambuf&lt;/a&gt;&lt;/code&gt; чья последовательность символов связана с файлом. И входная последовательность, и выходная последовательность связаны с одним и тем же файлом, и для обеих операций сохраняется позиция объединенного файла.</target>
        </trans-unit>
        <trans-unit id="4fe3a0b10ce1dabce9f14a49bd17e9baca64483c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::basic_osyncstream&lt;/code&gt;, &lt;code&gt;std::basic_syncbuf&lt;/code&gt;, and typedefs</source>
          <target state="translated">&lt;code&gt;std::basic_osyncstream&lt;/code&gt; , &lt;code&gt;std::basic_syncbuf&lt;/code&gt; и typedefs</target>
        </trans-unit>
        <trans-unit id="3462726fed80b85e9359be5d293b2169b295577d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::basic_string&lt;/code&gt; and &lt;code&gt;std::sub_match&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;std::basic_string&lt;/code&gt; и &lt;code&gt;std::sub_match&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="34319833fb2ad6fb976269b586a465fcfaea3aaf" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::basic_string&lt;/code&gt; satisfies the requirements of &lt;a href=&quot;../named_req/allocatorawarecontainer&quot;&gt;AllocatorAwareContainer&lt;/a&gt;, &lt;a href=&quot;../named_req/sequencecontainer&quot;&gt;SequenceContainer&lt;/a&gt;and &lt;a href=&quot;../named_req/contiguouscontainer&quot;&gt;ContiguousContainer&lt;/a&gt;(since C++17).</source>
          <target state="translated">&lt;code&gt;std::basic_string&lt;/code&gt; удовлетворяет требованиям &lt;a href=&quot;../named_req/allocatorawarecontainer&quot;&gt;AllocatorAwareContainer&lt;/a&gt; , &lt;a href=&quot;../named_req/sequencecontainer&quot;&gt;SequenceContainer&lt;/a&gt; и &lt;a href=&quot;../named_req/contiguouscontainer&quot;&gt;ContiguousContainer&lt;/a&gt; (начиная с C ++ 17).</target>
        </trans-unit>
        <trans-unit id="25042ac23a934cf1670e58afd01a08f042989654" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::basic_string_view&amp;lt;char8_t&amp;gt;&lt;/code&gt;(C++20)</source>
          <target state="translated">&lt;code&gt;std::basic_string_view&amp;lt;char8_t&amp;gt;&lt;/code&gt;(C++20)</target>
        </trans-unit>
        <trans-unit id="5c74e2a9de4dbc23d6fdac9505857cb54752ed5d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::basic_stringbuf&lt;/code&gt; is a &lt;code&gt;&lt;a href=&quot;basic_streambuf&quot;&gt;std::basic_streambuf&lt;/a&gt;&lt;/code&gt; whose associated character sequence is a memory-resident sequence of arbitrary characters, which can be initialized from or made available as an instance of &lt;code&gt;&lt;a href=&quot;../string/basic_string&quot;&gt;std::basic_string&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;std::basic_stringbuf&lt;/code&gt; - это &lt;code&gt;&lt;a href=&quot;basic_streambuf&quot;&gt;std::basic_streambuf&lt;/a&gt;&lt;/code&gt; чья связанная символьная последовательность является резидентной последовательностью произвольных символов, которая может быть инициализирована или доступна как экземпляр &lt;code&gt;&lt;a href=&quot;../string/basic_string&quot;&gt;std::basic_string&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e2f68bb275827e707542a32b2132fc70d0be8bf8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::basic_syncbuf&lt;/code&gt; is a wrapper for a &lt;code&gt;&lt;a href=&quot;basic_streambuf&quot;&gt;std::basic_streambuf&lt;/a&gt;&lt;/code&gt; (provided at construction time as a pointer). It accumulates output in its own internal buffer, and atomically transmits its entire contents to the wrapped buffer on destruction and when explicitly requested, so that they appear as a contiguous sequence of characters. It guarantees that there are no data races and no interleaving of characters sent to the wrapped buffer as long as all other outputs made to the same buffer are made through, possibly different, instances of &lt;code&gt;std::basic_syncbuf&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;std::basic_syncbuf&lt;/code&gt; - это оболочка для &lt;code&gt;&lt;a href=&quot;basic_streambuf&quot;&gt;std::basic_streambuf&lt;/a&gt;&lt;/code&gt; (предоставляется во время создания в качестве указателя). Он накапливает выходные данные в своем собственном внутреннем буфере и атомарно передает все содержимое в упакованный буфер при уничтожении и при явном запросе, чтобы они отображались в виде непрерывной последовательности символов. Это гарантирует, что не будет никаких гонок данных и чередования символов, отправляемых в упакованный буфер, если все другие выходные данные, сделанные в тот же буфер, делаются через, возможно, другие, экземпляры &lt;code&gt;std::basic_syncbuf&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fd83eadd1fc2d1f8db155ac3d34318bc1cf56684" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::basic_syncbuf&lt;/code&gt; objects whose states to swap</source>
          <target state="translated">&lt;code&gt;std::basic_syncbuf&lt;/code&gt; объекты, чьи состояния нужно поменять местами</target>
        </trans-unit>
        <trans-unit id="97f580905e381c907d981e60e66970e721b2cc85" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::bernoulli_distribution&lt;/code&gt; satisfies &lt;a href=&quot;../../named_req/randomnumberdistribution&quot;&gt;RandomNumberDistribution&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;std::bernoulli_distribution&lt;/code&gt; удовлетворяет &lt;a href=&quot;../../named_req/randomnumberdistribution&quot;&gt;RandomNumberDistribution&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="43c36891564fc4f7245b7b75bc84f9cba02ebeba" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::bind_front&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functional/bind&quot;&gt;std::bind&lt;/a&gt;&lt;/code&gt; provide support for &lt;a href=&quot;https://en.wikipedia.org/wiki/Partial_application&quot;&gt;partial function application&lt;/a&gt;, i.e. binding arguments to functions to produce new functions.</source>
          <target state="translated">&lt;code&gt;std::bind_front&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;functional/bind&quot;&gt;std::bind&lt;/a&gt;&lt;/code&gt; обеспечивают поддержку &lt;a href=&quot;https://en.wikipedia.org/wiki/Partial_application&quot;&gt;частичного применения функции&lt;/a&gt; , то есть привязки аргументов к функциям для создания новых функций.</target>
        </trans-unit>
        <trans-unit id="23785313d052adc0763e422629822ed2e8e29065" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::binomial_distribution&lt;/code&gt; satisfies &lt;a href=&quot;../../named_req/randomnumberdistribution&quot;&gt;RandomNumberDistribution&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;std::binomial_distribution&lt;/code&gt; удовлетворяет &lt;a href=&quot;../../named_req/randomnumberdistribution&quot;&gt;RandomNumberDistribution&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a9224a909447446235fdc4fa450b3009f5990c5e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::bit_xor&amp;lt;&amp;gt;&lt;/code&gt; is a specialization of &lt;code&gt;std::bit_xor&lt;/code&gt; with parameter and return type deduced.</source>
          <target state="translated">&lt;code&gt;std::bit_xor&amp;lt;&amp;gt;&lt;/code&gt; - это специализация &lt;code&gt;std::bit_xor&lt;/code&gt; с определенным параметром и возвращаемым типом.</target>
        </trans-unit>
        <trans-unit id="32ab0725b4937789956cd3134e83f4fc6bca42ab" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::boolalpha&lt;/code&gt; is an I/O manipulator, so it may be called with an expression such as &lt;code&gt;out &amp;lt;&amp;lt; std::boolalpha&lt;/code&gt; for any &lt;code&gt;out&lt;/code&gt; of type &lt;code&gt;&lt;a href=&quot;../basic_ostream&quot;&gt;std::basic_ostream&lt;/a&gt;&lt;/code&gt; or with an expression such as &lt;code&gt;in &amp;gt;&amp;gt; std::boolalpha&lt;/code&gt; for any &lt;code&gt;in&lt;/code&gt; of type &lt;code&gt;&lt;a href=&quot;../basic_istream&quot;&gt;std::basic_istream&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;std::boolalpha&lt;/code&gt; является I / O манипулятором, поэтому его можно назвать с выражением такого как &lt;code&gt;out &amp;lt;&amp;lt; std::boolalpha&lt;/code&gt; для любого &lt;code&gt;out&lt;/code&gt; типа &lt;code&gt;&lt;a href=&quot;../basic_ostream&quot;&gt;std::basic_ostream&lt;/a&gt;&lt;/code&gt; или с выражением такой как &lt;code&gt;in &amp;gt;&amp;gt; std::boolalpha&lt;/code&gt; для любого &lt;code&gt;in&lt;/code&gt; типа &lt;code&gt;&lt;a href=&quot;../basic_istream&quot;&gt;std::basic_istream&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="97d1b1f997f3c874053645c2d47ec851fbbaffec" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::byte&lt;/code&gt; is a distinct type that implements the concept of byte as specified in the C++ language definition.</source>
          <target state="translated">&lt;code&gt;std::byte&lt;/code&gt; - это отдельный тип, который реализует концепцию байта, указанную в определении языка C ++.</target>
        </trans-unit>
        <trans-unit id="e846956a578897f5a7e8147360b6876f9d4a4e1e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::calloc&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;malloc&quot;&gt;std::malloc&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;realloc&quot;&gt;std::realloc&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;aligned_alloc&quot;&gt;std::aligned_alloc&lt;/a&gt;&lt;/code&gt;(since C++17), &lt;code&gt;&lt;a href=&quot;free&quot;&gt;std::free&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;std::calloc&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;malloc&quot;&gt;std::malloc&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;realloc&quot;&gt;std::realloc&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;aligned_alloc&quot;&gt;std::aligned_alloc&lt;/a&gt;&lt;/code&gt; (начиная с C ++ 17), &lt;code&gt;&lt;a href=&quot;free&quot;&gt;std::free&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6c2b3f8186c4392f51363031a506c5b7fef66d2a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::cauchy_distribution&lt;/code&gt; satisfies all requirements of &lt;a href=&quot;../../named_req/randomnumberdistribution&quot;&gt;RandomNumberDistribution&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;std::cauchy_distribution&lt;/code&gt; удовлетворяет всем требованиям &lt;a href=&quot;../../named_req/randomnumberdistribution&quot;&gt;RandomNumberDistribution&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="22639445336d9d5d493d71fecd2210de50ce3b9e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::cbrt(arg)&lt;/code&gt; is not equivalent to &lt;code&gt;&lt;a href=&quot;pow&quot;&gt;std::pow&lt;/a&gt;(arg, 1.0/3)&lt;/code&gt; because &lt;code&gt;&lt;a href=&quot;pow&quot;&gt;std::pow&lt;/a&gt;&lt;/code&gt; cannot raise a negative base to a fractional exponent.</source>
          <target state="translated">&lt;code&gt;std::cbrt(arg)&lt;/code&gt; не эквивалентен &lt;code&gt;&lt;a href=&quot;pow&quot;&gt;std::pow&lt;/a&gt;(arg, 1.0/3)&lt;/code&gt; потому что &lt;code&gt;&lt;a href=&quot;pow&quot;&gt;std::pow&lt;/a&gt;&lt;/code&gt; не может поднять отрицательное основание до дробного показателя.</target>
        </trans-unit>
        <trans-unit id="d3ec330bf10bf64cd6976f9f6cdbde763a641535" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::chi_squared_distribution&lt;/code&gt; satisfies all requirements of &lt;a href=&quot;../../named_req/randomnumberdistribution&quot;&gt;RandomNumberDistribution&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;std::chi_squared_distribution&lt;/code&gt; удовлетворяет всем требованиям &lt;a href=&quot;../../named_req/randomnumberdistribution&quot;&gt;RandomNumberDistribution&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f3e8cbc766caa8d1c32abffb171a8a2c76a622ef" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::chrono::clock_time_conversion&lt;/code&gt; is a trait that specifies how to convert a &lt;code&gt;&lt;a href=&quot;time_point&quot;&gt;std::chrono::time_point&lt;/a&gt;&lt;/code&gt; of the &lt;code&gt;Source&lt;/code&gt; clock to that of the &lt;code&gt;Dest&lt;/code&gt; clock. It does so by providing an const-callable &lt;code&gt;operator()&lt;/code&gt; that accepts an argument of type &lt;code&gt;&lt;a href=&quot;time_point&quot;&gt;std::chrono::time_point&lt;/a&gt;&amp;lt;Source, Duration&amp;gt;&lt;/code&gt; and returns a &lt;code&gt;&lt;a href=&quot;time_point&quot;&gt;std::chrono::time_point&lt;/a&gt;&amp;lt;Dest, OtherDuration&amp;gt;&lt;/code&gt; that represents an equivalent point in time. The duration of the returned time point is computed from the source duration in a manner that varies for each specialization. &lt;code&gt;clock_time_conversion&lt;/code&gt; is normally only used indirectly, via &lt;code&gt;std::chrono::clock_cast&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;std::chrono::clock_time_conversion&lt;/code&gt; есть черта , которая определяет , как преобразовать &lt;code&gt;&lt;a href=&quot;time_point&quot;&gt;std::chrono::time_point&lt;/a&gt;&lt;/code&gt; от &lt;code&gt;Source&lt;/code&gt; часы к количеству &lt;code&gt;Dest&lt;/code&gt; часов. Это достигается путем предоставления const-вызываемого &lt;code&gt;operator()&lt;/code&gt; который принимает аргумент типа &lt;code&gt;&lt;a href=&quot;time_point&quot;&gt;std::chrono::time_point&lt;/a&gt;&amp;lt;Source, Duration&amp;gt;&lt;/code&gt; и возвращает &lt;code&gt;&lt;a href=&quot;time_point&quot;&gt;std::chrono::time_point&lt;/a&gt;&amp;lt;Dest, OtherDuration&amp;gt;&lt;/code&gt; который представляет эквивалентную точку во время. Длительность возвращенного момента времени вычисляется из продолжительности источника способом, который варьируется для каждой специализации. &lt;code&gt;clock_time_conversion&lt;/code&gt; обычно используется только косвенно, через &lt;code&gt;std::chrono::clock_cast&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f045d2731dae7d9a2469f88b10eff5dd32f72004" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::chrono::days&lt;/code&gt;(since C++20)</source>
          <target state="translated">&lt;code&gt;std::chrono::days&lt;/code&gt; (начиная с C ++ 20)</target>
        </trans-unit>
        <trans-unit id="2ea4b95a0683371b2f9ca49e28e41457c8ef2523" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::chrono::file_clock&lt;/code&gt; is an alias for the clock used for &lt;code&gt;&lt;a href=&quot;../filesystem/file_time_type&quot;&gt;std::filesystem::file_time_type&lt;/a&gt;&lt;/code&gt;. Its epoch is unspecified.</source>
          <target state="translated">&lt;code&gt;std::chrono::file_clock&lt;/code&gt; - псевдоним часов, используемых для &lt;code&gt;&lt;a href=&quot;../filesystem/file_time_type&quot;&gt;std::filesystem::file_time_type&lt;/a&gt;&lt;/code&gt; . Его эпоха не уточняется.</target>
        </trans-unit>
        <trans-unit id="e125350fc562e970446db9758feb9b73754284bb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::chrono::high_resolution_clock&lt;/code&gt; meets the requirements of &lt;a href=&quot;../named_req/trivialclock&quot;&gt;TrivialClock&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;std::chrono::high_resolution_clock&lt;/code&gt; соответствует требованиям &lt;a href=&quot;../named_req/trivialclock&quot;&gt;TrivialClock&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="df728f8be5b4f6a57be6ab7ff93578a6707a0ae0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::chrono::last&lt;/code&gt;, for the last day of the month;</source>
          <target state="translated">&lt;code&gt;std::chrono::last&lt;/code&gt; , за последний день месяца;</target>
        </trans-unit>
        <trans-unit id="0127b3d83922034df1531223fe21706512bf36a8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::chrono::months&lt;/code&gt;(since C++20)</source>
          <target state="translated">&lt;code&gt;std::chrono::months&lt;/code&gt; (начиная с C ++ 20)</target>
        </trans-unit>
        <trans-unit id="5d887bf37e598dda8d113c25633ab88f4cb13600" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::chrono::steady_clock&lt;/code&gt; meets the requirements of &lt;a href=&quot;../named_req/trivialclock&quot;&gt;TrivialClock&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;std::chrono::steady_clock&lt;/code&gt; соответствует требованиям &lt;a href=&quot;../named_req/trivialclock&quot;&gt;TrivialClock&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="52324f00eaa15e4cdc6c43217ed2771a102427a4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::chrono::system_clock&lt;/code&gt; meets the requirements of &lt;a href=&quot;../named_req/trivialclock&quot;&gt;TrivialClock&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;std::chrono::system_clock&lt;/code&gt; соответствует требованиям &lt;a href=&quot;../named_req/trivialclock&quot;&gt;TrivialClock&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7fc04ed7e313d32198d59c13b4792d1b0b173e71" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::chrono::weeks&lt;/code&gt;(since C++20)</source>
          <target state="translated">&lt;code&gt;std::chrono::weeks&lt;/code&gt; (начиная с C ++ 20)</target>
        </trans-unit>
        <trans-unit id="9ac4f34b32160656cbecc98a1ee4572f732b67f6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::chrono::years&lt;/code&gt;(since C++20)</source>
          <target state="translated">&lt;code&gt;std::chrono::years&lt;/code&gt; (начиная с C ++ 20)</target>
        </trans-unit>
        <trans-unit id="bfa5e06d771be8d4f6dc7663237bbe9daf5d82bd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::chrono::years&lt;/code&gt;- and &lt;code&gt;std::chrono::months&lt;/code&gt;-oriented arithmetic are supported directly. An implicit conversion to &lt;code&gt;std::chrono::sys_days&lt;/code&gt; allows &lt;code&gt;std::chrono::days&lt;/code&gt;-oriented arithmetic to be performed efficiently.</source>
          <target state="translated">&lt;code&gt;std::chrono::years&lt;/code&gt; - и &lt;code&gt;std::chrono::months&lt;/code&gt; ориентированная арифметика поддерживается напрямую. Неявное преобразование в &lt;code&gt;std::chrono::sys_days&lt;/code&gt; позволяет эффективно выполнять арифметику, ориентированную на std :: chrono &lt;code&gt;std::chrono::days&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a5484ab6c0379a27fdb71488f7d15e044a76eb4a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::chrono&lt;/code&gt; library</source>
          <target state="translated">&lt;code&gt;std::chrono&lt;/code&gt; библиотека std :: chrono</target>
        </trans-unit>
        <trans-unit id="4d296ea5863ff7b777d56292c8433e0452f6c6fa" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::codecvt_byname&lt;/code&gt; is a &lt;code&gt;&lt;a href=&quot;codecvt&quot;&gt;std::codecvt&lt;/a&gt;&lt;/code&gt; facet which encapsulates multibyte/wide character conversion rules of a locale specified at its construction.</source>
          <target state="translated">&lt;code&gt;std::codecvt_byname&lt;/code&gt; - это фасет &lt;code&gt;&lt;a href=&quot;codecvt&quot;&gt;std::codecvt&lt;/a&gt;&lt;/code&gt; который инкапсулирует правила преобразования многобайтовых / широких символов в локаль, указанную при его построении.</target>
        </trans-unit>
        <trans-unit id="b7dd739f104fae21a79d350564d83476981e9e5f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::codecvt_utf16&lt;/code&gt; is a &lt;code&gt;&lt;a href=&quot;codecvt&quot;&gt;std::codecvt&lt;/a&gt;&lt;/code&gt; facet which encapsulates conversion between a UTF-16 encoded byte string and UCS2 or UTF-32 character string (depending on the type of &lt;code&gt;Elem&lt;/code&gt;). This codecvt facet can be used to read and write UTF-16 files in binary mode.</source>
          <target state="translated">&lt;code&gt;std::codecvt_utf16&lt;/code&gt; - это фасет &lt;code&gt;&lt;a href=&quot;codecvt&quot;&gt;std::codecvt&lt;/a&gt;&lt;/code&gt; который инкапсулирует преобразование между строкой байтов в кодировке UTF-16 и строкой символов UCS2 или UTF-32 (в зависимости от типа &lt;code&gt;Elem&lt;/code&gt; ). Этот фасет codecvt можно использовать для чтения и записи файлов UTF-16 в двоичном режиме.</target>
        </trans-unit>
        <trans-unit id="29c174bd3330ba8bf72caa31f7b6b42fa1d9156b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::codecvt_utf8&lt;/code&gt; is a &lt;code&gt;&lt;a href=&quot;codecvt&quot;&gt;std::codecvt&lt;/a&gt;&lt;/code&gt; facet which encapsulates conversion between a UTF-8 encoded byte string and UCS2 or UTF-32 character string (depending on the type of &lt;code&gt;Elem&lt;/code&gt;). This codecvt facet can be used to read and write UTF-8 files, both text and binary.</source>
          <target state="translated">&lt;code&gt;std::codecvt_utf8&lt;/code&gt; - это фасет &lt;code&gt;&lt;a href=&quot;codecvt&quot;&gt;std::codecvt&lt;/a&gt;&lt;/code&gt; который инкапсулирует преобразование между строкой байтов в кодировке UTF-8 и строкой символов UCS2 или UTF-32 (в зависимости от типа &lt;code&gt;Elem&lt;/code&gt; ). Этот фасет codecvt может использоваться для чтения и записи файлов UTF-8, как текстовых, так и двоичных.</target>
        </trans-unit>
        <trans-unit id="f832b9bf45eec9f2f115b12128fe723b4c68cfe0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::codecvt_utf8_utf16&lt;/code&gt; is a &lt;code&gt;&lt;a href=&quot;codecvt&quot;&gt;std::codecvt&lt;/a&gt;&lt;/code&gt; facet which encapsulates conversion between a UTF-8 encoded byte string and UTF-16 encoded character string. If &lt;code&gt;Elem&lt;/code&gt; is a 32-bit type, one UTF-16 code unit will be stored in each 32-bit character of the output sequence.</source>
          <target state="translated">&lt;code&gt;std::codecvt_utf8_utf16&lt;/code&gt; - это фасет &lt;code&gt;&lt;a href=&quot;codecvt&quot;&gt;std::codecvt&lt;/a&gt;&lt;/code&gt; который инкапсулирует преобразование между строкой байтов в кодировке UTF-8 и строкой символов в кодировке UTF-16. Если &lt;code&gt;Elem&lt;/code&gt; является 32-битным типом, одна кодовая единица UTF-16 будет сохранена в каждом 32-битном символе выходной последовательности.</target>
        </trans-unit>
        <trans-unit id="a27e5fee138f572ad520ea598cf73bc2e8e68699" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::collate_byname&lt;/code&gt; is a &lt;code&gt;&lt;a href=&quot;collate&quot;&gt;std::collate&lt;/a&gt;&lt;/code&gt; facet which encapsulates locale-specific collation (comparison) and hashing of strings. Just like &lt;code&gt;&lt;a href=&quot;collate&quot;&gt;std::collate&lt;/a&gt;&lt;/code&gt;, it can be imbued in &lt;code&gt;&lt;a href=&quot;../regex/basic_regex&quot;&gt;std::regex&lt;/a&gt;&lt;/code&gt; and applied, by means of &lt;code&gt;std::locale::operator()&lt;/code&gt;, directly to all standard algorithms that expect a string comparison predicate.</source>
          <target state="translated">&lt;code&gt;std::collate_byname&lt;/code&gt; является &lt;code&gt;&lt;a href=&quot;collate&quot;&gt;std::collate&lt;/a&gt;&lt;/code&gt; фаска , который инкапсулирует локализованные сортировки (сравнение) и хэширование строк. Как и &lt;code&gt;&lt;a href=&quot;collate&quot;&gt;std::collate&lt;/a&gt;&lt;/code&gt; , его можно вставить в &lt;code&gt;&lt;a href=&quot;../regex/basic_regex&quot;&gt;std::regex&lt;/a&gt;&lt;/code&gt; и применить с помощью &lt;code&gt;std::locale::operator()&lt;/code&gt; напрямую ко всем стандартным алгоритмам, которые ожидают предикат сравнения строк.</target>
        </trans-unit>
        <trans-unit id="f0fee92b6a576e7386950be6f1be627eb62f33db" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::condition_variable&lt;/code&gt; works only with &lt;code&gt;&lt;a href=&quot;unique_lock&quot;&gt;std::unique_lock&lt;/a&gt;&amp;lt;&lt;a href=&quot;mutex&quot;&gt;std::mutex&lt;/a&gt;&amp;gt;&lt;/code&gt;; this restriction allows for maximal efficiency on some platforms. &lt;code&gt;&lt;a href=&quot;condition_variable_any&quot;&gt;std::condition_variable_any&lt;/a&gt;&lt;/code&gt; provides a condition variable that works with any &lt;a href=&quot;../named_req/basiclockable&quot;&gt;BasicLockable&lt;/a&gt; object, such as &lt;code&gt;&lt;a href=&quot;shared_lock&quot;&gt;std::shared_lock&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;std::condition_variable&lt;/code&gt; работает только с &lt;code&gt;&lt;a href=&quot;unique_lock&quot;&gt;std::unique_lock&lt;/a&gt;&amp;lt;&lt;a href=&quot;mutex&quot;&gt;std::mutex&lt;/a&gt;&amp;gt;&lt;/code&gt; ; это ограничение учитывает максимальную эффективность на некоторых платформах. &lt;code&gt;&lt;a href=&quot;condition_variable_any&quot;&gt;std::condition_variable_any&lt;/a&gt;&lt;/code&gt; предоставляет условную переменную, которая работает с любым объектом &lt;a href=&quot;../named_req/basiclockable&quot;&gt;BasicLockable&lt;/a&gt; , например &lt;code&gt;&lt;a href=&quot;shared_lock&quot;&gt;std::shared_lock&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7a09cabee8cc7327ea6113cf876758db70326f71" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::condition_variable_any&lt;/code&gt; can be used with &lt;code&gt;&lt;a href=&quot;shared_lock&quot;&gt;std::shared_lock&lt;/a&gt;&lt;/code&gt; in order to wait on a &lt;code&gt;&lt;a href=&quot;shared_mutex&quot;&gt;std::shared_mutex&lt;/a&gt;&lt;/code&gt; in shared ownership mode.</source>
          <target state="translated">&lt;code&gt;std::condition_variable_any&lt;/code&gt; может использоваться с &lt;code&gt;&lt;a href=&quot;shared_lock&quot;&gt;std::shared_lock&lt;/a&gt;&lt;/code&gt; для ожидания &lt;code&gt;&lt;a href=&quot;shared_mutex&quot;&gt;std::shared_mutex&lt;/a&gt;&lt;/code&gt; в режиме совместного владения.</target>
        </trans-unit>
        <trans-unit id="da285dc396f63c6f4370c85412e3bf4c8b70288c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::copysign&lt;/code&gt; is the only portable way to manipulate the sign of a NaN value (to examine the sign of a NaN, &lt;code&gt;signbit&lt;/code&gt; may also be used).</source>
          <target state="translated">&lt;code&gt;std::copysign&lt;/code&gt; является единственным переносимым способом манипулирования знаком значения NaN (для проверки знака NaN также может использоваться &lt;code&gt;signbit&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="dec4cfaf4dd31be3402d0290d7bcf0c2cda100d3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::ctype_byname&lt;/code&gt; is a &lt;code&gt;&lt;a href=&quot;ctype&quot;&gt;std::ctype&lt;/a&gt;&lt;/code&gt; facet which encapsulates character classification rules of the locale specified at its construction.</source>
          <target state="translated">&lt;code&gt;std::ctype_byname&lt;/code&gt; - это фасет &lt;code&gt;&lt;a href=&quot;ctype&quot;&gt;std::ctype&lt;/a&gt;&lt;/code&gt; который инкапсулирует правила классификации символов локали, указанной при его построении.</target>
        </trans-unit>
        <trans-unit id="48d133c7dc05905738abe26c5cc2610f78667ed8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::cv_status&lt;/code&gt; is used by the &lt;code&gt;wait_for&lt;/code&gt; and &lt;code&gt;wait_until&lt;/code&gt; methods of &lt;code&gt;&lt;a href=&quot;condition_variable&quot;&gt;std::condition_variable&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;condition_variable_any&quot;&gt;std::condition_variable_any&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;std::cv_status&lt;/code&gt; используется методами &lt;code&gt;wait_for&lt;/code&gt; и &lt;code&gt;wait_until&lt;/code&gt; в &lt;code&gt;&lt;a href=&quot;condition_variable&quot;&gt;std::condition_variable&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;condition_variable_any&quot;&gt;std::condition_variable_any&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="78c2046db037983cb249ce8d08603b36997f911a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::default_delete&lt;/code&gt; is the default destruction policy used by &lt;code&gt;&lt;a href=&quot;unique_ptr&quot;&gt;std::unique_ptr&lt;/a&gt;&lt;/code&gt; when no deleter is specified.</source>
          <target state="translated">&lt;code&gt;std::default_delete&lt;/code&gt; - это политика уничтожения по умолчанию, используемая &lt;code&gt;&lt;a href=&quot;unique_ptr&quot;&gt;std::unique_ptr&lt;/a&gt;&lt;/code&gt; когда не указано, что удалено.</target>
        </trans-unit>
        <trans-unit id="11ee961a9fe952865469b5b1362eb3a6d1138456" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::defer_lock&lt;/code&gt;, &lt;code&gt;std::try_to_lock&lt;/code&gt; and &lt;code&gt;std::adopt_lock&lt;/code&gt; are instances of empty struct tag types &lt;code&gt;&lt;a href=&quot;lock_tag_t&quot;&gt;std::defer_lock_t&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;lock_tag_t&quot;&gt;std::try_to_lock_t&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;lock_tag_t&quot;&gt;std::adopt_lock_t&lt;/a&gt;&lt;/code&gt; respectively.</source>
          <target state="translated">&lt;code&gt;std::defer_lock&lt;/code&gt; , &lt;code&gt;std::try_to_lock&lt;/code&gt; и &lt;code&gt;std::adopt_lock&lt;/code&gt; являются экземплярами пустых типов тегов struct &lt;code&gt;&lt;a href=&quot;lock_tag_t&quot;&gt;std::defer_lock_t&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;lock_tag_t&quot;&gt;std::try_to_lock_t&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;lock_tag_t&quot;&gt;std::adopt_lock_t&lt;/a&gt;&lt;/code&gt; соответственно.</target>
        </trans-unit>
        <trans-unit id="ff534366543af0ca822f02d2f5404431b0438911" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::defer_lock_t&lt;/code&gt;, &lt;code&gt;std::try_to_lock_t&lt;/code&gt; and &lt;code&gt;std::adopt_lock_t&lt;/code&gt; are empty struct tag types used to specify locking strategy for &lt;code&gt;&lt;a href=&quot;lock_guard&quot;&gt;std::lock_guard&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;std::scoped_lock&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;unique_lock&quot;&gt;std::unique_lock&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;shared_lock&quot;&gt;std::shared_lock&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;std::defer_lock_t&lt;/code&gt; , &lt;code&gt;std::try_to_lock_t&lt;/code&gt; и &lt;code&gt;std::adopt_lock_t&lt;/code&gt; - это пустые типы тегов struct, используемые для определения стратегии блокировки для &lt;code&gt;&lt;a href=&quot;lock_guard&quot;&gt;std::lock_guard&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;std::scoped_lock&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;unique_lock&quot;&gt;std::unique_lock&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;shared_lock&quot;&gt;std::shared_lock&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a5ba3a6548fd85a605db2a04aef9e451efc0f9a4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::deque&lt;/code&gt; (double-ended queue) is an indexed sequence container that allows fast insertion and deletion at both its beginning and its end. In addition, insertion and deletion at either end of a deque never invalidates pointers or references to the rest of the elements.</source>
          <target state="translated">&lt;code&gt;std::deque&lt;/code&gt; (двусторонняя очередь) - это контейнер с индексированной последовательностью, который позволяет быстро вставлять и удалять как в начале, так и в конце. Кроме того, вставка и удаление на любом конце deque никогда не лишает законной силы указатели или ссылки на остальные элементы.</target>
        </trans-unit>
        <trans-unit id="ac7511003a8120ef1ac2ae270a948663e03c1233" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::deque&lt;/code&gt; meets the requirements of &lt;a href=&quot;../named_req/container&quot;&gt;Container&lt;/a&gt;, &lt;a href=&quot;../named_req/allocatorawarecontainer&quot;&gt;AllocatorAwareContainer&lt;/a&gt;, &lt;a href=&quot;../named_req/sequencecontainer&quot;&gt;SequenceContainer&lt;/a&gt; and &lt;a href=&quot;../named_req/reversiblecontainer&quot;&gt;ReversibleContainer&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;std::deque&lt;/code&gt; отвечает требованиям &lt;a href=&quot;../named_req/container&quot;&gt;Контейнера&lt;/a&gt; , &lt;a href=&quot;../named_req/allocatorawarecontainer&quot;&gt;AllocatorAwareContainer&lt;/a&gt; , &lt;a href=&quot;../named_req/sequencecontainer&quot;&gt;SequenceContainer&lt;/a&gt; и &lt;a href=&quot;../named_req/reversiblecontainer&quot;&gt;ReversibleContainer&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="cd1189e9a91c6fd7c0c352263f9b637a6e4ec29e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::discrete_distribution&lt;/code&gt; produces random integers on the interval &lt;code&gt;[0, n)&lt;/code&gt;, where the probability of each individual integer &lt;code&gt;i&lt;/code&gt; is defined as w</source>
          <target state="translated">&lt;code&gt;std::discrete_distribution&lt;/code&gt; создает случайные целые числа в интервале &lt;code&gt;[0, n)&lt;/code&gt; , где вероятность каждого отдельного целого числа &lt;code&gt;i&lt;/code&gt; определяется как w</target>
        </trans-unit>
        <trans-unit id="73b9063244eaf29698d1ce46baf9783f844ba9e0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::discrete_distribution&lt;/code&gt; satisfies all requirements of &lt;a href=&quot;../../named_req/randomnumberdistribution&quot;&gt;RandomNumberDistribution&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;std::discrete_distribution&lt;/code&gt; удовлетворяет всем требованиям &lt;a href=&quot;../../named_req/randomnumberdistribution&quot;&gt;RandomNumberDistribution&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="babc06a10c9c15005fb04a3d088bf1290c70919d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::dynamic_extent&lt;/code&gt; is a constant of type &lt;code&gt;&lt;a href=&quot;../../types/size_t&quot;&gt;std::size_t&lt;/a&gt;&lt;/code&gt; that is used to differentiate &lt;a href=&quot;../span&quot;&gt;&lt;code&gt;std::span&lt;/code&gt;&lt;/a&gt; of static and dynamic extent.</source>
          <target state="translated">&lt;code&gt;std::dynamic_extent&lt;/code&gt; - это константа типа &lt;code&gt;&lt;a href=&quot;../../types/size_t&quot;&gt;std::size_t&lt;/a&gt;&lt;/code&gt; которая используется для различения &lt;a href=&quot;../span&quot;&gt; &lt;code&gt;std::span&lt;/code&gt; &lt;/a&gt; от статического и динамического экстента.</target>
        </trans-unit>
        <trans-unit id="c0c7ae6a02052d574c16ef064424d6bdfd3ac30f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::enable_shared_from_this&lt;/code&gt; allows an object &lt;code&gt;t&lt;/code&gt; that is currently managed by a &lt;code&gt;&lt;a href=&quot;shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&lt;/code&gt; named &lt;code&gt;pt&lt;/code&gt; to safely generate additional &lt;code&gt;&lt;a href=&quot;shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&lt;/code&gt; instances &lt;code&gt;pt1, pt2, ...&lt;/code&gt; that all share ownership of &lt;code&gt;t&lt;/code&gt; with &lt;code&gt;pt&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;std::enable_shared_from_this&lt;/code&gt; позволяет объекту &lt;code&gt;t&lt;/code&gt; , которым в настоящее время управляет &lt;code&gt;&lt;a href=&quot;shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&lt;/code&gt; именем &lt;code&gt;pt&lt;/code&gt; , безопасно генерировать дополнительные экземпляры &lt;code&gt;&lt;a href=&quot;shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&lt;/code&gt; &lt;code&gt;pt1, pt2, ...&lt;/code&gt; которые все совместно владеют &lt;code&gt;t&lt;/code&gt; с &lt;code&gt;pt&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9b225dda4f3adfeaed7ea510758b565e3aecef23" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::equal&lt;/code&gt; should not be used to compare the ranges formed by the iterators from &lt;code&gt;&lt;a href=&quot;../container/unordered_set&quot;&gt;std::unordered_set&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../container/unordered_multiset&quot;&gt;std::unordered_multiset&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../container/unordered_map&quot;&gt;std::unordered_map&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;../container/unordered_multimap&quot;&gt;std::unordered_multimap&lt;/a&gt;&lt;/code&gt; because the order in which the elements are stored in those containers may be different even if the two containers store the same elements.</source>
          <target state="translated">&lt;code&gt;std::equal&lt;/code&gt; не следует использовать для сравнения диапазонов, сформированных итераторами из &lt;code&gt;&lt;a href=&quot;../container/unordered_set&quot;&gt;std::unordered_set&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../container/unordered_multiset&quot;&gt;std::unordered_multiset&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../container/unordered_map&quot;&gt;std::unordered_map&lt;/a&gt;&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;../container/unordered_multimap&quot;&gt;std::unordered_multimap&lt;/a&gt;&lt;/code&gt; поскольку порядок, в котором элементы хранятся в этих контейнерах, может отличаться, даже если два контейнера хранят одинаковые элементы.</target>
        </trans-unit>
        <trans-unit id="632f518e0f97f3ba086be4ec5a62bb8100c02856" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::error_category&lt;/code&gt; serves as the base class for specific error category types, such as &lt;code&gt;&lt;a href=&quot;system_category&quot;&gt;std::system_category&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../io/iostream_category&quot;&gt;std::iostream_category&lt;/a&gt;&lt;/code&gt;, etc. Each specific category class defines the &lt;code&gt;error_code&lt;/code&gt; - &lt;code&gt;error_condition&lt;/code&gt; mapping and holds the explanatory strings for all error_conditions. The objects of error category classes are treated as singletons, passed by reference.</source>
          <target state="translated">&lt;code&gt;std::error_category&lt;/code&gt; служит базовым классом для определенных типов категорий ошибок, таких как &lt;code&gt;&lt;a href=&quot;system_category&quot;&gt;std::system_category&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../io/iostream_category&quot;&gt;std::iostream_category&lt;/a&gt;&lt;/code&gt; и т. д. Каждый конкретный класс категорий определяет отображение &lt;code&gt;error_code&lt;/code&gt; - &lt;code&gt;error_condition&lt;/code&gt; и содержит пояснительные строки для всех error_conditions. Объекты классов категории ошибок рассматриваются как одиночные, переданные по ссылке.</target>
        </trans-unit>
        <trans-unit id="fac9c199fb321fcb496aead48672d7b130b469fe" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::error_code&lt;/code&gt; is a platform-dependent error code. Each &lt;code&gt;std::error_code&lt;/code&gt; object holds an error code originating from the operating system or some low-level interface and a pointer to an object of type &lt;code&gt;&lt;a href=&quot;error_category&quot;&gt;std::error_category&lt;/a&gt;&lt;/code&gt;, which corresponds to the said interface. The error code values may be not unique across different error categories.</source>
          <target state="translated">&lt;code&gt;std::error_code&lt;/code&gt; является зависимым от платформы кодом ошибки. Каждый объект &lt;code&gt;std::error_code&lt;/code&gt; содержит код ошибки, исходящий из операционной системы или какого-либо низкоуровневого интерфейса, и указатель на объект типа &lt;code&gt;&lt;a href=&quot;error_category&quot;&gt;std::error_category&lt;/a&gt;&lt;/code&gt; , который соответствует указанному интерфейсу. Значения кода ошибки могут быть не уникальными для разных категорий ошибок.</target>
        </trans-unit>
        <trans-unit id="f695bdc00126c7ac476d86d0fb6b8427fd15538f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::error_condition&lt;/code&gt; is a platform-independent error code. Like &lt;code&gt;&lt;a href=&quot;error_code&quot;&gt;std::error_code&lt;/a&gt;&lt;/code&gt;, it is uniquely identified by an integer value and a &lt;code&gt;&lt;a href=&quot;error_category&quot;&gt;std::error_category&lt;/a&gt;&lt;/code&gt;, but unlike &lt;code&gt;&lt;a href=&quot;error_code&quot;&gt;std::error_code&lt;/a&gt;&lt;/code&gt;, the value is not platform-dependent.</source>
          <target state="translated">&lt;code&gt;std::error_condition&lt;/code&gt; - независимый от платформы код ошибки. Как и &lt;code&gt;&lt;a href=&quot;error_code&quot;&gt;std::error_code&lt;/a&gt;&lt;/code&gt; , он однозначно идентифицируется целочисленным значением и &lt;code&gt;&lt;a href=&quot;error_category&quot;&gt;std::error_category&lt;/a&gt;&lt;/code&gt; , но в отличие от &lt;code&gt;&lt;a href=&quot;error_code&quot;&gt;std::error_code&lt;/a&gt;&lt;/code&gt; это значение не зависит от платформы.</target>
        </trans-unit>
        <trans-unit id="d8e8654c75557ba66cb78816d2393b7f829e6472" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::exception_ptr&lt;/code&gt; is a nullable pointer-like type that manages an exception object which has been thrown and captured with &lt;code&gt;&lt;a href=&quot;current_exception&quot;&gt;std::current_exception&lt;/a&gt;&lt;/code&gt;. An instance of &lt;code&gt;std::exception_ptr&lt;/code&gt; may be passed to another function, possibly on another thread, where the exception may be rethrown and handled with a catch clause.</source>
          <target state="translated">&lt;code&gt;std::exception_ptr&lt;/code&gt; - это обнуляемый указатель типа, который управляет объектом исключения, который был брошен и захвачен с помощью &lt;code&gt;&lt;a href=&quot;current_exception&quot;&gt;std::current_exception&lt;/a&gt;&lt;/code&gt; . Экземпляр &lt;code&gt;std::exception_ptr&lt;/code&gt; может быть передан другой функции, возможно, в другой поток, где исключение может быть переброшено и обработано с помощью предложения catch.</target>
        </trans-unit>
        <trans-unit id="14b49292590a444036557cbbbda93f38fff8d1b2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::exception_ptr&lt;/code&gt; is not implicitly convertible to any arithmetic, enumeration, or pointer type. It is contextually convertible to &lt;code&gt;bool&lt;/code&gt;, and will evaluate to false if it is null, true otherwise.</source>
          <target state="translated">&lt;code&gt;std::exception_ptr&lt;/code&gt; неявно конвертируется в любой тип арифметики, перечисления или указателя. Это контекстно конвертируется в &lt;code&gt;bool&lt;/code&gt; , и оценивается как false, если оно равно null, в противном случае - true.</target>
        </trans-unit>
        <trans-unit id="57641bf827fb4f30125de277f6b3255d2e659787" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::exception_ptr&lt;/code&gt; meets the requirements of &lt;a href=&quot;../named_req/nullablepointer&quot;&gt;NullablePointer&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;std::exception_ptr&lt;/code&gt; соответствует требованиям &lt;a href=&quot;../named_req/nullablepointer&quot;&gt;NullablePointer&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9855684a30c9ba5dfd239066f3ae8f0d65a98657" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::execution::seq&lt;/code&gt;, &lt;code&gt;std::execution::par&lt;/code&gt;, &lt;code&gt;std::execution::par_unseq&lt;/code&gt;, and &lt;code&gt;std::execution::unseq&lt;/code&gt; are instances of the execution policy types &lt;code&gt;&lt;a href=&quot;execution_policy_tag_t&quot;&gt;std::execution::sequenced_policy&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;execution_policy_tag_t&quot;&gt;std::execution::parallel_policy&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;execution_policy_tag_t&quot;&gt;std::execution::parallel_unsequenced_policy&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;std::execution::unsequenced_policy&lt;/code&gt; respectively. They are used to specify the execution policy of parallel algorithms - i.e., the kinds of parallelism allowed.</source>
          <target state="translated">&lt;code&gt;std::execution::seq&lt;/code&gt; , &lt;code&gt;std::execution::par&lt;/code&gt; &lt;code&gt;std::execution::par_unseq&lt;/code&gt; :: par , std :: execute :: par_unseq и &lt;code&gt;std::execution::unseq&lt;/code&gt; являются экземплярами типов политики выполнения &lt;code&gt;&lt;a href=&quot;execution_policy_tag_t&quot;&gt;std::execution::sequenced_policy&lt;/a&gt;&lt;/code&gt; execute :: sequenced_policy , &lt;code&gt;&lt;a href=&quot;execution_policy_tag_t&quot;&gt;std::execution::parallel_policy&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;execution_policy_tag_t&quot;&gt;std::execution::parallel_unsequenced_policy&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;std::execution::unsequenced_policy&lt;/code&gt; соответственно. Они используются для указания политики выполнения параллельных алгоритмов, т. Е. Разрешенных видов параллелизма.</target>
        </trans-unit>
        <trans-unit id="f81f924ab5fb012ab97a4c81941f6da54601b41c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::exponential_distribution&lt;/code&gt; satisfies &lt;a href=&quot;../../named_req/randomnumberdistribution&quot;&gt;RandomNumberDistribution&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;std::exponential_distribution&lt;/code&gt; удовлетворяет &lt;a href=&quot;../../named_req/randomnumberdistribution&quot;&gt;RandomNumberDistribution&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="731f75b5983a917cf59abfe73aa61c1e6683808d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::extreme_value_distribution&lt;/code&gt; satisfies all requirements of &lt;a href=&quot;../../named_req/randomnumberdistribution&quot;&gt;RandomNumberDistribution&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;std::extreme_value_distribution&lt;/code&gt; удовлетворяет всем требованиям &lt;a href=&quot;../../named_req/randomnumberdistribution&quot;&gt;RandomNumberDistribution&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6b45df502c8abb6d9404ea462f3d01ebde814a38" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::fisher_f_distribution&lt;/code&gt; satisfies all requirements of &lt;a href=&quot;../../named_req/randomnumberdistribution&quot;&gt;RandomNumberDistribution&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;std::fisher_f_distribution&lt;/code&gt; удовлетворяет всем требованиям &lt;a href=&quot;../../named_req/randomnumberdistribution&quot;&gt;RandomNumberDistribution&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f4c4072e32a83cf416dd9cce5e53d8848117eccb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::fmod&lt;/code&gt;, but not &lt;code&gt;&lt;a href=&quot;remainder&quot;&gt;std::remainder&lt;/a&gt;&lt;/code&gt; is useful for doing silent wrapping of floating-point types to unsigned integer types: &lt;code&gt;(0.0 &amp;lt;= (y = std::fmod( &lt;a href=&quot;rint&quot;&gt;std::rint&lt;/a&gt;(x), 65536.0 )) ? y : 65536.0 + y)&lt;/code&gt; is in the range &lt;code&gt;[-0.0 .. 65535.0]&lt;/code&gt;, which corresponds to &lt;code&gt;unsigned short&lt;/code&gt;, but &lt;code&gt;&lt;a href=&quot;remainder&quot;&gt;std::remainder&lt;/a&gt;(&lt;a href=&quot;rint&quot;&gt;std::rint&lt;/a&gt;(x), 65536.0&lt;/code&gt; is in the range &lt;code&gt;[-32767.0, +32768.0]&lt;/code&gt;, which is outside of the range of &lt;code&gt;signed short&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;std::fmod&lt;/code&gt; , но не &lt;code&gt;&lt;a href=&quot;remainder&quot;&gt;std::remainder&lt;/a&gt;&lt;/code&gt; , полезен для тихого переноса типов с плавающей запятой в целочисленные типы без знака: &lt;code&gt;(0.0 &amp;lt;= (y = std::fmod( &lt;a href=&quot;rint&quot;&gt;std::rint&lt;/a&gt;(x), 65536.0 )) ? y : 65536.0 + y)&lt;/code&gt; находится в диапазоне &lt;code&gt;[-0.0 .. 65535.0]&lt;/code&gt; , что соответствует &lt;code&gt;unsigned short&lt;/code&gt; , но &lt;code&gt;&lt;a href=&quot;remainder&quot;&gt;std::remainder&lt;/a&gt;(&lt;a href=&quot;rint&quot;&gt;std::rint&lt;/a&gt;(x), 65536.0&lt;/code&gt; находится в диапазоне &lt;code&gt;[-32767.0, +32768.0]&lt;/code&gt; , что находится за пределами диапазона &lt;code&gt;signed short&lt;/code&gt; позиции .</target>
        </trans-unit>
        <trans-unit id="cbfadbd0a7ccd1e3ec0ee00d99bda6db1cc5ccdc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::forward_list&lt;/code&gt; is a container that supports fast insertion and removal of elements from anywhere in the container. Fast random access is not supported. It is implemented as a singly-linked list and essentially does not have any overhead compared to its implementation in C. Compared to &lt;code&gt;&lt;a href=&quot;list&quot;&gt;std::list&lt;/a&gt;&lt;/code&gt; this container provides more space efficient storage when bidirectional iteration is not needed.</source>
          <target state="translated">&lt;code&gt;std::forward_list&lt;/code&gt; - это контейнер, который поддерживает быструю вставку и удаление элементов из любой точки контейнера. Быстрый произвольный доступ не поддерживается. Он реализован в виде односвязного списка и, по существу, не имеет никаких накладных расходов по сравнению с его реализацией в C. По сравнению с &lt;code&gt;&lt;a href=&quot;list&quot;&gt;std::list&lt;/a&gt;&lt;/code&gt; этот контейнер обеспечивает более эффективное хранение, когда двунаправленная итерация не требуется.</target>
        </trans-unit>
        <trans-unit id="c2ebf9e9e435ee3056ad9fc9787f7844dacc9bd2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::forward_list&lt;/code&gt; meets the requirements of &lt;a href=&quot;../named_req/container&quot;&gt;Container&lt;/a&gt; (except for the &lt;code&gt;size&lt;/code&gt; member function and that &lt;code&gt;operator==&lt;/code&gt;'s complexity is always linear), &lt;a href=&quot;../named_req/allocatorawarecontainer&quot;&gt;AllocatorAwareContainer&lt;/a&gt; and &lt;a href=&quot;../named_req/sequencecontainer&quot;&gt;SequenceContainer&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;std::forward_list&lt;/code&gt; соответствует требованиям &lt;a href=&quot;../named_req/container&quot;&gt;контейнера&lt;/a&gt; (за исключением функции-члена &lt;code&gt;size&lt;/code&gt; и сложности &lt;code&gt;operator==&lt;/code&gt; всегда линейна), &lt;a href=&quot;../named_req/allocatorawarecontainer&quot;&gt;AllocatorAwareContainer&lt;/a&gt; и &lt;a href=&quot;../named_req/sequencecontainer&quot;&gt;SequenceContainer&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7837beae5eb8318478a03816d5fe69264da35bd5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::front_insert_iterator&lt;/code&gt; is an &lt;a href=&quot;../named_req/outputiterator&quot;&gt;LegacyOutputIterator&lt;/a&gt; that prepends elements to a container for which it was constructed. The container's &lt;code&gt;push_front()&lt;/code&gt; member function is called whenever the iterator (whether dereferenced or not) is assigned to. Incrementing the &lt;code&gt;std::front_insert_iterator&lt;/code&gt; is a no-op.</source>
          <target state="translated">&lt;code&gt;std::front_insert_iterator&lt;/code&gt; - это &lt;a href=&quot;../named_req/outputiterator&quot;&gt;LegacyOutputIterator,&lt;/a&gt; который добавляет элементы в контейнер, для которого он был создан. Функция- член контейнера &lt;code&gt;push_front()&lt;/code&gt; вызывается всякий раз, когда назначается итератор (с разыменованным или нет). Приращение в &lt;code&gt;std::front_insert_iterator&lt;/code&gt; является не оп.</target>
        </trans-unit>
        <trans-unit id="a292140cf981fe03ff447787efd5c8db75cd6be5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::function&lt;/code&gt; results in &lt;code&gt;&lt;a href=&quot;bad_function_call&quot;&gt;std::bad_function_call&lt;/a&gt;&lt;/code&gt; exception being thrown.</source>
          <target state="translated">&lt;code&gt;std::function&lt;/code&gt; приводит к &lt;code&gt;&lt;a href=&quot;bad_function_call&quot;&gt;std::bad_function_call&lt;/a&gt;&lt;/code&gt; исключения std :: bad_function_call .</target>
        </trans-unit>
        <trans-unit id="a3ae0891ae968af55946d0eb13471e46bd7151c2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::function&lt;/code&gt; satisfies the requirements of &lt;a href=&quot;../../named_req/copyconstructible&quot;&gt;CopyConstructible&lt;/a&gt; and &lt;a href=&quot;../../named_req/copyassignable&quot;&gt;CopyAssignable&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;std::function&lt;/code&gt; удовлетворяет требованиям &lt;a href=&quot;../../named_req/copyconstructible&quot;&gt;CopyConstructible&lt;/a&gt; и &lt;a href=&quot;../../named_req/copyassignable&quot;&gt;CopyAssignable&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2c5b3f73ed92b9406389fdf0d10ca68e16404c14" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::function&lt;/code&gt; to compare</source>
          <target state="translated">&lt;code&gt;std::function&lt;/code&gt; для сравнения</target>
        </trans-unit>
        <trans-unit id="a327e115acfa4ae14e0d19493fc8762f3f4abead" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::function&lt;/code&gt;'s allocator support was poorly specified and inconsistently implemented. Some implementations do not provide overloads (6-10) at all, some provide the overloads but ignore the supplied allocator argument, and some provide the overloads and use the supplied allocator for construction but not when the &lt;code&gt;std::function&lt;/code&gt; is reassigned. As a result, allocator support was removed in C++17.</source>
          <target state="translated">&lt;code&gt;std::function&lt;/code&gt; Поддержка распределителя в std :: function была плохо определена и неправильно реализована. Некоторые реализации вообще не предоставляют перегрузок (6-10), некоторые предоставляют перегрузки, но игнорируют предоставленный аргумент распределителя, а некоторые предоставляют перегрузки и используют предоставленный распределитель для построения, но не при переназначении &lt;code&gt;std::function&lt;/code&gt; . В результате поддержка распределителя была удалена в C ++ 17.</target>
        </trans-unit>
        <trans-unit id="712d2dee9547b4620e4b013fe8a329852f4ba582" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::function&lt;/code&gt;'s allocator support was poorly specified and inconsistently implemented. Some implementations do not support uses-allocator construction at all, some provide the needed constructor overloads but ignore the supplied allocator argument, and some provide the overloads and use the supplied allocator for construction but not when the &lt;code&gt;std::function&lt;/code&gt; is reassigned. As a result, allocator support was removed in C++17.</source>
          <target state="translated">&lt;code&gt;std::function&lt;/code&gt; Поддержка распределителя в std :: function была плохо определена и неправильно реализована. Некоторые реализации вообще не поддерживают конструкцию использования-распределителя, некоторые предоставляют необходимые перегрузки конструктора, но игнорируют предоставленный аргумент распределителя, а некоторые предоставляют перегрузки и используют предоставленный распределитель для конструирования, но не при переназначении &lt;code&gt;std::function&lt;/code&gt; . В результате поддержка распределителя была удалена в C ++ 17.</target>
        </trans-unit>
        <trans-unit id="ef1a78cf97a17ae6134be85fe81b8bc55f188b06" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::gamma_distribution&lt;/code&gt; satisfies &lt;a href=&quot;../../named_req/randomnumberdistribution&quot;&gt;RandomNumberDistribution&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;std::gamma_distribution&lt;/code&gt; удовлетворяет &lt;a href=&quot;../../named_req/randomnumberdistribution&quot;&gt;RandomNumberDistribution&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="480cc0303c36c42d3e2b99061ea26d10538b0a7a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::geometric_distribution&amp;lt;&amp;gt;(p)&lt;/code&gt; is exactly equivalent to &lt;code&gt;&lt;a href=&quot;negative_binomial_distribution&quot;&gt;std::negative_binomial_distribution&lt;/a&gt;&amp;lt;&amp;gt;(1, p)&lt;/code&gt;. It is also the discrete counterpart of &lt;code&gt;&lt;a href=&quot;exponential_distribution&quot;&gt;std::exponential_distribution&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;std::geometric_distribution&amp;lt;&amp;gt;(p)&lt;/code&gt; в точности эквивалентен &lt;code&gt;&lt;a href=&quot;negative_binomial_distribution&quot;&gt;std::negative_binomial_distribution&lt;/a&gt;&amp;lt;&amp;gt;(1, p)&lt;/code&gt; . Это также дискретный аналог &lt;code&gt;&lt;a href=&quot;exponential_distribution&quot;&gt;std::exponential_distribution&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a875eff720096f08c747f9f90b5860be91e34e17" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::geometric_distribution&lt;/code&gt; satisfies &lt;a href=&quot;../../named_req/randomnumberdistribution&quot;&gt;RandomNumberDistribution&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;std::geometric_distribution&lt;/code&gt; &lt;a href=&quot;../../named_req/randomnumberdistribution&quot;&gt;ometric_distribution&lt;/a&gt; удовлетворяет RandomNumberDistribution .</target>
        </trans-unit>
        <trans-unit id="9c0402cd35d0eb2692fe862c055f0797c10f2179" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::gslice&lt;/code&gt; is the selector class that identifies a subset of &lt;code&gt;&lt;a href=&quot;../valarray&quot;&gt;std::valarray&lt;/a&gt;&lt;/code&gt; indices defined by a multi-level set of strides and sizes. Objects of type &lt;code&gt;std::gslice&lt;/code&gt; can be used as indices with valarray's &lt;code&gt;operator[]&lt;/code&gt; to select, for example, columns of a multidimensional array represented as a &lt;code&gt;valarray&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;std::gslice&lt;/code&gt; - это класс селектора, который идентифицирует подмножество индексов &lt;code&gt;&lt;a href=&quot;../valarray&quot;&gt;std::valarray&lt;/a&gt;&lt;/code&gt; определенных многоуровневым набором шагов и размеров. Объекты типа &lt;code&gt;std::gslice&lt;/code&gt; могут использоваться как индексы с &lt;code&gt;operator[]&lt;/code&gt; valarray [] для выбора, например, столбцов многомерного массива, представленного как &lt;code&gt;valarray&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="52dbd11ae18bfb43cb00666d6f58bf0da1cc38ac" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::gslice_array&lt;/code&gt; is a helper template used by &lt;code&gt;&lt;a href=&quot;gslice&quot;&gt;std::gslice&lt;/a&gt;&lt;/code&gt; subscript operator. It has reference semantics to a subset of the array specified by the &lt;code&gt;std::gslice&lt;/code&gt; object.</source>
          <target state="translated">&lt;code&gt;std::gslice_array&lt;/code&gt; является вспомогательным шаблоном, используемым оператором индекса &lt;code&gt;&lt;a href=&quot;gslice&quot;&gt;std::gslice&lt;/a&gt;&lt;/code&gt; . Он имеет семантику ссылок на подмножество массива, указанного объектом &lt;code&gt;std::gslice&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a9633ecc1dd7b10e73c946202a0686610bf5c770" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::gslice_array&lt;/code&gt; is a helper template used by &lt;code&gt;std::indirect_array&lt;/code&gt; subscript operator. It has reference semantics to a subset of the array specified by an indirect array (&lt;code&gt;&lt;a href=&quot;../valarray&quot;&gt;std::valarray&lt;/a&gt;&amp;lt;&lt;a href=&quot;../../types/size_t&quot;&gt;std::size_t&lt;/a&gt;&amp;gt;&lt;/code&gt; object).</source>
          <target state="translated">&lt;code&gt;std::gslice_array&lt;/code&gt; является помощник шаблона , используемого &lt;code&gt;std::indirect_array&lt;/code&gt; оператором индекса. Он имеет семантику ссылок на подмножество массива, указанного косвенным массивом ( &lt;code&gt;&lt;a href=&quot;../valarray&quot;&gt;std::valarray&lt;/a&gt;&amp;lt;&lt;a href=&quot;../../types/size_t&quot;&gt;std::size_t&lt;/a&gt;&amp;gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="95b85e3781209d98618a09001f316b61cd5843df" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::hypot(x, y)&lt;/code&gt; is equivalent to &lt;code&gt;std::abs(&lt;a href=&quot;../complex&quot;&gt;std::complex&lt;/a&gt;&amp;lt;double&amp;gt;(x,y))&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;std::hypot(x, y)&lt;/code&gt; эквивалентен &lt;code&gt;std::abs(&lt;a href=&quot;../complex&quot;&gt;std::complex&lt;/a&gt;&amp;lt;double&amp;gt;(x,y))&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7f0ea701b80954df580c165eadacf5776c180e46" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::identity&lt;/code&gt; is a function object type whose &lt;code&gt;operator()&lt;/code&gt; returns its argument unchanged.</source>
          <target state="translated">&lt;code&gt;std::identity&lt;/code&gt; - это тип объекта функции, &lt;code&gt;operator()&lt;/code&gt; которого () возвращает свой аргумент без изменений.</target>
        </trans-unit>
        <trans-unit id="1c22e521fdbeb5e6776597727367efcea87a9141" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::identity&lt;/code&gt; is the identity function object: it returns its argument unchanged.</source>
          <target state="translated">&lt;code&gt;std::identity&lt;/code&gt; - это объект функции тождества: он возвращает свой аргумент без изменений.</target>
        </trans-unit>
        <trans-unit id="0385a1ac553e11d96d8d78b097dd0c676c86b86f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::in_place&lt;/code&gt;, &lt;code&gt;std::in_place_type&lt;/code&gt;, and &lt;code&gt;std::in_place_index&lt;/code&gt; are disambiguation tags that can be passed to the constructors of &lt;code&gt;&lt;a href=&quot;optional&quot;&gt;std::optional&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;variant&quot;&gt;std::variant&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;any&quot;&gt;std::any&lt;/a&gt;&lt;/code&gt; to indicate that the contained object should be constructed in-place, and (for the latter two) the type of the object to be constructed.</source>
          <target state="translated">&lt;code&gt;std::in_place&lt;/code&gt; , &lt;code&gt;std::in_place_type&lt;/code&gt; и &lt;code&gt;std::in_place_index&lt;/code&gt; является неоднозначность теги , которые могут быть переданы строителями &lt;code&gt;&lt;a href=&quot;optional&quot;&gt;std::optional&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;variant&quot;&gt;std::variant&lt;/a&gt;&lt;/code&gt; , и &lt;code&gt;&lt;a href=&quot;any&quot;&gt;std::any&lt;/a&gt;&lt;/code&gt; , чтобы указать , что содержащийся объект должен быть построен на месте, и (для последних двух) тип объекта, который будет построен.</target>
        </trans-unit>
        <trans-unit id="0168b9b751bd08c3bd1414db013cd45caa3e814d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::incrementable_traits&amp;lt;Iter&amp;gt;::difference_type&lt;/code&gt; if valid, otherwise &lt;code&gt;void&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;std::incrementable_traits&amp;lt;Iter&amp;gt;::difference_type&lt;/code&gt; если действительно, в противном случае &lt;code&gt;void&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d26bc5cdd9718de74b05d5b78f85e86c1265c0b9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::insert_iterator&lt;/code&gt; is a &lt;a href=&quot;../named_req/outputiterator&quot;&gt;LegacyOutputIterator&lt;/a&gt; that inserts elements into a container for which it was constructed, at the position pointed to by the supplied iterator. The container's &lt;code&gt;insert()&lt;/code&gt; member function is called whenever the iterator (whether dereferenced or not) is assigned to. Incrementing the &lt;code&gt;std::insert_iterator&lt;/code&gt; is a no-op.</source>
          <target state="translated">&lt;code&gt;std::insert_iterator&lt;/code&gt; - это &lt;a href=&quot;../named_req/outputiterator&quot;&gt;LegacyOutputIterator,&lt;/a&gt; который вставляет элементы в контейнер, для которого он был создан, в положение, указанное указанным итератором. Функция-контейнер контейнера &lt;code&gt;insert()&lt;/code&gt; вызывается всякий раз, когда назначается итератор (независимо от того, разыменован он или нет). Приращение в &lt;code&gt;std::insert_iterator&lt;/code&gt; является не оп.</target>
        </trans-unit>
        <trans-unit id="4ed0c5bbe217d673ceb1003957bd5b7d91123fdb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::int&lt;/code&gt;&lt;b&gt;x&lt;/b&gt;&lt;code&gt;_t&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;std::int&lt;/code&gt;&lt;b&gt;x&lt;/b&gt;&lt;code&gt;_t&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4e4313d5011c53e518c756a2252c4df9a362a403" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::int_fast&lt;/code&gt;&lt;b&gt;x&lt;/b&gt;&lt;code&gt;_t&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;std::int_fast&lt;/code&gt;&lt;b&gt;x&lt;/b&gt;&lt;code&gt;_t&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="056289e3e32a5cd8ae69529fe2789e844000ec9c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::int_least&lt;/code&gt;&lt;b&gt;x&lt;/b&gt;&lt;code&gt;_t&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;std::int_least&lt;/code&gt;&lt;b&gt;x&lt;/b&gt;&lt;code&gt;_t&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f5374c575ed2e778888b40082dccbedb38c0e168" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::integral_constant&amp;lt;std::size_t, N&amp;gt;&lt;/code&gt; for some &lt;code&gt;N&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;std::integral_constant&amp;lt;std::size_t, N&amp;gt;&lt;/code&gt; для некоторого &lt;code&gt;N&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="80ce62b2f6c64e9cc1a197075ce8d58710a0e3f7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::integral_constant&lt;/code&gt; wraps a static constant of specified type. It is the base class for the C++ type traits.</source>
          <target state="translated">&lt;code&gt;std::integral_constant&lt;/code&gt; оборачивает статическую константу указанного типа. Это базовый класс для черт типа C ++.</target>
        </trans-unit>
        <trans-unit id="6a4b13ca29e2535668fcc8630678687f8e5f495a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::ios_base::failure&lt;/code&gt; may be defined either as a member class of &lt;code&gt;&lt;a href=&quot;../ios_base&quot;&gt;std::ios_base&lt;/a&gt;&lt;/code&gt; or as a synonym (typedef) for another class with equivalent functionality.(since C++17).</source>
          <target state="translated">&lt;code&gt;std::ios_base::failure&lt;/code&gt; может быть определен как класс-член &lt;code&gt;&lt;a href=&quot;../ios_base&quot;&gt;std::ios_base&lt;/a&gt;&lt;/code&gt; или как синоним (typedef) для другого класса с эквивалентной функциональностью (начиная с C ++ 17).</target>
        </trans-unit>
        <trans-unit id="c35cebda19804ec67065696fcf947069ced92a75" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::is_aggregate&lt;/code&gt; type trait</source>
          <target state="translated">&lt;code&gt;std::is_aggregate&lt;/code&gt; типа std :: is_aggregate</target>
        </trans-unit>
        <trans-unit id="17c43791619df5add71d65dae6f070413cd24fb4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::is_base_of&amp;lt;A, B&amp;gt;::value&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; even if &lt;code&gt;A&lt;/code&gt; is a private, protected, or ambiguous base class of &lt;code&gt;B&lt;/code&gt;. In many situations, &lt;code&gt;&lt;a href=&quot;is_convertible&quot;&gt;std::is_convertible&lt;/a&gt;&amp;lt;B*, A*&amp;gt;&lt;/code&gt; is the more appropriate test.</source>
          <target state="translated">&lt;code&gt;std::is_base_of&amp;lt;A, B&amp;gt;::value&lt;/code&gt; является &lt;code&gt;true&lt;/code&gt; , даже если является частным, защищенным или неоднозначным базовым классом &lt;code&gt;B&lt;/code&gt; . Во многих ситуациях &lt;code&gt;&lt;a href=&quot;is_convertible&quot;&gt;std::is_convertible&lt;/a&gt;&amp;lt;B*, A*&amp;gt;&lt;/code&gt; &amp;lt;B *, A *&amp;gt; является более подходящим тестом. &lt;code&gt;A&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="fc232ada3163773b55f91cfd4ebcdc316148abd5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::is_default_constructible&amp;lt;T&amp;gt;&lt;/code&gt; does not test that &lt;code&gt;T x;&lt;/code&gt; would compile; it attempts &lt;a href=&quot;../language/direct_initialization&quot;&gt;direct-initialization&lt;/a&gt; with an empty argument list (see &lt;code&gt;&lt;a href=&quot;is_constructible&quot;&gt;std::is_constructible&lt;/a&gt;&lt;/code&gt;). Thus, &lt;code&gt;std::is_default_constructible_v&amp;lt;const int&amp;gt;&lt;/code&gt; and &lt;code&gt;std::is_default_constructible_v&amp;lt;const int[10]&amp;gt;&lt;/code&gt; are &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;std::is_default_constructible&amp;lt;T&amp;gt;&lt;/code&gt; не проверяет, что &lt;code&gt;T x;&lt;/code&gt; будет компилировать; он пытается выполнить &lt;a href=&quot;../language/direct_initialization&quot;&gt;прямую инициализацию&lt;/a&gt; с пустым списком аргументов (см. &lt;code&gt;&lt;a href=&quot;is_constructible&quot;&gt;std::is_constructible&lt;/a&gt;&lt;/code&gt; ). Таким образом, &lt;code&gt;std::is_default_constructible_v&amp;lt;const int&amp;gt;&lt;/code&gt; и &lt;code&gt;std::is_default_constructible_v&amp;lt;const int[10]&amp;gt;&lt;/code&gt; имеют значение &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4a7e3513494283e7e309e272990310bfd22e4c1d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::is_empty&amp;lt;T&amp;gt;&lt;/code&gt; and all other type traits are empty classes.</source>
          <target state="translated">&lt;code&gt;std::is_empty&amp;lt;T&amp;gt;&lt;/code&gt; и все другие черты типа являются пустыми классами.</target>
        </trans-unit>
        <trans-unit id="cd321ebf2f2858e8889f2a97ec260a2a043e7c22" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::is_invocable&lt;/code&gt;, &lt;code&gt;std::invoke_result&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;std::is_invocable&lt;/code&gt; , &lt;code&gt;std::invoke_result&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f22e915926826ff5411e65d836e38f3853fb4bee" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::is_sorted&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;is_sorted_until&quot;&gt;std::is_sorted_until&lt;/a&gt;&lt;/code&gt; both return true for empty ranges and ranges of length one.</source>
          <target state="translated">&lt;code&gt;std::is_sorted&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;is_sorted_until&quot;&gt;std::is_sorted_until&lt;/a&gt;&lt;/code&gt; оба возвращают true для пустых диапазонов и диапазонов длины один.</target>
        </trans-unit>
        <trans-unit id="76d5f0212c195e3069a6f21f54bdf8d5d6793a50" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::isspace(c,is.getloc())&lt;/code&gt; is true for the next character &lt;code&gt;c&lt;/code&gt; in &lt;code&gt;is&lt;/code&gt; (this whitespace character remains in the input stream).</source>
          <target state="translated">&lt;code&gt;std::isspace(c,is.getloc())&lt;/code&gt; имеет значение true для следующего символа &lt;code&gt;c&lt;/code&gt; в &lt;code&gt;is&lt;/code&gt; (этот пробельный символ остается во входном потоке).</target>
        </trans-unit>
        <trans-unit id="accacfbe11581a503dba5062106078b5b1e65e10" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::istream_iterator&lt;/code&gt; is a single-pass input iterator that reads successive objects of type &lt;code&gt;T&lt;/code&gt; from the &lt;code&gt;&lt;a href=&quot;../io/basic_istream&quot;&gt;std::basic_istream&lt;/a&gt;&lt;/code&gt; object for which it was constructed, by calling the appropriate &lt;code&gt;operator&amp;gt;&amp;gt;&lt;/code&gt;. The actual read operation is performed when the iterator is incremented, not when it is dereferenced. The first object is read when the iterator is constructed. Dereferencing only returns a copy of the most recently read object.</source>
          <target state="translated">&lt;code&gt;std::istream_iterator&lt;/code&gt; является однопроходным входным итератором, который считывает последовательные объекты типа &lt;code&gt;T&lt;/code&gt; из объекта &lt;code&gt;&lt;a href=&quot;../io/basic_istream&quot;&gt;std::basic_istream&lt;/a&gt;&lt;/code&gt; для которого он был создан, путем вызова соответствующего &lt;code&gt;operator&amp;gt;&amp;gt;&lt;/code&gt; . Фактическая операция чтения выполняется при увеличении итератора, а не при разыменовании. Первый объект читается при создании итератора. Разыменование возвращает только копию последнего прочитанного объекта.</target>
        </trans-unit>
        <trans-unit id="9cbfd53846c23724a1c027d6e2f38dde642ad5df" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::istreambuf_iterator&lt;/code&gt; has a trivial copy constructor, a constexpr default constructor, and a trivial destructor.</source>
          <target state="translated">&lt;code&gt;std::istreambuf_iterator&lt;/code&gt; имеет тривиальный конструктор копирования, конструктор по умолчанию для constexpr и тривиальный деструктор.</target>
        </trans-unit>
        <trans-unit id="69bcfd3a6166f9c6c392b5e7165bc3ea05cee29d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::istreambuf_iterator&lt;/code&gt; is a single-pass input iterator that reads successive characters from the &lt;code&gt;&lt;a href=&quot;../io/basic_streambuf&quot;&gt;std::basic_streambuf&lt;/a&gt;&lt;/code&gt; object for which it was constructed.</source>
          <target state="translated">&lt;code&gt;std::istreambuf_iterator&lt;/code&gt; - это однопроходный входной итератор, который считывает последовательные символы из объекта &lt;code&gt;&lt;a href=&quot;../io/basic_streambuf&quot;&gt;std::basic_streambuf&lt;/a&gt;&lt;/code&gt; для которого он был создан .</target>
        </trans-unit>
        <trans-unit id="9aa098edcf5248bd33724b3a40884863ecff491f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::iswdigit&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;iswxdigit&quot;&gt;std::iswxdigit&lt;/a&gt;&lt;/code&gt; are the only standard wide character classification functions that are not affected by the currently installed C locale.</source>
          <target state="translated">&lt;code&gt;std::iswdigit&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;iswxdigit&quot;&gt;std::iswxdigit&lt;/a&gt;&lt;/code&gt; являются единственными стандартными функциями классификации широких символов, на которые не влияет установленный в настоящее время языковой стандарт C.</target>
        </trans-unit>
        <trans-unit id="7cfa97d219e1324e07edaccefe8988d5dccc17b1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::iterator&lt;/code&gt; is the base class provided to simplify definitions of the required types for iterators.</source>
          <target state="translated">&lt;code&gt;std::iterator&lt;/code&gt; является базовым классом, предоставленным для упрощения определений необходимых типов для итераторов.</target>
        </trans-unit>
        <trans-unit id="b7042ea0b4cf46ee11c1e2aad8beb6aaeece852a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::iterator_traits&amp;lt;BidirIt&amp;gt;::value_type*&lt;/code&gt; and &lt;code&gt;std::sub_match&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;std::iterator_traits&amp;lt;BidirIt&amp;gt;::value_type*&lt;/code&gt; и &lt;code&gt;std::sub_match&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b55313b2cef60e74e0c2c5ed04471f86f95bff4e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::iterator_traits&amp;lt;BidirIt&amp;gt;::value_type&lt;/code&gt; and &lt;code&gt;std::sub_match&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;std::iterator_traits&amp;lt;BidirIt&amp;gt;::value_type&lt;/code&gt; и &lt;code&gt;std::sub_match&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="73e0d90f769db9ddd2bc286113fc7c3922356c42" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::iterator_traits&lt;/code&gt; is the type trait class that provides uniform interface to the properties of &lt;a href=&quot;../named_req/iterator&quot;&gt;LegacyIterator&lt;/a&gt; types. This makes it possible to implement algorithms only in terms of iterators.</source>
          <target state="translated">&lt;code&gt;std::iterator_traits&lt;/code&gt; - это класс свойств типа, который обеспечивает единый интерфейс со свойствами типов &lt;a href=&quot;../named_req/iterator&quot;&gt;LegacyIterator&lt;/a&gt; . Это позволяет реализовывать алгоритмы только в терминах итераторов.</target>
        </trans-unit>
        <trans-unit id="62067c7c19b742e9f2f87539809741fc87924de4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::launder&lt;/code&gt; has no effect on its argument. Its return value must be used to access the object. Thus, it's always an error to discard the return value.</source>
          <target state="translated">&lt;code&gt;std::launder&lt;/code&gt; не влияет на его аргумент. Его возвращаемое значение должно использоваться для доступа к объекту. Таким образом, всегда сбрасывать возвращаемое значение - ошибка.</target>
        </trans-unit>
        <trans-unit id="a6fd8f68c4429333d078e5364ffa87742fef95c9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::launder&lt;/code&gt; may be used in a &lt;a href=&quot;../language/constant_expression&quot;&gt;core constant expression&lt;/a&gt; if the value of its argument may be used in a core constant expression.</source>
          <target state="translated">&lt;code&gt;std::launder&lt;/code&gt; может использоваться в &lt;a href=&quot;../language/constant_expression&quot;&gt;выражении основной константы,&lt;/a&gt; если значение его аргумента может использоваться в выражении основной константы.</target>
        </trans-unit>
        <trans-unit id="fc0400f4a420bf2d62df57d158e61abc76eca486" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::list&amp;lt;T, A&amp;gt;&lt;/code&gt; allocates nodes of some internal type &lt;code&gt;Node&amp;lt;T&amp;gt;&lt;/code&gt;, using the allocator &lt;code&gt;&lt;a href=&quot;allocator_traits&quot;&gt;std::allocator_traits&lt;/a&gt;&amp;lt;A&amp;gt;::rebind_alloc&amp;lt;Node&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt;, which is implemented in terms of &lt;code&gt;A::rebind&amp;lt;Node&amp;lt;T&amp;gt;&amp;gt;::other&lt;/code&gt; if A is an &lt;code&gt;std::allocator&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;std::list&amp;lt;T, A&amp;gt;&lt;/code&gt; выделяет узлы некоторого внутреннего типа &lt;code&gt;Node&amp;lt;T&amp;gt;&lt;/code&gt; , используя распределитель &lt;code&gt;&lt;a href=&quot;allocator_traits&quot;&gt;std::allocator_traits&lt;/a&gt;&amp;lt;A&amp;gt;::rebind_alloc&amp;lt;Node&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; , который реализован в терминах &lt;code&gt;A::rebind&amp;lt;Node&amp;lt;T&amp;gt;&amp;gt;::other&lt;/code&gt; если A является &lt;code&gt;std::allocator&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="66722744970a911306b103b6b3a4bb83fa74da8e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::list&amp;lt;T, A&amp;gt;&lt;/code&gt; allocates nodes of some internal type &lt;code&gt;Node&amp;lt;T&amp;gt;&lt;/code&gt;, using the allocator &lt;code&gt;A::rebind&amp;lt;Node&amp;lt;T&amp;gt;&amp;gt;::other&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;std::list&amp;lt;T, A&amp;gt;&lt;/code&gt; выделяет узлы некоторого внутреннего типа &lt;code&gt;Node&amp;lt;T&amp;gt;&lt;/code&gt; , используя распределитель &lt;code&gt;A::rebind&amp;lt;Node&amp;lt;T&amp;gt;&amp;gt;::other&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c15f65983fc9b680377c222e85dac10cf4ab4144" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::list&lt;/code&gt; is a container that supports constant time insertion and removal of elements from anywhere in the container. Fast random access is not supported. It is usually implemented as a doubly-linked list. Compared to &lt;code&gt;&lt;a href=&quot;forward_list&quot;&gt;std::forward_list&lt;/a&gt;&lt;/code&gt; this container provides bidirectional iteration capability while being less space efficient.</source>
          <target state="translated">&lt;code&gt;std::list&lt;/code&gt; - это контейнер, который поддерживает постоянное время вставки и удаления элементов из любой точки контейнера. Быстрый произвольный доступ не поддерживается. Обычно он реализуется в виде двусвязного списка. По сравнению с &lt;code&gt;&lt;a href=&quot;forward_list&quot;&gt;std::forward_list&lt;/a&gt;&lt;/code&gt; этот контейнер обеспечивает возможность двунаправленной итерации, но при этом занимает меньше места.</target>
        </trans-unit>
        <trans-unit id="0b4e21027fec7854716699e00372b2255194f58b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::list&lt;/code&gt; meets the requirements of &lt;a href=&quot;../named_req/container&quot;&gt;Container&lt;/a&gt;, &lt;a href=&quot;../named_req/allocatorawarecontainer&quot;&gt;AllocatorAwareContainer&lt;/a&gt;, &lt;a href=&quot;../named_req/sequencecontainer&quot;&gt;SequenceContainer&lt;/a&gt; and &lt;a href=&quot;../named_req/reversiblecontainer&quot;&gt;ReversibleContainer&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;std::list&lt;/code&gt; отвечает требованиям &lt;a href=&quot;../named_req/container&quot;&gt;Контейнера&lt;/a&gt; , &lt;a href=&quot;../named_req/allocatorawarecontainer&quot;&gt;AllocatorAwareContainer&lt;/a&gt; , &lt;a href=&quot;../named_req/sequencecontainer&quot;&gt;SequenceContainer&lt;/a&gt; и &lt;a href=&quot;../named_req/reversiblecontainer&quot;&gt;ReversibleContainer&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="39480e048d13612808ce9e8bdf46a4d2d1efff1b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::locale::facet&lt;/code&gt; is the base class for facets. It provides a common base class so that locales could store pointers to the facets they implement in a single indexed container, and it abstracts support for facet reference counting. Whenever a facet is added to a locale, the locale increments the reference count in the facet (through an implementation-specific mechanism). Whenever a locale is destructed or modified, it decrements the reference count in each facet it no longer implements. Whenever a facet's reference count becomes zero, the locale performs &lt;code&gt;delete static_cast&amp;lt;std::locale::facet*&amp;gt;(f)&lt;/code&gt; where &lt;code&gt;f&lt;/code&gt; is the pointer to the facet.</source>
          <target state="translated">&lt;code&gt;std::locale::facet&lt;/code&gt; является базовым классом для фасетов. Он предоставляет общий базовый класс, чтобы локали могли хранить указатели на фасеты, которые они реализуют, в одном индексированном контейнере, и абстрагирует поддержку подсчета ссылок на фасеты. Всякий раз, когда фасет добавляется в локаль, локаль увеличивает счетчик ссылок в фасете (через механизм реализации). Всякий раз, когда языковой стандарт разрушается или изменяется, он уменьшает счетчик ссылок в каждом аспекте, который он больше не реализует. Всякий раз, когда счетчик ссылок фасета становится равным нулю, локаль выполняет &lt;code&gt;delete static_cast&amp;lt;std::locale::facet*&amp;gt;(f)&lt;/code&gt; где &lt;code&gt;f&lt;/code&gt; - указатель на фасет.</target>
        </trans-unit>
        <trans-unit id="25f4c47baf2c706d9502a2677329ad5ff357de25" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::localeconv&lt;/code&gt; modifies a static object, calling it from different threads without synchronization is undefined behavior.</source>
          <target state="translated">&lt;code&gt;std::localeconv&lt;/code&gt; изменяет статический объект, вызывая его из разных потоков без синхронизации, это неопределенное поведение.</target>
        </trans-unit>
        <trans-unit id="17fcade94977b46d0779598ca948f02a54971ac1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::lognormal_distribution&lt;/code&gt; satisfies all requirements of &lt;a href=&quot;../../named_req/randomnumberdistribution&quot;&gt;RandomNumberDistribution&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;std::lognormal_distribution&lt;/code&gt; удовлетворяет всем требованиям &lt;a href=&quot;../../named_req/randomnumberdistribution&quot;&gt;RandomNumberDistribution&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="36ea267312e8c2f25e5b22940ec75bd0844adcad" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::make_shared&lt;/code&gt; uses &lt;code&gt;::new&lt;/code&gt;, so if any special behavior has been set up using a class-specific &lt;a href=&quot;../new/operator_new&quot;&gt;&lt;code&gt;operator new&lt;/code&gt;&lt;/a&gt;, it will differ from &lt;code&gt;&lt;a href=&quot;../shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&amp;lt;T&amp;gt;(new T(args...))&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;std::make_shared&lt;/code&gt; использует &lt;code&gt;::new&lt;/code&gt; , поэтому, если какое-либо специальное поведение было настроено с использованием оператора класса, &lt;a href=&quot;../new/operator_new&quot;&gt; &lt;code&gt;operator new&lt;/code&gt; &lt;/a&gt; , оно будет отличаться от &lt;code&gt;&lt;a href=&quot;../shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&amp;lt;T&amp;gt;(new T(args...))&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b24879d26d53111bc2ca5c76cc8a905a3eaaf320" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::map::value_compare&lt;/code&gt; is a function object that compares objects of type &lt;code&gt;std::map::value_type&lt;/code&gt; (key-value pairs) by comparing of the first components of the pairs.</source>
          <target state="translated">&lt;code&gt;std::map::value_compare&lt;/code&gt; - это функциональный объект, который сравнивает объекты типа &lt;code&gt;std::map::value_type&lt;/code&gt; (пары ключ-значение) путем сравнения первых компонентов пар.</target>
        </trans-unit>
        <trans-unit id="69b03e94f70798f70251e093522baf56a3c25fde" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::map&lt;/code&gt; is a sorted associative container that contains key-value pairs with unique keys. Keys are sorted by using the comparison function &lt;code&gt;Compare&lt;/code&gt;. Search, removal, and insertion operations have logarithmic complexity. Maps are usually implemented as &lt;a href=&quot;https://en.wikipedia.org/wiki/Red%E2%80%93black_tree&quot;&gt;red-black trees&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;std::map&lt;/code&gt; - это отсортированный ассоциативный контейнер, содержащий пары ключ-значение с уникальными ключами. Ключи отсортированы с помощью функции сравнения &lt;code&gt;Compare&lt;/code&gt; . Операции поиска, удаления и вставки имеют логарифмическую сложность. Карты обычно реализованы в виде &lt;a href=&quot;https://en.wikipedia.org/wiki/Red%E2%80%93black_tree&quot;&gt;красно-черных деревьев&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f9b8c058371534a10bf6f6f1cfb81ee79141b674" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::map&lt;/code&gt; meets the requirements of &lt;a href=&quot;../named_req/container&quot;&gt;Container&lt;/a&gt;, &lt;a href=&quot;../named_req/allocatorawarecontainer&quot;&gt;AllocatorAwareContainer&lt;/a&gt;, &lt;a href=&quot;../named_req/associativecontainer&quot;&gt;AssociativeContainer&lt;/a&gt; and &lt;a href=&quot;../named_req/reversiblecontainer&quot;&gt;ReversibleContainer&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;std::map&lt;/code&gt; отвечает требованиям &lt;a href=&quot;../named_req/container&quot;&gt;Контейнера&lt;/a&gt; , &lt;a href=&quot;../named_req/allocatorawarecontainer&quot;&gt;AllocatorAwareContainer&lt;/a&gt; , &lt;a href=&quot;../named_req/associativecontainer&quot;&gt;AssociativeContainer&lt;/a&gt; и &lt;a href=&quot;../named_req/reversiblecontainer&quot;&gt;ReversibleContainer&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="84be1b95a94a0df278624077a9bf062e43144c11" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::mask_array&lt;/code&gt; is a helper template used by the &lt;a href=&quot;operator_at&quot;&gt;valarray subscript operator&lt;/a&gt; with &lt;code&gt;std::valarray&amp;lt;bool&amp;gt;&lt;/code&gt; argument. It has reference semantics and provides access to the subset of the valarray consisting of the elements whose indices correspond to &lt;code&gt;true&lt;/code&gt; values in the &lt;code&gt;&lt;a href=&quot;../valarray&quot;&gt;std::valarray&lt;/a&gt;&amp;lt;bool&amp;gt;&lt;/code&gt; mask.</source>
          <target state="translated">&lt;code&gt;std::mask_array&lt;/code&gt; - это вспомогательный шаблон, используемый оператором &lt;a href=&quot;operator_at&quot;&gt;нижнего индекса valarray&lt;/a&gt; с аргументом &lt;code&gt;std::valarray&amp;lt;bool&amp;gt;&lt;/code&gt; . Он имеет ссылочную семантику и предоставляет доступ к подмножеству valarray, состоящему из элементов, индексы которых соответствуют &lt;code&gt;true&lt;/code&gt; значениям в маске &lt;code&gt;&lt;a href=&quot;../valarray&quot;&gt;std::valarray&lt;/a&gt;&amp;lt;bool&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f1ba44ed66d1e1555c21ea7a3d7af56fb9452ba4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::match_results&lt;/code&gt; meets the requirements of a &lt;a href=&quot;../named_req/allocatorawarecontainer&quot;&gt;AllocatorAwareContainer&lt;/a&gt; and of a &lt;a href=&quot;../named_req/sequencecontainer&quot;&gt;SequenceContainer&lt;/a&gt;, except that only copy assignment, move assignment, and operations defined for a constant containers are supported, and that the semantics of comparison functions are different from those required for a container.</source>
          <target state="translated">&lt;code&gt;std::match_results&lt;/code&gt; соответствует требованиям &lt;a href=&quot;../named_req/allocatorawarecontainer&quot;&gt;AllocatorAwareContainer&lt;/a&gt; и &lt;a href=&quot;../named_req/sequencecontainer&quot;&gt;SequenceContainer&lt;/a&gt; , за исключением того, что поддерживаются только назначение копирования, перемещение перемещения и операции, определенные для постоянных контейнеров, и что семантика функций сравнения отличается от требуемой для контейнера.</target>
        </trans-unit>
        <trans-unit id="486be6c729cd8f9005df324c3f9cee7e87d5dd71" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::max_align_t&lt;/code&gt; is a &lt;a href=&quot;../named_req/trivialtype&quot;&gt;trivial&lt;/a&gt;&lt;a href=&quot;../named_req/standardlayouttype&quot;&gt;standard-layout&lt;/a&gt; type whose &lt;a href=&quot;../language/objects#Alignment&quot;&gt;alignment requirement&lt;/a&gt; is at least as strict (as large) as that of every scalar type.</source>
          <target state="translated">&lt;code&gt;std::max_align_t&lt;/code&gt; - это &lt;a href=&quot;../named_req/trivialtype&quot;&gt;тривиальный&lt;/a&gt; тип &lt;a href=&quot;../named_req/standardlayouttype&quot;&gt;стандартного макета&lt;/a&gt; , &lt;a href=&quot;../language/objects#Alignment&quot;&gt;требования к выравниванию&lt;/a&gt; которого, по крайней мере, такие же строгие (такие же большие), как и требования для каждого скалярного типа.</target>
        </trans-unit>
        <trans-unit id="de74cc16225bf11bc2936dc0ea5016c64a73d87a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::max_align_t&lt;/code&gt; is usually synonymous with the largest scalar type, which is &lt;code&gt;long double&lt;/code&gt; on most platforms, and its alignment requirement is either 8 or 16.</source>
          <target state="translated">&lt;code&gt;std::max_align_t&lt;/code&gt; обычно синонимичен с наибольшим скалярным типом, который на большинстве платформ &lt;code&gt;long double&lt;/code&gt; , и его требование выравнивания составляет 8 или 16.</target>
        </trans-unit>
        <trans-unit id="250616309b32d57f9c4f54607c0d6adeac132d82" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::mem_fn&lt;/code&gt; returns a call wrapper of unspecified type that has the following members:</source>
          <target state="translated">&lt;code&gt;std::mem_fn&lt;/code&gt; возвращает упаковщик вызовов неопределенного типа, который имеет следующие члены:</target>
        </trans-unit>
        <trans-unit id="019539277e675b31ee3787a2ae6f6741a1f927c8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::memcpy&lt;/code&gt; is meant to be the fastest library routine for memory-to-memory copy. It is usually more efficient than &lt;code&gt;&lt;a href=&quot;strcpy&quot;&gt;std::strcpy&lt;/a&gt;&lt;/code&gt;, which must scan the data it copies or &lt;code&gt;&lt;a href=&quot;memmove&quot;&gt;std::memmove&lt;/a&gt;&lt;/code&gt;, which must take precautions to handle overlapping inputs.</source>
          <target state="translated">&lt;code&gt;std::memcpy&lt;/code&gt; должен быть самой быстрой библиотечной подпрограммой для копирования из памяти в память. Обычно он более эффективен, чем &lt;code&gt;&lt;a href=&quot;strcpy&quot;&gt;std::strcpy&lt;/a&gt;&lt;/code&gt; , который должен сканировать данные, которые он копирует, или &lt;code&gt;&lt;a href=&quot;memmove&quot;&gt;std::memmove&lt;/a&gt;&lt;/code&gt; , который должен принимать меры предосторожности для обработки перекрывающихся входных данных.</target>
        </trans-unit>
        <trans-unit id="2118ff9fcca45263d25b203070d19f43992cc2ee" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::memory_order&lt;/code&gt; specifies how memory accesses, including regular, non-atomic memory accesses, are to be ordered around an atomic operation. Absent any constraints on a multi-core system, when multiple threads simultaneously read and write to several variables, one thread can observe the values change in an order different from the order another thread wrote them. Indeed, the apparent order of changes can even differ among multiple reader threads. Some similar effects can occur even on uniprocessor systems due to compiler transformations allowed by the memory model.</source>
          <target state="translated">&lt;code&gt;std::memory_order&lt;/code&gt; указывает, как обращения к памяти, включая обычные неатомарные обращения к памяти, должны быть упорядочены вокруг атомарной операции. При отсутствии каких-либо ограничений в многоядерной системе, когда несколько потоков одновременно читают и записывают несколько переменных, один поток может наблюдать изменение значений в порядке, отличном от порядка, в котором их написал другой поток. Действительно, видимый порядок изменений может даже различаться в разных потоках читателей. Некоторые подобные эффекты могут возникать даже в однопроцессорных системах из-за преобразований компилятора, допускаемых моделью памяти.</target>
        </trans-unit>
        <trans-unit id="3a7564b150268b029471f79e561f7972a4703c6f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::memset&lt;/code&gt; may be optimized away (under the &lt;a href=&quot;../../language/as_if&quot;&gt;as-if&lt;/a&gt; rules) if the object modified by this function is not accessed again for the rest of its lifetime (e.g. &lt;a href=&quot;https://gcc.gnu.org/bugzilla/show_bug.cgi?id=8537&quot;&gt;gcc bug 8537&lt;/a&gt;). For that reason, this function cannot be used to scrub memory (e.g. to fill an array that stored a password with zeroes). Solutions for that include &lt;a href=&quot;../../algorithm/fill&quot;&gt;&lt;code&gt;std::fill&lt;/code&gt;&lt;/a&gt; with volatile pointers, C11 &lt;a href=&quot;http://en.cppreference.com/w/c/string/byte/memset.html&quot;&gt;&lt;code&gt;memset_s&lt;/code&gt;&lt;/a&gt;, FreeBSD &lt;a href=&quot;https://www.freebsd.org/cgi/man.cgi?query=explicit_bzero&quot;&gt;explicit_bzero&lt;/a&gt; or Microsoft &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/windows/desktop/aa366877.aspx&quot;&gt;SecureZeroMemory&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;std::memset&lt;/code&gt; может быть оптимизирован (согласно правилам &amp;laquo; &lt;a href=&quot;../../language/as_if&quot;&gt;как будто&amp;raquo;&lt;/a&gt; ), если к объекту, измененному этой функцией, снова нет доступа в течение оставшейся части его времени жизни (например, &lt;a href=&quot;https://gcc.gnu.org/bugzilla/show_bug.cgi?id=8537&quot;&gt;ошибка gcc 8537&lt;/a&gt; ). По этой причине эту функцию нельзя использовать для очистки памяти (например, для заполнения массива, в котором хранится пароль, нулями). Решения для этого включают &lt;a href=&quot;../../algorithm/fill&quot;&gt; &lt;code&gt;std::fill&lt;/code&gt; &lt;/a&gt; с летучими указателями, С11 &lt;a href=&quot;http://en.cppreference.com/w/c/string/byte/memset.html&quot;&gt; &lt;code&gt;memset_s&lt;/code&gt; &lt;/a&gt; , FreeBSD &lt;a href=&quot;https://www.freebsd.org/cgi/man.cgi?query=explicit_bzero&quot;&gt;explicit_bzero&lt;/a&gt; или Microsoft &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/windows/desktop/aa366877.aspx&quot;&gt;SecureZeroMemory&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="37d85ef2212e37f34c3209150c0bbbf80edfa8c8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::messages_byname&lt;/code&gt; is a &lt;code&gt;&lt;a href=&quot;messages&quot;&gt;std::messages&lt;/a&gt;&lt;/code&gt; facet which encapsulates retrieval of strings from message catalogs of the locale specified at its construction.</source>
          <target state="translated">&lt;code&gt;std::messages_byname&lt;/code&gt; - это фасет &lt;code&gt;&lt;a href=&quot;messages&quot;&gt;std::messages&lt;/a&gt;&lt;/code&gt; который инкапсулирует извлечение строк из каталогов сообщений локали, указанной при его создании.</target>
        </trans-unit>
        <trans-unit id="33c8225db603dfa739b0e05e20477d0f83922789" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::moneypunct_byname&lt;/code&gt; is a &lt;code&gt;&lt;a href=&quot;moneypunct&quot;&gt;std::moneypunct&lt;/a&gt;&lt;/code&gt; facet which encapsulates monetary formatting preferences of a locale specified at its construction.</source>
          <target state="translated">&lt;code&gt;std::moneypunct_byname&lt;/code&gt; - это фасет &lt;code&gt;&lt;a href=&quot;moneypunct&quot;&gt;std::moneypunct&lt;/a&gt;&lt;/code&gt; который инкапсулирует настройки форматирования денежной единицы для локали, указанной при ее построении.</target>
        </trans-unit>
        <trans-unit id="efbca6737e4ba6c8e9dd65c08620ae6de6752df0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::move(x)&lt;/code&gt; or &lt;code&gt;x&lt;/code&gt;, depending on exception guarantees.</source>
          <target state="translated">&lt;code&gt;std::move(x)&lt;/code&gt; или &lt;code&gt;x&lt;/code&gt; , в зависимости от гарантий исключения.</target>
        </trans-unit>
        <trans-unit id="7de0377c2783e738adfca256a11f333e74b0abef" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::move&lt;/code&gt; is used to</source>
          <target state="translated">&lt;code&gt;std::move&lt;/code&gt; используется для</target>
        </trans-unit>
        <trans-unit id="57df1e08f7a50f846a44df6e8661f68fa099d33f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::move_iterator&lt;/code&gt; is an iterator adaptor which behaves exactly like the underlying iterator (which must be at least an &lt;a href=&quot;../named_req/inputiterator&quot;&gt;LegacyInputIterator&lt;/a&gt;), except that dereferencing converts the value returned by the underlying iterator into an rvalue. If this iterator is used as an input iterator, the effect is that the values are moved from, rather than copied from.</source>
          <target state="translated">&lt;code&gt;std::move_iterator&lt;/code&gt; - это адаптер итератора, который ведет себя точно так же, как базовый итератор (который должен быть как минимум &lt;a href=&quot;../named_req/inputiterator&quot;&gt;LegacyInputIterator&lt;/a&gt; ), за исключением того, что разыменование преобразует значение, возвращаемое базовым итератором, в значение r. Если этот итератор используется в качестве входного итератора, эффект состоит в том, что значения перемещаются, а не копируются из.</target>
        </trans-unit>
        <trans-unit id="b9911341852a0dfa39ac8efe01699ab44e9ef543" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::multimap::value_compare&lt;/code&gt; is a function object that compares objects of type &lt;code&gt;std::multimap::value_type&lt;/code&gt; (key-value pairs) by comparing of the first components of the pairs.</source>
          <target state="translated">&lt;code&gt;std::multimap::value_compare&lt;/code&gt; - это функциональный объект, который сравнивает объекты типа &lt;code&gt;std::multimap::value_type&lt;/code&gt; (пары ключ-значение) путем сравнения первых компонентов пар.</target>
        </trans-unit>
        <trans-unit id="96ab8f5decbb67bb55ce6193967b8c257928ef8d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::multimap&lt;/code&gt; meets the requirements of &lt;a href=&quot;../named_req/container&quot;&gt;Container&lt;/a&gt;, &lt;a href=&quot;../named_req/allocatorawarecontainer&quot;&gt;AllocatorAwareContainer&lt;/a&gt;, &lt;a href=&quot;../named_req/associativecontainer&quot;&gt;AssociativeContainer&lt;/a&gt; and &lt;a href=&quot;../named_req/reversiblecontainer&quot;&gt;ReversibleContainer&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;std::multimap&lt;/code&gt; отвечает требованиям &lt;a href=&quot;../named_req/container&quot;&gt;Контейнера&lt;/a&gt; , &lt;a href=&quot;../named_req/allocatorawarecontainer&quot;&gt;AllocatorAwareContainer&lt;/a&gt; , &lt;a href=&quot;../named_req/associativecontainer&quot;&gt;AssociativeContainer&lt;/a&gt; и &lt;a href=&quot;../named_req/reversiblecontainer&quot;&gt;ReversibleContainer&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9f752bf59adb24e8616e43fbea77f42838db6858" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::multiset&lt;/code&gt; is an associative container that contains a sorted set of objects of type Key. Unlike set, multiple keys with equivalent values are allowed. Sorting is done using the key comparison function Compare. Search, insertion, and removal operations have logarithmic complexity.</source>
          <target state="translated">&lt;code&gt;std::multiset&lt;/code&gt; - это ассоциативный контейнер, содержащий отсортированный набор объектов типа Key. В отличие от set, допускается использование нескольких ключей с эквивалентными значениями. Сортировка выполняется с помощью функции сравнения ключей Compare. Операции поиска, вставки и удаления имеют логарифмическую сложность.</target>
        </trans-unit>
        <trans-unit id="086e94514b0cdda6b7633c56cf601a40382a11cb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::multiset&lt;/code&gt; meets the requirements of &lt;a href=&quot;../named_req/container&quot;&gt;Container&lt;/a&gt;, &lt;a href=&quot;../named_req/allocatorawarecontainer&quot;&gt;AllocatorAwareContainer&lt;/a&gt;, &lt;a href=&quot;../named_req/associativecontainer&quot;&gt;AssociativeContainer&lt;/a&gt; and &lt;a href=&quot;../named_req/reversiblecontainer&quot;&gt;ReversibleContainer&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;std::multiset&lt;/code&gt; отвечает требованиям &lt;a href=&quot;../named_req/container&quot;&gt;Контейнера&lt;/a&gt; , &lt;a href=&quot;../named_req/allocatorawarecontainer&quot;&gt;AllocatorAwareContainer&lt;/a&gt; , &lt;a href=&quot;../named_req/associativecontainer&quot;&gt;AssociativeContainer&lt;/a&gt; и &lt;a href=&quot;../named_req/reversiblecontainer&quot;&gt;ReversibleContainer&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e96493daf69bb9a9ead26df58b81f61e6c62e6ea" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::mutex&lt;/code&gt; is neither copyable nor movable.</source>
          <target state="translated">&lt;code&gt;std::mutex&lt;/code&gt; является ни копируемым, ни подвижным.</target>
        </trans-unit>
        <trans-unit id="05b0d7c6eb2399ec5b7b4c3e31db6b51b12be1c0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::mutex&lt;/code&gt; is usually not accessed directly: &lt;code&gt;&lt;a href=&quot;unique_lock&quot;&gt;std::unique_lock&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;lock_guard&quot;&gt;std::lock_guard&lt;/a&gt;&lt;/code&gt;,  or &lt;code&gt;std::scoped_lock&lt;/code&gt;(since C++17) manage locking in a more exception-safe manner.</source>
          <target state="translated">&lt;code&gt;std::mutex&lt;/code&gt; Доступ к std :: mutex обычно не осуществляется напрямую: &lt;code&gt;&lt;a href=&quot;unique_lock&quot;&gt;std::unique_lock&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;lock_guard&quot;&gt;std::lock_guard&lt;/a&gt;&lt;/code&gt; или &lt;code&gt;std::scoped_lock&lt;/code&gt; (начиная с C ++ 17) управляют блокировкой более безопасным способом исключения.</target>
        </trans-unit>
        <trans-unit id="cc0d7eecfb40eeab627189c04ee7371985b6d0d7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::negative_binomial_distribution&lt;/code&gt; satisfies &lt;a href=&quot;../../named_req/randomnumberdistribution&quot;&gt;RandomNumberDistribution&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;std::negative_binomial_distribution&lt;/code&gt; &lt;a href=&quot;../../named_req/randomnumberdistribution&quot;&gt;positive_binomial_distribution&lt;/a&gt; удовлетворяет RandomNumberDistribution .</target>
        </trans-unit>
        <trans-unit id="356015a256f665f8a44e6d1e549d4cef107b40ba" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::nested_exception&lt;/code&gt; is a polymorphic mixin class which can capture and store the current exception, making it possible to nest exceptions of arbitrary types within each other.</source>
          <target state="translated">&lt;code&gt;std::nested_exception&lt;/code&gt; - это полиморфный класс mixin, который может захватывать и хранить текущее исключение, позволяя вкладывать исключения произвольных типов друг в друга.</target>
        </trans-unit>
        <trans-unit id="9714f66f30044372b37d250de64fe0d3c1071a2f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::new_handler&lt;/code&gt; is the function pointer type (pointer to function that takes no arguments and returns void), which is used by the functions &lt;code&gt;&lt;a href=&quot;set_new_handler&quot;&gt;std::set_new_handler&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;get_new_handler&quot;&gt;std::get_new_handler&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;std::new_handler&lt;/code&gt; - это тип указателя на функцию (указатель на функцию, которая не принимает аргументов и возвращает void), который используется функциями &lt;code&gt;&lt;a href=&quot;set_new_handler&quot;&gt;std::set_new_handler&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;get_new_handler&quot;&gt;std::get_new_handler&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a851774dbb169de3b43d1480564d86976d5d760a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::normal_distribution&lt;/code&gt; satisfies all requirements of &lt;a href=&quot;../../named_req/randomnumberdistribution&quot;&gt;RandomNumberDistribution&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;std::normal_distribution&lt;/code&gt; удовлетворяет всем требованиям &lt;a href=&quot;../../named_req/randomnumberdistribution&quot;&gt;RandomNumberDistribution&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6bbdbd6056802e22d2dfcad3cce3c52c0a59507e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::not1&lt;/code&gt; returns an object of type &lt;code&gt;&lt;a href=&quot;unary_negate&quot;&gt;std::unary_negate&lt;/a&gt;&amp;lt;&lt;a href=&quot;../../concepts/predicate&quot;&gt;Predicate&lt;/a&gt;&amp;gt;&lt;/code&gt;, constructed with &lt;code&gt;pred&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;std::not1&lt;/code&gt; возвращает объект типа &lt;code&gt;&lt;a href=&quot;unary_negate&quot;&gt;std::unary_negate&lt;/a&gt;&amp;lt;&lt;a href=&quot;../../concepts/predicate&quot;&gt;Predicate&lt;/a&gt;&amp;gt;&lt;/code&gt; , построенная с &lt;code&gt;pred&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1e7ef35eea64883819b88f9a89de62f625607241" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::not2&lt;/code&gt; returns an object of type &lt;code&gt;&lt;a href=&quot;binary_negate&quot;&gt;std::binary_negate&lt;/a&gt;&amp;lt;&lt;a href=&quot;../../concepts/predicate&quot;&gt;Predicate&lt;/a&gt;&amp;gt;&lt;/code&gt;, constructed with &lt;code&gt;pred&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;std::not2&lt;/code&gt; возвращает объект типа &lt;code&gt;&lt;a href=&quot;binary_negate&quot;&gt;std::binary_negate&lt;/a&gt;&amp;lt;&lt;a href=&quot;../../concepts/predicate&quot;&gt;Predicate&lt;/a&gt;&amp;gt;&lt;/code&gt; , построенная с &lt;code&gt;pred&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f70f4db2af2af44f2a7ba7b47013286ed6c35fb8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::nothrow&lt;/code&gt; is a constant of type &lt;code&gt;&lt;a href=&quot;nothrow_t&quot;&gt;std::nothrow_t&lt;/a&gt;&lt;/code&gt; used to disambiguate the overloads of throwing and non-throwing &lt;a href=&quot;operator_new&quot;&gt;allocation functions&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;std::nothrow&lt;/code&gt; является константой типа &lt;code&gt;&lt;a href=&quot;nothrow_t&quot;&gt;std::nothrow_t&lt;/a&gt;&lt;/code&gt; используемой для устранения неоднозначности перегрузок &lt;a href=&quot;operator_new&quot;&gt;функций выделения с &lt;/a&gt;одноразовым и не бросающим действием .</target>
        </trans-unit>
        <trans-unit id="7cda3e5771a651d7ac8313fe2f3aa00ac56c2106" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::nothrow_t&lt;/code&gt; is an empty class type used to disambiguate the overloads of throwing and non-throwing &lt;a href=&quot;operator_new&quot;&gt;allocation functions&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;std::nothrow_t&lt;/code&gt; является пустым типом класса, используемым для устранения неоднозначности перегрузок &lt;a href=&quot;operator_new&quot;&gt;функций выделения &lt;/a&gt;одноразовых и не-одноразовых .</target>
        </trans-unit>
        <trans-unit id="85ab32f61c86e1fe107572929e50efe8ee81c122" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::nullopt&lt;/code&gt; is a constant of type &lt;code&gt;&lt;a href=&quot;nullopt_t&quot;&gt;std::nullopt_t&lt;/a&gt;&lt;/code&gt; that is used to indicate &lt;code&gt;optional&lt;/code&gt; type with uninitialized state.</source>
          <target state="translated">&lt;code&gt;std::nullopt&lt;/code&gt; является константой типа &lt;code&gt;&lt;a href=&quot;nullopt_t&quot;&gt;std::nullopt_t&lt;/a&gt;&lt;/code&gt; которая используется для указания &lt;code&gt;optional&lt;/code&gt; типа с неинициализированным состоянием.</target>
        </trans-unit>
        <trans-unit id="02049de6eda615290c2b319f76d165fe688eb7d3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::nullopt_t&lt;/code&gt; is an empty class type used to indicate &lt;code&gt;optional&lt;/code&gt; type with uninitialized state. In particular, &lt;code&gt;&lt;a href=&quot;../optional&quot;&gt;std::optional&lt;/a&gt;&lt;/code&gt; has a constructor with &lt;code&gt;nullopt_t&lt;/code&gt; as a single argument, which creates an optional that does not contain a value.</source>
          <target state="translated">&lt;code&gt;std::nullopt_t&lt;/code&gt; - это пустой тип класса, используемый для указания &lt;code&gt;optional&lt;/code&gt; типа с неинициализированным состоянием. В частности, &lt;code&gt;&lt;a href=&quot;../optional&quot;&gt;std::optional&lt;/a&gt;&lt;/code&gt; &lt;code&gt;nullopt_t&lt;/code&gt; имеет конструктор с nullopt_t в качестве единственного аргумента, который создает необязательный аргумент, не содержащий значения.</target>
        </trans-unit>
        <trans-unit id="3f1013d2e1cbbed3314f41f8281dd0590dff1883" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::nullopt_t&lt;/code&gt; must be a non-aggregate &lt;a href=&quot;../../named_req/literaltype&quot;&gt;LiteralType&lt;/a&gt; and cannot have a default constructor or an initializer-list constructor.</source>
          <target state="translated">&lt;code&gt;std::nullopt_t&lt;/code&gt; должен быть неагрегированным &lt;a href=&quot;../../named_req/literaltype&quot;&gt;LiteralType&lt;/a&gt; и не может иметь конструктор по умолчанию или конструктор списка инициализатора.</target>
        </trans-unit>
        <trans-unit id="bfbb1c354a43470e1d88908e8209e04392aa55ad" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::nullptr_t&lt;/code&gt; is the type of the null pointer literal, &lt;a href=&quot;../language/nullptr&quot;&gt;&lt;code&gt;nullptr&lt;/code&gt;&lt;/a&gt;. It is a distinct type that is not itself a pointer type or a pointer to member type.</source>
          <target state="translated">&lt;code&gt;std::nullptr_t&lt;/code&gt; - это тип литерала нулевого указателя, &lt;a href=&quot;../language/nullptr&quot;&gt; &lt;code&gt;nullptr&lt;/code&gt; &lt;/a&gt; . Это отдельный тип, который сам по себе не является типом указателя или указателем на тип члена.</target>
        </trans-unit>
        <trans-unit id="e2e770b2f25bf1be459bc0ab1b7aa9828614268d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::numpunct_byname&lt;/code&gt; is a &lt;code&gt;&lt;a href=&quot;numpunct&quot;&gt;std::numpunct&lt;/a&gt;&lt;/code&gt; facet which encapsulates numeric punctuation preferences of a locale specified at its construction.</source>
          <target state="translated">&lt;code&gt;std::numpunct_byname&lt;/code&gt; - это фасет &lt;code&gt;&lt;a href=&quot;numpunct&quot;&gt;std::numpunct&lt;/a&gt;&lt;/code&gt; который инкапсулирует предпочтения числовой пунктуации для локали, указанной при ее построении.</target>
        </trans-unit>
        <trans-unit id="c2f1976e55e2fa1e62abc4428973a4a9531f2f1f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::once_flag&lt;/code&gt; is neither copyable nor movable.</source>
          <target state="translated">&lt;code&gt;std::once_flag&lt;/code&gt; не может быть скопирован или перемещен.</target>
        </trans-unit>
        <trans-unit id="dc46da909485bc2d93323c2c6ff124bedb3ce7fb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::ostream_iterator&lt;/code&gt; is a single-pass &lt;a href=&quot;../named_req/outputiterator&quot;&gt;LegacyOutputIterator&lt;/a&gt; that writes successive objects of type &lt;code&gt;T&lt;/code&gt; into the &lt;code&gt;&lt;a href=&quot;../io/basic_ostream&quot;&gt;std::basic_ostream&lt;/a&gt;&lt;/code&gt; object for which it was constructed, using &lt;code&gt;operator&amp;lt;&amp;lt;&lt;/code&gt;. Optional delimiter string is written to the output stream after every write operation. The write operation is performed when the iterator (whether dereferenced or not) is assigned to. Incrementing the &lt;code&gt;std::ostream_iterator&lt;/code&gt; is a no-op.</source>
          <target state="translated">&lt;code&gt;std::ostream_iterator&lt;/code&gt; - однопроходный &lt;a href=&quot;../named_req/outputiterator&quot;&gt;LegacyOutputIterator,&lt;/a&gt; который записывает последовательные объекты типа &lt;code&gt;T&lt;/code&gt; в объект &lt;code&gt;&lt;a href=&quot;../io/basic_ostream&quot;&gt;std::basic_ostream&lt;/a&gt;&lt;/code&gt; для которого он был создан , используя &lt;code&gt;operator&amp;lt;&amp;lt;&lt;/code&gt; . Необязательная строка-разделитель записывается в выходной поток после каждой операции записи. Операция записи выполняется, когда итератору (независимо от того, назначен он или нет) присвоен. Увеличение &lt;code&gt;std::ostream_iterator&lt;/code&gt; не допускается.</target>
        </trans-unit>
        <trans-unit id="777e432c8143a3737cc1c5cb394e70c18a51c20c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::ostreambuf_iterator&lt;/code&gt; is a single-pass &lt;a href=&quot;../named_req/outputiterator&quot;&gt;LegacyOutputIterator&lt;/a&gt; that writes successive characters into the &lt;code&gt;&lt;a href=&quot;../io/basic_streambuf&quot;&gt;std::basic_streambuf&lt;/a&gt;&lt;/code&gt; object for which it was constructed. The actual write operation is performed when the iterator (whether dereferenced or not) is assigned to. Incrementing the &lt;code&gt;std::ostreambuf_iterator&lt;/code&gt; is a no-op.</source>
          <target state="translated">&lt;code&gt;std::ostreambuf_iterator&lt;/code&gt; - это однопроходный &lt;a href=&quot;../named_req/outputiterator&quot;&gt;LegacyOutputIterator,&lt;/a&gt; который записывает последовательные символы в объект &lt;code&gt;&lt;a href=&quot;../io/basic_streambuf&quot;&gt;std::basic_streambuf&lt;/a&gt;&lt;/code&gt; для которого он был создан . Фактическая операция записи выполняется, когда итератору (независимо от того, назначен он или нет) назначен. Приращение в &lt;code&gt;std::ostreambuf_iterator&lt;/code&gt; является не оп.</target>
        </trans-unit>
        <trans-unit id="dc1abd29bb8831f4698cdb1094a6ca7e562e49e5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::pair&lt;/code&gt; is a struct template that provides a way to store two heterogeneous objects as a single unit. A pair is a specific case of a &lt;code&gt;&lt;a href=&quot;tuple&quot;&gt;std::tuple&lt;/a&gt;&lt;/code&gt; with two elements.</source>
          <target state="translated">&lt;code&gt;std::pair&lt;/code&gt; - это шаблон структуры, который обеспечивает способ хранения двух разнородных объектов в виде одного модуля. Пара является частным случаем &lt;code&gt;&lt;a href=&quot;tuple&quot;&gt;std::tuple&lt;/a&gt;&lt;/code&gt; с двумя элементами.</target>
        </trans-unit>
        <trans-unit id="ea8dd13c2816204756416ea997c79ecf7f5dc04b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::partial_ordering::equivalent&lt;/code&gt; if &lt;code&gt;a&lt;/code&gt; is equivalent to &lt;code&gt;b&lt;/code&gt; (&lt;code&gt;-0 &amp;lt;=&amp;gt; +0&lt;/code&gt; is equivalent)</source>
          <target state="translated">&lt;code&gt;std::partial_ordering::equivalent&lt;/code&gt; если &lt;code&gt;a&lt;/code&gt; эквивалентно &lt;code&gt;b&lt;/code&gt; ( &lt;code&gt;-0 &amp;lt;=&amp;gt; +0&lt;/code&gt; эквивалентно)</target>
        </trans-unit>
        <trans-unit id="371bc87e88fad51bc0750025291273ab879059d1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::partial_ordering::greater&lt;/code&gt; if &lt;code&gt;a&lt;/code&gt; is greater than &lt;code&gt;b&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;std::partial_ordering::greater&lt;/code&gt; если &lt;code&gt;a&lt;/code&gt; больше, чем &lt;code&gt;b&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c84a2e8316193f31e89963f9aecf5bee5195fb95" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::partial_ordering::less&lt;/code&gt; if &lt;code&gt;a&lt;/code&gt; is less than &lt;code&gt;b&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;std::partial_ordering::less&lt;/code&gt; если &lt;code&gt;a&lt;/code&gt; меньше, чем &lt;code&gt;b&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="40941de7130d4d5cf67a40eab0dc365768ccaeff" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::partial_ordering::less&lt;/code&gt; if &lt;code&gt;v&lt;/code&gt; is &lt;code&gt;less&lt;/code&gt;, &lt;code&gt;std::partial_ordering::greater&lt;/code&gt; if &lt;code&gt;v&lt;/code&gt; is &lt;code&gt;greater&lt;/code&gt;, &lt;code&gt;std::partial_ordering::equivalent&lt;/code&gt; if &lt;code&gt;v&lt;/code&gt; is &lt;code&gt;equal&lt;/code&gt; or &lt;code&gt;equivalent&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;std::partial_ordering::less&lt;/code&gt; , если &lt;code&gt;v&lt;/code&gt; является &lt;code&gt;less&lt;/code&gt; , &lt;code&gt;std::partial_ordering::greater&lt;/code&gt; если &lt;code&gt;v&lt;/code&gt; является &lt;code&gt;greater&lt;/code&gt; , &lt;code&gt;std::partial_ordering::equivalent&lt;/code&gt; , если &lt;code&gt;v&lt;/code&gt; является &lt;code&gt;equal&lt;/code&gt; или &lt;code&gt;equivalent&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f755b7dc0cfdc44f45a2b4967b0e34b372b2c615" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::partial_ordering::less&lt;/code&gt; if &lt;code&gt;v&lt;/code&gt; is &lt;code&gt;less&lt;/code&gt;, &lt;code&gt;std::partial_ordering::greater&lt;/code&gt; if &lt;code&gt;v&lt;/code&gt; is &lt;code&gt;greater&lt;/code&gt;, &lt;code&gt;std::partial_ordering::equivalent&lt;/code&gt; if &lt;code&gt;v&lt;/code&gt; is &lt;code&gt;equivalent&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;std::partial_ordering::less&lt;/code&gt; , если &lt;code&gt;v&lt;/code&gt; является &lt;code&gt;less&lt;/code&gt; , &lt;code&gt;std::partial_ordering::greater&lt;/code&gt; если &lt;code&gt;v&lt;/code&gt; является &lt;code&gt;greater&lt;/code&gt; , &lt;code&gt;std::partial_ordering::equivalent&lt;/code&gt; , если &lt;code&gt;v&lt;/code&gt; является &lt;code&gt;equivalent&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="29e17d41a2e0da1646d774fd033ea7297c0c1823" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::partial_ordering::unordered&lt;/code&gt; (&lt;code&gt;NaN &amp;lt;=&amp;gt; anything&lt;/code&gt; is unordered)</source>
          <target state="translated">&lt;code&gt;std::partial_ordering::unordered&lt;/code&gt; ( &lt;code&gt;NaN &amp;lt;=&amp;gt; anything&lt;/code&gt; неупорядочено)</target>
        </trans-unit>
        <trans-unit id="78e4fca92581bdc680ad0458a9583ac6d73d4986" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::partial_ordering&lt;/code&gt; is implicitly-convertible to &lt;code&gt;std::weak_equality&lt;/code&gt;, while both &lt;code&gt;std::strong_ordering&lt;/code&gt; and &lt;code&gt;std::weak_ordering&lt;/code&gt; are implicitly-convertible to &lt;code&gt;partial_ordering&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;std::partial_ordering&lt;/code&gt; неявно преобразуется в &lt;code&gt;std::weak_equality&lt;/code&gt; , в то время как &lt;code&gt;std::strong_ordering&lt;/code&gt; и &lt;code&gt;std::weak_ordering&lt;/code&gt; неявно преобразуются в &lt;code&gt;partial_ordering&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d9adc5c14a63be0c211528ab8475e8423b5ff9b9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::path&lt;/code&gt; class and &lt;a href=&quot;filesystem&quot;&gt; supporting functions&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;std::path&lt;/code&gt; класс std :: path и &lt;a href=&quot;filesystem&quot;&gt;вспомогательные функции&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="dea6211e610d9276a290efcf3829502f2aa014dd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::piecewise_constant_distribution&lt;/code&gt; produces random floating-point numbers, which are uniformly distributed within each of the several subintervals [b</source>
          <target state="translated">&lt;code&gt;std::piecewise_constant_distribution&lt;/code&gt; создает случайные числа с плавающей точкой, которые равномерно распределены в каждом из нескольких подинтервалов [b</target>
        </trans-unit>
        <trans-unit id="43981d3cf9fce583c6f001f7d756c2307dfe7dcb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::piecewise_constant_distribution&lt;/code&gt; satisfies all requirements of &lt;a href=&quot;../../named_req/randomnumberdistribution&quot;&gt;RandomNumberDistribution&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;std::piecewise_constant_distribution&lt;/code&gt; &lt;a href=&quot;../../named_req/randomnumberdistribution&quot;&gt;piecewise_constant_distribution&lt;/a&gt; удовлетворяет всем требованиям RandomNumberDistribution .</target>
        </trans-unit>
        <trans-unit id="1464d46a8a5b70bd224518f0ebc1bcbe92b2a5ad" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::piecewise_construct_t&lt;/code&gt; is an empty struct tag type used to disambiguate between different functions that take two tuple arguments.</source>
          <target state="translated">&lt;code&gt;std::piecewise_construct_t&lt;/code&gt; - это пустой тип тега struct, используемый для устранения неоднозначности между различными функциями, которые принимают два аргумента кортежа.</target>
        </trans-unit>
        <trans-unit id="1589591342e4d9b49b177cc62e6708def043ee9d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::piecewise_linear_distribution&lt;/code&gt; produces random floating-point numbers, which are distributed according to a linear probability density function within each of the several subintervals [b</source>
          <target state="translated">&lt;code&gt;std::piecewise_linear_distribution&lt;/code&gt; создает случайные числа с плавающей точкой, которые распределяются в соответствии с линейной функцией плотности вероятности в каждом из нескольких подинтервалов [b</target>
        </trans-unit>
        <trans-unit id="6d24b546da04ae6083af433d420f1dfdb16622bc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::piecewise_linear_distribution&lt;/code&gt; satisfies all requirements of &lt;a href=&quot;../../named_req/randomnumberdistribution&quot;&gt;RandomNumberDistribution&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;std::piecewise_linear_distribution&lt;/code&gt; &lt;a href=&quot;../../named_req/randomnumberdistribution&quot;&gt;piecewise_linear_distribution&lt;/a&gt; удовлетворяет всем требованиям RandomNumberDistribution .</target>
        </trans-unit>
        <trans-unit id="5263eace8b3cd417f114a0429efd9c8136337a84" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::pmr::basic_string&amp;lt;char&amp;gt;&lt;/code&gt;(typedef)</source>
          <target state="translated">&lt;code&gt;std::pmr::basic_string&amp;lt;char&amp;gt;&lt;/code&gt;(typedef)</target>
        </trans-unit>
        <trans-unit id="04b0e71ade467ccdc8596cd285211653c3c4181d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::pmr::basic_string&amp;lt;char16_t&amp;gt;&lt;/code&gt;(typedef)</source>
          <target state="translated">&lt;code&gt;std::pmr::basic_string&amp;lt;char16_t&amp;gt;&lt;/code&gt;(typedef)</target>
        </trans-unit>
        <trans-unit id="94c428b37d8b4967659c14af5dd6202e16b2d9ac" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::pmr::basic_string&amp;lt;char32_t&amp;gt;&lt;/code&gt;(typedef)</source>
          <target state="translated">&lt;code&gt;std::pmr::basic_string&amp;lt;char32_t&amp;gt;&lt;/code&gt;(typedef)</target>
        </trans-unit>
        <trans-unit id="ac9449917132480eccdf004e14b3b3160c633149" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::pmr::basic_string&amp;lt;char8_t&amp;gt;&lt;/code&gt;(typedef)</source>
          <target state="translated">&lt;code&gt;std::pmr::basic_string&amp;lt;char8_t&amp;gt;&lt;/code&gt;(typedef)</target>
        </trans-unit>
        <trans-unit id="07fb229870f46d1589fd827d7de6d407555b9a2e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::pmr::basic_string&amp;lt;wchar_t&amp;gt;&lt;/code&gt;(typedef)</source>
          <target state="translated">&lt;code&gt;std::pmr::basic_string&amp;lt;wchar_t&amp;gt;&lt;/code&gt;(typedef)</target>
        </trans-unit>
        <trans-unit id="a6ef8419a0f8f749d4b0898782b436f2688af048" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::pmr::cmatch&lt;/code&gt;(C++17)</source>
          <target state="translated">&lt;code&gt;std::pmr::cmatch&lt;/code&gt;(C++17)</target>
        </trans-unit>
        <trans-unit id="2c1d8a2f1dae6d653b3d33d171a915438c729345" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::pmr::pool_options&lt;/code&gt; is a set of constructor options for pool resources including &lt;code&gt;&lt;a href=&quot;synchronized_pool_resource&quot;&gt;std::pmr::synchronized_pool_resource&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;unsynchronized_pool_resource&quot;&gt;std::pmr::unsynchronized_pool_resource&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;std::pmr::pool_options&lt;/code&gt; - это набор опций конструктора для ресурсов пула, включая &lt;code&gt;&lt;a href=&quot;synchronized_pool_resource&quot;&gt;std::pmr::synchronized_pool_resource&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;unsynchronized_pool_resource&quot;&gt;std::pmr::unsynchronized_pool_resource&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="67af5bb43cec2dbc73e627d1f1b17685d821bdca" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::pmr::smatch&lt;/code&gt;(C++17)</source>
          <target state="translated">&lt;code&gt;std::pmr::smatch&lt;/code&gt;(C++17)</target>
        </trans-unit>
        <trans-unit id="ef61b23247e7c1bc5b192f4736b9280dc1125a43" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::pmr::string&lt;/code&gt;(C++17)</source>
          <target state="translated">&lt;code&gt;std::pmr::string&lt;/code&gt;(C++17)</target>
        </trans-unit>
        <trans-unit id="2f11f3c27c774ff34d4b096a46d172154a5427d1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::pmr::u16string&lt;/code&gt;(C++17)</source>
          <target state="translated">&lt;code&gt;std::pmr::u16string&lt;/code&gt;(C++17)</target>
        </trans-unit>
        <trans-unit id="fa425397581319f321b29dd377b961ea0133f7bf" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::pmr::u32string&lt;/code&gt;(C++17)</source>
          <target state="translated">&lt;code&gt;std::pmr::u32string&lt;/code&gt;(C++17)</target>
        </trans-unit>
        <trans-unit id="b090acc3f6ab9d6b5a4bd4de89335d0125925c67" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::pmr::u8string&lt;/code&gt;(C++20)</source>
          <target state="translated">&lt;code&gt;std::pmr::u8string&lt;/code&gt;(C++20)</target>
        </trans-unit>
        <trans-unit id="a17934a01dbbcf98ddbb9d5caa50058446ce333c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::pmr::wcmatch&lt;/code&gt;(C++17)</source>
          <target state="translated">&lt;code&gt;std::pmr::wcmatch&lt;/code&gt;(C++17)</target>
        </trans-unit>
        <trans-unit id="61828bbf68f417f4ded0154a94206ec249a946db" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::pmr::wsmatch&lt;/code&gt;(C++17)</source>
          <target state="translated">&lt;code&gt;std::pmr::wsmatch&lt;/code&gt;(C++17)</target>
        </trans-unit>
        <trans-unit id="b2e1399a9d01238f9ffc356412c4548413318ab1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::pmr::wstring&lt;/code&gt;(C++17)</source>
          <target state="translated">&lt;code&gt;std::pmr::wstring&lt;/code&gt;(C++17)</target>
        </trans-unit>
        <trans-unit id="544a2203d7964b1cf3eb3f59b1daa5161af63173" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::pointer_to_binary_function&lt;/code&gt; is a function object that acts as a wrapper around a binary function.</source>
          <target state="translated">&lt;code&gt;std::pointer_to_binary_function&lt;/code&gt; - это функциональный объект, который действует как оболочка для двоичной функции.</target>
        </trans-unit>
        <trans-unit id="68456b56f45eef4590adfe58b554b4aee2b82297" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::pointer_to_unary_function&lt;/code&gt; is a function object that acts as a wrapper around a unary function.</source>
          <target state="translated">&lt;code&gt;std::pointer_to_unary_function&lt;/code&gt; - это функциональный объект, который действует как обертка вокруг унарной функции.</target>
        </trans-unit>
        <trans-unit id="6c4a6649cb227401ea0fd4a3eae9fa3c98459c78" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::poisson_distribution&lt;/code&gt; satisfies &lt;a href=&quot;../../named_req/randomnumberdistribution&quot;&gt;RandomNumberDistribution&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;std::poisson_distribution&lt;/code&gt; удовлетворяет &lt;a href=&quot;../../named_req/randomnumberdistribution&quot;&gt;RandomNumberDistribution&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="fff6237f139ed8631e6228d9bc6dc7571a699631" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::ptrdiff_t&lt;/code&gt; is the signed integer type of the result of subtracting two pointers.</source>
          <target state="translated">&lt;code&gt;std::ptrdiff_t&lt;/code&gt; - целочисленный тип со знаком в результате вычитания двух указателей.</target>
        </trans-unit>
        <trans-unit id="bc3d3a0faaa081042eac5d79ba2d90b165298d55" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::ptrdiff_t&lt;/code&gt; is used for &lt;a href=&quot;../language/operator_arithmetic#Additive_operators&quot;&gt;pointer arithmetic&lt;/a&gt; and array indexing, if negative values are possible. Programs that use other types, such as &lt;code&gt;int&lt;/code&gt;, may fail on, e.g. 64-bit systems when the index exceeds &lt;code&gt;&lt;a href=&quot;climits&quot;&gt;INT_MAX&lt;/a&gt;&lt;/code&gt; or if it relies on 32-bit modular arithmetic.</source>
          <target state="translated">&lt;code&gt;std::ptrdiff_t&lt;/code&gt; используется для &lt;a href=&quot;../language/operator_arithmetic#Additive_operators&quot;&gt;арифметики указателей&lt;/a&gt; и индексации массивов, если возможны отрицательные значения. Программы, которые используют другие типы, такие как &lt;code&gt;int&lt;/code&gt; , могут не работать, например, в 64-битных системах, когда индекс превышает &lt;code&gt;&lt;a href=&quot;climits&quot;&gt;INT_MAX&lt;/a&gt;&lt;/code&gt; или если он опирается на 32-битную модульную арифметику.</target>
        </trans-unit>
        <trans-unit id="ac06d091aeafa710860b79da85a4289003f2e0d6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::random_device&lt;/code&gt; is a uniformly-distributed integer random number generator that produces non-deterministic random numbers.</source>
          <target state="translated">&lt;code&gt;std::random_device&lt;/code&gt; - это генератор случайных чисел с равномерным распределением, который генерирует недетерминированные случайные числа.</target>
        </trans-unit>
        <trans-unit id="b78d53dcaf5721417ff464f5dc1b01db5da3e66e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::random_device&lt;/code&gt; may be implemented in terms of an implementation-defined pseudo-random number engine if a non-deterministic source (e.g. a hardware device) is not available to the implementation. In this case each &lt;code&gt;std::random_device&lt;/code&gt; object may generate the same number sequence.</source>
          <target state="translated">&lt;code&gt;std::random_device&lt;/code&gt; может быть реализовано в терминах механизма псевдослучайных чисел, определенного в реализации, если недетерминированный источник (например, аппаратное устройство) недоступен для реализации. В этом случае каждый объект &lt;code&gt;std::random_device&lt;/code&gt; может генерировать одинаковую числовую последовательность.</target>
        </trans-unit>
        <trans-unit id="733d010e28fb65a97f04138cd398414c0b48b706" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::ratio&amp;lt;1, 1000000000000000000000&amp;gt;&lt;/code&gt;, if &lt;code&gt;&lt;a href=&quot;../../types/integer&quot;&gt;std::intmax_t&lt;/a&gt;&lt;/code&gt; can represent the denominator</source>
          <target state="translated">&lt;code&gt;std::ratio&amp;lt;1, 1000000000000000000000&amp;gt;&lt;/code&gt; , если &lt;code&gt;&lt;a href=&quot;../../types/integer&quot;&gt;std::intmax_t&lt;/a&gt;&lt;/code&gt; может представлять знаменатель</target>
        </trans-unit>
        <trans-unit id="21491fc755d5ba9791f6cacc8c43d1f42d070141" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::ratio&amp;lt;1, 1000000000000000000000000&amp;gt;&lt;/code&gt;, if &lt;code&gt;&lt;a href=&quot;../../types/integer&quot;&gt;std::intmax_t&lt;/a&gt;&lt;/code&gt; can represent the denominator</source>
          <target state="translated">&lt;code&gt;std::ratio&amp;lt;1, 1000000000000000000000000&amp;gt;&lt;/code&gt; , если &lt;code&gt;&lt;a href=&quot;../../types/integer&quot;&gt;std::intmax_t&lt;/a&gt;&lt;/code&gt; может представлять знаменатель</target>
        </trans-unit>
        <trans-unit id="cef43fbd2779ce1f8654b5f38187591e6ca329ba" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::ratio&amp;lt;1000000000000000000000, 1&amp;gt;&lt;/code&gt;, if &lt;code&gt;&lt;a href=&quot;../../types/integer&quot;&gt;std::intmax_t&lt;/a&gt;&lt;/code&gt; can represent the numerator</source>
          <target state="translated">&lt;code&gt;std::ratio&amp;lt;1000000000000000000000, 1&amp;gt;&lt;/code&gt; , если &lt;code&gt;&lt;a href=&quot;../../types/integer&quot;&gt;std::intmax_t&lt;/a&gt;&lt;/code&gt; может представлять числитель</target>
        </trans-unit>
        <trans-unit id="68ad18182f2c368fdb975c210404ad0c9e06d4c9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::ratio&amp;lt;1000000000000000000000000, 1&amp;gt;&lt;/code&gt;, if &lt;code&gt;&lt;a href=&quot;../../types/integer&quot;&gt;std::intmax_t&lt;/a&gt;&lt;/code&gt; can represent the numerator</source>
          <target state="translated">&lt;code&gt;std::ratio&amp;lt;1000000000000000000000000, 1&amp;gt;&lt;/code&gt; , если &lt;code&gt;&lt;a href=&quot;../../types/integer&quot;&gt;std::intmax_t&lt;/a&gt;&lt;/code&gt; может представлять числитель</target>
        </trans-unit>
        <trans-unit id="9c98cc470e8b16991d06d8bc751dbdd401256821" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::reference_wrapper&lt;/code&gt; is a class template that wraps a reference in a copyable, assignable object. It is frequently used as a mechanism to store references inside standard containers (like &lt;code&gt;&lt;a href=&quot;../../container/vector&quot;&gt;std::vector&lt;/a&gt;&lt;/code&gt;) which cannot normally hold references.</source>
          <target state="translated">&lt;code&gt;std::reference_wrapper&lt;/code&gt; - это шаблон класса, который оборачивает ссылку в копируемый, назначаемый объект. Он часто используется в качестве механизма для хранения ссылок внутри стандартных контейнеров (например, &lt;code&gt;&lt;a href=&quot;../../container/vector&quot;&gt;std::vector&lt;/a&gt;&lt;/code&gt; ), которые обычно не могут содержать ссылки.</target>
        </trans-unit>
        <trans-unit id="af9950592969ef1f447e03a8e3965b2efd182067" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::reference_wrapper&lt;/code&gt; is also used to pass objects by reference to &lt;code&gt;&lt;a href=&quot;bind&quot;&gt;std::bind&lt;/a&gt;&lt;/code&gt;, the constructor of &lt;code&gt;&lt;a href=&quot;../../thread/thread&quot;&gt;std::thread&lt;/a&gt;&lt;/code&gt;, or the helper functions &lt;code&gt;&lt;a href=&quot;../pair/make_pair&quot;&gt;std::make_pair&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../tuple/make_tuple&quot;&gt;std::make_tuple&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;std::reference_wrapper&lt;/code&gt; также используется для передачи объектов посредством ссылки на &lt;code&gt;&lt;a href=&quot;bind&quot;&gt;std::bind&lt;/a&gt;&lt;/code&gt; , конструктор &lt;code&gt;&lt;a href=&quot;../../thread/thread&quot;&gt;std::thread&lt;/a&gt;&lt;/code&gt; или вспомогательные функции &lt;code&gt;&lt;a href=&quot;../pair/make_pair&quot;&gt;std::make_pair&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;../tuple/make_tuple&quot;&gt;std::make_tuple&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="22aa124fedb12c1ebec2890071b10e4252dc0665" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::reference_wrapper&lt;/code&gt; is guaranteed to be &lt;a href=&quot;../../named_req/triviallycopyable&quot;&gt;TriviallyCopyable&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;std::reference_wrapper&lt;/code&gt; гарантированно может быть &lt;a href=&quot;../../named_req/triviallycopyable&quot;&gt;TriviallyCopyable&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e00c06df8463f4c62b5c854d2d046dfde8ce082d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::regex_iterator&lt;/code&gt; is a read-only iterator that accesses the individual matches of a regular expression within the underlying character sequence. It meets the requirements of a &lt;a href=&quot;../named_req/forwarditerator&quot;&gt;LegacyForwardIterator&lt;/a&gt;, except that for dereferenceable values &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; with &lt;code&gt;a == b&lt;/code&gt;, &lt;code&gt;*a&lt;/code&gt; and &lt;code&gt;*b&lt;/code&gt; will not be bound to the same object.</source>
          <target state="translated">&lt;code&gt;std::regex_iterator&lt;/code&gt; - это итератор только для чтения, который получает доступ к отдельным совпадениям регулярного выражения в базовой последовательности символов. Он соответствует требованиям &lt;a href=&quot;../named_req/forwarditerator&quot;&gt;LegacyForwardIterator&lt;/a&gt; , за исключением того, что для разыменованных значений &lt;code&gt;a&lt;/code&gt; и &lt;code&gt;b&lt;/code&gt; с &lt;code&gt;a == b&lt;/code&gt; , &lt;code&gt;*a&lt;/code&gt; и &lt;code&gt;*b&lt;/code&gt; не будут привязаны к одному и тому же объекту.</target>
        </trans-unit>
        <trans-unit id="ee427776b3ed6eca5825984efc250d1c3eb23dfe" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::regex_token_iterator&lt;/code&gt; is a read-only &lt;a href=&quot;../named_req/forwarditerator&quot;&gt;LegacyForwardIterator&lt;/a&gt; that accesses the individual sub-matches of every match of a regular expression within the underlying character sequence. It can also be used to access the parts of the sequence that were not matched by the given regular expression (e.g. as a tokenizer).</source>
          <target state="translated">&lt;code&gt;std::regex_token_iterator&lt;/code&gt; - это доступный только для чтения &lt;a href=&quot;../named_req/forwarditerator&quot;&gt;LegacyForwardIterator,&lt;/a&gt; который получает доступ к отдельным частичным совпадениям каждого совпадения регулярного выражения в базовой последовательности символов. Его также можно использовать для доступа к частям последовательности, которые не были сопоставлены с данным регулярным выражением (например, как токенизатор).</target>
        </trans-unit>
        <trans-unit id="67f2f3cf0fd664c7dfb87b979c353b536d657206" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::regex_traits::char_class_type&lt;/code&gt;(since C++11)</source>
          <target state="translated">&lt;code&gt;std::regex_traits::char_class_type&lt;/code&gt; (начиная с C ++ 11)</target>
        </trans-unit>
        <trans-unit id="8a7c1a8e462c9be7b58d511576da4998a286bbdc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::reverse_iterator&lt;/code&gt; does not work with iterators that return a reference to a member object (so-called &quot;stashing iterators&quot;). An example of stashing iterator is &lt;a href=&quot;../filesystem/path#Member_types_and_constants&quot;&gt;&lt;code&gt;std::filesystem::path::iterator&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;std::reverse_iterator&lt;/code&gt; не работает с итераторами, которые возвращают ссылку на объект-член (так называемые &amp;laquo;скрывающие итераторы&amp;raquo;). Примером сохранения итератора является &lt;a href=&quot;../filesystem/path#Member_types_and_constants&quot;&gt; &lt;code&gt;std::filesystem::path::iterator&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8bc574a36f080c60bc0dcdc67f6fbe182967c6a4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::reverse_iterator&lt;/code&gt; is an iterator adaptor that reverses the direction of a given iterator. In other words, when provided with a bidirectional iterator, &lt;code&gt;std::reverse_iterator&lt;/code&gt; produces a new iterator that moves from the end to the beginning of the sequence defined by the underlying bidirectional iterator.</source>
          <target state="translated">&lt;code&gt;std::reverse_iterator&lt;/code&gt; - это адаптер итератора, который меняет направление заданного итератора. Другими словами, когда обеспечивается двунаправленный итератор, &lt;code&gt;std::reverse_iterator&lt;/code&gt; создает новый итератор, который перемещается от конца к началу последовательности, определенной базовым двунаправленным итератором.</target>
        </trans-unit>
        <trans-unit id="06e6eb01ef0888fc5786006b255e0262355a35cb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::rotate&lt;/code&gt; is a common building block in many algorithms. This example demonstrates insertion sort:</source>
          <target state="translated">&lt;code&gt;std::rotate&lt;/code&gt; является общим строительным блоком во многих алгоритмах. Этот пример демонстрирует вставку сортировки:</target>
        </trans-unit>
        <trans-unit id="f441eb26d364454c44afbcadef7f5d66d2c48d76" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::seed_seq&lt;/code&gt; consumes a sequence of integer-valued data and produces a requested number of unsigned integer values &lt;code&gt;i&lt;/code&gt;, 0 &amp;le; i &amp;lt; 232</source>
          <target state="translated">&lt;code&gt;std::seed_seq&lt;/code&gt; использует последовательность целочисленных данных и выдает запрошенное количество целых значений без знака &lt;code&gt;i&lt;/code&gt; , 0 &amp;le; i &amp;lt;232</target>
        </trans-unit>
        <trans-unit id="9c2a99a1055ff146aefbad3ed9afa018825c25dd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::seed_seq&lt;/code&gt; meets the requirements of &lt;a href=&quot;../../named_req/seedsequence&quot;&gt;SeedSequence&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;std::seed_seq&lt;/code&gt; соответствует требованиям &lt;a href=&quot;../../named_req/seedsequence&quot;&gt;SeedSequence&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e4c8bb8b1657216775cfa8413677c1cdf341b425" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::set&lt;/code&gt; is an associative container that contains a sorted set of unique objects of type &lt;code&gt;Key&lt;/code&gt;. Sorting is done using the key comparison function &lt;a href=&quot;../named_req/compare&quot;&gt;Compare&lt;/a&gt;. Search, removal, and insertion operations have logarithmic complexity. Sets are usually implemented as &lt;a href=&quot;https://en.wikipedia.org/wiki/Red%E2%80%93black_tree&quot;&gt;red-black trees&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;std::set&lt;/code&gt; является ассоциативным контейнером, который содержит отсортированный набор уникальных объектов типа &lt;code&gt;Key&lt;/code&gt; . Сортировка выполняется с помощью функции &lt;a href=&quot;../named_req/compare&quot;&gt;сравнения&lt;/a&gt; ключей Compare . Операции поиска, удаления и вставки имеют логарифмическую сложность. Наборы обычно реализуются как &lt;a href=&quot;https://en.wikipedia.org/wiki/Red%E2%80%93black_tree&quot;&gt;красно-черные деревья&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f2c918ca952dcd23d77f536141c1af09ae7aa661" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::set&lt;/code&gt; meets the requirements of &lt;a href=&quot;../named_req/container&quot;&gt;Container&lt;/a&gt;, &lt;a href=&quot;../named_req/allocatorawarecontainer&quot;&gt;AllocatorAwareContainer&lt;/a&gt;, &lt;a href=&quot;../named_req/associativecontainer&quot;&gt;AssociativeContainer&lt;/a&gt; and &lt;a href=&quot;../named_req/reversiblecontainer&quot;&gt;ReversibleContainer&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;std::set&lt;/code&gt; соответствует требованиям &lt;a href=&quot;../named_req/container&quot;&gt;контейнера&lt;/a&gt; , &lt;a href=&quot;../named_req/allocatorawarecontainer&quot;&gt;AllocatorAwareContainer&lt;/a&gt; , &lt;a href=&quot;../named_req/associativecontainer&quot;&gt;AssociativeContainer&lt;/a&gt; и &lt;a href=&quot;../named_req/reversiblecontainer&quot;&gt;ReversibleContainer&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="cd33c830f9ff0669a2f536be537d8c93a0a03b50" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::shared_ptr&lt;/code&gt; is a smart pointer that retains shared ownership of an object through a pointer. Several &lt;code&gt;shared_ptr&lt;/code&gt; objects may own the same object. The object is destroyed and its memory deallocated when either of the following happens:</source>
          <target state="translated">&lt;code&gt;std::shared_ptr&lt;/code&gt; - это интеллектуальный указатель, который сохраняет общее владение объектом через указатель. Несколько объектов &lt;code&gt;shared_ptr&lt;/code&gt; могут иметь один и тот же объект. Объект уничтожается, и его память освобождается, когда происходит одно из следующих действий:</target>
        </trans-unit>
        <trans-unit id="fabbfc740b8d37fb726de4a43248fcefc33b4a9d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::shared_ptr&lt;/code&gt; may be used with an &lt;a href=&quot;../language/incomplete_type&quot;&gt;incomplete type&lt;/a&gt;&lt;code&gt;T&lt;/code&gt;. However, the constructor from a raw pointer (&lt;code&gt;template&amp;lt;class Y&amp;gt; shared_ptr(Y*)&lt;/code&gt;) and the &lt;code&gt;template&amp;lt;class Y&amp;gt; void reset(Y*)&lt;/code&gt; member function may only be called with a pointer to a complete type (note that &lt;code&gt;&lt;a href=&quot;unique_ptr&quot;&gt;std::unique_ptr&lt;/a&gt;&lt;/code&gt; may be constructed from a raw pointer to an incomplete type).</source>
          <target state="translated">&lt;code&gt;std::shared_ptr&lt;/code&gt; может быть использован с &lt;a href=&quot;../language/incomplete_type&quot;&gt;неполным типа &lt;/a&gt; &lt;code&gt;T&lt;/code&gt; . Однако конструктор из необработанного указателя ( &lt;code&gt;template&amp;lt;class Y&amp;gt; shared_ptr(Y*)&lt;/code&gt; ) и &lt;code&gt;template&amp;lt;class Y&amp;gt; void reset(Y*)&lt;/code&gt; члена &amp;lt;class Y&amp;gt; void reset (Y *) можно вызывать только с указателем на полный тип (обратите внимание, что &lt;code&gt;&lt;a href=&quot;unique_ptr&quot;&gt;std::unique_ptr&lt;/a&gt;&lt;/code&gt; может быть создан из необработанного указателя на неполный тип).</target>
        </trans-unit>
        <trans-unit id="03a4c722a55044327e4cfffa724449a4b88da0ed" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::signal&lt;/code&gt; with the first argument being the number of the signal currently handled (async handler can re-register itself, but not other signals).</source>
          <target state="translated">&lt;code&gt;std::signal&lt;/code&gt; с первым аргументом, являющимся номером обработанного в данный момент сигнала (асинхронный обработчик может перерегистрировать себя, но не другие сигналы).</target>
        </trans-unit>
        <trans-unit id="c2254b3548faa8b27fc548641136852a0c03336b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::signal&lt;/code&gt; with the first argument being the number of the signal currently handled (signal handler can re-register itself, but not other signals).</source>
          <target state="translated">&lt;code&gt;std::signal&lt;/code&gt; с первым аргументом, являющимся номером обработанного в данный момент сигнала (обработчик сигнала может перерегистрировать себя, но не другие сигналы).</target>
        </trans-unit>
        <trans-unit id="ca1e54b99db001a5b4190a0c7f3d8fffb71fc24f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::size_t&lt;/code&gt; can store the maximum size of a theoretically possible object of any type (including array). A type whose size cannot be represented by &lt;code&gt;std::size_t&lt;/code&gt; is ill-formed(since C++14) On many platforms (an exception is systems with segmented addressing) &lt;code&gt;std::size_t&lt;/code&gt; can safely store the value of any non-member pointer, in which case it is synonymous with &lt;code&gt;&lt;a href=&quot;integer&quot;&gt;std::uintptr_t&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;std::size_t&lt;/code&gt; может хранить максимальный размер теоретически возможного объекта любого типа (включая массив). Тип, размер которого не может быть представлен &lt;code&gt;std::size_t&lt;/code&gt; , плохо сформирован (начиная с C ++ 14). На многих платформах (исключение составляют системы с сегментированной адресацией) &lt;code&gt;std::size_t&lt;/code&gt; может безопасно хранить значение любого указателя, не являющегося членом , в этом случае это синоним &lt;code&gt;&lt;a href=&quot;integer&quot;&gt;std::uintptr_t&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="290cfac85ab67a680f302b6463b3fa047ee441eb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::size_t&lt;/code&gt; is commonly used for array indexing and loop counting. Programs that use other types, such as &lt;code&gt;unsigned int&lt;/code&gt;, for array indexing may fail on, e.g. 64-bit systems when the index exceeds &lt;code&gt;&lt;a href=&quot;climits&quot;&gt;UINT_MAX&lt;/a&gt;&lt;/code&gt; or if it relies on 32-bit modular arithmetic.</source>
          <target state="translated">&lt;code&gt;std::size_t&lt;/code&gt; обычно используется для индексации массива и подсчета циклов. Программы, которые используют другие типы, такие как &lt;code&gt;unsigned int&lt;/code&gt; , для индексации массива, могут не работать, например, в 64-битных системах, когда индекс превышает &lt;code&gt;&lt;a href=&quot;climits&quot;&gt;UINT_MAX&lt;/a&gt;&lt;/code&gt; или если он использует 32-битную модульную арифметику.</target>
        </trans-unit>
        <trans-unit id="056a9dc0cc03d5b2db95e167d1072f198456cc3f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::size_t&lt;/code&gt; is the unsigned integer type of the result of the &lt;a href=&quot;../language/sizeof&quot;&gt;&lt;code&gt;sizeof&lt;/code&gt;&lt;/a&gt; operator as well as the &lt;a href=&quot;../language/sizeof...&quot;&gt;&lt;code&gt;sizeof...&lt;/code&gt;&lt;/a&gt; operator and the &lt;a href=&quot;../language/alignof&quot;&gt;&lt;code&gt;alignof&lt;/code&gt;&lt;/a&gt; operator(since C++11).</source>
          <target state="translated">&lt;code&gt;std::size_t&lt;/code&gt; - это целочисленный тип без знака результата оператора &lt;a href=&quot;../language/sizeof&quot;&gt; &lt;code&gt;sizeof&lt;/code&gt; ,&lt;/a&gt; а также оператора &lt;a href=&quot;../language/sizeof...&quot;&gt; &lt;code&gt;sizeof...&lt;/code&gt; &lt;/a&gt; оператора &lt;a href=&quot;../language/alignof&quot;&gt; &lt;code&gt;alignof&lt;/code&gt; &lt;/a&gt; (начиная с C ++ 11).</target>
        </trans-unit>
        <trans-unit id="47242d9af8e0da2cd80e37ba7d69dc7cc3832e0f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::slice&lt;/code&gt; is the selector class that identifies a subset of &lt;code&gt;&lt;a href=&quot;../valarray&quot;&gt;std::valarray&lt;/a&gt;&lt;/code&gt; similar to &lt;a href=&quot;https://en.wikipedia.org/wiki/BLAS&quot;&gt;BLAS&lt;/a&gt; slice. An object of type &lt;code&gt;std::slice&lt;/code&gt; holds three values: the starting index, the stride, and the total number of values in the subset. Objects of type &lt;code&gt;std::slice&lt;/code&gt; can be used as indexes with valarray's &lt;code&gt;operator[]&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;std::slice&lt;/code&gt; - это класс селектора, который идентифицирует подмножество &lt;code&gt;&lt;a href=&quot;../valarray&quot;&gt;std::valarray&lt;/a&gt;&lt;/code&gt; аналогичное &lt;a href=&quot;https://en.wikipedia.org/wiki/BLAS&quot;&gt;BLAS- &lt;/a&gt;слайсу . Объект типа &lt;code&gt;std::slice&lt;/code&gt; содержит три значения: начальный индекс, шаг и общее количество значений в подмножестве. Объекты типа &lt;code&gt;std::slice&lt;/code&gt; могут использоваться как индексы с &lt;code&gt;operator[]&lt;/code&gt; valarray [] .</target>
        </trans-unit>
        <trans-unit id="cc6ba21c4316c6b51a3cf612a94f1cb6a3023448" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::slice_array&lt;/code&gt; is a helper template used by &lt;code&gt;&lt;a href=&quot;slice&quot;&gt;std::slice&lt;/a&gt;&lt;/code&gt; subscript operator. It has reference semantics to a subset of the array specified by the &lt;code&gt;std::slice&lt;/code&gt; object.</source>
          <target state="translated">&lt;code&gt;std::slice_array&lt;/code&gt; является вспомогательным шаблоном, используемым оператором нижнего индекса &lt;code&gt;&lt;a href=&quot;slice&quot;&gt;std::slice&lt;/a&gt;&lt;/code&gt; . Он имеет семантику ссылок на подмножество массива, указанного в &lt;code&gt;std::slice&lt;/code&gt; объектом .</target>
        </trans-unit>
        <trans-unit id="3c43c4b56b0bcbad2ca7fbcf999df357050cd5ed" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::span&lt;/code&gt; view</source>
          <target state="translated">&lt;code&gt;std::span&lt;/code&gt; view</target>
        </trans-unit>
        <trans-unit id="022aee2c614401246f82162884b2a5730dddc045" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::sqrt&lt;/code&gt; is required by the IEEE standard to be exact. The only other operations required to be exact are the &lt;a href=&quot;../../language/operator_arithmetic&quot;&gt;arithmetic operators&lt;/a&gt; and the function &lt;code&gt;&lt;a href=&quot;fma&quot;&gt;std::fma&lt;/a&gt;&lt;/code&gt;. After rounding to the return type (using default rounding mode), the result of &lt;code&gt;std::sqrt&lt;/code&gt; is indistinguishable from the infinitely precise result. In other words, the error is less than 0.5 ulp. Other functions, including &lt;code&gt;&lt;a href=&quot;pow&quot;&gt;std::pow&lt;/a&gt;&lt;/code&gt;, are not so constrained.</source>
          <target state="translated">&lt;code&gt;std::sqrt&lt;/code&gt; стандарт IEEE требует std :: sqrt . Единственные другие операции, которые должны быть точными, - это &lt;a href=&quot;../../language/operator_arithmetic&quot;&gt;арифметические операторы&lt;/a&gt; и функция &lt;code&gt;&lt;a href=&quot;fma&quot;&gt;std::fma&lt;/a&gt;&lt;/code&gt; . После округления до возвращаемого типа (с использованием режима округления по умолчанию) результат &lt;code&gt;std::sqrt&lt;/code&gt; неотличим от бесконечно точного результата. Другими словами, ошибка составляет менее 0,5 ulp. Другие функции, включая &lt;code&gt;&lt;a href=&quot;pow&quot;&gt;std::pow&lt;/a&gt;&lt;/code&gt; , не столь ограничены.</target>
        </trans-unit>
        <trans-unit id="a8d30cec9b43e6f974c8d36ed546411518d333cd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::streampos&lt;/code&gt; and &lt;code&gt;std::wstreampos&lt;/code&gt; are required to be the same type because &lt;code&gt;&lt;a href=&quot;../string/char_traits&quot;&gt;std::char_traits&lt;/a&gt;&amp;lt;char&amp;gt;::state_type&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../string/char_traits&quot;&gt;std::char_traits&lt;/a&gt;&amp;lt;wchar_t&amp;gt;::state_type&lt;/code&gt; are required to both be &lt;code&gt;&lt;a href=&quot;../string/multibyte/mbstate_t&quot;&gt;std::mbstate_t&lt;/a&gt;&lt;/code&gt;. C++98 had a self-contradictory statement that they may be different if the implementation supports no shift encoding in narrow-oriented iostreams but supports one or more shift encodings in wide-oriented streams, but that was corrected in C++03.</source>
          <target state="translated">&lt;code&gt;std::streampos&lt;/code&gt; и &lt;code&gt;std::wstreampos&lt;/code&gt; должны быть одного типа, потому что &lt;code&gt;&lt;a href=&quot;../string/char_traits&quot;&gt;std::char_traits&lt;/a&gt;&amp;lt;char&amp;gt;::state_type&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;../string/char_traits&quot;&gt;std::char_traits&lt;/a&gt;&amp;lt;wchar_t&amp;gt;::state_type&lt;/code&gt; оба должны быть &lt;code&gt;&lt;a href=&quot;../string/multibyte/mbstate_t&quot;&gt;std::mbstate_t&lt;/a&gt;&lt;/code&gt; . В C ++ 98 было противоречивое утверждение, что они могут отличаться, если реализация не поддерживает сдвиговое кодирование в узкоориентированных потоках, но поддерживает одно или несколько сдвиговых кодировок в широко ориентированных потоках, но это было исправлено в C ++ 03.</target>
        </trans-unit>
        <trans-unit id="ff0eafa74a74dee03ea9a69e23b551865010e207" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::strong_equality::equal&lt;/code&gt; if &lt;code&gt;p == q&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;std::strong_equality::equal&lt;/code&gt; если &lt;code&gt;p == q&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="88deaa9e64ae8679b6a5d73ef18b59c37a1452b8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::strong_equality::equal&lt;/code&gt; if &lt;code&gt;v&lt;/code&gt; is &lt;code&gt;equivalent&lt;/code&gt; or &lt;code&gt;equal&lt;/code&gt;, &lt;code&gt;std::strong_equality::nonequal&lt;/code&gt; if &lt;code&gt;v&lt;/code&gt; is &lt;code&gt;less&lt;/code&gt; or &lt;code&gt;greater&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;std::strong_equality::equal&lt;/code&gt; , если &lt;code&gt;v&lt;/code&gt; является &lt;code&gt;equivalent&lt;/code&gt; или &lt;code&gt;equal&lt;/code&gt; , &lt;code&gt;std::strong_equality::nonequal&lt;/code&gt; , если &lt;code&gt;v&lt;/code&gt; является &lt;code&gt;less&lt;/code&gt; или &lt;code&gt;greater&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b2828c1fd0dac296e742caf4bff22f7533be6f4d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::strong_equality::unequal&lt;/code&gt; if &lt;code&gt;p != q&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;std::strong_equality::unequal&lt;/code&gt; если &lt;code&gt;p != q&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="fdce79e381b03cf3c0ed3a09ab095fa0f7f8dd55" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::strong_equality&lt;/code&gt; is implicitly-convertible to &lt;code&gt;std::weak_equality&lt;/code&gt;, and &lt;code&gt;std::strong_ordering&lt;/code&gt; is implicitly-convertible to &lt;code&gt;strong_equality&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;std::strong_equality&lt;/code&gt; неявно преобразуется в &lt;code&gt;std::weak_equality&lt;/code&gt; , а &lt;code&gt;std::strong_ordering&lt;/code&gt; неявно преобразуется в &lt;code&gt;strong_equality&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c1bcf62941b855cdd0eac5af9fa875bd46144dbc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::strong_ordering::equal&lt;/code&gt; if &lt;code&gt;p == q&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;std::strong_ordering::equal&lt;/code&gt; если &lt;code&gt;p == q&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="fa83ac2e7a33bc297d6c81b58884fdb954ee3802" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::strong_ordering::equal&lt;/code&gt; if both operands are arithmetically equal,</source>
          <target state="translated">&lt;code&gt;std::strong_ordering::equal&lt;/code&gt; если оба операнда арифметически равны,</target>
        </trans-unit>
        <trans-unit id="a181c69bdfa2c3d7090838be67bdd8fbd3d75e3b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::strong_ordering::greater&lt;/code&gt; if &lt;code&gt;p &amp;gt; q&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;std::strong_ordering::greater&lt;/code&gt; если &lt;code&gt;p &amp;gt; q&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="71b898ba9d170e3716779c1c92981e7382e24f08" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::strong_ordering::greater&lt;/code&gt; otherwise.</source>
          <target state="translated">&lt;code&gt;std::strong_ordering::greater&lt;/code&gt; иначе std :: strong_ordering :: больше .</target>
        </trans-unit>
        <trans-unit id="94f91bbaa05a1c0e4e86bdd725dfda6ed828496c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::strong_ordering::less&lt;/code&gt; if &lt;code&gt;q &amp;gt; p&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;std::strong_ordering::less&lt;/code&gt; if &lt;code&gt;q &amp;gt; p&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="cd73a567570412ceb0f011855a55d1be0b51206d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::strong_ordering::less&lt;/code&gt; if the first operand is arithmetically less than the second</source>
          <target state="translated">&lt;code&gt;std::strong_ordering::less&lt;/code&gt; если первый операнд арифметически меньше второго</target>
        </trans-unit>
        <trans-unit id="a0be3656c320241f0794e9dd6c9a8f164ba69337" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::strong_ordering&lt;/code&gt; is the strongest of the five comparison categories: it is not implicitly-convertible from any other category and is implicitly-convertible to the other four.</source>
          <target state="translated">&lt;code&gt;std::strong_ordering&lt;/code&gt; является самой сильной из пяти категорий сравнения: он неявно не преобразуется из любой другой категории и неявно преобразуется в другие четыре.</target>
        </trans-unit>
        <trans-unit id="18a339f4bc94136e209672e86712fa4b5c74a67e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::strstreambuf&lt;/code&gt; is a &lt;code&gt;&lt;a href=&quot;basic_streambuf&quot;&gt;std::basic_streambuf&lt;/a&gt;&lt;/code&gt; whose associated character sequence is a character array, which may be constant (e.g. a string literal), modifyable but not dynamic (e.g. a stack-allocated array), or dynamic, in which case the &lt;code&gt;std::strstreambuf&lt;/code&gt; may be allowed to reallocate the array as necessary to accomodate output (e.g. by calling &lt;code&gt;delete[]&lt;/code&gt; and &lt;code&gt;new[]&lt;/code&gt; or user-provided functions).</source>
          <target state="translated">&lt;code&gt;std::strstreambuf&lt;/code&gt; - это &lt;code&gt;&lt;a href=&quot;basic_streambuf&quot;&gt;std::basic_streambuf&lt;/a&gt;&lt;/code&gt; чья связанная последовательность символов представляет собой массив символов, который может быть постоянным (например, строковый литерал), изменяемым, но не динамическим (например, массив, выделенный стеком), или динамическим, в этом случае &lt;code&gt;std::strstreambuf&lt;/code&gt; может быть разрешено перераспределять массив по мере необходимости для размещения выходных данных (например, путем вызова &lt;code&gt;delete[]&lt;/code&gt; и &lt;code&gt;new[]&lt;/code&gt; или пользовательских функций).</target>
        </trans-unit>
        <trans-unit id="20b1262a3ef1cef77b3b6dd08e920d63edd3d503" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::student_t_distribution&lt;/code&gt; satisfies all requirements of &lt;a href=&quot;../../named_req/randomnumberdistribution&quot;&gt;RandomNumberDistribution&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;std::student_t_distribution&lt;/code&gt; удовлетворяет всем требованиям &lt;a href=&quot;../../named_req/randomnumberdistribution&quot;&gt;RandomNumberDistribution&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d1a1bd7eb4ef8c03ea4109507696644c4ffb2d1e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::sub_match&lt;/code&gt; and &lt;code&gt;std::basic_string&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;std::sub_match&lt;/code&gt; и &lt;code&gt;std::basic_string&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0a5b5ab885216f8f5912119ae5ca87c8090e2875" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::sub_match&lt;/code&gt; and &lt;code&gt;std::iterator_traits&amp;lt;BidirIt&amp;gt;::value_type*&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;std::sub_match&lt;/code&gt; и &lt;code&gt;std::iterator_traits&amp;lt;BidirIt&amp;gt;::value_type*&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ff93371d4eb96a58db4fdb372bc81e5853b46bb4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::sub_match&lt;/code&gt; and &lt;code&gt;std::iterator_traits&amp;lt;BidirIt&amp;gt;::value_type&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;std::sub_match&lt;/code&gt; и &lt;code&gt;std::iterator_traits&amp;lt;BidirIt&amp;gt;::value_type&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ba31ca36a3af295296b1e09f75fa13408fe38921" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::swap&lt;/code&gt; may be &lt;a href=&quot;http://en.cppreference.com/w/cpp/language/extending_std&quot;&gt;specialized in namespace std&lt;/a&gt; for program-defined types, but such specializations are not found by &lt;a href=&quot;../language/adl&quot;&gt;ADL&lt;/a&gt; (the namespace std is not the associated namespace for the program-defined type).</source>
          <target state="translated">&lt;code&gt;std::swap&lt;/code&gt; может &lt;a href=&quot;http://en.cppreference.com/w/cpp/language/extending_std&quot;&gt;специализироваться на пространстве имен std&lt;/a&gt; для программно-определенных типов, но &lt;a href=&quot;../language/adl&quot;&gt;ADL&lt;/a&gt; не находит таких специализаций (пространство имен std не является ассоциированным пространством имен для программно-определенного типа).</target>
        </trans-unit>
        <trans-unit id="3cdfd51faa9c8fac8ac4c8f19556e6aaf7087b9c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::system_error&lt;/code&gt; is the type of the exception thrown by various library functions (typically the functions that interface with the OS facilities, e.g. the constructor of &lt;code&gt;&lt;a href=&quot;../thread/thread&quot;&gt;std::thread&lt;/a&gt;&lt;/code&gt;) when the exception has an associated &lt;code&gt;&lt;a href=&quot;error_code&quot;&gt;std::error_code&lt;/a&gt;&lt;/code&gt;, which may be reported.</source>
          <target state="translated">&lt;code&gt;std::system_error&lt;/code&gt; - это тип исключения, выдаваемого различными библиотечными функциями (обычно это функции, которые взаимодействуют со средствами ОС, например, конструктором &lt;code&gt;&lt;a href=&quot;../thread/thread&quot;&gt;std::thread&lt;/a&gt;&lt;/code&gt; ), когда с исключением связан связанный &lt;code&gt;&lt;a href=&quot;error_code&quot;&gt;std::error_code&lt;/a&gt;&lt;/code&gt; , о котором можно сообщить ,</target>
        </trans-unit>
        <trans-unit id="9b97e66f36eaf86ebef226240b01fec6a5931292" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::terminate()&lt;/code&gt; is called by the C++ runtime when exception handling fails for any of the following reasons:</source>
          <target state="translated">&lt;code&gt;std::terminate()&lt;/code&gt; вызывается средой выполнения C ++, когда обработка исключений завершается неудачей по любой из следующих причин:</target>
        </trans-unit>
        <trans-unit id="707766d49466f7eb486764ecef0242827a563761" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::terminate()&lt;/code&gt; may also be called directly from the program.</source>
          <target state="translated">&lt;code&gt;std::terminate()&lt;/code&gt; также может быть вызван непосредственно из программы.</target>
        </trans-unit>
        <trans-unit id="967f01400b555a0590b6a06e03c381f0be0d2748" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::terminate_handler&lt;/code&gt; is the function pointer type (pointer to function that takes no arguments and returns void), which is installed and queried by the functions &lt;code&gt;&lt;a href=&quot;set_terminate&quot;&gt;std::set_terminate&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;get_terminate&quot;&gt;std::get_terminate&lt;/a&gt;&lt;/code&gt; and called by &lt;code&gt;&lt;a href=&quot;terminate&quot;&gt;std::terminate&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;std::terminate_handler&lt;/code&gt; - это тип указателя на функцию (указатель на функцию, которая не принимает аргументов и возвращает void), которая устанавливается и запрашивается функциями &lt;code&gt;&lt;a href=&quot;set_terminate&quot;&gt;std::set_terminate&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;get_terminate&quot;&gt;std::get_terminate&lt;/a&gt;&lt;/code&gt; и вызывается с помощью &lt;code&gt;&lt;a href=&quot;terminate&quot;&gt;std::terminate&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="13cc468c9dc5514d2fac80612f05a11f45487235" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::thread&lt;/code&gt; objects may also be in the state that does not represent any thread (after default construction, move from, &lt;code&gt;&lt;a href=&quot;thread/detach&quot;&gt;detach&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;thread/join&quot;&gt;join&lt;/a&gt;&lt;/code&gt;), and a thread of execution may be not associated with any &lt;code&gt;thread&lt;/code&gt; objects (after &lt;code&gt;&lt;a href=&quot;thread/detach&quot;&gt;detach&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;std::thread&lt;/code&gt; Объекты std :: thread также могут находиться в состоянии, которое не представляет какой-либо поток (после построения по умолчанию, перемещаться, &lt;code&gt;&lt;a href=&quot;thread/detach&quot;&gt;detach&lt;/a&gt;&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;thread/join&quot;&gt;join&lt;/a&gt;&lt;/code&gt; ), и поток выполнения может быть не связан ни с какими объектами &lt;code&gt;thread&lt;/code&gt; (после &lt;code&gt;&lt;a href=&quot;thread/detach&quot;&gt;detach&lt;/a&gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="9efd773c6198d21cd58d5624e73cb6260c84320b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::tie&lt;/code&gt; can be used to introduce lexicographical comparison to a struct or to unpack a tuple:</source>
          <target state="translated">&lt;code&gt;std::tie&lt;/code&gt; можно использовать для введения лексикографического сравнения в структуру или для распаковки кортежа:</target>
        </trans-unit>
        <trans-unit id="d306d0d73a611a68233912abbfd10d0645a66545" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::tie&lt;/code&gt; may be used to unpack a &lt;code&gt;&lt;a href=&quot;../pair&quot;&gt;std::pair&lt;/a&gt;&lt;/code&gt; because &lt;code&gt;&lt;a href=&quot;../tuple&quot;&gt;std::tuple&lt;/a&gt;&lt;/code&gt; has a &lt;a href=&quot;operator=&quot;&gt;converting assignment&lt;/a&gt; from pairs:</source>
          <target state="translated">&lt;code&gt;std::tie&lt;/code&gt; можно использовать для распаковки &lt;code&gt;&lt;a href=&quot;../pair&quot;&gt;std::pair&lt;/a&gt;&lt;/code&gt; потому что &lt;code&gt;&lt;a href=&quot;../tuple&quot;&gt;std::tuple&lt;/a&gt;&lt;/code&gt; имеет &lt;a href=&quot;operator=&quot;&gt;присваиваемое преобразование&lt;/a&gt; из пар:</target>
        </trans-unit>
        <trans-unit id="afe708861136a7c969234dc59c3e1714fbac45b1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::time_get_byname&lt;/code&gt; is a &lt;code&gt;&lt;a href=&quot;time_get&quot;&gt;std::time_get&lt;/a&gt;&lt;/code&gt; facet which encapsulates time and date parsing rules of the locale specified at its construction.</source>
          <target state="translated">&lt;code&gt;std::time_get_byname&lt;/code&gt; - это фасет &lt;code&gt;&lt;a href=&quot;time_get&quot;&gt;std::time_get&lt;/a&gt;&lt;/code&gt; который инкапсулирует правила синтаксического анализа времени и даты для локали, указанной при ее построении.</target>
        </trans-unit>
        <trans-unit id="7c370603c900e9e11ba920686444d55c087581b4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::time_put_byname&lt;/code&gt; is a &lt;code&gt;&lt;a href=&quot;time_put&quot;&gt;std::time_put&lt;/a&gt;&lt;/code&gt; facet which encapsulates time and date formatting rules of the locale specified at its construction.</source>
          <target state="translated">&lt;code&gt;std::time_put_byname&lt;/code&gt; - это фасет &lt;code&gt;&lt;a href=&quot;time_put&quot;&gt;std::time_put&lt;/a&gt;&lt;/code&gt; который инкапсулирует правила форматирования времени и даты для локали, указанной при ее построении.</target>
        </trans-unit>
        <trans-unit id="168ace59259188176403e2196b7d0ba75671c5a7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::tmpnam&lt;/code&gt; modifies static state and is not required to be thread-safe.</source>
          <target state="translated">&lt;code&gt;std::tmpnam&lt;/code&gt; изменяет статическое состояние и не обязан быть потокобезопасным.</target>
        </trans-unit>
        <trans-unit id="dedb51abfca7405582b2d0f7f2e6c3a75a98b2f5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::to_address&lt;/code&gt; can be used even when &lt;code&gt;p&lt;/code&gt; does not reference storage that has an object constructed in it, in which case &lt;code&gt;&lt;a href=&quot;addressof&quot;&gt;std::addressof&lt;/a&gt;(*p)&lt;/code&gt; cannot be used because there's no valid object for the parameter of &lt;code&gt;&lt;a href=&quot;addressof&quot;&gt;std::addressof&lt;/a&gt;&lt;/code&gt; to bind to.</source>
          <target state="translated">&lt;code&gt;std::to_address&lt;/code&gt; можно использовать даже тогда , когда &lt;code&gt;p&lt;/code&gt; не ссылочный хранилище , которое имеет объект , построенный в нем, в этом случае &lt;code&gt;&lt;a href=&quot;addressof&quot;&gt;std::addressof&lt;/a&gt;(*p)&lt;/code&gt; не может быть использовано , так как нет действительного объекта для параметра &lt;code&gt;&lt;a href=&quot;addressof&quot;&gt;std::addressof&lt;/a&gt;&lt;/code&gt; к связываются с.</target>
        </trans-unit>
        <trans-unit id="b46c993ce36788048b268c1696eb73f8b98374f0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::to_chars&lt;/code&gt; and &lt;code&gt;std::from_chars&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;std::to_chars&lt;/code&gt; и &lt;code&gt;std::from_chars&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a9cd7760eccc84b707a50eaebab892d1d3e5f509" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::to_string&lt;/code&gt; relies on the current locale for formatting purposes, and therefore concurrent calls to &lt;code&gt;std::to_string&lt;/code&gt; from multiple threads may result in partial serialization of calls. C++17 provides &lt;a href=&quot;../../utility/to_chars&quot;&gt;&lt;code&gt;std::to_chars&lt;/code&gt;&lt;/a&gt; as a higher-performance locale-independent alternative.</source>
          <target state="translated">&lt;code&gt;std::to_string&lt;/code&gt; опирается на текущую локаль для целей форматирования, и поэтому одновременные вызовы &lt;code&gt;std::to_string&lt;/code&gt; из нескольких потоков могут привести к частичной сериализации вызовов. C ++ 17 предоставляет &lt;a href=&quot;../../utility/to_chars&quot;&gt; &lt;code&gt;std::to_chars&lt;/code&gt; &lt;/a&gt; как высокопроизводительную независимую от локали альтернативу.</target>
        </trans-unit>
        <trans-unit id="be1a0d836b90531682a592a8c05709e53004c149" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::transform&lt;/code&gt; applies the given function to a range and stores the result in another range, beginning at &lt;code&gt;d_first&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;std::transform&lt;/code&gt; применяет данную функцию к диапазону и сохраняет результат в другом диапазоне, начиная с &lt;code&gt;d_first&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c6cd4e102829d3895559858e0d9124b27ca438a8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::transform&lt;/code&gt; does not guarantee in-order application of &lt;code&gt;unary_op&lt;/code&gt; or &lt;code&gt;binary_op&lt;/code&gt;. To apply a function to a sequence in-order or to apply a function that modifies the elements of a sequence, use &lt;code&gt;&lt;a href=&quot;for_each&quot;&gt;std::for_each&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;std::transform&lt;/code&gt; не гарантирует применения по &lt;code&gt;unary_op&lt;/code&gt; или &lt;code&gt;binary_op&lt;/code&gt; . Чтобы применить функцию к последовательности по порядку или применить функцию, которая изменяет элементы последовательности, используйте &lt;code&gt;&lt;a href=&quot;for_each&quot;&gt;std::for_each&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="369cbe5d59701bacdbac57d4ffbdb1d3005d5fc3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::u16string&lt;/code&gt;(C++11)</source>
          <target state="translated">&lt;code&gt;std::u16string&lt;/code&gt;(C++11)</target>
        </trans-unit>
        <trans-unit id="5c664f67d51845abae95b5f4eff5530a5e4e852d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::u32string&lt;/code&gt;(C++11)</source>
          <target state="translated">&lt;code&gt;std::u32string&lt;/code&gt;(C++11)</target>
        </trans-unit>
        <trans-unit id="d018d8459afcf08b3a64d2e43507143d97d66702" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::u8string&lt;/code&gt;(C++20)</source>
          <target state="translated">&lt;code&gt;std::u8string&lt;/code&gt;(C++20)</target>
        </trans-unit>
        <trans-unit id="8db402252e2247e1115923d033d3fdbc01c24ffa" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::u8string&lt;/code&gt;(since C++20)</source>
          <target state="translated">&lt;code&gt;std::u8string&lt;/code&gt; (начиная с C ++ 20)</target>
        </trans-unit>
        <trans-unit id="28dc2a65207cfa538de9d0d3c83868d7291c3a71" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::u8string_view&lt;/code&gt;(since C++20)</source>
          <target state="translated">&lt;code&gt;std::u8string_view&lt;/code&gt; (начиная с C ++ 20)</target>
        </trans-unit>
        <trans-unit id="fc05d3bc1c5239c2cb1fa3a05f95d7b3bcb6d04a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::unexpected()&lt;/code&gt; is called by the C++ runtime when a &lt;a href=&quot;../../language/except_spec&quot;&gt;dynamic exception specification&lt;/a&gt; is violated: an exception is thrown from a function whose exception specification forbids exceptions of this type.</source>
          <target state="translated">&lt;code&gt;std::unexpected()&lt;/code&gt; вызывается средой выполнения C ++, когда нарушается &lt;a href=&quot;../../language/except_spec&quot;&gt;спецификация динамического исключения&lt;/a&gt; : исключение выдается из функции, спецификация исключения которой запрещает исключения этого типа.</target>
        </trans-unit>
        <trans-unit id="f92d15dc42ce35ff57483e797d7c8f8b1f9636b5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::unexpected()&lt;/code&gt; may also be called directly from the program.</source>
          <target state="translated">&lt;code&gt;std::unexpected()&lt;/code&gt; также может быть вызван непосредственно из программы.</target>
        </trans-unit>
        <trans-unit id="43b8f5b3528d14822224152dd25f600ede9e7c34" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::unexpected_handler&lt;/code&gt; is the function pointer type (pointer to function that takes no arguments and returns void), which is installed and queried by the functions &lt;code&gt;&lt;a href=&quot;set_unexpected&quot;&gt;std::set_unexpected&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;get_unexpected&quot;&gt;std::get_unexpected&lt;/a&gt;&lt;/code&gt; and called by &lt;code&gt;&lt;a href=&quot;unexpected&quot;&gt;std::unexpected&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;std::unexpected_handler&lt;/code&gt; типа указателя функции (указатель на функцию , которая не принимает никаких аргументов и возвращает недействительный), который устанавливается и запрашивается функциями &lt;code&gt;&lt;a href=&quot;set_unexpected&quot;&gt;std::set_unexpected&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;get_unexpected&quot;&gt;std::get_unexpected&lt;/a&gt;&lt;/code&gt; и вызываемого &lt;code&gt;&lt;a href=&quot;unexpected&quot;&gt;std::unexpected&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="749f7fda0e2e18379142e674b99f477616d0b136" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::uniform_int_distribution&lt;/code&gt; satisfies all requirements of &lt;a href=&quot;../../named_req/randomnumberdistribution&quot;&gt;RandomNumberDistribution&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;std::uniform_int_distribution&lt;/code&gt; удовлетворяет всем требованиям &lt;a href=&quot;../../named_req/randomnumberdistribution&quot;&gt;RandomNumberDistribution&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c444092291162ae7558c84afd48c45cb9322484f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::uniform_real_distribution&lt;/code&gt; satisfies all requirements of &lt;a href=&quot;../../named_req/randomnumberdistribution&quot;&gt;RandomNumberDistribution&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;std::uniform_real_distribution&lt;/code&gt; удовлетворяет всем требованиям &lt;a href=&quot;../../named_req/randomnumberdistribution&quot;&gt;RandomNumberDistribution&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="eb35955ee270e54b7c81eaa739704d3de5f1583a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::unique_ptr&lt;/code&gt; is a smart pointer that owns and manages another object through a pointer and disposes of that object when the &lt;code&gt;unique_ptr&lt;/code&gt; goes out of scope.</source>
          <target state="translated">&lt;code&gt;std::unique_ptr&lt;/code&gt; - это интеллектуальный указатель, который владеет и управляет другим объектом через указатель и удаляет этот объект, когда &lt;code&gt;unique_ptr&lt;/code&gt; выходит из области видимости.</target>
        </trans-unit>
        <trans-unit id="58e8a960823be282cfdc5e0d6c9be212b22d9797" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::unique_ptr&lt;/code&gt; is commonly used to manage the lifetime of objects, including:</source>
          <target state="translated">&lt;code&gt;std::unique_ptr&lt;/code&gt; обычно используется для управления временем жизни объектов, включая:</target>
        </trans-unit>
        <trans-unit id="e307c436ff83a7f2f77edf798287d471ee601de8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::unique_ptr&lt;/code&gt; may be constructed for an &lt;a href=&quot;../language/incomplete_type&quot;&gt;incomplete type&lt;/a&gt;&lt;code&gt;T&lt;/code&gt;, such as to facilitate the use as a handle in the &lt;a href=&quot;../language/pimpl&quot;&gt;pImpl idiom&lt;/a&gt;. If the default deleter is used, &lt;code&gt;T&lt;/code&gt; must be complete at the point in code where the deleter is invoked, which happens in the destructor, move assignment operator, and &lt;code&gt;reset&lt;/code&gt; member function of &lt;code&gt;std::unique_ptr&lt;/code&gt;. (Conversely, &lt;code&gt;&lt;a href=&quot;shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&lt;/code&gt; can't be constructed from a raw pointer to incomplete type, but can be destroyed where &lt;code&gt;T&lt;/code&gt; is incomplete). Note that if &lt;code&gt;T&lt;/code&gt; is a class template specialization, use of &lt;code&gt;unique_ptr&lt;/code&gt; as an operand, e.g. &lt;code&gt;!p&lt;/code&gt; requires &lt;code&gt;T&lt;/code&gt;'s parameters to be complete due to &lt;a href=&quot;../language/adl&quot;&gt;ADL&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;std::unique_ptr&lt;/code&gt; может быть создан для &lt;a href=&quot;../language/incomplete_type&quot;&gt;неполного типа &lt;/a&gt; &lt;code&gt;T&lt;/code&gt; , например, чтобы облегчить использование в качестве дескриптора в &lt;a href=&quot;../language/pimpl&quot;&gt;идиоме pImpl&lt;/a&gt; . Если используется средство удаления по умолчанию, &lt;code&gt;T&lt;/code&gt; должен быть завершен в той точке кода, где вызывается средство удаления, что происходит в деструкторе, операторе присваивания перемещения и &lt;code&gt;reset&lt;/code&gt; функцию-член &lt;code&gt;std::unique_ptr&lt;/code&gt; . (И наоборот, &lt;code&gt;&lt;a href=&quot;shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&lt;/code&gt; не может быть создан из необработанного указателя на неполный тип, но может быть уничтожен там, где &lt;code&gt;T&lt;/code&gt; неполный). Обратите внимание, что если &lt;code&gt;T&lt;/code&gt; является специализацией шаблона класса, использование &lt;code&gt;unique_ptr&lt;/code&gt; в качестве операнда, например &lt;code&gt;!p&lt;/code&gt; требует, чтобы параметры &lt;code&gt;T&lt;/code&gt; были полными из-за &lt;a href=&quot;../language/adl&quot;&gt;ADL&lt;/a&gt; .</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
