<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="cpp">
    <body>
      <group id="cpp">
        <trans-unit id="42d66c9df47506c2bbd054315689658beb84bc9e" translate="yes" xml:space="preserve">
          <source>U+B0000 - U+BFFFD</source>
          <target state="translated">U+B0000-U+BFFFD</target>
        </trans-unit>
        <trans-unit id="cdba1c6047783563972c12317b4d72868b21fd76" translate="yes" xml:space="preserve">
          <source>U+C0000 - U+CFFFD</source>
          <target state="translated">U+C0000-U+CFFFD</target>
        </trans-unit>
        <trans-unit id="010072229c529f3ca79fb579b3df7190d32934a1" translate="yes" xml:space="preserve">
          <source>U+D0000 - U+DFFFD</source>
          <target state="translated">U+D0000-U+DFFFD</target>
        </trans-unit>
        <trans-unit id="ce5b442ae1391ac6f3397af8e6e2ed8bbfa37b7f" translate="yes" xml:space="preserve">
          <source>U+E0000 - U+EFFFD</source>
          <target state="translated">U+E0000-U+EFFFD</target>
        </trans-unit>
        <trans-unit id="520d6df0bba5aba46938723a37a68ea22f05a23c" translate="yes" xml:space="preserve">
          <source>U+F900 - U+FD3D</source>
          <target state="translated">U+F900-U+FD3D</target>
        </trans-unit>
        <trans-unit id="163422b76168f04b02797dee7a00db38f358ee53" translate="yes" xml:space="preserve">
          <source>U+FD40 - U+FDCF</source>
          <target state="translated">U+FD40-U+FDCF</target>
        </trans-unit>
        <trans-unit id="fb7bec8d977e924e7257c5655dae76a42823e7a8" translate="yes" xml:space="preserve">
          <source>U+FDF0 - U+FE44</source>
          <target state="translated">U+FDF0-U+FE44</target>
        </trans-unit>
        <trans-unit id="04089c7fc7f2ca3bf063171c8d318a9d6ea6bbde" translate="yes" xml:space="preserve">
          <source>U+FE20 - U+FE2F</source>
          <target state="translated">U+FE20-U+FE2F</target>
        </trans-unit>
        <trans-unit id="f56e67971694a5871856f55e8563ac4dbbcaec84" translate="yes" xml:space="preserve">
          <source>U+FE47 - U+FFFD</source>
          <target state="translated">U+FE47-U+FFFD</target>
        </trans-unit>
        <trans-unit id="270912477818594d05da0936d300cdd48568315a" translate="yes" xml:space="preserve">
          <source>U&lt;code&gt;( { &lt;/code&gt;arg1, arg2, ...&lt;code&gt;} )&lt;/code&gt;</source>
          <target state="translated">U &lt;code&gt;( { &lt;/code&gt; arg1, arg2, ... &lt;code&gt;} )&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="931d496adbd3f197940b61b27f25bcf6e5ce6062" translate="yes" xml:space="preserve">
          <source>UB</source>
          <target state="translated">UB</target>
        </trans-unit>
        <trans-unit id="02625f3ba5ef5ecc340624e8cdbc7bbea1792597" translate="yes" xml:space="preserve">
          <source>UB and optimization</source>
          <target state="translated">ВБ и оптимизация</target>
        </trans-unit>
        <trans-unit id="fc4cea3d19213a9f2ad0bf9e1d25fcd42a13416e" translate="yes" xml:space="preserve">
          <source>UCHAR_MAXUSHRT_MAXUINT_MAXULONG_MAXULLONG_MAX</source>
          <target state="translated">UCHAR_MAXUSHRT_MAXUINT_MAXULONG_MAXULLONG_MAX</target>
        </trans-unit>
        <trans-unit id="2cfb9dd16496ce85eff96d27557f7b42dd5f480d" translate="yes" xml:space="preserve">
          <source>UCS2</source>
          <target state="translated">UCS2</target>
        </trans-unit>
        <trans-unit id="cc245ae082a0221ea07ed3630dd9a406b15ac831" translate="yes" xml:space="preserve">
          <source>UCS2(Windows)</source>
          <target state="translated">UCS2(Windows)</target>
        </trans-unit>
        <trans-unit id="fb192521136df48247e2057851a45e670921483e" translate="yes" xml:space="preserve">
          <source>UDL</source>
          <target state="translated">UDL</target>
        </trans-unit>
        <trans-unit id="b326c17ee1a8eb3c225550246d3d3c78e82f8b2f" translate="yes" xml:space="preserve">
          <source>UINT8_CUINT16_CUINT32_CUINT64_C</source>
          <target state="translated">UINT8_CUINT16_CUINT32_CUINT64_C</target>
        </trans-unit>
        <trans-unit id="6fc76eff0c2b7cb02126a9c106ac3442a9727995" translate="yes" xml:space="preserve">
          <source>UINT8_MAXUINT16_MAXUINT32_MAXUINT64_MAX</source>
          <target state="translated">UINT8_MAXUINT16_MAXUINT32_MAXUINT64_MAX</target>
        </trans-unit>
        <trans-unit id="9ba6e74bce3dda604b2bb3467dd7e8066580c7b5" translate="yes" xml:space="preserve">
          <source>UINTMAX_C</source>
          <target state="translated">UINTMAX_C</target>
        </trans-unit>
        <trans-unit id="5b83709ee00794f8873850a1d8ed0fb42b4fb169" translate="yes" xml:space="preserve">
          <source>UINTMAX_MAX</source>
          <target state="translated">UINTMAX_MAX</target>
        </trans-unit>
        <trans-unit id="ce620a4e99af76df2964e767b6f8444400deb8ca" translate="yes" xml:space="preserve">
          <source>UINTPTR_MAX</source>
          <target state="translated">UINTPTR_MAX</target>
        </trans-unit>
        <trans-unit id="bfda17e335d33e8db92bdb55c45171d922a6859c" translate="yes" xml:space="preserve">
          <source>UINT_FAST8_MAXUINT_FAST16_MAXUINT_FAST32_MAXUINT_FAST64_MAX</source>
          <target state="translated">UINT_FAST8_MAXUINT_FAST16_MAXUINT_FAST32_MAXUINT_FAST64_MAX</target>
        </trans-unit>
        <trans-unit id="ad74c7ce12e14f74c8c414a0ec98ea6351f500a5" translate="yes" xml:space="preserve">
          <source>UINT_LEAST8_MAXUINT_LEAST16_MAXUINT_LEAST32_MAXUINT_LEAST64_MAX</source>
          <target state="translated">UINT_LEAST8_MAXUINT_LEAST16_MAXUINT_LEAST32_MAXUINT_LEAST64_MAX</target>
        </trans-unit>
        <trans-unit id="4196b39d1eebc6a19e223c4aac2d97a9aacf8120" translate="yes" xml:space="preserve">
          <source>UIntType</source>
          <target state="translated">UIntType</target>
        </trans-unit>
        <trans-unit id="469dc1d6169a7065a141b529a6260202a1c8ab1a" translate="yes" xml:space="preserve">
          <source>UNDERTIE - CHARACTER TIE</source>
          <target state="translated">ГАЛСТУК-БАБОЧКА</target>
        </trans-unit>
        <trans-unit id="505551a88f566bb8fb83e0abedb58180312ddfab" translate="yes" xml:space="preserve">
          <source>URBGs and distributions are designed to be used together to produce random values. All of the random number engines may be specifically seeded, serialized, and deserialized for use with repeatable simulators.</source>
          <target state="translated">URBG и распределения предназначены для совместного получения случайных значений.Все движки случайных чисел могут быть специально посеяны,сериализованы и десериализованы для использования с повторяющимися симуляторами.</target>
        </trans-unit>
        <trans-unit id="5a9da893be5fd5fae314bea8dcdeeee12beeec4b" translate="yes" xml:space="preserve">
          <source>UTF-16</source>
          <target state="translated">UTF-16</target>
        </trans-unit>
        <trans-unit id="2b2540046f34663d3e4a6d43e9cf9715c955300b" translate="yes" xml:space="preserve">
          <source>UTF-16 big-endian</source>
          <target state="translated">биг-ендиан UTF-16</target>
        </trans-unit>
        <trans-unit id="3e0f2acffc4ed45f148e707196e35bf9de816b83" translate="yes" xml:space="preserve">
          <source>UTF-16 little-endian</source>
          <target state="translated">малогабаритный бензин UTF-16</target>
        </trans-unit>
        <trans-unit id="9d90671c2d02729e29282121f3418c32309d8132" translate="yes" xml:space="preserve">
          <source>UTF-32</source>
          <target state="translated">UTF-32</target>
        </trans-unit>
        <trans-unit id="627eba919968fb21d35e780ba4de3a0334bac3b5" translate="yes" xml:space="preserve">
          <source>UTF-32(non-Windows)</source>
          <target state="translated">UTF-32(non-Windows)</target>
        </trans-unit>
        <trans-unit id="663b90c899fa25a111067be0c22ffc64dcf581c2" translate="yes" xml:space="preserve">
          <source>UTF-8</source>
          <target state="translated">UTF-8</target>
        </trans-unit>
        <trans-unit id="a2cdcc963eb83efa7c23e1cb852551ce54343476" translate="yes" xml:space="preserve">
          <source>UTF-8 (no effect on endianness)</source>
          <target state="translated">UTF-8 (не влияет на эндианность)</target>
        </trans-unit>
        <trans-unit id="e6f9cf72db2d174ebd905a64df572642f988ef15" translate="yes" xml:space="preserve">
          <source>Unary &lt;a href=&quot;operator_arithmetic#Unary_arithmetic_operators&quot;&gt;plus and minus&lt;/a&gt;</source>
          <target state="translated">Унарный &lt;a href=&quot;operator_arithmetic#Unary_arithmetic_operators&quot;&gt;плюс и минус&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f5a792933066b9a9e2ac32f6f06b8c7c9b9c310a" translate="yes" xml:space="preserve">
          <source>Unary arithmetic operators</source>
          <target state="translated">Унарные арифметические операторы</target>
        </trans-unit>
        <trans-unit id="3b2a4a75a6716bd612609078150c84a2711d8a91" translate="yes" xml:space="preserve">
          <source>UnaryTypeTrait</source>
          <target state="translated">UnaryTypeTrait</target>
        </trans-unit>
        <trans-unit id="487d4ab7256ac0a9d6c0537cc67b1af3240a7a6a" translate="yes" xml:space="preserve">
          <source>Unblocks all threads currently waiting for &lt;code&gt;*this&lt;/code&gt;.</source>
          <target state="translated">Разблокирует все темы, ожидающие &lt;code&gt;*this&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a36f6dfc5a6d8e565414aa5eb95d57c3673c1b95" translate="yes" xml:space="preserve">
          <source>Undefined Behavior</source>
          <target state="translated">неопределённое поведение</target>
        </trans-unit>
        <trans-unit id="ae22d7da41718d2107d501afa593d0dc097c049a" translate="yes" xml:space="preserve">
          <source>Undefined Behavior and Fermat&amp;rsquo;s Last Theorem</source>
          <target state="translated">Неопределенное поведение и последняя теорема Ферма</target>
        </trans-unit>
        <trans-unit id="ebb35fed37a359f87ca6b9131bfd7b210eb81cd6" translate="yes" xml:space="preserve">
          <source>Undefined behavior</source>
          <target state="translated">Неопределённое поведение</target>
        </trans-unit>
        <trans-unit id="675cd8702b8351b311d54416e35e1e88d24ddc83" translate="yes" xml:space="preserve">
          <source>Undefined behavior can result in time travel (among other things, but time travel is the funkiest)</source>
          <target state="translated">Неопределенное поведение может привести к путешествиям во времени (среди прочего,но путешествия во времени-самое забавное).</target>
        </trans-unit>
        <trans-unit id="148339d92ffb0ef43ac5c644f243daf7596715dc" translate="yes" xml:space="preserve">
          <source>Under a</source>
          <target state="translated">Под</target>
        </trans-unit>
        <trans-unit id="9b9209c5de57506f2fda8e822d2a3ad3f311f55e" translate="yes" xml:space="preserve">
          <source>Under the following circumstances, the compilers are permitted, but not required to omit the copy and move(since C++11) construction of class objects even if the copy/move(since C++11) constructor and the destructor have observable side-effects. The objects are constructed directly into the storage where they would otherwise be copied/moved to. This is an optimization: even when it takes place and the copy/move(since C++11) constructor is not called, it still must be present and accessible (as if no optimization happened at all), otherwise the program is ill-formed:</source>
          <target state="translated">При следующих обстоятельствах компиляторы допускают,но не обязаны опускать конструкцию copy и move(since C++11)объектов класса,даже если конструктор copy/move(since C++11)и деструктор имеют заметные побочные эффекты.Объекты строятся непосредственно в хранилище,куда в противном случае они были бы скопированы/перемещены.Это оптимизация:даже если она происходит и конструктор copy/move(since C++11)не вызывается,он все равно должен присутствовать и быть доступен (как будто оптимизации вообще не было),иначе программа плохо сформирована:</target>
        </trans-unit>
        <trans-unit id="3bea3f4316b2cc744d56328e836cf72a7190a46d" translate="yes" xml:space="preserve">
          <source>Under the following circumstances, the compilers are required to omit the copy and move construction of class objects, even if the copy/move constructor and the destructor have observable side-effects. The objects are constructed directly into the storage where they would otherwise be copied/moved to. The copy/move constructors need not be present or accessible, as the language rules ensure that no copy/move operation takes place, even conceptually:</source>
          <target state="translated">В следующих случаях компиляторы обязаны опускать копирование и перемещать конструкцию объектов класса,даже если конструктор copy/move и деструктор имеют заметные побочные эффекты.Объекты строятся непосредственно в хранилище,куда в противном случае они были бы скопированы/перемещены.Конструкторы копирования/перемещения не обязательно должны присутствовать или быть доступны,так как правила языка гарантируют,что операция копирования/перемещения не происходит,даже концептуально:</target>
        </trans-unit>
        <trans-unit id="9c33868b413394e75c10c66bbcac09ee4be1866f" translate="yes" xml:space="preserve">
          <source>Under these conditions, it can be shown that &lt;code&gt;e&lt;/code&gt; is an equivalence relation, and &lt;code&gt;r&lt;/code&gt; induces a strict total ordering on the equivalence classes determined by &lt;code&gt;e&lt;/code&gt;.</source>
          <target state="translated">В этих условиях можно показать, что &lt;code&gt;e&lt;/code&gt; является отношением эквивалентности, а &lt;code&gt;r&lt;/code&gt; индуцирует строгое полное упорядочение классов эквивалентности, определенных &lt;code&gt;e&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b828bc3cb0b877121715201877f23784c033074d" translate="yes" xml:space="preserve">
          <source>Underflow is guaranteed if &lt;code&gt;|arg| &amp;lt; &lt;a href=&quot;../../types/climits&quot;&gt;DBL_MIN&lt;/a&gt;*(sqrt(&amp;pi;)/2)&lt;/code&gt;  erf(</source>
          <target state="translated">Слабость гарантируется, если &lt;code&gt;|arg| &amp;lt; &lt;a href=&quot;../../types/climits&quot;&gt;DBL_MIN&lt;/a&gt;*(sqrt(&amp;pi;)/2)&lt;/code&gt; erf (</target>
        </trans-unit>
        <trans-unit id="5b4fe0953f656d5c3e07304963135e1851f6e5c7" translate="yes" xml:space="preserve">
          <source>Understanding Integer Overflow in C/C++</source>
          <target state="translated">Понимание Целочисленного Переполнения в C/C++</target>
        </trans-unit>
        <trans-unit id="5e6066d0264c25a17abb92da4543d5a1bb3137db" translate="yes" xml:space="preserve">
          <source>Unevaluated expressions</source>
          <target state="translated">Неоценённые выражения</target>
        </trans-unit>
        <trans-unit id="28df9f930dfb483b42b3b26d6ba0e60a90d200c5" translate="yes" xml:space="preserve">
          <source>Unformatted input</source>
          <target state="translated">Неформатированный ввод</target>
        </trans-unit>
        <trans-unit id="123f1fcb3edd17ce760e7f03ab6319443c344106" translate="yes" xml:space="preserve">
          <source>Unformatted input/output</source>
          <target state="translated">Неформатированный ввод/вывод</target>
        </trans-unit>
        <trans-unit id="b123c392cb4c8cf5311ee23670ea9ec4b71c524c" translate="yes" xml:space="preserve">
          <source>Unformatted output</source>
          <target state="translated">Форматированный выход</target>
        </trans-unit>
        <trans-unit id="1103a0808298976db7d8e2eb535bd8a9ef0b0697" translate="yes" xml:space="preserve">
          <source>UnformattedInputFunction</source>
          <target state="translated">UnformattedInputFunction</target>
        </trans-unit>
        <trans-unit id="57c86519dc947e7a7668db91684400955bbea92e" translate="yes" xml:space="preserve">
          <source>UnformattedOutputFunction</source>
          <target state="translated">UnformattedOutputFunction</target>
        </trans-unit>
        <trans-unit id="746515815dbd70aa366c5c8ded38ceac411af5b5" translate="yes" xml:space="preserve">
          <source>Unicode characters in identifiers</source>
          <target state="translated">Символы Юникода в идентификаторах</target>
        </trans-unit>
        <trans-unit id="54c4cd3614eda1ec572a80ea2561789d6ec07f9a" translate="yes" xml:space="preserve">
          <source>Unicode conversion facilities</source>
          <target state="translated">Средства преобразования Unicode</target>
        </trans-unit>
        <trans-unit id="518945c57eea6f988b28705fe9a73ae61f28aad7" translate="yes" xml:space="preserve">
          <source>Unicode string literals</source>
          <target state="translated">Юникод-строковые литералы</target>
        </trans-unit>
        <trans-unit id="1d88fe66c0582c456f5ec5c8716a0f875d9594aa" translate="yes" xml:space="preserve">
          <source>Uniform container erasure</source>
          <target state="translated">Единообразное стирание контейнеров</target>
        </trans-unit>
        <trans-unit id="2d5f1d913211ede3bdf584eacf2d1f866d30dd39" translate="yes" xml:space="preserve">
          <source>Uniform distributions</source>
          <target state="translated">Унифицированные распределения</target>
        </trans-unit>
        <trans-unit id="ebaf278dff4a479e5c381e2d14da13ed28569d5b" translate="yes" xml:space="preserve">
          <source>Uniform random bit generator requirements</source>
          <target state="translated">Единые требования к генератору случайных битов</target>
        </trans-unit>
        <trans-unit id="43fc79a87964e43367c8f806ef4c1bc6c3c17e50" translate="yes" xml:space="preserve">
          <source>Uniform random bit generators</source>
          <target state="translated">Унифицированные генераторы случайных битов</target>
        </trans-unit>
        <trans-unit id="304d61b117a4be33152a4987bccb311ec8786d3d" translate="yes" xml:space="preserve">
          <source>Uniform random bit generators (URBGs), which include both random number engines, which are pseudo-random number generators that generate integer sequences with a uniform distribution, and true random number generators if available;</source>
          <target state="translated">Унифицированные генераторы случайных битов (URBG),которые включают в себя как движки случайных чисел,которые являются генераторами псевдослучайных чисел,генерирующими целочисленные последовательности с равномерным распределением,так и генераторы истинных случайных чисел,если таковые имеются;</target>
        </trans-unit>
        <trans-unit id="9961b884b0d41e9f96e9b47f18701458382481af" translate="yes" xml:space="preserve">
          <source>Uniform random bit generators are not intended to be used as random number generators: they are used as the source of random bits (generated in bulk, for efficiency). Any uniform random bit generator may be plugged into any &lt;a href=&quot;../numeric/random&quot;&gt;random number distribution&lt;/a&gt; in order to obtain a random number (formally, a random variate).</source>
          <target state="translated">Унифицированные генераторы случайных битов не предназначены для использования в качестве генераторов случайных чисел: они используются в качестве источника случайных битов (генерируемых навалом, для эффективности). Любой равномерный генератор случайных битов может быть подключен к любому &lt;a href=&quot;../numeric/random&quot;&gt;распределению случайных чисел&lt;/a&gt; , чтобы получить случайное число (формально случайное изменение).</target>
        </trans-unit>
        <trans-unit id="274ada2867567ab3047cbbf8de81549c088960b3" translate="yes" xml:space="preserve">
          <source>UniformRandomBitGenerator</source>
          <target state="translated">UniformRandomBitGenerator</target>
        </trans-unit>
        <trans-unit id="a1a52383b2bc722ac899de02954f212432e3b35b" translate="yes" xml:space="preserve">
          <source>Uninitialized scalar</source>
          <target state="translated">неинициализированный скаляр</target>
        </trans-unit>
        <trans-unit id="78a4eb44ac157ac9e3cfb278647cea168bf4035b" translate="yes" xml:space="preserve">
          <source>Uninitialized storage</source>
          <target state="translated">неинициализированное хранение</target>
        </trans-unit>
        <trans-unit id="669a8f132f6da5ef9c5ce154e361c127d5e3b34d" translate="yes" xml:space="preserve">
          <source>Union declaration</source>
          <target state="translated">декларация о союзе</target>
        </trans-unit>
        <trans-unit id="8b963a92c98e754dacda8255ebe746d63728ca26" translate="yes" xml:space="preserve">
          <source>Union-like classes</source>
          <target state="translated">Союзные классы</target>
        </trans-unit>
        <trans-unit id="3c64374ae8a1f69718dd9c2a053e7f58d07b77ab" translate="yes" xml:space="preserve">
          <source>Union-like classes can be used to implement &lt;a href=&quot;https://en.wikipedia.org/wiki/Tagged_union&quot;&gt;tagged unions&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://en.wikipedia.org/wiki/Tagged_union&quot;&gt;Подобные объединению&lt;/a&gt; классы могут использоваться для реализации теговых объединений .</target>
        </trans-unit>
        <trans-unit id="b88a7a2c81e25c95a2b907495a6fc73639f9b55f" translate="yes" xml:space="preserve">
          <source>Unions cannot contain a non-static data member with a non-trivial special member function (&lt;a href=&quot;copy_constructor&quot;&gt;copy constructor&lt;/a&gt;, &lt;a href=&quot;as_operator&quot;&gt;copy-assignment&lt;/a&gt; operator, or &lt;a href=&quot;destructor&quot;&gt;destructor&lt;/a&gt;).</source>
          <target state="translated">Профсоюзы не могут содержать нестатический элемент данных с нетривиальным специальной функцией члена ( &lt;a href=&quot;copy_constructor&quot;&gt;конструктором копирования&lt;/a&gt; , &lt;a href=&quot;as_operator&quot;&gt;копирование назначения&lt;/a&gt; оператора или &lt;a href=&quot;destructor&quot;&gt;деструктора&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="bfa43e96dbedcb883a94acbaaea9cf15eba0504f" translate="yes" xml:space="preserve">
          <source>Unique integer for use as pword/iword index.</source>
          <target state="translated">Уникальное целое число для использования в качестве индекса пароль/пароль.</target>
        </trans-unit>
        <trans-unit id="d66a64b1da303d5c4d195ea302bf616e42aaa173" translate="yes" xml:space="preserve">
          <source>Unit type intended for use as a well-behaved empty alternative in &lt;code&gt;&lt;a href=&quot;../variant&quot;&gt;std::variant&lt;/a&gt;&lt;/code&gt;. In particular, a variant of non-default-constructible types may list &lt;code&gt;std::monostate&lt;/code&gt; as its first alternative: this makes the variant itself default-constructible.</source>
          <target state="translated">Тип блока, предназначенный для использования в качестве пустой пустой альтернативы в &lt;code&gt;&lt;a href=&quot;../variant&quot;&gt;std::variant&lt;/a&gt;&lt;/code&gt; . В частности, вариант не-конструируемых по умолчанию типов может перечислить &lt;code&gt;std::monostate&lt;/code&gt; качестве своей первой альтернативы: это делает сам вариант конструируемым по умолчанию.</target>
        </trans-unit>
        <trans-unit id="43b3c1af3450df3cd0e1ac52c9b04b756ccd01b6" translate="yes" xml:space="preserve">
          <source>Unix and Unix-like systems (Linux, Mac OS X)</source>
          <target state="translated">Unix и Unix-подобные системы (Linux,Mac OS X)</target>
        </trans-unit>
        <trans-unit id="efec0246344a5eba097c63d394ab6c8738a45789" translate="yes" xml:space="preserve">
          <source>Unknown permissions (e.g. when &lt;a href=&quot;file_status&quot;&gt;file_status&lt;/a&gt; is created without permissions)</source>
          <target state="translated">Неизвестные разрешения (например, когда &lt;a href=&quot;file_status&quot;&gt;file_status&lt;/a&gt; создается без разрешений)</target>
        </trans-unit>
        <trans-unit id="689c51725b427087666b6048cec59bcb29fcbece" translate="yes" xml:space="preserve">
          <source>Unknown specializations</source>
          <target state="translated">Неизвестные специализации</target>
        </trans-unit>
        <trans-unit id="fc9481ccc42310377001eaf4b65f0ba7f43291d9" translate="yes" xml:space="preserve">
          <source>Unless</source>
          <target state="translated">Unless</target>
        </trans-unit>
        <trans-unit id="2103e6143f9ffb325540052fdb6e95f6374d7553" translate="yes" xml:space="preserve">
          <source>Unless &lt;a href=&quot;../preprocessor/impl&quot;&gt;&lt;code&gt; #pragma STDC FP_CONTRACT&lt;/code&gt;&lt;/a&gt; is supported and set to &lt;code&gt;OFF&lt;/code&gt;, all floating-point arithmetic may be performed as if the intermediate results have infinite range and precision, that is, optimizations that omit rounding errors and floating-point exceptions are allowed. For example, C++ allows the implementation of &lt;code&gt;(x*y) + z&lt;/code&gt; with a single fused multiply-add CPU instruction or optimization of &lt;code&gt;a = x*x*x*x;&lt;/code&gt; as &lt;code&gt;tmp = x *x; a = tmp*tmp&lt;/code&gt;.</source>
          <target state="translated">Если только &lt;a href=&quot;../preprocessor/impl&quot;&gt; &lt;code&gt; #pragma STDC FP_CONTRACT&lt;/code&gt; &lt;/a&gt; не поддерживается и не установлен в &lt;code&gt;OFF&lt;/code&gt; , вся арифметика с плавающей точкой может выполняться так, как если бы промежуточные результаты имели бесконечный диапазон и точность, то есть допускались оптимизации, которые исключают ошибки округления и исключения с плавающей точкой. Например, C ++ допускает реализацию &lt;code&gt;(x*y) + z&lt;/code&gt; с помощью одной объединенной инструкции CPU с многократным добавлением или оптимизацию &lt;code&gt;a = x*x*x*x;&lt;/code&gt; как &lt;code&gt;tmp = x *x; a = tmp*tmp&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="07db20d2d23583077e6ea6e7dac4ed0dbdee1a6b" translate="yes" xml:space="preserve">
          <source>Unless &lt;code&gt;sync_with_stdio(false)&lt;/code&gt; has been issued, it is safe to concurrently access these objects from multiple threads for both formatted and unformatted input.</source>
          <target state="translated">Если не было выполнено &lt;code&gt;sync_with_stdio(false)&lt;/code&gt; , можно одновременно обращаться к этим объектам из нескольких потоков как для форматированного, так и для неформатированного ввода.</target>
        </trans-unit>
        <trans-unit id="24cf8fcc45f1c3c9991d569649560b6a524615c5" translate="yes" xml:space="preserve">
          <source>Unless &lt;code&gt;sync_with_stdio(false)&lt;/code&gt; has been issued, it is safe to concurrently access these objects from multiple threads for both formatted and unformatted output.</source>
          <target state="translated">Если не было выполнено &lt;code&gt;sync_with_stdio(false)&lt;/code&gt; , можно одновременно обращаться к этим объектам из нескольких потоков как для форматированного, так и для неформатированного вывода.</target>
        </trans-unit>
        <trans-unit id="ffb634a2a2ce0ccfeec2cc3fe27d921270b24978" translate="yes" xml:space="preserve">
          <source>Unless a range error occurs, &lt;a href=&quot;../fenv/fe_round&quot;&gt;the current rounding mode&lt;/a&gt; is ignored</source>
          <target state="translated">Если не происходит ошибка диапазона, &lt;a href=&quot;../fenv/fe_round&quot;&gt;текущий режим округления&lt;/a&gt; игнорируется</target>
        </trans-unit>
        <trans-unit id="b15a066b3b603647166b0b65f64183254893ada5" translate="yes" xml:space="preserve">
          <source>Unless a range error occurs, &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INEXACT&lt;/a&gt;&lt;/code&gt; is never raised (the result is exact)</source>
          <target state="translated">Если не возникает ошибка диапазона, &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INEXACT&lt;/a&gt;&lt;/code&gt; никогда не возникает (точный результат)</target>
        </trans-unit>
        <trans-unit id="7a8fedd6b20728353d81d9da733470bcfcd14b54" translate="yes" xml:space="preserve">
          <source>Unless a variable template was &lt;a href=&quot;template_specialization&quot;&gt;explicitly specialized&lt;/a&gt; or explicitly instantiated, it is implicitly instantiated when a specialization of the variable template is used.</source>
          <target state="translated">Если шаблон переменной не был &lt;a href=&quot;template_specialization&quot;&gt;явно специализирован&lt;/a&gt; или явно создан, он неявно создается, когда используется специализация шаблона переменной.</target>
        </trans-unit>
        <trans-unit id="73ad983fb74c97b086aa0802f13da903aa886831" translate="yes" xml:space="preserve">
          <source>Unless noted otherwise, every expression used in a</source>
          <target state="translated">Если не указано иное,каждое выражение,используемое в</target>
        </trans-unit>
        <trans-unit id="0e8d48b8c7d263f43322d50666aca5a3f152bb21" translate="yes" xml:space="preserve">
          <source>Unless otherwise specified, all standard library objects that have been moved from are placed in a valid but unspecified state. That is, only the functions without preconditions, such as the assignment operator, can be safely used on the object after it was moved from:</source>
          <target state="translated">Если не указано иное,все стандартные библиотечные объекты,из которых были перемещены,помещаются в действительное,но неуказанное состояние.То есть только функции без предварительных условий,такие как оператор присваивания,могут безопасно использоваться на объекте после его перемещения:</target>
        </trans-unit>
        <trans-unit id="50f2a51822d2bc1f7472ad730cc910af100ceb07" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;../optional/hash&quot;&gt;&lt;code&gt;std::hash&amp;lt;std::optional&amp;gt;&lt;/code&gt;&lt;/a&gt;, hash of a variant does not typically equal the hash of the contained value; this makes it possible to distinguish &lt;code&gt;&lt;a href=&quot;../variant&quot;&gt;std::variant&lt;/a&gt;&amp;lt;int, int&amp;gt;&lt;/code&gt; holding the same value as different alternatives.</source>
          <target state="translated">В отличие от &lt;a href=&quot;../optional/hash&quot;&gt; &lt;code&gt;std::hash&amp;lt;std::optional&amp;gt;&lt;/code&gt; &lt;/a&gt; , хэш варианта обычно не равен хешу содержащегося значения; это позволяет различать &lt;code&gt;&lt;a href=&quot;../variant&quot;&gt;std::variant&lt;/a&gt;&amp;lt;int, int&amp;gt;&lt;/code&gt; содержащий одно и то же значение, как разные альтернативы.</target>
        </trans-unit>
        <trans-unit id="338f8ce75fb81cb04c2ab9cbb733a6def87c3d13" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;inputiterator&quot;&gt;LegacyInputIterator&lt;/a&gt; and &lt;a href=&quot;outputiterator&quot;&gt;LegacyOutputIterator&lt;/a&gt;, it can be used in multipass algorithms.</source>
          <target state="translated">В отличие от &lt;a href=&quot;inputiterator&quot;&gt;LegacyInputIterator&lt;/a&gt; и &lt;a href=&quot;outputiterator&quot;&gt;LegacyOutputIterator&lt;/a&gt; , он может использоваться в многопроходных алгоритмах.</target>
        </trans-unit>
        <trans-unit id="612a7e68b15f6d911dae610df0e6c53ee095c272" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;insert&quot;&gt;insert&lt;/a&gt; or &lt;a href=&quot;emplace&quot;&gt;emplace&lt;/a&gt;, these functions do not move from rvalue arguments if the insertion does not happen, which makes it easy to manipulate maps whose values are move-only types, such as &lt;code&gt;std::map&amp;lt;std::string, std::unique_ptr&amp;lt;foo&amp;gt;&amp;gt;&lt;/code&gt;. In addition, &lt;code&gt;try_emplace&lt;/code&gt; treats the key and the arguments to the &lt;code&gt;mapped_type&lt;/code&gt; separately, unlike &lt;a href=&quot;emplace&quot;&gt;emplace&lt;/a&gt;, which requires the arguments to construct a &lt;code&gt;value_type&lt;/code&gt; (that is, a &lt;code&gt;std::pair&lt;/code&gt;).</source>
          <target state="translated">В отличие от &lt;a href=&quot;insert&quot;&gt;insert&lt;/a&gt; или &lt;a href=&quot;emplace&quot;&gt;emplace&lt;/a&gt; , эти функции не перемещаются из аргументов rvalue, если вставка не происходит, что упрощает манипулирование картами, значения которых являются типами только для перемещения, такими как &lt;code&gt;std::map&amp;lt;std::string, std::unique_ptr&amp;lt;foo&amp;gt;&amp;gt;&lt;/code&gt; . Кроме того, &lt;code&gt;try_emplace&lt;/code&gt; обрабатывает ключ и аргументы &lt;code&gt;mapped_type&lt;/code&gt; отдельно, в отличие от &lt;a href=&quot;emplace&quot;&gt;emplace&lt;/a&gt; , который требует аргументов для создания &lt;code&gt;value_type&lt;/code&gt; (то есть &lt;code&gt;std::pair&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="6875db19fce8401ca9aebbb20205b26bb728d1fd" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;insert&quot;&gt;insert&lt;/a&gt; or &lt;a href=&quot;emplace&quot;&gt;emplace&lt;/a&gt;, these functions do not move from rvalue arguments if the insertion does not happen, which makes it easy to manipulate maps whose values are move-only types, such as &lt;code&gt;std::unordered_map&amp;lt;std::string, std::unique_ptr&amp;lt;foo&amp;gt;&amp;gt;&lt;/code&gt;. In addition, &lt;code&gt;try_emplace&lt;/code&gt; treats the key and the arguments to the &lt;code&gt;mapped_type&lt;/code&gt; separately, unlike &lt;a href=&quot;emplace&quot;&gt;emplace&lt;/a&gt;, which requires the arguments to construct a &lt;code&gt;value_type&lt;/code&gt; (that is, a &lt;code&gt;std::pair&lt;/code&gt;).</source>
          <target state="translated">В отличие от &lt;a href=&quot;insert&quot;&gt;insert&lt;/a&gt; или &lt;a href=&quot;emplace&quot;&gt;emplace&lt;/a&gt; , эти функции не перемещаются из аргументов rvalue, если вставка не происходит, что упрощает манипулирование картами, значения которых являются типами только для перемещения, такими как &lt;code&gt;std::unordered_map&amp;lt;std::string, std::unique_ptr&amp;lt;foo&amp;gt;&amp;gt;&lt;/code&gt; . Кроме того, &lt;code&gt;try_emplace&lt;/code&gt; обрабатывает ключ и аргументы &lt;code&gt;mapped_type&lt;/code&gt; отдельно, в отличие от &lt;a href=&quot;emplace&quot;&gt;emplace&lt;/a&gt; , который требует аргументов для создания &lt;code&gt;value_type&lt;/code&gt; (то есть &lt;code&gt;std::pair&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="2de29ed23c34ba831619b83b8554947943971200" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;&lt;a href=&quot;../basic_string/data&quot;&gt;std::basic_string::data()&lt;/a&gt;&lt;/code&gt; and string literals, &lt;code&gt;data()&lt;/code&gt; may return a pointer to a buffer that is not null-terminated. Therefore it is typically a mistake to pass &lt;code&gt;data()&lt;/code&gt; to a routine that takes just a &lt;code&gt;const CharT*&lt;/code&gt; and expects a null-terminated string.</source>
          <target state="translated">В отличие от &lt;code&gt;&lt;a href=&quot;../basic_string/data&quot;&gt;std::basic_string::data()&lt;/a&gt;&lt;/code&gt; и строковых литералов, &lt;code&gt;data()&lt;/code&gt; может возвращать указатель на буфер, который не заканчивается нулем. Поэтому, как правило, ошибочно передавать &lt;code&gt;data()&lt;/code&gt; в подпрограмму, которая принимает только &lt;code&gt;const CharT*&lt;/code&gt; и ожидает строку с нулевым символом в конце .</target>
        </trans-unit>
        <trans-unit id="b42b73288e226f5ad79616019df229c7343f10e7" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;&lt;a href=&quot;../basic_string/operator_at&quot;&gt;std::basic_string::operator[]&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;std::basic_string_view::operator[](size())&lt;/code&gt; has undefined behavior instead of returning &lt;code&gt;CharT()&lt;/code&gt;.</source>
          <target state="translated">В отличие от &lt;code&gt;&lt;a href=&quot;../basic_string/operator_at&quot;&gt;std::basic_string::operator[]&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;std::basic_string_view::operator[](size())&lt;/code&gt; имеет неопределенное поведение вместо возврата &lt;code&gt;CharT()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="82cf3dbf0c22a41175cd7995812ae5e616d63672" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;&lt;a href=&quot;../byte/strtok&quot;&gt;std::strtok&lt;/a&gt;&lt;/code&gt;, this function does not update static storage: it stores the parser state in the user-provided location.</source>
          <target state="translated">В отличие от &lt;code&gt;&lt;a href=&quot;../byte/strtok&quot;&gt;std::strtok&lt;/a&gt;&lt;/code&gt; , эта функция не обновляет статическое хранилище: она хранит состояние анализатора в предоставленном пользователем месте.</target>
        </trans-unit>
        <trans-unit id="4887cd4b1d808c0fb500939d898308b30c68c620" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;&lt;a href=&quot;../greater&quot;&gt;std::greater&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;std::ranges::greater&lt;/code&gt; requires all six comparison operators &lt;code&gt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;lt;=&lt;/code&gt;, &lt;code&gt;&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;gt;=&lt;/code&gt;, &lt;code&gt;==&lt;/code&gt; and &lt;code&gt;!=&lt;/code&gt; to be valid (via the &lt;a href=&quot;../../../concepts/stricttotallyordered&quot;&gt;&lt;code&gt;StrictTotallyOrderedWith&lt;/code&gt;&lt;/a&gt; constraint) and is entirely defined in terms of &lt;code&gt;std::ranges::less&lt;/code&gt;. However, the implementation is free to use &lt;code&gt;operator&amp;gt;&lt;/code&gt; directly, because those concepts require the results of the comparison operators to be consistent.</source>
          <target state="translated">В отличие от &lt;code&gt;&lt;a href=&quot;../greater&quot;&gt;std::greater&lt;/a&gt;&lt;/code&gt; , для &lt;code&gt;std::ranges::greater&lt;/code&gt; требуется, чтобы все шесть операторов сравнения &lt;code&gt;&amp;lt;&lt;/code&gt; , &lt;code&gt;&amp;lt;=&lt;/code&gt; , &lt;code&gt;&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;gt;=&lt;/code&gt; , &lt;code&gt;==&lt;/code&gt; и &lt;code&gt;!=&lt;/code&gt; &lt;a href=&quot;../../../concepts/stricttotallyordered&quot;&gt; &lt;code&gt;StrictTotallyOrderedWith&lt;/code&gt; &lt;/a&gt; действительными (через ограничение StrictTotallyOrderedWith ) и полностью определены в терминах &lt;code&gt;std::ranges::less&lt;/code&gt; . Тем не менее, реализация может использовать &lt;code&gt;operator&amp;gt;&lt;/code&gt; напрямую, потому что эти концепции требуют согласованности результатов операторов сравнения.</target>
        </trans-unit>
        <trans-unit id="76b2faafc9a3dbd22464e63c0ec0383467b9c99f" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;&lt;a href=&quot;../greater_equal&quot;&gt;std::greater_equal&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;std::ranges::greater_equal&lt;/code&gt; requires all six comparison operators &lt;code&gt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;lt;=&lt;/code&gt;, &lt;code&gt;&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;gt;=&lt;/code&gt;, &lt;code&gt;==&lt;/code&gt; and &lt;code&gt;!=&lt;/code&gt; to be valid (via the &lt;a href=&quot;../../../concepts/stricttotallyordered&quot;&gt;&lt;code&gt;StrictTotallyOrderedWith&lt;/code&gt;&lt;/a&gt; constraint) and is entirely defined in terms of &lt;code&gt;std::ranges::less&lt;/code&gt;. However, the implementation is free to use &lt;code&gt;operator&amp;gt;=&lt;/code&gt; directly, because those concepts require the results of the comparison operators to be consistent.</source>
          <target state="translated">В отличие от &lt;code&gt;&lt;a href=&quot;../greater_equal&quot;&gt;std::greater_equal&lt;/a&gt;&lt;/code&gt; , для &lt;code&gt;std::ranges::greater_equal&lt;/code&gt; требуется, чтобы все шесть операторов сравнения &lt;code&gt;&amp;lt;&lt;/code&gt; , &lt;code&gt;&amp;lt;=&lt;/code&gt; , &lt;code&gt;&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;gt;=&lt;/code&gt; , &lt;code&gt;==&lt;/code&gt; и &lt;code&gt;!=&lt;/code&gt; &lt;a href=&quot;../../../concepts/stricttotallyordered&quot;&gt; &lt;code&gt;StrictTotallyOrderedWith&lt;/code&gt; &lt;/a&gt; действительными (через ограничение StrictTotallyOrderedWith ) и полностью определены в терминах &lt;code&gt;std::ranges::less&lt;/code&gt; . Однако реализация может использовать &lt;code&gt;operator&amp;gt;=&lt;/code&gt; напрямую, потому что эти концепции требуют согласованности результатов операторов сравнения.</target>
        </trans-unit>
        <trans-unit id="78dbcad5e4fbe558a33518be37657107f091659c" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;&lt;a href=&quot;../less_equal&quot;&gt;std::less_equal&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;std::ranges::less_equal&lt;/code&gt; requires all six comparison operators &lt;code&gt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;lt;=&lt;/code&gt;, &lt;code&gt;&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;gt;=&lt;/code&gt;, &lt;code&gt;==&lt;/code&gt; and &lt;code&gt;!=&lt;/code&gt; to be valid (via the &lt;a href=&quot;../../../concepts/stricttotallyordered&quot;&gt;&lt;code&gt;StrictTotallyOrderedWith&lt;/code&gt;&lt;/a&gt; constraint) and is entirely defined in terms of &lt;code&gt;std::ranges::less&lt;/code&gt;. However, the implementation is free to use &lt;code&gt;operator&amp;lt;=&lt;/code&gt; directly, because those concepts require the results of the comparison operators to be consistent.</source>
          <target state="translated">В отличие от &lt;code&gt;&lt;a href=&quot;../less_equal&quot;&gt;std::less_equal&lt;/a&gt;&lt;/code&gt; , для &lt;code&gt;std::ranges::less_equal&lt;/code&gt; требуется, чтобы все шесть операторов сравнения &lt;code&gt;&amp;lt;&lt;/code&gt; , &lt;code&gt;&amp;lt;=&lt;/code&gt; , &lt;code&gt;&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;gt;=&lt;/code&gt; , &lt;code&gt;==&lt;/code&gt; и &lt;code&gt;!=&lt;/code&gt; &lt;a href=&quot;../../../concepts/stricttotallyordered&quot;&gt; &lt;code&gt;StrictTotallyOrderedWith&lt;/code&gt; &lt;/a&gt; действительными (через ограничение StrictTotallyOrderedWith ) и полностью определены в терминах &lt;code&gt;std::ranges::less&lt;/code&gt; . Однако реализация может использовать &lt;code&gt;operator&amp;lt;=&lt;/code&gt; напрямую, потому что эти концепции требуют согласованности результатов операторов сравнения.</target>
        </trans-unit>
        <trans-unit id="98c9c16f2e98cd689703db22c46385c7c82dbbfc" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;&lt;a href=&quot;../map/operator_at&quot;&gt;std::map::operator[]&lt;/a&gt;&lt;/code&gt;, this operator never inserts a new element into the container.</source>
          <target state="translated">В отличие от &lt;code&gt;&lt;a href=&quot;../map/operator_at&quot;&gt;std::map::operator[]&lt;/a&gt;&lt;/code&gt; , этот оператор никогда не вставляет новый элемент в контейнер.</target>
        </trans-unit>
        <trans-unit id="83c22ec940642abd3fc1b2b3f91bda4fefd9187c" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;&lt;a href=&quot;../not_equal_to&quot;&gt;std::not_equal_to&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;std::ranges::not_equal_to&lt;/code&gt; requires both &lt;code&gt;==&lt;/code&gt; and &lt;code&gt;!=&lt;/code&gt; to be valid (via the &lt;a href=&quot;../../../concepts/equalitycomparable&quot;&gt;&lt;code&gt;EqualityComparableWith&lt;/code&gt;&lt;/a&gt; constraint), and is entirely defined in terms of &lt;code&gt;std::ranges::equal_to&lt;/code&gt;. However, the implementation is free to use &lt;code&gt;operator!=&lt;/code&gt; directly, because those concepts require the results of &lt;code&gt;==&lt;/code&gt; and &lt;code&gt;!=&lt;/code&gt; to be consistent.</source>
          <target state="translated">В отличие от &lt;code&gt;&lt;a href=&quot;../not_equal_to&quot;&gt;std::not_equal_to&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;std::ranges::not_equal_to&lt;/code&gt; требует, чтобы оба значения &lt;code&gt;==&lt;/code&gt; и &lt;code&gt;!=&lt;/code&gt; Были действительными (через ограничение &lt;a href=&quot;../../../concepts/equalitycomparable&quot;&gt; &lt;code&gt;EqualityComparableWith&lt;/code&gt; &lt;/a&gt; ), и полностью определены в терминах &lt;code&gt;std::ranges::equal_to&lt;/code&gt; . Тем не менее, реализация может использовать &lt;code&gt;operator!=&lt;/code&gt; Напрямую, потому что эти концепции требуют, чтобы результаты &lt;code&gt;==&lt;/code&gt; и &lt;code&gt;!=&lt;/code&gt; Были согласованными.</target>
        </trans-unit>
        <trans-unit id="a93ac31e396db5acf4776ae92718a031c6e2a35d" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;&lt;a href=&quot;../shared_ptr/make_shared&quot;&gt;std::make_shared&lt;/a&gt;&lt;/code&gt; (which has &lt;code&gt;&lt;a href=&quot;../shared_ptr/allocate_shared&quot;&gt;std::allocate_shared&lt;/a&gt;&lt;/code&gt;), &lt;code&gt;std::make_unique&lt;/code&gt; does not have an allocator-aware counterpart. A hypothetical &lt;code&gt;allocate_unique&lt;/code&gt; would be required to invent the deleter type &lt;code&gt;D&lt;/code&gt; for the &lt;code&gt;unique_ptr&amp;lt;T,D&amp;gt;&lt;/code&gt; it returns which would contain an allocator object and invoke both &lt;code&gt;destroy&lt;/code&gt; and &lt;code&gt;deallocate&lt;/code&gt; in its &lt;code&gt;operator()&lt;/code&gt;.</source>
          <target state="translated">В отличие от &lt;code&gt;&lt;a href=&quot;../shared_ptr/make_shared&quot;&gt;std::make_shared&lt;/a&gt;&lt;/code&gt; (в котором есть &lt;code&gt;&lt;a href=&quot;../shared_ptr/allocate_shared&quot;&gt;std::allocate_shared&lt;/a&gt;&lt;/code&gt; &lt;code&gt;std::make_unique&lt;/code&gt; ), std :: make_unique не имеет аналога с распределителем. Гипотетический &lt;code&gt;allocate_unique&lt;/code&gt; потребовалось бы , чтобы изобрести тип Deleter &lt;code&gt;D&lt;/code&gt; для &lt;code&gt;unique_ptr&amp;lt;T,D&amp;gt;&lt;/code&gt; он возвращает , который будет содержать объект распределителя и вызывать как &lt;code&gt;destroy&lt;/code&gt; и &lt;code&gt;deallocate&lt;/code&gt; в его &lt;code&gt;operator()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bfa95d30700702ce194a65101a9f73a0be8c3e37" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;&lt;a href=&quot;../unique_ptr&quot;&gt;std::unique_ptr&lt;/a&gt;&lt;/code&gt;, the deleter of &lt;code&gt;&lt;a href=&quot;../shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&lt;/code&gt; is invoked even if the managed pointer is null.</source>
          <target state="translated">В отличие от &lt;code&gt;&lt;a href=&quot;../unique_ptr&quot;&gt;std::unique_ptr&lt;/a&gt;&lt;/code&gt; , средство удаления &lt;code&gt;&lt;a href=&quot;../shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&lt;/code&gt; вызывается, даже если управляемый указатель имеет значение null.</target>
        </trans-unit>
        <trans-unit id="bcc84ea13a79573b43e6585e6b696a907d0811f1" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;&lt;a href=&quot;endl&quot;&gt;std::endl&lt;/a&gt;&lt;/code&gt;, this manipulator does not flush the stream.</source>
          <target state="translated">В отличие от &lt;code&gt;&lt;a href=&quot;endl&quot;&gt;std::endl&lt;/a&gt;&lt;/code&gt; , этот манипулятор не очищает поток.</target>
        </trans-unit>
        <trans-unit id="efa45df35e365dacc26b0c10d8f1d5381eb5b951" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;&lt;a href=&quot;operator_at&quot;&gt;operator[]&lt;/a&gt;&lt;/code&gt;, performs a bounds check and throws &lt;code&gt;&lt;a href=&quot;../../error/out_of_range/out_of_range&quot;&gt;std::out_of_range&lt;/a&gt;&lt;/code&gt; if &lt;code&gt;pos&lt;/code&gt; does not correspond to a valid position in the bitset.</source>
          <target state="translated">В отличие от &lt;code&gt;&lt;a href=&quot;operator_at&quot;&gt;operator[]&lt;/a&gt;&lt;/code&gt; , выполняет проверку границ и выдает &lt;code&gt;&lt;a href=&quot;../../error/out_of_range/out_of_range&quot;&gt;std::out_of_range&lt;/a&gt;&lt;/code&gt; если &lt;code&gt;pos&lt;/code&gt; не соответствует допустимой позиции в наборе битов .</target>
        </trans-unit>
        <trans-unit id="f987fe2de50e7bdc36ad5bea121ee3e9648279c4" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;&lt;a href=&quot;remove&quot;&gt;std::forward_list::remove&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;erase&lt;/code&gt; accepts heterogenous types and does not force a conversion to the container's value type before invoking the &lt;code&gt;==&lt;/code&gt; operator.</source>
          <target state="translated">В отличии от &lt;code&gt;&lt;a href=&quot;remove&quot;&gt;std::forward_list::remove&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;erase&lt;/code&gt; принимает разнородные типы и не заставит преобразования в тип значения контейнера перед вызовом &lt;code&gt;==&lt;/code&gt; оператора.</target>
        </trans-unit>
        <trans-unit id="173b793fffeab067a076675a0bbf0ba3c09de869" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;&lt;a href=&quot;remove&quot;&gt;std::list::remove&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;erase&lt;/code&gt; accepts heterogenous types and does not force a conversion to the container's value type before invoking the &lt;code&gt;==&lt;/code&gt; operator.</source>
          <target state="translated">В отличие от &lt;code&gt;&lt;a href=&quot;remove&quot;&gt;std::list::remove&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;erase&lt;/code&gt; принимает гетерогенные типы и не вызывает преобразование в тип значения контейнера перед вызовом оператора &lt;code&gt;==&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4c977d4a7c4e43375bfbd8db6568cbdff01d3089" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;&lt;a href=&quot;shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;std::unique_ptr&lt;/code&gt; may manage an object through any custom handle type that satisfies &lt;a href=&quot;../named_req/nullablepointer&quot;&gt;NullablePointer&lt;/a&gt;. This allows, for example, managing objects located in shared memory, by supplying a &lt;code&gt;Deleter&lt;/code&gt; that defines &lt;code&gt;typedef &lt;a href=&quot;http://www.boost.org/doc/libs/release/doc/html/boost/interprocess/offset_ptr.html&quot;&gt;boost::offset_ptr&lt;/a&gt; pointer;&lt;/code&gt; or another &lt;a href=&quot;../named_req/allocator#Fancy_pointers&quot;&gt;fancy pointer&lt;/a&gt;.</source>
          <target state="translated">В отличие от &lt;code&gt;&lt;a href=&quot;shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;std::unique_ptr&lt;/code&gt; может управлять объектом через любой пользовательский тип дескриптора, который удовлетворяет &lt;a href=&quot;../named_req/nullablepointer&quot;&gt;NullablePointer&lt;/a&gt; . Это позволяет, например, управлять объектами, расположенными в разделяемой памяти, предоставляя &lt;code&gt;Deleter&lt;/code&gt; , который определяет &lt;code&gt;typedef &lt;a href=&quot;http://www.boost.org/doc/libs/release/doc/html/boost/interprocess/offset_ptr.html&quot;&gt;boost::offset_ptr&lt;/a&gt; pointer;&lt;/code&gt; typedef &lt;a href=&quot;http://www.boost.org/doc/libs/release/doc/html/boost/interprocess/offset_ptr.html&quot;&gt;boost :: offset_ptr&lt;/a&gt; ; или другой &lt;a href=&quot;../named_req/allocator#Fancy_pointers&quot;&gt;причудливый указатель&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1573c755f58e9c4746c81740477c0b3b24dac236" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;&lt;a href=&quot;test&quot;&gt;test()&lt;/a&gt;&lt;/code&gt;, does not throw exceptions: the behavior is undefined if &lt;code&gt;pos&lt;/code&gt; is out of bounds.</source>
          <target state="translated">В отличие от &lt;code&gt;&lt;a href=&quot;test&quot;&gt;test()&lt;/a&gt;&lt;/code&gt; , не генерирует исключения: поведение не определено, если &lt;code&gt;pos&lt;/code&gt; выходит за пределы.</target>
        </trans-unit>
        <trans-unit id="6eba30f9f21127f9176b2a660cfad2f04c8b9efb" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;static_cast&lt;/code&gt;, but like &lt;code&gt;const_cast&lt;/code&gt;, the &lt;code&gt;reinterpret_cast&lt;/code&gt; expression does not compile to any CPU instructions (except when converting between integers and pointers or on obscure architectures where pointer representation depends on its type). It is purely a compile-time directive which instructs the compiler to treat expression as if it had the type new_type.</source>
          <target state="translated">В отличие от &lt;code&gt;static_cast&lt;/code&gt; , но, как и &lt;code&gt;const_cast&lt;/code&gt; , выражение &lt;code&gt;reinterpret_cast&lt;/code&gt; не компилируется с какими-либо инструкциями ЦП (кроме случаев преобразования между целыми числами и указателями или в неясных архитектурах, где представление указателя зависит от его типа). Это чисто директива времени компиляции, которая указывает компилятору обрабатывать выражение, как если бы оно имело тип new_type.</target>
        </trans-unit>
        <trans-unit id="f39585865906a9f2075869fd7919be30089c3370" translate="yes" xml:space="preserve">
          <source>Unlike Rule of Three, failing to provide move constructor and move assignment is usually not an error, but a missed optimization opportunity.</source>
          <target state="translated">В отличие от правила три,отсутствие конструктора перемещения и назначения перемещений обычно является не ошибкой,а упущенной возможностью оптимизации.</target>
        </trans-unit>
        <trans-unit id="57237dac9eb413318550844e3881a717ec402781" translate="yes" xml:space="preserve">
          <source>Unlike explicit constructors, which are only considered during &lt;a href=&quot;direct_initialization&quot;&gt;direct initialization&lt;/a&gt; (which includes &lt;a href=&quot;explicit_cast&quot;&gt;explicit conversions&lt;/a&gt; such as &lt;a href=&quot;static_cast&quot;&gt;static_cast&lt;/a&gt;), converting constructors are also considered during &lt;a href=&quot;copy_initialization&quot;&gt;copy initialization&lt;/a&gt;, as part of &lt;a href=&quot;implicit_cast&quot;&gt;user-defined conversion sequence&lt;/a&gt;.</source>
          <target state="translated">В отличие от явных конструкторов, которые рассматриваются только во время &lt;a href=&quot;direct_initialization&quot;&gt;прямой инициализации&lt;/a&gt; (которая включает в себя &lt;a href=&quot;explicit_cast&quot;&gt;явные преобразования,&lt;/a&gt; такие как &lt;a href=&quot;static_cast&quot;&gt;static_cast&lt;/a&gt; ), преобразовательные конструкторы также учитываются при &lt;a href=&quot;copy_initialization&quot;&gt;инициализации копирования&lt;/a&gt; , как часть определенной &lt;a href=&quot;implicit_cast&quot;&gt;пользователем последовательности преобразования&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0519031d106f159f57ffffbcb3c189318dbf95d8" translate="yes" xml:space="preserve">
          <source>Unlike for &lt;code&gt;&lt;a href=&quot;../../container/vector/clear&quot;&gt;std::vector::clear&lt;/a&gt;&lt;/code&gt;, the C++ standard does not explicitly require that &lt;code&gt;&lt;a href=&quot;capacity&quot;&gt;capacity&lt;/a&gt;&lt;/code&gt; is unchanged by this function, but existing implementations do not change capacity. This means that they do not release the allocated memory (see also &lt;code&gt;&lt;a href=&quot;shrink_to_fit&quot;&gt;shrink_to_fit&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">В отличие от &lt;code&gt;&lt;a href=&quot;../../container/vector/clear&quot;&gt;std::vector::clear&lt;/a&gt;&lt;/code&gt; , стандарт C ++ явно не требует, чтобы &lt;code&gt;&lt;a href=&quot;capacity&quot;&gt;capacity&lt;/a&gt;&lt;/code&gt; не изменялась этой функцией, но существующие реализации не изменяют емкость. Это означает, что они не освобождают выделенную память (см. Также &lt;code&gt;&lt;a href=&quot;shrink_to_fit&quot;&gt;shrink_to_fit&lt;/a&gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="005bffdc5ce748f5fa7ecab037e6b4ba23fd3f4c" translate="yes" xml:space="preserve">
          <source>Unlike formatted output functions, this function does not set the &lt;code&gt;failbit&lt;/code&gt; if the output fails.</source>
          <target state="translated">В отличие от отформатированных функций вывода, эта функция не устанавливает &lt;code&gt;failbit&lt;/code&gt; если вывод завершается ошибкой.</target>
        </trans-unit>
        <trans-unit id="c11ef1e4f5cbd932283bfef60dfc1f2ad7da6484" translate="yes" xml:space="preserve">
          <source>Unlike functions or references to functions, pointers to functions are objects and thus can be stored in arrays, copied, assigned, etc.</source>
          <target state="translated">В отличие от функций или ссылок на функции,указатели на функции являются объектами и,таким образом,могут храниться в массивах,копироваться,присваиваться и т.д.</target>
        </trans-unit>
        <trans-unit id="4fc1a9b3bf127389b70df7d40bbc2018c53338a0" translate="yes" xml:space="preserve">
          <source>Unlike header guards, this pragma makes it impossible to erroneously use the same macro name in more than one file. On the other hand, since with &lt;code&gt;#pragma once&lt;/code&gt; files are excluded based on their filesystem-level identity, this can't protect against including a header twice if it exists in more than one location in a project.</source>
          <target state="translated">В отличие от защиты заголовков, эта прагма делает невозможным ошибочное использование одного и того же имени макроса в нескольких файлах. С другой стороны, поскольку при использовании &lt;code&gt;#pragma once&lt;/code&gt; файлы исключаются на основании их идентификатора на уровне файловой системы, это не может защитить от включения заголовка дважды, если он существует в нескольких местах проекта.</target>
        </trans-unit>
        <trans-unit id="ee79da911cfc98f59e02246e9625087f966f6ee4" translate="yes" xml:space="preserve">
          <source>Unlike many related functions, this function is</source>
          <target state="translated">В отличие от многих смежных функций,эта функция</target>
        </trans-unit>
        <trans-unit id="c7ea1f99bf46737fd3a9eb5569bcdb5f3547a949" translate="yes" xml:space="preserve">
          <source>Unlike most assignment operators, the assignment operator for &lt;code&gt;atomic_ref&lt;/code&gt; does not return a reference to its left-hand argument. It returns a copy of the stored value instead.</source>
          <target state="translated">В отличие от большинства операторов присваивания, оператор присваивания для &lt;code&gt;atomic_ref&lt;/code&gt; не возвращает ссылку на свой левый аргумент. Вместо этого он возвращает копию сохраненного значения.</target>
        </trans-unit>
        <trans-unit id="1a4db73f4f2b5f3d23685150e26ab0e326ffc436" translate="yes" xml:space="preserve">
          <source>Unlike most assignment operators, the assignment operators for atomic types do not return a reference to their left-hand arguments. They return a copy of the stored value instead.</source>
          <target state="translated">В отличие от большинства операторов присваивания,операторы присваивания для атомарных типов не возвращают ссылку на их левые аргументы.Вместо этого они возвращают копию сохраненного значения.</target>
        </trans-unit>
        <trans-unit id="3697fcced78a8dc2e1dd58511d1675942ea9902d" translate="yes" xml:space="preserve">
          <source>Unlike most compound assignment operators, the compound assignment operators for &lt;code&gt;atomic_ref&lt;/code&gt; do not return a reference to their left-hand arguments. They return a copy of the stored value instead.</source>
          <target state="translated">В отличие от большинства составных операторов присваивания, составные операторы присваивания для &lt;code&gt;atomic_ref&lt;/code&gt; не возвращают ссылку на свои левые аргументы. Вместо этого они возвращают копию сохраненного значения.</target>
        </trans-unit>
        <trans-unit id="139203564aef61dc9e502ac41ea33308504a0622" translate="yes" xml:space="preserve">
          <source>Unlike most compound assignment operators, the compound assignment operators for atomic types do not return a reference to their left-hand arguments. They return a copy of the stored value instead.</source>
          <target state="translated">В отличие от большинства составных операторов присваивания,составные операторы присваивания для атомных типов не возвращают ссылки на их левые аргументы.Вместо этого они возвращают копию сохраненного значения.</target>
        </trans-unit>
        <trans-unit id="dda22864e1900bb6a87e878513e661e3ee5d8ee4" translate="yes" xml:space="preserve">
          <source>Unlike most mathematical operations, the conversion of a floating-point value to text and back is</source>
          <target state="translated">В отличие от большинства математических операций,преобразование значения с плавающей точкой в текст и обратно заключается в следующем</target>
        </trans-unit>
        <trans-unit id="76a29065db67fecaafea29ca64388623baf0bcbc" translate="yes" xml:space="preserve">
          <source>Unlike most other tokenizers, the delimiters in &lt;code&gt;std::wcstok&lt;/code&gt; can be different for each subsequent token, and can even depend on the contents of the previous tokens.</source>
          <target state="translated">В отличие от большинства других токенизаторов, разделители в &lt;code&gt;std::wcstok&lt;/code&gt; могут отличаться для каждого последующего токена и даже могут зависеть от содержимого предыдущих токенов.</target>
        </trans-unit>
        <trans-unit id="c348ec3650d4d97ed9bc09e83c2572c81d376d68" translate="yes" xml:space="preserve">
          <source>Unlike most other tokenizers, the delimiters in &lt;code&gt;strtok&lt;/code&gt; can be different for each subsequent token, and can even depend on the contents of the previous tokens.</source>
          <target state="translated">В отличие от большинства других токенизаторов, разделители в &lt;code&gt;strtok&lt;/code&gt; могут отличаться для каждого последующего токена и даже могут зависеть от содержимого предыдущих токенов.</target>
        </trans-unit>
        <trans-unit id="e499b26c05a23f391924b25bade94974b21959a1" translate="yes" xml:space="preserve">
          <source>Unlike most pre-increment and pre-decrement operators, the pre-increment and pre-decrement operators for &lt;code&gt;atomic_ref&lt;/code&gt; do not return a reference to the modified object. They return a copy of the stored value instead.</source>
          <target state="translated">В отличие от большинства операторов предварительного увеличения и предварительного уменьшения, операторы предварительного увеличения и предварительного уменьшения для &lt;code&gt;atomic_ref&lt;/code&gt; не возвращают ссылку на измененный объект. Вместо этого они возвращают копию сохраненного значения.</target>
        </trans-unit>
        <trans-unit id="247d65607595333e4901228f7023c088dbe9e552" translate="yes" xml:space="preserve">
          <source>Unlike most pre-increment and pre-decrement operators, the pre-increment and pre-decrement operators for atomic types do not return a reference to the modified object. They return a copy of the stored value instead.</source>
          <target state="translated">В отличие от большинства предикрементных и предикрементных операторов,предикрементные и предикрементные операторы для атомных типов не возвращают ссылку на модифицированный объект.Вместо этого они возвращают копию сохраненного значения.</target>
        </trans-unit>
        <trans-unit id="536f52cdb9582b6792ddf498c21f83ff3bc9d9a5" translate="yes" xml:space="preserve">
          <source>Unlike other formatting functions in C++ and C libraries, &lt;code&gt;std::to_chars&lt;/code&gt; is locale-independent, non-allocating, and non-throwing. Only a small subset of formatting policies used by other libraries (such as &lt;code&gt;&lt;a href=&quot;../io/c/printf&quot;&gt;std::sprintf&lt;/a&gt;&lt;/code&gt;) is provided. This is intended to allow the fastest possible implementation that is useful in common high-throughput contexts such as text-based interchange (JSON or XML).</source>
          <target state="translated">В отличие от других функций форматирования в библиотеках C ++ и C, &lt;code&gt;std::to_chars&lt;/code&gt; зависит от локали, не выделяется и не выбрасывает. Предоставляется только небольшое подмножество политик форматирования, используемых другими библиотеками (такими как &lt;code&gt;&lt;a href=&quot;../io/c/printf&quot;&gt;std::sprintf&lt;/a&gt;&lt;/code&gt; ). Это предназначено для обеспечения максимально быстрой реализации, которая полезна в распространенных контекстах с высокой пропускной способностью, таких как текстовый обмен (JSON или XML).</target>
        </trans-unit>
        <trans-unit id="960cf91e24a03ae762e9fec6a351793c82e6e03d" translate="yes" xml:space="preserve">
          <source>Unlike other functions that take &lt;code&gt;std::valarray&lt;/code&gt; arguments, &lt;code&gt;begin()&lt;/code&gt; cannot accept the replacement types (such as the types produced by expression templates) that may be returned from expressions involving valarrays: &lt;code&gt;&lt;a href=&quot;../../iterator/begin&quot;&gt;std::begin&lt;/a&gt;(v1 + v2)&lt;/code&gt; is not portable, &lt;code&gt;&lt;a href=&quot;../../iterator/begin&quot;&gt;std::begin&lt;/a&gt;(&lt;a href=&quot;../valarray&quot;&gt;std::valarray&lt;/a&gt;&amp;lt;T&amp;gt;(v1 + v2))&lt;/code&gt; has to be used instead.</source>
          <target state="translated">В отличие от других функций, которые принимают аргументы &lt;code&gt;std::valarray&lt;/code&gt; , &lt;code&gt;begin()&lt;/code&gt; не может принимать замещающие типы (такие как типы, созданные шаблонами выражений), которые могут быть возвращены из выражений, включающих valarrays: &lt;code&gt;&lt;a href=&quot;../../iterator/begin&quot;&gt;std::begin&lt;/a&gt;(v1 + v2)&lt;/code&gt; не является переносимым , вместо этого следует использовать &lt;code&gt;&lt;a href=&quot;../../iterator/begin&quot;&gt;std::begin&lt;/a&gt;(&lt;a href=&quot;../valarray&quot;&gt;std::valarray&lt;/a&gt;&amp;lt;T&amp;gt;(v1 + v2))&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="07020cc0a6112afa1a94ca2a985fb8992ea81c5d" translate="yes" xml:space="preserve">
          <source>Unlike other functions that take &lt;code&gt;std::valarray&lt;/code&gt; arguments, &lt;code&gt;end()&lt;/code&gt; cannot accept the replacement types (such as the types produced by expression templates) that may be returned from expressions involving valarrays: &lt;code&gt;&lt;a href=&quot;../../iterator/end&quot;&gt;std::end&lt;/a&gt;(v1 + v2)&lt;/code&gt; is not portable, &lt;code&gt;&lt;a href=&quot;../../iterator/end&quot;&gt;std::end&lt;/a&gt;(&lt;a href=&quot;../valarray&quot;&gt;std::valarray&lt;/a&gt;&amp;lt;T&amp;gt;(v1 + v2))&lt;/code&gt; has to be used instead.</source>
          <target state="translated">В отличие от других функций, которые принимают аргументы &lt;code&gt;std::valarray&lt;/code&gt; , &lt;code&gt;end()&lt;/code&gt; не может принимать замещающие типы (например, типы, созданные шаблонами выражений), которые могут быть возвращены из выражений, включающих valarrays: &lt;code&gt;&lt;a href=&quot;../../iterator/end&quot;&gt;std::end&lt;/a&gt;(v1 + v2)&lt;/code&gt; не является переносимым , вместо этого следует использовать &lt;code&gt;&lt;a href=&quot;../../iterator/end&quot;&gt;std::end&lt;/a&gt;(&lt;a href=&quot;../valarray&quot;&gt;std::valarray&lt;/a&gt;&amp;lt;T&amp;gt;(v1 + v2))&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="82b08c1bafac008cc3356484b3bea8b8da199f4c" translate="yes" xml:space="preserve">
          <source>Unlike other parsing functions in C++ and C libraries, &lt;code&gt;std::from_chars&lt;/code&gt; is locale-independent, non-allocating, and non-throwing. Only a small subset of parsing policies used by other libraries (such as &lt;code&gt;&lt;a href=&quot;../io/c/scanf&quot;&gt;std::sscanf&lt;/a&gt;&lt;/code&gt;) is provided. This is intended to allow the fastest possible implementation that is useful in common high-throughput contexts such as text-based interchange (JSON or XML).</source>
          <target state="translated">В отличие от других функций синтаксического анализа в библиотеках C ++ и C, &lt;code&gt;std::from_chars&lt;/code&gt; зависит от локали, не выделяется и не выбрасывает. Предоставляется только небольшое подмножество политик синтаксического анализа, используемых другими библиотеками (такими как &lt;code&gt;&lt;a href=&quot;../io/c/scanf&quot;&gt;std::sscanf&lt;/a&gt;&lt;/code&gt; ). Это предназначено для обеспечения максимально быстрой реализации, которая полезна в распространенных контекстах с высокой пропускной способностью, таких как текстовый обмен (JSON или XML).</target>
        </trans-unit>
        <trans-unit id="bc22867a4de3145dca568d4e66ffa742bf46b614" translate="yes" xml:space="preserve">
          <source>Unlike other temporary objects, the exception object is considered to be an lvalue argument when initializing the catch clause parameters, so it can be caught by lvalue reference, modified, and rethrown.</source>
          <target state="translated">В отличие от других временных объектов,объект исключения при инициализации параметров положения catch считается аргументом lvalue,поэтому он может быть перехвачен ссылкой на lvalue,изменен и переотброшен.</target>
        </trans-unit>
        <trans-unit id="40e4049da792f251c064108725448595e7fb81c8" translate="yes" xml:space="preserve">
          <source>Unlike the &lt;a href=&quot;../named_req/destructible&quot;&gt;Destructible&lt;/a&gt; named requirement, &lt;code&gt;std::Destructible&lt;/code&gt; requires the destructor to be &lt;code&gt;noexcept(true)&lt;/code&gt;, not merely non-throwing when invoked, and allows reference types and array types.</source>
          <target state="translated">В отличие от именованного требования &lt;a href=&quot;../named_req/destructible&quot;&gt;Destructible&lt;/a&gt; , &lt;code&gt;std::Destructible&lt;/code&gt; требует, чтобы деструктор был &lt;code&gt;noexcept(true)&lt;/code&gt; , а не просто не выбрасывал при вызове, и допускает ссылочные типы и типы массивов.</target>
        </trans-unit>
        <trans-unit id="f2ff26def44fad2ae044095e7f187e2f9c03b39d" translate="yes" xml:space="preserve">
          <source>Unlike the &lt;code&gt;&lt;a href=&quot;../shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&lt;/code&gt; constructors, &lt;code&gt;std::make_shared&lt;/code&gt; does not allow a custom deleter.</source>
          <target state="translated">В отличие от конструкторов &lt;code&gt;&lt;a href=&quot;../shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;std::make_shared&lt;/code&gt; не допускает пользовательского удаления.</target>
        </trans-unit>
        <trans-unit id="1c6f8d4294a5e322f2430ee23bff35686e775144" translate="yes" xml:space="preserve">
          <source>Unlike the primary template &lt;code&gt;&lt;a href=&quot;../ctype&quot;&gt;std::ctype&lt;/a&gt;&lt;/code&gt;, this specialization does not perform a virtual function call when classifying characters. To customize the behavior, a derived class may provide a non-default classification table to the base class constructor.</source>
          <target state="translated">В отличие от основного шаблона &lt;code&gt;&lt;a href=&quot;../ctype&quot;&gt;std::ctype&lt;/a&gt;&lt;/code&gt; , эта специализация не выполняет вызов виртуальной функции при классификации символов. Чтобы настроить поведение, производный класс может предоставить таблицу классификации не по умолчанию для конструктора базового класса.</target>
        </trans-unit>
        <trans-unit id="3a3c250893800a21b88186ef185aadaf831d7992" translate="yes" xml:space="preserve">
          <source>Unlike the promotions, numeric conversions may change the values, with potential loss of precision.</source>
          <target state="translated">В отличие от рекламных акций,числовые преобразования могут изменять значения с потенциальной потерей точности.</target>
        </trans-unit>
        <trans-unit id="5cf90c59183d16b061b44fcdd59d790f2d00de63" translate="yes" xml:space="preserve">
          <source>Unlike the rest of the algorithms, for_each is not allowed to make copies of the elements in the sequence even if they are trivially copyable.</source>
          <target state="translated">В отличие от остальных алгоритмов,for_each не разрешается делать копии элементов в последовательности,даже если они тривиально копируемы.</target>
        </trans-unit>
        <trans-unit id="db1ac6c9a5b777adb044dcf5cc2c8e1d9362ebb5" translate="yes" xml:space="preserve">
          <source>Unlike the std::shared_ptr constructors, std::allocate_shared does not accept a separate custom deleter: the supplied allocator is used for destruction of the control block and the &lt;code&gt;T&lt;/code&gt; object, and for deallocation of their shared memory block.</source>
          <target state="translated">В отличие от конструкторов std :: shared_ptr, std :: allocate_shared не допускает отдельного пользовательского удаления: предоставленный распределитель используется для уничтожения блока управления и объекта &lt;code&gt;T&lt;/code&gt; , а также для освобождения их блока совместно используемой памяти.</target>
        </trans-unit>
        <trans-unit id="66abfa107dcdc9f5699b86a1259047a6420b2c52" translate="yes" xml:space="preserve">
          <source>Unlike type template parameter declaration, template template parameter declaration can only use the keyword &lt;code&gt;class&lt;/code&gt; and not &lt;code&gt;typename&lt;/code&gt;.</source>
          <target state="translated">В отличие от объявления параметров шаблона типа, объявление параметра шаблона шаблона может использовать только ключевое слово &lt;code&gt;class&lt;/code&gt; , а не &lt;code&gt;typename&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d675911d340ea7fe2bddf254d2a266f734dde906" translate="yes" xml:space="preserve">
          <source>Unlike with &lt;code&gt;&lt;a href=&quot;append&quot;&gt;append()&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;append&quot;&gt;operator/=&lt;/a&gt;&lt;/code&gt;, additional directory separators are never introduced.</source>
          <target state="translated">В отличие от &lt;code&gt;&lt;a href=&quot;append&quot;&gt;append()&lt;/a&gt;&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;append&quot;&gt;operator/=&lt;/a&gt;&lt;/code&gt; , дополнительные разделители каталогов никогда не вводятся.</target>
        </trans-unit>
        <trans-unit id="9795510ddaf8f7b584f9cfa5390b07d1db4d7240" translate="yes" xml:space="preserve">
          <source>Unlocks the associated mutex and releases ownership.</source>
          <target state="translated">Разблокирует соответствующий мьютекс и освобождает право собственности.</target>
        </trans-unit>
        <trans-unit id="f433ee5a4f5ef551015f8cbf8189774e6d42e0da" translate="yes" xml:space="preserve">
          <source>Unlocks the associated mutex from shared mode. Effectively calls &lt;code&gt;mutex()-&amp;gt;unlock_shared()&lt;/code&gt;.</source>
          <target state="translated">Разблокирует связанный мьютекс из общего режима. Эффективно вызывает &lt;code&gt;mutex()-&amp;gt;unlock_shared()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="961e1771431741648b7410afa7f25aec8f8bb6ba" translate="yes" xml:space="preserve">
          <source>Unlocks the mutex if its level of ownership is &lt;code&gt;1&lt;/code&gt; (there was exactly one more call to &lt;code&gt;&lt;a href=&quot;lock&quot;&gt;lock()&lt;/a&gt;&lt;/code&gt; than there were calls to &lt;code&gt;unlock()&lt;/code&gt; made by this thread), reduces the level of ownership by 1 otherwise.</source>
          <target state="translated">Разблокирует мьютекс, если его уровень владения равен &lt;code&gt;1&lt;/code&gt; (было ровно на один вызов &lt;code&gt;&lt;a href=&quot;lock&quot;&gt;lock()&lt;/a&gt;&lt;/code&gt; ровнее, чем вызовы &lt;code&gt;unlock()&lt;/code&gt; сделанные этим потоком), в противном случае уровень владения уменьшается на 1.</target>
        </trans-unit>
        <trans-unit id="3292cba2e9fa684816c3433f5e680ff1211985aa" translate="yes" xml:space="preserve">
          <source>Unlocks the mutex.</source>
          <target state="translated">Отпирает мьютекс.</target>
        </trans-unit>
        <trans-unit id="e5ecb1ac5a3284b964b98f95170550776c6f7221" translate="yes" xml:space="preserve">
          <source>Unnamed functions can be generated by &lt;a href=&quot;lambda&quot;&gt;lambda-expressions&lt;/a&gt;.</source>
          <target state="translated">Безымянные функции могут быть сгенерированы &lt;a href=&quot;lambda&quot;&gt;лямбда-выражениями&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f4abed0ca00f10480f822ed4f5c54c15d912133a" translate="yes" xml:space="preserve">
          <source>Unnamed namespaces</source>
          <target state="translated">Безымянные пространства имён</target>
        </trans-unit>
        <trans-unit id="ce07e4c5885039551bddbc7d0f27189dfc040aaa" translate="yes" xml:space="preserve">
          <source>Unnamed namespaces as well as all namespaces declared directly or indirectly within an unnamed namespace have &lt;a href=&quot;storage_duration#Linkage&quot;&gt;internal linkage&lt;/a&gt;, which means that any name that is declared within an unnamed namespace has internal linkage.</source>
          <target state="translated">Неназванные пространства имен, а также все пространства имен, объявленные прямо или косвенно в безымянном пространстве имен, имеют &lt;a href=&quot;storage_duration#Linkage&quot;&gt;внутреннюю связь&lt;/a&gt; , что означает, что любое имя, объявленное в безымянном пространстве имен, имеет внутреннюю связь.</target>
        </trans-unit>
        <trans-unit id="55c746743e689c2f62e5b9408423fdd2d1439715" translate="yes" xml:space="preserve">
          <source>Unordered associative containers</source>
          <target state="translated">Неупорядоченные ассоциативные контейнеры</target>
        </trans-unit>
        <trans-unit id="67512286f8974c10c046fc1f0f6675019780544f" translate="yes" xml:space="preserve">
          <source>Unordered associative containers are &lt;a href=&quot;container&quot;&gt;Containers&lt;/a&gt; that provide fast lookup of objects based on keys. Worst case complexity is linear but on average much faster for most of the operations.</source>
          <target state="translated">Неупорядоченные ассоциативные контейнеры - это &lt;a href=&quot;container&quot;&gt;контейнеры,&lt;/a&gt; которые обеспечивают быстрый поиск объектов на основе ключей. В худшем случае сложность линейна, но в среднем намного быстрее для большинства операций.</target>
        </trans-unit>
        <trans-unit id="5721c8ff7733bb174444b2a6b021b024c56a1897" translate="yes" xml:space="preserve">
          <source>Unordered associative containers are parametrized by &lt;code&gt;Key&lt;/code&gt;; &lt;code&gt;Hash&lt;/code&gt;, a &lt;a href=&quot;hash&quot;&gt;Hash&lt;/a&gt; function object which acts as hash function on &lt;code&gt;Key&lt;/code&gt;; and &lt;code&gt;Pred&lt;/code&gt;, a &lt;a href=&quot;binarypredicate&quot;&gt;BinaryPredicate&lt;/a&gt; evaluating equivalence between &lt;code&gt;Key&lt;/code&gt;s. &lt;code&gt;&lt;a href=&quot;../container/unordered_map&quot;&gt;std::unordered_map&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../container/unordered_multimap&quot;&gt;std::unordered_multimap&lt;/a&gt;&lt;/code&gt; also have a mapped type &lt;code&gt;T&lt;/code&gt; associated with the &lt;code&gt;Key&lt;/code&gt;.</source>
          <target state="translated">Неупорядоченные ассоциативные контейнеры параметризованы &lt;code&gt;Key&lt;/code&gt; ; &lt;code&gt;Hash&lt;/code&gt; , объект функции &lt;a href=&quot;hash&quot;&gt;Hash,&lt;/a&gt; который действует как хэш-функция для &lt;code&gt;Key&lt;/code&gt; ; и &lt;code&gt;Pred&lt;/code&gt; , &lt;a href=&quot;binarypredicate&quot;&gt;BinaryPredicate,&lt;/a&gt; оценивающий эквивалентность между &lt;code&gt;Key&lt;/code&gt; s. &lt;code&gt;&lt;a href=&quot;../container/unordered_map&quot;&gt;std::unordered_map&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;../container/unordered_multimap&quot;&gt;std::unordered_multimap&lt;/a&gt;&lt;/code&gt; также имеют сопоставленный тип &lt;code&gt;T&lt;/code&gt; , связанный с &lt;code&gt;Key&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="27d0b13503ae28a6d2a746765f82094c67a9edd8" translate="yes" xml:space="preserve">
          <source>Unordered associative containers implement unsorted (hashed) data structures that can be quickly searched (O(1) amortized, O(n) worst-case complexity).</source>
          <target state="translated">В неупорядоченных ассоциативных контейнерах реализованы несортированные (хэшированные)структуры данных,которые можно быстро искать (амортизация O(1),наихудшая сложность O(n)).</target>
        </trans-unit>
        <trans-unit id="b3e4ddc4a7977312b5ea810e7307eb4d25f9ced4" translate="yes" xml:space="preserve">
          <source>Unordered associative containers in the standard library</source>
          <target state="translated">Неупорядоченные ассоциативные контейнеры в стандартной библиотеке</target>
        </trans-unit>
        <trans-unit id="9cbf323cb4f143925595576784d5b591b9699888" translate="yes" xml:space="preserve">
          <source>Unordered associative containers meet the requirements of &lt;a href=&quot;allocatorawarecontainer&quot;&gt;AllocatorAwareContainer&lt;/a&gt;. For &lt;code&gt;&lt;a href=&quot;../container/unordered_map&quot;&gt;std::unordered_map&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../container/unordered_multimap&quot;&gt;std::unordered_multimap&lt;/a&gt;&lt;/code&gt; the requirements of &lt;code&gt;value_type&lt;/code&gt; in &lt;a href=&quot;allocatorawarecontainer&quot;&gt;AllocatorAwareContainer&lt;/a&gt; apply to &lt;code&gt;key_type&lt;/code&gt; and &lt;code&gt;mapped_type&lt;/code&gt; (not to &lt;code&gt;value_type&lt;/code&gt;).</source>
          <target state="translated">Неупорядоченные ассоциативные контейнеры соответствуют требованиям &lt;a href=&quot;allocatorawarecontainer&quot;&gt;AllocatorAwareContainer&lt;/a&gt; . Для &lt;code&gt;&lt;a href=&quot;../container/unordered_map&quot;&gt;std::unordered_map&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;../container/unordered_multimap&quot;&gt;std::unordered_multimap&lt;/a&gt;&lt;/code&gt; требования &lt;code&gt;value_type&lt;/code&gt; в &lt;a href=&quot;allocatorawarecontainer&quot;&gt;AllocatorAwareContainer&lt;/a&gt; применяются к &lt;code&gt;key_type&lt;/code&gt; и &lt;code&gt;mapped_type&lt;/code&gt; (не к &lt;code&gt;value_type&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="c05e882164dc6c352b2a91db5033a7f29679961d" translate="yes" xml:space="preserve">
          <source>Unordered dynamic initialization</source>
          <target state="translated">Беспорядочная динамическая инициализация</target>
        </trans-unit>
        <trans-unit id="6f584009e4c537a97fa6a23c2a4e0d998b8f9266" translate="yes" xml:space="preserve">
          <source>Unordered map is an associative container that contains key-value pairs with unique keys. Search, insertion, and removal of elements have average constant-time complexity.</source>
          <target state="translated">Unordered map-это ассоциативный контейнер,содержащий пары ключ-значение с уникальными ключами.Поиск,вставка и удаление элементов имеют среднюю постоянную сложность.</target>
        </trans-unit>
        <trans-unit id="a040e6bfa2ff6a84c4d4e54ec666b82a142217ba" translate="yes" xml:space="preserve">
          <source>Unordered multimap is an unordered associative container that supports equivalent keys (an unordered_multimap may contain multiple copies of each key value) and that associates values of another type with the keys. The unordered_multimap class supports forward iterators. Search, insertion, and removal have average constant-time complexity.</source>
          <target state="translated">Unordered multimap-это неупорядоченный ассоциативный контейнер,поддерживающий эквивалентные ключи (unordered_multimap может содержать несколько копий значения каждого ключа)и связывающий с ключами значения другого типа.Класс unordered_multimap поддерживает прямые итераторы.Поиск,вставка и удаление имеют среднюю постоянную сложность.</target>
        </trans-unit>
        <trans-unit id="781e73a9d10b79ea8423bbe4c282e042b203ed02" translate="yes" xml:space="preserve">
          <source>Unordered multiset is an associative container that contains set of possibly non-unique objects of type Key. Search, insertion, and removal have average constant-time complexity.</source>
          <target state="translated">Унифицированный мультисет-это ассоциативный контейнер,который содержит набор возможно неунифицированных объектов типа Key.Поиск,вставка и удаление имеют среднюю постоянную сложность.</target>
        </trans-unit>
        <trans-unit id="6c35c1e1852ab51c8cfda8139fbce10f60da69d7" translate="yes" xml:space="preserve">
          <source>Unordered set is an associative container that contains a set of unique objects of type Key. Search, insertion, and removal have average constant-time complexity.</source>
          <target state="translated">Неупорядоченный набор-это ассоциативный контейнер,содержащий набор уникальных объектов типа Key.Поиск,вставка и удаление имеют среднюю постоянную сложность.</target>
        </trans-unit>
        <trans-unit id="20ec84b0a684780da8ecd14376ab54e3d64c049a" translate="yes" xml:space="preserve">
          <source>UnorderedAssociativeContainer</source>
          <target state="translated">UnorderedAssociativeContainer</target>
        </trans-unit>
        <trans-unit id="5ed38d76cf76e990be50933f309543cd72253e57" translate="yes" xml:space="preserve">
          <source>Unqualified and qualified name lookup rules for class members are detailed in &lt;a href=&quot;lookup&quot;&gt;name lookup&lt;/a&gt;.</source>
          <target state="translated">Неквалифицированные и квалифицированные правила поиска имен для членов класса подробно описаны в &lt;a href=&quot;lookup&quot;&gt;поиске имен&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a712c79b38b9542c96589abf3e1dda8d1042e2a4" translate="yes" xml:space="preserve">
          <source>Unqualified function (&lt;code&gt;abs&lt;/code&gt;) is used to perform the computation. If such function is not available, &lt;code&gt;std::abs&lt;/code&gt; is used due to argument dependent lookup.</source>
          <target state="translated">Неквалифицированная функция ( &lt;code&gt;abs&lt;/code&gt; ) используется для выполнения вычислений. Если такая функция недоступна, используется &lt;code&gt;std::abs&lt;/code&gt; из-за зависимого от аргумента поиска.</target>
        </trans-unit>
        <trans-unit id="fc119a198d533d4b0bbb7710d68460cff957292e" translate="yes" xml:space="preserve">
          <source>Unqualified function (&lt;code&gt;acos&lt;/code&gt;) is used to perform the computation. If such function is not available, &lt;code&gt;&lt;a href=&quot;../math/acos&quot;&gt;std::acos&lt;/a&gt;&lt;/code&gt; is used due to argument dependent lookup.</source>
          <target state="translated">Неквалифицированная функция ( &lt;code&gt;acos&lt;/code&gt; ) используется для выполнения вычислений. Если такая функция недоступна, используется &lt;code&gt;&lt;a href=&quot;../math/acos&quot;&gt;std::acos&lt;/a&gt;&lt;/code&gt; из-за зависимого от аргумента поиска.</target>
        </trans-unit>
        <trans-unit id="f215557e10fbc19791a7df65c388833c1a7dd11c" translate="yes" xml:space="preserve">
          <source>Unqualified function (&lt;code&gt;asin&lt;/code&gt;) is used to perform the computation. If such function is not available, &lt;code&gt;&lt;a href=&quot;../math/asin&quot;&gt;std::asin&lt;/a&gt;&lt;/code&gt; is used due to argument dependent lookup.</source>
          <target state="translated">Неквалифицированная функция ( &lt;code&gt;asin&lt;/code&gt; ) используется для выполнения вычислений. Если такая функция недоступна, используется &lt;code&gt;&lt;a href=&quot;../math/asin&quot;&gt;std::asin&lt;/a&gt;&lt;/code&gt; из-за зависимого от аргумента поиска.</target>
        </trans-unit>
        <trans-unit id="9f3c5a7de17deb7da848c19ab6e3fce9f64dca13" translate="yes" xml:space="preserve">
          <source>Unqualified function (&lt;code&gt;atan2&lt;/code&gt;) is used to perform the computation. If such function is not available, &lt;code&gt;&lt;a href=&quot;../math/atan2&quot;&gt;std::atan2&lt;/a&gt;&lt;/code&gt; is used due to argument dependent lookup.</source>
          <target state="translated">Неквалифицированная функция ( &lt;code&gt;atan2&lt;/code&gt; ) используется для выполнения вычислений. Если такая функция недоступна, используется &lt;code&gt;&lt;a href=&quot;../math/atan2&quot;&gt;std::atan2&lt;/a&gt;&lt;/code&gt; из-за зависимого от аргумента поиска.</target>
        </trans-unit>
        <trans-unit id="fa3a701b0983c693521c1ddd5947f77acceaace8" translate="yes" xml:space="preserve">
          <source>Unqualified function (&lt;code&gt;atan&lt;/code&gt;) is used to perform the computation. If such function is not available, &lt;code&gt;&lt;a href=&quot;../math/atan&quot;&gt;std::atan&lt;/a&gt;&lt;/code&gt; is used due to argument dependent lookup.</source>
          <target state="translated">Неквалифицированная функция ( &lt;code&gt;atan&lt;/code&gt; ) используется для выполнения вычислений. Если такая функция недоступна, используется &lt;code&gt;&lt;a href=&quot;../math/atan&quot;&gt;std::atan&lt;/a&gt;&lt;/code&gt; из-за зависимого от аргумента поиска.</target>
        </trans-unit>
        <trans-unit id="39d51e27856339476f1d01bf7073fed7dc2b3dbb" translate="yes" xml:space="preserve">
          <source>Unqualified function (&lt;code&gt;cos&lt;/code&gt;) is used to perform the computation. If such function is not available, &lt;code&gt;&lt;a href=&quot;../math/cos&quot;&gt;std::cos&lt;/a&gt;&lt;/code&gt; is used due to argument dependent lookup.</source>
          <target state="translated">Неквалифицированная функция ( &lt;code&gt;cos&lt;/code&gt; ) используется для выполнения вычислений. Если такая функция недоступна, используется &lt;code&gt;&lt;a href=&quot;../math/cos&quot;&gt;std::cos&lt;/a&gt;&lt;/code&gt; из-за зависимого от аргумента поиска.</target>
        </trans-unit>
        <trans-unit id="dbf3b6db25b09f0814d7e5a7fef391df5875da2a" translate="yes" xml:space="preserve">
          <source>Unqualified function (&lt;code&gt;cosh&lt;/code&gt;) is used to perform the computation. If such function is not available, &lt;code&gt;&lt;a href=&quot;../math/cosh&quot;&gt;std::cosh&lt;/a&gt;&lt;/code&gt; is used due to argument dependent lookup.</source>
          <target state="translated">Неквалифицированная функция ( &lt;code&gt;cosh&lt;/code&gt; ) используется для выполнения вычислений. Если такая функция недоступна, используется &lt;code&gt;&lt;a href=&quot;../math/cosh&quot;&gt;std::cosh&lt;/a&gt;&lt;/code&gt; из-за зависимого от аргумента поиска.</target>
        </trans-unit>
        <trans-unit id="e8abb5dd0c771afacf6766178d00da2ba065a2ec" translate="yes" xml:space="preserve">
          <source>Unqualified function (&lt;code&gt;exp&lt;/code&gt;) is used to perform the computation. If such function is not available, &lt;code&gt;&lt;a href=&quot;../math/exp&quot;&gt;std::exp&lt;/a&gt;&lt;/code&gt; is used due to argument dependent lookup.</source>
          <target state="translated">Неквалифицированная функция ( &lt;code&gt;exp&lt;/code&gt; ) используется для выполнения вычислений. Если такая функция недоступна, используется &lt;code&gt;&lt;a href=&quot;../math/exp&quot;&gt;std::exp&lt;/a&gt;&lt;/code&gt; из-за зависимого от аргумента поиска.</target>
        </trans-unit>
        <trans-unit id="dd8575417503ea5be7c9d78fb49d54a74a502a5c" translate="yes" xml:space="preserve">
          <source>Unqualified function (&lt;code&gt;log10&lt;/code&gt;) is used to perform the computation. If such function is not available, &lt;code&gt;&lt;a href=&quot;../math/log10&quot;&gt;std::log10&lt;/a&gt;&lt;/code&gt; is used due to argument dependent lookup.</source>
          <target state="translated">Неквалифицированная функция ( &lt;code&gt;log10&lt;/code&gt; ) используется для выполнения вычислений. Если такая функция недоступна, используется &lt;code&gt;&lt;a href=&quot;../math/log10&quot;&gt;std::log10&lt;/a&gt;&lt;/code&gt; из-за зависимого от аргумента поиска.</target>
        </trans-unit>
        <trans-unit id="42fd42135c1c4e85d3b6e8229754e9d9e009486f" translate="yes" xml:space="preserve">
          <source>Unqualified function (&lt;code&gt;log&lt;/code&gt;) is used to perform the computation. If such function is not available, &lt;code&gt;&lt;a href=&quot;../math/log&quot;&gt;std::log&lt;/a&gt;&lt;/code&gt; is used due to argument dependent lookup.</source>
          <target state="translated">Неквалифицированная функция ( &lt;code&gt;log&lt;/code&gt; ) используется для выполнения вычислений. Если такая функция недоступна, используется &lt;code&gt;&lt;a href=&quot;../math/log&quot;&gt;std::log&lt;/a&gt;&lt;/code&gt; из-за зависимого от аргумента поиска.</target>
        </trans-unit>
        <trans-unit id="a8f42595543cd910c448cec8e9b024326f375da5" translate="yes" xml:space="preserve">
          <source>Unqualified function (&lt;code&gt;pow&lt;/code&gt;) is used to perform the computation. If such function is not available, &lt;code&gt;&lt;a href=&quot;../math/pow&quot;&gt;std::pow&lt;/a&gt;&lt;/code&gt; is used due to argument dependent lookup.</source>
          <target state="translated">Неквалифицированная функция ( &lt;code&gt;pow&lt;/code&gt; ) используется для выполнения вычислений. Если такая функция недоступна, используется &lt;code&gt;&lt;a href=&quot;../math/pow&quot;&gt;std::pow&lt;/a&gt;&lt;/code&gt; из-за зависимого от аргумента поиска.</target>
        </trans-unit>
        <trans-unit id="0b45579c9b454c00347186dba4b670a1612acd28" translate="yes" xml:space="preserve">
          <source>Unqualified function (&lt;code&gt;sin&lt;/code&gt;) is used to perform the computation. If such function is not available, &lt;code&gt;&lt;a href=&quot;../math/sin&quot;&gt;std::sin&lt;/a&gt;&lt;/code&gt; is used due to argument dependent lookup.</source>
          <target state="translated">Неквалифицированная функция ( &lt;code&gt;sin&lt;/code&gt; ) используется для выполнения вычислений. Если такая функция недоступна, используется &lt;code&gt;&lt;a href=&quot;../math/sin&quot;&gt;std::sin&lt;/a&gt;&lt;/code&gt; из-за зависимого от аргумента поиска.</target>
        </trans-unit>
        <trans-unit id="609a5411e92bb2e442b9695a0c7f1a35b0bcda38" translate="yes" xml:space="preserve">
          <source>Unqualified function (&lt;code&gt;sinh&lt;/code&gt;) is used to perform the computation. If such function is not available, &lt;code&gt;&lt;a href=&quot;../math/sinh&quot;&gt;std::sinh&lt;/a&gt;&lt;/code&gt; is used due to argument dependent lookup.</source>
          <target state="translated">Неквалифицированная функция ( &lt;code&gt;sinh&lt;/code&gt; ) используется для выполнения вычислений. Если такая функция недоступна, используется &lt;code&gt;&lt;a href=&quot;../math/sinh&quot;&gt;std::sinh&lt;/a&gt;&lt;/code&gt; из-за зависимого от аргумента поиска.</target>
        </trans-unit>
        <trans-unit id="c0b2457b178abb1fbcd11ec0b12722a8184da253" translate="yes" xml:space="preserve">
          <source>Unqualified function (&lt;code&gt;sqrt&lt;/code&gt;) is used to perform the computation. If such function is not available, &lt;code&gt;&lt;a href=&quot;../math/sqrt&quot;&gt;std::sqrt&lt;/a&gt;&lt;/code&gt; is used due to argument dependent lookup.</source>
          <target state="translated">Неквалифицированная функция ( &lt;code&gt;sqrt&lt;/code&gt; ) используется для выполнения вычислений. Если такая функция недоступна, используется &lt;code&gt;&lt;a href=&quot;../math/sqrt&quot;&gt;std::sqrt&lt;/a&gt;&lt;/code&gt; из-за зависимого от аргумента поиска.</target>
        </trans-unit>
        <trans-unit id="fa91ca5ff514fc595bf3f51f24fdd9e313d69b9c" translate="yes" xml:space="preserve">
          <source>Unqualified function (&lt;code&gt;tan&lt;/code&gt;) is used to perform the computation. If such function is not available, &lt;code&gt;&lt;a href=&quot;../math/tan&quot;&gt;std::tan&lt;/a&gt;&lt;/code&gt; is used due to argument dependent lookup.</source>
          <target state="translated">Неквалифицированная функция ( &lt;code&gt;tan&lt;/code&gt; ) используется для выполнения вычислений. Если такая функция недоступна, используется &lt;code&gt;&lt;a href=&quot;../math/tan&quot;&gt;std::tan&lt;/a&gt;&lt;/code&gt; из-за зависимого от аргумента поиска.</target>
        </trans-unit>
        <trans-unit id="d2d13c70f9b62f9ac241cafdef0b167740b73e83" translate="yes" xml:space="preserve">
          <source>Unqualified function (&lt;code&gt;tanh&lt;/code&gt;) is used to perform the computation. If such function is not available, &lt;code&gt;&lt;a href=&quot;../math/tanh&quot;&gt;std::tanh&lt;/a&gt;&lt;/code&gt; is used due to argument dependent lookup.</source>
          <target state="translated">Неквалифицированная функция ( &lt;code&gt;tanh&lt;/code&gt; ) используется для выполнения вычислений. Если такая функция недоступна, используется &lt;code&gt;&lt;a href=&quot;../math/tanh&quot;&gt;std::tanh&lt;/a&gt;&lt;/code&gt; из-за зависимого от аргумента поиска.</target>
        </trans-unit>
        <trans-unit id="5e538cf96d743b1733d4cf064e3d13d77d3aa646" translate="yes" xml:space="preserve">
          <source>Unqualified identifiers</source>
          <target state="translated">Неквалифицированные идентификаторы</target>
        </trans-unit>
        <trans-unit id="30683cf405f082292810a7676e96130ea1ebbac6" translate="yes" xml:space="preserve">
          <source>Unqualified name lookup</source>
          <target state="translated">Безоговорочный поиск имени</target>
        </trans-unit>
        <trans-unit id="42e9848a70274fa4e3ee76d98636ebc5974dc7bd" translate="yes" xml:space="preserve">
          <source>Unqualified name lookup of the name used to the left of the function-call operator (and, equivalently, operator in an expression) is described in &lt;a href=&quot;adl&quot;&gt;argument-dependent lookup&lt;/a&gt;.</source>
          <target state="translated">Неквалифицированный поиск имени, используемого слева от оператора вызова функции (и, что эквивалентно, оператора в выражении), описан в &lt;a href=&quot;adl&quot;&gt;зависимом от аргумента поиске&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="79648146553ba52f72840dfe58fd2d9c089e5fda" translate="yes" xml:space="preserve">
          <source>Unqualified name lookup that finds static members of &lt;code&gt;B&lt;/code&gt;, nested types of &lt;code&gt;B&lt;/code&gt;, and enumerators declared in &lt;code&gt;B&lt;/code&gt; is unambiguous even if there are multiple non-virtual base subobjects of type &lt;code&gt;B&lt;/code&gt; in the inheritance tree of the class being examined:</source>
          <target state="translated">Неполный поиск имени, который находит статические члены &lt;code&gt;B&lt;/code&gt; , вложенные типы &lt;code&gt;B&lt;/code&gt; и перечисленные в &lt;code&gt;B&lt;/code&gt; перечислители, является однозначным, даже если в дереве наследования исследуемого класса есть несколько не виртуальных базовых подобъектов типа &lt;code&gt;B&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="f0214ce4cc35b4369eeab0b471b29274746a99bb" translate="yes" xml:space="preserve">
          <source>Unregisters a range earlier registered with &lt;code&gt;&lt;a href=&quot;declare_no_pointers&quot;&gt;std::declare_no_pointers&lt;/a&gt;()&lt;/code&gt;.</source>
          <target state="translated">Отмена регистрации диапазона, ранее зарегистрированного с помощью &lt;code&gt;&lt;a href=&quot;declare_no_pointers&quot;&gt;std::declare_no_pointers&lt;/a&gt;()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="866d0de5757a1581405e841976c7443463cb9f92" translate="yes" xml:space="preserve">
          <source>Unrelated to contracting, intermediate results of floating-point arithmetic may have range and precision that is different from the one indicated by its type, see &lt;code&gt;&lt;a href=&quot;../types/climits/flt_eval_method&quot;&gt;FLT_EVAL_METHOD&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Не связанные с сокращением, промежуточные результаты арифметики с плавающей точкой могут иметь диапазон и точность, отличные от указанных в его типе, см. &lt;code&gt;&lt;a href=&quot;../types/climits/flt_eval_method&quot;&gt;FLT_EVAL_METHOD&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c38c9bea005b30ba6a290df566acf1664518f308" translate="yes" xml:space="preserve">
          <source>Unscoped enumeration</source>
          <target state="translated">нерассмотренный перечень</target>
        </trans-unit>
        <trans-unit id="6222e920759d4ffc44da225d807dad755988a0aa" translate="yes" xml:space="preserve">
          <source>Unscoped enumeration type</source>
          <target state="translated">Неопознанный тип перечисления</target>
        </trans-unit>
        <trans-unit id="326065904fc6d55f14165c03f41503850d0a81df" translate="yes" xml:space="preserve">
          <source>Unsequenced execution policies are the only case where function calls are</source>
          <target state="translated">Политики непоследовательного выполнения являются единственным случаем,когда вызовы функций являются следующими</target>
        </trans-unit>
        <trans-unit id="001f5aa9e95578bdbf624cdd233afcd23b9e1b0b" translate="yes" xml:space="preserve">
          <source>Unsets the formatting flags identified by &lt;code&gt;flags&lt;/code&gt;.</source>
          <target state="translated">Сбрасывает флаги форматирования, обозначенные &lt;code&gt;flags&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e58bf16bb4075ebd2ecdad4cd86deb15d7942bb7" translate="yes" xml:space="preserve">
          <source>Unsigned integer arithmetic is always performed modulo 2n</source>
          <target state="translated">Беззнаковая целочисленная арифметика всегда выполняется по модулю 2n</target>
        </trans-unit>
        <trans-unit id="73db4e2949bacc582e416479a510daae92386ab7" translate="yes" xml:space="preserve">
          <source>Unsigned integer of at least 32 bits</source>
          <target state="translated">Беззнаковое целое число не менее 32 бит</target>
        </trans-unit>
        <trans-unit id="4e7bbf9fbab3d07bb38581701f9d99705350278e" translate="yes" xml:space="preserve">
          <source>Unsigned integer type (usually &lt;code&gt;&lt;a href=&quot;../types/size_t&quot;&gt;std::size_t&lt;/a&gt;&lt;/code&gt;)</source>
          <target state="translated">Целочисленный тип без знака (обычно &lt;code&gt;&lt;a href=&quot;../types/size_t&quot;&gt;std::size_t&lt;/a&gt;&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="1569ce9087643318f5b374c7177d610cac24614f" translate="yes" xml:space="preserve">
          <source>Unsigned integers : maximum value</source>
          <target state="translated">Беззнаковые целые числа:максимальное значение</target>
        </trans-unit>
        <trans-unit id="6fe5f2a61d9b8437ce58885d4aebe34e13639a40" translate="yes" xml:space="preserve">
          <source>UnsignedIntegral</source>
          <target state="translated">UnsignedIntegral</target>
        </trans-unit>
        <trans-unit id="5097984a5f9238c911d1b186817d23c6f3bcfe68" translate="yes" xml:space="preserve">
          <source>Unspecified order</source>
          <target state="translated">Неопределённый порядок</target>
        </trans-unit>
        <trans-unit id="d37821663cc5797b1388ccb9821c1c66f6dc7be6" translate="yes" xml:space="preserve">
          <source>Unspecified.</source>
          <target state="translated">Unspecified.</target>
        </trans-unit>
        <trans-unit id="42bff37b51ec7b1fccab4a5d361519fa088bb006" translate="yes" xml:space="preserve">
          <source>Unsupported C headers</source>
          <target state="translated">Неподдерживаемые заголовки C</target>
        </trans-unit>
        <trans-unit id="3910cc8152231b6ede905978fe57cac1a0d03d97" translate="yes" xml:space="preserve">
          <source>Until &lt;a href=&quot;http://open-std.org/JTC1/SC22/WG21/docs/cwg_defects.html#1558&quot;&gt;CWG 1558&lt;/a&gt; (a C++14 defect), unused parameters in &lt;a href=&quot;../language/type_alias&quot;&gt;alias templates&lt;/a&gt; were not guaranteed to ensure SFINAE and could be ignored, so earlier compilers require a more complex definition of &lt;code&gt;void_t&lt;/code&gt;, such as.</source>
          <target state="translated">До &lt;a href=&quot;http://open-std.org/JTC1/SC22/WG21/docs/cwg_defects.html#1558&quot;&gt;CWG 1558&lt;/a&gt; (дефект C ++ 14) неиспользуемые параметры в &lt;a href=&quot;../language/type_alias&quot;&gt;шаблонах псевдонимов&lt;/a&gt; не гарантировали SFINAE и могли игнорироваться, поэтому более ранние компиляторы требовали более сложного определения &lt;code&gt;void_t&lt;/code&gt; , такого как.</target>
        </trans-unit>
        <trans-unit id="f7718ae633302ee609828ca76d3c8d3d51cfea89" translate="yes" xml:space="preserve">
          <source>Until C++11, &lt;code&gt;auto&lt;/code&gt; had the semantic of a &lt;a href=&quot;storage_duration&quot;&gt;storage duration specifier&lt;/a&gt;.</source>
          <target state="translated">До C ++ 11 &lt;code&gt;auto&lt;/code&gt; имел семантику &lt;a href=&quot;storage_duration&quot;&gt;спецификатора продолжительности хранения&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="965548c423c2af9ebf773d28ec036a9f63c4b83f" translate="yes" xml:space="preserve">
          <source>Until C++11, aggregate initialization could not be used in a constructor initializer list due to syntax restrictions.</source>
          <target state="translated">До появления C++11 агрегированная инициализация не могла быть использована в списке инициализатора конструктора из-за ограничений синтаксиса.</target>
        </trans-unit>
        <trans-unit id="9f555151d6b7d5f7a9ff7843af6a57a54b0a5819" translate="yes" xml:space="preserve">
          <source>Until C++11, classes that overloaded &lt;code&gt;operator&amp;amp;&lt;/code&gt; were not CopyConstructible and thus weren't usable in the standard library containers. As of C++11, the standard library uses &lt;code&gt;&lt;a href=&quot;../memory/addressof&quot;&gt;std::addressof&lt;/a&gt;&lt;/code&gt; whenever the address of an object is needed.</source>
          <target state="translated">До C ++ 11 классы, которые перегружали &lt;code&gt;operator&amp;amp;&lt;/code&gt; не были CopyConstructible и, следовательно, не могли использоваться в контейнерах стандартной библиотеки. Начиная с C ++ 11, стандартная библиотека использует &lt;code&gt;&lt;a href=&quot;../memory/addressof&quot;&gt;std::addressof&lt;/a&gt;&lt;/code&gt; всякий раз, когда требуется адрес объекта.</target>
        </trans-unit>
        <trans-unit id="9f5f5ea9e92fa642a1d809852878c2987d57848b" translate="yes" xml:space="preserve">
          <source>Until C++11, it was unspecified whether &lt;code&gt;basic_streambuf&lt;/code&gt; or any of its derived classes is &lt;a href=&quot;../../named_req/copyconstructible&quot;&gt;CopyConstructible&lt;/a&gt; (&lt;a href=&quot;http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#421&quot;&gt;LWG issue 421&lt;/a&gt;), and different C++ library implementations provided different options.</source>
          <target state="translated">До C ++ 11 не было определено, является ли &lt;code&gt;basic_streambuf&lt;/code&gt; или какой-либо из его производных классов &lt;a href=&quot;../../named_req/copyconstructible&quot;&gt;CopyConstructible&lt;/a&gt; ( &lt;a href=&quot;http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#421&quot;&gt;выпуск 421 &lt;/a&gt;LWG ), и различные реализации библиотеки C ++ предоставляли разные опции.</target>
        </trans-unit>
        <trans-unit id="328855c59d216dad3422e6e98a3125cd6d816dcf" translate="yes" xml:space="preserve">
          <source>Until C++11, narrowing conversions were permitted in aggregate initialization, but they are no longer allowed, except that, as of C++20, they are allowed when aggregate initialization uses round parentheses.</source>
          <target state="translated">До С++11 сужающие преобразования разрешались при совокупной инициализации,но они больше не разрешены,за исключением того,что,начиная с С++20,они разрешены при совокупной инициализации с использованием круглых скобок.</target>
        </trans-unit>
        <trans-unit id="6e17e7cb9fc8a5970b94833c26c3d5625cb274e1" translate="yes" xml:space="preserve">
          <source>Until C++11, the rounding direction of the quotient and the sign of the remainder in the &lt;a href=&quot;../../language/operator_arithmetic&quot;&gt;built-in division and remainder operators&lt;/a&gt; was implementation-defined if either of the operands was negative, but it was well-defined in &lt;code&gt;std::div&lt;/code&gt;.</source>
          <target state="translated">До C ++ 11 направление округления фактора и знака остатка во &lt;a href=&quot;../../language/operator_arithmetic&quot;&gt;встроенных операторах деления и остатка&lt;/a&gt; определялось реализацией, если любой из операндов был отрицательным, но он был четко определен в &lt;code&gt;std::div&lt;/code&gt; ,</target>
        </trans-unit>
        <trans-unit id="2dd75578b3cf163fd9cdf707fa3febbd8933afe1" translate="yes" xml:space="preserve">
          <source>Until C++11, which introduced &lt;code&gt;&lt;a href=&quot;../../atomic/atomic&quot;&gt;std::atomic&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../../atomic/atomic_signal_fence&quot;&gt;std::atomic_signal_fence&lt;/a&gt;&lt;/code&gt;, about the only thing a strictly conforming program could do in a signal handler was to assign a value to a &lt;code&gt;volatile static std::sig_atomic_t&lt;/code&gt; variable and promptly return.</source>
          <target state="translated">До C ++ 11, в котором были введены &lt;code&gt;&lt;a href=&quot;../../atomic/atomic&quot;&gt;std::atomic&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;../../atomic/atomic_signal_fence&quot;&gt;std::atomic_signal_fence&lt;/a&gt;&lt;/code&gt; , единственной вещью, которую строго соответствующая программа могла сделать в обработчике сигнала, было присвоение значения &lt;code&gt;volatile static std::sig_atomic_t&lt;/code&gt; переменной std :: sig_atomic_t и быстрый возврат.</target>
        </trans-unit>
        <trans-unit id="4d3ae3907e74b1b45f48b10e1e68c5b46d8f4619" translate="yes" xml:space="preserve">
          <source>Until C++14, the direct-initialization form &lt;code&gt;T a {args..}&lt;/code&gt; did not permit brace elision.</source>
          <target state="translated">До C ++ 14 форма прямой инициализации &lt;code&gt;T a {args..}&lt;/code&gt; не позволяла исключать скобки.</target>
        </trans-unit>
        <trans-unit id="7f752f60fcef0ea971b808f8f6eaf483ad584079" translate="yes" xml:space="preserve">
          <source>Until C++17, a function could not return a tuple using list-initialization:</source>
          <target state="translated">До появления C++17 функция не могла вернуть кортеж с помощью инициализированного списка:</target>
        </trans-unit>
        <trans-unit id="58fb383e77b7fb0335ad97e0f3c210c1e1d6f098" translate="yes" xml:space="preserve">
          <source>Until the introduction of explicit conversion functions in C++11, designing a class that should be usable in boolean contexts (e.g. &lt;code&gt;if(obj) { ... }&lt;/code&gt;) presented a problem: given a user-defined conversion function, such as &lt;code&gt;T::operator bool() const;&lt;/code&gt;, the implicit conversion sequence allowed one additional standard conversion sequence after that function call, which means the resultant &lt;code&gt;bool&lt;/code&gt; could be converted to &lt;code&gt;int&lt;/code&gt;, allowing such code as &lt;code&gt;obj &amp;lt;&amp;lt; 1;&lt;/code&gt; or &lt;code&gt;int i = obj;&lt;/code&gt;.</source>
          <target state="translated">До появления функций явного преобразования в C ++ 11 проектирование класса, который должен использоваться в логических контекстах (например, &lt;code&gt;if(obj) { ... }&lt;/code&gt; ), представляло проблему: учитывая определяемую пользователем функцию преобразования, такую ​​как &lt;code&gt;T::operator bool() const;&lt;/code&gt; последовательность неявного преобразования допускает одну дополнительную стандартную последовательность преобразования после этого вызова функции, что означает, что результирующий &lt;code&gt;bool&lt;/code&gt; может быть преобразован в &lt;code&gt;int&lt;/code&gt; , что позволяет использовать такой код как &lt;code&gt;obj &amp;lt;&amp;lt; 1;&lt;/code&gt; или &lt;code&gt;int i = obj;&lt;/code&gt; ,</target>
        </trans-unit>
        <trans-unit id="b46999a4d771dcf596a583d2c8bf0dbc1bb017bc" translate="yes" xml:space="preserve">
          <source>Until variable templates were introduced in C++14, parametrized variables were typically implemented as either static data members of class templates or as constexpr function templates returning the desired values.</source>
          <target state="translated">До появления шаблонов переменных в C++14 параметризованные переменные,как правило,реализовывались либо как статические члены данных в шаблонах классов,либо как шаблоны функций constexpr,возвращающие нужные значения.</target>
        </trans-unit>
        <trans-unit id="c65bb8e4818155db56e2464c0be89b93b4aa7fb0" translate="yes" xml:space="preserve">
          <source>Upon return to the scope of &lt;code&gt;setjmp&lt;/code&gt;, all accessible objects, floating-point status flags, and other components of the abstract machine have the same values as they had when &lt;code&gt;&lt;a href=&quot;longjmp&quot;&gt;std::longjmp&lt;/a&gt;&lt;/code&gt; was executed, except for the non-&lt;a href=&quot;../../language/cv&quot;&gt;volatile&lt;/a&gt; local variables in &lt;code&gt;setjmp&lt;/code&gt;'s scope, whose values are indeterminate if they have been changed since the setjmp invocation.</source>
          <target state="translated">После возврата в область действия &lt;code&gt;setjmp&lt;/code&gt; все доступные объекты, флаги состояния с плавающей запятой и другие компоненты абстрактной машины имеют те же значения, что и при &lt;code&gt;&lt;a href=&quot;longjmp&quot;&gt;std::longjmp&lt;/a&gt;&lt;/code&gt; , за исключением &lt;a href=&quot;../../language/cv&quot;&gt;энергонезависимых&lt;/a&gt; локальных переменных в &lt;code&gt;setjmp&lt;/code&gt; область действия, значения которой являются неопределенными, если они были изменены после вызова setjmp.</target>
        </trans-unit>
        <trans-unit id="30e91e701960bb8a2f2ddc9e70cec3e0f356f152" translate="yes" xml:space="preserve">
          <source>Uppercase version of &lt;code&gt;ch&lt;/code&gt; or unmodified &lt;code&gt;ch&lt;/code&gt; if no uppercase version is listed in the current C locale.</source>
          <target state="translated">Прописная версия &lt;code&gt;ch&lt;/code&gt; или немодифицированная &lt;code&gt;ch&lt;/code&gt; , если в текущей локали C версия верхнего регистра не указана.</target>
        </trans-unit>
        <trans-unit id="0bb18642b70b9f8a9c12ccf39487328f306b8e19" translate="yes" xml:space="preserve">
          <source>Usage</source>
          <target state="translated">Usage</target>
        </trans-unit>
        <trans-unit id="e2fa3e294a40d353ff7bd0279d846fe85eb6a460" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;mem_fn&lt;/code&gt; to store and execute a member function and a member object:</source>
          <target state="translated">Используйте &lt;code&gt;mem_fn&lt;/code&gt; для хранения и выполнения функции-члена и объекта-члена:</target>
        </trans-unit>
        <trans-unit id="ccd4cdfea5815983783eb398f954b34dd3308ca2" translate="yes" xml:space="preserve">
          <source>Use ECMAScript rules to construct strings in &lt;code&gt;&lt;a href=&quot;regex_replace&quot;&gt;std::regex_replace&lt;/a&gt;&lt;/code&gt; (&lt;a href=&quot;http://ecma-international.org/ecma-262/5.1/#sec-15.5.4.11&quot;&gt;syntax documentation&lt;/a&gt;)</source>
          <target state="translated">Используйте правила ECMAScript для создания строк в &lt;code&gt;&lt;a href=&quot;regex_replace&quot;&gt;std::regex_replace&lt;/a&gt;&lt;/code&gt; ( &lt;a href=&quot;http://ecma-international.org/ecma-262/5.1/#sec-15.5.4.11&quot;&gt;синтаксическая документация&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="7d2ca269005572f7dcc4f93975b5006fe75b32fe" translate="yes" xml:space="preserve">
          <source>Use POSIX</source>
          <target state="translated">Использовать POSIX</target>
        </trans-unit>
        <trans-unit id="59088c12cff257aabcfd96c2bff5eb6d63196ace" translate="yes" xml:space="preserve">
          <source>Use of an indeterminate value obtained by default-initializing a non-class variable of any type is &lt;a href=&quot;ub&quot;&gt;undefined behavior&lt;/a&gt; (in particular, it may be a &lt;a href=&quot;objects#Object_representation_and_value_representation&quot;&gt;trap representation&lt;/a&gt;), except in the following cases:</source>
          <target state="translated">Использование неопределенного значения, полученного при инициализации по умолчанию не относящейся к классу переменной любого типа, является &lt;a href=&quot;ub&quot;&gt;неопределенным поведением&lt;/a&gt; (в частности, это может быть представление &lt;a href=&quot;objects#Object_representation_and_value_representation&quot;&gt;прерывания&lt;/a&gt; ), за исключением следующих случаев:</target>
        </trans-unit>
        <trans-unit id="1343357d8857f07ed216045e4630d2360702830a" translate="yes" xml:space="preserve">
          <source>Use of pImpl requires a dedicated translation unit (a header-only library cannot use pImpl), introduces an additional class, a set of forwarding functions, and, if allocators are used, exposes the implementation detail of allocator use in the public interface.</source>
          <target state="translated">Использование pImpl требует наличия специального модуля трансляции (библиотека,работающая только с заголовками,не может использовать pImpl),вводит дополнительный класс,набор функций переадресации и,в случае использования аллокаторов,раскрывает подробности реализации использования аллокаторов в публичном интерфейсе.</target>
        </trans-unit>
        <trans-unit id="5c95344b6a2f2f118527f061626aec54628cfeac" translate="yes" xml:space="preserve">
          <source>Use of this invalid value as an argument to any &lt;code&gt;&lt;a href=&quot;../io/basic_istream&quot;&gt;std::istream&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../io/basic_ostream&quot;&gt;std::ostream&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../io/basic_streambuf&quot;&gt;std::streambuf&lt;/a&gt;&lt;/code&gt; member taking a value of this type is undefined behaviour</source>
          <target state="translated">Использование этого недопустимого значения в качестве аргумента в любой &lt;code&gt;&lt;a href=&quot;../io/basic_istream&quot;&gt;std::istream&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../io/basic_ostream&quot;&gt;std::ostream&lt;/a&gt;&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;../io/basic_streambuf&quot;&gt;std::streambuf&lt;/a&gt;&lt;/code&gt; член принимает значение этого типа не определено поведение</target>
        </trans-unit>
        <trans-unit id="6eb61fe88f9155e92fd5505231d51581c0a1f378" translate="yes" xml:space="preserve">
          <source>Use the &lt;a href=&quot;http://en.cppreference.com/w/cpp/regex/ecmascript&quot;&gt;Modified ECMAScript regular expression grammar&lt;/a&gt;</source>
          <target state="translated">Используйте &lt;a href=&quot;http://en.cppreference.com/w/cpp/regex/ecmascript&quot;&gt;Модифицированную грамматику регулярного выражения ECMAScript&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="0b59f8d4a6e7623991a4148e772aefe99cb9c959" translate="yes" xml:space="preserve">
          <source>Use the basic POSIX regular expression grammar (&lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap09.html#tag_09_03&quot;&gt;grammar documentation&lt;/a&gt;).</source>
          <target state="translated">Используйте базовую грамматику регулярных выражений POSIX ( &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap09.html#tag_09_03&quot;&gt;грамматическая документация&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="4032118ad7e10c8a56fe81c51513bcd0f4198612" translate="yes" xml:space="preserve">
          <source>Use the extended POSIX regular expression grammar (&lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap09.html#tag_09_04&quot;&gt;grammar documentation&lt;/a&gt;).</source>
          <target state="translated">Используйте расширенную грамматику регулярных выражений POSIX ( &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap09.html#tag_09_04&quot;&gt;грамматическая документация&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="efdfc5f80485169681a19ba23803d6f84ff4e293" translate="yes" xml:space="preserve">
          <source>Use the regular expression grammar used by the</source>
          <target state="translated">Используйте грамматику регулярного выражения,используемую в</target>
        </trans-unit>
        <trans-unit id="b6f72b04e0e8a80cecbd0a1176096ac1763ecf62" translate="yes" xml:space="preserve">
          <source>Used as a more readable equivalent to the traditional &lt;a href=&quot;for&quot;&gt; for loop&lt;/a&gt; operating over a range of values, such as all elements in a container.</source>
          <target state="translated">Используется в качестве более удобочитаемого эквивалента традиционному &lt;a href=&quot;for&quot;&gt;циклу for,&lt;/a&gt; работающему в диапазоне значений, таких как все элементы в контейнере.</target>
        </trans-unit>
        <trans-unit id="5a1c568d8c824c8779a7fbd4ddf0353bf241da96" translate="yes" xml:space="preserve">
          <source>Used fields</source>
          <target state="translated">Использованные поля</target>
        </trans-unit>
        <trans-unit id="df4ac21ba90d03bbec4f8d92680ff358bb022c1a" translate="yes" xml:space="preserve">
          <source>Used to mark a &lt;a href=&quot;../language/class_template&quot;&gt;template definition&lt;/a&gt;</source>
          <target state="translated">Используется для обозначения &lt;a href=&quot;../language/class_template&quot;&gt;определения шаблона&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="af59dbcc1c5fb76dabc78981244f1492f92bd30a" translate="yes" xml:space="preserve">
          <source>Used to refer to the character type</source>
          <target state="translated">Используется для обозначения типа символа</target>
        </trans-unit>
        <trans-unit id="452240ee9951387e7059a7bfdc9cc878fb58e6e5" translate="yes" xml:space="preserve">
          <source>Used to refer to the character type.</source>
          <target state="translated">Используется для обозначения типа символов.</target>
        </trans-unit>
        <trans-unit id="0411cff330fe1f926e098add76bac8d23f3a24cd" translate="yes" xml:space="preserve">
          <source>Used when actual size of the object must be known.</source>
          <target state="translated">Используется,когда реальный размер объекта должен быть известен.</target>
        </trans-unit>
        <trans-unit id="cd3a7677f14605e188f81a1607ce0b998a59e8fc" translate="yes" xml:space="preserve">
          <source>Used when it is otherwise awkward to ignore the remaining portion of the loop using conditional statements.</source>
          <target state="translated">Используется,когда в противном случае неудобно игнорировать оставшуюся часть цикла,используя условные операторы.</target>
        </trans-unit>
        <trans-unit id="73641814b8ae560f3493eb824a0db1bde1f528d6" translate="yes" xml:space="preserve">
          <source>Used when it is otherwise awkward to terminate the loop using the condition expression and conditional statements.</source>
          <target state="translated">Используется,когда в противном случае неудобно завершить цикл,используя выражение условия и условные операторы.</target>
        </trans-unit>
        <trans-unit id="e80aa66e106a415e8288da7170c66b3a43f1b6c5" translate="yes" xml:space="preserve">
          <source>Used when it is otherwise impossible to transfer control to the desired location using other statements.</source>
          <target state="translated">Используется,когда в противном случае невозможно передать управление в нужное место с помощью других утверждений.</target>
        </trans-unit>
        <trans-unit id="7062a1fb9e1b49180bc64e78c1788d8e78b97581" translate="yes" xml:space="preserve">
          <source>Used where code needs to be executed based on a run-time or compile-time condition.</source>
          <target state="translated">Используется в тех случаях,когда код должен быть выполнен на основе условия выполнения или компиляции.</target>
        </trans-unit>
        <trans-unit id="bf16483f532d4a8853cf1010caa2cb57d0f33c2f" translate="yes" xml:space="preserve">
          <source>Used where the &lt;a href=&quot;type-id#Dynamic_type&quot;&gt;dynamic type&lt;/a&gt; of a &lt;a href=&quot;objects#Polymorphic_objects&quot;&gt;polymorphic object&lt;/a&gt; must be known and for static type identification.</source>
          <target state="translated">Используется , когда &lt;a href=&quot;type-id#Dynamic_type&quot;&gt;тип динамический&lt;/a&gt; из &lt;a href=&quot;objects#Polymorphic_objects&quot;&gt;полиморфного объекта&lt;/a&gt; должен быть известен и для идентификации статического типа.</target>
        </trans-unit>
        <trans-unit id="42d90e90aadfee8047aec9690cf0574d0347d7d2" translate="yes" xml:space="preserve">
          <source>User code should usually use &lt;code&gt;std::chrono::clock_cast&lt;/code&gt;, which provides a generic interface to convert time points between clocks, rather than call these functions directly.</source>
          <target state="translated">Пользовательский код обычно должен использовать &lt;code&gt;std::chrono::clock_cast&lt;/code&gt; , который предоставляет универсальный интерфейс для преобразования временных точек между часами, а не вызывать эти функции напрямую.</target>
        </trans-unit>
        <trans-unit id="22f079a53befe874a015e16af5dac8a9dbe1d7c3" translate="yes" xml:space="preserve">
          <source>User replacement versions of global &lt;a href=&quot;../new/operator_new&quot;&gt;&lt;code&gt;operator new&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../new/operator_delete&quot;&gt;&lt;code&gt;operator delete&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">Замененные пользователем версии глобального &lt;a href=&quot;../new/operator_new&quot;&gt; &lt;code&gt;operator new&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;../new/operator_delete&quot;&gt; &lt;code&gt;operator delete&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="beecf2d4915648f8f0efab35c62b4b57d5f5b1df" translate="yes" xml:space="preserve">
          <source>User replacement versions of global &lt;a href=&quot;operator_new&quot;&gt;&lt;code&gt;operator new&lt;/code&gt;&lt;/a&gt; and &lt;strong&gt;&lt;code&gt;operator delete&lt;/code&gt;&lt;/strong&gt;</source>
          <target state="translated">Замененные пользователем версии глобального &lt;a href=&quot;operator_new&quot;&gt; &lt;code&gt;operator new&lt;/code&gt; &lt;/a&gt; и &lt;strong&gt; &lt;code&gt;operator delete&lt;/code&gt; &lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="36a2cff95d451b8ddda6e6fad777fc4eedb46043" translate="yes" xml:space="preserve">
          <source>User replacement versions of global &lt;strong&gt;&lt;code&gt;operator new&lt;/code&gt;&lt;/strong&gt; and &lt;a href=&quot;operator_delete&quot;&gt;&lt;code&gt;operator delete&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">Замененные пользователем версии глобального &lt;strong&gt; &lt;code&gt;operator new&lt;/code&gt; &lt;/strong&gt; и &lt;a href=&quot;operator_delete&quot;&gt; &lt;code&gt;operator delete&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f9aac68f1811d0c886372a7b6aa12dfd47145f36" translate="yes" xml:space="preserve">
          <source>User specializations may define the member type &lt;code&gt;iterator_concept&lt;/code&gt; to one of &lt;a href=&quot;iterator_tags&quot;&gt;iterator category tags&lt;/a&gt;, to indicate conformance to the iterator concepts.</source>
          <target state="translated">Пользовательские специализации могут определять тип элемента &lt;code&gt;iterator_concept&lt;/code&gt; для одного из &lt;a href=&quot;iterator_tags&quot;&gt;тегов категории итератора&lt;/a&gt; , чтобы указывать на соответствие концепциям итератора.</target>
        </trans-unit>
        <trans-unit id="691620a9d9530e81a0d5cd25eb278071f62c4739" translate="yes" xml:space="preserve">
          <source>User-Defined Literals</source>
          <target state="translated">Определяемые пользователем литералы</target>
        </trans-unit>
        <trans-unit id="d55e108d604fa5cfa1e00711a9ffe9ad9af9acb8" translate="yes" xml:space="preserve">
          <source>User-defined Literals for std::complex</source>
          <target state="translated">Определяемые пользователем литералы для std::complex</target>
        </trans-unit>
        <trans-unit id="66b100ca6f92096c7cc2adfb8fd94dcf564c734d" translate="yes" xml:space="preserve">
          <source>User-defined character traits may be used to provide &lt;a href=&quot;http://www.gotw.ca/gotw/029.htm&quot;&gt;case-insensitive comparison&lt;/a&gt;.</source>
          <target state="translated">Определенные пользователем черты характера можно использовать для &lt;a href=&quot;http://www.gotw.ca/gotw/029.htm&quot;&gt;сравнения без учета регистра&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="521384c0aef8e04b593ebebfeb20da581eaab716" translate="yes" xml:space="preserve">
          <source>User-defined classes and enumerations that implement the requirements of &lt;a href=&quot;../named_req/bitmasktype&quot;&gt;BitmaskType&lt;/a&gt; are required to overload the bitwise arithmetic operators &lt;code&gt;operator&amp;amp;&lt;/code&gt;, &lt;code&gt;operator|&lt;/code&gt;, &lt;code&gt;operator^&lt;/code&gt;, &lt;code&gt;operator~&lt;/code&gt;, &lt;code&gt;operator&amp;amp;=&lt;/code&gt;, &lt;code&gt;operator|=&lt;/code&gt;, and &lt;code&gt;operator^=&lt;/code&gt;, and may optionally overload the shift operators &lt;code&gt;operator&amp;lt;&amp;lt;&lt;/code&gt;&lt;code&gt;operator&amp;gt;&amp;gt;&lt;/code&gt;, &lt;code&gt;operator&amp;gt;&amp;gt;=&lt;/code&gt;, and &lt;code&gt;operator&amp;lt;&amp;lt;=&lt;/code&gt;. The canonical implementations usually follow the pattern for binary arithmetic operators described above.</source>
          <target state="translated">Определенные пользователем классы и перечисления, которые реализуют требования &lt;a href=&quot;../named_req/bitmasktype&quot;&gt;BitmaskType&lt;/a&gt; , необходимы для перегрузки побитовых арифметических операторов &lt;code&gt;operator&amp;amp;&lt;/code&gt; , &lt;code&gt;operator|&lt;/code&gt; , &lt;code&gt;operator^&lt;/code&gt; , &lt;code&gt;operator~&lt;/code&gt; , &lt;code&gt;operator&amp;amp;=&lt;/code&gt; , &lt;code&gt;operator|=&lt;/code&gt; , а &lt;code&gt;operator^=&lt;/code&gt; , и необязательно может перегрузить операторы сдвига &lt;code&gt;operator&amp;lt;&amp;lt;&lt;/code&gt; &lt;code&gt;operator&amp;gt;&amp;gt;&lt;/code&gt; , &lt;code&gt;operator&amp;gt;&amp;gt;=&lt;/code&gt; , а &lt;code&gt;operator&amp;lt;&amp;lt;=&lt;/code&gt; . Канонические реализации обычно следуют шаблону для двоичных арифметических операторов, описанному выше.</target>
        </trans-unit>
        <trans-unit id="41ab182df7e7de75a62a46e254284df8495915ff" translate="yes" xml:space="preserve">
          <source>User-defined classes that provide array-like access that allows both reading and writing typically define two overloads for &lt;code&gt;operator[]&lt;/code&gt;: const and non-const variants:</source>
          <target state="translated">Определяемые пользователем классы, предоставляющие доступ в виде массива, который позволяет как чтение, так и запись, обычно определяют две перегрузки для &lt;code&gt;operator[]&lt;/code&gt; : константный и неконстантный варианты:</target>
        </trans-unit>
        <trans-unit id="9759d0c809ae6bc40bb8a39c15779393d91b25b2" translate="yes" xml:space="preserve">
          <source>User-defined conversion function is invoked on the second stage of the &lt;a href=&quot;implicit_cast&quot;&gt;implicit conversion&lt;/a&gt;, which consists of zero or one &lt;a href=&quot;converting_constructor&quot;&gt;converting constructor&lt;/a&gt; or zero or one user-defined conversion function.</source>
          <target state="translated">Определяемая пользователем функция преобразования вызывается на втором этапе &lt;a href=&quot;implicit_cast&quot;&gt;неявного преобразования&lt;/a&gt; , который состоит из нуля или одного &lt;a href=&quot;converting_constructor&quot;&gt;конструктора преобразования&lt;/a&gt; или нуля или одной пользовательской функции преобразования.</target>
        </trans-unit>
        <trans-unit id="43fb76a0004d3479d12ac1d1092e34daa13fde1a" translate="yes" xml:space="preserve">
          <source>User-defined conversions (both converting constructors and user-defined conversion functions) are prohibited from taking part in implicit conversion sequence where it would make it possible to apply more than one user-defined conversion. Specifically, they are not considered if the target of the conversion is the first parameter of a constructor or the implicit object parameter of a user-defined conversion function, and that constructor/user-defined conversion is a candidate for.</source>
          <target state="translated">Пользовательские преобразования (как конструкторы преобразования,так и пользовательские функции преобразования)запрещены в неявной последовательности преобразования,где это позволило бы применить более одного пользовательского преобразования.В частности,они не рассматриваются,если целью преобразования является первый параметр конструктора или параметр неявного объекта пользовательской функции преобразования,а также если конструктор/пользовательское преобразование является кандидатом.</target>
        </trans-unit>
        <trans-unit id="c8869104cf44d820cb55c49ce74b8353880870a6" translate="yes" xml:space="preserve">
          <source>User-defined deduction guides</source>
          <target state="translated">Пользовательские руководства по вычетам</target>
        </trans-unit>
        <trans-unit id="ef26f7121e5a45ae6e617a4103dcbb63ab5dc3ab" translate="yes" xml:space="preserve">
          <source>User-defined deduction guides do not have to be templates:</source>
          <target state="translated">Пользовательские руководства по вычетам не обязательно должны быть шаблонами:</target>
        </trans-unit>
        <trans-unit id="ada924d219c774c38ebbaa26b6b0ac7bd8284f27" translate="yes" xml:space="preserve">
          <source>User-defined deduction guides must name a class template and must be introduced within the same semantic scope of the class template (which could be namespace or enclosing class) and, for a member class template, must have the same access, but deduction guides do not become members of that scope.</source>
          <target state="translated">Пользовательское руководство по вычетам должно давать имя шаблону класса и должно быть введено в той же семантической области видимости шаблона класса (которая может быть пространством имён или закрывающим классом),и для шаблона класса-участника должно иметь тот же доступ,но руководство по вычетам не становится членом этой области видимости.</target>
        </trans-unit>
        <trans-unit id="9f7140ad8b86562edf1af76c7b4d2ecd3daf0a05" translate="yes" xml:space="preserve">
          <source>User-defined literals</source>
          <target state="translated">Пользовательские литературы</target>
        </trans-unit>
        <trans-unit id="27875895c12b2d250978e1e13877f06ad81a62ef" translate="yes" xml:space="preserve">
          <source>User-defined literals (since C++11)</source>
          <target state="translated">Пользовательские литералы (начиная с C++11)</target>
        </trans-unit>
        <trans-unit id="f9e1a4e3fe3d8c4879519e8d07a0503e9a4c9e72" translate="yes" xml:space="preserve">
          <source>User-defined literals for string types</source>
          <target state="translated">Пользовательские литералы для строковых типов</target>
        </trans-unit>
        <trans-unit id="d0490dae080d561474031e5c0e2c4ef6347ced31" translate="yes" xml:space="preserve">
          <source>User-defined literals for time types</source>
          <target state="translated">Определяемые пользователем литералы для типов времени</target>
        </trans-unit>
        <trans-unit id="fc5e25714db01eb56b2bf86b5e7921777fc9f4c1" translate="yes" xml:space="preserve">
          <source>User-defined overloads</source>
          <target state="translated">Определяемые пользователем перегрузки</target>
        </trans-unit>
        <trans-unit id="33745b553a69e48bb26d5d43ad7a22124cb88491" translate="yes" xml:space="preserve">
          <source>User-defined overloads of &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; or &lt;code&gt;||&lt;/code&gt; have no effect on constraint normalization.</source>
          <target state="translated">Определяемые пользователем перегрузки &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; или &lt;code&gt;||&lt;/code&gt; не влияет на нормализацию ограничений.</target>
        </trans-unit>
        <trans-unit id="9d6ddc3c3044ee87f524355e003d05e7748d65d0" translate="yes" xml:space="preserve">
          <source>Users cannot construct &lt;code&gt;leap&lt;/code&gt; objects except by copying from existing &lt;code&gt;leap&lt;/code&gt; objects. The library implementation creates &lt;code&gt;leap&lt;/code&gt; objects when it initializes the time zone database and provides &lt;code&gt;const&lt;/code&gt; access to these objects.</source>
          <target state="translated">Пользователи не могут создавать объекты &lt;code&gt;leap&lt;/code&gt; кроме как путем копирования из существующих объектов &lt;code&gt;leap&lt;/code&gt; . Реализация библиотеки создает &lt;code&gt;leap&lt;/code&gt; объекты при инициализации базы данных часовых поясов и обеспечивает &lt;code&gt;const&lt;/code&gt; доступ к этим объектам.</target>
        </trans-unit>
        <trans-unit id="f9e764d8a62224f28652f9477d145424640947d7" translate="yes" xml:space="preserve">
          <source>Users cannot construct &lt;code&gt;link&lt;/code&gt; objects. The library implementation creates &lt;code&gt;link&lt;/code&gt; objects when it initializes the time zone database and provides &lt;code&gt;const&lt;/code&gt; access to these objects.</source>
          <target state="translated">Пользователи не могут создавать объекты &lt;code&gt;link&lt;/code&gt; . Реализация библиотеки создает &lt;code&gt;link&lt;/code&gt; объекты при инициализации базы данных часовых поясов и обеспечивает &lt;code&gt;const&lt;/code&gt; доступ к этим объектам.</target>
        </trans-unit>
        <trans-unit id="af2f54042c747b54c3093610083361c67a39fbfd" translate="yes" xml:space="preserve">
          <source>Users cannot construct &lt;code&gt;time_zone&lt;/code&gt; objects. The library implementation creates &lt;code&gt;time_zone&lt;/code&gt; objects when it initializes the time zone database and provides &lt;code&gt;const&lt;/code&gt; access to these objects.</source>
          <target state="translated">Пользователи не могут &lt;code&gt;time_zone&lt;/code&gt; объекты time_zone . Реализация библиотеки создает &lt;code&gt;time_zone&lt;/code&gt; объектов при инициализации базы данных часовых поясов и обеспечивает &lt;code&gt;const&lt;/code&gt; доступ к этим объектам.</target>
        </trans-unit>
        <trans-unit id="946304840b5dd2cc7ea35261e0218a4ed1cc1b01" translate="yes" xml:space="preserve">
          <source>Users may derive from &lt;code&gt;view_base&lt;/code&gt; or specialize &lt;code&gt;enable_view&lt;/code&gt; to &lt;code&gt;true&lt;/code&gt; for types which model &lt;code&gt;View&lt;/code&gt;, and specialize &lt;code&gt;enable_view&lt;/code&gt; to &lt;code&gt;false&lt;/code&gt; for types which do not.</source>
          <target state="translated">Пользователи могут наследовать от &lt;code&gt;view_base&lt;/code&gt; или специализировать &lt;code&gt;enable_view&lt;/code&gt; на &lt;code&gt;true&lt;/code&gt; для типов, которые моделируют &lt;code&gt;View&lt;/code&gt; , и специализировать &lt;code&gt;enable_view&lt;/code&gt; на &lt;code&gt;false&lt;/code&gt; для типов, которые этого не делают.</target>
        </trans-unit>
        <trans-unit id="d77619d2d2aeedbc5912e54a11fc69314fc4b9b4" translate="yes" xml:space="preserve">
          <source>Users may specialize &lt;code&gt;common_type&lt;/code&gt; for types &lt;code&gt;T1&lt;/code&gt; and &lt;code&gt;T2&lt;/code&gt; if.</source>
          <target state="translated">Пользователи могут специализировать &lt;code&gt;common_type&lt;/code&gt; для типов &lt;code&gt;T1&lt;/code&gt; и &lt;code&gt;T2&lt;/code&gt; , если.</target>
        </trans-unit>
        <trans-unit id="44312d9b5ba550e3bf714285fd931d65780211eb" translate="yes" xml:space="preserve">
          <source>Uses base class pword storage for runtime type identification of derived stream objects.</source>
          <target state="translated">Использует хранилище паролей базового класса для идентификации типа исполнения объектов производного потока.</target>
        </trans-unit>
        <trans-unit id="435dd26a3c29e79ab39283f08d206249de9658d9" translate="yes" xml:space="preserve">
          <source>Uses native_handle to enable realtime scheduling of C++ threads on a POSIX system.</source>
          <target state="translated">Использует родной_хэндл для включения в реальном времени планирования потоков C++на POSIX-системе.</target>
        </trans-unit>
        <trans-unit id="47d9c5030129b909d30f38ba61ff22e289ed4dc7" translate="yes" xml:space="preserve">
          <source>Uses the allocator &lt;code&gt;a&lt;/code&gt; to allocate &lt;code&gt;n*sizeof(Alloc::value_type)&lt;/code&gt; bytes of uninitialized storage.</source>
          <target state="translated">Использует распределитель &lt;code&gt;a&lt;/code&gt; для выделения &lt;code&gt;n*sizeof(Alloc::value_type)&lt;/code&gt; байтов неинициализированной памяти.</target>
        </trans-unit>
        <trans-unit id="5774066b9e43fa4c8cddba29af3f1729deeb9d50" translate="yes" xml:space="preserve">
          <source>Uses the allocator &lt;code&gt;a&lt;/code&gt; to deallocate the storage referenced by &lt;code&gt;p&lt;/code&gt;, by calling &lt;code&gt;a.deallocate(p, n)&lt;/code&gt;.</source>
          <target state="translated">Использует распределитель &lt;code&gt;a&lt;/code&gt; для освобождения хранилища, на которое ссылается &lt;code&gt;p&lt;/code&gt; , путем вызова &lt;code&gt;a.deallocate(p, n)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1ba97051617e132658e923e2cd0500400c48654b" translate="yes" xml:space="preserve">
          <source>Uses the outer allocator to allocate uninitialized storage.</source>
          <target state="translated">Использует внешний аллокатор для выделения неинициализированного хранилища.</target>
        </trans-unit>
        <trans-unit id="b3f5f74569dd5173607ac926d852b70e7c657155" translate="yes" xml:space="preserve">
          <source>Uses the outer allocator to call the destructor of the object pointed to by &lt;code&gt;p&lt;/code&gt;, by calling.</source>
          <target state="translated">Использует внешний распределитель для вызова деструктора объекта, на который указывает &lt;code&gt;p&lt;/code&gt; , путем вызова.</target>
        </trans-unit>
        <trans-unit id="1233805d22778d94a1a1092f4fdeffec6effe4da" translate="yes" xml:space="preserve">
          <source>Uses the outer allocator to deallocate the storage referenced by &lt;code&gt;p&lt;/code&gt;, by calling &lt;code&gt;&lt;a href=&quot;../allocator_traits&quot;&gt;std::allocator_traits&lt;/a&gt;&amp;lt;OuterAlloc&amp;gt;::deallocate(outer_allocator(), p, n)&lt;/code&gt;.</source>
          <target state="translated">Использует внешний распределитель для освобождения хранилища, на которое ссылается &lt;code&gt;p&lt;/code&gt; , путем вызова &lt;code&gt;&lt;a href=&quot;../allocator_traits&quot;&gt;std::allocator_traits&lt;/a&gt;&amp;lt;OuterAlloc&amp;gt;::deallocate(outer_allocator(), p, n)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9d6bd96d2b4bc007cec5dbc13bffdb43818c467e" translate="yes" xml:space="preserve">
          <source>Uses-allocator construction</source>
          <target state="translated">Использование-распределительная конструкция</target>
        </trans-unit>
        <trans-unit id="e8ccfd79bce11a76a3f0a27cd61f22c4be4a0529" translate="yes" xml:space="preserve">
          <source>Using a member typedef or alias template in a constructor or constructor template's parameter list does not, by itself, render the corresponding parameter of the implicitly generated guide a non-deduced context.</source>
          <target state="translated">Использование шаблона типа typeedef или alias в списке параметров конструктора или шаблона конструктора само по себе не выводит соответствующий параметр неявно сгенерированного руководства в невычитаемый контекст.</target>
        </trans-unit>
        <trans-unit id="3973ba3748f277f1b1247e46879f1a5b0ff12c85" translate="yes" xml:space="preserve">
          <source>Using this library may require additional compiler/linker options. GNU implementation requires linking with &lt;code&gt;-lstdc++fs&lt;/code&gt; and LLVM implementation requires linking with &lt;code&gt;-lc++fs&lt;/code&gt;.</source>
          <target state="translated">Использование этой библиотеки может потребовать дополнительных опций компилятора / компоновщика. Реализация GNU требует соединения с &lt;code&gt;-lstdc++fs&lt;/code&gt; а реализация LLVM требует соединения с &lt;code&gt;-lc++fs&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="478f8e8f8e40a23e1335aa300d9b135f2ed07fd9" translate="yes" xml:space="preserve">
          <source>Using-declaration</source>
          <target state="translated">Using-declaration</target>
        </trans-unit>
        <trans-unit id="e192f9ebd97a059b8b3818089ff571a2768e5ba3" translate="yes" xml:space="preserve">
          <source>Using-declaration introduces a member of a base class into the derived class definition, such as to expose a protected member of base as public member of derived. In this case, nested-name-specifier must name a base class of the one being defined. If the name is the name of an overloaded member function of the base class, all base class member functions with that name are introduced. If the derived class already has a member with the same name, parameter list, and qualifications, the derived class member hides or overrides (doesn't conflict with) the member that is introduced from the base class.</source>
          <target state="translated">Использование-декларация вводит член базового класса в определение производного класса,например,чтобы выставить защищенный член базы в качестве публичного члена производного.В этом случае вложенный указатель на имя должен назвать базовый класс определяемого класса.Если это имя является именем перегруженной функции-члена базового класса,то вводятся все функции-члены базового класса с этим именем.Если производный класс уже имеет член с таким же именем,список параметров и квалификации,то член производного класса скрывает или переопределяет (не конфликтует)член,который вводится из базового класса.</target>
        </trans-unit>
        <trans-unit id="647139d11b1988510ebdf137fbaac198034c6a6b" translate="yes" xml:space="preserve">
          <source>Using-declaration introduces a member of another namespace into current namespace or block scope.</source>
          <target state="translated">Использование-декларация вводит члена другого пространства имен в текущее пространство имен или блок-область.</target>
        </trans-unit>
        <trans-unit id="96ab3f618e4bb79ceae244afaf56510df88fbaa8" translate="yes" xml:space="preserve">
          <source>Using-declarations</source>
          <target state="translated">Using-declarations</target>
        </trans-unit>
        <trans-unit id="89ce2da2bf0809daefed3588888e71ab6c4b17a5" translate="yes" xml:space="preserve">
          <source>Using-declarations can be used to introduce namespace members into other namespaces and block scopes, or to introduce base class members into derived class definitions.</source>
          <target state="translated">Использование-объявления можно использовать для введения членов пространства имен в другие пространства имен и блочные пространства,или для введения членов базового класса в производные определения классов.</target>
        </trans-unit>
        <trans-unit id="1afd86105bb6b7eae3d1c2ff8ebac8080cc93c0b" translate="yes" xml:space="preserve">
          <source>Using-declarations cannot name &lt;a href=&quot;templates#template-id&quot;&gt;template-id&lt;/a&gt;, namespace, or a scoped enumerator. Each declarator in a using-declaration introduces one and only one name, for example using-declaration for an &lt;a href=&quot;enum&quot;&gt;enumeration&lt;/a&gt; does not introduce any of its enumerators.</source>
          <target state="translated">Объявления использования не могут называть &lt;a href=&quot;templates#template-id&quot;&gt;идентификатор шаблона&lt;/a&gt; , пространство имен или перечислитель с областью действия. Каждый декларатор в объявлении использования вводит одно и только одно имя, например, использование декларации для &lt;a href=&quot;enum&quot;&gt;перечисления&lt;/a&gt; не вводит ни одного из его перечислителей.</target>
        </trans-unit>
        <trans-unit id="243bb7e4adba8af291f9b9518cc9a875ccf74e65" translate="yes" xml:space="preserve">
          <source>Using-declarations in derived classes cannot refer to specializations of template conversion functions from base classes.</source>
          <target state="translated">Использование-объявления в производных классах не может относиться к специализациям функций преобразования шаблонов из базовых классов.</target>
        </trans-unit>
        <trans-unit id="890b0e8bf12e6e2f8622f4d2164034f01e35b67b" translate="yes" xml:space="preserve">
          <source>Using-directive does not add any names to the declarative region in which it appears (unlike the using-declaration), and thus does not prevent identical names from being declared.</source>
          <target state="translated">Употребляющее направление не добавляет никаких имен в декларативную область,в которой оно появляется (в отличие от использования-декларирования),и,таким образом,не препятствует объявлению идентичных имен.</target>
        </trans-unit>
        <trans-unit id="9267f4ac5eb849d97bac3ea55d519f3646d7511f" translate="yes" xml:space="preserve">
          <source>Using-directives</source>
          <target state="translated">Using-directives</target>
        </trans-unit>
        <trans-unit id="e478a805aae96b5ada7799a77a72b64e59439220" translate="yes" xml:space="preserve">
          <source>Using-directives are allowed only in namespace &lt;a href=&quot;scope&quot;&gt;scope&lt;/a&gt; and in block scope. From the point of view of unqualified &lt;a href=&quot;lookup&quot;&gt;name lookup&lt;/a&gt; of any name after a using-directive and until the end of the scope in which it appears, every name from namespace-name is visible as if it were declared in the nearest enclosing namespace which contains both the using-directive and namespace-name.</source>
          <target state="translated">Использование Директив допускаются только в пространстве имен &lt;a href=&quot;scope&quot;&gt;объема&lt;/a&gt; и в блоке области. С точки зрения &lt;a href=&quot;lookup&quot;&gt;поиска&lt;/a&gt; безоговорочного имени любого имени после директивы using и до конца области, в которой оно появляется, каждое имя из namespace-name является видимым, как если бы оно было объявлено в ближайшем окружающем пространстве имен, которое содержит оба директива using и namespace-name.</target>
        </trans-unit>
        <trans-unit id="fe20c085207b808c419801ec01c3f2d69d1e53a9" translate="yes" xml:space="preserve">
          <source>Using-directives are transitive for the purposes of &lt;a href=&quot;lookup&quot;&gt;unqualified lookup&lt;/a&gt;: if a scope contains a using-directive that nominates a namespace-name, which itself contains using-directive for some namespace-name-2, the effect is as if the using directives from the second namespace appear within the first. The order in which these transitive namespaces occur does not influence name lookup.</source>
          <target state="translated">Директивы using транзитивны для целей &lt;a href=&quot;lookup&quot;&gt;неквалифицированного поиска&lt;/a&gt; : если область содержит директиву using, которая назначает имя-пространства имен, которое само содержит директиву using для некоторого namespace-name-2, эффект такой, как если бы директивы using из второе пространство имен появляется внутри первого. Порядок, в котором происходят эти транзитивные пространства имен, не влияет на поиск имени.</target>
        </trans-unit>
        <trans-unit id="90e771e57dbe271295562deb5815544ce47acec2" translate="yes" xml:space="preserve">
          <source>Usual &lt;a href=&quot;qualified_lookup&quot;&gt;qualified name lookup&lt;/a&gt; is used for the identifier prefixed by &lt;code&gt;typename&lt;/code&gt;. Unlike the case with &lt;a href=&quot;elaborated_type_specifier&quot;&gt;elaborated type specifier&lt;/a&gt;, the lookup rules do not change despite the qualifier:</source>
          <target state="translated">Обычный &lt;a href=&quot;qualified_lookup&quot;&gt;поиск подходящего имени&lt;/a&gt; используется для идентификатора с префиксом &lt;code&gt;typename&lt;/code&gt; . В отличие от случая с &lt;a href=&quot;elaborated_type_specifier&quot;&gt;детально разработанным спецификатором типа&lt;/a&gt; , правила поиска не меняются, несмотря на классификатор:</target>
        </trans-unit>
        <trans-unit id="18fdc5ee8b1f8fba8dabaa933373c0483ab7fad7" translate="yes" xml:space="preserve">
          <source>Utilities</source>
          <target state="translated">Utilities</target>
        </trans-unit>
        <trans-unit id="72c1f2942e6c2f59eb16eb2f336358c3428f04e8" translate="yes" xml:space="preserve">
          <source>Utilities library</source>
          <target state="translated">коммунальная библиотека</target>
        </trans-unit>
        <trans-unit id="c238357565249d5db64377b7321a861ff74e6a3d" translate="yes" xml:space="preserve">
          <source>Utility components</source>
          <target state="translated">Коммунальные компоненты</target>
        </trans-unit>
        <trans-unit id="69be11f41a3c37842e99473568839d6e6c14c854" translate="yes" xml:space="preserve">
          <source>Utility library</source>
          <target state="translated">Полезная библиотека</target>
        </trans-unit>
        <trans-unit id="6c204fbda83dad99b4764ac479029ca8981e718e" translate="yes" xml:space="preserve">
          <source>Utility metafunction that maps a sequence of any types to the type &lt;code&gt;void&lt;/code&gt;.</source>
          <target state="translated">Утилита метафункция, которая отображает последовательность любых типов на тип &lt;code&gt;void&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b0d7fadc1640d7f4704fe07fafd860ef56a6519b" translate="yes" xml:space="preserve">
          <source>VERTICAL KANA REPEAT MARK - HANGUL JONGSEONG PHIEUPH-THIEUTH</source>
          <target state="translated">ВЕРТИКАЛЬНАЯ ОТМЕТКА ПОВТОРА КАНА-HANGUL JONGSEONG PHIEUPH-THIEUTH</target>
        </trans-unit>
        <trans-unit id="5a815286d91c46561b98d7d910a0542f7fa603a7" translate="yes" xml:space="preserve">
          <source>VULGAR FRACTION ONE QUARTER - VULGAR FRACTION THREE QUARTERS</source>
          <target state="translated">ВУЛЬГАРНАЯ ФРАКЦИЯ ОДНА ЧЕТВЕРТЬ-ВУЛЬГАРНАЯ ФРАКЦИЯ ТРИ ЧЕТВЕРТИ</target>
        </trans-unit>
        <trans-unit id="2a85014316c857fc68366f2d4cfeef4ccca44072" translate="yes" xml:space="preserve">
          <source>Valid non-zero alignments that are weaker than another &lt;code&gt;alignas&lt;/code&gt; on the same declaration are ignored.</source>
          <target state="translated">Допустимые ненулевые выравнивания, которые слабее других &lt;code&gt;alignas&lt;/code&gt; в том же объявлении, игнорируются.</target>
        </trans-unit>
        <trans-unit id="8dce170de238b1feda2ecd9674ea3ca0d068fbcb" translate="yes" xml:space="preserve">
          <source>Value</source>
          <target state="translated">Value</target>
        </trans-unit>
        <trans-unit id="f00df19eab61f9bc6b193ebf7f79f580e312b435" translate="yes" xml:space="preserve">
          <source>Value (hex)</source>
          <target state="translated">Значение (шестнадцатеричное)</target>
        </trans-unit>
        <trans-unit id="6ccf81011273d24c106e237774966bec5a3f3d04" translate="yes" xml:space="preserve">
          <source>Value (octal)</source>
          <target state="translated">Значение (восьмеричный)</target>
        </trans-unit>
        <trans-unit id="842d5c71fd285df07d76b3a931200aef4027bbe5" translate="yes" xml:space="preserve">
          <source>Value array containing</source>
          <target state="translated">Массив значений,содержащий</target>
        </trans-unit>
        <trans-unit id="8f9d98449ec4c8f79f22636316b3a0e923c947ef" translate="yes" xml:space="preserve">
          <source>Value array containing absolute values of the values in &lt;code&gt;va&lt;/code&gt;.</source>
          <target state="translated">Массив значений, содержащий абсолютные значения значений в &lt;code&gt;va&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bba712cfd9f7651aa772da136f89a61149be2ac1" translate="yes" xml:space="preserve">
          <source>Value array containing arc cosines of the values in &lt;code&gt;va&lt;/code&gt;.</source>
          <target state="translated">Массив значений, содержащий арккосинусы значений в &lt;code&gt;va&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="918e7d00363d34ea17b81a2896797c2d5407de29" translate="yes" xml:space="preserve">
          <source>Value array containing arc sines of the values in &lt;code&gt;va&lt;/code&gt;.</source>
          <target state="translated">Массив значений, содержащий синусоиды значений в &lt;code&gt;va&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7dd43aa4756d43fc4b8be056b5da614e7ae17fe0" translate="yes" xml:space="preserve">
          <source>Value array containing arc tangents of the values in &lt;code&gt;va&lt;/code&gt;.</source>
          <target state="translated">Массив значений, содержащий арктангенсы значений в &lt;code&gt;va&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7a16b1209abeda990f5a71b8d2e227e0b6c93b82" translate="yes" xml:space="preserve">
          <source>Value array containing common logarithms of the values in &lt;code&gt;va&lt;/code&gt;.</source>
          <target state="translated">Массив значений, содержащий общие логарифмы значений в &lt;code&gt;va&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a311ab5baa8093138875ac8a94b0cea46530bc77" translate="yes" xml:space="preserve">
          <source>Value array containing cosines of the values in &lt;code&gt;va&lt;/code&gt;.</source>
          <target state="translated">Массив значений, содержащий косинусы значений в &lt;code&gt;va&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="67e25f3a01cf3ed1b997a81a0d9b1d557b7e592b" translate="yes" xml:space="preserve">
          <source>Value array containing hyperbolic cosine of the values in &lt;code&gt;va&lt;/code&gt;.</source>
          <target state="translated">Массив значений, содержащий гиперболический косинус значений в &lt;code&gt;va&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9d4fd3ea31174e2ad27a712e67ef9575efad3f21" translate="yes" xml:space="preserve">
          <source>Value array containing hyperbolic sine of the values in &lt;code&gt;va&lt;/code&gt;.</source>
          <target state="translated">Массив значений, содержащий гиперболический синус значений в &lt;code&gt;va&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2a5794dbb6788174721a7201fba5775845755af6" translate="yes" xml:space="preserve">
          <source>Value array containing hyperbolic tangent of the values in &lt;code&gt;va&lt;/code&gt;.</source>
          <target state="translated">Массив значений, содержащий гиперболический тангенс значений в &lt;code&gt;va&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="788503847d55a0b843da66ecc9eb7e909c8e81ea" translate="yes" xml:space="preserve">
          <source>Value array containing natural logarithms of the values in &lt;code&gt;va&lt;/code&gt;.</source>
          <target state="translated">Массив значений, содержащий натуральные логарифмы значений в &lt;code&gt;va&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8d94e0b0bb891cd281312eef3d7cafb82f9093c2" translate="yes" xml:space="preserve">
          <source>Value array containing sine of the values in &lt;code&gt;va&lt;/code&gt;.</source>
          <target state="translated">Массив значений, содержащий синус значений в &lt;code&gt;va&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4bcd496b550ea36f6a6a5da52708746dfc984226" translate="yes" xml:space="preserve">
          <source>Value array containing square roots of the values in &lt;code&gt;va&lt;/code&gt;.</source>
          <target state="translated">Массив значений, содержащий квадратные корни значений в &lt;code&gt;va&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="acec93cb24e8ed07513e328851e06115700eaed0" translate="yes" xml:space="preserve">
          <source>Value array containing tangents of the values in &lt;code&gt;va&lt;/code&gt;.</source>
          <target state="translated">Массив значений, содержащий касательные значений в &lt;code&gt;va&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="de0430a56abae1a9c8cca4fd7a8b8906769e0636" translate="yes" xml:space="preserve">
          <source>Value categories</source>
          <target state="translated">Категории стоимости</target>
        </trans-unit>
        <trans-unit id="82a222afd8aa1f50591d47af3a1da440d1b6c1c9" translate="yes" xml:space="preserve">
          <source>Value initialization is performed in these situations:</source>
          <target state="translated">В этих ситуациях выполняется инициализация значения:</target>
        </trans-unit>
        <trans-unit id="44ee88d7a37283ed3f2e5c6bb77a69fd4b4ff443" translate="yes" xml:space="preserve">
          <source>Value of &lt;code&gt;str&lt;/code&gt;</source>
          <target state="translated">Значение &lt;code&gt;str&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f316bf9562d1f2536d1f98b558dad75f56bae376" translate="yes" xml:space="preserve">
          <source>Value of a floating-point or &lt;a href=&quot;../../types/is_integral&quot;&gt;Integral type&lt;/a&gt;</source>
          <target state="translated">Значение с плавающей точкой или &lt;a href=&quot;../../types/is_integral&quot;&gt;Интегральный тип&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="8868e91c4a5c3eea6c88793879068066054670cd" translate="yes" xml:space="preserve">
          <source>Value of a type &lt;code&gt;Y&lt;/code&gt; whose &lt;a href=&quot;../container/node_handle&quot;&gt;node handles&lt;/a&gt; are compatible with X</source>
          <target state="translated">Значение типа &lt;code&gt;Y&lt;/code&gt; , чьи &lt;a href=&quot;../container/node_handle&quot;&gt;дескрипторы узла&lt;/a&gt; совместимы с X</target>
        </trans-unit>
        <trans-unit id="a6d7a9a5f8f421d8d8d1289caa1073e525a68c0c" translate="yes" xml:space="preserve">
          <source>Value of type &lt;code&gt;X::size_type&lt;/code&gt;</source>
          <target state="translated">Значение типа &lt;code&gt;X::size_type&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a3076d857f6bafe8bc4b757157d8b7e92030d350" translate="yes" xml:space="preserve">
          <source>Value of type &lt;code&gt;X&lt;/code&gt;</source>
          <target state="translated">Значение типа &lt;code&gt;X&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="bdc99e4fc02f27b3e7f0e86f72aae50003652dc4" translate="yes" xml:space="preserve">
          <source>Value of type &lt;code&gt;X&lt;/code&gt; when &lt;code&gt;X&lt;/code&gt; supports multiple keys</source>
          <target state="translated">Значение типа &lt;code&gt;X&lt;/code&gt; , когда &lt;code&gt;X&lt;/code&gt; поддерживает несколько ключей</target>
        </trans-unit>
        <trans-unit id="d88b2ce84fd44f3d069f80a1cad885599a530444" translate="yes" xml:space="preserve">
          <source>Value of type &lt;code&gt;X&lt;/code&gt; when &lt;code&gt;X&lt;/code&gt; supports unique keys</source>
          <target state="translated">Значение типа &lt;code&gt;X&lt;/code&gt; , когда &lt;code&gt;X&lt;/code&gt; поддерживает уникальные ключи</target>
        </trans-unit>
        <trans-unit id="b2e637fb234b0c6b9d295e0383f8ac972d2e9be2" translate="yes" xml:space="preserve">
          <source>Value of type &lt;code&gt;float&lt;/code&gt;</source>
          <target state="translated">Значение типа &lt;code&gt;float&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1c7cea36bd22384e74ce5693b3a96747824e4406" translate="yes" xml:space="preserve">
          <source>Value range</source>
          <target state="translated">Диапазон значений</target>
        </trans-unit>
        <trans-unit id="51127d011c590cc06c1287343706272a08f0dc2d" translate="yes" xml:space="preserve">
          <source>Value too large to be stored in data type</source>
          <target state="translated">Слишком большое значение для хранения в типе данных.</target>
        </trans-unit>
        <trans-unit id="af99e0d3d72b238f81c500119ae328f4acda13dc" translate="yes" xml:space="preserve">
          <source>Value transformations</source>
          <target state="translated">Преобразования стоимости</target>
        </trans-unit>
        <trans-unit id="60a41a8af03cf015b251f42ec4877faede44cfa3" translate="yes" xml:space="preserve">
          <source>Value transformations are conversions that change the &lt;a href=&quot;value_category&quot;&gt;value category&lt;/a&gt; of an expression. They take place whenever an expression appears as an operand of an operator that expects an expression of a different value category.</source>
          <target state="translated">Преобразования значений - это преобразования, которые изменяют &lt;a href=&quot;value_category&quot;&gt;категорию&lt;/a&gt; значений выражения. Они имеют место всякий раз, когда выражение появляется как операнд оператора, который ожидает выражение другой категории значения.</target>
        </trans-unit>
        <trans-unit id="912f89db75340dd536695f5900751cb79605c44e" translate="yes" xml:space="preserve">
          <source>Value-dependent expressions</source>
          <target state="translated">Зависимые от значения выражения</target>
        </trans-unit>
        <trans-unit id="1c83d35b39b8a1674f047686e39badc8092fea73" translate="yes" xml:space="preserve">
          <source>ValueSwappable</source>
          <target state="translated">ValueSwappable</target>
        </trans-unit>
        <trans-unit id="5cfdbdef621053e4c2adb3e5800cfd3510d6d549" translate="yes" xml:space="preserve">
          <source>ValueType</source>
          <target state="translated">ValueType</target>
        </trans-unit>
        <trans-unit id="e3d8fb1ed748d78b39416572c15d6566892835be" translate="yes" xml:space="preserve">
          <source>Values of &lt;code&gt;base&lt;/code&gt; other than 8, 10, or 16 reset &lt;code&gt;basefield&lt;/code&gt; to zero, which corresponds to decimal output and prefix-dependent input.</source>
          <target state="translated">Значения &lt;code&gt;base&lt;/code&gt; отличные от 8, 10 или 16, сбрасывают &lt;code&gt;basefield&lt;/code&gt; на ноль, что соответствует десятичному выводу и вводу, зависящему от префикса.</target>
        </trans-unit>
        <trans-unit id="699b7fde74d4bad2ed32bf4fdac5cb581d05b675" translate="yes" xml:space="preserve">
          <source>Values of integer, floating-point, and enumeration types can be converted by &lt;a href=&quot;static_cast&quot;&gt;&lt;code&gt;static_cast&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;explicit_cast&quot;&gt;explicit cast&lt;/a&gt;, to any enumeration type. If the underlying type is not fixed, the result is unspecified(until C++17)undefined behavior(since C++17) if the source value (first converted to the enumeration's underlying type if floating-point) is out of range (the range is all values possible for the smallest bit field large enough to hold all enumerators of the target enumeration). Otherwise, the result is the same as the result of &lt;a href=&quot;implicit_cast&quot;&gt;implicit conversion&lt;/a&gt; to the underlying type.</source>
          <target state="translated">Значения целочисленного типа, числа с плавающей точкой и перечисления могут быть преобразованы с помощью &lt;a href=&quot;static_cast&quot;&gt; &lt;code&gt;static_cast&lt;/code&gt; &lt;/a&gt; или &lt;a href=&quot;explicit_cast&quot;&gt;явного приведения&lt;/a&gt; в любой тип перечисления. Если базовый тип не является фиксированным, результатом является неопределенное (до C ++ 17) неопределенное поведение (начиная с C ++ 17), если исходное значение (сначала преобразованное в базовый тип перечисления, если с плавающей точкой) выходит за пределы диапазона ( диапазон - это все возможные значения для наименьшего битового поля, достаточного для хранения всех перечислителей целевого перечисления). В противном случае результат совпадает с результатом &lt;a href=&quot;implicit_cast&quot;&gt;неявного преобразования&lt;/a&gt; в базовый тип.</target>
        </trans-unit>
        <trans-unit id="622c99b5f957359968fbce43706c282c2086981e" translate="yes" xml:space="preserve">
          <source>Values of unscoped enumeration type are &lt;a href=&quot;implicit_cast&quot;&gt;implicitly-convertible&lt;/a&gt; to integral types. If the underlying type is not fixed, the value is convertible to the first type from the following list able to hold their entire value range: &lt;code&gt;int&lt;/code&gt;, &lt;code&gt;unsigned int&lt;/code&gt;, &lt;code&gt;long&lt;/code&gt;, &lt;code&gt;unsigned long&lt;/code&gt;, &lt;code&gt;long long&lt;/code&gt;, or &lt;code&gt;unsigned long long&lt;/code&gt;. If the underlying type is fixed, the values can be converted to their promoted underlying type.</source>
          <target state="translated">Значения перечислимого типа с незаданной областью &lt;a href=&quot;implicit_cast&quot;&gt;неявно преобразуются&lt;/a&gt; в целочисленные типы. Если базовый тип не является фиксированным, значение может быть преобразовано в первый тип из следующего списка, который может содержать весь диапазон значений: &lt;code&gt;int&lt;/code&gt; , &lt;code&gt;unsigned int&lt;/code&gt; , &lt;code&gt;long&lt;/code&gt; , &lt;code&gt;unsigned long&lt;/code&gt; , &lt;code&gt;long long&lt;/code&gt; или &lt;code&gt;unsigned long long&lt;/code&gt; . Если базовый тип является фиксированным, значения могут быть преобразованы в их повышенный базовый тип.</target>
        </trans-unit>
        <trans-unit id="f8df93af76ffcc18fdab0d35c919d46adda08d0a" translate="yes" xml:space="preserve">
          <source>Values of zero will be replaced with implementation-specified defaults;</source>
          <target state="translated">Значения нуля будут заменены на значения по умолчанию,заданные реализацией;</target>
        </trans-unit>
        <trans-unit id="052336d34e395136fdc7b0ea68de9e6ce0735430" translate="yes" xml:space="preserve">
          <source>Values returned from &lt;code&gt;lookup_classname&lt;/code&gt; can be bitwise or'ed together; the resulting value represents membership in either of the corresponding character classes</source>
          <target state="translated">Значения, возвращаемые из &lt;code&gt;lookup_classname&lt;/code&gt; , могут быть побитовыми или объединенными; результирующее значение представляет членство в любом из соответствующих классов символов</target>
        </trans-unit>
        <trans-unit id="df08eb1d25241fdec3135b3385380633b3feb713" translate="yes" xml:space="preserve">
          <source>Variable template(since C++14)</source>
          <target state="translated">Переменный шаблон (начиная с C++14)</target>
        </trans-unit>
        <trans-unit id="07e0c173abb12ff926e54a677500672fc6b6b986" translate="yes" xml:space="preserve">
          <source>Variable templates</source>
          <target state="translated">Переменные шаблоны</target>
        </trans-unit>
        <trans-unit id="bb8bc60fbcd37b30cc10bb1c4aefe4bd77138258" translate="yes" xml:space="preserve">
          <source>Variable templates cannot be used as &lt;a href=&quot;template_parameters#Template_template_arguments&quot;&gt;template template arguments&lt;/a&gt;.</source>
          <target state="translated">Шаблоны переменных не могут использоваться в качестве &lt;a href=&quot;template_parameters#Template_template_arguments&quot;&gt;аргументов шаблонов&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="bf60c912c256eebe5d2b8b031ec6bed1e0afbc9c" translate="yes" xml:space="preserve">
          <source>Variable templates for type traits</source>
          <target state="translated">Переменные шаблоны для типовых признаков</target>
        </trans-unit>
        <trans-unit id="d41def7a6d8846ea38dabfb67345e2e0a09f52e7" translate="yes" xml:space="preserve">
          <source>Variables declared at block scope with the specifier &lt;code&gt;static&lt;/code&gt; have static storage duration but are initialized the first time control passes through their declaration (unless their initialization is &lt;a href=&quot;zero_initialization&quot;&gt;zero-&lt;/a&gt; or &lt;a href=&quot;constant_initialization&quot;&gt;constant-initialization&lt;/a&gt;, which can be performed before the block is first entered). On all further calls, the declaration is skipped.</source>
          <target state="translated">Переменные, объявленные в области видимости блока со &lt;code&gt;static&lt;/code&gt; спецификатором, имеют статическую длительность хранения, но инициализируются при первом прохождении контроля через их объявление (если только они не инициализируются &lt;a href=&quot;zero_initialization&quot;&gt;нулевой&lt;/a&gt; или &lt;a href=&quot;constant_initialization&quot;&gt;постоянной инициализацией&lt;/a&gt; , что может быть выполнено до первого ввода блока). При всех последующих вызовах объявление пропускается.</target>
        </trans-unit>
        <trans-unit id="56198fe808c824ddba06784c100164faedd427c3" translate="yes" xml:space="preserve">
          <source>Variadic &lt;code&gt;&lt;a href=&quot;thread/lock_guard&quot;&gt;std::lock_guard&lt;/a&gt;&lt;/code&gt; (&lt;code&gt;std::scoped_lock&lt;/code&gt;)</source>
          <target state="translated">Variadic &lt;code&gt;&lt;a href=&quot;thread/lock_guard&quot;&gt;std::lock_guard&lt;/a&gt;&lt;/code&gt; ( &lt;code&gt;std::scoped_lock&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="a8548e5a783f6964c2b71215ac2f1cf031c3e8a0" translate="yes" xml:space="preserve">
          <source>Variadic arguments</source>
          <target state="translated">вариадические аргументы</target>
        </trans-unit>
        <trans-unit id="8e36a4956d4555b32607f272180c87deea209898" translate="yes" xml:space="preserve">
          <source>Variadic functions</source>
          <target state="translated">вариадические функции</target>
        </trans-unit>
        <trans-unit id="04c44e45105b6cf53a83ce33f663f4af86c9d0a7" translate="yes" xml:space="preserve">
          <source>Variadic functions are functions (e.g. &lt;code&gt;&lt;a href=&quot;../io/c/printf&quot;&gt;std::printf&lt;/a&gt;&lt;/code&gt;) which take a &lt;a href=&quot;../language/variadic_arguments&quot;&gt;variable number of arguments&lt;/a&gt;.</source>
          <target state="translated">Функции Variadic - это функции (например, &lt;code&gt;&lt;a href=&quot;../io/c/printf&quot;&gt;std::printf&lt;/a&gt;&lt;/code&gt; ), которые принимают &lt;a href=&quot;../language/variadic_arguments&quot;&gt;переменное число аргументов&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8a308087e2905028e7ad5d2c240717d97448c333" translate="yes" xml:space="preserve">
          <source>Variadic templates</source>
          <target state="translated">вариадические шаблоны</target>
        </trans-unit>
        <trans-unit id="40aa5342cc8cddbbe71fe77cdf48f02a16642a52" translate="yes" xml:space="preserve">
          <source>Various &lt;a href=&quot;utility&quot;&gt; utility components&lt;/a&gt;</source>
          <target state="translated">Различные &lt;a href=&quot;utility&quot;&gt;вспомогательные компоненты&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="43dfbbdcd916a0c6741ae6b7703f2bf5dd8096c3" translate="yes" xml:space="preserve">
          <source>Vector capacity is never reduced when resizing to smaller size because that would invalidate all iterators, rather than only the ones that would be invalidated by the equivalent sequence of pop_back() calls.</source>
          <target state="translated">Векторная емкость никогда не уменьшается при изменении размера,так как это сделает недействительными все итераторы,а не только те,которые будут признаны недействительными эквивалентной последовательностью вызовов pop_back().</target>
        </trans-unit>
        <trans-unit id="5519001c19e39db626b1e56d5b3636ed5b38cb6f" translate="yes" xml:space="preserve">
          <source>Version (2) of the &lt;code&gt;#define&lt;/code&gt; directive defines a simple function-like macro.</source>
          <target state="translated">Версия (2) директивы &lt;code&gt;#define&lt;/code&gt; определяет простой функциональный макрос.</target>
        </trans-unit>
        <trans-unit id="ae3376f429640ab77c59ef69b6eeee356493fa80" translate="yes" xml:space="preserve">
          <source>Version (3) of the &lt;code&gt;#define&lt;/code&gt; directive defines a function-like macro with variable number of arguments. The additional arguments (called</source>
          <target state="translated">Версия (3) директивы &lt;code&gt;#define&lt;/code&gt; определяет функциональный макрос с переменным числом аргументов. Дополнительные аргументы (называемые</target>
        </trans-unit>
        <trans-unit id="3243986759cbfdbcf8f3fe70af12570a24f20c76" translate="yes" xml:space="preserve">
          <source>Version (4) of the &lt;code&gt;#define&lt;/code&gt; directive defines a function-like macro with variable number of arguments, but no regular arguments. The arguments (called</source>
          <target state="translated">Версия (4) директивы &lt;code&gt;#define&lt;/code&gt; определяет функциональный макрос с переменным количеством аргументов, но без обычных аргументов. Аргументы (называется</target>
        </trans-unit>
        <trans-unit id="1c26c7d8a48f6ecef280cf0b203307778072892d" translate="yes" xml:space="preserve">
          <source>Viable functions</source>
          <target state="translated">Поддерживаемые функции</target>
        </trans-unit>
        <trans-unit id="69bd4ef9fbd0894a22759c3766b859defbdedbc8" translate="yes" xml:space="preserve">
          <source>View</source>
          <target state="translated">View</target>
        </trans-unit>
        <trans-unit id="57dde08ae7e4931bf4b1d9d8203c8fb2aa6c4ddb" translate="yes" xml:space="preserve">
          <source>View of the substring &lt;code&gt;[pos, pos + rcount)&lt;/code&gt;.</source>
          <target state="translated">Вид подстроки &lt;code&gt;[pos, pos + rcount)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="08776128bd18b59c55542f61081a01440f41b01c" translate="yes" xml:space="preserve">
          <source>ViewableRange</source>
          <target state="translated">ViewableRange</target>
        </trans-unit>
        <trans-unit id="24be61285e096fa817d4cdb0a0ed8294ea5bd2fb" translate="yes" xml:space="preserve">
          <source>Views</source>
          <target state="translated">Views</target>
        </trans-unit>
        <trans-unit id="c911ee9da5495317a3fd2048e2a77408d0f7651d" translate="yes" xml:space="preserve">
          <source>Violations of constraints are detected at compile time, early in the template instantiation process, which leads to easy to follow error messages.</source>
          <target state="translated">Нарушения ограничений обнаруживаются во время компиляции,на ранней стадии процесса инстанцирования шаблона,что приводит к легко отслеживаемым сообщениям об ошибках.</target>
        </trans-unit>
        <trans-unit id="9b18a97a2fd2836708868d06e1ce4ef84d86615c" translate="yes" xml:space="preserve">
          <source>Virtual and pure virtual functions</source>
          <target state="translated">Виртуальные и чистые виртуальные функции</target>
        </trans-unit>
        <trans-unit id="f68e04bd9e3e62f1affa5f5cd95daed9e7141704" translate="yes" xml:space="preserve">
          <source>Virtual base classes</source>
          <target state="translated">Виртуальные базовые классы</target>
        </trans-unit>
        <trans-unit id="bb2875a5baa367827268a607eb3795f455c6012e" translate="yes" xml:space="preserve">
          <source>Virtual destructor</source>
          <target state="translated">Виртуальный Разрушитель</target>
        </trans-unit>
        <trans-unit id="5066038f5f1b55b5a2bc0bc13c582fae42181817" translate="yes" xml:space="preserve">
          <source>Virtual destructors</source>
          <target state="translated">Виртуальные деструкторы</target>
        </trans-unit>
        <trans-unit id="f6fe3c659ed8077db8d0b5920aa4b5764bff62d6" translate="yes" xml:space="preserve">
          <source>Virtual functions (whether declared virtual or overriding one) cannot have any associated constraints.</source>
          <target state="translated">Виртуальные функции (как объявленные виртуальными,так и переопределяющие)не могут иметь связанных с ними ограничений.</target>
        </trans-unit>
        <trans-unit id="7f5fcb0f75cbb4813db427832ef8357c8c51c72a" translate="yes" xml:space="preserve">
          <source>Virtual functions are member functions whose behavior can be overridden in derived classes. As opposed to non-virtual functions, the overridden behavior is preserved even if there is no compile-time information about the actual type of the class. If a derived class is handled using pointer or reference to the base class, a call to an overridden virtual function would invoke the behavior defined in the derived class. This behavior is suppressed if the function is selected using &lt;a href=&quot;lookup&quot;&gt;qualified name lookup&lt;/a&gt; (that is, if the function's name appears to the right of the scope resolution operator &lt;code&gt;::&lt;/code&gt;).</source>
          <target state="translated">Виртуальные функции - это функции-члены, поведение которых может быть переопределено в производных классах. В отличие от не виртуальных функций, переопределенное поведение сохраняется, даже если во время компиляции нет информации о фактическом типе класса. Если производный класс обрабатывается с использованием указателя или ссылки на базовый класс, вызов переопределенной виртуальной функции вызовет поведение, определенное в производном классе. Это поведение подавляется, если функция выбирается с использованием &lt;a href=&quot;lookup&quot;&gt;поиска&lt;/a&gt; по квалифицированному имени (то есть, если имя функции отображается справа от оператора разрешения области &lt;code&gt;::&lt;/code&gt; ) .</target>
        </trans-unit>
        <trans-unit id="d022c012c3444ee6f002dccdfcd5905c70efa42e" translate="yes" xml:space="preserve">
          <source>Visible side-effects</source>
          <target state="translated">Видимые побочные эффекты</target>
        </trans-unit>
        <trans-unit id="30c3d8194815052f5f9f54a1fac519295b84ad3f" translate="yes" xml:space="preserve">
          <source>Visual Studio 2010</source>
          <target state="translated">Визуальная студия 2010</target>
        </trans-unit>
        <trans-unit id="a50605af7e7015b16739f3db40248d1a64076a37" translate="yes" xml:space="preserve">
          <source>Visual Studio 2013 Inline Assembler</source>
          <target state="translated">Визуальная студия 2013 Интернет-ассемблер</target>
        </trans-unit>
        <trans-unit id="359a03f62e49986ef991446210499529db3fc418" translate="yes" xml:space="preserve">
          <source>Void expressions</source>
          <target state="translated">Пустые выражения</target>
        </trans-unit>
        <trans-unit id="f135b48d956f6ca097c1656d0a1863579947c9fb" translate="yes" xml:space="preserve">
          <source>Void expressions have no</source>
          <target state="translated">Пустые выражения не имеют</target>
        </trans-unit>
        <trans-unit id="e8f5359cab08d3573121923f7436c0f33fc92629" translate="yes" xml:space="preserve">
          <source>Void type</source>
          <target state="translated">Тип Пустоты</target>
        </trans-unit>
        <trans-unit id="e2415cb7f63df0c9de23362326ad3c37a9adfc96" translate="yes" xml:space="preserve">
          <source>W</source>
          <target state="translated">W</target>
        </trans-unit>
        <trans-unit id="c0bc38123ad63ab545d3b75627acdac77e9b79a6" translate="yes" xml:space="preserve">
          <source>WCHAR_MAX</source>
          <target state="translated">WCHAR_MAX</target>
        </trans-unit>
        <trans-unit id="04ea5fdfa0eae316269a47c7f10e8316337146a4" translate="yes" xml:space="preserve">
          <source>WCHAR_MIN</source>
          <target state="translated">WCHAR_MIN</target>
        </trans-unit>
        <trans-unit id="c37a74a6f2d73286ec534a439a5c059b13230ec6" translate="yes" xml:space="preserve">
          <source>WEOF</source>
          <target state="translated">WEOF</target>
        </trans-unit>
        <trans-unit id="8d070188c9052ddde44bc280e3aced3c983ed8c7" translate="yes" xml:space="preserve">
          <source>WINT_MAX</source>
          <target state="translated">WINT_MAX</target>
        </trans-unit>
        <trans-unit id="cb08e31a881a0bd7697665afb678cdce175c2f59" translate="yes" xml:space="preserve">
          <source>WINT_MIN</source>
          <target state="translated">WINT_MIN</target>
        </trans-unit>
        <trans-unit id="d7d72e040861a1f86b9b248b64986ff2db87de0a" translate="yes" xml:space="preserve">
          <source>WORD JOINER - TURNED DIGIT THREE</source>
          <target state="translated">СЛОВО СТОЛЯР-ПЕРЕВЁРНУТАЯ ЦИФРА ТРИ</target>
        </trans-unit>
        <trans-unit id="33d30632848d3fd0ed2340adbd7be3e3e8e61010" translate="yes" xml:space="preserve">
          <source>Waiting</source>
          <target state="translated">Waiting</target>
        </trans-unit>
        <trans-unit id="8c8066383629449e748934ef44df8baa244ceb3f" translate="yes" xml:space="preserve">
          <source>Waits for the result to become available. Blocks until specified &lt;code&gt;timeout_duration&lt;/code&gt; has elapsed or the result becomes available, whichever comes first. Returns value identifies the state of the result.</source>
          <target state="translated">Ожидает, когда результат станет доступным. Блокируется до истечения указанного времени &lt;code&gt;timeout_duration&lt;/code&gt; или до тех пор, пока результат не станет доступным, в зависимости от того, что произойдет раньше. Возвращаемое значение идентифицирует состояние результата.</target>
        </trans-unit>
        <trans-unit id="e9c45563358e813f157ba81b33143542165ba84e" translate="yes" xml:space="preserve">
          <source>Warning</source>
          <target state="translated">Warning</target>
        </trans-unit>
        <trans-unit id="128348550537d17215c4e4e19183a94c6cae96fb" translate="yes" xml:space="preserve">
          <source>We use &lt;code&gt;&lt;i&gt;E&lt;/i&gt;&lt;/code&gt; to denote the type of the expression &lt;code&gt;e&lt;/code&gt;. (In other words, &lt;code&gt;&lt;i&gt;E&lt;/i&gt;&lt;/code&gt; is the equivalent of &lt;code&gt;&lt;a href=&quot;../types/remove_reference&quot;&gt;std::remove_reference_t&lt;/a&gt;&amp;lt;decltype((e))&amp;gt;&lt;/code&gt;.).</source>
          <target state="translated">Мы используем &lt;code&gt;&lt;i&gt;E&lt;/i&gt;&lt;/code&gt; для обозначения типа выражения &lt;code&gt;e&lt;/code&gt; . (Другими словами, &lt;code&gt;&lt;i&gt;E&lt;/i&gt;&lt;/code&gt; является эквивалентом &lt;code&gt;&lt;a href=&quot;../types/remove_reference&quot;&gt;std::remove_reference_t&lt;/a&gt;&amp;lt;decltype((e))&amp;gt;&lt;/code&gt; .).</target>
        </trans-unit>
        <trans-unit id="ff2d0e12c8d86e48e138480e627a03522625fd5b" translate="yes" xml:space="preserve">
          <source>Weak equality</source>
          <target state="translated">Слабое равенство</target>
        </trans-unit>
        <trans-unit id="cc0eeac220c48abd1f4d8a9066580d68089b7e2a" translate="yes" xml:space="preserve">
          <source>Weak ordering</source>
          <target state="translated">Слабый заказ</target>
        </trans-unit>
        <trans-unit id="5f9aead2f88dbe4721a67660c3e46cd95c9d01ce" translate="yes" xml:space="preserve">
          <source>Weakly parallel forward progress</source>
          <target state="translated">Слабо параллельное продвижение вперед</target>
        </trans-unit>
        <trans-unit id="32d5d9f2881f15e8163749d6edac5a8dd285e442" translate="yes" xml:space="preserve">
          <source>WeaklyIncrementable</source>
          <target state="translated">WeaklyIncrementable</target>
        </trans-unit>
        <trans-unit id="f82be68a7fb4e7dec88f27463de94ad355242ee5" translate="yes" xml:space="preserve">
          <source>Week</source>
          <target state="translated">Week</target>
        </trans-unit>
        <trans-unit id="1d901e38ea200c08db624662589c69e315e01ff1" translate="yes" xml:space="preserve">
          <source>Week/day of the year</source>
          <target state="translated">неделя/день года</target>
        </trans-unit>
        <trans-unit id="17a74d187c8a04abdcb5c0a680b6e9d660e85fba" translate="yes" xml:space="preserve">
          <source>What Every C Programmer Should Know About Undefined Behavior #1/3</source>
          <target state="translated">Что каждый программист на Си должен знать о неопределённом поведении № 1/3.</target>
        </trans-unit>
        <trans-unit id="8b7904dfab491b34141248cdfa81f76b99500ce8" translate="yes" xml:space="preserve">
          <source>What Every C Programmer Should Know About Undefined Behavior #2/3</source>
          <target state="translated">Что каждый программист на Си должен знать о неопределённом поведении №2/3.</target>
        </trans-unit>
        <trans-unit id="faec1f8b604ae7cb007c3f28c6244f78ba75f633" translate="yes" xml:space="preserve">
          <source>What Every C Programmer Should Know About Undefined Behavior #3/3</source>
          <target state="translated">Что должен знать каждый программист на Си о неопределённом поведении № 3/3.</target>
        </trans-unit>
        <trans-unit id="5345ef8ed5a57eddad0fc38e73e7287b6270366c" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;forwarditerator&quot;&gt;LegacyForwardIterator&lt;/a&gt;, &lt;a href=&quot;bidirectionaliterator&quot;&gt;LegacyBidirectionalIterator&lt;/a&gt;, or &lt;a href=&quot;randomaccessiterator&quot;&gt;LegacyRandomAccessIterator&lt;/a&gt; satisfies the LegacyOutputIterator requirements in addition to its own requirements, it is described as &lt;b&gt;mutable&lt;/b&gt;.</source>
          <target state="translated">Когда &lt;a href=&quot;forwarditerator&quot;&gt;LegacyForwardIterator&lt;/a&gt; , &lt;a href=&quot;bidirectionaliterator&quot;&gt;LegacyBidirectionalIterator&lt;/a&gt; или &lt;a href=&quot;randomaccessiterator&quot;&gt;LegacyRandomAccessIterator&lt;/a&gt; удовлетворяет требованиям LegacyOutputIterator в дополнение к своим собственным требованиям, он описывается как &lt;b&gt;изменяемый&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="cc0170dca8716eb24882edf591a81dee83e562ee" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;#&lt;/code&gt; appears before &lt;code&gt;__VA_ARGS__&lt;/code&gt;, the entire expanded __VA_ARGS__ is enclosed in quotes:</source>
          <target state="translated">Когда &lt;code&gt;#&lt;/code&gt; появляется перед &lt;code&gt;__VA_ARGS__&lt;/code&gt; , весь расширенный __VA_ARGS__ заключается в кавычки:</target>
        </trans-unit>
        <trans-unit id="046623a30719eaa626e9121030272ea2805083f6" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;T&lt;/code&gt; is a (possibly cv-qualified) &lt;code&gt;void&lt;/code&gt;, it is unspecified whether function (1) is declared.</source>
          <target state="translated">Когда &lt;code&gt;T&lt;/code&gt; является (возможно, cv-квалифицированным) &lt;code&gt;void&lt;/code&gt; , не определено, объявлена ​​ли функция (1).</target>
        </trans-unit>
        <trans-unit id="bf6dcc3dc3f6b7e5ebe9923c510cc70615782d54" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;T&lt;/code&gt; is an array type, it is unspecified whether these member functions are declared, and if they are, what their return type is, except that the declaration (not necessarily the definition) of these functions is well-formed.</source>
          <target state="translated">Когда &lt;code&gt;T&lt;/code&gt; является типом массива, не определено, объявлены ли эти функции-члены и, если они есть, каков их тип возвращаемого значения, за исключением того, что объявление (не обязательно определение) этих функций правильно сформировано.</target>
        </trans-unit>
        <trans-unit id="97a2afc24ba5f22063e77c7d297d40d35897008d" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;T&lt;/code&gt; is not an array type, it is unspecified whether this function is declared. If the function is declared, it is unspecified what its return type is, except that the declaration (although not necessarily the definition) of the function is guaranteed to be legal.</source>
          <target state="translated">Когда &lt;code&gt;T&lt;/code&gt; не является типом массива, не указано, объявлена ​​ли эта функция. Если функция объявлена, то не указано, каков ее тип возврата, за исключением того, что объявление (хотя и не обязательно определение) функции гарантированно будет допустимым.</target>
        </trans-unit>
        <trans-unit id="841913a7a092250d0d74debefdc20a6387cf98d1" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;T&lt;/code&gt; is not an array type, the overloads (3), (4), and (6) enable &lt;code&gt;shared_from_this&lt;/code&gt; with &lt;code&gt;ptr&lt;/code&gt;, and the overload (13) enables &lt;code&gt;shared_from_this&lt;/code&gt; with the pointer returned by &lt;code&gt;r.release()&lt;/code&gt;.</source>
          <target state="translated">Когда &lt;code&gt;T&lt;/code&gt; не является типом массива, перегрузки (3), (4) и (6) активируют &lt;code&gt;shared_from_this&lt;/code&gt; с помощью &lt;code&gt;ptr&lt;/code&gt; , а перегрузка (13) &lt;code&gt;shared_from_this&lt;/code&gt; с указателем, возвращаемым &lt;code&gt;r.release()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="933697ca9b43c7b723b629859ce79b9ed2a3265c" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;isfinite(a) &amp;amp;&amp;amp; isfinite(b)&lt;/code&gt;, the following properties are guaranteed:</source>
          <target state="translated">Когда &lt;code&gt;isfinite(a) &amp;amp;&amp;amp; isfinite(b)&lt;/code&gt; , следующие свойства гарантированы:</target>
        </trans-unit>
        <trans-unit id="57eacd6a7d9600dd8cd2e42c3f2ae19d11ad628e" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;shared_ptr&lt;/code&gt; is created by calling &lt;code&gt;&lt;a href=&quot;shared_ptr/make_shared&quot;&gt;std::make_shared&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;shared_ptr/allocate_shared&quot;&gt;std::allocate_shared&lt;/a&gt;&lt;/code&gt;, the memory for both the control block and the managed object is created with a single allocation. The managed object is constructed in-place in a data member of the control block. When &lt;code&gt;shared_ptr&lt;/code&gt; is created via one of the &lt;code&gt;shared_ptr&lt;/code&gt; constructors, the managed object and the control block must be allocated separately. In this case, the control block stores a pointer to the managed object.</source>
          <target state="translated">Когда &lt;code&gt;shared_ptr&lt;/code&gt; создается вызовом &lt;code&gt;&lt;a href=&quot;shared_ptr/make_shared&quot;&gt;std::make_shared&lt;/a&gt;&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;shared_ptr/allocate_shared&quot;&gt;std::allocate_shared&lt;/a&gt;&lt;/code&gt; , память как для блока управления и управляемого объекта создаются с помощью одного распределения. Управляемый объект создается на месте в элементе данных блока управления. Когда &lt;code&gt;shared_ptr&lt;/code&gt; создается с помощью одного из конструкторов &lt;code&gt;shared_ptr&lt;/code&gt; , управляемый объект и блок управления должны быть выделены отдельно. В этом случае блок управления хранит указатель на управляемый объект.</target>
        </trans-unit>
        <trans-unit id="4833d1b8e7740b741eed936468b06c1d2f60499d" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;t&lt;/code&gt; is a &lt;a href=&quot;../language/reference#Forwarding_references&quot;&gt;forwarding reference&lt;/a&gt; (a function argument that is declared as an rvalue reference to a cv-unqualified function template parameter), this overload forwards the argument to another function with the &lt;a href=&quot;../language/value_category&quot;&gt;value category&lt;/a&gt; it had when passed to the calling function.</source>
          <target state="translated">Когда &lt;code&gt;t&lt;/code&gt; является &lt;a href=&quot;../language/reference#Forwarding_references&quot;&gt;ссылкой&lt;/a&gt; для пересылки (аргумент функции, который объявлен как rvalue-ссылка на параметр шаблона cqu-unqualified функции), эта перегрузка пересылает аргумент в другую функцию с &lt;a href=&quot;../language/value_category&quot;&gt;категорией значений, которую&lt;/a&gt; он имел при передаче вызывающей функции.</target>
        </trans-unit>
        <trans-unit id="f05559f6187d0eff998ef174b497dd5f9e035c58" translate="yes" xml:space="preserve">
          <source>When a &lt;code&gt;lock_guard&lt;/code&gt; object is created, it attempts to take ownership of the mutex it is given. When control leaves the scope in which the &lt;code&gt;lock_guard&lt;/code&gt; object was created, the &lt;code&gt;lock_guard&lt;/code&gt; is destructed and the mutex is released.</source>
          <target state="translated">Когда объект &lt;code&gt;lock_guard&lt;/code&gt; создан, он пытается завладеть предоставленным ему мьютексом. Когда элемент управления покидает область, в которой был создан объект &lt;code&gt;lock_guard&lt;/code&gt; , &lt;code&gt;lock_guard&lt;/code&gt; разрушается и мьютекс освобождается.</target>
        </trans-unit>
        <trans-unit id="e69de8ba0616baddc63eba743d4447e24a787005" translate="yes" xml:space="preserve">
          <source>When a &lt;code&gt;scoped_lock&lt;/code&gt; object is created, it attempts to take ownership of the mutexes it is given. When control leaves the scope in which the &lt;code&gt;scoped_lock&lt;/code&gt; object was created, the &lt;code&gt;scoped_lock&lt;/code&gt; is destructed and the mutexes are released, in reverse order. If several mutexes are given, deadlock avoidance algorithm is used as if by &lt;code&gt;&lt;a href=&quot;lock&quot;&gt;std::lock&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Когда объект &lt;code&gt;scoped_lock&lt;/code&gt; создается, он пытается завладеть предоставленными ему мьютексами. Когда элемент управления покидает область, в которой был создан объект &lt;code&gt;scoped_lock&lt;/code&gt; , &lt;code&gt;scoped_lock&lt;/code&gt; разрушается, и мьютексы освобождаются в обратном порядке. Если задано несколько мьютексов, алгоритм избежания тупиковой ситуации используется как бы &lt;code&gt;&lt;a href=&quot;lock&quot;&gt;std::lock&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="303d35d938cb833eac9338017dabe149a1c1712f" translate="yes" xml:space="preserve">
          <source>When a base class is intended for polymorphic use, its destructor may have to be declared public and virtual. This blocks implicit moves (and deprecates implicit copies), and so the special member functions have to be declared as defaulted&lt;sup id=&quot;cite_ref-2&quot;&gt;&lt;a href=&quot;rule_of_three#cite_note-2&quot;&gt;[2]&lt;/a&gt;&lt;/sup&gt;</source>
          <target state="translated">Когда базовый класс предназначен для полиморфного использования, его деструктор может быть объявлен открытым и виртуальным. Это блокирует неявные перемещения (и исключает неявные копии), и поэтому специальные функции-члены должны быть объявлены как значения по умолчанию &lt;sup id=&quot;cite_ref-2&quot;&gt;&lt;a href=&quot;rule_of_three#cite_note-2&quot;&gt;[2]&lt;/a&gt;&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="a38cdff86c855a9f5b8dafef92329da17987f83a" translate="yes" xml:space="preserve">
          <source>When a block declaration appears &lt;a href=&quot;statements#Compound_statements&quot;&gt;inside a block&lt;/a&gt;, and an identifier introduced by a declaration was previously declared in an outer block, the &lt;a href=&quot;scope&quot;&gt;outer declaration is hidden&lt;/a&gt; for the remainder of the block.</source>
          <target state="translated">Когда объявление блока появляется &lt;a href=&quot;statements#Compound_statements&quot;&gt;внутри блока&lt;/a&gt; , а идентификатор, введенный объявлением, был ранее объявлен во внешнем блоке, &lt;a href=&quot;scope&quot;&gt;внешнее объявление скрывается&lt;/a&gt; для оставшейся части блока.</target>
        </trans-unit>
        <trans-unit id="da9117b375eefc957e65150185d8008bdc45763a" translate="yes" xml:space="preserve">
          <source>When a class or variable(since C++14) template is instantiated, and there are partial specializations available, the compiler has to decide if the primary template is going to be used or one of its partial specializations.</source>
          <target state="translated">Когда шаблон класса или переменной (начиная с C++14)инстанцируется и доступны частичные специализации,компилятор должен решить,будет ли использоваться первичный шаблон или одна из его частичных специализаций.</target>
        </trans-unit>
        <trans-unit id="fea65df3178fced8b0ade7c9ce2a6ba4bc611c76" translate="yes" xml:space="preserve">
          <source>When a class template specialization is referenced in context that requires a complete object type, or when a function template specialization is referenced in context that requires a function definition to exist, the template is</source>
          <target state="translated">Когда на специализацию шаблона класса ссылаются в контексте,требующем полного типа объекта,или когда на специализацию шаблона функции ссылаются в контексте,требующем наличия определения функции,шаблон имеет вид</target>
        </trans-unit>
        <trans-unit id="5769c7acaf1d2335b2ca90b0ec55efa0d236a336" translate="yes" xml:space="preserve">
          <source>When a class uses &lt;code&gt;private&lt;/code&gt;&lt;a href=&quot;access&quot;&gt;member access specifier&lt;/a&gt; to derive from a base, all public and protected members of the base class are accessible as private members of the derived class (private members of the base are never accessible unless friended).</source>
          <target state="translated">Когда класс использует &lt;a href=&quot;access&quot;&gt;спецификатор доступа&lt;/a&gt; к &lt;code&gt;private&lt;/code&gt; члену для наследования от базы, все открытые и защищенные члены базового класса доступны как частные члены производного класса (закрытые члены базы никогда не будут доступны, если они не имеют друзей).</target>
        </trans-unit>
        <trans-unit id="2fcd782f662cbfb240e5bd78fca278b024889cc7" translate="yes" xml:space="preserve">
          <source>When a class uses &lt;code&gt;protected&lt;/code&gt;&lt;a href=&quot;access&quot;&gt;member access specifier&lt;/a&gt; to derive from a base, all public and protected members of the base class are accessible as protected members of the derived class (private members of the base are never accessible unless friended).</source>
          <target state="translated">Когда класс использует &lt;a href=&quot;access&quot;&gt;спецификатор доступа&lt;/a&gt; к &lt;code&gt;protected&lt;/code&gt; члену для наследования от базы, все открытые и защищенные члены базового класса доступны как защищенные члены производного класса (закрытые члены базы никогда не будут доступны, если они не имеют друзей).</target>
        </trans-unit>
        <trans-unit id="774bfe4108db2bde44499cb4a6ab68ddca8b923c" translate="yes" xml:space="preserve">
          <source>When a class uses &lt;code&gt;public&lt;/code&gt;&lt;a href=&quot;access&quot;&gt;member access specifier&lt;/a&gt; to derive from a base, all public members of the base class are accessible as public members of the derived class and all protected members of the base class are accessible as protected members of the derived class (private members of the base are never accessible unless friended).</source>
          <target state="translated">Когда класс использует &lt;code&gt;public&lt;/code&gt; &lt;a href=&quot;access&quot;&gt;спецификатор доступа&lt;/a&gt; к элементу для получения из базы, все открытые члены базового класса доступны как открытые члены производного класса, а все защищенные члены базового класса доступны как защищенные члены производного класса (частные члены из базы никогда не доступны, если не дружат).</target>
        </trans-unit>
        <trans-unit id="731c55e17d6e6e68ab60a46f9b70a72e60e6dd67" translate="yes" xml:space="preserve">
          <source>When a complete line of output needs to be flushed, the &lt;code&gt;&lt;a href=&quot;endl&quot;&gt;std::endl&lt;/a&gt;&lt;/code&gt; manipulator may be used.</source>
          <target state="translated">Когда необходимо очистить всю строку вывода, можно использовать манипулятор &lt;code&gt;&lt;a href=&quot;endl&quot;&gt;std::endl&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c302c1bc7c6fed86bcea489bc973092937f86e79" translate="yes" xml:space="preserve">
          <source>When a coroutine begins execution, it performs the following:</source>
          <target state="translated">Когда начинается исполнение корутины,она выполняет следующее:</target>
        </trans-unit>
        <trans-unit id="f150d08af5c8d72aecd740bc32ce2f1f91de3c2d" translate="yes" xml:space="preserve">
          <source>When a coroutine reaches a suspension point.</source>
          <target state="translated">Когда корутин достигает точки подвешивания.</target>
        </trans-unit>
        <trans-unit id="0c56a2828a8dc079acafa0f6578250d1ca9ad491" translate="yes" xml:space="preserve">
          <source>When a coroutine reaches the &lt;code&gt;co_return&lt;/code&gt; statement, it performs the following:</source>
          <target state="translated">Когда сопрограмма достигает оператора &lt;code&gt;co_return&lt;/code&gt; , она выполняет следующее:</target>
        </trans-unit>
        <trans-unit id="cf467bf3385d5e1232a7b50fd987d1bda1eb5b07" translate="yes" xml:space="preserve">
          <source>When a feature changes significantly, the macro will be updated accordingly.</source>
          <target state="translated">При значительном изменении функции макрос будет соответствующим образом обновлен.</target>
        </trans-unit>
        <trans-unit id="a1204ab37d3f0482e454433db039fd14f2d10599" translate="yes" xml:space="preserve">
          <source>When a file is included, it is processed by &lt;a href=&quot;../language/translation_phases&quot;&gt;translation phases&lt;/a&gt; 1-4, which may include, recursively, expansion of the nested &lt;code&gt;#include&lt;/code&gt; directives. To avoid repeated inclusion of the same file and endless recursion when a file includes itself, perhaps transitively,</source>
          <target state="translated">Когда файл включен, он обрабатывается &lt;a href=&quot;../language/translation_phases&quot;&gt;фазами трансляции&lt;/a&gt; 1-4, которые могут включать, рекурсивно, расширение вложенных директив &lt;code&gt;#include&lt;/code&gt; . Чтобы избежать повторного включения одного и того же файла и бесконечной рекурсии, когда файл включает себя, возможно, транзитивно,</target>
        </trans-unit>
        <trans-unit id="0f6ee751ce2ae6f2e1fe4fc82e2efbe71ee15f4f" translate="yes" xml:space="preserve">
          <source>When a friend declaration refers to a full specialization of a function template, the keyword &lt;code&gt;inline&lt;/code&gt; and default arguments cannot be used.</source>
          <target state="translated">Когда объявление друга ссылается на полную специализацию шаблона функции, ключевое слово &lt;code&gt;inline&lt;/code&gt; и аргументы по умолчанию не могут быть использованы.</target>
        </trans-unit>
        <trans-unit id="dd03b884a832ad273a2adbacad6fb75f476bfdf0" translate="yes" xml:space="preserve">
          <source>When a function is invoked, e.g. in a &lt;a href=&quot;operator_other#Built-in_function_call_operator&quot;&gt;function-call expression&lt;/a&gt;, the parameters are initialized from the arguments (either provided at the place of call or &lt;a href=&quot;default_arguments&quot;&gt;defaulted&lt;/a&gt;) and the statements in the function body are executed.</source>
          <target state="translated">Когда функция вызывается, например, в &lt;a href=&quot;operator_other#Built-in_function_call_operator&quot;&gt;выражении вызова функции&lt;/a&gt; , параметры инициализируются из аргументов (либо предоставленных в месте вызова, либо по &lt;a href=&quot;default_arguments&quot;&gt;умолчанию&lt;/a&gt; ), и выполняются операторы в теле функции.</target>
        </trans-unit>
        <trans-unit id="056da6db0024a8fc9e2178af3caa77a54e3aa303" translate="yes" xml:space="preserve">
          <source>When a function's return type is lvalue reference, the function call expression becomes an &lt;a href=&quot;value_category&quot;&gt;lvalue expression&lt;/a&gt;:</source>
          <target state="translated">Когда типом возврата функции является ссылка lvalue, выражение вызова функции становится &lt;a href=&quot;value_category&quot;&gt;выражением lvalue&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="4616bf2b5d98e8563f41341866c844e7ac6e8d1f" translate="yes" xml:space="preserve">
          <source>When a function-style cast or declaration of a variable uses the name of a primary class template &lt;code&gt;C&lt;/code&gt; without an argument list as the type specifier, deduction will proceed as follows:</source>
          <target state="translated">Когда приведение стиля функции или объявление переменной использует имя шаблона первичного класса &lt;code&gt;C&lt;/code&gt; без списка аргументов в качестве спецификатора типа, вывод будет выполняться следующим образом:</target>
        </trans-unit>
        <trans-unit id="703e91dee14a5d41272ff0618515064124c5ca74" translate="yes" xml:space="preserve">
          <source>When a lambda captures a member using implicit by-copy capture, it does not make a copy of that member variable: the use of a member variable &lt;code&gt;m&lt;/code&gt; is treated as an expression &lt;code&gt;(*this).m&lt;/code&gt;, and &lt;code&gt;*this&lt;/code&gt; is always implicitly captured by reference:</source>
          <target state="translated">Когда лямбда-член захватывает член с использованием неявного перехвата при копировании, он не создает копию этой переменной-члена: использование переменной-члена &lt;code&gt;m&lt;/code&gt; рассматривается как выражение &lt;code&gt;(*this).m&lt;/code&gt; , а &lt;code&gt;*this&lt;/code&gt; всегда фиксируется неявно по ссылке:</target>
        </trans-unit>
        <trans-unit id="3ea6ad3dcd073f66ca30ba43dbc0f20952f4603c" translate="yes" xml:space="preserve">
          <source>When a local class declares an unqualified function or class as a friend, only functions and classes in the innermost non-class scope are &lt;a href=&quot;lookup&quot;&gt;looked up&lt;/a&gt;, not the global functions:</source>
          <target state="translated">Когда локальный класс объявляет безоговорочную функцию или класса как друг, только функция и классы в сокровенных сферах неклассовых являются &lt;a href=&quot;lookup&quot;&gt;посмотрели&lt;/a&gt; , а не глобальные функции:</target>
        </trans-unit>
        <trans-unit id="8b46570618f5daf88923faf7d12da8873e3be80a" translate="yes" xml:space="preserve">
          <source>When a member is redeclared within the same class, it must do so under the same member access:</source>
          <target state="translated">Когда член повторно объявлен в том же классе,он должен сделать это под доступом того же самого члена:</target>
        </trans-unit>
        <trans-unit id="f224ac0d371f052e58a2217d4de98b1976737b0e" translate="yes" xml:space="preserve">
          <source>When a non-static class member is used in any of the contexts where the &lt;code&gt;this&lt;/code&gt; keyword is allowed (non-static member function bodies, member initializer lists, default member initializers), the implicit &lt;code&gt;this-&amp;gt;&lt;/code&gt; is automatically added before the name, resulting in a member access expression (which, if the member is a virtual member function, results in a virtual function call).</source>
          <target state="translated">Когда нестатический член класса используется в любом из контекстов, где разрешено ключевое слово &lt;code&gt;this&lt;/code&gt; (нестатические тела функций-членов, списки инициализаторов элементов, инициализаторы элементов по умолчанию), неявный &lt;code&gt;this-&amp;gt;&lt;/code&gt; автоматически добавляется перед именем, в результате чего в выражении доступа к члену (которое, если член является виртуальной функцией-членом, приводит к вызову виртуальной функции).</target>
        </trans-unit>
        <trans-unit id="c996fe1da1454bb286aadf030b85cfad7cae8fed" translate="yes" xml:space="preserve">
          <source>When a pointer to a protected member is formed, it must use a derived class in its declaration:</source>
          <target state="translated">Когда формируется указатель на защищаемый член,он должен использовать в своем объявлении производный класс:</target>
        </trans-unit>
        <trans-unit id="7fe22ece7b8d4604836b61b68f07304156388fd8" translate="yes" xml:space="preserve">
          <source>When a qualified name is used as a &lt;a href=&quot;declarations&quot;&gt;declarator&lt;/a&gt;, then &lt;a href=&quot;unqualified_lookup&quot;&gt;unqualified lookup&lt;/a&gt; of the names used in the same declarator that follow that qualified name, but not the names that precede it, is performed in the scope of the member's class or namespace:</source>
          <target state="translated">Если в качестве &lt;a href=&quot;declarations&quot;&gt;декларатора&lt;/a&gt; используется &lt;a href=&quot;unqualified_lookup&quot;&gt;полное&lt;/a&gt; имя, то в области действия класса или пространства имен члена выполняется неквалифицированный поиск имен, используемых в том же объявителе, которые следуют за этим квалифицированным именем, но не перед именами, предшествующими ему.</target>
        </trans-unit>
        <trans-unit id="7128500ddb4a19baad89fa94da4a6a51b2aa2144" translate="yes" xml:space="preserve">
          <source>When a signaling NaN is used as an argument to an arithmetic expression, the appropriate floating-point exception may be raised and the NaN is &quot;quieted&quot;, that is, the expression returns a quiet NaN.</source>
          <target state="translated">Когда в качестве аргумента к арифметическому выражению используется сигнальный NaN,соответствующее исключение с плавающей точкой может быть поднято,и NaN &quot;замкнуто&quot;,т.е.выражение возвращает тихий NaN.</target>
        </trans-unit>
        <trans-unit id="7f3acde83607f5ff6b438f0d494f026c16dc4d51" translate="yes" xml:space="preserve">
          <source>When a thread owns a &lt;code&gt;mutex&lt;/code&gt;, all other threads will block (for calls to &lt;a href=&quot;mutex/lock&quot;&gt;&lt;code&gt;lock&lt;/code&gt;&lt;/a&gt;) or receive a &lt;code&gt;false&lt;/code&gt; return value (for &lt;a href=&quot;mutex/try_lock&quot;&gt;&lt;code&gt;try_lock&lt;/code&gt;&lt;/a&gt;) if they attempt to claim ownership of the &lt;code&gt;mutex&lt;/code&gt;.</source>
          <target state="translated">Когда поток владеет &lt;code&gt;mutex&lt;/code&gt; , все другие потоки будут блокировать (для вызовов на &lt;a href=&quot;mutex/lock&quot;&gt; &lt;code&gt;lock&lt;/code&gt; &lt;/a&gt; ) или получать &lt;code&gt;false&lt;/code&gt; возвращаемое значение (для &lt;a href=&quot;mutex/try_lock&quot;&gt; &lt;code&gt;try_lock&lt;/code&gt; &lt;/a&gt; ), если они попытаются претендовать на владение &lt;code&gt;mutex&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="48235a61557c038c024774d3984da66f889dd511" translate="yes" xml:space="preserve">
          <source>When a thread owns a &lt;code&gt;recursive_mutex&lt;/code&gt;, all other threads will block (for calls to &lt;a href=&quot;recursive_mutex/lock&quot;&gt;&lt;code&gt;lock&lt;/code&gt;&lt;/a&gt;) or receive a &lt;code&gt;false&lt;/code&gt; return value (for &lt;a href=&quot;recursive_mutex/try_lock&quot;&gt;&lt;code&gt;try_lock&lt;/code&gt;&lt;/a&gt;) if they attempt to claim ownership of the &lt;code&gt;recursive_mutex&lt;/code&gt;.</source>
          <target state="translated">Когда потоку принадлежит &lt;code&gt;recursive_mutex&lt;/code&gt; , все остальные потоки заблокируют (для вызовов на &lt;a href=&quot;recursive_mutex/lock&quot;&gt; &lt;code&gt;lock&lt;/code&gt; &lt;/a&gt; ) или получат &lt;code&gt;false&lt;/code&gt; возвращаемое значение (для &lt;a href=&quot;recursive_mutex/try_lock&quot;&gt; &lt;code&gt;try_lock&lt;/code&gt; &lt;/a&gt; ), если они попытаются претендовать на владение &lt;code&gt;recursive_mutex&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="78d07a1734d460127f218d90a8985eff2cc5268d" translate="yes" xml:space="preserve">
          <source>When a thread reads a value from a memory location, it may see the initial value, the value written in the same thread, or the value written in another thread. See &lt;code&gt;&lt;a href=&quot;../atomic/memory_order&quot;&gt;std::memory_order&lt;/a&gt;&lt;/code&gt; for details on the order in which writes made from threads become visible to other threads.</source>
          <target state="translated">Когда поток читает значение из ячейки памяти, он может увидеть начальное значение, значение, записанное в том же потоке, или значение, записанное в другом потоке. Смотрите &lt;code&gt;&lt;a href=&quot;../atomic/memory_order&quot;&gt;std::memory_order&lt;/a&gt;&lt;/code&gt; для деталей о порядке, в котором записи, сделанные из потоков, становятся видимыми для других потоков.</target>
        </trans-unit>
        <trans-unit id="35914adcda38d9bc606dedbc8e87f226f4c33d60" translate="yes" xml:space="preserve">
          <source>When a unary fold is used with a pack expansion of length zero, only the following operators are allowed:</source>
          <target state="translated">При использовании одинарной папки с расширением пакета до нуля длины допускается использование только следующих операторов:</target>
        </trans-unit>
        <trans-unit id="a5725eb8b03373883cd17dd14b578f1aefe9ae18" translate="yes" xml:space="preserve">
          <source>When a union is initialized by aggregate initialization, only its first non-static data member is initialized.</source>
          <target state="translated">Когда объединение инициализируется совокупной инициализацией,инициализируется только его первый нестатический член.</target>
        </trans-unit>
        <trans-unit id="75156726fb61b37daeae849a8c23a8d3e99ac431" translate="yes" xml:space="preserve">
          <source>When a user-defined class overloads the function call operator, &lt;code&gt;operator()&lt;/code&gt;, it becomes a &lt;a href=&quot;../named_req/functionobject&quot;&gt;FunctionObject&lt;/a&gt; type. Many standard algorithms, from &lt;code&gt;&lt;a href=&quot;../algorithm/sort&quot;&gt;std::sort&lt;/a&gt;&lt;/code&gt; to &lt;code&gt;&lt;a href=&quot;../algorithm/accumulate&quot;&gt;std::accumulate&lt;/a&gt;&lt;/code&gt; accept objects of such types to customize behavior. There are no particularly notable canonical forms of &lt;code&gt;operator()&lt;/code&gt;, but to illustrate the usage.</source>
          <target state="translated">Когда пользовательский класс перегружает оператор вызова функции operator &lt;code&gt;operator()&lt;/code&gt; , он становится типом &lt;a href=&quot;../named_req/functionobject&quot;&gt;FunctionObject&lt;/a&gt; . Многие стандартные алгоритмы, от &lt;code&gt;&lt;a href=&quot;../algorithm/sort&quot;&gt;std::sort&lt;/a&gt;&lt;/code&gt; до &lt;code&gt;&lt;a href=&quot;../algorithm/accumulate&quot;&gt;std::accumulate&lt;/a&gt;&lt;/code&gt; принимают объекты таких типов для настройки поведения. Нет особо заметных канонических форм &lt;code&gt;operator()&lt;/code&gt; , но для иллюстрации использования.</target>
        </trans-unit>
        <trans-unit id="48f53b62820f7fe3746951152075f1cdb1ddd004" translate="yes" xml:space="preserve">
          <source>When a variadic function is called, after lvalue-to-rvalue, array-to-pointer, and function-to-pointer &lt;a href=&quot;implicit_cast#Lvalue_transformations&quot;&gt;conversions&lt;/a&gt;, each argument that is a part of the variable argument list undergoes additional conversions known as</source>
          <target state="translated">Когда VARIADIC функция вызываются после именующей к RValue, массива к указателю, а функция-на-указателю &lt;a href=&quot;implicit_cast#Lvalue_transformations&quot;&gt;преобразования&lt;/a&gt; , каждый аргумент , который является частью списка переменного аргумента претерпевает дополнительные преобразования , известные как</target>
        </trans-unit>
        <trans-unit id="4fc2bc7f5954311ab6cd53cf773a77f33b1fad76" translate="yes" xml:space="preserve">
          <source>When a virtual function call is made, the type returned by the final overrider is &lt;a href=&quot;implicit_cast&quot;&gt;implicitly converted&lt;/a&gt; to the return type of the overridden function that was called:</source>
          <target state="translated">Когда выполняется вызов виртуальной функции, тип, возвращаемый конечным переопределением, &lt;a href=&quot;implicit_cast&quot;&gt;неявно преобразуется&lt;/a&gt; в тип возврата переопределенной функции, которая была вызвана:</target>
        </trans-unit>
        <trans-unit id="93489141e89c6d227a8966329ac45e5e0c099d81" translate="yes" xml:space="preserve">
          <source>When a virtual function is called directly or indirectly from a constructor or from a destructor (including during the construction or destruction of the class&amp;rsquo;s non-static data members, e.g. in a member &lt;a href=&quot;constructor&quot;&gt;initializer list&lt;/a&gt;), and the object to which the call applies is the object under construction or destruction, the function called is the final overrider in the constructor&amp;rsquo;s or destructor&amp;rsquo;s class and not one overriding it in a more-derived class. In other words, during construction or destruction, the more-derived classes do not exist.</source>
          <target state="translated">Когда виртуальная функция вызывается прямо или косвенно из конструктора или из деструктора (в том числе во время создания или уничтожения нестатических элементов данных класса, например, в &lt;a href=&quot;constructor&quot;&gt;списке инициализатора&lt;/a&gt; члена ), и объект, к которому применяется вызов, является объект, находящийся в процессе строительства или уничтожения, вызываемая функция является окончательным переопределением в классе конструктора или деструктора, а не переопределением его в более производном классе. Другими словами, во время строительства или разрушения более производные классы не существуют.</target>
        </trans-unit>
        <trans-unit id="c93bab45e9c1d0dfc9ec2e952c16e1c1852bb4fb" translate="yes" xml:space="preserve">
          <source>When a weak compare-and-exchange would require a loop and a strong one would not, the strong one is preferable unless the object representation of &lt;code&gt;T&lt;/code&gt; may include padding bits,(until C++20) trap bits, or offers multiple object representations for the same value (e.g. floating-point NaN). In those cases, weak compare-and-exchange typically works because it quickly converges on some stable object representation.</source>
          <target state="translated">Когда для слабого сравнения и обмена потребуется цикл, а для сильного - нет, сильный вариант предпочтителен, если только объектное представление &lt;code&gt;T&lt;/code&gt; не может содержать биты заполнения, (до C ++ 20) биты-ловушки или не предлагает несколько представлений объекта для того же значения (например, с плавающей точкой NaN). В этих случаях слабое сравнение и обмен обычно работает, потому что оно быстро сходится к некоторому стабильному представлению объекта.</target>
        </trans-unit>
        <trans-unit id="b549d145a45bd55485a97603e36455b405b7f9e4" translate="yes" xml:space="preserve">
          <source>When a weak compare-and-exchange would require a loop and a strong one would not, the strong one is preferable unless the object representation of &lt;code&gt;T&lt;/code&gt; may include trap bits, or offers multiple object representations for the same value (e.g. floating-point NaN). In those cases, weak compare-and-exchange typically works because it quickly converges on some stable object representation.</source>
          <target state="translated">Когда для слабого сравнения и обмена потребуется цикл, а для сильного - нет, сильный вариант предпочтителен, если только объектное представление &lt;code&gt;T&lt;/code&gt; не может содержать биты ловушек или не предлагает несколько представлений объектов для одного и того же значения (например, NaN с плавающей точкой) ). В этих случаях слабое сравнение и обмен обычно работает, потому что оно быстро сходится к некоторому стабильному представлению объекта.</target>
        </trans-unit>
        <trans-unit id="3267a8eb3fe0cea3cd97459c2f9b3b8e6692761b" translate="yes" xml:space="preserve">
          <source>When active member of a union is switched by an assignment expression of the form &lt;code&gt;E1 = E2&lt;/code&gt; that uses either the built-in assignment operator or a trivial assignment operator, for each union member X that appears in the member access and array subscript subexpressions of &lt;code&gt;E1&lt;/code&gt; that is not a class with non-trivial or deleted default constructors, if modification of X would have undefined behavior under type aliasing rules, an object of the type of X is implicitly created in the nominated storage; no initialization is performed and the beginning of its lifetime is sequenced after the value computation of the left and right operands and before the assignment.</source>
          <target state="translated">Когда активный член объединения переключается выражением присваивания в форме &lt;code&gt;E1 = E2&lt;/code&gt; которое использует либо встроенный оператор присваивания, либо тривиальный оператор присваивания, для каждого члена объединения X, который появляется в подвыражениях доступа к элементу и подстрочного индекса массива &lt;code&gt;E1&lt;/code&gt; это не класс с нетривиальными или удаленными конструкторами по умолчанию; если модификация X будет иметь неопределенное поведение в соответствии с правилами псевдонимов типов, объект типа X неявно создается в назначенном хранилище; инициализация не выполняется, и начало его времени жизни определяется после вычисления значения левого и правого операндов и перед присваиванием.</target>
        </trans-unit>
        <trans-unit id="d56d5c0d1a9783bd328d5ceefac5e3f1fa5681a7" translate="yes" xml:space="preserve">
          <source>When all template arguments have been specified, deduced or obtained from default template arguments, every use of a template parameter in the function parameter list is replaced with the corresponding template arguments.</source>
          <target state="translated">Когда все аргументы шаблонов указаны,выведены или получены из аргументов шаблонов по умолчанию,каждое использование параметра шаблона в списке параметров функции заменяется на соответствующие аргументы шаблонов.</target>
        </trans-unit>
        <trans-unit id="b6e6698c4323b10a60e0746ae78192f4bab23b17" translate="yes" xml:space="preserve">
          <source>When allocating an object whose alignment requirement exceeds &lt;code&gt;__STDCPP_DEFAULT_NEW_ALIGNMENT__&lt;/code&gt; or an array of such objects, the new-expression passes the alignment requirement (wrapped in &lt;code&gt;&lt;a href=&quot;../memory/new/align_val_t&quot;&gt;std::align_val_t&lt;/a&gt;&lt;/code&gt;) as the second argument for the allocation function (for placement forms, &lt;code&gt;placement_params&lt;/code&gt; appear after the alignment, as the third, fourth, etc arguments). If overload resolution fails (which happens when a class-specific allocation function is defined with a different signature, since it hides the globals), overload resolution is attempted a second time, without alignment in the argument list. This allows alignment-unaware class-specific allocation functions to take precedence over the global alignment-aware allocation functions.</source>
          <target state="translated">При выделении объекта, требование выравнивания которого превышает &lt;code&gt;__STDCPP_DEFAULT_NEW_ALIGNMENT__&lt;/code&gt; , или массива таких объектов, выражение new передает требование выравнивания (обернутое в &lt;code&gt;&lt;a href=&quot;../memory/new/align_val_t&quot;&gt;std::align_val_t&lt;/a&gt;&lt;/code&gt; ) в качестве второго аргумента для функции выделения (для форм &lt;code&gt;placement_params&lt;/code&gt; , размещения_парамы появляются после выравнивания в качестве третьего, четвертого и т. д. аргументов). Если не удается разрешить перегрузку (что происходит, когда функция распределения для конкретного класса определена с другой сигнатурой, поскольку она скрывает глобальные переменные), повторное разрешение перегрузки предпринимается без выравнивания в списке аргументов. Это позволяет функциям распределения, не зависящим от выравнивания, иметь приоритет над функциями распределения с учетом глобального выравнивания.</target>
        </trans-unit>
        <trans-unit id="32f253fd06f69fca2aca9bf86ab82833c3ab166b" translate="yes" xml:space="preserve">
          <source>When allocating objects and arrays of objects whose alignment exceeds &lt;code&gt;__STDCPP_DEFAULT_NEW_ALIGNMENT__&lt;/code&gt;, overload resolution for placement forms is performed twice just as for regular forms: first, for alignment-aware function signatures, then for alignment-unaware function signatures.</source>
          <target state="translated">При выделении объектов и массивов объектов, выравнивание которых превышает &lt;code&gt;__STDCPP_DEFAULT_NEW_ALIGNMENT__&lt;/code&gt; , разрешение перегрузки для форм размещения выполняется дважды так же, как и для обычных форм: сначала для сигнатур функций, ориентированных на выравнивание, затем для сигнатур функций, не зависящих от выравнивания.</target>
        </trans-unit>
        <trans-unit id="fc6458ca664e9adb25872544f8c6cbc1b8d2ef56" translate="yes" xml:space="preserve">
          <source>When allocating objects and arrays of objects whose alignment exceeds &lt;code&gt;__STDCPP_DEFAULT_NEW_ALIGNMENT__&lt;/code&gt;, overload resolution is performed twice: first, for alignment-aware function signatures, then for alignment-unaware function signatures. This means that if a class with extended alignment has an alignment-unaware class-specific allocation function, it is the function that will be called, not the global alignment-aware allocation function. This is intentional: the class member is expected to know best how to handle that class.</source>
          <target state="translated">При выделении объектов и массивов объектов, выравнивание которых превышает &lt;code&gt;__STDCPP_DEFAULT_NEW_ALIGNMENT__&lt;/code&gt; , разрешение перегрузки выполняется дважды: сначала для сигнатур функций, связанных с выравниванием, затем для сигнатур функций, не зависящих от выравнивания. Это означает, что если класс с расширенным выравниванием имеет функцию выделения, не зависящую от выравнивания, то будет вызываться именно функция, а не функция выделения с учетом глобального выравнивания. Это сделано намеренно: ожидается, что ученик лучше знает, как обращаться с этим классом.</target>
        </trans-unit>
        <trans-unit id="dbe54944a43bccf5cf205c899d78217a14037efa" translate="yes" xml:space="preserve">
          <source>When an &lt;a href=&quot;eval_order&quot;&gt;evaluation&lt;/a&gt; of an expression writes to a memory location and another evaluation reads or modifies the same memory location, the expressions are said to</source>
          <target state="translated">Когда &lt;a href=&quot;eval_order&quot;&gt;оценка&lt;/a&gt; выражения записывает в ячейку памяти, а другая оценка считывает или изменяет ту же ячейку памяти, выражения называются</target>
        </trans-unit>
        <trans-unit id="f54b782cb8a2443df3f24c71942278de560d6c94" translate="yes" xml:space="preserve">
          <source>When an exception of type &lt;code&gt;E&lt;/code&gt; is thrown by any statement in compound-statement, it is matched against the types of the formal parameters &lt;code&gt;T&lt;/code&gt; of each catch-clause in handler-seq, in the order in which the catch clauses are listed. The exception is a match if any of the following is true:</source>
          <target state="translated">Когда исключение типа &lt;code&gt;E&lt;/code&gt; генерируется каким-либо оператором в составном операторе, оно сопоставляется с типами формальных параметров &lt;code&gt;T&lt;/code&gt; каждого предложения catch в handler-seq в том порядке, в котором перечислены предложения catch. Исключением является совпадение, если выполняется одно из следующих условий:</target>
        </trans-unit>
        <trans-unit id="141971b19d6009b0db3fb823a2039b332a4e6a99" translate="yes" xml:space="preserve">
          <source>When an explicit instantiation names a class template specialization, it serves as an explicit instantiation of the same kind (declaration or definition) of each of its non-inherited non-template members that has not been previously explicitly specialized in the translation unit. If this explicit instantiation is a definition, it is also an explicit instantiation definition only for the members that have been defined at this point.</source>
          <target state="translated">Когда эксплицитное инстанцирование называет специализацию шаблона класса,оно служит эксплицитным инстанцированием того же вида (объявления или определения)каждого из его неназванных членов,не являющихся шаблонами,которые ранее не были эксплицитно специализированными в модуле перевода.Если эта явная инстанцинация является определением,то она также является явным определением инстанцинации только для тех членов,которые были определены в данный момент.</target>
        </trans-unit>
        <trans-unit id="2e3df706304532f1fafe99d11c7b971952d33cd6" translate="yes" xml:space="preserve">
          <source>When an expression that uses type or non-type template parameters appears in the function parameter list or in the return type, that expression remains a part of the function template signature for the purpose of overloading:</source>
          <target state="translated">Когда выражение,использующее типовые или не типовые шаблонные параметры,появляется в списке параметров функции или в типе возврата,это выражение остается частью шаблонной сигнатуры функции с целью перегрузки:</target>
        </trans-unit>
        <trans-unit id="d6a2958786f5f2e3f6b231cd1ab5ade2e4415a58" translate="yes" xml:space="preserve">
          <source>When an incomplete line of output needs to be flushed, the &lt;code&gt;&lt;a href=&quot;flush&quot;&gt;std::flush&lt;/a&gt;&lt;/code&gt; manipulator may be used.</source>
          <target state="translated">Когда необходимо &lt;code&gt;&lt;a href=&quot;flush&quot;&gt;std::flush&lt;/a&gt;&lt;/code&gt; неполную строку вывода, можно использовать манипулятор std :: flush .</target>
        </trans-unit>
        <trans-unit id="ddca8d5dd1fab756efa48fbbb7d3a9d39e978269" translate="yes" xml:space="preserve">
          <source>When an object is first created, the cv-qualifiers used (which could be part of decl-specifier-seq or part of a declarator in a &lt;a href=&quot;declarations&quot;&gt;declaration&lt;/a&gt;, or part of type-id in a &lt;a href=&quot;new&quot;&gt;new-expression&lt;/a&gt;) determine the constness or volatility of the object, as follows:</source>
          <target state="translated">Когда объект создается впервые, используемые cv-квалификаторы (которые могут быть частью decl-specier-seq или частью декларатора в &lt;a href=&quot;declarations&quot;&gt;объявлении&lt;/a&gt; или частью type-id в &lt;a href=&quot;new&quot;&gt;новом выражении&lt;/a&gt; ) определяют постоянство или изменчивость объект, следующим образом:</target>
        </trans-unit>
        <trans-unit id="d130a7fb0dc18dd843e992986efede0bda37daa7" translate="yes" xml:space="preserve">
          <source>When an object of class type X is passed to or returned from a function, if each copy constructor, move constructor, and destructor of X is either trivial or deleted, and X has at least one non-deleted copy or move constructor, implementations are permitted to create a temporary object to hold the function parameter or result object.</source>
          <target state="translated">Когда в функцию передается или возвращается объект класса типа X,если каждый конструктор копирования,перемещения и деструктор X тривиален или удален,а X имеет хотя бы одну неудаленную копию или конструктор перемещения,реализации разрешены для создания временного объекта,в котором будет храниться параметр функции или объект-результат.</target>
        </trans-unit>
        <trans-unit id="01dd171c098fe6b55329621a15cc7367dee5f1d4" translate="yes" xml:space="preserve">
          <source>When an object of class type is &lt;a href=&quot;direct_initialization&quot;&gt;direct-initialized&lt;/a&gt; or &lt;a href=&quot;default_initialization&quot;&gt;default-initialized&lt;/a&gt; outside a &lt;a href=&quot;copy_initialization&quot;&gt;copy-initialization&lt;/a&gt; context, the candidate functions are all constructors of the class being initialized. The argument list is the expression list of the initializer.</source>
          <target state="translated">Когда объект типа класса &lt;a href=&quot;direct_initialization&quot;&gt;инициализируется напрямую&lt;/a&gt; или инициализируется по &lt;a href=&quot;default_initialization&quot;&gt;умолчанию&lt;/a&gt; вне контекста &lt;a href=&quot;copy_initialization&quot;&gt;инициализации копирования&lt;/a&gt; , все функции-кандидаты являются конструкторами инициализируемого класса. Список аргументов - это список выражений инициализатора.</target>
        </trans-unit>
        <trans-unit id="b112f8307a878b858abe15c415401e098531c633" translate="yes" xml:space="preserve">
          <source>When an object of class type is copy-initialized from an object of the same or derived class type, or default-initialized in a copy-initialization context, the candidate functions are all &lt;a href=&quot;converting_constructor&quot;&gt;converting constructors&lt;/a&gt; of the class being initialized. The argument list is the expression of the initializer.</source>
          <target state="translated">Когда объект типа класса инициализируется копией из объекта того же или производного типа класса, или инициализируется по умолчанию в контексте инициализации копирования, все функции-кандидаты являются &lt;a href=&quot;converting_constructor&quot;&gt;конструкторами преобразования&lt;/a&gt; инициализируемого класса. Список аргументов является выражением инициализатора.</target>
        </trans-unit>
        <trans-unit id="6c417ae51346e00b8f2e04143715b97da243d164" translate="yes" xml:space="preserve">
          <source>When an object of non-aggregate class type &lt;code&gt;T&lt;/code&gt; is &lt;a href=&quot;list_initialization&quot;&gt;list-initialized&lt;/a&gt;, two-phase overload resolution takes place.</source>
          <target state="translated">Когда объект не-агрегатного типа класса &lt;code&gt;T&lt;/code&gt; представляет &lt;a href=&quot;list_initialization&quot;&gt;список инициализирован&lt;/a&gt; , разрешение перегрузки двухфазного происходит.</target>
        </trans-unit>
        <trans-unit id="ae6288b4e0c89ad0ee91c5bb7ab0d2b10cfef5c7" translate="yes" xml:space="preserve">
          <source>When an object of some class &lt;code&gt;C&lt;/code&gt; is created, each non-static data member of non-reference type is allocated in some part of the object representation of &lt;code&gt;C&lt;/code&gt;. Whether reference members occupy any storage is implementation-defined, but their &lt;a href=&quot;storage_duration&quot;&gt;storage duration&lt;/a&gt; is the same as that of the object in which they are members.</source>
          <target state="translated">Когда объект некоторого класса &lt;code&gt;C&lt;/code&gt; создаются, каждый не-статический член данных без ссылочного типа выделяется в некоторой части объекта представления &lt;code&gt;C&lt;/code&gt; . То, занимают ли ссылочные элементы какое-либо хранилище, определяется реализацией, но их &lt;a href=&quot;storage_duration&quot;&gt;продолжительность хранения&lt;/a&gt; такая же, как и у объекта, членами которого они являются.</target>
        </trans-unit>
        <trans-unit id="63af81fffbdf1a90668b23768fdc0980bed3770a" translate="yes" xml:space="preserve">
          <source>When an object of type optional&amp;lt;T&amp;gt; is &lt;a href=&quot;../language/implicit_cast&quot;&gt;contextually converted to bool&lt;/a&gt;, the conversion returns &lt;code&gt;true&lt;/code&gt; if the object</source>
          <target state="translated">Когда объект необязательного типа &amp;lt;T&amp;gt; &lt;a href=&quot;../language/implicit_cast&quot;&gt;контекстно преобразуется в bool&lt;/a&gt; , преобразование возвращает &lt;code&gt;true&lt;/code&gt; , если объект</target>
        </trans-unit>
        <trans-unit id="1564a3bf1abdab4804c3b45d781d0743bc25fc6d" translate="yes" xml:space="preserve">
          <source>When an operator appears in an &lt;a href=&quot;expressions&quot;&gt;expression&lt;/a&gt;, and at least one of its operands has a &lt;a href=&quot;class&quot;&gt;class type&lt;/a&gt; or an &lt;a href=&quot;enum&quot;&gt;enumeration type&lt;/a&gt;, then &lt;a href=&quot;overload_resolution&quot;&gt;overload resolution&lt;/a&gt; is used to determine the user-defined function to be called among all the functions whose signatures match the following:</source>
          <target state="translated">Когда в &lt;a href=&quot;expressions&quot;&gt;выражении&lt;/a&gt; появляется оператор , и хотя бы один из его операндов имеет &lt;a href=&quot;class&quot;&gt;тип класса&lt;/a&gt; или тип &lt;a href=&quot;enum&quot;&gt;перечисления&lt;/a&gt; , то &lt;a href=&quot;overload_resolution&quot;&gt;разрешение перегрузки&lt;/a&gt; используется для определения пользовательской функции, которая должна вызываться среди всех функций, сигнатуры которых соответствуют следующему:</target>
        </trans-unit>
        <trans-unit id="fb0096bc731b7218f872e304d201c5d20ef5e918" translate="yes" xml:space="preserve">
          <source>When an unscoped enumeration is a class member, its enumerators may be accessed using class member access operators &lt;code&gt;.&lt;/code&gt; and &lt;code&gt;-&amp;gt;&lt;/code&gt;:</source>
          <target state="translated">Когда перечисление с незаданной областью является членом класса, доступ к его перечислителям можно получить с помощью операторов доступа к членам класса &lt;code&gt;.&lt;/code&gt; и &lt;code&gt;-&amp;gt;&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="6f67767f1271f59038f6527a10110416f4a16657" translate="yes" xml:space="preserve">
          <source>When applied to a class type, the result is the size of an object of that class plus any additional padding required to place such object in an array.</source>
          <target state="translated">При применении к типу класса в результате получается размер объекта этого класса плюс любая дополнительная подкладка,необходимая для размещения такого объекта в массиве.</target>
        </trans-unit>
        <trans-unit id="ad0c1d3f6453f804c34d81d7a95f3f37e5786005" translate="yes" xml:space="preserve">
          <source>When applied to a class, the identifier &lt;code&gt;final&lt;/code&gt; appears at the beginning of the class definition, immediately after the name of the class.</source>
          <target state="translated">При применении к классу идентификатор &lt;code&gt;final&lt;/code&gt; появляется в начале определения класса, сразу после имени класса.</target>
        </trans-unit>
        <trans-unit id="ebcafd6f66dd47f9f7ba53777289ab2dbc04fbca" translate="yes" xml:space="preserve">
          <source>When applied to a member function, the identifier &lt;code&gt;final&lt;/code&gt; appears immediately after the &lt;a href=&quot;function&quot;&gt;declarator&lt;/a&gt; in the syntax of a member function declaration or a member function definition inside a class definition.</source>
          <target state="translated">При применении к функции-члену &lt;code&gt;final&lt;/code&gt; идентификатор появляется сразу после &lt;a href=&quot;function&quot;&gt;объявления&lt;/a&gt; в синтаксисе объявления функции-члена или определения функции-члена внутри определения класса.</target>
        </trans-unit>
        <trans-unit id="64935cc54ab77b2b7e3b4674a370a21df9f2ba1a" translate="yes" xml:space="preserve">
          <source>When applied to a pointer, the subscript expression is always an lvalue.</source>
          <target state="translated">При применении к указателю выражение в подскрипте всегда является значением l.</target>
        </trans-unit>
        <trans-unit id="3fa5cb2eff44efae521c7cddc759eb971197f991" translate="yes" xml:space="preserve">
          <source>When applied to a reference type, the result is the size of the referenced type.</source>
          <target state="translated">При применении к типу ссылки результатом является размер ссылающегося типа.</target>
        </trans-unit>
        <trans-unit id="f4ae2ed79afdeb8f6c2a098503944e0bac2fe877" translate="yes" xml:space="preserve">
          <source>When applied to an array, the subscript expression is an &lt;a href=&quot;value_category&quot;&gt;lvalue&lt;/a&gt; if the array is an lvalue, and an &lt;a href=&quot;value_category&quot;&gt;xvalue&lt;/a&gt; if it isn't(since C++11).</source>
          <target state="translated">Когда применяется к массиву, выражение индекса является &lt;a href=&quot;value_category&quot;&gt;lvalue,&lt;/a&gt; если массив является lvalue, и &lt;a href=&quot;value_category&quot;&gt;xvalue,&lt;/a&gt; если это не так (начиная с C ++ 11).</target>
        </trans-unit>
        <trans-unit id="b3759c1c966a143bdfd4814a06fb7b793ddc31c8" translate="yes" xml:space="preserve">
          <source>When applied to an expression of polymorphic type, evaluation of a typeid expression may involve runtime overhead (a virtual table lookup), otherwise typeid expression is resolved at compile time.</source>
          <target state="translated">При применении к выражению полиморфного типа оценка типичного выражения может быть связана с накладными затратами времени (виртуальный поиск таблицы),в противном случае типичное выражение разрешается во время компиляции.</target>
        </trans-unit>
        <trans-unit id="e5ed37890741158bbf054cf52a8ebbc0e73b98c9" translate="yes" xml:space="preserve">
          <source>When applied to an expression, &lt;code&gt;sizeof&lt;/code&gt; does &lt;a href=&quot;expressions#Unevaluated_expressions&quot;&gt;not evaluate the expression&lt;/a&gt;, and even if the expression designates a polymorphic object, the result is the size of the static type of the expression. Lvalue-to-rvalue, array-to-pointer, or function-to-pointer conversions are not performed. &lt;a href=&quot;implicit_cast#Temporary_materialization&quot;&gt;Temporary materialization&lt;/a&gt;, however, is (formally) performed for prvalue arguments: sizeof determines the size of the result object.(since C++17).</source>
          <target state="translated">При нанесении на выражение, &lt;code&gt;sizeof&lt;/code&gt; никак &lt;a href=&quot;expressions#Unevaluated_expressions&quot;&gt;не оценивает выражение&lt;/a&gt; , и даже если выражение обозначает полиморфный объект, результат является размером типа статического выражения. Преобразование Lvalue-в-значение, массив-в-указатель или функция-в-указатель не выполняется. &lt;a href=&quot;implicit_cast#Temporary_materialization&quot;&gt;Временная материализация&lt;/a&gt; , однако, (формально) выполняется для аргументов prvalue: sizeof определяет размер объекта результата (начиная с C ++ 17).</target>
        </trans-unit>
        <trans-unit id="902efcbdae8639c2479afc412e93c5b16435e58a" translate="yes" xml:space="preserve">
          <source>When calling the allocation function, the new-expression passes the number of bytes requested as the first argument, of type &lt;code&gt;&lt;a href=&quot;../types/size_t&quot;&gt;std::size_t&lt;/a&gt;&lt;/code&gt;, which is exactly &lt;code&gt;sizeof(T)&lt;/code&gt; for non-array &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">При вызове функции распределения, новое выражение передает количество байт , запрошенных в качестве первого аргумента, типа &lt;code&gt;&lt;a href=&quot;../types/size_t&quot;&gt;std::size_t&lt;/a&gt;&lt;/code&gt; , который точно &lt;code&gt;sizeof(T)&lt;/code&gt; для не-массива &lt;code&gt;T&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7aab9cd14cb0a3097419a3a095e5a8499afb16ff" translate="yes" xml:space="preserve">
          <source>When code refers to a function in context that requires the function definition to exist, and this particular function has not been explicitly instantiated, implicit instantiation occurs. The list of template arguments does not have to be supplied if it can be &lt;a href=&quot;template_argument_deduction&quot;&gt;deduced&lt;/a&gt; from context.</source>
          <target state="translated">Когда код ссылается на функцию в контексте, которая требует определения функции, и эта конкретная функция не была явно создана, происходит неявная реализация. Список аргументов шаблона не нужно указывать, если он может быть &lt;a href=&quot;template_argument_deduction&quot;&gt;выведен&lt;/a&gt; из контекста.</target>
        </trans-unit>
        <trans-unit id="2f3a994250d478ff5309a561ec4f4f714968e84d" translate="yes" xml:space="preserve">
          <source>When code refers to a template in context that requires a completely defined type, or when the completeness of the type affects the code, and this particular type has not been explicitly instantiated, implicit instantiation occurs. For example, when an object of this type is constructed, but not when a pointer to this type is constructed.</source>
          <target state="translated">Когда код ссылается на шаблон в контексте,требующем полностью определенного типа,или когда полнота типа влияет на код,и этот конкретный тип не был явно инстанцирован,происходит неявная инстанциация.Например,когда построен объект данного типа,а не когда построен указатель на данный тип.</target>
        </trans-unit>
        <trans-unit id="e579a073bc59e27215b96008dac2e50df4bb57db" translate="yes" xml:space="preserve">
          <source>When comparing entire containers for equality, &lt;code&gt;operator==&lt;/code&gt; for the corresponding container are usually preferred.</source>
          <target state="translated">При сравнении всех контейнеров на равенство обычно предпочтительнее &lt;code&gt;operator==&lt;/code&gt; для соответствующего контейнера.</target>
        </trans-unit>
        <trans-unit id="47745284a6ed97288740ca09ddbb9f643055ef39" translate="yes" xml:space="preserve">
          <source>When considering the argument to a constructor or to a user-defined conversion function, only one standard conversion sequence is allowed (otherwise user-defined conversions could be effectively chained). When converting from one built-in type to another built-in type, only one standard conversion sequence is allowed.</source>
          <target state="translated">При рассмотрении аргумента к конструктору или к определяемой пользователем функции преобразования допускается только одна стандартная последовательность преобразования (в противном случае определяемые пользователем преобразования могут быть эффективно сцеплены).При преобразовании из одного встроенного типа в другой встроенный тип допускается только одна стандартная последовательность преобразования.</target>
        </trans-unit>
        <trans-unit id="553ce681044a1dac36f2a3c93df19f57a9078616" translate="yes" xml:space="preserve">
          <source>When constructing a complex class with multiple branches, within a constructor that belongs to one branch, polymorphism is restricted to that class and its bases: if it obtains a pointer or reference to a base subobject outside this subhierarchy, and attempts to invoke a virtual function call (e.g. using explicit member access), the behavior is undefined:</source>
          <target state="translated">При построении сложного класса с несколькими ветвями,внутри конструктора,принадлежащего одной ветви,полиморфизм ограничивается этим классом и его основаниями:если он получает указатель или ссылку на базовый подобъект вне этой подиерархии и пытается вызвать вызов виртуальной функции (например,с помощью явного доступа к члену),поведение будет неопределенным:</target>
        </trans-unit>
        <trans-unit id="aed446bf94f330e6e0b55d02da8f34b88ffea9e7" translate="yes" xml:space="preserve">
          <source>When copy elision occurs, the implementation treats the source and target of the omitted copy/move(since C++11) operation as simply two different ways of referring to the same object, and the destruction of that object occurs at the later of the times when the two objects would have been destroyed without the optimization (except that, if the parameter of the selected constructor is an rvalue reference to object type, the destruction occurs when the target would have been destroyed)(since C++17).</source>
          <target state="translated">Когда происходит элизия копии,реализация рассматривает источник и цель опущенной операции копирования/перемещения (начиная с C++11)как просто два разных способа обращения к одному и тому же объекту,и уничтожение этого объекта происходит в более поздний момент,когда оба объекта были бы уничтожены без оптимизации (за исключением того,что если параметром выбранного конструктора является ссылка rvalue на тип объекта,то уничтожение происходит,когда цель была бы уничтожена)(начиная с C++17).</target>
        </trans-unit>
        <trans-unit id="2dc86f028e3cfb1147dc7e004b4c16749351361e" translate="yes" xml:space="preserve">
          <source>When copying overlapping ranges, &lt;code&gt;std::copy&lt;/code&gt; is appropriate when copying to the left (beginning of the destination range is outside the source range) while &lt;code&gt;std::copy_backward&lt;/code&gt; is appropriate when copying to the right (end of the destination range is outside the source range).</source>
          <target state="translated">При копировании перекрывающихся диапазонов, &lt;code&gt;std::copy&lt;/code&gt; подходит для копирования влево (начало диапазона назначения выходит за пределы исходного диапазона), а &lt;code&gt;std::copy_backward&lt;/code&gt; подходит для копирования вправо (конец диапазона назначения находится вне источника ассортимент).</target>
        </trans-unit>
        <trans-unit id="63771776b0fe78c4297c086089bcc7b025dc8ded" translate="yes" xml:space="preserve">
          <source>When declaring a function, &lt;a href=&quot;except_spec&quot;&gt; exception specifications&lt;/a&gt; and &lt;a href=&quot;noexcept_spec&quot;&gt; noexcept specifiers&lt;/a&gt; may be provided to limit the types of the exceptions a function may throw.</source>
          <target state="translated">При объявлении функции, &lt;a href=&quot;except_spec&quot;&gt;спецификации исключений&lt;/a&gt; и &lt;a href=&quot;noexcept_spec&quot;&gt;noexcept спецификаторы&lt;/a&gt; могут быть предоставлены , чтобы ограничить типы исключений функции может бросить.</target>
        </trans-unit>
        <trans-unit id="a46821f25349d54835cd348827a97ba1db7215ad" translate="yes" xml:space="preserve">
          <source>When defining a member of an explicitly specialized class template outside the body of the class, the syntax &lt;code&gt;template &amp;lt;&amp;gt;&lt;/code&gt; is not used, except if it's a member of an explicitly specialized member class template, which is specialized as a class template, because otherwise, the syntax would require such definition to begin with &lt;code&gt;template&amp;lt;parameters&amp;gt;&lt;/code&gt; required by the nested template.</source>
          <target state="translated">При определении члена явно специализированного шаблона класса вне тела класса синтаксический &lt;code&gt;template &amp;lt;&amp;gt;&lt;/code&gt; не используется, за исключением случаев, когда он является членом явно специализированного шаблона класса члена, который специализируется как шаблон класса, потому что в противном случае, синтаксис требует, чтобы такое определение начиналось с &lt;code&gt;template&amp;lt;parameters&amp;gt;&lt;/code&gt; требуется для вложенного шаблона.</target>
        </trans-unit>
        <trans-unit id="80a330b63ba0a84c45e73880291aa572a3efa1e6" translate="yes" xml:space="preserve">
          <source>When determining if two &lt;a href=&quot;dependent_name&quot;&gt;dependent expressions&lt;/a&gt; are equivalent, only the dependent names involved are considered, not the results of name lookup. If multiple declarations of the same template differ in the result of name lookup, the first such declaration is used:</source>
          <target state="translated">При определении эквивалентности двух &lt;a href=&quot;dependent_name&quot;&gt;зависимых выражений&lt;/a&gt; учитываются только задействованные зависимые имена, а не результаты поиска по имени. Если в результате поиска имени несколько объявлений одного и того же шаблона различаются, используется первое такое объявление:</target>
        </trans-unit>
        <trans-unit id="7ef9fbc568a29fc667929a02fb6d63098b804ede" translate="yes" xml:space="preserve">
          <source>When directly used as the condition of &lt;a href=&quot;../language/static_assert&quot;&gt;&lt;code&gt;static_assert&lt;/code&gt; declaration&lt;/a&gt; or &lt;a href=&quot;../language/if#constexpr_if&quot;&gt;constexpr if statement&lt;/a&gt;, &lt;code&gt;std::is_constant_evaluated()&lt;/code&gt; always returns &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">Когда используется непосредственно в качестве условия &lt;a href=&quot;../language/static_assert&quot;&gt; &lt;code&gt;static_assert&lt;/code&gt; декларации&lt;/a&gt; или &lt;a href=&quot;../language/if#constexpr_if&quot;&gt;constexpr , если заявление&lt;/a&gt; , &lt;code&gt;std::is_constant_evaluated()&lt;/code&gt; всегда возвращает &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="18b778058d4f47bf64716da2bbf948a1a5fb94a5" translate="yes" xml:space="preserve">
          <source>When earlier tiebreakers, including partial ordering, failed to distinguish between two candidate function templates, the following rules apply:</source>
          <target state="translated">В тех случаях,когда в предыдущих тай-брейках,в том числе при частичном заказе,не удавалось провести различие между двумя шаблонами функций кандидата,применяются следующие правила:</target>
        </trans-unit>
        <trans-unit id="c5dfcd38376374c25b198c54aa21d3fdad95c984" translate="yes" xml:space="preserve">
          <source>When enabled, for an object &lt;code&gt;o&lt;/code&gt; of type &lt;code&gt;std::optional&amp;lt;T&amp;gt;&lt;/code&gt; that contains a value, &lt;code&gt;std::hash&amp;lt;std::optional&amp;lt;T&amp;gt;&amp;gt;()(o)&lt;/code&gt; evaluates to the same value as &lt;code&gt;std::hash&amp;lt;std::remove_const_t&amp;lt;T&amp;gt;&amp;gt;()(*o)&lt;/code&gt;. For an optional that does not contain a value, the hash is unspecified.</source>
          <target state="translated">При включении для объекта &lt;code&gt;o&lt;/code&gt; типа &lt;code&gt;std::optional&amp;lt;T&amp;gt;&lt;/code&gt; который содержит значение, &lt;code&gt;std::hash&amp;lt;std::optional&amp;lt;T&amp;gt;&amp;gt;()(o)&lt;/code&gt; возвращает то же значение, что и &lt;code&gt;std::hash&amp;lt;std::remove_const_t&amp;lt;T&amp;gt;&amp;gt;()(*o)&lt;/code&gt; . Для необязательного, который не содержит значения, хеш не указан.</target>
        </trans-unit>
        <trans-unit id="903d975e1994ac3a37b90733c8025f08ecf31a3c" translate="yes" xml:space="preserve">
          <source>When enabled,(since C++17) for a given &lt;code&gt;&lt;a href=&quot;../unique_ptr&quot;&gt;std::unique_ptr&lt;/a&gt;&amp;lt;T, D&amp;gt; p&lt;/code&gt;, this specialization ensures that &lt;code&gt;&lt;a href=&quot;../../utility/hash&quot;&gt;std::hash&lt;/a&gt;&amp;lt;&lt;a href=&quot;../unique_ptr&quot;&gt;std::unique_ptr&lt;/a&gt;&amp;lt;T, D&amp;gt;&amp;gt;()(p) == &lt;a href=&quot;../../utility/hash&quot;&gt;std::hash&lt;/a&gt;&amp;lt;typename &lt;a href=&quot;../unique_ptr&quot;&gt;std::unique_ptr&lt;/a&gt;&amp;lt;T, D&amp;gt;::pointer&amp;gt;()(p.get())&lt;/code&gt;.</source>
          <target state="translated">При включении (начиная с C ++ 17) для данного &lt;code&gt;&lt;a href=&quot;../unique_ptr&quot;&gt;std::unique_ptr&lt;/a&gt;&amp;lt;T, D&amp;gt; p&lt;/code&gt; эта специализация гарантирует, что &lt;code&gt;&lt;a href=&quot;../../utility/hash&quot;&gt;std::hash&lt;/a&gt;&amp;lt;&lt;a href=&quot;../unique_ptr&quot;&gt;std::unique_ptr&lt;/a&gt;&amp;lt;T, D&amp;gt;&amp;gt;()(p) == &lt;a href=&quot;../../utility/hash&quot;&gt;std::hash&lt;/a&gt;&amp;lt;typename &lt;a href=&quot;../unique_ptr&quot;&gt;std::unique_ptr&lt;/a&gt;&amp;lt;T, D&amp;gt;::pointer&amp;gt;()(p.get())&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="19ae5f22223dec57ebaf47feb7ebf7c7e201fce6" translate="yes" xml:space="preserve">
          <source>When entering a catch clause, if its formal parameter is a base class of the exception type, it is &lt;a href=&quot;copy_initialization&quot;&gt;copy-initialized&lt;/a&gt; from the base class subobject of the exception object. Otherwise, it is copy-initialized from the exception object (this copy is subject to &lt;a href=&quot;copy_elision&quot;&gt;copy elision&lt;/a&gt;).</source>
          <target state="translated">При вводе предложения catch, если его формальный параметр является базовым классом типа исключения, он &lt;a href=&quot;copy_initialization&quot;&gt;инициализируется копированием&lt;/a&gt; из подобъекта базового класса объекта исключения. В противном случае он инициализируется копией из объекта исключения (эта копия подлежит &lt;a href=&quot;copy_elision&quot;&gt;копированию&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="16fd800e4f4545dc8c54147c76bdffd06523fe14" translate="yes" xml:space="preserve">
          <source>When erasing at either end of the deque, references to non-erased elements are not invalidated by &lt;code&gt;&lt;a href=&quot;deque/erase&quot;&gt;erase&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;deque/pop_front&quot;&gt;pop_front&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;deque/pop_back&quot;&gt;pop_back&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">При стирании на любом конце двусторонней очереди, ссылки на нестираемым элементы не признаны недействительными &lt;code&gt;&lt;a href=&quot;deque/erase&quot;&gt;erase&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;deque/pop_front&quot;&gt;pop_front&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;deque/pop_back&quot;&gt;pop_back&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3e154c534821f10918bbd1a0adb594ebb17181d9" translate="yes" xml:space="preserve">
          <source>When every character of output needs to be flushed, the &lt;code&gt;&lt;a href=&quot;unitbuf&quot;&gt;std::unitbuf&lt;/a&gt;&lt;/code&gt; manipulator may be used.</source>
          <target state="translated">Когда каждый символ выходных данных должен быть &lt;code&gt;&lt;a href=&quot;unitbuf&quot;&gt;std::unitbuf&lt;/a&gt;&lt;/code&gt; можно использовать манипулятор std :: unitbuf .</target>
        </trans-unit>
        <trans-unit id="3a9eae4e1a206e51541973ab38f172716a809f23" translate="yes" xml:space="preserve">
          <source>When every output operation needs to be flushed, the &lt;code&gt;&lt;a href=&quot;unitbuf&quot;&gt;std::unitbuf&lt;/a&gt;&lt;/code&gt; manipulator may be used.</source>
          <target state="translated">Когда каждая выходная операция должна быть &lt;code&gt;&lt;a href=&quot;unitbuf&quot;&gt;std::unitbuf&lt;/a&gt;&lt;/code&gt; можно использовать манипулятор std :: unitbuf .</target>
        </trans-unit>
        <trans-unit id="de9fb1f75fc610360e59b80abf945bf3f980c7f7" translate="yes" xml:space="preserve">
          <source>When formatting a floating point value as hexfloat (i.e., when &lt;code&gt;floatfield == (&lt;a href=&quot;../../io/ios_base/fmtflags&quot;&gt;std::ios_base::fixed&lt;/a&gt; | &lt;a href=&quot;../../io/ios_base/fmtflags&quot;&gt;std::ios_base::scientific&lt;/a&gt;)&lt;/code&gt;), the stream's precision is not used; instead, the number is always printed with enough precision to exactly represent the value.</source>
          <target state="translated">При форматировании значения с плавающей точкой в ​​виде hexfloat (то есть, когда &lt;code&gt;floatfield == (&lt;a href=&quot;../../io/ios_base/fmtflags&quot;&gt;std::ios_base::fixed&lt;/a&gt; | &lt;a href=&quot;../../io/ios_base/fmtflags&quot;&gt;std::ios_base::scientific&lt;/a&gt;)&lt;/code&gt; ), точность потока не используется; вместо этого число всегда печатается с достаточной точностью, чтобы точно представлять значение.</target>
        </trans-unit>
        <trans-unit id="a40d58e1eae50e8055be19035d8b5887a01317a2" translate="yes" xml:space="preserve">
          <source>When given reference types, &lt;code&gt;common_reference&lt;/code&gt; attempts to find a reference type to which the supplied reference types can all be bound, but may return a non-reference type if it cannot find such a reference type.</source>
          <target state="translated">Когда заданы ссылочные типы, &lt;code&gt;common_reference&lt;/code&gt; пытается найти ссылочный тип, к которому могут быть привязаны все предоставленные ссылочные типы, но может вернуть не ссылочный тип, если не может найти такой ссылочный тип.</target>
        </trans-unit>
        <trans-unit id="dd4bc57db1751ca1bef7fa50506950271e3c5d18" translate="yes" xml:space="preserve">
          <source>When indexing C++ containers, such as &lt;code&gt;&lt;a href=&quot;../string/basic_string&quot;&gt;std::string&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../container/vector&quot;&gt;std::vector&lt;/a&gt;&lt;/code&gt;, etc, the appropriate type is the member typedef &lt;code&gt;size_type&lt;/code&gt; provided by such containers. It is usually defined as a synonym for &lt;code&gt;std::size_t&lt;/code&gt;.</source>
          <target state="translated">При индексировании контейнеров C ++, таких как &lt;code&gt;&lt;a href=&quot;../string/basic_string&quot;&gt;std::string&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../container/vector&quot;&gt;std::vector&lt;/a&gt;&lt;/code&gt; и т. Д., Соответствующий тип является членом typedef &lt;code&gt;size_type&lt;/code&gt; , предоставляемым такими контейнерами. Обычно он определяется как синоним для &lt;code&gt;std::size_t&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9ac68fbcc8bc1efc6049dde60f0e30093d3a91f7" translate="yes" xml:space="preserve">
          <source>When initialization of an object of non-class type cv1 &lt;code&gt;T&lt;/code&gt; requires a &lt;a href=&quot;cast_operator&quot;&gt;user-defined conversion function&lt;/a&gt; to convert from an initializer expression of class type cv &lt;code&gt;S&lt;/code&gt;, the following functions are candidates:</source>
          <target state="translated">Когда для инициализации объекта неклассового типа cv1 &lt;code&gt;T&lt;/code&gt; требуется &lt;a href=&quot;cast_operator&quot;&gt;пользовательская функция&lt;/a&gt; преобразования для преобразования из выражения инициализатора типа cv &lt;code&gt;S&lt;/code&gt; класса , следующие функции являются кандидатами:</target>
        </trans-unit>
        <trans-unit id="f2f9ef8bbb329e61c10d08ae998e3ab7e71030d3" translate="yes" xml:space="preserve">
          <source>When initializing from a single argument of a type that is a specialization of the class template at issue, copying deduction is generally preferred over wrapping by default:</source>
          <target state="translated">При инициализации с одного аргумента типа,который является специализацией шаблона класса,вычет копирования,как правило,предпочтительнее обертки по умолчанию:</target>
        </trans-unit>
        <trans-unit id="d46960739a911c065792d3eb6a771bd67fb54134" translate="yes" xml:space="preserve">
          <source>When inserting a range, the range version of &lt;code&gt;&lt;a href=&quot;insert&quot;&gt;insert()&lt;/a&gt;&lt;/code&gt; is generally preferable as it preserves the correct capacity growth behavior, unlike &lt;code&gt;reserve()&lt;/code&gt; followed by a series of &lt;code&gt;&lt;a href=&quot;push_back&quot;&gt;push_back()&lt;/a&gt;&lt;/code&gt;s.</source>
          <target state="translated">При вставке диапазона, версия диапазона &lt;code&gt;&lt;a href=&quot;insert&quot;&gt;insert()&lt;/a&gt;&lt;/code&gt; как правило, предпочтительнее, поскольку сохраняет правильное поведение при наращивании емкости, в отличие от &lt;code&gt;reserve()&lt;/code&gt; за которым следует серия &lt;code&gt;&lt;a href=&quot;push_back&quot;&gt;push_back()&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="906401050b55fc9b72b5d2421e9144fbb190452a" translate="yes" xml:space="preserve">
          <source>When inserting at either end of the deque, references are not invalidated by &lt;code&gt;&lt;a href=&quot;deque/insert&quot;&gt;insert&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;deque/emplace&quot;&gt;emplace&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">При вставке в любом конце deque ссылки не аннулируются &lt;code&gt;&lt;a href=&quot;deque/insert&quot;&gt;insert&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;deque/emplace&quot;&gt;emplace&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d58dc4a9c1d64bc2047ee755578c50f3b966be84" translate="yes" xml:space="preserve">
          <source>When instantiated with one of the floating-point types &lt;code&gt;float&lt;/code&gt;, &lt;code&gt;double&lt;/code&gt;, and &lt;code&gt;long double&lt;/code&gt;, &lt;code&gt;std::atomic&lt;/code&gt; provides additional atomic operations appropriate to floating-point types such as &lt;a href=&quot;atomic/fetch_add&quot;&gt;&lt;code&gt;fetch_add&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;atomic/fetch_sub&quot;&gt;&lt;code&gt;fetch_sub&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">При создании экземпляра с одним из типов с плавающей точкой &lt;code&gt;float&lt;/code&gt; , &lt;code&gt;double&lt;/code&gt; и &lt;code&gt;long double&lt;/code&gt; , &lt;code&gt;std::atomic&lt;/code&gt; предоставляет дополнительные атомарные операции, соответствующие типам с плавающей точкой, таким как &lt;a href=&quot;atomic/fetch_add&quot;&gt; &lt;code&gt;fetch_add&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;atomic/fetch_sub&quot;&gt; &lt;code&gt;fetch_sub&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="552f6dfa495a4acb2aa66f36a0ba5bf21b95fae5" translate="yes" xml:space="preserve">
          <source>When instantiated with one of the floating-point types &lt;code&gt;float&lt;/code&gt;, &lt;code&gt;double&lt;/code&gt;, and &lt;code&gt;long double&lt;/code&gt;, &lt;code&gt;std::atomic_ref&lt;/code&gt; provides additional atomic operations appropriate to floating-point types such as &lt;a href=&quot;atomic_ref/fetch_add&quot;&gt;&lt;code&gt;fetch_add&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;atomic_ref/fetch_sub&quot;&gt;&lt;code&gt;fetch_sub&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">При создании экземпляра с одним из типов с плавающей точкой &lt;code&gt;float&lt;/code&gt; , &lt;code&gt;double&lt;/code&gt; и &lt;code&gt;long double&lt;/code&gt; , &lt;code&gt;std::atomic_ref&lt;/code&gt; предоставляет дополнительные атомарные операции, соответствующие типам с плавающей точкой, таким как &lt;a href=&quot;atomic_ref/fetch_add&quot;&gt; &lt;code&gt;fetch_add&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;atomic_ref/fetch_sub&quot;&gt; &lt;code&gt;fetch_sub&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5bac602845c57306b8db9e963ef0dfc1cad72696" translate="yes" xml:space="preserve">
          <source>When instantiated with one of the following integral types, &lt;code&gt;std::atomic&lt;/code&gt; provides additional atomic operations appropriate to integral types such as &lt;a href=&quot;atomic/fetch_add&quot;&gt;&lt;code&gt;fetch_add&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;atomic/fetch_sub&quot;&gt;&lt;code&gt;fetch_sub&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;atomic/fetch_and&quot;&gt;&lt;code&gt;fetch_and&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;atomic/fetch_or&quot;&gt;&lt;code&gt;fetch_or&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;atomic/fetch_xor&quot;&gt;&lt;code&gt;fetch_xor&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">Когда создается экземпляр с одним из следующих целочисленных типов, &lt;code&gt;std::atomic&lt;/code&gt; предоставляет дополнительные атомарные операции, соответствующие целочисленным типам, таким как &lt;a href=&quot;atomic/fetch_add&quot;&gt; &lt;code&gt;fetch_add&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;atomic/fetch_sub&quot;&gt; &lt;code&gt;fetch_sub&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;atomic/fetch_and&quot;&gt; &lt;code&gt;fetch_and&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;atomic/fetch_or&quot;&gt; &lt;code&gt;fetch_or&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;atomic/fetch_xor&quot;&gt; &lt;code&gt;fetch_xor&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="baa8ebba32798819cb5a6086f1e8129674336cd6" translate="yes" xml:space="preserve">
          <source>When instantiated with one of the following integral types, &lt;code&gt;std::atomic_ref&lt;/code&gt; provides additional atomic operations appropriate to integral types such as &lt;a href=&quot;atomic_ref/fetch_add&quot;&gt;&lt;code&gt;fetch_add&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;atomic_ref/fetch_sub&quot;&gt;&lt;code&gt;fetch_sub&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;atomic_ref/fetch_and&quot;&gt;&lt;code&gt;fetch_and&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;atomic_ref/fetch_or&quot;&gt;&lt;code&gt;fetch_or&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;atomic_ref/fetch_xor&quot;&gt;&lt;code&gt;fetch_xor&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">При создании экземпляра с одним из следующих целочисленных типов &lt;code&gt;std::atomic_ref&lt;/code&gt; предоставляет дополнительные атомарные операции, соответствующие целочисленным типам, таким как &lt;a href=&quot;atomic_ref/fetch_add&quot;&gt; &lt;code&gt;fetch_add&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;atomic_ref/fetch_sub&quot;&gt; &lt;code&gt;fetch_sub&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;atomic_ref/fetch_and&quot;&gt; &lt;code&gt;fetch_and&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;atomic_ref/fetch_or&quot;&gt; &lt;code&gt;fetch_or&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;atomic_ref/fetch_xor&quot;&gt; &lt;code&gt;fetch_xor&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="503d40b06333e935efd323a580b4acbb78349e5a" translate="yes" xml:space="preserve">
          <source>When it is needed to interpret the bytes of an object as a value of a different type, &lt;code&gt;&lt;a href=&quot;../string/byte/memcpy&quot;&gt;std::memcpy&lt;/a&gt;&lt;/code&gt;or &lt;a href=&quot;../numeric/bit_cast&quot;&gt;&lt;code&gt;std::bit_cast&lt;/code&gt;&lt;/a&gt;(since C++20)can be used:</source>
          <target state="translated">Когда необходимо интерпретировать байты объекта как значение другого типа, можно использовать &lt;code&gt;&lt;a href=&quot;../string/byte/memcpy&quot;&gt;std::memcpy&lt;/a&gt;&lt;/code&gt; или &lt;a href=&quot;../numeric/bit_cast&quot;&gt; &lt;code&gt;std::bit_cast&lt;/code&gt; &lt;/a&gt; (начиная с C ++ 20):</target>
        </trans-unit>
        <trans-unit id="5281af908beb7c5eb475c7aeb21afb60dcc9c864" translate="yes" xml:space="preserve">
          <source>When language specifications nest, the innermost specification is the one that is in effect.</source>
          <target state="translated">Когда языковые спецификации гнездятся,внутренней спецификацией является та,которая действует.</target>
        </trans-unit>
        <trans-unit id="016122add2c9877f6072526697f450c52a1f6394" translate="yes" xml:space="preserve">
          <source>When making an explicit call to the conversion function, the type-id is greedy: it is the longest possible sequence of tokens that is a valid type id (including attributes, if any):</source>
          <target state="translated">При явном вызове функции преобразования,идентификатор типа является жадным:это самая длинная из возможных последовательностей токенов,которая является действительным идентификатором типа (включая атрибуты,если таковые имеются):</target>
        </trans-unit>
        <trans-unit id="c7b5147658508bc213c62aa761a47793df025adb" translate="yes" xml:space="preserve">
          <source>When moving overlapping ranges, &lt;code&gt;std::move&lt;/code&gt; is appropriate when moving to the left (beginning of the destination range is outside the source range) while &lt;code&gt;std::move_backward&lt;/code&gt; is appropriate when moving to the right (end of the destination range is outside the source range).</source>
          <target state="translated">При перемещении перекрывающихся диапазонов &lt;code&gt;std::move&lt;/code&gt; подходит для перемещения влево (начало диапазона назначения находится за пределами исходного диапазона), тогда как &lt;code&gt;std::move_backward&lt;/code&gt; подходит для перемещения вправо (конец диапазона назначения находится вне источника ассортимент).</target>
        </trans-unit>
        <trans-unit id="bcc9e1f7b6bbebc1441b5e338721e2a64a3a6fc2" translate="yes" xml:space="preserve">
          <source>When no more matches are found, copies the remaining non-matched characters to &lt;code&gt;out&lt;/code&gt; as if by &lt;code&gt;out = &lt;a href=&quot;../algorithm/copy&quot;&gt;std::copy&lt;/a&gt;(last_m.suffix().first, last_m.suffix().second, out)&lt;/code&gt; where &lt;code&gt;last_m&lt;/code&gt; is a copy of the last match found.</source>
          <target state="translated">Если совпадений больше не найдено, копирует оставшиеся &lt;code&gt;out = &lt;a href=&quot;../algorithm/copy&quot;&gt;std::copy&lt;/a&gt;(last_m.suffix().first, last_m.suffix().second, out)&lt;/code&gt; состояние &lt;code&gt;out&lt;/code&gt; как если бы out = &lt;a href=&quot;../algorithm/copy&quot;&gt;std :: copy&lt;/a&gt; (last_m.suffix (). First, last_m.suffix (). Second, out), где &lt;code&gt;last_m&lt;/code&gt; является копией последний найденный матч.</target>
        </trans-unit>
        <trans-unit id="a989818254cf8030ca8ff78fd514d37b03472368" translate="yes" xml:space="preserve">
          <source>When one of them is found by &lt;a href=&quot;../../language/unqualified_lookup&quot;&gt;normal unqualified lookup&lt;/a&gt; for the name to the left of the function-call operator, it inhibits &lt;a href=&quot;../../language/adl&quot;&gt;argument-dependent lookup&lt;/a&gt;.</source>
          <target state="translated">Когда один из них найден &lt;a href=&quot;../../language/unqualified_lookup&quot;&gt;обычным безусловным поиском&lt;/a&gt; имени слева от оператора вызова функции, он запрещает &lt;a href=&quot;../../language/adl&quot;&gt;поиск, зависящий от аргумента&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1514e0d97ec7c21ec7cdc4fc2229658217c2a1d3" translate="yes" xml:space="preserve">
          <source>When one or more lock-free atomic functions run concurrently, at least one of them is guaranteed to complete (all standard library lock-free operations are &lt;a href=&quot;https://en.wikipedia.org/wiki/Non-blocking_algorithm#Lock-freedom&quot;&gt;lock-free&lt;/a&gt; -- it is the job of the implementation to ensure they cannot be live-locked indefinitely by other threads, such as by continuously stealing the cache line).</source>
          <target state="translated">Когда одна или несколько элементарных функций без блокировок выполняются одновременно, гарантированно завершается хотя бы одна из них (все стандартные операции без &lt;a href=&quot;https://en.wikipedia.org/wiki/Non-blocking_algorithm#Lock-freedom&quot;&gt;блокировок&lt;/a&gt; библиотеки не блокируются - задача реализации состоит в том, чтобы гарантировать, что они не могут быть заблокированы в режиме реального времени). неопределенно другими потоками, например, постоянно крадя строку кэша).</target>
        </trans-unit>
        <trans-unit id="c525266500bfb2286ded86306e069bde3c22c32c" translate="yes" xml:space="preserve">
          <source>When one statement is expected, but multiple statements need to be executed in sequence (for example, in an &lt;a href=&quot;if&quot;&gt;if&lt;/a&gt; statement or a loop), a compound statement may be used:</source>
          <target state="translated">Когда ожидается один оператор, но несколько операторов должны выполняться последовательно (например, в операторе &lt;a href=&quot;if&quot;&gt;if&lt;/a&gt; или цикле), может использоваться составной оператор:</target>
        </trans-unit>
        <trans-unit id="99ceddfac8288288bcf4a468dfcdde568e2b94f6" translate="yes" xml:space="preserve">
          <source>When only one thread that is not blocked in a standard library function executes an &lt;a href=&quot;../atomic&quot;&gt;atomic function&lt;/a&gt; that is lock-free, that execution is guaranteed to complete (all standard library lock-free operations are &lt;a href=&quot;https://en.wikipedia.org/wiki/Non-blocking_algorithm#Obstruction-freedom&quot;&gt;obstruction-free&lt;/a&gt;).</source>
          <target state="translated">Когда только один поток, который не заблокирован в стандартной функции библиотеки, выполняет &lt;a href=&quot;../atomic&quot;&gt;элементарную функцию без&lt;/a&gt; блокировки, это выполнение гарантированно завершится (все операции без блокировки стандартной библиотеки не &lt;a href=&quot;https://en.wikipedia.org/wiki/Non-blocking_algorithm#Obstruction-freedom&quot;&gt;препятствуют выполнению&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="be17634a4507a825d9841a9ec6ecaee80238b41e" translate="yes" xml:space="preserve">
          <source>When parsing an expression, an operator which is listed on some row of the table above with a precedence will be bound tighter (as if by parentheses) to its arguments than any operator that is listed on a row further below it with a lower precedence. For example, the expressions &lt;code&gt;&lt;a href=&quot;../io/cout&quot;&gt;std::cout&lt;/a&gt; &amp;lt;&amp;lt; a &amp;amp; b&lt;/code&gt; and &lt;code&gt;*p++&lt;/code&gt; are parsed as &lt;code&gt;(&lt;a href=&quot;../io/cout&quot;&gt;std::cout&lt;/a&gt; &amp;lt;&amp;lt; a) &amp;amp; b&lt;/code&gt; and &lt;code&gt;*(p++)&lt;/code&gt;, and not as &lt;code&gt;&lt;a href=&quot;../io/cout&quot;&gt;std::cout&lt;/a&gt; &amp;lt;&amp;lt; (a &amp;amp; b)&lt;/code&gt; or &lt;code&gt;(*p)++&lt;/code&gt;.</source>
          <target state="translated">При синтаксическом анализе выражения оператор, который указан в некоторой строке таблицы выше с приоритетом, будет более тесно связан (как в скобках) со своими аргументами, чем любой оператор, который указан в строке ниже, с более низким приоритетом. Например, выражения &lt;code&gt;&lt;a href=&quot;../io/cout&quot;&gt;std::cout&lt;/a&gt; &amp;lt;&amp;lt; a &amp;amp; b&lt;/code&gt; и &lt;code&gt;*p++&lt;/code&gt; анализируются как &lt;code&gt;(&lt;a href=&quot;../io/cout&quot;&gt;std::cout&lt;/a&gt; &amp;lt;&amp;lt; a) &amp;amp; b&lt;/code&gt; и &lt;code&gt;*(p++)&lt;/code&gt; , а не как &lt;code&gt;&lt;a href=&quot;../io/cout&quot;&gt;std::cout&lt;/a&gt; &amp;lt;&amp;lt; (a &amp;amp; b)&lt;/code&gt; или &lt;code&gt;(*p)++&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f8b48f697df0e524fccfbe77ccb0c6aefdae765c" translate="yes" xml:space="preserve">
          <source>When parsing an incomplete floating-point value that ends in the exponent with no digits, such as parsing &lt;code&gt;&quot;100er&quot;&lt;/code&gt; with the conversion specifier &lt;code&gt;%f&lt;/code&gt;, the sequence &lt;code&gt;&quot;100e&quot;&lt;/code&gt; (the longest prefix of a possibly valid floating-point number) is consumed, resulting in a matching error (the consumed sequence cannot be converted to a floating-point number), with &lt;code&gt;&quot;r&quot;&lt;/code&gt; remaining. Some existing implementations do not follow this rule and roll back to consume only &lt;code&gt;&quot;100&quot;&lt;/code&gt;, leaving &lt;code&gt;&quot;er&quot;&lt;/code&gt;, e.g. &lt;a href=&quot;https://sourceware.org/bugzilla/show_bug.cgi?id=1765&quot;&gt;glibc bug 1765&lt;/a&gt;.</source>
          <target state="translated">При синтаксическом анализе неполного значения с плавающей запятой, которое заканчивается в показателе степени без цифр, например при разборе &lt;code&gt;&quot;100er&quot;&lt;/code&gt; с указателем преобразования &lt;code&gt;%f&lt;/code&gt; , используется последовательность &lt;code&gt;&quot;100e&quot;&lt;/code&gt; (самый длинный префикс из допустимого допустимого числа с плавающей запятой) , что приводит к ошибке сопоставления (использованная последовательность не может быть преобразована в число с плавающей запятой) с оставшимся &lt;code&gt;&quot;r&quot;&lt;/code&gt; . Некоторые существующие реализации не следуют этому правилу и откатываются, чтобы использовать только &lt;code&gt;&quot;100&quot;&lt;/code&gt; , оставляя &lt;code&gt;&quot;er&quot;&lt;/code&gt; , например, &lt;a href=&quot;https://sourceware.org/bugzilla/show_bug.cgi?id=1765&quot;&gt;glibc bug 1765&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f862fd02527b95bbe0a34ac38eb69a8e6f210d9f" translate="yes" xml:space="preserve">
          <source>When performing N:M conversions, this function may return &lt;code&gt;&lt;a href=&quot;../codecvt_base&quot;&gt;std::codecvt_base::partial&lt;/a&gt;&lt;/code&gt; after consuming all source characters (&lt;code&gt;from_next == from_end&lt;/code&gt;). This means that another internal character is needed to complete the conversion (e.g. when converting UTF-16 to UTF-8, if the last character in the source buffer is a high surrogate).</source>
          <target state="translated">При выполнении преобразований N: M эта функция может возвращать &lt;code&gt;&lt;a href=&quot;../codecvt_base&quot;&gt;std::codecvt_base::partial&lt;/a&gt;&lt;/code&gt; после использования всех исходных символов ( &lt;code&gt;from_next == from_end&lt;/code&gt; ). Это означает, что для завершения преобразования необходим другой внутренний символ (например, при преобразовании UTF-16 в UTF-8, если последний символ в исходном буфере является старшим суррогатом).</target>
        </trans-unit>
        <trans-unit id="73238300a6abe634b092cd3c78bfa124e710c17c" translate="yes" xml:space="preserve">
          <source>When performing matches, all marked sub-expressions &lt;code&gt;(expr)&lt;/code&gt; are treated as non-marking sub-expressions &lt;code&gt;(?:expr)&lt;/code&gt;. No matches are stored in the supplied &lt;code&gt;&lt;a href=&quot;../regex_match&quot;&gt;std::regex_match&lt;/a&gt;&lt;/code&gt; structure and &lt;code&gt;mark_count()&lt;/code&gt; is zero</source>
          <target state="translated">При выполнении совпадений все отмеченные &lt;code&gt;(expr)&lt;/code&gt; обрабатываются как &lt;code&gt;(?:expr)&lt;/code&gt; . В предоставленной структуре &lt;code&gt;&lt;a href=&quot;../regex_match&quot;&gt;std::regex_match&lt;/a&gt;&lt;/code&gt; совпадения не сохраняются, а &lt;code&gt;mark_count()&lt;/code&gt; - ноль</target>
        </trans-unit>
        <trans-unit id="c20cd38801efcb855e60aac217866665e1148ddd" translate="yes" xml:space="preserve">
          <source>When performing matches, all marked sub-expressions &lt;code&gt;(expr)&lt;/code&gt; are treated as non-marking sub-expressions &lt;code&gt;(?:expr)&lt;/code&gt;. No matches are stored in the supplied &lt;code&gt;&lt;a href=&quot;regex_match&quot;&gt;std::regex_match&lt;/a&gt;&lt;/code&gt; structure and &lt;code&gt;mark_count()&lt;/code&gt; is zero</source>
          <target state="translated">При выполнении совпадений все отмеченные &lt;code&gt;(expr)&lt;/code&gt; обрабатываются как &lt;code&gt;(?:expr)&lt;/code&gt; . В предоставленной структуре &lt;code&gt;&lt;a href=&quot;regex_match&quot;&gt;std::regex_match&lt;/a&gt;&lt;/code&gt; совпадения не сохраняются, а &lt;code&gt;mark_count()&lt;/code&gt; - ноль</target>
        </trans-unit>
        <trans-unit id="f4f7d6dbe3d540b5d3f8d4a7ca45e962b95c0edb" translate="yes" xml:space="preserve">
          <source>When placeholder types (either &lt;code&gt;auto&lt;/code&gt; or &lt;a href=&quot;../concepts&quot;&gt;Concept auto&lt;/a&gt;) appear in the parameter list of a function declaration or of a function template declaration, the declaration declares a function template, and one invented template parameter for each placeholder is appended to the template parameter list.</source>
          <target state="translated">Когда типы заполнителей (либо &lt;code&gt;auto&lt;/code&gt; , либо &lt;a href=&quot;../concepts&quot;&gt;Concept auto&lt;/a&gt; ) появляются в списке параметров объявления функции или объявления шаблона функции, объявление объявляет шаблон функции, и один изобретенный параметр шаблона для каждого заполнителя добавляется в список параметров шаблона.</target>
        </trans-unit>
        <trans-unit id="641c7fd3577d0edc6efac99f2f76379fc6931592" translate="yes" xml:space="preserve">
          <source>When reading characters, &lt;code&gt;std::istream_iterator&lt;/code&gt; skips whitespace by default (unless disabled with &lt;code&gt;&lt;a href=&quot;../io/manip/skipws&quot;&gt;std::noskipws&lt;/a&gt;&lt;/code&gt; or equivalent), while &lt;code&gt;&lt;a href=&quot;istreambuf_iterator&quot;&gt;std::istreambuf_iterator&lt;/a&gt;&lt;/code&gt; does not. In addition, &lt;code&gt;&lt;a href=&quot;istreambuf_iterator&quot;&gt;std::istreambuf_iterator&lt;/a&gt;&lt;/code&gt; is more efficient, since it avoids the overhead of constructing and destructing the sentry object once per character.</source>
          <target state="translated">При чтении символов &lt;code&gt;std::istream_iterator&lt;/code&gt; по умолчанию пропускает пробел (если только он не отключен с помощью &lt;code&gt;&lt;a href=&quot;../io/manip/skipws&quot;&gt;std::noskipws&lt;/a&gt;&lt;/code&gt; или эквивалентного), тогда как &lt;code&gt;&lt;a href=&quot;istreambuf_iterator&quot;&gt;std::istreambuf_iterator&lt;/a&gt;&lt;/code&gt; этого не делает. Кроме того, &lt;code&gt;&lt;a href=&quot;istreambuf_iterator&quot;&gt;std::istreambuf_iterator&lt;/a&gt;&lt;/code&gt; более эффективен, поскольку позволяет избежать накладных расходов на создание и уничтожение сторожевого объекта один раз за символ.</target>
        </trans-unit>
        <trans-unit id="1ab1d2134a41c9628e2098e71305ab92b1cd2216" translate="yes" xml:space="preserve">
          <source>When rethrowing exceptions, the second form must be used to avoid object slicing in the (typical) case where exception objects use inheritance:</source>
          <target state="translated">При перебрасывании исключений необходимо использовать вторую форму,чтобы избежать нарезания объектов в (типичном)случае,когда объекты исключений используют наследование:</target>
        </trans-unit>
        <trans-unit id="f9fb914caea510cf6dfabbb484a007b28ab4e8a3" translate="yes" xml:space="preserve">
          <source>When signal handler is set to a function and a signal occurs, it is implementation defined whether &lt;code&gt;std::signal(sig, &lt;a href=&quot;sig_strategies&quot;&gt;SIG_DFL&lt;/a&gt;)&lt;/code&gt; will be executed immediately before the start of signal handler. Also, the implementation can prevent some implementation-defined set of signals from occurring while the signal handler runs.</source>
          <target state="translated">Когда обработчик сигнала установлен на функцию, и сигнал возникает, это определяется реализацией, будет ли &lt;code&gt;std::signal(sig, &lt;a href=&quot;sig_strategies&quot;&gt;SIG_DFL&lt;/a&gt;)&lt;/code&gt; выполняться непосредственно перед запуском обработчика сигнала. Кроме того, реализация может предотвратить возникновение некоторого определенного реализацией набора сигналов во время работы обработчика сигналов.</target>
        </trans-unit>
        <trans-unit id="a82c7324d6d1f526ac5299ac166aafff69e4a350" translate="yes" xml:space="preserve">
          <source>When signed integer arithmetic operation overflows (the result does not fit in the result type), the behavior is undefined: it may wrap around according to the rules of the representation (typically 2's complement), it may trap on some platforms or due to compiler options (e.g. &lt;code&gt;-ftrapv&lt;/code&gt; in GCC and Clang), or may be completely &lt;a href=&quot;http://blog.llvm.org/2011/05/what-every-c-programmer-should-know_14.html&quot;&gt;optimized out by the compiler&lt;/a&gt;.</source>
          <target state="translated">Когда переполняется целочисленная арифметическая операция со знаком (результат не помещается в тип результата), поведение не определено: оно может переноситься в соответствии с правилами представления (как правило, с дополнением 2), оно может перехватываться на некоторых платформах или из-за компилятора параметры (например, &lt;code&gt;-ftrapv&lt;/code&gt; в GCC и Clang) или могут быть полностью &lt;a href=&quot;http://blog.llvm.org/2011/05/what-every-c-programmer-should-know_14.html&quot;&gt;оптимизированы компилятором&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9deeffc3f0edffbc9e7bf40fc167f8af90637021" translate="yes" xml:space="preserve">
          <source>When some &lt;a href=&quot;../algorithm/ranges&quot;&gt;constrain algorithms&lt;/a&gt; that usually return an iterator or a subrange of a &lt;a href=&quot;range&quot;&gt;&lt;code&gt;Range&lt;/code&gt;&lt;/a&gt; take a particular rvalue &lt;code&gt;Range&lt;/code&gt; argument that does not models exposition-only concept &lt;a href=&quot;range&quot;&gt;&lt;code&gt;__ForwardingRange&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;dangling&lt;/code&gt; will be returned instead to avoid returning potentially dangling results.</source>
          <target state="translated">Когда некоторые &lt;a href=&quot;../algorithm/ranges&quot;&gt;алгоритмы Constrain&lt;/a&gt; , которые обычно возвращают итератор или поддиапазон в &lt;a href=&quot;range&quot;&gt; &lt;code&gt;Range&lt;/code&gt; &lt;/a&gt; взять конкретный RValue &lt;code&gt;Range&lt;/code&gt; аргумент , который не модели экспозиции только концепт &lt;a href=&quot;range&quot;&gt; &lt;code&gt;__ForwardingRange&lt;/code&gt; &lt;/a&gt; , &lt;code&gt;dangling&lt;/code&gt; будет возвращен вместо того, чтобы избежать возвращения потенциально повисшие результатов.</target>
        </trans-unit>
        <trans-unit id="8b1e13bc5e72c1d99187d326eff8cc95c6a2ce2a" translate="yes" xml:space="preserve">
          <source>When specializing a function template, its template arguments can be omitted if &lt;a href=&quot;template_argument_deduction&quot;&gt;template argument deduction&lt;/a&gt; can provide them from the function arguments:</source>
          <target state="translated">При специализации шаблона функции его аргументы шаблона могут быть опущены, если &lt;a href=&quot;template_argument_deduction&quot;&gt;вычет аргументов шаблона&lt;/a&gt; может предоставить их из аргументов функции:</target>
        </trans-unit>
        <trans-unit id="ca2cbab4c43c7973149386ddec137d524c3e9fe8" translate="yes" xml:space="preserve">
          <source>When string literal concatenation takes place in &lt;a href=&quot;translation_phases&quot;&gt;translation phase 6&lt;/a&gt;, user-defined string literals are concatenated as well, and their ud-suffixes are ignored for the purpose of concatenation, except that only one suffix may appear on all concatenated literals:</source>
          <target state="translated">Когда конкатенация строковых литералов происходит на &lt;a href=&quot;translation_phases&quot;&gt;этапе 6 перевода&lt;/a&gt; , определяемые пользователем строковые литералы также объединяются, и их суффиксы ud игнорируются для целей конкатенации, за исключением того, что только один суффикс может появляться во всех конкатенированных литералах:</target>
        </trans-unit>
        <trans-unit id="1799979c98bbbebaef89ed6f1828299ab2b6a5e5" translate="yes" xml:space="preserve">
          <source>When such member function is declared in class X, it performs conversion from X to conversion-type-id:</source>
          <target state="translated">Когда такая функция-член объявлена в классе X,она выполняет преобразование из X в преобразование-тип-ид:</target>
        </trans-unit>
        <trans-unit id="1b9fe1265be0c139fe6cde0ba421b142a03ada23" translate="yes" xml:space="preserve">
          <source>When template arguments are provided, or, for &lt;a href=&quot;function_template#Template_argument_deduction&quot;&gt;function&lt;/a&gt; and &lt;a href=&quot;deduction_guide&quot;&gt;class&lt;/a&gt;(since C++17) templates only, deduced, they are substituted for the template parameters to obtain a</source>
          <target state="translated">Если предоставляются аргументы шаблона или только для шаблонов &lt;a href=&quot;function_template#Template_argument_deduction&quot;&gt;функций&lt;/a&gt; и &lt;a href=&quot;deduction_guide&quot;&gt;классов&lt;/a&gt; (начиная с C ++ 17), они заменяются параметрами шаблона для получения</target>
        </trans-unit>
        <trans-unit id="55f3e3f1e06a97818ce0ffb33865599309fb29ae" translate="yes" xml:space="preserve">
          <source>When the</source>
          <target state="translated">Когда</target>
        </trans-unit>
        <trans-unit id="aa5703929047ae870cd9bedc4f9eebb911b80493" translate="yes" xml:space="preserve">
          <source>When the argument is a class template, only the primary template is considered when matching the parameter. The partial specializations, if any, are only considered when a specialization based on this template template parameter happens to be instantiated.</source>
          <target state="translated">Когда аргументом является шаблон класса,при совпадении с параметром учитывается только первичный шаблон.Частичные специализации,если таковые имеются,учитываются только в том случае,если специализация,основанная на данном параметре шаблона,является инстанцированной.</target>
        </trans-unit>
        <trans-unit id="657c97ad1dccca00440cdc8eb7bd687219c46fbe" translate="yes" xml:space="preserve">
          <source>When the asynchronous operation is ready to send a result to the creator, it can do so by modifying</source>
          <target state="translated">Когда асинхронная операция готова отправить результат создателю,он может сделать это,модифицируя</target>
        </trans-unit>
        <trans-unit id="b3e1fc309740231aa065058d4a26e16a2e51f547" translate="yes" xml:space="preserve">
          <source>When the compiler encounters a user-defined literal with ud-suffix&lt;code&gt;X&lt;/code&gt;, it performs &lt;a href=&quot;lookup#Unqualified_name_lookup&quot;&gt;unqualified name lookup&lt;/a&gt;, looking for a function with the name &lt;code&gt;operator &quot;&quot; X&lt;/code&gt;. If the lookup does not find a declaration, the program is ill-formed. Otherwise,</source>
          <target state="translated">Когда компилятор встречает определенный пользователем буквальным с уд-суффикс &lt;code&gt;X&lt;/code&gt; , он выполняет &lt;a href=&quot;lookup#Unqualified_name_lookup&quot;&gt;неквалифицированного поиск имени&lt;/a&gt; , ищет функцию с именем &lt;code&gt;operator &quot;&quot; X&lt;/code&gt; . Если при поиске не найдено объявление, программа некорректна. В противном случае,</target>
        </trans-unit>
        <trans-unit id="a6e3ba42f8de770e69687876d93e30231038db0e" translate="yes" xml:space="preserve">
          <source>When the compiler encounters an unknown name in a program, it associates it with the declaration that introduced the name by means of &lt;a href=&quot;lookup&quot;&gt;name lookup&lt;/a&gt;, except for the &lt;a href=&quot;dependent_name&quot;&gt;dependent names&lt;/a&gt; in template declarations and definitions (for those names, the compiler determines whether they name a type, a template, or some other entity, which may require &lt;a href=&quot;dependent_name&quot;&gt;explicit disambiguation&lt;/a&gt;).</source>
          <target state="translated">Когда компилятор встречает неизвестное имя в программе, он связывает его с объявлением, которое ввело имя посредством &lt;a href=&quot;lookup&quot;&gt;поиска имени&lt;/a&gt; , за исключением &lt;a href=&quot;dependent_name&quot;&gt;зависимых имен&lt;/a&gt; в объявлениях и определениях шаблонов (для этих имен компилятор определяет, называют ли они тип шаблон или другой объект, который может потребовать &lt;a href=&quot;dependent_name&quot;&gt;явного устранения неоднозначности&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="3ffc67b2c989f365607047bd77316e5ecdadcda9" translate="yes" xml:space="preserve">
          <source>When the condition variable is notified, a timeout expires, or a &lt;a href=&quot;https://en.wikipedia.org/wiki/Spurious_wakeup&quot;&gt;spurious wakeup&lt;/a&gt; occurs, the thread is awakened, and the mutex is atomically reacquired. The thread should then check the condition and resume waiting if the wake up was spurious.</source>
          <target state="translated">Когда переменная условия уведомляется, истекает тайм-аут или происходит &lt;a href=&quot;https://en.wikipedia.org/wiki/Spurious_wakeup&quot;&gt;ложное пробуждение&lt;/a&gt; , поток пробуждается, и мьютекс атомарно восстанавливается. Затем поток должен проверить состояние и возобновить ожидание, если пробуждение было ложным.</target>
        </trans-unit>
        <trans-unit id="16dd5023449c37e3ee571367f3544e6dbf21123f" translate="yes" xml:space="preserve">
          <source>When the coroutine state is destroyed either because it terminated via co_return or uncaught exception, or because it was destroyed via its handle, it does the following:</source>
          <target state="translated">Когда состояние корутины разрушается либо из-за того,что оно завершилось с помощью исключения co_return,либо из-за того,что оно было уничтожено с помощью его рукоятки,он делает следующее:</target>
        </trans-unit>
        <trans-unit id="d296094acb938c3d5a36e0feef5bea491289a47a" translate="yes" xml:space="preserve">
          <source>When the default allocator is used, this results in the key being copy constructed from &lt;code&gt;key&lt;/code&gt; and the mapped value being &lt;a href=&quot;../../language/value_initialization&quot;&gt;value-initialized&lt;/a&gt;.</source>
          <target state="translated">Когда используется распределитель по умолчанию, это приводит к тому, что ключ копируется из &lt;code&gt;key&lt;/code&gt; а сопоставленное &lt;a href=&quot;../../language/value_initialization&quot;&gt;значение инициализируется значением&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d9fddcbdad59ebcc2389e29ab9d251d255ff093b" translate="yes" xml:space="preserve">
          <source>When the default allocator is used, this results in the key being move constructed from &lt;code&gt;key&lt;/code&gt; and the mapped value being &lt;a href=&quot;../../language/value_initialization&quot;&gt;value-initialized&lt;/a&gt;.</source>
          <target state="translated">Когда используется распределитель по умолчанию, это приводит к тому, что ключ перемещается из &lt;code&gt;key&lt;/code&gt; а отображаемое &lt;a href=&quot;../../language/value_initialization&quot;&gt;значение инициализируется значением&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="31f633e1dfad19457b495484c1fbe0072bbb264f" translate="yes" xml:space="preserve">
          <source>When the default semantics are not suitable, such as when the members must be compared out of order, or must use a comparison that's different from their natural comparison, then the programmer can write &lt;code&gt;operator&amp;lt;=&amp;gt;&lt;/code&gt; and let the compiler generate the appropriate relational operators. The kind of relational operators generated depends on the return type of the user-defined &lt;code&gt;operator&amp;lt;=&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">Когда семантика по умолчанию не подходит, например, когда элементы должны сравниваться не по порядку, или должны использовать сравнение, отличное от их естественного сравнения, тогда программист может написать &lt;code&gt;operator&amp;lt;=&amp;gt;&lt;/code&gt; и позволить компилятору генерировать соответствующие реляционные операторы , Тип генерируемых реляционных операторов зависит от типа возвращаемого пользователем пользовательского &lt;code&gt;operator&amp;lt;=&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5f0cf9abe0b614f53329302ad0d6b53be9c5214c" translate="yes" xml:space="preserve">
          <source>When the element type of an array is another array, it is said that the array is multidimensional:</source>
          <target state="translated">Когда типом элемента массива является другой массив,говорят,что массив многомерный:</target>
        </trans-unit>
        <trans-unit id="8371d69254feffac85782c93e2437f4715cd1cb6" translate="yes" xml:space="preserve">
          <source>When the initializer is a prvalue, the move constructor call is often optimized out(until C++17)never made(since C++17), see &lt;a href=&quot;copy_elision&quot;&gt;copy elision&lt;/a&gt;.</source>
          <target state="translated">Когда инициализатор является prvalue, вызов конструктора перемещения часто оптимизируется (до C ++ 17) и не выполняется (начиная с C ++ 17), см. &lt;a href=&quot;copy_elision&quot;&gt;Elision copy&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="10770c6e57727da2d2faacfcf5bbaf211dbc1a9b" translate="yes" xml:space="preserve">
          <source>When the left operand has reference type, the assignment operator modifies the referred-to object.</source>
          <target state="translated">Если левый операнд имеет тип ссылки,оператор присваивания изменяет объект,на который делается ссылка.</target>
        </trans-unit>
        <trans-unit id="0d0dbe17faf8b2da57c150cba1c216b9daf8702b" translate="yes" xml:space="preserve">
          <source>When the member type &lt;code&gt;pointer&lt;/code&gt; is not a raw pointer type, it is commonly referred to as a &quot;fancy pointer&quot;. Such pointers were introduced to support segmented memory architectures and are used today to access objects allocated in address spaces that differ from the homogeneous virtual address space that is accessed by raw pointers. An example of a fancy pointer is the mapping address-independent pointer &lt;a href=&quot;http://www.boost.org/doc/libs/release/doc/html/interprocess/offset_ptr.html&quot;&gt;boost::interprocess::offset_ptr&lt;/a&gt;, which makes it possible to allocate node-based data structures such as &lt;code&gt;&lt;a href=&quot;../container/set&quot;&gt;std::set&lt;/a&gt;&lt;/code&gt; in shared memory and memory mapped files mapped in different addresses in every process. Fancy pointers can be used independently of the allocator that provided them, through the class template &lt;code&gt;&lt;a href=&quot;../memory/pointer_traits&quot;&gt;std::pointer_traits&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Когда &lt;code&gt;pointer&lt;/code&gt; типа члена не является необработанным указателем, его обычно называют &amp;laquo;причудливым указателем&amp;raquo;. Такие указатели были введены для поддержки архитектуры сегментированной памяти и используются сегодня для доступа к объектам, расположенным в адресных пространствах, которые отличаются от однородного виртуального адресного пространства, к которому обращаются необработанные указатели. Примером причудливого указателя является указатель независимого от адреса указателя &lt;a href=&quot;http://www.boost.org/doc/libs/release/doc/html/interprocess/offset_ptr.html&quot;&gt;boost :: interprocess :: offset_ptr&lt;/a&gt; , который позволяет выделять структуры данных на основе узлов, такие как &lt;code&gt;&lt;a href=&quot;../container/set&quot;&gt;std::set&lt;/a&gt;&lt;/code&gt; в разделяемой памяти и отображенные в память файлы, сопоставленные по разным адресам в каждый процесс. Необычные указатели могут использоваться независимо от предоставившего их распределителя через шаблон класса &lt;code&gt;&lt;a href=&quot;../memory/pointer_traits&quot;&gt;std::pointer_traits&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e345263d3c16be0359604e2c7e37e80d322c6999" translate="yes" xml:space="preserve">
          <source>When the name of a non-type template parameter is used in an expression within the body of the class template, it is an unmodifiable &lt;a href=&quot;value_category&quot;&gt;prvalue&lt;/a&gt; unless its type was an lvalue reference type, or unless its type is a class type(since C++20).</source>
          <target state="translated">Когда имя параметра шаблона &lt;a href=&quot;value_category&quot;&gt;нетипичного&lt;/a&gt; типа используется в выражении в теле шаблона класса, это неизменяемое значение типа prvalue, если только его тип не является ссылочным типом lvalue или если его тип не является типом класса (поскольку C ++ 20).</target>
        </trans-unit>
        <trans-unit id="0dd4c2cd3956549ff3cdd1f8a7caf6b32e2cea01" translate="yes" xml:space="preserve">
          <source>When the noexcept-specification of a function template specialization is</source>
          <target state="translated">Когда спецификация шаблона функции,кроме спецификации,является</target>
        </trans-unit>
        <trans-unit id="cc159284033553cbafc104d522a5cf1ae76e1549" translate="yes" xml:space="preserve">
          <source>When the number of variants is zero or one, the invocation of the callable object is implemented in constant time, i.e. it does not depend on &lt;code&gt;sizeof...(Types)&lt;/code&gt;.</source>
          <target state="translated">Когда число вариантов равно нулю или единице, вызов вызываемого объекта осуществляется за постоянное время, то есть он не зависит от &lt;code&gt;sizeof...(Types)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b8b02aaeadad3d163b0d5be165966951d5f6a133" translate="yes" xml:space="preserve">
          <source>When the parameter-list is not empty, an optional comma may precede a &lt;code&gt;...&lt;/code&gt; signifying a variadic function. This provides compatibility with C (which added a requirement for a comma when it adopted function prototypes from C++).</source>
          <target state="translated">Когда список параметров не пустой, необязательная запятая может предшествовать &lt;code&gt;...&lt;/code&gt; , обозначая функцию с переменными числами. Это обеспечивает совместимость с C (который добавил требование к запятой, когда он принял прототипы функций из C ++).</target>
        </trans-unit>
        <trans-unit id="eadbea007ec076285100c5cbd07b8a2dc8928700" translate="yes" xml:space="preserve">
          <source>When the parser encounters the character sequence &lt;code&gt;&amp;lt;::&lt;/code&gt; and the subsequent character is neither &lt;code&gt;:&lt;/code&gt; nor &lt;code&gt;&amp;gt;&lt;/code&gt;, the &lt;code&gt;&amp;lt;&lt;/code&gt; is treated as a preprocessing token by itself and not as the first character of the alternative token &lt;code&gt;&amp;lt;:&lt;/code&gt;. Thus &lt;code&gt;&lt;a href=&quot;../container/vector&quot;&gt;std::vector&lt;/a&gt;&amp;lt;::&lt;a href=&quot;../string/basic_string&quot;&gt;std::string&lt;/a&gt;&amp;gt;&lt;/code&gt; won't be wrongly treated as &lt;code&gt;&lt;a href=&quot;../container/vector&quot;&gt;std::vector&lt;/a&gt;[:&lt;a href=&quot;../string/basic_string&quot;&gt;std::string&lt;/a&gt;&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">Когда парсер встречает последовательность символов &lt;code&gt;&amp;lt;::&lt;/code&gt; и последующий символ не является ни &lt;code&gt;:&lt;/code&gt; ни &lt;code&gt;&amp;gt;&lt;/code&gt; , то &lt;code&gt;&amp;lt;&lt;/code&gt; трактуются как первичная обработка лексем самого по себе , а не в качестве первого символа альтернативных маркеров &lt;code&gt;&amp;lt;:&lt;/code&gt; . Таким образом, &lt;code&gt;&lt;a href=&quot;../container/vector&quot;&gt;std::vector&lt;/a&gt;&amp;lt;::&lt;a href=&quot;../string/basic_string&quot;&gt;std::string&lt;/a&gt;&amp;gt;&lt;/code&gt; не будет ошибочно рассматриваться как &lt;code&gt;&lt;a href=&quot;../container/vector&quot;&gt;std::vector&lt;/a&gt;[:&lt;a href=&quot;../string/basic_string&quot;&gt;std::string&lt;/a&gt;&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8cc2032d32ca7885f140b25a96dcbee6c5397ce4" translate="yes" xml:space="preserve">
          <source>When the postfix increment and decrement appear in an expression, the corresponding user-defined function (&lt;code&gt;operator++&lt;/code&gt; or &lt;code&gt;operator--&lt;/code&gt;) is called with an integer argument &lt;code&gt;0&lt;/code&gt;. Typically, it is implemented as &lt;code&gt;T operator++(int)&lt;/code&gt;, where the argument is ignored. The postfix increment and decrement operator is usually implemented in terms of the prefix version:</source>
          <target state="translated">Когда постфиксный приращение и уменьшение появляются в выражении, соответствующая пользовательская функция ( &lt;code&gt;operator++&lt;/code&gt; или &lt;code&gt;operator--&lt;/code&gt; ) вызывается с целочисленным аргументом &lt;code&gt;0&lt;/code&gt; . Как правило, он реализован как &lt;code&gt;T operator++(int)&lt;/code&gt; , где аргумент игнорируется. Оператор увеличения и уменьшения постфикса обычно реализуется в терминах префиксной версии:</target>
        </trans-unit>
        <trans-unit id="fd043f49a212d5450703bb9a052e4fa639f20396" translate="yes" xml:space="preserve">
          <source>When the regex library needs to match two characters &lt;code&gt;c1&lt;/code&gt; and &lt;code&gt;c2&lt;/code&gt; and the flag &lt;code&gt;&lt;a href=&quot;../syntax_option_type&quot;&gt;std::regex_constants::collate&lt;/a&gt;&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, it executes &lt;code&gt;regex_traits&amp;lt;&amp;gt;::translate(c1) == regex_traits&amp;lt;&amp;gt;::translate(c2)&lt;/code&gt;.</source>
          <target state="translated">Когда библиотека regex должна соответствовать двум символам &lt;code&gt;c1&lt;/code&gt; и &lt;code&gt;c2&lt;/code&gt; и флаг &lt;code&gt;&lt;a href=&quot;../syntax_option_type&quot;&gt;std::regex_constants::collate&lt;/a&gt;&lt;/code&gt; равен &lt;code&gt;true&lt;/code&gt; , она выполняет &lt;code&gt;regex_traits&amp;lt;&amp;gt;::translate(c1) == regex_traits&amp;lt;&amp;gt;::translate(c2)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a73f957522574e9d880fc3def8f3dd16383a3e89" translate="yes" xml:space="preserve">
          <source>When the regex library needs to match two characters &lt;code&gt;c1&lt;/code&gt; and &lt;code&gt;c2&lt;/code&gt; and the flag &lt;code&gt;&lt;a href=&quot;../syntax_option_type&quot;&gt;std::regex_constants::icase&lt;/a&gt;&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, it executes &lt;code&gt;regex_traits&amp;lt;&amp;gt;::translate_nocase(c1) == regex_traits&amp;lt;&amp;gt;::translate_nocase(c2)&lt;/code&gt;.</source>
          <target state="translated">Когда библиотека regex должна соответствовать двум символам &lt;code&gt;c1&lt;/code&gt; и &lt;code&gt;c2&lt;/code&gt; , а флаг &lt;code&gt;&lt;a href=&quot;../syntax_option_type&quot;&gt;std::regex_constants::icase&lt;/a&gt;&lt;/code&gt; равен &lt;code&gt;true&lt;/code&gt; , она выполняет &lt;code&gt;regex_traits&amp;lt;&amp;gt;::translate_nocase(c1) == regex_traits&amp;lt;&amp;gt;::translate_nocase(c2)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="59285875d0142d5e8a1eb450e8a3f9927249ea97" translate="yes" xml:space="preserve">
          <source>When the result of specializing an alias template is a dependent &lt;a href=&quot;templates#template-id&quot;&gt;template-id&lt;/a&gt;, subsequent substitutions apply to that template-id:</source>
          <target state="translated">Когда результатом специализации шаблона псевдонима является зависимый &lt;a href=&quot;templates#template-id&quot;&gt;идентификатор шаблона&lt;/a&gt; , последующие замены применяются к этому идентификатору шаблона:</target>
        </trans-unit>
        <trans-unit id="7e5e471d5aa433ec3a110b9d7e72faf3a90a04a9" translate="yes" xml:space="preserve">
          <source>When the same function template specialization matches more than one overloaded function template (this often results from &lt;a href=&quot;template_argument_deduction&quot;&gt;template argument deduction&lt;/a&gt;),</source>
          <target state="translated">Когда одна и та же специализация шаблона функции соответствует более чем одному перегруженному шаблону функции (это часто является следствием &lt;a href=&quot;template_argument_deduction&quot;&gt;вывода аргумента шаблона&lt;/a&gt; ),</target>
        </trans-unit>
        <trans-unit id="b2ff5fd15b40403883483bc89510d97f14914365" translate="yes" xml:space="preserve">
          <source>When the target type is</source>
          <target state="translated">Когда тип цели</target>
        </trans-unit>
        <trans-unit id="511cb27754af79d62f22a1bf71b871d3d288ebcd" translate="yes" xml:space="preserve">
          <source>When the template-name of a simple-template-id names a constrained non-function template or a constrained template template-parameter, but not a member template that is a member of an unknown specialization, and all template-arguments in the simple-template-id are non-dependent, the associated constraints of the constrained template must be satisfied:</source>
          <target state="translated">Когда шаблон-имя простого шаблона-имеет ограниченный шаблон-параметр нефункции или ограниченный шаблон-параметр шаблона,но не является членом шаблона,который является членом неизвестной специализации,и все шаблоны-аргументы в простом шаблоне-идее не являются зависимыми,то соответствующие ограничения ограниченного шаблона должны быть удовлетворены:</target>
        </trans-unit>
        <trans-unit id="adb827bd0954ef807560ec125638e405788fa858" translate="yes" xml:space="preserve">
          <source>When the value of the argument corresponding to a non-type template parameter P that is declared with a dependent type is deduced from an expression, the template parameters in the type of P are deduced from the type of the value.</source>
          <target state="translated">При выведении из выражения значения аргумента,соответствующего нетипу шаблонного параметра P,объявленного с зависимым типом,из типа значения вычитаются шаблонные параметры типа P.</target>
        </trans-unit>
        <trans-unit id="a1b257f783065293c124a619280ef8e578d72775" translate="yes" xml:space="preserve">
          <source>When this is the case, member functions &lt;code&gt;find&lt;/code&gt;, &lt;code&gt;contains&lt;/code&gt;, &lt;code&gt;count&lt;/code&gt;, and &lt;code&gt;equal_range&lt;/code&gt; accept arguments of types other than &lt;code&gt;Key&lt;/code&gt; and expect that &lt;code&gt;Hash&lt;/code&gt; is callable with values of those types, and that &lt;code&gt;Hash::transparent_key_equal&lt;/code&gt; is a transparent comparison function such as &lt;code&gt;std::equal_to&amp;lt;&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">В этом случае функции-члены &lt;code&gt;find&lt;/code&gt; , &lt;code&gt;contains&lt;/code&gt; , &lt;code&gt;count&lt;/code&gt; и &lt;code&gt;equal_range&lt;/code&gt; принимают аргументы типов, отличных от &lt;code&gt;Key&lt;/code&gt; , и ожидают, что &lt;code&gt;Hash&lt;/code&gt; может вызываться со значениями этих типов, а &lt;code&gt;Hash::transparent_key_equal&lt;/code&gt; является прозрачной функцией сравнения, такой как &lt;code&gt;std::equal_to&amp;lt;&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="22fbcacb8ea8a01e09177002c1cd6a745c7d8006" translate="yes" xml:space="preserve">
          <source>When three-way comparison (such as &lt;code&gt;&lt;a href=&quot;../string/byte/memcmp&quot;&gt;std::memcmp&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../string/basic_string/compare&quot;&gt;std::string::compare&lt;/a&gt;&lt;/code&gt;) is provided, all six relational operators may be expressed through that:</source>
          <target state="translated">Когда предусмотрено трехстороннее сравнение (например, &lt;code&gt;&lt;a href=&quot;../string/byte/memcmp&quot;&gt;std::memcmp&lt;/a&gt;&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;../string/basic_string/compare&quot;&gt;std::string::compare&lt;/a&gt;&lt;/code&gt; ), все шесть реляционных операторов могут быть выражены через это:</target>
        </trans-unit>
        <trans-unit id="1f2f2e919801487fefca6150ecd5b3b80daddef7" translate="yes" xml:space="preserve">
          <source>When three-way comparison is not required (such as when providing a &lt;code&gt;Compare&lt;/code&gt; argument to standard algorithms such as &lt;code&gt;&lt;a href=&quot;../../algorithm/sort&quot;&gt;std::sort&lt;/a&gt;&lt;/code&gt;), &lt;a href=&quot;../locale/operator()&quot;&gt;&lt;code&gt;std::locale::operator()&lt;/code&gt;&lt;/a&gt; may be more appropriate.</source>
          <target state="translated">Когда трехстороннее сравнение не требуется (например, при предоставлении аргумента &lt;code&gt;Compare&lt;/code&gt; для стандартных алгоритмов, таких как &lt;code&gt;&lt;a href=&quot;../../algorithm/sort&quot;&gt;std::sort&lt;/a&gt;&lt;/code&gt; ), &lt;a href=&quot;../locale/operator()&quot;&gt; &lt;code&gt;std::locale::operator()&lt;/code&gt; &lt;/a&gt; может быть более подходящим.</target>
        </trans-unit>
        <trans-unit id="3b2aec7feac4af597a17debffe4c87be12d0ecab" translate="yes" xml:space="preserve">
          <source>When used as a &lt;a href=&quot;template_parameters#Template_arguments&quot;&gt;template argument&lt;/a&gt;, &lt;code&gt;class T&lt;/code&gt; is a type template parameter named &lt;code&gt;T&lt;/code&gt;, not an unnamed non-type parameter whose type &lt;code&gt;T&lt;/code&gt; is introduced by elaborated type specifier.</source>
          <target state="translated">При использовании в качестве &lt;a href=&quot;template_parameters#Template_arguments&quot;&gt;аргумента шаблона&lt;/a&gt; , &lt;code&gt;class T&lt;/code&gt; является параметром шаблона типа с именем &lt;code&gt;T&lt;/code&gt; , не безымянный параметр не-типа, типа &lt;code&gt;T&lt;/code&gt; вводятся уточненным спецификатором типа.</target>
        </trans-unit>
        <trans-unit id="a89f99191dc9016965a45193765f04ce9fd16336" translate="yes" xml:space="preserve">
          <source>When used as a function argument and when &lt;a href=&quot;overload_resolution&quot;&gt;two overloads&lt;/a&gt; of the function are available, one taking rvalue reference parameter and the other taking lvalue reference to const parameter, an rvalue binds to the rvalue reference overload (thus, if both copy and move constructors are available, an rvalue argument invokes the &lt;a href=&quot;move_constructor&quot;&gt;move constructor&lt;/a&gt;, and likewise with copy and move assignment operators).</source>
          <target state="translated">При использовании в качестве аргумента функции и при наличии &lt;a href=&quot;overload_resolution&quot;&gt;двух перегрузок&lt;/a&gt; функции, одна из которых принимает ссылочный параметр rvalue, а другая - ссылку lvalue на параметр const, rvalue связывается с перегруженной ссылкой rvalue (таким образом, если доступны конструкторы копирования и перемещения аргумент rvalue вызывает &lt;a href=&quot;move_constructor&quot;&gt;конструктор перемещения&lt;/a&gt; , а также операторы присваивания копирования и перемещения).</target>
        </trans-unit>
        <trans-unit id="f8ea00edd25f46b83546909c33b9f68661ba3e16" translate="yes" xml:space="preserve">
          <source>When used as an argument in a &lt;code&gt;&lt;a href=&quot;bind&quot;&gt;std::bind&lt;/a&gt;&lt;/code&gt; expression, the placeholder objects are stored in the generated function object, and when that function object is invoked with unbound arguments, each placeholder &lt;code&gt;_N&lt;/code&gt; is replaced by the corresponding Nth unbound argument.</source>
          <target state="translated">При использовании в качестве аргумента в выражении &lt;code&gt;&lt;a href=&quot;bind&quot;&gt;std::bind&lt;/a&gt;&lt;/code&gt; объекты-заполнители сохраняются в сгенерированном функциональном объекте, и когда этот функциональный объект вызывается с несвязанными аргументами, каждый заполнитель &lt;code&gt;_N&lt;/code&gt; заменяется соответствующим N-м свободным аргументом.</target>
        </trans-unit>
        <trans-unit id="4c90e24b8efd2362ba00ffddb7c37e312b7e82c3" translate="yes" xml:space="preserve">
          <source>When used at class scope, variable template declares a static data member template.</source>
          <target state="translated">При использовании в области видимости класса шаблон переменной объявляет шаблон статического члена данных.</target>
        </trans-unit>
        <trans-unit id="d3e7747ab6e5ee83d7abf31291a18569eac0496f" translate="yes" xml:space="preserve">
          <source>When used immediately after whitespace-delimited input, e.g. after &lt;code&gt;int n; &lt;a href=&quot;../../io/cin&quot;&gt;std::cin&lt;/a&gt; &amp;gt;&amp;gt; n;&lt;/code&gt;, &lt;code&gt;getline&lt;/code&gt; consumes the endline character left on the input stream by &lt;a href=&quot;../../io/basic_istream/operator_gtgt&quot;&gt;operator&amp;gt;&amp;gt;&lt;/a&gt;, and returns immediately. A common solution is to ignore all leftover characters on the line of input with &lt;code&gt;cin.ignore(&lt;a href=&quot;../../types/numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;&lt;a href=&quot;../../io/streamsize&quot;&gt;std::streamsize&lt;/a&gt;&amp;gt;::max(), '\n');&lt;/code&gt; before switching to line-oriented input.</source>
          <target state="translated">При использовании сразу после ввода через пробел, например, после &lt;code&gt;int n; &lt;a href=&quot;../../io/cin&quot;&gt;std::cin&lt;/a&gt; &amp;gt;&amp;gt; n;&lt;/code&gt; , &lt;code&gt;getline&lt;/code&gt; потребляет лицевую линию символа слева от входного потока с помощью &lt;a href=&quot;../../io/basic_istream/operator_gtgt&quot;&gt;оператора &amp;gt;&amp;gt;&lt;/a&gt; , и возвращается сразу. Распространенным решением является игнорирование всех оставшихся символов в строке ввода с помощью &lt;code&gt;cin.ignore(&lt;a href=&quot;../../types/numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;&lt;a href=&quot;../../io/streamsize&quot;&gt;std::streamsize&lt;/a&gt;&amp;gt;::max(), '\n');&lt;/code&gt; перед переключением на линейно-ориентированный ввод.</target>
        </trans-unit>
        <trans-unit id="810ee96ebb349b821e1635ff4d35660a0d38207d" translate="yes" xml:space="preserve">
          <source>When used in a class definition, &lt;code&gt;final&lt;/code&gt; specifies that this class may not appear in the base-specifier-list of another class definition (in other words, cannot be derived from). The program is ill-formed (a compile-time error is generated) otherwise. &lt;code&gt;final&lt;/code&gt; can also be used with a &lt;a href=&quot;union&quot;&gt;union&lt;/a&gt; definition, in which case it has no effect (other than on the outcome of &lt;code&gt;&lt;a href=&quot;../types/is_final&quot;&gt;std::is_final&lt;/a&gt;&lt;/code&gt;), since unions cannot be derived from).</source>
          <target state="translated">При использовании в определении класса &lt;code&gt;final&lt;/code&gt; указывает, что этот класс может отсутствовать в списке базовых спецификаторов определения другого класса (другими словами, не может быть получен из). В противном случае программа некорректна (генерируется ошибка времени компиляции). &lt;code&gt;final&lt;/code&gt; также может использоваться с определением &lt;a href=&quot;union&quot;&gt;объединения&lt;/a&gt; , и в этом случае оно не оказывает никакого влияния (кроме как на результат &lt;code&gt;&lt;a href=&quot;../types/is_final&quot;&gt;std::is_final&lt;/a&gt;&lt;/code&gt; ), поскольку объединения не могут быть получены из).</target>
        </trans-unit>
        <trans-unit id="9305de135bb255cca457fdbece5abb6dd9a1674a" translate="yes" xml:space="preserve">
          <source>When used in a controlling expression of &lt;a href=&quot;../preprocessor/conditional&quot;&gt;#if&lt;/a&gt; or &lt;a href=&quot;http://en.cppreference.com/w/c/preprocessor/conditional.html&quot;&gt;#elif&lt;/a&gt;, all signed integer constants act as if they have type &lt;code&gt;&lt;a href=&quot;../types/integer&quot;&gt;std::intmax_t&lt;/a&gt;&lt;/code&gt; and all unsigned integer constants act as if they have type &lt;code&gt;&lt;a href=&quot;../types/integer&quot;&gt;std::uintmax_t&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">При использовании в управляющем выражении &lt;a href=&quot;../preprocessor/conditional&quot;&gt;#if&lt;/a&gt; или &lt;a href=&quot;http://en.cppreference.com/w/c/preprocessor/conditional.html&quot;&gt;#elif&lt;/a&gt; все целочисленные константы со знаком действуют так, как будто они имеют тип &lt;code&gt;&lt;a href=&quot;../types/integer&quot;&gt;std::intmax_t&lt;/a&gt;&lt;/code&gt; а все целочисленные константы без знака действуют так, как если бы они имели тип &lt;code&gt;&lt;a href=&quot;../types/integer&quot;&gt;std::uintmax_t&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8b903d2e014bf8406262e3731d09165f67923eb1" translate="yes" xml:space="preserve">
          <source>When used in a virtual function declaration or definition, &lt;code&gt;final&lt;/code&gt; ensures that the function is virtual and specifies that it may not be overridden by derived classes. The program is ill-formed (a compile-time error is generated) otherwise.</source>
          <target state="translated">При использовании в объявлении или определении виртуальной функции &lt;code&gt;final&lt;/code&gt; гарантирует, что функция является виртуальной, и указывает, что она не может быть переопределена производными классами. В противном случае программа некорректна (генерируется ошибка времени компиляции).</target>
        </trans-unit>
        <trans-unit id="1a6b7e3d85e506288364ecfff9f25bf551cd3185" translate="yes" xml:space="preserve">
          <source>When used in an expression &lt;code&gt;in &amp;gt;&amp;gt; get_money(mon, intl)&lt;/code&gt;, parses the character input as a monetary value, as specified by the &lt;code&gt;&lt;a href=&quot;../../locale/money_get&quot;&gt;std::money_get&lt;/a&gt;&lt;/code&gt; facet of the locale currently imbued in &lt;code&gt;in&lt;/code&gt;, and stores the value in &lt;code&gt;mon&lt;/code&gt;.</source>
          <target state="translated">При использовании в выражении &lt;code&gt;in &amp;gt;&amp;gt; get_money(mon, intl)&lt;/code&gt; анализирует ввод символов как денежное значение, как указано в фасете &lt;code&gt;&lt;a href=&quot;../../locale/money_get&quot;&gt;std::money_get&lt;/a&gt;&lt;/code&gt; локали, в настоящий момент внедренной в &lt;code&gt;in&lt;/code&gt; , и сохраняет значение в &lt;code&gt;mon&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="dba580a9fb7386ece9bcb9047821c34efdbd2cc6" translate="yes" xml:space="preserve">
          <source>When used in an expression &lt;code&gt;in &amp;gt;&amp;gt; get_time(tmb, fmt)&lt;/code&gt;, parses the character input as a date/time value according to format string &lt;code&gt;fmt&lt;/code&gt; according to the &lt;code&gt;&lt;a href=&quot;../../locale/time_get&quot;&gt;std::time_get&lt;/a&gt;&lt;/code&gt; facet of the locale currently imbued in the input stream &lt;code&gt;in&lt;/code&gt;. The resultant value is stored in a &lt;code&gt;&lt;a href=&quot;../../chrono/c/tm&quot;&gt;std::tm&lt;/a&gt;&lt;/code&gt; object pointed to by &lt;code&gt;tmb&lt;/code&gt;.</source>
          <target state="translated">При использовании в выражении &lt;code&gt;in &amp;gt;&amp;gt; get_time(tmb, fmt)&lt;/code&gt; анализирует ввод символов как значение даты / времени в соответствии со строкой формата &lt;code&gt;fmt&lt;/code&gt; в соответствии с аспектом &lt;code&gt;&lt;a href=&quot;../../locale/time_get&quot;&gt;std::time_get&lt;/a&gt;&lt;/code&gt; локали, в настоящее время внедренной во входной поток &lt;code&gt;in&lt;/code&gt; . Полученное значение сохраняется в объекте &lt;code&gt;&lt;a href=&quot;../../chrono/c/tm&quot;&gt;std::tm&lt;/a&gt;&lt;/code&gt; указывает &lt;code&gt;tmb&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8f6b6002a8d5ee59f8db2c3ad5177196e34c65dc" translate="yes" xml:space="preserve">
          <source>When used in an expression &lt;code&gt;out &amp;lt;&amp;lt; put_money(mon, intl)&lt;/code&gt;, converts the monetary value &lt;code&gt;mon&lt;/code&gt; to its character representation as specified by the &lt;code&gt;&lt;a href=&quot;../../locale/money_put&quot;&gt;std::money_put&lt;/a&gt;&lt;/code&gt; facet of the locale currently imbued in &lt;code&gt;out&lt;/code&gt;.</source>
          <target state="translated">При использовании в выражении &lt;code&gt;out &amp;lt;&amp;lt; put_money(mon, intl)&lt;/code&gt; преобразует денежное значение &lt;code&gt;mon&lt;/code&gt; в его символьное представление, как указано в фасете &lt;code&gt;&lt;a href=&quot;../../locale/money_put&quot;&gt;std::money_put&lt;/a&gt;&lt;/code&gt; локали, в настоящее время внедренной в &lt;code&gt;out&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cf45d63014365fd6dcec8ecebade756fbe4b1751" translate="yes" xml:space="preserve">
          <source>When used in an expression &lt;code&gt;out &amp;lt;&amp;lt; put_time(tmb, fmt)&lt;/code&gt;, converts the date and time information from a given calendar time &lt;code&gt;tmb&lt;/code&gt; to a character string according to format string &lt;code&gt;fmt&lt;/code&gt;, as if by calling &lt;code&gt;&lt;a href=&quot;../../chrono/c/strftime&quot;&gt;std::strftime&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../../chrono/c/wcsftime&quot;&gt;std::wcsftime&lt;/a&gt;&lt;/code&gt;, or analog (depending on &lt;code&gt;CharT&lt;/code&gt;), according to the &lt;code&gt;&lt;a href=&quot;../../locale/time_put&quot;&gt;std::time_put&lt;/a&gt;&lt;/code&gt; facet of the locale currently imbued in the output stream &lt;code&gt;out&lt;/code&gt;.</source>
          <target state="translated">При использовании в выражении &lt;code&gt;out &amp;lt;&amp;lt; put_time(tmb, fmt)&lt;/code&gt; преобразует информацию о дате и времени из заданного календарного времени &lt;code&gt;tmb&lt;/code&gt; в строку символов в соответствии со строкой формата &lt;code&gt;fmt&lt;/code&gt; , как если бы вызывал &lt;code&gt;&lt;a href=&quot;../../chrono/c/strftime&quot;&gt;std::strftime&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../../chrono/c/wcsftime&quot;&gt;std::wcsftime&lt;/a&gt;&lt;/code&gt; или аналоговый (в зависимости от &lt;code&gt;CharT&lt;/code&gt; ), в соответствии с фасетом &lt;code&gt;&lt;a href=&quot;../../locale/time_put&quot;&gt;std::time_put&lt;/a&gt;&lt;/code&gt; локали, в настоящий момент внедренной в выходной поток &lt;code&gt;out&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c4b7fe6253074e6b867e1474688d0f2693a1f7d0" translate="yes" xml:space="preserve">
          <source>When used in an expression &lt;code&gt;out &amp;lt;&amp;lt; quoted(s, delim, escape)&lt;/code&gt;, where &lt;code&gt;out&lt;/code&gt; is an output stream with &lt;code&gt;char_type&lt;/code&gt; equal to &lt;code&gt;CharT&lt;/code&gt; and, for overloads 2-4, &lt;code&gt;traits_type&lt;/code&gt; equal to &lt;code&gt;Traits&lt;/code&gt;, behaves as a &lt;a href=&quot;../../named_req/formattedoutputfunction&quot;&gt;FormattedOutputFunction&lt;/a&gt;, which inserts into &lt;code&gt;out&lt;/code&gt; a sequence of characters &lt;code&gt;seq&lt;/code&gt; constructed as follows:</source>
          <target state="translated">При использовании в выражении &lt;code&gt;out &amp;lt;&amp;lt; quoted(s, delim, escape)&lt;/code&gt; , где &lt;code&gt;out&lt;/code&gt; представляет собой выходной поток с &lt;code&gt;char_type&lt;/code&gt; , равный &lt;code&gt;CharT&lt;/code&gt; , а для перегрузки 2-4, &lt;code&gt;traits_type&lt;/code&gt; , равных &lt;code&gt;Traits&lt;/code&gt; , ведет себя как &lt;a href=&quot;../../named_req/formattedoutputfunction&quot;&gt;FormattedOutputFunction&lt;/a&gt; , который вставляет &lt;code&gt;out&lt;/code&gt; последовательность символов &lt;code&gt;seq&lt;/code&gt; построена следующим образом:</target>
        </trans-unit>
        <trans-unit id="d8ac1ad4097229286f1a455e696150cbe6d78fe1" translate="yes" xml:space="preserve">
          <source>When used in an expression &lt;code&gt;out &amp;lt;&amp;lt; resetiosflags(mask)&lt;/code&gt; or &lt;code&gt;in &amp;gt;&amp;gt; resetiosflags(mask)&lt;/code&gt;, clears all format flags of the stream &lt;code&gt;out&lt;/code&gt; or &lt;code&gt;in&lt;/code&gt; as specified by the &lt;code&gt;mask&lt;/code&gt;.</source>
          <target state="translated">При использовании в выражении &lt;code&gt;out &amp;lt;&amp;lt; resetiosflags(mask)&lt;/code&gt; или &lt;code&gt;in &amp;gt;&amp;gt; resetiosflags(mask)&lt;/code&gt; очищает все флаги формата потока &lt;code&gt;out&lt;/code&gt; или &lt;code&gt;in&lt;/code&gt; , как указано в &lt;code&gt;mask&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="921ff88652686f85b631d9ceb7c724eb668d404a" translate="yes" xml:space="preserve">
          <source>When used in an expression &lt;code&gt;out &amp;lt;&amp;lt; setfill(c)&lt;/code&gt; sets the fill character of the stream &lt;code&gt;out&lt;/code&gt; to &lt;code&gt;c&lt;/code&gt;.</source>
          <target state="translated">При использовании в выражении &lt;code&gt;out &amp;lt;&amp;lt; setfill(c)&lt;/code&gt; устанавливает символ - заполнитель потока &lt;code&gt;out&lt;/code&gt; в &lt;code&gt;c&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9cb9f3afac80724df521c61b025e7c53651f4eb2" translate="yes" xml:space="preserve">
          <source>When used in an expression &lt;code&gt;out &amp;lt;&amp;lt; setiosflags(mask)&lt;/code&gt; or &lt;code&gt;in &amp;gt;&amp;gt; setiosflags(mask)&lt;/code&gt;, sets all format flags of the stream &lt;code&gt;out&lt;/code&gt; or &lt;code&gt;in&lt;/code&gt; as specified by the &lt;code&gt;mask&lt;/code&gt;.</source>
          <target state="translated">При использовании в выражении &lt;code&gt;out &amp;lt;&amp;lt; setiosflags(mask)&lt;/code&gt; или &lt;code&gt;in &amp;gt;&amp;gt; setiosflags(mask)&lt;/code&gt; , устанавливает все флаги формата потока &lt;code&gt;out&lt;/code&gt; или &lt;code&gt;in&lt;/code&gt; , как указано в &lt;code&gt;mask&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a87b307fde755e230f472b8260a494dc64a86904" translate="yes" xml:space="preserve">
          <source>When used in an expression &lt;code&gt;out &amp;lt;&amp;lt; setprecision(n)&lt;/code&gt; or &lt;code&gt;in &amp;gt;&amp;gt; setprecision(n)&lt;/code&gt;, sets the &lt;code&gt;precision&lt;/code&gt; parameter of the stream &lt;code&gt;out&lt;/code&gt; or &lt;code&gt;in&lt;/code&gt; to exactly &lt;code&gt;n&lt;/code&gt;.</source>
          <target state="translated">При использовании в выражении &lt;code&gt;out &amp;lt;&amp;lt; setprecision(n)&lt;/code&gt; или &lt;code&gt;in &amp;gt;&amp;gt; setprecision(n)&lt;/code&gt; устанавливает для параметра &lt;code&gt;precision&lt;/code&gt; потока &lt;code&gt;out&lt;/code&gt; или &lt;code&gt;in&lt;/code&gt; значение ровно &lt;code&gt;n&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c6a94f6a0cf9d3d1d83f0c666f4d933e3aa6770f" translate="yes" xml:space="preserve">
          <source>When used in an expression &lt;code&gt;out &amp;lt;&amp;lt; setw(n)&lt;/code&gt; or &lt;code&gt;in &amp;gt;&amp;gt; setw(n)&lt;/code&gt;, sets the &lt;code&gt;width&lt;/code&gt; parameter of the stream &lt;code&gt;out&lt;/code&gt; or &lt;code&gt;in&lt;/code&gt; to exactly &lt;code&gt;n&lt;/code&gt;.</source>
          <target state="translated">При использовании в выражении &lt;code&gt;out &amp;lt;&amp;lt; setw(n)&lt;/code&gt; или &lt;code&gt;in &amp;gt;&amp;gt; setw(n)&lt;/code&gt; устанавливает для параметра &lt;code&gt;width&lt;/code&gt; потока &lt;code&gt;out&lt;/code&gt; или &lt;code&gt;in&lt;/code&gt; значение ровно &lt;code&gt;n&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="101375a819be934deee54d8762c9258b209a7717" translate="yes" xml:space="preserve">
          <source>When used with &lt;a href=&quot;new&quot;&gt;new[]-expression&lt;/a&gt;, the size of an array may be zero; such an array has no elements:</source>
          <target state="translated">При использовании с &lt;a href=&quot;new&quot;&gt;выражением new []&lt;/a&gt; размер массива может быть равен нулю; такой массив не имеет элементов:</target>
        </trans-unit>
        <trans-unit id="b5d2f5c5efbba3505a9a104fbd815a3de55bb31d" translate="yes" xml:space="preserve">
          <source>When used with a (non-const) object that has copy-on-write semantics, the range-based for loop may trigger a deep copy by (implicitly) calling the non-const &lt;code&gt;begin()&lt;/code&gt; member function. If that is undesirable (for instance because the loop is not actually modifying the object), &lt;code&gt;&lt;a href=&quot;../utility/as_const&quot;&gt;std::as_const&lt;/a&gt;&lt;/code&gt; can be used:</source>
          <target state="translated">При использовании с (неконстантным) объектом, который имеет семантику копирования при записи, основанный на диапазоне цикл for может инициировать глубокое копирование путем (неявного) вызова неконстантной функции-члена &lt;code&gt;begin()&lt;/code&gt; . Если это нежелательно (например, потому что цикл фактически не модифицирует объект), можно использовать &lt;code&gt;&lt;a href=&quot;../utility/as_const&quot;&gt;std::as_const&lt;/a&gt;&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="bf6c1868cc765347d09cc64a36b7be944f8dd8fb" translate="yes" xml:space="preserve">
          <source>When using a non-converting locale (the default locale is non-converting), the overrider of this function in &lt;code&gt;&lt;a href=&quot;../basic_ifstream&quot;&gt;std::basic_ifstream&lt;/a&gt;&lt;/code&gt; may be optimized for zero-copy bulk I/O (by means of overriding &lt;code&gt;&lt;a href=&quot;../basic_streambuf/sgetn&quot;&gt;std::streambuf::xsgetn&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">При использовании неконвертирующего языкового стандарта (языковой стандарт по умолчанию неконвертирующий) переопределение этой функции в &lt;code&gt;&lt;a href=&quot;../basic_ifstream&quot;&gt;std::basic_ifstream&lt;/a&gt;&lt;/code&gt; может быть оптимизировано для массового ввода-вывода с нулевым копированием (путем переопределения &lt;code&gt;&lt;a href=&quot;../basic_streambuf/sgetn&quot;&gt;std::streambuf::xsgetn&lt;/a&gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="0986776c60c5c2e2615f44185f446f8dc94a3805" translate="yes" xml:space="preserve">
          <source>When using a non-converting locale (the default locale is non-converting), the overrider of this function in &lt;code&gt;&lt;a href=&quot;../basic_ofstream&quot;&gt;std::basic_ofstream&lt;/a&gt;&lt;/code&gt; may be optimized for zero-copy bulk I/O (by means of overriding &lt;code&gt;&lt;a href=&quot;../basic_streambuf/sputn&quot;&gt;std::streambuf::xsputn&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">При использовании неконвертирующего языкового стандарта (языковой стандарт по умолчанию неконвертирующий) переопределение этой функции в &lt;code&gt;&lt;a href=&quot;../basic_ofstream&quot;&gt;std::basic_ofstream&lt;/a&gt;&lt;/code&gt; может быть оптимизировано для массового ввода-вывода с нулевым копированием (посредством переопределения &lt;code&gt;&lt;a href=&quot;../basic_streambuf/sputn&quot;&gt;std::streambuf::xsputn&lt;/a&gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="cbe8e117435e8afed934a7b78bf92466217654af" translate="yes" xml:space="preserve">
          <source>When using parallel execution policy, it is the programmer's responsibility to avoid data races and deadlocks:</source>
          <target state="translated">При использовании политики параллельного выполнения,программист обязан избегать гонок данных и дедлоков:</target>
        </trans-unit>
        <trans-unit id="7dd97b15bcdd677ac393fd1531f4ab0a23cce05d" translate="yes" xml:space="preserve">
          <source>When working with the C++ container library, the proper type for the difference between iterators is the member typedef &lt;code&gt;difference_type&lt;/code&gt;, which is often synonymous with &lt;code&gt;std::ptrdiff_t&lt;/code&gt;.</source>
          <target state="translated">При работе с ++ контейнером библиотекой C, соответствующий типом разницы между итераторами является членом ЬурейеГо &lt;code&gt;difference_type&lt;/code&gt; , который часто ассоциируется с &lt;code&gt;std::ptrdiff_t&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="744601d71e0a622aae7e049c96112c98fceb410b" translate="yes" xml:space="preserve">
          <source>When writing characters, &lt;code&gt;&lt;a href=&quot;ostreambuf_iterator&quot;&gt;std::ostreambuf_iterator&lt;/a&gt;&lt;/code&gt; is more efficient, since it avoids the overhead of constructing and destructing the sentry object once per character.</source>
          <target state="translated">При написании символов &lt;code&gt;&lt;a href=&quot;ostreambuf_iterator&quot;&gt;std::ostreambuf_iterator&lt;/a&gt;&lt;/code&gt; более эффективен, поскольку позволяет избежать накладных расходов на создание и уничтожение объекта sentry один раз на символ.</target>
        </trans-unit>
        <trans-unit id="6d6a0d2f37c6465daaf393a9cbcafd860707692e" translate="yes" xml:space="preserve">
          <source>Whenever a reference is bound to a temporary or to a subobject thereof, the lifetime of the temporary is extended to match the lifetime of the reference, with the following exceptions:</source>
          <target state="translated">Всякий раз,когда ссылка привязана к временной или к ее подобъекту,срок действия временной ссылки продлевается,чтобы он совпадал со сроком действия ссылки,за следующими исключениями:</target>
        </trans-unit>
        <trans-unit id="a47ec6b9ae119d13c79d3ecadb3d357577c88006" translate="yes" xml:space="preserve">
          <source>Whenever an attempt is made to read or modify the stored value of an object of type &lt;code&gt;DynamicType&lt;/code&gt; through a glvalue of type &lt;code&gt;AliasedType&lt;/code&gt;, the behavior is undefined unless one of the following is true:</source>
          <target state="translated">Всякий раз, когда делается попытка прочитать или изменить сохраненное значение объекта типа &lt;code&gt;DynamicType&lt;/code&gt; с помощью glvalue типа &lt;code&gt;AliasedType&lt;/code&gt; , поведение не определено, если не выполняется одно из следующих условий:</target>
        </trans-unit>
        <trans-unit id="9101581b76be4f749934d75b25f2b3f56089760f" translate="yes" xml:space="preserve">
          <source>Whenever the arguments are some C++ basic types, there are no ADL-associated namespaces. Hence, those scenarios are identical with the non-ADL examples above.</source>
          <target state="translated">Всякий раз,когда аргументами являются некоторые базовые типы C++,не существует ADL-ассоциируемых пространств имен.Следовательно,эти сценарии идентичны вышеприведенным примерам,не связанным с ADL.</target>
        </trans-unit>
        <trans-unit id="77eef7bb821cc1a1b8c9c6ab0b0e1de54272ecdc" translate="yes" xml:space="preserve">
          <source>Where &lt;a href=&quot;../../language/objects#Strict_aliasing&quot;&gt;strict aliasing&lt;/a&gt; prohibits examining the same memory as values of two different types, &lt;code&gt;std::memcpy&lt;/code&gt; may be used to convert the values.</source>
          <target state="translated">В тех случаях, когда &lt;a href=&quot;../../language/objects#Strict_aliasing&quot;&gt;строгое псевдонимы&lt;/a&gt; запрещают проверять ту же память, что и значения двух разных типов, для преобразования значений можно использовать &lt;code&gt;std::memcpy&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c53cccdafaba481597a722fa2959cf7a851c2ce1" translate="yes" xml:space="preserve">
          <source>Where &lt;code&gt;weak_this&lt;/code&gt; is the hidden mutable &lt;code&gt;std::weak_ptr&lt;/code&gt; member of &lt;code&gt;std::shared_from_this&lt;/code&gt;. The assignment to the &lt;code&gt;weak_this&lt;/code&gt; member is not atomic and conflicts with any potentially concurrent access to the same object. This ensures that future calls to &lt;a href=&quot;../enable_shared_from_this/shared_from_this&quot;&gt;&lt;code&gt;shared_from_this()&lt;/code&gt;&lt;/a&gt; would share ownership with the &lt;code&gt;shared_ptr&lt;/code&gt; created by this raw pointer constructor.</source>
          <target state="translated">Где &lt;code&gt;weak_this&lt;/code&gt; это скрытый изменяемые &lt;code&gt;std::weak_ptr&lt;/code&gt; член &lt;code&gt;std::shared_from_this&lt;/code&gt; . Отнесение к &lt;code&gt;weak_this&lt;/code&gt; элемента не является атомарным и конфликтов с любым потенциально одновременным доступом к тому же объекту. Это гарантирует, что будущие вызовы &lt;a href=&quot;../enable_shared_from_this/shared_from_this&quot;&gt; &lt;code&gt;shared_from_this()&lt;/code&gt; &lt;/a&gt; будут совместно использовать владение с &lt;code&gt;shared_ptr&lt;/code&gt; , созданным этим необработанным конструктором указателя.</target>
        </trans-unit>
        <trans-unit id="328d7d83b15b53db0928e0b402874f758e429540" translate="yes" xml:space="preserve">
          <source>Where R is the ordering category type defined above.</source>
          <target state="translated">Где R-тип категории заказа,определенный выше.</target>
        </trans-unit>
        <trans-unit id="582de0628906c31348c3039934a0f8563d8361ee" translate="yes" xml:space="preserve">
          <source>Where a constant expression is grammatically required, including:</source>
          <target state="translated">Где грамматически требуется постоянное выражение,в том числе:</target>
        </trans-unit>
        <trans-unit id="a8ebf782644f9429bc1fc6810b05c7e9c3c03635" translate="yes" xml:space="preserve">
          <source>Where applicable, &lt;a href=&quot;../iterator/iterator_tags#Example&quot;&gt;tag dispatch&lt;/a&gt;, &lt;a href=&quot;static_assert&quot;&gt;static_assert&lt;/a&gt;, and, if available, &lt;a href=&quot;constraints&quot;&gt;concepts&lt;/a&gt;, are usually preferred over direct use of SFINAE.</source>
          <target state="translated">Где это применимо, &lt;a href=&quot;../iterator/iterator_tags#Example&quot;&gt;диспетчеризация тегов&lt;/a&gt; , &lt;a href=&quot;static_assert&quot;&gt;static_assert&lt;/a&gt; и, если возможно, &lt;a href=&quot;constraints&quot;&gt;концепции&lt;/a&gt; , обычно предпочтительнее прямого использования SFINAE.</target>
        </trans-unit>
        <trans-unit id="c16c807394bc564276f7b672bb496e133719e00a" translate="yes" xml:space="preserve">
          <source>Where built-in operators return &lt;code&gt;bool&lt;/code&gt;, most &lt;a href=&quot;operators&quot;&gt;user-defined overloads&lt;/a&gt; also return &lt;code&gt;bool&lt;/code&gt; so that the user-defined operators can be used in the same manner as the built-ins. However, in a user-defined operator overload, any type can be used as return type (including &lt;code&gt;void&lt;/code&gt;).</source>
          <target state="translated">Когда встроенные операторы возвращают &lt;code&gt;bool&lt;/code&gt; , большинство &lt;a href=&quot;operators&quot;&gt;пользовательских перегрузок&lt;/a&gt; также возвращают &lt;code&gt;bool&lt;/code&gt; , так что пользовательские операторы могут использоваться так же, как встроенные. Однако при пользовательской перегрузке оператора любой тип может использоваться в качестве возвращаемого типа (включая &lt;code&gt;void&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="1889e8caa29d75a1818f0a931ca52b8fe1415229" translate="yes" xml:space="preserve">
          <source>Where class-name must name the current class (or current instantiation of a class template), or, when declared at namespace scope or in a friend declaration, it must be a qualified class name.</source>
          <target state="translated">Тогда как имя класса должно содержать имя текущего класса (или текущее воплощение шаблона класса),или,когда оно объявляется в области пространства имен или в дружеском объявлении,оно должно быть квалифицированным именем класса.</target>
        </trans-unit>
        <trans-unit id="03f3df53bc82d8371ebdee50da2998db2016a301" translate="yes" xml:space="preserve">
          <source>Where class_name must name the current class (or current instantiation of a class template), or, when declared at namespace scope or in a friend declaration, it must be a qualified class name.</source>
          <target state="translated">Если имя class_name должно содержать имя текущего класса (или текущее воплощение шаблона класса),или,если оно объявлено в области видимости пространства имен или в объявлении друга,оно должно быть квалифицированным именем класса.</target>
        </trans-unit>
        <trans-unit id="d7ad86ffa9afba91a0ed8ad0042113ba1987e71e" translate="yes" xml:space="preserve">
          <source>Where direct access to the elements of the container is not wanted or not possible or distinguishing between lvalue &lt;code&gt;c[i] = v;&lt;/code&gt; and rvalue &lt;code&gt;v = c[i];&lt;/code&gt; usage, operator[] may return a proxy. see for example &lt;code&gt;&lt;a href=&quot;../utility/bitset/operator_at&quot;&gt;std::bitset::operator[]&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Там, где прямой доступ к элементам контейнера нежелателен или невозможен, или различие между lvalue &lt;code&gt;c[i] = v;&lt;/code&gt; и значение &lt;code&gt;v = c[i];&lt;/code&gt; Использование, оператор [] может вернуть прокси. см. например, &lt;code&gt;&lt;a href=&quot;../utility/bitset/operator_at&quot;&gt;std::bitset::operator[]&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7544bd14fb0127b9e675324fe322b59d1667847a" translate="yes" xml:space="preserve">
          <source>Where necessary, the compiler may implicitly define the &lt;a href=&quot;default_constructor&quot;&gt;default constructor&lt;/a&gt;, &lt;a href=&quot;copy_constructor&quot;&gt;copy constructor&lt;/a&gt;, &lt;a href=&quot;move_constructor&quot;&gt;move constructor&lt;/a&gt;, &lt;a href=&quot;as_operator&quot;&gt;copy assignment operator&lt;/a&gt;, &lt;a href=&quot;move_operator&quot;&gt;move assignment operator&lt;/a&gt;, and the &lt;a href=&quot;destructor&quot;&gt;destructor&lt;/a&gt;.</source>
          <target state="translated">В случае необходимости, компилятор может неявно определить &lt;a href=&quot;default_constructor&quot;&gt;конструктор по умолчанию&lt;/a&gt; , &lt;a href=&quot;copy_constructor&quot;&gt;конструктор копирования&lt;/a&gt; , &lt;a href=&quot;move_constructor&quot;&gt;перемещение конструктора&lt;/a&gt; , &lt;a href=&quot;as_operator&quot;&gt;копирующий оператор присваивания&lt;/a&gt; , &lt;a href=&quot;move_operator&quot;&gt;оператор присваивания шага&lt;/a&gt; , и &lt;a href=&quot;destructor&quot;&gt;деструктор&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0d39fc5aa0a8a0218582cd66f3e979536d5af157" translate="yes" xml:space="preserve">
          <source>Where the input for &lt;code&gt;real&lt;/code&gt; and &lt;code&gt;imaginary&lt;/code&gt; must be convertible to &lt;code&gt;T&lt;/code&gt;.  If an error occurs calls &lt;code&gt;is.setstate(ios_base::failbit)&lt;/code&gt;.</source>
          <target state="translated">Где вход для &lt;code&gt;real&lt;/code&gt; и &lt;code&gt;imaginary&lt;/code&gt; сусла быть конвертирован в &lt;code&gt;T&lt;/code&gt; . При возникновении ошибки вызывает &lt;code&gt;is.setstate(ios_base::failbit)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f939b6cebddd88e076c47ab7052d80f4f9691f8f" translate="yes" xml:space="preserve">
          <source>Whether &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INEXACT&lt;/a&gt;&lt;/code&gt; is raised by the mathematical library functions is unspecified in general, but may be explicitly specified in the description of the function (e.g. &lt;code&gt;&lt;a href=&quot;rint&quot;&gt;std::rint&lt;/a&gt;&lt;/code&gt; vs &lt;code&gt;&lt;a href=&quot;nearbyint&quot;&gt;std::nearbyint&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">То, &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INEXACT&lt;/a&gt;&lt;/code&gt; ли FE_INEXACT функциями математической библиотеки, в общем случае не определено, но может быть явно указано в описании функции (например, &lt;code&gt;&lt;a href=&quot;rint&quot;&gt;std::rint&lt;/a&gt;&lt;/code&gt; против &lt;code&gt;&lt;a href=&quot;nearbyint&quot;&gt;std::nearbyint&lt;/a&gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="b0ef570637f0306b69eab32021437454f7aeaff6" translate="yes" xml:space="preserve">
          <source>Whether &lt;code&gt;char&lt;/code&gt;, &lt;code&gt;short&lt;/code&gt;, &lt;code&gt;int&lt;/code&gt;, &lt;code&gt;long&lt;/code&gt;, and &lt;code&gt;long long&lt;/code&gt; bit fields that aren't explicitly &lt;code&gt;signed&lt;/code&gt; or &lt;code&gt;unsigned&lt;/code&gt; are signed or unsigned.</source>
          <target state="translated">Будь то &lt;code&gt;char&lt;/code&gt; , &lt;code&gt;short&lt;/code&gt; , &lt;code&gt;int&lt;/code&gt; , &lt;code&gt;long&lt;/code&gt; и &lt;code&gt;long long&lt;/code&gt; битовые поля, которые не &lt;code&gt;signed&lt;/code&gt; явно или не &lt;code&gt;unsigned&lt;/code&gt; , подписаны или не подписаны.</target>
        </trans-unit>
        <trans-unit id="21520e7d3c4c9457f0b61f7da5be4c28fb0b2934" translate="yes" xml:space="preserve">
          <source>Whether implemented or not, this function is normally called by &lt;code&gt;std::basic_streambuf::in_avail&lt;/code&gt; if the get area is empty.</source>
          <target state="translated">Реализована она или нет, эта функция обычно вызывается &lt;code&gt;std::basic_streambuf::in_avail&lt;/code&gt; если область get пуста.</target>
        </trans-unit>
        <trans-unit id="be104b12a99ce4ffaccf474c68581deb485380ae" translate="yes" xml:space="preserve">
          <source>Whether or not the operation succeeds, the stream is no longer associated with a file, and the buffer allocated by &lt;code&gt;&lt;a href=&quot;setbuf&quot;&gt;std::setbuf&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;setvbuf&quot;&gt;std::setvbuf&lt;/a&gt;&lt;/code&gt;, if any, is also disassociated and deallocated if automatic allocation was used.</source>
          <target state="translated">Независимо от того, успешно ли выполняется операция, поток больше не связан с файлом, и буфер, выделенный с помощью &lt;code&gt;&lt;a href=&quot;setbuf&quot;&gt;std::setbuf&lt;/a&gt;&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;setvbuf&quot;&gt;std::setvbuf&lt;/a&gt;&lt;/code&gt; , если таковой имеется, также разъединяется и освобождается, если используется автоматическое распределение.</target>
        </trans-unit>
        <trans-unit id="d46a08839feaec08adbd051313d8939dc9b21b97" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;&lt;a href=&quot;../money_put&quot;&gt;std::money_put&lt;/a&gt;&lt;/code&gt; uses pos_format for formatting positive values and neg_format for formatting negative values, &lt;code&gt;&lt;a href=&quot;../money_get&quot;&gt;std::money_get&lt;/a&gt;&lt;/code&gt; uses neg_format for parsing all monetary values: it assumes that neg_format is compatible with pos_format.</source>
          <target state="translated">В то время как &lt;code&gt;&lt;a href=&quot;../money_put&quot;&gt;std::money_put&lt;/a&gt;&lt;/code&gt; использует pos_format для форматирования положительных значений и neg_format для форматирования отрицательных значений, &lt;code&gt;&lt;a href=&quot;../money_get&quot;&gt;std::money_get&lt;/a&gt;&lt;/code&gt; использует neg_format для анализа всех денежных значений: предполагается, что neg_format совместим с pos_format.</target>
        </trans-unit>
        <trans-unit id="4882bae700593de48c423f4a185a6a87fc8e0168" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;codecvt&lt;/code&gt; supports N:M conversions (e.g. UTF-16 to UTF-8, where two internal characters may be necessary to decide what external characters to output), &lt;code&gt;&lt;a href=&quot;../../io/basic_filebuf&quot;&gt;std::basic_filebuf&lt;/a&gt;&lt;/code&gt; can only use &lt;code&gt;codecvt&lt;/code&gt; facets that define a 1:N conversion, that is it must be able to process one internal character at a time when writing to a file.</source>
          <target state="translated">В то время как &lt;code&gt;codecvt&lt;/code&gt; поддерживает преобразования N: M (например, UTF-16 в UTF-8, где два внутренних символа могут понадобиться для определения того, какие внешние символы выводить), &lt;code&gt;&lt;a href=&quot;../../io/basic_filebuf&quot;&gt;std::basic_filebuf&lt;/a&gt;&lt;/code&gt; может использовать &lt;code&gt;codecvt&lt;/code&gt; фасеты codecvt, которые определяют преобразование 1: N, то есть он должен уметь обрабатывать один внутренний символ за раз при записи в файл.</target>
        </trans-unit>
        <trans-unit id="ce692aaa12dee04f1b7857662f9696d7b39d104a" translate="yes" xml:space="preserve">
          <source>While all fundamental types &lt;code&gt;T&lt;/code&gt; for which &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::is_exact==true&lt;/code&gt; are integer types, a library may define exact types that aren't integers, e.g. a rational arithmetics type representing fractions.</source>
          <target state="translated">Хотя все фундаментальные типы &lt;code&gt;T&lt;/code&gt; , для которых &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::is_exact==true&lt;/code&gt; являются целочисленными типами, библиотека может определять точные типы, которые не являются целыми, например, рациональный арифметический тип, представляющий дроби.</target>
        </trans-unit>
        <trans-unit id="5c6831ef0dd5db6345bc002124c0babc32834531" translate="yes" xml:space="preserve">
          <source>While in C++, the scope of the init-statement and the scope of statement are one and the same, in C the scope of statement is nested within the scope of init-statement:</source>
          <target state="translated">В то время как в языке С++сфера применения иницационного заявления и сфера применения заявления являются одними и теми же,в языке С сфера применения заявления вложена в сферу применения иницационного заявления:</target>
        </trans-unit>
        <trans-unit id="f6a198ae06795de880db0e81ff4942b69fa0d198" translate="yes" xml:space="preserve">
          <source>While it's not true for fundamental C++ floating-point types, a third-party floating-point type &lt;code&gt;T&lt;/code&gt; may exist such that &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::lowest() != -&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::max()&lt;/code&gt;.</source>
          <target state="translated">Хотя это не так для фундаментальных типов C ++ с плавающей точкой, может существовать сторонний тип &lt;code&gt;T&lt;/code&gt; с плавающей точкой, такой что &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::lowest() != -&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::max()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bdb7f0b47137662d6f73c67c92fda0e6b0d6c3b8" translate="yes" xml:space="preserve">
          <source>While narrow strings provide &lt;code&gt;&lt;a href=&quot;printf&quot;&gt;std::snprintf&lt;/a&gt;&lt;/code&gt;, which makes it possible to determine the required output buffer size, there is no equivalent for wide strings, and in order to determine the buffer size, the program may need to call &lt;code&gt;std::swprintf&lt;/code&gt;, check the result value, and reallocate a larger buffer, trying again until successful.</source>
          <target state="translated">В то время как узкие строки предоставляют &lt;code&gt;&lt;a href=&quot;printf&quot;&gt;std::snprintf&lt;/a&gt;&lt;/code&gt; , который позволяет определить требуемый размер выходного буфера, эквивалент для широких строк не существует, и для определения размера буфера программе может потребоваться вызвать &lt;code&gt;std::swprintf&lt;/code&gt; , проверьте значение результата, и перераспределите больший буфер, пытаясь снова, пока успешно.</target>
        </trans-unit>
        <trans-unit id="2aad7bc15a2badfcfdc2770354ab9bdb48f5b39a" translate="yes" xml:space="preserve">
          <source>While narrow strings provide &lt;code&gt;&lt;a href=&quot;vfprintf&quot;&gt;std::vsnprintf&lt;/a&gt;&lt;/code&gt;, which makes it possible to determine the required output buffer size, there is no equivalent for wide strings, and in order to determine the buffer size, the program may need to call &lt;code&gt;std::vswprintf&lt;/code&gt;, check the result value, and reallocate a larger buffer, trying again until successful.</source>
          <target state="translated">В то время как узкие строки предоставляют &lt;code&gt;&lt;a href=&quot;vfprintf&quot;&gt;std::vsnprintf&lt;/a&gt;&lt;/code&gt; , что позволяет определить требуемый размер выходного буфера, эквивалент для широких строк не существует, и для определения размера буфера программе может потребоваться вызвать &lt;code&gt;std::vswprintf&lt;/code&gt; , проверьте значение результата, и перераспределите больший буфер, пытаясь снова, пока успешно.</target>
        </trans-unit>
        <trans-unit id="3d1b9b2d47483d07a008f2f3460cb714ec262b09" translate="yes" xml:space="preserve">
          <source>While objects of any complete type and cv pointers to void may be thrown as exception objects, all standard library functions throw anonymous temporary objects by value, and the types of those objects are derived (directly or indirectly) from &lt;code&gt;&lt;a href=&quot;../error/exception&quot;&gt;std::exception&lt;/a&gt;&lt;/code&gt;. User-defined exceptions usually follow this pattern.&lt;sup id=&quot;cite_ref-7&quot;&gt;&lt;a href=&quot;exceptions#cite_note-7&quot;&gt;[7]&lt;/a&gt;&lt;/sup&gt;&lt;sup id=&quot;cite_ref-8&quot;&gt;&lt;a href=&quot;exceptions#cite_note-8&quot;&gt;[8]&lt;/a&gt;&lt;/sup&gt;&lt;sup id=&quot;cite_ref-9&quot;&gt;&lt;a href=&quot;exceptions#cite_note-9&quot;&gt;[9]&lt;/a&gt;&lt;/sup&gt;</source>
          <target state="translated">В то время как объекты любого полного типа и cv указатели на void могут быть выброшены как объекты исключений, все стандартные библиотечные функции генерируют анонимные временные объекты по значению, а типы этих объектов выводятся (прямо или косвенно) из &lt;code&gt;&lt;a href=&quot;../error/exception&quot;&gt;std::exception&lt;/a&gt;&lt;/code&gt; . Пользовательские исключения обычно следуют этому шаблону. &lt;sup id=&quot;cite_ref-7&quot;&gt;&lt;a href=&quot;exceptions#cite_note-7&quot;&gt;[7] &lt;/a&gt;&lt;/sup&gt;&lt;sup id=&quot;cite_ref-8&quot;&gt;&lt;a href=&quot;exceptions#cite_note-8&quot;&gt;[8] &lt;/a&gt;&lt;/sup&gt;&lt;sup id=&quot;cite_ref-9&quot;&gt;&lt;a href=&quot;exceptions#cite_note-9&quot;&gt;[9]&lt;/a&gt;&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="dd014792b0e30b26904af64ce06af14ab14dade5" translate="yes" xml:space="preserve">
          <source>While the names &quot;gptr&quot; and &quot;egptr&quot; refer to the get area, the name &quot;eback&quot; refers to the end of the putback area: stepping backwards from gptr, characters can be put back until eback.</source>
          <target state="translated">В то время как имена &quot;gptr&quot; и &quot;egptr&quot; относятся к области get,имя &quot;eback&quot; относится к концу области putback:шаг назад от gptr,символы могут быть возвращены назад до eback.</target>
        </trans-unit>
        <trans-unit id="e6aed0f8bf11c0e2ccb4abb52781539645453846" translate="yes" xml:space="preserve">
          <source>While the signature does not need to have &lt;code&gt;const &amp;amp;&lt;/code&gt;, the function must not modify the objects passed to it and must be able to accept all values of type (possibly const) &lt;code&gt;Type1&lt;/code&gt; and &lt;code&gt;Type2&lt;/code&gt; regardless of &lt;a href=&quot;../../language/value_category&quot;&gt;value category&lt;/a&gt; (thus, &lt;code&gt;Type1 &amp;amp;&lt;/code&gt; is not allowed, nor is &lt;code&gt;Type1&lt;/code&gt; unless for &lt;code&gt;Type1&lt;/code&gt; a move is equivalent to a copy(since C++11)).</source>
          <target state="translated">Хотя подпись не должна иметь &lt;code&gt;const &amp;amp;&lt;/code&gt; , функция не должна изменять передаваемые ей объекты и должна иметь возможность принимать все значения типа (возможно, const) &lt;code&gt;Type1&lt;/code&gt; и &lt;code&gt;Type2&lt;/code&gt; независимо от &lt;a href=&quot;../../language/value_category&quot;&gt;категории значения&lt;/a&gt; (таким образом, &lt;code&gt;Type1 &amp;amp;&lt;/code&gt; не допускается Кроме того, &lt;code&gt;Type1&lt;/code&gt; не является исключением, если для &lt;code&gt;Type1&lt;/code&gt; перемещение эквивалентно копии (начиная с C ++ 11)).</target>
        </trans-unit>
        <trans-unit id="b82e35d8b86e026d1b1ef3ee87feedc4e74f5048" translate="yes" xml:space="preserve">
          <source>While the signature does not need to have &lt;code&gt;const &amp;amp;&lt;/code&gt;, the function must not modify the objects passed to it and must be able to accept all values of type (possibly const) &lt;code&gt;Type1&lt;/code&gt; and &lt;code&gt;Type2&lt;/code&gt; regardless of &lt;a href=&quot;../language/value_category&quot;&gt;value category&lt;/a&gt; (thus, &lt;code&gt;Type1 &amp;amp;&lt;/code&gt; is not allowed, nor is &lt;code&gt;Type1&lt;/code&gt; unless for &lt;code&gt;Type1&lt;/code&gt; a move is equivalent to a copy(since C++11)).</source>
          <target state="translated">Хотя подпись не должна иметь &lt;code&gt;const &amp;amp;&lt;/code&gt; , функция не должна изменять передаваемые ей объекты и должна иметь возможность принимать все значения типа (возможно, const) &lt;code&gt;Type1&lt;/code&gt; и &lt;code&gt;Type2&lt;/code&gt; независимо от &lt;a href=&quot;../language/value_category&quot;&gt;категории значения&lt;/a&gt; (таким образом, &lt;code&gt;Type1 &amp;amp;&lt;/code&gt; не допускается Кроме того, &lt;code&gt;Type1&lt;/code&gt; не является исключением, если для &lt;code&gt;Type1&lt;/code&gt; перемещение эквивалентно копии (начиная с C ++ 11)).</target>
        </trans-unit>
        <trans-unit id="90970ed5fc36e4c5fcc7d19dbc8d5693453a089b" translate="yes" xml:space="preserve">
          <source>While the stream is frozen, &lt;code&gt;&lt;a href=&quot;overflow&quot;&gt;overflow()&lt;/a&gt;&lt;/code&gt; will not reallocate the buffer and the &lt;code&gt;destructor&lt;/code&gt; will not deallocate the buffer (thereby causing a memory leak).</source>
          <target state="translated">Пока поток заморожен, &lt;code&gt;&lt;a href=&quot;overflow&quot;&gt;overflow()&lt;/a&gt;&lt;/code&gt; не перераспределяет буфер, а &lt;code&gt;destructor&lt;/code&gt; не освобождает буфер (что приводит к утечке памяти).</target>
        </trans-unit>
        <trans-unit id="51e02d156ab35053fbad0f57e42b76301b58ea18" translate="yes" xml:space="preserve">
          <source>While the variable declared in the range_declaration is usually used in the loop_statement, doing so is not required.</source>
          <target state="translated">Хотя переменная,объявленная в объявлении range_declaration,обычно используется в loop_statement,делать это не требуется.</target>
        </trans-unit>
        <trans-unit id="6c5f647e812d8ac720bd9936607ee574df0ff21f" translate="yes" xml:space="preserve">
          <source>While throw-expression can be used to transfer control to an arbitrary block of code up the execution stack, for arbitrary reasons (similar to &lt;code&gt;&lt;a href=&quot;../utility/program/longjmp&quot;&gt;std::longjmp&lt;/a&gt;&lt;/code&gt;), its intended usage is error handling.</source>
          <target state="translated">Хотя throw-выражение может использоваться для передачи управления произвольному блоку кода вверх по стеку выполнения, по произвольным причинам (аналогично &lt;code&gt;&lt;a href=&quot;../utility/program/longjmp&quot;&gt;std::longjmp&lt;/a&gt;&lt;/code&gt; ), его предполагаемое использование - обработка ошибок.</target>
        </trans-unit>
        <trans-unit id="721c1b250c710b24bfafaf9daadc9fa8642ecac8" translate="yes" xml:space="preserve">
          <source>While with &lt;code&gt;copy_options::recursive&lt;/code&gt;, the subdirectories are also copied, with their content, recursively.</source>
          <target state="translated">В то время как с &lt;code&gt;copy_options::recursive&lt;/code&gt; , подкаталоги также копируются с их содержимым рекурсивно.</target>
        </trans-unit>
        <trans-unit id="b7402781ffeb31aaf9f29177f61c8ff4a0f44050" translate="yes" xml:space="preserve">
          <source>Wide character</source>
          <target state="translated">Широкий характер</target>
        </trans-unit>
        <trans-unit id="1fb55327ce03b4f2af732e3d187f25baf551cf61" translate="yes" xml:space="preserve">
          <source>Wide character array manipulation</source>
          <target state="translated">Широкая манипуляция с массивом символов</target>
        </trans-unit>
        <trans-unit id="6808058d5dd776d7c4d9454174f9c39df21f19c7" translate="yes" xml:space="preserve">
          <source>Wide character representation of &lt;code&gt;c&lt;/code&gt; if &lt;code&gt;(unsigned char)c&lt;/code&gt; is a valid single-byte character in the initial shift state, &lt;code&gt;WEOF&lt;/code&gt; otherwise.</source>
          <target state="translated">Представление широких символов &lt;code&gt;c&lt;/code&gt; , если &lt;code&gt;(unsigned char)c&lt;/code&gt; является допустимым однобайтовым символом в начальном состоянии сдвига, в &lt;code&gt;WEOF&lt;/code&gt; случае WEOF .</target>
        </trans-unit>
        <trans-unit id="ab38913ae786de6e808a7c7241557b1856fc368e" translate="yes" xml:space="preserve">
          <source>Wide string manipulation</source>
          <target state="translated">Широкая манипуляция с строками</target>
        </trans-unit>
        <trans-unit id="e56ba2339bc3a2c7efd4a4f1ffa763681a4e7ccb" translate="yes" xml:space="preserve">
          <source>Widening always returns a wide character, but only the characters from the basic source character set (latin letters, digits, and punctuations required to write a C++ program) are guaranteed to have a unique, well-defined, widening transformation, which is also guaranteed to be reversible (by &lt;code&gt;&lt;a href=&quot;narrow&quot;&gt;narrow()&lt;/a&gt;&lt;/code&gt;). In practice, all characters whose multibyte representation is a single byte are usually widened to their wide character counterparts, and the rest of the possible single-byte values are usually mapped into the same placeholder value, typically &lt;code&gt;CharT(-1)&lt;/code&gt;.</source>
          <target state="translated">Расширение всегда возвращает широкий символ, но только символы из базового исходного набора символов (латинские буквы, цифры и знаки препинания, необходимые для написания программы на C ++) гарантированно имеют уникальное, четко определенное расширяющее преобразование, которое также гарантировано быть обратимым (по &lt;code&gt;&lt;a href=&quot;narrow&quot;&gt;narrow()&lt;/a&gt;&lt;/code&gt; ). На практике все символы, чье многобайтовое представление представляет собой один байт, обычно расширяются до своих аналогов широких символов, а остальные возможные однобайтовые значения обычно отображаются в одно и то же значение заполнителя, обычно &lt;code&gt;CharT(-1)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="15d388cfaf360c5681944037eaaad4926f0761c9" translate="yes" xml:space="preserve">
          <source>Widening, if successful, preserves all character classification categories known to &lt;code&gt;&lt;a href=&quot;is&quot;&gt;is()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Расширение, в случае успеха, сохраняет все известные категории классификации символов &lt;code&gt;&lt;a href=&quot;is&quot;&gt;is()&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4e27d3de30e21293ff54a527696fb3dc557516fd" translate="yes" xml:space="preserve">
          <source>Widens a single-byte character &lt;code&gt;c&lt;/code&gt; to its wide character equivalent.</source>
          <target state="translated">Расширяет однобайтовый символ &lt;code&gt;c&lt;/code&gt; до его эквивалента широкого символа.</target>
        </trans-unit>
        <trans-unit id="3cf16972858ec6c71abfb6fa6d539bdbe451dbf6" translate="yes" xml:space="preserve">
          <source>Width in bits by data model</source>
          <target state="translated">Ширина в битах по модели данных</target>
        </trans-unit>
        <trans-unit id="0352671572d548b1b50beb4586216b4e3764d488" translate="yes" xml:space="preserve">
          <source>Win16 API</source>
          <target state="translated">Win16 API</target>
        </trans-unit>
        <trans-unit id="ae7fc6d8171e0e405ed2e200f1d2b5056d479b80" translate="yes" xml:space="preserve">
          <source>Win32 API</source>
          <target state="translated">API Win32</target>
        </trans-unit>
        <trans-unit id="50f72286ea0c96bccbea595ccc66e3982412d267" translate="yes" xml:space="preserve">
          <source>Win64 API</source>
          <target state="translated">Win64 API</target>
        </trans-unit>
        <trans-unit id="84a4a9dac26edeb0330a247c9af1446aecf202e8" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;#pragma once&lt;/code&gt;, the same header appears as.</source>
          <target state="translated">При использовании &lt;code&gt;#pragma once&lt;/code&gt; и тот же заголовок отображается как.</target>
        </trans-unit>
        <trans-unit id="1d949445faea1f549e171010cf3291f2a325074c" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;N = l - f&lt;/code&gt;, for all &lt;code&gt;0 &amp;lt; i &amp;lt; N&lt;/code&gt;, &lt;code&gt;f[floor(&lt;table&gt;
&lt;tr&gt;&lt;td&gt;i-1&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;2&lt;/td&gt;&lt;/tr&gt;
&lt;/table&gt;)]&lt;/code&gt; does not compare less than &lt;code&gt;f[i]&lt;/code&gt;.</source>
          <target state="translated">С &lt;code&gt;N = l - f&lt;/code&gt; для всех &lt;code&gt;0 &amp;lt; i &amp;lt; N&lt;/code&gt; , &lt;code&gt;f[floor(&lt;table&gt; &lt;tr&gt;&lt;td&gt;i-1&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;2&lt;/td&gt;&lt;/tr&gt; &lt;/table&gt;)]&lt;/code&gt; не сравнивает меньше чем &lt;code&gt;f[i]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b0d81a9b5de91fa98a2d0ef9f4c7f4ecf47988e3" translate="yes" xml:space="preserve">
          <source>With \n instead of endl, the output would be the same, but may not appear in real time.</source>
          <target state="translated">При использовании \n вместо endl вывод будет таким же,но может не отображаться в реальном времени.</target>
        </trans-unit>
        <trans-unit id="47777a8b463cd5f1e3501816b2ffaa3ea107991e" translate="yes" xml:space="preserve">
          <source>With floating point types &lt;code&gt;std::to_string&lt;/code&gt; may yield unexpected results as the number of significant digits in the returned string can be zero, see the example.</source>
          <target state="translated">С типами с плавающей точкой &lt;code&gt;std::to_string&lt;/code&gt; может дать неожиданные результаты, так как количество значащих цифр в возвращаемой строке может быть нулевым, см. Пример.</target>
        </trans-unit>
        <trans-unit id="884b3b619e3ef18e83dc71855fd6e34d05de7659" translate="yes" xml:space="preserve">
          <source>With operands of arithmetic or enumeration type, the result of binary plus is the sum of the operands (after usual arithmetic conversions), and the result of the binary minus operator is the result of subtracting the second operand from the first (after usual arithmetic conversions), except that, if the type supports IEEE floating-point arithmetic (see &lt;code&gt;&lt;a href=&quot;../types/numeric_limits/is_iec559&quot;&gt;std::numeric_limits::is_iec559&lt;/a&gt;&lt;/code&gt;),</source>
          <target state="translated">Для операндов арифметического или перечислимого типа результат двоичного плюса представляет собой сумму операндов (после обычных арифметических преобразований), а результат двоичного оператора минуса - результат вычитания второго операнда из первого (после обычных арифметических преобразований) ), за исключением того, что если тип поддерживает арифметику с плавающей точкой IEEE (см. &lt;code&gt;&lt;a href=&quot;../types/numeric_limits/is_iec559&quot;&gt;std::numeric_limits::is_iec559&lt;/a&gt;&lt;/code&gt; ),</target>
        </trans-unit>
        <trans-unit id="fa16b9931c1f17c4f80ec1a246f1cc250c5dd37a" translate="yes" xml:space="preserve">
          <source>With the default allocator, this requirement is equivalent to the validity of &lt;code&gt;p-&amp;gt;~T()&lt;/code&gt;, which accepts class types with accessible destructors and all scalar types, but rejects array types, function types, reference types, and void.</source>
          <target state="translated">С распределителем по умолчанию это требование эквивалентно валидности &lt;code&gt;p-&amp;gt;~T()&lt;/code&gt; , которая принимает типы классов с доступными деструкторами и все скалярные типы, но отклоняет типы массивов, типы функций, ссылочные типы и void.</target>
        </trans-unit>
        <trans-unit id="b4fea2c438a60cf674bf6a42d287a393b3f62920" translate="yes" xml:space="preserve">
          <source>With the exception of &lt;code&gt;complex.h&lt;/code&gt; , each &lt;code&gt;xxx.h&lt;/code&gt; header included in the C++ standard library places in the global namespace each name that the corresponding &lt;code&gt;cxxx&lt;/code&gt; header would have placed in the &lt;code&gt;std&lt;/code&gt; namespace.</source>
          <target state="translated">За исключением &lt;code&gt;complex.h&lt;/code&gt; , каждый заголовок &lt;code&gt;xxx.h&lt;/code&gt; , включенный в стандартную библиотеку C ++, размещает в глобальном пространстве имен каждое имя, которое соответствующий заголовок &lt;code&gt;cxxx&lt;/code&gt; поместил бы в пространство имен &lt;code&gt;std&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5d30f232b7061443bee920972c5d82807b94d345" translate="yes" xml:space="preserve">
          <source>With the introduction of move semantics in C++11, value categories were redefined to characterize two independent properties of expressions&lt;sup id=&quot;cite_ref-5&quot;&gt;&lt;a href=&quot;value_category#cite_note-5&quot;&gt;[5]&lt;/a&gt;&lt;/sup&gt;:</source>
          <target state="translated">С введением семантики перемещения в C ++ 11 категории значений были переопределены для характеристики двух независимых свойств выражений &lt;sup id=&quot;cite_ref-5&quot;&gt;&lt;a href=&quot;value_category#cite_note-5&quot;&gt;[5]&lt;/a&gt;&lt;/sup&gt; :</target>
        </trans-unit>
        <trans-unit id="d7eedc43562dbda358e0af8f66b618c9779da2ba" translate="yes" xml:space="preserve">
          <source>Within a catch-clause, &lt;code&gt;&lt;a href=&quot;../error/current_exception&quot;&gt;std::current_exception&lt;/a&gt;&lt;/code&gt; can be used to capture the exception in an &lt;code&gt;&lt;a href=&quot;../error/exception_ptr&quot;&gt;std::exception_ptr&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;../error/throw_with_nested&quot;&gt;std::throw_with_nested&lt;/a&gt;&lt;/code&gt; may be used to build nested exceptions.</source>
          <target state="translated">В предложении catch можно использовать &lt;code&gt;&lt;a href=&quot;../error/current_exception&quot;&gt;std::current_exception&lt;/a&gt;&lt;/code&gt; для захвата исключения в &lt;code&gt;&lt;a href=&quot;../error/exception_ptr&quot;&gt;std::exception_ptr&lt;/a&gt;&lt;/code&gt; , а &lt;code&gt;&lt;a href=&quot;../error/throw_with_nested&quot;&gt;std::throw_with_nested&lt;/a&gt;&lt;/code&gt; можно использовать для создания вложенных исключений.</target>
        </trans-unit>
        <trans-unit id="245bc5b44f72c46518d49f6231bcdddbab7bc492" translate="yes" xml:space="preserve">
          <source>Within a class template definition (including its member functions and nested classes) some names may be deduced to refer to the</source>
          <target state="translated">В рамках определения шаблона класса (включая его функции-члены и вложенные классы)некоторые имена могут быть выведены для ссылки на</target>
        </trans-unit>
        <trans-unit id="bc89bf6548ea7d54b0a391d0d3c8b9447ce5c361" translate="yes" xml:space="preserve">
          <source>Within a scope, &lt;a href=&quot;lookup&quot;&gt;unqualified name lookup&lt;/a&gt; can be used to associate the name with its declaration.</source>
          <target state="translated">Внутри области &lt;a href=&quot;lookup&quot;&gt;поиска&lt;/a&gt; можно использовать неквалифицированное имя, чтобы связать имя с его объявлением.</target>
        </trans-unit>
        <trans-unit id="00817315634a43af97703fb51abe4ea2bd10d529" translate="yes" xml:space="preserve">
          <source>Within a template definition, certain names are deduced to belong to an</source>
          <target state="translated">В рамках определения шаблона некоторые имена вычисляются как принадлежащие к</target>
        </trans-unit>
        <trans-unit id="7119f9b6e9a5c41a2215c5c5ab587c351e88a0e6" translate="yes" xml:space="preserve">
          <source>Within a thread of execution, accesses (reads and writes) through &lt;a href=&quot;../language/cv&quot;&gt;volatile glvalues&lt;/a&gt; cannot be reordered past observable side-effects (including other volatile accesses) that are</source>
          <target state="translated">Внутри потока выполнения доступы (чтение и запись) через &lt;a href=&quot;../language/cv&quot;&gt;изменчивые значения&lt;/a&gt; не могут быть переупорядочены после наблюдаемых побочных эффектов (включая другие изменчивые обращения), которые</target>
        </trans-unit>
        <trans-unit id="6eda1a3a6846d50df7adc54351dedaf50fda69c3" translate="yes" xml:space="preserve">
          <source>Within the body of a function that uses variadic arguments, the values of these arguments may be accessed using the &lt;a href=&quot;../utility/variadic&quot;&gt;&amp;lt;cstdarg&amp;gt; library facilities&lt;/a&gt;:</source>
          <target state="translated">Внутри тела функции, которая использует переменные аргументы, к значениям этих аргументов можно получить доступ с помощью &lt;a href=&quot;../utility/variadic&quot;&gt;средств библиотеки &amp;lt;cstdarg&amp;gt;&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="af7aded55b08b8ee429002640a601104c0c3e5cf" translate="yes" xml:space="preserve">
          <source>Within the body of a lambda, any use of &lt;a href=&quot;decltype&quot;&gt;decltype&lt;/a&gt; on any variable with automatic storage duration is as if it were captured and odr-used, even though decltype itself isn't an odr-use and no actual capture takes place:</source>
          <target state="translated">В теле лямбды любое использование &lt;a href=&quot;decltype&quot;&gt;decltype&lt;/a&gt; для любой переменной с автоматической продолжительностью хранения выглядит так, как если бы оно было захвачено и использовано odr, даже если само decltype не используется odr и фактический захват не происходит:</target>
        </trans-unit>
        <trans-unit id="078ca0cc0ac40495d119f9a3fdddbbaaae3dc64d" translate="yes" xml:space="preserve">
          <source>Within the body of a non-static &lt;a href=&quot;member_functions&quot;&gt;member function&lt;/a&gt;, each identifier that names a non-static member is implicitly transformed to a class member access expression &lt;code&gt;this-&amp;gt;member&lt;/code&gt;.</source>
          <target state="translated">В теле нестатической &lt;a href=&quot;member_functions&quot;&gt;функции&lt;/a&gt; - члена каждый идентификатор, который называет нестатический член, неявно преобразуется в выражение доступа к члену класса &lt;code&gt;this-&amp;gt;member&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="79f7c80c73c316c30ac1674843481cc4326e1a44" translate="yes" xml:space="preserve">
          <source>Within the body of a non-static member function of X, any &lt;a href=&quot;expressions&quot;&gt;id-expression&lt;/a&gt; E (e.g. an identifier) that resolves to a non-type non-static member of X or of a base class of X, is transformed to a member access expression &lt;code&gt;(*this).E&lt;/code&gt; (unless it's already a part of a member access expression). This does not occur in template definition context, so a name may have to be prefixed with &lt;code&gt;this-&amp;gt;&lt;/code&gt; explicitly to become &lt;a href=&quot;dependent_name&quot;&gt;dependent&lt;/a&gt;.</source>
          <target state="translated">Внутри тела нестатической функции-члена X любое &lt;a href=&quot;expressions&quot;&gt;id-выражение&lt;/a&gt; E (например, идентификатор), которое разрешается в нестатический член нестандартного типа X или базового класса X, преобразуется в доступ к члену выражение &lt;code&gt;(*this).E&lt;/code&gt; (если оно уже не является частью выражения доступа члена). Этого не происходит в контексте определения шаблона, поэтому имени, возможно, придется добавить префикс &lt;code&gt;this-&amp;gt;&lt;/code&gt; явно, чтобы стать &lt;a href=&quot;dependent_name&quot;&gt;зависимым&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ff9fb1990c434e938a6a0e2d84512b173b30aeb8" translate="yes" xml:space="preserve">
          <source>Within the body of a non-static member function of X, any unqualified-id that resolves to a static member, an enumerator or a nested type of X or of a base class of X, is transformed to the corresponding qualified-id.</source>
          <target state="translated">В теле нестатической функции члена X любой неквалифицированный член,который разрешается к статическому члену,счетчику или вложенному типу X или базовому классу X,трансформируется в соответствующий квалифицированный член.</target>
        </trans-unit>
        <trans-unit id="5ba9b5ad1328d649ca86d8f4a5d41ae2a5633cf1" translate="yes" xml:space="preserve">
          <source>Within the function body, the function-local predefined variable &lt;code&gt;__func__&lt;/code&gt; is defined as if by.</source>
          <target state="translated">Внутри тела функции локальная предопределенная переменная &lt;code&gt;__func__&lt;/code&gt; определяется как будто с помощью.</target>
        </trans-unit>
        <trans-unit id="f89ece3e05e483d8d6633832e929cb8220c8daba" translate="yes" xml:space="preserve">
          <source>Within the same thread, evaluation A may be</source>
          <target state="translated">В пределах одной и той же темы,оценка A может быть</target>
        </trans-unit>
        <trans-unit id="c72f89b6f5d83e25d732495d891540e02b9e90aa" translate="yes" xml:space="preserve">
          <source>Within the same thread, evaluation A that is</source>
          <target state="translated">В рамках одной и той же темы,оценка А,то есть</target>
        </trans-unit>
        <trans-unit id="25258e5219c6e5baefb975484506b38b6aa8362b" translate="yes" xml:space="preserve">
          <source>Within the scope of a class template specialization or partial specialization, when the injected-class-name is used as a type-name, it is equivalent to the template-name followed by the template-arguments of the class template specialization or partial specialization enclosed in &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">В рамках специализации или частичной специализации шаблона класса, когда в качестве имени типа используется введенное имя класса, оно эквивалентно имени шаблона, за которым следуют аргументы шаблона специализации или частичной специализации шаблона класса. в &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ce2fab5742c8b33bc0537c80ea3b8dcc2cc835e1" translate="yes" xml:space="preserve">
          <source>Within the scope of a class template, the name of the template without a parameter list is an injected class name, and can be used as a type. In that case, class argument deduction does not happen and template parameters must be supplied explicitly:</source>
          <target state="translated">В рамках шаблона класса имя шаблона без списка параметров является именем инжектируемого класса и может быть использовано в качестве типа.В этом случае вычитания аргументов класса не происходит,и параметры шаблона должны быть предоставлены явно:</target>
        </trans-unit>
        <trans-unit id="05619ddfa2c0d81e8a6ead6a708344745a722242" translate="yes" xml:space="preserve">
          <source>Without std::flush, the output would be the same, but may not appear in real time.</source>
          <target state="translated">Без std::flush вывод был бы тем же самым,но может не отображаться в реальном времени.</target>
        </trans-unit>
        <trans-unit id="d0f55a4102a27df1431160445b96e34d20fd4f3d" translate="yes" xml:space="preserve">
          <source>Without std::unitbuf or another explicit flush, the output is the same, but does not appear in real time.</source>
          <target state="translated">Без std::unitbuf или другого явного флеша,вывод тот же самый,но не появляется в реальном времени.</target>
        </trans-unit>
        <trans-unit id="682b37a0a9239f633eb0a18ad35c5e23fe316950" translate="yes" xml:space="preserve">
          <source>Working with a &lt;code&gt;priority_queue&lt;/code&gt; is similar to managing a &lt;a href=&quot;../algorithm/make_heap&quot;&gt; heap&lt;/a&gt; in some random access container, with the benefit of not being able to accidentally invalidate the heap.</source>
          <target state="translated">Работа с &lt;code&gt;priority_queue&lt;/code&gt; аналогична управлению &lt;a href=&quot;../algorithm/make_heap&quot;&gt;кучей&lt;/a&gt; в некотором контейнере произвольного доступа, с преимуществом невозможности случайно аннулировать кучу.</target>
        </trans-unit>
        <trans-unit id="8065f27e56565b08250cf2bdf011c92725655e0d" translate="yes" xml:space="preserve">
          <source>Wrapper around a member function pointer. The class instance whose member function to call is passed as a pointer to the &lt;code&gt;operator()&lt;/code&gt;.</source>
          <target state="translated">Обертка вокруг указателя на функцию-член. Экземпляр класса, функция-член которого вызывается, передается как указатель на &lt;code&gt;operator()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a56128931adfe376f6d1c4233b2aee9d4414fed0" translate="yes" xml:space="preserve">
          <source>Wrapper around a member function pointer. The class instance whose member function to call is passed as a reference to the &lt;code&gt;operator()&lt;/code&gt;.</source>
          <target state="translated">Обертка вокруг указателя на функцию-член. Экземпляр класса, функция-член которого вызывается, передается как ссылка на &lt;code&gt;operator()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="dd35487a2eb7da40332f7fc41452378d92a72445" translate="yes" xml:space="preserve">
          <source>Writable</source>
          <target state="translated">Writable</target>
        </trans-unit>
        <trans-unit id="a9b6a4bb633bad2e9e1e0bcdbb56726b9e0e6146" translate="yes" xml:space="preserve">
          <source>Write to end</source>
          <target state="translated">Пишите до конца</target>
        </trans-unit>
        <trans-unit id="e87fd10313099f92edd69106267a002d4e8466a1" translate="yes" xml:space="preserve">
          <source>Writes a character &lt;code&gt;ch&lt;/code&gt; to &lt;code&gt;stdout&lt;/code&gt;. Internally, the character is converted to &lt;code&gt;unsigned char&lt;/code&gt; just before being written.</source>
          <target state="translated">Записывает символ &lt;code&gt;ch&lt;/code&gt; в стандартный &lt;code&gt;stdout&lt;/code&gt; . Внутренне, символ преобразуется в &lt;code&gt;unsigned char&lt;/code&gt; непосредственно перед написанием.</target>
        </trans-unit>
        <trans-unit id="a96b7df507ca67492643e29e1db1884cf6663933" translate="yes" xml:space="preserve">
          <source>Writes a character &lt;code&gt;ch&lt;/code&gt; to the given output stream &lt;code&gt;stream&lt;/code&gt;.</source>
          <target state="translated">Записывает символ &lt;code&gt;ch&lt;/code&gt; в заданный поток выходного &lt;code&gt;stream&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="001712686d4b96e8257e062bf8257f5854fb0c91" translate="yes" xml:space="preserve">
          <source>Writes a horizontal tab character.</source>
          <target state="translated">Пишет горизонтальный символ табуляции.</target>
        </trans-unit>
        <trans-unit id="b8a7060cb09fe871077059dd6f46ca33bbda1f49" translate="yes" xml:space="preserve">
          <source>Writes a literal &lt;code&gt;%&lt;/code&gt; character.</source>
          <target state="translated">Пишет буквальный символ &lt;code&gt;%&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cb18b1353d53796c65bfab0bce5e3151631b33c0" translate="yes" xml:space="preserve">
          <source>Writes a newline character.</source>
          <target state="translated">Пишет символ новой строки.</target>
        </trans-unit>
        <trans-unit id="6924072c304541be0f3e71e77883f2ec6c6a9d14" translate="yes" xml:space="preserve">
          <source>Writes a textual representation of a thread identifier &lt;code&gt;id&lt;/code&gt; to the output stream &lt;code&gt;ost&lt;/code&gt;.</source>
          <target state="translated">Записывает текстовое представление идентификатора &lt;code&gt;id&lt;/code&gt; потока в выходной поток &lt;code&gt;ost&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="767a6e009054da5918825851e61b1c02bbbf738a" translate="yes" xml:space="preserve">
          <source>Writes a textual representation of the distribution parameters and internal state to &lt;code&gt;os&lt;/code&gt;. The formatting flags and fill character of &lt;code&gt;os&lt;/code&gt; are unchanged.</source>
          <target state="translated">Записывает текстовое представление параметров распределения и внутреннего состояния в &lt;code&gt;os&lt;/code&gt; . Флаги форматирования и символ заполнения &lt;code&gt;os&lt;/code&gt; остаются без изменений.</target>
        </trans-unit>
        <trans-unit id="628a432848d3d2a0f439ca52671452d1eec4d9ff" translate="yes" xml:space="preserve">
          <source>Writes a wide character &lt;code&gt;ch&lt;/code&gt; to &lt;code&gt;stdout&lt;/code&gt;.</source>
          <target state="translated">Записывает широкий символ &lt;code&gt;ch&lt;/code&gt; в стандартный &lt;code&gt;stdout&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a61cc5af43d9f51fcd06a3cacfeb3348c1595940" translate="yes" xml:space="preserve">
          <source>Writes a wide character &lt;code&gt;ch&lt;/code&gt; to the given output stream &lt;code&gt;stream&lt;/code&gt;. &lt;code&gt;putwc()&lt;/code&gt; may be implemented as a macro and may evaluate &lt;code&gt;stream&lt;/code&gt; more than once.</source>
          <target state="translated">Записывает широкий символ &lt;code&gt;ch&lt;/code&gt; в указанный поток выходного &lt;code&gt;stream&lt;/code&gt; . &lt;code&gt;putwc()&lt;/code&gt; может быть реализован как макрос и может оценивать &lt;code&gt;stream&lt;/code&gt; более одного раза.</target>
        </trans-unit>
        <trans-unit id="bb34f2576c279e7725c583723fccb0fc6a3511eb" translate="yes" xml:space="preserve">
          <source>Writes every character from the null-terminated string &lt;code&gt;str&lt;/code&gt; and one additional newline character &lt;code&gt;'\n'&lt;/code&gt; to the output stream &lt;code&gt;&lt;a href=&quot;../c&quot;&gt;stdout&lt;/a&gt;&lt;/code&gt;, as if by repeatedly executing &lt;code&gt;&lt;a href=&quot;fputc&quot;&gt;std::fputc&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Записывает каждый символ из строки &lt;code&gt;str&lt;/code&gt; с нулевым символом в конце и одного дополнительного символа новой строки &lt;code&gt;'\n'&lt;/code&gt; в выходной поток &lt;code&gt;&lt;a href=&quot;../c&quot;&gt;stdout&lt;/a&gt;&lt;/code&gt; , как будто путем многократного выполнения &lt;code&gt;&lt;a href=&quot;fputc&quot;&gt;std::fputc&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5a503bcd94956c4103d38ea588d00af71b7d3a70" translate="yes" xml:space="preserve">
          <source>Writes every character from the null-terminated string &lt;code&gt;str&lt;/code&gt; to the output stream &lt;code&gt;stream&lt;/code&gt;, as if by repeatedly executing &lt;code&gt;&lt;a href=&quot;fputc&quot;&gt;std::fputc&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Записывает каждый символ из строки &lt;code&gt;str&lt;/code&gt; с нулевым символом в конце в поток выходного &lt;code&gt;stream&lt;/code&gt; , как будто путем многократного выполнения &lt;code&gt;&lt;a href=&quot;fputc&quot;&gt;std::fputc&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="83ab79edfcdea5e94d3e192eb9d45b8f6bebd9bf" translate="yes" xml:space="preserve">
          <source>Writes every wide character from the null-terminated wide string &lt;code&gt;str&lt;/code&gt; to the output stream &lt;code&gt;stream&lt;/code&gt;, as if by repeatedly executing &lt;code&gt;&lt;a href=&quot;fputwc&quot;&gt;std::fputwc&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Записывает каждый широкий символ из строки &lt;code&gt;str&lt;/code&gt; с нулевым символом в &lt;code&gt;&lt;a href=&quot;fputwc&quot;&gt;std::fputwc&lt;/a&gt;&lt;/code&gt; в поток выходного &lt;code&gt;stream&lt;/code&gt; , как будто путем многократного выполнения std :: fputwc .</target>
        </trans-unit>
        <trans-unit id="a9b88a484ae89e6d4131f01f0c94c90cbf9dc18c" translate="yes" xml:space="preserve">
          <source>Writes one character to the output sequence.</source>
          <target state="translated">Записывает один символ в выходную последовательность.</target>
        </trans-unit>
        <trans-unit id="3aeb20d4e3a246faca11563fb03064671edc3f42" translate="yes" xml:space="preserve">
          <source>Writes some data from the put area to the associated character sequence (to the file).</source>
          <target state="translated">Записывает некоторые данные из области ввода в ассоциированную последовательность символов (в файл).</target>
        </trans-unit>
        <trans-unit id="74f04ede6f753ddec049a69f229f7dc13079d99c" translate="yes" xml:space="preserve">
          <source>Writes the ISO 8601 week of the year as a decimal number. If the result is a single digit, it is prefixed with 0.</source>
          <target state="translated">Записывает неделю года по стандарту ISO 8601 в виде десятичного числа.Если результат-одна цифра,то префикс-0.</target>
        </trans-unit>
        <trans-unit id="f7d029ddd98ce63f15114123e69a3596edcb4ab0" translate="yes" xml:space="preserve">
          <source>Writes the ISO 8601 week-based year as a decimal number. If the result is less than four digits it is left-padded with 0 to four digits.</source>
          <target state="translated">Записывает год,основанный на неделе ISO 8601,в виде десятичного числа.Если результат меньше четырех цифр,то слева от него добавляется от 0 до четырех цифр.</target>
        </trans-unit>
        <trans-unit id="0cc1164d46d9e7c267ced7895e6152ab0b695562" translate="yes" xml:space="preserve">
          <source>Writes the ISO weekday as a decimal number (1-7), where Monday is &lt;code&gt;1&lt;/code&gt;.</source>
          <target state="translated">Записывает день недели ISO в виде десятичного числа (1-7), где понедельник равен &lt;code&gt;1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="71166ded75b14ffa703a04ab3f28950a6779e502" translate="yes" xml:space="preserve">
          <source>Writes the day of month as a decimal number. If the result is a single decimal digit, it is prefixed with 0.</source>
          <target state="translated">Пишет день месяца в виде десятичного числа.Если результат-одна десятичная цифра,то она префиксом 0.</target>
        </trans-unit>
        <trans-unit id="b0f7893ae9d8e28cab469762cfa8b52ab87190ba" translate="yes" xml:space="preserve">
          <source>Writes the day of month as a decimal number. If the result is a single decimal digit, it is prefixed with a space.</source>
          <target state="translated">Пишет день месяца в виде десятичного числа.Если результат-одна десятичная цифра,то она префиксована пробелом.</target>
        </trans-unit>
        <trans-unit id="1626fbac11740992d51707eebf9b1bc3e70c4e3f" translate="yes" xml:space="preserve">
          <source>Writes the day of the year as a decimal number (January 1 is &lt;code&gt;001&lt;/code&gt;). If the result is less than three digits, it is left-padded with 0 to three digits.</source>
          <target state="translated">Записывает день года в виде десятичного числа (1 января - &lt;code&gt;001&lt;/code&gt; ). Если результат меньше трех цифр, он дополняется слева от 0 до трех цифр.</target>
        </trans-unit>
        <trans-unit id="c029d304cd7d0c5128b916f1b7935a6092ee6d60" translate="yes" xml:space="preserve">
          <source>Writes the hour (12-hour clock) as a decimal number. If the result is a single digit, it is prefixed with 0.</source>
          <target state="translated">Пишет час (12-часовой)в виде десятичного числа.Если результат-одна цифра,то префикс-0.</target>
        </trans-unit>
        <trans-unit id="d586ae48a03fbce6cab63eb6156b184051a469fd" translate="yes" xml:space="preserve">
          <source>Writes the hour (24-hour clock) as a decimal number. If the result is a single digit, it is prefixed with 0.</source>
          <target state="translated">Записывает час (24-часовой)в виде десятичного числа.Если результат-одна цифра,то префикс-0.</target>
        </trans-unit>
        <trans-unit id="67151c9d086e78a6b607bc1d8cdeea642b931db1" translate="yes" xml:space="preserve">
          <source>Writes the last two decimal digits of the ISO 8601 week-based year. If the result is a single digit it is prefixed by 0.</source>
          <target state="translated">Записывает последние две десятичные цифры года,основанного на неделе ISO 8601.Если результат-одна цифра,то префикс-0.</target>
        </trans-unit>
        <trans-unit id="9ff9a700dc66f1c252bd7007b0facde18742ff7d" translate="yes" xml:space="preserve">
          <source>Writes the last two decimal digits of the year. If the result is a single digit it is prefixed by 0.</source>
          <target state="translated">Пишет последние две десятичные цифры года.Если результат-одна цифра,то префикс-0.</target>
        </trans-unit>
        <trans-unit id="30b48d91697b9f629d02ce9d83e7a421c921e234" translate="yes" xml:space="preserve">
          <source>Writes the locale's 12-hour clock time.</source>
          <target state="translated">Пишет местное 12-часовое время.</target>
        </trans-unit>
        <trans-unit id="a971b059080c39ac822e661aea1c87ec25348313" translate="yes" xml:space="preserve">
          <source>Writes the locale's abbreviated month name.</source>
          <target state="translated">Пишет сокращенное название месяца.</target>
        </trans-unit>
        <trans-unit id="f672aa4e85699374012ee1a535ef52d6be86123e" translate="yes" xml:space="preserve">
          <source>Writes the locale's abbreviated weekday name.</source>
          <target state="translated">Пишет сокращенное название дня недели.</target>
        </trans-unit>
        <trans-unit id="a93c6febd8287cd73094f5c7fa21ffc07a57cd24" translate="yes" xml:space="preserve">
          <source>Writes the locale's date and time representation.</source>
          <target state="translated">Пишет дату и время представления места.</target>
        </trans-unit>
        <trans-unit id="8990ab22cb03b6694ce6cb909d61b54ae50e921c" translate="yes" xml:space="preserve">
          <source>Writes the locale's date representation.</source>
          <target state="translated">Пишет дату представления места жительства.</target>
        </trans-unit>
        <trans-unit id="1dec9978ca81332b5e90610cec498718c6ecefef" translate="yes" xml:space="preserve">
          <source>Writes the locale's equivalent of the AM/PM designations associated with a 12-hour clock.</source>
          <target state="translated">Записывает местный эквивалент обозначений AM/PM,связанных с 12-часовыми часами.</target>
        </trans-unit>
        <trans-unit id="4bd0b778c0ca16103f3037347259706f50406b6f" translate="yes" xml:space="preserve">
          <source>Writes the locale's full month name.</source>
          <target state="translated">Пишет название местности на весь месяц.</target>
        </trans-unit>
        <trans-unit id="dbcf68702a0a2c1386e6fd13ec2cac6f00c12942" translate="yes" xml:space="preserve">
          <source>Writes the locale's full weekday name.</source>
          <target state="translated">Пишет название местности на полный рабочий день.</target>
        </trans-unit>
        <trans-unit id="ba5f45187c6fabe4410c47f297770de07e96243b" translate="yes" xml:space="preserve">
          <source>Writes the locale's time representation.</source>
          <target state="translated">Пишет временное представление местности.</target>
        </trans-unit>
        <trans-unit id="fc68d043b917adc440f4f576ac7e4b54287ebed4" translate="yes" xml:space="preserve">
          <source>Writes the minute as a decimal number. If the result is a single digit, it is prefixed with 0.</source>
          <target state="translated">Пишет минуту как десятичное число.Если результат-одна цифра,то префикс-0.</target>
        </trans-unit>
        <trans-unit id="c30fe76679f32dcce8e852b50af05cbd5aefe9f6" translate="yes" xml:space="preserve">
          <source>Writes the month as a decimal number (January is &lt;code&gt;01&lt;/code&gt;). If the result is a single digit, it is prefixed with 0.</source>
          <target state="translated">Записывает месяц как десятичное число (январь &lt;code&gt;01&lt;/code&gt; ). Если результат представляет собой одну цифру, к нему добавляется префикс 0.</target>
        </trans-unit>
        <trans-unit id="8032e3a64c8132ccb6ad44a63e27ef9ad4339e8a" translate="yes" xml:space="preserve">
          <source>Writes the offset from UTC in the ISO 8601 format. For example &lt;code&gt;-0430&lt;/code&gt; refers to 4 hours 30 minutes behind UTC. If the offset is zero, &lt;code&gt;+0000&lt;/code&gt; is used.</source>
          <target state="translated">Записывает смещение от UTC в формате ISO 8601. Например, &lt;code&gt;-0430&lt;/code&gt; означает 4 часа 30 минут после UTC. Если смещение равно нулю, используется &lt;code&gt;+0000&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9d76d87840d6936192aee3cda5289202c38d7018" translate="yes" xml:space="preserve">
          <source>Writes the representation of the matched subsequence &lt;code&gt;m&lt;/code&gt; to the output stream &lt;code&gt;os&lt;/code&gt;.</source>
          <target state="translated">Записывает представление сопоставленной подпоследовательности &lt;code&gt;m&lt;/code&gt; в выходной поток &lt;code&gt;os&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="17feef3d0503048639900d16af24c9e6fe4685c7" translate="yes" xml:space="preserve">
          <source>Writes the second as a decimal number. If the number of seconds is less than 10, the result is prefixed with 0.</source>
          <target state="translated">Пишет второе как десятичное число.Если число секунд меньше 10,то результат ставится префиксом 0.</target>
        </trans-unit>
        <trans-unit id="1a73b5e51c193b1deccbfaf669b4db12b0a55d6d" translate="yes" xml:space="preserve">
          <source>Writes the time zone abbreviation.</source>
          <target state="translated">Пишет аббревиатуру часового пояса.</target>
        </trans-unit>
        <trans-unit id="1d8938025c2761da9ede064d18f5ef84dcf58261" translate="yes" xml:space="preserve">
          <source>Writes the week number of the year as a decimal number. The first Monday of the year is the first day of week 01. Days of the same year prior to that are in week 00. If the result is a single digit, it is prefixed with 0.</source>
          <target state="translated">Пишет номер недели года в виде десятичного числа.Первый понедельник года-первый день недели 01.Дни того же года,предшествующие этому,в 00-й неделе.Если результат-одна цифра,то префикс-0.</target>
        </trans-unit>
        <trans-unit id="370c8fdb39d9f2b4190c27cb6e07474705f3c637" translate="yes" xml:space="preserve">
          <source>Writes the week number of the year as a decimal number. The first Sunday of the year is the first day of week 01. Days of the same year prior to that are in week 00. If the result is a single digit, it is prefixed with 0.</source>
          <target state="translated">Пишет номер недели года в виде десятичного числа.Первое воскресенье года-первый день недели 01.Дни того же года,предшествующие этому,в 00-й неделе.Если результат-одна цифра,то префикс-0.</target>
        </trans-unit>
        <trans-unit id="dbdae9db0bd7c298a373f28a7cd0509bbbb5b272" translate="yes" xml:space="preserve">
          <source>Writes the weekday as a decimal number (0-6), where Sunday is &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">Записывает день недели в виде десятичного числа (0-6), где воскресенье равно &lt;code&gt;0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bb21ea8cdea47573e1038fbae721d5dca3fb901b" translate="yes" xml:space="preserve">
          <source>Writes the year as a decimal number. If the result is less than four digits it is left-padded with 0 to four digits.</source>
          <target state="translated">Пишет год как десятичное число.Если результат меньше четырех цифр,то слева от него добавляется от 0 до четырех цифр.</target>
        </trans-unit>
        <trans-unit id="26249ba8d699dd0df931793d3da64b00c7c31d1d" translate="yes" xml:space="preserve">
          <source>Writes the year divided by 100 using floored division. If the result is a single decimal digit, it is prefixed with 0.</source>
          <target state="translated">Пишет год,разделенный на 100 с помощью флористического деления.Если результат-одна десятичная цифра,то он префиксованный 0.</target>
        </trans-unit>
        <trans-unit id="a77785063b2874f1bbee1b042250317d98d6b33a" translate="yes" xml:space="preserve">
          <source>Writes to &lt;code&gt;os&lt;/code&gt; the textual representation of &lt;code&gt;x&lt;/code&gt;'s current state. In the output, adjacent numbers are separated by one or more space characters. If &lt;code&gt;os&lt;/code&gt;'s fmtflags are not set to &lt;code&gt;ios_base::dec|ios_base::left&lt;/code&gt;, the behavior may be undefined.</source>
          <target state="translated">Пишет в &lt;code&gt;os&lt;/code&gt; текстовое представление &lt;code&gt;x&lt;/code&gt; текущего состояния &amp;laquo;ы. В выходных данных соседние числа разделены одним или несколькими пробелами. Если для fmtflags для &lt;code&gt;os&lt;/code&gt; не задано значение &lt;code&gt;ios_base::dec|ios_base::left&lt;/code&gt; , поведение может быть неопределенным.</target>
        </trans-unit>
        <trans-unit id="0d621d908346c0bfe11eb811537d53c64ce8ec02" translate="yes" xml:space="preserve">
          <source>Writes to fields</source>
          <target state="translated">Написано в поля</target>
        </trans-unit>
        <trans-unit id="00c192b84cfa44d2bd75c59846c86d17a1e44b25" translate="yes" xml:space="preserve">
          <source>Writes uncommitted changes to the underlying output sequence.</source>
          <target state="translated">Записывает нефиксированные изменения в исходную выходную последовательность.</target>
        </trans-unit>
        <trans-unit id="15ec5b51c4d780460bc9101843d2786a8b364326" translate="yes" xml:space="preserve">
          <source>Writes up to &lt;code&gt;count&lt;/code&gt; binary objects from the given array &lt;code&gt;buffer&lt;/code&gt; to the output stream &lt;code&gt;stream&lt;/code&gt;. The objects are written as if by reinterpreting each object as an array of &lt;code&gt;unsigned char&lt;/code&gt; and calling &lt;code&gt;&lt;a href=&quot;fputc&quot;&gt;std::fputc&lt;/a&gt;&lt;/code&gt;&lt;code&gt;size&lt;/code&gt; times for each object to write those &lt;code&gt;unsigned char&lt;/code&gt;s into &lt;code&gt;stream&lt;/code&gt;, in order. The file position indicator for the stream is advanced by the number of characters written.</source>
          <target state="translated">Записывает для &lt;code&gt;count&lt;/code&gt; двоичных объектов из данного &lt;code&gt;buffer&lt;/code&gt; массива в поток выходного &lt;code&gt;stream&lt;/code&gt; . Объекты записываются так, как если бы они переосмысливали каждый объект как массив &lt;code&gt;unsigned char&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;fputc&quot;&gt;std::fputc&lt;/a&gt;&lt;/code&gt; &lt;code&gt;size&lt;/code&gt; std :: fputc для каждого объекта, чтобы записать эти &lt;code&gt;unsigned char&lt;/code&gt; в &lt;code&gt;stream&lt;/code&gt; по порядку. Индикатор положения файла для потока увеличивается на количество записанных символов.</target>
        </trans-unit>
        <trans-unit id="c8447596ae9170966e015adf6c315155e2268bda" translate="yes" xml:space="preserve">
          <source>Writing to the character array accessed through &lt;code&gt;c_str()&lt;/code&gt; is undefined behavior.</source>
          <target state="translated">Запись в массив символов, доступ к которому осуществляется через &lt;code&gt;c_str()&lt;/code&gt; является неопределенным поведением.</target>
        </trans-unit>
        <trans-unit id="c032adc1ff629c9b66f22749ad667e6beadf144b" translate="yes" xml:space="preserve">
          <source>X</source>
          <target state="translated">X</target>
        </trans-unit>
        <trans-unit id="93cad4f773cccfbb33c80bc8546680efa75c09a4" translate="yes" xml:space="preserve">
          <source>X and X</source>
          <target state="translated">Х и Х</target>
        </trans-unit>
        <trans-unit id="d60cdb3a38da8a130cf91abef198ed0c8df65943" translate="yes" xml:space="preserve">
          <source>X and X appears before B in the Single Total Order</source>
          <target state="translated">X и X появляются перед B в едином общем заказе.</target>
        </trans-unit>
        <trans-unit id="2f3f27dde1e0deeab004667545a65bef35394ab9" translate="yes" xml:space="preserve">
          <source>X argument</source>
          <target state="translated">аргумент Х</target>
        </trans-unit>
        <trans-unit id="4ca65c470ec6016fed78ab6aef93dd257702b23f" translate="yes" xml:space="preserve">
          <source>X, X</source>
          <target state="translated">ИКС,ИКС</target>
        </trans-unit>
        <trans-unit id="6db6535836e6c904498ebb911985cfb1ab6cbadf" translate="yes" xml:space="preserve">
          <source>X, Y is</source>
          <target state="translated">X,Y</target>
        </trans-unit>
        <trans-unit id="9ea35756029154e9210bcca0b65c206107747ec2" translate="yes" xml:space="preserve">
          <source>X, and X</source>
          <target state="translated">Икс и Х</target>
        </trans-unit>
        <trans-unit id="565e6a618c216015d885283111a97727e2c3f173" translate="yes" xml:space="preserve">
          <source>X, and X is</source>
          <target state="translated">Икс,и Х</target>
        </trans-unit>
        <trans-unit id="6ba655c53b7c6f7ad109ea6e30e446c19a1740b7" translate="yes" xml:space="preserve">
          <source>Y argument</source>
          <target state="translated">Y аргумент</target>
        </trans-unit>
        <trans-unit id="ba12622aee8e1cee306fb2ae1705d34dc28d369e" translate="yes" xml:space="preserve">
          <source>Y is sequenced-before F in thread B</source>
          <target state="translated">Y последовательна-перед F в нити B</target>
        </trans-unit>
        <trans-unit id="ed1a905ea4a6fcc0ca7ba73cce1620307e6d6ffa" translate="yes" xml:space="preserve">
          <source>Y is sequenced-before FB in thread B</source>
          <target state="translated">Y последовательна-до FB в нити B.</target>
        </trans-unit>
        <trans-unit id="3850869b7a202e66b87556b87c42f6e3bad33150" translate="yes" xml:space="preserve">
          <source>Y reads the value written by X (or by the &lt;a href=&quot;memory_order&quot;&gt;release sequence headed by X&lt;/a&gt;)</source>
          <target state="translated">Y читает значение, записанное X (или &lt;a href=&quot;memory_order&quot;&gt;последовательностью выпуска, возглавляемой X&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="1038aa0966244ed387fbcfee4940af4843ba1a40" translate="yes" xml:space="preserve">
          <source>Y reads the value written by X (or the value would be written by &lt;a href=&quot;memory_order&quot;&gt;release sequence headed by X&lt;/a&gt; if X were a release operation)</source>
          <target state="translated">Y читает значение, записанное X (или значение будет записано &lt;a href=&quot;memory_order&quot;&gt;последовательностью выпуска, возглавляемой X,&lt;/a&gt; если X была операцией выпуска)</target>
        </trans-unit>
        <trans-unit id="4d77689f2569037f676a633b110bf28151defd7c" translate="yes" xml:space="preserve">
          <source>Y, and Y is</source>
          <target state="translated">Y,а Y</target>
        </trans-unit>
        <trans-unit id="879e32326c5217968ac8e3a14e4a8a5214957264" translate="yes" xml:space="preserve">
          <source>Year</source>
          <target state="translated">Year</target>
        </trans-unit>
        <trans-unit id="869ef4891ca6fa4509dc520e3f6640c9b0cfae4a" translate="yes" xml:space="preserve">
          <source>Year, day, month</source>
          <target state="translated">Год,день,месяц</target>
        </trans-unit>
        <trans-unit id="915f26f629fd3d6f51a4b7d5990e0b50d4471157" translate="yes" xml:space="preserve">
          <source>Year, month, day</source>
          <target state="translated">Год,месяц,день</target>
        </trans-unit>
        <trans-unit id="5397e0583f14f6c88de06b1ef28f460a1fb5b0ae" translate="yes" xml:space="preserve">
          <source>Yes</source>
          <target state="translated">Yes</target>
        </trans-unit>
        <trans-unit id="f1e34b1b0b0addb32d44f2528bede851abf77e03" translate="yes" xml:space="preserve">
          <source>Yes, except erased element(s)</source>
          <target state="translated">Да,за исключением стертых элементов.</target>
        </trans-unit>
        <trans-unit id="7ed1f0e98f8b97a0cbc079098f9b970f72dbe20e" translate="yes" xml:space="preserve">
          <source>Yield-expression returns a value to the caller and suspends the current coroutine: it is the common building block of resumable generator functions.</source>
          <target state="translated">Выражение доходности возвращает вызывающему абоненту значение и приостанавливает текущую коруэтину:это общий строительный блок функций возобновляемого генератора.</target>
        </trans-unit>
        <trans-unit id="1791a81aeb4f78d0ab4f9096c83089810fc43595" translate="yes" xml:space="preserve">
          <source>Yields &lt;code&gt;X​::​eq(c,d)&lt;/code&gt; if for some &lt;code&gt;c&lt;/code&gt; and &lt;code&gt;d&lt;/code&gt;, &lt;code&gt;e == X::to_int_type(c)&lt;/code&gt; and &lt;code&gt;f == X::to_int_type(d)&lt;/code&gt;</source>
          <target state="translated">Урожайность &lt;code&gt;X​::​eq(c,d)&lt;/code&gt; , если для некоторого &lt;code&gt;c&lt;/code&gt; и &lt;code&gt;d&lt;/code&gt; , &lt;code&gt;e == X::to_int_type(c)&lt;/code&gt; и &lt;code&gt;f == X::to_int_type(d)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="729d384e3fcd3d72644a0c1418ba7a729b79ac57" translate="yes" xml:space="preserve">
          <source>ZERO WIDTH SPACE - ZERO WIDTH JOINER</source>
          <target state="translated">НУЛЕВОЕ ПРОСТРАНСТВО ШИРИНЫ-НУЛЕВОЙ СОЕДИНИТЕЛЬ ШИРИНЫ</target>
        </trans-unit>
        <trans-unit id="51c939bb7f5f0758dd76abfc0b3c05c623bebff7" translate="yes" xml:space="preserve">
          <source>Zero if &lt;code&gt;lhs&lt;/code&gt; and &lt;code&gt;rhs&lt;/code&gt; compare equal.</source>
          <target state="translated">Ноль, если &lt;code&gt;lhs&lt;/code&gt; и &lt;code&gt;rhs&lt;/code&gt; сравниваются равными.</target>
        </trans-unit>
        <trans-unit id="917c36f59225ed77c40603a32141411ab5f9fea6" translate="yes" xml:space="preserve">
          <source>Zero if &lt;code&gt;x&lt;/code&gt; is zero; otherwise, one plus the base-2 logarithm of &lt;code&gt;x&lt;/code&gt;, with any fractional part discarded.</source>
          <target state="translated">Ноль, если &lt;code&gt;x&lt;/code&gt; ноль; в противном случае один плюс логарифм по основанию-2 для &lt;code&gt;x&lt;/code&gt; , а любая дробная часть отбрасывается.</target>
        </trans-unit>
        <trans-unit id="0f17813fad92e667b30a4557d41d38bf185f1f8c" translate="yes" xml:space="preserve">
          <source>Zero if &lt;code&gt;x&lt;/code&gt; is zero; otherwise, the largest integral power of two that is not greater than &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">Ноль, если &lt;code&gt;x&lt;/code&gt; ноль; в противном случае наибольшая интегральная степень двух не больше &lt;code&gt;x&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="405ae0fba6c1904278eb371bc24b47d81b1d7d3c" translate="yes" xml:space="preserve">
          <source>Zero initialization is performed in the following situations:</source>
          <target state="translated">Нулевая инициализация выполняется в следующих ситуациях:</target>
        </trans-unit>
        <trans-unit id="a1be729d580f443d76655de63a066d43b5c754d5" translate="yes" xml:space="preserve">
          <source>Zero or more of the following:</source>
          <target state="translated">Ноль или больше из следующего:</target>
        </trans-unit>
        <trans-unit id="d00bedfb8c02a9e78a0c8655d079c8a74339369e" translate="yes" xml:space="preserve">
          <source>Zero otherwise</source>
          <target state="translated">Иначе ноль</target>
        </trans-unit>
        <trans-unit id="ca77598d8983f14f3898f59c121fdcf1e9e18087" translate="yes" xml:space="preserve">
          <source>[-]d.ddd</source>
          <target state="translated">[-]d.ddd</target>
        </trans-unit>
        <trans-unit id="913e7afee46c7a822906ed5749ddbb4805cee7d2" translate="yes" xml:space="preserve">
          <source>[-]ddd.ddd</source>
          <target state="translated">[-]ddd.ddd</target>
        </trans-unit>
        <trans-unit id="8c2b29412829eefb22455e55f53e2c249d24e11a" translate="yes" xml:space="preserve">
          <source>[-]dddd</source>
          <target state="translated">[-]dddd</target>
        </trans-unit>
        <trans-unit id="c1734847a74561b4543b119ae934914f50b4cfb4" translate="yes" xml:space="preserve">
          <source>[-x3</source>
          <target state="translated">[-x3</target>
        </trans-unit>
        <trans-unit id="d750010a709171aa3f400cbe019efe556b93b506" translate="yes" xml:space="preserve">
          <source>[0,</source>
          <target state="translated">[0,</target>
        </trans-unit>
        <trans-unit id="e61dea886117af6d2ec7f9dcb7bd9a3411c6e61f" translate="yes" xml:space="preserve">
          <source>[&lt;code&gt;ranges::begin(E)&lt;/code&gt;, &lt;code&gt;ranges::end(E)&lt;/code&gt;) denotes a range, and</source>
          <target state="translated">[ &lt;code&gt;ranges::begin(E)&lt;/code&gt; , range &lt;code&gt;ranges::end(E)&lt;/code&gt; ) обозначает диапазон и</target>
        </trans-unit>
        <trans-unit id="228f7d207920fb84335fac5b2b06ed7b472ece9e" translate="yes" xml:space="preserve">
          <source>[deleted]</source>
          <target state="translated">[deleted]</target>
        </trans-unit>
        <trans-unit id="73a877ccfe464539ac89cb8083cf71234db18da5" translate="yes" xml:space="preserve">
          <source>[first,first)</source>
          <target state="translated">[first,first)</target>
        </trans-unit>
        <trans-unit id="7231a3611aa5bad8f818b0f7bb419a3d1200483d" translate="yes" xml:space="preserve">
          <source>[first,last)</source>
          <target state="translated">[first,last)</target>
        </trans-unit>
        <trans-unit id="2855c5627ea838aafc570baf3e8f5ddda039170b" translate="yes" xml:space="preserve">
          <source>[last,last)</source>
          <target state="translated">[last,last)</target>
        </trans-unit>
        <trans-unit id="51f320773f671463a4338fa2cd7489e0a7d0a19d" translate="yes" xml:space="preserve">
          <source>[nothrow-]swappable traits</source>
          <target state="translated">[nothrow-] сменные черты</target>
        </trans-unit>
        <trans-unit id="2706c6dc283ec831e2ea7c5771adc61d0195a5e5" translate="yes" xml:space="preserve">
          <source>[static]</source>
          <target state="translated">[static]</target>
        </trans-unit>
        <trans-unit id="44fed6b6252fc5fda7cc744792424bdd0b7b1020" translate="yes" xml:space="preserve">
          <source>[static](C++11)</source>
          <target state="translated">[static](C++11)</target>
        </trans-unit>
        <trans-unit id="e4b4e5b6ec02f085b66944f0e3a63cac3c002038" translate="yes" xml:space="preserve">
          <source>[static](C++17)</source>
          <target state="translated">[static](C++17)</target>
        </trans-unit>
        <trans-unit id="0352562c44ca57a96c86a8ce2c63b508390a988b" translate="yes" xml:space="preserve">
          <source>[static](C++20)</source>
          <target state="translated">[static](C++20)</target>
        </trans-unit>
        <trans-unit id="85894ee8b74956e4f1ad040534bebb4a92408ba9" translate="yes" xml:space="preserve">
          <source>[static](optional)</source>
          <target state="translated">[static](optional)</target>
        </trans-unit>
        <trans-unit id="e621ceda2c534b69cb910cae3059eb9ff125986d" translate="yes" xml:space="preserve">
          <source>[virtual]</source>
          <target state="translated">[virtual]</target>
        </trans-unit>
        <trans-unit id="986bbf2f9f0c3cbbc6546d685166748b60c20798" translate="yes" xml:space="preserve">
          <source>[virtual](C++11)</source>
          <target state="translated">[virtual](C++11)</target>
        </trans-unit>
        <trans-unit id="8af4f9130ab9142006b068ed0c1ed35271abd3b0" translate="yes" xml:space="preserve">
          <source>[virtual](implicitly declared)</source>
          <target state="translated">[виртуальный] (неявно объявленный)</target>
        </trans-unit>
        <trans-unit id="a80e5ea0695ed7f04f7f2926fafe2f96aa4dcb23" translate="yes" xml:space="preserve">
          <source>[x2</source>
          <target state="translated">[x2</target>
        </trans-unit>
        <trans-unit id="36886f5ee53771548cf5c86e4853a8dcf06d3e14" translate="yes" xml:space="preserve">
          <source>] radians, is returned.</source>
          <target state="translated">] радианы, возвращается.</target>
        </trans-unit>
        <trans-unit id="12ec352745ee599586db13a925319fe87a988295" translate="yes" xml:space="preserve">
          <source>], is returned.</source>
          <target state="translated">], возвращается.</target>
        </trans-unit>
        <trans-unit id="056353e23af4506e74d7003cb38640abbea6a449" translate="yes" xml:space="preserve">
          <source>]1/2</source>
          <target state="translated">]1/2</target>
        </trans-unit>
        <trans-unit id="2543ff7b78f94174e33e9adeb84f297edc54fffa" translate="yes" xml:space="preserve">
          <source>_1, _2, _3, _4, ...</source>
          <target state="translated">_1, _2, _3, _4, ...</target>
        </trans-unit>
        <trans-unit id="5903c0497b4b6110dd3051a9b31ef948bae78c64" translate="yes" xml:space="preserve">
          <source>_Exit</source>
          <target state="translated">_Exit</target>
        </trans-unit>
        <trans-unit id="a86d3649d1b2b72954d70aa40f94f98858c527ba" translate="yes" xml:space="preserve">
          <source>_IOFBF_IOLBF_IONBF</source>
          <target state="translated">_IOFBF_IOLBF_IONBF</target>
        </trans-unit>
        <trans-unit id="1b22c1d687dc7c54339d14d0aa2284796291aec8" translate="yes" xml:space="preserve">
          <source>__DATE__</source>
          <target state="translated">__DATE__</target>
        </trans-unit>
        <trans-unit id="9d5d8995523b8b8951428baa81ea663ff0bd2c77" translate="yes" xml:space="preserve">
          <source>__FILE__</source>
          <target state="translated">__FILE__</target>
        </trans-unit>
        <trans-unit id="a51b95694c81c92580bff6f580f8e200ecf86661" translate="yes" xml:space="preserve">
          <source>__LINE__</source>
          <target state="translated">__LINE__</target>
        </trans-unit>
        <trans-unit id="ce0bc0efbd8965b4d82a11aa07f4fab94777d3af" translate="yes" xml:space="preserve">
          <source>__STDCPP_DEFAULT_NEW_ALIGNMENT__</source>
          <target state="translated">__STDCPP_DEFAULT_NEW_ALIGNMENT__</target>
        </trans-unit>
        <trans-unit id="db9a3eaebbc58b7b2dff63e6d1078194a02871a4" translate="yes" xml:space="preserve">
          <source>__STDCPP_STRICT_POINTER_SAFETY__</source>
          <target state="translated">__STDCPP_STRICT_POINTER_SAFETY__</target>
        </trans-unit>
        <trans-unit id="950ee9617b60ace35791cfba67c4eda35d86e1d5" translate="yes" xml:space="preserve">
          <source>__STDCPP_THREADS__</source>
          <target state="translated">__STDCPP_THREADS__</target>
        </trans-unit>
        <trans-unit id="51f3c9479afc9737ac0812162dcb10cc18fbbd51" translate="yes" xml:space="preserve">
          <source>__STDC_HOSTED__</source>
          <target state="translated">__STDC_HOSTED__</target>
        </trans-unit>
        <trans-unit id="aa16038a596c275e6fffc69644dbad7ec1a3ceb3" translate="yes" xml:space="preserve">
          <source>__STDC_ISO_10646__</source>
          <target state="translated">__STDC_ISO_10646__</target>
        </trans-unit>
        <trans-unit id="230648d096a182990dad2c93fa8e616a0bed8465" translate="yes" xml:space="preserve">
          <source>__STDC_MB_MIGHT_NEQ_WC__</source>
          <target state="translated">__STDC_MB_MIGHT_NEQ_WC__</target>
        </trans-unit>
        <trans-unit id="aec164fb4da1e304eadad72b50ba5910b1144c03" translate="yes" xml:space="preserve">
          <source>__STDC_UTF_16__</source>
          <target state="translated">__STDC_UTF_16__</target>
        </trans-unit>
        <trans-unit id="92432151980d707704b3ddfa392fde3ab589eb6c" translate="yes" xml:space="preserve">
          <source>__STDC_UTF_32__</source>
          <target state="translated">__STDC_UTF_32__</target>
        </trans-unit>
        <trans-unit id="04202f9ce8c923e1e74ba2bfa78f2696041116d2" translate="yes" xml:space="preserve">
          <source>__STDC_VERSION__</source>
          <target state="translated">__STDC_VERSION__</target>
        </trans-unit>
        <trans-unit id="e7fe05e43de55659e13d860cf51adc28583a4875" translate="yes" xml:space="preserve">
          <source>__STDC__</source>
          <target state="translated">__STDC__</target>
        </trans-unit>
        <trans-unit id="cf716a68ef036dac529946b2640a330f562725fe" translate="yes" xml:space="preserve">
          <source>__TIME__</source>
          <target state="translated">__TIME__</target>
        </trans-unit>
        <trans-unit id="9c3e29639fd2bfaa4db627da53f4d56eac9f0ec0" translate="yes" xml:space="preserve">
          <source>__alignas_is_defined</source>
          <target state="translated">__alignas_is_defined</target>
        </trans-unit>
        <trans-unit id="d950e8ee18472fe83432e8178dd5392fac322513" translate="yes" xml:space="preserve">
          <source>__bool_true_false_are_defined</source>
          <target state="translated">__bool_true_false_are_defined</target>
        </trans-unit>
        <trans-unit id="a6268e3a2fc1725738e330bb09c9305b72ece231" translate="yes" xml:space="preserve">
          <source>__cplusplus</source>
          <target state="translated">__cplusplus</target>
        </trans-unit>
        <trans-unit id="e03702be2b6d9f308bc474cdb111403f31d2ea87" translate="yes" xml:space="preserve">
          <source>__cpp_aggregate_bases</source>
          <target state="translated">__cpp_aggregate_bases</target>
        </trans-unit>
        <trans-unit id="78f7eebcfee8baee7f506621f7ceff180ebb38c2" translate="yes" xml:space="preserve">
          <source>__cpp_aggregate_nsdmi</source>
          <target state="translated">__cpp_aggregate_nsdmi</target>
        </trans-unit>
        <trans-unit id="aecf58d673edcb66d050d3e2e7eba5a0afe4185c" translate="yes" xml:space="preserve">
          <source>__cpp_aggregate_paren_init</source>
          <target state="translated">__cpp_aggregate_paren_init</target>
        </trans-unit>
        <trans-unit id="4db17205b03376efcf08532704df0a94b80ff2e1" translate="yes" xml:space="preserve">
          <source>__cpp_alias_templates</source>
          <target state="translated">__cpp_alias_templates</target>
        </trans-unit>
        <trans-unit id="1b50ffd26242db4d6bb36e8a073d57b42af92dbe" translate="yes" xml:space="preserve">
          <source>__cpp_aligned_new</source>
          <target state="translated">__cpp_aligned_new</target>
        </trans-unit>
        <trans-unit id="27d2797bf877b1368535c5fbc7789bf8e7a43d75" translate="yes" xml:space="preserve">
          <source>__cpp_attributes</source>
          <target state="translated">__cpp_attributes</target>
        </trans-unit>
        <trans-unit id="fa07d30cba0187822a54da7812f67ef73fb0b29b" translate="yes" xml:space="preserve">
          <source>__cpp_binary_literals</source>
          <target state="translated">__cpp_binary_literals</target>
        </trans-unit>
        <trans-unit id="9233221aaacde95fdd55b38eb0f389324843a986" translate="yes" xml:space="preserve">
          <source>__cpp_capture_star_this</source>
          <target state="translated">__cpp_capture_star_this</target>
        </trans-unit>
        <trans-unit id="fbff2a2d3bc0732868b008428dd2e17daf86c9d1" translate="yes" xml:space="preserve">
          <source>__cpp_char8_t</source>
          <target state="translated">__cpp_char8_t</target>
        </trans-unit>
        <trans-unit id="35879cf6edddadc7f07576b594f812ccd01e0e28" translate="yes" xml:space="preserve">
          <source>__cpp_conditional_explicit</source>
          <target state="translated">__cpp_conditional_explicit</target>
        </trans-unit>
        <trans-unit id="6554a18ee88c8522382d28ab36f8ebd7e175fe13" translate="yes" xml:space="preserve">
          <source>__cpp_constexpr</source>
          <target state="translated">__cpp_constexpr</target>
        </trans-unit>
        <trans-unit id="e1c9cd84aa5ce04eef2027ea160ca3290b7ad000" translate="yes" xml:space="preserve">
          <source>__cpp_coroutines</source>
          <target state="translated">__cpp_coroutines</target>
        </trans-unit>
        <trans-unit id="1a2e5b6980d3ec352ab8610b6aebe0331f7c85de" translate="yes" xml:space="preserve">
          <source>__cpp_decltype</source>
          <target state="translated">__cpp_decltype</target>
        </trans-unit>
        <trans-unit id="30e058b311be2115aab20cb7ab797af4bf73322c" translate="yes" xml:space="preserve">
          <source>__cpp_decltype_auto</source>
          <target state="translated">__cpp_decltype_auto</target>
        </trans-unit>
        <trans-unit id="242a749b73f040bf68fa933b9175781fd85d21c1" translate="yes" xml:space="preserve">
          <source>__cpp_deduction_guides</source>
          <target state="translated">__cpp_deduction_guides</target>
        </trans-unit>
        <trans-unit id="3a8bdd7fb017e4f5b12dd8b2fab50c0f9a716657" translate="yes" xml:space="preserve">
          <source>__cpp_delegating_constructors</source>
          <target state="translated">__cpp_delegating_constructors</target>
        </trans-unit>
        <trans-unit id="975250ed39319bc10f0e4f6ba32b904cf175257c" translate="yes" xml:space="preserve">
          <source>__cpp_enumerator_attributes</source>
          <target state="translated">__cpp_enumerator_attributes</target>
        </trans-unit>
        <trans-unit id="3b5c1d2ec9a03cdd0631a101d55a030f176f3d74" translate="yes" xml:space="preserve">
          <source>__cpp_fold_expressions</source>
          <target state="translated">__cpp_fold_expressions</target>
        </trans-unit>
        <trans-unit id="dd54e558a55e90a31a278a30b8a17bd0470a27e5" translate="yes" xml:space="preserve">
          <source>__cpp_generic_lambdas</source>
          <target state="translated">__cpp_generic_lambdas</target>
        </trans-unit>
        <trans-unit id="5851aabfab46bf1cf3f38d2a662260f69f39fefc" translate="yes" xml:space="preserve">
          <source>__cpp_guaranteed_copy_elision</source>
          <target state="translated">__cpp_guaranteed_copy_elision</target>
        </trans-unit>
        <trans-unit id="64dc522012e8e37b94c68ea1e95e711e0d899c02" translate="yes" xml:space="preserve">
          <source>__cpp_hex_float</source>
          <target state="translated">__cpp_hex_float</target>
        </trans-unit>
        <trans-unit id="3817658cc0a09b582191a5b7ff9d3c12fb638b2d" translate="yes" xml:space="preserve">
          <source>__cpp_if_constexpr</source>
          <target state="translated">__cpp_if_constexpr</target>
        </trans-unit>
        <trans-unit id="01e50fa24457c5e9436a8e8e470f75ec87f89e94" translate="yes" xml:space="preserve">
          <source>__cpp_impl_destroying_delete</source>
          <target state="translated">__cpp_impl_destroying_delete</target>
        </trans-unit>
        <trans-unit id="10f562ee8727c9aeeefccee7e22065b234af8837" translate="yes" xml:space="preserve">
          <source>__cpp_impl_three_way_comparison</source>
          <target state="translated">__cpp_impl_three_way_comparison</target>
        </trans-unit>
        <trans-unit id="8372b211ab7aa3d2db5ef6dbe4bf9e84d46edd52" translate="yes" xml:space="preserve">
          <source>__cpp_inheriting_constructors</source>
          <target state="translated">__cpp_inheriting_constructors</target>
        </trans-unit>
        <trans-unit id="8db78a428ed6164ef434f29d445b397d48025bd3" translate="yes" xml:space="preserve">
          <source>__cpp_init_captures</source>
          <target state="translated">__cpp_init_captures</target>
        </trans-unit>
        <trans-unit id="3331bad3edb7735ec64c6916056cfc10590dcf69" translate="yes" xml:space="preserve">
          <source>__cpp_initializer_lists</source>
          <target state="translated">__cpp_initializer_lists</target>
        </trans-unit>
        <trans-unit id="81e37cead058df9398dca1e6d13208a976c4012c" translate="yes" xml:space="preserve">
          <source>__cpp_inline_variables</source>
          <target state="translated">__cpp_inline_variables</target>
        </trans-unit>
        <trans-unit id="3c68286ccf869158575094937b8b2a98ffb48599" translate="yes" xml:space="preserve">
          <source>__cpp_lambdas</source>
          <target state="translated">__cpp_lambdas</target>
        </trans-unit>
        <trans-unit id="2590a0ceb1649ffba013a25521809a21cd1284de" translate="yes" xml:space="preserve">
          <source>__cpp_namespace_attributes</source>
          <target state="translated">__cpp_namespace_attributes</target>
        </trans-unit>
        <trans-unit id="30cc60a82cc1d4477a2e07c1fa7a6a64cc1023c3" translate="yes" xml:space="preserve">
          <source>__cpp_noexcept_function_type</source>
          <target state="translated">__cpp_noexcept_function_type</target>
        </trans-unit>
        <trans-unit id="2593d2642e9db46e71f999b1bc148024d6d0b831" translate="yes" xml:space="preserve">
          <source>__cpp_nontype_template_args</source>
          <target state="translated">__cpp_nontype_template_args</target>
        </trans-unit>
        <trans-unit id="1892415e299d418abcb2ce3608af04f19ac199e1" translate="yes" xml:space="preserve">
          <source>__cpp_nontype_template_parameter_auto</source>
          <target state="translated">__cpp_nontype_template_parameter_auto</target>
        </trans-unit>
        <trans-unit id="8e2497a317030abf3388ed8fcdc0f581460fd74b" translate="yes" xml:space="preserve">
          <source>__cpp_nontype_template_parameter_class</source>
          <target state="translated">__cpp_nontype_template_parameter_class</target>
        </trans-unit>
        <trans-unit id="6f298ec98a281e895e57730ee42e4b685bf1d6e1" translate="yes" xml:space="preserve">
          <source>__cpp_nsdmi</source>
          <target state="translated">__cpp_nsdmi</target>
        </trans-unit>
        <trans-unit id="7844fe22ff8583f864600cf24c8acf071a07a268" translate="yes" xml:space="preserve">
          <source>__cpp_range_based_for</source>
          <target state="translated">__cpp_range_based_for</target>
        </trans-unit>
        <trans-unit id="e94a403428d4ea97b6f263dbcb0874c541f05fc8" translate="yes" xml:space="preserve">
          <source>__cpp_raw_strings</source>
          <target state="translated">__cpp_raw_strings</target>
        </trans-unit>
        <trans-unit id="2a807128a5985f4aedc323c209f0b26cf031ddc5" translate="yes" xml:space="preserve">
          <source>__cpp_ref_qualifiers</source>
          <target state="translated">__cpp_ref_qualifiers</target>
        </trans-unit>
        <trans-unit id="ec7f8108d8bd7c3189219118c4b92ebae110f376" translate="yes" xml:space="preserve">
          <source>__cpp_return_type_deduction</source>
          <target state="translated">__cpp_return_type_deduction</target>
        </trans-unit>
        <trans-unit id="a27448bb794e05840712bcbb343a4cbf12fadae2" translate="yes" xml:space="preserve">
          <source>__cpp_rvalue_references</source>
          <target state="translated">__cpp_rvalue_references</target>
        </trans-unit>
        <trans-unit id="28d6e14e6e0b8b130a165866cca9649aa7e9d864" translate="yes" xml:space="preserve">
          <source>__cpp_sized_deallocation</source>
          <target state="translated">__cpp_sized_deallocation</target>
        </trans-unit>
        <trans-unit id="d77473f1a619fc342dfc9123063a318297214d20" translate="yes" xml:space="preserve">
          <source>__cpp_static_assert</source>
          <target state="translated">__cpp_static_assert</target>
        </trans-unit>
        <trans-unit id="af80adf8b09bcfceb7e7134decd3d99ebd88c373" translate="yes" xml:space="preserve">
          <source>__cpp_structured_bindings</source>
          <target state="translated">__cpp_structured_bindings</target>
        </trans-unit>
        <trans-unit id="5456a2323fecac083d969b4421be5b3b5e785149" translate="yes" xml:space="preserve">
          <source>__cpp_template_template_args</source>
          <target state="translated">__cpp_template_template_args</target>
        </trans-unit>
        <trans-unit id="ddc5e77386a83826283ed12a4b5d3455f2275f1a" translate="yes" xml:space="preserve">
          <source>__cpp_threadsafe_static_init</source>
          <target state="translated">__cpp_threadsafe_static_init</target>
        </trans-unit>
        <trans-unit id="a51600d8c1a1f10a16f1e43b746d8821a1ba5bff" translate="yes" xml:space="preserve">
          <source>__cpp_unicode_characters</source>
          <target state="translated">__cpp_unicode_characters</target>
        </trans-unit>
        <trans-unit id="696ac6453d6507dd7871ba65e03fe52e19383ef5" translate="yes" xml:space="preserve">
          <source>__cpp_unicode_literals</source>
          <target state="translated">__cpp_unicode_literals</target>
        </trans-unit>
        <trans-unit id="fcfb6a809b1f0636cfdcac8dcaf0a56faf741fe9" translate="yes" xml:space="preserve">
          <source>__cpp_user_defined_literals</source>
          <target state="translated">__cpp_user_defined_literals</target>
        </trans-unit>
        <trans-unit id="793fd52dc655ccacc0d8fa1b3bf368e5266577b4" translate="yes" xml:space="preserve">
          <source>__cpp_variable_templates</source>
          <target state="translated">__cpp_variable_templates</target>
        </trans-unit>
        <trans-unit id="b2c1a1181d35bf405e3ead748a7662168e324024" translate="yes" xml:space="preserve">
          <source>__cpp_variadic_templates</source>
          <target state="translated">__cpp_variadic_templates</target>
        </trans-unit>
        <trans-unit id="423eb61df1fcdbb8fb8c6511db90aa6fb0318eaf" translate="yes" xml:space="preserve">
          <source>__cpp_variadic_using</source>
          <target state="translated">__cpp_variadic_using</target>
        </trans-unit>
        <trans-unit id="d8db95cc58ad2925bc93429910aec8cf2d80ad01" translate="yes" xml:space="preserve">
          <source>__func__</source>
          <target state="translated">__func__</target>
        </trans-unit>
        <trans-unit id="86f7e437faa5a7fce15d1ddcb9eaeaea377667b8" translate="yes" xml:space="preserve">
          <source>a</source>
          <target state="translated">a</target>
        </trans-unit>
        <trans-unit id="d66612ccc3a3c60bbf9be396b2e583b9ad6f732e" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;../../language/dynamic_cast&quot;&gt;&lt;code&gt;dynamic_cast&lt;/code&gt;&lt;/a&gt; expression</source>
          <target state="translated">&lt;a href=&quot;../../language/dynamic_cast&quot;&gt; &lt;code&gt;dynamic_cast&lt;/code&gt; &lt;/a&gt; выражение</target>
        </trans-unit>
        <trans-unit id="578b0d09cf884cabb2256541be565e3232f4a2d1" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;../../language/throw&quot;&gt;&lt;code&gt;throw&lt;/code&gt;&lt;/a&gt; expression</source>
          <target state="translated">&lt;a href=&quot;../../language/throw&quot;&gt; &lt;code&gt;throw&lt;/code&gt; &lt;/a&gt; выражение</target>
        </trans-unit>
        <trans-unit id="0c35fd85853bd90c9dea0e943c9e3e345e596a8c" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;../../named_req/callable&quot;&gt;Callable&lt;/a&gt; that accepts every possible alternative from every variant</source>
          <target state="translated">&lt;a href=&quot;../../named_req/callable&quot;&gt;Callable&lt;/a&gt; , который принимает все возможные альтернативы , от каждого варианта</target>
        </trans-unit>
        <trans-unit id="0f547d6f47fe102ed4af5089aaf331e46cb4bd5e" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;../language/lambda&quot;&gt;closure&lt;/a&gt; type</source>
          <target state="translated">&lt;a href=&quot;../language/lambda&quot;&gt;замыкание&lt;/a&gt; типа</target>
        </trans-unit>
        <trans-unit id="e0406f8e858cd057dce3f1a1bd186c9b49e3cd51" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;../language/operator_member_access#Built-in_member_access_operators&quot;&gt;pseudo-destructor call&lt;/a&gt; (if &lt;code&gt;It&lt;/code&gt; is a scalar type)</source>
          <target state="translated">&lt;a href=&quot;../language/operator_member_access#Built-in_member_access_operators&quot;&gt;псевдо-деструктор вызов&lt;/a&gt; (если &lt;code&gt;It&lt;/code&gt; представляет собой тип скаляр)</target>
        </trans-unit>
        <trans-unit id="2f2aa4051bfd7ae365b4f4b11cedb58bbfd66b3e" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;../named_req/uniformrandombitgenerator&quot;&gt;UniformRandomBitGenerator&lt;/a&gt; whose result type is convertible to &lt;code&gt;&lt;a href=&quot;../iterator/iterator_traits&quot;&gt;std::iterator_traits&lt;/a&gt;&amp;lt;RandomIt&amp;gt;::difference_type&lt;/code&gt;</source>
          <target state="translated">&lt;a href=&quot;../named_req/uniformrandombitgenerator&quot;&gt;UniformRandomBitGenerator&lt;/a&gt; , результат типа конвертируется в &lt;code&gt;&lt;a href=&quot;../iterator/iterator_traits&quot;&gt;std::iterator_traits&lt;/a&gt;&amp;lt;RandomIt&amp;gt;::difference_type&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3f35df8d2006030e7d4d979822b8a81b4761ea9f" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;../ranges/view&quot;&gt;&lt;code&gt;View&lt;/code&gt;&lt;/a&gt; consisting of a sequence generated by repeatedly incrementing an initial value</source>
          <target state="translated">&lt;a href=&quot;../ranges/view&quot;&gt; &lt;code&gt;View&lt;/code&gt; &lt;/a&gt; , состоящий из последовательности , сформированной путем многократного приращения начального значения</target>
        </trans-unit>
        <trans-unit id="f1b66b4d9a0ae57bf6f377005ad0ae6842f473ed" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;../ranges/view&quot;&gt;&lt;code&gt;View&lt;/code&gt;&lt;/a&gt; consisting of the first N elements of another &lt;a href=&quot;../ranges/view&quot;&gt;&lt;code&gt;View&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;../ranges/view&quot;&gt; &lt;code&gt;View&lt;/code&gt; &lt;/a&gt; , состоящий из первых N элементов другого &lt;a href=&quot;../ranges/view&quot;&gt; &lt;code&gt;View&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ae981f6c70dcb78f089b85eeb651ce9e721b682b" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;../ranges/view&quot;&gt;&lt;code&gt;View&lt;/code&gt;&lt;/a&gt; consisting of the sequence obtained from flattening a &lt;a href=&quot;../ranges/view&quot;&gt;&lt;code&gt;View&lt;/code&gt;&lt;/a&gt; of &lt;a href=&quot;../ranges/range&quot;&gt;&lt;code&gt;Range&lt;/code&gt;s&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;../ranges/view&quot;&gt; &lt;code&gt;View&lt;/code&gt; &lt;/a&gt; , состоящий из последовательности , полученной из выпрямления &lt;a href=&quot;../ranges/view&quot;&gt; &lt;code&gt;View&lt;/code&gt; &lt;/a&gt; из &lt;a href=&quot;../ranges/range&quot;&gt; &lt;code&gt;Range&lt;/code&gt; s&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e20442d4936a5775a6caf427d491901e50216ebf" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;../ranges/view&quot;&gt;&lt;code&gt;View&lt;/code&gt;&lt;/a&gt; of a sequence that applies a transformation function to each element</source>
          <target state="translated">&lt;a href=&quot;../ranges/view&quot;&gt; &lt;code&gt;View&lt;/code&gt; &lt;/a&gt; последовательности , которая применяет функцию преобразования к каждому элементу</target>
        </trans-unit>
        <trans-unit id="289a5f74d80c8aa744c90c4ee3868ed8609c9f49" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;../ranges/view&quot;&gt;&lt;code&gt;View&lt;/code&gt;&lt;/a&gt; of the elements of some other &lt;a href=&quot;../ranges/range&quot;&gt;&lt;code&gt;Range&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;../ranges/view&quot;&gt; &lt;code&gt;View&lt;/code&gt; &lt;/a&gt; из элементов некоторого другого &lt;a href=&quot;../ranges/range&quot;&gt; &lt;code&gt;Range&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a94750304f2970083f4213aac2cf32daebafda1d" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;../ranges/view&quot;&gt;&lt;code&gt;View&lt;/code&gt;&lt;/a&gt; over the subranges obtained from splitting another &lt;a href=&quot;../ranges/view&quot;&gt;&lt;code&gt;View&lt;/code&gt;&lt;/a&gt; using a delimiter</source>
          <target state="translated">a. &lt;a href=&quot;../ranges/view&quot;&gt; &lt;code&gt;View&lt;/code&gt; &lt;/a&gt; на поддиапазоны, полученный при разбиении другого &lt;a href=&quot;../ranges/view&quot;&gt; &lt;code&gt;View&lt;/code&gt; &lt;/a&gt; с использованием разделителя.</target>
        </trans-unit>
        <trans-unit id="3a4653cdeeb9369cc880c44c330b4bacc547ec37" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;../ranges/view&quot;&gt;&lt;code&gt;View&lt;/code&gt;&lt;/a&gt; that consists of the elements of a &lt;a href=&quot;../ranges/range&quot;&gt;&lt;code&gt;Range&lt;/code&gt;&lt;/a&gt; that satisfies a predicate</source>
          <target state="translated">&lt;a href=&quot;../ranges/view&quot;&gt; &lt;code&gt;View&lt;/code&gt; &lt;/a&gt; , который состоит из элементов &lt;a href=&quot;../ranges/range&quot;&gt; &lt;code&gt;Range&lt;/code&gt; &lt;/a&gt; , который удовлетворяет предикатный</target>
        </trans-unit>
        <trans-unit id="6c2fbed5ca96d4b2858696b97f8e59367cd9ca66" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;../ranges/view&quot;&gt;&lt;code&gt;View&lt;/code&gt;&lt;/a&gt; that contains a single element of a specified value</source>
          <target state="translated">&lt;a href=&quot;../ranges/view&quot;&gt; &lt;code&gt;View&lt;/code&gt; &lt;/a&gt; , который содержит один элемент заданного значения</target>
        </trans-unit>
        <trans-unit id="c7f3a3db304dcf5be7bc978bb2552c12c8bc06fb" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;../ranges/view&quot;&gt;&lt;code&gt;View&lt;/code&gt;&lt;/a&gt; that includes all elements of a &lt;a href=&quot;../ranges/range&quot;&gt;&lt;code&gt;Range&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;../ranges/view&quot;&gt; &lt;code&gt;View&lt;/code&gt; &lt;/a&gt; , который включает в себя все элементы &lt;a href=&quot;../ranges/range&quot;&gt; &lt;code&gt;Range&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="af11d84750e4dccfceeeab50c1f40114755c03a1" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;../ranges/view&quot;&gt;&lt;code&gt;View&lt;/code&gt;&lt;/a&gt; that iterates over the elements of another bidirectional view in reverse order</source>
          <target state="translated">&lt;a href=&quot;../ranges/view&quot;&gt; &lt;code&gt;View&lt;/code&gt; &lt;/a&gt; , который перебирает элементы другого двунаправленного зрения в обратном порядке</target>
        </trans-unit>
        <trans-unit id="e8c8ad0f2aa5b2688c79e49a80f74556ff5bb1c3" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;../types/is_scalar&quot;&gt;scalar type&lt;/a&gt;;</source>
          <target state="translated">&lt;a href=&quot;../types/is_scalar&quot;&gt;скалярный тип&lt;/a&gt; ;</target>
        </trans-unit>
        <trans-unit id="c5f1f7ebf1a60286c3263705f1ff2699892ba31a" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;binarypredicate&quot;&gt;BinaryPredicate&lt;/a&gt; that establishes an ordering relation</source>
          <target state="translated">&lt;a href=&quot;binarypredicate&quot;&gt;BinaryPredicate&lt;/a&gt; , что устанавливает отношение порядка</target>
        </trans-unit>
        <trans-unit id="b54276a912036a81a33307973d33e286dfbef1ac" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;bit_field&quot;&gt;&lt;i&gt;bit field&lt;/i&gt;&lt;/a&gt; type can be converted to &lt;code&gt;int&lt;/code&gt; if it can represent entire value range of the bit field, otherwise to &lt;code&gt;unsigned int&lt;/code&gt; if it can represent entire value range of the bit field, otherwise no integral promotions apply;</source>
          <target state="translated">&lt;a href=&quot;bit_field&quot;&gt;&lt;i&gt;битовое поле&lt;/i&gt;&lt;/a&gt; типа может быть преобразован в &lt;code&gt;int&lt;/code&gt; , если он может представлять весь диапазон значений битового поля, в противном случае &lt;code&gt;unsigned int&lt;/code&gt; , если он может представлять весь диапазон значений битового поля, в противном случае не интегральные акции не применяется;</target>
        </trans-unit>
        <trans-unit id="04be27008e83afb2d331f92d72c2fab2182c7c06" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;cast_operator&quot;&gt;user-defined conversion function&lt;/a&gt; name, such as &lt;code&gt;operator bool&lt;/code&gt;;</source>
          <target state="translated">определяемое &lt;a href=&quot;cast_operator&quot;&gt;пользователем&lt;/a&gt; имя функции преобразования , такое как &lt;code&gt;operator bool&lt;/code&gt; ;</target>
        </trans-unit>
        <trans-unit id="842b9bb73f31c7a70a7a8e8933647e7f312f7d30" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;class&quot;&gt;class declaration&lt;/a&gt;. The class name declared becomes a template name.</source>
          <target state="translated">&lt;a href=&quot;class&quot;&gt;объявление класса&lt;/a&gt; . Объявленное имя класса становится именем шаблона.</target>
        </trans-unit>
        <trans-unit id="58329cef5c48b9dd6d75ade29a0076bc7230f05a" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;class#Member_specification&quot;&gt;class member declaration&lt;/a&gt;;</source>
          <target state="translated">&lt;a href=&quot;class#Member_specification&quot;&gt;заявление члена класса&lt;/a&gt; ;</target>
        </trans-unit>
        <trans-unit id="197dcdb99acb57525f9c2a6fe89a245471fd8142" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;constant_expression#Converted_constant_expression&quot;&gt;contextually converted constant expression of type &lt;code&gt;bool&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;constant_expression#Converted_constant_expression&quot;&gt;контекстуально преобразованное постоянное выражение типа &lt;code&gt;bool&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b40006546d705539bc635f3175ea4d35431ac2da" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;constraints&quot;&gt;constraint expression&lt;/a&gt; which restricts the template parameters accepted by this function template</source>
          <target state="translated">&lt;a href=&quot;constraints&quot;&gt;выражение ограничения&lt;/a&gt; , которое ограничивает параметры шаблона , принятые этот шаблон функции</target>
        </trans-unit>
        <trans-unit id="dbc4d6e8690db53ad192b32cd88e3433f51c72d3" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;constraints&quot;&gt;requires-expression&lt;/a&gt;, such as &lt;code&gt;requires (T i) { typename T::type; }&lt;/code&gt;;</source>
          <target state="translated">&lt;a href=&quot;constraints&quot;&gt;требует-выражения&lt;/a&gt; , такие , как &lt;code&gt;requires (T i) { typename T::type; }&lt;/code&gt; ;</target>
        </trans-unit>
        <trans-unit id="6a7178c89e852f09b520cb3d8d0a0704888c1d34" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;constraints#Concepts&quot;&gt;concept&lt;/a&gt; name, optionally qualified, optionally followed by a template argument list enclosed in &amp;lt;&amp;gt;</source>
          <target state="translated">&lt;a href=&quot;constraints#Concepts&quot;&gt;концепция&lt;/a&gt; имя, необязательно квалифицированный, необязательно с последующим списком аргументов шаблона , заключенным в &amp;lt;&amp;gt;</target>
        </trans-unit>
        <trans-unit id="e54b0edc591fc30ea27121f4b241249a88d6dd05" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;declarations&quot;&gt;declaration&lt;/a&gt; of a named variable, whose type is the type of the element of the sequence represented by range_expression, or a reference to that type. Often uses the &lt;a href=&quot;auto&quot;&gt;auto specifier&lt;/a&gt; for automatic type deduction</source>
          <target state="translated">&lt;a href=&quot;declarations&quot;&gt;декларация&lt;/a&gt; именованного переменный, тип которого является типом элемента последовательности , представленной range_expression, или ссылка на этот тип. Часто использует &lt;a href=&quot;auto&quot;&gt;автоматический спецификатор&lt;/a&gt; для автоматического вывода типа</target>
        </trans-unit>
        <trans-unit id="feba1f8215a9e5044f736d79557f6d6af77814ce" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;declarations&quot;&gt;declaration&lt;/a&gt; of a single variable with a brace-or-equals &lt;a href=&quot;initialization&quot;&gt;initializer&lt;/a&gt;. the initializer is evaluated before each iteration, and if the value of the declared variable converts to &lt;code&gt;false&lt;/code&gt;, the loop is exited.</source>
          <target state="translated">&lt;a href=&quot;declarations&quot;&gt;заявление&lt;/a&gt; одной переменной с фигурной скобкой или-равно &lt;a href=&quot;initialization&quot;&gt;инициализатор&lt;/a&gt; . инициализатор вычисляется перед каждой итерацией, и если значение объявленной переменной преобразуется в &lt;code&gt;false&lt;/code&gt; , цикл завершается.</target>
        </trans-unit>
        <trans-unit id="9b8e7399060c9f5d9013f6aa031f2daeaf247245" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;declarations&quot;&gt;declaration&lt;/a&gt; of a variable. The declared variable name becomes a template name.</source>
          <target state="translated">&lt;a href=&quot;declarations&quot;&gt;объявление&lt;/a&gt; переменной. Объявленное имя переменной становится именем шаблона.</target>
        </trans-unit>
        <trans-unit id="0d19b02053245fd658744be05acb66f6795dfec5" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;declarations&quot;&gt;simple declaration&lt;/a&gt;, typically a declaration of a loop counter variable with initializer, but it may declare arbitrary many variables</source>
          <target state="translated">&lt;a href=&quot;declarations&quot;&gt;простая декларация&lt;/a&gt; , как правило , декларация счетчик цикла переменного с инициализатором, но он может объявить произвольные много переменных</target>
        </trans-unit>
        <trans-unit id="c20d095ecceecc0d92c5b636f980edf3d560c27f" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;declarations&quot;&gt;simple declaration&lt;/a&gt;, typically a declaration of a variable with initializer, but it may declare arbitrary many variables or be a &lt;a href=&quot;structured_binding&quot;&gt;structured binding declaration&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;declarations&quot;&gt;простая декларация&lt;/a&gt; , как правило , декларация переменного с инициализатором, но он может объявить произвольные много переменных или быть &lt;a href=&quot;structured_binding&quot;&gt;структурирована декларацией связывания&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c035c17095b570541b804043bd0d5c99497e6655" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;declarations&quot;&gt;simple declaration&lt;/a&gt;, typically a declaration of a variable with initializer, but it may declare arbitrary many variables or be a decomposition declaration</source>
          <target state="translated">&lt;a href=&quot;declarations&quot;&gt;простая декларация&lt;/a&gt; , как правило , декларация переменного с инициализатором, но он может объявить произвольные много переменных или быть декларацией разложения</target>
        </trans-unit>
        <trans-unit id="4b734860e87e75b35551beb9fadebdf9940d0be6" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;declarations&quot;&gt;simple declaration&lt;/a&gt;, typically a declaration of a variable with initializer, but it may declare arbitrary many variables or structured bindings</source>
          <target state="translated">&lt;a href=&quot;declarations&quot;&gt;простая декларация&lt;/a&gt; , как правило , декларация переменного с инициализатором, но он может объявить произвольные много переменных или структурированные привязки</target>
        </trans-unit>
        <trans-unit id="2201d89e3d55486c60323b0565f06038ff02c6ab" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;declarations#Simple_declaration&quot;&gt;simple declaration&lt;/a&gt; or &lt;a href=&quot;function#Function_definition&quot;&gt;function definition&lt;/a&gt; at namespace scope;</source>
          <target state="translated">&lt;a href=&quot;declarations#Simple_declaration&quot;&gt;простое объявление&lt;/a&gt; или &lt;a href=&quot;function#Function_definition&quot;&gt;определение функции&lt;/a&gt; в области видимости пространства имен;</target>
        </trans-unit>
        <trans-unit id="c8bcda74ea89e3702ab08c50656a296f15b010fd" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;expressions#Literals&quot;&gt;literal&lt;/a&gt; (except for &lt;a href=&quot;string_literal&quot;&gt;string literal&lt;/a&gt;), such as &lt;code&gt;42&lt;/code&gt;, &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;nullptr&lt;/code&gt;;</source>
          <target state="translated">&lt;a href=&quot;expressions#Literals&quot;&gt;буквальный&lt;/a&gt; (за исключением &lt;a href=&quot;string_literal&quot;&gt;строкового литерала&lt;/a&gt; ), такие как &lt;code&gt;42&lt;/code&gt; , &lt;code&gt;true&lt;/code&gt; или &lt;code&gt;nullptr&lt;/code&gt; ;</target>
        </trans-unit>
        <trans-unit id="8446974ce0d221e5eb27350acb15252dd76acf23" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;expressions#Primary_expressions&quot;&gt;primary expression&lt;/a&gt;, e.g. &lt;code&gt;&lt;a href=&quot;../concepts/swappable&quot;&gt;Swappable&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../types/is_integral&quot;&gt;std::is_integral&lt;/a&gt;&amp;lt;T&amp;gt;::value&lt;/code&gt;, &lt;code&gt;(&lt;a href=&quot;../types/is_object&quot;&gt;std::is_object_v&lt;/a&gt;&amp;lt;Args&amp;gt; &amp;amp;&amp;amp; ...)&lt;/code&gt;, or any parenthesized expression</source>
          <target state="translated">&lt;a href=&quot;expressions#Primary_expressions&quot;&gt;первичное выражение&lt;/a&gt; , например &lt;code&gt;&lt;a href=&quot;../concepts/swappable&quot;&gt;Swappable&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../types/is_integral&quot;&gt;std::is_integral&lt;/a&gt;&amp;lt;T&amp;gt;::value&lt;/code&gt; , &lt;code&gt;(&lt;a href=&quot;../types/is_object&quot;&gt;std::is_object_v&lt;/a&gt;&amp;lt;Args&amp;gt; &amp;amp;&amp;amp; ...)&lt;/code&gt; , или любое выражение в скобках</target>
        </trans-unit>
        <trans-unit id="500e95ea5cc0ecd68e30742d9d61e3323034d850" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;function&quot;&gt;function declaration&lt;/a&gt; where the type of at least one parameter uses the placeholder &lt;a href=&quot;auto&quot;&gt;auto&lt;/a&gt; or &lt;code&gt;Concept auto&lt;/code&gt;: the template parameter list will have one invented parameter for each placeholder (see Abbreviated function templates below</source>
          <target state="translated">&lt;a href=&quot;function&quot;&gt;объявление функции&lt;/a&gt; , когда тип по меньшей мере , одного параметра используется заполнитель &lt;a href=&quot;auto&quot;&gt;авто&lt;/a&gt; или &lt;code&gt;Concept auto&lt;/code&gt; : список параметров шаблона будет иметь один изобретенный параметр для каждого заполнителя (см сокращенных шаблонов функций ниже</target>
        </trans-unit>
        <trans-unit id="cf8f5a052390f7a051f82e9f9d21d32ee1c4a82a" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;function&quot;&gt;function declaration&lt;/a&gt;. The function name declared becomes a template name.</source>
          <target state="translated">&lt;a href=&quot;function&quot;&gt;объявление функции&lt;/a&gt; . Объявленное имя функции становится именем шаблона.</target>
        </trans-unit>
        <trans-unit id="c2f7755c6029f6a2726cac9e6db3c67772cad590" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;function&quot;&gt;trailing return type&lt;/a&gt;,</source>
          <target state="translated">&lt;a href=&quot;function&quot;&gt;тип возвращаемого трейлинг&lt;/a&gt; ,</target>
        </trans-unit>
        <trans-unit id="7edca23af0f84105b599f5a7b5d639d2bc955bbd" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;function#Parameter_list&quot;&gt;parameter declaration&lt;/a&gt; in a &lt;a href=&quot;class#Member_specification&quot;&gt;class member declaration&lt;/a&gt; (including friend function declarations), outside of default arguments;</source>
          <target state="translated">&lt;a href=&quot;function#Parameter_list&quot;&gt;объявление параметра&lt;/a&gt; в &lt;a href=&quot;class#Member_specification&quot;&gt;объявлении члена класса&lt;/a&gt; ( в том числе друга функции деклараций), за пределами аргументов по умолчанию;</target>
        </trans-unit>
        <trans-unit id="c118f25111af636da74b78a8eacfb1f5f20cd6c6" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;function#Parameter_list&quot;&gt;parameter declaration&lt;/a&gt; of a &lt;a href=&quot;function&quot;&gt;declarator for a function or function template&lt;/a&gt; whose name is qualified, outside of default arguments;</source>
          <target state="translated">&lt;a href=&quot;function#Parameter_list&quot;&gt;параметр декларация&lt;/a&gt; о &lt;a href=&quot;function&quot;&gt;описателе для шаблона функции или функции&lt;/a&gt; , чье имя квалифицировано, вне аргументов по умолчанию;</target>
        </trans-unit>
        <trans-unit id="f1184f488a359d5c1d1504b481c38dad94714e6b" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;function#Parameter_list&quot;&gt;parameter declaration&lt;/a&gt; of a &lt;a href=&quot;lambda&quot;&gt;lambda expression&lt;/a&gt; outside of default arguments;</source>
          <target state="translated">&lt;a href=&quot;function#Parameter_list&quot;&gt;параметр декларации&lt;/a&gt; о &lt;a href=&quot;lambda&quot;&gt;лямбда - выражения&lt;/a&gt; внешней аргументов по умолчанию;</target>
        </trans-unit>
        <trans-unit id="642baf6869f125ceaec67c589e398539c6e7f6ed" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;goto&quot;&gt;goto&lt;/a&gt; statement</source>
          <target state="translated">&lt;a href=&quot;goto&quot;&gt;Гото&lt;/a&gt; заявление</target>
        </trans-unit>
        <trans-unit id="c907e534b1c94f336b7e2cf57a58189deb97fe5d" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;implicit_cast&quot;&gt;standard conversion&lt;/a&gt;, &lt;a href=&quot;dynamic_cast&quot;&gt;dynamic_cast&lt;/a&gt;, or &lt;a href=&quot;static_cast&quot;&gt;static_cast&lt;/a&gt; to type &lt;code&gt;T*&lt;/code&gt; or &lt;code&gt;T&amp;amp;&lt;/code&gt;, except when converting from the &lt;a href=&quot;../types/null&quot;&gt;null pointer constant&lt;/a&gt; or from a &lt;a href=&quot;pointer#Pointers_to_void&quot;&gt;pointer to void&lt;/a&gt;;</source>
          <target state="translated">&lt;a href=&quot;implicit_cast&quot;&gt;стандартное преобразование&lt;/a&gt; , &lt;a href=&quot;dynamic_cast&quot;&gt;dynamic_cast&lt;/a&gt; или &lt;a href=&quot;static_cast&quot;&gt;static_cast&lt;/a&gt; к типу &lt;code&gt;T*&lt;/code&gt; или &lt;code&gt;T&amp;amp;&lt;/code&gt; , за исключением того, при преобразовании из &lt;a href=&quot;../types/null&quot;&gt;постоянной указателя NULL&lt;/a&gt; или из &lt;a href=&quot;pointer#Pointers_to_void&quot;&gt;указателя недействительными&lt;/a&gt; ;</target>
        </trans-unit>
        <trans-unit id="ff7412a5c700e7e775fdf95f63af3f717686860b" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;implicit_cast#Function_pointer_conversions&quot;&gt;function pointer conversion&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;implicit_cast#Function_pointer_conversions&quot;&gt;преобразование указателя на функцию&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="dd862ebece74d9a647884bc1f7ae05595e84d3dd" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;implicit_cast#Qualification_conversions&quot;&gt;qualification conversion&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;implicit_cast#Qualification_conversions&quot;&gt;квалификация преобразования&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="78294718f1c4d725f8f92854d2e7408626ebcedd" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;lambda&quot;&gt;lambda expression&lt;/a&gt;, such as &lt;code&gt;[](int x){ return x * x; }&lt;/code&gt;;</source>
          <target state="translated">&lt;a href=&quot;lambda&quot;&gt;лямбда - выражение&lt;/a&gt; , например, &lt;code&gt;[](int x){ return x * x; }&lt;/code&gt; ;</target>
        </trans-unit>
        <trans-unit id="84b39eaf4ad707d4a4dec485e938308dab148b12" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;name#Qualified_identifiers&quot;&gt;sequence of names and scope resolution operators &lt;code&gt;::&lt;/code&gt; &lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;name#Qualified_identifiers&quot;&gt;последовательность имен и операторов разрешения области видимости &lt;code&gt;::&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="0b9cefe53156bc46a61aba49ceb2bcf93ec727d8" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;named_req/basiclockable&quot;&gt;BasicLockable&lt;/a&gt; that supports attempted lock acquisition</source>
          <target state="translated">&lt;a href=&quot;named_req/basiclockable&quot;&gt;BasicLockable&lt;/a&gt; , который поддерживает попытку приобретения блокировки</target>
        </trans-unit>
        <trans-unit id="b2e74295624d6557dcdd2cc01e3b042f422a51a5" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;named_req/binarypredicate&quot;&gt;BinaryPredicate&lt;/a&gt; that establishes an ordering relation</source>
          <target state="translated">&lt;a href=&quot;named_req/binarypredicate&quot;&gt;BinaryPredicate&lt;/a&gt; , что устанавливает отношение порядка</target>
        </trans-unit>
        <trans-unit id="c9fc14a958079406695f087786e7323e37febb5f" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;named_req/clock&quot;&gt;Clock&lt;/a&gt; that does not throw exceptions</source>
          <target state="translated">&lt;a href=&quot;named_req/clock&quot;&gt;часы&lt;/a&gt; , не бросать исключения</target>
        </trans-unit>
        <trans-unit id="a8f9bb45156d6a61bb73c330f242efbcd3e0fcea" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;named_req/functionobject&quot;&gt;FunctionObject&lt;/a&gt; that for inputs with different values has a low probability of giving the same output</source>
          <target state="translated">&lt;a href=&quot;named_req/functionobject&quot;&gt;функциональный объект&lt;/a&gt; , что для входов с различными значениями имеют низкую вероятность дает тот же результат</target>
        </trans-unit>
        <trans-unit id="ea59a46b0fa1e2f0e7670029ccdde75669c8d886" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;named_req/functionobject&quot;&gt;FunctionObject&lt;/a&gt; that returns a value convertible to &lt;code&gt;bool&lt;/code&gt; for one argument without modifying it</source>
          <target state="translated">&lt;a href=&quot;named_req/functionobject&quot;&gt;функциональный объект&lt;/a&gt; , который возвращает значение , конвертируемые в &lt;code&gt;bool&lt;/code&gt; для одного аргумента , не изменяя его</target>
        </trans-unit>
        <trans-unit id="b54d733aca75c1dec32ecb63027a79406e738ca0" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;named_req/functionobject&quot;&gt;FunctionObject&lt;/a&gt; that returns a value convertible to &lt;code&gt;bool&lt;/code&gt; for two arguments without modifying them</source>
          <target state="translated">&lt;a href=&quot;named_req/functionobject&quot;&gt;функциональный объект&lt;/a&gt; , который возвращает значение конвертируется в &lt;code&gt;bool&lt;/code&gt; для двух аргументов , не изменяя их</target>
        </trans-unit>
        <trans-unit id="60356dec3126ca424603f3524c2c59c0f4d0e0b3" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;named_req/lockable&quot;&gt;Lockable&lt;/a&gt; that protects against data races and sequentially consistent synchronization</source>
          <target state="translated">&lt;a href=&quot;named_req/lockable&quot;&gt;Блокируемый&lt;/a&gt; , который защищает от гонок данных и последовательно последовательной синхронизации</target>
        </trans-unit>
        <trans-unit id="78a14075ec6e560d582c534d1ea3a8368ec01c15" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;named_req/lockable&quot;&gt;Lockable&lt;/a&gt; that supports timed lock acquisition</source>
          <target state="translated">&lt;a href=&quot;named_req/lockable&quot;&gt;Lockable&lt;/a&gt; что поддерживает приуроченное приобретение замка</target>
        </trans-unit>
        <trans-unit id="2420df90cbe1b6e70248694fed79e630531d3b06" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;named_req/mutex&quot;&gt;Mutex&lt;/a&gt; that supports shared ownership semantics</source>
          <target state="translated">&lt;a href=&quot;named_req/mutex&quot;&gt;мьютекс&lt;/a&gt; , который поддерживает долевую собственность семантику</target>
        </trans-unit>
        <trans-unit id="79e44acb7900ed6728581d5d8a9042f7e17f14c3" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;named_req/randomnumberengine&quot;&gt;RandomNumberEngine&lt;/a&gt; that transforms the output of another &lt;a href=&quot;named_req/randomnumberengine&quot;&gt;RandomNumberEngine&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;named_req/randomnumberengine&quot;&gt;RandomNumberEngine&lt;/a&gt; , который преобразует выходной сигнал другого &lt;a href=&quot;named_req/randomnumberengine&quot;&gt;RandomNumberEngine&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e17ffa05e7a19b50f16c2ab3c2e4a41b726df14f" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;named_req/timedlockable&quot;&gt;TimedLockable&lt;/a&gt; that protects against data races and sequentially consistent synchronization</source>
          <target state="translated">&lt;a href=&quot;named_req/timedlockable&quot;&gt;TimedLockable&lt;/a&gt; , который защищает от гонок данных и последовательно последовательной синхронизации</target>
        </trans-unit>
        <trans-unit id="782471ed828c26fe873bde60284584c9dc102f92" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;named_req/timedmutex&quot;&gt;TimedMutex&lt;/a&gt; that supports shared ownership semantics</source>
          <target state="translated">&lt;a href=&quot;named_req/timedmutex&quot;&gt;TimedMutex&lt;/a&gt; , который поддерживает долевую собственность семантику</target>
        </trans-unit>
        <trans-unit id="7d0093b4c5c45dc52be9aea4ff3837e330ec42b4" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;pointer&quot;&gt;pointer type&lt;/a&gt; (to object or to function);</source>
          <target state="translated">&lt;a href=&quot;pointer&quot;&gt;тип указателя&lt;/a&gt; (для объекта или функции);</target>
        </trans-unit>
        <trans-unit id="ae90d6992e65874408f2a555b237871969050472" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;pointer#Pointers_to_members&quot;&gt;pointer to member type&lt;/a&gt; (to member object or to member function);</source>
          <target state="translated">&lt;a href=&quot;pointer#Pointers_to_members&quot;&gt;указатель типа элемента&lt;/a&gt; (к объекту члена или к функции члена);</target>
        </trans-unit>
        <trans-unit id="089b5759d49b3f3e3e05a4ed136cf4cb2e556331" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;qualified_lookup&quot;&gt;qualified name&lt;/a&gt;, if any name that appears to the left of &lt;code&gt;::&lt;/code&gt; is a</source>
          <target state="translated">&lt;a href=&quot;qualified_lookup&quot;&gt;квалифицированное имя&lt;/a&gt; , если имя , которое отображается в левой части &lt;code&gt;::&lt;/code&gt; является</target>
        </trans-unit>
        <trans-unit id="49c176e338afd9bd3c2793dd3aab24e8628e50cf" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;qualified_lookup&quot;&gt;qualified name&lt;/a&gt;, whose qualifier is the</source>
          <target state="translated">&lt;a href=&quot;qualified_lookup&quot;&gt;квалифицированное имя&lt;/a&gt; , которого классификатор является</target>
        </trans-unit>
        <trans-unit id="906617abbba3f5b3395186a0beb57b664902cb46" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;ranges/view&quot;&gt;&lt;code&gt;View&lt;/code&gt;&lt;/a&gt; consisting of a sequence generated by repeatedly incrementing an initial value</source>
          <target state="translated">&lt;a href=&quot;ranges/view&quot;&gt; &lt;code&gt;View&lt;/code&gt; &lt;/a&gt; , состоящий из последовательности , сформированной путем многократного приращения начального значения</target>
        </trans-unit>
        <trans-unit id="584a08c6718b46b2d5bafb7362ec47101daa6021" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;ranges/view&quot;&gt;&lt;code&gt;View&lt;/code&gt;&lt;/a&gt; consisting of the first N elements of another &lt;a href=&quot;ranges/view&quot;&gt;&lt;code&gt;View&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;ranges/view&quot;&gt; &lt;code&gt;View&lt;/code&gt; &lt;/a&gt; , состоящий из первых N элементов другого &lt;a href=&quot;ranges/view&quot;&gt; &lt;code&gt;View&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="87aecd3717fd037445fe9653742baf83e68058f8" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;ranges/view&quot;&gt;&lt;code&gt;View&lt;/code&gt;&lt;/a&gt; consisting of the sequence obtained from flattening a &lt;a href=&quot;ranges/view&quot;&gt;&lt;code&gt;View&lt;/code&gt;&lt;/a&gt; of &lt;a href=&quot;ranges/range&quot;&gt;&lt;code&gt;Range&lt;/code&gt;s&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;ranges/view&quot;&gt; &lt;code&gt;View&lt;/code&gt; &lt;/a&gt; , состоящий из последовательности , полученной из выпрямления &lt;a href=&quot;ranges/view&quot;&gt; &lt;code&gt;View&lt;/code&gt; &lt;/a&gt; из &lt;a href=&quot;ranges/range&quot;&gt; &lt;code&gt;Range&lt;/code&gt; s&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a37c7d31d124ed7013e20399a2b928cc3860b13d" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;ranges/view&quot;&gt;&lt;code&gt;View&lt;/code&gt;&lt;/a&gt; of a sequence that applies a transformation function to each element</source>
          <target state="translated">&lt;a href=&quot;ranges/view&quot;&gt; &lt;code&gt;View&lt;/code&gt; &lt;/a&gt; последовательности , которая применяет функцию преобразования к каждому элементу</target>
        </trans-unit>
        <trans-unit id="15d88520977b781a636bb3e5929f30daaf0cc794" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;ranges/view&quot;&gt;&lt;code&gt;View&lt;/code&gt;&lt;/a&gt; of the elements of some other &lt;a href=&quot;ranges/range&quot;&gt;&lt;code&gt;Range&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;ranges/view&quot;&gt; &lt;code&gt;View&lt;/code&gt; &lt;/a&gt; из элементов некоторого другого &lt;a href=&quot;ranges/range&quot;&gt; &lt;code&gt;Range&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a744d52e04d21449948de57a486e1984145b091d" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;ranges/view&quot;&gt;&lt;code&gt;View&lt;/code&gt;&lt;/a&gt; over the subranges obtained from splitting another &lt;a href=&quot;ranges/view&quot;&gt;&lt;code&gt;View&lt;/code&gt;&lt;/a&gt; using a delimiter</source>
          <target state="translated">a. &lt;a href=&quot;ranges/view&quot;&gt; &lt;code&gt;View&lt;/code&gt; &lt;/a&gt; на поддиапазоны, полученный при разбиении другого &lt;a href=&quot;ranges/view&quot;&gt; &lt;code&gt;View&lt;/code&gt; &lt;/a&gt; с использованием разделителя.</target>
        </trans-unit>
        <trans-unit id="ea2a829aa46d29fe3671781db0df1002a16f9f56" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;ranges/view&quot;&gt;&lt;code&gt;View&lt;/code&gt;&lt;/a&gt; that consists of the elements of a &lt;a href=&quot;ranges/range&quot;&gt;&lt;code&gt;Range&lt;/code&gt;&lt;/a&gt; that satisfies a predicate</source>
          <target state="translated">&lt;a href=&quot;ranges/view&quot;&gt; &lt;code&gt;View&lt;/code&gt; &lt;/a&gt; , который состоит из элементов &lt;a href=&quot;ranges/range&quot;&gt; &lt;code&gt;Range&lt;/code&gt; &lt;/a&gt; , который удовлетворяет предикатный</target>
        </trans-unit>
        <trans-unit id="3270d31c1a13794c926d9de62c84a1561042e839" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;ranges/view&quot;&gt;&lt;code&gt;View&lt;/code&gt;&lt;/a&gt; that contains a single element of a specified value</source>
          <target state="translated">&lt;a href=&quot;ranges/view&quot;&gt; &lt;code&gt;View&lt;/code&gt; &lt;/a&gt; , который содержит один элемент заданного значения</target>
        </trans-unit>
        <trans-unit id="8ee5c0dac3dcdfb720bfc6c40ed3163b50c59d15" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;ranges/view&quot;&gt;&lt;code&gt;View&lt;/code&gt;&lt;/a&gt; that includes all elements of a &lt;a href=&quot;ranges/range&quot;&gt;&lt;code&gt;Range&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;ranges/view&quot;&gt; &lt;code&gt;View&lt;/code&gt; &lt;/a&gt; , который включает в себя все элементы &lt;a href=&quot;ranges/range&quot;&gt; &lt;code&gt;Range&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="569c82165b27db13ed5aaf3e2bd4eadc158f3978" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;ranges/view&quot;&gt;&lt;code&gt;View&lt;/code&gt;&lt;/a&gt; that iterates over the elements of another bidirectional view in reverse order</source>
          <target state="translated">&lt;a href=&quot;ranges/view&quot;&gt; &lt;code&gt;View&lt;/code&gt; &lt;/a&gt; , который перебирает элементы другого двунаправленного зрения в обратном порядке</target>
        </trans-unit>
        <trans-unit id="65f096eb23ce29a61ddace2d9bc3762ad47d07e2" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;string_literal&quot;&gt;string literal&lt;/a&gt;, such as &lt;code&gt;&quot;Hello, world!&quot;&lt;/code&gt;;</source>
          <target state="translated">&lt;a href=&quot;string_literal&quot;&gt;строковый литерал&lt;/a&gt; , например, &lt;code&gt;&quot;Hello, world!&quot;&lt;/code&gt; ;</target>
        </trans-unit>
        <trans-unit id="f91dfaeafd98f430989545790f287e35b5f20dc9" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;string_literal&quot;&gt;string literal&lt;/a&gt;;</source>
          <target state="translated">&lt;a href=&quot;string_literal&quot;&gt;строковый литерал&lt;/a&gt; ;</target>
        </trans-unit>
        <trans-unit id="191a5a89aef337a4a629add8645510717aab9bf2" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;template_parameters#Type_template_parameter&quot;&gt;default argument of a type template parameter&lt;/a&gt;, or</source>
          <target state="translated">&lt;a href=&quot;template_parameters#Type_template_parameter&quot;&gt;по умолчанию аргумент параметра шаблона типа&lt;/a&gt; , или</target>
        </trans-unit>
        <trans-unit id="25def632dd3eeeb127af967f287d3c112d182fe9" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;templates&quot;&gt;template&lt;/a&gt; name followed by its argument list, such as &lt;code&gt;MyTemplate&amp;lt;int&amp;gt;&lt;/code&gt;;</source>
          <target state="translated">&lt;a href=&quot;templates&quot;&gt;шаблон&lt;/a&gt; имени следует список аргументов, таких как &lt;code&gt;MyTemplate&amp;lt;int&amp;gt;&lt;/code&gt; ;</target>
        </trans-unit>
        <trans-unit id="552d64c54cb700af2ff2ba1111b75b5ffde66790" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;templates#template-id&quot;&gt;template-id&lt;/a&gt; where either</source>
          <target state="translated">&lt;a href=&quot;templates#template-id&quot;&gt;шаблон-идентификатор&lt;/a&gt; , где либо</target>
        </trans-unit>
        <trans-unit id="663fb41f0d766e7269a5347cbd45d461e373d362" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;try_catch&quot;&gt;catch-clause&lt;/a&gt; for an exception of type &lt;code&gt;T&lt;/code&gt;, &lt;code&gt;T&amp;amp;&lt;/code&gt;, or &lt;code&gt;T*&lt;/code&gt;.</source>
          <target state="translated">предложение &lt;a href=&quot;try_catch&quot;&gt;catch&lt;/a&gt; для исключения типа &lt;code&gt;T&lt;/code&gt; , &lt;code&gt;T&amp;amp;&lt;/code&gt; или &lt;code&gt;T*&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="208a7da5d29804a28adcf5b9f0314d6ff0dd0293" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;try_catch&quot;&gt;try-block&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;try_catch&quot;&gt;примерки блок&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="5e94d0262c8aa644df44502fbb216fd3ee7762db" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;user_literal&quot;&gt;user-defined literal operator&lt;/a&gt; name, such as &lt;code&gt;operator &quot;&quot; _km&lt;/code&gt;;</source>
          <target state="translated">&lt;a href=&quot;user_literal&quot;&gt;определенного пользователь буквального оператор&lt;/a&gt; имя, например, &lt;code&gt;operator &quot;&quot; _km&lt;/code&gt; ;</target>
        </trans-unit>
        <trans-unit id="99934e9b58a1babae9be931f9f2fea4fc18fc0ee" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;view&quot;&gt;&lt;code&gt;View&lt;/code&gt;&lt;/a&gt; that includes all elements of a &lt;a href=&quot;range&quot;&gt;&lt;code&gt;Range&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;view&quot;&gt; &lt;code&gt;View&lt;/code&gt; &lt;/a&gt; , который включает в себя все элементы &lt;a href=&quot;range&quot;&gt; &lt;code&gt;Range&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="316d511c8aa53b7526805d4e5457d26523ec3796" translate="yes" xml:space="preserve">
          <source>a &lt;code&gt;&lt;a href=&quot;../../io/basic_ostream&quot;&gt;std::basic_ostream&lt;/a&gt;&lt;/code&gt; to insert &lt;code&gt;p&lt;/code&gt; into</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../../io/basic_ostream&quot;&gt;std::basic_ostream&lt;/a&gt;&lt;/code&gt; для вставки &lt;code&gt;p&lt;/code&gt; в</target>
        </trans-unit>
        <trans-unit id="fbd12644c821ad9dd5361ab305ce3eacebcd4452" translate="yes" xml:space="preserve">
          <source>a &lt;code&gt;&lt;a href=&quot;../../io/basic_ostream&quot;&gt;std::basic_ostream&lt;/a&gt;&lt;/code&gt; to insert &lt;code&gt;ptr&lt;/code&gt; into</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../../io/basic_ostream&quot;&gt;std::basic_ostream&lt;/a&gt;&lt;/code&gt; для вставки &lt;code&gt;ptr&lt;/code&gt; в</target>
        </trans-unit>
        <trans-unit id="a4b2b6efcf66147f984a4f4c3f1b193be394563b" translate="yes" xml:space="preserve">
          <source>a &lt;code&gt;&lt;a href=&quot;../../string/basic_string&quot;&gt;std::basic_string&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../../string/basic_string_view&quot;&gt;std::basic_string_view&lt;/a&gt;&lt;/code&gt;, pointer to a null-terminated character/wide character string, or an input iterator that points to a null-terminated character/wide character sequence. The character type must be one of &lt;code&gt;char&lt;/code&gt;, &lt;code&gt;char8_t&lt;/code&gt;, (since C++20)&lt;code&gt;char16_t&lt;/code&gt;, &lt;code&gt;char32_t&lt;/code&gt;, &lt;code&gt;wchar_t&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../../string/basic_string&quot;&gt;std::basic_string&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../../string/basic_string_view&quot;&gt;std::basic_string_view&lt;/a&gt;&lt;/code&gt; , указатель на символьный / строку широких символов , оканчивающийся нуля, или входной итератор , который указует на характер / широкую последовательность символов , оканчивающийся нуля. Тип символа должен иметь тип &lt;code&gt;char&lt;/code&gt; , &lt;code&gt;char8_t&lt;/code&gt; , (начиная с C ++ 20) &lt;code&gt;char16_t&lt;/code&gt; , &lt;code&gt;char32_t&lt;/code&gt; , &lt;code&gt;wchar_t&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6b73bd2673de988b6a6630c49706a06b3e5e3bc7" translate="yes" xml:space="preserve">
          <source>a &lt;code&gt;&lt;a href=&quot;../../types/size_t&quot;&gt;std::size_t&lt;/a&gt;&lt;/code&gt; representing the hash value.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../../types/size_t&quot;&gt;std::size_t&lt;/a&gt;&lt;/code&gt; , представляющий значение хеш - функции.</target>
        </trans-unit>
        <trans-unit id="2d166a98420f3d07a1a5cfa0f15025354bc8ab03" translate="yes" xml:space="preserve">
          <source>a &lt;code&gt;&lt;a href=&quot;../locale&quot;&gt;std::locale&lt;/a&gt;&lt;/code&gt; object to compare</source>
          <target state="translated">объект &lt;code&gt;&lt;a href=&quot;../locale&quot;&gt;std::locale&lt;/a&gt;&lt;/code&gt; для сравнения</target>
        </trans-unit>
        <trans-unit id="d5b6a5305c4cd7829271fc0bef5a5469bcdbe9cb" translate="yes" xml:space="preserve">
          <source>a &lt;code&gt;&lt;a href=&quot;../numeric/ratio/ratio&quot;&gt;std::ratio&lt;/a&gt;&lt;/code&gt; type representing the tick period of the clock, in seconds</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../numeric/ratio/ratio&quot;&gt;std::ratio&lt;/a&gt;&lt;/code&gt; типа , представляющий период такта часов, в секундах</target>
        </trans-unit>
        <trans-unit id="28c282d6688b8d9817fe3654bc3aea6ec9948374" translate="yes" xml:space="preserve">
          <source>a &lt;code&gt;&lt;a href=&quot;../path&quot;&gt;std::filesystem::path&lt;/a&gt;&lt;/code&gt; object</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../path&quot;&gt;std::filesystem::path&lt;/a&gt;&lt;/code&gt; объекта</target>
        </trans-unit>
        <trans-unit id="5c15ad055910b7bab983130d3d0318587f713ea8" translate="yes" xml:space="preserve">
          <source>a &lt;code&gt;&lt;a href=&quot;../pool_options&quot;&gt;std::pmr::pool_options&lt;/a&gt;&lt;/code&gt; struct containing the constructor options</source>
          <target state="translated">структура &lt;code&gt;&lt;a href=&quot;../pool_options&quot;&gt;std::pmr::pool_options&lt;/a&gt;&lt;/code&gt; содержащая параметры конструктора</target>
        </trans-unit>
        <trans-unit id="54930ae4d23e136dcc5b456eec1ed82612b38402" translate="yes" xml:space="preserve">
          <source>a &lt;code&gt;&lt;a href=&quot;../shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e940f25cbf8cd2aa56592576ed0c20278acc2bff" translate="yes" xml:space="preserve">
          <source>a &lt;code&gt;&lt;a href=&quot;../shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../weak_ptr&quot;&gt;std::weak_ptr&lt;/a&gt;&lt;/code&gt; that will be viewed by this &lt;code&gt;&lt;a href=&quot;../weak_ptr&quot;&gt;std::weak_ptr&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;../weak_ptr&quot;&gt;std::weak_ptr&lt;/a&gt;&lt;/code&gt; , которые будут рассматриваться этим &lt;code&gt;&lt;a href=&quot;../weak_ptr&quot;&gt;std::weak_ptr&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ecdb524f3aba763d3ff8829b8227e31bef82cacf" translate="yes" xml:space="preserve">
          <source>a &lt;code&gt;basic_string&lt;/code&gt; used to initialize the buffer</source>
          <target state="translated">&lt;code&gt;basic_string&lt;/code&gt; используется для инициализации буфера</target>
        </trans-unit>
        <trans-unit id="a0e668eabf5840cd34ea3e0f28321b311fe77422" translate="yes" xml:space="preserve">
          <source>a &lt;code&gt;duration&lt;/code&gt; to copy from</source>
          <target state="translated">&lt;code&gt;duration&lt;/code&gt; копирования с</target>
        </trans-unit>
        <trans-unit id="6b0c69e8badd1554c8a8794737ab30e685ebbeb0" translate="yes" xml:space="preserve">
          <source>a &lt;code&gt;memory_order_seq_cst&lt;/code&gt; fence Y, then A precedes Y in S c) if a &lt;code&gt;memory_order_seq_cst&lt;/code&gt; fence X</source>
          <target state="translated">a &lt;code&gt;memory_order_seq_cst&lt;/code&gt; ограда Y, тогда A предшествует Y в S c) если &lt;code&gt;memory_order_seq_cst&lt;/code&gt; ограда X</target>
        </trans-unit>
        <trans-unit id="f0b51354e700071d41d8e696cc9589f3f0e23e24" translate="yes" xml:space="preserve">
          <source>a &lt;code&gt;memory_order_seq_cst&lt;/code&gt; fence Y, then X precedes Y in S</source>
          <target state="translated">&lt;code&gt;memory_order_seq_cst&lt;/code&gt; забор Y, то Х предшествует Y в S</target>
        </trans-unit>
        <trans-unit id="9d2d1cf5df9aa21b5f43d6c3730e0127bacfd20a" translate="yes" xml:space="preserve">
          <source>a &lt;code&gt;mutex&lt;/code&gt; from the time that it successfully calls either &lt;a href=&quot;mutex/lock&quot;&gt;&lt;code&gt;lock&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;mutex/try_lock&quot;&gt;&lt;code&gt;try_lock&lt;/code&gt;&lt;/a&gt; until it calls &lt;a href=&quot;mutex/unlock&quot;&gt;&lt;code&gt;unlock&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;mutex&lt;/code&gt; с того времени, она успешно вызывает либо &lt;a href=&quot;mutex/lock&quot;&gt; &lt;code&gt;lock&lt;/code&gt; &lt;/a&gt; или &lt;a href=&quot;mutex/try_lock&quot;&gt; &lt;code&gt;try_lock&lt;/code&gt; &lt;/a&gt; , пока он не вызывает &lt;a href=&quot;mutex/unlock&quot;&gt; &lt;code&gt;unlock&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="863d62328d5f1e3a0af927034efd3cb49a858007" translate="yes" xml:space="preserve">
          <source>a &lt;code&gt;recursive_mutex&lt;/code&gt; for a period of time that starts when it successfully calls either &lt;a href=&quot;recursive_mutex/lock&quot;&gt;&lt;code&gt;lock&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;mutex/try_lock&quot;&gt;&lt;code&gt;try_lock&lt;/code&gt;&lt;/a&gt;. During this period, the thread may make additional calls to &lt;a href=&quot;recursive_mutex/lock&quot;&gt;&lt;code&gt;lock&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;recursive_mutex/try_lock&quot;&gt;&lt;code&gt;try_lock&lt;/code&gt;&lt;/a&gt;. The period of ownership ends when the thread makes a matching number of calls to &lt;a href=&quot;recursive_mutex/unlock&quot;&gt;&lt;code&gt;unlock&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;recursive_mutex&lt;/code&gt; в течение периода времени , который начинается , когда он успешно вызывает либо &lt;a href=&quot;recursive_mutex/lock&quot;&gt; &lt;code&gt;lock&lt;/code&gt; &lt;/a&gt; или &lt;a href=&quot;mutex/try_lock&quot;&gt; &lt;code&gt;try_lock&lt;/code&gt; &lt;/a&gt; . В течение этого периода поток может сделать дополнительные вызовы для &lt;a href=&quot;recursive_mutex/lock&quot;&gt; &lt;code&gt;lock&lt;/code&gt; &lt;/a&gt; или &lt;a href=&quot;recursive_mutex/try_lock&quot;&gt; &lt;code&gt;try_lock&lt;/code&gt; &lt;/a&gt; . Период владения заканчивается, когда поток делает соответствующее количество вызовов, чтобы &lt;a href=&quot;recursive_mutex/unlock&quot;&gt; &lt;code&gt;unlock&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="60b02f0b0cd6b462a069eb540be8a96dc7f7ee1a" translate="yes" xml:space="preserve">
          <source>a &lt;code&gt;regex_iterator&lt;/code&gt; to compare to</source>
          <target state="translated">&lt;code&gt;regex_iterator&lt;/code&gt; сравнить с</target>
        </trans-unit>
        <trans-unit id="5f914aa0db45d26f593fbd3b3acb0736aa4d7f34" translate="yes" xml:space="preserve">
          <source>a &lt;code&gt;std::chrono::local_info&lt;/code&gt; describing the result of the conversion attempt</source>
          <target state="translated">&lt;code&gt;std::chrono::local_info&lt;/code&gt; , описывающее результат попытки преобразования</target>
        </trans-unit>
        <trans-unit id="e92b7ebf5ac6699b0419aafc5019fd69e5b495d1" translate="yes" xml:space="preserve">
          <source>a &lt;code&gt;std::future&lt;/code&gt; that will transfer state to &lt;code&gt;*this&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;std::future&lt;/code&gt; , который будет передавать состояние на &lt;code&gt;*this&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="45c38558d576f7077eb936fedf2e6993f71552d0" translate="yes" xml:space="preserve">
          <source>a &lt;code&gt;std::partial_ordering &lt;/code&gt; value to check</source>
          <target state="translated">&lt;code&gt;std::partial_ordering &lt;/code&gt; значение для проверки</target>
        </trans-unit>
        <trans-unit id="6cb6d8aec9d0d7086c8d7b490355b651816e9f71" translate="yes" xml:space="preserve">
          <source>a &lt;code&gt;std::partial_ordering&lt;/code&gt; value to check</source>
          <target state="translated">&lt;code&gt;std::partial_ordering&lt;/code&gt; значение для проверки</target>
        </trans-unit>
        <trans-unit id="2abc4eda553b7e2119f385f0dd8fe079b5901fc1" translate="yes" xml:space="preserve">
          <source>a &lt;code&gt;std::shared_future&lt;/code&gt; that will transfer state to &lt;code&gt;*this&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;std::shared_future&lt;/code&gt; , который будет передавать состояние на &lt;code&gt;*this&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ea1ec8d4b72649962e567349201f78a7aecef264" translate="yes" xml:space="preserve">
          <source>a &lt;code&gt;std::strong_equality&lt;/code&gt; value to check</source>
          <target state="translated">значение &lt;code&gt;std::strong_equality&lt;/code&gt; для проверки</target>
        </trans-unit>
        <trans-unit id="842ba00de4d8ab8dd4f532e899b87cf7099a8622" translate="yes" xml:space="preserve">
          <source>a &lt;code&gt;std::strong_ordering&lt;/code&gt; value to check</source>
          <target state="translated">значение &lt;code&gt;std::strong_ordering&lt;/code&gt; для проверки</target>
        </trans-unit>
        <trans-unit id="0253836014928024de0859d29625df2f344d46ad" translate="yes" xml:space="preserve">
          <source>a &lt;code&gt;std::weak_equality&lt;/code&gt; value to check</source>
          <target state="translated">&lt;code&gt;std::weak_equality&lt;/code&gt; значение для проверки</target>
        </trans-unit>
        <trans-unit id="f76354e64cc6e23de23245adc7499dc00576366f" translate="yes" xml:space="preserve">
          <source>a &lt;code&gt;std::weak_ordering &lt;/code&gt; value to check</source>
          <target state="translated">значение &lt;code&gt;std::weak_ordering &lt;/code&gt; для проверки</target>
        </trans-unit>
        <trans-unit id="05358986f183ddf4595d8859a958cc712f0ab225" translate="yes" xml:space="preserve">
          <source>a &lt;code&gt;std::weak_ordering&lt;/code&gt; value to check</source>
          <target state="translated">значение &lt;code&gt;std::weak_ordering&lt;/code&gt; для проверки</target>
        </trans-unit>
        <trans-unit id="d9610770cf81d239e7a04362e6d0fadfaa64deec" translate="yes" xml:space="preserve">
          <source>a &lt;code&gt;sub_match&lt;/code&gt;, &lt;code&gt;basic_string&lt;/code&gt;, pointer to a null-terminated string or a character to compare</source>
          <target state="translated">&lt;code&gt;sub_match&lt;/code&gt; , &lt;code&gt;basic_string&lt;/code&gt; , указатель на строку с нулевым символом или символ для сравнения</target>
        </trans-unit>
        <trans-unit id="63b26ec0d5fac3c3232b5ffc726c7befaaed3d72" translate="yes" xml:space="preserve">
          <source>a &lt;code&gt;time_point&lt;/code&gt; to convert from</source>
          <target state="translated">&lt;code&gt;time_point&lt;/code&gt; конвертировать из</target>
        </trans-unit>
        <trans-unit id="816fe47038210aaf21ca1a99d9e95e7a3f42b5cc" translate="yes" xml:space="preserve">
          <source>a FIFO (also known as pipe) file</source>
          <target state="translated">файл FIFO (также известный как трубный).</target>
        </trans-unit>
        <trans-unit id="54a9c6eed1e0626765604b3dcde6dced86c39ba2" translate="yes" xml:space="preserve">
          <source>a UTF-8 encoded &lt;code&gt;&lt;a href=&quot;../../string/basic_string&quot;&gt;std::string&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../../string/basic_string_view&quot;&gt;std::string_view&lt;/a&gt;&lt;/code&gt;, a pointer to a null-terminated multibyte string, or an input iterator with char value type that points to a null-terminated multibyte string</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../../string/basic_string&quot;&gt;std::string&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../../string/basic_string_view&quot;&gt;std::string_view&lt;/a&gt;&lt;/code&gt; в кодировке UTF-8 , указатель на многобайтовую строку с нулевым символом в конце или итератор ввода с типом значения char, указывающим на многобайтовую строку с нулевым символом в конце</target>
        </trans-unit>
        <trans-unit id="d879d1e4b9050e4ddcaaf4d1177df97586b36972" translate="yes" xml:space="preserve">
          <source>a base class subobject, or</source>
          <target state="translated">подобъект базового класса,или</target>
        </trans-unit>
        <trans-unit id="f4918892ac7e83e823a2320d1ac12b97395fb22e" translate="yes" xml:space="preserve">
          <source>a basic stream output function</source>
          <target state="translated">базовая функция вывода потока</target>
        </trans-unit>
        <trans-unit id="b40f7d626aeddea7dd6317df88183469b83e1e8c" translate="yes" xml:space="preserve">
          <source>a basic_ostream of the same type to swap with</source>
          <target state="translated">basic_ostream того же типа для обмена на</target>
        </trans-unit>
        <trans-unit id="7bf28d638858caf4f712e1c44d5c9646f9188b75" translate="yes" xml:space="preserve">
          <source>a basic_string used as a source used to initialize the regex</source>
          <target state="translated">строка basic_string,используемая в качестве источника для инициализации регекса</target>
        </trans-unit>
        <trans-unit id="6e9b8e3d4e8d4b69f9fcb8e7bf96871b00610a3b" translate="yes" xml:space="preserve">
          <source>a bitmask value of type &lt;code&gt;category&lt;/code&gt; indicating the collate facet category</source>
          <target state="translated">значение битовой маски &lt;code&gt;category&lt;/code&gt; типа, указывающее категорию аспекта сопоставления</target>
        </trans-unit>
        <trans-unit id="9f85b8ca8bc6020d25703e2cd3d781082f967763" translate="yes" xml:space="preserve">
          <source>a bitmask value of type &lt;code&gt;category&lt;/code&gt; indicating the ctype facet category</source>
          <target state="translated">значение битовой маски &lt;code&gt;category&lt;/code&gt; типа, указывающее категорию фасета ctype</target>
        </trans-unit>
        <trans-unit id="a9222a22156a69a4cc22429a74768f81e03c8001" translate="yes" xml:space="preserve">
          <source>a bitmask value of type &lt;code&gt;category&lt;/code&gt; indicating the messages facet category</source>
          <target state="translated">значение битовой маски &lt;code&gt;category&lt;/code&gt; типа, указывающее категорию фасета сообщения</target>
        </trans-unit>
        <trans-unit id="952a4bcb614afbf75d9c9379f3e6fad36cbc2407" translate="yes" xml:space="preserve">
          <source>a bitmask value of type &lt;code&gt;category&lt;/code&gt; indicating the monetary facet category</source>
          <target state="translated">значение битовой маски типа type, указывающее &lt;code&gt;category&lt;/code&gt; денежного фасета</target>
        </trans-unit>
        <trans-unit id="a321349b7f9b76dc26dc645283a6f6c0d3935161" translate="yes" xml:space="preserve">
          <source>a bitmask value of type &lt;code&gt;category&lt;/code&gt; indicating the numeric facet category</source>
          <target state="translated">значение битовой маски типа &lt;code&gt;category&lt;/code&gt; указывающее числовую категорию фасетов</target>
        </trans-unit>
        <trans-unit id="b2849fb686ecb1e5989a880cd4bb3d2e85d8c6f8" translate="yes" xml:space="preserve">
          <source>a bitmask value of type &lt;code&gt;category&lt;/code&gt; indicating the time facet category</source>
          <target state="translated">значение битовой маски &lt;code&gt;category&lt;/code&gt; типа, указывающее категорию временного аспекта</target>
        </trans-unit>
        <trans-unit id="5378f3a4e98f36da8d1cc7ac9fde2e0f766b8ce0" translate="yes" xml:space="preserve">
          <source>a block special file</source>
          <target state="translated">специальный файл блока</target>
        </trans-unit>
        <trans-unit id="31510aaf6cad0411c7217a1f61ae7d5e0d11e988" translate="yes" xml:space="preserve">
          <source>a callable object used to determine equality</source>
          <target state="translated">вызываемый объект,используемый для определения равенства</target>
        </trans-unit>
        <trans-unit id="16cbd5bc356bd1da4d6938d770e5e05cf23f18f0" translate="yes" xml:space="preserve">
          <source>a callable object used to hash the elements of the string</source>
          <target state="translated">вызываемый объект,используемый для хэширования элементов строки</target>
        </trans-unit>
        <trans-unit id="e104c12ef41e3cdab35da94692fcec6545e90e82" translate="yes" xml:space="preserve">
          <source>a callable to initialize the</source>
          <target state="translated">вызываемый для инициализации</target>
        </trans-unit>
        <trans-unit id="a43b347761e3e1642f174ca5ec98e18e3c558b21" translate="yes" xml:space="preserve">
          <source>a callable used to initialize &lt;code&gt;*this&lt;/code&gt;</source>
          <target state="translated">вызываемый используется для инициализации &lt;code&gt;*this&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="dc6aead76d9ee30f0a5c5d4684ed174e264c2836" translate="yes" xml:space="preserve">
          <source>a cast expression to lvalue reference type, such as &lt;code&gt;static_cast&amp;lt;int&amp;amp;&amp;gt;(x)&lt;/code&gt;;</source>
          <target state="translated">выражение приведения к типу ссылки lvalue, например &lt;code&gt;static_cast&amp;lt;int&amp;amp;&amp;gt;(x)&lt;/code&gt; ;</target>
        </trans-unit>
        <trans-unit id="9115722d18c29f111bc7117bd95ced839664bc51" translate="yes" xml:space="preserve">
          <source>a cast expression to non-reference type, such as &lt;code&gt;static_cast&amp;lt;double&amp;gt;(x)&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../string/basic_string&quot;&gt;std::string&lt;/a&gt;{}&lt;/code&gt;, or &lt;code&gt;(int)42&lt;/code&gt;;</source>
          <target state="translated">приведение выражения к не ссылочному типу, такому как &lt;code&gt;static_cast&amp;lt;double&amp;gt;(x)&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../string/basic_string&quot;&gt;std::string&lt;/a&gt;{}&lt;/code&gt; или &lt;code&gt;(int)42&lt;/code&gt; ;</target>
        </trans-unit>
        <trans-unit id="e763fd172d6152f43975ef5910f0aa8ba9d50062" translate="yes" xml:space="preserve">
          <source>a cast expression to rvalue reference to function type, such as &lt;code&gt;static_cast&amp;lt;void (&amp;amp;&amp;amp;)(int)&amp;gt;(x)&lt;/code&gt;.</source>
          <target state="translated">приведенное выражение для rvalue ссылки на тип функции, например &lt;code&gt;static_cast&amp;lt;void (&amp;amp;&amp;amp;)(int)&amp;gt;(x)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="be2abbbe2e0dfe771f0371f123450bb9bd07c9bb" translate="yes" xml:space="preserve">
          <source>a cast expression to rvalue reference to object type, such as &lt;code&gt;static_cast&amp;lt;char&amp;amp;&amp;amp;&amp;gt;(x)&lt;/code&gt;;</source>
          <target state="translated">приведенное выражение для rvalue ссылки на тип объекта, например &lt;code&gt;static_cast&amp;lt;char&amp;amp;&amp;amp;&amp;gt;(x)&lt;/code&gt; ;</target>
        </trans-unit>
        <trans-unit id="53484ba10b1e424e0b9496d35157e69373bf554a" translate="yes" xml:space="preserve">
          <source>a character from the source character set minus single-quote (&lt;code&gt;'&lt;/code&gt;), backslash (&lt;code&gt;\&lt;/code&gt;), or the newline character,</source>
          <target state="translated">символ из исходного набора символов минус одинарные кавычки ( &lt;code&gt;'&lt;/code&gt; ), обратный слеш ( &lt;code&gt;\&lt;/code&gt; ) или символ новой строки,</target>
        </trans-unit>
        <trans-unit id="242427c6b2eafcaf248ee1b9d7c883407593539a" translate="yes" xml:space="preserve">
          <source>a character input stream</source>
          <target state="translated">поток ввода символов</target>
        </trans-unit>
        <trans-unit id="0efbbee14797deed6a7056276c65b5e154453b0a" translate="yes" xml:space="preserve">
          <source>a character output stream</source>
          <target state="translated">поток вывода символов</target>
        </trans-unit>
        <trans-unit id="70a6bbc7a457f3e06d375719052224054e262911" translate="yes" xml:space="preserve">
          <source>a character range to use</source>
          <target state="translated">диапазон символов</target>
        </trans-unit>
        <trans-unit id="f1cf02ceb7cec86411208ea818ed5141785e1a23" translate="yes" xml:space="preserve">
          <source>a character range to use, represented as &lt;code&gt;&lt;a href=&quot;../../string/basic_string&quot;&gt;std::string&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../../string/basic_string_view&quot;&gt;std::string_view&lt;/a&gt;&lt;/code&gt;, pointer to a null-terminated multibyte string, or as an input iterator with char value type that points to a null-terminated multibyte string</source>
          <target state="translated">диапазон символов для использования, представленный как &lt;code&gt;&lt;a href=&quot;../../string/basic_string&quot;&gt;std::string&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../../string/basic_string_view&quot;&gt;std::string_view&lt;/a&gt;&lt;/code&gt; , указатель на многобайтовую строку с нулевым символом в конце или как итератор ввода с типом значения char, указывающим на многобайтовую строку с нулевым символом в конце</target>
        </trans-unit>
        <trans-unit id="1736d8d35a09815a4736564ec0af7bbafefb5389" translate="yes" xml:space="preserve">
          <source>a character sequence or a single character to compare to the end of the string</source>
          <target state="translated">последовательность символов или один символ для сравнения с концом строки</target>
        </trans-unit>
        <trans-unit id="eb17e0910a8a3e8109807493a04ca35e79111c97" translate="yes" xml:space="preserve">
          <source>a character sequence or a single character to compare to the end of the string view</source>
          <target state="translated">последовательность символов или один символ для сравнения с концом строкового представления</target>
        </trans-unit>
        <trans-unit id="792cac041ed6c9d94e7546b52a466c7057d1833f" translate="yes" xml:space="preserve">
          <source>a character sequence or a single character to compare to the start of the string</source>
          <target state="translated">последовательность символов или один символ для сравнения с началом строки</target>
        </trans-unit>
        <trans-unit id="cf6ca109dc96019eacef9105cfc32c6bb8adf9f3" translate="yes" xml:space="preserve">
          <source>a character sequence or a single character to compare to the start of the string view</source>
          <target state="translated">последовательность символов или один символ для сравнения с началом представления строки</target>
        </trans-unit>
        <trans-unit id="a36ddc3729dac1840b73df74f47d5b5381de7021" translate="yes" xml:space="preserve">
          <source>a character special file</source>
          <target state="translated">файл со специальными символами</target>
        </trans-unit>
        <trans-unit id="a5250d7e3929a03629a280317471b3d3c146b682" translate="yes" xml:space="preserve">
          <source>a class type (&lt;code&gt;class&lt;/code&gt; or &lt;code&gt;struct&lt;/code&gt; or &lt;code&gt;union&lt;/code&gt;) that:</source>
          <target state="translated">тип класса ( &lt;code&gt;class&lt;/code&gt; или &lt;code&gt;struct&lt;/code&gt; или &lt;code&gt;union&lt;/code&gt; ), который:</target>
        </trans-unit>
        <trans-unit id="f075c0a2aeaae5daa8fce7ca9d846ae302099ae2" translate="yes" xml:space="preserve">
          <source>a class type that contains allocation information</source>
          <target state="translated">тип класса,содержащий информацию о распределении</target>
        </trans-unit>
        <trans-unit id="691a4be3772ad8ef069a61765f06c1d8bc2961d8" translate="yes" xml:space="preserve">
          <source>a class/function/variable template</source>
          <target state="translated">шаблон класса/функции/переменной</target>
        </trans-unit>
        <trans-unit id="8af3fd16bec574be1984ea9e734c9bf45f25959e" translate="yes" xml:space="preserve">
          <source>a comma-separated list of parameters like in a function declaration, except that default arguments are not allowed and it cannot end with an ellipsis (other than one signifying a pack expansion). These parameters have no storage, linkage or lifetime, and are only used to assist in specifying requirements. These parameters are in scope until the closing &lt;code&gt;} &lt;/code&gt; of the requirement-seq.</source>
          <target state="translated">список параметров, разделенных запятыми, как в объявлении функции, за исключением того, что аргументы по умолчанию недопустимы и не могут заканчиваться многоточием (кроме одного, обозначающего расширение пакета). Эти параметры не имеют хранения, связи или срока службы и используются только для определения требований. Эти параметры находятся в области действия до закрытия &lt;code&gt;} &lt;/code&gt; require-seq.</target>
        </trans-unit>
        <trans-unit id="f11728936e3c6825ff0c40fb8190cad46110b798" translate="yes" xml:space="preserve">
          <source>a comma-separated list of zero or more &lt;a href=&quot;lambda#Lambda_capture&quot;&gt;captures&lt;/a&gt;, optionally beginning with a capture-default.</source>
          <target state="translated">разделенный запятыми список от нуля или более &lt;a href=&quot;lambda#Lambda_capture&quot;&gt;перехватов&lt;/a&gt; , опционально начинающихся с перехвата по умолчанию.</target>
        </trans-unit>
        <trans-unit id="34fd2e1333d218ba0d65569377b79829eed062f3" translate="yes" xml:space="preserve">
          <source>a compatible &lt;a href=&quot;../node_handle&quot;&gt;node handle&lt;/a&gt;</source>
          <target state="translated">совместимый &lt;a href=&quot;../node_handle&quot;&gt;дескриптор узла&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="12cf74b9d504b7de17cb8733f3089bb0c746c26c" translate="yes" xml:space="preserve">
          <source>a complex number determined by &lt;code&gt;r&lt;/code&gt; and &lt;code&gt;theta&lt;/code&gt;.</source>
          <target state="translated">комплексное число, определяемое &lt;code&gt;r&lt;/code&gt; и &lt;code&gt;theta&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="832f4c5d564988716ce6fc985261dbaeef18716f" translate="yes" xml:space="preserve">
          <source>a complex number type</source>
          <target state="translated">тип комплексного номера</target>
        </trans-unit>
        <trans-unit id="87f7888775f37c05d22b86f373fe58cc238751cb" translate="yes" xml:space="preserve">
          <source>a complex or scalar value of matching type (&lt;code&gt;float&lt;/code&gt;, &lt;code&gt;double&lt;/code&gt;, &lt;code&gt;long double&lt;/code&gt;)</source>
          <target state="translated">комплексное или скалярное значение соответствующего типа ( &lt;code&gt;float&lt;/code&gt; , &lt;code&gt;double&lt;/code&gt; , &lt;code&gt;long double&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="b420ae5c7d6bcd895849ec43707c9cd9b5295f2a" translate="yes" xml:space="preserve">
          <source>a compound type constructed from a dependent type</source>
          <target state="translated">составной тип,построенный из зависимого типа</target>
        </trans-unit>
        <trans-unit id="3e10ceabf9c0862a21d4c968a88d28cf606e6ae4" translate="yes" xml:space="preserve">
          <source>a concept (&lt;a href=&quot;constraints&quot;&gt;constraints and concepts&lt;/a&gt;) (since C++20)</source>
          <target state="translated">концепция ( &lt;a href=&quot;constraints&quot;&gt;ограничения и концепции&lt;/a&gt; ) (начиная с C ++ 20)</target>
        </trans-unit>
        <trans-unit id="705840ece91c45959e8d8b85562f78f90621fb91" translate="yes" xml:space="preserve">
          <source>a constant &lt;a href=&quot;../named_req/bidirectionaliterator&quot;&gt;LegacyBidirectionalIterator&lt;/a&gt; with a &lt;code&gt;value_type&lt;/code&gt; of &lt;code&gt;path&lt;/code&gt;, except that for dereferenceable iterators &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; of type &lt;code&gt;path::iterator&lt;/code&gt; with &lt;code&gt;a == b&lt;/code&gt;, there is no requirement that &lt;code&gt;*a&lt;/code&gt; and &lt;code&gt;*b&lt;/code&gt; are bound to the same object</source>
          <target state="translated">константа &lt;a href=&quot;../named_req/bidirectionaliterator&quot;&gt;LegacyBidirectionalIterator&lt;/a&gt; с &lt;code&gt;value_type&lt;/code&gt; по &lt;code&gt;path&lt;/code&gt; , за исключением того, что для разыменовываемых итераторов и &lt;code&gt;b&lt;/code&gt; типа &lt;code&gt;path::iterator&lt;/code&gt; с &lt;code&gt;a == b&lt;/code&gt; , не существует требования , чтобы &lt;code&gt;*a&lt;/code&gt; и &lt;code&gt;*b&lt;/code&gt; связаны с тем же объектом &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0861d8f96c22cf00ddd38be06d579dc5846fa4bb" translate="yes" xml:space="preserve">
          <source>a constant expression of the same type as the type of condition after conversions and &lt;a href=&quot;implicit_cast&quot;&gt;integral promotions&lt;/a&gt;</source>
          <target state="translated">постоянное выражение того же типа, что и тип условия после преобразований и &lt;a href=&quot;implicit_cast&quot;&gt;интегральных повышений&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="fa1e013cc131d9284341359f6bccff749d73ab2d" translate="yes" xml:space="preserve">
          <source>a constant of type &lt;code&gt;&lt;a href=&quot;codecvt_mode&quot;&gt;std::codecvt_mode&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">константа типа &lt;code&gt;&lt;a href=&quot;codecvt_mode&quot;&gt;std::codecvt_mode&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2092e802512bd4b6672ffecf3059eab3c2dc675a" translate="yes" xml:space="preserve">
          <source>a constant of type &lt;code&gt;size_t&lt;/code&gt; signifying that the &lt;code&gt;span&lt;/code&gt; has dynamic extent</source>
          <target state="translated">константа типа &lt;code&gt;size_t&lt;/code&gt; , означающая, что &lt;code&gt;span&lt;/code&gt; имеет динамический экстент</target>
        </trans-unit>
        <trans-unit id="43883e62b71e2ce20764378f921e1463f7c5e2fb" translate="yes" xml:space="preserve">
          <source>a constructor for a base or member that the implicit definition of the constructor would call is</source>
          <target state="translated">конструктор для базы или члена,который неявное определение конструктора будет вызывать следующим образом</target>
        </trans-unit>
        <trans-unit id="1e0e47bbea0419696dda53a2c740d527152ed34a" translate="yes" xml:space="preserve">
          <source>a container (such as &lt;code&gt;&lt;a href=&quot;../container/vector&quot;&gt;std::vector&lt;/a&gt;&lt;/code&gt;) of non-recursive &lt;a href=&quot;directory_iterator&quot;&gt;&lt;code&gt;directory_iterator&lt;/code&gt;s&lt;/a&gt; that forms the recursion stack</source>
          <target state="translated">контейнер (такой как &lt;code&gt;&lt;a href=&quot;../container/vector&quot;&gt;std::vector&lt;/a&gt;&lt;/code&gt; ) нерекурсивных &lt;a href=&quot;directory_iterator&quot;&gt; &lt;code&gt;directory_iterator&lt;/code&gt; s,&lt;/a&gt; который формирует стек рекурсии</target>
        </trans-unit>
        <trans-unit id="6da0ef251a56bef0d297d95fb6f03dcddc9d4d68" translate="yes" xml:space="preserve">
          <source>a container with a &lt;code&gt;begin&lt;/code&gt; method</source>
          <target state="translated">контейнер с методом &lt;code&gt;begin&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3ab7db750fffecfbea2fd7f3a1826d7a47ff6dfd" translate="yes" xml:space="preserve">
          <source>a container with a &lt;code&gt;data()&lt;/code&gt; method</source>
          <target state="translated">контейнер с методом &lt;code&gt;data()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d42aaf6f8dfa2ceb1302ac9a7aae99e65ad76dd7" translate="yes" xml:space="preserve">
          <source>a container with a &lt;code&gt;rbegin&lt;/code&gt; method</source>
          <target state="translated">контейнер с методом &lt;code&gt;rbegin&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8a255f3578bec602079f216affbbb6421964db15" translate="yes" xml:space="preserve">
          <source>a container with a &lt;code&gt;rend&lt;/code&gt; method</source>
          <target state="translated">контейнер с методом &lt;code&gt;rend&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d76e199c3451be874b54d52909a700c365bc58d9" translate="yes" xml:space="preserve">
          <source>a container with a &lt;code&gt;size&lt;/code&gt; method</source>
          <target state="translated">контейнер с &lt;code&gt;size&lt;/code&gt; метода</target>
        </trans-unit>
        <trans-unit id="5936962ad861e75e91156317d373da013aa2a18b" translate="yes" xml:space="preserve">
          <source>a container with an &lt;code&gt;empty&lt;/code&gt; method</source>
          <target state="translated">контейнер с &lt;code&gt;empty&lt;/code&gt; методом</target>
        </trans-unit>
        <trans-unit id="8eecf2dba113b51a014b2681b5af4fc06cf180a3" translate="yes" xml:space="preserve">
          <source>a container with an &lt;code&gt;end&lt;/code&gt; method</source>
          <target state="translated">контейнер с &lt;code&gt;end&lt;/code&gt; методом</target>
        </trans-unit>
        <trans-unit id="32ae34e0c2ff3b97cd9427b79233b671fd97c530" translate="yes" xml:space="preserve">
          <source>a copy of the base() iterator</source>
          <target state="translated">копия итератора base()</target>
        </trans-unit>
        <trans-unit id="7332ce803122087bfbb9401270891b4faedd3f1f" translate="yes" xml:space="preserve">
          <source>a copy of the base() iterator, the name is for exposition only</source>
          <target state="translated">копия итератора base(),имя предназначено только для экспозиции.</target>
        </trans-unit>
        <trans-unit id="311bf83f22bc4bb383f24fd37ba3cb18d0aeb36d" translate="yes" xml:space="preserve">
          <source>a copy of the value returned by &lt;code&gt;&lt;a href=&quot;../../locale/locale&quot;&gt;std::locale&lt;/a&gt;()&lt;/code&gt;</source>
          <target state="translated">копия значения, возвращаемого &lt;code&gt;&lt;a href=&quot;../../locale/locale&quot;&gt;std::locale&lt;/a&gt;()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6f958f7a6a78be01a6805b5c1af1d682eeb8a134" translate="yes" xml:space="preserve">
          <source>a cv-qualified version of a dependent type</source>
          <target state="translated">cv-квалифицированный вариант зависимого типа</target>
        </trans-unit>
        <trans-unit id="fc96c9e2930591a8d0a0e1f5aef8a747ab1ae764" translate="yes" xml:space="preserve">
          <source>a declaration</source>
          <target state="translated">заявление</target>
        </trans-unit>
        <trans-unit id="de382bf6f6303f1d66d3ee9fa105e4cb909ae0fb" translate="yes" xml:space="preserve">
          <source>a default member initializer (for default constructor only) is</source>
          <target state="translated">инициализатором члена по умолчанию (только для конструктора по умолчанию)является</target>
        </trans-unit>
        <trans-unit id="c35c5385471cf8ca008de727f3a8bb03a39d8fc4" translate="yes" xml:space="preserve">
          <source>a default-constructed &lt;code&gt;path()&lt;/code&gt; followed by</source>
          <target state="translated">созданный по умолчанию &lt;code&gt;path()&lt;/code&gt; за которым следует</target>
        </trans-unit>
        <trans-unit id="3720dd36cc49fe927d2449b3b2fe294001d00344" translate="yes" xml:space="preserve">
          <source>a definition of a variable for which &lt;a href=&quot;default_initialization&quot;&gt;no initialization is performed&lt;/a&gt;.</source>
          <target state="translated">определение переменной, для которой &lt;a href=&quot;default_initialization&quot;&gt;не выполняется инициализация&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8574bc2dee7611873d6999d1419b5b65057eda6e" translate="yes" xml:space="preserve">
          <source>a definition of a variable of non-literal type</source>
          <target state="translated">определение переменной нелитературного типа</target>
        </trans-unit>
        <trans-unit id="bf8e57bf98d46c7f4282d67c960acf8da327fef4" translate="yes" xml:space="preserve">
          <source>a definition of a variable of static or thread &lt;a href=&quot;storage_duration&quot;&gt;storage duration&lt;/a&gt;</source>
          <target state="translated">определение переменной статической или &lt;a href=&quot;storage_duration&quot;&gt;длительности хранения&lt;/a&gt; потока</target>
        </trans-unit>
        <trans-unit id="39cd8bcb29b6ae12a4df802c4fe0c9397f3f8893" translate="yes" xml:space="preserve">
          <source>a deleter to copy from</source>
          <target state="translated">удаление для копирования с</target>
        </trans-unit>
        <trans-unit id="94a71c43d37808b7131ebf1bfafb843815bd7985" translate="yes" xml:space="preserve">
          <source>a deleter to use to destroy the object</source>
          <target state="translated">удалитель для использования с целью уничтожения объекта</target>
        </trans-unit>
        <trans-unit id="24ff51d02f7ddaf5794e2da95d7baf8bf41c271f" translate="yes" xml:space="preserve">
          <source>a deterministic &lt;a href=&quot;named_req/uniformrandombitgenerator&quot;&gt;UniformRandomBitGenerator&lt;/a&gt;, defined by the seed</source>
          <target state="translated">детерминированный &lt;a href=&quot;named_req/uniformrandombitgenerator&quot;&gt;UniformRandomBitGenerator&lt;/a&gt; , определяемый начальным числом</target>
        </trans-unit>
        <trans-unit id="534eb8b60097429551e576498f52d179c2f4e5dd" translate="yes" xml:space="preserve">
          <source>a directory</source>
          <target state="translated">каталог</target>
        </trans-unit>
        <trans-unit id="8bddca722adcb261998df0de3bb3c97a6c748832" translate="yes" xml:space="preserve">
          <source>a directory entry</source>
          <target state="translated">запись каталога</target>
        </trans-unit>
        <trans-unit id="927fd0565fdd62ffef9d7df984e6c6f5ed72f85d" translate="yes" xml:space="preserve">
          <source>a directory_iterator</source>
          <target state="translated">каталог_iterator</target>
        </trans-unit>
        <trans-unit id="867723c6d0ee2b6557184f124ed60f12f45d1dd0" translate="yes" xml:space="preserve">
          <source>a discarded-value expression.</source>
          <target state="translated">отбракованное ценностное выражение.</target>
        </trans-unit>
        <trans-unit id="336c91ab3bd545d36262022c4abcf1ea256c10d5" translate="yes" xml:space="preserve">
          <source>a disjunctive clause subsumes a conjunctive clause if and only if there is an atomic constraint &lt;code&gt;U&lt;/code&gt; in the disjunctive clause and an atomic constraint &lt;code&gt;V&lt;/code&gt; in the conjunctive clause such that &lt;code&gt;U&lt;/code&gt; subsumes &lt;code&gt;V&lt;/code&gt;;</source>
          <target state="translated">дизъюнктивное предложение относится к конъюнктивному предложению тогда и только тогда, когда в дизъюнктивном предложении есть атомное ограничение &lt;code&gt;U&lt;/code&gt; и атомарное ограничение &lt;code&gt;V&lt;/code&gt; в конъюнктивном предложении, так что &lt;code&gt;U&lt;/code&gt; включает &lt;code&gt;V&lt;/code&gt; ;</target>
        </trans-unit>
        <trans-unit id="6b5747ff852acba8c48d1a6cb5da34fc9e296730" translate="yes" xml:space="preserve">
          <source>a duration to copy from</source>
          <target state="translated">продолжительность копирования с</target>
        </trans-unit>
        <trans-unit id="c350a90cf1671cc555d57758875af84ffdbe33a9" translate="yes" xml:space="preserve">
          <source>a family of classes (&lt;a href=&quot;class_template&quot;&gt;class template&lt;/a&gt;), which may be &lt;a href=&quot;member_template&quot;&gt;nested classes&lt;/a&gt;</source>
          <target state="translated">семейство классов ( &lt;a href=&quot;class_template&quot;&gt;шаблон класса&lt;/a&gt; ), в которое могут быть &lt;a href=&quot;member_template&quot;&gt;вложенные классы&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="7ac66b538aae3ff5b2eebbb9164d6b15968c2655" translate="yes" xml:space="preserve">
          <source>a family of functions (&lt;a href=&quot;function_template&quot;&gt;function template&lt;/a&gt;), which may be &lt;a href=&quot;member_template&quot;&gt;member functions&lt;/a&gt;</source>
          <target state="translated">семейство функций ( &lt;a href=&quot;function_template&quot;&gt;шаблон функции&lt;/a&gt; ), которые могут быть &lt;a href=&quot;member_template&quot;&gt;функциями-членами&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b225fab8be27928cedcf387d1202d942115cf6f7" translate="yes" xml:space="preserve">
          <source>a family of variables (&lt;a href=&quot;variable_template&quot;&gt;variable template&lt;/a&gt;) (since C++14)</source>
          <target state="translated">семейство переменных ( &lt;a href=&quot;variable_template&quot;&gt;шаблон переменной&lt;/a&gt; ) (начиная с C ++ 14)</target>
        </trans-unit>
        <trans-unit id="fa031b408b61feecac632070eb11680ef7afef0a" translate="yes" xml:space="preserve">
          <source>a function call expression that calls a function (or a constructor) that is not declared &lt;a href=&quot;constexpr&quot;&gt;constexpr&lt;/a&gt;</source>
          <target state="translated">выражение вызова функции, которое вызывает функцию (или конструктор), которая не объявлена &lt;a href=&quot;constexpr&quot;&gt;constexpr&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="1cc0ab25d190ee32f3fbd65c276911c0bf316acb" translate="yes" xml:space="preserve">
          <source>a function call or an overloaded operator expression, whose return type is lvalue reference, such as &lt;code&gt;&lt;a href=&quot;../string/basic_string/getline&quot;&gt;std::getline&lt;/a&gt;(&lt;a href=&quot;../io/cin&quot;&gt;std::cin&lt;/a&gt;, str)&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../io/cout&quot;&gt;std::cout&lt;/a&gt; &amp;lt;&amp;lt; 1&lt;/code&gt;, &lt;code&gt;str1 = str2&lt;/code&gt;, or &lt;code&gt;++it&lt;/code&gt;;</source>
          <target state="translated">вызов функции или перегруженное выражение оператора, тип возвращаемого значения которого является ссылкой на lvalue, например &lt;code&gt;&lt;a href=&quot;../string/basic_string/getline&quot;&gt;std::getline&lt;/a&gt;(&lt;a href=&quot;../io/cin&quot;&gt;std::cin&lt;/a&gt;, str)&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../io/cout&quot;&gt;std::cout&lt;/a&gt; &amp;lt;&amp;lt; 1&lt;/code&gt; , &lt;code&gt;str1 = str2&lt;/code&gt; или &lt;code&gt;++it&lt;/code&gt; ;</target>
        </trans-unit>
        <trans-unit id="fe3271b2a2bdf8654d96145285508cb27eb7fa3c" translate="yes" xml:space="preserve">
          <source>a function call or an overloaded operator expression, whose return type is non-reference, such as &lt;code&gt;str.substr(1, 2)&lt;/code&gt;, &lt;code&gt;str1 + str2&lt;/code&gt;, or &lt;code&gt;it++&lt;/code&gt;;</source>
          <target state="translated">вызов функции или перегруженное выражение оператора, тип возвращаемого значения которого не является ссылочным, например &lt;code&gt;str.substr(1, 2)&lt;/code&gt; , &lt;code&gt;str1 + str2&lt;/code&gt; или &lt;code&gt;it++&lt;/code&gt; ;</target>
        </trans-unit>
        <trans-unit id="0aac9ce8ff230dee25d75b3c0b2e89e1a93af6fb" translate="yes" xml:space="preserve">
          <source>a function call or an overloaded operator expression, whose return type is rvalue reference to function;</source>
          <target state="translated">вызов функции или перегруженное выражение оператора,типом возврата которого является ссылка на функцию по значению rvalue;</target>
        </trans-unit>
        <trans-unit id="06b3616b9a0b9e911ad389bfd163627a7c1c34bc" translate="yes" xml:space="preserve">
          <source>a function call or an overloaded operator expression, whose return type is rvalue reference to object, such as &lt;code&gt;std::move(x)&lt;/code&gt;;</source>
          <target state="translated">вызов функции или перегруженное выражение оператора, тип возвращаемого значения которого является rvalue ссылкой на объект, такой как &lt;code&gt;std::move(x)&lt;/code&gt; ;</target>
        </trans-unit>
        <trans-unit id="89282f06fce2e206dcc5d91b9a98ea7c21e34204" translate="yes" xml:space="preserve">
          <source>a function call to a &lt;code&gt;constexpr&lt;/code&gt; function which is declared, but not defined</source>
          <target state="translated">вызов функции для функции &lt;code&gt;constexpr&lt;/code&gt; , которая объявлена, но не определена</target>
        </trans-unit>
        <trans-unit id="10915ad1ef913f2efda469b6ef4db5fda7260bf8" translate="yes" xml:space="preserve">
          <source>a function call to a &lt;code&gt;constexpr&lt;/code&gt; function/constructor template instantiation where the instantiation fails to satisfy &lt;a href=&quot;constexpr&quot;&gt;constexpr function/constructor&lt;/a&gt; requirements.</source>
          <target state="translated">вызов функции для экземпляра шаблона функции / конструктора &lt;code&gt;constexpr&lt;/code&gt; , где экземпляр не удовлетворяет &lt;a href=&quot;constexpr&quot;&gt;требованиям к функции / конструктору constexpr&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1a1e14620347e6a891947bb343ed08d832b480d5" translate="yes" xml:space="preserve">
          <source>a function object type. The behavior is undefined if its return type is not one of the five comparison category types (strong_equality, weak_equality, strong_ordering, weak_ordering, or partial_ordering)</source>
          <target state="translated">тип объекта функции.Поведение не определено,если возвращаемый тип не является одним из пяти типов категории сравнения (strong_equality,weak_equality,strong_ordering,weak_ordering или partial_ordering).</target>
        </trans-unit>
        <trans-unit id="8d0e3c882e6f573300e1c9692eab26458b8cdc46" translate="yes" xml:space="preserve">
          <source>a function type whose exception specification is value-dependent</source>
          <target state="translated">тип функции,спецификация исключения которой зависит от значения</target>
        </trans-unit>
        <trans-unit id="e47b118e9260ac46b886dbed4343d2d945bd3192" translate="yes" xml:space="preserve">
          <source>a glvalue</source>
          <target state="translated">клейкая ценность</target>
        </trans-unit>
        <trans-unit id="7ba358203ed2199073a8967bad6e8c7ab1203303" translate="yes" xml:space="preserve">
          <source>a glvalue (&amp;ldquo;generalized&amp;rdquo; lvalue) is an expression whose evaluation determines the identity of an object, bit-field, or function;</source>
          <target state="translated">glvalue (&amp;laquo;обобщенное&amp;raquo; lvalue) - это выражение, оценка которого определяет идентичность объекта, битового поля или функции;</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
