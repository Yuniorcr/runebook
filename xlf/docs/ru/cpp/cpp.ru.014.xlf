<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="cpp">
    <body>
      <group id="cpp">
        <trans-unit id="8b3f01687d89feac7cfe2128cd7fb4336c3f52ee" translate="yes" xml:space="preserve">
          <source>Errors and special cases are handled as if the operation is implemented by &lt;code&gt;&lt;a href=&quot;../math/exp&quot;&gt;std::exp&lt;/a&gt;(y*&lt;a href=&quot;../math/log&quot;&gt;std::log&lt;/a&gt;(x))&lt;/code&gt;.</source>
          <target state="translated">Ошибки и особые случаи обрабатываются так, как будто операция реализована с помощью &lt;code&gt;&lt;a href=&quot;../math/exp&quot;&gt;std::exp&lt;/a&gt;(y*&lt;a href=&quot;../math/log&quot;&gt;std::log&lt;/a&gt;(x))&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d8eceb47949f152b23fef3272be167f4940d38aa" translate="yes" xml:space="preserve">
          <source>Errors and special cases are handled as if the operation is implemented by &lt;code&gt;&lt;a href=&quot;cosh&quot;&gt;std::cosh&lt;/a&gt;(i*z)&lt;/code&gt;, where &lt;code&gt;i&lt;/code&gt; is the imaginary unit.</source>
          <target state="translated">Ошибки и особые случаи обрабатываются так, как будто операция реализуется с помощью &lt;code&gt;&lt;a href=&quot;cosh&quot;&gt;std::cosh&lt;/a&gt;(i*z)&lt;/code&gt; , где &lt;code&gt;i&lt;/code&gt; - мнимая единица.</target>
        </trans-unit>
        <trans-unit id="2ab0e556309413233a2f6554e50dca392be2f614" translate="yes" xml:space="preserve">
          <source>Errors are reported as specified in &lt;code&gt;&lt;a href=&quot;math_errhandling&quot;&gt;math_errhandling&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Ошибки сообщаются как указано в &lt;code&gt;&lt;a href=&quot;math_errhandling&quot;&gt;math_errhandling&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7331ffbc406cc972b5f70c046e3dc2cb4171b6f9" translate="yes" xml:space="preserve">
          <source>Errors are reported consistent with &lt;a href=&quot;../math/math_errhandling&quot;&gt;math_errhandling&lt;/a&gt;.</source>
          <target state="translated">Об ошибках сообщается в соответствии с &lt;a href=&quot;../math/math_errhandling&quot;&gt;math_errhandling&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ed0e29a499e18c343b1b41bf866f5a04007120ed" translate="yes" xml:space="preserve">
          <source>Errors are reported consistent with &lt;code&gt;&lt;a href=&quot;../math/math_errhandling&quot;&gt;math_errhandling&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Об ошибках сообщается в соответствии с &lt;code&gt;&lt;a href=&quot;../math/math_errhandling&quot;&gt;math_errhandling&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5864985afc7c53fae220dc47110ea05595ec5f47" translate="yes" xml:space="preserve">
          <source>Errors may be reported as specified in &lt;a href=&quot;../math/math_errhandling&quot;&gt;math_errhandling&lt;/a&gt;.</source>
          <target state="translated">Ошибки могут сообщаться, как указано в &lt;a href=&quot;../math/math_errhandling&quot;&gt;math_errhandling&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ee99754a522541dd514fb00437ecaa5173a3680b" translate="yes" xml:space="preserve">
          <source>Errors that arise during exception handling are handled by &lt;code&gt;&lt;a href=&quot;../error/terminate&quot;&gt;std::terminate&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../error/exception/unexpected&quot;&gt;std::unexpected&lt;/a&gt;&lt;/code&gt;(until C++17).</source>
          <target state="translated">Ошибки, возникающие во время обработки исключений, обрабатываются &lt;code&gt;&lt;a href=&quot;../error/terminate&quot;&gt;std::terminate&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;../error/exception/unexpected&quot;&gt;std::unexpected&lt;/a&gt;&lt;/code&gt; (до C ++ 17).</target>
        </trans-unit>
        <trans-unit id="b4cfe1f435f06beaae8e7d7c6d43e5dddbe640bb" translate="yes" xml:space="preserve">
          <source>Escape</source>
          <target state="translated">Escape</target>
        </trans-unit>
        <trans-unit id="aa094bf265d4ea86b5f894d7a380cedfb2baed9e" translate="yes" xml:space="preserve">
          <source>Escape sequences</source>
          <target state="translated">Побеговые последовательности</target>
        </trans-unit>
        <trans-unit id="bd56cff3676fe902e346c447da9fdfeeaa8307a3" translate="yes" xml:space="preserve">
          <source>Escape sequences are used to represent certain special characters within &lt;a href=&quot;string_literal&quot;&gt;string literals&lt;/a&gt; and &lt;a href=&quot;character_literal&quot;&gt;character literals&lt;/a&gt;.</source>
          <target state="translated">Escape-последовательности используются для представления определенных специальных символов в &lt;a href=&quot;string_literal&quot;&gt;строковых литералах&lt;/a&gt; и &lt;a href=&quot;character_literal&quot;&gt;символьных литералах&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f742a88872219830426d31bbcd98064272e610fb" translate="yes" xml:space="preserve">
          <source>Essentially, &lt;code&gt;E1&lt;/code&gt; is evaluated and discarded in both cases; 2) if &lt;code&gt;E2&lt;/code&gt; is a &lt;a href=&quot;data_members&quot;&gt;non-static data member&lt;/a&gt;:</source>
          <target state="translated">По сути, &lt;code&gt;E1&lt;/code&gt; оценивается и отбрасывается в обоих случаях; 2) если &lt;code&gt;E2&lt;/code&gt; является &lt;a href=&quot;data_members&quot;&gt;нестатическим членом данных&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="cff4774a9f4e9cd8077ee08295f533dd38074331" translate="yes" xml:space="preserve">
          <source>Establishes &lt;a href=&quot;https://en.wikipedia.org/wiki/Strict_weak_ordering&quot;&gt;strict weak ordering&lt;/a&gt; relation with the following properties</source>
          <target state="translated">Устанавливает &lt;a href=&quot;https://en.wikipedia.org/wiki/Strict_weak_ordering&quot;&gt;строгие&lt;/a&gt; отношения слабого порядка со следующими свойствами</target>
        </trans-unit>
        <trans-unit id="852a89d52bfbfe13219c2f99e5bebf530d7e1264" translate="yes" xml:space="preserve">
          <source>Establishes &lt;a href=&quot;memory_order&quot;&gt;memory synchronization ordering&lt;/a&gt; of non-atomic and relaxed atomic accesses, as instructed by &lt;code&gt;order&lt;/code&gt;, without an associated atomic operation.</source>
          <target state="translated">Устанавливает &lt;a href=&quot;memory_order&quot;&gt;порядок синхронизации памяти неатомарного&lt;/a&gt; и расслабленного атомного доступа, как указано в &lt;code&gt;order&lt;/code&gt; , без связанной атомарной операции.</target>
        </trans-unit>
        <trans-unit id="f3f364090d806d3b0cee66b4e00edd9582f9bb6b" translate="yes" xml:space="preserve">
          <source>Establishes an &lt;a href=&quot;https://en.wikipedia.org/wiki/Equivalence_relation&quot;&gt;equivalence relation&lt;/a&gt;, that is, it satisfies the following properties:</source>
          <target state="translated">Устанавливает &lt;a href=&quot;https://en.wikipedia.org/wiki/Equivalence_relation&quot;&gt;отношение эквивалентности&lt;/a&gt; , то есть удовлетворяет следующим свойствам:</target>
        </trans-unit>
        <trans-unit id="8d058e497d38c36626918d3f0a58443807999d35" translate="yes" xml:space="preserve">
          <source>Establishes an equivalence relation. Returns &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;x.param() == y.param()&lt;/code&gt; and future infinite sequences of values that would be generated by repeated invocations of &lt;code&gt;x(g1)&lt;/code&gt; and &lt;code&gt;y(g2)&lt;/code&gt; would be equal as long as &lt;code&gt;g1 == g2&lt;/code&gt;.</source>
          <target state="translated">Устанавливает отношение эквивалентности. Возвращает &lt;code&gt;true&lt;/code&gt; , если &lt;code&gt;x.param() == y.param()&lt;/code&gt; и будущие бесконечные последовательности значений, которые будут сгенерированы повторными вызовами &lt;code&gt;x(g1)&lt;/code&gt; и &lt;code&gt;y(g2)&lt;/code&gt; , будут равны, если &lt;code&gt;g1 == g2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="224e99f2262d85ee9bdcb40ff75322e28286d665" translate="yes" xml:space="preserve">
          <source>Establishes an exception handler around the body of a function.</source>
          <target state="translated">Создает обработчик исключений вокруг тела функции.</target>
        </trans-unit>
        <trans-unit id="2c8128bfda4d0efc1187706eb75c4af98c699f3e" translate="yes" xml:space="preserve">
          <source>Establishes equivalence relationship with the following properties</source>
          <target state="translated">Устанавливает отношения эквивалентности со следующими свойствами</target>
        </trans-unit>
        <trans-unit id="a0a813deb9e43ef1c13a8996290d00b720e38940" translate="yes" xml:space="preserve">
          <source>Establishes memory synchronization ordering of non-atomic and relaxed atomic accesses, as instructed by &lt;code&gt;order&lt;/code&gt;, between a thread and a signal handler executed on the same thread. This is equivalent to &lt;code&gt;&lt;a href=&quot;atomic_thread_fence&quot;&gt;std::atomic_thread_fence&lt;/a&gt;&lt;/code&gt;, except no CPU instructions for memory ordering are issued. Only reordering of the instructions by the compiler is suppressed as &lt;code&gt;order&lt;/code&gt; instructs. For example, a fence with release semantics prevents reads or writes from being moved past subsequent writes and a fence with acquire semantics prevents reads or writes from being moved ahead of preceding reads.</source>
          <target state="translated">Устанавливает порядок синхронизации памяти неатомарного и расслабленного атомарного доступа, как указано в &lt;code&gt;order&lt;/code&gt; , между потоком и обработчиком сигнала, выполняемым в одном потоке. Это эквивалентно &lt;code&gt;&lt;a href=&quot;atomic_thread_fence&quot;&gt;std::atomic_thread_fence&lt;/a&gt;&lt;/code&gt; , за исключением того, что не выдаются инструкции процессора для упорядочения памяти. Только переупорядочивание инструкций компилятором подавляется в &lt;code&gt;order&lt;/code&gt; указаниями порядка . Например, ограничитель с семантикой выпуска предотвращает перемещение операций чтения или записи после последующих записей, а ограничитель с семантикой получения предотвращает перемещение операций чтения или записи перед предшествующими операциями чтения.</target>
        </trans-unit>
        <trans-unit id="557e271e8a3a0cf9ee786e9ab59e8bf077dde9c7" translate="yes" xml:space="preserve">
          <source>Estimates the number of characters available for input in the associated character sequence. &lt;code&gt;&lt;a href=&quot;underflow&quot;&gt;underflow()&lt;/a&gt;&lt;/code&gt; is guaranteed not to return &lt;code&gt;Traits::eof()&lt;/code&gt; or throw an exception until at least that many characters are extracted.</source>
          <target state="translated">Оценивает количество символов, доступных для ввода в связанной последовательности символов. &lt;code&gt;&lt;a href=&quot;underflow&quot;&gt;underflow()&lt;/a&gt;&lt;/code&gt; гарантированно не возвращает &lt;code&gt;Traits::eof()&lt;/code&gt; и не генерирует исключение, пока не будет извлечено как минимум столько символов.</target>
        </trans-unit>
        <trans-unit id="5ad645d0b6cf4e8f2f0f5a5463bf7ca6f9950d22" translate="yes" xml:space="preserve">
          <source>Euclidean norm</source>
          <target state="translated">евклидовая норма</target>
        </trans-unit>
        <trans-unit id="da7594d31984baf99a077013f0aee618827920d2" translate="yes" xml:space="preserve">
          <source>Evaluation order and sequencing</source>
          <target state="translated">Порядок и последовательность оценки</target>
        </trans-unit>
        <trans-unit id="f6b2d28039057e6a76561c58410eb4f016c0728f" translate="yes" xml:space="preserve">
          <source>Even before allocator support was removed from &lt;code&gt;std::function&lt;/code&gt; in C++17, these assignment operators use the default allocator rather than the allocator of &lt;code&gt;*this&lt;/code&gt; or the allocator of &lt;code&gt;other&lt;/code&gt; (see &lt;a href=&quot;http://open-std.org/JTC1/SC22/WG21/docs/lwg-closed.html#2386&quot;&gt;LWG #2386&lt;/a&gt;).</source>
          <target state="translated">Даже до того, как поддержка распределителя была удалена из &lt;code&gt;std::function&lt;/code&gt; в C ++ 17, эти операторы присваивания используют распределитель по умолчанию, а не распределитель &lt;code&gt;*this&lt;/code&gt; или распределитель &lt;code&gt;other&lt;/code&gt; (см. &lt;a href=&quot;http://open-std.org/JTC1/SC22/WG21/docs/lwg-closed.html#2386&quot;&gt;LWG # 2386&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="5bf28a5cb25e295e74fa193c881e4823ae53ebb2" translate="yes" xml:space="preserve">
          <source>Even if &lt;code&gt;ymd.ok()&lt;/code&gt; is true, the resulting &lt;code&gt;year_month_day&lt;/code&gt; may not represent a valid date if &lt;code&gt;ymd.day()&lt;/code&gt; is 29, 30, or 31.</source>
          <target state="translated">Даже если &lt;code&gt;ymd.ok()&lt;/code&gt; имеет значение true, итоговый &lt;code&gt;year_month_day&lt;/code&gt; может не представлять действительную дату, если &lt;code&gt;ymd.day()&lt;/code&gt; - 29, 30 или 31.</target>
        </trans-unit>
        <trans-unit id="13f714ec21c59f4555ffdd439f65ba1de4339a70" translate="yes" xml:space="preserve">
          <source>Even if &lt;code&gt;ymwd.ok()&lt;/code&gt; is true, the resulting &lt;code&gt;year_month_weekday&lt;/code&gt; may not represent a valid date if &lt;code&gt;ymwd.index()&lt;/code&gt; is 5.</source>
          <target state="translated">Даже если &lt;code&gt;ymwd.ok()&lt;/code&gt; имеет значение true, итоговый &lt;code&gt;year_month_weekday&lt;/code&gt; может не представлять действительную дату, если &lt;code&gt;ymwd.index()&lt;/code&gt; равен 5.</target>
        </trans-unit>
        <trans-unit id="d9c13458a40bd815f989f602ad0395796fb458d9" translate="yes" xml:space="preserve">
          <source>Even if notified under lock, overload (1) makes no guarantees about the state of the associated predicate when returning due to timeout.</source>
          <target state="translated">Даже если уведомление под замком,перегрузка (1)не дает никаких гарантий о состоянии связанного с ней предиката при возвращении из-за таймаута.</target>
        </trans-unit>
        <trans-unit id="e8a756d7fa529afd7aeb13d1511bd134a3d2cc0c" translate="yes" xml:space="preserve">
          <source>Even if the clock in use is &lt;code&gt;&lt;a href=&quot;../../chrono/steady_clock&quot;&gt;std::chrono::steady_clock&lt;/a&gt;&lt;/code&gt; or another monotonic clock, a system clock adjustment may induce a spurious wakeup.</source>
          <target state="translated">Даже если используемые часы являются &lt;code&gt;&lt;a href=&quot;../../chrono/steady_clock&quot;&gt;std::chrono::steady_clock&lt;/a&gt;&lt;/code&gt; или другими монотонными часами, настройка системных часов может вызвать ложное пробуждение.</target>
        </trans-unit>
        <trans-unit id="30fbd007da85ebd7312535e0cc529833d2a4d4fe" translate="yes" xml:space="preserve">
          <source>Even if the name to the left of &lt;code&gt;::&lt;/code&gt; refers to a namespace, the template disambiguator is allowed:</source>
          <target state="translated">Даже если имя слева от &lt;code&gt;::&lt;/code&gt; относится к пространству имен, устранение неоднозначности шаблона допускается:</target>
        </trans-unit>
        <trans-unit id="82ac5cb6cfab85d924b4733697e77158a0419204" translate="yes" xml:space="preserve">
          <source>Even if the shared variable is atomic, it must be modified under the mutex in order to correctly publish the modification to the waiting thread.</source>
          <target state="translated">Даже если общая переменная является атомарной,она должна быть изменена под мьютексом,чтобы корректно опубликовать модификацию в потоке ожидания.</target>
        </trans-unit>
        <trans-unit id="4d9633b8291e518788e5b04c3307f8044e23b7cb" translate="yes" xml:space="preserve">
          <source>Even though &lt;code&gt;%c&lt;/code&gt; expects &lt;code&gt;int&lt;/code&gt; argument, it is safe to pass a &lt;code&gt;char&lt;/code&gt; because of the integer promotion that takes place when a variadic function is called.</source>
          <target state="translated">Несмотря на то, что &lt;code&gt;%c&lt;/code&gt; ожидает аргумент &lt;code&gt;int&lt;/code&gt; , безопасно передавать &lt;code&gt;char&lt;/code&gt; из-за целочисленного преобразования, которое происходит при вызове функции с переменным числом аргументов.</target>
        </trans-unit>
        <trans-unit id="eef899288103457cb2c6536cbb280b5cca3eb991" translate="yes" xml:space="preserve">
          <source>Even though &lt;code&gt;if&lt;/code&gt; is a &lt;a href=&quot;../../keywords/if&quot;&gt;keyword&lt;/a&gt; in C++, it is a ud-suffix of the &lt;a href=&quot;../../language/user_literal&quot;&gt;literal operator&lt;/a&gt; of the form &lt;code&gt;operator &quot;&quot;if&lt;/code&gt; and in the literal expressions such as &lt;code&gt;1if&lt;/code&gt; or &lt;code&gt;1.0if&lt;/code&gt; because it is not separated by whitespace and is not a standalone token.</source>
          <target state="translated">Даже если &lt;code&gt;if&lt;/code&gt; является &lt;a href=&quot;../../keywords/if&quot;&gt;ключевым словом&lt;/a&gt; в C ++, это ud-суффикс &lt;a href=&quot;../../language/user_literal&quot;&gt;литерального оператора оператора&lt;/a&gt; формы &lt;code&gt;operator &quot;&quot;if&lt;/code&gt; и в литеральных выражениях, таких как &lt;code&gt;1if&lt;/code&gt; или &lt;code&gt;1.0if&lt;/code&gt; , потому что он не разделен пробелами и не является автономным токеном. ,</target>
        </trans-unit>
        <trans-unit id="205833ef6be0b707c638302ab3b276a23d851ced" translate="yes" xml:space="preserve">
          <source>Even though &lt;code&gt;try&lt;/code&gt; blocks are allowed in constexpr functions, throwing exceptions is still disallowed in a constant expression.</source>
          <target state="translated">Несмотря на то, что блоки &lt;code&gt;try&lt;/code&gt; разрешены в функциях constexpr, создание исключений все еще запрещено в постоянном выражении.</target>
        </trans-unit>
        <trans-unit id="beca8aa735200901df75e963c1c548f38fd8410f" translate="yes" xml:space="preserve">
          <source>Even though destructors are not inherited, if a base class declares its destructor &lt;code&gt;virtual&lt;/code&gt;, the derived destructor always overrides it. This makes it possible to delete dynamically allocated objects of polymorphic type through pointers to base.</source>
          <target state="translated">Даже если деструкторы не наследуются, если базовый класс объявляет свой &lt;code&gt;virtual&lt;/code&gt; деструктор , производный деструктор всегда переопределяет его. Это позволяет удалять динамически размещенные объекты полиморфного типа через указатели на базу.</target>
        </trans-unit>
        <trans-unit id="fd583cbe0ab59fe4a28f57f7cb504c86fd58cbce" translate="yes" xml:space="preserve">
          <source>Even though names in an unnamed namespace may be declared with external linkage, they are never accessible from other translation units because their namespace name is unique.</source>
          <target state="translated">Несмотря на то,что имена в безымянном пространстве имён могут быть объявлены с помощью внешних ссылок,они никогда не будут доступны из других единиц перевода,поскольку их имя пространства имён уникально.</target>
        </trans-unit>
        <trans-unit id="89f989b918b3efa1509410878202d64feeaad6c7" translate="yes" xml:space="preserve">
          <source>Even though the non-allocating placement new (9,10) cannot be replaced, a function with the same signature may be defined at class scope as described above. In addition, global overloads that look like placement new but take a non-void pointer type as the second argument are allowed, so the code that wants to ensure that the true placement new is called (e.g. &lt;code&gt;&lt;a href=&quot;../allocator/construct&quot;&gt;std::allocator::construct&lt;/a&gt;&lt;/code&gt;), must use &lt;code&gt;::new&lt;/code&gt; and also cast the pointer to &lt;code&gt;void*&lt;/code&gt;.</source>
          <target state="translated">Даже несмотря на то, что неразмещающее размещение new (9,10) не может быть заменено, функция с такой же сигнатурой может быть определена в области видимости класса, как описано выше. Кроме того, допускаются глобальные перегрузки, которые выглядят как размещение нового, но в качестве второго аргумента принимают не указатель типа void, поэтому вызывается код, который хочет гарантировать, что истинное размещение нового вызывается (например, &lt;code&gt;&lt;a href=&quot;../allocator/construct&quot;&gt;std::allocator::construct&lt;/a&gt;&lt;/code&gt; ), должен использовать &lt;code&gt;::new&lt;/code&gt; , а также привести указатель к &lt;code&gt;void*&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f76a45b89412fbbe4ac41ff04a11f89153e89cd3" translate="yes" xml:space="preserve">
          <source>Even though top-level &lt;a href=&quot;cv&quot;&gt;cv-qualifiers&lt;/a&gt; on the parameters are discarded in function declarations, they modify the type of the parameter as visible in the body of a function:</source>
          <target state="translated">Хотя &lt;a href=&quot;cv&quot;&gt;cv-квалификаторы&lt;/a&gt; верхнего уровня для параметров отбрасываются в объявлениях функций, они изменяют тип параметра, видимый в теле функции:</target>
        </trans-unit>
        <trans-unit id="a45dfe469d18cb059aef8c5b79aaf3c568df5677" translate="yes" xml:space="preserve">
          <source>Even when the destructor is called directly (e.g. &lt;code&gt;obj.~Foo();&lt;/code&gt;), the return statement in &lt;code&gt;~Foo()&lt;/code&gt; does not return control to the caller immediately: it calls all those member and base destructors first.</source>
          <target state="translated">Даже когда деструктор вызывается напрямую (например, &lt;code&gt;obj.~Foo();&lt;/code&gt; ), оператор return в &lt;code&gt;~Foo()&lt;/code&gt; не возвращает управление вызывающей стороне немедленно: он сначала вызывает все эти члены и базовые деструкторы.</target>
        </trans-unit>
        <trans-unit id="c457cc0cca53f5efaec11bdae6464c7a8f3d1683" translate="yes" xml:space="preserve">
          <source>Even with relaxed memory model, out-of-thin-air values are not allowed to circularly depend on their own computations, for example, with &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; initially zero,</source>
          <target state="translated">Даже при использовании модели с расслабленной памятью значения не из воздуха не могут циклически зависеть от их собственных вычислений, например, когда &lt;code&gt;x&lt;/code&gt; и &lt;code&gt;y&lt;/code&gt; изначально равны нулю,</target>
        </trans-unit>
        <trans-unit id="0d294028b66fc033fb8f8b33345165f1b149cdc7" translate="yes" xml:space="preserve">
          <source>Every &lt;a href=&quot;objects&quot;&gt;object&lt;/a&gt; and &lt;a href=&quot;reference&quot;&gt;reference&lt;/a&gt; has a</source>
          <target state="translated">Каждый &lt;a href=&quot;objects&quot;&gt;объект&lt;/a&gt; и &lt;a href=&quot;reference&quot;&gt;ссылка&lt;/a&gt; имеет</target>
        </trans-unit>
        <trans-unit id="1e3d5eff0d465c69879e0e0871021f12c2fae6c2" translate="yes" xml:space="preserve">
          <source>Every &lt;a href=&quot;templates&quot;&gt;template&lt;/a&gt; is parametrized by one or more template parameters, indicated in the parameter-list of the template declaration syntax:</source>
          <target state="translated">Каждый &lt;a href=&quot;templates&quot;&gt;шаблон&lt;/a&gt; параметризован одним или несколькими параметрами шаблона, указанными в списке параметров синтаксиса объявления шаблона:</target>
        </trans-unit>
        <trans-unit id="9a47d9aa16911998ba8cb56b9196661886621057" translate="yes" xml:space="preserve">
          <source>Every &lt;a href=&quot;type-id&quot;&gt;object type&lt;/a&gt; has the property called</source>
          <target state="translated">Каждый &lt;a href=&quot;type-id&quot;&gt;тип объекта&lt;/a&gt; имеет свойство с именем</target>
        </trans-unit>
        <trans-unit id="d4c1d197b0b4ce5bf0d47347c3c212d7928dae9a" translate="yes" xml:space="preserve">
          <source>Every call to &lt;code&gt;&lt;a href=&quot;str&quot;&gt;str()&lt;/a&gt;&lt;/code&gt; freezes the stream to preserve the validity of the pointer it returns. To allow the destructor to deallocate the buffer, &lt;code&gt;freeze(false)&lt;/code&gt; needs to be called explicitly.</source>
          <target state="translated">Каждый вызов &lt;code&gt;&lt;a href=&quot;str&quot;&gt;str()&lt;/a&gt;&lt;/code&gt; останавливает поток, чтобы сохранить действительность указателя, который он возвращает. Чтобы деструктор освободил буфер, нужно явно вызвать &lt;code&gt;freeze(false)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="267f5eca029a0473ad86866143a283d6e67dc0cd" translate="yes" xml:space="preserve">
          <source>Every catch-clause in the function-try-block for a constructor must terminate by throwing an exception. If the control reaches the end of such handler, the current exception is automatically rethrown as if by &lt;code&gt;throw;&lt;/code&gt;. The return statement is not allowed in any catch clause of a constructor's function-try-block.</source>
          <target state="translated">Каждое catch-предложение в функции-try-block для конструктора должно завершаться с помощью исключения. Если элемент управления достигает конца такого обработчика, текущее исключение автоматически перебрасывается, как будто с помощью &lt;code&gt;throw;&lt;/code&gt; , Оператор return недопустим в любом предложении catch функции-try-block конструктора.</target>
        </trans-unit>
        <trans-unit id="40c918ca9b8fb74eddbf2e3635eb193312898d9a" translate="yes" xml:space="preserve">
          <source>Every character &lt;code&gt;c&lt;/code&gt; obtained in Stage 1, other than the decimal point &lt;code&gt;'.'&lt;/code&gt;, is converted to &lt;code&gt;CharT&lt;/code&gt; by calling &lt;code&gt;&lt;a href=&quot;../use_facet&quot;&gt;std::use_facet&lt;/a&gt;&amp;lt;&lt;a href=&quot;../ctype&quot;&gt;std::ctype&lt;/a&gt;&amp;lt;CharT&amp;gt;&amp;gt;(str.getloc()).widen(c)&lt;/code&gt;.</source>
          <target state="translated">Каждый символ &lt;code&gt;c&lt;/code&gt; , полученный на этапе 1, кроме десятичной точки &lt;code&gt;'.'&lt;/code&gt; , преобразуется в &lt;code&gt;CharT&lt;/code&gt; путем вызова &lt;code&gt;&lt;a href=&quot;../use_facet&quot;&gt;std::use_facet&lt;/a&gt;&amp;lt;&lt;a href=&quot;../ctype&quot;&gt;std::ctype&lt;/a&gt;&amp;lt;CharT&amp;gt;&amp;gt;(str.getloc()).widen(c)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="55240b46d1b2c778147a32f69f02140623223676" translate="yes" xml:space="preserve">
          <source>Every copy assignment operator is &lt;a href=&quot;../language/as_operator#Trivial_copy_assignment_operator&quot;&gt;trivial&lt;/a&gt; or deleted</source>
          <target state="translated">Каждый оператор присваивания копии является &lt;a href=&quot;../language/as_operator#Trivial_copy_assignment_operator&quot;&gt;тривиальным&lt;/a&gt; или удаленным</target>
        </trans-unit>
        <trans-unit id="44ece2209b7a05d39c75b1dcbb965646849a11d9" translate="yes" xml:space="preserve">
          <source>Every copy constructor is &lt;a href=&quot;../language/copy_constructor#Trivial_copy_constructor&quot;&gt;trivial&lt;/a&gt; or deleted</source>
          <target state="translated">Каждый конструктор копирования &lt;a href=&quot;../language/copy_constructor#Trivial_copy_constructor&quot;&gt;тривиален&lt;/a&gt; или удален</target>
        </trans-unit>
        <trans-unit id="ddca33bae1f5063131bf99b04d54385eb0d2361a" translate="yes" xml:space="preserve">
          <source>Every coroutine must have a return type that satisfies a number of requirements, noted below.</source>
          <target state="translated">Каждый корутин должен иметь тип возврата,который удовлетворяет ряду требований,указанных ниже.</target>
        </trans-unit>
        <trans-unit id="6f0b1e2abf2c7b435c80221dcc61afd569006cf6" translate="yes" xml:space="preserve">
          <source>Every direct base of &lt;code&gt;T&lt;/code&gt; has a trivial default constructor</source>
          <target state="translated">Каждая прямая база &lt;code&gt;T&lt;/code&gt; имеет тривиальный конструктор по умолчанию</target>
        </trans-unit>
        <trans-unit id="e4f4a9e39d552d4d3b8434b290840e0cb2a72f79" translate="yes" xml:space="preserve">
          <source>Every expression required to be equality preserving is further required to be</source>
          <target state="translated">Каждое выражение,требующееся для сохранения равенства,должно быть следующим</target>
        </trans-unit>
        <trans-unit id="596cadab563dc077013bb82171b4d411422fe26e" translate="yes" xml:space="preserve">
          <source>Every function in C++ is either</source>
          <target state="translated">Каждая функция на C++</target>
        </trans-unit>
        <trans-unit id="2e5a037bddcba35d74d8f0e90f7f426c42f8bbb7" translate="yes" xml:space="preserve">
          <source>Every function type, every function name with &lt;a href=&quot;storage_duration&quot;&gt;external linkage&lt;/a&gt;, and every variable name with &lt;a href=&quot;storage_duration&quot;&gt;external linkage&lt;/a&gt;, has a property called</source>
          <target state="translated">Каждый тип функции, каждое имя функции с &lt;a href=&quot;storage_duration&quot;&gt;внешней связью&lt;/a&gt; и каждое имя переменной с &lt;a href=&quot;storage_duration&quot;&gt;внешней связью&lt;/a&gt; имеет свойство, называемое</target>
        </trans-unit>
        <trans-unit id="9220204e7dd00c7e1b3f8ea123e9b7a6432dc43a" translate="yes" xml:space="preserve">
          <source>Every initializer clause is &lt;a href=&quot;eval_order&quot;&gt;sequenced before&lt;/a&gt; any initializer clause that follows it in the braced-init-list. This is in contrast with the arguments of a &lt;a href=&quot;operator_other#Built-in_function_call_operator&quot;&gt;function call expression&lt;/a&gt;, which are &lt;a href=&quot;eval_order&quot;&gt;unsequenced&lt;/a&gt;.</source>
          <target state="translated">Каждое предложение инициализатора &lt;a href=&quot;eval_order&quot;&gt;упорядочено перед&lt;/a&gt; любым предложением инициализатора, которое следует за ним в фигурном списке инициализации. Это противоречит аргументам &lt;a href=&quot;operator_other#Built-in_function_call_operator&quot;&gt;выражения вызова функции&lt;/a&gt; , которые не &lt;a href=&quot;eval_order&quot;&gt;упорядочены&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e6ec13c0519794ea073e3092993cf4c79e0a531c" translate="yes" xml:space="preserve">
          <source>Every move assignment operator is &lt;a href=&quot;../language/move_operator#Trivial_move_assignment_operator&quot;&gt;trivial&lt;/a&gt; or deleted</source>
          <target state="translated">Каждый оператор назначения перемещения &lt;a href=&quot;../language/move_operator#Trivial_move_assignment_operator&quot;&gt;тривиален&lt;/a&gt; или удален</target>
        </trans-unit>
        <trans-unit id="be04d7a82c5aad5c68ef07fc699cbbb387d1c3f3" translate="yes" xml:space="preserve">
          <source>Every move constructor is &lt;a href=&quot;../language/move_constructor#Trivial_move_constructor&quot;&gt;trivial&lt;/a&gt; or deleted</source>
          <target state="translated">Каждый шаг конструктора &lt;a href=&quot;../language/move_constructor#Trivial_move_constructor&quot;&gt;тривиален&lt;/a&gt; или удален</target>
        </trans-unit>
        <trans-unit id="cec5230f04de71fff49fd937f9a018fd570d7a46" translate="yes" xml:space="preserve">
          <source>Every name that denotes an entity is introduced into the program by a &lt;a href=&quot;declarations&quot;&gt;declaration&lt;/a&gt;. Every name that denotes a label is introduced into the program either by a &lt;a href=&quot;goto&quot;&gt;goto statement&lt;/a&gt; or by a &lt;a href=&quot;statements#Labels&quot;&gt;labeled statement&lt;/a&gt;. A name used in more than one translation unit may refer to the same or different entities, depending on &lt;a href=&quot;storage_duration#Linkage&quot;&gt;linkage&lt;/a&gt;.</source>
          <target state="translated">Каждое имя, которое обозначает сущность, вводится в программу посредством &lt;a href=&quot;declarations&quot;&gt;объявления&lt;/a&gt; . Каждое имя, которое обозначает метку, вводится в программу либо с помощью &lt;a href=&quot;goto&quot;&gt;оператора goto,&lt;/a&gt; либо с помощью оператора с &lt;a href=&quot;statements#Labels&quot;&gt;меткой&lt;/a&gt; . Имя, используемое в нескольких единицах перевода, может относиться к одним и тем же или различным объектам, в зависимости от &lt;a href=&quot;storage_duration#Linkage&quot;&gt;связи&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b69a8648e61c5f2cb090d5c8ee69368fecb775bd" translate="yes" xml:space="preserve">
          <source>Every non-static data member of &lt;code&gt;&lt;i&gt;E&lt;/i&gt;&lt;/code&gt; must be a direct member of &lt;code&gt;&lt;i&gt;E&lt;/i&gt;&lt;/code&gt; or the same base class of &lt;code&gt;&lt;i&gt;E&lt;/i&gt;&lt;/code&gt;, and must be well-formed in the context of the structured binding when named as &lt;code&gt;&lt;i&gt;&lt;b&gt;e&lt;/b&gt;&lt;/i&gt;.&lt;i&gt;name&lt;/i&gt;&lt;/code&gt;. &lt;code&gt;&lt;i&gt;E&lt;/i&gt;&lt;/code&gt; may not have an anonymous union member. The number of identifiers must equal the number of non-static data members.</source>
          <target state="translated">Каждый нестатический член данных &lt;code&gt;&lt;i&gt;E&lt;/i&gt;&lt;/code&gt; должен быть прямым членом &lt;code&gt;&lt;i&gt;E&lt;/i&gt;&lt;/code&gt; или того же базового класса &lt;code&gt;&lt;i&gt;E&lt;/i&gt;&lt;/code&gt; и должен быть правильно сформирован в контексте структурированной привязки, когда назван как &lt;code&gt;&lt;i&gt;&lt;b&gt;e&lt;/b&gt;&lt;/i&gt;.&lt;i&gt;name&lt;/i&gt;&lt;/code&gt; . &lt;code&gt;&lt;i&gt;E&lt;/i&gt;&lt;/code&gt; может не иметь анонимного члена профсоюза. Количество идентификаторов должно равняться количеству нестатических элементов данных.</target>
        </trans-unit>
        <trans-unit id="b87d3e4870484b5764d76023f3269d280331e5c7" translate="yes" xml:space="preserve">
          <source>Every non-static member of class type has a trivial default constructor</source>
          <target state="translated">Каждый нестатический член типа класса имеет тривиальный конструктор по умолчанию</target>
        </trans-unit>
        <trans-unit id="2ce1bf1bc0be1980d77a06eeb4de4b342c337db3" translate="yes" xml:space="preserve">
          <source>Every standard library component that may need to allocate or release storage, from &lt;code&gt;std::string&lt;/code&gt;, &lt;code&gt;std::vector&lt;/code&gt;, and every container except &lt;code&gt;std::array&lt;/code&gt;, to &lt;code&gt;std::shared_ptr&lt;/code&gt; and &lt;code&gt;std::function&lt;/code&gt;, does so through an &lt;strong&gt;Allocator&lt;/strong&gt;: an object of a class type that satisfies the following requirements.</source>
          <target state="translated">Каждый стандартный компонент библиотеки, которому может потребоваться выделить или освободить хранилище, от &lt;code&gt;std::string&lt;/code&gt; , &lt;code&gt;std::vector&lt;/code&gt; и каждого контейнера, кроме &lt;code&gt;std::array&lt;/code&gt; , до &lt;code&gt;std::shared_ptr&lt;/code&gt; и &lt;code&gt;std::function&lt;/code&gt; , делает это через &lt;strong&gt;Allocator&lt;/strong&gt; : объект типа класса, который удовлетворяет следующим требованиям.</target>
        </trans-unit>
        <trans-unit id="2cf1b35b018fe1d430f2ed7ed9345dcf2146ab69" translate="yes" xml:space="preserve">
          <source>Every stream I/O function if an exception is thrown by any member function of the associated stream buffer (e.g. sbumpc(), xsputn(), sgetc(), overflow(), etc)</source>
          <target state="translated">Каждая функция ввода/вывода потока,если исключение выбрасывается любой функцией-членом соответствующего буфера потока (например,sbumpc(),xsputn(),sgetc(),overflow(),и т.д.)</target>
        </trans-unit>
        <trans-unit id="b09575dd9bf238348e1eb74acc65642a4f28513f" translate="yes" xml:space="preserve">
          <source>Every successive character &lt;code&gt;c&lt;/code&gt; from the sequence of CharT's from Stage 3 is output as if by &lt;code&gt;*out++ = c&lt;/code&gt;.</source>
          <target state="translated">Каждый последующий символ &lt;code&gt;c&lt;/code&gt; из последовательности CharT из Стадии 3 выводится, как если бы &lt;code&gt;*out++ = c&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fa77f47a69b4e10cfca826c1e3a0f4dc9c68af3b" translate="yes" xml:space="preserve">
          <source>Every value of pointer type is one of the following:</source>
          <target state="translated">Каждое значение типа указателя является одним из следующих:</target>
        </trans-unit>
        <trans-unit id="2711daf557af7651a60993264c29beb1d7e39e00" translate="yes" xml:space="preserve">
          <source>Everything about the actual allocation details of bit fields within the class object</source>
          <target state="translated">Всё,что связано с фактическими деталями распределения битовых полей внутри объекта класса</target>
        </trans-unit>
        <trans-unit id="17a1a39f3910e68bd1f80c1b610bdc32df68bf11" translate="yes" xml:space="preserve">
          <source>Everywhere the standard library uses the &lt;a href=&quot;../named_req/compare&quot;&gt;Compare&lt;/a&gt; requirements, equivalence is determined by using the equivalence relation as described on &lt;a href=&quot;../named_req/compare&quot;&gt;Compare&lt;/a&gt;. In imprecise terms, two objects &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; are considered equivalent if neither compares less than the other: &lt;code&gt;!comp(a, b) &amp;amp;&amp;amp;&amp;nbsp;!comp(b, a)&lt;/code&gt;.</source>
          <target state="translated">Везде, где стандартная библиотека использует требования &lt;a href=&quot;../named_req/compare&quot;&gt;Сравнения&lt;/a&gt; , эквивалентность определяется с помощью отношения эквивалентности, как описано в &lt;a href=&quot;../named_req/compare&quot;&gt;Сравнении&lt;/a&gt; . В неточных терминах два объекта &lt;code&gt;a&lt;/code&gt; и &lt;code&gt;b&lt;/code&gt; считаются эквивалентными, если ни один из них не сравнивается меньше, чем другой &lt;code&gt;!comp(a, b) &amp;amp;&amp;amp;&amp;nbsp;!comp(b, a)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6b75c2f9b6cdfbe488daafdef876670cbfaba7ec" translate="yes" xml:space="preserve">
          <source>Everywhere the standard library uses the &lt;a href=&quot;../named_req/compare&quot;&gt;Compare&lt;/a&gt; requirements, uniqueness is determined by using the equivalence relation. In imprecise terms, two objects &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; are considered equivalent (not unique) if neither compares less than the other: &lt;code&gt;!comp(a, b) &amp;amp;&amp;amp;&amp;nbsp;!comp(b, a)&lt;/code&gt;.</source>
          <target state="translated">Везде, где стандартная библиотека использует требования &lt;a href=&quot;../named_req/compare&quot;&gt;сравнения&lt;/a&gt; , уникальность определяется с помощью отношения эквивалентности. В неточных терминах два объекта &lt;code&gt;a&lt;/code&gt; и &lt;code&gt;b&lt;/code&gt; считаются эквивалентными (не уникальными), если ни один из них не сравнивается меньше, чем другой &lt;code&gt;!comp(a, b) &amp;amp;&amp;amp;&amp;nbsp;!comp(b, a)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b615d029d5b8025e266ba5a37f8108df4dbd2078" translate="yes" xml:space="preserve">
          <source>Everywhere the standard library uses the &lt;a href=&quot;../named_req/compare&quot;&gt;Compare&lt;/a&gt; requirements, uniqueness is determined by using the equivalence relation. In imprecise terms, two objects &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; are considered equivalent if neither compares less than the other: &lt;code&gt;!comp(a, b) &amp;amp;&amp;amp;&amp;nbsp;!comp(b, a)&lt;/code&gt;.</source>
          <target state="translated">Везде, где стандартная библиотека использует требования &lt;a href=&quot;../named_req/compare&quot;&gt;сравнения&lt;/a&gt; , уникальность определяется с помощью отношения эквивалентности. В неточных терминах два объекта &lt;code&gt;a&lt;/code&gt; и &lt;code&gt;b&lt;/code&gt; считаются эквивалентными, если ни один из них не сравнивается меньше, чем другой &lt;code&gt;!comp(a, b) &amp;amp;&amp;amp;&amp;nbsp;!comp(b, a)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0cae74747ce921ce4dc2761826efeaa22990fc6f" translate="yes" xml:space="preserve">
          <source>Exact</source>
          <target state="translated">Exact</target>
        </trans-unit>
        <trans-unit id="b73dce3ae50ecab687b47c8e8958379cbaf57ff0" translate="yes" xml:space="preserve">
          <source>Exactly &lt;code&gt;(last - first) - 1&lt;/code&gt; applications of the binary operation.</source>
          <target state="translated">Точно &lt;code&gt;(last - first) - 1&lt;/code&gt; приложение бинарной операции.</target>
        </trans-unit>
        <trans-unit id="4db39051f1f33d287e9bf44fd101eccfd97335d2" translate="yes" xml:space="preserve">
          <source>Exactly &lt;code&gt;(last - first)/2&lt;/code&gt; swaps.</source>
          <target state="translated">Точно &lt;code&gt;(last - first)/2&lt;/code&gt; свопа.</target>
        </trans-unit>
        <trans-unit id="999c7ba21fe6cfdf477efe576e8b30044ac5b242" translate="yes" xml:space="preserve">
          <source>Exactly &lt;code&gt;&lt;a href=&quot;../iterator/distance&quot;&gt;std::distance&lt;/a&gt;(first, last)&lt;/code&gt; applications of the predicate.</source>
          <target state="translated">Именно &lt;code&gt;&lt;a href=&quot;../iterator/distance&quot;&gt;std::distance&lt;/a&gt;(first, last)&lt;/code&gt; приложения предиката.</target>
        </trans-unit>
        <trans-unit id="1fc8a6d486ec5aab15a1c1be51264f79f56fc49b" translate="yes" xml:space="preserve">
          <source>Exactly &lt;code&gt;&lt;a href=&quot;../iterator/distance&quot;&gt;std::distance&lt;/a&gt;(first, last)&lt;/code&gt; invocations of &lt;code&gt;g()&lt;/code&gt; and assignments.</source>
          <target state="translated">Именно &lt;code&gt;&lt;a href=&quot;../iterator/distance&quot;&gt;std::distance&lt;/a&gt;(first, last)&lt;/code&gt; вызовы &lt;code&gt;g()&lt;/code&gt; и присваивания.</target>
        </trans-unit>
        <trans-unit id="35529081f2f26b1b90fd973935838e5852bc467d" translate="yes" xml:space="preserve">
          <source>Exactly &lt;code&gt;count&lt;/code&gt; assignments, for &lt;code&gt;count &amp;gt; 0&lt;/code&gt;.</source>
          <target state="translated">Точное &lt;code&gt;count&lt;/code&gt; назначений, для &lt;code&gt;count &amp;gt; 0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5a8809cf33804ae021cd515fa06675d07f185d82" translate="yes" xml:space="preserve">
          <source>Exactly &lt;code&gt;count&lt;/code&gt; assignments, if &lt;code&gt;count&amp;gt;0&lt;/code&gt;.</source>
          <target state="translated">Точное &lt;code&gt;count&lt;/code&gt; назначений, если &lt;code&gt;count&amp;gt;0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f0e851801f10602f0a4225377722df5cf5583ba1" translate="yes" xml:space="preserve">
          <source>Exactly &lt;code&gt;count&lt;/code&gt; invocations of &lt;code&gt;g()&lt;/code&gt; and assignments, for &lt;code&gt;count&amp;gt;0&lt;/code&gt;.</source>
          <target state="translated">Точно &lt;code&gt;count&lt;/code&gt; вызовы &lt;code&gt;g()&lt;/code&gt; и присваивания, для &lt;code&gt;count&amp;gt;0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9e8a97940b9961f72ad69126c982a5fb916192e8" translate="yes" xml:space="preserve">
          <source>Exactly &lt;code&gt;distance(first, last)&lt;/code&gt; applications of &lt;code&gt;p&lt;/code&gt;.</source>
          <target state="translated">Точно &lt;code&gt;distance(first, last)&lt;/code&gt; применения &lt;code&gt;p&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="664be72d77dd1a490f0db6001689b115d6a6b71a" translate="yes" xml:space="preserve">
          <source>Exactly &lt;code&gt;last - first&lt;/code&gt; applications of the predicate.</source>
          <target state="translated">Именно &lt;code&gt;last - first&lt;/code&gt; применения предиката.</target>
        </trans-unit>
        <trans-unit id="7e7f4d09b4ff46a04df0991518050618d9d2f7b5" translate="yes" xml:space="preserve">
          <source>Exactly &lt;code&gt;last - first&lt;/code&gt; assignments.</source>
          <target state="translated">Именно &lt;code&gt;last - first&lt;/code&gt; задания.</target>
        </trans-unit>
        <trans-unit id="b25aeebe72d8f421614fa0ad0873495e44259427" translate="yes" xml:space="preserve">
          <source>Exactly &lt;code&gt;last - first&lt;/code&gt; increments and assignments.</source>
          <target state="translated">Именно &lt;code&gt;last - first&lt;/code&gt; приращения и назначения.</target>
        </trans-unit>
        <trans-unit id="dd0f4944e44dc9fa8a6fa7891d44439f219ac35c" translate="yes" xml:space="preserve">
          <source>Exactly &lt;code&gt;last - first&lt;/code&gt; move assignments.</source>
          <target state="translated">Точно &lt;code&gt;last - first&lt;/code&gt; ход заданий.</target>
        </trans-unit>
        <trans-unit id="64786764c6cc4f57b36277db2d8d6df02d730d57" translate="yes" xml:space="preserve">
          <source>Exactly &lt;code&gt;last&lt;/code&gt; - &lt;code&gt;first&lt;/code&gt; applications of &lt;code&gt;f&lt;/code&gt;.</source>
          <target state="translated">Именно &lt;code&gt;last&lt;/code&gt; - &lt;code&gt;first&lt;/code&gt; применения &lt;code&gt;f&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3fd8d57c8139bdfd24f5d36db13c1c858637e062" translate="yes" xml:space="preserve">
          <source>Exactly &lt;code&gt;n&lt;/code&gt; applications of &lt;code&gt;f&lt;/code&gt;.</source>
          <target state="translated">Ровно &lt;code&gt;n&lt;/code&gt; приложений &lt;code&gt;f&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="aabf3a891f0ec18e0d36466fa6f0c9ce5485153e" translate="yes" xml:space="preserve">
          <source>Exactly max(N-1,0) comparisons, where &lt;code&gt;N = &lt;a href=&quot;../iterator/distance&quot;&gt;std::distance&lt;/a&gt;(first, last)&lt;/code&gt;.</source>
          <target state="translated">Точно максимальное (N-1,0) сравнение, где &lt;code&gt;N = &lt;a href=&quot;../iterator/distance&quot;&gt;std::distance&lt;/a&gt;(first, last)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="99195733fda66fedc7bf44e9446fa1cb19801072" translate="yes" xml:space="preserve">
          <source>Exactly one of &lt;code&gt;bool(a &amp;lt; b)&lt;/code&gt;, &lt;code&gt;bool(a &amp;gt; b)&lt;/code&gt; and &lt;code&gt;bool(a == b)&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;;</source>
          <target state="translated">Точно одно из &lt;code&gt;bool(a &amp;lt; b)&lt;/code&gt; , &lt;code&gt;bool(a &amp;gt; b)&lt;/code&gt; и &lt;code&gt;bool(a == b)&lt;/code&gt; является &lt;code&gt;true&lt;/code&gt; ;</target>
        </trans-unit>
        <trans-unit id="c0a2d0e4e192dcffd92f7c5fc920779a3a46eca3" translate="yes" xml:space="preserve">
          <source>Examines the filesystem object referred to by this directory entry and stores its attributes for retrieval with &lt;a href=&quot;status&quot;&gt;&lt;code&gt;status()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;exists&quot;&gt;&lt;code&gt;exists()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;is_regular_file&quot;&gt;&lt;code&gt;is_regular_file()&lt;/code&gt;&lt;/a&gt;, and other status accessors.</source>
          <target state="translated">Исследует объект файловой системы , упоминаемый в данной записи каталога , и сохраняет свои атрибуты для поиска с &lt;a href=&quot;status&quot;&gt; &lt;code&gt;status()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;exists&quot;&gt; &lt;code&gt;exists()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;is_regular_file&quot;&gt; &lt;code&gt;is_regular_file()&lt;/code&gt; &lt;/a&gt; и другие аксессор состояния.</target>
        </trans-unit>
        <trans-unit id="d9b9f013ab46e72d63d24bb4f00288b2d9847138" translate="yes" xml:space="preserve">
          <source>Examines the partitioned (as if by &lt;code&gt;&lt;a href=&quot;partition&quot;&gt;std::partition&lt;/a&gt;&lt;/code&gt;) range &lt;code&gt;[first, last)&lt;/code&gt; and locates the end of the first partition, that is, the first element that does not satisfy &lt;code&gt;p&lt;/code&gt; or &lt;code&gt;last&lt;/code&gt; if all elements satisfy &lt;code&gt;p&lt;/code&gt;.</source>
          <target state="translated">Исследует разделенный (как если бы это был &lt;code&gt;&lt;a href=&quot;partition&quot;&gt;std::partition&lt;/a&gt;&lt;/code&gt; ) диапазон &lt;code&gt;[first, last)&lt;/code&gt; и находит конец первого раздела, то есть первого элемента, который не удовлетворяет &lt;code&gt;p&lt;/code&gt; или &lt;code&gt;last&lt;/code&gt; , если все элементы удовлетворяют &lt;code&gt;p&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bcb284168678a0919d196ddf44691afe02c5f4b3" translate="yes" xml:space="preserve">
          <source>Examines the range &lt;code&gt;[first, last)&lt;/code&gt; and finds the largest range beginning at &lt;code&gt;first&lt;/code&gt; in which the elements are sorted in ascending order.</source>
          <target state="translated">Исследует диапазон &lt;code&gt;[first, last)&lt;/code&gt; и находит наибольшее начало диапазона на &lt;code&gt;first&lt;/code&gt; , в которой элементы сортируются в порядке возрастания.</target>
        </trans-unit>
        <trans-unit id="0a9b4d7926393a3c0dd8eb8f3c42a7ab58af6b22" translate="yes" xml:space="preserve">
          <source>Examines the range &lt;code&gt;[first, last)&lt;/code&gt; and finds the largest range beginning at &lt;code&gt;first&lt;/code&gt; which is a</source>
          <target state="translated">Изучает диапазон &lt;code&gt;[first, last)&lt;/code&gt; и находит самый большой диапазон, начинающийся &lt;code&gt;first&lt;/code&gt; который является</target>
        </trans-unit>
        <trans-unit id="0f01ed56a1e32a05e5ef96e4d779f34784af9a96" translate="yes" xml:space="preserve">
          <source>Example</source>
          <target state="translated">Example</target>
        </trans-unit>
        <trans-unit id="bd9e11c33e704e33e3cee607c8252cdbbcd8a124" translate="yes" xml:space="preserve">
          <source>Example With Custom Comparator</source>
          <target state="translated">Пример с пользовательским компаратором</target>
        </trans-unit>
        <trans-unit id="ab4f744b89a1cf5abcd9dceb291ddd3e9f741894" translate="yes" xml:space="preserve">
          <source>Example from &lt;a href=&quot;http://www.gotw.ca/gotw/030.htm&quot;&gt;http://www.gotw.ca/gotw/030.htm&lt;/a&gt;.</source>
          <target state="translated">Пример с &lt;a href=&quot;http://www.gotw.ca/gotw/030.htm&quot;&gt;http://www.gotw.ca/gotw/030.htm&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e251b366d1e0802c0331ec415628df8aa911103c" translate="yes" xml:space="preserve">
          <source>Example output on one of the implementations.</source>
          <target state="translated">Пример вывода на одной из реализаций.</target>
        </trans-unit>
        <trans-unit id="ea1fb9b04a44f008daf87c7d9f9e133ac9bce209" translate="yes" xml:space="preserve">
          <source>Example using a custom comparison function</source>
          <target state="translated">Пример использования пользовательской функции сравнения</target>
        </trans-unit>
        <trans-unit id="db0a68cbf7c526f2a972b13383c59c76ca98c33e" translate="yes" xml:space="preserve">
          <source>Example with vectors :</source>
          <target state="translated">Пример с векторами :</target>
        </trans-unit>
        <trans-unit id="eb01bf04c9a0e8a71c45816513df424f1c7ffedb" translate="yes" xml:space="preserve">
          <source>Examples</source>
          <target state="translated">Examples</target>
        </trans-unit>
        <trans-unit id="8221a0d43625eba2795f842d5c24c7c9f59b0337" translate="yes" xml:space="preserve">
          <source>Examples of &lt;code&gt;Boolean&lt;/code&gt; types include &lt;code&gt;bool&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../types/integral_constant&quot;&gt;std::true_type&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;../utility/bitset&quot;&gt;std::bitset&lt;/a&gt;&amp;lt;N&amp;gt;::reference&lt;/code&gt;. Pointers are not &lt;code&gt;Boolean&lt;/code&gt; types.</source>
          <target state="translated">Примеры &lt;code&gt;Boolean&lt;/code&gt; типов включают &lt;code&gt;bool&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../types/integral_constant&quot;&gt;std::true_type&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;../utility/bitset&quot;&gt;std::bitset&lt;/a&gt;&amp;lt;N&amp;gt;::reference&lt;/code&gt; . Указатели не являются &lt;code&gt;Boolean&lt;/code&gt; типами.</target>
        </trans-unit>
        <trans-unit id="d1eddcef956b054e171719c037485ba482a76be3" translate="yes" xml:space="preserve">
          <source>Examples of erasure methods are &lt;code&gt;&lt;a href=&quot;container/set/erase&quot;&gt;std::set::erase&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;container/vector/pop_back&quot;&gt;std::vector::pop_back&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;container/deque/pop_front&quot;&gt;std::deque::pop_front&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;container/map/clear&quot;&gt;std::map::clear&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Примеры способов стирания являются &lt;code&gt;&lt;a href=&quot;container/set/erase&quot;&gt;std::set::erase&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;container/vector/pop_back&quot;&gt;std::vector::pop_back&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;container/deque/pop_front&quot;&gt;std::deque::pop_front&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;container/map/clear&quot;&gt;std::map::clear&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1fe47fa951fcb6357223febc9d44197fbb268fda" translate="yes" xml:space="preserve">
          <source>Examples of implementation-defined launch policies are the sync policy (execute immediately, within the async call) and the task policy (similar to async, but thread-locals are not cleared).</source>
          <target state="translated">Примерами политик запуска,определенных реализацией,являются политика синхронизации (выполняется немедленно,в пределах вызова асинхронизации)и политика задач (аналогично асинхронизации,но нисходящие потоки не очищаются).</target>
        </trans-unit>
        <trans-unit id="e910df0f6bb9dfed95f71ce88f75479176c518cf" translate="yes" xml:space="preserve">
          <source>Examples of insertion methods are &lt;code&gt;&lt;a href=&quot;container/set/insert&quot;&gt;std::set::insert&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;container/map/emplace&quot;&gt;std::map::emplace&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;container/vector/push_back&quot;&gt;std::vector::push_back&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;container/deque/push_front&quot;&gt;std::deque::push_front&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Примерами методов вставки являются &lt;code&gt;&lt;a href=&quot;container/set/insert&quot;&gt;std::set::insert&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;container/map/emplace&quot;&gt;std::map::emplace&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;container/vector/push_back&quot;&gt;std::vector::push_back&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;container/deque/push_front&quot;&gt;std::deque::push_front&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="69702eefdd99747ec1287d6c73c6d3f8f05c1292" translate="yes" xml:space="preserve">
          <source>Examples of partial specializations in the standard library include &lt;code&gt;&lt;a href=&quot;../memory/unique_ptr&quot;&gt;std::unique_ptr&lt;/a&gt;&lt;/code&gt;, which has a partial specialization for array types.</source>
          <target state="translated">Примеры частичной специализации в стандартной библиотеке включают &lt;code&gt;&lt;a href=&quot;../memory/unique_ptr&quot;&gt;std::unique_ptr&lt;/a&gt;&lt;/code&gt; , которая имеет частичную специализацию для типов массивов.</target>
        </trans-unit>
        <trans-unit id="a00ca19e4db47060f538e8b506c6503ac18be3b7" translate="yes" xml:space="preserve">
          <source>Except for &lt;code&gt;value_type&lt;/code&gt;, all the member types of &lt;code&gt;&lt;a href=&quot;../memory/allocator_traits&quot;&gt;std::allocator_traits&lt;/a&gt;&amp;lt;X&amp;gt;&lt;/code&gt; are complete types.</source>
          <target state="translated">За исключением &lt;code&gt;value_type&lt;/code&gt; , все типы членов &lt;code&gt;&lt;a href=&quot;../memory/allocator_traits&quot;&gt;std::allocator_traits&lt;/a&gt;&amp;lt;X&amp;gt;&lt;/code&gt; являются полными типами.</target>
        </trans-unit>
        <trans-unit id="8acd64a7d513ffba5fa93f11be47de7c9fc5c1db" translate="yes" xml:space="preserve">
          <source>Except for default argument, aligned_storage is expressible in terms of alignas:</source>
          <target state="translated">За исключением аргумента по умолчанию,значение переменной align_storage является expressible с точки зрения alignas:</target>
        </trans-unit>
        <trans-unit id="f51732ca4ed72fa4525ab38c97db1146e4d04378" translate="yes" xml:space="preserve">
          <source>Except in the constructors of &lt;code&gt;&lt;a href=&quot;strstreambuf&quot;&gt;std::strstreambuf&lt;/a&gt;&lt;/code&gt;, negative values of &lt;code&gt;std::streamsize&lt;/code&gt; are never used.</source>
          <target state="translated">За исключением конструкторов &lt;code&gt;&lt;a href=&quot;strstreambuf&quot;&gt;std::strstreambuf&lt;/a&gt;&lt;/code&gt; , отрицательные значения &lt;code&gt;std::streamsize&lt;/code&gt; никогда не используются.</target>
        </trans-unit>
        <trans-unit id="d587eb69ad8f0449298a08da77269d9ca0f24406" translate="yes" xml:space="preserve">
          <source>Except that if no exception specification is explicitly provided, the exception specification is considered to be one that would be used by the implicitly-declared destructor (see below). In most cases, this is &lt;code&gt;noexcept(true)&lt;/code&gt;. Thus a throwing destructor must be explicitly declared &lt;code&gt;noexcept(false)&lt;/code&gt;.</source>
          <target state="translated">За исключением того, что если спецификация исключений явно не указана, считается, что спецификация исключений будет использоваться неявно объявленным деструктором (см. Ниже). В большинстве случаев это не &lt;code&gt;noexcept(true)&lt;/code&gt; . Таким образом, метательный деструктор должен быть явно объявлен &lt;code&gt;noexcept(false)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0d95da02e76b8dae287531e540c02e16d08b2978" translate="yes" xml:space="preserve">
          <source>Except that names declared by the init-statement (if init-statement is a declaration) and names declared by condition (if condition is a declaration) are in the same scope, which is also the scope of both statements.</source>
          <target state="translated">За исключением того,что имена,заявленные в заявлении init (если заявление init является декларацией),и имена,заявленные в заявлении condition (если условие является декларацией),входят в одну и ту же область применения,которая также входит в сферу применения обоих заявлений.</target>
        </trans-unit>
        <trans-unit id="29967c007b524bf4d82e67020addcf8209e607a6" translate="yes" xml:space="preserve">
          <source>Except that names declared by the init-statement (if init-statement is a declaration) and names declared by condition (if condition is a declaration) are in the same scope, which is also the scope of statement.</source>
          <target state="translated">За исключением того,что имена,заявленные в заявлении init (если заявление init является декларацией),и имена,заявленные в заявлении condition (если условие является декларацией),входят в одну и ту же область применения,которая также входит в сферу применения заявления.</target>
        </trans-unit>
        <trans-unit id="e357f711ee87c54bd0e9332d642407c850fea7c4" translate="yes" xml:space="preserve">
          <source>Except that the calls to &lt;code&gt;decay_copy&lt;/code&gt; are evaluated in the context of the caller, so that any exceptions thrown during evaluation and copying/moving of the arguments are thrown in the current thread, without starting the new thread.</source>
          <target state="translated">За исключением того, что вызовы &lt;code&gt;decay_copy&lt;/code&gt; оцениваются в контексте вызывающей стороны, поэтому любые исключения, генерируемые во время оценки и копирования / перемещения аргументов, генерируются в текущем потоке без запуска нового потока.</target>
        </trans-unit>
        <trans-unit id="1eeb0a1df8df205ed68a524cbaa8c0fab4fe1d23" translate="yes" xml:space="preserve">
          <source>Except that.</source>
          <target state="translated">Кроме этого.</target>
        </trans-unit>
        <trans-unit id="f96eec6bcb0eb29fc403d27737c989d54305c3d2" translate="yes" xml:space="preserve">
          <source>Exception categories</source>
          <target state="translated">Исключительные категории</target>
        </trans-unit>
        <trans-unit id="b4b0dfe7027c1d349ba13a7e79558e44ec341bd8" translate="yes" xml:space="preserve">
          <source>Exception handling</source>
          <target state="translated">Исключения из правил</target>
        </trans-unit>
        <trans-unit id="2c1ebcb87ed425e2ea948b9057321bf79663c920" translate="yes" xml:space="preserve">
          <source>Exception handling provides a way of transferring control and information from some point in the execution of a program to a handler associated with a point previously passed by the execution (in other words, exception handling transfers control up the call stack).</source>
          <target state="translated">Обработка исключений обеспечивает способ передачи управления и информации от некоторой точки выполнения программы к обработчику,связанному с точкой,ранее переданной во время выполнения (другими словами,обработка исключений передает управление вверх по стеку вызовов).</target>
        </trans-unit>
        <trans-unit id="484018b13af3fa5985246c3cf1cb9a80f78a4b2e" translate="yes" xml:space="preserve">
          <source>Exception handling utilities</source>
          <target state="translated">Утилиты обработки исключений</target>
        </trans-unit>
        <trans-unit id="f20b401bcfd0d6316854bd1c5be2e83c76d1de4f" translate="yes" xml:space="preserve">
          <source>Exception objects</source>
          <target state="translated">Исключительные объекты</target>
        </trans-unit>
        <trans-unit id="c178e2e0328be43fb7ba635e2d8a88fc566b2eb0" translate="yes" xml:space="preserve">
          <source>Exception of type &lt;code&gt;&lt;a href=&quot;../error/system_error&quot;&gt;std::system_error&lt;/a&gt;&lt;/code&gt; may be thrown on errors, with the following error codes:</source>
          <target state="translated">Исключение типа &lt;code&gt;&lt;a href=&quot;../error/system_error&quot;&gt;std::system_error&lt;/a&gt;&lt;/code&gt; может выдаваться при ошибках со следующими кодами ошибок:</target>
        </trans-unit>
        <trans-unit id="80d5280e70d86ad891f2b40c8ed78d7da520c6d7" translate="yes" xml:space="preserve">
          <source>Exception safety</source>
          <target state="translated">Исключительная безопасность</target>
        </trans-unit>
        <trans-unit id="cd3dfbe79fda3a9d92de67b1bd4f1dc9f60ab723" translate="yes" xml:space="preserve">
          <source>Exceptions</source>
          <target state="translated">Exceptions</target>
        </trans-unit>
        <trans-unit id="860a1ec6dde884258f991928e357d615dac44a1f" translate="yes" xml:space="preserve">
          <source>Exceptions (e.g. &lt;code&gt;&lt;a href=&quot;error/exception&quot;&gt;std::exception&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;error/terminate&quot;&gt;std::terminate&lt;/a&gt;&lt;/code&gt;), assertions (e.g. &lt;code&gt;&lt;a href=&quot;error/assert&quot;&gt;assert&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">Исключения (например, &lt;code&gt;&lt;a href=&quot;error/exception&quot;&gt;std::exception&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;error/terminate&quot;&gt;std::terminate&lt;/a&gt;&lt;/code&gt; ), утверждения (например, &lt;code&gt;&lt;a href=&quot;error/assert&quot;&gt;assert&lt;/a&gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="1c85cdf1b242c92824cb3422445a6b69100c6e06" translate="yes" xml:space="preserve">
          <source>Exceptions of type &lt;code&gt;std::runtime_error&lt;/code&gt; are thrown by the following standard library components: &lt;code&gt;&lt;a href=&quot;../../locale/locale/locale&quot;&gt;std::locale::locale&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../../locale/locale/combine&quot;&gt;std::locale::combine&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Исключения типа &lt;code&gt;std::runtime_error&lt;/code&gt; следующими стандартными компонентами библиотеки: &lt;code&gt;&lt;a href=&quot;../../locale/locale/locale&quot;&gt;std::locale::locale&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;../../locale/locale/combine&quot;&gt;std::locale::combine&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3655d713d676393ce50c4dfe2c15b248f391aaef" translate="yes" xml:space="preserve">
          <source>Exceptions that are thrown from member initializers may be handled by &lt;a href=&quot;function-try-block&quot;&gt;function-try-block&lt;/a&gt;.</source>
          <target state="translated">Исключения, которые вызываются из инициализаторов-членов, могут обрабатываться &lt;a href=&quot;function-try-block&quot;&gt;функцией-try-block&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f3ccb3655838c7cc0f05342ca4d518865db28c05" translate="yes" xml:space="preserve">
          <source>Exchanges the contents of &lt;code&gt;*this&lt;/code&gt; and &lt;code&gt;r&lt;/code&gt;.</source>
          <target state="translated">Обменяет содержимое &lt;code&gt;*this&lt;/code&gt; и &lt;code&gt;r&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cf0531db840de334e816e5c677f3bd63fcd3dd1a" translate="yes" xml:space="preserve">
          <source>Exchanges the contents of &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt;</source>
          <target state="translated">Обменяет содержимое &lt;code&gt;a&lt;/code&gt; и &lt;code&gt;b&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="10d46d6be13fed97bcfc06d63285187114a038e8" translate="yes" xml:space="preserve">
          <source>Exchanges the contents of the container adaptor with those of &lt;code&gt;other&lt;/code&gt;. Effectively calls &lt;code&gt;using &lt;a href=&quot;../../algorithm/swap&quot;&gt;std::swap&lt;/a&gt;; swap(c, other.c); swap(comp, other.comp);&lt;/code&gt;</source>
          <target state="translated">Обменивает содержимое контейнера контейнера с &lt;code&gt;other&lt;/code&gt; . Эффективно звонит &lt;code&gt;using &lt;a href=&quot;../../algorithm/swap&quot;&gt;std::swap&lt;/a&gt;; swap(c, other.c); swap(comp, other.comp);&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3e6e9555c788d205a45c120fea2405b48de6ce8a" translate="yes" xml:space="preserve">
          <source>Exchanges the contents of the container adaptor with those of &lt;code&gt;other&lt;/code&gt;. Effectively calls &lt;code&gt;using &lt;a href=&quot;../../algorithm/swap&quot;&gt;std::swap&lt;/a&gt;; swap(c, other.c);&lt;/code&gt;</source>
          <target state="translated">Обменивает содержимое контейнера контейнера с &lt;code&gt;other&lt;/code&gt; . Эффективно звонит &lt;code&gt;using &lt;a href=&quot;../../algorithm/swap&quot;&gt;std::swap&lt;/a&gt;; swap(c, other.c);&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="49de04ba32b7f84cb9cd03e37185b56ecd9e1b91" translate="yes" xml:space="preserve">
          <source>Exchanges the contents of the container with those of &lt;code&gt;other&lt;/code&gt;. Does not cause iterators and references to associate with the other container.</source>
          <target state="translated">Обменивает содержимое контейнера с &lt;code&gt;other&lt;/code&gt; . Не вызывает связывания итераторов и ссылок с другим контейнером.</target>
        </trans-unit>
        <trans-unit id="cca5e7e3ee4209e3931f1f34eaaecf8cf0a0bc6a" translate="yes" xml:space="preserve">
          <source>Exchanges the contents of the container with those of &lt;code&gt;other&lt;/code&gt;. Does not invoke any move, copy, or swap operations on individual elements.</source>
          <target state="translated">Обменивает содержимое контейнера с &lt;code&gt;other&lt;/code&gt; . Не вызывает никаких операций перемещения, копирования или замены отдельных элементов.</target>
        </trans-unit>
        <trans-unit id="62bfbc4c539262880741976e01c4f02e7c1e4a00" translate="yes" xml:space="preserve">
          <source>Exchanges the contents of the stream buffer with those of &lt;code&gt;other&lt;/code&gt;.</source>
          <target state="translated">Обменивается содержимым буфера потока с данными &lt;code&gt;other&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3a6e431a73a626620ce066c3e9d4f31fda3acf08" translate="yes" xml:space="preserve">
          <source>Exchanges the contents of the string with those of &lt;code&gt;other&lt;/code&gt;. All iterators and references may be invalidated.</source>
          <target state="translated">Обменивается содержимым строки с содержимым &lt;code&gt;other&lt;/code&gt; . Все итераторы и ссылки могут быть недействительными.</target>
        </trans-unit>
        <trans-unit id="a091ec29303367010ecc75278a112bbcdf30230b" translate="yes" xml:space="preserve">
          <source>Exchanges the contents of the sync stream buffer with those of &lt;code&gt;other&lt;/code&gt;.</source>
          <target state="translated">Обменивается содержимым буфера потока синхронизации с данными &lt;code&gt;other&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6582eb59d4c7d4d4f55d78fce8cfcf8c22bc4bb7" translate="yes" xml:space="preserve">
          <source>Exchanges the contents of two regular expressions.</source>
          <target state="translated">Обмен содержимым двух регулярных выражений.</target>
        </trans-unit>
        <trans-unit id="67e3c44b994c5e59c6fd36a93ede7ec7c8983289" translate="yes" xml:space="preserve">
          <source>Exchanges the given values.</source>
          <target state="translated">Обменяться заданными значениями.</target>
        </trans-unit>
        <trans-unit id="a2b38d8b13b6bc9e51339c32d2d13644d36846b9" translate="yes" xml:space="preserve">
          <source>Exchanges the internal states of the lock objects.</source>
          <target state="translated">Обмен внутренними состояниями объектов замка.</target>
        </trans-unit>
        <trans-unit id="7c072815ce7ddc6a4942335ae6ce9574b39ca082" translate="yes" xml:space="preserve">
          <source>Exchanges the shared states and stored tasks of &lt;code&gt;*this&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt;.</source>
          <target state="translated">Обменивается общими состояниями и сохраненными задачами &lt;code&gt;*this&lt;/code&gt; и &lt;code&gt;other&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8b12f471554dcab6c425a7585115003928398434" translate="yes" xml:space="preserve">
          <source>Exchanges the shared states of two &lt;code&gt;match_results&lt;/code&gt; objects.</source>
          <target state="translated">&lt;code&gt;match_results&lt;/code&gt; общие состояния двух объектов match_results .</target>
        </trans-unit>
        <trans-unit id="59d42fecea425bb592e078023cd032e5a993fe31" translate="yes" xml:space="preserve">
          <source>Exchanges the shared states of two promise objects.</source>
          <target state="translated">Обменяется общими состояниями двух обещающих объектов.</target>
        </trans-unit>
        <trans-unit id="18b676510da12b57d475482111403500d0eaec7b" translate="yes" xml:space="preserve">
          <source>Exchanges the state of &lt;code&gt;lhs&lt;/code&gt; with that of &lt;code&gt;rhs&lt;/code&gt;. Effectively calls &lt;code&gt;lhs.swap(rhs)&lt;/code&gt;.</source>
          <target state="translated">Меняет состояние &lt;code&gt;lhs&lt;/code&gt; на &lt;code&gt;rhs&lt;/code&gt; . Эффективно вызывает &lt;code&gt;lhs.swap(rhs)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f1b9970f1ef14caaf33f01eabd758b36bb1eff60" translate="yes" xml:space="preserve">
          <source>Exchanges the state of the stream with those of &lt;code&gt;other&lt;/code&gt;.</source>
          <target state="translated">Обменивается состоянием потока с &lt;code&gt;other&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="31ddf92acf4cafa84669771e5848a6787348f3e4" translate="yes" xml:space="preserve">
          <source>Exchanges the state with another input/output stream object. Effectively calls &lt;code&gt;basic_istream&amp;lt;CharT,Traits&amp;gt;::swap(other)&lt;/code&gt;.</source>
          <target state="translated">Обменивается состоянием с другим объектом потока ввода / вывода. Эффективно вызывает &lt;code&gt;basic_istream&amp;lt;CharT,Traits&amp;gt;::swap(other)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d4b57df173bf97bd6ea27f8a30b30cea7df455a9" translate="yes" xml:space="preserve">
          <source>Exchanges the states of &lt;code&gt;*this&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt;, except for the associated &lt;code&gt;rdbuf&lt;/code&gt; objects. &lt;code&gt;&lt;a href=&quot;rdbuf&quot;&gt;rdbuf()&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;other.rdbuf()&lt;/code&gt; returns the same values as before the call.</source>
          <target state="translated">Обмен состояниями &lt;code&gt;*this&lt;/code&gt; и &lt;code&gt;other&lt;/code&gt; , за исключением связанных объектов &lt;code&gt;rdbuf&lt;/code&gt; . &lt;code&gt;&lt;a href=&quot;rdbuf&quot;&gt;rdbuf()&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;other.rdbuf()&lt;/code&gt; возвращают те же значения, что и до вызова.</target>
        </trans-unit>
        <trans-unit id="7057d033a604041b5eda100f7d1ff124d6f8a8db" translate="yes" xml:space="preserve">
          <source>Exchanges the stored callable objects of &lt;code&gt;*this&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt;.</source>
          <target state="translated">Обменивается сохраненными вызываемыми объектами &lt;code&gt;*this&lt;/code&gt; и &lt;code&gt;other&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d4dce99c5d1d30eb407da92e2d161ddb796ea801" translate="yes" xml:space="preserve">
          <source>Exchanges the underlying handles of two thread objects.</source>
          <target state="translated">Обменяется базовыми ручками двух нитевых объектов.</target>
        </trans-unit>
        <trans-unit id="4bec71ee58c3ce1a623ca2ef092eecb76d6de116" translate="yes" xml:space="preserve">
          <source>Exchanges the values referenced by &lt;code&gt;t&lt;/code&gt; and &lt;code&gt;u&lt;/code&gt;.</source>
          <target state="translated">Обмен значениями, на которые ссылаются &lt;code&gt;t&lt;/code&gt; и &lt;code&gt;u&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9a51b1fd2363fd0ca07531efcb4dd24feaa75b80" translate="yes" xml:space="preserve">
          <source>Exchanges the view with that of &lt;code&gt;v&lt;/code&gt;.</source>
          <target state="translated">Обменивается мнением с &lt;code&gt;v&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="be6d66875d5906f7cae3a9398d5dbf1c7968e188" translate="yes" xml:space="preserve">
          <source>Exclusive locking</source>
          <target state="translated">Эксклюзивная блокировка</target>
        </trans-unit>
        <trans-unit id="7f9696585c07b96ae418afaf36f528ec350cef50" translate="yes" xml:space="preserve">
          <source>Executable file format error</source>
          <target state="translated">Ошибка формата исполняемого файла</target>
        </trans-unit>
        <trans-unit id="9c973cb9f93e36abf91a1e9c23f91399e854d72a" translate="yes" xml:space="preserve">
          <source>Executes a for loop over a range.</source>
          <target state="translated">Выполняет петлю на расстоянии.</target>
        </trans-unit>
        <trans-unit id="613b116d4f4f58b27e039a622ea9cf3d90eab7e4" translate="yes" xml:space="preserve">
          <source>Executes a statement repeatedly, until the value of condition becomes &lt;code&gt;false&lt;/code&gt;. The test takes place before each iteration.</source>
          <target state="translated">Выполняет оператор несколько раз, пока значение условия не станет &lt;code&gt;false&lt;/code&gt; . Тест проводится перед каждой итерацией.</target>
        </trans-unit>
        <trans-unit id="fb5a19ea5e56f8a6995eea08fd4658f19b1ba739" translate="yes" xml:space="preserve">
          <source>Executes a statement repeatedly, until the value of expression becomes false. The test takes place after each iteration.</source>
          <target state="translated">Выполняет операцию несколько раз,пока значение выражения не станет ложным.Тест происходит после каждой итерации.</target>
        </trans-unit>
        <trans-unit id="0c64270896df6b47ed0ab90cdaa2526a36293282" translate="yes" xml:space="preserve">
          <source>Executes init-statement once, then executes statement and iteration_expression repeatedly, until the value of condition becomes false. The test takes place before each iteration.</source>
          <target state="translated">Выполняет init-выражение один раз,затем повторно выполняет оператор и итерацию_выражения до тех пор,пока значение условия не станет ложным.Тест выполняется перед каждой итерацией.</target>
        </trans-unit>
        <trans-unit id="64b4397dfd824f8172c44d1c4f9e248b16268c1c" translate="yes" xml:space="preserve">
          <source>Executes the &lt;a href=&quot;../named_req/callable&quot;&gt;Callable&lt;/a&gt; object &lt;code&gt;f&lt;/code&gt; exactly once, even if called concurrently, from several threads.</source>
          <target state="translated">Выполняет объект &lt;a href=&quot;../named_req/callable&quot;&gt;Callable &lt;/a&gt; &lt;code&gt;f&lt;/code&gt; ровно один раз, даже если он вызывается одновременно из нескольких потоков.</target>
        </trans-unit>
        <trans-unit id="5241bfbf176faa293d6e52adf2a2d31791dc7d39" translate="yes" xml:space="preserve">
          <source>Executes the &lt;a href=&quot;statements#Compound_statements&quot;&gt;compound statement&lt;/a&gt; as if under a global lock: all outermost synchronized blocks in the program execute in a single total order. The end of each synchronized block synchronizes with the beginning of the next synchronized block in that order. Synchronized blocks that are nested within other synchronized blocks have no special semantics.</source>
          <target state="translated">Выполняет &lt;a href=&quot;statements#Compound_statements&quot;&gt;составной оператор,&lt;/a&gt; как будто под глобальной блокировкой: все внешние синхронизированные блоки в программе выполняются в едином общем порядке. Конец каждого синхронизированного блока синхронизируется с началом следующего синхронизированного блока в этом порядке. Синхронизированные блоки, вложенные в другие синхронизированные блоки, не имеют специальной семантики.</target>
        </trans-unit>
        <trans-unit id="fb88910ec6e8f148a726def306751bb61d10e009" translate="yes" xml:space="preserve">
          <source>Executes the body of the lambda-expression, when invoked. When accessing a variable, accesses its captured copy (for the entities captured by copy), or the original object (for the entities captured by reference). Unless the keyword &lt;code&gt;mutable&lt;/code&gt; was used in the lambda-expression, the function-call operator is const-qualified and the objects that were captured by copy are non-modifiable from inside this &lt;code&gt;operator()&lt;/code&gt;. The function-call operator is never volatile-qualified and never virtual.</source>
          <target state="translated">Выполняет тело лямбда-выражения при вызове. При доступе к переменной обращается к ее захваченной копии (для сущностей, захваченных копией) или к исходному объекту (для сущностей, захваченных ссылкой). Если ключевое слово &lt;code&gt;mutable&lt;/code&gt; не использовалось в лямбда-выражении, оператор вызова функции является константно квалифицированным, и объекты, которые были захвачены копией, не модифицируются внутри этого &lt;code&gt;operator()&lt;/code&gt; . Оператор вызова функции никогда не является волатильным и никогда не виртуальным.</target>
        </trans-unit>
        <trans-unit id="6d525b71568c2d982f46feb96b332bedcdc6e4a0" translate="yes" xml:space="preserve">
          <source>Execution</source>
          <target state="translated">Execution</target>
        </trans-unit>
        <trans-unit id="de7349273ae9d07fc03da50e188f4f34b7d2aa3e" translate="yes" xml:space="preserve">
          <source>Execution policies</source>
          <target state="translated">Политика исполнения</target>
        </trans-unit>
        <trans-unit id="881673b7fc0425b71c75a900e8dd961e60da16d7" translate="yes" xml:space="preserve">
          <source>Exhausting memory in the pool causes the next allocation request for that pool to allocate an additional chunk of memory from the</source>
          <target state="translated">Исчерпание памяти в пуле вызывает следующий запрос распределения для этого пула,чтобы выделить дополнительный кусок памяти из</target>
        </trans-unit>
        <trans-unit id="4d3a207c682e51fd0f76ac46376bd504dd04bb4b" translate="yes" xml:space="preserve">
          <source>Existing elements of &lt;code&gt;a&lt;/code&gt; are destroyed or assigned to</source>
          <target state="translated">Существующие элементы уничтожены или переданы &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="28c764ed1d6222630406c5783a2aaab97f66bd88" translate="yes" xml:space="preserve">
          <source>Expanded value</source>
          <target state="translated">Расширенное значение</target>
        </trans-unit>
        <trans-unit id="3a28add9450f041df1694bda9dbd7fe1ffe87170" translate="yes" xml:space="preserve">
          <source>Expands to an expression (not necessarily a compile-time constant) of type &lt;code&gt;&lt;a href=&quot;clock_t&quot;&gt;std::clock_t&lt;/a&gt;&lt;/code&gt; equal to the number of clock ticks per second, as returned by &lt;code&gt;&lt;a href=&quot;clock&quot;&gt;std::clock()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Расширяется до выражения (не обязательно константы времени компиляции) типа &lt;code&gt;&lt;a href=&quot;clock_t&quot;&gt;std::clock_t&lt;/a&gt;&lt;/code&gt; равного количеству тактов в секунду, возвращаемому &lt;code&gt;&lt;a href=&quot;clock&quot;&gt;std::clock()&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a94ceb9709072dbc8a9721a63225f49eded59877" translate="yes" xml:space="preserve">
          <source>Expands to an expression which can be used to initialize an &lt;code&gt;&lt;a href=&quot;atomic&quot;&gt;std::atomic&lt;/a&gt;&lt;/code&gt; object that can be initialized from &lt;code&gt;value&lt;/code&gt;. If the atomic object has static storage duration, this initialization is &lt;a href=&quot;../language/constant_initialization&quot;&gt;constant initialization&lt;/a&gt;.</source>
          <target state="translated">Расширяется до выражения, которое можно использовать для инициализации объекта &lt;code&gt;&lt;a href=&quot;atomic&quot;&gt;std::atomic&lt;/a&gt;&lt;/code&gt; который можно инициализировать из &lt;code&gt;value&lt;/code&gt; . Если атомарный объект имеет статическую продолжительность хранения, эта инициализация является &lt;a href=&quot;../language/constant_initialization&quot;&gt;постоянной инициализацией&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="de6a2f8e65def43ce5a852e140e79c980dade60d" translate="yes" xml:space="preserve">
          <source>Expands to an integer constant expression equal to the maximum value returned by the function &lt;code&gt;&lt;a href=&quot;rand&quot;&gt;std::rand&lt;/a&gt;&lt;/code&gt;. This value is implementation dependent. It's guaranteed that this value is at least &lt;code&gt;32767&lt;/code&gt;.</source>
          <target state="translated">Расширяется до целочисленного константного выражения, равного максимальному значению, возвращаемому функцией &lt;code&gt;&lt;a href=&quot;rand&quot;&gt;std::rand&lt;/a&gt;&lt;/code&gt; . Это значение зависит от реализации. Гарантируется, что это значение не менее &lt;code&gt;32767&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b74a3f6f88cbf8779ab38cebe0c4e5a1aa35bcc5" translate="yes" xml:space="preserve">
          <source>Expands to positive &lt;code&gt;double&lt;/code&gt; expression that indicates overflow, not necessarily representable as a &lt;code&gt;float&lt;/code&gt;</source>
          <target state="translated">Расширяется до положительного &lt;code&gt;double&lt;/code&gt; выражения, которое указывает на переполнение, не обязательно представляемое как число с &lt;code&gt;float&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f5ccabdc1716ee0f1f6ba421bfe7a3cb18e19e27" translate="yes" xml:space="preserve">
          <source>Expands to positive &lt;code&gt;float&lt;/code&gt; expression that indicates overflow</source>
          <target state="translated">Расширяется до положительного выражения с &lt;code&gt;float&lt;/code&gt; которое указывает на переполнение</target>
        </trans-unit>
        <trans-unit id="1517f254032c8417e8afa57de1c3cc258d11f6c4" translate="yes" xml:space="preserve">
          <source>Expands to positive &lt;code&gt;long double&lt;/code&gt; expression that indicates overflow, not necessarily representable as a &lt;code&gt;float&lt;/code&gt; or &lt;code&gt;double&lt;/code&gt;</source>
          <target state="translated">Расширяется до положительного &lt;code&gt;long double&lt;/code&gt; выражения, которое указывает на переполнение, не обязательно представляемое как число с &lt;code&gt;float&lt;/code&gt; или &lt;code&gt;double&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="bc198697dbf6af57511ca5dfb75efa170fb6388d" translate="yes" xml:space="preserve">
          <source>Expansion loci</source>
          <target state="translated">Локусы расширения</target>
        </trans-unit>
        <trans-unit id="d9e0a488e53cfe7c390afb8b463eb5bb25a7cfba" translate="yes" xml:space="preserve">
          <source>Experimental libraries</source>
          <target state="translated">Экспериментальные библиотеки</target>
        </trans-unit>
        <trans-unit id="b32ef340ea4702fd5f41dbe4001671d76174ef71" translate="yes" xml:space="preserve">
          <source>Explanation</source>
          <target state="translated">Explanation</target>
        </trans-unit>
        <trans-unit id="52641b8a40589b37d9770ba9ee57a29be108ded9" translate="yes" xml:space="preserve">
          <source>Explicit (full) specialization of a member of a partial specialization is declared the same way as an explicit specialization of the primary template.</source>
          <target state="translated">Явная (полная)специализация члена частичной специализации объявляется так же,как и явная специализация первичного шаблона.</target>
        </trans-unit>
        <trans-unit id="dd412ab552031cf5dc3a067286b0057cfec3dfe8" translate="yes" xml:space="preserve">
          <source>Explicit conversion from (possibly const) &lt;code&gt;fpos&lt;/code&gt; to &lt;code&gt;&lt;a href=&quot;streamoff&quot;&gt;std::streamoff&lt;/a&gt;&lt;/code&gt;. The result is the stored offset.</source>
          <target state="translated">Явное преобразование из (возможно, const) &lt;code&gt;fpos&lt;/code&gt; в &lt;code&gt;&lt;a href=&quot;streamoff&quot;&gt;std::streamoff&lt;/a&gt;&lt;/code&gt; . Результатом является сохраненное смещение.</target>
        </trans-unit>
        <trans-unit id="1c63bca80feb759ba98d57e981b658fef25d5cce" translate="yes" xml:space="preserve">
          <source>Explicit instantiation</source>
          <target state="translated">Явная конкретизация</target>
        </trans-unit>
        <trans-unit id="4b142316d64b45cb4860439c17ed8cd8981f0aa9" translate="yes" xml:space="preserve">
          <source>Explicit instantiation can only appear in the enclosing namespace of the template, unless it uses qualified-id:</source>
          <target state="translated">Явная конкретизация может появляться только в прилагаемом пространстве имён шаблона,если только в нем не используется квалифицированныйид:</target>
        </trans-unit>
        <trans-unit id="ee1fc799be568941add0e5c7edd28b1bd51ae960" translate="yes" xml:space="preserve">
          <source>Explicit instantiation declarations do not suppress the implicit instantiation of &lt;a href=&quot;inline&quot;&gt;inline&lt;/a&gt; functions, &lt;a href=&quot;auto&quot;&gt;auto&lt;/a&gt;-declarations, references, and class template specializations. (thus, when the inline function that is a subject of explicit instantiation declaration is ODR-used, it is implicitly instantiated for inlining, but its out-of-line copy is not generated in this TU).</source>
          <target state="translated">Явные объявления создания экземпляров не подавляют неявное создание экземпляров &lt;a href=&quot;inline&quot;&gt;встроенных&lt;/a&gt; функций, &lt;a href=&quot;auto&quot;&gt;автоматических&lt;/a&gt; объявлений, ссылок и специализаций шаблонов классов. (таким образом, когда встроенная функция, являющаяся предметом явного объявления экземпляра, используется ODR, она неявно создается для встраивания, но ее внешняя копия не генерируется в этом TU).</target>
        </trans-unit>
        <trans-unit id="572c84d2570e91de98df5fd413b0bd1a4670b56d" translate="yes" xml:space="preserve">
          <source>Explicit instantiation definition of a function template with &lt;a href=&quot;default_arguments&quot;&gt;default arguments&lt;/a&gt; is not a use of the arguments, and does not attempt to initialize them:</source>
          <target state="translated">Явное определение экземпляра шаблона функции с &lt;a href=&quot;default_arguments&quot;&gt;аргументами по умолчанию&lt;/a&gt; не использует аргументы и не пытается их инициализировать:</target>
        </trans-unit>
        <trans-unit id="0dcc010f6137a4796c623c315a5959bc45a20109" translate="yes" xml:space="preserve">
          <source>Explicit instantiation definitions ignore member access specifiers: parameter types and return types may be private.</source>
          <target state="translated">Явные определения инстанцирования игнорируют спецификаторы доступа членов:типы параметров и возвращаемых типов могут быть приватными.</target>
        </trans-unit>
        <trans-unit id="65478c257174b4e3c09ba657cd00b83b6bf1640b" translate="yes" xml:space="preserve">
          <source>Explicit instantiation has no effect if an &lt;a href=&quot;template_specialization&quot;&gt;explicit specialization&lt;/a&gt; appeared before for the same set of template arguments.</source>
          <target state="translated">Явная реализация не имеет никакого эффекта, если &lt;a href=&quot;template_specialization&quot;&gt;явная специализация&lt;/a&gt; появилась ранее для того же набора аргументов шаблона.</target>
        </trans-unit>
        <trans-unit id="d36a0cc2732df089c694dc98284a6d85796f30ad" translate="yes" xml:space="preserve">
          <source>Explicit instantiation of a function template or of a member function of a class template cannot use &lt;code&gt;inline&lt;/code&gt; or &lt;code&gt;constexpr&lt;/code&gt;. If the declaration of the explicit instantiation names an implicitly-declared special member function, the program is ill-formed.</source>
          <target state="translated">Явное создание экземпляра шаблона функции или функции-члена шаблона класса не может использовать &lt;code&gt;inline&lt;/code&gt; или &lt;code&gt;constexpr&lt;/code&gt; . Если объявление явного создания экземпляра присваивает имя неявно объявленной специальной функции-члену, программа некорректна.</target>
        </trans-unit>
        <trans-unit id="30c811d49cc758004cfc53fc79ee65d4652de860" translate="yes" xml:space="preserve">
          <source>Explicit instantiations, explicit specializations, or partial specializations of concepts are not allowed (the meaning of the original definition of a constraint cannot be changed).</source>
          <target state="translated">Явные конкретизации,явные специализации или частичные специализации понятий не допускаются (значение первоначального определения ограничения изменять нельзя).</target>
        </trans-unit>
        <trans-unit id="2e55319f81d1a852746aa5972684208a80ae6770" translate="yes" xml:space="preserve">
          <source>Explicit specialization</source>
          <target state="translated">Явная специализация</target>
        </trans-unit>
        <trans-unit id="593deb78caf931f5a8926f7968637e3804e9bc2d" translate="yes" xml:space="preserve">
          <source>Explicit specialization may be declared in any scope where its primary template may be defined (which may be different from the scope where the primary template is defined; such as with out-of-class specialization of a &lt;a href=&quot;member_template&quot;&gt;member template&lt;/a&gt;) . Explicit specialization has to appear after the non-specialized template declaration.</source>
          <target state="translated">Явная специализация может быть объявлена ​​в любой области, где может быть определен ее первичный шаблон (который может отличаться от области, в которой определяется первичный шаблон; например, в случае внеклассовой специализации &lt;a href=&quot;member_template&quot;&gt;шаблона элемента&lt;/a&gt; ). Явная специализация должна появиться после объявления специализированного шаблона.</target>
        </trans-unit>
        <trans-unit id="8870f1f0b78d6b643054caef6f197e66cbb50dc0" translate="yes" xml:space="preserve">
          <source>Explicit specializations of function templates</source>
          <target state="translated">Явная специализация шаблонов функций</target>
        </trans-unit>
        <trans-unit id="d9b457bfa7e9dfdb8f202a1cfd0b13910b32a1d1" translate="yes" xml:space="preserve">
          <source>Explicit template argument lists may not be specified when calling any of them.</source>
          <target state="translated">Явные списки аргументов шаблонов могут быть не указаны при вызове любого из них.</target>
        </trans-unit>
        <trans-unit id="901409defb65997b43ccf96e53d877ad8c4540d5" translate="yes" xml:space="preserve">
          <source>Explicit template arguments</source>
          <target state="translated">Явные шаблонные аргументы</target>
        </trans-unit>
        <trans-unit id="4431a5f6720c93927b4ab9fdd98f9a2ec4e9c49f" translate="yes" xml:space="preserve">
          <source>Explicit template instantiation</source>
          <target state="translated">Явная инстанциация шаблона</target>
        </trans-unit>
        <trans-unit id="0fab44e233e42157cd5dea76fd8cf3c8b9d7adc5" translate="yes" xml:space="preserve">
          <source>Explicit template specialization</source>
          <target state="translated">Явная специализация шаблонов</target>
        </trans-unit>
        <trans-unit id="efc7df6ee447c5edc7f6c07135ad3f5023dea6a8" translate="yes" xml:space="preserve">
          <source>Explicit type conversion</source>
          <target state="translated">Явное преобразование типа</target>
        </trans-unit>
        <trans-unit id="dd8bfe3fdab8ac97b580b2a4aef0404f178b5ac1" translate="yes" xml:space="preserve">
          <source>Exponential functions</source>
          <target state="translated">Экспоненциальные функции</target>
        </trans-unit>
        <trans-unit id="af9874c4957d8cd8c01ba533edd025cf4c27e381" translate="yes" xml:space="preserve">
          <source>Exposes class &lt;code&gt;&lt;a href=&quot;vector&quot;&gt;std::vector&lt;/a&gt;&amp;lt;bool&amp;gt;::reference&lt;/code&gt; as a method of accessing individual bits. In particular, objects of this class are returned by &lt;a href=&quot;vector/operator_at&quot;&gt;&lt;code&gt;operator[]&lt;/code&gt;&lt;/a&gt; by value.</source>
          <target state="translated">Предоставляет класс &lt;code&gt;&lt;a href=&quot;vector&quot;&gt;std::vector&lt;/a&gt;&amp;lt;bool&amp;gt;::reference&lt;/code&gt; как метод доступа к отдельным битам. В частности, объекты этого класса возвращаются &lt;a href=&quot;vector/operator_at&quot;&gt; &lt;code&gt;operator[]&lt;/code&gt; &lt;/a&gt; по значению.</target>
        </trans-unit>
        <trans-unit id="386b8e5c19a5d25975c5d960c8d6889b5c0e7456" translate="yes" xml:space="preserve">
          <source>Exposes the type named &lt;code&gt;type&lt;/code&gt;, which is the common type of two &lt;code&gt;&lt;a href=&quot;../duration&quot;&gt;std::chrono::duration&lt;/a&gt;&lt;/code&gt;s.</source>
          <target state="translated">Предоставляет тип именованного &lt;code&gt;type&lt;/code&gt; , который является общим типом двух &lt;code&gt;&lt;a href=&quot;../duration&quot;&gt;std::chrono::duration&lt;/a&gt;&lt;/code&gt; s.</target>
        </trans-unit>
        <trans-unit id="81c630945113fb74890dbe59b04840a67c663c1b" translate="yes" xml:space="preserve">
          <source>Exposes the type named &lt;code&gt;type&lt;/code&gt;, which is the common type of two &lt;code&gt;&lt;a href=&quot;../time_point&quot;&gt;std::chrono::time_point&lt;/a&gt;&lt;/code&gt;s.</source>
          <target state="translated">Предоставляет тип именованного &lt;code&gt;type&lt;/code&gt; , который является общим типом двух &lt;code&gt;&lt;a href=&quot;../time_point&quot;&gt;std::chrono::time_point&lt;/a&gt;&lt;/code&gt; s.</target>
        </trans-unit>
        <trans-unit id="dde7602ac0e3b525fda01f2a33c67f49539ca405" translate="yes" xml:space="preserve">
          <source>Exposition-only data member holding the sentinel (typically either a number, for a bounded iota view, or an instance of &lt;code&gt;std::unreachable_sentinel_t&lt;/code&gt; for an unbounded iota view.</source>
          <target state="translated">Элемент данных только для экспозиции, содержащий страж (обычно это число для ограниченного представления йоты или экземпляр &lt;code&gt;std::unreachable_sentinel_t&lt;/code&gt; для неограниченного представления йоты.</target>
        </trans-unit>
        <trans-unit id="cf2a2572c2908ed7f54343df2e7969e31bec570b" translate="yes" xml:space="preserve">
          <source>Exposition-only data member holding the sentinel of the underlying &lt;a href=&quot;view&quot;&gt;&lt;code&gt;View&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Элемент данных только для экспозиции, содержащий страж базового &lt;a href=&quot;view&quot;&gt; &lt;code&gt;View&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="97b695b9b9cfde3612c21b3add972cc0f21f4e26" translate="yes" xml:space="preserve">
          <source>Expression</source>
          <target state="translated">Expression</target>
        </trans-unit>
        <trans-unit id="41e32832dbe3b76f5e8fc2a5f15b3848cf05e235" translate="yes" xml:space="preserve">
          <source>Expression SFINAE</source>
          <target state="translated">СФИНАЯ ЭКСПРЕССИЯ</target>
        </trans-unit>
        <trans-unit id="833207cd0a28197ca9f0d233e80f2413b069f412" translate="yes" xml:space="preserve">
          <source>Expression evaluation may produce a result (e.g., evaluation of &lt;code&gt;2+2&lt;/code&gt; produces the result &lt;code&gt;4&lt;/code&gt;) and may generate side-effects (e.g. evaluation of &lt;code&gt;&lt;a href=&quot;../io/c/fprintf&quot;&gt;std::printf&lt;/a&gt;(&quot;%d&quot;,4)&lt;/code&gt; prints the character &lt;code&gt;'4'&lt;/code&gt; on the standard output).</source>
          <target state="translated">Оценка выражения может давать результат (например, оценка &lt;code&gt;2+2&lt;/code&gt; дает результат &lt;code&gt;4&lt;/code&gt; ) и может генерировать побочные эффекты (например, оценка &lt;code&gt;&lt;a href=&quot;../io/c/fprintf&quot;&gt;std::printf&lt;/a&gt;(&quot;%d&quot;,4)&lt;/code&gt; печатает символ &lt;code&gt;'4'&lt;/code&gt; в стандарте вывод).</target>
        </trans-unit>
        <trans-unit id="0a7a6ba0d7d2af3106edf9d912c2fc5a47512f54" translate="yes" xml:space="preserve">
          <source>Expression statements</source>
          <target state="translated">Заявления о выражении мнений</target>
        </trans-unit>
        <trans-unit id="ae5fccd8dcd8fc317f8edfc8259af86cd2967a29" translate="yes" xml:space="preserve">
          <source>Expressions</source>
          <target state="translated">Expressions</target>
        </trans-unit>
        <trans-unit id="bd7f69f355486bcb0814ab9e5cf3b7318931dffa" translate="yes" xml:space="preserve">
          <source>Extended &lt;code&gt;static_assert&lt;/code&gt;</source>
          <target state="translated">Extended &lt;code&gt;static_assert&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="85f5fa538ad73dc2c1cf60d6bcfc4288cb6d221b" translate="yes" xml:space="preserve">
          <source>Extending memory management tools</source>
          <target state="translated">Расширение инструментов управления памятью</target>
        </trans-unit>
        <trans-unit id="446e27d8fc1178607fbaea2ba6117c2bee0e3166" translate="yes" xml:space="preserve">
          <source>Extending the namespace std</source>
          <target state="translated">Расширение пространства имён std</target>
        </trans-unit>
        <trans-unit id="e73f93d7fc042bb05945a0bc48fe3f9f81efe46b" translate="yes" xml:space="preserve">
          <source>Extension to &lt;a href=&quot;language/aggregate_initialization&quot;&gt;aggregate initialization&lt;/a&gt;</source>
          <target state="translated">Расширение для &lt;a href=&quot;language/aggregate_initialization&quot;&gt;агрегированной инициализации&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="9d6e9863adde877292363ab102515ca7b6ccafb6" translate="yes" xml:space="preserve">
          <source>Extensions for &lt;code&gt;std::future&lt;/code&gt;</source>
          <target state="translated">Расширения для &lt;code&gt;std::future&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="71a1260f76544c68e3425a1c076e5499b0002fbb" translate="yes" xml:space="preserve">
          <source>Extent</source>
          <target state="translated">Extent</target>
        </trans-unit>
        <trans-unit id="f92e601eb8d663033dca3851ad6f1616d1966aa7" translate="yes" xml:space="preserve">
          <source>External links</source>
          <target state="translated">Внешние ссылки</target>
        </trans-unit>
        <trans-unit id="a1aea7fedb01b55857a374fd355fdb3f3d76821e" translate="yes" xml:space="preserve">
          <source>Extracting a node invalidates only the iterators to the extracted element, and preserves the relative order of the elements that are not erased. Pointers and references to the extracted element remain valid, but cannot be used while element is owned by a node handle: they become usable if the element is inserted into a container.</source>
          <target state="translated">Извлечение узла делает недействительными только итераторы к извлеченному элементу и сохраняет относительный порядок не стираемых элементов.Указатели и ссылки на извлеченный элемент остаются действительными,но не могут быть использованы,пока элемент принадлежит дескриптору узла:они становятся пригодными для использования,если элемент вставляется в контейнер.</target>
        </trans-unit>
        <trans-unit id="b5485507a535a08d29060699bc1ba26e5fbec017" translate="yes" xml:space="preserve">
          <source>Extracting a node invalidates the iterators to the extracted element. Pointers and references to the extracted element remain valid, but cannot be used while element is owned by a node handle: they become usable if the element is inserted into a container.</source>
          <target state="translated">Извлечение узла делает недействительными итераторы к извлеченному элементу.Указатели и ссылки на извлекаемый элемент остаются действительными,но не могут быть использованы,пока элемент принадлежит дескриптору узла:они становятся пригодными для использования,если элемент вставляется в контейнер.</target>
        </trans-unit>
        <trans-unit id="b15d94524be33e2064c90d0f8c997adad64d1ab7" translate="yes" xml:space="preserve">
          <source>Extracting a single character that is the last character of the stream does not set &lt;code&gt;eofbit&lt;/code&gt;: this is different from other formatted input functions, such as extracting the last integer with &lt;code&gt;operator&amp;gt;&amp;gt;&lt;/code&gt;, but this behavior matches the behavior of &lt;code&gt;&lt;a href=&quot;../c/scanf&quot;&gt;std::scanf&lt;/a&gt;&lt;/code&gt; with &lt;code&gt;&quot;%c&quot;&lt;/code&gt; format specifier.</source>
          <target state="translated">Извлечение одного символа, который является последним символом потока, не устанавливает &lt;code&gt;eofbit&lt;/code&gt; : это отличается от других форматированных входных функций, таких как извлечение последнего целого числа с &lt;code&gt;operator&amp;gt;&amp;gt;&lt;/code&gt; , но это поведение соответствует поведению &lt;code&gt;&lt;a href=&quot;../c/scanf&quot;&gt;std::scanf&lt;/a&gt;&lt;/code&gt; с помощью &lt;code&gt;&quot;%c&quot;&lt;/code&gt; спецификатор формата.</target>
        </trans-unit>
        <trans-unit id="77a2197986a0f5813101a331f598cfcb85a220fb" translate="yes" xml:space="preserve">
          <source>Extracts an element from the pair using tuple-like interface.</source>
          <target state="translated">Извлекает элемент из пары с помощью кортежа.</target>
        </trans-unit>
        <trans-unit id="ef0ddc3034770dba9709a96861d6340f80bd0470" translate="yes" xml:space="preserve">
          <source>Extracts and discards characters from the input stream until and including &lt;code&gt;delim&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;delim&lt;/code&gt; и удаляет символы из входного потока до и включая разделитель .</target>
        </trans-unit>
        <trans-unit id="c16944c77e932413c2253839ec882702fb001de1" translate="yes" xml:space="preserve">
          <source>Extracts character or characters from stream.</source>
          <target state="translated">Извлекает символы из потока.</target>
        </trans-unit>
        <trans-unit id="a68c11784d768fd75f5143a08580523eaca81d6d" translate="yes" xml:space="preserve">
          <source>Extracts characters from stream until end of line or the specified delimiter &lt;code&gt;delim&lt;/code&gt;.</source>
          <target state="translated">Экстракты символы из потока до конца строки или указанного разделителя &lt;code&gt;delim&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b0ac0f2a82fe93a443fa08ceb0fe622f9ece3c06" translate="yes" xml:space="preserve">
          <source>Extracts characters from stream.</source>
          <target state="translated">Извлекает символы из потока.</target>
        </trans-unit>
        <trans-unit id="7649df41de72e363648c6e8cac8be1f6dc3a552f" translate="yes" xml:space="preserve">
          <source>Extracts the &lt;code&gt;Ith&lt;/code&gt; element element from the array.</source>
          <target state="translated">Извлекает &lt;code&gt;Ith&lt;/code&gt; элемент элемент из массива.</target>
        </trans-unit>
        <trans-unit id="44b2e430b2cfaf879035a796088aa41b5223f736" translate="yes" xml:space="preserve">
          <source>Extracts the current &lt;code&gt;&lt;a href=&quot;../match_results&quot;&gt;std::match_results&lt;/a&gt;&lt;/code&gt; from a &lt;code&gt;regex_iterator&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../match_results&quot;&gt;std::match_results&lt;/a&gt;&lt;/code&gt; текущий std :: match_results из &lt;code&gt;regex_iterator&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="b56e81381fa5a47e6b3ea3eb1d488fda4cab62e7" translate="yes" xml:space="preserve">
          <source>Extracts up to &lt;code&gt;count&lt;/code&gt; immediately available characters from the input stream. The extracted characters are stored into the character array pointed to by &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="translated">Извлекает до &lt;code&gt;count&lt;/code&gt; сразу доступных символов из входного потока. Извлеченные символы сохраняются в массив символов, на который указывает &lt;code&gt;s&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e72ac13e9cd4d6af9eb70d5cf0e07a1000b3c95a" translate="yes" xml:space="preserve">
          <source>F is sequenced-before X in thread A</source>
          <target state="translated">F последовательно перед X в резьбе A</target>
        </trans-unit>
        <trans-unit id="7baf4c10d15dfb9c6bb605f66aef033fa6c6e2a5" translate="yes" xml:space="preserve">
          <source>FA is sequenced-before X in thread A</source>
          <target state="translated">ФА последовательно перед X в резьбе A</target>
        </trans-unit>
        <trans-unit id="ee8392aac4b3ee280362ef5273dcbf0dce3c5592" translate="yes" xml:space="preserve">
          <source>FEMININE ORDINAL INDICATOR</source>
          <target state="translated">ЖЕНСКИЙ ПОРЯДКОВЫЙ ИНДИКАТОР</target>
        </trans-unit>
        <trans-unit id="c061bc777cddf822c848be8c51b3f6a8a14f19f4" translate="yes" xml:space="preserve">
          <source>FE_ALL_EXCEPTFE_DIVBYZEROFE_INEXACTFE_INVALIDFE_OVERFLOWFE_UNDERFLOW</source>
          <target state="translated">FE_ALL_EXCEPTFE_DIVBYZEROFE_INEXACTFE_INVALIDFE_OVERFLOWFE_UNDERFLOW</target>
        </trans-unit>
        <trans-unit id="b1c364462df93e13ffc864f5e34d434d3e0896f1" translate="yes" xml:space="preserve">
          <source>FE_DFL_ENV</source>
          <target state="translated">FE_DFL_ENV</target>
        </trans-unit>
        <trans-unit id="afc46bada59e52921ca04acfa3e557f4d34949db" translate="yes" xml:space="preserve">
          <source>FE_DOWNWARDFE_TONEARESTFE_TOWARDZEROFE_UPWARD</source>
          <target state="translated">FE_DOWNWARDFE_TONEARESTFE_TOWARDZEROFE_UPWARD</target>
        </trans-unit>
        <trans-unit id="f17f59f8bb1aa4aa1c2a8be48c8b3cc395132a95" translate="yes" xml:space="preserve">
          <source>FE_UNDERFLOW</source>
          <target state="translated">FE_UNDERFLOW</target>
        </trans-unit>
        <trans-unit id="5fc0e01507a5cabdda26a6538ed27cbe059c94c7" translate="yes" xml:space="preserve">
          <source>FE_UPWARD</source>
          <target state="translated">FE_UPWARD</target>
        </trans-unit>
        <trans-unit id="6c8821a037c125e39dc3cb69a201a2174bd7c0f8" translate="yes" xml:space="preserve">
          <source>FILENAME_MAX</source>
          <target state="translated">FILENAME_MAX</target>
        </trans-unit>
        <trans-unit id="ec0e6a828868888b35d7b88c45bc8ec8ded65b4c" translate="yes" xml:space="preserve">
          <source>FLT_DECIMAL_DIGDBL_DECIMAL_DIGLDBL_DECIMAL_DIG</source>
          <target state="translated">FLT_DECIMAL_DIGDBL_DECIMAL_DIGLDBL_DECIMAL_DIG</target>
        </trans-unit>
        <trans-unit id="7afcf0013539d05e408bc6855b9ff9c33961ba4a" translate="yes" xml:space="preserve">
          <source>FLT_DIGDBL_DIGLDBL_DIG</source>
          <target state="translated">FLT_DIGDBL_DIGLDBL_DIG</target>
        </trans-unit>
        <trans-unit id="fb4b82dd7a09ae0e4cd4ec26fae3ace2a1f492b3" translate="yes" xml:space="preserve">
          <source>FLT_EPSILONDBL_EPSILONLDBL_EPSILON</source>
          <target state="translated">FLT_EPSILONDBL_EPSILONLDBL_EPSILON</target>
        </trans-unit>
        <trans-unit id="19a80ddd685588eb2c01ceaa6c67ca15a9d3cd90" translate="yes" xml:space="preserve">
          <source>FLT_EVAL_METHOD</source>
          <target state="translated">FLT_EVAL_METHOD</target>
        </trans-unit>
        <trans-unit id="27b085fe54adba08fa4a2911aa54c2928531a994" translate="yes" xml:space="preserve">
          <source>FLT_HAS_SUBNORMDBL_HAS_SUBNORMLDBL_HAS_SUBNORM</source>
          <target state="translated">FLT_HAS_SUBNORMDBL_HAS_SUBNORMLDBL_HAS_SUBNORM</target>
        </trans-unit>
        <trans-unit id="d23e1d93b48a70a6b3008660a10922fc69e91714" translate="yes" xml:space="preserve">
          <source>FLT_MANT_DIGDBL_MANT_DIGLDBL_MANT_DIG</source>
          <target state="translated">FLT_MANT_DIGDBL_MANT_DIGLDBL_MANT_DIG</target>
        </trans-unit>
        <trans-unit id="14a1a55c6769f2d618f216dd4e1926c937963a81" translate="yes" xml:space="preserve">
          <source>FLT_MAXDBL_MAXLDBL_MAX</source>
          <target state="translated">FLT_MAXDBL_MAXLDBL_MAX</target>
        </trans-unit>
        <trans-unit id="1a43181bc7c68633c0d3a314ceb823229a88ee19" translate="yes" xml:space="preserve">
          <source>FLT_MAX_10_EXPDBL_MAX_10_EXPLDBL_MAX_10_EXP</source>
          <target state="translated">FLT_MAX_10_EXPDBL_MAX_10_EXPLDBL_MAX_10_EXP</target>
        </trans-unit>
        <trans-unit id="ed2d991f061e360c893c5a713ef996b38ebffdc9" translate="yes" xml:space="preserve">
          <source>FLT_MAX_EXPDBL_MAX_EXPLDBL_MAX_EXP</source>
          <target state="translated">FLT_MAX_EXPDBL_MAX_EXPLDBL_MAX_EXP</target>
        </trans-unit>
        <trans-unit id="24b8072d7962d75d2c508ff42b7b1b1555e6bb66" translate="yes" xml:space="preserve">
          <source>FLT_MINDBL_MINLDBL_MIN</source>
          <target state="translated">FLT_MINDBL_MINLDBL_MIN</target>
        </trans-unit>
        <trans-unit id="6869500f7b0f9c2b39432ab1b4dcf3e3690ba2a4" translate="yes" xml:space="preserve">
          <source>FLT_MIN_10_EXPDBL_MIN_10_EXPLDBL_MIN_10_EXP</source>
          <target state="translated">FLT_MIN_10_EXPDBL_MIN_10_EXPLDBL_MIN_10_EXP</target>
        </trans-unit>
        <trans-unit id="d64b48614536e2d9f3fd84e0b2d0f3339ef6dae1" translate="yes" xml:space="preserve">
          <source>FLT_MIN_EXPDBL_MIN_EXPLDBL_MIN_EXP</source>
          <target state="translated">FLT_MIN_EXPDBL_MIN_EXPLDBL_MIN_EXP</target>
        </trans-unit>
        <trans-unit id="3d8d38284d7c48984126ae4544c8465c506ee097" translate="yes" xml:space="preserve">
          <source>FLT_RADIX</source>
          <target state="translated">FLT_RADIX</target>
        </trans-unit>
        <trans-unit id="234dca4e2a0e92e5608ec0464e330e76723ea1d3" translate="yes" xml:space="preserve">
          <source>FLT_ROUNDS</source>
          <target state="translated">FLT_ROUNDS</target>
        </trans-unit>
        <trans-unit id="7e6cd06ba47da57a942743f790919ca173fb6d20" translate="yes" xml:space="preserve">
          <source>FLT_TRUE_MINDBL_TRUE_MINLDBL_TRUE_MIN</source>
          <target state="translated">FLT_TRUE_MINDBL_TRUE_MINLDBL_TRUE_MIN</target>
        </trans-unit>
        <trans-unit id="60945a4b9de8b69d4d5468fc065e520c99d43f40" translate="yes" xml:space="preserve">
          <source>FOPEN_MAX</source>
          <target state="translated">FOPEN_MAX</target>
        </trans-unit>
        <trans-unit id="052dbc6bd1e79a500f50639c055da0a0bddfcda6" translate="yes" xml:space="preserve">
          <source>FP_NORMAL, FP_SUBNORMAL, FP_ZERO, FP_INFINITE, FP_NAN</source>
          <target state="translated">FP_NORMAL,FP_SUBNORMAL,FP_ZERO,FP_INFINITE,FP_NAN</target>
        </trans-unit>
        <trans-unit id="4b390f17b3415cc66503253a8e943ae6869cbbbb" translate="yes" xml:space="preserve">
          <source>FP_NORMALFP_SUBNORMALFP_ZEROFP_INFINITEFP_NAN</source>
          <target state="translated">FP_NORMALFP_SUBNORMALFP_ZEROFP_INFINITEFP_NAN</target>
        </trans-unit>
        <trans-unit id="13ad13aaa89439dd8522b85f083a14ec539c93e9" translate="yes" xml:space="preserve">
          <source>FP_ZERO</source>
          <target state="translated">FP_ZERO</target>
        </trans-unit>
        <trans-unit id="8c6c7c8ebbe0f69f73a317ea017f66dfe215ff4a" translate="yes" xml:space="preserve">
          <source>Facet categories</source>
          <target state="translated">Категории лиц</target>
        </trans-unit>
        <trans-unit id="041a83e17c0f537ae2ed62d3b2cdf6826e396193" translate="yes" xml:space="preserve">
          <source>Facet category base classes</source>
          <target state="translated">Базовые классы категории Facet</target>
        </trans-unit>
        <trans-unit id="b533c7fea0c500ba4ef293884991083e32ec4a68" translate="yes" xml:space="preserve">
          <source>Facets with the same &lt;code&gt;id&lt;/code&gt; belong to the same facet category and replace each other when added to a locale object.</source>
          <target state="translated">Фасеты с одинаковым &lt;code&gt;id&lt;/code&gt; принадлежат к одной и той же категории фасетов и заменяют друг друга при добавлении в объект локали.</target>
        </trans-unit>
        <trans-unit id="66908b176ccb4f40a6f1a10938d28a50727305a6" translate="yes" xml:space="preserve">
          <source>Factor operations</source>
          <target state="translated">Факторные операции</target>
        </trans-unit>
        <trans-unit id="5580687121fcfefa146981fb36d296bc3f0de348" translate="yes" xml:space="preserve">
          <source>Factories</source>
          <target state="translated">Factories</target>
        </trans-unit>
        <trans-unit id="ce6c5bc258e8bef5e3ae59b1338a20c4748ea8d2" translate="yes" xml:space="preserve">
          <source>Failure to open</source>
          <target state="translated">Не открывается</target>
        </trans-unit>
        <trans-unit id="d3051aec047cdd51e6d43d2664a5df396a9877fb" translate="yes" xml:space="preserve">
          <source>Failures to meet the postconditions, such as failing to produce a valid return value object</source>
          <target state="translated">Неспособность выполнить постусловия,такие как неспособность создать объект с действительным возвращаемым значением</target>
        </trans-unit>
        <trans-unit id="3914bd46dc4687d6b7087f5c008acc618475cc00" translate="yes" xml:space="preserve">
          <source>Failures to meet the preconditions of another function that must be called</source>
          <target state="translated">Неспособность выполнить предварительные условия другой функции,которая должна быть вызвана</target>
        </trans-unit>
        <trans-unit id="c29752c93447e11b1a890d7ac78a70435ca5bdb4" translate="yes" xml:space="preserve">
          <source>Fancy pointers</source>
          <target state="translated">Фантастические указатели</target>
        </trans-unit>
        <trans-unit id="b494fef582ccfffefb54575ea4e577f7dbaf26c1" translate="yes" xml:space="preserve">
          <source>Fast access but fixed number of elements</source>
          <target state="translated">Быстрый доступ,но фиксированное количество элементов</target>
        </trans-unit>
        <trans-unit id="24dd69ccc43e1ae6d5f5a742d02f0da0f6b32305" translate="yes" xml:space="preserve">
          <source>Fast access but mostly inefficient insertions/deletions</source>
          <target state="translated">Быстрый доступ,но в основном неэффективные вставки/удаления</target>
        </trans-unit>
        <trans-unit id="ad565d9d01d0e0bf91fd6a8532f6d81613338901" translate="yes" xml:space="preserve">
          <source>Feature</source>
          <target state="translated">Feature</target>
        </trans-unit>
        <trans-unit id="0775fb360f01bab977ed5ec997840be1f65f3719" translate="yes" xml:space="preserve">
          <source>Feature testing</source>
          <target state="translated">Испытание характеристик</target>
        </trans-unit>
        <trans-unit id="9fe9f4b9291746b85204d55ff6be73414f9570ac" translate="yes" xml:space="preserve">
          <source>Feature testing (C++20)</source>
          <target state="translated">Функциональное тестирование (C++20)</target>
        </trans-unit>
        <trans-unit id="bc0228c9de8004fdac6db7743fdd23e61859a392" translate="yes" xml:space="preserve">
          <source>Fence-atomic synchronization</source>
          <target state="translated">атомно-заборная синхронизация</target>
        </trans-unit>
        <trans-unit id="c0f00371ddb6eac35be65eb720b3cab89de6182d" translate="yes" xml:space="preserve">
          <source>Fence-fence synchronization</source>
          <target state="translated">Синхронизация ограждений</target>
        </trans-unit>
        <trans-unit id="e79120c3392d8a2111f0e85788e61d24a2973100" translate="yes" xml:space="preserve">
          <source>Fence-fence synchronization can be used to add synchronization to a sequence of several relaxed atomic operations, for example.</source>
          <target state="translated">Синхронизация ограждения может быть использована,например,для добавления синхронизации к последовательности нескольких расслабленных атомных операций.</target>
        </trans-unit>
        <trans-unit id="9d413b1e7e21f8acf4d5ba31c56b61a1a190cf03" translate="yes" xml:space="preserve">
          <source>File I/O implementation</source>
          <target state="translated">Реализация ввода/вывода файлов</target>
        </trans-unit>
        <trans-unit id="a1369155ac8ee1937c5466bde76ab0bbbcbba45c" translate="yes" xml:space="preserve">
          <source>File access</source>
          <target state="translated">Доступ к файлам</target>
        </trans-unit>
        <trans-unit id="ecbca940d8a1676fb3cfcf517eb3d1e3e48574ec" translate="yes" xml:space="preserve">
          <source>File access mode flag &lt;code&gt;&quot;b&quot;&lt;/code&gt; can optionally be specified to open a file &lt;a href=&quot;../c#Binary_and_text_modes&quot;&gt;in binary mode&lt;/a&gt;. This flag has no effect on POSIX systems, but on Windows, for example, it disables special handling of &lt;code&gt;'\n'&lt;/code&gt; and &lt;code&gt;'\x1A'&lt;/code&gt;.</source>
          <target state="translated">При желании можно указать флаг режима доступа к файлу &lt;code&gt;&quot;b&quot;&lt;/code&gt; чтобы открыть файл &lt;a href=&quot;../c#Binary_and_text_modes&quot;&gt;в двоичном режиме&lt;/a&gt; . Этот флаг не влияет на системы POSIX, но в Windows, например, он отключает специальную обработку &lt;code&gt;'\n'&lt;/code&gt; и &lt;code&gt;'\x1A'&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9675879f138420dc849c3b02c7a08a45f1764ce0" translate="yes" xml:space="preserve">
          <source>File access mode flag &lt;code&gt;&quot;x&quot;&lt;/code&gt; can optionally be appended to &quot;w&quot; or &quot;w+&quot; specifiers. This flag forces the function to fail if the file exists, instead of overwriting it. (C++17)</source>
          <target state="translated">Флаг режима доступа к файлу &lt;code&gt;&quot;x&quot;&lt;/code&gt; может быть добавлен к спецификаторам &amp;laquo;w&amp;raquo; или &amp;laquo;w +&amp;raquo;. Этот флаг вызывает сбой функции, если файл существует, вместо перезаписи. (C ++ 17)</target>
        </trans-unit>
        <trans-unit id="848538ee54491f003e342600d6426cc1665c1d90" translate="yes" xml:space="preserve">
          <source>File descriptor value too large</source>
          <target state="translated">Слишком большое значение дескриптора файла</target>
        </trans-unit>
        <trans-unit id="e4abf36a5ea54ec41cce22ec0fe706639aba0b93" translate="yes" xml:space="preserve">
          <source>File exists</source>
          <target state="translated">Файл существует</target>
        </trans-unit>
        <trans-unit id="64fd779c46cf2d931941b36cb1e56f079e1d6e2c" translate="yes" xml:space="preserve">
          <source>File operations</source>
          <target state="translated">Файловые операции</target>
        </trans-unit>
        <trans-unit id="0b24f6042e86aadda1815101f042d04954349481" translate="yes" xml:space="preserve">
          <source>File owner has execute/search permission</source>
          <target state="translated">Владелец файла имеет разрешение на выполнение/поиск</target>
        </trans-unit>
        <trans-unit id="1a3e84e64dd01307f0ee39195f923bfa54b5c0c6" translate="yes" xml:space="preserve">
          <source>File owner has read permission</source>
          <target state="translated">Владелец файла имеет разрешение на чтение</target>
        </trans-unit>
        <trans-unit id="00a45fcb3c463f25a9813f51c216665d3293d7ab" translate="yes" xml:space="preserve">
          <source>File owner has read, write, and execute/search permissions</source>
          <target state="translated">Владелец файла имеет права на чтение,запись и выполнение/поиск.</target>
        </trans-unit>
        <trans-unit id="01358bbedd5677b98189c5d53b33f357f182c488" translate="yes" xml:space="preserve">
          <source>File owner has write permission</source>
          <target state="translated">Владелец файла имеет письменное разрешение</target>
        </trans-unit>
        <trans-unit id="1a996ddad7a713856017f5f90fe0498db20bdbda" translate="yes" xml:space="preserve">
          <source>File position indicator on success or &lt;code&gt;-1L&lt;/code&gt; if failure occurs. Also sets &lt;code&gt;&lt;a href=&quot;../../error/errno&quot;&gt;errno&lt;/a&gt;&lt;/code&gt; on failure.</source>
          <target state="translated">Индикатор положения файла в случае успеха или &lt;code&gt;-1L&lt;/code&gt; в случае сбоя. Также устанавливает &lt;code&gt;&lt;a href=&quot;../../error/errno&quot;&gt;errno&lt;/a&gt;&lt;/code&gt; на неудачу.</target>
        </trans-unit>
        <trans-unit id="a494399ad447f56f41d7522c5db08562d3c24708" translate="yes" xml:space="preserve">
          <source>File positioning</source>
          <target state="translated">Позиционирование файла</target>
        </trans-unit>
        <trans-unit id="36cd96e05c782cee5791cf21bde1893978c5c077" translate="yes" xml:space="preserve">
          <source>File scope</source>
          <target state="translated">Файловые метлы</target>
        </trans-unit>
        <trans-unit id="a0704a4eaa055ab08e3766911e446737f4f2a445" translate="yes" xml:space="preserve">
          <source>File too large</source>
          <target state="translated">Файл слишком большой</target>
        </trans-unit>
        <trans-unit id="0205534386e03d869079430b7c0117e9af5229d7" translate="yes" xml:space="preserve">
          <source>File types</source>
          <target state="translated">Типы файлов</target>
        </trans-unit>
        <trans-unit id="fae255f2995d1f907f01cf7594e8462316da5be7" translate="yes" xml:space="preserve">
          <source>Filename and line information</source>
          <target state="translated">Имя файла и информация о строке</target>
        </trans-unit>
        <trans-unit id="5ba8d30ffba45db4e2f3f220829fe902e2fd990f" translate="yes" xml:space="preserve">
          <source>Filename too long</source>
          <target state="translated">Фильм слишком длинный</target>
        </trans-unit>
        <trans-unit id="092fe85f5c2e62269fa44ec1fcbf190e92f16564" translate="yes" xml:space="preserve">
          <source>Filesystem</source>
          <target state="translated">Filesystem</target>
        </trans-unit>
        <trans-unit id="bbc4c49f164b158dbe825399e8316a41a98039c5" translate="yes" xml:space="preserve">
          <source>Filesystem TS</source>
          <target state="translated">Файловая система TS</target>
        </trans-unit>
        <trans-unit id="f6adde9d94ef3f9818beca92c4fb5775d3d08a90" translate="yes" xml:space="preserve">
          <source>Filesystem library</source>
          <target state="translated">Библиотека файловой системы</target>
        </trans-unit>
        <trans-unit id="d6016e126bb1261237244c868e871626e1164a78" translate="yes" xml:space="preserve">
          <source>Fills [&lt;code&gt;rb&lt;/code&gt;,&lt;code&gt;re&lt;/code&gt;) with 32-bit quantities depending on the initial supplied values and potential previous calls to &lt;code&gt;generate&lt;/code&gt;. If &lt;code&gt;rb == re&lt;/code&gt;, it does nothing.</source>
          <target state="translated">Заполняет [ &lt;code&gt;rb&lt;/code&gt; , &lt;code&gt;re&lt;/code&gt; ) 32-битными величинами в зависимости от начальных значений и возможных предыдущих вызовов для &lt;code&gt;generate&lt;/code&gt; . Если &lt;code&gt;rb == re&lt;/code&gt; , он ничего не делает.</target>
        </trans-unit>
        <trans-unit id="0477adab8010ca288bf22b1b3deddefba747b42d" translate="yes" xml:space="preserve">
          <source>Fills the range &lt;code&gt;[begin, end)&lt;/code&gt; with unsigned integer values &lt;code&gt;i&lt;/code&gt;, 0 &amp;le; i &amp;lt; 232</source>
          <target state="translated">Заполняет диапазон &lt;code&gt;[begin, end)&lt;/code&gt; целыми значениями без знака &lt;code&gt;i&lt;/code&gt; , 0 &amp;le; i &amp;lt;232</target>
        </trans-unit>
        <trans-unit id="da2860ae65231144c9442af16b999bbb60810f8b" translate="yes" xml:space="preserve">
          <source>Fills the range &lt;code&gt;[first, last)&lt;/code&gt; with sequentially increasing values, starting with &lt;code&gt;value&lt;/code&gt; and repetitively evaluating &lt;code&gt;++value&lt;/code&gt;.</source>
          <target state="translated">Заполняет диапазон &lt;code&gt;[first, last)&lt;/code&gt; последовательно увеличивающимися значениями, начиная со &lt;code&gt;value&lt;/code&gt; и повторяя оценку &lt;code&gt;++value&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ae117132b523ad7bbcabf063e4512b94303ad825" translate="yes" xml:space="preserve">
          <source>Final classes cannot be used as base classes.</source>
          <target state="translated">Финальные классы не могут быть использованы в качестве базовых классов.</target>
        </trans-unit>
        <trans-unit id="f71bda78a1e6997b4c579d61039ab383458a0b93" translate="yes" xml:space="preserve">
          <source>Finally, &lt;code&gt;awaiter.await_resume()&lt;/code&gt; is called, and its result is the result of the whole &lt;code&gt;co_await expr&lt;/code&gt; expression.</source>
          <target state="translated">Наконец, &lt;code&gt;awaiter.await_resume()&lt;/code&gt; , и его результат является результатом всего выражения &lt;code&gt;co_await expr&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4db4903bd597b61dd8a328899682e291be0a76a1" translate="yes" xml:space="preserve">
          <source>Finally, calls &lt;code&gt;is.width(0)&lt;/code&gt; to cancel the effects of &lt;code&gt;&lt;a href=&quot;../../io/manip/setw&quot;&gt;std::setw&lt;/a&gt;&lt;/code&gt;, if any.</source>
          <target state="translated">Наконец, вызывает &lt;code&gt;is.width(0)&lt;/code&gt; для отмены эффектов &lt;code&gt;&lt;a href=&quot;../../io/manip/setw&quot;&gt;std::setw&lt;/a&gt;&lt;/code&gt; , если таковые имеются.</target>
        </trans-unit>
        <trans-unit id="9e4015259c16ae5de63c7894d2c7b391c4ca0b80" translate="yes" xml:space="preserve">
          <source>Finally, calls &lt;code&gt;os.width(0)&lt;/code&gt; to cancel the effects of &lt;code&gt;&lt;a href=&quot;../../io/manip/setw&quot;&gt;std::setw&lt;/a&gt;&lt;/code&gt;, if any.</source>
          <target state="translated">Наконец, вызывает &lt;code&gt;os.width(0)&lt;/code&gt; для отмены эффектов &lt;code&gt;&lt;a href=&quot;../../io/manip/setw&quot;&gt;std::setw&lt;/a&gt;&lt;/code&gt; , если таковые имеются.</target>
        </trans-unit>
        <trans-unit id="177dc3f32e13dff30c58fffec60fe61e244cc93e" translate="yes" xml:space="preserve">
          <source>Finally, outputs each character from the resulting sequence as if by calling &lt;code&gt;out.rdbuf()-&amp;gt;sputn(seq, n)&lt;/code&gt;, where &lt;code&gt;n=&lt;a href=&quot;../../algorithm/max&quot;&gt;std::max&lt;/a&gt;(out.width(), seq.size())&lt;/code&gt; and &lt;code&gt;out.width(0)&lt;/code&gt; to cancel the effects of &lt;code&gt;&lt;a href=&quot;setw&quot;&gt;std::setw&lt;/a&gt;&lt;/code&gt;, if any.</source>
          <target state="translated">Наконец, выводит каждый символ из результирующей последовательности, как если бы он вызывал &lt;code&gt;out.rdbuf()-&amp;gt;sputn(seq, n)&lt;/code&gt; , где &lt;code&gt;n=&lt;a href=&quot;../../algorithm/max&quot;&gt;std::max&lt;/a&gt;(out.width(), seq.size())&lt;/code&gt; и &lt;code&gt;out.width(0)&lt;/code&gt; для отмены эффектов &lt;code&gt;&lt;a href=&quot;setw&quot;&gt;std::setw&lt;/a&gt;&lt;/code&gt; , если таковые имеются.</target>
        </trans-unit>
        <trans-unit id="00d858cc8e88f691053b3dcc6137ac4cde6d6ced" translate="yes" xml:space="preserve">
          <source>Finds an element equal to element pointed to by &lt;code&gt;key&lt;/code&gt; in an array pointed to by &lt;code&gt;ptr&lt;/code&gt;. The array contains &lt;code&gt;count&lt;/code&gt; elements of &lt;code&gt;size&lt;/code&gt; bytes each and must be partitioned with respect to the object pointed to by &lt;code&gt;key&lt;/code&gt;, that is, all the elements that compare less than must appear before all the elements that compare equal to, and those must appear before all the elements that compare greater than the key object. A fully sorted array satisfies these requirements. The elements are compared using function pointed to by &lt;code&gt;comp&lt;/code&gt;.</source>
          <target state="translated">Находит элемент, равный элементу, на который указывает &lt;code&gt;key&lt;/code&gt; в массиве, на который указывает &lt;code&gt;ptr&lt;/code&gt; . Массив содержит &lt;code&gt;count&lt;/code&gt; элементов &lt;code&gt;size&lt;/code&gt; байтов каждый и должен быть разбит на части относительно объекта, на который указывает &lt;code&gt;key&lt;/code&gt; , то есть все элементы, которые сравниваются меньше, чем должны появляться перед всеми элементами, которые сравниваются равными, и те, которые должны появляться перед всеми элементы, которые сравниваются больше, чем ключевой объект. Полностью отсортированный массив удовлетворяет этим требованиям. Элементы сравниваются с помощью функции, на которую указывает &lt;code&gt;comp&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e9927a1e661f4bfd80aaf31b22f6f41e30e9b227" translate="yes" xml:space="preserve">
          <source>Finds real roots of multiple quadratic equations.</source>
          <target state="translated">Находит реальные корни множественных квадратичных уравнений.</target>
        </trans-unit>
        <trans-unit id="30bcbdf5d9a1fe0bd647e009803f909f56efc575" translate="yes" xml:space="preserve">
          <source>Finds the first character equal to any of the characters in the given character sequence.</source>
          <target state="translated">Находит первый символ,равный любому из символов в данной последовательности символов.</target>
        </trans-unit>
        <trans-unit id="5cdb4e092b97109f8b2048be07ca72c3bde0609f" translate="yes" xml:space="preserve">
          <source>Finds the first character equal to none of the characters in the given character sequence. The search considers only the interval [&lt;code&gt;pos&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;size&quot;&gt;size()&lt;/a&gt;&lt;/code&gt;). If the character is not present in the interval, &lt;code&gt;&lt;a href=&quot;npos&quot;&gt;npos&lt;/a&gt;&lt;/code&gt; will be returned.</source>
          <target state="translated">Находит первый символ, равный ни одному из символов в данной последовательности символов. Поиск учитывает только интервал [ &lt;code&gt;pos&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;size&quot;&gt;size()&lt;/a&gt;&lt;/code&gt; ). Если символ отсутствует в интервале, &lt;code&gt;&lt;a href=&quot;npos&quot;&gt;npos&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="24f9fbec876cfd13c75d96d81a6a74110daac9d5" translate="yes" xml:space="preserve">
          <source>Finds the first character equal to one of the characters in the given character sequence. The search considers only the interval [&lt;code&gt;pos&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;size&quot;&gt;size()&lt;/a&gt;&lt;/code&gt;). If the character is not present in the interval, &lt;code&gt;&lt;a href=&quot;npos&quot;&gt;npos&lt;/a&gt;&lt;/code&gt; will be returned.</source>
          <target state="translated">Находит первый символ, равный одному из символов в данной последовательности символов. Поиск учитывает только интервал [ &lt;code&gt;pos&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;size&quot;&gt;size()&lt;/a&gt;&lt;/code&gt; ). Если символ отсутствует в интервале, &lt;code&gt;&lt;a href=&quot;npos&quot;&gt;npos&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a02ae1c73392d3f6a41d7039bf6f66883821f319" translate="yes" xml:space="preserve">
          <source>Finds the first character in wide string pointed to by &lt;code&gt;dest&lt;/code&gt;, that is also in wide string pointed to by &lt;code&gt;str&lt;/code&gt;.</source>
          <target state="translated">Находит первый символ в широкой строке, на которую указывает &lt;code&gt;dest&lt;/code&gt; , то есть также в широкой строке, на которую указывает &lt;code&gt;str&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="981d0030e7019507414199bd0e078d7265cd8673" translate="yes" xml:space="preserve">
          <source>Finds the first character not equal to any of the characters in the given character sequence.</source>
          <target state="translated">Находит первый символ,не равный ни одному из символов в данной последовательности символов.</target>
        </trans-unit>
        <trans-unit id="c744c8fe55a01d138ec8c24e1528aec65ec2023a" translate="yes" xml:space="preserve">
          <source>Finds the first occurrence of the byte string &lt;code&gt;target&lt;/code&gt; in the byte string pointed to by &lt;code&gt;str&lt;/code&gt;. The terminating null characters are not compared.</source>
          <target state="translated">Находит первое вхождение &lt;code&gt;target&lt;/code&gt; байтовой строки в байтовой строке, на которую указывает &lt;code&gt;str&lt;/code&gt; . Завершающие нулевые символы не сравниваются.</target>
        </trans-unit>
        <trans-unit id="822e0508dd7e5034ad40e0d29a486e2402585a0d" translate="yes" xml:space="preserve">
          <source>Finds the first occurrence of the character &lt;code&gt;static_cast&amp;lt;char&amp;gt;(ch)&lt;/code&gt; in the byte string pointed to by &lt;code&gt;str&lt;/code&gt;.</source>
          <target state="translated">Находит первое вхождение символа &lt;code&gt;static_cast&amp;lt;char&amp;gt;(ch)&lt;/code&gt; в строке байтов, на которую указывает &lt;code&gt;str&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9388d73210fb9a6adcc18de249cc87e2da6d4106" translate="yes" xml:space="preserve">
          <source>Finds the first occurrence of the wide character &lt;code&gt;ch&lt;/code&gt; in the wide string pointed to by &lt;code&gt;str&lt;/code&gt;.</source>
          <target state="translated">Находит первое вхождение широкого символа &lt;code&gt;ch&lt;/code&gt; в широкой строке, на которую указывает &lt;code&gt;str&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="60954d9dde97ea95b47805de626af5f9bb89a11c" translate="yes" xml:space="preserve">
          <source>Finds the first occurrence of the wide string &lt;code&gt;src&lt;/code&gt; in the wide string pointed to by &lt;code&gt;dest&lt;/code&gt;. The terminating null characters are not compared.</source>
          <target state="translated">Находит первое вхождение широкой строки &lt;code&gt;src&lt;/code&gt; в широкой строке, на которую указывает &lt;code&gt;dest&lt;/code&gt; . Завершающие нулевые символы не сравниваются.</target>
        </trans-unit>
        <trans-unit id="fc71329dcb9337103dd5851e9eb7dfa903cd2767" translate="yes" xml:space="preserve">
          <source>Finds the first substring equal to the given character sequence.</source>
          <target state="translated">Находит первую подстроку,равную заданной последовательности символов.</target>
        </trans-unit>
        <trans-unit id="73d8f05c9748bf0bddfc6937b1e51af871f089f0" translate="yes" xml:space="preserve">
          <source>Finds the first substring equal to the given character sequence. Search begins at &lt;code&gt;pos&lt;/code&gt;, i.e. the found substring must not begin in a position preceding &lt;code&gt;pos&lt;/code&gt;.</source>
          <target state="translated">Находит первую подстроку, равную данной последовательности символов. Поиск начинается с &lt;code&gt;pos&lt;/code&gt; , то есть найденная подстрока не должна начинаться с позиции, предшествующей &lt;code&gt;pos&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d519b8e547c2fea611a706cf0f567de8c481f047" translate="yes" xml:space="preserve">
          <source>Finds the greatest element in the range &lt;code&gt;[first, last)&lt;/code&gt;.</source>
          <target state="translated">Находит самый большой элемент в диапазоне &lt;code&gt;[first, last)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2a0eba935882bc5c40f3eb57edca9ffaa6207e17" translate="yes" xml:space="preserve">
          <source>Finds the last character equal to none of the characters in the given character sequence. The search considers only the interval [0, pos]. If the character is not present in the interval, &lt;code&gt;&lt;a href=&quot;npos&quot;&gt;npos&lt;/a&gt;&lt;/code&gt; will be returned.</source>
          <target state="translated">Находит последний символ, равный ни одному из символов в данной последовательности символов. Поиск учитывает только интервал [0, pos]. Если символ отсутствует в интервале, &lt;code&gt;&lt;a href=&quot;npos&quot;&gt;npos&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="031b5bc7f5b52d9b68f531ec16e07add0732f8a9" translate="yes" xml:space="preserve">
          <source>Finds the last character equal to one of characters in the given character sequence. Exact search algorithm is not specified. The search considers only the interval [0; pos]. If the character is not present in the interval, &lt;code&gt;&lt;a href=&quot;npos&quot;&gt;npos&lt;/a&gt;&lt;/code&gt; will be returned.</source>
          <target state="translated">Находит последний символ, равный одному из символов в данной последовательности символов. Точный алгоритм поиска не указан. Поиск учитывает только интервал [0; поз]. Если символ отсутствует в интервале, &lt;code&gt;&lt;a href=&quot;npos&quot;&gt;npos&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="262672fc83487a5e2f2a3a72605026935426490e" translate="yes" xml:space="preserve">
          <source>Finds the last character equal to one of characters in the given character sequence. The exact search algorithm is not specified. The search considers only the interval [0, pos]. If the character is not present in the interval, &lt;code&gt;&lt;a href=&quot;npos&quot;&gt;npos&lt;/a&gt;&lt;/code&gt; will be returned.</source>
          <target state="translated">Находит последний символ, равный одному из символов в данной последовательности символов. Точный алгоритм поиска не указан. Поиск учитывает только интервал [0, pos]. Если символ отсутствует в интервале, &lt;code&gt;&lt;a href=&quot;npos&quot;&gt;npos&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c2eeb42fd9c4368ca6e261a7eaf0eb9173c9ca19" translate="yes" xml:space="preserve">
          <source>Finds the last character not equal to any of the characters in the given character sequence.</source>
          <target state="translated">Находит последний символ,не равный ни одному из символов в данной последовательности символов.</target>
        </trans-unit>
        <trans-unit id="c9e927921904e1bd8a7847a95ec12dfc3ed90fd5" translate="yes" xml:space="preserve">
          <source>Finds the last occurrence of &lt;code&gt;ch&lt;/code&gt; (after conversion to &lt;code&gt;char&lt;/code&gt;) in the byte string pointed to by &lt;code&gt;str&lt;/code&gt;. The terminating null character is considered to be a part of the string and can be found if searching for &lt;code&gt;'\0'&lt;/code&gt;.</source>
          <target state="translated">Находит последнее вхождение &lt;code&gt;ch&lt;/code&gt; (после преобразования в &lt;code&gt;char&lt;/code&gt; ) в байтовой строке, на которую указывает &lt;code&gt;str&lt;/code&gt; . Завершающий нулевой символ считается частью строки и может быть найден при поиске &lt;code&gt;'\0'&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="abb2c2feff5f0426d0ef85cddeeca9860311e3e9" translate="yes" xml:space="preserve">
          <source>Finds the last occurrence of the wide character &lt;code&gt;ch&lt;/code&gt; in the wide string pointed to by &lt;code&gt;str&lt;/code&gt;.</source>
          <target state="translated">Находит последнее вхождение широкого символа &lt;code&gt;ch&lt;/code&gt; в широкой строке, на которую указывает &lt;code&gt;str&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="aba2a0477e061745abafbf2e570698649cfbd049" translate="yes" xml:space="preserve">
          <source>Finds the last substring equal to the given character sequence.</source>
          <target state="translated">Находит последнюю подстроку,равную заданной последовательности символов.</target>
        </trans-unit>
        <trans-unit id="85ecfa172af6c676f0f2b7ede4563bdf54dbd13d" translate="yes" xml:space="preserve">
          <source>Finds the last substring equal to the given character sequence. Search begins at &lt;code&gt;pos&lt;/code&gt;, i.e. the found substring must not begin in a position following &lt;code&gt;pos&lt;/code&gt;. If &lt;code&gt;&lt;a href=&quot;npos&quot;&gt;npos&lt;/a&gt;&lt;/code&gt; or any value not smaller than &lt;code&gt;&lt;a href=&quot;size&quot;&gt;size()&lt;/a&gt;&lt;/code&gt;-1 is passed as &lt;code&gt;pos&lt;/code&gt;, whole string will be searched.</source>
          <target state="translated">Находит последнюю подстроку, равную данной последовательности символов. Поиск начинается с &lt;code&gt;pos&lt;/code&gt; , то есть найденная подстрока не должна начинаться с позиции, следующей за &lt;code&gt;pos&lt;/code&gt; . Если &lt;code&gt;&lt;a href=&quot;npos&quot;&gt;npos&lt;/a&gt;&lt;/code&gt; или любое значение, не меньшее, чем &lt;code&gt;&lt;a href=&quot;size&quot;&gt;size()&lt;/a&gt;&lt;/code&gt; -1, передается как &lt;code&gt;pos&lt;/code&gt; , будет выполняться поиск по всей строке.</target>
        </trans-unit>
        <trans-unit id="4e96707b2590ca4719626a87f0675c2693cd9371" translate="yes" xml:space="preserve">
          <source>Finds the next token in a null-terminated byte string pointed to by &lt;code&gt;str&lt;/code&gt;. The separator characters are identified by null-terminated byte string pointed to by &lt;code&gt;delim&lt;/code&gt;.</source>
          <target state="translated">Находит следующий токен в байтовой строке с нулевым символом в конце, на которую указывает &lt;code&gt;str&lt;/code&gt; . Символы-разделители идентифицируются байтовой строкой с нулевым символом в &lt;code&gt;delim&lt;/code&gt; на которую указывает разделитель .</target>
        </trans-unit>
        <trans-unit id="380ef08d0f8e6c7597e5b529abb1fb2b2ba51aa4" translate="yes" xml:space="preserve">
          <source>Finds the next token in a null-terminated wide string pointed to by &lt;code&gt;str&lt;/code&gt;. The separator characters are identified by null-terminated wide string pointed to by &lt;code&gt;delim&lt;/code&gt;.</source>
          <target state="translated">Находит следующий токен в широкой строке с нулевым символом в конце, на которую указывает &lt;code&gt;str&lt;/code&gt; . Символы-разделители идентифицируются широкой строкой с нулевым символом в &lt;code&gt;delim&lt;/code&gt; на которую указывает разделитель .</target>
        </trans-unit>
        <trans-unit id="59f9527a2060df058f520ec4facfb5d116cfb5ab" translate="yes" xml:space="preserve">
          <source>Finds the smallest and greatest element in the range &lt;code&gt;[first, last)&lt;/code&gt;.</source>
          <target state="translated">Находит самый маленький и самый большой элемент в диапазоне &lt;code&gt;[first, last)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="73f7ebc728f72e9244fbcb71e4bebffbcaa8c095" translate="yes" xml:space="preserve">
          <source>Finds the smallest element in the range &lt;code&gt;[first, last)&lt;/code&gt;.</source>
          <target state="translated">Находит наименьший элемент в диапазоне &lt;code&gt;[first, last)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fb4718767cbeb7ec2a4050ea8b0704c79bba10d8" translate="yes" xml:space="preserve">
          <source>First clears &lt;a href=&quot;../ios_base/iostate&quot;&gt;&lt;code&gt;eofbit&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Сначала очищает &lt;a href=&quot;../ios_base/iostate&quot;&gt; &lt;code&gt;eofbit&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c779ca82cc21b768cc6c4bcc4f1d87107bdb7d29" translate="yes" xml:space="preserve">
          <source>First clears &lt;code&gt;eofbit&lt;/code&gt;, then behaves as &lt;a href=&quot;../../named_req/unformattedinputfunction&quot;&gt;UnformattedInputFunction&lt;/a&gt;. After constructing and checking the sentry object, if &lt;code&gt;rdbuf()&lt;/code&gt; is not null, calls &lt;code&gt;rdbuf()-&amp;gt;sputbackc(ch)&lt;/code&gt;, which calls &lt;code&gt;rdbuf()-&amp;gt;pbackfail(ch)&lt;/code&gt; if &lt;code&gt;ch&lt;/code&gt; does not equal the most recently extracted character.</source>
          <target state="translated">Сначала очищает &lt;code&gt;eofbit&lt;/code&gt; , затем ведет себя как &lt;a href=&quot;../../named_req/unformattedinputfunction&quot;&gt;UnformattedInputFunction&lt;/a&gt; . После создания и проверки объекта &lt;code&gt;rdbuf()&lt;/code&gt; , если rdbuf () не равен нулю, вызывает &lt;code&gt;rdbuf()-&amp;gt;sputbackc(ch)&lt;/code&gt; , который вызывает &lt;code&gt;rdbuf()-&amp;gt;pbackfail(ch)&lt;/code&gt; если &lt;code&gt;ch&lt;/code&gt; не равен последнему извлеченному символу.</target>
        </trans-unit>
        <trans-unit id="13f51e93c18a65140da3cb2cb1dfab78c49243a0" translate="yes" xml:space="preserve">
          <source>First destroys the current contained object (if any) by &lt;code&gt;&lt;a href=&quot;reset&quot;&gt;reset()&lt;/a&gt;&lt;/code&gt;, then:</source>
          <target state="translated">Сначала уничтожает текущий содержащийся объект (если есть) с помощью &lt;code&gt;&lt;a href=&quot;reset&quot;&gt;reset()&lt;/a&gt;&lt;/code&gt; , затем:</target>
        </trans-unit>
        <trans-unit id="401e859548baba3ec799317e533e96d7551f1830" translate="yes" xml:space="preserve">
          <source>First version</source>
          <target state="translated">Первый вариант</target>
        </trans-unit>
        <trans-unit id="1654933a6fa4f43716580ffeb045cae1b208fe38" translate="yes" xml:space="preserve">
          <source>First, &lt;a href=&quot;implicit_cast&quot;&gt;Pointer conversions&lt;/a&gt; (pointer to member conversions if the arguments are pointers to members), function pointer conversions,(since C++17) and &lt;a href=&quot;implicit_cast&quot;&gt;qualification conversions&lt;/a&gt; are applied to both operands to obtain the</source>
          <target state="translated">Во-первых, &lt;a href=&quot;implicit_cast&quot;&gt;преобразования Pointer&lt;/a&gt; (указатель на преобразования элементов, если аргументы являются указателями на элементы), преобразования указателей на функции (начиная с C ++ 17) и &lt;a href=&quot;implicit_cast&quot;&gt;квалификационные преобразования&lt;/a&gt; применяются к обоим операндам для получения</target>
        </trans-unit>
        <trans-unit id="30c242bb4e4e1c97688da86303f8e70ebf723f0f" translate="yes" xml:space="preserve">
          <source>First, allocates or resizes the private storage (dynamic array of &lt;code&gt;long&lt;/code&gt; or another indexable data structure) sufficiently to make &lt;code&gt;index&lt;/code&gt; a valid index, then returns a reference to the &lt;code&gt;long&lt;/code&gt; element of the private storage with the index &lt;code&gt;index&lt;/code&gt;.</source>
          <target state="translated">Сначала выделяется или изменяется размер частного хранилища (динамический массив &lt;code&gt;long&lt;/code&gt; или другая индексируемая структура данных) в достаточной степени, чтобы сделать &lt;code&gt;index&lt;/code&gt; допустимым индексом, а затем возвращается ссылка на &lt;code&gt;long&lt;/code&gt; элемент частного хранилища с индексным &lt;code&gt;index&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c741d459f4a943d6ccb7e91f1d19877e2b46cf15" translate="yes" xml:space="preserve">
          <source>First, allocates or resizes the private storage (dynamic array of &lt;code&gt;void*&lt;/code&gt; or another indexable data structure) sufficiently to make &lt;code&gt;index&lt;/code&gt; a valid index, then returns a reference to the &lt;code&gt;void*&lt;/code&gt; element of the private storage with the index &lt;code&gt;index&lt;/code&gt;.</source>
          <target state="translated">Сначала выделяет или изменяет размер частного хранилища (динамический массив &lt;code&gt;void*&lt;/code&gt; или другой индексируемой структуры данных) в достаточной степени, чтобы сделать &lt;code&gt;index&lt;/code&gt; допустимым индексом, затем возвращает ссылку на элемент &lt;code&gt;void*&lt;/code&gt; частного хранилища с индексным &lt;code&gt;index&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f1a406a5e11adcba583e47ceded69c0a59895e04" translate="yes" xml:space="preserve">
          <source>First, attempts to close the file associated with &lt;code&gt;stream&lt;/code&gt;, ignoring any errors. Then, if &lt;code&gt;filename&lt;/code&gt; is not null, attempts to open the file specified by &lt;code&gt;filename&lt;/code&gt; using &lt;code&gt;mode&lt;/code&gt; as if by &lt;code&gt;fopen&lt;/code&gt;, and associates that file with the file stream pointed to by &lt;code&gt;stream&lt;/code&gt;. If &lt;code&gt;filename&lt;/code&gt; is a null pointer, then the function attempts to reopen the file that is already associated with &lt;code&gt;stream&lt;/code&gt; (it is implementation defined which mode changes are allowed in this case).</source>
          <target state="translated">Сначала предпринимаются попытки закрыть файл, связанный с &lt;code&gt;stream&lt;/code&gt; , игнорируя любые ошибки. Затем, если &lt;code&gt;filename&lt;/code&gt; не равно нулю, пытается открыть файл, указанный в &lt;code&gt;filename&lt;/code&gt; используя &lt;code&gt;mode&lt;/code&gt; как если бы он был &lt;code&gt;fopen&lt;/code&gt; , и связывает этот файл с потоком файлов, на который указывает &lt;code&gt;stream&lt;/code&gt; . Если &lt;code&gt;filename&lt;/code&gt; является нулевым указателем, то функция пытается повторно открыть файл, который уже связан с &lt;code&gt;stream&lt;/code&gt; (это определяется реализацией, какие изменения режима разрешены в этом случае).</target>
        </trans-unit>
        <trans-unit id="5badc51c36e2585292a914e3f1823ec376257caf" translate="yes" xml:space="preserve">
          <source>First, before doing anything else, obtains type and permissions of &lt;code&gt;from&lt;/code&gt; by no more than a single call to</source>
          <target state="translated">Во-первых, прежде чем делать что-либо еще, получает тип и разрешения &lt;code&gt;from&lt;/code&gt; не более чем одного вызова</target>
        </trans-unit>
        <trans-unit id="bd0a7f661657d89c37e4c1215e80d0191bb4862d" translate="yes" xml:space="preserve">
          <source>First, calls &lt;a href=&quot;emit&quot;&gt;&lt;code&gt;emit()&lt;/code&gt;&lt;/a&gt; to transmit all pending output (and delayed flush, if any) to the wrapped stream.</source>
          <target state="translated">Сначала вызывается &lt;a href=&quot;emit&quot;&gt; &lt;code&gt;emit()&lt;/code&gt; &lt;/a&gt; для передачи всех ожидающих результатов (и отложенного сброса, если таковые имеются) в упакованный поток.</target>
        </trans-unit>
        <trans-unit id="eab9bd2628b9d318b166ebaf056d0f32c1ae9059" translate="yes" xml:space="preserve">
          <source>First, calls &lt;a href=&quot;emit&quot;&gt;&lt;code&gt;emit()&lt;/code&gt;&lt;/a&gt;. If an exception is thrown by the call to &lt;code&gt;emit()&lt;/code&gt;, it is caught and ignored.</source>
          <target state="translated">Во-первых, вызовы &lt;a href=&quot;emit&quot;&gt; &lt;code&gt;emit()&lt;/code&gt; &lt;/a&gt; . Если при вызове &lt;code&gt;emit()&lt;/code&gt; генерируется исключение , оно перехватывается и игнорируется.</target>
        </trans-unit>
        <trans-unit id="daac23b0d5c1b3ef73330f0f556ea905967387b5" translate="yes" xml:space="preserve">
          <source>First, calls &lt;a href=&quot;emit&quot;&gt;&lt;code&gt;emit()&lt;/code&gt;&lt;/a&gt;. If an exception is thrown by the call to &lt;code&gt;emit()&lt;/code&gt;, it is caught and ignored. Then, destroys the member &lt;code&gt;std::basic_syncbuf&lt;/code&gt; and the base &lt;code&gt;&lt;a href=&quot;../basic_ostream&quot;&gt;std::basic_ostream&lt;/a&gt;&lt;/code&gt; as usual.</source>
          <target state="translated">Во-первых, вызовы &lt;a href=&quot;emit&quot;&gt; &lt;code&gt;emit()&lt;/code&gt; &lt;/a&gt; . Если при вызове &lt;code&gt;emit()&lt;/code&gt; генерируется исключение , оно перехватывается и игнорируется. Затем, как обычно , уничтожает член &lt;code&gt;std::basic_syncbuf&lt;/code&gt; и базовый &lt;code&gt;&lt;a href=&quot;../basic_ostream&quot;&gt;std::basic_ostream&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="99f9e198aa798816c58da32cfc0095d286931e68" translate="yes" xml:space="preserve">
          <source>First, clears the error bits in &lt;code&gt;err&lt;/code&gt; by executing &lt;code&gt;err = &lt;a href=&quot;../../io/ios_base/iostate&quot;&gt;std::ios_base::goodbit&lt;/a&gt;&lt;/code&gt;. Then reads characters from the input sequence &lt;code&gt;[beg, end)&lt;/code&gt; that are expected by the &lt;code&gt;&lt;a href=&quot;../time_get&quot;&gt;std::time_get&lt;/a&gt;&lt;/code&gt; format specifier formed by combining &lt;code&gt;'%'&lt;/code&gt;, &lt;code&gt;modifier&lt;/code&gt; (if not &lt;code&gt;'\0'&lt;/code&gt;), and &lt;code&gt;format&lt;/code&gt;. If the characters do not combine to form a valid conversion specifier, sets &lt;code&gt;failbit&lt;/code&gt; in &lt;code&gt;err&lt;/code&gt;. If the end of the input stream is reached after reading a character, sets &lt;code&gt;eofbit&lt;/code&gt; in &lt;code&gt;err&lt;/code&gt;. If the input string was parsed successfully, updates the corresponding fields of &lt;code&gt;*t&lt;/code&gt;.   For complex conversion specifiers, such as &lt;code&gt;'%x'&lt;/code&gt; or &lt;code&gt;'%c'&lt;/code&gt;, or the directives that use the modifiers &lt;code&gt;'E'&lt;/code&gt; and &lt;code&gt;'O'&lt;/code&gt;, the function may fail to determine some of the values to store in &lt;code&gt;*t&lt;/code&gt;. In such case, it sets &lt;code&gt;eofbit&lt;/code&gt; in &lt;code&gt;err&lt;/code&gt; and leaves these fields in unspecified state.</source>
          <target state="translated">Сначала очищает биты ошибок в &lt;code&gt;err&lt;/code&gt; , выполняя &lt;code&gt;err = &lt;a href=&quot;../../io/ios_base/iostate&quot;&gt;std::ios_base::goodbit&lt;/a&gt;&lt;/code&gt; . Затем считывает символы из входной последовательности &lt;code&gt;[beg, end)&lt;/code&gt; , которые ожидаются &lt;code&gt;&lt;a href=&quot;../time_get&quot;&gt;std::time_get&lt;/a&gt;&lt;/code&gt; формата std :: time_get , сформированным путем объединения &lt;code&gt;'%'&lt;/code&gt; , &lt;code&gt;modifier&lt;/code&gt; (если не &lt;code&gt;'\0'&lt;/code&gt; ) и &lt;code&gt;format&lt;/code&gt; . Если символы не объединяются, чтобы сформировать действительный спецификатор преобразования, устанавливает &lt;code&gt;failbit&lt;/code&gt; в &lt;code&gt;err&lt;/code&gt; . Если конец входного потока достигнут после чтения символа, устанавливает &lt;code&gt;eofbit&lt;/code&gt; в &lt;code&gt;err&lt;/code&gt; . Если входная строка была успешно проанализирована, обновляются соответствующие поля &lt;code&gt;*t&lt;/code&gt; . Для сложных спецификаторов преобразования, таких как &lt;code&gt;'%x'&lt;/code&gt; или &lt;code&gt;'%c'&lt;/code&gt; , или директив, которые используют модификаторы &lt;code&gt;'E'&lt;/code&gt; и &lt;code&gt;'O'&lt;/code&gt; , функция может не определить некоторые значения для хранения в &lt;code&gt;*t&lt;/code&gt; . В этом случае он устанавливает &lt;code&gt;eofbit&lt;/code&gt; в значение &lt;code&gt;err&lt;/code&gt; и оставляет эти поля в неопределенном состоянии.</target>
        </trans-unit>
        <trans-unit id="761e411f45989f18b8cdc09dfae5d408bc3760bb" translate="yes" xml:space="preserve">
          <source>First, expr is converted to an awaitable as follows:</source>
          <target state="translated">Во-первых,экспрессия превращается в ожидаемую следующим образом:</target>
        </trans-unit>
        <trans-unit id="49e86d447ef30f5d8ac55d11082a293ce491a304" translate="yes" xml:space="preserve">
          <source>First, if &lt;code&gt;&lt;a href=&quot;../../types/numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::is_iec559&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, performs the ISO/IEC/IEEE 60559</source>
          <target state="translated">Во-первых, если &lt;code&gt;&lt;a href=&quot;../../types/numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::is_iec559&lt;/code&gt; имеет значение &lt;code&gt;true&lt;/code&gt; , выполняет ISO / IEC / IEEE 60559</target>
        </trans-unit>
        <trans-unit id="714bfffed5c4d1159d21c2074b0dd5ebd28587dd" translate="yes" xml:space="preserve">
          <source>First, if &lt;code&gt;T&lt;/code&gt; is a class type and the initializer is a &lt;a href=&quot;value_category&quot;&gt;prvalue&lt;/a&gt; expression whose cv-unqualified type is the same class as &lt;code&gt;T&lt;/code&gt;, the initializer expression itself, rather than a temporary materialized from it, is used to initialize the destination object: see &lt;a href=&quot;copy_elision&quot;&gt;copy elision&lt;/a&gt;</source>
          <target state="translated">Во-первых, если &lt;code&gt;T&lt;/code&gt; является типом класса и инициализатор является выражением &lt;a href=&quot;value_category&quot;&gt;prvalue,&lt;/a&gt; чей cv-unqualified тип является тем же классом, что и &lt;code&gt;T&lt;/code&gt; , то для инициализации целевого объекта используется само выражение инициализатора, а не временное материализованное из него: см. &lt;a href=&quot;copy_elision&quot;&gt;Копию элизия&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="3a19b536bb9ed4bb6c617709d11bbfa515bb05a0" translate="yes" xml:space="preserve">
          <source>First, if &lt;code&gt;root_name() != base.root_name() || is_absolute() != base.is_absolute() || (!has_root_directory() &amp;amp;&amp;amp; base.has_root_directory())&lt;/code&gt;, returns a default-constructed path.</source>
          <target state="translated">Во-первых, если &lt;code&gt;root_name() != base.root_name() || is_absolute() != base.is_absolute() || (!has_root_directory() &amp;amp;&amp;amp; base.has_root_directory())&lt;/code&gt; , возвращает созданный по умолчанию путь.</target>
        </trans-unit>
        <trans-unit id="0af0623ac822520c62720be6f5b81d9ab7f82065" translate="yes" xml:space="preserve">
          <source>First, records that a flush is pending, by updating the appropriate private flag.</source>
          <target state="translated">Во-первых,записывает,что флеш находится в ожидании,обновив соответствующий приватный флаг.</target>
        </trans-unit>
        <trans-unit id="a3dedc18a8aa37448d34180fda53b30fdca03e04" translate="yes" xml:space="preserve">
          <source>First, remembers the currently raised floating-point exceptions, then restores the floating-point environment from the object pointed to by &lt;code&gt;envp&lt;/code&gt; (similar to &lt;code&gt;&lt;a href=&quot;feenv&quot;&gt;std::fesetenv&lt;/a&gt;&lt;/code&gt;), then raises the floating-point exceptions that were saved.</source>
          <target state="translated">Сначала запоминает &lt;code&gt;envp&lt;/code&gt; исключения с плавающей точкой, затем восстанавливает среду с плавающей точкой из объекта, на который указывает envp (по аналогии с &lt;code&gt;&lt;a href=&quot;feenv&quot;&gt;std::fesetenv&lt;/a&gt;&lt;/code&gt; ), затем поднимает исключения с плавающей точкой, которые были сохранены.</target>
        </trans-unit>
        <trans-unit id="f26f81a265113be2257dfeddeb17e46ef91bc7df" translate="yes" xml:space="preserve">
          <source>First, retrieve the outermost allocator &lt;code&gt;OUTERMOST&lt;/code&gt; by calling &lt;code&gt;this-&amp;gt;outer_allocator()&lt;/code&gt;, and then calling the &lt;code&gt;outer_allocator()&lt;/code&gt; member function recursively on the result of this call until reaching an allocator that has no such member function.</source>
          <target state="translated">Сначала извлекаем самый внешний распределитель &lt;code&gt;OUTERMOST&lt;/code&gt; , вызывая &lt;code&gt;this-&amp;gt;outer_allocator()&lt;/code&gt; , а затем рекурсивно вызывая &lt;code&gt;outer_allocator()&lt;/code&gt; член external_allocator () в результате этого вызова, пока не достигнем распределителя, у которого нет такой функции-члена.</target>
        </trans-unit>
        <trans-unit id="b22ed5216bdf7ab4edb25ec8436348da2427fb87" translate="yes" xml:space="preserve">
          <source>First, saves the current floating-point environment to the object pointed to by &lt;code&gt;envp&lt;/code&gt; (similar to &lt;code&gt;&lt;a href=&quot;feenv&quot;&gt;std::fegetenv&lt;/a&gt;&lt;/code&gt;), then clears all floating-point status flags, and then installs the non-stop mode: future floating-point exceptions will not interrupt execution (will not trap), until the floating-point environment is restored by &lt;code&gt;&lt;a href=&quot;feupdateenv&quot;&gt;std::feupdateenv&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;feenv&quot;&gt;std::fesetenv&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Сначала сохраняет текущую среду с плавающей запятой в объекте, на который указывает &lt;code&gt;envp&lt;/code&gt; (аналогично &lt;code&gt;&lt;a href=&quot;feenv&quot;&gt;std::fegetenv&lt;/a&gt;&lt;/code&gt; ), затем очищает все флаги состояния с плавающей запятой, а затем устанавливает безостановочный режим: будущие исключения с плавающей запятой не будут выполнение прерывания (не перехватывать), пока среда с плавающей точкой не будет восстановлена ​​с помощью &lt;code&gt;&lt;a href=&quot;feupdateenv&quot;&gt;std::feupdateenv&lt;/a&gt;&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;feenv&quot;&gt;std::fesetenv&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="19ae2c760d73ee6a549348974c9ddff8cc5fef2c" translate="yes" xml:space="preserve">
          <source>First, set each element of the output range to the value &lt;code&gt;0x8b8b8b8b&lt;/code&gt;</source>
          <target state="translated">Сначала установите для каждого элемента выходного диапазона значение &lt;code&gt;0x8b8b8b8b&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="37c02899047a91960018379b0f4a7201e2a7714f" translate="yes" xml:space="preserve">
          <source>First, the argument-dependent lookup is not considered if the lookup set produced by usual &lt;a href=&quot;lookup&quot;&gt;unqualified lookup&lt;/a&gt; contains any of the following:</source>
          <target state="translated">Во-первых, зависящий от аргумента поиск не рассматривается, если набор поиска, созданный обычным &lt;a href=&quot;lookup&quot;&gt;неквалифицированным поиском,&lt;/a&gt; содержит любое из следующего:</target>
        </trans-unit>
        <trans-unit id="71da67e0b30adfe6e4f96fe9e13991f6f8a033f3" translate="yes" xml:space="preserve">
          <source>Firstly, if this path has an &lt;a href=&quot;extension&quot;&gt;&lt;code&gt;extension()&lt;/code&gt;&lt;/a&gt;, it is removed from the generic-format view of the pathname.</source>
          <target state="translated">Во-первых, если этот путь имеет &lt;a href=&quot;extension&quot;&gt; &lt;code&gt;extension()&lt;/code&gt; &lt;/a&gt; , он удаляется из представления общего формата пути.</target>
        </trans-unit>
        <trans-unit id="d24ff9bf0ed02a5411428beac3e4bd1d30fe9f46" translate="yes" xml:space="preserve">
          <source>Five &lt;a href=&quot;../../language/deduction_guide&quot;&gt;deduction guides&lt;/a&gt; are provided for &lt;code&gt;span&lt;/code&gt;.</source>
          <target state="translated">Пяти &lt;a href=&quot;../../language/deduction_guide&quot;&gt;дедукции направляющими&lt;/a&gt; предназначены для &lt;code&gt;span&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="27e98ae5f197207336755cc33861b5d103faad58" translate="yes" xml:space="preserve">
          <source>Fixed width integer types</source>
          <target state="translated">Исправлена ширина целых типов</target>
        </trans-unit>
        <trans-unit id="a96f6d996f06dc7144585656dcc077cf300a6377" translate="yes" xml:space="preserve">
          <source>Fixed width integer types (since C++11)</source>
          <target state="translated">Исправлена ширина целых типов (начиная с C++11)</target>
        </trans-unit>
        <trans-unit id="0a6c931f357cf026414e375b77b04d8235b7334d" translate="yes" xml:space="preserve">
          <source>Flag type and operations</source>
          <target state="translated">Тип флага и операции</target>
        </trans-unit>
        <trans-unit id="27cbb35a9b1b271932f7636ca4faaede088277a2" translate="yes" xml:space="preserve">
          <source>Flips bits, i.e. changes &lt;code&gt;true&lt;/code&gt; values to &lt;code&gt;false&lt;/code&gt; and &lt;code&gt;false&lt;/code&gt; values to &lt;code&gt;true&lt;/code&gt;. Equivalent to a logical NOT operation on part or all of the bitset.</source>
          <target state="translated">Переворачивает биты, т.е. изменяет &lt;code&gt;true&lt;/code&gt; значения на &lt;code&gt;false&lt;/code&gt; и &lt;code&gt;false&lt;/code&gt; значения на &lt;code&gt;true&lt;/code&gt; . Эквивалентно логической операции НЕ для части или всего набора битов.</target>
        </trans-unit>
        <trans-unit id="b5dfec7a1df7a1c20eb6ca15e9bee0c75b291919" translate="yes" xml:space="preserve">
          <source>Floating point literal defines a compile-time constant whose value is specified in the source file.</source>
          <target state="translated">Библиотека с плавающей точкой определяет константу времени компиляции,значение которой указано в исходном файле.</target>
        </trans-unit>
        <trans-unit id="530b771e0a4d9da8f37e390916e11d1da9b65536" translate="yes" xml:space="preserve">
          <source>Floating point manipulation functions</source>
          <target state="translated">Функции манипуляции с плавающей точкой</target>
        </trans-unit>
        <trans-unit id="4cdfaff55d21c2eb1c0a0dbeace3c9c4e378eda8" translate="yes" xml:space="preserve">
          <source>Floating point types</source>
          <target state="translated">Типы с плавающей точкой</target>
        </trans-unit>
        <trans-unit id="931a4d33f9a7670df77e53c7e39d2883c52b8c58" translate="yes" xml:space="preserve">
          <source>Floating point value corresponding to the contents of &lt;code&gt;str&lt;/code&gt; on success. If the converted value falls out of range of corresponding return type, range error occurs and &lt;code&gt;&lt;a href=&quot;../../numeric/math/huge_val&quot;&gt;HUGE_VAL&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../../numeric/math/huge_val&quot;&gt;HUGE_VALF&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../../numeric/math/huge_val&quot;&gt;HUGE_VALL&lt;/a&gt;&lt;/code&gt; is returned. If no conversion can be performed, &lt;code&gt;​0​&lt;/code&gt; is returned and *str_end is set to str.</source>
          <target state="translated">Значение с плавающей запятой, соответствующее содержимому &lt;code&gt;str&lt;/code&gt; в случае успеха. Если преобразованное значение выходит за пределы диапазона соответствующего возвращаемого типа, возникает ошибка диапазона и &lt;code&gt;&lt;a href=&quot;../../numeric/math/huge_val&quot;&gt;HUGE_VAL&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../../numeric/math/huge_val&quot;&gt;HUGE_VALF&lt;/a&gt;&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;../../numeric/math/huge_val&quot;&gt;HUGE_VALL&lt;/a&gt;&lt;/code&gt; . Если преобразование не может быть выполнено, &lt;code&gt;​0​&lt;/code&gt; возвращается и * str_end установлен на ул.</target>
        </trans-unit>
        <trans-unit id="5679c54758fee21d770fd6c545d0c43032628157" translate="yes" xml:space="preserve">
          <source>Floating point value corresponding to the contents of &lt;code&gt;str&lt;/code&gt; on success. If the converted value falls out of range of corresponding return type, range error occurs and &lt;code&gt;&lt;a href=&quot;../../numeric/math/huge_val&quot;&gt;HUGE_VAL&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../../numeric/math/huge_val&quot;&gt;HUGE_VALF&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../../numeric/math/huge_val&quot;&gt;HUGE_VALL&lt;/a&gt;&lt;/code&gt; is returned. If no conversion can be performed, &lt;code&gt;​0​&lt;/code&gt; is returned.</source>
          <target state="translated">Значение с плавающей запятой, соответствующее содержимому &lt;code&gt;str&lt;/code&gt; в случае успеха. Если преобразованное значение выходит за пределы диапазона соответствующего возвращаемого типа, возникает ошибка диапазона и &lt;code&gt;&lt;a href=&quot;../../numeric/math/huge_val&quot;&gt;HUGE_VAL&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../../numeric/math/huge_val&quot;&gt;HUGE_VALF&lt;/a&gt;&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;../../numeric/math/huge_val&quot;&gt;HUGE_VALL&lt;/a&gt;&lt;/code&gt; . Если преобразование не может быть выполнено, &lt;code&gt;​0​&lt;/code&gt; возвращается.</target>
        </trans-unit>
        <trans-unit id="d2f57b6272c09794ad846fa25baa135845cf2031" translate="yes" xml:space="preserve">
          <source>Floating point value identifying the &amp;mu; distribution parameter.</source>
          <target state="translated">Значение с плавающей точкой, определяющее параметр распределения &amp;mu;.</target>
        </trans-unit>
        <trans-unit id="9a1cf11d8c926cc9f1bbac062621307bdc11199f" translate="yes" xml:space="preserve">
          <source>Floating point value identifying the degrees of freedom of the distribution.</source>
          <target state="translated">Значение с плавающей точкой,определяющее степень свободы распределения.</target>
        </trans-unit>
        <trans-unit id="a725365fc9cc7788cab748ff13281e3d748d0017" translate="yes" xml:space="preserve">
          <source>Floating point value identifying the p distribution parameter.</source>
          <target state="translated">Значение с плавающей точкой,идентифицирующее p-параметр распределения.</target>
        </trans-unit>
        <trans-unit id="3bfd050a822b215062fc674739b968774ba30a01" translate="yes" xml:space="preserve">
          <source>Floating point value identifying the rate of events per unit.</source>
          <target state="translated">Значение с плавающей точкой,определяющее скорость событий на единицу.</target>
        </trans-unit>
        <trans-unit id="5c65e500905d168962e036e5e1c8cfd585b5a35a" translate="yes" xml:space="preserve">
          <source>Floating point value in range [0, 1).</source>
          <target state="translated">Значение с плавающей точкой в диапазоне [0,1].</target>
        </trans-unit>
        <trans-unit id="a4edd9f5da9c5bff6fa7351be1698e5f17713a8e" translate="yes" xml:space="preserve">
          <source>Floating&amp;ndash;integral conversions</source>
          <target state="translated">Плавающие-интегральные преобразования</target>
        </trans-unit>
        <trans-unit id="fe4d2e99025a6ead51e9b2e632c32efaa3c94a25" translate="yes" xml:space="preserve">
          <source>Floating-point contraction</source>
          <target state="translated">Сокращение в плавающей точке</target>
        </trans-unit>
        <trans-unit id="a694704378ed350bc958fb519c8315b5d52a02b7" translate="yes" xml:space="preserve">
          <source>Floating-point conversions</source>
          <target state="translated">Преобразование с плавающей запятой</target>
        </trans-unit>
        <trans-unit id="037c72279324a50181c71503f07e7e0083f1c23d" translate="yes" xml:space="preserve">
          <source>Floating-point environment</source>
          <target state="translated">Среда с плавающей запятой</target>
        </trans-unit>
        <trans-unit id="fc13961bdda58d06692a8ad8f8156b2841512415" translate="yes" xml:space="preserve">
          <source>Floating-point expressions may have greater range and precision than indicated by their types, see &lt;code&gt;&lt;a href=&quot;../types/climits/flt_eval_method&quot;&gt;FLT_EVAL_METHOD&lt;/a&gt;&lt;/code&gt;. Floating-point expressions may also be</source>
          <target state="translated">Выражения с плавающей точкой могут иметь больший диапазон и точность, чем указано их типами, см. &lt;code&gt;&lt;a href=&quot;../types/climits/flt_eval_method&quot;&gt;FLT_EVAL_METHOD&lt;/a&gt;&lt;/code&gt; . Выражения с плавающей точкой также могут быть</target>
        </trans-unit>
        <trans-unit id="0e05b4ea4725d83345dcb31354835a769615b781" translate="yes" xml:space="preserve">
          <source>Floating-point promotion</source>
          <target state="translated">Популяризация с плавающей точкой</target>
        </trans-unit>
        <trans-unit id="f74d231baa71e2a641e3234ad91f55a94e0aa7a0" translate="yes" xml:space="preserve">
          <source>Floating-point types may support &lt;a href=&quot;../types/numeric_limits&quot;&gt;special values&lt;/a&gt;:</source>
          <target state="translated">Типы с плавающей точкой могут поддерживать &lt;a href=&quot;../types/numeric_limits&quot;&gt;специальные значения&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="a26e00b84e77b40bea4bb511f8f60ed076daa97b" translate="yes" xml:space="preserve">
          <source>Flowing off the end of a value-returning function (except &lt;code&gt;main&lt;/code&gt;) without a return statement is undefined behavior.</source>
          <target state="translated">Выход из конца функции, возвращающей значение (кроме &lt;code&gt;main&lt;/code&gt; ) без оператора return, является неопределенным поведением.</target>
        </trans-unit>
        <trans-unit id="6666b9fcba2b772c274346c92162b6c1a3611ada" translate="yes" xml:space="preserve">
          <source>Flushes the output sequence &lt;code&gt;os&lt;/code&gt; as if by calling &lt;code&gt;os.flush()&lt;/code&gt;.</source>
          <target state="translated">Очищает выходную последовательность &lt;code&gt;os&lt;/code&gt; , как будто вызывая &lt;code&gt;os.flush()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9cdb990f130f6549318c7c3b84780625f76de3f4" translate="yes" xml:space="preserve">
          <source>Flushes the output sequence &lt;code&gt;os&lt;/code&gt; as if by calling &lt;code&gt;os.flush()&lt;/code&gt;. Then, if &lt;code&gt;os.rdbuf()&lt;/code&gt; actually points to a &lt;code&gt;&lt;a href=&quot;../basic_syncbuf&quot;&gt;std::basic_syncbuf&lt;/a&gt;&amp;lt;CharT, Traits, Allocator&amp;gt;&lt;/code&gt;&lt;code&gt;buf&lt;/code&gt;, calls &lt;code&gt;buf.emit()&lt;/code&gt;.</source>
          <target state="translated">Очищает выходную последовательность &lt;code&gt;os&lt;/code&gt; , как будто вызывая &lt;code&gt;os.flush()&lt;/code&gt; . Затем, если &lt;code&gt;os.rdbuf()&lt;/code&gt; действительно указывает на &lt;code&gt;&lt;a href=&quot;../basic_syncbuf&quot;&gt;std::basic_syncbuf&lt;/a&gt;&amp;lt;CharT, Traits, Allocator&amp;gt;&lt;/code&gt; &lt;code&gt;buf&lt;/code&gt; , вызывает &lt;code&gt;buf.emit()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d4727f15c3dadc6abc3267b67039a85b366a9aeb" translate="yes" xml:space="preserve">
          <source>Flushing is performed in the destructor of the &lt;code&gt;&lt;a href=&quot;../basic_ostream/sentry&quot;&gt;std::basic_ostream::sentry&lt;/a&gt;&lt;/code&gt; object, which calls &lt;code&gt;str.rdbuf()-&amp;gt;pubsync()&lt;/code&gt; if &lt;code&gt;str.flags() &amp;amp; &lt;a href=&quot;../ios_base/fmtflags&quot;&gt;std::ios_base::unitbuf&lt;/a&gt; == true&lt;/code&gt;.</source>
          <target state="translated">Сброс выполняется в деструкторе объекта &lt;code&gt;&lt;a href=&quot;../basic_ostream/sentry&quot;&gt;std::basic_ostream::sentry&lt;/a&gt;&lt;/code&gt; , который вызывает &lt;code&gt;str.rdbuf()-&amp;gt;pubsync()&lt;/code&gt; если &lt;code&gt;str.flags() &amp;amp; &lt;a href=&quot;../ios_base/fmtflags&quot;&gt;std::ios_base::unitbuf&lt;/a&gt; == true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="dd2e024a054d8c1876c1f1a73eab175647867cec" translate="yes" xml:space="preserve">
          <source>Fold expressions</source>
          <target state="translated">Прямые выражения</target>
        </trans-unit>
        <trans-unit id="820f688950b36fa22a06159885b2b0b589f17953" translate="yes" xml:space="preserve">
          <source>Fold-expressions</source>
          <target state="translated">Fold-expressions</target>
        </trans-unit>
        <trans-unit id="73ea87451f9d5e42c6d3450b515bcb3f98250b83" translate="yes" xml:space="preserve">
          <source>Follow rather than skip directory symlinks.</source>
          <target state="translated">Следуйте,а не пропускайте сим-ссылки каталога.</target>
        </trans-unit>
        <trans-unit id="c9eac869d3c658b081e1a95ca062116b32f0aaa4" translate="yes" xml:space="preserve">
          <source>Follow symlinks (default behavior)</source>
          <target state="translated">Следуйте симлинкам (поведение по умолчанию)</target>
        </trans-unit>
        <trans-unit id="9d728e94fbab96a42d3b4d9a6cb222f5e938822e" translate="yes" xml:space="preserve">
          <source>Following exposition-only concepts are used for several types, but they are not parts of the interface of standard library.</source>
          <target state="translated">Следующие экспозиционные концепции используются для нескольких типов,но они не являются частью интерфейса стандартной библиотеки.</target>
        </trans-unit>
        <trans-unit id="6f40e40d82fd8846da49808b0b708490ce0379e1" translate="yes" xml:space="preserve">
          <source>Following member functions are conditionally different from corresponding member functions of &lt;code&gt;&lt;a href=&quot;../utility/optional&quot;&gt;std::optional&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Следующие функции-члены условно отличаются от соответствующих функций-членов &lt;code&gt;&lt;a href=&quot;../utility/optional&quot;&gt;std::optional&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ec0c3b76630fd745381cc215a284820af75a683a" translate="yes" xml:space="preserve">
          <source>Footnotes</source>
          <target state="translated">Footnotes</target>
        </trans-unit>
        <trans-unit id="2eedcffa258b92b2d623f330307d6610480c73b1" translate="yes" xml:space="preserve">
          <source>For (1), &lt;code&gt;&lt;a href=&quot;../../types/is_copy_assignable&quot;&gt;std::is_copy_assignable&lt;/a&gt;&amp;lt;T_i&amp;gt;::value&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; for all &lt;code&gt;T_i&lt;/code&gt; in &lt;code&gt;Types&lt;/code&gt;.</source>
          <target state="translated">Для (1), &lt;code&gt;&lt;a href=&quot;../../types/is_copy_assignable&quot;&gt;std::is_copy_assignable&lt;/a&gt;&amp;lt;T_i&amp;gt;::value&lt;/code&gt; является &lt;code&gt;true&lt;/code&gt; для всех &lt;code&gt;T_i&lt;/code&gt; в &lt;code&gt;Types&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="27e932e63be3980babb2b5c3e1834eb9ece2f5cb" translate="yes" xml:space="preserve">
          <source>For (1),&lt;code&gt;&lt;a href=&quot;../../types/is_copy_assignable&quot;&gt;std::is_copy_assignable&lt;/a&gt;&amp;lt;first_type&amp;gt;::value&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../../types/is_copy_assignable&quot;&gt;std::is_copy_assignable&lt;/a&gt;&amp;lt;second_type&amp;gt;::value&lt;/code&gt; are both &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">Для (1) &lt;code&gt;&lt;a href=&quot;../../types/is_copy_assignable&quot;&gt;std::is_copy_assignable&lt;/a&gt;&amp;lt;first_type&amp;gt;::value&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;../../types/is_copy_assignable&quot;&gt;std::is_copy_assignable&lt;/a&gt;&amp;lt;second_type&amp;gt;::value&lt;/code&gt; оба имеют значение &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cce1fc39ab817dad0417c749a97b121fa9da8698" translate="yes" xml:space="preserve">
          <source>For (1-3), if the result would be outside the range [0, 255], the actual stored value is unspecified.</source>
          <target state="translated">Для (1-3),если результат выходит за пределы диапазона [0,255],фактическое сохраненное значение является неуказанным.</target>
        </trans-unit>
        <trans-unit id="80750dcb6fca71c81371e8509ae0e5a32ea184f9" translate="yes" xml:space="preserve">
          <source>For (2), &lt;code&gt;&lt;a href=&quot;../../types/is_move_assignable&quot;&gt;std::is_move_assignable&lt;/a&gt;&amp;lt;T_i&amp;gt;::value&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; for all &lt;code&gt;T_i&lt;/code&gt; in &lt;code&gt;Types&lt;/code&gt;.</source>
          <target state="translated">Для (2) &lt;code&gt;&lt;a href=&quot;../../types/is_move_assignable&quot;&gt;std::is_move_assignable&lt;/a&gt;&amp;lt;T_i&amp;gt;::value&lt;/code&gt; имеет значение &lt;code&gt;true&lt;/code&gt; для всех &lt;code&gt;T_i&lt;/code&gt; в &lt;code&gt;Types&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cf60873df305a2582da8245d9a95bc5dabb1f1c1" translate="yes" xml:space="preserve">
          <source>For (2),&lt;code&gt;&lt;a href=&quot;../../types/is_assignable&quot;&gt;std::is_assignable&lt;/a&gt;&amp;lt;first_type&amp;amp;, const U1&amp;amp;&amp;gt;::value&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../../types/is_assignable&quot;&gt;std::is_assignable&lt;/a&gt;&amp;lt;second_type&amp;amp;, const U2&amp;amp;&amp;gt;::value&lt;/code&gt; are both &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">Для (2) &lt;code&gt;&lt;a href=&quot;../../types/is_assignable&quot;&gt;std::is_assignable&lt;/a&gt;&amp;lt;first_type&amp;amp;, const U1&amp;amp;&amp;gt;::value&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;../../types/is_assignable&quot;&gt;std::is_assignable&lt;/a&gt;&amp;lt;second_type&amp;amp;, const U2&amp;amp;&amp;gt;::value&lt;/code&gt; оба имеют значение &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2e266ee47c94d97b82af99ef255fd0f260a99d2c" translate="yes" xml:space="preserve">
          <source>For (3), &lt;code&gt;sizeof...(UTypes) == sizeof...(Types)&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../../types/is_assignable&quot;&gt;std::is_assignable&lt;/a&gt;&amp;lt;T_i&amp;amp;, const U_i&amp;amp;&amp;gt;::value&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; for all corresponding pairs of types &lt;code&gt;T_i&lt;/code&gt; in &lt;code&gt;Types&lt;/code&gt; and &lt;code&gt;U_i&lt;/code&gt; in &lt;code&gt;UTypes&lt;/code&gt;.</source>
          <target state="translated">Для (3) &lt;code&gt;sizeof...(UTypes) == sizeof...(Types)&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;../../types/is_assignable&quot;&gt;std::is_assignable&lt;/a&gt;&amp;lt;T_i&amp;amp;, const U_i&amp;amp;&amp;gt;::value&lt;/code&gt; имеет значение &lt;code&gt;true&lt;/code&gt; для всех соответствующих пар типов &lt;code&gt;T_i&lt;/code&gt; в &lt;code&gt;Types&lt;/code&gt; и &lt;code&gt;U_i&lt;/code&gt; в &lt;code&gt;UTypes&lt;/code&gt; ,</target>
        </trans-unit>
        <trans-unit id="235c0ae5251a55b5cc4853b6e31b390a6d489d01" translate="yes" xml:space="preserve">
          <source>For (3),&lt;code&gt;&lt;a href=&quot;../../types/is_move_assignable&quot;&gt;std::is_move_assignable&lt;/a&gt;&amp;lt;first_type&amp;gt;::value&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../../types/is_move_assignable&quot;&gt;std::is_move_assignable&lt;/a&gt;&amp;lt;second_type&amp;gt;::value&lt;/code&gt; are both &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">Для (3) &lt;code&gt;&lt;a href=&quot;../../types/is_move_assignable&quot;&gt;std::is_move_assignable&lt;/a&gt;&amp;lt;first_type&amp;gt;::value&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;../../types/is_move_assignable&quot;&gt;std::is_move_assignable&lt;/a&gt;&amp;lt;second_type&amp;gt;::value&lt;/code&gt; оба имеют значение &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6c23beb9ab1e1686d723073f239e4dd5ad833ba8" translate="yes" xml:space="preserve">
          <source>For (4), &lt;code&gt;sizeof...(UTypes) == sizeof...(Types)&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../../types/is_assignable&quot;&gt;std::is_assignable&lt;/a&gt;&amp;lt;T_i&amp;amp;, U_i&amp;amp;&amp;amp;&amp;gt;::value&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; for all corresponding pairs of types &lt;code&gt;T_i&lt;/code&gt; in &lt;code&gt;Types&lt;/code&gt; and &lt;code&gt;U_i&lt;/code&gt; in &lt;code&gt;UTypes&lt;/code&gt;.</source>
          <target state="translated">Для (4) &lt;code&gt;sizeof...(UTypes) == sizeof...(Types)&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;../../types/is_assignable&quot;&gt;std::is_assignable&lt;/a&gt;&amp;lt;T_i&amp;amp;, U_i&amp;amp;&amp;amp;&amp;gt;::value&lt;/code&gt; имеет значение &lt;code&gt;true&lt;/code&gt; для всех соответствующих пар типов &lt;code&gt;T_i&lt;/code&gt; в &lt;code&gt;Types&lt;/code&gt; и &lt;code&gt;U_i&lt;/code&gt; в &lt;code&gt;UTypes&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d612fce9fe1d1b17e3a906128095373ba91170e6" translate="yes" xml:space="preserve">
          <source>For (4),&lt;code&gt;&lt;a href=&quot;../../types/is_assignable&quot;&gt;std::is_assignable&lt;/a&gt;&amp;lt;first_type&amp;amp;, U1&amp;amp;&amp;amp;&amp;gt;::value&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../../types/is_assignable&quot;&gt;std::is_assignable&lt;/a&gt;&amp;lt;second_type&amp;amp;, U2&amp;amp;&amp;amp;&amp;gt;::value&lt;/code&gt; are both &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">Для (4) &lt;code&gt;&lt;a href=&quot;../../types/is_assignable&quot;&gt;std::is_assignable&lt;/a&gt;&amp;lt;first_type&amp;amp;, U1&amp;amp;&amp;amp;&amp;gt;::value&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;../../types/is_assignable&quot;&gt;std::is_assignable&lt;/a&gt;&amp;lt;second_type&amp;amp;, U2&amp;amp;&amp;amp;&amp;gt;::value&lt;/code&gt; оба имеют значение &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6dc7376755e98b71c2080e8a531379170a9f0d46" translate="yes" xml:space="preserve">
          <source>For (5), &lt;code&gt;sizeof...(Types) == 2&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../../types/is_assignable&quot;&gt;std::is_assignable&lt;/a&gt;&amp;lt;T_0&amp;amp;, const U1&amp;amp;&amp;gt;::value&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../../types/is_assignable&quot;&gt;std::is_assignable&lt;/a&gt;&amp;lt;T_1&amp;amp;, const U2&amp;amp;&amp;gt;::value&lt;/code&gt; are both &lt;code&gt;true&lt;/code&gt;, where &lt;code&gt;T_0&lt;/code&gt; and &lt;code&gt;T_1&lt;/code&gt; are the two types constituting &lt;code&gt;Types&lt;/code&gt;.</source>
          <target state="translated">Для (5) &lt;code&gt;sizeof...(Types) == 2&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;../../types/is_assignable&quot;&gt;std::is_assignable&lt;/a&gt;&amp;lt;T_0&amp;amp;, const U1&amp;amp;&amp;gt;::value&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;../../types/is_assignable&quot;&gt;std::is_assignable&lt;/a&gt;&amp;lt;T_1&amp;amp;, const U2&amp;amp;&amp;gt;::value&lt;/code&gt; оба имеют значение &lt;code&gt;true&lt;/code&gt; , где &lt;code&gt;T_0&lt;/code&gt; и &lt;code&gt;T_1&lt;/code&gt; являются двумя типами, составляющими &lt;code&gt;Types&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="94214e5075f274a6f5fa7b33c9435afe45df0332" translate="yes" xml:space="preserve">
          <source>For (6), &lt;code&gt;sizeof...(Types) == 2&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../../types/is_assignable&quot;&gt;std::is_assignable&lt;/a&gt;&amp;lt;T_0&amp;amp;, U1&amp;amp;&amp;amp;&amp;gt;::value&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../../types/is_assignable&quot;&gt;std::is_assignable&lt;/a&gt;&amp;lt;T_1&amp;amp;, U2&amp;amp;&amp;amp;&amp;gt;::value&lt;/code&gt; are both &lt;code&gt;true&lt;/code&gt;, where &lt;code&gt;T_0&lt;/code&gt; and &lt;code&gt;T_1&lt;/code&gt; are the two types constituting &lt;code&gt;Types&lt;/code&gt;.</source>
          <target state="translated">Для (6) &lt;code&gt;sizeof...(Types) == 2&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;../../types/is_assignable&quot;&gt;std::is_assignable&lt;/a&gt;&amp;lt;T_0&amp;amp;, U1&amp;amp;&amp;amp;&amp;gt;::value&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;../../types/is_assignable&quot;&gt;std::is_assignable&lt;/a&gt;&amp;lt;T_1&amp;amp;, U2&amp;amp;&amp;amp;&amp;gt;::value&lt;/code&gt; оба имеют значение &lt;code&gt;true&lt;/code&gt; , где &lt;code&gt;T_0&lt;/code&gt; и &lt;code&gt;T_1&lt;/code&gt; являются два типа, составляющие &lt;code&gt;Types&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="83856baa7fbad81b10e160970bde088c89421d40" translate="yes" xml:space="preserve">
          <source>For 0&amp;le;arg&amp;le;1,</source>
          <target state="translated">Для 0&amp;le;arg&amp;le;1,</target>
        </trans-unit>
        <trans-unit id="3bd6dc6d78016b2a3f1c8c074db727a1bd8e2c50" translate="yes" xml:space="preserve">
          <source>For &lt;a href=&quot;../named_req/triviallycopyable&quot;&gt;TriviallyCopyable&lt;/a&gt; types, value representation is a part of the object representation, which means that copying the bytes occupied by the object in the storage is sufficient to produce another object with the same value (except if the value is a</source>
          <target state="translated">Для типов &lt;a href=&quot;../named_req/triviallycopyable&quot;&gt;TriviallyCopyable&lt;/a&gt; представление значения является частью представления объекта, что означает, что копирования байтов, занятых объектом в хранилище, достаточно для создания другого объекта с таким же значением (кроме случаев, когда значение является</target>
        </trans-unit>
        <trans-unit id="a6d068410c3d5d5e1e66f214a4705f1da0744b99" translate="yes" xml:space="preserve">
          <source>For &lt;a href=&quot;do&quot;&gt;do-while&lt;/a&gt; loop, it acts as:</source>
          <target state="translated">Для цикла &lt;a href=&quot;do&quot;&gt;do-&lt;/a&gt; while он действует как:</target>
        </trans-unit>
        <trans-unit id="192dfceddbf339e300daed630beff6523e185814" translate="yes" xml:space="preserve">
          <source>For &lt;a href=&quot;for&quot;&gt;for&lt;/a&gt; and &lt;a href=&quot;range-for&quot;&gt;range-for&lt;/a&gt; loop, it acts as:</source>
          <target state="translated">Для цикла &lt;a href=&quot;for&quot;&gt;for&lt;/a&gt; и &lt;a href=&quot;range-for&quot;&gt;range-for&lt;/a&gt; он действует как:</target>
        </trans-unit>
        <trans-unit id="25d4ebe9fb8814a98da8afb721d4a6bdeed00a0f" translate="yes" xml:space="preserve">
          <source>For &lt;a href=&quot;operator_comparison&quot;&gt;relational operators&lt;/a&gt; &amp;gt; and &amp;ge; respectively</source>
          <target state="translated">Для &lt;a href=&quot;operator_comparison&quot;&gt;реляционных операторов&lt;/a&gt; &amp;gt; и &amp;ge; соответственно</target>
        </trans-unit>
        <trans-unit id="c82d883f6eaf9d2b9ddb7fd8e6adaa4e2930e681" translate="yes" xml:space="preserve">
          <source>For &lt;a href=&quot;operator_comparison&quot;&gt;relational operators&lt;/a&gt; &amp;lt; and &amp;le; respectively</source>
          <target state="translated">Для &lt;a href=&quot;operator_comparison&quot;&gt;реляционных операторов&lt;/a&gt; &amp;lt;и &amp;le; соответственно</target>
        </trans-unit>
        <trans-unit id="80184e736b13dd44e9e03f7f4a2465c93e2f10ce" translate="yes" xml:space="preserve">
          <source>For &lt;a href=&quot;operator_comparison&quot;&gt;relational operators&lt;/a&gt; = and &amp;ne; respectively</source>
          <target state="translated">Для &lt;a href=&quot;operator_comparison&quot;&gt;реляционных операторов&lt;/a&gt; = и &amp;ne; соответственно</target>
        </trans-unit>
        <trans-unit id="67db5ac16c817d0aad978db1daa9912c166fac6a" translate="yes" xml:space="preserve">
          <source>For &lt;a href=&quot;while&quot;&gt;while&lt;/a&gt; loop, it acts as.</source>
          <target state="translated">В &lt;a href=&quot;while&quot;&gt;то время как&lt;/a&gt; петли, он действует как.</target>
        </trans-unit>
        <trans-unit id="2ceb12570320e8236ce37933edca4d8d71e4edce" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;&lt;a href=&quot;../../numeric/ratio/ratio&quot;&gt;std::micro&lt;/a&gt;&lt;/code&gt;, if the character &amp;micro; (U+00B5) cannot be represented in the encoding used for &lt;code&gt;CharT&lt;/code&gt;, the suffix &quot;&lt;code&gt;us&lt;/code&gt;&quot; is used instead.</source>
          <target state="translated">Для &lt;code&gt;&lt;a href=&quot;../../numeric/ratio/ratio&quot;&gt;std::micro&lt;/a&gt;&lt;/code&gt; , если символ &amp;micro; (U + 00B5) не может быть представлен в кодировке, используемой для &lt;code&gt;CharT&lt;/code&gt; , вместо него используется суффикс &amp;laquo; &lt;code&gt;us&lt;/code&gt; &amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="decd50a2a6c24904b14b0159d4b4ee28edc12dd8" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;&lt;a href=&quot;../basic_string&quot;&gt;std::string&lt;/a&gt;&lt;/code&gt;, the elements are bytes (objects of type char), which are not the same as characters if a multibyte encoding such as UTF-8 is used.</source>
          <target state="translated">Для &lt;code&gt;&lt;a href=&quot;../basic_string&quot;&gt;std::string&lt;/a&gt;&lt;/code&gt; элементы являются байтами (объектами типа char), которые не совпадают с символами, если используется многобайтовая кодировка, такая как UTF-8.</target>
        </trans-unit>
        <trans-unit id="4fc81475176c004bf7dd4b13445be6b3d996668a" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;&lt;a href=&quot;../container/unordered_set&quot;&gt;std::unordered_set&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../container/unordered_multiset&quot;&gt;std::unordered_multiset&lt;/a&gt;&lt;/code&gt; the value type is the same as the key type and both &lt;code&gt;iterator&lt;/code&gt; and &lt;code&gt;const_iterator&lt;/code&gt; are constant iterators. For &lt;code&gt;&lt;a href=&quot;../container/unordered_map&quot;&gt;std::unordered_map&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../container/unordered_multimap&quot;&gt;std::unordered_multimap&lt;/a&gt;&lt;/code&gt; the value type is &lt;code&gt;&lt;a href=&quot;../utility/pair&quot;&gt;std::pair&lt;/a&gt;&amp;lt;const Key, T&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">Для &lt;code&gt;&lt;a href=&quot;../container/unordered_set&quot;&gt;std::unordered_set&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;../container/unordered_multiset&quot;&gt;std::unordered_multiset&lt;/a&gt;&lt;/code&gt; тип значения совпадает с типом ключа, и &lt;code&gt;iterator&lt;/code&gt; и &lt;code&gt;const_iterator&lt;/code&gt; являются постоянными итераторами. Для &lt;code&gt;&lt;a href=&quot;../container/unordered_map&quot;&gt;std::unordered_map&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;../container/unordered_multimap&quot;&gt;std::unordered_multimap&lt;/a&gt;&lt;/code&gt; типом значения является &lt;code&gt;&lt;a href=&quot;../utility/pair&quot;&gt;std::pair&lt;/a&gt;&amp;lt;const Key, T&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9d3533c7dfac4c0a2f11001f27ce7038422be45e" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;T*&lt;/code&gt; types, the result may be an undefined address, but the operation otherwise has no undefined behavior. The program is ill-formed if &lt;code&gt;T&lt;/code&gt; is not an object type.</source>
          <target state="translated">Для типов &lt;code&gt;T*&lt;/code&gt; результат может быть неопределенным адресом, но в противном случае операция не имеет неопределенного поведения. Программа плохо сформирована, если &lt;code&gt;T&lt;/code&gt; не тип объекта.</target>
        </trans-unit>
        <trans-unit id="6d8b259c841d7fe56fd4cbc44dbede3d4a2f5d45" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;T*&lt;/code&gt; types, the result may be an undefined address, but the operations otherwise have no undefined behavior. The program is ill-formed if &lt;code&gt;T&lt;/code&gt; is not an object type.</source>
          <target state="translated">Для типов &lt;code&gt;T*&lt;/code&gt; результатом может быть неопределенный адрес, но в противном случае операции не имеют неопределенного поведения. Программа плохо сформирована, если &lt;code&gt;T&lt;/code&gt; не тип объекта.</target>
        </trans-unit>
        <trans-unit id="fdab33fa5bc42221e341bfb5aa446019046bda10" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;allocate_shared&lt;/code&gt;, the object (or the individual array elements for (2-5))(since C++20) are destroyed via the expression &lt;code&gt;&lt;a href=&quot;../allocator_traits&quot;&gt;std::allocator_traits&lt;/a&gt;&amp;lt;A2&amp;gt;::destroy(a, p)&lt;/code&gt;, where &lt;code&gt;p&lt;/code&gt; is a pointer to the object and &lt;code&gt;a&lt;/code&gt; is a copy of the allocator passed to &lt;code&gt;allocate_shared&lt;/code&gt;, rebound to the type of the object being destroyed.</source>
          <target state="translated">Для &lt;code&gt;allocate_shared&lt;/code&gt; объект (или отдельные элементы массива для (2-5)) (начиная с C ++ 20) уничтожаются с помощью выражения &lt;code&gt;&lt;a href=&quot;../allocator_traits&quot;&gt;std::allocator_traits&lt;/a&gt;&amp;lt;A2&amp;gt;::destroy(a, p)&lt;/code&gt; , где &lt;code&gt;p&lt;/code&gt; - это указатель на объект, а &lt;code&gt;a&lt;/code&gt; является копией распределителя, переданного в &lt;code&gt;allocate_shared&lt;/code&gt; , привязанного к типу уничтожаемого объекта.</target>
        </trans-unit>
        <trans-unit id="ffeded1df965bfced36bed8a9a11d97603f70744" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;allocate_shared_default_init&lt;/code&gt;, the object (or individual elements if &lt;code&gt;T&lt;/code&gt; is an array type) will be destroyed by &lt;code&gt;p-&amp;gt;~X()&lt;/code&gt;, where &lt;code&gt;p&lt;/code&gt; is a pointer to the object and &lt;code&gt;X&lt;/code&gt; is its type.</source>
          <target state="translated">Для &lt;code&gt;allocate_shared_default_init&lt;/code&gt; объект (или отдельные элементы, если &lt;code&gt;T&lt;/code&gt; является типом массива) будет уничтожен &lt;code&gt;p-&amp;gt;~X()&lt;/code&gt; , где &lt;code&gt;p&lt;/code&gt; - указатель на объект, а &lt;code&gt;X&lt;/code&gt; - его тип.</target>
        </trans-unit>
        <trans-unit id="eaf9872d7fc84f0c3657f05544061163d1795a7f" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;k = 0,..., m-1&lt;/code&gt;</source>
          <target state="translated">Для &lt;code&gt;k = 0,..., m-1&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7a84133a6d81bd30988c564a8a6cf37a9783a4cf" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;k = m,..., m+n-1&lt;/code&gt;,</source>
          <target state="translated">Для &lt;code&gt;k = m,..., m+n-1&lt;/code&gt; ,</target>
        </trans-unit>
        <trans-unit id="3702c14d2d2a72e5ae19407c373383886d03512a" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;operator,&lt;/code&gt;, the unary &lt;code&gt;operator&amp;amp;&lt;/code&gt;, and &lt;code&gt;operator-&amp;gt;&lt;/code&gt;, if there are no viable functions (see below) in the set of candidate functions, then the operator is reinterpreted as a built-in.</source>
          <target state="translated">Для &lt;code&gt;operator,&lt;/code&gt; унарного &lt;code&gt;operator&amp;amp;&lt;/code&gt; и &lt;code&gt;operator-&amp;gt;&lt;/code&gt; , если в наборе функций-кандидатов нет жизнеспособных функций (см. Ниже), оператор переинтерпретируется как встроенный.</target>
        </trans-unit>
        <trans-unit id="0d394b44570e5e62b408fa0499880cd8eb0cf013" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;std::binary_search&lt;/code&gt; to succeed, the range &lt;code&gt;[first, last)&lt;/code&gt; must be at least partially ordered with respect to &lt;code&gt;value&lt;/code&gt;, i.e. it must satisfy all of the following requirements:</source>
          <target state="translated">Для &lt;code&gt;std::binary_search&lt;/code&gt; диапазон &lt;code&gt;[first, last)&lt;/code&gt; должен быть хотя бы частично упорядочен относительно &lt;code&gt;value&lt;/code&gt; , то есть он должен удовлетворять всем следующим требованиям:</target>
        </trans-unit>
        <trans-unit id="82aaf8ae9515fcaa10aa37778070bfaa5e42e07b" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;std::lrint&lt;/code&gt; and &lt;code&gt;std::llrint&lt;/code&gt; functions:</source>
          <target state="translated">Для &lt;code&gt;std::lrint&lt;/code&gt; и &lt;code&gt;std::llrint&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="386ec7b95ea37fdce144fa4084a418bcda9d46f7" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;std::lround&lt;/code&gt; and &lt;code&gt;std::llround&lt;/code&gt; functions:</source>
          <target state="translated">Для &lt;code&gt;std::lround&lt;/code&gt; и &lt;code&gt;std::llround&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="93056bf6dac8be93c20bc17806b06200f88a2398" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;union&lt;/code&gt; types, the implicitly-defined move assignment operator copies the object representation (as by &lt;code&gt;&lt;a href=&quot;../string/byte/memmove&quot;&gt;std::memmove&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">Для типов &lt;code&gt;union&lt;/code&gt; неявно определенный оператор присваивания перемещения копирует представление объекта (как в &lt;code&gt;&lt;a href=&quot;../string/byte/memmove&quot;&gt;std::memmove&lt;/a&gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="ab727ef011ac32b32b71004213c9062e03c40ca6" translate="yes" xml:space="preserve">
          <source>For IEEE-compatible type &lt;code&gt;double&lt;/code&gt;, overflow happens if &lt;code&gt;0 &amp;lt; x &amp;lt; 1/DBL_MAX&lt;/code&gt; or if &lt;code&gt;x &amp;gt; 171.7&lt;/code&gt;.</source>
          <target state="translated">Для IEEE-совместимого типа &lt;code&gt;double&lt;/code&gt; переполнение происходит, если &lt;code&gt;0 &amp;lt; x &amp;lt; 1/DBL_MAX&lt;/code&gt; или если &lt;code&gt;x &amp;gt; 171.7&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="308485408ad23c9a6a581efd5af8112d70a5819e" translate="yes" xml:space="preserve">
          <source>For IEEE-compatible type &lt;code&gt;double&lt;/code&gt;, overflow is guaranteed if 709.8 &amp;lt; arg, and underflow is guaranteed if arg &amp;lt; -708.4.</source>
          <target state="translated">Для IEEE-совместимого типа &lt;code&gt;double&lt;/code&gt; переполнение гарантируется, если 709,8 &amp;lt;arg, и недостаточное переполнение гарантируется, если arg &amp;lt;-708.4.</target>
        </trans-unit>
        <trans-unit id="9ebd607b970e88332eac8b1adf8c8066c0dd8e42" translate="yes" xml:space="preserve">
          <source>For IEEE-compatible type &lt;code&gt;double&lt;/code&gt;, overflow is guaranteed if 709.8 &amp;lt; arg.</source>
          <target state="translated">Для IEEE-совместимого типа &lt;code&gt;double&lt;/code&gt; переполнение гарантируется, если 709.8 &amp;lt;arg.</target>
        </trans-unit>
        <trans-unit id="7abd0d73ae7ceb8182e2cfda7bc62d8a3837d067" translate="yes" xml:space="preserve">
          <source>For POSIX-based operating systems, &lt;code&gt;std::filesystem::absolute(p)&lt;/code&gt; is equivalent to &lt;code&gt;&lt;a href=&quot;current_path&quot;&gt;std::filesystem::current_path&lt;/a&gt;() / p&lt;/code&gt;.</source>
          <target state="translated">Для операционных систем на основе POSIX &lt;code&gt;std::filesystem::absolute(p)&lt;/code&gt; эквивалентен &lt;code&gt;&lt;a href=&quot;current_path&quot;&gt;std::filesystem::current_path&lt;/a&gt;() / p&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="119d7cdec7ea51fa50da00d5d9417b5384f14791" translate="yes" xml:space="preserve">
          <source>For Windows, &lt;code&gt;absolute&lt;/code&gt; may be implemented as a call to &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/windows/desktop/aa364963(v=vs.85).aspx&quot;&gt;GetFullPathNameW&lt;/a&gt;.</source>
          <target state="translated">Для Windows &lt;code&gt;absolute&lt;/code&gt; может быть реализован как вызов &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/windows/desktop/aa364963(v=vs.85).aspx&quot;&gt;GetFullPathNameW&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c4e888a145f1992272e7918f8fc284c6a7e06ad4" translate="yes" xml:space="preserve">
          <source>For a</source>
          <target state="translated">Для</target>
        </trans-unit>
        <trans-unit id="ca411b7633697d58c29db0495dbecc36219406c0" translate="yes" xml:space="preserve">
          <source>For a &lt;a href=&quot;dependent_name&quot;&gt;non-dependent name&lt;/a&gt; used in a template definition, unqualified name lookup takes place when the template definition is examined. The binding to the declarations made at that point is not affected by declarations visible at the point of instantiation. For a &lt;a href=&quot;dependent_name&quot;&gt;dependent name&lt;/a&gt; used in a template definition, the lookup is postponed until the template arguments are known, at which time &lt;a href=&quot;adl&quot;&gt;ADL&lt;/a&gt; examines function declarations with external linkage(until C++11) that are visible from the template definition context as well as in the template instantiation context, while non-ADL lookup only examines function declarations with external linkage(until C++11) that are visible from the template definition context (in other words, adding a new function declaration after template definition does not make it visible except via ADL). The behavior is undefined if there is a better match with external linkage in the namespaces examined by the ADL lookup, declared in some other translation unit, or if the lookup would have been ambiguous if those translation units were examined. In any case, if a base class depends on a template parameter, its scope is not examined by unqualified name lookup (neither at the point of definition nor at the point of instantiation).</source>
          <target state="translated">Для &lt;a href=&quot;dependent_name&quot;&gt;независимого имени,&lt;/a&gt; используемого в определении шаблона, поиск по неквалифицированному имени выполняется при проверке определения шаблона. Привязка к объявлениям, сделанным в этот момент, не зависит от объявлений, видимых в момент создания экземпляра. Для &lt;a href=&quot;dependent_name&quot;&gt;зависимого имени,&lt;/a&gt; используемого в определении шаблона, поиск откладывается до тех пор, пока не станут известны аргументы шаблона, и в этот момент &lt;a href=&quot;adl&quot;&gt;ADL&lt;/a&gt;проверяет объявления функций с внешними связями (до C ++ 11), которые видны из контекста определения шаблона, а также из контекста создания шаблона, в то время как поиск без ADL проверяет только объявления функций с внешними связями (до C ++ 11), которые видимы из контекста определения шаблона (другими словами, добавление нового объявления функции после определения шаблона не делает его видимым, кроме как через ADL). Поведение не определено, если существует лучшее соответствие с внешней связью в пространствах имен, проверенных поиском ADL, объявленных в каком-то другом модуле перевода, или если поиск был бы неоднозначным, если бы эти блоки перевода были проверены. В любом случае, если базовый класс зависит от параметра шаблона,его область действия не проверяется безусловным поиском имени (ни в точке определения, ни в точке создания).</target>
        </trans-unit>
        <trans-unit id="883759e78914d4b04a2fe3535a894bcffbf8a177" translate="yes" xml:space="preserve">
          <source>For a &lt;a href=&quot;member_functions&quot;&gt;member function&lt;/a&gt; of a non-template class, the default arguments are allowed on the out-of-class definition, and are combined with the default arguments provided by the declaration inside the class body. If these out-of-class defaults would turn a member function into a default, copy, or move constructor the program is ill-formed. For member functions of class templates, all defaults must be provided in the initial declaration of the member function.</source>
          <target state="translated">Для &lt;a href=&quot;member_functions&quot;&gt;функции-члена&lt;/a&gt; не шаблонного класса аргументы по умолчанию разрешены в определении вне класса и объединяются с аргументами по умолчанию, предоставляемыми объявлением внутри тела класса. Если эти внеклассные значения по умолчанию превратят функцию-член в конструктор по умолчанию, скопировать или переместить, программа не будет сформирована. Для функций-членов шаблонов классов все значения по умолчанию должны быть указаны в первоначальном объявлении функции-члена.</target>
        </trans-unit>
        <trans-unit id="02ea56864a8e8c007867dec05809cd5a9f98b81f" translate="yes" xml:space="preserve">
          <source>For a container &lt;code&gt;c&lt;/code&gt;, the expression &lt;code&gt;c.front()&lt;/code&gt; is equivalent to &lt;code&gt;*c.begin()&lt;/code&gt;.</source>
          <target state="translated">Для контейнера &lt;code&gt;c&lt;/code&gt; выражение &lt;code&gt;c.front()&lt;/code&gt; эквивалентно &lt;code&gt;*c.begin()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c061e2be7835c9d94a21ab627e460ae3f5da4b8d" translate="yes" xml:space="preserve">
          <source>For a container &lt;code&gt;c&lt;/code&gt;, the expression &lt;code&gt;return c.back();&lt;/code&gt; is equivalent to &lt;code&gt;{ auto tmp = c.end(); --tmp; return *tmp; }&lt;/code&gt;</source>
          <target state="translated">Для контейнера &lt;code&gt;c&lt;/code&gt; выражение &lt;code&gt;return c.back();&lt;/code&gt; эквивалентно &lt;code&gt;{ auto tmp = c.end(); --tmp; return *tmp; }&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a12f2ebb81a91e44d54c155d3b7a470c7c32d87a" translate="yes" xml:space="preserve">
          <source>For a given &lt;code&gt;&lt;a href=&quot;../shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&amp;lt;T&amp;gt; p&lt;/code&gt;, this specialization ensures that.</source>
          <target state="translated">Для данного &lt;code&gt;&lt;a href=&quot;../shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&amp;lt;T&amp;gt; p&lt;/code&gt; эта специализация гарантирует это.</target>
        </trans-unit>
        <trans-unit id="61761986c4556882eacd9227f774252dea0c81ea" translate="yes" xml:space="preserve">
          <source>For a name used anywhere in &lt;a href=&quot;class&quot;&gt;class definition&lt;/a&gt;, except inside a member function body, a default argument of a member function, exception specification of a member function, default member initializer, &lt;a href=&quot;attributes/contract&quot;&gt;contract condition&lt;/a&gt;(since C++20), or inside a nested class definition (including names of the bases from which the nested class is derived), the following scopes are searched:</source>
          <target state="translated">Для имени, используемого в любом месте &lt;a href=&quot;class&quot;&gt;определения класса&lt;/a&gt; , кроме как внутри тела функции-члена, аргумента по умолчанию для функции-члена, спецификации исключения для функции-члена, инициализатора члена по умолчанию, &lt;a href=&quot;attributes/contract&quot;&gt;условия контракта&lt;/a&gt; (начиная с C ++ 20) или внутри вложенного класса В определении (включая имена баз, из которых получен вложенный класс) ищутся следующие области:</target>
        </trans-unit>
        <trans-unit id="a684765457eef405a769182256e4ade4f401bc30" translate="yes" xml:space="preserve">
          <source>For a name used in a &lt;a href=&quot;default_arguments&quot;&gt;default argument&lt;/a&gt; in a function declaration, or name used in the expression part of a &lt;a href=&quot;constructor&quot;&gt;member-initializer&lt;/a&gt; of a constructor, the function parameter names are found first, before the enclosing block, class, or namespace scopes are examined:</source>
          <target state="translated">Для имени, используемого в &lt;a href=&quot;default_arguments&quot;&gt;аргументе&lt;/a&gt; по умолчанию в объявлении функции, или имени, используемом в части выражения &lt;a href=&quot;constructor&quot;&gt;инициализатора-члена&lt;/a&gt; конструктора, имена параметров функции должны быть найдены первыми, прежде чем будут рассмотрены области, включающие в себя блок, класс или пространство имен:</target>
        </trans-unit>
        <trans-unit id="6ae66449c2d64e5e5aa0c8dcee38ad7d218d4918" translate="yes" xml:space="preserve">
          <source>For a name used in a &lt;a href=&quot;friend&quot;&gt;friend&lt;/a&gt; function definition inside the body of the class that is granting friendship, unqualified name lookup proceeds the same way as for a member function. For a name used in a &lt;a href=&quot;friend&quot;&gt;friend&lt;/a&gt; function which is defined outside the body of a class, unqualified name lookup proceeds the same way as for a function in a namespace.</source>
          <target state="translated">Для имени, используемого в определении функции- &lt;a href=&quot;friend&quot;&gt;друга&lt;/a&gt; внутри тела класса, предоставляющего дружбу, поиск безусловного имени происходит так же, как и для функции-члена. Для имени, используемого в &lt;a href=&quot;friend&quot;&gt;дружественной&lt;/a&gt; функции, которая определена вне тела класса, поиск безоговорочного имени происходит так же, как и для функции в пространстве имен.</target>
        </trans-unit>
        <trans-unit id="f880effac86bc82db2f16b2948bd47f4311ada8a" translate="yes" xml:space="preserve">
          <source>For a name used in a user-declared namespace outside of any function or class, this namespace is searched before the use of the name, then the namespace enclosing this namespace before the declaration of this namespace, etc until the global namespace is reached.</source>
          <target state="translated">Для имени,используемого в объявленном пользователем пространстве имён вне какой-либо функции или класса,поиск этого пространства имён производится до использования имени,затем пространства имён,окружающего это пространство имён до объявления этого пространства имён,и т.д.до тех пор,пока не будет достигнуто глобальное пространство имён.</target>
        </trans-unit>
        <trans-unit id="d01e0277c975bcb293141e811447dfa3ec140823" translate="yes" xml:space="preserve">
          <source>For a name used in global (top-level namespace) scope, outside of any function, class, or user-declared namespace, the global scope before the use of the name is examined:</source>
          <target state="translated">Для имени,используемого в глобальном (пространстве имен верхнего уровня)пространстве имен,за пределами любой функции,класса или объявленного пользователем пространства имен,перед использованием имени проверяется глобальный диапазон:</target>
        </trans-unit>
        <trans-unit id="6751cf91d41edea8f420573f4bb5cfa36ba1c19a" translate="yes" xml:space="preserve">
          <source>For a name used in the catch-clause of a &lt;a href=&quot;function-try-block&quot;&gt;function-try-block&lt;/a&gt;, lookup proceeds as if for a name used in the very beginning of the outermost block of the function body (in particular, function parameters are visible, but names declared in that outermost block are not).</source>
          <target state="translated">Для имени, используемого в предложении catch &lt;a href=&quot;function-try-block&quot;&gt;функции-try-block&lt;/a&gt; , поиск продолжается, как будто для имени, используемого в самом начале самого внешнего блока тела функции (в частности, параметры функции видимы, но имена объявлены в этот самый внешний блок не).</target>
        </trans-unit>
        <trans-unit id="0ecffe6eebcdaa6e0a2a4a2d57d191d6b1fc5d6c" translate="yes" xml:space="preserve">
          <source>For a name used in the declarator of a &lt;a href=&quot;friend&quot;&gt;friend&lt;/a&gt; function declaration that friends a member function from another class, if the name isn't a part of any template argument, the unqualified lookup first examines the entire scope of the member function's class. If not found in that scope (or if the name is a part of a template argument), the lookup continues as if for a member function of the class that is granting friendship.</source>
          <target state="translated">Для имени, используемого в деклараторе объявления функции- &lt;a href=&quot;friend&quot;&gt;друга,&lt;/a&gt; который дружит с функцией-членом из другого класса, если имя не является частью какого-либо аргумента шаблона, неквалифицированный поиск сначала исследует всю область действия класса функции-члена. Если не найдено в этой области (или если имя является частью аргумента шаблона), поиск продолжается, как будто для функции-члена класса, который предоставляет дружбу.</target>
        </trans-unit>
        <trans-unit id="d95608e8a2ef528dbac2bab8b35c1d8f3a28d62b" translate="yes" xml:space="preserve">
          <source>For a name used in the definition of a &lt;a href=&quot;static&quot;&gt;static data member&lt;/a&gt;, lookup proceeds the same way as for a name used in the definition of a member function.</source>
          <target state="translated">Для имени, используемого в определении &lt;a href=&quot;static&quot;&gt;статического члена данных&lt;/a&gt; , поиск выполняется так же, как и для имени, используемого в определении функции-члена.</target>
        </trans-unit>
        <trans-unit id="f034307944cf4601fdfc2f8a86c32703ec89cf55" translate="yes" xml:space="preserve">
          <source>For a name used in the definition of a function, either in its body or as part of default argument, where the function is a member of user-declared or global namespace, the block in which the name is used is searched before the use of the name, then the enclosing block is searched before the start of that block, etc, until reaching the block that is the function body. Then the namespace in which the function is declared is searched until the definition (not necessarily the declaration) of the function that uses the name, then the enclosing namespaces, etc.</source>
          <target state="translated">Для имени,используемого в определении функции,либо в ее теле,либо в качестве части аргумента по умолчанию,когда функция является членом объявленного пользователем или глобального пространства имен,поиск в блоке,в котором используется имя,выполняется до использования имени,затем выполняется поиск в ограждающем блоке до начала этого блока и т.д.,пока не будет достигнут блок,являющийся телом функции.Затем выполняется поиск в пространстве имён,в котором объявлена функция,до определения (необязательно до объявления)функции,использующей имя,затем-охватывающих пространств имён и т.д.</target>
        </trans-unit>
        <trans-unit id="e69fc9e6436e85bd5e71b5f6fffe00b9251f55e4" translate="yes" xml:space="preserve">
          <source>For a name used in the definition of a namespace-member variable outside the namespace, lookup proceeds the same way as for a name used inside the namespace:</source>
          <target state="translated">Для имени,используемого в определении переменной-член пространства имен вне пространства имен,поиск продолжается так же,как и для имени,используемого внутри пространства имен:</target>
        </trans-unit>
        <trans-unit id="8362e87a521c085b7be1055bd62a4345efa29ea0" translate="yes" xml:space="preserve">
          <source>For a name used in the initializer part of the &lt;a href=&quot;enum&quot;&gt;enumerator declaration&lt;/a&gt;, previously declared enumerators in the same enumeration are found first, before the unqualified name lookup proceeds to examine the enclosing block, class, or namespace scope.</source>
          <target state="translated">Для имя , используемое в инициализатор части &lt;a href=&quot;enum&quot;&gt;декларации нумератора&lt;/a&gt; , заявленные ранее счетчикам в том же перечисления найдены во- первых, перед тем Безусловном поиск имени переходит к исследовать окружающий блок, класс, или область пространства имен.</target>
        </trans-unit>
        <trans-unit id="6979bced06285133967c5c4b103d3e0247545465" translate="yes" xml:space="preserve">
          <source>For a name used inside a member function body, a default argument of a member function, an exception specification of a member function, a default member initializer, a &lt;a href=&quot;attributes/contract&quot;&gt;contract condition&lt;/a&gt; of a member function(since C++20), or a nested class definition (including names of the bases from which the nested class is derived), the scopes searched are the same as in &lt;a href=&quot;unqualified_lookup#Class_definition&quot;&gt;class definition&lt;/a&gt;, except that the entire scope of the class is considered, not just the part prior to the declaration that uses the name. For nested classes the entire body of the enclosing class is searched.</source>
          <target state="translated">Для имени, используемого внутри тела функции-члена, аргумент по умолчанию для функции-члена, спецификация исключения для функции-члена, инициализатор члена по умолчанию, &lt;a href=&quot;attributes/contract&quot;&gt;условие контракта&lt;/a&gt; для функции-члена (начиная с C ++ 20) или вложенный класс При определении (включая имена оснований, из которых получен вложенный класс), искомые области совпадают с &lt;a href=&quot;unqualified_lookup#Class_definition&quot;&gt;определением класса&lt;/a&gt; , за исключением того, что рассматривается вся область действия класса, а не только часть до объявления, в котором используется имя , Для вложенных классов выполняется поиск всего тела включающего класса.</target>
        </trans-unit>
        <trans-unit id="5f9f456dc65dd5916b44e6d8b6b804f14836dd56" translate="yes" xml:space="preserve">
          <source>For a non-union aggregate, element for which a designated initializer is not provided are initialized the same as described above for when the number of initializer clauses is less than the number of members (default member initializers where provided, empty list-initialization otherwise):</source>
          <target state="translated">Для несоюзного агрегата элемент,для которого не предусмотрен указанный инициализатор,инициализируется так же,как описано выше,когда число пунктов инициализации меньше,чем число членов (инициализаторы по умолчанию,если предусмотрено,пустая инициализация в противном случае):</target>
        </trans-unit>
        <trans-unit id="5961fe12a3117fa1b2454e762062290b637aa259" translate="yes" xml:space="preserve">
          <source>For a pair of atomic modifications of M called A and B, B occurs after A in M's modification order if.</source>
          <target state="translated">Для пары атомных модификаций М,называемых A и B,B происходит после A в порядке модификации М,если.</target>
        </trans-unit>
        <trans-unit id="00a88dd4d98c693a356d74c5b2bd02963d1cfab7" translate="yes" xml:space="preserve">
          <source>For a pair of atomic operations on M called A and B, where A writes and B reads M's value, if there are two &lt;code&gt;memory_order_seq_cst&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;atomic_thread_fence&quot;&gt;std::atomic_thread_fence&lt;/a&gt;&lt;/code&gt;s X and Y, and if A is</source>
          <target state="translated">Для пары атомарных операций над M, называемых A и B, где A записывает и B считывает значение M, если есть два &lt;code&gt;memory_order_seq_cst&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;atomic_thread_fence&quot;&gt;std::atomic_thread_fence&lt;/a&gt;&lt;/code&gt; s X и Y, и если A является</target>
        </trans-unit>
        <trans-unit id="e8a036efd00fe52d195f38f7af9f452d212a3c7c" translate="yes" xml:space="preserve">
          <source>For a regular file &lt;code&gt;p&lt;/code&gt;, returns the size determined as if by reading the &lt;code&gt;st_size&lt;/code&gt; member of the structure obtained by POSIX &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/stat.html&quot;&gt;stat&lt;/a&gt; (symlinks are followed).</source>
          <target state="translated">Для обычного файла &lt;code&gt;p&lt;/code&gt; возвращает размер, определенный, как если бы он &lt;code&gt;st_size&lt;/code&gt; элемент st_size структуры, полученной из POSIX &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/stat.html&quot;&gt;stat&lt;/a&gt; (символические ссылки следуют).</target>
        </trans-unit>
        <trans-unit id="1a9910e8a0a912c3015de0a3b33c5c17808e192d" translate="yes" xml:space="preserve">
          <source>For a reverse iterator &lt;code&gt;r&lt;/code&gt; constructed from an iterator &lt;code&gt;i&lt;/code&gt;, the relationship &lt;code&gt;&amp;amp;*r == &amp;amp;*(i-1)&lt;/code&gt; is always true (as long as &lt;code&gt;r&lt;/code&gt; is dereferenceable); thus a reverse iterator constructed from a one-past-the-end iterator dereferences to the last element in a sequence.</source>
          <target state="translated">Для обратного итератора &lt;code&gt;r&lt;/code&gt; , созданного из итератора &lt;code&gt;i&lt;/code&gt; , соотношение &lt;code&gt;&amp;amp;*r == &amp;amp;*(i-1)&lt;/code&gt; всегда истинно (до тех пор, пока &lt;code&gt;r&lt;/code&gt; является разыменованным); таким образом, обратный итератор, построенный из итератора &amp;laquo;один за другим&amp;raquo;, разыменовывает последний элемент в последовательности.</target>
        </trans-unit>
        <trans-unit id="ad06b47edb0bcc2d8539e75487122b7c88338360" translate="yes" xml:space="preserve">
          <source>For a span &lt;code&gt;c&lt;/code&gt;, the expression &lt;code&gt;c.back()&lt;/code&gt; is equivalent to &lt;code&gt;*(c.end()-1)&lt;/code&gt;.</source>
          <target state="translated">Для диапазона &lt;code&gt;c&lt;/code&gt; выражение &lt;code&gt;c.back()&lt;/code&gt; эквивалентно &lt;code&gt;*(c.end()-1)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e1fa034a73d65c807607dcc81680fbdbbcb66bcc" translate="yes" xml:space="preserve">
          <source>For a span &lt;code&gt;c&lt;/code&gt;, the expression &lt;code&gt;c.front()&lt;/code&gt; is equivalent to &lt;code&gt;*c.begin()&lt;/code&gt;.</source>
          <target state="translated">Для диапазона &lt;code&gt;c&lt;/code&gt; выражение &lt;code&gt;c.front()&lt;/code&gt; эквивалентно &lt;code&gt;*c.begin()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5c154bb2c5d060e3bc21cda45246264cc660e3cf" translate="yes" xml:space="preserve">
          <source>For a standard stream &lt;code&gt;str&lt;/code&gt;, synchronized with the C stream &lt;code&gt;f&lt;/code&gt;, the following pairs of functions have identical effect:</source>
          <target state="translated">Для стандартного потока &lt;code&gt;str&lt;/code&gt; , синхронизированного с потоком C &lt;code&gt;f&lt;/code&gt; , следующие пары функций имеют идентичный эффект:</target>
        </trans-unit>
        <trans-unit id="de5683ef87cd469dd98d4cc4a0aed5b17f0dbfb7" translate="yes" xml:space="preserve">
          <source>For a type &lt;code&gt;T&lt;/code&gt;, the default value of &lt;code&gt;enable_view&amp;lt;T&amp;gt;&lt;/code&gt; is:</source>
          <target state="translated">Для типа &lt;code&gt;T&lt;/code&gt; значением по умолчанию &lt;code&gt;enable_view&amp;lt;T&amp;gt;&lt;/code&gt; является:</target>
        </trans-unit>
        <trans-unit id="a003d5a71c47171b8ec220d6469cdc87d155fcf6" translate="yes" xml:space="preserve">
          <source>For a type &lt;code&gt;TC&lt;/code&gt;:</source>
          <target state="translated">Для типа &lt;code&gt;TC&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="28eb0e4e99d6754c04540069cc9b86b6e86b0026" translate="yes" xml:space="preserve">
          <source>For a unary operator &lt;code&gt;@&lt;/code&gt; whose argument has type &lt;code&gt;T1&lt;/code&gt; (after removing cv-qualifications), or binary operator &lt;code&gt;@&lt;/code&gt; whose left operand has type &lt;code&gt;T1&lt;/code&gt; and right operand of type &lt;code&gt;T2&lt;/code&gt; (after removing cv-qualifications), the following sets of candidate functions are prepared:</source>
          <target state="translated">Для унарного оператора &lt;code&gt;@&lt;/code&gt; , аргумент которого имеет тип &lt;code&gt;T1&lt;/code&gt; (после удаления cv-квалификаций), или двоичного оператора &lt;code&gt;@&lt;/code&gt; , левый операнд которого имеет тип &lt;code&gt;T1&lt;/code&gt; и правый операнд типа &lt;code&gt;T2&lt;/code&gt; (после удаления cv-квалификаций), подготавливаются следующие наборы функций-кандидатов. :</target>
        </trans-unit>
        <trans-unit id="a0f6b7e105043260b05aaf0d46100e8d47e56be4" translate="yes" xml:space="preserve">
          <source>For a union with bits that participate in the value representations of some members but not the others, compare-and-exchange might always fail because such padding bits have indeterminate values when they do not participate in the value representation of the active member.</source>
          <target state="translated">Для союза с битами,которые участвуют в представлении ценностей одних членов,но не других,сравнение и обмен всегда могут оказаться неудачными,потому что такие биты подкладки имеют неопределенные значения,когда они не участвуют в представлении ценностей активного члена.</target>
        </trans-unit>
        <trans-unit id="1edec90a35f1485dfd1de3cb8edee29c85050704" translate="yes" xml:space="preserve">
          <source>For all &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;!(a &amp;lt; a)&lt;/code&gt;</source>
          <target state="translated">Для всех &lt;code&gt;a&lt;/code&gt; , &lt;code&gt;!(a &amp;lt; a)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="be2f118aaee33f35b4a4d55d4b1363d900dc2269" translate="yes" xml:space="preserve">
          <source>For all &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;comp(a,a)==false&lt;/code&gt;</source>
          <target state="translated">Для всех &lt;code&gt;a&lt;/code&gt; , &lt;code&gt;comp(a,a)==false&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="232a0e7be31828ff9c9e76ce04deca11781e6a26" translate="yes" xml:space="preserve">
          <source>For all &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;equiv(a,a)==true&lt;/code&gt;</source>
          <target state="translated">Для всех &lt;code&gt;a&lt;/code&gt; , &lt;code&gt;equiv(a,a)==true&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="dcda67f6f48d3eaf152c442223488264fae5046f" translate="yes" xml:space="preserve">
          <source>For all &lt;code&gt;c&lt;/code&gt; and &lt;code&gt;d&lt;/code&gt;, &lt;code&gt;X​::​eq(c,d)&lt;/code&gt; is equal to &lt;code&gt;X​::​eq_int_type(X​::​to_int_type(c), X​::​to_int_type(d))&lt;/code&gt;</source>
          <target state="translated">Для всех &lt;code&gt;c&lt;/code&gt; и &lt;code&gt;d&lt;/code&gt; , &lt;code&gt;X​::​eq(c,d)&lt;/code&gt; равно &lt;code&gt;X​::​eq_int_type(X​::​to_int_type(c), X​::​to_int_type(d))&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2032585f99e27bc2ad7b8385f77f212571492869" translate="yes" xml:space="preserve">
          <source>For all other functions, reaching the end of a catch clause is equivalent to &lt;code&gt;return;&lt;/code&gt; if the function's return type is (possibly cv-qualified) &lt;code&gt;void&lt;/code&gt;, otherwise the behavior is undefined.</source>
          <target state="translated">Для всех других функций достижение конца предложения catch эквивалентно &lt;code&gt;return;&lt;/code&gt; если возвращаемый тип функции (возможно, cv-квалифицирован) &lt;code&gt;void&lt;/code&gt; , в противном случае поведение не определено.</target>
        </trans-unit>
        <trans-unit id="da7d72e89e6f7a108ff843546e67ee1b3d8bf96b" translate="yes" xml:space="preserve">
          <source>For all other names (variables, namespaces, classes, etc), name lookup must produce a single declaration in order for the program to compile. Lookup for a name in a scope finds all declarations of that name, with one exception, known as the &quot;struct hack&quot; or &quot;type/non-type hiding&quot;: Within the same scope, some occurrences of a name may refer to a declaration of a class/struct/union/enum that is not a typedef, while all other occurrences of the same name either all refer to the same variable, non-static data member (since C++14), or enumerator, or they all refer to possibly overloaded function or function template names. In this case, there is no error, but the type name is hidden from lookup (the code must use &lt;a href=&quot;elaborated_type_specifier&quot;&gt;elaborated type specifier&lt;/a&gt; to access it).</source>
          <target state="translated">Для всех других имен (переменных, пространств имен, классов и т. Д.) Поиск по имени должен производить одно объявление для компиляции программы. Поиск по имени в области находит все объявления этого имени, за одним исключением, известным как &amp;laquo;взлом структуры&amp;raquo; или &amp;laquo;сокрытие типа / не-типа&amp;raquo;: в одной и той же области некоторые вхождения имени могут ссылаться на объявление класса / struct / union / enum, который не является typedef, в то время как все другие вхождения с одинаковыми именами либо ссылаются на одну и ту же переменную, нестатический член данных (начиная с C ++ 14), либо перечислитель, либо все они обратитесь к возможно перегруженным именам функций или шаблонов функций. В этом случае ошибки нет, но имя типа скрыто от поиска ( для доступа к нему код должен использовать &lt;a href=&quot;elaborated_type_specifier&quot;&gt;разработанный спецификатор типа&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="10db488ddc48847974dabc392b2f321428b2ad60" translate="yes" xml:space="preserve">
          <source>For all other objects (class objects initialized by a trivial default constructor, non-class objects, arrays of those, etc.), lifetime begins when the properly-aligned storage for the object is allocated and ends when the storage is deallocated or reused by another object.</source>
          <target state="translated">Для всех остальных объектов (объектов классов,инициализированных тривиальным конструктором по умолчанию,неклассовых объектов,массивов этих объектов и т.д.)время жизни начинается с момента выделения для объекта правильно выровненного хранилища и заканчивается,когда хранилище разобрано или повторно используется другим объектом.</target>
        </trans-unit>
        <trans-unit id="760abd8226337c152c576ef554b6c75c15801476" translate="yes" xml:space="preserve">
          <source>For all three operators, the usual arithmetic conversions are performed on both operands and determine the type of the result.</source>
          <target state="translated">Для всех трех операторов выполняются обычные арифметические приведения на обоих операндов и определяется тип результата.</target>
        </trans-unit>
        <trans-unit id="8d67a35b43e5bf5606d1d36920c0574ac4035475" translate="yes" xml:space="preserve">
          <source>For all values of &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;a == a&lt;/code&gt; yields &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">Для всех значений , &lt;code&gt;a == a&lt;/code&gt; доходность &lt;code&gt;true&lt;/code&gt; . &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="bd7a423e3b93ec1547e0b8fd506cf138031deb4a" translate="yes" xml:space="preserve">
          <source>For an</source>
          <target state="translated">Для</target>
        </trans-unit>
        <trans-unit id="abab0bc9e7d335f8452e190fdf3bbe8302cb65a4" translate="yes" xml:space="preserve">
          <source>For an &lt;a href=&quot;expressions#Operators&quot;&gt;operator&lt;/a&gt; used in expression (e.g., &lt;code&gt;operator+&lt;/code&gt; used in &lt;code&gt;a+b&lt;/code&gt;), the lookup rules are slightly different from the operator used in an explicit function-call expression such as &lt;code&gt;operator+(a,b)&lt;/code&gt;: when parsing an expression, two separate lookups are performed: for the non-member operator overloads and for the member operator overloads (for the operators where both forms are permitted). Those sets are then merged with the built-in operator overloads on equal grounds as described in &lt;a href=&quot;overload_resolution&quot;&gt;overload resolution&lt;/a&gt;. If explicit function call syntax is used, regular unqualified name lookup is performed:</source>
          <target state="translated">Для &lt;a href=&quot;expressions#Operators&quot;&gt;оператора,&lt;/a&gt; используемого в выражении (например, &lt;code&gt;operator+&lt;/code&gt; используется в &lt;code&gt;a+b&lt;/code&gt; ), правила поиска немного отличаются от оператора, используемого в явном выражении вызова функции, таком как &lt;code&gt;operator+(a,b)&lt;/code&gt; : при разборе выражения два отдельных поиск выполняется: для перегрузок операторов, не являющихся членами, и для перегрузок операторов-членов (для операторов, где разрешены обе формы). Эти наборы затем объединяются со встроенными перегрузками операторов на равных основаниях, как описано в &lt;a href=&quot;overload_resolution&quot;&gt;разрешении перегрузки&lt;/a&gt; . Если используется явный синтаксис вызова функции, выполняется обычный поиск по неквалифицированному имени:</target>
        </trans-unit>
        <trans-unit id="cfdde08423e6892ce026f332e4722775a6fd0ec4" translate="yes" xml:space="preserve">
          <source>For an inline function or inline variable(since C++17), a definition is required in every translation unit where it is</source>
          <target state="translated">Для inline-функции или inline-переменной (начиная с C++17),определение требуется в каждой единице трансляции,где оно есть</target>
        </trans-unit>
        <trans-unit id="b13c06c8df9fdd2618a4c37f530dfc9ec64faee7" translate="yes" xml:space="preserve">
          <source>For an object &lt;code&gt;m&lt;/code&gt; of Mutex type:</source>
          <target state="translated">Для объекта &lt;code&gt;m&lt;/code&gt; типа Mutex:</target>
        </trans-unit>
        <trans-unit id="10c618faebd2cba6e4ed1d78498e9c737887c436" translate="yes" xml:space="preserve">
          <source>For an object of type &lt;code&gt;T&lt;/code&gt;,</source>
          <target state="translated">Для объекта типа &lt;code&gt;T&lt;/code&gt; ,</target>
        </trans-unit>
        <trans-unit id="9cbc15bac40798667e2c28ef32d8acd0bfca6527" translate="yes" xml:space="preserve">
          <source>For any &lt;code&gt;year_month_day&lt;/code&gt; object &lt;code&gt;ymd&lt;/code&gt; representing a valid date (&lt;code&gt;ymd.ok() == true&lt;/code&gt;), converting &lt;code&gt;ymd&lt;/code&gt; to &lt;code&gt;sys_days&lt;/code&gt; and back yields the same value.</source>
          <target state="translated">Для любого &lt;code&gt;year_month_day&lt;/code&gt; объекта &lt;code&gt;ymd&lt;/code&gt; , представляющий собой действительную дату ( &lt;code&gt;ymd.ok() == true&lt;/code&gt; ), преобразование &lt;code&gt;ymd&lt;/code&gt; в &lt;code&gt;sys_days&lt;/code&gt; и обратно дает то же значение.</target>
        </trans-unit>
        <trans-unit id="f2a393f7232125085f4da3eb01cb2d41b026b8c4" translate="yes" xml:space="preserve">
          <source>For any object &lt;code&gt;z&lt;/code&gt; of type &lt;code&gt;complex&amp;lt;T&amp;gt;&lt;/code&gt;, &lt;code&gt;reinterpret_cast&amp;lt;T(&amp;amp;)[2]&amp;gt;(z)[0]&lt;/code&gt; is the real part of z and &lt;code&gt;reinterpret_cast&amp;lt;T(&amp;amp;)[2]&amp;gt;(z)[1]&lt;/code&gt; is the imaginary part of z.</source>
          <target state="translated">Для любого объекта &lt;code&gt;z&lt;/code&gt; типа &lt;code&gt;complex&amp;lt;T&amp;gt;&lt;/code&gt; , &lt;code&gt;reinterpret_cast&amp;lt;T(&amp;amp;)[2]&amp;gt;(z)[0]&lt;/code&gt; является действительной частью г и &lt;code&gt;reinterpret_cast&amp;lt;T(&amp;amp;)[2]&amp;gt;(z)[1]&lt;/code&gt; мнимая часть г.</target>
        </trans-unit>
        <trans-unit id="aa002637ab58deab74ffaca3cf03066bd188d114" translate="yes" xml:space="preserve">
          <source>For any object of class or aggregate types if it, or any of its subobjects, is initialized by anything other than the &lt;a href=&quot;default_constructor#Trivial_default_constructor&quot;&gt;trivial default constructor&lt;/a&gt;, lifetime begins when initialization ends.</source>
          <target state="translated">Для любого объекта класса или агрегатного типа, если он или любой из его подобъектов инициализируется чем-то иным, чем &lt;a href=&quot;default_constructor#Trivial_default_constructor&quot;&gt;простой конструктор по умолчанию&lt;/a&gt; , время жизни начинается после завершения инициализации.</target>
        </trans-unit>
        <trans-unit id="cdd8992024517b51f7efb1e98465ebff61447714" translate="yes" xml:space="preserve">
          <source>For any object of class types whose &lt;a href=&quot;destructor#Trivial_destructor&quot;&gt;destructor&lt;/a&gt; is not trivial, lifetime ends when the execution of the destructor begins.</source>
          <target state="translated">Для любого объекта типов классов, чей &lt;a href=&quot;destructor#Trivial_destructor&quot;&gt;деструктор&lt;/a&gt; не является тривиальным, время жизни заканчивается, когда начинается выполнение деструктора.</target>
        </trans-unit>
        <trans-unit id="fa44da499e47fc6fac2860172008adb9c1ff9a16" translate="yes" xml:space="preserve">
          <source>For any other type, &lt;code&gt;value&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">Для любого другого типа &lt;code&gt;value&lt;/code&gt; равно &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cefa90cb2c929a28be455e9f8fda7d414ab3948b" translate="yes" xml:space="preserve">
          <source>For any pointer to an element of an array of &lt;code&gt;complex&amp;lt;T&amp;gt;&lt;/code&gt; named &lt;code&gt;p&lt;/code&gt; and any valid array index &lt;code&gt;i&lt;/code&gt;, &lt;code&gt;reinterpret_cast&amp;lt;T*&amp;gt;(p)[2*i]&lt;/code&gt; is the real part of the complex number &lt;code&gt;p[i]&lt;/code&gt;, and &lt;code&gt;reinterpret_cast&amp;lt;T*&amp;gt;(p)[2*i + 1]&lt;/code&gt; is the imaginary part of the complex number &lt;code&gt;p[i]&lt;/code&gt;</source>
          <target state="translated">Для любого указателя на элемент массива &lt;code&gt;complex&amp;lt;T&amp;gt;&lt;/code&gt; с именем &lt;code&gt;p&lt;/code&gt; и любого действительного индекса массива &lt;code&gt;i&lt;/code&gt; , &lt;code&gt;reinterpret_cast&amp;lt;T*&amp;gt;(p)[2*i]&lt;/code&gt; является действительной частью комплексного числа &lt;code&gt;p[i]&lt;/code&gt; , и &lt;code&gt;reinterpret_cast&amp;lt;T*&amp;gt;(p)[2*i + 1]&lt;/code&gt; - мнимая часть комплексного числа &lt;code&gt;p[i]&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="33bcdf350e21fefb2826ca912ee3190d4a971dc5" translate="yes" xml:space="preserve">
          <source>For any two values &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt; of the type &lt;code&gt;&lt;a href=&quot;../../iterator/iterator_traits&quot;&gt;std::iterator_traits&lt;/a&gt;&amp;lt;RandomIt1&amp;gt;::value_type&lt;/code&gt;, if &lt;code&gt;pred(A, B) == true&lt;/code&gt;, then &lt;code&gt;hf(A) == hf(B)&lt;/code&gt; shall be &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">Для любых двух значений &lt;code&gt;A&lt;/code&gt; и &lt;code&gt;B&lt;/code&gt; типа &lt;code&gt;&lt;a href=&quot;../../iterator/iterator_traits&quot;&gt;std::iterator_traits&lt;/a&gt;&amp;lt;RandomIt1&amp;gt;::value_type&lt;/code&gt; , если pred &lt;code&gt;pred(A, B) == true&lt;/code&gt; , тогда &lt;code&gt;hf(A) == hf(B)&lt;/code&gt; должно быть &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6b450ffc7f721529dcdc6d1be9e46c5d50a2a925" translate="yes" xml:space="preserve">
          <source>For any type &lt;code&gt;T&lt;/code&gt; (including incomplete types), other than &lt;a href=&quot;functions&quot;&gt;function type&lt;/a&gt; or &lt;a href=&quot;reference&quot;&gt;reference type&lt;/a&gt;, there are three more distinct types in the C++ type system: const-qualified&lt;code&gt;T&lt;/code&gt;, volatile-qualified&lt;code&gt;T&lt;/code&gt;, and const-volatile-qualified&lt;code&gt;T&lt;/code&gt;.  Note: &lt;a href=&quot;array&quot;&gt;array types&lt;/a&gt; are considered to have the same cv-qualification as their element types.</source>
          <target state="translated">Для любого типа &lt;code&gt;T&lt;/code&gt; ( в том числе неполных типов), кроме &lt;a href=&quot;functions&quot;&gt;типа функции&lt;/a&gt; или &lt;a href=&quot;reference&quot;&gt;ссылочного типа&lt;/a&gt; , существует три различных тип более в системе типов C ++: Const-квалифицирован &lt;code&gt;T&lt;/code&gt; , энергозависимая квалификация &lt;code&gt;T&lt;/code&gt; и Const энергонезависимых квалифицированных &lt;code&gt;T&lt;/code&gt; . Примечание: считается, что &lt;a href=&quot;array&quot;&gt;типы массивов&lt;/a&gt; имеют ту же квалификацию cv, что и их типы элементов.</target>
        </trans-unit>
        <trans-unit id="587d19dece0a5e657eee4b9c6dab7110d60627cf" translate="yes" xml:space="preserve">
          <source>For any z, acos(z) = &amp;pi; - acos(-z).</source>
          <target state="translated">Для любого z acos (z) = &amp;pi; - acos (-z).</target>
        </trans-unit>
        <trans-unit id="21aee1213fe266997611327508955de0364192e9" translate="yes" xml:space="preserve">
          <source>For any z, atanh(z) =</source>
          <target state="translated">Для любого z,atanh(z)=</target>
        </trans-unit>
        <trans-unit id="e254b6622c2f4cf79e478657cc199aa0c2eea2e9" translate="yes" xml:space="preserve">
          <source>For append streams (&lt;code&gt;mode &amp;amp; ios_base::ate == true&lt;/code&gt;), &lt;code&gt;pptr() == pbase() + s.size()&lt;/code&gt;, so that subsequent output will be appended to the last character copied from &lt;code&gt;s&lt;/code&gt;(since C++11)</source>
          <target state="translated">Для потоков добавления ( &lt;code&gt;mode &amp;amp; ios_base::ate == true&lt;/code&gt; ) &lt;code&gt;pptr() == pbase() + s.size()&lt;/code&gt; , чтобы последующий вывод был добавлен к последнему символу, скопированному из &lt;code&gt;s&lt;/code&gt; (начиная с C ++ 11 )</target>
        </trans-unit>
        <trans-unit id="c24da57cc18573525a82a6c2c1fa0a27b061d0da" translate="yes" xml:space="preserve">
          <source>For arg&amp;gt;1, &amp;Sigma;&amp;infin;</source>
          <target state="translated">Для arg&amp;gt; 1, &amp;Sigma;&amp;infin;</target>
        </trans-unit>
        <trans-unit id="7046cc5d9597c58aa7e54080523a910de0e052c1" translate="yes" xml:space="preserve">
          <source>For arg&amp;lt;0, 2arg</source>
          <target state="translated">Для arg &amp;lt;0, 2arg</target>
        </trans-unit>
        <trans-unit id="188be9f862ad64a9a657bafc75642d5f5c9f6a4f" translate="yes" xml:space="preserve">
          <source>For arithmetic types not subject to promotion, the common type may be viewed as the type of the (possibly mixed-mode) arithmetic expression such as &lt;code&gt;T0() + T1() + ... + Tn()&lt;/code&gt;.</source>
          <target state="translated">Для арифметических типов, не подлежащих продвижению, общий тип может рассматриваться как тип арифметического выражения (возможно, смешанного режима), такого как &lt;code&gt;T0() + T1() + ... + Tn()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="79dccf2c6a91881692253227b281b3f534531201" translate="yes" xml:space="preserve">
          <source>For arithmetic types, the thousands separator character, obtained from &lt;code&gt;&lt;a href=&quot;../use_facet&quot;&gt;std::use_facet&lt;/a&gt;&amp;lt;&lt;a href=&quot;../numpunct&quot;&gt;std::numpunct&lt;/a&gt;&amp;lt;CharT&amp;gt;&amp;gt;(str.getloc()).thousands_sep()&lt;/code&gt;, is inserted into the sequence according to the grouping rules provided by &lt;code&gt;&lt;a href=&quot;../use_facet&quot;&gt;std::use_facet&lt;/a&gt;&amp;lt;&lt;a href=&quot;../numpunct&quot;&gt;std::numpunct&lt;/a&gt;&amp;lt;CharT&amp;gt;&amp;gt;(str.getloc()).grouping()&lt;/code&gt;</source>
          <target state="translated">Для арифметических типов символ-разделитель тысяч, полученный из &lt;code&gt;&lt;a href=&quot;../use_facet&quot;&gt;std::use_facet&lt;/a&gt;&amp;lt;&lt;a href=&quot;../numpunct&quot;&gt;std::numpunct&lt;/a&gt;&amp;lt;CharT&amp;gt;&amp;gt;(str.getloc()).thousands_sep()&lt;/code&gt; , вставляется в последовательность в соответствии с правилами группировки, предоставленными &lt;code&gt;&lt;a href=&quot;../use_facet&quot;&gt;std::use_facet&lt;/a&gt;&amp;lt;&lt;a href=&quot;../numpunct&quot;&gt;std::numpunct&lt;/a&gt;&amp;lt;CharT&amp;gt;&amp;gt;(str.getloc()).grouping()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c01eb08fd12dd04934e4ddc13d646e9cc256574b" translate="yes" xml:space="preserve">
          <source>For auto-returning functions, the parameter &lt;code&gt;P&lt;/code&gt; is obtained as follows: in &lt;code&gt;T&lt;/code&gt;, the declared return type of the function that includes &lt;code&gt;auto&lt;/code&gt;, every occurrence of &lt;code&gt;auto&lt;/code&gt; is replaced with an imaginary type template parameter &lt;code&gt;U&lt;/code&gt;. The argument &lt;code&gt;A&lt;/code&gt; is the expression of the &lt;a href=&quot;return&quot;&gt;return&lt;/a&gt; statement, and if the return statement has no operand, &lt;code&gt;A&lt;/code&gt; is &lt;code&gt;void()&lt;/code&gt;. After deduction of &lt;code&gt;U&lt;/code&gt; from &lt;code&gt;P&lt;/code&gt; and &lt;code&gt;A&lt;/code&gt; following the rules described above, the deduced &lt;code&gt;U&lt;/code&gt; is substituted into &lt;code&gt;T&lt;/code&gt; to get the actual return type:</source>
          <target state="translated">Для авто-возвращении функций, параметр &lt;code&gt;P&lt;/code&gt; получаются следующим образом : в &lt;code&gt;T&lt;/code&gt; , заявленный типа возврата функции , которая включает в себя &lt;code&gt;auto&lt;/code&gt; , каждом вхождении &lt;code&gt;auto&lt;/code&gt; заменяется шаблон воображаемого типа параметра &lt;code&gt;U&lt;/code&gt; . Аргумент &lt;code&gt;A&lt;/code&gt; является выражением оператора &lt;a href=&quot;return&quot;&gt;возврата&lt;/a&gt; , и если оператор возврата не имеет операнда, &lt;code&gt;A&lt;/code&gt; является &lt;code&gt;void()&lt;/code&gt; . После вычета &lt;code&gt;U&lt;/code&gt; из &lt;code&gt;P&lt;/code&gt; и &lt;code&gt;A&lt;/code&gt; в соответствии с правилами, описанными выше, выведенный &lt;code&gt;U&lt;/code&gt; подставляется в &lt;code&gt;T&lt;/code&gt; для получения фактического возвращаемого типа:</target>
        </trans-unit>
        <trans-unit id="21745cae4e72428f50d08dc188de6ed08f485b25" translate="yes" xml:space="preserve">
          <source>For both integer and floating-point types, if &lt;code&gt;showpos&lt;/code&gt; is set, the modifier &lt;code&gt;+&lt;/code&gt; is prepended</source>
          <target state="translated">Для обоих типов: целочисленных и с плавающей точкой, если &lt;code&gt;showpos&lt;/code&gt; , добавляется модификатор &lt;code&gt;+&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6e00438cc48aea953c237222b040f934d513cc5a" translate="yes" xml:space="preserve">
          <source>For both overloads, if the iterator type is mutable, &lt;code&gt;f&lt;/code&gt; may modify the elements of the range through the dereferenced iterator. If &lt;code&gt;f&lt;/code&gt; returns a result, the result is ignored.</source>
          <target state="translated">Для обеих перегрузок, если тип итератора является изменяемым, &lt;code&gt;f&lt;/code&gt; может изменять элементы диапазона через разыменованный итератор. Если &lt;code&gt;f&lt;/code&gt; возвращает результат, результат игнорируется.</target>
        </trans-unit>
        <trans-unit id="d4b87d39492f3a203318f3eec5a45d21ed020f35" translate="yes" xml:space="preserve">
          <source>For both overloads, if the iterator type is mutable, &lt;code&gt;f&lt;/code&gt; may modify the elements of the range through the dereferenced iterator. If &lt;code&gt;f&lt;/code&gt; returns a result, the result is ignored. If &lt;code&gt;n&lt;/code&gt; is less than zero, the behavior is undefined.</source>
          <target state="translated">Для обеих перегрузок, если тип итератора является изменяемым, &lt;code&gt;f&lt;/code&gt; может изменять элементы диапазона через разыменованный итератор. Если &lt;code&gt;f&lt;/code&gt; возвращает результат, результат игнорируется. Если &lt;code&gt;n&lt;/code&gt; меньше нуля, поведение не определено.</target>
        </trans-unit>
        <trans-unit id="2cbfdeffec6dd0f35e1227e8a499f4b7385ae247" translate="yes" xml:space="preserve">
          <source>For both user-defined or implicitly-defined destructors, after the body of the destructor is executed, the compiler calls the destructors for all non-static non-variant members of the class, in reverse order of declaration, then it calls the destructors of all direct non-virtual base classes in &lt;a href=&quot;constructor#Initialization_order&quot;&gt;reverse order of construction&lt;/a&gt; (which in turn call the destructors of their members and their base classes, etc), and then, if this object is of most-derived class, it calls the destructors of all virtual bases.</source>
          <target state="translated">Как для пользовательских, так и для неявно определенных деструкторов, после выполнения тела деструктора компилятор вызывает деструкторы для всех нестатических не вариантных членов класса в обратном порядке объявления, затем он вызывает деструкторы все прямые не виртуальные базовые классы в &lt;a href=&quot;constructor#Initialization_order&quot;&gt;обратном порядке конструирования&lt;/a&gt; (которые в свою очередь вызывают деструкторы их членов и их базовые классы и т. д.), а затем, если этот объект относится к классу с наибольшим производным, он вызывает деструкторы всех виртуальных основы.</target>
        </trans-unit>
        <trans-unit id="db34171dc6d92c22aa5da5d7cd5e78cc97249f77" translate="yes" xml:space="preserve">
          <source>For char arrays shorter than &lt;code&gt;&lt;a href=&quot;climits&quot;&gt;PTRDIFF_MAX&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;std::ptrdiff_t&lt;/code&gt; acts as the signed counterpart of &lt;code&gt;&lt;a href=&quot;size_t&quot;&gt;std::size_t&lt;/a&gt;&lt;/code&gt;: it can store the size of the array of any type and is, on most platforms, synonymous with &lt;code&gt;&lt;a href=&quot;integer&quot;&gt;std::intptr_t&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Для массивов символов короче &lt;code&gt;&lt;a href=&quot;climits&quot;&gt;PTRDIFF_MAX&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;std::ptrdiff_t&lt;/code&gt; выступает в качестве подписанного контрагента &lt;code&gt;&lt;a href=&quot;size_t&quot;&gt;std::size_t&lt;/a&gt;&lt;/code&gt; : он может хранить размер массива любого типа и на большинстве платформ, синонимичных с &lt;code&gt;&lt;a href=&quot;integer&quot;&gt;std::intptr_t&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6f3c75e611a43557be37674fd1cb00bb164eeebf" translate="yes" xml:space="preserve">
          <source>For compatibility with C89, an optional comma may appear before the ellipsis if the parameter list contains at least one parameter:</source>
          <target state="translated">Для совместимости с C89 перед эллипсисом может появиться необязательная запятая,если список параметров содержит хотя бы один параметр:</target>
        </trans-unit>
        <trans-unit id="94880bd109360b34fd05f9d76510d26eb3dee88a" translate="yes" xml:space="preserve">
          <source>For constexpr function templates and constexpr member functions of class templates, at least one specialization must satisfy the abovementioned requirements. Other specializations are still considered as constexpr, even though a call to such a function cannot appear in a constant expression.</source>
          <target state="translated">Для шаблонов функций constexpr и функций-членов constexpr шаблонов классов хотя бы одна специализация должна удовлетворять вышеуказанным требованиям.Другие специализации по-прежнему рассматриваются как constexpr,хотя вызов такой функции не может появиться в константном выражении.</target>
        </trans-unit>
        <trans-unit id="9efcdd76c0a92319514fd74592e33806161ca5b0" translate="yes" xml:space="preserve">
          <source>For control over formatting, use &lt;code&gt;std::chrono::format&lt;/code&gt;.</source>
          <target state="translated">Для контроля над форматированием используйте &lt;code&gt;std::chrono::format&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ce61db7d14bb600483458137835d50aed271a6ed" translate="yes" xml:space="preserve">
          <source>For creation of a full date, any of the following three orders are accepted:</source>
          <target state="translated">Для создания полной даты принимается любой из следующих трех заказов:</target>
        </trans-unit>
        <trans-unit id="1e51f626291c443aca3537b45aaca51887d63f76" translate="yes" xml:space="preserve">
          <source>For detailed rules on overload resolution, see &lt;a href=&quot;overload_resolution&quot;&gt;overload resolution&lt;/a&gt;.</source>
          <target state="translated">Подробные правила разрешения &lt;a href=&quot;overload_resolution&quot;&gt;перегрузки&lt;/a&gt; см. В разделе разрешение перегрузки .</target>
        </trans-unit>
        <trans-unit id="3ccd8ef2913234c8ce975d9ef8bd2b1cb54addbe" translate="yes" xml:space="preserve">
          <source>For each &lt;code&gt;Ti&lt;/code&gt; in &lt;code&gt;Types...&lt;/code&gt;, the corresponding type &lt;code&gt;Vi&lt;/code&gt; in &lt;code&gt;VTypes...&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;../../types/decay&quot;&gt;std::decay&lt;/a&gt;&amp;lt;Ti&amp;gt;::type&lt;/code&gt; unless application of &lt;code&gt;&lt;a href=&quot;../../types/decay&quot;&gt;std::decay&lt;/a&gt;&lt;/code&gt; results in &lt;code&gt;&lt;a href=&quot;../functional/reference_wrapper&quot;&gt;std::reference_wrapper&lt;/a&gt;&amp;lt;X&amp;gt;&lt;/code&gt; for some type &lt;code&gt;X&lt;/code&gt;, in which case the deduced type is &lt;code&gt;X&amp;amp;&lt;/code&gt;.</source>
          <target state="translated">Для каждого &lt;code&gt;Ti&lt;/code&gt; в &lt;code&gt;Types...&lt;/code&gt; соответствующий тип &lt;code&gt;Vi&lt;/code&gt; в &lt;code&gt;VTypes...&lt;/code&gt; является &lt;code&gt;&lt;a href=&quot;../../types/decay&quot;&gt;std::decay&lt;/a&gt;&amp;lt;Ti&amp;gt;::type&lt;/code&gt; если применение &lt;code&gt;&lt;a href=&quot;../../types/decay&quot;&gt;std::decay&lt;/a&gt;&lt;/code&gt; приводит к &lt;code&gt;&lt;a href=&quot;../functional/reference_wrapper&quot;&gt;std::reference_wrapper&lt;/a&gt;&amp;lt;X&amp;gt;&lt;/code&gt; для некоторого типа &lt;code&gt;X&lt;/code&gt; , в этом случае выведенный тип - &lt;code&gt;X&amp;amp;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ebdcf0767cd45dcef0e5f166fda3ae1b99a89262" translate="yes" xml:space="preserve">
          <source>For each &lt;code&gt;i&lt;/code&gt; in &lt;code&gt;[0,j)&lt;/code&gt;, &lt;code&gt;X​::​eq(p[i], q[i])&lt;/code&gt; is true</source>
          <target state="translated">Для каждого &lt;code&gt;i&lt;/code&gt; в &lt;code&gt;[0,j)&lt;/code&gt; , &lt;code&gt;X​::​eq(p[i], q[i])&lt;/code&gt; верно</target>
        </trans-unit>
        <trans-unit id="a48fe3fe8c043eed63afe7b1696e912edb4e26e0" translate="yes" xml:space="preserve">
          <source>For each &lt;code&gt;i&lt;/code&gt; in &lt;code&gt;[0,n)&lt;/code&gt;, performs &lt;code&gt;X​::​assign(s[i], c)&lt;/code&gt;.</source>
          <target state="translated">Для каждого &lt;code&gt;i&lt;/code&gt; в &lt;code&gt;[0,n)&lt;/code&gt; выполняется &lt;code&gt;X​::​assign(s[i], c)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c7673ab38c4ed279e12cc192b7a57b5fd910e9b3" translate="yes" xml:space="preserve">
          <source>For each &lt;code&gt;i&lt;/code&gt; in &lt;code&gt;[0,n)&lt;/code&gt;, performs &lt;code&gt;X​::​assign(s[i], p[i])&lt;/code&gt;</source>
          <target state="translated">Для каждого &lt;code&gt;i&lt;/code&gt; в &lt;code&gt;[0,n)&lt;/code&gt; выполняется &lt;code&gt;X​::​assign(s[i], p[i])&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3a6ddee35ee106c63cce63cef04db68150835b00" translate="yes" xml:space="preserve">
          <source>For each declarator, the initializer may be one of the following:</source>
          <target state="translated">Для каждого декларатора инициализатором может быть один из следующих:</target>
        </trans-unit>
        <trans-unit id="71cdc882df31450c88808b61a9ff32adee6518cf" translate="yes" xml:space="preserve">
          <source>For each distinct base class that is specified &lt;code&gt;virtual&lt;/code&gt;, the most derived object contains only one base class subobject of that type, even if the class appears many times in the inheritance hierarchy (as long as it is inherited &lt;code&gt;virtual&lt;/code&gt; every time).</source>
          <target state="translated">Для каждого отдельного базового класса, который указан &lt;code&gt;virtual&lt;/code&gt; , наиболее производный объект содержит только один подобъект базового класса этого типа, даже если этот класс появляется много раз в иерархии наследования (если он каждый раз наследуется &lt;code&gt;virtual&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="5bfb358921b4b02768fb8323b116ca9ed3bbe11d" translate="yes" xml:space="preserve">
          <source>For each element in &lt;code&gt;va&lt;/code&gt; computes</source>
          <target state="translated">Для каждого элемента в &lt;code&gt;va&lt;/code&gt; вычисляет</target>
        </trans-unit>
        <trans-unit id="483eec964f0d73c99af70508de57de3007259d4d" translate="yes" xml:space="preserve">
          <source>For each element in &lt;code&gt;va&lt;/code&gt; computes arc cosine of the value of the element.</source>
          <target state="translated">Для каждого элемента в &lt;code&gt;va&lt;/code&gt; вычисляется арккосинус значения элемента.</target>
        </trans-unit>
        <trans-unit id="adb75759a95a8aeb64e9736b66397da9bd1d4446" translate="yes" xml:space="preserve">
          <source>For each element in &lt;code&gt;va&lt;/code&gt; computes arc sine of the value of the element.</source>
          <target state="translated">Для каждого элемента в &lt;code&gt;va&lt;/code&gt; вычисляется арксинус значения элемента.</target>
        </trans-unit>
        <trans-unit id="ca88cd5ed53414ce6dc3bf89279bd5da6137ef0b" translate="yes" xml:space="preserve">
          <source>For each element in &lt;code&gt;va&lt;/code&gt; computes arc tangent of the value of the element.</source>
          <target state="translated">Для каждого элемента в &lt;code&gt;va&lt;/code&gt; вычисляется арктангенс значения элемента.</target>
        </trans-unit>
        <trans-unit id="f7b456dfebcb725eca2a813704a2d061981a4d5d" translate="yes" xml:space="preserve">
          <source>For each element in &lt;code&gt;va&lt;/code&gt; computes common (base 10) logarithm of the value of the element.</source>
          <target state="translated">Для каждого элемента в &lt;code&gt;va&lt;/code&gt; вычисляется общий (основание 10) логарифм значения элемента.</target>
        </trans-unit>
        <trans-unit id="604bbd841643b027a383acee66008e7977d1d958" translate="yes" xml:space="preserve">
          <source>For each element in &lt;code&gt;va&lt;/code&gt; computes cosine of the value of the element.</source>
          <target state="translated">Для каждого элемента в &lt;code&gt;va&lt;/code&gt; вычисляется косинус значения элемента.</target>
        </trans-unit>
        <trans-unit id="6f10323acc53f3b6e728d81bacf3f244188492b8" translate="yes" xml:space="preserve">
          <source>For each element in &lt;code&gt;va&lt;/code&gt; computes hyperbolic cosine of the value of the element.</source>
          <target state="translated">Для каждого элемента в &lt;code&gt;va&lt;/code&gt; вычисляется гиперболический косинус значения элемента.</target>
        </trans-unit>
        <trans-unit id="d1e0c67a77c4c9f3880463f9d8f3aa99bf732d31" translate="yes" xml:space="preserve">
          <source>For each element in &lt;code&gt;va&lt;/code&gt; computes hyperbolic sine of the value of the element.</source>
          <target state="translated">Для каждого элемента в &lt;code&gt;va&lt;/code&gt; вычисляется гиперболический синус значения элемента.</target>
        </trans-unit>
        <trans-unit id="fea32eb8ad9df99ec39e088fce28cbee17276c80" translate="yes" xml:space="preserve">
          <source>For each element in &lt;code&gt;va&lt;/code&gt; computes hyperbolic tangent of the value of the element.</source>
          <target state="translated">Для каждого элемента в &lt;code&gt;va&lt;/code&gt; вычисляется гиперболический тангенс значения элемента.</target>
        </trans-unit>
        <trans-unit id="cd3565d6513a55d7d6d649e63d9ef8dc096c132d" translate="yes" xml:space="preserve">
          <source>For each element in &lt;code&gt;va&lt;/code&gt; computes natural logarithm of the value of the element.</source>
          <target state="translated">Для каждого элемента в &lt;code&gt;va&lt;/code&gt; вычисляется натуральный логарифм значения элемента.</target>
        </trans-unit>
        <trans-unit id="8613519bb915be734bdb83ddf1139c1436d679c7" translate="yes" xml:space="preserve">
          <source>For each element in &lt;code&gt;va&lt;/code&gt; computes sine of the value of the element.</source>
          <target state="translated">Для каждого элемента в &lt;code&gt;va&lt;/code&gt; вычисляется синус значения элемента.</target>
        </trans-unit>
        <trans-unit id="16f2ed1e42028d25247c7e709cdd5ffa277bdfdc" translate="yes" xml:space="preserve">
          <source>For each element in &lt;code&gt;va&lt;/code&gt; computes tangent of the value of the element.</source>
          <target state="translated">Для каждого элемента в &lt;code&gt;va&lt;/code&gt; вычисляется тангенс значения элемента.</target>
        </trans-unit>
        <trans-unit id="2e8b5a06d41da5547ea77c34dce52624edf4f443" translate="yes" xml:space="preserve">
          <source>For each element in &lt;code&gt;va&lt;/code&gt; computes the square root of the value of the element.</source>
          <target state="translated">Для каждого элемента в &lt;code&gt;va&lt;/code&gt; вычисляется квадратный корень из значения элемента.</target>
        </trans-unit>
        <trans-unit id="de5098d9b31cace81235396b1ac2a117bb05f2f0" translate="yes" xml:space="preserve">
          <source>For each identifier, a variable whose type is &quot;reference to &lt;code&gt;&lt;a href=&quot;../utility/tuple/tuple_element&quot;&gt;std::tuple_element&lt;/a&gt;&amp;lt;i, E&amp;gt;::type&lt;/code&gt;&quot; is introduced: lvalue reference if its corresponding initializer is an lvalue, rvalue reference otherwise. The initializer for the i-th variable is.</source>
          <target state="translated">Для каждого идентификатора вводится переменная, тип которой &amp;laquo;ссылка на &lt;code&gt;&lt;a href=&quot;../utility/tuple/tuple_element&quot;&gt;std::tuple_element&lt;/a&gt;&amp;lt;i, E&amp;gt;::type&lt;/code&gt; &amp;raquo;: ссылка lvalue, если ее соответствующий инициализатор является lvalue, в противном случае ссылка rvalue. Инициализатором для i-й переменной является.</target>
        </trans-unit>
        <trans-unit id="e5405c9dfb873a374ff065f865a38e9ad5451317" translate="yes" xml:space="preserve">
          <source>For each non-explicit &lt;a href=&quot;cast_operator&quot;&gt;user-defined conversion function&lt;/a&gt; in &lt;code&gt;T&lt;/code&gt; or in a base of &lt;code&gt;T&lt;/code&gt; (unless hidden), whose cv-qualifiers is same or greater than &lt;code&gt;T&lt;/code&gt;'s cv-qualifiers, and where the conversion function converts to:</source>
          <target state="translated">Для каждой неявной &lt;a href=&quot;cast_operator&quot;&gt;пользовательской функции преобразования&lt;/a&gt; в &lt;code&gt;T&lt;/code&gt; или в базе &lt;code&gt;T&lt;/code&gt; (если не скрыто), чьи cv-квалификаторы такие же или больше, чем у cv-квалификаторов &lt;code&gt;T&lt;/code&gt; , и где функция преобразования преобразуется в:</target>
        </trans-unit>
        <trans-unit id="96919b66c472b53a5ced1aa599bee24bc87358ce" translate="yes" xml:space="preserve">
          <source>For each pair of viable function &lt;code&gt;F1&lt;/code&gt; and &lt;code&gt;F2&lt;/code&gt;, the implicit conversion sequences from the &lt;code&gt;i&lt;/code&gt;-th argument to &lt;code&gt;i&lt;/code&gt;-th parameter are ranked to determine which one is better (except the first argument, the</source>
          <target state="translated">Для каждой пары жизнеспособных функций &lt;code&gt;F1&lt;/code&gt; и &lt;code&gt;F2&lt;/code&gt; последовательности неявного преобразования из &lt;code&gt;i&lt;/code&gt; -го аргумента в &lt;code&gt;i&lt;/code&gt; -й параметр ранжируются, чтобы определить, какая из них лучше (кроме первого аргумента,</target>
        </trans-unit>
        <trans-unit id="077e83335df9a76882a31f009c6cc740f8436fb9" translate="yes" xml:space="preserve">
          <source>For each such match &lt;code&gt;m&lt;/code&gt;, copies the non-matched subsequence (&lt;a href=&quot;match_results/prefix&quot;&gt;&lt;code&gt;m.prefix()&lt;/code&gt;&lt;/a&gt;) into &lt;code&gt;out&lt;/code&gt; as if by &lt;code&gt;out = &lt;a href=&quot;../algorithm/copy&quot;&gt;std::copy&lt;/a&gt;(m.prefix().first, m.prefix().second, out)&lt;/code&gt; and then replaces the matched subsequence with the formatted replacement string as if by calling &lt;a href=&quot;match_results/format&quot;&gt;&lt;code&gt;out = m.format(out, fmt, flags)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Для каждого такого совпадения &lt;code&gt;m&lt;/code&gt; копирует &lt;a href=&quot;match_results/prefix&quot;&gt; &lt;code&gt;m.prefix()&lt;/code&gt; &lt;/a&gt; подпоследовательность ( m.prefix () ) в &lt;code&gt;out&lt;/code&gt; как бы с помощью &lt;code&gt;out = &lt;a href=&quot;../algorithm/copy&quot;&gt;std::copy&lt;/a&gt;(m.prefix().first, m.prefix().second, out)&lt;/code&gt; и затем заменяет совпавшую подпоследовательность отформатированной строкой замены, как будто вызывая &lt;a href=&quot;match_results/format&quot;&gt; &lt;code&gt;out = m.format(out, fmt, flags)&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="35a02408e3ec343aa382ddb9f4539b81b6f6a912" translate="yes" xml:space="preserve">
          <source>For each type, non-type, and template parameter, including parameter packs, a unique fictitious type, value, or template is generated and substituted into function type of the template</source>
          <target state="translated">Для каждого типа,не-типа и шаблонного параметра,включая пакеты параметров,генерируется уникальный фиктивный тип,значение или шаблон и подставляется в тип функции шаблона</target>
        </trans-unit>
        <trans-unit id="952fe468d5ee316980e589da22eb6018ea32e1cd" translate="yes" xml:space="preserve">
          <source>For equivalent elements in the original two ranges, the elements from the first range (preserving their original order) precede the elements from the second range (preserving their original order).</source>
          <target state="translated">Для эквивалентных элементов из двух исходных диапазонов,элементы из первого диапазона (с сохранением их исходного порядка)предшествуют элементам из второго диапазона (с сохранением их исходного порядка).</target>
        </trans-unit>
        <trans-unit id="f8bf46aa49e5e80eadcaac2f31ab62ee0b13bf20" translate="yes" xml:space="preserve">
          <source>For every &lt;code&gt;std::atomic&amp;lt;X&amp;gt;&lt;/code&gt; (whether or not specialized), &lt;code&gt;std::atomic&amp;lt;X&amp;gt;::value_type&lt;/code&gt; is &lt;code&gt;X&lt;/code&gt;.</source>
          <target state="translated">Для каждого &lt;code&gt;std::atomic&amp;lt;X&amp;gt;&lt;/code&gt; (или не специализировано), &lt;code&gt;std::atomic&amp;lt;X&amp;gt;::value_type&lt;/code&gt; есть &lt;code&gt;X&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="57dd021d134106ddd0d180af4fadda643026b891" translate="yes" xml:space="preserve">
          <source>For every &lt;code&gt;std::atomic_ref&amp;lt;X&amp;gt;&lt;/code&gt; (whether or not specialized), &lt;code&gt;std::atomic_ref&amp;lt;X&amp;gt;::value_type&lt;/code&gt; is &lt;code&gt;X&lt;/code&gt;.</source>
          <target state="translated">Для каждого &lt;code&gt;std::atomic_ref&amp;lt;X&amp;gt;&lt;/code&gt; (или не специализированы), &lt;code&gt;std::atomic_ref&amp;lt;X&amp;gt;::value_type&lt;/code&gt; есть &lt;code&gt;X&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e51dc104fca63d5103f9e0cf646aa86197a6c341" translate="yes" xml:space="preserve">
          <source>For every T that is a pointer-to-member type or the type &lt;code&gt;&lt;a href=&quot;../types/nullptr_t&quot;&gt;std::nullptr_t&lt;/a&gt;&lt;/code&gt;, the following function signature participates in overload resolution:</source>
          <target state="translated">Для каждого T, который является типом указателя на член или типом &lt;code&gt;&lt;a href=&quot;../types/nullptr_t&quot;&gt;std::nullptr_t&lt;/a&gt;&lt;/code&gt; , следующая сигнатура функции участвует в разрешении перегрузки:</target>
        </trans-unit>
        <trans-unit id="d6a1bb30012f8a1244f1eb8a6420656d9d6e09c6" translate="yes" xml:space="preserve">
          <source>For every conversion specifier other than &lt;code&gt;n&lt;/code&gt;, the longest sequence of input characters which does not exceed any speciﬁed ﬁeld width and which either is exactly what the conversion specifier expects or is a prefix of a sequence it would expect, is what's consumed from the stream. The ﬁrst character, if any, after this consumed sequence remains unread. If the consumed sequence has length zero or if the consumed sequence cannot be converted as specified above, the matching failure occurs unless end-of-ﬁle, an encoding error, or a read error prevented input from the stream, in which case it is an input failure.</source>
          <target state="translated">Для каждого спецификатора преобразования, отличного от &lt;code&gt;n&lt;/code&gt; , самая длинная последовательность входных символов, которая не превышает какой-либо заданной ширины поля и которая либо является именно тем, что ожидает спецификатор преобразования, либо является префиксом последовательности, которую он ожидал, - это то, что потребляется из потока. Первый символ, если он есть, после этой использованной последовательности остается непрочитанным. Если использованная последовательность имеет нулевую длину или если использованная последовательность не может быть преобразована, как указано выше, сбой сопоставления происходит, если только конец файла, ошибка кодирования или ошибка чтения не предотвратили ввод из потока, и в этом случае он является Ошибка входа.</target>
        </trans-unit>
        <trans-unit id="90c2546abb31c7caf07bad20c6eabba4b2fe603e" translate="yes" xml:space="preserve">
          <source>For every enumeration or pointer to member type &lt;code&gt;T&lt;/code&gt;, optionally volatile-qualified, the following function signature participates in overload resolution:</source>
          <target state="translated">Для каждого перечисления или указателя на тип члена &lt;code&gt;T&lt;/code&gt; , необязательно квалифицированного volatile, в разрешении перегрузки участвует следующая сигнатура функции:</target>
        </trans-unit>
        <trans-unit id="88970b9a9ff96606e8a48b4759fd878eb0266d29" translate="yes" xml:space="preserve">
          <source>For every iterator type &lt;code&gt;It&lt;/code&gt;, a typedef &lt;code&gt;&lt;a href=&quot;iterator_traits&quot;&gt;std::iterator_traits&lt;/a&gt;&amp;lt;It&amp;gt;::iterator_category&lt;/code&gt; is available, which is an alias to one of these five(until C++20)six(since C++20) tag types.</source>
          <target state="translated">Для каждого типа итератор &lt;code&gt;It&lt;/code&gt; , ЬурейеЕ &lt;code&gt;&lt;a href=&quot;iterator_traits&quot;&gt;std::iterator_traits&lt;/a&gt;&amp;lt;It&amp;gt;::iterator_category&lt;/code&gt; доступен, который является псевдонимом для одного из этих пяти (до C ++ 20) шесть (с C ++ 20) типов тегов.</target>
        </trans-unit>
        <trans-unit id="e71c9303eec62288eff7b54439f77781e36bc155" translate="yes" xml:space="preserve">
          <source>For every optionally cv-qualified object type &lt;code&gt;T&lt;/code&gt;, the following function signatures participate in overload resolution:</source>
          <target state="translated">Для каждого необязательного cv-квалифицированного типа объекта &lt;code&gt;T&lt;/code&gt; в разрешении перегрузки участвуют следующие сигнатуры функций:</target>
        </trans-unit>
        <trans-unit id="96c0842f465784a49ab8d68561798db17053d280" translate="yes" xml:space="preserve">
          <source>For every pair A1 and A2, where A1 is an arithmetic type (optionally volatile-qualified) and A2 is a promoted arithmetic type, the following function signature participates in overload resolution:</source>
          <target state="translated">Для каждой пары A1 и A2,где A1-арифметический тип (опционально volatile-qualified),а A2-продвинутый арифметический тип,в разрешении перегрузки участвует следующая сигнатура функции:</target>
        </trans-unit>
        <trans-unit id="20e473aa5e7c31193000e4e17752d2e9b84efea5" translate="yes" xml:space="preserve">
          <source>For every pair I1 and I2, where I1 is an integral type (optionally volatile-qualified) and I2 is a promoted integral type, the following function signatures participate in overload resolution:</source>
          <target state="translated">Для каждой пары I1 и I2,где I1 является интегральным типом (опционально volatile-qualified),а I2-раскрученным интегральным типом,в разрешении перегрузки участвуют следующие функциональные сигнатуры:</target>
        </trans-unit>
        <trans-unit id="fef8c5eb5bd67258e2ec4544fa11f3c0a8bfa352" translate="yes" xml:space="preserve">
          <source>For every pair of promoted arithmetic types L and R and for every type P, where P is a pointer, pointer-to-member, or scoped enumeration type, the following function signatures participate in the overload resolution performed in step 5 of the rules above:</source>
          <target state="translated">Для каждой пары раскрученных арифметических типов L и R и для каждого типа P,где P является указателем,указателем на члена или scoped перечисленным типом перечисления,в разрешении перегрузки,выполненном на шаге 5 правил выше,участвуют следующие сигнатуры функции:</target>
        </trans-unit>
        <trans-unit id="d638c80e090b37ee12468ee54f0147dce03100fb" translate="yes" xml:space="preserve">
          <source>For every parameter in params whose type is specified as &lt;code&gt;auto&lt;/code&gt;, an invented template parameter is added to template-params, in order of appearance. The invented template parameter may be a &lt;a href=&quot;parameter_pack&quot;&gt;parameter pack&lt;/a&gt; if the corresponding function member of params is a function parameter pack.</source>
          <target state="translated">Для каждого параметра в параметрах, тип которого указан как &lt;code&gt;auto&lt;/code&gt; , в шаблон-параметры добавляется изобретенный параметр шаблона в порядке появления. Изобретенный параметр шаблона может быть &lt;a href=&quot;parameter_pack&quot;&gt;пакетом параметров,&lt;/a&gt; если соответствующий элемент функции params является пакетом параметров функции.</target>
        </trans-unit>
        <trans-unit id="859f56c75df09c6419c76fcbdbe8ae8dbb4f8aed" translate="yes" xml:space="preserve">
          <source>For every type &lt;code&gt;MP&lt;/code&gt; that is a pointer to member object or pointer to member function or &lt;code&gt;&lt;a href=&quot;../types/nullptr_t&quot;&gt;std::nullptr_t&lt;/a&gt;&lt;/code&gt;, the following function signatures participate in overload resolution:</source>
          <target state="translated">Для каждого типа &lt;code&gt;MP&lt;/code&gt; , который является указателем на объект-член или указателем на функцию-член или &lt;code&gt;&lt;a href=&quot;../types/nullptr_t&quot;&gt;std::nullptr_t&lt;/a&gt;&lt;/code&gt; , следующие сигнатуры функций участвуют в разрешении перегрузки:</target>
        </trans-unit>
        <trans-unit id="5ba25517699790e207bae588adda9d67eb82eb32" translate="yes" xml:space="preserve">
          <source>For every type &lt;code&gt;P&lt;/code&gt; which is either pointer to object or pointer to function or &lt;code&gt;&lt;a href=&quot;../types/nullptr_t&quot;&gt;std::nullptr_t&lt;/a&gt;&lt;/code&gt;(until C++14), the following function signatures participate in overload resolution:</source>
          <target state="translated">Для каждого типа &lt;code&gt;P&lt;/code&gt; , который является либо указателем на объект, либо указателем на функцию или &lt;code&gt;&lt;a href=&quot;../types/nullptr_t&quot;&gt;std::nullptr_t&lt;/a&gt;&lt;/code&gt; (до C ++ 14), следующие сигнатуры функций участвуют в разрешении перегрузки:</target>
        </trans-unit>
        <trans-unit id="ee4a3f0b05542f01bd799b3b751f77169b8294dd" translate="yes" xml:space="preserve">
          <source>For every type other than reference and function, the type system supports three additional &lt;a href=&quot;cv&quot;&gt;cv-qualified versions&lt;/a&gt; of that type (&lt;code&gt;const&lt;/code&gt;, &lt;code&gt;volatile&lt;/code&gt;, and &lt;code&gt;const volatile&lt;/code&gt;).</source>
          <target state="translated">Для каждого типа, кроме ссылки и функции, система типов поддерживает три дополнительные &lt;a href=&quot;cv&quot;&gt;cv-квалифицированные версии&lt;/a&gt; этого типа ( &lt;code&gt;const&lt;/code&gt; , &lt;code&gt;volatile&lt;/code&gt; и &lt;code&gt;const volatile&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="ba768967270bb243200289babda957e1dccea676" translate="yes" xml:space="preserve">
          <source>For every valid value of &lt;code&gt;char_type&lt;/code&gt;, there must be a unique value of &lt;code&gt;int_type&lt;/code&gt; distinct from &lt;code&gt;eof()&lt;/code&gt;. For example, a common implementation of &lt;code&gt;char_traits&amp;lt;char&amp;gt;::eof()&lt;/code&gt; is &lt;code&gt;return -1&lt;/code&gt;, and a corresponding valid implementation of &lt;code&gt;char_traits&amp;lt;char&amp;gt;::to_int_type(c)&lt;/code&gt; is &lt;code&gt;return (unsigned char)c&lt;/code&gt;.</source>
          <target state="translated">Для каждого допустимого значения &lt;code&gt;char_type&lt;/code&gt; должно быть уникальное значение &lt;code&gt;int_type&lt;/code&gt; , отличное от &lt;code&gt;eof()&lt;/code&gt; . Например, общая реализация &lt;code&gt;char_traits&amp;lt;char&amp;gt;::eof()&lt;/code&gt; - это &lt;code&gt;return -1&lt;/code&gt; , а соответствующая правильная реализация &lt;code&gt;char_traits&amp;lt;char&amp;gt;::to_int_type(c)&lt;/code&gt; - это &lt;code&gt;return (unsigned char)c&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="220aba5bf092ed62052a3a23de11e863b192c055" translate="yes" xml:space="preserve">
          <source>For every virtual function, there is the</source>
          <target state="translated">Для каждой виртуальной функции есть</target>
        </trans-unit>
        <trans-unit id="96405e325a2957f41ae4e0cb514953a5e216ba60" translate="yes" xml:space="preserve">
          <source>For example when the regex flag &lt;code&gt;&lt;a href=&quot;../syntax_option_type&quot;&gt;std::regex_constants::collate&lt;/a&gt;&lt;/code&gt; is set, then the sequence &lt;code&gt;[a-b]&lt;/code&gt; would match some character &lt;code&gt;c1&lt;/code&gt; if &lt;code&gt;traits.transform(&quot;a&quot;) &amp;lt;= traits.transform(c1) &amp;lt;= traits.transform(&quot;b&quot;)&lt;/code&gt;. Note that this function takes a character sequence as the argument to accomodate to the ranges defined like &lt;code&gt;[&lt;/code&gt;&lt;code&gt;[.ae.]-d]&lt;/code&gt;.</source>
          <target state="translated">Например, когда установлен флаг regex &lt;code&gt;&lt;a href=&quot;../syntax_option_type&quot;&gt;std::regex_constants::collate&lt;/a&gt;&lt;/code&gt; , последовательность &lt;code&gt;[a-b]&lt;/code&gt; будет соответствовать некоторому символу &lt;code&gt;c1&lt;/code&gt; , если &lt;code&gt;traits.transform(&quot;a&quot;) &amp;lt;= traits.transform(c1) &amp;lt;= traits.transform(&quot;b&quot;)&lt;/code&gt; . Обратите внимание, что эта функция принимает последовательность символов в качестве аргумента для согласования с диапазонами, определенными как &lt;code&gt;[&lt;/code&gt; &lt;code&gt;[.ae.]-d]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6db6725e9e7d5c088630e348048d1e73fc7657d3" translate="yes" xml:space="preserve">
          <source>For example,</source>
          <target state="translated">Например,</target>
        </trans-unit>
        <trans-unit id="21afdf58d530130e0cd1ecfb369c10eeeccc97f9" translate="yes" xml:space="preserve">
          <source>For example, &lt;code&gt;int b:3;&lt;/code&gt; may have the range of values &lt;code&gt;0..7&lt;/code&gt; or &lt;code&gt;-4..3&lt;/code&gt;.</source>
          <target state="translated">Например, &lt;code&gt;int b:3;&lt;/code&gt; может иметь диапазон значений &lt;code&gt;0..7&lt;/code&gt; или &lt;code&gt;-4..3&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b7d231fa0de4c53b5a41ff143b9ff0bc463fe738" translate="yes" xml:space="preserve">
          <source>For example, a gslice with starting index &lt;code&gt;3&lt;/code&gt;, strides &lt;code&gt;{19,4,1&lt;/code&gt;} and lengths &lt;code&gt;{2,4,3} &lt;/code&gt; generates the following set of indices:</source>
          <target state="translated">Например, gslice с начальным индексом &lt;code&gt;3&lt;/code&gt; , шагами &lt;code&gt;{19,4,1&lt;/code&gt; } и длинами &lt;code&gt;{2,4,3} &lt;/code&gt; генерирует следующий набор индексов:</target>
        </trans-unit>
        <trans-unit id="b98b27a6a16bb9a7bf0282ec3a82d51ac5557fa2" translate="yes" xml:space="preserve">
          <source>For example, given &lt;code&gt;const auto&amp;amp; i = expr;&lt;/code&gt;, the type of &lt;code&gt;i&lt;/code&gt; is exactly the type of the argument &lt;code&gt;u&lt;/code&gt; in an imaginary template &lt;code&gt;template&amp;lt;class U&amp;gt; void f(const U&amp;amp; u)&lt;/code&gt; if the function call &lt;code&gt;f(expr)&lt;/code&gt; was compiled. Therefore, &lt;code&gt;auto&amp;amp;&amp;amp;&lt;/code&gt; may be deduced either as an lvalue reference or rvalue reference according to the initializer, which is used in range-based for loop.</source>
          <target state="translated">Например, если задано &lt;code&gt;const auto&amp;amp; i = expr;&lt;/code&gt; тип &lt;code&gt;i&lt;/code&gt; - это тип аргумента &lt;code&gt;u&lt;/code&gt; в воображаемом шаблоне &lt;code&gt;template&amp;lt;class U&amp;gt; void f(const U&amp;amp; u)&lt;/code&gt; если вызов функции &lt;code&gt;f(expr)&lt;/code&gt; был скомпилирован. Следовательно, &lt;code&gt;auto&amp;amp;&amp;amp;&lt;/code&gt; может быть выведено либо как ссылка lvalue, либо как ссылка rvalue в соответствии с инициализатором, который используется в цикле for на основе диапазона.</target>
        </trans-unit>
        <trans-unit id="b64fbd2e8414cb52362895b9416d02f046ec2ac9" translate="yes" xml:space="preserve">
          <source>For example, if a wrapper does not just forward its argument, but calls a member function on the argument, and forwards its result:</source>
          <target state="translated">Например,если обертка не просто пересылает свой аргумент,а вызывает функцию-член по аргументу и пересылает его результат:</target>
        </trans-unit>
        <trans-unit id="3ad08d76cd3366adf2e4002a2a86eba860f92547" translate="yes" xml:space="preserve">
          <source>For example, if used in wrapper such as the following, the template behaves as described below:</source>
          <target state="translated">Например,при использовании в обертке,как показано ниже,шаблон ведет себя так,как описано ниже:</target>
        </trans-unit>
        <trans-unit id="17f92461460ba9421050f5a120102adab4bd7d16" translate="yes" xml:space="preserve">
          <source>For example, in:</source>
          <target state="translated">Например,в:</target>
        </trans-unit>
        <trans-unit id="8f787b27b81522ff7994a2b1d11b99ed11a43f0f" translate="yes" xml:space="preserve">
          <source>For example, on Windows, where &lt;code&gt;\&lt;/code&gt; is the preferred separator, the path &lt;code&gt;foo/bar&lt;/code&gt; will be converted to &lt;code&gt;foo\bar&lt;/code&gt;.</source>
          <target state="translated">Например, в Windows, где &lt;code&gt;\&lt;/code&gt; является предпочтительным разделителем, путь &lt;code&gt;foo/bar&lt;/code&gt; будет преобразован в &lt;code&gt;foo\bar&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c80798c74b99761f9f8d6a1d7f496bb6f7e553ba" translate="yes" xml:space="preserve">
          <source>For example, on some platforms, bit fields don't straddle bytes, on others they do</source>
          <target state="translated">Например,на некоторых платформах битовые поля не распределяются по байтам,на других они распределяются</target>
        </trans-unit>
        <trans-unit id="e2df7d9cb75dfece63f96a9945f6d4796b35277d" translate="yes" xml:space="preserve">
          <source>For example, the composite pointer type of &lt;code&gt;void*&lt;/code&gt; and &lt;code&gt;const int*&lt;/code&gt; is &lt;code&gt;const void*&lt;/code&gt;. The composite pointer type of &lt;code&gt;int**&lt;/code&gt; and &lt;code&gt;const int**&lt;/code&gt; is &lt;code&gt;const int* const*&lt;/code&gt;. Note that until C++14, &lt;code&gt;int**&lt;/code&gt; and &lt;code&gt;const int**&lt;/code&gt; could not be compared.</source>
          <target state="translated">Например, составной указатель типа &lt;code&gt;void*&lt;/code&gt; и &lt;code&gt;const int*&lt;/code&gt; является &lt;code&gt;const void*&lt;/code&gt; . Тип составного указателя &lt;code&gt;int**&lt;/code&gt; и &lt;code&gt;const int**&lt;/code&gt; - это &lt;code&gt;const int* const*&lt;/code&gt; . Обратите внимание, что до C ++ 14 нельзя сравнивать &lt;code&gt;int**&lt;/code&gt; и &lt;code&gt;const int**&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="62bb742426a794f8be0f5a25a2d2f7632ae88b7a" translate="yes" xml:space="preserve">
          <source>For example, the following class template does not use the type T in its private members or in the body of push_back.</source>
          <target state="translated">Например,следующий шаблон класса не использует тип T в своих приватных членах или в теле push_back.</target>
        </trans-unit>
        <trans-unit id="9c6f9185eeed0381f9dd1d89f296fbc5ee5be5b1" translate="yes" xml:space="preserve">
          <source>For example, to compile &lt;code&gt;&lt;a href=&quot;../io/cout&quot;&gt;std::cout&lt;/a&gt; &amp;lt;&amp;lt; &lt;a href=&quot;../io/manip/endl&quot;&gt;std::endl&lt;/a&gt;;&lt;/code&gt;, the compiler performs:</source>
          <target state="translated">Например, для компиляции &lt;code&gt;&lt;a href=&quot;../io/cout&quot;&gt;std::cout&lt;/a&gt; &amp;lt;&amp;lt; &lt;a href=&quot;../io/manip/endl&quot;&gt;std::endl&lt;/a&gt;;&lt;/code&gt; Компилятор выполняет:</target>
        </trans-unit>
        <trans-unit id="9d4b3358e1df9f2bea37a27eaa5e14ffa2bc6778" translate="yes" xml:space="preserve">
          <source>For example, with &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; initially zero,</source>
          <target state="translated">Например, с &lt;code&gt;x&lt;/code&gt; и &lt;code&gt;y&lt;/code&gt; изначально ноль,</target>
        </trans-unit>
        <trans-unit id="059c3e8cce263b2945a18ac90b2637e10a8026b1" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">Например:</target>
        </trans-unit>
        <trans-unit id="f2cbbd695a1dfd1a4a615d31b844bf65755121de" translate="yes" xml:space="preserve">
          <source>For floating-point &amp;alpha;, the value obtained is the sum of &amp;alpha; independent exponentially distributed random variables, each of which has a mean of &amp;beta;</source>
          <target state="translated">Для числа с плавающей точкой полученное значение представляет собой сумму независимых независимых экспоненциально распределенных случайных величин, каждая из которых имеет среднее значение &amp;beta;</target>
        </trans-unit>
        <trans-unit id="37bba3e4eccd73e2ef72c749ab8c25e15efc6e60" translate="yes" xml:space="preserve">
          <source>For floating-point types with denormalization, &lt;code&gt;min&lt;/code&gt; returns the minimum positive normalized value.</source>
          <target state="translated">Для типов с плавающей точкой с денормализацией &lt;code&gt;min&lt;/code&gt; возвращает минимальное положительное нормализованное значение.</target>
        </trans-unit>
        <trans-unit id="b593b953b77c2c511c9c9e8acca67b444d03c30c" translate="yes" xml:space="preserve">
          <source>For floating-point types, if &lt;code&gt;showpoint&lt;/code&gt; is set, the modifier &lt;code&gt;#&lt;/code&gt; is prepended.</source>
          <target state="translated">Для типов с плавающей точкой, если установлена точка &lt;code&gt;showpoint&lt;/code&gt; , добавляется модификатор &lt;code&gt;#&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="52fff2d809b2cb152e5b4a1ad6291720dc27d5c1" translate="yes" xml:space="preserve">
          <source>For floating-point types, the &lt;a href=&quot;../../numeric/fenv&quot;&gt;floating-point environment&lt;/a&gt; in effect may be different from the calling thread's floating-point environment. The operation need not be conform to the corresponding &lt;code&gt;&lt;a href=&quot;../../types/numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&lt;/code&gt; traits but is encouraged to do so. If the result is not a representable value for its type, the result is unspecified but the operation otherwise has no undefined behavior.</source>
          <target state="translated">Для типов с &lt;a href=&quot;../../numeric/fenv&quot;&gt;плавающей точкой&lt;/a&gt; действующая среда с плавающей точкой может отличаться от среды с плавающей точкой вызывающего потока. Операция не обязательно должна соответствовать соответствующим признакам &lt;code&gt;&lt;a href=&quot;../../types/numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&lt;/code&gt; но рекомендуется делать это. Если результат не является представимым значением для своего типа, результат не определен, но в противном случае операция не имеет неопределенного поведения.</target>
        </trans-unit>
        <trans-unit id="5ab94c8e0b590e7f556887eaae16aec44908d571" translate="yes" xml:space="preserve">
          <source>For function and function template names, name lookup can associate multiple declarations with the same name, and may obtain additional declarations from &lt;a href=&quot;adl&quot;&gt;argument-dependent lookup&lt;/a&gt;. &lt;a href=&quot;function_template&quot;&gt;Template argument deduction&lt;/a&gt; may also apply, and the set of declarations is passed to &lt;a href=&quot;overload_resolution&quot;&gt;overload resolution&lt;/a&gt;, which selects the declaration that will be used. &lt;a href=&quot;access&quot;&gt;Member access&lt;/a&gt; rules, if applicable, are considered only after name lookup and overload resolution.</source>
          <target state="translated">Для имен функций и шаблонов функций поиск по имени может связывать несколько объявлений с одним и тем же именем и может получать дополнительные объявления из &lt;a href=&quot;adl&quot;&gt;поиска, зависящего&lt;/a&gt; от аргумента . Может также применяться &lt;a href=&quot;function_template&quot;&gt;вывод аргументов шаблона&lt;/a&gt; , и набор объявлений передается для &lt;a href=&quot;overload_resolution&quot;&gt;разрешения перегрузки&lt;/a&gt; , которое выбирает объявление, которое будет использоваться. Правила &lt;a href=&quot;access&quot;&gt;доступа членов&lt;/a&gt; , если они применимы, рассматриваются только после поиска имени и разрешения перегрузки.</target>
        </trans-unit>
        <trans-unit id="36d9c94cd9c3cc36a9b671f755d250722c29f111" translate="yes" xml:space="preserve">
          <source>For functions, specifies that the return type will be deduced from its return statements.</source>
          <target state="translated">Для функций указывает,что тип возврата будет вычитаться из его отчётов о возврате.</target>
        </trans-unit>
        <trans-unit id="f9d92b090fe79a87f7ef3997de21c665c200fc40" translate="yes" xml:space="preserve">
          <source>For initialization of locals (that is, block scope) static and thread-local variables, see &lt;a href=&quot;storage_duration#Static_local_variables&quot;&gt;static local variables&lt;/a&gt;.</source>
          <target state="translated">Для инициализации локальных (то есть, области блока) статических и локальных переменных потока см. &lt;a href=&quot;storage_duration#Static_local_variables&quot;&gt;Статические локальные переменные&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ac4327b8179e23975065e9af7bd05ec6be15b5bc" translate="yes" xml:space="preserve">
          <source>For input streams (&lt;code&gt;mode &amp;amp; ios_base::in == true&lt;/code&gt;), &lt;code&gt;eback()&lt;/code&gt; points at the first character, &lt;code&gt;gptr() == eback()&lt;/code&gt;, and &lt;code&gt;egptr() == eback() + s.size()&lt;/code&gt;: the subsequent input will read the first character copied from &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="translated">Для входных потоков ( &lt;code&gt;mode &amp;amp; ios_base::in == true&lt;/code&gt; ) &lt;code&gt;eback()&lt;/code&gt; указывает на первый символ, &lt;code&gt;gptr() == eback()&lt;/code&gt; и &lt;code&gt;egptr() == eback() + s.size()&lt;/code&gt; : последующий ввод будет читать первый символ, скопированный из &lt;code&gt;s&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ec3905377a1c94d495d985035e68f7411ea9980d" translate="yes" xml:space="preserve">
          <source>For input streams (and for update streams on which the last operation was input), the behavior is undefined.</source>
          <target state="translated">Для потоков ввода (и для потоков обновления,для которых была введена последняя операция)поведение не определено.</target>
        </trans-unit>
        <trans-unit id="3263d60841f8b602b9cc58bd2747c0e72fde62e4" translate="yes" xml:space="preserve">
          <source>For integer &lt;code&gt;arg&lt;/code&gt;, the binary logarithm can be interpreted as the zero-based index of the most significant 1 bit in the input.</source>
          <target state="translated">Для целочисленного &lt;code&gt;arg&lt;/code&gt; двоичный логарифм можно интерпретировать как индекс, начинающийся с нуля, наиболее значимого 1 бита на входе.</target>
        </trans-unit>
        <trans-unit id="ed5f0c55df7482886d0bbb61dde66b50525bc79d" translate="yes" xml:space="preserve">
          <source>For integer types, if &lt;code&gt;showbase&lt;/code&gt; is set, the modifier &lt;code&gt;#&lt;/code&gt; is prepended.</source>
          <target state="translated">Для целочисленных типов, если установлена &lt;code&gt;showbase&lt;/code&gt; , добавляется модификатор &lt;code&gt;#&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cf8479d95c472194fb01daf6a842e55ed66b89af" translate="yes" xml:space="preserve">
          <source>For integer types, length modifier is added to the conversion specification if necessary: &lt;code&gt;h&lt;/code&gt; for &lt;code&gt;short&lt;/code&gt; and &lt;code&gt;unsigned short&lt;/code&gt;, &lt;code&gt;l&lt;/code&gt; for &lt;code&gt;long&lt;/code&gt; and &lt;code&gt;unsigned long&lt;/code&gt;, &lt;code&gt;ll&lt;/code&gt; for &lt;code&gt;long long&lt;/code&gt; and &lt;code&gt;unsigned long long&lt;/code&gt;</source>
          <target state="translated">Для целочисленных типов модификатор длины добавляется в спецификацию преобразования при необходимости: &lt;code&gt;h&lt;/code&gt; для &lt;code&gt;short&lt;/code&gt; и &lt;code&gt;unsigned short&lt;/code&gt; , &lt;code&gt;l&lt;/code&gt; для &lt;code&gt;long&lt;/code&gt; и &lt;code&gt;unsigned long&lt;/code&gt; , &lt;code&gt;ll&lt;/code&gt; для &lt;code&gt;long long&lt;/code&gt; и &lt;code&gt;unsigned long long&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6101d794e56d2d1f4f0a50cfba90d4442ea8210d" translate="yes" xml:space="preserve">
          <source>For integer types, length modifier is added to the conversion specification if necessary: &lt;code&gt;l&lt;/code&gt; for &lt;code&gt;long&lt;/code&gt; and &lt;code&gt;unsigned long&lt;/code&gt;, &lt;code&gt;ll&lt;/code&gt; for &lt;code&gt;long long&lt;/code&gt; and &lt;code&gt;unsigned long long&lt;/code&gt;(since C++11).</source>
          <target state="translated">Для целочисленных типов модификатор длины добавляется в спецификацию преобразования при необходимости: &lt;code&gt;l&lt;/code&gt; для &lt;code&gt;long&lt;/code&gt; и &lt;code&gt;unsigned long&lt;/code&gt; , &lt;code&gt;ll&lt;/code&gt; для &lt;code&gt;long long&lt;/code&gt; и &lt;code&gt;unsigned long long&lt;/code&gt; (начиная с C ++ 11).</target>
        </trans-unit>
        <trans-unit id="9635f0a469e86775a961c9f4f06c2d75d2ad2838" translate="yes" xml:space="preserve">
          <source>For integral and arithmetic types, the template argument provided during instantiation must be a &lt;a href=&quot;constant_expression&quot;&gt;converted constant expression&lt;/a&gt; of the template parameter's type (so certain implicit conversion applies).</source>
          <target state="translated">Для целочисленных и арифметических типов аргумент шаблона, предоставляемый во время создания экземпляра, должен быть &lt;a href=&quot;constant_expression&quot;&gt;преобразованным константным выражением&lt;/a&gt; типа параметра шаблона (поэтому применяется определенное неявное преобразование).</target>
        </trans-unit>
        <trans-unit id="888e66ad3cd1de9e2997f82859b81050f3f98936" translate="yes" xml:space="preserve">
          <source>For integral arguments, &lt;a href=&quot;abs&quot;&gt;the integral overloads of &lt;code&gt;std::abs&lt;/code&gt;&lt;/a&gt; are likely better matches. If &lt;code&gt;std::abs&lt;/code&gt; is called with an argument of type &lt;code&gt;X&lt;/code&gt; such that &lt;code&gt;&lt;a href=&quot;../../types/is_unsigned&quot;&gt;std::is_unsigned&lt;/a&gt;&amp;lt;X&amp;gt;::value&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; and &lt;code&gt;X&lt;/code&gt; cannot be converted to &lt;code&gt;int&lt;/code&gt; by &lt;a href=&quot;../../language/implicit_cast#Integral_promotion&quot;&gt;integral promotion&lt;/a&gt;, the program is ill-formed.</source>
          <target state="translated">Для целочисленных аргументов &lt;a href=&quot;abs&quot;&gt;интегральные перегрузки &lt;code&gt;std::abs&lt;/code&gt; &lt;/a&gt; , вероятно, лучше соответствуют. Если &lt;code&gt;std::abs&lt;/code&gt; вызывается с аргументом типа &lt;code&gt;X&lt;/code&gt; , таким образом, что &lt;code&gt;&lt;a href=&quot;../../types/is_unsigned&quot;&gt;std::is_unsigned&lt;/a&gt;&amp;lt;X&amp;gt;::value&lt;/code&gt; имеет значение &lt;code&gt;true&lt;/code&gt; , и &lt;code&gt;X&lt;/code&gt; не может быть преобразован в &lt;code&gt;int&lt;/code&gt; путем &lt;a href=&quot;../../language/implicit_cast#Integral_promotion&quot;&gt;интегрального продвижения&lt;/a&gt; , программа является некорректной.</target>
        </trans-unit>
        <trans-unit id="1060ee889330db82947214695c2314922ae38003" translate="yes" xml:space="preserve">
          <source>For integral operands, it yields the algebraic quotient.</source>
          <target state="translated">Для интегральных операндов она дает алгебраический коэффициент.</target>
        </trans-unit>
        <trans-unit id="88259ad2a8442b91aaef00f672b4f16ecba02e17" translate="yes" xml:space="preserve">
          <source>For lvalue reference parameters, the argument provided at instantiation cannot be a temporary, an unnamed lvalue, or a named lvalue with no linkage (in other words, the argument must have linkage).</source>
          <target state="translated">Для ссылочных параметров lvalue аргумент,приводимый при инстанциировании,не может быть временным,безымянным значением lvalue или именованным значением lvalue без связи (другими словами,аргумент должен иметь связь).</target>
        </trans-unit>
        <trans-unit id="07ec985082848563aa89c0c13f4926e059b3c9cc" translate="yes" xml:space="preserve">
          <source>For member functions of class &lt;code&gt;X&lt;/code&gt;, the type of the implicit object parameter is affected by cv-qualifications and ref-qualifications of the member function as described in &lt;a href=&quot;member_functions&quot;&gt;member functions&lt;/a&gt;.</source>
          <target state="translated">Для функций-членов класса &lt;code&gt;X&lt;/code&gt; на тип неявного параметра объекта влияют cv-квалификации и реф-квалификации функции-члена, как описано в &lt;a href=&quot;member_functions&quot;&gt;функциях-членах&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="19791e90c11ccaf6d487d6bb230d6565f3784cc4" translate="yes" xml:space="preserve">
          <source>For most &lt;code&gt;z&lt;/code&gt;, &lt;code&gt;std::proj(z)==z&lt;/code&gt;, but all complex infinities, even the numbers where one component is infinite and the other is NaN, become positive real infinity, &lt;code&gt;(&lt;a href=&quot;../math/infinity&quot;&gt;INFINITY&lt;/a&gt;, 0)&lt;/code&gt; or &lt;code&gt;(&lt;a href=&quot;../math/infinity&quot;&gt;INFINITY&lt;/a&gt;, -0)&lt;/code&gt;. The sign of the imaginary (zero) component is the sign of &lt;code&gt;&lt;a href=&quot;imag2&quot;&gt;std::imag&lt;/a&gt;(z)&lt;/code&gt;.</source>
          <target state="translated">Для большинства &lt;code&gt;z&lt;/code&gt; , &lt;code&gt;std::proj(z)==z&lt;/code&gt; , но все сложные бесконечности, даже номера , где один компонент является бесконечным , а другим является NaN, становится положительной реальной бесконечность, &lt;code&gt;(&lt;a href=&quot;../math/infinity&quot;&gt;INFINITY&lt;/a&gt;, 0)&lt;/code&gt; или &lt;code&gt;(&lt;a href=&quot;../math/infinity&quot;&gt;INFINITY&lt;/a&gt;, -0)&lt;/code&gt; . Знак мнимой (нулевой) составляющей является знаком &lt;code&gt;&lt;a href=&quot;imag2&quot;&gt;std::imag&lt;/a&gt;(z)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="dedc12147e0e26b892c9c3c4c65e52f5512feb4a" translate="yes" xml:space="preserve">
          <source>For multi-level pointers, the following restrictions apply: a multilevel pointer &lt;code&gt;P1&lt;/code&gt; which is cv1</source>
          <target state="translated">Для многоуровневых указателей применяются следующие ограничения: многоуровневый указатель &lt;code&gt;P1&lt;/code&gt; , который является cv1</target>
        </trans-unit>
        <trans-unit id="376ecc03409163c2995d77d8d27738cf7cb39e45" translate="yes" xml:space="preserve">
          <source>For negative &lt;code&gt;a&lt;/code&gt;, the behavior of &lt;code&gt;a &amp;lt;&amp;lt; b&lt;/code&gt; is undefined.</source>
          <target state="translated">Для отрицательного &lt;code&gt;a&lt;/code&gt; поведение &lt;code&gt;a &amp;lt;&amp;lt; b&lt;/code&gt; не определено.</target>
        </trans-unit>
        <trans-unit id="1494de8919bb1c4ea96591e8c652173df74c133c" translate="yes" xml:space="preserve">
          <source>For negative &lt;code&gt;a&lt;/code&gt;, the value of &lt;code&gt;a &amp;gt;&amp;gt; b&lt;/code&gt; is implementation-defined (in most implementations, this performs arithmetic right shift, so that the result remains negative).</source>
          <target state="translated">При отрицательном &lt;code&gt;a&lt;/code&gt; , значение &lt;code&gt;a &amp;gt;&amp;gt; b&lt;/code&gt; зависит от реализации (в большинстве реализаций, это выполняет арифметический сдвиг вправо, так что результат остается отрицательный).</target>
        </trans-unit>
        <trans-unit id="8d245548c2af614dd2b79e9d581bbfee18630af5" translate="yes" xml:space="preserve">
          <source>For non-&lt;a href=&quot;union&quot;&gt;union&lt;/a&gt; class types, members with the same &lt;a href=&quot;access&quot;&gt;member access&lt;/a&gt; are always allocated so that the members declared later have higher addresses within a class object. Members with different access control are allocated in unspecified order (the compiler may group them together). Alignment requirements may necessitate padding between members, or after the last member of a class.</source>
          <target state="translated">Для типов классов, не относящихся к &lt;a href=&quot;union&quot;&gt;объединению&lt;/a&gt; , члены с одинаковым &lt;a href=&quot;access&quot;&gt;доступом&lt;/a&gt; к членам всегда выделяются таким образом, чтобы объявленные позже члены имели более высокие адреса в объекте класса. Члены с разным контролем доступа распределяются в неуказанном порядке (компилятор может группировать их вместе). Требования выравнивания могут потребовать дополнения между членами или после последнего члена класса.</target>
        </trans-unit>
        <trans-unit id="9b6b58d70b3d593d4d88872f97e32d333db88729" translate="yes" xml:space="preserve">
          <source>For non-appending output streams, &lt;code&gt;pptr() == pbase()&lt;/code&gt;, so that subsequent output will overwrite the characters copied from &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="translated">Для не &lt;code&gt;pptr() == pbase()&lt;/code&gt; потоков вывода pptr () == pbase () , так что при последующем выводе будут перезаписаны символы, скопированные из &lt;code&gt;s&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="606fb425d7d848cb68effbf7891839f3901900f6" translate="yes" xml:space="preserve">
          <source>For non-array &lt;code&gt;type&lt;/code&gt;, the single object is constructed in the acquired memory area.</source>
          <target state="translated">Для не массивного &lt;code&gt;type&lt;/code&gt; единственный объект создается в полученной области памяти.</target>
        </trans-unit>
        <trans-unit id="2e50302a0b35323ade517a1a99cf0e861fd9f2ad" translate="yes" xml:space="preserve">
          <source>For non-class types, copy and move assignment are indistinguishable and are referred to as</source>
          <target state="translated">Для типов,не относящихся к классу,назначение копирования и перемещения неразличимо и называется</target>
        </trans-unit>
        <trans-unit id="961645d5c1ea45b10c1dab6cd681b33d3b3e7623" translate="yes" xml:space="preserve">
          <source>For non-class types, the right operand is first &lt;a href=&quot;implicit_cast&quot;&gt;implicitly converted&lt;/a&gt; to the cv-unqualified type of the left operand, and then its value is copied into the object identified by left operand.</source>
          <target state="translated">Для не классовых типов правый операнд сначала &lt;a href=&quot;implicit_cast&quot;&gt;неявно преобразуется&lt;/a&gt; в тип cv-unqualified левого операнда, а затем его значение копируется в объект, идентифицируемый левым операндом.</target>
        </trans-unit>
        <trans-unit id="763322c7964e589eee6959c4585b224d003bfdec" translate="yes" xml:space="preserve">
          <source>For non-polymorphic objects, the interpretation of the value is determined from the expression in which the object is used, and is decided at compile time.</source>
          <target state="translated">Для неполиморфных объектов интерпретация значения определяется из выражения,в котором объект используется,и решается при компиляции.</target>
        </trans-unit>
        <trans-unit id="abfd29ae0e4b12baa41dd1f2957ee892d3a0b889" translate="yes" xml:space="preserve">
          <source>For non-template functions, default arguments can be added to a function that was already declared if the function is redeclared in the same scope. At the point of a function call, the defaults are a union of the defaults provided in all visible declarations for the function. A redeclaration cannot introduce a default for an argument for which a default is already visible (even if the value is the same). A re-declaration in an inner scope does not acquire the default arguments from outer scopes.</source>
          <target state="translated">Для нешаблонных функций аргументы по умолчанию могут быть добавлены в функцию,которая уже была объявлена,если функция объявлена заново в той же области видимости.В момент вызова функции значения по умолчанию являются объединением значений по умолчанию,предусмотренных во всех видимых объявлениях для функции.Повторное объявление не может ввести значение по умолчанию для аргумента,для которого значение по умолчанию уже видно (даже если значение то же самое).Повторное объявление во внутренней области применения не получает аргументы по умолчанию из внешних областей применения.</target>
        </trans-unit>
        <trans-unit id="0991570f4540f46325a93449ba04cca879b380b0" translate="yes" xml:space="preserve">
          <source>For non-type template parameter packs whose type uses a placeholder type, the type is independently deduced for each template argument and need not match:</source>
          <target state="translated">Для пакетов параметров без типа шаблона,тип которых использует тип плейсхолдера,тип вычитается независимо для каждого аргумента шаблона и не обязательно должен совпадать:</target>
        </trans-unit>
        <trans-unit id="bd5aba2924605ce9fcbd81eb53c058fae5c7dea4" translate="yes" xml:space="preserve">
          <source>For non-type template parameters, specifies that the type will be deduced from the argument.</source>
          <target state="translated">Для параметров,не относящихся к типу шаблона,указывает,что тип будет выведен из аргумента.</target>
        </trans-unit>
        <trans-unit id="7514bfabe1453bf3e4fa04b102092e65768ddd6d" translate="yes" xml:space="preserve">
          <source>For non-union class types (&lt;code&gt;class&lt;/code&gt; and &lt;code&gt;struct&lt;/code&gt;), the move assignment operator performs full member-wise move assignment of the object's direct bases and immediate non-static members, in their declaration order, using built-in assignment for the scalars, memberwise move-assignment for arrays, and move assignment operator for class types (called non-virtually).</source>
          <target state="translated">Для не являющихся объединением типов классов ( &lt;code&gt;class&lt;/code&gt; и &lt;code&gt;struct&lt;/code&gt; ) оператор присваивания перемещений выполняет полное присваивание по элементам присваивания прямых оснований объекта и непосредственных нестатических членов в порядке их объявления, используя встроенное присваивание для скаляров для каждого элемента перемещение-присваивание для массивов и оператор присваивания перемещения для типов классов (называемых не виртуально).</target>
        </trans-unit>
        <trans-unit id="268fe4cbc20a4aa0215c7d01242785136c98fb6e" translate="yes" xml:space="preserve">
          <source>For nonempty ranges, exactly &lt;code&gt;&lt;a href=&quot;../iterator/distance&quot;&gt;std::distance&lt;/a&gt;(first, last) - 1&lt;/code&gt; applications of the corresponding predicate.</source>
          <target state="translated">Для непустых диапазонов в точности &lt;code&gt;&lt;a href=&quot;../iterator/distance&quot;&gt;std::distance&lt;/a&gt;(first, last) - 1&lt;/code&gt; применение соответствующего предиката.</target>
        </trans-unit>
        <trans-unit id="f6180b71feea7358927f872628400b8246c94135" translate="yes" xml:space="preserve">
          <source>For nonempty ranges, exactly &lt;code&gt;&lt;a href=&quot;../iterator/distance&quot;&gt;std::distance&lt;/a&gt;(first,last) -1&lt;/code&gt; applications of the corresponding predicate.</source>
          <target state="translated">Для непустых диапазонов, точно &lt;code&gt;&lt;a href=&quot;../iterator/distance&quot;&gt;std::distance&lt;/a&gt;(first,last) -1&lt;/code&gt; приложения соответствующего предиката.</target>
        </trans-unit>
        <trans-unit id="6147555f2527654078938dabd88a3dffc2574f9a" translate="yes" xml:space="preserve">
          <source>For objects of non-aggregate class type, a public &lt;a href=&quot;../language/default_constructor&quot;&gt;default constructor&lt;/a&gt; must be defined (either user-defined or implicitly defined) to satisfy DefaultConstructible.</source>
          <target state="translated">Для объектов неагрегированного типа класса должен быть определен общедоступный &lt;a href=&quot;../language/default_constructor&quot;&gt;конструктор по умолчанию&lt;/a&gt; (определяемый пользователем или неявно определенный) для соответствия DefaultConstructible.</target>
        </trans-unit>
        <trans-unit id="5e455249348a9249c3d467d0641b99a240d6d8c9" translate="yes" xml:space="preserve">
          <source>For other contexts where overloaded function names can appear, see &lt;a href=&quot;overloaded_address&quot;&gt;taking the address of an overloaded function&lt;/a&gt;.</source>
          <target state="translated">Для других контекстов, где могут появляться имена перегруженных функций, см. &lt;a href=&quot;overloaded_address&quot;&gt;Получение адреса перегруженной функции&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e2bc8579aeb917ea35ac1bcbad18eb05fd4bdc45" translate="yes" xml:space="preserve">
          <source>For output streams (&lt;code&gt;mode &amp;amp; ios_base::out == true&lt;/code&gt;), &lt;code&gt;pbase()&lt;/code&gt; points at the first character and &lt;code&gt;epptr() &amp;gt;= pbase() + s.size()&lt;/code&gt; (epptr is allowed to point farther so that the following &lt;code&gt;sputc()&lt;/code&gt; wouldn't immediately call &lt;code&gt;overflow()&lt;/code&gt;)</source>
          <target state="translated">Для выходных потоков ( &lt;code&gt;mode &amp;amp; ios_base::out == true&lt;/code&gt; ) &lt;code&gt;pbase()&lt;/code&gt; указывает на первый символ, а &lt;code&gt;epptr() &amp;gt;= pbase() + s.size()&lt;/code&gt; (epptr разрешено указывать дальше так, чтобы следующий &lt;code&gt;sputc()&lt;/code&gt; не будет сразу вызывать &lt;code&gt;overflow()&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="8f63d9afe770e3006ba3c31bb680ec6934c94657" translate="yes" xml:space="preserve">
          <source>For output streams (and for update streams on which the last operation was output), writes any unwritten data from the &lt;code&gt;stream&lt;/code&gt;'s buffer to the associated output device.</source>
          <target state="translated">Для выходных потоков (и для потоков обновления, для которых была выведена последняя операция), записывает любые неписанные данные из буфера &lt;code&gt;stream&lt;/code&gt; в соответствующее устройство вывода.</target>
        </trans-unit>
        <trans-unit id="481575f6bdf13b67deef2e241c2a9a6d1c8d891f" translate="yes" xml:space="preserve">
          <source>For output streams, this typically results in writing the contents of the put area into the associated sequence, i.e. flushing of the output buffer. For input streams, this typically empties the get area and forces a re-read from the associated sequence to pick up recent changes. The default behavior (found, for example, in &lt;code&gt;&lt;a href=&quot;../basic_stringbuf&quot;&gt;std::basic_stringbuf&lt;/a&gt;&lt;/code&gt;), is to do nothing.</source>
          <target state="translated">Для выходных потоков это обычно приводит к записи содержимого области размещения в связанную последовательность, то есть к очистке выходного буфера. Для входных потоков это обычно очищает область получения и вынуждает перечитывать из связанной последовательности, чтобы получить последние изменения. Поведение по умолчанию (найденное, например, в &lt;code&gt;&lt;a href=&quot;../basic_stringbuf&quot;&gt;std::basic_stringbuf&lt;/a&gt;&lt;/code&gt; ) - ничего не делать.</target>
        </trans-unit>
        <trans-unit id="a6ae1e52a83b6ade1ae039896874969c5f21c0bf" translate="yes" xml:space="preserve">
          <source>For overload (5), &lt;code&gt;&lt;a href=&quot;../../types/is_constructible&quot;&gt;std::is_constructible_v&lt;/a&gt;&amp;lt;T, const U&amp;amp;&amp;gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../../types/is_assignable&quot;&gt;std::is_assignable_v&lt;/a&gt;&amp;lt;T&amp;amp;, const U&amp;amp;&amp;gt;&lt;/code&gt; are both &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">Для перегрузки (5) &lt;code&gt;&lt;a href=&quot;../../types/is_constructible&quot;&gt;std::is_constructible_v&lt;/a&gt;&amp;lt;T, const U&amp;amp;&amp;gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;../../types/is_assignable&quot;&gt;std::is_assignable_v&lt;/a&gt;&amp;lt;T&amp;amp;, const U&amp;amp;&amp;gt;&lt;/code&gt; имеют значение &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="75a2c90c2bfc30a317a46c88b8a56739d5f6fa1d" translate="yes" xml:space="preserve">
          <source>For overload (6), &lt;code&gt;&lt;a href=&quot;../../types/is_constructible&quot;&gt;std::is_constructible_v&lt;/a&gt;&amp;lt;T, U&amp;gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../../types/is_assignable&quot;&gt;std::is_assignable_v&lt;/a&gt;&amp;lt;T&amp;amp;, U&amp;gt;&lt;/code&gt; are both &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">Для перегрузки (6) &lt;code&gt;&lt;a href=&quot;../../types/is_constructible&quot;&gt;std::is_constructible_v&lt;/a&gt;&amp;lt;T, U&amp;gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;../../types/is_assignable&quot;&gt;std::is_assignable_v&lt;/a&gt;&amp;lt;T&amp;amp;, U&amp;gt;&lt;/code&gt; оба имеют значение &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2780c151ef71bd4320af5b5a8131bcdca9bcbb78" translate="yes" xml:space="preserve">
          <source>For overloads (1,2), if one of the parameters is an rvalue, the reference returned becomes a dangling reference at the end of the full expression that contains the call to &lt;code&gt;minmax&lt;/code&gt;:</source>
          <target state="translated">Для перегрузок (1,2), если один из параметров является значением r, возвращаемая ссылка становится висячей ссылкой в ​​конце полного выражения, содержащего вызов &lt;code&gt;minmax&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="8382a9060c467fcc4ada14b4b211aabe3aa6d683" translate="yes" xml:space="preserve">
          <source>For overloads (3,5,7,9), The function can be implemented with the return type different from &lt;code&gt;&lt;a href=&quot;../valarray&quot;&gt;std::valarray&lt;/a&gt;&lt;/code&gt;. In this case, the replacement type has the following properties:</source>
          <target state="translated">Для перегрузок (3,5,7,9), функция может быть реализована с типом возвращаемого значения, отличным от &lt;code&gt;&lt;a href=&quot;../valarray&quot;&gt;std::valarray&lt;/a&gt;&lt;/code&gt; . В этом случае тип замены имеет следующие свойства:</target>
        </trans-unit>
        <trans-unit id="e863547ad76debf1e954b0555a0ab321eb1a4d01" translate="yes" xml:space="preserve">
          <source>For pointers to functions, the valid arguments are pointers to functions with linkage (or constant expressions that evaluate to null pointer values).</source>
          <target state="translated">Для указателей на функции допустимыми аргументами являются указатели на функции с линковкой (или константные выражения,которые оценивают до нуля значения указателя).</target>
        </trans-unit>
        <trans-unit id="0c14d4f91a6fd67c34187b14315456bf4871a9d3" translate="yes" xml:space="preserve">
          <source>For pointers to member functions and pointers to data members, &lt;code&gt;t1&lt;/code&gt; may be a regular pointer or an object of class type that overloads &lt;code&gt;operator*&lt;/code&gt;, such as &lt;code&gt;&lt;a href=&quot;../memory/unique_ptr&quot;&gt;std::unique_ptr&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../memory/shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Для указателей на функции-члены и указателей на члены-данные &lt;code&gt;t1&lt;/code&gt; может быть обычным указателем или объектом типа класса, который перегружает &lt;code&gt;operator*&lt;/code&gt; , например &lt;code&gt;&lt;a href=&quot;../memory/unique_ptr&quot;&gt;std::unique_ptr&lt;/a&gt;&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;../memory/shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a71d4a336a0c5624e650b25202bdefde98d600fd" translate="yes" xml:space="preserve">
          <source>For pointers to members, the argument has to be a pointer to member expressed as &lt;code&gt;&amp;amp;Class::Member&lt;/code&gt; or a constant expression that evaluates to null pointer or &lt;code&gt;&lt;a href=&quot;../types/nullptr_t&quot;&gt;std::nullptr_t&lt;/a&gt;&lt;/code&gt; value.</source>
          <target state="translated">Для указателей на члены аргумент должен быть указателем на член, выраженным как &lt;code&gt;&amp;amp;Class::Member&lt;/code&gt; или константным выражением, которое оценивается как нулевой указатель или значение &lt;code&gt;&lt;a href=&quot;../types/nullptr_t&quot;&gt;std::nullptr_t&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a1d3d2317fc6b323549d75e48efcd87a6d6fa4bd" translate="yes" xml:space="preserve">
          <source>For pointers to objects, the template arguments have to designate the address of a complete object with static &lt;a href=&quot;storage_duration&quot;&gt;storage duration&lt;/a&gt; and a &lt;a href=&quot;storage_duration#Linkage&quot;&gt;linkage&lt;/a&gt; (either internal or external), or a constant expression that evaluates to the appropriate null pointer or &lt;code&gt;&lt;a href=&quot;../types/nullptr_t&quot;&gt;std::nullptr_t&lt;/a&gt;&lt;/code&gt; value.</source>
          <target state="translated">Для указателей на объекты аргументы шаблона должны указывать адрес полного объекта со статической &lt;a href=&quot;storage_duration&quot;&gt;продолжительностью хранения&lt;/a&gt; и &lt;a href=&quot;storage_duration#Linkage&quot;&gt;связью&lt;/a&gt; (внутренней или внешней) или константным выражением, которое оценивается как соответствующий нулевой указатель или значение &lt;code&gt;&lt;a href=&quot;../types/nullptr_t&quot;&gt;std::nullptr_t&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="62b3bed6c74847c88d09ff91b5a9eb3064f5365b" translate="yes" xml:space="preserve">
          <source>For portable directory and file naming, see &lt;a href=&quot;../../filesystem&quot;&gt;C++ filesystem library&lt;/a&gt; or &lt;a href=&quot;http://www.boost.org/doc/libs/1_56_0/libs/filesystem/doc/index.htm&quot;&gt;boost.filesystem&lt;/a&gt;.</source>
          <target state="translated">Для переносимых имен каталогов и файлов см. &lt;a href=&quot;../../filesystem&quot;&gt;Библиотеку файловой системы C ++&lt;/a&gt; или &lt;a href=&quot;http://www.boost.org/doc/libs/1_56_0/libs/filesystem/doc/index.htm&quot;&gt;boost.filesystem&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="bb935bbe4c86edf17255328af95f195fe665edf1" translate="yes" xml:space="preserve">
          <source>For portable pathname generation from Unicode strings, see &lt;a href=&quot;u8path&quot;&gt;u8path&lt;/a&gt;.</source>
          <target state="translated">Для генерации переносимого пути из строк Unicode, смотрите &lt;a href=&quot;u8path&quot;&gt;u8path&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0dfb375daadbb3e77fbf4f5775a23c9dc598be6b" translate="yes" xml:space="preserve">
          <source>For proper values of &lt;code&gt;i&lt;/code&gt; and &lt;code&gt;j&lt;/code&gt;, the following properties are true:</source>
          <target state="translated">Для правильных значений &lt;code&gt;i&lt;/code&gt; и &lt;code&gt;j&lt;/code&gt; верны следующие свойства:</target>
        </trans-unit>
        <trans-unit id="530c267bd41398cdf37d989d6c0ff07e1066ef3d" translate="yes" xml:space="preserve">
          <source>For prvalue expressions, the dynamic type is always the same as the static type.</source>
          <target state="translated">Для выражений prvalue динамический тип всегда совпадает со статическим типом.</target>
        </trans-unit>
        <trans-unit id="adfb2dec7da66f103fd2b9cd71521128041db54d" translate="yes" xml:space="preserve">
          <source>For signed &lt;code&gt;Integral&lt;/code&gt; types, arithmetic is defined to use two&amp;rsquo;s complement representation. There are no undefined results.</source>
          <target state="translated">Для типов со &lt;code&gt;Integral&lt;/code&gt; арифметика определяется с использованием представления дополнения до двух. Там нет неопределенных результатов.</target>
        </trans-unit>
        <trans-unit id="ed5e530786bebc7b272d33fe3e9f636b75dcece4" translate="yes" xml:space="preserve">
          <source>For signed and non-negative &lt;code&gt;a&lt;/code&gt;, if a * 2b</source>
          <target state="translated">Для подписанного и неотрицательного &lt;code&gt;a&lt;/code&gt; , если a * 2b</target>
        </trans-unit>
        <trans-unit id="3af751b6ecf63d4481061bc54946dd23bc4bd1ff" translate="yes" xml:space="preserve">
          <source>For signed and non-negative &lt;code&gt;a&lt;/code&gt;, the value of &lt;code&gt;a &amp;lt;&amp;lt; b&lt;/code&gt; is a * 2b</source>
          <target state="translated">Для подписанного и неотрицательного &lt;code&gt;a&lt;/code&gt; значение &lt;code&gt;a &amp;lt;&amp;lt; b&lt;/code&gt; равно * 2b</target>
        </trans-unit>
        <trans-unit id="8d1075cea1a2a6de71e067eda636b7104a7e1c7b" translate="yes" xml:space="preserve">
          <source>For signed integral types, arithmetic is defined to use two&amp;rsquo;s complement representation. There are no undefined results.</source>
          <target state="translated">Для целочисленных типов со знаком арифметика определяется с использованием представления дополнения до двух. Там нет неопределенных результатов.</target>
        </trans-unit>
        <trans-unit id="7df120d1e9011ddd1ce77a96f4b12ae1b34f6af9" translate="yes" xml:space="preserve">
          <source>For some &lt;code&gt;j&lt;/code&gt; in &lt;code&gt;[0,n)&lt;/code&gt;, &lt;code&gt;X​::​lt(p[j], q[j])&lt;/code&gt; is true and</source>
          <target state="translated">В течение некоторого &lt;code&gt;j&lt;/code&gt; в &lt;code&gt;[0,n)&lt;/code&gt; , &lt;code&gt;X​::​lt(p[j], q[j])&lt;/code&gt; истинно и</target>
        </trans-unit>
        <trans-unit id="81ca343fa42d2babb2e6749bedea9b053e460258" translate="yes" xml:space="preserve">
          <source>For some engines, &quot;fast jump&quot; algorithms are known, which advance the state by many steps (order of millions) without calculating intermediate state transitions, although not necessarily in constant time.</source>
          <target state="translated">Для некоторых движков известны алгоритмы &quot;быстрого прыжка&quot;,которые продвигают состояние на много шагов (порядка миллионов),не вычисляя промежуточные переходы состояния,хотя и не обязательно в постоянное время.</target>
        </trans-unit>
        <trans-unit id="fd4abd3a725738e4ad1d6b4cf76b4fe8cb02df5a" translate="yes" xml:space="preserve">
          <source>For some of the C standard library headers of the form &lt;code&gt;xxx.h&lt;/code&gt;, the C++ standard library both includes an identically-named header and another header of the form &lt;code&gt;cxxx&lt;/code&gt; (all meaningful &lt;code&gt;cxxx&lt;/code&gt; headers are listed above).</source>
          <target state="translated">Для некоторых заголовков стандартной библиотеки C в форме &lt;code&gt;xxx.h&lt;/code&gt; стандартная библиотека C ++ включает заголовок с одинаковым именем и другой заголовок формы &lt;code&gt;cxxx&lt;/code&gt; (все значимые заголовки &lt;code&gt;cxxx&lt;/code&gt; перечислены выше).</target>
        </trans-unit>
        <trans-unit id="cf567f1a3c60615e84656e20417b1a1de74545ac" translate="yes" xml:space="preserve">
          <source>For some of the signals, the implementation may call &lt;code&gt;std::signal(sig, &lt;a href=&quot;sig_strategies&quot;&gt;SIG_IGN&lt;/a&gt;)&lt;/code&gt; at the startup of the program. For the rest, the implementation must call &lt;code&gt;std::signal(sig, &lt;a href=&quot;sig_strategies&quot;&gt;SIG_DFL&lt;/a&gt;)&lt;/code&gt;.</source>
          <target state="translated">Для некоторых сигналов реализация может вызвать &lt;code&gt;std::signal(sig, &lt;a href=&quot;sig_strategies&quot;&gt;SIG_IGN&lt;/a&gt;)&lt;/code&gt; при запуске программы. В остальном реализация должна вызывать &lt;code&gt;std::signal(sig, &lt;a href=&quot;sig_strategies&quot;&gt;SIG_DFL&lt;/a&gt;)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7f03372ec69aa391f826e43bea001123512eb679" translate="yes" xml:space="preserve">
          <source>For standard attributes, it will expand to the year and month in which the attribute was added to the working draft (see table below), the presence of vendor-specific attributes is determined by a non-zero value.</source>
          <target state="translated">Для стандартных атрибутов он будет расширяться до года и месяца,в котором атрибут был добавлен в рабочий проект (см.таблицу ниже),наличие атрибутов конкретного поставщика определяется ненулевым значением.</target>
        </trans-unit>
        <trans-unit id="b56d8ebf643b96a82d52768c03f8db9aa07210bd" translate="yes" xml:space="preserve">
          <source>For templated functions with deduced return types, the return value may be named in a postcondition without additional restrictions (except that the name of the return value is treated as having a &lt;a href=&quot;../dependent_name#Type-dependent_expressions&quot;&gt;dependent type&lt;/a&gt;). For the non-templated functions with deduced return types, naming the return value is prohibited in declarations (but allowed in the definitions):</source>
          <target state="translated">Для шаблонных функций с выведенными типами возврата возвращаемое значение может быть названо в постусловии без дополнительных ограничений (за исключением того, что имя возвращаемого значения рассматривается как имеющий &lt;a href=&quot;../dependent_name#Type-dependent_expressions&quot;&gt;зависимый тип&lt;/a&gt; ). Для не шаблонных функций с выводимыми типами возврата, именование возвращаемого значения запрещено в объявлениях (но допускается в определениях):</target>
        </trans-unit>
        <trans-unit id="6c8bc61f784489c1be269b98b2a834b94911c08f" translate="yes" xml:space="preserve">
          <source>For the &lt;code&gt;A&lt;/code&gt; conversion style</source>
          <target state="translated">Для стиля преобразования &lt;code&gt;A&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e2ae91f5c3692945d40532e2d71ac0a4386bf89f" translate="yes" xml:space="preserve">
          <source>For the &lt;code&gt;E&lt;/code&gt; conversion style</source>
          <target state="translated">Для стиля преобразования &lt;code&gt;E&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ebb3f8b2a8fff5b3415e1098f326b2c10a1d27f2" translate="yes" xml:space="preserve">
          <source>For the &lt;code&gt;G&lt;/code&gt; conversion style conversion with style &lt;code&gt;E&lt;/code&gt; or &lt;code&gt;F&lt;/code&gt; will be performed.</source>
          <target state="translated">Для &lt;code&gt;G&lt;/code&gt; преобразования стиля преобразования в стиле &lt;code&gt;E&lt;/code&gt; или &lt;code&gt;F&lt;/code&gt; будет выполняться.</target>
        </trans-unit>
        <trans-unit id="5a1ff43b4f3925bee54ad2942ba18ef8a4606c5a" translate="yes" xml:space="preserve">
          <source>For the &lt;code&gt;X&lt;/code&gt; conversion letters &lt;code&gt;ABCDEF&lt;/code&gt; are used.</source>
          <target state="translated">Для преобразования &lt;code&gt;X&lt;/code&gt; используются буквы &lt;code&gt;ABCDEF&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="57890cceddb7efc24f01d52d8cf7f7dcc8bbc9c7" translate="yes" xml:space="preserve">
          <source>For the &lt;code&gt;a&lt;/code&gt; conversion style</source>
          <target state="translated">Для &lt;code&gt;a&lt;/code&gt; стиля преобразования</target>
        </trans-unit>
        <trans-unit id="ff2ab4c944a5b84fe46520d57012d6c750be1de1" translate="yes" xml:space="preserve">
          <source>For the &lt;code&gt;char&lt;/code&gt; specialization, &lt;code&gt;eq&lt;/code&gt; and &lt;code&gt;lt&lt;/code&gt; are defined identically to the built-in operators &lt;code&gt;==&lt;/code&gt; and &lt;code&gt;&amp;lt;&lt;/code&gt; for type &lt;code&gt;unsigned char&lt;/code&gt; (</source>
          <target state="translated">Для специализации &lt;code&gt;char&lt;/code&gt; , &lt;code&gt;eq&lt;/code&gt; и &lt;code&gt;lt&lt;/code&gt; определяются идентично встроенным операторам &lt;code&gt;==&lt;/code&gt; и &lt;code&gt;&amp;lt;&lt;/code&gt; для типа &lt;code&gt;unsigned char&lt;/code&gt; (</target>
        </trans-unit>
        <trans-unit id="41f7d301edd4649ecc9cc5e4ae27295bc06e8657" translate="yes" xml:space="preserve">
          <source>For the &lt;code&gt;e&lt;/code&gt; conversion style</source>
          <target state="translated">Для стиля преобразования &lt;code&gt;e&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a793f4315aaf80e04799e8d39a2f905e34a3d0ea" translate="yes" xml:space="preserve">
          <source>For the &lt;code&gt;g&lt;/code&gt; conversion style conversion with style &lt;code&gt;e&lt;/code&gt; or &lt;code&gt;f&lt;/code&gt; will be performed.</source>
          <target state="translated">Для &lt;code&gt;g&lt;/code&gt; преобразования преобразования стиля со стилем &lt;code&gt;e&lt;/code&gt; или &lt;code&gt;f&lt;/code&gt; будет.</target>
        </trans-unit>
        <trans-unit id="807d09a568c3d3ab555b52969a3cc98de7806c36" translate="yes" xml:space="preserve">
          <source>For the &lt;code&gt;x&lt;/code&gt; conversion letters &lt;code&gt;abcdef&lt;/code&gt; are used.</source>
          <target state="translated">Для преобразования &lt;code&gt;x&lt;/code&gt; используются буквы &lt;code&gt;abcdef&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="964c75b68c3b67fa44944f427366e59ff71c8628" translate="yes" xml:space="preserve">
          <source>For the IEEE-compatible type &lt;code&gt;double&lt;/code&gt;, if |arg| &amp;gt; 710.5, then &lt;code&gt;cosh(arg)&lt;/code&gt; overflows.</source>
          <target state="translated">Для IEEE-совместимого типа &lt;code&gt;double&lt;/code&gt; , если | arg | &amp;gt; 710,5, то переполнение &lt;code&gt;cosh(arg)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="dc98bc92461ef84f63213928d7e0dd4bec2a4ac3" translate="yes" xml:space="preserve">
          <source>For the IEEE-compatible type &lt;code&gt;double&lt;/code&gt;, underflow is guaranteed if &lt;code&gt;arg&lt;/code&gt; &amp;gt; 26.55.</source>
          <target state="translated">Для &lt;code&gt;double&lt;/code&gt; типа, совместимого с IEEE , недопустимость гарантируется, если &lt;code&gt;arg&lt;/code&gt; &amp;gt; 26.55.</target>
        </trans-unit>
        <trans-unit id="5139171c7dc4bf39c00774f4969ee9ed5cb06814" translate="yes" xml:space="preserve">
          <source>For the alphabetic components of the default date format (if any), this function is usually case-insensitive.</source>
          <target state="translated">Для алфавитных компонентов формата даты по умолчанию (если таковые имеются)эта функция обычно не чувствительна к регистру.</target>
        </trans-unit>
        <trans-unit id="ca85fb6216b889960979e71b66f45292ecb6fff0" translate="yes" xml:space="preserve">
          <source>For the alphabetic components of the default time format (if any), this function is usually case-insensitive.</source>
          <target state="translated">Для алфавитных компонентов формата времени по умолчанию (если таковые имеются)эта функция обычно не чувствительна к регистру.</target>
        </trans-unit>
        <trans-unit id="3387ca380771e46f30ac460b364c23f3a50ac485" translate="yes" xml:space="preserve">
          <source>For the binary operators (except shifts), if the promoted operands have different types, additional set of implicit conversions is applied, known as</source>
          <target state="translated">Для двоичных операторов (за исключением сдвигов),если продвигаемые операндов имеют различные типы,применяется дополнительный набор неявных преобразований,известный как</target>
        </trans-unit>
        <trans-unit id="5834b75a1d37489895cb80d1b1901ebbb10cdea5" translate="yes" xml:space="preserve">
          <source>For the built-in logical AND operator, the result is &lt;code&gt;true&lt;/code&gt; if both operands are &lt;code&gt;true&lt;/code&gt;. Otherwise, the result is &lt;code&gt;false&lt;/code&gt;. This operator is &lt;a href=&quot;https://en.wikipedia.org/wiki/Short-circuit_evaluation&quot;&gt;short-circuiting&lt;/a&gt;: if the first operand is &lt;code&gt;false&lt;/code&gt;, the second operand is not evaluated.</source>
          <target state="translated">Для встроенного логического оператора AND результат равен &lt;code&gt;true&lt;/code&gt; , если оба операнда имеют значение &lt;code&gt;true&lt;/code&gt; . В противном случае результат будет &lt;code&gt;false&lt;/code&gt; . Этот оператор имеет &lt;a href=&quot;https://en.wikipedia.org/wiki/Short-circuit_evaluation&quot;&gt;короткое замыкание&lt;/a&gt; : если первый операнд имеет значение &lt;code&gt;false&lt;/code&gt; , второй операнд не оценивается.</target>
        </trans-unit>
        <trans-unit id="4f868d872215ad926f03072ef85906893d1cbc9f" translate="yes" xml:space="preserve">
          <source>For the built-in logical NOT operator, the result is &lt;code&gt;true&lt;/code&gt; if the operand is &lt;code&gt;false&lt;/code&gt;. Otherwise, the result is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">Для встроенного логического оператора NOT результат равен &lt;code&gt;true&lt;/code&gt; , если операнд равен &lt;code&gt;false&lt;/code&gt; . В противном случае результат будет &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="98a7f937369cdbc13ece1f4624b3c0deaca24c09" translate="yes" xml:space="preserve">
          <source>For the built-in logical OR operator, the result is &lt;code&gt;true&lt;/code&gt; if either the first or the second operand (or both) is &lt;code&gt;true&lt;/code&gt;. This operator is short-circuiting: if the first operand is &lt;code&gt;true&lt;/code&gt;, the second operand is not evaluated.</source>
          <target state="translated">Для встроенного логического оператора ИЛИ результат равен &lt;code&gt;true&lt;/code&gt; , если либо первый, либо второй операнд (или оба) имеют значение &lt;code&gt;true&lt;/code&gt; . Этот оператор имеет короткое замыкание: если первый операнд имеет значение &lt;code&gt;true&lt;/code&gt; , второй операнд не оценивается.</target>
        </trans-unit>
        <trans-unit id="e1db3901d3c9b8e71a137ee3fd4f6e31711c8ecd" translate="yes" xml:space="preserve">
          <source>For the built-in operator, expression must have arithmetic or unscoped enumeration type. Integral promotion is performed on the operand and determines the type of the result.</source>
          <target state="translated">Для встроенного оператора выражение должно иметь арифметический или непописанный тип перечисления.Интегральное продвижение выполняется на операнде и определяет тип результата.</target>
        </trans-unit>
        <trans-unit id="ed7967925e3d9a903dc61fad15c26826b80985cc" translate="yes" xml:space="preserve">
          <source>For the built-in operator, expression must have arithmetic, unscoped enumeration, or pointer type. Integral promotion is performed on the operand if it has integral or unscoped enumeration type and determines the type of the result.</source>
          <target state="translated">Для встроенного оператора выражение должно иметь арифметический,не кодированное перечисление или тип указателя.Интегральное продвижение выполняется на операнде,если он имеет интегральный или не кодированный тип перечисления и определяет тип результата.</target>
        </trans-unit>
        <trans-unit id="1f4b14dfb9171534a115c48cff5a996c8739f0c3" translate="yes" xml:space="preserve">
          <source>For the built-in operator, lhs and rhs must be one of the following:</source>
          <target state="translated">Для встроенного оператора lhs и rhs должны быть одним из следующих:</target>
        </trans-unit>
        <trans-unit id="c2fd6c69985c326b9c90b5457d6125aba9680de4" translate="yes" xml:space="preserve">
          <source>For the built-in operator, lhs and rhs must both have arithmetic or unscoped enumeration type.</source>
          <target state="translated">Для встроенного оператора lhs и rhs должны иметь арифметический или непонятный тип перечисления.</target>
        </trans-unit>
        <trans-unit id="21aefc527d6a29a300de35c2b1a6e0de364db29e" translate="yes" xml:space="preserve">
          <source>For the built-in operator, lhs and rhs must both have integral or unscoped enumeration type</source>
          <target state="translated">Для встроенного оператора lhs и rhs должны иметь встроенный или не встроенный пересчет.</target>
        </trans-unit>
        <trans-unit id="0e1c1ef458021530f026a00ce0e6a1cdf579bce8" translate="yes" xml:space="preserve">
          <source>For the built-in operator, lhs may have any non-const scalar type and rhs must be implicitly convertible to the type of lhs.</source>
          <target state="translated">Для встроенного оператора lhs может иметь любой неконстантный скалярный тип,а rhs должен быть неявно конвертирован в тип lhs.</target>
        </trans-unit>
        <trans-unit id="0fc6e93f0b5ccc41116e96e66ba6cc181fbeaf32" translate="yes" xml:space="preserve">
          <source>For the built-in operators, lhs and rhs must both have integral or unscoped enumeration type. Integral promotions are performed on both operands.</source>
          <target state="translated">Для встроенных операторов lhs и rhs должны иметь интегральный или непонятный тип перечисления.Интегральные промо-акции выполняются на обоих операндов.</target>
        </trans-unit>
        <trans-unit id="8b5909dfd25b823a91c25e0c6ebfb4fe115565d4" translate="yes" xml:space="preserve">
          <source>For the built-in operators, lhs and rhs must both have integral or unscoped enumeration type. Usual arithmetic conversions are performed on both operands and determine the type of the result.</source>
          <target state="translated">Для встроенных операторов lhs и rhs должны иметь интегральный или непонятный тип перечисления.Обычные арифметические преобразования выполняются на обоих операндов и определяют тип результата.</target>
        </trans-unit>
        <trans-unit id="631e90fa71e23701d70b68b196fb2c8886d4ce41" translate="yes" xml:space="preserve">
          <source>For the character sequence &lt;code&gt;[first, last)&lt;/code&gt;, obtains the primary sort key in the imbued locale's collating order, that is, the sort key that is based on the positions of the letters and collation units in the national alphabet, ignoring case, diacritics, variants, etc. If a primary sort key compares less than another primary sort key with &lt;code&gt;operator&amp;lt;&lt;/code&gt;, then the character sequence that produced the first sort key comes before the character sequence that produced the second sort key, in the currently imbued locale's primary collation order.</source>
          <target state="translated">Для последовательности символов &lt;code&gt;[first, last)&lt;/code&gt; , получает первичный ключ сортировки в порядке сортировки пропущенной локали, то есть ключ сортировки, который основан на положениях букв и единиц сопоставления в национальном алфавите, игнорируя регистр, диакритические знаки, варианты и т. д. Если первичный ключ сортировки сравнивает меньше, чем другой первичный ключ сортировки с &lt;code&gt;operator&amp;lt;&lt;/code&gt; , то последовательность символов, которая произвела первый ключ сортировки, предшествует последовательности символов, которая произвела второй ключ сортировки, в первичном порядке сопоставления текущей текущей локали ,</target>
        </trans-unit>
        <trans-unit id="e113ddf9e42810bbcd7d53a7fd8437e10332cdc3" translate="yes" xml:space="preserve">
          <source>For the definition of &lt;code&gt;&lt;a href=&quot;../iterator/iterator_traits&quot;&gt;std::iterator_traits&lt;/a&gt;&lt;/code&gt;, the following exposition-only concept is defined.</source>
          <target state="translated">Для определения &lt;code&gt;&lt;a href=&quot;../iterator/iterator_traits&quot;&gt;std::iterator_traits&lt;/a&gt;&lt;/code&gt; определена следующая концепция только для экспозиции.</target>
        </trans-unit>
        <trans-unit id="d1225d08c6a217571442e3f149849eb65e94bce7" translate="yes" xml:space="preserve">
          <source>For the entities that are captured by reference (with the default capture &lt;code&gt;[&amp;amp;]&lt;/code&gt; or when using the character &amp;amp;, e.g. &lt;code&gt;[&amp;amp;a, &amp;amp;b, &amp;amp;c]&lt;/code&gt;), it is unspecified if additional data members are declared in the closure type , but any such additional members must satisfy &lt;a href=&quot;../named_req/literaltype&quot;&gt;LiteralType&lt;/a&gt;(since C++17).</source>
          <target state="translated">Для объектов, которые захватываются по ссылке (с захватом по умолчанию &lt;code&gt;[&amp;amp;]&lt;/code&gt; или при использовании символа &amp;amp;, например, &lt;code&gt;[&amp;amp;a, &amp;amp;b, &amp;amp;c]&lt;/code&gt; ), не определено, если дополнительные элементы данных объявлены в типе замыкания, но любые такие дополнительные члены должны удовлетворять &lt;a href=&quot;../named_req/literaltype&quot;&gt;LiteralType&lt;/a&gt; (начиная с C ++ 17).</target>
        </trans-unit>
        <trans-unit id="1a22058978c1262938bcaa97c3c6020766a5ad4e" translate="yes" xml:space="preserve">
          <source>For the first (non-array) form, expression must be a pointer to an object type or a class type &lt;a href=&quot;implicit_cast&quot;&gt;contextually implicitly convertible&lt;/a&gt; to such pointer, and its value must be either</source>
          <target state="translated">Для первой формы (не массива) выражение должно быть указателем на тип объекта или тип класса, &lt;a href=&quot;implicit_cast&quot;&gt;контекстуально неявно преобразуемый&lt;/a&gt; в такой указатель, и его значение должно быть либо</target>
        </trans-unit>
        <trans-unit id="299adf2377e7d703f91fcfc6dc32f0216b89eb0d" translate="yes" xml:space="preserve">
          <source>For the first (non-const) version, the behavior is undefined if this character is modified to any value other than &lt;code&gt;CharT()&lt;/code&gt; .</source>
          <target state="translated">Для первой (неконстантной) версии поведение не определено, если этот символ изменен на любое значение, отличное от &lt;code&gt;CharT()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="90655817fab85d8ac14c5bbb029cd02bf793db95" translate="yes" xml:space="preserve">
          <source>For the last two rows of the table, &lt;code&gt;&lt;i&gt;num&lt;/i&gt;&lt;/code&gt; and &lt;code&gt;&lt;i&gt;den&lt;/i&gt;&lt;/code&gt; in the suffix are &lt;code&gt;Period::type::num&lt;/code&gt; and &lt;code&gt;Period::type::den&lt;/code&gt; formatted as a decimal number with no leading zeroes, respectively.</source>
          <target state="translated">Для двух последних строк таблицы &lt;code&gt;&lt;i&gt;num&lt;/i&gt;&lt;/code&gt; и &lt;code&gt;&lt;i&gt;den&lt;/i&gt;&lt;/code&gt; в суффиксе имеют формат &lt;code&gt;Period::type::num&lt;/code&gt; и &lt;code&gt;Period::type::den&lt;/code&gt; отформатированный как десятичное число без начальных нулей, соответственно.</target>
        </trans-unit>
        <trans-unit id="cbb5833c26a713296ad8005d9e28d5fc0bbfe8a6" translate="yes" xml:space="preserve">
          <source>For the name of a class or class template used within the definition of that class or template or derived from one, unqualified name lookup finds the class that's being defined as if the name was introduced by a member declaration (with public member access). For more detail, see &lt;a href=&quot;injected-class-name&quot;&gt;injected-class-name&lt;/a&gt;.</source>
          <target state="translated">Для имени класса или шаблона класса, используемого в определении этого класса или шаблона или производного от него, неквалифицированный поиск имени находит класс, который определяется так, как если бы имя было введено объявлением члена (с открытым доступом члена). Для получения более подробной информации смотрите имя &lt;a href=&quot;injected-class-name&quot;&gt;введенного класса&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="43ac5c7c822f021589a3f0df6c74ca1128531b73" translate="yes" xml:space="preserve">
          <source>For the number of elements in the range &lt;code&gt;[first, last)&lt;/code&gt; without any additional criteria, see &lt;code&gt;&lt;a href=&quot;../iterator/distance&quot;&gt;std::distance&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Количество элементов в диапазоне &lt;code&gt;[first, last)&lt;/code&gt; без каких-либо дополнительных критериев см. В &lt;code&gt;&lt;a href=&quot;../iterator/distance&quot;&gt;std::distance&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3eb35ae41318a2300948bfa04a8b59aa4c523fcb" translate="yes" xml:space="preserve">
          <source>For the objects of type &lt;code&gt;char&lt;/code&gt;, &lt;code&gt;signed char&lt;/code&gt;, and &lt;code&gt;unsigned char&lt;/code&gt; (unless they are oversize &lt;a href=&quot;bit_field&quot;&gt;bit fields&lt;/a&gt;), every bit of the object representation is required to participate in the value representation and each possible bit pattern represents a distinct value (no padding, trap bits, or multiple representations allowed).</source>
          <target state="translated">Для объектов типа &lt;code&gt;char&lt;/code&gt; , &lt;code&gt;signed char&lt;/code&gt; и &lt;code&gt;unsigned char&lt;/code&gt; (если они не являются &lt;a href=&quot;bit_field&quot;&gt;битовыми полями&lt;/a&gt; негабаритного размера ), каждый бит представления объекта должен участвовать в представлении значения, а каждый возможный битовый шаблон представляет отдельное значение (без заполнения, ловушки). биты или допускается несколько представлений).</target>
        </trans-unit>
        <trans-unit id="eda418fc0d7e0da6163efe2b320b70eff6e157ef" translate="yes" xml:space="preserve">
          <source>For the overload with an ExecutionPolicy, there may be a performance cost if ForwardIt's value type is not &lt;a href=&quot;../named_req/copyconstructible&quot;&gt;CopyConstructible&lt;/a&gt;.</source>
          <target state="translated">Для перегрузки с ExecutionPolicy может быть снижение производительности, если тип значения &lt;a href=&quot;../named_req/copyconstructible&quot;&gt;ForwardIt&lt;/a&gt; не CopyConstructible .</target>
        </trans-unit>
        <trans-unit id="e5b59a3fe5c4c6ada03047f0bc055b7cec5863b8" translate="yes" xml:space="preserve">
          <source>For the overloads with an ExecutionPolicy, there may be a performance cost if &lt;code&gt;ForwardIt1&lt;/code&gt;'s value_type is not &lt;a href=&quot;../named_req/moveconstructible&quot;&gt;MoveConstructible&lt;/a&gt;.</source>
          <target state="translated">Для перегрузок с ExecutionPolicy может быть &lt;code&gt;ForwardIt1&lt;/code&gt; производительности, если для value_type ForwardIt1 не &lt;a href=&quot;../named_req/moveconstructible&quot;&gt;указано значение MoveConstructible&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ca027ab75b905772f5d961e5c587aca010bc2ac6" translate="yes" xml:space="preserve">
          <source>For the overloads with an ExecutionPolicy, there may be a performance cost if the value type of &lt;code&gt;ForwardIterator1&lt;/code&gt; is not both &lt;a href=&quot;../named_req/copyconstructible&quot;&gt;CopyConstructible&lt;/a&gt; and &lt;a href=&quot;../named_req/copyassignable&quot;&gt;CopyAssignable&lt;/a&gt;.</source>
          <target state="translated">Для перегрузок с ExecutionPolicy может быть &lt;code&gt;ForwardIterator1&lt;/code&gt; производительности, если тип значения ForwardIterator1 не является одновременно &lt;a href=&quot;../named_req/copyconstructible&quot;&gt;CopyConstructible&lt;/a&gt; и &lt;a href=&quot;../named_req/copyassignable&quot;&gt;CopyAssignable&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ecf8e99bee770bd19c532d009a039c1a135e9bb1" translate="yes" xml:space="preserve">
          <source>For the purpose of &lt;a href=&quot;lookup&quot;&gt;name lookup&lt;/a&gt;, determining the type and value of the &lt;a href=&quot;this&quot;&gt;this pointer&lt;/a&gt; and for accessing non-static class members, the body of the closure type's function call operator is considered in the context of the lambda-expression.</source>
          <target state="translated">В целях &lt;a href=&quot;lookup&quot;&gt;поиска имени&lt;/a&gt; , определения типа и значения &lt;a href=&quot;this&quot;&gt;указателя this&lt;/a&gt; и для доступа к нестатическим членам класса тело оператора вызова функции типа замыкания рассматривается в контексте лямбда-выражения.</target>
        </trans-unit>
        <trans-unit id="65aeedb9e92b2d4cea74d76c9050bb672b686f5f" translate="yes" xml:space="preserve">
          <source>For the purpose of &lt;code&gt;scoped_allocator_adaptor&lt;/code&gt;, if the next inner allocator is &lt;code&gt;A&lt;/code&gt;, any class &lt;code&gt;T&lt;/code&gt; for which &lt;code&gt;&lt;a href=&quot;uses_allocator&quot;&gt;std::uses_allocator&lt;/a&gt;&amp;lt;T,A&amp;gt;::value == true&lt;/code&gt; participates in the recursion as if it was a container. Additionally, &lt;code&gt;&lt;a href=&quot;../utility/pair&quot;&gt;std::pair&lt;/a&gt;&lt;/code&gt; is treated as such a container by specific overloads of &lt;a href=&quot;scoped_allocator_adaptor/construct&quot;&gt;&lt;code&gt;scoped_allocator_adaptor::construct&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">В целях &lt;code&gt;scoped_allocator_adaptor&lt;/code&gt; , если следующим внутренним распределителем является &lt;code&gt;A&lt;/code&gt; , любой класс &lt;code&gt;T&lt;/code&gt; , для которого &lt;code&gt;&lt;a href=&quot;uses_allocator&quot;&gt;std::uses_allocator&lt;/a&gt;&amp;lt;T,A&amp;gt;::value == true&lt;/code&gt; участвует в рекурсии, как если бы он был контейнером. Кроме того, &lt;code&gt;&lt;a href=&quot;../utility/pair&quot;&gt;std::pair&lt;/a&gt;&lt;/code&gt; обрабатывается как такой контейнер специальными перегрузками &lt;a href=&quot;scoped_allocator_adaptor/construct&quot;&gt; &lt;code&gt;scoped_allocator_adaptor::construct&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4cae47b4767abaac03c592dbea46b05ec44cfc59" translate="yes" xml:space="preserve">
          <source>For the purpose of this trait, the extent to which an implementation determines that a type cannot meet the &lt;a href=&quot;../named_req/clock&quot;&gt;Clock&lt;/a&gt; requirements is unspecified, except that a minimum &lt;code&gt;T&lt;/code&gt; shall not qualify as a &lt;a href=&quot;../named_req/clock&quot;&gt;Clock&lt;/a&gt; unless it meets all of the following conditions:</source>
          <target state="translated">В целях этого признака степень, в которой реализация определяет, что тип не может соответствовать требованиям &lt;a href=&quot;../named_req/clock&quot;&gt;Clock,&lt;/a&gt; не определена, за исключением того, что минимальный &lt;code&gt;T&lt;/code&gt; не должен квалифицироваться как &lt;a href=&quot;../named_req/clock&quot;&gt;Clock,&lt;/a&gt; если он не удовлетворяет всем следующим условиям:</target>
        </trans-unit>
        <trans-unit id="fbf72513b1cc6b7e687b6187fddcae47438a5f71" translate="yes" xml:space="preserve">
          <source>For the purpose of this trait, two arrays have the same value if their elements have the same values, two non-union classes have the same value if their direct subobjects have the same value, and two unions have the same value if they have the same active member and the value of that member are the same.</source>
          <target state="translated">Для этого признака два массива имеют одинаковое значение,если их элементы имеют одинаковые значения,два несоюзных класса имеют одинаковое значение,если их прямые подобъекты имеют одинаковое значение,и два союза имеют одинаковое значение,если у них один и тот же активный член и значение этого члена одинаково.</target>
        </trans-unit>
        <trans-unit id="73e5a63a0091c86f2d780d4bd7205bd859be1626" translate="yes" xml:space="preserve">
          <source>For the purpose of unqualified name lookup, all declarations from a namespace nominated by a &lt;a href=&quot;namespace&quot;&gt;using directive&lt;/a&gt; appear as if declared in the nearest enclosing namespace which contains, directly or indirectly, both the using-directive and the nominated namespace.</source>
          <target state="translated">В целях поиска безоговорочного имени все объявления из пространства имен, назначенного с &lt;a href=&quot;namespace&quot;&gt;помощью директивы using,&lt;/a&gt; выглядят так, как будто они объявлены в ближайшем окружающем пространстве имен, которое прямо или косвенно содержит как директиву using, так и номинированное пространство имен.</target>
        </trans-unit>
        <trans-unit id="be7ff9400561e79a38fa934ba94eb51a08e444ed" translate="yes" xml:space="preserve">
          <source>For the purposes of the description below, a pointer type &lt;code&gt;Y*&lt;/code&gt; is said to be</source>
          <target state="translated">Для целей описания ниже указатель типа &lt;code&gt;Y*&lt;/code&gt; называется</target>
        </trans-unit>
        <trans-unit id="e8841a4885b112152b14a19649fc94d610b058fa" translate="yes" xml:space="preserve">
          <source>For the purposes of this check, the variable definition is never interpreted as a function declaration, and the use of &lt;code&gt;&lt;a href=&quot;../utility/declval&quot;&gt;std::declval&lt;/a&gt;&lt;/code&gt; is not considered an &lt;a href=&quot;../language/definition#ODR-use&quot;&gt;odr-use&lt;/a&gt;. &lt;a href=&quot;../language/access&quot;&gt;Access checks&lt;/a&gt; are performed as if from a context unrelated to &lt;code&gt;T&lt;/code&gt; and any of the types in &lt;code&gt;Args&lt;/code&gt;. Only the validity of the immediate context of the variable definition is considered.</source>
          <target state="translated">Для целей этой проверки определение переменной никогда не интерпретируется как объявление функции, и использование &lt;code&gt;&lt;a href=&quot;../utility/declval&quot;&gt;std::declval&lt;/a&gt;&lt;/code&gt; не считается &lt;a href=&quot;../language/definition#ODR-use&quot;&gt;odr-использованием&lt;/a&gt; . &lt;a href=&quot;../language/access&quot;&gt;Проверки доступа&lt;/a&gt; выполняются как будто из контекста, не связанного с &lt;code&gt;T&lt;/code&gt; и любым из типов в &lt;code&gt;Args&lt;/code&gt; . Учитывается только действительность непосредственного контекста определения переменной.</target>
        </trans-unit>
        <trans-unit id="0b9a3ac76356afb7c5f4a3ea00f4b7fb14d9e7d4" translate="yes" xml:space="preserve">
          <source>For the rest of overload resolution, the</source>
          <target state="translated">Для остальной части разрешения перегрузки</target>
        </trans-unit>
        <trans-unit id="a71380803d7225c2397b15d7056c647fe014ba63" translate="yes" xml:space="preserve">
          <source>For the sake of exposition, assume that &lt;code&gt;regex_iterator&lt;/code&gt; contains the following members:</source>
          <target state="translated">Предположим, что &lt;code&gt;regex_iterator&lt;/code&gt; содержит следующие члены:</target>
        </trans-unit>
        <trans-unit id="67321d4e15267f4eda7f0452bd90ebdb6e086831" translate="yes" xml:space="preserve">
          <source>For the second (array) form, expression must be a null pointer value or a pointer value previously obtained by an array form of &lt;a href=&quot;new&quot;&gt;new-expression&lt;/a&gt;. If expression is anything else, including if it's a pointer obtained by the non-array form of &lt;a href=&quot;new&quot;&gt;new-expression&lt;/a&gt;, the behavior is &lt;a href=&quot;ub&quot;&gt;undefined&lt;/a&gt;.</source>
          <target state="translated">Для второй формы (массива) выражение должно быть нулевым значением указателя или значением указателя, ранее полученным в виде массива &lt;a href=&quot;new&quot;&gt;new-expression&lt;/a&gt; . Если выражение - это что-то еще, в том числе указатель, полученный не-массивом формы &lt;a href=&quot;new&quot;&gt;new-expression&lt;/a&gt; , поведение не &lt;a href=&quot;ub&quot;&gt;определено&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a9c4273040bcad4221585f3c35b8ea39b7d5d39a" translate="yes" xml:space="preserve">
          <source>For the situations when three-way comparison is not required, &lt;code&gt;&lt;a href=&quot;../basic_string&quot;&gt;std::basic_string&lt;/a&gt;&lt;/code&gt; provides the usual &lt;a href=&quot;operator_cmp&quot;&gt;relational operators&lt;/a&gt; (&lt;code&gt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;lt;=&lt;/code&gt;, &lt;code&gt;==&lt;/code&gt;, &lt;code&gt;&amp;gt;&lt;/code&gt;, etc).</source>
          <target state="translated">Для ситуаций, когда трехстороннее сравнение не требуется, &lt;code&gt;&lt;a href=&quot;../basic_string&quot;&gt;std::basic_string&lt;/a&gt;&lt;/code&gt; предоставляет обычные &lt;a href=&quot;operator_cmp&quot;&gt;реляционные операторы&lt;/a&gt; ( &lt;code&gt;&amp;lt;&lt;/code&gt; , &lt;code&gt;&amp;lt;=&lt;/code&gt; , &lt;code&gt;==&lt;/code&gt; , &lt;code&gt;&amp;gt;&lt;/code&gt; и т. Д.).</target>
        </trans-unit>
        <trans-unit id="6f0ec42ffc782d2dbbdc18b148a303310b9bc1a6" translate="yes" xml:space="preserve">
          <source>For the specializations of &lt;code&gt;&lt;a href=&quot;../fpos&quot;&gt;std::fpos&lt;/a&gt;&lt;/code&gt; that are used in the standard library, &lt;code&gt;State&lt;/code&gt; is always &lt;code&gt;&lt;a href=&quot;../../string/multibyte/mbstate_t&quot;&gt;std::mbstate_t&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Для специализаций &lt;code&gt;&lt;a href=&quot;../fpos&quot;&gt;std::fpos&lt;/a&gt;&lt;/code&gt; , которые используются в стандартной библиотеке, &lt;code&gt;State&lt;/code&gt; всегда является &lt;code&gt;&lt;a href=&quot;../../string/multibyte/mbstate_t&quot;&gt;std::mbstate_t&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="144964c0df3039e3c71b1f52434a1f307b2a75a0" translate="yes" xml:space="preserve">
          <source>For the static member functions, the</source>
          <target state="translated">Для функций статического члена</target>
        </trans-unit>
        <trans-unit id="eb5c7ff9cfa9a962ebc4d24b7e58d44592b6e8bd" translate="yes" xml:space="preserve">
          <source>For the types that are both &lt;a href=&quot;../named_req/equalitycomparable&quot;&gt;EqualityComparable&lt;/a&gt; and &lt;a href=&quot;../named_req/lessthancomparable&quot;&gt;LessThanComparable&lt;/a&gt;, the C++ standard library makes a distinction between</source>
          <target state="translated">Для типов, которые являются &lt;a href=&quot;../named_req/equalitycomparable&quot;&gt;EqualityComparable&lt;/a&gt; и &lt;a href=&quot;../named_req/lessthancomparable&quot;&gt;LessThanComparable&lt;/a&gt; , стандартная библиотека C ++ делает различие между</target>
        </trans-unit>
        <trans-unit id="731f2b2536187de6fbaec0afbeb784f1678b4260" translate="yes" xml:space="preserve">
          <source>For the types that are both &lt;a href=&quot;equalitycomparable&quot;&gt;EqualityComparable&lt;/a&gt; and LessThanComparable, the C++ standard library makes a distinction between</source>
          <target state="translated">Для типов, которые являются &lt;a href=&quot;equalitycomparable&quot;&gt;EqualityComparable&lt;/a&gt; и LessThanComparable, стандартная библиотека C ++ делает различие между</target>
        </trans-unit>
        <trans-unit id="a44f5a2bb8a05cc20c72fea8758fde71db78f3d3" translate="yes" xml:space="preserve">
          <source>For the types that are both EqualityComparable and &lt;a href=&quot;lessthancomparable&quot;&gt;LessThanComparable&lt;/a&gt;, the C++ standard library makes a distinction between</source>
          <target state="translated">Для типов, которые являются EqualityComparable и &lt;a href=&quot;lessthancomparable&quot;&gt;LessThanComparable&lt;/a&gt; , стандартная библиотека C ++ делает различие между</target>
        </trans-unit>
        <trans-unit id="ea9de19131b3606684b0baafb3d2151f5a32dd40" translate="yes" xml:space="preserve">
          <source>For the use in derived class definitions, see &lt;a href=&quot;using_declaration&quot;&gt;using declaration&lt;/a&gt;.</source>
          <target state="translated">Для использования в определениях производного класса, смотрите &lt;a href=&quot;using_declaration&quot;&gt;использование объявления&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="48183fff740905d93ae3026fe871d3be4a4d9ec5" translate="yes" xml:space="preserve">
          <source>For two different parameters &lt;code&gt;k1&lt;/code&gt; and &lt;code&gt;k2&lt;/code&gt; that are not equal, the probability that &lt;code&gt;&lt;a href=&quot;../hash&quot;&gt;std::hash&lt;/a&gt;&amp;lt;Key&amp;gt;()(k1) == &lt;a href=&quot;../hash&quot;&gt;std::hash&lt;/a&gt;&amp;lt;Key&amp;gt;()(k2)&lt;/code&gt; should be very small, approaching &lt;code&gt;1.0/&lt;a href=&quot;../../types/numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;size_t&amp;gt;::max()&lt;/code&gt;.</source>
          <target state="translated">Для двух разных параметров &lt;code&gt;k1&lt;/code&gt; и &lt;code&gt;k2&lt;/code&gt; , которые не равны, вероятность того, что &lt;code&gt;&lt;a href=&quot;../hash&quot;&gt;std::hash&lt;/a&gt;&amp;lt;Key&amp;gt;()(k1) == &lt;a href=&quot;../hash&quot;&gt;std::hash&lt;/a&gt;&amp;lt;Key&amp;gt;()(k2)&lt;/code&gt; должна быть очень мала, приближаясь к &lt;code&gt;1.0/&lt;a href=&quot;../../types/numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;size_t&amp;gt;::max()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cc4402b538e707e656178152f7bd8d1b40d16256" translate="yes" xml:space="preserve">
          <source>For two parameters &lt;code&gt;k1&lt;/code&gt; and &lt;code&gt;k2&lt;/code&gt; that are equal, &lt;code&gt;&lt;a href=&quot;../hash&quot;&gt;std::hash&lt;/a&gt;&amp;lt;Key&amp;gt;()(k1) == &lt;a href=&quot;../hash&quot;&gt;std::hash&lt;/a&gt;&amp;lt;Key&amp;gt;()(k2)&lt;/code&gt;.</source>
          <target state="translated">Для двух одинаковых параметров &lt;code&gt;k1&lt;/code&gt; и &lt;code&gt;k2&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;../hash&quot;&gt;std::hash&lt;/a&gt;&amp;lt;Key&amp;gt;()(k1) == &lt;a href=&quot;../hash&quot;&gt;std::hash&lt;/a&gt;&amp;lt;Key&amp;gt;()(k2)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="94a3ad0257f1ac1480c81596b592db0d4b3511aa" translate="yes" xml:space="preserve">
          <source>For two-digit input values, many implementations use the same parsing rules as the conversion specifier &lt;code&gt;'%y'&lt;/code&gt; as used by &lt;code&gt;&lt;a href=&quot;../../io/manip/get_time&quot;&gt;std::get_time&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;get&quot;&gt;std::time_get::get()&lt;/a&gt;&lt;/code&gt;, and the POSIX function &lt;code&gt;strptime()&lt;/code&gt;: two-digit integer is expected, the values in the range [69,99] results in values 1969 to 1999, range [00,68] results in 2000-2068. Four-digit inputs are typically accepted as-is.</source>
          <target state="translated">Для двузначных входных значений многие реализации используют те же правила синтаксического анализа, что и спецификатор преобразования &lt;code&gt;'%y'&lt;/code&gt; используемый &lt;code&gt;&lt;a href=&quot;../../io/manip/get_time&quot;&gt;std::get_time&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;get&quot;&gt;std::time_get::get()&lt;/a&gt;&lt;/code&gt; и функцией POSIX. &lt;code&gt;strptime()&lt;/code&gt; : two- ожидается целое число цифр, значения в диапазоне [69,99] приводят к значениям с 1969 по 1999 год, в диапазоне [00,68] результаты в 2000-2068 годах. Четырехзначные входные данные обычно принимаются как есть.</target>
        </trans-unit>
        <trans-unit id="642cd801d14b4a66f154da3cc51856b49e293f28" translate="yes" xml:space="preserve">
          <source>For two-way comparisons, &lt;a href=&quot;operator_cmp&quot;&gt;binary operators&lt;/a&gt; may be more suitable.</source>
          <target state="translated">Для двусторонних сравнений, &lt;a href=&quot;operator_cmp&quot;&gt; бинарные операторы&lt;/a&gt; могут быть более подходящими.</target>
        </trans-unit>
        <trans-unit id="fe584cd3d04227e8ee6e63e57235b2b1a239458e" translate="yes" xml:space="preserve">
          <source>For type &lt;code&gt;L&lt;/code&gt; to be BasicLockable, the following conditions have to be satisfied for an object &lt;code&gt;m&lt;/code&gt; of type &lt;code&gt;L&lt;/code&gt;:</source>
          <target state="translated">Чтобы тип &lt;code&gt;L&lt;/code&gt; был BasicLockable, следующие условия должны быть выполнены для объекта &lt;code&gt;m&lt;/code&gt; типа &lt;code&gt;L&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="a492045a60cf54bb3785e73eca1da2d9437cc013" translate="yes" xml:space="preserve">
          <source>For type &lt;code&gt;L&lt;/code&gt; to be Lockable, it must meet the above condition as well as the following:</source>
          <target state="translated">Чтобы тип &lt;code&gt;L&lt;/code&gt; был блокируемым, он должен удовлетворять вышеуказанному условию, а также следующим условиям:</target>
        </trans-unit>
        <trans-unit id="3192f26467193016e7a310e7cb38a3fb281f3879" translate="yes" xml:space="preserve">
          <source>For type &lt;code&gt;L&lt;/code&gt; to be TimedLockable, the following conditions have to be satisfied for an object &lt;code&gt;m&lt;/code&gt; of type &lt;code&gt;L&lt;/code&gt;:</source>
          <target state="translated">Чтобы тип &lt;code&gt;L&lt;/code&gt; был TimedLockable, для объекта &lt;code&gt;m&lt;/code&gt; типа &lt;code&gt;L&lt;/code&gt; должны быть выполнены следующие условия :</target>
        </trans-unit>
        <trans-unit id="e5e7522e5abd30c0f3d5e5a223c5721c59cbeef9" translate="yes" xml:space="preserve">
          <source>For unsigned &lt;code&gt;a&lt;/code&gt; and for signed and non-negative &lt;code&gt;a&lt;/code&gt;, the value of &lt;code&gt;a &amp;gt;&amp;gt; b&lt;/code&gt; is the integer part of a/2b</source>
          <target state="translated">Для беззнаковых &lt;code&gt;a&lt;/code&gt; и для подписанных и неотрицательных &lt;code&gt;a&lt;/code&gt; значение &lt;code&gt;a &amp;gt;&amp;gt; b&lt;/code&gt; является целой частью a / 2b</target>
        </trans-unit>
        <trans-unit id="aebdb0e43e858256601ff6d8a7d5738865f2a1f9" translate="yes" xml:space="preserve">
          <source>For unsigned &lt;code&gt;a&lt;/code&gt;, the value of &lt;code&gt;a &amp;lt;&amp;lt; b&lt;/code&gt; is the value of a * 2b</source>
          <target state="translated">Для беззнакового &lt;code&gt;a&lt;/code&gt; значение &lt;code&gt;a &amp;lt;&amp;lt; b&lt;/code&gt; является значением a * 2b</target>
        </trans-unit>
        <trans-unit id="d49c3968569060d907f70256e73011fe41b82ee7" translate="yes" xml:space="preserve">
          <source>For variables and other names introduced by simple declarations, the point of declaration is immediately after that name's &lt;a href=&quot;declarations#Declarators&quot;&gt;declarator&lt;/a&gt; and before its initializer, if any:</source>
          <target state="translated">Для переменных и других имен, вводимых простыми декларациями, точка объявления находится сразу после &lt;a href=&quot;declarations#Declarators&quot;&gt;декларатора&lt;/a&gt; этого имени и перед его инициализатором, если он есть:</target>
        </trans-unit>
        <trans-unit id="4406791fdc0c802a309313fed6968b3cbed9aba4" translate="yes" xml:space="preserve">
          <source>For variables, specifies that the type of the variable that is being declared will be automatically deduced from its initializer.</source>
          <target state="translated">Для переменных указывает,что тип объявляемой переменной будет автоматически выведен из ее инициализатора.</target>
        </trans-unit>
        <trans-unit id="5c276069327cb6d9e2ff643e9fb634c6f1cb43de" translate="yes" xml:space="preserve">
          <source>For version (2), the number of arguments must be the same as the number of parameters in macro definition. For versions (3,4), the number of arguments must be more than(until C++20)at least as many as(since C++20) the number of parameters (not counting &lt;code&gt;...&lt;/code&gt;). Otherwise the program is ill-formed. If the identifier is not in functional-notation, i.e. does not have parentheses after itself, it is not replaced at all.</source>
          <target state="translated">Для версии (2) количество аргументов должно совпадать с количеством параметров в определении макроса. Для версий (3,4) количество аргументов должно быть больше, чем (до C ++ 20), по крайней мере, столько же, сколько (начиная с C ++ 20) количества параметров (не считая &lt;code&gt;...&lt;/code&gt; ). В противном случае программа не работает. Если идентификатор не находится в функциональной нотации, т.е. не имеет скобок после себя, он вообще не заменяется.</target>
        </trans-unit>
        <trans-unit id="1eb818e764a2afb52d153586d87b0ff7106e9cc9" translate="yes" xml:space="preserve">
          <source>For versions (3,4), replacement-list may contain the token sequence &lt;code&gt;__VA_OPT__ (&lt;/code&gt;content&lt;code&gt;)&lt;/code&gt;, which is replaced by content if &lt;code&gt;__VA_ARGS__&lt;/code&gt; is non-empty, and expands to nothing otherwise.</source>
          <target state="translated">Для версий (3,4) замена-список может содержать последовательность токенов &lt;code&gt;__VA_OPT__ (&lt;/code&gt; контент &lt;code&gt;)&lt;/code&gt; , которая заменяется контентом, если &lt;code&gt;__VA_ARGS__&lt;/code&gt; не пуста, и в противном случае расширяется до нуля.</target>
        </trans-unit>
        <trans-unit id="689abf1f4ab72838db75e84748d7996dea17600f" translate="yes" xml:space="preserve">
          <source>For virtual calls (if the bases are initialized), the same rules apply as the rules for the virtual calls from constructors and destructors: virtual member functions behave as if the dynamic type of &lt;code&gt;*this&lt;/code&gt; is the class that's being constructed (dynamic dispatch does not propagate down the inheritance hierarchy) and virtual calls (but not static calls) to &lt;a href=&quot;abstract_class&quot;&gt;pure virtual&lt;/a&gt; member functions are undefined behavior.</source>
          <target state="translated">Для виртуальных вызовов (если базы инициализированы) применяются те же правила, что и для виртуальных вызовов от конструкторов и деструкторов: виртуальные функции-члены ведут себя так, как будто динамический тип &lt;code&gt;*this&lt;/code&gt; класс, который создается (динамическая диспетчеризация не распространяться вниз по иерархии наследования) и виртуальные вызовы (но не статические вызовы) на &lt;a href=&quot;abstract_class&quot;&gt;чисто виртуальные&lt;/a&gt; функции-члены являются неопределенным поведением.</target>
        </trans-unit>
        <trans-unit id="0c5f085443078183be6555b610a3066515f2b25f" translate="yes" xml:space="preserve">
          <source>For zero-sized arrays,</source>
          <target state="translated">Для массивов нулевого размера,</target>
        </trans-unit>
        <trans-unit id="0a460a0808dc0afa3b1cab6d45b0c32f450b8082" translate="yes" xml:space="preserve">
          <source>Forcing a copy assignment operator to be generated by the compiler.</source>
          <target state="translated">Принудительная генерация компилятором оператора присваивания копий.</target>
        </trans-unit>
        <trans-unit id="11ad1e8557a20546e9537fc0a5b3a329b83d8d13" translate="yes" xml:space="preserve">
          <source>Forcing a copy constructor to be generated by the compiler.</source>
          <target state="translated">Принудительная генерация компилятором конструктора копирования.</target>
        </trans-unit>
        <trans-unit id="dd180500aac427aa2facdbe0b7cd406cce37ac98" translate="yes" xml:space="preserve">
          <source>Forcing a move assignment operator to be generated by the compiler.</source>
          <target state="translated">Принуждение компилятора к генерации оператора присваивания движения.</target>
        </trans-unit>
        <trans-unit id="b5ea5bcf5fc337ca9689a82c3a3c7580484f1408" translate="yes" xml:space="preserve">
          <source>Forcing a move constructor to be generated by the compiler.</source>
          <target state="translated">Принудительная генерация компилятором конструктора перемещения.</target>
        </trans-unit>
        <trans-unit id="72ef49edf9ca8e31454f8e3e5987fc43ac16422c" translate="yes" xml:space="preserve">
          <source>Form (3) is a special case of elaborated type specifier, usually referred to as</source>
          <target state="translated">Форма (3)является особым случаем спецификатора разработанного типа,обычно называемого</target>
        </trans-unit>
        <trans-unit id="3851c6a3b646b09f934a18b67d308cc11979b8c6" translate="yes" xml:space="preserve">
          <source>Formal definition of</source>
          <target state="translated">Формальное определение</target>
        </trans-unit>
        <trans-unit id="617d00cd751356da85b2e1f1f2eca6aa12a756a0" translate="yes" xml:space="preserve">
          <source>Formal description</source>
          <target state="translated">Формальное описание</target>
        </trans-unit>
        <trans-unit id="3bfb55cdc85542de2eeac7c01ac22e44b5143662" translate="yes" xml:space="preserve">
          <source>Formally,</source>
          <target state="translated">Formally,</target>
        </trans-unit>
        <trans-unit id="be2c3615928f7aa5bc5a7d980eb4d06a17642a73" translate="yes" xml:space="preserve">
          <source>Formally, &lt;code&gt;StrictTotallyOrderedWith&amp;lt;T, U&amp;gt;&lt;/code&gt; is satisfied only if, given any lvalue &lt;code&gt;t&lt;/code&gt; of type &lt;code&gt;const &lt;a href=&quot;../types/remove_reference&quot;&gt;std::remove_reference_t&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt; and any lvalue &lt;code&gt;u&lt;/code&gt; of type &lt;code&gt;const &lt;a href=&quot;../types/remove_reference&quot;&gt;std::remove_reference_t&lt;/a&gt;&amp;lt;U&amp;gt;&lt;/code&gt;, and let &lt;code&gt;C&lt;/code&gt; be &lt;code&gt;&lt;a href=&quot;../types/common_reference&quot;&gt;std::common_reference_t&lt;/a&gt;&amp;lt;const &lt;a href=&quot;../types/remove_reference&quot;&gt;std::remove_reference_t&lt;/a&gt;&amp;lt;T&amp;gt;&amp;amp;, const &lt;a href=&quot;../types/remove_reference&quot;&gt;std::remove_reference_t&lt;/a&gt;&amp;lt;U&amp;gt;&amp;amp;&amp;gt;&lt;/code&gt; :</source>
          <target state="translated">Формально &lt;code&gt;StrictTotallyOrderedWith&amp;lt;T, U&amp;gt;&lt;/code&gt; выполняется только в том случае, если при наличии любого значения &lt;code&gt;t&lt;/code&gt; типа &lt;code&gt;const &lt;a href=&quot;../types/remove_reference&quot;&gt;std::remove_reference_t&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt; и любого значения &lt;code&gt;u&lt;/code&gt; типа &lt;code&gt;const &lt;a href=&quot;../types/remove_reference&quot;&gt;std::remove_reference_t&lt;/a&gt;&amp;lt;U&amp;gt;&lt;/code&gt; и пусть &lt;code&gt;C&lt;/code&gt; будет &lt;code&gt;&lt;a href=&quot;../types/common_reference&quot;&gt;std::common_reference_t&lt;/a&gt;&amp;lt;const &lt;a href=&quot;../types/remove_reference&quot;&gt;std::remove_reference_t&lt;/a&gt;&amp;lt;T&amp;gt;&amp;amp;, const &lt;a href=&quot;../types/remove_reference&quot;&gt;std::remove_reference_t&lt;/a&gt;&amp;lt;U&amp;gt;&amp;amp;&amp;gt;&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="ac3a456d751219d7a66e0d0371e02798d8d5d3ea" translate="yes" xml:space="preserve">
          <source>Formally, a substring &lt;code&gt;str&lt;/code&gt; is said to be</source>
          <target state="translated">Формально подстрока &lt;code&gt;str&lt;/code&gt; называется</target>
        </trans-unit>
        <trans-unit id="8819ae53d6eeeb966d61dd310165099d50cdc3e7" translate="yes" xml:space="preserve">
          <source>Formally, a template template-parameter &lt;code&gt;P&lt;/code&gt; is at least as specialized as a template template argument &lt;code&gt;A&lt;/code&gt; if, given the following rewrite to two function templates, the function template corresponding to &lt;code&gt;P&lt;/code&gt; is at least as specialized as the function template corresponding to &lt;code&gt;A&lt;/code&gt; according to the partial ordering rules for &lt;a href=&quot;function_template&quot;&gt;function templates&lt;/a&gt;. Given an invented class template &lt;code&gt;X &lt;/code&gt; with the template parameter list of &lt;code&gt;A&lt;/code&gt; (including default arguments):</source>
          <target state="translated">Формально шаблон-параметр шаблона &lt;code&gt;P&lt;/code&gt; , по крайней мере, столь же специализирован, как аргумент шаблона шаблона &lt;code&gt;A&lt;/code&gt; , если, учитывая следующее переписывание двух шаблонов функций, шаблон функции, соответствующий &lt;code&gt;P&lt;/code&gt; , по крайней мере, столь же специализирован, как шаблон функции, соответствующий &lt;code&gt;A&lt;/code&gt; согласно правила частичного упорядочения для &lt;a href=&quot;function_template&quot;&gt;шаблонов функций&lt;/a&gt; . Придумал придуманный шаблон класса &lt;code&gt;X &lt;/code&gt; со списком параметров шаблона &lt;code&gt;A&lt;/code&gt; (включая аргументы по умолчанию):</target>
        </trans-unit>
        <trans-unit id="117e56a1f0fa17b3f88e2093765a4fbfc78944a1" translate="yes" xml:space="preserve">
          <source>Formally, assigns through each iterator &lt;code&gt;i&lt;/code&gt; in [d_first, d_first + (last - first)) the value of the generalized noncommutative sum of &lt;code&gt;init, *j...&lt;/code&gt; for every &lt;code&gt;j&lt;/code&gt; in [first, first + (i - d_first)) over &lt;code&gt;binary_op&lt;/code&gt;,</source>
          <target state="translated">Формально присваивает через каждый итератор &lt;code&gt;i&lt;/code&gt; в [d_first, d_first + (last - first)) значение обобщенной некоммутативной суммы &lt;code&gt;init, *j...&lt;/code&gt; для каждого &lt;code&gt;j&lt;/code&gt; в [first, first + (i - d_first)) в течение &lt;code&gt;binary_op&lt;/code&gt; ,</target>
        </trans-unit>
        <trans-unit id="67dce949f95f6583a76648b394095c1ec1ca39c5" translate="yes" xml:space="preserve">
          <source>Formally, assigns through each iterator &lt;code&gt;i&lt;/code&gt; in [d_first, d_first + (last - first)) the value of the generalized noncommutative sum of &lt;code&gt;init, unary_op(*j)...&lt;/code&gt; for every &lt;code&gt;j&lt;/code&gt; in [first, first + (i - d_first)) over &lt;code&gt;binary_op&lt;/code&gt;,</source>
          <target state="translated">Формально присваивает через каждый итератор &lt;code&gt;i&lt;/code&gt; в [d_first, d_first + (last - first)) значение обобщенной некоммутативной суммы &lt;code&gt;init, unary_op(*j)...&lt;/code&gt; для каждого &lt;code&gt;j&lt;/code&gt; в [first, first + (i - d_first) )) более &lt;code&gt;binary_op&lt;/code&gt; ,</target>
        </trans-unit>
        <trans-unit id="95a3ed38da232217c4f6f08f54e48cb7d257ddec" translate="yes" xml:space="preserve">
          <source>Formally, assigns through each iterator &lt;code&gt;i&lt;/code&gt; in [d_first, d_first + (last - first)) the value of.</source>
          <target state="translated">Формально присваивает через каждый итератор &lt;code&gt;i&lt;/code&gt; [d_first, d_first + (last - first)).</target>
        </trans-unit>
        <trans-unit id="42355d6a7c2d7676346a2158f0e06426adf8925e" translate="yes" xml:space="preserve">
          <source>Formally, assigns through each iterator &lt;code&gt;i&lt;/code&gt; in [d_first, d_first + (last - first)) the value of:</source>
          <target state="translated">Формально присваивает через каждый итератор &lt;code&gt;i&lt;/code&gt; в [d_first, d_first + (last - first)) значение:</target>
        </trans-unit>
        <trans-unit id="aa803427d4e1d44c6149f49a34143aabb8a952e0" translate="yes" xml:space="preserve">
          <source>Formally, for each &lt;code&gt;i&lt;/code&gt; in &lt;code&gt;[0, count)&lt;/code&gt;, performs &lt;code&gt;assign(src[i], dest[i])&lt;/code&gt;.</source>
          <target state="translated">Формально для каждого &lt;code&gt;i&lt;/code&gt; в &lt;code&gt;[0, count)&lt;/code&gt; выполняет &lt;code&gt;assign(src[i], dest[i])&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="554c2426b4e5c1f78a13a29231a721f516bd1cbf" translate="yes" xml:space="preserve">
          <source>Formally, given an expression &lt;code&gt;E&lt;/code&gt; such that &lt;code&gt;decltype((E))&lt;/code&gt; is &lt;code&gt;T&lt;/code&gt; and an lvalue &lt;code&gt;t&lt;/code&gt; that denotes the same object as &lt;code&gt;E&lt;/code&gt;, &lt;code&gt;T&lt;/code&gt; models &lt;code&gt;__ForwardingRange&lt;/code&gt; only if.</source>
          <target state="translated">Формально, учитывая выражение &lt;code&gt;E&lt;/code&gt; такое, что &lt;code&gt;decltype((E))&lt;/code&gt; равно &lt;code&gt;T&lt;/code&gt; , а l-значение &lt;code&gt;t&lt;/code&gt; , которое обозначает тот же объект, что и &lt;code&gt;E&lt;/code&gt; , &lt;code&gt;T&lt;/code&gt; моделирует &lt;code&gt;__ForwardingRange&lt;/code&gt; , только если.</target>
        </trans-unit>
        <trans-unit id="f43c3db9c814c3ddff2a854cf059e58f985b2721" translate="yes" xml:space="preserve">
          <source>Formally, given an expression &lt;code&gt;E&lt;/code&gt; such that &lt;code&gt;decltype((E))&lt;/code&gt; is &lt;code&gt;T&lt;/code&gt;, &lt;code&gt;T&lt;/code&gt; models &lt;code&gt;&lt;a href=&quot;../range/range&quot;&gt;Range&lt;/a&gt;&lt;/code&gt; only if.</source>
          <target state="translated">Формально, учитывая выражение &lt;code&gt;E&lt;/code&gt; такое, что &lt;code&gt;decltype((E))&lt;/code&gt; равно &lt;code&gt;T&lt;/code&gt; , &lt;code&gt;T&lt;/code&gt; моделирует &lt;code&gt;&lt;a href=&quot;../range/range&quot;&gt;Range&lt;/a&gt;&lt;/code&gt; только в том случае, если.</target>
        </trans-unit>
        <trans-unit id="067b1a2613c21e1fd48648c5caa1394000d7f227" translate="yes" xml:space="preserve">
          <source>Formally, given.</source>
          <target state="translated">Формально,учитывая.</target>
        </trans-unit>
        <trans-unit id="b90f213e247d65d8f658b379e51068d2511abb68" translate="yes" xml:space="preserve">
          <source>Formally, if &lt;code&gt;E&lt;/code&gt; and &lt;code&gt;F&lt;/code&gt; are expressions, and &lt;code&gt;T&lt;/code&gt; is the type &lt;code&gt;&lt;a href=&quot;../types/decay&quot;&gt;std::decay_t&lt;/a&gt;&amp;lt;decltype((E))&amp;gt;&lt;/code&gt;, then.</source>
          <target state="translated">Формально, если &lt;code&gt;E&lt;/code&gt; и &lt;code&gt;F&lt;/code&gt; - выражения, а &lt;code&gt;T&lt;/code&gt; - это тип &lt;code&gt;&lt;a href=&quot;../types/decay&quot;&gt;std::decay_t&lt;/a&gt;&amp;lt;decltype((E))&amp;gt;&lt;/code&gt; , то.</target>
        </trans-unit>
        <trans-unit id="67f89cac3a2bdd1a32a9d4e925980ecdcd1ff780" translate="yes" xml:space="preserve">
          <source>Formally, returns a value &lt;code&gt;e&lt;/code&gt; such that &lt;code&gt;X::eq_int_type(e, X::to_int_type(c))&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt; for all values &lt;code&gt;c&lt;/code&gt;.</source>
          <target state="translated">Формально возвращает значение &lt;code&gt;e&lt;/code&gt; такое, что &lt;code&gt;X::eq_int_type(e, X::to_int_type(c))&lt;/code&gt; является &lt;code&gt;false&lt;/code&gt; для всех значений &lt;code&gt;c&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ba8bfc3113f8f3e8c405a965d6f37d86be2d7991" translate="yes" xml:space="preserve">
          <source>Formally, returns the value &lt;code&gt;x&lt;/code&gt; such that &lt;code&gt;X::eq_int_type(c, X::to_int_type(x))&lt;/code&gt; is true, and an unspecified value if no such &lt;code&gt;x&lt;/code&gt; exists.</source>
          <target state="translated">Формально возвращает значение &lt;code&gt;x&lt;/code&gt; таким образом, что &lt;code&gt;X::eq_int_type(c, X::to_int_type(x))&lt;/code&gt; равно true, и неопределенное значение, если такого &lt;code&gt;x&lt;/code&gt; нет существует.</target>
        </trans-unit>
        <trans-unit id="52d033134dacb8018588f4302d9453d80ec19597" translate="yes" xml:space="preserve">
          <source>Formally, the</source>
          <target state="translated">Формально</target>
        </trans-unit>
        <trans-unit id="52e0a6f1e0d63a4dd3bc991539c544e18482cfab" translate="yes" xml:space="preserve">
          <source>Formally, the C++ standard makes no guarantee on the accuracy of floating-point operations.</source>
          <target state="translated">Формально стандарт C++не дает никаких гарантий на точность операций с плавающей точкой.</target>
        </trans-unit>
        <trans-unit id="95a4b2acf26b1c49aea8abebe466f09b5002e38b" translate="yes" xml:space="preserve">
          <source>Formally, the syntax is.</source>
          <target state="translated">Формально,синтаксис.</target>
        </trans-unit>
        <trans-unit id="3e6350defe07d4e2839cc6eb5191b1da5190bee4" translate="yes" xml:space="preserve">
          <source>Formally, the unbiased exponent is the integral part of log</source>
          <target state="translated">Формально непредвзятый экспонент является неотъемлемой частью бревна.</target>
        </trans-unit>
        <trans-unit id="91dd56eddc735a099ddc37f2c2b8d705630baadf" translate="yes" xml:space="preserve">
          <source>Formally, the unbiased exponent is the signed integral part of log</source>
          <target state="translated">Формально непредвзятым экспонентом является подписанная неотъемлемая часть бревна.</target>
        </trans-unit>
        <trans-unit id="8179a0c7fe36d2a8a17e5adad38978ddb099049d" translate="yes" xml:space="preserve">
          <source>Formally, to determine which of any two function templates is more specialized, the partial ordering process first transforms one of the two templates as follows:</source>
          <target state="translated">Формально,чтобы определить,какой из двух шаблонов функций является более специализированным,процесс частичного заказа сначала преобразует один из двух шаблонов следующим образом:</target>
        </trans-unit>
        <trans-unit id="3636bbcd81222a968d5588186dbdf6c4b0b042e0" translate="yes" xml:space="preserve">
          <source>Formally, to establish more-specialized-than relationship between partial specializations, each is first converted to a fictitious function template as follows:</source>
          <target state="translated">Формально,чтобы установить более специализированные,чем связь между частичными специализациями,каждая из них сначала преобразуется в вымышленный шаблон функции следующим образом:</target>
        </trans-unit>
        <trans-unit id="f2967eb9e0cfcedd6a189b6a8d3866a634ebbc35" translate="yes" xml:space="preserve">
          <source>Formally.</source>
          <target state="translated">Formally.</target>
        </trans-unit>
        <trans-unit id="041a5dec481d6bf0724caeaa84bc135d7d9062d4" translate="yes" xml:space="preserve">
          <source>Format</source>
          <target state="translated">Format</target>
        </trans-unit>
        <trans-unit id="9d6e5b21d4a23bd5ccd62830a8a750d8fe1ca459" translate="yes" xml:space="preserve">
          <source>Format constants for the &lt;code&gt;&lt;a href=&quot;../io/c/printf&quot;&gt;std::fprintf&lt;/a&gt;&lt;/code&gt; family of functions</source>
          <target state="translated">Константы формата для &lt;code&gt;&lt;a href=&quot;../io/c/printf&quot;&gt;std::fprintf&lt;/a&gt;&lt;/code&gt; семейства функций</target>
        </trans-unit>
        <trans-unit id="2baad9ad4884ebddda05c6c67af479131ae29e6b" translate="yes" xml:space="preserve">
          <source>Format constants for the &lt;code&gt;&lt;a href=&quot;../io/c/scanf&quot;&gt;std::fscanf&lt;/a&gt;&lt;/code&gt; family of functions</source>
          <target state="translated">Константы формата для &lt;code&gt;&lt;a href=&quot;../io/c/scanf&quot;&gt;std::fscanf&lt;/a&gt;&lt;/code&gt; семейства функций</target>
        </trans-unit>
        <trans-unit id="6b8afd05c64332502d3616cc67779e98de2c7168" translate="yes" xml:space="preserve">
          <source>Format conversions</source>
          <target state="translated">Преобразование форматов</target>
        </trans-unit>
        <trans-unit id="7175d023e27abe317865a491022a09c5f080a380" translate="yes" xml:space="preserve">
          <source>Format macro constants</source>
          <target state="translated">Макроконстанты формата</target>
        </trans-unit>
        <trans-unit id="9316b4e7eba6949a72f828ee21024df921672e3c" translate="yes" xml:space="preserve">
          <source>Format observers</source>
          <target state="translated">Наблюдатели формата</target>
        </trans-unit>
        <trans-unit id="f544ee1a7acc5ea325b43ab1bc03f12126274ad5" translate="yes" xml:space="preserve">
          <source>Format string</source>
          <target state="translated">Форматная строка</target>
        </trans-unit>
        <trans-unit id="c4bb81b6ba2e3eacfc477a97d7def7d80d2c55be" translate="yes" xml:space="preserve">
          <source>Formats monetary value and writes the result to output stream.</source>
          <target state="translated">Форматирует денежное выражение и записывает результат в выходной поток.</target>
        </trans-unit>
        <trans-unit id="7c20d6ad01a878bb9e8639e10169a49131276aca" translate="yes" xml:space="preserve">
          <source>Formats the streamable object &lt;code&gt;s&lt;/code&gt; using the format string &lt;code&gt;fmt&lt;/code&gt; and the locale &lt;code&gt;loc&lt;/code&gt; (if provided).</source>
          <target state="translated">Форматирует потоковый объект &lt;code&gt;s&lt;/code&gt; использованием строки формата &lt;code&gt;fmt&lt;/code&gt; и locale &lt;code&gt;loc&lt;/code&gt; . (если есть).</target>
        </trans-unit>
        <trans-unit id="8bf1052f7f8c855373309b9742ea3d34a8c56846" translate="yes" xml:space="preserve">
          <source>Formatted input</source>
          <target state="translated">Форматированный ввод</target>
        </trans-unit>
        <trans-unit id="ee59b03a5ff5c727bd5ce0a27fd2bc91e970bc1f" translate="yes" xml:space="preserve">
          <source>Formatted input/output</source>
          <target state="translated">Форматированный ввод/вывод</target>
        </trans-unit>
        <trans-unit id="c7cf7a590d478b0b7b99c49e642af36f47cd56e2" translate="yes" xml:space="preserve">
          <source>Formatted output</source>
          <target state="translated">Форматированный вывод</target>
        </trans-unit>
        <trans-unit id="722101e27f69cbe90326b9ee974bad21c5f7f772" translate="yes" xml:space="preserve">
          <source>Formatted output functions &lt;a href=&quot;../basic_ostream/operator_ltlt&quot;&gt;operator&amp;lt;&amp;lt;&lt;/a&gt;, &lt;code&gt;&lt;a href=&quot;../manip/put_money&quot;&gt;std::put_money&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;../manip/put_time&quot;&gt;std::put_time&lt;/a&gt;&lt;/code&gt;, if they encounter the end of the output stream before completing output.</source>
          <target state="translated">&lt;a href=&quot;../basic_ostream/operator_ltlt&quot;&gt;Операторы&lt;/a&gt; форматированных функций вывода &amp;lt;&amp;lt; , &lt;code&gt;&lt;a href=&quot;../manip/put_money&quot;&gt;std::put_money&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;../manip/put_time&quot;&gt;std::put_time&lt;/a&gt;&lt;/code&gt; , если они сталкиваются с концом потока вывода перед завершением вывода.</target>
        </trans-unit>
        <trans-unit id="c36735a1b156faf0d8948786e00b3f1ee63bfe64" translate="yes" xml:space="preserve">
          <source>FormattedInputFunction</source>
          <target state="translated">FormattedInputFunction</target>
        </trans-unit>
        <trans-unit id="8ad283919e38bfa7958b6669077f83561656b04b" translate="yes" xml:space="preserve">
          <source>FormattedOutputFunction</source>
          <target state="translated">FormattedOutputFunction</target>
        </trans-unit>
        <trans-unit id="841f832857c780b47f478b4f21d34d8995af64b8" translate="yes" xml:space="preserve">
          <source>Formatting</source>
          <target state="translated">Formatting</target>
        </trans-unit>
        <trans-unit id="4f6565ce2772bffe98b3ba5983af96ce7e5de363" translate="yes" xml:space="preserve">
          <source>Forms a &lt;code&gt;&lt;a href=&quot;../complex&quot;&gt;std::complex&lt;/a&gt;&lt;/code&gt; literal representing an imaginary number.</source>
          <target state="translated">Формирует &lt;code&gt;&lt;a href=&quot;../complex&quot;&gt;std::complex&lt;/a&gt;&lt;/code&gt; литерал представляющий мнимое число.</target>
        </trans-unit>
        <trans-unit id="643fc7954cfd8223ed9cf2e31d62065c242ec93d" translate="yes" xml:space="preserve">
          <source>Forms a &lt;code&gt;&lt;a href=&quot;duration&quot;&gt;std::chrono::duration&lt;/a&gt;&lt;/code&gt; literal representing hours.</source>
          <target state="translated">Формирует &lt;code&gt;&lt;a href=&quot;duration&quot;&gt;std::chrono::duration&lt;/a&gt;&lt;/code&gt; литерал представляющий часы.</target>
        </trans-unit>
        <trans-unit id="331255970e3e48a89f2154f44ef024e28fb6bd1c" translate="yes" xml:space="preserve">
          <source>Forms a &lt;code&gt;&lt;a href=&quot;duration&quot;&gt;std::chrono::duration&lt;/a&gt;&lt;/code&gt; literal representing microseconds.</source>
          <target state="translated">Формирует &lt;code&gt;&lt;a href=&quot;duration&quot;&gt;std::chrono::duration&lt;/a&gt;&lt;/code&gt; литерал представляющий микросекунды.</target>
        </trans-unit>
        <trans-unit id="8c586fe6bccfd167b2ec9b0341a50e0e2e23b2bd" translate="yes" xml:space="preserve">
          <source>Forms a &lt;code&gt;&lt;a href=&quot;duration&quot;&gt;std::chrono::duration&lt;/a&gt;&lt;/code&gt; literal representing milliseconds.</source>
          <target state="translated">Формирует &lt;code&gt;&lt;a href=&quot;duration&quot;&gt;std::chrono::duration&lt;/a&gt;&lt;/code&gt; литерал представляющий миллисекунды.</target>
        </trans-unit>
        <trans-unit id="aabdc8e30aa11c549d953403622d6b09da7416a8" translate="yes" xml:space="preserve">
          <source>Forms a &lt;code&gt;&lt;a href=&quot;duration&quot;&gt;std::chrono::duration&lt;/a&gt;&lt;/code&gt; literal representing minutes.</source>
          <target state="translated">Формирует &lt;code&gt;&lt;a href=&quot;duration&quot;&gt;std::chrono::duration&lt;/a&gt;&lt;/code&gt; литерал представляющий минуты.</target>
        </trans-unit>
        <trans-unit id="b2b858860ebb5672d0b628f2489cbedb92290864" translate="yes" xml:space="preserve">
          <source>Forms a &lt;code&gt;&lt;a href=&quot;duration&quot;&gt;std::chrono::duration&lt;/a&gt;&lt;/code&gt; literal representing nanoseconds.</source>
          <target state="translated">Образует литерал &lt;code&gt;&lt;a href=&quot;duration&quot;&gt;std::chrono::duration&lt;/a&gt;&lt;/code&gt; представляющий наносекунды.</target>
        </trans-unit>
        <trans-unit id="d804e0c1b4cad0bfbb3de1fe4b5fa00aa0254978" translate="yes" xml:space="preserve">
          <source>Forms a &lt;code&gt;&lt;a href=&quot;duration&quot;&gt;std::chrono::duration&lt;/a&gt;&lt;/code&gt; literal representing seconds.</source>
          <target state="translated">Образует литерал &lt;code&gt;&lt;a href=&quot;duration&quot;&gt;std::chrono::duration&lt;/a&gt;&lt;/code&gt; представляющий секунды.</target>
        </trans-unit>
        <trans-unit id="1f2764e36e954fe7d39b543d927e58cc08e2ae3b" translate="yes" xml:space="preserve">
          <source>Forms a &lt;code&gt;std::basic_string&amp;lt;CharT&amp;gt;&lt;/code&gt;&lt;code&gt;s&lt;/code&gt; consisting of the day value stored in &lt;code&gt;d&lt;/code&gt; formatted as a decimal number, with a leading zero if the result would otherwise be a single decimal digit. Inserts that string into &lt;code&gt;os&lt;/code&gt;. Then, if &lt;code&gt;!d.ok()&lt;/code&gt;, inserts the string &lt;code&gt;&quot; is not a valid day&quot;&lt;/code&gt; into &lt;code&gt;os&lt;/code&gt;.</source>
          <target state="translated">Образует &lt;code&gt;std::basic_string&amp;lt;CharT&amp;gt;&lt;/code&gt; &lt;code&gt;s&lt;/code&gt; , состоящий из значения , хранящегося в день &lt;code&gt;d&lt;/code&gt; отформатированной в виде десятичного числа, с ведущим нулем , если результат будет в противном случае быть одним десятичным числом. Вставляет эту строку в &lt;code&gt;os&lt;/code&gt; . Затем, если &lt;code&gt;!d.ok()&lt;/code&gt; , вставляет строку &lt;code&gt;&quot; is not a valid day&quot;&lt;/code&gt; в &lt;code&gt;os&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="38eae2fb3ad7f9bb81e8d518abb33df758dc07a9" translate="yes" xml:space="preserve">
          <source>Forms a &lt;code&gt;std::basic_string&amp;lt;CharT&amp;gt;&lt;/code&gt;&lt;code&gt;s&lt;/code&gt; consisting of the year value stored in &lt;code&gt;y&lt;/code&gt; formatted as a decimal number, left-padded with &lt;code&gt;0&lt;/code&gt; to four digits if the result would otherwise be less than four digits. Inserts that string into &lt;code&gt;os&lt;/code&gt;. Then, if &lt;code&gt;!y.ok()&lt;/code&gt;, inserts the string &lt;code&gt;&quot; is not a valid year&quot;&lt;/code&gt; into &lt;code&gt;os&lt;/code&gt;.</source>
          <target state="translated">Образует &lt;code&gt;std::basic_string&amp;lt;CharT&amp;gt;&lt;/code&gt; &lt;code&gt;s&lt;/code&gt; , состоящие из года значения , хранящееся в &lt;code&gt;y&lt;/code&gt; отформатированного в виде десятичного числа, слева дополненные &lt;code&gt;0&lt;/code&gt; до четырех цифр , если результат будет в противном случае будет меньше , чем четыре цифры. Вставляет эту строку в &lt;code&gt;os&lt;/code&gt; . Затем, если &lt;code&gt;!y.ok()&lt;/code&gt; , вставляет строку &lt;code&gt;&quot; is not a valid year&quot;&lt;/code&gt; неверный год&amp;raquo; в &lt;code&gt;os&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0d5578517ed64bd2435fafaf294658c0cb1801f2" translate="yes" xml:space="preserve">
          <source>Forms a &lt;code&gt;std::chrono::day&lt;/code&gt; literal representing a day of the month in the calendar.</source>
          <target state="translated">Формирует литерал &lt;code&gt;std::chrono::day&lt;/code&gt; представляющий день месяца в календаре.</target>
        </trans-unit>
        <trans-unit id="07aea1146bfbc451baff20e77016224dc3f5174b" translate="yes" xml:space="preserve">
          <source>Forms a &lt;code&gt;std::chrono::year&lt;/code&gt; literal representing a year in the proleptic Gregorian calendar.</source>
          <target state="translated">Формирует литерал &lt;code&gt;std::chrono::year&lt;/code&gt; представляющий год в грипорианском календаре.</target>
        </trans-unit>
        <trans-unit id="820c807c48f38eb8ca42664fa731c03b51c0dc19" translate="yes" xml:space="preserve">
          <source>Forms a string literal of the desired type.</source>
          <target state="translated">Формирует строковый литерал нужного типа.</target>
        </trans-unit>
        <trans-unit id="985e41dbd82d997c605a0a512d9497c566128eb1" translate="yes" xml:space="preserve">
          <source>Forms a string view of a character literal.</source>
          <target state="translated">Формирует строковый вид символьного литерала.</target>
        </trans-unit>
        <trans-unit id="70ef5d692d3abeefce2c77380edc61da30bbd98d" translate="yes" xml:space="preserve">
          <source>Forms can be nested and processed recursively: &lt;code&gt;X&amp;lt;int&amp;gt;(*)(char[6])&lt;/code&gt; is an example of &lt;code&gt;type(*)(T)&lt;/code&gt;, where</source>
          <target state="translated">Формы могут быть вложены и обработаны рекурсивно: &lt;code&gt;X&amp;lt;int&amp;gt;(*)(char[6])&lt;/code&gt; является примером &lt;code&gt;type(*)(T)&lt;/code&gt; , где</target>
        </trans-unit>
        <trans-unit id="96d68418cb661c4b3699c2e8d5be8b57b843889b" translate="yes" xml:space="preserve">
          <source>Forms the &lt;a href=&quot;https://en.wikipedia.org/wiki/Logical_conjunction&quot;&gt;logical conjunction&lt;/a&gt; of the type traits &lt;code&gt;B...&lt;/code&gt;, effectively performing a logical AND on the sequence of traits.</source>
          <target state="translated">Формирует &lt;a href=&quot;https://en.wikipedia.org/wiki/Logical_conjunction&quot;&gt;логическое соединение&lt;/a&gt; типа черт &lt;code&gt;B...&lt;/code&gt; , эффективно выполняя логическое И для последовательности черт.</target>
        </trans-unit>
        <trans-unit id="abc06d4ed5fe67746f60bf85f949f812a573392b" translate="yes" xml:space="preserve">
          <source>Forms the &lt;a href=&quot;https://en.wikipedia.org/wiki/Logical_disjunction&quot;&gt;logical disjunction&lt;/a&gt; of the type traits &lt;code&gt;B...&lt;/code&gt;, effectively performing a logical OR on the sequence of traits.</source>
          <target state="translated">Формирует &lt;a href=&quot;https://en.wikipedia.org/wiki/Logical_disjunction&quot;&gt;логическое дизъюнкция&lt;/a&gt; типа черты &lt;code&gt;B...&lt;/code&gt; , эффективно выполняя логическое ИЛИ на последовательности черт.</target>
        </trans-unit>
        <trans-unit id="bb06b9b7e348bda3d1bd2e01e574d860866f1b4f" translate="yes" xml:space="preserve">
          <source>Forms the logical negation of the type trait &lt;code&gt;B&lt;/code&gt;.</source>
          <target state="translated">Формы логического отрицания типа признака &lt;code&gt;B&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="82ea89ab75987595e45620e5e795108b1b6e0406" translate="yes" xml:space="preserve">
          <source>Forward declaration</source>
          <target state="translated">Форвардное заявление</target>
        </trans-unit>
        <trans-unit id="69f690f33d986c3349097e854e0eb9e08b5cc4f9" translate="yes" xml:space="preserve">
          <source>Forward declarations</source>
          <target state="translated">Форвардные заявления</target>
        </trans-unit>
        <trans-unit id="a0a5ca500e9440c8915b30c97f259cacfbb1a922" translate="yes" xml:space="preserve">
          <source>Forward iterator to the new end of the range.</source>
          <target state="translated">Переместите итератор в новый конец диапазона.</target>
        </trans-unit>
        <trans-unit id="55728db9a1113137c393ce6ac1e01d0996797010" translate="yes" xml:space="preserve">
          <source>Forward progress</source>
          <target state="translated">Продвижение вперед</target>
        </trans-unit>
        <trans-unit id="ad2924cf16dd4b5c687b5dd4c3d38f7f20d99988" translate="yes" xml:space="preserve">
          <source>ForwardIterator</source>
          <target state="translated">ForwardIterator</target>
        </trans-unit>
        <trans-unit id="967415c810ff974308b7e163c5a8b2ee4963dfdf" translate="yes" xml:space="preserve">
          <source>ForwardRange</source>
          <target state="translated">ForwardRange</target>
        </trans-unit>
        <trans-unit id="02f29ee395fe54e14061ef2943f36bed0af18091" translate="yes" xml:space="preserve">
          <source>Forwarding references</source>
          <target state="translated">Пересылка ссылок</target>
        </trans-unit>
        <trans-unit id="9cc6112b2b655f82745fcb59748e093ab1fe8817" translate="yes" xml:space="preserve">
          <source>Forwarding references are a special kind of references that preserve the value category of a function argument, making it possible to</source>
          <target state="translated">Переадресация ссылок-это особый вид ссылок,сохраняющий категорию значений аргумента функции,позволяющий</target>
        </trans-unit>
        <trans-unit id="2d1b43ed1d5df75c8cdb7fbed98fd0e15496fb8b" translate="yes" xml:space="preserve">
          <source>Four specializations are provided by the standard library.</source>
          <target state="translated">Четыре специализации предоставляются стандартной библиотекой.</target>
        </trans-unit>
        <trans-unit id="646942bdd43335fac5c5cb8c90a98c4a1571691d" translate="yes" xml:space="preserve">
          <source>Four standalone (locale-independent) specializations are provided by the standard library:</source>
          <target state="translated">Четыре автономные (локально-независимые)специализации предоставляются стандартной библиотекой:</target>
        </trans-unit>
        <trans-unit id="6eb9522d427a2669dd67835d7011efde7feafc8c" translate="yes" xml:space="preserve">
          <source>Fourth version</source>
          <target state="translated">четвёртый вариант</target>
        </trans-unit>
        <trans-unit id="67c664a3c5100ef6f1199beaf5c8ee1e3784d4ea" translate="yes" xml:space="preserve">
          <source>Free raw memory obtained from allocate_bytes</source>
          <target state="translated">Свободная сырая память,полученная из allocate_bytes</target>
        </trans-unit>
        <trans-unit id="66c8be8d1a5492d1eb9655f15bf0380194107efe" translate="yes" xml:space="preserve">
          <source>Frees raw memory obtained by allocate_object</source>
          <target state="translated">Освобождает необработанную память,полученную с помощью allocate_object</target>
        </trans-unit>
        <trans-unit id="2715bc5b3d7345dfa8bf763d473dced4c5997198" translate="yes" xml:space="preserve">
          <source>Freestanding and hosted implementations</source>
          <target state="translated">Отдельно стоящие и размещенные реализации</target>
        </trans-unit>
        <trans-unit id="755e9516e294b0231da60ee53dcb1cf6956a6f7f" translate="yes" xml:space="preserve">
          <source>Friend declarations cannot refer to partial specializations, but can refer to full specializations:</source>
          <target state="translated">Заявления друзей не могут относиться к частичной специализации,но могут относиться к полной специализации:</target>
        </trans-unit>
        <trans-unit id="78f907cdd8f4e2ead952047583a3ce2951b50c9e" translate="yes" xml:space="preserve">
          <source>Friend function declaration</source>
          <target state="translated">Декларация о функции друга</target>
        </trans-unit>
        <trans-unit id="74ed844100eed25ad0c1bd3b12ca6cc5919b4157" translate="yes" xml:space="preserve">
          <source>Friend function definition</source>
          <target state="translated">Определение функции друга</target>
        </trans-unit>
        <trans-unit id="cc53f78835350ac24156d967e62ee0b5c8a5687b" translate="yes" xml:space="preserve">
          <source>Friendship is not inherited (your friend's children are not your friends).</source>
          <target state="translated">Дружба не наследуется (дети Вашего друга не являются Вашими друзьями).</target>
        </trans-unit>
        <trans-unit id="8c8cea4fdc1598ec00b1de75a422605f0af14cee" translate="yes" xml:space="preserve">
          <source>Friendship is not transitive (a friend of your friend is not your friend).</source>
          <target state="translated">Дружба не переходная (друг друга не твой друг).</target>
        </trans-unit>
        <trans-unit id="e8b58840737fe83d2eef7b8580aadc5bae0ab4f5" translate="yes" xml:space="preserve">
          <source>Full names</source>
          <target state="translated">Полные имена</target>
        </trans-unit>
        <trans-unit id="0ca544d7457648c14cce40272868cda27ebf4451" translate="yes" xml:space="preserve">
          <source>Function Objects</source>
          <target state="translated">Функциональные объекты</target>
        </trans-unit>
        <trans-unit id="f7f0e1bdfa2f3add115b52939d15e6fd3460937e" translate="yes" xml:space="preserve">
          <source>Function adaptors</source>
          <target state="translated">Функциональные адаптеры</target>
        </trans-unit>
        <trans-unit id="8231e66ed9c1c9e042523416e1ad72237c2d2874" translate="yes" xml:space="preserve">
          <source>Function argument lists</source>
          <target state="translated">Списки аргументов функций</target>
        </trans-unit>
        <trans-unit id="5bfbcebae9458d0af9e37589048c8edd93acdcad" translate="yes" xml:space="preserve">
          <source>Function body</source>
          <target state="translated">Функциональный орган</target>
        </trans-unit>
        <trans-unit id="f14045db7fd843c69383648cf94f75fb3d176a15" translate="yes" xml:space="preserve">
          <source>Function call</source>
          <target state="translated">Вызов функции</target>
        </trans-unit>
        <trans-unit id="61f764306c5b4c873805f4d7503e407f01f0da37" translate="yes" xml:space="preserve">
          <source>Function call expression is similar in syntax to value initialization &lt;code&gt;T()&lt;/code&gt;, to &lt;a href=&quot;explicit_cast&quot;&gt;function-style cast&lt;/a&gt; expression &lt;code&gt;T(A1)&lt;/code&gt;, and to direct initialization of a temporary &lt;code&gt;T(A1, A2, A3, ...)&lt;/code&gt;, where &lt;code&gt;T&lt;/code&gt; is the name of a type.</source>
          <target state="translated">Вызов функции выражение аналогично синтаксису к значению инициализации &lt;code&gt;T()&lt;/code&gt; , чтобы &lt;a href=&quot;explicit_cast&quot;&gt;литая функция стиль&lt;/a&gt; выражения &lt;code&gt;T(A1)&lt;/code&gt; , и прямой инициализации временной &lt;code&gt;T(A1, A2, A3, ...)&lt;/code&gt; , где &lt;code&gt;T&lt;/code&gt; это имя типа.</target>
        </trans-unit>
        <trans-unit id="55cb199824723ac48f856b32fde1674eff49a87b" translate="yes" xml:space="preserve">
          <source>Function call expressions returning &lt;code&gt;void&lt;/code&gt;, cast expressions to &lt;code&gt;void&lt;/code&gt;, and &lt;a href=&quot;throw&quot;&gt;throw-expressions&lt;/a&gt; are classified as prvalue expressions, but they cannot be used to initialize references or as function arguments. They can be used in discarded-value contexts (e.g. on a line of its own, as the left-hand operand of the comma operator, etc.) and in the &lt;code&gt;return&lt;/code&gt; statement in a function returning &lt;code&gt;void&lt;/code&gt;. In addition, throw-expressions may be used as the second and the third operands of the &lt;a href=&quot;operator_other&quot;&gt;conditional operator ?:&lt;/a&gt;.</source>
          <target state="translated">Выражения вызова функций, возвращающие &lt;code&gt;void&lt;/code&gt; , приведенные выражения к &lt;code&gt;void&lt;/code&gt; и &lt;a href=&quot;throw&quot;&gt;throw-выражения&lt;/a&gt; , классифицируются как выражения prvalue, но их нельзя использовать для инициализации ссылок или в качестве аргументов функции. Они могут использоваться в контекстах с отбрасываемыми значениями (например, в собственной строке, в качестве левого операнда оператора запятой и т. Д.) И в операторе &lt;code&gt;return&lt;/code&gt; в функции, возвращающей &lt;code&gt;void&lt;/code&gt; . Кроме того, выражения throw могут использоваться как второй и третий операнды &lt;a href=&quot;operator_other&quot;&gt;условного оператора?:&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="25056cd4f19ab3cf2ddbe426ca4f88659c9ecb1f" translate="yes" xml:space="preserve">
          <source>Function call operator</source>
          <target state="translated">Оператор вызова функций</target>
        </trans-unit>
        <trans-unit id="c89b9bb41c4c13c872e30f5eb0bb250a5c580801" translate="yes" xml:space="preserve">
          <source>Function declaration</source>
          <target state="translated">Декларация функций</target>
        </trans-unit>
        <trans-unit id="8d84dffd70068ddd1111084e3623daad3386117d" translate="yes" xml:space="preserve">
          <source>Function declarations may appear in any scope. A function declaration at class scope introduces a class member function (unless the friend specifier is used), see &lt;a href=&quot;member_functions&quot;&gt;member functions&lt;/a&gt; and &lt;a href=&quot;friend&quot;&gt;friend functions&lt;/a&gt; for details.</source>
          <target state="translated">Объявления функций могут появляться в любой области видимости. Объявление функции в области видимости класса вводит функцию - член класса (если не используется друг спецификатор), см &lt;a href=&quot;member_functions&quot;&gt;функции - членов&lt;/a&gt; и &lt;a href=&quot;friend&quot;&gt;друг функции&lt;/a&gt; для деталей.</target>
        </trans-unit>
        <trans-unit id="01a7dcd826dbbad15679402aaa257c1e8bee4fd2" translate="yes" xml:space="preserve">
          <source>Function declarators can be mixed with other declarators, where decl-specifier-seq allows:</source>
          <target state="translated">Функциональные деклараторы можно смешивать с другими деклараторами,где позволяет decl-specifier-seq:</target>
        </trans-unit>
        <trans-unit id="b5f8af75bc5ad30466ed317152a310aba07e877e" translate="yes" xml:space="preserve">
          <source>Function definition</source>
          <target state="translated">Определение функций</target>
        </trans-unit>
        <trans-unit id="8a31e049889b12e1b53d0e991bba8a50561e7a03" translate="yes" xml:space="preserve">
          <source>Function discards any whitespace characters (as determined by &lt;code&gt;&lt;a href=&quot;iswspace&quot;&gt;std::iswspace&lt;/a&gt;()&lt;/code&gt;) until first non-whitespace character is found. Then it takes as many characters as possible to form a valid floating-point representation and converts them to a floating-point value. The valid floating-point value can be one of the following:</source>
          <target state="translated">Функция отбрасывает любые пробельные символы (как определено &lt;code&gt;&lt;a href=&quot;iswspace&quot;&gt;std::iswspace&lt;/a&gt;()&lt;/code&gt; ) до тех пор, пока не будет найден первый непробельный символ. Затем требуется как можно больше символов, чтобы сформировать правильное представление с плавающей точкой и преобразовать их в значение с плавающей точкой. Допустимое значение с плавающей запятой может быть одним из следующих:</target>
        </trans-unit>
        <trans-unit id="268b166a91a60d5f1a938de3418f1d3678105197" translate="yes" xml:space="preserve">
          <source>Function discards any whitespace characters (as determined by &lt;code&gt;std::isspace()&lt;/code&gt;) until first non-whitespace character is found. Then it takes as many characters as possible to form a valid floating-point representation and converts them to a floating-point value. The valid floating-point value can be one of the following:</source>
          <target state="translated">Функция отбрасывает любые пробельные символы (как определено &lt;code&gt;std::isspace()&lt;/code&gt; ) до тех пор, пока не будет найден первый непробельный символ. Затем требуется как можно больше символов, чтобы сформировать правильное представление с плавающей точкой и преобразовать их в значение с плавающей точкой. Допустимое значение с плавающей запятой может быть одним из следующих:</target>
        </trans-unit>
        <trans-unit id="56d376c8d143e7051f331c1aba9bc9e6fccbf798" translate="yes" xml:space="preserve">
          <source>Function invocation</source>
          <target state="translated">Вызов функции</target>
        </trans-unit>
        <trans-unit id="ec031b84374532b3dd5e02a9109e50cae284b830" translate="yes" xml:space="preserve">
          <source>Function macros for integer constants</source>
          <target state="translated">Функциональные макросы для целочисленных констант</target>
        </trans-unit>
        <trans-unit id="60be48a55b3f6bfe81f126777640e7116a702836" translate="yes" xml:space="preserve">
          <source>Function macros for minimum-width integer constants</source>
          <target state="translated">Функциональные макросы для целочисленных констант минимальной ширины</target>
        </trans-unit>
        <trans-unit id="bc8a59f44f5ba9847650733c0cafd473c4eed11f" translate="yes" xml:space="preserve">
          <source>Function not supported</source>
          <target state="translated">Функция не поддерживается</target>
        </trans-unit>
        <trans-unit id="b248eacc8c468b679bd61ad8cb82d22de759fe43" translate="yes" xml:space="preserve">
          <source>Function object for computing remainders of divisions. Implements &lt;code&gt;operator%&lt;/code&gt; for type &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">Функция объекта для вычисления остатков делений. Реализует &lt;code&gt;operator%&lt;/code&gt; для типа &lt;code&gt;T&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a4633ecd37c7996641d9e6e60f41f4acaad220fb" translate="yes" xml:space="preserve">
          <source>Function object for performing addition. Effectively calls &lt;code&gt;operator+&lt;/code&gt; on two instances of type &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">Функциональный объект для выполнения сложения. Эффективно вызывает &lt;code&gt;operator+&lt;/code&gt; на двух экземплярах типа &lt;code&gt;T&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d149129b3c23a795999a21bc625bd934320c5a89" translate="yes" xml:space="preserve">
          <source>Function object for performing bitwise AND. Effectively calls &lt;code&gt;operator&amp;amp;&lt;/code&gt; on type &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">Функциональный объект для выполнения побитового И. Эффективно называет &lt;code&gt;operator&amp;amp;&lt;/code&gt; по типу &lt;code&gt;T&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b599fdda8a6eff8b08fa4dda5e4633fab0dbe0ce" translate="yes" xml:space="preserve">
          <source>Function object for performing bitwise NOT. Effectively calls &lt;code&gt;operator~&lt;/code&gt; on type &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">Функция объекта для выполнения побитового НЕ. Эффективно вызывает &lt;code&gt;operator~&lt;/code&gt; на тип &lt;code&gt;T&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="313209366a119d00dc320937bfc0bbb8786800ec" translate="yes" xml:space="preserve">
          <source>Function object for performing bitwise OR. Effectively calls &lt;code&gt;operator|&lt;/code&gt; on type &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">Функциональный объект для выполнения побитового ИЛИ. Эффективно звонит &lt;code&gt;operator|&lt;/code&gt; на тип &lt;code&gt;T&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c5887d43f2e0df69b82fff43b54f846c4704fa46" translate="yes" xml:space="preserve">
          <source>Function object for performing bitwise XOR. Effectively calls &lt;code&gt;operator^&lt;/code&gt; on type &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">Функциональный объект для выполнения побитового XOR. Эффективно вызывает &lt;code&gt;operator^&lt;/code&gt; по типу &lt;code&gt;T&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e180b41511a71768ffe2c960f01fb1039a41108e" translate="yes" xml:space="preserve">
          <source>Function object for performing comparisons. Deduces the parameter types of the function call operator from the arguments (but not the return type).</source>
          <target state="translated">Функциональный объект для проведения сравнений.Вычитает типы параметров оператора вызова функции из аргументов (но не тип возврата).</target>
        </trans-unit>
        <trans-unit id="56f077a1110154764933177a4a8a45a67a0e117f" translate="yes" xml:space="preserve">
          <source>Function object for performing comparisons. Unless specialised, invokes &lt;code&gt;operator!=&lt;/code&gt; on type &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">Функциональный объект для выполнения сравнений. Если не специализировались, вызывающий &lt;code&gt;operator!=&lt;/code&gt; По типу &lt;code&gt;T&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3d8efff6ca90765aa3a8bc08e4dd6c03c3e58a69" translate="yes" xml:space="preserve">
          <source>Function object for performing comparisons. Unless specialised, invokes &lt;code&gt;operator==&lt;/code&gt; on type &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">Функциональный объект для выполнения сравнений. Если не специализированы, вызывает &lt;code&gt;operator==&lt;/code&gt; по типу &lt;code&gt;T&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="60aea8fb12e1c43b673c06d961c8619b0f1469c4" translate="yes" xml:space="preserve">
          <source>Function object for performing comparisons. Unless specialized, invokes &lt;code&gt;operator&amp;gt;&lt;/code&gt; on type &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">Функциональный объект для выполнения сравнений. Если не специализированы, вызывает &lt;code&gt;operator&amp;gt;&lt;/code&gt; по типу &lt;code&gt;T&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="738acefb6a4d9540bfe0b153875600600ca1005f" translate="yes" xml:space="preserve">
          <source>Function object for performing comparisons. Unless specialized, invokes &lt;code&gt;operator&amp;gt;=&lt;/code&gt; on type &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">Функциональный объект для выполнения сравнений. Если не специализировано, вызывающий &lt;code&gt;operator&amp;gt;=&lt;/code&gt; по типу &lt;code&gt;T&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2ed4fd907e2e5e744c2b2efa9d9bc109fe8439c7" translate="yes" xml:space="preserve">
          <source>Function object for performing comparisons. Unless specialized, invokes &lt;code&gt;operator&amp;lt;&lt;/code&gt; on type &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">Функциональный объект для выполнения сравнений. Если не специализированы, вызывает &lt;code&gt;operator&amp;lt;&lt;/code&gt; на тип &lt;code&gt;T&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="86238797ec5cdcf632292c3e4d25c647b5a4693a" translate="yes" xml:space="preserve">
          <source>Function object for performing comparisons. Unless specialized, invokes &lt;code&gt;operator&amp;lt;=&lt;/code&gt; on type &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">Функциональный объект для выполнения сравнений. Если не специализированные, вызывающий &lt;code&gt;operator&amp;lt;=&lt;/code&gt; по типу &lt;code&gt;T&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0fe5410430a56ab0ae8cbfda0c39393d3efaefd1" translate="yes" xml:space="preserve">
          <source>Function object for performing division. Effectively calls &lt;code&gt;operator/&lt;/code&gt; on two instances of type &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">Функциональный объект для выполнения деления. Эффективно вызывает &lt;code&gt;operator/&lt;/code&gt; на двух экземплярах типа &lt;code&gt;T&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="12de586434654aa1a14b6b2d8a259de90a34392f" translate="yes" xml:space="preserve">
          <source>Function object for performing logical AND (logical conjunction). Effectively calls &lt;code&gt;operator&amp;amp;&amp;amp;&lt;/code&gt; on type &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">Функциональный объект для выполнения логического И (логическое соединение). Эффективно вызывает &lt;code&gt;operator&amp;amp;&amp;amp;&lt;/code&gt; по типу &lt;code&gt;T&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1490a0997baca27d81b16387b04a8b28fa19d7e6" translate="yes" xml:space="preserve">
          <source>Function object for performing logical NOT (logical negation). Effectively calls &lt;code&gt;operator!&lt;/code&gt; for type &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">Функциональный объект для выполнения логического НЕ (логическое отрицание). Эффективно звонит &lt;code&gt;operator!&lt;/code&gt; для типа &lt;code&gt;T&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="26fc81b06029a179ee570f03e59c7d8106976333" translate="yes" xml:space="preserve">
          <source>Function object for performing logical OR (logical disjunction). Effectively calls &lt;code&gt;operator||&lt;/code&gt; on type &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">Функциональный объект для выполнения логического ИЛИ (логического дизъюнкции). Эффективно звонит &lt;code&gt;operator||&lt;/code&gt; на тип &lt;code&gt;T&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="863b97dec6e3bad00c70886e69a7afbb1c4e16fb" translate="yes" xml:space="preserve">
          <source>Function object for performing multiplication. Effectively calls &lt;code&gt;operator*&lt;/code&gt; on two instances of type &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">Функциональный объект для выполнения умножения. Эффективно вызывает &lt;code&gt;operator*&lt;/code&gt; на двух экземплярах типа &lt;code&gt;T&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a134daaeb15195627f59ee24f26ecba80c6eb4fc" translate="yes" xml:space="preserve">
          <source>Function object for performing negation. Effectively calls &lt;code&gt;operator-&lt;/code&gt; on an instance of type &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">Функциональный объект для выполнения отрицания. Эффективно вызывает &lt;code&gt;operator-&lt;/code&gt; на экземпляре типа &lt;code&gt;T&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6be85bc0166110c97cce13deef82fe7cce65ca9c" translate="yes" xml:space="preserve">
          <source>Function object for performing subtraction. Effectively calls &lt;code&gt;operator-&lt;/code&gt; on two instances of type &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">Функциональный объект для выполнения вычитания. Эффективно вызывает &lt;code&gt;operator-&lt;/code&gt; на двух экземплярах типа &lt;code&gt;T&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="05785bcc60d939df6f0a0f7578eb56a67e1b185f" translate="yes" xml:space="preserve">
          <source>Function objects</source>
          <target state="translated">Функциональные объекты</target>
        </trans-unit>
        <trans-unit id="b8f9cce63cec2dc22abc32a4cbf9907e736f87ee" translate="yes" xml:space="preserve">
          <source>Function objects, Function invocations, Bind operations and Reference wrappers</source>
          <target state="translated">Объекты функций,вызовы функций,операции привязки и опорные обёртки</target>
        </trans-unit>
        <trans-unit id="474b3e14aec889f00fbd7fffa4899aaf67c18da3" translate="yes" xml:space="preserve">
          <source>Function overloads vs function specializations</source>
          <target state="translated">Перегрузка функций по сравнению со специализацией функций</target>
        </trans-unit>
        <trans-unit id="05c625ce62f1567c6464e68f3d0c5ca596683e7c" translate="yes" xml:space="preserve">
          <source>Function parameter list</source>
          <target state="translated">Список параметров функции</target>
        </trans-unit>
        <trans-unit id="cacf242390ee182c0b5703d0e286b16458b2d6ac" translate="yes" xml:space="preserve">
          <source>Function parameter pack (a form of &lt;a href=&quot;declarations&quot;&gt;declarator&lt;/a&gt;, appears in a function parameter list of a variadic function template).</source>
          <target state="translated">Пакет параметров функции (форма &lt;a href=&quot;declarations&quot;&gt;объявления&lt;/a&gt; , появляется в списке параметров функции шаблона переменной функции).</target>
        </trans-unit>
        <trans-unit id="ee2ed22b6c316767fa0eee64138df658812f8372" translate="yes" xml:space="preserve">
          <source>Function parameter scope</source>
          <target state="translated">Область действия параметров функции</target>
        </trans-unit>
        <trans-unit id="16a39e4b6666353c50f59b56d3cce3eb5dbeca02" translate="yes" xml:space="preserve">
          <source>Function parameters are not allowed in default arguments (even if they are not evaluated)(until C++14) except if they are unevaluated(since C++14). Note that parameters that appear earlier in the parameter list are in &lt;a href=&quot;scope&quot;&gt;scope&lt;/a&gt;:</source>
          <target state="translated">Параметры функций не допускаются в аргументах по умолчанию (даже если они не оцениваются) (до C ++ 14), за исключением случаев, когда они не оценены (начиная с C ++ 14). Обратите внимание, что параметры, которые появляются ранее в списке параметров, находятся в &lt;a href=&quot;scope&quot;&gt;области видимости&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="c545df3352143fe60a307ebf941a3169f4b04ba9" translate="yes" xml:space="preserve">
          <source>Function pointer conversions</source>
          <target state="translated">Преобразование указателей функций</target>
        </trans-unit>
        <trans-unit id="14644346bcc70a878c3eb265226005a7304bec16" translate="yes" xml:space="preserve">
          <source>Function scope</source>
          <target state="translated">Объём функций</target>
        </trans-unit>
        <trans-unit id="d879bbf1375b073db057a0370df0b5d2aaf75d77" translate="yes" xml:space="preserve">
          <source>Function template</source>
          <target state="translated">Шаблон функции</target>
        </trans-unit>
        <trans-unit id="e8ac637a6e8fb2f46175ee490eb2eb83645238b8" translate="yes" xml:space="preserve">
          <source>Function template &lt;code&gt;std::mem_fn&lt;/code&gt; generates wrapper objects for pointers to members, which can store, copy, and invoke a pointer to member. Both references and pointers (including smart pointers) to an object can be used when invoking a &lt;code&gt;std::mem_fn&lt;/code&gt;.</source>
          <target state="translated">Шаблон функции &lt;code&gt;std::mem_fn&lt;/code&gt; генерирует объекты-оболочки для указателей на члены, которые могут хранить, копировать и вызывать указатель на член. Как ссылки, так и указатели (включая интеллектуальные указатели) на объект могут использоваться при вызове &lt;code&gt;std::mem_fn&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ba1b466469de4bedf72f07dd5b3b51bc92ecf5e1" translate="yes" xml:space="preserve">
          <source>Function template instantiation</source>
          <target state="translated">инстанцирование шаблона функции</target>
        </trans-unit>
        <trans-unit id="a76d53230697569d7c028ff1451f97505d469db4" translate="yes" xml:space="preserve">
          <source>Function template overloading</source>
          <target state="translated">Перегрузка шаблона функции</target>
        </trans-unit>
        <trans-unit id="86dd3fddcc75cfa4e063a703f32c8ede28f4c30d" translate="yes" xml:space="preserve">
          <source>Function template parameters are substituted (replaced by template arguments) twice:</source>
          <target state="translated">Параметры шаблона функции подставляются (заменяются на аргументы шаблона)дважды:</target>
        </trans-unit>
        <trans-unit id="6027571a098596d5e87183ff7d586ec483f03343" translate="yes" xml:space="preserve">
          <source>Function template specialization</source>
          <target state="translated">Специализация шаблона функции</target>
        </trans-unit>
        <trans-unit id="c03fc20cda6df9ef92fd64413e95464c0412a4fc" translate="yes" xml:space="preserve">
          <source>Function templates &lt;code&gt;ref&lt;/code&gt; and &lt;code&gt;cref&lt;/code&gt; are helper functions that generate an object of type &lt;code&gt;&lt;a href=&quot;reference_wrapper&quot;&gt;std::reference_wrapper&lt;/a&gt;&lt;/code&gt;, using &lt;a href=&quot;../../language/template_argument_deduction&quot;&gt;template argument deduction&lt;/a&gt; to determine the template argument of the result.</source>
          <target state="translated">Шаблоны функций &lt;code&gt;ref&lt;/code&gt; и &lt;code&gt;cref&lt;/code&gt; являются вспомогательными функциями, которые генерируют объект типа &lt;code&gt;&lt;a href=&quot;reference_wrapper&quot;&gt;std::reference_wrapper&lt;/a&gt;&lt;/code&gt; , используя &lt;a href=&quot;../../language/template_argument_deduction&quot;&gt;вывод аргумента шаблона&lt;/a&gt; для определения аргумента шаблона результата.</target>
        </trans-unit>
        <trans-unit id="d90c99af4d1617c8e3520279788821d8d6072cea" translate="yes" xml:space="preserve">
          <source>Function templates and non-template functions may be overloaded.</source>
          <target state="translated">Шаблоны функций и нешаблонные функции могут быть перегружены.</target>
        </trans-unit>
        <trans-unit id="527a4bc836096e4223cdeb54a2dc838640d3aaaa" translate="yes" xml:space="preserve">
          <source>Function to pointer</source>
          <target state="translated">Функция указателя</target>
        </trans-unit>
        <trans-unit id="ccff159bf6b5506e0e1b9835119cc9060c666c2b" translate="yes" xml:space="preserve">
          <source>Function wrappers</source>
          <target state="translated">Функциональные обёртки</target>
        </trans-unit>
        <trans-unit id="2e3030f5a7f048cef8382d50828336e71bb753d2" translate="yes" xml:space="preserve">
          <source>Function-like macros</source>
          <target state="translated">Функциональные макросы</target>
        </trans-unit>
        <trans-unit id="a542b043e775e7bb5b171b48eca68e3eaf37af10" translate="yes" xml:space="preserve">
          <source>Function-like macros replace each occurrence of defined identifier with replacement-list, additionally taking a number of arguments, which then replace corresponding occurrences of any of the parameters in the replacement-list.</source>
          <target state="translated">Функциональноподобные макросы заменяют каждое появление определенного идентификатора на заменяющий список,дополнительно принимая ряд аргументов,которые затем заменяют соответствующие вхождения любого из параметров в заменяющем списке.</target>
        </trans-unit>
        <trans-unit id="1bc7ec84b7f54258ed54c7cecbe2e69587cb60b9" translate="yes" xml:space="preserve">
          <source>Function-local static objects in all definitions of the same &lt;a href=&quot;inline&quot;&gt;inline function&lt;/a&gt; (which may be implicitly inline) all refer to the same object defined in one translation unit.</source>
          <target state="translated">Функционально-локальные статические объекты во всех определениях одной и той же &lt;a href=&quot;inline&quot;&gt;встроенной функции&lt;/a&gt; (которая может быть неявно встроенной) все ссылаются на один и тот же объект, определенный в одной единице перевода.</target>
        </trans-unit>
        <trans-unit id="fbeb9de485717bfd55eb5b969f4aef0b216aa354" translate="yes" xml:space="preserve">
          <source>Function-local static objects in all function definitions are shared across all translation units (they all refer to the same object defined in one translation unit)</source>
          <target state="translated">Функционально-локальные статические объекты во всех определениях функций совместно используются всеми единицами трансляции (все они относятся к одному и тому же объекту,определенному в одной единице трансляции).</target>
        </trans-unit>
        <trans-unit id="22b482f447a1cfcb8f938c680757e7b627882a11" translate="yes" xml:space="preserve">
          <source>Function-try-block</source>
          <target state="translated">Function-try-block</target>
        </trans-unit>
        <trans-unit id="36dbe687f7a701ccda0c0ab3d3368fc1726070a3" translate="yes" xml:space="preserve">
          <source>Function-try-block does not catch the exceptions thrown by the copy/move constructors and the destructors of the function parameters passed by value: those exceptions are thrown in context of the caller.</source>
          <target state="translated">Функция-трибулятор не перехватывает исключения,брошенные конструкторами копирования/перемещения и деструкторами параметров функции,передаваемых по значению:эти исключения бросаются в контексте вызывающего абонента.</target>
        </trans-unit>
        <trans-unit id="62fa030d8057f6948ce260fe787ed5a6b93441e6" translate="yes" xml:space="preserve">
          <source>Function-try-block of the top-level function of a thread does not catch the exceptions thrown from the constructors and destructors of &lt;a href=&quot;storage_duration&quot;&gt;thread-local&lt;/a&gt; objects (except for the constructors of function-scoped thread-locals).</source>
          <target state="translated">Функция-try-block функции верхнего уровня потока не перехватывает исключения, сгенерированные конструкторами и деструкторами &lt;a href=&quot;storage_duration&quot;&gt;локальных&lt;/a&gt; объектов потока (за исключением конструкторов локальных потоков функции с областью действия).</target>
        </trans-unit>
        <trans-unit id="e6221f912553a22b3b906841565a95ac6fe744e4" translate="yes" xml:space="preserve">
          <source>FunctionObject</source>
          <target state="translated">FunctionObject</target>
        </trans-unit>
        <trans-unit id="c504a5185db1d5f75bfd32087e1e44501fcf47f1" translate="yes" xml:space="preserve">
          <source>Functional cast</source>
          <target state="translated">Функциональный литой</target>
        </trans-unit>
        <trans-unit id="2b961dea1dc0c60ddf9a2c8e9d090f6f7d082483" translate="yes" xml:space="preserve">
          <source>Functions</source>
          <target state="translated">Functions</target>
        </trans-unit>
        <trans-unit id="b4889f5791eb376ad73674ef2d3c06e94b724603" translate="yes" xml:space="preserve">
          <source>Functions and macro constants for signal management</source>
          <target state="translated">Функции и макроконстанты для управления сигналами</target>
        </trans-unit>
        <trans-unit id="a1141ae7da62060d933a86668311750ac59f208e" translate="yes" xml:space="preserve">
          <source>Functions and references to functions are not function object types, but can be used where function object types are expected due to function-to-pointer &lt;a href=&quot;../language/implicit_cast&quot;&gt;implicit conversion&lt;/a&gt;.</source>
          <target state="translated">Функции и ссылки на функции не являются типами функциональных объектов, но могут использоваться там, где ожидаются типы функциональных объектов из-за &lt;a href=&quot;../language/implicit_cast&quot;&gt;неявного преобразования&lt;/a&gt; функции в указатель .</target>
        </trans-unit>
        <trans-unit id="ab7bbe95387b8d4e9017d700d4c60ae66f3da45c" translate="yes" xml:space="preserve">
          <source>Functions are C++ entities that associate a sequence of &lt;a href=&quot;statements&quot;&gt;statements&lt;/a&gt; (a</source>
          <target state="translated">Функции - это объекты C ++, которые связывают последовательность &lt;a href=&quot;statements&quot;&gt;операторов&lt;/a&gt; (</target>
        </trans-unit>
        <trans-unit id="9a1ebfefe2d4935a5dd163de13ea3976c504e0ea" translate="yes" xml:space="preserve">
          <source>Functions are not objects: there are no arrays of functions and functions cannot be passed by value or returned from other functions. Pointers and references to functions are allowed, and may be used where functions themselves cannot.</source>
          <target state="translated">Функции не являются объектами:нет массивов функций и функции не могут передаваться по значениям или возвращаться из других функций.Допускаются указатели и ссылки на функции,и могут использоваться там,где сами функции не могут.</target>
        </trans-unit>
        <trans-unit id="e4cd68a9abe69d2fc916398ed73a57ddaba5e3ac" translate="yes" xml:space="preserve">
          <source>Functions differing only in their exception specification cannot be overloaded (just like the return type, exception specification is part of function type, but not part of the function signature)(since C++17).</source>
          <target state="translated">Функции,отличающиеся только спецификацией исключения,не могут быть перегружены (так же,как и тип возврата,спецификация исключения является частью типа функции,но не частью сигнатуры функции)(начиная с C++17).</target>
        </trans-unit>
        <trans-unit id="d805e16a2e1dab2e9501d00d8aa06488d3d1141d" translate="yes" xml:space="preserve">
          <source>Functions in input/output classes returning this type use &lt;code&gt;X::pos_type(X::off_type(-1))&lt;/code&gt; is an invalid value to signal an error</source>
          <target state="translated">Функции в классах ввода / вывода, возвращающие этот тип, используют &lt;code&gt;X::pos_type(X::off_type(-1))&lt;/code&gt; , это недопустимое значение, сигнализирующее об ошибке</target>
        </trans-unit>
        <trans-unit id="f4f28c856ebb451338613595e08fe5dd22c841b5" translate="yes" xml:space="preserve">
          <source>Functions managing the current thread</source>
          <target state="translated">Функции управления текущим потоком</target>
        </trans-unit>
        <trans-unit id="d3e493f42a02a1130d7650420222293b27d1128f" translate="yes" xml:space="preserve">
          <source>Functions passed to &lt;code&gt;&lt;a href=&quot;at_quick_exit&quot;&gt;std::at_quick_exit&lt;/a&gt;&lt;/code&gt; are called in reverse order of their registration. If an exception tries to propagate out of any of the functions, &lt;code&gt;&lt;a href=&quot;../../error/terminate&quot;&gt;std::terminate&lt;/a&gt;&lt;/code&gt; is called. After calling the registered functions, calls &lt;code&gt;&lt;a href=&quot;_exit&quot;&gt;std::_Exit&lt;/a&gt;(exit_code)&lt;/code&gt;.</source>
          <target state="translated">Функции, переданные в &lt;code&gt;&lt;a href=&quot;at_quick_exit&quot;&gt;std::at_quick_exit&lt;/a&gt;&lt;/code&gt; , вызываются в обратном порядке их регистрации. Если исключение пытается распространиться из любой функции, вызывается &lt;code&gt;&lt;a href=&quot;../../error/terminate&quot;&gt;std::terminate&lt;/a&gt;&lt;/code&gt; . После вызова зарегистрированных функций вызывается &lt;code&gt;&lt;a href=&quot;_exit&quot;&gt;std::_Exit&lt;/a&gt;(exit_code)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2271b1375ac754084b518ec111ad83a20a6f3bb3" translate="yes" xml:space="preserve">
          <source>Functions passed to &lt;code&gt;&lt;a href=&quot;atexit&quot;&gt;std::atexit&lt;/a&gt;&lt;/code&gt; are not called.</source>
          <target state="translated">Функции, переданные в &lt;code&gt;&lt;a href=&quot;atexit&quot;&gt;std::atexit&lt;/a&gt;&lt;/code&gt; , не вызываются.</target>
        </trans-unit>
        <trans-unit id="a4c76c24658f2c936074eb17b534063810ef4a85" translate="yes" xml:space="preserve">
          <source>Functions templates cannot be declared &lt;code&gt;virtual&lt;/code&gt;. This applies only to functions that are themselves templates - a regular member function of a class template can be declared virtual.</source>
          <target state="translated">Шаблоны функций не могут быть объявлены &lt;code&gt;virtual&lt;/code&gt; . Это относится только к функциям, которые сами являются шаблонами - обычная функция-член шаблона класса может быть объявлена ​​виртуальной.</target>
        </trans-unit>
        <trans-unit id="987a9735f7910a78415404d390c2c2321b297df5" translate="yes" xml:space="preserve">
          <source>Functions to determine the type contained in character data</source>
          <target state="translated">Функции определения типа,содержащегося в символьных данных</target>
        </trans-unit>
        <trans-unit id="56333d40b9d13a5dd6765448f63eb5888129f41c" translate="yes" xml:space="preserve">
          <source>Functions to determine the type contained in wide character data</source>
          <target state="translated">Функции определения типа,содержащегося в широкоформатных данных</target>
        </trans-unit>
        <trans-unit id="268aa8a9dc8a94eb9552c1bc422fd7d569604150" translate="yes" xml:space="preserve">
          <source>Fundamental library concepts</source>
          <target state="translated">Фундаментальные библиотечные концепции</target>
        </trans-unit>
        <trans-unit id="9415eca058dab008a0c257d5b5372a414020f727" translate="yes" xml:space="preserve">
          <source>Fundamental types</source>
          <target state="translated">Фундаментальные типы</target>
        </trans-unit>
        <trans-unit id="f9ccc0fa4eefc3fc4fbd603adf877686e0fcb107" translate="yes" xml:space="preserve">
          <source>Fundamental types defined by the language</source>
          <target state="translated">Фундаментальные типы,определяемые языком</target>
        </trans-unit>
        <trans-unit id="bafd4b54282745a2bed1442852b73f4b3189a77a" translate="yes" xml:space="preserve">
          <source>Further Reading</source>
          <target state="translated">Дальнейшее чтение</target>
        </trans-unit>
        <trans-unit id="90203b2e01951bcae33561da4c2fe607351b5912" translate="yes" xml:space="preserve">
          <source>Furthermore, &lt;code&gt;auto&lt;/code&gt;and type-constraint&lt;code&gt;auto&lt;/code&gt;(since C++20) can appear in:</source>
          <target state="translated">Кроме того, &lt;code&gt;auto&lt;/code&gt; и &lt;code&gt;auto&lt;/code&gt; с ограничением типов (начиная с C ++ 20) могут появляться в:</target>
        </trans-unit>
        <trans-unit id="6dc21edb8c36c3f6d406c872d0cb241b792a813e" translate="yes" xml:space="preserve">
          <source>Furthermore.</source>
          <target state="translated">Furthermore.</target>
        </trans-unit>
        <trans-unit id="ef3bf279dd511b3249e9a0fa2ada2e63ca452156" translate="yes" xml:space="preserve">
          <source>Future errors</source>
          <target state="translated">Будущие ошибки</target>
        </trans-unit>
        <trans-unit id="965db80f650641f51dead99c13720e4035c9ef70" translate="yes" xml:space="preserve">
          <source>Futures</source>
          <target state="translated">Futures</target>
        </trans-unit>
        <trans-unit id="4c00eeb89fd7b78411cbeb5ccec11fa4c97f179d" translate="yes" xml:space="preserve">
          <source>GCC 4.6 libstdc++</source>
          <target state="translated">GCC 4.6 libstdc++</target>
        </trans-unit>
        <trans-unit id="8678ed721c5d5bc588ebb7a34742eafcc58d8a66" translate="yes" xml:space="preserve">
          <source>GCC Inline Assembly HOWTO</source>
          <target state="translated">GCC Inline Assembly HOWTO</target>
        </trans-unit>
        <trans-unit id="e28f7b13c864b2544bcffb8944485f05b95aa03f" translate="yes" xml:space="preserve">
          <source>GCC assembly with the attribute:</source>
          <target state="translated">GCC сборка с атрибутом:</target>
        </trans-unit>
        <trans-unit id="29dc240b146eb494ed0bbceef77ad1534442b61b" translate="yes" xml:space="preserve">
          <source>GCC assembly without the attribute: the entire function is serialized.</source>
          <target state="translated">Сборка GCC без атрибута:вся функция сериализована.</target>
        </trans-unit>
        <trans-unit id="607e8f7d61ea73ecc2a3928fe014d54ac981f615" translate="yes" xml:space="preserve">
          <source>GLAGOLITIC CAPITAL LETTER AZU - COMBINING CYRILLIC LETTER IOTIFIED BIG YUS</source>
          <target state="translated">ГЛАГОЛИЦА ЗАГЛАВНАЯ БУКВА АЗУ-СОЧЕТАНИЕ КИРИЛЛИЦЫ IOTIFIED BIG YUS</target>
        </trans-unit>
        <trans-unit id="770bd3164fd3f78b840dd2606eee557790bae82f" translate="yes" xml:space="preserve">
          <source>GNU libc function &lt;code&gt;&lt;a href=&quot;http://www.gnu.org/s/hello/manual/libc/Control-Functions.html&quot;&gt;feenableexcept()&lt;/a&gt;&lt;/code&gt; enables trapping of the floating-point exceptions, which generates the signal &lt;code&gt;SIGFPE&lt;/code&gt;. If the compiler option &lt;code&gt;-fnon-call-exceptions&lt;/code&gt; was used, the handler for that signal may throw a user-defined C++ exception.</source>
          <target state="translated">Функция GNU libc &lt;code&gt;&lt;a href=&quot;http://www.gnu.org/s/hello/manual/libc/Control-Functions.html&quot;&gt;feenableexcept()&lt;/a&gt;&lt;/code&gt; позволяет перехватывать исключения с плавающей запятой, которые генерируют сигнал &lt;code&gt;SIGFPE&lt;/code&gt; . Если использовалась опция компилятора &lt;code&gt;-fnon-call-exceptions&lt;/code&gt; , обработчик для этого сигнала может выдать пользовательское исключение C ++.</target>
        </trans-unit>
        <trans-unit id="7e7d86fda01350dd97d7deed580504fa4ea12720" translate="yes" xml:space="preserve">
          <source>GNU libstdc++ stores 4 additional members: three cached facets and a flag to indicate that fill was initialized.</source>
          <target state="translated">В GNU libstdc++хранится 4 дополнительных члена:три кэшированные грани и флаг,указывающий на то,что заливка была инициализирована.</target>
        </trans-unit>
        <trans-unit id="262e4b5ffc0564ab9152ecabdaf6c1affcaea1bc" translate="yes" xml:space="preserve">
          <source>GOTW issue 47: Uncaught Exceptions</source>
          <target state="translated">ПОСЛЕДНИЙ выпуск 47:Исключения</target>
        </trans-unit>
        <trans-unit id="143075ce23be9b2dbef6368dc5e0e4219829451a" translate="yes" xml:space="preserve">
          <source>Garbage collector support</source>
          <target state="translated">Поддержка сборщика мусора</target>
        </trans-unit>
        <trans-unit id="9239ee2cda84eca4c3440e2a7b50148af67da3d4" translate="yes" xml:space="preserve">
          <source>General</source>
          <target state="translated">General</target>
        </trans-unit>
        <trans-unit id="c807e9f8f0554603e2d07bd5ea3e21f358d0409a" translate="yes" xml:space="preserve">
          <source>General purpose utilities: &lt;a href=&quot;utility/program&quot;&gt; program control&lt;/a&gt;, &lt;a href=&quot;memory/c&quot;&gt; dynamic memory allocation&lt;/a&gt;, &lt;a href=&quot;numeric/random&quot;&gt; random numbers&lt;/a&gt;, &lt;a href=&quot;algorithm&quot;&gt; sort and search&lt;/a&gt;</source>
          <target state="translated">Утилиты общего назначения: &lt;a href=&quot;utility/program&quot;&gt;управление программой&lt;/a&gt; , &lt;a href=&quot;memory/c&quot;&gt;динамическое распределение памяти&lt;/a&gt; , &lt;a href=&quot;numeric/random&quot;&gt;случайные числа&lt;/a&gt; , &lt;a href=&quot;algorithm&quot;&gt;сортировка и поиск&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ed31062b543a89f89f4324118c873e8e23d6d8a5" translate="yes" xml:space="preserve">
          <source>General-purpose utilities</source>
          <target state="translated">Жилищно-коммунальные хозяйства общего назначения</target>
        </trans-unit>
        <trans-unit id="5c6d1d670f7f626ac925f247ce54a21001aced36" translate="yes" xml:space="preserve">
          <source>Generalized lambda-capture</source>
          <target state="translated">Обобщенная лямбда-захват</target>
        </trans-unit>
        <trans-unit id="f356c8b2b591cd001b93f307940d89de652b1d90" translate="yes" xml:space="preserve">
          <source>Generalized range-based &lt;code&gt;for&lt;/code&gt; loop</source>
          <target state="translated">Обобщенный диапазон на основе &lt;code&gt;for&lt;/code&gt; цикла</target>
        </trans-unit>
        <trans-unit id="42544cf1873411d097739bf7d82068c8b915ea3d" translate="yes" xml:space="preserve">
          <source>Generalized sum of &lt;code&gt;init&lt;/code&gt; and &lt;code&gt;*first&lt;/code&gt;, &lt;code&gt;*(first+1)&lt;/code&gt;, ... &lt;code&gt;*(last-1)&lt;/code&gt; over &lt;code&gt;binary_op&lt;/code&gt;,</source>
          <target state="translated">Обобщенная сумма &lt;code&gt;init&lt;/code&gt; и &lt;code&gt;*first&lt;/code&gt; , &lt;code&gt;*(first+1)&lt;/code&gt; , ... &lt;code&gt;*(last-1)&lt;/code&gt; по &lt;code&gt;binary_op&lt;/code&gt; ,</target>
        </trans-unit>
        <trans-unit id="13dfcc134e2752a1f9a0a0493daeaa583d9e01a7" translate="yes" xml:space="preserve">
          <source>Generally speaking, the pseudo-random number generator should only be seeded once, before any calls to &lt;code&gt;rand()&lt;/code&gt;, at the start of the program. It should not be repeatedly seeded, or reseeded every time you wish to generate a new batch of pseudo-random numbers.</source>
          <target state="translated">Вообще говоря, генератор псевдослучайных чисел должен быть засеян только один раз, перед любыми вызовами &lt;code&gt;rand()&lt;/code&gt; , в начале программы. Он не должен быть повторно посеян или повторно заполнен каждый раз, когда вы хотите сгенерировать новую партию псевдослучайных чисел.</target>
        </trans-unit>
        <trans-unit id="7ebbc49a3b2f1f41072b44a34d7a54d1bce22da9" translate="yes" xml:space="preserve">
          <source>Generates a non-deterministic uniformly-distributed random value.</source>
          <target state="translated">Генерирует недетерминистическую равномерно распределенную случайную величину.</target>
        </trans-unit>
        <trans-unit id="974bfaa70e23e754b8c317100b6cf3c9baf7cefa" translate="yes" xml:space="preserve">
          <source>Generates a pseudo-random value. The state of the engine is advanced by one position.</source>
          <target state="translated">Генерирует псевдослучайное значение.Состояние двигателя улучшается на одну позицию.</target>
        </trans-unit>
        <trans-unit id="69477acbfb73a301833c0442c884476d728e54ee" translate="yes" xml:space="preserve">
          <source>Generates a random floating point number in range [0, 1).</source>
          <target state="translated">Генерирует случайное число с плавающей точкой в диапазоне [0,1].</target>
        </trans-unit>
        <trans-unit id="e11bac75cd58a1ca2fdf3ef16eb35185ecf226b4" translate="yes" xml:space="preserve">
          <source>Generates a random value. The state of the underlying engine is advanced one or more times.</source>
          <target state="translated">Генерирует случайное значение.Состояние основного двигателя прогрессирует один или несколько раз.</target>
        </trans-unit>
        <trans-unit id="045d154a63fd09f9bc95c348dc0baa989ebab1d6" translate="yes" xml:space="preserve">
          <source>Generates random numbers according to the &lt;a href=&quot;https://en.wikipedia.org/wiki/Normal_distribution&quot;&gt;Normal (or Gaussian) random number distribution&lt;/a&gt;. It is defined as:   f(x; &amp;mu;,&amp;sigma;) =</source>
          <target state="translated">Генерирует случайные числа в соответствии с &lt;a href=&quot;https://en.wikipedia.org/wiki/Normal_distribution&quot;&gt;нормальным (или гауссовым) распределением случайных чисел&lt;/a&gt; . Он определяется как: f (x; &amp;mu;, &amp;sigma;) =</target>
        </trans-unit>
        <trans-unit id="74b3ade82ac714c1951306b471876167535085c8" translate="yes" xml:space="preserve">
          <source>Generates random numbers that are distributed according to the associated probability function. The entropy is acquired by calling &lt;code&gt;g.operator()&lt;/code&gt;.</source>
          <target state="translated">Генерирует случайные числа, которые распределены в соответствии с ассоциированной функцией вероятности. Энтропия получается путем вызова &lt;code&gt;g.operator()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8d441fb5f62f87aca029a4bb398180b09920a3f5" translate="yes" xml:space="preserve">
          <source>Generation</source>
          <target state="translated">Generation</target>
        </trans-unit>
        <trans-unit id="742daa97a3eea8220673e99a3db1f627bdf6d93c" translate="yes" xml:space="preserve">
          <source>Generic (polymorphic) lambda expressions</source>
          <target state="translated">Общие (полиморфные)лямбда-выражения</target>
        </trans-unit>
        <trans-unit id="a3b12ef32437e95ff76df32c3bf2e29d863224ec" translate="yes" xml:space="preserve">
          <source>Generic components may, in addition, offer</source>
          <target state="translated">Общие компоненты могут,кроме того,предложить</target>
        </trans-unit>
        <trans-unit id="d399f4838f649a1dd72fc3c7d1626e48aca6fcc9" translate="yes" xml:space="preserve">
          <source>Generic locking algorithms</source>
          <target state="translated">Общие алгоритмы блокировки</target>
        </trans-unit>
        <trans-unit id="522f4aca708bf0b67f4969ccd2a81f0afbce9777" translate="yes" xml:space="preserve">
          <source>Generic mutex management</source>
          <target state="translated">Общий менеджмент мьютекса</target>
        </trans-unit>
        <trans-unit id="bb5f7091dca0b61fa982fa58c2f04caba2c88133" translate="yes" xml:space="preserve">
          <source>Generic pathname format</source>
          <target state="translated">Общий формат патнама</target>
        </trans-unit>
        <trans-unit id="5062b24e22ad40ee77724d279398f1dbf438838e" translate="yes" xml:space="preserve">
          <source>Get area</source>
          <target state="translated">Получить область</target>
        </trans-unit>
        <trans-unit id="f30e54b151b7e1d903f56be15b95cfc3a9e8869c" translate="yes" xml:space="preserve">
          <source>Gets and sets the exception mask of the stream. The exception mask determines the error states on occurrence of which the stream throws exception of type &lt;code&gt;&lt;a href=&quot;../ios_base/failure&quot;&gt;failure&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Получает и задает маску исключения для потока. Маска исключения определяет состояния ошибки, при возникновении которых поток генерирует исключение &lt;code&gt;&lt;a href=&quot;../ios_base/failure&quot;&gt;failure&lt;/a&gt;&lt;/code&gt; типа .</target>
        </trans-unit>
        <trans-unit id="b970edd37ceef3acb34a7c5e361913bd8492e2aa" translate="yes" xml:space="preserve">
          <source>Gets and sets the underlying string.</source>
          <target state="translated">Получает и устанавливает базовую строку.</target>
        </trans-unit>
        <trans-unit id="332452f1980fa4e174e790babca85d5c6e588e9e" translate="yes" xml:space="preserve">
          <source>Gets the default memory resource pointer.</source>
          <target state="translated">Получает указатель ресурсов памяти по умолчанию.</target>
        </trans-unit>
        <trans-unit id="499d742f096a087b00e3a25ac2c61ce6526047bb" translate="yes" xml:space="preserve">
          <source>Getting the result</source>
          <target state="translated">Получение результата</target>
        </trans-unit>
        <trans-unit id="a31c54bbb19e0e2599a1d0ad74d19479e5b692ac" translate="yes" xml:space="preserve">
          <source>Given &lt;code&gt;N = &lt;a href=&quot;../iterator/distance&quot;&gt;std::distance&lt;/a&gt;(first, last)&lt;/code&gt;, performs O(log N) applications of the predicate &lt;code&gt;p&lt;/code&gt;.</source>
          <target state="translated">Учитывая &lt;code&gt;N = &lt;a href=&quot;../iterator/distance&quot;&gt;std::distance&lt;/a&gt;(first, last)&lt;/code&gt; , выполняет O (log N) приложений предиката &lt;code&gt;p&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2de26a11901d553b8a58d6c3ba8e560899db14ac" translate="yes" xml:space="preserve">
          <source>Given &lt;code&gt;N = &lt;a href=&quot;../iterator/distance&quot;&gt;std::distance&lt;/a&gt;(first, last)&lt;/code&gt;},</source>
          <target state="translated">Учитывая &lt;code&gt;N = &lt;a href=&quot;../iterator/distance&quot;&gt;std::distance&lt;/a&gt;(first, last)&lt;/code&gt; },</target>
        </trans-unit>
        <trans-unit id="201a57a136c12310d1acc1180f1b02b9f2f6f001" translate="yes" xml:space="preserve">
          <source>Given &lt;code&gt;N = last - first&lt;/code&gt;.</source>
          <target state="translated">Учитывая &lt;code&gt;N = last - first&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d3e5ecd385ba57ca31705c6a420eb24ffafacec4" translate="yes" xml:space="preserve">
          <source>Given &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt;, dereferenceable iterators of type &lt;code&gt;It&lt;/code&gt;.</source>
          <target state="translated">Учитывая &lt;code&gt;a&lt;/code&gt; и &lt;code&gt;b&lt;/code&gt; , разыменовываемые итераторы типа &lt;code&gt;It&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bd092018ae73c0887d7dc6c9b1bb5a5adc4b89b7" translate="yes" xml:space="preserve">
          <source>Given N = &lt;code&gt;&lt;a href=&quot;../iterator/distance&quot;&gt;std::distance&lt;/a&gt;(first,last)&lt;/code&gt;,</source>
          <target state="translated">Учитывая N = &lt;code&gt;&lt;a href=&quot;../iterator/distance&quot;&gt;std::distance&lt;/a&gt;(first,last)&lt;/code&gt; ,</target>
        </trans-unit>
        <trans-unit id="a60f6d48405c975ae0935013623bdd24a66ebef7" translate="yes" xml:space="preserve">
          <source>Given a BinaryPredicate &lt;code&gt;bin_pred&lt;/code&gt; and a pair of iterators &lt;code&gt;iter1&lt;/code&gt; and &lt;code&gt;iter2&lt;/code&gt; or an iterator &lt;code&gt;iter&lt;/code&gt; and a value &lt;code&gt;value&lt;/code&gt;, the expression &lt;code&gt;bin_pred(*iter1, *iter2)&lt;/code&gt; or, respectively, &lt;code&gt;bin_pred(*iter, value)&lt;/code&gt;, must be &lt;a href=&quot;../language/implicit_cast&quot;&gt;contextually convertible&lt;/a&gt; to &lt;code&gt;bool&lt;/code&gt;.</source>
          <target state="translated">Учитывая BinaryPredicate &lt;code&gt;bin_pred&lt;/code&gt; и пару итераторов &lt;code&gt;iter1&lt;/code&gt; и &lt;code&gt;iter2&lt;/code&gt; или итератор &lt;code&gt;iter&lt;/code&gt; и значение &lt;code&gt;value&lt;/code&gt; , выражение &lt;code&gt;bin_pred(*iter1, *iter2)&lt;/code&gt; или, соответственно, &lt;code&gt;bin_pred(*iter, value)&lt;/code&gt; , должно быть &lt;a href=&quot;../language/implicit_cast&quot;&gt;контекстно конвертируемым&lt;/a&gt; в &lt;code&gt;bool&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8aa890934e1378f6d141dac2f7867c119b8ad1fa" translate="yes" xml:space="preserve">
          <source>Given a function parameter &lt;code&gt;P&lt;/code&gt; that depends on one or more type template parameters &lt;code&gt;T&lt;/code&gt;i, template template parameters &lt;code&gt;TT&lt;/code&gt;i, or non-type template parameters &lt;code&gt;I&lt;/code&gt;i, and the corresponding argument &lt;code&gt;A&lt;/code&gt;, deduction takes place if &lt;code&gt;P&lt;/code&gt; has one of the following forms:</source>
          <target state="translated">При заданном параметре функции &lt;code&gt;P&lt;/code&gt; , который зависит от одного или нескольких параметров шаблона типа &lt;code&gt;T&lt;/code&gt; i, параметров шаблона шаблона &lt;code&gt;TT&lt;/code&gt; i или параметров нетипичного шаблона &lt;code&gt;I&lt;/code&gt; i и соответствующего аргумента &lt;code&gt;A&lt;/code&gt; , вычет происходит, если &lt;code&gt;P&lt;/code&gt; имеет одну из следующих форм:</target>
        </trans-unit>
        <trans-unit id="849104a88d07876b31798d027eae5e4b5ac7a9c0" translate="yes" xml:space="preserve">
          <source>Given a pointer ptr to a buffer of size space, returns a pointer aligned by the specified alignment for size number of bytes and decreases space argument by the number of bytes used for alignment. The first aligned address is returned.</source>
          <target state="translated">Получая указатель ptr на буфер пространства размеров,возвращает указатель,выровненный по указанному выравниванию для количества байт и уменьшает аргумент пространства на количество байт,используемых для выравнивания.Возвращается первый адрес выравнивания.</target>
        </trans-unit>
        <trans-unit id="1d1642375a13cf9d00a6f14be269e1b8dfaf5497" translate="yes" xml:space="preserve">
          <source>Given a set of types &lt;code&gt;Args...&lt;/code&gt;, if &lt;code&gt;&lt;a href=&quot;../declval&quot;&gt;std::declval&lt;/a&gt;&amp;lt;Args&amp;gt;()...&lt;/code&gt; meet the requirements for arguments to &lt;code&gt;ranges::swap&lt;/code&gt; above, &lt;code&gt;SwapT&lt;/code&gt; will satisfy &lt;code&gt;std::&lt;a href=&quot;../../concepts/invocable&quot;&gt;Invocable&lt;/a&gt;&amp;lt;const SwapT&amp;amp;, Args...&amp;gt;&lt;/code&gt;. Otherwise, no function call operator of &lt;code&gt;SwapT&lt;/code&gt; participates in overload resolution.</source>
          <target state="translated">Учитывая набор типов &lt;code&gt;Args...&lt;/code&gt; , если &lt;code&gt;&lt;a href=&quot;../declval&quot;&gt;std::declval&lt;/a&gt;&amp;lt;Args&amp;gt;()...&lt;/code&gt; удовлетворяет требованиям для аргументов для &lt;code&gt;ranges::swap&lt;/code&gt; выше, &lt;code&gt;SwapT&lt;/code&gt; будет удовлетворять &lt;code&gt;std::&lt;a href=&quot;../../concepts/invocable&quot;&gt;Invocable&lt;/a&gt;&amp;lt;const SwapT&amp;amp;, Args...&amp;gt;&lt;/code&gt; . В противном случае ни один оператор вызова функции &lt;code&gt;SwapT&lt;/code&gt; не участвует в разрешении перегрузки.</target>
        </trans-unit>
        <trans-unit id="cd88ec801294426ab54d23bc136aca37fe96b8e0" translate="yes" xml:space="preserve">
          <source>Given a user-defined &lt;code&gt;operator==&lt;/code&gt; and &lt;code&gt;operator&amp;lt;&lt;/code&gt; for objects of type &lt;code&gt;T&lt;/code&gt;, implements the usual semantics of other comparison operators.</source>
          <target state="translated">Для заданного пользователем &lt;code&gt;operator==&lt;/code&gt; и &lt;code&gt;operator&amp;lt;&lt;/code&gt; для объектов типа &lt;code&gt;T&lt;/code&gt; реализуется обычная семантика других операторов сравнения.</target>
        </trans-unit>
        <trans-unit id="9347968d88bdedbaad63962c44f19bc3e70fd1d7" translate="yes" xml:space="preserve">
          <source>Given an instance &lt;code&gt;c&lt;/code&gt; of &lt;code&gt;map&lt;/code&gt;:</source>
          <target state="translated">Учитывая экземпляр &lt;code&gt;c&lt;/code&gt; на &lt;code&gt;map&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="c587de6b8b3e1339541445cfac7615e9dbb23ca9" translate="yes" xml:space="preserve">
          <source>Given an instance &lt;code&gt;c&lt;/code&gt; of &lt;code&gt;multimap&lt;/code&gt;:</source>
          <target state="translated">Учитывая экземпляр &lt;code&gt;c&lt;/code&gt; из &lt;code&gt;multimap&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="a14568942f46c8464d02bc68bb11bb1b20d8f671" translate="yes" xml:space="preserve">
          <source>Given an instance &lt;code&gt;c&lt;/code&gt; of &lt;code&gt;multiset&lt;/code&gt;:</source>
          <target state="translated">Учитывая экземпляр &lt;code&gt;c&lt;/code&gt; из &lt;code&gt;multiset&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="3e2459dd2b814290389adeffd53910165c623ff3" translate="yes" xml:space="preserve">
          <source>Given an instance &lt;code&gt;c&lt;/code&gt; of &lt;code&gt;set&lt;/code&gt;:</source>
          <target state="translated">Учитывая экземпляр &lt;code&gt;c&lt;/code&gt; из &lt;code&gt;set&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="881f1c518159f483a92d230aff08438c975cfc40" translate="yes" xml:space="preserve">
          <source>Given an instance &lt;code&gt;c&lt;/code&gt; of &lt;code&gt;unordered_map&lt;/code&gt;:</source>
          <target state="translated">Учитывая экземпляр &lt;code&gt;c&lt;/code&gt; из &lt;code&gt;unordered_map&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="fa31a301eaa86d94083d76755aeb6d15245d1d46" translate="yes" xml:space="preserve">
          <source>Given an instance &lt;code&gt;c&lt;/code&gt; of &lt;code&gt;unordered_multimap&lt;/code&gt;:</source>
          <target state="translated">Учитывая экземпляр &lt;code&gt;c&lt;/code&gt; из &lt;code&gt;unordered_multimap&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="f6d85ed3e34fe83d62419c16e466b796d53d7bae" translate="yes" xml:space="preserve">
          <source>Given an instance &lt;code&gt;c&lt;/code&gt; of &lt;code&gt;unordered_multiset&lt;/code&gt;:</source>
          <target state="translated">Учитывая экземпляр &lt;code&gt;c&lt;/code&gt; из &lt;code&gt;unordered_multiset&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="a229fa6402280d8d3988d3795c697a501535b4a0" translate="yes" xml:space="preserve">
          <source>Given an instance &lt;code&gt;c&lt;/code&gt; of &lt;code&gt;unordered_set&lt;/code&gt;:</source>
          <target state="translated">Учитывая экземпляр &lt;code&gt;c&lt;/code&gt; из &lt;code&gt;unordered_set&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="585b276223e3efe88a4cec484dd924b01d338788" translate="yes" xml:space="preserve">
          <source>Given an object &lt;code&gt;G&lt;/code&gt; obtained from an earlier call to &lt;code&gt;bind_front(f, args...)&lt;/code&gt;, when a glvalue &lt;code&gt;g&lt;/code&gt; designating &lt;code&gt;G&lt;/code&gt; is invoked in a function call expression &lt;code&gt;g(call_args...)&lt;/code&gt;, an invocation of the stored object takes place, as if by.</source>
          <target state="translated">Учитывая объект &lt;code&gt;G&lt;/code&gt; , полученный из более раннего вызова &lt;code&gt;bind_front(f, args...)&lt;/code&gt; , когда glvalue &lt;code&gt;g&lt;/code&gt; , обозначающий &lt;code&gt;G&lt;/code&gt; , вызывается в выражении вызова функции &lt;code&gt;g(call_args...)&lt;/code&gt; , происходит вызов сохраненного объекта, как будто мимо.</target>
        </trans-unit>
        <trans-unit id="a88f34b4e5838dad793cf28d772a20e6a14e6fb1" translate="yes" xml:space="preserve">
          <source>Given an object &lt;code&gt;g&lt;/code&gt; obtained from an earlier call to &lt;code&gt;bind&lt;/code&gt;, when it is invoked in a function call expression &lt;code&gt;g(u1, u2, ... uM)&lt;/code&gt;, an invocation of the stored object takes place, as if by &lt;code&gt;&lt;a href=&quot;invoke&quot;&gt;std::invoke&lt;/a&gt;(fd, &lt;a href=&quot;../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;V1&amp;gt;(v1), &lt;a href=&quot;../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;V2&amp;gt;(v2), ..., &lt;a href=&quot;../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;VN&amp;gt;(vN))&lt;/code&gt;, where &lt;code&gt;fd&lt;/code&gt; is a value of type &lt;code&gt;&lt;a href=&quot;../../types/decay&quot;&gt;std::decay_t&lt;/a&gt;&amp;lt;F&amp;gt;&lt;/code&gt; the values and types of the bound arguments &lt;code&gt;v1, v2, ..., vN&lt;/code&gt; are determined as specified below.</source>
          <target state="translated">Учитывая объект &lt;code&gt;g&lt;/code&gt; , полученный из более раннего вызова &lt;code&gt;bind&lt;/code&gt; , когда он вызывается в выражении вызова функции &lt;code&gt;g(u1, u2, ... uM)&lt;/code&gt; , происходит вызов хранимого объекта, как если бы это было &lt;code&gt;&lt;a href=&quot;invoke&quot;&gt;std::invoke&lt;/a&gt;(fd, &lt;a href=&quot;../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;V1&amp;gt;(v1), &lt;a href=&quot;../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;V2&amp;gt;(v2), ..., &lt;a href=&quot;../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;VN&amp;gt;(vN))&lt;/code&gt; помощью std :: invoke ( fd, std :: forward &amp;lt;V1&amp;gt; (v1), std :: forward &amp;lt;V2&amp;gt; (v2), ..., std :: forward &amp;lt;VN&amp;gt; (vN)) , где &lt;code&gt;fd&lt;/code&gt; - значение типа &lt;code&gt;&lt;a href=&quot;../../types/decay&quot;&gt;std::decay_t&lt;/a&gt;&amp;lt;F&amp;gt;&lt;/code&gt; значения и типы связанных аргументов &lt;code&gt;v1, v2, ..., vN&lt;/code&gt; определяются, как указано ниже.</target>
        </trans-unit>
        <trans-unit id="a8337adfa8cf3c8e162bcbe5e0229685e6eb60d8" translate="yes" xml:space="preserve">
          <source>Given the character sequence from the previous steps, if the first character equals &lt;code&gt;ct.widen('-')&lt;/code&gt;, calls &lt;code&gt;mp.neg_format()&lt;/code&gt; to obtain the formatting &lt;code&gt;&lt;a href=&quot;../money_base&quot;&gt;pattern&lt;/a&gt;&lt;/code&gt;, otherwise calls &lt;code&gt;mp.pos_format()&lt;/code&gt;, where &lt;code&gt;mp&lt;/code&gt; is the &lt;code&gt;&lt;a href=&quot;../moneypunct&quot;&gt;std::moneypunct&lt;/a&gt;&amp;lt;CharT, intl&amp;gt;&lt;/code&gt; facet imbued in &lt;code&gt;str.getloc()&lt;/code&gt;.</source>
          <target state="translated">Учитывая последовательность символов из предыдущих шагов, если первый символ равен &lt;code&gt;ct.widen('-')&lt;/code&gt; , вызывает &lt;code&gt;mp.neg_format()&lt;/code&gt; для получения &lt;code&gt;&lt;a href=&quot;../money_base&quot;&gt;pattern&lt;/a&gt;&lt;/code&gt; форматирования , в противном случае вызывает &lt;code&gt;mp.pos_format()&lt;/code&gt; , где &lt;code&gt;mp&lt;/code&gt; - это &lt;code&gt;&lt;a href=&quot;../moneypunct&quot;&gt;std::moneypunct&lt;/a&gt;&amp;lt;CharT, intl&amp;gt;&lt;/code&gt; &lt;code&gt;str.getloc()&lt;/code&gt; в str.getloc () .</target>
        </trans-unit>
        <trans-unit id="66236ee54dcad384d354db9941193df8b20deffb" translate="yes" xml:space="preserve">
          <source>Given the set of candidate functions, constructed as described above, the next step of overload resolution is examining arguments and parameters to reduce the set to the set of</source>
          <target state="translated">Учитывая набор функций-кандидатов,построенных,как описано выше,следующим шагом разрешения перегрузки является изучение аргументов и параметров для уменьшения набора до набора из</target>
        </trans-unit>
        <trans-unit id="c0aebd42da085f11a7898d7938dcfcf81f34f4ad" translate="yes" xml:space="preserve">
          <source>Given the starting value s, a list of strides i</source>
          <target state="translated">Учитывая начальное значение s,список шагов i</target>
        </trans-unit>
        <trans-unit id="93321ba8b5317191b60feb65e2cf919f7e2a81f1" translate="yes" xml:space="preserve">
          <source>Given.</source>
          <target state="translated">Given.</target>
        </trans-unit>
        <trans-unit id="c46a97000778eff7a9406aa7dac4bb058a740c4f" translate="yes" xml:space="preserve">
          <source>Gives well-defined results for reference types, void types, array types, and function types.</source>
          <target state="translated">Дает четко определенные результаты для типов ссылок,типов пустот,типов массивов и типов функций.</target>
        </trans-unit>
        <trans-unit id="6c1092b384c391c235bf0f03a6b067bc9829d4dd" translate="yes" xml:space="preserve">
          <source>Global objects</source>
          <target state="translated">Глобальные объекты</target>
        </trans-unit>
        <trans-unit id="8ecf59cbff938c3c09e7ac755a67fc60c8335206" translate="yes" xml:space="preserve">
          <source>Global replacements</source>
          <target state="translated">Глобальные замены</target>
        </trans-unit>
        <trans-unit id="6f85091c78ab312c0eeab087e50a90d21a6d8a82" translate="yes" xml:space="preserve">
          <source>Guaranteed copy elision through simplified &lt;a href=&quot;language/value_category&quot;&gt;value categories&lt;/a&gt;</source>
          <target state="translated">Гарантированное копирование через упрощенные &lt;a href=&quot;language/value_category&quot;&gt;категории значений&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="daf1a29d21388e553e2e351d8eb2ded2e9be0a7c" translate="yes" xml:space="preserve">
          <source>Guides (2-3) are needed because the &lt;code&gt;&lt;a href=&quot;../basic_string&quot;&gt;std::basic_string&lt;/a&gt;&lt;/code&gt; constructors for &lt;code&gt;&lt;a href=&quot;../basic_string_view&quot;&gt;std::basic_string_view&lt;/a&gt;&lt;/code&gt;s are made templates to avoid causing ambiguities in existing code, and those templates do not support class template argument deduction.</source>
          <target state="translated">Руководства (2-3) необходимы, потому что конструкторы &lt;code&gt;&lt;a href=&quot;../basic_string&quot;&gt;std::basic_string&lt;/a&gt;&lt;/code&gt; для &lt;code&gt;&lt;a href=&quot;../basic_string_view&quot;&gt;std::basic_string_view&lt;/a&gt;&lt;/code&gt; являются шаблонами, чтобы избежать двусмысленности в существующем коде, и эти шаблоны не поддерживают вывод аргументов шаблона класса.</target>
        </trans-unit>
        <trans-unit id="ab161f039e51e47e91c7fb547b04ada20d53b4a3" translate="yes" xml:space="preserve">
          <source>H. Sutter (1998) &lt;a href=&quot;http://www.gotw.ca/publications/mill02.htm&quot;&gt;&quot;What's In a Class? - The Interface Principle&quot;&lt;/a&gt; in C++ Report, 10(3)</source>
          <target state="translated">Х. Саттер (1998) &lt;a href=&quot;http://www.gotw.ca/publications/mill02.htm&quot;&gt;&amp;laquo;Что в классе? - Принцип интерфейса&amp;raquo;&lt;/a&gt; в отчете C ++, 10 (3)</target>
        </trans-unit>
        <trans-unit id="4d2fcf54f70e7b8f49c067c962c20ecc9c2156b7" translate="yes" xml:space="preserve">
          <source>H. Sutter (2000) &quot;Exceptional C++&quot;</source>
          <target state="translated">H.Саттер (2000)&quot;Исключительный С++&quot;.</target>
        </trans-unit>
        <trans-unit id="4dba1c99fa72599cb430192c2725ee29e7826d41" translate="yes" xml:space="preserve">
          <source>H. Sutter (2004) &lt;a href=&quot;http://www.drdobbs.com/when-and-how-to-use-exceptions/184401836&quot;&gt;&quot;When and How to Use Exceptions&quot;&lt;/a&gt; in Dr. Dobb's</source>
          <target state="translated">Х. Саттер (2004) &lt;a href=&quot;http://www.drdobbs.com/when-and-how-to-use-exceptions/184401836&quot;&gt;&amp;laquo;Когда и как использовать исключения&amp;raquo;&lt;/a&gt; в книге доктора Добба</target>
        </trans-unit>
        <trans-unit id="f3726a2cbec5aa86ee541f35ad869f9d462e3d65" translate="yes" xml:space="preserve">
          <source>H.Sutter, A. Alexandrescu (2004) &quot;C++ Coding Standards&quot; Item 73</source>
          <target state="translated">Х.Саттер,А.Александреску (2004)&quot;Стандарты кодирования C++&quot; Пункт 73</target>
        </trans-unit>
        <trans-unit id="3ee760973e367e7fcaab598e6a4779e4ff88cda5" translate="yes" xml:space="preserve">
          <source>H.Sutter, A. Alexandrescu (2004), &quot;C++ Coding Standards&quot;, Item 70</source>
          <target state="translated">Х.Саттер,А.Александреску (2004),&quot;Стандарты кодирования С++&quot;,пункт 70.</target>
        </trans-unit>
        <trans-unit id="202043e89dc2aeb009dea78fe3ba6aecc90d862d" translate="yes" xml:space="preserve">
          <source>HANGZHOU NUMERAL ONE - HANGUL DOUBLE DOT TONE MARK</source>
          <target state="translated">ХАНЧЖОУСКАЯ ЦИФРА ОДИН-ХАНГУЛЬСКАЯ ДВОЙНАЯ ТОЧЕЧНАЯ МЕТКА</target>
        </trans-unit>
        <trans-unit id="498203d3437361cd8d2965b93c0eb3f8af84971a" translate="yes" xml:space="preserve">
          <source>HUGE_VALF, HUGE_VAL, HUGE_VALL</source>
          <target state="translated">HUGE_VALF,HUGE_VAL,HUGE_VALL</target>
        </trans-unit>
        <trans-unit id="0ff054331f849fe26ab715fa596bf0d6c1b9b49c" translate="yes" xml:space="preserve">
          <source>HUGE_VALFHUGE_VALHUGE_VALL</source>
          <target state="translated">HUGE_VALFHUGE_VALHUGE_VALL</target>
        </trans-unit>
        <trans-unit id="b38181b2101d3ec22f60111fb7da75e6dc9d72e8" translate="yes" xml:space="preserve">
          <source>HUGE_VALL</source>
          <target state="translated">HUGE_VALL</target>
        </trans-unit>
        <trans-unit id="71eafe8cf5a2cb341c2f05d96f0f6422891ac1dd" translate="yes" xml:space="preserve">
          <source>Handling of exception specification violations (removed in C++17)</source>
          <target state="translated">Обработка нарушений спецификации исключений (удалено на C++17)</target>
        </trans-unit>
        <trans-unit id="5c4704b5df9665a78c88de802bae877af50465d2" translate="yes" xml:space="preserve">
          <source>Handling of failures in exception handling</source>
          <target state="translated">Обработка отказов в обработке исключений</target>
        </trans-unit>
        <trans-unit id="ea1720079c69bfadf4103ddaa2b4cd30fc66377a" translate="yes" xml:space="preserve">
          <source>Handling of variable length argument lists</source>
          <target state="translated">Обработка списков аргументов переменной длины</target>
        </trans-unit>
        <trans-unit id="0e8c641cc752e55897602b479a23cc749b022d01" translate="yes" xml:space="preserve">
          <source>Happens-before</source>
          <target state="translated">Happens-before</target>
        </trans-unit>
        <trans-unit id="94332d550f7e901bb03f8bebf16b0fe18a1b3ec5" translate="yes" xml:space="preserve">
          <source>Hard links typically cannot cross filesystem boundaries.</source>
          <target state="translated">Жесткие ссылки обычно не могут пересекать границы файловой системы.</target>
        </trans-unit>
        <trans-unit id="5c50832940f07dd15684fc07335b91ae9b50c034" translate="yes" xml:space="preserve">
          <source>Hardlinking to directories is typically restricted to the superuser.</source>
          <target state="translated">Связь с каталогами,как правило,ограничивается суперпользователем.</target>
        </trans-unit>
        <trans-unit id="b2bd7d3deca1dfde9d0e77745248dd3241e3fb2f" translate="yes" xml:space="preserve">
          <source>Hardware could require that an object to be referenced by an &lt;code&gt;atomic_ref&amp;lt;T&amp;gt;&lt;/code&gt; have stricter alignment than other &lt;code&gt;T&lt;/code&gt; objects, and whether operations on an &lt;code&gt;atomic_ref&lt;/code&gt; are lock-free can depend on the alignment of the referenced object.</source>
          <target state="translated">Аппаратное обеспечение может потребовать, чтобы объект, на который ссылается &lt;code&gt;atomic_ref&amp;lt;T&amp;gt;&lt;/code&gt; имел более строгое выравнивание, чем другие объекты &lt;code&gt;T&lt;/code&gt; , и то, будут ли операции с &lt;code&gt;atomic_ref&lt;/code&gt; свободными от блокировки, может зависеть от выравнивания ссылочного объекта.</target>
        </trans-unit>
        <trans-unit id="50278ca49d19fb7161c9b6156704c44ac84f382e" translate="yes" xml:space="preserve">
          <source>Has all non-static data members and bit-fields declared in the same class (either all in the derived or all in some base)</source>
          <target state="translated">Имеет все нестатические члены данных и битовые поля,объявленные в одном и том же классе (либо все в производном,либо все в какой-то базе)</target>
        </trans-unit>
        <trans-unit id="132088df73d03b2b991fee16006dc96529cc0d11" translate="yes" xml:space="preserve">
          <source>Has no base classes of the same type as the first non-static data member (see &lt;a href=&quot;../language/ebo&quot;&gt;empty base optimization&lt;/a&gt;)</source>
          <target state="translated">Не имеет базовых классов того же типа, что и первый нестатический элемент данных (см. &lt;a href=&quot;../language/ebo&quot;&gt;Пустую базовую оптимизацию&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="3282080bc3a2066760485abf22d4931cd7cf3786" translate="yes" xml:space="preserve">
          <source>Has no non-static data members of reference type</source>
          <target state="translated">Не имеет нестатических членов данных ссылочного типа</target>
        </trans-unit>
        <trans-unit id="c4b0a2efb77a438bdd71e13e8a4b27ab2c2ef90e" translate="yes" xml:space="preserve">
          <source>Has no two (possibly indirect) base class subobjects of the same type</source>
          <target state="translated">Не имеет двух (возможно,косвенных)подобъектов базового класса одного и того же типа</target>
        </trans-unit>
        <trans-unit id="e78a6eedfa1171855e11a7dd558ba1ee29f9b975" translate="yes" xml:space="preserve">
          <source>Has no virtual functions or virtual base classes</source>
          <target state="translated">Не имеет виртуальных функций или виртуальных базовых классов</target>
        </trans-unit>
        <trans-unit id="07ad7632b84dfe67303c7a8f028a0886800e4870" translate="yes" xml:space="preserve">
          <source>Has one or more &lt;a href=&quot;../language/default_constructor&quot;&gt;default constructors&lt;/a&gt;, all of which are either &lt;a href=&quot;../language/default_constructor#Trivial_default_constructor&quot;&gt;trivial&lt;/a&gt; or deleted, and at least one of which is not deleted.</source>
          <target state="translated">Имеет один или несколько &lt;a href=&quot;../language/default_constructor&quot;&gt;конструкторов по умолчанию&lt;/a&gt; , каждый из которых либо &lt;a href=&quot;../language/default_constructor#Trivial_default_constructor&quot;&gt;тривиален,&lt;/a&gt; либо удален, и хотя бы один из них не удален.</target>
        </trans-unit>
        <trans-unit id="873507a022b58de26a88deae87268cbd8d6af5b1" translate="yes" xml:space="preserve">
          <source>Hash</source>
          <target state="translated">Hash</target>
        </trans-unit>
        <trans-unit id="cc87e65725671e76b83dd75a39435552efd495a6" translate="yes" xml:space="preserve">
          <source>Hash functions are only required to produce the same result for the same input within a single execution of a program; this allows salted hashes that prevent collision denial-of-service attacks.</source>
          <target state="translated">Хэш-функции необходимы только для получения одного и того же результата для одного и того же входа в рамках одного выполнения программы;это позволяет использовать соленые хэши,предотвращающие атаки типа &quot;отказ в обслуживании&quot; при столкновении.</target>
        </trans-unit>
        <trans-unit id="4cd57ebbbfb5b1908d66fa1e003e1ce14e29637e" translate="yes" xml:space="preserve">
          <source>Hash functions should not throw exceptions.</source>
          <target state="translated">Хэш-функции не должны бросать исключения.</target>
        </trans-unit>
        <trans-unit id="7250b05d4111b3b36a49cda927210c8e3d368f6a" translate="yes" xml:space="preserve">
          <source>Hash policy</source>
          <target state="translated">хеш-политика</target>
        </trans-unit>
        <trans-unit id="b807d317600ff4b338e846d561ee4e0b84f0360a" translate="yes" xml:space="preserve">
          <source>Hash support</source>
          <target state="translated">Хэш-поддержка</target>
        </trans-unit>
        <trans-unit id="53e49a69fb315c4f51afc9825055d4858a064cdc" translate="yes" xml:space="preserve">
          <source>Hashing</source>
          <target state="translated">Hashing</target>
        </trans-unit>
        <trans-unit id="31341c6f0c7af677ffb8fadcb92038e8ac2b6193" translate="yes" xml:space="preserve">
          <source>Header</source>
          <target state="translated">Header</target>
        </trans-unit>
        <trans-unit id="f123fa3f00736262aa136563dd12c3a430fa1bf8" translate="yes" xml:space="preserve">
          <source>Header name preprocessing tokens are only formed within a &lt;code&gt;#include&lt;/code&gt; directive.</source>
          <target state="translated">Токены предварительной обработки имени заголовка формируются только в директиве &lt;code&gt;#include&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1a9eca02fd1369c5ba18c271ae9822e684c6bc3d" translate="yes" xml:space="preserve">
          <source>Headers required for a</source>
          <target state="translated">Заголовки,необходимые для</target>
        </trans-unit>
        <trans-unit id="8cd5e50ec159eebcf43e109ff007519db94c87f5" translate="yes" xml:space="preserve">
          <source>Heap allocation</source>
          <target state="translated">Распределение кучи</target>
        </trans-unit>
        <trans-unit id="adcf91c671cec8bebaf87ee37c2421ff5ebb56fd" translate="yes" xml:space="preserve">
          <source>Heap operations</source>
          <target state="translated">Куча операций</target>
        </trans-unit>
        <trans-unit id="43a1b94a7a6895d855248fbccdd91510cfbd3ac0" translate="yes" xml:space="preserve">
          <source>Helper Classes</source>
          <target state="translated">Классы помощника</target>
        </trans-unit>
        <trans-unit id="035f96a8918459049a59bec0947605cd2a64fdef" translate="yes" xml:space="preserve">
          <source>Helper classes</source>
          <target state="translated">Классы помощи</target>
        </trans-unit>
        <trans-unit id="7612db9ee91cb4487af96f647ff4f3cd2038be3a" translate="yes" xml:space="preserve">
          <source>Helper concepts</source>
          <target state="translated">Концепции помощи</target>
        </trans-unit>
        <trans-unit id="058d2ea713d8ed40ef598fece850d00d28cef415" translate="yes" xml:space="preserve">
          <source>Helper functions &lt;code&gt;&lt;a href=&quot;ref&quot;&gt;std::ref&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;ref&quot;&gt;std::cref&lt;/a&gt;&lt;/code&gt; are often used to generate &lt;code&gt;std::reference_wrapper&lt;/code&gt; objects.</source>
          <target state="translated">Вспомогательные функции &lt;code&gt;&lt;a href=&quot;ref&quot;&gt;std::ref&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;ref&quot;&gt;std::cref&lt;/a&gt;&lt;/code&gt; часто используются для генерации объектов &lt;code&gt;std::reference_wrapper&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e9564c40bd71a52a2d2792a274dcd71ecab83247" translate="yes" xml:space="preserve">
          <source>Helper functions to control the format of input and output</source>
          <target state="translated">Функции помощника для управления форматом входа и выхода</target>
        </trans-unit>
        <trans-unit id="24355834da4c51ce8fa25dadf7ca038baf516e2f" translate="yes" xml:space="preserve">
          <source>Helper objects</source>
          <target state="translated">вспомогательные объекты</target>
        </trans-unit>
        <trans-unit id="bbca939563aab0002ed11e9e60251643d9e2435c" translate="yes" xml:space="preserve">
          <source>Helper template</source>
          <target state="translated">Шаблон помощника</target>
        </trans-unit>
        <trans-unit id="26e4565205fc729962b9119b4035fad3d08ea499" translate="yes" xml:space="preserve">
          <source>Helper template alias</source>
          <target state="translated">Псевдоним шаблона помощника</target>
        </trans-unit>
        <trans-unit id="62f3bc8fedb9c00e4b9d3da1c58627fb9c932c3e" translate="yes" xml:space="preserve">
          <source>Helper templates</source>
          <target state="translated">Шаблоны справки</target>
        </trans-unit>
        <trans-unit id="58208feff4ae33c36603b46c3dceaa24f222cc8d" translate="yes" xml:space="preserve">
          <source>Helper types</source>
          <target state="translated">Типы помощников</target>
        </trans-unit>
        <trans-unit id="0b456005f09a660089e455709c3792d427e45f64" translate="yes" xml:space="preserve">
          <source>Helper variable template</source>
          <target state="translated">Шаблон переменной Helper</target>
        </trans-unit>
        <trans-unit id="777d2c2c6fac9bb59d841ec60aa0bce62ce73ffb" translate="yes" xml:space="preserve">
          <source>Helper variable templates</source>
          <target state="translated">Шаблоны переменных Helper</target>
        </trans-unit>
        <trans-unit id="3c9b3433e6f225e4ae00ef2041d44d91bfbf7113" translate="yes" xml:space="preserve">
          <source>Helpers</source>
          <target state="translated">Helpers</target>
        </trans-unit>
        <trans-unit id="7023d54552e06b34cfb338ed903ce5341dc89c1a" translate="yes" xml:space="preserve">
          <source>Here &amp;mu; is the &lt;a href=&quot;https://en.wikipedia.org/wiki/Mean&quot;&gt;mean&lt;/a&gt; and &amp;sigma; is the &lt;a href=&quot;https://en.wikipedia.org/wiki/Standard_deviation&quot;&gt;standard deviation&lt;/a&gt; (</source>
          <target state="translated">Здесь &amp;mu; - &lt;a href=&quot;https://en.wikipedia.org/wiki/Mean&quot;&gt;среднее значение,&lt;/a&gt; а &amp;sigma; - &lt;a href=&quot;https://en.wikipedia.org/wiki/Standard_deviation&quot;&gt;стандартное отклонение&lt;/a&gt; (</target>
        </trans-unit>
        <trans-unit id="de582de9c63661c059dbbb7442ed40762e356594" translate="yes" xml:space="preserve">
          <source>Here the sequence &lt;code&gt;= 0&lt;/code&gt; is known as pure-specifier, and appears either immediately after the declarator or after the optional virt-specifier (&lt;a href=&quot;override&quot;&gt;override&lt;/a&gt; or &lt;a href=&quot;final&quot;&gt;final&lt;/a&gt;).</source>
          <target state="translated">Здесь последовательность &lt;code&gt;= 0&lt;/code&gt; известна как чистый спецификатор и появляется либо сразу после объявления, либо после необязательного виртуального спецификатора ( &lt;a href=&quot;override&quot;&gt;переопределение&lt;/a&gt; или &lt;a href=&quot;final&quot;&gt;финал&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="f4d46b65d1ca1962518c48c70d9aa7c8452f90c5" translate="yes" xml:space="preserve">
          <source>Here, &lt;b&gt;insertion&lt;/b&gt; refers to any method which adds one or more elements to the container and &lt;b&gt;erasure&lt;/b&gt; refers to any method which removes one or more elements from the container.</source>
          <target state="translated">Здесь, &lt;b&gt;вставка&lt;/b&gt; относится к любому способу , который добавляет один или более элементы в контейнер и &lt;b&gt;стирание&lt;/b&gt; относится к любому способу , который удаляет один или несколько элементов из контейнера.</target>
        </trans-unit>
        <trans-unit id="b19a132f13926967d1824a2efe39a0ee64381eb2" translate="yes" xml:space="preserve">
          <source>Hermite polynomials</source>
          <target state="translated">эрмитажные полиномы</target>
        </trans-unit>
        <trans-unit id="2dc4f9ad06827dbb0f947199ccb4b57ddbc18030" translate="yes" xml:space="preserve">
          <source>Hexadecimal escape sequences have no length limit and terminate at the first character that is not a valid hexadecimal digit. If the value represented by a single hexadecimal escape sequence does not fit the range of values represented by the character type used in this string literal (&lt;code&gt;char&lt;/code&gt;, &lt;code&gt;char16_t&lt;/code&gt;, &lt;code&gt;char32_t&lt;/code&gt;, or &lt;code&gt;wchar_t&lt;/code&gt;), the result is unspecified.</source>
          <target state="translated">Шестнадцатеричные escape-последовательности не имеют ограничения по длине и оканчиваются на первый символ, который не является допустимой шестнадцатеричной цифрой. Если значение, представленное одной шестнадцатеричной escape-последовательностью, не соответствует диапазону значений, представленных типом символов, используемым в этом строковом литерале ( &lt;code&gt;char&lt;/code&gt; , &lt;code&gt;char16_t&lt;/code&gt; , &lt;code&gt;char32_t&lt;/code&gt; или &lt;code&gt;wchar_t&lt;/code&gt; ), результат не указан.</target>
        </trans-unit>
        <trans-unit id="29f4576900e04b4bdfd8b4fe7f982605474c3863" translate="yes" xml:space="preserve">
          <source>Hexadecimal floating literals</source>
          <target state="translated">плавающие шестнадцатеричные буквы</target>
        </trans-unit>
        <trans-unit id="fcb2d1955da83c672014766fe096b6618bd4cc33" translate="yes" xml:space="preserve">
          <source>Hexadecimal floating-point formatting ignores the stream precision specification, as required by the specification of &lt;code&gt;&lt;a href=&quot;../../locale/num_put/put&quot;&gt;std::num_put::do_put&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Шестнадцатеричное форматирование с плавающей точкой игнорирует спецификацию точности потока, как того требует спецификация &lt;code&gt;&lt;a href=&quot;../../locale/num_put/put&quot;&gt;std::num_put::do_put&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="903711dad7d075316de1f7c8c822711821173306" translate="yes" xml:space="preserve">
          <source>Higher level memory management utilities</source>
          <target state="translated">Утилиты управления памятью более высокого уровня</target>
        </trans-unit>
        <trans-unit id="90ccd6497400b5576aeca1bd94af74aae1e0a250" translate="yes" xml:space="preserve">
          <source>History</source>
          <target state="translated">History</target>
        </trans-unit>
        <trans-unit id="0201fd3572c6260109888327f99b40b98e8c814b" translate="yes" xml:space="preserve">
          <source>History of C++</source>
          <target state="translated">История С++</target>
        </trans-unit>
        <trans-unit id="9c025e64c93f51353b31decb167c0c14635a6990" translate="yes" xml:space="preserve">
          <source>Host is unreachable</source>
          <target state="translated">Хозяин недоступен</target>
        </trans-unit>
        <trans-unit id="96e08c08807a48c02c8a25b2e222a3aa87859604" translate="yes" xml:space="preserve">
          <source>Hour, minute, second</source>
          <target state="translated">Час,минута,секунда</target>
        </trans-unit>
        <trans-unit id="a84d5827435e6eaee2628507f60c486924602e72" translate="yes" xml:space="preserve">
          <source>However if &lt;code&gt;ForwardIt1&lt;/code&gt; and &lt;code&gt;ForwardIt2&lt;/code&gt; meet the requirements of &lt;a href=&quot;../named_req/randomaccessiterator&quot;&gt;LegacyRandomAccessIterator&lt;/a&gt; and &lt;code&gt;&lt;a href=&quot;../iterator/distance&quot;&gt;std::distance&lt;/a&gt;(first1, last1) != &lt;a href=&quot;../iterator/distance&quot;&gt;std::distance&lt;/a&gt;(first2, last2)&lt;/code&gt; no applications of the predicate are made.</source>
          <target state="translated">Однако, если &lt;code&gt;ForwardIt1&lt;/code&gt; и &lt;code&gt;ForwardIt2&lt;/code&gt; соответствуют требованиям &lt;a href=&quot;../named_req/randomaccessiterator&quot;&gt;LegacyRandomAccessIterator&lt;/a&gt; и &lt;code&gt;&lt;a href=&quot;../iterator/distance&quot;&gt;std::distance&lt;/a&gt;(first1, last1) != &lt;a href=&quot;../iterator/distance&quot;&gt;std::distance&lt;/a&gt;(first2, last2)&lt;/code&gt; приложения предиката не создаются.</target>
        </trans-unit>
        <trans-unit id="06e6faa2b0497056bfffbc66aaba9ed450e5ff3a" translate="yes" xml:space="preserve">
          <source>However, all C++ compilers use &lt;a href=&quot;https://en.wikipedia.org/wiki/Two's_complement&quot;&gt;two's complement&lt;/a&gt; representation, and as of C++20, it is the only representation allowed by the standard, with the guaranteed range from -2N-1</source>
          <target state="translated">Однако все компиляторы C ++ используют представление &lt;a href=&quot;https://en.wikipedia.org/wiki/Two's_complement&quot;&gt;дополнения до двух&lt;/a&gt; , и начиная с C ++ 20 это единственное представление, разрешенное стандартом, с гарантированным диапазоном от -2N-1</target>
        </trans-unit>
        <trans-unit id="a5298c4b4732ec5cdb50753f0b7bff99ff4504e8" translate="yes" xml:space="preserve">
          <source>However, base class subobjects are not so constrained, and can be completely optimized out from the object layout:</source>
          <target state="translated">Однако подобъекты базового класса не столь ограничены и могут быть полностью оптимизированы из компоновки объектов:</target>
        </trans-unit>
        <trans-unit id="0474028c83ae02e6c1719cbd200f19338eb23c2e" translate="yes" xml:space="preserve">
          <source>However, for non-&lt;a href=&quot;../named_req/randomaccessiterator&quot;&gt;LegacyRandomAccessIterators&lt;/a&gt;, the number of iterator increments is O(N).</source>
          <target state="translated">Однако для не &lt;a href=&quot;../named_req/randomaccessiterator&quot;&gt;LegacyRandomAccessIterators&lt;/a&gt; число приращений итератора равно O (N).</target>
        </trans-unit>
        <trans-unit id="a7074ce423985ae2c548c5817d3af2b722ab809a" translate="yes" xml:space="preserve">
          <source>However, if &lt;code&gt;BidirIt&lt;/code&gt; additionally meets the requirements of &lt;a href=&quot;../named_req/randomaccessiterator&quot;&gt;LegacyRandomAccessIterator&lt;/a&gt;, complexity is constant.</source>
          <target state="translated">Однако, если &lt;code&gt;BidirIt&lt;/code&gt; дополнительно соответствует требованиям &lt;a href=&quot;../named_req/randomaccessiterator&quot;&gt;LegacyRandomAccessIterator&lt;/a&gt; , сложность постоянна.</target>
        </trans-unit>
        <trans-unit id="c130fc889986236f01e7bd0a7491d9e506116625" translate="yes" xml:space="preserve">
          <source>However, if &lt;code&gt;InputIt1&lt;/code&gt; and &lt;code&gt;InputIt2&lt;/code&gt; meet the requirements of &lt;a href=&quot;../named_req/randomaccessiterator&quot;&gt;LegacyRandomAccessIterator&lt;/a&gt; and &lt;code&gt;last1 - first1 != last2 - first2&lt;/code&gt; then no applications of the predicate are made (size mismatch is detected without looking at any elements).</source>
          <target state="translated">Однако, если &lt;code&gt;InputIt1&lt;/code&gt; и &lt;code&gt;InputIt2&lt;/code&gt; удовлетворяют требованиям &lt;a href=&quot;../named_req/randomaccessiterator&quot;&gt;LegacyRandomAccessIterator&lt;/a&gt; и last1 &lt;code&gt;last1 - first1 != last2 - first2&lt;/code&gt; тогда не применяются приложения предиката (несоответствие размера обнаруживается без просмотра каких-либо элементов).</target>
        </trans-unit>
        <trans-unit id="d4de2084e6a7ba7c4a9702f5d91188f9754f96a6" translate="yes" xml:space="preserve">
          <source>However, if &lt;code&gt;InputIt&lt;/code&gt; additionally meets the requirements of &lt;a href=&quot;../named_req/randomaccessiterator&quot;&gt;LegacyRandomAccessIterator&lt;/a&gt;, complexity is constant.</source>
          <target state="translated">Однако, если &lt;code&gt;InputIt&lt;/code&gt; дополнительно отвечает требованиям &lt;a href=&quot;../named_req/randomaccessiterator&quot;&gt;LegacyRandomAccessIterator&lt;/a&gt; , сложность постоянна.</target>
        </trans-unit>
        <trans-unit id="923af777ec78d98d0a47fdd5e9f0c732405eb150" translate="yes" xml:space="preserve">
          <source>However, if &lt;code&gt;InputIt&lt;/code&gt; or &lt;code&gt;ForwardIt&lt;/code&gt; additionally meets the requirements of &lt;a href=&quot;../named_req/randomaccessiterator&quot;&gt;LegacyRandomAccessIterator&lt;/a&gt;, complexity is constant.</source>
          <target state="translated">Однако, если &lt;code&gt;InputIt&lt;/code&gt; или &lt;code&gt;ForwardIt&lt;/code&gt; дополнительно соответствуют требованиям &lt;a href=&quot;../named_req/randomaccessiterator&quot;&gt;LegacyRandomAccessIterator&lt;/a&gt; , сложность постоянна.</target>
        </trans-unit>
        <trans-unit id="789aa7b03048a6d89e55166c2876d111a76287b2" translate="yes" xml:space="preserve">
          <source>However, if deduction succeeds for all parameters that participate in template argument deduction, and all template arguments that aren't deduced are explicitly specified or defaulted, then the remaining function parameters are compared with the corresponding function arguments. For each remaining parameter &lt;code&gt;P&lt;/code&gt; with a type that was non-dependent before substitution of any explicitly-specified template arguments, if the corresponding argument &lt;code&gt;A&lt;/code&gt; cannot be implicitly converted to &lt;code&gt;P&lt;/code&gt;, deduction fails.</source>
          <target state="translated">Однако, если вывод выполняется успешно для всех параметров, которые участвуют в выводе аргументов шаблона, и все аргументы шаблона, которые не были выведены, указываются или задаются по умолчанию, тогда остальные параметры функции сравниваются с соответствующими аргументами функции. Для каждого оставшегося параметра &lt;code&gt;P&lt;/code&gt; с типом, который был независимым до замены каких-либо явно заданных аргументов шаблона, если соответствующий аргумент &lt;code&gt;A&lt;/code&gt; не может быть неявно преобразован в &lt;code&gt;P&lt;/code&gt; , вывод не выполняется.</target>
        </trans-unit>
        <trans-unit id="d3ec3f026f2aba3bad033eb828adf9c63839692d" translate="yes" xml:space="preserve">
          <source>However, if the declaration uses &lt;a href=&quot;constexpr&quot;&gt;&lt;code&gt;constexpr&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;inline&quot;&gt;&lt;code&gt;inline&lt;/code&gt;&lt;/a&gt;(since C++17) specifier, the member must be declared to have complete type.</source>
          <target state="translated">Однако, если объявление использует &lt;a href=&quot;constexpr&quot;&gt; &lt;code&gt;constexpr&lt;/code&gt; &lt;/a&gt; или &lt;a href=&quot;inline&quot;&gt; &lt;code&gt;inline&lt;/code&gt; &lt;/a&gt; (начиная с C ++ 17) спецификатор, член должен быть объявлен как завершенный тип.</target>
        </trans-unit>
        <trans-unit id="9217191a146bae3519a7a8c89cf7f10d4b0ff050" translate="yes" xml:space="preserve">
          <source>However, one implementation (libc++) is known to construct the &lt;code&gt;key_type&lt;/code&gt; and &lt;code&gt;mapped_type&lt;/code&gt; objects via two separate allocator &lt;code&gt;construct()&lt;/code&gt; calls, as arguably required by the standards as published, rather than emplacing a &lt;code&gt;value_type&lt;/code&gt; object.</source>
          <target state="translated">Однако известно, что одна реализация (libc ++) &lt;code&gt;mapped_type&lt;/code&gt; объекты &lt;code&gt;key_type&lt;/code&gt; и mapped_type с помощью двух отдельных вызовов allocator &lt;code&gt;construct()&lt;/code&gt; , как это требуется согласно опубликованным стандартам, вместо использования объекта &lt;code&gt;value_type&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9b2db98636723bfe7992740aadfd807719cd51f4" translate="yes" xml:space="preserve">
          <source>However, the attributes that appear after the declarator (in the syntax above), apply to the type of the function, not to the function itself.</source>
          <target state="translated">Однако атрибуты,которые появляются после декларатора (в синтаксисе выше),относятся к типу функции,а не к самой функции.</target>
        </trans-unit>
        <trans-unit id="dff18122d5fc3679e0217a5ccca9f25c585e46ac" translate="yes" xml:space="preserve">
          <source>Hyperbolic cosine is an entire function in the complex plane and has no branch cuts. It is periodic with respect to the imaginary component, with period 2&amp;pi;i.</source>
          <target state="translated">Гиперболический косинус представляет собой целую функцию в комплексной плоскости и не имеет ответвлений. Он периодичен относительно мнимой компоненты, с периодом 2&amp;pi;i.</target>
        </trans-unit>
        <trans-unit id="f3ed3aadb3c9adb061d870e136cd1453348e8c73" translate="yes" xml:space="preserve">
          <source>Hyperbolic functions</source>
          <target state="translated">гиперболические функции</target>
        </trans-unit>
        <trans-unit id="a05dc25b96449633c73f65c5aa0e18f13e31788b" translate="yes" xml:space="preserve">
          <source>Hyperbolic sine is an entire function in the complex plane and has no branch cuts. It is periodic with respect to the imaginary component, with period 2&amp;pi;i.</source>
          <target state="translated">Гиперболический синус является целой функцией в комплексной плоскости и не имеет ответвлений. Он периодичен относительно мнимой компоненты, с периодом 2&amp;pi;i.</target>
        </trans-unit>
        <trans-unit id="c6a249eb7c58320fe1bb3e19e6e61f7ae663bb92" translate="yes" xml:space="preserve">
          <source>Hyperbolic tangent is an analytical function on the complex plain and has no branch cuts. It is periodic with respect to the imaginary component, with period &amp;pi;i, and has poles of the first order along the imaginary line, at coordinates (0, &amp;pi;(1/2 + n)). However no common floating-point representation is able to represent &amp;pi;/2 exactly, thus there is no value of the argument for which a pole error occurs.</source>
          <target state="translated">Гиперболический тангенс является аналитической функцией на сложной равнине и не имеет разрезов ветвей. Он периодичен относительно мнимой компоненты с периодом &amp;pi;i и имеет полюсы первого порядка вдоль мнимой линии в координатах (0, &amp;pi; (1/2 + n)). Однако ни одно общее представление с плавающей точкой не может точно представить &amp;pi; / 2, поэтому не существует значения аргумента, для которого возникает ошибка полюса.</target>
        </trans-unit>
        <trans-unit id="ca73ab65568cd125c2d27a22bbd9e863c10b675d" translate="yes" xml:space="preserve">
          <source>I</source>
          <target state="translated">I</target>
        </trans-unit>
        <trans-unit id="6b58ece8e2eb85355e743b6e1a72cb6eb0c30006" translate="yes" xml:space="preserve">
          <source>I/O Manipulators</source>
          <target state="translated">манипуляторы ввода/вывода</target>
        </trans-unit>
        <trans-unit id="0676b814ab2a9d403059287e94b18b3f3ed5e63c" translate="yes" xml:space="preserve">
          <source>I/O error</source>
          <target state="translated">ошибка ввода/вывода</target>
        </trans-unit>
        <trans-unit id="3fd6cee6dbc10d47db1d5e293da18cd3279cfd34" translate="yes" xml:space="preserve">
          <source>I/O format flags are obtained, as if by</source>
          <target state="translated">Флаги формата ввода/вывода получаются,как будто посредством</target>
        </trans-unit>
        <trans-unit id="00a1147221fe28724b5d852d3cc11debd18ea881" translate="yes" xml:space="preserve">
          <source>IBM XL C/C++ Inline Assembly</source>
          <target state="translated">Онлайновая ассамблея IBM XL C/C++</target>
        </trans-unit>
        <trans-unit id="97e6907b70a51197746c7a59244053494e95092c" translate="yes" xml:space="preserve">
          <source>ICE</source>
          <target state="translated">ICE</target>
        </trans-unit>
        <trans-unit id="2eb6372a578be72d248c4e343e8fc7a5d78b9a77" translate="yes" xml:space="preserve">
          <source>IEC 60559 recommends that &lt;code&gt;from&lt;/code&gt; is returned whenever &lt;code&gt;from==to&lt;/code&gt;. These functions return &lt;code&gt;to&lt;/code&gt; instead, which makes the behavior around zero consistent: &lt;code&gt;std::nextafter(-0.0, +0.0)&lt;/code&gt; returns &lt;code&gt;+0.0&lt;/code&gt; and &lt;code&gt;std::nextafter(+0.0, -0.0)&lt;/code&gt; returns &lt;code&gt;&amp;ndash;0.0&lt;/code&gt;.</source>
          <target state="translated">IEC 60559 рекомендует &lt;code&gt;from&lt;/code&gt; возвращается всякий раз , когда &lt;code&gt;from==to&lt;/code&gt; . Эти функции возвращают &lt;code&gt;to&lt;/code&gt; вместо этого, что делает поведение вокруг нулевого последовательный: &lt;code&gt;std::nextafter(-0.0, +0.0)&lt;/code&gt; возвращает &lt;code&gt;+0.0&lt;/code&gt; и &lt;code&gt;std::nextafter(+0.0, -0.0)&lt;/code&gt; возвращает &lt;code&gt;&amp;ndash;0.0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7d95a8939f16c4020223847e17e36720cebf2bb9" translate="yes" xml:space="preserve">
          <source>IEEE-754</source>
          <target state="translated">IEEE-754</target>
        </trans-unit>
        <trans-unit id="42d5d0fd7522f477e6c48c8cc234d0d9ab04dea9" translate="yes" xml:space="preserve">
          <source>ILP32</source>
          <target state="translated">ILP32</target>
        </trans-unit>
        <trans-unit id="bb6e7841dba2c83d7f4685d9f749f0a969927ab9" translate="yes" xml:space="preserve">
          <source>INFINITY</source>
          <target state="translated">INFINITY</target>
        </trans-unit>
        <trans-unit id="0c47ba7d876463299943e6f3c404bf80428ff851" translate="yes" xml:space="preserve">
          <source>INT8_CINT16_CINT32_CINT64_C</source>
          <target state="translated">INT8_CINT16_CINT32_CINT64_C</target>
        </trans-unit>
        <trans-unit id="9ea288f9428eb0424cc8044a5b63c8eac0420d9a" translate="yes" xml:space="preserve">
          <source>INT8_MAXINT16_MAXINT32_MAXINT64_MAX</source>
          <target state="translated">INT8_MAXINT16_MAXINT32_MAXINT64_MAX</target>
        </trans-unit>
        <trans-unit id="bc5a628cd596773389eaaf98a83bf94ceac150f9" translate="yes" xml:space="preserve">
          <source>INT8_MININT16_MININT32_MININT64_MIN</source>
          <target state="translated">INT8_MININT16_MININT32_MININT64_MIN</target>
        </trans-unit>
        <trans-unit id="f9102afc9b1d8d90bfec23471f9597ad0cf050e9" translate="yes" xml:space="preserve">
          <source>INTMAX_C</source>
          <target state="translated">INTMAX_C</target>
        </trans-unit>
        <trans-unit id="aefed58e7c3b20f7462bf747350723518bd7f3f5" translate="yes" xml:space="preserve">
          <source>INTMAX_MAX</source>
          <target state="translated">INTMAX_MAX</target>
        </trans-unit>
        <trans-unit id="a349d125102eeb5388d505c737ca6ccb840fc470" translate="yes" xml:space="preserve">
          <source>INTMAX_MIN</source>
          <target state="translated">INTMAX_MIN</target>
        </trans-unit>
        <trans-unit id="a8b82d9c693483b9795a47d286279f7fe077830a" translate="yes" xml:space="preserve">
          <source>INTPTR_MAX</source>
          <target state="translated">INTPTR_MAX</target>
        </trans-unit>
        <trans-unit id="ea1e73a8ba1358e9d441c380ac5a64aadd6313f9" translate="yes" xml:space="preserve">
          <source>INTPTR_MIN</source>
          <target state="translated">INTPTR_MIN</target>
        </trans-unit>
        <trans-unit id="cb3002d9d4b8d1bb4ad6b3fb3f8ee0eb1cd9e1b9" translate="yes" xml:space="preserve">
          <source>INT_FAST8_MAXINT_FAST16_MAXINT_FAST32_MAXINT_FAST64_MAX</source>
          <target state="translated">INT_FAST8_MAXINT_FAST16_MAXINT_FAST32_MAXINT_FAST64_MAX</target>
        </trans-unit>
        <trans-unit id="5c002bd42be6d97da6ee9fd6a8de846f49b7760c" translate="yes" xml:space="preserve">
          <source>INT_FAST8_MININT_FAST16_MININT_FAST32_MININT_FAST64_MIN</source>
          <target state="translated">INT_FAST8_MININT_FAST16_MININT_FAST32_MININT_FAST64_MIN</target>
        </trans-unit>
        <trans-unit id="81b4c2799073b036b71feb59eff38c668d0be8e4" translate="yes" xml:space="preserve">
          <source>INT_LEAST8_MAXINT_LEAST16_MAXINT_LEAST32_MAXINT_LEAST64_MAX</source>
          <target state="translated">INT_LEAST8_MAXINT_LEAST16_MAXINT_LEAST32_MAXINT_LEAST64_MAX</target>
        </trans-unit>
        <trans-unit id="303ab3b780f2f436597e803172a659d338cb695a" translate="yes" xml:space="preserve">
          <source>INT_LEAST8_MININT_LEAST16_MININT_LEAST32_MININT_LEAST64_MIN</source>
          <target state="translated">INT_LEAST8_MININT_LEAST16_MININT_LEAST32_MININT_LEAST64_MIN</target>
        </trans-unit>
        <trans-unit id="47a57f6b8f5e7dac870d669f2d10489423c2c097" translate="yes" xml:space="preserve">
          <source>INVERTED UNDERTIE</source>
          <target state="translated">ИНВЕРТИРОВАННОЕ НИЖНЕЕ БЕЛЬЁ</target>
        </trans-unit>
        <trans-unit id="6f332e7bc9fb4c964cc115b4bb4e0c9c81b651a9" translate="yes" xml:space="preserve">
          <source>INVOKE</source>
          <target state="translated">INVOKE</target>
        </trans-unit>
        <trans-unit id="bfa0e3fd8d2d6bf8a03a66ca3906291682906b88" translate="yes" xml:space="preserve">
          <source>INVOKE&amp;lt;R&amp;gt;(f, t1, t2, ..., tN)</source>
          <target state="translated">INVOKE &amp;lt;R&amp;gt; (f, t1, t2, ..., tN)</target>
        </trans-unit>
        <trans-unit id="381dd7d678830c863bcf610275aa82caf553b63a" translate="yes" xml:space="preserve">
          <source>INVOKE(f, t1, t2, ..., tN)</source>
          <target state="translated">INVOKE(f,t1,t2,...,tN)</target>
        </trans-unit>
        <trans-unit id="b7d04a533ba2785a0158159ad98ad6ef6b754b06" translate="yes" xml:space="preserve">
          <source>ISO 30112 defines POSIX control characters as Unicode characters U+0000..U+001F, U+007F..U+009F, U+2028, and U+2029 (Unicode classes Cc, Zl, and Zp).</source>
          <target state="translated">ISO 30112 определяет управляющие символы POSIX как символы Юникода U+0000...U+001F,U+007F...U+009F,U+2028 и U+2029 (классы Юникода Cc,Zl и Zp).</target>
        </trans-unit>
        <trans-unit id="fff375c325eb5a33dd2e39fc8434af17d533adb3" translate="yes" xml:space="preserve">
          <source>ISO 30112 defines POSIX space characters as Unicode characters U+0009..U+000D, U+0020, U+1680, U+180E, U+2000..U+2006, U+2008..U+200A, U+2028, U+2029, U+205F, and U+3000.</source>
          <target state="translated">ISO 30112 определяет пробельные символы POSIX как символы Юникода U+0009...U+000D,U+0020,U+1680,U+180E,U+2000...U+2006,U+2008...U+200A,U+2028,U+2029,U+205F и U+3000.</target>
        </trans-unit>
        <trans-unit id="83c8d536c17446dc8d23f11cf08547ab6f0ceaef" translate="yes" xml:space="preserve">
          <source>ISO 8601 week-based year</source>
          <target state="translated">год по ISO 8601 неделя</target>
        </trans-unit>
        <trans-unit id="660c1f28ee4e6a1155a4515d1d3d38f625034fe8" translate="yes" xml:space="preserve">
          <source>ISO C language standard requires that C compilers support the following three pragmas, and some C++ compiler vendors support them, to varying degrees, in their C++ frontends:</source>
          <target state="translated">Стандарт языка ISO C требует,чтобы компиляторы C поддерживали следующие три прагмы,а некоторые поставщики компиляторов C++поддерживают их,в различной степени,в своих C++фронтах:</target>
        </trans-unit>
        <trans-unit id="f0de3ffcac31393cdc320a257a71c6856ecd9b41" translate="yes" xml:space="preserve">
          <source>Identical to the complexity of &lt;code&gt;Container::emplace_back&lt;/code&gt;.</source>
          <target state="translated">Идентичен по сложности &lt;code&gt;Container::emplace_back&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7c1a745105ff9b6c357cf50bdd91090ffef6ae55" translate="yes" xml:space="preserve">
          <source>Identifier removed</source>
          <target state="translated">Идентификатор удален</target>
        </trans-unit>
        <trans-unit id="649d2864df18704de32e689e69e63f2483e8b76e" translate="yes" xml:space="preserve">
          <source>Identifiers</source>
          <target state="translated">Identifiers</target>
        </trans-unit>
        <trans-unit id="7e5a975b6add84fd53e3710a9ceac15eb06663b7" translate="yes" xml:space="preserve">
          <source>Identity</source>
          <target state="translated">Identity</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
