<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="cpp">
    <body>
      <group id="cpp">
        <trans-unit id="a3d00b46e93a04f762ceacf129a7d8e708f9cdae" translate="yes" xml:space="preserve">
          <source>If object is an lvalue expression, and its type is &lt;code&gt;T&lt;/code&gt; or derived from &lt;code&gt;T&lt;/code&gt;, and is equally or less cv-qualified, then the reference is bound to the object identified by the lvalue or to its base class subobject.</source>
          <target state="translated">Если объект является выражением lvalue и его тип равен &lt;code&gt;T&lt;/code&gt; или является производным от &lt;code&gt;T&lt;/code&gt; и имеет одинаковую или меньшую квалификацию cv, то ссылка привязывается к объекту, идентифицированному lvalue, или его подобъекту базового класса.</target>
        </trans-unit>
        <trans-unit id="aa22f5451003f7660daffd02d5df19ccf7abfc20" translate="yes" xml:space="preserve">
          <source>If one evaluation modifies a memory location, and the other reads or modifies the same memory location, and if at least one of the evaluations is not an atomic operation, the behavior of the program is undefined (the program has a &lt;a href=&quot;../language/memory_model&quot;&gt;data race&lt;/a&gt;) unless there exists a</source>
          <target state="translated">Если одна оценка изменяет ячейку памяти, а другая читает или изменяет ту же ячейку памяти, и если хотя бы одна из оценок не является атомарной операцией, поведение программы не определено (программа имеет &lt;a href=&quot;../language/memory_model&quot;&gt;гонку данных&lt;/a&gt; ), если нет существует</target>
        </trans-unit>
        <trans-unit id="e3ee4df0d28305af8190dfed503a69842ecdea1b" translate="yes" xml:space="preserve">
          <source>If one of the operands is of type &lt;code&gt;bool&lt;/code&gt; and the other is not, the program is ill-formed.</source>
          <target state="translated">Если один из операндов имеет тип &lt;code&gt;bool&lt;/code&gt; , а другой - нет, программа некорректна.</target>
        </trans-unit>
        <trans-unit id="2677ad2fee54206928d1289296944052d7155f2a" translate="yes" xml:space="preserve">
          <source>If one of the strings has an encoding prefix and the other doesn't, the one that doesn't will be considered to have the same encoding prefix as the other.</source>
          <target state="translated">Если одна из строк имеет префикс кодировки,а другая нет,то та,которая не имеет префикса кодировки,будет считаться имеющей тот же префикс кодировки,что и другая.</target>
        </trans-unit>
        <trans-unit id="5394cec101ec494404d07198530eec4ab37c59ad" translate="yes" xml:space="preserve">
          <source>If one of the two arguments is NaN, the value of the other argument is returned</source>
          <target state="translated">Если один из двух аргументов является NaN,возвращается значение другого аргумента</target>
        </trans-unit>
        <trans-unit id="41700bbfc9368c2b5358e57134ccfd94d1f553f5" translate="yes" xml:space="preserve">
          <source>If one range is a prefix of another, the shorter range is lexicographically</source>
          <target state="translated">Если один диапазон является префиксом другого,то более короткий диапазон является лексикографически</target>
        </trans-unit>
        <trans-unit id="dcc36215317b874404f96885cfc95439d29a3922" translate="yes" xml:space="preserve">
          <source>If only one function is left, that function is selected.</source>
          <target state="translated">Если осталась только одна функция,то она выбирается.</target>
        </trans-unit>
        <trans-unit id="58314a8e7e0dda6a0f7693f28a3be7368beb7517" translate="yes" xml:space="preserve">
          <source>If only one of &lt;code&gt;*this&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt; contains a value (let's call this object &lt;code&gt;in&lt;/code&gt; and the other &lt;code&gt;un&lt;/code&gt;), the contained value of &lt;code&gt;un&lt;/code&gt; is &lt;a href=&quot;../../language/direct_initialization&quot;&gt;direct-initialized&lt;/a&gt; from &lt;code&gt;std::move(*in)&lt;/code&gt;, followed by destruction of the contained value of &lt;code&gt;in&lt;/code&gt; as if by &lt;code&gt;in-&amp;gt;T::~T()&lt;/code&gt;. After this call, &lt;code&gt;in&lt;/code&gt; does not contain a value; &lt;code&gt;un&lt;/code&gt; contains a value.</source>
          <target state="translated">Если только один из &lt;code&gt;*this&lt;/code&gt; и &lt;code&gt;other&lt;/code&gt; содержит значение (давайте назовем этот объект &lt;code&gt;in&lt;/code&gt; и другой &lt;code&gt;un&lt;/code&gt; ), содержащийся значение &lt;code&gt;un&lt;/code&gt; является &lt;a href=&quot;../../language/direct_initialization&quot;&gt;прямым инициализируется&lt;/a&gt; из &lt;code&gt;std::move(*in)&lt;/code&gt; , с последующим разрушением содержащегося значения &lt;code&gt;in&lt;/code&gt; как бы &lt;code&gt;in-&amp;gt;T::~T()&lt;/code&gt; . После этого вызова &lt;code&gt;in&lt;/code&gt; не содержит значения; &lt;code&gt;un&lt;/code&gt; содержит значение.</target>
        </trans-unit>
        <trans-unit id="38fac4f8f19905bafe2c9ea62d2092290cb1aaea" translate="yes" xml:space="preserve">
          <source>If only one of the two function templates being compared is a member function , and that function template is a non-static member of some class &lt;code&gt;A&lt;/code&gt;, a new first parameter is inserted into its parameter list, whose type is &lt;code&gt;cv A&amp;amp;&amp;amp;&lt;/code&gt; if the member function template is &amp;amp;&amp;amp;-qualified and &lt;code&gt;cv A&amp;amp;&lt;/code&gt; otherwise (cv is the cv-qualification of the member function template) -- this helps the ordering of operators, which are looked up both as member and as non-member functions:</source>
          <target state="translated">Если только один из двух сравниваемых шаблонов функций является функцией-членом, и этот шаблон функции является нестатическим членом некоторого класса &lt;code&gt;A&lt;/code&gt; , новый первый параметр вставляется в его список параметров, тип которого &lt;code&gt;cv A&amp;amp;&amp;amp;&lt;/code&gt; если функция-член шаблон является &amp;amp;&amp;amp; - квалифицированным, а &lt;code&gt;cv A&amp;amp;&lt;/code&gt; остальным (cv - квалификацией cv шаблона функции-члена) - это помогает упорядочить операторы, которые рассматриваются как функции-члены и как функции, не являющиеся членами:</target>
        </trans-unit>
        <trans-unit id="ec7712843cd5f938f1aba16750b9a0671c8585bc" translate="yes" xml:space="preserve">
          <source>If other is an rvalue expression, &lt;a href=&quot;move_constructor&quot;&gt;move constructor&lt;/a&gt; will be selected by overload resolution and called during copy-initialization. There is no such term as move-initialization.</source>
          <target state="translated">Если другое является выражением rvalue, &lt;a href=&quot;move_constructor&quot;&gt;конструктор перемещения&lt;/a&gt; будет выбран с помощью разрешения перегрузки и будет вызван во время инициализации копирования. Нет такого термина как инициализация перемещения.</target>
        </trans-unit>
        <trans-unit id="9ddc5ecaabd07bdd4041442caa75864db6c6d691" translate="yes" xml:space="preserve">
          <source>If overflow occurs, the behavior is undefined.</source>
          <target state="translated">Если произойдет переполнение,поведение будет неопределенным.</target>
        </trans-unit>
        <trans-unit id="750847988fad756b2797b04ab539da8a7a039e9f" translate="yes" xml:space="preserve">
          <source>If overload resolution selects an inherited constructor, it is accessible if it would be accessible when used to construct an object of the corresponding base class: the accessibility of the using-declaration that introduced it is ignored.</source>
          <target state="translated">Если при перегрузочном разрешении выбирается наследуемый конструктор,то он доступен,если бы он был доступен при использовании для построения объекта соответствующего базового класса:доступность введенной в него use-декларации игнорируется.</target>
        </trans-unit>
        <trans-unit id="210ca7809f61451a624d2c6beec2bcb2c768f5c6" translate="yes" xml:space="preserve">
          <source>If overload resolution selects one of the inherited constructors when initializing an object of such derived class, then the &lt;code&gt;Base&lt;/code&gt; subobject from which the constructor was inherited is initialized using the inherited constructor, and all other bases and members of &lt;code&gt;Derived&lt;/code&gt; are initialized as if by the defaulted default constructor (default member initializers are used if provided, otherwise default initialization takes place). The entire initialization is treated as a single function call: initialization of the parameters of the inherited constructor is sequenced-before initialization of any base or member of the derived object.</source>
          <target state="translated">Если разрешение перегрузки выбирает один из унаследованных конструкторов при инициализации объекта такого производного класса, то подобъект &lt;code&gt;Base&lt;/code&gt; , от которого был унаследован конструктор, инициализируется с помощью унаследованного конструктора, а все другие базы и члены &lt;code&gt;Derived&lt;/code&gt; инициализируются так, как если бы по умолчанию конструктор по умолчанию (инициализаторы членов по умолчанию используются, если они предусмотрены, в противном случае происходит инициализация по умолчанию). Вся инициализация обрабатывается как один вызов функции: инициализация параметров унаследованного конструктора выполняется до инициализации любой базы или члена производного объекта.</target>
        </trans-unit>
        <trans-unit id="569b041ed62609471e4536cb80335e9cadb562bd" translate="yes" xml:space="preserve">
          <source>If possible, constructs an object of type &lt;code&gt;T&lt;/code&gt; in allocated uninitialized storage pointed to by &lt;code&gt;p&lt;/code&gt;, by calling.</source>
          <target state="translated">Если возможно, создает объект типа &lt;code&gt;T&lt;/code&gt; в выделенном неинициализированном хранилище, на которое указывает &lt;code&gt;p&lt;/code&gt; путем вызова.</target>
        </trans-unit>
        <trans-unit id="7bd19a7c8b0277a43bb96d2aa204eaa9e1df26a8" translate="yes" xml:space="preserve">
          <source>If possible, obtains the copy-constructed version of the allocator &lt;code&gt;a&lt;/code&gt;, by calling &lt;code&gt;a.select_on_container_copy_construction()&lt;/code&gt;. If the above is not possible (e.g. &lt;code&gt;a&lt;/code&gt; does not have the member function &lt;code&gt;select_on_container_copy_construction()&lt;/code&gt;, then returns &lt;code&gt;a&lt;/code&gt;, unmodified.</source>
          <target state="translated">Если возможно, получает созданную на копии версию распределителя &lt;code&gt;a&lt;/code&gt; , вызывая &lt;code&gt;a.select_on_container_copy_construction()&lt;/code&gt; . Если вышеупомянутое невозможно (например, &lt;code&gt;a&lt;/code&gt; не имеет функции-члена &lt;code&gt;select_on_container_copy_construction()&lt;/code&gt; , то возвращает &lt;code&gt;a&lt;/code&gt; , неизмененный.</target>
        </trans-unit>
        <trans-unit id="c2bb51f991f1f844a514dcdb161773a64461aa00" translate="yes" xml:space="preserve">
          <source>If possible, obtains the maximum theoretically possible allocation size from the allocator &lt;code&gt;a&lt;/code&gt;, by calling.</source>
          <target state="translated">Если возможно, получает максимальный теоретически возможный размер выделения от распределителя &lt;code&gt;a&lt;/code&gt; путем вызова.</target>
        </trans-unit>
        <trans-unit id="e98d09928ca05eb652c54751fcdfc483c6a1ba29" translate="yes" xml:space="preserve">
          <source>If present, the &lt;code&gt;hash&lt;/code&gt; parameter may be used to pass a pre-computed hash value as an optimization. The behavior is undefined if invoking &lt;code&gt;&lt;a href=&quot;hash_function&quot;&gt;hash_function()&lt;/a&gt;&lt;/code&gt; on the key passed do not produce the same value as &lt;code&gt;hash&lt;/code&gt;.</source>
          <target state="translated">При наличии параметр &lt;code&gt;hash&lt;/code&gt; может использоваться для передачи предварительно вычисленного значения хеш-функции в качестве оптимизации. Поведение не определено, если вызов &lt;code&gt;&lt;a href=&quot;hash_function&quot;&gt;hash_function()&lt;/a&gt;&lt;/code&gt; для переданного ключа не дает того же значения, что и &lt;code&gt;hash&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b615c53ecc545ad86db4eb50538fd76266abf064" translate="yes" xml:space="preserve">
          <source>If present, the &lt;code&gt;hash&lt;/code&gt; parameter may be used to pass a pre-computed hash value as an optimization. The behavior is undefined if invoking &lt;code&gt;hash_function()&lt;/code&gt; on the key passed do not produce the same value as &lt;code&gt;hash&lt;/code&gt;.</source>
          <target state="translated">При наличии параметр &lt;code&gt;hash&lt;/code&gt; может использоваться для передачи предварительно вычисленного значения хеш-функции в качестве оптимизации. Поведение не определено, если вызов &lt;code&gt;hash_function()&lt;/code&gt; для переданного ключа не дает того же значения, что и &lt;code&gt;hash&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d0ad3998a5ac30264cf943a5c000f09e6f5af44e" translate="yes" xml:space="preserve">
          <source>If prior to the call &lt;code&gt;*this&lt;/code&gt; has an associated mutex and has acquired ownership of it, the mutex is unlocked.</source>
          <target state="translated">Если до вызова &lt;code&gt;*this&lt;/code&gt; имеет связанный мьютекс и приобрел право собственности на него, мьютекс разблокируется.</target>
        </trans-unit>
        <trans-unit id="5bdd482f92ba03cbf032a677ef80f876bd9e89d4" translate="yes" xml:space="preserve">
          <source>If putback position was available, returns the character that the next pointer is now pointing at, converted to &lt;code&gt;int_type&lt;/code&gt; with &lt;code&gt;Traits::to_int_type(*gptr())&lt;/code&gt;. The next single-character input from this streambuf will return this character.</source>
          <target state="translated">Если позиция возврата была доступна, возвращает символ, на который теперь указывает следующий указатель, преобразованный в &lt;code&gt;int_type&lt;/code&gt; с помощью &lt;code&gt;Traits::to_int_type(*gptr())&lt;/code&gt; . Следующий односимвольный ввод из этого потокового буфера вернет этот символ.</target>
        </trans-unit>
        <trans-unit id="3eb692c025338041e4eed4f9319cfb04b675d552" translate="yes" xml:space="preserve">
          <source>If putback position was not available, returns what &lt;code&gt;&lt;a href=&quot;pbackfail&quot;&gt;pbackfail()&lt;/a&gt;&lt;/code&gt; returns, which is &lt;code&gt;Traits::eof()&lt;/code&gt; on failure.</source>
          <target state="translated">Если позиция возврата недоступна, возвращает то, что возвращает &lt;code&gt;&lt;a href=&quot;pbackfail&quot;&gt;pbackfail()&lt;/a&gt;&lt;/code&gt; , то есть &lt;code&gt;Traits::eof()&lt;/code&gt; при ошибке .</target>
        </trans-unit>
        <trans-unit id="fd77c426f218dbc4996392b11cbf4a9df041bd55" translate="yes" xml:space="preserve">
          <source>If range_expression is an expression of a class type &lt;code&gt;C&lt;/code&gt; that has both a member named &lt;code&gt;begin&lt;/code&gt; and a member named &lt;code&gt;end&lt;/code&gt; (regardless of the type or accessibility of such member), then</source>
          <target state="translated">Если range_expression является выражением типа &lt;code&gt;C&lt;/code&gt; класса, который имеет как член с именем &lt;code&gt;begin&lt;/code&gt; ,так и член с именем &lt;code&gt;end&lt;/code&gt; (независимо от типа или доступности такого члена), тогда</target>
        </trans-unit>
        <trans-unit id="a31a47abbcbe52c11cb5aabb738ee006961c36bf" translate="yes" xml:space="preserve">
          <source>If range_expression is an expression of array type, then</source>
          <target state="translated">Если выражение range_expression является выражением типа массива,то</target>
        </trans-unit>
        <trans-unit id="8998880636aec0b41e1f3aa9bb5068fe2d087a45" translate="yes" xml:space="preserve">
          <source>If range_expression returns a temporary, its lifetime is extended until the end of the loop, as indicated by binding to the forwarding reference &lt;b&gt;&lt;code&gt;__range&lt;/code&gt;&lt;/b&gt;, but beware that the lifetime of any temporary within range_expression</source>
          <target state="translated">Если range_expression возвращает временное значение, его время жизни увеличивается до конца цикла, как указано привязкой к ссылке пересылки &lt;b&gt; &lt;code&gt;__range&lt;/code&gt; &lt;/b&gt; , но следует &lt;b&gt;помнить&lt;/b&gt; , что время жизни любого временного объекта в пределах range_expression</target>
        </trans-unit>
        <trans-unit id="831b1dfec868a21157a075677fd82a9bf6d69aa8" translate="yes" xml:space="preserve">
          <source>If rdbuf() is a null pointer, does nothing.</source>
          <target state="translated">Если rdbuf()является нулевым указателем,то ничего не делает.</target>
        </trans-unit>
        <trans-unit id="1b1e7d795c25e0720f46207c35f854b7bc6a7349" translate="yes" xml:space="preserve">
          <source>If reallocation occurs, all iterators, including the past the end iterator, and all references to the elements are invalidated. If no reallocation takes place, no iterators or references are invalidated.</source>
          <target state="translated">Если происходит перераспределение,то все итераторы,включая прошедший конец итератора,и все ссылки на элементы считаются недействительными.Если перераспределение не происходит,ни итераторы,ни ссылки на элементы не считаются недействительными.</target>
        </trans-unit>
        <trans-unit id="b5722a09effa0795d91444af4d2753abca8a7e18" translate="yes" xml:space="preserve">
          <source>If rehashing occurs due to the insertion, all iterators are invalidated. Otherwise iterators are not affected. References are not invalidated. Rehashing occurs only if the new number of elements is greater than &lt;code&gt;max_load_factor()*bucket_count()&lt;/code&gt;.</source>
          <target state="translated">Если перефразировка происходит из-за вставки, все итераторы становятся недействительными. В противном случае итераторы не будут затронуты. Ссылки не являются недействительными. Перефразировка происходит, только если новое количество элементов больше, чем &lt;code&gt;max_load_factor()*bucket_count()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b48960c4455b015acecf76682b1d33d5044e8f1b" translate="yes" xml:space="preserve">
          <source>If rehashing occurs due to the insertion, all iterators are invalidated. Otherwise iterators are not affected. References are not invalidated. Rehashing occurs only if the new number of elements is greater than &lt;code&gt;max_load_factor()*bucket_count()&lt;/code&gt;. If the insertion is successful, pointers and references to the element obtained while it is held in the node handle are invalidated, and pointers and references obtained to that element before it was extracted become valid.(since C++17).</source>
          <target state="translated">Если перефразировка происходит из-за вставки, все итераторы становятся недействительными. В противном случае итераторы не будут затронуты. Ссылки не являются недействительными. Перефразировка происходит, только если новое количество элементов больше, чем &lt;code&gt;max_load_factor()*bucket_count()&lt;/code&gt; . Если вставка прошла успешно, указатели и ссылки на элемент, полученные при его удержании в дескрипторе узла, становятся недействительными, а указатели и ссылки, полученные на этот элемент до его извлечения, становятся действительными (начиная с C ++ 17).</target>
        </trans-unit>
        <trans-unit id="e5803322a669884d371a27e94b8e3347c4a1e0b8" translate="yes" xml:space="preserve">
          <source>If removing references and cv-qualifiers from &lt;code&gt;P&lt;/code&gt; gives &lt;code&gt;&lt;a href=&quot;../utility/initializer_list&quot;&gt;std::initializer_list&lt;/a&gt;&amp;lt;P'&amp;gt;&lt;/code&gt; and &lt;code&gt;A&lt;/code&gt; is a &lt;a href=&quot;list_initialization&quot;&gt;braced-init-list&lt;/a&gt;, then deduction is performed for every element of the initializer list, taking &lt;code&gt;P'&lt;/code&gt; as the parameter and the list element &lt;code&gt;A'&lt;/code&gt; as the argument:</source>
          <target state="translated">Если удаление ссылок и cv-квалификаторов из &lt;code&gt;P&lt;/code&gt; дает &lt;code&gt;&lt;a href=&quot;../utility/initializer_list&quot;&gt;std::initializer_list&lt;/a&gt;&amp;lt;P'&amp;gt;&lt;/code&gt; а &lt;code&gt;A&lt;/code&gt; представляет собой &lt;a href=&quot;list_initialization&quot;&gt;фигурный список инициализации&lt;/a&gt; , то для каждого элемента списка инициализатора выполняется удержание, принимая &lt;code&gt;P'&lt;/code&gt; в качестве параметра и элемента списка. &lt;code&gt;A'&lt;/code&gt; в качестве аргумента:</target>
        </trans-unit>
        <trans-unit id="4023bf4d1f43d575e2d6327b1416c5ed7d9cb751" translate="yes" xml:space="preserve">
          <source>If removing references and cv-qualifiers from &lt;code&gt;P&lt;/code&gt; gives &lt;code&gt;P'&lt;/code&gt;[&lt;code&gt;N&lt;/code&gt;], and &lt;code&gt;A&lt;/code&gt; is a non-empty braced-init-list, then deduction is performed as above, except if &lt;code&gt;N&lt;/code&gt; is a non-type template parameter, it is deduced from the length of the initializer list:</source>
          <target state="translated">Если удаление ссылок и квалификаторов cv из &lt;code&gt;P&lt;/code&gt; дает &lt;code&gt;P'&lt;/code&gt; [ &lt;code&gt;N&lt;/code&gt; ], а &lt;code&gt;A&lt;/code&gt; является непустым списком фигурных скобок-инициализации, то вычет выполняется так же, как указано выше, за исключением того, что &lt;code&gt;N&lt;/code&gt; является параметром шаблона нетипичного типа, он выводится из длины списка инициализатора:</target>
        </trans-unit>
        <trans-unit id="3e746f9c695cdf56415555b25b2b13ebeeb30b4c" translate="yes" xml:space="preserve">
          <source>If searching for an empty string (&lt;code&gt;str.size()&lt;/code&gt;, &lt;code&gt;count&lt;/code&gt;, or &lt;code&gt;Traits::length(s)&lt;/code&gt; is zero) returns &lt;code&gt;pos&lt;/code&gt; (the empty string is found immediately) unless &lt;code&gt;pos &amp;gt; size()&lt;/code&gt; (including the case where &lt;code&gt;pos == npos&lt;/code&gt;), in which case returns &lt;code&gt;size()&lt;/code&gt;.</source>
          <target state="translated">Если поиск пустой строки ( &lt;code&gt;str.size()&lt;/code&gt; , &lt;code&gt;count&lt;/code&gt; или &lt;code&gt;Traits::length(s)&lt;/code&gt; равен нулю) возвращает &lt;code&gt;pos&lt;/code&gt; (пустая строка найдена сразу), если только &lt;code&gt;pos &amp;gt; size()&lt;/code&gt; (включая случай, когда &lt;code&gt;pos == npos&lt;/code&gt; ), в этом случае возвращает &lt;code&gt;size()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8032ef45e981f5ae9ab731c15293224cc1be4894" translate="yes" xml:space="preserve">
          <source>If side-effect A is visible with respect to the value computation B, then the longest contiguous subset of the side-effects to M, in</source>
          <target state="translated">Если побочный эффект A виден по отношению к вычислению значения B,то самое длинное смежное подмножество побочных эффектов M в</target>
        </trans-unit>
        <trans-unit id="a813fcc7c976b042560912c3cfabd51324dc8cdf" translate="yes" xml:space="preserve">
          <source>If some &lt;a href=&quot;value_category&quot;&gt;glvalue expression&lt;/a&gt; refers to a &lt;a href=&quot;objects&quot;&gt;polymorphic object&lt;/a&gt;, the type of its most derived object is known as the dynamic type.</source>
          <target state="translated">Если какое- &lt;a href=&quot;value_category&quot;&gt;то выражение glvalue&lt;/a&gt; ссылается на &lt;a href=&quot;objects&quot;&gt;полиморфный объект&lt;/a&gt; , тип его самого производного объекта называется динамическим типом.</target>
        </trans-unit>
        <trans-unit id="eee5be8ef339e31668583c5122cb3ea37abcf9da" translate="yes" xml:space="preserve">
          <source>If some element is found &lt;code&gt;m&lt;/code&gt; times in &lt;code&gt;[first1, last1)&lt;/code&gt; and &lt;code&gt;n&lt;/code&gt; times in &lt;code&gt;[first2, last2)&lt;/code&gt;, it will be copied to &lt;code&gt;d_first&lt;/code&gt; exactly &lt;code&gt;std::abs(m-n)&lt;/code&gt; times. If &lt;code&gt;m&amp;gt;n&lt;/code&gt;, then the last &lt;code&gt;m-n&lt;/code&gt; of those elements are copied from &lt;code&gt;[first1,last1)&lt;/code&gt;, otherwise the last &lt;code&gt;n-m&lt;/code&gt; elements are copied from &lt;code&gt;[first2,last2)&lt;/code&gt;. The resulting range cannot overlap with either of the input ranges.</source>
          <target state="translated">Если какой-то элемент найден &lt;code&gt;m&lt;/code&gt; раз в &lt;code&gt;[first1, last1)&lt;/code&gt; и &lt;code&gt;n&lt;/code&gt; раз в &lt;code&gt;[first2, last2)&lt;/code&gt; , он будет скопирован в &lt;code&gt;d_first&lt;/code&gt; точно в &lt;code&gt;std::abs(m-n)&lt;/code&gt; раз. Если &lt;code&gt;m&amp;gt;n&lt;/code&gt; , то последние &lt;code&gt;m-n&lt;/code&gt; этих элементов копируются из &lt;code&gt;[first1,last1)&lt;/code&gt; , в противном случае последние элементы &lt;code&gt;n-m&lt;/code&gt; копируются из &lt;code&gt;[first2,last2)&lt;/code&gt; . Результирующий диапазон не может перекрываться ни с одним из входных диапазонов.</target>
        </trans-unit>
        <trans-unit id="caf2cbf83a05e60a4bb97a0592549e75d93ad63b" translate="yes" xml:space="preserve">
          <source>If some element is found &lt;code&gt;m&lt;/code&gt; times in &lt;code&gt;[first1, last1)&lt;/code&gt; and &lt;code&gt;n&lt;/code&gt; times in &lt;code&gt;[first2, last2)&lt;/code&gt;, then all &lt;code&gt;m&lt;/code&gt; elements will be copied from &lt;code&gt;[first1, last1)&lt;/code&gt; to &lt;code&gt;d_first&lt;/code&gt;, preserving order, and then exactly &lt;code&gt;&lt;a href=&quot;max&quot;&gt;std::max&lt;/a&gt;(n-m, 0)&lt;/code&gt; elements will be copied from &lt;code&gt;[first2, last2)&lt;/code&gt; to &lt;code&gt;d_first&lt;/code&gt;, also preserving order.</source>
          <target state="translated">Если какой-то элемент найден &lt;code&gt;m&lt;/code&gt; раз в &lt;code&gt;[first1, last1)&lt;/code&gt; и &lt;code&gt;n&lt;/code&gt; раз в &lt;code&gt;[first2, last2)&lt;/code&gt; , то все &lt;code&gt;m&lt;/code&gt; элементов будут скопированы из &lt;code&gt;[first1, last1)&lt;/code&gt; в &lt;code&gt;d_first&lt;/code&gt; , сохраняя порядок, а затем точно в &lt;code&gt;&lt;a href=&quot;max&quot;&gt;std::max&lt;/a&gt;(n-m, 0)&lt;/code&gt; элементы будут скопированы из &lt;code&gt;[first2, last2)&lt;/code&gt; в &lt;code&gt;d_first&lt;/code&gt; , также сохраняя порядок.</target>
        </trans-unit>
        <trans-unit id="67873cc8d634e461cb815d4a8417a686c3237eb4" translate="yes" xml:space="preserve">
          <source>If some member function &lt;code&gt;vf&lt;/code&gt; is declared as &lt;code&gt;virtual&lt;/code&gt; in a class &lt;code&gt;Base&lt;/code&gt;, and some class &lt;code&gt;Derived&lt;/code&gt;, which is derived, directly or indirectly, from &lt;code&gt;Base&lt;/code&gt;, has a declaration for member function with the same.</source>
          <target state="translated">Если некоторая функция-член &lt;code&gt;vf&lt;/code&gt; объявлена ​​как &lt;code&gt;virtual&lt;/code&gt; в классе &lt;code&gt;Base&lt;/code&gt; , а другой класс &lt;code&gt;Derived&lt;/code&gt; , который прямо или косвенно является производным от &lt;code&gt;Base&lt;/code&gt; , имеет объявление для функции-члена с тем же.</target>
        </trans-unit>
        <trans-unit id="e561cbd21051ae04ee69688d91773e4d66564214" translate="yes" xml:space="preserve">
          <source>If some of the arguments that are supplied in the call to &lt;code&gt;g()&lt;/code&gt; are not matched by any placeholders stored in &lt;code&gt;g&lt;/code&gt;, the unused arguments are evaluated and discarded.</source>
          <target state="translated">Если некоторые из аргументов, предоставленных в вызове &lt;code&gt;g()&lt;/code&gt; , не совпадают ни с какими заполнителями, хранящимися в &lt;code&gt;g&lt;/code&gt; , неиспользуемые аргументы оцениваются и отбрасываются.</target>
        </trans-unit>
        <trans-unit id="c16f0b9646e0495cf7360c2d57ef97bff686bc4e" translate="yes" xml:space="preserve">
          <source>If some user-declared constructors are present, the user may still force the automatic generation of a default constructor by the compiler that would be implicitly-declared otherwise with the keyword &lt;code&gt;default&lt;/code&gt;.</source>
          <target state="translated">Если присутствуют некоторые объявленные пользователем конструкторы, пользователь все равно может принудительно сгенерировать компилятором конструктор по умолчанию, который в противном случае был бы объявлен неявно с ключевым словом &lt;code&gt;default&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="81f7a3f627cd87e8bf750cf042cc3a980725dec5" translate="yes" xml:space="preserve">
          <source>If some user-defined constructors are present, the user may still force the automatic generation of a default constructor by the compiler that would be implicitly-declared otherwise with the keyword &lt;code&gt;default&lt;/code&gt;.</source>
          <target state="translated">Если присутствуют некоторые определяемые пользователем конструкторы, пользователь все равно может принудительно сгенерировать компилятором конструктор по умолчанию, который неявно был бы объявлен иначе с ключевым словом &lt;code&gt;default&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4f89b2e39dc991aa70988548f099b5134242e0c1" translate="yes" xml:space="preserve">
          <source>If statement is a single statement (not a compound statement), the scope of variables declared in it is limited to the while loop as if it was a compound statement, in other words,</source>
          <target state="translated">Если оператор является единственным оператором (а не составным оператором),то объем объявленных в нем переменных ограничивается циклом,как если бы это был составной оператор,другими словами,</target>
        </trans-unit>
        <trans-unit id="de8e6184779d6e772f3df1e2bc68eaa83374bf85" translate="yes" xml:space="preserve">
          <source>If statement-true is entered by &lt;a href=&quot;goto&quot;&gt;goto&lt;/a&gt; or &lt;code&gt;longjmp&lt;/code&gt;, statement_false is not executed.</source>
          <target state="translated">Если выражение-истина введено с помощью &lt;a href=&quot;goto&quot;&gt;goto&lt;/a&gt; или &lt;code&gt;longjmp&lt;/code&gt; , Statement_false не выполняется.</target>
        </trans-unit>
        <trans-unit id="5e2cbc4d6a00d3a75286c31bf804d8bad59194eb" translate="yes" xml:space="preserve">
          <source>If statement_true or statement_false is not a compound statement, it is treated as if it were:</source>
          <target state="translated">Если утверждение_true или утверждение_false не является составным выражением,оно рассматривается,как если бы оно было составным:</target>
        </trans-unit>
        <trans-unit id="834b8d6940f6e20e10043e602b81088e525449aa" translate="yes" xml:space="preserve">
          <source>If successful, an integer value corresponding to the contents of &lt;code&gt;str&lt;/code&gt; is returned.</source>
          <target state="translated">В случае успеха возвращается целочисленное значение, соответствующее содержимому &lt;code&gt;str&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="25bfeb839d8f5173b50bb285122b4cc54720321c" translate="yes" xml:space="preserve">
          <source>If successful, returns a pointer to the object that controls the opened file stream, with both eof and error bits cleared. The stream is fully buffered unless filename refers to an interactive device.</source>
          <target state="translated">В случае успеха возвращает указатель на объект,управляющий открытым файловым потоком,с очищенными битами eof и error.Поток полностью буферизируется,если только имя файла не ссылается на интерактивное устройство.</target>
        </trans-unit>
        <trans-unit id="5632ad995e8027aefc150ef8436b23c84c4578ae" translate="yes" xml:space="preserve">
          <source>If successful, returns the IEEE floating-point remainder of the division &lt;code&gt;x/y&lt;/code&gt; as defined above.</source>
          <target state="translated">В случае успеха возвращает остаток IEEE с плавающей запятой от деления &lt;code&gt;x/y&lt;/code&gt; , как определено выше.</target>
        </trans-unit>
        <trans-unit id="7ba7ac810951fe3d89eb854fd7520e591880a573" translate="yes" xml:space="preserve">
          <source>If successful, returns the absolute value of &lt;code&gt;arg&lt;/code&gt; (&lt;code&gt;|arg|&lt;/code&gt;). The value returned is exact and does not depend on any rounding modes.</source>
          <target state="translated">В случае успеха возвращает абсолютное значение &lt;code&gt;arg&lt;/code&gt; ( &lt;code&gt;|arg|&lt;/code&gt; ). Возвращаемое значение является точным и не зависит от каких-либо режимов округления.</target>
        </trans-unit>
        <trans-unit id="a595b23fd21a8f04c669747846486d0e27d71af0" translate="yes" xml:space="preserve">
          <source>If successful, returns the floating-point remainder of the division &lt;code&gt;x/y&lt;/code&gt; as defined above.</source>
          <target state="translated">В случае успеха возвращает остаток с плавающей точкой от деления &lt;code&gt;x/y&lt;/code&gt; , как определено выше.</target>
        </trans-unit>
        <trans-unit id="03e429269f7181e14b033dacb9e7bf8c7396151a" translate="yes" xml:space="preserve">
          <source>If successful, returns the floating-point remainder of the division &lt;code&gt;x/y&lt;/code&gt; as defined in &lt;code&gt;&lt;a href=&quot;remainder&quot;&gt;std::remainder&lt;/a&gt;&lt;/code&gt;, and stores, in &lt;code&gt;*quo&lt;/code&gt;, the sign and at least three of the least significant bits of &lt;code&gt;x/y&lt;/code&gt; (formally, stores a value whose sign is the sign of &lt;code&gt;x/y&lt;/code&gt; and whose magnitude is congruent modulo 2n</source>
          <target state="translated">В случае успеха возвращает остаток с плавающей запятой от деления &lt;code&gt;x/y&lt;/code&gt; , как определено в &lt;code&gt;&lt;a href=&quot;remainder&quot;&gt;std::remainder&lt;/a&gt;&lt;/code&gt; , и сохраняет в &lt;code&gt;*quo&lt;/code&gt; знак и, по крайней мере, три из младших значащих битов &lt;code&gt;x/y&lt;/code&gt; (формально, хранит значение, знак которого является знаком &lt;code&gt;x/y&lt;/code&gt; а величина которого конгруэнтна по модулю 2n</target>
        </trans-unit>
        <trans-unit id="ea98bbdcb76a97fab4ef9d6ca9c32eecbe479081" translate="yes" xml:space="preserve">
          <source>If successful, returns the larger of two floating point values. The value returned is exact and does not depend on any rounding modes.</source>
          <target state="translated">В случае успеха возвращает большее из двух значений с плавающей точкой.Возвращаемое значение является точным и не зависит от режимов округления.</target>
        </trans-unit>
        <trans-unit id="9423b4432f6a645ec2473ed82b459b6686deb60f" translate="yes" xml:space="preserve">
          <source>If successful, returns the positive difference between x and y.</source>
          <target state="translated">В случае успеха возвращает положительную разницу между х и у.</target>
        </trans-unit>
        <trans-unit id="46138f9b406992b59d0f9492f2e64a28cf85480b" translate="yes" xml:space="preserve">
          <source>If successful, returns the smaller of two floating point values. The value returned is exact and does not depend on any rounding modes.</source>
          <target state="translated">В случае успеха возвращает меньшее из двух значений с плавающей точкой.Возвращаемое значение является точным и не зависит от режимов округления.</target>
        </trans-unit>
        <trans-unit id="5ca1e3a726f6c442c2b326f76a16b023bb9441ee" translate="yes" xml:space="preserve">
          <source>If successful, returns the value of &lt;code&gt;(x*y) + z&lt;/code&gt; as if calculated to infinite precision and rounded once to fit the result type (or, alternatively, calculated as a single ternary floating-point operation).</source>
          <target state="translated">В случае успеха возвращает значение &lt;code&gt;(x*y) + z&lt;/code&gt; как если бы оно было рассчитано с бесконечной точностью и округлено один раз для соответствия типу результата (или, альтернативно, рассчитано как одна троичная операция с плавающей запятой).</target>
        </trans-unit>
        <trans-unit id="44139e51119b7719b4d6c2c45a98ecd6bcfaac63" translate="yes" xml:space="preserve">
          <source>If such a specialization has a member named &lt;code&gt;type&lt;/code&gt;, it must be a public and unambiguous member type that names a cv-unqualified non-reference type to which both &lt;code&gt;T1&lt;/code&gt; and &lt;code&gt;T2&lt;/code&gt; are explicitly convertible. Additionally, &lt;code&gt;std::common_type&amp;lt;T1, T2&amp;gt;::type&lt;/code&gt; and &lt;code&gt;std::common_type&amp;lt;T2, T1&amp;gt;::type&lt;/code&gt; must denote the same type.</source>
          <target state="translated">Если такая специализация имеет член с именем &lt;code&gt;type&lt;/code&gt; , он должен быть открытым и однозначным типом члена, который называет неквалифицированный cv не ссылочный тип, к которому &lt;code&gt;T1&lt;/code&gt; и &lt;code&gt;T2&lt;/code&gt; явно конвертируемы. Кроме того, &lt;code&gt;std::common_type&amp;lt;T1, T2&amp;gt;::type&lt;/code&gt; и &lt;code&gt;std::common_type&amp;lt;T2, T1&amp;gt;::type&lt;/code&gt; должны обозначать один и тот же тип.</target>
        </trans-unit>
        <trans-unit id="3a37148d1443f4a7f83a98b72097fe4c825195aa" translate="yes" xml:space="preserve">
          <source>If such a specialization has a member named &lt;code&gt;type&lt;/code&gt;, it must be a public and unambiguous member type that names a type to which both &lt;code&gt;TQual&amp;lt;T&amp;gt;&lt;/code&gt; and &lt;code&gt;UQual&amp;lt;U&amp;gt;&lt;/code&gt; are convertible. Additionally, &lt;code&gt;std::basic_common_reference&amp;lt;T, U, TQual, UQual&amp;gt;::type&lt;/code&gt; and &lt;code&gt;std::basic_common_reference&amp;lt;U, T, UQual, TQual&amp;gt;::type&lt;/code&gt; must denote the same type.</source>
          <target state="translated">Если такая специализация имеет член с именем &lt;code&gt;type&lt;/code&gt; , он должен быть открытым и однозначным типом члена, который &lt;code&gt;TQual&amp;lt;T&amp;gt;&lt;/code&gt; тип, к которому могут быть преобразованы как TQual &amp;lt;T&amp;gt;, так и &lt;code&gt;UQual&amp;lt;U&amp;gt;&lt;/code&gt; . Кроме того, &lt;code&gt;std::basic_common_reference&amp;lt;T, U, TQual, UQual&amp;gt;::type&lt;/code&gt; и &lt;code&gt;std::basic_common_reference&amp;lt;U, T, UQual, TQual&amp;gt;::type&lt;/code&gt; должны обозначать один и тот же тип.</target>
        </trans-unit>
        <trans-unit id="a948028c1758b5531024e3fe8732225a9c5cc129" translate="yes" xml:space="preserve">
          <source>If such character was found, is it the</source>
          <target state="translated">Если такой персонаж был найден,то</target>
        </trans-unit>
        <trans-unit id="18c5e1768b43942789912ab8899675cb0c8b4274" translate="yes" xml:space="preserve">
          <source>If such character was found, it is</source>
          <target state="translated">Если такой персонаж и был найден,то это</target>
        </trans-unit>
        <trans-unit id="1e5aef218cb47cb6d5be701f51f4abca139d0794" translate="yes" xml:space="preserve">
          <source>If such function has multiple return statements, the deduction is performed for each return statement. All the resulting types must be the same and become the actual return type.</source>
          <target state="translated">Если такая функция имеет несколько операторов возврата,то вычет производится для каждого оператора возврата.Все результирующие типы должны быть одинаковыми и становиться фактическим типом возврата.</target>
        </trans-unit>
        <trans-unit id="0ef2cb48d46014bbb2de04ceea1ca8d25cb98355" translate="yes" xml:space="preserve">
          <source>If such function has no return statement, &lt;code&gt;A&lt;/code&gt; is &lt;code&gt;void()&lt;/code&gt; when deducing.</source>
          <target state="translated">Если такая функция не имеет оператора возврата, при выводе &lt;code&gt;A&lt;/code&gt; это &lt;code&gt;void()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="781a8af57a4e00c05cd18f270856d6e17bfee700" translate="yes" xml:space="preserve">
          <source>If such wide character was found, it is</source>
          <target state="translated">Если такой широкий характер и был найден,то это</target>
        </trans-unit>
        <trans-unit id="cc7116ca6f31d674f4a72c2589a0d09f652f8823" translate="yes" xml:space="preserve">
          <source>If such wide character was found, it is the</source>
          <target state="translated">Если такой широкий характер и был найден,то это -</target>
        </trans-unit>
        <trans-unit id="6016d8ecaf1d3d66d2fab0578528efd9598d22d7" translate="yes" xml:space="preserve">
          <source>If that invocation returns normally (such call to &lt;code&gt;call_once&lt;/code&gt; is known as</source>
          <target state="translated">Если этот вызов возвращается нормально (такой вызов &lt;code&gt;call_once&lt;/code&gt; известен как</target>
        </trans-unit>
        <trans-unit id="d62acf7636b44fe974a0dd1f118413c4d750777d" translate="yes" xml:space="preserve">
          <source>If that invocation throws an exception, it is propagated to the caller of &lt;code&gt;call_once&lt;/code&gt;, and the flag is not flipped so that another call will be attempted (such call to &lt;code&gt;call_once&lt;/code&gt; is known as</source>
          <target state="translated">Если этот вызов вызывает исключение, он &lt;code&gt;call_once&lt;/code&gt; вызывающей стороне call_once , и флаг не переворачивается, так что будет предпринят другой вызов (такой вызов &lt;code&gt;call_once&lt;/code&gt; известен как</target>
        </trans-unit>
        <trans-unit id="80a16c9b65c48e0464ea5d60a9c92f28adf5f633" translate="yes" xml:space="preserve">
          <source>If that portion of the array previously provided storage for another object, the lifetime of that object ends because its storage was reused, however the lifetime of the array itself does not end (its storage is not considered to have been reused).</source>
          <target state="translated">Если эта часть массива ранее предоставляла хранилище для другого объекта,то время жизни этого объекта заканчивается из-за того,что его хранилище было использовано повторно,однако время жизни самого массива не заканчивается (его хранилище не считается повторно использованным).</target>
        </trans-unit>
        <trans-unit id="3d9b7696c9777c3fdef5f5f1690ef14ee23382d9" translate="yes" xml:space="preserve">
          <source>If the</source>
          <target state="translated">Если</target>
        </trans-unit>
        <trans-unit id="345e55abff70a548ca370acdb8ec63c08545a970" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;filename&quot;&gt;&lt;code&gt;filename()&lt;/code&gt;&lt;/a&gt; component of the generic-format path contains a period (&lt;code&gt;.&lt;/code&gt;), and is not one of the special filesystem elements dot or dot-dot, then the</source>
          <target state="translated">Если компонент &lt;a href=&quot;filename&quot;&gt; &lt;code&gt;filename()&lt;/code&gt; &lt;/a&gt; пути общего формата содержит точку ( &lt;code&gt;.&lt;/code&gt; ) И не является одним из специальных элементов файловой системы точка или точка-точка, то</target>
        </trans-unit>
        <trans-unit id="ba0ee99ef431871bed3ba20ad26dd7f7656ca3aa" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;&lt;a href=&quot;tm&quot;&gt;std::tm&lt;/a&gt;&lt;/code&gt; object was obtained from &lt;code&gt;&lt;a href=&quot;../../io/manip/get_time&quot;&gt;std::get_time&lt;/a&gt;&lt;/code&gt; or the POSIX &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/009695399/functions/strptime.html&quot;&gt;strptime&lt;/a&gt;, the value of &lt;code&gt;tm_isdst&lt;/code&gt; is indeterminate, and needs to be set explicitly before calling &lt;code&gt;mktime&lt;/code&gt;.</source>
          <target state="translated">Если объект &lt;code&gt;&lt;a href=&quot;tm&quot;&gt;std::tm&lt;/a&gt;&lt;/code&gt; был получен из &lt;code&gt;&lt;a href=&quot;../../io/manip/get_time&quot;&gt;std::get_time&lt;/a&gt;&lt;/code&gt; или POSIX &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/009695399/functions/strptime.html&quot;&gt;strptime&lt;/a&gt; , значение &lt;code&gt;tm_isdst&lt;/code&gt; является неопределенным и должно быть задано явно перед вызовом &lt;code&gt;mktime&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="78ffd5bdb618a15dacdd93c1f4888f75a24f4a33" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;Promise&lt;/code&gt; type defines a class-level replacement, it will be used, otherwise global &lt;code&gt;&lt;a href=&quot;../memory/new/operator_new&quot;&gt;operator new&lt;/a&gt;&lt;/code&gt; will be used.</source>
          <target state="translated">Если тип &lt;code&gt;Promise&lt;/code&gt; определяет замену на уровне класса, он будет использоваться, в противном случае будет использоваться глобальный &lt;code&gt;&lt;a href=&quot;../memory/new/operator_new&quot;&gt;operator new&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="73ae41564f6a1c376265c280e35f0cabc8e5e1b5" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;Promise&lt;/code&gt; type defines a placement form of &lt;code&gt;&lt;a href=&quot;../memory/new/operator_new&quot;&gt;operator new&lt;/a&gt;&lt;/code&gt; that takes additional parameters, and they match an argument list where the first argument is the size requested (of type &lt;code&gt;&lt;a href=&quot;../types/size_t&quot;&gt;std::size_t&lt;/a&gt;&lt;/code&gt;) and the rest are the coroutine function arguments, those arguments will be passed to &lt;code&gt;&lt;a href=&quot;../memory/new/operator_new&quot;&gt;operator new&lt;/a&gt;&lt;/code&gt; (this makes it possible to use &lt;a href=&quot;../memory/uses_allocator#Uses-allocator_construction&quot;&gt;leading-allocator-convention&lt;/a&gt; for coroutines).</source>
          <target state="translated">Если тип &lt;code&gt;Promise&lt;/code&gt; определяет форму размещения &lt;code&gt;&lt;a href=&quot;../memory/new/operator_new&quot;&gt;operator new&lt;/a&gt;&lt;/code&gt; который принимает дополнительные параметры, и они соответствуют списку аргументов, где первый аргумент - запрашиваемый размер (типа &lt;code&gt;&lt;a href=&quot;../types/size_t&quot;&gt;std::size_t&lt;/a&gt;&lt;/code&gt; ), а остальные - аргументы функции сопрограммы, эти аргументы будут быть передано &lt;code&gt;&lt;a href=&quot;../memory/new/operator_new&quot;&gt;operator new&lt;/a&gt;&lt;/code&gt; (это позволяет использовать &lt;a href=&quot;../memory/uses_allocator#Uses-allocator_construction&quot;&gt;соглашение с ведущими-распределителями&lt;/a&gt; для сопрограмм).</target>
        </trans-unit>
        <trans-unit id="478337dee1f38e04706d749bfe79388ccef331de" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;directory_iterator&lt;/code&gt; reports an error or is advanced past the last directory entry, it becomes equal to the default-constructed iterator, also known as the end iterator. Two end iterators are always equal, dereferencing or incrementing the end iterator is undefined behavior.</source>
          <target state="translated">Если &lt;code&gt;directory_iterator&lt;/code&gt; сообщает об ошибке или продвигается дальше последней записи каталога, он становится равным построенному по умолчанию итератору, также известному как конечный итератор. Два конечных итератора всегда равны, разыменование или увеличение конечного итератора - неопределенное поведение.</target>
        </trans-unit>
        <trans-unit id="b8e4d93257a92c723d2b683f90d9e06102fd5b29" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;local_time&lt;/code&gt; is ambiguous, then &lt;code&gt;result == local_info::ambiguous&lt;/code&gt;, &lt;code&gt;first&lt;/code&gt; is filled out with the &lt;code&gt;std::chrono::sys_info&lt;/code&gt; that ends just after the &lt;code&gt;local_time&lt;/code&gt;, and &lt;code&gt;second&lt;/code&gt; is filled with the &lt;code&gt;std::chrono::sys_info&lt;/code&gt; that starts just before the &lt;code&gt;local_time&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;local_time&lt;/code&gt; является неоднозначным, то &lt;code&gt;result == local_info::ambiguous&lt;/code&gt; , &lt;code&gt;first&lt;/code&gt; заполняется &lt;code&gt;std::chrono::sys_info&lt;/code&gt; который заканчивается сразу после &lt;code&gt;local_time&lt;/code&gt; , а &lt;code&gt;second&lt;/code&gt; заполняется &lt;code&gt;std::chrono::sys_info&lt;/code&gt; который начинается как раз перед &lt;code&gt;local_time&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="be3a36bf5edab54949d33d3601ee2498da9859cd" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;local_time&lt;/code&gt; is nonexistent, then &lt;code&gt;result == local_info::nonexistent&lt;/code&gt;, &lt;code&gt;first&lt;/code&gt; is filled out with the &lt;code&gt;std::chrono::sys_info&lt;/code&gt; that ends just prior to the &lt;code&gt;local_time&lt;/code&gt;, and &lt;code&gt;second&lt;/code&gt; is filled out with the &lt;code&gt;std::chrono::sys_info&lt;/code&gt; that begins just after the &lt;code&gt;local_time&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;local_time&lt;/code&gt; не существует, то &lt;code&gt;result == local_info::nonexistent&lt;/code&gt; , &lt;code&gt;first&lt;/code&gt; заполняется &lt;code&gt;std::chrono::sys_info&lt;/code&gt; который заканчивается незадолго до &lt;code&gt;local_time&lt;/code&gt; , а &lt;code&gt;second&lt;/code&gt; заполняется &lt;code&gt;std::chrono::sys_info&lt;/code&gt; это начинается сразу после &lt;code&gt;local_time&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="aba2a61809646633728f0c300cb4a04fd0fdd0e8" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;nptr&lt;/code&gt; is empty or does not have the expected form, no conversion is performed, and (if &lt;code&gt;enptr&lt;/code&gt; is not &lt;code&gt;&lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt;) the value of &lt;code&gt;nptr&lt;/code&gt; is stored in the object pointed to by &lt;code&gt;endptr&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;nptr&lt;/code&gt; пуст или не имеет ожидаемой формы, преобразование не выполняется, и (если &lt;code&gt;enptr&lt;/code&gt; не &lt;code&gt;&lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt; ) значение &lt;code&gt;nptr&lt;/code&gt; сохраняется в объекте, на который указывает &lt;code&gt;endptr&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ebdf7be468a8d6d0434b13fed187af1e31121791" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;recursive_directory_iterator&lt;/code&gt; reports an error or is advanced past the last directory entry of the top-level directory, it becomes equal to the default-constructed iterator, also known as the end iterator. Two end iterators are always equal, dereferencing or incrementing the end iterator is undefined behavior.</source>
          <target state="translated">Если &lt;code&gt;recursive_directory_iterator&lt;/code&gt; сообщает об ошибке или продвигается дальше последней записи каталога в каталоге верхнего уровня, он становится равным построенному по умолчанию итератору, также известному как конечный итератор. Два конечных итератора всегда равны, разыменование или увеличение конечного итератора - неопределенное поведение.</target>
        </trans-unit>
        <trans-unit id="5651c6461cabc5494e66b0b82def60eb3e607dc1" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;std::future&lt;/code&gt; obtained from &lt;code&gt;std::async&lt;/code&gt; is not moved from or bound to a reference, the destructor of the &lt;code&gt;&lt;a href=&quot;future&quot;&gt;std::future&lt;/a&gt;&lt;/code&gt; will block at the end of the full expression until the asynchronous operation completes, essentially making code such as the following synchronous:</source>
          <target state="translated">Если &lt;code&gt;std::future&lt;/code&gt; полученный из &lt;code&gt;std::async&lt;/code&gt; , не перемещен или не связан со ссылкой, деструктор &lt;code&gt;&lt;a href=&quot;future&quot;&gt;std::future&lt;/a&gt;&lt;/code&gt; будет блокироваться в конце полного выражения до завершения асинхронной операции, по существу создавая код, такой как следующее синхронно:</target>
        </trans-unit>
        <trans-unit id="f1881ec1b9072afac208ff470251f98ed10178f8" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;str&lt;/code&gt; is empty or does not have the expected form, no conversion is performed, and (if &lt;code&gt;str_end&lt;/code&gt; is not &lt;code&gt;&lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt;) the value of &lt;code&gt;str&lt;/code&gt; is stored in the object pointed to by &lt;code&gt;str_end&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;str&lt;/code&gt; пуст или не имеет ожидаемой формы, преобразование не выполняется, и (если &lt;code&gt;str_end&lt;/code&gt; не равен &lt;code&gt;&lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt; ) значение &lt;code&gt;str&lt;/code&gt; сохраняется в объекте, на который указывает &lt;code&gt;str_end&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e50fd41c5ef8a59127cf972f021ae16ba8532f47" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;stream&lt;/code&gt; is open in binary mode, the new position is exactly &lt;code&gt;offset&lt;/code&gt; bytes measured from the beginning of the file if &lt;code&gt;origin&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;../c&quot;&gt;SEEK_SET&lt;/a&gt;&lt;/code&gt;, from the current file position if &lt;code&gt;origin&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;../c&quot;&gt;SEEK_CUR&lt;/a&gt;&lt;/code&gt;, and from the end of the file if &lt;code&gt;origin&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;../c&quot;&gt;SEEK_END&lt;/a&gt;&lt;/code&gt;. Binary streams are not required to support &lt;code&gt;&lt;a href=&quot;../c&quot;&gt;SEEK_END&lt;/a&gt;&lt;/code&gt;, in particular if additional null bytes are output.</source>
          <target state="translated">Если &lt;code&gt;stream&lt;/code&gt; открыт в двоичном режиме, новая позиция - это точно &lt;code&gt;offset&lt;/code&gt; байты, измеренные от начала файла, если &lt;code&gt;origin&lt;/code&gt; - &lt;code&gt;&lt;a href=&quot;../c&quot;&gt;SEEK_SET&lt;/a&gt;&lt;/code&gt; , от текущей позиции файла, если &lt;code&gt;origin&lt;/code&gt; - &lt;code&gt;&lt;a href=&quot;../c&quot;&gt;SEEK_CUR&lt;/a&gt;&lt;/code&gt; , и от конца файла, если &lt;code&gt;origin&lt;/code&gt; - &lt;code&gt;&lt;a href=&quot;../c&quot;&gt;SEEK_END&lt;/a&gt;&lt;/code&gt; . Двоичные потоки не обязаны поддерживать &lt;code&gt;&lt;a href=&quot;../c&quot;&gt;SEEK_END&lt;/a&gt;&lt;/code&gt; , в частности, если выводятся дополнительные нулевые байты.</target>
        </trans-unit>
        <trans-unit id="37a2ed3c9a259690f19d7262a85bdeef29cb181d" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;stream&lt;/code&gt; is open in text mode, the only supported values for &lt;code&gt;offset&lt;/code&gt; are zero (which works with any &lt;code&gt;origin&lt;/code&gt;) and a value returned by an earlier call to &lt;code&gt;&lt;a href=&quot;ftell&quot;&gt;std::ftell&lt;/a&gt;&lt;/code&gt; on a stream associated with the same file (which only works with &lt;code&gt;origin&lt;/code&gt; of &lt;code&gt;&lt;a href=&quot;../c&quot;&gt;SEEK_SET&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">Если &lt;code&gt;stream&lt;/code&gt; открыт в текстовом режиме, единственными поддерживаемыми значениями для &lt;code&gt;offset&lt;/code&gt; являются ноль (который работает с любым &lt;code&gt;origin&lt;/code&gt; ) и значение, возвращаемое более ранним вызовом &lt;code&gt;&lt;a href=&quot;ftell&quot;&gt;std::ftell&lt;/a&gt;&lt;/code&gt; в потоке, связанном с тем же файлом (который работает только с &lt;code&gt;origin&lt;/code&gt; из &lt;code&gt;&lt;a href=&quot;../c&quot;&gt;SEEK_SET&lt;/a&gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="892724969fe6221e78fcbe5fd94b682363cb5949" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;stream&lt;/code&gt; is wide-oriented, the restrictions of both text and binary streams apply (result of &lt;code&gt;&lt;a href=&quot;ftell&quot;&gt;std::ftell&lt;/a&gt;&lt;/code&gt; is allowed with SEEK_SET and zero offset is allowed from SEEK_SET and SEEK_CUR, but not SEEK_END).</source>
          <target state="translated">Если &lt;code&gt;stream&lt;/code&gt; широко ориентирован, применяются ограничения как текстового, так и двоичного потоков (результат &lt;code&gt;&lt;a href=&quot;ftell&quot;&gt;std::ftell&lt;/a&gt;&lt;/code&gt; допускается с SEEK_SET, а смещение нуля допускается из SEEK_SET и SEEK_CUR, но не SEEK_END).</target>
        </trans-unit>
        <trans-unit id="d0b614dfebe10969c88ebb875d7426f7d8ef68bd" translate="yes" xml:space="preserve">
          <source>If the OS uses a</source>
          <target state="translated">Если операционная система использует</target>
        </trans-unit>
        <trans-unit id="78c8e20ea6a30edcc63fb9e62dc035eb0fe67dd3" translate="yes" xml:space="preserve">
          <source>If the above is not possible (e.g. &lt;code&gt;a&lt;/code&gt; does not have the member function &lt;code&gt;construct()&lt;/code&gt;,), then calls placement-new as.</source>
          <target state="translated">Если вышеупомянутое невозможно (например, &lt;code&gt;a&lt;/code&gt; не имеет функции-члена &lt;code&gt;construct()&lt;/code&gt; ,), тогда вызывается place-new as.</target>
        </trans-unit>
        <trans-unit id="08776426179650f866b4d0470c65442caf416cce" translate="yes" xml:space="preserve">
          <source>If the above is not possible (e.g. &lt;code&gt;a&lt;/code&gt; does not have the member function &lt;code&gt;max_size()&lt;/code&gt;), then returns &lt;code&gt;&lt;a href=&quot;../../types/numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;size_type&amp;gt;::max()&lt;/code&gt;(until C++17)&lt;code&gt;&lt;a href=&quot;../../types/numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;size_type&amp;gt;::max() / sizeof(value_type)&lt;/code&gt;(since C++17).</source>
          <target state="translated">Если вышеупомянутое невозможно (например, &lt;code&gt;a&lt;/code&gt; не имеет функции-члена &lt;code&gt;max_size()&lt;/code&gt; ), тогда возвращается &lt;code&gt;&lt;a href=&quot;../../types/numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;size_type&amp;gt;::max()&lt;/code&gt; (до C ++ 17) &lt;code&gt;&lt;a href=&quot;../../types/numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;size_type&amp;gt;::max() / sizeof(value_type)&lt;/code&gt; (начиная с C ++ 17).</target>
        </trans-unit>
        <trans-unit id="aac3be73f3bb8e2fda1848ee16dfee9b40b5d6a7" translate="yes" xml:space="preserve">
          <source>If the aggregate initialization uses copy-(until C++14)list-initialization syntax (&lt;code&gt;T a = {args..}&lt;/code&gt;or &lt;code&gt;T a {args..}&lt;/code&gt;(since C++14)), the braces around the nested initializer lists may be elided (omitted), in which case as many initializer clauses as necessary are used to initialize every member or element of the corresponding subaggregate, and the subsequent initializer clauses are used to initialize the following members of the object. However, if the object has a sub-aggregate without any members (an empty struct, or a struct holding only static members), brace elision is not allowed, and an empty nested list &lt;code&gt;{} &lt;/code&gt; must be used.</source>
          <target state="translated">Если в агрегатной инициализации используется синтаксис инициализации списка (до C ++ 14) ( &lt;code&gt;T a = {args..}&lt;/code&gt; или &lt;code&gt;T a {args..}&lt;/code&gt; (начиная с C ++ 14)), фигурные скобки заключаются во вложенный инициализатор списки могут быть исключены (опущены), и в этом случае столько инициализирующих предложений, сколько необходимо, используется для инициализации каждого члена или элемента соответствующего субагрегата, а последующие операторы инициализатора используются для инициализации следующих членов объекта. Однако, если объект имеет субагрегат без каких-либо элементов (пустая структура или структура, содержащая только статические члены), исключение скобок не допускается, и необходимо использовать пустой вложенный список &lt;code&gt;{} &lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e0399c949000296ee9ae66ca9aac394f1a2f1f9c" translate="yes" xml:space="preserve">
          <source>If the aggregate that is initialized with a designated initializer clause has an anonymous union member, the corresponding designated initializer must name one of the members of that anonymous union.</source>
          <target state="translated">Если агрегат,инициализированный указанным пунктом об инициализации,имеет анонимного члена профсоюза,то соответствующий назначенный инициализатор должен назвать имя одного из членов этого анонимного профсоюза.</target>
        </trans-unit>
        <trans-unit id="594b9ef516bc13e866ad5205b086e5efba4a2ca2" translate="yes" xml:space="preserve">
          <source>If the algorithm fails to allocate memory, &lt;code&gt;&lt;a href=&quot;../memory/new/bad_alloc&quot;&gt;std::bad_alloc&lt;/a&gt;&lt;/code&gt; is thrown.</source>
          <target state="translated">Если алгоритму не удается выделить память, &lt;code&gt;&lt;a href=&quot;../memory/new/bad_alloc&quot;&gt;std::bad_alloc&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1bbf4fee39cb9b1e1b2e31f5aa92d3790c46ca1d" translate="yes" xml:space="preserve">
          <source>If the algorithm fails to allocate memory, &lt;code&gt;&lt;a href=&quot;new/bad_alloc&quot;&gt;std::bad_alloc&lt;/a&gt;&lt;/code&gt; is thrown.</source>
          <target state="translated">Если алгоритму не удается выделить память, &lt;code&gt;&lt;a href=&quot;new/bad_alloc&quot;&gt;std::bad_alloc&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c2e9382364758d1ba08276bed3a0538d258c6220" translate="yes" xml:space="preserve">
          <source>If the allocation function returns a null pointer, which is possible if the non-throwing overload was selected, e.g. with &lt;code&gt;new(&lt;a href=&quot;../memory/new/nothrow&quot;&gt;std::nothrow&lt;/a&gt;) T;&lt;/code&gt;, then the new-expression returns immediately, it does not attempt to initialize an object or to call a deallocation function. If the standard placement allocation function returns a null pointer, which is possible if the user passes a null pointer as the argument, the behavior is undefined.(since C++17).</source>
          <target state="translated">Если функция выделения возвращает нулевой указатель, что возможно, если была выбрана перегрузка без выбрасывания, например, с &lt;code&gt;new(&lt;a href=&quot;../memory/new/nothrow&quot;&gt;std::nothrow&lt;/a&gt;) T;&lt;/code&gt; , затем new-выражение возвращается немедленно, оно не пытается инициализировать объект или вызвать функцию освобождения. Если стандартная функция размещения размещения возвращает нулевой указатель, что возможно, если пользователь передает нулевой указатель в качестве аргумента, поведение не определено (начиная с C ++ 17).</target>
        </trans-unit>
        <trans-unit id="a90b4223ec8c5c3e6da2dcd84075a2e4a1b01cc8" translate="yes" xml:space="preserve">
          <source>If the allocator will</source>
          <target state="translated">Если аллокатор</target>
        </trans-unit>
        <trans-unit id="61e2b91fec3faec7fc75d4eceab84254e8c8a972" translate="yes" xml:space="preserve">
          <source>If the argument &lt;code&gt;A&lt;/code&gt; of the transformed template-1 can be used to deduce the corresponding parameter &lt;code&gt;P&lt;/code&gt; of template-2, but not vice versa, then this &lt;code&gt;A&lt;/code&gt; is more specialized than &lt;code&gt;P&lt;/code&gt; with regards to the type(s) that are deduced by this P/A pair.</source>
          <target state="translated">Если аргумент &lt;code&gt;A&lt;/code&gt; преобразованного шаблона-1 можно использовать для вывода соответствующего параметра &lt;code&gt;P&lt;/code&gt; шаблона-2, но не наоборот, то этот &lt;code&gt;A&lt;/code&gt; более специализирован, чем &lt;code&gt;P&lt;/code&gt; ,в отношении типа (типов), которые выводятся этим П / П пара.</target>
        </trans-unit>
        <trans-unit id="2619199639dd0dfe77e10f7ea0d17382af754c82" translate="yes" xml:space="preserve">
          <source>If the argument is &amp;plusmn;&amp;infin;, &amp;plusmn;1 is returned</source>
          <target state="translated">Если аргумент равен &amp;plusmn; &amp;infin;, возвращается &amp;plusmn; 1</target>
        </trans-unit>
        <trans-unit id="a9eeedbf12ee3261a62193ec2f7bf409d740fd6e" translate="yes" xml:space="preserve">
          <source>If the argument is &amp;plusmn;&amp;infin;, +&amp;infin; is returned</source>
          <target state="translated">Если аргумент равен &amp;plusmn; &amp;infin;, + &amp;infin; возвращается</target>
        </trans-unit>
        <trans-unit id="bc0e32230b86eab8904c3236eac37ff6f8e3e5b9" translate="yes" xml:space="preserve">
          <source>If the argument is &amp;plusmn;&amp;infin;, +&amp;infin; is returned.</source>
          <target state="translated">Если аргумент равен &amp;plusmn; &amp;infin;, возвращается + &amp;infin;.</target>
        </trans-unit>
        <trans-unit id="70915638207ef43ec09152008a5ac4da1c3e101e" translate="yes" xml:space="preserve">
          <source>If the argument is &amp;plusmn;0, &amp;plusmn;&amp;infin; is returned and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_DIVBYZERO&lt;/a&gt;&lt;/code&gt; is raised</source>
          <target state="translated">Если аргумент &amp;plusmn; 0, &amp;plusmn; &amp;infin; возвращается и &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_DIVBYZERO&lt;/a&gt;&lt;/code&gt; поднимается</target>
        </trans-unit>
        <trans-unit id="4bcd3cf56514ebcbadf81a91fe745d514dda05b5" translate="yes" xml:space="preserve">
          <source>If the argument is &amp;plusmn;0, &amp;plusmn;0 is returned</source>
          <target state="translated">Если аргумент равен &amp;plusmn; 0, возвращается &amp;plusmn; 0</target>
        </trans-unit>
        <trans-unit id="79c9397babcc1b0c97ddd36d4f6dacccb4dbab7b" translate="yes" xml:space="preserve">
          <source>If the argument is &amp;plusmn;0, +&amp;infin; is returned and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_DIVBYZERO&lt;/a&gt;&lt;/code&gt; is raised</source>
          <target state="translated">Если аргумент равен &amp;plusmn; 0, + &amp;infin; возвращается и &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_DIVBYZERO&lt;/a&gt;&lt;/code&gt; повышается</target>
        </trans-unit>
        <trans-unit id="97d561db29f01535350a0e816707f41c9ebbceeb" translate="yes" xml:space="preserve">
          <source>If the argument is &amp;plusmn;0, +0 is returned</source>
          <target state="translated">Если аргумент равен &amp;plusmn; 0, возвращается +0</target>
        </trans-unit>
        <trans-unit id="6f44ff73ce4a7042130e83bc24af8060e5fe2b98" translate="yes" xml:space="preserve">
          <source>If the argument is &amp;plusmn;0, -&amp;infin; is returned</source>
          <target state="translated">Если аргумент равен &amp;plusmn; 0, возвращается -&amp;infin;</target>
        </trans-unit>
        <trans-unit id="310b79d192c0fa5a1ce6ca3877e2deb499d9d5f3" translate="yes" xml:space="preserve">
          <source>If the argument is &amp;plusmn;0, -&amp;infin; is returned and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_DIVBYZERO&lt;/a&gt;&lt;/code&gt; is raised.</source>
          <target state="translated">Если аргумент равен &amp;plusmn; 0, возвращается -&amp;infin; и &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_DIVBYZERO&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e20d184a4efd311faacd5da72518930f348cac5a" translate="yes" xml:space="preserve">
          <source>If the argument is &amp;plusmn;0, 1 is returned</source>
          <target state="translated">Если аргумент равен &amp;plusmn; 0, возвращается 1</target>
        </trans-unit>
        <trans-unit id="d3f53d74b0dca3908c99b1e364989b3591808e1e" translate="yes" xml:space="preserve">
          <source>If the argument is &amp;plusmn;0, it is returned unmodified</source>
          <target state="translated">Если аргумент равен &amp;plusmn; 0, он возвращается без изменений</target>
        </trans-unit>
        <trans-unit id="ccd73690fa7a557641f2fe90d1fb0da76c7573ad" translate="yes" xml:space="preserve">
          <source>If the argument is &amp;plusmn;0, it is returned, unmodified</source>
          <target state="translated">Если аргумент равен &amp;plusmn; 0, он возвращается без изменений</target>
        </trans-unit>
        <trans-unit id="666ec3240c22502f1099c8da74484f25ff980d70" translate="yes" xml:space="preserve">
          <source>If the argument is &amp;plusmn;1, a pole error occurs.</source>
          <target state="translated">Если аргумент равен &amp;plusmn; 1, возникает ошибка полюса.</target>
        </trans-unit>
        <trans-unit id="16671d13b546303a8dbbbb41028ae78cbf067eb9" translate="yes" xml:space="preserve">
          <source>If the argument is +&amp;infin; or &amp;plusmn;0, it is returned, unmodified.</source>
          <target state="translated">Если аргумент равен + &amp;infin; или &amp;plusmn; 0, он возвращается без изменений.</target>
        </trans-unit>
        <trans-unit id="54b0607c64e592ab2e8d7944a7583de099ef78bc" translate="yes" xml:space="preserve">
          <source>If the argument is +&amp;infin;, +&amp;infin; is returned</source>
          <target state="translated">Если аргумент + &amp;infin;, + &amp;infin; возвращается</target>
        </trans-unit>
        <trans-unit id="aa21d5b0bb57bf219f506cda16da2521284b89b4" translate="yes" xml:space="preserve">
          <source>If the argument is +&amp;infin;, +&amp;infin; is returned.</source>
          <target state="translated">Если аргумент + &amp;infin;, возвращается + &amp;infin;.</target>
        </trans-unit>
        <trans-unit id="540557a8bd62a5b0f36f5bd102aec659ebb950db" translate="yes" xml:space="preserve">
          <source>If the argument is +&amp;infin;, +&amp;pi;/2 is returned</source>
          <target state="translated">Если аргумент + &amp;infin;, возвращается + &amp;pi; / 2</target>
        </trans-unit>
        <trans-unit id="7199243658fb47291089c2b185fa5cf8110be042" translate="yes" xml:space="preserve">
          <source>If the argument is +&amp;infin;, +0 is returned</source>
          <target state="translated">Если аргумент равен + &amp;infin;, возвращается +0</target>
        </trans-unit>
        <trans-unit id="f4be25ee19a8f2e9c79ffae1bfa98e41cff590c7" translate="yes" xml:space="preserve">
          <source>If the argument is +1, the value &lt;code&gt;+0&lt;/code&gt; is returned.</source>
          <target state="translated">Если аргумент равен +1, возвращается значение &lt;code&gt;+0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="09765a27421db439d2ceef1decf36c6c5400ca31" translate="yes" xml:space="preserve">
          <source>If the argument is -&amp;infin;, +0 is returned</source>
          <target state="translated">Если аргумент -&amp;infin;, возвращается +0</target>
        </trans-unit>
        <trans-unit id="ab67da2ac08a598b0aeee9a84a5ea4203889b128" translate="yes" xml:space="preserve">
          <source>If the argument is -&amp;infin;, -&amp;pi;/2 is returned</source>
          <target state="translated">Если аргумент -&amp;infin;, возвращается -&amp;pi; / 2</target>
        </trans-unit>
        <trans-unit id="c52a07d7a9cd046aa4f61618e846c887cf3ca1d0" translate="yes" xml:space="preserve">
          <source>If the argument is -&amp;infin;, -1 is returned</source>
          <target state="translated">Если аргумент -&amp;infin;, -1 возвращается</target>
        </trans-unit>
        <trans-unit id="3cb7272c20346f5eded435e9a2ce5990a13f544b" translate="yes" xml:space="preserve">
          <source>If the argument is -&amp;infin;, 2 is returned</source>
          <target state="translated">Если аргумент -&amp;infin;, возвращается 2</target>
        </trans-unit>
        <trans-unit id="7b59bb47bb4f9b237288770872fa9592f179ad22" translate="yes" xml:space="preserve">
          <source>If the argument is -&amp;infin;, NaN is returned and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; is raised</source>
          <target state="translated">Если аргумент -&amp;infin;, NaN возвращается и &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; повышается</target>
        </trans-unit>
        <trans-unit id="2728e75a63954aabe83e882896db0bf09fd9c3f9" translate="yes" xml:space="preserve">
          <source>If the argument is -1, -&amp;infin; is returned and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_DIVBYZERO&lt;/a&gt;&lt;/code&gt; is raised.</source>
          <target state="translated">Если аргумент равен -1, возвращается -&amp;infin; и &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_DIVBYZERO&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="dad9f0dbcbb32af831ea87c9b1abd3643a5b7b20" translate="yes" xml:space="preserve">
          <source>If the argument is 1, +0 is returned</source>
          <target state="translated">Если аргумент равен 1,то возвращается +0.</target>
        </trans-unit>
        <trans-unit id="290ee1b584ad39adb2720da091bea3742f568b9f" translate="yes" xml:space="preserve">
          <source>If the argument is 2, +0 is returned</source>
          <target state="translated">Если аргумент 2,то возвращается +0.</target>
        </trans-unit>
        <trans-unit id="9f6074320a813a4e58ce3f8235a3e40354fe9d12" translate="yes" xml:space="preserve">
          <source>If the argument is NaN, NaN is returned</source>
          <target state="translated">Если аргумент NaN,возвращается NaN.</target>
        </trans-unit>
        <trans-unit id="ccc4c1fc3fbbb948e5c992719dc5c43cdd7d9790" translate="yes" xml:space="preserve">
          <source>If the argument is NaN, NaN is returned and domain error is not reported</source>
          <target state="translated">Если аргумент NaN,возвращается NaN,и об ошибке домена не сообщается.</target>
        </trans-unit>
        <trans-unit id="663f54eba211611128011b5b2bd091f463b1a1cc" translate="yes" xml:space="preserve">
          <source>If the argument is a designated initializer list, a conversion is only possible if the parameter has an aggregate type that can be initialized from that initializer list according to the rules for &lt;a href=&quot;aggregate_initialization&quot;&gt;aggregate initialization&lt;/a&gt;, in which case the implicit conversion sequence is a user-defined conversion sequence whose second standard conversion sequence is an identity conversion.</source>
          <target state="translated">Если аргумент является назначенным списком инициализатора, преобразование возможно только в том случае, если параметр имеет агрегатный тип, который может быть инициализирован из этого списка инициализатора в соответствии с правилами для &lt;a href=&quot;aggregate_initialization&quot;&gt;агрегатной инициализации&lt;/a&gt; , и в этом случае последовательность неявного преобразования является определяемым пользователем преобразованием. последовательность, чья вторая стандартная последовательность преобразования является преобразованием идентичности.</target>
        </trans-unit>
        <trans-unit id="f630be49c2abd923603f430a83802a576f8d8a5b" translate="yes" xml:space="preserve">
          <source>If the argument is a negative integer, +&amp;infin; is returned and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_DIVBYZERO&lt;/a&gt;&lt;/code&gt; is raised</source>
          <target state="translated">Если аргумент является отрицательным целым числом, + &amp;infin; , возвращается и &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_DIVBYZERO&lt;/a&gt;&lt;/code&gt; поднимается</target>
        </trans-unit>
        <trans-unit id="d3cb5a23f7100fda931d00bdcf1949dd71d061ad" translate="yes" xml:space="preserve">
          <source>If the argument is a negative integer, NaN is returned and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; is raised</source>
          <target state="translated">Если аргумент является отрицательным числом, то возвращается значение NaN и &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; поднимается</target>
        </trans-unit>
        <trans-unit id="20646ae3669e13c85917f45de5026134f970fd91" translate="yes" xml:space="preserve">
          <source>If the argument is less than -0, &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; is raised and NaN is returned.</source>
          <target state="translated">Если аргумент меньше -0, &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; повышается и NaN возвращается.</target>
        </trans-unit>
        <trans-unit id="d60f1479d7ad633bb20dc263baae8366ce50fe47" translate="yes" xml:space="preserve">
          <source>If the argument is less than -1, NaN is returned and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; is raised.</source>
          <target state="translated">Если аргумент меньше -1, возвращается NaN и &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="82e61b5e3d8efb3126389ca46e457ed7c53253b6" translate="yes" xml:space="preserve">
          <source>If the argument is less than 1, a domain error occurs.</source>
          <target state="translated">Если аргумент меньше 1,то происходит ошибка домена.</target>
        </trans-unit>
        <trans-unit id="8ca2273cafe3374e2295b541c384fca2773d84f3" translate="yes" xml:space="preserve">
          <source>If the argument is negative, NaN is returned and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; is raised.</source>
          <target state="translated">Если аргумент отрицательный, возвращается NaN и &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0ce877c1c558f9ec930d2aac72c101f35a2f7812" translate="yes" xml:space="preserve">
          <source>If the argument is not on the interval [-1, +1], a range error occurs.</source>
          <target state="translated">Если аргумент не находится на интервале [-1,+1],то возникает ошибка диапазона.</target>
        </trans-unit>
        <trans-unit id="a3c3924a950cbead03e34404522a3031242c5c81" translate="yes" xml:space="preserve">
          <source>If the arguments are temporaries, &lt;code&gt;forward_as_tuple&lt;/code&gt; does not extend their lifetime; they have to be used before the end of the full expression.</source>
          <target state="translated">Если аргументы временные, &lt;code&gt;forward_as_tuple&lt;/code&gt; не продлевает срок их службы; они должны быть использованы до конца полного выражения.</target>
        </trans-unit>
        <trans-unit id="2199aba2bc9bf0df1d73b9c3777d78213c53216a" translate="yes" xml:space="preserve">
          <source>If the array contains several elements that &lt;code&gt;comp&lt;/code&gt; would indicate as equal to the element searched for, then it is unspecified which element the function will return as the result.</source>
          <target state="translated">Если массив содержит несколько элементов, которые &lt;code&gt;comp&lt;/code&gt; будет указывать как равные искомому элементу, то неизвестно, какой элемент функция возвратит в результате.</target>
        </trans-unit>
        <trans-unit id="f51494a87d2300af12e0330eba96c74b86cb7986" translate="yes" xml:space="preserve">
          <source>If the associated file is not open (&lt;code&gt;is_open() == false&lt;/code&gt;), returns &lt;code&gt;Traits::eof()&lt;/code&gt; before doing anything.</source>
          <target state="translated">Если связанный файл не открыт ( &lt;code&gt;is_open() == false&lt;/code&gt; ), возвращает &lt;code&gt;Traits::eof()&lt;/code&gt; прежде чем что-либо делать.</target>
        </trans-unit>
        <trans-unit id="b7bafed16d966c0cf1207175d019010ae108d6c1" translate="yes" xml:space="preserve">
          <source>If the associated file is not open (&lt;code&gt;is_open()==false&lt;/code&gt;), fails immediately.</source>
          <target state="translated">Если связанный файл не открыт ( &lt;code&gt;is_open()==false&lt;/code&gt; ), немедленно произойдет сбой.</target>
        </trans-unit>
        <trans-unit id="ae52be96052bf801f3b8098ab2013b04fe3a4a04" translate="yes" xml:space="preserve">
          <source>If the associated file is not open (&lt;code&gt;is_open()==false&lt;/code&gt;, fails immediately.</source>
          <target state="translated">Если связанный файл не открыт ( &lt;code&gt;is_open()==false&lt;/code&gt; , немедленно произойдет сбой.</target>
        </trans-unit>
        <trans-unit id="7cac4bee56cffefb9d5f96aafb66ad2424beb17d" translate="yes" xml:space="preserve">
          <source>If the associated file was already open, returns a null pointer right away.</source>
          <target state="translated">Если связанный с ним файл уже был открыт,то сразу же возвращает нулевой указатель.</target>
        </trans-unit>
        <trans-unit id="707b71cd5415cf8d8476c290727e5a9c8c18e35f" translate="yes" xml:space="preserve">
          <source>If the associated mutex is already locked by this &lt;code&gt;shared_lock&lt;/code&gt; (that is, &lt;a href=&quot;owns_lock&quot;&gt;owns_lock&lt;/a&gt; returns &lt;code&gt;true&lt;/code&gt;), &lt;code&gt;&lt;a href=&quot;../../error/system_error&quot;&gt;std::system_error&lt;/a&gt;&lt;/code&gt; with an error code of &lt;code&gt;&lt;a href=&quot;../../error/errc&quot;&gt;std::errc::resource_deadlock_would_occur&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">Если связанный мьютекс уже заблокирован этим &lt;code&gt;shared_lock&lt;/code&gt; (то есть, &lt;a href=&quot;owns_lock&quot;&gt;owns_lock&lt;/a&gt; возвращает &lt;code&gt;true&lt;/code&gt; ), &lt;code&gt;&lt;a href=&quot;../../error/system_error&quot;&gt;std::system_error&lt;/a&gt;&lt;/code&gt; с кодом ошибки &lt;code&gt;&lt;a href=&quot;../../error/errc&quot;&gt;std::errc::resource_deadlock_would_occur&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a8b1ad230edb75da7998e440c34314fa12ebb13f" translate="yes" xml:space="preserve">
          <source>If the body of a lambda &lt;a href=&quot;definition#ODR-use&quot;&gt;odr-uses&lt;/a&gt; an entity captured by copy, the member of the closure type is accessed. If it is not odr-using the entity, the access is to the original object:</source>
          <target state="translated">Если в теле лямбда- &lt;a href=&quot;definition#ODR-use&quot;&gt;выражения используется&lt;/a&gt; объект, захваченный копией, доступ к члену типа замыкания. Если объект не использует odr, доступ осуществляется к исходному объекту:</target>
        </trans-unit>
        <trans-unit id="efb071bf7d785901c94b7543fe7ce5432fcfa86c" translate="yes" xml:space="preserve">
          <source>If the braced-init-list is empty and &lt;code&gt;T&lt;/code&gt; is a class type with a default constructor, &lt;a href=&quot;value_initialization&quot;&gt;value-initialization&lt;/a&gt; is performed.</source>
          <target state="translated">Если список braced-init-list пуст и &lt;code&gt;T&lt;/code&gt; является типом класса с конструктором по умолчанию, выполняется &lt;a href=&quot;value_initialization&quot;&gt;инициализация значения&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1719a9715867ad8b0bc520fba8f212e17cc25ebe" translate="yes" xml:space="preserve">
          <source>If the buffer uses dynamic allocation, sets the frozen status of the stream to &lt;code&gt;freezefl&lt;/code&gt;.</source>
          <target state="translated">Если буфер использует динамическое распределение, устанавливает замороженное состояние потока в &lt;code&gt;freezefl&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a1b15e0ac114ac6cf1d11c46237069b5057df384" translate="yes" xml:space="preserve">
          <source>If the call returns &lt;code&gt;(pos_type)-1&lt;/code&gt;, executes &lt;code&gt;setstate(failbit)&lt;/code&gt;.</source>
          <target state="translated">Если вызов возвращает &lt;code&gt;(pos_type)-1&lt;/code&gt; , выполняется &lt;code&gt;setstate(failbit)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d455f5da56a971dee921cba17f2bcf47c19cb43f" translate="yes" xml:space="preserve">
          <source>If the call returns &lt;code&gt;false&lt;/code&gt;, the iterator sets &lt;code&gt;*this&lt;/code&gt; to the end-of-sequence iterator, the function returns.</source>
          <target state="translated">Если вызов возвращает &lt;code&gt;false&lt;/code&gt; , итератор устанавливает &lt;code&gt;*this&lt;/code&gt; в итератор конца последовательности, функция возвращает.</target>
        </trans-unit>
        <trans-unit id="e503214a190894ba07737d97130f4f4e57a0952d" translate="yes" xml:space="preserve">
          <source>If the call returns &lt;code&gt;true&lt;/code&gt;, the function returns.</source>
          <target state="translated">Если вызов возвращает &lt;code&gt;true&lt;/code&gt; , функция возвращает.</target>
        </trans-unit>
        <trans-unit id="5756be4be986d9060f28be2990144a451f23bebb" translate="yes" xml:space="preserve">
          <source>If the call to &lt;code&gt;pbuf-&amp;gt;sputc(c)&lt;/code&gt; returns &lt;code&gt;Traits::eof&lt;/code&gt;, sets the failed() flag to true.</source>
          <target state="translated">Если вызов &lt;code&gt;pbuf-&amp;gt;sputc(c)&lt;/code&gt; возвращает &lt;code&gt;Traits::eof&lt;/code&gt; , устанавливает флаг failed () в true.</target>
        </trans-unit>
        <trans-unit id="4aae1dcba7a08d934d0a653ad0c0ff27019c75f7" translate="yes" xml:space="preserve">
          <source>If the capture-default is &lt;code&gt;&amp;amp;&lt;/code&gt;, subsequent simple captures must not begin with &lt;code&gt;&amp;amp;&lt;/code&gt;.</source>
          <target state="translated">Если значение по умолчанию для захвата - &lt;code&gt;&amp;amp;&lt;/code&gt; , последующие простые захваты не должны начинаться с &lt;code&gt;&amp;amp;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0277bab17cc429663b1ace6d465fb1f995414d4e" translate="yes" xml:space="preserve">
          <source>If the capture-default is &lt;code&gt;=&lt;/code&gt;, subsequent simple captures must begin with &lt;code&gt;&amp;amp;&lt;/code&gt; or be &lt;code&gt;*this&lt;/code&gt;(since C++17)or &lt;code&gt;this&lt;/code&gt;(since C++20).</source>
          <target state="translated">Если значение по умолчанию для захвата &lt;code&gt;=&lt;/code&gt; , последующие простые захваты должны начинаться с &lt;code&gt;&amp;amp;&lt;/code&gt; или быть &lt;code&gt;*this&lt;/code&gt; (начиная с C ++ 17) или &lt;code&gt;this&lt;/code&gt; (начиная с C ++ 20).</target>
        </trans-unit>
        <trans-unit id="de84be00a72fc5e9e1aaa148e3a8f5aade0e83e5" translate="yes" xml:space="preserve">
          <source>If the cast is successful, &lt;code&gt;dynamic_cast&lt;/code&gt; returns a value of type &lt;code&gt;new_type&lt;/code&gt;. If the cast fails and &lt;code&gt;new_type&lt;/code&gt; is a pointer type, it returns a null pointer of that type. If the cast fails and &lt;code&gt;new_type&lt;/code&gt; is a reference type, it throws an exception that matches a handler of type &lt;code&gt;&lt;a href=&quot;../types/bad_cast&quot;&gt;std::bad_cast&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Если приведение выполнено успешно, &lt;code&gt;dynamic_cast&lt;/code&gt; возвращает значение типа &lt;code&gt;new_type&lt;/code&gt; . Если приведение не выполнено и &lt;code&gt;new_type&lt;/code&gt; является типом указателя, он возвращает нулевой указатель этого типа. Если приведение завершается неудачно и &lt;code&gt;new_type&lt;/code&gt; является ссылочным типом, он генерирует исключение, соответствующее обработчику типа &lt;code&gt;&lt;a href=&quot;../types/bad_cast&quot;&gt;std::bad_cast&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8d0ba473a6711055af0221180f781e98850fbb86" translate="yes" xml:space="preserve">
          <source>If the character matches one of &lt;code&gt;&quot;0123456789abcdefxABCDEFX+-&quot;&lt;/code&gt;, widened to the locale's char_type as if by &lt;code&gt;&lt;a href=&quot;../use_facet&quot;&gt;std::use_facet&lt;/a&gt;&amp;lt;&lt;a href=&quot;../ctype&quot;&gt;std::ctype&lt;/a&gt;&amp;lt;charT&amp;gt;&amp;gt;(str.getloc()).widen()&lt;/code&gt;, it is converted to the corresponding &lt;code&gt;char&lt;/code&gt;.</source>
          <target state="translated">Если символ соответствует одному из &lt;code&gt;&quot;0123456789abcdefxABCDEFX+-&quot;&lt;/code&gt; , расширенный до char_type локали, как если бы он был &lt;code&gt;&lt;a href=&quot;../use_facet&quot;&gt;std::use_facet&lt;/a&gt;&amp;lt;&lt;a href=&quot;../ctype&quot;&gt;std::ctype&lt;/a&gt;&amp;lt;charT&amp;gt;&amp;gt;(str.getloc()).widen()&lt;/code&gt; , он преобразуется в соответствующий &lt;code&gt;char&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a1c4cec9fd9552b11fc88dfc3cdd3888d0078a93" translate="yes" xml:space="preserve">
          <source>If the character matches the decimal point separator (&lt;code&gt;&lt;a href=&quot;../use_facet&quot;&gt;std::use_facet&lt;/a&gt;&amp;lt;&lt;a href=&quot;../numpunct&quot;&gt;std::numpunct&lt;/a&gt;&amp;lt;charT&amp;gt;&amp;gt;(str.getloc()).decimal_point())&lt;/code&gt;), it is replaced by &lt;code&gt;'.'&lt;/code&gt;.</source>
          <target state="translated">Если символ соответствует разделителю десятичных знаков ( &lt;code&gt;&lt;a href=&quot;../use_facet&quot;&gt;std::use_facet&lt;/a&gt;&amp;lt;&lt;a href=&quot;../numpunct&quot;&gt;std::numpunct&lt;/a&gt;&amp;lt;charT&amp;gt;&amp;gt;(str.getloc()).decimal_point())&lt;/code&gt; ), он заменяется на &lt;code&gt;'.'&lt;/code&gt; ,</target>
        </trans-unit>
        <trans-unit id="4175453721d5f90ed16f3adae9fd0acf7beb27c3" translate="yes" xml:space="preserve">
          <source>If the character matches the thousands separator (&lt;code&gt;&lt;a href=&quot;../use_facet&quot;&gt;std::use_facet&lt;/a&gt;&amp;lt;&lt;a href=&quot;../numpunct&quot;&gt;std::numpunct&lt;/a&gt;&amp;lt;charT&amp;gt;&amp;gt;(str.getloc()).thousands_sep()&lt;/code&gt;) and the thousands separation is in use at all &lt;code&gt;&lt;a href=&quot;../use_facet&quot;&gt;std::use_facet&lt;/a&gt;&amp;lt;&lt;a href=&quot;../numpunct&quot;&gt;std::numpunct&lt;/a&gt;&amp;lt;charT&amp;gt;&amp;gt;(str.getloc()).grouping().length() != 0&lt;/code&gt;, then if the decimal point &lt;code&gt;'.'&lt;/code&gt; has not yet been accumulated, the position of the character is remembered, but the character is otherwise ignored. If the decimal point has already been accumulated, the character is discarded and Stage 2 terminates.</source>
          <target state="translated">Если символ соответствует разделителю тысяч ( &lt;code&gt;&lt;a href=&quot;../use_facet&quot;&gt;std::use_facet&lt;/a&gt;&amp;lt;&lt;a href=&quot;../numpunct&quot;&gt;std::numpunct&lt;/a&gt;&amp;lt;charT&amp;gt;&amp;gt;(str.getloc()).thousands_sep()&lt;/code&gt; ) и разделение тысяч используется вообще &lt;code&gt;&lt;a href=&quot;../use_facet&quot;&gt;std::use_facet&lt;/a&gt;&amp;lt;&lt;a href=&quot;../numpunct&quot;&gt;std::numpunct&lt;/a&gt;&amp;lt;charT&amp;gt;&amp;gt;(str.getloc()).grouping().length() != 0&lt;/code&gt; , тогда если десятичная точка &lt;code&gt;'.'&lt;/code&gt; еще не накоплено, позиция персонажа запоминается, но в противном случае персонаж игнорируется. Если десятичная точка уже накоплена, персонаж отбрасывается и этап 2 заканчивается.</target>
        </trans-unit>
        <trans-unit id="e6c7076c1a1240513d559610a53ddb63ba3eb6f5" translate="yes" xml:space="preserve">
          <source>If the character sequence &lt;code&gt;[first, last)&lt;/code&gt; represents the name of a valid character class in the currently imbued locale (that is, the string between &lt;code&gt;[:&lt;/code&gt; and &lt;code&gt;:]&lt;/code&gt; in regular expressions), returns the implementation-defined value representing this character class. Otherwise, returns zero.</source>
          <target state="translated">Если последовательность символов &lt;code&gt;[first, last)&lt;/code&gt; представляет имя допустимого класса символов в текущей локали (то есть строка между &lt;code&gt;[:&lt;/code&gt; и &lt;code&gt;:]&lt;/code&gt; в регулярных выражениях), возвращает значение, определенное реализацией, представляющее этот класс символов. В противном случае возвращает ноль.</target>
        </trans-unit>
        <trans-unit id="a2ef46a67a9512caa78f86cb2680b53275117ae5" translate="yes" xml:space="preserve">
          <source>If the character sequence &lt;code&gt;[first, last)&lt;/code&gt; represents the name of a valid collating element in the currently imbued locale, returns the name of that collating element. Otherwise, returns an empty string.</source>
          <target state="translated">Если последовательность символов &lt;code&gt;[first, last)&lt;/code&gt; представляет имя действительного элемента сортировки в текущей вставленной локали, возвращает имя этого элемента сортировки. В противном случае возвращает пустую строку.</target>
        </trans-unit>
        <trans-unit id="4fe55081ac62dc0b587a9cbf52fa55cd3bee4000" translate="yes" xml:space="preserve">
          <source>If the closure object's &lt;code&gt;operator()&lt;/code&gt; has a non-throwing exception specification, then the pointer returned by this function has the type pointer to noexcept function.</source>
          <target state="translated">Если &lt;code&gt;operator()&lt;/code&gt; объекта замыкания имеет спецификацию исключений без выброса, то указатель, возвращаемый этой функцией, имеет указатель типа на функцию noexcept.</target>
        </trans-unit>
        <trans-unit id="745715b691af433f45a6d1bda05f6b64c4819109" translate="yes" xml:space="preserve">
          <source>If the compiler issues warnings on unused entities, that warning is suppressed for any entity declared maybe_unused.</source>
          <target state="translated">Если компилятор выдает предупреждения на неиспользуемые сущности,то это предупреждение подавляется для любой сущности,объявленной maybe_unused.</target>
        </trans-unit>
        <trans-unit id="c8a49a5236b04e3615bd1cc238ec4430854742fb" translate="yes" xml:space="preserve">
          <source>If the condition yields &lt;code&gt;true&lt;/code&gt; after conversion to &lt;code&gt;bool&lt;/code&gt;, statement-true is executed.</source>
          <target state="translated">Если условие возвращает &lt;code&gt;true&lt;/code&gt; после преобразования в &lt;code&gt;bool&lt;/code&gt; , выполняется выражение-true.</target>
        </trans-unit>
        <trans-unit id="229091fed99fdddbb18485bc60172db01d5f6825" translate="yes" xml:space="preserve">
          <source>If the conditions listed above are not met, a valid pointer to the new object may still be obtained by applying the pointer optimization barrier &lt;a href=&quot;../utility/launder&quot;&gt;&lt;code&gt;std::launder&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Если перечисленные выше условия не выполняются, действительный указатель на новый объект все еще может быть получен путем применения барьера оптимизации указателя &lt;a href=&quot;../utility/launder&quot;&gt; &lt;code&gt;std::launder&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2221877dc5bedfe8cd4e7aed36ecca467cec7440" translate="yes" xml:space="preserve">
          <source>If the constructor was inherited from multiple base class subobjects of type B, the program is ill-formed, similar to multiply-inherited non-static member functions:</source>
          <target state="translated">Если конструктор наследуется от множества подобъектов базового класса типа B,то программа плохо образуется,подобно умножаемым функциям без статических членов:</target>
        </trans-unit>
        <trans-unit id="ec7e0506f8686074df12634f2b0dcdc66508f971" translate="yes" xml:space="preserve">
          <source>If the container is empty, the returned iterator will be equal to &lt;code&gt;&lt;a href=&quot;end&quot;&gt;end()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Если контейнер пуст, возвращаемый итератор будет равен &lt;code&gt;&lt;a href=&quot;end&quot;&gt;end()&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4be0a9674e89e888ef7897d1c0bff106b4bd693d" translate="yes" xml:space="preserve">
          <source>If the conversion fails with &lt;code&gt;&lt;a href=&quot;../../locale/codecvt_base&quot;&gt;std::codecvt_base::error&lt;/a&gt;&lt;/code&gt;, returns &lt;code&gt;Traits::eof()&lt;/code&gt; without attempting any output.</source>
          <target state="translated">Если преобразование завершается неудачно с &lt;code&gt;&lt;a href=&quot;../../locale/codecvt_base&quot;&gt;std::codecvt_base::error&lt;/a&gt;&lt;/code&gt; , возвращает &lt;code&gt;Traits::eof()&lt;/code&gt; без попытки вывода.</target>
        </trans-unit>
        <trans-unit id="60a697aa95e320d7d6b93da3ee60c2df0a966a8e" translate="yes" xml:space="preserve">
          <source>If the conversion function fails to convert the entire field, the value &lt;code&gt;​0​&lt;/code&gt; is stored in &lt;code&gt;v&lt;/code&gt;</source>
          <target state="translated">Если функция преобразования не может преобразовать все поле, значение &lt;code&gt;​0​&lt;/code&gt; хранится в &lt;code&gt;v&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a4027272e7c52f77712bdb3b653471483e93cc10" translate="yes" xml:space="preserve">
          <source>If the conversion function results in a negative value too large to fit in the type of &lt;code&gt;v&lt;/code&gt;, the most negative representable value is stored in &lt;code&gt;v&lt;/code&gt;, or zero for unsigned integer types.(until C++17)</source>
          <target state="translated">Если функция преобразования приводит к отрицательному значению, слишком большому, чтобы соответствовать типу &lt;code&gt;v&lt;/code&gt; , наиболее отрицательное представимое значение сохраняется в &lt;code&gt;v&lt;/code&gt; , или ноль для целочисленных типов без знака (до C ++ 17).</target>
        </trans-unit>
        <trans-unit id="fb166b2ef44fa2af14cb9e58cf13d66806179e94" translate="yes" xml:space="preserve">
          <source>If the conversion function results in a positive value too large to fit in the type of &lt;code&gt;v&lt;/code&gt;, the most positive representable value is stored in &lt;code&gt;v&lt;/code&gt;</source>
          <target state="translated">Если функция преобразования приводит к положительному значению, слишком большому, чтобы соответствовать типу &lt;code&gt;v&lt;/code&gt; , наиболее положительное представимое значение сохраняется в &lt;code&gt;v&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d2eaadc84330d90ea23a53f900d957f39efcabf8" translate="yes" xml:space="preserve">
          <source>If the conversion is successful, the &lt;code&gt;time&lt;/code&gt; object is modified. All fields of &lt;code&gt;time&lt;/code&gt; are updated to fit their proper ranges. &lt;code&gt;time-&amp;gt;tm_wday&lt;/code&gt; and &lt;code&gt;time-&amp;gt;tm_yday&lt;/code&gt; are recalculated using information available in other fields.</source>
          <target state="translated">Если преобразование прошло успешно, объект &lt;code&gt;time&lt;/code&gt; изменяется. Все поля &lt;code&gt;time&lt;/code&gt; обновляются, чтобы соответствовать их нужным диапазонам. &lt;code&gt;time-&amp;gt;tm_wday&lt;/code&gt; и &lt;code&gt;time-&amp;gt;tm_yday&lt;/code&gt; пересчитываются с использованием информации, доступной в других полях.</target>
        </trans-unit>
        <trans-unit id="c8c7ea2a20a700c8ab515cd57db8ff2477c02ff7" translate="yes" xml:space="preserve">
          <source>If the converted value falls out of range of corresponding return type, a range error occurs (setting &lt;code&gt;&lt;a href=&quot;../../error/errno&quot;&gt;errno&lt;/a&gt;&lt;/code&gt; to &lt;code&gt;&lt;a href=&quot;../../error/errno_macros&quot;&gt;ERANGE&lt;/a&gt;&lt;/code&gt;) and &lt;code&gt;&lt;a href=&quot;../../types/climits&quot;&gt;LONG_MAX&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../../types/climits&quot;&gt;LONG_MIN&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../../types/climits&quot;&gt;LLONG_MAX&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../../types/climits&quot;&gt;LLONG_MIN&lt;/a&gt;&lt;/code&gt; is returned.</source>
          <target state="translated">Если преобразованное значение выходит за пределы диапазона соответствующего возвращаемого типа, возникает ошибка диапазона (установка &lt;code&gt;&lt;a href=&quot;../../error/errno&quot;&gt;errno&lt;/a&gt;&lt;/code&gt; на &lt;code&gt;&lt;a href=&quot;../../error/errno_macros&quot;&gt;ERANGE&lt;/a&gt;&lt;/code&gt; ) и &lt;code&gt;&lt;a href=&quot;../../types/climits&quot;&gt;LONG_MAX&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../../types/climits&quot;&gt;LONG_MIN&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../../types/climits&quot;&gt;LLONG_MAX&lt;/a&gt;&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;../../types/climits&quot;&gt;LLONG_MIN&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6192b4cbcd6b133ff7698ce09fce768219ba252e" translate="yes" xml:space="preserve">
          <source>If the converted value falls out of range of corresponding return type, a range error occurs (setting &lt;code&gt;&lt;a href=&quot;../../error/errno&quot;&gt;errno&lt;/a&gt;&lt;/code&gt; to &lt;code&gt;&lt;a href=&quot;../../error/errno_macros&quot;&gt;ERANGE&lt;/a&gt;&lt;/code&gt;) and &lt;code&gt;&lt;a href=&quot;../../types/integer&quot;&gt;INTMAX_MAX&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../../types/integer&quot;&gt;INTMAX_MIN&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../../types/integer&quot;&gt;UINTMAX_MAX&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;​0​&lt;/code&gt; is returned, as appropriate.</source>
          <target state="translated">Если преобразованное значение выпадает из диапазона соответствующих возвращаемого типа, возникает ошибка диапазона (настройка &lt;code&gt;&lt;a href=&quot;../../error/errno&quot;&gt;errno&lt;/a&gt;&lt;/code&gt; к &lt;code&gt;&lt;a href=&quot;../../error/errno_macros&quot;&gt;ERANGE&lt;/a&gt;&lt;/code&gt; ) и &lt;code&gt;&lt;a href=&quot;../../types/integer&quot;&gt;INTMAX_MAX&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../../types/integer&quot;&gt;INTMAX_MIN&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../../types/integer&quot;&gt;UINTMAX_MAX&lt;/a&gt;&lt;/code&gt; или &lt;code&gt;​0​&lt;/code&gt; возвращается, в зависимости от обстоятельств.</target>
        </trans-unit>
        <trans-unit id="fa940cdd0f1bc4912d7a80a9acf3e3f2a1974390" translate="yes" xml:space="preserve">
          <source>If the coroutine ends with an uncaught exception, it performs the following:</source>
          <target state="translated">Если корутин заканчивается с не пойманным исключением,он выполняет следующее:</target>
        </trans-unit>
        <trans-unit id="12ad0f51863289a6c7c5da2f479d5e058f364975" translate="yes" xml:space="preserve">
          <source>If the coroutine is a non-static member function, such as &lt;code&gt;task&amp;lt;void&amp;gt; my_class::method1(int x) const;&lt;/code&gt;, its &lt;code&gt;Promise&lt;/code&gt; type is &lt;code&gt;std::coroutine_traits&amp;lt;task&amp;lt;void&amp;gt;, const my_class&amp;amp;, int&amp;gt;::promise_type&lt;/code&gt;.</source>
          <target state="translated">Если сопрограмма является нестатической функцией-членом, такой как &lt;code&gt;task&amp;lt;void&amp;gt; my_class::method1(int x) const;&lt;/code&gt; его тип &lt;code&gt;Promise&lt;/code&gt; - &lt;code&gt;std::coroutine_traits&amp;lt;task&amp;lt;void&amp;gt;, const my_class&amp;amp;, int&amp;gt;::promise_type&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7dc7e439c27949bc04c73f28d03c64e858d4848d" translate="yes" xml:space="preserve">
          <source>If the coroutine is defined as &lt;code&gt;task&amp;lt;float&amp;gt; foo(&lt;a href=&quot;../string/basic_string&quot;&gt;std::string&lt;/a&gt; x, bool flag);&lt;/code&gt;, then its &lt;code&gt;Promise&lt;/code&gt; type is &lt;code&gt;std::coroutine_traits&amp;lt;task&amp;lt;float&amp;gt;, std::string, bool&amp;gt;::promise_type&lt;/code&gt;.</source>
          <target state="translated">Если сопрограмма определена как &lt;code&gt;task&amp;lt;float&amp;gt; foo(&lt;a href=&quot;../string/basic_string&quot;&gt;std::string&lt;/a&gt; x, bool flag);&lt;/code&gt; , тогда его тип &lt;code&gt;Promise&lt;/code&gt; - это &lt;code&gt;std::coroutine_traits&amp;lt;task&amp;lt;float&amp;gt;, std::string, bool&amp;gt;::promise_type&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8ed628c0c3ef9224600ee8ab10e072d7456f4358" translate="yes" xml:space="preserve">
          <source>If the coroutine was suspended in the co_await expression, and is later resumed, the resume point is immediately before the call to &lt;code&gt;awaiter.await_resume()&lt;/code&gt;.</source>
          <target state="translated">Если сопрограмма была приостановлена ​​в выражении co_await и впоследствии возобновлена, точка возобновления находится непосредственно перед вызовом &lt;code&gt;awaiter.await_resume()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="779db0a2dceed4ce10fd8dad1f3fd5a2aa365ff9" translate="yes" xml:space="preserve">
          <source>If the correct result is greater than &lt;code&gt;&lt;a href=&quot;../../types/climits&quot;&gt;INT_MAX&lt;/a&gt;&lt;/code&gt; or smaller than &lt;code&gt;&lt;a href=&quot;../../types/climits&quot;&gt;INT_MIN&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; is raised.</source>
          <target state="translated">Если правильный результат больше &lt;code&gt;&lt;a href=&quot;../../types/climits&quot;&gt;INT_MAX&lt;/a&gt;&lt;/code&gt; или меньше &lt;code&gt;&lt;a href=&quot;../../types/climits&quot;&gt;INT_MIN&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; повышается.</target>
        </trans-unit>
        <trans-unit id="6c1e25624b3fd048578a45e9a3c4ec61bc91d80f" translate="yes" xml:space="preserve">
          <source>If the correct result is greater than &lt;code&gt;&lt;a href=&quot;../../types/climits&quot;&gt;INT_MAX&lt;/a&gt;&lt;/code&gt; or smaller than &lt;code&gt;&lt;a href=&quot;../../types/climits&quot;&gt;INT_MIN&lt;/a&gt;&lt;/code&gt;, a domain error or a range error may occur.</source>
          <target state="translated">Если правильный результат больше чем &lt;code&gt;&lt;a href=&quot;../../types/climits&quot;&gt;INT_MAX&lt;/a&gt;&lt;/code&gt; или меньше чем &lt;code&gt;&lt;a href=&quot;../../types/climits&quot;&gt;INT_MIN&lt;/a&gt;&lt;/code&gt; , может произойти ошибка домена или ошибка диапазона.</target>
        </trans-unit>
        <trans-unit id="df721ce87be91a1d2a0670fee727bda1f6488296" translate="yes" xml:space="preserve">
          <source>If the correct result is greater than &lt;code&gt;&lt;a href=&quot;../../types/climits&quot;&gt;INT_MAX&lt;/a&gt;&lt;/code&gt; or smaller than &lt;code&gt;&lt;a href=&quot;../../types/climits&quot;&gt;INT_MIN&lt;/a&gt;&lt;/code&gt;, the return value is unspecified.</source>
          <target state="translated">Если правильный результат больше &lt;code&gt;&lt;a href=&quot;../../types/climits&quot;&gt;INT_MAX&lt;/a&gt;&lt;/code&gt; или меньше &lt;code&gt;&lt;a href=&quot;../../types/climits&quot;&gt;INT_MIN&lt;/a&gt;&lt;/code&gt; , возвращаемое значение не указано.</target>
        </trans-unit>
        <trans-unit id="e57a705dd469f19d6863e23a81d83613f10c1c86" translate="yes" xml:space="preserve">
          <source>If the current rounding mode is &lt;code&gt;&lt;a href=&quot;../fenv/fe_round&quot;&gt;FE_TONEAREST&lt;/a&gt;&lt;/code&gt;, this function rounds to even in halfway cases (like &lt;code&gt;rint&lt;/code&gt;, but unlike &lt;code&gt;round&lt;/code&gt;).</source>
          <target state="translated">Если текущим режимом округления является &lt;code&gt;&lt;a href=&quot;../fenv/fe_round&quot;&gt;FE_TONEAREST&lt;/a&gt;&lt;/code&gt; , эта функция округляется даже до половины &lt;code&gt;rint&lt;/code&gt; (например, rint , но в отличие от &lt;code&gt;round&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="e2333eb5beb6ae4621087ed67aea4b57771b1571" translate="yes" xml:space="preserve">
          <source>If the current rounding mode is...</source>
          <target state="translated">Если текущий режим округления...</target>
        </trans-unit>
        <trans-unit id="896aca99d0b416d865962f92c6c37d2f798c20b2" translate="yes" xml:space="preserve">
          <source>If the current size is greater than &lt;code&gt;count&lt;/code&gt;, the container is reduced to its first &lt;code&gt;count&lt;/code&gt; elements.</source>
          <target state="translated">Если текущий размер больше чем &lt;code&gt;count&lt;/code&gt; , контейнер сокращается до его первых элементов &lt;code&gt;count&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1c6fbeaf9e8910c2d4ff6f11b1e18360cddb4c17" translate="yes" xml:space="preserve">
          <source>If the current size is greater than &lt;code&gt;count&lt;/code&gt;, the string is reduced to its first &lt;code&gt;count&lt;/code&gt; elements.</source>
          <target state="translated">Если текущий размер больше чем &lt;code&gt;count&lt;/code&gt; , строка сокращается до своих первых элементов &lt;code&gt;count&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8f352e4005a3a9b34a2f768d15d84aa23ea90cd3" translate="yes" xml:space="preserve">
          <source>If the current size is less than &lt;code&gt;count&lt;/code&gt;,</source>
          <target state="translated">Если текущий размер меньше, чем &lt;code&gt;count&lt;/code&gt; ,</target>
        </trans-unit>
        <trans-unit id="6f72d059786307ab4c08950a1fc590bdfbacc9a7" translate="yes" xml:space="preserve">
          <source>If the current size is less than &lt;code&gt;count&lt;/code&gt;, additional characters are appended.</source>
          <target state="translated">Если текущий размер меньше &lt;code&gt;count&lt;/code&gt; , добавляются дополнительные символы.</target>
        </trans-unit>
        <trans-unit id="c289d28a9c0b1ae0f12bb49e019b21510591df99" translate="yes" xml:space="preserve">
          <source>If the current size is less than &lt;code&gt;count&lt;/code&gt;, additional elements are appended and initialized with copies of &lt;code&gt;value&lt;/code&gt;.</source>
          <target state="translated">Если текущий размер меньше &lt;code&gt;count&lt;/code&gt; , дополнительные элементы добавляются и инициализируются с копиями &lt;code&gt;value&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="442e11214c1977140f19902972be104365029434" translate="yes" xml:space="preserve">
          <source>If the deallocation functions that were found are class-specific, size-unaware class-specific deallocation function (without a parameter of type &lt;code&gt;&lt;a href=&quot;../types/size_t&quot;&gt;std::size_t&lt;/a&gt;&lt;/code&gt;) is preferred over size-aware class-specific deallocation function (with a parameter of type &lt;code&gt;&lt;a href=&quot;../types/size_t&quot;&gt;std::size_t&lt;/a&gt;&lt;/code&gt;)</source>
          <target state="translated">Если найденные функции освобождения являются специфичными для класса, то функция освобождения от независящего от размера класса (без параметра типа &lt;code&gt;&lt;a href=&quot;../types/size_t&quot;&gt;std::size_t&lt;/a&gt;&lt;/code&gt; ) предпочтительнее, чем зависящая от размера функция освобождения класса (с параметром типа &lt;code&gt;&lt;a href=&quot;../types/size_t&quot;&gt;std::size_t&lt;/a&gt;&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="81a5d52aae1f78fba956c41a28dfa8ef8191aab3" translate="yes" xml:space="preserve">
          <source>If the declared return type is &lt;code&gt;auto&lt;/code&gt;, then the actual return type is &lt;a href=&quot;../utility/compare/common_comparison_category&quot;&gt;&lt;code&gt;std::common_comparison_category_t&amp;lt;Ms&amp;gt;&lt;/code&gt;&lt;/a&gt; where Ms is the list (possibly empty) of the types of base and member subobject and member array elements to be compared. This makes it easier to write cases where the return type non-trivially depends on the members, such as:</source>
          <target state="translated">Если объявленным типом возврата является &lt;code&gt;auto&lt;/code&gt; , то фактическим типом возврата является &lt;a href=&quot;../utility/compare/common_comparison_category&quot;&gt; &lt;code&gt;std::common_comparison_category_t&amp;lt;Ms&amp;gt;&lt;/code&gt; &lt;/a&gt; где Ms - список (возможно, пустой) типов базовых и дочерних подобъектов и элементов массива элементов, которые необходимо сравнить. Это облегчает написание случаев, когда тип возвращаемого значения нетривиально зависит от членов, таких как:</target>
        </trans-unit>
        <trans-unit id="a11e45a27e5f79c83df818f9c033db03c1a75a8a" translate="yes" xml:space="preserve">
          <source>If the default is specified for a template parameter of a primary class template , primary variable template, (since C++14)or alias template, each subsequent template parameter must have a default argument, except the very last one may be a template parameter pack. In a function template, there are no restrictions on the parameters that follow a default, and a parameter pack may be followed by more type parameters only if they have defaults or can be deduced from the function arguments.</source>
          <target state="translated">Если для параметра шаблона первичного класса,шаблона первичной переменной,(начиная с C++14)или шаблона алиасов указан параметр по умолчанию,то каждый последующий параметр шаблона должен иметь аргумент по умолчанию,за исключением того,что самым последним может быть пакет параметров шаблона.В шаблоне функции нет ограничений на параметры,которые следуют за шаблоном по умолчанию,и пакет параметров может сопровождаться параметрами большего типа только в том случае,если они имеют значения по умолчанию или могут быть выведены из аргументов функции.</target>
        </trans-unit>
        <trans-unit id="15dd06f6865462c19c491fa71c0e722074bd75af" translate="yes" xml:space="preserve">
          <source>If the definition of any object results in an object of &lt;a href=&quot;incomplete_type&quot;&gt;incomplete type&lt;/a&gt; or &lt;a href=&quot;abstract_class&quot;&gt;abstract class type&lt;/a&gt;, the program is ill-formed.</source>
          <target state="translated">Если определение какого-либо объекта приводит к объекту &lt;a href=&quot;incomplete_type&quot;&gt;неполного типа&lt;/a&gt; или &lt;a href=&quot;abstract_class&quot;&gt;абстрактного типа класса&lt;/a&gt; , программа плохо сформирована.</target>
        </trans-unit>
        <trans-unit id="6627083d86de96fac39a9639172b8e5cae7776e7" translate="yes" xml:space="preserve">
          <source>If the destination type is &lt;code&gt;bool&lt;/code&gt;, this is a boolean conversion (see below).</source>
          <target state="translated">Если тип назначения - &lt;code&gt;bool&lt;/code&gt; , это логическое преобразование (см. Ниже).</target>
        </trans-unit>
        <trans-unit id="bcab72b198f459511f9abd66295e0e372205290d" translate="yes" xml:space="preserve">
          <source>If the destination type is signed, the value does not change if the source integer can be represented in the destination type. Otherwise the result is implementation-defined(until C++20)the unique value of the destination type equal to the source value modulo 2n</source>
          <target state="translated">При значении типа назначения значение не изменяется,если в типе назначения может быть представлено исходное целое число.В противном случае результат определяется реализацией (до C++20)уникального значения типа получателя,равного исходному значению по модулю 2n</target>
        </trans-unit>
        <trans-unit id="926b449ff74682e6ecadc43082826a46200dfffc" translate="yes" xml:space="preserve">
          <source>If the destination type is unsigned, the resulting value is the smallest unsigned value equal to the source value &lt;a href=&quot;https://en.wikipedia.org/wiki/Modular_arithmetic&quot;&gt; modulo&lt;/a&gt; 2n</source>
          <target state="translated">Если тип назначения не имеет знака, полученное значение является наименьшим значением без знака, равным исходному значению &lt;a href=&quot;https://en.wikipedia.org/wiki/Modular_arithmetic&quot;&gt;по модулю&lt;/a&gt; 2n.</target>
        </trans-unit>
        <trans-unit id="4a5a2a7675f65b9135eddde36e34f905978fe4fb" translate="yes" xml:space="preserve">
          <source>If the directory structure contains cycles, the end iterator may be unreachable.</source>
          <target state="translated">Если структура каталога содержит циклы,то конечный итератор может быть недоступен.</target>
        </trans-unit>
        <trans-unit id="3337548ef4310df502c47a0607ce0d45303b5ba5" translate="yes" xml:space="preserve">
          <source>If the elements in the two ranges are equal, returns &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">Если элементы в двух диапазонах равны, возвращает &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1870c25fe91ccb4fdf9e04186e90172ccaa106e8" translate="yes" xml:space="preserve">
          <source>If the else part of the if statement is present and condition yields &lt;code&gt;false&lt;/code&gt; after conversion to &lt;code&gt;bool&lt;/code&gt;, statement-false is executed.</source>
          <target state="translated">Если в операторе if присутствует другая часть else и условие возвращает &lt;code&gt;false&lt;/code&gt; после преобразования в &lt;code&gt;bool&lt;/code&gt; , выполняется оператор Statement -false.</target>
        </trans-unit>
        <trans-unit id="f2f9989909780caf1535a25076ad27e3ad5b20b0" translate="yes" xml:space="preserve">
          <source>If the enclosing class declaration is, in turn, a class template, when a member template is defined outside of the class body, it takes two sets of template parameters: one for the enclosing class, and another one for itself:</source>
          <target state="translated">Если декларация класса-окрытия,в свою очередь,является шаблоном класса,то при определении шаблона-членов вне тела класса требуется два набора параметров шаблона:один для класса-окрытия,а другой-для себя:</target>
        </trans-unit>
        <trans-unit id="fa860288a207ce4de20ba1818eb37f1d240c59f9" translate="yes" xml:space="preserve">
          <source>If the encoding is state-dependent (&lt;code&gt;encoding() == -1&lt;/code&gt;), then more than &lt;code&gt;max_length()&lt;/code&gt; external characters may be consumed to produce one internal character.</source>
          <target state="translated">Если кодировка зависит от состояния ( &lt;code&gt;encoding() == -1&lt;/code&gt; ), то для создания одного внутреннего символа может использоваться больше чем &lt;code&gt;max_length()&lt;/code&gt; внешних символов.</target>
        </trans-unit>
        <trans-unit id="63c81f2ab01c02567fbf73ffd81b990b4f235586" translate="yes" xml:space="preserve">
          <source>If the end iterator is reached before a valid date is read, the function sets &lt;code&gt;&lt;a href=&quot;../../io/ios_base/iostate&quot;&gt;std::ios_base::eofbit&lt;/a&gt;&lt;/code&gt; in &lt;code&gt;err&lt;/code&gt;. If a parsing error is encountered, the function sets &lt;code&gt;&lt;a href=&quot;../../io/ios_base/iostate&quot;&gt;std::ios_base::failbit&lt;/a&gt;&lt;/code&gt; in &lt;code&gt;err&lt;/code&gt;.</source>
          <target state="translated">Если конечный итератор достигнут до того, как будет прочитана действительная дата, функция устанавливает &lt;code&gt;&lt;a href=&quot;../../io/ios_base/iostate&quot;&gt;std::ios_base::eofbit&lt;/a&gt;&lt;/code&gt; в &lt;code&gt;err&lt;/code&gt; . Если возникает ошибка синтаксического анализа, функция устанавливает &lt;code&gt;&lt;a href=&quot;../../io/ios_base/iostate&quot;&gt;std::ios_base::failbit&lt;/a&gt;&lt;/code&gt; в &lt;code&gt;err&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8aae18db76ff682a209b370fc6276ae620d78597" translate="yes" xml:space="preserve">
          <source>If the end iterator is reached before a valid month name is read, the function sets &lt;code&gt;&lt;a href=&quot;../../io/ios_base/iostate&quot;&gt;std::ios_base::eofbit&lt;/a&gt;&lt;/code&gt; in &lt;code&gt;err&lt;/code&gt;. If a parsing error is encountered, the function sets &lt;code&gt;&lt;a href=&quot;../../io/ios_base/iostate&quot;&gt;std::ios_base::failbit&lt;/a&gt;&lt;/code&gt; in &lt;code&gt;err&lt;/code&gt;.</source>
          <target state="translated">Если конечный итератор достигнут до того, как будет прочитано правильное название месяца, функция устанавливает &lt;code&gt;&lt;a href=&quot;../../io/ios_base/iostate&quot;&gt;std::ios_base::eofbit&lt;/a&gt;&lt;/code&gt; в &lt;code&gt;err&lt;/code&gt; . Если возникает ошибка синтаксического анализа, функция устанавливает &lt;code&gt;&lt;a href=&quot;../../io/ios_base/iostate&quot;&gt;std::ios_base::failbit&lt;/a&gt;&lt;/code&gt; в &lt;code&gt;err&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="eed2547c74a6a3a462c75d24c54d56132c1d3935" translate="yes" xml:space="preserve">
          <source>If the end iterator is reached before a valid value is read, the function sets &lt;code&gt;&lt;a href=&quot;../../io/ios_base/iostate&quot;&gt;std::ios_base::eofbit&lt;/a&gt;&lt;/code&gt; in &lt;code&gt;err&lt;/code&gt;. If a parsing error is encountered, the function sets &lt;code&gt;&lt;a href=&quot;../../io/ios_base/iostate&quot;&gt;std::ios_base::failbit&lt;/a&gt;&lt;/code&gt; in &lt;code&gt;err&lt;/code&gt;.</source>
          <target state="translated">Если конечный итератор достигнут до того, как будет прочитано правильное значение, функция устанавливает &lt;code&gt;&lt;a href=&quot;../../io/ios_base/iostate&quot;&gt;std::ios_base::eofbit&lt;/a&gt;&lt;/code&gt; в &lt;code&gt;err&lt;/code&gt; . Если возникает ошибка синтаксического анализа, функция устанавливает &lt;code&gt;&lt;a href=&quot;../../io/ios_base/iostate&quot;&gt;std::ios_base::failbit&lt;/a&gt;&lt;/code&gt; в &lt;code&gt;err&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9920cfb6a997d965d21f9be654bb51f5b8757867" translate="yes" xml:space="preserve">
          <source>If the end iterator is reached before a valid weekday name is read, the function sets &lt;code&gt;&lt;a href=&quot;../../io/ios_base/iostate&quot;&gt;std::ios_base::eofbit&lt;/a&gt;&lt;/code&gt; in &lt;code&gt;err&lt;/code&gt;. If a parsing error is encountered, the function sets &lt;code&gt;&lt;a href=&quot;../../io/ios_base/iostate&quot;&gt;std::ios_base::failbit&lt;/a&gt;&lt;/code&gt; in &lt;code&gt;err&lt;/code&gt;.</source>
          <target state="translated">Если конечный итератор достигнут до того, как будет прочитано правильное имя дня недели, функция устанавливает &lt;code&gt;&lt;a href=&quot;../../io/ios_base/iostate&quot;&gt;std::ios_base::eofbit&lt;/a&gt;&lt;/code&gt; в &lt;code&gt;err&lt;/code&gt; . Если возникает ошибка синтаксического анализа, функция устанавливает &lt;code&gt;&lt;a href=&quot;../../io/ios_base/iostate&quot;&gt;std::ios_base::failbit&lt;/a&gt;&lt;/code&gt; в &lt;code&gt;err&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="56f8aef93d36921723ad214ce365f4585fbe9195" translate="yes" xml:space="preserve">
          <source>If the entity named by the (unqualified) identifier is a local entity, and would result in an intervening &lt;a href=&quot;lambda&quot;&gt;lambda expression&lt;/a&gt; capturing it by copy if it were named outside of an unevaluated operand in the declarative region in which the identifier appears, then the type of the expression is the type of a &lt;a href=&quot;operator_member_access&quot;&gt;class member access expression&lt;/a&gt; naming the non-static data member that would be declared for such a capture in the closure object of the innermost such intervening lambda expression.</source>
          <target state="translated">Если сущность, названная (неквалифицированным) идентификатором, является локальной сущностью и приведет к тому, что промежуточное &lt;a href=&quot;lambda&quot;&gt;лямбда-выражение&lt;/a&gt; захватит ее по копии, если она будет названа вне неоцененного операнда в декларативной области, в которой появляется идентификатор, тогда тип выражение является типом &lt;a href=&quot;operator_member_access&quot;&gt;выражения доступа к члену класса, в котором&lt;/a&gt; указаны нестатические данные, которые были бы объявлены для такого захвата в объекте замыкания самого внутреннего такого промежуточного лямбда-выражения.</target>
        </trans-unit>
        <trans-unit id="dfdabf4aff6dc82f3c877f50307cf3a860280ed1" translate="yes" xml:space="preserve">
          <source>If the entity named is a &lt;a href=&quot;template_parameters#Non-type_template_parameter&quot;&gt;template parameter object&lt;/a&gt; for a template parameter of type &lt;code&gt;T&lt;/code&gt;, the type of the expression is &lt;code&gt;const T&lt;/code&gt;.</source>
          <target state="translated">Если объект с именем является &lt;a href=&quot;template_parameters#Non-type_template_parameter&quot;&gt;объектом параметра шаблона&lt;/a&gt; для параметра шаблона типа &lt;code&gt;T&lt;/code&gt; , тип выражения &lt;code&gt;const T&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d94c16d2093f565827acd0baa83270e850862eaa" translate="yes" xml:space="preserve">
          <source>If the exception is thrown from a constructor that is invoked by a &lt;a href=&quot;new&quot;&gt;new-expression&lt;/a&gt;, the matching &lt;a href=&quot;../memory/new/operator_delete&quot;&gt;deallocation function&lt;/a&gt; is called, if available.</source>
          <target state="translated">Если исключение выдается из конструктора, который вызывается &lt;a href=&quot;new&quot;&gt;новым выражением&lt;/a&gt; , вызывается соответствующая &lt;a href=&quot;../memory/new/operator_delete&quot;&gt;функция освобождения&lt;/a&gt; , если она доступна.</target>
        </trans-unit>
        <trans-unit id="7c77baa68d29932853f92768b1f24a64502a012b" translate="yes" xml:space="preserve">
          <source>If the execution of the loop needs to be continued at the end of the loop body, &lt;a href=&quot;continue&quot;&gt; continue statement&lt;/a&gt; can be used as shortcut.</source>
          <target state="translated">Если выполнение цикла необходимо продолжить в конце тела цикла, &lt;a href=&quot;continue&quot;&gt;оператор continue&lt;/a&gt; может использоваться как ярлык.</target>
        </trans-unit>
        <trans-unit id="f8c4f280148d62bcff94e6cfcf459f791d957459" translate="yes" xml:space="preserve">
          <source>If the execution of the loop needs to be continued at the end of the loop body, a &lt;a href=&quot;continue&quot;&gt; continue statement&lt;/a&gt; can be used as shortcut.</source>
          <target state="translated">Если выполнение цикла необходимо продолжить в конце тела цикла, оператор &lt;a href=&quot;continue&quot;&gt;continue&lt;/a&gt; может использоваться в качестве ярлыка.</target>
        </trans-unit>
        <trans-unit id="94e3914e819b4e9c6f38a7c7d3a8f66bfec35d72" translate="yes" xml:space="preserve">
          <source>If the execution of the loop needs to be terminated at some point, &lt;a href=&quot;break&quot;&gt; break statement&lt;/a&gt; can be used as terminating statement.</source>
          <target state="translated">Если выполнение цикла необходимо прекратить в какой-то момент, &lt;a href=&quot;break&quot;&gt;оператор break&lt;/a&gt; можно использовать как оператор завершения.</target>
        </trans-unit>
        <trans-unit id="2cd72081fe396e16bec08079f951e2582fddd18b" translate="yes" xml:space="preserve">
          <source>If the execution of the loop needs to be terminated at some point, a &lt;a href=&quot;break&quot;&gt; break statement&lt;/a&gt; can be used as terminating statement.</source>
          <target state="translated">Если выполнение цикла необходимо прервать в какой-то момент, оператор &lt;a href=&quot;break&quot;&gt;break&lt;/a&gt; можно использовать как оператор завершения.</target>
        </trans-unit>
        <trans-unit id="a63e54974439d0c04ddba7efece25f14eb6ccc71" translate="yes" xml:space="preserve">
          <source>If the expression &lt;code&gt;&lt;a href=&quot;clock_time_conversion&quot;&gt;std::chrono::clock_time_conversion&lt;/a&gt;&amp;lt;Dest, Source&amp;gt;{}(t)&lt;/code&gt; is well-formed, returns the result of that expression.</source>
          <target state="translated">Если выражение &lt;code&gt;&lt;a href=&quot;clock_time_conversion&quot;&gt;std::chrono::clock_time_conversion&lt;/a&gt;&amp;lt;Dest, Source&amp;gt;{}(t)&lt;/code&gt; правильно сформировано, возвращает результат этого выражения.</target>
        </trans-unit>
        <trans-unit id="5c56737809ca6e1f51c00db974474519c25494a7" translate="yes" xml:space="preserve">
          <source>If the expression &lt;code&gt;E&lt;/code&gt; has the form &lt;code&gt;PA-&amp;gt;B&lt;/code&gt; or &lt;code&gt;A.B&lt;/code&gt; (where A has class type cv T), then &lt;code&gt;B&lt;/code&gt; is &lt;a href=&quot;lookup&quot;&gt;looked up&lt;/a&gt; as a member function of &lt;code&gt;T&lt;/code&gt;. The function declarations found by that lookup are the candidate functions. The argument list for the purpose of overload resolution has the implied object argument of type cv T.</source>
          <target state="translated">Если выражение &lt;code&gt;E&lt;/code&gt; имеет вид &lt;code&gt;PA-&amp;gt;B&lt;/code&gt; или &lt;code&gt;A.B&lt;/code&gt; (где А имеет класс тип резюме T), то &lt;code&gt;B&lt;/code&gt; будет &lt;a href=&quot;lookup&quot;&gt;посмотрел вверх&lt;/a&gt; как функции члена &lt;code&gt;T&lt;/code&gt; . Объявления функций, найденные этим поиском, являются функциями-кандидатами. Список аргументов для разрешения перегрузки имеет подразумеваемый объектный аргумент типа cv T.</target>
        </trans-unit>
        <trans-unit id="a23e92522ea5793ad90d37f08a288000d14cacdf" translate="yes" xml:space="preserve">
          <source>If the expression &lt;code&gt;E&lt;/code&gt; is a &lt;a href=&quot;expressions#Primary_expressions&quot;&gt;primary expression&lt;/a&gt;, the name is &lt;a href=&quot;lookup&quot;&gt;looked up&lt;/a&gt; following normal rules for function calls (which may involve &lt;a href=&quot;adl&quot;&gt;ADL&lt;/a&gt;). The function declarations found by this lookup are (due to the way lookup works) either:</source>
          <target state="translated">Если выражение &lt;code&gt;E&lt;/code&gt; является &lt;a href=&quot;expressions#Primary_expressions&quot;&gt;основным выражением&lt;/a&gt; , имя &lt;a href=&quot;lookup&quot;&gt;ищется в&lt;/a&gt; соответствии с обычными правилами для вызовов функций (которые могут включать &lt;a href=&quot;adl&quot;&gt;ADL&lt;/a&gt; ). Объявления функций, найденные этим поиском, (из-за способа поиска) также:</target>
        </trans-unit>
        <trans-unit id="69f0efd4d241778b0ab12aa15f7c0cba8b51c323" translate="yes" xml:space="preserve">
          <source>If the expression &lt;code&gt;a &amp;lt;=&amp;gt; b&lt;/code&gt; is well-formed and its result is convertible to &lt;code&gt;std::partial_ordering&lt;/code&gt;, returns that result.</source>
          <target state="translated">Если выражение &lt;code&gt;a &amp;lt;=&amp;gt; b&lt;/code&gt; правильно сформировано, и его результат может быть преобразован в &lt;code&gt;std::partial_ordering&lt;/code&gt; , возвращает этот результат.</target>
        </trans-unit>
        <trans-unit id="a3ce312862a56044d6ce5fd6d18b3cc810505779" translate="yes" xml:space="preserve">
          <source>If the expression &lt;code&gt;a &amp;lt;=&amp;gt; b&lt;/code&gt; is well-formed and its result is convertible to &lt;code&gt;std::strong_equality&lt;/code&gt;, returns that result.</source>
          <target state="translated">Если выражение &lt;code&gt;a &amp;lt;=&amp;gt; b&lt;/code&gt; правильно сформировано и его результат может быть преобразован в &lt;code&gt;std::strong_equality&lt;/code&gt; , возвращает этот результат.</target>
        </trans-unit>
        <trans-unit id="2791850e6413d1fb089fa268221ec13c44284426" translate="yes" xml:space="preserve">
          <source>If the expression &lt;code&gt;a &amp;lt;=&amp;gt; b&lt;/code&gt; is well-formed and its result is convertible to &lt;code&gt;std::weak_equality&lt;/code&gt;, returns that result.</source>
          <target state="translated">Если выражение &lt;code&gt;a &amp;lt;=&amp;gt; b&lt;/code&gt; правильно сформировано и его результат может быть преобразован в &lt;code&gt;std::weak_equality&lt;/code&gt; , возвращает этот результат.</target>
        </trans-unit>
        <trans-unit id="6562c1886aa8be17523dc870268a8b013d14d9d0" translate="yes" xml:space="preserve">
          <source>If the expression &lt;code&gt;a &amp;lt;=&amp;gt; b&lt;/code&gt; is well-formed and its result is convertible to &lt;code&gt;std::weak_ordering&lt;/code&gt;, returns that result.</source>
          <target state="translated">Если выражение &lt;code&gt;a &amp;lt;=&amp;gt; b&lt;/code&gt; правильно сформировано и его результат может быть преобразован в &lt;code&gt;std::weak_ordering&lt;/code&gt; , возвращает этот результат.</target>
        </trans-unit>
        <trans-unit id="82d3a34faff20e40c4069465ee795568784e5d84" translate="yes" xml:space="preserve">
          <source>If the expression &lt;code&gt;a &amp;lt;=&amp;gt; b&lt;/code&gt; is well-formed, returns its result</source>
          <target state="translated">Если выражение &lt;code&gt;a &amp;lt;=&amp;gt; b&lt;/code&gt; правильно сформировано, возвращает его результат</target>
        </trans-unit>
        <trans-unit id="a8ccf3f902bab3475c2f0d81bd04eb2a781e9731" translate="yes" xml:space="preserve">
          <source>If the expression above is a prvalue, the awaiter object is a temporary &lt;a href=&quot;implicit_cast#Temporary_materialization&quot;&gt;materialized&lt;/a&gt; from it. Otherwise, if the expression above is an glvalue, the awaiter object is the object to which it refers.</source>
          <target state="translated">Если вышеприведенное выражение является prvalue, объект ожидающего является временно &lt;a href=&quot;implicit_cast#Temporary_materialization&quot;&gt;материализованным&lt;/a&gt; из него. В противном случае, если вышеприведенное выражение является glvalue, объект ожидателя - это объект, к которому он относится.</target>
        </trans-unit>
        <trans-unit id="84b2a486468566117d378873877349b38e54a1e0" translate="yes" xml:space="preserve">
          <source>If the expression evaluates to nonzero value, the controlled code block is included and skipped otherwise.</source>
          <target state="translated">Если выражение вычисляется до ненулевого значения,то управляемый блок кода включается и пропускается в противном случае.</target>
        </trans-unit>
        <trans-unit id="f8f246002c66268584002c4ed48b13695ad83d46" translate="yes" xml:space="preserve">
          <source>If the expression is a non-void prvalue (after any lvalue-to-rvalue conversion that might have taken place), &lt;a href=&quot;implicit_cast#Temporary_materialization&quot;&gt;temporary materialization&lt;/a&gt; occurs.</source>
          <target state="translated">Если выражение является не пустым prvalue (после любого преобразования lvalue в rvalue, которое могло иметь место), происходит &lt;a href=&quot;implicit_cast#Temporary_materialization&quot;&gt;временная материализация&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7329a5c8ff286b9d0a4e59efe0069989f5cd5e91" translate="yes" xml:space="preserve">
          <source>If the expression used as init or as pack has an operator with precedence below cast at the top level, it can be parenthesized:</source>
          <target state="translated">Если выражение,используемое как init или как pack,имеет оператор,имеющий приоритет ниже каста на верхнем уровне,то оно может быть заключено в круглые скобки:</target>
        </trans-unit>
        <trans-unit id="a2b1b61632e47d98b991cfabb43ddaa1fc1c9b3b" translate="yes" xml:space="preserve">
          <source>If the failure has been caused by end of file condition, additionally sets the</source>
          <target state="translated">Если сбой был вызван состоянием конца файла,дополнительно установите параметр</target>
        </trans-unit>
        <trans-unit id="90c9cca36bdb9f6f7d9748c18430b538e7979538" translate="yes" xml:space="preserve">
          <source>If the failure has been caused by end-of-file condition, additionally sets the</source>
          <target state="translated">Если неисправность вызвана состоянием конца файла,дополнительно установите параметр</target>
        </trans-unit>
        <trans-unit id="994d9bf8337b9cacbb5385430d81add1cb5bd997" translate="yes" xml:space="preserve">
          <source>If the failure has been caused by some other error, sets the</source>
          <target state="translated">Если сбой был вызван какой-либо другой ошибкой,установите параметр</target>
        </trans-unit>
        <trans-unit id="40e036169518dee5621368e67a2b9be1ab5fb193" translate="yes" xml:space="preserve">
          <source>If the file is currently open by the current or another process, the behavior of this function is implementation-defined (in particular, POSIX systems unlink the file name, although the file system space is not reclaimed even if this was the last hardlink to the file until the last running process closes the file, Windows does not allow the file to be deleted).</source>
          <target state="translated">Если файл в данный момент открыт текущим или другим процессом,поведение этой функции определяется реализацией (в частности,POSIX-системы не связывают имя файла,хотя пространство файловой системы не восстанавливается,даже если это была последняя жесткая связь с файлом до тех пор,пока последний запущенный процесс не закроет файл,Windows не позволяет удалить файл).</target>
        </trans-unit>
        <trans-unit id="f8a3927438032bc9c246a1d6cab93f5a9e333a4a" translate="yes" xml:space="preserve">
          <source>If the file is not open (&lt;code&gt;is_open()==false&lt;/code&gt;, this function returns &lt;code&gt;Traits::eof()&lt;/code&gt; immediately.</source>
          <target state="translated">Если файл не открыт ( &lt;code&gt;is_open()==false&lt;/code&gt; , эта функция немедленно возвращает &lt;code&gt;Traits::eof()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a0aabb532f13e04a1724903ba0225e1eed159600" translate="yes" xml:space="preserve">
          <source>If the file is open for reading, updates the get area if necessary.</source>
          <target state="translated">Если файл открыт для чтения,при необходимости обновите область получения.</target>
        </trans-unit>
        <trans-unit id="b7298526d7f2b5594b5589a131851e279edeaa84" translate="yes" xml:space="preserve">
          <source>If the file is open for writing, first writes the put area and any unshift sequences required by the currently imbued locale, using &lt;code&gt;&lt;a href=&quot;../basic_streambuf/overflow&quot;&gt;overflow()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Если файл открыт для записи, сначала запишите область размещения и любые последовательности отмены сдвига, требуемые текущей вставленной локалью, используя &lt;code&gt;&lt;a href=&quot;../basic_streambuf/overflow&quot;&gt;overflow()&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e6046f5bcc7e057f2daa45b27fc1473dbcccb2e9" translate="yes" xml:space="preserve">
          <source>If the file size is cached in this &lt;code&gt;directory_entry&lt;/code&gt;, returns the cached value. Otherwise, returns &lt;code&gt;std::filesystem::file_size(path())&lt;/code&gt; or &lt;code&gt;std::filesystem::file_size(path(), ec)&lt;/code&gt;, respectively.</source>
          <target state="translated">Если размер файла кэшируется в этом &lt;code&gt;directory_entry&lt;/code&gt; , возвращает кэшированное значение. В противном случае возвращает &lt;code&gt;std::filesystem::file_size(path())&lt;/code&gt; или &lt;code&gt;std::filesystem::file_size(path(), ec)&lt;/code&gt; соответственно.</target>
        </trans-unit>
        <trans-unit id="fc2139afc05136a3d64cc794796b08e516434f34" translate="yes" xml:space="preserve">
          <source>If the filename is one of the special filesystem components dot or dot-dot, or if it has no periods, the function returns the entire &lt;a href=&quot;filename&quot;&gt;&lt;code&gt;filename()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Если имя файла является одним из специальных компонентов файловой системы точка или точка-точка, или если оно не имеет периодов, функция возвращает все &lt;a href=&quot;filename&quot;&gt; &lt;code&gt;filename()&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="06579240cba49b57e27dc71348315d2cf9aab0ac" translate="yes" xml:space="preserve">
          <source>If the final overrider of a &lt;code&gt;transaction_safe_dynamic&lt;/code&gt; function is not declared &lt;code&gt;transaction_safe&lt;/code&gt;, calling it in an atomic block is undefined behavior.</source>
          <target state="translated">Если окончательные подмены из &lt;code&gt;transaction_safe_dynamic&lt;/code&gt; функции не объявлены &lt;code&gt;transaction_safe&lt;/code&gt; , назвав его в атомном блоке неопределенное поведение.</target>
        </trans-unit>
        <trans-unit id="7d41e6a07f9e559a56f8b06959d59178f0f1531d" translate="yes" xml:space="preserve">
          <source>If the first character in the filename is a period, that period is ignored (a filename like &quot;.profile&quot; is not treated as an extension).</source>
          <target state="translated">Если первый символ в имени файла является периодом,то этот период игнорируется (имя файла типа &quot;.profile&quot; не рассматривается как расширение).</target>
        </trans-unit>
        <trans-unit id="6020291574132d5834e014d6c7f58d404fb0a67b" translate="yes" xml:space="preserve">
          <source>If the first character of the set is &lt;code&gt;^&lt;/code&gt;, then all characters not in the set are matched. If the set begins with &lt;code&gt;]&lt;/code&gt; or &lt;code&gt;^]&lt;/code&gt; then the &lt;code&gt;]&lt;/code&gt; character is also included into the set. It is implementation-defined whether the character &lt;code&gt;-&lt;/code&gt; in the non-initial position in the scanset may be indicating a range, as in &lt;code&gt;[0-9]&lt;/code&gt;. If width specifier is used, matches only up to</source>
          <target state="translated">Если первый символ набора - &lt;code&gt;^&lt;/code&gt; , то все символы, не входящие в набор, сопоставляются. Если набор начинается с &lt;code&gt;]&lt;/code&gt; или &lt;code&gt;^]&lt;/code&gt; , то символ &lt;code&gt;]&lt;/code&gt; также включается в набор. Определяется реализацией, может ли символ &lt;code&gt;-&lt;/code&gt; в не начальной позиции в наборе сканирования указывать диапазон, как в &lt;code&gt;[0-9]&lt;/code&gt; . Если используется спецификатор ширины, соответствует только до</target>
        </trans-unit>
        <trans-unit id="87a6fda77086306a8c7bdf456c9e29f296b5945d" translate="yes" xml:space="preserve">
          <source>If the first character of the string returned by &lt;code&gt;mp.positive_sign()&lt;/code&gt; or &lt;code&gt;mp.negative_sign()&lt;/code&gt; is found in the &lt;code&gt;money_base::sign&lt;/code&gt; position of the formatting pattern, it is consumed, and the rest of the characters in that string are expected and consumed after all other components of the monetary value. If both &lt;code&gt;mp.positive_sign()&lt;/code&gt; and &lt;code&gt;mp.negative_sign()&lt;/code&gt; are non-empty, the sign is required and must match the first character of one of these strings. If one of theses strings is empty, the sign is optional (and if it is absent, the sign of the result corresponds to the string that was empty). If both strings are empty, or have the same first character, the result is given the positive sign. If the output parameter is a string (&lt;code&gt;digits&lt;/code&gt;) and the result is negative, the value &lt;code&gt;ct.widen('-')&lt;/code&gt; is stored as the first character of the result.</source>
          <target state="translated">Если первый символ строки, возвращенной &lt;code&gt;mp.positive_sign()&lt;/code&gt; или &lt;code&gt;mp.negative_sign()&lt;/code&gt; , найден в позиции &lt;code&gt;money_base::sign&lt;/code&gt; шаблона форматирования, он используется, а остальные символы в этой строке ожидаются и потребляется после всех других компонентов денежной стоимости. Если оба &lt;code&gt;mp.positive_sign()&lt;/code&gt; и &lt;code&gt;mp.negative_sign()&lt;/code&gt; не пустые, знак обязателен и должен соответствовать первому символу одной из этих строк. Если одна из этих строк пуста, знак является необязательным (и если он отсутствует, знак результата соответствует пустой строке). Если обе строки пусты или имеют один и тот же первый символ, результат получает положительный знак. Если выходным параметром является строка ( &lt;code&gt;digits&lt;/code&gt; ) и результат отрицательный, значение &lt;code&gt;ct.widen('-')&lt;/code&gt; сохраняется как первый символ результата.</target>
        </trans-unit>
        <trans-unit id="6d83faa70c2aba93e1941e43de6bbfe2385cd57c" translate="yes" xml:space="preserve">
          <source>If the flag has static &lt;a href=&quot;../language/storage_duration#Storage_duration&quot;&gt;storage duration&lt;/a&gt;, this &lt;a href=&quot;../language/initialization#Static_initialization&quot;&gt;initialization is static&lt;/a&gt;.</source>
          <target state="translated">Если флаг имеет статическую &lt;a href=&quot;../language/storage_duration#Storage_duration&quot;&gt;продолжительность хранения&lt;/a&gt; , эта &lt;a href=&quot;../language/initialization#Static_initialization&quot;&gt;инициализация является статической&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0aca185ec9eaa4817332d6d1708fa168e08a203c" translate="yes" xml:space="preserve">
          <source>If the floating literal begins with the character sequence &lt;code&gt;0x&lt;/code&gt; or &lt;code&gt;0X&lt;/code&gt;, the floating literal is a</source>
          <target state="translated">Если плавающий литерал начинается с последовательности символов &lt;code&gt;0x&lt;/code&gt; или &lt;code&gt;0X&lt;/code&gt; , плавающий литерал является</target>
        </trans-unit>
        <trans-unit id="1fc39f622f213adb1f2c8d85a8aa6d829ea3b127" translate="yes" xml:space="preserve">
          <source>If the format specifier &lt;code&gt;%Z&lt;/code&gt; is used and successfully parsed, the parsed value is assigned to &lt;code&gt;*abbrev&lt;/code&gt; if &lt;code&gt;abbrev&lt;/code&gt; is not null. If the format specifier &lt;code&gt;%z&lt;/code&gt; or a modified variant is used and successfully parsed, the parsed value is assigned to &lt;code&gt;*offset&lt;/code&gt; if &lt;code&gt;offset&lt;/code&gt; is not null, and the parsed offset will be subtracted from the parsed timestamp before the difference is assigned to &lt;code&gt;tp&lt;/code&gt;.</source>
          <target state="translated">Если спецификатор формата &lt;code&gt;%Z&lt;/code&gt; используется и успешно проанализирован, проанализированное значение присваивается &lt;code&gt;*abbrev&lt;/code&gt; , если &lt;code&gt;abbrev&lt;/code&gt; не является нулевым. Если спецификатор формата &lt;code&gt;%z&lt;/code&gt; или модифицированный вариант используется и успешно проанализирован, проанализированное значение присваивается &lt;code&gt;*offset&lt;/code&gt; если &lt;code&gt;offset&lt;/code&gt; не равно нулю, и проанализированное смещение будет вычтено из проанализированной временной метки, прежде чем разность будет назначена для &lt;code&gt;tp&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e503e2359ab45b0919fcc779613a87ba2c630429" translate="yes" xml:space="preserve">
          <source>If the format specifier &lt;code&gt;%Z&lt;/code&gt; is used and successfully parsed, the parsed value is assigned to &lt;code&gt;*abbrev&lt;/code&gt; if &lt;code&gt;abbrev&lt;/code&gt; is not null. If the format specifier &lt;code&gt;%z&lt;/code&gt; or a modified variant is used and successfully parsed, the parsed value is assigned to &lt;code&gt;*offset&lt;/code&gt; if &lt;code&gt;offset&lt;/code&gt; is not null.</source>
          <target state="translated">Если спецификатор формата &lt;code&gt;%Z&lt;/code&gt; используется и успешно проанализирован, проанализированное значение присваивается &lt;code&gt;*abbrev&lt;/code&gt; , если &lt;code&gt;abbrev&lt;/code&gt; не является нулевым. Если спецификатор формата &lt;code&gt;%z&lt;/code&gt; или измененный вариант используется и успешно проанализирован, проанализированному значению присваивается значение &lt;code&gt;*offset&lt;/code&gt; , если &lt;code&gt;offset&lt;/code&gt; не равно нулю.</target>
        </trans-unit>
        <trans-unit id="2ce235bdf9bf338e07e75bb2fe881d619ae23200" translate="yes" xml:space="preserve">
          <source>If the function &lt;code&gt;Derived::f&lt;/code&gt; overrides a function &lt;code&gt;Base::f&lt;/code&gt;, their return types must either be the same or be</source>
          <target state="translated">Если функция &lt;code&gt;Derived::f&lt;/code&gt; переопределяет функцию &lt;code&gt;Base::f&lt;/code&gt; , их возвращаемые типы должны быть одинаковыми или</target>
        </trans-unit>
        <trans-unit id="857c1e56c78b3e56396b067396f56e801e6dd2c3" translate="yes" xml:space="preserve">
          <source>If the function call operator of the specialization &lt;code&gt;std::greater&amp;lt;void&amp;gt;&lt;/code&gt; calls a built-in operator comparing pointers, it yields a strict total order even if the built-in &lt;code&gt;operator&amp;gt;&lt;/code&gt; does not. This strict total order is consistent among the specializations &lt;code&gt;std::less&amp;lt;void&amp;gt;&lt;/code&gt;, &lt;code&gt;std::greater&amp;lt;void&amp;gt;&lt;/code&gt;, &lt;code&gt;std::less_equal&amp;lt;void&amp;gt;&lt;/code&gt;, and &lt;code&gt;std::greater_equal&amp;lt;void&amp;gt;&lt;/code&gt;, and is also consistent with the partial order imposed by the corresponding built-in operators.</source>
          <target state="translated">Если оператор вызова функции специализации &lt;code&gt;std::greater&amp;lt;void&amp;gt;&lt;/code&gt; вызывает встроенный оператор, сравнивающий указатели, он выдает строгий общий порядок, даже если встроенный &lt;code&gt;operator&amp;gt;&lt;/code&gt; этого не делает. Этот строгий общий порядок согласован среди специализаций &lt;code&gt;std::less&amp;lt;void&amp;gt;&lt;/code&gt; , &lt;code&gt;std::greater&amp;lt;void&amp;gt;&lt;/code&gt; , &lt;code&gt;std::less_equal&amp;lt;void&amp;gt;&lt;/code&gt; и &lt;code&gt;std::greater_equal&amp;lt;void&amp;gt;&lt;/code&gt; , а также соответствует частичному порядку навязывается соответствующими встроенными операторами.</target>
        </trans-unit>
        <trans-unit id="efb23e76ae6241c0d68a489477442012c4a6ba54" translate="yes" xml:space="preserve">
          <source>If the function call operator of the specialization &lt;code&gt;std::greater_equal&amp;lt;void&amp;gt;&lt;/code&gt; calls a built-in operator comparing pointers, it yields a strict total order even if the built-in &lt;code&gt;operator&amp;gt;=&lt;/code&gt; does not. This strict total order is consistent among the specializations &lt;code&gt;std::less&amp;lt;void&amp;gt;&lt;/code&gt;, &lt;code&gt;std::greater&amp;lt;void&amp;gt;&lt;/code&gt;, &lt;code&gt;std::less_equal&amp;lt;void&amp;gt;&lt;/code&gt;, and &lt;code&gt;std::greater_equal&amp;lt;void&amp;gt;&lt;/code&gt;, and is also consistent with the partial order imposed by the corresponding built-in operators.</source>
          <target state="translated">Если оператор вызова функции специализации &lt;code&gt;std::greater_equal&amp;lt;void&amp;gt;&lt;/code&gt; вызывает встроенный оператор сравнения указателей, он выдает строгий общий порядок, даже если встроенный &lt;code&gt;operator&amp;gt;=&lt;/code&gt; этого не делает. Этот строгий общий порядок согласован среди специализаций &lt;code&gt;std::less&amp;lt;void&amp;gt;&lt;/code&gt; , &lt;code&gt;std::greater&amp;lt;void&amp;gt;&lt;/code&gt; , &lt;code&gt;std::less_equal&amp;lt;void&amp;gt;&lt;/code&gt; и &lt;code&gt;std::greater_equal&amp;lt;void&amp;gt;&lt;/code&gt; , а также соответствует частичному порядку навязывается соответствующими встроенными операторами.</target>
        </trans-unit>
        <trans-unit id="7d4d6d78f770aad39153c1ff4080cd8ea8e3ca96" translate="yes" xml:space="preserve">
          <source>If the function call operator of the specialization &lt;code&gt;std::less&amp;lt;void&amp;gt;&lt;/code&gt; calls a built-in operator comparing pointers, it yields a strict total order even if the built-in &lt;code&gt;operator&amp;lt;&lt;/code&gt; does not. This strict total order is consistent among the specializations &lt;code&gt;std::less&amp;lt;void&amp;gt;&lt;/code&gt;, &lt;code&gt;std::greater&amp;lt;void&amp;gt;&lt;/code&gt;, &lt;code&gt;std::less_equal&amp;lt;void&amp;gt;&lt;/code&gt;, and &lt;code&gt;std::greater_equal&amp;lt;void&amp;gt;&lt;/code&gt;, and is also consistent with the partial order imposed by the corresponding built-in operators.</source>
          <target state="translated">Если оператор вызова функции специализации &lt;code&gt;std::less&amp;lt;void&amp;gt;&lt;/code&gt; вызывает встроенный оператор, сравнивающий указатели, он выдает строгий общий порядок, даже если встроенный &lt;code&gt;operator&amp;lt;&lt;/code&gt; этого не делает. Этот строгий общий порядок согласован среди специализаций &lt;code&gt;std::less&amp;lt;void&amp;gt;&lt;/code&gt; , &lt;code&gt;std::greater&amp;lt;void&amp;gt;&lt;/code&gt; , &lt;code&gt;std::less_equal&amp;lt;void&amp;gt;&lt;/code&gt; и &lt;code&gt;std::greater_equal&amp;lt;void&amp;gt;&lt;/code&gt; , а также соответствует частичному порядку навязывается соответствующими встроенными операторами.</target>
        </trans-unit>
        <trans-unit id="40559e5060a6bc4c31508f6386e2b42c2555e25e" translate="yes" xml:space="preserve">
          <source>If the function call operator of the specialization &lt;code&gt;std::less_equal&amp;lt;void&amp;gt;&lt;/code&gt; calls a built-in operator comparing pointers, it yields a strict total order even if the built-in &lt;code&gt;operator&amp;lt;=&lt;/code&gt; does not. This strict total order is consistent among the specializations &lt;code&gt;std::less&amp;lt;void&amp;gt;&lt;/code&gt;, &lt;code&gt;std::greater&amp;lt;void&amp;gt;&lt;/code&gt;, &lt;code&gt;std::less_equal&amp;lt;void&amp;gt;&lt;/code&gt;, and &lt;code&gt;std::greater_equal&amp;lt;void&amp;gt;&lt;/code&gt;, and is also consistent with the partial order imposed by the corresponding built-in operators.</source>
          <target state="translated">Если оператор вызова функции специализации &lt;code&gt;std::less_equal&amp;lt;void&amp;gt;&lt;/code&gt; вызывает встроенный оператор сравнения указателей, он выдает строгий общий порядок, даже если встроенный &lt;code&gt;operator&amp;lt;=&lt;/code&gt; этого не делает. Этот строгий общий порядок согласован среди специализаций &lt;code&gt;std::less&amp;lt;void&amp;gt;&lt;/code&gt; , &lt;code&gt;std::greater&amp;lt;void&amp;gt;&lt;/code&gt; , &lt;code&gt;std::less_equal&amp;lt;void&amp;gt;&lt;/code&gt; и &lt;code&gt;std::greater_equal&amp;lt;void&amp;gt;&lt;/code&gt; , а также соответствует частичному порядку навязывается соответствующими встроенными операторами.</target>
        </trans-unit>
        <trans-unit id="6d049b3d36607639d24052288370b34cd4ee531e" translate="yes" xml:space="preserve">
          <source>If the function extracts no characters (e.g. if &lt;code&gt;count &amp;lt; 1&lt;/code&gt;), &lt;code&gt;setstate(failbit)&lt;/code&gt; is executed.</source>
          <target state="translated">Если функция не извлекает никаких символов (например, если &lt;code&gt;count &amp;lt; 1&lt;/code&gt; ), &lt;code&gt;setstate(failbit)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f3778a28625a42b16a2c98400bf20b26542a73dd" translate="yes" xml:space="preserve">
          <source>If the function is called when no exception is being handled, an empty &lt;code&gt;&lt;a href=&quot;exception_ptr&quot;&gt;std::exception_ptr&lt;/a&gt;&lt;/code&gt; is returned.</source>
          <target state="translated">Если функция вызывается, когда исключение не обрабатывается, возвращается пустой &lt;code&gt;&lt;a href=&quot;exception_ptr&quot;&gt;std::exception_ptr&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="251005437285fe4170728bd7ef6498ade0a544a1" translate="yes" xml:space="preserve">
          <source>If the function is overloaded, &lt;a href=&quot;overload_resolution&quot;&gt;overload resolution&lt;/a&gt; takes place first, and the program is only ill-formed if the deleted function was selected.</source>
          <target state="translated">Если функция перегружена, сначала выполняется &lt;a href=&quot;overload_resolution&quot;&gt;разрешение перегрузки&lt;/a&gt; , и программа работает плохо, только если удаленная функция была выбрана.</target>
        </trans-unit>
        <trans-unit id="0813887879f4315c7f626d21875c1875367fd78d" translate="yes" xml:space="preserve">
          <source>If the function name names a function template, then, first, &lt;a href=&quot;template_argument_deduction&quot;&gt;template argument deduction&lt;/a&gt; is done, and if it succeeds, it produces a single template specialization which is added to the set of overloads to consider. All functions whose associated &lt;a href=&quot;constraints&quot;&gt;constraints&lt;/a&gt; are not satisfied are dropped from the set.(since C++20) If more than one function from the set matches the target, and at least one function is non-template, the template specializations are eliminated from consideration. For any pair of non-template functions where one is &lt;a href=&quot;constraints&quot;&gt;more constrained&lt;/a&gt; than another, the less constrained function is dropped from the set(since C++20). If all remaining candidates are template specializations, &lt;a href=&quot;partial_specialization&quot;&gt;less specialized&lt;/a&gt; ones are removed if more specialized are available. If more than one candidate remains after the removals, the program is ill-formed.</source>
          <target state="translated">Если имя функции именует шаблон функции, то, во-первых, выполняется &lt;a href=&quot;template_argument_deduction&quot;&gt;вывод аргумента шаблона&lt;/a&gt; , и, если это происходит успешно, создается одна специализация шаблона, которая добавляется к набору перегрузок, которые необходимо учитывать. Все функции, связанные &lt;a href=&quot;constraints&quot;&gt;ограничения&lt;/a&gt; которых не выполняются, удаляются из набора (начиная с C ++ 20). Если целевая функция соответствует более чем одной функции из набора, и хотя бы одна функция не является шаблонной, то специализации шаблона исключаются из рассмотрения. , Для любой пары не шаблонных функций, где одна &lt;a href=&quot;constraints&quot;&gt;более ограничена,&lt;/a&gt; чем другая, менее ограниченная функция удаляется из набора (начиная с C ++ 20). Если все остальные кандидаты являются шаблонными специализациями, &lt;a href=&quot;partial_specialization&quot;&gt;менее специализированными&lt;/a&gt;те удаляются, если доступны более специализированные. Если после удаления остается более одного кандидата, программа является некорректной.</target>
        </trans-unit>
        <trans-unit id="22b71c40978885e6386333f0b2f28d4de5c561ce" translate="yes" xml:space="preserve">
          <source>If the function selected by overload resolution does not exchange the values referenced by &lt;code&gt;t&lt;/code&gt; and &lt;code&gt;u&lt;/code&gt;, the program is ill-formed; no diagnostic required.</source>
          <target state="translated">Если функция, выбранная с помощью разрешения перегрузки, не обменивается значениями, на которые ссылаются &lt;code&gt;t&lt;/code&gt; и &lt;code&gt;u&lt;/code&gt; , программа некорректна; Диагностика не требуется.</target>
        </trans-unit>
        <trans-unit id="93d41cd28845eed34b17adb4d10684f1b1c26d1d" translate="yes" xml:space="preserve">
          <source>If the function that called &lt;code&gt;&lt;a href=&quot;setjmp&quot;&gt;setjmp&lt;/a&gt;&lt;/code&gt; has exited, the behavior is undefined (in other words, only long jumps up the call stack are allowed).</source>
          <target state="translated">Если вышла функция, &lt;code&gt;&lt;a href=&quot;setjmp&quot;&gt;setjmp&lt;/a&gt;&lt;/code&gt; , поведение не определено (другими словами, разрешены только длинные прыжки вверх по стеку вызовов).</target>
        </trans-unit>
        <trans-unit id="532af6d794823602f1906bb8fd26e75deeabc0c7" translate="yes" xml:space="preserve">
          <source>If the function throws an exception of the type not listed in its exception specification, the function &lt;code&gt;&lt;a href=&quot;../error/exception/unexpected&quot;&gt;std::unexpected&lt;/a&gt;&lt;/code&gt; is called. The default function calls &lt;code&gt;&lt;a href=&quot;../error/terminate&quot;&gt;std::terminate&lt;/a&gt;&lt;/code&gt;, but it may be replaced by a user-provided function (via &lt;code&gt;&lt;a href=&quot;../error/exception/set_unexpected&quot;&gt;std::set_unexpected&lt;/a&gt;&lt;/code&gt;) which may call &lt;code&gt;&lt;a href=&quot;../error/terminate&quot;&gt;std::terminate&lt;/a&gt;&lt;/code&gt; or throw an exception. If the exception thrown from &lt;code&gt;&lt;a href=&quot;../error/exception/unexpected&quot;&gt;std::unexpected&lt;/a&gt;&lt;/code&gt; is accepted by the exception specification, stack unwinding continues as usual. If it isn't, but &lt;code&gt;&lt;a href=&quot;../error/bad_exception&quot;&gt;std::bad_exception&lt;/a&gt;&lt;/code&gt; is allowed by the exception specification, &lt;code&gt;&lt;a href=&quot;../error/bad_exception&quot;&gt;std::bad_exception&lt;/a&gt;&lt;/code&gt; is thrown. Otherwise, &lt;code&gt;&lt;a href=&quot;../error/terminate&quot;&gt;std::terminate&lt;/a&gt;&lt;/code&gt; is called.</source>
          <target state="translated">Если функция выдает исключение типа, не указанного в спецификации исключений, вызывается функция &lt;code&gt;&lt;a href=&quot;../error/exception/unexpected&quot;&gt;std::unexpected&lt;/a&gt;&lt;/code&gt; . Функция по умолчанию вызывает &lt;code&gt;&lt;a href=&quot;../error/terminate&quot;&gt;std::terminate&lt;/a&gt;&lt;/code&gt; , но она может быть заменена предоставленной пользователем функцией (через &lt;code&gt;&lt;a href=&quot;../error/exception/set_unexpected&quot;&gt;std::set_unexpected&lt;/a&gt;&lt;/code&gt; ), которая может вызвать &lt;code&gt;&lt;a href=&quot;../error/terminate&quot;&gt;std::terminate&lt;/a&gt;&lt;/code&gt; или вызвать исключение. Если исключение, выброшенное из &lt;code&gt;&lt;a href=&quot;../error/exception/unexpected&quot;&gt;std::unexpected&lt;/a&gt;&lt;/code&gt; , принято спецификацией исключения, разматывание стека продолжается как обычно. Если это не так, но &lt;code&gt;&lt;a href=&quot;../error/bad_exception&quot;&gt;std::bad_exception&lt;/a&gt;&lt;/code&gt; допускается спецификацией исключения, &lt;code&gt;&lt;a href=&quot;../error/bad_exception&quot;&gt;std::bad_exception&lt;/a&gt;&lt;/code&gt; . В противном случае вызывается &lt;code&gt;&lt;a href=&quot;../error/terminate&quot;&gt;std::terminate&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b4bb1179760bc730c31b7e350c9e316f8b5d5256" translate="yes" xml:space="preserve">
          <source>If the function-try-block is on a delegating constructor, which called a non-delegating constructor that completed successfully, but then the body of the delegating constructor throws, the destructor of this object will be completed before any catch clauses of the function-try-block are entered.</source>
          <target state="translated">Если функция-трибулятор находится на делегирующем конструкторе,который вызвал неделегирующий конструктор,завершившийся успешно,но затем бросил тело делегирующего конструктора,то деструктор этого объекта будет завершен до того,как будут введены какие-нибудь ловушки функции-трибулятора.</target>
        </trans-unit>
        <trans-unit id="7500ebfb29c88826fb63f492df6d76905a9569c0" translate="yes" xml:space="preserve">
          <source>If the get area is empty, calls &lt;code&gt;&lt;a href=&quot;showmanyc&quot;&gt;showmanyc()&lt;/a&gt;&lt;/code&gt; to determine the number of bytes available in the associated character sequence. In this case, the value returned is the number of bytes that can be extracted from the buffer while it's guaranteed that &lt;code&gt;&lt;a href=&quot;underflow&quot;&gt;underflow()&lt;/a&gt;&lt;/code&gt; would not return &lt;code&gt;Traits::eof&lt;/code&gt;.</source>
          <target state="translated">Если область get пуста, вызывается &lt;code&gt;&lt;a href=&quot;showmanyc&quot;&gt;showmanyc()&lt;/a&gt;&lt;/code&gt; для определения количества байтов, доступных в соответствующей последовательности символов. В этом случае возвращаемое значение - это количество байтов, которое может быть извлечено из буфера, хотя гарантируется, что &lt;code&gt;&lt;a href=&quot;underflow&quot;&gt;underflow()&lt;/a&gt;&lt;/code&gt; не вернет &lt;code&gt;Traits::eof&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3b3eec597fe44d789a14bb34434aa90dd5be188a" translate="yes" xml:space="preserve">
          <source>If the implementation cannot parallelize or vectorize (e.g. due to lack of resources), all standard execution policies can fall back to sequential execution.</source>
          <target state="translated">Если реализация не может распараллелить или векторизовать (например,из-за нехватки ресурсов),все стандартные политики выполнения могут вернуться к последовательному выполнению.</target>
        </trans-unit>
        <trans-unit id="1d83c11796c2c1e3f318ffcc89e81bbd5f8b11e8" translate="yes" xml:space="preserve">
          <source>If the implementation does not support floating-point infinities, the macro &lt;code&gt;INFINITY&lt;/code&gt; expands to a positive value that is guaranteed to overflow a &lt;code&gt;float&lt;/code&gt; at compile time, and the use of this macro generates a compiler warning.</source>
          <target state="translated">Если реализация не поддерживает бесконечности с плавающей точкой, макрос &lt;code&gt;INFINITY&lt;/code&gt; расширяется до положительного значения, которое гарантированно переполняет число с &lt;code&gt;float&lt;/code&gt; во время компиляции, и использование этого макроса генерирует предупреждение компилятора.</target>
        </trans-unit>
        <trans-unit id="c2a825970a15face4ff4ecff0110e20adedc7e9c" translate="yes" xml:space="preserve">
          <source>If the implementation of this function requires a call to &lt;code&gt;new&lt;/code&gt; and the call fails, the returned pointer will hold a reference to an instance of &lt;code&gt;&lt;a href=&quot;../memory/new/bad_alloc&quot;&gt;std::bad_alloc&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Если для реализации этой функции требуется вызов &lt;code&gt;new&lt;/code&gt; и вызов завершится неудачно, возвращаемый указатель будет содержать ссылку на экземпляр &lt;code&gt;&lt;a href=&quot;../memory/new/bad_alloc&quot;&gt;std::bad_alloc&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="026f63aebd84e1c965f7e8366d68af982aae2ce8" translate="yes" xml:space="preserve">
          <source>If the implementation of this function requires copying the captured exception object and its copy constructor throws an exception, the returned pointer will hold a reference to the exception thrown. If the copy constructor of the thrown exception object also throws, the returned pointer may hold a reference to an instance of &lt;code&gt;&lt;a href=&quot;bad_exception&quot;&gt;std::bad_exception&lt;/a&gt;&lt;/code&gt; to break the endless loop.</source>
          <target state="translated">Если реализация этой функции требует копирования захваченного объекта исключения и его конструктор копирования генерирует исключение, возвращаемый указатель будет содержать ссылку на выброшенное исключение. Если конструктор копирования брошенного объекта исключения также выбрасывает, возвращенный указатель может содержать ссылку на экземпляр &lt;code&gt;&lt;a href=&quot;bad_exception&quot;&gt;std::bad_exception&lt;/a&gt;&lt;/code&gt; чтобы разорвать бесконечный цикл.</target>
        </trans-unit>
        <trans-unit id="19ffe219703efe6527e00547f4a8cca5d22a9042" translate="yes" xml:space="preserve">
          <source>If the implementation supports IEEE floating-point arithmetic (IEC 60559),</source>
          <target state="translated">Если реализация поддерживает арифметику с плавающей запятой IEEE (IEC 60559),</target>
        </trans-unit>
        <trans-unit id="288c402c66673ce9a5009971c355fc8223b75acd" translate="yes" xml:space="preserve">
          <source>If the implementation supports IEEE floating-point arithmetic (IEC 60559),   For the &lt;code&gt;std::rint&lt;/code&gt; function:</source>
          <target state="translated">Если реализация поддерживает арифметику с плавающей точкой IEEE (IEC 60559), для функции &lt;code&gt;std::rint&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="0958ac9ba873e345e2bdc636b948c447e2e03547" translate="yes" xml:space="preserve">
          <source>If the implementation supports IEEE floating-point arithmetic (IEC 60559),   For the &lt;code&gt;std::round&lt;/code&gt; function:</source>
          <target state="translated">Если реализация поддерживает арифметику с плавающей точкой IEEE (IEC 60559), для функции &lt;code&gt;std::round&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="c7685e11635ec992c012cd0e03140bd9ce1479a3" translate="yes" xml:space="preserve">
          <source>If the implementation supports IEEE floating-point arithmetic (IEC 60559), &lt;code&gt;math_errhandling &amp;amp; MATH_ERREXCEPT&lt;/code&gt; is required to be non-zero.</source>
          <target state="translated">Если реализация поддерживает арифметику с плавающей точкой IEEE (IEC 60559), &lt;code&gt;math_errhandling &amp;amp; MATH_ERREXCEPT&lt;/code&gt; должно быть ненулевым.</target>
        </trans-unit>
        <trans-unit id="452d571ea8f52d84cf9e46de2bbbf6be56c3970a" translate="yes" xml:space="preserve">
          <source>If the implementation supports IEEE floating-point arithmetic,</source>
          <target state="translated">Если реализация поддерживает арифметику с плавающей запятой IEEE,</target>
        </trans-unit>
        <trans-unit id="7392bc849012f8a7b52172fc01358b19f1c644b0" translate="yes" xml:space="preserve">
          <source>If the implementation supports floating-point infinities, the macro &lt;code&gt;INFINITY&lt;/code&gt; expands to constant expression of type &lt;code&gt;float&lt;/code&gt; which evaluates to positive or unsigned infinity.</source>
          <target state="translated">Если реализация поддерживает бесконечность с плавающей точкой, макрос &lt;code&gt;INFINITY&lt;/code&gt; расширяется до константного выражения типа &lt;code&gt;float&lt;/code&gt; , которое оценивается как положительная или беззнаковая бесконечность.</target>
        </trans-unit>
        <trans-unit id="5ccfe7e9c2a2ea14c1997c4a20a1b44aba2730f7" translate="yes" xml:space="preserve">
          <source>If the implicitly-declared copy assignment operator is neither deleted nor trivial, it is defined (that is, a function body is generated and compiled) by the compiler if &lt;a href=&quot;definition#ODR-use&quot;&gt;odr-used&lt;/a&gt;. For &lt;code&gt;union&lt;/code&gt; types, the implicitly-defined copy assignment copies the object representation (as by &lt;code&gt;&lt;a href=&quot;../string/byte/memmove&quot;&gt;std::memmove&lt;/a&gt;&lt;/code&gt;). For non-union class types (&lt;code&gt;class&lt;/code&gt; and &lt;code&gt;struct&lt;/code&gt;), the operator performs member-wise copy assignment of the object's bases and non-static members, in their initialization order, using built-in assignment for the scalars and copy assignment operator for class types.</source>
          <target state="translated">Если неявно объявленный оператор присваивания копии не является ни удаленным, ни тривиальным, он определяется (то есть тело функции генерируется и компилируется) компилятором, если &lt;a href=&quot;definition#ODR-use&quot;&gt;используется odr&lt;/a&gt; . Для типов &lt;code&gt;union&lt;/code&gt; неявно определенное назначение копирования копирует представление объекта (как с помощью &lt;code&gt;&lt;a href=&quot;../string/byte/memmove&quot;&gt;std::memmove&lt;/a&gt;&lt;/code&gt; ). Для типов &lt;code&gt;class&lt;/code&gt; не относящихся к объединению ( класс и &lt;code&gt;struct&lt;/code&gt; ), оператор выполняет присваивание копий по элементам для базовых и нестатических членов объекта в порядке их инициализации, используя встроенное присваивание для скаляров и оператор присваивания для типов классов. ,</target>
        </trans-unit>
        <trans-unit id="d8ae3f1b05db376bf2d23b1574a42628e3a6ef11" translate="yes" xml:space="preserve">
          <source>If the implicitly-declared copy constructor is not deleted, it is defined (that is, a function body is generated and compiled) by the compiler if &lt;a href=&quot;definition#ODR-use&quot;&gt;odr-used&lt;/a&gt;. For &lt;code&gt;union&lt;/code&gt; types, the implicitly-defined copy constructor copies the object representation (as by &lt;code&gt;&lt;a href=&quot;../string/byte/memmove&quot;&gt;std::memmove&lt;/a&gt;&lt;/code&gt;). For non-union class types (&lt;code&gt;class&lt;/code&gt; and &lt;code&gt;struct&lt;/code&gt;), the constructor performs full member-wise copy of the object's bases and non-static members, in their initialization order, using direct initialization. If this satisfies the requirements of a &lt;a href=&quot;constexpr&quot;&gt;constexpr constructor&lt;/a&gt;, the generated copy constructor is &lt;code&gt;constexpr&lt;/code&gt;.(since C++11).</source>
          <target state="translated">Если неявно объявленный конструктор копирования не удаляется, он определяется (то есть тело функции генерируется и компилируется) компилятором, если &lt;a href=&quot;definition#ODR-use&quot;&gt;используется odr&lt;/a&gt; . Для типов &lt;code&gt;union&lt;/code&gt; неявно определенный конструктор копирования копирует представление объекта (как с помощью &lt;code&gt;&lt;a href=&quot;../string/byte/memmove&quot;&gt;std::memmove&lt;/a&gt;&lt;/code&gt; ). Для типов &lt;code&gt;class&lt;/code&gt; не являющихся объединениями ( класс и &lt;code&gt;struct&lt;/code&gt; ), конструктор выполняет полную для всех членов копию баз и нестатических членов объекта в порядке их инициализации, используя прямую инициализацию. Если это удовлетворяет требованиям конструктора &lt;a href=&quot;constexpr&quot;&gt;constexpr&lt;/a&gt; , сгенерированный конструктор копирования будет &lt;code&gt;constexpr&lt;/code&gt; . ( Начиная с C ++ 11).</target>
        </trans-unit>
        <trans-unit id="30e62786983413b04a43c6ccf7b6769db6b9db27" translate="yes" xml:space="preserve">
          <source>If the implicitly-declared default constructor is not defined as deleted, it is defined (that is, a function body is generated and compiled) by the compiler if &lt;a href=&quot;definition#ODR-use&quot;&gt;odr-used&lt;/a&gt;, and it has exactly the same effect as a user-defined constructor with empty body and empty initializer list. That is, it calls the default constructors of the bases and of the non-static members of this class. If this satisfies the requirements of a &lt;a href=&quot;constexpr&quot;&gt;constexpr constructor&lt;/a&gt;, the generated constructor is &lt;code&gt;constexpr&lt;/code&gt;.(since C++11).</source>
          <target state="translated">Если неявно объявленный конструктор по умолчанию не определен как удаленный, он определяется (то есть тело функции генерируется и компилируется) компилятором, если &lt;a href=&quot;definition#ODR-use&quot;&gt;используется odr&lt;/a&gt; , и он имеет тот же эффект, что и определяемый пользователем конструктор с пустое тело и пустой список инициализатора. То есть он вызывает конструкторы по умолчанию для баз и нестатических членов этого класса. Если это удовлетворяет требованиям конструктора &lt;a href=&quot;constexpr&quot;&gt;constexpr&lt;/a&gt; , сгенерированный конструктор будет &lt;code&gt;constexpr&lt;/code&gt; . ( Начиная с C ++ 11).</target>
        </trans-unit>
        <trans-unit id="c350045eebab9392561937d25bdc83283a8bc2b6" translate="yes" xml:space="preserve">
          <source>If the implicitly-declared move assignment operator is neither deleted nor trivial, it is defined (that is, a function body is generated and compiled) by the compiler if &lt;a href=&quot;definition#ODR-use&quot;&gt;odr-used&lt;/a&gt;.</source>
          <target state="translated">Если неявно объявленный оператор присваивания перемещения не является ни удаленным, ни тривиальным, он определяется (то есть тело функции генерируется и компилируется) компилятором, если &lt;a href=&quot;definition#ODR-use&quot;&gt;используется odr&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ceab06f5631ee2653c87921d9ff9e756382351b1" translate="yes" xml:space="preserve">
          <source>If the implicitly-declared move constructor is neither deleted nor trivial, it is defined (that is, a function body is generated and compiled) by the compiler if &lt;a href=&quot;definition#ODR-use&quot;&gt;odr-used&lt;/a&gt;. For &lt;code&gt;union&lt;/code&gt; types, the implicitly-defined move constructor copies the object representation (as by &lt;code&gt;&lt;a href=&quot;../string/byte/memmove&quot;&gt;std::memmove&lt;/a&gt;&lt;/code&gt;). For non-union class types (&lt;code&gt;class&lt;/code&gt; and &lt;code&gt;struct&lt;/code&gt;), the move constructor performs full member-wise move of the object's bases and non-static members, in their initialization order, using direct initialization with an &lt;a href=&quot;value_category#xvalue&quot;&gt;xvalue&lt;/a&gt; argument. If this satisfies the requirements of a &lt;a href=&quot;constexpr&quot;&gt;constexpr constructor&lt;/a&gt;, the generated move constructor is &lt;code&gt;constexpr&lt;/code&gt;.</source>
          <target state="translated">Если неявно объявленный конструктор перемещения ни удален, ни тривиален, он определяется (то есть тело функции генерируется и компилируется) компилятором, если &lt;a href=&quot;definition#ODR-use&quot;&gt;используется odr&lt;/a&gt; . Для типов &lt;code&gt;union&lt;/code&gt; неявно определенный конструктор перемещения копирует представление объекта (как с помощью &lt;code&gt;&lt;a href=&quot;../string/byte/memmove&quot;&gt;std::memmove&lt;/a&gt;&lt;/code&gt; ). Для не относящихся к объединению типов классов ( &lt;code&gt;class&lt;/code&gt; и &lt;code&gt;struct&lt;/code&gt; ) конструктор перемещения выполняет полное перемещение элементов и нестатических элементов объекта в порядке их инициализации с использованием прямой инициализации с аргументом &lt;a href=&quot;value_category#xvalue&quot;&gt;xvalue&lt;/a&gt; . Если это удовлетворяет требованиям конструктора &lt;a href=&quot;constexpr&quot;&gt;constexpr&lt;/a&gt; , сгенерированный конструктор перемещения является &lt;code&gt;constexpr&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4b006776f232a7b6fc30d9aed9df44514f27ef73" translate="yes" xml:space="preserve">
          <source>If the initialization &lt;a href=&quot;throw&quot;&gt;throws an exception&lt;/a&gt;, the variable is not considered to be initialized, and initialization will be attempted again the next time control passes through the declaration.</source>
          <target state="translated">Если при инициализации &lt;a href=&quot;throw&quot;&gt;возникает исключение&lt;/a&gt; , переменная не считается инициализированной, и при следующей передаче управления через объявление будет предпринята попытка инициализации.</target>
        </trans-unit>
        <trans-unit id="70a7998feab60665e9807c4931559d1fd72d7fb4" translate="yes" xml:space="preserve">
          <source>If the initialization of a non-inline variable(since C++17) is deferred to happen after the first statement of main/thread function, it happens before the first &lt;a href=&quot;definition#ODR-use&quot;&gt;odr-use&lt;/a&gt; of any variable with static/thread storage duration defined in the same translation unit as the variable to be initialized. If no variable or function is odr-used from a given translation unit, the non-local variables defined in that translation unit may never be initialized (this models the behavior of an on-demand dynamic library). However, as long as anything from a translation unit is odr-used, all non-local variables whose initialization or destruction has side effects will be initialized even if they are not used in the program.</source>
          <target state="translated">Если инициализация не встроенной переменной (начиная с C ++ 17) откладывается на выполнение после первого оператора функции main / thread, это происходит до первого &lt;a href=&quot;definition#ODR-use&quot;&gt;использования odr&lt;/a&gt; любой переменной со статическим / потоковым временем хранения, определенным в та же единица перевода, что и для инициализируемой переменной. Если ни одна переменная или функция не используется odr из данного модуля перевода, нелокальные переменные, определенные в этом модуле перевода, могут никогда не инициализироваться (это моделирует поведение динамической библиотеки по требованию). Однако, пока что-либо из модуля перевода используется odr, все нелокальные переменные, инициализация или уничтожение которых имеет побочные эффекты, будут инициализироваться, даже если они не используются в программе.</target>
        </trans-unit>
        <trans-unit id="3f6bf015004432f99da972ebcadb65c84565ae76" translate="yes" xml:space="preserve">
          <source>If the initialization of a non-local variable with static or thread storage duration exits via an exception, &lt;code&gt;&lt;a href=&quot;../error/terminate&quot;&gt;std::terminate&lt;/a&gt;&lt;/code&gt; is called.</source>
          <target state="translated">Если инициализация нелокальной переменной со статической или потоковой продолжительностью хранения завершается через исключение, вызывается &lt;code&gt;&lt;a href=&quot;../error/terminate&quot;&gt;std::terminate&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1b11a1c3896d9b7ae4903a89c0351942d3a51b04" translate="yes" xml:space="preserve">
          <source>If the initialization of an inline variable is deferred, it happens before the first &lt;a href=&quot;definition#ODR-use&quot;&gt;odr-use&lt;/a&gt; of that specific variable.</source>
          <target state="translated">Если инициализация встроенной переменной откладывается, это происходит до первого &lt;a href=&quot;definition#ODR-use&quot;&gt;использования&lt;/a&gt; этой конкретной переменной.</target>
        </trans-unit>
        <trans-unit id="126551b23f54c215a6bae6f1387512974293e25e" translate="yes" xml:space="preserve">
          <source>If the initialization recursively enters the block in which the variable is being initialized, the behavior is undefined.</source>
          <target state="translated">Если инициализация рекурсивно входит в блок,в котором инициализируется переменная,поведение не определено.</target>
        </trans-unit>
        <trans-unit id="b698184c8fc9c6ca4e1b58ee7ce5abecef65b881" translate="yes" xml:space="preserve">
          <source>If the initializer (range_expression) is a braced-init-list, __range is deduced to be &lt;code&gt;std::initializer_list&amp;lt;&amp;gt;&amp;amp;&amp;amp;&lt;/code&gt;</source>
          <target state="translated">Если инициализатор (range_expression) является списком фигурных скобок-инициализации, __range определяется как &lt;code&gt;std::initializer_list&amp;lt;&amp;gt;&amp;amp;&amp;amp;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2f9de00dbbb1064006866fc50c910f17dedcc3df" translate="yes" xml:space="preserve">
          <source>If the initializer clause is a nested braced-init-list (which is not an expression), the corresponding array element/class member/public base(since C++17) is &lt;a href=&quot;list_initialization&quot;&gt;list-initialized&lt;/a&gt; from that clause: aggregate initialization is recursive.</source>
          <target state="translated">Если предложение initializer представляет собой вложенный фигурный список инициализации (который не является выражением), соответствующий элемент массива / член класса / открытая база (начиная с C ++ 17) &lt;a href=&quot;list_initialization&quot;&gt;инициализируется списком&lt;/a&gt; из этого предложения: агрегатная инициализация является рекурсивной.</target>
        </trans-unit>
        <trans-unit id="263c85b919faedf2707a9f0cb930d424e5361608" translate="yes" xml:space="preserve">
          <source>If the initializer clause is an expression, implicit conversions are allowed as per copy-initialization, except, for &lt;a href=&quot;list_initialization&quot;&gt;list-initialization&lt;/a&gt; form, narrowing conversions are prohibited(since C++11).</source>
          <target state="translated">Если предложение initializer является выражением, неявные преобразования разрешены согласно инициализации копирования, за исключением формы &lt;a href=&quot;list_initialization&quot;&gt;инициализации списка&lt;/a&gt; , сужающие преобразования запрещены (начиная с C ++ 11).</target>
        </trans-unit>
        <trans-unit id="9e522fac274022ad05f5205f4ec4d76c0dff7b8d" translate="yes" xml:space="preserve">
          <source>If the initializer is a braced-init-list &lt;code&gt;{&lt;/code&gt;arg1, arg2, ...&lt;code&gt;} &lt;/code&gt;, rules of &lt;a href=&quot;list_initialization&quot;&gt;list initialization&lt;/a&gt; are followed.</source>
          <target state="translated">Если инициализатор представляет собой фигурный список инициализации &lt;code&gt;{&lt;/code&gt; arg1, arg2, ... &lt;code&gt;} &lt;/code&gt; , соблюдаются правила &lt;a href=&quot;list_initialization&quot;&gt;инициализации списка&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="17a801942e1f9c93f9b22088a58723039bdb9b3e" translate="yes" xml:space="preserve">
          <source>If the initializer list is empty and &lt;code&gt;T&lt;/code&gt; has a default constructor, phase 1 is skipped.</source>
          <target state="translated">Если список инициализаторов пуст и &lt;code&gt;T&lt;/code&gt; имеет конструктор по умолчанию, фаза 1 пропускается.</target>
        </trans-unit>
        <trans-unit id="3e6d2d2dc08cc044669732b9dbb39c02db128762" translate="yes" xml:space="preserve">
          <source>If the initializer list is empty, the values of &lt;a href=&quot;begin&quot;&gt;&lt;code&gt;begin()&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;end()&lt;/code&gt; are unspecified, but will be identical.</source>
          <target state="translated">Если список инициализаторов пуст, значения &lt;a href=&quot;begin&quot;&gt; &lt;code&gt;begin()&lt;/code&gt; &lt;/a&gt; и &lt;code&gt;end()&lt;/code&gt; не определены, но будут идентичны.</target>
        </trans-unit>
        <trans-unit id="e4201a6a146ed0efc5a6cfe2c7d212a524559429" translate="yes" xml:space="preserve">
          <source>If the initializer list is empty, the values of &lt;code&gt;begin()&lt;/code&gt; and &lt;a href=&quot;end&quot;&gt;&lt;code&gt;end()&lt;/code&gt;&lt;/a&gt; are unspecified, but will be identical.</source>
          <target state="translated">Если список инициализаторов пуст, значения &lt;code&gt;begin()&lt;/code&gt; и &lt;a href=&quot;end&quot;&gt; &lt;code&gt;end()&lt;/code&gt; &lt;/a&gt; не определены, но будут идентичны.</target>
        </trans-unit>
        <trans-unit id="d6346069140ef89aa4a40fbb67316690947509e3" translate="yes" xml:space="preserve">
          <source>If the input has been parsed into preprocessing tokens up to a given character, the next preprocessing token is generally taken to be the longest sequence of characters that could constitute a preprocessing token, even if that would cause subsequent analysis to fail. This is commonly known as</source>
          <target state="translated">Если вход был разобран на маркеры препроцессирования до заданного символа,то следующей маркерой препроцессирования обычно считается самая длинная последовательность символов,которая может составлять маркер препроцессирования,даже если это приведет к тому,что последующий анализ окажется неудачным.Это широко известно как</target>
        </trans-unit>
        <trans-unit id="15db5ceb85ecf11c1bb40aa49fe97037e6943c70" translate="yes" xml:space="preserve">
          <source>If the input iterator &lt;code&gt;beg&lt;/code&gt; becomes equal to &lt;code&gt;end&lt;/code&gt; before the parsing was completed, sets both &lt;code&gt;failbit&lt;/code&gt; and &lt;code&gt;eofbit&lt;/code&gt; in &lt;code&gt;err&lt;/code&gt;. If parsing fails for another reason, sets the &lt;code&gt;failbit&lt;/code&gt; in &lt;code&gt;err&lt;/code&gt;. Either way, does not modify the output parameter ((&lt;code&gt;units&lt;/code&gt; or &lt;code&gt;digits&lt;/code&gt;) on error.</source>
          <target state="translated">Если входной итератор &lt;code&gt;beg&lt;/code&gt; становится равным &lt;code&gt;end&lt;/code&gt; до того , как синтаксический анализ был завершен, устанавливает как &lt;code&gt;failbit&lt;/code&gt; и &lt;code&gt;eofbit&lt;/code&gt; в &lt;code&gt;err&lt;/code&gt; . Если синтаксический анализ завершается неудачно по другой причине, устанавливает &lt;code&gt;failbit&lt;/code&gt; в &lt;code&gt;err&lt;/code&gt; . В любом случае, не изменяет выходной параметр (( &lt;code&gt;units&lt;/code&gt; или &lt;code&gt;digits&lt;/code&gt; ) при ошибке.</target>
        </trans-unit>
        <trans-unit id="32e7c4b65d1f3ec9ebd0ad90287093fbb310dbce" translate="yes" xml:space="preserve">
          <source>If the input sequence has a read position available (&lt;code&gt;gptr() &amp;lt; egptr()&lt;/code&gt;, returns &lt;code&gt;(unsigned char)(*gptr())&lt;/code&gt;.</source>
          <target state="translated">Если входная последовательность имеет доступную позицию чтения ( &lt;code&gt;gptr() &amp;lt; egptr()&lt;/code&gt; , возвращает &lt;code&gt;(unsigned char)(*gptr())&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="45b2d15e0da710723c3cf60d16eb11250968276f" translate="yes" xml:space="preserve">
          <source>If the input sequence read position is not available, returns &lt;code&gt;&lt;a href=&quot;uflow&quot;&gt;uflow()&lt;/a&gt;&lt;/code&gt;. Otherwise returns &lt;code&gt;Traits::to_int_type(*gptr())&lt;/code&gt;.</source>
          <target state="translated">Если позиция чтения входной последовательности недоступна, возвращает &lt;code&gt;&lt;a href=&quot;uflow&quot;&gt;uflow()&lt;/a&gt;&lt;/code&gt; . В противном случае возвращает &lt;code&gt;Traits::to_int_type(*gptr())&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6f43632fd3506c566c7659b87242e4ba36c845b6" translate="yes" xml:space="preserve">
          <source>If the input sequence read position is not available, returns &lt;code&gt;&lt;a href=&quot;underflow&quot;&gt;underflow()&lt;/a&gt;&lt;/code&gt;. Otherwise returns &lt;code&gt;Traits::to_int_type(*gptr())&lt;/code&gt;.</source>
          <target state="translated">Если позиция чтения входной последовательности недоступна, возвращает &lt;code&gt;&lt;a href=&quot;underflow&quot;&gt;underflow()&lt;/a&gt;&lt;/code&gt; . В противном случае возвращает &lt;code&gt;Traits::to_int_type(*gptr())&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a9116078f703a37d13100bfaf8b9930ee23b4bdb" translate="yes" xml:space="preserve">
          <source>If the insertion failed because the element already exists, returns an iterator to the already existing element with the equivalent key.</source>
          <target state="translated">Если вставка не удалась из-за того,что элемент уже существует,возвращает итератор к уже существующему элементу с эквивалентным ключом.</target>
        </trans-unit>
        <trans-unit id="a9fe612f9ce2e8b253c5cf483a66190457dfe15b" translate="yes" xml:space="preserve">
          <source>If the iterator holds a zero-length match and &lt;code&gt;start == end&lt;/code&gt;, &lt;code&gt;*this&lt;/code&gt; is set to end-of-sequence iterator and the function returns.</source>
          <target state="translated">Если итератор содержит совпадение нулевой длины и &lt;code&gt;start == end&lt;/code&gt; , &lt;code&gt;*this&lt;/code&gt; устанавливается на итератор конца последовательности, и функция возвращается.</target>
        </trans-unit>
        <trans-unit id="00ebb2aeeb1edae6ae85a26d3e1931e1626d24a9" translate="yes" xml:space="preserve">
          <source>If the lambda definition uses an explicit template parameter list, that template parameter list is used with &lt;code&gt;operator()&lt;/code&gt;. For every parameter in params whose type is specified as &lt;code&gt;auto&lt;/code&gt;, an additional invented template parameter is appended to the end of that template parameter list:</source>
          <target state="translated">Если лямбда-определение использует явный список параметров шаблона, этот список параметров шаблона используется с &lt;code&gt;operator()&lt;/code&gt; . Для каждого параметра в параметрах, тип которого указан как &lt;code&gt;auto&lt;/code&gt; , в конец этого списка параметров шаблона добавляется дополнительный изобретенный параметр шаблона:</target>
        </trans-unit>
        <trans-unit id="c2e82d8a32eeab86a4c1f4f5bce0d91e5af9b994" translate="yes" xml:space="preserve">
          <source>If the lambda-expression captures anything by copy (either implicitly with capture clause &lt;code&gt;[=]&lt;/code&gt; or explicitly with a capture that does not include the character &amp;amp;, e.g. &lt;code&gt;[a, b, c]&lt;/code&gt;), the closure type includes unnamed non-static data members, declared in unspecified order, that hold copies of all entities that were so captured.</source>
          <target state="translated">Если лямбда-выражение захватывает что-либо с помощью копии (либо неявно с предложением захвата &lt;code&gt;[=]&lt;/code&gt; , либо явно с захватом, который не включает символ &amp;amp;, например, &lt;code&gt;[a, b, c]&lt;/code&gt; ), тип замыкания включает неназванные нестатические данные члены, объявленные в неуказанном порядке, которые хранят копии всех сущностей, которые были захвачены.</target>
        </trans-unit>
        <trans-unit id="fd29e44a99211fd550448d9553f6ae1ad92b1445" translate="yes" xml:space="preserve">
          <source>If the last modification time is cached in this &lt;code&gt;directory_entry&lt;/code&gt;, returns the cached value. Otherwise, returns &lt;code&gt;std::filesystem::last_write_time(path())&lt;/code&gt; or &lt;code&gt;std::filesystem::last_write_time(path(), ec)&lt;/code&gt;, respectively.</source>
          <target state="translated">Если время последнего изменения кэшируется в этом &lt;code&gt;directory_entry&lt;/code&gt; , возвращает кэшированное значение. В противном случае возвращает &lt;code&gt;std::filesystem::last_write_time(path())&lt;/code&gt; или &lt;code&gt;std::filesystem::last_write_time(path(), ec)&lt;/code&gt; соответственно.</target>
        </trans-unit>
        <trans-unit id="7b9eab5ed5a441c8e5830c92fe0f6282d0707a87" translate="yes" xml:space="preserve">
          <source>If the left and the right operands identify overlapping objects, the behavior is undefined (unless the overlap is exact and the type is the same).</source>
          <target state="translated">Если левый и правый операнды идентифицируют перекрывающиеся объекты,поведение не определено (если только перекрытие не является точным и тип одинаковым).</target>
        </trans-unit>
        <trans-unit id="fa424ec54e9e85e6bf53212ac1a5db2c477f5b29" translate="yes" xml:space="preserve">
          <source>If the length specifier &lt;code&gt;l&lt;/code&gt; is not used, the conversion specifiers &lt;code&gt;c&lt;/code&gt;, &lt;code&gt;s&lt;/code&gt;, and &lt;code&gt;[&lt;/code&gt; perform wide-to-multibyte character conversion as if by calling &lt;a href=&quot;../../string/multibyte/wcrtomb&quot;&gt;&lt;code&gt;wcrtomb()&lt;/code&gt;&lt;/a&gt; with an &lt;a href=&quot;../../string/multibyte/mbstate_t&quot;&gt;&lt;code&gt;mbstate_t&lt;/code&gt;&lt;/a&gt; object initialized to zero before the first character is converted.</source>
          <target state="translated">Если спецификатор длины &lt;code&gt;l&lt;/code&gt; не используется, спецификаторы преобразования &lt;code&gt;c&lt;/code&gt; , &lt;code&gt;s&lt;/code&gt; и &lt;code&gt;[&lt;/code&gt; выполняют преобразование широких в многобайтовые символы, как если бы они &lt;a href=&quot;../../string/multibyte/wcrtomb&quot;&gt; &lt;code&gt;wcrtomb()&lt;/code&gt; &lt;/a&gt; с объектом &lt;a href=&quot;../../string/multibyte/mbstate_t&quot;&gt; &lt;code&gt;mbstate_t&lt;/code&gt; ,&lt;/a&gt; инициализированным в ноль перед преобразованием первого символа.</target>
        </trans-unit>
        <trans-unit id="4854bc47bd09d34dbcbd17a9720f9b303f9e3fb1" translate="yes" xml:space="preserve">
          <source>If the literal operator is a template, it must have an empty parameter list and can have only one template parameter, which must be a non-type template parameter pack with element type &lt;code&gt;char&lt;/code&gt; (in which case it is known as a</source>
          <target state="translated">Если литеральный оператор является шаблоном, он должен иметь пустой список параметров и может иметь только один параметр шаблона, который должен быть пакетом параметров нетипичного шаблона с типом элемента &lt;code&gt;char&lt;/code&gt; (в этом случае он известен как</target>
        </trans-unit>
        <trans-unit id="fa1825d8cb36d3fdb7a1cdb0411663647de38a09" translate="yes" xml:space="preserve">
          <source>If the lock is &lt;code&gt;&lt;a href=&quot;unique_lock&quot;&gt;std::unique_lock&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;condition_variable&quot;&gt;std::condition_variable&lt;/a&gt;&lt;/code&gt; may provide better performance.</source>
          <target state="translated">Если блокировка &lt;code&gt;&lt;a href=&quot;unique_lock&quot;&gt;std::unique_lock&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;condition_variable&quot;&gt;std::condition_variable&lt;/a&gt;&lt;/code&gt; может обеспечить лучшую производительность.</target>
        </trans-unit>
        <trans-unit id="2072cff7e155c80603cea5b9b2279dd4d08fd38c" translate="yes" xml:space="preserve">
          <source>If the lookup of a member of current instantiation gives a different result between the point of instantiation and the point of definition, the lookup is ambiguous. Note however that when a member name is used, it is not automatically converted to a class member access expression, only explicit member access expressions indicate members of current instantiation:</source>
          <target state="translated">Если поиск члена текущей инстанциии дает другой результат между точкой инстанцирования и точкой определения,то поиск неоднозначен.Обратите внимание,однако,что при использовании имени члена,оно не преобразуется автоматически в выражение доступа члена класса,только явные выражения доступа члена указывают на члены текущей инстанциии:</target>
        </trans-unit>
        <trans-unit id="01f377ce674649640d133ed5cc78ca704a3b02f5" translate="yes" xml:space="preserve">
          <source>If the lookup of the left hand side name comes up with a class/struct or union name, the name on the right hand side of &lt;code&gt;::&lt;/code&gt; is looked up in the scope of that class (and so may find a declaration of a member of that class or of its base), with the following exceptions.</source>
          <target state="translated">Если при поиске левой части имени появляется имя класса / структуры или объединения, имя в правой части &lt;code&gt;::&lt;/code&gt; ищется в области действия этого класса (и поэтому может найти объявление члена этот класс или его базы), со следующими исключениями.</target>
        </trans-unit>
        <trans-unit id="d37b88b9ada3dd332af605d1fd3e5a8cf0eb71e3" translate="yes" xml:space="preserve">
          <source>If the lookup of the left-hand side name comes up with an &lt;a href=&quot;enum&quot;&gt;enumeration&lt;/a&gt; (either scoped or unscoped), the lookup of the right-hand side must result in an enumerator that belongs that enumeration, otherwise the program is ill-formed.</source>
          <target state="translated">Если при поиске имени в левой части появляется &lt;a href=&quot;enum&quot;&gt;перечисление&lt;/a&gt; (с областью или без него), поиск с правой стороны должен привести к перечислителю, который принадлежит этому перечислению, в противном случае программа некорректна.</target>
        </trans-unit>
        <trans-unit id="1c84f7f76196e3d1858123032bdb6f7a708a9edc" translate="yes" xml:space="preserve">
          <source>If the main function is defined with a &lt;a href=&quot;function-try-block&quot;&gt;function-try-block&lt;/a&gt;, the exceptions thrown by the destructors of static objects (which are destroyed by the implied &lt;code&gt;&lt;a href=&quot;../utility/program/exit&quot;&gt;std::exit&lt;/a&gt;&lt;/code&gt;) are not caught by it.</source>
          <target state="translated">Если основная функция определена с помощью &lt;a href=&quot;function-try-block&quot;&gt;функции-try-block&lt;/a&gt; , то исключения, создаваемые деструкторами статических объектов (которые уничтожаются подразумеваемым &lt;code&gt;&lt;a href=&quot;../utility/program/exit&quot;&gt;std::exit&lt;/a&gt;&lt;/code&gt; ), им не перехватываются.</target>
        </trans-unit>
        <trans-unit id="3e06f91c09b7d51a80ad502bd1ebea399586e472" translate="yes" xml:space="preserve">
          <source>If the match does not exist:</source>
          <target state="translated">Если матча не существует:</target>
        </trans-unit>
        <trans-unit id="7e82db05b3b86f89f14289a124a974cfc8812bd1" translate="yes" xml:space="preserve">
          <source>If the match exists:</source>
          <target state="translated">Если совпадение существует:</target>
        </trans-unit>
        <trans-unit id="4183569bf1256905bbaf650046e97c16dae9e0cc" translate="yes" xml:space="preserve">
          <source>If the meaning of a</source>
          <target state="translated">Если смысл</target>
        </trans-unit>
        <trans-unit id="e85a366ebfca22ae74e5b65314e65c8d7039ce9f" translate="yes" xml:space="preserve">
          <source>If the minus sign was part of the input sequence, the numeric value calculated from the sequence of digits is negated as if by &lt;a href=&quot;../../language/operator_arithmetic#Unary_arithmetic_operators&quot;&gt;unary minus&lt;/a&gt; in the result type, which applies unsigned integer wraparound rules.</source>
          <target state="translated">Если знак минус был частью входной последовательности, числовое значение, вычисленное из последовательности цифр, отменяется, как если бы оно было &lt;a href=&quot;../../language/operator_arithmetic#Unary_arithmetic_operators&quot;&gt;одинарным минусом&lt;/a&gt; в типе результата, который применяет правила целочисленного округления без знака.</target>
        </trans-unit>
        <trans-unit id="9ec415c505d275361f5e319da3ba14be0e8e4bd1" translate="yes" xml:space="preserve">
          <source>If the minus sign was part of the input sequence, the numeric value calculated from the sequence of digits is negated as if by &lt;a href=&quot;../../language/operator_arithmetic#Unary_arithmetic_operators&quot;&gt;unary minus&lt;/a&gt; in the result type.</source>
          <target state="translated">Если знак минус был частью входной последовательности, числовое значение, вычисленное из последовательности цифр, сводится как бы к &lt;a href=&quot;../../language/operator_arithmetic#Unary_arithmetic_operators&quot;&gt;унарному минусу&lt;/a&gt; в типе результата.</target>
        </trans-unit>
        <trans-unit id="5755fdc9594791908fc98437469bea77cb6e1fd5" translate="yes" xml:space="preserve">
          <source>If the most recent match was not a zero-length match, the operator sets &lt;code&gt;flags&lt;/code&gt; to &lt;code&gt;flags | regex_constants::match_prev_avail&lt;/code&gt; and invokes the following:</source>
          <target state="translated">Если последнее совпадение не было совпадением нулевой длины, оператор устанавливает &lt;code&gt;flags&lt;/code&gt; в &lt;code&gt;flags | regex_constants::match_prev_avail&lt;/code&gt; и вызывает следующее:</target>
        </trans-unit>
        <trans-unit id="d96faf371e54d959541ad721b9a13b1a3685ad32" translate="yes" xml:space="preserve">
          <source>If the most recently called function, out of &lt;code&gt;&lt;a href=&quot;../basic_streambuf/underflow&quot;&gt;underflow()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../basic_streambuf/overflow&quot;&gt;overflow()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../basic_streambuf/pubseekpos&quot;&gt;seekpos()&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;../basic_streambuf/pubseekoff&quot;&gt;seekoff()&lt;/a&gt;&lt;/code&gt;, was &lt;code&gt;&lt;a href=&quot;../basic_streambuf/overflow&quot;&gt;overflow()&lt;/a&gt;&lt;/code&gt;, then calls &lt;code&gt;std::codecvt::unshift()&lt;/code&gt;, perhaps multiple times, to determine the unshift sequence according to the imbued locale, and writes that sequence to file with &lt;code&gt;overflow(Traits::eof())&lt;/code&gt;.</source>
          <target state="translated">Если последней вызванной функцией из &lt;code&gt;&lt;a href=&quot;../basic_streambuf/underflow&quot;&gt;underflow()&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../basic_streambuf/overflow&quot;&gt;overflow()&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../basic_streambuf/pubseekpos&quot;&gt;seekpos()&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;../basic_streambuf/pubseekoff&quot;&gt;seekoff()&lt;/a&gt;&lt;/code&gt; была &lt;code&gt;&lt;a href=&quot;../basic_streambuf/overflow&quot;&gt;overflow()&lt;/a&gt;&lt;/code&gt; , то вызывается &lt;code&gt;std::codecvt::unshift()&lt;/code&gt; , возможно, несколько раз, чтобы определить unshift последовательность в соответствии с пропущенным языком и записывает эту последовательность в файл с &lt;code&gt;overflow(Traits::eof())&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="90491130497fa2fc6497b24640b7ae73bc68aa73" translate="yes" xml:space="preserve">
          <source>If the multibyte character encoding is state-dependent (&lt;a href=&quot;../../locale/codecvt/encoding&quot;&gt;&lt;code&gt;codecvt::encoding()&lt;/code&gt;&lt;/a&gt; returned &lt;code&gt;-1&lt;/code&gt;) or variable-length (&lt;code&gt;codecvt::encoding()&lt;/code&gt; returned &lt;code&gt;​0​&lt;/code&gt;) and the offset &lt;code&gt;off&lt;/code&gt; is not &lt;code&gt;​0​&lt;/code&gt;, fails immediately: this function cannot determine the number of bytes that correspond to &lt;code&gt;off&lt;/code&gt; characters.</source>
          <target state="translated">Если кодирование многобайтовой символ зависящий от состояния ( &lt;a href=&quot;../../locale/codecvt/encoding&quot;&gt; &lt;code&gt;codecvt::encoding()&lt;/code&gt; &lt;/a&gt; возвращается &lt;code&gt;-1&lt;/code&gt; ) или переменной длиной ( &lt;code&gt;codecvt::encoding()&lt;/code&gt; возвращается &lt;code&gt;​0​&lt;/code&gt; ) и смещение &lt;code&gt;off&lt;/code&gt; не &lt;code&gt;​0​&lt;/code&gt; , терпит неудачу сразу: это Функция не может определить количество байтов, которые соответствуют &lt;code&gt;off&lt;/code&gt; символам.</target>
        </trans-unit>
        <trans-unit id="312e4e4f74f5b82f6bd25b87461c9b4fbde989e6" translate="yes" xml:space="preserve">
          <source>If the multibyte character in &lt;code&gt;*s&lt;/code&gt; corresponds to a multi-char16_t sequence (e.g. a surrogate pair in UTF-16), then after the first call to this function, &lt;code&gt;*ps&lt;/code&gt; is updated in such a way that the next call to &lt;code&gt;mbrtoc16&lt;/code&gt; will write out the additional char16_t, without considering &lt;code&gt;*s&lt;/code&gt;.</source>
          <target state="translated">Если многобайтовый символ в &lt;code&gt;*s&lt;/code&gt; соответствует последовательности multi-char16_t (например, суррогатная пара в UTF-16), то после первого вызова этой функции &lt;code&gt;*ps&lt;/code&gt; обновляется таким образом, что следующий вызов &lt;code&gt;mbrtoc16&lt;/code&gt; будет записывать из дополнительного char16_t без учета &lt;code&gt;*s&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bcb6afe2a5acb943ad2fdd6f475921c6ce71ebf8" translate="yes" xml:space="preserve">
          <source>If the multibyte character in &lt;code&gt;*s&lt;/code&gt; corresponds to a multi-char32_t sequence (not possible with UTF-32), then after the first call to this function, &lt;code&gt;*ps&lt;/code&gt; is updated in such a way that the next calls to &lt;code&gt;mbrtoc32&lt;/code&gt; will write out the additional char32_t, without considering &lt;code&gt;*s&lt;/code&gt;.</source>
          <target state="translated">Если многобайтовый символ в &lt;code&gt;*s&lt;/code&gt; соответствует последовательности multi-char32_t (это невозможно с UTF-32), то после первого вызова этой функции &lt;code&gt;*ps&lt;/code&gt; обновляется таким образом, что при следующих вызовах &lt;code&gt;mbrtoc32&lt;/code&gt; будут записаны дополнительный char32_t, без учета &lt;code&gt;*s&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="baf70aa7bd1cf40829d0398b1fa87e9dc92941f8" translate="yes" xml:space="preserve">
          <source>If the mutex is already locked by this &lt;code&gt;std::unique_lock&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../../error/system_error&quot;&gt;std::system_error&lt;/a&gt;&lt;/code&gt; with an error code of &lt;code&gt;&lt;a href=&quot;../../error/errc&quot;&gt;std::errc::resource_deadlock_would_occur&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">Если мьютекс уже заблокирован этим &lt;code&gt;std::unique_lock&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../../error/system_error&quot;&gt;std::system_error&lt;/a&gt;&lt;/code&gt; с кодом ошибки &lt;code&gt;&lt;a href=&quot;../../error/errc&quot;&gt;std::errc::resource_deadlock_would_occur&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="26a0b8cab69da9fd4564dd153dc7e72537daded3" translate="yes" xml:space="preserve">
          <source>If the mutex is already locked by this &lt;code&gt;unique_lock&lt;/code&gt; (in other words, &lt;a href=&quot;owns_lock&quot;&gt;owns_lock&lt;/a&gt; is true), &lt;code&gt;&lt;a href=&quot;../../error/system_error&quot;&gt;std::system_error&lt;/a&gt;&lt;/code&gt; with an error code of &lt;code&gt;&lt;a href=&quot;../../error/errc&quot;&gt;std::errc::resource_deadlock_would_occur&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">Если мьютекс уже заблокирован этим &lt;code&gt;unique_lock&lt;/code&gt; (другими словами, &lt;a href=&quot;owns_lock&quot;&gt;owns_lock&lt;/a&gt; имеет значение true), &lt;code&gt;&lt;a href=&quot;../../error/system_error&quot;&gt;std::system_error&lt;/a&gt;&lt;/code&gt; с кодом ошибки &lt;code&gt;&lt;a href=&quot;../../error/errc&quot;&gt;std::errc::resource_deadlock_would_occur&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="554e21c6a83788b53dc332bdeec20b2bc45e361b" translate="yes" xml:space="preserve">
          <source>If the mutex is already locked, &lt;code&gt;&lt;a href=&quot;../../error/system_error&quot;&gt;std::system_error&lt;/a&gt;&lt;/code&gt; with an error code of &lt;code&gt;&lt;a href=&quot;../../error/errc&quot;&gt;std::errc::resource_deadlock_would_occur&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">Если мьютекс уже заблокирован, &lt;code&gt;&lt;a href=&quot;../../error/system_error&quot;&gt;std::system_error&lt;/a&gt;&lt;/code&gt; с кодом ошибки &lt;code&gt;&lt;a href=&quot;../../error/errc&quot;&gt;std::errc::resource_deadlock_would_occur&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e5f5c7e5fb56183cbccedca22001e62c7b4f9e65" translate="yes" xml:space="preserve">
          <source>If the name appears immediately to the right of the scope resolution operator &lt;code&gt;::&lt;/code&gt; or possibly after &lt;code&gt;::&lt;/code&gt; followed by the disambiguating keyword &lt;code&gt;template&lt;/code&gt;, see.</source>
          <target state="translated">Если имя появляется сразу справа от оператора разрешения области действия &lt;code&gt;::&lt;/code&gt; или, возможно, после &lt;code&gt;::&lt;/code&gt; , за которым следует &lt;code&gt;template&lt;/code&gt; неоднозначного ключевого слова , см.</target>
        </trans-unit>
        <trans-unit id="12c49bf8d3ab86a8d2eba4533e6f3ce9e54beb97" translate="yes" xml:space="preserve">
          <source>If the name lookup does not find a previously declared type name, the elaborated-type-specifier is introduced by &lt;code&gt;class&lt;/code&gt;, &lt;code&gt;struct&lt;/code&gt;, or &lt;code&gt;union&lt;/code&gt; (i.e. not by &lt;code&gt;enum&lt;/code&gt;), and class-name is an unqualified identifier, then the elaborated-type-specifier is a class declaration of the class-name.</source>
          <target state="translated">Если поиск имени не находит ранее объявленное имя типа, разработанный спецификатор типа вводится &lt;code&gt;class&lt;/code&gt; , &lt;code&gt;struct&lt;/code&gt; или &lt;code&gt;union&lt;/code&gt; (то есть не &lt;code&gt;enum&lt;/code&gt; ), а имя класса является неквалифицированным идентификатором, тогда разработанный тип-типа Спецификатор является объявлением класса имени класса.</target>
        </trans-unit>
        <trans-unit id="680aaf5d39f0524608d21769dd7093d5030e0ccf" translate="yes" xml:space="preserve">
          <source>If the name of the class itself appears as class-or-identifier in the member initializer list, then the list must consist of that one member initializer only; such constructor is known as the</source>
          <target state="translated">Если имя самого класса в списке инициализатора-членов появляется как имя класса или идентификатора,то список должен состоять только из этого одного инициализатора-членов;такой конструктор известен как</target>
        </trans-unit>
        <trans-unit id="b15648eb5df5f87645e8346a354b1f3da3971a94" translate="yes" xml:space="preserve">
          <source>If the name on the left of &lt;code&gt;::&lt;/code&gt; refers to a namespace or if there is nothing on the left of &lt;code&gt;::&lt;/code&gt; (in which case it refers to the global namespace), the name that appears on the right hand side of &lt;code&gt;::&lt;/code&gt; is looked up in the scope of that namespace, except that.</source>
          <target state="translated">Если имя в левой части &lt;code&gt;::&lt;/code&gt; относится к пространству имен , или если нет ничего на левый &lt;code&gt;::&lt;/code&gt; (в этом случае оно относится к глобальному пространству имен), имя , которое на правой стороне появится &lt;code&gt;::&lt;/code&gt; ищутся в области этого пространства имен, кроме этого.</target>
        </trans-unit>
        <trans-unit id="351414d67b6211a3be33d9c5a18059ec3fe49dc4" translate="yes" xml:space="preserve">
          <source>If the name refers to a &lt;a href=&quot;typedef&quot;&gt;typedef name&lt;/a&gt;, a &lt;a href=&quot;type_alias&quot;&gt;type alias&lt;/a&gt;, a &lt;a href=&quot;template_parameters#Type_template_parameter&quot;&gt;template type parameter&lt;/a&gt;, or an &lt;a href=&quot;type_alias&quot;&gt;alias template specialization&lt;/a&gt;, the program is ill-formed, otherwise the elaborated type specifier introduces the name into the declaration the same way a &lt;a href=&quot;declarations#Specifiers&quot;&gt;simple type specifier&lt;/a&gt; introduces its type-name.</source>
          <target state="translated">Если имя относится к &lt;a href=&quot;typedef&quot;&gt;имени ЬурейеГо&lt;/a&gt; , &lt;a href=&quot;type_alias&quot;&gt;типа псевдоним&lt;/a&gt; , &lt;a href=&quot;template_parameters#Type_template_parameter&quot;&gt;параметр типа шаблона&lt;/a&gt; , или &lt;a href=&quot;type_alias&quot;&gt;шаблон псевдонима специализация&lt;/a&gt; , программа плохо формируется, иначе развернутый спецификатор типа вводит имя в декларацию же образом &lt;a href=&quot;declarations#Specifiers&quot;&gt;спецификатор простого типа&lt;/a&gt; вводит его тип-имя.</target>
        </trans-unit>
        <trans-unit id="7bf4ac13d848aeaa14204e7424d717fa7118c92d" translate="yes" xml:space="preserve">
          <source>If the names of two parameter packs appear in the same pattern, they are expanded simultaneously, and they must have the same length:</source>
          <target state="translated">Если имена двух пакетов параметров появляются на одной и той же детали,то они расширяются одновременно и должны иметь одинаковую длину:</target>
        </trans-unit>
        <trans-unit id="a2b281f14bc994fec6ff8448c81b41b3e5d1e437" translate="yes" xml:space="preserve">
          <source>If the nearest enclosing function declarator is not the declarator of a function definition, its potential scope ends at the end of that function declarator.</source>
          <target state="translated">Если ближайший декларатор ограждающей функции не является декларатором определения функции,то его потенциальная область действия заканчивается в конце декларатора этой функции.</target>
        </trans-unit>
        <trans-unit id="b5670784086b76d24bb1fae4d2445942134f26af" translate="yes" xml:space="preserve">
          <source>If the new &lt;code&gt;&lt;a href=&quot;size&quot;&gt;size()&lt;/a&gt;&lt;/code&gt; is greater than &lt;code&gt;&lt;a href=&quot;capacity&quot;&gt;capacity()&lt;/a&gt;&lt;/code&gt; then all iterators and references (including the past-the-end iterator) are invalidated. Otherwise only the past-the-end iterator is invalidated.</source>
          <target state="translated">Если новый &lt;code&gt;&lt;a href=&quot;size&quot;&gt;size()&lt;/a&gt;&lt;/code&gt; больше &lt;code&gt;&lt;a href=&quot;capacity&quot;&gt;capacity()&lt;/a&gt;&lt;/code&gt; то все итераторы и ссылки (включая итератор конца-в-конце) становятся недействительными. В противном случае только последний итератор становится недействительным.</target>
        </trans-unit>
        <trans-unit id="cf94debed8cd7dc4895c7d2f2f99ed8c3d0eef6f" translate="yes" xml:space="preserve">
          <source>If the new &lt;code&gt;&lt;a href=&quot;size&quot;&gt;size()&lt;/a&gt;&lt;/code&gt; is greater than &lt;code&gt;&lt;a href=&quot;capacity&quot;&gt;capacity()&lt;/a&gt;&lt;/code&gt;, all iterators and references are invalidated. Otherwise, only the iterators and references before the insertion point remain valid. The past-the-end iterator is also invalidated.</source>
          <target state="translated">Если новый &lt;code&gt;&lt;a href=&quot;size&quot;&gt;size()&lt;/a&gt;&lt;/code&gt; больше &lt;code&gt;&lt;a href=&quot;capacity&quot;&gt;capacity()&lt;/a&gt;&lt;/code&gt; , все итераторы и ссылки становятся недействительными. Иначе, только итераторы и ссылки перед точкой вставки остаются действительными. Последний итератор также становится недействительным.</target>
        </trans-unit>
        <trans-unit id="7ea2ea05865b3c53570d6c768a8336b0fce606d3" translate="yes" xml:space="preserve">
          <source>If the new size is bigger than the old one : all iterators are invalidated</source>
          <target state="translated">Если новый размер больше старого:все итераторы недействительны.</target>
        </trans-unit>
        <trans-unit id="92c6212e4fbc62d508c776cafe31778487d050cd" translate="yes" xml:space="preserve">
          <source>If the new size is smaller than the old one : only erased elements and the past-the-end iterator</source>
          <target state="translated">Если новый размер меньше старого:только стертые элементы и итератор прошлого-конца</target>
        </trans-unit>
        <trans-unit id="b4edb10d6256f62d87a1b6332196a1e63e973276" translate="yes" xml:space="preserve">
          <source>If the next character begins a sequence of characters that could be the prefix and initial double quote of a &lt;a href=&quot;string_literal&quot;&gt;raw string literal&lt;/a&gt;, the next preprocessing token shall be a raw string literal. The literal consists of the shortest sequence of characters that matches the raw-string pattern.</source>
          <target state="translated">Если следующий символ начинает последовательность символов, которые могут быть префиксом и начальной двойной кавычкой &lt;a href=&quot;string_literal&quot;&gt;необработанного строкового литерала&lt;/a&gt; , следующий токен предварительной обработки должен быть необработанным строковым литералом. Литерал состоит из самой короткой последовательности символов, которая соответствует шаблону необработанной строки.</target>
        </trans-unit>
        <trans-unit id="d33bd7b55fb01fe98f2f3acadf5f6a08379b3852" translate="yes" xml:space="preserve">
          <source>If the next pointer for the put area (&lt;code&gt;&lt;a href=&quot;../basic_streambuf/pptr&quot;&gt;std::streambuf::pptr()&lt;/a&gt;&lt;/code&gt;) is a null pointer, returns zero.</source>
          <target state="translated">Если следующий указатель для области размещения ( &lt;code&gt;&lt;a href=&quot;../basic_streambuf/pptr&quot;&gt;std::streambuf::pptr()&lt;/a&gt;&lt;/code&gt; ) является нулевым указателем, возвращается ноль.</target>
        </trans-unit>
        <trans-unit id="f2a3a5f033565b87ab609d62fb110b1186e8e3e4" translate="yes" xml:space="preserve">
          <source>If the next pointer is greater than the beginning pointer in a get area, a</source>
          <target state="translated">Если следующий указатель больше,чем начальный указатель в области get,a</target>
        </trans-unit>
        <trans-unit id="c38cc8ddc7ddabb28e42f0dfb6f798c707698933" translate="yes" xml:space="preserve">
          <source>If the next pointer is less than the end pointer in the get area, a</source>
          <target state="translated">Если следующий указатель меньше,чем конечный указатель в области get,a</target>
        </trans-unit>
        <trans-unit id="c4b8d1b94f24bba646631c4092b8de8ae27a04b9" translate="yes" xml:space="preserve">
          <source>If the next pointer is less than the end pointer in the put area, a</source>
          <target state="translated">Если следующий указатель меньше,чем конечный указатель в области ввода,a</target>
        </trans-unit>
        <trans-unit id="9a69438e54d280f6f9ab5d647f4340372fb34e64" translate="yes" xml:space="preserve">
          <source>If the next three characters are &lt;code&gt;&amp;lt;::&lt;/code&gt; and the subsequent character is neither &lt;code&gt;:&lt;/code&gt; nor &lt;code&gt;&amp;gt;&lt;/code&gt;, the &lt;code&gt;&amp;lt;&lt;/code&gt; is treated as a preprocessing token by itself (and not as the first character of the &lt;a href=&quot;operator_alternative&quot;&gt;alternative token&lt;/a&gt;&lt;code&gt;&amp;lt;:&lt;/code&gt;).</source>
          <target state="translated">Если следующие три символа - &lt;code&gt;&amp;lt;::&lt;/code&gt; , а последующий символ - ни &lt;code&gt;:&lt;/code&gt; , ни &lt;code&gt;&amp;gt;&lt;/code&gt; , символ &lt;code&gt;&amp;lt;&lt;/code&gt; обрабатывается как токен предварительной обработки (а не как первый символ &lt;a href=&quot;operator_alternative&quot;&gt;альтернативного токена &lt;/a&gt; &lt;code&gt;&amp;lt;:&lt;/code&gt; :) .</target>
        </trans-unit>
        <trans-unit id="af14e08b4fe197ba9df3e02d9b9e83c72cf7dc83" translate="yes" xml:space="preserve">
          <source>If the number of characters generated for the specified format is less than the value returned by &lt;code&gt;str.width()&lt;/code&gt;, then copies of &lt;code&gt;fill&lt;/code&gt; are inserted to bring the total length of the output sequence to exactly &lt;code&gt;str.width()&lt;/code&gt;, as follows:</source>
          <target state="translated">Если количество символов, сгенерированных для указанного формата, меньше значения, возвращаемого &lt;code&gt;str.width()&lt;/code&gt; , то вставляются копии &lt;code&gt;fill&lt;/code&gt; , чтобы привести общую длину выходной последовательности к точности &lt;code&gt;str.width()&lt;/code&gt; , следующим образом:</target>
        </trans-unit>
        <trans-unit id="f0d99c831c2d187591fcd3895e3191880ca06c5c" translate="yes" xml:space="preserve">
          <source>If the number of hard links is cached in this &lt;code&gt;directory_entry&lt;/code&gt;, returns the cached value. Otherwise, returns &lt;code&gt;std::filesystem::hard_link_count(path())&lt;/code&gt; or &lt;code&gt;std::filesystem::hard_link_count(path(), ec)&lt;/code&gt;, respectively.</source>
          <target state="translated">Если количество жестких ссылок кэшируется в этом &lt;code&gt;directory_entry&lt;/code&gt; , возвращает кэшированное значение. В противном случае возвращает &lt;code&gt;std::filesystem::hard_link_count(path())&lt;/code&gt; или &lt;code&gt;std::filesystem::hard_link_count(path(), ec)&lt;/code&gt; соответственно.</target>
        </trans-unit>
        <trans-unit id="b99a05a29894a68183df39a196889aa25aa975f9" translate="yes" xml:space="preserve">
          <source>If the number of initializer clauses exceeds the number of members and bases(since C++17) to initialize, the program is ill-formed.</source>
          <target state="translated">Если количество пунктов инициализатора превышает количество членов и баз (начиная с С++17)для инициализации,то программа плохо сформирована.</target>
        </trans-unit>
        <trans-unit id="b81ad8faee1ff23ba51f5fbba00473611ac8e7b6" translate="yes" xml:space="preserve">
          <source>If the number of initializer clauses is less than the number of members and bases(since C++17) or initializer list is completely empty, the remaining members and bases(since C++17) are initialized by their &lt;a href=&quot;data_members#Member_initialization&quot;&gt;default member initializers&lt;/a&gt;, if provided in the class definition, and otherwise(since C++14) by empty lists, in accordance with the usual &lt;a href=&quot;list_initialization&quot;&gt;list-initialization&lt;/a&gt; rules (which performs value-initialization for non-class types and non-aggregate classes with default constructors, and aggregate initialization for aggregates). If a member of a reference type is one of these remaining members, the program is ill-formed.</source>
          <target state="translated">Если количество предложений инициализатора меньше количества членов и баз (начиная с C ++ 17) или список инициализаторов полностью пуст, остальные члены и базы (начиная с C ++ 17) инициализируются инициализаторами их &lt;a href=&quot;data_members#Member_initialization&quot;&gt;членов&lt;/a&gt; по умолчанию , если предоставляется в определении класса и, в противном случае (начиная с C ++ 14) пустыми списками, в соответствии с обычными правилами &lt;a href=&quot;list_initialization&quot;&gt;инициализации списков&lt;/a&gt; (которые выполняют инициализацию значений для не классовых типов и неагрегированных классов с конструкторами по умолчанию, а также агрегируют инициализация для агрегатов). Если член ссылочного типа является одним из этих оставшихся членов, программа является некорректной.</target>
        </trans-unit>
        <trans-unit id="bb0f41458b43834e51177c5651bbd7795714a125" translate="yes" xml:space="preserve">
          <source>If the number of initializer clauses is less than the number of members or initializer list is completely empty, the remaining members are &lt;a href=&quot;value_initialization&quot;&gt;value-initialized&lt;/a&gt;. If a member of a reference type is one of these remaining members, the program is ill-formed.</source>
          <target state="translated">Если количество предложений инициализатора меньше, чем количество членов, или список инициализаторов полностью пуст, остальные члены &lt;a href=&quot;value_initialization&quot;&gt;инициализируются значением&lt;/a&gt; . Если член ссылочного типа является одним из этих оставшихся членов, программа является некорректной.</target>
        </trans-unit>
        <trans-unit id="b0ce7ffb5fd666d693981b8165606cef96184b92" translate="yes" xml:space="preserve">
          <source>If the number of variants is larger than 1, the invocation of the callable object has no complexity requirements.</source>
          <target state="translated">Если количество вариантов больше 1,то вызов вызываемого объекта не имеет требований к сложности.</target>
        </trans-unit>
        <trans-unit id="30a909a72a6ffc780941652c5f3605de8c85f27e" translate="yes" xml:space="preserve">
          <source>If the object being deleted has incomplete class type at the point of deletion, and the complete class has a non-trivial destructor or a deallocation function, the behavior is undefined.</source>
          <target state="translated">Если удаляемый объект на момент удаления имеет неполный тип класса,а полный класс имеет нетривиальный деструктор или функцию deallocation,то поведение не определено.</target>
        </trans-unit>
        <trans-unit id="94419747850ceda4ef56a69f80c16b2a13fb641e" translate="yes" xml:space="preserve">
          <source>If the object contains a value and the type &lt;code&gt;T&lt;/code&gt; is not trivially destructible (see &lt;code&gt;&lt;a href=&quot;../../types/is_destructible&quot;&gt;std::is_trivially_destructible&lt;/a&gt;&lt;/code&gt;), destroys the contained value by calling its destructor, as if by &lt;code&gt;value().T::~T()&lt;/code&gt;.</source>
          <target state="translated">Если объект содержит значение, а тип &lt;code&gt;T&lt;/code&gt; не является тривиально разрушаемым (см. &lt;code&gt;&lt;a href=&quot;../../types/is_destructible&quot;&gt;std::is_trivially_destructible&lt;/a&gt;&lt;/code&gt; ), уничтожает содержащееся в нем значение, вызывая его деструктор, как если бы он был равен &lt;code&gt;value().T::~T()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ec70e1f18459a8290a0f4bd35e232554ccfd607b" translate="yes" xml:space="preserve">
          <source>If the object is an array of unknown size, and the supplied brace-enclosed initializer list has &lt;code&gt;n&lt;/code&gt; clauses, the size of the array is &lt;code&gt;n&lt;/code&gt;. (Note that the object in this case cannot be a non-static data member: a member must have complete type.)</source>
          <target state="translated">Если объект является массивом неизвестного размера, и поставляемый в скобках список инициализаторов имеет &lt;code&gt;n&lt;/code&gt; предложений, размер массива равен &lt;code&gt;n&lt;/code&gt; . (Обратите внимание, что объект в этом случае не может быть нестатическим элементом данных: элемент должен иметь полный тип.)</target>
        </trans-unit>
        <trans-unit id="dc925382d2c313f9d5510edd341c98dae666642c" translate="yes" xml:space="preserve">
          <source>If the object pointed to by &lt;code&gt;ptr&lt;/code&gt; is already owned, the function results in undefined behavior.</source>
          <target state="translated">Если объект, на который указывает &lt;code&gt;ptr&lt;/code&gt; , уже принадлежит, функция приводит к неопределенному поведению.</target>
        </trans-unit>
        <trans-unit id="6178c7826636249aa31114e15b28fd10b4ae9c38" translate="yes" xml:space="preserve">
          <source>If the object to which the glvalue refers contains an indeterminate value (such as obtained by &lt;a href=&quot;default_initialization&quot;&gt;default initializing&lt;/a&gt; a non-class automatic variable), the behavior is &lt;a href=&quot;ub&quot;&gt;undefined&lt;/a&gt;.</source>
          <target state="translated">Если объект, на который ссылается glvalue, содержит неопределенное значение (например, полученное по &lt;a href=&quot;default_initialization&quot;&gt;умолчанию при инициализации&lt;/a&gt; неклассовой автоматической переменной), поведение не &lt;a href=&quot;ub&quot;&gt;определено&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="854c163308d68bcd5f11e6e68fac53ee79ca0fa5" translate="yes" xml:space="preserve">
          <source>If the objects are &lt;a href=&quot;../../language/objects#Subobjects&quot;&gt;potentially-overlapping&lt;/a&gt; or not &lt;a href=&quot;../../named_req/triviallycopyable&quot;&gt;TriviallyCopyable&lt;/a&gt;, the behavior of &lt;code&gt;memcpy&lt;/code&gt; is not specified and &lt;a href=&quot;http://stackoverflow.com/questions/29777492&quot;&gt;may be undefined&lt;/a&gt;.</source>
          <target state="translated">Если объекты &lt;a href=&quot;../../language/objects#Subobjects&quot;&gt;потенциально перекрываются&lt;/a&gt; или не &lt;a href=&quot;../../named_req/triviallycopyable&quot;&gt;TriviallyCopyable&lt;/a&gt; , поведение &lt;code&gt;memcpy&lt;/code&gt; не указано и &lt;a href=&quot;http://stackoverflow.com/questions/29777492&quot;&gt;может быть неопределенным&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="43ec58c2abf0222a29b0c8fffc8a48f853af4796" translate="yes" xml:space="preserve">
          <source>If the objects are &lt;a href=&quot;../../language/objects#Subobjects&quot;&gt;potentially-overlapping&lt;/a&gt; or not &lt;a href=&quot;../../named_req/triviallycopyable&quot;&gt;TriviallyCopyable&lt;/a&gt;, the behavior of &lt;code&gt;memmove&lt;/code&gt; is not specified and &lt;a href=&quot;http://stackoverflow.com/questions/29777492&quot;&gt;may be undefined&lt;/a&gt;.</source>
          <target state="translated">Если объекты &lt;a href=&quot;../../language/objects#Subobjects&quot;&gt;потенциально перекрываются&lt;/a&gt; или не &lt;a href=&quot;../../named_req/triviallycopyable&quot;&gt;TriviallyCopyable&lt;/a&gt; , поведение &lt;code&gt;memmove&lt;/code&gt; не определено и &lt;a href=&quot;http://stackoverflow.com/questions/29777492&quot;&gt;может быть неопределенным&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="af231aef821c421dada8c16256fc78ace43c4fd5" translate="yes" xml:space="preserve">
          <source>If the objects are not &lt;a href=&quot;../../named_req/triviallycopyable&quot;&gt;TriviallyCopyable&lt;/a&gt;, the behavior is undefined.</source>
          <target state="translated">Если объекты не &lt;a href=&quot;../../named_req/triviallycopyable&quot;&gt;TriviallyCopyable&lt;/a&gt; , поведение не определено.</target>
        </trans-unit>
        <trans-unit id="7439cc88d3247f96faa2170d824e55add0c21fea" translate="yes" xml:space="preserve">
          <source>If the objects overlap, the behavior is undefined.</source>
          <target state="translated">Если объекты накладываются друг на друга,поведение не определено.</target>
        </trans-unit>
        <trans-unit id="cfd990fe5c8c1f9320d43b19453f94b1906d5b8d" translate="yes" xml:space="preserve">
          <source>If the old locale's encoding is state-dependent and file is not positioned at the beginning, then the new locale must have the same &lt;code&gt;&lt;a href=&quot;../../locale/codecvt&quot;&gt;std::codecvt&lt;/a&gt;&lt;/code&gt; facet as the one previously imbued.</source>
          <target state="translated">Если кодировка старой локали зависит от состояния, а файл не располагается в начале, тогда новая локаль должна иметь тот же фасет &lt;code&gt;&lt;a href=&quot;../../locale/codecvt&quot;&gt;std::codecvt&lt;/a&gt;&lt;/code&gt; что и ранее внедренный .</target>
        </trans-unit>
        <trans-unit id="7518873ec88dce6433b77a202724dd872b5facce" translate="yes" xml:space="preserve">
          <source>If the old pointer was non-empty, deletes the previously managed object &lt;code&gt;if(old_ptr) get_deleter()(old_ptr)&lt;/code&gt;.</source>
          <target state="translated">Если старый указатель был непустым, удаляет ранее управляемый объект &lt;code&gt;if(old_ptr) get_deleter()(old_ptr)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4dd6552f73dd69bf5933722a03efee57f0b98bea" translate="yes" xml:space="preserve">
          <source>If the open operation succeeds and &lt;code&gt;openmode &amp;amp; &lt;a href=&quot;../ios_base/openmode&quot;&gt;std::ios_base::ate&lt;/a&gt; != 0&lt;/code&gt; (the &lt;code&gt;ate&lt;/code&gt; bit is set), repositions the file position to the end of file, as if by calling &lt;code&gt;&lt;a href=&quot;../c/fseek&quot;&gt;std::fseek&lt;/a&gt;(file, 0, &lt;a href=&quot;../c&quot;&gt;SEEK_END&lt;/a&gt;)&lt;/code&gt;, where &lt;code&gt;file&lt;/code&gt; is the pointer returned by calling &lt;code&gt;fopen&lt;/code&gt;. If the repositioning fails, calls &lt;code&gt;&lt;a href=&quot;close&quot;&gt;close()&lt;/a&gt;&lt;/code&gt; and returns a null pointer to indicate failure.</source>
          <target state="translated">Если операция открытия завершается успешно и &lt;code&gt;openmode &amp;amp; &lt;a href=&quot;../ios_base/openmode&quot;&gt;std::ios_base::ate&lt;/a&gt; != 0&lt;/code&gt; ( бит &lt;code&gt;ate&lt;/code&gt; установлен), перемещает позицию файла в конец файла, как если бы вызывал &lt;code&gt;&lt;a href=&quot;../c/fseek&quot;&gt;std::fseek&lt;/a&gt;(file, 0, &lt;a href=&quot;../c&quot;&gt;SEEK_END&lt;/a&gt;)&lt;/code&gt; , где &lt;code&gt;file&lt;/code&gt; - указатель, возвращаемый вызовом &lt;code&gt;fopen&lt;/code&gt; . Если перепозиционирование не удается, вызывает &lt;code&gt;&lt;a href=&quot;close&quot;&gt;close()&lt;/a&gt;&lt;/code&gt; и возвращает нулевой указатель, указывающий на сбой.</target>
        </trans-unit>
        <trans-unit id="1df990f7386ff3f2cc16de12a9e72eb727c483f2" translate="yes" xml:space="preserve">
          <source>If the operand is not &lt;code&gt;bool&lt;/code&gt;, it is converted to &lt;code&gt;bool&lt;/code&gt; using &lt;a href=&quot;implicit_cast&quot;&gt;contextual conversion to bool&lt;/a&gt;: it is only well-formed if the declaration &lt;code&gt;bool t(arg)&lt;/code&gt; is well-formed, for some invented temporary &lt;code&gt;t&lt;/code&gt;.</source>
          <target state="translated">Если операндом не является &lt;code&gt;bool&lt;/code&gt; , он преобразуется в &lt;code&gt;bool&lt;/code&gt; с помощью &lt;a href=&quot;implicit_cast&quot;&gt;контекстного преобразования в bool&lt;/a&gt; : он корректно формируется, только если объявление &lt;code&gt;bool t(arg)&lt;/code&gt; правильно сформировано для некоторого изобретенного временного &lt;code&gt;t&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="910435839383d33c5dc2d8d4ba19e0ed1ca648ae" translate="yes" xml:space="preserve">
          <source>If the operand is the name of an overloaded function, the address may be taken only if the overload can be resolved due to context. See &lt;a href=&quot;overloaded_address&quot;&gt;Address of an overloaded function&lt;/a&gt; for details.</source>
          <target state="translated">Если операндом является имя перегруженной функции, адрес может быть взят только в том случае, если перегрузка может быть разрешена из-за контекста. См. &lt;a href=&quot;overloaded_address&quot;&gt;Адрес перегруженной функции&lt;/a&gt; для деталей.</target>
        </trans-unit>
        <trans-unit id="edcca376b9017a314c5ce3c74e8c8cd913ab1436" translate="yes" xml:space="preserve">
          <source>If the operand of the post-increment operator is of type &lt;code&gt;bool&lt;/code&gt;, it is set to &lt;code&gt;true&lt;/code&gt;(deprecated).(until C++17).</source>
          <target state="translated">Если операнд оператора &lt;code&gt;bool&lt;/code&gt; типа имеет тип bool , ему присваивается значение &lt;code&gt;true&lt;/code&gt; (не рекомендуется) (до C ++ 17).</target>
        </trans-unit>
        <trans-unit id="6058f3bacdd6399a42fe9ae2e370059cb00c4139" translate="yes" xml:space="preserve">
          <source>If the operand of the pre-increment operator is of type &lt;code&gt;bool&lt;/code&gt;, it is set to &lt;code&gt;true&lt;/code&gt;(deprecated).(until C++17).</source>
          <target state="translated">Если операнд оператора предварительного приращения имеет тип &lt;code&gt;bool&lt;/code&gt; , он имеет значение &lt;code&gt;true&lt;/code&gt; (не рекомендуется) (до C ++ 17).</target>
        </trans-unit>
        <trans-unit id="6c5fbbf8cf6f23e69c16207aea6b5866059dd114" translate="yes" xml:space="preserve">
          <source>If the operand passed to an arithmetic operator is integral or unscoped enumeration type, then before any other action (but after lvalue-to-rvalue conversion, if applicable), the operand undergoes &lt;a href=&quot;implicit_cast#Integral_promotion&quot;&gt;integral promotion&lt;/a&gt;. If an operand has array or function type, array-to-pointer and function-to-pointer conversions are applied.</source>
          <target state="translated">Если операнд, переданный арифметическому оператору, является типом перечисления с целым числом или с незаданной областью, то перед любым другим действием (но после преобразования lvalue в rvalue, если применимо), операнд подвергается &lt;a href=&quot;implicit_cast#Integral_promotion&quot;&gt;интегральному продвижению&lt;/a&gt; . Если операнд имеет массив или тип функции, применяются преобразования массива в указатель и функции в указатель.</target>
        </trans-unit>
        <trans-unit id="b2856e7c84ee7bcd9c7d54aff911eeecd1a576e8" translate="yes" xml:space="preserve">
          <source>If the operand to &lt;code&gt;typeid&lt;/code&gt; is a class type or a reference to a class type, then that class type must not be an &lt;a href=&quot;incomplete_type&quot;&gt;incomplete type&lt;/a&gt;.</source>
          <target state="translated">Если операнд &lt;code&gt;typeid&lt;/code&gt; является типом класса или ссылкой на тип класса, то этот тип класса не должен быть &lt;a href=&quot;incomplete_type&quot;&gt;неполным типом&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a6f60e09ec075130d1f28f4c735c3e62c6710a29" translate="yes" xml:space="preserve">
          <source>If the operands has arithmetic or enumeration type (scoped or unscoped),</source>
          <target state="translated">Если операнды имеют арифметический или перечислительный тип (скопированные или не скопированные),</target>
        </trans-unit>
        <trans-unit id="0f10e3bc67559ed7f0001e6e7e37e3c27f4624c6" translate="yes" xml:space="preserve">
          <source>If the operation would result in &lt;code&gt;size() &amp;gt; max_size()&lt;/code&gt;, throws &lt;code&gt;&lt;a href=&quot;../../error/length_error/length_error&quot;&gt;std::length_error&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Если операция приведет к &lt;code&gt;size() &amp;gt; max_size()&lt;/code&gt; , выдает &lt;code&gt;&lt;a href=&quot;../../error/length_error/length_error&quot;&gt;std::length_error&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b217f2aa9381c149a3dabe0b7cf0fe6551f65c06" translate="yes" xml:space="preserve">
          <source>If the options argument was not supplied, returns &lt;code&gt;options::none&lt;/code&gt;.</source>
          <target state="translated">Если аргумент options не был предоставлен, возвращает &lt;code&gt;options::none&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b113388f82173776cc247c5cef46e3268d0b48fb" translate="yes" xml:space="preserve">
          <source>If the orientation of the stream has already been decided (by executing output or by an earlier call to fwide), this function does nothing.</source>
          <target state="translated">Если ориентация потока уже определена (путем выполнения вывода или более раннего вызова fwide),эта функция ничего не делает.</target>
        </trans-unit>
        <trans-unit id="1de522a1c1fdc728580e466d8485c9d4aecac535" translate="yes" xml:space="preserve">
          <source>If the original pointer is pointing to a base class subobject within an object of some polymorphic type, &lt;a href=&quot;dynamic_cast&quot;&gt;dynamic_cast&lt;/a&gt; may be used to obtain a &lt;code&gt;void*&lt;/code&gt; that is pointing at the complete object of the most derived type.</source>
          <target state="translated">Если исходный указатель указывает на подобъект базового класса в объекте некоторого полиморфного типа, &lt;a href=&quot;dynamic_cast&quot;&gt;dynamic_cast&lt;/a&gt; может использоваться для получения &lt;code&gt;void*&lt;/code&gt; , указывающего на законченный объект самого производного типа.</target>
        </trans-unit>
        <trans-unit id="990f3e3a0b5d27b439c43881744b60db8d8b4e06" translate="yes" xml:space="preserve">
          <source>If the output could not be generated, sets &lt;code&gt;failbit&lt;/code&gt;, If exceptions on failbit are enabled in this stream's exception mask, throws &lt;a href=&quot;../io/ios_base/failure&quot;&gt;&lt;code&gt;ios_base::failure&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Если вывод не может быть сгенерирован, устанавливает &lt;code&gt;failbit&lt;/code&gt; , Если в маске исключений этого потока включены исключения на failbit, выдает &lt;a href=&quot;../io/ios_base/failure&quot;&gt; &lt;code&gt;ios_base::failure&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="36e1dfece2770bc2927fb6c9f13e3ae6d4aa3615" translate="yes" xml:space="preserve">
          <source>If the output fails for any reason, sets &lt;code&gt;badbit&lt;/code&gt;.</source>
          <target state="translated">Если вывод по какой-либо причине завершается неудачно, устанавливает &lt;code&gt;badbit&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2b185a676601b8249554276be7b4af45b951241d" translate="yes" xml:space="preserve">
          <source>If the output sequence write position is not available (the buffer is full), then calls &lt;code&gt;overflow(ch)&lt;/code&gt;.</source>
          <target state="translated">Если позиция записи выходной последовательности недоступна (буфер заполнен), то вызывается &lt;code&gt;overflow(ch)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0ddd7375e8e8b7ed3f1d22a6f4f461c76fda6d26" translate="yes" xml:space="preserve">
          <source>If the overload resolution selects a built-in candidate, the &lt;a href=&quot;implicit_cast&quot;&gt;user-defined conversion sequence&lt;/a&gt; from an operand of class type is not allowed to have a second standard conversion sequence: the user-defined conversion function must give the expected operand type directly:</source>
          <target state="translated">Если разрешение перегрузки выбирает встроенного кандидата, определяемая &lt;a href=&quot;implicit_cast&quot;&gt;пользователем последовательность преобразования&lt;/a&gt; из операнда типа класса не может иметь вторую стандартную последовательность преобразования: определяемая пользователем функция преобразования должна непосредственно давать ожидаемый тип операнда:</target>
        </trans-unit>
        <trans-unit id="0339e3bc8e944d80de0d65db76ef29721018ee48" translate="yes" xml:space="preserve">
          <source>If the parameter &lt;code&gt;icase&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, the character class ignores character case, e.g. the regex &lt;code&gt;[:lower:]&lt;/code&gt; with &lt;code&gt;&lt;a href=&quot;../syntax_option_type&quot;&gt;std::regex_constants::icase&lt;/a&gt;&lt;/code&gt; generates a call to &lt;code&gt;regex_traits&amp;lt;&amp;gt;::lookup_classname()&lt;/code&gt; with &lt;code&gt;[first, last)&lt;/code&gt; indicating the string &lt;code&gt;&quot;lower&quot;&lt;/code&gt; and &lt;code&gt;icase == true&lt;/code&gt;. This call returns the same bitmask as the call generated by the regex &lt;code&gt;[:alpha:]&lt;/code&gt; with &lt;code&gt;icase == false&lt;/code&gt;.</source>
          <target state="translated">Если параметр &lt;code&gt;icase&lt;/code&gt; равен &lt;code&gt;true&lt;/code&gt; , класс символов игнорирует регистр символов, например, regex &lt;code&gt;[:lower:]&lt;/code&gt; с &lt;code&gt;&lt;a href=&quot;../syntax_option_type&quot;&gt;std::regex_constants::icase&lt;/a&gt;&lt;/code&gt; генерирует вызов &lt;code&gt;regex_traits&amp;lt;&amp;gt;::lookup_classname()&lt;/code&gt; с &lt;code&gt;[first, last)&lt;/code&gt; указывающим строка &lt;code&gt;&quot;lower&quot;&lt;/code&gt; и &lt;code&gt;icase == true&lt;/code&gt; . Этот вызов возвращает ту же битовую маску, что и вызов, сгенерированный регулярным выражением &lt;code&gt;[:alpha:]&lt;/code&gt; с &lt;code&gt;icase == false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="71a8649df3ecbbada92cdc80a78f0174dc434084" translate="yes" xml:space="preserve">
          <source>If the parameter of the catch-clause is a reference type, any changes made to it are reflected in the exception object, and can be observed by another handler if the exception is rethrown with &lt;code&gt;throw;&lt;/code&gt;. If the parameter is not a reference, any changes made to it are are local and its lifetime ends when the handler exits.</source>
          <target state="translated">Если параметр предложения catch является ссылочным типом, любые внесенные в него изменения отражаются в объекте исключения и могут наблюдаться другим обработчиком, если исключение повторно вызывается с помощью &lt;code&gt;throw;&lt;/code&gt; , Если параметр не является ссылкой, любые изменения, внесенные в него, являются локальными, и его время жизни заканчивается при выходе из обработчика.</target>
        </trans-unit>
        <trans-unit id="6dad0498ed0cf6b6b98d4eaaf808c912c3d3152c" translate="yes" xml:space="preserve">
          <source>If the parameter type is &lt;code&gt;&lt;a href=&quot;../utility/initializer_list&quot;&gt;std::initializer_list&lt;/a&gt;&amp;lt;X&amp;gt;&lt;/code&gt;, and there is an non-narrowing implicit conversion from every element of the initializer list to &lt;code&gt;X&lt;/code&gt;, the implicit conversion sequence for the purpose of overload resolution is the worst conversion necessary. If the braced-init-list is empty, the conversion sequence is the identity conversion.</source>
          <target state="translated">Если тип параметра - &lt;code&gt;&lt;a href=&quot;../utility/initializer_list&quot;&gt;std::initializer_list&lt;/a&gt;&amp;lt;X&amp;gt;&lt;/code&gt; , и существует неявное неявное преобразование из каждого элемента списка инициализатора в &lt;code&gt;X&lt;/code&gt; , последовательность неявного преобразования с целью разрешения перегрузки является худшим необходимым преобразованием. Если список фигурных скобок пуст, последовательность преобразования является преобразованием идентичности.</target>
        </trans-unit>
        <trans-unit id="18426061d489bcb10c6138a5612f8728895a21a5" translate="yes" xml:space="preserve">
          <source>If the parameter type is some aggregate &lt;code&gt;X&lt;/code&gt; and the initializer list consists of exactly one element of same or derived class (possibly cv-qualified), the implicit conversion sequence is the one required to convert the element to the parameter type.</source>
          <target state="translated">Если типом параметра является некоторый агрегат &lt;code&gt;X&lt;/code&gt; , а список инициализаторов состоит ровно из одного элемента того же или производного класса (возможно, cv-квалифицированного), неявная последовательность преобразования - это та, которая требуется для преобразования элемента в тип параметра.</target>
        </trans-unit>
        <trans-unit id="d845ac35c60a3d6398352b7893d2603e6b328c05" translate="yes" xml:space="preserve">
          <source>If the parent directory is outside directory hierarchy that is iterated on (i.e. &lt;code&gt;depth() == 0&lt;/code&gt;), sets &lt;code&gt;*this&lt;/code&gt; to an end directory iterator.</source>
          <target state="translated">Если родительский каталог находится за пределами иерархии каталогов, в которой выполняется итерация (т. Е. &lt;code&gt;depth() == 0&lt;/code&gt; ), для &lt;code&gt;*this&lt;/code&gt; устанавливается конечный итератор каталога.</target>
        </trans-unit>
        <trans-unit id="8f12e10b26c51070735d7546640510f221a4a717" translate="yes" xml:space="preserve">
          <source>If the parsing succeeds, does not change &lt;code&gt;err&lt;/code&gt;, and stores the result in &lt;code&gt;units&lt;/code&gt; or &lt;code&gt;digits&lt;/code&gt;.</source>
          <target state="translated">Если синтаксический успешно, не меняет &lt;code&gt;err&lt;/code&gt; , и сохраняет результат в &lt;code&gt;units&lt;/code&gt; или &lt;code&gt;digits&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="704ea65740c7ae23e0fe2ae321dd1d4cee11f634" translate="yes" xml:space="preserve">
          <source>If the part of the regular expression that matched is just an &lt;a href=&quot;http://en.cppreference.com/w/cpp/regex/ecmascript#Assertions&quot;&gt;assertion&lt;/a&gt; (&lt;code&gt;^&lt;/code&gt;, &lt;code&gt;$&lt;/code&gt;, &lt;code&gt;\b&lt;/code&gt;, &lt;code&gt;\B&lt;/code&gt;), the match stored in the iterator is a zero-length match, that is, &lt;code&gt;match[0].first == match[0].second&lt;/code&gt;.</source>
          <target state="translated">Если совпадающая часть регулярного выражения является просто &lt;a href=&quot;http://en.cppreference.com/w/cpp/regex/ecmascript#Assertions&quot;&gt;утверждением&lt;/a&gt; ( &lt;code&gt;^&lt;/code&gt; , &lt;code&gt;$&lt;/code&gt; , &lt;code&gt;\b&lt;/code&gt; , &lt;code&gt;\B&lt;/code&gt; ), совпадение, сохраненное в итераторе, является совпадением нулевой длины, то есть &lt;code&gt;match[0].first == match[0].second&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a2ebed057a709d5166451a5bb4fdfc9d04cff29d" translate="yes" xml:space="preserve">
          <source>If the path &lt;code&gt;p&lt;/code&gt; refers to a symbolic link, returns a new path object which refers to the target of that symbolic link.</source>
          <target state="translated">Если путь &lt;code&gt;p&lt;/code&gt; ссылается на символическую ссылку, возвращает новый объект пути, который ссылается на цель этой символической ссылки.</target>
        </trans-unit>
        <trans-unit id="a5a2ee3308db767e5626b5d282347713ca3b32db" translate="yes" xml:space="preserve">
          <source>If the pathname is either &lt;code&gt;.&lt;/code&gt; or &lt;code&gt;..&lt;/code&gt;, or if &lt;a href=&quot;filename&quot;&gt;&lt;code&gt;filename()&lt;/code&gt;&lt;/a&gt; does not contain the &lt;code&gt;.&lt;/code&gt; character, then empty path is returned.</source>
          <target state="translated">Если путь либо &lt;code&gt;.&lt;/code&gt; или &lt;code&gt;..&lt;/code&gt; , или если &lt;a href=&quot;filename&quot;&gt; &lt;code&gt;filename()&lt;/code&gt; &lt;/a&gt; не содержит &lt;code&gt;.&lt;/code&gt; символ, затем возвращается пустой путь.</target>
        </trans-unit>
        <trans-unit id="422fd574496432a86171fe46fb0d9e0b579301d4" translate="yes" xml:space="preserve">
          <source>If the pattern ([pat_first, pat_last)) is empty, returns &lt;code&gt;make_pair(first, first)&lt;/code&gt;.</source>
          <target state="translated">Если шаблон ([pat_first, pat_last)) пуст, возвращает &lt;code&gt;make_pair(first, first)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="70f9539cc95e6db66dffafbd8aa72c5758b90e7b" translate="yes" xml:space="preserve">
          <source>If the pattern was matched, but the parsed value is not in the range representable by the type of &lt;code&gt;value&lt;/code&gt;, returns value of type &lt;code&gt;from_chars_result&lt;/code&gt; such that &lt;code&gt;ec&lt;/code&gt; equals &lt;code&gt;&lt;a href=&quot;../error/errc&quot;&gt;std::errc::result_out_of_range&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;ptr&lt;/code&gt; points at the first character not matching the pattern. &lt;code&gt;value&lt;/code&gt; is unmodified.</source>
          <target state="translated">Если шаблон был сопоставлен, но проанализированное значение не находится в диапазоне, представляемом типом &lt;code&gt;value&lt;/code&gt; , возвращает значение типа &lt;code&gt;from_chars_result&lt;/code&gt; , такое что &lt;code&gt;ec&lt;/code&gt; равно &lt;code&gt;&lt;a href=&quot;../error/errc&quot;&gt;std::errc::result_out_of_range&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;ptr&lt;/code&gt; указывает на первый символ, не соответствующий шаблону. &lt;code&gt;value&lt;/code&gt; не изменяется.</target>
        </trans-unit>
        <trans-unit id="0a87d6d2f05d467c7b59a0780f341a0df12fb06a" translate="yes" xml:space="preserve">
          <source>If the placeholder type specifier is &lt;code&gt;auto&lt;/code&gt;or type-constraint&lt;code&gt;auto&lt;/code&gt;(since C++20), the variable type is deduced from the initializer using the rules for &lt;a href=&quot;template_argument_deduction&quot;&gt;template argument deduction&lt;/a&gt; from a function call (see &lt;a href=&quot;template_argument_deduction#Other_contexts&quot;&gt;template argument deduction#Other contexts&lt;/a&gt; for details).</source>
          <target state="translated">Если спецификатор типа заполнителя имеет значение &lt;code&gt;auto&lt;/code&gt; или &lt;code&gt;auto&lt;/code&gt; с ограничением типа (начиная с C ++ 20), тип переменной выводится из инициализатора с использованием правил для &lt;a href=&quot;template_argument_deduction&quot;&gt;выведения аргументов шаблона&lt;/a&gt; из вызова функции (подробности см. В разделе &lt;a href=&quot;template_argument_deduction#Other_contexts&quot;&gt;Вывод аргумента шаблона # Другие контексты&lt;/a&gt; ). ,</target>
        </trans-unit>
        <trans-unit id="2276b641f558192e6893ac9cc30b93561ac6a1e7" translate="yes" xml:space="preserve">
          <source>If the placeholder type specifier is &lt;code&gt;decltype(auto)&lt;/code&gt;or type-constraint&lt;code&gt;decltype(auto)&lt;/code&gt;(since C++20), the deduced type is &lt;code&gt;decltype(e)&lt;/code&gt;, where &lt;code&gt;e&lt;/code&gt; is the initializer.</source>
          <target state="translated">Если указатель типа заполнителя имеет тип &lt;code&gt;decltype(auto)&lt;/code&gt; или ограничение типа по типу &lt;code&gt;decltype(auto)&lt;/code&gt; (начиная с C ++ 20), выводимый тип - это &lt;code&gt;decltype(e)&lt;/code&gt; , где &lt;code&gt;e&lt;/code&gt; - инициализатор.</target>
        </trans-unit>
        <trans-unit id="ac0eb770b354dc56dd2f5ee40b48df9887d2f9d4" translate="yes" xml:space="preserve">
          <source>If the placeholder type specifier is used to declare multiple variables, the deduced types must match. For example, the declaration &lt;code&gt;auto i = 0, d = 0.0;&lt;/code&gt; is ill-formed, while the declaration &lt;code&gt;auto i = 0, *p = &amp;amp;i;&lt;/code&gt; is well-formed and the &lt;code&gt;auto&lt;/code&gt; is deduced as &lt;code&gt;int&lt;/code&gt;.</source>
          <target state="translated">Если спецификатор типа заполнителя используется для объявления нескольких переменных, выведенные типы должны совпадать. Например, объявление &lt;code&gt;auto i = 0, d = 0.0;&lt;/code&gt; неправильно сформирован, в то время как объявление &lt;code&gt;auto i = 0, *p = &amp;amp;i;&lt;/code&gt; является правильно сформированным, и &lt;code&gt;auto&lt;/code&gt; выводится как &lt;code&gt;int&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="05226f11d77b34f54e805ec7153e749dfb3f47a5" translate="yes" xml:space="preserve">
          <source>If the platform uses mixed endian, &lt;code&gt;std::endian::native&lt;/code&gt; does not equal either &lt;code&gt;std::endian::big&lt;/code&gt; nor &lt;code&gt;std::endian::little&lt;/code&gt;</source>
          <target state="translated">Если платформа использует смешанный метод endian, &lt;code&gt;std::endian::native&lt;/code&gt; не равен ни &lt;code&gt;std::endian::big&lt;/code&gt; ни &lt;code&gt;std::endian::little&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="12d037e01ff534df66a9b8a862a8773089ded879" translate="yes" xml:space="preserve">
          <source>If the pointer (either &lt;code&gt;gptr&lt;/code&gt; or &lt;code&gt;pptr&lt;/code&gt; or both) is repositioned, it is done as follows:</source>
          <target state="translated">Если указатель (или &lt;code&gt;gptr&lt;/code&gt; , или &lt;code&gt;pptr&lt;/code&gt; , или оба) перемещен, это делается следующим образом:</target>
        </trans-unit>
        <trans-unit id="28cec222b90e62fa53ecba18ed8db910c7df5ecd" translate="yes" xml:space="preserve">
          <source>If the pointer &lt;code&gt;P&lt;/code&gt; points to the &lt;code&gt;i&lt;/code&gt;th element of an array, and the pointer &lt;code&gt;Q&lt;/code&gt; points at the &lt;code&gt;j&lt;/code&gt;th element of the same array, the expression &lt;code&gt;P-Q&lt;/code&gt; has the value &lt;code&gt;i-j&lt;/code&gt;, if the value fits in &lt;code&gt;&lt;a href=&quot;../types/ptrdiff_t&quot;&gt;std::ptrdiff_t&lt;/a&gt;&lt;/code&gt;. Both operands must point to the elements of the same array (or one past the end), otherwise the behavior is undefined. If the result does not fit in &lt;code&gt;&lt;a href=&quot;../types/ptrdiff_t&quot;&gt;std::ptrdiff_t&lt;/a&gt;&lt;/code&gt;, the behavior is undefined.</source>
          <target state="translated">Если указатель &lt;code&gt;P&lt;/code&gt; указывает на &lt;code&gt;i&lt;/code&gt; - й элемент массива, а указатель &lt;code&gt;Q&lt;/code&gt; указывает на &lt;code&gt;j&lt;/code&gt; - й элемент того же массива, выражение &lt;code&gt;P-Q&lt;/code&gt; имеет значение &lt;code&gt;i-j&lt;/code&gt; , если значение соответствует &lt;code&gt;&lt;a href=&quot;../types/ptrdiff_t&quot;&gt;std::ptrdiff_t&lt;/a&gt;&lt;/code&gt; . Оба операнда должны указывать на элементы одного и того же массива (или один после конца), в противном случае поведение не определено. Если результат не помещается в &lt;code&gt;&lt;a href=&quot;../types/ptrdiff_t&quot;&gt;std::ptrdiff_t&lt;/a&gt;&lt;/code&gt; , поведение не определено.</target>
        </trans-unit>
        <trans-unit id="2c3af6cf6b2fece3bf06d95f3b15704d049a2a68" translate="yes" xml:space="preserve">
          <source>If the pointer &lt;code&gt;P&lt;/code&gt; points to the &lt;code&gt;i&lt;/code&gt;th element of an array, then the expressions &lt;code&gt;P+n&lt;/code&gt;, &lt;code&gt;n+P&lt;/code&gt;, and &lt;code&gt;P-n&lt;/code&gt; are pointers of the same type that point to the &lt;code&gt;i+n&lt;/code&gt;th, &lt;code&gt;i+n&lt;/code&gt;th, and &lt;code&gt;i-n&lt;/code&gt;th element of the same array, respectively. The result of pointer addition may also be a one-past-the-end pointer (that is, pointer &lt;code&gt;P&lt;/code&gt; such that the expression &lt;code&gt;P-1&lt;/code&gt; points to the last element of the array). Any other situations (that is, attempts to generate a pointer that isn't pointing at an element of the same array or one past the end) invoke undefined behavior.</source>
          <target state="translated">Если указатель &lt;code&gt;P&lt;/code&gt; указывает на &lt;code&gt;i&lt;/code&gt; - й элемент массива, то выражение &lt;code&gt;P+n&lt;/code&gt; , &lt;code&gt;n+P&lt;/code&gt; , и &lt;code&gt;P-n&lt;/code&gt; являются указателями одного и того же типа , что указывает на &lt;code&gt;i+n&lt;/code&gt; - е, &lt;code&gt;i+n&lt;/code&gt; - й и &lt;code&gt;i-n&lt;/code&gt; й элемент того же массива, соответственно. Результатом добавления указателя также может быть указатель &amp;laquo;один за другим&amp;raquo; (то есть указатель &lt;code&gt;P&lt;/code&gt; , такой что выражение &lt;code&gt;P-1&lt;/code&gt; указывает на последний элемент массива). Любые другие ситуации (то есть попытки создать указатель, который не указывает на элемент того же массива или один за концом) вызывают неопределенное поведение.</target>
        </trans-unit>
        <trans-unit id="0ca8d499f0d01575fddc904d502c2ba50ea7a28f" translate="yes" xml:space="preserve">
          <source>If the pointer is advanced and then &lt;code&gt;&lt;a href=&quot;overflow&quot;&gt;overflow()&lt;/a&gt;&lt;/code&gt; is called to flush the put area to the associated character sequence, the effect is that extra &lt;code&gt;count&lt;/code&gt; characters with undefined values are output.</source>
          <target state="translated">Если указатель является расширенным, а затем вызывается метод &lt;code&gt;&lt;a href=&quot;overflow&quot;&gt;overflow()&lt;/a&gt;&lt;/code&gt; чтобы очистить область вставки от связанной последовательности символов, в результате выдается дополнительное &lt;code&gt;count&lt;/code&gt; символов с неопределенными значениями.</target>
        </trans-unit>
        <trans-unit id="e450bd3f7a3a2237b2e10ff661bc465b1471234b" translate="yes" xml:space="preserve">
          <source>If the pointers stored in &lt;code&gt;pword&lt;/code&gt; require management, &lt;code&gt;&lt;a href=&quot;register_callback&quot;&gt;register_callback()&lt;/a&gt;&lt;/code&gt; may be used to install handlers that execute deep copy or deallocation as needed.</source>
          <target state="translated">Если указатели, хранящиеся в &lt;code&gt;pword&lt;/code&gt; , требуют управления, &lt;code&gt;&lt;a href=&quot;register_callback&quot;&gt;register_callback()&lt;/a&gt;&lt;/code&gt; может использоваться для установки обработчиков, которые выполняют глубокое копирование или освобождение по мере необходимости.</target>
        </trans-unit>
        <trans-unit id="16ee378b87cd08352666411c9cd09d7998ae045a" translate="yes" xml:space="preserve">
          <source>If the pool selected for a block of size &lt;code&gt;bytes&lt;/code&gt; is unable to satisfy the request from its internal data structures, calls &lt;code&gt;allocate()&lt;/code&gt; on the upstream memory resource to obtain memory.</source>
          <target state="translated">Если пул, выбранный для блока &lt;code&gt;bytes&lt;/code&gt; размера, не может удовлетворить запрос от своих внутренних структур данных, вызывает метод &lt;code&gt;allocate()&lt;/code&gt; для восходящего ресурса памяти, чтобы получить память.</target>
        </trans-unit>
        <trans-unit id="9eafb34d20e4bdd821ef599345cd0d19bc68a4ab" translate="yes" xml:space="preserve">
          <source>If the precision of the input cannot be exactly represented with seconds, then the format is a decimal floating point number with a fixed format and a precision matching that of the precision of the input (or to a microseconds precision if the conversion to floating point decimal seconds cannot be made within 18 fractional digits). The character for the decimal point is localized according to the locale.</source>
          <target state="translated">Если точность ввода не может быть точно представлена секундами,то формат представляет собой десятичное число с плавающей точкой с фиксированным форматом и точностью,соответствующей точности ввода (или с точностью до микросекунд,если преобразование в десятичные секунды с плавающей точкой не может быть произведено с точностью до 18 дробных цифр).Символ для десятичной запятой локализован в соответствии с локалью.</target>
        </trans-unit>
        <trans-unit id="556a0df3f2ed8a7cac546a84886519ac3ebeac8f" translate="yes" xml:space="preserve">
          <source>If the previous stage does not produce a match, all constructors of &lt;code&gt;T&lt;/code&gt; participate in &lt;a href=&quot;overload_resolution#Implicit_conversion_sequence_in_list-initialization&quot;&gt;overload resolution&lt;/a&gt; against the set of arguments that consists of the elements of the braced-init-list, with the restriction that only non-narrowing conversions are allowed. If this stage produces an explicit constructor as the best match for a copy-list-initialization, compilation fails (note, in simple copy-initialization, explicit constructors are not considered at all).</source>
          <target state="translated">Если предыдущий этап не приводит к совпадению, все конструкторы &lt;code&gt;T&lt;/code&gt; участвуют в &lt;a href=&quot;overload_resolution#Implicit_conversion_sequence_in_list-initialization&quot;&gt;разрешении перегрузки&lt;/a&gt; для набора аргументов, который состоит из элементов braced-init-list, с ограничением, что разрешены только не сужающие преобразования. Если на этом этапе создается явный конструктор как наилучшее совпадение для инициализации списка копирования, компиляция завершается неудачно (обратите внимание, что при простой инициализации копирования явные конструкторы вообще не рассматриваются).</target>
        </trans-unit>
        <trans-unit id="7cc06dc92cb043df323fc3aa474cf3ba56bb3c97" translate="yes" xml:space="preserve">
          <source>If the primary member template is explicitly (fully) specialized for a given (implicit) specialization of the enclosing class template, the partial specializations of the member template are ignored for this specialization of the enclosing class template.</source>
          <target state="translated">Если шаблон первичного члена явно (полностью)специализирован для заданной (неявной)специализации шаблона класса-поставщика,частичные специализации шаблона-поставщика игнорируются для этой специализации шаблона класса-поставщика.</target>
        </trans-unit>
        <trans-unit id="adfd306bbffa0b23164cbb3f7616b73a92779a42" translate="yes" xml:space="preserve">
          <source>If the primary template has a exception specification that isn't &lt;code&gt;noexcept(false)&lt;/code&gt;, the explicit specializations must have a compatible exception specification.</source>
          <target state="translated">Если основной шаблон имеет спецификацию исключений, которая не является &lt;code&gt;noexcept(false)&lt;/code&gt; , у явных специализаций должна быть совместимая спецификация исключений.</target>
        </trans-unit>
        <trans-unit id="a27f2e5bb1066b5ba8ecb5c6e80fdaaed8988b08" translate="yes" xml:space="preserve">
          <source>If the program closes the file, e.g. by executing &lt;code&gt;&lt;a href=&quot;fclose&quot;&gt;std::fclose&lt;/a&gt;&lt;/code&gt;, the file is automatically deleted.</source>
          <target state="translated">Если программа закрывает файл, например, путем выполнения &lt;code&gt;&lt;a href=&quot;fclose&quot;&gt;std::fclose&lt;/a&gt;&lt;/code&gt; , файл автоматически удаляется.</target>
        </trans-unit>
        <trans-unit id="f054e6c94ddb2b1d1ab37e865dadbaa42672443f" translate="yes" xml:space="preserve">
          <source>If the program terminates abnormally, it is implementation-defined if these temporary files are deleted.</source>
          <target state="translated">Если программа прекращает работу аномально,то при удалении этих временных файлов определяется ее реализация.</target>
        </trans-unit>
        <trans-unit id="2165d06ea6d2bb20531c9f3d3cebc5362167aa09" translate="yes" xml:space="preserve">
          <source>If the program terminates normally (by calling &lt;code&gt;&lt;a href=&quot;../../utility/program/exit&quot;&gt;std::exit&lt;/a&gt;&lt;/code&gt;, returning from &lt;code&gt;main&lt;/code&gt;, etc), all files that were opened by calling &lt;code&gt;std::tmpfile&lt;/code&gt; are also automatically deleted.</source>
          <target state="translated">Если программа завершается нормально (путем вызова &lt;code&gt;&lt;a href=&quot;../../utility/program/exit&quot;&gt;std::exit&lt;/a&gt;&lt;/code&gt; , возврата из &lt;code&gt;main&lt;/code&gt; и т. Д.), Все файлы, которые были открыты путем вызова &lt;code&gt;std::tmpfile&lt;/code&gt; , также автоматически удаляются.</target>
        </trans-unit>
        <trans-unit id="c4563d58386ce90b83da2edbf6c91576f3250457" translate="yes" xml:space="preserve">
          <source>If the put area becomes full (&lt;code&gt;pptr() == epptr()&lt;/code&gt;), this function may call &lt;code&gt;&lt;a href=&quot;overflow&quot;&gt;overflow()&lt;/a&gt;&lt;/code&gt;, or achieve the effect of calling &lt;code&gt;overflow()&lt;/code&gt; by some other, unspecified, means.</source>
          <target state="translated">Если область размещения становится заполненной ( &lt;code&gt;pptr() == epptr()&lt;/code&gt; ), эта функция может вызвать &lt;code&gt;&lt;a href=&quot;overflow&quot;&gt;overflow()&lt;/a&gt;&lt;/code&gt; или достичь эффекта вызова &lt;code&gt;overflow()&lt;/code&gt; другими, неуказанными, средствами.</target>
        </trans-unit>
        <trans-unit id="4470c9cf96cf0b0427223088eda48f753afa8e5d" translate="yes" xml:space="preserve">
          <source>If the range is empty, &lt;code&gt;init&lt;/code&gt; is returned, unmodified.</source>
          <target state="translated">Если диапазон пуст, &lt;code&gt;init&lt;/code&gt; возвращается без изменений.</target>
        </trans-unit>
        <trans-unit id="0a1fccb7fec68247b6a1b2dd1f263989d79d91a2" translate="yes" xml:space="preserve">
          <source>If the ratio &lt;code&gt;R1&lt;/code&gt; is greater than or equal to the ratio &lt;code&gt;R2&lt;/code&gt;, provides the member constant &lt;code&gt;value&lt;/code&gt; equal &lt;code&gt;true&lt;/code&gt;. Otherwise, &lt;code&gt;value&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">Если отношение &lt;code&gt;R1&lt;/code&gt; больше или равно отношению &lt;code&gt;R2&lt;/code&gt; , обеспечивается постоянное &lt;code&gt;value&lt;/code&gt; элемента, равное &lt;code&gt;true&lt;/code&gt; . В противном случае &lt;code&gt;value&lt;/code&gt; является &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1a7f289660496e50704c8e12b0a1a4ded1768f65" translate="yes" xml:space="preserve">
          <source>If the ratio &lt;code&gt;R1&lt;/code&gt; is greater than than the ratio &lt;code&gt;R2&lt;/code&gt;, provides the member constant &lt;code&gt;value&lt;/code&gt; equal &lt;code&gt;true&lt;/code&gt;. Otherwise, &lt;code&gt;value&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">Если отношение &lt;code&gt;R1&lt;/code&gt; больше, чем отношение &lt;code&gt;R2&lt;/code&gt; , обеспечивается постоянное &lt;code&gt;value&lt;/code&gt; члена, равное &lt;code&gt;true&lt;/code&gt; . В противном случае &lt;code&gt;value&lt;/code&gt; является &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="486dc284a8aec5600eb2ce6107311df95fa15c27" translate="yes" xml:space="preserve">
          <source>If the ratio &lt;code&gt;R1&lt;/code&gt; is less than or equal to the ratio &lt;code&gt;R2&lt;/code&gt;, provides the member constant &lt;code&gt;value&lt;/code&gt; equal &lt;code&gt;true&lt;/code&gt;. Otherwise, &lt;code&gt;value&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">Если отношение &lt;code&gt;R1&lt;/code&gt; меньше или равно отношению &lt;code&gt;R2&lt;/code&gt; , обеспечивается постоянное &lt;code&gt;value&lt;/code&gt; элемента, равное &lt;code&gt;true&lt;/code&gt; . В противном случае &lt;code&gt;value&lt;/code&gt; является &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2c44d3b0dc212e8ac325d4b33e901580daa7a83e" translate="yes" xml:space="preserve">
          <source>If the ratio R1 is less than the ratio R2, provides the member constant &lt;code&gt;value&lt;/code&gt; equal &lt;code&gt;true&lt;/code&gt;. Otherwise, &lt;code&gt;value&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">Если отношение R1 меньше, чем отношение R2, обеспечивается постоянное &lt;code&gt;value&lt;/code&gt; члена, равное &lt;code&gt;true&lt;/code&gt; . В противном случае &lt;code&gt;value&lt;/code&gt; является &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="402f8a7cc133b62e154ebba1457929bfddbc3bf0" translate="yes" xml:space="preserve">
          <source>If the ratios R1 and R2 are equal, provides the member constant &lt;code&gt;value&lt;/code&gt; equal &lt;code&gt;true&lt;/code&gt;. Otherwise, &lt;code&gt;value&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">Если отношения R1 и R2 равны, &lt;code&gt;value&lt;/code&gt; константы члена равно &lt;code&gt;true&lt;/code&gt; . В противном случае &lt;code&gt;value&lt;/code&gt; является &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="86470dd50c07d87d87cc6afc10ca67f451b58476" translate="yes" xml:space="preserve">
          <source>If the ratios R1 and R2 are not equal, provides the member constant &lt;code&gt;value&lt;/code&gt; equal &lt;code&gt;true&lt;/code&gt;. Otherwise, &lt;code&gt;value&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">Если отношения R1 и R2 не равны, &lt;code&gt;value&lt;/code&gt; константы члена равно &lt;code&gt;true&lt;/code&gt; . В противном случае &lt;code&gt;value&lt;/code&gt; является &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e6ef67dfe973705134074e186274b6c8db214065" translate="yes" xml:space="preserve">
          <source>If the referred-to object was destroyed (e.g. by explicit destructor call), but the storage was not deallocated, a reference to the out-of-lifetime object may be used in limited ways, and may become valid if the object is recreated in the same storage (see &lt;a href=&quot;lifetime#Access_outside_of_lifetime&quot;&gt;Access outside of lifetime&lt;/a&gt; for details).</source>
          <target state="translated">Если указанный объект был уничтожен (например, с помощью явного вызова деструктора), но хранилище не было освобождено, ссылка на устаревший объект может использоваться ограниченным образом и может стать действительной, если объект воссоздан в то же хранилище (подробности см. в разделе &lt;a href=&quot;lifetime#Access_outside_of_lifetime&quot;&gt;Доступ за пределами срока службы&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="32e827308169dc81e7dc50577c7dd9c26262ce2a" translate="yes" xml:space="preserve">
          <source>If the representation &lt;code&gt;rep&lt;/code&gt; of the duration requires some other implementation to return a maximum-length duration, &lt;code&gt;&lt;a href=&quot;../duration_values&quot;&gt;std::chrono::duration_values&lt;/a&gt;&lt;/code&gt; can be specialized to return the desired value.</source>
          <target state="translated">Если представление &lt;code&gt;rep&lt;/code&gt; продолжительности требует, чтобы какая-то другая реализация возвращала продолжительность максимальной длины, &lt;code&gt;&lt;a href=&quot;../duration_values&quot;&gt;std::chrono::duration_values&lt;/a&gt;&lt;/code&gt; может быть специализированным, чтобы возвратить желаемое значение.</target>
        </trans-unit>
        <trans-unit id="cf898146c6c3c24b40b13c45caea3516ac8e0db7" translate="yes" xml:space="preserve">
          <source>If the representation &lt;code&gt;rep&lt;/code&gt; of the duration requires some other implementation to return a minimum-length duration, &lt;code&gt;&lt;a href=&quot;../duration_values&quot;&gt;std::chrono::duration_values&lt;/a&gt;&lt;/code&gt; can be specialized to return the desired value.</source>
          <target state="translated">Если представление &lt;code&gt;rep&lt;/code&gt; продолжительности требует, чтобы какая-то другая реализация возвращала продолжительность минимальной длины, &lt;code&gt;&lt;a href=&quot;../duration_values&quot;&gt;std::chrono::duration_values&lt;/a&gt;&lt;/code&gt; может быть специализированным, чтобы возвратить желаемое значение.</target>
        </trans-unit>
        <trans-unit id="216bb9502dac2c6f6a263c7893d238bdae801fdf" translate="yes" xml:space="preserve">
          <source>If the representation &lt;code&gt;rep&lt;/code&gt; of the duration requires some other implementation to return a zero-length duration, &lt;code&gt;&lt;a href=&quot;../duration_values&quot;&gt;std::chrono::duration_values&lt;/a&gt;&lt;/code&gt; can be specialized to return the desired value.</source>
          <target state="translated">Если представление &lt;code&gt;rep&lt;/code&gt; продолжительности требует некоторой другой реализации, чтобы возвратить длительность нулевой длины, &lt;code&gt;&lt;a href=&quot;../duration_values&quot;&gt;std::chrono::duration_values&lt;/a&gt;&lt;/code&gt; может быть специализированным, чтобы возвратить желаемое значение.</target>
        </trans-unit>
        <trans-unit id="79081ea2c3cd338bf77b76285c9d2307dabb3758" translate="yes" xml:space="preserve">
          <source>If the result of &lt;code&gt;std::lrint&lt;/code&gt; or &lt;code&gt;std::llrint&lt;/code&gt; is outside the range representable by the return type, a domain error or a range error may occur.</source>
          <target state="translated">Если результат &lt;code&gt;std::lrint&lt;/code&gt; или &lt;code&gt;std::llrint&lt;/code&gt; находится за пределами диапазона, представляемого возвращаемым типом, может возникнуть ошибка домена или ошибки диапазона.</target>
        </trans-unit>
        <trans-unit id="587dd46cd3feba4cdcd09248f53d64715a053010" translate="yes" xml:space="preserve">
          <source>If the result of &lt;code&gt;std::lround&lt;/code&gt; or &lt;code&gt;std::llround&lt;/code&gt; is outside the range representable by the return type, a domain error or a range error may occur.</source>
          <target state="translated">Если результат &lt;code&gt;std::lround&lt;/code&gt; или &lt;code&gt;std::llround&lt;/code&gt; находится за пределами диапазона, представляемого типом возвращаемого значения, может произойти ошибка домена или ошибка диапазона.</target>
        </trans-unit>
        <trans-unit id="f9143780183f7e4a1182584068e608842bda530b" translate="yes" xml:space="preserve">
          <source>If the result of the conversion is unique, then &lt;code&gt;result == local_info::unique&lt;/code&gt;, &lt;code&gt;first&lt;/code&gt; is filled out with the correct &lt;code&gt;std::chrono::sys_info&lt;/code&gt;, and &lt;code&gt;second&lt;/code&gt; is zero-initialized.</source>
          <target state="translated">Если результат преобразования является уникальным, то &lt;code&gt;result == local_info::unique&lt;/code&gt; , &lt;code&gt;first&lt;/code&gt; заполняется корректным &lt;code&gt;std::chrono::sys_info&lt;/code&gt; , а &lt;code&gt;second&lt;/code&gt; инициализируется нулями.</target>
        </trans-unit>
        <trans-unit id="8eeeae32aeed1e098fc91dd8bd921c86fb200e23" translate="yes" xml:space="preserve">
          <source>If the result of the rounding is outside the range of the return type, &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; is raised and an implementation-defined value is returned</source>
          <target state="translated">Если результат округления находится за пределами диапазона возвращаемого типа, &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; повышается и возвращается значение, определенное реализацией</target>
        </trans-unit>
        <trans-unit id="40b9661e308f2792d26e6a4e9185df30cab4c8f8" translate="yes" xml:space="preserve">
          <source>If the result would be outside the range [-32767, 32767], the actual stored value is unspecified.</source>
          <target state="translated">Если результат выходит за пределы диапазона [-32767,32767],то фактическое сохраненное значение не указывается.</target>
        </trans-unit>
        <trans-unit id="12704794f475153a5a68233a95befd2418ed3109" translate="yes" xml:space="preserve">
          <source>If the result would be outside the range [0, 255], the actual stored value is unspecified.</source>
          <target state="translated">Если результат окажется за пределами диапазона [0,255],то фактическое сохраненное значение будет неуказано.</target>
        </trans-unit>
        <trans-unit id="9b8913f174ebaea61408caa1ef433d1587bd6ffe" translate="yes" xml:space="preserve">
          <source>If the resulting pointer type is a function pointer, a pointer to member, or &lt;code&gt;&lt;a href=&quot;../types/nullptr_t&quot;&gt;std::nullptr_t&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;p &amp;lt;=&amp;gt; q&lt;/code&gt; returns a prvalue of type &lt;a href=&quot;../utility/compare/strong_equality&quot;&gt;&lt;code&gt;std::strong_equality&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">Если результирующий тип указателя является указателем на функцию, указатель на член или &lt;code&gt;&lt;a href=&quot;../types/nullptr_t&quot;&gt;std::nullptr_t&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;p &amp;lt;=&amp;gt; q&lt;/code&gt; возвращает значение типа &lt;a href=&quot;../utility/compare/strong_equality&quot;&gt; &lt;code&gt;std::strong_equality&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="2e78c0f7505a15522acda3776ce4ce10a21d82dd" translate="yes" xml:space="preserve">
          <source>If the resulting pointer type is an object pointer type, &lt;code&gt;p &amp;lt;=&amp;gt; q&lt;/code&gt; returns a prvalue of type &lt;a href=&quot;../utility/compare/strong_ordering&quot;&gt;&lt;code&gt;strong_ordering&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">Если результирующий тип указателя является типом указателя объекта, &lt;code&gt;p &amp;lt;=&amp;gt; q&lt;/code&gt; возвращает значение типа &lt;a href=&quot;../utility/compare/strong_ordering&quot;&gt; &lt;code&gt;strong_ordering&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="dbda3e4805d43967af0a89706ef34251ae9306d8" translate="yes" xml:space="preserve">
          <source>If the resulting year value for (1-3) is outside the range [-32767,32767], the actual value stored is unspecified.</source>
          <target state="translated">Если результирующее значение года для (1-3)выходит за пределы диапазона [-32767,32767],то фактическое значение,сохраненное в памяти,не уточняется.</target>
        </trans-unit>
        <trans-unit id="d76cd29ea50833e8ec64892b7a35746e9aff8b17" translate="yes" xml:space="preserve">
          <source>If the return statement uses a brace-init-list, deduction is not allowed:</source>
          <target state="translated">Если в выписке о возврате товара используется список,вычет не разрешается:</target>
        </trans-unit>
        <trans-unit id="fa7a732c5f6541d73e515269ccd1d1ceb3b46448" translate="yes" xml:space="preserve">
          <source>If the return type is &lt;code&gt;decltype(auto)&lt;/code&gt;, the return type is as what would be obtained if the expression used in the return statement were wrapped in &lt;a href=&quot;decltype&quot;&gt;decltype&lt;/a&gt;.</source>
          <target state="translated">Если типом возврата является &lt;code&gt;decltype(auto)&lt;/code&gt; , типом возврата будет то, что было бы получено, если бы выражение, используемое в операторе возврата, было заключено в &lt;a href=&quot;decltype&quot;&gt;decltype&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d28a3f66a7fff0e2a4e0c4769a914c3fc6299edf" translate="yes" xml:space="preserve">
          <source>If the return type of the function template is a placeholder (&lt;code&gt;auto&lt;/code&gt; or &lt;code&gt;decltype(auto)&lt;/code&gt;), that return type is a non-deduced context and is determined from the instantiation.</source>
          <target state="translated">Если тип возвращаемого значения в шаблоне функции является заполнителем ( &lt;code&gt;auto&lt;/code&gt; или &lt;code&gt;decltype(auto)&lt;/code&gt; ), этот тип возвращаемого значения представляет собой не выводимый контекст и определяется из экземпляра.</target>
        </trans-unit>
        <trans-unit id="55096951d03276844009d4ac6ef2f86a40234649" translate="yes" xml:space="preserve">
          <source>If the returned value is &lt;code&gt;0&lt;/code&gt;, it will have the same sign as &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">Если возвращаемое значение равно &lt;code&gt;0&lt;/code&gt; , оно будет иметь тот же знак, что и &lt;code&gt;x&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6acd7cb12ab8e3d0ef11d24ea68011a7873b5dae" translate="yes" xml:space="preserve">
          <source>If the rewrite produces an invalid type, then &lt;code&gt;P&lt;/code&gt; is not at least as specialized as &lt;code&gt;A&lt;/code&gt;.</source>
          <target state="translated">Если переписывают производит неверный тип, то &lt;code&gt;P&lt;/code&gt; не , по крайней мере специализированы , как &lt;code&gt;A&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4014e2bbf13db27364d7162d5b480ce0991f7037" translate="yes" xml:space="preserve">
          <source>If the right hand side of &lt;code&gt;::&lt;/code&gt; names the same class as the left hand side, the name designates the &lt;a href=&quot;constructor&quot;&gt;constructor&lt;/a&gt; of that class. Such qualified name can only be used in a declaration of a constructor and in the &lt;a href=&quot;using_declaration&quot;&gt;using-declaration&lt;/a&gt; for an &lt;a href=&quot;using_declaration#Inheriting_constructors&quot;&gt;inheriting constructor&lt;/a&gt;. In those lookups where function names are ignored (that is, when looking up a name on the left of &lt;code&gt;::&lt;/code&gt;, when looking up a name in &lt;a href=&quot;elaborated_type_specifier&quot;&gt;elaborated type specifier&lt;/a&gt;, or &lt;a href=&quot;derived_class&quot;&gt;base specifier&lt;/a&gt;), the same syntax resolves to the injected-class-name:</source>
          <target state="translated">Если правая часть &lt;code&gt;::&lt;/code&gt; имен того же класса, что и левая сторона, имя обозначает &lt;a href=&quot;constructor&quot;&gt;конструктор&lt;/a&gt; этого класса. Такое квалифицированное имя может использоваться только в объявлении конструктора и в &lt;a href=&quot;using_declaration&quot;&gt;объявлении использования&lt;/a&gt; для &lt;a href=&quot;using_declaration#Inheriting_constructors&quot;&gt;наследующего конструктора&lt;/a&gt; . В тех поисках, где имена функций игнорируются (то есть при поиске имени слева от &lt;code&gt;::&lt;/code&gt; , при поиске имени в &lt;a href=&quot;elaborated_type_specifier&quot;&gt;подробном спецификаторе типа&lt;/a&gt; или &lt;a href=&quot;derived_class&quot;&gt;базовом спецификаторе&lt;/a&gt; ), тот же синтаксис разрешается в injected-class-name :</target>
        </trans-unit>
        <trans-unit id="cf85d17881197f4ecbe7cccfb07809892b92473d" translate="yes" xml:space="preserve">
          <source>If the right operand is a</source>
          <target state="translated">Если правильный операнд</target>
        </trans-unit>
        <trans-unit id="3c25a1f1f190f7079576b9f6ac4b83bbb5951e6a" translate="yes" xml:space="preserve">
          <source>If the same function is registered multiple times, it is called multiple times.</source>
          <target state="translated">Если одна и та же функция регистрируется несколько раз,она вызывается несколько раз.</target>
        </trans-unit>
        <trans-unit id="6456596730ba60e84aee4ac147873b048b5c59b5" translate="yes" xml:space="preserve">
          <source>If the second operand is zero, the behavior is undefined, except that if floating-point division is taking place and the type supports IEEE floating-point arithmetic (see &lt;code&gt;&lt;a href=&quot;../types/numeric_limits/is_iec559&quot;&gt;std::numeric_limits::is_iec559&lt;/a&gt;&lt;/code&gt;), then:</source>
          <target state="translated">Если второй операнд равен нулю, поведение не определено, за исключением того, что если происходит деление с плавающей запятой и тип поддерживает арифметику с плавающей запятой IEEE (см. &lt;code&gt;&lt;a href=&quot;../types/numeric_limits/is_iec559&quot;&gt;std::numeric_limits::is_iec559&lt;/a&gt;&lt;/code&gt; ), то:</target>
        </trans-unit>
        <trans-unit id="04f0455691936b497fbaebef44e9588dc509eb29" translate="yes" xml:space="preserve">
          <source>If the sentry returned &lt;code&gt;false&lt;/code&gt; or sentry's constructor threw an exception, no input takes place</source>
          <target state="translated">Если сторож вернул &lt;code&gt;false&lt;/code&gt; или конструктор сторожа выдал исключение, ввод не производится</target>
        </trans-unit>
        <trans-unit id="39a91a877963ed9b5a894be3943380a70d626e6f" translate="yes" xml:space="preserve">
          <source>If the sentry returned &lt;code&gt;false&lt;/code&gt; or sentry's constructor threw an exception, no output takes place</source>
          <target state="translated">Если сторож вернул &lt;code&gt;false&lt;/code&gt; или конструктор сторожа выдал исключение, вывод не производится</target>
        </trans-unit>
        <trans-unit id="bb9f6b8db596d35efa0c018a14df69e7f6bbfaa1" translate="yes" xml:space="preserve">
          <source>If the sentry returned &lt;code&gt;false&lt;/code&gt; or sentry's constructor threw an exception:</source>
          <target state="translated">Если часовой вернул &lt;code&gt;false&lt;/code&gt; или конструктор часового вызвал исключение:</target>
        </trans-unit>
        <trans-unit id="1a7affbf0e55ba9d44864cd1959e23685822e021" translate="yes" xml:space="preserve">
          <source>If the sentry returned &lt;code&gt;true&lt;/code&gt;, attempts to perform the desired output by inserting the characters into the output stream as if by calling &lt;code&gt;rdbuf()-&amp;gt;sputc()&lt;/code&gt; or &lt;code&gt;rdbuf()-&amp;gt;xsputn()&lt;/code&gt;. Additionally, &lt;code&gt;rdbuf()-&amp;gt;overflow()&lt;/code&gt; and &lt;code&gt;rdbuf()-&amp;gt;sync()&lt;/code&gt; may be called, but no other virtual member function of &lt;code&gt;&lt;a href=&quot;../io/basic_streambuf&quot;&gt;std::basic_streambuf&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Если часовой вернул значение &lt;code&gt;true&lt;/code&gt; , пытается выполнить желаемый вывод, вставляя символы в выходной поток, как если бы он вызывал &lt;code&gt;rdbuf()-&amp;gt;sputc()&lt;/code&gt; или &lt;code&gt;rdbuf()-&amp;gt;xsputn()&lt;/code&gt; . Кроме того, могут быть вызваны &lt;code&gt;rdbuf()-&amp;gt;overflow()&lt;/code&gt; и &lt;code&gt;rdbuf()-&amp;gt;sync()&lt;/code&gt; , но никакой другой виртуальной функции-члена &lt;code&gt;&lt;a href=&quot;../io/basic_streambuf&quot;&gt;std::basic_streambuf&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d65656ed9a96ce6e5067eef9a37718da9bc64cf6" translate="yes" xml:space="preserve">
          <source>If the sentry returned &lt;code&gt;true&lt;/code&gt;, performs the input as if by calling &lt;code&gt;rdbuf()-&amp;gt;sbumpc()&lt;/code&gt; or &lt;code&gt;rdbuf()-&amp;gt;sgetc()&lt;/code&gt;.</source>
          <target state="translated">Если часовой вернул значение &lt;code&gt;true&lt;/code&gt; , ввод выполняется как будто путем вызова &lt;code&gt;rdbuf()-&amp;gt;sbumpc()&lt;/code&gt; или &lt;code&gt;rdbuf()-&amp;gt;sgetc()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="70cc476a7cece12b6a2caeadf0dc66668c3d640a" translate="yes" xml:space="preserve">
          <source>If the set of potential exceptions is the set of all types, the implicit exception specification is &lt;code&gt;noexcept(false)&lt;/code&gt;.</source>
          <target state="translated">Если набор потенциальных исключений - это набор всех типов, спецификацией неявного исключения является &lt;code&gt;noexcept(false)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2fd5f4d3d66499f24cbe8e9106c8eff484bfafb9" translate="yes" xml:space="preserve">
          <source>If the signal handler is called NOT as a result of &lt;code&gt;&lt;a href=&quot;abort&quot;&gt;std::abort&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;raise&quot;&gt;std::raise&lt;/a&gt;&lt;/code&gt; (asynchronous signal), the behavior is undefined if.</source>
          <target state="translated">Если обработчик сигнала вызывается NOT в результате &lt;code&gt;&lt;a href=&quot;abort&quot;&gt;std::abort&lt;/a&gt;&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;raise&quot;&gt;std::raise&lt;/a&gt;&lt;/code&gt; (асинхронный сигнал), поведение не определено, если.</target>
        </trans-unit>
        <trans-unit id="671f3a813ef40ad3c5384400961c74b31b5b1d3a" translate="yes" xml:space="preserve">
          <source>If the signal handler is called as a result of &lt;code&gt;&lt;a href=&quot;abort&quot;&gt;std::abort&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;raise&quot;&gt;std::raise&lt;/a&gt;&lt;/code&gt; (synchronous signal), the behavior is undefined if the signal handler calls &lt;code&gt;&lt;a href=&quot;raise&quot;&gt;std::raise&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Если обработчик сигнала вызывается в результате &lt;code&gt;&lt;a href=&quot;abort&quot;&gt;std::abort&lt;/a&gt;&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;raise&quot;&gt;std::raise&lt;/a&gt;&lt;/code&gt; (синхронный сигнал), поведение не определено, если обработчик сигнала вызывает &lt;code&gt;&lt;a href=&quot;raise&quot;&gt;std::raise&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6be8eefa6fa1b67c6f58f6b59c61b09644913654" translate="yes" xml:space="preserve">
          <source>If the single-argument overload (17,18) is not provided, but the size-aware overload taking &lt;code&gt;std::size_t&lt;/code&gt; as the second parameter (21,22) is provided, the size-aware form is called for normal deallocation, and the C++ runtime passes the size of the object to be deallocated as the second argument. If both forms are defined, the size-unaware version is called.</source>
          <target state="translated">Если перегрузка с одним аргументом (17,18) не предусмотрена, но обеспечивается перегрузка с учетом размера, принимающая &lt;code&gt;std::size_t&lt;/code&gt; в качестве второго параметра (21,22), форма с учетом размера вызывается для нормального освобождения, и среда выполнения C ++ передает размер объекта, который должен быть освобожден, в качестве второго аргумента. Если обе формы определены, вызывается версия без учета размера.</target>
        </trans-unit>
        <trans-unit id="c2d39c7de53ad27f42a0268ca018c937a1d8ffae" translate="yes" xml:space="preserve">
          <source>If the size of the bitset is known at compile time, &lt;code&gt;&lt;a href=&quot;../utility/bitset&quot;&gt;std::bitset&lt;/a&gt;&lt;/code&gt; may be used, which offers a richer set of member functions. In addition, &lt;a href=&quot;http://www.boost.org/doc/libs/release/libs/dynamic_bitset/dynamic_bitset.html&quot;&gt;boost::dynamic_bitset&lt;/a&gt; exists as an alternative to &lt;code&gt;std::vector&amp;lt;bool&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">Если размер набора битов известен во время компиляции, может использоваться &lt;code&gt;&lt;a href=&quot;../utility/bitset&quot;&gt;std::bitset&lt;/a&gt;&lt;/code&gt; , который предлагает более широкий набор функций-членов. Кроме того, &lt;a href=&quot;http://www.boost.org/doc/libs/release/libs/dynamic_bitset/dynamic_bitset.html&quot;&gt;boost :: dynamic_bitset&lt;/a&gt; существует в качестве альтернативы &lt;code&gt;std::vector&amp;lt;bool&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d3ec4da197f7dc487044d683f9f3f0534aa5677b" translate="yes" xml:space="preserve">
          <source>If the size of the bitset is not known at compile time, &lt;a href=&quot;../container/vector_bool&quot;&gt;std::vector&amp;lt;bool&amp;gt;&lt;/a&gt; or &lt;a href=&quot;http://www.boost.org/doc/libs/release/libs/dynamic_bitset/dynamic_bitset.html&quot;&gt;boost::dynamic_bitset&lt;/a&gt; may be used.</source>
          <target state="translated">Если размер набора битов не известен во время компиляции, можно использовать &lt;a href=&quot;../container/vector_bool&quot;&gt;std :: vector &amp;lt;bool&amp;gt;&lt;/a&gt; или &lt;a href=&quot;http://www.boost.org/doc/libs/release/libs/dynamic_bitset/dynamic_bitset.html&quot;&gt;boost :: dynamic_bitset&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ad1cf7f64b041e9b0a91851335d5ade685bd49da" translate="yes" xml:space="preserve">
          <source>If the size requested is larger than what the largest pool can handle, memory is allocated by calling &lt;code&gt;allocate()&lt;/code&gt; on the upstream memory resource.</source>
          <target state="translated">Если запрашиваемый размер больше, чем может обработать самый большой пул, память выделяется путем вызова &lt;code&gt;allocate()&lt;/code&gt; в восходящем ресурсе памяти.</target>
        </trans-unit>
        <trans-unit id="b62ea5d0b3c38b6b4f7a4e5580107ff3cf6239e4" translate="yes" xml:space="preserve">
          <source>If the source and destination ranges (that is, &lt;code&gt;[first, last)&lt;/code&gt; and &lt;code&gt;[d_first, d_first+(last-first))&lt;/code&gt; respectively) overlap, the behavior is undefined.</source>
          <target state="translated">Если исходный и целевой диапазоны (то есть &lt;code&gt;[first, last)&lt;/code&gt; и &lt;code&gt;[d_first, d_first+(last-first))&lt;/code&gt; соответственно) перекрываются, поведение не определено.</target>
        </trans-unit>
        <trans-unit id="81c139c2b88224c56ebf4f7944ce062c13ebe2bf" translate="yes" xml:space="preserve">
          <source>If the source character type is &lt;code&gt;char16_t&lt;/code&gt;, conversion from UTF-16 to native filesystem encoding is used.</source>
          <target state="translated">Если исходный тип символа - &lt;code&gt;char16_t&lt;/code&gt; , используется преобразование из UTF-16 в кодировку собственной файловой системы.</target>
        </trans-unit>
        <trans-unit id="913c2f0506e7ab797a84a2f6e825328ef3b20217" translate="yes" xml:space="preserve">
          <source>If the source character type is &lt;code&gt;char32_t&lt;/code&gt;, conversion from UTF-32 to native filesystem encoding is used.</source>
          <target state="translated">Если исходный тип символа &lt;code&gt;char32_t&lt;/code&gt; , используется преобразование из UTF-32 в кодировку собственной файловой системы.</target>
        </trans-unit>
        <trans-unit id="694b72bdebad2e7991d3953383227294208921f6" translate="yes" xml:space="preserve">
          <source>If the source character type is &lt;code&gt;char8_t&lt;/code&gt;, conversion from UTF-8 to native filesystem encoding is used.</source>
          <target state="translated">Если исходный тип символа &lt;code&gt;char8_t&lt;/code&gt; , используется преобразование из UTF-8 в кодировку собственной файловой системы.</target>
        </trans-unit>
        <trans-unit id="96a70ab7daabf750d23aa93b01ed20ad4c4a1d50" translate="yes" xml:space="preserve">
          <source>If the source character type is &lt;code&gt;char&lt;/code&gt;, the encoding of the source is assumed to be the native narrow encoding (so no conversion takes place on POSIX systems)</source>
          <target state="translated">Если исходный тип &lt;code&gt;char&lt;/code&gt; - char , предполагается, что кодировка источника является родной узкой кодировкой (поэтому в системах POSIX преобразование не выполняется)</target>
        </trans-unit>
        <trans-unit id="4f00894176b3c2149f96504f78763e6045b2b289" translate="yes" xml:space="preserve">
          <source>If the source character type is &lt;code&gt;wchar_t&lt;/code&gt;, the input is assumed to be the native wide encoding (so no conversion takes places on Windows)</source>
          <target state="translated">Если исходный символьный тип - &lt;code&gt;wchar_t&lt;/code&gt; , предполагается, что входные данные являются собственно кодируемыми (поэтому в Windows преобразование не выполняется)</target>
        </trans-unit>
        <trans-unit id="c129bdb54be16ce791f2a9877c6536a222b2a628" translate="yes" xml:space="preserve">
          <source>If the source type is &lt;code&gt;bool&lt;/code&gt;, the value &lt;code&gt;false&lt;/code&gt; is converted to zero and the value &lt;code&gt;true&lt;/code&gt; is converted to the value one of the destination type (note that if the destination type is &lt;code&gt;int&lt;/code&gt;, this is an integer promotion, not an integer conversion).</source>
          <target state="translated">Если тип источника - &lt;code&gt;bool&lt;/code&gt; , значение &lt;code&gt;false&lt;/code&gt; преобразуется в ноль, а значение &lt;code&gt;true&lt;/code&gt; преобразуется в значение один из целевого типа (обратите внимание, что если тип назначения - &lt;code&gt;int&lt;/code&gt; , это целочисленное продвижение, а не целочисленное преобразование).</target>
        </trans-unit>
        <trans-unit id="bab9d6ec8e3d2f1fd684bd9854d45b7e92934c4f" translate="yes" xml:space="preserve">
          <source>If the source value can be represented exactly in the destination type, it does not change.</source>
          <target state="translated">Если исходное значение может быть точно представлено в типе назначения,то оно не меняется.</target>
        </trans-unit>
        <trans-unit id="efb29c4d220f173d5c3f3bd33b9dfc2ebc5dd7b6" translate="yes" xml:space="preserve">
          <source>If the source value is between two representable values of the destination type, the result is one of those two values (it is implementation-defined which one, although if IEEE arithmetic is supported, rounding defaults &lt;a href=&quot;../numeric/fenv/fe_round&quot;&gt;to nearest&lt;/a&gt;).</source>
          <target state="translated">Если исходное значение находится между двумя представимыми значениями целевого типа, результатом является одно из этих двух значений (какое из них определяется реализацией, хотя, если поддерживается арифметика IEEE, округляется по умолчанию &lt;a href=&quot;../numeric/fenv/fe_round&quot;&gt;до ближайшего&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="31b86def2b9a34fa38b7b256145666db6c5bf517" translate="yes" xml:space="preserve">
          <source>If the span is empty, the returned iterator will be equal to &lt;code&gt;end()&lt;/code&gt;.</source>
          <target state="translated">Если диапазон пуст, возвращаемый итератор будет равен &lt;code&gt;end()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3b682c7de7ba329b4fb255e71c3dba81aec002eb" translate="yes" xml:space="preserve">
          <source>If the specified size of the bit field is greater than the size of its type, the value is limited by the type: a &lt;code&gt;&lt;a href=&quot;../types/integer&quot;&gt;std::uint8_t&lt;/a&gt; b : 1000;&lt;/code&gt; would still hold values between 0 and 255. the extra bits become unused padding.</source>
          <target state="translated">Если указанный размер битового поля больше размера его типа, значение ограничивается типом: a &lt;code&gt;&lt;a href=&quot;../types/integer&quot;&gt;std::uint8_t&lt;/a&gt; b : 1000;&lt;/code&gt; будет по-прежнему содержать значения от 0 до 255. дополнительные биты становятся неиспользованными дополнением.</target>
        </trans-unit>
        <trans-unit id="0cd8d8e47fd2f7d673121bf212de39492d391631" translate="yes" xml:space="preserve">
          <source>If the static type of the object that is being deleted differs from its dynamic type (such as when deleting a &lt;a href=&quot;../../language/objects&quot;&gt;polymorphic&lt;/a&gt; object through a pointer to base), and if the destructor in the static type is virtual, the single object form of delete begins lookup of the deallocation function's name starting from the point of definition of the final overrider of its virtual destructor. Regardless of which deallocation function would be executed at run time, the statically visible version of operator delete must be accessible in order to compile. In other cases, when deleting an array through a pointer to base, or when deleting through pointer to base with non-virtual destructor, the behavior is undefined.</source>
          <target state="translated">Если статический тип удаляемого объекта отличается от его динамического типа (например, при удалении &lt;a href=&quot;../../language/objects&quot;&gt;полиморфного&lt;/a&gt; объекта через указатель на базу), и если деструктор в статическом типе является виртуальным, форма удаления одиночного объекта начинает поиск имени функции освобождения, начиная с точки определения окончательного переопределения ее виртуального деструктора. Независимо от того, какая функция освобождения будет выполняться во время выполнения, статически видимая версия оператора delete должна быть доступна для компиляции. В других случаях при удалении массива с помощью указателя на базу или при удалении с помощью указателя на базу с не виртуальным деструктором поведение не определено.</target>
        </trans-unit>
        <trans-unit id="1a0ccecdae65148cf1c548284599ec7fc29e7a26" translate="yes" xml:space="preserve">
          <source>If the stored argument &lt;code&gt;arg&lt;/code&gt; is of type &lt;code&gt;&lt;a href=&quot;reference_wrapper&quot;&gt;std::reference_wrapper&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt; (for example, &lt;code&gt;&lt;a href=&quot;ref&quot;&gt;std::ref&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;ref&quot;&gt;std::cref&lt;/a&gt;&lt;/code&gt; was used in the initial call to &lt;code&gt;bind&lt;/code&gt;), then the argument &lt;code&gt;vn&lt;/code&gt; in the &lt;code&gt;std::invoke&lt;/code&gt; call above is &lt;code&gt;arg.get()&lt;/code&gt; and the type &lt;code&gt;Vn&lt;/code&gt; in the same call is &lt;code&gt;T&amp;amp;&lt;/code&gt;: the stored argument is passed by reference into the invoked function object.</source>
          <target state="translated">Если сохраненный аргумент &lt;code&gt;arg&lt;/code&gt; имеет тип &lt;code&gt;&lt;a href=&quot;reference_wrapper&quot;&gt;std::reference_wrapper&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt; (например, &lt;code&gt;&lt;a href=&quot;ref&quot;&gt;std::ref&lt;/a&gt;&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;ref&quot;&gt;std::cref&lt;/a&gt;&lt;/code&gt; использовался при первоначальном вызове &lt;code&gt;bind&lt;/code&gt; ), то аргумент &lt;code&gt;vn&lt;/code&gt; в приведенном выше вызове &lt;code&gt;std::invoke&lt;/code&gt; это &lt;code&gt;arg.get()&lt;/code&gt; а тип &lt;code&gt;Vn&lt;/code&gt; в том же вызове - &lt;code&gt;T&amp;amp;&lt;/code&gt; : сохраненный аргумент передается по ссылке в вызываемый объект функции.</target>
        </trans-unit>
        <trans-unit id="acee41d0611ce916e2778b1cfd039971f9e77287" translate="yes" xml:space="preserve">
          <source>If the stored argument &lt;code&gt;arg&lt;/code&gt; is of type &lt;code&gt;T&lt;/code&gt; for which &lt;code&gt;&lt;a href=&quot;is_bind_expression&quot;&gt;std::is_bind_expression&lt;/a&gt;&amp;lt;T&amp;gt;::value == true&lt;/code&gt; (for example, another &lt;code&gt;bind&lt;/code&gt; expression was passed directly into the initial call to &lt;code&gt;bind&lt;/code&gt;), then &lt;code&gt;bind&lt;/code&gt; performs function composition: instead of passing the function object that the bind subexpression would return, the subexpression is invoked eagerly, and its return value is passed to the outer invokable object. If the bind subexpression has any placeholder arguments, they are shared with the outer bind (picked out of &lt;code&gt;u1, u2, ...&lt;/code&gt;). Specifically, the argument &lt;code&gt;vn&lt;/code&gt; in the &lt;code&gt;std::invoke&lt;/code&gt; call above is &lt;code&gt;arg(std::forward&amp;lt;Uj&amp;gt;(uj)...)&lt;/code&gt; and the type &lt;code&gt;Vn&lt;/code&gt; in the same call is &lt;code&gt;&lt;a href=&quot;../../types/result_of&quot;&gt;std::result_of_t&lt;/a&gt;&amp;lt;T cv &amp;amp;(Uj&amp;amp;&amp;amp;...)&amp;gt;&amp;amp;&amp;amp;&lt;/code&gt; (cv qualification is the same as that of &lt;code&gt;g&lt;/code&gt;).</source>
          <target state="translated">Если сохраненный аргумент &lt;code&gt;arg&lt;/code&gt; имеет тип &lt;code&gt;T&lt;/code&gt; , для которого &lt;code&gt;&lt;a href=&quot;is_bind_expression&quot;&gt;std::is_bind_expression&lt;/a&gt;&amp;lt;T&amp;gt;::value == true&lt;/code&gt; (например, другое выражение &lt;code&gt;bind&lt;/code&gt; было передано непосредственно в начальный вызов &lt;code&gt;bind&lt;/code&gt; ), тогда &lt;code&gt;bind&lt;/code&gt; выполняет композицию функций: вместо Передав функциональный объект, который вернуло подвыражение bind, подвыражение вызывается с нетерпением, а его возвращаемое значение передается внешнему вызываемому объекту. Если подвыражение связывания имеет какие-либо аргументы-заполнители, они используются совместно с внешним связыванием (выбирается из &lt;code&gt;u1, u2, ...&lt;/code&gt; ). В частности, аргумент &lt;code&gt;vn&lt;/code&gt; в приведенном выше вызове &lt;code&gt;std::invoke&lt;/code&gt; : &lt;code&gt;arg(std::forward&amp;lt;Uj&amp;gt;(uj)...)&lt;/code&gt; и тип &lt;code&gt;Vn&lt;/code&gt; в одном вызове - это &lt;code&gt;&lt;a href=&quot;../../types/result_of&quot;&gt;std::result_of_t&lt;/a&gt;&amp;lt;T cv &amp;amp;(Uj&amp;amp;&amp;amp;...)&amp;gt;&amp;amp;&amp;amp;&lt;/code&gt; (квалификация cv такая же, как и для &lt;code&gt;g&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="dc4a284d335b2d5c1ce7e8244468b32d33179179" translate="yes" xml:space="preserve">
          <source>If the stored argument &lt;code&gt;arg&lt;/code&gt; is of type &lt;code&gt;T&lt;/code&gt;, for which &lt;code&gt;&lt;a href=&quot;is_placeholder&quot;&gt;std::is_placeholder&lt;/a&gt;&amp;lt;T&amp;gt;::value != 0&lt;/code&gt; (meaning, a placeholder such as &lt;code&gt;std::placeholders::_1, _2, _3, ...&lt;/code&gt; was used as the argument to the initial call to &lt;code&gt;bind&lt;/code&gt;), then the argument indicated by the placeholder (&lt;code&gt;u1&lt;/code&gt; for &lt;code&gt;_1&lt;/code&gt;, &lt;code&gt;u2&lt;/code&gt; for &lt;code&gt;_2&lt;/code&gt;, etc) is passed to the invokable object: the argument &lt;code&gt;vn&lt;/code&gt; in the &lt;code&gt;std::invoke&lt;/code&gt; call above is &lt;code&gt;&lt;a href=&quot;../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;Uj&amp;gt;(uj)&lt;/code&gt; and the corresponding type &lt;code&gt;Vn&lt;/code&gt; in the same call is &lt;code&gt;Uj&amp;amp;&amp;amp;&lt;/code&gt;.</source>
          <target state="translated">Если сохраненный аргумент &lt;code&gt;arg&lt;/code&gt; имеет тип &lt;code&gt;T&lt;/code&gt; , для которого &lt;code&gt;&lt;a href=&quot;is_placeholder&quot;&gt;std::is_placeholder&lt;/a&gt;&amp;lt;T&amp;gt;::value != 0&lt;/code&gt; (имеется в виду, заполнитель, такой как &lt;code&gt;std::placeholders::_1, _2, _3, ...&lt;/code&gt; использовался как аргумент начального вызова &lt;code&gt;bind&lt;/code&gt; ), затем аргумент, указанный в качестве заполнителя ( &lt;code&gt;u1&lt;/code&gt; для &lt;code&gt;_1&lt;/code&gt; , &lt;code&gt;u2&lt;/code&gt; для &lt;code&gt;_2&lt;/code&gt; и т. д.), передается вызываемому объекту: аргумент &lt;code&gt;vn&lt;/code&gt; в приведенном выше вызове &lt;code&gt;std::invoke&lt;/code&gt; - это &lt;code&gt;&lt;a href=&quot;../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;Uj&amp;gt;(uj)&lt;/code&gt; и соответствующий тип &lt;code&gt;Vn&lt;/code&gt; в одном вызове - &lt;code&gt;Uj&amp;amp;&amp;amp;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5073b898afe983835e7576b31a4b2a5ed1384e70" translate="yes" xml:space="preserve">
          <source>If the stored reference is &lt;a href=&quot;../../named_req/callable&quot;&gt;Callable&lt;/a&gt;, &lt;code&gt;std::reference_wrapper&lt;/code&gt; is callable with the same arguments.</source>
          <target state="translated">Если сохраненная ссылка &lt;a href=&quot;../../named_req/callable&quot;&gt;Callable&lt;/a&gt; , &lt;code&gt;std::reference_wrapper&lt;/code&gt; вызывается с теми же аргументами.</target>
        </trans-unit>
        <trans-unit id="721f1a0ff5ac2a85a4aec48dc758c5efa06cf129" translate="yes" xml:space="preserve">
          <source>If the stream is open in binary mode, the value obtained by this function is the number of bytes from the beginning of the file.</source>
          <target state="translated">Если поток открыт в двоичном режиме,то значение,получаемое этой функцией,представляет собой количество байт от начала файла.</target>
        </trans-unit>
        <trans-unit id="1be01e06d2b7863dcf18bfbfbb7a62e4aff8f3b7" translate="yes" xml:space="preserve">
          <source>If the stream is open in text mode, the value returned by this function is unspecified and is only meaningful as the input to &lt;code&gt;&lt;a href=&quot;fseek&quot;&gt;std::fseek&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Если поток открыт в текстовом режиме, значение, возвращаемое этой функцией, не определено и имеет смысл только как входные данные для &lt;code&gt;&lt;a href=&quot;fseek&quot;&gt;std::fseek&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="dcf9d7178da0219ad2eb8a851abb68eb2713f063" translate="yes" xml:space="preserve">
          <source>If the stream is using a dynamically-allocated array for output, disables (&lt;code&gt;flag == true&lt;/code&gt;) or enables (&lt;code&gt;flag == false&lt;/code&gt;) automatic allocation/deallocation of the buffer. Effectively calls &lt;code&gt;rdbuf()-&amp;gt;freeze(flag)&lt;/code&gt;.</source>
          <target state="translated">Если поток использует динамически распределенный массив для вывода, отключает ( &lt;code&gt;flag == true&lt;/code&gt; ) или включает ( &lt;code&gt;flag == false&lt;/code&gt; ) автоматическое выделение / освобождение буфера. Эффективно вызывает &lt;code&gt;rdbuf()-&amp;gt;freeze(flag)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e3a1404f13d35c564c59b09dcb07b726f75ab0a7" translate="yes" xml:space="preserve">
          <source>If the strictest (largest) &lt;code&gt;alignas&lt;/code&gt; on a declaration is weaker than the alignment it would have without any &lt;code&gt;alignas&lt;/code&gt; specifiers (that is, weaker than its natural alignment or weaker than &lt;code&gt;alignas&lt;/code&gt; on another declaration of the same object or type), the program is ill-formed:</source>
          <target state="translated">Если самые строгие (самые большие) &lt;code&gt;alignas&lt;/code&gt; в объявлении слабее, чем выравнивание, которое было бы без &lt;code&gt;alignas&lt;/code&gt; спецификаторов (то есть слабее, чем его естественное выравнивание, или слабее, чем &lt;code&gt;alignas&lt;/code&gt; в другом объявлении того же объекта или типа), программа не работает. -formed:</target>
        </trans-unit>
        <trans-unit id="b376b7c229a7bc07ebacea949f846a78b0d1782c" translate="yes" xml:space="preserve">
          <source>If the strings overlap, the behavior is undefined.</source>
          <target state="translated">Если строки перекрываются,поведение не определено.</target>
        </trans-unit>
        <trans-unit id="7d57980d6c4db7f5a88e476c28a7345cd0ee1e03" translate="yes" xml:space="preserve">
          <source>If the synchronization is turned off, the C++ standard streams are allowed to buffer their I/O independently, which may be considerably faster in some cases.</source>
          <target state="translated">Если синхронизация отключена,то стандартным потокам С++разрешается буферизация их входов/выходов независимо друг от друга,что в некоторых случаях может быть значительно быстрее.</target>
        </trans-unit>
        <trans-unit id="9a8cb52b7220965fcee67fc72cd6b2b899d9bdff" translate="yes" xml:space="preserve">
          <source>If the target sequence is uniquely matched, &lt;code&gt;v&lt;/code&gt; is set to the corresponding &lt;code&gt;bool&lt;/code&gt; value. Otherwise &lt;code&gt;false&lt;/code&gt; is stored in &lt;code&gt;v&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../../io/ios_base/iostate&quot;&gt;std::ios_base::failbit&lt;/a&gt;&lt;/code&gt; is assigned to &lt;code&gt;err&lt;/code&gt;. If unique match could not be found before the input ended (&lt;code&gt;in==end&lt;/code&gt;), &lt;code&gt;err|=&lt;a href=&quot;../../io/ios_base/iostate&quot;&gt;std::ios_base::eofbit&lt;/a&gt;&lt;/code&gt; is executed.</source>
          <target state="translated">Если целевая последовательность совпадает однозначно, для &lt;code&gt;v&lt;/code&gt; устанавливается соответствующее значение &lt;code&gt;bool&lt;/code&gt; . В противном случае &lt;code&gt;false&lt;/code&gt; сохраняется в &lt;code&gt;v&lt;/code&gt; , а &lt;code&gt;&lt;a href=&quot;../../io/ios_base/iostate&quot;&gt;std::ios_base::failbit&lt;/a&gt;&lt;/code&gt; назначается для &lt;code&gt;err&lt;/code&gt; . Если уникальное совпадение не может быть найдено до окончания ввода ( &lt;code&gt;in==end&lt;/code&gt; ), выполняется &lt;code&gt;err|=&lt;a href=&quot;../../io/ios_base/iostate&quot;&gt;std::ios_base::eofbit&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f1289b6bdc776c1418acfec4d954c523b4601b0f" translate="yes" xml:space="preserve">
          <source>If the type &lt;code&gt;T&lt;/code&gt; is a reference type, provides the member typedef &lt;code&gt;type&lt;/code&gt; which is the type referred to by &lt;code&gt;T&lt;/code&gt; with its topmost cv-qualifiers removed. Otherwise &lt;code&gt;type&lt;/code&gt; is &lt;code&gt;T&lt;/code&gt; with its topmost cv-qualifiers removed.</source>
          <target state="translated">Если тип &lt;code&gt;T&lt;/code&gt; является ссылочным типом, предоставляет &lt;code&gt;type&lt;/code&gt; typedef члена, который является типом, на который ссылается &lt;code&gt;T&lt;/code&gt; , с удаленными самыми верхними квалификаторами cv. В противном случае &lt;code&gt;type&lt;/code&gt; - &lt;code&gt;T&lt;/code&gt; с удаленными самыми верхними квалификаторами cv.</target>
        </trans-unit>
        <trans-unit id="bc4e534b1c21d223bb95673e8d15e125bb5d8892" translate="yes" xml:space="preserve">
          <source>If the type &lt;code&gt;T&lt;/code&gt; is a reference type, provides the member typedef &lt;code&gt;type&lt;/code&gt; which is the type referred to by &lt;code&gt;T&lt;/code&gt;. Otherwise &lt;code&gt;type&lt;/code&gt; is &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">Если типа &lt;code&gt;T&lt;/code&gt; является ссылочным типом, обеспечивает ЬурейиЙ член &lt;code&gt;type&lt;/code&gt; , который является типом ссылается &lt;code&gt;T&lt;/code&gt; . В противном случае &lt;code&gt;type&lt;/code&gt; является &lt;code&gt;T&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="568c9a7735dfb6e7c3f7facf46f864c936b3998f" translate="yes" xml:space="preserve">
          <source>If the type is complete and if, for the delete[] only, the operand is a pointer to a class type with a non-trivial destructor or a (possibly multi-dimensional) array thereof, the global size-aware global function (with a parameter of type &lt;code&gt;&lt;a href=&quot;../types/size_t&quot;&gt;std::size_t&lt;/a&gt;&lt;/code&gt;) is selected</source>
          <target state="translated">Если тип завершен и если только для delete [], операндом является указатель на тип класса с нетривиальным деструктором или его (возможно многомерным) массивом, глобальная глобальная функция, учитывающая размер (с параметр типа &lt;code&gt;&lt;a href=&quot;../types/size_t&quot;&gt;std::size_t&lt;/a&gt;&lt;/code&gt; ) выбран</target>
        </trans-unit>
        <trans-unit id="d45b643bd174051aee94549a2f03f3ff00e0a987" translate="yes" xml:space="preserve">
          <source>If the type is reference type, the operator returns the alignment of</source>
          <target state="translated">Если тип является типом ссылки,оператор возвращает выравнивание</target>
        </trans-unit>
        <trans-unit id="e61370f729d3fc61feda284c6f51bb8eac974871" translate="yes" xml:space="preserve">
          <source>If the type of &lt;code&gt;v&lt;/code&gt; is &lt;code&gt;bool&lt;/code&gt;</source>
          <target state="translated">Если тип &lt;code&gt;v&lt;/code&gt; является &lt;code&gt;bool&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="bb07f1de8954ef59a83dcf953df4f4e9416e15a0" translate="yes" xml:space="preserve">
          <source>If the type of &lt;code&gt;v&lt;/code&gt; is &lt;code&gt;bool&lt;/code&gt; and &lt;code&gt;boolalpha!=0&lt;/code&gt;, the following replaces stages 2 and 3:</source>
          <target state="translated">Если тип &lt;code&gt;v&lt;/code&gt; является &lt;code&gt;bool&lt;/code&gt; и &lt;code&gt;boolalpha!=0&lt;/code&gt; , следующие этапы заменяют этапы 2 и 3:</target>
        </trans-unit>
        <trans-unit id="9a11f0db514f9cdeffd237282d9ed24955a00f05" translate="yes" xml:space="preserve">
          <source>If the type of &lt;code&gt;v&lt;/code&gt; is &lt;code&gt;bool&lt;/code&gt; and &lt;code&gt;boolalpha==0&lt;/code&gt;, proceeds as if the type of &lt;code&gt;v&lt;/code&gt; is &lt;code&gt;long&lt;/code&gt;, except for the value to be stored in &lt;code&gt;v&lt;/code&gt; in stage 3.</source>
          <target state="translated">Если типом &lt;code&gt;v&lt;/code&gt; является &lt;code&gt;bool&lt;/code&gt; и &lt;code&gt;boolalpha==0&lt;/code&gt; , происходит, как если бы тип &lt;code&gt;v&lt;/code&gt; был &lt;code&gt;long&lt;/code&gt; , за исключением значения, которое будет сохранено в &lt;code&gt;v&lt;/code&gt; на этапе 3.</target>
        </trans-unit>
        <trans-unit id="5c85042e7deeed4301f664d1dc468bbb3d06b939" translate="yes" xml:space="preserve">
          <source>If the type of &lt;code&gt;v&lt;/code&gt; is &lt;code&gt;bool&lt;/code&gt; and boolalpha is not set, then if the value to be stored is &lt;code&gt;​0​&lt;/code&gt;, &lt;code&gt;false&lt;/code&gt; is stored, if the value to be stored is &lt;code&gt;1&lt;/code&gt;, &lt;code&gt;true&lt;/code&gt; is stored, for any other value &lt;code&gt;&lt;a href=&quot;../../io/ios_base/iostate&quot;&gt;std::ios_base::failbit&lt;/a&gt;&lt;/code&gt; is assigned to &lt;code&gt;err&lt;/code&gt; and &lt;code&gt;true&lt;/code&gt; is stored.</source>
          <target state="translated">Если тип &lt;code&gt;v&lt;/code&gt; является &lt;code&gt;bool&lt;/code&gt; и boolalpha не установлен, то , если значение , которое будет храниться в &lt;code&gt;​0​&lt;/code&gt; , &lt;code&gt;false&lt;/code&gt; сохраняется, если сохраняемое значение является &lt;code&gt;1&lt;/code&gt; , &lt;code&gt;true&lt;/code&gt; , сохраняется, для любого другого значения &lt;code&gt;&lt;a href=&quot;../../io/ios_base/iostate&quot;&gt;std::ios_base::failbit&lt;/a&gt;&lt;/code&gt; назначается на &lt;code&gt;err&lt;/code&gt; , а &lt;code&gt;true&lt;/code&gt; сохраняется.</target>
        </trans-unit>
        <trans-unit id="7476d41e2a67317c3bb5251d97663d77eeb1e42c" translate="yes" xml:space="preserve">
          <source>If the type of &lt;code&gt;v&lt;/code&gt; is &lt;code&gt;double&lt;/code&gt;, will use conversion specifier &lt;code&gt;%lg&lt;/code&gt;</source>
          <target state="translated">Если тип &lt;code&gt;v&lt;/code&gt; является &lt;code&gt;double&lt;/code&gt; , будет использовать преобразование спецификатор &lt;code&gt;%lg&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="dfdf59b17079b062cc1b92411ee58243a516a33f" translate="yes" xml:space="preserve">
          <source>If the type of &lt;code&gt;v&lt;/code&gt; is &lt;code&gt;float&lt;/code&gt;, will use conversion specifier &lt;code&gt;%g&lt;/code&gt;</source>
          <target state="translated">Если тип &lt;code&gt;v&lt;/code&gt; является &lt;code&gt;float&lt;/code&gt; , будет использовать спецификатор преобразования &lt;code&gt;%g&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4567caa0edddb2a88680b490c4e2737935cdcbd5" translate="yes" xml:space="preserve">
          <source>If the type of &lt;code&gt;v&lt;/code&gt; is &lt;code&gt;long double&lt;/code&gt;, the length modifier &lt;code&gt;L&lt;/code&gt; is added to the conversion specifier.</source>
          <target state="translated">Если тип &lt;code&gt;v&lt;/code&gt; является &lt;code&gt;long double&lt;/code&gt; модификатор длиной &lt;code&gt;L&lt;/code&gt; добавляется в спецификатор преобразования.</target>
        </trans-unit>
        <trans-unit id="0474c288e1ccdf560a85090121492766095a9be3" translate="yes" xml:space="preserve">
          <source>If the type of &lt;code&gt;v&lt;/code&gt; is &lt;code&gt;long double&lt;/code&gt;, will use conversion specifier &lt;code&gt;%Lg&lt;/code&gt;</source>
          <target state="translated">Если тип &lt;code&gt;v&lt;/code&gt; является &lt;code&gt;long double&lt;/code&gt; , будет использовать спецификатор преобразования &lt;code&gt;%Lg&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="00d6a72b02646eead810c617c23ae522ca753e6d" translate="yes" xml:space="preserve">
          <source>If the type of &lt;code&gt;v&lt;/code&gt; is &lt;code&gt;void*&lt;/code&gt;, will use conversion specifier &lt;code&gt;%p&lt;/code&gt;</source>
          <target state="translated">Если тип &lt;code&gt;v&lt;/code&gt; является &lt;code&gt;void*&lt;/code&gt; , будет использовать спецификатор преобразования &lt;code&gt;%p&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="29e503ca84cb15f39173a1562dbbbb2beffa737a" translate="yes" xml:space="preserve">
          <source>If the type of &lt;code&gt;v&lt;/code&gt; is a floating-point type, the the first applicable choice of the following is selected:</source>
          <target state="translated">Если тип &lt;code&gt;v&lt;/code&gt; является с плавающей запятой, выбирается первый подходящий вариант из следующих:</target>
        </trans-unit>
        <trans-unit id="af8313560c731302bab034bb408aa878436ea837" translate="yes" xml:space="preserve">
          <source>If the type of &lt;code&gt;v&lt;/code&gt; is an integer type, the the first applicable choice of the following five is selected:</source>
          <target state="translated">Если тип &lt;code&gt;v&lt;/code&gt; является целочисленным типом, выбирается первый подходящий вариант из следующих пяти:</target>
        </trans-unit>
        <trans-unit id="c3a7ea4c84d1d685474ebd89637a92007ea3ea02" translate="yes" xml:space="preserve">
          <source>If the type of &lt;code&gt;v&lt;/code&gt; is an integer type, the the first applicable choice of the following is selected:</source>
          <target state="translated">Если тип &lt;code&gt;v&lt;/code&gt; является целочисленным типом, выбирается первый подходящий вариант из следующих:</target>
        </trans-unit>
        <trans-unit id="78f0474ec6b14c626c7efaff5801d926c1f92941" translate="yes" xml:space="preserve">
          <source>If the type of &lt;code&gt;v&lt;/code&gt; is signed, will use conversion specifier &lt;code&gt;%d&lt;/code&gt;</source>
          <target state="translated">Если тип &lt;code&gt;v&lt;/code&gt; подписан, будет использоваться спецификатор преобразования &lt;code&gt;%d&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4990261c39b3a34d0f827b213b2a6345d9b18783" translate="yes" xml:space="preserve">
          <source>If the type of &lt;code&gt;v&lt;/code&gt; is unsigned, will use conversion specifier &lt;code&gt;%u&lt;/code&gt;</source>
          <target state="translated">Если тип &lt;code&gt;v&lt;/code&gt; без знака, будет использовать спецификатор преобразования &lt;code&gt;%u&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="51577fdf94f044af450cebe5474487f90f5669ab" translate="yes" xml:space="preserve">
          <source>If the type of the next argument in &lt;code&gt;ap&lt;/code&gt; (after promotions) is not compatible with &lt;code&gt;T&lt;/code&gt;, the behavior is undefined, unless:</source>
          <target state="translated">Если тип следующего аргумента в &lt;code&gt;ap&lt;/code&gt; (после продвижения) не совместим с &lt;code&gt;T&lt;/code&gt; , поведение не определено, если только:</target>
        </trans-unit>
        <trans-unit id="37ea6657641f330790f7fa714b3234e4d4d737e5" translate="yes" xml:space="preserve">
          <source>If the type's alignment requirement exceeds &lt;code&gt;__STDCPP_DEFAULT_NEW_ALIGNMENT__&lt;/code&gt;, alignment-aware deallocation functions (with a parameter of type &lt;code&gt;&lt;a href=&quot;../memory/new/align_val_t&quot;&gt;std::align_val_t&lt;/a&gt;&lt;/code&gt;) are preferred. For other types, the alignment-unaware deallocation functions (without a parameter of type &lt;code&gt;&lt;a href=&quot;../memory/new/align_val_t&quot;&gt;std::align_val_t&lt;/a&gt;&lt;/code&gt;) are preferred.</source>
          <target state="translated">Если требование выравнивания типа превышает &lt;code&gt;__STDCPP_DEFAULT_NEW_ALIGNMENT__&lt;/code&gt; , предпочтительны функции освобождения с учетом выравнивания (с параметром типа &lt;code&gt;&lt;a href=&quot;../memory/new/align_val_t&quot;&gt;std::align_val_t&lt;/a&gt;&lt;/code&gt; ). Для других типов, функции освобождения от выравнивания (без параметра типа &lt;code&gt;&lt;a href=&quot;../memory/new/align_val_t&quot;&gt;std::align_val_t&lt;/a&gt;&lt;/code&gt; предпочтительны ).</target>
        </trans-unit>
        <trans-unit id="9e2d47f6d426a3f84b185a211656e8cd6bd7698e" translate="yes" xml:space="preserve">
          <source>If the underlying bytes of &lt;code&gt;obj1&lt;/code&gt; is copied into such an array, and then the resulting content is copied back into &lt;code&gt;obj1&lt;/code&gt;, &lt;code&gt;obj1&lt;/code&gt; will hold its original value. If the underlying bytes of &lt;code&gt;obj1&lt;/code&gt; are copied into &lt;code&gt;obj2&lt;/code&gt;, &lt;code&gt;obj2&lt;/code&gt; will hold &lt;code&gt;obj1&lt;/code&gt;'s value.</source>
          <target state="translated">Если нижележащие байты &lt;code&gt;obj1&lt;/code&gt; копируются в такой массив, а затем результирующее содержимое копируется обратно в &lt;code&gt;obj1&lt;/code&gt; , &lt;code&gt;obj1&lt;/code&gt; сохранит свое первоначальное значение. Если нижележащие байты &lt;code&gt;obj1&lt;/code&gt; копируются в &lt;code&gt;obj2&lt;/code&gt; , &lt;code&gt;obj2&lt;/code&gt; будет содержать значение &lt;code&gt;obj1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1c532a0885cdbf73cb10a896503a4564c8a0bf0b" translate="yes" xml:space="preserve">
          <source>If the underlying type is fixed, the result is the same as the &lt;a href=&quot;implicit_cast#Integral_conversions&quot;&gt;converting&lt;/a&gt; the original value first to the underlying type of the enumeration and then to the enumeration type.</source>
          <target state="translated">Если базовый тип является фиксированным, результат аналогичен &lt;a href=&quot;implicit_cast#Integral_conversions&quot;&gt;преобразованию&lt;/a&gt; исходного значения сначала в базовый тип перечисления, а затем в тип перечисления.</target>
        </trans-unit>
        <trans-unit id="53c5be902373ad8ba2b8c3eceeaae48131069091" translate="yes" xml:space="preserve">
          <source>If the underlying type is not fixed, the result is unspecified(until C++17)undefined behavior(since C++17) if the value of expression is out of range (the range is all values possible for the smallest bit field large enough to hold all enumerators of the target enumeration).</source>
          <target state="translated">Если тип,лежащий в основе,не зафиксирован,то результат будет неуточненным(до C++17)неопределенным поведением(начиная с C++17),если значение выражения находится вне диапазона (диапазон-это все возможные значения для наименьшего битового поля,достаточно большого,чтобы вместить все числители целевого перечисления).</target>
        </trans-unit>
        <trans-unit id="9584e81563cc79a87482512943d106e7c6f35aeb" translate="yes" xml:space="preserve">
          <source>If the user defined function returns when handling &lt;code&gt;&lt;a href=&quot;sig_types&quot;&gt;SIGFPE&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;sig_types&quot;&gt;SIGILL&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;sig_types&quot;&gt;SIGSEGV&lt;/a&gt;&lt;/code&gt; or any other implementation-defined signal specifying a computational exception, the behavior is undefined.</source>
          <target state="translated">Если пользовательская функция возвращается при обработке &lt;code&gt;&lt;a href=&quot;sig_types&quot;&gt;SIGFPE&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;sig_types&quot;&gt;SIGILL&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;sig_types&quot;&gt;SIGSEGV&lt;/a&gt;&lt;/code&gt; или любого другого определенного реализацией сигнала, указывающего вычислительное исключение, поведение не определено.</target>
        </trans-unit>
        <trans-unit id="758bb6908f51c11c8477acd6f36292722e9b2a25" translate="yes" xml:space="preserve">
          <source>If the user-defined signal handling strategy is not set using &lt;code&gt;&lt;a href=&quot;signal&quot;&gt;std::signal()&lt;/a&gt;&lt;/code&gt; yet, it is implementation-defined whether the signal will be ignored or default handler will be invoked.</source>
          <target state="translated">Если определяемая пользователем стратегия обработки сигналов еще не установлена ​​с использованием &lt;code&gt;&lt;a href=&quot;signal&quot;&gt;std::signal()&lt;/a&gt;&lt;/code&gt; , определяется реализацией, будет ли сигнал игнорироваться или будет вызываться обработчик по умолчанию.</target>
        </trans-unit>
        <trans-unit id="ad569346ec44ef60f084b9ce61fd4164c7c32f63" translate="yes" xml:space="preserve">
          <source>If the usual deduction from &lt;code&gt;P&lt;/code&gt; and &lt;code&gt;A&lt;/code&gt; (as described above) fails, the following alternatives are additionally considered:</source>
          <target state="translated">Если обычный вычет из &lt;code&gt;P&lt;/code&gt; и &lt;code&gt;A&lt;/code&gt; (как описано выше) терпит неудачу, дополнительно рассматриваются следующие альтернативы:</target>
        </trans-unit>
        <trans-unit id="222dded9de677b2df12bcb544421882e3b919712" translate="yes" xml:space="preserve">
          <source>If the usual deduction from &lt;code&gt;P&lt;/code&gt; and &lt;code&gt;A&lt;/code&gt; fails, the following alternatives are additionally considered:</source>
          <target state="translated">Если обычный вычет из &lt;code&gt;P&lt;/code&gt; и &lt;code&gt;A&lt;/code&gt; терпит неудачу, дополнительно рассматриваются следующие альтернативы:</target>
        </trans-unit>
        <trans-unit id="2044c8cb072e19726cdc9c11e14101e5b7aa5788" translate="yes" xml:space="preserve">
          <source>If the value &lt;code&gt;​0​&lt;/code&gt; is added or subtracted from a pointer, the result is the pointer, unchanged. If two pointers point at the same object or are both one past the end of the same array, or both are null pointers, then the result of subtraction is equal to &lt;code&gt;(&lt;a href=&quot;../types/ptrdiff_t&quot;&gt;std::ptrdiff_t&lt;/a&gt;)0&lt;/code&gt;.</source>
          <target state="translated">Если значение &lt;code&gt;​0​&lt;/code&gt; добавляется или вычитается из указателя, результат является указателем, без изменений. Если два указателя указывают на один и тот же объект или оба находятся за концом одного и того же массива, или оба являются нулевыми указателями, то результат вычитания равен &lt;code&gt;(&lt;a href=&quot;../types/ptrdiff_t&quot;&gt;std::ptrdiff_t&lt;/a&gt;)0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="29e60c2f6520b56b9cab3b22f7509b4a9255b562" translate="yes" xml:space="preserve">
          <source>If the value in the first dimension is erroneous for any of these reasons,</source>
          <target state="translated">Если значение в первом измерении ошибочно по какой-либо из этих причин,</target>
        </trans-unit>
        <trans-unit id="030063b706611cf1e8e06a4ae59ec7618b58db95" translate="yes" xml:space="preserve">
          <source>If the value of &lt;code&gt;ch&lt;/code&gt; is neither representable as a &lt;code&gt;wchar_t&lt;/code&gt; nor equal to the value of the macro &lt;code&gt;WEOF&lt;/code&gt;, the behavior is undefined.</source>
          <target state="translated">Если значение &lt;code&gt;ch&lt;/code&gt; не может быть представлено как &lt;code&gt;wchar_t&lt;/code&gt; и не равно значению макроса &lt;code&gt;WEOF&lt;/code&gt; , поведение не определено.</target>
        </trans-unit>
        <trans-unit id="248a5c7e458d6f5d84a843bb9bad9a695797de69" translate="yes" xml:space="preserve">
          <source>If the value of &lt;code&gt;wc&lt;/code&gt; is neither representable as a &lt;code&gt;wchar_t&lt;/code&gt; nor equal to the value of the macro &lt;code&gt;WEOF&lt;/code&gt;, the behavior is undefined.</source>
          <target state="translated">Если значение &lt;code&gt;wc&lt;/code&gt; не представляется ни как &lt;code&gt;wchar_t&lt;/code&gt; , ни равно значению макроса &lt;code&gt;WEOF&lt;/code&gt; , поведение не определено.</target>
        </trans-unit>
        <trans-unit id="95ab164f16af6b727b63cdf344a7e218377e5641" translate="yes" xml:space="preserve">
          <source>If the value of base is &lt;code&gt;​0​&lt;/code&gt;, the numeric base is auto-detected: if the prefix is &lt;code&gt;0&lt;/code&gt;, the base is octal, if the prefix is &lt;code&gt;0x&lt;/code&gt; or &lt;code&gt;0X&lt;/code&gt;, the base is hexadecimal, otherwise the base is decimal.</source>
          <target state="translated">Если значение основания составляет &lt;code&gt;​0​&lt;/code&gt; , цифровая база определяется автоматически: если префикс &lt;code&gt;0&lt;/code&gt; , базовая восьмеричный, если префикс &lt;code&gt;0x&lt;/code&gt; или &lt;code&gt;0X&lt;/code&gt; , основание представляет собой шестнадцатеричное, в противном случае основание представляет собой десятичное.</target>
        </trans-unit>
        <trans-unit id="70a9c765b78740ba6c067e64a0ddbb7ae2ac6060" translate="yes" xml:space="preserve">
          <source>If the value of the integer literal is too big to fit in any of the types allowed by suffix/base combination and the compiler supports extended integer types (such as &lt;code&gt;__int128&lt;/code&gt;) the literal may be given the extended integer type -- otherwise the program is ill-formed.</source>
          <target state="translated">Если значение целочисленного литерала слишком велико, чтобы поместиться в любой из типов, разрешенных комбинацией суффикс / основание, и компилятор поддерживает расширенные целочисленные типы (такие как &lt;code&gt;__int128&lt;/code&gt; ), может быть присвоен расширенный целочисленный тип - в противном случае программа плохо сформирован.</target>
        </trans-unit>
        <trans-unit id="e8c33ee241a255a63ad79ee3a3348d39830a7425" translate="yes" xml:space="preserve">
          <source>If the value to be stored in &lt;code&gt;*exp&lt;/code&gt; is outside the range of &lt;code&gt;int&lt;/code&gt;, the behavior is unspecified.</source>
          <target state="translated">Если значение, которое будет сохранено в &lt;code&gt;*exp&lt;/code&gt; , выходит за пределы диапазона &lt;code&gt;int&lt;/code&gt; , поведение не определено.</target>
        </trans-unit>
        <trans-unit id="e2f54be830759cbe8fb68d644557c982f45181ea" translate="yes" xml:space="preserve">
          <source>If the value type is known to be a built-in type, the const variant should return by value.</source>
          <target state="translated">Если тип значения известен как встроенный,то вариант const должен возвращаться по значению.</target>
        </trans-unit>
        <trans-unit id="90307671f8933d3e9e5abc11ed1d390a29f7fef2" translate="yes" xml:space="preserve">
          <source>If the variant is &lt;a href=&quot;valueless_by_exception&quot;&gt;valueless_by_exception&lt;/a&gt;, returns &lt;a href=&quot;variant_npos&quot;&gt;variant_npos&lt;/a&gt;.</source>
          <target state="translated">Если вариант - &lt;a href=&quot;valueless_by_exception&quot;&gt;valueless_by_exception&lt;/a&gt; , возвращает &lt;a href=&quot;variant_npos&quot;&gt;вариант_npos&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="fa561126aaa10ae89524de188dae5e165b1fdb67" translate="yes" xml:space="preserve">
          <source>If the vector changed capacity, all of them. If not, none.</source>
          <target state="translated">Если вектор изменил емкость,то все они.Если нет,то нет.</target>
        </trans-unit>
        <trans-unit id="4d3428e86be4da734a232d16973b7cf3b93b4058" translate="yes" xml:space="preserve">
          <source>If the vector changed capacity, all of them. If not, only end().</source>
          <target state="translated">Если вектор изменил емкость,то все они.Если нет,то только конец().</target>
        </trans-unit>
        <trans-unit id="72ef803ef1a355b795f9869f64ff81133821942a" translate="yes" xml:space="preserve">
          <source>If the vector changed capacity, all of them. If not, only those after the insertion point.</source>
          <target state="translated">Если вектор изменил емкость,то все они.Если нет,то только те,что после точки вставки.</target>
        </trans-unit>
        <trans-unit id="eb75958a443f6e86954852258d39617127eed64b" translate="yes" xml:space="preserve">
          <source>If the wide character produced is the null character, the conversion state &lt;code&gt;*ps&lt;/code&gt; represents the initial shift state.</source>
          <target state="translated">Если полученный широкий символ является нулевым символом, состояние преобразования &lt;code&gt;*ps&lt;/code&gt; представляет начальное состояние сдвига.</target>
        </trans-unit>
        <trans-unit id="24382f133af9ec92a179262afb80b489903f3a55" translate="yes" xml:space="preserve">
          <source>If the wide character produced is the null character, the conversion state stored in &lt;code&gt;*ps&lt;/code&gt; is the initial shift state.</source>
          <target state="translated">Если полученный широкий символ является нулевым символом, состояние преобразования, сохраненное в &lt;code&gt;*ps&lt;/code&gt; , является исходным состоянием сдвига.</target>
        </trans-unit>
        <trans-unit id="0c78b539f6ef73fa78a596278e160b79dda2072b" translate="yes" xml:space="preserve">
          <source>If there are multiple declarations with different lexical orders (e.g. a function template declared with trailing return type, to be substituted after a parameter, and redeclared with ordinary return type that would be substituted before the parameter), then the program is ill-formed; no diagnostic required.</source>
          <target state="translated">Если существует несколько объявлений с различными лексическими ордерами (например,шаблон функции,объявленной с типом возврата трейлинга,который должен быть подставлен после параметра,и повторно объявленной с обычным типом возврата,который должен быть подставлен перед параметром),то программа плохо сформирована;диагностика не требуется.</target>
        </trans-unit>
        <trans-unit id="d2b18351965a2fe087972c4fc08282cc6ca24208" translate="yes" xml:space="preserve">
          <source>If there are multiple overloads of the function or operator being called, after the implicit conversion sequence is built from &lt;code&gt;T1&lt;/code&gt; to each available &lt;code&gt;T2&lt;/code&gt;, &lt;a href=&quot;overload_resolution&quot;&gt;overload resolution&lt;/a&gt; rules decide which overload is compiled.</source>
          <target state="translated">При наличии нескольких перегрузок функции или оператора вызывается, после того , как неявное последовательность преобразования построен из &lt;code&gt;T1&lt;/code&gt; в каждой доступной &lt;code&gt;T2&lt;/code&gt; , &lt;a href=&quot;overload_resolution&quot;&gt;разрешение перегрузки&lt;/a&gt; правила решить , какие перегрузки компилируется.</target>
        </trans-unit>
        <trans-unit id="a5a33472c5c80216c585ac1f3e2bb1b8d2b913cd" translate="yes" xml:space="preserve">
          <source>If there are multiple parameters, each &lt;code&gt;P&lt;/code&gt;/&lt;code&gt;A&lt;/code&gt; pair is deduced separately and the deduced template arguments are then combined. If deduction fails or is ambiguous for any &lt;code&gt;P&lt;/code&gt;/&lt;code&gt;A&lt;/code&gt; pair or if different pairs yield different deduced template arguments, or if any template argument remains neither deduced nor explicitly specified, compilation fails.</source>
          <target state="translated">Если имеется несколько параметров, каждая пара &lt;code&gt;P&lt;/code&gt; / &lt;code&gt;A&lt;/code&gt; выводится отдельно, а выводимые аргументы шаблона затем объединяются. Если вывод не удается или является неоднозначным для любой пары &lt;code&gt;P&lt;/code&gt; / &lt;code&gt;A&lt;/code&gt; , или если разные пары дают разные выведенные аргументы шаблона, или если какой-либо аргумент шаблона не остается ни выведенным, ни явно заданным, компиляция завершается неудачно.</target>
        </trans-unit>
        <trans-unit id="08ff4d812abea495b9856132aa9d1453e7f49ba6" translate="yes" xml:space="preserve">
          <source>If there are multiple return statements, they must all deduce to the same type.</source>
          <target state="translated">Если существует несколько заявлений о возврате,то все они должны быть выведены к одному и тому же типу.</target>
        </trans-unit>
        <trans-unit id="56e2a9dcbebace2c5e7ec9081f6a581a3eccd3f0" translate="yes" xml:space="preserve">
          <source>If there are no elements</source>
          <target state="translated">Если нет элементов</target>
        </trans-unit>
        <trans-unit id="2be453c0735328c6008b2c9ff54809c970ae7dd0" translate="yes" xml:space="preserve">
          <source>If there are no elements, the behavior is undefined.</source>
          <target state="translated">Если элементов нет,поведение не определено.</target>
        </trans-unit>
        <trans-unit id="60124398219caa2545336ef3688db0d123bcef47" translate="yes" xml:space="preserve">
          <source>If there are no matches, copies the entire sequence into &lt;code&gt;out&lt;/code&gt; as-is, by &lt;code&gt;out = &lt;a href=&quot;../algorithm/copy&quot;&gt;std::copy&lt;/a&gt;(first, last, out)&lt;/code&gt;</source>
          <target state="translated">Если совпадений нет, копируется вся последовательность в &lt;code&gt;out&lt;/code&gt; состояние как есть, путем &lt;code&gt;out = &lt;a href=&quot;../algorithm/copy&quot;&gt;std::copy&lt;/a&gt;(first, last, out)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="430a0a9ceb3976f6b074269c72597aae319e083f" translate="yes" xml:space="preserve">
          <source>If there are no more entries left in the currently iterated directory, the iteration is resumed over the parent directory. The process is repeated if the parent directory has no sibling entries that can to be iterated on. If the parent of the directory hierarchy that has been recursively iterated on is reached (there are no candidate entries at &lt;code&gt;depth() == 0)&lt;/code&gt;, &lt;code&gt;*this&lt;/code&gt; is set to an end iterator.</source>
          <target state="translated">Если в текущем итеративном каталоге больше не осталось записей, итерация возобновляется в родительском каталоге. Процесс повторяется, если в родительском каталоге нет записей одного уровня, которые можно повторять. Если родительский элемент иерархии каталогов, который был рекурсивно повторен, достигнут (нет записей-кандидатов на &lt;code&gt;depth() == 0)&lt;/code&gt; , &lt;code&gt;*this&lt;/code&gt; устанавливается конечный итератор.</target>
        </trans-unit>
        <trans-unit id="786c19346a6501f7f519d77c25d16a5bd6120203" translate="yes" xml:space="preserve">
          <source>If there is no associated mutex or the mutex is not locked, &lt;code&gt;&lt;a href=&quot;../../error/system_error&quot;&gt;std::system_error&lt;/a&gt;&lt;/code&gt; with an error code of &lt;code&gt;&lt;a href=&quot;../../error/errc&quot;&gt;std::errc::operation_not_permitted&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">Если нет ассоциированного мьютекса или мьютекс не заблокирован, &lt;code&gt;&lt;a href=&quot;../../error/system_error&quot;&gt;std::system_error&lt;/a&gt;&lt;/code&gt; с кодом ошибки &lt;code&gt;&lt;a href=&quot;../../error/errc&quot;&gt;std::errc::operation_not_permitted&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="cd20e611e7f59595531f451ca3dfeabb2921c4e5" translate="yes" xml:space="preserve">
          <source>If there is no associated mutex, &lt;code&gt;&lt;a href=&quot;../../error/system_error&quot;&gt;std::system_error&lt;/a&gt;&lt;/code&gt; with an error code of &lt;code&gt;&lt;a href=&quot;../../error/errc&quot;&gt;std::errc::operation_not_permitted&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">Если нет ассоциированного мьютекса, &lt;code&gt;&lt;a href=&quot;../../error/system_error&quot;&gt;std::system_error&lt;/a&gt;&lt;/code&gt; с кодом ошибки &lt;code&gt;&lt;a href=&quot;../../error/errc&quot;&gt;std::errc::operation_not_permitted&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5d214d3c80c859a6e49e6fef5913cd6a8474d164" translate="yes" xml:space="preserve">
          <source>If there is no corresponding call to &lt;code&gt;&lt;a href=&quot;va_start&quot;&gt;va_start&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;va_copy&quot;&gt;va_copy&lt;/a&gt;&lt;/code&gt;, or if &lt;code&gt;va_end&lt;/code&gt; is not called before a function that calls &lt;code&gt;&lt;a href=&quot;va_start&quot;&gt;va_start&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;va_copy&quot;&gt;va_copy&lt;/a&gt;&lt;/code&gt; returns, the behavior is undefined.</source>
          <target state="translated">Если нет соответствующего вызова &lt;code&gt;&lt;a href=&quot;va_start&quot;&gt;va_start&lt;/a&gt;&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;va_copy&quot;&gt;va_copy&lt;/a&gt;&lt;/code&gt; , или если &lt;code&gt;va_end&lt;/code&gt; не вызывается до того, как функция, которая вызывает &lt;code&gt;&lt;a href=&quot;va_start&quot;&gt;va_start&lt;/a&gt;&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;va_copy&quot;&gt;va_copy&lt;/a&gt;&lt;/code&gt; , возвращает поведение, оно не определено.</target>
        </trans-unit>
        <trans-unit id="82e2ba4ed8370caec8cb2a4375b819fec9dd1a0f" translate="yes" xml:space="preserve">
          <source>If there is no pattern match, returns a value of type &lt;code&gt;from_chars_result&lt;/code&gt; such that &lt;code&gt;ptr&lt;/code&gt; equals &lt;code&gt;first&lt;/code&gt; and &lt;code&gt;ec&lt;/code&gt; equals &lt;code&gt;&lt;a href=&quot;../error/errc&quot;&gt;std::errc::invalid_argument&lt;/a&gt;&lt;/code&gt;. &lt;code&gt;value&lt;/code&gt; is unmodified.</source>
          <target state="translated">Если нет совпадения с шаблоном, возвращает значение типа &lt;code&gt;from_chars_result&lt;/code&gt; , такое, что &lt;code&gt;ptr&lt;/code&gt; равен &lt;code&gt;first&lt;/code&gt; , а &lt;code&gt;ec&lt;/code&gt; равен &lt;code&gt;&lt;a href=&quot;../error/errc&quot;&gt;std::errc::invalid_argument&lt;/a&gt;&lt;/code&gt; . &lt;code&gt;value&lt;/code&gt; не изменяется.</target>
        </trans-unit>
        <trans-unit id="bb2824bbf3f97be3e717eef3b6756fb7dd5b0ccf" translate="yes" xml:space="preserve">
          <source>If there is no return statement or if the argument of the return statement is a void expression, the declared return type must be either &lt;code&gt;decltype(auto)&lt;/code&gt;, in which case the deduced return type is &lt;code&gt;void&lt;/code&gt;, or (possibly cv-qualified) &lt;code&gt;auto&lt;/code&gt; , in which case the deduced return type is then (identically cv-qualified) &lt;code&gt;void&lt;/code&gt;.</source>
          <target state="translated">Если нет оператора возврата или если аргумент оператора возврата является выражением void, объявленный тип возврата должен быть либо &lt;code&gt;decltype(auto)&lt;/code&gt; , в этом случае выведенный тип возврата &lt;code&gt;void&lt;/code&gt; , либо (возможно, cv-квалифицированный) &lt;code&gt;auto&lt;/code&gt; , в этом случае выведенный тип возврата тогда (идентично cv-квалифицированному) &lt;code&gt;void&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9786fb90520614ec4de44d4ccd5a94337ce70dc0" translate="yes" xml:space="preserve">
          <source>If there is no value of type &lt;code&gt;To&lt;/code&gt; corresponding to the value representation produced, the behavior is undefined. If there are multiple such values, which value is produced is unspecified.</source>
          <target state="translated">Если нет значения типа &lt;code&gt;To&lt;/code&gt; , соответствующего произведенному представлению значения, поведение не определено. Если таких значений несколько, какое значение создается, не указывается.</target>
        </trans-unit>
        <trans-unit id="08e7e744ae0e0c5037802c6defe497d81baa4ef8" translate="yes" xml:space="preserve">
          <source>If there is not enough memory, the old memory block is not freed and null pointer is returned.</source>
          <target state="translated">Если памяти недостаточно,старый блок памяти не освобождается и возвращается нулевой указатель.</target>
        </trans-unit>
        <trans-unit id="75b29d8574fca6602e9dfcd68f07686982e86cb2" translate="yes" xml:space="preserve">
          <source>If there is nothing on the left hand side of the &lt;code&gt;::&lt;/code&gt;, the lookup considers only declarations made in the global namespace scope (or introduced into the global namespace by a &lt;a href=&quot;namespace&quot;&gt;using declaration&lt;/a&gt;). This makes it possible to refer to such names even if they were hidden by a local declaration:</source>
          <target state="translated">Если в левой части &lt;code&gt;::&lt;/code&gt; нет ничего , то поиск рассматривает только объявления, сделанные в глобальной области имен (или введенные в глобальное пространство имен с &lt;a href=&quot;namespace&quot;&gt;помощью объявления использования&lt;/a&gt; ). Это позволяет ссылаться на такие имена, даже если они были скрыты локальной декларацией:</target>
        </trans-unit>
        <trans-unit id="a39354352c3a36abb4078e05bc0601edf6cd7f44" translate="yes" xml:space="preserve">
          <source>If there was a &lt;code&gt;memory_order_seq_cst&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;atomic_thread_fence&quot;&gt;std::atomic_thread_fence&lt;/a&gt;&lt;/code&gt; operation X</source>
          <target state="translated">Если была &lt;code&gt;memory_order_seq_cst&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;atomic_thread_fence&quot;&gt;std::atomic_thread_fence&lt;/a&gt;&lt;/code&gt; операция X</target>
        </trans-unit>
        <trans-unit id="ad371531997ade6500f19cfb02b883b25ff79f63" translate="yes" xml:space="preserve">
          <source>If these functions fail to meet the postcondition (&lt;code&gt;lock.owns_lock()==true&lt;/code&gt; and &lt;code&gt;lock.mutex()&lt;/code&gt; is locked by the calling thread), &lt;code&gt;&lt;a href=&quot;../../error/terminate&quot;&gt;std::terminate&lt;/a&gt;&lt;/code&gt; is called. For example, this could happen if relocking the mutex throws an exception,</source>
          <target state="translated">Если эти функции не удовлетворяют постусловию ( &lt;code&gt;lock.owns_lock()==true&lt;/code&gt; и &lt;code&gt;lock.mutex()&lt;/code&gt; блокируется вызывающим потоком), вызывается &lt;code&gt;&lt;a href=&quot;../../error/terminate&quot;&gt;std::terminate&lt;/a&gt;&lt;/code&gt; . Например, это может произойти, если при блокировке мьютекса возникнет исключение,</target>
        </trans-unit>
        <trans-unit id="8b7c68c75d237fbfbeeafab70e579d60f492f831" translate="yes" xml:space="preserve">
          <source>If these functions fail to meet the postcondition (&lt;code&gt;lock&lt;/code&gt; is locked by the calling thread), &lt;code&gt;&lt;a href=&quot;../../error/terminate&quot;&gt;std::terminate&lt;/a&gt;&lt;/code&gt; is called. For example, this could happen if relocking the mutex throws an exception,</source>
          <target state="translated">Если эти функции не удовлетворяют постусловию ( &lt;code&gt;lock&lt;/code&gt; блокируется вызывающим потоком), вызывается &lt;code&gt;&lt;a href=&quot;../../error/terminate&quot;&gt;std::terminate&lt;/a&gt;&lt;/code&gt; . Например, это может произойти, если при блокировке мьютекса возникнет исключение,</target>
        </trans-unit>
        <trans-unit id="e64ebeb583017ab34a1b336b3949d0e606ed7464" translate="yes" xml:space="preserve">
          <source>If these functions fail to meet the postconditions (&lt;code&gt;lock.owns_lock()==true&lt;/code&gt; and &lt;code&gt;lock.mutex()&lt;/code&gt; is locked by the calling thread), &lt;code&gt;&lt;a href=&quot;../../error/terminate&quot;&gt;std::terminate&lt;/a&gt;&lt;/code&gt; is called. For example, this could happen if relocking the mutex throws an exception,</source>
          <target state="translated">Если эти функции не удовлетворяют постусловиям ( &lt;code&gt;lock.owns_lock()==true&lt;/code&gt; и &lt;code&gt;lock.mutex()&lt;/code&gt; блокируется вызывающим потоком), вызывается &lt;code&gt;&lt;a href=&quot;../../error/terminate&quot;&gt;std::terminate&lt;/a&gt;&lt;/code&gt; . Например, это может произойти, если при блокировке мьютекса возникнет исключение,</target>
        </trans-unit>
        <trans-unit id="80d1cce971ef81ebeb27b3f75282ca12f479c4a3" translate="yes" xml:space="preserve">
          <source>If these functions fail to meet the postconditions (&lt;code&gt;lock&lt;/code&gt; is locked by the calling thread), &lt;code&gt;&lt;a href=&quot;../../error/terminate&quot;&gt;std::terminate&lt;/a&gt;&lt;/code&gt; is called. For example, this could happen if relocking the mutex throws an exception,</source>
          <target state="translated">Если эти функции не удовлетворяют постусловиям ( &lt;code&gt;lock&lt;/code&gt; блокируется вызывающим потоком), вызывается &lt;code&gt;&lt;a href=&quot;../../error/terminate&quot;&gt;std::terminate&lt;/a&gt;&lt;/code&gt; . Например, это может произойти, если при блокировке мьютекса возникнет исключение,</target>
        </trans-unit>
        <trans-unit id="3d778c344c068708c3e9722504ddb91a10967713" translate="yes" xml:space="preserve">
          <source>If this &lt;code&gt;codecvt&lt;/code&gt; facet does not define a conversion, no characters are converted. &lt;code&gt;to_next&lt;/code&gt; is set to be equal to &lt;code&gt;to&lt;/code&gt;, &lt;code&gt;state&lt;/code&gt; is unchanged, and &lt;code&gt;&lt;a href=&quot;../codecvt_base&quot;&gt;std::codecvt_base::noconv&lt;/a&gt;&lt;/code&gt; is returned.</source>
          <target state="translated">Если этот &lt;code&gt;codecvt&lt;/code&gt; фасет не определяет преобразование, никакие символы не преобразуются. &lt;code&gt;to_next&lt;/code&gt; устанавливается равным &lt;code&gt;to&lt;/code&gt; , &lt;code&gt;state&lt;/code&gt; не меняется, и &lt;code&gt;&lt;a href=&quot;../codecvt_base&quot;&gt;std::codecvt_base::noconv&lt;/a&gt;&lt;/code&gt; возвращается.</target>
        </trans-unit>
        <trans-unit id="aacf8a59ed2ae04fea1befba59a2f4989fe43a0b" translate="yes" xml:space="preserve">
          <source>If this &lt;code&gt;wstring_convert&lt;/code&gt; object was constructed without a user-supplied byte-error string, throws &lt;code&gt;&lt;a href=&quot;../../error/range_error/range_error&quot;&gt;std::range_error&lt;/a&gt;&lt;/code&gt; on conversion failure.</source>
          <target state="translated">Если этот объект &lt;code&gt;wstring_convert&lt;/code&gt; был создан без предоставленной пользователем строки ошибки байта, в &lt;code&gt;&lt;a href=&quot;../../error/range_error/range_error&quot;&gt;std::range_error&lt;/a&gt;&lt;/code&gt; сбоя преобразования выдается std :: range_error .</target>
        </trans-unit>
        <trans-unit id="cbcd6f179051e3d4d790103a0692450f238f91b6" translate="yes" xml:space="preserve">
          <source>If this &lt;code&gt;wstring_convert&lt;/code&gt; object was constructed without a user-supplied wide-error string, throws &lt;code&gt;&lt;a href=&quot;../../error/range_error/range_error&quot;&gt;std::range_error&lt;/a&gt;&lt;/code&gt; on conversion failure.</source>
          <target state="translated">Если этот объект &lt;code&gt;wstring_convert&lt;/code&gt; был создан без предоставленной пользователем строки с широкой ошибкой, в &lt;code&gt;&lt;a href=&quot;../../error/range_error/range_error&quot;&gt;std::range_error&lt;/a&gt;&lt;/code&gt; сбоя преобразования выдается std :: range_error .</target>
        </trans-unit>
        <trans-unit id="f6ba9b5bd88a92b215f9d46a302f511d4c0d3235" translate="yes" xml:space="preserve">
          <source>If this function is called after I/O has occurred on the standard stream, the behavior is implementation-defined: implementations range from no effect to destroying the read buffer.</source>
          <target state="translated">Если эта функция вызывается после того,как вход/выход произошел в стандартном потоке,поведение определяется реализацией:реализации варьируются от отсутствия эффекта до уничтожения буфера чтения.</target>
        </trans-unit>
        <trans-unit id="7ab8ebc954b0557ea6a9a5ccedd0ab0cb9a2ceb2" translate="yes" xml:space="preserve">
          <source>If this function is called twice on the same &lt;code&gt;obj&lt;/code&gt;, the behavior is undefined.</source>
          <target state="translated">Если эта функция вызывается дважды в одном и том же &lt;code&gt;obj&lt;/code&gt; , поведение не определено.</target>
        </trans-unit>
        <trans-unit id="5b1e8e769c369fe401942d10347ef2341bebc1e8" translate="yes" xml:space="preserve">
          <source>If transfer of control enters the scope of any automatic variables (e.g. by jumping forward over a declaration statement), the program is ill-formed (cannot be compiled), unless all variables whose scope is entered have.</source>
          <target state="translated">Если передача управления входит в область действия любых автоматических переменных (например,перепрыгивая через оператор объявления),то программа плохо сформирована (не может быть скомпилирована),если только не все переменные,область действия которых введена.</target>
        </trans-unit>
        <trans-unit id="9007006fca17d8a04caf552baacfbe914165d918" translate="yes" xml:space="preserve">
          <source>If transfer of control exits the scope of any automatic variables (e.g. by jumping backwards to a point before the declarations of such variables or by jumping forward out of a compound statement where the variables are scoped), the destructors are called for all variables whose scope was exited, in the order opposite to the order of their construction.</source>
          <target state="translated">Если передача управления выходит из области видимости любых автоматических переменных (например,при прыжке назад в точку перед объявлением таких переменных или при прыжке вперед из составного оператора,в котором эти переменные находятся в области видимости),то деструкторы вызываются для всех переменных,область видимости которых вышла из области видимости,в порядке,противоположном порядку их построения.</target>
        </trans-unit>
        <trans-unit id="96de619385ef72541fd42f53b710eb1ba726dc0a" translate="yes" xml:space="preserve">
          <source>If two &lt;code&gt;Key&lt;/code&gt;s are equal according to &lt;code&gt;Pred&lt;/code&gt;, &lt;code&gt;Hash&lt;/code&gt; must return the same value for both keys.</source>
          <target state="translated">Если два &lt;code&gt;Key&lt;/code&gt; равны согласно &lt;code&gt;Pred&lt;/code&gt; , &lt;code&gt;Hash&lt;/code&gt; должен вернуть одинаковое значение для обоих ключей.</target>
        </trans-unit>
        <trans-unit id="21514f17271611919ab5d31d97737af032553cf0" translate="yes" xml:space="preserve">
          <source>If two conversion sequences are indistinguishable because they have the same rank, the following additional rules apply:</source>
          <target state="translated">Если две последовательности преобразования неотличимы друг от друга,так как имеют один и тот же ранг,то применяются следующие дополнительные правила:</target>
        </trans-unit>
        <trans-unit id="236b56e175db6d0402c006ec6f6fe29bfcd434e0" translate="yes" xml:space="preserve">
          <source>If two or more overloads accept different pointer types, an overload for &lt;code&gt;std::nullptr_t&lt;/code&gt; is necessary to accept a null pointer argument.</source>
          <target state="translated">Если две или более перегрузки принимают разные типы указателей, перегрузка для &lt;code&gt;std::nullptr_t&lt;/code&gt; необходима для принятия аргумента нулевого указателя.</target>
        </trans-unit>
        <trans-unit id="1df13f76013467c8d1808876f2f6ad361b81ec46" translate="yes" xml:space="preserve">
          <source>If two pointers are not specified to compare greater or compare equal, the result of the comparison is unspecified. The result may be nondeterministic, and need not be consistent even for multiple evaluations of the same expression with the same operands in the same execution of the program:</source>
          <target state="translated">Если два указателя не указаны для сравнения большего или равного,то результат сравнения не указан.Результат может быть недетерминированным,и не обязательно быть последовательным даже для множественных оценок одного и того же выражения с одними и теми же операндами в одном и том же выполнении программы:</target>
        </trans-unit>
        <trans-unit id="54c474a432a885a9d80c638012c2da37dcdf5a0e" translate="yes" xml:space="preserve">
          <source>If two ranges have equivalent elements and are of the same length, then the ranges are lexicographically</source>
          <target state="translated">Если два диапазона имеют эквивалентные элементы и имеют одинаковую длину,то диапазоны являются лексикографически</target>
        </trans-unit>
        <trans-unit id="dea9e99a4902829c785e86953d9771a67436d749" translate="yes" xml:space="preserve">
          <source>If two thread identifiers compare equal, they have identical textual representations; if they do not compare equal, their representations are distinct.</source>
          <target state="translated">Если два идентификатора потоков сравнивают равные,то они имеют одинаковые текстовые представления;если же они не сравнивают равные,то их представления различаются.</target>
        </trans-unit>
        <trans-unit id="44df2c42d0c8b0977cc12b1567332b861f35e2c9" translate="yes" xml:space="preserve">
          <source>If two union members are standard-layout types, it's well-defined to examine their common subsequence on any compiler.</source>
          <target state="translated">Если два члена союза являются стандартными типами подпоследовательностей,то это хорошо определено для изучения их общей подпоследовательности на любом компиляторе.</target>
        </trans-unit>
        <trans-unit id="905593757752d3cb5b8a000e5d6df93d8badb63b" translate="yes" xml:space="preserve">
          <source>If two using-declarations inherit the constructor with the same signature (from two direct base classes), the program is ill-formed.</source>
          <target state="translated">Если две use-декларации наследуют конструктор с одной и той же сигнатурой (от двух прямых базовых классов),то программа плохо сформирована.</target>
        </trans-unit>
        <trans-unit id="b3ee41429cd3e4ea61f8eae244494a1cc4dbc646" translate="yes" xml:space="preserve">
          <source>If type is an array type, an array of objects is initialized.</source>
          <target state="translated">Если тип является типом массива,то инициализируется массив объектов.</target>
        </trans-unit>
        <trans-unit id="dfd366835c89e7a8dac1ada14ac3a1a2f256aa18" translate="yes" xml:space="preserve">
          <source>If type-constraint is &lt;code&gt;Concept&amp;lt;A&lt;sub&gt;1&lt;/sub&gt;, ..., A&lt;sub&gt;n&lt;/sub&gt;&amp;gt;&lt;/code&gt;, then the constraint expression &lt;code&gt;Concept&amp;lt;T, A&lt;sub&gt;1&lt;/sub&gt;, ..., A&lt;sub&gt;n&lt;/sub&gt;&amp;gt;&lt;/code&gt; must be valid and return &lt;code&gt;true&lt;/code&gt;;</source>
          <target state="translated">Если тип-ограничение &lt;code&gt;Concept&amp;lt;A&lt;sub&gt;1&lt;/sub&gt;, ..., A&lt;sub&gt;n&lt;/sub&gt;&amp;gt;&lt;/code&gt; , то выражение ограничения &lt;code&gt;Concept&amp;lt;T, A&lt;sub&gt;1&lt;/sub&gt;, ..., A&lt;sub&gt;n&lt;/sub&gt;&amp;gt;&lt;/code&gt; должен быть действительным и вернуть &lt;code&gt;true&lt;/code&gt; ;</target>
        </trans-unit>
        <trans-unit id="37e1efeb1f04dd65befd738a35a8fbab85af47d5" translate="yes" xml:space="preserve">
          <source>If type-constraint is present, let &lt;code&gt;T&lt;/code&gt; be the type deduced for the placeholder, &lt;code&gt;T&lt;/code&gt; must satisfy the immediately-declared constraint of type-constraint. That is,</source>
          <target state="translated">Если есть ограничение типа, пусть &lt;code&gt;T&lt;/code&gt; будет типом, выведенным для заполнителя, &lt;code&gt;T&lt;/code&gt; должен удовлетворять объявленному немедленно ограничению типа. То есть,</target>
        </trans-unit>
        <trans-unit id="60c6cdefb849b977d1ac7bc22c41f84525eb69b1" translate="yes" xml:space="preserve">
          <source>If value-initialization in overload (1) is undesirable, for example, if the elements are of non-class type and zeroing out is not needed, it can be avoided by providing a &lt;a href=&quot;http://stackoverflow.com/a/21028912/273767&quot;&gt;custom Allocator::construct&lt;/a&gt;.</source>
          <target state="translated">Если инициализация значения в overload (1) нежелательна, например, если элементы принадлежат не классу и обнуление не требуется, этого можно избежать, предоставив &lt;a href=&quot;http://stackoverflow.com/a/21028912/273767&quot;&gt;пользовательскую конструкцию Allocator ::&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9f66ab74451a3db452059ec3845f07a89e06bbf3" translate="yes" xml:space="preserve">
          <source>If wc is the null wide character &lt;code&gt;L'\0'&lt;/code&gt;, a null byte is stored, preceded by any shift sequence necessary to restore the initial shift state and the conversion state parameter &lt;code&gt;*ps&lt;/code&gt; is updated to represent the initial shift state.</source>
          <target state="translated">Если wc является широким нулевым символом &lt;code&gt;L'\0'&lt;/code&gt; , сохраняется нулевой байт, которому предшествует любая последовательность сдвигов, необходимая для восстановления начального состояния сдвига, а параметр &lt;code&gt;*ps&lt;/code&gt; состояния преобразования обновляется для представления начального состояния сдвига.</target>
        </trans-unit>
        <trans-unit id="32c015539aa6def36ac45f02ee69383d444c9a17" translate="yes" xml:space="preserve">
          <source>If width specifier is used, matches up to</source>
          <target state="translated">Если используется спецификатор ширины,то соответствует до</target>
        </trans-unit>
        <trans-unit id="80643aeb5f10297c8773a32774b36761e19c9f6e" translate="yes" xml:space="preserve">
          <source>If x is zero and y is infinite or if x is infinite and y is zero, and z is a NaN, then NaN is returned and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; may be raised</source>
          <target state="translated">Если x равен нулю и y бесконечен или если x бесконечен и y равен нулю, а z является NaN, то возвращается NaN, и &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; может быть повышен</target>
        </trans-unit>
        <trans-unit id="217b0f1a492e46dd9c7d22b89fac1d204972e19f" translate="yes" xml:space="preserve">
          <source>If x is zero and y is infinite or if x is infinite and y is zero, and z is not a NaN, then NaN is returned and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; is raised</source>
          <target state="translated">Если х равен нулю , а у бесконечен или , если х бесконечно и у равна нулю, а г не является NaN, то NaN , возвращается и &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; поднимается</target>
        </trans-unit>
        <trans-unit id="46f35d1f1e835536b48c1d1451cead305f826b6a" translate="yes" xml:space="preserve">
          <source>If x or y are NaN, NaN is returned</source>
          <target state="translated">Если x или y-NaN,NaN возвращается.</target>
        </trans-unit>
        <trans-unit id="448389c4ec48e9adff6b8542b1d7d5e0005baf1b" translate="yes" xml:space="preserve">
          <source>If x*y is an exact infinity and z is an infinity with the opposite sign, NaN is returned and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; is raised</source>
          <target state="translated">Если х * у является точной бесконечностью и г представляет собой бесконечность с противоположным знаком, NaN возвращается и &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; поднимается</target>
        </trans-unit>
        <trans-unit id="3bdeffa5a91b0032e30c68e073ce8335607fac7a" translate="yes" xml:space="preserve">
          <source>If you do not have C++11, an equivalent to &lt;code&gt;std::find_if_not&lt;/code&gt; is to use &lt;code&gt;std::find_if&lt;/code&gt; with the negated predicate.</source>
          <target state="translated">Если у вас нет C ++ 11, эквивалент &lt;code&gt;std::find_if_not&lt;/code&gt; является использование &lt;code&gt;std::find_if&lt;/code&gt; с отрицательным предикатом.</target>
        </trans-unit>
        <trans-unit id="dee1d062b9bd3ef2ac4463366425592d8bf6079d" translate="yes" xml:space="preserve">
          <source>If z is NaN, and x*y aren't 0*Inf or Inf*0, then NaN is returned (without FE_INVALID)</source>
          <target state="translated">Если z-NaN,а x*y-не 0*Inf или Inf*0,то возвращается NaN (без FE_INVALID)</target>
        </trans-unit>
        <trans-unit id="fede8b50b6882e5d3ce2a02e4778a6b33e6bfd1e" translate="yes" xml:space="preserve">
          <source>If |arg| &amp;gt; 1, a domain error occurs and NaN is returned.</source>
          <target state="translated">Если | arg | &amp;gt; 1, возникает ошибка домена и возвращается NaN.</target>
        </trans-unit>
        <trans-unit id="19ae8a036da573c60fcd648999f547940ac705f3" translate="yes" xml:space="preserve">
          <source>If |k|&amp;gt;1, a domain error may occur</source>
          <target state="translated">Если | k |&amp;gt; 1, может возникнуть ошибка домена</target>
        </trans-unit>
        <trans-unit id="f54d83c12cb912afe24330261b82ab51323c3c37" translate="yes" xml:space="preserve">
          <source>If |x| &amp;gt; 1, a domain error may occur</source>
          <target state="translated">Если | х | &amp;gt; 1, может возникнуть ошибка домена</target>
        </trans-unit>
        <trans-unit id="124d00d6f3d9dc4a6bd589c99e1ea07d87b1c00a" translate="yes" xml:space="preserve">
          <source>If, after a using-directive was used to nominate some namespace, the namespace is extended and additional members and/or using-directives are added to it, those additional members and the additional namespaces are visible through the using-directive (in contrast with using-declaration).</source>
          <target state="translated">Если после того как Using-директива была использована для назначения некоторого пространства имён,то это пространство имён расширяется и к нему добавляются дополнительные члены и/или Using-директивы,то эти дополнительные члены и дополнительные пространства имён видны через Using-директиву (в отличие от use-declaration).</target>
        </trans-unit>
        <trans-unit id="f18ec98606b2fb57c51cf2d2b42ed110712ce687" translate="yes" xml:space="preserve">
          <source>If, after considering all pairs of overloaded templates, there is one that is unambiguously more specialized than all others, that template's specialization is selected, otherwise compilation fails.</source>
          <target state="translated">Если,рассмотрев все пары перегруженных шаблонов,есть один,который однозначно более специализированный,чем все остальные,то выбирается специализация этого шаблона,иначе компиляция не удастся.</target>
        </trans-unit>
        <trans-unit id="18db54187de2ad0a31a7c5e4bdded4c034fc402d" translate="yes" xml:space="preserve">
          <source>If, after construction, the member &lt;code&gt;regex_iterator&lt;/code&gt; is not an end-of-sequence iterator, sets the member pointer to the address of the current &lt;code&gt;&lt;a href=&quot;../sub_match&quot;&gt;std::sub_match&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Если после построения член &lt;code&gt;regex_iterator&lt;/code&gt; не является итератором конца последовательности, устанавливает указатель члена на адрес текущего &lt;code&gt;&lt;a href=&quot;../sub_match&quot;&gt;std::sub_match&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="24d2b4c0d32e555ffdf12e4f24627c557a463748" translate="yes" xml:space="preserve">
          <source>If, after copying the terminating null character from &lt;code&gt;src&lt;/code&gt;, &lt;code&gt;count&lt;/code&gt; is not reached, additional null characters are written to &lt;code&gt;dest&lt;/code&gt; until the total of &lt;code&gt;count&lt;/code&gt; characters have been written.</source>
          <target state="translated">Если после копирования завершающего нулевого символа из &lt;code&gt;src&lt;/code&gt; , &lt;code&gt;count&lt;/code&gt; не будет достигнуто, дополнительные символы нуль не записываются &lt;code&gt;dest&lt;/code&gt; до тех пор , в общей сложности &lt;code&gt;count&lt;/code&gt; символов были написаны.</target>
        </trans-unit>
        <trans-unit id="d6321b986a2eb461234e0b8b628d35dcf35b6aeb" translate="yes" xml:space="preserve">
          <source>If, after copying the terminating null wide character from &lt;code&gt;src&lt;/code&gt;, &lt;code&gt;count&lt;/code&gt; is not reached, additional null wide characters are written to &lt;code&gt;dest&lt;/code&gt; until the total of &lt;code&gt;count&lt;/code&gt; characters have been written.</source>
          <target state="translated">Если после копирования завершающих нулевого символа из &lt;code&gt;src&lt;/code&gt; , &lt;code&gt;count&lt;/code&gt; не будет достигнут, дополнительные нулевые широкие символы не записываются в &lt;code&gt;dest&lt;/code&gt; , пока сумма &lt;code&gt;count&lt;/code&gt; символов были написана.</target>
        </trans-unit>
        <trans-unit id="2b833da015ca09bbc003a6a35757746d54b28eaa" translate="yes" xml:space="preserve">
          <source>If, after overload resolution, the order of declaration of the aggregate's members does not match for the selected overload, the initialization of the parameter will be ill-formed.</source>
          <target state="translated">Если после разрешения перегрузки порядок объявления членов агрегата не совпадает с выбранной перегрузкой,инициализация параметра будет плохо оформлена.</target>
        </trans-unit>
        <trans-unit id="4344e13bb6aa8857aeb8da90f2cfb52094846e93" translate="yes" xml:space="preserve">
          <source>If, after the using-declaration was used to take a member from a namespace, the namespace is extended and additional declarations for the same name are introduced, those additional declarations do not become visible through the using-declaration (in contrast with using-directive). One exception is when a using-declaration names a class template: partial specializations introduced later are effectively visible, because their &lt;a href=&quot;lookup&quot;&gt;lookup&lt;/a&gt; proceeds through the primary template.</source>
          <target state="translated">Если после того, как объявление использования использовалось для извлечения члена из пространства имен, пространство имен расширяется и вводятся дополнительные объявления для того же имени, эти дополнительные объявления не становятся видимыми через объявление использования (в отличие от директивы using-директивы ). Единственное исключение - когда объявление-использование называет шаблон класса: частичные специализации, представленные позже, эффективно видны, потому что их &lt;a href=&quot;lookup&quot;&gt;поиск&lt;/a&gt; проходит через основной шаблон.</target>
        </trans-unit>
        <trans-unit id="dbce6be800bfbd414094242237e485ad6d751c14" translate="yes" xml:space="preserve">
          <source>If, by the time &lt;code&gt;call_once&lt;/code&gt; is called, &lt;code&gt;flag&lt;/code&gt; indicates that &lt;code&gt;f&lt;/code&gt; was already called, &lt;code&gt;call_once&lt;/code&gt; returns right away (such a call to &lt;code&gt;call_once&lt;/code&gt; is known as</source>
          <target state="translated">Если, к тому времени &lt;code&gt;call_once&lt;/code&gt; называется, &lt;code&gt;flag&lt;/code&gt; указывает на то, что &lt;code&gt;f&lt;/code&gt; уже называется, &lt;code&gt;call_once&lt;/code&gt; возвращается сразу же (например , вызов &lt;code&gt;call_once&lt;/code&gt; известен как</target>
        </trans-unit>
        <trans-unit id="515903e5cd9a30bdc013b27094038c879ea5e3ca" translate="yes" xml:space="preserve">
          <source>If, instead of a function body, the special syntax &lt;code&gt;= delete&amp;nbsp;;&lt;/code&gt; is used, the function is defined as</source>
          <target state="translated">Если вместо тела функции используется специальный синтаксис &lt;code&gt;= delete&amp;nbsp;;&lt;/code&gt; используется, функция определяется как</target>
        </trans-unit>
        <trans-unit id="1fcb027646c98dda89397bc3d304d3c40f2112ab" translate="yes" xml:space="preserve">
          <source>If, prior to this call, &lt;code&gt;*this&lt;/code&gt; has an associated mutex ((&lt;code&gt;&lt;a href=&quot;mutex&quot;&gt;mutex()&lt;/a&gt;&lt;/code&gt; returns a non-null pointer) and has acquired ownership of it (&lt;code&gt;owns()&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt;), the mutex is unlocked by calling &lt;code&gt;&lt;a href=&quot;../shared_mutex/unlock_shared&quot;&gt;unlock_shared()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Если перед этим вызовом &lt;code&gt;*this&lt;/code&gt; него есть связанный мьютекс (( &lt;code&gt;&lt;a href=&quot;mutex&quot;&gt;mutex()&lt;/a&gt;&lt;/code&gt; возвращает ненулевой указатель) и он приобрел владение им ( &lt;code&gt;owns()&lt;/code&gt; возвращает &lt;code&gt;true&lt;/code&gt; ), мьютекс разблокируется путем вызова &lt;code&gt;&lt;a href=&quot;../shared_mutex/unlock_shared&quot;&gt;unlock_shared()&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cddfcce1d6482355377933166f2bf61ba8023df9" translate="yes" xml:space="preserve">
          <source>If, when this instance of &lt;code&gt;&lt;a href=&quot;../ctype&quot;&gt;std::ctype&lt;/a&gt;&amp;lt;char&amp;gt;&lt;/code&gt; was constructed, a custom classification table was provided and the second argument to the constructor (the boolean &lt;code&gt;del&lt;/code&gt;) was &lt;code&gt;true&lt;/code&gt;, then this destructor executes &lt;code&gt;delete[] table()&lt;/code&gt;.</source>
          <target state="translated">Если при создании этого экземпляра &lt;code&gt;&lt;a href=&quot;../ctype&quot;&gt;std::ctype&lt;/a&gt;&amp;lt;char&amp;gt;&lt;/code&gt; была предоставлена ​​настраиваемая таблица классификации, а второй аргумент конструктора (логическое значение &lt;code&gt;del&lt;/code&gt; ) был &lt;code&gt;true&lt;/code&gt; , тогда этот деструктор выполняет &lt;code&gt;delete[] table()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="abf34976945e39546eb65c898c5e72a940d36da7" translate="yes" xml:space="preserve">
          <source>Ignore symlinks</source>
          <target state="translated">игнорировать симлинки</target>
        </trans-unit>
        <trans-unit id="3c9993c27a919660753159130e530c6cef6861a2" translate="yes" xml:space="preserve">
          <source>Ill-formed expression used in a template parameter type</source>
          <target state="translated">Иллюстрированное выражение,используемое в типе параметра шаблона</target>
        </trans-unit>
        <trans-unit id="e25011561bbd556c89b469f62fed950e3e750d2a" translate="yes" xml:space="preserve">
          <source>Ill-formed expression used in the function type</source>
          <target state="translated">Иллюстрированное выражение,используемое в типе функции</target>
        </trans-unit>
        <trans-unit id="e769494ea641bd01735c8978b12dae80bc631fc2" translate="yes" xml:space="preserve">
          <source>Illegal byte sequence</source>
          <target state="translated">Незаконная последовательность байтов</target>
        </trans-unit>
        <trans-unit id="d87c7055340deb568caf4674b187c44939256ef2" translate="yes" xml:space="preserve">
          <source>Illustrates the difference in the matching algorithm between ECMAScript and POSIX regular expressions.</source>
          <target state="translated">Иллюстрирует разницу в алгоритме согласования регулярных выражений ECMAScript и POSIX.</target>
        </trans-unit>
        <trans-unit id="13da76356b1fa19b7292603df60cd8183deacc7b" translate="yes" xml:space="preserve">
          <source>Imbues &lt;code&gt;u&lt;/code&gt; with the locale &lt;code&gt;loc&lt;/code&gt;</source>
          <target state="translated">Насыщает &lt;code&gt;u&lt;/code&gt; с локали &lt;code&gt;loc&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8781d615fd77be9578225c40ac67b9471394cced" translate="yes" xml:space="preserve">
          <source>Implementation</source>
          <target state="translated">Implementation</target>
        </trans-unit>
        <trans-unit id="1bec87acbedb55cac0fd8887b67c78afe18b54a1" translate="yes" xml:space="preserve">
          <source>Implementation defined behavior control</source>
          <target state="translated">Внедрение контроля определенного поведения</target>
        </trans-unit>
        <trans-unit id="dd1e3f977c02056ea472998c02c487e2316720f9" translate="yes" xml:space="preserve">
          <source>Implementation defined behavior is controlled by &lt;code&gt;#pragma&lt;/code&gt; directive.</source>
          <target state="translated">Поведение, определяемое реализацией, контролируется директивой &lt;code&gt;#pragma&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="baec7f3938747fde7fd91e8cd29d528dd3ee3a7c" translate="yes" xml:space="preserve">
          <source>Implementation defined class type. The name &lt;code&gt;proxy&lt;/code&gt; is for exposition only.</source>
          <target state="translated">Реализация определенного типа класса. Название &lt;code&gt;proxy&lt;/code&gt; только для экспозиции.</target>
        </trans-unit>
        <trans-unit id="e0bf2dc952ab6d2617aa9b9ee013534f9eeb5b62" translate="yes" xml:space="preserve">
          <source>Implementation notes</source>
          <target state="translated">Инструкции по внедрению</target>
        </trans-unit>
        <trans-unit id="ac4df666d0cf4b162038d0ca49842cbe67665bba" translate="yes" xml:space="preserve">
          <source>Implementation properties</source>
          <target state="translated">Свойства реализации</target>
        </trans-unit>
        <trans-unit id="618e4b612934a7109a06661620d8dd64653307f6" translate="yes" xml:space="preserve">
          <source>Implementation test to check if setbuf() is supported on a dynamic strstream (output obtained with Sun Studio).</source>
          <target state="translated">Тест реализации для проверки,поддерживается ли функция setbuf()на динамическом строковом потоке (вывод получен с помощью Sun Studio).</target>
        </trans-unit>
        <trans-unit id="4ba79c92bcb0daad8f101d0490ccc2e884002f26" translate="yes" xml:space="preserve">
          <source>Implementation-defined meaning, but POSIX XSI specifies that when set on a directory, only file owners may delete files even if the directory is writeable to others (used with &lt;code&gt;/tmp&lt;/code&gt;)</source>
          <target state="translated">Значение, определяемое реализацией, но POSIX XSI указывает, что при установке в каталоге только владельцы файлов могут удалять файлы, даже если каталог доступен для записи другим пользователям (используется с &lt;code&gt;/tmp&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="c4dfef564acdd2d91911e7e70e08d38d4e85e505" translate="yes" xml:space="preserve">
          <source>Implementation-defined native handle object.</source>
          <target state="translated">Реализованный нативный объект хэндла.</target>
        </trans-unit>
        <trans-unit id="5df371b6c82001fdb73bd4a012e00b058a54aeba" translate="yes" xml:space="preserve">
          <source>Implementation-defined pathname format, auto-detected where possible</source>
          <target state="translated">Формат,определяемый реализацией,по возможности с автоопределением.</target>
        </trans-unit>
        <trans-unit id="667c8eda998c1c080db13b731500db6f8a8c9f3c" translate="yes" xml:space="preserve">
          <source>Implementation-defined value. If &lt;code&gt;command&lt;/code&gt; is a null pointer, returns a nonzero value if and only if the command processor exists.</source>
          <target state="translated">Значение, определяемое реализацией. Если &lt;code&gt;command&lt;/code&gt; является нулевым указателем, возвращает ненулевое значение тогда и только тогда, когда существует командный процессор.</target>
        </trans-unit>
        <trans-unit id="2b90c22fbd261737448cc728280b9e1a0b2564f9" translate="yes" xml:space="preserve">
          <source>Implementation-defined.</source>
          <target state="translated">Implementation-defined.</target>
        </trans-unit>
        <trans-unit id="fc59b9097e566566bcbc34003e0d601ccd5cbd0c" translate="yes" xml:space="preserve">
          <source>Implementations are encouraged to avoid dynamic allocations for small objects, but such an optimization may only be applied to types for which &lt;code&gt;&lt;a href=&quot;../types/is_move_constructible&quot;&gt;std::is_nothrow_move_constructible&lt;/a&gt;&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">Реализациям рекомендуется избегать динамического выделения небольших объектов, но такая оптимизация может применяться только к типам, для которых &lt;code&gt;&lt;a href=&quot;../types/is_move_constructible&quot;&gt;std::is_nothrow_move_constructible&lt;/a&gt;&lt;/code&gt; возвращает &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3d4e582a58851ee6c4bb6dc2e172c7707251917f" translate="yes" xml:space="preserve">
          <source>Implementations are encouraged to declare the placeholders as if by &lt;code&gt;inline constexpr /*unspecified*/ _1;&lt;/code&gt;, although declaring them by &lt;code&gt;extern /*unspecified*/ _1;&lt;/code&gt; is still allowed by the standard.</source>
          <target state="translated">Реализациям рекомендуется объявлять заполнители, как будто &lt;code&gt;inline constexpr /*unspecified*/ _1;&lt;/code&gt; , хотя объявляя их &lt;code&gt;extern /*unspecified*/ _1;&lt;/code&gt; все еще разрешено стандартом.</target>
        </trans-unit>
        <trans-unit id="fc2283d4e61c94c8b4cf57a3cc3008b1c58fed08" translate="yes" xml:space="preserve">
          <source>Implementations are encouraged to not consider &lt;code&gt;p&lt;/code&gt; not existing to be an error.</source>
          <target state="translated">Реализациям рекомендуется не рассматривать &lt;code&gt;p&lt;/code&gt; как несуществующий как ошибку.</target>
        </trans-unit>
        <trans-unit id="4cdbff21c557331fbffdc58f3ae0f283ef89f728" translate="yes" xml:space="preserve">
          <source>Implementations are encouraged to not provide any programmatic way to query, set, or modify the build level or to set or modify the violation handler.</source>
          <target state="translated">Приветствуется не предоставлять программный способ запроса,установки или изменения уровня сборки,а также установки или изменения обработчика нарушения.</target>
        </trans-unit>
        <trans-unit id="0fc00335f1f76568cf7bc5d27173b1a48e4839fb" translate="yes" xml:space="preserve">
          <source>Implementations are not permitted to declare library functions as &lt;code&gt;constexpr&lt;/code&gt; unless the standard says the function is &lt;code&gt;constexpr&lt;/code&gt;.</source>
          <target state="translated">Реализациям не разрешается объявлять библиотечные функции как &lt;code&gt;constexpr&lt;/code&gt; , если в стандарте не указано, что функция является &lt;code&gt;constexpr&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cac6f663736c0881de57437359b44434cf63f3b6" translate="yes" xml:space="preserve">
          <source>Implementations may provide specializations of &lt;code&gt;std::numeric_limits&lt;/code&gt; for implementation-specific types: e.g. GCC provides &lt;code&gt;std::numeric_limits&amp;lt;__int128&amp;gt;&lt;/code&gt;. Non-standard libraries may &lt;a href=&quot;http://en.cppreference.com/w/cpp/language/extending_std&quot;&gt;add specializations&lt;/a&gt; for library-provided types, e.g. &lt;a href=&quot;http://openexr.com/&quot;&gt;OpenEXR&lt;/a&gt; provides &lt;code&gt;std::numeric_limits&amp;lt;half&amp;gt;&lt;/code&gt; for a 16-bit floating-point type.</source>
          <target state="translated">Реализации могут предоставлять специализации &lt;code&gt;std::numeric_limits&lt;/code&gt; для специфических для реализации типов: например, GCC предоставляет &lt;code&gt;std::numeric_limits&amp;lt;__int128&amp;gt;&lt;/code&gt; . Нестандартные библиотеки могут &lt;a href=&quot;http://en.cppreference.com/w/cpp/language/extending_std&quot;&gt;добавлять специализации&lt;/a&gt; для предоставляемых библиотекой типов, например, &lt;a href=&quot;http://openexr.com/&quot;&gt;OpenEXR&lt;/a&gt; предоставляет &lt;code&gt;std::numeric_limits&amp;lt;half&amp;gt;&lt;/code&gt; для 16-битного типа с плавающей точкой.</target>
        </trans-unit>
        <trans-unit id="e11e78a73a7bdbeba97a62a3332a0fcaea58d4d7" translate="yes" xml:space="preserve">
          <source>Implementations that do not support C++17, but support &lt;a href=&quot;http://en.cppreference.com/w/cpp/experimental/special_math&quot;&gt;ISO 29124:2010&lt;/a&gt;, provide this function if &lt;code&gt;__STDCPP_MATH_SPEC_FUNCS__&lt;/code&gt; is defined by the implementation to a value at least 201003L and if the user defines &lt;code&gt;__STDCPP_WANT_MATH_SPEC_FUNCS__&lt;/code&gt; before including any standard library headers.</source>
          <target state="translated">Реализации, которые не поддерживают C ++ 17, но поддерживают &lt;a href=&quot;http://en.cppreference.com/w/cpp/experimental/special_math&quot;&gt;ISO 29124: 2010&lt;/a&gt; , предоставляют эту функцию, если &lt;code&gt;__STDCPP_MATH_SPEC_FUNCS__&lt;/code&gt; определяется реализацией как минимум со значением 201003L и если пользователь определяет &lt;code&gt;__STDCPP_WANT_MATH_SPEC_FUNCS__&lt;/code&gt; перед включением любых заголовков стандартной библиотеки.</target>
        </trans-unit>
        <trans-unit id="70e8f87cf29af9772a694ae2cede769b63d6dda0" translate="yes" xml:space="preserve">
          <source>Implementations that do not support ISO 29124:2010 but support TR 19768:2007 (TR1), provide this function in the header &lt;code&gt;tr1/cmath&lt;/code&gt; and namespace &lt;code&gt;std::tr1&lt;/code&gt;.</source>
          <target state="translated">Реализации, которые не поддерживают ISO 29124: 2010, но поддерживают TR 19768: 2007 (TR1), предоставляют эту функцию в заголовке &lt;code&gt;tr1/cmath&lt;/code&gt; и пространстве имен &lt;code&gt;std::tr1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="773665687bef6caf01efcdb3d35a7cb85d3b76c9" translate="yes" xml:space="preserve">
          <source>Implementations usually guarantee precision of less than 1 ulp (units in the last place): &lt;a href=&quot;http://sourceware.org/git/?p=glibc.git;a=blob_plain;f=sysdeps/ieee754/dbl-64/e_hypot.c&quot;&gt;GNU&lt;/a&gt;, &lt;a href=&quot;http://www.freebsd.org/cgi/cvsweb.cgi/src/lib/msun/src/e_hypot.c?rev=1.13.4.2;content-type=text/plain&quot;&gt;BSD&lt;/a&gt;, &lt;a href=&quot;http://www.open64.net/doc/d5/d3f/hypot_8c-source.html&quot;&gt;Open64&lt;/a&gt;.</source>
          <target state="translated">Реализации обычно гарантируют точность менее 1 ulp (единицы на последнем месте): &lt;a href=&quot;http://sourceware.org/git/?p=glibc.git;a=blob_plain;f=sysdeps/ieee754/dbl-64/e_hypot.c&quot;&gt;GNU&lt;/a&gt; , &lt;a href=&quot;http://www.freebsd.org/cgi/cvsweb.cgi/src/lib/msun/src/e_hypot.c?rev=1.13.4.2;content-type=text/plain&quot;&gt;BSD&lt;/a&gt; , &lt;a href=&quot;http://www.open64.net/doc/d5/d3f/hypot_8c-source.html&quot;&gt;Open64&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7c1270f12ce6696248d9babe2729d237c7e58364" translate="yes" xml:space="preserve">
          <source>Implements the analogs of the unary arithmetic operators for complex numbers.</source>
          <target state="translated">Вводит аналоги унарных арифметических операторов для комплексных чисел.</target>
        </trans-unit>
        <trans-unit id="ecc1f13a5483ad5061a47e46d970f730cb42f7e5" translate="yes" xml:space="preserve">
          <source>Implements the binary operators for complex arithmetic and for mixed complex/scalar arithmetic. Scalar arguments are treated as complex numbers with the real part equal to the argument and the imaginary part set to zero.</source>
          <target state="translated">Вводит двоичные операторы для комплексной арифметики и для смешанной комплексной/скалярной арифметики.Скалярные аргументы рассматриваются как комплексные числа с вещественной частью,равной аргументу,и мнимой частью,установленной в ноль.</target>
        </trans-unit>
        <trans-unit id="c4afda3b855163af9d0d3b6360d184e0bdc5cd94" translate="yes" xml:space="preserve">
          <source>Implements the compound assignment operators for complex arithmetic and for mixed complex/scalar arithmetic. Scalar arguments are treated as complex numbers with the real part equal to the argument and the imaginary part set to zero.</source>
          <target state="translated">Вводит составные операторы присваивания для комплексной арифметики и для смешанной комплексной/скалярной арифметики.Скалярные аргументы рассматриваются как комплексные числа с вещественной частью,равной аргументу,и мнимой частью,установленной в ноль.</target>
        </trans-unit>
        <trans-unit id="7b890ec344a13c8ecc3220d297694526da2518e7" translate="yes" xml:space="preserve">
          <source>Implements unary plus and unary minus for the durations.</source>
          <target state="translated">Включают одинарный плюс и одинарный минус для продолжительности.</target>
        </trans-unit>
        <trans-unit id="978783100f08201e0e5529544f86d4a285682f97" translate="yes" xml:space="preserve">
          <source>Implicit conversion sequence consists of the following, in this order:</source>
          <target state="translated">Неявная последовательность преобразования состоит в следующем,в этом порядке:</target>
        </trans-unit>
        <trans-unit id="1429b69e907debf636007c5f2b2aa8f332893f57" translate="yes" xml:space="preserve">
          <source>Implicit conversion sequence in list-initialization</source>
          <target state="translated">Неявная последовательность преобразования в списке-инициализации</target>
        </trans-unit>
        <trans-unit id="a454cb8b77503090cbd9a357441f356bcc77421b" translate="yes" xml:space="preserve">
          <source>Implicit conversions</source>
          <target state="translated">Неявные преобразования</target>
        </trans-unit>
        <trans-unit id="46354cbf9b435d43405dcf0d28126a074735a10d" translate="yes" xml:space="preserve">
          <source>Implicit conversions are performed whenever an expression of some type &lt;code&gt;T1&lt;/code&gt; is used in context that does not accept that type, but accepts some other type &lt;code&gt;T2&lt;/code&gt;; in particular:</source>
          <target state="translated">Неявные преобразования выполняются всякий раз, когда выражение некоторого типа &lt;code&gt;T1&lt;/code&gt; используется в контексте, который не принимает этот тип, но принимает некоторый другой тип &lt;code&gt;T2&lt;/code&gt; ; в частности:</target>
        </trans-unit>
        <trans-unit id="c7e1233543f67ff6021074ff2ae9773f138a2071" translate="yes" xml:space="preserve">
          <source>Implicit conversions between two durations normally depends on the tick period of the durations. However, implicit conversions can happen regardless of tick period if &lt;code&gt;std::chrono::treat_as_floating_point&amp;lt;Rep&amp;gt;::value == true&lt;/code&gt;.</source>
          <target state="translated">Неявные преобразования между двумя длительностями обычно зависят от периода тиков этих длительностей. Однако неявные преобразования могут происходить независимо от периода &lt;code&gt;std::chrono::treat_as_floating_point&amp;lt;Rep&amp;gt;::value == true&lt;/code&gt; если std :: chrono :: Treat_as_floating_point &amp;lt;Rep&amp;gt; :: value == true .</target>
        </trans-unit>
        <trans-unit id="cff2a76253e4ae1d3384d748888091cc614f0787" translate="yes" xml:space="preserve">
          <source>Implicit expression variations</source>
          <target state="translated">Неявные вариации выражений</target>
        </trans-unit>
        <trans-unit id="6deeab06530145f211662ed2cb9cf74741af72c3" translate="yes" xml:space="preserve">
          <source>Implicit instantiation</source>
          <target state="translated">Неявная конкретизация</target>
        </trans-unit>
        <trans-unit id="46c4cf71d06da185f299f0f266b516eb714362c2" translate="yes" xml:space="preserve">
          <source>Implicitly declared copy assignment operator</source>
          <target state="translated">Неявно объявленный оператор присвоения копии</target>
        </trans-unit>
        <trans-unit id="f3b3376d1419db08d028d5d3e6c6df0f0035aa37" translate="yes" xml:space="preserve">
          <source>Implicitly declared destructor</source>
          <target state="translated">Неявно объявленный деструктор</target>
        </trans-unit>
        <trans-unit id="0562f19403fee4205b21d8bb018af2a9b080047c" translate="yes" xml:space="preserve">
          <source>Implicitly-declared and user-defined non-explicit &lt;a href=&quot;copy_constructor&quot;&gt;copy constructors&lt;/a&gt; and &lt;a href=&quot;move_constructor&quot;&gt;move constructors&lt;/a&gt; are converting constructors.</source>
          <target state="translated">Косвенно объявленные и определяемого пользователь без явного &lt;a href=&quot;copy_constructor&quot;&gt;копирования Конструкторы&lt;/a&gt; и &lt;a href=&quot;move_constructor&quot;&gt;перемещений Конструкторы&lt;/a&gt; преобразовывают конструкторы.</target>
        </trans-unit>
        <trans-unit id="29a6f3e1205f66c508c2094943ddce2c63b0df90" translate="yes" xml:space="preserve">
          <source>Implicitly-declared copy assignment operator</source>
          <target state="translated">Неявно заявленный оператор присвоения копии</target>
        </trans-unit>
        <trans-unit id="a6d4013875adefe27157f85be3bba73a81597a9f" translate="yes" xml:space="preserve">
          <source>Implicitly-declared copy constructor</source>
          <target state="translated">Неявно заявленный конструктор копирования</target>
        </trans-unit>
        <trans-unit id="88095a2668d811c3785a1fa8299728b3a2949e56" translate="yes" xml:space="preserve">
          <source>Implicitly-declared default constructor</source>
          <target state="translated">Неявно заявленный конструктор по умолчанию</target>
        </trans-unit>
        <trans-unit id="58d35239637c6ad0d309cc3ac73e345488ae6f80" translate="yes" xml:space="preserve">
          <source>Implicitly-declared destructor</source>
          <target state="translated">Неявно заявленный деструктор</target>
        </trans-unit>
        <trans-unit id="a122664f9fa35a0ead17f50a517e4e30c5f78e62" translate="yes" xml:space="preserve">
          <source>Implicitly-declared move assignment operator</source>
          <target state="translated">Неявно заявленный оператор назначения перемещения</target>
        </trans-unit>
        <trans-unit id="2c98bb0a4aaf09d346ed78f5a0b9b9a10f6c45be" translate="yes" xml:space="preserve">
          <source>Implicitly-declared move constructor</source>
          <target state="translated">Неявно заявленный конструктор перемещения</target>
        </trans-unit>
        <trans-unit id="2deeed834989276fef215f6f2897d39d3740f2f0" translate="yes" xml:space="preserve">
          <source>Implicitly-defined copy assignment operator</source>
          <target state="translated">Неявно определенный оператор присвоения копии</target>
        </trans-unit>
        <trans-unit id="d011d88c050a6f60568345047d29ebc388337773" translate="yes" xml:space="preserve">
          <source>Implicitly-defined copy constructor</source>
          <target state="translated">Неявно определенный конструктор копирования</target>
        </trans-unit>
        <trans-unit id="fa97e996fd2560cf2c05804b139c35767f0e76e5" translate="yes" xml:space="preserve">
          <source>Implicitly-defined default constructor</source>
          <target state="translated">Неявно определенный конструктор по умолчанию</target>
        </trans-unit>
        <trans-unit id="061bd07a1bb1a33b801c708770977b87d559dec3" translate="yes" xml:space="preserve">
          <source>Implicitly-defined destructor</source>
          <target state="translated">Неявно определенный деструктор</target>
        </trans-unit>
        <trans-unit id="2904db3125ebf0c63383992eb2b2968ba47ba5e2" translate="yes" xml:space="preserve">
          <source>Implicitly-defined member functions</source>
          <target state="translated">Неявно определенные функции членов</target>
        </trans-unit>
        <trans-unit id="e45913a1e2322cc7a36b3505067db026e25257da" translate="yes" xml:space="preserve">
          <source>Implicitly-defined move assignment operator</source>
          <target state="translated">Неявно определенный оператор назначения перемещения</target>
        </trans-unit>
        <trans-unit id="4ebcbcc97e562ec198f2e53e43d491b81d9344ee" translate="yes" xml:space="preserve">
          <source>Implicitly-defined move constructor</source>
          <target state="translated">Неявно определенный конструктор перемещения</target>
        </trans-unit>
        <trans-unit id="2f48272a7bcd8ca888d2cfc92fd1bc8b4d291257" translate="yes" xml:space="preserve">
          <source>Implicitly-generated deduction guides</source>
          <target state="translated">Неявно сгенерированные руководства по вычетам</target>
        </trans-unit>
        <trans-unit id="27328a2eb2f15815a68b1653d19575045b8cf992" translate="yes" xml:space="preserve">
          <source>In 2's complement systems, the absolute value of the most-negative value is out of range, e.g. for 32-bit 2's complement type int, INT_MIN is -2147483648, but the would-be result 2147483648 is greater than INT_MAX, which is 2147483647.</source>
          <target state="translated">В системах комплемента 2 абсолютное значение самой отрицательной величины находится вне диапазона,например,для 32-битного 2-го типа комплемента int,INT_MIN равен -2147483648,а потенциальный результат 2147483648 больше INT_MAX,то есть 2147483647.</target>
        </trans-unit>
        <trans-unit id="b5fd98f8c63f3d298c51c647d77132a000415d4f" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;adl&quot;&gt;argument-dependent lookup&lt;/a&gt;, when a namespace is added to the set of associated namespaces, its inline namespaces are added as well, and if an inline namespace is added to the list of associated namespaces, its enclosing namespace is added as well.</source>
          <target state="translated">При &lt;a href=&quot;adl&quot;&gt;поиске&lt;/a&gt; , зависящем от аргумента , когда пространство имен добавляется в набор связанных пространств имен, также добавляются его встроенные пространства имен, а если добавляется встроенное пространство имен в список связанных пространств имен, также добавляется и его пространство имен.</target>
        </trans-unit>
        <trans-unit id="9fd1e0ac5e63fbea64f332e88d4780d848f55564" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;constant_expression&quot;&gt;constant expression&lt;/a&gt; and &lt;a href=&quot;constant_initialization&quot;&gt;constant initialization&lt;/a&gt;, return value optimization (RVO) is guaranteed, however, named return value optimization (NRVO) is forbidden (note: this is specified by post-C++14 defect report CWG 2022 and reversed by defect report CWG 2278):</source>
          <target state="translated">При &lt;a href=&quot;constant_expression&quot;&gt;постоянном выражении&lt;/a&gt; и &lt;a href=&quot;constant_initialization&quot;&gt;постоянной инициализации&lt;/a&gt; оптимизация возвращаемого значения (RVO) гарантирована, однако запрещена именованная оптимизация возвращаемого значения (NRVO) (примечание: это указано в отчете о дефектах после C ++ 14 CWG 2022 и отменяется в отчете о дефектах CWG 2278):</target>
        </trans-unit>
        <trans-unit id="4438658486a8aa1c2ccb17440e6244e19bb12c43" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;coroutines&quot;&gt;coroutines&lt;/a&gt;, copy/move of the parameter into coroutine state may be elided where this does not change the behavior of the program other than by omitting the calls to the parameter's constructor and destructor. This can take place if the parameter is never referenced after a suspension point or when the entire coroutine state was never heap-allocated in the first place.</source>
          <target state="translated">В &lt;a href=&quot;coroutines&quot;&gt;сопрограммах&lt;/a&gt; копирование / перемещение параметра в состояние сопрограммы может быть исключено, если это не меняет поведение программы, кроме как путем пропуска вызовов конструктора и деструктора параметра. Это может иметь место, если на параметр никогда не ссылаются после точки приостановки или когда все состояние сопрограммы никогда не выделялось в куче.</target>
        </trans-unit>
        <trans-unit id="752b262a5dc8786ae6cab7940e196fea49ff6ccb" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;fold&quot;&gt;fold-expressions&lt;/a&gt;, the pattern is the entire subexpression that does not contain an unexpanded parameter pack.</source>
          <target state="translated">В &lt;a href=&quot;fold&quot;&gt;выражениях сгиба&lt;/a&gt; шаблон - это полное подвыражение, которое не содержит нерасширенный пакет параметров.</target>
        </trans-unit>
        <trans-unit id="2242cd439921fc4c92bc135cffe3759d57213422" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;list_initialization&quot;&gt;list initialization&lt;/a&gt;, the argument is a braced-init-list, which isn't an expression, so the implicit conversion sequence into the parameter type for the purpose of overload resolution is decided by the following special rules:</source>
          <target state="translated">При &lt;a href=&quot;list_initialization&quot;&gt;инициализации списка&lt;/a&gt; аргумент представляет собой фигурный список инициализации, который не является выражением, поэтому последовательность неявного преобразования в тип параметра с целью разрешения перегрузки определяется следующими специальными правилами:</target>
        </trans-unit>
        <trans-unit id="1cc4dbef738efa286661d780a703351be8b0b7f1" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;overload_resolution#Best_viable_function&quot;&gt;overload resolution&lt;/a&gt;, partial ordering takes precedence over whether a function template is generated from a guide: if the function template generated from the constructor is more specialized than the one generated from the deduction guide, the one generated from the constructor is chosen. Because the copy deduction candidate is typically more specialized than a wrapping constructor, this rule means that copying is generally preferred over wrapping.</source>
          <target state="translated">При &lt;a href=&quot;overload_resolution#Best_viable_function&quot;&gt;разрешении перегрузки&lt;/a&gt; частичное упорядочение имеет приоритет перед тем, генерируется ли шаблон функции из руководства: если шаблон функции, созданный из конструктора, является более специализированным, чем шаблон, созданный из руководства по вычету, выбирается шаблон, созданный из конструктора. Поскольку кандидат на вычет копирования обычно более специализирован, чем конструктор упаковки, это правило означает, что копирование, как правило, предпочтительнее переноса.</target>
        </trans-unit>
        <trans-unit id="4809c5e41e7473cccbc72a4bb155bdc02191303e" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;overload_resolution#Call_to_an_overloaded_operator&quot;&gt;overload resolution against user-defined operators&lt;/a&gt;, for every combination of types &lt;code&gt;D&lt;/code&gt;, &lt;code&gt;B&lt;/code&gt;, &lt;code&gt;R&lt;/code&gt;, where class type &lt;code&gt;B&lt;/code&gt; is either the same class as &lt;code&gt;D&lt;/code&gt; or an unambiguous and accessible base class of &lt;code&gt;D&lt;/code&gt;, and &lt;code&gt;R&lt;/code&gt; is either an object or function type, the following function signature participates in overload resolution:</source>
          <target state="translated">В &lt;a href=&quot;overload_resolution#Call_to_an_overloaded_operator&quot;&gt;разрешении перегрузки для определенных пользователем операторов&lt;/a&gt; для каждой комбинации типов &lt;code&gt;D&lt;/code&gt; , &lt;code&gt;B&lt;/code&gt; , &lt;code&gt;R&lt;/code&gt; , где тип класса &lt;code&gt;B&lt;/code&gt; является либо тем же классом, что и &lt;code&gt;D&lt;/code&gt; , либо однозначным и доступным базовым классом &lt;code&gt;D&lt;/code&gt; , а &lt;code&gt;R&lt;/code&gt; является типом объекта или функции следующая сигнатура функции участвует в разрешении перегрузки:</target>
        </trans-unit>
        <trans-unit id="624c4590775fbf40a4b7d04856d19fc9508c5fa6" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;overload_resolution#Call_to_an_overloaded_operator&quot;&gt;overload resolution against user-defined operators&lt;/a&gt;, for every object type &lt;code&gt;T&lt;/code&gt; (possibly cv-qualified), the following function signature participates in overload resolution:</source>
          <target state="translated">При &lt;a href=&quot;overload_resolution#Call_to_an_overloaded_operator&quot;&gt;разрешении перегрузки для определенных пользователем операторов&lt;/a&gt; для каждого типа объекта &lt;code&gt;T&lt;/code&gt; (возможно, cv-квалифицированного) в разрешении перегрузки участвует следующая сигнатура функции:</target>
        </trans-unit>
        <trans-unit id="307ea5bb116870783914632b4b12d175efc040fc" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;overload_resolution#Call_to_an_overloaded_operator&quot;&gt;overload resolution against user-defined operators&lt;/a&gt;, for every optionally volatile-qualified arithmetic type &lt;code&gt;A&lt;/code&gt; other than &lt;code&gt;bool&lt;/code&gt;, and for every optionally volatile-qualified pointer &lt;code&gt;P&lt;/code&gt; to optionally cv-qualified object type, the following function signatures participate in overload resolution:</source>
          <target state="translated">В &lt;a href=&quot;overload_resolution#Call_to_an_overloaded_operator&quot;&gt;разрешении перегрузки для определенных пользователем операторов&lt;/a&gt; , для каждого необязательного арифметического типа &lt;code&gt;A&lt;/code&gt; , кроме &lt;code&gt;bool&lt;/code&gt; , и для каждого необязательного указателя &lt;code&gt;P&lt;/code&gt; в необязательном cv-квалифицированном типе объекта в разрешении перегрузки участвуют следующие сигнатуры функций:</target>
        </trans-unit>
        <trans-unit id="5990cf25ac820a864a2b308a05c41a666871b396" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;overload_resolution#Call_to_an_overloaded_operator&quot;&gt;overload resolution against user-defined operators&lt;/a&gt;, for every pair A1 and A2, where A1 is an arithmetic type (optionally volatile-qualified) and A2 is a promoted arithmetic type, the following function signatures participate in overload resolution:</source>
          <target state="translated">В &lt;a href=&quot;overload_resolution#Call_to_an_overloaded_operator&quot;&gt;разрешении перегрузки для определенных пользователем операторов&lt;/a&gt; для каждой пары A1 и A2, где A1 - арифметический тип (необязательно определяемый по волатильности), а A2 - повышенный арифметический тип, следующие сигнатуры функций участвуют в разрешении перегрузки:</target>
        </trans-unit>
        <trans-unit id="8d3869a5bce1a140062b4b7e7874a7e2f0b63bc7" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;overload_resolution#Call_to_an_overloaded_operator&quot;&gt;overload resolution against user-defined operators&lt;/a&gt;, for every pair of promoted arithmetic types &lt;code&gt;L&lt;/code&gt; and &lt;code&gt;R&lt;/code&gt; and for every object type &lt;code&gt;T&lt;/code&gt;, the following function signatures participate in overload resolution:</source>
          <target state="translated">При &lt;a href=&quot;overload_resolution#Call_to_an_overloaded_operator&quot;&gt;разрешении перегрузки для определенных пользователем операторов&lt;/a&gt; для каждой пары повышенных арифметических типов &lt;code&gt;L&lt;/code&gt; и &lt;code&gt;R&lt;/code&gt; и для каждого типа объекта &lt;code&gt;T&lt;/code&gt; в разрешении перегрузки участвуют следующие сигнатуры функций:</target>
        </trans-unit>
        <trans-unit id="b24752ca21e578d5ccc2e9cc894a56665fc96230" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;overload_resolution#Call_to_an_overloaded_operator&quot;&gt;overload resolution against user-defined operators&lt;/a&gt;, for every pair of promoted arithmetic types &lt;code&gt;L&lt;/code&gt; and &lt;code&gt;R&lt;/code&gt;, including enumeration types, the following function signatures participate in overload resolution:</source>
          <target state="translated">При &lt;a href=&quot;overload_resolution#Call_to_an_overloaded_operator&quot;&gt;разрешении перегрузки для определенных пользователем операторов&lt;/a&gt; для каждой пары повышенных арифметических типов &lt;code&gt;L&lt;/code&gt; и &lt;code&gt;R&lt;/code&gt; , включая типы перечисления, следующие сигнатуры функций участвуют в разрешении перегрузки:</target>
        </trans-unit>
        <trans-unit id="fd26ab1ed7c9b56dae3b9425960ee35cb9730a3f" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;overload_resolution#Call_to_an_overloaded_operator&quot;&gt;overload resolution against user-defined operators&lt;/a&gt;, for every pair of promoted arithmetic types &lt;code&gt;LA&lt;/code&gt; and &lt;code&gt;RA&lt;/code&gt; and for every pair of promoted integral types &lt;code&gt;LI&lt;/code&gt; and &lt;code&gt;RI&lt;/code&gt; the following function signatures participate in overload resolution:</source>
          <target state="translated">При &lt;a href=&quot;overload_resolution#Call_to_an_overloaded_operator&quot;&gt;разрешении перегрузки для определенных пользователем операторов&lt;/a&gt; для каждой пары повышенных арифметических типов &lt;code&gt;LA&lt;/code&gt; и &lt;code&gt;RA&lt;/code&gt; и для каждой пары повышенных целочисленных типов &lt;code&gt;LI&lt;/code&gt; и &lt;code&gt;RI&lt;/code&gt; в разрешении перегрузки участвуют следующие сигнатуры функций:</target>
        </trans-unit>
        <trans-unit id="f476dbd74c2f442c1c2e2829bce88b4a88341d7d" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;overload_resolution#Call_to_an_overloaded_operator&quot;&gt;overload resolution against user-defined operators&lt;/a&gt;, for every pair of promoted integral types &lt;code&gt;L&lt;/code&gt; and &lt;code&gt;R&lt;/code&gt; the following function signatures participate in overload resolution:</source>
          <target state="translated">При &lt;a href=&quot;overload_resolution#Call_to_an_overloaded_operator&quot;&gt;разрешении перегрузки для определенных пользователем операторов&lt;/a&gt; для каждой пары повышенных целочисленных типов &lt;code&gt;L&lt;/code&gt; и &lt;code&gt;R&lt;/code&gt; в разрешении перегрузки участвуют следующие сигнатуры функций:</target>
        </trans-unit>
        <trans-unit id="eb835b282c835e4cba40899b90f1b4b1b4026a72" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;overload_resolution#Call_to_an_overloaded_operator&quot;&gt;overload resolution against user-defined operators&lt;/a&gt;, for every pair of promoted integral types &lt;code&gt;L&lt;/code&gt; and &lt;code&gt;R&lt;/code&gt;, the following function signatures participate in overload resolution:</source>
          <target state="translated">При &lt;a href=&quot;overload_resolution#Call_to_an_overloaded_operator&quot;&gt;разрешении перегрузки для определенных пользователем операторов&lt;/a&gt; для каждой пары повышенных целочисленных типов &lt;code&gt;L&lt;/code&gt; и &lt;code&gt;R&lt;/code&gt; в разрешении перегрузки участвуют следующие сигнатуры функций:</target>
        </trans-unit>
        <trans-unit id="c4a93fe8e1bc45c860bc0b892d8c877cf026beb8" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;overload_resolution#Call_to_an_overloaded_operator&quot;&gt;overload resolution against user-defined operators&lt;/a&gt;, for every promoted arithmetic type &lt;code&gt;A&lt;/code&gt; and for every type &lt;code&gt;T&lt;/code&gt;, the following function signatures participate in overload resolution:</source>
          <target state="translated">В &lt;a href=&quot;overload_resolution#Call_to_an_overloaded_operator&quot;&gt;разрешении перегрузки для определенных пользователем операторов&lt;/a&gt; для каждого повышенного арифметического типа &lt;code&gt;A&lt;/code&gt; и для каждого типа &lt;code&gt;T&lt;/code&gt; в разрешении перегрузки участвуют следующие сигнатуры функций:</target>
        </trans-unit>
        <trans-unit id="fb2d8e1a38d1a77a396a0e77f09d5580ac4be3ba" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;overload_resolution#Call_to_an_overloaded_operator&quot;&gt;overload resolution against user-defined operators&lt;/a&gt;, for every type &lt;code&gt;T&lt;/code&gt; that is either object type (possibly cv-qualified) or function type (not const- or ref-qualified), the following function signature participates in overload resolution:</source>
          <target state="translated">При &lt;a href=&quot;overload_resolution#Call_to_an_overloaded_operator&quot;&gt;разрешении перегрузки для определенных пользователем операторов&lt;/a&gt; для каждого типа &lt;code&gt;T&lt;/code&gt; , который является либо типом объекта (возможно, cv-квалифицированным), либо типом функции (не квалифицированным или не квалифицированным), в разрешении перегрузки участвует следующая сигнатура функции:</target>
        </trans-unit>
        <trans-unit id="401b7699fa1e8e938b279018437f1606b4040a67" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;overload_resolution#Call_to_an_overloaded_operator&quot;&gt;overload resolution against user-defined operators&lt;/a&gt;, for every type &lt;code&gt;T&lt;/code&gt;, the following function signatures participate in overload resolution:</source>
          <target state="translated">При &lt;a href=&quot;overload_resolution#Call_to_an_overloaded_operator&quot;&gt;разрешении перегрузки для определенных пользователем операторов&lt;/a&gt; для каждого типа &lt;code&gt;T&lt;/code&gt; в разрешении перегрузки участвуют следующие сигнатуры функций:</target>
        </trans-unit>
        <trans-unit id="0c2aad84e7da44f63319332803f4b852d30346b4" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;overload_resolution#Call_to_an_overloaded_operator&quot;&gt;overload resolution against user-defined operators&lt;/a&gt;, for pointer or enumeration type &lt;code&gt;T&lt;/code&gt;, the following function signature participates in overload resolution:</source>
          <target state="translated">При &lt;a href=&quot;overload_resolution#Call_to_an_overloaded_operator&quot;&gt;разрешении перегрузки для определенных пользователем операторов&lt;/a&gt; для указателя или типа перечисления &lt;code&gt;T&lt;/code&gt; в разрешении перегрузки участвует следующая сигнатура функции:</target>
        </trans-unit>
        <trans-unit id="5cea19a589fd752a8bdd766f6cd3803387a4d265" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;overload_resolution#Call_to_an_overloaded_operator&quot;&gt;overload resolution against user-defined operators&lt;/a&gt;, the following built-in function signatures participate in overload resolution:</source>
          <target state="translated">При &lt;a href=&quot;overload_resolution#Call_to_an_overloaded_operator&quot;&gt;разрешении перегрузки для определенных пользователем операторов&lt;/a&gt; в разрешении перегрузки участвуют следующие сигнатуры встроенных функций:</target>
        </trans-unit>
        <trans-unit id="ee813279dc64b0e3db6b8e7e767214afb0a3c85c" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;overload_resolution#Call_to_an_overloaded_operator&quot;&gt;overload resolution against user-defined operators&lt;/a&gt;, this operator does not introduce any additional function signatures: built-in address-of operator does not apply if there exists an overloaded &lt;code&gt;operator&amp;amp;&lt;/code&gt; that is a &lt;a href=&quot;overload_resolution#Viable_functions&quot;&gt;viable function&lt;/a&gt;.</source>
          <target state="translated">При &lt;a href=&quot;overload_resolution#Call_to_an_overloaded_operator&quot;&gt;разрешении перегрузки для определенных пользователем операторов&lt;/a&gt; этот оператор не вводит никаких дополнительных сигнатур функций: встроенный оператор address-of не применяется, если существует перегруженный &lt;code&gt;operator&amp;amp;&lt;/code&gt; это &lt;a href=&quot;overload_resolution#Viable_functions&quot;&gt;жизнеспособная функция&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="dd138803f2292cc51a5e2969a85f684f859f9f88" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;using_declaration&quot;&gt;using declaration&lt;/a&gt;, ellipsis may appear in the list of declarators, this is useful when deriving from a parameter pack:</source>
          <target state="translated">При &lt;a href=&quot;using_declaration&quot;&gt;использовании объявления&lt;/a&gt; , многоточие может появиться в списке объявлений, это полезно при выводе из пакета параметров:</target>
        </trans-unit>
        <trans-unit id="c58f1f0803bbe584686a6a997ca2d9633a806b36" translate="yes" xml:space="preserve">
          <source>In C prior to C99 (but not in C++), unsuffixed decimal values that do not fit in &lt;code&gt;long int&lt;/code&gt; are allowed to have the type &lt;code&gt;unsigned long int&lt;/code&gt;.</source>
          <target state="translated">В C, предшествующем C99 (но не в C ++), десятичные значения без суффиксов, которые не помещаются в &lt;code&gt;long int&lt;/code&gt; , могут иметь тип &lt;code&gt;unsigned long int&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="11a679b4f1f70ac38a1af627d070d394e3b260d2" translate="yes" xml:space="preserve">
          <source>In C++, unlike C, variables cannot be declared &lt;code&gt;register&lt;/code&gt;.</source>
          <target state="translated">В C ++, в отличие от C, переменные не могут быть объявлены как &lt;code&gt;register&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9036e8af52064611d82c261ee7c4ae9a4cdd7015" translate="yes" xml:space="preserve">
          <source>In C++11 and C++14 it is valid to construct a &lt;code&gt;&lt;a href=&quot;../shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt; from a &lt;code&gt;&lt;a href=&quot;../unique_ptr&quot;&gt;std::unique_ptr&lt;/a&gt;&amp;lt;T[]&amp;gt;&lt;/code&gt;:</source>
          <target state="translated">В C ++ 11 и C ++ 14 допустимо создать &lt;code&gt;&lt;a href=&quot;../shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt; из &lt;code&gt;&lt;a href=&quot;../unique_ptr&quot;&gt;std::unique_ptr&lt;/a&gt;&amp;lt;T[]&amp;gt;&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="d7851c45dc812ab508d940b1e3b960f585dcd4c8" translate="yes" xml:space="preserve">
          <source>In C++11, &lt;code&gt;broken_promise&lt;/code&gt; was specified to equal zero despite &lt;code&gt;&lt;a href=&quot;../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&lt;/code&gt;/&lt;code&gt;&lt;a href=&quot;../error/error_condition&quot;&gt;std::error_condition&lt;/a&gt;&lt;/code&gt; using zero to mean &quot;no error&quot;. This was fixed in C++14.</source>
          <target state="translated">В C ++ 11 параметр &lt;code&gt;broken_promise&lt;/code&gt; было указано равным нулю, несмотря на то , что условие &lt;code&gt;&lt;a href=&quot;../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&lt;/code&gt; / &lt;code&gt;&lt;a href=&quot;../error/error_condition&quot;&gt;std::error_condition&lt;/a&gt;&lt;/code&gt; равно нулю, что означает &amp;laquo;нет ошибки&amp;raquo;. Это было исправлено в C ++ 14.</target>
        </trans-unit>
        <trans-unit id="c2a0733225045f42e4ffac4f7cced1fd8bd01edc" translate="yes" xml:space="preserve">
          <source>In C++11, expressions that:</source>
          <target state="translated">В Си++11,выражения,которые:</target>
        </trans-unit>
        <trans-unit id="8a471ce8454b0c44c542d11c1ba3841025440979" translate="yes" xml:space="preserve">
          <source>In C++11, these constants were specified with redundant keyword &lt;code&gt;static&lt;/code&gt;, which was removed by C++14 via &lt;a href=&quot;http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2053&quot;&gt;LWG issue 2053&lt;/a&gt;.</source>
          <target state="translated">В C ++ 11 эти константы были определены с помощью избыточного &lt;code&gt;static&lt;/code&gt; ключевого слова , которое было удалено в C ++ 14 через &lt;a href=&quot;http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2053&quot;&gt;выпуск LWG 2053&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="984160a3e04fdf728c84931473e5065db87d2de8" translate="yes" xml:space="preserve">
          <source>In C++17, &lt;a href=&quot;copy_elision&quot;&gt;copy elision&lt;/a&gt; was made mandatory in some situations, and that required separation of prvalue expressions from the temporary objects initialized by them, resulting in the system we have today. Note that, in contrast with the C++11 scheme, prvalues are no longer moved from.</source>
          <target state="translated">В C ++ 17 в некоторых ситуациях &lt;a href=&quot;copy_elision&quot;&gt;исключение копирования&lt;/a&gt; было обязательным, и это требовало отделения выражений prvalue от инициализируемых ими временных объектов, что привело к созданию системы, которую мы имеем сегодня. Обратите внимание, что, в отличие от схемы C ++ 11, значения prval больше не перемещаются.</target>
        </trans-unit>
        <trans-unit id="4f1bbad23b5985f92e8fd5da90bac9e6e27f0dfa" translate="yes" xml:space="preserve">
          <source>In C++98 prior to C++03 (which introduced value initialization), the expression &lt;code&gt;new T()&lt;/code&gt; was classified as default initialization and specified zero-initialization.</source>
          <target state="translated">В C ++ 98 до C ++ 03 (который вводил инициализацию значения) выражение &lt;code&gt;new T()&lt;/code&gt; было классифицировано как инициализация по умолчанию и указывала нулевую инициализацию.</target>
        </trans-unit>
        <trans-unit id="9476240519883d62813958bad1862fa3943959d8" translate="yes" xml:space="preserve">
          <source>In C++98/C++03, if an error occurs, &lt;code&gt;v&lt;/code&gt; is left unchanged. In C++11, it is set to a value as described above.</source>
          <target state="translated">В C ++ 98 / C ++ 03, если возникает ошибка, &lt;code&gt;v&lt;/code&gt; остается без изменений. В C ++ 11 для него установлено значение, как описано выше.</target>
        </trans-unit>
        <trans-unit id="5a00b4bd83d09e5862a084a0513a75ec121bbf2e" translate="yes" xml:space="preserve">
          <source>In C, &lt;code&gt;putc()&lt;/code&gt; may be implemented as a macro, which is disallowed in C++. Therefore calls to &lt;code&gt;std::fputc()&lt;/code&gt; and &lt;code&gt;std::putc()&lt;/code&gt; always have the same effect.</source>
          <target state="translated">В C &lt;code&gt;putc()&lt;/code&gt; может быть реализован как макрос, что запрещено в C ++. Поэтому вызовы &lt;code&gt;std::fputc()&lt;/code&gt; и &lt;code&gt;std::putc()&lt;/code&gt; всегда имеют одинаковый эффект.</target>
        </trans-unit>
        <trans-unit id="cf9734438af23c6dfb132972af4a721d26ce5a2e" translate="yes" xml:space="preserve">
          <source>In C, character array of size one less than the size of the string literal may be initialized from a string literal; the resulting array is not null-terminated. This is not allowed in C++.</source>
          <target state="translated">В языке C из строкового литерала можно инициализировать символьный массив размером на один символ меньше размера строкового литерала,результирующий массив не является нуль-терминированным.В Си++это недопустимо.</target>
        </trans-unit>
        <trans-unit id="38e0a2f5a0dd182661a588f644d0e761c91db444" translate="yes" xml:space="preserve">
          <source>In C, character constants such as &lt;code&gt;'a'&lt;/code&gt; or &lt;code&gt;'\n'&lt;/code&gt; have type &lt;code&gt;int&lt;/code&gt;, rather than &lt;code&gt;char&lt;/code&gt;.</source>
          <target state="translated">В C символьные константы, такие как &lt;code&gt;'a'&lt;/code&gt; или &lt;code&gt;'\n'&lt;/code&gt; имеют тип &lt;code&gt;int&lt;/code&gt; , а не &lt;code&gt;char&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c022ffe44f1e1cb8c1253d8ca27c1f6f5d7901e9" translate="yes" xml:space="preserve">
          <source>In C, inline functions do not have to be declared inline in every translation unit (at most one may be non-inline or extern inline), the function definitions do not have to be identical (but the behavior of the program must not depend on which one is called), and the function-local statics are distinct between different definitions of the same function.</source>
          <target state="translated">В языке Си встроенные функции не обязательно должны быть объявлены inline в каждой единице трансляции (максимум одна из них может быть нестрочной или экстернной inline),определения функций не обязательно должны быть идентичными (но поведение программы не должно зависеть от того,какая из них вызывается),а функционально-локальная статика различается между разными определениями одной и той же функции.</target>
        </trans-unit>
        <trans-unit id="c2835e1b41b93ce6d5849cf55c8cf7a0e81c4f48" translate="yes" xml:space="preserve">
          <source>In C, string literals are of type &lt;code&gt;char[]&lt;/code&gt;, and can be assigned directly to a (non-const) &lt;code&gt;char*&lt;/code&gt;. C++03 allowed it as well (but deprecated it, as literals are &lt;code&gt;const&lt;/code&gt; in C++). C++11 no longer allows such assignments without a cast.</source>
          <target state="translated">В C строковые литералы имеют тип &lt;code&gt;char[]&lt;/code&gt; и могут быть назначены непосредственно (неконстантному) &lt;code&gt;char*&lt;/code&gt; . C ++ 03 разрешено это , а также (но не рекомендуется ее, как литералы &lt;code&gt;const&lt;/code&gt; в C ++). C ++ 11 больше не позволяет такие назначения без приведения.</target>
        </trans-unit>
        <trans-unit id="2ab9e9edb5ce53cff5c0a794854dbeaa98df7eba" translate="yes" xml:space="preserve">
          <source>In C, the address of a &lt;code&gt;register&lt;/code&gt; variable cannot be taken, but in C++, a variable declared &lt;code&gt;register&lt;/code&gt; is semantically indistinguishable from a variable declared without any storage class specifiers.</source>
          <target state="translated">В C адрес переменной &lt;code&gt;register&lt;/code&gt; не может быть получен, но в C ++ объявленный &lt;code&gt;register&lt;/code&gt; переменной семантически неотличим от переменной, объявленной без каких-либо спецификаторов класса хранения.</target>
        </trans-unit>
        <trans-unit id="c82c0f1785717e06dc6cfec64c1ec49afdff6848" translate="yes" xml:space="preserve">
          <source>In C, the macro &lt;code&gt;NULL&lt;/code&gt; may have the type &lt;code&gt;void*&lt;/code&gt;, but that is not allowed in C++.</source>
          <target state="translated">В C макрос &lt;code&gt;NULL&lt;/code&gt; может иметь тип &lt;code&gt;void*&lt;/code&gt; , но это не разрешено в C ++.</target>
        </trans-unit>
        <trans-unit id="f0bfb9c61efe498d3321fdcd4f4cc72588b7c2a9" translate="yes" xml:space="preserve">
          <source>In C, the ternary conditional operator has higher precedence than assignment operators. Therefore, the expression &lt;code&gt;e = a &amp;lt; d ? a++ : a = d&lt;/code&gt;, which is parsed in C++ as &lt;code&gt;e = ((a &amp;lt; d) ? (a++) : (a = d))&lt;/code&gt;, will fail to compile in C due to grammatical or semantic constraints in C. See the corresponding C page for details.</source>
          <target state="translated">В Си троичный условный оператор имеет более высокий приоритет, чем операторы присваивания. Следовательно, выражение &lt;code&gt;e = a &amp;lt; d ? a++ : a = d&lt;/code&gt; , который в C ++ анализируется как &lt;code&gt;e = ((a &amp;lt; d) ? (a++) : (a = d))&lt;/code&gt; , не будет компилироваться в C из-за грамматических или семантических ограничений в C. См. соответствующие C страница для деталей.</target>
        </trans-unit>
        <trans-unit id="c59c494dc7b28d6f1ae3f3e1fba28d7c33f040e5" translate="yes" xml:space="preserve">
          <source>In IS0 8601 weeks begin with Monday and the first week of the year must satisfy the following requirements:</source>
          <target state="translated">В IS0 8601 неделя начинается с понедельника и первая неделя года должна соответствовать следующим требованиям:</target>
        </trans-unit>
        <trans-unit id="c2409d0ab324438044b126d5eaae356ad25d17dc" translate="yes" xml:space="preserve">
          <source>In ISO 8601 weeks begin with Monday and the first week of the year must satisfy the following requirements:</source>
          <target state="translated">В стандарте ISO 8601 недели начинаются с понедельника и первая неделя года должна соответствовать следующим требованиям:</target>
        </trans-unit>
        <trans-unit id="3f2df198c19b4d3aee57fa1d2f0a4c70b3d8c1de" translate="yes" xml:space="preserve">
          <source>In a</source>
          <target state="translated">Через</target>
        </trans-unit>
        <trans-unit id="0c962fc44a425f14d1e80539f2eadaa9d9481b53" translate="yes" xml:space="preserve">
          <source>In a &lt;a href=&quot;../language/templates&quot;&gt; template declaration&lt;/a&gt;, &lt;code&gt;class&lt;/code&gt; can be used to introduce &lt;a href=&quot;../language/template_parameters#Type_template_parameter&quot;&gt; type template parameters&lt;/a&gt; and &lt;a href=&quot;../language/template_parameters#Template_template_parameter&quot;&gt; template template parameters&lt;/a&gt;</source>
          <target state="translated">В &lt;a href=&quot;../language/templates&quot;&gt;объявлении шаблона&lt;/a&gt; , &lt;code&gt;class&lt;/code&gt; может быть использован для введения &lt;a href=&quot;../language/template_parameters#Type_template_parameter&quot;&gt;параметров шаблона типа&lt;/a&gt; и &lt;a href=&quot;../language/template_parameters#Template_template_parameter&quot;&gt;параметров шаблона шаблона&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b62c4f9f476c687ff843ca517e75f7940028ba13" translate="yes" xml:space="preserve">
          <source>In a &lt;a href=&quot;../language/templates&quot;&gt; template declaration&lt;/a&gt;, &lt;code&gt;typename&lt;/code&gt; can be used as an alternative to &lt;a href=&quot;class&quot;&gt; class&lt;/a&gt; to declare &lt;a href=&quot;../language/template_parameters#Type_template_parameter&quot;&gt;type template parameters&lt;/a&gt;and template template parameters(since C++17).</source>
          <target state="translated">В &lt;a href=&quot;../language/templates&quot;&gt;объявлении шаблона&lt;/a&gt; , &lt;code&gt;typename&lt;/code&gt; может быть использовано в качестве альтернативы &lt;a href=&quot;class&quot;&gt;класса&lt;/a&gt; объявить &lt;a href=&quot;../language/template_parameters#Type_template_parameter&quot;&gt;параметры шаблона типа&lt;/a&gt; и параметры шаблона шаблона (так как C ++ 17).</target>
        </trans-unit>
        <trans-unit id="6c62102a69b04462fa302dbc2df4626b43048568" translate="yes" xml:space="preserve">
          <source>In a &lt;a href=&quot;lambda&quot;&gt;lambda&lt;/a&gt; declaration, it appears either immediately after the capture list, or immediately after the (keyword &lt;code&gt;mutable&lt;/code&gt; (if one is used).</source>
          <target state="translated">В &lt;a href=&quot;lambda&quot;&gt;лямбда-&lt;/a&gt; объявлении оно появляется либо сразу после списка захвата, либо сразу после (ключевое слово &lt;code&gt;mutable&lt;/code&gt; (если оно используется).</target>
        </trans-unit>
        <trans-unit id="e1d855aa75c086efbd816d762abc1c86bd8016f1" translate="yes" xml:space="preserve">
          <source>In a &lt;a href=&quot;return&quot;&gt;return statement&lt;/a&gt;, when the operand is a &lt;a href=&quot;value_category&quot;&gt;prvalue&lt;/a&gt; of the same class type (ignoring &lt;a href=&quot;cv&quot;&gt;cv-qualification&lt;/a&gt;) as the function return type:</source>
          <target state="translated">В операторе &lt;a href=&quot;return&quot;&gt;возврата&lt;/a&gt; , когда операнд является &lt;a href=&quot;value_category&quot;&gt;prvalue&lt;/a&gt; того же типа класса (игнорируя &lt;a href=&quot;cv&quot;&gt;квалификацию cv&lt;/a&gt; ), что и тип возврата функции:</target>
        </trans-unit>
        <trans-unit id="177a6daaadac5e744a3c9483ebb25b9c5956b8d4" translate="yes" xml:space="preserve">
          <source>In a &lt;a href=&quot;return&quot;&gt;return statement&lt;/a&gt;, when the operand is the name of a non-volatile object with automatic storage duration, which isn't a function parameter or a catch clause parameter, and which is of the same class type (ignoring &lt;a href=&quot;cv&quot;&gt;cv-qualification&lt;/a&gt;) as the function return type. This variant of copy elision is known as NRVO, &quot;named return value optimization&quot;.</source>
          <target state="translated">В операторе &lt;a href=&quot;return&quot;&gt;возврата&lt;/a&gt; , когда операндом является имя энергонезависимого объекта с автоматической продолжительностью хранения, который не является параметром функции или параметром предложения catch и имеет тот же тип класса (игнорирующий &lt;a href=&quot;cv&quot;&gt;квалификацию cv&lt;/a&gt; ), что и тип возврата функции. Этот вариант исключения копии известен как NRVO, &amp;laquo;оптимизация именованного значения&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="fde11b27cc6006e08d96a8f3a53a33443f577fd4" translate="yes" xml:space="preserve">
          <source>In a &lt;a href=&quot;throw&quot;&gt;throw-expression&lt;/a&gt;, when the operand is the name of a non-volatile object with automatic storage duration, which isn't a function parameter or a catch clause parameter, and whose scope does not extend past the innermost try-block (if there is a try-block).</source>
          <target state="translated">В &lt;a href=&quot;throw&quot;&gt;выражении throw&lt;/a&gt; , когда операндом является имя энергонезависимого объекта с автоматической продолжительностью хранения, который не является параметром функции или параметром предложения catch и область действия которого не выходит за пределы самого внутреннего блока try (если есть триб-блок).</target>
        </trans-unit>
        <trans-unit id="601aeec487cb6099c489a8b16b96b24dfb6cd755" translate="yes" xml:space="preserve">
          <source>In a &lt;a href=&quot;try_catch&quot;&gt;catch clause&lt;/a&gt;, when the argument is of the same type (ignoring &lt;a href=&quot;cv&quot;&gt;cv-qualification&lt;/a&gt;) as the exception object thrown, the copy of the exception object is omitted and the body of the catch clause accesses the exception object directly, as if caught by reference (there cannot be a move from the exception object because it is always an lvalue). This is disabled if such copy elision would change the observable behavior of the program for any reason other than skipping the copy constructor and the destructor of the catch clause argument (for example, if the catch clause argument is modified, and the exception object is rethrown with &lt;code&gt;throw&lt;/code&gt;).</source>
          <target state="translated">В предложении &lt;a href=&quot;try_catch&quot;&gt;catch&lt;/a&gt; , когда аргумент имеет тот же тип (игнорирующий &lt;a href=&quot;cv&quot;&gt;cv-qualification&lt;/a&gt; ), что и брошенный объект исключения, копия объекта исключения исключается, а тело предложения catch получает прямой доступ к объекту исключения, как если бы оно было поймано ссылка (не может быть перемещения из объекта исключения, потому что это всегда lvalue). Это отключено, если такое удаление копии изменит наблюдаемое поведение программы по любой причине, кроме пропуска конструктора копирования и деструктора аргумента предложения catch (например, если аргумент предложения catch изменен, а объект исключения переброшен с &lt;code&gt;throw&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="556d00127671f5f34cb70b7e4bc4f78905db67ff" translate="yes" xml:space="preserve">
          <source>In a base-specifier of a &lt;a href=&quot;derived_class&quot;&gt;derived class&lt;/a&gt; declaration, define the accessibility of inherited members of the subsequent base class.</source>
          <target state="translated">В базовом спецификаторе объявления &lt;a href=&quot;derived_class&quot;&gt;производного класса&lt;/a&gt; определите доступность унаследованных членов последующего базового класса.</target>
        </trans-unit>
        <trans-unit id="02b565401cf5d5664e816543f1fd59c4e0eec827" translate="yes" xml:space="preserve">
          <source>In a class scope, the name of the current class is treated as if it were a public member name; this is called</source>
          <target state="translated">В области видимости класса имя текущего класса обрабатывается,как если бы оно было публичным именем члена;это имя называется</target>
        </trans-unit>
        <trans-unit id="dd0fdaa3d2c6bc7e7e1f68aa336ca282ee91f5ee" translate="yes" xml:space="preserve">
          <source>In a class template, the injected-class-name can be used either as a template name that refers to the current template, or as a class name that refers to the current instantiation.</source>
          <target state="translated">В шаблоне класса,имя инжектируемого класса может быть использовано либо как имя шаблона,которое ссылается на текущий шаблон,либо как имя класса,которое ссылается на текущее инстанцирование.</target>
        </trans-unit>
        <trans-unit id="44fa3b441a0dd74cd09577454cd3ff350af83aaa" translate="yes" xml:space="preserve">
          <source>In a comma expression &lt;code&gt;E1, E2&lt;/code&gt;, the expression &lt;code&gt;E1&lt;/code&gt; is evaluated, its result is &lt;a href=&quot;expressions#Discarded-value_expressions&quot;&gt;discarded&lt;/a&gt; (although if it has class type, it won't be destroyed &lt;a href=&quot;lifetime#Temporary_object_lifetime&quot;&gt;until the end of the containing full expression&lt;/a&gt;), and its side effects are completed before evaluation of the expression &lt;code&gt;E2&lt;/code&gt; begins (note that a user-defined &lt;code&gt;operator,&lt;/code&gt; cannot guarantee sequencing)(until C++17).</source>
          <target state="translated">В выражении &lt;code&gt;E1, E2&lt;/code&gt; запятой вычисляется выражение &lt;code&gt;E1&lt;/code&gt; , его результат &lt;a href=&quot;expressions#Discarded-value_expressions&quot;&gt;отбрасывается&lt;/a&gt; (хотя, если он имеет тип класса, он не будет уничтожен &lt;a href=&quot;lifetime#Temporary_object_lifetime&quot;&gt;до конца содержащего полное выражение&lt;/a&gt; ), а его побочные эффекты завершаются до оценки выражения &lt;code&gt;E2&lt;/code&gt; начинается (обратите внимание, что пользовательский &lt;code&gt;operator,&lt;/code&gt; не может гарантировать последовательность) (до C ++ 17).</target>
        </trans-unit>
        <trans-unit id="6d39978f8296a8c3b0b3811afba0c562703be315" translate="yes" xml:space="preserve">
          <source>In a constexpr if statement, the value of condition must be a &lt;a href=&quot;constant_expression#Converted_constant_expression&quot;&gt;contextually converted constant expression of type &lt;code&gt;bool&lt;/code&gt;&lt;/a&gt;. If the value is &lt;code&gt;true&lt;/code&gt;, then statement-false is discarded (if present), otherwise, statement-true is discarded.</source>
          <target state="translated">В выражении constexpr if значение condition должно быть &lt;a href=&quot;constant_expression#Converted_constant_expression&quot;&gt;контекстно-преобразованным константным выражением типа &lt;code&gt;bool&lt;/code&gt; &lt;/a&gt; . Если значение равно &lt;code&gt;true&lt;/code&gt; , то оператор-ложь отбрасывается (если присутствует), в противном случае оператор-истина отбрасывается.</target>
        </trans-unit>
        <trans-unit id="ffa4404e890de02936df9088f71b377c51dc866e" translate="yes" xml:space="preserve">
          <source>In a declaration or a definition of a template, including alias template, a name that is not a member of the</source>
          <target state="translated">В декларации или определении шаблона,включая шаблон псевдонима,имя,которое не входит в состав</target>
        </trans-unit>
        <trans-unit id="0d44582f7d0710a8597f720797b494b72912bece" translate="yes" xml:space="preserve">
          <source>In a function declaration, after a parameter with a default argument, all subsequent parameters must.</source>
          <target state="translated">В объявлении функции после параметра с аргументом по умолчанию должны быть все последующие параметры.</target>
        </trans-unit>
        <trans-unit id="29bba75b946ab8a0a1465e021f70b5a3cf77b940" translate="yes" xml:space="preserve">
          <source>In a function parameter list, if an ellipsis appears in a parameter declaration (whether it names a function parameter pack (as in, Args&lt;code&gt;...&lt;/code&gt;args) or not) the parameter declaration is the pattern:</source>
          <target state="translated">В списке параметров функции, если в объявлении параметра появляется многоточие (независимо от того, называет ли он пакет параметров функции (например, Args &lt;code&gt;...&lt;/code&gt; args) или нет), объявлением параметра является шаблон:</target>
        </trans-unit>
        <trans-unit id="ff38e5d5bc4cb779e7363c8977789202cfec1e6e" translate="yes" xml:space="preserve">
          <source>In a function returning &lt;code&gt;void&lt;/code&gt;, the return statement with expression can be used, if the expression type is &lt;code&gt;void&lt;/code&gt;.</source>
          <target state="translated">В функции, возвращающей &lt;code&gt;void&lt;/code&gt; , может использоваться оператор return с выражением, если тип выражения &lt;code&gt;void&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e9aa7f5d4e2a651b7a8c4283d212b044b1deb7ca" translate="yes" xml:space="preserve">
          <source>In a manner similar to &lt;a href=&quot;mutex&quot;&gt;&lt;code&gt;mutex&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;timed_mutex&lt;/code&gt; offers exclusive, non-recursive ownership semantics. In addition, &lt;code&gt;timed_mutex&lt;/code&gt; provides the ability to attempt to claim ownership of a &lt;code&gt;timed_mutex&lt;/code&gt; with a timeout via the &lt;a href=&quot;timed_mutex/try_lock_for&quot;&gt;&lt;code&gt;try_lock_for()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;timed_mutex/try_lock_until&quot;&gt;&lt;code&gt;try_lock_until()&lt;/code&gt;&lt;/a&gt; methods.</source>
          <target state="translated">Способ , аналогичным &lt;a href=&quot;mutex&quot;&gt; &lt;code&gt;mutex&lt;/code&gt; &lt;/a&gt; , &lt;code&gt;timed_mutex&lt;/code&gt; предлагает эксклюзивную нерекурсивную семантику собственности. Кроме того, &lt;code&gt;timed_mutex&lt;/code&gt; предоставляет возможность попытаться претендовать на владение &lt;code&gt;timed_mutex&lt;/code&gt; с тайм-аутом через &lt;a href=&quot;timed_mutex/try_lock_for&quot;&gt; &lt;code&gt;try_lock_for()&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;timed_mutex/try_lock_until&quot;&gt; &lt;code&gt;try_lock_until()&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a105c84562cad718ddfbcbaeae2b0d01a57bb6a5" translate="yes" xml:space="preserve">
          <source>In a manner similar to &lt;a href=&quot;timed_mutex&quot;&gt;&lt;code&gt;timed_mutex&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;shared_timed_mutex&lt;/code&gt; provides the ability to attempt to claim ownership of a &lt;code&gt;shared_timed_mutex&lt;/code&gt; with a timeout via the &lt;a href=&quot;shared_timed_mutex/try_lock_for&quot;&gt;&lt;code&gt;try_lock_for()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;shared_timed_mutex/try_lock_until&quot;&gt;&lt;code&gt;try_lock_until()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;shared_timed_mutex/try_lock_shared_for&quot;&gt;&lt;code&gt;try_lock_shared_for()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;shared_timed_mutex/try_lock_shared_until&quot;&gt;&lt;code&gt;try_lock_shared_until()&lt;/code&gt;&lt;/a&gt; methods.</source>
          <target state="translated">Таким же образом, как и &lt;a href=&quot;timed_mutex&quot;&gt; &lt;code&gt;timed_mutex&lt;/code&gt; &lt;/a&gt; , &lt;code&gt;shared_timed_mutex&lt;/code&gt; предоставляет возможность попытаться претендовать на право собственности на &lt;code&gt;shared_timed_mutex&lt;/code&gt; с таймаутом через &lt;a href=&quot;shared_timed_mutex/try_lock_for&quot;&gt; &lt;code&gt;try_lock_for()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;shared_timed_mutex/try_lock_until&quot;&gt; &lt;code&gt;try_lock_until()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;shared_timed_mutex/try_lock_shared_for&quot;&gt; &lt;code&gt;try_lock_shared_for()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;shared_timed_mutex/try_lock_shared_until&quot;&gt; &lt;code&gt;try_lock_shared_until()&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="73ef1571fcba32d6299f7cfb10f71f4b33622399" translate="yes" xml:space="preserve">
          <source>In a manner similar to &lt;code&gt;&lt;a href=&quot;recursive_mutex&quot;&gt;std::recursive_mutex&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;recursive_timed_mutex&lt;/code&gt; provides exclusive, recursive ownership semantics. In addition, &lt;code&gt;recursive_timed_mutex&lt;/code&gt; provides the ability to attempt to claim ownership of a &lt;code&gt;recursive_timed_mutex&lt;/code&gt; with a timeout via the &lt;a href=&quot;recursive_timed_mutex/try_lock_for&quot;&gt;&lt;code&gt;try_lock_for&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;recursive_timed_mutex/try_lock_until&quot;&gt;&lt;code&gt;try_lock_until&lt;/code&gt;&lt;/a&gt; methods.</source>
          <target state="translated">Подобно &lt;code&gt;&lt;a href=&quot;recursive_mutex&quot;&gt;std::recursive_mutex&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;recursive_timed_mutex&lt;/code&gt; обеспечивает исключительную рекурсивную семантику владения. Кроме того, &lt;code&gt;recursive_timed_mutex&lt;/code&gt; предоставляет возможность попытаться претендовать на владение &lt;code&gt;recursive_timed_mutex&lt;/code&gt; с таймаутом через методы &lt;a href=&quot;recursive_timed_mutex/try_lock_for&quot;&gt; &lt;code&gt;try_lock_for&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;recursive_timed_mutex/try_lock_until&quot;&gt; &lt;code&gt;try_lock_until&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6849ef8c2becfa3fc06c88b17ac43d2f4c411e40" translate="yes" xml:space="preserve">
          <source>In a member function declaration or definition, &lt;code&gt;override&lt;/code&gt; ensures that the function is virtual and is overriding a virtual function from a base class. The program is ill-formed (a compile-time error is generated) if this is not true.</source>
          <target state="translated">В объявлении или определении функции-члена &lt;code&gt;override&lt;/code&gt; гарантирует, что функция является виртуальной и переопределяет виртуальную функцию из базового класса. Программа некорректна (генерируется ошибка во время компиляции), если это не так.</target>
        </trans-unit>
        <trans-unit id="e4f5d5b55ed5d6a1476b0d473859397b31a64db5" translate="yes" xml:space="preserve">
          <source>In a member-specification of a &lt;a href=&quot;class&quot;&gt;class/struct&lt;/a&gt; or &lt;a href=&quot;union&quot;&gt;union&lt;/a&gt;, define the accessibility of subsequent members.</source>
          <target state="translated">В спецификации члена &lt;a href=&quot;class&quot;&gt;класса / структуры&lt;/a&gt; или &lt;a href=&quot;union&quot;&gt;объединения&lt;/a&gt; определите доступность последующих членов.</target>
        </trans-unit>
        <trans-unit id="94c1a387b407acb6d65fdcd502fe4af3873221a8" translate="yes" xml:space="preserve">
          <source>In a primary class template, the template parameter pack must be the final parameter in the template parameter list. In a function template, the template parameter pack may appear earlier in the list provided that all following parameters can be deduced from the function arguments, or have default arguments:</source>
          <target state="translated">В шаблоне первичного класса пакет параметров шаблона должен быть конечным параметром в списке параметров шаблона.В шаблоне функции пакет шаблонных параметров может появиться раньше в списке при условии,что все следующие параметры могут быть выведены из аргументов функции или иметь аргументы по умолчанию:</target>
        </trans-unit>
        <trans-unit id="1d0f0e8e5fc7ee584cfdd9cc8db60b33727fe5d0" translate="yes" xml:space="preserve">
          <source>In a qualified name &lt;code&gt;C::D&lt;/code&gt;, if.</source>
          <target state="translated">В квалифицированном имени &lt;code&gt;C::D&lt;/code&gt; , если.</target>
        </trans-unit>
        <trans-unit id="72a217ab1ac4987acb0fd819dc67e7faf17facb8" translate="yes" xml:space="preserve">
          <source>In a return statement or a throw-expression, if the compiler cannot perform copy elision but the conditions for copy elision are met or would be met, except that the source is a function parameter, the compiler will attempt to use the move constructor even if the object is designated by an lvalue; see &lt;a href=&quot;return#Notes&quot;&gt;return statement&lt;/a&gt; for details.</source>
          <target state="translated">В операторе возврата или бросающем выражении, если компилятор не может выполнить удаление копии, но условия исключения копирования соблюдены или будут выполнены, за исключением того, что источник является параметром функции, компилятор попытается использовать конструктор перемещения, даже если объект обозначен lvalue; см. &lt;a href=&quot;return#Notes&quot;&gt;заявление возврата&lt;/a&gt; для деталей.</target>
        </trans-unit>
        <trans-unit id="cb9d44c1145d9374305ce7d0683c7666a1a8faf1" translate="yes" xml:space="preserve">
          <source>In a standard-layout union with an active member of non-union class type &lt;code&gt;T1&lt;/code&gt;, it is permitted to read a non-static data member &lt;code&gt;m&lt;/code&gt; of another union member of non-union class type &lt;code&gt;T2&lt;/code&gt; provided &lt;code&gt;m&lt;/code&gt; is part of the common initial sequence of &lt;code&gt;T1&lt;/code&gt; and &lt;code&gt;T2&lt;/code&gt; (except that reading a volatile member through non-volatile glvalue is undefined).</source>
          <target state="translated">В объединении стандартной компоновки с активным членом типа &lt;code&gt;T1&lt;/code&gt; класса , не являющегося объединением , разрешается читать нестатический член &lt;code&gt;m&lt;/code&gt; данных другого члена объединения типа &lt;code&gt;T2&lt;/code&gt; , не являющегося объединением, при условии, что &lt;code&gt;m&lt;/code&gt; является частью общей начальной последовательности из &lt;code&gt;T1&lt;/code&gt; и &lt;code&gt;T2&lt;/code&gt; ( за исключением того, что чтение летучего элемента через энергонезависимую glvalue не определено).</target>
        </trans-unit>
        <trans-unit id="57d94135b1f4411284cd0b70dd280cd47ea7b667" translate="yes" xml:space="preserve">
          <source>In a typical implementation, &lt;code&gt;std::shared_ptr&lt;/code&gt; holds only two pointers:</source>
          <target state="translated">В типичной реализации &lt;code&gt;std::shared_ptr&lt;/code&gt; содержит только два указателя:</target>
        </trans-unit>
        <trans-unit id="302df27cb656ad4b16b22d1abb7ca751d6dcd20f" translate="yes" xml:space="preserve">
          <source>In a typical implementation, the only data members of &lt;code&gt;std::ostream_iterator&lt;/code&gt; are a pointer to the associated &lt;code&gt;std::basic_ostream&lt;/code&gt; and a pointer to the first character in the delimiter string.</source>
          <target state="translated">В типичной реализации единственными членами данных &lt;code&gt;std::ostream_iterator&lt;/code&gt; являются указатель на связанный &lt;code&gt;std::basic_ostream&lt;/code&gt; и указатель на первый символ в строке разделителя.</target>
        </trans-unit>
        <trans-unit id="28d88a36238effdebec563fabaf3d6addb51154c" translate="yes" xml:space="preserve">
          <source>In a typical implementation, the only data members of &lt;code&gt;std::ostreambuf_iterator&lt;/code&gt; are a pointer to the associated &lt;code&gt;std::basic_streambuf&lt;/code&gt; and a boolean flag indicating if the the end of file condition has been reached.</source>
          <target state="translated">В типичной реализации единственными членами данных &lt;code&gt;std::ostreambuf_iterator&lt;/code&gt; являются указатель на связанный &lt;code&gt;std::basic_streambuf&lt;/code&gt; и логический флаг, указывающий, достигнуто ли условие конца файла.</target>
        </trans-unit>
        <trans-unit id="cf627f59eb9ce680a79832f3ab2b75fd54c9e5dc" translate="yes" xml:space="preserve">
          <source>In a valid C++ program, every thread eventually does one of the following:</source>
          <target state="translated">В действующей программе на Си++каждый поток в конечном итоге выполняет одно из следующих действий:</target>
        </trans-unit>
        <trans-unit id="5fae65e7ec13a45d7642866607e117019083d5bd" translate="yes" xml:space="preserve">
          <source>In addition to being available via inclusion of the &amp;lt;tuple&amp;gt; header, the templates (3-5) are available when either of the headers &amp;lt;array&amp;gt; or &amp;lt;utility&amp;gt; are included.</source>
          <target state="translated">В дополнение к тому, что они доступны через включение заголовка &amp;lt;tuple&amp;gt;, шаблоны (3-5) доступны, когда включены либо заголовки &amp;lt;array&amp;gt;, либо &amp;lt;utility&amp;gt;.</target>
        </trans-unit>
        <trans-unit id="15c8d22eeeed9e3926980c7851a1d6015cd58fda" translate="yes" xml:space="preserve">
          <source>In addition to being included in &lt;code&gt;&amp;lt;iterator&amp;gt;&lt;/code&gt;, &lt;code&gt;std::begin&lt;/code&gt; and &lt;code&gt;std::cbegin&lt;/code&gt; are guaranteed to become available if any of the following headers are included: &lt;code&gt;&amp;lt;array&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;deque&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;forward_list&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;list&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;map&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;regex&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;set&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;span&amp;gt;&lt;/code&gt;(since C++20), &lt;code&gt;&amp;lt;string&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;string_view&amp;gt;&lt;/code&gt;(since C++17), &lt;code&gt;&amp;lt;unordered_map&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;unordered_set&amp;gt;&lt;/code&gt;, and &lt;code&gt;&amp;lt;vector&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">В дополнение к тому, что они включены в &lt;code&gt;&amp;lt;iterator&amp;gt;&lt;/code&gt; , &lt;code&gt;std::begin&lt;/code&gt; и &lt;code&gt;std::cbegin&lt;/code&gt; гарантированно станут доступными, если будет включен любой из следующих заголовков: &lt;code&gt;&amp;lt;array&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;deque&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;forward_list&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;list&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;map&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;regex&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;set&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;span&amp;gt;&lt;/code&gt; (начиная с C ++ 20), &lt;code&gt;&amp;lt;string&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;string_view&amp;gt;&lt;/code&gt; (начиная с C ++ 17), &lt;code&gt;&amp;lt;unordered_map&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;unordered_set&amp;gt;&lt;/code&gt; и &lt;code&gt;&amp;lt;vector&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="338a7c84c19f8a1e820335032a79e38ce0602216" translate="yes" xml:space="preserve">
          <source>In addition to being included in &lt;code&gt;&amp;lt;iterator&amp;gt;&lt;/code&gt;, &lt;code&gt;std::data&lt;/code&gt; is guaranteed to become available if any of the following headers are included: &lt;code&gt;&amp;lt;array&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;deque&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;forward_list&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;list&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;map&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;regex&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;set&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;span&amp;gt;&lt;/code&gt;(since C++20), &lt;code&gt;&amp;lt;string&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;string_view&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;unordered_map&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;unordered_set&amp;gt;&lt;/code&gt;, and &lt;code&gt;&amp;lt;vector&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">Помимо включения в &lt;code&gt;&amp;lt;iterator&amp;gt;&lt;/code&gt; , &lt;code&gt;std::data&lt;/code&gt; гарантированно станет доступным, если будет включен любой из следующих заголовков: &lt;code&gt;&amp;lt;array&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;deque&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;forward_list&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;list&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;map&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;regex&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;set&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;span&amp;gt;&lt;/code&gt; (начиная с C ++ 20), &lt;code&gt;&amp;lt;string&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;string_view&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;unordered_map&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;unordered_set&amp;gt;&lt;/code&gt; и &lt;code&gt;&amp;lt;vector&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f8ecedc3305486dab3dbe344b85d3d2b73a9d8eb" translate="yes" xml:space="preserve">
          <source>In addition to being included in &lt;code&gt;&amp;lt;iterator&amp;gt;&lt;/code&gt;, &lt;code&gt;std::empty&lt;/code&gt; is guaranteed to become available if any of the following headers are included: &lt;code&gt;&amp;lt;array&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;deque&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;forward_list&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;list&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;map&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;regex&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;set&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;span&amp;gt;&lt;/code&gt;(since C++20), &lt;code&gt;&amp;lt;string&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;string_view&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;unordered_map&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;unordered_set&amp;gt;&lt;/code&gt;, and &lt;code&gt;&amp;lt;vector&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">Помимо включения в &lt;code&gt;&amp;lt;iterator&amp;gt;&lt;/code&gt; , &lt;code&gt;std::empty&lt;/code&gt; гарантированно станет доступным, если будет включен любой из следующих заголовков: &lt;code&gt;&amp;lt;array&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;deque&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;forward_list&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;list&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;map&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;regex&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;set&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;span&amp;gt;&lt;/code&gt; (начиная с C ++ 20), &lt;code&gt;&amp;lt;string&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;string_view&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;unordered_map&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;unordered_set&amp;gt;&lt;/code&gt; и &lt;code&gt;&amp;lt;vector&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9360d86ce66685d75aa6a0b3e3f9a322ab2b75da" translate="yes" xml:space="preserve">
          <source>In addition to being included in &lt;code&gt;&amp;lt;iterator&amp;gt;&lt;/code&gt;, &lt;code&gt;std::end&lt;/code&gt; and &lt;code&gt;std::cend&lt;/code&gt; are guaranteed to become available if any of the following headers are included: &lt;code&gt;&amp;lt;array&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;deque&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;forward_list&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;list&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;map&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;regex&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;set&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;span&amp;gt;&lt;/code&gt;(since C++20), &lt;code&gt;&amp;lt;string&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;string_view&amp;gt;&lt;/code&gt;(since C++17), &lt;code&gt;&amp;lt;unordered_map&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;unordered_set&amp;gt;&lt;/code&gt;, and &lt;code&gt;&amp;lt;vector&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">В дополнении к включены в &lt;code&gt;&amp;lt;iterator&amp;gt;&lt;/code&gt; , &lt;code&gt;std::end&lt;/code&gt; и &lt;code&gt;std::cend&lt;/code&gt; гарантированно становятся доступными , если любой из следующих заголовков включены: &lt;code&gt;&amp;lt;array&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;deque&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;forward_list&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;list&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;map&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;regex&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;set&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;span&amp;gt;&lt;/code&gt; (начиная с C ++ 20), &lt;code&gt;&amp;lt;string&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;string_view&amp;gt;&lt;/code&gt; (начиная с C ++ 17), &lt;code&gt;&amp;lt;unordered_map&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;unordered_set&amp;gt;&lt;/code&gt; и &lt;code&gt;&amp;lt;vector&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b4a73cea37076402c9805971389b5c85fd80eb64" translate="yes" xml:space="preserve">
          <source>In addition to being included in &lt;code&gt;&amp;lt;iterator&amp;gt;&lt;/code&gt;, &lt;code&gt;std::rbegin&lt;/code&gt; and &lt;code&gt;std::crbegin&lt;/code&gt; are guaranteed to become available if any of the following headers are included: &lt;code&gt;&amp;lt;array&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;deque&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;forward_list&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;list&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;map&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;regex&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;set&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;span&amp;gt;&lt;/code&gt;(since C++20), &lt;code&gt;&amp;lt;string&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;string_view&amp;gt;&lt;/code&gt;(since C++17), &lt;code&gt;&amp;lt;unordered_map&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;unordered_set&amp;gt;&lt;/code&gt;, and &lt;code&gt;&amp;lt;vector&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">В дополнение к тому, что они включены в &lt;code&gt;&amp;lt;iterator&amp;gt;&lt;/code&gt; , &lt;code&gt;std::rbegin&lt;/code&gt; и &lt;code&gt;std::crbegin&lt;/code&gt; гарантированно станут доступными, если будет включен любой из следующих заголовков: &lt;code&gt;&amp;lt;array&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;deque&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;forward_list&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;list&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;map&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;regex&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;set&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;span&amp;gt;&lt;/code&gt; (начиная с C ++ 20), &lt;code&gt;&amp;lt;string&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;string_view&amp;gt;&lt;/code&gt; (начиная с C ++ 17), &lt;code&gt;&amp;lt;unordered_map&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;unordered_set&amp;gt;&lt;/code&gt; и &lt;code&gt;&amp;lt;vector&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="80150b5d7065d7588ce5758ee13c5f0c81f3d9cb" translate="yes" xml:space="preserve">
          <source>In addition to being included in &lt;code&gt;&amp;lt;iterator&amp;gt;&lt;/code&gt;, &lt;code&gt;std::rend&lt;/code&gt; and &lt;code&gt;std::crend&lt;/code&gt; are guaranteed to become available if any of the following headers are included: &lt;code&gt;&amp;lt;array&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;deque&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;forward_list&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;list&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;map&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;regex&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;set&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;span&amp;gt;&lt;/code&gt;(since C++20), &lt;code&gt;&amp;lt;string&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;string_view&amp;gt;&lt;/code&gt;(since C++17), &lt;code&gt;&amp;lt;unordered_map&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;unordered_set&amp;gt;&lt;/code&gt;, and &lt;code&gt;&amp;lt;vector&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">В дополнение к включены в &lt;code&gt;&amp;lt;iterator&amp;gt;&lt;/code&gt; , &lt;code&gt;std::rend&lt;/code&gt; и &lt;code&gt;std::crend&lt;/code&gt; гарантированно становятся доступными , если любой из следующих заголовков включены: &lt;code&gt;&amp;lt;array&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;deque&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;forward_list&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;list&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;map&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;regex&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;set&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;span&amp;gt;&lt;/code&gt; (начиная с C ++ 20), &lt;code&gt;&amp;lt;string&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;string_view&amp;gt;&lt;/code&gt; (начиная с C ++ 17), &lt;code&gt;&amp;lt;unordered_map&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;unordered_set&amp;gt;&lt;/code&gt; и &lt;code&gt;&amp;lt;vector&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ece481ac1f67deffb145ed3b4d4e6b31704b49ce" translate="yes" xml:space="preserve">
          <source>In addition to being included in &lt;code&gt;&amp;lt;iterator&amp;gt;&lt;/code&gt;, &lt;code&gt;std::size&lt;/code&gt; and &lt;code&gt;std::ssize&lt;/code&gt; are guaranteed to become available if any of the following headers are included: &lt;code&gt;&amp;lt;array&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;deque&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;forward_list&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;list&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;map&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;regex&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;set&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;span&amp;gt;&lt;/code&gt;(since C++20), &lt;code&gt;&amp;lt;string&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;string_view&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;unordered_map&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;unordered_set&amp;gt;&lt;/code&gt;, and &lt;code&gt;&amp;lt;vector&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">В дополнение к включены в &lt;code&gt;&amp;lt;iterator&amp;gt;&lt;/code&gt; , &lt;code&gt;std::size&lt;/code&gt; и &lt;code&gt;std::ssize&lt;/code&gt; гарантированно становятся доступными , если любой из следующих заголовков включены: &lt;code&gt;&amp;lt;array&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;deque&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;forward_list&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;list&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;map&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;regex&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;set&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;span&amp;gt;&lt;/code&gt; (начиная с C ++ 20), &lt;code&gt;&amp;lt;string&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;string_view&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;unordered_map&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;unordered_set&amp;gt;&lt;/code&gt; и &lt;code&gt;&amp;lt;vector&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a875ba5ef1aeb5e5a529dc3dc7727bb4112f85b1" translate="yes" xml:space="preserve">
          <source>In addition to changing the file position indicator, &lt;code&gt;fseek&lt;/code&gt; undoes the effects of &lt;code&gt;&lt;a href=&quot;ungetc&quot;&gt;std::ungetc&lt;/a&gt;&lt;/code&gt; and clears the end-of-file status, if applicable.</source>
          <target state="translated">В дополнение к изменению индикатора положения файла, &lt;code&gt;fseek&lt;/code&gt; отменяет эффекты &lt;code&gt;&lt;a href=&quot;ungetc&quot;&gt;std::ungetc&lt;/a&gt;&lt;/code&gt; и очищает состояние конца файла, если это применимо.</target>
        </trans-unit>
        <trans-unit id="cf1188534c30ece32fd46ec4ab40935b4238d277" translate="yes" xml:space="preserve">
          <source>In addition to keywords, there are</source>
          <target state="translated">В дополнение к ключевым словам,есть</target>
        </trans-unit>
        <trans-unit id="271348d0f95843d6de9b4a3bea7c7a4b2fb93975" translate="yes" xml:space="preserve">
          <source>In addition to sophisticated locale-dependent parsers and formatters provided by the &lt;a href=&quot;io&quot;&gt;C++ I/O&lt;/a&gt; library, the &lt;a href=&quot;io/c&quot;&gt;C I/O&lt;/a&gt; library, &lt;a href=&quot;string/basic_string#Numeric_conversions&quot;&gt;C++ string converters&lt;/a&gt;, and &lt;a href=&quot;string/byte#Conversions_to_numeric_formats&quot;&gt;C string converters&lt;/a&gt;, the header &lt;a href=&quot;header/charconv&quot;&gt;&lt;code&gt;&amp;lt;charconv&amp;gt;&lt;/code&gt;&lt;/a&gt; provides light-weight, locale-independent, non-allocating, non-throwing, ASCII-only parsers and formatters for arithmetic types.</source>
          <target state="translated">В дополнении к сложным локали-зависимые анализаторы и форматерам , предоставляемых &lt;a href=&quot;io&quot;&gt;C ++ I / O&lt;/a&gt; библиотеки, &lt;a href=&quot;io/c&quot;&gt;CI / вывод&lt;/a&gt; библиотека, &lt;a href=&quot;string/basic_string#Numeric_conversions&quot;&gt;C ++ струнных преобразователей&lt;/a&gt; и &lt;a href=&quot;string/byte#Conversions_to_numeric_formats&quot;&gt;струнные преобразователи C&lt;/a&gt; , заголовок &lt;a href=&quot;header/charconv&quot;&gt; &lt;code&gt;&amp;lt;charconv&amp;gt;&lt;/code&gt; &lt;/a&gt; обеспечивает легкий, локалите-независимый, не- парсеры и форматеры, предназначенные только для ASCII и предназначенные для арифметических операций.</target>
        </trans-unit>
        <trans-unit id="792f40a7aa00c160ead2eca530fe86663d38f9ab" translate="yes" xml:space="preserve">
          <source>In addition to the above, the composite pointer type between pointer to function and pointer to noexcept function (as long as the function type is the same) is pointer to function.</source>
          <target state="translated">В дополнение к вышесказанному,составной тип указателя между указателем на функцию и указателем на неисключительную функцию (до тех пор,пока тип функции совпадает)является указателем на функцию.</target>
        </trans-unit>
        <trans-unit id="ae9ffad79cce78b91bc762e83fe3fface28c2158" translate="yes" xml:space="preserve">
          <source>In addition to the above, the standard library provides specializations for all (scoped and unscoped) enumeration types. These may be (but are not required to be) implemented as &lt;code&gt;std::hash&amp;lt;&lt;a href=&quot;../types/underlying_type&quot;&gt;std::underlying_type&lt;/a&gt;&amp;lt;Enum&amp;gt;::type&amp;gt;&lt;/code&gt;).</source>
          <target state="translated">В дополнение к вышесказанному, стандартная библиотека предоставляет специализации для всех (перечисляемых и незаданных) типов перечисления. Они могут быть (но не обязательно) реализованы как &lt;code&gt;std::hash&amp;lt;&lt;a href=&quot;../types/underlying_type&quot;&gt;std::underlying_type&lt;/a&gt;&amp;lt;Enum&amp;gt;::type&amp;gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="0d12b27afe84f919d4cf85c2c720f51dd78c7c47" translate="yes" xml:space="preserve">
          <source>In addition to the engines and distributions described above, the functions and constants from the C random library are also available though not recommended:</source>
          <target state="translated">Кроме описанных выше движков и распределений,доступны также функции и константы из библиотеки случайных чисел C,хотя и не рекомендуются:</target>
        </trans-unit>
        <trans-unit id="d7885497c8e90724cd51455d17a67e9d4213e9e7" translate="yes" xml:space="preserve">
          <source>In addition to the use in collation, the implementation-specific format of the transformed string is known to &lt;a href=&quot;../../regex/regex_traits/transform_primary&quot;&gt;std::regex_traits&amp;lt;&amp;gt;::transform_primary&lt;/a&gt;, which is able to extract the equivalence class information.</source>
          <target state="translated">В дополнение к использованию в сопоставлении, специфичный для реализации формат преобразованной строки известен как &lt;a href=&quot;../../regex/regex_traits/transform_primary&quot;&gt;std :: regex_traits &amp;lt;&amp;gt; :: transform_primary&lt;/a&gt; , который способен извлекать информацию о классе эквивалентности.</target>
        </trans-unit>
        <trans-unit id="a698de81532c150ff1ad39e8d086bac28e3d07da" translate="yes" xml:space="preserve">
          <source>In addition, &lt;a href=&quot;bit_field&quot;&gt;bit field declarations&lt;/a&gt; are allowed.</source>
          <target state="translated">Кроме того, &lt;a href=&quot;bit_field&quot;&gt;объявления битовых полей&lt;/a&gt; допускаются.</target>
        </trans-unit>
        <trans-unit id="4b8e054656c974f48dccf563843687d3cffa39b2" translate="yes" xml:space="preserve">
          <source>In addition, &lt;code&gt;&lt;a href=&quot;../atomic_flag&quot;&gt;std::atomic_flag&lt;/a&gt;&lt;/code&gt; can be value-initialized to clear state with the expression &lt;code&gt;&lt;a href=&quot;../atomic_flag_init&quot;&gt;ATOMIC_FLAG_INIT&lt;/a&gt;&lt;/code&gt;. For an atomic_flag with static &lt;a href=&quot;../../language/storage_duration#Storage_duration&quot;&gt;storage duration&lt;/a&gt;, this guarantees &lt;a href=&quot;../../language/initialization#Static_initialization&quot;&gt;static initialization&lt;/a&gt;: the flag can be used in constructors of static objects.</source>
          <target state="translated">Кроме того, &lt;code&gt;&lt;a href=&quot;../atomic_flag&quot;&gt;std::atomic_flag&lt;/a&gt;&lt;/code&gt; может быть инициализирован значением для очистки состояния с помощью выражения &lt;code&gt;&lt;a href=&quot;../atomic_flag_init&quot;&gt;ATOMIC_FLAG_INIT&lt;/a&gt;&lt;/code&gt; . Для atomic_flag со статической &lt;a href=&quot;../../language/storage_duration#Storage_duration&quot;&gt;продолжительностью хранения&lt;/a&gt; это гарантирует &lt;a href=&quot;../../language/initialization#Static_initialization&quot;&gt;статическую инициализацию&lt;/a&gt; : флаг может использоваться в конструкторах статических объектов.</target>
        </trans-unit>
        <trans-unit id="7f193d95fb5f81fb5974342efbdfb55ebd6bb874" translate="yes" xml:space="preserve">
          <source>In addition, &lt;code&gt;std::cerr.tie()&lt;/code&gt; returns &lt;code&gt;&amp;amp;&lt;a href=&quot;cout&quot;&gt;std::cout&lt;/a&gt;&lt;/code&gt; (same for &lt;code&gt;wcerr&lt;/code&gt; and &lt;code&gt;wcout&lt;/code&gt;), meaning that any output operation on &lt;code&gt;std::cerr&lt;/code&gt; first executes &lt;code&gt;&lt;a href=&quot;cout&quot;&gt;std::cout&lt;/a&gt;.flush()&lt;/code&gt; (via &lt;code&gt;&lt;a href=&quot;basic_ostream/sentry&quot;&gt;std::basic_ostream::sentry&lt;/a&gt;&lt;/code&gt;'s constructor) (since C++11).</source>
          <target state="translated">Кроме того, &lt;code&gt;std::cerr.tie()&lt;/code&gt; возвращает &lt;code&gt;&amp;amp;&lt;a href=&quot;cout&quot;&gt;std::cout&lt;/a&gt;&lt;/code&gt; (то же самое для &lt;code&gt;wcerr&lt;/code&gt; и &lt;code&gt;wcout&lt;/code&gt; ), что означает, что любая операция вывода в &lt;code&gt;std::cerr&lt;/code&gt; сначала выполняет &lt;code&gt;&lt;a href=&quot;cout&quot;&gt;std::cout&lt;/a&gt;.flush()&lt;/code&gt; (через &lt;code&gt;&lt;a href=&quot;basic_ostream/sentry&quot;&gt;std::basic_ostream::sentry&lt;/a&gt;&lt;/code&gt; ) (начиная с C ++ 11).</target>
        </trans-unit>
        <trans-unit id="fa95bff2b2f1d155be7f57dab28372be4d7eb068" translate="yes" xml:space="preserve">
          <source>In addition, C-style cast notation is allowed to cast from, to, and between pointers to incomplete class type. If both expression and new_type are pointers to incomplete class types, it's unspecified whether static_cast or reinterpret_cast gets selected.</source>
          <target state="translated">Кроме того,разрешено использовать нотацию в стиле C для различения от,к и между указателями к неполному типу класса.Если и выражение,и новый_тип являются указателями на незавершенные типы классов,то не указывается,будет ли выбрано static_cast или reinterpret_cast.</target>
        </trans-unit>
        <trans-unit id="ce46012134e55d98fb6c46e02b9a75f51edf17ba" translate="yes" xml:space="preserve">
          <source>In addition, a typical implementation holds a data member of type &lt;code&gt;&lt;a href=&quot;ios_base/openmode&quot;&gt;std::ios_base::openmode&lt;/a&gt;&lt;/code&gt; to indicate the status of the stream (input-only, output-only, input/output, at-end, etc).</source>
          <target state="translated">Кроме того, типичная реализация содержит элемент данных типа &lt;code&gt;&lt;a href=&quot;ios_base/openmode&quot;&gt;std::ios_base::openmode&lt;/a&gt;&lt;/code&gt; для указания состояния потока (только для ввода, только для вывода, ввода / вывода, конца и т. Д.).</target>
        </trans-unit>
        <trans-unit id="f488b539106ae565b1a7adaef610b9d6be03b1fa" translate="yes" xml:space="preserve">
          <source>In addition, a value-initialized object of the type must produce a null value of that type. This null value shall only be equivalent to itself. Default initialization of the type may have an indeterminate value.</source>
          <target state="translated">Кроме того,инициализированный по значению объект данного типа должен выдавать нулевое значение этого типа.Это нулевое значение должно быть эквивалентно только самому себе.Инициализация типа по умолчанию может иметь неопределенное значение.</target>
        </trans-unit>
        <trans-unit id="7a8db860cf41b64de062e0a8128719f25222688f" translate="yes" xml:space="preserve">
          <source>In addition, accesses to atomic objects may establish inter-thread synchronization and order non-atomic memory accesses as specified by &lt;code&gt;&lt;a href=&quot;memory_order&quot;&gt;std::memory_order&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Кроме того, доступ к атомарным объектам может установить межпотоковую синхронизацию и упорядочить &lt;code&gt;&lt;a href=&quot;memory_order&quot;&gt;std::memory_order&lt;/a&gt;&lt;/code&gt; доступ к памяти, как указано в std :: memory_order .</target>
        </trans-unit>
        <trans-unit id="15638d0e65e84f9a793f46e162b9a6f8ac56803a" translate="yes" xml:space="preserve">
          <source>In addition, all names declared in &lt;a href=&quot;namespace&quot;&gt;unnamed namespace&lt;/a&gt; or a namespace within an unnamed namespace, even ones explicitly declared &lt;code&gt;extern&lt;/code&gt;, have internal linkage.</source>
          <target state="translated">Кроме того, все имена, объявленные в &lt;a href=&quot;namespace&quot;&gt;безымянном пространстве имен&lt;/a&gt; или в пространстве имен в безымянном пространстве имен, даже те, которые явно объявлены &lt;code&gt;extern&lt;/code&gt; , имеют внутреннюю связь.</target>
        </trans-unit>
        <trans-unit id="49487efebaebbb07ca06e7cb34f9dc3b236bdf9b" translate="yes" xml:space="preserve">
          <source>In addition, evaluation of that expression is not allowed to call non-const member functions of the dereferenced iterators.</source>
          <target state="translated">Кроме того,оценка этого выражения не позволяет вызывать функции,не являющиеся членами константы,у разыменованных итераторов.</target>
        </trans-unit>
        <trans-unit id="ff0e19edf9941c628d63cc46fd91d50b5ee3522e" translate="yes" xml:space="preserve">
          <source>In addition, every locale object constructed in a C++ program implements its own (locale-specific) versions of these four specializations.</source>
          <target state="translated">Кроме того,каждый объект локали,построенный в программе на языке Си++,реализует свои собственные (локально-специфические)версии этих четырех специализаций.</target>
        </trans-unit>
        <trans-unit id="34a1ac7c8b7c33c94bfab7f6061398698b960b4f" translate="yes" xml:space="preserve">
          <source>In addition, every locale object constructed in a C++ program implements its own (locale-specific) versions of these specializations.</source>
          <target state="translated">Кроме того,каждый объект локали,построенный в программе на языке Си++,реализует свои собственные (локально-специфические)версии этих специализаций.</target>
        </trans-unit>
        <trans-unit id="d46580f66bb3168b2878f24c3024ecea21ce496c" translate="yes" xml:space="preserve">
          <source>In addition, for each class template &lt;code&gt;std::basic_&lt;i&gt;T&lt;/i&gt;&lt;/code&gt; declared in this header, &lt;code&gt;std::&lt;i&gt;T&lt;/i&gt;&lt;/code&gt; and &lt;code&gt;std::w&lt;i&gt;T&lt;/i&gt;&lt;/code&gt; are declared as a synonym of &lt;code&gt;std::basic_&lt;i&gt;T&lt;/i&gt;&amp;lt;char&amp;gt;&lt;/code&gt; and &lt;code&gt;std::basic_&lt;i&gt;T&lt;/i&gt;&amp;lt;wchar_t&amp;gt;&lt;/code&gt; respectively.</source>
          <target state="translated">Кроме того, для каждого шаблона класса &lt;code&gt;std::basic_&lt;i&gt;T&lt;/i&gt;&lt;/code&gt; объявленного в этом заголовке, &lt;code&gt;std::&lt;i&gt;T&lt;/i&gt;&lt;/code&gt; и &lt;code&gt;std::w&lt;i&gt;T&lt;/i&gt;&lt;/code&gt; объявляются как синоним &lt;code&gt;std::basic_&lt;i&gt;T&lt;/i&gt;&amp;lt;char&amp;gt;&lt;/code&gt; и &lt;code&gt;std::basic_&lt;i&gt;T&lt;/i&gt;&amp;lt;wchar_t&amp;gt;&lt;/code&gt; соответственно.</target>
        </trans-unit>
        <trans-unit id="5d1d9f9e3417a73b82b4272cc321a2469fc45949" translate="yes" xml:space="preserve">
          <source>In addition, if the lvalue is of volatile-qualified class type, a volatile copy-constructor is required to initialize the resulting rvalue temporary.</source>
          <target state="translated">Кроме того,если значение l относится к классу летучих,то для временной инициализации результирующего значения требуется летучий копировально-конструктор.</target>
        </trans-unit>
        <trans-unit id="9ce4f9734cf334aa096d562134cd27bb864fe82d" translate="yes" xml:space="preserve">
          <source>In addition, implementations are allowed to:</source>
          <target state="translated">Кроме того,реализация разрешена:</target>
        </trans-unit>
        <trans-unit id="6fca944845bc26e72a63f6ee2aaf3fc85bb418c7" translate="yes" xml:space="preserve">
          <source>In addition, it's undefined behavior to #define or #undef names identical to &lt;a href=&quot;../keywords&quot;&gt;keywords&lt;/a&gt;. If at least one standard library header is included, it's undefined behavior to #define or #undef identifiers identical to names declared in any standard library header.</source>
          <target state="translated">Кроме того, поведение #define или #undef, идентичное &lt;a href=&quot;../keywords&quot;&gt;ключевым словам, не определено&lt;/a&gt; . Если включен хотя бы один стандартный заголовок библиотеки, поведение #define или #undef идентично идентификаторам, объявленным в любом заголовке стандартной библиотеки.</target>
        </trans-unit>
        <trans-unit id="9d2f44e82fedbe71cbece0ffe227d0a0158a8b14" translate="yes" xml:space="preserve">
          <source>In addition, many &lt;a href=&quot;../types&quot;&gt;type traits&lt;/a&gt; are implemented using SFINAE.</source>
          <target state="translated">Кроме того, многие &lt;a href=&quot;../types&quot;&gt;черты типа&lt;/a&gt; реализованы с использованием SFINAE.</target>
        </trans-unit>
        <trans-unit id="e92c1e872be57b036dbc2507bb5706e7b76dcd09" translate="yes" xml:space="preserve">
          <source>In addition, member and non-member functions are provided to support the following operations:</source>
          <target state="translated">Кроме того,выполняются функции членов и не членов для поддержки следующих операций:</target>
        </trans-unit>
        <trans-unit id="89093684fff07258cc05ff168ca489272759c61f" translate="yes" xml:space="preserve">
          <source>In addition, so-called</source>
          <target state="translated">Кроме того,так называемый</target>
        </trans-unit>
        <trans-unit id="29000479e98fa4979896c6eb46f598587861c215" translate="yes" xml:space="preserve">
          <source>In addition, synchronized C++ streams are guaranteed to be thread-safe (individual characters output from multiple threads may interleave, but no data races occur).</source>
          <target state="translated">Кроме того,синхронизированные потоки C++гарантированно являются потокобезопасными (отдельные символы,выводимые из нескольких потоков,могут чередоваться,но при этом не происходит никаких гонок данных).</target>
        </trans-unit>
        <trans-unit id="5fea8ea2966b10c7537944404433308f3b7b4ff6" translate="yes" xml:space="preserve">
          <source>In addition, the following standard library facilities accept any Callable type (not just &lt;a href=&quot;functionobject&quot;&gt;FunctionObject&lt;/a&gt;).</source>
          <target state="translated">Кроме того, следующие стандартные библиотечные средства принимают любой тип Callable (не только &lt;a href=&quot;functionobject&quot;&gt;FunctionObject&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="6c22d022938dfbf51f3ef71122c0c58581f4ff83" translate="yes" xml:space="preserve">
          <source>In addition, the implicit conversion in copy-initialization must produce &lt;code&gt;T&lt;/code&gt; directly from the initializer, while, e.g. direct-initialization expects an implicit conversion from the initializer to an argument of &lt;code&gt;T&lt;/code&gt;'s constructor.</source>
          <target state="translated">Кроме того, неявное преобразование в копии инициализации должно производить &lt;code&gt;T&lt;/code&gt; непосредственно из инициализатора, в то время как, например , прямая инициализация ожидает , что неявное преобразование от инициализатора в качестве аргумента &lt;code&gt;T&lt;/code&gt; конструктора &amp;laquo;ы.</target>
        </trans-unit>
        <trans-unit id="92a67045a12eca5e07b1c4404b9093c3441f456c" translate="yes" xml:space="preserve">
          <source>In addition, the standard exception types &lt;code&gt;&lt;a href=&quot;../range_error/range_error&quot;&gt;std::range_error&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../overflow_error/overflow_error&quot;&gt;std::overflow_error&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../underflow_error/underflow_error&quot;&gt;std::underflow_error&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../../regex/regex_error&quot;&gt;std::regex_error&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;../system_error&quot;&gt;std::system_error&lt;/a&gt;&lt;/code&gt; are derived from &lt;code&gt;std::runtime_error&lt;/code&gt;.</source>
          <target state="translated">Кроме того, стандартные типы исключений &lt;code&gt;&lt;a href=&quot;../range_error/range_error&quot;&gt;std::range_error&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../overflow_error/overflow_error&quot;&gt;std::overflow_error&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../underflow_error/underflow_error&quot;&gt;std::underflow_error&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../../regex/regex_error&quot;&gt;std::regex_error&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;../system_error&quot;&gt;std::system_error&lt;/a&gt;&lt;/code&gt; являются производными от &lt;code&gt;std::runtime_error&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="46ca753eadbc6e64c330f063c04cf76079373fe6" translate="yes" xml:space="preserve">
          <source>In addition, the standard library offers several RAII wrappers to manage user-provided resources:</source>
          <target state="translated">Кроме того,стандартная библиотека предлагает несколько RAII-оберток для управления ресурсами,предоставляемыми пользователями:</target>
        </trans-unit>
        <trans-unit id="891107f99b45712dab34dbd0d5adc64b629b07b9" translate="yes" xml:space="preserve">
          <source>In addition, two function templates are</source>
          <target state="translated">Кроме того,два шаблона функций</target>
        </trans-unit>
        <trans-unit id="ff24fd16f36ec6c36c829ad13c5fdc98ceb02332" translate="yes" xml:space="preserve">
          <source>In addition, unparenthesized type is greedy: it will include every token that can be a part of a declarator:</source>
          <target state="translated">Кроме того,непарентированный тип является жадным:он будет включать в себя каждую лексель,которая может быть частью декларатора:</target>
        </trans-unit>
        <trans-unit id="33a1d90854c6b62d20682a431d3deb3e352e1570" translate="yes" xml:space="preserve">
          <source>In addition, volatile accesses are not atomic (concurrent read and write is a &lt;a href=&quot;../language/memory_model&quot;&gt;data race&lt;/a&gt;) and do not order memory (non-volatile memory accesses may be freely reordered around the volatile access).</source>
          <target state="translated">Кроме того, энергозависимые обращения не являются атомарными (одновременное чтение и запись - это &lt;a href=&quot;../language/memory_model&quot;&gt;гонка данных&lt;/a&gt; ) и не упорядочивают память (доступ к энергонезависимой памяти может свободно переупорядочиваться вокруг энергозависимого доступа).</target>
        </trans-unit>
        <trans-unit id="3cb2abcf8bbfd3a7bfabbd1249bd200fcbc8e347" translate="yes" xml:space="preserve">
          <source>In addition, within the namespace &lt;code&gt;std::chrono&lt;/code&gt;, the directive &lt;code&gt;using namespace literals::chrono_literals;&lt;/code&gt; is provided by the standard library, so that if a programmer uses &lt;code&gt;using namespace std::chrono;&lt;/code&gt; to gain access to the classes in the chrono library, the corresponding literal operators become visible as well.</source>
          <target state="translated">Кроме того, в пространстве имен &lt;code&gt;std::chrono&lt;/code&gt; , директива &lt;code&gt;using namespace literals::chrono_literals;&lt;/code&gt; предоставляется стандартной библиотекой, так что если программист использует &lt;code&gt;using namespace std::chrono;&lt;/code&gt; чтобы получить доступ к классам в библиотеке хронографа, также становятся видимыми соответствующие литеральные операторы.</target>
        </trans-unit>
        <trans-unit id="208c76a1040cc2d170e334de617b92960c4a9549" translate="yes" xml:space="preserve">
          <source>In all cases in which the call to &lt;code&gt;regex_search&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt;, &lt;code&gt;match.prefix().first&lt;/code&gt; will be equal to the previous value of &lt;code&gt;match[0].second&lt;/code&gt; and for each index</source>
          <target state="translated">Во всех случаях, когда вызов &lt;code&gt;regex_search&lt;/code&gt; возвращает &lt;code&gt;true&lt;/code&gt; , &lt;code&gt;match.prefix().first&lt;/code&gt; будет равен предыдущему значению &lt;code&gt;match[0].second&lt;/code&gt; и для каждого индекса</target>
        </trans-unit>
        <trans-unit id="b3e3fd9de0235c44f06b8f45f6682e2f71d0e99c" translate="yes" xml:space="preserve">
          <source>In all cases the deleter is initialized from &lt;code&gt;&lt;a href=&quot;../../utility/forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;decltype(d)&amp;gt;(d)&lt;/code&gt;.</source>
          <target state="translated">Во всех случаях средство удаления инициализируется из &lt;code&gt;&lt;a href=&quot;../../utility/forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;decltype(d)&amp;gt;(d)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="702fc4c8ea20caf42025f3c5b2479929ca73939e" translate="yes" xml:space="preserve">
          <source>In all cases, a constructor selected to copy or move an object is odr-used even if &lt;a href=&quot;copy_elision&quot;&gt;copy elision&lt;/a&gt; takes place.</source>
          <target state="translated">Во всех случаях конструктор, выбранный для копирования или перемещения объекта, используется в odr, даже если имеет место &lt;a href=&quot;copy_elision&quot;&gt;исключение копирования&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="448921a2325557aed9e228f8da4e834b6e28cdeb" translate="yes" xml:space="preserve">
          <source>In all cases, attr is an optional sequence of &lt;a href=&quot;attributes&quot;&gt;attributes&lt;/a&gt;. When appearing immediately after the identifier, it applies to the object being declared.</source>
          <target state="translated">Во всех случаях attr является необязательной последовательностью &lt;a href=&quot;attributes&quot;&gt;атрибутов&lt;/a&gt; . При появлении сразу после идентификатора он применяется к объявленному объекту.</target>
        </trans-unit>
        <trans-unit id="83161a84bc1a7a51d78f0506c4b7ea19c215e3d3" translate="yes" xml:space="preserve">
          <source>In all cases, cv-qualifiers are ignored by typeid (that is, &lt;code&gt;typeid(const T) == typeid(T)&lt;/code&gt;).</source>
          <target state="translated">Во всех случаях cv-квалификаторы игнорируются typeid (то есть &lt;code&gt;typeid(const T) == typeid(T)&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="10f7d85b749093104c6f7b42f1410b3aa41a5078" translate="yes" xml:space="preserve">
          <source>In all cases, equality is checked by calling &lt;a href=&quot;../char_traits/cmp&quot;&gt;&lt;code&gt;Traits::eq&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Во всех случаях равенство проверяется путем вызова &lt;a href=&quot;../char_traits/cmp&quot;&gt; &lt;code&gt;Traits::eq&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e78e8c07f5b30e31f34be5630e807f2679203b79" translate="yes" xml:space="preserve">
          <source>In all cases, equality is checked by calling &lt;a href=&quot;../char_traits/cmp&quot;&gt;Traits::eq&lt;/a&gt;.</source>
          <target state="translated">Во всех случаях равенство проверяется путем вызова &lt;a href=&quot;../char_traits/cmp&quot;&gt;Traits :: eq&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="42ce3a010af7213a4ee16fafe2f69cd257e4ea24" translate="yes" xml:space="preserve">
          <source>In all cases, for the built-in operators, lhs and rhs must have either.</source>
          <target state="translated">Во всех случаях,для встроенных операторов,lhs и rhs должны иметь либо то,либо другое.</target>
        </trans-unit>
        <trans-unit id="773f0f51c30de4ead22498372e4d412e3f3708c1" translate="yes" xml:space="preserve">
          <source>In all cases, if &lt;code&gt;ptr&lt;/code&gt; is a null pointer, the standard library deallocation functions do nothing. If the pointer passed to the standard library deallocation function was not obtained from the corresponding standard library allocation function, the behavior is undefined.</source>
          <target state="translated">Во всех случаях, если &lt;code&gt;ptr&lt;/code&gt; является нулевым указателем, стандартные функции освобождения библиотеки ничего не делают. Если указатель, переданный в функцию освобождения стандартной библиотеки, не был получен из соответствующей функции выделения стандартной библиотеки, поведение не определено.</target>
        </trans-unit>
        <trans-unit id="013ee203d2185f13defcfecaa9d4ae3f3d4ae52b" translate="yes" xml:space="preserve">
          <source>In all cases, if the empty pair of braces &lt;code&gt;{} &lt;/code&gt; is used and &lt;code&gt;T&lt;/code&gt; is an</source>
          <target state="translated">Во всех случаях, если используется пустая пара фигурных скобок &lt;code&gt;{} &lt;/code&gt; и &lt;code&gt;T&lt;/code&gt; является</target>
        </trans-unit>
        <trans-unit id="9dfb4259d8b5e6ee928f73bc11c3685d70ea5622" translate="yes" xml:space="preserve">
          <source>In all cases, it is the stored pointer (the one returned by &lt;code&gt;&lt;a href=&quot;get&quot;&gt;get()&lt;/a&gt;&lt;/code&gt;) that is compared, rather than the managed pointer (the one passed to the deleter when use_count goes to zero). The two pointers may differ in a shared_ptr created using the aliasing constructor.</source>
          <target state="translated">Во всех случаях сравнивается хранимый указатель (возвращаемый &lt;code&gt;&lt;a href=&quot;get&quot;&gt;get()&lt;/a&gt;&lt;/code&gt; ), а не управляемый указатель (передаваемый удалителю, когда значение use_count обращается в ноль). Два указателя могут отличаться в shared_ptr, созданном с использованием конструктора псевдонимов.</target>
        </trans-unit>
        <trans-unit id="f050a06aeea57760c69721a08f3162ee7c38913e" translate="yes" xml:space="preserve">
          <source>In all cases, the conversion begins in initial shift state, unless non-initial starting state was provided to this &lt;code&gt;wstring_convert&lt;/code&gt; constructor. The number of characters converted and the final value of the conversion state are remembered and can be accessed with &lt;code&gt;&lt;a href=&quot;state&quot;&gt;state()&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;converted&quot;&gt;converted()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Во всех случаях преобразование начинается в начальном смещенном состоянии, если этому конструктору &lt;code&gt;wstring_convert&lt;/code&gt; было предоставлено не начальное начальное состояние . Количество преобразованных символов и конечное значение состояния преобразования запоминаются и могут быть доступны с помощью &lt;code&gt;&lt;a href=&quot;state&quot;&gt;state()&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;converted&quot;&gt;converted()&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="89b8bdb3cdd26cc5757a5fc307bf6e8cbadfa071" translate="yes" xml:space="preserve">
          <source>In all cases, throws &lt;code&gt;&lt;a href=&quot;../../error/length_error/length_error&quot;&gt;std::length_error&lt;/a&gt;&lt;/code&gt; if &lt;code&gt;size() + ins_count &amp;gt; max_size()&lt;/code&gt; where &lt;code&gt;ins_count&lt;/code&gt; is the number of characters that will be inserted and may throw any exceptions thrown by &lt;code&gt;Allocator::allocate&lt;/code&gt;.</source>
          <target state="translated">Во всех случаях выдает &lt;code&gt;&lt;a href=&quot;../../error/length_error/length_error&quot;&gt;std::length_error&lt;/a&gt;&lt;/code&gt; если &lt;code&gt;size() + ins_count &amp;gt; max_size()&lt;/code&gt; где &lt;code&gt;ins_count&lt;/code&gt; - количество символов, которое будет вставлено, и может выдавать любые исключения, &lt;code&gt;Allocator::allocate&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a6bec4825b469bd22420b217d83b3fa4ef3c1c3f" translate="yes" xml:space="preserve">
          <source>In all other cases the result is &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">Во всех остальных случаях результат &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c0ee8040c05c6072650b3fc884f5719734c12fb2" translate="yes" xml:space="preserve">
          <source>In all other cases, neither template is more specialized than the other with regards to the type(s) deduced by this P/A pair.</source>
          <target state="translated">Во всех остальных случаях ни один шаблон не является более специализированным,чем другой,в отношении типа(ов),вычитаемого(ых)этой парой Р/А.</target>
        </trans-unit>
        <trans-unit id="e58e6d192ec64176fdc1379f81dba51aa0d986c8" translate="yes" xml:space="preserve">
          <source>In all other cases, the result is exact (&lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INEXACT&lt;/a&gt;&lt;/code&gt; is never raised) and &lt;a href=&quot;../fenv/fe_round&quot;&gt;the current rounding mode&lt;/a&gt; is ignored</source>
          <target state="translated">Во всех остальных случаях результат является точным ( &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INEXACT&lt;/a&gt;&lt;/code&gt; никогда не поднимается), а &lt;a href=&quot;../fenv/fe_round&quot;&gt;текущий режим округления&lt;/a&gt; игнорируется.</target>
        </trans-unit>
        <trans-unit id="725c5378c2d25e77fa8739dfffb5cdbf3d501bf2" translate="yes" xml:space="preserve">
          <source>In all these contexts, the function selected from the overload set is the function whose type matches the pointer to function, reference to function, or pointer to member function type that is expected by</source>
          <target state="translated">Во всех этих контекстах,функция,выбранная из перегрузочного множества,является функцией,тип которой соответствует указателю на функцию,ссылке на функцию или указателю на тип функции-члена,который ожидается посредством</target>
        </trans-unit>
        <trans-unit id="42e33142558dfcb4a52d9857fc0366f3d6fbcb3d" translate="yes" xml:space="preserve">
          <source>In an inline function,</source>
          <target state="translated">Встроенная функция,</target>
        </trans-unit>
        <trans-unit id="e54ee587ae8370595daaa17b48b214c6cedbda36" translate="yes" xml:space="preserve">
          <source>In any case, &lt;code&gt;std::terminate&lt;/code&gt; calls the currently installed &lt;code&gt;&lt;a href=&quot;terminate_handler&quot;&gt;std::terminate_handler&lt;/a&gt;&lt;/code&gt;. The default &lt;code&gt;&lt;a href=&quot;terminate_handler&quot;&gt;std::terminate_handler&lt;/a&gt;&lt;/code&gt; calls &lt;code&gt;&lt;a href=&quot;../utility/program/abort&quot;&gt;std::abort&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">В любом случае, &lt;code&gt;std::terminate&lt;/code&gt; вызывает текущий установленный &lt;code&gt;&lt;a href=&quot;terminate_handler&quot;&gt;std::terminate_handler&lt;/a&gt;&lt;/code&gt; . Стандартный &lt;code&gt;&lt;a href=&quot;terminate_handler&quot;&gt;std::terminate_handler&lt;/a&gt;&lt;/code&gt; вызывает &lt;code&gt;&lt;a href=&quot;../utility/program/abort&quot;&gt;std::abort&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d3dd5c3a82e6a3c58b090861766b926905a15762" translate="yes" xml:space="preserve">
          <source>In any case, &lt;code&gt;str.width(0)&lt;/code&gt; is called to cancel the effects of &lt;code&gt;&lt;a href=&quot;../../io/manip/setw&quot;&gt;std::setw&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">В любом случае, &lt;code&gt;str.width(0)&lt;/code&gt; вызывается для отмены эффектов &lt;code&gt;&lt;a href=&quot;../../io/manip/setw&quot;&gt;std::setw&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6c3348754a124fedffbdcc31ba4b5c403932481c" translate="yes" xml:space="preserve">
          <source>In any case, an additional fictional function template derived as above from a hypothetical constructor &lt;code&gt;C(C)&lt;/code&gt; is added, called the copy deduction candidate.</source>
          <target state="translated">В любом случае добавляется дополнительный шаблон вымышленной функции, полученный, как указано выше, из гипотетического конструктора &lt;code&gt;C(C)&lt;/code&gt; , называемый кандидатом на вычет копирования.</target>
        </trans-unit>
        <trans-unit id="fa4b872de2f5ce03a3a38ccff298fd27acc8cd7f" translate="yes" xml:space="preserve">
          <source>In any case, container operations (as well as algorithms, or any other C++ standard library functions) may be parallelized internally as long as this does not change the user-visible results (e.g. &lt;code&gt;&lt;a href=&quot;algorithm/transform&quot;&gt;std::transform&lt;/a&gt;&lt;/code&gt; may be parallelized, but not &lt;code&gt;&lt;a href=&quot;algorithm/for_each&quot;&gt;std::for_each&lt;/a&gt;&lt;/code&gt; which is specified to visit each element of a sequence in order)</source>
          <target state="translated">В любом случае контейнерные операции (а также алгоритмы или любые другие стандартные функции библиотеки C ++) могут быть распараллелены внутри, если это не изменит видимых пользователю результатов (например, &lt;code&gt;&lt;a href=&quot;algorithm/transform&quot;&gt;std::transform&lt;/a&gt;&lt;/code&gt; может быть распараллелен, но не &lt;code&gt;&lt;a href=&quot;algorithm/for_each&quot;&gt;std::for_each&lt;/a&gt;&lt;/code&gt; , который указан для посещения каждого элемента последовательности по порядку)</target>
        </trans-unit>
        <trans-unit id="2da0390056e4062badb9f03f93f263c86a863ecf" translate="yes" xml:space="preserve">
          <source>In any case, if &lt;code&gt;count&amp;gt;0&lt;/code&gt;, it then stores a null character &lt;code&gt;CharT()&lt;/code&gt; into the next successive location of the array and updates &lt;code&gt;gcount()&lt;/code&gt;.</source>
          <target state="translated">В любом случае, если &lt;code&gt;count&amp;gt;0&lt;/code&gt; , он сохраняет нулевой символ &lt;code&gt;CharT()&lt;/code&gt; в следующем последовательном местоположении массива и обновляет &lt;code&gt;gcount()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4df2d850754842c746a077f1d7414c07173a5713" translate="yes" xml:space="preserve">
          <source>In any case, if U is an incomplete type, the program is ill-formed.</source>
          <target state="translated">В любом случае,если U является неполным типом,программа плохо сформирована.</target>
        </trans-unit>
        <trans-unit id="ea9753e092b975406e86e9a75ca8490421b85d80" translate="yes" xml:space="preserve">
          <source>In any case, if an exception is thrown for any reason, this function has no effect (strong exception guarantee).</source>
          <target state="translated">В любом случае,если по какой-либо причине выбрасывается исключение,эта функция не имеет никакого эффекта (сильная гарантия исключения).</target>
        </trans-unit>
        <trans-unit id="6ea5742f9037c3ece834bf38253ccb990e6ae335" translate="yes" xml:space="preserve">
          <source>In any case, if an exception is thrown for any reason, this function has no effect (strong exception guarantee).(since C++11).</source>
          <target state="translated">В любом случае,если по какой-то причине выбрасывается исключение,эта функция не имеет никакого эффекта (сильная гарантия исключения).(начиная с C++11).</target>
        </trans-unit>
        <trans-unit id="5ad29af16c7a4b0eae9f716a384a3fe434c038e3" translate="yes" xml:space="preserve">
          <source>In any case, if any part of a type name is non-deduced, the entire type name is non-deduced context. However, compound types can include both deduced and non-deduced type names. For example, in &lt;code&gt;A&amp;lt;T&amp;gt;::B&amp;lt;T2&amp;gt;&lt;/code&gt;, &lt;code&gt;T&lt;/code&gt; is non-deduced because of rule #1 (nested name specifier), and &lt;code&gt;T2&lt;/code&gt; is non-deduced because it is part of the same type name, but in &lt;code&gt;void(*f)(typename A&amp;lt;T&amp;gt;::B, A&amp;lt;T&amp;gt;)&lt;/code&gt;, the &lt;code&gt;T&lt;/code&gt; in &lt;code&gt;A&amp;lt;T&amp;gt;::B&lt;/code&gt; is non-deduced (because of the same rule), while the &lt;code&gt;T&lt;/code&gt; in &lt;code&gt;A&amp;lt;T&amp;gt;&lt;/code&gt; is deduced.</source>
          <target state="translated">В любом случае, если какая-либо часть имени типа не выводится, все имя типа является не выводимым контекстом. Однако составные типы могут включать как выведенные, так и не выведенные имена типов. Например, в &lt;code&gt;A&amp;lt;T&amp;gt;::B&amp;lt;T2&amp;gt;&lt;/code&gt; , &lt;code&gt;T&lt;/code&gt; не является выводится из правила # 1 (вложенное имя спецификатора), и &lt;code&gt;T2&lt;/code&gt; не является выводом , потому что она является частью того же имя типа, но и в &lt;code&gt;void(*f)(typename A&amp;lt;T&amp;gt;::B, A&amp;lt;T&amp;gt;)&lt;/code&gt; , &lt;code&gt;T&lt;/code&gt; в &lt;code&gt;A&amp;lt;T&amp;gt;::B&lt;/code&gt; не выводится (из-за того же правила), а &lt;code&gt;T&lt;/code&gt; в &lt;code&gt;A&amp;lt;T&amp;gt;&lt;/code&gt; выводится.</target>
        </trans-unit>
        <trans-unit id="bac936a68f34bcde27ef8af2c5541d05870721a4" translate="yes" xml:space="preserve">
          <source>In any case, if the conversion function fails &lt;code&gt;&lt;a href=&quot;../../io/ios_base/iostate&quot;&gt;std::ios_base::failbit&lt;/a&gt;&lt;/code&gt; is assigned to &lt;code&gt;err&lt;/code&gt;</source>
          <target state="translated">В любом случае, если функция преобразования завершается с ошибкой, &lt;code&gt;&lt;a href=&quot;../../io/ios_base/iostate&quot;&gt;std::ios_base::failbit&lt;/a&gt;&lt;/code&gt; назначается для &lt;code&gt;err&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f692dd6979a28b812ff55210b84b6db94eddba7d" translate="yes" xml:space="preserve">
          <source>In any case, if the pointed-to type is different from the array element type, disregarding cv qualifications, at every level if the elements are themselves pointers, the behavior of pointer arithmetic is undefined. In particular, pointer arithmetic with pointer to base, which is pointing at an element of an array of derived objects is undefined.</source>
          <target state="translated">В любом случае,если указанный тип отличается от типа элемента массива,без учета квалификаций cv,на каждом уровне,если элементы сами по себе являются указателями,поведение арифметики с указателями является неопределенным.В частности,арифметика с указателями на базу,которая указывает на элемент массива производных объектов,не определена.</target>
        </trans-unit>
        <trans-unit id="a6713811e3c955566cd61aabae4ba44639991bc9" translate="yes" xml:space="preserve">
          <source>In any case, if the value of the right operand is negative or is greater or equal to the number of bits in the promoted left operand, the behavior is undefined.</source>
          <target state="translated">В любом случае,если значение правого операнда отрицательное,больше или равно количеству битов в раскрученном левом операнде,поведение не определено.</target>
        </trans-unit>
        <trans-unit id="e408e1ffc24f4902a539b882cf7a3ebb2a011be7" translate="yes" xml:space="preserve">
          <source>In any case, sets the &lt;code&gt;gcount()&lt;/code&gt; counter to zero.</source>
          <target state="translated">В любом случае устанавливает &lt;code&gt;gcount()&lt;/code&gt; на ноль.</target>
        </trans-unit>
        <trans-unit id="3d278d5d6ccb754380b757eb2f8bd5786624cf05" translate="yes" xml:space="preserve">
          <source>In any case, the argument list for the purpose of overload resolution is the argument list of the function call expression preceded by the implied object argument &lt;code&gt;E&lt;/code&gt; (when matching against the surrogate function, the user-defined conversion will automatically convert the implied object argument to the first argument of the surrogate function).</source>
          <target state="translated">В любом случае список аргументов для разрешения перегрузки является списком аргументов выражения вызова функции, которому предшествует неявный аргумент объекта &lt;code&gt;E&lt;/code&gt; (при сопоставлении с суррогатной функцией пользовательское преобразование автоматически преобразует неявный аргумент объекта в первый аргумент суррогатной функции).</target>
        </trans-unit>
        <trans-unit id="ba7e54962dc6ba91c1893f539a5af9b0dd3bcd03" translate="yes" xml:space="preserve">
          <source>In any case, the call to &lt;code&gt;std::async&lt;/code&gt;</source>
          <target state="translated">В любом случае вызов &lt;code&gt;std::async&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ac7f68c6ecc54f2511911cdf7e14078e65684035" translate="yes" xml:space="preserve">
          <source>In any case, the check is made whether the &lt;code&gt;char&lt;/code&gt; obtained from the previous steps is allowed in the input field that would be parsed by &lt;code&gt;&lt;a href=&quot;../../io/c/scanf&quot;&gt;std::scanf&lt;/a&gt;&lt;/code&gt; given the conversion specifier selected in Stage 1. If it is allowed, it is accumulated in a temporary buffer and Stage 2 repeats. If it is not allowed, Stage 2 terminates.</source>
          <target state="translated">В любом случае выполняется проверка, разрешен ли &lt;code&gt;char&lt;/code&gt; полученный на предыдущих шагах, в поле ввода, которое будет проанализировано &lt;code&gt;&lt;a href=&quot;../../io/c/scanf&quot;&gt;std::scanf&lt;/a&gt;&lt;/code&gt; учетом спецификатора преобразования, выбранного на этапе 1. Если это разрешено, он накапливается в временный буфер и этап 2 повторяется. Если это не разрешено, этап 2 завершается.</target>
        </trans-unit>
        <trans-unit id="7239f4c6ede432f98a1ba74015ef9a8efc5ff852" translate="yes" xml:space="preserve">
          <source>In any case, the path class behaves as if it stores a pathname in the native format and automatically converts to generic format as needed (each member function specifies which format it interprets the path as).</source>
          <target state="translated">В любом случае,класс пути ведет себя так,как будто хранит путь в родном формате и при необходимости автоматически преобразует его в общий формат (каждая функция-член определяет,в каком формате он интерпретирует путь).</target>
        </trans-unit>
        <trans-unit id="d3d5f9fb69cc2220358beed9110dba0f5144fa1f" translate="yes" xml:space="preserve">
          <source>In any case, the result is a &lt;code&gt;bool&lt;/code&gt; prvalue.</source>
          <target state="translated">В любом случае, результатом является предварительное значение &lt;code&gt;bool&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bdbc8735ab228c93f4f0db0b86729ff991ed9876" translate="yes" xml:space="preserve">
          <source>In any case, the resulting value is one of at most two floating-point values closest to the value of the string matching the pattern, after rounding according to &lt;code&gt;&lt;a href=&quot;../types/numeric_limits/float_round_style&quot;&gt;std::round_to_nearest&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">В любом случае результирующее значение является одним из не более двух значений с плавающей точкой, ближайших к значению строки, соответствующей шаблону, после округления в соответствии с &lt;code&gt;&lt;a href=&quot;../types/numeric_limits/float_round_style&quot;&gt;std::round_to_nearest&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c407d2239a1860dec731b410278172d7d1e7af2e" translate="yes" xml:space="preserve">
          <source>In any case, updates the private member variable that is accessed by &lt;code&gt;&lt;a href=&quot;is_open&quot;&gt;is_open()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">В любом случае обновляет закрытую переменную-член, к которой &lt;code&gt;&lt;a href=&quot;is_open&quot;&gt;is_open()&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fd58a7b2537b4b1d9769b336c69ed0405e2bf357" translate="yes" xml:space="preserve">
          <source>In any event, whether terminating by exception or returning, the sentry's destructor is called before leaving this function.</source>
          <target state="translated">В любом случае,будь то прекращение по причине исключения или возвращение,перед выходом из этой функции вызывается деструктор часового.</target>
        </trans-unit>
        <trans-unit id="9d70a008be456375cc51641818d2f498b0e8cfe0" translate="yes" xml:space="preserve">
          <source>In both cases, virt-specifier-seq, if used, is either &lt;code&gt;override&lt;/code&gt; or &lt;a href=&quot;final&quot;&gt;final&lt;/a&gt;, or &lt;code&gt;final override&lt;/code&gt; or &lt;code&gt;override final&lt;/code&gt;.</source>
          <target state="translated">В обоих случаях virt-specier-seq, если используется, является либо &lt;code&gt;override&lt;/code&gt; или &lt;a href=&quot;final&quot;&gt;final&lt;/a&gt; , либо &lt;code&gt;final override&lt;/code&gt; , либо &lt;code&gt;override final&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7735a0f86f64131cc2baeb3f9d91024df4a0f2ac" translate="yes" xml:space="preserve">
          <source>In brief, a class that defines &lt;code&gt;operator&amp;lt;=&amp;gt;&lt;/code&gt; automatically gets compiler-generated operators ==, !=, &amp;lt;, &amp;lt;=, &amp;gt;, and &amp;gt;=. A class can define &lt;code&gt;operator&amp;lt;=&amp;gt;&lt;/code&gt; as defaulted, in which case the compiler will also generate the code for that operator.</source>
          <target state="translated">Вкратце, класс, который определяет &lt;code&gt;operator&amp;lt;=&amp;gt;&lt;/code&gt; автоматически получает сгенерированные компилятором операторы ==,! =, &amp;lt;, &amp;lt;=,&amp;gt; И&amp;gt; =. Класс может определить &lt;code&gt;operator&amp;lt;=&amp;gt;&lt;/code&gt; по умолчанию, и в этом случае компилятор также сгенерирует код для этого оператора.</target>
        </trans-unit>
        <trans-unit id="b4aca348b75aa570f1a0831d21e79e759aa35c7a" translate="yes" xml:space="preserve">
          <source>In case of ambiguity between a variable declaration using the direct-initialization syntax (1) (with round parentheses) and a &lt;a href=&quot;function&quot;&gt;function declaration&lt;/a&gt;, the compiler always chooses function declaration. This disambiguation rule is sometimes counter-intuitive and has been called the &lt;a href=&quot;https://en.wikipedia.org/wiki/Most_vexing_parse&quot;&gt;most vexing parse&lt;/a&gt;.</source>
          <target state="translated">В случае неоднозначности между объявлением переменной с использованием синтаксиса прямой инициализации (1) (с круглыми скобками) и &lt;a href=&quot;function&quot;&gt;объявлением функции&lt;/a&gt; , компилятор всегда выбирает объявление функции. Это правило устранения неоднозначности иногда нелогично и называется &lt;a href=&quot;https://en.wikipedia.org/wiki/Most_vexing_parse&quot;&gt;самым неприятным анализом&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="901202dfb183bd5273740fd75a6cb4999a9adde4" translate="yes" xml:space="preserve">
          <source>In case of ambiguity between a variable declaration using the direct-initialization syntax and a function declaration, the compiler always chooses function declaration; see &lt;a href=&quot;direct_initialization#Notes&quot;&gt;direct-initialization&lt;/a&gt;.</source>
          <target state="translated">В случае неоднозначности между объявлением переменной с использованием синтаксиса прямой инициализации и объявлением функции, компилятор всегда выбирает объявление функции; см &lt;a href=&quot;direct_initialization#Notes&quot;&gt;прямая инициализация&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="584cb1daba5fb668ec776aaad71f0f0a1e678a65" translate="yes" xml:space="preserve">
          <source>In case of ambiguity between the size of the bit field and the default member initializer, the longest sequence of tokens that forms a valid size is chosen:</source>
          <target state="translated">В случае неоднозначности между размером поля бита и инициализатором члена по умолчанию,выбирается самая длинная последовательность токенов,формирующая допустимый размер:</target>
        </trans-unit>
        <trans-unit id="c60f89be5e6a24d3e9af482fb30cc5225a2b9c40" translate="yes" xml:space="preserve">
          <source>In class definition</source>
          <target state="translated">В определении класса</target>
        </trans-unit>
        <trans-unit id="0ed480b0f5f767a36b4cca750fd3df5eb7dea2c0" translate="yes" xml:space="preserve">
          <source>In class template</source>
          <target state="translated">В шаблоне класса</target>
        </trans-unit>
        <trans-unit id="88cf7e36aa40464925cb0cdb822a38f9a11a2e03" translate="yes" xml:space="preserve">
          <source>In class templates, &lt;code&gt;this&lt;/code&gt; is a &lt;a href=&quot;dependent_name&quot;&gt;dependent expression&lt;/a&gt;, and explicit &lt;code&gt;this-&amp;gt;&lt;/code&gt; may be used to force another expression to become dependent.</source>
          <target state="translated">В шаблонах классов &lt;code&gt;this&lt;/code&gt; является &lt;a href=&quot;dependent_name&quot;&gt;зависимым выражением&lt;/a&gt; , и явное &lt;code&gt;this-&amp;gt;&lt;/code&gt; может использоваться, чтобы заставить другое выражение стать зависимым.</target>
        </trans-unit>
        <trans-unit id="9bb902edc779601077555fd4ba8ae150af319a7a" translate="yes" xml:space="preserve">
          <source>In contrast to &lt;code&gt;&lt;a href=&quot;fmod&quot;&gt;std::fmod()&lt;/a&gt;&lt;/code&gt;, the returned value is not guaranteed to have the same sign as &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">В отличие от &lt;code&gt;&lt;a href=&quot;fmod&quot;&gt;std::fmod()&lt;/a&gt;&lt;/code&gt; , возвращаемое значение не обязательно имеет тот же знак, что и &lt;code&gt;x&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="29e6d4a4833ba899fe54d6d48cb6237bf996c237" translate="yes" xml:space="preserve">
          <source>In copy-list-initialization, if phase 2 selects an explicit constructor, the initialization is ill-formed (as opposed to all over copy-initializations where explicit constructors are not even considered).</source>
          <target state="translated">При Copy-list-initialization,если на втором этапе выбирается эксплицитный конструктор,инициализация плохо формируется (в отличие от повсеместных инициализаций копирования,где эксплицитные конструкторы даже не учитываются).</target>
        </trans-unit>
        <trans-unit id="0f662aa9e7fe6829be9755a0bb2464c6d5830c0c" translate="yes" xml:space="preserve">
          <source>In declarations</source>
          <target state="translated">В декларациях</target>
        </trans-unit>
        <trans-unit id="6cfdd0eb8f38950930fcb84521ccaa8ab0f3a576" translate="yes" xml:space="preserve">
          <source>In declarations, attributes may appear both before the whole declaration and directly after the name of the entity that is declared, in which case they are combined. In most other situations, attributes apply to the directly preceding entity.</source>
          <target state="translated">В декларациях атрибуты могут появляться как перед всей декларацией,так и непосредственно после названия декларируемого субъекта,в этом случае они объединяются.В большинстве других ситуаций атрибуты применяются к непосредственно предшествующему субъекту.</target>
        </trans-unit>
        <trans-unit id="2913833b48b2894352d88e1660f11e59aa09d3c6" translate="yes" xml:space="preserve">
          <source>In detail</source>
          <target state="translated">Подробно</target>
        </trans-unit>
        <trans-unit id="9ea333fa04508f8dc9aec394ed0e05cc9396345e" translate="yes" xml:space="preserve">
          <source>In detail, the common comparison type of a list of n types T0...Tn-1 is defined as follows:</source>
          <target state="translated">Подробнее общий тип сравнения списка из n типов T0...Tn-1 определен следующим образом:</target>
        </trans-unit>
        <trans-unit id="0c0bc79ad40602f6280764ba3e86b0386a7085c2" translate="yes" xml:space="preserve">
          <source>In detail:</source>
          <target state="translated">В деталях:</target>
        </trans-unit>
        <trans-unit id="c02c2129e19b776dcabd51f1ec40f2e879325a96" translate="yes" xml:space="preserve">
          <source>In direct-list-initialization (but not in copy-list-initalization), when deducing the meaning of the &lt;a href=&quot;auto&quot;&gt;auto&lt;/a&gt; from a braced-init-list, the braced-init-list must contain only one element, and the type of auto will be the type of that element:</source>
          <target state="translated">При прямой инициализации списка (но не при инициализации копирования списка), при выводе значения &lt;a href=&quot;auto&quot;&gt;auto&lt;/a&gt; из списка braced -init-list, список braced-init-list должен содержать только один элемент, и тип auto будет быть типом этого элемента:</target>
        </trans-unit>
        <trans-unit id="c32c9ac9a30d2bf4ad4aaca0daac65dbd6f4dbc0" translate="yes" xml:space="preserve">
          <source>In each case</source>
          <target state="translated">В каждом случае</target>
        </trans-unit>
        <trans-unit id="8ff5c44b9f8d73aec0aa66262a809a1b948e7c53" translate="yes" xml:space="preserve">
          <source>In each case, the object (or individual elements if &lt;code&gt;T&lt;/code&gt; is an array type)(since C++20) will be destroyed by &lt;code&gt;p-&amp;gt;~X()&lt;/code&gt;, where &lt;code&gt;p&lt;/code&gt; is a pointer to the object and &lt;code&gt;X&lt;/code&gt; is its type.</source>
          <target state="translated">В каждом случае объект (или отдельные элементы, если &lt;code&gt;T&lt;/code&gt; является типом массива) (начиная с C ++ 20) будет уничтожен &lt;code&gt;p-&amp;gt;~X()&lt;/code&gt; , где &lt;code&gt;p&lt;/code&gt; - указатель на объект, а &lt;code&gt;X&lt;/code&gt; - его тип.</target>
        </trans-unit>
        <trans-unit id="a0acff1fbd7c81794afc6d04ed614676c2d1a5ea" translate="yes" xml:space="preserve">
          <source>In each context, the name of an overloaded function may be preceded by address-of operator &lt;code&gt;&amp;amp;&lt;/code&gt; and may be enclosed in a redundant set of parentheses.</source>
          <target state="translated">В каждом контексте имени перегруженной функции может предшествовать оператор address-of &lt;code&gt;&amp;amp;&lt;/code&gt; , и он может быть заключен в избыточный набор скобок.</target>
        </trans-unit>
        <trans-unit id="580d311d2c3830913522a71b0ee0845b37f593cf" translate="yes" xml:space="preserve">
          <source>In either case, &lt;code&gt;std::unexpected&lt;/code&gt; calls the currently installed &lt;code&gt;&lt;a href=&quot;unexpected_handler&quot;&gt;std::unexpected_handler&lt;/a&gt;&lt;/code&gt;. The default &lt;code&gt;&lt;a href=&quot;unexpected_handler&quot;&gt;std::unexpected_handler&lt;/a&gt;&lt;/code&gt; calls &lt;code&gt;&lt;a href=&quot;../terminate&quot;&gt;std::terminate&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">В любом случае, &lt;code&gt;std::unexpected&lt;/code&gt; вызывает установленный в данный момент &lt;code&gt;&lt;a href=&quot;unexpected_handler&quot;&gt;std::unexpected_handler&lt;/a&gt;&lt;/code&gt; . Стандартный &lt;code&gt;&lt;a href=&quot;unexpected_handler&quot;&gt;std::unexpected_handler&lt;/a&gt;&lt;/code&gt; вызывает &lt;code&gt;&lt;a href=&quot;../terminate&quot;&gt;std::terminate&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6513d1fe43b0727e95c4ecbedbc97f1ff6159779" translate="yes" xml:space="preserve">
          <source>In either case, an additional null character value &lt;code&gt;CharT()&lt;/code&gt; is stored at the end of the output. If no characters were extracted, sets &lt;a href=&quot;../ios_base/iostate&quot;&gt;&lt;code&gt;failbit&lt;/code&gt;&lt;/a&gt; (the null character is still written, to the first position in the output). Finally, calls &lt;code&gt;st.width(0)&lt;/code&gt; to cancel the effects of &lt;code&gt;&lt;a href=&quot;../manip/setw&quot;&gt;std::setw&lt;/a&gt;&lt;/code&gt;, if any.  3).</source>
          <target state="translated">В любом случае дополнительное нулевое символьное значение &lt;code&gt;CharT()&lt;/code&gt; сохраняется в конце вывода. Если никакие символы не были извлечены, устанавливает &lt;a href=&quot;../ios_base/iostate&quot;&gt; &lt;code&gt;failbit&lt;/code&gt; &lt;/a&gt; (нулевой символ все еще записан, в первую позицию в выводе). Наконец, вызывает &lt;code&gt;st.width(0)&lt;/code&gt; для отмены эффектов &lt;code&gt;&lt;a href=&quot;../manip/setw&quot;&gt;std::setw&lt;/a&gt;&lt;/code&gt; , если таковые имеются. 3).</target>
        </trans-unit>
        <trans-unit id="8164d479fcc12457fe047a38c7a34d5e26adfd63" translate="yes" xml:space="preserve">
          <source>In either case, no elements are copied or moved, only the internal pointers of the container nodes are repointed (rebalancing may occur, as with &lt;code&gt;&lt;a href=&quot;erase&quot;&gt;erase()&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">В любом случае никакие элементы не копируются или перемещаются, только внутренние указатели узлов контейнера перераспределяются (может произойти перебалансировка, как в случае erase &lt;code&gt;&lt;a href=&quot;erase&quot;&gt;erase()&lt;/a&gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="3eb50cbaf3e01225bd1ecea1bf00b9412ffb6b4a" translate="yes" xml:space="preserve">
          <source>In either case, no elements are copied or moved, only the internal pointers of the container nodes are repointed.</source>
          <target state="translated">В любом случае,никакие элементы не копируются и не перемещаются,перепечатываются только внутренние указатели узлов контейнера.</target>
        </trans-unit>
        <trans-unit id="c657cee6a5de51a9466de54eb7a34b06cf204249" translate="yes" xml:space="preserve">
          <source>In either case, stores the number of characters extracted in the member variable accessed by subsequent calls to &lt;code&gt;&lt;a href=&quot;gcount&quot;&gt;gcount()&lt;/a&gt;&lt;/code&gt;. If &lt;code&gt;sb&lt;/code&gt; is a null pointer or if no characters were inserted into &lt;code&gt;sb&lt;/code&gt;, calls &lt;code&gt;setstate(failbit)&lt;/code&gt; (which may throw &lt;code&gt;&lt;a href=&quot;../ios_base/failure&quot;&gt;std::ios_base::failure&lt;/a&gt;&lt;/code&gt; if enabled).</source>
          <target state="translated">В любом случае хранит количество символов, извлеченных из переменной-члена, к которой обращаются последующие вызовы &lt;code&gt;&lt;a href=&quot;gcount&quot;&gt;gcount()&lt;/a&gt;&lt;/code&gt; . Если &lt;code&gt;sb&lt;/code&gt; является нулевым указателем или если в &lt;code&gt;sb&lt;/code&gt; не было вставлено ни одного символа , вызывается &lt;code&gt;setstate(failbit)&lt;/code&gt; (который может вызвать &lt;code&gt;&lt;a href=&quot;../ios_base/failure&quot;&gt;std::ios_base::failure&lt;/a&gt;&lt;/code&gt; если он включен).</target>
        </trans-unit>
        <trans-unit id="f958e451ccea1b7f622427f43a20430e7db91448" translate="yes" xml:space="preserve">
          <source>In existing implementations, the number of weak pointers is incremented (&lt;a href=&quot;https://stackoverflow.com/questions/43297517/stdshared-ptr-internals-weak-count-more-than-expected&quot;&gt;[1]&lt;/a&gt;, &lt;a href=&quot;https://www.reddit.com/r/cpp/comments/3eia29/stdshared_ptrs_secret_constructor/ctfeh1p&quot;&gt;[2]&lt;/a&gt;) if there is a shared pointer to the same control block.</source>
          <target state="translated">В существующих реализациях количество слабых указателей увеличивается ( &lt;a href=&quot;https://stackoverflow.com/questions/43297517/stdshared-ptr-internals-weak-count-more-than-expected&quot;&gt;[1]&lt;/a&gt; , &lt;a href=&quot;https://www.reddit.com/r/cpp/comments/3eia29/stdshared_ptrs_secret_constructor/ctfeh1p&quot;&gt;[2]&lt;/a&gt; ), если есть общий указатель на тот же блок управления.</target>
        </trans-unit>
        <trans-unit id="1241f4b4a5871614c0b0e937d887dd31b0d585a9" translate="yes" xml:space="preserve">
          <source>In expressions</source>
          <target state="translated">В выражениях</target>
        </trans-unit>
        <trans-unit id="db2370d3e7ba69273bdb62a10e047b42c0843bf1" translate="yes" xml:space="preserve">
          <source>In function-like macros, a &lt;code&gt;#&lt;/code&gt; operator before an identifier in the replacement-list runs the identifier through parameter replacement and encloses the result in quotes, effectively creating a string literal. In addition, the preprocessor adds backslashes to escape the quotes surrounding embedded string literals, if any, and doubles the backslashes within the string as necessary. All leading and trailing whitespace is removed, and any sequence of whitespace in the middle of the text (but not inside embedded string literals) is collapsed to a single space. This operation is called &quot;stringification&quot;. If the result of stringification is not a valid string literal, the behavior is undefined.</source>
          <target state="translated">В функционально-подобных макросах оператор &lt;code&gt;#&lt;/code&gt; перед идентификатором в списке замены выполняет идентификатор посредством замены параметра и заключает результат в кавычки, эффективно создавая строковый литерал. Кроме того, препроцессор добавляет обратную косую черту, чтобы избежать кавычек, окружающих встроенные строковые литералы, если таковые имеются, и удваивает обратную косую черту в строке при необходимости. Все начальные и конечные пробелы удаляются, и любая последовательность пробелов в середине текста (но не внутри встроенных строковых литералов) сворачивается в один пробел. Эта операция называется &amp;laquo;stringification&amp;raquo;. Если результат строкового преобразования не является допустимым строковым литералом, поведение не определено.</target>
        </trans-unit>
        <trans-unit id="1a66e73cddda4a347472a74c2bcb63aabea7fcb6" translate="yes" xml:space="preserve">
          <source>In general, for any trivially copyable type &lt;code&gt;T&lt;/code&gt; and an object &lt;code&gt;obj1&lt;/code&gt; of &lt;code&gt;T&lt;/code&gt;, the underlying bytes of &lt;code&gt;obj1&lt;/code&gt; can be copied (e.g. by means of &lt;code&gt;&lt;a href=&quot;../string/byte/memcpy&quot;&gt;std::memcpy&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../string/byte/memmove&quot;&gt;std::memmove&lt;/a&gt;&lt;/code&gt;) into an array of &lt;code&gt;char&lt;/code&gt;, &lt;code&gt;unsigned char&lt;/code&gt; or &lt;a href=&quot;byte&quot;&gt;&lt;code&gt;std::byte&lt;/code&gt;&lt;/a&gt; or into &lt;code&gt;obj2&lt;/code&gt;, a distinct object of &lt;code&gt;T&lt;/code&gt;. Neither &lt;code&gt;obj1&lt;/code&gt; nor &lt;code&gt;obj2&lt;/code&gt; may be a potentially-overlapping subobject.</source>
          <target state="translated">В общем, для любого тривиально копируемого типа &lt;code&gt;T&lt;/code&gt; и объекта &lt;code&gt;obj1&lt;/code&gt; из &lt;code&gt;T&lt;/code&gt; , основные байты &lt;code&gt;obj1&lt;/code&gt; могут быть скопированы (например, с помощью &lt;code&gt;&lt;a href=&quot;../string/byte/memcpy&quot;&gt;std::memcpy&lt;/a&gt;&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;../string/byte/memmove&quot;&gt;std::memmove&lt;/a&gt;&lt;/code&gt; ) в массив &lt;code&gt;char&lt;/code&gt; , &lt;code&gt;unsigned char&lt;/code&gt; или &lt;a href=&quot;byte&quot;&gt; &lt;code&gt;std::byte&lt;/code&gt; &lt;/a&gt; или в &lt;code&gt;obj2&lt;/code&gt; , отдельный объект &lt;code&gt;T&lt;/code&gt; . Ни &lt;code&gt;obj1&lt;/code&gt; , ни &lt;code&gt;obj2&lt;/code&gt; не могут быть потенциально перекрывающимися подобъектами.</target>
        </trans-unit>
        <trans-unit id="38fcfe4d6a87e17a455c75a9b0e425f272558b3d" translate="yes" xml:space="preserve">
          <source>In general, implicit conversion from one multi-level pointer to another follows the rules described in &lt;a href=&quot;implicit_cast#Qualification_conversions&quot;&gt;qualification conversions&lt;/a&gt; and in &lt;a href=&quot;operator_comparison#Pointer_comparison_operators&quot;&gt;pointer comparison operators&lt;/a&gt;.</source>
          <target state="translated">В общем, неявное преобразование из одного многоуровневого указателя в другой следует правилам, описанным в &lt;a href=&quot;implicit_cast#Qualification_conversions&quot;&gt;квалификационных преобразованиях&lt;/a&gt; и в &lt;a href=&quot;operator_comparison#Pointer_comparison_operators&quot;&gt;операторах сравнения указателей&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="81b4dfcd41b67e7e484427a572743c0af786423b" translate="yes" xml:space="preserve">
          <source>In general, the candidate function whose parameters match the arguments most closely is the one that is called.</source>
          <target state="translated">Как правило,вызывается функция-кандидат,параметры которой наиболее точно соответствуют аргументам.</target>
        </trans-unit>
        <trans-unit id="1c76635c26067171ee4fb88a5e53efe29ca5200a" translate="yes" xml:space="preserve">
          <source>In general, the lifetime of a temporary cannot be further extended by &quot;passing it on&quot;: a second reference, initialized from the reference to which the temporary was bound, does not affect its lifetime.</source>
          <target state="translated">В целом,срок жизни временного лица не может быть продлен путем &quot;передачи его дальше&quot;:вторая ссылка,инициализированная из ссылки,к которой было привязано временное лицо,не влияет на срок его службы.</target>
        </trans-unit>
        <trans-unit id="3b068778e762f7be532eacfc3e630095231dc1ab" translate="yes" xml:space="preserve">
          <source>In generic contexts, the destructor call syntax can be used with an object of non-class type; this is known as pseudo-destructor call: see &lt;a href=&quot;operator_member_access#Built-in_member_access_operators&quot;&gt;member access operator&lt;/a&gt;.</source>
          <target state="translated">В общем контексте синтаксис вызова деструктора может использоваться с объектом неклассового типа; это называется псевдодеструкторным вызовом: см. &lt;a href=&quot;operator_member_access#Built-in_member_access_operators&quot;&gt;оператор доступа к элементу&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0e96e30536ed7d7370721a29eb0a3baf8e9861d0" translate="yes" xml:space="preserve">
          <source>In locales other than &lt;code&gt;&quot;C&quot;&lt;/code&gt;, an alphabetic character is a character for which &lt;code&gt;std::isupper()&lt;/code&gt; or &lt;code&gt;std::islower()&lt;/code&gt; returns non-zero or any other character considered alphabetic by the locale. In any case, &lt;code&gt;std::iscntrl()&lt;/code&gt;, &lt;code&gt;std::isdigit()&lt;/code&gt;, &lt;code&gt;std::ispunct()&lt;/code&gt; and &lt;code&gt;std::isspace()&lt;/code&gt; will return zero for this character.</source>
          <target state="translated">В локалях, отличных от &lt;code&gt;&quot;C&quot;&lt;/code&gt; , буквенный символ - это символ, для которого &lt;code&gt;std::isupper()&lt;/code&gt; или &lt;code&gt;std::islower()&lt;/code&gt; возвращает ненулевой или любой другой символ, который в алфавите считается алфавитным. В любом случае &lt;code&gt;std::iscntrl()&lt;/code&gt; , &lt;code&gt;std::isdigit()&lt;/code&gt; , &lt;code&gt;std::ispunct()&lt;/code&gt; и &lt;code&gt;std::isspace()&lt;/code&gt; вернут ноль для этого символа.</target>
        </trans-unit>
        <trans-unit id="2c7ad051625c76a00388473f47c41ae5d264a453" translate="yes" xml:space="preserve">
          <source>In many implementations, &lt;code&gt;is_nothrow_constructible&lt;/code&gt; also checks if the destructor throws because it is effectively &lt;code&gt;noexcept(T(arg))&lt;/code&gt;. Same applies to &lt;code&gt;is_trivially_constructible&lt;/code&gt;, which, in these implementations, also requires that the destructor is trivial: &lt;a href=&quot;https://gcc.gnu.org/bugzilla/show_bug.cgi?id=51452&quot;&gt;GCC bug 51452&lt;/a&gt;&lt;a href=&quot;http://cplusplus.github.io/LWG/lwg-active.html#2116&quot;&gt;LWG issue 2116&lt;/a&gt;.</source>
          <target state="translated">Во многих реализациях &lt;code&gt;is_nothrow_constructible&lt;/code&gt; также проверяет, выбрасывает ли деструктор, потому что он фактически &lt;code&gt;noexcept(T(arg))&lt;/code&gt; . То же самое относится к &lt;code&gt;is_trivially_constructible&lt;/code&gt; , который в этих реализациях также требует, чтобы деструктор был тривиальным: &lt;a href=&quot;https://gcc.gnu.org/bugzilla/show_bug.cgi?id=51452&quot;&gt;ошибка GCC 51452 LWG &lt;/a&gt;&lt;a href=&quot;http://cplusplus.github.io/LWG/lwg-active.html#2116&quot;&gt;выпуск 2116&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="33323ec4f069d0c0b878342b0a8185699b19819e" translate="yes" xml:space="preserve">
          <source>In many implementations, &lt;code&gt;is_nothrow_copy_constructible&lt;/code&gt; also checks if the destructor throws because it is effectively &lt;code&gt;noexcept(T(arg))&lt;/code&gt;. Same applies to &lt;code&gt;is_trivially_copy_constructible&lt;/code&gt;, which, in these implementations, also requires that the destructor is trivial: &lt;a href=&quot;https://gcc.gnu.org/bugzilla/show_bug.cgi?id=51452&quot;&gt;GCC bug 51452&lt;/a&gt;&lt;a href=&quot;http://cplusplus.github.io/LWG/lwg-active.html#2116&quot;&gt;LWG issue 2116&lt;/a&gt;.</source>
          <target state="translated">Во многих реализациях &lt;code&gt;is_nothrow_copy_constructible&lt;/code&gt; также проверяет, выбрасывает ли деструктор, потому что он фактически &lt;code&gt;noexcept(T(arg))&lt;/code&gt; . То же относится и к &lt;code&gt;is_trivially_copy_constructible&lt;/code&gt; , который в этих реализациях также требует, чтобы деструктор был тривиальным: &lt;a href=&quot;https://gcc.gnu.org/bugzilla/show_bug.cgi?id=51452&quot;&gt;ошибка GCC 51452 LWG &lt;/a&gt;&lt;a href=&quot;http://cplusplus.github.io/LWG/lwg-active.html#2116&quot;&gt;выпуск 2116&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="accf831c87b14d37d2cc6eafd0090b844f5f9b51" translate="yes" xml:space="preserve">
          <source>In many implementations, &lt;code&gt;is_nothrow_default_constructible&lt;/code&gt; also checks if the destructor throws because it is effectively &lt;code&gt;noexcept(T())&lt;/code&gt;. Same applies to &lt;code&gt;is_trivially_default_constructible&lt;/code&gt;, which, in these implementations, also requires that the destructor is trivial: &lt;a href=&quot;https://gcc.gnu.org/bugzilla/show_bug.cgi?id=51452&quot;&gt;GCC bug 51452&lt;/a&gt;&lt;a href=&quot;http://cplusplus.github.io/LWG/lwg-active.html#2116&quot;&gt;LWG issue 2116&lt;/a&gt;.</source>
          <target state="translated">Во многих реализациях &lt;code&gt;is_nothrow_default_constructible&lt;/code&gt; также проверяет, выбрасывает ли деструктор, потому что он фактически не &lt;code&gt;noexcept(T())&lt;/code&gt; . То же относится и к &lt;code&gt;is_trivially_default_constructible&lt;/code&gt; , который в этих реализациях также требует, чтобы деструктор был тривиальным: &lt;a href=&quot;https://gcc.gnu.org/bugzilla/show_bug.cgi?id=51452&quot;&gt;ошибка GCC 51452 LWG &lt;/a&gt;&lt;a href=&quot;http://cplusplus.github.io/LWG/lwg-active.html#2116&quot;&gt;выпуск 2116&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5d90dd0a15587a98cbedbb69df63e111504c94d0" translate="yes" xml:space="preserve">
          <source>In many implementations, &lt;code&gt;is_nothrow_move_constructible&lt;/code&gt; also checks if the destructor throws because it is effectively &lt;code&gt;noexcept(T(arg))&lt;/code&gt;. Same applies to &lt;code&gt;is_trivially_move_constructible&lt;/code&gt;, which, in these implementations, also requires that the destructor is trivial: &lt;a href=&quot;https://gcc.gnu.org/bugzilla/show_bug.cgi?id=51452&quot;&gt;GCC bug 51452&lt;/a&gt;&lt;a href=&quot;http://cplusplus.github.io/LWG/lwg-active.html#2116&quot;&gt;LWG issue 2116&lt;/a&gt;.</source>
          <target state="translated">Во многих реализациях &lt;code&gt;is_nothrow_move_constructible&lt;/code&gt; также проверяет, выбрасывает ли деструктор, потому что он фактически &lt;code&gt;noexcept(T(arg))&lt;/code&gt; . То же самое относится к &lt;code&gt;is_trivially_move_constructible&lt;/code&gt; , который в этих реализациях также требует, чтобы деструктор был тривиальным: &lt;a href=&quot;https://gcc.gnu.org/bugzilla/show_bug.cgi?id=51452&quot;&gt;ошибка GCC 51452 LWG &lt;/a&gt;&lt;a href=&quot;http://cplusplus.github.io/LWG/lwg-active.html#2116&quot;&gt;выпуск 2116&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4f61cbb399593cd96a01d7c1e70f3b86ca51dd80" translate="yes" xml:space="preserve">
          <source>In many implementations, standard output is line-buffered, and writing &lt;code&gt;'\n'&lt;/code&gt; causes a flush anyway, unless &lt;code&gt;std::ios::sync_with_stdio(false)&lt;/code&gt; was executed. In those situations, unnecessary &lt;code&gt;endl&lt;/code&gt; only degrades the performance of file output, not standard output.</source>
          <target state="translated">Во многих реализациях стандартный вывод буферизуется строкой, и запись &lt;code&gt;'\n'&lt;/code&gt; в любом случае вызывает сброс, если только не был выполнен &lt;code&gt;std::ios::sync_with_stdio(false)&lt;/code&gt; . В этих ситуациях ненужный &lt;code&gt;endl&lt;/code&gt; только ухудшает производительность вывода файла, а не стандартный вывод.</target>
        </trans-unit>
        <trans-unit id="b5cc9d63c613364dc5793e8e7ac9b68a692864f4" translate="yes" xml:space="preserve">
          <source>In many situations, copy constructors are optimized out even if they would produce observable side-effects, see &lt;a href=&quot;copy_elision&quot;&gt;copy elision&lt;/a&gt;.</source>
          <target state="translated">Во многих ситуациях конструкторы копирования оптимизируются, даже если они будут вызывать наблюдаемые побочные эффекты, см. &lt;a href=&quot;copy_elision&quot;&gt;Раздел &amp;laquo;Разрешение копирования&amp;raquo;&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="361bbab390512b139df616a956291652c3a5e8eb" translate="yes" xml:space="preserve">
          <source>In most implementations, this function updates a global static object of type &lt;code&gt;&lt;a href=&quot;mbstate_t&quot;&gt;std::mbstate_t&lt;/a&gt;&lt;/code&gt; as it processes through the string, and cannot be called simultaneously by two threads, &lt;code&gt;&lt;a href=&quot;mbsrtowcs&quot;&gt;std::mbsrtowcs&lt;/a&gt;&lt;/code&gt; should be used in such cases.</source>
          <target state="translated">В большинстве реализаций эта функция обновляет глобальный статический объект типа &lt;code&gt;&lt;a href=&quot;mbstate_t&quot;&gt;std::mbstate_t&lt;/a&gt;&lt;/code&gt; при обработке через строку и не может вызываться одновременно двумя потоками, в таких случаях следует использовать &lt;code&gt;&lt;a href=&quot;mbsrtowcs&quot;&gt;std::mbsrtowcs&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="49690d1d0c037eea359d8320b2de46145cef5181" translate="yes" xml:space="preserve">
          <source>In most implementations, this function updates a global static object of type &lt;code&gt;&lt;a href=&quot;mbstate_t&quot;&gt;std::mbstate_t&lt;/a&gt;&lt;/code&gt; as it processes through the string, and cannot be called simultaneously by two threads, &lt;code&gt;&lt;a href=&quot;wcsrtombs&quot;&gt;std::wcsrtombs&lt;/a&gt;&lt;/code&gt; should be used in such cases.</source>
          <target state="translated">В большинстве реализаций эта функция обновляет глобальный статический объект типа &lt;code&gt;&lt;a href=&quot;mbstate_t&quot;&gt;std::mbstate_t&lt;/a&gt;&lt;/code&gt; при обработке через строку и не может вызываться одновременно двумя потоками, в таких случаях следует использовать &lt;code&gt;&lt;a href=&quot;wcsrtombs&quot;&gt;std::wcsrtombs&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="88d76a48f8f96c35da8c08d45a4e62de40b811d7" translate="yes" xml:space="preserve">
          <source>In most implementations, this returns &lt;code&gt;&lt;a href=&quot;../../types/numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;size_type&amp;gt;::max() / sizeof(value_type)&lt;/code&gt;.</source>
          <target state="translated">В большинстве реализаций это возвращает &lt;code&gt;&lt;a href=&quot;../../types/numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;size_type&amp;gt;::max() / sizeof(value_type)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9dfeb8ee21790e4ab7902716cd854784402ed77a" translate="yes" xml:space="preserve">
          <source>In multithreaded environment, the value returned by use_count is approximate (typical implementations use a &lt;a href=&quot;../../atomic/memory_order&quot;&gt;memory_order_relaxed&lt;/a&gt; load).</source>
          <target state="translated">В многопоточной среде значение, возвращаемое значением use_count, является приблизительным (в типичных реализациях используется загрузка &lt;a href=&quot;../../atomic/memory_order&quot;&gt;memory_order_relaxed&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="b0b00c8c047435001bd2de135f45ca01beaae4c1" translate="yes" xml:space="preserve">
          <source>In namespace and block scope</source>
          <target state="translated">В пространстве имён и блочном пространстве</target>
        </trans-unit>
        <trans-unit id="20891e1e3bb66c9419f1d516300d8501998694a6" translate="yes" xml:space="preserve">
          <source>In old or nonconforming compilers, using the &lt;a href=&quot;../language/operator_alternative&quot;&gt;alternative operator representations&lt;/a&gt; may still require including this header.</source>
          <target state="translated">В старых или несоответствующих компиляторах использование &lt;a href=&quot;../language/operator_alternative&quot;&gt;альтернативных представлений операторов&lt;/a&gt; может все еще требовать включения этого заголовка.</target>
        </trans-unit>
        <trans-unit id="976a60901e43304c76c9540f3f429a8d9f4c6a87" translate="yes" xml:space="preserve">
          <source>In order for a template to be instantiated, every template parameter (type, non-type, or template) must be replaced by a corresponding template argument. For &lt;a href=&quot;class_template&quot;&gt;class templates&lt;/a&gt;, the arguments are either explicitly provided, &lt;a href=&quot;deduction_guide&quot;&gt;deduced from the initializer&lt;/a&gt;, (since C++17) or defaulted. For &lt;a href=&quot;function_template&quot;&gt;function templates&lt;/a&gt;, the arguments are explicitly provided, &lt;a href=&quot;template_argument_deduction&quot;&gt;deduced from the context&lt;/a&gt;, or defaulted.</source>
          <target state="translated">Чтобы создать экземпляр шаблона, каждый параметр шаблона (тип, нетип или шаблон) должен быть заменен соответствующим аргументом шаблона. Для &lt;a href=&quot;class_template&quot;&gt;шаблонов классов&lt;/a&gt; аргументы либо предоставляются явно, либо &lt;a href=&quot;deduction_guide&quot;&gt;выводятся из инициализатора&lt;/a&gt; (начиная с C ++ 17), либо по умолчанию. Для &lt;a href=&quot;function_template&quot;&gt;шаблонов функций&lt;/a&gt; аргументы предоставляются явно, &lt;a href=&quot;template_argument_deduction&quot;&gt;выводятся из контекста&lt;/a&gt; или по умолчанию.</target>
        </trans-unit>
        <trans-unit id="2d740db339a5645df895be9040440821225a705c" translate="yes" xml:space="preserve">
          <source>In order for an exception to be caught, the throw-expression has to be inside a &lt;a href=&quot;try_catch&quot;&gt;try-block&lt;/a&gt; or inside a function called from a try-block, and there has to be a &lt;a href=&quot;try_catch&quot;&gt;catch clause&lt;/a&gt; that matches the type of the exception object.</source>
          <target state="translated">Чтобы исключение было перехвачено, выражение throw должно быть внутри &lt;a href=&quot;try_catch&quot;&gt;блока try&lt;/a&gt; или внутри функции, вызываемой из блока try, и должно быть предложение &lt;a href=&quot;try_catch&quot;&gt;catch&lt;/a&gt; , соответствующее типу объекта исключения.</target>
        </trans-unit>
        <trans-unit id="b7a11d6633f27612217d043955d8513b0eaf805c" translate="yes" xml:space="preserve">
          <source>In order to compile a function call, the compiler must first perform &lt;a href=&quot;lookup&quot;&gt;name lookup&lt;/a&gt;, which, for functions, may involve &lt;a href=&quot;adl&quot;&gt;argument-dependent lookup&lt;/a&gt;, and for function templates may be followed by &lt;a href=&quot;template_argument_deduction&quot;&gt;template argument deduction&lt;/a&gt;. If these steps produce more than one</source>
          <target state="translated">Чтобы скомпилировать вызов функции, компилятор должен сначала выполнить &lt;a href=&quot;lookup&quot;&gt;поиск имени&lt;/a&gt; , который для функций может включать в себя &lt;a href=&quot;adl&quot;&gt;поиск&lt;/a&gt; , зависящий от аргумента , а для шаблонов функций может следовать &lt;a href=&quot;template_argument_deduction&quot;&gt;вывод аргумента шаблона&lt;/a&gt; . Если эти шаги производят более одного</target>
        </trans-unit>
        <trans-unit id="c439dee89b66538a41331ba7addd781be9e95710" translate="yes" xml:space="preserve">
          <source>In order to examine all matches within the target sequence, &lt;code&gt;std::regex_search&lt;/code&gt; may be called in a loop, restarting each time from &lt;code&gt;m[0].second&lt;/code&gt; of the previous call. &lt;code&gt;&lt;a href=&quot;regex_iterator&quot;&gt;std::regex_iterator&lt;/a&gt;&lt;/code&gt; offers an easy interface to this iteration.</source>
          <target state="translated">Чтобы проверить все совпадения в целевой последовательности, &lt;code&gt;std::regex_search&lt;/code&gt; может быть вызван в цикле, перезапускающемся каждый раз с &lt;code&gt;m[0].second&lt;/code&gt; предыдущего вызова. &lt;code&gt;&lt;a href=&quot;regex_iterator&quot;&gt;std::regex_iterator&lt;/a&gt;&lt;/code&gt; предлагает простой интерфейс для этой итерации.</target>
        </trans-unit>
        <trans-unit id="93e5fcbc9e67b4e1b987a567473422ebf0dee92c" translate="yes" xml:space="preserve">
          <source>In order to instantiate a &lt;a href=&quot;class_template&quot;&gt;class template&lt;/a&gt;, every template argument must be known, but not every template argument has to be specified. In the following contexts the compiler will deduce the missing template arguments from the type of the initializer:</source>
          <target state="translated">Чтобы создать экземпляр &lt;a href=&quot;class_template&quot;&gt;шаблона класса&lt;/a&gt; , каждый аргумент шаблона должен быть известен, но не каждый аргумент шаблона должен быть указан. В следующих контекстах компилятор выведет отсутствующие аргументы шаблона из типа инициализатора:</target>
        </trans-unit>
        <trans-unit id="9bf61b9c2f6c8ed792b21ac9dd2327e234ccbf15" translate="yes" xml:space="preserve">
          <source>In order to instantiate a &lt;a href=&quot;function_template&quot;&gt;function template&lt;/a&gt;, every template argument must be known, but not every template argument has to be specified. When possible, the compiler will deduce the missing template arguments from the function arguments. This occurs when a function call is attempted, when an address of a function template is taken, and in some &lt;a href=&quot;template_argument_deduction#Other_contexts&quot;&gt;other contexts&lt;/a&gt;:</source>
          <target state="translated">Чтобы создать экземпляр &lt;a href=&quot;function_template&quot;&gt;шаблона функции&lt;/a&gt; , каждый аргумент шаблона должен быть известен, но не каждый аргумент шаблона должен быть указан. Когда это возможно, компилятор выводит отсутствующие аргументы шаблона из аргументов функции. Это происходит при попытке вызова функции, при получении адреса шаблона функции и в некоторых &lt;a href=&quot;template_argument_deduction#Other_contexts&quot;&gt;других контекстах&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="8076ca3c217ff4a7a98ccc16264bf0332155e2a1" translate="yes" xml:space="preserve">
          <source>In order to instantiate a &lt;strong&gt;function template&lt;/strong&gt;, every template argument must be known, but not every template argument has to be specified. When possible, the compiler will deduce the missing template arguments from the function arguments. This occurs when a function call is attempted and when an address of a function template is taken.</source>
          <target state="translated">Чтобы создать экземпляр &lt;strong&gt;шаблона функции&lt;/strong&gt; , каждый аргумент шаблона должен быть известен, но не каждый аргумент шаблона должен быть указан. Когда это возможно, компилятор выводит отсутствующие аргументы шаблона из аргументов функции. Это происходит при попытке вызова функции и при получении адреса шаблона функции.</target>
        </trans-unit>
        <trans-unit id="ed244da1aecd793a261081beab12c67de2da00bb" translate="yes" xml:space="preserve">
          <source>In order to satisfy alignment requirements of all non-static members of a &lt;a href=&quot;class&quot;&gt;class&lt;/a&gt;,</source>
          <target state="translated">Чтобы удовлетворить требования выравнивания всех нестатических членов &lt;a href=&quot;class&quot;&gt;класса&lt;/a&gt; ,</target>
        </trans-unit>
        <trans-unit id="2dce1c16904fec9d3889052abdb4ab00a4c0f330" translate="yes" xml:space="preserve">
          <source>In order to satisfy the requirements of array-oriented access, an implementation is constrained to store the real and imaginary components of a &lt;code&gt;std::complex&lt;/code&gt; specialization in separate and adjacent memory locations. Possible declarations for its non-static data members include:</source>
          <target state="translated">Чтобы удовлетворить требования ориентированного на массив доступа, реализация ограничена хранением действительных и мнимых компонентов специализации &lt;code&gt;std::complex&lt;/code&gt; в отдельных и смежных областях памяти. Возможные объявления для его нестатических элементов данных включают в себя:</target>
        </trans-unit>
        <trans-unit id="d223a004acbe8c2ee4258ddff41fb5bd9c563a88" translate="yes" xml:space="preserve">
          <source>In order to wait in a shared mutex in shared ownership mode, &lt;code&gt;&lt;a href=&quot;condition_variable_any&quot;&gt;std::condition_variable_any&lt;/a&gt;&lt;/code&gt; can be used (&lt;code&gt;&lt;a href=&quot;condition_variable&quot;&gt;std::condition_variable&lt;/a&gt;&lt;/code&gt; requires &lt;code&gt;&lt;a href=&quot;unique_lock&quot;&gt;std::unique_lock&lt;/a&gt;&lt;/code&gt; and so can only wait in unique ownership mode).</source>
          <target state="translated">Для того , чтобы ждать в общем мьютексе в режиме совместной собственности, &lt;code&gt;&lt;a href=&quot;condition_variable_any&quot;&gt;std::condition_variable_any&lt;/a&gt;&lt;/code&gt; можно использовать ( &lt;code&gt;&lt;a href=&quot;condition_variable&quot;&gt;std::condition_variable&lt;/a&gt;&lt;/code&gt; требует &lt;code&gt;&lt;a href=&quot;unique_lock&quot;&gt;std::unique_lock&lt;/a&gt;&lt;/code&gt; и так можно ждать только в уникальном режиме собственности).</target>
        </trans-unit>
        <trans-unit id="a0570d7fb641b108923426180a7da145cd589a42" translate="yes" xml:space="preserve">
          <source>In other words, &lt;code&gt;std::bind_front(f, bound_args...)(call_args...)&lt;/code&gt; is equivalent to &lt;code&gt;&lt;a href=&quot;invoke&quot;&gt;std::invoke&lt;/a&gt;(f, bound_args..., call_args....)&lt;/code&gt;.</source>
          <target state="translated">Другими словами, &lt;code&gt;std::bind_front(f, bound_args...)(call_args...)&lt;/code&gt; эквивалентен &lt;code&gt;&lt;a href=&quot;invoke&quot;&gt;std::invoke&lt;/a&gt;(f, bound_args..., call_args....)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b9c4cf6f1de09d5243e6d12c4b6e447d38d42628" translate="yes" xml:space="preserve">
          <source>In other words, after replacing the type (e.g. an iterator type) in a well-formed non-aggregate initialization with &lt;code&gt;dangling&lt;/code&gt;, the resulting initialization is also well-formed.</source>
          <target state="translated">Другими словами, после замены типа (например, типа итератора) в правильно сформированной неагрегированной инициализации &lt;code&gt;dangling&lt;/code&gt; , результирующая инициализация также будет правильно сформирована.</target>
        </trans-unit>
        <trans-unit id="2fdcde52c9613f8d9965c24cc761c64f7f29bbf9" translate="yes" xml:space="preserve">
          <source>In other words, if an algorithm takes a Predicate &lt;code&gt;pred&lt;/code&gt; and an iterator &lt;code&gt;first&lt;/code&gt;, it should be able to test the object of the type pointed to by the iterator &lt;code&gt;first&lt;/code&gt; using the given predicate via a construct like &lt;code&gt;if(pred(*first)) {...}&lt;/code&gt;.</source>
          <target state="translated">Другими словами, если алгоритм принимает предикат &lt;code&gt;pred&lt;/code&gt; и итератора &lt;code&gt;first&lt;/code&gt; , он должен быть в состоянии проверить объект типа , на который указывает итератора &lt;code&gt;first&lt;/code&gt; использованием данного предиката с помощью конструкции , как &lt;code&gt;if(pred(*first)) {...}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="491de468bd659078aefdfec90cf19da2bcde4cae" translate="yes" xml:space="preserve">
          <source>In other words, the conversion to the common reference type must preserve equality.</source>
          <target state="translated">Другими словами,преобразование в общий тип ссылки должно сохранить равенство.</target>
        </trans-unit>
        <trans-unit id="1515a939c60d7a0551eb77267cda9623a3ec082e" translate="yes" xml:space="preserve">
          <source>In other words, the conversion to the common type must preserve equality.</source>
          <target state="translated">Другими словами,переход на общий тип должен сохранить равенство.</target>
        </trans-unit>
        <trans-unit id="e7bf915fd2c7af366ac00ae6abbc509a778d1910" translate="yes" xml:space="preserve">
          <source>In other words, the summation operations may be performed in arbitrary order, and the behavior is nondeterministic if &lt;code&gt;binary_op&lt;/code&gt; is not associative.</source>
          <target state="translated">Другими словами, операции суммирования могут выполняться в произвольном порядке, и поведение является недетерминированным, если &lt;code&gt;binary_op&lt;/code&gt; не является ассоциативным.</target>
        </trans-unit>
        <trans-unit id="a80c785731fa7946b71b60f0a1b2f2901be26657" translate="yes" xml:space="preserve">
          <source>In overload (1), if &lt;code&gt;T&lt;/code&gt;'s move constructor is not &lt;code&gt;noexcept&lt;/code&gt; and T is not &lt;a href=&quot;../../named_req/copyinsertable&quot;&gt;CopyInsertable&lt;/a&gt; into &lt;code&gt;*this&lt;/code&gt;, vector will use the throwing move constructor. If it throws, the guarantee is waived and the effects are unspecified.</source>
          <target state="translated">В перегрузках (1), если &lt;code&gt;T&lt;/code&gt; ход Конструктор &amp;laquo;ы не &lt;code&gt;noexcept&lt;/code&gt; и Т не &lt;a href=&quot;../../named_req/copyinsertable&quot;&gt;CopyInsertable&lt;/a&gt; в &lt;code&gt;*this&lt;/code&gt; вектор будет использовать конструктор метательного перемещения. Если он выбрасывает, гарантия отменяется, а последствия не уточняются.</target>
        </trans-unit>
        <trans-unit id="da0255ac708e972224b54cc46137f223d8fcb17c" translate="yes" xml:space="preserve">
          <source>In particular, &lt;code&gt;std::move&lt;/code&gt; produces an &lt;a href=&quot;../language/value_category&quot;&gt;xvalue expression&lt;/a&gt; that identifies its argument &lt;code&gt;t&lt;/code&gt;. It is exactly equivalent to a static_cast to an rvalue reference type.</source>
          <target state="translated">В частности, &lt;code&gt;std::move&lt;/code&gt; создает &lt;a href=&quot;../language/value_category&quot;&gt;выражение xvalue,&lt;/a&gt; которое идентифицирует его аргумент &lt;code&gt;t&lt;/code&gt; . Это в точности эквивалентно static_cast для ссылочного типа rvalue.</target>
        </trans-unit>
        <trans-unit id="bc5f562f16c7f3516fd8ac3ab2d0a32811211b88" translate="yes" xml:space="preserve">
          <source>In particular, all hard links for the same file or directory are equivalent, and a symlink and its target on the same file system are equivalent.</source>
          <target state="translated">В частности,все жесткие ссылки для одного и того же файла или каталога эквивалентны,а сим-ссылка и ее цель в одной и той же файловой системе эквивалентны.</target>
        </trans-unit>
        <trans-unit id="6c9eea59b15650f810d84d6038841dd320cdfa3e" translate="yes" xml:space="preserve">
          <source>In particular, for negative_sign of &lt;code&gt;&quot;-&quot;&lt;/code&gt;, the formatting may appear as &lt;code&gt;&quot;-1.23 &amp;euro;&quot;&lt;/code&gt;, while for negative_sign of &lt;code&gt;&quot;()&quot;&lt;/code&gt; it would appear as &lt;code&gt;&quot;(1.23 &amp;euro;)&quot;&lt;/code&gt;.</source>
          <target state="translated">В частности, для negative_sign из &lt;code&gt;&quot;-&quot;&lt;/code&gt; , форматирование может выглядеть как &lt;code&gt;&quot;-1.23 &amp;euro;&quot;&lt;/code&gt; , в то время как для negative_sign из &lt;code&gt;&quot;()&quot;&lt;/code&gt; это будет выглядеть как &lt;code&gt;&quot;(1.23 &amp;euro;)&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e9805358780c9313bdf8b46c3d77f45f54ffa9c0" translate="yes" xml:space="preserve">
          <source>In particular, like all rvalues, xvalues bind to rvalue references, and like all glvalues, xvalues may be &lt;a href=&quot;objects#Polymorphic_objects&quot;&gt;polymorphic&lt;/a&gt;, and non-class xvalues may be &lt;a href=&quot;cv&quot;&gt;cv-qualified&lt;/a&gt;.</source>
          <target state="translated">В частности, как и все значения rvalue, значения xvalue привязываются к ссылкам rvalue, и, как и все значения glvalue, значения xvalue могут быть &lt;a href=&quot;objects#Polymorphic_objects&quot;&gt;полиморфными&lt;/a&gt; , а значения xvalue , не относящиеся к классу, могут быть &lt;a href=&quot;cv&quot;&gt;cv-квалифицированными&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3440815d0cff772e37f45dd6a4e47c1dc0bf363e" translate="yes" xml:space="preserve">
          <source>In particular, non-copyable arguments and array to pointer conversion.</source>
          <target state="translated">В частности,не копируемые аргументы и преобразование массива в указатель.</target>
        </trans-unit>
        <trans-unit id="25d069cd55a0e3cbff6493480ec850fae36c0fdc" translate="yes" xml:space="preserve">
          <source>In particular, this implies that string literals, addresses of array elements, and addresses of non-static members cannot be used as template arguments to instantiate templates whose corresponding non-type template parameters are pointers to objects.</source>
          <target state="translated">В частности,это означает,что строковые литералы,адреса элементов массива и адреса нестатических членов не могут быть использованы в качестве аргументов шаблона для инстанцирования шаблонов,соответствующими нетипными параметрами которых являются указатели на объекты.</target>
        </trans-unit>
        <trans-unit id="16b8d6ec9c39d406c45bf8c3a95070cf38451515" translate="yes" xml:space="preserve">
          <source>In particular, this implies that the failures of constructors (see also &lt;a href=&quot;raii&quot;&gt;RAII&lt;/a&gt;) and most operators should be reported by throwing exceptions.</source>
          <target state="translated">В частности, это подразумевает, что о сбоях конструкторов (см. Также &lt;a href=&quot;raii&quot;&gt;RAII&lt;/a&gt; ) и большинства операторов следует сообщать, создавая исключения.</target>
        </trans-unit>
        <trans-unit id="6bd64e741fcbffe364b20bed2e39dc776e83f8c6" translate="yes" xml:space="preserve">
          <source>In particular, this implies that.</source>
          <target state="translated">В частности,это подразумевает.</target>
        </trans-unit>
        <trans-unit id="7778e57383bfe144db5dc5276001e50344a7eb81" translate="yes" xml:space="preserve">
          <source>In practice, constant initialization is performed at compile time, and pre-calculated object representations are stored as part of the program image (e.g. in the &lt;code&gt;.data&lt;/code&gt; section). If a variable is both &lt;code&gt;const&lt;/code&gt; and constant-initialized, its object representation may be stored in a read-only section of the program image (e.g. the &lt;code&gt;.rodata&lt;/code&gt; section).</source>
          <target state="translated">На практике постоянная инициализация выполняется во время компиляции, а предварительно рассчитанные представления объектов сохраняются как часть образа программы (например, в разделе &lt;code&gt;.data&lt;/code&gt; ). Если переменная является и &lt;code&gt;const&lt;/code&gt; , и инициализированной константой, ее объектное представление может быть сохранено в секции только для чтения образа программы (например, секция &lt;code&gt;.rodata&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="c5f7e6132c24b431ab05a1b29a68ed1255266ac7" translate="yes" xml:space="preserve">
          <source>In practice, implementations of &lt;code&gt;std::copy&lt;/code&gt; avoid multiple assignments and use bulk copy functions such as &lt;code&gt;&lt;a href=&quot;../string/byte/memmove&quot;&gt;std::memmove&lt;/a&gt;&lt;/code&gt; if the value type is &lt;a href=&quot;../named_req/triviallycopyable&quot;&gt;TriviallyCopyable&lt;/a&gt;.</source>
          <target state="translated">На практике реализации &lt;code&gt;std::copy&lt;/code&gt; избегают множественных присваиваний и используют функции массового копирования, такие как &lt;code&gt;&lt;a href=&quot;../string/byte/memmove&quot;&gt;std::memmove&lt;/a&gt;&lt;/code&gt; если типом значения является &lt;a href=&quot;../named_req/triviallycopyable&quot;&gt;TriviallyCopyable&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4166dd075003042b54540673bbf26b17c11851e9" translate="yes" xml:space="preserve">
          <source>In practice, they may be implemented as function objects, or with special compiler extensions.</source>
          <target state="translated">На практике они могут быть реализованы в виде объектов функций или со специальными расширениями компилятора.</target>
        </trans-unit>
        <trans-unit id="66affe68d971b057413c1675fbe61348d2fbb2ee" translate="yes" xml:space="preserve">
          <source>In practice, this means that the synchronized C++ streams are unbuffered, and each I/O operation on a C++ stream is immediately applied to the corresponding C stream's buffer. This makes it possible to freely mix C++ and C I/O.</source>
          <target state="translated">На практике это означает,что синхронизированные С++потоки не буферизируются,и каждая операция ввода/вывода над С++потоком немедленно применяется к соответствующему буферу С-потока.Это позволяет свободно смешивать C++и C ввода/вывода.</target>
        </trans-unit>
        <trans-unit id="a9d5344404c3cda159f179c91a199091db72dee1" translate="yes" xml:space="preserve">
          <source>In simple cases, both pImpl and factory method break compile-time dependency between the implementation and the users of the class interface. Factory method creates a hidden dependency on the vtable, and so reordering, adding, or removing virtual member functions breaks the ABI. The pImpl approach has no hidden dependencies, however if the implementation class is a class template specialization, the compilation firewall benefit is lost: the users of the interface must observe the entire template definition in order to instantiate the correct specialization. A common design approach in this case is to refactor the implementation in a way that avoids parametrization, this is another use case for the C++ Core Guidelines &lt;a href=&quot;https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#Rt-scary&quot;&gt;T.61 Do not over-parametrize members&lt;/a&gt; and &lt;a href=&quot;https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#t84-use-a-non-template-core-implementation-to-provide-an-abi-stable-interface&quot;&gt;T.84 Use a non-template core implementation to provide an ABI-stable interface&lt;/a&gt;.</source>
          <target state="translated">В простых случаях и метод pImpl, и метод фабрики нарушают зависимость во время компиляции между реализацией и пользователями интерфейса класса. Фабричный метод создает скрытую зависимость от vtable, поэтому изменение порядка, добавление или удаление виртуальных функций-членов нарушает ABI. Подход pImpl не имеет скрытых зависимостей, однако, если класс реализации является специализацией шаблона класса, преимущество межсетевого экрана компиляции теряется: пользователи интерфейса должны соблюдать полное определение шаблона, чтобы создать правильную специализацию. Обычный подход к проектированию в этом случае заключается в рефакторинге реализации таким образом, чтобы избежать параметризации, это еще один вариант использования для основных принципов C ++ &lt;a href=&quot;https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#Rt-scary&quot;&gt;T.61. Не переопределяйте параметры членов&lt;/a&gt; и&lt;a href=&quot;https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#t84-use-a-non-template-core-implementation-to-provide-an-abi-stable-interface&quot;&gt;T.84 Использовать не шаблонную базовую реализацию для обеспечения ABI-стабильного интерфейса&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e257383e8a791be56a7795dcfa164d94b6cff0ea" translate="yes" xml:space="preserve">
          <source>In some contexts, only type names can validly appear. In these contexts, a dependent qualified name is assumed to name a type and no &lt;code&gt;typename&lt;/code&gt; is required:</source>
          <target state="translated">В некоторых контекстах только имена типов могут отображаться корректно. В этих условиях, зависимое квалифицированное имя предполагается назвать тип и не &lt;code&gt;typename&lt;/code&gt; не требуется:</target>
        </trans-unit>
        <trans-unit id="b4f0ab4a86013d411969196467703372e7da8ad4" translate="yes" xml:space="preserve">
          <source>In some multibyte encodings, any given multibyte character sequence may represent different characters depending on the previous byte sequences, known as &quot;shift sequences&quot;. Such encodings are known as state-dependent: knowledge of the current shift state is required to interpret each character. An NTMBS is only valid if it begins and ends in the initial shift state: if a shift sequence was used, the corresponding unshift sequence has to be present before the terminating null character. Examples of such encodings are the 7-bit JIS, BOCU-1 and &lt;a href=&quot;http://www.unicode.org/reports/tr6&quot;&gt;SCSU&lt;/a&gt;.</source>
          <target state="translated">В некоторых многобайтовых кодировках любая заданная многобайтовая последовательность символов может представлять разные символы в зависимости от предыдущих последовательностей байтов, известных как &amp;laquo;последовательности сдвига&amp;raquo;. Такие кодировки известны как зависящие от состояния: знание текущего состояния сдвига требуется для интерпретации каждого символа. NTMBS действительна только в том случае, если она начинается и заканчивается в исходном состоянии сдвига: если использовалась последовательность сдвигов, соответствующая последовательность несмещений должна присутствовать перед завершающим нулевым символом. Примерами таких кодировок являются 7-битные JIS, BOCU-1 и &lt;a href=&quot;http://www.unicode.org/reports/tr6&quot;&gt;SCSU&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="621567d318323c5c0c22b8501fb1f3c5e2acd90e" translate="yes" xml:space="preserve">
          <source>In such a nested declaration, some of the levels may remain unspecialized (except that it can't specialize a class member template if its enclosing class is unspecialized). For each of those levels, the declaration needs &lt;code&gt;template&amp;lt;arguments&amp;gt;&lt;/code&gt;, because such specializations are themselves templates:</source>
          <target state="translated">В таком вложенном объявлении некоторые уровни могут оставаться неспециализированными (за исключением того, что он не может специализировать шаблон члена класса, если его включающий класс не специализирован). Для каждого из этих уровней для объявления требуется &lt;code&gt;template&amp;lt;arguments&amp;gt;&lt;/code&gt; , поскольку такие специализации сами являются шаблонами:</target>
        </trans-unit>
        <trans-unit id="816350383b2c1e072a6ac4d701ae17bc019c55f8" translate="yes" xml:space="preserve">
          <source>In the C programming language, at least one named parameter must appear before the ellipsis parameter, so &lt;code&gt;printz(...);&lt;/code&gt; is not valid. In C++, this form is allowed even though the arguments passed to such function are not accessible, and is commonly used as the fallback overload in &lt;a href=&quot;sfinae&quot;&gt;SFINAE&lt;/a&gt;, exploiting the lowest priority of the ellipsis conversion in &lt;a href=&quot;overload_resolution&quot;&gt;overload resolution&lt;/a&gt;.</source>
          <target state="translated">В языке программирования C перед параметром с многоточием должен быть хотя бы один именованный параметр, поэтому &lt;code&gt;printz(...);&lt;/code&gt; не действует. В C ++ эта форма разрешена, даже если аргументы, передаваемые такой функции, недоступны и обычно используются в качестве резервной перегрузки в &lt;a href=&quot;sfinae&quot;&gt;SFINAE&lt;/a&gt; , используя наименьший приоритет преобразования многоточия в &lt;a href=&quot;overload_resolution&quot;&gt;разрешении перегрузки&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b7448b8bb4cfc9ef5b6d6148816f9abc314f332d" translate="yes" xml:space="preserve">
          <source>In the C programming language, the &lt;code&gt;goto&lt;/code&gt; statement has fewer restrictions and can enter the scope of any variable other than variable-length array or variably-modified pointer.</source>
          <target state="translated">В языке программирования C &lt;code&gt;goto&lt;/code&gt; имеет меньше ограничений и может вводить область видимости любой переменной, кроме массива переменной длины или переменно-модифицированного указателя.</target>
        </trans-unit>
        <trans-unit id="11df4d5daefca94681eb0c6608609ae515a3f4d3" translate="yes" xml:space="preserve">
          <source>In the C programming language, the width of a bit field cannot exceed the width of the underlying type.</source>
          <target state="translated">В языке программирования C ширина битового поля не может превышать ширину подстилающего типа.</target>
        </trans-unit>
        <trans-unit id="bfc682244d852627ff0d041c2287a081b50d47c4" translate="yes" xml:space="preserve">
          <source>In the above example, if non-ADL lookup for operator&amp;lt;&amp;lt; were allowed from the instantiation context, the instantiation of &lt;code&gt;E::writeObject&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;&lt;/code&gt; would have two different definitions: one using &lt;code&gt;P1::operator&amp;lt;&amp;lt;&lt;/code&gt; and one using &lt;code&gt;P2::operator&amp;lt;&amp;lt;&lt;/code&gt;. Such ODR violation may not be detected by the linker, leading to one or the other being used in both instances.</source>
          <target state="translated">В вышеприведенном примере, если поиск без оператора ADL для оператора &amp;lt;&amp;lt; был разрешен из контекста создания экземпляра, создание экземпляра &lt;code&gt;E::writeObject&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;&lt;/code&gt; будет иметь два разных определения: одно с использованием &lt;code&gt;P1::operator&amp;lt;&amp;lt;&lt;/code&gt; и одно используя &lt;code&gt;P2::operator&amp;lt;&amp;lt;&lt;/code&gt; . Такое нарушение ODR не может быть обнаружено компоновщиком, что приводит к тому, что один или другой используется в обоих случаях.</target>
        </trans-unit>
        <trans-unit id="94f9ba60d2631df2a644921fed4cce7a6456d2d7" translate="yes" xml:space="preserve">
          <source>In the above,</source>
          <target state="translated">В вышеизложенном,</target>
        </trans-unit>
        <trans-unit id="f761fd1f890c95288965ab17065f5bc7b6d6b538" translate="yes" xml:space="preserve">
          <source>In the above, &lt;code&gt;Alloc&lt;/code&gt; is a type that satisfies &lt;a href=&quot;../named_req/allocator&quot;&gt;Allocator&lt;/a&gt;or is a pointer type convertible to &lt;code&gt;std::experimental::pmr::memory_resource*&lt;/code&gt;(library fundamentals TS).</source>
          <target state="translated">В приведенном выше &lt;code&gt;Alloc&lt;/code&gt; является типом, который удовлетворяет &lt;a href=&quot;../named_req/allocator&quot;&gt;Allocator,&lt;/a&gt; или типом указателя, конвертируемым в &lt;code&gt;std::experimental::pmr::memory_resource*&lt;/code&gt; (основы библиотеки TS).</target>
        </trans-unit>
        <trans-unit id="4cc61cf6708e3ef42bac60b85582a7b7be2f3f6f" translate="yes" xml:space="preserve">
          <source>In the body of a cv-qualified function, the &lt;a href=&quot;this&quot;&gt;this&lt;/a&gt; pointer is cv-qualified, e.g. in a &lt;code&gt;const&lt;/code&gt; member function, only other const member functions may be called normally. (A non-const member function may still be called if &lt;a href=&quot;const_cast&quot;&gt;const_cast&lt;/a&gt; is applied or through an access path that does not involve &lt;a href=&quot;this&quot;&gt;this&lt;/a&gt;.).</source>
          <target state="translated">В теле cv-квалифицированной функции &lt;a href=&quot;this&quot;&gt;этот&lt;/a&gt; указатель является cv-квалифицированным, например, в функции-члене &lt;code&gt;const&lt;/code&gt; , только другие функции-члены const могут быть вызваны нормально. ( &lt;a href=&quot;const_cast&quot;&gt;Неконстантная&lt;/a&gt; функция-член может все еще вызываться, если применяется const_cast или через путь доступа, который не включает &lt;a href=&quot;this&quot;&gt;это&lt;/a&gt; .).</target>
        </trans-unit>
        <trans-unit id="893e73a07f97db13bb810fec92b5bc2d9c3779e6" translate="yes" xml:space="preserve">
          <source>In the body of the loop, the following steps take place:</source>
          <target state="translated">В теле петли выполняются следующие действия:</target>
        </trans-unit>
        <trans-unit id="905f50bd3c725e6724b6b75435c36c4e71558664" translate="yes" xml:space="preserve">
          <source>In the body of the template declaration, the name of a type parameter is a typedef-name which aliases the type supplied when the template is instantiated.</source>
          <target state="translated">В теле декларации шаблона имя параметра типа-это имя типа,которое является псевдонимом типа,поставляемого при инстанциировании шаблона.</target>
        </trans-unit>
        <trans-unit id="7218fc3a4992cbcd0152232cad3f51efabb5d84f" translate="yes" xml:space="preserve">
          <source>In the body of the template declaration, the name of this parameter is a template-name (and needs arguments to be instantiated).</source>
          <target state="translated">В теле декларации шаблона имя этого параметра является именем шаблона (и требует инстанцирования аргументов).</target>
        </trans-unit>
        <trans-unit id="900936499efddab53cef702850868c269921a8b7" translate="yes" xml:space="preserve">
          <source>In the case of equality, as determined by &lt;code&gt;operator==&lt;/code&gt;, only lexical representations are compared. Therefore, &lt;code&gt;path(&quot;a&quot;) == path(&quot;b&quot;)&lt;/code&gt; is never &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">В случае равенства, определяемого &lt;code&gt;operator==&lt;/code&gt; , сравниваются только лексические представления. Следовательно, &lt;code&gt;path(&quot;a&quot;) == path(&quot;b&quot;)&lt;/code&gt; никогда не бывает &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9ea417255bb9a3e4e66840a148e5a0eeb99a4a75" translate="yes" xml:space="preserve">
          <source>In the case of equivalence, as determined by &lt;a href=&quot;../equivalent&quot;&gt;&lt;code&gt;equivalent()&lt;/code&gt;&lt;/a&gt;, it is checked whether two paths</source>
          <target state="translated">В случае эквивалентности, как это определено методом &lt;a href=&quot;../equivalent&quot;&gt; &lt;code&gt;equivalent()&lt;/code&gt; &lt;/a&gt; , проверяется наличие двух путей.</target>
        </trans-unit>
        <trans-unit id="0918c8dba94ff6fd94b2510e1844c87eba4fa8bc" translate="yes" xml:space="preserve">
          <source>In the case of thrown exception, the states of the contained values of &lt;code&gt;*this&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt; are determined by the exception safety guarantees of &lt;code&gt;swap&lt;/code&gt; of type &lt;code&gt;T&lt;/code&gt; or &lt;code&gt;T&lt;/code&gt;'s move constructor, whichever is called. For both &lt;code&gt;*this&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt;, if the object contained a value, it is left containing a value, and the other way round.</source>
          <target state="translated">В случае сгенерированного исключения состояния содержащихся значений &lt;code&gt;*this&lt;/code&gt; и &lt;code&gt;other&lt;/code&gt; определяются гарантиями безопасности исключения &lt;code&gt;swap&lt;/code&gt; типа &lt;code&gt;T&lt;/code&gt; или конструктора перемещения &lt;code&gt;T&lt;/code&gt; , в зависимости от того, что вызывается. Для обоих &lt;code&gt;*this&lt;/code&gt; и &lt;code&gt;other&lt;/code&gt; , если объект содержит значение, он остается содержащим значение, и наоборот.</target>
        </trans-unit>
        <trans-unit id="74253cd795fea072a07aa9a7e78a4232e8101c59" translate="yes" xml:space="preserve">
          <source>In the cases (1,2), virt-specifier-seq, if used, is either &lt;a href=&quot;override&quot;&gt;override&lt;/a&gt; or &lt;code&gt;final&lt;/code&gt;, or &lt;code&gt;final override&lt;/code&gt; or &lt;code&gt;override final&lt;/code&gt;. In the case (3), the only allowed value of class-virt-specifier, if used, is &lt;code&gt;final&lt;/code&gt;.</source>
          <target state="translated">В случаях (1,2) virt-specier-seq, если используется, является либо &lt;a href=&quot;override&quot;&gt;override,&lt;/a&gt; либо &lt;code&gt;final&lt;/code&gt; , либо &lt;code&gt;final override&lt;/code&gt; , либо &lt;code&gt;override final&lt;/code&gt; . В случае (3) единственное допустимое значение спецификатора класса, если оно используется, является &lt;code&gt;final&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="64cdd0ab070b191de582e146726ae3b52445aff7" translate="yes" xml:space="preserve">
          <source>In the context of a &lt;a href=&quot;direct_initialization&quot;&gt;direct-initialization&lt;/a&gt;, a &lt;code&gt;bool&lt;/code&gt; object may be initialized from a prvalue of type &lt;code&gt;&lt;a href=&quot;../types/nullptr_t&quot;&gt;std::nullptr_t&lt;/a&gt;&lt;/code&gt;, including &lt;code&gt;nullptr&lt;/code&gt;. The resulting value is &lt;code&gt;false&lt;/code&gt;. However, this is not considered to be an implicit conversion.</source>
          <target state="translated">В контексте &lt;a href=&quot;direct_initialization&quot;&gt;прямой инициализации&lt;/a&gt; , &lt;code&gt;bool&lt;/code&gt; объект может быть инициализирован из prvalue типа &lt;code&gt;&lt;a href=&quot;../types/nullptr_t&quot;&gt;std::nullptr_t&lt;/a&gt;&lt;/code&gt; , в том числе &lt;code&gt;nullptr&lt;/code&gt; . Полученное значение &lt;code&gt;false&lt;/code&gt; . Однако это не считается неявным преобразованием.</target>
        </trans-unit>
        <trans-unit id="c2371f6402972bc45972f3f09d5d022fcbd00df0" translate="yes" xml:space="preserve">
          <source>In the default &quot;C&quot; locale, the following lowercase letters &lt;code&gt;abcdefghijklmnopqrstuvwxyz&lt;/code&gt; are replaced with respective uppercase letters &lt;code&gt;ABCDEFGHIJKLMNOPQRSTUVWXYZ&lt;/code&gt;.</source>
          <target state="translated">В локали &quot;C&quot; по умолчанию следующие строчные буквы &lt;code&gt;abcdefghijklmnopqrstuvwxyz&lt;/code&gt; заменяются соответствующими заглавными буквами &lt;code&gt;ABCDEFGHIJKLMNOPQRSTUVWXYZ&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f82450bef11bed620bb59a03e863ef7afabcdad8" translate="yes" xml:space="preserve">
          <source>In the default &quot;C&quot; locale, the following uppercase letters &lt;code&gt;ABCDEFGHIJKLMNOPQRSTUVWXYZ&lt;/code&gt; are replaced with respective lowercase letters &lt;code&gt;abcdefghijklmnopqrstuvwxyz&lt;/code&gt;.</source>
          <target state="translated">В локали &amp;laquo;C&amp;raquo; по умолчанию следующие заглавные буквы &lt;code&gt;ABCDEFGHIJKLMNOPQRSTUVWXYZ&lt;/code&gt; заменяются соответствующими строчными буквами &lt;code&gt;abcdefghijklmnopqrstuvwxyz&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="27d01f4ee118275f671ea1fc69da0b10c876ae4d" translate="yes" xml:space="preserve">
          <source>In the definition above,</source>
          <target state="translated">В приведенном выше определении,</target>
        </trans-unit>
        <trans-unit id="b73a608fd45fbdf0b5c22a44851fbc673377e55d" translate="yes" xml:space="preserve">
          <source>In the definition of a constructor of a class,</source>
          <target state="translated">В определении конструктора класса,</target>
        </trans-unit>
        <trans-unit id="92eaf109eca502313374c00968739b34523e2380" translate="yes" xml:space="preserve">
          <source>In the definitions above,</source>
          <target state="translated">В вышеприведенных определениях,</target>
        </trans-unit>
        <trans-unit id="817086841623d69755c18cd1a550bd17dbc9cec2" translate="yes" xml:space="preserve">
          <source>In the end, calls &lt;code&gt;str.width(0)&lt;/code&gt; to cancel the effects of any &lt;code&gt;&lt;a href=&quot;../../io/manip/setw&quot;&gt;std::setw&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">В конце, вызывает &lt;code&gt;str.width(0)&lt;/code&gt; чтобы отменить эффекты любого &lt;code&gt;&lt;a href=&quot;../../io/manip/setw&quot;&gt;std::setw&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c655d96839ca7780fa82778f8220c935df02845d" translate="yes" xml:space="preserve">
          <source>In the expression &lt;code&gt;E1.*E2&lt;/code&gt;:</source>
          <target state="translated">В выражении &lt;code&gt;E1.*E2&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="7b082767dd5ca682cdbd1f19496a9ffb37833f35" translate="yes" xml:space="preserve">
          <source>In the expression &lt;code&gt;E1.E2&lt;/code&gt;:</source>
          <target state="translated">В выражении &lt;code&gt;E1.E2&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="9db07dd430b24754012846b56b013710f95fae18" translate="yes" xml:space="preserve">
          <source>In the expression above, the identifier &lt;code&gt;swap&lt;/code&gt; is looked up in the same manner as the one used by the C++17 &lt;code&gt;&lt;a href=&quot;../../types/is_swappable&quot;&gt;std::is_nothrow_swappable&lt;/a&gt;&lt;/code&gt; trait.</source>
          <target state="translated">В выражении выше, идентификатор &lt;code&gt;swap&lt;/code&gt; ищутся в том же порядке, который используется в C ++ 17 &lt;code&gt;&lt;a href=&quot;../../types/is_swappable&quot;&gt;std::is_nothrow_swappable&lt;/a&gt;&lt;/code&gt; признака.</target>
        </trans-unit>
        <trans-unit id="4e914c03795fc0434d207252646fcc5c2fbb853f" translate="yes" xml:space="preserve">
          <source>In the following cases the expression specifying the first dimension is erroneous:</source>
          <target state="translated">В следующих случаях выражение,указывающее первое измерение,ошибочно:</target>
        </trans-unit>
        <trans-unit id="bb90da930e22170c110ed69983a4cd8c89699138" translate="yes" xml:space="preserve">
          <source>In the following cases, the injected-class-name is treated as a template-name of the class template itself:</source>
          <target state="translated">В следующих случаях имя инжектируемого класса рассматривается как имя-шаблон самого шаблона класса:</target>
        </trans-unit>
        <trans-unit id="6f57e7c031dc103138aa47aafe5169cd4d0818a3" translate="yes" xml:space="preserve">
          <source>In the following cases, the types, templates, and non-type values that are used to compose &lt;code&gt;P&lt;/code&gt; do not participate in template argument deduction, but instead</source>
          <target state="translated">В следующих случаях типы, шаблоны и нетиповые значения, используемые для составления &lt;code&gt;P&lt;/code&gt; , не участвуют в выводе аргументов шаблона, а вместо этого</target>
        </trans-unit>
        <trans-unit id="18a089e2076eb0c963948461ded82840d2c5491f" translate="yes" xml:space="preserve">
          <source>In the following contexts ADL-only lookup (that is, lookup in associated namespaces only) takes place:</source>
          <target state="translated">В следующих контекстах происходит поиск только по ADL (т.е.поиск только в ассоциированных пространствах имен):</target>
        </trans-unit>
        <trans-unit id="1e7e564013cddb0a744a7b7d9845915473666e88" translate="yes" xml:space="preserve">
          <source>In the following contexts, a context-specific type &lt;code&gt;T&lt;/code&gt; is expected, and the expression &lt;code&gt;e&lt;/code&gt; of class type &lt;code&gt;E&lt;/code&gt; is only allowed if &lt;code&gt;E&lt;/code&gt; has a single non-explicit &lt;a href=&quot;cast_operator&quot;&gt;user-defined conversion function&lt;/a&gt; to an allowable type(until C++14)there is exactly one type &lt;code&gt;T&lt;/code&gt; among the allowable types such that &lt;code&gt;E&lt;/code&gt; has non-explicit conversion functions whose return types are (possibly cv-qualified) &lt;code&gt;T&lt;/code&gt; or reference to (possibly cv-qualified) &lt;code&gt;T&lt;/code&gt;, and &lt;code&gt;e&lt;/code&gt; is implicitly convertible to &lt;code&gt;T&lt;/code&gt;(since C++14). Such expression &lt;code&gt;e&lt;/code&gt; is said to be</source>
          <target state="translated">В следующих контекстах ожидается специфический для контекста тип &lt;code&gt;T&lt;/code&gt; , и выражение &lt;code&gt;e&lt;/code&gt; типа класса &lt;code&gt;E&lt;/code&gt; допустимо только в том случае, если &lt;code&gt;E&lt;/code&gt; имеет единственную неявную &lt;a href=&quot;cast_operator&quot;&gt;пользовательскую функцию преобразования&lt;/a&gt; в допустимый тип (до C ++ 14). это ровно один тип &lt;code&gt;T&lt;/code&gt; среди допустимых типов, так что &lt;code&gt;E&lt;/code&gt; имеет неявные функции преобразования, чьи возвращаемые типы (возможно, cv-квалифицированные) &lt;code&gt;T&lt;/code&gt; или ссылка (возможно, cv-квалифицированные) &lt;code&gt;T&lt;/code&gt; , и &lt;code&gt;e&lt;/code&gt; неявно конвертируется в &lt;code&gt;T&lt;/code&gt; (так как C ++ 14). Такое выражение &lt;code&gt;e&lt;/code&gt; называется</target>
        </trans-unit>
        <trans-unit id="e9d454a482529bf2ee5e3a62d016e12659bf0446" translate="yes" xml:space="preserve">
          <source>In the following contexts, the type &lt;code&gt;bool&lt;/code&gt; is expected and the implicit conversion is performed if the declaration &lt;code&gt;bool t(e);&lt;/code&gt; is well-formed (that is, an explicit conversion function such as &lt;code&gt;explicit T::operator bool() const;&lt;/code&gt; is considered). Such expression &lt;code&gt;e&lt;/code&gt; is said to be</source>
          <target state="translated">В следующих контекстах ожидается тип &lt;code&gt;bool&lt;/code&gt; , и неявное преобразование выполняется, если объявление &lt;code&gt;bool t(e);&lt;/code&gt; корректно сформирован (то есть рассматривается явная функция преобразования, такая как &lt;code&gt;explicit T::operator bool() const;&lt;/code&gt; ). Такое выражение &lt;code&gt;e&lt;/code&gt; называется</target>
        </trans-unit>
        <trans-unit id="e8e08b92d2240f4a88c69d4e69a8df8c00816b49" translate="yes" xml:space="preserve">
          <source>In the following examples, the fictitious arguments will be called U1, U2.</source>
          <target state="translated">В следующих примерах вымышленные аргументы будут называться U1,U2.</target>
        </trans-unit>
        <trans-unit id="2ebb63b824c4cdb079972404f91cbe60baeddcf6" translate="yes" xml:space="preserve">
          <source>In the implementation used to execute this example, overflow() over-allocates the put area to 512 bytes: a call to str() would only return the four initialized bytes, but the next 508 calls to sputc() would not require new calls to overflow().</source>
          <target state="translated">В реализации,используемой для выполнения этого примера,overflow()переопределяет область put на 512 байт:вызов str()вернет только четыре инициализированных байта,а следующие 508 вызовов sputc()не потребуют новых вызовов overflow().</target>
        </trans-unit>
        <trans-unit id="f8c299b36b8a4498bc3547746db843fd4f953399" translate="yes" xml:space="preserve">
          <source>In the initialization of a variable, when the initializer expression is a &lt;a href=&quot;value_category&quot;&gt;prvalue&lt;/a&gt; of the same class type (ignoring &lt;a href=&quot;cv&quot;&gt;cv-qualification&lt;/a&gt;) as the variable type:</source>
          <target state="translated">При инициализации переменной, когда выражение инициализатора является &lt;a href=&quot;value_category&quot;&gt;prvalue&lt;/a&gt; того же типа класса (игнорируя &lt;a href=&quot;cv&quot;&gt;квалификацию cv&lt;/a&gt; ), что и тип переменной:</target>
        </trans-unit>
        <trans-unit id="27c642266c0731a2e8f833d8f0a3ec3946651726" translate="yes" xml:space="preserve">
          <source>In the initialization of an object, when the source object is a nameless temporary and is of the same class type (ignoring &lt;a href=&quot;cv&quot;&gt;cv-qualification&lt;/a&gt;) as the target object. When the nameless temporary is the operand of a return statement, this variant of copy elision is known as RVO, &quot;return value optimization&quot;.</source>
          <target state="translated">При инициализации объекта, когда исходный объект является временным безымянным и имеет тот же тип класса (игнорирующий &lt;a href=&quot;cv&quot;&gt;квалификацию cv&lt;/a&gt; ), что и целевой объект. Когда безымянный временный оператор является операндом оператора возврата, этот вариант разрешения копирования известен как RVO, &amp;laquo;оптимизация возвращаемого значения&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="5c373829034265c5b0e2556da1a4e7ca6ed3781b" translate="yes" xml:space="preserve">
          <source>In the integer and floating-point digit sequences, optional separators &lt;code&gt;'&lt;/code&gt; are allowed between any two digits and are ignored</source>
          <target state="translated">В цифровых последовательностях целой и с плавающей точкой, дополнительные сепараторы &lt;code&gt;'&lt;/code&gt; разрешены между любыми двумя цифрами и игнорируются</target>
        </trans-unit>
        <trans-unit id="1597dcf21e743f45fe04b66865d76eb95469ddd2" translate="yes" xml:space="preserve">
          <source>In the published C++11 and C++14 standards, this function was specified to require &lt;code&gt;mapped_type&lt;/code&gt; to be &lt;a href=&quot;../../named_req/defaultinsertable&quot;&gt;DefaultInsertable&lt;/a&gt; and &lt;code&gt;key_type&lt;/code&gt; to be &lt;a href=&quot;../../named_req/copyinsertable&quot;&gt;CopyInsertable&lt;/a&gt; or &lt;a href=&quot;../../named_req/moveinsertable&quot;&gt;MoveInsertable&lt;/a&gt; into &lt;code&gt;*this&lt;/code&gt;. This specification was defective and was fixed by &lt;a href=&quot;http://cplusplus.github.io/LWG/lwg-defects.html#2469&quot;&gt;LWG issue 2469&lt;/a&gt;, and the description above incorporates the resolution of that issue.</source>
          <target state="translated">В опубликованной C ++ 11 и C ++ 14 стандартов, эта функция была определена требовать &lt;code&gt;mapped_type&lt;/code&gt; быть &lt;a href=&quot;../../named_req/defaultinsertable&quot;&gt;DefaultInsertable&lt;/a&gt; и &lt;code&gt;key_type&lt;/code&gt; быть &lt;a href=&quot;../../named_req/copyinsertable&quot;&gt;CopyInsertable&lt;/a&gt; или &lt;a href=&quot;../../named_req/moveinsertable&quot;&gt;MoveInsertable&lt;/a&gt; в &lt;code&gt;*this&lt;/code&gt; . Эта спецификация была дефектной и была исправлена ​​в &lt;a href=&quot;http://cplusplus.github.io/LWG/lwg-defects.html#2469&quot;&gt;выпуске 2469 LWG&lt;/a&gt; , и приведенное выше описание включает решение этой проблемы.</target>
        </trans-unit>
        <trans-unit id="984b95b188d8b6ed51c0929b5bbcca151d81d732" translate="yes" xml:space="preserve">
          <source>In the second form of if statement (the one including else), if statement-true is also an if statement then that inner if statement must contain an else part as well (in other words, in nested if-statements, the else is associated with the closest if that doesn't have an else).</source>
          <target state="translated">Во второй форме утверждения if (в том числе и в другой),если утверждение-истина тоже утверждение if,то и в этой внутренней форме утверждение if должно содержать и другую часть (иными словами,во вложенных утверждениях if,другое связано с самым близким,если у него нет другого).</target>
        </trans-unit>
        <trans-unit id="b7c2588aa39c2094ccbf6764f2545ff5d48d7081" translate="yes" xml:space="preserve">
          <source>In the unary-binary overload (3,6), &lt;code&gt;unary_op&lt;/code&gt; is not applied to &lt;code&gt;init&lt;/code&gt;.</source>
          <target state="translated">В унарно-двоичной перегрузке (3,6) &lt;code&gt;unary_op&lt;/code&gt; не применяется к &lt;code&gt;init&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f46af473d10885afbc17d62f3973969b56f43750" translate="yes" xml:space="preserve">
          <source>In these initializer expressions, &lt;code&gt;e&lt;/code&gt; is an lvalue if the type of the entity &lt;code&gt;&lt;i&gt;e&lt;/i&gt;&lt;/code&gt; is an lvalue reference (this only happens if the ref-operator is &lt;code&gt;&amp;amp;&lt;/code&gt; or if it is &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; and the initializer expression is an lvalue) and an xvalue otherwise (this effectively performs a kind of perfect forwarding), &lt;code&gt;i&lt;/code&gt; is a &lt;code&gt;&lt;a href=&quot;../types/size_t&quot;&gt;std::size_t&lt;/a&gt;&lt;/code&gt; prvalue, and &lt;code&gt;&amp;lt;i&amp;gt;&lt;/code&gt; is always interpreted as a template parameter list.</source>
          <target state="translated">В этих выражениях инициализатора &lt;code&gt;e&lt;/code&gt; является lvalue, если тип сущности &lt;code&gt;&lt;i&gt;e&lt;/i&gt;&lt;/code&gt; является ссылкой lvalue (это происходит, только если оператор ref равен &lt;code&gt;&amp;amp;&lt;/code&gt; или если это &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; , а выражение инициализатора является lvalue) и xvalue в противном случае (это эффективно выполняет своего рода идеальную пересылку), &lt;code&gt;i&lt;/code&gt; является значением типа &lt;code&gt;&lt;a href=&quot;../types/size_t&quot;&gt;std::size_t&lt;/a&gt;&lt;/code&gt; , а &lt;code&gt;&amp;lt;i&amp;gt;&lt;/code&gt; всегда интерпретируется как список параметров шаблона.</target>
        </trans-unit>
        <trans-unit id="5edaaa50a68b7de4d405f0db9e2d071386701607" translate="yes" xml:space="preserve">
          <source>In this case, all non-atomic and relaxed atomic stores that are &lt;a href=&quot;memory_order&quot;&gt;sequenced-before&lt;/a&gt; F in thread A will &lt;a href=&quot;memory_order&quot;&gt;happen-before&lt;/a&gt; all non-atomic and relaxed atomic loads from the same locations made in thread B after Y.</source>
          <target state="translated">В этом случае все неатомарные и релаксированные атомные хранилища, которые &lt;a href=&quot;memory_order&quot;&gt;упорядочены - до&lt;/a&gt; F в потоке A, &lt;a href=&quot;memory_order&quot;&gt;произойдут - до того, как&lt;/a&gt; все неатомарные и релаксированные атомные нагрузки из тех же местоположений, что и в потоке B после Y.</target>
        </trans-unit>
        <trans-unit id="0a4cf3adc0dea1f1e86d6ff23d2e32a0caa67f56" translate="yes" xml:space="preserve">
          <source>In this case, all non-atomic and relaxed atomic stores that are &lt;a href=&quot;memory_order&quot;&gt;sequenced-before&lt;/a&gt; FA in thread A will &lt;a href=&quot;memory_order&quot;&gt;happen-before&lt;/a&gt; all non-atomic and relaxed atomic loads from the same locations made in thread B after FB.</source>
          <target state="translated">В этом случае все неатомарные и релаксированные атомные хранилища, которые &lt;a href=&quot;memory_order&quot;&gt;упорядочены до&lt;/a&gt; FA в потоке A, будут &lt;a href=&quot;memory_order&quot;&gt;происходить до&lt;/a&gt; всех неатомарных и релаксированных атомных нагрузок из тех же местоположений, что и в потоке B после FB.</target>
        </trans-unit>
        <trans-unit id="8725b52d3c1fdf65bcce6d3f222c3cb193f19490" translate="yes" xml:space="preserve">
          <source>In this case, all non-atomic and relaxed atomic stores that are &lt;a href=&quot;memory_order&quot;&gt;sequenced-before&lt;/a&gt; X in thread A will &lt;a href=&quot;memory_order&quot;&gt;happen-before&lt;/a&gt; all non-atomic and relaxed atomic loads from the same locations made in thread B after F.</source>
          <target state="translated">В этом случае все неатомарные и релаксированные атомные хранилища, которые &lt;a href=&quot;memory_order&quot;&gt;упорядочены - до&lt;/a&gt; X в потоке A, &lt;a href=&quot;memory_order&quot;&gt;произойдут - до&lt;/a&gt; всех неатомарных и релаксированных атомных нагрузок из тех же местоположений, что и в потоке B после F.</target>
        </trans-unit>
        <trans-unit id="c0eb534d99bfe7cabd6fc507165a3b864a58be3c" translate="yes" xml:space="preserve">
          <source>In this case, the keyword</source>
          <target state="translated">В данном случае ключевое слово</target>
        </trans-unit>
        <trans-unit id="353019d63051611e784bf71d2adc4b77fb808f2b" translate="yes" xml:space="preserve">
          <source>In this case, the member of any specialization of A becomes a friend. This does not involve instantiating the primary template A: the only requirements are that the deduction of the template parameters of A from that specialization succeeds, and that substitution of the deduced template arguments into the friend declaration produces a declaration that would be a valid redeclaration of the member of the specialization:</source>
          <target state="translated">В этом случае член любой специализации А становится другом.Это не предполагает конкретизации первичного шаблона А:единственное требование заключается в том,что вычитание параметров шаблона А из этой специализации является успешным,и замена вычитаемых аргументов шаблона на декларацию друга приводит к появлению декларации,которая была бы действительной повторной декларацией участника специализации:</target>
        </trans-unit>
        <trans-unit id="216570cc099d91d9e8fcba19ae0d75946676ed16" translate="yes" xml:space="preserve">
          <source>In this case, the target constructor is selected by overload resolution and executed first, then the control returns to the delegating constructor and its body is executed.</source>
          <target state="translated">В этом случае целевой конструктор выбирается по разрешению перегрузки и выполняется сначала,затем элемент управления возвращается к делегирующему конструктору,а его тело выполняется.</target>
        </trans-unit>
        <trans-unit id="06f9e15b2ae9be584dce74848cf7b7f2676331fc" translate="yes" xml:space="preserve">
          <source>In this example, initial allocation of the underlying array was for 16 bytes.</source>
          <target state="translated">В данном примере начальное распределение лежащего в основе массива составляло 16 байт.</target>
        </trans-unit>
        <trans-unit id="330c586d17d06314846a2d3fffc6301809c539ee" translate="yes" xml:space="preserve">
          <source>In this example, two values that compare equal under this comparison (which is case-insensitive on the member &lt;code&gt;name&lt;/code&gt; can be distinguished by functions that are case-sensitive:</source>
          <target state="translated">В этом примере два значения равно , которые сравнивают при этом сравнении (что не чувствителен к регистру на членах &lt;code&gt;name&lt;/code&gt; можно выделить с помощью функций, которые чувствительны к регистру:</target>
        </trans-unit>
        <trans-unit id="ff5a35c9480e5a35d467f9e8b2a4ffafdc16c703" translate="yes" xml:space="preserve">
          <source>In those situations where copy assignment cannot benefit from resource reuse (it does not manage a heap-allocated array and does not have a (possibly transitive) member that does, such as a member &lt;code&gt;&lt;a href=&quot;../container/vector&quot;&gt;std::vector&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../string/basic_string&quot;&gt;std::string&lt;/a&gt;&lt;/code&gt;), there is a popular convenient shorthand: the copy-and-swap assignment operator, which takes its parameter by value (thus working as both copy- and move-assignment depending on the value category of the argument), swaps with the parameter, and lets the destructor clean it up.</source>
          <target state="translated">В тех ситуациях, когда назначение копии не может извлечь выгоду из повторного использования ресурса (оно не управляет массивом, выделенным кучей, и не имеет (возможно, транзитивного) члена, который имеет, например, член &lt;code&gt;&lt;a href=&quot;../container/vector&quot;&gt;std::vector&lt;/a&gt;&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;../string/basic_string&quot;&gt;std::string&lt;/a&gt;&lt;/code&gt; ), является популярным удобным сокращением: оператор присваивания &amp;laquo;копировать и поменять&amp;raquo;, который принимает свой параметр по значению (таким образом, работает как присваивание при копировании и перемещении в зависимости от категории значения аргумента), заменяет параметр и позволяет деструктор убери это.</target>
        </trans-unit>
        <trans-unit id="44d42e4e7cdc63f569100975fee76f3a07f480d3" translate="yes" xml:space="preserve">
          <source>In typical usage, &lt;code&gt;count&lt;/code&gt; is the size of the destination array.</source>
          <target state="translated">При обычном использовании &lt;code&gt;count&lt;/code&gt; - это размер целевого массива.</target>
        </trans-unit>
        <trans-unit id="4027a85dd787fe56399bbb11ac7adf2fe0eee28f" translate="yes" xml:space="preserve">
          <source>In typical usage, input stream processing stops on any error. &lt;code&gt;eof()&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;fail&quot;&gt;fail()&lt;/a&gt;&lt;/code&gt; can then be used to distinguish between different error conditions.</source>
          <target state="translated">При обычном использовании обработка входного потока останавливается при любой ошибке. Затем можно использовать &lt;code&gt;eof()&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;fail&quot;&gt;fail()&lt;/a&gt;&lt;/code&gt; чтобы различать различные состояния ошибки.</target>
        </trans-unit>
        <trans-unit id="1c6002149b8d6c5a43ae8ee73b0dbdfdf5535c0c" translate="yes" xml:space="preserve">
          <source>In typical usage, input stream processing stops on any error; &lt;code&gt;feof&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;ferror&quot;&gt;std::ferror&lt;/a&gt;&lt;/code&gt; are then used to distinguish between different error conditions.</source>
          <target state="translated">При обычном использовании обработка входного потока останавливается при любой ошибке; Затем используются &lt;code&gt;feof&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;ferror&quot;&gt;std::ferror&lt;/a&gt;&lt;/code&gt; , чтобы различать различные состояния ошибки.</target>
        </trans-unit>
        <trans-unit id="21e3e82b3a013fa09de3345372c2bcda63c11cf0" translate="yes" xml:space="preserve">
          <source>In typical use cases, this function is the last thing called by a detached thread.</source>
          <target state="translated">В типичных случаях использования эта функция является последним,что вызывается отделенным потоком.</target>
        </trans-unit>
        <trans-unit id="7790a0c7a8cccc64f38d56e2325db218d5c6811d" translate="yes" xml:space="preserve">
          <source>Inappropriate I/O control operation</source>
          <target state="translated">Неправильная операция управления входом/выходом</target>
        </trans-unit>
        <trans-unit id="db54974f7f0ad531e35648ba85b9388029b4d7ef" translate="yes" xml:space="preserve">
          <source>Includes</source>
          <target state="translated">Includes</target>
        </trans-unit>
        <trans-unit id="8705867aeef60bcf6e033673dc025bf70ea7c829" translate="yes" xml:space="preserve">
          <source>Includes January 4</source>
          <target state="translated">Включает 4 января</target>
        </trans-unit>
        <trans-unit id="ea5fdcf7120862d98b9dd3dd4a179e2277f2b2e6" translate="yes" xml:space="preserve">
          <source>Includes e.g. &lt;a href=&quot;memory/new/operator_new&quot;&gt;&lt;code&gt;operator new&lt;/code&gt; &lt;/a&gt;, &lt;a href=&quot;memory/new/operator_delete&quot;&gt; &lt;code&gt;operator delete&lt;/code&gt; &lt;/a&gt;, &lt;code&gt;&lt;a href=&quot;memory/new/set_new_handler&quot;&gt;std::set_new_handler&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Включает, например, &lt;a href=&quot;memory/new/operator_new&quot;&gt; &lt;code&gt;operator new&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;memory/new/operator_delete&quot;&gt; &lt;code&gt;operator delete&lt;/code&gt; &lt;/a&gt; , &lt;code&gt;&lt;a href=&quot;memory/new/set_new_handler&quot;&gt;std::set_new_handler&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bbc9d5a2379fe53e6888d69ff2cfd239b49d1c65" translate="yes" xml:space="preserve">
          <source>Includes e.g. &lt;code&gt;&lt;a href=&quot;memory/c/malloc&quot;&gt;std::malloc&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;memory/c/free&quot;&gt;std::free&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Включает, например, &lt;code&gt;&lt;a href=&quot;memory/c/malloc&quot;&gt;std::malloc&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;memory/c/free&quot;&gt;std::free&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1e25648908297ca3a4ff1a029bba15e376074f7a" translate="yes" xml:space="preserve">
          <source>Includes first Thursday of the year</source>
          <target state="translated">Включает первый четверг года.</target>
        </trans-unit>
        <trans-unit id="2effbb73909ece6a25dcb3109ac70345242cea64" translate="yes" xml:space="preserve">
          <source>Includes other source file into current source file at the line immediately after the directive.</source>
          <target state="translated">Включает другой исходный файл в текущий исходный файл в строке сразу после директивы.</target>
        </trans-unit>
        <trans-unit id="28d47aeec93ecafec39966de5877d68ae0fa0071" translate="yes" xml:space="preserve">
          <source>Including &lt;code&gt;&amp;lt;iostream&amp;gt;&lt;/code&gt; behaves as if it defines a static storage duration object of type &lt;code&gt;&lt;a href=&quot;../io/ios_base/init&quot;&gt;std::ios_base::Init&lt;/a&gt;&lt;/code&gt;, whose constructor initializes the standard stream objects if it is the first &lt;code&gt;std::ios_base::Init&lt;/code&gt; object to be constructed, and whose destructor flushes those objects (except for &lt;code&gt;cin&lt;/code&gt; and &lt;code&gt;wcin&lt;/code&gt;) if it is the last &lt;code&gt;std::ios_base::Init&lt;/code&gt; object to be destroyed.</source>
          <target state="translated">Включение &lt;code&gt;&amp;lt;iostream&amp;gt;&lt;/code&gt; ведет себя так, как будто оно определяет статический объект продолжительности хранения типа &lt;code&gt;&lt;a href=&quot;../io/ios_base/init&quot;&gt;std::ios_base::Init&lt;/a&gt;&lt;/code&gt; , конструктор которого инициализирует объекты стандартного потока, если это первый объект &lt;code&gt;std::ios_base::Init&lt;/code&gt; , и чей Деструктор сбрасывает эти объекты (за исключением &lt;code&gt;cin&lt;/code&gt; и &lt;code&gt;wcin&lt;/code&gt; ), если это последний объект &lt;code&gt;std::ios_base::Init&lt;/code&gt; подлежащий уничтожению.</target>
        </trans-unit>
        <trans-unit id="5cd1c15a802ac17b19b885143fcfe2ec21636c5b" translate="yes" xml:space="preserve">
          <source>Including &lt;strong&gt;&lt;code&gt;&amp;lt;version&amp;gt;&lt;/code&gt;&lt;/strong&gt; also defines all &lt;a href=&quot;../feature_test#Library_features&quot;&gt;library feature-testing macros&lt;/a&gt;.</source>
          <target state="translated">Включение &lt;strong&gt; &lt;code&gt;&amp;lt;version&amp;gt;&lt;/code&gt; &lt;/strong&gt; также определяет все &lt;a href=&quot;../feature_test#Library_features&quot;&gt;макросы тестирования функций библиотеки&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1221ac54217af05f258b4f8aa9f00478c543372d" translate="yes" xml:space="preserve">
          <source>Incomparable values are..</source>
          <target state="translated">Несопоставимые значения...</target>
        </trans-unit>
        <trans-unit id="1ab3146cdd793eb63530b9c56d89f5648c4b83e9" translate="yes" xml:space="preserve">
          <source>Incomplete type</source>
          <target state="translated">Незавершенный тип</target>
        </trans-unit>
        <trans-unit id="38e49d07d428f67ddcca69cc70a81d4cae36a937" translate="yes" xml:space="preserve">
          <source>Increase the capacity of the vector to a value that's greater or equal to &lt;code&gt;new_cap&lt;/code&gt;. If &lt;code&gt;new_cap&lt;/code&gt; is greater than the current &lt;code&gt;&lt;a href=&quot;capacity&quot;&gt;capacity()&lt;/a&gt;&lt;/code&gt;, new storage is allocated, otherwise the method does nothing.</source>
          <target state="translated">Увеличьте емкость вектора до значения, которое больше или равно &lt;code&gt;new_cap&lt;/code&gt; . Если &lt;code&gt;new_cap&lt;/code&gt; больше текущей &lt;code&gt;&lt;a href=&quot;capacity&quot;&gt;capacity()&lt;/a&gt;&lt;/code&gt; , выделяется новое хранилище, в противном случае метод ничего не делает.</target>
        </trans-unit>
        <trans-unit id="7e427ab8b4862191565a1a29a01d981f9c08b30f" translate="yes" xml:space="preserve">
          <source>Increment and decrement</source>
          <target state="translated">Инкремент и декремент</target>
        </trans-unit>
        <trans-unit id="cfe414b6ddcaa8292d016a5a3592ec3f7ea7fada" translate="yes" xml:space="preserve">
          <source>Increment and decrement operators are overloaded for many standard library types. In particular, every &lt;a href=&quot;../named_req/iterator&quot;&gt;LegacyIterator&lt;/a&gt; overloads operator++ and every &lt;a href=&quot;../named_req/bidirectionaliterator&quot;&gt;LegacyBidirectionalIterator&lt;/a&gt; overloads operator--, even if those operators are no-ops for the particular iterator.</source>
          <target state="translated">Операторы увеличения и уменьшения перегружены для многих стандартных типов библиотек. В частности, каждый &lt;a href=&quot;../named_req/iterator&quot;&gt;LegacyIterator&lt;/a&gt; перегружает оператор ++ и каждый &lt;a href=&quot;../named_req/bidirectionaliterator&quot;&gt;LegacyBidirectionalIterator&lt;/a&gt; перегружает оператор - даже если эти операторы не выполняются для конкретного итератора.</target>
        </trans-unit>
        <trans-unit id="f17d70be0f16733c0dc8c67eabfb624d43b60216" translate="yes" xml:space="preserve">
          <source>Increment/decrement operators</source>
          <target state="translated">Операторы инкремента/декремента</target>
        </trans-unit>
        <trans-unit id="cc787748953bd4e94e67cc95ac787d4d3cfb9a68" translate="yes" xml:space="preserve">
          <source>Increment/decrement operators increment or decrement the value of the object.</source>
          <target state="translated">Операторы инкремента/декрементации увеличивают или уменьшают значение объекта.</target>
        </trans-unit>
        <trans-unit id="0f9b5e452f10a6b34da1fb48e02ee30bd5033db1" translate="yes" xml:space="preserve">
          <source>Incrementable</source>
          <target state="translated">Incrementable</target>
        </trans-unit>
        <trans-unit id="cc5ea811af56aeeaf46a0c9737e89031c9af2a17" translate="yes" xml:space="preserve">
          <source>Increments given iterator &lt;code&gt;it&lt;/code&gt; by &lt;code&gt;n&lt;/code&gt; elements.</source>
          <target state="translated">Приращение дано итератор &lt;code&gt;it&lt;/code&gt; по &lt;code&gt;n&lt;/code&gt; элементов.</target>
        </trans-unit>
        <trans-unit id="e3348f80bc84ba16802159a506f193e84a80b03d" translate="yes" xml:space="preserve">
          <source>Increments or decrements the iterator.</source>
          <target state="translated">Увеличивает или укажет итератор.</target>
        </trans-unit>
        <trans-unit id="84c43591c7009c31f153f3e91418e222e8d0fdab" translate="yes" xml:space="preserve">
          <source>Increments or decrements the iterator. Inverse operations are applied to the underlying operator because of the reverse order.</source>
          <target state="translated">Увеличивает или укажет итератор.Обратные операции применяются к базовому оператору из-за обратного ордера.</target>
        </trans-unit>
        <trans-unit id="39764a20978ad7b2e0a6b9bd65f20bac9b65b929" translate="yes" xml:space="preserve">
          <source>Increments or decrements the number of ticks for this duration.</source>
          <target state="translated">Увеличивает или уменьшает количество тиков за эту продолжительность.</target>
        </trans-unit>
        <trans-unit id="910224cadb5c448e8d25dd0213abaae95c58e5ea" translate="yes" xml:space="preserve">
          <source>Index into the array pointed to by the stored pointer.</source>
          <target state="translated">Индекс в массив,на который указывает хранимый указатель.</target>
        </trans-unit>
        <trans-unit id="9d3b08115f1b71f8141facbb6d5edfd271773b19" translate="yes" xml:space="preserve">
          <source>Indicated by a trailing &lt;code&gt;...&lt;/code&gt;(other than one introducing a pack expansion)(since C++11) following the parameter-list of a &lt;a href=&quot;function&quot;&gt;function declaration&lt;/a&gt;.</source>
          <target state="translated">Обозначается завершающим &lt;code&gt;...&lt;/code&gt; (кроме того, который вводит расширение пакета) (начиная с C ++ 11) после списка параметров &lt;a href=&quot;function&quot;&gt;объявления функции&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d49ada4a4f9e6394d6c031cdd3db87968627070f" translate="yes" xml:space="preserve">
          <source>Indicated by using the following syntax for a parameter in the parameter-list of a &lt;a href=&quot;function&quot;&gt;function declaration&lt;/a&gt;.</source>
          <target state="translated">Обозначается с помощью следующего синтаксиса для параметра в списке параметров &lt;a href=&quot;function&quot;&gt;объявления функции&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1712d2e8f937518e01b0931bd205206ed1a8017a" translate="yes" xml:space="preserve">
          <source>Indicates if the match results are ready (valid) or not.</source>
          <target state="translated">Показывает,готовы ли результаты матча (действительны)или нет.</target>
        </trans-unit>
        <trans-unit id="05d56af25aa45704ec160c601a10df5e1c115f08" translate="yes" xml:space="preserve">
          <source>Indicates if this match was successful</source>
          <target state="translated">Показывает,было ли это совпадение успешным</target>
        </trans-unit>
        <trans-unit id="fb13d85a03c61cb1a77aee405db444e1e7dd0d1e" translate="yes" xml:space="preserve">
          <source>Indicates that dependency chain in release-consume &lt;code&gt;&lt;a href=&quot;../../atomic/memory_order&quot;&gt;std::memory_order&lt;/a&gt;&lt;/code&gt; propagates in and out of the function, which allows the compiler to skip unnecessary memory fence instructions.</source>
          <target state="translated">Указывает, что цепочка зависимостей в выпуске-потреблении &lt;code&gt;&lt;a href=&quot;../../atomic/memory_order&quot;&gt;std::memory_order&lt;/a&gt;&lt;/code&gt; распространяется внутри и вне функции, что позволяет компилятору пропускать ненужные инструкции по ограничению памяти.</target>
        </trans-unit>
        <trans-unit id="b1eef975978a88d290550921db3dd4b23de6ed3c" translate="yes" xml:space="preserve">
          <source>Indicates that the fall through from the previous case label is intentional and should not be diagnosed by a compiler that warns on fallthrough.</source>
          <target state="translated">Указывает на то,что падение с предыдущей метки случая является преднамеренным и не должно диагностироваться компилятором,который предупреждает о падении.</target>
        </trans-unit>
        <trans-unit id="07a894f6f65f599ff826de67eb639e25aa960be1" translate="yes" xml:space="preserve">
          <source>Indicates that the function definition should be optimized for invocation from a &lt;a href=&quot;../transactional_memory&quot;&gt;synchronized statement&lt;/a&gt;.</source>
          <target state="translated">Указывает, что определение функции должно быть оптимизировано для вызова из &lt;a href=&quot;../transactional_memory&quot;&gt;синхронизированного оператора&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="404bc23b0c3c1dc2dde1e96665adb2a133cb2f1a" translate="yes" xml:space="preserve">
          <source>Indicates that the function definition should be optimized for invocation from a &lt;a href=&quot;../transactional_memory&quot;&gt;synchronized statement&lt;/a&gt;. In particular, it avoids serializing synchronized blocks that make a call to a function that is transaction-safe for the majority of calls, but not for all calls.</source>
          <target state="translated">Указывает, что определение функции должно быть оптимизировано для вызова из &lt;a href=&quot;../transactional_memory&quot;&gt;синхронизированного оператора&lt;/a&gt; . В частности, он избегает сериализации синхронизированных блоков, которые делают вызов функции, которая безопасна для транзакций для большинства вызовов, но не для всех вызовов.</target>
        </trans-unit>
        <trans-unit id="3763a0ac1424ab7603605b2e6e73c73516778f16" translate="yes" xml:space="preserve">
          <source>Indicates that the function does not return.</source>
          <target state="translated">Указывает на то,что функция не возвращается.</target>
        </trans-unit>
        <trans-unit id="aadf5ff318f6e9ff51544f26ee3de70c127e4ff5" translate="yes" xml:space="preserve">
          <source>Indicates that the name or entity declared with this attribute is &lt;a href=&quot;https://en.wikipedia.org/wiki/Deprecation&quot;&gt;deprecated&lt;/a&gt;, that is, the use is allowed, but discouraged for some reason.</source>
          <target state="translated">Указывает, что имя или сущность, объявленные с этим атрибутом, &lt;a href=&quot;https://en.wikipedia.org/wiki/Deprecation&quot;&gt;устарели&lt;/a&gt; , то есть использование разрешено, но по какой-то причине не рекомендуется.</target>
        </trans-unit>
        <trans-unit id="eb1d4e9c5ff0d33dedb5c76e1e3e0a72c774ec1e" translate="yes" xml:space="preserve">
          <source>Indicates that the use of the name or entity declared with this attribute is allowed, but discouraged for some reason. Compilers typically issue warnings on such uses. The string-literal, if specified, is usually included in the warnings.</source>
          <target state="translated">Указывает на то,что использование имени или сущности,объявленной с данным атрибутом,разрешено,но по каким-то причинам запрещено.Как правило,компиляторы выдают предупреждения о таком использовании.Строково-литературный,если он указан,обычно включается в предупреждения.</target>
        </trans-unit>
        <trans-unit id="1b877dccdb68430deec81ae5c7d0c2899c1a04b6" translate="yes" xml:space="preserve">
          <source>Indicates that this data member need not have an address distinct from all other non-static data members of its class.</source>
          <target state="translated">Указывает на то,что этот член данных не обязательно должен иметь адрес,отличный от всех других нестатических членов его класса.</target>
        </trans-unit>
        <trans-unit id="6a97cea227e92a547c1dd0162d3c17f7d0180b0c" translate="yes" xml:space="preserve">
          <source>Indicates that this data member need not have an address distinct from all other non-static data members of its class. This means that if the member has an empty type (e.g. stateless Allocator), the compiler may optimise it to occupy no space, just like if it were an &lt;a href=&quot;../ebo&quot;&gt;empty base&lt;/a&gt;. If the member is not empty, any tail padding in it may be also reused to store other data members.</source>
          <target state="translated">Указывает, что этот член данных не должен иметь адрес, отличный от всех других нестатических членов данных своего класса. Это означает, что если элемент имеет пустой тип (например, Allocator без сохранения состояния), компилятор может оптимизировать его, чтобы он не занимал места, как если бы он был &lt;a href=&quot;../ebo&quot;&gt;пустой базой&lt;/a&gt; . Если элемент не пустой, любой хвостовой отступ в нем также может быть повторно использован для хранения других элементов данных.</target>
        </trans-unit>
        <trans-unit id="7e16e5df080d66d35fd0fc9ce14ca2cddaaf531e" translate="yes" xml:space="preserve">
          <source>Indicates the endianness of all &lt;a href=&quot;../language/type-id&quot;&gt;scalar types&lt;/a&gt;:</source>
          <target state="translated">Указывает на порядковый номер всех &lt;a href=&quot;../language/type-id&quot;&gt;скалярных типов&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="b7ced8b89669e17290208433d069c305c4668cd4" translate="yes" xml:space="preserve">
          <source>Indirect access</source>
          <target state="translated">Косвенный доступ</target>
        </trans-unit>
        <trans-unit id="945f4467f9e3980b9bc435c192be55e1cdba33ac" translate="yes" xml:space="preserve">
          <source>Indirect callable concepts</source>
          <target state="translated">непрямые вызываемые понятия</target>
        </trans-unit>
        <trans-unit id="615d0df84a8bde5c3b3b45942556ad9ee41f5c88" translate="yes" xml:space="preserve">
          <source>IndirectRelation</source>
          <target state="translated">IndirectRelation</target>
        </trans-unit>
        <trans-unit id="a517704fa906449a7f15a8ece89573834bd716d4" translate="yes" xml:space="preserve">
          <source>IndirectStrictWeakOrder</source>
          <target state="translated">IndirectStrictWeakOrder</target>
        </trans-unit>
        <trans-unit id="4fd88b3054ecad93f1a95a527c3891631b31f23d" translate="yes" xml:space="preserve">
          <source>IndirectUnaryInvocableIndirectRegularUnaryInvocable</source>
          <target state="translated">IndirectUnaryInvocableIndirectRegularUnaryInvocable</target>
        </trans-unit>
        <trans-unit id="d4d035f7c30e113629f27edd40bf70e82d6284b2" translate="yes" xml:space="preserve">
          <source>IndirectUnaryPredicate</source>
          <target state="translated">IndirectUnaryPredicate</target>
        </trans-unit>
        <trans-unit id="1ba4d5bf8c849bf8c04b9c6e21cc8e1df44157c8" translate="yes" xml:space="preserve">
          <source>Indirection through a pointer that became invalid in this manner and passing it to a deallocation function (double-delete) is undefined behavior. Any other use is implementation-defined.</source>
          <target state="translated">Индримация через указатель,который таким образом стал недействительным,и передача его в функцию дилокации (double-delete)является неопределенным поведением.Любое другое использование является реализацией.</target>
        </trans-unit>
        <trans-unit id="fc6c8e1f0dc3858c691ccb1300793e524ab1874b" translate="yes" xml:space="preserve">
          <source>Indirection through an invalid pointer value and passing an invalid pointer value to a deallocation function have undefined behavior. Any other use of an invalid pointer value has implementation-defined behavior.</source>
          <target state="translated">Индерентификация через некорректное значение указателя и передача некорректного значения указателя в функцию дилокации имеют неопределённое поведение.Любое другое использование недействительного значения указателя имеет реализацию-определенное поведение.</target>
        </trans-unit>
        <trans-unit id="caa250f6b40fd31e6e435ad3ec42b55df8c15198" translate="yes" xml:space="preserve">
          <source>IndirectlyComparable</source>
          <target state="translated">IndirectlyComparable</target>
        </trans-unit>
        <trans-unit id="79246d49d2de7bde0e84161dfa390e35ead80dbb" translate="yes" xml:space="preserve">
          <source>IndirectlyCopyable</source>
          <target state="translated">IndirectlyCopyable</target>
        </trans-unit>
        <trans-unit id="c1b4de1846b6ae50bbf1bb567d1c5423353b3f7c" translate="yes" xml:space="preserve">
          <source>IndirectlyCopyableStorable</source>
          <target state="translated">IndirectlyCopyableStorable</target>
        </trans-unit>
        <trans-unit id="4f10a919177009406f024b0a5f8b598cade73a1d" translate="yes" xml:space="preserve">
          <source>IndirectlyMovable</source>
          <target state="translated">IndirectlyMovable</target>
        </trans-unit>
        <trans-unit id="be4b7238e8cf0d8749bb2f509a225195d878018a" translate="yes" xml:space="preserve">
          <source>IndirectlyMovableStorable</source>
          <target state="translated">IndirectlyMovableStorable</target>
        </trans-unit>
        <trans-unit id="1fb085c0bd571e7f0dafcbf700d51d838a32da50" translate="yes" xml:space="preserve">
          <source>IndirectlySwappable</source>
          <target state="translated">IndirectlySwappable</target>
        </trans-unit>
        <trans-unit id="b5f6e97cd4faf7045970097d59a8c5be90de03ff" translate="yes" xml:space="preserve">
          <source>Inexact result</source>
          <target state="translated">Неточный результат</target>
        </trans-unit>
        <trans-unit id="98df9b88a5e801dd458f9dea0b5eb524b074282a" translate="yes" xml:space="preserve">
          <source>Infinite loop without side-effects</source>
          <target state="translated">Бесконечный цикл без побочных эффектов</target>
        </trans-unit>
        <trans-unit id="8f1b65e86ba58e7d09ad5b638567441248d44fd1" translate="yes" xml:space="preserve">
          <source>Informally &quot;A is more specialized than B&quot; means &quot;A accepts a subset of the types that B accepts&quot;.</source>
          <target state="translated">В неофициальном порядке &quot;А является более специализированным,чем В&quot; означает &quot;А принимает подмножество типов,которые принимает В&quot;.</target>
        </trans-unit>
        <trans-unit id="8e26416412a250dc41f16163d325bfe0d9375649" translate="yes" xml:space="preserve">
          <source>Informally &quot;A is more specialized than B&quot; means &quot;A accepts fewer types than B&quot;.</source>
          <target state="translated">В неофициальном порядке &quot;А является более специализированным,чем В&quot; означает &quot;А принимает меньше типов,чем В&quot;.</target>
        </trans-unit>
        <trans-unit id="837818b163877df19b00b59309303eba5812d227" translate="yes" xml:space="preserve">
          <source>Informally, an object is odr-used if its value is read (unless it is a compile time constant) or written, its address is taken, or a reference is bound to it; a reference is odr-used if it is used and its referent is not known at compile time; and a function is odr-used if a function call to it is made or its address is taken. If an object, a reference or a function is odr-used, its definition must exist somewhere in the program; a violation of that is usually a link-time error.</source>
          <target state="translated">Информально,объект используется в odr-пользовании,если его значение прочитано (если только он не является константой времени компиляции)или записано,его адрес взят или к нему привязана ссылка;ссылка используется в odr-пользовании,если она используется и ее референт неизвестен во время компиляции;и функция используется в odr-пользовании,если к ней произведен вызов функции или взят ее адрес.Если объект,ссылка или функция используются в режиме odr,их определение должно существовать где-то в программе;нарушение этого правила обычно является ошибкой во времени компиляции.</target>
        </trans-unit>
        <trans-unit id="c6ae6b7147966f4caadf3becb3a298c96ec40912" translate="yes" xml:space="preserve">
          <source>Informally, two types are</source>
          <target state="translated">В неофициальном порядке,два типа</target>
        </trans-unit>
        <trans-unit id="37bbacc3d1827431eb0e90015863e8cd1f6d09b3" translate="yes" xml:space="preserve">
          <source>Informs the compiler that the dependency tree started by an &lt;code&gt;&lt;a href=&quot;memory_order&quot;&gt;std::memory_order_consume&lt;/a&gt;&lt;/code&gt; atomic load operation does not extend past the return value of &lt;code&gt;std::kill_dependency&lt;/code&gt;; that is, the argument does not carry a dependency into the return value.</source>
          <target state="translated">Информирует компилятор о том, что дерево зависимостей, запущенное с помощью &lt;code&gt;&lt;a href=&quot;memory_order&quot;&gt;std::memory_order_consume&lt;/a&gt;&lt;/code&gt; атомарной загрузки std :: memory_order_consume , не выходит за пределы возвращаемого значения &lt;code&gt;std::kill_dependency&lt;/code&gt; ; то есть аргумент не несет зависимости в возвращаемое значение.</target>
        </trans-unit>
        <trans-unit id="e9f0d94767eeb4fdf66bcb63f83f831a24817f3f" translate="yes" xml:space="preserve">
          <source>Informs the garbage collector or leak detector that the specified memory region (&lt;code&gt;n&lt;/code&gt; bytes beginning at the byte pointed to by &lt;code&gt;p&lt;/code&gt;) contains no traceable pointers. If any part of the region is within an allocated object, the entire region must be contained in the same object.</source>
          <target state="translated">Сообщает сборщику мусора или детектору утечки, что указанная область памяти ( &lt;code&gt;n&lt;/code&gt; байтов, начинающаяся с байта, на который указывает &lt;code&gt;p&lt;/code&gt; ) не содержит отслеживаемых указателей. Если какая-либо часть региона находится внутри выделенного объекта, вся область должна содержаться в одном и том же объекте.</target>
        </trans-unit>
        <trans-unit id="6b00d875f974811886ac196dcb915203f177f6a1" translate="yes" xml:space="preserve">
          <source>Informs the implementation that the object &lt;code&gt;ptr&lt;/code&gt; points to is aligned to at least &lt;code&gt;N&lt;/code&gt;. The implementation may use this information to generate more efficient code, but it might only make this assumption if the object is accessed via the return value of &lt;code&gt;assume_aligned&lt;/code&gt;.</source>
          <target state="translated">Информирует реализации , что объект &lt;code&gt;ptr&lt;/code&gt; указывает на выровнен по меньшей мере , &lt;code&gt;N&lt;/code&gt; . Реализация может использовать эту информацию для генерации более эффективного кода, но она может сделать это предположение, только если доступ к объекту осуществляется через возвращаемое значение &lt;code&gt;assume_aligned&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fdaddb9ce367c2ca746a97cc24d2e8817a51f27d" translate="yes" xml:space="preserve">
          <source>Inheritance</source>
          <target state="translated">Inheritance</target>
        </trans-unit>
        <trans-unit id="24e63953e4f041a3bb4ac3148f230860861e7ff3" translate="yes" xml:space="preserve">
          <source>Inheritance diagram.</source>
          <target state="translated">Диаграмма наследования.</target>
        </trans-unit>
        <trans-unit id="43a9b1d67674ea8718fc711a00f7bb00fbb4c4df" translate="yes" xml:space="preserve">
          <source>Inherited copy and move constructors are not included in the list of candidate functions when constructing a derived class object.</source>
          <target state="translated">Унаследованные конструкторы копирования и перемещения не включаются в список функций-кандидатов при построении объекта производного класса.</target>
        </trans-unit>
        <trans-unit id="8f06971d5187bb5c21be32f180285afdb914b12b" translate="yes" xml:space="preserve">
          <source>Inherited from &lt;a href=&quot;../../../types/integral_constant&quot;&gt; std::integral_constant&lt;/a&gt;</source>
          <target state="translated">Наследуется от &lt;a href=&quot;../../../types/integral_constant&quot;&gt;std :: integra_constant&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f30304d5307d8a19e13fb3ed0a2bac9d82e0a424" translate="yes" xml:space="preserve">
          <source>Inherited from &lt;a href=&quot;../../error/exception&quot;&gt; std::exception&lt;/a&gt;</source>
          <target state="translated">Наследуется от &lt;a href=&quot;../../error/exception&quot;&gt;std :: exception&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="01fe97cbbb0941b6f2a72d6bcbf5bf30c49dc7b1" translate="yes" xml:space="preserve">
          <source>Inherited from &lt;a href=&quot;../../error/runtime_error/runtime_error&quot;&gt; std::runtime_error&lt;/a&gt;</source>
          <target state="translated">Наследуется от &lt;a href=&quot;../../error/runtime_error/runtime_error&quot;&gt;std :: runtime_error&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="179a5175974c4d0f1231cb42168b0c03c785293b" translate="yes" xml:space="preserve">
          <source>Inherited from &lt;a href=&quot;../../error/system_error&quot;&gt; std::system_error&lt;/a&gt;</source>
          <target state="translated">Наследуется от &lt;a href=&quot;../../error/system_error&quot;&gt;std :: system_error&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="7a80e3d34750b628e39956fcaf30d5d8a1ed24f4" translate="yes" xml:space="preserve">
          <source>Inherited from &lt;a href=&quot;../../types/integral_constant&quot;&gt; std::integral_constant&lt;/a&gt;</source>
          <target state="translated">Наследуется от &lt;a href=&quot;../../types/integral_constant&quot;&gt;std :: integra_constant&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="dc3357171bb4abff2c5bcfa928f18def082a907c" translate="yes" xml:space="preserve">
          <source>Inherited from &lt;a href=&quot;../error/exception&quot;&gt; std::exception&lt;/a&gt;</source>
          <target state="translated">Наследуется от &lt;a href=&quot;../error/exception&quot;&gt;std :: exception&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="30b72f9cdb58e5970783c671d3934c33faeb1623" translate="yes" xml:space="preserve">
          <source>Inherited from &lt;a href=&quot;../error/logic_error/logic_error&quot;&gt; std::logic_error&lt;/a&gt;</source>
          <target state="translated">Наследуется от &lt;a href=&quot;../error/logic_error/logic_error&quot;&gt;std :: logic_error&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="957863018da5b123ab6f6ee5e33f1ffffd93019e" translate="yes" xml:space="preserve">
          <source>Inherited from &lt;a href=&quot;../error/runtime_error/runtime_error&quot;&gt; std::runtime_error&lt;/a&gt;</source>
          <target state="translated">Наследуется от &lt;a href=&quot;../error/runtime_error/runtime_error&quot;&gt;std :: runtime_error&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="4810ddaa7ee3800c8518272cbd3eab0a576e08e1" translate="yes" xml:space="preserve">
          <source>Inherited from &lt;a href=&quot;../error/system_error&quot;&gt; std::system_error&lt;/a&gt;</source>
          <target state="translated">Наследуется от &lt;a href=&quot;../error/system_error&quot;&gt;std :: system_error&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="8f42576c785a3be8154970999da87190cb9371f9" translate="yes" xml:space="preserve">
          <source>Inherited from &lt;a href=&quot;../exception&quot;&gt; std::exception&lt;/a&gt;</source>
          <target state="translated">Наследуется от &lt;a href=&quot;../exception&quot;&gt;std :: exception&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="1ff5d17ac32734b6c4b40b6f4b8d2dbbce7f1b33" translate="yes" xml:space="preserve">
          <source>Inherited from &lt;a href=&quot;../types/integral_constant&quot;&gt; std::integral_constant&lt;/a&gt;</source>
          <target state="translated">Наследуется от &lt;a href=&quot;../types/integral_constant&quot;&gt;std :: integra_constant&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="64a89d3879a72da7c6ee665cb1868939227a129a" translate="yes" xml:space="preserve">
          <source>Inherited from &lt;a href=&quot;../utility/pair&quot;&gt; std::pair&lt;/a&gt;</source>
          <target state="translated">Наследуется от &lt;a href=&quot;../utility/pair&quot;&gt;std :: pair&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ad227e6a5a2991b9ae2118d21b1ded53643ffeb6" translate="yes" xml:space="preserve">
          <source>Inherited from &lt;a href=&quot;bad_alloc&quot;&gt; std::bad_alloc&lt;/a&gt;</source>
          <target state="translated">Наследуется от &lt;a href=&quot;bad_alloc&quot;&gt;std :: bad_alloc&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="0640747e62ff14ba1b29b108a996ca8f524d1b5a" translate="yes" xml:space="preserve">
          <source>Inherited from &lt;a href=&quot;basic_ios&quot;&gt; std::basic_ios&lt;/a&gt;</source>
          <target state="translated">Наследуется от &lt;a href=&quot;basic_ios&quot;&gt;std :: basic_ios&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="de0c89b89174954a9f92de2b010f4eba6cf65be6" translate="yes" xml:space="preserve">
          <source>Inherited from &lt;a href=&quot;basic_istream&quot;&gt; std::basic_istream&lt;/a&gt;</source>
          <target state="translated">Наследуется от &lt;a href=&quot;basic_istream&quot;&gt;std :: basic_istream&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="5294336a5cb08c884f1c1c77c83e45be59fa6ba0" translate="yes" xml:space="preserve">
          <source>Inherited from &lt;a href=&quot;basic_ostream&quot;&gt; std::basic_ostream&lt;/a&gt;</source>
          <target state="translated">Наследуется от &lt;a href=&quot;basic_ostream&quot;&gt;std :: basic_ostream&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="9055f46788224b7f31bcf6f24250ff5d47695175" translate="yes" xml:space="preserve">
          <source>Inherited from &lt;a href=&quot;basic_streambuf&quot;&gt; std::basic_streambuf&lt;/a&gt;</source>
          <target state="translated">Наследуется от &lt;a href=&quot;basic_streambuf&quot;&gt;std :: basic_streambuf&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="538de0fbed9b76df7a6ab5144cdd294244e05923" translate="yes" xml:space="preserve">
          <source>Inherited from &lt;a href=&quot;codecvt&quot;&gt; std::codecvt&lt;/a&gt;</source>
          <target state="translated">Наследуется от &lt;a href=&quot;codecvt&quot;&gt;std :: codecvt&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="691ededb623378951567ffd0bfa980099fbe3761" translate="yes" xml:space="preserve">
          <source>Inherited from &lt;a href=&quot;codecvt_base&quot;&gt; std::codecvt_base&lt;/a&gt;</source>
          <target state="translated">Наследуется от &lt;a href=&quot;codecvt_base&quot;&gt;std :: codecvt_base&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="55051117752349a92484d2d68e1536f7ba751ac6" translate="yes" xml:space="preserve">
          <source>Inherited from &lt;a href=&quot;collate&quot;&gt; std::collate&lt;/a&gt;</source>
          <target state="translated">Наследуется от &lt;a href=&quot;collate&quot;&gt;std :: collate&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="646bf27bfd425c0266f785460d8846b085490446" translate="yes" xml:space="preserve">
          <source>Inherited from &lt;a href=&quot;exception&quot;&gt; std::exception&lt;/a&gt;</source>
          <target state="translated">Наследуется от &lt;a href=&quot;exception&quot;&gt;std :: exception&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="2b1e16a440f913fb0c212304822e1171df74e082" translate="yes" xml:space="preserve">
          <source>Inherited from &lt;a href=&quot;integral_constant&quot;&gt; std::integral_constant&lt;/a&gt;</source>
          <target state="translated">Наследуется от &lt;a href=&quot;integral_constant&quot;&gt;std :: integra_constant&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="3d307388b240b50355fd55953eea3dcf640dd433" translate="yes" xml:space="preserve">
          <source>Inherited from &lt;a href=&quot;ios_base&quot;&gt; std::ios_base&lt;/a&gt;</source>
          <target state="translated">Наследуется от &lt;a href=&quot;ios_base&quot;&gt;std :: ios_base&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e507c076782fb8eb8b54d375f2f956f7369f545d" translate="yes" xml:space="preserve">
          <source>Inherited from &lt;a href=&quot;messages&quot;&gt; std::messages&lt;/a&gt;</source>
          <target state="translated">Наследуется от &lt;a href=&quot;messages&quot;&gt;std :: messages&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f67af012ab32d51632e38d03380caedc6cb1fd11" translate="yes" xml:space="preserve">
          <source>Inherited from &lt;a href=&quot;money_base&quot;&gt;std::money_base&lt;/a&gt;</source>
          <target state="translated">Наследуется от &lt;a href=&quot;money_base&quot;&gt;std :: money_base&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="88842694e8b959006d435b6cad10e7a20f4f86fe" translate="yes" xml:space="preserve">
          <source>Inherited from &lt;a href=&quot;moneypunct&quot;&gt; std::moneypunct&lt;/a&gt;</source>
          <target state="translated">Наследуется от &lt;a href=&quot;moneypunct&quot;&gt;std :: moneypunct&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="4d17a29ada80f7d12d7692d7e6aaa8521d515613" translate="yes" xml:space="preserve">
          <source>Inherited from &lt;a href=&quot;numpunct&quot;&gt; std::numpunct&lt;/a&gt;</source>
          <target state="translated">Наследуется от &lt;a href=&quot;numpunct&quot;&gt;std :: numpunct&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="96f6c2f33d9e5a486e8905be371715ec2d5e0e4c" translate="yes" xml:space="preserve">
          <source>Inherited from &lt;a href=&quot;runtime_error/runtime_error&quot;&gt; std::runtime_error&lt;/a&gt;</source>
          <target state="translated">Наследуется от &lt;a href=&quot;runtime_error/runtime_error&quot;&gt;std :: runtime_error&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="7efc4c44fcbc8224af5b604f6ea179f896007df5" translate="yes" xml:space="preserve">
          <source>Inherited from &lt;a href=&quot;time_get&quot;&gt; std::time_get&lt;/a&gt;</source>
          <target state="translated">Наследуется от &lt;a href=&quot;time_get&quot;&gt;std :: time_get&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="6fda6ad022c33ce0f5b1400e8f343ad50076eeb0" translate="yes" xml:space="preserve">
          <source>Inherited from &lt;a href=&quot;time_put&quot;&gt; std::time_put&lt;/a&gt;</source>
          <target state="translated">Наследуется от &lt;a href=&quot;time_put&quot;&gt;std :: time_put&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e7135edcc0660dff5ef07a7531f5a314d1a14345" translate="yes" xml:space="preserve">
          <source>Inherited from std::ctype&amp;lt;CharT&amp;gt;</source>
          <target state="translated">Наследуется от std :: ctype &amp;lt;CharT&amp;gt;</target>
        </trans-unit>
        <trans-unit id="96606dedfe0d1180adfbb7cf5dc6b000d690eeaa" translate="yes" xml:space="preserve">
          <source>Inherited from std::ctype&amp;lt;char&amp;gt;</source>
          <target state="translated">Наследуется от std :: ctype &amp;lt;char&amp;gt;</target>
        </trans-unit>
        <trans-unit id="6835bd4de94e4c8ff9fa81f21f0a45e937163c89" translate="yes" xml:space="preserve">
          <source>Inherited from std::ctype_base</source>
          <target state="translated">Унаследованный от std::ctype_base</target>
        </trans-unit>
        <trans-unit id="2a9684185e4ab4b7acc08548b265978c0ac9b665" translate="yes" xml:space="preserve">
          <source>Inherited from std::messages_base</source>
          <target state="translated">Унаследованный от std::messages_base</target>
        </trans-unit>
        <trans-unit id="ec11a5942722961cf6c8bf90cef0c0ab7cbfd804" translate="yes" xml:space="preserve">
          <source>Inherited from std::time_base</source>
          <target state="translated">Унаследованный от std::time_base</target>
        </trans-unit>
        <trans-unit id="a162155e80acef2e40d64da7fae4b6cef737ccc3" translate="yes" xml:space="preserve">
          <source>Inheriting constructors</source>
          <target state="translated">Унаследовавшие конструкторы</target>
        </trans-unit>
        <trans-unit id="ed212d227256484af63b60ae12f72487723786d7" translate="yes" xml:space="preserve">
          <source>Inheriting from empty base classes usually does not increase the size of a class due to &lt;a href=&quot;../language/ebo&quot;&gt;empty base optimization&lt;/a&gt;.</source>
          <target state="translated">Наследование от пустых базовых классов обычно не увеличивает размер класса из-за &lt;a href=&quot;../language/ebo&quot;&gt;оптимизации&lt;/a&gt; пустых базовых классов .</target>
        </trans-unit>
        <trans-unit id="19682bdb9185a5fa9d763d414d0443d3a0bc2456" translate="yes" xml:space="preserve">
          <source>Init</source>
          <target state="translated">Init</target>
        </trans-unit>
        <trans-unit id="68fa16ffd48f366e4fa8d57fea78ff03fcab0191" translate="yes" xml:space="preserve">
          <source>Initialization</source>
          <target state="translated">Initialization</target>
        </trans-unit>
        <trans-unit id="f6e1e46e4baf5716e3220f3484c1af85b95e71c8" translate="yes" xml:space="preserve">
          <source>Initialization by constructor</source>
          <target state="translated">Инициализация конструктором</target>
        </trans-unit>
        <trans-unit id="d0105ebd75116f796a8152546a960d90f6068ea4" translate="yes" xml:space="preserve">
          <source>Initialization of &lt;a href=&quot;../language/storage_duration#Static_local_variables&quot;&gt;function-local statics&lt;/a&gt; is guaranteed to occur only once even when called from multiple threads, and may be more efficient than the equivalent code using &lt;code&gt;std::call_once&lt;/code&gt;.</source>
          <target state="translated">Инициализация &lt;a href=&quot;../language/storage_duration#Static_local_variables&quot;&gt;функционально-локальной статики&lt;/a&gt; гарантированно происходит только один раз, даже если она вызывается из нескольких потоков, и может быть более эффективной, чем эквивалентный код, использующий &lt;code&gt;std::call_once&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d91f501eae2c832f1b0b7e4d4973d0855f66060e" translate="yes" xml:space="preserve">
          <source>Initialization order</source>
          <target state="translated">Приказ о инициализации</target>
        </trans-unit>
        <trans-unit id="49fb3cd233b01d2f3fca6d231ff8868b279e8d64" translate="yes" xml:space="preserve">
          <source>Initialization to all bits zero does not guarantee that a floating-point or a pointer would be initialized to 0.0 and the null pointer value, respectively (although that is true on all common platforms).</source>
          <target state="translated">Инициализация на все биты нуля не гарантирует,что плавающая точка или указатель будут инициализированы на 0.0 и значение нулевого указателя соответственно (хотя это верно на всех распространенных платформах).</target>
        </trans-unit>
        <trans-unit id="6ea9d5c7645589c136d59cd57df44af49ce9783f" translate="yes" xml:space="preserve">
          <source>Initialization with a &lt;a href=&quot;../../language/string_literal&quot;&gt;string literal&lt;/a&gt; that contains embedded &lt;code&gt;'\0'&lt;/code&gt; characters uses the overload (5), which stops at the first null character. This can be avoided by specifying a different constructor or by using &lt;a href=&quot;operator_q__q_s&quot;&gt;&lt;code&gt;operator&quot;&quot;s&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">При инициализации &lt;a href=&quot;../../language/string_literal&quot;&gt;строковым литералом&lt;/a&gt; , содержащим вложенные символы &lt;code&gt;'\0'&lt;/code&gt; используется перегрузка (5), которая останавливается на первом нулевом символе. Этого можно избежать, указав другой конструктор или используя &lt;a href=&quot;operator_q__q_s&quot;&gt; &lt;code&gt;operator&quot;&quot;s&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="a8b6090f523a6604aaf83ad226d272f3e664763f" translate="yes" xml:space="preserve">
          <source>Initializer lists</source>
          <target state="translated">Списки инициализаторов</target>
        </trans-unit>
        <trans-unit id="5205b0ca0f0fefcfe68c33103c2c9c1ce338c249" translate="yes" xml:space="preserve">
          <source>Initializer lists may be implemented as a pair of pointers or pointer and length. Copying a &lt;code&gt;std::initializer_list&lt;/code&gt; does not copy the underlying objects.</source>
          <target state="translated">Списки инициализатора могут быть реализованы в виде пары указателей или указателя и длины. Копирование &lt;code&gt;std::initializer_list&lt;/code&gt; не копирует базовые объекты.</target>
        </trans-unit>
        <trans-unit id="4cd615dbf08a4b7ea3976db14aee644d6937efce" translate="yes" xml:space="preserve">
          <source>Initializes an aggregate from braced-init-list.</source>
          <target state="translated">Инициализирует агрегат из списка &quot;Брэйд-иннит&quot;.</target>
        </trans-unit>
        <trans-unit id="44dcbda2c857e660e975019d6dd123883526dd75" translate="yes" xml:space="preserve">
          <source>Initializes an object from another object.</source>
          <target state="translated">Инициализирует объект с другого объекта.</target>
        </trans-unit>
        <trans-unit id="0d3ed04db9734c04b00626e83cd3a554c91216b4" translate="yes" xml:space="preserve">
          <source>Initializes an object from braced-init-list.</source>
          <target state="translated">Инициализирует объект из списка скрепленных фигур.</target>
        </trans-unit>
        <trans-unit id="b28ee811ef30d6e7a7f950db96ff44c9ab341ca0" translate="yes" xml:space="preserve">
          <source>Initializes an object from explicit set of constructor arguments.</source>
          <target state="translated">Инициализирует объект из явного набора аргументов конструктора.</target>
        </trans-unit>
        <trans-unit id="3612fbe04b3d4f902d2d49989872e1c625ef8e37" translate="yes" xml:space="preserve">
          <source>Initializes exposition-only data member &lt;code&gt;bound_&lt;/code&gt; with &lt;code&gt;bound&lt;/code&gt;.</source>
          <target state="translated">Инициализирует элемент данных только для экспозиции &lt;code&gt;bound_&lt;/code&gt; with &lt;code&gt;bound&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e582f41fbe9142faa1edac6dc025f737e0f1efef" translate="yes" xml:space="preserve">
          <source>Initializes exposition-only data member &lt;code&gt;current_&lt;/code&gt; with &lt;code&gt;current&lt;/code&gt; and exposition-only data members &lt;code&gt;parent_&lt;/code&gt; with &lt;code&gt;addressof(parent)&lt;/code&gt;.</source>
          <target state="translated">Инициализирует элемент данных только для экспозиции &lt;code&gt;current_&lt;/code&gt; с элементами данных &lt;code&gt;current&lt;/code&gt; и только для экспозиции &lt;code&gt;parent_&lt;/code&gt; с &lt;code&gt;addressof(parent)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="687eeb5c76107cbf76d277e107912b3a093ddbf0" translate="yes" xml:space="preserve">
          <source>Initializes exposition-only data member &lt;code&gt;end_&lt;/code&gt; with &lt;code&gt;parent&lt;/code&gt;.</source>
          <target state="translated">Инициализирует элемент данных только для экспозиции &lt;code&gt;end_&lt;/code&gt; с &lt;code&gt;parent&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="45a2d2edd8a0c33265b1f7964c619dbe931e75f5" translate="yes" xml:space="preserve">
          <source>Initializes exposition-only data member &lt;code&gt;value_&lt;/code&gt; with &lt;code&gt;value&lt;/code&gt;. This value will be returned by operator* and incremented by operator++</source>
          <target state="translated">Инициализирует элемент данных только для экспозиции &lt;code&gt;value_&lt;/code&gt; со &lt;code&gt;value&lt;/code&gt; . Это значение будет возвращено оператором * и увеличено оператором ++</target>
        </trans-unit>
        <trans-unit id="3ed19383d0a866bf81dc2a8bf40d1563412b85cf" translate="yes" xml:space="preserve">
          <source>Initializes the</source>
          <target state="translated">Инициализирует</target>
        </trans-unit>
        <trans-unit id="a8d332dbed9d2af60e29bd52e5cde6a80c7ad53b" translate="yes" xml:space="preserve">
          <source>Initializes the default-constructed atomic object &lt;code&gt;obj&lt;/code&gt; with the value &lt;code&gt;desired&lt;/code&gt;. The function is not atomic: concurrent access from another thread, even through an atomic operation, is a data race.</source>
          <target state="translated">Инициализирует построенный по умолчанию атомарный объект &lt;code&gt;obj&lt;/code&gt; с &lt;code&gt;desired&lt;/code&gt; значением . Функция не атомарна: параллельный доступ из другого потока, даже через атомарную операцию, является гонкой данных.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
