<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="cpp">
    <body>
      <group id="cpp">
        <trans-unit id="3b425af2c74038d3cea50dc46fcd13bffe0eccf8" translate="yes" xml:space="preserve">
          <source>As of C++17, the types of the</source>
          <target state="translated">Начиная с C++17,типы</target>
        </trans-unit>
        <trans-unit id="459c28d90aaec6c98bb359ff8946c3af0fb14c25" translate="yes" xml:space="preserve">
          <source>As of C++20, &lt;code&gt;std::rel_ops&lt;/code&gt; are deprecated in favor of &lt;a href=&quot;../../language/default_comparisons&quot;&gt;&lt;code&gt;operator&amp;lt;=&amp;gt;&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Начиная с C ++ 20, &lt;code&gt;std::rel_ops&lt;/code&gt; устарела в пользу &lt;a href=&quot;../../language/default_comparisons&quot;&gt; &lt;code&gt;operator&amp;lt;=&amp;gt;&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="393ac68dbef87cdc436bb91eca938eb72a14d0ab" translate="yes" xml:space="preserve">
          <source>As of the ISO C11 standard, the C language has the &lt;code&gt;_Alignas&lt;/code&gt; keyword and defines &lt;code&gt;alignas&lt;/code&gt; as a preprocessor macro expanding to the keyword in the header &lt;a href=&quot;http://en.cppreference.com/w/c/types.html&quot;&gt;&lt;code&gt;&amp;lt;stdalign.h&amp;gt;&lt;/code&gt;&lt;/a&gt;, but in C++ this is a keyword, and the headers &lt;a href=&quot;../header#Meaningless_C_headers&quot;&gt;&lt;code&gt;&amp;lt;stdalign.h&amp;gt;&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../header/cstdalign&quot;&gt;&lt;code&gt;&amp;lt;cstdalign&amp;gt;&lt;/code&gt;&lt;/a&gt; do not define such macro. They do, however, define the macro constant &lt;code&gt;__alignas_is_defined&lt;/code&gt;.</source>
          <target state="translated">Что касается стандарта ISO C11, язык C имеет ключевое слово &lt;code&gt;_Alignas&lt;/code&gt; и определяет &lt;code&gt;alignas&lt;/code&gt; как макрос препроцессора, расширяющийся до ключевого слова в заголовке &lt;a href=&quot;http://en.cppreference.com/w/c/types.html&quot;&gt; &lt;code&gt;&amp;lt;stdalign.h&amp;gt;&lt;/code&gt; &lt;/a&gt; , но в C ++ это ключевое слово, а заголовки &lt;a href=&quot;../header#Meaningless_C_headers&quot;&gt; &lt;code&gt;&amp;lt;stdalign.h&amp;gt;&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;../header/cstdalign&quot;&gt; &lt;code&gt;&amp;lt;cstdalign&amp;gt;&lt;/code&gt; &lt;/a&gt; не определяют такой макрос. Тем не менее, они определяют макро константу &lt;code&gt;__alignas_is_defined&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1a3bf7d8519e9e7ad03735c819bddeb04ebd58f9" translate="yes" xml:space="preserve">
          <source>As opposed to &lt;code&gt;&lt;a href=&quot;vector&quot;&gt;std::vector&lt;/a&gt;&lt;/code&gt;, the elements of a deque are not stored contiguously: typical implementations use a sequence of individually allocated fixed-size arrays, with additional bookkeeping, which means indexed access to deque must perform two pointer dereferences, compared to vector's indexed access which performs only one.</source>
          <target state="translated">В отличие от &lt;code&gt;&lt;a href=&quot;vector&quot;&gt;std::vector&lt;/a&gt;&lt;/code&gt; , элементы deque не сохраняются непрерывно: типичные реализации используют последовательность индивидуально распределенных массивов фиксированного размера с дополнительным ведением учета, что означает, что индексированный доступ к deque должен выполнять две разыменования указателя по сравнению с vector индексированный доступ, который выполняет только один.</target>
        </trans-unit>
        <trans-unit id="fda56045f92b7462f128e13910bd06f8f30c0434" translate="yes" xml:space="preserve">
          <source>As other &lt;a href=&quot;declarations&quot;&gt;block declarations&lt;/a&gt;, this declaration can appear inside a block (a function body or another compound statement), and, as all other declarations, this declaration can also appear outside a block.</source>
          <target state="translated">Как и другие &lt;a href=&quot;declarations&quot;&gt;объявления блока&lt;/a&gt; , это объявление может появляться внутри блока (тела функции или другого составного оператора), и, как и все другие объявления, это объявление также может появляться вне блока.</target>
        </trans-unit>
        <trans-unit id="2b28e6bf13601652216db82706de6c91cb78b5eb" translate="yes" xml:space="preserve">
          <source>As part of the C++ &lt;a href=&quot;memory_model#Forward_progress&quot;&gt;forward progress guarantee&lt;/a&gt;, the behavior is &lt;a href=&quot;ub&quot;&gt;undefined&lt;/a&gt; if a loop that has no &lt;a href=&quot;as_if&quot;&gt;observable behavior&lt;/a&gt; (does not make calls to I/O functions, access volatile objects, or perform atomic or synchronization operations) does not terminate. Compilers are permitted to remove such loops.</source>
          <target state="translated">Как часть &lt;a href=&quot;memory_model#Forward_progress&quot;&gt;гарантии прямого продвижения&lt;/a&gt; C ++ , поведение не &lt;a href=&quot;ub&quot;&gt;определено,&lt;/a&gt; если цикл, который не имеет &lt;a href=&quot;as_if&quot;&gt;наблюдаемого поведения&lt;/a&gt; (не выполняет вызовы функций ввода-вывода, доступа к изменчивым объектам или выполнения атомарных операций или операций синхронизации), не прерывается. Компиляторам разрешено удалять такие циклы.</target>
        </trans-unit>
        <trans-unit id="a58c582d2511f72c3f58935ef1fcd1a0625d23a3" translate="yes" xml:space="preserve">
          <source>As specifed in &lt;code&gt;&lt;a href=&quot;../../locale/num_put/put&quot;&gt;std::num_put::put&lt;/a&gt;&lt;/code&gt;, the showbase flag in integer output acts like the # format specifier in &lt;code&gt;&lt;a href=&quot;../c/printf&quot;&gt;std::printf&lt;/a&gt;&lt;/code&gt;, which means the numeric base prefix is</source>
          <target state="translated">Как указано в &lt;code&gt;&lt;a href=&quot;../../locale/num_put/put&quot;&gt;std::num_put::put&lt;/a&gt;&lt;/code&gt; , флаг showbase в целочисленном выводе действует как спецификатор формата # в &lt;code&gt;&lt;a href=&quot;../c/printf&quot;&gt;std::printf&lt;/a&gt;&lt;/code&gt; , что означает, что числовой базовый префикс равен</target>
        </trans-unit>
        <trans-unit id="758f5930578d19fd61834cd8aab203c32e2b6172" translate="yes" xml:space="preserve">
          <source>As specified in &lt;code&gt;&lt;a href=&quot;../../locale/time_get/get&quot;&gt;std::time_get::do_get&lt;/a&gt;&lt;/code&gt;, which this function calls, it's unspecified if this function zero out the fields in &lt;code&gt;*tmb&lt;/code&gt; that are not set directly by the conversion specifiers that appear in &lt;code&gt;fmt&lt;/code&gt;: portable programs should initialize every field of &lt;code&gt;*tmb&lt;/code&gt; to zero before calling &lt;code&gt;std::get_time&lt;/code&gt;.</source>
          <target state="translated">Как указано в &lt;code&gt;&lt;a href=&quot;../../locale/time_get/get&quot;&gt;std::time_get::do_get&lt;/a&gt;&lt;/code&gt; , который вызывает эта функция, не указывается , обнуляет ли эта функция поля в &lt;code&gt;*tmb&lt;/code&gt; , которые не установлены непосредственно спецификаторами преобразования, которые появляются в &lt;code&gt;fmt&lt;/code&gt; : portable, программы должны инициализировать каждое поле &lt;code&gt;*tmb&lt;/code&gt; в ноль перед вызовом &lt;code&gt;std::get_time&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="12353475b6995e09c45d7991314f3740302cb8b2" translate="yes" xml:space="preserve">
          <source>As specified in &lt;code&gt;&lt;a href=&quot;math_errhandling&quot;&gt;math_errhandling&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INEXACT&lt;/a&gt;&lt;/code&gt; may be (but isn't required to be on non-IEEE floating-point platforms) raised by &lt;code&gt;std::rint&lt;/code&gt; when rounding a non-integer finite value.</source>
          <target state="translated">Как указано в &lt;code&gt;&lt;a href=&quot;math_errhandling&quot;&gt;math_errhandling&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INEXACT&lt;/a&gt;&lt;/code&gt; может (но не обязательно для платформ с плавающей точкой не-IEEE) &lt;code&gt;std::rint&lt;/code&gt; при округлении нецелого конечного значения.</target>
        </trans-unit>
        <trans-unit id="7725511f2ba730c6af150bdf08e783c9982b3239" translate="yes" xml:space="preserve">
          <source>As the control flow moves up the call stack, destructors are invoked for all objects with &lt;a href=&quot;storage_duration&quot;&gt;automatic storage duration&lt;/a&gt; constructed, but not yet destroyed, since the corresponding try-block was entered, in reverse order of completion of their constructors.  If an exception is thrown from a destructor of a local variable or of a temporary used in a &lt;a href=&quot;return&quot;&gt;return&lt;/a&gt; statement, the destructor for the object returned from the function is also invoked.(since C++14).</source>
          <target state="translated">Когда поток управления перемещается вверх по стеку вызовов, деструкторы вызываются для всех объектов с &lt;a href=&quot;storage_duration&quot;&gt;автоматической продолжительностью хранения, созданной&lt;/a&gt; , но еще не уничтоженной, поскольку был введен соответствующий блок try, в обратном порядке завершения их конструкторов. Если исключение выдается из деструктора локальной переменной или временного объекта, используемого в операторе &lt;a href=&quot;return&quot;&gt;возврата&lt;/a&gt; , также вызывается деструктор для объекта, возвращаемого функцией (начиная с C ++ 14).</target>
        </trans-unit>
        <trans-unit id="59a6248c1a38202e83ccc7b37adc45f17d3ca8bb" translate="yes" xml:space="preserve">
          <source>As the object of the interface type controls the lifetime of the object of the implementation type, the pointer to implementation is usually &lt;code&gt;&lt;a href=&quot;../memory/unique_ptr&quot;&gt;std::unique_ptr&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Поскольку объект типа интерфейса управляет временем жизни объекта типа реализации, указатель на реализацию обычно является &lt;code&gt;&lt;a href=&quot;../memory/unique_ptr&quot;&gt;std::unique_ptr&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="95b6d730748d0282aeb230ca4bb19bcc16aee1d0" translate="yes" xml:space="preserve">
          <source>As with &lt;code&gt;&lt;a href=&quot;../promise/~promise&quot;&gt;std::promise::~promise&lt;/a&gt;&lt;/code&gt;, if the shared state is abandoned before it was made ready, an &lt;code&gt;&lt;a href=&quot;../future_error&quot;&gt;std::future_error&lt;/a&gt;&lt;/code&gt; exception is stored with the error code &lt;code&gt;&lt;a href=&quot;../future_errc&quot;&gt;std::future_errc::broken_promise&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">Как и в случае &lt;code&gt;&lt;a href=&quot;../promise/~promise&quot;&gt;std::promise::~promise&lt;/a&gt;&lt;/code&gt; , если общее состояние &lt;code&gt;&lt;a href=&quot;../future_error&quot;&gt;std::future_error&lt;/a&gt;&lt;/code&gt; до того, как оно было готово, исключение std :: future_error сохраняется с кодом ошибки &lt;code&gt;&lt;a href=&quot;../future_errc&quot;&gt;std::future_errc::broken_promise&lt;/a&gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="db81005fb30215522b4ae6ed80e37c5851341286" translate="yes" xml:space="preserve">
          <source>As with &lt;code&gt;&lt;a href=&quot;readsome&quot;&gt;readsome()&lt;/a&gt;&lt;/code&gt;, it is implementation-defined whether this function does anything with library-supplied streams. The intent is typically for the next read operation to pick up any changes that may have been made to the associated input sequence after the stream buffer last filled its get area. To achieve that, &lt;code&gt;sync()&lt;/code&gt; may empty the get area, or it may refill it, or it may do nothing. A notable exception is Visual Studio, where this operation discards the unprocessed input when called with a standard input stream.</source>
          <target state="translated">Как и в случае &lt;code&gt;&lt;a href=&quot;readsome&quot;&gt;readsome()&lt;/a&gt;&lt;/code&gt; , определяется реализацией, делает ли эта функция что-либо с потоками, предоставляемыми библиотекой. Как правило, целью следующей операции чтения является определение любых изменений, которые могли быть внесены в соответствующую входную последовательность после того, как буфер потока в последний раз заполнил свою область получения. Чтобы достичь этого, &lt;code&gt;sync()&lt;/code&gt; может очистить область get, заполнить или ничего не сделать. Заметным исключением является Visual Studio, где эта операция отбрасывает необработанный ввод при вызове со стандартным потоком ввода.</target>
        </trans-unit>
        <trans-unit id="e02b3da6a9ef315d015858b0685c757647c3727e" translate="yes" xml:space="preserve">
          <source>As with &lt;code&gt;&lt;a href=&quot;try_lock&quot;&gt;try_lock()&lt;/a&gt;&lt;/code&gt;, this function is allowed to fail spuriously and return &lt;code&gt;false&lt;/code&gt; even if the mutex was not locked by any other thread at some point before &lt;code&gt;timeout_time&lt;/code&gt;.</source>
          <target state="translated">Как и в &lt;code&gt;&lt;a href=&quot;try_lock&quot;&gt;try_lock()&lt;/a&gt;&lt;/code&gt; , этой функции разрешен случайный сбой и она возвращает &lt;code&gt;false&lt;/code&gt; , даже если мьютекс не был заблокирован каким-либо другим потоком в какой-то момент до &lt;code&gt;timeout_time&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2344babfb98b4f53fd07a875b3c619171ca14ba3" translate="yes" xml:space="preserve">
          <source>As with &lt;code&gt;&lt;a href=&quot;try_lock&quot;&gt;try_lock()&lt;/a&gt;&lt;/code&gt;, this function is allowed to fail spuriously and return &lt;code&gt;false&lt;/code&gt; even if the mutex was not locked by any other thread at some point during &lt;code&gt;timeout_duration&lt;/code&gt;.</source>
          <target state="translated">Как и в &lt;code&gt;&lt;a href=&quot;try_lock&quot;&gt;try_lock()&lt;/a&gt;&lt;/code&gt; , этой функции разрешен случайный сбой и она возвращает &lt;code&gt;false&lt;/code&gt; , даже если мьютекс не был заблокирован каким-либо другим потоком в какой-то момент во время &lt;code&gt;timeout_duration&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6cc991e561b91afca581c36d0451f165db913528" translate="yes" xml:space="preserve">
          <source>As with &lt;code&gt;&lt;a href=&quot;try_lock_shared&quot;&gt;try_lock_shared()&lt;/a&gt;&lt;/code&gt;, this function is allowed to fail spuriously and return &lt;code&gt;false&lt;/code&gt; even if the mutex was not locked by any other thread at some point before &lt;code&gt;timeout_time&lt;/code&gt;.</source>
          <target state="translated">Как и в &lt;code&gt;&lt;a href=&quot;try_lock_shared&quot;&gt;try_lock_shared()&lt;/a&gt;&lt;/code&gt; , этой функции разрешен случайный сбой и она возвращает &lt;code&gt;false&lt;/code&gt; , даже если мьютекс не был заблокирован каким-либо другим потоком в какой-то момент до &lt;code&gt;timeout_time&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="17ca3ed64cc51c1cb0dc92ea591b8dc31fb89228" translate="yes" xml:space="preserve">
          <source>As with &lt;code&gt;&lt;a href=&quot;try_lock_shared&quot;&gt;try_lock_shared()&lt;/a&gt;&lt;/code&gt;, this function is allowed to fail spuriously and return &lt;code&gt;false&lt;/code&gt; even if the mutex was not locked by any other thread at some point during &lt;code&gt;timeout_duration&lt;/code&gt;.</source>
          <target state="translated">Как и в &lt;code&gt;&lt;a href=&quot;try_lock_shared&quot;&gt;try_lock_shared()&lt;/a&gt;&lt;/code&gt; , этой функции разрешен случайный сбой и она возвращает &lt;code&gt;false&lt;/code&gt; , даже если мьютекс не был заблокирован каким-либо другим потоком в какой-то момент во время &lt;code&gt;timeout_duration&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a6c725944b1fe65a2ebfcadda7a99c820c0b5684" translate="yes" xml:space="preserve">
          <source>As with all cast expressions, the result is:</source>
          <target state="translated">Как и в случае со всеми выражениями гипса,результат:</target>
        </trans-unit>
        <trans-unit id="c4531a0fac3bef177007b25ab065170cd62b185b" translate="yes" xml:space="preserve">
          <source>As with all floating-point expressions, the expression &lt;code&gt;(x*y) + z&lt;/code&gt; may be compiled as a fused multiply-add unless the &lt;a href=&quot;../../preprocessor/impl&quot;&gt;#pragma&lt;/a&gt;&lt;code&gt;STDC FP_CONTRACT&lt;/code&gt; is off.</source>
          <target state="translated">Как и для всех выражений с плавающей запятой, выражение &lt;code&gt;(x*y) + z&lt;/code&gt; может быть скомпилировано как &lt;code&gt;STDC FP_CONTRACT&lt;/code&gt; умножение-сложение, если только &lt;a href=&quot;../../preprocessor/impl&quot;&gt;#pragma &lt;/a&gt;STDC FP_CONTRACT выключено.</target>
        </trans-unit>
        <trans-unit id="a3219f037624b3a59d32f19972411fe565f772da" translate="yes" xml:space="preserve">
          <source>As with any &lt;a href=&quot;../fenv&quot;&gt;floating-point environment&lt;/a&gt; functionality, rounding is only guaranteed if &lt;code&gt;#pragma STDC FENV_ACCESS ON&lt;/code&gt; is set.</source>
          <target state="translated">Как и для любой функциональности &lt;a href=&quot;../fenv&quot;&gt;среды&lt;/a&gt; с плавающей запятой , округление гарантируется только в том случае, если установлен параметр &lt;code&gt;#pragma STDC FENV_ACCESS ON&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c944fdb24684333ebc3c89bf06ee5cb49e730938" translate="yes" xml:space="preserve">
          <source>As with any &lt;a href=&quot;binarypredicate&quot;&gt;BinaryPredicate&lt;/a&gt;, evaluation of that expression is not allowed to call non-const functions through the dereferenced iterators.</source>
          <target state="translated">Как и в случае любого &lt;a href=&quot;binarypredicate&quot;&gt;BinaryPredicate&lt;/a&gt; , вычисление этого выражения не позволяет вызывать неконстантные функции через разыменованные итераторы.</target>
        </trans-unit>
        <trans-unit id="0c8150aa08651170bc9a40a763dd7808b45e5c3c" translate="yes" xml:space="preserve">
          <source>As with any declaration, attributes that appear before the declaration and the attributes that appear immediately after the identifier within the declarator both apply to the entity being declared or defined (in this case, to the function).</source>
          <target state="translated">Как и в любом декларировании,атрибуты,появляющиеся до объявления,и атрибуты,появляющиеся сразу после идентификатора внутри декларатора,применяются к объявляемому или определяемому объекту (в данном случае к функции).</target>
        </trans-unit>
        <trans-unit id="56571e50d5f66c5a4fcd35d377801f5d88c364d4" translate="yes" xml:space="preserve">
          <source>As with any declaration, the type of the function &lt;code&gt;func&lt;/code&gt; declared as &lt;code&gt;ret func(params)&lt;/code&gt; is &lt;code&gt;ret(params)&lt;/code&gt; (except for parameter type rewriting described below): see &lt;a href=&quot;type-id#Type_naming&quot;&gt;type naming&lt;/a&gt;.</source>
          <target state="translated">Как и в любом объявлении, тип функции &lt;code&gt;func&lt;/code&gt; , объявленной как &lt;code&gt;ret func(params)&lt;/code&gt; является &lt;code&gt;ret(params)&lt;/code&gt; (за исключением переписывания типа параметра, описанного ниже): см. &lt;a href=&quot;type-id#Type_naming&quot;&gt;Naming type&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="696ebcfb49b007939dac3def74f8d0bf869c372d" translate="yes" xml:space="preserve">
          <source>As with any floating-point computations, accuracy loss may raise &lt;code&gt;&lt;a href=&quot;../../numeric/fenv/fe_exceptions&quot;&gt;FE_INEXACT&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Как и при любых вычислениях с плавающей запятой, потеря точности может повысить &lt;code&gt;&lt;a href=&quot;../../numeric/fenv/fe_exceptions&quot;&gt;FE_INEXACT&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e78a90c2d8247309ba7cb75c5ea72e82d43d4fa8" translate="yes" xml:space="preserve">
          <source>As with any implicitly-declared special member function, the exception specification of the implicitly-declared destructor is non-throwing unless the destructor of any potentially-constructed base or member is &lt;a href=&quot;noexcept_spec&quot;&gt;potentially-throwing&lt;/a&gt;(since C++17)implicit definition would directly invoke a function with a different exception specification(until C++17). In practice, implicit destructors are &lt;code&gt;noexcept&lt;/code&gt; unless the class is &quot;poisoned&quot; by a base or member whose destructor is &lt;code&gt;noexcept(false)&lt;/code&gt;.</source>
          <target state="translated">Как и в случае любой неявно объявленной специальной функции-члена, спецификация исключений неявно объявленного деструктора не является броском, если деструктор любой потенциально сконструированной базы или члена не является &lt;a href=&quot;noexcept_spec&quot;&gt;потенциально бросающим&lt;/a&gt; (начиная с C ++ 17), неявное определение непосредственно вызовет функция с другой спецификацией исключений (до C ++ 17). На практике неявные деструкторы не &lt;code&gt;noexcept&lt;/code&gt; если только класс не &amp;laquo;отравлен&amp;raquo; базой или членом, чей деструктор не &lt;code&gt;noexcept(false)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="50e87fdf512eb04cfd3749351769cc640478c4f4" translate="yes" xml:space="preserve">
          <source>As with any other uninitialized storage, the objects are created using &lt;a href=&quot;../language/new&quot;&gt;placement new&lt;/a&gt; and destroyed with explicit destructor calls.</source>
          <target state="translated">Как и в любом другом неинициализированном хранилище, объекты создаются с использованием &lt;a href=&quot;../language/new&quot;&gt;новых&lt;/a&gt; и уничтожаются с помощью явных вызовов деструкторов.</target>
        </trans-unit>
        <trans-unit id="17eb59c250e2c883a971b71b88fc81b6282b7ab5" translate="yes" xml:space="preserve">
          <source>As with copy assignment, it is unspecified whether virtual base class subobjects that are accessible through more than one path in the inheritance lattice, are assigned more than once by the implicitly-defined move assignment operator:</source>
          <target state="translated">Как и в случае с присвоением копий,неясно,назначаются ли виртуальные подобъекты базового класса,доступные через более чем один путь в решетке наследования,более одного раза неявно определяемым оператором присвоения перемещения:</target>
        </trans-unit>
        <trans-unit id="845dc726234df1066d102eb3d7d5edcb75d4ae23" translate="yes" xml:space="preserve">
          <source>As with most user-defined overloads, return types should match return types provided by the built-in operators so that &lt;a href=&quot;operators&quot;&gt;the user-defined operators&lt;/a&gt; can be used in the same manner as the built-ins. However, in a user-defined operator overload, any type can be used as return type (including &lt;code&gt;void&lt;/code&gt;). One exception is &lt;code&gt;operator-&amp;gt;&lt;/code&gt;, which must return a pointer or another class with overloaded &lt;code&gt;operator-&amp;gt;&lt;/code&gt; to be realistically usable.</source>
          <target state="translated">Как и в случае большинства пользовательских перегрузок, возвращаемые типы должны соответствовать возвращаемым типам, предоставляемым встроенными операторами, чтобы &lt;a href=&quot;operators&quot;&gt;пользовательские операторы&lt;/a&gt; могли использоваться так же, как и встроенные. Однако при пользовательской перегрузке оператора любой тип может использоваться в качестве возвращаемого типа (включая &lt;code&gt;void&lt;/code&gt; ). Единственное исключение - &lt;code&gt;operator-&amp;gt;&lt;/code&gt; , который должен возвращать указатель или другой класс с перегруженным &lt;code&gt;operator-&amp;gt;&lt;/code&gt; чтобы его можно было реально использовать.</target>
        </trans-unit>
        <trans-unit id="a00bb778184f2e410cf6c8021b7589c57c820f61" translate="yes" xml:space="preserve">
          <source>As with other &lt;a href=&quot;static&quot;&gt;static members&lt;/a&gt;, a definition of a static data member template may be required. Such definition is provided outside the class definition. A template declaration of a static data member at namespace scope may also be a definition of a non-template &lt;a href=&quot;member_template&quot;&gt;data member of a class template&lt;/a&gt;:</source>
          <target state="translated">Как и в случае других &lt;a href=&quot;static&quot;&gt;статических элементов&lt;/a&gt; , может потребоваться определение шаблона статического элемента данных. Такое определение предоставляется вне определения класса. Объявление шаблона статического члена данных в области пространства имен также может быть определением не шаблонного &lt;a href=&quot;member_template&quot;&gt;члена данных шаблона класса&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="0caedc0a848a88fa7660a1d1d491a243138571ee" translate="yes" xml:space="preserve">
          <source>As with unions, if a variant holds a value of some object type &lt;code&gt;T&lt;/code&gt;, the object representation of &lt;code&gt;T&lt;/code&gt; is allocated directly within the object representation of the variant itself. Variant is not allowed to allocate additional (dynamic) memory.</source>
          <target state="translated">Как и в случае союзов, если вариант содержит значение некоторого типа объекта &lt;code&gt;T&lt;/code&gt; , объектное представление &lt;code&gt;T&lt;/code&gt; выделяется непосредственно в объектном представлении самого варианта. Варианту запрещается выделять дополнительную (динамическую) память.</target>
        </trans-unit>
        <trans-unit id="a16aea9de44066876745f8be1e3815d74bf01236" translate="yes" xml:space="preserve">
          <source>As with using-declarations for any other non-static member functions, if an inherited constructor matches the signature of one of the constructors of &lt;code&gt;Derived&lt;/code&gt;, it is hidden from lookup by the version found in &lt;code&gt;Derived&lt;/code&gt;. If one of the inherited constructors of &lt;code&gt;Base&lt;/code&gt; happens to have the signature that matches a copy/move constructor of the &lt;code&gt;Derived&lt;/code&gt;, it does not prevent implicit generation of &lt;code&gt;Derived&lt;/code&gt; copy/move constructor (which then hides the inherited version, similar to &lt;code&gt;using operator=&lt;/code&gt;).</source>
          <target state="translated">Как и в случае использования-объявлений для любых других нестатических функций-членов, если унаследованный конструктор совпадает с сигнатурой одного из конструкторов &lt;code&gt;Derived&lt;/code&gt; , он скрыт от поиска версией, найденной в &lt;code&gt;Derived&lt;/code&gt; . Если один из унаследованных конструкторов &lt;code&gt;Base&lt;/code&gt; имеет сигнатуру, совпадающую с конструктором копирования / перемещения &lt;code&gt;Derived&lt;/code&gt; , это не предотвращает неявную генерацию конструктора &lt;code&gt;Derived&lt;/code&gt; копирования / перемещения (который затем скрывает унаследованную версию, аналогично &lt;code&gt;using operator=&lt;/code&gt; ) ,</target>
        </trans-unit>
        <trans-unit id="79bc029ba48a0820eb9af6de0ebd1ea7e6ea9789" translate="yes" xml:space="preserve">
          <source>As-if rule</source>
          <target state="translated">правило As-if</target>
        </trans-unit>
        <trans-unit id="49bf55dc112eb3597726ba8ecf785a4fae4cbce0" translate="yes" xml:space="preserve">
          <source>Assertions</source>
          <target state="translated">Assertions</target>
        </trans-unit>
        <trans-unit id="b2f457245914fc23605f0f7914ce430db153c7e2" translate="yes" xml:space="preserve">
          <source>Assertions help to implement checking of preconditions in programs.</source>
          <target state="translated">Утверждения помогают реализовать проверку предусловий в программах.</target>
        </trans-unit>
        <trans-unit id="fdd23dc2be237bc20201ebacd22daaf8d91fcba6" translate="yes" xml:space="preserve">
          <source>Assign the range &lt;code&gt;[il.begin(), il.end())&lt;/code&gt; into &lt;code&gt;a&lt;/code&gt;. Elements of &lt;code&gt;a&lt;/code&gt; that were not assigned to are destroyed</source>
          <target state="translated">Назначают диапазон &lt;code&gt;[il.begin(), il.end())&lt;/code&gt; в . Элементы , которые не были назначены уничтожены &lt;code&gt;a&lt;/code&gt; &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f202c66f553fb440879be6b02e68b6d5eec62e62" translate="yes" xml:space="preserve">
          <source>Assign the value of &lt;code&gt;other&lt;/code&gt; to &lt;code&gt;*this&lt;/code&gt;.</source>
          <target state="translated">Присвоить значение &lt;code&gt;other&lt;/code&gt; для &lt;code&gt;*this&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a88debc55c7f994c398ec8c342bc18a51643d37f" translate="yes" xml:space="preserve">
          <source>Assignable</source>
          <target state="translated">Assignable</target>
        </trans-unit>
        <trans-unit id="e55df441e8955746182110c3946288f381520e83" translate="yes" xml:space="preserve">
          <source>Assignment</source>
          <target state="translated">Assignment</target>
        </trans-unit>
        <trans-unit id="57808f73b7c2a86fa45f02e4061d5d9b69c60881" translate="yes" xml:space="preserve">
          <source>Assignment need not be a total function. In particular, if assigning to some object &lt;code&gt;x&lt;/code&gt; can cause some other object &lt;code&gt;y&lt;/code&gt; to be modified, then &lt;code&gt;x = y&lt;/code&gt; is likely not in the domain of &lt;code&gt;=&lt;/code&gt;. This typically happens if the right operand is owned directly or indirectly by the left operand (e.g., with smart pointers to nodes in an node-based data structure, or with something like &lt;code&gt;&lt;a href=&quot;../container/vector&quot;&gt;std::vector&lt;/a&gt;&amp;lt;&lt;a href=&quot;../utility/any&quot;&gt;std::any&lt;/a&gt;&amp;gt;&lt;/code&gt;).</source>
          <target state="translated">Назначение не должно быть общей функцией. В частности, если присвоение некоторому объекту &lt;code&gt;x&lt;/code&gt; может привести к изменению другого объекта &lt;code&gt;y&lt;/code&gt; , то &lt;code&gt;x = y&lt;/code&gt; , вероятно, не находится в области &lt;code&gt;=&lt;/code&gt; . Обычно это происходит, если правый операнд прямо или косвенно принадлежит левому операнду (например, с помощью умных указателей на узлы в структуре данных на основе узлов или с чем-то вроде &lt;code&gt;&lt;a href=&quot;../container/vector&quot;&gt;std::vector&lt;/a&gt;&amp;lt;&lt;a href=&quot;../utility/any&quot;&gt;std::any&lt;/a&gt;&amp;gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="39671023c69da7c852abacd292e68eeae860a3fe" translate="yes" xml:space="preserve">
          <source>Assignment operator</source>
          <target state="translated">Назначивающий оператор</target>
        </trans-unit>
        <trans-unit id="aa098245c1ec6b3b4a9cec4ec49f68bc2b3dc905" translate="yes" xml:space="preserve">
          <source>Assignment operators</source>
          <target state="translated">Назначивающие операторы</target>
        </trans-unit>
        <trans-unit id="a8dbab8cdfdf68fc2916694485f688c6d01225f3" translate="yes" xml:space="preserve">
          <source>Assignment operators modify the value of the object.</source>
          <target state="translated">Операторы присваивания изменяют значение объекта.</target>
        </trans-unit>
        <trans-unit id="fcab7b97b0f1e15ee8896c3acff0e0448829e741" translate="yes" xml:space="preserve">
          <source>Assignment through a mutable &lt;code&gt;ForwardIterator&lt;/code&gt; iterator cannot invalidate the iterator (implicit due to &lt;code&gt;reference&lt;/code&gt; defined as a true reference)</source>
          <target state="translated">Назначение через изменяемый итератор &lt;code&gt;ForwardIterator&lt;/code&gt; не может сделать недействительным итератор (неявный из-за &lt;code&gt;reference&lt;/code&gt; определенной как истинная ссылка)</target>
        </trans-unit>
        <trans-unit id="fe44cd73fab188856ba0f6384ea8fafe903edc50" translate="yes" xml:space="preserve">
          <source>Assignment through an output iterator is expected to alternate with incrementing. Double-increment is undefined behavior (C++ standard currently claims that double increment is supported, contrary to the STL documentation; this is &lt;a href=&quot;http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#2035&quot;&gt;LWG #2035&lt;/a&gt;).</source>
          <target state="translated">Ожидается, что назначение через выходной итератор будет чередоваться с увеличением. Двойное приращение - неопределенное поведение (стандарт C ++ в настоящее время утверждает, что двойное приращение поддерживается, в отличие от документации STL; это &lt;a href=&quot;http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#2035&quot;&gt;LWG # 2035&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="553860964fd6a1007a18f254d5618448ceac0701" translate="yes" xml:space="preserve">
          <source>Assignment through the same value of an output iterator happens only once: algorithms on output iterators must be single-pass algorithms.</source>
          <target state="translated">Присвоение через одно и то же значение выходного итератора происходит только один раз:алгоритмы на выходных итераторах должны быть однопроходными.</target>
        </trans-unit>
        <trans-unit id="524653a24d773948c1d7496e501b9fa8b1adbd56" translate="yes" xml:space="preserve">
          <source>Assigns &lt;code&gt;other&lt;/code&gt; to &lt;code&gt;*this&lt;/code&gt;. This defaulted assignment operator performs a shallow copy of the data pointer and the size, i.e., after a call to this function, &lt;code&gt;data() == other.data()&lt;/code&gt; and &lt;code&gt;size() == other.size()&lt;/code&gt;.</source>
          <target state="translated">Назначает &lt;code&gt;other&lt;/code&gt; к &lt;code&gt;*this&lt;/code&gt; . Этот оператор присваивания по умолчанию выполняет поверхностную копию указателя данных и размера, т. &lt;code&gt;data() == other.data()&lt;/code&gt; После вызова этой функции data () == other.data () и &lt;code&gt;size() == other.size()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4f7c009b9e05455f5ee322973dbe74b2cf883cb0" translate="yes" xml:space="preserve">
          <source>Assigns &lt;code&gt;r = d&lt;/code&gt;</source>
          <target state="translated">Назначает &lt;code&gt;r = d&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4aafd41880c29ea871a64084e56a24b9a1dd1f31" translate="yes" xml:space="preserve">
          <source>Assigns a character.</source>
          <target state="translated">Назначает персонажа.</target>
        </trans-unit>
        <trans-unit id="c380382dc946c6b38c72f9000c2fa642f83370ed" translate="yes" xml:space="preserve">
          <source>Assigns a new</source>
          <target state="translated">Назначает нового</target>
        </trans-unit>
        <trans-unit id="148d8d90edaa74304a70db798f7ca1605e9d4d0a" translate="yes" xml:space="preserve">
          <source>Assigns a recursive directory iterator.</source>
          <target state="translated">Назначает итератор рекурсивного каталога.</target>
        </trans-unit>
        <trans-unit id="6bcc16d175c62b0f7d0ca59170841be8738b1f42" translate="yes" xml:space="preserve">
          <source>Assigns a value to the referenced bit.</source>
          <target state="translated">Присваивает значение указанному биту.</target>
        </trans-unit>
        <trans-unit id="70c1ad8e16a29319ca5255591ac175bae3d1f77a" translate="yes" xml:space="preserve">
          <source>Assigns another &lt;code&gt;basic_filebuf&lt;/code&gt; object.</source>
          <target state="translated">Назначает другой объект &lt;code&gt;basic_filebuf&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ac1f7eb83c6013e04d8d08ba10d298a42ccc7668" translate="yes" xml:space="preserve">
          <source>Assigns another stream object.</source>
          <target state="translated">Назначает другой объект потока.</target>
        </trans-unit>
        <trans-unit id="b30f137ee566f8e589d71ba4820344e1b4d0d089" translate="yes" xml:space="preserve">
          <source>Assigns contents to an error condition.</source>
          <target state="translated">Присваивает содержимое состоянию ошибки.</target>
        </trans-unit>
        <trans-unit id="ad0b945b4ffa28d85095693a880450266a0ca151" translate="yes" xml:space="preserve">
          <source>Assigns contents to an error condition. Sets the error code to &lt;code&gt;val&lt;/code&gt; and error category to &lt;code&gt;cat&lt;/code&gt;.</source>
          <target state="translated">Назначает содержимое для условия ошибки. Устанавливает код ошибки &lt;code&gt;val&lt;/code&gt; а категорию ошибок - &lt;code&gt;cat&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ea89ac146cf04142bd2be43a6e0a9c6e6569d6ee" translate="yes" xml:space="preserve">
          <source>Assigns contents to the contained value.</source>
          <target state="translated">Присваивает содержимое содержащемуся значению.</target>
        </trans-unit>
        <trans-unit id="2093eed70685137da5105e2eb98d22672f7415b0" translate="yes" xml:space="preserve">
          <source>Assigns new content to the directory entry object. Sets the path to &lt;code&gt;p&lt;/code&gt; and calls &lt;a href=&quot;refresh&quot;&gt;&lt;code&gt;refresh&lt;/code&gt;&lt;/a&gt; to update the cached attributes. If an error occurs, the values of the cached attributes are unspecified.</source>
          <target state="translated">Назначает новое содержимое объекту записи каталога. Устанавливает путь к &lt;code&gt;p&lt;/code&gt; и вызывает &lt;a href=&quot;refresh&quot;&gt; &lt;code&gt;refresh&lt;/code&gt; &lt;/a&gt; для обновления кэшированных атрибутов. Если возникает ошибка, значения кэшированных атрибутов не указываются.</target>
        </trans-unit>
        <trans-unit id="985e7cc92c5da0b124ac42b6b293ea6ab860d46d" translate="yes" xml:space="preserve">
          <source>Assigns new values to the contents.</source>
          <target state="translated">Присваивает новые значения содержимому.</target>
        </trans-unit>
        <trans-unit id="01f85854d8567649bd63cc3cf8e502d10e76c2fa" translate="yes" xml:space="preserve">
          <source>Assigns the contents of &lt;code&gt;other&lt;/code&gt;.</source>
          <target state="translated">Назначает содержимое &lt;code&gt;other&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="334748da8228ad08ebb5167fc8305cc7025bf9e9" translate="yes" xml:space="preserve">
          <source>Assigns the contents of another &lt;code&gt;shared_future&lt;/code&gt;.</source>
          <target state="translated">Назначает содержимое другого &lt;code&gt;shared_future&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b207364b5a449e23901fdab43b361ab06c868233" translate="yes" xml:space="preserve">
          <source>Assigns the contents of another future object.</source>
          <target state="translated">Назначает содержимое другого будущего объекта.</target>
        </trans-unit>
        <trans-unit id="4f05b82c9cda5c4c83b76872686239121d98d3fc" translate="yes" xml:space="preserve">
          <source>Assigns the contents of one &lt;code&gt;duration&lt;/code&gt; to another.</source>
          <target state="translated">Назначает содержимое одной &lt;code&gt;duration&lt;/code&gt; другой.</target>
        </trans-unit>
        <trans-unit id="e767b59b7ccb0fbb234828fcb4b12aaf2f52a32b" translate="yes" xml:space="preserve">
          <source>Assigns the contents to the regular expression.</source>
          <target state="translated">Присваивает содержимое регулярному выражению.</target>
        </trans-unit>
        <trans-unit id="2dfd90f5b61c413ae9ace2f839434909fb2f18d8" translate="yes" xml:space="preserve">
          <source>Assigns the contents.</source>
          <target state="translated">Назначает содержимое.</target>
        </trans-unit>
        <trans-unit id="19908a094e988df6a7adcb0e6c5d93f456d9ed88" translate="yes" xml:space="preserve">
          <source>Assigns the data members of &lt;code&gt;other&lt;/code&gt; to &lt;code&gt;*this&lt;/code&gt;.</source>
          <target state="translated">Назначают элементы данных &lt;code&gt;other&lt;/code&gt; к &lt;code&gt;*this&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="82e1cf9bdead926f51d186513fb276548517188c" translate="yes" xml:space="preserve">
          <source>Assigns the given value &lt;code&gt;value&lt;/code&gt; to all elements in the container.</source>
          <target state="translated">Назначает данное значение &lt;code&gt;value&lt;/code&gt; всем элементам в контейнере.</target>
        </trans-unit>
        <trans-unit id="86e7899b4fde9882ed3e1a38d15420d9298faf2e" translate="yes" xml:space="preserve">
          <source>Assigns the range represented by &lt;code&gt;il&lt;/code&gt; into &lt;code&gt;a&lt;/code&gt;&lt;sup id=&quot;cite_ref-1&quot;&gt;&lt;a href=&quot;sequencecontainer#cite_note-1&quot;&gt;[1]&lt;/a&gt;&lt;/sup&gt;</source>
          <target state="translated">Назначает диапазона , представленного &lt;code&gt;il&lt;/code&gt; в &lt;code&gt;a&lt;/code&gt; &lt;sup id=&quot;cite_ref-1&quot;&gt;&lt;a href=&quot;sequencecontainer#cite_note-1&quot;&gt;[1]&lt;/a&gt;&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="191520175c260ae79e0f47e5426987b311a602d8" translate="yes" xml:space="preserve">
          <source>Assigns values to all referred elements.</source>
          <target state="translated">Присваивает значения всем переданным элементам.</target>
        </trans-unit>
        <trans-unit id="902cee84cc49e2a403fa00fdfc2ec44cf1457c20" translate="yes" xml:space="preserve">
          <source>Associated types</source>
          <target state="translated">Связанные виды</target>
        </trans-unit>
        <trans-unit id="9ed2fd1fcf10b45d142954b85138750fe63d022c" translate="yes" xml:space="preserve">
          <source>Associated use_count increments are guaranteed to be part of the atomic operation. Associated use_count decrements are sequenced after the atomic operation, but are not required to be part of it, except for the use_count change when overriding &lt;code&gt;expected&lt;/code&gt; in a failed CAS. Any associated deletion and deallocation are sequenced after the atomic update step and are not part of the atomic operation.</source>
          <target state="translated">Связанные приращения use_count гарантированно являются частью атомарной операции. Связанные приращения use_count упорядочиваются после атомарной операции, но не обязательно должны быть ее частью, за исключением изменения use_count при переопределении, &lt;code&gt;expected&lt;/code&gt; в отказавшем CAS. Любое связанное удаление и освобождение упорядочиваются после атомарного обновления и не являются частью атомарной операции.</target>
        </trans-unit>
        <trans-unit id="bad1cb6f24e9b441150943730abacf00652d78d1" translate="yes" xml:space="preserve">
          <source>Associates one or more exception handlers (catch-clauses) with a compound statement.</source>
          <target state="translated">Соотнесение одного или нескольких обработчиков исключений (catch-clauses)с составным заявлением.</target>
        </trans-unit>
        <trans-unit id="e1b7038d16ea26b3ef95375a5ebae12043ab309d" translate="yes" xml:space="preserve">
          <source>Associative containers</source>
          <target state="translated">Ассоциированные контейнеры</target>
        </trans-unit>
        <trans-unit id="622dca44b962cc1f074838d9efdbe8759696a1de" translate="yes" xml:space="preserve">
          <source>Associative containers implement sorted data structures that can be quickly searched (O(log n) complexity).</source>
          <target state="translated">Ассоциированные контейнеры реализуют сортируемые структуры данных,которые можно быстро искать (сложность O(log n)).</target>
        </trans-unit>
        <trans-unit id="1c6a25ab3379bdd54a1512bb45e9d133927a1700" translate="yes" xml:space="preserve">
          <source>Associative containers in the standard library</source>
          <target state="translated">Ассоциированные контейнеры в стандартной библиотеке</target>
        </trans-unit>
        <trans-unit id="f3b3c941634aac79492f857fc539fd4c9d008a56" translate="yes" xml:space="preserve">
          <source>AssociativeContainer</source>
          <target state="translated">AssociativeContainer</target>
        </trans-unit>
        <trans-unit id="d20b5a26a1cdf631954b50a5206246dff93d9c8a" translate="yes" xml:space="preserve">
          <source>Associativity</source>
          <target state="translated">Associativity</target>
        </trans-unit>
        <trans-unit id="b3392e5205fe590e481f972619ef5508947ebdc5" translate="yes" xml:space="preserve">
          <source>Associativity specification is redundant for unary operators and is only shown for completeness: unary prefix operators always associate right-to-left (&lt;code&gt;delete ++*p&lt;/code&gt; is &lt;code&gt;delete(++(*p))&lt;/code&gt;) and unary postfix operators always associate left-to-right (&lt;code&gt;a[1][2]++&lt;/code&gt; is &lt;code&gt;((a[1])[2])++&lt;/code&gt;). Note that the associativity is meaningful for member access operators, even though they are grouped with unary postfix operators: &lt;code&gt;a.b++&lt;/code&gt; is parsed &lt;code&gt;(a.b)++&lt;/code&gt; and not &lt;code&gt;a.(b++)&lt;/code&gt;.</source>
          <target state="translated">Спецификация ассоциативности избыточна для унарных операторов и показана только для полноты: унарные префиксные операторы всегда ассоциируются справа налево ( &lt;code&gt;delete ++*p&lt;/code&gt; - &lt;code&gt;delete(++(*p))&lt;/code&gt; ), а унарные постфиксные операторы всегда ассоциируются слева направо -право ( &lt;code&gt;a[1][2]++&lt;/code&gt; is &lt;code&gt;((a[1])[2])++&lt;/code&gt; ). Обратите внимание, что ассоциативность имеет смысл для операторов доступа к элементам, даже если они сгруппированы с унарными постфиксными операторами: &lt;code&gt;a.b++&lt;/code&gt; анализируется &lt;code&gt;(a.b)++&lt;/code&gt; а не &lt;code&gt;a.(b++)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f6062b342e2d9e9c70ef9a02f2326265c628746c" translate="yes" xml:space="preserve">
          <source>Assuming &lt;code&gt;i&lt;/code&gt; has built-in type or the postincrement operator is not &lt;a href=&quot;operators&quot;&gt;overloaded&lt;/a&gt; to return by lvalue reference.</source>
          <target state="translated">Предполагая, что у &lt;code&gt;i&lt;/code&gt; есть встроенный тип или оператор постинкремента не &lt;a href=&quot;operators&quot;&gt;перегружен&lt;/a&gt; для возврата по ссылке lvalue.</target>
        </trans-unit>
        <trans-unit id="74f381465fb7e488d40ff21e2669ec9bd0efa9fd" translate="yes" xml:space="preserve">
          <source>Assuming &lt;code&gt;i&lt;/code&gt; has built-in type or the pre-increment operator is &lt;a href=&quot;operators&quot;&gt;overloaded&lt;/a&gt; to return by lvalue reference.</source>
          <target state="translated">Предполагая, что у &lt;code&gt;i&lt;/code&gt; есть встроенный тип, или оператор предварительного приращения &lt;a href=&quot;operators&quot;&gt;перегружен&lt;/a&gt; для возврата по ссылке lvalue.</target>
        </trans-unit>
        <trans-unit id="033599246c3928bd9bbc1f63fef180f75f1d6fa6" translate="yes" xml:space="preserve">
          <source>Assuming that &lt;code&gt;CD&lt;/code&gt; is the function return type and &lt;code&gt;CR&amp;lt;A, B&amp;gt; = &lt;a href=&quot;../../types/common_type&quot;&gt;std::common_type&lt;/a&gt;&amp;lt;A, B&amp;gt;::type&lt;/code&gt;, then:</source>
          <target state="translated">Предполагая, что &lt;code&gt;CD&lt;/code&gt; является типом возвращаемого значения функции и &lt;code&gt;CR&amp;lt;A, B&amp;gt; = &lt;a href=&quot;../../types/common_type&quot;&gt;std::common_type&lt;/a&gt;&amp;lt;A, B&amp;gt;::type&lt;/code&gt; , тогда:</target>
        </trans-unit>
        <trans-unit id="f51aeb937353e872aa16e888ad3642d2d51989e0" translate="yes" xml:space="preserve">
          <source>Assuming that &lt;code&gt;CT =&lt;br/&gt; &lt;a href=&quot;../../types/common_type&quot;&gt;std::common_type&lt;/a&gt;&amp;lt;&lt;a href=&quot;../duration&quot;&gt;std::chrono::duration&lt;/a&gt;&amp;lt;Rep1, Period1&amp;gt;,&lt;br/&gt; &lt;a href=&quot;../duration&quot;&gt;std::chrono::duration&lt;/a&gt;&amp;lt;Rep2, Period2&amp;gt;&amp;gt;::type&lt;/code&gt;, then:</source>
          <target state="translated">Предполагая, что &lt;code&gt;CT =&lt;br/&gt; &lt;a href=&quot;../../types/common_type&quot;&gt;std::common_type&lt;/a&gt;&amp;lt;&lt;a href=&quot;../duration&quot;&gt;std::chrono::duration&lt;/a&gt;&amp;lt;Rep1, Period1&amp;gt;,&lt;br/&gt; &lt;a href=&quot;../duration&quot;&gt;std::chrono::duration&lt;/a&gt;&amp;lt;Rep2, Period2&amp;gt;&amp;gt;::type&lt;/code&gt; CT = &lt;br/&gt; std :: common_type &amp;lt; &lt;a href=&quot;../duration&quot;&gt;std :: chrono :: duration&lt;/a&gt; &amp;lt;Rep1, Period1&amp;gt;, &lt;br/&gt; &lt;a href=&quot;../duration&quot;&gt;std :: chrono :: duration&lt;/a&gt; &amp;lt;Rep2, Period2 &amp;gt;&amp;gt; :: type , тогда:</target>
        </trans-unit>
        <trans-unit id="16dad30e22d9f8f0b187b91674cdf99f5bfa4cfb" translate="yes" xml:space="preserve">
          <source>Assuming that alignment requirements are met, a &lt;code&gt;reinterpret_cast&lt;/code&gt; does not change the &lt;a href=&quot;pointer#Pointers&quot;&gt;value of a pointer&lt;/a&gt; outside of a few limited cases dealing with &lt;a href=&quot;static_cast#pointer-interconvertible&quot;&gt;&lt;i&gt;pointer-interconvertible&lt;/i&gt;&lt;/a&gt; objects:</source>
          <target state="translated">Предполагая, что требования выравнивания выполнены, &lt;code&gt;reinterpret_cast&lt;/code&gt; не изменяет &lt;a href=&quot;pointer#Pointers&quot;&gt;значение указателя&lt;/a&gt; за пределами нескольких ограниченных случаев, имеющих дело с объектами, &lt;a href=&quot;static_cast#pointer-interconvertible&quot;&gt;&lt;i&gt;взаимозаменяемыми&lt;/i&gt;&lt;/a&gt; с &lt;i&gt;указателем&lt;/i&gt; :</target>
        </trans-unit>
        <trans-unit id="eaa51d32fe12f955eec03f2bc4bdb2751f3da027" translate="yes" xml:space="preserve">
          <source>At first, a local variable of type &lt;code&gt;BidirIt&lt;/code&gt; is constructed with the value of &lt;code&gt;match[0].second&lt;/code&gt;.</source>
          <target state="translated">Сначала создается локальная переменная типа &lt;code&gt;BidirIt&lt;/code&gt; со значением &lt;code&gt;match[0].second&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a9ec839d7fa04addb5ce25ff54e78bc29c079bf1" translate="yes" xml:space="preserve">
          <source>At least one major implementation does not implement these rules and instead optimizes out the store to &lt;code&gt;n&lt;/code&gt;. The lifetime rules are under reconsideration as &lt;a href=&quot;https://wg21.link/CWG2256&quot;&gt;core issue 2256&lt;/a&gt;.</source>
          <target state="translated">По крайней мере, одна крупная реализация не реализует эти правила и вместо этого оптимизирует хранилище для &lt;code&gt;n&lt;/code&gt; . Правила жизни пересматриваются как &lt;a href=&quot;https://wg21.link/CWG2256&quot;&gt;основной вопрос 2256&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5357281e6d1ead597f87156333dc4e4a2d371458" translate="yes" xml:space="preserve">
          <source>At least one of &lt;code&gt;T1&lt;/code&gt; and &lt;code&gt;T2&lt;/code&gt; depends on a user-defined type, and</source>
          <target state="translated">По крайней мере один из &lt;code&gt;T1&lt;/code&gt; и &lt;code&gt;T2&lt;/code&gt; зависит от определенного пользователем типа, и</target>
        </trans-unit>
        <trans-unit id="b7ff6c8662e2b7c4ac75ca0560a6904f05eb0097" translate="yes" xml:space="preserve">
          <source>At most</source>
          <target state="translated">Максимум</target>
        </trans-unit>
        <trans-unit id="a065be791d5f07e9b9b28e1a3ee4de5830efc2d5" translate="yes" xml:space="preserve">
          <source>At most 2&amp;middot;(N&lt;sub&gt;1&lt;/sub&gt;+N&lt;sub&gt;2&lt;/sub&gt;-1) comparisons, where N&lt;sub&gt;1&lt;/sub&gt;&lt;code&gt;= &lt;a href=&quot;../iterator/distance&quot;&gt;std::distance&lt;/a&gt;(first1, last1)&lt;/code&gt; and N&lt;sub&gt;2&lt;/sub&gt;&lt;code&gt;= &lt;a href=&quot;../iterator/distance&quot;&gt;std::distance&lt;/a&gt;(first2, last2)&lt;/code&gt;.</source>
          <target state="translated">Не более 2 &amp;middot; (N &lt;sub&gt;1&lt;/sub&gt; + N &lt;sub&gt;2&lt;/sub&gt; -1) сравнений, где N &lt;sub&gt;1 &lt;/sub&gt; &lt;code&gt;= &lt;a href=&quot;../iterator/distance&quot;&gt;std::distance&lt;/a&gt;(first1, last1)&lt;/code&gt; и N &lt;sub&gt;2 &lt;/sub&gt; &lt;code&gt;= &lt;a href=&quot;../iterator/distance&quot;&gt;std::distance&lt;/a&gt;(first2, last2)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f417027ea40c23a98d041983aee663fe84c4fd8a" translate="yes" xml:space="preserve">
          <source>At most 2&amp;middot;min(N1, N2) applications of the comparison operation, where &lt;code&gt;N1 = &lt;a href=&quot;../iterator/distance&quot;&gt;std::distance&lt;/a&gt;(first1, last1)&lt;/code&gt; and &lt;code&gt;N2 = &lt;a href=&quot;../iterator/distance&quot;&gt;std::distance&lt;/a&gt;(first2, last2)&lt;/code&gt;.</source>
          <target state="translated">Не более 2 &amp;middot; мин (N1, N2) приложений операции сравнения, где &lt;code&gt;N1 = &lt;a href=&quot;../iterator/distance&quot;&gt;std::distance&lt;/a&gt;(first1, last1)&lt;/code&gt; и &lt;code&gt;N2 = &lt;a href=&quot;../iterator/distance&quot;&gt;std::distance&lt;/a&gt;(first2, last2)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="82ec885967ce3dacad15402cd2d8eb2b10af93f5" translate="yes" xml:space="preserve">
          <source>At most &lt;code&gt;(last-first)/2&lt;/code&gt; swaps. Averaged over the entire sequence of permutations, typical implementations use about 3 comparisons and 1.5 swaps per call.</source>
          <target state="translated">Максимум &lt;code&gt;(last-first)/2&lt;/code&gt; свопа. Усредненные по всей последовательности перестановок, типичные реализации используют около 3 сравнений и 1,5 перестановок на вызов.</target>
        </trans-unit>
        <trans-unit id="ddecdfce8186bf2f225c5a792633c5ddf7b502c1" translate="yes" xml:space="preserve">
          <source>At most &lt;code&gt;3*&lt;a href=&quot;../iterator/distance&quot;&gt;std::distance&lt;/a&gt;(first, last)&lt;/code&gt; comparisons.</source>
          <target state="translated">Не более &lt;code&gt;3*&lt;a href=&quot;../iterator/distance&quot;&gt;std::distance&lt;/a&gt;(first, last)&lt;/code&gt; сравнений.</target>
        </trans-unit>
        <trans-unit id="37142ec0061a83658ba826e1c1afead3f11e0ec2" translate="yes" xml:space="preserve">
          <source>At most &lt;code&gt;d_last - d_first&lt;/code&gt; of the elements are placed sorted to the range &lt;code&gt;[d_first, d_first + n)&lt;/code&gt;. &lt;code&gt;n&lt;/code&gt; is the number of elements to sort (&lt;code&gt;n = min(last - first, d_last - d_first)&lt;/code&gt;). The order of equal elements is not guaranteed to be preserved.</source>
          <target state="translated">В большинстве &lt;code&gt;d_last - d_first&lt;/code&gt; из элементов размещены сортируются в диапазоне &lt;code&gt;[d_first, d_first + n)&lt;/code&gt; . &lt;code&gt;n&lt;/code&gt; - количество элементов для сортировки ( &lt;code&gt;n = min(last - first, d_last - d_first)&lt;/code&gt; ). Порядок равных элементов не гарантируется для сохранения.</target>
        </trans-unit>
        <trans-unit id="d2675fe7d12495f05dcdb52627fa675c17129e6a" translate="yes" xml:space="preserve">
          <source>At most &lt;code&gt;last - first&lt;/code&gt; applications of the predicate and the projection.</source>
          <target state="translated">Самое &lt;code&gt;last - first&lt;/code&gt; применения предиката и проекции.</target>
        </trans-unit>
        <trans-unit id="29eb338ad07d90987b424a3ee5360988d67741cd" translate="yes" xml:space="preserve">
          <source>At most &lt;code&gt;last - first&lt;/code&gt; applications of the predicate.</source>
          <target state="translated">Самое &lt;code&gt;last - first&lt;/code&gt; применения предиката.</target>
        </trans-unit>
        <trans-unit id="c36a9685749cdd93b9b788e8f13203a1e8dd5a28" translate="yes" xml:space="preserve">
          <source>At most &lt;code&gt;last&lt;/code&gt; - &lt;code&gt;first&lt;/code&gt; applications of the predicate.</source>
          <target state="translated">Самое &lt;code&gt;last&lt;/code&gt; - &lt;code&gt;first&lt;/code&gt; применения предиката.</target>
        </trans-unit>
        <trans-unit id="835c572fed24e005461e8303ab401feae3c77b72" translate="yes" xml:space="preserve">
          <source>At most &lt;code&gt;std::distance(first, last)&lt;/code&gt; applications of &lt;code&gt;p&lt;/code&gt;.</source>
          <target state="translated">В большинстве &lt;code&gt;std::distance(first, last)&lt;/code&gt; применения &lt;code&gt;p&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="28b847c1c9ad7813c6cd6afbca6893f3a89d3246" translate="yes" xml:space="preserve">
          <source>At most N/2 swaps, where &lt;code&gt;N = &lt;a href=&quot;../iterator/distance&quot;&gt;std::distance&lt;/a&gt;(first, last)&lt;/code&gt;. Averaged over the entire sequence of permutations, typical implementations use about 3 comparisons and 1.5 swaps per call.</source>
          <target state="translated">Не более N / 2 свопов, где &lt;code&gt;N = &lt;a href=&quot;../iterator/distance&quot;&gt;std::distance&lt;/a&gt;(first, last)&lt;/code&gt; . Усредненные по всей последовательности перестановок, типичные реализации используют около 3 сравнений и 1,5 перестановок на вызов.</target>
        </trans-unit>
        <trans-unit id="87d08107753bb0853d26d589fe4f49b4791d7a3c" translate="yes" xml:space="preserve">
          <source>At most O(N&lt;sup&gt;2&lt;/sup&gt;) applications of the predicate, or exactly N if the sequences are already equal, where &lt;code&gt;N=&lt;a href=&quot;../iterator/distance&quot;&gt;std::distance&lt;/a&gt;(first1, last1)&lt;/code&gt;.</source>
          <target state="translated">Не более O (N &lt;sup&gt;2&lt;/sup&gt; ) применений предиката или ровно N, если последовательности уже равны, где &lt;code&gt;N=&lt;a href=&quot;../iterator/distance&quot;&gt;std::distance&lt;/a&gt;(first1, last1)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7e9957d5de91d4b7c6c68d594aa3aa480005b9e3" translate="yes" xml:space="preserve">
          <source>At most linear in the &lt;code&gt;&lt;a href=&quot;size&quot;&gt;size()&lt;/a&gt;&lt;/code&gt; of the container.</source>
          <target state="translated">Максимально линейно по &lt;code&gt;&lt;a href=&quot;size&quot;&gt;size()&lt;/a&gt;&lt;/code&gt; контейнера.</target>
        </trans-unit>
        <trans-unit id="7b67cf2f323c75240ad28ea0936fabdb2eb7dfd2" translate="yes" xml:space="preserve">
          <source>At most linear in the &lt;code&gt;&lt;a href=&quot;size&quot;&gt;size()&lt;/a&gt;&lt;/code&gt; of the string.</source>
          <target state="translated">Максимально линейно по &lt;code&gt;&lt;a href=&quot;size&quot;&gt;size()&lt;/a&gt;&lt;/code&gt; строки.</target>
        </trans-unit>
        <trans-unit id="1f95351bbc9191f119c0c979d668c0b60be5e7b1" translate="yes" xml:space="preserve">
          <source>At most linear in the size of the container.</source>
          <target state="translated">Максимально линейный по размеру контейнер.</target>
        </trans-unit>
        <trans-unit id="a42136bb0320d6ac91f01ed89b5ec95ea11cd801" translate="yes" xml:space="preserve">
          <source>At most max(floor((3/2)*(N&amp;minus;1)), 0) applications of the predicate, where &lt;code&gt;N = &lt;a href=&quot;../iterator/distance&quot;&gt;std::distance&lt;/a&gt;(first, last)&lt;/code&gt;.</source>
          <target state="translated">Максимум max (floor ((3/2) * (N &amp;minus; 1)), 0) применения предиката, где &lt;code&gt;N = &lt;a href=&quot;../iterator/distance&quot;&gt;std::distance&lt;/a&gt;(first, last)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1d7bca3c1a2d078e776e71dcbe99b35a321e5167" translate="yes" xml:space="preserve">
          <source>At most one &lt;a href=&quot;union#Union-like_classes&quot;&gt;variant member&lt;/a&gt; can have a &lt;a href=&quot;data_members#Member_initialization&quot;&gt;default member initializer&lt;/a&gt;.</source>
          <target state="translated">Не более одного &lt;a href=&quot;union#Union-like_classes&quot;&gt;варианта элемента&lt;/a&gt; может иметь &lt;a href=&quot;data_members#Member_initialization&quot;&gt;инициализатор элемента по умолчанию&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6c1f6896df7e191deb062d81024e89c21817f2db" translate="yes" xml:space="preserve">
          <source>At most one copy option in each of the following options groups may be present, otherwise the behavior of the copy functions is undefined.</source>
          <target state="translated">Максимум один вариант копирования в каждой из следующих групп опций может присутствовать,в противном случае поведение функций копирования не определено.</target>
        </trans-unit>
        <trans-unit id="4d4b41d6c4f9d31917e8132872ca199c890aa525" translate="yes" xml:space="preserve">
          <source>At most one grammar option must be chosen out of &lt;code&gt;ECMAScript&lt;/code&gt;, &lt;code&gt;basic&lt;/code&gt;, &lt;code&gt;extended&lt;/code&gt;, &lt;code&gt;awk&lt;/code&gt;, &lt;code&gt;grep&lt;/code&gt;, &lt;code&gt;egrep&lt;/code&gt;. If no grammar is chosen, &lt;code&gt;ECMAScript&lt;/code&gt; is assumed to be selected. The other options serve as modifiers, such that &lt;code&gt;&lt;a href=&quot;../basic_regex&quot;&gt;std::regex&lt;/a&gt;(&quot;meow&quot;, std::regex::icase)&lt;/code&gt; is equivalent to &lt;code&gt;&lt;a href=&quot;../basic_regex&quot;&gt;std::regex&lt;/a&gt;(&quot;meow&quot;, std::regex::ECMAScript|std::regex::icase)&lt;/code&gt;.</source>
          <target state="translated">Максимум один вариант грамматики должен быть выбран из &lt;code&gt;ECMAScript&lt;/code&gt; , &lt;code&gt;basic&lt;/code&gt; , &lt;code&gt;extended&lt;/code&gt; , &lt;code&gt;awk&lt;/code&gt; , &lt;code&gt;grep&lt;/code&gt; , &lt;code&gt;egrep&lt;/code&gt; . Если грамматика не выбрана, предполагается , что &lt;code&gt;ECMAScript&lt;/code&gt; будет выбран. Другие параметры служат модификаторами, так что &lt;code&gt;&lt;a href=&quot;../basic_regex&quot;&gt;std::regex&lt;/a&gt;(&quot;meow&quot;, std::regex::icase)&lt;/code&gt; эквивалентен &lt;code&gt;&lt;a href=&quot;../basic_regex&quot;&gt;std::regex&lt;/a&gt;(&quot;meow&quot;, std::regex::ECMAScript|std::regex::icase)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4664e42aaeebe95a9d1a078a45a775bf60943bc7" translate="yes" xml:space="preserve">
          <source>At most one grammar option must be chosen out of &lt;code&gt;ECMAScript&lt;/code&gt;, &lt;code&gt;basic&lt;/code&gt;, &lt;code&gt;extended&lt;/code&gt;, &lt;code&gt;awk&lt;/code&gt;, &lt;code&gt;grep&lt;/code&gt;, &lt;code&gt;egrep&lt;/code&gt;. If no grammar is chosen, &lt;code&gt;ECMAScript&lt;/code&gt; is assumed to be selected. The other options serve as modifiers, such that &lt;code&gt;&lt;a href=&quot;basic_regex&quot;&gt;std::regex&lt;/a&gt;(&quot;meow&quot;, std::regex::icase)&lt;/code&gt; is equivalent to &lt;code&gt;&lt;a href=&quot;basic_regex&quot;&gt;std::regex&lt;/a&gt;(&quot;meow&quot;, std::regex::ECMAScript|std::regex::icase)&lt;/code&gt;.</source>
          <target state="translated">Максимум один вариант грамматики должен быть выбран из &lt;code&gt;ECMAScript&lt;/code&gt; , &lt;code&gt;basic&lt;/code&gt; , &lt;code&gt;extended&lt;/code&gt; , &lt;code&gt;awk&lt;/code&gt; , &lt;code&gt;grep&lt;/code&gt; , &lt;code&gt;egrep&lt;/code&gt; . Если грамматика не выбрана, предполагается , что &lt;code&gt;ECMAScript&lt;/code&gt; будет выбран. Другие параметры служат модификаторами, так что &lt;code&gt;&lt;a href=&quot;basic_regex&quot;&gt;std::regex&lt;/a&gt;(&quot;meow&quot;, std::regex::icase)&lt;/code&gt; эквивалентен &lt;code&gt;&lt;a href=&quot;basic_regex&quot;&gt;std::regex&lt;/a&gt;(&quot;meow&quot;, std::regex::ECMAScript|std::regex::icase)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5e31fa82af84a5c287a47f543cebf5aedf134031" translate="yes" xml:space="preserve">
          <source>At most one grammar option must be chosen out of &lt;code&gt;ECMAScript&lt;/code&gt;, &lt;code&gt;basic&lt;/code&gt;, &lt;code&gt;extended&lt;/code&gt;, &lt;code&gt;awk&lt;/code&gt;, &lt;code&gt;grep&lt;/code&gt;, &lt;code&gt;egrep&lt;/code&gt;. If no grammar is chosen, &lt;code&gt;ECMAScript&lt;/code&gt; is assumed to be selected. The other options serve as modifiers, such that &lt;code&gt;std::regex(&quot;meow&quot;, std::regex::icase)&lt;/code&gt; is equivalent to &lt;code&gt;std::regex(&quot;meow&quot;, std::regex::ECMAScript|std::regex::icase)&lt;/code&gt;.</source>
          <target state="translated">Максимум один вариант грамматики должен быть выбран из &lt;code&gt;ECMAScript&lt;/code&gt; , &lt;code&gt;basic&lt;/code&gt; , &lt;code&gt;extended&lt;/code&gt; , &lt;code&gt;awk&lt;/code&gt; , &lt;code&gt;grep&lt;/code&gt; , &lt;code&gt;egrep&lt;/code&gt; . Если грамматика не выбрана, предполагается , что &lt;code&gt;ECMAScript&lt;/code&gt; будет выбран. Другие параметры служат модификаторами, так что &lt;code&gt;std::regex(&quot;meow&quot;, std::regex::icase)&lt;/code&gt; эквивалентен &lt;code&gt;std::regex(&quot;meow&quot;, std::regex::ECMAScript|std::regex::icase)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="311d67e063c452f5ead23f742890b672f660636b" translate="yes" xml:space="preserve">
          <source>At most one of &lt;code&gt;add&lt;/code&gt;, &lt;code&gt;remove&lt;/code&gt;, &lt;code&gt;replace&lt;/code&gt; may be present, otherwise the behavior of the permissions function is undefined.</source>
          <target state="translated">Может присутствовать самое большее одно из: &lt;code&gt;add&lt;/code&gt; , &lt;code&gt;remove&lt;/code&gt; , &lt;code&gt;replace&lt;/code&gt; , в противном случае поведение функции разрешений не определено.</target>
        </trans-unit>
        <trans-unit id="2395ecfd633261d1a9cd5400cd07b765cc2f7a58" translate="yes" xml:space="preserve">
          <source>At most two comparisons.</source>
          <target state="translated">Максимум два сравнения.</target>
        </trans-unit>
        <trans-unit id="5c3f1418c87059f4cdb7e84bd90cc9bbf999a3c8" translate="yes" xml:space="preserve">
          <source>At or after modified element(s)</source>
          <target state="translated">На или после модифицированного элемента (элементов)</target>
        </trans-unit>
        <trans-unit id="b99b53e1b81171c73a473d86eb4eba8e01df0ac3" translate="yes" xml:space="preserve">
          <source>At program startup,</source>
          <target state="translated">При запуске программы,</target>
        </trans-unit>
        <trans-unit id="bc78dcde97d0faac3fa0ab3c4057950ede8cc9fd" translate="yes" xml:space="preserve">
          <source>At the point in the code the operator() is called, the type must be complete. In some implementations a &lt;code&gt;static_assert&lt;/code&gt; is used to make sure this is the case. The reason for this requirement is that calling &lt;a href=&quot;../language/delete&quot;&gt;delete&lt;/a&gt; on an incomplete type is undefined behavior in C++ if the complete class type has a nontrivial destructor or a deallocation function, as the compiler has no way of knowing whether such functions exist and must be invoked.</source>
          <target state="translated">В точке кода вызывается оператор (), тип должен быть полным. В некоторых реализациях &lt;code&gt;static_assert&lt;/code&gt; используется, чтобы убедиться, что это так. Причина этого требования заключается в том, что вызов &lt;a href=&quot;../language/delete&quot;&gt;delete&lt;/a&gt; для неполного типа является неопределенным поведением в C ++, если полный тип класса имеет нетривиальный деструктор или функцию освобождения, поскольку компилятор не может знать, существуют ли такие функции и должен ли быть вызван.</target>
        </trans-unit>
        <trans-unit id="e34285cac72686e9e93e2ea071243a4d166878b4" translate="yes" xml:space="preserve">
          <source>Atomic Operations library</source>
          <target state="translated">Библиотека атомных операций</target>
        </trans-unit>
        <trans-unit id="8c9d8d00b5cb702da9e8a277758916eb4dd3cc1c" translate="yes" xml:space="preserve">
          <source>Atomic and synchronized blocks</source>
          <target state="translated">Атомные и синхронизированные блоки</target>
        </trans-unit>
        <trans-unit id="6816e21f31c82f13f142f06d907125e6d3ac7b98" translate="yes" xml:space="preserve">
          <source>Atomic and synchronized blocks are used to implement &lt;a href=&quot;transactional_memory&quot;&gt;transactional memory&lt;/a&gt;.</source>
          <target state="translated">Атомарные и синхронизированные блоки используются для реализации &lt;a href=&quot;transactional_memory&quot;&gt;транзакционной памяти&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="82b6893aff5aea02a2292327874493a700ee80ae" translate="yes" xml:space="preserve">
          <source>Atomic blocks</source>
          <target state="translated">Атомные блоки</target>
        </trans-unit>
        <trans-unit id="17b2c09204bb130f11f065ef3080da8ab1f767cb" translate="yes" xml:space="preserve">
          <source>Atomic constraints</source>
          <target state="translated">Атомные ограничения</target>
        </trans-unit>
        <trans-unit id="401a31bc657222e6c53d68e589a5e6bc2cfed3b4" translate="yes" xml:space="preserve">
          <source>Atomic constraints are formed during &lt;a href=&quot;constraints#Constraint_normalization&quot;&gt;constraint normalization&lt;/a&gt;. &lt;code&gt;E&lt;/code&gt; is never a logical AND or logical OR expression (those form conjunctions and disjunctions, respectively).</source>
          <target state="translated">Атомные ограничения формируются во время &lt;a href=&quot;constraints#Constraint_normalization&quot;&gt;нормализации ограничений&lt;/a&gt; . &lt;code&gt;E&lt;/code&gt; никогда не является логическим И или логическим выражением ИЛИ (они образуют соединения и дизъюнкции соответственно).</target>
        </trans-unit>
        <trans-unit id="ab3668521ac1e65f2c9a3ca3cc545235dc9f88c8" translate="yes" xml:space="preserve">
          <source>Atomic load with &lt;code&gt;memory_order_acquire&lt;/code&gt; or stronger is an acquire operation. The lock() operation on a &lt;a href=&quot;../named_req/mutex&quot;&gt;Mutex&lt;/a&gt; is also an acquire operation. Note that &lt;code&gt;&lt;a href=&quot;atomic_thread_fence&quot;&gt;std::atomic_thread_fence&lt;/a&gt;&lt;/code&gt; imposes stronger synchronization requirements than an acquire operation.</source>
          <target state="translated">Атомная загрузка с &lt;code&gt;memory_order_acquire&lt;/code&gt; или более сильной является операцией получения. Операция lock () на &lt;a href=&quot;../named_req/mutex&quot;&gt;Mutex&lt;/a&gt; также является операцией получения. Обратите внимание, что &lt;code&gt;&lt;a href=&quot;atomic_thread_fence&quot;&gt;std::atomic_thread_fence&lt;/a&gt;&lt;/code&gt; накладывает более строгие требования к синхронизации, чем операция получения.</target>
        </trans-unit>
        <trans-unit id="783585c8300c9cdf7a66c42d7b14307cfec6d73d" translate="yes" xml:space="preserve">
          <source>Atomic load with &lt;code&gt;memory_order_consume&lt;/code&gt; or stronger is a consume operation. Note that &lt;code&gt;&lt;a href=&quot;atomic_thread_fence&quot;&gt;std::atomic_thread_fence&lt;/a&gt;&lt;/code&gt; imposes stronger synchronization requirements than a consume operation.</source>
          <target state="translated">Атомная загрузка с &lt;code&gt;memory_order_consume&lt;/code&gt; или более сильной является операцией потребления. Обратите внимание, что &lt;code&gt;&lt;a href=&quot;atomic_thread_fence&quot;&gt;std::atomic_thread_fence&lt;/a&gt;&lt;/code&gt; накладывает более строгие требования к синхронизации, чем операция потребления.</target>
        </trans-unit>
        <trans-unit id="fb34ad6782840b3609292d56d50524837de11852" translate="yes" xml:space="preserve">
          <source>Atomic operations</source>
          <target state="translated">Атомные операции</target>
        </trans-unit>
        <trans-unit id="99d4cd5536d79615f44163fe8a9526d16ce5bfca" translate="yes" xml:space="preserve">
          <source>Atomic operations applied to an object through an &lt;code&gt;atomic_ref&lt;/code&gt; are atomic with respect to atomic operations applied through any other &lt;code&gt;atomic_ref&lt;/code&gt; referencing the same object.</source>
          <target state="translated">Атомарные операции, применяемые к объекту через &lt;code&gt;atomic_ref&lt;/code&gt; , являются атомарными по отношению к атомарным операциям, применяемым через любой другой &lt;code&gt;atomic_ref&lt;/code&gt; , ссылающийся на тот же объект.</target>
        </trans-unit>
        <trans-unit id="ec45a74e461d6d1f9a6d6860119c9137a6fed5b2" translate="yes" xml:space="preserve">
          <source>Atomic operations library</source>
          <target state="translated">Библиотека атомных операций</target>
        </trans-unit>
        <trans-unit id="ac1cfc02a52dba8b178a48b4597760d28fb77ccd" translate="yes" xml:space="preserve">
          <source>Atomic operations tagged &lt;code&gt;memory_order_relaxed&lt;/code&gt; are not synchronization operations; they do not impose an order among concurrent memory accesses. They only guarantee atomicity and modification order consistency.</source>
          <target state="translated">Атомарные операции, помеченные &lt;code&gt;memory_order_relaxed&lt;/code&gt; , не являются операциями синхронизации; они не навязывают порядок между одновременными обращениями к памяти. Они только гарантируют атомарность и согласованность порядка модификации.</target>
        </trans-unit>
        <trans-unit id="4f6d4f2c68a571824e3f43d98c75cbda9d541c52" translate="yes" xml:space="preserve">
          <source>Atomic operations tagged &lt;code&gt;memory_order_seq_cst&lt;/code&gt; not only order memory the same way as release/acquire ordering (everything that</source>
          <target state="translated">Атомарные операции, помеченные &lt;code&gt;memory_order_seq_cst&lt;/code&gt; , не только упорядочивают память так же, как упорядочение освобождения / получения (все, что</target>
        </trans-unit>
        <trans-unit id="72d4efbfff4cc7a737493b1c1c5054ea34242989" translate="yes" xml:space="preserve">
          <source>Atomic store with &lt;code&gt;memory_order_release&lt;/code&gt; or stronger is a release operation. The unlock() operation on a &lt;a href=&quot;../named_req/mutex&quot;&gt;Mutex&lt;/a&gt; is also a release operation. Note that &lt;code&gt;&lt;a href=&quot;atomic_thread_fence&quot;&gt;std::atomic_thread_fence&lt;/a&gt;&lt;/code&gt; imposes stronger synchronization requirements than a release operation.</source>
          <target state="translated">Атомное хранилище с &lt;code&gt;memory_order_release&lt;/code&gt; или более сильной является операцией освобождения. Операция unlock () на &lt;a href=&quot;../named_req/mutex&quot;&gt;Mutex&lt;/a&gt; также является операцией освобождения. Обратите внимание, что &lt;code&gt;&lt;a href=&quot;atomic_thread_fence&quot;&gt;std::atomic_thread_fence&lt;/a&gt;&lt;/code&gt; накладывает более строгие требования к синхронизации, чем операция освобождения.</target>
        </trans-unit>
        <trans-unit id="6bd53298c2672a3d3501c1b3d668970f3f55e051" translate="yes" xml:space="preserve">
          <source>Atomic types</source>
          <target state="translated">Атомные типы</target>
        </trans-unit>
        <trans-unit id="90945bda736ccd52d67480431115772e6ed72f07" translate="yes" xml:space="preserve">
          <source>Atomic-fence synchronization</source>
          <target state="translated">Атомно-заборная синхронизация</target>
        </trans-unit>
        <trans-unit id="5d6ac2f41530550ee308dc296f9a8b617587365b" translate="yes" xml:space="preserve">
          <source>Atomically changes the state of a &lt;code&gt;&lt;a href=&quot;../atomic_flag&quot;&gt;std::atomic_flag&lt;/a&gt;&lt;/code&gt; to clear (&lt;code&gt;false&lt;/code&gt;).</source>
          <target state="translated">Атомно изменяет состояние &lt;code&gt;&lt;a href=&quot;../atomic_flag&quot;&gt;std::atomic_flag&lt;/a&gt;&lt;/code&gt; чтобы очистить ( &lt;code&gt;false&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="29366d9f87188ae24c9efa9144aa990ffcfc84da" translate="yes" xml:space="preserve">
          <source>Atomically changes the state of a &lt;code&gt;&lt;a href=&quot;../atomic_flag&quot;&gt;std::atomic_flag&lt;/a&gt;&lt;/code&gt; to set (&lt;code&gt;true&lt;/code&gt;) and returns the value it held before.</source>
          <target state="translated">Атомно изменяет состояние &lt;code&gt;&lt;a href=&quot;../atomic_flag&quot;&gt;std::atomic_flag&lt;/a&gt;&lt;/code&gt; на set ( &lt;code&gt;true&lt;/code&gt; ) и возвращает значение, которое оно содержало ранее.</target>
        </trans-unit>
        <trans-unit id="1ad9c0fc62bc1537d54b4759ea20c55784c16070" translate="yes" xml:space="preserve">
          <source>Atomically changes the state of a &lt;code&gt;&lt;a href=&quot;atomic_flag&quot;&gt;std::atomic_flag&lt;/a&gt;&lt;/code&gt; pointed to by &lt;code&gt;p&lt;/code&gt; to clear (&lt;code&gt;false&lt;/code&gt;).</source>
          <target state="translated">Атомно изменяет состояние &lt;code&gt;&lt;a href=&quot;atomic_flag&quot;&gt;std::atomic_flag&lt;/a&gt;&lt;/code&gt; указывает &lt;code&gt;p&lt;/code&gt; , чтобы очистить ( &lt;code&gt;false&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="75a7c684721b08be0f1216c929374cec16cea043" translate="yes" xml:space="preserve">
          <source>Atomically changes the state of a &lt;code&gt;&lt;a href=&quot;atomic_flag&quot;&gt;std::atomic_flag&lt;/a&gt;&lt;/code&gt; pointed to by &lt;code&gt;p&lt;/code&gt; to set (&lt;code&gt;true&lt;/code&gt;) and returns the value it held before.</source>
          <target state="translated">Атомно изменяет состояние &lt;code&gt;&lt;a href=&quot;atomic_flag&quot;&gt;std::atomic_flag&lt;/a&gt;&lt;/code&gt; указывает &lt;code&gt;p&lt;/code&gt; , чтобы установить ( &lt;code&gt;true&lt;/code&gt; ), и возвращает значение, которое он содержал ранее.</target>
        </trans-unit>
        <trans-unit id="2222bc337f08cf3ae8d66cc236b81d457d5ceac1" translate="yes" xml:space="preserve">
          <source>Atomically compares the &lt;a href=&quot;../../language/objects&quot;&gt;object representation&lt;/a&gt;(until C++20)&lt;a href=&quot;../../language/objects&quot;&gt;value representation&lt;/a&gt;(since C++20) of &lt;code&gt;*this&lt;/code&gt; with that of &lt;code&gt;expected&lt;/code&gt;, and if those are bitwise-equal, replaces the former with &lt;code&gt;desired&lt;/code&gt; (performs read-modify-write operation). Otherwise, loads the actual value stored in &lt;code&gt;*this&lt;/code&gt; into &lt;code&gt;expected&lt;/code&gt; (performs load operation).</source>
          <target state="translated">Атомарно сравнивает &lt;a href=&quot;../../language/objects&quot;&gt;представление объекта&lt;/a&gt; (до 20 ++ , C) &lt;a href=&quot;../../language/objects&quot;&gt;представления значений&lt;/a&gt; (так как C ++ 20) &lt;code&gt;*this&lt;/code&gt; с тем из &lt;code&gt;expected&lt;/code&gt; , и , если таковые побитовое равны, заменяет прежний с &lt;code&gt;desired&lt;/code&gt; (выполняет чтение-модификация-запись операции ). В противном случае загружает фактическое значение, сохраненное в &lt;code&gt;*this&lt;/code&gt; , в &lt;code&gt;expected&lt;/code&gt; (выполняет операцию загрузки).</target>
        </trans-unit>
        <trans-unit id="7b40ae57bd4976e100c4d9ee74cf8c6179fd8839" translate="yes" xml:space="preserve">
          <source>Atomically compares the &lt;a href=&quot;../../language/objects&quot;&gt;value representation&lt;/a&gt; of the referenced object with that of &lt;code&gt;expected&lt;/code&gt;, and if those are bitwise-equal, replaces the former with &lt;code&gt;desired&lt;/code&gt; (performs a read-modify-write operation). Otherwise, loads the actual value stored in the referenced object into &lt;code&gt;expected&lt;/code&gt; (performs a load operation).</source>
          <target state="translated">Атомно сравнивает &lt;a href=&quot;../../language/objects&quot;&gt;представление&lt;/a&gt; значения ссылочного объекта с &lt;code&gt;expected&lt;/code&gt; , и, если они равны по битам, заменяет первое на &lt;code&gt;desired&lt;/code&gt; (выполняет операцию чтения-изменения-записи). В противном случае загружает фактическое значение, сохраненное в ссылочном объекте, в &lt;code&gt;expected&lt;/code&gt; (выполняет операцию загрузки).</target>
        </trans-unit>
        <trans-unit id="aeaea937abc0bf67a8421b823386eae91292163e" translate="yes" xml:space="preserve">
          <source>Atomically compares the &lt;a href=&quot;../language/objects&quot;&gt;object representation&lt;/a&gt;(until C++20)&lt;a href=&quot;../language/objects&quot;&gt;value representation&lt;/a&gt;(since C++20) of the object pointed to by &lt;code&gt;obj&lt;/code&gt; with that of the object pointed to by &lt;code&gt;expected&lt;/code&gt;, and if those are bitwise-equal, replaces the former with &lt;code&gt;desired&lt;/code&gt; (performs read-modify-write operation). Otherwise, loads the actual value pointed to by &lt;code&gt;obj&lt;/code&gt; into &lt;code&gt;*expected&lt;/code&gt; (performs load operation). Copying is performed as if by &lt;code&gt;&lt;a href=&quot;../string/byte/memcpy&quot;&gt;std::memcpy&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Атомно сравнивает &lt;a href=&quot;../language/objects&quot;&gt;представление объекта&lt;/a&gt; (до C ++ 20) &lt;a href=&quot;../language/objects&quot;&gt;представления значения&lt;/a&gt; (начиная с C ++ 20) объекта, на который указывает &lt;code&gt;obj&lt;/code&gt; , с объектом, на который указывает &lt;code&gt;expected&lt;/code&gt; , и, если они равны по битам, заменяет первое на &lt;code&gt;desired&lt;/code&gt; (выполняет операцию чтения-изменения-записи). В противном случае загружает фактическое значение, на которое указывает &lt;code&gt;obj&lt;/code&gt; , в &lt;code&gt;*expected&lt;/code&gt; (выполняет операцию загрузки). Копирование выполняется как бы с помощью &lt;code&gt;&lt;a href=&quot;../string/byte/memcpy&quot;&gt;std::memcpy&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="100502f70f849b38ac64477081a65ec2c013fbb9" translate="yes" xml:space="preserve">
          <source>Atomically increments or decrements the current value of the referenced object. These operations are read-modify-write operations.</source>
          <target state="translated">Атоматически увеличивает или уменьшает текущее значение объекта,на который делается ссылка.Эти операции являются операциями чтения-изменения-записи.</target>
        </trans-unit>
        <trans-unit id="478a2d2041d2790f2221395bbe5bc4e3d3f3c4ae" translate="yes" xml:space="preserve">
          <source>Atomically increments or decrements the current value. The operation is read-modify-write operation.</source>
          <target state="translated">Атоматически увеличивает или уменьшает текущее значение.Операция является операцией чтения-изменения-записи.</target>
        </trans-unit>
        <trans-unit id="f7bed069080eb00025095bf335aa11983b2283e1" translate="yes" xml:space="preserve">
          <source>Atomically loads and returns the current value of the atomic variable. Equivalent to &lt;code&gt;load()&lt;/code&gt;.</source>
          <target state="translated">Атомно загружает и возвращает текущее значение атомной переменной. Эквивалент &lt;code&gt;load()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1952cd629d030a2fa8403e27ef4aeced380b94ae" translate="yes" xml:space="preserve">
          <source>Atomically loads and returns the current value of the atomic variable. Memory is affected according to the value of &lt;code&gt;order&lt;/code&gt;.</source>
          <target state="translated">Атомно загружает и возвращает текущее значение атомной переменной. Память влияет на стоимость &lt;code&gt;order&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1f83aead02c429c2fa534aa09292be21ef4c6405" translate="yes" xml:space="preserve">
          <source>Atomically loads and returns the current value of the referenced object. Equivalent to &lt;code&gt;load()&lt;/code&gt;.</source>
          <target state="translated">Атомно загружает и возвращает текущее значение ссылочного объекта. Эквивалент &lt;code&gt;load()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e52c7a399bc235c4dbc0b29092d8308432fa02c0" translate="yes" xml:space="preserve">
          <source>Atomically loads and returns the current value of the referenced object. Memory is affected according to the value of &lt;code&gt;order&lt;/code&gt;.</source>
          <target state="translated">Атомно загружает и возвращает текущее значение ссылочного объекта. Память влияет на стоимость &lt;code&gt;order&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f53b29272e48fca5f9671422bca6315e7e6fd8c3" translate="yes" xml:space="preserve">
          <source>Atomically replaces the current value of the referenced object with &lt;code&gt;desired&lt;/code&gt;. Memory is affected according to the value of &lt;code&gt;order&lt;/code&gt;.</source>
          <target state="translated">Атомно заменяет текущее значение ссылочного объекта на &lt;code&gt;desired&lt;/code&gt; . Память влияет на стоимость &lt;code&gt;order&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a19feea96676cb1f3c159f83afde19f4a6539c3e" translate="yes" xml:space="preserve">
          <source>Atomically replaces the current value of the referenced object with the result of arithmetic addition of the value and &lt;code&gt;arg&lt;/code&gt;. This operation is a read-modify-write operation. Memory is affected according to the value of &lt;code&gt;order&lt;/code&gt;.</source>
          <target state="translated">Атомно заменяет текущее значение ссылочного объекта на результат арифметического сложения значения и &lt;code&gt;arg&lt;/code&gt; . Эта операция является операцией чтения-изменения-записи. Память влияет на стоимость &lt;code&gt;order&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6b3d0c0959425f2182650fbfbac226f664e7ddf7" translate="yes" xml:space="preserve">
          <source>Atomically replaces the current value of the referenced object with the result of arithmetic subtraction of the value and &lt;code&gt;arg&lt;/code&gt;. This operation is a read-modify-write operation. Memory is affected according to the value of &lt;code&gt;order&lt;/code&gt;.</source>
          <target state="translated">Атомно заменяет текущее значение ссылочного объекта результатом арифметического вычитания значения и &lt;code&gt;arg&lt;/code&gt; . Эта операция является операцией чтения-изменения-записи. Память влияет на стоимость &lt;code&gt;order&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="99dda00379caf075c4d39211472eaedafbd4f762" translate="yes" xml:space="preserve">
          <source>Atomically replaces the current value of the referenced object with the result of bitwise AND of the value and &lt;code&gt;arg&lt;/code&gt;. This operation is a read-modify-write operation. Memory is affected according to the value of &lt;code&gt;order&lt;/code&gt;.</source>
          <target state="translated">Атомно заменяет текущее значение ссылочного объекта результатом побитового И значения и &lt;code&gt;arg&lt;/code&gt; . Эта операция является операцией чтения-изменения-записи. Память влияет на стоимость &lt;code&gt;order&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="323c91d66c8118d7dbee222ab3de24a8cae5e0b1" translate="yes" xml:space="preserve">
          <source>Atomically replaces the current value of the referenced object with the result of bitwise OR of the value and &lt;code&gt;arg&lt;/code&gt;. This operation is a read-modify-write operation. Memory is affected according to the value of &lt;code&gt;order&lt;/code&gt;.</source>
          <target state="translated">Атомно заменяет текущее значение ссылочного объекта результатом побитового ИЛИ значения и &lt;code&gt;arg&lt;/code&gt; . Эта операция является операцией чтения-изменения-записи. Память влияет на стоимость &lt;code&gt;order&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="adf79a00626da82188ce094554607a0fe2a38357" translate="yes" xml:space="preserve">
          <source>Atomically replaces the current value of the referenced object with the result of bitwise XOR of the value and &lt;code&gt;arg&lt;/code&gt;. This operation is a read-modify-write operation. Memory is affected according to the value of &lt;code&gt;order&lt;/code&gt;.</source>
          <target state="translated">Атомно заменяет текущее значение ссылочного объекта результатом побитового XOR значения и &lt;code&gt;arg&lt;/code&gt; . Эта операция является операцией чтения-изменения-записи. Память влияет на стоимость &lt;code&gt;order&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ed67e3ed1c1744cb0f490f47975b11310f42139e" translate="yes" xml:space="preserve">
          <source>Atomically replaces the current value of the referenced object with the result of computation involving the previous value and &lt;code&gt;arg&lt;/code&gt;. These operations are read-modify-write operations.</source>
          <target state="translated">Атомно заменяет текущее значение ссылочного объекта на результат вычисления с использованием предыдущего значения и &lt;code&gt;arg&lt;/code&gt; . Эти операции являются операциями чтения-изменения-записи.</target>
        </trans-unit>
        <trans-unit id="f9b3020972d1b8ef0fae02f3fff0adbd8b1bd992" translate="yes" xml:space="preserve">
          <source>Atomically replaces the current value with &lt;code&gt;desired&lt;/code&gt;. Memory is affected according to the value of &lt;code&gt;order&lt;/code&gt;.</source>
          <target state="translated">Атомно заменяет текущее значение на &lt;code&gt;desired&lt;/code&gt; . Память влияет на стоимость &lt;code&gt;order&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c638ee73c1897f53905a40e8ba22b46e8d59e4e1" translate="yes" xml:space="preserve">
          <source>Atomically replaces the current value with the result of arithmetic addition of the value and &lt;code&gt;arg&lt;/code&gt;. The operation is read-modify-write operation. Memory is affected according to the value of &lt;code&gt;order&lt;/code&gt;.</source>
          <target state="translated">Атомно заменяет текущее значение результатом арифметического сложения значения и &lt;code&gt;arg&lt;/code&gt; . Операция является операцией чтения-изменения-записи. Память влияет на стоимость &lt;code&gt;order&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b99663e5dfaace40d5f5294851f50381ac55b0bc" translate="yes" xml:space="preserve">
          <source>Atomically replaces the current value with the result of arithmetic subtraction of the value and &lt;code&gt;arg&lt;/code&gt;. The operation is read-modify-write operation. Memory is affected according to the value of &lt;code&gt;order&lt;/code&gt;.</source>
          <target state="translated">Атомно заменяет текущее значение результатом арифметического вычитания значения и &lt;code&gt;arg&lt;/code&gt; . Операция является операцией чтения-изменения-записи. Память влияет на стоимость &lt;code&gt;order&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="79ead769b0375ec14ce72a88030040dd2a0e44be" translate="yes" xml:space="preserve">
          <source>Atomically replaces the current value with the result of bitwise AND of the value and &lt;code&gt;arg&lt;/code&gt;. The operation is read-modify-write operation. Memory is affected according to the value of &lt;code&gt;order&lt;/code&gt;.</source>
          <target state="translated">Атомно заменяет текущее значение на результат побитового И значения и &lt;code&gt;arg&lt;/code&gt; . Операция является операцией чтения-изменения-записи. Память влияет на стоимость &lt;code&gt;order&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2b7fe2746833cc38f05662da6d971a85fc32df09" translate="yes" xml:space="preserve">
          <source>Atomically replaces the current value with the result of bitwise OR of the value and &lt;code&gt;arg&lt;/code&gt;. The operation is read-modify-write operation. Memory is affected according to the value of &lt;code&gt;order&lt;/code&gt;.</source>
          <target state="translated">Атомно заменяет текущее значение результатом побитового ИЛИ значения и &lt;code&gt;arg&lt;/code&gt; . Операция является операцией чтения-изменения-записи. Память влияет на стоимость &lt;code&gt;order&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7ea95b2c69d82181c7d1ab5a7c21e9a5addde310" translate="yes" xml:space="preserve">
          <source>Atomically replaces the current value with the result of bitwise XOR of the value and &lt;code&gt;arg&lt;/code&gt;. The operation is read-modify-write operation. Memory is affected according to the value of &lt;code&gt;order&lt;/code&gt;.</source>
          <target state="translated">Атомно заменяет текущее значение на результат побитового XOR значения и &lt;code&gt;arg&lt;/code&gt; . Операция является операцией чтения-изменения-записи. Память влияет на стоимость &lt;code&gt;order&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="10212a346ea05ad906b686a41eca7ff8ef3b510f" translate="yes" xml:space="preserve">
          <source>Atomically replaces the current value with the result of computation involving the previous value and &lt;code&gt;arg&lt;/code&gt;. The operation is read-modify-write operation.</source>
          <target state="translated">Атомно заменяет текущее значение на результат вычисления с использованием предыдущего значения и &lt;code&gt;arg&lt;/code&gt; . Операция является операцией чтения-изменения-записи.</target>
        </trans-unit>
        <trans-unit id="3467c0dccb0c6c9b65479a9107e17419103cfb53" translate="yes" xml:space="preserve">
          <source>Atomically replaces the underlying &lt;code&gt;&lt;a href=&quot;../shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt; with &lt;code&gt;desired&lt;/code&gt; as if by &lt;code&gt;p.swap(desired)&lt;/code&gt; where &lt;code&gt;p&lt;/code&gt; is the underlying &lt;code&gt;std::shared_ptr&amp;lt;T&amp;gt;&lt;/code&gt; and returns a copy of the value that &lt;code&gt;p&lt;/code&gt; had immediately before the swap. Memory is ordered according to &lt;code&gt;order&lt;/code&gt;. This is an atomic read-modify-write operation.</source>
          <target state="translated">Атомно заменяет базовый &lt;code&gt;&lt;a href=&quot;../shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt; на &lt;code&gt;desired&lt;/code&gt; как если бы &lt;code&gt;p.swap(desired)&lt;/code&gt; где &lt;code&gt;p&lt;/code&gt; - базовый &lt;code&gt;std::shared_ptr&amp;lt;T&amp;gt;&lt;/code&gt; и возвращает копию значения, которое &lt;code&gt;p&lt;/code&gt; имел непосредственно перед свопом. Память упорядочена в соответствии с &lt;code&gt;order&lt;/code&gt; . Это атомарная операция чтения-изменения-записи.</target>
        </trans-unit>
        <trans-unit id="85d280e69a1a33e2d68aa75acba96c49fd3e46b4" translate="yes" xml:space="preserve">
          <source>Atomically replaces the underlying &lt;code&gt;&lt;a href=&quot;../weak_ptr&quot;&gt;std::weak_ptr&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt; with &lt;code&gt;desired&lt;/code&gt; as if by &lt;code&gt;p.swap(desired)&lt;/code&gt; where &lt;code&gt;p&lt;/code&gt; is the underlying &lt;code&gt;std::weak_ptr&amp;lt;T&amp;gt;&lt;/code&gt;, and returns a copy of the value that &lt;code&gt;p&lt;/code&gt; had immediately before the swap. Memory is ordered according to &lt;code&gt;order&lt;/code&gt;. This is an atomic read-modify-write operation.</source>
          <target state="translated">Атомно заменяет базовый &lt;code&gt;&lt;a href=&quot;../weak_ptr&quot;&gt;std::weak_ptr&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt; на &lt;code&gt;desired&lt;/code&gt; как если бы &lt;code&gt;p.swap(desired)&lt;/code&gt; где &lt;code&gt;p&lt;/code&gt; - базовый &lt;code&gt;std::weak_ptr&amp;lt;T&amp;gt;&lt;/code&gt; , и возвращает копию значения, которое &lt;code&gt;p&lt;/code&gt; имело непосредственно перед перестановкой. Память упорядочена в соответствии с &lt;code&gt;order&lt;/code&gt; . Это атомарная операция чтения-изменения-записи.</target>
        </trans-unit>
        <trans-unit id="0a463d97ca8c0c667a93bc169dce0bad4944f951" translate="yes" xml:space="preserve">
          <source>Atomically replaces the underlying value with &lt;code&gt;desired&lt;/code&gt;. The operation is read-modify-write operation. Memory is affected according to the value of &lt;code&gt;order&lt;/code&gt;.</source>
          <target state="translated">Атомно заменяет базовое значение на &lt;code&gt;desired&lt;/code&gt; . Операция является операцией чтения-изменения-записи. Память влияет на стоимость &lt;code&gt;order&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="718b9a19aefebfb54908169ba35b035711a206bc" translate="yes" xml:space="preserve">
          <source>Atomically replaces the value of &lt;code&gt;*this&lt;/code&gt; with the value of &lt;code&gt;desired&lt;/code&gt; as if by &lt;code&gt;p.swap(desired)&lt;/code&gt; where &lt;code&gt;p&lt;/code&gt; is the underlying &lt;code&gt;std::shared_ptr&amp;lt;T&amp;gt;&lt;/code&gt;. Memory is ordered according to &lt;code&gt;order&lt;/code&gt;. The behavior is undefined if &lt;code&gt;order&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;../../atomic/memory_order&quot;&gt;std::memory_order_consume&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../../atomic/memory_order&quot;&gt;std::memory_order_acquire&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;../../atomic/memory_order&quot;&gt;std::memory_order_acq_rel&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Атомно заменяет значение &lt;code&gt;*this&lt;/code&gt; на значение &lt;code&gt;desired&lt;/code&gt; как будто на &lt;code&gt;p.swap(desired)&lt;/code&gt; где &lt;code&gt;p&lt;/code&gt; является базовым &lt;code&gt;std::shared_ptr&amp;lt;T&amp;gt;&lt;/code&gt; . Память упорядочена в соответствии с &lt;code&gt;order&lt;/code&gt; . Поведение не определено, если &lt;code&gt;order&lt;/code&gt; равен &lt;code&gt;&lt;a href=&quot;../../atomic/memory_order&quot;&gt;std::memory_order_consume&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../../atomic/memory_order&quot;&gt;std::memory_order_acquire&lt;/a&gt;&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;../../atomic/memory_order&quot;&gt;std::memory_order_acq_rel&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cc343521b195a9638c26a309b38189be49c6ff1c" translate="yes" xml:space="preserve">
          <source>Atomically replaces the value of &lt;code&gt;*this&lt;/code&gt; with the value of &lt;code&gt;desired&lt;/code&gt; as if by &lt;code&gt;p.swap(desired)&lt;/code&gt; where &lt;code&gt;p&lt;/code&gt; is the underlying &lt;code&gt;std::weak_ptr&amp;lt;T&amp;gt;&lt;/code&gt;. Memory is ordered according to &lt;code&gt;order&lt;/code&gt;. The behavior is undefined if &lt;code&gt;order&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;../../atomic/memory_order&quot;&gt;std::memory_order_consume&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../../atomic/memory_order&quot;&gt;std::memory_order_acquire&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;../../atomic/memory_order&quot;&gt;std::memory_order_acq_rel&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Атомно заменяет значение &lt;code&gt;*this&lt;/code&gt; на значение &lt;code&gt;desired&lt;/code&gt; как будто на &lt;code&gt;p.swap(desired)&lt;/code&gt; где &lt;code&gt;p&lt;/code&gt; является базовым &lt;code&gt;std::weak_ptr&amp;lt;T&amp;gt;&lt;/code&gt; . Память упорядочена в соответствии с &lt;code&gt;order&lt;/code&gt; . Поведение не определено, если &lt;code&gt;order&lt;/code&gt; равен &lt;code&gt;&lt;a href=&quot;../../atomic/memory_order&quot;&gt;std::memory_order_consume&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../../atomic/memory_order&quot;&gt;std::memory_order_acquire&lt;/a&gt;&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;../../atomic/memory_order&quot;&gt;std::memory_order_acq_rel&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="eccb30a10adac1732c948846412c97a22323cf04" translate="yes" xml:space="preserve">
          <source>Atomically replaces the value of the referenced object with &lt;code&gt;desired&lt;/code&gt;. The operation is a read-modify-write operation. Memory is affected according to the value of &lt;code&gt;order&lt;/code&gt;.</source>
          <target state="translated">Атомно заменяет значение ссылочного объекта на &lt;code&gt;desired&lt;/code&gt; . Операция является операцией чтения-изменения-записи. Память влияет на стоимость &lt;code&gt;order&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="80dd75e8d600a19f4770f91cf5757274b7f5c6c5" translate="yes" xml:space="preserve">
          <source>Atomically replaces the value pointed by &lt;code&gt;obj&lt;/code&gt; with the result of bitwise AND between the old value of &lt;code&gt;obj&lt;/code&gt; and &lt;code&gt;arg&lt;/code&gt;. Returns the value &lt;code&gt;obj&lt;/code&gt; held previously.</source>
          <target state="translated">Атомно заменяет значение, указанное в &lt;code&gt;obj&lt;/code&gt; , на результат побитового И между старым значением &lt;code&gt;obj&lt;/code&gt; и &lt;code&gt;arg&lt;/code&gt; . Возвращает значение &lt;code&gt;obj&lt;/code&gt; , сохраненное ранее.</target>
        </trans-unit>
        <trans-unit id="790044bcc17db31e5c336936470c4daa1b6b3cd4" translate="yes" xml:space="preserve">
          <source>Atomically replaces the value pointed by &lt;code&gt;obj&lt;/code&gt; with the result of bitwise OR between the old value of &lt;code&gt;obj&lt;/code&gt; and &lt;code&gt;arg&lt;/code&gt;. Returns the value &lt;code&gt;obj&lt;/code&gt; held previously.</source>
          <target state="translated">Атомно заменяет значение, указанное &lt;code&gt;obj&lt;/code&gt; , на результат побитового ИЛИ между старым значением &lt;code&gt;obj&lt;/code&gt; и &lt;code&gt;arg&lt;/code&gt; . Возвращает значение &lt;code&gt;obj&lt;/code&gt; , сохраненное ранее.</target>
        </trans-unit>
        <trans-unit id="f251ecee591189cacdcc48a0936a14e913d943df" translate="yes" xml:space="preserve">
          <source>Atomically replaces the value pointed by &lt;code&gt;obj&lt;/code&gt; with the result of bitwise XOR between the old value of &lt;code&gt;obj&lt;/code&gt; and &lt;code&gt;arg&lt;/code&gt;. Returns the value &lt;code&gt;obj&lt;/code&gt; held previously.</source>
          <target state="translated">Атомно заменяет значение, указанное в &lt;code&gt;obj&lt;/code&gt; , на результат побитового XOR между старым значением &lt;code&gt;obj&lt;/code&gt; и &lt;code&gt;arg&lt;/code&gt; . Возвращает значение &lt;code&gt;obj&lt;/code&gt; , сохраненное ранее.</target>
        </trans-unit>
        <trans-unit id="3d9f4d98a3780918fb788b0a5026571e73af577e" translate="yes" xml:space="preserve">
          <source>Atomically returns a copy of the underlying &lt;code&gt;std::weak_ptr&amp;lt;T&amp;gt;&lt;/code&gt;. Memory is ordered according to &lt;code&gt;order&lt;/code&gt;. The behavior is undefined if &lt;code&gt;order&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;../../atomic/memory_order&quot;&gt;std::memory_order_release&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../../atomic/memory_order&quot;&gt;std::memory_order_acq_rel&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Атомно возвращает копию лежащего в основе &lt;code&gt;std::weak_ptr&amp;lt;T&amp;gt;&lt;/code&gt; . Память упорядочена в соответствии с &lt;code&gt;order&lt;/code&gt; . Поведение не определено, если &lt;code&gt;order&lt;/code&gt; равен &lt;code&gt;&lt;a href=&quot;../../atomic/memory_order&quot;&gt;std::memory_order_release&lt;/a&gt;&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;../../atomic/memory_order&quot;&gt;std::memory_order_acq_rel&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="33f67f81fe0865ff25fe2875aabcaf4cb3ed91ca" translate="yes" xml:space="preserve">
          <source>Atomically returns a copy of the underlying shared pointer. Memory is ordered according to &lt;code&gt;order&lt;/code&gt;. The behavior is undefined if &lt;code&gt;order&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;../../atomic/memory_order&quot;&gt;std::memory_order_release&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../../atomic/memory_order&quot;&gt;std::memory_order_acq_rel&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Атомно возвращает копию базового общего указателя. Память упорядочена в соответствии с &lt;code&gt;order&lt;/code&gt; . Поведение не определено, если &lt;code&gt;order&lt;/code&gt; равен &lt;code&gt;&lt;a href=&quot;../../atomic/memory_order&quot;&gt;std::memory_order_release&lt;/a&gt;&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;../../atomic/memory_order&quot;&gt;std::memory_order_acq_rel&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="68c88562518723a64d9fcb4f31aa71ec0eefafe8" translate="yes" xml:space="preserve">
          <source>Atomically stores the exception pointer &lt;code&gt;p&lt;/code&gt; into the shared state and makes the state ready.</source>
          <target state="translated">Атомно хранит указатель исключения &lt;code&gt;p&lt;/code&gt; в общем состоянии и готовит состояние.</target>
        </trans-unit>
        <trans-unit id="c5a3aae2b82d6bc278809f7ca79720a49ddb5e50" translate="yes" xml:space="preserve">
          <source>Atomically transmits all pending output to the wrapped stream.</source>
          <target state="translated">Атоматически передает все отложенные выходные данные в обернутый поток.</target>
        </trans-unit>
        <trans-unit id="22cd0cbd81dee9dcd227285a4fb456261af24ea4" translate="yes" xml:space="preserve">
          <source>Atomics</source>
          <target state="translated">Atomics</target>
        </trans-unit>
        <trans-unit id="a0416416d30eca6a7701e0924dc48acb5d8ff422" translate="yes" xml:space="preserve">
          <source>Attempting to forward an rvalue as an lvalue, such as by instantiating the form (2) with lvalue reference type T, is a compile-time error.</source>
          <target state="translated">Попытка переслать значение в виде l-значения,например,путем инстанцирования формы (2)со ссылкой на l-значение типа T,является ошибкой во времени компиляции.</target>
        </trans-unit>
        <trans-unit id="76a4004354e2dd4daf0348cba6cc1fc1999f48f1" translate="yes" xml:space="preserve">
          <source>Attempting to modify a string literal results in</source>
          <target state="translated">Попытка изменить строковый литерал приводит к тому,что</target>
        </trans-unit>
        <trans-unit id="abad2c050ad896c23b0ad28b3e223e6dd62344dd" translate="yes" xml:space="preserve">
          <source>Attempting to specialize a template defined in the &lt;code&gt;&amp;lt;type_traits&amp;gt;&lt;/code&gt; header results in undefined behavior, except that &lt;code&gt;&lt;a href=&quot;types/common_type&quot;&gt;std::common_type&lt;/a&gt;&lt;/code&gt; may be specialized &lt;a href=&quot;types/common_type#Specializations&quot;&gt;as described in its description&lt;/a&gt;.</source>
          <target state="translated">Попытка специализировать шаблон, определенный в заголовке &lt;code&gt;&amp;lt;type_traits&amp;gt;&lt;/code&gt; , приводит к неопределенному поведению, за исключением того, что &lt;code&gt;&lt;a href=&quot;types/common_type&quot;&gt;std::common_type&lt;/a&gt;&lt;/code&gt; может быть специализированным, &lt;a href=&quot;types/common_type#Specializations&quot;&gt;как описано в его описании&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="78a4a89b2d2486832b4cafece47f12bab7a55776" translate="yes" xml:space="preserve">
          <source>Attempts to acquire the lock for the current execution agent (thread, process, task) without blocking. If an exception is thrown, no lock is obtained.</source>
          <target state="translated">Попытки получить блокировку для текущего агента исполнения (поток,процесс,задача)без блокировки.Если выбрасывается исключение,то блокировка не получается.</target>
        </trans-unit>
        <trans-unit id="baca3810d2cde4b7e1025b84062248c5223beff5" translate="yes" xml:space="preserve">
          <source>Attempts to clear the floating-point exceptions that are listed in the bitmask argument &lt;code&gt;excepts&lt;/code&gt;, which is a bitwise OR of the &lt;a href=&quot;fe_exceptions&quot;&gt;floating point exception macros&lt;/a&gt;.</source>
          <target state="translated">Попытки очистить исключения с плавающей точкой, которые перечислены в битовой аргумент &lt;code&gt;excepts&lt;/code&gt; , который является побитовым ИЛИ с &lt;a href=&quot;fe_exceptions&quot;&gt;плавающей точкой макросов исключения&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7dbed2ba20cbcb53c66e4a383e6c53bad4b2eb39" translate="yes" xml:space="preserve">
          <source>Attempts to extract (&quot;splice&quot;) each element in &lt;code&gt;source&lt;/code&gt; and insert it into &lt;code&gt;*this&lt;/code&gt; using the comparison object of &lt;code&gt;*this&lt;/code&gt;.</source>
          <target state="translated">Пытается извлечь (&quot;склеить&quot;) каждый элемент в &lt;code&gt;source&lt;/code&gt; и вставить его в &lt;code&gt;*this&lt;/code&gt; , используя объект сравнения &lt;code&gt;*this&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="69638346260f8c39f54ee09036f959b95caeb136" translate="yes" xml:space="preserve">
          <source>Attempts to extract (&quot;splice&quot;) each element in &lt;code&gt;source&lt;/code&gt; and insert it into &lt;code&gt;*this&lt;/code&gt; using the comparison object of &lt;code&gt;*this&lt;/code&gt;. If there is an element in &lt;code&gt;*this&lt;/code&gt; with key equivalent to the key of an element from &lt;code&gt;source&lt;/code&gt;, then that element is not extracted from &lt;code&gt;source&lt;/code&gt;. No elements are copied or moved, only the internal pointers of the container nodes are repointed. All pointers and references to the transferred elements remain valid, but now refer into &lt;code&gt;*this&lt;/code&gt;, not into &lt;code&gt;source&lt;/code&gt;.</source>
          <target state="translated">Пытается извлечь (&quot;склеить&quot;) каждый элемент в &lt;code&gt;source&lt;/code&gt; и вставить его в &lt;code&gt;*this&lt;/code&gt; , используя объект сравнения &lt;code&gt;*this&lt;/code&gt; . Если в &lt;code&gt;*this&lt;/code&gt; есть элемент с ключом, эквивалентным ключу элемента из &lt;code&gt;source&lt;/code&gt; , то этот элемент не извлекается из &lt;code&gt;source&lt;/code&gt; . Элементы не копируются и не перемещаются, только внутренние указатели узлов контейнера переопределяются. Все указатели и ссылки на переданные элементы остаются действительными, но теперь ссылаются на &lt;code&gt;*this&lt;/code&gt; , а не на &lt;code&gt;source&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="95555f012243a16b5fbac5ece1355dd665253556" translate="yes" xml:space="preserve">
          <source>Attempts to extract (&quot;splice&quot;) each element in &lt;code&gt;source&lt;/code&gt; and insert it into &lt;code&gt;*this&lt;/code&gt; using the hash function and key equality predicate of &lt;code&gt;*this&lt;/code&gt;.</source>
          <target state="translated">Пытается извлечь (&quot;склеить&quot;) каждый элемент в &lt;code&gt;source&lt;/code&gt; и вставить его в &lt;code&gt;*this&lt;/code&gt; с помощью хеш-функции и предиката равенства ключей &lt;code&gt;*this&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5462c1b9abbfcaedbee9e1ed5c5c12b594c2335b" translate="yes" xml:space="preserve">
          <source>Attempts to extract (&quot;splice&quot;) each element in &lt;code&gt;source&lt;/code&gt; and insert it into &lt;code&gt;*this&lt;/code&gt; using the hash function and key equality predicate of &lt;code&gt;*this&lt;/code&gt;. If there is an element in &lt;code&gt;*this&lt;/code&gt; with key equivalent to the key of an element from &lt;code&gt;source&lt;/code&gt;, then that element is not extracted from &lt;code&gt;source&lt;/code&gt;. No elements are copied or moved, only the internal pointers of the container nodes are repointed. All pointers and references to the transferred elements remain valid, but now refer into &lt;code&gt;*this&lt;/code&gt;, not into &lt;code&gt;source&lt;/code&gt;. Iterators referring to the transferred elements and all iterators referring to &lt;code&gt;*this&lt;/code&gt; are invalidated. Iterators to elements remaining in &lt;code&gt;source&lt;/code&gt; remain valid.</source>
          <target state="translated">Пытается извлечь (&quot;склеить&quot;) каждый элемент в &lt;code&gt;source&lt;/code&gt; и вставить его в &lt;code&gt;*this&lt;/code&gt; с помощью хеш-функции и предиката равенства ключей &lt;code&gt;*this&lt;/code&gt; . Если в &lt;code&gt;*this&lt;/code&gt; есть элемент с ключом, эквивалентным ключу элемента из &lt;code&gt;source&lt;/code&gt; , то этот элемент не извлекается из &lt;code&gt;source&lt;/code&gt; . Элементы не копируются и не перемещаются, только внутренние указатели узлов контейнера переопределяются. Все указатели и ссылки на переданные элементы остаются действительными, но теперь ссылаются на &lt;code&gt;*this&lt;/code&gt; , а не на &lt;code&gt;source&lt;/code&gt; . Итераторы, ссылающиеся на переданные элементы, и все итераторы, ссылающиеся на &lt;code&gt;*this&lt;/code&gt; признаны недействительными Итераторы для элементов, оставшихся в &lt;code&gt;source&lt;/code&gt; остаются действительными.</target>
        </trans-unit>
        <trans-unit id="92bc4254a3b00d301ffc057c9e050501ca173c4b" translate="yes" xml:space="preserve">
          <source>Attempts to obtain exclusive ownership of the mutex for the calling thread without blocking. If ownership is not obtained, returns immediately. The function is allowed to spuriously fail and return even if the mutex is not currently owned by another thread.</source>
          <target state="translated">Попытки получить эксклюзивное право собственности на мьютекс для вызывающей нити без блокировки.Если право собственности не получено,возвращается немедленно.Функция может ложно выйти из строя и вернуться,даже если мьютекс в настоящее время не принадлежит другому потоку.</target>
        </trans-unit>
        <trans-unit id="9d99e4cbad6e4e7caa7d20dc148d4b12dfad9de6" translate="yes" xml:space="preserve">
          <source>Attempts to obtain exclusive ownership of the mutex within the duration specified by &lt;code&gt;duration&lt;/code&gt;. If &lt;code&gt;duration&lt;/code&gt; is less or equal &lt;code&gt;duration.zero()&lt;/code&gt;, attempts to obtain the ownership without locking (as if by &lt;code&gt;try_lock()&lt;/code&gt;). Otherwise, this function blocks until the mutex is acquired or until the time specified by &lt;code&gt;duration&lt;/code&gt; passes. It returns within &lt;code&gt;duration&lt;/code&gt; only if it succeeds, but it allowed to fail to acquire the mutex even if at some point in time during &lt;code&gt;duration&lt;/code&gt; it was not owned by another thread. In any case, it returns &lt;code&gt;true&lt;/code&gt; if the mutex was acquired and &lt;code&gt;false&lt;/code&gt; otherwise.</source>
          <target state="translated">Попытки получить исключительное право собственности на мьютекс в течение срока, указанного в &lt;code&gt;duration&lt;/code&gt; . Если &lt;code&gt;duration&lt;/code&gt; меньше или равна &lt;code&gt;duration.zero()&lt;/code&gt; , попытка получить владение без блокировки (как будто с помощью &lt;code&gt;try_lock()&lt;/code&gt; ). В противном случае эта функция блокируется до тех пор, пока мьютекс не будет получен или пока не пройдет время, указанное в &lt;code&gt;duration&lt;/code&gt; . Он возвращает в течение &lt;code&gt;duration&lt;/code&gt; только если он успешен, но ему разрешалось не получить мьютекс, даже если в какой-то момент времени в течение &lt;code&gt;duration&lt;/code&gt; он не принадлежал другому потоку. В любом случае, он возвращает &lt;code&gt;true&lt;/code&gt; , если мьютекс был получен, и &lt;code&gt;false&lt;/code&gt; в противном случае.</target>
        </trans-unit>
        <trans-unit id="80bd748efa455b573b135d3617ebfa1fd13b34d8" translate="yes" xml:space="preserve">
          <source>Attempts to obtain exclusive ownership of the mutex within the time left until &lt;code&gt;time_point&lt;/code&gt;. If &lt;code&gt;time_point&lt;/code&gt; already passed, attempts to obtain the ownership without locking (as if by &lt;code&gt;try_lock()&lt;/code&gt;). Otherwise, this function blocks until the mutex is acquired or until the time specified by &lt;code&gt;time_point&lt;/code&gt; passes. It returns before &lt;code&gt;time_point&lt;/code&gt; only if it succeeds, but it allowed to fail to acquire the mutex even if at some point in time before &lt;code&gt;time_point&lt;/code&gt; it was not owned by another thread. In any case, it returns &lt;code&gt;true&lt;/code&gt; if the mutex was acquired and &lt;code&gt;false&lt;/code&gt; otherwise.</source>
          <target state="translated">Попытки получить исключительное право собственности на мьютекс в течение времени, оставшегося до &lt;code&gt;time_point&lt;/code&gt; . Если &lt;code&gt;time_point&lt;/code&gt; уже пройден, попытка получить владение без блокировки (как будто с помощью &lt;code&gt;try_lock()&lt;/code&gt; ). В противном случае эта функция блокируется, пока мьютекс не будет получен или пока не &lt;code&gt;time_point&lt;/code&gt; время, указанное в time_point . Он возвращает до &lt;code&gt;time_point&lt;/code&gt; только в случае успеха, но ему не удалось получить мьютекс, даже если в какой-то момент времени до &lt;code&gt;time_point&lt;/code&gt; он не принадлежал другому потоку. В любом случае, он возвращает &lt;code&gt;true&lt;/code&gt; , если мьютекс был получен, и &lt;code&gt;false&lt;/code&gt; в противном случае.</target>
        </trans-unit>
        <trans-unit id="7fb190dc6b50cac16e4189df447478fcf3a9d392" translate="yes" xml:space="preserve">
          <source>Attempts to obtain shared ownership of the mutex for the calling thread without blocking. If ownership is not obtained, returns immediately. The function is allowed to spuriously fail and return even if the mutex is not currently owned by any threads in any mode.</source>
          <target state="translated">Попытки получить право совместной собственности на мьютекс для вызывающей нити без блокировки.Если право собственности не получено,возвращается немедленно.Функция допускает ложный сбой и возврат,даже если в данный момент мьютекс не принадлежит ни одному потоку ни в каком режиме.</target>
        </trans-unit>
        <trans-unit id="f1ab0535323ac87b863427dcfd803c52e2e71c97" translate="yes" xml:space="preserve">
          <source>Attempts to obtain shared ownership of the mutex within the duration specified by &lt;code&gt;duration&lt;/code&gt;. If &lt;code&gt;duration&lt;/code&gt; is less or equal &lt;code&gt;duration.zero()&lt;/code&gt;, attempts to obtain the ownership without waiting (as if by &lt;code&gt;try_lock()&lt;/code&gt;). Otherwise, this function blocks until the mutex is acquired or until the time specified by &lt;code&gt;duration&lt;/code&gt; passes. It returns within &lt;code&gt;duration&lt;/code&gt; only if it succeeds, but it allowed to fail to acquire the mutex even if at some point in time during &lt;code&gt;duration&lt;/code&gt; it was not owned by another thread. In any case, it returns &lt;code&gt;true&lt;/code&gt; if the mutex was acquired and &lt;code&gt;false&lt;/code&gt; otherwise.</source>
          <target state="translated">Попытки получить совместное владение мьютексом в течение продолжительности, указанной в &lt;code&gt;duration&lt;/code&gt; . Если &lt;code&gt;duration&lt;/code&gt; меньше или равна &lt;code&gt;duration.zero()&lt;/code&gt; , попытка получить владение без ожидания (как будто с помощью &lt;code&gt;try_lock()&lt;/code&gt; ). В противном случае эта функция блокируется до тех пор, пока мьютекс не будет получен или пока не пройдет время, указанное в &lt;code&gt;duration&lt;/code&gt; . Он возвращает в течение &lt;code&gt;duration&lt;/code&gt; только если он успешен, но ему разрешалось не получить мьютекс, даже если в какой-то момент времени в течение &lt;code&gt;duration&lt;/code&gt; он не принадлежал другому потоку. В любом случае, он возвращает &lt;code&gt;true&lt;/code&gt; , если мьютекс был получен, и &lt;code&gt;false&lt;/code&gt; в противном случае.</target>
        </trans-unit>
        <trans-unit id="7e1b61606843aa888af598e0c261d938b302f15a" translate="yes" xml:space="preserve">
          <source>Attempts to obtain shared ownership of the mutex within the time left until &lt;code&gt;time_point&lt;/code&gt;. If &lt;code&gt;time_point&lt;/code&gt; already passed, attempts to obtain the ownership without locking (as if by &lt;code&gt;try_lock()&lt;/code&gt;). Otherwise, this function blocks until the mutex is acquired or until the time specified by &lt;code&gt;time_point&lt;/code&gt; passes. It returns before &lt;code&gt;time_point&lt;/code&gt; only if it succeeds, but it allowed to fail to acquire the mutex even if at some point in time before &lt;code&gt;time_point&lt;/code&gt; it was not owned by another thread. In any case, it returns &lt;code&gt;true&lt;/code&gt; if the mutex was acquired and &lt;code&gt;false&lt;/code&gt; otherwise.</source>
          <target state="translated">Попытки получить общее владение мьютексом в течение времени, оставшегося до &lt;code&gt;time_point&lt;/code&gt; . Если &lt;code&gt;time_point&lt;/code&gt; уже пройден, попытка получить владение без блокировки (как будто с помощью &lt;code&gt;try_lock()&lt;/code&gt; ). В противном случае эта функция блокируется, пока мьютекс не будет получен или пока не &lt;code&gt;time_point&lt;/code&gt; время, указанное в time_point . Он возвращает до &lt;code&gt;time_point&lt;/code&gt; только в случае успеха, но ему не удалось получить мьютекс, даже если в какой-то момент времени до &lt;code&gt;time_point&lt;/code&gt; он не принадлежал другому потоку. В любом случае, он возвращает &lt;code&gt;true&lt;/code&gt; , если мьютекс был получен, и &lt;code&gt;false&lt;/code&gt; в противном случае.</target>
        </trans-unit>
        <trans-unit id="52d6b2b14e6e6fe30ee7f8d64fe95f33b5f6832a" translate="yes" xml:space="preserve">
          <source>Attempts to parse the input stream &lt;code&gt;is&lt;/code&gt; into the &lt;code&gt;&lt;a href=&quot;../duration&quot;&gt;std::chrono::duration&lt;/a&gt;&lt;/code&gt;&lt;code&gt;d&lt;/code&gt;, interpreted as the time of day since midnight, according to the format string &lt;code&gt;fmt&lt;/code&gt;.</source>
          <target state="translated">Попытки разобрать входной поток &lt;code&gt;is&lt;/code&gt; в &lt;code&gt;&lt;a href=&quot;../duration&quot;&gt;std::chrono::duration&lt;/a&gt;&lt;/code&gt; &lt;code&gt;d&lt;/code&gt; , интерпретируемой как время дня с полуночи, согласно форматной строке &lt;code&gt;fmt&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="376efd8a04cc4bbd4dec0c37c8f77d83f331d150" translate="yes" xml:space="preserve">
          <source>Attempts to parse the input stream &lt;code&gt;is&lt;/code&gt; into the &lt;code&gt;std::chrono::day&lt;/code&gt;&lt;code&gt;d&lt;/code&gt; according to the format string &lt;code&gt;fmt&lt;/code&gt;.</source>
          <target state="translated">Попытки разобрать входной поток &lt;code&gt;is&lt;/code&gt; в &lt;code&gt;std::chrono::day&lt;/code&gt; &lt;code&gt;d&lt;/code&gt; в соответствии со строкой формата &lt;code&gt;fmt&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0ca1a9386d370561e811dd985b14a1c196b3e9e6" translate="yes" xml:space="preserve">
          <source>Attempts to parse the input stream &lt;code&gt;is&lt;/code&gt; into the &lt;code&gt;std::chrono::month&lt;/code&gt;&lt;code&gt;m&lt;/code&gt; according to the format string &lt;code&gt;fmt&lt;/code&gt;.</source>
          <target state="translated">Попытки разобрать входной поток &lt;code&gt;is&lt;/code&gt; в &lt;code&gt;std::chrono::month&lt;/code&gt; &lt;code&gt;m&lt;/code&gt; в соответствии со строкой формата &lt;code&gt;fmt&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="40506d7d67c8bce66782b683f245a3f3fdf40954" translate="yes" xml:space="preserve">
          <source>Attempts to parse the input stream &lt;code&gt;is&lt;/code&gt; into the &lt;code&gt;std::chrono::month_day&lt;/code&gt;&lt;code&gt;md&lt;/code&gt; according to the format string &lt;code&gt;fmt&lt;/code&gt;.</source>
          <target state="translated">Попытки разобрать входной поток &lt;code&gt;is&lt;/code&gt; в &lt;code&gt;std::chrono::month_day&lt;/code&gt; &lt;code&gt;md&lt;/code&gt; в соответствии с форматом строки &lt;code&gt;fmt&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="40de5b5311f786d5adb9ba2992f4f537c57266b8" translate="yes" xml:space="preserve">
          <source>Attempts to parse the input stream &lt;code&gt;is&lt;/code&gt; into the &lt;code&gt;std::chrono::weekday&lt;/code&gt;&lt;code&gt;wd&lt;/code&gt; according to the format string &lt;code&gt;fmt&lt;/code&gt;.</source>
          <target state="translated">Попытки разобрать входной поток &lt;code&gt;is&lt;/code&gt; в &lt;code&gt;std::chrono::weekday&lt;/code&gt; &lt;code&gt;wd&lt;/code&gt; в соответствии со строкой формата &lt;code&gt;fmt&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3c5714af52ba60c907aab16771ef9fc12f5e61b9" translate="yes" xml:space="preserve">
          <source>Attempts to parse the input stream &lt;code&gt;is&lt;/code&gt; into the &lt;code&gt;std::chrono::year&lt;/code&gt;&lt;code&gt;y&lt;/code&gt; according to the format string &lt;code&gt;fmt&lt;/code&gt;.</source>
          <target state="translated">Попытки разобрать входной поток &lt;code&gt;is&lt;/code&gt; в &lt;code&gt;std::chrono::year&lt;/code&gt; &lt;code&gt;y&lt;/code&gt; в соответствии со строкой формата &lt;code&gt;fmt&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="40c30b9ec9cc1fd3faebf2fb9fdfd4762f1dbc0a" translate="yes" xml:space="preserve">
          <source>Attempts to parse the input stream &lt;code&gt;is&lt;/code&gt; into the &lt;code&gt;std::chrono::year_month&lt;/code&gt;&lt;code&gt;ym&lt;/code&gt; according to the format string &lt;code&gt;fmt&lt;/code&gt;.</source>
          <target state="translated">Попытки разобрать входной поток &lt;code&gt;is&lt;/code&gt; в &lt;code&gt;std::chrono::year_month&lt;/code&gt; &lt;code&gt;ym&lt;/code&gt; в соответствии со строкой формата &lt;code&gt;fmt&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ca0d091ecc65883512fa43e7446c9c5bb23b7dda" translate="yes" xml:space="preserve">
          <source>Attempts to parse the input stream &lt;code&gt;is&lt;/code&gt; into the &lt;code&gt;std::chrono::year_month_day&lt;/code&gt;&lt;code&gt;ymd&lt;/code&gt; according to the format string &lt;code&gt;fmt&lt;/code&gt;.</source>
          <target state="translated">Попытки разобрать входной поток &lt;code&gt;is&lt;/code&gt; в &lt;code&gt;std::chrono::year_month_day&lt;/code&gt; &lt;code&gt;ymd&lt;/code&gt; в соответствии со строкой формата &lt;code&gt;fmt&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="31bf10609fbb5d90b5c351b1efc2680a881a160b" translate="yes" xml:space="preserve">
          <source>Attempts to parse the input stream &lt;code&gt;is&lt;/code&gt; into the time point &lt;code&gt;tp&lt;/code&gt; according to the format string &lt;code&gt;fmt&lt;/code&gt;.</source>
          <target state="translated">Попытки разобрать входной поток &lt;code&gt;is&lt;/code&gt; в момент времени &lt;code&gt;tp&lt;/code&gt; в соответствии со строкой формата &lt;code&gt;fmt&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="80ba342b8785a08804a333bbfedec341d6d1c9c0" translate="yes" xml:space="preserve">
          <source>Attempts to raise all floating point exceptions listed in &lt;code&gt;excepts&lt;/code&gt; (a bitwise OR of the &lt;a href=&quot;fe_exceptions&quot;&gt;floating point exception macros&lt;/a&gt;). If one of the exceptions is &lt;code&gt;&lt;a href=&quot;fe_exceptions&quot;&gt;FE_OVERFLOW&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;fe_exceptions&quot;&gt;FE_UNDERFLOW&lt;/a&gt;&lt;/code&gt;, this function may additionally raise &lt;code&gt;&lt;a href=&quot;fe_exceptions&quot;&gt;FE_INEXACT&lt;/a&gt;&lt;/code&gt;. The order in which the exceptions are raised is unspecified, except that &lt;code&gt;&lt;a href=&quot;fe_exceptions&quot;&gt;FE_OVERFLOW&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;fe_exceptions&quot;&gt;FE_UNDERFLOW&lt;/a&gt;&lt;/code&gt; are always raised before &lt;code&gt;&lt;a href=&quot;fe_exceptions&quot;&gt;FE_INEXACT&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Попытки вызвать все исключения с плавающей запятой, перечисленные в &lt;code&gt;excepts&lt;/code&gt; (побитовое ИЛИ &lt;a href=&quot;fe_exceptions&quot;&gt;макросов исключений&lt;/a&gt; с плавающей запятой ). Если одним из исключений является &lt;code&gt;&lt;a href=&quot;fe_exceptions&quot;&gt;FE_OVERFLOW&lt;/a&gt;&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;fe_exceptions&quot;&gt;FE_UNDERFLOW&lt;/a&gt;&lt;/code&gt; , эта функция может дополнительно повысить &lt;code&gt;&lt;a href=&quot;fe_exceptions&quot;&gt;FE_INEXACT&lt;/a&gt;&lt;/code&gt; . Порядок, в котором вызываются исключения, не определен, за исключением того, что &lt;code&gt;&lt;a href=&quot;fe_exceptions&quot;&gt;FE_OVERFLOW&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;fe_exceptions&quot;&gt;FE_UNDERFLOW&lt;/a&gt;&lt;/code&gt; всегда &lt;code&gt;&lt;a href=&quot;fe_exceptions&quot;&gt;FE_INEXACT&lt;/a&gt;&lt;/code&gt; до FE_INEXACT .</target>
        </trans-unit>
        <trans-unit id="a086d942884a301b827479029ba19c2746237425" translate="yes" xml:space="preserve">
          <source>Attribute</source>
          <target state="translated">Attribute</target>
        </trans-unit>
        <trans-unit id="a902057674f85199d3ac1499e38efca7a4896e56" translate="yes" xml:space="preserve">
          <source>Attribute declaration (&lt;a href=&quot;attributes&quot;&gt;attr&lt;/a&gt;&lt;code&gt;;&lt;/code&gt;) (since C++11)</source>
          <target state="translated">Объявление атрибута ( &lt;a href=&quot;attributes&quot;&gt;attr &lt;/a&gt; &lt;code&gt;;&lt;/code&gt; ) (начиная с C ++ 11)</target>
        </trans-unit>
        <trans-unit id="73fed77350865417033e78f8ec9ca2448d835567" translate="yes" xml:space="preserve">
          <source>Attribute list</source>
          <target state="translated">Список атрибутов</target>
        </trans-unit>
        <trans-unit id="a6652617f2c799eb11ee727b16c5646c48af6905" translate="yes" xml:space="preserve">
          <source>Attributes</source>
          <target state="translated">Attributes</target>
        </trans-unit>
        <trans-unit id="fad8ef5207a6faf8cf0a093eff47035c565b35b8" translate="yes" xml:space="preserve">
          <source>Attributes for &lt;a href=&quot;language/enum&quot;&gt;enumerators&lt;/a&gt;</source>
          <target state="translated">Атрибуты для &lt;a href=&quot;language/enum&quot;&gt;счетчиков&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c24797e2f08fead2ed265ebddf05756fe163fa39" translate="yes" xml:space="preserve">
          <source>Attributes for &lt;a href=&quot;language/namespace&quot;&gt;namespaces&lt;/a&gt;</source>
          <target state="translated">Атрибуты для &lt;a href=&quot;language/namespace&quot;&gt;пространств имен&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="24a93aad8da8b2ecc0fb62d3635f7bcad0973aee" translate="yes" xml:space="preserve">
          <source>Attributes provide the unified standard syntax for implementation-defined language extensions, such as the GNU and IBM language extensions &lt;code&gt;__attribute__((...))&lt;/code&gt;, Microsoft extension &lt;code&gt;__declspec()&lt;/code&gt;, etc.</source>
          <target state="translated">Атрибуты предоставляют унифицированный стандартный синтаксис для расширений, определяемых реализацией, таких как расширения языка GNU и IBM &lt;code&gt;__attribute__((...))&lt;/code&gt; , расширение Microsoft &lt;code&gt;__declspec()&lt;/code&gt; и т. Д.</target>
        </trans-unit>
        <trans-unit id="35d5b17890aadedb8aadfe40da01d18e88c0f170" translate="yes" xml:space="preserve">
          <source>Average case O(N), worst case O(N*size()+N), where N is &lt;code&gt;source.size()&lt;/code&gt;.</source>
          <target state="translated">Средний случай O (N), наихудший случай O (N * size () + N), где N - &lt;code&gt;source.size()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ca02a8758f4a48f9665324811a74024dd77f1084" translate="yes" xml:space="preserve">
          <source>Average case linear in the number of elements with the key &lt;code&gt;key&lt;/code&gt;, worst case linear in the size of the container.</source>
          <target state="translated">Средний случай линейный по количеству элементов с ключом &lt;code&gt;key&lt;/code&gt; , наихудший случай линейный по размеру контейнера.</target>
        </trans-unit>
        <trans-unit id="500ca2374c6717aa20d965b6fb6566e425ffa363" translate="yes" xml:space="preserve">
          <source>Average case linear in the size of the container, worst case quadratic.</source>
          <target state="translated">Средний корпус линейный по размеру контейнера,наихудший-квадратичный.</target>
        </trans-unit>
        <trans-unit id="0cf15213abbcf806e052466023c496d374b93c5e" translate="yes" xml:space="preserve">
          <source>Average case: constant, worst case: linear in size.</source>
          <target state="translated">Средний случай:постоянный,наихудший случай:линейный по размеру.</target>
        </trans-unit>
        <trans-unit id="c69ec73023882fcdb14f4029c8b28967cb6b9150" translate="yes" xml:space="preserve">
          <source>Average number of elements per bucket.</source>
          <target state="translated">Среднее количество элементов на ведро.</target>
        </trans-unit>
        <trans-unit id="5af1300096bdfebd096b49bf84d70a955eb1b7f9" translate="yes" xml:space="preserve">
          <source>Avoiding implicit copy assignment.</source>
          <target state="translated">Избежать неявного копирования.</target>
        </trans-unit>
        <trans-unit id="8c40560d40ca8b01a27ce21af51b6bb3a0aa5d77" translate="yes" xml:space="preserve">
          <source>Avoiding implicit generation of the copy constructor.</source>
          <target state="translated">Предотвращение неявной генерации конструктора копирования.</target>
        </trans-unit>
        <trans-unit id="55a6c927298fd43f61b985a13d7c9627855c38d0" translate="yes" xml:space="preserve">
          <source>Avoiding implicit move assignment.</source>
          <target state="translated">Избежать неявного назначения перемещения.</target>
        </trans-unit>
        <trans-unit id="21e51124dadde6f26a27f5ade3d091ebb552a9a3" translate="yes" xml:space="preserve">
          <source>Avoiding implicit move constructor.</source>
          <target state="translated">Избежать неявного перемещения конструктора.</target>
        </trans-unit>
        <trans-unit id="ae4f281df5a5d0ff3cad6371f76d5c29b6d953ec" translate="yes" xml:space="preserve">
          <source>B</source>
          <target state="translated">B</target>
        </trans-unit>
        <trans-unit id="4c39141080123158d56211e39765a42a9728de5f" translate="yes" xml:space="preserve">
          <source>B 2) A</source>
          <target state="translated">B 2)A</target>
        </trans-unit>
        <trans-unit id="62706ba741ba699cbebde8104c0834806fb26022" translate="yes" xml:space="preserve">
          <source>B 3) A</source>
          <target state="translated">B 3)A</target>
        </trans-unit>
        <trans-unit id="0a1b08f2698d8eaa357ae4e4639ab5964829b92d" translate="yes" xml:space="preserve">
          <source>B 4) A</source>
          <target state="translated">B 4)A</target>
        </trans-unit>
        <trans-unit id="fc28f53619db61ee68c4c2b6467d93002c47863a" translate="yes" xml:space="preserve">
          <source>B and A appears before Y in the Single Total Order</source>
          <target state="translated">Б и А появляются перед Y в едином общем порядке.</target>
        </trans-unit>
        <trans-unit id="403422f66cba2adadb0da593596292864fb30e29" translate="yes" xml:space="preserve">
          <source>B within thread 1 and C is</source>
          <target state="translated">B в пределах резьбы 1 и C</target>
        </trans-unit>
        <trans-unit id="4e54499211164f4b65d4e8324b3d4ca2593386d6" translate="yes" xml:space="preserve">
          <source>B, and X appears before Y in the Single Total Order, then B observes either:</source>
          <target state="translated">B,и X появляется перед Y в Едином Всего Ордене,затем B тоже наблюдает:</target>
        </trans-unit>
        <trans-unit id="45e5662cbbb3c35284b81863cd8050953ac79093" translate="yes" xml:space="preserve">
          <source>B, and X appears before Y in the Single Total Order.</source>
          <target state="translated">B,и X появляется перед Y в Едином общем порядке.</target>
        </trans-unit>
        <trans-unit id="a4bf1b75c4f0c15c46e32fb9f6447c95ca649c7c" translate="yes" xml:space="preserve">
          <source>B, and both A and B are sequentially consistent atomic operations 3) A is</source>
          <target state="translated">B,и A,и B являются последовательно последовательными атомными операциями 3)A является</target>
        </trans-unit>
        <trans-unit id="f4bf2b61e8848faddd0e0998dfeaa5d79d2e597c" translate="yes" xml:space="preserve">
          <source>B, then A appears to be evaluated before B in all contexts.</source>
          <target state="translated">В,затем А,как представляется,оценивается перед В во всех контекстах.</target>
        </trans-unit>
        <trans-unit id="cd0adbaaff060b07baf50fd24c9446ab105890da" translate="yes" xml:space="preserve">
          <source>B, then A precedes B in S 2) for every pair of atomic operations A and B on an object M, where A is</source>
          <target state="translated">B,затем A предшествует B в S 2)для каждой пары атомных операций A и B над объектом M,где A является</target>
        </trans-unit>
        <trans-unit id="b23fad0d216b95f70509ee04aeb30c3631070eb7" translate="yes" xml:space="preserve">
          <source>B, then B observes one of the following:</source>
          <target state="translated">Б,затем Б наблюдает одно из следующего:</target>
        </trans-unit>
        <trans-unit id="bfcc02cf7f3d23e187eac12bb5d9ac766d223025" translate="yes" xml:space="preserve">
          <source>B. Stroustrup (2000), &quot;The C++ Programming Language&quot;&lt;a href=&quot;http://stroustrup.com/3rd_safe.pdf&quot;&gt;Appendix E&quot;&lt;/a&gt;</source>
          <target state="translated">Б. Страуструп (2000), &amp;laquo;Язык программирования C ++&amp;raquo;, &lt;a href=&quot;http://stroustrup.com/3rd_safe.pdf&quot;&gt;Приложение E &amp;raquo;&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c1a4c571996703e3e33bba826b70616b63fd77ac" translate="yes" xml:space="preserve">
          <source>B...</source>
          <target state="translated">B...</target>
        </trans-unit>
        <trans-unit id="56809777eee50fda776cf36fcf8f615216fd8cfd" translate="yes" xml:space="preserve">
          <source>B: a) if A and B are both &lt;code&gt;memory_order_seq_cst&lt;/code&gt; operations, then A precedes B in S b) if A is a &lt;code&gt;memory_order_seq_cst&lt;/code&gt; operation, and B</source>
          <target state="translated">B: a) если A и B оба &lt;code&gt;memory_order_seq_cst&lt;/code&gt; операциями memory_order_seq_cst , то A предшествует B в S b) если A является операцией &lt;code&gt;memory_order_seq_cst&lt;/code&gt; , и B</target>
        </trans-unit>
        <trans-unit id="90973d18393c2644dbda93e71ed88917ecac4b89" translate="yes" xml:space="preserve">
          <source>BLAS-like slice of a valarray: starting index, length, stride</source>
          <target state="translated">BLAS-подобный ломтик валаррея:стартовый индекс,длина,шажок</target>
        </trans-unit>
        <trans-unit id="6909406a48bd13f476c9416147defba89909eee5" translate="yes" xml:space="preserve">
          <source>BUFSIZ</source>
          <target state="translated">BUFSIZ</target>
        </trans-unit>
        <trans-unit id="1afefdad8f394c65ed6d000a865d699a38489c6f" translate="yes" xml:space="preserve">
          <source>Bad address</source>
          <target state="translated">Плохой адрес</target>
        </trans-unit>
        <trans-unit id="100269e198b12a051ab659ff66bd324a08031278" translate="yes" xml:space="preserve">
          <source>Bad file descriptor</source>
          <target state="translated">Плохой дескриптор файла</target>
        </trans-unit>
        <trans-unit id="551cd91c11cd1216214e9eb9e26d84be076f8948" translate="yes" xml:space="preserve">
          <source>Bad message</source>
          <target state="translated">Плохое сообщение</target>
        </trans-unit>
        <trans-unit id="6bda91ea312720b2ec09940e98682034dcace7af" translate="yes" xml:space="preserve">
          <source>Barebones valarray-backed Matrix class with a &lt;a href=&quot;https://en.wikipedia.org/wiki/Trace_(linear_algebra)&quot;&gt;trace&lt;/a&gt; calculating function.</source>
          <target state="translated">Класс Matrix с поддержкой Barebones Valarray и функцией вычисления &lt;a href=&quot;https://en.wikipedia.org/wiki/Trace_(linear_algebra)&quot;&gt;трассировки&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="077fe9c54ed5ed26fa547f4ded3ef9a9bb066d65" translate="yes" xml:space="preserve">
          <source>Base</source>
          <target state="translated">Base</target>
        </trans-unit>
        <trans-unit id="3bcdbe728e1760eac3fdacb54d72efd9ba89bbaa" translate="yes" xml:space="preserve">
          <source>Base specifiers and member initializer lists</source>
          <target state="translated">Базовые спецификаторы и списки инициализаторов членов</target>
        </trans-unit>
        <trans-unit id="b1604e75055b78b9111dd5b59253504e535b02f2" translate="yes" xml:space="preserve">
          <source>Base::vf (whether or not the word &lt;code&gt;override&lt;/code&gt; is used in its declaration).</source>
          <target state="translated">Base :: vf (независимо от того, используется ли слово &lt;code&gt;override&lt;/code&gt; в его объявлении).</target>
        </trans-unit>
        <trans-unit id="5899059fb2d20a463b2a04266836e60a1b0645c6" translate="yes" xml:space="preserve">
          <source>BaseCharacteristic</source>
          <target state="translated">BaseCharacteristic</target>
        </trans-unit>
        <trans-unit id="aa2c96dacf00c451ef465f6115a45a20bccf1256" translate="yes" xml:space="preserve">
          <source>Basic</source>
          <target state="translated">Basic</target>
        </trans-unit>
        <trans-unit id="e4e7ae591b0abd861a75d3fa39a7cab907d2a5c8" translate="yes" xml:space="preserve">
          <source>Basic concepts</source>
          <target state="translated">Основные концепции</target>
        </trans-unit>
        <trans-unit id="1dda37dbdb1d5ae832ec94dde2b8248f41206b6f" translate="yes" xml:space="preserve">
          <source>Basic exception guarantee</source>
          <target state="translated">Гарантия основного исключения</target>
        </trans-unit>
        <trans-unit id="beb8cd5e0f8e7a06f8d36dc83c4364f7f79078fa" translate="yes" xml:space="preserve">
          <source>Basic operations</source>
          <target state="translated">Основные операции</target>
        </trans-unit>
        <trans-unit id="3fc431b29bb2c2516db706b2f480a558166eba6d" translate="yes" xml:space="preserve">
          <source>Basic types</source>
          <target state="translated">Основные типы</target>
        </trans-unit>
        <trans-unit id="928b9aad5c0144f195e57231e11400d2c46ac0fb" translate="yes" xml:space="preserve">
          <source>Basic types (e.g. &lt;code&gt;&lt;a href=&quot;types/size_t&quot;&gt;std::size_t&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;types/nullptr_t&quot;&gt;std::nullptr_t&lt;/a&gt;&lt;/code&gt;), RTTI (e.g. &lt;code&gt;&lt;a href=&quot;types/type_info&quot;&gt;std::type_info&lt;/a&gt;&lt;/code&gt;), type traits (e.g. &lt;code&gt;&lt;a href=&quot;types/is_integral&quot;&gt;std::is_integral&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;types/rank&quot;&gt;std::rank&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">Основные типы (например, &lt;code&gt;&lt;a href=&quot;types/size_t&quot;&gt;std::size_t&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;types/nullptr_t&quot;&gt;std::nullptr_t&lt;/a&gt;&lt;/code&gt; ), RTTI (например, &lt;code&gt;&lt;a href=&quot;types/type_info&quot;&gt;std::type_info&lt;/a&gt;&lt;/code&gt; ), признаки типа (например, &lt;code&gt;&lt;a href=&quot;types/is_integral&quot;&gt;std::is_integral&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;types/rank&quot;&gt;std::rank&lt;/a&gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="5c2ef712eeb88ff3db947441935726076c82c0bb" translate="yes" xml:space="preserve">
          <source>BasicLockable</source>
          <target state="translated">BasicLockable</target>
        </trans-unit>
        <trans-unit id="90870ca4432acfd7b541273fcb2661e871119daf" translate="yes" xml:space="preserve">
          <source>Because &lt;a href=&quot;../../language/template_argument_deduction&quot;&gt;template argument deduction&lt;/a&gt; does not consider implicit conversions, these operators cannot be used for mixed integer/complex arithmetic. In all cases, the scalar must have the same type as the underlying type of the complex number.</source>
          <target state="translated">Поскольку при &lt;a href=&quot;../../language/template_argument_deduction&quot;&gt;выводе аргументов шаблона&lt;/a&gt; не учитываются неявные преобразования, эти операторы нельзя использовать для смешанной целочисленной / комплексной арифметики. Во всех случаях скаляр должен иметь тот же тип, что и базовый тип комплексного числа.</target>
        </trans-unit>
        <trans-unit id="d1f6ad19289944156463986759f118c4be88ae5a" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;&lt;a href=&quot;../memory/unique_ptr&quot;&gt;std::unique_ptr&lt;/a&gt;&lt;/code&gt; requires that the pointed-to type is a complete type in any context where the deleter is called, the destructor and the copy/move assignment operators must be user-declared and defined out-of-line, in the implementation file, where the implementation class is complete. This suppresses the move constructor, which has to be defined or defaulted.</source>
          <target state="translated">Поскольку &lt;code&gt;&lt;a href=&quot;../memory/unique_ptr&quot;&gt;std::unique_ptr&lt;/a&gt;&lt;/code&gt; требует, чтобы указательный тип был полным типом в любом контексте, где вызывается средство удаления, деструктор и операторы назначения копирования / перемещения должны быть объявлены пользователем и определены вне строки в реализации файл, в котором класс реализации завершен. Это подавляет конструктор перемещения, который должен быть определен или установлен по умолчанию.</target>
        </trans-unit>
        <trans-unit id="ee2e8f20b5463733118ed9ad438d1e579dcd6096" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;assert&lt;/code&gt; is a &lt;a href=&quot;../preprocessor/replace&quot;&gt;function-like macro&lt;/a&gt;, commas anywhere in condition that are not protected by parentheses are interpreted as macro argument separators. Such commas are often found in template argument lists and list-initialization:</source>
          <target state="translated">Поскольку &lt;code&gt;assert&lt;/code&gt; является &lt;a href=&quot;../preprocessor/replace&quot;&gt;функционально-подобным макросом&lt;/a&gt; , запятые в любом месте условия, которые не защищены скобками, интерпретируются как разделители аргументов макроса. Такие запятые часто встречаются в списках аргументов шаблона и инициализации списка:</target>
        </trans-unit>
        <trans-unit id="53424f213e903d21acf1145501cd3bd319bc65a2" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;regex_match&lt;/code&gt; only considers full matches, the same regex may give different matches between &lt;code&gt;regex_match&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;regex_search&quot;&gt;std::regex_search&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">Поскольку &lt;code&gt;regex_match&lt;/code&gt; рассматривает только полные совпадения, один и тот же регулярное выражение может давать разные совпадения между &lt;code&gt;regex_match&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;regex_search&quot;&gt;std::regex_search&lt;/a&gt;&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="4c2c9164d9adc62f94d817ac748a2112477652ed" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;setlocale&lt;/code&gt; modifies global state which affects execution of locale-dependent functions, it is undefined behavior to call it from one thread, while another thread is executing any of the following functions: &lt;code&gt;&lt;a href=&quot;../io/c/printf&quot;&gt;std::fprintf&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;std::isprint&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../string/wide/iswdigit&quot;&gt;std::iswdigit&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;localeconv&quot;&gt;std::localeconv&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;std::tolower&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../io/c/scanf&quot;&gt;std::fscanf&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;std::ispunct&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../string/wide/iswgraph&quot;&gt;std::iswgraph&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../string/multibyte/mblen&quot;&gt;std::mblen&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;std::toupper&lt;/code&gt;, &lt;code&gt;std::isalnum&lt;/code&gt;, &lt;code&gt;std::isspace&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../string/wide/iswlower&quot;&gt;std::iswlower&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../string/multibyte/mbstowcs&quot;&gt;std::mbstowcs&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../string/wide/towlower&quot;&gt;std::towlower&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;std::isalpha&lt;/code&gt;, &lt;code&gt;std::isupper&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../string/wide/iswprint&quot;&gt;std::iswprint&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../string/multibyte/mbtowc&quot;&gt;std::mbtowc&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../string/wide/towupper&quot;&gt;std::towupper&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;std::isblank&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../string/wide/iswalnum&quot;&gt;std::iswalnum&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../string/wide/iswpunct&quot;&gt;std::iswpunct&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;std::setlocale&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../string/wide/wcscoll&quot;&gt;std::wcscoll&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;std::iscntrl&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../string/wide/iswalpha&quot;&gt;std::iswalpha&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../string/wide/iswspace&quot;&gt;std::iswspace&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../string/byte/strcoll&quot;&gt;std::strcoll&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../string/wide/wcstof&quot;&gt;std::wcstod&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;std::isdigit&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../string/wide/iswblank&quot;&gt;std::iswblank&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../string/wide/iswupper&quot;&gt;std::iswupper&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../string/byte/strerror&quot;&gt;std::strerror&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../string/multibyte/wcstombs&quot;&gt;std::wcstombs&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;std::isgraph&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../string/wide/iswcntrl&quot;&gt;std::iswcntrl&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../string/wide/iswxdigit&quot;&gt;std::iswxdigit&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../string/byte/strtof&quot;&gt;std::strtod&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../string/wide/wcsxfrm&quot;&gt;std::wcsxfrm&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;std::islower&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../string/wide/iswctype&quot;&gt;std::iswctype&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;std::isxdigit&lt;/code&gt;.</source>
          <target state="translated">Поскольку &lt;code&gt;setlocale&lt;/code&gt; изменяет глобальное состояние, которое влияет на выполнение зависящих от локали функций, вызывать его из одного потока не определено, в то время как другой поток выполняет любую из следующих функций: &lt;code&gt;&lt;a href=&quot;../io/c/printf&quot;&gt;std::fprintf&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;std::isprint&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../string/wide/iswdigit&quot;&gt;std::iswdigit&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;localeconv&quot;&gt;std::localeconv&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;std::tolower&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../io/c/scanf&quot;&gt;std::fscanf&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;std::ispunct&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../string/wide/iswgraph&quot;&gt;std::iswgraph&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../string/multibyte/mblen&quot;&gt;std::mblen&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;std::toupper&lt;/code&gt; , &lt;code&gt;std::isalnum&lt;/code&gt; , &lt;code&gt;std::isspace&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../string/wide/iswlower&quot;&gt;std::iswlower&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../string/multibyte/mbstowcs&quot;&gt;std::mbstowcs&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../string/wide/towlower&quot;&gt;std::towlower&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;std::isalpha&lt;/code&gt; , &lt;code&gt;std::isupper&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../string/wide/iswprint&quot;&gt;std::iswprint&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../string/multibyte/mbtowc&quot;&gt;std::mbtowc&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../string/wide/towupper&quot;&gt;std::towupper&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;std::isblank&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../string/wide/iswalnum&quot;&gt;std::iswalnum&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../string/wide/iswpunct&quot;&gt;std::iswpunct&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;std::setlocale&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../string/wide/wcscoll&quot;&gt;std::wcscoll&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;std::iscntrl&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../string/wide/iswalpha&quot;&gt;std::iswalpha&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../string/wide/iswspace&quot;&gt;std::iswspace&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../string/byte/strcoll&quot;&gt;std::strcoll&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../string/wide/wcstof&quot;&gt;std::wcstod&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;std::isdigit&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../string/wide/iswblank&quot;&gt;std::iswblank&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../string/wide/iswupper&quot;&gt;std::iswupper&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../string/byte/strerror&quot;&gt;std::strerror&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../string/multibyte/wcstombs&quot;&gt;std::wcstombs&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;std::isgraph&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../string/wide/iswcntrl&quot;&gt;std::iswcntrl&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../string/wide/iswxdigit&quot;&gt;std::iswxdigit&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../string/byte/strtof&quot;&gt;std::strtod&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../string/wide/wcsxfrm&quot;&gt;std::wcsxfrm&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;std::islower&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../string/wide/iswctype&quot;&gt;std::iswctype&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;std::isxdigit&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="89d8571118516caef2a1d25c02e79eb519ae1beb" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;std::remove&lt;/code&gt; takes &lt;code&gt;value&lt;/code&gt; by reference, it can have unexpected behavior if it is a reference to an element of the range &lt;code&gt;[first, last)&lt;/code&gt;.</source>
          <target state="translated">Поскольку &lt;code&gt;std::remove&lt;/code&gt; принимает &lt;code&gt;value&lt;/code&gt; по ссылке, оно может иметь неожиданное поведение, если оно является ссылкой на элемент диапазона &lt;code&gt;[first, last)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="20471d58e5d2833a1993c6fb0cc59d825025d821" translate="yes" xml:space="preserve">
          <source>Because C++ copies and copy-assigns objects of user-defined types in various situations (passing/returning by value, manipulating a container, etc), these special member functions will be called, if accessible, and if they are not user-defined, they are implicitly-defined by the compiler.</source>
          <target state="translated">Поскольку C++копирует и копирует объекты пользовательских типов в различных ситуациях (передача/возвращение по значению,манипулирование контейнером и т.д.),эти специальные функции-члены будут вызываться,если они доступны,а если они не являются пользовательскими,то они неявно определяются компилятором.</target>
        </trans-unit>
        <trans-unit id="517acf744121042d5f84823be03eeb3b29badaed" translate="yes" xml:space="preserve">
          <source>Because C++ interprets a character immediately following a string literal as a &lt;a href=&quot;../language/user_literal&quot;&gt;user-defined string literal&lt;/a&gt;, C code such as &lt;code&gt;printf(&quot;%&quot;PRId64&quot;\n&quot;,n);&lt;/code&gt; is invalid C++ and requires a space before &lt;code&gt;PRId64&lt;/code&gt;.</source>
          <target state="translated">Поскольку C ++ интерпретирует символ, следующий непосредственно за строковым литералом, как определяемый &lt;a href=&quot;../language/user_literal&quot;&gt;пользователем строковый литерал&lt;/a&gt; , код C, такой как &lt;code&gt;printf(&quot;%&quot;PRId64&quot;\n&quot;,n);&lt;/code&gt; является недействительным C ++ и требует пробела перед &lt;code&gt;PRId64&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="219e7d89011a786888d2482ec713003b1ecb5238" translate="yes" xml:space="preserve">
          <source>Because POSIX uses &quot;leftmost longest&quot; matching rule (the longest matching subsequence is matched, and if there are several such subsequences, the first one is matched), it is not suitable, for example, for parsing markup languages: a POSIX regex such as &lt;code&gt;&quot;&amp;lt;tag[^&amp;gt;]*&amp;gt;.*&amp;lt;/tag&amp;gt;&quot;&lt;/code&gt; would match everything from the first &lt;code&gt;&quot;&amp;lt;tag&quot;&lt;/code&gt; to the last &lt;code&gt;&quot;&amp;lt;/tag&amp;gt;&quot;&lt;/code&gt;, including every &lt;code&gt;&quot;&amp;lt;/tag&amp;gt;&quot;&lt;/code&gt; and &lt;code&gt;&quot;&amp;lt;tag&amp;gt;&quot;&lt;/code&gt; inbetween. On the other hand, ECMAScript supports non-greedy matches, and the ECMAScript regex &lt;code&gt;&quot;&amp;lt;tag[^&amp;gt;]*&amp;gt;.*?&amp;lt;/tag&amp;gt;&quot;&lt;/code&gt; would match only until the first closing tag.</source>
          <target state="translated">Поскольку POSIX использует правило сопоставления &amp;laquo;самый длинный самый длинный&amp;raquo; (самая длинная совпадающая подпоследовательность сопоставляется, и если имеется несколько таких подпоследовательностей, первая соответствует), то это не подходит, например, для анализа языков разметки: регулярное выражение POSIX, такое как &lt;code&gt;&quot;&amp;lt;tag[^&amp;gt;]*&amp;gt;.*&amp;lt;/tag&amp;gt;&quot;&lt;/code&gt; будет соответствовать всему от первого &lt;code&gt;&quot;&amp;lt;tag&quot;&lt;/code&gt; до последнего &lt;code&gt;&quot;&amp;lt;/tag&amp;gt;&quot;&lt;/code&gt; , включая все &lt;code&gt;&quot;&amp;lt;/tag&amp;gt;&quot;&lt;/code&gt; и &lt;code&gt;&quot;&amp;lt;tag&amp;gt;&quot;&lt;/code&gt; между. С другой стороны, ECMAScript поддерживает не жадные совпадения, а регулярное выражение ECMAScript &lt;code&gt;&quot;&amp;lt;tag[^&amp;gt;]*&amp;gt;.*?&amp;lt;/tag&amp;gt;&quot;&lt;/code&gt; будет соответствовать только до первого закрывающего тега.</target>
        </trans-unit>
        <trans-unit id="b08396994d212dfe6289df9ec245e89c348fd76a" translate="yes" xml:space="preserve">
          <source>Because a pair of brackets following the keyword &lt;code&gt;delete&lt;/code&gt; is always interpreted as the array form of delete, a lambda-expression with empty capture list immediately after &lt;code&gt;delete&lt;/code&gt; must be enclosed in parentheses.</source>
          <target state="translated">Поскольку пара скобок после ключевого слова &lt;code&gt;delete&lt;/code&gt; всегда интерпретируется как форма удаления массива, лямбда-выражение с пустым списком захвата сразу после &lt;code&gt;delete&lt;/code&gt; должно быть заключено в скобки.</target>
        </trans-unit>
        <trans-unit id="672ca8a2390d44e9109a5b0f60fc6036a7a4d8de" translate="yes" xml:space="preserve">
          <source>Because a temporary copy of the object is constructed during post-increment and post-decrement,</source>
          <target state="translated">Потому что временная копия объекта создается во время пост-инкремента и после декремента,</target>
        </trans-unit>
        <trans-unit id="52aa0f31213848ac5fabf7dcecdd2f55a132ed32" translate="yes" xml:space="preserve">
          <source>Because array elements cannot have incomplete type, multidimensional arrays cannot have unknown bound in a dimension other than the first:</source>
          <target state="translated">Поскольку элементы массива не могут иметь неполный тип,многомерные массивы не могут иметь неизвестную границу в измерении,отличном от первой:</target>
        </trans-unit>
        <trans-unit id="ebfd5a82361d89ed63a37a3062866f4e78777689" translate="yes" xml:space="preserve">
          <source>Because bit fields do not necessarily begin at the beginning of a byte, address of a bit field cannot be taken. Pointers and non-const references to bit fields are not possible. When &lt;a href=&quot;reference_initialization&quot;&gt;initializing a const reference&lt;/a&gt; from a bit field, a temporary is created (its type is the type of the bit field), copy initialized with the value of the bit field, and the reference is bound to that temporary.</source>
          <target state="translated">Поскольку битовые поля не обязательно начинаются в начале байта, адрес битового поля не может быть взят. Указатели и неконстантные ссылки на битовые поля невозможны. При &lt;a href=&quot;reference_initialization&quot;&gt;инициализации константной ссылки&lt;/a&gt; из битового поля создается временный объект (его тип является типом битового поля), копия инициализируется значением битового поля, и ссылка привязывается к этому временному объекту.</target>
        </trans-unit>
        <trans-unit id="165915841c598e436e4f4ef5949ddbdf66094494" translate="yes" xml:space="preserve">
          <source>Because both &lt;code&gt;iterator&lt;/code&gt; and &lt;code&gt;const_iterator&lt;/code&gt; are constant iterators (and may in fact be the same type), it is not possible to mutate the elements of the container through an iterator returned by any of these member functions.</source>
          <target state="translated">Поскольку &lt;code&gt;iterator&lt;/code&gt; и &lt;code&gt;const_iterator&lt;/code&gt; являются постоянными итераторами (и на самом деле могут иметь один и тот же тип), невозможно изменить элементы контейнера через итератор, возвращаемый любой из этих функций-членов.</target>
        </trans-unit>
        <trans-unit id="b5ebf1a72c58aab22e302945eaa39d0cb80ef7c4" translate="yes" xml:space="preserve">
          <source>Because comments &lt;a href=&quot;language/translation_phases&quot;&gt;are removed&lt;/a&gt; before the preprocessor stage, a macro cannot be used to form a comment and an unterminated C-style comment doesn't spill over from an #include'd file.</source>
          <target state="translated">Поскольку комментарии &lt;a href=&quot;language/translation_phases&quot;&gt;удаляются&lt;/a&gt; до стадии препроцессора, макрос не может быть использован для формирования комментария, и из файла # include'd не выводится не определенный комментарий в стиле C.</target>
        </trans-unit>
        <trans-unit id="8283f8b80380fa4e852889799ea8ad590ba8476b" translate="yes" xml:space="preserve">
          <source>Because condition #2 is tested before condition #3, the input line that exactly fits the buffer does not trigger failbit.</source>
          <target state="translated">Поскольку условие #2 тестируется перед условием #3,входная строка,которая точно подходит к буферу,не запускает failbit.</target>
        </trans-unit>
        <trans-unit id="515369749f5f51688eb83df1f7be779be9524043" translate="yes" xml:space="preserve">
          <source>Because copying &lt;code&gt;std::domain_error&lt;/code&gt; is not permitted to throw exceptions, this message is typically stored internally as a separately-allocated reference-counted string. This is also why there is no constructor taking &lt;code&gt;std::string&amp;amp;&amp;amp;&lt;/code&gt;: it would have to copy the content anyway.</source>
          <target state="translated">Поскольку копирование &lt;code&gt;std::domain_error&lt;/code&gt; не разрешает генерировать исключения, это сообщение обычно хранится внутри как отдельно выделенная строка с подсчетом ссылок. По этой же причине нет конструктора, принимающего &lt;code&gt;std::string&amp;amp;&amp;amp;&lt;/code&gt; : ему бы все равно пришлось копировать содержимое.</target>
        </trans-unit>
        <trans-unit id="6ecb376ab21a6f256feb79f178105c51676d0d60" translate="yes" xml:space="preserve">
          <source>Because copying &lt;code&gt;std::exception&lt;/code&gt; is not permitted to throw exceptions, when derived classes (such as &lt;code&gt;&lt;a href=&quot;../runtime_error/runtime_error&quot;&gt;std::runtime_error&lt;/a&gt;&lt;/code&gt;) have to manage a user-defined diagnostic message, it is typically implemented as a copy-on-write string.</source>
          <target state="translated">Поскольку копирование &lt;code&gt;std::exception&lt;/code&gt; не разрешено генерировать исключения, когда производные классы (такие как &lt;code&gt;&lt;a href=&quot;../runtime_error/runtime_error&quot;&gt;std::runtime_error&lt;/a&gt;&lt;/code&gt; ) должны управлять определенным пользователем диагностическим сообщением, это обычно реализуется как строка копирования при записи.</target>
        </trans-unit>
        <trans-unit id="3da5bbc4235f4c93a80ce50bc387f0b13711c29a" translate="yes" xml:space="preserve">
          <source>Because copying &lt;code&gt;std::invalid_argument&lt;/code&gt; is not permitted to throw exceptions, this message is typically stored internally as a separately-allocated reference-counted string. This is also why there is no constructor taking &lt;code&gt;std::string&amp;amp;&amp;amp;&lt;/code&gt;: it would have to copy the content anyway.</source>
          <target state="translated">Поскольку копирование &lt;code&gt;std::invalid_argument&lt;/code&gt; не разрешает генерировать исключения, это сообщение обычно хранится внутри как отдельно выделенная строка с подсчетом ссылок. По этой же причине нет конструктора, принимающего &lt;code&gt;std::string&amp;amp;&amp;amp;&lt;/code&gt; : ему бы все равно пришлось копировать содержимое.</target>
        </trans-unit>
        <trans-unit id="976f924388c6dee8de713ae69d4c65520bd93b74" translate="yes" xml:space="preserve">
          <source>Because copying &lt;code&gt;std::length_error&lt;/code&gt; is not permitted to throw exceptions, this message is typically stored internally as a separately-allocated reference-counted string. This is also why there is no constructor taking &lt;code&gt;std::string&amp;amp;&amp;amp;&lt;/code&gt;: it would have to copy the content anyway.</source>
          <target state="translated">Поскольку копирование &lt;code&gt;std::length_error&lt;/code&gt; не разрешает генерировать исключения, это сообщение обычно хранится внутри как отдельно выделенная строка с подсчетом ссылок. По этой же причине нет конструктора, принимающего &lt;code&gt;std::string&amp;amp;&amp;amp;&lt;/code&gt; : ему бы все равно пришлось копировать содержимое.</target>
        </trans-unit>
        <trans-unit id="d329778fe1d9574d6ed3f3facfee5d31e87476c0" translate="yes" xml:space="preserve">
          <source>Because copying &lt;code&gt;std::logic_error&lt;/code&gt; is not permitted to throw exceptions, this message is typically stored internally as a separately-allocated reference-counted string. This is also why there is no constructor taking &lt;code&gt;std::string&amp;amp;&amp;amp;&lt;/code&gt;: it would have to copy the content anyway.</source>
          <target state="translated">Поскольку копирование &lt;code&gt;std::logic_error&lt;/code&gt; не разрешает генерировать исключения, это сообщение обычно хранится внутри как отдельно выделенная строка с подсчетом ссылок. По этой же причине нет конструктора, принимающего &lt;code&gt;std::string&amp;amp;&amp;amp;&lt;/code&gt; : ему бы все равно пришлось копировать содержимое.</target>
        </trans-unit>
        <trans-unit id="018a393e39e3b182ca10487c347de04d186be7cb" translate="yes" xml:space="preserve">
          <source>Because copying &lt;code&gt;std::out_of_range&lt;/code&gt; is not permitted to throw exceptions, this message is typically stored internally as a separately-allocated reference-counted string. This is also why there is no constructor taking &lt;code&gt;std::string&amp;amp;&amp;amp;&lt;/code&gt;: it would have to copy the content anyway.</source>
          <target state="translated">Поскольку копирование &lt;code&gt;std::out_of_range&lt;/code&gt; не разрешает генерировать исключения, это сообщение обычно хранится внутри как отдельно выделенная строка с подсчетом ссылок. По этой же причине нет конструктора, принимающего &lt;code&gt;std::string&amp;amp;&amp;amp;&lt;/code&gt; : ему бы все равно пришлось копировать содержимое.</target>
        </trans-unit>
        <trans-unit id="6f345edfef34a7652c4a3e8c88a8d58867553acd" translate="yes" xml:space="preserve">
          <source>Because copying &lt;code&gt;std::overflow_error&lt;/code&gt; is not permitted to throw exceptions, this message is typically stored internally as a separately-allocated reference-counted string. This is also why there is no constructor taking &lt;code&gt;std::string&amp;amp;&amp;amp;&lt;/code&gt;: it would have to copy the content anyway.</source>
          <target state="translated">Поскольку копирование &lt;code&gt;std::overflow_error&lt;/code&gt; не разрешает генерировать исключения, это сообщение обычно хранится внутри как отдельно выделенная строка с подсчетом ссылок. По этой же причине нет конструктора, принимающего &lt;code&gt;std::string&amp;amp;&amp;amp;&lt;/code&gt; : ему бы все равно пришлось копировать содержимое.</target>
        </trans-unit>
        <trans-unit id="57850b32155ea45ecb9e2f25f07c6b9ec1154de7" translate="yes" xml:space="preserve">
          <source>Because copying &lt;code&gt;std::range_error&lt;/code&gt; is not permitted to throw exceptions, this message is typically stored internally as a separately-allocated reference-counted string. This is also why there is no constructor taking &lt;code&gt;std::string&amp;amp;&amp;amp;&lt;/code&gt;: it would have to copy the content anyway.</source>
          <target state="translated">Поскольку копирование &lt;code&gt;std::range_error&lt;/code&gt; не разрешает генерировать исключения, это сообщение обычно хранится внутри как отдельно выделенная строка с подсчетом ссылок. По этой же причине нет конструктора, принимающего &lt;code&gt;std::string&amp;amp;&amp;amp;&lt;/code&gt; : ему бы все равно пришлось копировать содержимое.</target>
        </trans-unit>
        <trans-unit id="402cb452aa1c6e8357e1ec6173212b86a7d33f65" translate="yes" xml:space="preserve">
          <source>Because copying &lt;code&gt;std::runtime_error&lt;/code&gt; is not permitted to throw exceptions, this message is typically stored internally as a separately-allocated reference-counted string. This is also why there is no constructor taking &lt;code&gt;std::string&amp;amp;&amp;amp;&lt;/code&gt;: it would have to copy the content anyway.</source>
          <target state="translated">Поскольку копирование &lt;code&gt;std::runtime_error&lt;/code&gt; не разрешает генерировать исключения, это сообщение обычно хранится внутри как отдельно выделенная строка с подсчетом ссылок. По этой же причине нет конструктора, принимающего &lt;code&gt;std::string&amp;amp;&amp;amp;&lt;/code&gt; : ему бы все равно пришлось копировать содержимое.</target>
        </trans-unit>
        <trans-unit id="37068db94b3bf966577e4aa45601ece784efa76c" translate="yes" xml:space="preserve">
          <source>Because copying &lt;code&gt;std::underflow_error&lt;/code&gt; is not permitted to throw exceptions, this message is typically stored internally as a separately-allocated reference-counted string. This is also why there is no constructor taking &lt;code&gt;std::string&amp;amp;&amp;amp;&lt;/code&gt;: it would have to copy the content anyway.</source>
          <target state="translated">Поскольку копирование &lt;code&gt;std::underflow_error&lt;/code&gt; не разрешает генерировать исключения, это сообщение обычно хранится внутри как отдельно выделенная строка с подсчетом ссылок. По этой же причине нет конструктора, принимающего &lt;code&gt;std::string&amp;amp;&amp;amp;&lt;/code&gt; : ему бы все равно пришлось копировать содержимое.</target>
        </trans-unit>
        <trans-unit id="9379074a5072b78ee4eeef2326fa80c14b76e9c1" translate="yes" xml:space="preserve">
          <source>Because copying a standard library class derived from &lt;code&gt;std::exception&lt;/code&gt; is not permitted to throw exceptions, this message is typically stored internally as a separately-allocated reference-counted string.</source>
          <target state="translated">Поскольку копирование стандартного библиотечного класса, полученного из &lt;code&gt;std::exception&lt;/code&gt; , не позволяет генерировать исключения, это сообщение обычно хранится внутри как отдельно выделенная строка с подсчетом ссылок.</target>
        </trans-unit>
        <trans-unit id="7ae6e0e63afdccc5b632c5cb746027af8b35d225" translate="yes" xml:space="preserve">
          <source>Because correct C++ programs are free of undefined behavior, compilers may produce unexpected results when a program that actually has UB is compiled with optimization enabled:</source>
          <target state="translated">Поскольку корректные программы на Си++свободны от неопределённого поведения,компиляторы могут выдавать неожиданные результаты,когда программа,в которой на самом деле есть UB,компилируется с включенной оптимизацией:</target>
        </trans-unit>
        <trans-unit id="4626ae145ee72ecf116829f511a5171a1ace5607" translate="yes" xml:space="preserve">
          <source>Because currency symbol is optional if &lt;code&gt;showbase&lt;/code&gt; is off but the entire multicharacter &lt;code&gt;negative_sign()&lt;/code&gt; is required, given the formatting pattern &lt;code&gt;{sign, value, space, symbol}&lt;/code&gt; with &lt;code&gt;showbase&lt;/code&gt; off and negative_sign of &lt;code&gt;&quot;-&quot;&lt;/code&gt;, the string &lt;code&gt;&quot;-1.23 &amp;euro;&quot;&lt;/code&gt; parses as &lt;code&gt;-123&lt;/code&gt; and leaves &quot;&amp;euro;&quot; unconsumed on the input stream, but if negative_sign is &lt;code&gt;&quot;()&quot;&lt;/code&gt;, the string &lt;code&gt;&quot;(1.23 &amp;euro;)&quot;&lt;/code&gt; is consumed completely.</source>
          <target state="translated">Поскольку символ валюты необязателен, если &lt;code&gt;showbase&lt;/code&gt; выключен, но требуется весь &lt;code&gt;&quot;-1.23 &amp;euro;&quot;&lt;/code&gt; &lt;code&gt;negative_sign()&lt;/code&gt; , учитывая шаблон форматирования &lt;code&gt;{sign, value, space, symbol}&lt;/code&gt; с отключенной &lt;code&gt;showbase&lt;/code&gt; и отрицательным_сигналом &lt;code&gt;&quot;-&quot;&lt;/code&gt; , строка &quot;-1.23 &amp;euro;&quot; анализируется как &lt;code&gt;-123&lt;/code&gt; и оставляет &amp;laquo;&amp;euro;&amp;raquo; неизрасходованным во входном потоке, но если отрицательный_сигнал равен &lt;code&gt;&quot;()&quot;&lt;/code&gt; , строка &lt;code&gt;&quot;(1.23 &amp;euro;)&quot;&lt;/code&gt; используется полностью.</target>
        </trans-unit>
        <trans-unit id="9c7bc26a7deccd5754905307ee4096fdff25e864" translate="yes" xml:space="preserve">
          <source>Because each &lt;code&gt;std::array&amp;lt;T, N&amp;gt;&lt;/code&gt; is a fixed-size container, the value returned by &lt;code&gt;max_size&lt;/code&gt; equals &lt;code&gt;N&lt;/code&gt; (which is also the value returned by &lt;code&gt;&lt;a href=&quot;size&quot;&gt;size&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">Поскольку каждый &lt;code&gt;std::array&amp;lt;T, N&amp;gt;&lt;/code&gt; является контейнером фиксированного размера, значение, возвращаемое &lt;code&gt;max_size&lt;/code&gt; , равно &lt;code&gt;N&lt;/code&gt; (которое также является значением, возвращаемым &lt;code&gt;&lt;a href=&quot;size&quot;&gt;size&lt;/a&gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="d1d63aeceb4f0e5680d16d7c267971930a3bce18" translate="yes" xml:space="preserve">
          <source>Because locales and facets must be available for the IO stream objects with static storage duration, such as &lt;code&gt;&lt;a href=&quot;../../../io/cout&quot;&gt;std::cout&lt;/a&gt;&lt;/code&gt;, typical implementations let implicit default constructor zero-initialize the contents of &lt;code&gt;&lt;a href=&quot;../id&quot;&gt;std::locale::id&lt;/a&gt;&lt;/code&gt; during static initialization (before constructors run for static objects), and when a facet is added to any locale for the first time, the locale completes initialization of the facet's &lt;code&gt;id&lt;/code&gt;.</source>
          <target state="translated">Поскольку локали и фасеты должны быть доступны для потоковых объектов ввода-вывода со статической продолжительностью хранения, таких как &lt;code&gt;&lt;a href=&quot;../../../io/cout&quot;&gt;std::cout&lt;/a&gt;&lt;/code&gt; , типичные реализации позволяют неявному конструктору по умолчанию инициализировать ноль содержимого &lt;code&gt;&lt;a href=&quot;../id&quot;&gt;std::locale::id&lt;/a&gt;&lt;/code&gt; во время статической инициализации (до запуска конструкторов) для статических объектов), и когда фасет добавляется в любую локаль в первый раз, локаль завершает инициализацию &lt;code&gt;id&lt;/code&gt; фасета .</target>
        </trans-unit>
        <trans-unit id="bad967f19eac295089f2fac67901872b755b210a" translate="yes" xml:space="preserve">
          <source>Because most conversion specifiers first consume all consecutive whitespace, code such as.</source>
          <target state="translated">Потому что большинство спецификаторов преобразования сначала потребляют все последовательные пробельные символы,например,код.</target>
        </trans-unit>
        <trans-unit id="baeb5892e67350663f292930f0546a18e00a4338" translate="yes" xml:space="preserve">
          <source>Because of argument-dependent lookup, non-member functions and non-member operators defined in the same namespace as a class are considered part of the public interface of that class (if they are found through ADL) &lt;sup id=&quot;cite_ref-1&quot;&gt;&lt;a href=&quot;adl#cite_note-1&quot;&gt;[1]&lt;/a&gt;&lt;/sup&gt;.  ADL is the reason behind the established idiom for swapping two objects in generic code:</source>
          <target state="translated">Из-за зависимого от аргумента поиска функции, не являющиеся членами, и операторы, не являющиеся членами, определенные в том же пространстве имен, что и класс, считаются частью открытого интерфейса этого класса (если они обнаруживаются через ADL) &lt;sup id=&quot;cite_ref-1&quot;&gt;&lt;a href=&quot;adl#cite_note-1&quot;&gt;[1]&lt;/a&gt;&lt;/sup&gt; . ADL является причиной установленной идиомы для замены двух объектов в общем коде:</target>
        </trans-unit>
        <trans-unit id="e744698bc894ffd70f35015c02148587a2699846" translate="yes" xml:space="preserve">
          <source>Because of the &lt;a href=&quot;implicit_cast&quot;&gt;array-to-pointer&lt;/a&gt; implicit conversion, pointer to the first element of an array can be initialized with an expression of array type:</source>
          <target state="translated">Из &lt;a href=&quot;implicit_cast&quot;&gt;-за&lt;/a&gt; неявного преобразования массива в указатель указатель на первый элемент массива может быть инициализирован выражением типа массива:</target>
        </trans-unit>
        <trans-unit id="940a6ecf2484f5047dcbde372b969605698443fc" translate="yes" xml:space="preserve">
          <source>Because of the &lt;a href=&quot;implicit_cast&quot;&gt;derived-to-base&lt;/a&gt; implicit conversion for pointers, pointer to a base class can be initialized with the address of a derived class:</source>
          <target state="translated">Из &lt;a href=&quot;implicit_cast&quot;&gt;-за&lt;/a&gt; неявного преобразования производных в базу для указателей указатель на базовый класс может быть инициализирован с адресом производного класса:</target>
        </trans-unit>
        <trans-unit id="6d22544963a037f06cda7296c1659e0c18ea6896" translate="yes" xml:space="preserve">
          <source>Because of the rule above, if initialization of some object &lt;code&gt;o1&lt;/code&gt; refers to an namespace-scope object &lt;code&gt;o2&lt;/code&gt;, which potentially requires dynamic initialization, but is defined later in the same translation unit, it is unspecified whether the value of &lt;code&gt;o2&lt;/code&gt; used will be the value of the fully initialized &lt;code&gt;o2&lt;/code&gt; (because the compiler promoted initialization of &lt;code&gt;o2&lt;/code&gt; to compile time) or will be the value of &lt;code&gt;o2&lt;/code&gt; merely zero-initialized.</source>
          <target state="translated">Из-за вышеприведенного правила, если инициализация некоторого объекта &lt;code&gt;o1&lt;/code&gt; ссылается на объект &lt;code&gt;o2&lt;/code&gt; пространства имен , который потенциально требует динамической инициализации, но определяется позже в той же самой единице перевода, не определено, будет ли значение &lt;code&gt;o2&lt;/code&gt; использоваться как значение полностью инициализированного &lt;code&gt;o2&lt;/code&gt; (потому что компилятор способствовал инициализации &lt;code&gt;o2&lt;/code&gt; для времени компиляции) или будет значением &lt;code&gt;o2&lt;/code&gt; просто с нулевой инициализацией.</target>
        </trans-unit>
        <trans-unit id="f9dfa5b6f4b206c84c88479521272aa1a77080bd" translate="yes" xml:space="preserve">
          <source>Because of the side-effects involved, built-in increment and decrement operators must be used with care to avoid undefined behavior due to violations of &lt;a href=&quot;eval_order&quot;&gt;sequencing rules&lt;/a&gt;.</source>
          <target state="translated">Из-за сопутствующих побочных эффектов необходимо осторожно использовать встроенные операторы увеличения и уменьшения, чтобы избежать неопределенного поведения из-за нарушений &lt;a href=&quot;eval_order&quot;&gt;правил последовательности&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7e487fcdc25049314ba3c1aa8b2d5bde8e083329" translate="yes" xml:space="preserve">
          <source>Because of these rules, the following function declarations declare exactly the same function:</source>
          <target state="translated">Из-за этих правил следующие декларации функций объявляют точно такую же функцию:</target>
        </trans-unit>
        <trans-unit id="d688b7551f970383439094dc77352596d64c75aa" translate="yes" xml:space="preserve">
          <source>Because operator&amp;lt; is defined for pairs, containers of pairs can be sorted.</source>
          <target state="translated">Поскольку оператор &amp;lt;определен для пар, контейнеры пар могут быть отсортированы.</target>
        </trans-unit>
        <trans-unit id="6d70357852eee5a3977fc8f45f9558148ea3110c" translate="yes" xml:space="preserve">
          <source>Because operator&amp;lt; is defined for tuples, containers of tuples can be sorted.</source>
          <target state="translated">Поскольку оператор &amp;lt;определен для кортежей, контейнеры кортежей могут быть отсортированы.</target>
        </trans-unit>
        <trans-unit id="9988c3b00612ee646fb4689ee722feac6456ce93" translate="yes" xml:space="preserve">
          <source>Because private data members of a class participate in its object representation, affecting size and layout, and because private member functions of a class participate in &lt;a href=&quot;overload_resolution&quot;&gt;overload resolution&lt;/a&gt; (which takes place before member access checking), any change to those implementation details requires recompilation of all users of the class.</source>
          <target state="translated">Поскольку закрытые члены-данные класса участвуют в представлении его объекта, влияя на размер и компоновку, а также потому, что закрытые функции-члены класса участвуют в &lt;a href=&quot;overload_resolution&quot;&gt;разрешении перегрузки&lt;/a&gt; (что происходит до проверки доступа к элементу), любое изменение этих деталей реализации требует перекомпиляции всех пользователи класса.</target>
        </trans-unit>
        <trans-unit id="c3b6294e7526f54f684e9230a46827a20327483e" translate="yes" xml:space="preserve">
          <source>Because reallocation may involve bytewise copying (regardless of whether it's to expand or to contract), only the objects of &lt;a href=&quot;../../named_req/triviallycopyable&quot;&gt;TriviallyCopyable&lt;/a&gt; types are safe to access in the preserved part of the memory block after a call to &lt;code&gt;realloc&lt;/code&gt;.</source>
          <target state="translated">Поскольку перераспределение может включать в себя побочное копирование (независимо от того, будет ли оно расширяться или сжиматься), только объекты типов &lt;a href=&quot;../../named_req/triviallycopyable&quot;&gt;TriviallyCopyable&lt;/a&gt; безопасны для доступа в сохраненной части блока памяти после вызова &lt;code&gt;realloc&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a7a4b66b6298eef0d24f634e1a2d845ff026b299" translate="yes" xml:space="preserve">
          <source>Because references are not objects, there are no arrays of references, no pointers to references, and no references to references:</source>
          <target state="translated">Поскольку ссылки не являются объектами,нет массивов ссылок,нет указателей на ссылки,нет ссылок на ссылки:</target>
        </trans-unit>
        <trans-unit id="f2058d826c2c292a12210fe0965fc4ca9d8da0fd" translate="yes" xml:space="preserve">
          <source>Because rvalue references can bind to xvalues, they can refer to non-temporary objects:</source>
          <target state="translated">Поскольку ссылки на значения могут быть привязаны к x-значениям,они могут относиться к не временным объектам:</target>
        </trans-unit>
        <trans-unit id="04759d29e77b0401f5cb7e54b5a9ccc5b0666e57" translate="yes" xml:space="preserve">
          <source>Because some assignment operator (move or copy) is always declared for any class, the base class assignment operator is always hidden. If a using-declaration is used to bring in the assignment operator from the base class, and its argument type could be the same as the argument type of the implicit assignment operator of the derived class, the using-declaration is also hidden by the implicit declaration.</source>
          <target state="translated">Так как некоторый оператор присваивания (перемещение или копирование)всегда объявлен для любого класса,то базовый оператор присваивания класса всегда скрыт.Если для вывода оператора присваивания из базового класса используется use-декларация,а тип его аргумента может совпадать с типом аргумента неявного оператора присваивания производного класса,то use-декларация также скрывается неявным объявлением.</target>
        </trans-unit>
        <trans-unit id="00f0a274c1ab8c40e7bb092c85aefd4a4d48b525" translate="yes" xml:space="preserve">
          <source>Because stage 2 filters out characters such as 'p', 'N' or 'i', the hexadecimal floating-point numbers such as &quot;0x1.23p-10&quot; and the strings &quot;NaN&quot; or &quot;inf&quot; may be rejected by &lt;code&gt;do_get(double)&lt;/code&gt; even if they are valid input to &lt;code&gt;strtod&lt;/code&gt;: this is &lt;a href=&quot;http://cplusplus.github.io/LWG/lwg-active.html#2381&quot;&gt;LWG #2381&lt;/a&gt;.</source>
          <target state="translated">Поскольку на этапе 2 отфильтровываются такие символы, как 'p', 'N' или 'i', шестнадцатеричные числа с плавающей точкой, такие как &quot;0x1.23p-10&quot; и строки &quot;NaN&quot; или &quot;inf&quot;, могут быть отклонены &lt;code&gt;do_get(double)&lt;/code&gt; даже если они действительны для ввода в &lt;code&gt;strtod&lt;/code&gt; : это &lt;a href=&quot;http://cplusplus.github.io/LWG/lwg-active.html#2381&quot;&gt;LWG # 2381&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="05b082dade44717cca16c2a58fad1dfdcc56490d" translate="yes" xml:space="preserve">
          <source>Because stage 2 filters out characters such as 'p', 'N' or 'i', the hexadecimal floating-point numbers such as &quot;0x1.23p-10&quot; and the strings &quot;NaN&quot; or &quot;inf&quot; may be rejected by &lt;code&gt;do_get(double)&lt;/code&gt; even if they are valid input to &lt;code&gt;strtod&lt;/code&gt;: this is &lt;a href=&quot;https://cplusplus.github.io/LWG/lwg-active.html#2381&quot;&gt;LWG #2381&lt;/a&gt;.</source>
          <target state="translated">Поскольку на этапе 2 отфильтровываются символы, такие как 'p', 'N' или 'i', шестнадцатеричные числа с плавающей запятой, такие как &quot;0x1.23p-10&quot;, и строки &quot;NaN&quot; или &quot;inf&quot; могут быть отклонены &lt;code&gt;do_get(double)&lt;/code&gt; даже если они являются действительными входными &lt;code&gt;strtod&lt;/code&gt; для strtod : это &lt;a href=&quot;https://cplusplus.github.io/LWG/lwg-active.html#2381&quot;&gt;LWG # 2381&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="fa02ffb6258aec2d2486ffca8631f59286ef5ce5" translate="yes" xml:space="preserve">
          <source>Because the &lt;a href=&quot;noexcept&quot;&gt;noexcept&lt;/a&gt; operator always returns &lt;code&gt;true&lt;/code&gt; for a constant expression, it can be used to check if a particular invocation of a constexpr function takes the constant expression branch:</source>
          <target state="translated">Поскольку оператор &lt;a href=&quot;noexcept&quot;&gt;noexcept&lt;/a&gt; всегда возвращает &lt;code&gt;true&lt;/code&gt; для константного выражения, его можно использовать для проверки, принимает ли конкретный вызов функции constexpr ветвь константного выражения:</target>
        </trans-unit>
        <trans-unit id="13956b893efc09b160ae84ba33c1cbb13cb7bc62" translate="yes" xml:space="preserve">
          <source>Because the C++ program terminates if a destructor throws an exception during stack unwinding (which usually cannot be predicted), all practical destructors are non-throwing even if they are not declared noexcept. All destructors found in the C++ standard library are non-throwing.</source>
          <target state="translated">Поскольку программа на языке Си++прекращает свою работу,если при размотке стека (что обычно невозможно предсказать)деструктор выбрасывает исключение,все практические деструкторы не выбрасываются,даже если они не объявлены неисключительными.Все деструкторы,найденные в стандартной библиотеке Си++,являются небрасывающими.</target>
        </trans-unit>
        <trans-unit id="a4b14ea26ead34a1997c4a30b1317b3b91b17acb" translate="yes" xml:space="preserve">
          <source>Because the algorithm takes &lt;code&gt;old_value&lt;/code&gt; and &lt;code&gt;new_value&lt;/code&gt; by reference, it can have unexpected behavior if either is a reference to an element of the range &lt;code&gt;[first, last)&lt;/code&gt;.</source>
          <target state="translated">Поскольку алгоритм принимает &lt;code&gt;old_value&lt;/code&gt; и &lt;code&gt;new_value&lt;/code&gt; посредством ссылки, он может иметь неожиданное поведение , если либо является ссылка на элемент диапазона &lt;code&gt;[first, last)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="265f1e5e363f13b331939f8d44a25ab55d331f5b" translate="yes" xml:space="preserve">
          <source>Because the compiler is (usually) unable to analyze the code of an external library to determine whether it does or does not perform I/O or volatile access, third-party library calls also aren't affected by optimization. However, standard library calls may be replaced by other calls, eliminated, or added to the program during optimization. Statically-linked third-party library code may be subject to link-time optimization.</source>
          <target state="translated">Поскольку компилятор (как правило)не в состоянии проанализировать код внешней библиотеки,чтобы определить,выполняет или не выполняет ввод/вывод или нестабильный доступ,вызовы сторонних библиотек также не затрагиваются оптимизацией.Однако при оптимизации стандартные вызовы библиотек могут быть заменены другими вызовами,устранены или добавлены в программу.Статически привязанный код сторонней библиотеки может быть подвергнут оптимизации во времени линковки.</target>
        </trans-unit>
        <trans-unit id="3f7a16168cd91eaf4c419d45869f4dbf9eb22f7c" translate="yes" xml:space="preserve">
          <source>Because the copy assignment operator is always declared for any class, the base class assignment operator is always hidden. If a &lt;a href=&quot;using_declaration#In_class_definition&quot;&gt;using-declaration&lt;/a&gt; is used to bring in the assignment operator from the base class, and its argument type could be the same as the argument type of the implicit assignment operator of the derived class, the using-declaration is also hidden by the implicit declaration.</source>
          <target state="translated">Поскольку оператор присваивания копии всегда объявляется для любого класса, оператор присваивания базового класса всегда скрыт. Если &lt;a href=&quot;using_declaration#In_class_definition&quot;&gt;объявление-&lt;/a&gt; использование используется для ввода оператора присваивания из базового класса, и его тип аргумента может совпадать с типом аргумента неявного оператора присваивания производного класса, объявление-использование также скрывается неявным декларация.</target>
        </trans-unit>
        <trans-unit id="4f97ab617bba2611157c1c18672811c19cf4fbf8" translate="yes" xml:space="preserve">
          <source>Because the default constructor is &lt;code&gt;constexpr&lt;/code&gt;, static &lt;code&gt;std::any&lt;/code&gt;s are initialized as part of &lt;a href=&quot;../../language/initialization#Non-local_variables&quot;&gt;static non-local initialization&lt;/a&gt;, before any dynamic non-local initialization begins. This makes it safe to use an object of type &lt;code&gt;std::any&lt;/code&gt; in a constructor of any static object.</source>
          <target state="translated">Поскольку конструктором по умолчанию является &lt;code&gt;constexpr&lt;/code&gt; , статические &lt;code&gt;std::any&lt;/code&gt; s инициализируются как часть &lt;a href=&quot;../../language/initialization#Non-local_variables&quot;&gt;статической нелокальной инициализации&lt;/a&gt; до начала любой динамической нелокальной инициализации. Это позволяет безопасно использовать объект типа &lt;code&gt;std::any&lt;/code&gt; в конструкторе любого статического объекта.</target>
        </trans-unit>
        <trans-unit id="42b540f8fad9f3f5b7e3465475a9831636bf020b" translate="yes" xml:space="preserve">
          <source>Because the default constructor is &lt;code&gt;constexpr&lt;/code&gt;, static &lt;code&gt;weak_ptr&lt;/code&gt;s are initialized as part of &lt;a href=&quot;../../language/initialization#Non-local_variables&quot;&gt;static non-local initialization&lt;/a&gt;, before any dynamic non-local initialization begins. This makes it safe to use a weak_ptr in a constructor of any static object.</source>
          <target state="translated">Поскольку конструктором по умолчанию является &lt;code&gt;constexpr&lt;/code&gt; , статические &lt;code&gt;weak_ptr&lt;/code&gt; инициализируются как часть &lt;a href=&quot;../../language/initialization#Non-local_variables&quot;&gt;статической нелокальной инициализации&lt;/a&gt; до начала любой динамической нелокальной инициализации. Это позволяет безопасно использовать weak_ptr в конструкторе любого статического объекта.</target>
        </trans-unit>
        <trans-unit id="fe59378ecb23670abf397ca1ed600f6c13757f88" translate="yes" xml:space="preserve">
          <source>Because the default constructor is &lt;code&gt;constexpr&lt;/code&gt;, static mutexes are initialized as part of &lt;a href=&quot;../../language/initialization#Non-local_variables&quot;&gt;static non-local initialization&lt;/a&gt;, before any dynamic non-local initialization begins. This makes it safe to lock a mutex in a constructor of any static object.</source>
          <target state="translated">Поскольку конструктором по умолчанию является &lt;code&gt;constexpr&lt;/code&gt; , статические мьютексы инициализируются как часть &lt;a href=&quot;../../language/initialization#Non-local_variables&quot;&gt;статической нелокальной инициализации&lt;/a&gt; до начала любой динамической нелокальной инициализации. Это позволяет безопасно блокировать мьютекс в конструкторе любого статического объекта.</target>
        </trans-unit>
        <trans-unit id="920e4279426f6b2bafbfaf754987ba73067a3aed" translate="yes" xml:space="preserve">
          <source>Because the default constructor is &lt;code&gt;constexpr&lt;/code&gt;, static shared_ptrs are initialized as part of &lt;a href=&quot;../../language/initialization#Non-local_variables&quot;&gt;static non-local initialization&lt;/a&gt;, before any dynamic non-local initialization begins. This makes it safe to use a shared_ptr in a constructor of any static object.</source>
          <target state="translated">Поскольку конструктором по умолчанию является &lt;code&gt;constexpr&lt;/code&gt; , статические shared_ptrs инициализируются как часть &lt;a href=&quot;../../language/initialization#Non-local_variables&quot;&gt;статической нелокальной инициализации&lt;/a&gt; до начала любой динамической нелокальной инициализации. Это позволяет безопасно использовать shared_ptr в конструкторе любого статического объекта.</target>
        </trans-unit>
        <trans-unit id="534359d78874e4479c30413b7cac076114495993" translate="yes" xml:space="preserve">
          <source>Because the default constructor is &lt;code&gt;constexpr&lt;/code&gt;, static unique_ptrs are initialized as part of &lt;a href=&quot;../../language/initialization#Non-local_variables&quot;&gt;static non-local initialization&lt;/a&gt;, before any dynamic non-local initialization begins. This makes it safe to use a unique_ptr in a constructor of any static object.</source>
          <target state="translated">Поскольку конструктором по умолчанию является &lt;code&gt;constexpr&lt;/code&gt; , статические unique_ptrs инициализируются как часть &lt;a href=&quot;../../language/initialization#Non-local_variables&quot;&gt;статической нелокальной инициализации&lt;/a&gt; до начала любой динамической нелокальной инициализации. Это позволяет безопасно использовать unique_ptr в конструкторе любого статического объекта.</target>
        </trans-unit>
        <trans-unit id="ebbf73d1f46f71b596f1282630351e427e8477a7" translate="yes" xml:space="preserve">
          <source>Because the meaning of the keyword inline for functions came to mean &quot;multiple definitions are permitted&quot; rather than &quot;inlining is preferred&quot;, that meaning was extended to variables.</source>
          <target state="translated">Поскольку значение ключевого слова inline для функций стало означать &quot;разрешено несколько определений&quot;,а не &quot;предпочтительно вставлять&quot;,то это значение было расширено на переменные.</target>
        </trans-unit>
        <trans-unit id="006cf008ab0b4c79aa08791fcfe4af60405cca97" translate="yes" xml:space="preserve">
          <source>Because the presence of a user-defined destructor, copy-constructor, or copy-assignment operator prevents implicit definition of the &lt;a href=&quot;move_constructor&quot;&gt;move constructor&lt;/a&gt; and the &lt;a href=&quot;move_operator&quot;&gt;move assignment operator&lt;/a&gt;, any class for which move semantics are desirable, has to declare all five special member functions:</source>
          <target state="translated">Поскольку наличие определенного пользователем деструктора, оператора копирования или конструктора копирования предотвращает неявное определение конструктора &lt;a href=&quot;move_constructor&quot;&gt;перемещения&lt;/a&gt; и &lt;a href=&quot;move_operator&quot;&gt;оператора назначения перемещения&lt;/a&gt; , любой класс, для которого желательна семантика перемещения, должен объявлять все пять специальных функций-членов:</target>
        </trans-unit>
        <trans-unit id="b6dd2c080a889192fcdc9756c073e592957f9bd5" translate="yes" xml:space="preserve">
          <source>Because the short-circuiting properties of &lt;code&gt;operator&amp;amp;&amp;amp;&lt;/code&gt; and &lt;code&gt;operator||&lt;/code&gt; do not apply to overloads, and because types with boolean semantics are uncommon, only two standard library classes overload these operators:</source>
          <target state="translated">Потому что свойства короткого замыкания &lt;code&gt;operator&amp;amp;&amp;amp;&lt;/code&gt; и &lt;code&gt;operator||&lt;/code&gt; не применяются к перегрузкам, а поскольку типы с логической семантикой встречаются редко, только два стандартных библиотечных класса перегружают эти операторы:</target>
        </trans-unit>
        <trans-unit id="da716a2068c8a4a0779a87e17e684144cccab8b0" translate="yes" xml:space="preserve">
          <source>Because the terminating character is counted as an extracted character, an empty input line does not trigger failbit.</source>
          <target state="translated">Поскольку завершающий символ считается извлеченным,пустая строка ввода не запускает бит отказа.</target>
        </trans-unit>
        <trans-unit id="4d2b809785ffb9b84788684b26543ec41eac3af8" translate="yes" xml:space="preserve">
          <source>Because these operators group left-to-right, the expression &lt;code&gt;a&amp;lt;b&amp;lt;c&lt;/code&gt; is parsed &lt;code&gt;(a&amp;lt;b)&amp;lt;c&lt;/code&gt;, and not &lt;code&gt;a&amp;lt;(b&amp;lt;c)&lt;/code&gt; or &lt;code&gt;(a&amp;lt;b)&amp;amp;&amp;amp;(b&amp;lt;c)&lt;/code&gt;.</source>
          <target state="translated">Поскольку эти операторы группируются слева направо, выражение &lt;code&gt;a&amp;lt;b&amp;lt;c&lt;/code&gt; анализируется &lt;code&gt;(a&amp;lt;b)&amp;lt;c&lt;/code&gt; , а не &lt;code&gt;a&amp;lt;(b&amp;lt;c)&lt;/code&gt; или &lt;code&gt;(a&amp;lt;b)&amp;amp;&amp;amp;(b&amp;lt;c)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="70619bda160666d212cde7b85f1f8b5a55f4c5a2" translate="yes" xml:space="preserve">
          <source>Because this function provides the automatic fall back to direct call to the destructor, the member function &lt;code&gt;destroy()&lt;/code&gt; is an optional &lt;a href=&quot;../../named_req/allocator&quot;&gt;Allocator&lt;/a&gt; requirement since C++11.</source>
          <target state="translated">Поскольку эта функция обеспечивает автоматический возврат к прямому вызову деструктора, функция- &lt;code&gt;destroy()&lt;/code&gt; является необязательным требованием &lt;a href=&quot;../../named_req/allocator&quot;&gt;Allocator&lt;/a&gt; начиная с C ++ 11.</target>
        </trans-unit>
        <trans-unit id="7687252b20cc0d88dc4dda04b2b393cf7f223dc8" translate="yes" xml:space="preserve">
          <source>Because this function provides the automatic fall back to placement new, the member function &lt;code&gt;construct()&lt;/code&gt; is an optional &lt;a href=&quot;../../named_req/allocator&quot;&gt;Allocator&lt;/a&gt; requirement since C++11.</source>
          <target state="translated">Поскольку эта функция обеспечивает автоматический возврат к размещению new, функция-член &lt;code&gt;construct()&lt;/code&gt; является необязательным требованием &lt;a href=&quot;../../named_req/allocator&quot;&gt;Allocator&lt;/a&gt; начиная с C ++ 11.</target>
        </trans-unit>
        <trans-unit id="7f86afd7df6f8079055e111a54ab1c7b1acee01f" translate="yes" xml:space="preserve">
          <source>Because this function takes an &lt;code&gt;int&lt;/code&gt;, it cannot manipulate buffers larger than &lt;code&gt;std::numeric_limits&amp;lt;int&amp;gt;::max()&lt;/code&gt; characters (&lt;a href=&quot;http://wg21.link/lwg255&quot;&gt;LWG 255&lt;/a&gt;).</source>
          <target state="translated">Поскольку эта функция принимает &lt;code&gt;int&lt;/code&gt; , она не может манипулировать буферами, размер которых превышает &lt;code&gt;std::numeric_limits&amp;lt;int&amp;gt;::max()&lt;/code&gt; символов ( &lt;a href=&quot;http://wg21.link/lwg255&quot;&gt;LWG 255&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="96b9e8b9f2beaa29d6fe717de5892c225fc24e46" translate="yes" xml:space="preserve">
          <source>Because transfer of control is &lt;a href=&quot;goto&quot;&gt;not permitted to enter the scope&lt;/a&gt; of a variable, if a declaration statement is encountered inside the statement, it has to be scoped in its own compound statement:</source>
          <target state="translated">Поскольку передача управления &lt;a href=&quot;goto&quot;&gt;не позволяет входить в область&lt;/a&gt; действия переменной, если внутри оператора встречается оператор объявления, он должен быть ограничен в своем собственном составном операторе:</target>
        </trans-unit>
        <trans-unit id="8087588a9b0c2147f6476231103eced47874ee97" translate="yes" xml:space="preserve">
          <source>Because trigraphs are processed early, a comment such as &lt;code&gt;// Will the next line be executed?????/&lt;/code&gt; will effectively comment out the following line, and the string literal such as &lt;code&gt;&quot;Enter date ??/??/??&quot;&lt;/code&gt; is parsed as &lt;code&gt;&quot;Enter date \\??&quot;&lt;/code&gt;.</source>
          <target state="translated">Поскольку триграфы обрабатываются рано, комментарий, такой как &lt;code&gt;// Will the next line be executed?????/&lt;/code&gt; , фактически закомментирует следующую строку, а строковый литерал, такой как &lt;code&gt;&quot;Enter date ??/??/??&quot;&lt;/code&gt; анализируется как &lt;code&gt;&quot;Enter date \\??&quot;&lt;/code&gt; ,</target>
        </trans-unit>
        <trans-unit id="48a81f0ee3ab4431a19bb6ed8bbbce0c2c607478" translate="yes" xml:space="preserve">
          <source>Because variadic parameters have the lowest rank for the purpose of &lt;a href=&quot;overload_resolution&quot;&gt;overload resolution&lt;/a&gt;, they are commonly used as the catch-all fallbacks in &lt;a href=&quot;sfinae&quot;&gt;SFINAE&lt;/a&gt;.</source>
          <target state="translated">Поскольку переменные параметры имеют самый низкий ранг с целью &lt;a href=&quot;overload_resolution&quot;&gt;разрешения перегрузки&lt;/a&gt; , они обычно используются в качестве &lt;a href=&quot;sfinae&quot;&gt;универсальных откатов&lt;/a&gt; в SFINAE .</target>
        </trans-unit>
        <trans-unit id="3342f0b566e3613e9188ea93ab88f717f12a0f2c" translate="yes" xml:space="preserve">
          <source>Because when const member function calls a function through a non-const member pointer, the non-const overload of the implementation function is called, the pointer has to be wrapped in &lt;code&gt;&lt;a href=&quot;http://en.cppreference.com/w/cpp/experimental/propagate_const&quot;&gt;std::experimental::propagate_const&lt;/a&gt;&lt;/code&gt; or equivalent.</source>
          <target state="translated">Поскольку, когда константная функция-член вызывает функцию через неконстантный указатель на член, вызывается неконстантная перегрузка функции реализации, указатель должен быть заключен в &lt;code&gt;&lt;a href=&quot;http://en.cppreference.com/w/cpp/experimental/propagate_const&quot;&gt;std::experimental::propagate_const&lt;/a&gt;&lt;/code&gt; или эквивалент</target>
        </trans-unit>
        <trans-unit id="8374ae1ab38ced7f1c45fb4cad278a13b4530170" translate="yes" xml:space="preserve">
          <source>Before &lt;code&gt;std::bit_cast&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../string/byte/memcpy&quot;&gt;std::memcpy&lt;/a&gt;&lt;/code&gt; can be used when it is needed to interpret the object representation as one of another type:</source>
          <target state="translated">Перед &lt;code&gt;std::bit_cast&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../string/byte/memcpy&quot;&gt;std::memcpy&lt;/a&gt;&lt;/code&gt; можно использовать , когда необходимо интерпретировать представление объекта в виде одного другого типа:</target>
        </trans-unit>
        <trans-unit id="fea4659c4c01a5438272693831b7a6cf369a447e" translate="yes" xml:space="preserve">
          <source>Before C++11, floating-point exceptions were not specified, &lt;code&gt;&lt;a href=&quot;../../error/errno_macros&quot;&gt;EDOM&lt;/a&gt;&lt;/code&gt; was required for any domain error, &lt;code&gt;&lt;a href=&quot;../../error/errno_macros&quot;&gt;ERANGE&lt;/a&gt;&lt;/code&gt; was required for overflows and implementation-defined for underflows.</source>
          <target state="translated">До C ++ 11 исключения с плавающей точкой не &lt;code&gt;&lt;a href=&quot;../../error/errno_macros&quot;&gt;EDOM&lt;/a&gt;&lt;/code&gt; , EDOM требовался для любой ошибки домена, &lt;code&gt;&lt;a href=&quot;../../error/errno_macros&quot;&gt;ERANGE&lt;/a&gt;&lt;/code&gt; требовался для переполнений и определялся реализацией для переполнений.</target>
        </trans-unit>
        <trans-unit id="8315db453a2a5506755072ec6a7820d4232e1cea" translate="yes" xml:space="preserve">
          <source>Before a call to &lt;code&gt;str()&lt;/code&gt; that uses the result as a C string, the stream buffer must be null-terminated. Regular output such as with &lt;code&gt;stream &amp;lt;&amp;lt; 1.2&lt;/code&gt; does not store a null terminator, it must be appended explicitly, typically with the manipulator &lt;code&gt;&lt;a href=&quot;../manip/ends&quot;&gt;std::ends&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Перед вызовом &lt;code&gt;str()&lt;/code&gt; который использует результат как строку C, буфер потока должен завершаться нулем. Обычный вывод, например, с &lt;code&gt;stream &amp;lt;&amp;lt; 1.2&lt;/code&gt; , не хранит нулевой терминатор, он должен добавляться явно, обычно с помощью манипулятора &lt;code&gt;&lt;a href=&quot;../manip/ends&quot;&gt;std::ends&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a94bcd5b8d87a105ad9ebe672411a4e5e7749b2c" translate="yes" xml:space="preserve">
          <source>Before any call to &lt;code&gt;str()&lt;/code&gt; that uses the result as a C string, the buffer must be null-terminated, typically with &lt;code&gt;&lt;a href=&quot;manip/ends&quot;&gt;std::ends&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Перед любым вызовом &lt;code&gt;str()&lt;/code&gt; который использует результат как строку C, буфер должен заканчиваться нулем, как правило, с &lt;code&gt;&lt;a href=&quot;manip/ends&quot;&gt;std::ends&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c35792e95cf3b07cb316904dfad082217f59a440" translate="yes" xml:space="preserve">
          <source>Before any catch clauses of a function-try-block on a constructor are entered, all fully-constructed members and bases have already been destroyed.</source>
          <target state="translated">До того,как были введены какие-либо уловительные положения функционального блока на конструкторе,все полностью построенные члены и базы уже были уничтожены.</target>
        </trans-unit>
        <trans-unit id="d25af084b2d0cf872bc310ddc2b32c2b646e23c4" translate="yes" xml:space="preserve">
          <source>Before any catch clauses of a function-try-block on a destructor are entered, all bases and non-variant members have already been destroyed.</source>
          <target state="translated">Перед вводом любых ловушек функции-три-блока на деструкторе все основания и многовариантные члены уже были уничтожены.</target>
        </trans-unit>
        <trans-unit id="73e853eca15162afc8c02a1bedca567760609d5c" translate="yes" xml:space="preserve">
          <source>Before any further analysis, constraints are &lt;a href=&quot;constraints#Constraint_normalization&quot;&gt;normalized&lt;/a&gt; by substituting the body of every name concept and every requires expression until what is left is a sequence of conjunctions and disjunctions on atomic constraints.</source>
          <target state="translated">Перед дальнейшим анализом ограничения &lt;a href=&quot;constraints#Constraint_normalization&quot;&gt;нормализуются&lt;/a&gt; путем подстановки тела каждого понятия имени, и каждому требуется выражение, пока не останется последовательность соединений и дизъюнкций на атомарных ограничениях.</target>
        </trans-unit>
        <trans-unit id="6aa106196ee396275230e60cf51ed929654bbc97" translate="yes" xml:space="preserve">
          <source>Before any of the member functions would yield undefined results, calls callbacks, registered by &lt;a href=&quot;register_callback&quot;&gt;&lt;code&gt;register_callback()&lt;/code&gt;&lt;/a&gt; passing &lt;a href=&quot;event&quot;&gt;&lt;code&gt;erase_event&lt;/code&gt;&lt;/a&gt; as parameter.</source>
          <target state="translated">Прежде чем какая-либо из функций-членов выдаст неопределенные результаты, она вызывает обратные вызовы, зарегистрированные в &lt;a href=&quot;register_callback&quot;&gt; &lt;code&gt;register_callback()&lt;/code&gt; &lt;/a&gt; передавая &lt;a href=&quot;event&quot;&gt; &lt;code&gt;erase_event&lt;/code&gt; в&lt;/a&gt; качестве параметра.</target>
        </trans-unit>
        <trans-unit id="32981297d13de998df78a59af43e17581b0c92e7" translate="yes" xml:space="preserve">
          <source>Before class template argument deduction was introduced, a common approach to avoiding explicitly specifying arguments is to use a function template:</source>
          <target state="translated">До введения вычитания аргументов из шаблона класса распространенным подходом,позволяющим избежать явного указания аргументов,является использование шаблона функции:</target>
        </trans-unit>
        <trans-unit id="448996df8021b850305d2f1a744547e3fb5a961d" translate="yes" xml:space="preserve">
          <source>Before deduction begins, the following adjustments to &lt;code&gt;P&lt;/code&gt; and &lt;code&gt;A&lt;/code&gt; are made:</source>
          <target state="translated">Перед тем, как начнется удержание, выполняются следующие корректировки &lt;code&gt;P&lt;/code&gt; и &lt;code&gt;A&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="ec06b6296ed6cd7c8b9af0261c5f6873359d381f" translate="yes" xml:space="preserve">
          <source>Before doing anything else, &lt;code&gt;seekg&lt;/code&gt; clears &lt;code&gt;eofbit&lt;/code&gt;.</source>
          <target state="translated">Прежде чем делать что-либо еще, &lt;code&gt;seekg&lt;/code&gt; очищает &lt;code&gt;eofbit&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7de5fab850d46a3b252876719b32d89d2a9ae789" translate="yes" xml:space="preserve">
          <source>Before insertion, first, all characters are widened using &lt;code&gt;os.widen()&lt;/code&gt;, then padding is determined as follows: if the number of characters to insert is less than &lt;code&gt;os.width()&lt;/code&gt;, then enough copies of &lt;code&gt;os.fill()&lt;/code&gt; are added to the character sequence to make its length equal &lt;code&gt;os.width()&lt;/code&gt;. If &lt;code&gt;(out.flags()&amp;amp;&lt;a href=&quot;../ios_base/fmtflags&quot;&gt;std::ios_base::adjustfield&lt;/a&gt;) == &lt;a href=&quot;../ios_base/fmtflags&quot;&gt;std::ios_base::left&lt;/a&gt;&lt;/code&gt;, the fill characters are added at the end of the output sequence, otherwise they are added before the output sequence. After insertion, &lt;code&gt;width(0)&lt;/code&gt; is called to cancel the effects of &lt;code&gt;&lt;a href=&quot;../manip/setw&quot;&gt;std::setw&lt;/a&gt;&lt;/code&gt;, if any.  The behavior is undefined if &lt;code&gt;s&lt;/code&gt; is a null pointer.</source>
          <target state="translated">Перед вставкой сначала все символы расширяются с помощью &lt;code&gt;os.widen()&lt;/code&gt; , затем заполнение определяется следующим образом: если количество символов для вставки меньше, чем &lt;code&gt;os.width()&lt;/code&gt; , то добавляется достаточное количество копий &lt;code&gt;os.fill()&lt;/code&gt; к последовательности символов, чтобы сделать ее длину равной &lt;code&gt;os.width()&lt;/code&gt; . Если &lt;code&gt;(out.flags()&amp;amp;&lt;a href=&quot;../ios_base/fmtflags&quot;&gt;std::ios_base::adjustfield&lt;/a&gt;) == &lt;a href=&quot;../ios_base/fmtflags&quot;&gt;std::ios_base::left&lt;/a&gt;&lt;/code&gt; , символы заполнения добавляются в конец выходной последовательности, в противном случае они добавляются перед выходной последовательностью. После вставки вызывается &lt;code&gt;width(0)&lt;/code&gt; для отмены эффектов &lt;code&gt;&lt;a href=&quot;../manip/setw&quot;&gt;std::setw&lt;/a&gt;&lt;/code&gt; , если таковые имеются. Поведение не определено, если &lt;code&gt;s&lt;/code&gt; является нулевым указателем.</target>
        </trans-unit>
        <trans-unit id="66a732adfdd2f159eb6ed563c85a4950c2ff838b" translate="yes" xml:space="preserve">
          <source>Before modified element(s)</source>
          <target state="translated">Перед модифицированными элементами</target>
        </trans-unit>
        <trans-unit id="d97a4012796ad8947371e2ae9f789d3c201395de" translate="yes" xml:space="preserve">
          <source>Before name lookup can be performed for the name on the right hand side of &lt;code&gt;::&lt;/code&gt;, lookup must be completed for the name on its left hand side (unless a &lt;a href=&quot;decltype&quot;&gt;decltype&lt;/a&gt; expression is used, or there is nothing on the left). This lookup, which may be qualified or unqualified, depending on whether there's another &lt;code&gt;::&lt;/code&gt; to the left of that name, considers only namespaces, class types, enumerations, and templates whose specializations are types:</source>
          <target state="translated">Прежде чем можно выполнить поиск имени для имени в правой части &lt;code&gt;::&lt;/code&gt; , поиск должен быть выполнен для имени в левой части (если не используется выражение &lt;a href=&quot;decltype&quot;&gt;decltype&lt;/a&gt; или слева ничего нет). Этот поиск, который может быть квалифицированным или неквалифицированным, в зависимости от того, есть ли другой &lt;code&gt;::&lt;/code&gt; слева от этого имени, рассматривает только пространства имен, типы классов, перечисления и шаблоны, специализации которых являются типами:</target>
        </trans-unit>
        <trans-unit id="82707517c83290ff1d38dc49904b3bfd7e902adb" translate="yes" xml:space="preserve">
          <source>Before overload resolution begins, the functions selected by name lookup and template argument deduction are combined to form the set of</source>
          <target state="translated">Перед началом разрешения перегрузки функции,выбранные по поиску имени и вычитанию аргументов шаблона,объединяются в набор из</target>
        </trans-unit>
        <trans-unit id="ff5ff5557a213e5cbabe46f3d7e81258ac04a845" translate="yes" xml:space="preserve">
          <source>Before the compound statement that forms the function body of the constructor begins executing, initialization of all direct bases, virtual bases, and non-static data members is finished. Member initializer list is the place where non-default initialization of these objects can be specified. For members that cannot be default-initialized, such as members of reference and const-qualified types, member initializers must be specified. No initialization is performed for &lt;a href=&quot;union#Anonymous_unions&quot;&gt;anonymous unions&lt;/a&gt; or &lt;a href=&quot;union#Union-like_class&quot;&gt;variant members&lt;/a&gt; that do not have a member initializer.</source>
          <target state="translated">Перед тем, как начинается выполнение составного оператора, который формирует тело функции конструктора, инициализация всех прямых баз, виртуальных баз и нестатических элементов данных. Список инициализаторов элементов - это место, где можно указать инициализацию этих объектов по умолчанию Для элементов, которые не могут быть инициализированы по умолчанию, таких как ссылочные элементы и типы с константной квалификацией, должны быть указаны инициализаторы элементов. Не выполняется инициализация для &lt;a href=&quot;union#Anonymous_unions&quot;&gt;анонимных объединений&lt;/a&gt; или &lt;a href=&quot;union#Union-like_class&quot;&gt;вариантов членов,&lt;/a&gt; которые не имеют инициализатора элементов.</target>
        </trans-unit>
        <trans-unit id="c0c425b7763137b46eb294c01dcbca3225e7768a" translate="yes" xml:space="preserve">
          <source>Before the lifetime of an object has started but after the storage which the object will occupy has been allocated or, after the lifetime of an object has ended and before the storage which the object occupied is reused or released, the following uses of the glvalue expression that identifies that object are undefined:</source>
          <target state="translated">До начала жизни объекта,но после выделения хранилища,в котором этот объект будет находиться,или после окончания жизни объекта и до того,как хранилище,в котором этот объект будет находиться,будет повторно использовано или освобождено,следующие виды использования выражения клея,которое идентифицирует этот объект,являются неопределенными:</target>
        </trans-unit>
        <trans-unit id="01ee3728daf49b9887894e9051143ca70683a003" translate="yes" xml:space="preserve">
          <source>Behaves as &lt;a href=&quot;../../named_req/unformattedinputfunction&quot;&gt;UnformattedInputFunction&lt;/a&gt;, except that &lt;code&gt;&lt;a href=&quot;gcount&quot;&gt;gcount()&lt;/a&gt;&lt;/code&gt; is not affected. After constructing and checking the sentry object,</source>
          <target state="translated">Ведет себя как &lt;a href=&quot;../../named_req/unformattedinputfunction&quot;&gt;UnformattedInputFunction&lt;/a&gt; , за исключением того, что на &lt;code&gt;&lt;a href=&quot;gcount&quot;&gt;gcount()&lt;/a&gt;&lt;/code&gt; это не влияет. После создания и проверки сторожевого объекта,</target>
        </trans-unit>
        <trans-unit id="afa456ec56112ff3b6b761bd5b74f63ce75d28ec" translate="yes" xml:space="preserve">
          <source>Behaves as &lt;a href=&quot;../../named_req/unformattedinputfunction&quot;&gt;UnformattedInputFunction&lt;/a&gt;, except that &lt;code&gt;&lt;a href=&quot;gcount&quot;&gt;gcount()&lt;/a&gt;&lt;/code&gt; is not affected. After constructing and checking the sentry object, if &lt;code&gt;fail() == true&lt;/code&gt;, returns &lt;code&gt;pos_type(-1)&lt;/code&gt;. Otherwise, returns &lt;code&gt;rdbuf()-&amp;gt;pubseekoff(0, &lt;a href=&quot;../ios_base/seekdir&quot;&gt;std::ios_base::cur&lt;/a&gt;, &lt;a href=&quot;../ios_base/openmode&quot;&gt;std::ios_base::in&lt;/a&gt;)&lt;/code&gt;.</source>
          <target state="translated">Ведет себя как &lt;a href=&quot;../../named_req/unformattedinputfunction&quot;&gt;UnformattedInputFunction&lt;/a&gt; , за исключением того, что на &lt;code&gt;&lt;a href=&quot;gcount&quot;&gt;gcount()&lt;/a&gt;&lt;/code&gt; это не влияет. После создания и проверки объекта &lt;code&gt;pos_type(-1)&lt;/code&gt; , если &lt;code&gt;fail() == true&lt;/code&gt; , возвращает pos_type (-1) . В противном случае возвращает &lt;code&gt;rdbuf()-&amp;gt;pubseekoff(0, &lt;a href=&quot;../ios_base/seekdir&quot;&gt;std::ios_base::cur&lt;/a&gt;, &lt;a href=&quot;../ios_base/openmode&quot;&gt;std::ios_base::in&lt;/a&gt;)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3a77bac3067d3940c6b684599ba369eb392602c9" translate="yes" xml:space="preserve">
          <source>Behaves as &lt;a href=&quot;../../named_req/unformattedinputfunction&quot;&gt;UnformattedInputFunction&lt;/a&gt;. After constructing and checking the sentry object,</source>
          <target state="translated">Ведет себя как &lt;a href=&quot;../../named_req/unformattedinputfunction&quot;&gt;UnformattedInputFunction&lt;/a&gt; . После создания и проверки сторожевого объекта,</target>
        </trans-unit>
        <trans-unit id="9678066f0a18b755a7a83de41a67b8f539cf21e5" translate="yes" xml:space="preserve">
          <source>Behaves as &lt;a href=&quot;../../named_req/unformattedinputfunction&quot;&gt;UnformattedInputFunction&lt;/a&gt;. After constructing and checking the sentry object, extracts characters and stores them into successive locations of the character array whose first element is pointed to by &lt;code&gt;s&lt;/code&gt;. Characters are extracted and stored until any of the following conditions occurs:</source>
          <target state="translated">Ведет себя как &lt;a href=&quot;../../named_req/unformattedinputfunction&quot;&gt;UnformattedInputFunction&lt;/a&gt; . После создания и проверки объекта sentry, извлекает символы и сохраняет их в последовательных местах массива символов, на первый элемент которого указывает &lt;code&gt;s&lt;/code&gt; . Символы извлекаются и сохраняются до тех пор, пока не произойдет любое из следующих условий:</target>
        </trans-unit>
        <trans-unit id="5452e2d70444e38dce8d1658572b189b3491c062" translate="yes" xml:space="preserve">
          <source>Behaves as &lt;a href=&quot;../../named_req/unformattedinputfunction&quot;&gt;UnformattedInputFunction&lt;/a&gt;. After constructing and checking the sentry object, extracts characters from &lt;code&gt;*this&lt;/code&gt; and stores them in successive locations of the array whose first element is pointed to by &lt;code&gt;s&lt;/code&gt;, until any of the following occurs (tested in the order shown):</source>
          <target state="translated">Ведет себя как &lt;a href=&quot;../../named_req/unformattedinputfunction&quot;&gt;UnformattedInputFunction&lt;/a&gt; . После создания и проверки объекта sentry, извлекает символы из &lt;code&gt;*this&lt;/code&gt; и сохраняет их в последовательных расположениях массива, на первый элемент которого указывает &lt;code&gt;s&lt;/code&gt; , до тех пор, пока не произойдет любое из следующих действий (проверено в указанном порядке):</target>
        </trans-unit>
        <trans-unit id="2ce9bf750568029bd6c252857e382b90c6756ee0" translate="yes" xml:space="preserve">
          <source>Behaves as &lt;a href=&quot;../../named_req/unformattedinputfunction&quot;&gt;UnformattedInputFunction&lt;/a&gt;. After constructing and testing the sentry object, reads the next character from the input stream without extracting it.</source>
          <target state="translated">Ведет себя как &lt;a href=&quot;../../named_req/unformattedinputfunction&quot;&gt;UnformattedInputFunction&lt;/a&gt; . После создания и тестирования объекта sentry читает следующий символ из входного потока, не извлекая его.</target>
        </trans-unit>
        <trans-unit id="0749de46c88cb22f7c4409a2cfcef6bf1f8046f6" translate="yes" xml:space="preserve">
          <source>Behaves as &lt;a href=&quot;../../named_req/unformattedoutputfunction&quot;&gt;UnformattedOutputFunction&lt;/a&gt; (except without actually performing output). After constructing and checking the sentry object,</source>
          <target state="translated">Ведет себя как &lt;a href=&quot;../../named_req/unformattedoutputfunction&quot;&gt;UnformattedOutputFunction&lt;/a&gt; (за исключением того, что фактически не выполняет вывод). После создания и проверки сторожевого объекта,</target>
        </trans-unit>
        <trans-unit id="4672c00972c0e6a7e7c5cce22e6b19b90240fb04" translate="yes" xml:space="preserve">
          <source>Behaves as a &lt;a href=&quot;../../named_req/formattedoutputfunction&quot;&gt;FormattedOutputFunction&lt;/a&gt;. After constructing and checking the sentry object, determines the output format padding as follows:</source>
          <target state="translated">Ведет себя как &lt;a href=&quot;../../named_req/formattedoutputfunction&quot;&gt;FormattedOutputFunction&lt;/a&gt; . После создания и проверки сторожевого объекта определяется заполнение выходного формата следующим образом:</target>
        </trans-unit>
        <trans-unit id="fd13a34bc371a84520ebfd6305bba27395aa1de8" translate="yes" xml:space="preserve">
          <source>Behaves as an &lt;a href=&quot;../../named_req/unformattedinputfunction&quot;&gt;UnformattedInputFunction&lt;/a&gt;, except that &lt;code&gt;is.gcount()&lt;/code&gt; is not modified. After constructing and checking the sentry object, extracts characters from the stream and discards them until any one of the following conditions occurs:</source>
          <target state="translated">Ведет себя как &lt;a href=&quot;../../named_req/unformattedinputfunction&quot;&gt;UnformattedInputFunction&lt;/a&gt; , за исключением того, что &lt;code&gt;is.gcount()&lt;/code&gt; не изменяется. После создания и проверки объекта sentry, извлекает символы из потока и отбрасывает их, пока не произойдет одно из следующих условий:</target>
        </trans-unit>
        <trans-unit id="fb87348382a678ef761dc7c93eddfa49c60fd167" translate="yes" xml:space="preserve">
          <source>Behaves as an &lt;a href=&quot;../../named_req/unformattedinputfunction&quot;&gt;UnformattedInputFunction&lt;/a&gt;, except that it has an unspecified effect on &lt;code&gt;is.gcount()&lt;/code&gt;. After constructing and checking the sentry object, attempts to parse the input stream &lt;code&gt;is&lt;/code&gt; into &lt;code&gt;d&lt;/code&gt; according to the format string &lt;code&gt;fmt&lt;/code&gt;. If the parse fails to decode a valid &lt;code&gt;day&lt;/code&gt;, &lt;code&gt;is.setstate(&lt;a href=&quot;../../io/ios_base/iostate&quot;&gt;std::ios_base::failbit&lt;/a&gt;)&lt;/code&gt; is called and &lt;code&gt;d&lt;/code&gt; is not modified.</source>
          <target state="translated">Ведет себя как &lt;a href=&quot;../../named_req/unformattedinputfunction&quot;&gt;UnformattedInputFunction&lt;/a&gt; , за исключением того, что он имеет неопределенный эффект для &lt;code&gt;is.gcount()&lt;/code&gt; . После построения и проверки объекта сторожевого, попытка разобрать входной поток &lt;code&gt;is&lt;/code&gt; в &lt;code&gt;d&lt;/code&gt; в соответствии с форматом строка &lt;code&gt;fmt&lt;/code&gt; . Если синтаксический анализ не может декодировать действительный &lt;code&gt;day&lt;/code&gt; , &lt;code&gt;is.setstate(&lt;a href=&quot;../../io/ios_base/iostate&quot;&gt;std::ios_base::failbit&lt;/a&gt;)&lt;/code&gt; и &lt;code&gt;d&lt;/code&gt; не изменяется.</target>
        </trans-unit>
        <trans-unit id="1fa65d008ed7c245aef54a0ea0b67364379c951b" translate="yes" xml:space="preserve">
          <source>Behaves as an &lt;a href=&quot;../../named_req/unformattedinputfunction&quot;&gt;UnformattedInputFunction&lt;/a&gt;, except that it has an unspecified effect on &lt;code&gt;is.gcount()&lt;/code&gt;. After constructing and checking the sentry object, attempts to parse the input stream &lt;code&gt;is&lt;/code&gt; into &lt;code&gt;d&lt;/code&gt; according to the format string &lt;code&gt;fmt&lt;/code&gt;. If the parse fails to decode a valid &lt;code&gt;duration&lt;/code&gt;, &lt;code&gt;is.setstate(&lt;a href=&quot;../../io/ios_base/iostate&quot;&gt;std::ios_base::failbit&lt;/a&gt;)&lt;/code&gt; is called and &lt;code&gt;d&lt;/code&gt; is not modified.</source>
          <target state="translated">Ведет себя как &lt;a href=&quot;../../named_req/unformattedinputfunction&quot;&gt;UnformattedInputFunction&lt;/a&gt; , за исключением того, что он имеет неопределенный эффект для &lt;code&gt;is.gcount()&lt;/code&gt; . После построения и проверки объекта сторожевого, попытка разобрать входной поток &lt;code&gt;is&lt;/code&gt; в &lt;code&gt;d&lt;/code&gt; в соответствии с форматом строка &lt;code&gt;fmt&lt;/code&gt; . Если синтаксический анализ не может декодировать допустимую &lt;code&gt;duration&lt;/code&gt; , &lt;code&gt;is.setstate(&lt;a href=&quot;../../io/ios_base/iostate&quot;&gt;std::ios_base::failbit&lt;/a&gt;)&lt;/code&gt; и &lt;code&gt;d&lt;/code&gt; не изменяется.</target>
        </trans-unit>
        <trans-unit id="d2831b6a6c206e8d8a233d91bfdec888a2de732b" translate="yes" xml:space="preserve">
          <source>Behaves as an &lt;a href=&quot;../../named_req/unformattedinputfunction&quot;&gt;UnformattedInputFunction&lt;/a&gt;, except that it has an unspecified effect on &lt;code&gt;is.gcount()&lt;/code&gt;. After constructing and checking the sentry object, attempts to parse the input stream &lt;code&gt;is&lt;/code&gt; into &lt;code&gt;m&lt;/code&gt; according to the format string &lt;code&gt;fmt&lt;/code&gt;. If the parse fails to decode a valid &lt;code&gt;month&lt;/code&gt;, &lt;code&gt;is.setstate(&lt;a href=&quot;../../io/ios_base/iostate&quot;&gt;std::ios_base::failbit&lt;/a&gt;)&lt;/code&gt; is called and &lt;code&gt;m&lt;/code&gt; is not modified.</source>
          <target state="translated">Ведет себя как &lt;a href=&quot;../../named_req/unformattedinputfunction&quot;&gt;UnformattedInputFunction&lt;/a&gt; , за исключением того, что он имеет неопределенный эффект для &lt;code&gt;is.gcount()&lt;/code&gt; . После построения и проверки объекта сторожевого, попытка разобрать входной поток &lt;code&gt;is&lt;/code&gt; в &lt;code&gt;m&lt;/code&gt; в зависимости от формата строка &lt;code&gt;fmt&lt;/code&gt; . Если анализ не может декодировать действительный &lt;code&gt;month&lt;/code&gt; , &lt;code&gt;is.setstate(&lt;a href=&quot;../../io/ios_base/iostate&quot;&gt;std::ios_base::failbit&lt;/a&gt;)&lt;/code&gt; и &lt;code&gt;m&lt;/code&gt; не изменяется.</target>
        </trans-unit>
        <trans-unit id="faffa23b913d2432b4e5d59afb1027604b07f00e" translate="yes" xml:space="preserve">
          <source>Behaves as an &lt;a href=&quot;../../named_req/unformattedinputfunction&quot;&gt;UnformattedInputFunction&lt;/a&gt;, except that it has an unspecified effect on &lt;code&gt;is.gcount()&lt;/code&gt;. After constructing and checking the sentry object, attempts to parse the input stream &lt;code&gt;is&lt;/code&gt; into &lt;code&gt;md&lt;/code&gt; according to the format string &lt;code&gt;fmt&lt;/code&gt;. If the parse fails to decode a valid &lt;code&gt;month_day&lt;/code&gt;, &lt;code&gt;is.setstate(&lt;a href=&quot;../../io/ios_base/iostate&quot;&gt;std::ios_base::failbit&lt;/a&gt;)&lt;/code&gt; is called and &lt;code&gt;md&lt;/code&gt; is not modified.</source>
          <target state="translated">Ведет себя как &lt;a href=&quot;../../named_req/unformattedinputfunction&quot;&gt;UnformattedInputFunction&lt;/a&gt; , за исключением того, что он имеет неопределенный эффект для &lt;code&gt;is.gcount()&lt;/code&gt; . После построения и проверки объекта сторожевого, попытка разобрать входной поток &lt;code&gt;is&lt;/code&gt; в &lt;code&gt;md&lt;/code&gt; в соответствии с форматом строка &lt;code&gt;fmt&lt;/code&gt; . Если синтаксический анализ не может декодировать действительный &lt;code&gt;month_day&lt;/code&gt; , &lt;code&gt;is.setstate(&lt;a href=&quot;../../io/ios_base/iostate&quot;&gt;std::ios_base::failbit&lt;/a&gt;)&lt;/code&gt; а &lt;code&gt;md&lt;/code&gt; не изменяется.</target>
        </trans-unit>
        <trans-unit id="e065fe398d7803bd86c6a7e26d51804b3b96c6b0" translate="yes" xml:space="preserve">
          <source>Behaves as an &lt;a href=&quot;../../named_req/unformattedinputfunction&quot;&gt;UnformattedInputFunction&lt;/a&gt;, except that it has an unspecified effect on &lt;code&gt;is.gcount()&lt;/code&gt;. After constructing and checking the sentry object, attempts to parse the input stream &lt;code&gt;is&lt;/code&gt; into &lt;code&gt;tp&lt;/code&gt; according to the format string &lt;code&gt;fmt&lt;/code&gt;. If the parse fails to decode a valid time point, &lt;code&gt;is.setstate(&lt;a href=&quot;../../io/ios_base/iostate&quot;&gt;std::ios_base::failbit&lt;/a&gt;)&lt;/code&gt; is called and &lt;code&gt;tp&lt;/code&gt; is not modified.</source>
          <target state="translated">Ведет себя как &lt;a href=&quot;../../named_req/unformattedinputfunction&quot;&gt;UnformattedInputFunction&lt;/a&gt; , за исключением того, что он имеет неопределенный эффект для &lt;code&gt;is.gcount()&lt;/code&gt; . После создания и проверки объекта sentry, попытки проанализировать входной поток &lt;code&gt;is&lt;/code&gt; в &lt;code&gt;tp&lt;/code&gt; в соответствии со строкой формата &lt;code&gt;fmt&lt;/code&gt; . Если синтаксический анализ не может декодировать действительный момент времени, &lt;code&gt;is.setstate(&lt;a href=&quot;../../io/ios_base/iostate&quot;&gt;std::ios_base::failbit&lt;/a&gt;)&lt;/code&gt; и &lt;code&gt;tp&lt;/code&gt; не изменяется.</target>
        </trans-unit>
        <trans-unit id="3e916f1ce3a09969712030a89b921f22ad91cde6" translate="yes" xml:space="preserve">
          <source>Behaves as an &lt;a href=&quot;../../named_req/unformattedinputfunction&quot;&gt;UnformattedInputFunction&lt;/a&gt;, except that it has an unspecified effect on &lt;code&gt;is.gcount()&lt;/code&gt;. After constructing and checking the sentry object, attempts to parse the input stream &lt;code&gt;is&lt;/code&gt; into &lt;code&gt;wd&lt;/code&gt; according to the format string &lt;code&gt;fmt&lt;/code&gt;. If the parse fails to decode a valid &lt;code&gt;weekday&lt;/code&gt;, &lt;code&gt;is.setstate(&lt;a href=&quot;../../io/ios_base/iostate&quot;&gt;std::ios_base::failbit&lt;/a&gt;)&lt;/code&gt; is called and &lt;code&gt;wd&lt;/code&gt; is not modified.</source>
          <target state="translated">Ведет себя как &lt;a href=&quot;../../named_req/unformattedinputfunction&quot;&gt;UnformattedInputFunction&lt;/a&gt; , за исключением того, что он имеет неопределенный эффект для &lt;code&gt;is.gcount()&lt;/code&gt; . После построения и проверки объекта сторожевого, попытка разобрать входной поток &lt;code&gt;is&lt;/code&gt; в &lt;code&gt;wd&lt;/code&gt; в соответствии со строкой формата &lt;code&gt;fmt&lt;/code&gt; . Если анализ не может декодировать действительный &lt;code&gt;weekday&lt;/code&gt; , &lt;code&gt;is.setstate(&lt;a href=&quot;../../io/ios_base/iostate&quot;&gt;std::ios_base::failbit&lt;/a&gt;)&lt;/code&gt; и &lt;code&gt;wd&lt;/code&gt; не изменяется.</target>
        </trans-unit>
        <trans-unit id="534f077e6bac2d7fcd7ec6bfbd2ce8a229d9e671" translate="yes" xml:space="preserve">
          <source>Behaves as an &lt;a href=&quot;../../named_req/unformattedinputfunction&quot;&gt;UnformattedInputFunction&lt;/a&gt;, except that it has an unspecified effect on &lt;code&gt;is.gcount()&lt;/code&gt;. After constructing and checking the sentry object, attempts to parse the input stream &lt;code&gt;is&lt;/code&gt; into &lt;code&gt;y&lt;/code&gt; according to the format string &lt;code&gt;fmt&lt;/code&gt;. If the parse fails to decode a valid &lt;code&gt;year&lt;/code&gt;, &lt;code&gt;is.setstate(&lt;a href=&quot;../../io/ios_base/iostate&quot;&gt;std::ios_base::failbit&lt;/a&gt;)&lt;/code&gt; is called and &lt;code&gt;y&lt;/code&gt; is not modified.</source>
          <target state="translated">Ведет себя как &lt;a href=&quot;../../named_req/unformattedinputfunction&quot;&gt;UnformattedInputFunction&lt;/a&gt; , за исключением того, что он имеет неопределенный эффект для &lt;code&gt;is.gcount()&lt;/code&gt; . После построения и проверки объекта сторожевого, попытка разобрать входной поток &lt;code&gt;is&lt;/code&gt; в &lt;code&gt;y&lt;/code&gt; в соответствии с форматом строка &lt;code&gt;fmt&lt;/code&gt; . Если при синтаксическом анализе не удается декодировать действительный &lt;code&gt;year&lt;/code&gt; , &lt;code&gt;is.setstate(&lt;a href=&quot;../../io/ios_base/iostate&quot;&gt;std::ios_base::failbit&lt;/a&gt;)&lt;/code&gt; а &lt;code&gt;y&lt;/code&gt; не изменяется.</target>
        </trans-unit>
        <trans-unit id="9d1a3df7d8a7fca81ecb344ddc22950a523c840e" translate="yes" xml:space="preserve">
          <source>Behaves as an &lt;a href=&quot;../../named_req/unformattedinputfunction&quot;&gt;UnformattedInputFunction&lt;/a&gt;, except that it has an unspecified effect on &lt;code&gt;is.gcount()&lt;/code&gt;. After constructing and checking the sentry object, attempts to parse the input stream &lt;code&gt;is&lt;/code&gt; into &lt;code&gt;ym&lt;/code&gt; according to the format string &lt;code&gt;fmt&lt;/code&gt;. If the parse fails to decode a valid &lt;code&gt;year_month&lt;/code&gt;, &lt;code&gt;is.setstate(&lt;a href=&quot;../../io/ios_base/iostate&quot;&gt;std::ios_base::failbit&lt;/a&gt;)&lt;/code&gt; is called and &lt;code&gt;ym&lt;/code&gt; is not modified.</source>
          <target state="translated">Ведет себя как &lt;a href=&quot;../../named_req/unformattedinputfunction&quot;&gt;UnformattedInputFunction&lt;/a&gt; , за исключением того, что он имеет неопределенный эффект для &lt;code&gt;is.gcount()&lt;/code&gt; . После построения и проверки объекта сторожевого, попытка разобрать входной поток &lt;code&gt;is&lt;/code&gt; в &lt;code&gt;ym&lt;/code&gt; в соответствии с форматом строка &lt;code&gt;fmt&lt;/code&gt; . Если синтаксический анализ не может декодировать действительный &lt;code&gt;year_month&lt;/code&gt; , &lt;code&gt;is.setstate(&lt;a href=&quot;../../io/ios_base/iostate&quot;&gt;std::ios_base::failbit&lt;/a&gt;)&lt;/code&gt; а &lt;code&gt;ym&lt;/code&gt; не изменяется.</target>
        </trans-unit>
        <trans-unit id="354ffd6415a45c8148f6d721a7550f4e07921a44" translate="yes" xml:space="preserve">
          <source>Behaves as an &lt;a href=&quot;../../named_req/unformattedinputfunction&quot;&gt;UnformattedInputFunction&lt;/a&gt;, except that it has an unspecified effect on &lt;code&gt;is.gcount()&lt;/code&gt;. After constructing and checking the sentry object, attempts to parse the input stream &lt;code&gt;is&lt;/code&gt; into &lt;code&gt;ymd&lt;/code&gt; according to the format string &lt;code&gt;fmt&lt;/code&gt;. If the parse fails to decode a valid &lt;code&gt;year_month_day&lt;/code&gt;, &lt;code&gt;is.setstate(&lt;a href=&quot;../../io/ios_base/iostate&quot;&gt;std::ios_base::failbit&lt;/a&gt;)&lt;/code&gt; is called and &lt;code&gt;ymd&lt;/code&gt; is not modified.</source>
          <target state="translated">Ведет себя как &lt;a href=&quot;../../named_req/unformattedinputfunction&quot;&gt;UnformattedInputFunction&lt;/a&gt; , за исключением того, что он имеет неопределенный эффект для &lt;code&gt;is.gcount()&lt;/code&gt; . После создания и проверки объекта &lt;code&gt;ymd&lt;/code&gt; , попытки проанализировать входной поток &lt;code&gt;is&lt;/code&gt; в ymd в соответствии со строкой формата &lt;code&gt;fmt&lt;/code&gt; . Если синтаксический анализ не может декодировать действительный &lt;code&gt;year_month_day&lt;/code&gt; , &lt;code&gt;is.setstate(&lt;a href=&quot;../../io/ios_base/iostate&quot;&gt;std::ios_base::failbit&lt;/a&gt;)&lt;/code&gt; и &lt;code&gt;ymd&lt;/code&gt; не изменяется.</target>
        </trans-unit>
        <trans-unit id="b31240671d71f38c08c6175c2a624c5485aa3e4b" translate="yes" xml:space="preserve">
          <source>Behaves as an &lt;a href=&quot;../../named_req/unformattedoutputfunction&quot;&gt;UnformattedOutputFunction&lt;/a&gt;. After constructing and checking the sentry object, outputs the characters from successive locations in the character array whose first element is pointed to by &lt;code&gt;s&lt;/code&gt;. Characters are inserted into the output sequence until one of the following occurs:</source>
          <target state="translated">Ведет себя как &lt;a href=&quot;../../named_req/unformattedoutputfunction&quot;&gt;UnformattedOutputFunction&lt;/a&gt; . После создания и проверки объекта sentry выводит символы из последовательных расположений в массиве символов, на первый элемент которого указывает &lt;code&gt;s&lt;/code&gt; . Символы вставляются в выходную последовательность до тех пор, пока не произойдет одно из следующих действий:</target>
        </trans-unit>
        <trans-unit id="420d1377b9bbd844155a88eb257414b14d2edd8c" translate="yes" xml:space="preserve">
          <source>Behaves as an &lt;a href=&quot;../../named_req/unformattedoutputfunction&quot;&gt;UnformattedOutputFunction&lt;/a&gt;. After constructing and checking the sentry object, writes the character &lt;code&gt;ch&lt;/code&gt; to the output stream.</source>
          <target state="translated">Ведет себя как &lt;a href=&quot;../../named_req/unformattedoutputfunction&quot;&gt;UnformattedOutputFunction&lt;/a&gt; . После создания и проверки объекта sentry записывает символ &lt;code&gt;ch&lt;/code&gt; в выходной поток.</target>
        </trans-unit>
        <trans-unit id="82ff397227b9a7ad0f8b7b725088913fce6ee471" translate="yes" xml:space="preserve">
          <source>Behaves as an atomic operation.</source>
          <target state="translated">Ведет себя как атомная операция.</target>
        </trans-unit>
        <trans-unit id="b9dc5d13ce0d39d79ca5f8d6c575a41f58014821" translate="yes" xml:space="preserve">
          <source>Behaves as if applying &lt;code&gt;&lt;a href=&quot;iter_swap&quot;&gt;std::iter_swap&lt;/a&gt;&lt;/code&gt; to every pair of iterators &lt;code&gt;first+i, (last-i) - 1&lt;/code&gt; for each non-negative &lt;code&gt;i &amp;lt; (last-first)/2&lt;/code&gt;</source>
          <target state="translated">Ведет себя так, как будто применяет &lt;code&gt;&lt;a href=&quot;iter_swap&quot;&gt;std::iter_swap&lt;/a&gt;&lt;/code&gt; к каждой паре итераторов &lt;code&gt;first+i, (last-i) - 1&lt;/code&gt; для каждого неотрицательного &lt;code&gt;i &amp;lt; (last-first)/2&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="bed410844ec9fd5b13e393d20c755ef0b8dfbf2d" translate="yes" xml:space="preserve">
          <source>Behaves as if by executing the assignment &lt;code&gt;*(d_first + (last - first) - 1 - i) = *(first + i)&lt;/code&gt; once for each non-negative &lt;code&gt;i &amp;lt; (last - first)&lt;/code&gt;</source>
          <target state="translated">Ведет себя так, как будто выполняет присваивание &lt;code&gt;*(d_first + (last - first) - 1 - i) = *(first + i)&lt;/code&gt; один раз для каждого неотрицательного &lt;code&gt;i &amp;lt; (last - first)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c2095bbba3a93f2559c0792b761c684cd2ef1312" translate="yes" xml:space="preserve">
          <source>Behaves as if it forms a &lt;code&gt;&lt;a href=&quot;../../string/basic_string&quot;&gt;std::basic_string&lt;/a&gt;&amp;lt;CharT, Traits&amp;gt;&lt;/code&gt;&lt;code&gt;str&lt;/code&gt; initially consisting of the characters in &lt;code&gt;&lt;a href=&quot;../../string/basic_string/to_string&quot;&gt;std::to_string&lt;/a&gt;(d.count())&lt;/code&gt; (if &lt;code&gt;CharT&lt;/code&gt; is &lt;code&gt;char&lt;/code&gt;) or &lt;code&gt;&lt;a href=&quot;../../string/basic_string/to_wstring&quot;&gt;std::to_wstring&lt;/a&gt;(d.count())&lt;/code&gt; (if &lt;code&gt;CharT&lt;/code&gt; is &lt;code&gt;wchar_t&lt;/code&gt;). Appends to &lt;code&gt;str&lt;/code&gt; a suffix based on &lt;code&gt;Period::type&lt;/code&gt; according to the following table, and inserts &lt;code&gt;str&lt;/code&gt; into the stream with &lt;code&gt;os &amp;lt;&amp;lt; str;&lt;/code&gt;.</source>
          <target state="translated">Ведет себя так, как если бы он формировал &lt;code&gt;&lt;a href=&quot;../../string/basic_string&quot;&gt;std::basic_string&lt;/a&gt;&amp;lt;CharT, Traits&amp;gt;&lt;/code&gt; &lt;code&gt;str&lt;/code&gt; , первоначально состоящий из символов в &lt;code&gt;&lt;a href=&quot;../../string/basic_string/to_string&quot;&gt;std::to_string&lt;/a&gt;(d.count())&lt;/code&gt; (если &lt;code&gt;CharT&lt;/code&gt; - &lt;code&gt;char&lt;/code&gt; ) или &lt;code&gt;&lt;a href=&quot;../../string/basic_string/to_wstring&quot;&gt;std::to_wstring&lt;/a&gt;(d.count())&lt;/code&gt; (если &lt;code&gt;CharT&lt;/code&gt; равен &lt;code&gt;wchar_t&lt;/code&gt; ). Добавляет &lt;code&gt;str&lt;/code&gt; суффикс на основе &lt;code&gt;Period::type&lt;/code&gt; согласно следующей таблице и вставляет &lt;code&gt;str&lt;/code&gt; в поток с помощью &lt;code&gt;os &amp;lt;&amp;lt; str;&lt;/code&gt; ,</target>
        </trans-unit>
        <trans-unit id="1ba1f2a3eb212b1fa99c5e19994960cbf5cc4c56" translate="yes" xml:space="preserve">
          <source>Behaves like the &lt;code&gt;&lt;a href=&quot;../basic_streambuf/underflow&quot;&gt;underflow()&lt;/a&gt;&lt;/code&gt;, except that if &lt;code&gt;&lt;a href=&quot;../basic_streambuf/underflow&quot;&gt;underflow()&lt;/a&gt;&lt;/code&gt; succeeds (does not return &lt;code&gt;Traits::eof()&lt;/code&gt;), then advances the next pointer for the get area. In other words, consumes one of the characters obtained by &lt;code&gt;&lt;a href=&quot;../basic_streambuf/underflow&quot;&gt;underflow()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Ведет себя как &lt;code&gt;&lt;a href=&quot;../basic_streambuf/underflow&quot;&gt;underflow()&lt;/a&gt;&lt;/code&gt; , за исключением того, что если &lt;code&gt;&lt;a href=&quot;../basic_streambuf/underflow&quot;&gt;underflow()&lt;/a&gt;&lt;/code&gt; завершается успешно (не возвращает &lt;code&gt;Traits::eof()&lt;/code&gt; ), то продвигает следующий указатель для области get. Другими словами, использует один из символов, полученных &lt;code&gt;&lt;a href=&quot;../basic_streambuf/underflow&quot;&gt;underflow()&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c7424443eb2a5187f8df088d1e24d7b153e76c40" translate="yes" xml:space="preserve">
          <source>Behaves like the base class &lt;code&gt;&lt;a href=&quot;../basic_streambuf/overflow&quot;&gt;std::basic_streambuf::overflow&lt;/a&gt;&lt;/code&gt;, except that to write the data, first uses &lt;code&gt;&lt;a href=&quot;../../locale/codecvt/out&quot;&gt;std::codecvt::out&lt;/a&gt;&lt;/code&gt; of the imbued locale to convert the characters into external (possibly multibyte) representation, stored in a temporary buffer (allocated as large as necessary), then uses file I/O to copy all fully-converted bytes into the file.</source>
          <target state="translated">Ведет себя подобно базовому классу &lt;code&gt;&lt;a href=&quot;../basic_streambuf/overflow&quot;&gt;std::basic_streambuf::overflow&lt;/a&gt;&lt;/code&gt; , за исключением того, что для записи данных сначала используется &lt;code&gt;&lt;a href=&quot;../../locale/codecvt/out&quot;&gt;std::codecvt::out&lt;/a&gt;&lt;/code&gt; языкового стандарта для преобразования символов во внешнее (возможно, многобайтовое) представление, хранящееся во временном буфере (выделяется по мере необходимости), затем использует файловый ввод / вывод для копирования всех полностью преобразованных байтов в файл.</target>
        </trans-unit>
        <trans-unit id="ead68b316b3a5bb13de60a50d4b049c735bc0457" translate="yes" xml:space="preserve">
          <source>Behaves like the base class &lt;code&gt;std::basic_streambuf::underflow&lt;/code&gt;, except that to read the data from the associated character sequence (the file) into the get area, first reads the bytes from the file into a temporary buffer (allocated as large as necessary), then uses &lt;code&gt;std::codecvt::in&lt;/code&gt; of the imbued locale to convert the external (typically, multibyte) representation to the internal form which is then used to populate the get area. The conversion may be skipped if the locale's &lt;code&gt;std::codecvt::always_noconv&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">Ведет себя так же, как базовый класс &lt;code&gt;std::basic_streambuf::underflow&lt;/code&gt; , за исключением того, что для чтения данных из связанной последовательности символов (файла) в область get сначала считываются байты из файла во временный буфер (выделяемый по мере необходимости) ), затем использует &lt;code&gt;std::codecvt::in&lt;/code&gt; языкового стандарта для преобразования внешнего (обычно многобайтового) представления во внутреннюю форму, которая затем используется для заполнения области получения. Преобразование может быть пропущено, если &lt;code&gt;std::codecvt::always_noconv&lt;/code&gt; возвращает &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8144558f99cdff249c2ee868ada81e832e47eeb4" translate="yes" xml:space="preserve">
          <source>Behavior as published</source>
          <target state="translated">Поведение в опубликованном виде</target>
        </trans-unit>
        <trans-unit id="3b4de82624ef063c5570a0aa0bb2fd68f2dc6163" translate="yes" xml:space="preserve">
          <source>Bernoulli distributions</source>
          <target state="translated">дистрибуции Бернулли</target>
        </trans-unit>
        <trans-unit id="1e5ebe6f1289f29133bcd6572d2c2241857b3a1a" translate="yes" xml:space="preserve">
          <source>Besides &lt;a href=&quot;operator_other&quot;&gt;function-call expressions&lt;/a&gt;, where &lt;a href=&quot;overload_resolution&quot;&gt;overload resolution&lt;/a&gt; takes place, the name of an overloaded function may appear in the following 7 contexts:</source>
          <target state="translated">Помимо &lt;a href=&quot;operator_other&quot;&gt;выражений вызова функций&lt;/a&gt; , где имеет место &lt;a href=&quot;overload_resolution&quot;&gt;разрешение перегрузки&lt;/a&gt; , имя перегруженной функции может появляться в следующих 7 контекстах:</target>
        </trans-unit>
        <trans-unit id="35a9468290c3394c97c047fe437a550a62007c54" translate="yes" xml:space="preserve">
          <source>Besides commenting out, other mechanisms used for source code exclusion are.</source>
          <target state="translated">Помимо комментариев,для исключения исходного кода используются и другие механизмы.</target>
        </trans-unit>
        <trans-unit id="03958a7c9ad1213ec526869eb4c84b20e58f0961" translate="yes" xml:space="preserve">
          <source>Besides establishing new parse state and position, a call to this function undoes the effects of &lt;code&gt;&lt;a href=&quot;ungetc&quot;&gt;std::ungetc&lt;/a&gt;&lt;/code&gt; and clears the end-of-file state, if it is set.</source>
          <target state="translated">Помимо установления нового состояния и позиции синтаксического анализа, вызов этой функции отменяет эффекты &lt;code&gt;&lt;a href=&quot;ungetc&quot;&gt;std::ungetc&lt;/a&gt;&lt;/code&gt; и очищает состояние конца файла, если оно установлено.</target>
        </trans-unit>
        <trans-unit id="cde31df5b3a6edf2b668225ad16ccbe6298bf72e" translate="yes" xml:space="preserve">
          <source>Besides function calls and operator expressions, template argument deduction is used in the following situations:</source>
          <target state="translated">Кроме вызовов функций и выражений операторов,вычитание аргументов шаблонов используется в следующих ситуациях:</target>
        </trans-unit>
        <trans-unit id="1ea3de9ed1aa39d9d12037783bc2af648287a89b" translate="yes" xml:space="preserve">
          <source>Besides function lvalues, the function call expression supports pointers to functions, dereferenced pointers to member functions, &lt;a href=&quot;lambda&quot;&gt;lambda-expressions&lt;/a&gt;, and any variable of class type that overloads the function-call operator. Together, these types are known as &lt;a href=&quot;../named_req/functionobject&quot;&gt;FunctionObjects&lt;/a&gt;, and they are used ubiquitously through the C++ standard library, see for example, usages of &lt;a href=&quot;../named_req/binarypredicate&quot;&gt;BinaryPredicate&lt;/a&gt; and &lt;a href=&quot;../named_req/compare&quot;&gt;Compare&lt;/a&gt;.</source>
          <target state="translated">Помимо значений функции l, выражение вызова функции поддерживает указатели на функции, разыменованные указатели на функции-члены, &lt;a href=&quot;lambda&quot;&gt;лямбда-выражения&lt;/a&gt; и любую переменную типа класса, которая перегружает оператор вызова функции. Вместе эти типы известны как &lt;a href=&quot;../named_req/functionobject&quot;&gt;FunctionObjects&lt;/a&gt; , и они используются повсеместно через стандартную библиотеку C ++, см., Например, использование &lt;a href=&quot;../named_req/binarypredicate&quot;&gt;BinaryPredicate&lt;/a&gt; и &lt;a href=&quot;../named_req/compare&quot;&gt;Compare&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="eadda9e8c93ae861b29d0afee13d836c6af0e0f7" translate="yes" xml:space="preserve">
          <source>Besides introducing the new exception template &lt;a href=&quot;../error/tx_exception&quot;&gt;&lt;code&gt;std::tx_exception&lt;/code&gt;&lt;/a&gt;, the transactional memory technical specification makes the following changes to the standard library:</source>
          <target state="translated">Помимо введения нового шаблона исключения &lt;a href=&quot;../error/tx_exception&quot;&gt; &lt;code&gt;std::tx_exception&lt;/code&gt; &lt;/a&gt; , техническая спецификация транзакционной памяти вносит следующие изменения в стандартную библиотеку:</target>
        </trans-unit>
        <trans-unit id="f85f4cbfeeefb97ce1a4ae209c4036553a0f1353" translate="yes" xml:space="preserve">
          <source>Besides suitably declared identifiers, the following can be used in expressions in the same role:</source>
          <target state="translated">Кроме подходящих объявленных идентификаторов,в выражениях в той же роли может использоваться следующее:</target>
        </trans-unit>
        <trans-unit id="dc609bbb82549ba7934f717ed858b800830e4534" translate="yes" xml:space="preserve">
          <source>Besides the minimal bit counts, the C++ Standard guarantees that  &lt;code&gt;1 == sizeof(char) &amp;lt;= sizeof(short) &amp;lt;= sizeof(int) &amp;lt;= sizeof(long) &amp;lt;= sizeof(long long)&lt;/code&gt;.</source>
          <target state="translated">Помимо минимального количества битов, стандарт C ++ гарантирует, что &lt;code&gt;1 == sizeof(char) &amp;lt;= sizeof(short) &amp;lt;= sizeof(int) &amp;lt;= sizeof(long) &amp;lt;= sizeof(long long)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c97ed01493243e69d10ffc8e50648f78cab73dcd" translate="yes" xml:space="preserve">
          <source>Besides the standard attributes listed below, implementations may support arbitrary non-standard attributes with implementation-defined behavior. All attributes unknown to an implementation are ignored without causing an error.(since C++17).</source>
          <target state="translated">Кроме стандартных атрибутов,перечисленных ниже,реализации могут поддерживать произвольные нестандартные атрибуты с определённым в реализации поведением.Все неизвестные реализации атрибуты игнорируются,не приводя к ошибке (начиная с C++17).</target>
        </trans-unit>
        <trans-unit id="326ce75ab410687b03d60753ab3b5a7bc3c6aa60" translate="yes" xml:space="preserve">
          <source>Besides the system-specific information necessary to access the device (e.g. a POSIX file descriptor), each C stream object holds the following:</source>
          <target state="translated">Помимо системной информации,необходимой для доступа к устройству (например,файловый дескриптор POSIX),каждый объект C-потока содержит следующее:</target>
        </trans-unit>
        <trans-unit id="987751c78ae2b93d437defad81b5467e3258fa00" translate="yes" xml:space="preserve">
          <source>Best viable function</source>
          <target state="translated">Наилучшая жизнеспособная функция</target>
        </trans-unit>
        <trans-unit id="5445f48f941a5ad1d1542f8d66aef55a24056167" translate="yes" xml:space="preserve">
          <source>Between threads, evaluation A</source>
          <target state="translated">Между нитями,оценка А</target>
        </trans-unit>
        <trans-unit id="08921ac97281717dcf3cc5edee55ed9ec1246d18" translate="yes" xml:space="preserve">
          <source>Between threads, evaluation A is</source>
          <target state="translated">Между нитями,оценка А</target>
        </trans-unit>
        <trans-unit id="2451baa075c4c2006f43575b68fffc6be3054416" translate="yes" xml:space="preserve">
          <source>BidirIt first</source>
          <target state="translated">БидирИт первым</target>
        </trans-unit>
        <trans-unit id="d0770f96a62e4dba7b78dc8ded5a3d2559e0c17b" translate="yes" xml:space="preserve">
          <source>BidirIt second</source>
          <target state="translated">БидирИт-второе</target>
        </trans-unit>
        <trans-unit id="ffdf5ba9df9ed49abf7794c76ef97818235d86f9" translate="yes" xml:space="preserve">
          <source>BidirectionalIterator</source>
          <target state="translated">BidirectionalIterator</target>
        </trans-unit>
        <trans-unit id="482ad58667e3f2f9817b420cb310aa97436e0bbd" translate="yes" xml:space="preserve">
          <source>BidirectionalRange</source>
          <target state="translated">BidirectionalRange</target>
        </trans-unit>
        <trans-unit id="c460d3f926dfc813742e2a51770def855d27f159" translate="yes" xml:space="preserve">
          <source>Binary and text modes</source>
          <target state="translated">Двоичный и текстовый режимы</target>
        </trans-unit>
        <trans-unit id="91150bd6516ac5f77628d936130ba9cf5ec13ae6" translate="yes" xml:space="preserve">
          <source>Binary arithmetic operators</source>
          <target state="translated">двоичные арифметические операторы</target>
        </trans-unit>
        <trans-unit id="b85455cd395dfbce0c44e85498fb4706eb3346ce" translate="yes" xml:space="preserve">
          <source>Binary literals in the C++ core language</source>
          <target state="translated">Двоичные литералы в базовом языке C++</target>
        </trans-unit>
        <trans-unit id="cc724df4c71a335d592593fb78d0f54cdc71de39" translate="yes" xml:space="preserve">
          <source>Binary operators are typically implemented as non-members to maintain symmetry (for example, when adding a complex number and an integer, if &lt;code&gt;operator+&lt;/code&gt; is a member function of the complex type, then only &lt;code&gt;complex+integer&lt;/code&gt; would compile, and not &lt;code&gt;integer+complex&lt;/code&gt;). Since for every binary arithmetic operator there exists a corresponding compound assignment operator, canonical forms of binary operators are implemented in terms of their compound assignments:</source>
          <target state="translated">Бинарные операторы обычно реализуются как не-члены для поддержания симметрии (например, при добавлении комплексного числа и целого числа, если &lt;code&gt;operator+&lt;/code&gt; является функцией-членом сложного типа, компилируется только &lt;code&gt;complex+integer&lt;/code&gt; , а не &lt;code&gt;integer+complex&lt;/code&gt; ) , Поскольку для каждого двоичного арифметического оператора существует соответствующий составной оператор присваивания, канонические формы двоичных операторов реализуются в терминах их составных присваиваний:</target>
        </trans-unit>
        <trans-unit id="9b181c7beda214f4532f13b77ba42314ece1f768" translate="yes" xml:space="preserve">
          <source>Binary search operations (on sorted ranges)</source>
          <target state="translated">Операции двоичного поиска (на отсортированных диапазонах)</target>
        </trans-unit>
        <trans-unit id="9b0e681b6c800f7b05bda65505fa83f5f1a1be72" translate="yes" xml:space="preserve">
          <source>BinaryPredicate</source>
          <target state="translated">BinaryPredicate</target>
        </trans-unit>
        <trans-unit id="d7b9396086e5ec8058fd32dd688322acc6d2bf68" translate="yes" xml:space="preserve">
          <source>BinaryTypeTrait</source>
          <target state="translated">BinaryTypeTrait</target>
        </trans-unit>
        <trans-unit id="3dbc95d187c9e90ca622a826dd7edb08cc9cacfa" translate="yes" xml:space="preserve">
          <source>Binders</source>
          <target state="translated">Binders</target>
        </trans-unit>
        <trans-unit id="f4e69ca5e425a4bf55911c4e6db32c6119febe30" translate="yes" xml:space="preserve">
          <source>Binding a reference to a virtual base class subobject.</source>
          <target state="translated">Привязка ссылки на виртуальный подобъект базового класса.</target>
        </trans-unit>
        <trans-unit id="e9f04cf314fb7952075910e2f9ba75070c56f9c6" translate="yes" xml:space="preserve">
          <source>Binding of</source>
          <target state="translated">Связывание</target>
        </trans-unit>
        <trans-unit id="c0cece0851be5efd26379576b4bcef2caf1dd812" translate="yes" xml:space="preserve">
          <source>Binding of a reference parameter directly to the argument expression is either Identity or a derived-to-base Conversion:</source>
          <target state="translated">Привязкой ссылочного параметра непосредственно к выражению аргумента является либо идентичность,либо производное преобразование в базу:</target>
        </trans-unit>
        <trans-unit id="d829dc6fbeb72ba40b4a6193d7c09ca8de6d9c66" translate="yes" xml:space="preserve">
          <source>Binding rules</source>
          <target state="translated">Обязательные правила</target>
        </trans-unit>
        <trans-unit id="f722c7dc45abe867103665120ef13603cd9867f6" translate="yes" xml:space="preserve">
          <source>Binds a given argument &lt;code&gt;x&lt;/code&gt; to a first or second parameter of the given binary function object &lt;code&gt;f&lt;/code&gt;. That is, stores &lt;code&gt;x&lt;/code&gt; within the resulting wrapper, which, if called, passes &lt;code&gt;x&lt;/code&gt; as the first or the second parameter of &lt;code&gt;f&lt;/code&gt;.</source>
          <target state="translated">Привязывает данный аргумент &lt;code&gt;x&lt;/code&gt; к первому или второму параметру данного двоичного функционального объекта &lt;code&gt;f&lt;/code&gt; . То есть хранит &lt;code&gt;x&lt;/code&gt; в полученной обертке, которая, если она вызывается, передает &lt;code&gt;x&lt;/code&gt; в качестве первого или второго параметра &lt;code&gt;f&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2587e5513df92e2184a69043d5b2d8c64896348f" translate="yes" xml:space="preserve">
          <source>Binds a reference to an object.</source>
          <target state="translated">Привязывает ссылку на объект.</target>
        </trans-unit>
        <trans-unit id="7ff0b1c06c14891fb48b824df8e7692aa76016b3" translate="yes" xml:space="preserve">
          <source>Binds the specified names to subobjects or elements of the initializer.</source>
          <target state="translated">Привязывает указанные имена к подобъектам или элементам инициализатора.</target>
        </trans-unit>
        <trans-unit id="48c22d075b084cd5b8d711e4184eb43a90b6c4ef" translate="yes" xml:space="preserve">
          <source>Binomial coefficients can be expressed in terms of the beta function: \(\binom{n}{k} = \frac{1}{(n+1)B(n-k+1,k+1)}\).</source>
          <target state="translated">Биномиальные коэффициенты могут быть выражены в терминах бета-функции:\(\binom{n}{k}=\frac{1}{(n+1)B(n-k+1,k+1)}\).</target>
        </trans-unit>
        <trans-unit id="e8835c712451999e0a892ac12f5715c4350423b1" translate="yes" xml:space="preserve">
          <source>Bit</source>
          <target state="translated">Bit</target>
        </trans-unit>
        <trans-unit id="b5630cfa9108a371c432ca1b8e629cf6bc1b012a" translate="yes" xml:space="preserve">
          <source>Bit field</source>
          <target state="translated">битовое поле</target>
        </trans-unit>
        <trans-unit id="b045376f837c7f5b36378c8f4a5c40a869f8ef92" translate="yes" xml:space="preserve">
          <source>Bit fields</source>
          <target state="translated">битовые поля</target>
        </trans-unit>
        <trans-unit id="443a8710a8bef103647191f97f7cd879bcad9c73" translate="yes" xml:space="preserve">
          <source>Bit manipulation</source>
          <target state="translated">манипулирование битами</target>
        </trans-unit>
        <trans-unit id="491df97cfa5e39f515f28ec7e2a2d72a45a33da8" translate="yes" xml:space="preserve">
          <source>Bit manipulation (since C++20)</source>
          <target state="translated">Махинации с битами (с C++20)</target>
        </trans-unit>
        <trans-unit id="e6078ce7cb8ef5cea6018354d8a889b9edde5cbc" translate="yes" xml:space="preserve">
          <source>BitmaskType</source>
          <target state="translated">BitmaskType</target>
        </trans-unit>
        <trans-unit id="5ec768dbd17e419b41b32bba46a2d38687d9a71f" translate="yes" xml:space="preserve">
          <source>Bitset</source>
          <target state="translated">Bitset</target>
        </trans-unit>
        <trans-unit id="741c773876c69e2cd07b549c1ea8ece454c609e3" translate="yes" xml:space="preserve">
          <source>Bitwise &lt;a href=&quot;operator_arithmetic#Bitwise_shift_operators&quot;&gt;left shift and right shift&lt;/a&gt;</source>
          <target state="translated">Побитовое &lt;a href=&quot;operator_arithmetic#Bitwise_shift_operators&quot;&gt;смещение влево и вправо&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="17e80e5f71e9b85954b350f117d4dfeb3c5cf70a" translate="yes" xml:space="preserve">
          <source>Bitwise AND</source>
          <target state="translated">И</target>
        </trans-unit>
        <trans-unit id="306fd7520aac5bd6625750560fd55f52696ffa54" translate="yes" xml:space="preserve">
          <source>Bitwise OR of the floating-point exception macros that are both included in &lt;code&gt;excepts&lt;/code&gt; and correspond to floating-point exceptions currently set.</source>
          <target state="translated">Побитовое ИЛИ макросов исключений с плавающей точкой, которые включены в &lt;code&gt;excepts&lt;/code&gt; и соответствуют установленным в данный момент исключениям с плавающей точкой.</target>
        </trans-unit>
        <trans-unit id="35355cba328d12df3bd3dca4cc2c3703b1246bb3" translate="yes" xml:space="preserve">
          <source>Bitwise arithmetic operators</source>
          <target state="translated">битовые арифметические операторы</target>
        </trans-unit>
        <trans-unit id="9137bddcb31c15dd59efa0751eb46d78510d3c77" translate="yes" xml:space="preserve">
          <source>Bitwise logic operators</source>
          <target state="translated">битовые логические операторы</target>
        </trans-unit>
        <trans-unit id="67445a8812f7cd259e3b6e21272d2fddff30a9e2" translate="yes" xml:space="preserve">
          <source>Bitwise operations</source>
          <target state="translated">побочные операции</target>
        </trans-unit>
        <trans-unit id="d49fb1543c1cf037be882f516f8283e8411c03af" translate="yes" xml:space="preserve">
          <source>Bitwise shift operators</source>
          <target state="translated">операторы смены</target>
        </trans-unit>
        <trans-unit id="5bf1d047debbacfb72d2c4727d98ae3d266e79f4" translate="yes" xml:space="preserve">
          <source>Block declaration (a declaration that can appear inside a &lt;a href=&quot;statements#Compound_statement&quot;&gt;block&lt;/a&gt;), which, in turn, can be one of the following:</source>
          <target state="translated">Объявление блока (объявление, которое может появляться внутри &lt;a href=&quot;statements#Compound_statement&quot;&gt;блока&lt;/a&gt; ), которое, в свою очередь, может быть одним из следующих:</target>
        </trans-unit>
        <trans-unit id="e681513340338ab189ae37b3a82732813788fc1e" translate="yes" xml:space="preserve">
          <source>Block scope</source>
          <target state="translated">Блочный прицел</target>
        </trans-unit>
        <trans-unit id="ab7474d238eb40c9da20e933f1c1d4048b69acd4" translate="yes" xml:space="preserve">
          <source>Blocks for the provided duration or until a lock on &lt;code&gt;m&lt;/code&gt; is acquired.</source>
          <target state="translated">Блокирует на предоставленную продолжительность или пока не будет получена блокировка на &lt;code&gt;m&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="92391cb25322ebaeda3d45357ca30e226b318b27" translate="yes" xml:space="preserve">
          <source>Blocks the calling thread until exclusive ownership of the mutex can be obtained.</source>
          <target state="translated">Блокирует вызывающую нить до тех пор,пока не будет получена эксклюзивная собственность на мьютекс.</target>
        </trans-unit>
        <trans-unit id="8f7f11c61615ab6fa684880437bc9968e692fba9" translate="yes" xml:space="preserve">
          <source>Blocks the calling thread until shared ownership of the mutex can be obtained.</source>
          <target state="translated">Блокирует вызывающий поток до тех пор,пока не будет получена общая собственность на мьютекс.</target>
        </trans-unit>
        <trans-unit id="2fd2dcd848502428b39dc60b6225e09d3f0e7e57" translate="yes" xml:space="preserve">
          <source>Blocks the current thread until the thread identified by &lt;code&gt;*this&lt;/code&gt; finishes its execution.</source>
          <target state="translated">Блокирует текущий поток до тех пор, пока поток, обозначенный &lt;code&gt;*this&lt;/code&gt; завершит свое выполнение.</target>
        </trans-unit>
        <trans-unit id="6e00d4fd15cea4053d3d66470eca6ff8a4eb81f0" translate="yes" xml:space="preserve">
          <source>Blocks the execution of the current thread for</source>
          <target state="translated">Блокирует выполнение текущего потока для</target>
        </trans-unit>
        <trans-unit id="74a224c0de9a1fe8a0d5475e7041194e73e5a53a" translate="yes" xml:space="preserve">
          <source>Blocks the execution of the current thread until specified &lt;code&gt;sleep_time&lt;/code&gt; has been reached.</source>
          <target state="translated">Блокирует выполнение текущего потока, пока не будет достигнуто указанное значение &lt;code&gt;sleep_time&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9af45472a96a859ddc1794b6abf6298174b74613" translate="yes" xml:space="preserve">
          <source>Blocks until a lock can be obtained for the current execution agent (thread, process, task). If an exception is thrown, no lock is obtained.</source>
          <target state="translated">Блокирует до тех пор,пока не будет получена блокировка для текущего агента исполнения (поток,процесс,задача).Если выбрасывается исключение,то блокировка не получается.</target>
        </trans-unit>
        <trans-unit id="eba863ee2c609bd20888a9ee01d8f0bc03fe3b0b" translate="yes" xml:space="preserve">
          <source>Blocks until the provided time limit point is reached or a lock on &lt;code&gt;m&lt;/code&gt; is acquired.</source>
          <target state="translated">Блокируется до тех пор, пока не будет достигнута заданная временная граница или не будет получена блокировка на &lt;code&gt;m&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fb596caefce629504fd3a475f3183426b8a356e3" translate="yes" xml:space="preserve">
          <source>Blocks until the result becomes available. &lt;code&gt;valid() == true&lt;/code&gt; after the call.</source>
          <target state="translated">Блокирует, пока результат не станет доступным. &lt;code&gt;valid() == true&lt;/code&gt; после вызова.</target>
        </trans-unit>
        <trans-unit id="b76ff4906f33c2dd97ddd929b9662ba8cac6174c" translate="yes" xml:space="preserve">
          <source>Boolean</source>
          <target state="translated">Boolean</target>
        </trans-unit>
        <trans-unit id="7bb852d637486dd2f9b852b32fe5bd9ba4fa4b63" translate="yes" xml:space="preserve">
          <source>Boolean conversions</source>
          <target state="translated">булевы преобразования</target>
        </trans-unit>
        <trans-unit id="c9a26dc7a812c76d486afec462ae9a205a68b3e6" translate="yes" xml:space="preserve">
          <source>Boolean literals</source>
          <target state="translated">булевские буквы</target>
        </trans-unit>
        <trans-unit id="74e13cd703ad7a9a0db9e8fcedf7a2cbccdea7d3" translate="yes" xml:space="preserve">
          <source>Boolean negation operator</source>
          <target state="translated">логический оператор отрицания</target>
        </trans-unit>
        <trans-unit id="49f29c844f200eead7503c6d10737135d242ba2b" translate="yes" xml:space="preserve">
          <source>Boolean type</source>
          <target state="translated">булевский тип</target>
        </trans-unit>
        <trans-unit id="a14c6ec0166e69a3cf0be1f4ccc882e1dc773e55" translate="yes" xml:space="preserve">
          <source>Both &lt;a href=&quot;../../language/new&quot;&gt;new-expression&lt;/a&gt; and &lt;a href=&quot;../../language/delete&quot;&gt;delete-expression&lt;/a&gt;, when used with objects whose alignment requirement is greater than &lt;code&gt;__STDCPP_DEFAULT_NEW_ALIGNMENT__&lt;/code&gt;, pass that alignment requirement as an argument of type &lt;code&gt;std::align_val_t&lt;/code&gt; to the selected allocation/deallocation function.</source>
          <target state="translated">И &lt;a href=&quot;../../language/new&quot;&gt;new-expression,&lt;/a&gt; и &lt;a href=&quot;../../language/delete&quot;&gt;delete-expression&lt;/a&gt; , когда используются с объектами, требование выравнивания которых больше, чем &lt;code&gt;__STDCPP_DEFAULT_NEW_ALIGNMENT__&lt;/code&gt; , передают это требование выравнивания в качестве аргумента типа &lt;code&gt;std::align_val_t&lt;/code&gt; выбранной функции выделения / освобождения.</target>
        </trans-unit>
        <trans-unit id="efa828bc8c6e261a85369b79ad278f982b80b478" translate="yes" xml:space="preserve">
          <source>Both &lt;a href=&quot;function_template&quot;&gt;function template&lt;/a&gt; and &lt;a href=&quot;class_template&quot;&gt;class template&lt;/a&gt; declarations may appear with the &lt;code&gt;friend&lt;/code&gt; specifier in any non-local class or class template (although only function templates may be defined within the class or class template that is granting friendship). In this case, every specialization of the template becomes a friend, whether it is implicitly instantiated, partially specialized, or explicitly specialized.</source>
          <target state="translated">Как &lt;a href=&quot;function_template&quot;&gt;шаблоны функций, так&lt;/a&gt; и объявления шаблонов &lt;a href=&quot;class_template&quot;&gt;классов&lt;/a&gt; могут появляться с указателем &lt;code&gt;friend&lt;/code&gt; в любом нелокальном классе или шаблоне класса (хотя в классе или шаблоне класса, который предоставляет дружбу, могут быть определены только шаблоны функций). В этом случае каждая специализация шаблона становится другом, независимо от того, является ли он неявно созданным, частично специализированным или явно специализированным.</target>
        </trans-unit>
        <trans-unit id="63016d3fee2638a4d3429bfc299eeab7075b466b" translate="yes" xml:space="preserve">
          <source>Both &lt;code&gt;EXIT_SUCCESS&lt;/code&gt; and the value zero indicate successful program execution status (see &lt;code&gt;&lt;a href=&quot;exit&quot;&gt;std::exit&lt;/a&gt;&lt;/code&gt;), although it is not required that &lt;code&gt;EXIT_SUCCESS&lt;/code&gt; equals zero.</source>
          <target state="translated">И &lt;code&gt;EXIT_SUCCESS&lt;/code&gt; , и нулевое значение указывают на статус успешного выполнения программы (см. &lt;code&gt;&lt;a href=&quot;exit&quot;&gt;std::exit&lt;/a&gt;&lt;/code&gt; ), хотя необязательно, чтобы &lt;code&gt;EXIT_SUCCESS&lt;/code&gt; равнялся нулю.</target>
        </trans-unit>
        <trans-unit id="ff19dd1cff37c69bcf7f62a061f0632df661ad27" translate="yes" xml:space="preserve">
          <source>Both constructors (other than &lt;a href=&quot;copy_constructor&quot;&gt;copy&lt;/a&gt;/&lt;a href=&quot;move_constructor&quot;&gt;move&lt;/a&gt;) and user-defined conversion functions may be function templates; the meaning of &lt;code&gt;explicit&lt;/code&gt; doesn't change.</source>
          <target state="translated">И конструкторы (кроме &lt;a href=&quot;copy_constructor&quot;&gt;копирования&lt;/a&gt; / &lt;a href=&quot;move_constructor&quot;&gt;перемещения&lt;/a&gt; ) и определяемые пользователем функции преобразования могут быть шаблонами функций; значение &lt;code&gt;explicit&lt;/code&gt; не меняется.</target>
        </trans-unit>
        <trans-unit id="6b2dfd50c4fa7ea73355cbddda751f4dda04b1d2" translate="yes" xml:space="preserve">
          <source>Both constructors are protected, and are only called by the concrete streambuf classes, such as &lt;code&gt;&lt;a href=&quot;../basic_filebuf&quot;&gt;std::basic_filebuf&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../basic_stringbuf&quot;&gt;std::basic_stringbuf&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;../strstreambuf&quot;&gt;std::strstreambuf&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Оба конструктора защищены и вызываются только конкретными классами streambuf, такими как &lt;code&gt;&lt;a href=&quot;../basic_filebuf&quot;&gt;std::basic_filebuf&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../basic_stringbuf&quot;&gt;std::basic_stringbuf&lt;/a&gt;&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;../strstreambuf&quot;&gt;std::strstreambuf&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a919957c7deab2ea5acd8f4154fbcf839bb6dac2" translate="yes" xml:space="preserve">
          <source>Both copy- and move-assignment operators for directory_entry are are defaulted.</source>
          <target state="translated">Операторы копирования и переноса для директории_ввода по умолчанию.</target>
        </trans-unit>
        <trans-unit id="5bb05230f21307e6f1e1d771c4a72fefe561d481" translate="yes" xml:space="preserve">
          <source>Both scoped enumeration types and unscoped enumeration types whose underlying type is fixed can be initialized from an integer without a cast, using &lt;a href=&quot;list_initialization&quot;&gt;list initialization&lt;/a&gt;, if all of the following is true:</source>
          <target state="translated">И типы перечисления с областью действия, и типы перечисления с незаданной областью, базовый тип которых является фиксированным, могут быть инициализированы из целого числа без преобразования, используя &lt;a href=&quot;list_initialization&quot;&gt;инициализацию списка&lt;/a&gt; , если выполняется все следующее:</target>
        </trans-unit>
        <trans-unit id="5deba5db9615b12e705c1e44fac1908355100dcb" translate="yes" xml:space="preserve">
          <source>Both single-object and array allocation functions may be defined as public static member functions of a class (versions (15-18)). If defined, these allocation functions are called by &lt;a href=&quot;../../language/new&quot;&gt;new-expressions&lt;/a&gt; to allocate memory for single objects and arrays of this class, unless the new expression used the form &lt;code&gt;::new&lt;/code&gt; which bypasses class-scope lookup. The keyword &lt;code&gt;static&lt;/code&gt; is optional for these functions: whether used or not, the allocation function is a static member function.</source>
          <target state="translated">Функции выделения как одного объекта, так и массива могут быть определены как общедоступные статические функции-члены класса (версии (15-18)). Если они определены, эти функции выделения вызываются выражениями &lt;a href=&quot;../../language/new&quot;&gt;new&lt;/a&gt; для выделения памяти для отдельных объектов и массивов этого класса, если только новое выражение не использует форму &lt;code&gt;::new&lt;/code&gt; , которая обходит поиск в классе. Ключевое слово &lt;code&gt;static&lt;/code&gt; является необязательным для этих функций: независимо от того, используется или нет, функция распределения является статической функцией-членом.</target>
        </trans-unit>
        <trans-unit id="0028861eddd8245788364237b82fa610aebd0d8e" translate="yes" xml:space="preserve">
          <source>Both this function and the constructor of &lt;code&gt;&lt;a href=&quot;../shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&lt;/code&gt; may be used to acquire temporary ownership of the managed object referred to by a &lt;code&gt;std::weak_ptr&lt;/code&gt;. The difference is that the constructor of &lt;code&gt;&lt;a href=&quot;../shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&lt;/code&gt; throws an exception when its &lt;code&gt;std::weak_ptr&lt;/code&gt; argument is empty, while &lt;code&gt;std::weak_ptr&amp;lt;T&amp;gt;::lock()&lt;/code&gt; constructs an empty &lt;code&gt;std::shared_ptr&amp;lt;T&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">И эта функция, и конструктор &lt;code&gt;&lt;a href=&quot;../shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&lt;/code&gt; могут использоваться для получения временного владения управляемым объектом, на который ссылается &lt;code&gt;std::weak_ptr&lt;/code&gt; . Разница заключается в том, что конструктор &lt;code&gt;&lt;a href=&quot;../shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&lt;/code&gt; выдает исключение, когда его аргумент &lt;code&gt;std::weak_ptr&lt;/code&gt; пуст, а &lt;code&gt;std::weak_ptr&amp;lt;T&amp;gt;::lock()&lt;/code&gt; создает пустой &lt;code&gt;std::shared_ptr&amp;lt;T&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c71adfce132d82af6ce298cc94111b2a04e3c1ab" translate="yes" xml:space="preserve">
          <source>Both versions are constant expressions of type &lt;code&gt;&lt;a href=&quot;../types/size_t&quot;&gt;std::size_t&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Обе версии являются константными выражениями типа &lt;code&gt;&lt;a href=&quot;../types/size_t&quot;&gt;std::size_t&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="943facfd40f56533abfb37b73ee46c45ee23481a" translate="yes" xml:space="preserve">
          <source>Boyer-Moore search algorithm implementation</source>
          <target state="translated">Реализация алгоритма поиска Бойер-Мур</target>
        </trans-unit>
        <trans-unit id="498eeb65762b20bc8f5d61f62b5b2037e626f9c9" translate="yes" xml:space="preserve">
          <source>Boyer-Moore-Horspool search algorithm implementation</source>
          <target state="translated">Реализация алгоритма поиска Boyer-Moore-Horspool</target>
        </trans-unit>
        <trans-unit id="f87d9810eeab220cb3bd2cc07cbf939aafc31cb1" translate="yes" xml:space="preserve">
          <source>Brace-enclosed initializers</source>
          <target state="translated">Инициализаторы в закрытом корпусе</target>
        </trans-unit>
        <trans-unit id="014d790a3d5a9df8c0ff4408ebe540186f635544" translate="yes" xml:space="preserve">
          <source>Breaks the association of the associated mutex, if any, and &lt;code&gt;*this&lt;/code&gt;.</source>
          <target state="translated">Разрывает ассоциацию ассоциированного мьютекса, если он есть, и &lt;code&gt;*this&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c7dfd8323fd5e72ce649953eb9bbb100abdbf328" translate="yes" xml:space="preserve">
          <source>Broken pipe</source>
          <target state="translated">Кусочки труб</target>
        </trans-unit>
        <trans-unit id="e5817b915ebc6c65487325f1fad96d1830f9ec3a" translate="yes" xml:space="preserve">
          <source>Bucket index for the key &lt;code&gt;key&lt;/code&gt;.</source>
          <target state="translated">Индекс корзины для &lt;code&gt;key&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1578c16566abfd5ed0ac525177c29f906ca89176" translate="yes" xml:space="preserve">
          <source>Bucket interface</source>
          <target state="translated">Ковшовый интерфейс</target>
        </trans-unit>
        <trans-unit id="39da5ebcfeabc5cbfab75222627dd08adc0b92bb" translate="yes" xml:space="preserve">
          <source>Build level and violation handling</source>
          <target state="translated">Строить уровень и обработка нарушений</target>
        </trans-unit>
        <trans-unit id="20f409cc87c744070ec80e942947a590f8db80d1" translate="yes" xml:space="preserve">
          <source>Built-in</source>
          <target state="translated">Built-in</target>
        </trans-unit>
        <trans-unit id="5620451e3028694b641893b89d306b16dd893957" translate="yes" xml:space="preserve">
          <source>Built-in &lt;a href=&quot;operator_comparison#Three-way_comparison&quot;&gt;three-way comparison operator&lt;/a&gt;</source>
          <target state="translated">Встроенный &lt;a href=&quot;operator_comparison#Three-way_comparison&quot;&gt;трехсторонний оператор сравнения&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ba57c0678fa197d58d012dcdbd8ff367ded4373c" translate="yes" xml:space="preserve">
          <source>Built-in address-of operator</source>
          <target state="translated">Встроенный адрес оператора</target>
        </trans-unit>
        <trans-unit id="89c57ad877bc748c74e85159feaaf08e70f5f5a1" translate="yes" xml:space="preserve">
          <source>Built-in comma operator</source>
          <target state="translated">Встроенный оператор запятой</target>
        </trans-unit>
        <trans-unit id="29c41e2e5a519d072283f8900cfb2aecddea654d" translate="yes" xml:space="preserve">
          <source>Built-in function call operator</source>
          <target state="translated">Встроенный оператор вызова функций</target>
        </trans-unit>
        <trans-unit id="6a837a52363a7caaa8043442690c260da71652ff" translate="yes" xml:space="preserve">
          <source>Built-in indirection operator</source>
          <target state="translated">Встроенный оператор связи</target>
        </trans-unit>
        <trans-unit id="667f2d7df45e4a7b467abfa721de0d718054104f" translate="yes" xml:space="preserve">
          <source>Built-in member access operators</source>
          <target state="translated">Встроенные операторы доступа</target>
        </trans-unit>
        <trans-unit id="76bd10380a7941d509b7c26c3c0d87d1eddae2bc" translate="yes" xml:space="preserve">
          <source>Built-in pointer-to-member access operators</source>
          <target state="translated">Встроенные операторы доступа по указателю на члена</target>
        </trans-unit>
        <trans-unit id="74faee7794760c0f5ba932d0cc3927a1f7c63af0" translate="yes" xml:space="preserve">
          <source>Built-in postfix operators</source>
          <target state="translated">Встроенные постфиксные операторы</target>
        </trans-unit>
        <trans-unit id="c49aba310c5c949e131422dc6d86594cd3fd9999" translate="yes" xml:space="preserve">
          <source>Built-in prefix operators</source>
          <target state="translated">Встроенные префиксные операторы</target>
        </trans-unit>
        <trans-unit id="01e1dbd00564662647a6c23a14ae45eff862413d" translate="yes" xml:space="preserve">
          <source>Built-in subscript operator</source>
          <target state="translated">Встроенный абонентский оператор</target>
        </trans-unit>
        <trans-unit id="97de26f6f9f063ed744153d8d933e88e0b59a100" translate="yes" xml:space="preserve">
          <source>Builtin compound assignment</source>
          <target state="translated">Назначение стройкомплекса</target>
        </trans-unit>
        <trans-unit id="860269ba76f59f407f62610e614523ed6bb2b17c" translate="yes" xml:space="preserve">
          <source>Builtin direct assignment</source>
          <target state="translated">Строить прямое назначение</target>
        </trans-unit>
        <trans-unit id="cd27a3b8b65f3e0b8397cd40fb51bd882218435c" translate="yes" xml:space="preserve">
          <source>Builtin operators &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; and &lt;code&gt;||&lt;/code&gt; perform short-circuit evaluation (do not evaluate the second operand if the result is known after evaluating the first), but overloaded operators behave like regular function calls and always evaluate both operands</source>
          <target state="translated">Встроенные операторы &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; и &lt;code&gt;||&lt;/code&gt; выполнять оценку короткого замыкания (не оценивать второй операнд, если результат известен после вычисления первого), но перегруженные операторы ведут себя как обычные вызовы функций и всегда оценивают оба операнда</target>
        </trans-unit>
        <trans-unit id="05d591efb279e3a248c17303baf5ea55526a4063" translate="yes" xml:space="preserve">
          <source>But the same parameter cannot be given default arguments twice in the same scope.</source>
          <target state="translated">Но один и тот же параметр не может быть дважды задан аргументами по умолчанию в одной и той же области.</target>
        </trans-unit>
        <trans-unit id="ae372236d69794d1162dbcde117c87725ee50599" translate="yes" xml:space="preserve">
          <source>By default (with the default &lt;code&gt;&lt;a href=&quot;../char_traits&quot;&gt;std::char_traits&lt;/a&gt;&lt;/code&gt;), this function is not locale-sensitive. See &lt;code&gt;&lt;a href=&quot;../../locale/collate/compare&quot;&gt;std::collate::compare&lt;/a&gt;&lt;/code&gt; for locale-aware three-way string comparison.</source>
          <target state="translated">По умолчанию (со стандартным &lt;code&gt;&lt;a href=&quot;../char_traits&quot;&gt;std::char_traits&lt;/a&gt;&lt;/code&gt; ) эта функция не зависит от локали. См. &lt;code&gt;&lt;a href=&quot;../../locale/collate/compare&quot;&gt;std::collate::compare&lt;/a&gt;&lt;/code&gt; для трехстороннего сравнения строк с учетом локали.</target>
        </trans-unit>
        <trans-unit id="f3a260b7cae289fb8e1fb6ad3c38b354a5c26916" translate="yes" xml:space="preserve">
          <source>By default, all eight standard C++ streams are synchronized with their respective C streams.</source>
          <target state="translated">По умолчанию все восемь стандартных потоков C++синхронизированы с соответствующими им потоками C.</target>
        </trans-unit>
        <trans-unit id="ce023180676c6490743b29e9926007bad4819315" translate="yes" xml:space="preserve">
          <source>By default, symlinks are not followed, but this can be enabled by specifying the directory option &lt;a href=&quot;directory_options&quot;&gt;&lt;code&gt;follow_directory_symlink&lt;/code&gt;&lt;/a&gt; at construction time.</source>
          <target state="translated">По умолчанию символические ссылки не используются, но это можно включить, указав параметр каталога &lt;a href=&quot;directory_options&quot;&gt; &lt;code&gt;follow_directory_symlink&lt;/code&gt; &lt;/a&gt; во время создания.</target>
        </trans-unit>
        <trans-unit id="0eb851d780be859c6cd08434ab3959f35e91fa13" translate="yes" xml:space="preserve">
          <source>By default, the standard streams &lt;code&gt;cin&lt;/code&gt; and &lt;code&gt;cerr&lt;/code&gt; are tied to &lt;code&gt;cout&lt;/code&gt;. Similarly, their wide counterparts &lt;code&gt;wcin&lt;/code&gt; and &lt;code&gt;wcerr&lt;/code&gt; are tied to &lt;code&gt;wcout&lt;/code&gt;.</source>
          <target state="translated">По умолчанию стандартные потоки &lt;code&gt;cin&lt;/code&gt; и &lt;code&gt;cerr&lt;/code&gt; привязаны к &lt;code&gt;cout&lt;/code&gt; . Точно так же их широкие аналоги &lt;code&gt;wcin&lt;/code&gt; и &lt;code&gt;wcerr&lt;/code&gt; связаны с &lt;code&gt;wcout&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c0541acf21651250dc0b8e2afd7f3da25009343a" translate="yes" xml:space="preserve">
          <source>By default, this will call placement-new, as by &lt;code&gt;::new((void*)p) T()&lt;/code&gt; (that is, &lt;a href=&quot;../language/value_initialization&quot;&gt;value-initialize&lt;/a&gt; the object pointed to by &lt;code&gt;p&lt;/code&gt;). If value-initialization is undesirable, for example, if the object is of non-class type and zeroing out is not needed, it can be avoided by providing a &lt;a href=&quot;http://stackoverflow.com/a/21028912/273767&quot;&gt;custom Allocator::construct&lt;/a&gt;.</source>
          <target state="translated">По умолчанию это будет вызывать Placement-New, как: &lt;code&gt;::new((void*)p) T()&lt;/code&gt; (то есть &lt;a href=&quot;../language/value_initialization&quot;&gt;инициализировать&lt;/a&gt; значение объекта, на который указывает &lt;code&gt;p&lt;/code&gt; ). Если инициализация значения нежелательна, например, если объект не принадлежит к классу и обнуление не требуется, этого можно избежать, предоставив &lt;a href=&quot;http://stackoverflow.com/a/21028912/273767&quot;&gt;пользовательскую конструкцию Allocator ::&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d236d4012192938e212acacd3e99444273086ecb" translate="yes" xml:space="preserve">
          <source>By default, this will call placement-new, as by &lt;code&gt;::new((void*)p) T()&lt;/code&gt; (that is, &lt;a href=&quot;../language/value_initialization&quot;&gt;value-initialize&lt;/a&gt; the object pointed to by &lt;code&gt;p&lt;/code&gt;). If value-initialization is undesirable, for example, if the object is of non-class type and zeroing out is not needed, it can be avoided by providing a &lt;a href=&quot;https://stackoverflow.com/a/21028912/273767&quot;&gt;custom Allocator::construct&lt;/a&gt;.</source>
          <target state="translated">По умолчанию это вызовет размещение-новое, например &lt;code&gt;::new((void*)p) T()&lt;/code&gt; (то есть &lt;a href=&quot;../language/value_initialization&quot;&gt;инициализирует&lt;/a&gt; значение объекта, на который указывает &lt;code&gt;p&lt;/code&gt; ). Если инициализация значения нежелательна, например, если объект не относится к классу и обнуление не требуется, этого можно избежать, предоставив &lt;a href=&quot;https://stackoverflow.com/a/21028912/273767&quot;&gt;настраиваемую конструкцию Allocator ::&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7803ee252527503b67d1eeb0deb252622746cebd" translate="yes" xml:space="preserve">
          <source>Byte</source>
          <target state="translated">Byte</target>
        </trans-unit>
        <trans-unit id="8e26337cf6bb10967dc0cb055379c6312a7a94ee" translate="yes" xml:space="preserve">
          <source>Byte/multibyte character</source>
          <target state="translated">Байт/мультибайт</target>
        </trans-unit>
        <trans-unit id="32096c2e0eff33d844ee6d675407ace18289357d" translate="yes" xml:space="preserve">
          <source>C</source>
          <target state="translated">C</target>
        </trans-unit>
        <trans-unit id="15c24806702abe5ea48e31ecde1d9e103ea60746" translate="yes" xml:space="preserve">
          <source>C &lt;a href=&quot;language_linkage&quot;&gt;language linkage&lt;/a&gt; is not allowed.</source>
          <target state="translated">&lt;a href=&quot;language_linkage&quot;&gt;Связь на языке&lt;/a&gt; C не допускается.</target>
        </trans-unit>
        <trans-unit id="09b5b3333cb4ff4683a9d0855cb7f956ff522e8f" translate="yes" xml:space="preserve">
          <source>C Date and time utilities</source>
          <target state="translated">C Дата и время утилиты</target>
        </trans-unit>
        <trans-unit id="1eca25182c934c202df4d629e6f313747250a6f1" translate="yes" xml:space="preserve">
          <source>C compatibility header.</source>
          <target state="translated">Заголовок совместимости C.</target>
        </trans-unit>
        <trans-unit id="f27d46df9dc50736ed4e3b3843a69d430fee37b8" translate="yes" xml:space="preserve">
          <source>C compatibility headers</source>
          <target state="translated">Заголовки совместимости с C</target>
        </trans-unit>
        <trans-unit id="b75858e6f52757d42995120144302a816dcfb58b" translate="yes" xml:space="preserve">
          <source>C compatibility macro constant, expands to integer constant &lt;code&gt;1&lt;/code&gt;</source>
          <target state="translated">Макропостоянная совместимость с C, расширяется до целочисленной константы &lt;code&gt;1&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3a96bb87493004f593e10038ce1e6395886cc3ef" translate="yes" xml:space="preserve">
          <source>C library</source>
          <target state="translated">C-библиотека</target>
        </trans-unit>
        <trans-unit id="085bb2391a15d3dae8b4fa9f82fd51d51923f45e" translate="yes" xml:space="preserve">
          <source>C library locales</source>
          <target state="translated">Местонахождение библиотеки C</target>
        </trans-unit>
        <trans-unit id="401eb191196e5e41faa446684424f56e654762b8" translate="yes" xml:space="preserve">
          <source>C localization utilities</source>
          <target state="translated">C утилиты локализации</target>
        </trans-unit>
        <trans-unit id="f247a737aad973565e0ba61f676327ab62c8b7fc" translate="yes" xml:space="preserve">
          <source>C memory management library</source>
          <target state="translated">библиотека управления памятью на C</target>
        </trans-unit>
        <trans-unit id="726cf0d2d039a3d7cb20400e7f928d472fbf197c" translate="yes" xml:space="preserve">
          <source>C numeric limits interface</source>
          <target state="translated">Интерфейс числовых ограничений C</target>
        </trans-unit>
        <trans-unit id="b970bd670bcff0b0de508ab26d86ee7e72402f93" translate="yes" xml:space="preserve">
          <source>C random library</source>
          <target state="translated">C произвольная библиотека</target>
        </trans-unit>
        <trans-unit id="56b2ac8093b8f482b9514d65903de1ddffba1b90" translate="yes" xml:space="preserve">
          <source>C streams are objects of type &lt;code&gt;std::FILE&lt;/code&gt; that can only be accessed and manipulated through pointers of type &lt;code&gt;std::FILE*&lt;/code&gt; (Note: while it may be possible to create a local object of type &lt;code&gt;std::FILE&lt;/code&gt; by dereferencing and copying a valid &lt;code&gt;std::FILE*&lt;/code&gt;, using the address of such copy in the I/O functions is undefined behavior). Each C stream is associated with an external physical device (file, standard input stream, printer, serial port, etc).</source>
          <target state="translated">Потоки C - это объекты типа &lt;code&gt;std::FILE&lt;/code&gt; , доступ к которым можно получить и манипулировать только с помощью указателей типа &lt;code&gt;std::FILE*&lt;/code&gt; (Примечание: хотя возможно создание локального объекта типа &lt;code&gt;std::FILE&lt;/code&gt; путем разыменования и копирования valid &lt;code&gt;std::FILE*&lt;/code&gt; , использование адреса такой копии в функциях ввода / вывода - неопределенное поведение). Каждый поток C связан с внешним физическим устройством (файл, стандартный поток ввода, принтер, последовательный порт и т. Д.).</target>
        </trans-unit>
        <trans-unit id="a6cb82dfe4668eb03399d738975e3f7f2a00e75b" translate="yes" xml:space="preserve">
          <source>C streams can be used for both unformatted and formatted input and output. They are locale-sensitive and may perform wide/multibyte conversions as necessary. Unlike C++ streams, where each stream is associated with its own locale, all C streams access the same locale object: the one most recently installed with &lt;code&gt;&lt;a href=&quot;../locale/setlocale&quot;&gt;std::setlocale&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">C-потоки могут использоваться как для неформатированного, так и для форматированного ввода и вывода. Они чувствительны к локали и могут выполнять широкое / многобайтовое преобразование по мере необходимости. В отличие от потоков C ++, где каждый поток связан со своей собственной локалью, все потоки C имеют доступ к одному и тому же объекту локали: тот, который был установлен последний раз с помощью &lt;code&gt;&lt;a href=&quot;../locale/setlocale&quot;&gt;std::setlocale&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="79c384f1ba053ea6a78d8c958d790e56d9052ca1" translate="yes" xml:space="preserve">
          <source>C string holding the name of the desired category</source>
          <target state="translated">C строка,содержащая имя нужной категории</target>
        </trans-unit>
        <trans-unit id="437c617752c611b36293355138fcbc5720307f88" translate="yes" xml:space="preserve">
          <source>C string holding the name of the desired mapping.</source>
          <target state="translated">C строка,содержащая имя нужного отображения.</target>
        </trans-unit>
        <trans-unit id="136b0b9b8ee0529927aebb743b29982272ffa9e4" translate="yes" xml:space="preserve">
          <source>C&amp;amp;</source>
          <target state="translated">C&amp;amp;</target>
        </trans-unit>
        <trans-unit id="fc2b4216164cfb01ac45112054b3fedda8b56c86" translate="yes" xml:space="preserve">
          <source>C++</source>
          <target state="translated">C++</target>
        </trans-unit>
        <trans-unit id="2f6d341776b09562a2d3ff15e2b8fa6906d9644e" translate="yes" xml:space="preserve">
          <source>C++ (and C) source code may be written in any non-ASCII 7-bit character set that includes the &lt;a href=&quot;https://en.wikipedia.org/wiki/ISO_646&quot;&gt;ISO 646:1983&lt;/a&gt; invariant character set. However, several C++ operators and punctuators require characters that are outside of the ISO 646 codeset: &lt;code&gt;{, }, [, ], #, \, ^, |, ~&lt;/code&gt;. To be able to use character encodings where some or all of these symbols do not exist (such as the German &lt;a href=&quot;http://de.wikipedia.org/wiki/DIN_66003&quot;&gt;DIN 66003&lt;/a&gt;), C++ defines the following alternatives composed of ISO 646 compatible characters.</source>
          <target state="translated">Исходный код C ++ (и C) может быть написан в любом не-ASCII 7-битном наборе символов, который включает инвариантный набор символов &lt;a href=&quot;https://en.wikipedia.org/wiki/ISO_646&quot;&gt;ISO 646: 1983&lt;/a&gt; . Однако для некоторых операторов и знаков препинания C ++ требуются символы, которые находятся за пределами кодового набора ISO 646: &lt;code&gt;{, }, [, ], #, \, ^, |, ~&lt;/code&gt; . Чтобы иметь возможность использовать кодировки символов, где некоторые или все эти символы не существуют (например, немецкий &lt;a href=&quot;http://de.wikipedia.org/wiki/DIN_66003&quot;&gt;DIN 66003&lt;/a&gt; ), C ++ определяет следующие альтернативы, состоящие из символов, совместимых с ISO 646.</target>
        </trans-unit>
        <trans-unit id="8274017a1dfc8a6e7bcb25acc6a50472b6e52ca1" translate="yes" xml:space="preserve">
          <source>C++ (and C) source code may be written in any non-ASCII 7-bit character set that includes the &lt;a href=&quot;https://en.wikipedia.org/wiki/ISO_646&quot;&gt;ISO 646:1983&lt;/a&gt; invariant character set. However, several C++ operators and punctuators require characters that are outside of the ISO 646 codeset: &lt;code&gt;{, }, [, ], #, \, ^, |, ~&lt;/code&gt;. To be able to use character encodings where some or all of these symbols do not exist (such as the German &lt;a href=&quot;https://de.wikipedia.org/wiki/DIN_66003&quot;&gt;DIN 66003&lt;/a&gt;), C++ defines the following alternatives composed of ISO 646 compatible characters.</source>
          <target state="translated">Исходный код C ++ (и C) может быть написан с использованием любого 7-битного набора символов, отличного от ASCII, который включает инвариантный набор символов &lt;a href=&quot;https://en.wikipedia.org/wiki/ISO_646&quot;&gt;ISO 646: 1983&lt;/a&gt; . Однако для некоторых операторов и знаков препинания C ++ требуются символы, не входящие в кодировку ISO 646: &lt;code&gt;{, }, [, ], #, \, ^, |, ~&lt;/code&gt; . Чтобы иметь возможность использовать кодировки символов, в которых некоторые или все эти символы не существуют (например, немецкий &lt;a href=&quot;https://de.wikipedia.org/wiki/DIN_66003&quot;&gt;DIN 66003&lt;/a&gt; ), C ++ определяет следующие альтернативы, состоящие из символов, совместимых с ISO 646.</target>
        </trans-unit>
        <trans-unit id="3c7d95b436ecd68b95eaa98a87bac58f93c37e6b" translate="yes" xml:space="preserve">
          <source>C++ Core Guidelines &lt;a href=&quot;https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#e14-use-purpose-designed-user-defined-types-as-exceptions-not-built-in-types&quot;&gt;E.14&lt;/a&gt;</source>
          <target state="translated">Основные положения C ++ &lt;a href=&quot;https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#e14-use-purpose-designed-user-defined-types-as-exceptions-not-built-in-types&quot;&gt;E.14&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="8cd612f2751329bbc16fee8f0091854df9f6031e" translate="yes" xml:space="preserve">
          <source>C++ Core Guidelines &lt;a href=&quot;https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#e15-catch-exceptions-from-a-hierarchy-by-reference&quot;&gt;E.15&lt;/a&gt;</source>
          <target state="translated">Основные положения C ++ &lt;a href=&quot;https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#e15-catch-exceptions-from-a-hierarchy-by-reference&quot;&gt;E.15&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="98881b02a247b26f94eb74fc06a45d722e646dd5" translate="yes" xml:space="preserve">
          <source>C++ Core Guidelines &lt;a href=&quot;https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#i10-use-exceptions-to-signal-a-failure-to-perform-a-required-task&quot;&gt;I.10&lt;/a&gt;</source>
          <target state="translated">Основные положения C ++ &lt;a href=&quot;https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#i10-use-exceptions-to-signal-a-failure-to-perform-a-required-task&quot;&gt;I.10&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c8be3e815f49596e499ad72b4130d9ecd2f1b149" translate="yes" xml:space="preserve">
          <source>C++ Core Guidelines E.6 &quot;Use RAII to prevent leaks&quot;</source>
          <target state="translated">C++Core Guidelines E.6 &quot;Использовать RAII для предотвращения утечек&quot;.</target>
        </trans-unit>
        <trans-unit id="147230a86e1c7e0bef8e1878444e4fbcc383fa96" translate="yes" xml:space="preserve">
          <source>C++ Operator Precedence</source>
          <target state="translated">Приоритет оператора C++</target>
        </trans-unit>
        <trans-unit id="c31eca9ef3dcd7526b7195249185a9729b743830" translate="yes" xml:space="preserve">
          <source>C++ Programming Language</source>
          <target state="translated">Язык программирования C++</target>
        </trans-unit>
        <trans-unit id="e7e7bcbec1050d7f0d883fbb8bc2748f84236f39" translate="yes" xml:space="preserve">
          <source>C++ also includes the &lt;a href=&quot;io/c&quot;&gt; input/output functions defined by C&lt;/a&gt;, such as &lt;code&gt;&lt;a href=&quot;io/c/fopen&quot;&gt;std::fopen&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;io/c/fgetc&quot;&gt;std::getc&lt;/a&gt;&lt;/code&gt;, etc.</source>
          <target state="translated">C ++ также включает функции &lt;a href=&quot;io/c&quot;&gt;ввода / вывода, определенные C&lt;/a&gt; , такие как &lt;code&gt;&lt;a href=&quot;io/c/fopen&quot;&gt;std::fopen&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;io/c/fgetc&quot;&gt;std::getc&lt;/a&gt;&lt;/code&gt; и т. Д.</target>
        </trans-unit>
        <trans-unit id="06557fdbe17d2e091891cc63144b53692b2f4c27" translate="yes" xml:space="preserve">
          <source>C++ attribute: carries_dependency (since C++11)</source>
          <target state="translated">C++атрибут:carries_dependency (начиная с C++11)</target>
        </trans-unit>
        <trans-unit id="3a80c78aa3d0be4365d4a4aace53df1894fafefe" translate="yes" xml:space="preserve">
          <source>C++ attribute: deprecated (since C++14)</source>
          <target state="translated">C++атрибут:deprecated (начиная с C++14)</target>
        </trans-unit>
        <trans-unit id="ad4b4ad5889a95c53ae7ededcaefccd580e10788" translate="yes" xml:space="preserve">
          <source>C++ attribute: expects, ensures, assert (C++20)</source>
          <target state="translated">C++атрибут:ожидает,обеспечивает,утверждает (C++20)</target>
        </trans-unit>
        <trans-unit id="1f01e78c670736bcfbc7cbb131e20f9036aefa35" translate="yes" xml:space="preserve">
          <source>C++ attribute: fallthrough (since C++17)</source>
          <target state="translated">C++атрибут:падение (начиная с C++17)</target>
        </trans-unit>
        <trans-unit id="a55af33c93fad900d8f3c516df19e406f43533ff" translate="yes" xml:space="preserve">
          <source>C++ attribute: likely, unlikely (since C++20)</source>
          <target state="translated">С++атрибут:вероятный,маловероятный (с С++20)</target>
        </trans-unit>
        <trans-unit id="69ebed955bad0cdef08a090954f7632df7b64103" translate="yes" xml:space="preserve">
          <source>C++ attribute: maybe_unused (since C++17)</source>
          <target state="translated">C++атрибут:maybe_unused (начиная с C++17)</target>
        </trans-unit>
        <trans-unit id="127add9901453ff701417a6b814f3ecc1b88d1ac" translate="yes" xml:space="preserve">
          <source>C++ attribute: no_unique_address (since C++20)</source>
          <target state="translated">C++атрибут:no_unique_address (начиная с C++20)</target>
        </trans-unit>
        <trans-unit id="f9e91b3dd1ac40fbbb8928fd5021a1da6124dcb0" translate="yes" xml:space="preserve">
          <source>C++ attribute: nodiscard (since C++17)</source>
          <target state="translated">C++атрибут:nodiscard (начиная с C++17)</target>
        </trans-unit>
        <trans-unit id="1f8de489858717f3061b65d4e3dae9adad203d70" translate="yes" xml:space="preserve">
          <source>C++ attribute: noreturn (since C++11)</source>
          <target state="translated">C++атрибут:noreturn (начиная с C++11)</target>
        </trans-unit>
        <trans-unit id="387814363c5c1f906d9da1e85cb5bc67e4f38c05" translate="yes" xml:space="preserve">
          <source>C++ attribute: optimize_for_synchronized (TM TS)</source>
          <target state="translated">C++атрибут:optim_for_synchronized (TM TS)</target>
        </trans-unit>
        <trans-unit id="4583aeee6b4e07e7a7eb1f6b99f908d66bf96f40" translate="yes" xml:space="preserve">
          <source>C++ defines several function objects that represent common arithmetic and logical operations:</source>
          <target state="translated">C++определяет несколько объектов функций,которые представляют собой общие арифметические и логические операции:</target>
        </trans-unit>
        <trans-unit id="c67f57f6a26a137cf9bc71e8f9c5a5af0559e777" translate="yes" xml:space="preserve">
          <source>C++ includes a variety of utility libraries that provide functionality ranging from &lt;a href=&quot;utility/bitset&quot;&gt;bit-counting&lt;/a&gt; to &lt;a href=&quot;utility/functional/bind&quot;&gt;partial function application&lt;/a&gt;. These libraries can be broadly divided into two groups:</source>
          <target state="translated">C ++ включает в себя множество служебных библиотек, которые обеспечивают функциональность, начиная от &lt;a href=&quot;utility/bitset&quot;&gt;подсчета битов и&lt;/a&gt; заканчивая &lt;a href=&quot;utility/functional/bind&quot;&gt;частичным применением функций&lt;/a&gt; . Эти библиотеки можно разделить на две группы:</target>
        </trans-unit>
        <trans-unit id="76aad39fcff3282441a6d5280586f60940cc31a5" translate="yes" xml:space="preserve">
          <source>C++ includes built-in support for threads, mutual exclusion, condition variables, and futures.</source>
          <target state="translated">В C++встроена поддержка потоков,взаимного исключения,условных переменных и фьючерсов.</target>
        </trans-unit>
        <trans-unit id="3934f659aacbf1f001d3645344748b8c444cd791" translate="yes" xml:space="preserve">
          <source>C++ includes support for two types of time manipulation:</source>
          <target state="translated">C++включает поддержку двух типов манипуляций с временем:</target>
        </trans-unit>
        <trans-unit id="92a2c968a34da23e4708e71892c2ffb721fa839a" translate="yes" xml:space="preserve">
          <source>C++ includes the following types of statements:</source>
          <target state="translated">С++включает в себя следующие типы утверждений:</target>
        </trans-unit>
        <trans-unit id="49dd66f99c3d0ac54dc62b7ee7eb01eca487493b" translate="yes" xml:space="preserve">
          <source>C++ includes two input/output libraries: a modern, stream-based I/O library and the standard set of C-style I/O functions.</source>
          <target state="translated">C++включает в себя две библиотеки ввода/вывода:современную потоковую библиотеку ввода/вывода и стандартный набор функций ввода/вывода в стиле Си.</target>
        </trans-unit>
        <trans-unit id="e0e04efcb6a316f4e833950df1ac7962ec66959a" translate="yes" xml:space="preserve">
          <source>C++ keywords</source>
          <target state="translated">C++ключевые слова</target>
        </trans-unit>
        <trans-unit id="3aee0b831c4708d12c9406617e0cc1e8018f2d74" translate="yes" xml:space="preserve">
          <source>C++ keywords: alignas (since C++11)</source>
          <target state="translated">Ключевые слова на C++:alignas (начиная с C++11)</target>
        </trans-unit>
        <trans-unit id="29507b9a59ffc6150615d0d338bd1beb939dfad0" translate="yes" xml:space="preserve">
          <source>C++ keywords: alignof (since C++11)</source>
          <target state="translated">Ключевые слова C++:alignof (начиная с C++11)</target>
        </trans-unit>
        <trans-unit id="183b1dcdba07c3b1be4b49fab102e89c9a7de240" translate="yes" xml:space="preserve">
          <source>C++ keywords: and</source>
          <target state="translated">C++ключевые слова:и</target>
        </trans-unit>
        <trans-unit id="3a6e38d19cc3dc2909a3faa576f245fdf6217690" translate="yes" xml:space="preserve">
          <source>C++ keywords: and_eq</source>
          <target state="translated">C++ключевые слова:и_eq</target>
        </trans-unit>
        <trans-unit id="124a64afaa6c8c5bfca6047dd460511a6b97db33" translate="yes" xml:space="preserve">
          <source>C++ keywords: asm</source>
          <target state="translated">C++ключевые слова:asm</target>
        </trans-unit>
        <trans-unit id="a0612d43a8ba92fee978df18206be3adce6458fa" translate="yes" xml:space="preserve">
          <source>C++ keywords: audit (since C++20)</source>
          <target state="translated">Ключевые слова на C++:аудит (начиная с C++20)</target>
        </trans-unit>
        <trans-unit id="b2ccdccd648a0f0a224169f56af64c5a94ea2b07" translate="yes" xml:space="preserve">
          <source>C++ keywords: auto</source>
          <target state="translated">C++ключевые слова:auto</target>
        </trans-unit>
        <trans-unit id="526ec64f9498eb1229f0b99304e24893a3786743" translate="yes" xml:space="preserve">
          <source>C++ keywords: axiom (since C++20)</source>
          <target state="translated">Ключевые слова на C++:аксиома (начиная с C++20)</target>
        </trans-unit>
        <trans-unit id="163810b967745c12225f305e7e817d651df13205" translate="yes" xml:space="preserve">
          <source>C++ keywords: bitand</source>
          <target state="translated">C++ключевые слова:бит и</target>
        </trans-unit>
        <trans-unit id="05bce8999813ae5f7d868f68ce64fcade539f423" translate="yes" xml:space="preserve">
          <source>C++ keywords: bitor</source>
          <target state="translated">C++ключевые слова:bitor</target>
        </trans-unit>
        <trans-unit id="ba78f8f4b5950d9d7ebfc170c7afd751c59bdc1f" translate="yes" xml:space="preserve">
          <source>C++ keywords: bool</source>
          <target state="translated">C++ключевые слова:bool</target>
        </trans-unit>
        <trans-unit id="d69d38c5fa6d513f4ee223cae0f80ada3cf1eb0b" translate="yes" xml:space="preserve">
          <source>C++ keywords: break</source>
          <target state="translated">C++ключевые слова:перерыв</target>
        </trans-unit>
        <trans-unit id="1b869375d71945d8fecb773bf590ce8095cc4588" translate="yes" xml:space="preserve">
          <source>C++ keywords: case</source>
          <target state="translated">C++ключевые слова:регистр</target>
        </trans-unit>
        <trans-unit id="a7c81faed45b85c8dcd86de0734ee278e34df717" translate="yes" xml:space="preserve">
          <source>C++ keywords: catch</source>
          <target state="translated">C++ключевые слова:поймать</target>
        </trans-unit>
        <trans-unit id="fb289f167e01192a7926393875a6c8672f6c6f9e" translate="yes" xml:space="preserve">
          <source>C++ keywords: char</source>
          <target state="translated">C++ключевые слова:char</target>
        </trans-unit>
        <trans-unit id="eacf79f3f8a785c01bc0ce19bb78a42fbe110d2b" translate="yes" xml:space="preserve">
          <source>C++ keywords: char16_t (since C++11)</source>
          <target state="translated">Ключевые слова на C++:char16_t (начиная с C++11)</target>
        </trans-unit>
        <trans-unit id="d42a327c13fbb384479588185d9a50190dde3cf8" translate="yes" xml:space="preserve">
          <source>C++ keywords: char32_t (since C++11)</source>
          <target state="translated">Ключевые слова на C++:char32_t (начиная с C++11)</target>
        </trans-unit>
        <trans-unit id="e2545bdc74a2da147dd1af1123e6aa8edbc09e87" translate="yes" xml:space="preserve">
          <source>C++ keywords: char8_t (since C++20)</source>
          <target state="translated">Ключевые слова на C++:char8_t (начиная с C++20)</target>
        </trans-unit>
        <trans-unit id="c2ebb8c0d088a0587ab8ccaeece91bd9e176a491" translate="yes" xml:space="preserve">
          <source>C++ keywords: class</source>
          <target state="translated">C++ключевые слова:класс</target>
        </trans-unit>
        <trans-unit id="29b898e1bb17af4eedf763c0844dd1fbb1bdd22d" translate="yes" xml:space="preserve">
          <source>C++ keywords: co_await</source>
          <target state="translated">C++ключевые слова:co_await</target>
        </trans-unit>
        <trans-unit id="16a636816ed7f754d904e9002adf34e537a3bbfa" translate="yes" xml:space="preserve">
          <source>C++ keywords: co_return</source>
          <target state="translated">C++ключевые слова:co_return</target>
        </trans-unit>
        <trans-unit id="33bc95e36c6779fdbd2d85867f4c0f747ae853fe" translate="yes" xml:space="preserve">
          <source>C++ keywords: co_yield</source>
          <target state="translated">C++ключевые слова:co_yield</target>
        </trans-unit>
        <trans-unit id="01848e98ae4887d344100accfb0dc0f687fda24d" translate="yes" xml:space="preserve">
          <source>C++ keywords: compl</source>
          <target state="translated">C++ключевые слова:compl</target>
        </trans-unit>
        <trans-unit id="6f9e6b0ca42a7a44125068643d4aeacd6ed22adc" translate="yes" xml:space="preserve">
          <source>C++ keywords: concept</source>
          <target state="translated">C++ключевые слова:понятие</target>
        </trans-unit>
        <trans-unit id="26d8438420078942bafe0fcabb0f3a9ff8f21c57" translate="yes" xml:space="preserve">
          <source>C++ keywords: const</source>
          <target state="translated">C++ключевые слова:const</target>
        </trans-unit>
        <trans-unit id="69601052b6f31cbc68f401b4565ce386a65a23c2" translate="yes" xml:space="preserve">
          <source>C++ keywords: const_cast</source>
          <target state="translated">C++ключевые слова:const_cast</target>
        </trans-unit>
        <trans-unit id="bf6dfea8cb8956898c49e4b94e6e3b12224c1209" translate="yes" xml:space="preserve">
          <source>C++ keywords: consteval</source>
          <target state="translated">C++ключевые слова:consteval</target>
        </trans-unit>
        <trans-unit id="527aef1fbeeb02aed3a5fdbfc85d582ce0f515aa" translate="yes" xml:space="preserve">
          <source>C++ keywords: constexpr (since C++11)</source>
          <target state="translated">Ключевые слова на C++:constexpr (начиная с C++11)</target>
        </trans-unit>
        <trans-unit id="395fd0f15c5d8fac44a7288a59ea5a86379a156b" translate="yes" xml:space="preserve">
          <source>C++ keywords: continue</source>
          <target state="translated">Ключевые слова на C++:продолжить</target>
        </trans-unit>
        <trans-unit id="36bf9192492d110977874a62802f3f0cbf1c7005" translate="yes" xml:space="preserve">
          <source>C++ keywords: decltype</source>
          <target state="translated">C++ключевые слова:decltype</target>
        </trans-unit>
        <trans-unit id="f30dc791d0616219ea0defdde70ed1cfef4ff5c8" translate="yes" xml:space="preserve">
          <source>C++ keywords: default</source>
          <target state="translated">C++ключевые слова:по умолчанию</target>
        </trans-unit>
        <trans-unit id="94d1f98ddc77ffbdfd69b93ceca8b8d435110d3c" translate="yes" xml:space="preserve">
          <source>C++ keywords: delete</source>
          <target state="translated">C++ключевые слова:удалить</target>
        </trans-unit>
        <trans-unit id="2fec1767b7b69a4a327e04a5a4c3a4f27379bdd2" translate="yes" xml:space="preserve">
          <source>C++ keywords: do</source>
          <target state="translated">C++ключевые слова:сделать</target>
        </trans-unit>
        <trans-unit id="7bafac1a9bd6cde00b59ed3cdcbd753151e0a51a" translate="yes" xml:space="preserve">
          <source>C++ keywords: double</source>
          <target state="translated">C++ключевые слова:двойной</target>
        </trans-unit>
        <trans-unit id="0b4a595b8bfbe949f6ca15f733e9e13331a42383" translate="yes" xml:space="preserve">
          <source>C++ keywords: dynamic_cast</source>
          <target state="translated">Ключевые слова на C++:dynamic_cast</target>
        </trans-unit>
        <trans-unit id="b32114b3f766f8a6739a7358915b26ea1b71457a" translate="yes" xml:space="preserve">
          <source>C++ keywords: else</source>
          <target state="translated">C++ключевые слова:иначе</target>
        </trans-unit>
        <trans-unit id="9917c70089a8094b6d2fbb8e852e373f906a704b" translate="yes" xml:space="preserve">
          <source>C++ keywords: enum</source>
          <target state="translated">C++ключевые слова:enum</target>
        </trans-unit>
        <trans-unit id="d544a09b352faa3a994cc54ccff972a5a3cb000b" translate="yes" xml:space="preserve">
          <source>C++ keywords: explicit</source>
          <target state="translated">Ключевые слова на C++:явный</target>
        </trans-unit>
        <trans-unit id="3c3210a8eec85af05733531fd5df52b05cdd6aa9" translate="yes" xml:space="preserve">
          <source>C++ keywords: export</source>
          <target state="translated">C++ключевые слова:экспорт</target>
        </trans-unit>
        <trans-unit id="de55ab46e46dffbf77fad964ecd27e3f0d9ef421" translate="yes" xml:space="preserve">
          <source>C++ keywords: extern</source>
          <target state="translated">C++ключевые слова:extern</target>
        </trans-unit>
        <trans-unit id="e57865b70fcda2180074588769785ddc1a36b1c4" translate="yes" xml:space="preserve">
          <source>C++ keywords: false</source>
          <target state="translated">C++ключевые слова:false</target>
        </trans-unit>
        <trans-unit id="a700071e23581008cd76b45c2c69fea512ecb640" translate="yes" xml:space="preserve">
          <source>C++ keywords: final (since C++11)</source>
          <target state="translated">Ключевые слова на C++:окончательное (начиная с C++11)</target>
        </trans-unit>
        <trans-unit id="d02f9afd3fb00647e6a8e3424d891ceecd47fa78" translate="yes" xml:space="preserve">
          <source>C++ keywords: float</source>
          <target state="translated">C++ключевые слова:float</target>
        </trans-unit>
        <trans-unit id="a5cd84453036526e60fa4e42dda9e069ff310fd3" translate="yes" xml:space="preserve">
          <source>C++ keywords: for</source>
          <target state="translated">C++ключевые слова:для</target>
        </trans-unit>
        <trans-unit id="48f95d56f056fed8728e03635e48afcd5b420407" translate="yes" xml:space="preserve">
          <source>C++ keywords: friend</source>
          <target state="translated">C++ключевые слова:друг</target>
        </trans-unit>
        <trans-unit id="1e68fa94e046f072a7ff1b219e912a351a979625" translate="yes" xml:space="preserve">
          <source>C++ keywords: goto</source>
          <target state="translated">C++ключевые слова:goto</target>
        </trans-unit>
        <trans-unit id="4725b0f2dcc6d3119ce93a5f3e3d49658b9f6ae7" translate="yes" xml:space="preserve">
          <source>C++ keywords: if</source>
          <target state="translated">C++ключевые слова:если</target>
        </trans-unit>
        <trans-unit id="e499739fb3e6977144ad9e1eeb2e5bc4a8ddc540" translate="yes" xml:space="preserve">
          <source>C++ keywords: inline</source>
          <target state="translated">C++ключевые слова:inline</target>
        </trans-unit>
        <trans-unit id="b3fd1b872d293865c0aefeed8e6183dd1c548684" translate="yes" xml:space="preserve">
          <source>C++ keywords: int</source>
          <target state="translated">C++ключевые слова:int</target>
        </trans-unit>
        <trans-unit id="c27210515d0813a21164dfce05ea3be2f9ae3b66" translate="yes" xml:space="preserve">
          <source>C++ keywords: long</source>
          <target state="translated">C++ключевые слова:длинный</target>
        </trans-unit>
        <trans-unit id="4d43f4cb276936dd386b3bd9758fc75c328cc95f" translate="yes" xml:space="preserve">
          <source>C++ keywords: mutable</source>
          <target state="translated">C++ключевые слова:mutable</target>
        </trans-unit>
        <trans-unit id="b02800bd96f0d61d78a098b7b68899cdbbd6afe6" translate="yes" xml:space="preserve">
          <source>C++ keywords: namespace</source>
          <target state="translated">C++ключевые слова:пространство имён</target>
        </trans-unit>
        <trans-unit id="4f9a52b4836fa43713e1e3fa4d56214068cc8def" translate="yes" xml:space="preserve">
          <source>C++ keywords: new</source>
          <target state="translated">C++ключевые слова:новый</target>
        </trans-unit>
        <trans-unit id="9c0ca031ba0d25429ecf94970709e58032f30ab8" translate="yes" xml:space="preserve">
          <source>C++ keywords: noexcept (since C++11)</source>
          <target state="translated">Ключевые слова на языке С++:не исключение (начиная с C++11)</target>
        </trans-unit>
        <trans-unit id="c89b31c825167c40b35e37235a165123fdf5b4e4" translate="yes" xml:space="preserve">
          <source>C++ keywords: not</source>
          <target state="translated">C++ключевые слова:нет</target>
        </trans-unit>
        <trans-unit id="3cc0c7490348f3b3ba14089762bd72de7bd639ce" translate="yes" xml:space="preserve">
          <source>C++ keywords: not_eq</source>
          <target state="translated">C++ключевые слова:not_eq</target>
        </trans-unit>
        <trans-unit id="b19ba534185a30e68c38be176f0412bc1f2bc6b5" translate="yes" xml:space="preserve">
          <source>C++ keywords: nullptr (since C++11)</source>
          <target state="translated">Ключевые слова на C++:nullptr (начиная с C++11)</target>
        </trans-unit>
        <trans-unit id="70814bfe02a7af8b95ce36bc95a7da1123095a6a" translate="yes" xml:space="preserve">
          <source>C++ keywords: operator</source>
          <target state="translated">C++ключевые слова:оператор</target>
        </trans-unit>
        <trans-unit id="c23df376605d78f63a5500160b48ee512157ad7c" translate="yes" xml:space="preserve">
          <source>C++ keywords: or</source>
          <target state="translated">C++ключевые слова:или</target>
        </trans-unit>
        <trans-unit id="d20cac1ee4d77d9ffa9e5793ad0383aa3ad51475" translate="yes" xml:space="preserve">
          <source>C++ keywords: or_eq</source>
          <target state="translated">C++ключевые слова:или_eq</target>
        </trans-unit>
        <trans-unit id="8a0293371d55246ce973ae3e75626127f1504b6a" translate="yes" xml:space="preserve">
          <source>C++ keywords: override (since C++11)</source>
          <target state="translated">Ключевые слова C++:переопределение (начиная с C++11)</target>
        </trans-unit>
        <trans-unit id="03786ae3b9f628796529d09b809dbfc8b46793fe" translate="yes" xml:space="preserve">
          <source>C++ keywords: private</source>
          <target state="translated">C++ключевые слова:приватный</target>
        </trans-unit>
        <trans-unit id="df7d4ea5bc32cb787a6f750294cd5227c2fcd0d1" translate="yes" xml:space="preserve">
          <source>C++ keywords: protected</source>
          <target state="translated">C++ключевые слова:защищённый</target>
        </trans-unit>
        <trans-unit id="bfab844551173e61ef5a9ab220a29b66c69734b6" translate="yes" xml:space="preserve">
          <source>C++ keywords: public</source>
          <target state="translated">C++ключевые слова:public</target>
        </trans-unit>
        <trans-unit id="1f1f72ef9a8c96008d1a90280fd58c243aa19f0b" translate="yes" xml:space="preserve">
          <source>C++ keywords: register</source>
          <target state="translated">C++ключевые слова:регистр</target>
        </trans-unit>
        <trans-unit id="cd98a0128d90a9233e207ec1405b9a7e57585055" translate="yes" xml:space="preserve">
          <source>C++ keywords: reinterpret_cast</source>
          <target state="translated">C++ключевые слова:reinterpret_cast</target>
        </trans-unit>
        <trans-unit id="e57ca4acf8809388dce3238247eb7aa0f55ae138" translate="yes" xml:space="preserve">
          <source>C++ keywords: requires</source>
          <target state="translated">Ключевые слова на C++:требуется</target>
        </trans-unit>
        <trans-unit id="1abcca2b0e66ee60c977a4e5782dd98d5b4d457d" translate="yes" xml:space="preserve">
          <source>C++ keywords: return</source>
          <target state="translated">C++ключевые слова:вернуться</target>
        </trans-unit>
        <trans-unit id="4b1adaad1115bcff0759ad4794ff292ed78b3c23" translate="yes" xml:space="preserve">
          <source>C++ keywords: short</source>
          <target state="translated">C++ключевые слова:короткий</target>
        </trans-unit>
        <trans-unit id="7bd3bfdfb2f3297c5564232cb8f3314290cdc7cf" translate="yes" xml:space="preserve">
          <source>C++ keywords: signed</source>
          <target state="translated">C++ключевые слова:подписано</target>
        </trans-unit>
        <trans-unit id="4ff280c7a565563348f26be8d65133c336d662d3" translate="yes" xml:space="preserve">
          <source>C++ keywords: sizeof</source>
          <target state="translated">C++ключевые слова:sizeof</target>
        </trans-unit>
        <trans-unit id="1a6d44df359c5334d919f430e3f3a4ac0d088d64" translate="yes" xml:space="preserve">
          <source>C++ keywords: static</source>
          <target state="translated">C++ключевые слова:статический</target>
        </trans-unit>
        <trans-unit id="94bea4546792cb644fbf90e8a6f9c16d09f62ef3" translate="yes" xml:space="preserve">
          <source>C++ keywords: static_assert (since C++11)</source>
          <target state="translated">Ключевые слова на C++:static_assert (начиная с C++11)</target>
        </trans-unit>
        <trans-unit id="72096556dc877cb5f85ffd02a8ca80027a3dd3aa" translate="yes" xml:space="preserve">
          <source>C++ keywords: static_cast</source>
          <target state="translated">C++ключевые слова:static_cast</target>
        </trans-unit>
        <trans-unit id="b2fb75279739ad8e2dec4f932c10feab705444ec" translate="yes" xml:space="preserve">
          <source>C++ keywords: struct</source>
          <target state="translated">C++ключевые слова:struct</target>
        </trans-unit>
        <trans-unit id="1d55fcffd470c877223faca7c22ebb0001352b9e" translate="yes" xml:space="preserve">
          <source>C++ keywords: switch</source>
          <target state="translated">C++ключевые слова:switch</target>
        </trans-unit>
        <trans-unit id="8a86cf3a93c4b52678e6d0617edc0697e04f2ca0" translate="yes" xml:space="preserve">
          <source>C++ keywords: template</source>
          <target state="translated">C++ключевые слова:шаблон</target>
        </trans-unit>
        <trans-unit id="917e6e9b4ef5b0862e8ac7fdc4490ad8424f619e" translate="yes" xml:space="preserve">
          <source>C++ keywords: this</source>
          <target state="translated">C++ключевые слова:это</target>
        </trans-unit>
        <trans-unit id="7be930465dc63b127e9244e46b51e76cf2df9d25" translate="yes" xml:space="preserve">
          <source>C++ keywords: thread_local (since C++11)</source>
          <target state="translated">Ключевые слова на C++:thread_local (начиная с C++11)</target>
        </trans-unit>
        <trans-unit id="b6e56566966d5710214d6f3ea6c95ab6c44200df" translate="yes" xml:space="preserve">
          <source>C++ keywords: throw</source>
          <target state="translated">C++ключевые слова:бросить</target>
        </trans-unit>
        <trans-unit id="0044cc96e436f4b21ecd72cd8dfbd5e16f91d829" translate="yes" xml:space="preserve">
          <source>C++ keywords: true</source>
          <target state="translated">C++ключевые слова:true</target>
        </trans-unit>
        <trans-unit id="98ac0c70a9cb341c8cd03989ea0fb7d75b0bb05a" translate="yes" xml:space="preserve">
          <source>C++ keywords: try</source>
          <target state="translated">C++ключевые слова:попробуйте</target>
        </trans-unit>
        <trans-unit id="ef86b57182f4ee052964937a9ab5e68c63c4ce5f" translate="yes" xml:space="preserve">
          <source>C++ keywords: typedef</source>
          <target state="translated">C++ключевые слова:typedef</target>
        </trans-unit>
        <trans-unit id="454d53b90b0b8d7c3a3e8ad398ac791969143134" translate="yes" xml:space="preserve">
          <source>C++ keywords: typeid</source>
          <target state="translated">C++ключевые слова:typeid</target>
        </trans-unit>
        <trans-unit id="f09f8d522055844ed39f38a10e8d3068231112c5" translate="yes" xml:space="preserve">
          <source>C++ keywords: typename</source>
          <target state="translated">C++ключевые слова:имя типа</target>
        </trans-unit>
        <trans-unit id="e9cfe8a8699032565be2259c78cf9cf21c03061f" translate="yes" xml:space="preserve">
          <source>C++ keywords: union</source>
          <target state="translated">C++ключевые слова:объединение</target>
        </trans-unit>
        <trans-unit id="3a2039a0d25e07bab54ea79e32cbb688dd58e12e" translate="yes" xml:space="preserve">
          <source>C++ keywords: unsigned</source>
          <target state="translated">C++ключевые слова:неподписанный</target>
        </trans-unit>
        <trans-unit id="8471d9f4d77d2e5eb14371c1da076716f02eaa32" translate="yes" xml:space="preserve">
          <source>C++ keywords: using</source>
          <target state="translated">C++ключевые слова:использование</target>
        </trans-unit>
        <trans-unit id="ca2d0f00321b8103f435fd2b14b1924abd2dfb05" translate="yes" xml:space="preserve">
          <source>C++ keywords: virtual</source>
          <target state="translated">C++ключевые слова:виртуальный</target>
        </trans-unit>
        <trans-unit id="624f83b1ecef18ff894e0bb447112f9f3014800a" translate="yes" xml:space="preserve">
          <source>C++ keywords: void</source>
          <target state="translated">C++ключевые слова:void</target>
        </trans-unit>
        <trans-unit id="f78e5cc4134b90e370b281fe8d44693b1ec58e36" translate="yes" xml:space="preserve">
          <source>C++ keywords: volatile</source>
          <target state="translated">C++ключевые слова:volatile</target>
        </trans-unit>
        <trans-unit id="9c61c84d1b44e56098d4c56e5048e58138e3fbc7" translate="yes" xml:space="preserve">
          <source>C++ keywords: wchar_t</source>
          <target state="translated">C++ключевые слова:wchar_t</target>
        </trans-unit>
        <trans-unit id="2c909f57896904cc34b1cc4e253dd5d79ed3ab7b" translate="yes" xml:space="preserve">
          <source>C++ keywords: while</source>
          <target state="translated">C++ключевые слова:в то время как</target>
        </trans-unit>
        <trans-unit id="7b74b5079b0e1bc6b6d3a9df3f3dcaf748b4fdf4" translate="yes" xml:space="preserve">
          <source>C++ keywords: xor</source>
          <target state="translated">C++ключевые слова:xor</target>
        </trans-unit>
        <trans-unit id="eb3705de2bf421a4730d1843c818dc31e4324286" translate="yes" xml:space="preserve">
          <source>C++ keywords: xor_eq</source>
          <target state="translated">C++ключевые слова:xor_eq</target>
        </trans-unit>
        <trans-unit id="00d4296327feae05e7f754006f1f81e7b3df74e7" translate="yes" xml:space="preserve">
          <source>C++ language</source>
          <target state="translated">язык C++</target>
        </trans-unit>
        <trans-unit id="5c6e1f137cae8deef2fe086c3a40c23cb3abd95c" translate="yes" xml:space="preserve">
          <source>C++ named requirements: Allocator</source>
          <target state="translated">C++названные требования:Распределитель</target>
        </trans-unit>
        <trans-unit id="68093762465efd54450ba8bcd9c0a91c4dbf0f1b" translate="yes" xml:space="preserve">
          <source>C++ named requirements: AllocatorAwareContainer</source>
          <target state="translated">C++названные требования:AllocatorAwareContainer .</target>
        </trans-unit>
        <trans-unit id="ab7ac32bec349da4c19ab2096d1b1255564f39b0" translate="yes" xml:space="preserve">
          <source>C++ named requirements: AssociativeContainer</source>
          <target state="translated">C++названные требования:AssociativeContainer</target>
        </trans-unit>
        <trans-unit id="bce38a21c7a5a1ec76fbe77837afdf562ff1649d" translate="yes" xml:space="preserve">
          <source>C++ named requirements: BasicLockable</source>
          <target state="translated">C++названные требования:BasicLockable</target>
        </trans-unit>
        <trans-unit id="e1a9abc4c52e314d687b58fdfa28003600137949" translate="yes" xml:space="preserve">
          <source>C++ named requirements: BinaryPredicate</source>
          <target state="translated">C++названные требования:BinaryPredicate</target>
        </trans-unit>
        <trans-unit id="77f706b668a619259c5204b16d231a4b5f303147" translate="yes" xml:space="preserve">
          <source>C++ named requirements: BinaryTypeTrait</source>
          <target state="translated">C++названные требования:BinaryTypeTrait</target>
        </trans-unit>
        <trans-unit id="2dac169f409edf4d6004eeef2aa80e3ce234acba" translate="yes" xml:space="preserve">
          <source>C++ named requirements: BitmaskType</source>
          <target state="translated">C++названные требования:BitmaskType</target>
        </trans-unit>
        <trans-unit id="3ac90618765ee9c85f861c53f0604fe5b1bece8f" translate="yes" xml:space="preserve">
          <source>C++ named requirements: Callable</source>
          <target state="translated">C++названные требования:Звонок на</target>
        </trans-unit>
        <trans-unit id="ee45309ee631f97e8c54fdd32dd4c7314a219410" translate="yes" xml:space="preserve">
          <source>C++ named requirements: CharTraits</source>
          <target state="translated">C++названные требования:CharTraits</target>
        </trans-unit>
        <trans-unit id="e49e0b2de04ceaac02567e3c466ce7f34aa9139b" translate="yes" xml:space="preserve">
          <source>C++ named requirements: Clock</source>
          <target state="translated">C++названные требования:Часы</target>
        </trans-unit>
        <trans-unit id="03d4cd85a40261a51658ef8d686e3877be8fb96e" translate="yes" xml:space="preserve">
          <source>C++ named requirements: Compare</source>
          <target state="translated">C++названные требования:Сравнить</target>
        </trans-unit>
        <trans-unit id="ac0da8de55de872e9c67b652831ec7e483b09c3b" translate="yes" xml:space="preserve">
          <source>C++ named requirements: ConstexprIterator</source>
          <target state="translated">C++названные требования:КонстеxprIterator</target>
        </trans-unit>
        <trans-unit id="d0267fe31b3826841ff7251625998f2fcb06717e" translate="yes" xml:space="preserve">
          <source>C++ named requirements: Container</source>
          <target state="translated">C++названные требования:Контейнер</target>
        </trans-unit>
        <trans-unit id="cf843c7d6d3dc3a137cc532583586f04e6c312a3" translate="yes" xml:space="preserve">
          <source>C++ named requirements: ContiguousContainer</source>
          <target state="translated">C++названные требования:Контейнер ContiguousContainer .</target>
        </trans-unit>
        <trans-unit id="8f039fec7eb71a74ef921bce40ef720e3e7301f7" translate="yes" xml:space="preserve">
          <source>C++ named requirements: CopyAssignable</source>
          <target state="translated">C++названные требования:CopyAssignable</target>
        </trans-unit>
        <trans-unit id="a5a5a4d38564c8be046908e5b71fa8fc1c5617c2" translate="yes" xml:space="preserve">
          <source>C++ named requirements: CopyConstructible</source>
          <target state="translated">C++названные требования:CopyConstructible</target>
        </trans-unit>
        <trans-unit id="8a6121d6fc5b64e9265c4080e5c5342c8e2ea499" translate="yes" xml:space="preserve">
          <source>C++ named requirements: CopyInsertable</source>
          <target state="translated">C++названные требования:CopyInsertable</target>
        </trans-unit>
        <trans-unit id="e0410f086a810b23ccfa34f4b0166c8fba23f310" translate="yes" xml:space="preserve">
          <source>C++ named requirements: DefaultConstructible</source>
          <target state="translated">C++названные требования:DefaultConstructible</target>
        </trans-unit>
        <trans-unit id="a0e9c4ff46f14ebb3f87a8006d8b76bdc0d3803b" translate="yes" xml:space="preserve">
          <source>C++ named requirements: DefaultInsertable</source>
          <target state="translated">C++названные требования:DefaultInsertable</target>
        </trans-unit>
        <trans-unit id="5f0c828f8de0769b3ee1f87f72ae6283f03e4208" translate="yes" xml:space="preserve">
          <source>C++ named requirements: Destructible</source>
          <target state="translated">C++названные требования:Разрушимый</target>
        </trans-unit>
        <trans-unit id="a3846bfd4ceb5970ead3569546441faa22d6f618" translate="yes" xml:space="preserve">
          <source>C++ named requirements: EmplaceConstructible (since C++11)</source>
          <target state="translated">C++названные требования:EmplaceConstructible (начиная с C++11)</target>
        </trans-unit>
        <trans-unit id="0f00c016cd8d60c879ed8f11a065a6cdb2245c1a" translate="yes" xml:space="preserve">
          <source>C++ named requirements: EqualityComparable</source>
          <target state="translated">C++названные требования:EqualityComparable</target>
        </trans-unit>
        <trans-unit id="a4bdf57055cd7c0dae92592574976fad30e86740" translate="yes" xml:space="preserve">
          <source>C++ named requirements: Erasable</source>
          <target state="translated">C++названные требования:Стираемый</target>
        </trans-unit>
        <trans-unit id="c9dce4c90e1ab07bd8e4f26bfd59c7bb93d2c13b" translate="yes" xml:space="preserve">
          <source>C++ named requirements: FormattedInputFunction</source>
          <target state="translated">C++названные требования:ФорматированныйInputFunction .</target>
        </trans-unit>
        <trans-unit id="78390db68319248607d73e238aa034d36af5547e" translate="yes" xml:space="preserve">
          <source>C++ named requirements: FormattedOutputFunction</source>
          <target state="translated">C++названные требования:FormattedOutputFunction .</target>
        </trans-unit>
        <trans-unit id="17341909637487f66a0a51420af28ebc0ff53f17" translate="yes" xml:space="preserve">
          <source>C++ named requirements: FunctionObject</source>
          <target state="translated">C++названные требования:FunctionObject</target>
        </trans-unit>
        <trans-unit id="83eafac0e33fd85d404291ef083b29a6c21e4bd5" translate="yes" xml:space="preserve">
          <source>C++ named requirements: Hash</source>
          <target state="translated">C++названные требования:Хаш</target>
        </trans-unit>
        <trans-unit id="b7114351c4bbaa9528560ef257598f798ddb3de5" translate="yes" xml:space="preserve">
          <source>C++ named requirements: LegacyBidirectionalIterator</source>
          <target state="translated">C++названные требования:LegacyBidirectionalIterator</target>
        </trans-unit>
        <trans-unit id="333591b546d46f2b2872fef1e1d696156e3d4da4" translate="yes" xml:space="preserve">
          <source>C++ named requirements: LegacyContiguousIterator</source>
          <target state="translated">C++названные требования:LegacyContiguousIterator</target>
        </trans-unit>
        <trans-unit id="49fdc557343b56a30b7a499efbbea9f6e8d5ea27" translate="yes" xml:space="preserve">
          <source>C++ named requirements: LegacyForwardIterator</source>
          <target state="translated">C++названные требования:LegacyForwardIterator</target>
        </trans-unit>
        <trans-unit id="b0ca593d796d2c1f1cdfea5aaaa5bcc718fed510" translate="yes" xml:space="preserve">
          <source>C++ named requirements: LegacyInputIterator</source>
          <target state="translated">C++названные требования:LegacyInputIterator</target>
        </trans-unit>
        <trans-unit id="daac43c9c4fb82513fe27e3efbdb288f38305a58" translate="yes" xml:space="preserve">
          <source>C++ named requirements: LegacyIterator</source>
          <target state="translated">C++названные требования:LegacyIterator</target>
        </trans-unit>
        <trans-unit id="491d2d06bd47da0deeddf998db8a57451119a47e" translate="yes" xml:space="preserve">
          <source>C++ named requirements: LegacyOutputIterator</source>
          <target state="translated">C++названные требования:LegacyOutputIterator</target>
        </trans-unit>
        <trans-unit id="2bae53a7d3573b63c5126a51eeda215a90f01f27" translate="yes" xml:space="preserve">
          <source>C++ named requirements: LegacyRandomAccessIterator</source>
          <target state="translated">C++названные требования:LegacyRandomAccessIterator</target>
        </trans-unit>
        <trans-unit id="234fc9eae136300c3a84df869801ddac1bc39e85" translate="yes" xml:space="preserve">
          <source>C++ named requirements: LessThanComparable</source>
          <target state="translated">C++названные требования:LessThanComparable</target>
        </trans-unit>
        <trans-unit id="fa488eac6c38cb8817603703df4bd4bc17b5bc3c" translate="yes" xml:space="preserve">
          <source>C++ named requirements: LiteralType</source>
          <target state="translated">C++названные требования:LiteralType</target>
        </trans-unit>
        <trans-unit id="7e27d143c2848bfc04da8fa00c12fc56eba98a8f" translate="yes" xml:space="preserve">
          <source>C++ named requirements: Lockable</source>
          <target state="translated">C++названные требования:Запираемый</target>
        </trans-unit>
        <trans-unit id="ffa229dee12fb9a9290b1083466a57ea9ef88cb2" translate="yes" xml:space="preserve">
          <source>C++ named requirements: MoveAssignable (since C++11)</source>
          <target state="translated">C++названные требования:MoveAssignable (начиная с C++11)</target>
        </trans-unit>
        <trans-unit id="3c7af72e00db75b25a6339c6bc85b14f40833ea5" translate="yes" xml:space="preserve">
          <source>C++ named requirements: MoveConstructible (since C++11)</source>
          <target state="translated">C++названные требования:MoveConstructible (начиная с C++11)</target>
        </trans-unit>
        <trans-unit id="596d45856032c8c30536491e6532eb33250543a6" translate="yes" xml:space="preserve">
          <source>C++ named requirements: MoveInsertable (since C++11)</source>
          <target state="translated">C++названные требования:MoveInsertable (начиная с C++11)</target>
        </trans-unit>
        <trans-unit id="1c772f99ba3b1d592fe8bec17544a1e701895811" translate="yes" xml:space="preserve">
          <source>C++ named requirements: Mutex</source>
          <target state="translated">C++названные требования:Мьютекс</target>
        </trans-unit>
        <trans-unit id="e88a54faa0bd94e7b4c8d3cd5b28da3afb45b924" translate="yes" xml:space="preserve">
          <source>C++ named requirements: NullablePointer (since C++11)</source>
          <target state="translated">C++названные требования:NullablePointer (начиная с C++11)</target>
        </trans-unit>
        <trans-unit id="dc4469e68ff2c5b54f8ee6d9e3f309ac6b21c5bb" translate="yes" xml:space="preserve">
          <source>C++ named requirements: NumericType</source>
          <target state="translated">C++названные требования:NumericType</target>
        </trans-unit>
        <trans-unit id="c535b9a77f5571dd0ffba42bac2b8d4ab54373c3" translate="yes" xml:space="preserve">
          <source>C++ named requirements: PODType</source>
          <target state="translated">C++названные требования:PODType</target>
        </trans-unit>
        <trans-unit id="f8a0530ac14d26f5e08f4d837ff5542a4988b36d" translate="yes" xml:space="preserve">
          <source>C++ named requirements: Predicate</source>
          <target state="translated">C++названные требования:Предикат</target>
        </trans-unit>
        <trans-unit id="84db291a7430e53241b723b9cdb6f5c57cf85f43" translate="yes" xml:space="preserve">
          <source>C++ named requirements: RandomNumberDistribution</source>
          <target state="translated">C++названные требования:RandomNumberDistribution</target>
        </trans-unit>
        <trans-unit id="16dd49ad42be796cea9fe6814de48219bd526a22" translate="yes" xml:space="preserve">
          <source>C++ named requirements: RandomNumberEngine</source>
          <target state="translated">C++названные требования:RandomNumberEngine</target>
        </trans-unit>
        <trans-unit id="57db25a8dd2fe59f88627a14f0d9f4454923652f" translate="yes" xml:space="preserve">
          <source>C++ named requirements: RandomNumberEngineAdaptor</source>
          <target state="translated">C++названные требования:RandomNumberEngineAdaptor</target>
        </trans-unit>
        <trans-unit id="ada05a46bb39c300a568907c930d2a57c5b9005d" translate="yes" xml:space="preserve">
          <source>C++ named requirements: RegexTraits</source>
          <target state="translated">C++названные требования:RegexTraits</target>
        </trans-unit>
        <trans-unit id="016355c7ec2c0cd838b6de26f8a355d0c2f26913" translate="yes" xml:space="preserve">
          <source>C++ named requirements: ReversibleContainer</source>
          <target state="translated">C++названные требования:Реверсивный контейнер</target>
        </trans-unit>
        <trans-unit id="19a660b52b4b8c99460cfc9a560b03a16cf9cb42" translate="yes" xml:space="preserve">
          <source>C++ named requirements: SeedSequence</source>
          <target state="translated">C++названные требования:SeedSequence</target>
        </trans-unit>
        <trans-unit id="331ae8b25a90d44993d56e79517cc81206e0068d" translate="yes" xml:space="preserve">
          <source>C++ named requirements: SequenceContainer</source>
          <target state="translated">C++названные требования:SequenceContainer</target>
        </trans-unit>
        <trans-unit id="5f9909d09bcc4eb0bdaada38cd2e514913d23668" translate="yes" xml:space="preserve">
          <source>C++ named requirements: SharedMutex</source>
          <target state="translated">C++названные требования:SharedMutex</target>
        </trans-unit>
        <trans-unit id="f60730295a5aa0cd12e4416e599d5f966530ef4d" translate="yes" xml:space="preserve">
          <source>C++ named requirements: SharedTimedMutex</source>
          <target state="translated">C++названные требования:SharedTimedMutex</target>
        </trans-unit>
        <trans-unit id="d03f73195120ea59f692bd306fc14c4f75ddea6e" translate="yes" xml:space="preserve">
          <source>C++ named requirements: StandardLayoutType</source>
          <target state="translated">C++названные требования:StandardLayoutType</target>
        </trans-unit>
        <trans-unit id="7c2afe9643847a18800f6549859cddf158aebfc0" translate="yes" xml:space="preserve">
          <source>C++ named requirements: Swappable</source>
          <target state="translated">C++названные требования:Сменный</target>
        </trans-unit>
        <trans-unit id="2699ee8a713e7d4efdc2e45280ccf4b85602bf33" translate="yes" xml:space="preserve">
          <source>C++ named requirements: TimedLockable</source>
          <target state="translated">C++названные требования:TimedLockable</target>
        </trans-unit>
        <trans-unit id="e4b09ebf2a8a166fe825d2ef813341e3cf6c00c4" translate="yes" xml:space="preserve">
          <source>C++ named requirements: TimedMutex</source>
          <target state="translated">C++названные требования:TimedMutex</target>
        </trans-unit>
        <trans-unit id="0f87af6136487f4529c077f27de7397f9b71930c" translate="yes" xml:space="preserve">
          <source>C++ named requirements: TransformationTrait</source>
          <target state="translated">C++названные требования:TransformationTrait</target>
        </trans-unit>
        <trans-unit id="90ecc6e1cfa9c37cd7a9058209da8423a4e1b338" translate="yes" xml:space="preserve">
          <source>C++ named requirements: TrivialClock</source>
          <target state="translated">C++названные требования:TrivialClock</target>
        </trans-unit>
        <trans-unit id="6e4be673e637f57a59a671d691fed257e408bde7" translate="yes" xml:space="preserve">
          <source>C++ named requirements: TrivialType</source>
          <target state="translated">C++названные требования:TrivialType</target>
        </trans-unit>
        <trans-unit id="547fb3490fe494ac4547d562d1e3a4efcf9201ea" translate="yes" xml:space="preserve">
          <source>C++ named requirements: TriviallyCopyable</source>
          <target state="translated">C++названные требования:TriviallyCopyable</target>
        </trans-unit>
        <trans-unit id="5dbb493f4749a745c93c18f6210f4d60d51e03a6" translate="yes" xml:space="preserve">
          <source>C++ named requirements: UnaryTypeTrait</source>
          <target state="translated">C++названные требования:UnaryTypeTrait</target>
        </trans-unit>
        <trans-unit id="4994b5268d59d59fba759c4ba742ecf79924693a" translate="yes" xml:space="preserve">
          <source>C++ named requirements: UnformattedInputFunction</source>
          <target state="translated">C++названные требования:НеформатированныйInputFunction .</target>
        </trans-unit>
        <trans-unit id="d5d9e9fb8d202091be5c90998db3426e13ad8496" translate="yes" xml:space="preserve">
          <source>C++ named requirements: UnformattedOutputFunction</source>
          <target state="translated">C++названные требования:НеформатированныйOutputFunction .</target>
        </trans-unit>
        <trans-unit id="6e75c2aeea843d06f31a9ca2caeb62946537533d" translate="yes" xml:space="preserve">
          <source>C++ named requirements: UniformRandomBitGenerator</source>
          <target state="translated">C++названные требования:УниформаРандоМБитГенератор</target>
        </trans-unit>
        <trans-unit id="87ad5436e94ce7e8b55c4f29d6f5a45aad21cf59" translate="yes" xml:space="preserve">
          <source>C++ named requirements: UnorderedAssociativeContainer</source>
          <target state="translated">C++названные требования:UnorderedAssociativeContainer</target>
        </trans-unit>
        <trans-unit id="15fe7066a6555232e049a6b5ae3a3b40fcc5e98b" translate="yes" xml:space="preserve">
          <source>C++ named requirements: ValueSwappable</source>
          <target state="translated">C++названные требования:ValueSwappable</target>
        </trans-unit>
        <trans-unit id="bb6995247feeb0031e28871e5d52bb0bde2f6ab2" translate="yes" xml:space="preserve">
          <source>C++ pragmas in Visual Studio 2015</source>
          <target state="translated">C++прагмы в Visual Studio 2015</target>
        </trans-unit>
        <trans-unit id="7b72da128624ab00dbe11304128e495f5b161352" translate="yes" xml:space="preserve">
          <source>C++ programs create, destroy, refer to, access, and manipulate</source>
          <target state="translated">Программы на C++создают,уничтожают,ссылаются,получают доступ и манипулируют</target>
        </trans-unit>
        <trans-unit id="cc223fe085208876202452b5634bdb87b28fe03f" translate="yes" xml:space="preserve">
          <source>C++ standard</source>
          <target state="translated">стандарт С++</target>
        </trans-unit>
        <trans-unit id="1a70571302b7aef91f6a1709d3bff98dbbe103cc" translate="yes" xml:space="preserve">
          <source>C++ time utilites</source>
          <target state="translated">использование времени C++</target>
        </trans-unit>
        <trans-unit id="4ae06f5fc59967a95d7d2edd41265fb164cde198" translate="yes" xml:space="preserve">
          <source>C++ type system overview</source>
          <target state="translated">обзор системы типа C++</target>
        </trans-unit>
        <trans-unit id="59267432adf8c9336c020edab8c6d1687c5a8555" translate="yes" xml:space="preserve">
          <source>C++-style</source>
          <target state="translated">C++-style</target>
        </trans-unit>
        <trans-unit id="741b2c379deb40170659b19eb9ef222dbd5fa167" translate="yes" xml:space="preserve">
          <source>C++-style comments are usually used to comment single lines, however, multiple C++-style comments can be placed together to form multi-line comments. C++-style comments tell the compiler to ignore all content between &lt;code&gt;//&lt;/code&gt; and a new line.</source>
          <target state="translated">Комментарии в стиле C ++ обычно используются для комментирования отдельных строк, однако несколько комментариев в стиле C ++ можно размещать вместе для формирования многострочных комментариев. Комментарии в стиле C ++ говорят компилятору игнорировать весь контент между &lt;code&gt;//&lt;/code&gt; и новой строкой.</target>
        </trans-unit>
        <trans-unit id="59fa0388313caf4655070a0038f68ffbc408c139" translate="yes" xml:space="preserve">
          <source>C++03</source>
          <target state="translated">C++03</target>
        </trans-unit>
        <trans-unit id="afd7c0601f217ac99e680979ea51cdb99e023353" translate="yes" xml:space="preserve">
          <source>C++03 POD with deleted non-trivial assignment was not trivial</source>
          <target state="translated">C++03 POD с удаленным нетривиальным присваиванием не было тривиальным</target>
        </trans-unit>
        <trans-unit id="d030954e126ef3cc7aa28e489ff18c492566d17e" translate="yes" xml:space="preserve">
          <source>C++03 standard (ISO/IEC 14882:2003):</source>
          <target state="translated">Стандарт C++03 (ISO/IEC 14882:2003):</target>
        </trans-unit>
        <trans-unit id="aa182f32a2b889bab8bb654d1c6efd34ac494dd1" translate="yes" xml:space="preserve">
          <source>C++11</source>
          <target state="translated">C++11</target>
        </trans-unit>
        <trans-unit id="eb6204614cbf77403cd382a95e0f929788c6393d" translate="yes" xml:space="preserve">
          <source>C++11 (class type)</source>
          <target state="translated">C++11 (тип класса)</target>
        </trans-unit>
        <trans-unit id="bca730909e080a8fc13db2273be471dfdb358b21" translate="yes" xml:space="preserve">
          <source>C++11 standard (ISO/IEC 14882:2011):</source>
          <target state="translated">Стандарт С++11 (ISO/IEC 14882:2011):</target>
        </trans-unit>
        <trans-unit id="526d8c7b1c46f07481431485812086e8bde79cad" translate="yes" xml:space="preserve">
          <source>C++14</source>
          <target state="translated">C++14</target>
        </trans-unit>
        <trans-unit id="3cf652fe8eeb36408d7f957624dd1e5feb276abf" translate="yes" xml:space="preserve">
          <source>C++14 (void)</source>
          <target state="translated">C++14 (пустота)</target>
        </trans-unit>
        <trans-unit id="451b62af75ef22e7c1ee3794a50c6a6c3fdd7f7e" translate="yes" xml:space="preserve">
          <source>C++14 standard (ISO/IEC 14882:2014):</source>
          <target state="translated">Стандарт С++14 (ISO/IEC 14882:2014):</target>
        </trans-unit>
        <trans-unit id="69ae287a1096db334e322d2404e3cd62fc5f7016" translate="yes" xml:space="preserve">
          <source>C++17</source>
          <target state="translated">C++17</target>
        </trans-unit>
        <trans-unit id="4c20ccb3f39c8ffe021987c4ad44fbb012e0262a" translate="yes" xml:space="preserve">
          <source>C++17 standard (ISO/IEC 14882:2017):</source>
          <target state="translated">Стандарт С++17 (ISO/IEC 14882:2017):</target>
        </trans-unit>
        <trans-unit id="9f0db8e1214a8ccf376f0bc5ba61385a18fbb5cc" translate="yes" xml:space="preserve">
          <source>C++20 defines a set of &lt;a href=&quot;../language/constraints&quot;&gt;constrained&lt;/a&gt; comparison function objects. The equality operators (&lt;code&gt;ranges::equal_to&lt;/code&gt; and &lt;code&gt;ranges::not_equal_to&lt;/code&gt;) require the types of the arguments to model &lt;a href=&quot;../concepts/equalitycomparable&quot;&gt;&lt;code&gt;EqualityComparableWith&lt;/code&gt;&lt;/a&gt;. The relational operators (&lt;code&gt;ranges::less&lt;/code&gt;, &lt;code&gt;ranges::greater&lt;/code&gt;, &lt;code&gt;ranges::less_equal&lt;/code&gt;, and &lt;code&gt;ranges::greater_equal&lt;/code&gt;) require the types of the arguments to model &lt;a href=&quot;../concepts/stricttotallyordered&quot;&gt;&lt;code&gt;StrictTotallyOrderedWith&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">C ++ 20 определяет набор &lt;a href=&quot;../language/constraints&quot;&gt;ограниченных&lt;/a&gt; объектов функции сравнения. Операторы равенства ( &lt;code&gt;ranges::equal_to&lt;/code&gt; и range &lt;code&gt;ranges::not_equal_to&lt;/code&gt; ) требуют типы аргументов для моделирования &lt;a href=&quot;../concepts/equalitycomparable&quot;&gt; &lt;code&gt;EqualityComparableWith&lt;/code&gt; &lt;/a&gt; . Операторы отношений ( &lt;code&gt;ranges::less&lt;/code&gt; , &lt;code&gt;ranges::greater&lt;/code&gt; , &lt;code&gt;ranges::less_equal&lt;/code&gt; и &lt;code&gt;ranges::greater_equal&lt;/code&gt; ) требуют типов аргументов для моделирования &lt;a href=&quot;../concepts/stricttotallyordered&quot;&gt; &lt;code&gt;StrictTotallyOrderedWith&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="05eb29d2d943895480cbf23e5a4b02a727a6e2db" translate="yes" xml:space="preserve">
          <source>C++20 introduces a new system of iterators based on &lt;a href=&quot;language/constraints&quot;&gt;concepts&lt;/a&gt; that are different from C++17 iterators. While the basic taxonomy remains similar, the requirements for individual iterator categories are somewhat different.</source>
          <target state="translated">C ++ 20 представляет новую систему итераторов, основанную на &lt;a href=&quot;language/constraints&quot;&gt;концепциях&lt;/a&gt; , отличных от итераторов C ++ 17. Хотя базовая таксономия остается схожей, требования к отдельным категориям итераторов несколько отличаются.</target>
        </trans-unit>
        <trans-unit id="2e528f3cc4d3fc3ca8b281cef54dbb5b071d694e" translate="yes" xml:space="preserve">
          <source>C++20 iterator concepts</source>
          <target state="translated">концепции итератора C++20</target>
        </trans-unit>
        <trans-unit id="098b2706a0a08c620a10641456b665a828dbc0fa" translate="yes" xml:space="preserve">
          <source>C++20 provides &lt;a href=&quot;../language/constraints&quot;&gt;constrained&lt;/a&gt; versions of most algorithms in the namespace &lt;code&gt;std::ranges&lt;/code&gt;. In these algorithms, a range can be specified as either a &lt;a href=&quot;https://en.cppreference.com/mwiki/index.php?title=cpp/iterator/Iterator&amp;amp;action=edit&amp;amp;redlink=1&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt;-&lt;a href=&quot;https://en.cppreference.com/mwiki/index.php?title=cpp/iterator/Sentinel&amp;amp;action=edit&amp;amp;redlink=1&quot;&gt;&lt;code&gt;Sentinel&lt;/code&gt;&lt;/a&gt; pair or as a single &lt;a href=&quot;../ranges/range&quot;&gt;&lt;code&gt;Range&lt;/code&gt;&lt;/a&gt; argument, and projections and pointer-to-member callables are supported. Additionally, the return type of most algorithms have been changed to return all potentially useful information computed during the execution of the algorithm.</source>
          <target state="translated">C ++ 20 предоставляет &lt;a href=&quot;../language/constraints&quot;&gt;ограниченные&lt;/a&gt; версии большинства алгоритмов в пространстве имен &lt;code&gt;std::ranges&lt;/code&gt; . В этих алгоритмах диапазон может быть указан либо как пара &lt;a href=&quot;https://en.cppreference.com/mwiki/index.php?title=cpp/iterator/Iterator&amp;amp;action=edit&amp;amp;redlink=1&quot;&gt; &lt;code&gt;Iterator&lt;/code&gt; &lt;/a&gt; - &lt;a href=&quot;https://en.cppreference.com/mwiki/index.php?title=cpp/iterator/Sentinel&amp;amp;action=edit&amp;amp;redlink=1&quot;&gt; &lt;code&gt;Sentinel&lt;/code&gt; ,&lt;/a&gt; либо как один аргумент &lt;a href=&quot;../ranges/range&quot;&gt; &lt;code&gt;Range&lt;/code&gt; &lt;/a&gt; , и поддерживаются проекции и вызовы указателя на член. Кроме того, тип возврата большинства алгоритмов был изменен, чтобы возвращать всю потенциально полезную информацию, вычисленную во время выполнения алгоритма.</target>
        </trans-unit>
        <trans-unit id="1e947bf13606a87a8b5513ba351822e6dad8eca6" translate="yes" xml:space="preserve">
          <source>C++20 provides &lt;a href=&quot;language/constraints&quot;&gt;constrained&lt;/a&gt; uninitialized memory algorithms that accept range arguments or iterator-sentinel pairs.</source>
          <target state="translated">C ++ 20 предоставляет &lt;a href=&quot;language/constraints&quot;&gt;ограниченные&lt;/a&gt; неинициализированные алгоритмы памяти, которые принимают аргументы диапазона или пары итератор-страж.</target>
        </trans-unit>
        <trans-unit id="02dac318248d623e3712f39050dab4b9f4c60683" translate="yes" xml:space="preserve">
          <source>C++20 provides &lt;a href=&quot;language/constraints&quot;&gt;constrained&lt;/a&gt; versions of most algorithms in the namespace &lt;code&gt;std::ranges&lt;/code&gt;. In these algorithms, a range can be specified as either an &lt;a href=&quot;https://en.cppreference.com/mwiki/index.php?title=cpp/iterator/Iterator&amp;amp;action=edit&amp;amp;redlink=1&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt;-&lt;a href=&quot;https://en.cppreference.com/mwiki/index.php?title=cpp/iterator/Sentinel&amp;amp;action=edit&amp;amp;redlink=1&quot;&gt;&lt;code&gt;Sentinel&lt;/code&gt;&lt;/a&gt; pair or as a single &lt;a href=&quot;ranges/range&quot;&gt;&lt;code&gt;Range&lt;/code&gt;&lt;/a&gt; argument, and projections and pointer-to-member callables are supported. Additionally, the return types of most algorithms have been changed to return all potentially useful information computed during the execution of the algorithm.</source>
          <target state="translated">C ++ 20 предоставляет &lt;a href=&quot;language/constraints&quot;&gt;ограниченные&lt;/a&gt; версии большинства алгоритмов в пространстве имен &lt;code&gt;std::ranges&lt;/code&gt; . В этих алгоритмах диапазон может быть задан либо как пара &lt;a href=&quot;https://en.cppreference.com/mwiki/index.php?title=cpp/iterator/Iterator&amp;amp;action=edit&amp;amp;redlink=1&quot;&gt; &lt;code&gt;Iterator&lt;/code&gt; &lt;/a&gt; - &lt;a href=&quot;https://en.cppreference.com/mwiki/index.php?title=cpp/iterator/Sentinel&amp;amp;action=edit&amp;amp;redlink=1&quot;&gt; &lt;code&gt;Sentinel&lt;/code&gt; ,&lt;/a&gt; либо как один аргумент &lt;a href=&quot;ranges/range&quot;&gt; &lt;code&gt;Range&lt;/code&gt; &lt;/a&gt; , и поддерживаются проекции и вызовы указателя на член. Кроме того, типы возврата большинства алгоритмов были изменены, чтобы возвращать всю потенциально полезную информацию, вычисленную во время выполнения алгоритма.</target>
        </trans-unit>
        <trans-unit id="b22ed7e9c883004117343b0e71726914a2fd2287" translate="yes" xml:space="preserve">
          <source>C++98</source>
          <target state="translated">C++98</target>
        </trans-unit>
        <trans-unit id="ba0489b5be9b76c42ad4405b0950fd7062f9aa6d" translate="yes" xml:space="preserve">
          <source>C++98 standard (ISO/IEC 14882:1998):</source>
          <target state="translated">Стандарт С++98 (ISO/IEC 14882:1998):</target>
        </trans-unit>
        <trans-unit id="f192047d0579fa733e3007a4b4927c4192eec128" translate="yes" xml:space="preserve">
          <source>C, but C precedes A in the single total order C-E-F-A of &lt;code&gt;memory_order_seq_cst&lt;/code&gt; (see &lt;a href=&quot;https://plv.mpi-sws.org/scfix/paper.pdf&quot;&gt;Lahav et al&lt;/a&gt;).</source>
          <target state="translated">C, но C предшествует A в едином общем порядке CEFA &lt;code&gt;memory_order_seq_cst&lt;/code&gt; (см. &lt;a href=&quot;https://plv.mpi-sws.org/scfix/paper.pdf&quot;&gt;Лахав и др.&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="f56f539774c9129a13109892792a99de9ce3ec15" translate="yes" xml:space="preserve">
          <source>C-string or char array to use as the contents of the stream</source>
          <target state="translated">С-строка или массив символов для использования в качестве содержимого потока</target>
        </trans-unit>
        <trans-unit id="bd39761895022d52ef2184edffb0689497519cb3" translate="yes" xml:space="preserve">
          <source>C-style</source>
          <target state="translated">C-style</target>
        </trans-unit>
        <trans-unit id="7526d60a0c8e276994609ec345feddbe30ee8465" translate="yes" xml:space="preserve">
          <source>C-style &lt;a href=&quot;string/multibyte&quot;&gt; Unicode character conversion functions&lt;/a&gt;</source>
          <target state="translated">C-стиль &lt;a href=&quot;string/multibyte&quot;&gt;Функции преобразования символов Unicode в&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="56a020c22140d662b6720ea7925672fd8f454173" translate="yes" xml:space="preserve">
          <source>C-style IO</source>
          <target state="translated">ИО в стиле &quot;С</target>
        </trans-unit>
        <trans-unit id="44c1448ec5b283e6541ef6028da691d71017b995" translate="yes" xml:space="preserve">
          <source>C-style cast</source>
          <target state="translated">замок в стиле С</target>
        </trans-unit>
        <trans-unit id="c2150e9d35b98ece63e7d4b63009872a56f2d872" translate="yes" xml:space="preserve">
          <source>C-style cast expression</source>
          <target state="translated">С-образное литое выражение</target>
        </trans-unit>
        <trans-unit id="c663a9e8a239cedd93c5da9c15d557da154de974" translate="yes" xml:space="preserve">
          <source>C-style comments are usually used to comment large blocks of text, however, they can be used to comment single lines. To insert a C-style comment, simply surround text with &lt;code&gt;/*&lt;/code&gt; and &lt;code&gt;*/&lt;/code&gt;; this will cause the contents of the comment to be ignored by the compiler. Although it is not part of the C++ standard, &lt;code&gt;/**&lt;/code&gt; and &lt;code&gt;*/&lt;/code&gt; are often used to indicate documentation blocks; this is legal because the second asterisk is simply treated as part of the comment. C-style comments cannot be nested.</source>
          <target state="translated">Комментарии в стиле C обычно используются для комментирования больших блоков текста, однако их можно использовать для комментирования отдельных строк. Чтобы вставить комментарий в стиле C, просто окружите текст &lt;code&gt;/*&lt;/code&gt; и &lt;code&gt;*/&lt;/code&gt; ; это заставит компилятор игнорировать содержимое комментария. Хотя это не является частью стандарта C ++, &lt;code&gt;/**&lt;/code&gt; и &lt;code&gt;*/&lt;/code&gt; часто используются для обозначения блоков документации; это законно, потому что вторая звездочка просто рассматривается как часть комментария. Комментарии в стиле C не могут быть вложенными.</target>
        </trans-unit>
        <trans-unit id="48253fbd0ad94c130de734e904780378dbaf86ae" translate="yes" xml:space="preserve">
          <source>C-style date and time library</source>
          <target state="translated">Библиотека данных и времени в стиле С</target>
        </trans-unit>
        <trans-unit id="2f7dc08f72f32281ebb854326effae89b085e12d" translate="yes" xml:space="preserve">
          <source>C-style date and time library (e.g. &lt;code&gt;&lt;a href=&quot;chrono/c/time&quot;&gt;std::time&lt;/a&gt;&lt;/code&gt;)</source>
          <target state="translated">Библиотека даты и времени в стиле C (например, &lt;code&gt;&lt;a href=&quot;chrono/c/time&quot;&gt;std::time&lt;/a&gt;&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="f58953ee114042660a40fb46cdbb6561045fdd9e" translate="yes" xml:space="preserve">
          <source>C-style file input/output</source>
          <target state="translated">ввод/вывод файлов в стиле C</target>
        </trans-unit>
        <trans-unit id="ee69eba17157f0bd643ab8f69127f0bbfedd84dc" translate="yes" xml:space="preserve">
          <source>C-style input-output functions</source>
          <target state="translated">Функции ввода-вывода в стиле C</target>
        </trans-unit>
        <trans-unit id="78e1709449ee6d0679c98c9e988b4d20f58cb3c2" translate="yes" xml:space="preserve">
          <source>C-style memory management</source>
          <target state="translated">управление памятью в стиле С</target>
        </trans-unit>
        <trans-unit id="b3df26bb0867d25f5ab994e73d5725e15e0b58b0" translate="yes" xml:space="preserve">
          <source>C-style time/date utilites</source>
          <target state="translated">C-стиль использования времени/даты</target>
        </trans-unit>
        <trans-unit id="52aea3b6618c4eb66aee74f7ff3b04621de74570" translate="yes" xml:space="preserve">
          <source>C-style variadic functions</source>
          <target state="translated">вариадические функции в стиле С</target>
        </trans-unit>
        <trans-unit id="24fc58ea2f98cd20a27008421ec7f7e3dfc35435" translate="yes" xml:space="preserve">
          <source>CHAR_BIT</source>
          <target state="translated">CHAR_BIT</target>
        </trans-unit>
        <trans-unit id="725f72738449b33d5ed2db35158ace2f646b043c" translate="yes" xml:space="preserve">
          <source>CHAR_MAX</source>
          <target state="translated">CHAR_MAX</target>
        </trans-unit>
        <trans-unit id="b30c9342a5465cef0a56934460b3bfa4e2e74c49" translate="yes" xml:space="preserve">
          <source>CHAR_MIN</source>
          <target state="translated">CHAR_MIN</target>
        </trans-unit>
        <trans-unit id="c820f67f5827175c8c204a8b983dc8a39b93cac1" translate="yes" xml:space="preserve">
          <source>CIRCLED DIGIT ONE - NEGATIVE CIRCLED DIGIT ZERO</source>
          <target state="translated">ОБВЕДЁННАЯ ЦИФРА ОДИН-ОТРИЦАТЕЛЬНАЯ ОБВЕДЁННАЯ ЦИФРА НОЛЬ</target>
        </trans-unit>
        <trans-unit id="fff8f67cf9fc327818272d81ae72e6f4b9164d0a" translate="yes" xml:space="preserve">
          <source>CJK COMPATIBILITY IDEOGRAPH-F900 - ARABIC LIGATURE ALEF WITH FATHATAN ISOLATED FORM</source>
          <target state="translated">CJK СОВМЕСТИМОСТЬ ИДЕОГРАФ F900-АРАБСКАЯ ЛИГАТУРА ALEF С ИЗОЛИРОВАННОЙ ФОРМОЙ FATHATAN</target>
        </trans-unit>
        <trans-unit id="190e1ea5952f0d388e456800d46304578b3a93e8" translate="yes" xml:space="preserve">
          <source>CJK RADICAL REPEAT - IDEOGRAPHIC DESCRIPTION CHARACTER OVERLAID</source>
          <target state="translated">CJK РАДИКАЛЬНОЕ ПОВТОРЕНИЕ-ИДЕОГРАФИЧЕСКОЕ ОПИСАНИЕ ПЕРСОНАЖА НАКЛАДЫВАЕТСЯ</target>
        </trans-unit>
        <trans-unit id="789b032a45d264e7a02138bff69b47aacb370fca" translate="yes" xml:space="preserve">
          <source>CLOCKS_PER_SEC</source>
          <target state="translated">CLOCKS_PER_SEC</target>
        </trans-unit>
        <trans-unit id="8b6654ec4bc3d0c514cc6e4b4ad72a0db37a1444" translate="yes" xml:space="preserve">
          <source>COMBINING DOTTED GRAVE ACCENT - COMBINING RIGHT ARROWHEAD AND DOWN ARROWHEAD BELOW</source>
          <target state="translated">СОВМЕЩЕНИЕ ТОЧЕЧНОГО МОГИЛЬНОГО АКЦЕНТА-СОВМЕЩЕНИЕ ПРАВОГО НАКОНЕЧНИКА СТРЕЛКИ И НИЖНЕГО НАКОНЕЧНИКА СТРЕЛКИ НИЖЕ</target>
        </trans-unit>
        <trans-unit id="714ab47a0e6f413b3bf281d1f4cbe410847fe7f1" translate="yes" xml:space="preserve">
          <source>COMBINING GRAVE ACCENT - COMBINING LATIN SMALL LETTER X</source>
          <target state="translated">СОВМЕЩЕНИЕ СЕРЬЕЗНОГО АКЦЕНТА-СОВМЕЩЕНИЕ ЛАТИНСКОЙ МАЛЕНЬКОЙ БУКВЫ X</target>
        </trans-unit>
        <trans-unit id="35575c776ae958fb9883f5bf9ba9b6cfaf676fb9" translate="yes" xml:space="preserve">
          <source>COMBINING LEFT HARPOON ABOVE - COMBINING ASTERISK ABOVE</source>
          <target state="translated">СОВМЕЩЕНИЕ ЛЕВОГО ГАРПУНА СВЕРХУ-СОВМЕЩЕНИЕ ЗВЕЗДОЧКИ СВЕРХУ</target>
        </trans-unit>
        <trans-unit id="7febb4b03096c80654f363847dc95a2cfb84fefe" translate="yes" xml:space="preserve">
          <source>COMBINING LIGATURE LEFT HALF - COMBINING CYRILLIC TITLO RIGHT HALF</source>
          <target state="translated">СОВМЕЩЕНИЕ ЛИГАТУРЫ ЛЕВАЯ ПОЛОВИНА-СОВМЕЩЕНИЕ КИРИЛЛИЧЕСКОГО ТИТЛА ПРАВАЯ ПОЛОВИНА</target>
        </trans-unit>
        <trans-unit id="9560447a54fd74d0cf86900665e48394b8c2274d" translate="yes" xml:space="preserve">
          <source>CPL</source>
          <target state="translated">CPL</target>
        </trans-unit>
        <trans-unit id="b24be71613a88ae74ef2222af07f1f8532a2eb06" translate="yes" xml:space="preserve">
          <source>CRTP</source>
          <target state="translated">CRTP</target>
        </trans-unit>
        <trans-unit id="a59d9bcee7f8794c67d0f8eaac8b827616f73808" translate="yes" xml:space="preserve">
          <source>CTAD</source>
          <target state="translated">CTAD</target>
        </trans-unit>
        <trans-unit id="47563e02f34b97527aa11cd2660b1c531f28a7a0" translate="yes" xml:space="preserve">
          <source>CWG 1213</source>
          <target state="translated">CWG 1213</target>
        </trans-unit>
        <trans-unit id="4b2c33f3b2901add653231f28b9837371837d438" translate="yes" xml:space="preserve">
          <source>CWG 1301</source>
          <target state="translated">CWG 1301</target>
        </trans-unit>
        <trans-unit id="6ffd78fdcfc97704227c81ed211b654ae584f03c" translate="yes" xml:space="preserve">
          <source>CWG 1313</source>
          <target state="translated">CWG 1313</target>
        </trans-unit>
        <trans-unit id="e72262c1f7923c69acd5b6e632a6ea0b0ee13223" translate="yes" xml:space="preserve">
          <source>CWG 1315</source>
          <target state="translated">CWG 1315</target>
        </trans-unit>
        <trans-unit id="74b12783757c5081b7fb53b3cd6b878928af8eae" translate="yes" xml:space="preserve">
          <source>CWG 1391</source>
          <target state="translated">CWG 1391</target>
        </trans-unit>
        <trans-unit id="d9e49fbd701bbcdc956dcedc347ee4c2dab0f2ed" translate="yes" xml:space="preserve">
          <source>CWG 1394</source>
          <target state="translated">CWG 1394</target>
        </trans-unit>
        <trans-unit id="4fb7724609c8a8b0dcca0bada49c63e843cf4195" translate="yes" xml:space="preserve">
          <source>CWG 1395</source>
          <target state="translated">CWG 1395</target>
        </trans-unit>
        <trans-unit id="7154988f61117199c76a049798a28cf90de02420" translate="yes" xml:space="preserve">
          <source>CWG 1397</source>
          <target state="translated">CWG 1397</target>
        </trans-unit>
        <trans-unit id="b449890ac0834487b5eaf123c275fd35b1137504" translate="yes" xml:space="preserve">
          <source>CWG 1423</source>
          <target state="translated">CWG 1423</target>
        </trans-unit>
        <trans-unit id="9a7b9cc74202f3c29fa36c900f6ba27c585313fc" translate="yes" xml:space="preserve">
          <source>CWG 1458</source>
          <target state="translated">CWG 1458</target>
        </trans-unit>
        <trans-unit id="40d23e9f1ab69a460e82608189870f9b5cac5e51" translate="yes" xml:space="preserve">
          <source>CWG 1467</source>
          <target state="translated">CWG 1467</target>
        </trans-unit>
        <trans-unit id="d9c41df53bb29177228be09033e92e1deef54502" translate="yes" xml:space="preserve">
          <source>CWG 1550</source>
          <target state="translated">CWG 1550</target>
        </trans-unit>
        <trans-unit id="2749cb8bd08487f07f57b026d7f0a32906248fc7" translate="yes" xml:space="preserve">
          <source>CWG 1558</source>
          <target state="translated">CWG 1558</target>
        </trans-unit>
        <trans-unit id="1930e406ede3e006c8d9aac6e7043f5d94676955" translate="yes" xml:space="preserve">
          <source>CWG 1560</source>
          <target state="translated">CWG 1560</target>
        </trans-unit>
        <trans-unit id="e6ba8d164871c6a798203d13dfcb1e6e4da6da78" translate="yes" xml:space="preserve">
          <source>CWG 1579</source>
          <target state="translated">CWG 1579</target>
        </trans-unit>
        <trans-unit id="73c5f99cc638773086e35615fade4d4947d1d60e" translate="yes" xml:space="preserve">
          <source>CWG 1591</source>
          <target state="translated">CWG 1591</target>
        </trans-unit>
        <trans-unit id="735a2e213b861827190fdf465dd014f41f1f5684" translate="yes" xml:space="preserve">
          <source>CWG 1601</source>
          <target state="translated">CWG 1601</target>
        </trans-unit>
        <trans-unit id="f698a022a799e476a4b5d90908c4f0968039b3a4" translate="yes" xml:space="preserve">
          <source>CWG 1638</source>
          <target state="translated">CWG 1638</target>
        </trans-unit>
        <trans-unit id="9d6075634dd8060a300813233ee99f173cd90be3" translate="yes" xml:space="preserve">
          <source>CWG 1672</source>
          <target state="translated">CWG 1672</target>
        </trans-unit>
        <trans-unit id="b72ace2ad31c1e2fb91f1346d396608578b35f79" translate="yes" xml:space="preserve">
          <source>CWG 1696</source>
          <target state="translated">CWG 1696</target>
        </trans-unit>
        <trans-unit id="28347337bf2cc1f1919d510e1adbb168425a77c2" translate="yes" xml:space="preserve">
          <source>CWG 1719</source>
          <target state="translated">CWG 1719</target>
        </trans-unit>
        <trans-unit id="be03df1470395dcc9eeb7f3194fc4e5a81102ad5" translate="yes" xml:space="preserve">
          <source>CWG 1722</source>
          <target state="translated">CWG 1722</target>
        </trans-unit>
        <trans-unit id="0c7f27ab354ac1a80a384197c76d4e3d24b3a644" translate="yes" xml:space="preserve">
          <source>CWG 1734</source>
          <target state="translated">CWG 1734</target>
        </trans-unit>
        <trans-unit id="93fb30cfc8e126fb5fe13f8d64ea000c6669b4e0" translate="yes" xml:space="preserve">
          <source>CWG 1781</source>
          <target state="translated">CWG 1781</target>
        </trans-unit>
        <trans-unit id="75c74907ac6a6383a90bffab070b3ef5f33e6cdb" translate="yes" xml:space="preserve">
          <source>CWG 1813</source>
          <target state="translated">CWG 1813</target>
        </trans-unit>
        <trans-unit id="2eaa057756492b48b304275aed682a52bf13bef5" translate="yes" xml:space="preserve">
          <source>CWG 1838</source>
          <target state="translated">CWG 1838</target>
        </trans-unit>
        <trans-unit id="0d25ef040ac6f3edbf12f878493bba23ddbf903d" translate="yes" xml:space="preserve">
          <source>CWG 1863</source>
          <target state="translated">ПРГ 1863 Г.</target>
        </trans-unit>
        <trans-unit id="d31cb5a2e409347064465cd90ecdb5de73cbbcca" translate="yes" xml:space="preserve">
          <source>CWG 1866</source>
          <target state="translated">ПРГ 1866 Г.</target>
        </trans-unit>
        <trans-unit id="af6cfdd2ae9b748b30376111eb2e1a4d17271d87" translate="yes" xml:space="preserve">
          <source>CWG 1878</source>
          <target state="translated">CWG 1878</target>
        </trans-unit>
        <trans-unit id="76b6b3653d71fac1420ccfc68013d1df012f6885" translate="yes" xml:space="preserve">
          <source>CWG 1885</source>
          <target state="translated">CWG 1885</target>
        </trans-unit>
        <trans-unit id="80077256fcd7c8d10a1735e2561b5761dc72781c" translate="yes" xml:space="preserve">
          <source>CWG 1891</source>
          <target state="translated">CWG 1891</target>
        </trans-unit>
        <trans-unit id="1028a0754e9331957ee9dec60315a06334455543" translate="yes" xml:space="preserve">
          <source>CWG 1895</source>
          <target state="translated">CWG 1895</target>
        </trans-unit>
        <trans-unit id="715e6f5a0af4ea83c2adbba2e1c4a84c4cdf4c23" translate="yes" xml:space="preserve">
          <source>CWG 1911</source>
          <target state="translated">CWG 1911</target>
        </trans-unit>
        <trans-unit id="d59063371cbbf3c50fa4004a2c980a915a5a3712" translate="yes" xml:space="preserve">
          <source>CWG 1932</source>
          <target state="translated">CWG 1932</target>
        </trans-unit>
        <trans-unit id="fee2040205e11bfb3c90d627d95a3ef1b06bf7c8" translate="yes" xml:space="preserve">
          <source>CWG 1940</source>
          <target state="translated">ПРГ 1940</target>
        </trans-unit>
        <trans-unit id="7be04ab603086e1fe7b3d69077927db8d61e60df" translate="yes" xml:space="preserve">
          <source>CWG 195</source>
          <target state="translated">ПРГ 195</target>
        </trans-unit>
        <trans-unit id="401b02ff04774bdf69dfc351c0fc646e8c52792c" translate="yes" xml:space="preserve">
          <source>CWG 1951</source>
          <target state="translated">ПРГ 1951</target>
        </trans-unit>
        <trans-unit id="28c16abcb79a7d2985fffaea2e7091ceaeedcb15" translate="yes" xml:space="preserve">
          <source>CWG 1952</source>
          <target state="translated">ПРГ 1952 Г.</target>
        </trans-unit>
        <trans-unit id="78e6d54c5d8c416b62b8bc7f6de701b3133dfbaa" translate="yes" xml:space="preserve">
          <source>CWG 1955</source>
          <target state="translated">ПРГ 1955 Г.</target>
        </trans-unit>
        <trans-unit id="41f749570a89d069549057499232a1cc43471407" translate="yes" xml:space="preserve">
          <source>CWG 1992</source>
          <target state="translated">CWG 1992</target>
        </trans-unit>
        <trans-unit id="1463942fad687beb04e017d429368db857b7bf10" translate="yes" xml:space="preserve">
          <source>CWG 2004</source>
          <target state="translated">ПРГ 2004</target>
        </trans-unit>
        <trans-unit id="24b2f326ff1dbd6e75b7fe0777847a2048e25f64" translate="yes" xml:space="preserve">
          <source>CWG 2012</source>
          <target state="translated">CWG 2012</target>
        </trans-unit>
        <trans-unit id="a252ff07735443b3b89651fd3662e3f4c3a99e40" translate="yes" xml:space="preserve">
          <source>CWG 2022</source>
          <target state="translated">CWG 2022</target>
        </trans-unit>
        <trans-unit id="585fa29096b9165f2e65d4ab7ac3d55d4ccca16d" translate="yes" xml:space="preserve">
          <source>CWG 2026</source>
          <target state="translated">CWG 2026</target>
        </trans-unit>
        <trans-unit id="8190296876c615aed0b58aa2986f2e3603ff068b" translate="yes" xml:space="preserve">
          <source>CWG 2039</source>
          <target state="translated">CWG 2039</target>
        </trans-unit>
        <trans-unit id="9fac3c0f458bed3f35cc6e7ea77169bfd642f791" translate="yes" xml:space="preserve">
          <source>CWG 2052</source>
          <target state="translated">CWG 2052</target>
        </trans-unit>
        <trans-unit id="905971b8c2ebad4151cef0c505c6db3c3443e509" translate="yes" xml:space="preserve">
          <source>CWG 2082</source>
          <target state="translated">CWG 2082</target>
        </trans-unit>
        <trans-unit id="a60400639f386cc83b091425fd72478bd78dccb6" translate="yes" xml:space="preserve">
          <source>CWG 2084</source>
          <target state="translated">CWG 2084</target>
        </trans-unit>
        <trans-unit id="d0912de9c62ce2a759dd40ba5c95059625c84704" translate="yes" xml:space="preserve">
          <source>CWG 2091</source>
          <target state="translated">CWG 2091</target>
        </trans-unit>
        <trans-unit id="97ce1e0c528bfc8a4aee8f304b082d78f3313d15" translate="yes" xml:space="preserve">
          <source>CWG 2094</source>
          <target state="translated">CWG 2094</target>
        </trans-unit>
        <trans-unit id="bb553bbdccad20b58a6287507179e7aaac1138f8" translate="yes" xml:space="preserve">
          <source>CWG 2100</source>
          <target state="translated">CWG 2100</target>
        </trans-unit>
        <trans-unit id="7d55f979aebc02a17a304196dbaedd6e39446715" translate="yes" xml:space="preserve">
          <source>CWG 2120</source>
          <target state="translated">CWG 2120</target>
        </trans-unit>
        <trans-unit id="57a98d99b6d9403964ab62e7650db4ce2125747b" translate="yes" xml:space="preserve">
          <source>CWG 2137</source>
          <target state="translated">CWG 2137</target>
        </trans-unit>
        <trans-unit id="5e7983e2eff1437835ae2c5af3c0e619bb441ca6" translate="yes" xml:space="preserve">
          <source>CWG 2163</source>
          <target state="translated">CWG 2163</target>
        </trans-unit>
        <trans-unit id="fab7f39f8b013bbf0a59f2fe8002534da773c8aa" translate="yes" xml:space="preserve">
          <source>CWG 2167</source>
          <target state="translated">CWG 2167</target>
        </trans-unit>
        <trans-unit id="3f873603897faddf9e479a2f3afd854cd91d6381" translate="yes" xml:space="preserve">
          <source>CWG 2171</source>
          <target state="translated">CWG 2171</target>
        </trans-unit>
        <trans-unit id="fe9644b244394c2eabfc31e02ec47a961f67cb01" translate="yes" xml:space="preserve">
          <source>CWG 2176</source>
          <target state="translated">CWG 2176</target>
        </trans-unit>
        <trans-unit id="203df293763ce0d669052a6832f14d3fafcf7792" translate="yes" xml:space="preserve">
          <source>CWG 2268</source>
          <target state="translated">CWG 2268</target>
        </trans-unit>
        <trans-unit id="0654e95544b6a3934ee54bf50137e9773bf4eece" translate="yes" xml:space="preserve">
          <source>CWG 2278</source>
          <target state="translated">CWG 2278</target>
        </trans-unit>
        <trans-unit id="1e706907058df91acb35f56258b08ab09a4a3a70" translate="yes" xml:space="preserve">
          <source>CWG 2387</source>
          <target state="translated">CWG 2387</target>
        </trans-unit>
        <trans-unit id="82d53da8356c3ca3b92f1c7356ff3db1988d1b75" translate="yes" xml:space="preserve">
          <source>CWG 330</source>
          <target state="translated">CWG 330</target>
        </trans-unit>
        <trans-unit id="ccb6c3b42336d94c15bb3870d96c4815af38060e" translate="yes" xml:space="preserve">
          <source>CWG 393</source>
          <target state="translated">CWG 393</target>
        </trans-unit>
        <trans-unit id="e15dfefc20dc9707f7b3d7e3bfd742f4ba2fe0e6" translate="yes" xml:space="preserve">
          <source>CWG 45</source>
          <target state="translated">CWG 45</target>
        </trans-unit>
        <trans-unit id="a683182b298c47030d15a78fb9455cd68db3f4e1" translate="yes" xml:space="preserve">
          <source>CWG 496</source>
          <target state="translated">CWG 496</target>
        </trans-unit>
        <trans-unit id="f6a4d2d7852a929bdef3282acacef0950c6827a3" translate="yes" xml:space="preserve">
          <source>CWG 500</source>
          <target state="translated">CWG 500</target>
        </trans-unit>
        <trans-unit id="8168079f990033b28ee30baf555b21dac700dbe5" translate="yes" xml:space="preserve">
          <source>CWG 577</source>
          <target state="translated">CWG 577</target>
        </trans-unit>
        <trans-unit id="6fc7f7d941214d7e90028d76ec9df5aece8e4b10" translate="yes" xml:space="preserve">
          <source>CWG 613</source>
          <target state="translated">CWG 613</target>
        </trans-unit>
        <trans-unit id="65ecce3064605f43be72ea3dd69ca82afaeced68" translate="yes" xml:space="preserve">
          <source>CWG 616</source>
          <target state="translated">CWG 616</target>
        </trans-unit>
        <trans-unit id="de85001d3da367b6bc9e3cd052c9bab51ab5abda" translate="yes" xml:space="preserve">
          <source>CWG 727</source>
          <target state="translated">CWG 727</target>
        </trans-unit>
        <trans-unit id="1617da0092a5442eeec85cdd1cb1225081fe44bf" translate="yes" xml:space="preserve">
          <source>CWG 903</source>
          <target state="translated">CWG 903</target>
        </trans-unit>
        <trans-unit id="af14bcf58f1a68925b0a5504ba2c3fedd31bf275" translate="yes" xml:space="preserve">
          <source>CWG 975</source>
          <target state="translated">CWG 975</target>
        </trans-unit>
        <trans-unit id="883938ab5275fd7f506eef92dcbd07ff4e7d5615" translate="yes" xml:space="preserve">
          <source>Cache size access</source>
          <target state="translated">Доступ к размеру кэша</target>
        </trans-unit>
        <trans-unit id="abd58164af939ff4d9cde0c5a458880ac0375eb1" translate="yes" xml:space="preserve">
          <source>Calculates the length of a null-terminated character sequence, that is, the smallest &lt;code&gt;i&lt;/code&gt; such that &lt;code&gt;p[i]==0&lt;/code&gt;.</source>
          <target state="translated">Вычисляет длину символьной последовательности с нулевым символом в конце, то есть наименьшего &lt;code&gt;i&lt;/code&gt; , такого что &lt;code&gt;p[i]==0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cf186f04df8bd87628a780c3378dd3632fd2a3a3" translate="yes" xml:space="preserve">
          <source>Calculates the phase angle (in radians) of the complex number &lt;code&gt;z&lt;/code&gt;.</source>
          <target state="translated">Вычисляет фазовый угол (в радианах) комплексного числа &lt;code&gt;z&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="57f0569da38bf80c03db47109bd43da72eb97f7c" translate="yes" xml:space="preserve">
          <source>Calculates the smallest integral power of two that is not smaller than &lt;code&gt;x&lt;/code&gt;. If that value is not representable in &lt;code&gt;T&lt;/code&gt;, the result is unspecified.</source>
          <target state="translated">Вычисляет наименьшую интегральную степень двух, которая не меньше &lt;code&gt;x&lt;/code&gt; . Если это значение не представимо в &lt;code&gt;T&lt;/code&gt; , результат не указан.</target>
        </trans-unit>
        <trans-unit id="adab5090ac6a1b7b5420faac7be86c41721ba27c" translate="yes" xml:space="preserve">
          <source>Calendar</source>
          <target state="translated">Calendar</target>
        </trans-unit>
        <trans-unit id="77ea7aa743c8ae5ceebe6476bf7df6ad49a72839" translate="yes" xml:space="preserve">
          <source>Call once</source>
          <target state="translated">Позвонить один раз</target>
        </trans-unit>
        <trans-unit id="f4eba4ac4450eda1340606ecffb5eb5859411715" translate="yes" xml:space="preserve">
          <source>Call signature</source>
          <target state="translated">Call signature</target>
        </trans-unit>
        <trans-unit id="31298f54f958dfd787e62fd18a5dfa0ea246238e" translate="yes" xml:space="preserve">
          <source>Call to a class object</source>
          <target state="translated">Вызов объекта класса</target>
        </trans-unit>
        <trans-unit id="788d2b3c20bc6bb4acdf2e12c362e93fcf9f86e9" translate="yes" xml:space="preserve">
          <source>Call to a named function</source>
          <target state="translated">Вызов именованной функции</target>
        </trans-unit>
        <trans-unit id="25e89ac78843ab3e453d550dab696b1c2685d9c8" translate="yes" xml:space="preserve">
          <source>Call to an overloaded operator</source>
          <target state="translated">Вызов перегруженного оператора</target>
        </trans-unit>
        <trans-unit id="3b55289fd0c473d42c2d6be6391e6a9f53a24056" translate="yes" xml:space="preserve">
          <source>Callable</source>
          <target state="translated">Callable</target>
        </trans-unit>
        <trans-unit id="23d949dfc4bd360aaa190a7d8b95216e5ade27f3" translate="yes" xml:space="preserve">
          <source>Callable concepts</source>
          <target state="translated">Каллиграфические концепции</target>
        </trans-unit>
        <trans-unit id="26f12919d9abcbe806f8a77ed9eb33b55d766a0f" translate="yes" xml:space="preserve">
          <source>Calling &lt;code&gt;back&lt;/code&gt; on an empty container is undefined.</source>
          <target state="translated">Вызов &lt;code&gt;back&lt;/code&gt; на пустой контейнер не определен.</target>
        </trans-unit>
        <trans-unit id="ff2ffbf673a19e18259ea1cb76992f714681e368" translate="yes" xml:space="preserve">
          <source>Calling &lt;code&gt;back&lt;/code&gt; on an empty span results in undefined behavior.</source>
          <target state="translated">Вызов &lt;code&gt;back&lt;/code&gt; на пустом результаты пролетного в непредсказуемом поведении.</target>
        </trans-unit>
        <trans-unit id="6717d3aa8431f388fa22c83faef176dba4e916c3" translate="yes" xml:space="preserve">
          <source>Calling &lt;code&gt;front&lt;/code&gt; on an empty container is undefined.</source>
          <target state="translated">Вызов &lt;code&gt;front&lt;/code&gt; в пустом контейнере не определен.</target>
        </trans-unit>
        <trans-unit id="1b224fd770585fb9a84773057036aa9e7e6d3a7e" translate="yes" xml:space="preserve">
          <source>Calling &lt;code&gt;front&lt;/code&gt; on an empty span results in undefined behavior.</source>
          <target state="translated">Вызов &lt;code&gt;front&lt;/code&gt; на пустом промежутке приводит к неопределенному поведению.</target>
        </trans-unit>
        <trans-unit id="2c9aa3a9eae1452c28134c585eb3820a002e81bd" translate="yes" xml:space="preserve">
          <source>Calling &lt;code&gt;pop_back&lt;/code&gt; on an empty container is undefined.</source>
          <target state="translated">Вызов &lt;code&gt;pop_back&lt;/code&gt; для пустого контейнера не определен.</target>
        </trans-unit>
        <trans-unit id="3735210d481937108546f459443e5f1fd0f227c2" translate="yes" xml:space="preserve">
          <source>Calling &lt;code&gt;std::snprintf&lt;/code&gt; with zero &lt;code&gt;buf_size&lt;/code&gt; and null pointer for &lt;code&gt;buffer&lt;/code&gt; is useful to determine the necessary buffer size to contain the output:</source>
          <target state="translated">Вызов &lt;code&gt;std::snprintf&lt;/code&gt; с нулевым &lt;code&gt;buf_size&lt;/code&gt; и нулевым указателем для &lt;code&gt;buffer&lt;/code&gt; полезен для определения размера буфера, необходимого для вывода:</target>
        </trans-unit>
        <trans-unit id="8ca41836763a311e7e3b63538aadbcd41b01f43b" translate="yes" xml:space="preserve">
          <source>Calling a member function of class X on an object of any other type invokes undefined behavior.</source>
          <target state="translated">Вызов функции члена класса X на объекте любого другого типа вызывает неопределенное поведение.</target>
        </trans-unit>
        <trans-unit id="b21d6934e73f94ffe04f7672733609014752fd4f" translate="yes" xml:space="preserve">
          <source>Calling any non-const member function of a &lt;code&gt;path&lt;/code&gt; invalidates all iterators referring to elements of that object.</source>
          <target state="translated">Вызов любой неконстантной функции-члена &lt;code&gt;path&lt;/code&gt; делает недействительными все итераторы, ссылающиеся на элементы этого объекта.</target>
        </trans-unit>
        <trans-unit id="6605741078828d4b9eb94a61e28230ca57d44e38" translate="yes" xml:space="preserve">
          <source>Calling non-const member functions on the string, excluding &lt;a href=&quot;operator_at&quot;&gt;&lt;code&gt;operator[]()&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;&lt;a href=&quot;at&quot;&gt;at()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;front&quot;&gt;front()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;back&quot;&gt;back()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;begin&quot;&gt;begin()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;end&quot;&gt;end()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;rbegin&quot;&gt;rbegin()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;rend&quot;&gt;rend()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Вызов неконстантных функций-членов в строке, за исключением &lt;a href=&quot;operator_at&quot;&gt; &lt;code&gt;operator[]()&lt;/code&gt; &lt;/a&gt; , &lt;code&gt;&lt;a href=&quot;at&quot;&gt;at()&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;front&quot;&gt;front()&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;back&quot;&gt;back()&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;begin&quot;&gt;begin()&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;end&quot;&gt;end()&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;rbegin&quot;&gt;rbegin()&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;rend&quot;&gt;rend()&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bfe2bc9fc50f90ff08c540ee75e64a547ec4aa73" translate="yes" xml:space="preserve">
          <source>Calling non-const member functions on the string, excluding &lt;code&gt;&lt;a href=&quot;operator_at&quot;&gt;operator[]&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;at&quot;&gt;at()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;front&quot;&gt;front()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;back&quot;&gt;back()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;begin&quot;&gt;begin()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;rbegin&quot;&gt;rbegin()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;end&quot;&gt;end()&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;rend&quot;&gt;rend()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Вызов неконстантных функций-членов в строке, за исключением &lt;code&gt;&lt;a href=&quot;operator_at&quot;&gt;operator[]&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;at&quot;&gt;at()&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;front&quot;&gt;front()&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;back&quot;&gt;back()&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;begin&quot;&gt;begin()&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;rbegin&quot;&gt;rbegin()&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;end&quot;&gt;end()&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;rend&quot;&gt;rend()&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1590423ec88dccd74976d9c0b4a15cd539e5de0f" translate="yes" xml:space="preserve">
          <source>Calling the function from several threads does not induce a data race. The implementation shall support the registration of at least &lt;code&gt;32&lt;/code&gt; functions.</source>
          <target state="translated">Вызов функции из нескольких потоков не вызывает гонки данных. Реализация должна поддерживать регистрацию как минимум &lt;code&gt;32&lt;/code&gt; функций.</target>
        </trans-unit>
        <trans-unit id="ae706e35be31c74437d8b879378de31abca1e947" translate="yes" xml:space="preserve">
          <source>Calling this function if &lt;a href=&quot;../unique_lock/mutex&quot;&gt;&lt;code&gt;lock.mutex()&lt;/code&gt;&lt;/a&gt; is not locked by the current thread is undefined behavior.</source>
          <target state="translated">Вызов этой функции, если &lt;a href=&quot;../unique_lock/mutex&quot;&gt; &lt;code&gt;lock.mutex()&lt;/code&gt; &lt;/a&gt; не заблокирован текущим потоком, является неопределенным поведением.</target>
        </trans-unit>
        <trans-unit id="75bbd4aac5cc1d989e699d782da569785e80372d" translate="yes" xml:space="preserve">
          <source>Calling this function if &lt;a href=&quot;../unique_lock/mutex&quot;&gt;&lt;code&gt;lock.mutex()&lt;/code&gt;&lt;/a&gt; is not the same mutex as the one used by all other threads that are currently waiting on the same condition variable is undefined behavior.</source>
          <target state="translated">Вызов этой функции, если &lt;a href=&quot;../unique_lock/mutex&quot;&gt; &lt;code&gt;lock.mutex()&lt;/code&gt; &lt;/a&gt; не является тем же мьютексом, который используется всеми другими потоками, которые в данный момент ожидают ту же переменную условия, это неопределенное поведение.</target>
        </trans-unit>
        <trans-unit id="4dc1176c569db8cabf9eb9a19f697b5eace8b739" translate="yes" xml:space="preserve">
          <source>Calling this function if &lt;code&gt;lock.mutex()&lt;/code&gt; is not locked by the current thread is undefined behavior.</source>
          <target state="translated">Вызов этой функции, если &lt;code&gt;lock.mutex()&lt;/code&gt; не заблокирован текущим потоком, является неопределенным поведением.</target>
        </trans-unit>
        <trans-unit id="59ddebba5c0c5f3cf16d2db3348b2a06ea675f9c" translate="yes" xml:space="preserve">
          <source>Calling this function if &lt;code&gt;lock.mutex()&lt;/code&gt; is not the same mutex as the one used by all other threads that are currently waiting on the same condition variable is undefined behavior.</source>
          <target state="translated">Вызов этой функции, если &lt;code&gt;lock.mutex()&lt;/code&gt; не является тем же мьютексом, который используется всеми другими потоками, которые в данный момент ожидают ту же переменную условия, это неопределенное поведение.</target>
        </trans-unit>
        <trans-unit id="ca1101d4e72ebfdcdf0ad75bb31490874ef21229" translate="yes" xml:space="preserve">
          <source>Calling wait on the same &lt;code&gt;std::shared_future&lt;/code&gt; from multiple threads is not safe; the intended use is for each thread that waits on the same shared state to have a copy of a &lt;code&gt;std::shared_future&lt;/code&gt;.</source>
          <target state="translated">Вызов wait для одного и того же &lt;code&gt;std::shared_future&lt;/code&gt; из нескольких потоков не является безопасным; предполагаемое использование для каждого потока, который ожидает в том же общем состоянии, чтобы иметь копию &lt;code&gt;std::shared_future&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7fe2219fd2346b0443d87479d3d6381482c45d02" translate="yes" xml:space="preserve">
          <source>Calls &lt;a href=&quot;emit&quot;&gt;&lt;code&gt;emit()&lt;/code&gt;&lt;/a&gt; to transmit all pending output (and delayed flush, if any) to the wrapped stream. If an exception is thrown by this call, it is caught and ignored.</source>
          <target state="translated">Вызывает &lt;a href=&quot;emit&quot;&gt; &lt;code&gt;emit()&lt;/code&gt; &lt;/a&gt; для передачи всех ожидающих результатов (и отложенного сброса, если таковые имеются) в упакованный поток. Если этим вызовом генерируется исключение, оно перехватывается и игнорируется.</target>
        </trans-unit>
        <trans-unit id="e7211e6009a18f7a09fbc9ac46b8a624714b4410" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;::&lt;a href=&quot;../new/operator_delete&quot;&gt;operator delete&lt;/a&gt;(void*)&lt;/code&gt;or &lt;code&gt;::&lt;a href=&quot;../new/operator_delete&quot;&gt;operator delete&lt;/a&gt;(void*, &lt;a href=&quot;../new/align_val_t&quot;&gt;std::align_val_t&lt;/a&gt;)&lt;/code&gt;(since C++17), but it is unspecified when and how it is called.</source>
          <target state="translated">Вызывает &lt;code&gt;::&lt;a href=&quot;../new/operator_delete&quot;&gt;operator delete&lt;/a&gt;(void*)&lt;/code&gt; или &lt;code&gt;::&lt;a href=&quot;../new/operator_delete&quot;&gt;operator delete&lt;/a&gt;(void*, &lt;a href=&quot;../new/align_val_t&quot;&gt;std::align_val_t&lt;/a&gt;)&lt;/code&gt; (начиная с C ++ 17), но не указано, когда и как он вызывается.</target>
        </trans-unit>
        <trans-unit id="d77a5af1e4348b5987265920ffaec5aa8d151398" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;&lt;a href=&quot;close&quot;&gt;close()&lt;/a&gt;&lt;/code&gt; to close the associated file and destructs all other members of &lt;code&gt;basic_filebuf&lt;/code&gt;. If an exception is thrown by &lt;code&gt;&lt;a href=&quot;close&quot;&gt;close()&lt;/a&gt;&lt;/code&gt;, it is caught and not rethrown.</source>
          <target state="translated">Вызывает &lt;code&gt;&lt;a href=&quot;close&quot;&gt;close()&lt;/a&gt;&lt;/code&gt; чтобы закрыть связанный файл и уничтожает все остальные члены &lt;code&gt;basic_filebuf&lt;/code&gt; . Если исключение выдается функцией &lt;code&gt;&lt;a href=&quot;close&quot;&gt;close()&lt;/a&gt;&lt;/code&gt; , оно перехватывается и не перебрасывается.</target>
        </trans-unit>
        <trans-unit id="36548e9702a28bd62ee76fcd892dc9bc23d3cf34" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;&lt;a href=&quot;freeze&quot;&gt;freeze()&lt;/a&gt;&lt;/code&gt;, then returns a copy of start pointer of the get area, &lt;code&gt;&lt;a href=&quot;../basic_streambuf/gptr&quot;&gt;std::streambuf::eback()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Вызывает &lt;code&gt;&lt;a href=&quot;freeze&quot;&gt;freeze()&lt;/a&gt;&lt;/code&gt; , затем возвращает копию указателя начала области get, &lt;code&gt;&lt;a href=&quot;../basic_streambuf/gptr&quot;&gt;std::streambuf::eback()&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d5eeb168b574d3d4c252825f4a3753f9379de82e" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;basic_ios::swap(rhs)&lt;/code&gt; to swap all data members of the base class except for &lt;code&gt;rdbuf()&lt;/code&gt;, and swaps the values of the &lt;code&gt;gcount()&lt;/code&gt; counters between &lt;code&gt;*this&lt;/code&gt; and &lt;code&gt;rhs&lt;/code&gt;. This swap function is protected: it is called by the swap functions of the swappable input stream classes &lt;code&gt;&lt;a href=&quot;../basic_ifstream&quot;&gt;std::basic_ifstream&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../basic_istringstream&quot;&gt;std::basic_istringstream&lt;/a&gt;&lt;/code&gt;, which know how to correctly swap the associated streambuffers.</source>
          <target state="translated">Вызывает &lt;code&gt;basic_ios::swap(rhs)&lt;/code&gt; для замены всех членов данных базового класса, кроме &lt;code&gt;rdbuf()&lt;/code&gt; , и меняет значения &lt;code&gt;gcount()&lt;/code&gt; между &lt;code&gt;*this&lt;/code&gt; и &lt;code&gt;rhs&lt;/code&gt; . Эта функция подкачки защищена: она вызывается функциями подкачки классов &lt;code&gt;&lt;a href=&quot;../basic_ifstream&quot;&gt;std::basic_ifstream&lt;/a&gt;&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;../basic_istringstream&quot;&gt;std::basic_istringstream&lt;/a&gt;&lt;/code&gt; , которые могут быть заменены , std :: basic_ifstream и std :: basic_istringstream , которые знают, как правильно поменять связанные потоковые буферы.</target>
        </trans-unit>
        <trans-unit id="7ac56e091391242bbdc4ad807edc846cff28d837" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;basic_ios::swap(rhs)&lt;/code&gt; to swap all data members of the base class, except for &lt;code&gt;rdbuf()&lt;/code&gt;, between &lt;code&gt;*this&lt;/code&gt; and &lt;code&gt;rhs&lt;/code&gt;. This swap function is protected: it is called by the swap functions of the swappable output stream classes &lt;code&gt;&lt;a href=&quot;../basic_ofstream&quot;&gt;std::basic_ofstream&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../basic_ostringstream&quot;&gt;std::basic_ostringstream&lt;/a&gt;&lt;/code&gt;, which know how to correctly swap the associated streambuffers.</source>
          <target state="translated">Вызывает &lt;code&gt;basic_ios::swap(rhs)&lt;/code&gt; для замены всех членов данных базового класса, кроме &lt;code&gt;rdbuf()&lt;/code&gt; , между &lt;code&gt;*this&lt;/code&gt; и &lt;code&gt;rhs&lt;/code&gt; . Эта функция подкачки защищена: она вызывается функциями подкачки классов &lt;code&gt;&lt;a href=&quot;../basic_ofstream&quot;&gt;std::basic_ofstream&lt;/a&gt;&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;../basic_ostringstream&quot;&gt;std::basic_ostringstream&lt;/a&gt;&lt;/code&gt; , которые можно заменить, std :: basic_ofstream и std :: basic_ostringstream , которые знают, как правильно поменять связанные потоковые буферы.</target>
        </trans-unit>
        <trans-unit id="e3dc184d2193e1837c7b1ab6ae910b4a5a68b463" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;clear()&lt;/code&gt; on success.</source>
          <target state="translated">Вызывает &lt;code&gt;clear()&lt;/code&gt; в случае успеха.</target>
        </trans-unit>
        <trans-unit id="3934f9f9eebfbb559e3c31093566b7ed8b1d4ffc" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;setstate(failbit)&lt;/code&gt; on failure.</source>
          <target state="translated">Вызывает &lt;code&gt;setstate(failbit)&lt;/code&gt; при сбое.</target>
        </trans-unit>
        <trans-unit id="d2c103774ce296202589b581a39e2733fbd14eeb" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;swap&lt;/code&gt; (which might be &lt;code&gt;&lt;a href=&quot;../../algorithm/swap&quot;&gt;std::swap&lt;/a&gt;&lt;/code&gt;, or might be found via ADL) for each element in &lt;code&gt;*this&lt;/code&gt; and its corresponding element in &lt;code&gt;other&lt;/code&gt;.</source>
          <target state="translated">Вызывает &lt;code&gt;swap&lt;/code&gt; (который может быть &lt;code&gt;&lt;a href=&quot;../../algorithm/swap&quot;&gt;std::swap&lt;/a&gt;&lt;/code&gt; или может быть найден через ADL) для каждого элемента в &lt;code&gt;*this&lt;/code&gt; и его соответствующего элемента в &lt;code&gt;other&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="481431a2735414dcd8592892b784b43366935f35" translate="yes" xml:space="preserve">
          <source>Calls the &lt;a href=&quot;../../../named_req/callable&quot;&gt;Callable&lt;/a&gt; object, reference to which is stored. This function is available only if the stored reference points to a &lt;a href=&quot;../../../named_req/callable&quot;&gt;Callable&lt;/a&gt; object.</source>
          <target state="translated">Вызывает объект &lt;a href=&quot;../../../named_req/callable&quot;&gt;Callable&lt;/a&gt; , ссылка на который сохраняется. Эта функция доступна только в том случае, если сохраненные ссылки указывают на &lt;a href=&quot;../../../named_req/callable&quot;&gt;вызываемый&lt;/a&gt; объект.</target>
        </trans-unit>
        <trans-unit id="0bbf1dcddfa6e1ab86b5f404a8df59c3e805b815" translate="yes" xml:space="preserve">
          <source>Calls the appropriate extraction operator, given an rvalue reference to an input stream object (equivalent to &lt;code&gt;st &amp;gt;&amp;gt; &lt;a href=&quot;../../utility/forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;T&amp;gt;(value)&lt;/code&gt;). This function does not participate in overload resolution unless the expression &lt;code&gt;st &amp;gt;&amp;gt; &lt;a href=&quot;../../utility/forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;T&amp;gt;(value)&lt;/code&gt; is well-formed.</source>
          <target state="translated">Вызывает соответствующий оператор извлечения, учитывая rvalue ссылку на объект входного потока (эквивалентно &lt;code&gt;st &amp;gt;&amp;gt; &lt;a href=&quot;../../utility/forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;T&amp;gt;(value)&lt;/code&gt; ). Эта функция не участвует в разрешении перегрузки, если выражение &lt;code&gt;st &amp;gt;&amp;gt; &lt;a href=&quot;../../utility/forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;T&amp;gt;(value)&lt;/code&gt; является корректным.</target>
        </trans-unit>
        <trans-unit id="9c48a860ccae7d78225a13d6988e12c01b392911" translate="yes" xml:space="preserve">
          <source>Calls the appropriate extraction operator, given an rvalue reference to an input stream object (equivalent to &lt;code&gt;st &amp;gt;&amp;gt; value&lt;/code&gt;).</source>
          <target state="translated">Вызывает соответствующий оператор извлечения, учитывая rvalue ссылку на объект входного потока (эквивалентно &lt;code&gt;st &amp;gt;&amp;gt; value&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="7b5b7a129b3ced37543947e6912ecc3cecfa84d6" translate="yes" xml:space="preserve">
          <source>Calls the destructor of the object pointed to by &lt;code&gt;p&lt;/code&gt;, as if by &lt;code&gt;p-&amp;gt;~T()&lt;/code&gt;.</source>
          <target state="translated">Вызывает деструктор объекта, на который указывает &lt;code&gt;p&lt;/code&gt; , как если бы &lt;code&gt;p-&amp;gt;~T()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b405a9cd2b966c4bc34d98cc6f9f7cf4e95fe857" translate="yes" xml:space="preserve">
          <source>Calls the destructor of the object pointed to by &lt;code&gt;p&lt;/code&gt;.</source>
          <target state="translated">Вызывает деструктор объекта, на который указывает &lt;code&gt;p&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="78b1409922d2e4a9785fcea7996d5ce02b31a4ce" translate="yes" xml:space="preserve">
          <source>Calls the destructor of the object pointed to by &lt;code&gt;p&lt;/code&gt;. If possible, does so by calling &lt;code&gt;a.destroy(p)&lt;/code&gt;. If not possible (e.g. &lt;code&gt;a&lt;/code&gt; does not have the member function &lt;code&gt;destroy()&lt;/code&gt;), then calls the destructor of &lt;code&gt;*p&lt;/code&gt; directly, as &lt;code&gt;p-&amp;gt;~T()&lt;/code&gt;.</source>
          <target state="translated">Вызывает деструктор объекта, на который указывает &lt;code&gt;p&lt;/code&gt; . Если возможно, &lt;code&gt;a.destroy(p)&lt;/code&gt; это, вызвав a.destroy (p) . Если это невозможно (например, &lt;code&gt;a&lt;/code&gt; не имеет функции-члена &lt;code&gt;destroy()&lt;/code&gt; ), то вызывает деструктор &lt;code&gt;*p&lt;/code&gt; напрямую, как &lt;code&gt;p-&amp;gt;~T()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d65d02c76675e1ef2e0ab59d434954fbf4aab1b9" translate="yes" xml:space="preserve">
          <source>Calls the function named &lt;code&gt;swap()&lt;/code&gt; found by overload resolution among all functions with that name that are found by &lt;a href=&quot;../language/adl&quot;&gt;argument-dependent lookup&lt;/a&gt; and the two &lt;code&gt;&lt;a href=&quot;../algorithm/swap&quot;&gt;std::swap&lt;/a&gt;&lt;/code&gt; templates defined in the header &lt;code&gt;&amp;lt;utility&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">Вызывает функцию &lt;code&gt;swap()&lt;/code&gt; найденную с помощью разрешения перегрузки, среди всех функций с таким именем, которые находятся в &lt;a href=&quot;../language/adl&quot;&gt;зависимом&lt;/a&gt; от аргумента поиске, и двух шаблонах &lt;code&gt;&lt;a href=&quot;../algorithm/swap&quot;&gt;std::swap&lt;/a&gt;&lt;/code&gt; определенных в заголовке &lt;code&gt;&amp;lt;utility&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fb046b6586e057bb9aae9a1e6bfffa31963ec5ed" translate="yes" xml:space="preserve">
          <source>Calls the host environment's command processor (e.g. &lt;code&gt;/bin/sh&lt;/code&gt;, &lt;code&gt;cmd.exe&lt;/code&gt;, &lt;code&gt;command.com&lt;/code&gt;) with the parameter &lt;code&gt;command&lt;/code&gt;. Returns an implementation-defined value (usually the value that the invoked program returns).</source>
          <target state="translated">Вызывает командный процессор среды хоста (например, &lt;code&gt;/bin/sh&lt;/code&gt; , &lt;code&gt;cmd.exe&lt;/code&gt; , &lt;code&gt;command.com&lt;/code&gt; ) с помощью &lt;code&gt;command&lt;/code&gt; параметра . Возвращает значение, определенное реализацией (обычно значение, которое возвращает вызванная программа).</target>
        </trans-unit>
        <trans-unit id="b26b8306a6c31504edbc512428e1a837332ab1bd" translate="yes" xml:space="preserve">
          <source>Calls the stored function.</source>
          <target state="translated">Вызывает сохраненную функцию.</target>
        </trans-unit>
        <trans-unit id="afca4766bb42b40e6c34338087393e97b7c59c19" translate="yes" xml:space="preserve">
          <source>Calls the stored task with &lt;code&gt;args&lt;/code&gt; as the arguments. The return value of the task or any exceptions thrown are stored in the shared state. The shared state is made ready and any threads waiting for this are unblocked.</source>
          <target state="translated">Вызывает сохраненную задачу с &lt;code&gt;args&lt;/code&gt; в качестве аргументов. Возвращаемое значение задачи или любые сгенерированные исключения хранятся в общем состоянии. Общее состояние готово, и все потоки, ожидающие этого, разблокированы.</target>
        </trans-unit>
        <trans-unit id="dd90a8cace7a8f14fa555e29a7e7953fe85896a1" translate="yes" xml:space="preserve">
          <source>Calls the stored task with forwarded &lt;code&gt;args&lt;/code&gt; as the arguments. The return value of the task or any exception thrown by it is stored in the shared state of &lt;code&gt;*this&lt;/code&gt;.</source>
          <target state="translated">Вызывает сохраненную задачу с переданными &lt;code&gt;args&lt;/code&gt; в качестве аргументов. Возвращаемое значение задачи или любое вызванное ею исключение сохраняется в общем состоянии &lt;code&gt;*this&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0ee1a97db496e5e5a537daa1da0e2cec32168671" translate="yes" xml:space="preserve">
          <source>Calls to &lt;a href=&quot;synchronized_pool_resource/do_allocate&quot;&gt;&lt;code&gt;do_allocate&lt;/code&gt;&lt;/a&gt; are dispatched to the pool serving the smallest blocks accommodating the requested size.</source>
          <target state="translated">Вызовы &lt;a href=&quot;synchronized_pool_resource/do_allocate&quot;&gt; &lt;code&gt;do_allocate&lt;/code&gt; &lt;/a&gt; отправляются в пул, обслуживающий наименьшие блоки, отвечающие запрошенному размеру.</target>
        </trans-unit>
        <trans-unit id="40a3a9a4b8f56ea0c9cc9b74ebd031cfe3acb404" translate="yes" xml:space="preserve">
          <source>Calls to &lt;a href=&quot;unsynchronized_pool_resource/do_allocate&quot;&gt;&lt;code&gt;do_allocate&lt;/code&gt;&lt;/a&gt; are dispatched to the pool serving the smallest blocks accommodating the requested size.</source>
          <target state="translated">Вызовы &lt;a href=&quot;unsynchronized_pool_resource/do_allocate&quot;&gt; &lt;code&gt;do_allocate&lt;/code&gt; &lt;/a&gt; отправляются в пул, обслуживающий наименьшие блоки, отвечающие запрошенному размеру.</target>
        </trans-unit>
        <trans-unit id="2bc1581a9b7b77d7540b30aeb4545a58a025742b" translate="yes" xml:space="preserve">
          <source>Calls to &lt;code&gt;Allocator::allocate&lt;/code&gt; may throw.</source>
          <target state="translated">Вызовы &lt;code&gt;Allocator::allocate&lt;/code&gt; могут генерировать.</target>
        </trans-unit>
        <trans-unit id="1e921f3a7ab8c6ee7f214b9ae25dfd4e6dac7ed9" translate="yes" xml:space="preserve">
          <source>Calls to &lt;code&gt;c8rtomb&lt;/code&gt; with a null pointer argument for &lt;code&gt;s&lt;/code&gt; may introduce a data race with other calls to &lt;code&gt;c8rtomb&lt;/code&gt; with a null pointer argument for &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="translated">Вызовы &lt;code&gt;c8rtomb&lt;/code&gt; с аргументом нулевого указателя для &lt;code&gt;s&lt;/code&gt; могут привести к гонке данных с другими вызовами &lt;code&gt;c8rtomb&lt;/code&gt; с аргументом нулевого указателя для &lt;code&gt;s&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="842bfa338f91c208278bfed4b504f42e1234ae0a" translate="yes" xml:space="preserve">
          <source>Calls to const member functions of the distribution and &lt;code&gt;os &amp;lt;&amp;lt; d&lt;/code&gt; do not affect the sequence of numbers produced by repeated &lt;code&gt;d(g)&lt;/code&gt;.</source>
          <target state="translated">Вызовы константных функций-членов распределения и &lt;code&gt;os &amp;lt;&amp;lt; d&lt;/code&gt; не влияют на последовательность чисел, созданную повторным &lt;code&gt;d(g)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8f6bda6c551be6982977241156d440ef692185ef" translate="yes" xml:space="preserve">
          <source>Calls to these functions that allocate or deallocate a particular unit of storage occur in a single total order, and each such deallocation call &lt;a href=&quot;../../atomic/memory_order&quot;&gt;happens-before&lt;/a&gt; the next allocation (if any) in this order.</source>
          <target state="translated">Вызовы этих функций, которые выделяют или освобождают определенную единицу хранения, происходят в одном общем порядке, и каждый такой вызов освобождения &lt;a href=&quot;../../atomic/memory_order&quot;&gt;происходит до&lt;/a&gt; следующего выделения (если оно есть) в этом порядке.</target>
        </trans-unit>
        <trans-unit id="e7f6d16e4b3fb1f8e6d8ebfda2e4deaa82522158" translate="yes" xml:space="preserve">
          <source>Calls to this function do not introduce data races with calls to &lt;code&gt;&lt;a href=&quot;get_future&quot;&gt;get_future&lt;/a&gt;&lt;/code&gt; (but they need not synchronize with each other).</source>
          <target state="translated">Вызовы этой функции не &lt;code&gt;&lt;a href=&quot;get_future&quot;&gt;get_future&lt;/a&gt;&lt;/code&gt; к гонкам данных с вызовами get_future (но они не должны синхронизироваться друг с другом).</target>
        </trans-unit>
        <trans-unit id="0e8b087d01af0042b03fbd3b40cf94cd4b629f74" translate="yes" xml:space="preserve">
          <source>Calls to this function do not introduce data races with calls to &lt;code&gt;&lt;a href=&quot;set_value&quot;&gt;set_value&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;set_exception&quot;&gt;set_exception&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;set_value_at_thread_exit&quot;&gt;set_value_at_thread_exit&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;set_exception_at_thread_exit&quot;&gt;set_exception_at_thread_exit&lt;/a&gt;&lt;/code&gt; (but they need not synchronize with each other).</source>
          <target state="translated">Вызовы этой функции не вводят гонки данных с вызовами &lt;code&gt;&lt;a href=&quot;set_value&quot;&gt;set_value&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;set_exception&quot;&gt;set_exception&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;set_value_at_thread_exit&quot;&gt;set_value_at_thread_exit&lt;/a&gt;&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;set_exception_at_thread_exit&quot;&gt;set_exception_at_thread_exit&lt;/a&gt;&lt;/code&gt; (но они не должны синхронизироваться друг с другом).</target>
        </trans-unit>
        <trans-unit id="978f12bb4868b3da1bd6017109c32a97b6cc062a" translate="yes" xml:space="preserve">
          <source>Can be used to iterate through a single bucket</source>
          <target state="translated">Может быть использован для итераций через одно ведро</target>
        </trans-unit>
        <trans-unit id="0754caffdf7dc1f3c428a31d5458447d8f2078b5" translate="yes" xml:space="preserve">
          <source>Can be variadic as well</source>
          <target state="translated">Может быть и вариадическим</target>
        </trans-unit>
        <trans-unit id="32df764f4a004f4803750cb06a6e1038b85f5ab0" translate="yes" xml:space="preserve">
          <source>Can throw the exceptions thrown from &lt;code&gt;Alloc::allocate()&lt;/code&gt; or from the constructor of &lt;code&gt;T&lt;/code&gt;. If an exception is thrown, (1) has no effect. If an exception is thrown during the construction of the array, already-initialized elements are destroyed in reverse order(since C++20).</source>
          <target state="translated">Может бросить исключения , из &lt;code&gt;Alloc::allocate()&lt;/code&gt; или из конструктора &lt;code&gt;T&lt;/code&gt; . Если выдается исключение, (1) не имеет никакого эффекта. Если во время создания массива возникает исключение, уже инициализированные элементы уничтожаются в обратном порядке (начиная с C ++ 20).</target>
        </trans-unit>
        <trans-unit id="a4c126ec0c1d28e21fc971d14fbf29c30650c27c" translate="yes" xml:space="preserve">
          <source>Candidate functions</source>
          <target state="translated">Кандидатские функции</target>
        </trans-unit>
        <trans-unit id="3a1ea5de25db4a707e5b97c9c93167ca46913fc0" translate="yes" xml:space="preserve">
          <source>Cannot be called and thus never returns a value. The return type is &lt;code&gt;T&amp;amp;&amp;amp;&lt;/code&gt; unless &lt;code&gt;T&lt;/code&gt; is (possibly cv-qualified) &lt;code&gt;void&lt;/code&gt;, in which case the return type is &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">Невозможно вызвать и, следовательно, никогда не возвращает значение. Тип возвращаемого значения &lt;code&gt;T&amp;amp;&amp;amp;&lt;/code&gt; , если &lt;code&gt;T&lt;/code&gt; не является (возможно , резюме квалифицированных) &lt;code&gt;void&lt;/code&gt; , и в этом случае тип возвращаемого значения &lt;code&gt;T&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a47709738a13682382a8bb47d1c3c176fb6cf434" translate="yes" xml:space="preserve">
          <source>Canonical implementations</source>
          <target state="translated">канонические внедрения</target>
        </trans-unit>
        <trans-unit id="ca09c54bff74a82bae543ebe259f7452ee8c5293" translate="yes" xml:space="preserve">
          <source>Capabilities</source>
          <target state="translated">Capabilities</target>
        </trans-unit>
        <trans-unit id="45bd908df490edd79694ba0daff82fc092970b55" translate="yes" xml:space="preserve">
          <source>Capacity</source>
          <target state="translated">Capacity</target>
        </trans-unit>
        <trans-unit id="8c8a5e126ef7ec6a6ad77d0edf96fa8a146e07ff" translate="yes" xml:space="preserve">
          <source>Capacity of the currently allocated storage.</source>
          <target state="translated">Емкость выделенного в настоящее время хранилища.</target>
        </trans-unit>
        <trans-unit id="b17823bc1728ea261d27feb54556ae24540f0e72" translate="yes" xml:space="preserve">
          <source>Capture and storage of exception objects</source>
          <target state="translated">Съемка и хранение объектов исключений</target>
        </trans-unit>
        <trans-unit id="dc6500dd683ae5c40011f02be84c903248d14d1b" translate="yes" xml:space="preserve">
          <source>Capturing the result of &lt;code&gt;std::clamp&lt;/code&gt; by reference if one of the parameters is rvalue produces a dangling reference if that parameter is returned:</source>
          <target state="translated">Захват результата &lt;code&gt;std::clamp&lt;/code&gt; по ссылке, если одним из параметров является значение rvalue, приводит к зависанию ссылки, если этот параметр возвращается:</target>
        </trans-unit>
        <trans-unit id="f412180178dea3bf686bb7206b2a1c6f412f169f" translate="yes" xml:space="preserve">
          <source>Capturing the result of &lt;code&gt;std::max&lt;/code&gt; by reference if one of the parameters is rvalue produces a dangling reference if that parameter is returned:</source>
          <target state="translated">Захват результата &lt;code&gt;std::max&lt;/code&gt; по ссылке, если одним из параметров является rvalue, приводит к зависанию ссылки, если этот параметр возвращается:</target>
        </trans-unit>
        <trans-unit id="37013b98a907be74378196d00c40398eaed52529" translate="yes" xml:space="preserve">
          <source>Capturing the result of &lt;code&gt;std::min&lt;/code&gt; by reference if one of the parameters is rvalue produces a dangling reference if that parameter is returned:</source>
          <target state="translated">Захват результата &lt;code&gt;std::min&lt;/code&gt; по ссылке, если одним из параметров является rvalue, приводит к зависанию ссылки, если этот параметр возвращается:</target>
        </trans-unit>
        <trans-unit id="aeac558c74f367c4d77b33a3b991b9293571a506" translate="yes" xml:space="preserve">
          <source>Care should be taken when using &lt;code&gt;enable_if&lt;/code&gt; in the type of a template non-type parameter of a namespace-scope function template. Some ABI specifications like the Itanium ABI do not include the instantiation-dependent portions of non-type template parameters in the mangling, meaning that specializations of two distinct function templates might end up with the same mangled name and be erroneously linked together. For example:</source>
          <target state="translated">Следует проявлять осторожность при использовании &lt;code&gt;enable_if&lt;/code&gt; в типе параметра типа non-type шаблона функции пространства имен. Некоторые спецификации ABI, такие как Itanium ABI, не включают в себя зависящие от экземпляров части нетипичных параметров шаблонов в календаре, что означает, что специализации двух разных шаблонов функций могут заканчиваться одним и тем же искаженным именем и быть ошибочно связаны друг с другом. Например:</target>
        </trans-unit>
        <trans-unit id="bbfb9c69143915569ecc52059ab10ea7a1d14360" translate="yes" xml:space="preserve">
          <source>Careful use of &lt;code&gt;emplace&lt;/code&gt; allows the new element to be constructed while avoiding unnecessary copy or move operations. The constructor of the new element (i.e. &lt;code&gt;&lt;a href=&quot;../../utility/pair&quot;&gt;std::pair&lt;/a&gt;&amp;lt;const Key, T&amp;gt;&lt;/code&gt;) is called with exactly the same arguments as supplied to &lt;code&gt;emplace&lt;/code&gt;, forwarded via &lt;code&gt;&lt;a href=&quot;../../utility/forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;Args&amp;gt;(args)...&lt;/code&gt;.</source>
          <target state="translated">Тщательное использование &lt;code&gt;emplace&lt;/code&gt; позволяет создавать новый элемент, избегая ненужных операций копирования или перемещения. Конструктор нового элемента (т.е. &lt;code&gt;&lt;a href=&quot;../../utility/pair&quot;&gt;std::pair&lt;/a&gt;&amp;lt;const Key, T&amp;gt;&lt;/code&gt; ) вызывается с точно такими же рассуждениями, поставляемыми &lt;code&gt;emplace&lt;/code&gt; , пересылаемые через &lt;code&gt;&lt;a href=&quot;../../utility/forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;Args&amp;gt;(args)...&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="52b9bfebd40c006ea3917327fed74d66704c9687" translate="yes" xml:space="preserve">
          <source>Careful use of &lt;code&gt;emplace&lt;/code&gt; allows the new element to be constructed while avoiding unnecessary copy or move operations. The constructor of the new element (i.e. &lt;code&gt;&lt;a href=&quot;../../utility/pair&quot;&gt;std::pair&lt;/a&gt;&amp;lt;const Key, T&amp;gt;&lt;/code&gt;) is called with exactly the same arguments as supplied to &lt;code&gt;emplace&lt;/code&gt;, forwarded via &lt;code&gt;&lt;a href=&quot;../../utility/forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;Args&amp;gt;(args)...&lt;/code&gt;. The element may be constructed even if there already is an element with the key in the container, in which case the newly constructed element will be destroyed immediately.</source>
          <target state="translated">Тщательное использование &lt;code&gt;emplace&lt;/code&gt; позволяет создавать новый элемент, избегая ненужных операций копирования или перемещения. Конструктор нового элемента (т.е. &lt;code&gt;&lt;a href=&quot;../../utility/pair&quot;&gt;std::pair&lt;/a&gt;&amp;lt;const Key, T&amp;gt;&lt;/code&gt; ) вызывается с точно такими же рассуждениями, поставляемыми &lt;code&gt;emplace&lt;/code&gt; , пересылаемые через &lt;code&gt;&lt;a href=&quot;../../utility/forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;Args&amp;gt;(args)...&lt;/code&gt; . Элемент может быть создан, даже если в контейнере уже есть элемент с ключом, и в этом случае вновь созданный элемент будет немедленно уничтожен.</target>
        </trans-unit>
        <trans-unit id="4714de10bb9278addf37bd8e9cf61fba91ba9335" translate="yes" xml:space="preserve">
          <source>Careful use of &lt;code&gt;emplace&lt;/code&gt; allows the new element to be constructed while avoiding unnecessary copy or move operations. The constructor of the new element is called with exactly the same arguments as supplied to &lt;code&gt;emplace&lt;/code&gt;, forwarded via &lt;code&gt;&lt;a href=&quot;../../utility/forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;Args&amp;gt;(args)...&lt;/code&gt;.</source>
          <target state="translated">Тщательное использование &lt;code&gt;emplace&lt;/code&gt; позволяет создавать новый элемент, избегая ненужных операций копирования или перемещения. Конструктор нового элемента вызываются с точно такими же рассуждениями, поставляемыми &lt;code&gt;emplace&lt;/code&gt; , пересылаемые через &lt;code&gt;&lt;a href=&quot;../../utility/forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;Args&amp;gt;(args)...&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3d62f1320fbf353fbac4ea498ae530ee45805f5d" translate="yes" xml:space="preserve">
          <source>Careful use of &lt;code&gt;emplace&lt;/code&gt; allows the new element to be constructed while avoiding unnecessary copy or move operations. The constructor of the new element is called with exactly the same arguments as supplied to &lt;code&gt;emplace&lt;/code&gt;, forwarded via &lt;code&gt;&lt;a href=&quot;../../utility/forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;Args&amp;gt;(args)...&lt;/code&gt;. The element may be constructed even if there already is an element with the key in the container, in which case the newly constructed element will be destroyed immediately.</source>
          <target state="translated">Тщательное использование &lt;code&gt;emplace&lt;/code&gt; позволяет создавать новый элемент, избегая ненужных операций копирования или перемещения. Конструктор нового элемента вызываются с точно такими же рассуждениями, поставляемыми &lt;code&gt;emplace&lt;/code&gt; , пересылаемые через &lt;code&gt;&lt;a href=&quot;../../utility/forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;Args&amp;gt;(args)...&lt;/code&gt; . Элемент может быть создан, даже если в контейнере уже есть элемент с ключом, и в этом случае вновь созданный элемент будет немедленно уничтожен.</target>
        </trans-unit>
        <trans-unit id="9ba8ece0eb57ce634431d006ebb786d69e1c0fb8" translate="yes" xml:space="preserve">
          <source>Carries dependency</source>
          <target state="translated">Зависимость от грузоперевозок</target>
        </trans-unit>
        <trans-unit id="349f4b2217e91ab2d1ba3827cff21266a8c0e7bc" translate="yes" xml:space="preserve">
          <source>Case 1: binding an array</source>
          <target state="translated">Случай 1:связывание массива</target>
        </trans-unit>
        <trans-unit id="56f64fdbefc9674a22cdd908d97b4da3d5e9aac5" translate="yes" xml:space="preserve">
          <source>Case 1: if &lt;code&gt;&lt;i&gt;E&lt;/i&gt;&lt;/code&gt; is an array type, then the names are bound to the array elements.</source>
          <target state="translated">Случай 1: если &lt;code&gt;&lt;i&gt;E&lt;/i&gt;&lt;/code&gt; является типом массива, то имена привязываются к элементам массива.</target>
        </trans-unit>
        <trans-unit id="8fc50ba85c9e0bf4533570a0c18a73541e34b19c" translate="yes" xml:space="preserve">
          <source>Case 2: binding a tuple-like type</source>
          <target state="translated">Дело 2:связывание кортежа типа &quot;кортеж&quot;.</target>
        </trans-unit>
        <trans-unit id="a28b6bd53fab5c5518781c66d9367f259e8a1a8b" translate="yes" xml:space="preserve">
          <source>Case 2: if &lt;code&gt;&lt;i&gt;E&lt;/i&gt;&lt;/code&gt; is a non-union class type and &lt;code&gt;&lt;a href=&quot;../utility/tuple/tuple_size&quot;&gt;std::tuple_size&lt;/a&gt;&amp;lt;E&amp;gt;&lt;/code&gt; is a complete type, then the &quot;tuple-like&quot; binding protocol is used.</source>
          <target state="translated">Случай 2: если &lt;code&gt;&lt;i&gt;E&lt;/i&gt;&lt;/code&gt; является типом класса, не являющимся объединением, а &lt;code&gt;&lt;a href=&quot;../utility/tuple/tuple_size&quot;&gt;std::tuple_size&lt;/a&gt;&amp;lt;E&amp;gt;&lt;/code&gt; является полным типом, то используется протокол связывания типа &amp;laquo;кортеж&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="511322fb92a18ad6c803db32b44850aa3b21431d" translate="yes" xml:space="preserve">
          <source>Case 3: binding to data members</source>
          <target state="translated">Случай 3:привязка к членам данных</target>
        </trans-unit>
        <trans-unit id="d6570c00b51cbb8acf7b8685b39e65082f79bd7f" translate="yes" xml:space="preserve">
          <source>Case 3: if &lt;code&gt;&lt;i&gt;E&lt;/i&gt;&lt;/code&gt; is a non-union class type but &lt;code&gt;&lt;a href=&quot;../utility/tuple/tuple_size&quot;&gt;std::tuple_size&lt;/a&gt;&amp;lt;E&amp;gt;&lt;/code&gt; is not a complete type, then the names are bound to the accessible data members of &lt;code&gt;&lt;i&gt;E&lt;/i&gt;&lt;/code&gt;.</source>
          <target state="translated">Случай 3: если &lt;code&gt;&lt;i&gt;E&lt;/i&gt;&lt;/code&gt; является тип класса , не союз , но &lt;code&gt;&lt;a href=&quot;../utility/tuple/tuple_size&quot;&gt;std::tuple_size&lt;/a&gt;&amp;lt;E&amp;gt;&lt;/code&gt; не полный тип, то имена связаны с доступными членами данных &lt;code&gt;&lt;i&gt;E&lt;/i&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="74473f63620ac45f2911b86a7f11c6501a7660cd" translate="yes" xml:space="preserve">
          <source>Cast and assignment strip away any extraneous range and precision: this models the action of storing a value from an extended-precision FPU register into a standard-sized memory location.</source>
          <target state="translated">Отливка и присвоение полосы прочь от любого постороннего диапазона и точности:это моделирует действие хранения значения из расширенного регистра FPU с высокой точностью в ячейку памяти стандартного размера.</target>
        </trans-unit>
        <trans-unit id="8107a9770cf1c808e1686a8e8b7cced06eac8bfc" translate="yes" xml:space="preserve">
          <source>Casting between integer durations where the source period is exactly divisible by the target period (e.g. hours to minutes) or between floating-point durations can be performed with ordinary casts or implicitly via &lt;a href=&quot;duration&quot;&gt;std::chrono::duration constructors&lt;/a&gt;, no &lt;code&gt;duration_cast&lt;/code&gt; is needed.</source>
          <target state="translated">Приведение между целочисленными длительностями, когда исходный период точно делится на целевой период (например, часы в минуты) или между длительностями с плавающей запятой, может быть выполнено с обычными приведениями или неявно с помощью конструкторов &lt;a href=&quot;duration&quot;&gt;std :: chrono :: duration&lt;/a&gt; , не требуется никакая &lt;code&gt;duration_cast&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6f784c0dfdd40d5aecdcc755d6d0d02557b2aa7e" translate="yes" xml:space="preserve">
          <source>Casting from a floating-point duration to an integer duration is &lt;a href=&quot;../../language/implicit_cast#Floating_-_integral_conversions&quot;&gt;subject to undefined behavior&lt;/a&gt; when the floating-point value is NaN, infinity, or too large to be representable by the target's integer type. Otherwise, casting to an integer duration is subject to truncation as with any static_cast to an integer type.</source>
          <target state="translated">Преобразование из длительности с плавающей запятой в целочисленную длительность &lt;a href=&quot;../../language/implicit_cast#Floating_-_integral_conversions&quot;&gt;подчиняется неопределенному поведению,&lt;/a&gt; когда значение с плавающей запятой равно NaN, бесконечности или слишком велико, чтобы его можно было представить целочисленным типом цели. В противном случае приведение к целочисленной продолжительности подлежит усечению, как и для любого static_cast целочисленного типа.</target>
        </trans-unit>
        <trans-unit id="d1bd210bf015301c8468da6b036f05fe262ff0f0" translate="yes" xml:space="preserve">
          <source>Catch clause of a function-try block</source>
          <target state="translated">Клавиша &quot;поймать&quot; функционального блока</target>
        </trans-unit>
        <trans-unit id="a3c686e711e4720f99b4562bb3dbaae7ab658cf2" translate="yes" xml:space="preserve">
          <source>Category</source>
          <target state="translated">Category</target>
        </trans-unit>
        <trans-unit id="8610c7e6c1a1322fdf2ebc74043f66b624b393a8" translate="yes" xml:space="preserve">
          <source>Causes abnormal program termination unless &lt;code&gt;&lt;a href=&quot;sig_types&quot;&gt;SIGABRT&lt;/a&gt;&lt;/code&gt; is being caught by a signal handler passed to &lt;code&gt;&lt;a href=&quot;signal&quot;&gt;std::signal&lt;/a&gt;&lt;/code&gt; and the handler does not return.</source>
          <target state="translated">Вызывает ненормальное завершение программы, если обработчик сигнала не перехватывает &lt;code&gt;&lt;a href=&quot;sig_types&quot;&gt;SIGABRT&lt;/a&gt;&lt;/code&gt; , передаваемый в &lt;code&gt;&lt;a href=&quot;signal&quot;&gt;std::signal&lt;/a&gt;&lt;/code&gt; и обработчик не возвращает.</target>
        </trans-unit>
        <trans-unit id="a5fc98a179eaefefc7383473561adf59469b047c" translate="yes" xml:space="preserve">
          <source>Causes normal program termination to occur without completely cleaning the resources.</source>
          <target state="translated">Причиняет нормальное завершение программы без полной очистки ресурсов.</target>
        </trans-unit>
        <trans-unit id="03d84237d77c18a1ea9454f00c0d5a2c4def6e6a" translate="yes" xml:space="preserve">
          <source>Causes normal program termination to occur.</source>
          <target state="translated">Причиняет нормальное завершение программы.</target>
        </trans-unit>
        <trans-unit id="e1f612c1cf7abef4418592e6cc6efbf397106128" translate="yes" xml:space="preserve">
          <source>Causes reallocation if the new &lt;code&gt;&lt;a href=&quot;size&quot;&gt;size()&lt;/a&gt;&lt;/code&gt; is greater than the old &lt;code&gt;&lt;a href=&quot;capacity&quot;&gt;capacity()&lt;/a&gt;&lt;/code&gt;. If the new &lt;code&gt;&lt;a href=&quot;size&quot;&gt;size()&lt;/a&gt;&lt;/code&gt; is greater than &lt;code&gt;&lt;a href=&quot;capacity&quot;&gt;capacity()&lt;/a&gt;&lt;/code&gt;, all iterators and references are invalidated. Otherwise, only the iterators and references before the insertion point remain valid. The past-the-end iterator is also invalidated.</source>
          <target state="translated">Вызывает перераспределение, если новый &lt;code&gt;&lt;a href=&quot;size&quot;&gt;size()&lt;/a&gt;&lt;/code&gt; больше, чем старая &lt;code&gt;&lt;a href=&quot;capacity&quot;&gt;capacity()&lt;/a&gt;&lt;/code&gt; . Если новый &lt;code&gt;&lt;a href=&quot;size&quot;&gt;size()&lt;/a&gt;&lt;/code&gt; больше &lt;code&gt;&lt;a href=&quot;capacity&quot;&gt;capacity()&lt;/a&gt;&lt;/code&gt; , все итераторы и ссылки становятся недействительными. Иначе, только итераторы и ссылки перед точкой вставки остаются действительными. Последний итератор также становится недействительным.</target>
        </trans-unit>
        <trans-unit id="1b3b922a89d7fd2178e02a2f975053d39cd95e01" translate="yes" xml:space="preserve">
          <source>Causes the enclosing &lt;a href=&quot;for&quot;&gt;for&lt;/a&gt;, &lt;a href=&quot;range-for&quot;&gt;range-for&lt;/a&gt;, &lt;a href=&quot;while&quot;&gt;while&lt;/a&gt; or &lt;a href=&quot;do&quot;&gt;do-while&lt;/a&gt; loop or &lt;a href=&quot;switch&quot;&gt; switch statement&lt;/a&gt; to terminate.</source>
          <target state="translated">Вызывает заключающий &lt;a href=&quot;for&quot;&gt;для&lt;/a&gt; , &lt;a href=&quot;range-for&quot;&gt;диапазона для&lt;/a&gt; , в &lt;a href=&quot;while&quot;&gt;то время&lt;/a&gt; или &lt;a href=&quot;do&quot;&gt;же, в то время как&lt;/a&gt; петля или &lt;a href=&quot;switch&quot;&gt;переключатель заявление&lt;/a&gt; прекратить.</target>
        </trans-unit>
        <trans-unit id="c910b43d8c16258ce3d66377f217e9ecf4da3d0f" translate="yes" xml:space="preserve">
          <source>Causes the remaining portion of the enclosing &lt;a href=&quot;for&quot;&gt;for&lt;/a&gt;, &lt;a href=&quot;range-for&quot;&gt;range-for&lt;/a&gt;, &lt;a href=&quot;while&quot;&gt;while&lt;/a&gt; or &lt;a href=&quot;do&quot;&gt; do-while&lt;/a&gt; loop body to be skipped.</source>
          <target state="translated">Причины оставшейся части ограждающего &lt;a href=&quot;for&quot;&gt;для&lt;/a&gt; , &lt;a href=&quot;range-for&quot;&gt;диапазона для&lt;/a&gt; , в &lt;a href=&quot;while&quot;&gt;то время&lt;/a&gt; или &lt;a href=&quot;do&quot;&gt;делать-то время как&lt;/a&gt; тело цикла будет пропущено.</target>
        </trans-unit>
        <trans-unit id="e2cc09c65ee94e9da20a5da53ff7a1764aa2d212" translate="yes" xml:space="preserve">
          <source>Certain &lt;a href=&quot;operator_arithmetic#Additive_operators&quot;&gt;addition, subtraction&lt;/a&gt;, &lt;a href=&quot;operator_incdec&quot;&gt;increment, and decrement&lt;/a&gt; operators are defined for pointers to elements of arrays: such pointers satisfy the &lt;a href=&quot;../named_req/randomaccessiterator&quot;&gt;LegacyRandomAccessIterator&lt;/a&gt; requirements and allow the C++ library &lt;a href=&quot;../algorithm&quot;&gt;algorithms&lt;/a&gt; to work with raw arrays.</source>
          <target state="translated">Определенные операторы &lt;a href=&quot;operator_arithmetic#Additive_operators&quot;&gt;сложения, вычитания&lt;/a&gt; , &lt;a href=&quot;operator_incdec&quot;&gt;увеличения и уменьшения&lt;/a&gt; определены для указателей на элементы массивов: такие указатели удовлетворяют требованиям &lt;a href=&quot;../named_req/randomaccessiterator&quot;&gt;LegacyRandomAccessIterator&lt;/a&gt; и позволяют &lt;a href=&quot;../algorithm&quot;&gt;алгоритмам&lt;/a&gt; библиотеки C ++ работать с необработанными массивами.</target>
        </trans-unit>
        <trans-unit id="16ced4992002374e1ee48c60ab57aa3dd53629bb" translate="yes" xml:space="preserve">
          <source>Certain words in a C++ program have special meaning, and these are known as &lt;a href=&quot;../keywords&quot;&gt;keywords&lt;/a&gt;. Others can be used as &lt;a href=&quot;name&quot;&gt;identifiers&lt;/a&gt;. &lt;a href=&quot;../comments&quot;&gt;Comments&lt;/a&gt; are ignored during translation. Certain characters in the program have to be represented with &lt;a href=&quot;escape&quot;&gt;escape sequences&lt;/a&gt;.</source>
          <target state="translated">Определенные слова в программе на C ++ имеют особое значение, и они называются &lt;a href=&quot;../keywords&quot;&gt;ключевыми словами&lt;/a&gt; . Другие могут быть использованы в качестве &lt;a href=&quot;name&quot;&gt;идентификаторов&lt;/a&gt; . &lt;a href=&quot;../comments&quot;&gt;Комментарии&lt;/a&gt; игнорируются при переводе. Определенные символы в программе должны быть представлены &lt;a href=&quot;escape&quot;&gt;escape-последовательностями&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="191f1780427cc9f433fedbcd960fd714be286f24" translate="yes" xml:space="preserve">
          <source>Change the return type of the &lt;code&gt;&lt;a href=&quot;container/list/remove&quot;&gt;remove()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;container/list/remove&quot;&gt;remove_if()&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;container/list/unique&quot;&gt;unique()&lt;/a&gt;&lt;/code&gt; members of &lt;code&gt;&lt;a href=&quot;container/forward_list&quot;&gt;std::forward_list&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;container/list&quot;&gt;std::list&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">Измените тип возвращаемого значения элементов &lt;code&gt;&lt;a href=&quot;container/list/remove&quot;&gt;remove()&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;container/list/remove&quot;&gt;remove_if()&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;container/list/unique&quot;&gt;unique()&lt;/a&gt;&lt;/code&gt; в &lt;code&gt;&lt;a href=&quot;container/forward_list&quot;&gt;std::forward_list&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;container/list&quot;&gt;std::list&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a51058c46332744397288d2669e24ba920dc2025" translate="yes" xml:space="preserve">
          <source>Changes access permissions of the file to which &lt;code&gt;p&lt;/code&gt; resolves, as if by POSIX &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/fchmodat.html&quot;&gt;fchmodat&lt;/a&gt;. Symlinks are followed unless &lt;code&gt;perm_options::nofollow&lt;/code&gt; is set in &lt;code&gt;opts&lt;/code&gt;.</source>
          <target state="translated">Изменяет права доступа к файлу, к которому разрешает &lt;code&gt;p&lt;/code&gt; , как если бы POSIX &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/fchmodat.html&quot;&gt;fchmodat&lt;/a&gt; . Символьные ссылки следуют, если &lt;code&gt;perm_options::nofollow&lt;/code&gt; не установлен в &lt;code&gt;opts&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="40368d132c05a81e3cd862a506ed5beaadcc50be" translate="yes" xml:space="preserve">
          <source>Changes access permissions of the file to which &lt;code&gt;p&lt;/code&gt; resolves, as if by POSIX &lt;a href=&quot;https://pubs.opengroup.org/onlinepubs/9699919799/functions/fchmodat.html&quot;&gt;fchmodat&lt;/a&gt;. Symlinks are followed unless &lt;code&gt;perm_options::nofollow&lt;/code&gt; is set in &lt;code&gt;opts&lt;/code&gt;.</source>
          <target state="translated">Изменяет права доступа к файлу, в который разрешается &lt;code&gt;p&lt;/code&gt; , как если бы это был POSIX &lt;a href=&quot;https://pubs.opengroup.org/onlinepubs/9699919799/functions/fchmodat.html&quot;&gt;fchmodat&lt;/a&gt; . Символьные ссылки используются, если &lt;code&gt;perm_options::nofollow&lt;/code&gt; не установлен в &lt;code&gt;opts&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d059f7f607e7b98754449b95b9c9f18d224be17e" translate="yes" xml:space="preserve">
          <source>Changes the associated locale so that all characters inserted or extracted after this call (and until another call to &lt;code&gt;imbue()&lt;/code&gt;) are converted using the &lt;code&gt;&lt;a href=&quot;../../locale/codecvt&quot;&gt;std::codecvt&lt;/a&gt;&lt;/code&gt; facet of &lt;code&gt;loc&lt;/code&gt;.</source>
          <target state="translated">Изменяет связанный языковой стандарт, чтобы все символы, вставленные или извлеченные после этого вызова (и до следующего вызова &lt;code&gt;imbue()&lt;/code&gt; ), были преобразованы с использованием фасета &lt;code&gt;&lt;a href=&quot;../../locale/codecvt&quot;&gt;std::codecvt&lt;/a&gt;&lt;/code&gt; для &lt;code&gt;loc&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="59519c86c11d2513037e609c3becf73e19a3102f" translate="yes" xml:space="preserve">
          <source>Changes the associated locale.</source>
          <target state="translated">Изменяет связанную с этим местность.</target>
        </trans-unit>
        <trans-unit id="e1931e70aa0ae325fe795a9e9d024fe1264be193" translate="yes" xml:space="preserve">
          <source>Changes the contained object to one of type &lt;code&gt;&lt;a href=&quot;../../types/decay&quot;&gt;std::decay_t&lt;/a&gt;&amp;lt;ValueType&amp;gt;&lt;/code&gt; constructed from the arguments.</source>
          <target state="translated">Изменяет содержащийся объект на один из типов &lt;code&gt;&lt;a href=&quot;../../types/decay&quot;&gt;std::decay_t&lt;/a&gt;&amp;lt;ValueType&amp;gt;&lt;/code&gt; из аргументов.</target>
        </trans-unit>
        <trans-unit id="7260987e96fdc55dd04ca01a135da1cbdd6808b1" translate="yes" xml:space="preserve">
          <source>Changes the current emit-on-sync policy.</source>
          <target state="translated">Изменяет текущую политику &quot;излучение-на-синхроне&quot;.</target>
        </trans-unit>
        <trans-unit id="900063105ed808c1839aeda96993e8913c65dcff" translate="yes" xml:space="preserve">
          <source>Changes the current file name and number in the preprocessor.</source>
          <target state="translated">Изменяет имя и номер текущего файла в препроцессоре.</target>
        </trans-unit>
        <trans-unit id="bcd3bc7bc25f117f48576a1067f3eab87dc09962" translate="yes" xml:space="preserve">
          <source>Changes the filename of a file. The file is identified by character string pointed to by &lt;code&gt;old_filename&lt;/code&gt;. The new filename is identified by character string pointed to by &lt;code&gt;new_filename&lt;/code&gt;.</source>
          <target state="translated">Изменяет имя файла файла. Файл идентифицируется символьной строкой, на которую указывает &lt;code&gt;old_filename&lt;/code&gt; . Новое имя файла идентифицируется символьной строкой, на которую указывает &lt;code&gt;new_filename&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a983560b5611c7eaf3bbb1134baa772fadd17a2a" translate="yes" xml:space="preserve">
          <source>Changes the filename of the directory entry.</source>
          <target state="translated">Изменяет имя файла записи записной книжки.</target>
        </trans-unit>
        <trans-unit id="15ca90f2bd5d157747f2bcfd7fd13098d9365990" translate="yes" xml:space="preserve">
          <source>Changes the output format.</source>
          <target state="translated">Изменение формата вывода.</target>
        </trans-unit>
        <trans-unit id="028cce033fce6f33e2a026dffc3790dff3f7ae1a" translate="yes" xml:space="preserve">
          <source>Changes the size of the regular file named by &lt;code&gt;p&lt;/code&gt; as if by POSIX &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/truncate.html&quot;&gt;truncate&lt;/a&gt;: if the file size was previously larger than &lt;code&gt;new_size&lt;/code&gt;, the remainder of the file is discarded. If the file was previously smaller than &lt;code&gt;new_size&lt;/code&gt;, the file size is increased and the new area appears as if zero-filled.</source>
          <target state="translated">Изменение размера обычного файла , названного &lt;code&gt;p&lt;/code&gt; , как по POSIX &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/truncate.html&quot;&gt;срезанным&lt;/a&gt; : если размер файла был больше , чем ранее &lt;code&gt;new_size&lt;/code&gt; , остальная часть файла отбрасывается. Если файл ранее был меньше, чем &lt;code&gt;new_size&lt;/code&gt; , размер файла увеличивается, и новая область выглядит как заполненная нулями.</target>
        </trans-unit>
        <trans-unit id="2f316517a8bf4ef3b0724ffad3626c592c26ce51" translate="yes" xml:space="preserve">
          <source>Changes the size of the regular file named by &lt;code&gt;p&lt;/code&gt; as if by POSIX &lt;a href=&quot;https://pubs.opengroup.org/onlinepubs/9699919799/functions/truncate.html&quot;&gt;truncate&lt;/a&gt;: if the file size was previously larger than &lt;code&gt;new_size&lt;/code&gt;, the remainder of the file is discarded. If the file was previously smaller than &lt;code&gt;new_size&lt;/code&gt;, the file size is increased and the new area appears as if zero-filled.</source>
          <target state="translated">Изменяет размер обычного файла с именем &lt;code&gt;p&lt;/code&gt; , как если бы он был &lt;a href=&quot;https://pubs.opengroup.org/onlinepubs/9699919799/functions/truncate.html&quot;&gt;усечен&lt;/a&gt; POSIX : если размер файла ранее был больше, чем &lt;code&gt;new_size&lt;/code&gt; , оставшаяся часть файла отбрасывается. Если файл ранее был меньше, чем &lt;code&gt;new_size&lt;/code&gt; , размер файла увеличивается, и новая область выглядит как заполненная нулями.</target>
        </trans-unit>
        <trans-unit id="9f1702f311546e930d8f583ff60c5b7dafb56f91" translate="yes" xml:space="preserve">
          <source>Changes the the buffering mode of the given file stream &lt;code&gt;stream&lt;/code&gt; as indicated by the argument &lt;code&gt;mode&lt;/code&gt;. In addition,</source>
          <target state="translated">Изменяет режим буферизации данного потока файлового &lt;code&gt;stream&lt;/code&gt; как указано в &lt;code&gt;mode&lt;/code&gt; аргумента . К тому же,</target>
        </trans-unit>
        <trans-unit id="db66637e4bd602383b9a36e093d02ad744d50d19" translate="yes" xml:space="preserve">
          <source>CharT</source>
          <target state="translated">CharT</target>
        </trans-unit>
        <trans-unit id="075d1aa22da1d1a791ea28f036dd3029899ef7df" translate="yes" xml:space="preserve">
          <source>CharTarray&lt;code&gt;[&lt;/code&gt;n&lt;code&gt;]&lt;/code&gt;&lt;code&gt;= &quot;&quot;;&lt;/code&gt;</source>
          <target state="translated">CharTarray &lt;code&gt;[&lt;/code&gt; n &lt;code&gt;]&lt;/code&gt; &lt;code&gt;= &quot;&quot;;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3a40d3a3e7cab1d5912b21bb9180e2c135f3d1b0" translate="yes" xml:space="preserve">
          <source>CharTraits</source>
          <target state="translated">CharTraits</target>
        </trans-unit>
        <trans-unit id="ea0427dd5d6f2fd22fb387a84f007ebffee5c102" translate="yes" xml:space="preserve">
          <source>CharTraits is required by the following standard library class templates as a template type parameter:</source>
          <target state="translated">CharTraits в качестве параметра типа шаблона требуются следующие стандартные шаблоны классов библиотеки:</target>
        </trans-unit>
        <trans-unit id="0f52782a792cc00d2892c8162c4d20455ac882bd" translate="yes" xml:space="preserve">
          <source>CharTraits is satisfied by the following standard library classes:</source>
          <target state="translated">CharTraits удовлетворен следующими стандартными библиотечными классами:</target>
        </trans-unit>
        <trans-unit id="ee9946c82d4a077c5be79e3015a3d2479d9fcaf2" translate="yes" xml:space="preserve">
          <source>Character</source>
          <target state="translated">Character</target>
        </trans-unit>
        <trans-unit id="f72882235ad60f37016237d8303fb8c1162e42f0" translate="yes" xml:space="preserve">
          <source>Character and character string arguments (e.g., of type &lt;code&gt;char&lt;/code&gt; or &lt;code&gt;const char*&lt;/code&gt;) are handled by the &lt;a href=&quot;operator_ltlt2&quot;&gt;non-member overloads&lt;/a&gt; of &lt;code&gt;operator&amp;lt;&amp;lt;&lt;/code&gt;. Attempting to output a character using the member function call syntax (e.g., &lt;code&gt;&lt;a href=&quot;../cout&quot;&gt;std::cout&lt;/a&gt;.operator&amp;lt;&amp;lt;('c');&lt;/code&gt;) will call one of overloads (2-4) and output the numerical value. Attempting to output a character string using the member function call syntax will call overload (7) and print the pointer value instead.</source>
          <target state="translated">Аргументы символов и символов строк (например, типа &lt;code&gt;char&lt;/code&gt; или &lt;code&gt;const char*&lt;/code&gt; ) обрабатывается по &lt;a href=&quot;operator_ltlt2&quot;&gt;перегрузкам , не являющиеся членов&lt;/a&gt; из &lt;code&gt;operator&amp;lt;&amp;lt;&lt;/code&gt; . Попытка вывести символ с использованием синтаксиса вызова функции-члена (например, &lt;code&gt;&lt;a href=&quot;../cout&quot;&gt;std::cout&lt;/a&gt;.operator&amp;lt;&amp;lt;('c');&lt;/code&gt; ) вызовет одну из перегрузок (2-4) и выведет числовое значение. Попытка вывести символьную строку с использованием синтаксиса вызова функции-члена вызовет перегрузку (7) и вместо этого выведет значение указателя.</target>
        </trans-unit>
        <trans-unit id="6512adfeb2b6b71a8085a0b4569a9025105f6ea1" translate="yes" xml:space="preserve">
          <source>Character array manipulation</source>
          <target state="translated">Манипуляция с массивом символов</target>
        </trans-unit>
        <trans-unit id="e6c2fd1aae71d170866344f96ee158518de8bbea" translate="yes" xml:space="preserve">
          <source>Character arrays</source>
          <target state="translated">Массивы символов</target>
        </trans-unit>
        <trans-unit id="11a965778572465b297760373bc0ab9a5fe50dd4" translate="yes" xml:space="preserve">
          <source>Character classification</source>
          <target state="translated">Классификация символов</target>
        </trans-unit>
        <trans-unit id="5e46fee36b88268f4391d4aab452946b36ee208f" translate="yes" xml:space="preserve">
          <source>Character conversions</source>
          <target state="translated">Преобразование символов</target>
        </trans-unit>
        <trans-unit id="ea3303247b226441481c96408e89f86363fc056f" translate="yes" xml:space="preserve">
          <source>Character converted to &lt;code&gt;char_type&lt;/code&gt;.</source>
          <target state="translated">Символ преобразуется в &lt;code&gt;char_type&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c75ca2fc8c1a6a863ef50c02a9cfe0d0c2a00888" translate="yes" xml:space="preserve">
          <source>Character converted to its standard equivalent and then to &lt;code&gt;char&lt;/code&gt;. &lt;code&gt;dfault&lt;/code&gt; is returned if the conversion fails.</source>
          <target state="translated">Символ преобразуется в его стандартный эквивалент, а затем в &lt;code&gt;char&lt;/code&gt; . &lt;code&gt;dfault&lt;/code&gt; возвращается, если преобразование не удалось .</target>
        </trans-unit>
        <trans-unit id="71abf6f6cdd425368811b306d03c5406b82396a5" translate="yes" xml:space="preserve">
          <source>Character manipulation</source>
          <target state="translated">Манипулирование персонажами</target>
        </trans-unit>
        <trans-unit id="4c58f86ca967b4e419cb22f348fc6985fce2677c" translate="yes" xml:space="preserve">
          <source>Character matching should be performed without regard to case.</source>
          <target state="translated">Сопоставление символов должно выполняться без учета регистра.</target>
        </trans-unit>
        <trans-unit id="2c0613c06e2948d7013037f534e1060ec71035f9" translate="yes" xml:space="preserve">
          <source>Character ranges of the form</source>
          <target state="translated">Диапазоны символов формы</target>
        </trans-unit>
        <trans-unit id="01b4f31695ebfef5e54e268eeccaa5f720d189d9" translate="yes" xml:space="preserve">
          <source>Character string identifying the value of the environmental variable or null pointer if such variable is not found.</source>
          <target state="translated">Строка символов,идентифицирующая значение переменной окружения или нулевой указатель,если такая переменная не найдена.</target>
        </trans-unit>
        <trans-unit id="ce6ddaa694e2a7b4942fbc87cf18e8f64d26f9b2" translate="yes" xml:space="preserve">
          <source>Character types</source>
          <target state="translated">Типы символов</target>
        </trans-unit>
        <trans-unit id="2fa17410341c773958ab0b06148ed01369e49360" translate="yes" xml:space="preserve">
          <source>Characteristics</source>
          <target state="translated">Characteristics</target>
        </trans-unit>
        <trans-unit id="b6f59f08fd6d58c6725e21a9ec24e068148ec586" translate="yes" xml:space="preserve">
          <source>Characters</source>
          <target state="translated">Characters</target>
        </trans-unit>
        <trans-unit id="f75befe1513c72cfd4b48f48e3e273b661b4521f" translate="yes" xml:space="preserve">
          <source>Characters are extracted until either.</source>
          <target state="translated">Символы извлекаются до тех пор,пока не будет найдено ни одного из них.</target>
        </trans-unit>
        <trans-unit id="5d0fadb68912f46be7478bf1dc2a449a1ccab7e3" translate="yes" xml:space="preserve">
          <source>Characters following the null character are not compared.</source>
          <target state="translated">Символы,следующие за нулевым символом,не сравниваются.</target>
        </trans-unit>
        <trans-unit id="bbb7ac13141743e85ef9cf35d0729e5e44ee839e" translate="yes" xml:space="preserve">
          <source>Checks for the presence of an &lt;a href=&quot;language/attributes&quot;&gt;attribute&lt;/a&gt;.</source>
          <target state="translated">Проверяет наличие &lt;a href=&quot;language/attributes&quot;&gt;атрибута&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5c239cb24da30a931bb645a231c2c1a422922f55" translate="yes" xml:space="preserve">
          <source>Checks if &lt;code&gt;*this&lt;/code&gt; is the only &lt;code&gt;shared_ptr&lt;/code&gt; instance managing the current object, i.e. whether &lt;code&gt;use_count() == 1&lt;/code&gt;.</source>
          <target state="translated">Проверяет, является ли &lt;code&gt;*this&lt;/code&gt; единственный экземпляр &lt;code&gt;shared_ptr&lt;/code&gt; , управляющий текущим объектом, т. &lt;code&gt;use_count() == 1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="64fe6c568f795adfd098e0d63f6859cec6831cc6" translate="yes" xml:space="preserve">
          <source>Checks if &lt;code&gt;*this&lt;/code&gt; represents a valid date. Because a &lt;code&gt;year_month_day_last&lt;/code&gt; represents the last day of a particular month, it represents a valid date as long as the year and month are valid.</source>
          <target state="translated">Проверяет, является ли &lt;code&gt;*this&lt;/code&gt; действительной датой. Поскольку &lt;code&gt;year_month_day_last&lt;/code&gt; представляет последний день определенного месяца, он представляет действительную дату, если год и месяц действительны.</target>
        </trans-unit>
        <trans-unit id="0373b2fbb18e3c084d0c6cb8a8392f2d23211bd2" translate="yes" xml:space="preserve">
          <source>Checks if &lt;code&gt;*this&lt;/code&gt; stores a non-null pointer, i.e. whether &lt;code&gt;get() != nullptr&lt;/code&gt;.</source>
          <target state="translated">Проверяет, если &lt;code&gt;*this&lt;/code&gt; хранит ненулевой указатель, т. &lt;code&gt;get() != nullptr&lt;/code&gt; ли ()! = Nullptr .</target>
        </trans-unit>
        <trans-unit id="c4fb57d3244245c7b2c53e5525199fd6990e81a5" translate="yes" xml:space="preserve">
          <source>Checks if &lt;code&gt;T&lt;/code&gt; is an &lt;a href=&quot;../language/aggregate_initialization&quot;&gt;aggregate type&lt;/a&gt;. The member constant &lt;code&gt;value&lt;/code&gt; is equal to &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;T&lt;/code&gt; is an aggregate type and &lt;code&gt;false&lt;/code&gt; otherwise.</source>
          <target state="translated">Проверки , если &lt;code&gt;T&lt;/code&gt; представляет собой &lt;a href=&quot;../language/aggregate_initialization&quot;&gt;совокупный тип&lt;/a&gt; . Постоянный член &lt;code&gt;value&lt;/code&gt; равно &lt;code&gt;true&lt;/code&gt; , если &lt;code&gt;T&lt;/code&gt; представляет собой агрегат типа и &lt;code&gt;false&lt;/code&gt; в противном случае.</target>
        </trans-unit>
        <trans-unit id="46810c15e7731f0bcc598e64e82c003580066f60" translate="yes" xml:space="preserve">
          <source>Checks if &lt;code&gt;ch&lt;/code&gt; is a printable character as classified by the currently installed C locale. In the default, &quot;C&quot; locale, the following characters are printable:</source>
          <target state="translated">Проверяет, является ли &lt;code&gt;ch&lt;/code&gt; печатным символом в соответствии с установленным в настоящее время языковым стандартом C. В локали &quot;C&quot; по умолчанию можно печатать следующие символы:</target>
        </trans-unit>
        <trans-unit id="bef2c39f0952ee3e2e6df2eb7c4b6c1cb97c1231" translate="yes" xml:space="preserve">
          <source>Checks if &lt;code&gt;lhs&lt;/code&gt; is</source>
          <target state="translated">Проверяет &lt;code&gt;lhs&lt;/code&gt; является</target>
        </trans-unit>
        <trans-unit id="8742a8ea58f9f8b2f58eab45ce84322d20b1ef7e" translate="yes" xml:space="preserve">
          <source>Checks if &lt;code&gt;x&lt;/code&gt; is an integral power of two.</source>
          <target state="translated">Проверяет, является ли &lt;code&gt;x&lt;/code&gt; целой степенью двойки.</target>
        </trans-unit>
        <trans-unit id="e01f0ff952438d49e950107b31dc2f6d176fb839" translate="yes" xml:space="preserve">
          <source>Checks if all, any or none of the bits are set to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">Проверяет, установлены ли все, какие-либо или ни один из битов в значение &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ebd2ed423ea71f7993be85315a4cf55c91df927f" translate="yes" xml:space="preserve">
          <source>Checks if an element equivalent to &lt;code&gt;value&lt;/code&gt; appears within the range &lt;code&gt;[first, last)&lt;/code&gt;.</source>
          <target state="translated">Проверяет, находится ли элемент, эквивалентный &lt;code&gt;value&lt;/code&gt; , в диапазоне &lt;code&gt;[first, last)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3df65edb22a1ea82942fb937399112c261a1ddf5" translate="yes" xml:space="preserve">
          <source>Checks if the &lt;code&gt;month&lt;/code&gt; object stored in &lt;code&gt;*this&lt;/code&gt; is valid.</source>
          <target state="translated">Проверяет, является ли объект &lt;code&gt;month&lt;/code&gt; хранящийся в &lt;code&gt;*this&lt;/code&gt; действительным.</target>
        </trans-unit>
        <trans-unit id="cf1c1960bf8bd117039d083bce42dfd50d32f263" translate="yes" xml:space="preserve">
          <source>Checks if the contained &lt;a href=&quot;../month&quot;&gt;&lt;code&gt;month&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../weekday_indexed&quot;&gt;&lt;code&gt;weekday_indexed&lt;/code&gt;&lt;/a&gt; objects are valid.</source>
          <target state="translated">Проверяет, являются ли содержащиеся объекты &lt;a href=&quot;../month&quot;&gt; &lt;code&gt;month&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;../weekday_indexed&quot;&gt; &lt;code&gt;weekday_indexed&lt;/code&gt; &lt;/a&gt; действительными.</target>
        </trans-unit>
        <trans-unit id="c0e9dbc22fbac3c623e99fa4b12c00c784887ebb" translate="yes" xml:space="preserve">
          <source>Checks if the contained &lt;a href=&quot;../month&quot;&gt;&lt;code&gt;month&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../weekday_last&quot;&gt;&lt;code&gt;weekday_last&lt;/code&gt;&lt;/a&gt; objects are valid.</source>
          <target state="translated">Проверяет , действительны ли содержащиеся объекты &lt;a href=&quot;../month&quot;&gt; &lt;code&gt;month&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;../weekday_last&quot;&gt; &lt;code&gt;weekday_last&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a186fda0be6fbf8b4f0463ca58545aab4b63c811" translate="yes" xml:space="preserve">
          <source>Checks if the container has no elements, i.e. whether &lt;code&gt;begin() == end()&lt;/code&gt;.</source>
          <target state="translated">Проверяет, нет ли в контейнере элементов, т.е. есть ли &lt;code&gt;begin() == end()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bdababdda3b078e8a754954e78f43fa63c1e9fca" translate="yes" xml:space="preserve">
          <source>Checks if the day value stored in &lt;code&gt;*this&lt;/code&gt; is in the valid range, i.e., [1, 31].</source>
          <target state="translated">Проверяет, находится ли значение дня, хранящееся в &lt;code&gt;*this&lt;/code&gt; в допустимом диапазоне, т. Е. [1, 31].</target>
        </trans-unit>
        <trans-unit id="883d61f7b86b64216417405d15836a0059e52c16" translate="yes" xml:space="preserve">
          <source>Checks if the elements in range &lt;code&gt;[first, last)&lt;/code&gt; are a</source>
          <target state="translated">Проверки , если элементы в диапазоне &lt;code&gt;[first, last)&lt;/code&gt; являются</target>
        </trans-unit>
        <trans-unit id="edd5932dbd43271b51bea92b6301c914eb0d9627" translate="yes" xml:space="preserve">
          <source>Checks if the elements in range &lt;code&gt;[first, last)&lt;/code&gt; are sorted in non-descending order.</source>
          <target state="translated">Проверяет , отсортированы ли элементы в диапазоне &lt;code&gt;[first, last)&lt;/code&gt; в не убывающем порядке.</target>
        </trans-unit>
        <trans-unit id="7583a23f352a0114e03ecd5b421ac82f127e76d4" translate="yes" xml:space="preserve">
          <source>Checks if the end of the given file stream has been reached.</source>
          <target state="translated">Проверяет,достигнут ли конец данного потока файлов.</target>
        </trans-unit>
        <trans-unit id="0ea631da0eac64b4493283ac77224a99a20a1afb" translate="yes" xml:space="preserve">
          <source>Checks if the error value is valid, i.e. non-zero.</source>
          <target state="translated">Проверяет правильность значения ошибки,т.е.ненулевое.</target>
        </trans-unit>
        <trans-unit id="e0a4ec6efbb9408286b1f97366f614bd6aebe167" translate="yes" xml:space="preserve">
          <source>Checks if the file stream has an associated file.</source>
          <target state="translated">Проверяет,есть ли в файловом потоке связанный файл.</target>
        </trans-unit>
        <trans-unit id="9939f20d92c8448e034a9fb2ce041b3a30041e38" translate="yes" xml:space="preserve">
          <source>Checks if the first range &lt;code&gt;[first1, last1)&lt;/code&gt; is lexicographically</source>
          <target state="translated">Проверяет, является ли первый диапазон &lt;code&gt;[first1, last1)&lt;/code&gt; лексикографически</target>
        </trans-unit>
        <trans-unit id="9c9cf6d9c81ca1a6f48142b146482b5a7d92c18d" translate="yes" xml:space="preserve">
          <source>Checks if the future refers to a shared state.</source>
          <target state="translated">Проверяет,относится ли будущее к общему государству.</target>
        </trans-unit>
        <trans-unit id="1f541bb8843b33c6aed03a6b4cf9d5e87a333b18" translate="yes" xml:space="preserve">
          <source>Checks if the given character classified as a graphic character (i.e. printable, excluding space) by the given locale's &lt;code&gt;&lt;a href=&quot;ctype&quot;&gt;std::ctype&lt;/a&gt;&lt;/code&gt; facet.</source>
          <target state="translated">Проверяет, классифицирован ли данный символ как графический символ (т. Е. Печатается, исключая пробел) по указанному фасету локали &lt;code&gt;&lt;a href=&quot;ctype&quot;&gt;std::ctype&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2b8c77159013c45824384fde718470edb60e4d82" translate="yes" xml:space="preserve">
          <source>Checks if the given character classified as a printable character (including space) by the given locale's &lt;code&gt;&lt;a href=&quot;ctype&quot;&gt;std::ctype&lt;/a&gt;&lt;/code&gt; facet.</source>
          <target state="translated">Проверяет, классифицирован ли данный символ как печатный символ (включая пробел) по фасету данного языкового стандарта &lt;code&gt;&lt;a href=&quot;ctype&quot;&gt;std::ctype&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8c2b1f4fcd055b704d957a1b2cdeb2187a3b7dbc" translate="yes" xml:space="preserve">
          <source>Checks if the given character classified as an alphanumeric character by the given locale's &lt;code&gt;&lt;a href=&quot;ctype&quot;&gt;std::ctype&lt;/a&gt;&lt;/code&gt; facet.</source>
          <target state="translated">Проверяет, классифицирован ли данный символ как алфавитно-цифровой символ по фасету данного языкового стандарта &lt;code&gt;&lt;a href=&quot;ctype&quot;&gt;std::ctype&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4f79c82fa33d708a83fc2cde057f0b8a25d9b077" translate="yes" xml:space="preserve">
          <source>Checks if the given character is a blank character as classified by the currently installed C locale. Blank characters are whitespace characters used to separate words within a sentence. In the default C locale, only space (&lt;code&gt;0x20&lt;/code&gt;) and horizontal tab (&lt;code&gt;0x09&lt;/code&gt;) are classified as blank characters.</source>
          <target state="translated">Проверяет, является ли данный символ пустым, как классифицировано в текущей установленной локали C. Пустые символы - это пробельные символы, используемые для разделения слов в предложении. В локали C по умолчанию только пробел ( &lt;code&gt;0x20&lt;/code&gt; ) и горизонтальная табуляция ( &lt;code&gt;0x09&lt;/code&gt; ) классифицируются как пустые символы.</target>
        </trans-unit>
        <trans-unit id="63924bd06b9cfc417682f6f2da0b8cccc1b40b2a" translate="yes" xml:space="preserve">
          <source>Checks if the given character is a control character as classified by the currently installed C locale. In the default, &quot;C&quot; locale, the control characters are the characters with the codes &lt;code&gt;0x00-0x1F&lt;/code&gt; and &lt;code&gt;0x7F&lt;/code&gt;.</source>
          <target state="translated">Проверяет, является ли данный символ управляющим символом в соответствии с установленным в настоящее время языковым стандартом C. В локали &quot;C&quot; по умолчанию управляющими символами являются символы с кодами &lt;code&gt;0x00-0x1F&lt;/code&gt; и &lt;code&gt;0x7F&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="620ca22193327aabe490bc69707b719cd34918b4" translate="yes" xml:space="preserve">
          <source>Checks if the given character is a hexadecimal numeric character (&lt;code&gt;0123456789abcdefABCDEF&lt;/code&gt;).</source>
          <target state="translated">Проверяет, является ли данный символ шестнадцатеричным числовым символом ( &lt;code&gt;0123456789abcdefABCDEF&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="8b960e379d1de64e4dd59c0a98f8f7ba08f6e01b" translate="yes" xml:space="preserve">
          <source>Checks if the given character is a punctuation character as classified by the current C locale. The default C locale classifies the characters &lt;code&gt;!&quot;#$%&amp;amp;'()*+,-./:;&amp;lt;=&amp;gt;?@[\]^_`{|}~&lt;/code&gt; as punctuation.</source>
          <target state="translated">Проверяет, является ли данный символ символом пунктуации в соответствии с текущим языковым стандартом C. Локаль C по умолчанию классифицирует символы &lt;code&gt;!&quot;#$%&amp;amp;'()*+,-./:;&amp;lt;=&amp;gt;?@[\]^_`{|}~&lt;/code&gt; Как знаки пунктуации.</target>
        </trans-unit>
        <trans-unit id="e36cb86f2350ed7cbcb8c08ff869f068fcb37a55" translate="yes" xml:space="preserve">
          <source>Checks if the given character is an alphabetic character as classified by the currently installed C locale. In the default locale, the following characters are alphabetic:</source>
          <target state="translated">Проверяет,является ли данный символ алфавитным по классификации текущей установленной локали C.В установленной по умолчанию локали следующие символы являются алфавитными:</target>
        </trans-unit>
        <trans-unit id="8460053f4f6257cbef25ff160120cc6c7e959e75" translate="yes" xml:space="preserve">
          <source>Checks if the given character is an alphanumeric character as classified by the current C locale. In the default locale, the following characters are alphanumeric:</source>
          <target state="translated">Проверяет,является ли данный символ буквенно-цифровым,классифицированным по текущей локали C.В локали по умолчанию следующие символы являются буквенно-цифровыми:</target>
        </trans-unit>
        <trans-unit id="e7168f1ddb2b4d425325e246ea920d97240da433" translate="yes" xml:space="preserve">
          <source>Checks if the given character is an uppercase character as classified by the currently installed C locale. In the default &quot;C&quot; locale, &lt;code&gt;isupper&lt;/code&gt; returns a nonzero value only for the uppercase letters (&lt;code&gt;ABCDEFGHIJKLMNOPQRSTUVWXYZ&lt;/code&gt;).</source>
          <target state="translated">Проверяет, является ли данный символ заглавным, как классифицировано текущей установленной локалью C. В локали &quot;C&quot; по умолчанию &lt;code&gt;isupper&lt;/code&gt; возвращает ненулевое значение только для заглавных букв ( &lt;code&gt;ABCDEFGHIJKLMNOPQRSTUVWXYZ&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="11145349eb5a7ce12671e4ea9c07676f5f562772" translate="yes" xml:space="preserve">
          <source>Checks if the given character is classified as a blank character by the given locale's ctype facet.</source>
          <target state="translated">Проверяет,классифицируется ли данный символ как пустой по фаске типа c данной локали.</target>
        </trans-unit>
        <trans-unit id="6d19f846387e2564dd01a4273fc111bb0f3752b9" translate="yes" xml:space="preserve">
          <source>Checks if the given character is classified as a control character by the given locale's &lt;code&gt;&lt;a href=&quot;ctype&quot;&gt;std::ctype&lt;/a&gt;&lt;/code&gt; facet.</source>
          <target state="translated">Проверяет, классифицирован ли данный символ как управляющий символ по фасету данного языкового стандарта &lt;code&gt;&lt;a href=&quot;ctype&quot;&gt;std::ctype&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d1d14d696222c936849b54795e37e65ab005fff8" translate="yes" xml:space="preserve">
          <source>Checks if the given character is classified as a digit by the given locale's &lt;code&gt;&lt;a href=&quot;ctype&quot;&gt;std::ctype&lt;/a&gt;&lt;/code&gt; facet.</source>
          <target state="translated">Проверяет, классифицирован ли данный символ как цифра по фасету данного языкового стандарта &lt;code&gt;&lt;a href=&quot;ctype&quot;&gt;std::ctype&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="65f5cc11ad968a30d5184556f3ca2929d52f75ca" translate="yes" xml:space="preserve">
          <source>Checks if the given character is classified as a hexadecimal digit by the given locale's &lt;code&gt;&lt;a href=&quot;ctype&quot;&gt;std::ctype&lt;/a&gt;&lt;/code&gt; facet.</source>
          <target state="translated">Проверяет, классифицирован ли данный символ как шестнадцатеричная цифра по фасету данного языкового стандарта &lt;code&gt;&lt;a href=&quot;ctype&quot;&gt;std::ctype&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5a564f70b3df82a305537021cab411cdbd81adce" translate="yes" xml:space="preserve">
          <source>Checks if the given character is classified as a lowercase alphabetic character by the given locale's &lt;code&gt;&lt;a href=&quot;ctype&quot;&gt;std::ctype&lt;/a&gt;&lt;/code&gt; facet.</source>
          <target state="translated">Проверяет, классифицирован ли данный символ как строчный буквенный символ по фасету данного языкового стандарта &lt;code&gt;&lt;a href=&quot;ctype&quot;&gt;std::ctype&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2a2d197badc519c2b6d6b8c1c0f0089443b1e3e0" translate="yes" xml:space="preserve">
          <source>Checks if the given character is classified as a lowercase character according to the current C locale. In the default &quot;C&quot; locale, &lt;code&gt;islower&lt;/code&gt; returns a nonzero value only for the lowercase letters (&lt;code&gt;abcdefghijklmnopqrstuvwxyz&lt;/code&gt;).</source>
          <target state="translated">Проверяет, классифицирован ли данный символ как строчный в соответствии с текущей локалью языка C. В локали по умолчанию &quot;C&quot; &lt;code&gt;islower&lt;/code&gt; возвращает ненулевое значение только для строчных букв ( &lt;code&gt;abcdefghijklmnopqrstuvwxyz&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="23434ffbce64a443ceebe9b25bfd4dee6b410a4d" translate="yes" xml:space="preserve">
          <source>Checks if the given character is classified as a whitespace character by the given locale's ctype facet.</source>
          <target state="translated">Проверяет,классифицируется ли данный символ как символ пробела по фацетке типа c данной локали.</target>
        </trans-unit>
        <trans-unit id="29b8c4707acb6f5f5b0af799234d886e0c8bdb59" translate="yes" xml:space="preserve">
          <source>Checks if the given character is classified as an alphabetic character by the given locale's &lt;code&gt;&lt;a href=&quot;ctype&quot;&gt;std::ctype&lt;/a&gt;&lt;/code&gt; facet.</source>
          <target state="translated">Проверяет, классифицирован ли данный символ как алфавитный символ по фасету данного языкового стандарта &lt;code&gt;&lt;a href=&quot;ctype&quot;&gt;std::ctype&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f13395f8feb0b1900f02da016716c265861d48bd" translate="yes" xml:space="preserve">
          <source>Checks if the given character is classified as an punctuation character by the given locale's &lt;code&gt;&lt;a href=&quot;ctype&quot;&gt;std::ctype&lt;/a&gt;&lt;/code&gt; facet.</source>
          <target state="translated">Проверяет, классифицирован ли данный символ как знак пунктуации по фасету данного языкового стандарта &lt;code&gt;&lt;a href=&quot;ctype&quot;&gt;std::ctype&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="06bebae7934c976345409e18e4892deb4f07b810" translate="yes" xml:space="preserve">
          <source>Checks if the given character is classified as an uppercase alphabetic character by the given locale's &lt;code&gt;&lt;a href=&quot;ctype&quot;&gt;std::ctype&lt;/a&gt;&lt;/code&gt; facet.</source>
          <target state="translated">Проверяет, классифицирован ли данный символ как заглавный алфавитный символ фасетом &lt;code&gt;&lt;a href=&quot;ctype&quot;&gt;std::ctype&lt;/a&gt;&lt;/code&gt; данной локали .</target>
        </trans-unit>
        <trans-unit id="05ecdcea5d58ceaa8ef5f1b140c063bf55d26ae8" translate="yes" xml:space="preserve">
          <source>Checks if the given character is graphic (has a graphical representation) as classified by the currently installed C locale. In the default C locale, the following characters are graphic:</source>
          <target state="translated">Проверяет,является ли данный символ графическим (имеет графическое представление),классифицированным по текущей установленной локали C.В установленной по умолчанию С-локации следующие символы являются графическими:</target>
        </trans-unit>
        <trans-unit id="53e2f7b7aaa15bbc121a001ba778520977aa5a41" translate="yes" xml:space="preserve">
          <source>Checks if the given character is one of the 10 decimal digits: &lt;code&gt;0123456789&lt;/code&gt;.</source>
          <target state="translated">Проверяет, является ли данный символ одной из 10 десятичных цифр: &lt;code&gt;0123456789&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8fe8cd0a6bef5c367f22c30f7a34e386596daca0" translate="yes" xml:space="preserve">
          <source>Checks if the given character is whitespace character as classified by the currently installed C locale. In the default locale, the whitespace characters are the following:</source>
          <target state="translated">Проверяет,является ли данный символ символом пробела,классифицированным по текущей установленной локали C.В установленной по умолчанию локали пробельные символы являются следующими:</target>
        </trans-unit>
        <trans-unit id="eb1f23b247c77dd957a70ee1a23c0abb19665059" translate="yes" xml:space="preserve">
          <source>Checks if the given file status is known, Equivalent to &lt;code&gt;s.type() != file_type::none&lt;/code&gt;.</source>
          <target state="translated">Проверяет, известен ли данный статус файла, эквивалентно &lt;code&gt;s.type() != file_type::none&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="218bbbf54d03f6b2078dbf8b7f02244dc7b15314" translate="yes" xml:space="preserve">
          <source>Checks if the given file status or path corresponds to a FIFO or pipe file as if determined by POSIX &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/sys_stat.h.html&quot;&gt;S_ISFIFO&lt;/a&gt;.</source>
          <target state="translated">Проверяет, соответствует ли данный статус файла или путь файлу FIFO или &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/sys_stat.h.html&quot;&gt;каналу,&lt;/a&gt; как если бы это было определено POSIX S_ISFIFO .</target>
        </trans-unit>
        <trans-unit id="59f78fd0654c3e8fd55833e4c87be9c606945a6f" translate="yes" xml:space="preserve">
          <source>Checks if the given file status or path corresponds to a FIFO or pipe file as if determined by POSIX &lt;a href=&quot;https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/sys_stat.h.html&quot;&gt;S_ISFIFO&lt;/a&gt;.</source>
          <target state="translated">Проверяет, соответствует ли данный статус файла или путь файлу FIFO или &lt;a href=&quot;https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/sys_stat.h.html&quot;&gt;каналу,&lt;/a&gt; как если бы он определен POSIX S_ISFIFO .</target>
        </trans-unit>
        <trans-unit id="a5bbc2239e82c8c44869791aa800f48187a92cdb" translate="yes" xml:space="preserve">
          <source>Checks if the given file status or path corresponds to a block special file, as if determined by the POSIX &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/sys_stat.h.html&quot;&gt;S_ISBLK &lt;/a&gt;. Examples of block special files are block devices such as &lt;code&gt;/dev/sda&lt;/code&gt; or &lt;code&gt;/dev/loop0&lt;/code&gt; on Linux.</source>
          <target state="translated">Проверяет, соответствует ли данный статус файла или путь специальному файлу блока, как если бы это было определено POSIX &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/sys_stat.h.html&quot;&gt;S_ISBLK&lt;/a&gt; . Примерами блочных специальных файлов являются блочные устройства, такие как &lt;code&gt;/dev/sda&lt;/code&gt; или &lt;code&gt;/dev/loop0&lt;/code&gt; в Linux.</target>
        </trans-unit>
        <trans-unit id="2e5197f0c4392ff508470e6034eff6166cf69b18" translate="yes" xml:space="preserve">
          <source>Checks if the given file status or path corresponds to a block special file, as if determined by the POSIX &lt;a href=&quot;https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/sys_stat.h.html&quot;&gt;S_ISBLK &lt;/a&gt;. Examples of block special files are block devices such as &lt;code&gt;/dev/sda&lt;/code&gt; or &lt;code&gt;/dev/loop0&lt;/code&gt; on Linux.</source>
          <target state="translated">Проверяет, соответствует ли данный статус файла или путь к специальному файлу блока, как если бы он определен POSIX &lt;a href=&quot;https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/sys_stat.h.html&quot;&gt;S_ISBLK&lt;/a&gt; . Примерами блочных специальных файлов являются блочные устройства, такие как &lt;code&gt;/dev/sda&lt;/code&gt; или &lt;code&gt;/dev/loop0&lt;/code&gt; в Linux.</target>
        </trans-unit>
        <trans-unit id="cd5468dc57f1c432cf3158ebdd4f2506febe1e97" translate="yes" xml:space="preserve">
          <source>Checks if the given file status or path corresponds to a character special file, as if determined by POSIX &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/sys_stat.h.html&quot;&gt;S_ISCHR&lt;/a&gt;. Examples of character special files are character devices such as &lt;code&gt;/dev/null&lt;/code&gt;, &lt;code&gt;/dev/tty&lt;/code&gt;, &lt;code&gt;/dev/audio&lt;/code&gt;, or &lt;code&gt;/dev/nvram&lt;/code&gt; on Linux.</source>
          <target state="translated">Проверяет, соответствует ли данный статус файла или путь специальному символьному файлу, как если бы это было определено POSIX &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/sys_stat.h.html&quot;&gt;S_ISCHR&lt;/a&gt; . Примерами символьных специальных файлов являются символьные устройства, такие как &lt;code&gt;/dev/null&lt;/code&gt; , &lt;code&gt;/dev/tty&lt;/code&gt; , &lt;code&gt;/dev/audio&lt;/code&gt; или &lt;code&gt;/dev/nvram&lt;/code&gt; в Linux.</target>
        </trans-unit>
        <trans-unit id="9479e1dc7e5343ba2e42d47605397490d2ca33f0" translate="yes" xml:space="preserve">
          <source>Checks if the given file status or path corresponds to a character special file, as if determined by POSIX &lt;a href=&quot;https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/sys_stat.h.html&quot;&gt;S_ISCHR&lt;/a&gt;. Examples of character special files are character devices such as &lt;code&gt;/dev/null&lt;/code&gt;, &lt;code&gt;/dev/tty&lt;/code&gt;, &lt;code&gt;/dev/audio&lt;/code&gt;, or &lt;code&gt;/dev/nvram&lt;/code&gt; on Linux.</source>
          <target state="translated">Проверяет, соответствует ли данный статус или путь к файлу специальному символьному файлу, как если бы он определен POSIX &lt;a href=&quot;https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/sys_stat.h.html&quot;&gt;S_ISCHR&lt;/a&gt; . Примерами специальных символьных файлов являются символьные устройства, такие как &lt;code&gt;/dev/null&lt;/code&gt; , &lt;code&gt;/dev/tty&lt;/code&gt; , &lt;code&gt;/dev/audio&lt;/code&gt; или &lt;code&gt;/dev/nvram&lt;/code&gt; в Linux.</target>
        </trans-unit>
        <trans-unit id="5800e2498685522757fe31c5c55c07d4ca923fef" translate="yes" xml:space="preserve">
          <source>Checks if the given file status or path corresponds to a directory.</source>
          <target state="translated">Проверяет,соответствует ли данный статус файла или путь к нему каталогу.</target>
        </trans-unit>
        <trans-unit id="1a93cdcd4a85825d11b2a20b899602004622f63c" translate="yes" xml:space="preserve">
          <source>Checks if the given file status or path corresponds to a file of type</source>
          <target state="translated">Проверяет,соответствует ли данный статус файла или путь к нему типу файла</target>
        </trans-unit>
        <trans-unit id="bac818da5390c8dda2cd14c441525beaeb1ca7ce" translate="yes" xml:space="preserve">
          <source>Checks if the given file status or path corresponds to a named IPC socket, as if determined by the POSIX &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/sys_stat.h.html&quot;&gt;S_IFSOCK&lt;/a&gt;.</source>
          <target state="translated">Проверяет, соответствует ли данный статус файла или путь указанному сокету IPC, как если бы это было определено POSIX &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/sys_stat.h.html&quot;&gt;S_IFSOCK&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="458e32f94beeea7ee61df2abc8def72cf58275aa" translate="yes" xml:space="preserve">
          <source>Checks if the given file status or path corresponds to a named IPC socket, as if determined by the POSIX &lt;a href=&quot;https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/sys_stat.h.html&quot;&gt;S_IFSOCK&lt;/a&gt;.</source>
          <target state="translated">Проверяет, соответствует ли данный статус файла или путь названному IPC-сокету, как если бы он определен POSIX &lt;a href=&quot;https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/sys_stat.h.html&quot;&gt;S_IFSOCK&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5cbb58c72659913381cfab0101affa7e32b4218a" translate="yes" xml:space="preserve">
          <source>Checks if the given file status or path corresponds to a regular file.</source>
          <target state="translated">Проверяет,соответствует ли данный статус файла или путь к нему обычному файлу.</target>
        </trans-unit>
        <trans-unit id="069358c7a4934c3a0eff64f5a19fd200748050f4" translate="yes" xml:space="preserve">
          <source>Checks if the given file status or path corresponds to a symbolic link, as if determined by the POSIX &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/sys_stat.h.html&quot;&gt;S_IFLNK&lt;/a&gt;.</source>
          <target state="translated">Проверяет, соответствует ли данный статус файла или путь символической ссылке, как если бы это было определено POSIX &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/sys_stat.h.html&quot;&gt;S_IFLNK&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8a8bcc19d24795c03f4c0be56e5c1f1fd67d60e2" translate="yes" xml:space="preserve">
          <source>Checks if the given file status or path corresponds to a symbolic link, as if determined by the POSIX &lt;a href=&quot;https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/sys_stat.h.html&quot;&gt;S_IFLNK&lt;/a&gt;.</source>
          <target state="translated">Проверяет, соответствует ли данный статус файла или путь символьной ссылке, как если бы это определено POSIX &lt;a href=&quot;https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/sys_stat.h.html&quot;&gt;S_IFLNK&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7887d8d69526f9ccd0654883e159eed9a48b721d" translate="yes" xml:space="preserve">
          <source>Checks if the given file status or path corresponds to an existing file or directory.</source>
          <target state="translated">Проверяет,соответствует ли данный статус файла или путь к нему существующему файлу или каталогу.</target>
        </trans-unit>
        <trans-unit id="86e15e5f001ace8d5ed732d67f679b17b8027345" translate="yes" xml:space="preserve">
          <source>Checks if the given wide character can be printed, i.e. it is either a number (&lt;code&gt;0123456789&lt;/code&gt;), an uppercase letter (&lt;code&gt;ABCDEFGHIJKLMNOPQRSTUVWXYZ&lt;/code&gt;), a lowercase letter (&lt;code&gt;abcdefghijklmnopqrstuvwxyz&lt;/code&gt;), a punctuation character(&lt;code&gt;!&quot;#$%&amp;amp;'()*+,-./:;&amp;lt;=&amp;gt;?@[\]^_`{|}~&lt;/code&gt;), space or any printable character specific to the current C locale.</source>
          <target state="translated">Проверяет, можно ли печатать данный широкий символ, т. Е. Является ли оно числом ( &lt;code&gt;0123456789&lt;/code&gt; ), заглавной буквой ( &lt;code&gt;ABCDEFGHIJKLMNOPQRSTUVWXYZ&lt;/code&gt; ), строчной буквой ( &lt;code&gt;abcdefghijklmnopqrstuvwxyz&lt;/code&gt; ), знаком пунктуации ( &lt;code&gt;!&quot;#$%&amp;amp;'()*+,-./:;&amp;lt;=&amp;gt;?@[\]^_`{|}~&lt;/code&gt; ), пробел или любой печатаемый специфический характер для текущей локали C.</target>
        </trans-unit>
        <trans-unit id="6ddf1d4606203515c454d3cbf72c353c2b7a5550" translate="yes" xml:space="preserve">
          <source>Checks if the given wide character corresponds (if narrowed) to a hexadecimal numeric character, i.e. one of &lt;code&gt;0123456789abcdefABCDEF&lt;/code&gt;.</source>
          <target state="translated">Проверяет, соответствует ли данный широкий символ (если он сужен) шестнадцатеричному числовому символу, то есть одному из &lt;code&gt;0123456789abcdefABCDEF&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9737563245a39a0f23f82812e136487feb35b8a3" translate="yes" xml:space="preserve">
          <source>Checks if the given wide character corresponds (if narrowed) to one of the ten decimal digit characters &lt;code&gt;0123456789&lt;/code&gt;.</source>
          <target state="translated">Проверяет, соответствует ли данный широкий символ (если он сужен) одному из десяти десятичных цифр &lt;code&gt;0123456789&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="901c321d30a4b9e0c1bb0f4ce4f0b7f3fc5086ff" translate="yes" xml:space="preserve">
          <source>Checks if the given wide character has a graphical representation, i.e. it is either a number (&lt;code&gt;0123456789&lt;/code&gt;), an uppercase letter (&lt;code&gt;ABCDEFGHIJKLMNOPQRSTUVWXYZ&lt;/code&gt;), a lowercase letter (&lt;code&gt;abcdefghijklmnopqrstuvwxyz&lt;/code&gt;), a punctuation character(&lt;code&gt;!&quot;#$%&amp;amp;'()*+,-./:;&amp;lt;=&amp;gt;?@[\]^_`{|}~&lt;/code&gt;) or any graphical character specific to the current C locale.</source>
          <target state="translated">Проверяет, имеет ли данный широкий символ графическое представление, т. Е. Является ли оно числом ( &lt;code&gt;0123456789&lt;/code&gt; ), заглавной буквой ( &lt;code&gt;ABCDEFGHIJKLMNOPQRSTUVWXYZ&lt;/code&gt; ), строчной буквой ( &lt;code&gt;abcdefghijklmnopqrstuvwxyz&lt;/code&gt; ), знаком пунктуации ( &lt;code&gt;!&quot;#$%&amp;amp;'()*+,-./:;&amp;lt;=&amp;gt;?@[\]^_`{|}~&lt;/code&gt; ) или любой графический символ, относящийся к текущей локали Си.</target>
        </trans-unit>
        <trans-unit id="69347e858d3166f00f30fe95f9dd5f5ae37bc816" translate="yes" xml:space="preserve">
          <source>Checks if the given wide character is a control character, i.e. codes &lt;code&gt;0x00-0x1F&lt;/code&gt; and &lt;code&gt;0x7F&lt;/code&gt; and any control characters specific to the current locale.</source>
          <target state="translated">Проверяет, является ли данный широкий символ управляющим символом, то есть кодами &lt;code&gt;0x00-0x1F&lt;/code&gt; и &lt;code&gt;0x7F&lt;/code&gt; , а также какими-либо управляющими символами, характерными для текущей локали.</target>
        </trans-unit>
        <trans-unit id="f75e93760224f49060fa9daae484b93562cec26c" translate="yes" xml:space="preserve">
          <source>Checks if the given wide character is a lowercase letter, i.e. one of &lt;code&gt;abcdefghijklmnopqrstuvwxyz&lt;/code&gt; or any lowercase letter specific to the current locale.</source>
          <target state="translated">Проверяет, является ли данный широкий символ строчной буквой, т. &lt;code&gt;abcdefghijklmnopqrstuvwxyz&lt;/code&gt; или любой строчной буквой, характерной для текущей локали.</target>
        </trans-unit>
        <trans-unit id="d3bc1df8c65e55dc36b4066a3cfbf00b5eb6d139" translate="yes" xml:space="preserve">
          <source>Checks if the given wide character is a punctuation character, i.e. it is one of &lt;code&gt;!&quot;#$%&amp;amp;'()*+,-./:;&amp;lt;=&amp;gt;?@[\]^_`{|}~&lt;/code&gt; or any punctuation character specific to the current locale.</source>
          <target state="translated">Проверяет, является ли данный широкий символ символом пунктуации, т. Е. Является ли он одним из &lt;code&gt;!&quot;#$%&amp;amp;'()*+,-./:;&amp;lt;=&amp;gt;?@[\]^_`{|}~&lt;/code&gt; Или любым другим символ пунктуации, специфичный для текущей локали.</target>
        </trans-unit>
        <trans-unit id="7082207d2a2725304cb1acc7985965ef85b95446" translate="yes" xml:space="preserve">
          <source>Checks if the given wide character is a wide whitespace character as classified by the currently installed C locale. In the default locale, the whitespace characters are the following:</source>
          <target state="translated">Проверяет,является ли данный широкий символ широким пробелом,классифицированным по текущей установленной локали C.В установленной по умолчанию локали пробельные символы являются следующими:</target>
        </trans-unit>
        <trans-unit id="ecee395d873139c5f79bbced8e5ab2094298ef99" translate="yes" xml:space="preserve">
          <source>Checks if the given wide character is an alphabetic character, i.e. either an uppercase letter (&lt;code&gt;ABCDEFGHIJKLMNOPQRSTUVWXYZ&lt;/code&gt;), a lowercase letter (&lt;code&gt;abcdefghijklmnopqrstuvwxyz&lt;/code&gt;) or any alphabetic character specific to the current locale.</source>
          <target state="translated">Проверяет, является ли данный широкий символ буквенным символом, то есть либо заглавной буквой ( &lt;code&gt;ABCDEFGHIJKLMNOPQRSTUVWXYZ&lt;/code&gt; ), строчной буквой ( &lt;code&gt;abcdefghijklmnopqrstuvwxyz&lt;/code&gt; ), либо любым буквенным символом, характерным для текущей локали.</target>
        </trans-unit>
        <trans-unit id="5467527cb982943f926960fa171baeacafcc85de" translate="yes" xml:space="preserve">
          <source>Checks if the given wide character is an alphanumeric character, i.e. either a number (&lt;code&gt;0123456789&lt;/code&gt;), an uppercase letter (&lt;code&gt;ABCDEFGHIJKLMNOPQRSTUVWXYZ&lt;/code&gt;), a lowercase letter (&lt;code&gt;abcdefghijklmnopqrstuvwxyz&lt;/code&gt;) or any alphanumeric character specific to the current locale.</source>
          <target state="translated">Проверяет, является ли данный широкий символ буквенно-цифровым символом, т. &lt;code&gt;0123456789&lt;/code&gt; ( 0123456789 ), заглавной буквой ( &lt;code&gt;ABCDEFGHIJKLMNOPQRSTUVWXYZ&lt;/code&gt; ), строчной буквой ( &lt;code&gt;abcdefghijklmnopqrstuvwxyz&lt;/code&gt; ) или любым буквенно-цифровым символом, характерным для текущей локали.</target>
        </trans-unit>
        <trans-unit id="43c33322c3d3cfbcbf8bd68f060fd927a3eb782d" translate="yes" xml:space="preserve">
          <source>Checks if the given wide character is an uppercase letter, i.e. one of &lt;code&gt;ABCDEFGHIJKLMNOPQRSTUVWXYZ&lt;/code&gt; or any uppercase letter specific to the current locale.</source>
          <target state="translated">Проверяет, является ли данный широкий символ заглавной буквой, то есть &lt;code&gt;ABCDEFGHIJKLMNOPQRSTUVWXYZ&lt;/code&gt; или любой заглавной буквой, характерной для текущей локали.</target>
        </trans-unit>
        <trans-unit id="1541b6076382859c29bdb454303ad0411f5bf188" translate="yes" xml:space="preserve">
          <source>Checks if the given wide character is classified as blank character (that is, a whitespace character used to separate words in a sentence) by the current C locale. In the default C locale, only space (&lt;code&gt;0x20&lt;/code&gt;) and horizontal tab (&lt;code&gt;0x09&lt;/code&gt;) are blank characters.</source>
          <target state="translated">Проверяет, классифицируется ли данный широкий символ как пустой символ (то есть символ пробела, используемый для разделения слов в предложении) в текущей локали языка C. В локали C по умолчанию только пробел ( &lt;code&gt;0x20&lt;/code&gt; ) и горизонтальная табуляция ( &lt;code&gt;0x09&lt;/code&gt; ) являются пустыми символами.</target>
        </trans-unit>
        <trans-unit id="5b129df05edbccc2dbdbb661453142c518a02f19" translate="yes" xml:space="preserve">
          <source>Checks if the identifier was &lt;a href=&quot;replace&quot;&gt;defined as a macro name&lt;/a&gt;.</source>
          <target state="translated">Проверяет, был ли идентификатор &lt;a href=&quot;replace&quot;&gt;определен как имя макроса&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="64cb0aa280d8c5b49543261dbfb062c65e2ea369" translate="yes" xml:space="preserve">
          <source>Checks if the locale &lt;code&gt;loc&lt;/code&gt; implements the facet &lt;code&gt;Facet&lt;/code&gt;.</source>
          <target state="translated">Проверяет, реализует ли локаль &lt;code&gt;loc&lt;/code&gt; фасет &lt;code&gt;Facet&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c9985c18b99c624309993b776322be3e5b6066d2" translate="yes" xml:space="preserve">
          <source>Checks if the month value stored in &lt;code&gt;*this&lt;/code&gt; is in the valid range, i.e., [1, 12].</source>
          <target state="translated">Проверяет, находится ли значение месяца, хранящееся в &lt;code&gt;*this&lt;/code&gt; в допустимом диапазоне, т. Е. [1, 12].</target>
        </trans-unit>
        <trans-unit id="f0dd7dcb8d83418ab5c1982a79ec6863927fac41" translate="yes" xml:space="preserve">
          <source>Checks if the objects refer to the same types.</source>
          <target state="translated">Проверяет,относятся ли объекты к одним и тем же типам.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
