<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="cpp">
    <body>
      <group id="cpp">
        <trans-unit id="fc058be4fe81eec42326824dea95a8995ba79311" translate="yes" xml:space="preserve">
          <source>The formal parameter of the catch clause (type-specifier-seq and declarator or type-specifier-seq and abstract-declarator) determines which types of exceptions cause this catch clause to be entered. It cannot be an &lt;a href=&quot;reference&quot;&gt;rvalue reference type&lt;/a&gt;, &lt;a href=&quot;abstract_class&quot;&gt;abstract class&lt;/a&gt;, &lt;a href=&quot;incomplete_type&quot;&gt;incomplete type&lt;/a&gt;, or pointer to incomplete type (except that pointers to (possibly &lt;a href=&quot;cv&quot;&gt;cv&lt;/a&gt;-qualified) &lt;code&gt;void&lt;/code&gt; are allowed). If the type of the formal parameter is array type or function type, it is treated as the corresponding pointer type (similar to a &lt;a href=&quot;function&quot;&gt;function declaration&lt;/a&gt;).</source>
          <target state="translated">Формальный параметр предложения catch (тип-спецификатор-seq и декларатор или тип-спецификатор-seq и абстрактный-декларатор) определяет, какие типы исключений вызывают ввод этого предложения. Это не может быть &lt;a href=&quot;reference&quot;&gt;ссылочный тип rvalue&lt;/a&gt; , &lt;a href=&quot;abstract_class&quot;&gt;абстрактный класс&lt;/a&gt; , &lt;a href=&quot;incomplete_type&quot;&gt;неполный тип&lt;/a&gt; или указатель на неполный тип (за исключением того, что разрешены указатели на (возможно, &lt;a href=&quot;cv&quot;&gt;cv&lt;/a&gt; -qualified) &lt;code&gt;void&lt;/code&gt; ). Если тип формального параметра - тип массива или тип функции, он обрабатывается как соответствующий тип указателя (аналогично &lt;a href=&quot;function&quot;&gt;объявлению функции&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="8c84fba53b093effe5342ab55502a277a5ffaba5" translate="yes" xml:space="preserve">
          <source>The format of &lt;code&gt;filename&lt;/code&gt; is implementation-defined, and does not necessarily refer to a file (e.g. it may be the console or another device accessible through filesystem API). On platforms that support them, &lt;code&gt;filename&lt;/code&gt; may include absolute or relative filesystem path.</source>
          <target state="translated">Формат имени &lt;code&gt;filename&lt;/code&gt; определяется реализацией и не обязательно относится к файлу (например, это может быть консоль или другое устройство, доступное через API файловой системы). На платформах, которые их поддерживают, &lt;code&gt;filename&lt;/code&gt; может содержать абсолютный или относительный путь файловой системы.</target>
        </trans-unit>
        <trans-unit id="19e13fb520e9b9f29460d58a00f41c09337dc08f" translate="yes" xml:space="preserve">
          <source>The format of floating-point values is as follows:</source>
          <target state="translated">Формат значений с плавающей точкой следующий:</target>
        </trans-unit>
        <trans-unit id="a0add987dacb96215da068df8fc467e3a8d4b58c" translate="yes" xml:space="preserve">
          <source>The format of the number is the same as expected by &lt;a href=&quot;../../string/byte/strtof&quot;&gt;&lt;code&gt;strtof()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Формат числа совпадает с ожидаемым &lt;a href=&quot;../../string/byte/strtof&quot;&gt; &lt;code&gt;strtof()&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c7a581065d0c8c103e51ec546cb2d29946e0e282" translate="yes" xml:space="preserve">
          <source>The format of the number is the same as expected by &lt;a href=&quot;../../string/byte/strtol&quot;&gt;&lt;code&gt;strtol()&lt;/code&gt;&lt;/a&gt; with the value &lt;code&gt;10&lt;/code&gt; for the &lt;code&gt;base&lt;/code&gt; argument.</source>
          <target state="translated">Формат числа совпадает с ожидаемым &lt;a href=&quot;../../string/byte/strtol&quot;&gt; &lt;code&gt;strtol()&lt;/code&gt; &lt;/a&gt; со значением &lt;code&gt;10&lt;/code&gt; для &lt;code&gt;base&lt;/code&gt; аргумента.</target>
        </trans-unit>
        <trans-unit id="de50d9c89fd0c551d172e90d35e19763d28aebed" translate="yes" xml:space="preserve">
          <source>The format of the number is the same as expected by &lt;a href=&quot;../../string/byte/strtol&quot;&gt;&lt;code&gt;strtol()&lt;/code&gt;&lt;/a&gt; with the value &lt;code&gt;​0​&lt;/code&gt; for the &lt;code&gt;base&lt;/code&gt; argument (base is determined by the first characters parsed).</source>
          <target state="translated">Формат числа такой же , как и следовало ожидать от &lt;a href=&quot;../../string/byte/strtol&quot;&gt; &lt;code&gt;strtol()&lt;/code&gt; &lt;/a&gt; со значением &lt;code&gt;​0​&lt;/code&gt; для &lt;code&gt;base&lt;/code&gt; аргумента (база определяется с помощью первых символов разбираемых).</target>
        </trans-unit>
        <trans-unit id="f009580f6110aee4f2a9398c68d1bf94787198b5" translate="yes" xml:space="preserve">
          <source>The format of the number is the same as expected by &lt;a href=&quot;../../string/byte/strtoul&quot;&gt;&lt;code&gt;strtoul()&lt;/code&gt;&lt;/a&gt; with the value &lt;code&gt;10&lt;/code&gt; for the &lt;code&gt;base&lt;/code&gt; argument.</source>
          <target state="translated">Формат числа совпадает с ожидаемым &lt;a href=&quot;../../string/byte/strtoul&quot;&gt; &lt;code&gt;strtoul()&lt;/code&gt; &lt;/a&gt; со значением &lt;code&gt;10&lt;/code&gt; для &lt;code&gt;base&lt;/code&gt; аргумента.</target>
        </trans-unit>
        <trans-unit id="48ec45a6a03f7559d556421a2a44ac148d321b20" translate="yes" xml:space="preserve">
          <source>The format of the number is the same as expected by &lt;a href=&quot;../../string/byte/strtoul&quot;&gt;&lt;code&gt;strtoul()&lt;/code&gt;&lt;/a&gt; with the value &lt;code&gt;16&lt;/code&gt; for the &lt;code&gt;base&lt;/code&gt; argument.</source>
          <target state="translated">Формат числа совпадает с ожидаемым &lt;a href=&quot;../../string/byte/strtoul&quot;&gt; &lt;code&gt;strtoul()&lt;/code&gt; &lt;/a&gt; со значением &lt;code&gt;16&lt;/code&gt; для &lt;code&gt;base&lt;/code&gt; аргумента.</target>
        </trans-unit>
        <trans-unit id="bb05ad1877111e85c5dfa1d9f5bf199cff8a0c43" translate="yes" xml:space="preserve">
          <source>The format of the number is the same as expected by &lt;a href=&quot;../../string/byte/strtoul&quot;&gt;&lt;code&gt;strtoul()&lt;/code&gt;&lt;/a&gt; with the value &lt;code&gt;8&lt;/code&gt; for the &lt;code&gt;base&lt;/code&gt; argument.</source>
          <target state="translated">Формат числа совпадает с ожидаемым &lt;a href=&quot;../../string/byte/strtoul&quot;&gt; &lt;code&gt;strtoul()&lt;/code&gt; &lt;/a&gt; со значением &lt;code&gt;8&lt;/code&gt; для &lt;code&gt;base&lt;/code&gt; аргумента.</target>
        </trans-unit>
        <trans-unit id="f5976eb1d0b6e29b5c32d55d187559f6ff886126" translate="yes" xml:space="preserve">
          <source>The format of the number is the same as expected by &lt;a href=&quot;../../string/wide/wcstof&quot;&gt;&lt;code&gt;wcstof()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Формат числа такой же, как ожидалось от &lt;a href=&quot;../../string/wide/wcstof&quot;&gt; &lt;code&gt;wcstof()&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="fecd04092122729704233da78da7584029c1baf0" translate="yes" xml:space="preserve">
          <source>The format of the number is the same as expected by &lt;a href=&quot;../../string/wide/wcstol&quot;&gt;&lt;code&gt;wcstol()&lt;/code&gt;&lt;/a&gt; with the value &lt;code&gt;10&lt;/code&gt; for the &lt;code&gt;base&lt;/code&gt; argument.</source>
          <target state="translated">Формат числа совпадает с ожидаемым &lt;a href=&quot;../../string/wide/wcstol&quot;&gt; &lt;code&gt;wcstol()&lt;/code&gt; &lt;/a&gt; со значением &lt;code&gt;10&lt;/code&gt; для &lt;code&gt;base&lt;/code&gt; аргумента.</target>
        </trans-unit>
        <trans-unit id="5bb104d61d7e8e7ed04a16c3daae6cd68cca3601" translate="yes" xml:space="preserve">
          <source>The format of the number is the same as expected by &lt;a href=&quot;../../string/wide/wcstol&quot;&gt;&lt;code&gt;wcstol()&lt;/code&gt;&lt;/a&gt; with the value &lt;code&gt;​0​&lt;/code&gt; for the &lt;code&gt;base&lt;/code&gt; argument (base is determined by the first characters parsed).</source>
          <target state="translated">Формат числа такой же , как и следовало ожидать от &lt;a href=&quot;../../string/wide/wcstol&quot;&gt; &lt;code&gt;wcstol()&lt;/code&gt; &lt;/a&gt; со значением &lt;code&gt;​0​&lt;/code&gt; для &lt;code&gt;base&lt;/code&gt; аргумента (база определяется с помощью первых символов разбираемых).</target>
        </trans-unit>
        <trans-unit id="90f5746e8bc2a7796c8836cbdbee3ca457ca3f47" translate="yes" xml:space="preserve">
          <source>The format of the number is the same as expected by &lt;a href=&quot;../../string/wide/wcstoul&quot;&gt;&lt;code&gt;wcstoul()&lt;/code&gt;&lt;/a&gt; with the value &lt;code&gt;10&lt;/code&gt; for the &lt;code&gt;base&lt;/code&gt; argument.</source>
          <target state="translated">Формат числа совпадает с ожидаемым &lt;a href=&quot;../../string/wide/wcstoul&quot;&gt; &lt;code&gt;wcstoul()&lt;/code&gt; &lt;/a&gt; со значением &lt;code&gt;10&lt;/code&gt; для &lt;code&gt;base&lt;/code&gt; аргумента.</target>
        </trans-unit>
        <trans-unit id="c174dea8f8ac6d3123fee439903c3ea47dd4f027" translate="yes" xml:space="preserve">
          <source>The format of the number is the same as expected by &lt;a href=&quot;../../string/wide/wcstoul&quot;&gt;&lt;code&gt;wcstoul()&lt;/code&gt;&lt;/a&gt; with the value &lt;code&gt;16&lt;/code&gt; for the &lt;code&gt;base&lt;/code&gt; argument.</source>
          <target state="translated">Формат числа совпадает с ожидаемым &lt;a href=&quot;../../string/wide/wcstoul&quot;&gt; &lt;code&gt;wcstoul()&lt;/code&gt; &lt;/a&gt; со значением &lt;code&gt;16&lt;/code&gt; для &lt;code&gt;base&lt;/code&gt; аргумента.</target>
        </trans-unit>
        <trans-unit id="f5eb1aae953e6c6c5362653e5973307871541db0" translate="yes" xml:space="preserve">
          <source>The format of the number is the same as expected by &lt;a href=&quot;../../string/wide/wcstoul&quot;&gt;&lt;code&gt;wcstoul()&lt;/code&gt;&lt;/a&gt; with the value &lt;code&gt;8&lt;/code&gt; for the &lt;code&gt;base&lt;/code&gt; argument.</source>
          <target state="translated">Формат числа совпадает с ожидаемым &lt;a href=&quot;../../string/wide/wcstoul&quot;&gt; &lt;code&gt;wcstoul()&lt;/code&gt; &lt;/a&gt; со значением &lt;code&gt;8&lt;/code&gt; для &lt;code&gt;base&lt;/code&gt; аргумента.</target>
        </trans-unit>
        <trans-unit id="3d9e18bdb76f0cfc72cfc7220ca845cba830ae2b" translate="yes" xml:space="preserve">
          <source>The format string consists of ordinary multibyte characters (except &lt;code&gt;%&lt;/code&gt;), which are copied unchanged into the output stream, and conversion specifications. Each conversion specification has the following format:</source>
          <target state="translated">Строка формата состоит из обычных многобайтовых символов (кроме &lt;code&gt;%&lt;/code&gt; ), которые копируются без изменений в выходной поток, и спецификаций преобразования. Каждая спецификация преобразования имеет следующий формат:</target>
        </trans-unit>
        <trans-unit id="978f5198d804b9a4148d59f23d49bd19f235af7b" translate="yes" xml:space="preserve">
          <source>The format string consists of ordinary wide characters (except &lt;code&gt;%&lt;/code&gt;), which are copied unchanged into the output stream, and conversion specifications. Each conversion specification has the following format:</source>
          <target state="translated">Строка формата состоит из обычных широких символов (кроме &lt;code&gt;%&lt;/code&gt; ), которые копируются без изменений в выходной поток, и спецификаций преобразования. Каждая спецификация преобразования имеет следующий формат:</target>
        </trans-unit>
        <trans-unit id="77ae2a1ebbf9dfc51f6f5d5f89c9ab7a18fe650c" translate="yes" xml:space="preserve">
          <source>The format string consists of zero or more conversion specifiers and ordinary characters (except &lt;code&gt;%&lt;/code&gt;). All ordinary characters, including the terminating null character, are copied to the output string without modification. Each conversion specification begins with &lt;code&gt;%&lt;/code&gt; character, optionally followed by &lt;code&gt;E&lt;/code&gt; or &lt;code&gt;O&lt;/code&gt; modifier (ignored if unsupported by the locale), followed by the character that determines the behavior of the specifier. The following format specifiers are available:</source>
          <target state="translated">Строка формата состоит из нуля или более спецификаторов преобразования и обычных символов (кроме &lt;code&gt;%&lt;/code&gt; ). Все обычные символы, включая завершающий нулевой символ, копируются в выходную строку без изменений. Каждая спецификация преобразования начинается с символа &lt;code&gt;%&lt;/code&gt; , за которым необязательно следует модификатор &lt;code&gt;E&lt;/code&gt; или &lt;code&gt;O&lt;/code&gt; (игнорируется, если языковой стандарт не поддерживается), за которым следует символ, определяющий поведение спецификатора. Доступны следующие спецификаторы формата:</target>
        </trans-unit>
        <trans-unit id="f2ac326d01048c042fad765ae54487eb3b38a164" translate="yes" xml:space="preserve">
          <source>The format string consists of zero or more conversion specifiers and ordinary characters. All ordinary characters, excluding the terminating null character, are written into the output stream without modification. Each unmodified conversion specifier begins with a &lt;code&gt;%&lt;/code&gt; character followed by a character that determines the behavior of the specifier. Some conversion specifiers have a modified form in which an &lt;code&gt;E&lt;/code&gt; or &lt;code&gt;O&lt;/code&gt; modifier character is inserted after the &lt;code&gt;%&lt;/code&gt; character. Each conversion specifier is replaced by appropriate characters in the output as described below.</source>
          <target state="translated">Строка формата состоит из нуля или более спецификаторов преобразования и обычных символов. Все обычные символы, за исключением завершающего нулевого символа, записываются в выходной поток без изменений. Каждый неизмененный спецификатор преобразования начинается с символа &lt;code&gt;%&lt;/code&gt; , за которым следует символ, определяющий поведение спецификатора. Некоторые спецификаторы преобразования имеют измененную форму, в которой символ модификатора &lt;code&gt;E&lt;/code&gt; или &lt;code&gt;O&lt;/code&gt; вставляется после символа &lt;code&gt;%&lt;/code&gt; . Каждый спецификатор преобразования заменяется соответствующими символами в выходных данных, как описано ниже.</target>
        </trans-unit>
        <trans-unit id="3945cb192e1c3a5530627de4981979e1dedb2322" translate="yes" xml:space="preserve">
          <source>The format string consists of zero or more conversion specifiers and ordinary characters. Each ordinary character, excluding whitespace characters and the terminating null character, matches one identical character from the input stream, or causes the function to fail if the next character on the stream does not compare equal.</source>
          <target state="translated">Строка формата состоит из нуля и более спецификаторов преобразования и обычных символов.Каждый обычный символ,исключая символы пробела и завершающий нулевой символ,совпадает с одним идентичным символом из входного потока или приводит к отказу функции,если следующий символ в потоке не совпадает.</target>
        </trans-unit>
        <trans-unit id="ae378d353693d1c7d74c4fd94775d83dcaefd506" translate="yes" xml:space="preserve">
          <source>The format string consists of zero or more conversion specifiers, whitespace characters, and ordinary characters (except &lt;code&gt;%&lt;/code&gt;). Each ordinary character is expected to match one character in the input stream in case-insensitive comparison. Each whitespace character matches arbitrary whitespace in the input string. Each conversion specification begins with &lt;code&gt;%&lt;/code&gt; character, optionally followed by &lt;code&gt;E&lt;/code&gt; or &lt;code&gt;O&lt;/code&gt; modifier (ignored if unsupported by the locale), followed by the character that determines the behavior of the specifier. The format specifiers match the POSIX function &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/strptime.html&quot;&gt;strptime()&lt;/a&gt;:</source>
          <target state="translated">Строка формата состоит из нуля или более спецификаторов преобразования, пробельных символов и обычных символов (кроме &lt;code&gt;%&lt;/code&gt; ). Ожидается, что каждый обычный символ будет соответствовать одному символу во входном потоке при сравнении без учета регистра. Каждый символ пробела соответствует произвольному пробелу во входной строке. Каждая спецификация преобразования начинается с символа &lt;code&gt;%&lt;/code&gt; , за которым необязательно следует модификатор &lt;code&gt;E&lt;/code&gt; или &lt;code&gt;O&lt;/code&gt; (игнорируется, если языковой стандарт не поддерживается), за которым следует символ, определяющий поведение спецификатора. Спецификаторы формата соответствуют функции POSIX &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/strptime.html&quot;&gt;strptime ()&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="27b600c5cf47587815343dd3f9cb052e7b9ecfa5" translate="yes" xml:space="preserve">
          <source>The format string consists of zero or more conversion specifiers, whitespace characters, and ordinary characters (except &lt;code&gt;%&lt;/code&gt;). Each ordinary character is expected to match one character in the input stream in case-insensitive comparison. Each whitespace character matches arbitrary whitespace in the input string. Each conversion specification begins with &lt;code&gt;%&lt;/code&gt; character, optionally followed by &lt;code&gt;E&lt;/code&gt; or &lt;code&gt;O&lt;/code&gt; modifier (ignored if unsupported by the locale), followed by the character that determines the behavior of the specifier. The format specifiers match the POSIX function &lt;a href=&quot;https://pubs.opengroup.org/onlinepubs/9699919799/functions/strptime.html&quot;&gt;strptime()&lt;/a&gt;:</source>
          <target state="translated">Строка формата состоит из нуля или более спецификаторов преобразования, пробелов и обычных символов (кроме &lt;code&gt;%&lt;/code&gt; ). Ожидается, что каждый обычный символ будет соответствовать одному символу во входном потоке при сравнении без учета регистра. Каждый пробельный символ соответствует произвольному пробелу во входной строке. Каждая спецификация преобразования начинается с символа &lt;code&gt;%&lt;/code&gt; , за которым необязательно следует модификатор &lt;code&gt;E&lt;/code&gt; или &lt;code&gt;O&lt;/code&gt; (игнорируется, если он не поддерживается локалью), за которым следует символ, определяющий поведение спецификатора. Спецификаторы формата соответствуют функции &lt;a href=&quot;https://pubs.opengroup.org/onlinepubs/9699919799/functions/strptime.html&quot;&gt;strptime ()&lt;/a&gt; POSIX :</target>
        </trans-unit>
        <trans-unit id="5d35574333561b6d7197206a894209f7b4dca21b" translate="yes" xml:space="preserve">
          <source>The format string consists of.</source>
          <target state="translated">Строка формата состоит из.</target>
        </trans-unit>
        <trans-unit id="f557203d9607d6c00cf9156c3eb7b68888a42acd" translate="yes" xml:space="preserve">
          <source>The formatting &lt;code&gt;&lt;a href=&quot;../money_base&quot;&gt;pattern&lt;/a&gt;&lt;/code&gt; used by this function is always &lt;code&gt;mp.neg_format()&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../money_base&quot;&gt;pattern&lt;/a&gt;&lt;/code&gt; форматирования , используемый этой функцией, всегда &lt;code&gt;mp.neg_format()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="36de08c85d1411e27803f51f67e99c60bb0859a9" translate="yes" xml:space="preserve">
          <source>The friend declaration appears in a &lt;a href=&quot;class&quot;&gt;class body&lt;/a&gt; and grants a function or another class access to private and protected members of the class where the friend declaration appears.</source>
          <target state="translated">Объявление друга появляется в &lt;a href=&quot;class&quot;&gt;теле класса&lt;/a&gt; и предоставляет функции или другому классу доступ к закрытым и защищенным членам класса, в котором появляется объявление друга.</target>
        </trans-unit>
        <trans-unit id="f1e777bed230647173e4ad51c340e8839794d4c2" translate="yes" xml:space="preserve">
          <source>The full contents of a floating-point exception flag is not necessarily a boolean value indicating whether the exception is raised or cleared. For example, it may be a struct which includes the boolean status and the address of the code that triggered the exception. These functions obtain all such content and obtain/store it in &lt;code&gt;flagp&lt;/code&gt; in implementation-defined format.</source>
          <target state="translated">Полное содержание флага исключения с плавающей точкой не обязательно является логическим значением, указывающим, было ли исключение возбуждено или очищено. Например, это может быть структура, которая включает логическое состояние и адрес кода, вызвавшего исключение. Эти функции получают весь такой контент и получают / сохраняют его в &lt;code&gt;flagp&lt;/code&gt; в формате, определяемом реализацией.</target>
        </trans-unit>
        <trans-unit id="3f3faeb997d1ed337e80e4abb047a6ba3e3e7ebc" translate="yes" xml:space="preserve">
          <source>The full path the directory entry refers to.</source>
          <target state="translated">Полный путь,к которому относится запись записной книжки.</target>
        </trans-unit>
        <trans-unit id="3d6b6fb5d314fe36dd9f31283cfc562903b69b1f" translate="yes" xml:space="preserve">
          <source>The function (or member) name specified by &lt;code&gt;E&lt;/code&gt; can be overloaded, &lt;a href=&quot;overload_resolution&quot;&gt;overload resolution&lt;/a&gt; rules used to decide which overload is to be called.</source>
          <target state="translated">Имя функции (или члена), указанное &lt;code&gt;E&lt;/code&gt; , может быть перегружено, правила &lt;a href=&quot;overload_resolution&quot;&gt;разрешения перегрузки&lt;/a&gt; используются для определения, какая перегрузка должна быть вызвана.</target>
        </trans-unit>
        <trans-unit id="e82b0b07e6f429ee9f9368f05dad9fa0ba43d37a" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;TC::now()&lt;/code&gt; does not throw exceptions.</source>
          <target state="translated">Функция &lt;code&gt;TC::now()&lt;/code&gt; не генерирует исключения.</target>
        </trans-unit>
        <trans-unit id="0e4cb90e10ef6ef7003e78c1e00b67a01ecdf0f5" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;canonical()&lt;/code&gt; is modeled after the POSIX &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/realpath.html&quot;&gt;realpath&lt;/a&gt;.</source>
          <target state="translated">Функция &lt;code&gt;canonical()&lt;/code&gt; моделируется по &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/realpath.html&quot;&gt;реальному&lt;/a&gt; пути POSIX .</target>
        </trans-unit>
        <trans-unit id="a8f8abebb05723f10583ccaaf0c51e54fca3aa87" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;canonical()&lt;/code&gt; is modeled after the POSIX &lt;a href=&quot;https://pubs.opengroup.org/onlinepubs/9699919799/functions/realpath.html&quot;&gt;realpath&lt;/a&gt;.</source>
          <target state="translated">Функция &lt;code&gt;canonical()&lt;/code&gt; смоделирована на основе &lt;a href=&quot;https://pubs.opengroup.org/onlinepubs/9699919799/functions/realpath.html&quot;&gt;реального&lt;/a&gt; пути POSIX .</target>
        </trans-unit>
        <trans-unit id="83d5158312c85ad69a25e7f6c7b3eb92ed2aac66" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;std::frexp&lt;/code&gt;, together with its dual, &lt;code&gt;&lt;a href=&quot;ldexp&quot;&gt;std::ldexp&lt;/a&gt;&lt;/code&gt;, can be used to manipulate the representation of a floating-point number without direct bit manipulations.</source>
          <target state="translated">Функция &lt;code&gt;std::frexp&lt;/code&gt; вместе со своим двойным &lt;code&gt;&lt;a href=&quot;ldexp&quot;&gt;std::ldexp&lt;/a&gt;&lt;/code&gt; может использоваться для манипулирования представлением числа с плавающей точкой без прямых битовых манипуляций.</target>
        </trans-unit>
        <trans-unit id="7a6d7907ee719b354792f98bec95c1316c2a0690" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;std::ldexp&lt;/code&gt; (&quot;load exponent&quot;), together with its dual, &lt;code&gt;&lt;a href=&quot;frexp&quot;&gt;std::frexp&lt;/a&gt;&lt;/code&gt;, can be used to manipulate the representation of a floating-point number without direct bit manipulations.</source>
          <target state="translated">Функция &lt;code&gt;std::ldexp&lt;/code&gt; (&amp;laquo;показатель степени загрузки&amp;raquo;) вместе со своим двойным &lt;code&gt;&lt;a href=&quot;frexp&quot;&gt;std::frexp&lt;/a&gt;&lt;/code&gt; может использоваться для манипулирования представлением числа с плавающей точкой без прямых битовых манипуляций.</target>
        </trans-unit>
        <trans-unit id="57c5dfaac85f79a223adb7359ed5cef42e000f8a" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;weakly_canonical()&lt;/code&gt; was introduced to simplify operational semantics of &lt;a href=&quot;relative&quot;&gt;&lt;code&gt;relative()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Функция &lt;code&gt;weakly_canonical()&lt;/code&gt; была введена для упрощения операционной семантики &lt;a href=&quot;relative&quot;&gt; &lt;code&gt;relative()&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="65499eb81228ba91e476f471dc5abca02679437e" translate="yes" xml:space="preserve">
          <source>The function accepts (and does nothing with) the null pointer to reduce the amount of special-casing. Whether allocation succeeds or not, the pointer returned by an allocation function can be passed to &lt;code&gt;std::free&lt;/code&gt;.</source>
          <target state="translated">Функция принимает (и ничего не делает) нулевой указатель, чтобы уменьшить количество специальных регистров. Независимо от того, успешно ли выполнено выделение, указатель, возвращаемый функцией выделения, может быть передан в &lt;code&gt;std::free&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2446536a1064ed7b3941beeb277b791515eaa68b" translate="yes" xml:space="preserve">
          <source>The function body is a &lt;a href=&quot;statements#Compound_statements&quot;&gt;compound statement&lt;/a&gt; (sequence of zero or more statements surrounded by a pair of curly braces), which is executed when the function call is made.</source>
          <target state="translated">Тело функции представляет собой &lt;a href=&quot;statements#Compound_statements&quot;&gt;составной оператор&lt;/a&gt; (последовательность из нуля или более операторов, окруженных парой фигурных скобок), который выполняется при выполнении вызова функции.</target>
        </trans-unit>
        <trans-unit id="c3d08aba422a7497ce575560818de2b5e3664ee2" translate="yes" xml:space="preserve">
          <source>The function call expressions have the form.</source>
          <target state="translated">Выражения вызова функций имеют форму.</target>
        </trans-unit>
        <trans-unit id="ef5f5323e424bfd7a1f80cd467bc80719cc4bc17" translate="yes" xml:space="preserve">
          <source>The function called by a user-defined literal is known as</source>
          <target state="translated">Функция,вызываемая определяемым пользователем литералом,известна как</target>
        </trans-unit>
        <trans-unit id="21d35ce53dec97b605e35fbf4bfeaf3e6b25267e" translate="yes" xml:space="preserve">
          <source>The function calls &lt;code&gt;&lt;a href=&quot;sbumpc&quot;&gt;sbumpc()&lt;/a&gt;&lt;/code&gt; to advance the input sequence. If that function returns &lt;code&gt;Traits::eof()&lt;/code&gt; meaning that input sequence has been exhausted and &lt;code&gt;&lt;a href=&quot;uflow&quot;&gt;uflow()&lt;/a&gt;&lt;/code&gt; could not retrieve more data, &lt;code&gt;Traits::eof()&lt;/code&gt; is returned. Otherwise &lt;code&gt;&lt;a href=&quot;sgetc&quot;&gt;sgetc()&lt;/a&gt;&lt;/code&gt; is called in order to read the character.</source>
          <target state="translated">Функция вызывает &lt;code&gt;&lt;a href=&quot;sbumpc&quot;&gt;sbumpc()&lt;/a&gt;&lt;/code&gt; для продвижения последовательности ввода. Если эта функция возвращает &lt;code&gt;Traits::eof()&lt;/code&gt; что означает, что входная последовательность исчерпана и &lt;code&gt;&lt;a href=&quot;uflow&quot;&gt;uflow()&lt;/a&gt;&lt;/code&gt; не может получить больше данных, &lt;code&gt;Traits::eof()&lt;/code&gt; . В противном случае &lt;code&gt;&lt;a href=&quot;sgetc&quot;&gt;sgetc()&lt;/a&gt;&lt;/code&gt; для чтения символа.</target>
        </trans-unit>
        <trans-unit id="e8f1319f9d6ef5782692a77b9fd4057196ea681b" translate="yes" xml:space="preserve">
          <source>The function can be implemented with the return type different from &lt;code&gt;&lt;a href=&quot;../valarray&quot;&gt;std::valarray&lt;/a&gt;&lt;/code&gt;. In this case, the replacement type has the following properties:</source>
          <target state="translated">Функция может быть реализована с типом возвращаемого значения, отличным от &lt;code&gt;&lt;a href=&quot;../valarray&quot;&gt;std::valarray&lt;/a&gt;&lt;/code&gt; . В этом случае тип замены имеет следующие свойства:</target>
        </trans-unit>
        <trans-unit id="c822a40a4534bfa3e5439e5ab35928c6a3a344b3" translate="yes" xml:space="preserve">
          <source>The function can be used only if &lt;code&gt;operator&amp;lt;&lt;/code&gt; is defined for type &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">Функция может быть использована только тогда , когда &lt;code&gt;operator&amp;lt;&lt;/code&gt; определен для типа &lt;code&gt;T&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="882d329b93dcad39ff502adfce6844369dd33e8b" translate="yes" xml:space="preserve">
          <source>The function can be used only if &lt;code&gt;operator+=&lt;/code&gt; is defined for type &lt;code&gt;T&lt;/code&gt;. If the &lt;code&gt;std::valarray&lt;/code&gt; is empty, the behavior is undefined. The order in which the elements are processed by this function is unspecified.</source>
          <target state="translated">Функцию можно использовать только в том случае, если для типа &lt;code&gt;T&lt;/code&gt; определен &lt;code&gt;operator+=&lt;/code&gt; . Если &lt;code&gt;std::valarray&lt;/code&gt; пуст, поведение не определено. Порядок, в котором элементы обрабатываются этой функцией, не указан.</target>
        </trans-unit>
        <trans-unit id="91f7fe88eabe258e81ae01d0f690791e30dabd0d" translate="yes" xml:space="preserve">
          <source>The function does not participate in overload resolution unless &lt;code&gt;ToDuration&lt;/code&gt; is an instance of &lt;code&gt;&lt;a href=&quot;../duration&quot;&gt;std::chrono::duration&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Функция не участвует в разрешении перегрузки, если &lt;code&gt;ToDuration&lt;/code&gt; не является экземпляром &lt;code&gt;&lt;a href=&quot;../duration&quot;&gt;std::chrono::duration&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b0d7738f85da6ab4917bf056d0bb5e776378bfa8" translate="yes" xml:space="preserve">
          <source>The function does not participate in the overload resolution unless &lt;code&gt;&lt;a href=&quot;../../types/numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;Rep&amp;gt;::is_signed&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">Функция не участвует в разрешении перегрузки, если &lt;code&gt;&lt;a href=&quot;../../types/numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;Rep&amp;gt;::is_signed&lt;/code&gt; имеет значение &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3f53989ed7fe6b85b91be67846d454e5a5091efc" translate="yes" xml:space="preserve">
          <source>The function does not participate in the overload resolution unless &lt;code&gt;ToDuration&lt;/code&gt; is an instance of &lt;code&gt;&lt;a href=&quot;../duration&quot;&gt;std::chrono::duration&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../treat_as_floating_point&quot;&gt;std::chrono::treat_as_floating_point&lt;/a&gt;&amp;lt;typename ToDuration::rep&amp;gt;::value&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">Функция не участвует в разрешении перегрузки, если &lt;code&gt;ToDuration&lt;/code&gt; не является экземпляром &lt;code&gt;&lt;a href=&quot;../duration&quot;&gt;std::chrono::duration&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;../treat_as_floating_point&quot;&gt;std::chrono::treat_as_floating_point&lt;/a&gt;&amp;lt;typename ToDuration::rep&amp;gt;::value&lt;/code&gt; равно &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2bf9d721422f351f851c897408c2ce6f0621c92c" translate="yes" xml:space="preserve">
          <source>The function does not participate in the overload resolution unless &lt;code&gt;ToDuration&lt;/code&gt; is an instance of &lt;code&gt;&lt;a href=&quot;../duration&quot;&gt;std::chrono::duration&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Функция не участвует в разрешении перегрузки, если &lt;code&gt;ToDuration&lt;/code&gt; не является экземпляром &lt;code&gt;&lt;a href=&quot;../duration&quot;&gt;std::chrono::duration&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="38127f74fcf3c7345c5f5fdb8dc95f19e70fd613" translate="yes" xml:space="preserve">
          <source>The function does not participate in the overload resolution unless &lt;code&gt;ToDuration&lt;/code&gt; is an specialization of &lt;code&gt;&lt;a href=&quot;../duration&quot;&gt;std::chrono::duration&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../treat_as_floating_point&quot;&gt;std::chrono::treat_as_floating_point&lt;/a&gt;&amp;lt;typename ToDuration::rep&amp;gt;::value&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">Функция не участвует в разрешении перегрузки , если &lt;code&gt;ToDuration&lt;/code&gt; не является специализация &lt;code&gt;&lt;a href=&quot;../duration&quot;&gt;std::chrono::duration&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;../treat_as_floating_point&quot;&gt;std::chrono::treat_as_floating_point&lt;/a&gt;&amp;lt;typename ToDuration::rep&amp;gt;::value&lt;/code&gt; является &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4dd86d349303d51526c774f537efd9b40b552f98" translate="yes" xml:space="preserve">
          <source>The function does not participate in the overload resolution unless &lt;code&gt;ToDuration&lt;/code&gt; is an specialization of &lt;code&gt;&lt;a href=&quot;../duration&quot;&gt;std::chrono::duration&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Функция не участвует в разрешении перегрузки, если &lt;code&gt;ToDuration&lt;/code&gt; не является специализацией &lt;code&gt;&lt;a href=&quot;../duration&quot;&gt;std::chrono::duration&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="126f425397cb45dc94e0836b07e8eefad9995278" translate="yes" xml:space="preserve">
          <source>The function does not support localization, and the newline character cannot be removed.</source>
          <target state="translated">Функция не поддерживает локализацию,и символ новой строки не может быть удален.</target>
        </trans-unit>
        <trans-unit id="072cec0bee6f6155df5b228611698b2538fe2d6d" translate="yes" xml:space="preserve">
          <source>The function does not support localization.</source>
          <target state="translated">Функция не поддерживает локализацию.</target>
        </trans-unit>
        <trans-unit id="b9ca2d431e6b4c994632d537c675b64adb91091c" translate="yes" xml:space="preserve">
          <source>The function drops any effects from previous calls to &lt;code&gt;ungetc&lt;/code&gt;.</source>
          <target state="translated">Функция сбрасывает любые эффекты от предыдущих вызовов в &lt;code&gt;ungetc&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="23ccd8cd43cb3d597e337e15d54fe5c87828b3ec" translate="yes" xml:space="preserve">
          <source>The function has mathematical poles at &amp;pi;(1/2 + n); however no common floating-point representation is able to represent &amp;pi;/2 exactly, thus there is no value of the argument for which a pole error occurs.</source>
          <target state="translated">Функция имеет математические полюсы в точке &amp;pi; (1/2 + n); однако никакое общее представление с плавающей точкой не может точно представить &amp;pi; / 2, поэтому нет значения аргумента, для которого возникает ошибка полюса.</target>
        </trans-unit>
        <trans-unit id="af880fe541df16b2fd4a74d41e9903882d62887d" translate="yes" xml:space="preserve">
          <source>The function is continuous onto the branch cut taking into account the sign of imaginary part</source>
          <target state="translated">Функция непрерывна на отрезке ветви с учетом знака воображаемой части.</target>
        </trans-unit>
        <trans-unit id="064517df7162e7c80b05f70d0c1d72dcf596b5e9" translate="yes" xml:space="preserve">
          <source>The function is equivalent to &lt;code&gt;&lt;a href=&quot;fseek&quot;&gt;std::fseek&lt;/a&gt;(stream, 0, &lt;a href=&quot;../c&quot;&gt;SEEK_SET&lt;/a&gt;);&lt;/code&gt;, except that end-of-file and error indicators are cleared.</source>
          <target state="translated">Функция эквивалентна &lt;code&gt;&lt;a href=&quot;fseek&quot;&gt;std::fseek&lt;/a&gt;(stream, 0, &lt;a href=&quot;../c&quot;&gt;SEEK_SET&lt;/a&gt;);&lt;/code&gt; за исключением того, что индикаторы конца файла и ошибки очищаются.</target>
        </trans-unit>
        <trans-unit id="75e35cecac837fab428a324853818b53ded0ac11" translate="yes" xml:space="preserve">
          <source>The function is named after the integer function ⍳ from the programming language APL. It was one of the &lt;a href=&quot;http://www.sgi.com/tech/stl/iota.html&quot;&gt;STL components&lt;/a&gt; that were not included in C++98, but eventually made it into the standard library in C++11.</source>
          <target state="translated">Функция названа в честь целочисленной функции ⍳ из языка программирования APL. Это был один из &lt;a href=&quot;http://www.sgi.com/tech/stl/iota.html&quot;&gt;компонентов STL&lt;/a&gt; , которые не были включены в C ++ 98, но в конечном итоге вошли в стандартную библиотеку в C ++ 11.</target>
        </trans-unit>
        <trans-unit id="fe1dff5e844a0cf75859a0d38601b66527b350d8" translate="yes" xml:space="preserve">
          <source>The function is named after the integer function ⍳ from the programming language APL. It was one of the &lt;a href=&quot;https://www.sgi.com/tech/stl/iota.html&quot;&gt;STL components&lt;/a&gt; that were not included in C++98, but eventually made it into the standard library in C++11.</source>
          <target state="translated">Функция названа в честь целочисленной функции ⍳ из языка программирования APL. Это был один из &lt;a href=&quot;https://www.sgi.com/tech/stl/iota.html&quot;&gt;компонентов STL,&lt;/a&gt; который не был включен в C ++ 98, но в конечном итоге вошел в стандартную библиотеку в C ++ 11.</target>
        </trans-unit>
        <trans-unit id="e9eb4c7699e43ce8f08f56257eff79ffdcf27b49" translate="yes" xml:space="preserve">
          <source>The function is not required to be defined for |x|&amp;gt;1</source>
          <target state="translated">Функция не должна быть определена для | x |&amp;gt; 1</target>
        </trans-unit>
        <trans-unit id="b0d406efcda5923258fa6e7ba435edf7afdbb66b" translate="yes" xml:space="preserve">
          <source>The function is only required to be defined where both &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; are greater than zero, and is allowed to report a domain error otherwise.</source>
          <target state="translated">Функция должна быть определена только тогда, когда &lt;code&gt;x&lt;/code&gt; и &lt;code&gt;y&lt;/code&gt; больше нуля, и в противном случае ей разрешено сообщать об ошибке домена.</target>
        </trans-unit>
        <trans-unit id="6034c35371ebcc562e4d00c27057a576e4fdd7db" translate="yes" xml:space="preserve">
          <source>The function may update &lt;code&gt;gptr&lt;/code&gt;, &lt;code&gt;egptr&lt;/code&gt; and &lt;code&gt;eback&lt;/code&gt; pointers to define the location of newly loaded data (if any). On failure, the function ensures that either &lt;code&gt;gptr() == nullptr&lt;/code&gt; or &lt;code&gt;gptr() == egptr&lt;/code&gt;.</source>
          <target state="translated">Функция может обновлять указатели &lt;code&gt;gptr&lt;/code&gt; , &lt;code&gt;egptr&lt;/code&gt; и &lt;code&gt;eback&lt;/code&gt; для определения местоположения вновь загруженных данных (если они есть). В случае сбоя функция гарантирует, что либо &lt;code&gt;gptr() == nullptr&lt;/code&gt; либо &lt;code&gt;gptr() == egptr&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e7a7a46183956d552300dee684d15128ebe48ebf" translate="yes" xml:space="preserve">
          <source>The function may update &lt;code&gt;pptr&lt;/code&gt;, &lt;code&gt;epptr&lt;/code&gt; and &lt;code&gt;pbase&lt;/code&gt; pointers to define the location to write more data. On failure, the function ensures that either &lt;code&gt;pptr() == nullptr&lt;/code&gt; or &lt;code&gt;pptr() == epptr&lt;/code&gt;.</source>
          <target state="translated">Функция может обновлять &lt;code&gt;pptr&lt;/code&gt; , &lt;code&gt;epptr&lt;/code&gt; и &lt;code&gt;pbase&lt;/code&gt; , чтобы определить местоположение для записи дополнительных данных. В случае сбоя функция гарантирует, что либо &lt;code&gt;pptr() == nullptr&lt;/code&gt; &lt;code&gt;pptr() == epptr&lt;/code&gt; либо pptr () == epptr .</target>
        </trans-unit>
        <trans-unit id="15af0ce237ff3b3144c6a868b8ee125006a14e71" translate="yes" xml:space="preserve">
          <source>The function modifies static storage and is not thread-safe.</source>
          <target state="translated">Функция модифицирует статическую память и не является потокобезопасной.</target>
        </trans-unit>
        <trans-unit id="ab3db171e79e2989a832c6ee9c99d6df12884a1d" translate="yes" xml:space="preserve">
          <source>The function modifies the pointer only if it would be possible to fit the wanted number of bytes aligned by the given alignment into the buffer. If the buffer is too small, the function does nothing and returns &lt;code&gt;nullptr&lt;/code&gt;.</source>
          <target state="translated">Функция изменяет указатель только в том случае, если можно было бы разместить требуемое количество байтов, выровненных с помощью данного выравнивания, в буфер. Если буфер слишком мал, функция ничего не делает и возвращает &lt;code&gt;nullptr&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bc27df1dece75c7950d8306c4124d7ab25b1a17f" translate="yes" xml:space="preserve">
          <source>The function must not modify the objects passed to it and must return consistent results when called for the same objects, regardless of their positions in the array.</source>
          <target state="translated">Функция не должна модифицировать переданные ей объекты и должна возвращать последовательные результаты при вызове для одних и тех же объектов,независимо от их положения в массиве.</target>
        </trans-unit>
        <trans-unit id="6f186c1fa81fe391780ded04d401cc94118bdba5" translate="yes" xml:space="preserve">
          <source>The function name stands for &quot;complementary span&quot;</source>
          <target state="translated">Название функции означает &quot;дополнительный диапазон&quot;.</target>
        </trans-unit>
        <trans-unit id="db20681f76479d1a2df4829db6ccf4a0a080e0ef" translate="yes" xml:space="preserve">
          <source>The function name stands for &quot;new scalb&quot;, where &lt;code&gt;scalb&lt;/code&gt; was an older non-standard function whose second argument had floating-point type.</source>
          <target state="translated">Имя функции означает &amp;laquo;новый скальб&amp;raquo;, где &lt;code&gt;scalb&lt;/code&gt; был более старой нестандартной функцией, второй аргумент которой имел тип с плавающей точкой.</target>
        </trans-unit>
        <trans-unit id="c9dcfedf49fa204154f0431b2673a0daebcd06a5" translate="yes" xml:space="preserve">
          <source>The function object &lt;code&gt;pred&lt;/code&gt; shall not apply any non-constant function through the dereferenced iterator. This function object may be a pointer to function or an object of a type with an appropriate function call operator.</source>
          <target state="translated">Функция &lt;code&gt;pred&lt;/code&gt; объекта не должна применять какую-либо непостоянную функцию через разыменованный итератор. Этот функциональный объект может быть указателем на функцию или объектом типа с соответствующим оператором вызова функции.</target>
        </trans-unit>
        <trans-unit id="fec4de0270a6f3097d68f50b43e7edfb64e10dc9" translate="yes" xml:space="preserve">
          <source>The function parameters that do not participate in template argument deduction (e.g. if the corresponding template arguments are explicitly specified) are subject to implicit conversions to the type of the corresponding function parameter (as in the usual &lt;a href=&quot;overload_resolution&quot;&gt;overload resolution&lt;/a&gt;).</source>
          <target state="translated">Параметры функции, которые не участвуют в выводе аргументов шаблона (например, если соответствующие аргументы шаблона указаны явно), подвергаются неявным преобразованиям в тип соответствующего параметра функции (как в обычном &lt;a href=&quot;overload_resolution&quot;&gt;разрешении перегрузки&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="7eeb93d2b7dca68685dc425373a6764fb01e3729" translate="yes" xml:space="preserve">
          <source>The function provides no means to prevent buffer overflow of the destination array, given sufficiently long input string. &lt;code&gt;std::gets&lt;/code&gt; was deprecated in C++11 and removed from C++14.</source>
          <target state="translated">Функция не предоставляет средств для предотвращения переполнения буфера массива назначения, учитывая достаточно длинную входную строку. &lt;code&gt;std::gets&lt;/code&gt; устарел в C ++ 11 и удален из C ++ 14.</target>
        </trans-unit>
        <trans-unit id="fa9dad8347dfb2e0d670a4af83e853b0527c897a" translate="yes" xml:space="preserve">
          <source>The function template &lt;code&gt;bind&lt;/code&gt; generates a forwarding call wrapper for &lt;code&gt;f&lt;/code&gt;. Calling this wrapper is equivalent to invoking &lt;code&gt;f&lt;/code&gt; with some of its arguments bound to &lt;code&gt;args&lt;/code&gt;.</source>
          <target state="translated">Шаблон функции &lt;code&gt;bind&lt;/code&gt; создает оболочку переадресации для &lt;code&gt;f&lt;/code&gt; . Вызов этой оболочки эквивалентен вызову &lt;code&gt;f&lt;/code&gt; с некоторыми аргументами, связанными с &lt;code&gt;args&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1b74686fedbb22b834206589460eadd916d0aa6c" translate="yes" xml:space="preserve">
          <source>The function template &lt;code&gt;bind_front&lt;/code&gt; generates a forwarding call wrapper for &lt;code&gt;f&lt;/code&gt;. Calling this wrapper is equivalent to invoking &lt;code&gt;f&lt;/code&gt; with its first &lt;code&gt;sizeof...(Args)&lt;/code&gt; parameters bound to &lt;code&gt;args&lt;/code&gt;.</source>
          <target state="translated">Шаблон функции &lt;code&gt;bind_front&lt;/code&gt; генерирует оболочку переадресации вызова для &lt;code&gt;f&lt;/code&gt; . Вызов этой оболочки эквивалентен вызову &lt;code&gt;f&lt;/code&gt; с его первыми параметрами &lt;code&gt;sizeof...(Args)&lt;/code&gt; связанными с &lt;code&gt;args&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a42b57be9690e30b4d127d5c56b2e136867973a2" translate="yes" xml:space="preserve">
          <source>The function templates #1 and #3 have different signatures and are distinct templates. Nonetheless, #2 and #4, despite being instantiations of different function templates, have the same mangled name &lt;a href=&quot;https://github.com/itanium-cxx-abi/cxx-abi/issues/20&quot;&gt;in the Itanium C++ ABI&lt;/a&gt; (&lt;code&gt;_Z4funcI1XLi0EEvv&lt;/code&gt;), meaning that the linker will erroneously consider them to be the same entity.</source>
          <target state="translated">Шаблоны функций № 1 и № 3 имеют разные подписи и являются различными шаблонами. Тем не менее, # 2 и # 4, несмотря на то, что они являются экземплярами различных шаблонов функций, имеют одно искаженное имя &lt;a href=&quot;https://github.com/itanium-cxx-abi/cxx-abi/issues/20&quot;&gt;в ABI- &lt;/a&gt; &lt;code&gt;_Z4funcI1XLi0EEvv&lt;/code&gt; Itanium C ++ ( _Z4funcI1XLi0EEvv ), что означает, что компоновщик ошибочно будет считать их одним и тем же объектом.</target>
        </trans-unit>
        <trans-unit id="1661ab084a02d0a0b4022e49867df5380e8a9ad8" translate="yes" xml:space="preserve">
          <source>The function templates are then ranked as if for &lt;a href=&quot;function_template#Function_template_overloading&quot;&gt;function template overloading&lt;/a&gt;.</source>
          <target state="translated">Затем шаблоны функций ранжируются так, как если бы они были &lt;a href=&quot;function_template#Function_template_overloading&quot;&gt;перегружены&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7c3559ff21a7ec0a87fd87249ee0c6ee1ced4a14" translate="yes" xml:space="preserve">
          <source>The function then returns the pointer to the beginning of the token</source>
          <target state="translated">Затем функция возвращает указатель на начало токена.</target>
        </trans-unit>
        <trans-unit id="4126da2324b4eb270d68c514e43af8301f52dd63" translate="yes" xml:space="preserve">
          <source>The function to calculate the result has not been started yet</source>
          <target state="translated">Функция расчета результата еще не запущена.</target>
        </trans-unit>
        <trans-unit id="eb957ebe7149eefbfbfc9fa1905a6cdb297d02f9" translate="yes" xml:space="preserve">
          <source>The function type of the function template is &lt;code&gt;P&lt;/code&gt;. The &lt;a href=&quot;overloaded_address&quot;&gt;target type&lt;/a&gt; is the type of &lt;code&gt;A&lt;/code&gt;:</source>
          <target state="translated">Тип функции шаблона функции является &lt;code&gt;P&lt;/code&gt; . Тип &lt;a href=&quot;overloaded_address&quot;&gt;цели&lt;/a&gt; - это тип &lt;code&gt;A&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="d62041d0f93824e7e4927764fa5aa1df2523bc0c" translate="yes" xml:space="preserve">
          <source>The function-call operator is always &lt;code&gt;constexpr&lt;/code&gt; if it satisfies the requirements of a &lt;a href=&quot;constexpr&quot;&gt;constexpr function&lt;/a&gt;. It is also constexpr if the keyword constexpr was used in the lambda declaration.</source>
          <target state="translated">Оператор вызова функции всегда является &lt;code&gt;constexpr&lt;/code&gt; , если он удовлетворяет требованиям &lt;a href=&quot;constexpr&quot;&gt;функции constexpr&lt;/a&gt; . Также является constexpr, если ключевое слово constexpr использовалось в лямбда-объявлении.</target>
        </trans-unit>
        <trans-unit id="90237372df253176f7201dadf305ca2efdb82ba0" translate="yes" xml:space="preserve">
          <source>The function-call operator is an &lt;a href=&quot;consteval&quot;&gt;immediate function&lt;/a&gt; if the keyword &lt;code&gt;consteval&lt;/code&gt; was used in the lambda expression.</source>
          <target state="translated">Оператор вызова функции является &lt;a href=&quot;consteval&quot;&gt;непосредственной функцией,&lt;/a&gt; если в лямбда-выражении было использовано ключевое слово &lt;code&gt;consteval&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="18222cb267ac69f3312ca400b95bb5960956fbce" translate="yes" xml:space="preserve">
          <source>The function-call operators of T are obtained by ordinary &lt;a href=&quot;lookup&quot;&gt;lookup&lt;/a&gt; of the name &lt;code&gt;operator()&lt;/code&gt; in the context of the expression &lt;code&gt;(E).operator()&lt;/code&gt;, and every declaration found is added to the set of candidate functions.</source>
          <target state="translated">Операторы вызова функции для T получают обычным &lt;a href=&quot;lookup&quot;&gt;поиском &lt;/a&gt; &lt;code&gt;operator()&lt;/code&gt; name () в контексте выражения &lt;code&gt;(E).operator()&lt;/code&gt; , и каждое найденное объявление добавляется в набор функций-кандидатов.</target>
        </trans-unit>
        <trans-unit id="5f03f8854c3dadb42ebc1a2f13e6f98271799bab" translate="yes" xml:space="preserve">
          <source>The function-like entities described on this page are</source>
          <target state="translated">Функциональные сущности,описанные на этой странице,выглядят следующим образом</target>
        </trans-unit>
        <trans-unit id="c90c3720bc6cd842ff45d50c455cbeb05ef64826" translate="yes" xml:space="preserve">
          <source>The function-try-block is one of the alternative syntax forms for function-body, which is a part of &lt;a href=&quot;function&quot;&gt;function definition&lt;/a&gt;.</source>
          <target state="translated">Функция-try-block является одной из альтернативных синтаксических форм для функции body, которая является частью &lt;a href=&quot;function&quot;&gt;определения функции&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7d70566d5bc405ba10ba5bb68262596374bff760" translate="yes" xml:space="preserve">
          <source>The functions &lt;code&gt;&lt;a href=&quot;expm1&quot;&gt;std::expm1&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;std::log1p&lt;/code&gt; are useful for financial calculations, for example, when calculating small daily interest rates: (1+x)n</source>
          <target state="translated">Функции &lt;code&gt;&lt;a href=&quot;expm1&quot;&gt;std::expm1&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;std::log1p&lt;/code&gt; полезны для финансовых расчетов, например, при расчете небольших ежедневных процентных ставок: (1 + x) n</target>
        </trans-unit>
        <trans-unit id="ce063565abd09222888790e9a9d67e9d39a935ae" translate="yes" xml:space="preserve">
          <source>The functions &lt;code&gt;std::expm1&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;log1p&quot;&gt;std::log1p&lt;/a&gt;&lt;/code&gt; are useful for financial calculations, for example, when calculating small daily interest rates: (1+x)n</source>
          <target state="translated">Функции &lt;code&gt;std::expm1&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;log1p&quot;&gt;std::log1p&lt;/a&gt;&lt;/code&gt; полезны для финансовых расчетов, например, при расчете небольших ежедневных процентных ставок: (1 + x) n</target>
        </trans-unit>
        <trans-unit id="7d057934f5d91a8d0d5efe334eb2fd28c09a314a" translate="yes" xml:space="preserve">
          <source>The functions may be called concurrently with the destruction of the objects with static storage duration and with each other, maintaining the guarantee that if registration of A was sequenced-before the registration of B, then the call to B is sequenced-before the call to A, same applies to the sequencing between static object constructors and calls to &lt;code&gt;atexit&lt;/code&gt;: see &lt;code&gt;&lt;a href=&quot;exit&quot;&gt;std::exit&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Функции могут вызываться одновременно с уничтожением объектов со статической продолжительностью хранения и друг с другом, сохраняя гарантию того, что если последовательность A была упорядочена до регистрации B, то вызов B упорядочен до вызова A, то же самое относится к последовательности между конструкторами статических объектов и вызовам &lt;code&gt;atexit&lt;/code&gt; : смотрите &lt;code&gt;&lt;a href=&quot;exit&quot;&gt;std::exit&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3db16cc57db5dbc928e64b1b6ac3975c579a8b6a" translate="yes" xml:space="preserve">
          <source>The functions sets the pointer pointed to by &lt;code&gt;endptr&lt;/code&gt; to point to the character past the last character interpreted. If &lt;code&gt;endptr&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt;, it is ignored.</source>
          <target state="translated">Функция устанавливает указатель, на который указывает &lt;code&gt;endptr&lt;/code&gt; , для указания на символ после последнего интерпретированного символа. Если &lt;code&gt;endptr&lt;/code&gt; равен &lt;code&gt;&lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt; , он игнорируется.</target>
        </trans-unit>
        <trans-unit id="79e95f56658767e1e470d9215d4b6600bf8174e3" translate="yes" xml:space="preserve">
          <source>The functions sets the pointer pointed to by &lt;code&gt;endptr&lt;/code&gt; to point to the wide character past the last character interpreted. If &lt;code&gt;endptr&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt;, it is ignored.</source>
          <target state="translated">Функции устанавливают указатель, на который указывает &lt;code&gt;endptr&lt;/code&gt; , чтобы указывать на широкий символ после последнего интерпретированного символа. Если &lt;code&gt;endptr&lt;/code&gt; равен &lt;code&gt;&lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt; , он игнорируется.</target>
        </trans-unit>
        <trans-unit id="69ad6824d6f8c048fddeb1809adb4e0dadf9dc71" translate="yes" xml:space="preserve">
          <source>The functions sets the pointer pointed to by &lt;code&gt;str_end&lt;/code&gt; to point to the character past the last character interpreted. If &lt;code&gt;str_end&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt;, it is ignored.</source>
          <target state="translated">Функции устанавливают указатель, на который указывает &lt;code&gt;str_end&lt;/code&gt; , чтобы указать на символ после последнего интерпретированного символа. Если &lt;code&gt;str_end&lt;/code&gt; равен &lt;code&gt;&lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt; , он игнорируется.</target>
        </trans-unit>
        <trans-unit id="9c7ec7a3aab98e1d97256af5eb3cd5dd8ac9ef4b" translate="yes" xml:space="preserve">
          <source>The functions sets the pointer pointed to by &lt;code&gt;str_end&lt;/code&gt; to point to the wide character past the last character interpreted. If &lt;code&gt;str_end&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt;, it is ignored.</source>
          <target state="translated">Функции устанавливают указатель, на который указывает &lt;code&gt;str_end&lt;/code&gt; , чтобы указать широкий символ после последнего интерпретированного символа. Если &lt;code&gt;str_end&lt;/code&gt; равен &lt;code&gt;&lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt; , он игнорируется.</target>
        </trans-unit>
        <trans-unit id="f29db516e7cae858024d84b5b0bd244f31b9db50" translate="yes" xml:space="preserve">
          <source>The functions that accept rvalue reference parameters (including &lt;a href=&quot;../language/move_constructor&quot;&gt;move constructors&lt;/a&gt;, &lt;a href=&quot;../language/move_operator&quot;&gt;move assignment operators&lt;/a&gt;, and regular member functions such as &lt;code&gt;&lt;a href=&quot;../container/vector/push_back&quot;&gt;std::vector::push_back&lt;/a&gt;&lt;/code&gt;) are selected, by &lt;a href=&quot;../language/overload_resolution&quot;&gt;overload resolution&lt;/a&gt;, when called with &lt;a href=&quot;../language/value_category&quot;&gt;rvalue&lt;/a&gt; arguments (either &lt;a href=&quot;../language/value_category&quot;&gt;prvalues&lt;/a&gt; such as a temporary objects or &lt;a href=&quot;../language/value_category&quot;&gt;xvalues&lt;/a&gt; such as the one produced by &lt;code&gt;std::move&lt;/code&gt;). If the argument identifies a resource-owning object, these overloads have the option, but aren't required, to</source>
          <target state="translated">Функции , которые принимают RValue эталонных параметров ( в том числе на &lt;a href=&quot;../language/move_constructor&quot;&gt;перемещение конструкторов&lt;/a&gt; , &lt;a href=&quot;../language/move_operator&quot;&gt;операторов присваивания шага&lt;/a&gt; и регулярные функций - членов , такие как &lt;code&gt;&lt;a href=&quot;../container/vector/push_back&quot;&gt;std::vector::push_back&lt;/a&gt;&lt;/code&gt; ) выбирается путем &lt;a href=&quot;../language/overload_resolution&quot;&gt;разрешения перегрузки&lt;/a&gt; , когда вызываются с &lt;a href=&quot;../language/value_category&quot;&gt;RValue&lt;/a&gt; аргументами (либо &lt;a href=&quot;../language/value_category&quot;&gt;prvalues&lt;/a&gt; , такие как временные объекты или &lt;a href=&quot;../language/value_category&quot;&gt;xvalues,&lt;/a&gt; например, полученное с помощью &lt;code&gt;std::move&lt;/code&gt; ). Если аргумент идентифицирует объект, владеющий ресурсом, эти перегрузки имеют опцию, но не обязательны для</target>
        </trans-unit>
        <trans-unit id="e09608bd7873c020fdfa17e45a1cb9324cfb8735" translate="yes" xml:space="preserve">
          <source>The functions underflow() and overflow()/sync() perform the actual I/O between the file and the get and put areas of the buffer. When &lt;code&gt;CharT&lt;/code&gt; is not &lt;code&gt;char&lt;/code&gt;, most implementations store multibyte characters in the file and a &lt;code&gt;&lt;a href=&quot;../locale/codecvt&quot;&gt;std::codecvt&lt;/a&gt;&lt;/code&gt; facet is used to perform wide/multibyte character conversion.</source>
          <target state="translated">Функции underflow () и overflow () / sync () выполняют фактический ввод-вывод между файлом и областями получения и размещения буфера. Когда &lt;code&gt;CharT&lt;/code&gt; не является &lt;code&gt;char&lt;/code&gt; , большинство реализаций хранит многобайтовые символы в файле, а фасет &lt;code&gt;&lt;a href=&quot;../locale/codecvt&quot;&gt;std::codecvt&lt;/a&gt;&lt;/code&gt; используется для преобразования широких / многобайтовых символов.</target>
        </trans-unit>
        <trans-unit id="bffe0d58cdd89a2176e51e07265897958db537f6" translate="yes" xml:space="preserve">
          <source>The functions will be called during the destruction of the static objects, in reverse order: if A was registered before B, then the call to B is made before the call to A. Same applies to the ordering between static object constructors and the calls to &lt;code&gt;atexit&lt;/code&gt;: see &lt;code&gt;&lt;a href=&quot;exit&quot;&gt;std::exit&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Функции будут вызываться при уничтожении статических объектов в обратном порядке: если A был зарегистрирован до B, то вызов B выполняется до вызова A. То же самое относится к упорядочению между конструкторами статических объектов и вызовами &lt;code&gt;atexit&lt;/code&gt; : см. &lt;code&gt;&lt;a href=&quot;exit&quot;&gt;std::exit&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="aed96e855f7e3173d3f85e69b959cd5f429e28d2" translate="yes" xml:space="preserve">
          <source>The generated random number.</source>
          <target state="translated">Сгенерированное случайное число.</target>
        </trans-unit>
        <trans-unit id="7e36dee47d5123274fbbdd384f8394bc9448d978" translate="yes" xml:space="preserve">
          <source>The generation of the implicitly-defined copy assignment operator is deprecated(since C++11) if &lt;code&gt;T&lt;/code&gt; has a user-declared destructor or user-declared copy constructor.</source>
          <target state="translated">Генерация неявно определенного оператора присваивания копии не рекомендуется (начиная с C ++ 11), если &lt;code&gt;T&lt;/code&gt; имеет объявленный пользователем деструктор или объявленный пользователем конструктор копирования.</target>
        </trans-unit>
        <trans-unit id="9e1eed93866aa0d0e35d2a62d35e689f1a41f754" translate="yes" xml:space="preserve">
          <source>The generation of the implicitly-defined copy constructor is deprecated if &lt;code&gt;T&lt;/code&gt; has a user-defined destructor or user-defined copy assignment operator.</source>
          <target state="translated">Генерация неявно определенного конструктора копирования не рекомендуется, если у &lt;code&gt;T&lt;/code&gt; есть пользовательский деструктор или пользовательский оператор назначения копирования.</target>
        </trans-unit>
        <trans-unit id="4f4aa88d036bf2efbab8a357c041b989e684ecb4" translate="yes" xml:space="preserve">
          <source>The generic template and two template specializations each contain a single version of &lt;code&gt;get&lt;/code&gt;. The three versions of &lt;code&gt;get&lt;/code&gt; differ only in the return type.</source>
          <target state="translated">Типовой шаблон и две шаблонные специализации содержат одну версию &lt;code&gt;get&lt;/code&gt; . Три версии &lt;code&gt;get&lt;/code&gt; отличаются только типом возврата.</target>
        </trans-unit>
        <trans-unit id="7aac1cf4d4dcf6d2df58133c2a7081efc8452b18" translate="yes" xml:space="preserve">
          <source>The global objects &lt;code&gt;std::cerr&lt;/code&gt; and &lt;code&gt;std::wcerr&lt;/code&gt; control output to a stream buffer of implementation-defined type (derived from &lt;code&gt;&lt;a href=&quot;basic_streambuf&quot;&gt;std::streambuf&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;basic_streambuf&quot;&gt;std::wstreambuf&lt;/a&gt;&lt;/code&gt;, respectively), associated with the standard C error output stream &lt;code&gt;&lt;a href=&quot;c&quot;&gt;stderr&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Глобальные объекты &lt;code&gt;std::cerr&lt;/code&gt; и &lt;code&gt;std::wcerr&lt;/code&gt; управляют выводом в потоковый буфер определенного типа реализации (производный от &lt;code&gt;&lt;a href=&quot;basic_streambuf&quot;&gt;std::streambuf&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;basic_streambuf&quot;&gt;std::wstreambuf&lt;/a&gt;&lt;/code&gt; соответственно), связанный со стандартным потоком вывода ошибок C &lt;code&gt;&lt;a href=&quot;c&quot;&gt;stderr&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4cdce0c44ee46c553e1a9e5502ff67dca5ca8589" translate="yes" xml:space="preserve">
          <source>The global objects &lt;code&gt;std::cin&lt;/code&gt; and &lt;code&gt;std::wcin&lt;/code&gt; control input from a stream buffer of implementation-defined type (derived from &lt;code&gt;&lt;a href=&quot;basic_streambuf&quot;&gt;std::streambuf&lt;/a&gt;&lt;/code&gt;), associated with the standard C input stream &lt;code&gt;&lt;a href=&quot;c&quot;&gt;stdin&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Глобальные объекты &lt;code&gt;std::cin&lt;/code&gt; и &lt;code&gt;std::wcin&lt;/code&gt; управляют вводом из потокового буфера определенного типа реализации (производного от &lt;code&gt;&lt;a href=&quot;basic_streambuf&quot;&gt;std::streambuf&lt;/a&gt;&lt;/code&gt; ), связанного со стандартным входным потоком C &lt;code&gt;&lt;a href=&quot;c&quot;&gt;stdin&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="461aa84897b843038a6471036df9b6bfd2e5db28" translate="yes" xml:space="preserve">
          <source>The global objects &lt;code&gt;std::clog&lt;/code&gt; and &lt;code&gt;std::wclog&lt;/code&gt; control output to a stream buffer of implementation-defined type (derived from &lt;code&gt;&lt;a href=&quot;basic_streambuf&quot;&gt;std::streambuf&lt;/a&gt;&lt;/code&gt;), associated with the standard C output stream &lt;code&gt;&lt;a href=&quot;c&quot;&gt;stderr&lt;/a&gt;&lt;/code&gt;, but, unlike &lt;code&gt;&lt;a href=&quot;cerr&quot;&gt;std::cerr&lt;/a&gt;&lt;/code&gt;/&lt;code&gt;&lt;a href=&quot;cerr&quot;&gt;std::wcerr&lt;/a&gt;&lt;/code&gt;, these streams are not automatically flushed and not automatically tie()'d with cout.</source>
          <target state="translated">Глобальные объекты &lt;code&gt;std::clog&lt;/code&gt; и &lt;code&gt;std::wclog&lt;/code&gt; управляют выводом в потоковый буфер определенного типа реализации (производный от &lt;code&gt;&lt;a href=&quot;basic_streambuf&quot;&gt;std::streambuf&lt;/a&gt;&lt;/code&gt; ), связанный со стандартным выходным потоком C &lt;code&gt;&lt;a href=&quot;c&quot;&gt;stderr&lt;/a&gt;&lt;/code&gt; , но, в отличие от &lt;code&gt;&lt;a href=&quot;cerr&quot;&gt;std::cerr&lt;/a&gt;&lt;/code&gt; / &lt;code&gt;&lt;a href=&quot;cerr&quot;&gt;std::wcerr&lt;/a&gt;&lt;/code&gt; , эти потоки не сбрасываются автоматически и не автоматически связываются () с cout.</target>
        </trans-unit>
        <trans-unit id="f5f98bba6559b17ed7e6d131e3611a81638ab812" translate="yes" xml:space="preserve">
          <source>The global objects &lt;code&gt;std::cout&lt;/code&gt; and &lt;code&gt;std::wcout&lt;/code&gt; control output to a stream buffer of implementation-defined type (derived from &lt;code&gt;&lt;a href=&quot;basic_streambuf&quot;&gt;std::streambuf&lt;/a&gt;&lt;/code&gt;), associated with the standard C output stream &lt;code&gt;&lt;a href=&quot;c&quot;&gt;stdout&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Глобальные объекты &lt;code&gt;std::cout&lt;/code&gt; и &lt;code&gt;std::wcout&lt;/code&gt; управляют выводом в потоковый буфер определенного типа реализации (производный от &lt;code&gt;&lt;a href=&quot;basic_streambuf&quot;&gt;std::streambuf&lt;/a&gt;&lt;/code&gt; ), связанный со стандартным выходным потоком C &lt;code&gt;&lt;a href=&quot;c&quot;&gt;stdout&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="70f50373a3f6e5f0380c536e396a13926eb96f45" translate="yes" xml:space="preserve">
          <source>The goto statement transfers control to the location specified by &lt;a href=&quot;statements#Labels&quot;&gt;label&lt;/a&gt;. The goto statement must be in the same function as the label it is referring, it may appear before or after the label.</source>
          <target state="translated">Оператор goto передает управление в местоположение, указанное &lt;a href=&quot;statements#Labels&quot;&gt;меткой&lt;/a&gt; . Оператор goto должен быть в той же функции, что и метка, на которую он ссылается, он может появляться до или после метки.</target>
        </trans-unit>
        <trans-unit id="9203ba2e1b9acd8459fc296135b185d6bdec6014" translate="yes" xml:space="preserve">
          <source>The groups are stored as binary values: three-digit group is &lt;code&gt;'\3'&lt;/code&gt;, and 51-digit group is &lt;code&gt;'3'&lt;/code&gt;. The character at index zero of the returned string holds the number of digits in the rightmost group. The character at index 1 holds the number of digits in the second group from the right, etc. The grouping indicated by the last character in the returned string is reused to group all remaining digits in the (left part of) the number.</source>
          <target state="translated">Группы хранятся в виде двоичных значений: группа из трех цифр - &lt;code&gt;'\3'&lt;/code&gt; , а группа из 51 цифры - &lt;code&gt;'3'&lt;/code&gt; . Символ с нулевым индексом возвращаемой строки содержит количество цифр в самой правой группе. Символ в индексе 1 содержит количество цифр во второй группе справа и т. Д. Группировка, указанная последним символом в возвращаемой строке, используется повторно для группировки всех оставшихся цифр в (левой части) числа.</target>
        </trans-unit>
        <trans-unit id="377e30e67488234928e5265aef21fdf60f228f58" translate="yes" xml:space="preserve">
          <source>The guarantee that &lt;code&gt;std::from_chars&lt;/code&gt; can recover every floating-point value formatted by &lt;a href=&quot;to_chars&quot;&gt;&lt;code&gt;std::to_chars&lt;/code&gt;&lt;/a&gt; exactly is only provided if both functions are from the same implementation.</source>
          <target state="translated">Гарантия того, что &lt;code&gt;std::from_chars&lt;/code&gt; может восстановить каждое значение с плавающей запятой, отформатированное с помощью &lt;a href=&quot;to_chars&quot;&gt; &lt;code&gt;std::to_chars&lt;/code&gt; &lt;/a&gt; точно предоставляется только в том случае, если обе функции принадлежат одной и той же реализации.</target>
        </trans-unit>
        <trans-unit id="6a78268c72fa332949b19e97ea94c6bd065b9550" translate="yes" xml:space="preserve">
          <source>The guarantee that &lt;code&gt;std::from_chars&lt;/code&gt; can recover every floating-point value formatted by &lt;code&gt;to_chars&lt;/code&gt; exactly is only provided if both functions are from the same implementation.</source>
          <target state="translated">Гарантия того, что &lt;code&gt;std::from_chars&lt;/code&gt; может восстановить каждое значение с плавающей запятой, отформатированное с помощью &lt;code&gt;to_chars&lt;/code&gt; точно, предоставляется только в том случае, если обе функции имеют одну и ту же реализацию.</target>
        </trans-unit>
        <trans-unit id="bb6a61b9c44ca51fc2d67b8e734fd60e0f744ad5" translate="yes" xml:space="preserve">
          <source>The hash code of the associated &lt;code&gt;type_info&lt;/code&gt; object.</source>
          <target state="translated">Хеш-код связанного объекта &lt;code&gt;type_info&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b862a5e504b0376ea8c84c346ba305c970071424" translate="yes" xml:space="preserve">
          <source>The hash function.</source>
          <target state="translated">Хэш-функция.</target>
        </trans-unit>
        <trans-unit id="3937832fedbe42cd580633aa32952bacd6b0b437" translate="yes" xml:space="preserve">
          <source>The hash value that respects collation order.</source>
          <target state="translated">Хэш-значение,уважающее порядок сверки.</target>
        </trans-unit>
        <trans-unit id="e822b844b21e9499cc3d98cbf3f05f1abdf07e6d" translate="yes" xml:space="preserve">
          <source>The header &lt;a href=&quot;../header/iterator&quot;&gt;&lt;code&gt;&amp;lt;iterator&amp;gt;&lt;/code&gt;&lt;/a&gt; provides a set of concepts and related utility templates designed to ease constraining common algorithm operations.</source>
          <target state="translated">Заголовок &lt;a href=&quot;../header/iterator&quot;&gt; &lt;code&gt;&amp;lt;iterator&amp;gt;&lt;/code&gt; &lt;/a&gt; предоставляет набор концепций и связанных шаблонов утилит, предназначенных для облегчения ограничения общих операций алгоритма.</target>
        </trans-unit>
        <trans-unit id="32774d695cdea646f90e7d021305a854ad71bc9b" translate="yes" xml:space="preserve">
          <source>The header &lt;a href=&quot;../header/typeinfo&quot;&gt;&amp;lt;typeinfo&amp;gt;&lt;/a&gt; must be included before using &lt;code&gt;typeid&lt;/code&gt; (if the header is not included, every use of the keyword &lt;code&gt;typeid&lt;/code&gt; makes the program ill-formed.).</source>
          <target state="translated">Заголовок &lt;a href=&quot;../header/typeinfo&quot;&gt;&amp;lt;typeinfo&amp;gt;&lt;/a&gt; должен быть включен перед использованием &lt;code&gt;typeid&lt;/code&gt; (если заголовок не включен, каждое использование ключевого слова &lt;code&gt;typeid&lt;/code&gt; делает программу плохо сформированной.).</target>
        </trans-unit>
        <trans-unit id="39e45883b37cb57381dea376201d7779a8f05664" translate="yes" xml:space="preserve">
          <source>The header &lt;a href=&quot;header/bit&quot;&gt;&lt;code&gt;&amp;lt;bit&amp;gt;&lt;/code&gt;&lt;/a&gt; provides several function templates to access, manipulate, and process individual bits and bit sequences.</source>
          <target state="translated">Заголовок &lt;a href=&quot;header/bit&quot;&gt; &lt;code&gt;&amp;lt;bit&amp;gt;&lt;/code&gt; &lt;/a&gt; предоставляет несколько шаблонов функций для доступа, обработки и обработки отдельных битов и битовых последовательностей.</target>
        </trans-unit>
        <trans-unit id="c204ad70977b9fc2b727eaecd4f753ba2d1dc617" translate="yes" xml:space="preserve">
          <source>The header &lt;a href=&quot;header/cfenv&quot;&gt;&lt;code&gt;&amp;lt;cfenv&amp;gt;&lt;/code&gt;&lt;/a&gt; defines &lt;a href=&quot;numeric/fenv&quot;&gt;flags and functions related to exceptional floating-point state&lt;/a&gt;, such as overflow and division by zero.</source>
          <target state="translated">Заголовок &lt;a href=&quot;header/cfenv&quot;&gt; &lt;code&gt;&amp;lt;cfenv&amp;gt;&lt;/code&gt; &lt;/a&gt; определяет &lt;a href=&quot;numeric/fenv&quot;&gt;флаги и функции, связанные с исключительным состоянием с плавающей точкой&lt;/a&gt; , таким как переполнение и деление на ноль.</target>
        </trans-unit>
        <trans-unit id="0cbc07e97f0d93b88b9c5ece9e00510e37bf2c6a" translate="yes" xml:space="preserve">
          <source>The header &lt;a href=&quot;header/cmath&quot;&gt;&lt;code&gt;&amp;lt;cmath&amp;gt;&lt;/code&gt;&lt;/a&gt; also provides several mathematical special functions such as &lt;code&gt;&lt;a href=&quot;numeric/special_math/beta&quot;&gt;std::beta&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;numeric/special_math/hermite&quot;&gt;std::hermite&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;numeric/special_math/cyl_bessel_i&quot;&gt;std::cyl_bessel_i&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Заголовок &lt;a href=&quot;header/cmath&quot;&gt; &lt;code&gt;&amp;lt;cmath&amp;gt;&lt;/code&gt; &lt;/a&gt; также предоставляет несколько математических специальных функций, таких как &lt;code&gt;&lt;a href=&quot;numeric/special_math/beta&quot;&gt;std::beta&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;numeric/special_math/hermite&quot;&gt;std::hermite&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;numeric/special_math/cyl_bessel_i&quot;&gt;std::cyl_bessel_i&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5f4dd67444c139abdd3f7b0de3e2b42f5e337403" translate="yes" xml:space="preserve">
          <source>The header &lt;a href=&quot;header/cmath&quot;&gt;&lt;code&gt;&amp;lt;cmath&amp;gt;&lt;/code&gt;&lt;/a&gt; provides &lt;a href=&quot;numeric/math&quot;&gt;standard C library mathematical functions&lt;/a&gt; such as &lt;code&gt;&lt;a href=&quot;numeric/math/fabs&quot;&gt;std::fabs&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;numeric/math/sqrt&quot;&gt;std::sqrt&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;numeric/math/sin&quot;&gt;std::sin&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Заголовок &lt;a href=&quot;header/cmath&quot;&gt; &lt;code&gt;&amp;lt;cmath&amp;gt;&lt;/code&gt; &lt;/a&gt; предоставляет &lt;a href=&quot;numeric/math&quot;&gt;стандартные математические функции библиотеки C,&lt;/a&gt; такие как &lt;code&gt;&lt;a href=&quot;numeric/math/fabs&quot;&gt;std::fabs&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;numeric/math/sqrt&quot;&gt;std::sqrt&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;numeric/math/sin&quot;&gt;std::sin&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="743b06117d162324a98c31415f3c294f57b66ed9" translate="yes" xml:space="preserve">
          <source>The header &lt;a href=&quot;header/iterator&quot;&gt;&lt;code&gt;&amp;lt;iterator&amp;gt;&lt;/code&gt;&lt;/a&gt; provides a set of concepts and related utilities designed to ease constraining common algorithm operations.</source>
          <target state="translated">Заголовок &lt;a href=&quot;header/iterator&quot;&gt; &lt;code&gt;&amp;lt;iterator&amp;gt;&lt;/code&gt; &lt;/a&gt; предоставляет набор концепций и связанных утилит, предназначенных для облегчения ограничения общих операций алгоритма.</target>
        </trans-unit>
        <trans-unit id="508d20b6cea54c392d295d11726346c65aa4b0b3" translate="yes" xml:space="preserve">
          <source>The header &lt;a href=&quot;header/numeric&quot;&gt;&lt;code&gt;&amp;lt;numeric&amp;gt;&lt;/code&gt;&lt;/a&gt; provides numeric algorithms below:</source>
          <target state="translated">Заголовок &lt;a href=&quot;header/numeric&quot;&gt; &lt;code&gt;&amp;lt;numeric&amp;gt;&lt;/code&gt; &lt;/a&gt; предоставляет числовые алгоритмы ниже:</target>
        </trans-unit>
        <trans-unit id="ba440bf8e1f8c37da5221f67c871d6fb13769ff0" translate="yes" xml:space="preserve">
          <source>The header &lt;a href=&quot;header/random&quot;&gt;&lt;code&gt;&amp;lt;random&amp;gt;&lt;/code&gt;&lt;/a&gt; defines &lt;a href=&quot;numeric/random&quot;&gt;pseudo-random number generators and numerical distributions&lt;/a&gt;. The header &lt;a href=&quot;header/cstdlib&quot;&gt;&lt;code&gt;&amp;lt;cstdlib&amp;gt;&lt;/code&gt;&lt;/a&gt; also includes C-style random number generation via &lt;code&gt;&lt;a href=&quot;numeric/random/srand&quot;&gt;std::srand&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;numeric/random/rand&quot;&gt;std::rand&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Заголовок &lt;a href=&quot;header/random&quot;&gt; &lt;code&gt;&amp;lt;random&amp;gt;&lt;/code&gt; &lt;/a&gt; определяет &lt;a href=&quot;numeric/random&quot;&gt;генераторы псевдослучайных чисел и числовые распределения&lt;/a&gt; . Заголовок &lt;a href=&quot;header/cstdlib&quot;&gt; &lt;code&gt;&amp;lt;cstdlib&amp;gt;&lt;/code&gt; &lt;/a&gt; также включает генерацию случайных чисел в стиле C через &lt;code&gt;&lt;a href=&quot;numeric/random/srand&quot;&gt;std::srand&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;numeric/random/rand&quot;&gt;std::rand&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="dd8e217a3115bdf6060d0de317017567a06a41d7" translate="yes" xml:space="preserve">
          <source>The header &lt;a href=&quot;header/ratio&quot;&gt;&lt;code&gt;&amp;lt;ratio&amp;gt;&lt;/code&gt;&lt;/a&gt; provides &lt;a href=&quot;numeric/ratio&quot;&gt;types and functions for manipulating and storing compile-time ratios&lt;/a&gt;.</source>
          <target state="translated">Заголовок &lt;a href=&quot;header/ratio&quot;&gt; &lt;code&gt;&amp;lt;ratio&amp;gt;&lt;/code&gt; &lt;/a&gt; предоставляет &lt;a href=&quot;numeric/ratio&quot;&gt;типы и функции для управления и хранения соотношений времени компиляции&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="218920ec6c8d077db4c2f0630d45c58c68f68e0c" translate="yes" xml:space="preserve">
          <source>The header &lt;a href=&quot;header/version&quot;&gt;&lt;code&gt;&amp;lt;version&amp;gt;&lt;/code&gt;&lt;/a&gt; supplies implementation-dependent information about the C++ standard library (such as the version number and release date. It also defines the &lt;a href=&quot;utility/feature_test&quot;&gt;library feature-test macros&lt;/a&gt;.</source>
          <target state="translated">Заголовок &lt;a href=&quot;header/version&quot;&gt; &lt;code&gt;&amp;lt;version&amp;gt;&lt;/code&gt; &lt;/a&gt; предоставляет зависящую от реализации информацию о стандартной библиотеке C ++ (например, номер версии и дату выпуска), а также определяет &lt;a href=&quot;utility/feature_test&quot;&gt;макросы проверки возможностей библиотеки&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="bf5126087a87a6889e7920c9e1157d0b23d15572" translate="yes" xml:space="preserve">
          <source>The header &lt;code&gt;&amp;lt;exception&amp;gt;&lt;/code&gt; provides several classes and functions related to exception handling in C++ programs.</source>
          <target state="translated">Заголовок &lt;code&gt;&amp;lt;exception&amp;gt;&lt;/code&gt; предоставляет несколько классов и функций, связанных с обработкой исключений в программах на C ++.</target>
        </trans-unit>
        <trans-unit id="bc6caf28cb4847d14f957dc4f821e46a30b84457" translate="yes" xml:space="preserve">
          <source>The header &lt;code&gt;&amp;lt;iostream&amp;gt;&lt;/code&gt; behaves as if it defines (directly or indirectly) an instance of &lt;code&gt;std::ios_base::Init&lt;/code&gt; with static storage duration: this makes it safe to access the standard I/O streams in the constructors and destructors of static objects with &lt;a href=&quot;../../language/initialization#Non-local_variables&quot;&gt;ordered initialization&lt;/a&gt; (as long as &lt;code&gt;#include &amp;lt;iostream&amp;gt;&lt;/code&gt; is included in the translation unit before these objects were defined).</source>
          <target state="translated">Заголовок &lt;code&gt;&amp;lt;iostream&amp;gt;&lt;/code&gt; ведет себя так, как если бы он определял (прямо или косвенно) экземпляр &lt;code&gt;std::ios_base::Init&lt;/code&gt; со статической продолжительностью хранения: это обеспечивает безопасный доступ к стандартным потокам ввода-вывода в конструкторах и деструкторах статических объектов с &lt;a href=&quot;../../language/initialization#Non-local_variables&quot;&gt;упорядоченной инициализацией&lt;/a&gt; (до тех пор, пока &lt;code&gt;#include &amp;lt;iostream&amp;gt;&lt;/code&gt; включено в модуль перевода до определения этих объектов).</target>
        </trans-unit>
        <trans-unit id="fd4ecbc573accaaae87826b6f734bf136d186983" translate="yes" xml:space="preserve">
          <source>The header &lt;code&gt;&amp;lt;system_error&amp;gt;&lt;/code&gt; defines types and functions used to report error conditions originating from the operating system, streams I/O, &lt;code&gt;&lt;a href=&quot;thread/future&quot;&gt;std::future&lt;/a&gt;&lt;/code&gt;, or other low-level APIs.</source>
          <target state="translated">Заголовок &lt;code&gt;&amp;lt;system_error&amp;gt;&lt;/code&gt; определяет типы и функции, используемые для сообщения об ошибках, происходящих из операционной системы, потокового ввода-вывода, &lt;code&gt;&lt;a href=&quot;thread/future&quot;&gt;std::future&lt;/a&gt;&lt;/code&gt; или других низкоуровневых API.</target>
        </trans-unit>
        <trans-unit id="57e8428ad704374a45b4d8a73edeba81162f1a2e" translate="yes" xml:space="preserve">
          <source>The headers &lt;code&gt;&amp;lt;ciso646&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;cstdalign&amp;gt;&lt;/code&gt;, and &lt;code&gt;&amp;lt;cstdbool&amp;gt;&lt;/code&gt; are meaningless in C++ because the macros they provide in C are language keywords in C++.</source>
          <target state="translated">Заголовки &lt;code&gt;&amp;lt;ciso646&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;cstdalign&amp;gt;&lt;/code&gt; и &lt;code&gt;&amp;lt;cstdbool&amp;gt;&lt;/code&gt; не имеют смысла в C ++, потому что макросы, которые они предоставляют в C, являются ключевыми словами языка в C ++.</target>
        </trans-unit>
        <trans-unit id="7e08bc9e99ec8f39019e1085b8cf1191154179ba" translate="yes" xml:space="preserve">
          <source>The headers &lt;code&gt;&amp;lt;complex.h&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;ccomplex&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;tgmath.h&amp;gt;&lt;/code&gt;, and &lt;code&gt;&amp;lt;ctgmath&amp;gt;&lt;/code&gt; do not contain any content from the C standard library and instead merely include other headers from the C++ standard library. The use of all these headers is deprecated in C++.</source>
          <target state="translated">Заголовки &lt;code&gt;&amp;lt;complex.h&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;ccomplex&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;tgmath.h&amp;gt;&lt;/code&gt; и &lt;code&gt;&amp;lt;ctgmath&amp;gt;&lt;/code&gt; не содержат никакого содержимого из стандартной библиотеки C и вместо этого просто включают другие заголовки из стандартной библиотеки C ++. Использование всех этих заголовков не рекомендуется в C ++.</target>
        </trans-unit>
        <trans-unit id="9d743155eef03d9de2f708dc85802d31a16ee771" translate="yes" xml:space="preserve">
          <source>The hexadecimal floating-point literals were not part of C++ until C++17, although they can be parsed and printed by the I/O functions since C++11: both C++ I/O streams when &lt;code&gt;&lt;a href=&quot;../io/manip/fixed&quot;&gt;std::hexfloat&lt;/a&gt;&lt;/code&gt; is enabled and the C I/O streams: &lt;code&gt;&lt;a href=&quot;../io/c/fprintf&quot;&gt;std::printf&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../io/c/fscanf&quot;&gt;std::scanf&lt;/a&gt;&lt;/code&gt;, etc. See &lt;code&gt;&lt;a href=&quot;../string/byte/strtof&quot;&gt;std::strtof&lt;/a&gt;&lt;/code&gt; for the format description.</source>
          <target state="translated">Шестнадцатеричные литералы с плавающей точкой не были частью C ++ до C ++ 17, хотя они могут быть проанализированы и распечатаны функциями ввода-вывода начиная с C ++ 11: оба потока ввода-вывода C ++ при включенном &lt;code&gt;&lt;a href=&quot;../io/manip/fixed&quot;&gt;std::hexfloat&lt;/a&gt;&lt;/code&gt; и потоки CI / O: &lt;code&gt;&lt;a href=&quot;../io/c/fprintf&quot;&gt;std::printf&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../io/c/fscanf&quot;&gt;std::scanf&lt;/a&gt;&lt;/code&gt; и т. д. См. &lt;code&gt;&lt;a href=&quot;../string/byte/strtof&quot;&gt;std::strtof&lt;/a&gt;&lt;/code&gt; для описания формата.</target>
        </trans-unit>
        <trans-unit id="2bcfe16e4a34071ba0fe16d4ac0cbe3af5aafda3" translate="yes" xml:space="preserve">
          <source>The hinted insert (3,4) does not return a boolean in order to be signature-compatible with positional insert on sequential containers, such as &lt;code&gt;&lt;a href=&quot;../vector/insert&quot;&gt;std::vector::insert&lt;/a&gt;&lt;/code&gt;. This makes it possible to create generic inserters such as &lt;code&gt;&lt;a href=&quot;../../iterator/inserter&quot;&gt;std::inserter&lt;/a&gt;&lt;/code&gt;. One way to check success of a hinted insert is to compare &lt;a href=&quot;size&quot;&gt;size()&lt;/a&gt; before and after.</source>
          <target state="translated">Подсказка insert (3,4) не возвращает логическое значение, чтобы быть совместимым с сигнатурой с позиционной вставкой в ​​последовательных контейнерах, таких как &lt;code&gt;&lt;a href=&quot;../vector/insert&quot;&gt;std::vector::insert&lt;/a&gt;&lt;/code&gt; . Это позволяет создавать универсальные вставки, такие как &lt;code&gt;&lt;a href=&quot;../../iterator/inserter&quot;&gt;std::inserter&lt;/a&gt;&lt;/code&gt; . Один из способов проверить успех подсказки - сравнить &lt;a href=&quot;size&quot;&gt;size ()&lt;/a&gt; до и после.</target>
        </trans-unit>
        <trans-unit id="25af4f74a579fcba3c500fb626cf10f9c5227e2b" translate="yes" xml:space="preserve">
          <source>The hinted insert (4-6) does not return a boolean in order to be signature-compatible with positional insert on sequential containers, such as &lt;code&gt;&lt;a href=&quot;../vector/insert&quot;&gt;std::vector::insert&lt;/a&gt;&lt;/code&gt;. This makes it possible to create generic inserters such as &lt;code&gt;&lt;a href=&quot;../../iterator/inserter&quot;&gt;std::inserter&lt;/a&gt;&lt;/code&gt;. One way to check success of a hinted insert is to compare &lt;a href=&quot;size&quot;&gt;size()&lt;/a&gt; before and after.</source>
          <target state="translated">Подсказка insert (4-6) не возвращает логическое значение, чтобы быть совместимым с сигнатурой с позиционной вставкой в ​​последовательных контейнерах, таких как &lt;code&gt;&lt;a href=&quot;../vector/insert&quot;&gt;std::vector::insert&lt;/a&gt;&lt;/code&gt; . Это позволяет создавать универсальные вставки, такие как &lt;code&gt;&lt;a href=&quot;../../iterator/inserter&quot;&gt;std::inserter&lt;/a&gt;&lt;/code&gt; . Один из способов проверить успех подсказки - сравнить &lt;a href=&quot;size&quot;&gt;size ()&lt;/a&gt; до и после.</target>
        </trans-unit>
        <trans-unit id="60466cfba360b12a497fdcbd2421cdfcee028890" translate="yes" xml:space="preserve">
          <source>The identifier &lt;code&gt;override&lt;/code&gt;, if used, appears immediately after the &lt;a href=&quot;function&quot;&gt;declarator&lt;/a&gt; in the syntax of a member function declaration or a member function definition inside a class definition.</source>
          <target state="translated">&lt;code&gt;override&lt;/code&gt; идентификатора , если оно используется, появляется сразу после &lt;a href=&quot;function&quot;&gt;объявления&lt;/a&gt; в синтаксисе объявления функции-члена или определения функции-члена внутри определения класса.</target>
        </trans-unit>
        <trans-unit id="855cd3f29b0c4d0647de6b78163ac3dde4862c47" translate="yes" xml:space="preserve">
          <source>The identifier in any capture without an initializer (other than the &lt;code&gt;this&lt;/code&gt;-capture) is looked up using usual &lt;a href=&quot;lookup&quot;&gt;unqualified name lookup&lt;/a&gt; in the</source>
          <target state="translated">Идентификатор в любом захвате без инициализатора (кроме &lt;code&gt;this&lt;/code&gt; -capture) ищется с использованием обычного &lt;a href=&quot;lookup&quot;&gt;поиска без определения имени&lt;/a&gt; в</target>
        </trans-unit>
        <trans-unit id="e9e7a102d6df5884074f2499d6bb5f69817edee5" translate="yes" xml:space="preserve">
          <source>The identifier then becomes the name of an lvalue that refers to the object bound to said variable.</source>
          <target state="translated">Идентификатор затем становится именем значения l,которое относится к объекту,связанному с указанной переменной.</target>
        </trans-unit>
        <trans-unit id="822a7edda6406f5fc42188900a3b551e64031aa7" translate="yes" xml:space="preserve">
          <source>The immediate input function &lt;a href=&quot;../basic_istream/readsome&quot;&gt;&lt;code&gt;basic_istream::readsome&lt;/code&gt;&lt;/a&gt;, if &lt;a href=&quot;../basic_streambuf/in_avail&quot;&gt;&lt;code&gt;basic_streambuf::in_avail&lt;/code&gt;&lt;/a&gt; returns &lt;code&gt;-1&lt;/code&gt;</source>
          <target state="translated">Функция непосредственного ввода &lt;a href=&quot;../basic_istream/readsome&quot;&gt; &lt;code&gt;basic_istream::readsome&lt;/code&gt; &lt;/a&gt; , если &lt;a href=&quot;../basic_streambuf/in_avail&quot;&gt; &lt;code&gt;basic_streambuf::in_avail&lt;/code&gt; &lt;/a&gt; возвращает &lt;code&gt;-1&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="dc1a01ff9f1f5abac042b758d317c3db71ae72ed" translate="yes" xml:space="preserve">
          <source>The implementation is guaranteed to support the registration of at least &lt;code&gt;32&lt;/code&gt; functions. The exact limit is implementation-defined.</source>
          <target state="translated">Реализация гарантированно поддерживает регистрацию как минимум &lt;code&gt;32&lt;/code&gt; функций. Точный предел определяется реализацией.</target>
        </trans-unit>
        <trans-unit id="d765572265bbb1c2ba3ca90d43753fb5f543201a" translate="yes" xml:space="preserve">
          <source>The implementation is required to ensure that the</source>
          <target state="translated">Реализация необходима для обеспечения того,чтобы</target>
        </trans-unit>
        <trans-unit id="f14c981912c9ec5ad33b5a6c478bfe2e9cbdf180" translate="yes" xml:space="preserve">
          <source>The implementation may define additional macro constants in &lt;code&gt;&amp;lt;cfenv&amp;gt;&lt;/code&gt; to identify additional floating-point exceptions. All such constants begin with &lt;code&gt;FE_&lt;/code&gt; followed by at least one uppercase letter.</source>
          <target state="translated">Реализация может определять дополнительные макроконстанты в &lt;code&gt;&amp;lt;cfenv&amp;gt;&lt;/code&gt; для идентификации дополнительных исключений с плавающей точкой. Все такие константы начинаются с &lt;code&gt;FE_&lt;/code&gt; , за которым следует хотя бы одна заглавная буква.</target>
        </trans-unit>
        <trans-unit id="22e5ff471a91c192911b7ddaa27337e54bd023f9" translate="yes" xml:space="preserve">
          <source>The implementation may extend the behavior of the first overload of &lt;code&gt;std::async&lt;/code&gt; by enabling additional (implementation-defined) bits in the default launch policy.</source>
          <target state="translated">Реализация может расширить поведение первой перегрузки &lt;code&gt;std::async&lt;/code&gt; , включив дополнительные (определяемые реализацией) биты в политике запуска по умолчанию.</target>
        </trans-unit>
        <trans-unit id="66f2e43503845c9ed791a5293976886ce8971522" translate="yes" xml:space="preserve">
          <source>The implementation may meet the requirements without creating a temporary &lt;code&gt;shared_ptr&lt;/code&gt; object.</source>
          <target state="translated">Реализация может соответствовать требованиям без создания временного объекта &lt;code&gt;shared_ptr&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="64697b003de59849a6866340318f593ae74fc065" translate="yes" xml:space="preserve">
          <source>The implementation may meet the requirements without creating a temporary &lt;code&gt;weak_ptr&lt;/code&gt; object.</source>
          <target state="translated">Реализация может соответствовать требованиям без создания временного объекта &lt;code&gt;weak_ptr&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7b237d3793f32597e507f67af416d68948b4ad9d" translate="yes" xml:space="preserve">
          <source>The implementation may support other date formats besides the ones required by the standard.</source>
          <target state="translated">Реализация может поддерживать и другие форматы дат,помимо требуемых стандартом.</target>
        </trans-unit>
        <trans-unit id="12a35a278ea92405afc482e169257edd666c8c44" translate="yes" xml:space="preserve">
          <source>The implementation shall provide sufficient additional &lt;code&gt;constexpr&lt;/code&gt; and &lt;code&gt;noexcept&lt;/code&gt; overloads of these functions so that a &lt;code&gt;basic_string_view&amp;lt;CharT,Traits&amp;gt;&lt;/code&gt; object &lt;code&gt;sv&lt;/code&gt; may be compared to another object &lt;code&gt;t&lt;/code&gt; with an implicit conversion to &lt;code&gt;basic_string_view&amp;lt;CharT,Traits&amp;gt;&lt;/code&gt;, with semantics identical to comparing &lt;code&gt;sv&lt;/code&gt; and &lt;code&gt;basic_string_view&amp;lt;CharT,Traits&amp;gt;(t)&lt;/code&gt;.</source>
          <target state="translated">Реализации должны обеспечить достаточный дополнительный &lt;code&gt;constexpr&lt;/code&gt; и &lt;code&gt;noexcept&lt;/code&gt; перегрузки этих функций , так что &lt;code&gt;basic_string_view&amp;lt;CharT,Traits&amp;gt;&lt;/code&gt; объект &lt;code&gt;sv&lt;/code&gt; может быть по сравнению с другим объектом &lt;code&gt;t&lt;/code&gt; с неявным преобразованием к &lt;code&gt;basic_string_view&amp;lt;CharT,Traits&amp;gt;&lt;/code&gt; , с семантикой идентичны сравнениями &lt;code&gt;sv&lt;/code&gt; и &lt;code&gt;basic_string_view&amp;lt;CharT,Traits&amp;gt;(t)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b8fa4c86d6d639e7f910fb3c11363bc126fb0186" translate="yes" xml:space="preserve">
          <source>The implementations are encouraged to detect the case when &lt;code&gt;&lt;a href=&quot;valid&quot;&gt;valid()&lt;/a&gt;&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt; before the call and throw a &lt;code&gt;&lt;a href=&quot;../future_error&quot;&gt;std::future_error&lt;/a&gt;&lt;/code&gt; with an error condition of &lt;code&gt;&lt;a href=&quot;../future_errc&quot;&gt;std::future_errc::no_state&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Реализации рекомендуется обнаруживать случай, когда &lt;code&gt;&lt;a href=&quot;valid&quot;&gt;valid()&lt;/a&gt;&lt;/code&gt; имеет значение &lt;code&gt;false&lt;/code&gt; перед вызовом, и &lt;code&gt;&lt;a href=&quot;../future_error&quot;&gt;std::future_error&lt;/a&gt;&lt;/code&gt; с условием ошибки &lt;code&gt;&lt;a href=&quot;../future_errc&quot;&gt;std::future_errc::no_state&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3ef09408705d9954ea1018c6860f6e1b66768503" translate="yes" xml:space="preserve">
          <source>The implementations are encouraged to detect the case when &lt;code&gt;valid == false&lt;/code&gt; before the call and throw a &lt;a href=&quot;../future_error&quot;&gt;&lt;code&gt;future_error&lt;/code&gt;&lt;/a&gt; with an error condition of &lt;a href=&quot;../future_errc&quot;&gt;&lt;code&gt;future_errc::no_state&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Реализациям рекомендуется обнаруживать случай, когда &lt;code&gt;valid == false&lt;/code&gt; перед вызовом, и генерировать &lt;a href=&quot;../future_error&quot;&gt; &lt;code&gt;future_error&lt;/code&gt; &lt;/a&gt; с условием ошибки &lt;a href=&quot;../future_errc&quot;&gt; &lt;code&gt;future_errc::no_state&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="46992c68e68dfb44f3f1d1f0f1a081b8b330576b" translate="yes" xml:space="preserve">
          <source>The implementations are encouraged to detect the case when &lt;code&gt;valid == false&lt;/code&gt; before the call and throw a &lt;code&gt;&lt;a href=&quot;../future_error&quot;&gt;std::future_error&lt;/a&gt;&lt;/code&gt; with an error condition of &lt;code&gt;&lt;a href=&quot;../future_errc&quot;&gt;std::future_errc::no_state&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Реализации рекомендуется обнаруживать случай, когда &lt;code&gt;valid == false&lt;/code&gt; перед вызовом, и &lt;code&gt;&lt;a href=&quot;../future_error&quot;&gt;std::future_error&lt;/a&gt;&lt;/code&gt; с условием ошибки &lt;code&gt;&lt;a href=&quot;../future_errc&quot;&gt;std::future_errc::no_state&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="30a185593e3d55839d1d436fbf8fa472dc5d96a9" translate="yes" xml:space="preserve">
          <source>The implementations in &lt;a href=&quot;http://llvm.org/svn/llvm-project/libcxx/trunk/src/random.cpp&quot;&gt;libc++&lt;/a&gt; and &lt;a href=&quot;http://gcc.gnu.org/viewcvs/gcc/trunk/libstdc%20%20-v3/src/c%20%2011/random.cc?view=markup#l77&quot;&gt;libstdc++&lt;/a&gt; expect &lt;code&gt;token&lt;/code&gt; to be the name of a character device that produces random numbers when read from, with the default value &lt;code&gt;&quot;/dev/urandom&quot;&lt;/code&gt;, although where the CPU instruction RDRND is available, libstdc++ uses that as the default.</source>
          <target state="translated">Реализации в &lt;a href=&quot;http://llvm.org/svn/llvm-project/libcxx/trunk/src/random.cpp&quot;&gt;libc ++&lt;/a&gt; и &lt;a href=&quot;http://gcc.gnu.org/viewcvs/gcc/trunk/libstdc%20%20-v3/src/c%20%2011/random.cc?view=markup#l77&quot;&gt;libstdc ++&lt;/a&gt; ожидают, что &lt;code&gt;token&lt;/code&gt; будет именем символьного устройства, которое выдает случайные числа при чтении со значением по умолчанию &lt;code&gt;&quot;/dev/urandom&quot;&lt;/code&gt; , хотя там, где доступна инструкция CPU RDRND, libstdc ++ использует это как значение по умолчанию ,</target>
        </trans-unit>
        <trans-unit id="07ff6cacb8ff12c796c80e4fa51112a73181e2ed" translate="yes" xml:space="preserve">
          <source>The implementations in &lt;a href=&quot;https://llvm.org/svn/llvm-project/libcxx/trunk/src/random.cpp&quot;&gt;libc++&lt;/a&gt; and &lt;a href=&quot;https://gcc.gnu.org/viewcvs/gcc/trunk/libstdc%20%20-v3/src/c%20%2011/random.cc?view=markup#l77&quot;&gt;libstdc++&lt;/a&gt; expect &lt;code&gt;token&lt;/code&gt; to be the name of a character device that produces random numbers when read from, with the default value &lt;code&gt;&quot;/dev/urandom&quot;&lt;/code&gt;, although where the CPU instruction RDRND is available, libstdc++ uses that as the default.</source>
          <target state="translated">Реализации в &lt;a href=&quot;https://llvm.org/svn/llvm-project/libcxx/trunk/src/random.cpp&quot;&gt;libc ++&lt;/a&gt; и &lt;a href=&quot;https://gcc.gnu.org/viewcvs/gcc/trunk/libstdc%20%20-v3/src/c%20%2011/random.cc?view=markup#l77&quot;&gt;libstdc ++&lt;/a&gt; ожидают, что &lt;code&gt;token&lt;/code&gt; будет именем символьного устройства, которое производит случайные числа при чтении из, со значением по умолчанию &lt;code&gt;&quot;/dev/urandom&quot;&lt;/code&gt; , хотя там, где доступна инструкция ЦП RDRND, libstdc ++ использует это по умолчанию .</target>
        </trans-unit>
        <trans-unit id="1e1bd066a7f11748e7bb0264fc2e8c480f468bd7" translate="yes" xml:space="preserve">
          <source>The implicitly-declared (or defaulted on its first declaration) copy assignment operator has an exception specification as described in &lt;a href=&quot;except_spec&quot;&gt;dynamic exception specification&lt;/a&gt;(until C++17)&lt;a href=&quot;noexcept_spec&quot;&gt;exception specification&lt;/a&gt;(since C++17).</source>
          <target state="translated">Неявно объявленных (или по умолчанию на своей первой декларации) копировать оператор присваивания имеет спецификацию исключения , как описано в &lt;a href=&quot;except_spec&quot;&gt;динамической спецификации исключений&lt;/a&gt; (до С ++ 17) &lt;a href=&quot;noexcept_spec&quot;&gt;спецификации исключений&lt;/a&gt; (так как C ++ 17).</target>
        </trans-unit>
        <trans-unit id="94f03f3d0e083d8f05c0d3d27ca9e6043e7f1447" translate="yes" xml:space="preserve">
          <source>The implicitly-declared (or defaulted on its first declaration) copy constructor has an exception specification as described in &lt;a href=&quot;except_spec&quot;&gt;dynamic exception specification&lt;/a&gt;(until C++17)&lt;a href=&quot;noexcept_spec&quot;&gt;exception specification&lt;/a&gt;(since C++17).</source>
          <target state="translated">Неявно объявленных (или по умолчанию на его первой декларации) конструктор копирования имеет спецификацию исключения , как описано в &lt;a href=&quot;except_spec&quot;&gt;динамической спецификации исключений&lt;/a&gt; (до С ++ 17) &lt;a href=&quot;noexcept_spec&quot;&gt;спецификации исключений&lt;/a&gt; (так как C ++ 17).</target>
        </trans-unit>
        <trans-unit id="c3a2dc4c3c835b9d7e3746bb1d579e66f0b3d256" translate="yes" xml:space="preserve">
          <source>The implicitly-declared (or defaulted on its first declaration) default constructor has an exception specification as described in &lt;a href=&quot;except_spec&quot;&gt;dynamic exception specification&lt;/a&gt;(until C++17)&lt;a href=&quot;noexcept_spec&quot;&gt;exception specification&lt;/a&gt;(since C++17).</source>
          <target state="translated">Неявно объявленных (или по умолчанию на своем первом объявлении) конструктор по умолчанию имеет спецификацию исключения , как описано в &lt;a href=&quot;except_spec&quot;&gt;динамической спецификации исключений&lt;/a&gt; (до С ++ 17) &lt;a href=&quot;noexcept_spec&quot;&gt;спецификации исключений&lt;/a&gt; (так как C ++ 17).</target>
        </trans-unit>
        <trans-unit id="ad35568398ddbdf1c5594f6799a40acc879779b5" translate="yes" xml:space="preserve">
          <source>The implicitly-declared (or defaulted on its first declaration) move assignment operator has an exception specification as described in &lt;a href=&quot;except_spec&quot;&gt;dynamic exception specification&lt;/a&gt;(until C++17)&lt;a href=&quot;noexcept_spec&quot;&gt;exception specification&lt;/a&gt;(since C++17).</source>
          <target state="translated">Неявно объявленный (или по умолчанию на своем первое объявление) операторе присваивания движения имеет спецификацию исключения , как описано в &lt;a href=&quot;except_spec&quot;&gt;динамической спецификации исключений&lt;/a&gt; (до С ++ 17) &lt;a href=&quot;noexcept_spec&quot;&gt;спецификации исключений&lt;/a&gt; (так как C ++ 17).</target>
        </trans-unit>
        <trans-unit id="3deae4df87e12fce8a01835c91a2ac9242a339b1" translate="yes" xml:space="preserve">
          <source>The implicitly-declared (or defaulted on its first declaration) move constructor has an exception specification as described in &lt;a href=&quot;except_spec&quot;&gt;dynamic exception specification&lt;/a&gt;(until C++17)&lt;a href=&quot;noexcept_spec&quot;&gt;exception specification&lt;/a&gt;(since C++17).</source>
          <target state="translated">Неявно объявленных (или по умолчанию на своем первом объявлении) конструктор перемещения имеет спецификацию исключения , как описано в &lt;a href=&quot;except_spec&quot;&gt;динамической спецификации исключений&lt;/a&gt; (до С ++ 17) &lt;a href=&quot;noexcept_spec&quot;&gt;спецификации исключений&lt;/a&gt; (так как C ++ 17).</target>
        </trans-unit>
        <trans-unit id="3213a8544ac4c22b0682928a2ce16724be0fb301" translate="yes" xml:space="preserve">
          <source>The implicitly-declared copy constructor for class &lt;code&gt;T&lt;/code&gt; is undefined if any of the following conditions are true:</source>
          <target state="translated">Неявно объявленный конструктор копирования для класса &lt;code&gt;T&lt;/code&gt; не определен, если выполняется любое из следующих условий:</target>
        </trans-unit>
        <trans-unit id="6fae264774979621faa26711431abb58dbca09db" translate="yes" xml:space="preserve">
          <source>The implicitly-declared destructor is virtual (because the base class has a virtual destructor) and the lookup for the deallocation function (&lt;code&gt;&lt;a href=&quot;../memory/new/operator_delete&quot;&gt;operator delete&lt;/a&gt;()&lt;/code&gt; results in a call to ambiguous, deleted, or inaccessible function.</source>
          <target state="translated">Неявно объявленный деструктор является виртуальным (поскольку базовый класс имеет виртуальный деструктор), и поиск функции освобождения ( &lt;code&gt;&lt;a href=&quot;../memory/new/operator_delete&quot;&gt;operator delete&lt;/a&gt;()&lt;/code&gt; приводит к вызову неоднозначной, удаленной или недоступной функции).</target>
        </trans-unit>
        <trans-unit id="50ffc691488ff90f9bb81089da927863779b099a" translate="yes" xml:space="preserve">
          <source>The implicitly-declared or defaulted copy constructor for class &lt;code&gt;T&lt;/code&gt; is defined as</source>
          <target state="translated">Неявно объявленный или дефолтный конструктор копирования для класса &lt;code&gt;T&lt;/code&gt; определяется как</target>
        </trans-unit>
        <trans-unit id="08afe67b1a14690a725702d4c692f1dc10c64e2f" translate="yes" xml:space="preserve">
          <source>The implicitly-declared or defaulted default constructor for class &lt;code&gt;T&lt;/code&gt; is  undefined (until C++11)defined as deleted(since C++11) if any of the following is true:</source>
          <target state="translated">Неявно объявленный или дефолтный конструктор по умолчанию для класса &lt;code&gt;T&lt;/code&gt; не определен (до C ++ 11) и определен как удаленный (начиная с C ++ 11), если выполняется любое из следующих условий:</target>
        </trans-unit>
        <trans-unit id="65cafdb084858cf182d0ce28289e802bf9e83822" translate="yes" xml:space="preserve">
          <source>The implicitly-declared or defaulted destructor for class &lt;code&gt;T&lt;/code&gt; is  undefined (until C++11)defined as</source>
          <target state="translated">Неявно объявленный или дефолтный деструктор для класса &lt;code&gt;T&lt;/code&gt; не определен (до C ++ 11) и определен как</target>
        </trans-unit>
        <trans-unit id="e8b5ed6dfa8b272f8c00f443dfeac236e2515204" translate="yes" xml:space="preserve">
          <source>The implicitly-declared or defaulted move assignment operator for class &lt;code&gt;T&lt;/code&gt; is defined as</source>
          <target state="translated">Неявно объявленный или не заданный по умолчанию оператор присваивания перемещения для класса &lt;code&gt;T&lt;/code&gt; определяется как</target>
        </trans-unit>
        <trans-unit id="4ce2934ef2171aeb2c0ad6a343b987738915dab2" translate="yes" xml:space="preserve">
          <source>The implicitly-declared or defaulted move constructor for class &lt;code&gt;T&lt;/code&gt; is defined as</source>
          <target state="translated">Неявно объявленный или не заданный по умолчанию конструктор перемещения для класса &lt;code&gt;T&lt;/code&gt; определяется как</target>
        </trans-unit>
        <trans-unit id="ad92a1e56a9451101a860f2143c244760ecd26c4" translate="yes" xml:space="preserve">
          <source>The implicitly-defined special member functions are typically incorrect if the class is managing a resource whose handle is an object of non-class type (raw pointer, POSIX file descriptor, etc), whose destructor does nothing and copy constructor/assignment operator performs a &quot;shallow copy&quot; (copy the value of the handle, without duplicating the underlying resource).</source>
          <target state="translated">Неявно определенные специальные функции-члены,как правило,некорректны,если класс управляет ресурсом,хэндл которого является объектом неклассового типа (необработанный указатель,файловый дескриптор POSIX и т.д.),деструктор которого ничего не делает,а конструктор/оператор присваивания выполняет &quot;мелкое копирование&quot; (копирование значения хэндла,без дублирования базового ресурса).</target>
        </trans-unit>
        <trans-unit id="192f6f2391fc950f581ebc15e6c0166986a4e41a" translate="yes" xml:space="preserve">
          <source>The implicitly-generated member functions and any member function declared as defaulted on its first declaration are inline just like any other function defined inside a class definition.</source>
          <target state="translated">Неявно сгенерированные функции-члены и любая функция-член,объявленная по умолчанию при первом объявлении,являются встроенными,как и любая другая функция,определенная внутри определения класса.</target>
        </trans-unit>
        <trans-unit id="d43d2eaebfe91ea20d3c9ee4934fb21de74d02b4" translate="yes" xml:space="preserve">
          <source>The implied &lt;code&gt;lk.unlock&lt;/code&gt; is</source>
          <target state="translated">Подразумеваемой &lt;code&gt;lk.unlock&lt;/code&gt; является</target>
        </trans-unit>
        <trans-unit id="34929ac211f53c3511c4b293c3b116cd7ed0a254" translate="yes" xml:space="preserve">
          <source>The index stored in &lt;code&gt;*this&lt;/code&gt;.</source>
          <target state="translated">Индекс хранится в &lt;code&gt;*this&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="09af74812a9060b648ff5292103d113c603a82ef" translate="yes" xml:space="preserve">
          <source>The index-based overloads (1-4) fail to compile if the index &lt;code&gt;I&lt;/code&gt; is neither 0 nor 1.</source>
          <target state="translated">Перегрузки на основе индекса (1-4) не компилируются, если индекс &lt;code&gt;I&lt;/code&gt; не равен ни 0, ни 1.</target>
        </trans-unit>
        <trans-unit id="46437bdc4c7e2e85424bc222273ad44e53f18e36" translate="yes" xml:space="preserve">
          <source>The indicated operator can be applied to type &lt;code&gt;T&lt;/code&gt;</source>
          <target state="translated">Указанный оператор может быть применен к типу &lt;code&gt;T&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7846514f422b5378fb77af4cf9b31d07acbbdb16" translate="yes" xml:space="preserve">
          <source>The indirection and member operators are overloaded by many iterators and smart pointer classes.</source>
          <target state="translated">Операторы индеррекции и члены перегружены многими итераторами и классами умных указателей.</target>
        </trans-unit>
        <trans-unit id="8129cebea0ce621764c93ae2762d3f9a991933ef" translate="yes" xml:space="preserve">
          <source>The indirection operator expressions have the form.</source>
          <target state="translated">Выражения операторов-инициаторов имеют форму.</target>
        </trans-unit>
        <trans-unit id="9f172228ef4f13bff865c966d96876715b4f88e1" translate="yes" xml:space="preserve">
          <source>The information provided by this function is usually also provided as a byproduct of directory iteration, and may be obtained by the member functions of &lt;code&gt;&lt;a href=&quot;directory_entry&quot;&gt;directory_entry&lt;/a&gt;&lt;/code&gt;. During directory iteration, calling &lt;code&gt;status&lt;/code&gt; again is unnecessary.</source>
          <target state="translated">Информация, предоставляемая этой функцией, обычно также предоставляется в качестве побочного продукта итерации каталога и может быть получена функциями-членами &lt;code&gt;&lt;a href=&quot;directory_entry&quot;&gt;directory_entry&lt;/a&gt;&lt;/code&gt; . Во время итерации каталога повторный вызов &lt;code&gt;status&lt;/code&gt; не требуется.</target>
        </trans-unit>
        <trans-unit id="0116c386923508482ffe7b197c85ac890bdc4bf4" translate="yes" xml:space="preserve">
          <source>The information provided by this function is usually also provided as a byproduct of directory iteration. During directory iteration, calling &lt;code&gt;exists(*iterator)&lt;/code&gt; is less efficient than &lt;code&gt;exists(iterator-&amp;gt;status())&lt;/code&gt;.</source>
          <target state="translated">Информация, предоставляемая этой функцией, обычно также предоставляется как побочный продукт итерации каталога. Во время итерации каталога вызов &lt;code&gt;exists(*iterator)&lt;/code&gt; менее эффективен, чем &lt;code&gt;exists(iterator-&amp;gt;status())&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a8eeab648787f5a49f075a54a3ff963c76b7abfc" translate="yes" xml:space="preserve">
          <source>The inherited constructors are equivalent to user-defined constructors with an empty body and with a &lt;a href=&quot;constructor&quot;&gt;member initializer list&lt;/a&gt; consisting of a single nested-name-specifier, which forwards all of its arguments to the base class constructor.</source>
          <target state="translated">Унаследованные конструкторы эквивалентны определяемым пользователем конструкторам с пустым телом и &lt;a href=&quot;constructor&quot;&gt;списком инициализатора члена,&lt;/a&gt; состоящим из одного спецификатора вложенного имени, который перенаправляет все свои аргументы в конструктор базового класса.</target>
        </trans-unit>
        <trans-unit id="d9039e574ac657d6dcb969a83965e5c07901ebe3" translate="yes" xml:space="preserve">
          <source>The initial value may be provided in the initializer section of a &lt;a href=&quot;declarations&quot;&gt;declarator&lt;/a&gt; or a &lt;a href=&quot;new&quot;&gt;new expression&lt;/a&gt;. It also takes place during function calls: function parameters and the function return values are also initialized.</source>
          <target state="translated">Начальное значение может быть указано в разделе инициализатора &lt;a href=&quot;declarations&quot;&gt;объявления&lt;/a&gt; или в &lt;a href=&quot;new&quot;&gt;новом выражении&lt;/a&gt; . Это также происходит во время вызовов функции: параметры функции и возвращаемые значения функции также инициализируются.</target>
        </trans-unit>
        <trans-unit id="dca3507cd72234d2aa0fdea51eb1cebb2b9753f0" translate="yes" xml:space="preserve">
          <source>The initializers where class-or-identifier names a &lt;a href=&quot;derived_class&quot;&gt;virtual base class&lt;/a&gt; are ignored during execution of constructors of any class that is not the most derived class of the object that's being constructed.</source>
          <target state="translated">Инициализаторы, где class-or-identifier называют &lt;a href=&quot;derived_class&quot;&gt;виртуальным базовым классом&lt;/a&gt; , игнорируются при выполнении конструкторов любого класса, который не является самым производным классом объекта, который создается.</target>
        </trans-unit>
        <trans-unit id="51f3e6edc128bfcb0be013fd2d1ae1da69f60e07" translate="yes" xml:space="preserve">
          <source>The injected-class-name is the name of a class within the scope of said class.</source>
          <target state="translated">Имя инжектируемого класса-это имя класса в рамках данного класса.</target>
        </trans-unit>
        <trans-unit id="606b29738683260e78646411c4bd2990a0c81802" translate="yes" xml:space="preserve">
          <source>The injected-class-name of a class template or class template specialization can be used either as a template-name or a type-name wherever it is in scope.</source>
          <target state="translated">Имя инжектируемого класса-шаблона класса или специализация шаблона класса может использоваться как имя шаблона,так и имя типа,где бы оно ни находилось в области видимости.</target>
        </trans-unit>
        <trans-unit id="588b0a23a80aa452a55821a2b55a11188b48a689" translate="yes" xml:space="preserve">
          <source>The inline specifier cannot be used with a function or variable(since C++17) declaration at block scope (inside another function).</source>
          <target state="translated">Строчный спецификатор не может быть использован с объявлением функции или переменной (поскольку C++17)в области видимости блока (внутри другой функции).</target>
        </trans-unit>
        <trans-unit id="11abde87d1d2ac1bfae6d03e1fd645c8d719bd0d" translate="yes" xml:space="preserve">
          <source>The inline specifier cannot re-declare a function or variable(since C++17) that was already defined in the translation unit as non-inline.</source>
          <target state="translated">Строковый спецификатор не может повторно объявить функцию или переменную (поскольку C++17),которая уже была определена в единице трансляции как нестрочная.</target>
        </trans-unit>
        <trans-unit id="5dbd088428b0bac15f8a60242c8b9596e62e2450" translate="yes" xml:space="preserve">
          <source>The input is parsed as if by &lt;code&gt;&lt;a href=&quot;../../io/c/scanf&quot;&gt;std::scanf&lt;/a&gt;&lt;/code&gt; with the conversion specifier selected in Stage 1</source>
          <target state="translated">Входные данные анализируются как будто с помощью &lt;code&gt;&lt;a href=&quot;../../io/c/scanf&quot;&gt;std::scanf&lt;/a&gt;&lt;/code&gt; с указателем преобразования, выбранным на этапе 1</target>
        </trans-unit>
        <trans-unit id="e89c213728057cbded885c2e82d2eb3ce4460233" translate="yes" xml:space="preserve">
          <source>The input is parsed as if by &lt;code&gt;&lt;a href=&quot;../../string/byte/strtol&quot;&gt;std::strtoll&lt;/a&gt;&lt;/code&gt; for signed integer &lt;code&gt;v&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../../string/byte/strtoul&quot;&gt;std::strtoull&lt;/a&gt;&lt;/code&gt; for unsigned integer &lt;code&gt;v&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../../string/byte/strtof&quot;&gt;std::strtof&lt;/a&gt;&lt;/code&gt; for &lt;code&gt;float&lt;/code&gt;&lt;code&gt;v&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../../string/byte/strtof&quot;&gt;std::strtod&lt;/a&gt;&lt;/code&gt; for &lt;code&gt;double&lt;/code&gt;&lt;code&gt;v&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;../../string/byte/strtof&quot;&gt;std::strtold&lt;/a&gt;&lt;/code&gt; for &lt;code&gt;long double&lt;/code&gt;&lt;code&gt;v&lt;/code&gt;</source>
          <target state="translated">Входные данные анализируются как бы с помощью &lt;code&gt;&lt;a href=&quot;../../string/byte/strtol&quot;&gt;std::strtoll&lt;/a&gt;&lt;/code&gt; для целого числа со знаком &lt;code&gt;v&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../../string/byte/strtoul&quot;&gt;std::strtoull&lt;/a&gt;&lt;/code&gt; для целого числа без знака &lt;code&gt;v&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../../string/byte/strtof&quot;&gt;std::strtof&lt;/a&gt;&lt;/code&gt; для числа с &lt;code&gt;float&lt;/code&gt; &lt;code&gt;v&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../../string/byte/strtof&quot;&gt;std::strtod&lt;/a&gt;&lt;/code&gt; для &lt;code&gt;double&lt;/code&gt; &lt;code&gt;v&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;../../string/byte/strtof&quot;&gt;std::strtold&lt;/a&gt;&lt;/code&gt; для &lt;code&gt;long double&lt;/code&gt; &lt;code&gt;v&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="41603f2c61d6937ed51388a6bc806662aaa244d7" translate="yes" xml:space="preserve">
          <source>The input is parsed as if by &lt;code&gt;&lt;a href=&quot;../../string/byte/strtol&quot;&gt;std::strtoll&lt;/a&gt;&lt;/code&gt; for signed integer &lt;code&gt;v&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../../string/byte/strtoul&quot;&gt;std::strtoull&lt;/a&gt;&lt;/code&gt; for unsigned integer &lt;code&gt;v&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;../../string/byte/strtof&quot;&gt;std::strtold&lt;/a&gt;&lt;/code&gt; for floating-point &lt;code&gt;v&lt;/code&gt;</source>
          <target state="translated">Входные данные анализируются как бы с помощью &lt;code&gt;&lt;a href=&quot;../../string/byte/strtol&quot;&gt;std::strtoll&lt;/a&gt;&lt;/code&gt; для целого числа со знаком &lt;code&gt;v&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../../string/byte/strtoul&quot;&gt;std::strtoull&lt;/a&gt;&lt;/code&gt; для целого числа без знака &lt;code&gt;v&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;../../string/byte/strtof&quot;&gt;std::strtold&lt;/a&gt;&lt;/code&gt; для числа с плавающей запятой &lt;code&gt;v&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1eae9126bfe2845e4a7f3d75fa1de5c6799e7530" translate="yes" xml:space="preserve">
          <source>The inputs to an expression consist of its operands.</source>
          <target state="translated">Входные данные для выражения состоят из операндов.</target>
        </trans-unit>
        <trans-unit id="607e5d93133cf024a79ee0801db268525f2aa983" translate="yes" xml:space="preserve">
          <source>The insertion operation in &lt;code&gt;out &amp;lt;&amp;lt; put_money(mon, intl)&lt;/code&gt; behaves as a &lt;a href=&quot;../../named_req/formattedoutputfunction&quot;&gt;FormattedOutputFunction&lt;/a&gt;.</source>
          <target state="translated">Операции вставки в &lt;code&gt;out &amp;lt;&amp;lt; put_money(mon, intl)&lt;/code&gt; ведут себя как &lt;a href=&quot;../../named_req/formattedoutputfunction&quot;&gt;FormattedOutputFunction&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e7c7b3ed830ddfb4f12cf5eaf80d05dfaf6783a2" translate="yes" xml:space="preserve">
          <source>The instantiation of a</source>
          <target state="translated">инстанцирование</target>
        </trans-unit>
        <trans-unit id="e91461402009e482fb1a78f2f939226ff4aded6b" translate="yes" xml:space="preserve">
          <source>The integer value that is stored together with the callback is typically an index obtained from &lt;code&gt;&lt;a href=&quot;xalloc&quot;&gt;xalloc()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Целочисленное значение, которое сохраняется вместе с обратным вызовом, обычно является индексом, полученным из &lt;code&gt;&lt;a href=&quot;xalloc&quot;&gt;xalloc()&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e754c5d2f0c37f77dbd459373feccfde0264f302" translate="yes" xml:space="preserve">
          <source>The integral type generated by the engine. Results are undefined if this is not an unsigned integral type.</source>
          <target state="translated">Интегральный тип,генерируемый двигателем.Результаты не определены,если это не беззнаковый интегральный тип.</target>
        </trans-unit>
        <trans-unit id="40c53aad3caa79b07c6f8ca53ea06f1869a292cc" translate="yes" xml:space="preserve">
          <source>The intent of concepts is to model semantic categories (Number, Range, RegularFunction) rather than syntactic restrictions (HasPlus, Array). According to &lt;a href=&quot;https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#t20-avoid-concepts-without-meaningful-semantics&quot;&gt;ISO C++ core guideline T.20&lt;/a&gt;, &quot;The ability to specify a meaningful semantics is a defining characteristic of a true concept, as opposed to a syntactic constraint.&quot;</source>
          <target state="translated">Целью концепций является моделирование семантических категорий (Number, Range, RegularFunction), а не синтаксических ограничений (HasPlus, Array). Согласно &lt;a href=&quot;https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#t20-avoid-concepts-without-meaningful-semantics&quot;&gt;основному руководству ISO C ++ T.20&lt;/a&gt; , &amp;laquo;способность определять значимую семантику является определяющей характеристикой истинного понятия, а не синтаксического ограничения&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="619a8685fc9309dd7fa35fcbb4dc104bf7401e8a" translate="yes" xml:space="preserve">
          <source>The intent of this function is to allow &lt;a href=&quot;../../language/range-for&quot;&gt;range for loops&lt;/a&gt; to work with valarrays, not to provide container semantics.</source>
          <target state="translated">Цель этой функции - позволить &lt;a href=&quot;../../language/range-for&quot;&gt;диапазону для циклов&lt;/a&gt; работать с значениями, а не обеспечивать семантику контейнера.</target>
        </trans-unit>
        <trans-unit id="8413f561941f9afa4883b6089ece4689223790be" translate="yes" xml:space="preserve">
          <source>The intent of this requirement is to preserve binary compatibility between the C++ library complex number types and the &lt;a href=&quot;http://en.cppreference.com/w/c/language/arithmetic_types.html#Complex_floating_types&quot;&gt;C language complex number types&lt;/a&gt; (and arrays thereof), which have an identical object representation requirement.</source>
          <target state="translated">Цель этого требования - сохранить двоичную совместимость между типами комплексных чисел библиотеки C ++ и типами &lt;a href=&quot;http://en.cppreference.com/w/c/language/arithmetic_types.html#Complex_floating_types&quot;&gt;комплексных чисел языка C&lt;/a&gt; (и их массивами), которые имеют идентичное требование представления объектов.</target>
        </trans-unit>
        <trans-unit id="8f653c0dd9ae48a2397aac170d1b0f16776c082f" translate="yes" xml:space="preserve">
          <source>The interface of C++ standard library is defined by the following collection of headers.</source>
          <target state="translated">Интерфейс стандартной библиотеки C++определяется следующей коллекцией заголовков.</target>
        </trans-unit>
        <trans-unit id="6b2570d1e40f42d32deec64488687b81c00f5106" translate="yes" xml:space="preserve">
          <source>The internal pathname in generic pathname format, converted to specified string type.</source>
          <target state="translated">Внутреннее имя в общем формате,преобразованное в указанный строковый тип.</target>
        </trans-unit>
        <trans-unit id="9e600bbfc64aa5e497181bbfbd63f0f68de6a8dc" translate="yes" xml:space="preserve">
          <source>The internal pathname in native pathname format, converted to specified string type.</source>
          <target state="translated">Внутреннее имя в родном формате,преобразованное в указанный строковый тип.</target>
        </trans-unit>
        <trans-unit id="004ca417b1356b06ecce1a0eded3b5b9c702a405" translate="yes" xml:space="preserve">
          <source>The inverse of the referenced bit.</source>
          <target state="translated">Иначе говоря,это обратная часть упомянутого бита.</target>
        </trans-unit>
        <trans-unit id="94b5c297f476b2d4707fabdba8af9c74ed678810" translate="yes" xml:space="preserve">
          <source>The invocation of &lt;code&gt;setjmp&lt;/code&gt; must appear only in one of the following contexts:</source>
          <target state="translated">Вызов &lt;code&gt;setjmp&lt;/code&gt; должен появляться только в одном из следующих контекстов:</target>
        </trans-unit>
        <trans-unit id="e9cf86ded4e35142c7778644f54d0174bfb84173" translate="yes" xml:space="preserve">
          <source>The iteration order of this container is not required to be stable (so, for example, &lt;code&gt;&lt;a href=&quot;../algorithm/equal&quot;&gt;std::equal&lt;/a&gt;&lt;/code&gt; cannot be used to compare two &lt;code&gt;std::unordered_multimap&lt;/code&gt;s), except that every group of elements whose keys compare</source>
          <target state="translated">Порядок итерации этого контейнера не обязательно должен быть стабильным (поэтому, например, &lt;code&gt;&lt;a href=&quot;../algorithm/equal&quot;&gt;std::equal&lt;/a&gt;&lt;/code&gt; нельзя использовать для сравнения двух &lt;code&gt;std::unordered_multimap&lt;/code&gt; s), за исключением того, что каждая группа элементов, чьи ключи сравниваются</target>
        </trans-unit>
        <trans-unit id="97c9b700924b706247c8bc9808f1bc7725c3a1aa" translate="yes" xml:space="preserve">
          <source>The iteration order of this container is not required to be stable (so, for example, &lt;code&gt;&lt;a href=&quot;../algorithm/equal&quot;&gt;std::equal&lt;/a&gt;&lt;/code&gt; cannot be used to compare two &lt;code&gt;std::unordered_multiset&lt;/code&gt;s), except that every group of elements whose keys compare</source>
          <target state="translated">Порядок итерации этого контейнера не обязательно должен быть стабильным (поэтому, например, &lt;code&gt;&lt;a href=&quot;../algorithm/equal&quot;&gt;std::equal&lt;/a&gt;&lt;/code&gt; нельзя использовать для сравнения двух &lt;code&gt;std::unordered_multiset&lt;/code&gt; s), за исключением того, что каждая группа элементов, чьи ключи сравниваются</target>
        </trans-unit>
        <trans-unit id="1863ed213c7ef5f7feaa4f2890c2f01f674b7ab4" translate="yes" xml:space="preserve">
          <source>The iterator &lt;code&gt;first&lt;/code&gt; does not need to be dereferenceable if &lt;code&gt;first==last&lt;/code&gt;: erasing an empty range is a no-op.</source>
          <target state="translated">Итератор &lt;code&gt;first&lt;/code&gt; не должен быть разыменованным, если &lt;code&gt;first==last&lt;/code&gt; : стирание пустого диапазона не допускается.</target>
        </trans-unit>
        <trans-unit id="416bf9a217d579e782b2dcb1f169937401418ec1" translate="yes" xml:space="preserve">
          <source>The iterator &lt;code&gt;pos&lt;/code&gt; must be valid and dereferenceable. Thus the &lt;code&gt;&lt;a href=&quot;end&quot;&gt;end()&lt;/a&gt;&lt;/code&gt; iterator (which is valid, but is not dereferencable) cannot be used as a value for &lt;code&gt;pos&lt;/code&gt;.</source>
          <target state="translated">Итератор &lt;code&gt;pos&lt;/code&gt; должен быть действительным и разыменованным. Таким образом, итератор &lt;code&gt;&lt;a href=&quot;end&quot;&gt;end()&lt;/a&gt;&lt;/code&gt; (который действителен, но не может быть разыменован) не может использоваться в качестве значения для &lt;code&gt;pos&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b61e02fbf920d53ad39bacd79891eb0d1792824a" translate="yes" xml:space="preserve">
          <source>The iterator &lt;code&gt;pos&lt;/code&gt; must be valid and dereferenceable. Thus the &lt;code&gt;&lt;a href=&quot;end&quot;&gt;end()&lt;/a&gt;&lt;/code&gt; iterator (which is valid, but is not dereferenceable) cannot be used as a value for &lt;code&gt;pos&lt;/code&gt;.</source>
          <target state="translated">Итератор &lt;code&gt;pos&lt;/code&gt; должен быть действительным и разыменованным. Таким образом, итератор &lt;code&gt;&lt;a href=&quot;end&quot;&gt;end()&lt;/a&gt;&lt;/code&gt; (который действителен, но не может быть разыменован) не может использоваться в качестве значения для &lt;code&gt;pos&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2eb90b5d51c71efded43df27cab17311bc850303" translate="yes" xml:space="preserve">
          <source>The iterator equal to &lt;code&gt;first + (last - n_first)&lt;/code&gt;.</source>
          <target state="translated">Итератор равен &lt;code&gt;first + (last - n_first)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="abfb235c9222b9db1250ee25ae21c35e487f8f38" translate="yes" xml:space="preserve">
          <source>The iterator library provides definitions for five(until C++17)six(since C++17) kinds of iterators as well as iterator traits, adaptors, and utility functions.</source>
          <target state="translated">Библиотека итераторов предоставляет определения пяти(до C++17)шести(начиная с C++17)видов итераторов,а также трейтов итераторов,адаптеров и функций утилит.</target>
        </trans-unit>
        <trans-unit id="196d09b17633c1d18330b9904d4f41189e178366" translate="yes" xml:space="preserve">
          <source>The iterator obtained from this function is invalidated when the member function &lt;code&gt;resize()&lt;/code&gt; is called on the array &lt;code&gt;v&lt;/code&gt; or when the lifetime of &lt;code&gt;v&lt;/code&gt; ends, whichever comes first.</source>
          <target state="translated">Полученный из этой функции итератор становится недействительным, когда функция-член &lt;code&gt;resize()&lt;/code&gt; вызывается для массива &lt;code&gt;v&lt;/code&gt; или когда заканчивается время жизни &lt;code&gt;v&lt;/code&gt; , в зависимости от того, что наступит раньше.</target>
        </trans-unit>
        <trans-unit id="05de9016d2fdcc550169519b30085812eef58929" translate="yes" xml:space="preserve">
          <source>The iterator obtained from this function template is invalidated when the member function &lt;a href=&quot;resize&quot;&gt;&lt;code&gt;resize()&lt;/code&gt;&lt;/a&gt; is called on the array &lt;code&gt;v&lt;/code&gt; or when the lifetime of &lt;code&gt;v&lt;/code&gt; ends, whichever comes first.</source>
          <target state="translated">Итератор, полученный из этого шаблона функции, становится недействительным, когда функция-член &lt;a href=&quot;resize&quot;&gt; &lt;code&gt;resize()&lt;/code&gt; &lt;/a&gt; вызывается для массива &lt;code&gt;v&lt;/code&gt; или когда заканчивается время жизни &lt;code&gt;v&lt;/code&gt; , в зависимости от того, что наступит раньше.</target>
        </trans-unit>
        <trans-unit id="6f533c17b31181fda7a7478422455fda0c5a1103" translate="yes" xml:space="preserve">
          <source>The iterator past the end of the first partition within &lt;code&gt;[first, last)&lt;/code&gt; or &lt;code&gt;last&lt;/code&gt; if all elements satisfy &lt;code&gt;p&lt;/code&gt;.</source>
          <target state="translated">Итератор после конца первого раздела в &lt;code&gt;[first, last)&lt;/code&gt; или &lt;code&gt;last&lt;/code&gt; , если все элементы удовлетворяют &lt;code&gt;p&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="476e11b985ea98b293af90f225eabcc6be286b5e" translate="yes" xml:space="preserve">
          <source>The key comparison function object.</source>
          <target state="translated">Объект функции сравнения клавиш.</target>
        </trans-unit>
        <trans-unit id="de179c257b2f3167c894faa5512c2c228fcea52f" translate="yes" xml:space="preserve">
          <source>The key comparison function.</source>
          <target state="translated">Функция сравнения клавиш.</target>
        </trans-unit>
        <trans-unit id="4c74d4bbf1c90d9364823e4f3ebbd85ffbb952ff" translate="yes" xml:space="preserve">
          <source>The keyword &lt;a href=&quot;../keyword/template&quot;&gt;&lt;code&gt;template&lt;/code&gt;&lt;/a&gt; may appear in qualified identifiers as necessary to disambiguate &lt;a href=&quot;dependent_name&quot;&gt;dependent template names&lt;/a&gt;.</source>
          <target state="translated">Ключевое слово &lt;a href=&quot;../keyword/template&quot;&gt; &lt;code&gt;template&lt;/code&gt; &lt;/a&gt; может появляться в квалифицированных идентификаторах по мере необходимости для устранения неоднозначности &lt;a href=&quot;dependent_name&quot;&gt;имен зависимых шаблонов&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="49c5ea1550a8c0099418f191e52d2190bdb35cb8" translate="yes" xml:space="preserve">
          <source>The keyword &lt;code&gt;nullptr&lt;/code&gt; denotes the pointer literal. It is a &lt;a href=&quot;value_category&quot;&gt;prvalue&lt;/a&gt; of type &lt;code&gt;&lt;a href=&quot;../types/nullptr_t&quot;&gt;std::nullptr_t&lt;/a&gt;&lt;/code&gt;. There exist &lt;a href=&quot;implicit_cast&quot;&gt;implicit conversions&lt;/a&gt; from &lt;code&gt;nullptr&lt;/code&gt; to null pointer value of any pointer type and any pointer to member type. Similar conversions exist for any null pointer constant, which includes values of type &lt;code&gt;&lt;a href=&quot;../types/nullptr_t&quot;&gt;std::nullptr_t&lt;/a&gt;&lt;/code&gt; as well as the macro &lt;code&gt;&lt;a href=&quot;../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Ключевое слово &lt;code&gt;nullptr&lt;/code&gt; обозначает указатель литерал. Это &lt;a href=&quot;value_category&quot;&gt;значение&lt;/a&gt; типа &lt;code&gt;&lt;a href=&quot;../types/nullptr_t&quot;&gt;std::nullptr_t&lt;/a&gt;&lt;/code&gt; . Существуют &lt;a href=&quot;implicit_cast&quot;&gt;неявные преобразования&lt;/a&gt; из &lt;code&gt;nullptr&lt;/code&gt; в нулевое значение указателя любого типа указателя и любого указателя на тип члена. Аналогичные преобразования существуют для любой константы нулевого указателя, которая включает в себя значения типа &lt;code&gt;&lt;a href=&quot;../types/nullptr_t&quot;&gt;std::nullptr_t&lt;/a&gt;&lt;/code&gt; а также макрос &lt;code&gt;&lt;a href=&quot;../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cc50291017180e4feb23c15b01028337ea026e19" translate="yes" xml:space="preserve">
          <source>The keyword &lt;code&gt;requires&lt;/code&gt; is also used to begin a</source>
          <target state="translated">Ключевое слово &lt;code&gt;requires&lt;/code&gt; также используется, чтобы начать</target>
        </trans-unit>
        <trans-unit id="38ca54bb4a4020554bc23191438cf8b9378a16b3" translate="yes" xml:space="preserve">
          <source>The keyword &lt;code&gt;requires&lt;/code&gt; is used to introduce a</source>
          <target state="translated">Ключевое слово &lt;code&gt;requires&lt;/code&gt; используется, чтобы ввести</target>
        </trans-unit>
        <trans-unit id="0f400e14a3942078db12d200e17dbee2a1ed3dcd" translate="yes" xml:space="preserve">
          <source>The keyword &lt;code&gt;template&lt;/code&gt; may only be used in this way after operators &lt;code&gt;::&lt;/code&gt; (scope resolution), &lt;code&gt;-&amp;gt;&lt;/code&gt; (member access through pointer), and &lt;code&gt;.&lt;/code&gt; (member access), the following are all valid examples:</source>
          <target state="translated">Ключевое слово &lt;code&gt;template&lt;/code&gt; может использоваться таким образом только после операторов &lt;code&gt;::&lt;/code&gt; (разрешение области), &lt;code&gt;-&amp;gt;&lt;/code&gt; (доступ к элементу через указатель) и &lt;code&gt;.&lt;/code&gt; (членский доступ), все следующие действительные примеры:</target>
        </trans-unit>
        <trans-unit id="13bd0f41e6a40479c82db81587bd210c9975f65f" translate="yes" xml:space="preserve">
          <source>The keyword &lt;code&gt;this&lt;/code&gt; is a &lt;a href=&quot;value_category&quot;&gt;prvalue&lt;/a&gt;&lt;a href=&quot;expressions&quot;&gt;expression&lt;/a&gt; whose value is the address of the object, on which the member function is being called. It can appear in the following contexts:</source>
          <target state="translated">Ключевое слово &lt;code&gt;this&lt;/code&gt; является &lt;a href=&quot;expressions&quot;&gt;выражением &lt;/a&gt;&lt;a href=&quot;value_category&quot;&gt;prvalue&lt;/a&gt; , значением которого является адрес объекта, для которого вызывается функция-член. Это может появиться в следующих контекстах:</target>
        </trans-unit>
        <trans-unit id="5fb21cb06e25fb3ea23dccf8da1e5fef70f7615d" translate="yes" xml:space="preserve">
          <source>The keyword &lt;code&gt;typename&lt;/code&gt; can be used even outside of templates.</source>
          <target state="translated">Ключевое слово &lt;code&gt;typename&lt;/code&gt; может использоваться даже вне шаблонов.</target>
        </trans-unit>
        <trans-unit id="78b1b9af4e7e3fe2a278d800536b1dea324a61db" translate="yes" xml:space="preserve">
          <source>The keyword &lt;code&gt;typename&lt;/code&gt; may only be used in this way before qualified names (e.g. &lt;code&gt;T::x&lt;/code&gt;), but the names need not be dependent.</source>
          <target state="translated">Ключевое слово &lt;code&gt;typename&lt;/code&gt; может использоваться таким образом только перед квалифицированными именами (например, &lt;code&gt;T::x&lt;/code&gt; ), но имена не должны быть зависимыми.</target>
        </trans-unit>
        <trans-unit id="79655a71967b64b901ff64e9dbeb497972506960" translate="yes" xml:space="preserve">
          <source>The keyword &lt;code&gt;typename&lt;/code&gt; must only be used in template declarations and definitions and only in contexts in which dependent names can be used. This excludes explicit specialization declarations and explicit instantiation declarations.</source>
          <target state="translated">Ключевое слово &lt;code&gt;typename&lt;/code&gt; должно использоваться только в объявлениях и определениях шаблонов и только в тех контекстах, в которых могут использоваться зависимые имена. Это исключает явные объявления специализации и явные объявления экземпляров.</target>
        </trans-unit>
        <trans-unit id="95a190feaf53fdb99612657d6559e66695dae193" translate="yes" xml:space="preserve">
          <source>The keyword is unused and reserved.</source>
          <target state="translated">Ключевое слово не используется и зарезервировано.</target>
        </trans-unit>
        <trans-unit id="58bf644951168b25add914fb2af57f56e1426658" translate="yes" xml:space="preserve">
          <source>The keyword-like forms (&lt;code&gt;and&lt;/code&gt;,&lt;code&gt;or&lt;/code&gt;,&lt;code&gt;not&lt;/code&gt;) and the symbol-like forms (&lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt;,&lt;code&gt;||&lt;/code&gt;,&lt;code&gt;!&lt;/code&gt;) can be used interchangeably (See &lt;a href=&quot;operator_alternative&quot;&gt;alternative representations&lt;/a&gt;)</source>
          <target state="translated">Ключевое слово-подобные формы ( &lt;code&gt;and&lt;/code&gt; , &lt;code&gt;or&lt;/code&gt; , &lt;code&gt;not&lt;/code&gt; ) и символ-подобных форм ( &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; , &lt;code&gt;||&lt;/code&gt; , &lt;code&gt;!&lt;/code&gt; ) Могут быть использованы как взаимозаменяемые (см &lt;a href=&quot;operator_alternative&quot;&gt;альтернативных представлений&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="8387e8b5a34e9a813a529166973aeadc61823549" translate="yes" xml:space="preserve">
          <source>The lambda expression is a prvalue expression of unique unnamed non-union non-aggregate class type, known as</source>
          <target state="translated">Выражение лямбда является prvalue-выражением уникального безымянного не-союзного неагрессивного типа класса,известного под названием</target>
        </trans-unit>
        <trans-unit id="1dc3cef4c1069bfe1bc8a146544fa3fcdd7f2326" translate="yes" xml:space="preserve">
          <source>The largest allocation size that is required to be fulfilled using the pooling mechanism. Attempts to allocate a single block larger than this threshold will be allocated directly from the upstream &lt;code&gt;&lt;a href=&quot;memory_resource&quot;&gt;std::pmr::memory_resource&lt;/a&gt;&lt;/code&gt;. If &lt;code&gt;largest_required_pool_block&lt;/code&gt; is zero or is greater than an implementation-defined limit, that limit is used instead. The implementation may choose a pass-through threshold larger than specified in this field.</source>
          <target state="translated">Наибольший размер выделения, который требуется выполнить с помощью механизма объединения. Попытки выделить один блок, больший, чем этот порог, будут выделены непосредственно из восходящего потока &lt;code&gt;&lt;a href=&quot;memory_resource&quot;&gt;std::pmr::memory_resource&lt;/a&gt;&lt;/code&gt; . Если &lt;code&gt;largest_required_pool_block&lt;/code&gt; равен нулю или превышает предел, определенный реализацией, вместо этого используется этот предел. Реализация может выбрать порог прохода, больший, чем указано в этом поле.</target>
        </trans-unit>
        <trans-unit id="0f76fd3117478f278b8a26d22cae6980cc3dc7bc" translate="yes" xml:space="preserve">
          <source>The largest block size and maximum chunk size may be tuned by passing a &lt;code&gt;&lt;a href=&quot;pool_options&quot;&gt;std::pmr::pool_options&lt;/a&gt;&lt;/code&gt; struct to its constructor.</source>
          <target state="translated">Наибольший размер блока и максимальный размер фрагмента могут быть настроены путем передачи структуры &lt;code&gt;&lt;a href=&quot;pool_options&quot;&gt;std::pmr::pool_options&lt;/a&gt;&lt;/code&gt; его конструктору.</target>
        </trans-unit>
        <trans-unit id="5a4ed139500fd5d555f2f6faa85fd84cfda82ebd" translate="yes" xml:space="preserve">
          <source>The largest possible number of char-like objects that can be referred to by a &lt;code&gt;basic_string_view&lt;/code&gt;.</source>
          <target state="translated">Максимально возможное количество объектов типа char, на которые можно ссылаться при помощи &lt;code&gt;basic_string_view&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a8c1d33c39832e1576d640ab855b96a2c40bccb6" translate="yes" xml:space="preserve">
          <source>The largest representable floating-point values are exact integers in all standard floating-point formats, so &lt;code&gt;std::nearbyint&lt;/code&gt; never overflows on its own; however the result may overflow any integer type (including &lt;code&gt;&lt;a href=&quot;../../types/integer&quot;&gt;std::intmax_t&lt;/a&gt;&lt;/code&gt;), when stored in an integer variable.</source>
          <target state="translated">Самые большие представимые значения с плавающей точкой являются точными целыми числами во всех стандартных форматах с плавающей точкой, поэтому &lt;code&gt;std::nearbyint&lt;/code&gt; никогда не переполняется сам по себе; однако результат может быть переполнен любым целочисленным типом (включая &lt;code&gt;&lt;a href=&quot;../../types/integer&quot;&gt;std::intmax_t&lt;/a&gt;&lt;/code&gt; ) при хранении в целочисленной переменной.</target>
        </trans-unit>
        <trans-unit id="0e0e71108205254bc43c1052dde67ff6846b625e" translate="yes" xml:space="preserve">
          <source>The largest representable floating-point values are exact integers in all standard floating-point formats, so &lt;code&gt;std::rint&lt;/code&gt; never overflows on its own; however the result may overflow any integer type (including &lt;code&gt;&lt;a href=&quot;../../types/integer&quot;&gt;std::intmax_t&lt;/a&gt;&lt;/code&gt;), when stored in an integer variable.</source>
          <target state="translated">Самые большие представимые значения с плавающей точкой являются точными целыми числами во всех стандартных форматах с плавающей точкой, поэтому &lt;code&gt;std::rint&lt;/code&gt; никогда не переполняется сам по себе; однако результат может быть переполнен любым целочисленным типом (включая &lt;code&gt;&lt;a href=&quot;../../types/integer&quot;&gt;std::intmax_t&lt;/a&gt;&lt;/code&gt; ) при хранении в целочисленной переменной.</target>
        </trans-unit>
        <trans-unit id="fdc448092c1ae5b510cac2bc24fecc523a9a01e6" translate="yes" xml:space="preserve">
          <source>The largest representable floating-point values are exact integers in all standard floating-point formats, so &lt;code&gt;std::round&lt;/code&gt; never overflows on its own; however the result may overflow any integer type (including &lt;code&gt;&lt;a href=&quot;../../types/integer&quot;&gt;std::intmax_t&lt;/a&gt;&lt;/code&gt;), when stored in an integer variable.</source>
          <target state="translated">Самые большие представимые значения с плавающей точкой являются точными целыми числами во всех стандартных форматах с плавающей точкой, поэтому &lt;code&gt;std::round&lt;/code&gt; никогда не переполняется сам по себе; однако результат может быть переполнен любым целочисленным типом (включая &lt;code&gt;&lt;a href=&quot;../../types/integer&quot;&gt;std::intmax_t&lt;/a&gt;&lt;/code&gt; ) при хранении в целочисленной переменной.</target>
        </trans-unit>
        <trans-unit id="149a06b50d59b602c5dedd71bc2f5b4d4782a259" translate="yes" xml:space="preserve">
          <source>The largest representable floating-point values are exact integers in all standard floating-point formats, so this function never overflows on its own; however the result may overflow any integer type (including &lt;code&gt;&lt;a href=&quot;../../types/integer&quot;&gt;std::intmax_t&lt;/a&gt;&lt;/code&gt;), when stored in an integer variable.</source>
          <target state="translated">Самые большие представимые значения с плавающей точкой являются точными целыми числами во всех стандартных форматах с плавающей точкой, поэтому эта функция никогда не переполняется сама по себе; однако результат может быть переполнен любым целочисленным типом (включая &lt;code&gt;&lt;a href=&quot;../../types/integer&quot;&gt;std::intmax_t&lt;/a&gt;&lt;/code&gt; ) при хранении в целочисленной переменной.</target>
        </trans-unit>
        <trans-unit id="ccc3bae22c3039b6aa4ddd26ffed5dd3a3801a47" translate="yes" xml:space="preserve">
          <source>The last character in</source>
          <target state="translated">Последний персонаж в</target>
        </trans-unit>
        <trans-unit id="d97f60f8595e3388c7571dd07273229e64ab3160" translate="yes" xml:space="preserve">
          <source>The last modification time for the referred-to filesystem object.</source>
          <target state="translated">Последнее время модификации для объекта файловой системы ссылок.</target>
        </trans-unit>
        <trans-unit id="003204e389b9da8284fc1fb45f6c42edd43b43df" translate="yes" xml:space="preserve">
          <source>The latin &lt;a href=&quot;https://en.wikipedia.org/wiki/Long_s&quot;&gt;letter 'ſ' (U+017F)&lt;/a&gt; is the alternative lowercase form of 'S' (U+0053).</source>
          <target state="translated">Латинская &lt;a href=&quot;https://en.wikipedia.org/wiki/Long_s&quot;&gt;буква &amp;laquo;ſ&amp;raquo; (U + 017F)&lt;/a&gt; является альтернативной строчной формой &amp;laquo;S&amp;raquo; (U + 0053).</target>
        </trans-unit>
        <trans-unit id="7e8b919f2dc439db08daff4c3a4bb57cb3581675" translate="yes" xml:space="preserve">
          <source>The leading zero generated by the conversion specification &lt;code&gt;#o&lt;/code&gt; (resulting from the combination of &lt;code&gt;&lt;a href=&quot;../../io/manip/showbase&quot;&gt;std::showbase&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../../io/manip/hex&quot;&gt;std::oct&lt;/a&gt;&lt;/code&gt; for example) is not counted as a padding character.</source>
          <target state="translated">Начальный ноль, сгенерированный спецификацией преобразования &lt;code&gt;#o&lt;/code&gt; (например, полученный в результате комбинации &lt;code&gt;&lt;a href=&quot;../../io/manip/showbase&quot;&gt;std::showbase&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;../../io/manip/hex&quot;&gt;std::oct&lt;/a&gt;&lt;/code&gt; ), не считается символом заполнения.</target>
        </trans-unit>
        <trans-unit id="bae67611e59a74badd8c128046df5c4dafdb9b1d" translate="yes" xml:space="preserve">
          <source>The length of character sequence pointed to by &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="translated">Длина последовательности символов, на которую указывает &lt;code&gt;s&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="198958162200c69daf435147f9c229df71f282ff" translate="yes" xml:space="preserve">
          <source>The length of the maximum initial segment that contains only characters from byte string pointed to by &lt;code&gt;src&lt;/code&gt;.</source>
          <target state="translated">Длина максимального начального сегмента, который содержит только символы из байтовой строки, на которую указывает &lt;code&gt;src&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="63de454d6ebc822ff35b5de2988085c7a2c0e23c" translate="yes" xml:space="preserve">
          <source>The length of the maximum initial segment that contains only characters from wide string pointed to by &lt;code&gt;src&lt;/code&gt;.</source>
          <target state="translated">Длина максимального начального сегмента, который содержит только символы из широкой строки, на которую указывает &lt;code&gt;src&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="83dc1b81260e13a56926b8fcc5b2fc9652de1176" translate="yes" xml:space="preserve">
          <source>The length of the maximum initial segment that contains only characters not found in the byte string pointed to by &lt;code&gt;src&lt;/code&gt;.</source>
          <target state="translated">Длина максимального начального сегмента, который содержит только символы, не найденные в байтовой строке, на которую указывает &lt;code&gt;src&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5f772a2bec6f10a883f7267bd67367b712ef3954" translate="yes" xml:space="preserve">
          <source>The length of the maximum initial segment that contains only characters not found in the character string pointed to by &lt;code&gt;src&lt;/code&gt;.</source>
          <target state="translated">Длина максимального начального сегмента, который содержит только символы, не найденные в строке символов, на которую указывает &lt;code&gt;src&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8fe0dd8d74988395bb6129f5a7e4490356eb2a0b" translate="yes" xml:space="preserve">
          <source>The length of the null-terminated character string.</source>
          <target state="translated">Длина нулевой строки символов.</target>
        </trans-unit>
        <trans-unit id="c0686acb8c60390ca16c8404e742b7a9caf518b0" translate="yes" xml:space="preserve">
          <source>The length of the null-terminated string &lt;code&gt;str&lt;/code&gt;.</source>
          <target state="translated">Длина строки с нулевым символом в конце &lt;code&gt;str&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="70aa39cc3ba65fdf92c15438e02fd88c74004295" translate="yes" xml:space="preserve">
          <source>The length of the null-terminated wide string &lt;code&gt;str&lt;/code&gt;.</source>
          <target state="translated">Длина строки с нулевым символом в конце &lt;code&gt;str&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="569fe0bc480cb2d8fd1b576d50ac246394b981a8" translate="yes" xml:space="preserve">
          <source>The length of the specified match or sub-match.</source>
          <target state="translated">Длина указанного матча или подматча.</target>
        </trans-unit>
        <trans-unit id="593d216bcb63cbce0afb160433d1ab015cf4835d" translate="yes" xml:space="preserve">
          <source>The length of the transformed string, not including the terminating null-character.</source>
          <target state="translated">Длина преобразованной строки,без учета оконечного null-символа.</target>
        </trans-unit>
        <trans-unit id="e3b3ec34feef4d29ba71c02ffc289279c3d65e7e" translate="yes" xml:space="preserve">
          <source>The length of the transformed wide string, not including the terminating null-character.</source>
          <target state="translated">Длина преобразованной широкой строки,без учета оконечного null-символа.</target>
        </trans-unit>
        <trans-unit id="ed8baa6719cd710e95a7b3c07ae38fff0961e9d8" translate="yes" xml:space="preserve">
          <source>The level of support for the open modes other than &lt;code&gt;&lt;a href=&quot;../ios_base/openmode&quot;&gt;std::ios_base::in&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../ios_base/openmode&quot;&gt;std::ios_base::out&lt;/a&gt;&lt;/code&gt; varies among implementations. C++11 explicitly specifies the support for &lt;code&gt;&lt;a href=&quot;../ios_base/openmode&quot;&gt;std::ios_base::ate&lt;/a&gt;&lt;/code&gt; in &lt;code&gt;&lt;a href=&quot;str&quot;&gt;str()&lt;/a&gt;&lt;/code&gt; and in this constructor, but &lt;code&gt;&lt;a href=&quot;../ios_base/openmode&quot;&gt;std::ios_base::app&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../ios_base/openmode&quot;&gt;std::ios_base::trunc&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;../ios_base/openmode&quot;&gt;std::ios_base::binary&lt;/a&gt;&lt;/code&gt; have different effects on different implementations.</source>
          <target state="translated">Уровень поддержки открытых режимов, отличных от &lt;code&gt;&lt;a href=&quot;../ios_base/openmode&quot;&gt;std::ios_base::in&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;../ios_base/openmode&quot;&gt;std::ios_base::out&lt;/a&gt;&lt;/code&gt; варьируется в зависимости от реализации. C ++ 11 явно указывает поддержку &lt;code&gt;&lt;a href=&quot;../ios_base/openmode&quot;&gt;std::ios_base::ate&lt;/a&gt;&lt;/code&gt; в &lt;code&gt;&lt;a href=&quot;str&quot;&gt;str()&lt;/a&gt;&lt;/code&gt; и в этом конструкторе, но &lt;code&gt;&lt;a href=&quot;../ios_base/openmode&quot;&gt;std::ios_base::app&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../ios_base/openmode&quot;&gt;std::ios_base::trunc&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;../ios_base/openmode&quot;&gt;std::ios_base::binary&lt;/a&gt;&lt;/code&gt; имеют разные эффекты на разные реализации.</target>
        </trans-unit>
        <trans-unit id="557e0b119e086c3a7c5bcdd2f05ba46d098531ff" translate="yes" xml:space="preserve">
          <source>The library provides overloads for all signed and unsigned integer types and &lt;code&gt;char&lt;/code&gt; as the referenced type of the parameter &lt;code&gt;value&lt;/code&gt;. 2-4) Floating-point parsers: Expects the pattern identical to the one used by &lt;code&gt;&lt;a href=&quot;../string/byte/strtof&quot;&gt;std::strtod&lt;/a&gt;&lt;/code&gt; in the default (&quot;C&quot;) locale, except that</source>
          <target state="translated">Библиотека обеспечивает перегрузки для всех целочисленных типов со &lt;code&gt;char&lt;/code&gt; и без знака и символа в качестве ссылочного типа &lt;code&gt;value&lt;/code&gt; параметра . 2-4) Парсеры с плавающей запятой: ожидает шаблон, идентичный тому, который используется &lt;code&gt;&lt;a href=&quot;../string/byte/strtof&quot;&gt;std::strtod&lt;/a&gt;&lt;/code&gt; в локали по умолчанию (&quot;C&quot;), за исключением того, что</target>
        </trans-unit>
        <trans-unit id="0c00bda8553a4155113db78626e8f2751d276761" translate="yes" xml:space="preserve">
          <source>The library versions of &lt;a href=&quot;../new/operator_new&quot;&gt;&lt;code&gt;operator new&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../new/operator_delete&quot;&gt;&lt;code&gt;operator delete&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">Библиотека версий &lt;a href=&quot;../new/operator_new&quot;&gt; &lt;code&gt;operator new&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;../new/operator_delete&quot;&gt; &lt;code&gt;operator delete&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="8ed95002f088794bbcb4dda6067ef23523590d14" translate="yes" xml:space="preserve">
          <source>The library versions of &lt;a href=&quot;operator_new&quot;&gt;&lt;code&gt;operator new&lt;/code&gt;&lt;/a&gt; and &lt;strong&gt;&lt;code&gt;operator delete&lt;/code&gt;&lt;/strong&gt;</source>
          <target state="translated">Библиотека версий &lt;a href=&quot;operator_new&quot;&gt; &lt;code&gt;operator new&lt;/code&gt; &lt;/a&gt; и &lt;strong&gt; &lt;code&gt;operator delete&lt;/code&gt; &lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="be0df0b3b3695421bdf2d17b88a03ae80713339f" translate="yes" xml:space="preserve">
          <source>The library versions of &lt;strong&gt;&lt;code&gt;operator new&lt;/code&gt;&lt;/strong&gt; and &lt;a href=&quot;operator_delete&quot;&gt;&lt;code&gt;operator delete&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">Библиотека версий &lt;strong&gt; &lt;code&gt;operator new&lt;/code&gt; &lt;/strong&gt; и &lt;a href=&quot;operator_delete&quot;&gt; &lt;code&gt;operator delete&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="9a277b5aee4eef17b2deb4d6d21114b2a958a7d0" translate="yes" xml:space="preserve">
          <source>The lifetime of a &lt;a href=&quot;reference&quot;&gt;reference&lt;/a&gt; begins when its initialization is complete and ends as if it were a scalar object.</source>
          <target state="translated">Время жизни &lt;a href=&quot;reference&quot;&gt;ссылки&lt;/a&gt; начинается, когда ее инициализация завершена, и заканчивается, как если бы это был скалярный объект.</target>
        </trans-unit>
        <trans-unit id="89060782836e6f22829eef94ab23da8fa518fbc4" translate="yes" xml:space="preserve">
          <source>The lifetime of a temporary object created when evaluating the default arguments of a default constructor used to initialize an element of an array ends before the next element of the array begins initialization.</source>
          <target state="translated">Время жизни временного объекта,созданного при вычислении аргументов по умолчанию конструктора по умолчанию,используемого для инициализации элемента массива,заканчивается до начала инициализации следующего элемента массива.</target>
        </trans-unit>
        <trans-unit id="d83f5d7c17e682f051804ccec8769174402ff049" translate="yes" xml:space="preserve">
          <source>The lifetime of a temporary object may be extended by binding to a const lvalue reference or to an rvalue reference(since C++11), see &lt;a href=&quot;reference_initialization#Lifetime_of_a_temporary&quot;&gt;reference initialization&lt;/a&gt; for details.</source>
          <target state="translated">Время жизни временного объекта может быть увеличено путем привязки к ссылке на постоянное значение или к ссылке на значение (начиная с C ++ 11), подробности см. В разделе &lt;a href=&quot;reference_initialization#Lifetime_of_a_temporary&quot;&gt;инициализация ссылки&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="076f84edd8eb9b71ed85703e28397b69b08f0333" translate="yes" xml:space="preserve">
          <source>The lifetime of an object must exceed the lifetime of all &lt;code&gt;atomic_ref&lt;/code&gt;s that references the object. While any &lt;code&gt;atomic_ref&lt;/code&gt; instances referencing an object exists, the object must be exclusively accessed through these &lt;code&gt;atomic_ref&lt;/code&gt; instances. No subobject of an object referenced by an &lt;code&gt;atomic_ref&lt;/code&gt; object may be concurrently referenced by any other &lt;code&gt;atomic_ref&lt;/code&gt; object.</source>
          <target state="translated">Время жизни объекта должно превышать время жизни всех &lt;code&gt;atomic_ref&lt;/code&gt; , которые ссылаются на объект. Хотя любые экземпляры &lt;code&gt;atomic_ref&lt;/code&gt; , ссылающиеся на объект, существуют, доступ к объекту должен осуществляться исключительно через эти экземпляры &lt;code&gt;atomic_ref&lt;/code&gt; . Никакой подобъект объекта, на который &lt;code&gt;atomic_ref&lt;/code&gt; объект atomic_ref, не может быть одновременно указан любой другой &lt;code&gt;atomic_ref&lt;/code&gt; объект atomic_ref .</target>
        </trans-unit>
        <trans-unit id="a71cb474b6739261f5b46ecfbc97690fb132e551" translate="yes" xml:space="preserve">
          <source>The lifetime of the array pointed to by the returned pointer is not specified, but in practice it persist as long as the RTTI data structure for the given type exists, which has application lifetime unless loaded from a dynamic library (that can be unloaded).</source>
          <target state="translated">Время жизни массива,на который указывает возвращаемый указатель,не указано,но на практике оно сохраняется до тех пор,пока существует структура данных RTTI для данного типа,которая имеет время жизни приложения,если не загружена из динамической библиотеки (которая может быть выгружена).</target>
        </trans-unit>
        <trans-unit id="f43e95e8be78827b0fca16403fd5210ff788dde7" translate="yes" xml:space="preserve">
          <source>The lifetime of the coroutine state is strictly nested within the lifetime of the caller, and</source>
          <target state="translated">Жизнь корутинового состояния строго вложена в жизнь вызывающего абонента,и</target>
        </trans-unit>
        <trans-unit id="5a0b7c168044f4f8abc53a10a8fba540177660d1" translate="yes" xml:space="preserve">
          <source>The list of base classes is provided in the base-clause of the &lt;a href=&quot;class&quot;&gt;class declaration syntax&lt;/a&gt;. The base-clause consists of the character &lt;code&gt;:&lt;/code&gt; followed by a comma-separated list of one or more base-specifiers.</source>
          <target state="translated">Список базовых классов приведен в предложении base &lt;a href=&quot;class&quot;&gt;синтаксиса объявления класса&lt;/a&gt; . Базовое предложение состоит из символа &lt;code&gt;:&lt;/code&gt; за которым следует разделенный запятыми список из одного или нескольких спецификаторов базы.</target>
        </trans-unit>
        <trans-unit id="e8509d637336c6e1606720db4e003e047c2a510a" translate="yes" xml:space="preserve">
          <source>The list of exceptions in a &lt;a href=&quot;except_spec&quot;&gt;dynamic exception specification&lt;/a&gt; may also be a pack expansion.</source>
          <target state="translated">Список исключений в &lt;a href=&quot;except_spec&quot;&gt;спецификации динамических исключений&lt;/a&gt; также может быть расширением пакета.</target>
        </trans-unit>
        <trans-unit id="1d2a38cb5249a278425f59d24c4f0053fd48d52a" translate="yes" xml:space="preserve">
          <source>The list of parameters, as in &lt;a href=&quot;function&quot;&gt;named functions&lt;/a&gt;, except that &lt;a href=&quot;default_arguments&quot;&gt;default arguments&lt;/a&gt; are not allowed(until C++14). If &lt;code&gt;auto&lt;/code&gt; is used as a type of a parameter, the lambda is a</source>
          <target state="translated">Список параметров, как в &lt;a href=&quot;function&quot;&gt;именованных функциях&lt;/a&gt; , за исключением того, что &lt;a href=&quot;default_arguments&quot;&gt;аргументы по умолчанию&lt;/a&gt; не допускаются (до C ++ 14). Если &lt;code&gt;auto&lt;/code&gt; используется как тип параметра, лямбда</target>
        </trans-unit>
        <trans-unit id="56ba40ec75d4e586507c6a313f3b68e7ecfe238c" translate="yes" xml:space="preserve">
          <source>The locale before the call to this function. Effectively returns the result of expression &lt;code&gt;traits_i.imbue(loc)&lt;/code&gt;.</source>
          <target state="translated">Локаль перед вызовом этой функции. Эффективно возвращает результат выражения &lt;code&gt;traits_i.imbue(loc)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5a529ceb5bbb923af9b086a8c649b5e092235f98" translate="yes" xml:space="preserve">
          <source>The locale facility includes internationalization support for character classification and string collation, numeric, monetary, and date/time formatting and parsing, and message retrieval. Locale settings control the behavior of stream I/O, regular expression library, and other components of the C++ standard library.</source>
          <target state="translated">Подсистема локали включает поддержку интернационализации для классификации символов и сопоставления строк,цифрового,денежного и форматирования и разбора даты/времени,а также поиска сообщений.Настройки локали контролируют поведение потокового ввода/вывода,библиотеки регулярных выражений и других компонентов стандартной библиотеки C++.</target>
        </trans-unit>
        <trans-unit id="6a18c5b3999c487308a7e91b96715e80aeb807b2" translate="yes" xml:space="preserve">
          <source>The locale object, associated with the stream before the operation.</source>
          <target state="translated">Объект локали,связанный с потоком перед операцией.</target>
        </trans-unit>
        <trans-unit id="634778b18ec9739eca32858af18b0dca1f0f0da1" translate="yes" xml:space="preserve">
          <source>The locale used for localized behavior in the regular expression. Must be &lt;a href=&quot;../named_req/copyconstructible&quot;&gt;CopyConstructible&lt;/a&gt;</source>
          <target state="translated">Локаль используется для локализованного поведения в регулярном выражении. Должно быть &lt;a href=&quot;../named_req/copyconstructible&quot;&gt;CopyConstructible&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="8def683f0d8be3b6186d5dfddb9cf73b5969d06c" translate="yes" xml:space="preserve">
          <source>The logic operator expressions have the form.</source>
          <target state="translated">Выражения логических операторов имеют форму.</target>
        </trans-unit>
        <trans-unit id="c3300cacfe4a9fc0c17331372ee202459b693b68" translate="yes" xml:space="preserve">
          <source>The logical complement of the result of calling &lt;code&gt;pred(x)&lt;/code&gt;.</source>
          <target state="translated">Логическое дополнение результата вызова &lt;code&gt;pred(x)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cba68059335b1355e50f5ebe51cc201e645ee88a" translate="yes" xml:space="preserve">
          <source>The logical complement of the result of calling &lt;code&gt;pred(x, y)&lt;/code&gt;.</source>
          <target state="translated">Логическое дополнение результата вызова &lt;code&gt;pred(x, y)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8fdd4b0ecee0c4aa58c8a23319359361fe1a2339" translate="yes" xml:space="preserve">
          <source>The lognormal_distribution random number distribution produces random numbers x &amp;gt; 0 according to a &lt;a href=&quot;https://en.wikipedia.org/wiki/Log-normal_distribution&quot;&gt;log-normal distribution&lt;/a&gt;:  f(x; m,s) =</source>
          <target state="translated">Распределение случайных чисел lognormal_distribution создает случайные числа x&amp;gt; 0 в соответствии с &lt;a href=&quot;https://en.wikipedia.org/wiki/Log-normal_distribution&quot;&gt;нормальным логарифмическим распределением&lt;/a&gt; : f (x; m, s) =</target>
        </trans-unit>
        <trans-unit id="c212e644a85dc2243b9b6984f045c993a30403ee" translate="yes" xml:space="preserve">
          <source>The lookup for member &lt;code&gt;get&lt;/code&gt; ignores accessibility as usual and also ignores the exact type of the non-type template parameter. A private &lt;code&gt;template&amp;lt;char*&amp;gt; void get();&lt;/code&gt; member will cause the member interpretation to be used, even though it is ill-formed.</source>
          <target state="translated">Поиск элемента &lt;code&gt;get&lt;/code&gt; игнорирует доступность как обычно, а также игнорирует точный тип параметра шаблона нетипичного типа. Закрытый &lt;code&gt;template&amp;lt;char*&amp;gt; void get();&lt;/code&gt; член будет вызывать использование интерпретации члена, даже если она неверно сформирована.</target>
        </trans-unit>
        <trans-unit id="25f8094c991911b431b2e09c25ab9f0d486ffb8e" translate="yes" xml:space="preserve">
          <source>The lookup for the identifier &lt;code&gt;swap&lt;/code&gt; in the exception specification finds this function template in addition to anything found by the usual lookup rules, making the exception specification equivalent to C++17 &lt;code&gt;&lt;a href=&quot;../types/is_swappable&quot;&gt;std::is_nothrow_swappable&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Поиск для идентификатора &lt;code&gt;swap&lt;/code&gt; в спецификации исключения находит этот шаблон функции в дополнении к чему - либо найденному по обычным правилам подстановки, делая исключение спецификации эквивалента C ++ 17 &lt;code&gt;&lt;a href=&quot;../types/is_swappable&quot;&gt;std::is_nothrow_swappable&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d22abe7f13a33e5aaa7ba9fe7d2fe4cac70e1316" translate="yes" xml:space="preserve">
          <source>The macro &lt;code&gt;&lt;a href=&quot;../types/offsetof&quot;&gt;offsetof&lt;/a&gt;&lt;/code&gt; may be used to determine the offset of any member from the beginning of a standard-layout class.</source>
          <target state="translated">Макрос &lt;code&gt;&lt;a href=&quot;../types/offsetof&quot;&gt;offsetof&lt;/a&gt;&lt;/code&gt; может использоваться для определения смещения любого члена от начала класса стандартной компоновки.</target>
        </trans-unit>
        <trans-unit id="c041240d72efe54a8080b43aef6a5e9d20fb0e98" translate="yes" xml:space="preserve">
          <source>The macro &lt;code&gt;&lt;a href=&quot;offsetof&quot;&gt;offsetof&lt;/a&gt;&lt;/code&gt; can only be used with standard-layout classes.</source>
          <target state="translated">Макрос &lt;code&gt;&lt;a href=&quot;offsetof&quot;&gt;offsetof&lt;/a&gt;&lt;/code&gt; может использоваться только с классами стандартной компоновки.</target>
        </trans-unit>
        <trans-unit id="a80e1699fb25e0be7eaf64d7cde6fed39109e343" translate="yes" xml:space="preserve">
          <source>The macro &lt;code&gt;NAN&lt;/code&gt; expands to constant expression of type &lt;code&gt;float&lt;/code&gt; which evaluates to a quiet not-a-number (QNaN) value. If the implementation does not support QNaNs, this macro constant is not defined.</source>
          <target state="translated">Макрос &lt;code&gt;NAN&lt;/code&gt; расширяется до константного выражения типа &lt;code&gt;float&lt;/code&gt; , которое оценивается как тихое значение не числа (QNaN). Если реализация не поддерживает QNaN, эта макропостоянная величина не определяется.</target>
        </trans-unit>
        <trans-unit id="511bc44ac64af1c05b670d54015e303e4e44b53b" translate="yes" xml:space="preserve">
          <source>The macro &lt;code&gt;NULL&lt;/code&gt; is an implementation-defined null pointer constant, which may be.</source>
          <target state="translated">Макрос &lt;code&gt;NULL&lt;/code&gt; - это константа нулевого указателя, определяемая реализацией, которая может быть.</target>
        </trans-unit>
        <trans-unit id="e7a478300d3bf8ff1fa598a5f4a3701de66a2d50" translate="yes" xml:space="preserve">
          <source>The macro &lt;code&gt;offsetof&lt;/code&gt; expands to an integral constant expression of type &lt;code&gt;&lt;a href=&quot;size_t&quot;&gt;std::size_t&lt;/a&gt;&lt;/code&gt;, the value of which is the offset, in bytes, from the beginning of an object of specified type to its specified member, including padding if any.</source>
          <target state="translated">Макрос &lt;code&gt;offsetof&lt;/code&gt; расширяется до целочисленного константного выражения типа &lt;code&gt;&lt;a href=&quot;size_t&quot;&gt;std::size_t&lt;/a&gt;&lt;/code&gt; , значением которого является смещение в байтах от начала объекта указанного типа до его указанного члена, включая заполнение, если оно есть.</target>
        </trans-unit>
        <trans-unit id="a5a472a05b4e53b9216f7fc0c3e059710e59c4a4" translate="yes" xml:space="preserve">
          <source>The macro constant &lt;code&gt;FE_ALL_EXCEPT&lt;/code&gt;, which expands to the bitwise OR of all other &lt;code&gt;FE_*&lt;/code&gt;, is always defined and is zero if floating-point exceptions are not supported by the implementation.</source>
          <target state="translated">Макро константа &lt;code&gt;FE_ALL_EXCEPT&lt;/code&gt; , который расширяется в побитовое ИЛИ всех других &lt;code&gt;FE_*&lt;/code&gt; , всегда определяется и равен нулю , если исключения с плавающей точкой не поддерживаются реализацией.</target>
        </trans-unit>
        <trans-unit id="44aac1c9879022e9fba891603df04ea9ca8e044a" translate="yes" xml:space="preserve">
          <source>The macro constant &lt;code&gt;FE_DFL_ENV&lt;/code&gt; expands to an expression of type &lt;code&gt;const std::fenv_t*&lt;/code&gt;, which points to a full copy of the default floating-point environment, that is, the environment as loaded at program startup.</source>
          <target state="translated">Макро константа &lt;code&gt;FE_DFL_ENV&lt;/code&gt; расширяется до выражения типа &lt;code&gt;const std::fenv_t*&lt;/code&gt; , которое указывает на полную копию среды по умолчанию с плавающей запятой, то есть среды, загружаемой при запуске программы.</target>
        </trans-unit>
        <trans-unit id="4e6484c8cfd3a1b8d998f588b04075f3f3fb6a9f" translate="yes" xml:space="preserve">
          <source>The macro constant &lt;code&gt;math_errhandling&lt;/code&gt; expands to an expression of type &lt;code&gt;int&lt;/code&gt; that is either equal to &lt;code&gt;MATH_ERRNO&lt;/code&gt;, or equal to &lt;code&gt;MATH_ERREXCEPT&lt;/code&gt;, or equal to their bitwise OR (&lt;code&gt;MATH_ERRNO | MATH_ERREXCEPT&lt;/code&gt;).</source>
          <target state="translated">Макрос постоянной &lt;code&gt;math_errhandling&lt;/code&gt; расширяется до выражения типа &lt;code&gt;int&lt;/code&gt; , который либо равен &lt;code&gt;MATH_ERRNO&lt;/code&gt; , или равно &lt;code&gt;MATH_ERREXCEPT&lt;/code&gt; или равна их побитового ИЛИ ( &lt;code&gt;MATH_ERRNO | MATH_ERREXCEPT&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="1d50b82bba3614372048e0562a743464334498a2" translate="yes" xml:space="preserve">
          <source>The manipulators that are invoked with arguments (e.g. &lt;code&gt;&lt;a href=&quot;cout&quot;&gt;std::cout&lt;/a&gt; &amp;lt;&amp;lt; &lt;a href=&quot;manip/setw&quot;&gt;std::setw&lt;/a&gt;(10);&lt;/code&gt;) are implemented as functions returning objects of unspecified type. These manipulators define their own &lt;code&gt;operator&amp;lt;&amp;lt;&lt;/code&gt; or &lt;code&gt;operator&amp;gt;&amp;gt;&lt;/code&gt; which perform the requested manipulation.</source>
          <target state="translated">Манипуляторы, которые вызываются с аргументами (например, &lt;code&gt;&lt;a href=&quot;cout&quot;&gt;std::cout&lt;/a&gt; &amp;lt;&amp;lt; &lt;a href=&quot;manip/setw&quot;&gt;std::setw&lt;/a&gt;(10);&lt;/code&gt; ), реализованы как функции, возвращающие объекты неопределенного типа. Эти манипуляторы определяют свой собственный &lt;code&gt;operator&amp;lt;&amp;lt;&lt;/code&gt; или &lt;code&gt;operator&amp;gt;&amp;gt;&lt;/code&gt; который выполняет запрошенную манипуляцию.</target>
        </trans-unit>
        <trans-unit id="016c7618765bc086feb76ffa7317750d2349efbd" translate="yes" xml:space="preserve">
          <source>The manipulators that are invoked without arguments (e.g. &lt;code&gt;&lt;a href=&quot;cout&quot;&gt;std::cout&lt;/a&gt; &amp;lt;&amp;lt; &lt;a href=&quot;manip/boolalpha&quot;&gt;std::boolalpha&lt;/a&gt;;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;cin&quot;&gt;std::cin&lt;/a&gt; &amp;gt;&amp;gt; &lt;a href=&quot;manip/hex&quot;&gt;std::hex&lt;/a&gt;;&lt;/code&gt;) are implemented as functions that take a reference to a stream as their only argument. The special overloads of &lt;a href=&quot;basic_ostream/operator_ltlt&quot;&gt;&lt;code&gt;basic_ostream::operator&amp;lt;&amp;lt;&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;basic_istream/operator_gtgt&quot;&gt;&lt;code&gt;basic_istream::operator&amp;gt;&amp;gt;&lt;/code&gt;&lt;/a&gt; accept pointers to these functions. These functions (or instantiations of function templates) are the only &lt;a href=&quot;http://en.cppreference.com/w/cpp/language/extending_std#Addressable_functions&quot;&gt;addressable functions&lt;/a&gt; in the standard library.(since C++20).</source>
          <target state="translated">Манипуляторы, которые вызываются без аргументов (например, &lt;code&gt;&lt;a href=&quot;cout&quot;&gt;std::cout&lt;/a&gt; &amp;lt;&amp;lt; &lt;a href=&quot;manip/boolalpha&quot;&gt;std::boolalpha&lt;/a&gt;;&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;cin&quot;&gt;std::cin&lt;/a&gt; &amp;gt;&amp;gt; &lt;a href=&quot;manip/hex&quot;&gt;std::hex&lt;/a&gt;;&lt;/code&gt; ), реализованы как функции, которые принимают ссылку на поток в качестве единственного аргумента. Специальные перегрузки &lt;a href=&quot;basic_ostream/operator_ltlt&quot;&gt; &lt;code&gt;basic_ostream::operator&amp;lt;&amp;lt;&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;basic_istream/operator_gtgt&quot;&gt; &lt;code&gt;basic_istream::operator&amp;gt;&amp;gt;&lt;/code&gt; &lt;/a&gt; принимают указатели на эти функции. Эти функции (или экземпляры шаблонов функций) являются единственными &lt;a href=&quot;http://en.cppreference.com/w/cpp/language/extending_std#Addressable_functions&quot;&gt;адресуемыми функциями&lt;/a&gt; в стандартной библиотеке (начиная с C ++ 20).</target>
        </trans-unit>
        <trans-unit id="0acdda7356c347f1e3a711be9e894cc6cb8fd66c" translate="yes" xml:space="preserve">
          <source>The manner in which &lt;code&gt;&lt;a href=&quot;vector&quot;&gt;std::vector&lt;/a&gt;&amp;lt;bool&amp;gt;&lt;/code&gt; is made space efficient (as well as whether it is optimized at all) is implementation defined. One potential optimization involves coalescing vector elements such that each element occupies a single bit instead of &lt;code&gt;sizeof(bool)&lt;/code&gt; bytes.</source>
          <target state="translated">Способ, которым &lt;code&gt;&lt;a href=&quot;vector&quot;&gt;std::vector&lt;/a&gt;&amp;lt;bool&amp;gt;&lt;/code&gt; делается пространственно-эффективным (а также оптимизируется ли он вообще), определяется реализацией. Одна потенциальная оптимизация включает в себя объединение векторных элементов, так что каждый элемент занимает один бит вместо байтов &lt;code&gt;sizeof(bool)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="08f5f3a85d25f2d17a7f4389b37fef34e9befb11" translate="yes" xml:space="preserve">
          <source>The manner in which the arguments given at the OS command line are converted into the multibyte character arrays referenced by &lt;code&gt;argv&lt;/code&gt; may involve implementation-defined processing:</source>
          <target state="translated">Способ, которым аргументы, заданные в командной строке ОС, преобразуются в многобайтовые массивы символов, на которые ссылается &lt;code&gt;argv&lt;/code&gt; , может включать в себя обработку, определяемую реализацией:</target>
        </trans-unit>
        <trans-unit id="58a4e89b5d75599c18d4cf2463da2bc790d5e376" translate="yes" xml:space="preserve">
          <source>The mapped value of &lt;code&gt;ch&lt;/code&gt; using the mapping identified by &lt;code&gt;desc&lt;/code&gt; in LC_CTYPE facet of the current C locale.</source>
          <target state="translated">Отображенное значение &lt;code&gt;ch&lt;/code&gt; , используя отображение, идентифицированное &lt;code&gt;desc&lt;/code&gt; в фасете LC_CTYPE текущей локали C.</target>
        </trans-unit>
        <trans-unit id="8da49c2641d38472ced25e1d078a923e49026a41" translate="yes" xml:space="preserve">
          <source>The materialization of a temporary object is generally delayed as long as possible in order to avoid creating unnecessary temporary object: see &lt;a href=&quot;copy_elision&quot;&gt;copy elision&lt;/a&gt;.</source>
          <target state="translated">Материализация временного объекта, как правило, задерживается как можно дольше, чтобы избежать создания ненужного временного объекта: см. &lt;a href=&quot;copy_elision&quot;&gt;Раздел &amp;laquo;Удаление копии&amp;raquo;&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="030e1db264f4cf63958d4ac7eff5a182391b9628" translate="yes" xml:space="preserve">
          <source>The mathematical definition of the principal value of arc sine is asin z = -</source>
          <target state="translated">Математическое определение главного значения синуса дуги-асин z=-</target>
        </trans-unit>
        <trans-unit id="97d3912b761a5766d76f8e019b7647d3c28a58a9" translate="yes" xml:space="preserve">
          <source>The mathematical definition of the principal value of the inverse hyperbolic cosine is acosh z = ln(z + &amp;radic;z+1&amp;radic;z-1)  For any z, acosh(z) =</source>
          <target state="translated">Математическое определение главного значения обратного гиперболического косинуса: acosh z = ln (z + &amp;radic;z + 1&amp;radic;z-1) Для любого z acosh (z) =</target>
        </trans-unit>
        <trans-unit id="2ee0c302057514ba3aa0f5c20f8146065a6d4cf3" translate="yes" xml:space="preserve">
          <source>The mathematical definition of the principal value of the inverse hyperbolic sine is asinh z = ln(z + &amp;radic;1+z2</source>
          <target state="translated">Математическое определение главного значения обратного гиперболического синуса: asinh z = ln (z + &amp;radic;1 + z2</target>
        </trans-unit>
        <trans-unit id="e0ab357d29d58615b6db4b151ccaf98654e0e8b9" translate="yes" xml:space="preserve">
          <source>The mathematical functions in the standard library components do not throw this exception (mathematical functions report range errors as specified in &lt;code&gt;&lt;a href=&quot;../../numeric/math/math_errhandling&quot;&gt;math_errhandling&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">Математические функции в компонентах стандартной библиотеки не выдают это исключение (математические функции сообщают об ошибках диапазона, как указано в &lt;code&gt;&lt;a href=&quot;../../numeric/math/math_errhandling&quot;&gt;math_errhandling&lt;/a&gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="58113db72a97ac5e55ee3d47627cc11fbb811664" translate="yes" xml:space="preserve">
          <source>The mathematical functions of the standard library components do not throw this exception (mathematical functions report overflow errors as specified in &lt;code&gt;&lt;a href=&quot;../../numeric/math/math_errhandling&quot;&gt;math_errhandling&lt;/a&gt;&lt;/code&gt;). Third-party libraries, however, use this. For example, &lt;a href=&quot;http://www.boost.org/doc/libs/1_55_0/libs/math/doc/html/math_toolkit/error_handling.html&quot;&gt;boost.math&lt;/a&gt; throws &lt;code&gt;std::overflow_error&lt;/code&gt; if &lt;code&gt;boost::math::policies::throw_on_error&lt;/code&gt; is enabled (the default setting).</source>
          <target state="translated">Математические функции компонентов стандартной библиотеки не выдают это исключение (математические функции сообщают об ошибках переполнения, как указано в &lt;code&gt;&lt;a href=&quot;../../numeric/math/math_errhandling&quot;&gt;math_errhandling&lt;/a&gt;&lt;/code&gt; ). Сторонние библиотеки, однако, используют это. Например, &lt;a href=&quot;http://www.boost.org/doc/libs/1_55_0/libs/math/doc/html/math_toolkit/error_handling.html&quot;&gt;boost.math&lt;/a&gt; выбрасывает &lt;code&gt;std::overflow_error&lt;/code&gt; если включен &lt;code&gt;boost::math::policies::throw_on_error&lt;/code&gt; (настройка по умолчанию).</target>
        </trans-unit>
        <trans-unit id="43eb628800204d96d7e81842c715db4a7e602e27" translate="yes" xml:space="preserve">
          <source>The mathematical functions of the standard library components do not throw this exception (mathematical functions report overflow errors as specified in &lt;code&gt;&lt;a href=&quot;../../numeric/math/math_errhandling&quot;&gt;math_errhandling&lt;/a&gt;&lt;/code&gt;). Third-party libraries, however, use this. For example, &lt;a href=&quot;https://www.boost.org/doc/libs/1_55_0/libs/math/doc/html/math_toolkit/error_handling.html&quot;&gt;boost.math&lt;/a&gt; throws &lt;code&gt;std::overflow_error&lt;/code&gt; if &lt;code&gt;boost::math::policies::throw_on_error&lt;/code&gt; is enabled (the default setting).</source>
          <target state="translated">Математические функции компонентов стандартной библиотеки не вызывают это исключение (математические функции сообщают об ошибках переполнения, как указано в &lt;code&gt;&lt;a href=&quot;../../numeric/math/math_errhandling&quot;&gt;math_errhandling&lt;/a&gt;&lt;/code&gt; ). Однако сторонние библиотеки используют это. Например, &lt;a href=&quot;https://www.boost.org/doc/libs/1_55_0/libs/math/doc/html/math_toolkit/error_handling.html&quot;&gt;boost.math&lt;/a&gt; выдает &lt;code&gt;std::overflow_error&lt;/code&gt; если включен &lt;code&gt;boost::math::policies::throw_on_error&lt;/code&gt; (настройка по умолчанию).</target>
        </trans-unit>
        <trans-unit id="b1ce23e380db1867330cee83f35a43a3c26b63df" translate="yes" xml:space="preserve">
          <source>The maximum allocation size for OuterAlloc.</source>
          <target state="translated">Максимальный размер распределения для OuterAlloc.</target>
        </trans-unit>
        <trans-unit id="e6a66616954e988ad69d8232b96f5ad75ebaeb3d" translate="yes" xml:space="preserve">
          <source>The maximum number of &lt;code&gt;ExternT&lt;/code&gt; characters that could be consumed if converted by &lt;code&gt;&lt;a href=&quot;in&quot;&gt;in()&lt;/a&gt;&lt;/code&gt; to produce one &lt;code&gt;InternT&lt;/code&gt; character.</source>
          <target state="translated">Максимальное количество символов &lt;code&gt;ExternT&lt;/code&gt; , которое можно использовать при преобразовании в &lt;code&gt;&lt;a href=&quot;in&quot;&gt;in()&lt;/a&gt;&lt;/code&gt; для получения одного &lt;code&gt;InternT&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c5d2605f57cf7a516878f1456bacc8bf68ff240d" translate="yes" xml:space="preserve">
          <source>The maximum number of blocks that will be allocated at once from the upstream &lt;code&gt;&lt;a href=&quot;memory_resource&quot;&gt;std::pmr::memory_resource&lt;/a&gt;&lt;/code&gt; to replenish the pool. If the value of &lt;code&gt;max_blocks_per_chunk&lt;/code&gt; is zero or is greater than an implementation-defined limit, that limit is used instead. The implementation may choose to use a smaller value than is specified in this field and may use different values for different pools.</source>
          <target state="translated">Максимальное количество блоков, которое будет выделено одновременно из восходящего потока &lt;code&gt;&lt;a href=&quot;memory_resource&quot;&gt;std::pmr::memory_resource&lt;/a&gt;&lt;/code&gt; для пополнения пула. Если значение &lt;code&gt;max_blocks_per_chunk&lt;/code&gt; равно нулю или превышает предел, определенный реализацией, вместо этого используется этот предел. Реализация может выбрать использование меньшего значения, чем указано в этом поле, и может использовать разные значения для разных пулов.</target>
        </trans-unit>
        <trans-unit id="ef98d6b10d2a64071a19841e541af22baf6b008a" translate="yes" xml:space="preserve">
          <source>The maximum number of levels of ownership is unspecified. A call to &lt;code&gt;try_lock&lt;/code&gt; will return &lt;code&gt;false&lt;/code&gt; if this number is exceeded.</source>
          <target state="translated">Максимальное количество уровней владения не указано. Вызов &lt;code&gt;try_lock&lt;/code&gt; вернет &lt;code&gt;false&lt;/code&gt; , если этот номер превышен.</target>
        </trans-unit>
        <trans-unit id="bf578a55e820eb222bfd9c3060644e38bddddff9" translate="yes" xml:space="preserve">
          <source>The maximum number of levels of ownership is unspecified. A call to &lt;code&gt;try_lock_for&lt;/code&gt; will return &lt;code&gt;false&lt;/code&gt; if this number is exceeded.</source>
          <target state="translated">Максимальное количество уровней владения не указано. Вызов &lt;code&gt;try_lock_for&lt;/code&gt; вернет &lt;code&gt;false&lt;/code&gt; , если это число превышено.</target>
        </trans-unit>
        <trans-unit id="7496f6de330e88cd441a674882cf192e5823a0c2" translate="yes" xml:space="preserve">
          <source>The maximum number of levels of ownership is unspecified. A call to &lt;code&gt;try_lock_until&lt;/code&gt; will return &lt;code&gt;false&lt;/code&gt; if this number is exceeded.</source>
          <target state="translated">Максимальное количество уровней владения не указано. Вызов &lt;code&gt;try_lock_until&lt;/code&gt; вернет &lt;code&gt;false&lt;/code&gt; , если это число будет превышено.</target>
        </trans-unit>
        <trans-unit id="516d0ea27a06242455894ddf3d9021aca322b598" translate="yes" xml:space="preserve">
          <source>The maximum number of levels of ownership is unspecified. An exception of type &lt;code&gt;&lt;a href=&quot;../../error/system_error&quot;&gt;std::system_error&lt;/a&gt;&lt;/code&gt; will be thrown if this number is exceeded.</source>
          <target state="translated">Максимальное количество уровней владения не указано. Исключение типа &lt;code&gt;&lt;a href=&quot;../../error/system_error&quot;&gt;std::system_error&lt;/a&gt;&lt;/code&gt; будет выдано , если это число превышено.</target>
        </trans-unit>
        <trans-unit id="3f7c181bde374eeb6452476ff6b3a7543371ba08" translate="yes" xml:space="preserve">
          <source>The maximum number of times that a &lt;code&gt;recursive_mutex&lt;/code&gt; may be locked is unspecified, but after that number is reached, calls to &lt;a href=&quot;recursive_mutex/lock&quot;&gt;&lt;code&gt;lock&lt;/code&gt;&lt;/a&gt; will throw &lt;code&gt;&lt;a href=&quot;../error/system_error&quot;&gt;std::system_error&lt;/a&gt;&lt;/code&gt; and calls to &lt;a href=&quot;mutex/try_lock&quot;&gt;&lt;code&gt;try_lock&lt;/code&gt;&lt;/a&gt; will return &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">Максимальное количество раз, которое &lt;code&gt;recursive_mutex&lt;/code&gt; может быть заблокировано, не указано, но после того, как это число будет достигнуто, вызовы &lt;a href=&quot;recursive_mutex/lock&quot;&gt; &lt;code&gt;lock&lt;/code&gt; &lt;/a&gt; будут генерировать &lt;code&gt;&lt;a href=&quot;../error/system_error&quot;&gt;std::system_error&lt;/a&gt;&lt;/code&gt; а вызовы &lt;a href=&quot;mutex/try_lock&quot;&gt; &lt;code&gt;try_lock&lt;/code&gt; &lt;/a&gt; будут возвращать &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a24b749dcce9aa560cb6a3f3aa6c86777a9e5381" translate="yes" xml:space="preserve">
          <source>The maximum of the elements.</source>
          <target state="translated">Максимум элементов.</target>
        </trans-unit>
        <trans-unit id="2d061d5c7925797cceba9d91fa06eb294531985d" translate="yes" xml:space="preserve">
          <source>The maximum potentially generated value.</source>
          <target state="translated">Максимальная потенциально генерируемая величина.</target>
        </trans-unit>
        <trans-unit id="69a097b71a9a8b372efe8c272aa3e609c3c54fe8" translate="yes" xml:space="preserve">
          <source>The maximum supported allocation size.</source>
          <target state="translated">Максимально поддерживаемый размер распределения.</target>
        </trans-unit>
        <trans-unit id="8c16c9cf3f818c29edfdff221593b78944e7d444" translate="yes" xml:space="preserve">
          <source>The maximum value potentially generated by the distribution.</source>
          <target state="translated">Максимальное значение,потенциально генерируемое распределением.</target>
        </trans-unit>
        <trans-unit id="f173db7218831b033970ba26eec47af5157e549e" translate="yes" xml:space="preserve">
          <source>The meaning and the type of the result of this function is implementation-defined. On a POSIX system, this may be a value of type &lt;code&gt;pthread_cond_t*&lt;/code&gt;. On a Windows system, this may be a &lt;code&gt;PCONDITION_VARIABLE&lt;/code&gt;.</source>
          <target state="translated">Значение и тип результата этой функции определяется реализацией. В системе POSIX это может быть значение типа &lt;code&gt;pthread_cond_t*&lt;/code&gt; . В системе Windows это может быть &lt;code&gt;PCONDITION_VARIABLE&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b8b50f9c9a68f338aee12b4deb4d472419d36c02" translate="yes" xml:space="preserve">
          <source>The meaning of the format specifiers are:</source>
          <target state="translated">Смысл спецификаторов формата:</target>
        </trans-unit>
        <trans-unit id="5c2b2f950c575d77dea5f7dca516f87942977025" translate="yes" xml:space="preserve">
          <source>The mechanism for selecting the build level is implementation-defined. Combining translation units that were translated at different build levels is conditionally-supported.</source>
          <target state="translated">Механизм выбора уровня сборки определяется реализацией.Условно поддерживается объединение единиц перевода,которые были переведены на разных уровнях сборки.</target>
        </trans-unit>
        <trans-unit id="69ef650d47f1d92c2572bf80d049412bb1aad754" translate="yes" xml:space="preserve">
          <source>The member &lt;code&gt;operator()&lt;/code&gt; effectively returns the same value as &lt;code&gt;&lt;a href=&quot;hash_code&quot;&gt;hash_code()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Оператор-член &lt;code&gt;operator()&lt;/code&gt; эффективно возвращает то же значение, что и &lt;code&gt;&lt;a href=&quot;hash_code&quot;&gt;hash_code()&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="68d7297c4dbfb9ca93d5a11a625ec7d05314ebfc" translate="yes" xml:space="preserve">
          <source>The member access operator expressions have the form.</source>
          <target state="translated">Выражения оператора доступа членов имеют форму.</target>
        </trans-unit>
        <trans-unit id="9ac4e03045a811db7fdf9a33fae47eaa532e51b8" translate="yes" xml:space="preserve">
          <source>The member access operator expressions through pointers to members have the form.</source>
          <target state="translated">Выражения оператора доступа члена через указатели на членов имеют форму.</target>
        </trans-unit>
        <trans-unit id="d1f68969edf8b53ae807e1ece64ebe13ea9b9298" translate="yes" xml:space="preserve">
          <source>The member access through pointer to member &lt;code&gt;operator-&amp;gt;*&lt;/code&gt;. There are no specific downsides to overloading this operator, but it is rarely used in practice. It was suggested that it could be part of &lt;a href=&quot;http://www.aristeia.com/Papers/DDJ_Oct_1999.pdf&quot;&gt;smart pointer interface&lt;/a&gt;, and in fact is used in that capacity by actors in &lt;a href=&quot;http://www.boost.org/doc/libs/release/libs/phoenix/doc/html/phoenix/modules/operator.html#phoenix.modules.operator.member_pointer_operator&quot;&gt;boost.phoenix&lt;/a&gt;. It is more common in EDSLs such as &lt;a href=&quot;https://github.com/schlangster/cpp.react/blob/master/include/react/Signal.h#L557&quot;&gt;cpp.react&lt;/a&gt;.</source>
          <target state="translated">Доступ к члену через указатель на член &lt;code&gt;operator-&amp;gt;*&lt;/code&gt; . Нет особых недостатков в перегрузке этого оператора, но он редко используется на практике. Было высказано предположение, что он может быть частью &lt;a href=&quot;http://www.aristeia.com/Papers/DDJ_Oct_1999.pdf&quot;&gt;интерфейса интеллектуального указателя&lt;/a&gt; и фактически используется в этом качестве актерами в &lt;a href=&quot;http://www.boost.org/doc/libs/release/libs/phoenix/doc/html/phoenix/modules/operator.html#phoenix.modules.operator.member_pointer_operator&quot;&gt;boost.phoenix&lt;/a&gt; . Это чаще встречается в EDSL, таких как &lt;a href=&quot;https://github.com/schlangster/cpp.react/blob/master/include/react/Signal.h#L557&quot;&gt;cpp.react&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="89feaad6ef39273143072a5bab0c6502c099dc36" translate="yes" xml:space="preserve">
          <source>The member access through pointer to member &lt;code&gt;operator-&amp;gt;*&lt;/code&gt;. There are no specific downsides to overloading this operator, but it is rarely used in practice. It was suggested that it could be part of &lt;a href=&quot;http://www.aristeia.com/Papers/DDJ_Oct_1999.pdf&quot;&gt;smart pointer interface&lt;/a&gt;, and in fact is used in that capacity by actors in &lt;a href=&quot;https://www.boost.org/doc/libs/release/libs/phoenix/doc/html/phoenix/modules/operator.html#phoenix.modules.operator.member_pointer_operator&quot;&gt;boost.phoenix&lt;/a&gt;. It is more common in EDSLs such as &lt;a href=&quot;https://github.com/schlangster/cpp.react/blob/master/include/react/Signal.h#L557&quot;&gt;cpp.react&lt;/a&gt;.</source>
          <target state="translated">Доступ к члену через указатель на &lt;code&gt;operator-&amp;gt;*&lt;/code&gt; член -&amp;gt; * . У перегрузки этого оператора нет особых недостатков, но на практике он используется редко. Было высказано предположение, что он может быть частью &lt;a href=&quot;http://www.aristeia.com/Papers/DDJ_Oct_1999.pdf&quot;&gt;интерфейса интеллектуального указателя&lt;/a&gt; и фактически используется в этом качестве участниками в &lt;a href=&quot;https://www.boost.org/doc/libs/release/libs/phoenix/doc/html/phoenix/modules/operator.html#phoenix.modules.operator.member_pointer_operator&quot;&gt;boost.phoenix&lt;/a&gt; . Это чаще встречается в EDSL, таких как &lt;a href=&quot;https://github.com/schlangster/cpp.react/blob/master/include/react/Signal.h#L557&quot;&gt;cpp.react&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="239a9f71d3cf420873e0877dbfed19f440ad8974" translate="yes" xml:space="preserve">
          <source>The member character sequence in a buffer open for writing can be over-allocated for efficiency purposes. In that case, only the</source>
          <target state="translated">Последовательность символов в буфере,открытом для записи,может быть перераспределена в целях эффективности.В этом случае только</target>
        </trans-unit>
        <trans-unit id="05e762769a30065e204bb28bf51cb0273777e561" translate="yes" xml:space="preserve">
          <source>The member constants in &lt;code&gt;basic_regex&lt;/code&gt; are duplicates of the &lt;a href=&quot;syntax_option_type&quot;&gt;syntax_option_type&lt;/a&gt; constants defined in the namespace &lt;code&gt;std::regex_constants&lt;/code&gt;.</source>
          <target state="translated">Константы-члены в &lt;code&gt;basic_regex&lt;/code&gt; являются дубликатами констант &lt;a href=&quot;syntax_option_type&quot;&gt;syntax_option_type,&lt;/a&gt; определенных в пространстве имен &lt;code&gt;std::regex_constants&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="15df05692a271ee845f25f3cb5b040794f20a534" translate="yes" xml:space="preserve">
          <source>The member function &lt;code&gt;&lt;a href=&quot;optional/reset&quot;&gt;reset()&lt;/a&gt;&lt;/code&gt; is called.</source>
          <target state="translated">Функция-член &lt;code&gt;&lt;a href=&quot;optional/reset&quot;&gt;reset()&lt;/a&gt;&lt;/code&gt; вызывается.</target>
        </trans-unit>
        <trans-unit id="efb92cc5bc9ac09558948d91fa6f04f3671a172b" translate="yes" xml:space="preserve">
          <source>The member function called by the Searcher overload of &lt;code&gt;&lt;a href=&quot;../../algorithm/search&quot;&gt;std::search&lt;/a&gt;&lt;/code&gt; to perform a search with this searcher.</source>
          <target state="translated">Функция-член, вызываемая перегрузкой Searcher в &lt;code&gt;&lt;a href=&quot;../../algorithm/search&quot;&gt;std::search&lt;/a&gt;&lt;/code&gt; для выполнения поиска с помощью этого поисковика.</target>
        </trans-unit>
        <trans-unit id="02d35ef45a2be736ac5d48567bf5243bd00060f5" translate="yes" xml:space="preserve">
          <source>The member function called by the Searcher overload of &lt;code&gt;&lt;a href=&quot;../../algorithm/search&quot;&gt;std::search&lt;/a&gt;&lt;/code&gt; to perform a search with this searcher. &lt;code&gt;RandomIt2&lt;/code&gt; must meet the requirements of &lt;a href=&quot;../../named_req/randomaccessiterator&quot;&gt;LegacyRandomAccessIterator&lt;/a&gt;.</source>
          <target state="translated">Функция-член, вызываемая перегрузкой Searcher в &lt;code&gt;&lt;a href=&quot;../../algorithm/search&quot;&gt;std::search&lt;/a&gt;&lt;/code&gt; для выполнения поиска с помощью этого поисковика. &lt;code&gt;RandomIt2&lt;/code&gt; должен соответствовать требованиям &lt;a href=&quot;../../named_req/randomaccessiterator&quot;&gt;LegacyRandomAccessIterator&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0d5b7b86f4cef7432fea2b9bc1aebd9323994e41" translate="yes" xml:space="preserve">
          <source>The member functions introduced by a using-declaration into a derived class are considered to be members of the derived class for the purpose of defining the type of the</source>
          <target state="translated">Функции-члены,вводимые в производном классе путем использования-декларации,считаются членами производного класса для целей определения типа</target>
        </trans-unit>
        <trans-unit id="764b4e1ee289e17bad4f60ec0a9d42691689afe9" translate="yes" xml:space="preserve">
          <source>The member functions of &lt;code&gt;&lt;a href=&quot;../initializer_list&quot;&gt;std::initializer_list&lt;/a&gt;&lt;/code&gt; and the &lt;code&gt;std::initializer_list&lt;/code&gt; overloads of &lt;code&gt;&lt;a href=&quot;../../iterator/begin&quot;&gt;std::begin&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../../iterator/end&quot;&gt;std::end&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">Функции-члены &lt;code&gt;&lt;a href=&quot;../initializer_list&quot;&gt;std::initializer_list&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;std::initializer_list&lt;/code&gt; перегружают &lt;code&gt;&lt;a href=&quot;../../iterator/begin&quot;&gt;std::begin&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;../../iterator/end&quot;&gt;std::end&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="bc2f6b335fdc83b3a9f3feda6af5eaac09524b21" translate="yes" xml:space="preserve">
          <source>The member functions of this specialization are not guaranteed to be noexcept because the hash of the underlying type might throw.</source>
          <target state="translated">Членские функции этой специализации не гарантируются,за исключением того,что может быть брошен хэш основного типа.</target>
        </trans-unit>
        <trans-unit id="ef67f3b96aad3f43ceefc11f4c679e1c0ac92843" translate="yes" xml:space="preserve">
          <source>The member functions of this specialization are not guaranteed to be noexcept because the pointer may be a fancy pointer and its hash might throw.</source>
          <target state="translated">Членские функции этой специализации не гарантируются,за исключением того,что указатель может быть причудливым,а его хэш может бросать.</target>
        </trans-unit>
        <trans-unit id="833dfb1c2bf2f506172d76aae796695e09f833e7" translate="yes" xml:space="preserve">
          <source>The member functions of this specialization are not guaranteed to be noexcept.</source>
          <target state="translated">Членские функции этой специализации не гарантируются.</target>
        </trans-unit>
        <trans-unit id="5e5711660055f235ace0e4ed3873cb22e451c3b1" translate="yes" xml:space="preserve">
          <source>The member functions return defined default values unless the &lt;code&gt;matched&lt;/code&gt; member is &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">Функции-члены возвращают определенные значения по умолчанию, если только &lt;code&gt;matched&lt;/code&gt; элемент не равен &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b48a3030fca44418386968b5abfc5df76aac60a3" translate="yes" xml:space="preserve">
          <source>The member interpretation is used if the range type has a member named &lt;code&gt;begin&lt;/code&gt; and a member named &lt;code&gt;end&lt;/code&gt;. This is done regardless of whether the member is a type, data member, function, or enumerator, and regardless of its accessibility. Thus a class like &lt;code&gt;class meow { enum { begin = 1, end = 2}; /* rest of class */ };&lt;/code&gt; cannot be used with the range-based for loop even if the namespace-scope begin/end functions are present.</source>
          <target state="translated">Интерпретация элемента используется, если тип диапазона имеет элемент с именем &lt;code&gt;begin&lt;/code&gt; и элемент с именем &lt;code&gt;end&lt;/code&gt; . Это делается независимо от того, является ли член типом, элементом данных, функцией или перечислителем и независимо от его доступности. Таким образом, класс, подобный &lt;code&gt;class meow { enum { begin = 1, end = 2}; /* rest of class */ };&lt;/code&gt; не может использоваться с циклом for на основе диапазона, даже если присутствуют функции начала / конца области имен.</target>
        </trans-unit>
        <trans-unit id="d02cf71c651a6bbe450e9796516bdcd13d4f27a6" translate="yes" xml:space="preserve">
          <source>The member names of the</source>
          <target state="translated">Имена членов</target>
        </trans-unit>
        <trans-unit id="b6068893a255d37e81d9aa5432b3ceed4971bdcc" translate="yes" xml:space="preserve">
          <source>The member names of the base class, other than &lt;code&gt;conjunction&lt;/code&gt; and &lt;code&gt;operator=&lt;/code&gt;, are not hidden and are unambiguously available in &lt;code&gt;conjunction&lt;/code&gt;.</source>
          <target state="translated">Имена членов базового класса, отличные от &lt;code&gt;conjunction&lt;/code&gt; и &lt;code&gt;operator=&lt;/code&gt; , не являются скрытыми и однозначно доступны в &lt;code&gt;conjunction&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ab1bc84edd2dcc31d9c428be3ac37ab55ba141eb" translate="yes" xml:space="preserve">
          <source>The member names of the base class, other than &lt;code&gt;disjunction&lt;/code&gt; and &lt;code&gt;operator=&lt;/code&gt;, are not hidden and are unambiguously available in &lt;code&gt;disjunction&lt;/code&gt;.</source>
          <target state="translated">Имена членов базового класса, кроме &lt;code&gt;disjunction&lt;/code&gt; и &lt;code&gt;operator=&lt;/code&gt; , не являются скрытыми и однозначно доступны в &lt;code&gt;disjunction&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="88413da3549b10a5d3c5e5a05a9f77dbd30567cc" translate="yes" xml:space="preserve">
          <source>The member operator() is noexcept if the &lt;code&gt;&lt;a href=&quot;invoke&quot;&gt;std::invoke&lt;/a&gt;&lt;/code&gt; expression it calls is noexcept (in other words, it preserves the exception specification of the underlying call operator).</source>
          <target state="translated">Оператор-член () не является исключением, если &lt;code&gt;&lt;a href=&quot;invoke&quot;&gt;std::invoke&lt;/a&gt;&lt;/code&gt; выражение std :: invoke не является исключением (другими словами, он сохраняет спецификацию исключений основного оператора вызова).</target>
        </trans-unit>
        <trans-unit id="99180f77f5a8ca80c11eb2a7965cbabfd4d9c9cc" translate="yes" xml:space="preserve">
          <source>The member specification, or the</source>
          <target state="translated">Спецификация члена,или</target>
        </trans-unit>
        <trans-unit id="6247f710bbdb924881ced1b35c970d774f909927" translate="yes" xml:space="preserve">
          <source>The member template class &lt;code&gt;rebind&lt;/code&gt; provides a way to obtain an allocator for a different type. For example,</source>
          <target state="translated">&lt;code&gt;rebind&lt;/code&gt; класса шаблона члена предоставляет способ получить распределитель для другого типа. Например,</target>
        </trans-unit>
        <trans-unit id="03f1ae3b478686fb238fb267920a6735d4e1a474" translate="yes" xml:space="preserve">
          <source>The member type &lt;code&gt;X::pointer&lt;/code&gt; of &lt;code&gt;&lt;a href=&quot;../memory/unique_ptr&quot;&gt;std::unique_ptr&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">Тип члена &lt;code&gt;X::pointer&lt;/code&gt; на &lt;code&gt;&lt;a href=&quot;../memory/unique_ptr&quot;&gt;std::unique_ptr&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f2a0ec56c51738314ed8d919d00be55a70b110d4" translate="yes" xml:space="preserve">
          <source>The member type &lt;code&gt;is_transparent&lt;/code&gt; indicates to the caller that this function object is a</source>
          <target state="translated">Тип члена &lt;code&gt;is_transparent&lt;/code&gt; указывает вызывающей стороне, что этот функциональный объект является</target>
        </trans-unit>
        <trans-unit id="97d1ac879c7a04ed1084ddb26ee5600ac333f1dc" translate="yes" xml:space="preserve">
          <source>The member types &lt;code&gt;X::iterator&lt;/code&gt; and &lt;code&gt;X::const_iterator&lt;/code&gt; are &lt;a href=&quot;contiguousiterator&quot;&gt;LegacyContiguousIterators&lt;/a&gt;</source>
          <target state="translated">Типы элементов &lt;code&gt;X::iterator&lt;/code&gt; и &lt;code&gt;X::const_iterator&lt;/code&gt; являются &lt;a href=&quot;contiguousiterator&quot;&gt;LegacyContiguousIterators&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="189eb458b5906253d856798d17eff7858e326e0c" translate="yes" xml:space="preserve">
          <source>The member types &lt;code&gt;X::pointer&lt;/code&gt;, &lt;code&gt;X::const_pointer&lt;/code&gt;, &lt;code&gt;X::void_pointer&lt;/code&gt; and &lt;code&gt;X::const_void_pointer&lt;/code&gt; of every &lt;a href=&quot;allocator&quot;&gt;Allocator&lt;/a&gt; type &lt;code&gt;X&lt;/code&gt;</source>
          <target state="translated">Типы членов &lt;code&gt;X::pointer&lt;/code&gt; , &lt;code&gt;X::const_pointer&lt;/code&gt; , &lt;code&gt;X::void_pointer&lt;/code&gt; и &lt;code&gt;X::const_void_pointer&lt;/code&gt; каждого &lt;a href=&quot;allocator&quot;&gt;Allocator&lt;/a&gt; типа &lt;code&gt;X&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="743df5645d4509941f7715864c429844824ed55b" translate="yes" xml:space="preserve">
          <source>The member types &lt;code&gt;iterator&lt;/code&gt; and &lt;code&gt;const_iterator&lt;/code&gt; may be aliases to the same type. Since &lt;code&gt;iterator&lt;/code&gt; is convertible to &lt;code&gt;const_iterator&lt;/code&gt;, &lt;code&gt;const_iterator&lt;/code&gt; should be used in function parameter lists to avoid violations of the One Definition Rule.</source>
          <target state="translated">&lt;code&gt;iterator&lt;/code&gt; типов элементов и &lt;code&gt;const_iterator&lt;/code&gt; могут быть псевдонимами одного типа. Поскольку &lt;code&gt;iterator&lt;/code&gt; может быть преобразован в &lt;code&gt;const_iterator&lt;/code&gt; , &lt;code&gt;const_iterator&lt;/code&gt; следует использовать в списках параметров функции, чтобы избежать нарушений правила единого определения.</target>
        </trans-unit>
        <trans-unit id="4efe6ec44ec82b96dea5c4b0710d2c28b043d1ac" translate="yes" xml:space="preserve">
          <source>The members have the following meaning:</source>
          <target state="translated">Члены имеют следующее значение:</target>
        </trans-unit>
        <trans-unit id="e6dadd198818909e166ec932a678a2a940461078" translate="yes" xml:space="preserve">
          <source>The memory available to a C++ program is one or more contiguous sequences of</source>
          <target state="translated">Память,доступная для программы на С++,представляет собой одну или несколько последовательностей из</target>
        </trans-unit>
        <trans-unit id="037dde83ce079503b4e08f9c73501e2afb83137e" translate="yes" xml:space="preserve">
          <source>The memory models for the read-modify-write and load operations are &lt;code&gt;succ&lt;/code&gt; and &lt;code&gt;fail&lt;/code&gt; respectively. The (1-2) versions use &lt;code&gt;&lt;a href=&quot;memory_order&quot;&gt;std::memory_order_seq_cst&lt;/a&gt;&lt;/code&gt; by default.</source>
          <target state="translated">Модели памяти для операций чтения-изменения-записи и загрузки соответственно &lt;code&gt;succ&lt;/code&gt; и &lt;code&gt;fail&lt;/code&gt; . (1-2) версии по умолчанию используют &lt;code&gt;&lt;a href=&quot;memory_order&quot;&gt;std::memory_order_seq_cst&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5a1f66f39bcd63450604a4fcb472208a00fc0663" translate="yes" xml:space="preserve">
          <source>The memory models for the read-modify-write and load operations are &lt;code&gt;success&lt;/code&gt; and &lt;code&gt;failure&lt;/code&gt; respectively. In the (2) and (4) versions &lt;code&gt;order&lt;/code&gt; is used for both read-modify-write and load operations, except that &lt;code&gt;&lt;a href=&quot;../memory_order&quot;&gt;std::memory_order_acquire&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../memory_order&quot;&gt;std::memory_order_relaxed&lt;/a&gt;&lt;/code&gt; are used for the load operation if &lt;code&gt;order == &lt;a href=&quot;../memory_order&quot;&gt;std::memory_order_acq_rel&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;order == &lt;a href=&quot;../memory_order&quot;&gt;std::memory_order_release&lt;/a&gt;&lt;/code&gt; respectively.</source>
          <target state="translated">Модели памяти для операций чтения-изменения-записи и загрузки являются соответственно &lt;code&gt;success&lt;/code&gt; и &lt;code&gt;failure&lt;/code&gt; . В версиях (2) и (4) &lt;code&gt;order&lt;/code&gt; используется как для операций чтения, изменения, записи, так и для операций загрузки, за исключением того, что &lt;code&gt;&lt;a href=&quot;../memory_order&quot;&gt;std::memory_order_acquire&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;../memory_order&quot;&gt;std::memory_order_relaxed&lt;/a&gt;&lt;/code&gt; используются для операции загрузки, если &lt;code&gt;order == &lt;a href=&quot;../memory_order&quot;&gt;std::memory_order_acq_rel&lt;/a&gt;&lt;/code&gt; , или &lt;code&gt;order == &lt;a href=&quot;../memory_order&quot;&gt;std::memory_order_release&lt;/a&gt;&lt;/code&gt; соответственно.</target>
        </trans-unit>
        <trans-unit id="1aed46d8db03878f84ce9975ff764e9083e6702c" translate="yes" xml:space="preserve">
          <source>The memory resource pointer used by this polymorphic allocator.</source>
          <target state="translated">Указатель ресурса памяти,используемый этим полиморфным аллокатором.</target>
        </trans-unit>
        <trans-unit id="6f83b6ed70462af18ce1b14250e467f4f95844bf" translate="yes" xml:space="preserve">
          <source>The memory-writing conversion specifier &lt;code&gt;%n&lt;/code&gt; is a common target of security exploits where format strings depend on user input and is not supported by the bounds-checked &lt;code&gt;printf_s&lt;/code&gt; family of functions.</source>
          <target state="translated">Спецификатор преобразования записи в память &lt;code&gt;%n&lt;/code&gt; является распространенной целью эксплойтов безопасности, где строки формата зависят от ввода пользователя и не поддерживаются семейством функций &lt;code&gt;printf_s&lt;/code&gt; с проверкой границ .</target>
        </trans-unit>
        <trans-unit id="f9bdd1c45276cceff72dd22eaf8b65416fc4d7fe" translate="yes" xml:space="preserve">
          <source>The message from the catalog or a copy of &lt;code&gt;dfault&lt;/code&gt; if none was found.</source>
          <target state="translated">Сообщение из каталога или копия &lt;code&gt;dfault&lt;/code&gt; , если ничего не найдено.</target>
        </trans-unit>
        <trans-unit id="9d90f0cf5503392d1c2a08fa622e0683a067c582" translate="yes" xml:space="preserve">
          <source>The minimum of the elements.</source>
          <target state="translated">Минимум элементов.</target>
        </trans-unit>
        <trans-unit id="c57eecd663caaf3065c20e7f0d66aee57b9dc3f2" translate="yes" xml:space="preserve">
          <source>The minimum potentially generated value.</source>
          <target state="translated">Минимальное потенциально создаваемое значение.</target>
        </trans-unit>
        <trans-unit id="537c9aead08e9763da9b55897fd3bfcdaaa4e86a" translate="yes" xml:space="preserve">
          <source>The minimum value potentially generated by the distribution.</source>
          <target state="translated">Минимальное значение,потенциально генерируемое распределением.</target>
        </trans-unit>
        <trans-unit id="b3bcade615775889eac9bb5e7a58de484f254bd4" translate="yes" xml:space="preserve">
          <source>The modified command &lt;code&gt;%EC&lt;/code&gt; writes the locale's alternative representation of the century.</source>
          <target state="translated">Модифицированная команда &lt;code&gt;%EC&lt;/code&gt; записывает альтернативное представление столетия для локали.</target>
        </trans-unit>
        <trans-unit id="75f0dc4bd53f64c06e6fa0ff392db719eabb0f3d" translate="yes" xml:space="preserve">
          <source>The modified command &lt;code&gt;%EX&lt;/code&gt; interprets the locale's alternate time representation.</source>
          <target state="translated">Измененная команда &lt;code&gt;%EX&lt;/code&gt; интерпретирует альтернативное представление времени для локали.</target>
        </trans-unit>
        <trans-unit id="8bec27fca38ee75b95e3d0eaf504b8384963b028" translate="yes" xml:space="preserve">
          <source>The modified command &lt;code&gt;%EX&lt;/code&gt; writes the locale's alternate time representation.</source>
          <target state="translated">Модифицированная команда &lt;code&gt;%EX&lt;/code&gt; записывает альтернативное представление времени для локали.</target>
        </trans-unit>
        <trans-unit id="ee3cd7f7d1a25a1212fb29ddd03a9ef8472c165d" translate="yes" xml:space="preserve">
          <source>The modified command &lt;code&gt;%EY&lt;/code&gt; interprets the locale's alternative representation.</source>
          <target state="translated">Измененная команда &lt;code&gt;%EY&lt;/code&gt; интерпретирует альтернативное представление локали.</target>
        </trans-unit>
        <trans-unit id="1c68da4605fcc44c21d173eb10055c069c70b906" translate="yes" xml:space="preserve">
          <source>The modified command &lt;code&gt;%Ec&lt;/code&gt; interprets the locale's alternative date and time representation.</source>
          <target state="translated">Измененная команда &lt;code&gt;%Ec&lt;/code&gt; интерпретирует альтернативное представление даты и времени для локали.</target>
        </trans-unit>
        <trans-unit id="a9a1950a1c24f9659bd1e5f981ceb85d050b8767" translate="yes" xml:space="preserve">
          <source>The modified command &lt;code&gt;%Ec&lt;/code&gt; writes the locale's alternative date and time representation.</source>
          <target state="translated">Модифицированная команда &lt;code&gt;%Ec&lt;/code&gt; записывает альтернативное представление даты и времени для локали.</target>
        </trans-unit>
        <trans-unit id="e5775f2037b71dc38628c3500d791bc260bbebcb" translate="yes" xml:space="preserve">
          <source>The modified command &lt;code&gt;%Ex&lt;/code&gt; interprets the locale's alternate date representation.</source>
          <target state="translated">Измененная команда &lt;code&gt;%Ex&lt;/code&gt; интерпретирует альтернативное представление даты в локали.</target>
        </trans-unit>
        <trans-unit id="bb64ab15333504747771454a51c8294973e64441" translate="yes" xml:space="preserve">
          <source>The modified command &lt;code&gt;%Ex&lt;/code&gt; produces the locale's alternate date representation.</source>
          <target state="translated">Модифицированная команда &lt;code&gt;%Ex&lt;/code&gt; создает альтернативное представление даты для локали.</target>
        </trans-unit>
        <trans-unit id="14f6995f41f4a2d2134344889d2b79f5bfd0bf66" translate="yes" xml:space="preserve">
          <source>The modified command &lt;code&gt;%OH&lt;/code&gt; interprets the locale's alternative representation.</source>
          <target state="translated">Измененная команда &lt;code&gt;%OH&lt;/code&gt; интерпретирует альтернативное представление локали.</target>
        </trans-unit>
        <trans-unit id="da00c4361910133feb2655f2790d2c1bb35c3217" translate="yes" xml:space="preserve">
          <source>The modified command &lt;code&gt;%OH&lt;/code&gt; writes the locale's alternative representation.</source>
          <target state="translated">Модифицированная команда &lt;code&gt;%OH&lt;/code&gt; записывает альтернативное представление локали.</target>
        </trans-unit>
        <trans-unit id="02e1996d6f854882e96f32146e024df272f3e789" translate="yes" xml:space="preserve">
          <source>The modified command &lt;code&gt;%OI&lt;/code&gt; writes the locale's alternative representation.</source>
          <target state="translated">Модифицированная команда &lt;code&gt;%OI&lt;/code&gt; записывает альтернативное представление локали.</target>
        </trans-unit>
        <trans-unit id="283ff3b42755095dc2a58cb25631e8f808fd7dc4" translate="yes" xml:space="preserve">
          <source>The modified command &lt;code&gt;%OM&lt;/code&gt; interprets the locale's alternative representation.</source>
          <target state="translated">Измененная команда &lt;code&gt;%OM&lt;/code&gt; интерпретирует альтернативное представление локали.</target>
        </trans-unit>
        <trans-unit id="2256cc6eb2ce9c6dcb14d9932189e3173fe6fb7b" translate="yes" xml:space="preserve">
          <source>The modified command &lt;code&gt;%OM&lt;/code&gt; writes the locale's alternative representation.</source>
          <target state="translated">Модифицированная команда &lt;code&gt;%OM&lt;/code&gt; записывает альтернативное представление локали.</target>
        </trans-unit>
        <trans-unit id="e18d9132406fc6f5671d9b0f4de1913dbd9ea54c" translate="yes" xml:space="preserve">
          <source>The modified command &lt;code&gt;%OS&lt;/code&gt; interprets the locale's alternative representation.</source>
          <target state="translated">Измененная команда &lt;code&gt;%OS&lt;/code&gt; интерпретирует альтернативное представление локали.</target>
        </trans-unit>
        <trans-unit id="735aa83ce9d55484119953184990a8a3c5ef2bf3" translate="yes" xml:space="preserve">
          <source>The modified command &lt;code&gt;%OS&lt;/code&gt; writes the locale's alternative representation.</source>
          <target state="translated">Модифицированная команда &lt;code&gt;%OS&lt;/code&gt; записывает альтернативное представление локали.</target>
        </trans-unit>
        <trans-unit id="8dc1c917e7b33d49bec0f32a6ee8ce91fe3898be" translate="yes" xml:space="preserve">
          <source>The modified command &lt;code&gt;%OU&lt;/code&gt; writes the locale's alternative representation.</source>
          <target state="translated">Модифицированная команда &lt;code&gt;%OU&lt;/code&gt; записывает альтернативное представление локали.</target>
        </trans-unit>
        <trans-unit id="fed0585fe25d67debd6eae7991bab2b8338b1306" translate="yes" xml:space="preserve">
          <source>The modified command &lt;code&gt;%OV&lt;/code&gt; writes the locale's alternative representation.</source>
          <target state="translated">Измененная команда &lt;code&gt;%OV&lt;/code&gt; записывает альтернативное представление локали.</target>
        </trans-unit>
        <trans-unit id="39e0e2ebc4225fd4de3a9212027bfa57ba77c5c1" translate="yes" xml:space="preserve">
          <source>The modified command &lt;code&gt;%OW&lt;/code&gt; writes the locale's alternative representation.</source>
          <target state="translated">Измененная команда &lt;code&gt;%OW&lt;/code&gt; записывает альтернативное представление локали.</target>
        </trans-unit>
        <trans-unit id="b8c0342bc98a8d9ac901f7fa48dc3728088a24cf" translate="yes" xml:space="preserve">
          <source>The modified command &lt;code&gt;%Od&lt;/code&gt; writes the locale's alternative representation.</source>
          <target state="translated">Модифицированная команда &lt;code&gt;%Od&lt;/code&gt; записывает альтернативное представление локали.</target>
        </trans-unit>
        <trans-unit id="23a1adfc45649b52f8d2f79649429566f6756cd0" translate="yes" xml:space="preserve">
          <source>The modified command &lt;code&gt;%Oe&lt;/code&gt; writes the locale's alternative representation.</source>
          <target state="translated">Модифицированная команда &lt;code&gt;%Oe&lt;/code&gt; записывает альтернативное представление локали.</target>
        </trans-unit>
        <trans-unit id="3f211113e01d87804b53bf0839dc4545235c21b5" translate="yes" xml:space="preserve">
          <source>The modified command &lt;code&gt;%Om&lt;/code&gt; interprets the locale's alternative representation.</source>
          <target state="translated">Измененная команда &lt;code&gt;%Om&lt;/code&gt; интерпретирует альтернативное представление локали.</target>
        </trans-unit>
        <trans-unit id="6bfc0f055c1fd26cc9dfcc3dd3e7269715d8fbdd" translate="yes" xml:space="preserve">
          <source>The modified command &lt;code&gt;%Om&lt;/code&gt; writes the locale's alternative representation.</source>
          <target state="translated">Модифицированная команда &lt;code&gt;%Om&lt;/code&gt; записывает альтернативное представление локали.</target>
        </trans-unit>
        <trans-unit id="4738bf4fa0770676817bc173268ec85ebdefcba5" translate="yes" xml:space="preserve">
          <source>The modified command &lt;code&gt;%Ou&lt;/code&gt; interprets the locale's alternative representation.</source>
          <target state="translated">Измененная команда &lt;code&gt;%Ou&lt;/code&gt; интерпретирует альтернативное представление локали.</target>
        </trans-unit>
        <trans-unit id="28885626f1f9a4c0bc54a2f829547cf0075f8fc0" translate="yes" xml:space="preserve">
          <source>The modified command &lt;code&gt;%Ou&lt;/code&gt; writes the locale's alternative representation.</source>
          <target state="translated">Модифицированная команда &lt;code&gt;%Ou&lt;/code&gt; записывает альтернативное представление локали.</target>
        </trans-unit>
        <trans-unit id="46f001b91727d0cd13635e13519f0c94ccb1c799" translate="yes" xml:space="preserve">
          <source>The modified command &lt;code&gt;%Ow&lt;/code&gt; interprets the locale's alternative representation.</source>
          <target state="translated">Измененная команда &lt;code&gt;%Ow&lt;/code&gt; интерпретирует альтернативное представление локали.</target>
        </trans-unit>
        <trans-unit id="116f6b00825f4347d9b3ad162c904523d7a741ec" translate="yes" xml:space="preserve">
          <source>The modified command &lt;code&gt;%Ow&lt;/code&gt; writes the locale's alternative representation.</source>
          <target state="translated">Модифицированная команда &lt;code&gt;%Ow&lt;/code&gt; записывает альтернативное представление локали.</target>
        </trans-unit>
        <trans-unit id="eeffbf82acb0112a4308b4adc0a39d3f2e8cd8e8" translate="yes" xml:space="preserve">
          <source>The modified commands &lt;code&gt;%EC&lt;/code&gt; and &lt;code&gt;%OC&lt;/code&gt; interpret the locale's alternative representation of the century.</source>
          <target state="translated">Модифицированные команды &lt;code&gt;%EC&lt;/code&gt; и &lt;code&gt;%OC&lt;/code&gt; интерпретируют альтернативное представление локали века.</target>
        </trans-unit>
        <trans-unit id="1f8b1cf22bf3b662efdfa9705f03b9deebed9290" translate="yes" xml:space="preserve">
          <source>The modified commands &lt;code&gt;%Ed&lt;/code&gt; and &lt;code&gt;%Ee&lt;/code&gt; interpret the locale's alternative representation.</source>
          <target state="translated">Измененные команды &lt;code&gt;%Ed&lt;/code&gt; и &lt;code&gt;%Ee&lt;/code&gt; интерпретируют альтернативное представление локали.</target>
        </trans-unit>
        <trans-unit id="3d9c4fc10338b78eb69266a4a35ef3927badf16c" translate="yes" xml:space="preserve">
          <source>The modified commands &lt;code&gt;%Ey&lt;/code&gt; and &lt;code&gt;%Oy&lt;/code&gt; interpret the locale's alternative representation.</source>
          <target state="translated">Измененные команды &lt;code&gt;%Ey&lt;/code&gt; и &lt;code&gt;%Oy&lt;/code&gt; интерпретируют альтернативное представление локали.</target>
        </trans-unit>
        <trans-unit id="c680b13d4cfe115916d50f79a4e761597d1ce5f8" translate="yes" xml:space="preserve">
          <source>The modified commands &lt;code&gt;%Ez&lt;/code&gt; and &lt;code&gt;%Oz&lt;/code&gt; insert a &lt;code&gt;:&lt;/code&gt; between the hours and minutes (e.g., &lt;code&gt;-04:30&lt;/code&gt;).</source>
          <target state="translated">Измененные команды &lt;code&gt;%Ez&lt;/code&gt; и &lt;code&gt;%Oz&lt;/code&gt; вставляют &lt;code&gt;:&lt;/code&gt; между часами и минутами (например, &lt;code&gt;-04:30&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="967e201acaf95797b9f2a6182b751263d355c430" translate="yes" xml:space="preserve">
          <source>The modified commands &lt;code&gt;%Ez&lt;/code&gt; and &lt;code&gt;%Oz&lt;/code&gt; parses the format &lt;code&gt;[+|-]h[h][:mm]&lt;/code&gt; (i.e., requiring a &lt;code&gt;:&lt;/code&gt; between the hours and minutes and making the leading zero for hour optional).</source>
          <target state="translated">Модифицированные команды &lt;code&gt;%Ez&lt;/code&gt; и &lt;code&gt;%Oz&lt;/code&gt; анализируют формат &lt;code&gt;[+|-]h[h][:mm]&lt;/code&gt; (т. Е. Требуются &lt;code&gt;:&lt;/code&gt; между часами и минутами и необязательный ввод начального нуля для часа).</target>
        </trans-unit>
        <trans-unit id="b675bd758d57655fae835bb898a51c3bcb35971b" translate="yes" xml:space="preserve">
          <source>The monetary format is an array of four &lt;code&gt;char&lt;/code&gt;s convertible to &lt;code&gt;std::money_base::part&lt;/code&gt;. In that sequence, each of &lt;code&gt;symbol&lt;/code&gt;, &lt;code&gt;sign&lt;/code&gt;, and &lt;code&gt;value&lt;/code&gt; appears exactly once, and either &lt;code&gt;space&lt;/code&gt; or &lt;code&gt;none&lt;/code&gt; appears in the remaining position. The value &lt;code&gt;none&lt;/code&gt;, if present, is not first; the value &lt;code&gt;space&lt;/code&gt;, if present, is neither first nor last.</source>
          <target state="translated">Денежный формат представляет собой массив из четырех &lt;code&gt;char&lt;/code&gt; конвертируемых в &lt;code&gt;std::money_base::part&lt;/code&gt; . В этой последовательности каждый из &lt;code&gt;symbol&lt;/code&gt; , &lt;code&gt;sign&lt;/code&gt; и &lt;code&gt;value&lt;/code&gt; появляется ровно один раз, и в оставшейся позиции появляется либо &lt;code&gt;space&lt;/code&gt; либо &lt;code&gt;none&lt;/code&gt; . Значение &lt;code&gt;none&lt;/code&gt; , если присутствует, не является первым; &lt;code&gt;space&lt;/code&gt; значений , если оно присутствует, не является ни первым, ни последним.</target>
        </trans-unit>
        <trans-unit id="57df9eb0b96a23c853c95f72ee4e1aa61512a265" translate="yes" xml:space="preserve">
          <source>The month value stored in &lt;code&gt;*this&lt;/code&gt;.</source>
          <target state="translated">Значение месяца хранится в &lt;code&gt;*this&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e90e2ca09851d3473823a48772a0e35e7c3866b3" translate="yes" xml:space="preserve">
          <source>The most-derived type of &lt;code&gt;other&lt;/code&gt; may not match the most derived type of &lt;code&gt;*this&lt;/code&gt;. A derived class implementation therefore must typically check whether the most derived types of &lt;code&gt;*this&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt; match using &lt;code&gt;dynamic_cast&lt;/code&gt;, and immediately return &lt;code&gt;false&lt;/code&gt; if the cast fails.</source>
          <target state="translated">Наиболее производный тип &lt;code&gt;other&lt;/code&gt; может не соответствовать наиболее производному типу &lt;code&gt;*this&lt;/code&gt; . Поэтому реализация производного класса должна обычно проверять, соответствуют ли наиболее производные типы &lt;code&gt;*this&lt;/code&gt; и &lt;code&gt;other&lt;/code&gt; с использованием &lt;code&gt;dynamic_cast&lt;/code&gt; , и немедленно возвращать &lt;code&gt;false&lt;/code&gt; , если приведение не выполнено.</target>
        </trans-unit>
        <trans-unit id="16d05d9f68ef63dd77ebb7c2b2b018270c08172b" translate="yes" xml:space="preserve">
          <source>The motivation behind &lt;code&gt;std::result_of&lt;/code&gt; is to determine the result of invoking a &lt;a href=&quot;../named_req/callable&quot;&gt;Callable&lt;/a&gt;, in particular if that result type is different for different sets of arguments.</source>
          <target state="translated">Мотивация &lt;code&gt;std::result_of&lt;/code&gt; состоит в том, чтобы определить результат вызова &lt;a href=&quot;../named_req/callable&quot;&gt;Callable&lt;/a&gt; , в частности, если этот тип результата отличается для разных наборов аргументов.</target>
        </trans-unit>
        <trans-unit id="be939183f398e144c5a9f5a26339a5ff2df358bf" translate="yes" xml:space="preserve">
          <source>The move assignment operator for class &lt;code&gt;T&lt;/code&gt; is trivial if all of the following is true:</source>
          <target state="translated">Оператор присваивания для класса &lt;code&gt;T&lt;/code&gt; является тривиальным, если все следующее верно:</target>
        </trans-unit>
        <trans-unit id="913a05bd12f57d4991f4c434437ba8fdc8ca96af" translate="yes" xml:space="preserve">
          <source>The move assignment operator is called whenever it is selected by &lt;a href=&quot;overload_resolution&quot;&gt;overload resolution&lt;/a&gt;, e.g. when an object appears on the left-hand side of an assignment expression, where the right-hand side is an rvalue of the same or implicitly convertible type.</source>
          <target state="translated">Оператор присваивания перемещения вызывается всякий раз, когда он выбирается &lt;a href=&quot;overload_resolution&quot;&gt;разрешением перегрузки&lt;/a&gt; , например, когда объект появляется в левой части выражения присваивания, где правая часть является r-значением того же или неявно конвертируемого типа.</target>
        </trans-unit>
        <trans-unit id="964822bbec02f38193fe2598cdea03b6e1354a55" translate="yes" xml:space="preserve">
          <source>The move constructor for class &lt;code&gt;T&lt;/code&gt; is trivial if all of the following is true:</source>
          <target state="translated">Конструктор перемещения для класса &lt;code&gt;T&lt;/code&gt; тривиален, если все из следующего верно:</target>
        </trans-unit>
        <trans-unit id="43ecab829b4442770406c7743a4c24f8d39184e8" translate="yes" xml:space="preserve">
          <source>The move constructor is typically called when an object is &lt;a href=&quot;initialization&quot;&gt;initialized&lt;/a&gt; (by &lt;a href=&quot;direct_initialization&quot;&gt;direct-initialization&lt;/a&gt; or &lt;a href=&quot;copy_initialization&quot;&gt;copy-initialization&lt;/a&gt;) from &lt;a href=&quot;value_category#rvalue&quot;&gt;rvalue&lt;/a&gt; (xvalue or prvalue)(until C++17)xvalue(since C++17) of the same type, including.</source>
          <target state="translated">Конструктор перемещения обычно вызывается, когда объект &lt;a href=&quot;initialization&quot;&gt;инициализируется&lt;/a&gt; (путем &lt;a href=&quot;direct_initialization&quot;&gt;прямой инициализации&lt;/a&gt; или &lt;a href=&quot;copy_initialization&quot;&gt;копирования-инициализации&lt;/a&gt; ) из &lt;a href=&quot;value_category#rvalue&quot;&gt;rvalue&lt;/a&gt; (xvalue или prvalue) (до C ++ 17) xvalue (начиная с C ++ 17) того же типа, в том числе.</target>
        </trans-unit>
        <trans-unit id="6c57480f2676fa3a3bf78ec56583003322efec68" translate="yes" xml:space="preserve">
          <source>The multibyte encoding used by this function is specified by the currently active C locale.</source>
          <target state="translated">Многобайтовая кодировка,используемая этой функцией,задается текущей активной локалью C.</target>
        </trans-unit>
        <trans-unit id="3934767ca9f156dfb707eb56bde26fbae9cf9bf0" translate="yes" xml:space="preserve">
          <source>The multibyte null character was converted and stored.</source>
          <target state="translated">Многобайтовый нулевой символ конвертируется и сохраняется.</target>
        </trans-unit>
        <trans-unit id="a13f36d11d813ad1aa81620c3624a0829c3d680e" translate="yes" xml:space="preserve">
          <source>The multibyte null character was converted and stored. &lt;code&gt;src&lt;/code&gt; is set to &lt;code&gt;&lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;*ps&lt;/code&gt; represents the initial shift state.</source>
          <target state="translated">Многобайтовый нулевой символ был преобразован и сохранен. &lt;code&gt;src&lt;/code&gt; имеет &lt;code&gt;&lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt; а &lt;code&gt;*ps&lt;/code&gt; представляет начальное состояние сдвига.</target>
        </trans-unit>
        <trans-unit id="afaeafb6cba6f4e054dc4876689069feee1d4951" translate="yes" xml:space="preserve">
          <source>The mutex must be locked by the current thread of execution in shared mode, otherwise, the behavior is undefined.</source>
          <target state="translated">Мьютекс должен быть заблокирован текущим потоком исполнения в общем режиме,в противном случае поведение не определено.</target>
        </trans-unit>
        <trans-unit id="9efc369f87fb8cd445bfe13d9edeb971e0837953" translate="yes" xml:space="preserve">
          <source>The mutex must be locked by the current thread of execution, otherwise, the behavior is undefined.</source>
          <target state="translated">Мьютекс должен быть заблокирован текущим потоком исполнения,в противном случае поведение не определено.</target>
        </trans-unit>
        <trans-unit id="2c6d8525b20aacdba1419fafc3fc7f5ae08bc2dd" translate="yes" xml:space="preserve">
          <source>The n distribution parameter.</source>
          <target state="translated">Параметр n распределения.</target>
        </trans-unit>
        <trans-unit id="96123ca150593776b8703cdefba85a9b3570e940" translate="yes" xml:space="preserve">
          <source>The name &lt;code&gt;array::elems&lt;/code&gt; is only for exposition, it's not part of the interface.</source>
          <target state="translated">Имя &lt;code&gt;array::elems&lt;/code&gt; предназначено только для ознакомления , оно не является частью интерфейса.</target>
        </trans-unit>
        <trans-unit id="db9a37193da19fc9dd60f45b310779d49a73e6a1" translate="yes" xml:space="preserve">
          <source>The name &lt;code&gt;posix&lt;/code&gt; is reserved for a future top-level namespace. The behavior is undefined if a program declares or defines anything in that namespace.</source>
          <target state="translated">Имя &lt;code&gt;posix&lt;/code&gt; зарезервировано для будущего пространства имен верхнего уровня. Поведение не определено, если программа объявляет или определяет что-либо в этом пространстве имен.</target>
        </trans-unit>
        <trans-unit id="3705e1c5df92bb63d55f69679ede335b0b4b0b65" translate="yes" xml:space="preserve">
          <source>The name &lt;code&gt;proxy&lt;/code&gt; is for exposition only.</source>
          <target state="translated">Название &lt;code&gt;proxy&lt;/code&gt; только для экспозиции.</target>
        </trans-unit>
        <trans-unit id="fc982d2e54ad63316d942020cd2cc954f5238174" translate="yes" xml:space="preserve">
          <source>The name &lt;code&gt;ranges::swap&lt;/code&gt; denotes a</source>
          <target state="translated">Диапазон имен &lt;code&gt;ranges::swap&lt;/code&gt; обозначает</target>
        </trans-unit>
        <trans-unit id="2aed87bc0a44df46c92723b411bf691a391dd142" translate="yes" xml:space="preserve">
          <source>The name of a non-static data member or a non-static member function can only appear in the following three situations:</source>
          <target state="translated">Название нестатического члена данных или нестатической функции может появиться только в следующих трех ситуациях:</target>
        </trans-unit>
        <trans-unit id="89cb222de00d870b7103bfa145f09bcde84c1415" translate="yes" xml:space="preserve">
          <source>The name of an enumerator introduced in a &lt;a href=&quot;enum&quot;&gt;scoped enumeration&lt;/a&gt; begins at the point of declaration and ends at the end of the enum specifier (in contrast, unscoped enumerators are in scope after the end of the enum specifier).</source>
          <target state="translated">Имя перечислителя, введенное в перечисление с &lt;a href=&quot;enum&quot;&gt;областью,&lt;/a&gt; начинается в точке объявления и заканчивается в конце спецификатора перечисления (напротив, перечислители с незаданной областью находятся в области видимости после конца спецификатора перечисления).</target>
        </trans-unit>
        <trans-unit id="10cae2ebd2504e13706f02700ec469c53921536e" translate="yes" xml:space="preserve">
          <source>The name of an unscoped enumeration may be omitted: such declaration only introduces the enumerators into the enclosing scope:</source>
          <target state="translated">Название неразборчивого перечисления может быть опущено:такое заявление только вводит перечисления в прилагаемый объем:</target>
        </trans-unit>
        <trans-unit id="814dfe2ccc46c197be3bf6a8df03805774f01aa8" translate="yes" xml:space="preserve">
          <source>The name of every &lt;a href=&quot;class&quot;&gt;class&lt;/a&gt; member (static, non-static, function, type, etc) has an associated &quot;member access&quot;. When a name of the member is used anywhere a program, its access is checked, and if it does not satisfy the access rules, the program does not compile:</source>
          <target state="translated">С именем каждого члена &lt;a href=&quot;class&quot;&gt;класса&lt;/a&gt; (статического, нестатического, функции, типа и т. Д.) Связан &amp;laquo;доступ к члену&amp;raquo;. Когда имя члена используется где-либо в программе, проверяется его доступ, и если оно не удовлетворяет правилам доступа, программа не компилируется:</target>
        </trans-unit>
        <trans-unit id="59568709b5ee764a18b13d2df686742954820331" translate="yes" xml:space="preserve">
          <source>The name of the associated &lt;code&gt;type_info&lt;/code&gt; object.</source>
          <target state="translated">Имя связанного объекта &lt;code&gt;type_info&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ccf301417aa7c5ce4d3a1d2609e3c2ea16a28b7f" translate="yes" xml:space="preserve">
          <source>The name of the locale or &quot;*&quot; if unnamed.</source>
          <target state="translated">Название локали или &quot;*&quot;,если не указано.</target>
        </trans-unit>
        <trans-unit id="ab62ba490e7db4c1ba2cce1f51033276d065dbc5" translate="yes" xml:space="preserve">
          <source>The name of the nested class exists in the scope of the enclosing class, and name lookup from a member function of a nested class visits the scope of the enclosing class after examining the scope of the nested class. Like any member of its enclosing class, the nested class has access to all names (private, protected, etc) to which the enclosing class has access, but it is otherwise independent and has no special access to the &lt;a href=&quot;this&quot;&gt;this&lt;/a&gt; pointer of the enclosing class.</source>
          <target state="translated">Имя вложенного класса существует в области действия включающего класса, а поиск имени из функции-члена вложенного класса посещает область действия включающего класса после изучения области действия вложенного класса. Как и любой член своего включающего класса, вложенный класс имеет доступ ко всем именам (частным, защищенным и т. Д.), К которым имеет доступ включающий класс, но в остальном он независим и не имеет специального доступа к указателю &lt;a href=&quot;this&quot;&gt;this&lt;/a&gt; включающего класса.</target>
        </trans-unit>
        <trans-unit id="8748ab247c13f054caf5ac6393ba32b0c81004a9" translate="yes" xml:space="preserve">
          <source>The name of the parameter is optional:</source>
          <target state="translated">Имя параметра является необязательным:</target>
        </trans-unit>
        <trans-unit id="5fef32c68362194a9310ccea4c204a96d5f83c27" translate="yes" xml:space="preserve">
          <source>The name of the required language linkage</source>
          <target state="translated">Название требуемой языковой связи</target>
        </trans-unit>
        <trans-unit id="6a22edb52d9ca8d339db6db0919c173b04d7cfae" translate="yes" xml:space="preserve">
          <source>The name of this function can have one of the two forms:</source>
          <target state="translated">Название этой функции может иметь одну из двух форм:</target>
        </trans-unit>
        <trans-unit id="2e85a699586442a78b31c18e7ca7ed56aace9084" translate="yes" xml:space="preserve">
          <source>The name of this function stands for &quot;stream: how many characters?&quot;, so it is pronounced &quot;S how many C&quot;, rather than &quot;show many C&quot;</source>
          <target state="translated">Название этой функции означает &quot;поток:сколько символов?&quot;,поэтому произносится &quot;S,сколько C&quot;,а не &quot;показать много C&quot;.</target>
        </trans-unit>
        <trans-unit id="4177d34d388a7f7f015fd91e4b891be839e0252a" translate="yes" xml:space="preserve">
          <source>The name of this time zone (e.g., &lt;code&gt;&quot;America/New_York&quot;&lt;/code&gt;).</source>
          <target state="translated">Название этого часового пояса (например, &lt;code&gt;&quot;America/New_York&quot;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="b1f3d7cdd9264d99f9f78cc280cd57b23e748c7e" translate="yes" xml:space="preserve">
          <source>The name stands for &quot;string pointer break&quot;, because it returns a pointer to the first of the separator (&quot;break&quot;) characters.</source>
          <target state="translated">Имя означает &quot;break указателя на строку&quot;,так как возвращает указатель на первый из символов разделителя (&quot;break&quot;).</target>
        </trans-unit>
        <trans-unit id="1ee1404e6d3d16d932267176149d19223296bb12" translate="yes" xml:space="preserve">
          <source>The names &lt;code&gt;argc&lt;/code&gt; and &lt;code&gt;argv&lt;/code&gt; are arbitrary, as well as the representation of the types of the parameters: &lt;code&gt;int main(int ac, char** av)&lt;/code&gt; is equally valid.</source>
          <target state="translated">Имена &lt;code&gt;argc&lt;/code&gt; и &lt;code&gt;argv&lt;/code&gt; являются произвольными, так же как и представление типов параметров: &lt;code&gt;int main(int ac, char** av)&lt;/code&gt; одинаково действителен.</target>
        </trans-unit>
        <trans-unit id="15246282307805d7fde541df72df9de56fc0168b" translate="yes" xml:space="preserve">
          <source>The names used in the default arguments are looked up, checked for &lt;a href=&quot;access&quot;&gt;accessibility&lt;/a&gt;, and bound at the point of declaration, but are executed at the point of the function call:</source>
          <target state="translated">Имена, используемые в аргументах по умолчанию, ищутся, проверяются на &lt;a href=&quot;access&quot;&gt;доступность&lt;/a&gt; и привязываются в точке объявления, но выполняются в точке вызова функции:</target>
        </trans-unit>
        <trans-unit id="dc8c0c1bca9964f296fb879c9e2285406fd9815a" translate="yes" xml:space="preserve">
          <source>The namespace &lt;a href=&quot;../utility/rel_ops/operator_cmp&quot;&gt;rel_ops&lt;/a&gt; provides generic operators &lt;code&gt;!=&lt;/code&gt;, &lt;code&gt;&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;=&lt;/code&gt;, and &lt;code&gt;&amp;gt;=&lt;/code&gt;</source>
          <target state="translated">Пространство имен &lt;a href=&quot;../utility/rel_ops/operator_cmp&quot;&gt;rel_ops&lt;/a&gt; предоставляет универсальные операторы &lt;code&gt;!=&lt;/code&gt; , &lt;code&gt;&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;=&lt;/code&gt; И &lt;code&gt;&amp;gt;=&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="747b64b0884ce26c6ee214fc6fa900b44b84b929" translate="yes" xml:space="preserve">
          <source>The namespace &lt;code&gt;std&lt;/code&gt; is used to place names of the standard C++ library. See &lt;a href=&quot;http://en.cppreference.com/w/cpp/language/extending_std&quot;&gt;Extending namespace std&lt;/a&gt; for the rules about adding names to it.</source>
          <target state="translated">Пространство имен &lt;code&gt;std&lt;/code&gt; используется для размещения имен стандартной библиотеки C ++. См. &lt;a href=&quot;http://en.cppreference.com/w/cpp/language/extending_std&quot;&gt;Расширение пространства имен std&lt;/a&gt; для правил о добавлении имен в него.</target>
        </trans-unit>
        <trans-unit id="029adc599436884611e1679c479ef261e73420f2" translate="yes" xml:space="preserve">
          <source>The namespace alias &lt;code&gt;std::view&lt;/code&gt; is provided as a shorthand for &lt;code&gt;std::ranges::view&lt;/code&gt;.</source>
          <target state="translated">Псевдоним пространства имен &lt;code&gt;std::view&lt;/code&gt; предоставляется как сокращение для &lt;code&gt;std::ranges::view&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a00a6ec7f2538958f4971dfcb23715d488c7aa23" translate="yes" xml:space="preserve">
          <source>The namespace-body defines a &lt;a href=&quot;scope&quot;&gt;namespace scope&lt;/a&gt;, which affects &lt;a href=&quot;lookup&quot;&gt;name lookup&lt;/a&gt;.</source>
          <target state="translated">Тело namespace-body определяет &lt;a href=&quot;scope&quot;&gt;область пространства имен&lt;/a&gt; , которая влияет на &lt;a href=&quot;lookup&quot;&gt;поиск имени&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="44461e8e669298aaabf78d64c5cf761c5b270b21" translate="yes" xml:space="preserve">
          <source>The native handle of this condition variable.</source>
          <target state="translated">Нативный хэндл этой переменной условий.</target>
        </trans-unit>
        <trans-unit id="0fd9941f111f60c6088fd13f324a4124b6730d22" translate="yes" xml:space="preserve">
          <source>The native string representation of the pathname, using native syntax, native character type, and native character encoding. This string is suitable for use with OS APIs.</source>
          <target state="translated">Родное строковое представление пути с использованием родного синтаксиса,родного символьного типа и родной кодировки.Эта строка подходит для использования с OS API.</target>
        </trans-unit>
        <trans-unit id="da3734864c7a6f4ae8da4b63030befa1148f5321" translate="yes" xml:space="preserve">
          <source>The natural logarithm of a complex number z with polar coordinate components (r,&amp;theta;) equals ln r + i(&amp;theta;+2n&amp;pi;), with the principal value ln r + i&amp;theta;</source>
          <target state="translated">Натуральный логарифм комплексного числа z с компонентами полярной координаты (r, &amp;theta;) равен ln r + i (&amp;theta; + 2n&amp;pi;) с главным значением ln r + i&amp;theta;</target>
        </trans-unit>
        <trans-unit id="3e1f12a369d7befe692c93f44687eb7110ca778a" translate="yes" xml:space="preserve">
          <source>The nearest integer value to &lt;code&gt;arg&lt;/code&gt;, according to the &lt;a href=&quot;../fenv/fe_round&quot;&gt;current rounding mode&lt;/a&gt;, is returned.</source>
          <target state="translated">Ближайшее целое значение &lt;code&gt;arg&lt;/code&gt; , в соответствии с &lt;a href=&quot;../fenv/fe_round&quot;&gt;текущим режимом округления&lt;/a&gt; , возвращается.</target>
        </trans-unit>
        <trans-unit id="a00868e0a58251c056ae90a3de93adcb746a8300" translate="yes" xml:space="preserve">
          <source>The new alias alias_name provides an alternate method of accessing ns_name.</source>
          <target state="translated">Новый псевдоним alias_name обеспечивает альтернативный метод доступа к имени ns_name.</target>
        </trans-unit>
        <trans-unit id="429783cbe5a2b5c7d1031e7777e0e7ddc7639a9d" translate="yes" xml:space="preserve">
          <source>The new expression looks for appropriate allocation function's name firstly in the class scope, and after that in the global scope. Note, that as per &lt;a href=&quot;../../language/lookup&quot;&gt;name lookup rules&lt;/a&gt;, any allocation functions declared in class scope hides all global allocation functions for the new-expressions that attempt to allocate objects of this class.</source>
          <target state="translated">Новое выражение ищет имя соответствующей функции распределения сначала в области видимости класса, а затем в глобальной области видимости. Обратите внимание, что согласно &lt;a href=&quot;../../language/lookup&quot;&gt;правилам поиска имен&lt;/a&gt; , все функции выделения, объявленные в области видимости класса, скрывают все глобальные функции размещения для выражений new, которые пытаются выделить объекты этого класса.</target>
        </trans-unit>
        <trans-unit id="b4f387edefbb790808ceeca9099abd48faba678a" translate="yes" xml:space="preserve">
          <source>The new string can be one of:</source>
          <target state="translated">Новая строка может быть одной из них:</target>
        </trans-unit>
        <trans-unit id="c9828879c32005d467860b7e9f5f3d8c58eb5420" translate="yes" xml:space="preserve">
          <source>The new value of &lt;code&gt;rv&lt;/code&gt; is unspecified.</source>
          <target state="translated">Новое значение &lt;code&gt;rv&lt;/code&gt; не указано.</target>
        </trans-unit>
        <trans-unit id="5d39b572de7e7c5941b91ef76f32e21e73a603a2" translate="yes" xml:space="preserve">
          <source>The new, nameless, locale.</source>
          <target state="translated">Новое,безымянное,местное.</target>
        </trans-unit>
        <trans-unit id="da2f7bd8f4e5182cfeb3ed50ce6c838f6be3f42c" translate="yes" xml:space="preserve">
          <source>The new-expression allocates storage by calling the appropriate &lt;a href=&quot;../memory/new/operator_new&quot;&gt; allocation function&lt;/a&gt;. If &lt;code&gt;type&lt;/code&gt; is a non-array type, the name of the function is &lt;code&gt;operator new&lt;/code&gt;. If &lt;code&gt;type&lt;/code&gt; is an array type, the name of the function is &lt;code&gt;operator new[]&lt;/code&gt;.</source>
          <target state="translated">Выражение new выделяет хранилище, вызывая соответствующую &lt;a href=&quot;../memory/new/operator_new&quot;&gt;функцию выделения&lt;/a&gt; . Если &lt;code&gt;type&lt;/code&gt; является типом массива, имя функции - &lt;code&gt;operator new&lt;/code&gt; . Если &lt;code&gt;type&lt;/code&gt; является типом массива, имя функции - &lt;code&gt;operator new[]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f81c62ecf75f1df624cbf52969b5f6fcc7a10310" translate="yes" xml:space="preserve">
          <source>The new-line character &lt;code&gt;\n&lt;/code&gt; has special meaning when used in &lt;a href=&quot;../io/c&quot;&gt;text mode I/O&lt;/a&gt;: it is converted to the OS-specific newline representation, usually a byte or byte sequence. Some systems mark their lines with length fields instead.</source>
          <target state="translated">Символ новой строки &lt;code&gt;\n&lt;/code&gt; имеет особое значение при использовании в &lt;a href=&quot;../io/c&quot;&gt;режиме ввода-вывода&lt;/a&gt; в текстовом режиме : он преобразуется в специфическое для ОС представление новой строки, обычно байтовую или байтовую последовательность. Некоторые системы помечают свои строки полями длины.</target>
        </trans-unit>
        <trans-unit id="5004a5f082175ce95c41ab6d7df587cd32a7942b" translate="yes" xml:space="preserve">
          <source>The newly-created object of type &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">Вновь созданный объект типа &lt;code&gt;T&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6a3ab198cc816c45e12af507dd340aff4fdc62a4" translate="yes" xml:space="preserve">
          <source>The next character in the get area, &lt;code&gt;(unsigned char)(*gptr())&lt;/code&gt; on success, &lt;code&gt;&lt;a href=&quot;../c&quot;&gt;EOF&lt;/a&gt;&lt;/code&gt; on failure.</source>
          <target state="translated">Следующий символ в области получения &lt;code&gt;(unsigned char)(*gptr())&lt;/code&gt; при успехе, &lt;code&gt;&lt;a href=&quot;../c&quot;&gt;EOF&lt;/a&gt;&lt;/code&gt; при ошибке.</target>
        </trans-unit>
        <trans-unit id="b97d648e7c3b9a6a63758b3451bbdb0486f22240" translate="yes" xml:space="preserve">
          <source>The next character is extracted from &lt;code&gt;in&lt;/code&gt; as if by &lt;code&gt;char_type ct = *in;&lt;/code&gt;</source>
          <target state="translated">Следующий символ извлекается из &lt;code&gt;in&lt;/code&gt; как будто &lt;code&gt;char_type ct = *in;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b4680ffa8ce226ac6776cedbea3e5f170c27a198" translate="yes" xml:space="preserve">
          <source>The next multibyte character to be stored would exceed &lt;code&gt;len&lt;/code&gt;.</source>
          <target state="translated">Следующий многобайтовый символ, который будет сохранен, будет превышать &lt;code&gt;len&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ceaab5e3743ebc5e67758c93a0ae4928508e66de" translate="yes" xml:space="preserve">
          <source>The next wide character from the stream or &lt;code&gt;WEOF&lt;/code&gt; if an error has occurred or the end of file has been reached. If an encoding error occurred, &lt;code&gt;&lt;a href=&quot;../../error/errno&quot;&gt;errno&lt;/a&gt;&lt;/code&gt; is set to &lt;code&gt;EILSEQ&lt;/code&gt;.</source>
          <target state="translated">Следующий широкий символ из потока или &lt;code&gt;WEOF&lt;/code&gt; , если произошла ошибка или достигнут конец файла. Если произошла ошибка кодирования, &lt;code&gt;&lt;a href=&quot;../../error/errno&quot;&gt;errno&lt;/a&gt;&lt;/code&gt; устанавливается в &lt;code&gt;EILSEQ&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1e768a510933a94e869abc7fbe11cfe3c7af6736" translate="yes" xml:space="preserve">
          <source>The next wide character to be stored would exceed &lt;code&gt;len&lt;/code&gt;.</source>
          <target state="translated">Следующий широкий символ, который будет сохранен, будет превышать &lt;code&gt;len&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="01a927ab9df8533e7f8f33e9f6abfb695cfb7e25" translate="yes" xml:space="preserve">
          <source>The noexcept-specification is a part of the function type and may appear as part of any &lt;a href=&quot;function&quot;&gt;function declarator&lt;/a&gt;.</source>
          <target state="translated">Спецификация noexcept является частью типа функции и может появляться как часть любого &lt;a href=&quot;function&quot;&gt;объявления функции&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7e8e2aa7b768b907757e4c37f13e697b69a77fae" translate="yes" xml:space="preserve">
          <source>The noexcept-specification is not a part of the function type (just like &lt;a href=&quot;except_spec&quot;&gt;dynamic exception specification&lt;/a&gt;) and can only appear as a part of a &lt;a href=&quot;lambda&quot;&gt;lambda declarator&lt;/a&gt; or a top-level &lt;a href=&quot;function&quot;&gt;function declarator&lt;/a&gt; when declaring functions, variables, non-static data members of type function, pointer to function, reference to function, or pointer to member function, and also when declaring a parameter or a return type in one of those declarations that in turn happens to be a pointer or reference to function. It cannot appear in a &lt;a href=&quot;typedef&quot;&gt;typedef&lt;/a&gt; or &lt;a href=&quot;type_alias&quot;&gt;type alias&lt;/a&gt; declaration.</source>
          <target state="translated">Noexcept-спецификация не является частью типа функции (так же , как &lt;a href=&quot;except_spec&quot;&gt;динамические спецификации исключений&lt;/a&gt; ) и может появиться только как часть &lt;a href=&quot;lambda&quot;&gt;лямбды - описателя&lt;/a&gt; или верхнего уровень &lt;a href=&quot;function&quot;&gt;функции описателя&lt;/a&gt; при объявлении функции, переменных, не статические элементы данных типа функция, указатель на функцию, ссылка на функцию или указатель на функцию-член, а также при объявлении параметра или возвращаемого типа в одном из тех объявлений, которые в свою очередь оказываются указателем или ссылкой на функцию. Он не может появиться в объявлении &lt;a href=&quot;typedef&quot;&gt;typedef&lt;/a&gt; или &lt;a href=&quot;type_alias&quot;&gt;псевдонима типа&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="91d5dbc9bc5e94a5126d0bce53badf87576b47e0" translate="yes" xml:space="preserve">
          <source>The non-converting specialization &lt;code&gt;&lt;a href=&quot;../codecvt&quot;&gt;std::codecvt&lt;/a&gt;&amp;lt;char, char, &lt;a href=&quot;../../string/multibyte/mbstate_t&quot;&gt;std::mbstate_t&lt;/a&gt;&amp;gt;&lt;/code&gt; always returns &lt;code&gt;&lt;a href=&quot;../codecvt_base&quot;&gt;std::codecvt_base::noconv&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Неконвертирующая специализация &lt;code&gt;&lt;a href=&quot;../codecvt&quot;&gt;std::codecvt&lt;/a&gt;&amp;lt;char, char, &lt;a href=&quot;../../string/multibyte/mbstate_t&quot;&gt;std::mbstate_t&lt;/a&gt;&amp;gt;&lt;/code&gt; всегда возвращает &lt;code&gt;&lt;a href=&quot;../codecvt_base&quot;&gt;std::codecvt_base::noconv&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="dc09343d894c712f42534e3a3a7a2e71d277a115" translate="yes" xml:space="preserve">
          <source>The non-converting specialization &lt;code&gt;&lt;a href=&quot;../codecvt&quot;&gt;std::codecvt&lt;/a&gt;&amp;lt;char, char, &lt;a href=&quot;../../string/multibyte/mbstate_t&quot;&gt;std::mbstate_t&lt;/a&gt;&amp;gt;&lt;/code&gt; returns &lt;code&gt;1&lt;/code&gt;.</source>
          <target state="translated">Неконвертирующая специализация &lt;code&gt;&lt;a href=&quot;../codecvt&quot;&gt;std::codecvt&lt;/a&gt;&amp;lt;char, char, &lt;a href=&quot;../../string/multibyte/mbstate_t&quot;&gt;std::mbstate_t&lt;/a&gt;&amp;gt;&lt;/code&gt; возвращает &lt;code&gt;1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3181f2172f64e8c18c66b621b97fc46888a027ba" translate="yes" xml:space="preserve">
          <source>The non-converting specialization &lt;code&gt;&lt;a href=&quot;../codecvt&quot;&gt;std::codecvt&lt;/a&gt;&amp;lt;char, char, &lt;a href=&quot;../../string/multibyte/mbstate_t&quot;&gt;std::mbstate_t&lt;/a&gt;&amp;gt;&lt;/code&gt; returns &lt;code&gt;&lt;a href=&quot;../../algorithm/min&quot;&gt;std::min&lt;/a&gt;(max, from_end-from)&lt;/code&gt;.</source>
          <target state="translated">Неконвертирующая специализация &lt;code&gt;&lt;a href=&quot;../codecvt&quot;&gt;std::codecvt&lt;/a&gt;&amp;lt;char, char, &lt;a href=&quot;../../string/multibyte/mbstate_t&quot;&gt;std::mbstate_t&lt;/a&gt;&amp;gt;&lt;/code&gt; возвращает &lt;code&gt;&lt;a href=&quot;../../algorithm/min&quot;&gt;std::min&lt;/a&gt;(max, from_end-from)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a64105f39486401f5acc80b055bc1c3fc01a2fb5" translate="yes" xml:space="preserve">
          <source>The non-converting specialization &lt;code&gt;&lt;a href=&quot;../codecvt&quot;&gt;std::codecvt&lt;/a&gt;&amp;lt;char, char, &lt;a href=&quot;../../string/multibyte/mbstate_t&quot;&gt;std::mbstate_t&lt;/a&gt;&amp;gt;&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">Неконвертирующая специализация &lt;code&gt;&lt;a href=&quot;../codecvt&quot;&gt;std::codecvt&lt;/a&gt;&amp;lt;char, char, &lt;a href=&quot;../../string/multibyte/mbstate_t&quot;&gt;std::mbstate_t&lt;/a&gt;&amp;gt;&lt;/code&gt; возвращает &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e57a9aa4e3c88808abdb8487b916a663a9f0cec4" translate="yes" xml:space="preserve">
          <source>The non-negative value of type &lt;code&gt;catalog&lt;/code&gt; that can be used with &lt;code&gt;&lt;a href=&quot;get&quot;&gt;get()&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;close&quot;&gt;close()&lt;/a&gt;&lt;/code&gt;. Returns a negative value if the catalog could not be opened.</source>
          <target state="translated">Неотрицательное значение типа &lt;code&gt;catalog&lt;/code&gt; , которое можно использовать с &lt;code&gt;&lt;a href=&quot;get&quot;&gt;get()&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;close&quot;&gt;close()&lt;/a&gt;&lt;/code&gt; . Возвращает отрицательное значение, если каталог не может быть открыт.</target>
        </trans-unit>
        <trans-unit id="02e334d13769a2c905eebc3be84f4142a27bd649" translate="yes" xml:space="preserve">
          <source>The non-throwing overload has no special action on error.</source>
          <target state="translated">Небросающая перегрузка не имеет специальных действий по ошибке.</target>
        </trans-unit>
        <trans-unit id="34e36164ec9a95125dc49a45834357890507b833" translate="yes" xml:space="preserve">
          <source>The non-throwing overload returns &lt;code&gt;-1&lt;/code&gt; on errors.</source>
          <target state="translated">Перегрузка без выбрасывания возвращает &lt;code&gt;-1&lt;/code&gt; при ошибках.</target>
        </trans-unit>
        <trans-unit id="aa28e66303348738c761475c96ff70e7788d369b" translate="yes" xml:space="preserve">
          <source>The non-throwing overload returns &lt;code&gt;false&lt;/code&gt; on errors.</source>
          <target state="translated">Не перебрасывающая перегрузка возвращает &lt;code&gt;false&lt;/code&gt; при ошибках.</target>
        </trans-unit>
        <trans-unit id="919ace58ca21119d988f2559255ddff1ca1db7ec" translate="yes" xml:space="preserve">
          <source>The non-throwing overload returns &lt;code&gt;static_cast&amp;lt;uintmax_t&amp;gt;(-1)&lt;/code&gt; on errors.</source>
          <target state="translated">Перегрузка без выбрасывания возвращает &lt;code&gt;static_cast&amp;lt;uintmax_t&amp;gt;(-1)&lt;/code&gt; при ошибках.</target>
        </trans-unit>
        <trans-unit id="998e79778beab53392bc4f00d5142904ec8702e3" translate="yes" xml:space="preserve">
          <source>The non-throwing overload returns an empty path on errors.</source>
          <target state="translated">Неперебрасываемая перегрузка возвращает пустой путь по ошибкам.</target>
        </trans-unit>
        <trans-unit id="afb768fa11ed8a7e400ee259f3f1ed7b0405bd1e" translate="yes" xml:space="preserve">
          <source>The non-throwing overload sets all members to &lt;code&gt;static_cast&amp;lt;uintmax_t&amp;gt;(-1)&lt;/code&gt; on error.</source>
          <target state="translated">Перегрузка без выбрасывания устанавливает все элементы в &lt;code&gt;static_cast&amp;lt;uintmax_t&amp;gt;(-1)&lt;/code&gt; в случае ошибки.</target>
        </trans-unit>
        <trans-unit id="fa9c9a7d355030087b9f4a3bf568048262b6a45c" translate="yes" xml:space="preserve">
          <source>The norm calculated by this function is also known as &lt;a href=&quot;https://en.wikipedia.org/wiki/Field_norm&quot;&gt;field norm&lt;/a&gt; or &lt;a href=&quot;http://mathworld.wolfram.com/AbsoluteSquare.html&quot;&gt;absolute square&lt;/a&gt;.</source>
          <target state="translated">Норма, вычисляемая этой функцией, также называется &lt;a href=&quot;https://en.wikipedia.org/wiki/Field_norm&quot;&gt;полевой нормой&lt;/a&gt; или &lt;a href=&quot;http://mathworld.wolfram.com/AbsoluteSquare.html&quot;&gt;абсолютным квадратом&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7e486b6025e3738e962c61297301601872036ad5" translate="yes" xml:space="preserve">
          <source>The normal form of an expression &lt;code&gt;(E)&lt;/code&gt; is the normal form of &lt;code&gt;E&lt;/code&gt;;</source>
          <target state="translated">Нормальная форма выражения &lt;code&gt;(E)&lt;/code&gt; является нормальной формой &lt;code&gt;E&lt;/code&gt; ;</target>
        </trans-unit>
        <trans-unit id="9bddf9d40a32b5e00d57e01971707d640e804497" translate="yes" xml:space="preserve">
          <source>The normal form of an expression &lt;code&gt;C&amp;lt;A1, A2, ... , AN&amp;gt;&lt;/code&gt;, where &lt;code&gt;C&lt;/code&gt; names a concept, is the normal form of the constraint expression of &lt;code&gt;C&lt;/code&gt;, after substituting A1, A2, ... , AN for &lt;code&gt;C&lt;/code&gt;'s respective template parameters in the parameter mappings of each atomic constraint of C. If any such substitution into the parameter mappings results in an invalid type or expression, the program is ill-formed, no diagnostic required.</source>
          <target state="translated">Нормальная форма выражения &lt;code&gt;C&amp;lt;A1, A2, ... , AN&amp;gt;&lt;/code&gt; , где &lt;code&gt;C&lt;/code&gt; называет концепт, является нормальной формой выражения ограничения &lt;code&gt;C&lt;/code&gt; после замены A1, A2, ..., AN на &lt;code&gt;C&lt;/code&gt; ' Соответствующие параметры шаблона в сопоставлениях параметров каждого атомарного ограничения C. Если любая такая замена в сопоставлениях параметров приводит к недопустимому типу или выражению, программа некорректна, диагностика не требуется.</target>
        </trans-unit>
        <trans-unit id="5086c57862725f37980d863e1b8836e88a15cef7" translate="yes" xml:space="preserve">
          <source>The normal form of an expression &lt;code&gt;E1 &amp;amp;&amp;amp; E2&lt;/code&gt; is the conjunction of the normal forms of &lt;code&gt;E1&lt;/code&gt; and &lt;code&gt;E2&lt;/code&gt;.</source>
          <target state="translated">Нормальная форма выражения &lt;code&gt;E1 &amp;amp;&amp;amp; E2&lt;/code&gt; - это соединение нормальных форм &lt;code&gt;E1&lt;/code&gt; и &lt;code&gt;E2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="218bd31f9dfc47e61adeda7a1fae8d05c1d9c91a" translate="yes" xml:space="preserve">
          <source>The normal form of an expression &lt;code&gt;E1 || E2&lt;/code&gt; is the disjunction of the normal forms of &lt;code&gt;E1&lt;/code&gt; and &lt;code&gt;E2&lt;/code&gt;.</source>
          <target state="translated">Нормальная форма выражения &lt;code&gt;E1 || E2&lt;/code&gt; - это дизъюнкция нормальных форм &lt;code&gt;E1&lt;/code&gt; и &lt;code&gt;E2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3cfc995fd9a247d5a41e7c2c9e5f1255a95384b9" translate="yes" xml:space="preserve">
          <source>The normal form of any other expression &lt;code&gt;E&lt;/code&gt; is the atomic constraint whose expression is &lt;code&gt;E&lt;/code&gt; and whose parameter mapping is the identity mapping. This includes all &lt;a href=&quot;fold&quot;&gt;fold expressions&lt;/a&gt;, even those folding over the &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; or &lt;code&gt;||&lt;/code&gt; operators.</source>
          <target state="translated">Нормальная форма любого другого выражения &lt;code&gt;E&lt;/code&gt; - это атомарное ограничение, выражение которого - &lt;code&gt;E&lt;/code&gt; , а отображение параметров - отображение тождеств. Это включает в себя все &lt;a href=&quot;fold&quot;&gt;выражения сгиба&lt;/a&gt; , даже те, которые сворачиваются над &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; или &lt;code&gt;||&lt;/code&gt; операторы.</target>
        </trans-unit>
        <trans-unit id="fe2c62a2f9883108b9601f6b362958e238efecab" translate="yes" xml:space="preserve">
          <source>The notifying thread does not need to hold the lock on the same mutex as the one held by the waiting thread(s); in fact doing so is a pessimization, since the notified thread would immediately block again, waiting for the notifying thread to release the lock.</source>
          <target state="translated">Поток нотификации не должен держать блокировку на том же мьютексе,что и поток ожидания;на самом деле,это пессимизация,так как поток нотификации будет немедленно блокироваться снова,ожидая,пока поток нотификации освободит блокировку.</target>
        </trans-unit>
        <trans-unit id="74b817b062ef6088a10c131453eb749d4d9679d7" translate="yes" xml:space="preserve">
          <source>The notifying thread does not need to hold the lock on the same mutex as the one held by the waiting thread(s); in fact doing so is a pessimization, since the notified thread would immediately block again, waiting for the notifying thread to release the lock. However, some implementations (in particular many implementations of pthreads) recognize this situation and avoid this &quot;hurry up and wait&quot; scenario by transferring the waiting thread from the condition variable's queue directly to the queue of the mutex within the notify call, without waking it up.</source>
          <target state="translated">Поток нотификации не должен держать блокировку на том же мьютексе,что и поток ожидания;на самом деле,это пессимизация,так как поток нотификации будет немедленно блокироваться снова,ожидая,пока поток нотификации освободит блокировку.Однако некоторые реализации (в частности,многие реализации pthreads)распознают эту ситуацию и избегают этого сценария &quot;поторопиться и подождать&quot;,перенося ожидающий поток из очереди условной переменной непосредственно в очередь мьютекса в рамках вызова уведомления,не пробуждая его.</target>
        </trans-unit>
        <trans-unit id="d72947b7a5e5177d55e7da50e671e2cfaa9b935b" translate="yes" xml:space="preserve">
          <source>The null character (&lt;code&gt;'\0'&lt;/code&gt;, &lt;code&gt;L'\0'&lt;/code&gt;, &lt;code&gt;char16_t()&lt;/code&gt;, etc) is always appended to the string literal: thus, a string literal &lt;code&gt;&quot;Hello&quot;&lt;/code&gt; is a &lt;code&gt;const char[6]&lt;/code&gt; holding the characters &lt;code&gt;'H'&lt;/code&gt;, &lt;code&gt;'e'&lt;/code&gt;, &lt;code&gt;'l'&lt;/code&gt;, &lt;code&gt;'l'&lt;/code&gt;, &lt;code&gt;'o'&lt;/code&gt;, and &lt;code&gt;'\0'&lt;/code&gt;.</source>
          <target state="translated">Нулевой символ ( &lt;code&gt;'\0'&lt;/code&gt; , &lt;code&gt;L'\0'&lt;/code&gt; , &lt;code&gt;char16_t()&lt;/code&gt; и т. Д.) Всегда добавляется к строковому литералу: таким образом, строковый литерал &lt;code&gt;&quot;Hello&quot;&lt;/code&gt; является &lt;code&gt;const char[6]&lt;/code&gt; содержащим символы &lt;code&gt;'H'&lt;/code&gt; , &lt;code&gt;'e'&lt;/code&gt; , &lt;code&gt;'l'&lt;/code&gt; , &lt;code&gt;'l'&lt;/code&gt; , &lt;code&gt;'o'&lt;/code&gt; и &lt;code&gt;'\0'&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="faf4539050f33260142e5e1942efa29dd4846fe8" translate="yes" xml:space="preserve">
          <source>The null character was converted and stored.</source>
          <target state="translated">Нулевой символ был преобразован и сохранен.</target>
        </trans-unit>
        <trans-unit id="248246a3944930a0737208d795018f3412610899" translate="yes" xml:space="preserve">
          <source>The null character was converted and stored. &lt;code&gt;src&lt;/code&gt; is set to &lt;code&gt;&lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;*ps&lt;/code&gt; represents the initial shift state.</source>
          <target state="translated">Нулевой символ был преобразован и сохранен. &lt;code&gt;src&lt;/code&gt; имеет &lt;code&gt;&lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt; а &lt;code&gt;*ps&lt;/code&gt; представляет начальное состояние сдвига.</target>
        </trans-unit>
        <trans-unit id="c07d16928e24253bdda00754b26c48658241a00d" translate="yes" xml:space="preserve">
          <source>The null directive (&lt;code&gt;#&lt;/code&gt; followed by a line break) is allowed and has no effect.</source>
          <target state="translated">Директива null ( &lt;code&gt;#&lt;/code&gt; , за которой следует разрыв строки) разрешена и не имеет никакого эффекта.</target>
        </trans-unit>
        <trans-unit id="025c68351e84ef6a409e2a0b3cccd1343af71a32" translate="yes" xml:space="preserve">
          <source>The number of &lt;code&gt;CharT&lt;/code&gt; elements in the string.</source>
          <target state="translated">Количество элементов &lt;code&gt;CharT&lt;/code&gt; в строке.</target>
        </trans-unit>
        <trans-unit id="ed5405dde434342736b19ab060ea61207493342f" translate="yes" xml:space="preserve">
          <source>The number of &lt;code&gt;CharT&lt;/code&gt; elements in the view.</source>
          <target state="translated">Количество элементов &lt;code&gt;CharT&lt;/code&gt; в представлении.</target>
        </trans-unit>
        <trans-unit id="e56138bf523de60c8f035f5f12250f1f8ed8ee0d" translate="yes" xml:space="preserve">
          <source>The number of &lt;code&gt;externT&lt;/code&gt; characters that would be consumed if converted by &lt;code&gt;&lt;a href=&quot;in&quot;&gt;do_in()&lt;/a&gt;&lt;/code&gt; until either all &lt;code&gt;from_end-from&lt;/code&gt; characters were consumed or &lt;code&gt;max&lt;/code&gt;&lt;code&gt;internT&lt;/code&gt; characters were produced, or a conversion error occurred.</source>
          <target state="translated">Количество символов &lt;code&gt;externT&lt;/code&gt; , которые будут использованы при преобразовании &lt;code&gt;&lt;a href=&quot;in&quot;&gt;do_in()&lt;/a&gt;&lt;/code&gt; до тех пор, пока не будут использованы все &lt;code&gt;from_end-from&lt;/code&gt; или не будет &lt;code&gt;internT&lt;/code&gt; &lt;code&gt;max&lt;/code&gt; количество символов internT , или произошла ошибка преобразования.</target>
        </trans-unit>
        <trans-unit id="7563f8961703d5358be5cd18a6c7fd7caeb16313" translate="yes" xml:space="preserve">
          <source>The number of &lt;code&gt;shared_ptr&lt;/code&gt; instances sharing the ownership of the managed object at the instant of the call.</source>
          <target state="translated">Количество экземпляров &lt;code&gt;shared_ptr&lt;/code&gt; , совместно использующих права собственности на управляемый объект в момент вызова.</target>
        </trans-unit>
        <trans-unit id="69061d2f8b406eee14a4cb45eba7155a2d754383" translate="yes" xml:space="preserve">
          <source>The number of bits in a bit field sets the limit to the range of values it can hold:</source>
          <target state="translated">Количество битов в поле битов устанавливает предел диапазона значений,который он может удерживать:</target>
        </trans-unit>
        <trans-unit id="3f9099e3c7d873d70b362e3a89df1f5709452578" translate="yes" xml:space="preserve">
          <source>The number of buckets in the container.</source>
          <target state="translated">Количество ведер в контейнере.</target>
        </trans-unit>
        <trans-unit id="c785090a06b869af10617d403684a6661945ed63" translate="yes" xml:space="preserve">
          <source>The number of bytes (between &lt;code&gt;1&lt;/code&gt; and &lt;code&gt;n&lt;/code&gt;) that complete a valid multibyte character.</source>
          <target state="translated">Количество байтов (от &lt;code&gt;1&lt;/code&gt; до &lt;code&gt;n&lt;/code&gt; ), которые завершают допустимый многобайтовый символ.</target>
        </trans-unit>
        <trans-unit id="4be8b408517c6e0f5de03175a85f9c74465aa587" translate="yes" xml:space="preserve">
          <source>The number of bytes stored in the array object (including any shift sequences). This may be zero when &lt;code&gt;c8&lt;/code&gt; is not the final code unit in the UTF-8 representation of a code point.</source>
          <target state="translated">Количество байтов, хранящихся в объекте массива (включая любые последовательности сдвига). Это может быть ноль, когда &lt;code&gt;c8&lt;/code&gt; не является конечной кодовой единицей в представлении UTF-8 кодовой точки.</target>
        </trans-unit>
        <trans-unit id="1b02eec6dc83ccdd83bcea1a56eb671b42ec3a69" translate="yes" xml:space="preserve">
          <source>The number of bytes written into the character array pointed to by &lt;code&gt;str&lt;/code&gt; not including the terminating &lt;code&gt;'\0'&lt;/code&gt; on success. If &lt;code&gt;count&lt;/code&gt; was reached before the entire string could be stored, &lt;code&gt;​0​&lt;/code&gt; is returned and the contents are undefined.</source>
          <target state="translated">Количество байтов, записанных в массив символов, на которые указывает &lt;code&gt;str&lt;/code&gt; , не включая завершающий &lt;code&gt;'\0'&lt;/code&gt; в случае успеха. Если &lt;code&gt;count&lt;/code&gt; был достигнут до того , как вся строка может быть сохранена, &lt;code&gt;​0​&lt;/code&gt; возвращается , и содержимое не определены.</target>
        </trans-unit>
        <trans-unit id="d8967c57de8e646af979d9e3d24efce148b0348b" translate="yes" xml:space="preserve">
          <source>The number of characters actually extracted.</source>
          <target state="translated">Количество фактически извлечённых символов.</target>
        </trans-unit>
        <trans-unit id="a55f46f0cba247803d518fc84899892627e6d13a" translate="yes" xml:space="preserve">
          <source>The number of characters available for non-blocking read (either the size of the get area or the number of characters ready for reading from the associated character sequence), or &lt;code&gt;-1&lt;/code&gt; if no characters are available in the associated sequence as far as &lt;code&gt;&lt;a href=&quot;showmanyc&quot;&gt;showmanyc()&lt;/a&gt;&lt;/code&gt; can tell.</source>
          <target state="translated">Количество символов, доступных для неблокирующего чтения (либо размер области получения, либо количество символов, готовых к чтению из связанной последовательности символов), или &lt;code&gt;-1&lt;/code&gt; , если в связанной последовательности нет доступных символов, вплоть до &lt;code&gt;&lt;a href=&quot;showmanyc&quot;&gt;showmanyc()&lt;/a&gt;&lt;/code&gt; могу сказать.</target>
        </trans-unit>
        <trans-unit id="8ec083d621e3f753125e182fe5084fd848f34df3" translate="yes" xml:space="preserve">
          <source>The number of characters available for reading from the file, or &lt;code&gt;-1&lt;/code&gt; if the end of file was reached.</source>
          <target state="translated">Количество символов, доступных для чтения из файла, или &lt;code&gt;-1&lt;/code&gt; , если достигнут конец файла.</target>
        </trans-unit>
        <trans-unit id="daf9eb1b235764a22547b341d3cc6ad96b107014" translate="yes" xml:space="preserve">
          <source>The number of characters consumed by the most recent conversion operation.</source>
          <target state="translated">Количество символов,потребляемых последней операцией преобразования.</target>
        </trans-unit>
        <trans-unit id="31a745112d734fafc43f6e526f229e8cc0817594" translate="yes" xml:space="preserve">
          <source>The number of characters extracted by the last unformatted input operation.</source>
          <target state="translated">Количество символов,извлеченных последней неоформленной операцией ввода.</target>
        </trans-unit>
        <trans-unit id="025f13559fc4a76405d90651c0e5de33b6d88a9a" translate="yes" xml:space="preserve">
          <source>The number of characters in the put area, or zero if nothing was output.</source>
          <target state="translated">Количество символов в поле ввода,или ноль,если ничего не было выведено.</target>
        </trans-unit>
        <trans-unit id="b36a0d1d6266f14401ce912fa34b84443739b9ed" translate="yes" xml:space="preserve">
          <source>The number of characters successfully read. If it is less than &lt;code&gt;count&lt;/code&gt; the input sequence has reached the end.</source>
          <target state="translated">Количество символов успешно прочитано. Если он меньше, чем &lt;code&gt;count&lt;/code&gt; входная последовательность достигла конца.</target>
        </trans-unit>
        <trans-unit id="755b4ee802930b67c7f96314436110b4b1007db7" translate="yes" xml:space="preserve">
          <source>The number of characters successfully written.</source>
          <target state="translated">Количество успешно написанных символов.</target>
        </trans-unit>
        <trans-unit id="0424ddfc94d33a5b039d2cf4e4fb1ccac4396955" translate="yes" xml:space="preserve">
          <source>The number of characters that are certainly available in the associated character sequence, or &lt;code&gt;-1&lt;/code&gt; if &lt;code&gt;showmanyc&lt;/code&gt; can determine, without blocking, that no characters are available. If &lt;code&gt;showmanyc&lt;/code&gt; returns &lt;code&gt;-1&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;underflow&quot;&gt;underflow()&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;uflow&quot;&gt;uflow()&lt;/a&gt;&lt;/code&gt; will definitely return &lt;code&gt;Traits::eof&lt;/code&gt; or throw.</source>
          <target state="translated">Количество символов, которые, безусловно, доступны в соответствующей последовательности символов, или &lt;code&gt;-1&lt;/code&gt; , если &lt;code&gt;showmanyc&lt;/code&gt; может определить, не блокируя, что символы недоступны. Если &lt;code&gt;showmanyc&lt;/code&gt; возвращает &lt;code&gt;-1&lt;/code&gt; , underflow &lt;code&gt;&lt;a href=&quot;underflow&quot;&gt;underflow()&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;uflow&quot;&gt;uflow()&lt;/a&gt;&lt;/code&gt; обязательно вернут &lt;code&gt;Traits::eof&lt;/code&gt; или throw.</target>
        </trans-unit>
        <trans-unit id="572abc135ef958490a79fa0e1af5c7c67e142749" translate="yes" xml:space="preserve">
          <source>The number of characters written to the put area.</source>
          <target state="translated">Количество символов,записанных в поле ввода.</target>
        </trans-unit>
        <trans-unit id="be9d72f9b5ea67854905c61a719c823300aee734" translate="yes" xml:space="preserve">
          <source>The number of comparisons performed is logarithmic in the distance between &lt;code&gt;first&lt;/code&gt; and &lt;code&gt;last&lt;/code&gt; (At most 2 * log</source>
          <target state="translated">Количество выполненных сравнений является логарифмическим по расстоянию между &lt;code&gt;first&lt;/code&gt; и &lt;code&gt;last&lt;/code&gt; (не более 2 * log</target>
        </trans-unit>
        <trans-unit id="d7d13597f2fd284fd58cd626f0e7ce58b0a1966e" translate="yes" xml:space="preserve">
          <source>The number of comparisons performed is logarithmic in the distance between &lt;code&gt;first&lt;/code&gt; and &lt;code&gt;last&lt;/code&gt; (At most log</source>
          <target state="translated">Количество выполненных сравнений является логарифмическим по расстоянию между &lt;code&gt;first&lt;/code&gt; и &lt;code&gt;last&lt;/code&gt; (не более</target>
        </trans-unit>
        <trans-unit id="91c8ac1c75a7c617f2a0ac89cd3799820e4457ed" translate="yes" xml:space="preserve">
          <source>The number of digits between the &lt;code&gt;thousand-sep&lt;/code&gt;s (maximum size of &lt;code&gt;digits&lt;/code&gt;) is specified by the result of &lt;code&gt;&lt;a href=&quot;numpunct/grouping&quot;&gt;grouping()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Количество цифр между &lt;code&gt;thousand-sep&lt;/code&gt; секунд (максимальный размер &lt;code&gt;digits&lt;/code&gt; ) определяется результатом &lt;code&gt;&lt;a href=&quot;numpunct/grouping&quot;&gt;grouping()&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3f0b350cad560ae534bf63d3c358b99770cd98ec" translate="yes" xml:space="preserve">
          <source>The number of digits to be displayed after the decimal point. In common U.S. locales, this is the value &lt;code&gt;2&lt;/code&gt;.</source>
          <target state="translated">Количество цифр, отображаемых после десятичной точки. В распространенных регионах США это значение равно &lt;code&gt;2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c33eec86884077ae614b5177f47626b4225aee87" translate="yes" xml:space="preserve">
          <source>The number of elements in &lt;code&gt;Ints&lt;/code&gt;.</source>
          <target state="translated">Количество элементов в &lt;code&gt;Ints&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8b450587ddfddf28cae24e2b30442386956861df" translate="yes" xml:space="preserve">
          <source>The number of elements in the bucket &lt;code&gt;n&lt;/code&gt;.</source>
          <target state="translated">Количество элементов в ведре &lt;code&gt;n&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fa1ca4d47e01f9e18e5e6074af9cfd49cb03a9d8" translate="yes" xml:space="preserve">
          <source>The number of elements in the container.</source>
          <target state="translated">Количество элементов в контейнере.</target>
        </trans-unit>
        <trans-unit id="68853860c0d5a8f06c3b286e4f1020c334bca256" translate="yes" xml:space="preserve">
          <source>The number of elements in the span.</source>
          <target state="translated">Количество элементов в пролете.</target>
        </trans-unit>
        <trans-unit id="20396f56c8e3a0c13e5e36b7f2622f3b64ae5d64" translate="yes" xml:space="preserve">
          <source>The number of elements removed.</source>
          <target state="translated">Количество удаленных элементов.</target>
        </trans-unit>
        <trans-unit id="57b03f33847e8f2cd5650b62940211a1dd591b64" translate="yes" xml:space="preserve">
          <source>The number of hard links for &lt;code&gt;p&lt;/code&gt;.</source>
          <target state="translated">Количество жестких ссылок для &lt;code&gt;p&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cce184fd3e4e941c3606117950b45af922d77f66" translate="yes" xml:space="preserve">
          <source>The number of hard links for the referred-to filesystem object.</source>
          <target state="translated">Количество жестких ссылок на объект файловой системы.</target>
        </trans-unit>
        <trans-unit id="61f0b12e8e21833dacb834088dec03bd1d45a5bc" translate="yes" xml:space="preserve">
          <source>The number of increments needed to go from &lt;code&gt;first&lt;/code&gt; to &lt;code&gt;last&lt;/code&gt;. The value may be negative if random-access iterators are used and &lt;code&gt;first&lt;/code&gt; is reachable from &lt;code&gt;last&lt;/code&gt;(since C++11).</source>
          <target state="translated">Количество приращений, необходимое для перехода от &lt;code&gt;first&lt;/code&gt; к &lt;code&gt;last&lt;/code&gt; . Значение может быть отрицательным, если используются итераторы с произвольным доступом, и &lt;code&gt;first&lt;/code&gt; доступен из &lt;code&gt;last&lt;/code&gt; (начиная с C ++ 11).</target>
        </trans-unit>
        <trans-unit id="50988967f711f6f1b94fadc8faa1c4123b2c14c3" translate="yes" xml:space="preserve">
          <source>The number of marked sub-expressions within the regular expression.</source>
          <target state="translated">Количество помеченных подвыражений в регулярном выражении.</target>
        </trans-unit>
        <trans-unit id="c70fa04485fef696ceac1a34cbd7f1b495aed9ee" translate="yes" xml:space="preserve">
          <source>The number of submatches.</source>
          <target state="translated">Количество субматчей.</target>
        </trans-unit>
        <trans-unit id="d956e6449331c6b04b931088c9ef0870fa076aa0" translate="yes" xml:space="preserve">
          <source>The number of ticks for this duration.</source>
          <target state="translated">Количество тиков за эту продолжительность.</target>
        </trans-unit>
        <trans-unit id="d4eed26281a1ccba1c3fbe30a41dad631fb16096" translate="yes" xml:space="preserve">
          <source>The numbers that are supported by &lt;code&gt;std::numpunct&lt;/code&gt; have the format described below. Here &lt;code&gt;digit&lt;/code&gt; represents the radix set specified by the &lt;code&gt;fmtflags&lt;/code&gt; argument value, &lt;code&gt;thousands-sep&lt;/code&gt; and &lt;code&gt;decimal-point&lt;/code&gt; are the results of &lt;code&gt;&lt;a href=&quot;numpunct/thousands_sep&quot;&gt;thousands_sep()&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;numpunct/decimal_point&quot;&gt;decimal_point()&lt;/a&gt;&lt;/code&gt; functions respectively. The format of integer values is as follows:</source>
          <target state="translated">Числа, которые поддерживаются &lt;code&gt;std::numpunct&lt;/code&gt; имеют формат, описанный ниже. Здесь &lt;code&gt;digit&lt;/code&gt; представляет набор базисного , заданный &lt;code&gt;fmtflags&lt;/code&gt; значения аргумента, &lt;code&gt;thousands-sep&lt;/code&gt; и &lt;code&gt;decimal-point&lt;/code&gt; являются результатами &lt;code&gt;&lt;a href=&quot;numpunct/thousands_sep&quot;&gt;thousands_sep()&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;numpunct/decimal_point&quot;&gt;decimal_point()&lt;/a&gt;&lt;/code&gt; функция соответственно. Формат целочисленных значений следующий:</target>
        </trans-unit>
        <trans-unit id="9bab7274b85a85fa328c276ae190e2933c1da232" translate="yes" xml:space="preserve">
          <source>The numeric input overloads of &lt;a href=&quot;../basic_istream/operator_gtgt&quot;&gt;&lt;code&gt;basic_istream::operator&amp;gt;&amp;gt;&lt;/code&gt;&lt;/a&gt; if the end of the stream was encountered while reading the next character, on Stage 2 of &lt;a href=&quot;../../locale/num_get/get&quot;&gt;&lt;code&gt;num_get::get&lt;/code&gt;&lt;/a&gt; processing. Depending on the parsing state, &lt;code&gt;failbit&lt;/code&gt; may or may not be set at the same time: for example, &lt;code&gt;int n; istringstream buf(&quot;1&quot;); buf &amp;gt;&amp;gt; n;&lt;/code&gt; sets &lt;code&gt;eofbit&lt;/code&gt;, but not &lt;code&gt;failbit&lt;/code&gt;: the integer &lt;code&gt;1&lt;/code&gt; was successfully parsed and stored in &lt;code&gt;n&lt;/code&gt;. On the other hand, &lt;code&gt;bool b; istringstream buf(&quot;tr&quot;); buf &amp;gt;&amp;gt; boolalpha &amp;gt;&amp;gt; b;&lt;/code&gt; sets both &lt;code&gt;eofbit&lt;/code&gt; and &lt;code&gt;failbit&lt;/code&gt;: there was not enough characters to complete the parsing of the boolean &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">Числовой ввод перегружает &lt;a href=&quot;../basic_istream/operator_gtgt&quot;&gt; &lt;code&gt;basic_istream::operator&amp;gt;&amp;gt;&lt;/code&gt; &lt;/a&gt; если при чтении следующего символа был обнаружен конец потока, на этапе 2 обработки &lt;a href=&quot;../../locale/num_get/get&quot;&gt; &lt;code&gt;num_get::get&lt;/code&gt; &lt;/a&gt; . В зависимости от состояния синтаксического анализа, &lt;code&gt;failbit&lt;/code&gt; может быть или не быть установлен одновременно: например, &lt;code&gt;int n; istringstream buf(&quot;1&quot;); buf &amp;gt;&amp;gt; n;&lt;/code&gt; устанавливает &lt;code&gt;eofbit&lt;/code&gt; , но не &lt;code&gt;failbit&lt;/code&gt; : целое число &lt;code&gt;1&lt;/code&gt; было успешно проанализировано и сохранено в &lt;code&gt;n&lt;/code&gt; . С другой стороны, &lt;code&gt;bool b; istringstream buf(&quot;tr&quot;); buf &amp;gt;&amp;gt; boolalpha &amp;gt;&amp;gt; b;&lt;/code&gt; устанавливает как &lt;code&gt;eofbit&lt;/code&gt; ,так и &lt;code&gt;failbit&lt;/code&gt; : не хватило символов, чтобы завершить разбор логической &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1d4dfe124ae3866d608f524aa57220b740c6faaa" translate="yes" xml:space="preserve">
          <source>The numeric value if &lt;code&gt;ch&lt;/code&gt; indeed represents a digit in the currently imbued locale that is valid for the numeric base &lt;code&gt;radix&lt;/code&gt;, or &lt;code&gt;-1&lt;/code&gt; on error.</source>
          <target state="translated">Числовое значение , если &lt;code&gt;ch&lt;/code&gt; действительно представляет собой цифру в настоящее время пропитано локал, которая действительна для цифрового базовой системы &lt;code&gt;radix&lt;/code&gt; , или &lt;code&gt;-1&lt;/code&gt; в случае ошибки.</target>
        </trans-unit>
        <trans-unit id="cea1f54bd02da8f425b152ab8d2a7f0fbeca2475" translate="yes" xml:space="preserve">
          <source>The numeric, pointer, and boolean input overloads of &lt;a href=&quot;../basic_istream/operator_gtgt&quot;&gt;&lt;code&gt;basic_istream::operator&amp;gt;&amp;gt;&lt;/code&gt;&lt;/a&gt; (technically, the overloads of &lt;a href=&quot;../../locale/num_get/get&quot;&gt;&lt;code&gt;num_get::get&lt;/code&gt;&lt;/a&gt; they call), if the input cannot be parsed as a valid value or if the value parsed does not fit in the destination type.</source>
          <target state="translated">&lt;a href=&quot;../basic_istream/operator_gtgt&quot;&gt; &lt;code&gt;basic_istream::operator&amp;gt;&amp;gt;&lt;/code&gt; &lt;/a&gt; , указательные и логические входные перегрузки для basic_istream :: operator &amp;gt;&amp;gt; (технически это перегрузки &lt;a href=&quot;../../locale/num_get/get&quot;&gt; &lt;code&gt;num_get::get&lt;/code&gt; &lt;/a&gt; они вызывают), если вход не может быть проанализирован как допустимое значение или если проанализированное значение не помещается в тип назначения.</target>
        </trans-unit>
        <trans-unit id="0220d8c40333a0093943bf969db90f89079c2dd9" translate="yes" xml:space="preserve">
          <source>The object</source>
          <target state="translated">Объект</target>
        </trans-unit>
        <trans-unit id="984c0e6a80490ef643982434d691b02d8e724169" translate="yes" xml:space="preserve">
          <source>The object &lt;code&gt;u&lt;/code&gt; is &lt;a href=&quot;../language/default_initialization&quot;&gt;default-initialized&lt;/a&gt;</source>
          <target state="translated">Объект &lt;code&gt;u&lt;/code&gt; является по &lt;a href=&quot;../language/default_initialization&quot;&gt;умолчанию инициализируется&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="60fdf35addca2d2e61228bbe293b020ce2b060c9" translate="yes" xml:space="preserve">
          <source>The object &lt;code&gt;u&lt;/code&gt; is &lt;a href=&quot;../language/value_initialization&quot;&gt;value-initialized&lt;/a&gt; or &lt;a href=&quot;../language/aggregate_initialization&quot;&gt;aggregate-initialized&lt;/a&gt;.</source>
          <target state="translated">Объект &lt;code&gt;u&lt;/code&gt; является &lt;a href=&quot;../language/value_initialization&quot;&gt;значение инициализирован&lt;/a&gt; или &lt;a href=&quot;../language/aggregate_initialization&quot;&gt;агрегатно-инициализирован&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d66e0c5c8edf403a2575eab1d9bd1a5f03140bf4" translate="yes" xml:space="preserve">
          <source>The object created by a new-expression is initialized according to the following rules:</source>
          <target state="translated">Объект,созданный новым выражением,инициализируется по следующим правилам:</target>
        </trans-unit>
        <trans-unit id="6a3691e4261c0727fb8c31da0443f64d25b8f791" translate="yes" xml:space="preserve">
          <source>The object denoted by the glvalue is not accessed if:</source>
          <target state="translated">Объект,обозначенный значением клея,не доступен,если:</target>
        </trans-unit>
        <trans-unit id="25231b05a1580da27ff890c7619a820a11b0eb7b" translate="yes" xml:space="preserve">
          <source>The object is default-initialized.</source>
          <target state="translated">Объект по умолчанию инициализирован.</target>
        </trans-unit>
        <trans-unit id="43048e7b920911676623be86d837ae144bd2a9c0" translate="yes" xml:space="preserve">
          <source>The object is destroyed using &lt;a href=&quot;../language/delete&quot;&gt;&lt;code&gt;delete-expression&lt;/code&gt;&lt;/a&gt; or a custom deleter that is supplied to &lt;code&gt;shared_ptr&lt;/code&gt; during construction.</source>
          <target state="translated">Объект уничтожается с помощью &lt;a href=&quot;../language/delete&quot;&gt; &lt;code&gt;delete-expression&lt;/code&gt; &lt;/a&gt; или пользовательского удалителя, который передается в &lt;code&gt;shared_ptr&lt;/code&gt; во время построения.</target>
        </trans-unit>
        <trans-unit id="ff26c6e45a2e565960b0a55f98032b59b34935b9" translate="yes" xml:space="preserve">
          <source>The object is disposed of using a potentially user-supplied deleter by calling &lt;code&gt;get_deleter()(ptr)&lt;/code&gt;. The default deleter uses the &lt;code&gt;delete&lt;/code&gt; operator, which destroys the object and deallocates the memory.</source>
          <target state="translated">Объект удаляется с помощью потенциально предоставленного пользователем средства удаления, вызывая &lt;code&gt;get_deleter()(ptr)&lt;/code&gt; . Средство &lt;code&gt;delete&lt;/code&gt; умолчанию использует оператор удаления , который уничтожает объект и освобождает память.</target>
        </trans-unit>
        <trans-unit id="3d70e838df487033e13d3e82fefeabf6dda9f65a" translate="yes" xml:space="preserve">
          <source>The object is disposed of using the associated deleter when either of the following happens:</source>
          <target state="translated">Объект избавляется от использования связанного с ним удалителя,когда происходит одно из следующих событий:</target>
        </trans-unit>
        <trans-unit id="6079965a1e8cbec0fa1c764e9dc6325a1f66300d" translate="yes" xml:space="preserve">
          <source>The object is initialized with/assigned from a value of type &lt;code&gt;&lt;a href=&quot;optional/nullopt_t&quot;&gt;std::nullopt_t&lt;/a&gt;&lt;/code&gt; or an &lt;code&gt;optional&lt;/code&gt; object that</source>
          <target state="translated">Объект инициализируется / присваивается из значения типа &lt;code&gt;&lt;a href=&quot;optional/nullopt_t&quot;&gt;std::nullopt_t&lt;/a&gt;&lt;/code&gt; или &lt;code&gt;optional&lt;/code&gt; объекта, который</target>
        </trans-unit>
        <trans-unit id="2eb07629fc5eb59fd1eeea479f34c50d51c4b7cf" translate="yes" xml:space="preserve">
          <source>The object is initialized with/assigned from a value of type &lt;code&gt;T&lt;/code&gt; or another &lt;code&gt;optional&lt;/code&gt; that</source>
          <target state="translated">Объект инициализируется / выделено из значения типа &lt;code&gt;T&lt;/code&gt; или другой &lt;code&gt;optional&lt;/code&gt; , что</target>
        </trans-unit>
        <trans-unit id="106e7472fad2690d4a66e2210e0161c76f0e3d6c" translate="yes" xml:space="preserve">
          <source>The object of type &lt;a href=&quot;../money_base&quot;&gt;&lt;code&gt;std::money_base::format&lt;/code&gt;&lt;/a&gt; describing the formatting used by this locale.</source>
          <target state="translated">Объект типа &lt;a href=&quot;../money_base&quot;&gt; &lt;code&gt;std::money_base::format&lt;/code&gt; &lt;/a&gt; описывающий форматирование, используемое этой локалью.</target>
        </trans-unit>
        <trans-unit id="a2654facce30fa17d2f2a6f53431efdc1fad3b19" translate="yes" xml:space="preserve">
          <source>The object of type &lt;code&gt;&lt;a href=&quot;../../string/basic_string&quot;&gt;std::string&lt;/a&gt;&lt;/code&gt; holding the groups. The standard specializations of &lt;code&gt;std::moneypunct&lt;/code&gt; return an empty string, indicating no grouping. Typical groupings (e.g. the &lt;code&gt;en_US&lt;/code&gt; locale) return &lt;code&gt;&quot;\003&quot;&lt;/code&gt;.</source>
          <target state="translated">Объект типа &lt;code&gt;&lt;a href=&quot;../../string/basic_string&quot;&gt;std::string&lt;/a&gt;&lt;/code&gt; содержащий группы. Стандартные специализации &lt;code&gt;std::moneypunct&lt;/code&gt; возвращают пустую строку, что указывает на отсутствие группировки. Типичные группы (например, локаль &lt;code&gt;en_US&lt;/code&gt; ) возвращают &lt;code&gt;&quot;\003&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2953e9f8be35412309323e09c4560896f13bada8" translate="yes" xml:space="preserve">
          <source>The object of type &lt;code&gt;&lt;a href=&quot;../../string/basic_string&quot;&gt;std::string&lt;/a&gt;&lt;/code&gt; holding the groups. The standard specializations of &lt;code&gt;std::numpunct&lt;/code&gt; return an empty string, indicating no grouping. Typical groupings (e.g. the &lt;code&gt;en_US&lt;/code&gt; locale) return &lt;code&gt;&quot;\003&quot;&lt;/code&gt;.</source>
          <target state="translated">Объект типа &lt;code&gt;&lt;a href=&quot;../../string/basic_string&quot;&gt;std::string&lt;/a&gt;&lt;/code&gt; содержащий группы. Стандартные специализации &lt;code&gt;std::numpunct&lt;/code&gt; возвращают пустую строку, что указывает на отсутствие группировки. Типичные группы (например, локаль &lt;code&gt;en_US&lt;/code&gt; ) возвращают &lt;code&gt;&quot;\003&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9f2911ed4a3e7e4e904c59b8350c8e9466228f6c" translate="yes" xml:space="preserve">
          <source>The object of type &lt;code&gt;CharT&lt;/code&gt; holding the decimal point character.</source>
          <target state="translated">Объект типа &lt;code&gt;CharT&lt;/code&gt; , содержащий символ десятичной точки.</target>
        </trans-unit>
        <trans-unit id="4f95c2c5399637a34a9ee8645410f77e300b41a0" translate="yes" xml:space="preserve">
          <source>The object of type &lt;code&gt;char_type&lt;/code&gt; to use as the thousands separator. In common U.S. locales, this is &lt;code&gt;','&lt;/code&gt; or &lt;code&gt;L','&lt;/code&gt;.</source>
          <target state="translated">Объект типа &lt;code&gt;char_type&lt;/code&gt; для использования в качестве разделителя тысяч. В распространенных регионах США это &lt;code&gt;','&lt;/code&gt; или &lt;code&gt;L','&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="80bb88b1b4433caf62a715152b1b50f8ad2b9e79" translate="yes" xml:space="preserve">
          <source>The object of type &lt;code&gt;char_type&lt;/code&gt; to use as the thousands separator. The standard specializations of &lt;code&gt;std::numpunct&lt;/code&gt; return &lt;code&gt;','&lt;/code&gt; and &lt;code&gt;L','&lt;/code&gt;.</source>
          <target state="translated">Объект типа &lt;code&gt;char_type&lt;/code&gt; для использования в качестве разделителя тысяч. Стандартные специализации &lt;code&gt;std::numpunct&lt;/code&gt; возвращают &lt;code&gt;','&lt;/code&gt; и &lt;code&gt;L','&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a260dce16a0baabc887328041b098cae9e79f602" translate="yes" xml:space="preserve">
          <source>The object of type &lt;code&gt;string_type&lt;/code&gt; holding the currency symbol or code.</source>
          <target state="translated">Объект типа &lt;code&gt;string_type&lt;/code&gt; , содержащий символ валюты или код.</target>
        </trans-unit>
        <trans-unit id="16c53b267fd0abe28bee8b120878e85d544083a4" translate="yes" xml:space="preserve">
          <source>The object or the type declared by such a declaration will have its &lt;a href=&quot;objects#Alignment&quot;&gt;alignment requirement&lt;/a&gt; equal to the strictest (largest) non-zero expression of all &lt;code&gt;alignas&lt;/code&gt; specifiers used in the declaration, unless it would weaken the natural alignment of the type.</source>
          <target state="translated">У объекта или типа, объявленного таким объявлением, будет &lt;a href=&quot;objects#Alignment&quot;&gt;требование выравнивания,&lt;/a&gt; равное строжайшему (наибольшему) ненулевому выражению из всех &lt;code&gt;alignas&lt;/code&gt; используемых в объявлении, если только это не ослабит естественное выравнивание типа.</target>
        </trans-unit>
        <trans-unit id="50b34d11b1100c8ed664baedbf8283fc21bb891d" translate="yes" xml:space="preserve">
          <source>The objects are locked by an unspecified series of calls to &lt;code&gt;lock&lt;/code&gt;, &lt;code&gt;try_lock&lt;/code&gt;, and &lt;code&gt;unlock&lt;/code&gt;. If a call to &lt;code&gt;lock&lt;/code&gt; or &lt;code&gt;unlock&lt;/code&gt; results in an exception, &lt;code&gt;unlock&lt;/code&gt; is called for any locked objects before rethrowing.</source>
          <target state="translated">Объекты блокируются неопределенной серией вызовов &lt;code&gt;lock&lt;/code&gt; , &lt;code&gt;try_lock&lt;/code&gt; и &lt;code&gt;unlock&lt;/code&gt; . Если вызов &lt;code&gt;lock&lt;/code&gt; или &lt;code&gt;unlock&lt;/code&gt; приводит к исключению, &lt;code&gt;unlock&lt;/code&gt; вызывается для любых заблокированных объектов перед повторным выбросом.</target>
        </trans-unit>
        <trans-unit id="833b82da6caa8dd8aeb20cf9477fe5f85be57f81" translate="yes" xml:space="preserve">
          <source>The objects created by new-expressions (objects with dynamic storage duration) persist until the pointer returned by the new-expression is used in a matching &lt;a href=&quot;delete&quot;&gt;delete-expression&lt;/a&gt;. If the original value of pointer is lost, the object becomes unreachable and cannot be deallocated: a</source>
          <target state="translated">Объекты, созданные с помощью новых выражений (объекты с динамической продолжительностью хранения), сохраняются до тех пор, пока указатель, возвращаемый новым выражением, не будет использован в соответствующем &lt;a href=&quot;delete&quot;&gt;выражении удаления&lt;/a&gt; . Если исходное значение указателя потеряно, объект становится недоступным и не может быть освобожден: a</target>
        </trans-unit>
        <trans-unit id="b2967e2fb3ae07f3f5e3a1fec435ab589fa1f55b" translate="yes" xml:space="preserve">
          <source>The objects may overlap: copying takes place as if the characters were copied to a temporary character array and then the characters were copied from the array to &lt;code&gt;dest&lt;/code&gt;.</source>
          <target state="translated">Объекты могут перекрываться: копирование происходит так, как если бы символы были скопированы во временный массив символов, а затем символы были скопированы из массива в &lt;code&gt;dest&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2a17a553ce0d57587be0e8416824c075ef07c922" translate="yes" xml:space="preserve">
          <source>The obtained character on success or &lt;code&gt;&lt;a href=&quot;../c&quot;&gt;EOF&lt;/a&gt;&lt;/code&gt; on failure.</source>
          <target state="translated">Полученный персонаж в случае успеха или &lt;code&gt;&lt;a href=&quot;../c&quot;&gt;EOF&lt;/a&gt;&lt;/code&gt; в случае неудачи.</target>
        </trans-unit>
        <trans-unit id="04be47c26eb26c26238109edcd20d6d4d1bb0dc8" translate="yes" xml:space="preserve">
          <source>The obtained wide character or &lt;code&gt;WEOF&lt;/code&gt; if an error has occurred or the end of file reached.</source>
          <target state="translated">Полученный широкий символ или &lt;code&gt;WEOF&lt;/code&gt; , если произошла ошибка или достигнут конец файла.</target>
        </trans-unit>
        <trans-unit id="2110df2bf8befabdd98eb59b3910b478af8f2dcc" translate="yes" xml:space="preserve">
          <source>The official document on Feature Test Recommendations</source>
          <target state="translated">Официальный документ о рекомендациях по тестированию характеристик</target>
        </trans-unit>
        <trans-unit id="f708415e16cfe9e7bf1990f786292e4c9e381ac6" translate="yes" xml:space="preserve">
          <source>The offset of the first member of a standard-layout type is always zero (&lt;a href=&quot;../language/ebo&quot;&gt;empty-base optimization&lt;/a&gt; is mandatory).</source>
          <target state="translated">Смещение первого члена типа стандартного макета всегда равно нулю ( &lt;a href=&quot;../language/ebo&quot;&gt;оптимизация пустой базы&lt;/a&gt; обязательна).</target>
        </trans-unit>
        <trans-unit id="607857504a9e70bca8a47464af6277ec197d69cc" translate="yes" xml:space="preserve">
          <source>The old value of &lt;code&gt;obj&lt;/code&gt;.</source>
          <target state="translated">Старое значение &lt;code&gt;obj&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3d886bb54edd589fbd6ce35fc4f8d5d2fed63519" translate="yes" xml:space="preserve">
          <source>The only data stored in a &lt;code&gt;duration&lt;/code&gt; is a tick count of type &lt;code&gt;Rep&lt;/code&gt;. If &lt;code&gt;Rep&lt;/code&gt; is floating point, then the &lt;code&gt;duration&lt;/code&gt; can represent fractions of ticks. &lt;code&gt;Period&lt;/code&gt; is included as part of the duration's type, and is only used when converting between different durations.</source>
          <target state="translated">Единственными данными, хранящимися в &lt;code&gt;duration&lt;/code&gt; является число тиков типа &lt;code&gt;Rep&lt;/code&gt; . Если &lt;code&gt;Rep&lt;/code&gt; - это число с плавающей запятой, то &lt;code&gt;duration&lt;/code&gt; может представлять собой доли тиков. &lt;code&gt;Period&lt;/code&gt; включается как часть типа длительности и используется только при преобразовании между разными длительностями.</target>
        </trans-unit>
        <trans-unit id="b2218d6760efda73de78e40ceb5f652b71248a9b" translate="yes" xml:space="preserve">
          <source>The only difference between &lt;code&gt;std::nearbyint&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;rint&quot;&gt;std::rint&lt;/a&gt;&lt;/code&gt; is that &lt;code&gt;std::nearbyint&lt;/code&gt; never raises &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INEXACT&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Единственное различие между &lt;code&gt;std::nearbyint&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;rint&quot;&gt;std::rint&lt;/a&gt;&lt;/code&gt; состоит в том, что &lt;code&gt;std::nearbyint&lt;/code&gt; никогда не вызывает &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INEXACT&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="50d45e1a42306e63fbd2dd995b7cef21bbf82264" translate="yes" xml:space="preserve">
          <source>The only difference between &lt;code&gt;std::rint&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;nearbyint&quot;&gt;std::nearbyint&lt;/a&gt;&lt;/code&gt; is that &lt;code&gt;&lt;a href=&quot;nearbyint&quot;&gt;std::nearbyint&lt;/a&gt;&lt;/code&gt; never raises &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INEXACT&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Единственная разница между &lt;code&gt;std::rint&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;nearbyint&quot;&gt;std::nearbyint&lt;/a&gt;&lt;/code&gt; заключается в том, что &lt;code&gt;&lt;a href=&quot;nearbyint&quot;&gt;std::nearbyint&lt;/a&gt;&lt;/code&gt; никогда не вызывает &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INEXACT&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fb56d0a76a6c53bff26b5b866f1ad038bed2665b" translate="yes" xml:space="preserve">
          <source>The only exceptions are that non-type template parameters of</source>
          <target state="translated">Единственным исключением является то,что нетипные параметры шаблонов для</target>
        </trans-unit>
        <trans-unit id="f6e8829ff8f2f1e7710d51780b5775f091279131" translate="yes" xml:space="preserve">
          <source>The only specifier that is allowed to appear twice in a decl-specifier-seq is &lt;code&gt;long&lt;/code&gt; (which can appear twice). All other repeats, such as &lt;code&gt;const static const&lt;/code&gt;, or &lt;code&gt;virtual inline virtual&lt;/code&gt; are errors.</source>
          <target state="translated">Единственный спецификатор, которому разрешено появляться дважды в decl-specier-seq, это &lt;code&gt;long&lt;/code&gt; (который может появляться дважды). Все остальные повторения, такие как &lt;code&gt;const static const&lt;/code&gt; или &lt;code&gt;virtual inline virtual&lt;/code&gt; , являются ошибками.</target>
        </trans-unit>
        <trans-unit id="776dd59d6ff8d1a9ef4d3f03ca55cae7469eb4a0" translate="yes" xml:space="preserve">
          <source>The only specifiers allowed in the decl-specifier-seq of a constructor declaration are &lt;a href=&quot;friend&quot;&gt;friend&lt;/a&gt;, &lt;a href=&quot;inline&quot;&gt;inline&lt;/a&gt;, &lt;code&gt;explicit&lt;/code&gt; and &lt;code&gt;constexpr&lt;/code&gt; (in particular, no return type is allowed). Note that &lt;a href=&quot;member_functions&quot;&gt;cv- and ref-qualifiers&lt;/a&gt; are not allowed either; const and volatile semantics of an object under construction don't kick in until the most-derived constructor completes.</source>
          <target state="translated">Единственные спецификаторы, разрешенные в decl-specier-seq объявления конструктора, это &lt;a href=&quot;friend&quot;&gt;friend&lt;/a&gt; , &lt;a href=&quot;inline&quot;&gt;inline&lt;/a&gt; , &lt;code&gt;explicit&lt;/code&gt; и &lt;code&gt;constexpr&lt;/code&gt; (в частности, тип возврата не допускается). Обратите внимание, что &lt;a href=&quot;member_functions&quot;&gt;cv- и ref-квалификаторы&lt;/a&gt; также не допускаются; константная и изменчивая семантика строящегося объекта не включается до тех пор, пока не завершится самый производный конструктор.</target>
        </trans-unit>
        <trans-unit id="d61491cad2b2617e213366873d893b816a75646e" translate="yes" xml:space="preserve">
          <source>The only standard &lt;code&gt;&lt;a href=&quot;../../atomic/atomic&quot;&gt;std::atomic&lt;/a&gt;&lt;/code&gt; member constant &lt;code&gt;is_always_lock_free&lt;/code&gt; is also provided by this specialization.</source>
          <target state="translated">Единственная стандартная константа-член &lt;code&gt;&lt;a href=&quot;../../atomic/atomic&quot;&gt;std::atomic&lt;/a&gt;&lt;/code&gt; &lt;code&gt;is_always_lock_free&lt;/code&gt; также предоставляется этой специализацией.</target>
        </trans-unit>
        <trans-unit id="b892e85a0c7fdd49003290d933695bc0a6e29fec" translate="yes" xml:space="preserve">
          <source>The only standard library components that throw this exception are &lt;code&gt;&lt;a href=&quot;../../locale/wstring_convert/from_bytes&quot;&gt;std::wstring_convert::from_bytes&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../../locale/wstring_convert/to_bytes&quot;&gt;std::wstring_convert::to_bytes&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Единственными стандартными компонентами библиотеки, которые &lt;code&gt;&lt;a href=&quot;../../locale/wstring_convert/from_bytes&quot;&gt;std::wstring_convert::from_bytes&lt;/a&gt;&lt;/code&gt; это исключение, являются std :: wstring_convert :: from_bytes и &lt;code&gt;&lt;a href=&quot;../../locale/wstring_convert/to_bytes&quot;&gt;std::wstring_convert::to_bytes&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c2e814e1afd8365ad73dca6904c0b4c6f214183c" translate="yes" xml:space="preserve">
          <source>The only standard library components that throw this exception are &lt;code&gt;&lt;a href=&quot;../../utility/bitset/to_ulong&quot;&gt;std::bitset::to_ulong&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../../utility/bitset/to_ullong&quot;&gt;std::bitset::to_ullong&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Единственными стандартными компонентами библиотеки, которые &lt;code&gt;&lt;a href=&quot;../../utility/bitset/to_ulong&quot;&gt;std::bitset::to_ulong&lt;/a&gt;&lt;/code&gt; это исключение, являются std :: bitset :: to_ulong и &lt;code&gt;&lt;a href=&quot;../../utility/bitset/to_ullong&quot;&gt;std::bitset::to_ullong&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a3648d0d11e1d50129adc447f795d03447db5902" translate="yes" xml:space="preserve">
          <source>The only trivially copyable types are scalar types, trivially copyable classes, and arrays of such types/classes (possibly const-qualified, but not volatile-qualified).</source>
          <target state="translated">Единственными тривиально копируемыми типами являются скалярные типы,тривиально копируемые классы и массивы таких типов/классов (возможно,const-qualified,но не volatile-qualified).</target>
        </trans-unit>
        <trans-unit id="b25a51f5e3f4b6ece2ce4ed04dda4a2b91159629" translate="yes" xml:space="preserve">
          <source>The only valid use of &lt;code&gt;operator*&lt;/code&gt; with an output iterator is on the left of an assignment: &lt;code&gt;operator*&lt;/code&gt; may return a proxy object, which defines a member &lt;code&gt;operator=&lt;/code&gt; (which may be a template).</source>
          <target state="translated">Единственное допустимое использование &lt;code&gt;operator*&lt;/code&gt; с выходным итератором - слева от присваивания: &lt;code&gt;operator*&lt;/code&gt; может возвращать прокси-объект, который определяет член &lt;code&gt;operator=&lt;/code&gt; (который может быть шаблоном).</target>
        </trans-unit>
        <trans-unit id="b9566ed81642e87a223297fba2ea3d2e3900b558" translate="yes" xml:space="preserve">
          <source>The only way to replace an allocator is copy-assignment, move-assignment, and swap:</source>
          <target state="translated">Единственный способ заменить аллокатор-это копирование,перемещение и обмен:</target>
        </trans-unit>
        <trans-unit id="d1f3d8e5a7c4ed4c1fad80ee519fc4a484fdc734" translate="yes" xml:space="preserve">
          <source>The operand expr of a built-in postfix increment or decrement operator must be a modifiable (non-const) &lt;a href=&quot;value_category&quot;&gt;lvalue&lt;/a&gt; of non-boolean arithmetic type or pointer to complete &lt;a href=&quot;type-id&quot;&gt;object type&lt;/a&gt;. The result is &lt;a href=&quot;value_category&quot;&gt;prvalue&lt;/a&gt; copy of the original value of the operand. As a side-effect, for non-boolean operands, the expression &lt;code&gt;x++&lt;/code&gt; modifies the value of its operand as if by evaluating &lt;code&gt;x += 1&lt;/code&gt;, and the expression &lt;code&gt;x--&lt;/code&gt; modifies the value of its operand as if by evaluating &lt;code&gt;x -= 1&lt;/code&gt;. All arithmetic conversion rules and pointer arithmetic rules defined for &lt;a href=&quot;operator_arithmetic&quot;&gt;arithmetic operators&lt;/a&gt; apply and determine the implicit conversion (if any) applied to the operand as well as the return type of the expression.</source>
          <target state="translated">Выражение операнда встроенного постфиксного оператора приращения или уменьшения должно быть изменяемым (неконстантным) &lt;a href=&quot;value_category&quot;&gt;l&lt;/a&gt; -значением не булева арифметического типа или указателем на полный &lt;a href=&quot;type-id&quot;&gt;тип объекта&lt;/a&gt; . Результатом является &lt;a href=&quot;value_category&quot;&gt;prvalue&lt;/a&gt; копия исходного значения операнда. В качестве побочного эффекта для небулевых операндов выражение &lt;code&gt;x++&lt;/code&gt; изменяет значение своего операнда как будто путем вычисления &lt;code&gt;x += 1&lt;/code&gt; , а выражение &lt;code&gt;x--&lt;/code&gt; изменяет значение своего операнда как будто путем вычисления &lt;code&gt;x -= 1&lt;/code&gt; , Все правила арифметического преобразования и арифметические правила указателя, определенные для &lt;a href=&quot;operator_arithmetic&quot;&gt;арифметических операторов&lt;/a&gt; применить и определить неявное преобразование (если оно есть), примененное к операнду, а также тип возвращаемого значения выражения.</target>
        </trans-unit>
        <trans-unit id="46362931546b6ab532aa0058b79c1a3e9f6e3d4e" translate="yes" xml:space="preserve">
          <source>The operand expr of a built-in prefix increment or decrement operator must be a modifiable (non-const) &lt;a href=&quot;value_category&quot;&gt;lvalue&lt;/a&gt; of non-boolean arithmetic type or pointer to complete &lt;a href=&quot;type-id&quot;&gt;object type&lt;/a&gt;. For non-boolean operands, the expression &lt;code&gt;++x&lt;/code&gt; is exactly equivalent to &lt;code&gt;x += 1&lt;/code&gt;, and the expression &lt;code&gt;--x&lt;/code&gt; is exactly equivalent to &lt;code&gt;x -= 1&lt;/code&gt;, that is, the prefix increment or decrement is an lvalue expression that identifies the modified operand. All arithmetic conversion rules and pointer arithmetic rules defined for &lt;a href=&quot;operator_arithmetic&quot;&gt;arithmetic operators&lt;/a&gt; apply and determine the implicit conversion (if any) applied to the operand as well as the return type of the expression.</source>
          <target state="translated">Выражение операнда встроенного префиксного оператора увеличения или уменьшения должно быть изменяемым (неконстантным) &lt;a href=&quot;value_category&quot;&gt;l&lt;/a&gt; -значением не-булева арифметического типа или указателем на полный &lt;a href=&quot;type-id&quot;&gt;тип объекта&lt;/a&gt; . Для не булевых операндов выражение &lt;code&gt;++x&lt;/code&gt; в точности эквивалентно &lt;code&gt;x += 1&lt;/code&gt; , а выражение &lt;code&gt;--x&lt;/code&gt; точно эквивалентно &lt;code&gt;x -= 1&lt;/code&gt; , то есть приращение или уменьшение префикса является выражением lvalue, которое идентифицирует модифицированный операнд. Все правила арифметического преобразования и арифметические правила указателя, определенные для &lt;a href=&quot;operator_arithmetic&quot;&gt;арифметических операторов,&lt;/a&gt; применяются и определяют неявное преобразование (если оно есть), применяемое к операнду, а также тип возврата выражения.</target>
        </trans-unit>
        <trans-unit id="87d402fbb54b3649a9536c28ce47e12a587d6550" translate="yes" xml:space="preserve">
          <source>The operand of &lt;code&gt;sizeof&lt;/code&gt; can't be a C-style type cast: the expression &lt;code&gt;sizeof (int) * p&lt;/code&gt; is unambiguously interpreted as &lt;code&gt;(sizeof(int)) * p&lt;/code&gt;, but not &lt;code&gt;sizeof((int)*p)&lt;/code&gt;.</source>
          <target state="translated">Операнд &lt;code&gt;sizeof&lt;/code&gt; не может быть приведением типа в стиле C: выражение &lt;code&gt;sizeof (int) * p&lt;/code&gt; однозначно интерпретируется как &lt;code&gt;(sizeof(int)) * p&lt;/code&gt; , но не &lt;code&gt;sizeof((int)*p)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="085c6a701b7e7a71f8bd49b79840a23c53c15e50" translate="yes" xml:space="preserve">
          <source>The operand of the built-in indirection operator must be pointer to object or a pointer to function, and the result is the lvalue referring to the pointer or function to which expr points.</source>
          <target state="translated">Операнд встроенного оператора индентификации должен быть указателем на объект или указателем на функцию,а результатом является lvalue,ссылающаяся на указатель или на функцию,на которую ссылаются точки экспрессии.</target>
        </trans-unit>
        <trans-unit id="a41ba177e9a175366d24e342abbe5cb594a72284" translate="yes" xml:space="preserve">
          <source>The operands of any operator may be other expressions or primary expressions (e.g. in &lt;code&gt;1+2*3&lt;/code&gt;, the operands of operator+ are the subexpression &lt;code&gt;2*3&lt;/code&gt; and the primary expression &lt;code&gt;1&lt;/code&gt;).</source>
          <target state="translated">Операндами любого оператора могут быть другие выражения или первичные выражения (например, в &lt;code&gt;1+2*3&lt;/code&gt; операнды оператора + являются подвыражением &lt;code&gt;2*3&lt;/code&gt; и первичным выражением &lt;code&gt;1&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="d012c764a34c8f374b29407cde1eb1fdbb47c2a6" translate="yes" xml:space="preserve">
          <source>The operands of the operators &lt;a href=&quot;typeid&quot;&gt;&lt;code&gt;typeid&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;sizeof&quot;&gt;&lt;code&gt;sizeof&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;noexcept&quot;&gt;&lt;code&gt;noexcept&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;decltype&quot;&gt;&lt;code&gt;decltype&lt;/code&gt;&lt;/a&gt;(since C++11) are expressions that are not evaluated (unless they are polymorphic glvalues and are the operands of &lt;code&gt;typeid&lt;/code&gt;), since these operators only query the compile-time properties of their operands. Thus, &lt;code&gt;&lt;a href=&quot;../types/size_t&quot;&gt;std::size_t&lt;/a&gt; n = sizeof(&lt;a href=&quot;../io/cout&quot;&gt;std::cout&lt;/a&gt; &amp;lt;&amp;lt; 42);&lt;/code&gt; does not perform console output.</source>
          <target state="translated">Операнды операторов &lt;a href=&quot;typeid&quot;&gt; &lt;code&gt;typeid&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;sizeof&quot;&gt; &lt;code&gt;sizeof&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;noexcept&quot;&gt; &lt;code&gt;noexcept&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;decltype&quot;&gt; &lt;code&gt;decltype&lt;/code&gt; &lt;/a&gt; (так как C ++ 11) является выражением, которые не оценивается (если они не являются полиморфным glvalues и операнды &lt;code&gt;typeid&lt;/code&gt; ), так как эти операторы запроса только свойств во время компиляции их операндов. Таким образом, &lt;code&gt;&lt;a href=&quot;../types/size_t&quot;&gt;std::size_t&lt;/a&gt; n = sizeof(&lt;a href=&quot;../io/cout&quot;&gt;std::cout&lt;/a&gt; &amp;lt;&amp;lt; 42);&lt;/code&gt; не выполняет вывод на консоль.</target>
        </trans-unit>
        <trans-unit id="85054a8ab24569b5d580787ed8730ffc9c0905a7" translate="yes" xml:space="preserve">
          <source>The operation behaves as though &lt;code&gt;&lt;a href=&quot;set_value&quot;&gt;set_value&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;set_exception&quot;&gt;set_exception&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;set_value_at_thread_exit&quot;&gt;set_value_at_thread_exit&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;set_exception_at_thread_exit&lt;/code&gt; acquire a single mutex associated with the promise object while updating the promise object.</source>
          <target state="translated">Операция ведет себя так, как будто &lt;code&gt;&lt;a href=&quot;set_value&quot;&gt;set_value&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;set_exception&quot;&gt;set_exception&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;set_value_at_thread_exit&quot;&gt;set_value_at_thread_exit&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;set_exception_at_thread_exit&lt;/code&gt; получают один мьютекс, связанный с объектом обещания, при обновлении объекта обещания.</target>
        </trans-unit>
        <trans-unit id="ff918beb1f805c40357e0f6201e33f727cf409ae" translate="yes" xml:space="preserve">
          <source>The operation behaves as though &lt;code&gt;&lt;a href=&quot;set_value&quot;&gt;set_value&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;set_exception&quot;&gt;set_exception&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;set_value_at_thread_exit&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;set_exception_at_thread_exit&quot;&gt;set_exception_at_thread_exit&lt;/a&gt;&lt;/code&gt; acquire a single mutex associated with the promise object while updating the promise object.</source>
          <target state="translated">Операция ведет себя так, как будто &lt;code&gt;&lt;a href=&quot;set_value&quot;&gt;set_value&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;set_exception&quot;&gt;set_exception&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;set_value_at_thread_exit&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;set_exception_at_thread_exit&quot;&gt;set_exception_at_thread_exit&lt;/a&gt;&lt;/code&gt; получают один мьютекс, связанный с объектом обещания, при обновлении объекта обещания.</target>
        </trans-unit>
        <trans-unit id="0dc1d1f6cd97262d10d4163c6f4669641d9589c9" translate="yes" xml:space="preserve">
          <source>The operation behaves as though &lt;code&gt;&lt;a href=&quot;set_value&quot;&gt;set_value&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;set_exception&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;set_value_at_thread_exit&quot;&gt;set_value_at_thread_exit&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;set_exception_at_thread_exit&quot;&gt;set_exception_at_thread_exit&lt;/a&gt;&lt;/code&gt; acquire a single mutex associated with the promise object while updating the promise object.</source>
          <target state="translated">Операция ведет себя так, как будто &lt;code&gt;&lt;a href=&quot;set_value&quot;&gt;set_value&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;set_exception&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;set_value_at_thread_exit&quot;&gt;set_value_at_thread_exit&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;set_exception_at_thread_exit&quot;&gt;set_exception_at_thread_exit&lt;/a&gt;&lt;/code&gt; получают один мьютекс, связанный с объектом обещания, при обновлении объекта обещания.</target>
        </trans-unit>
        <trans-unit id="894be649e20a0f667a76b29adef6436e4b7cbd04" translate="yes" xml:space="preserve">
          <source>The operation behaves as though &lt;code&gt;set_value&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;set_exception&quot;&gt;set_exception&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;set_value_at_thread_exit&quot;&gt;set_value_at_thread_exit&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;set_exception_at_thread_exit&quot;&gt;set_exception_at_thread_exit&lt;/a&gt;&lt;/code&gt; acquire a single mutex associated with the promise object while updating the promise object.</source>
          <target state="translated">Операция ведет себя так, как будто &lt;code&gt;set_value&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;set_exception&quot;&gt;set_exception&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;set_value_at_thread_exit&quot;&gt;set_value_at_thread_exit&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;set_exception_at_thread_exit&quot;&gt;set_exception_at_thread_exit&lt;/a&gt;&lt;/code&gt; получают один мьютекс, связанный с объектом обещания, при обновлении объекта обещания.</target>
        </trans-unit>
        <trans-unit id="ada6c00780096e7ea571132eafd7f86af9d8f166" translate="yes" xml:space="preserve">
          <source>The operation is performed as if the following is executed:</source>
          <target state="translated">Операция выполняется так,как будто выполняется следующее:</target>
        </trans-unit>
        <trans-unit id="9c665cf102b9a36a3c0f45e7d1968e4deab591b0" translate="yes" xml:space="preserve">
          <source>The operator &lt;code&gt;operator!&lt;/code&gt; is commonly overloaded by the user-defined classes that are intended to be used in boolean contexts. Such classes also provide a user-defined conversion function &lt;code&gt;explicit operator bool()&lt;/code&gt; (see &lt;code&gt;&lt;a href=&quot;../io/basic_ios&quot;&gt;std::basic_ios&lt;/a&gt;&lt;/code&gt; for the standard library example), and the expected behavior of &lt;code&gt;operator!&lt;/code&gt; is to return the value opposite of &lt;code&gt;operator bool&lt;/code&gt;.</source>
          <target state="translated">Оператор &lt;code&gt;operator!&lt;/code&gt; обычно перегружается пользовательскими классами, которые предназначены для использования в логических контекстах. Такие классы также предоставляют пользовательскую функцию преобразования, &lt;code&gt;explicit operator bool()&lt;/code&gt; (см. &lt;code&gt;&lt;a href=&quot;../io/basic_ios&quot;&gt;std::basic_ios&lt;/a&gt;&lt;/code&gt; для примера стандартной библиотеки) и ожидаемое поведение &lt;code&gt;operator!&lt;/code&gt; вернуть значение, противоположное &lt;code&gt;operator bool&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f80c851a7fa156f63455e4364c3b3e9685929eb0" translate="yes" xml:space="preserve">
          <source>The operators &lt;code&gt;::&lt;/code&gt; (scope resolution), &lt;code&gt;.&lt;/code&gt; (member access), &lt;code&gt;.*&lt;/code&gt; (member access through pointer to member), and &lt;code&gt;?:&lt;/code&gt; (ternary conditional) cannot be overloaded.</source>
          <target state="translated">Операторы &lt;code&gt;::&lt;/code&gt; (разрешение области видимости) &lt;code&gt;.&lt;/code&gt; (доступ к элементу),. &lt;code&gt;.*&lt;/code&gt; (доступ к элементу через указатель на член) и &lt;code&gt;?:&lt;/code&gt; (троичное условие) не может быть перегружен.</target>
        </trans-unit>
        <trans-unit id="aac712726a5efd650938a3acaadc33f6fc3919ae" translate="yes" xml:space="preserve">
          <source>The order of destruction of non-local variables is described in &lt;code&gt;&lt;a href=&quot;../utility/program/exit&quot;&gt;std::exit&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Порядок уничтожения нелокальных переменных описан в &lt;code&gt;&lt;a href=&quot;../utility/program/exit&quot;&gt;std::exit&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="35758388f82a3ab09aa2cb82071589277664456d" translate="yes" xml:space="preserve">
          <source>The order of equal elements is not guaranteed to be preserved. The order of the remaining elements in the range &lt;code&gt;[middle, last)&lt;/code&gt; is unspecified.</source>
          <target state="translated">Порядок равных элементов не гарантируется для сохранения. Порядок оставшихся элементов в диапазоне &lt;code&gt;[middle, last)&lt;/code&gt; не указан.</target>
        </trans-unit>
        <trans-unit id="8b4e996418f65beaf879b200f677d977522bbc6c" translate="yes" xml:space="preserve">
          <source>The order of member initializers in the list is irrelevant: the actual order of initialization is as follows:</source>
          <target state="translated">Порядок инициализаторов-участников в списке не имеет значения:фактический порядок инициализации следующий:</target>
        </trans-unit>
        <trans-unit id="4ee2462340320dfffdb2356e18adfc9d73dab60f" translate="yes" xml:space="preserve">
          <source>The order of the elements that are not erased is preserved. (This makes it possible to erase individual elements while iterating through the container.).</source>
          <target state="translated">Сохраняется порядок элементов,которые не стираются.(Это позволяет стирать отдельные элементы во время итерации через контейнер).</target>
        </trans-unit>
        <trans-unit id="45de463a3e1e66d3a48db307eb7e59ab651dcd8a" translate="yes" xml:space="preserve">
          <source>The order of the elements that compare equivalent is the order of insertion and does not change. (since C++11).</source>
          <target state="translated">Порядок элементов,которые сравнивают эквивалент,является порядком вставки и не изменяется.(начиная с С++11).</target>
        </trans-unit>
        <trans-unit id="abd27fd7960ecb4b3cee9ed3bc8fa827648946bf" translate="yes" xml:space="preserve">
          <source>The order of the key-value pairs whose keys compare equivalent is the order of insertion and does not change. (since C++11).</source>
          <target state="translated">Порядок пар ключ-значение,ключи которых сравнивают эквивалент,является порядком вставки и не изменяется.(начиная с C++11).</target>
        </trans-unit>
        <trans-unit id="a9ef10d36f3c0c975aa40ae381346f09fe5d7ab9" translate="yes" xml:space="preserve">
          <source>The ordering comparisons are done lexicographically -- the comparison is performed by a function equivalent to &lt;code&gt;&lt;a href=&quot;../../algorithm/lexicographical_compare&quot;&gt;std::lexicographical_compare&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Сравнение порядка выполняется лексикографически - сравнение выполняется функцией, эквивалентной &lt;code&gt;&lt;a href=&quot;../../algorithm/lexicographical_compare&quot;&gt;std::lexicographical_compare&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f0966d7161405c174477a1237dbe2bf1df99477d" translate="yes" xml:space="preserve">
          <source>The ordering is strict weak ordering relation.</source>
          <target state="translated">Заказ-это строгое слабое отношение к заказу.</target>
        </trans-unit>
        <trans-unit id="1f12ff5d7e6a675fd2031dd36912c9789309ddc9" translate="yes" xml:space="preserve">
          <source>The original intent of the &lt;code&gt;inline&lt;/code&gt; keyword was to serve as an indicator to the optimizer that &lt;a href=&quot;https://en.wikipedia.org/wiki/inline_expansion&quot;&gt;inline substitution of a function&lt;/a&gt; is preferred over function call, that is, instead of executing the function call CPU instruction to transfer control to the function body, a copy of the function body is executed without generating the call. This avoids overhead created by the function call (passing the arguments and retrieving the result) but it may result in a larger executable as the code for the function has to be repeated multiple times.</source>
          <target state="translated">Первоначальная цель ключевого слова &lt;code&gt;inline&lt;/code&gt; заключалась в том, чтобы служить оптимизатору индикатором того, что &lt;a href=&quot;https://en.wikipedia.org/wiki/inline_expansion&quot;&gt;внутреннее замещение функции&lt;/a&gt; предпочтительнее вызова функции, то есть вместо выполнения инструкции CPU вызова функции для передачи управления в тело функции, копия тело функции выполняется без генерации вызова. Это позволяет избежать накладных расходов, создаваемых вызовом функции (передача аргументов и получение результата), но это может привести к увеличению размера исполняемого файла, поскольку код функции должен повторяться несколько раз.</target>
        </trans-unit>
        <trans-unit id="083eed7b2639f184e8f8cd016a58c77c340553d1" translate="yes" xml:space="preserve">
          <source>The output iterator &lt;code&gt;std::raw_storage_iterator&lt;/code&gt; makes it possible for standard algorithms to store results in uninitialized memory. Whenever the algorithm writes an object of type &lt;code&gt;T&lt;/code&gt; to the dereferenced iterator, the object is copy-constructed into the location in the uninitialized storage pointed to by the iterator. The template parameter &lt;code&gt;OutputIt&lt;/code&gt; is any type that meets the requirements of &lt;a href=&quot;../named_req/outputiterator&quot;&gt;LegacyOutputIterator&lt;/a&gt; and has &lt;code&gt;operator*&lt;/code&gt; defined to return an object, for which &lt;code&gt;operator&amp;amp;&lt;/code&gt; returns an object of type &lt;code&gt;T*&lt;/code&gt;. Usually, the type &lt;code&gt;T*&lt;/code&gt; is used as &lt;code&gt;OutputIt&lt;/code&gt;.</source>
          <target state="translated">Итератор вывода &lt;code&gt;std::raw_storage_iterator&lt;/code&gt; позволяет стандартным алгоритмам сохранять результаты в неинициализированной памяти. Всякий раз, когда алгоритм записывает объект типа &lt;code&gt;T&lt;/code&gt; в разыменованный итератор, объект копируется в место в неинициализированном хранилище, на которое указывает итератор. Параметр шаблона &lt;code&gt;OutputIt&lt;/code&gt; - это любой тип, который соответствует требованиям &lt;a href=&quot;../named_req/outputiterator&quot;&gt;LegacyOutputIterator&lt;/a&gt; и имеет &lt;code&gt;operator*&lt;/code&gt; определенный для возврата объекта, для которого &lt;code&gt;operator&amp;amp;&lt;/code&gt; возвращает объект типа &lt;code&gt;T*&lt;/code&gt; . Обычно тип &lt;code&gt;T*&lt;/code&gt; используется как &lt;code&gt;OutputIt&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e482ce31b119d64121012b0392dad700a664ac70" translate="yes" xml:space="preserve">
          <source>The outputs of an expression consist of its result and all operands modified by the expression (if any).</source>
          <target state="translated">Выводы выражения состоят из его результата и всех операндов,измененных выражением (если таковые имеются).</target>
        </trans-unit>
        <trans-unit id="9c85e268da67030ad87455310612ee6e33a42e99" translate="yes" xml:space="preserve">
          <source>The overload (3) only participates in overload resolution if &lt;code&gt;Sseq&lt;/code&gt; qualifies as a &lt;a href=&quot;../../../named_req/seedsequence&quot;&gt;SeedSequence&lt;/a&gt;. In particular, it is excluded from the set of candidate functions if &lt;code&gt;Sseq&lt;/code&gt; is convertible to &lt;code&gt;result_type&lt;/code&gt;.</source>
          <target state="translated">Перегрузка (3) участвует только в разрешении перегрузки, если &lt;code&gt;Sseq&lt;/code&gt; квалифицируется как &lt;a href=&quot;../../../named_req/seedsequence&quot;&gt;SeedSequence&lt;/a&gt; . В частности, он исключается из набора функций-кандидатов, если &lt;code&gt;Sseq&lt;/code&gt; конвертируется в &lt;code&gt;result_type&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="06bb537d779118fbd7f2e14985ef313bb0e992d7" translate="yes" xml:space="preserve">
          <source>The overload (3) zeroes out elements of non-class types such as &lt;code&gt;int&lt;/code&gt;, which is different from the behavior of &lt;a href=&quot;../../language/new&quot;&gt;&lt;code&gt;new[]&lt;/code&gt;&lt;/a&gt;, which leaves them uninitialized. To match the behavior of &lt;code&gt;new[]&lt;/code&gt;, a &lt;a href=&quot;http://stackoverflow.com/a/21028912/273767&quot;&gt;custom Allocator::construct&lt;/a&gt; can be provided which leaves such elements uninitialized.</source>
          <target state="translated">Перегрузка (3) обнуляет элементы не классовых типов, таких как &lt;code&gt;int&lt;/code&gt; , что отличается от поведения &lt;a href=&quot;../../language/new&quot;&gt; &lt;code&gt;new[]&lt;/code&gt; &lt;/a&gt; , что оставляет их неинициализированными. Чтобы соответствовать поведению &lt;code&gt;new[]&lt;/code&gt; , можно предоставить &lt;a href=&quot;http://stackoverflow.com/a/21028912/273767&quot;&gt;пользовательскую конструкцию Allocator ::,&lt;/a&gt; которая оставляет такие элементы неинициализированными.</target>
        </trans-unit>
        <trans-unit id="b0d7a75e51aff3dfb39b338a8d075fab0f39ca24" translate="yes" xml:space="preserve">
          <source>The overload (3) zeroes out elements of non-class types such as &lt;code&gt;int&lt;/code&gt;, which is different from the behavior of &lt;a href=&quot;../../language/new&quot;&gt;&lt;code&gt;new[]&lt;/code&gt;&lt;/a&gt;, which leaves them uninitialized. To match the behavior of &lt;code&gt;new[]&lt;/code&gt;, a &lt;a href=&quot;https://stackoverflow.com/a/21028912/273767&quot;&gt;custom Allocator::construct&lt;/a&gt; can be provided which leaves such elements uninitialized.</source>
          <target state="translated">Перегрузка (3) обнуляет элементы неклассовых типов, таких как &lt;code&gt;int&lt;/code&gt; , что отличается от поведения &lt;a href=&quot;../../language/new&quot;&gt; &lt;code&gt;new[]&lt;/code&gt; &lt;/a&gt; , что оставляет их неинициализированными. Чтобы соответствовать поведению &lt;code&gt;new[]&lt;/code&gt; , может быть предоставлена &lt;a href=&quot;https://stackoverflow.com/a/21028912/273767&quot;&gt;настраиваемая конструкция Allocator ::,&lt;/a&gt; которая оставляет такие элементы неинициализированными.</target>
        </trans-unit>
        <trans-unit id="6bf1e7ebfe0e6d90d794292aee13cc0558b63e2d" translate="yes" xml:space="preserve">
          <source>The overload of &lt;code&gt;&lt;a href=&quot;../../iterator/begin&quot;&gt;std::begin&lt;/a&gt;&lt;/code&gt; for &lt;code&gt;initializer_list&lt;/code&gt; returns a pointer to the first element of &lt;code&gt;il&lt;/code&gt;.</source>
          <target state="translated">Перегрузка &lt;code&gt;&lt;a href=&quot;../../iterator/begin&quot;&gt;std::begin&lt;/a&gt;&lt;/code&gt; для &lt;code&gt;initializer_list&lt;/code&gt; возвращает указатель на первый элемент &lt;code&gt;il&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="038f0a2e5a071bb2843d1c518dc177b71222920c" translate="yes" xml:space="preserve">
          <source>The overload of &lt;code&gt;&lt;a href=&quot;../../iterator/begin&quot;&gt;std::begin&lt;/a&gt;&lt;/code&gt; for &lt;code&gt;valarray&lt;/code&gt; returns an iterator of unspecified type referring to the first element in the numeric array.</source>
          <target state="translated">Перегрузка &lt;code&gt;&lt;a href=&quot;../../iterator/begin&quot;&gt;std::begin&lt;/a&gt;&lt;/code&gt; для &lt;code&gt;valarray&lt;/code&gt; возвращает итератор неопределенного типа, ссылающийся на первый элемент в числовом массиве.</target>
        </trans-unit>
        <trans-unit id="84c575ea93991f4dfe1b4bf2acfc46b67a8cd82c" translate="yes" xml:space="preserve">
          <source>The overload of &lt;code&gt;&lt;a href=&quot;../../iterator/end&quot;&gt;std::end&lt;/a&gt;&lt;/code&gt; for &lt;code&gt;initializer_list&lt;/code&gt; returns a pointer to one past the last element of &lt;code&gt;il&lt;/code&gt;.</source>
          <target state="translated">Перегрузка &lt;code&gt;&lt;a href=&quot;../../iterator/end&quot;&gt;std::end&lt;/a&gt;&lt;/code&gt; для &lt;code&gt;initializer_list&lt;/code&gt; возвращает указатель на один после последнего элемента &lt;code&gt;il&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e3e880f9ab6d60647899982795a8dda9c2944720" translate="yes" xml:space="preserve">
          <source>The overload of &lt;code&gt;&lt;a href=&quot;../../iterator/end&quot;&gt;std::end&lt;/a&gt;&lt;/code&gt; for &lt;code&gt;valarray&lt;/code&gt; returns an iterator of unspecified type referring to the one past the last element in the numeric array.</source>
          <target state="translated">Перегрузка &lt;code&gt;&lt;a href=&quot;../../iterator/end&quot;&gt;std::end&lt;/a&gt;&lt;/code&gt; для &lt;code&gt;valarray&lt;/code&gt; возвращает итератор неопределенного типа, который ссылается на один за последним элементом в числовом массиве.</target>
        </trans-unit>
        <trans-unit id="dc73911917476c7646928434557b596727d6486b" translate="yes" xml:space="preserve">
          <source>The overload of &lt;code&gt;&lt;a href=&quot;../../iterator/rbegin&quot;&gt;std::rbegin&lt;/a&gt;&lt;/code&gt; for &lt;code&gt;initializer_list&lt;/code&gt; returns an &lt;code&gt;&lt;a href=&quot;../../iterator/reverse_iterator&quot;&gt;std::reverse_iterator&lt;/a&gt;&lt;/code&gt; pointing at the last element of &lt;code&gt;il&lt;/code&gt;.</source>
          <target state="translated">Перегрузка &lt;code&gt;&lt;a href=&quot;../../iterator/rbegin&quot;&gt;std::rbegin&lt;/a&gt;&lt;/code&gt; для &lt;code&gt;initializer_list&lt;/code&gt; возвращает &lt;code&gt;&lt;a href=&quot;../../iterator/reverse_iterator&quot;&gt;std::reverse_iterator&lt;/a&gt;&lt;/code&gt; указывающий на последний элемент &lt;code&gt;il&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ce6318ab93622dbaf9e7b41535ac8be907e21159" translate="yes" xml:space="preserve">
          <source>The overload of &lt;code&gt;&lt;a href=&quot;../../iterator/rend&quot;&gt;std::rend&lt;/a&gt;&lt;/code&gt; for &lt;code&gt;initializer_list&lt;/code&gt; returns an &lt;code&gt;&lt;a href=&quot;../../iterator/reverse_iterator&quot;&gt;std::reverse_iterator&lt;/a&gt;&lt;/code&gt; pointing at the first element of &lt;code&gt;il&lt;/code&gt;.</source>
          <target state="translated">Перегрузка &lt;code&gt;&lt;a href=&quot;../../iterator/rend&quot;&gt;std::rend&lt;/a&gt;&lt;/code&gt; для &lt;code&gt;initializer_list&lt;/code&gt; возвращает &lt;code&gt;&lt;a href=&quot;../../iterator/reverse_iterator&quot;&gt;std::reverse_iterator&lt;/a&gt;&lt;/code&gt; указывающий на первый элемент &lt;code&gt;il&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0c43a69d1f5e72f32062b0ff1de3c8b0d1df1068" translate="yes" xml:space="preserve">
          <source>The overload of operator &lt;code&gt;-&amp;gt;&lt;/code&gt; must either return a raw pointer, or return an object (by reference or by value) for which operator &lt;code&gt;-&amp;gt;&lt;/code&gt; is in turn overloaded.</source>
          <target state="translated">Перегрузка оператора &lt;code&gt;-&amp;gt;&lt;/code&gt; должна либо возвращать необработанный указатель, либо возвращать объект (по ссылке или по значению), для которого оператор &lt;code&gt;-&amp;gt;&lt;/code&gt; , в свою очередь, перегружен.</target>
        </trans-unit>
        <trans-unit id="59c7e08ff39317162bda21db4d04832d07f05332" translate="yes" xml:space="preserve">
          <source>The overload that does not take a &lt;code&gt;&lt;a href=&quot;../../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&amp;amp;&lt;/code&gt; parameter throws &lt;a href=&quot;../filesystem_error&quot;&gt;&lt;code&gt;filesystem_error&lt;/code&gt;&lt;/a&gt; on underlying OS API errors, constructed with &lt;code&gt;p&lt;/code&gt; as the first path argument and the OS error code as the error code argument. The overload taking a &lt;code&gt;&lt;a href=&quot;../../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&amp;amp;&lt;/code&gt; parameter sets it to the OS API error code if an OS API call fails, and executes &lt;code&gt;ec.clear()&lt;/code&gt; if no errors occur. Any overload not marked &lt;code&gt;noexcept&lt;/code&gt; may throw &lt;code&gt;&lt;a href=&quot;../../memory/new/bad_alloc&quot;&gt;std::bad_alloc&lt;/a&gt;&lt;/code&gt; if memory allocation fails.</source>
          <target state="translated">Перегрузки , который не принимает &lt;code&gt;&lt;a href=&quot;../../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&amp;amp;&lt;/code&gt; параметр бросает &lt;a href=&quot;../filesystem_error&quot;&gt; &lt;code&gt;filesystem_error&lt;/code&gt; &lt;/a&gt; на основных ошибках ОС API, построенные с &lt;code&gt;p&lt;/code&gt; в качестве первого аргумента пути и OS кода ошибки в качестве аргумента кода ошибки. Перегрузка, принимающая параметр &lt;code&gt;&lt;a href=&quot;../../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&amp;amp;&lt;/code&gt; устанавливает его в код ошибки API OS в случае сбоя вызова API OS и выполняет &lt;code&gt;ec.clear()&lt;/code&gt; если ошибок не возникает. Любая перегрузка, не отмеченная &lt;code&gt;noexcept&lt;/code&gt; , может &lt;code&gt;&lt;a href=&quot;../../memory/new/bad_alloc&quot;&gt;std::bad_alloc&lt;/a&gt;&lt;/code&gt; если выделение памяти завершится неудачно.</target>
        </trans-unit>
        <trans-unit id="68156db91adc064f5a1b3f123b0b56bb2aa82cf8" translate="yes" xml:space="preserve">
          <source>The overload that does not take a &lt;code&gt;&lt;a href=&quot;../../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&amp;amp;&lt;/code&gt; parameter throws &lt;a href=&quot;../filesystem_error&quot;&gt;&lt;code&gt;filesystem_error&lt;/code&gt;&lt;/a&gt; on underlying OS API errors, constructed with the OS error code as the error code argument. The overload taking a &lt;code&gt;&lt;a href=&quot;../../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&amp;amp;&lt;/code&gt; parameter sets it to the OS API error code if an OS API call fails, and executes &lt;code&gt;ec.clear()&lt;/code&gt; if no errors occur. Any overload not marked &lt;code&gt;noexcept&lt;/code&gt; may throw &lt;code&gt;&lt;a href=&quot;../../memory/new/bad_alloc&quot;&gt;std::bad_alloc&lt;/a&gt;&lt;/code&gt; if memory allocation fails.</source>
          <target state="translated">Перегрузка , которая не принимает &lt;code&gt;&lt;a href=&quot;../../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&amp;amp;&lt;/code&gt; параметр бросает &lt;a href=&quot;../filesystem_error&quot;&gt; &lt;code&gt;filesystem_error&lt;/code&gt; &lt;/a&gt; на основных ошибках OS API, построенных с OS кодом ошибки как код ошибки аргумент. Перегрузка, принимающая параметр &lt;code&gt;&lt;a href=&quot;../../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&amp;amp;&lt;/code&gt; устанавливает его в код ошибки API OS в случае сбоя вызова API OS и выполняет &lt;code&gt;ec.clear()&lt;/code&gt; если ошибок не возникает. Любая перегрузка, не отмеченная &lt;code&gt;noexcept&lt;/code&gt; , может &lt;code&gt;&lt;a href=&quot;../../memory/new/bad_alloc&quot;&gt;std::bad_alloc&lt;/a&gt;&lt;/code&gt; если выделение памяти завершится неудачно.</target>
        </trans-unit>
        <trans-unit id="a24af84b98cf1ff1037189e681754591d35e0d1f" translate="yes" xml:space="preserve">
          <source>The overload that does not take a &lt;code&gt;&lt;a href=&quot;../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&amp;amp;&lt;/code&gt; parameter throws &lt;a href=&quot;filesystem_error&quot;&gt;&lt;code&gt;filesystem_error&lt;/code&gt;&lt;/a&gt; on underlying OS API errors, constructed with &lt;code&gt;from&lt;/code&gt; as the first path argument, &lt;code&gt;to&lt;/code&gt; as the second path argument, and the OS error code as the error code argument. The overload taking a &lt;code&gt;&lt;a href=&quot;../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&amp;amp;&lt;/code&gt; parameter sets it to the OS API error code if an OS API call fails, and executes &lt;code&gt;ec.clear()&lt;/code&gt; if no errors occur. Any overload not marked &lt;code&gt;noexcept&lt;/code&gt; may throw &lt;code&gt;&lt;a href=&quot;../memory/new/bad_alloc&quot;&gt;std::bad_alloc&lt;/a&gt;&lt;/code&gt; if memory allocation fails.</source>
          <target state="translated">Перегрузки , который не принимает &lt;code&gt;&lt;a href=&quot;../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&amp;amp;&lt;/code&gt; параметр бросает &lt;a href=&quot;filesystem_error&quot;&gt; &lt;code&gt;filesystem_error&lt;/code&gt; &lt;/a&gt; на основных ошибках ОС API, построенных &lt;code&gt;from&lt;/code&gt; в качестве первого аргумента пути, &lt;code&gt;to&lt;/code&gt; в качестве второго пути аргумента, и OS кода ошибки в качестве аргумента кода ошибки. Перегрузка, принимающая параметр &lt;code&gt;&lt;a href=&quot;../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&amp;amp;&lt;/code&gt; устанавливает его в код ошибки API OS в случае сбоя вызова API OS и выполняет &lt;code&gt;ec.clear()&lt;/code&gt; если ошибок не возникает. Любая перегрузка, не отмеченная &lt;code&gt;noexcept&lt;/code&gt; , может &lt;code&gt;&lt;a href=&quot;../memory/new/bad_alloc&quot;&gt;std::bad_alloc&lt;/a&gt;&lt;/code&gt; если выделение памяти завершится неудачно.</target>
        </trans-unit>
        <trans-unit id="5c99e4f6d242cae156fe8c53c180077d5056a8e5" translate="yes" xml:space="preserve">
          <source>The overload that does not take a &lt;code&gt;&lt;a href=&quot;../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&amp;amp;&lt;/code&gt; parameter throws &lt;a href=&quot;filesystem_error&quot;&gt;&lt;code&gt;filesystem_error&lt;/code&gt;&lt;/a&gt; on underlying OS API errors, constructed with &lt;code&gt;old_p&lt;/code&gt; as the first path argument, &lt;code&gt;new_p&lt;/code&gt; as the second path argument, and the OS error code as the error code argument. The overload taking a &lt;code&gt;&lt;a href=&quot;../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&amp;amp;&lt;/code&gt; parameter sets it to the OS API error code if an OS API call fails, and executes &lt;code&gt;ec.clear()&lt;/code&gt; if no errors occur. Any overload not marked &lt;code&gt;noexcept&lt;/code&gt; may throw &lt;code&gt;&lt;a href=&quot;../memory/new/bad_alloc&quot;&gt;std::bad_alloc&lt;/a&gt;&lt;/code&gt; if memory allocation fails.</source>
          <target state="translated">Перегрузки , который не принимает &lt;code&gt;&lt;a href=&quot;../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&amp;amp;&lt;/code&gt; параметр бросает &lt;a href=&quot;filesystem_error&quot;&gt; &lt;code&gt;filesystem_error&lt;/code&gt; &lt;/a&gt; на основных ошибках ОС API, построенные с &lt;code&gt;old_p&lt;/code&gt; в качестве первого аргумента пути, &lt;code&gt;new_p&lt;/code&gt; в качестве второго пути аргумента, и OS кода ошибки в качестве аргумента кода ошибки. Перегрузка, принимающая параметр &lt;code&gt;&lt;a href=&quot;../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&amp;amp;&lt;/code&gt; устанавливает его в код ошибки API OS в случае сбоя вызова API OS и выполняет &lt;code&gt;ec.clear()&lt;/code&gt; если ошибок не возникает. Любая перегрузка, не отмеченная &lt;code&gt;noexcept&lt;/code&gt; , может &lt;code&gt;&lt;a href=&quot;../memory/new/bad_alloc&quot;&gt;std::bad_alloc&lt;/a&gt;&lt;/code&gt; если выделение памяти завершится неудачно.</target>
        </trans-unit>
        <trans-unit id="a0951321ca4ae56851938cae8c8021bfe0924467" translate="yes" xml:space="preserve">
          <source>The overload that does not take a &lt;code&gt;&lt;a href=&quot;../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&amp;amp;&lt;/code&gt; parameter throws &lt;a href=&quot;filesystem_error&quot;&gt;&lt;code&gt;filesystem_error&lt;/code&gt;&lt;/a&gt; on underlying OS API errors, constructed with &lt;code&gt;p1&lt;/code&gt; as the first path argument, &lt;code&gt;p2&lt;/code&gt; as the second path argument, and the OS error code as the error code argument. The overload taking a &lt;code&gt;&lt;a href=&quot;../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&amp;amp;&lt;/code&gt; parameter sets it to the OS API error code if an OS API call fails, and executes &lt;code&gt;ec.clear()&lt;/code&gt; if no errors occur. Any overload not marked &lt;code&gt;noexcept&lt;/code&gt; may throw &lt;code&gt;&lt;a href=&quot;../memory/new/bad_alloc&quot;&gt;std::bad_alloc&lt;/a&gt;&lt;/code&gt; if memory allocation fails.</source>
          <target state="translated">Перегрузки , который не принимает &lt;code&gt;&lt;a href=&quot;../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&amp;amp;&lt;/code&gt; параметр бросает &lt;a href=&quot;filesystem_error&quot;&gt; &lt;code&gt;filesystem_error&lt;/code&gt; &lt;/a&gt; на основных ошибках ОС API, построенные с &lt;code&gt;p1&lt;/code&gt; в качестве первого аргумента пути, &lt;code&gt;p2&lt;/code&gt; в качестве второго пути аргумента, и OS кода ошибки в качестве аргумента кода ошибки. Перегрузка, принимающая параметр &lt;code&gt;&lt;a href=&quot;../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&amp;amp;&lt;/code&gt; устанавливает его в код ошибки API OS в случае сбоя вызова API OS и выполняет &lt;code&gt;ec.clear()&lt;/code&gt; если ошибок не возникает. Любая перегрузка, не отмеченная &lt;code&gt;noexcept&lt;/code&gt; , может &lt;code&gt;&lt;a href=&quot;../memory/new/bad_alloc&quot;&gt;std::bad_alloc&lt;/a&gt;&lt;/code&gt; если выделение памяти завершится неудачно.</target>
        </trans-unit>
        <trans-unit id="097925b28af9c725f044eb3f3ff1a0803fb41ab3" translate="yes" xml:space="preserve">
          <source>The overload that does not take a &lt;code&gt;&lt;a href=&quot;../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&amp;amp;&lt;/code&gt; parameter throws &lt;a href=&quot;filesystem_error&quot;&gt;&lt;code&gt;filesystem_error&lt;/code&gt;&lt;/a&gt; on underlying OS API errors, constructed with &lt;code&gt;p&lt;/code&gt; as the first path argument and the OS error code as the error code argument. The overload taking a &lt;code&gt;&lt;a href=&quot;../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&amp;amp;&lt;/code&gt; parameter sets it to the OS API error code if an OS API call fails, and executes &lt;code&gt;ec.clear()&lt;/code&gt; if no errors occur. Any overload not marked &lt;code&gt;noexcept&lt;/code&gt; may throw &lt;code&gt;&lt;a href=&quot;../memory/new/bad_alloc&quot;&gt;std::bad_alloc&lt;/a&gt;&lt;/code&gt; if memory allocation fails.</source>
          <target state="translated">Перегрузки , который не принимает &lt;code&gt;&lt;a href=&quot;../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&amp;amp;&lt;/code&gt; параметр бросает &lt;a href=&quot;filesystem_error&quot;&gt; &lt;code&gt;filesystem_error&lt;/code&gt; &lt;/a&gt; на основных ошибках ОС API, построенные с &lt;code&gt;p&lt;/code&gt; в качестве первого аргумента пути и OS кода ошибки в качестве аргумента кода ошибки. Перегрузка, принимающая параметр &lt;code&gt;&lt;a href=&quot;../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&amp;amp;&lt;/code&gt; устанавливает его в код ошибки API OS в случае сбоя вызова API OS и выполняет &lt;code&gt;ec.clear()&lt;/code&gt; если ошибок не возникает. Любая перегрузка, не отмеченная &lt;code&gt;noexcept&lt;/code&gt; , может &lt;code&gt;&lt;a href=&quot;../memory/new/bad_alloc&quot;&gt;std::bad_alloc&lt;/a&gt;&lt;/code&gt; если выделение памяти завершится неудачно.</target>
        </trans-unit>
        <trans-unit id="2743dce817550a96f75513fc032ccf30bdcdc608" translate="yes" xml:space="preserve">
          <source>The overload that does not take a &lt;code&gt;&lt;a href=&quot;../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&amp;amp;&lt;/code&gt; parameter throws &lt;a href=&quot;filesystem_error&quot;&gt;&lt;code&gt;filesystem_error&lt;/code&gt;&lt;/a&gt; on underlying OS API errors, constructed with &lt;code&gt;p&lt;/code&gt; as the first path argument, &lt;code&gt;base&lt;/code&gt; as the second path argument, and the OS error code as the error code argument. The overload taking a &lt;code&gt;&lt;a href=&quot;../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&amp;amp;&lt;/code&gt; parameter sets it to the OS API error code if an OS API call fails, and executes &lt;code&gt;ec.clear()&lt;/code&gt; if no errors occur. Any overload not marked &lt;code&gt;noexcept&lt;/code&gt; may throw &lt;code&gt;&lt;a href=&quot;../memory/new/bad_alloc&quot;&gt;std::bad_alloc&lt;/a&gt;&lt;/code&gt; if memory allocation fails.</source>
          <target state="translated">Перегрузки , который не принимает &lt;code&gt;&lt;a href=&quot;../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&amp;amp;&lt;/code&gt; параметр бросает &lt;a href=&quot;filesystem_error&quot;&gt; &lt;code&gt;filesystem_error&lt;/code&gt; &lt;/a&gt; на основных ошибках ОС API, построенные с &lt;code&gt;p&lt;/code&gt; в качестве первого аргумента пути, &lt;code&gt;base&lt;/code&gt; в качестве второго пути аргумента, и OS кода ошибки в качестве аргумента кода ошибки. Перегрузка, принимающая параметр &lt;code&gt;&lt;a href=&quot;../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&amp;amp;&lt;/code&gt; устанавливает его в код ошибки API OS в случае сбоя вызова API OS и выполняет &lt;code&gt;ec.clear()&lt;/code&gt; если ошибок не возникает. Любая перегрузка, не отмеченная &lt;code&gt;noexcept&lt;/code&gt; , может &lt;code&gt;&lt;a href=&quot;../memory/new/bad_alloc&quot;&gt;std::bad_alloc&lt;/a&gt;&lt;/code&gt; если выделение памяти завершится неудачно.</target>
        </trans-unit>
        <trans-unit id="45cad57e74ff3ba3f508e070185a6b0faa062d9c" translate="yes" xml:space="preserve">
          <source>The overload that does not take a &lt;code&gt;&lt;a href=&quot;../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&amp;amp;&lt;/code&gt; parameter throws &lt;a href=&quot;filesystem_error&quot;&gt;&lt;code&gt;filesystem_error&lt;/code&gt;&lt;/a&gt; on underlying OS API errors, constructed with &lt;code&gt;path to be returned&lt;/code&gt; as the first path argument and the OS error code as the error code argument. The overload taking a &lt;code&gt;&lt;a href=&quot;../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&amp;amp;&lt;/code&gt; parameter sets it to the OS API error code if an OS API call fails, and executes &lt;code&gt;ec.clear()&lt;/code&gt; if no errors occur. Any overload not marked &lt;code&gt;noexcept&lt;/code&gt; may throw &lt;code&gt;&lt;a href=&quot;../memory/new/bad_alloc&quot;&gt;std::bad_alloc&lt;/a&gt;&lt;/code&gt; if memory allocation fails.</source>
          <target state="translated">Перегрузка , которая не принимает &lt;code&gt;&lt;a href=&quot;../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&amp;amp;&lt;/code&gt; параметр бросает &lt;a href=&quot;filesystem_error&quot;&gt; &lt;code&gt;filesystem_error&lt;/code&gt; &lt;/a&gt; на основных ошибках OS API, построенных с &lt;code&gt;path to be returned&lt;/code&gt; в качестве первого аргумента пути и OS кода ошибки в качестве кода ошибки аргумента. Перегрузка, принимающая параметр &lt;code&gt;&lt;a href=&quot;../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&amp;amp;&lt;/code&gt; устанавливает его в код ошибки API OS в случае сбоя вызова API OS и выполняет &lt;code&gt;ec.clear()&lt;/code&gt; если ошибок не возникает. Любая перегрузка, не отмеченная &lt;code&gt;noexcept&lt;/code&gt; , может &lt;code&gt;&lt;a href=&quot;../memory/new/bad_alloc&quot;&gt;std::bad_alloc&lt;/a&gt;&lt;/code&gt; если выделение памяти завершится неудачно.</target>
        </trans-unit>
        <trans-unit id="63b27ca41e532a5a7a9cbe39b5246376a55b9912" translate="yes" xml:space="preserve">
          <source>The overload that does not take a &lt;code&gt;&lt;a href=&quot;../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&amp;amp;&lt;/code&gt; parameter throws &lt;a href=&quot;filesystem_error&quot;&gt;&lt;code&gt;filesystem_error&lt;/code&gt;&lt;/a&gt; on underlying OS API errors, constructed with &lt;code&gt;target&lt;/code&gt; as the first path argument, &lt;code&gt;link&lt;/code&gt; as the second path argument, and the OS error code as the error code argument. The overload taking a &lt;code&gt;&lt;a href=&quot;../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&amp;amp;&lt;/code&gt; parameter sets it to the OS API error code if an OS API call fails, and executes &lt;code&gt;ec.clear()&lt;/code&gt; if no errors occur. Any overload not marked &lt;code&gt;noexcept&lt;/code&gt; may throw &lt;code&gt;&lt;a href=&quot;../memory/new/bad_alloc&quot;&gt;std::bad_alloc&lt;/a&gt;&lt;/code&gt; if memory allocation fails.</source>
          <target state="translated">Перегрузки , который не принимает &lt;code&gt;&lt;a href=&quot;../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&amp;amp;&lt;/code&gt; параметр бросает &lt;a href=&quot;filesystem_error&quot;&gt; &lt;code&gt;filesystem_error&lt;/code&gt; &lt;/a&gt; на основных ошибках ОС API, построенные с &lt;code&gt;target&lt;/code&gt; в качестве первого аргумента пути, &lt;code&gt;link&lt;/code&gt; в качестве второго пути аргумента, и OS кода ошибки в качестве аргумента кода ошибки. Перегрузка, принимающая параметр &lt;code&gt;&lt;a href=&quot;../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&amp;amp;&lt;/code&gt; устанавливает его в код ошибки API OS в случае сбоя вызова API OS и выполняет &lt;code&gt;ec.clear()&lt;/code&gt; если ошибок не возникает. Любая перегрузка, не отмеченная &lt;code&gt;noexcept&lt;/code&gt; , может &lt;code&gt;&lt;a href=&quot;../memory/new/bad_alloc&quot;&gt;std::bad_alloc&lt;/a&gt;&lt;/code&gt; если выделение памяти завершится неудачно</target>
        </trans-unit>
        <trans-unit id="7b44057a826fb8d870cd4cdd23aeed9b3f71f525" translate="yes" xml:space="preserve">
          <source>The overload with a template parameter named &lt;code&gt;ExecutionPolicy&lt;/code&gt; reports errors as follows:</source>
          <target state="translated">Перегрузка с параметром шаблона с именем &lt;code&gt;ExecutionPolicy&lt;/code&gt; сообщает об ошибках следующим образом:</target>
        </trans-unit>
        <trans-unit id="be64bc9e876275165a0c7eba9eb5ad84ea913bf6" translate="yes" xml:space="preserve">
          <source>The overloads (2-6) provide allocator propagation into &lt;code&gt;&lt;a href=&quot;../utility/pair&quot;&gt;std::pair&lt;/a&gt;&lt;/code&gt;, which supports neither leading-allocator nor trailing-allocator calling conventions (unlike, e.g. &lt;code&gt;&lt;a href=&quot;../utility/tuple&quot;&gt;std::tuple&lt;/a&gt;&lt;/code&gt;, which uses leading-allocator convention).</source>
          <target state="translated">Перегрузки (2-6) обеспечивают распространение распределителя в &lt;code&gt;&lt;a href=&quot;../utility/pair&quot;&gt;std::pair&lt;/a&gt;&lt;/code&gt; , который не поддерживает ни соглашения о вызовах начального-распределителя, ни конечного-распределителя (в отличие, например, от &lt;code&gt;&lt;a href=&quot;../utility/tuple&quot;&gt;std::tuple&lt;/a&gt;&lt;/code&gt; , в котором используется соглашение о ведущем-распределителе).</target>
        </trans-unit>
        <trans-unit id="684f3f556fb197adb926e01a526a9556d8043a2d" translate="yes" xml:space="preserve">
          <source>The overloads (5,6) are often implemented as a loop that calls the overload (3) with &lt;code&gt;&lt;a href=&quot;end&quot;&gt;end()&lt;/a&gt;&lt;/code&gt; as the hint; they are optimized for appending a sorted sequence (such as another set) whose smallest element is greater than the last element in &lt;code&gt;*this&lt;/code&gt;.</source>
          <target state="translated">Перегрузки (5,6) часто реализуются как цикл, который вызывает перегрузку (3) с &lt;code&gt;&lt;a href=&quot;end&quot;&gt;end()&lt;/a&gt;&lt;/code&gt; в качестве подсказки; они оптимизированы для добавления отсортированной последовательности (например, другого набора), чей наименьший элемент больше, чем последний элемент в &lt;code&gt;*this&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="70d94f85af425ede81ffbbe7061489408578ee30" translate="yes" xml:space="preserve">
          <source>The overloads are marked as &lt;code&gt;constexpr&lt;/code&gt; since C++14.</source>
          <target state="translated">Перегрузки отмечены как &lt;code&gt;constexpr&lt;/code&gt; начиная с C ++ 14.</target>
        </trans-unit>
        <trans-unit id="44fe9b19e02fae03d565fc0de302ad3d97db79e7" translate="yes" xml:space="preserve">
          <source>The overloads not taking &lt;code&gt;opts&lt;/code&gt; as a parameter uses a default constructed instance of &lt;a href=&quot;../pool_options&quot;&gt;&lt;code&gt;pool_options&lt;/code&gt;&lt;/a&gt; as the options. The overloads not taking &lt;code&gt;upstream&lt;/code&gt; as a parameter uses the return value of &lt;code&gt;&lt;a href=&quot;../get_default_resource&quot;&gt;std::pmr::get_default_resource&lt;/a&gt;()&lt;/code&gt; as the upstream memory resource.</source>
          <target state="translated">Перегрузки, не принимающие &lt;code&gt;opts&lt;/code&gt; в качестве параметра, используют &lt;a href=&quot;../pool_options&quot;&gt; &lt;code&gt;pool_options&lt;/code&gt; &lt;/a&gt; по умолчанию экземпляр pool_options в качестве параметров. Перегрузки, не принимающие &lt;code&gt;upstream&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;../get_default_resource&quot;&gt;std::pmr::get_default_resource&lt;/a&gt;()&lt;/code&gt; в качестве параметра, используют возвращаемое значение std :: pmr :: get_default_resource () в качестве восходящего ресурса памяти.</target>
        </trans-unit>
        <trans-unit id="5088ac896f932a6a0d4f549d22b00102f8ee7619" translate="yes" xml:space="preserve">
          <source>The overloads not taking &lt;code&gt;opts&lt;/code&gt; as a parameter uses a default constructed instance of &lt;a href=&quot;../pool_options&quot;&gt;&lt;code&gt;pool_options&lt;/code&gt;&lt;/a&gt; as the options. The overloads not taking &lt;code&gt;upstream&lt;/code&gt; as a parameter uses the return value of &lt;code&gt;&lt;a href=&quot;../get_default_resource&quot;&gt;std::pmr::get_default_resource&lt;/a&gt;&lt;/code&gt; as the upstream memory resource.</source>
          <target state="translated">Перегрузки, не принимающие &lt;code&gt;opts&lt;/code&gt; в качестве параметра, используют &lt;a href=&quot;../pool_options&quot;&gt; &lt;code&gt;pool_options&lt;/code&gt; &lt;/a&gt; по умолчанию экземпляр pool_options в качестве параметров. Перегрузки, не принимающие &lt;code&gt;upstream&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;../get_default_resource&quot;&gt;std::pmr::get_default_resource&lt;/a&gt;&lt;/code&gt; в качестве параметра, используют возвращаемое значение std :: pmr :: get_default_resource в качестве восходящего ресурса памяти.</target>
        </trans-unit>
        <trans-unit id="8126e43884394c17d3457633c0894495b6f29864" translate="yes" xml:space="preserve">
          <source>The overloads of &lt;code&gt;operator&amp;gt;&amp;gt;&lt;/code&gt; and &lt;code&gt;operator&amp;lt;&amp;lt;&lt;/code&gt; that take a &lt;code&gt;&lt;a href=&quot;../io/basic_istream&quot;&gt;std::istream&lt;/a&gt;&amp;amp;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../io/basic_ostream&quot;&gt;std::ostream&lt;/a&gt;&amp;amp;&lt;/code&gt; as the left hand argument are known as insertion and extraction operators. Since they take the user-defined type as the right argument (&lt;code&gt;b&lt;/code&gt; in a@b), they must be implemented as non-members.</source>
          <target state="translated">Перегрузки &lt;code&gt;operator&amp;gt;&amp;gt;&lt;/code&gt; и &lt;code&gt;operator&amp;lt;&amp;lt;&lt;/code&gt; которые принимают &lt;code&gt;&lt;a href=&quot;../io/basic_istream&quot;&gt;std::istream&lt;/a&gt;&amp;amp;&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;../io/basic_ostream&quot;&gt;std::ostream&lt;/a&gt;&amp;amp;&lt;/code&gt; в качестве левого аргумента, известны как операторы вставки и извлечения. Так как они принимают пользовательский тип в качестве правильного аргумента ( &lt;code&gt;b&lt;/code&gt; в a @ b), они должны быть реализованы как не-члены.</target>
        </trans-unit>
        <trans-unit id="435446cb476ebaebe355f8cf48105e0dddc8213e" translate="yes" xml:space="preserve">
          <source>The overloads of operators &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; and &lt;code&gt;||&lt;/code&gt; lose short-circuit evaluation.</source>
          <target state="translated">Перегрузки операторов &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; и &lt;code&gt;||&lt;/code&gt; потерять оценку короткого замыкания.</target>
        </trans-unit>
        <trans-unit id="c77c38e018a2a03f4663ee8fdfa0fd3a61518b4d" translate="yes" xml:space="preserve">
          <source>The overloads taking parameters named &lt;code&gt;pos1&lt;/code&gt; or &lt;code&gt;pos2&lt;/code&gt; throws &lt;code&gt;&lt;a href=&quot;../../error/out_of_range/out_of_range&quot;&gt;std::out_of_range&lt;/a&gt;&lt;/code&gt; if the argument is out of range.</source>
          <target state="translated">Перегрузки , принимающие параметры , названные &lt;code&gt;pos1&lt;/code&gt; или &lt;code&gt;pos2&lt;/code&gt; бросков &lt;code&gt;&lt;a href=&quot;../../error/out_of_range/out_of_range&quot;&gt;std::out_of_range&lt;/a&gt;&lt;/code&gt; , если аргумент находится вне диапазона.</target>
        </trans-unit>
        <trans-unit id="15de6f30385481ec7a64ac4f54a04bf7a70486ea" translate="yes" xml:space="preserve">
          <source>The overloads that do not use &lt;code&gt;std::piecewise_construct_t&lt;/code&gt; assume that each tuple argument becomes the element of a pair. The overloads that use &lt;code&gt;std::piecewise_construct_t&lt;/code&gt; assume that each tuple argument is used to construct, piecewise, a new object of specified type, which will become the element of the pair.</source>
          <target state="translated">Перегрузки, которые не используют &lt;code&gt;std::piecewise_construct_t&lt;/code&gt; предполагают, что каждый аргумент кортежа становится элементом пары. Перегрузки, использующие &lt;code&gt;std::piecewise_construct_t&lt;/code&gt; предполагают, что каждый аргумент кортежа используется для кусочного конструирования нового объекта указанного типа, который станет элементом пары.</target>
        </trans-unit>
        <trans-unit id="b7bdb96b9c09362e092f33a4cbae2fe72c83f4e2" translate="yes" xml:space="preserve">
          <source>The overloads with a template parameter named &lt;code&gt;ExecutionPolicy&lt;/code&gt; report errors as follows:</source>
          <target state="translated">Перегрузки с параметром шаблона с именем &lt;code&gt;ExecutionPolicy&lt;/code&gt; сообщают об ошибках следующим образом:</target>
        </trans-unit>
        <trans-unit id="a864b224232c408c9511f10f7feafcbf33889a52" translate="yes" xml:space="preserve">
          <source>The override for the virtual member function &lt;code&gt;what()&lt;/code&gt; may by provided, but is not required.</source>
          <target state="translated">Переопределение для виртуальной функции-члена &lt;code&gt;what()&lt;/code&gt; может быть предоставлено, но не является обязательным.</target>
        </trans-unit>
        <trans-unit id="8d89be08f6f6c31578200be6591584e87d1fdf78" translate="yes" xml:space="preserve">
          <source>The overriders of &lt;a href=&quot;virtual&quot;&gt;virtual&lt;/a&gt; functions do not acquire the default arguments from the base class declarations, and when the virtual function call is made, the default arguments are decided based on the static type of the object (note: this can be avoided with &lt;a href=&quot;http://www.gotw.ca/publications/mill18.htm&quot;&gt;non-virtual interface&lt;/a&gt; pattern).</source>
          <target state="translated">Переопределители &lt;a href=&quot;virtual&quot;&gt;виртуальных&lt;/a&gt; функций не получают аргументы по умолчанию из объявлений базового класса, и когда выполняется вызов виртуальной функции, аргументы по умолчанию определяются на основе статического типа объекта (примечание: этого можно избежать с помощью &lt;a href=&quot;http://www.gotw.ca/publications/mill18.htm&quot;&gt;не виртуального).&lt;/a&gt; шаблон интерфейса ).</target>
        </trans-unit>
        <trans-unit id="c2ff4997fdc8d657823adaf82ddae1edd807b428" translate="yes" xml:space="preserve">
          <source>The ownership of an object can only be shared with another &lt;code&gt;shared_ptr&lt;/code&gt; by copy constructing or copy assigning its value to another &lt;code&gt;shared_ptr&lt;/code&gt;. Constructing a new &lt;code&gt;shared_ptr&lt;/code&gt; using the raw underlying pointer owned by another &lt;code&gt;shared_ptr&lt;/code&gt; leads to undefined behavior.</source>
          <target state="translated">Владение объектом может быть разделено только с другим &lt;code&gt;shared_ptr&lt;/code&gt; путем создания копии или копирования присвоения его значения другому &lt;code&gt;shared_ptr&lt;/code&gt; . Создание нового &lt;code&gt;shared_ptr&lt;/code&gt; с использованием необработанного базового указателя, принадлежащего другому &lt;code&gt;shared_ptr&lt;/code&gt; , приводит к неопределенному поведению.</target>
        </trans-unit>
        <trans-unit id="fa11b27c4386988848a8387d60af610e8a21c655" translate="yes" xml:space="preserve">
          <source>The paragraph defining the strict aliasing rule in the standard contains two additional bullets partially inherited from C:</source>
          <target state="translated">В пункте,определяющем строгое правило наложения псевдонимов в стандарте,содержатся две дополнительные пули,частично унаследованные от С:</target>
        </trans-unit>
        <trans-unit id="8d946d0089157a6f8805e15b4ad51c2da0943b9d" translate="yes" xml:space="preserve">
          <source>The parallelizable version of this algorithm, &lt;code&gt;&lt;a href=&quot;transform_reduce&quot;&gt;std::transform_reduce&lt;/a&gt;&lt;/code&gt;, requires &lt;code&gt;op1&lt;/code&gt; and &lt;code&gt;op2&lt;/code&gt; to be commutative and associative, but &lt;code&gt;std::inner_product&lt;/code&gt; makes no such requirement, and always performs the operations in the order given.</source>
          <target state="translated">&lt;code&gt;op1&lt;/code&gt; версия этого алгоритма, &lt;code&gt;&lt;a href=&quot;transform_reduce&quot;&gt;std::transform_reduce&lt;/a&gt;&lt;/code&gt; , требует, чтобы op1 и &lt;code&gt;op2&lt;/code&gt; были коммутативными и ассоциативными, но &lt;code&gt;std::inner_product&lt;/code&gt; не предъявляет таких требований и всегда выполняет операции в указанном порядке.</target>
        </trans-unit>
        <trans-unit id="88022664eeccd42a9c9975d465fba66ce4506250" translate="yes" xml:space="preserve">
          <source>The parameter &lt;code&gt;P&lt;/code&gt; is obtained as follows: in &lt;code&gt;T&lt;/code&gt;, the declared type of the variable that includes &lt;code&gt;auto&lt;/code&gt;, every occurrence of &lt;code&gt;auto&lt;/code&gt; is replaced with an imaginary type template parameter &lt;code&gt;U&lt;/code&gt; or, if the initialization is copy-list-initialization, with &lt;code&gt;std::initializer_list&amp;lt;U&amp;gt;&lt;/code&gt;. The argument &lt;code&gt;A&lt;/code&gt; is the initializer expression. After deduction of &lt;code&gt;U&lt;/code&gt; from &lt;code&gt;P&lt;/code&gt; and &lt;code&gt;A&lt;/code&gt; following the rules described above, the deduced &lt;code&gt;U&lt;/code&gt; is substituted into &lt;code&gt;P&lt;/code&gt; to get the actual variable type:</source>
          <target state="translated">Параметр &lt;code&gt;P&lt;/code&gt; получается следующим образом: в &lt;code&gt;T&lt;/code&gt; , объявленном типе переменной, которая включает в себя &lt;code&gt;auto&lt;/code&gt; , каждое вхождение &lt;code&gt;auto&lt;/code&gt; заменяется параметром &lt;code&gt;U&lt;/code&gt; воображаемого типа шаблона или, если инициализация является инициализацией copy-list-initialization, на &lt;code&gt;std::initializer_list&amp;lt;U&amp;gt;&lt;/code&gt; . Аргумент &lt;code&gt;A&lt;/code&gt; является выражением инициализатора. После вычета &lt;code&gt;U&lt;/code&gt; из &lt;code&gt;P&lt;/code&gt; и &lt;code&gt;A&lt;/code&gt; в соответствии с правилами, описанными выше, выведенный &lt;code&gt;U&lt;/code&gt; подставляется в &lt;code&gt;P&lt;/code&gt; для получения фактического типа переменной:</target>
        </trans-unit>
        <trans-unit id="ced868183336be7e9556ada04c5529aea418503e" translate="yes" xml:space="preserve">
          <source>The parameter &lt;code&gt;i&lt;/code&gt; shall be less than the number of elements in the array; otherwise, the behavior is undefined.</source>
          <target state="translated">Параметр &lt;code&gt;i&lt;/code&gt; должен быть меньше количества элементов в массиве; в противном случае поведение не определено.</target>
        </trans-unit>
        <trans-unit id="399902f69cf10a83ab53fc5cc2b8d7444ca7d8d2" translate="yes" xml:space="preserve">
          <source>The parameter &lt;code&gt;init&lt;/code&gt; appears last, differing from &lt;code&gt;&lt;a href=&quot;transform_exclusive_scan&quot;&gt;std::transform_exclusive_scan&lt;/a&gt;&lt;/code&gt;, because it is optional for this function.</source>
          <target state="translated">Параметр &lt;code&gt;init&lt;/code&gt; появляется последним, в отличие от &lt;code&gt;&lt;a href=&quot;transform_exclusive_scan&quot;&gt;std::transform_exclusive_scan&lt;/a&gt;&lt;/code&gt; , поскольку он не является обязательным для этой функции.</target>
        </trans-unit>
        <trans-unit id="309510cf9024b1695506845548ff6ef69f7b6db0" translate="yes" xml:space="preserve">
          <source>The parameter is passed by value and is subject to slicing.</source>
          <target state="translated">Параметр передается по значению и подлежит нарезке.</target>
        </trans-unit>
        <trans-unit id="7f622764221043c46158533031680f20b679054a" translate="yes" xml:space="preserve">
          <source>The parameter types and the return type of the function must match the target exactly, no implicit conversions are considered (e.g. a function returning a pointer to derived won't get selected when initializing a pointer to function returning a pointer to base).</source>
          <target state="translated">Типы параметров и тип возвращаемой функции должны точно совпадать с целью,не учитываются неявные приведения (например,функция,возвращающая указатель на производную,не будет выделена при инициализации указателя на функцию,возвращающую указатель на базу).</target>
        </trans-unit>
        <trans-unit id="04103a3447a63b6cf20e5c231a8fc7a4ccdc71ac" translate="yes" xml:space="preserve">
          <source>The parameter types, as well as the return type of a function cannot be &lt;a href=&quot;incomplete_type&quot;&gt;incomplete&lt;/a&gt;&lt;a href=&quot;class&quot;&gt;class types&lt;/a&gt;, except for deleted functions(since C++11). The completeness check is made in the context of the function</source>
          <target state="translated">Типы параметров, а также возвращаемый тип функции не могут быть &lt;a href=&quot;incomplete_type&quot;&gt;неполными &lt;/a&gt;&lt;a href=&quot;class&quot;&gt;типами классов&lt;/a&gt; , за исключением удаленных функций (начиная с C ++ 11). Проверка полноты выполняется в контексте функции</target>
        </trans-unit>
        <trans-unit id="72593e2e10e937d3bd8a9e45b5e7630cd1c55e97" translate="yes" xml:space="preserve">
          <source>The parameters declared in the declarator of a function definition are &lt;a href=&quot;scope&quot;&gt;in scope&lt;/a&gt; within the body. If a parameter is not used in the function body, it does not need to be named (it's sufficient to use an abstract declarator).</source>
          <target state="translated">Параметры, объявленные в объявителе определения функции, находятся &lt;a href=&quot;scope&quot;&gt;в области видимости&lt;/a&gt; внутри тела. Если параметр не используется в теле функции, его не нужно называть (достаточно использовать абстрактный декларатор).</target>
        </trans-unit>
        <trans-unit id="d233ef2eab4dce31ee515ec28dc0e9bc316caee3" translate="yes" xml:space="preserve">
          <source>The parameters m and s are, respectively, the mean and standard deviation of the natural logarithm of x.</source>
          <target state="translated">Параметрами m и s являются,соответственно,среднее и стандартное отклонение естественного логарифма x.</target>
        </trans-unit>
        <trans-unit id="cef460ed950b6b80761f1b32499ca34a65c8b52d" translate="yes" xml:space="preserve">
          <source>The parameters of a distribution object may be changed either permanently, by using &lt;code&gt;d.param(p)&lt;/code&gt; or just for the duration of a single operator() call, by using &lt;code&gt;d(g,p)&lt;/code&gt;.</source>
          <target state="translated">Параметры объекта распределения могут быть изменены либо навсегда, используя &lt;code&gt;d.param(p)&lt;/code&gt; либо просто на время одного вызова оператора (), используя &lt;code&gt;d(g,p)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d2936a021e331baf2a03da363a001e002fbef98a" translate="yes" xml:space="preserve">
          <source>The parameters of the slice -- start, size and stride respectively.</source>
          <target state="translated">Параметры среза --старт,размер и шаг соответственно.</target>
        </trans-unit>
        <trans-unit id="0269c7638cb516f0a5e4f2122a21b168b3bc2795" translate="yes" xml:space="preserve">
          <source>The parameters of the slice -- start, sizes and strides respectively.</source>
          <target state="translated">Параметры среза --старт,размеры и шаги соответственно.</target>
        </trans-unit>
        <trans-unit id="467dc40c372e73f0c2c12405d62c7e8ef32d3367" translate="yes" xml:space="preserve">
          <source>The parameters of the two-parameter form of the main function allow arbitrary multibyte character strings to be passed from the execution environment (these are typically known as</source>
          <target state="translated">Параметры двухпараметрической формы основной функции позволяют передавать произвольные многобайтовые символьные строки из среды исполнения (их обычно называют</target>
        </trans-unit>
        <trans-unit id="3c5a1d2074edfc3d26b83a970525326f7df017be" translate="yes" xml:space="preserve">
          <source>The parsed date is stored in the corresponding fields of the &lt;code&gt;&lt;a href=&quot;../../chrono/c/tm&quot;&gt;std::tm&lt;/a&gt;&lt;/code&gt; structure pointed to by the argument &lt;code&gt;t&lt;/code&gt;.</source>
          <target state="translated">Анализируемая дата сохраняется в соответствующих полях структуры &lt;code&gt;&lt;a href=&quot;../../chrono/c/tm&quot;&gt;std::tm&lt;/a&gt;&lt;/code&gt; указывает аргумент &lt;code&gt;t&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6f535b74a20fe9252e07e454d87e684ef404bcaa" translate="yes" xml:space="preserve">
          <source>The parsed month is stored in the &lt;code&gt;&lt;a href=&quot;../../chrono/c/tm&quot;&gt;std::tm&lt;/a&gt;&lt;/code&gt; field &lt;code&gt;t-&amp;gt;tm_mon&lt;/code&gt;.</source>
          <target state="translated">Разобранный месяц хранится в &lt;code&gt;&lt;a href=&quot;../../chrono/c/tm&quot;&gt;std::tm&lt;/a&gt;&lt;/code&gt; поле &lt;code&gt;t-&amp;gt;tm_mon&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d5c30cfbbbd6f7927a29d7fcfe63ecd32a351360" translate="yes" xml:space="preserve">
          <source>The parsed time is stored in the corresponding fields of the &lt;code&gt;&lt;a href=&quot;../../chrono/c/tm&quot;&gt;std::tm&lt;/a&gt;&lt;/code&gt; structure pointed to by the argument &lt;code&gt;t&lt;/code&gt;.</source>
          <target state="translated">Проанализированное время сохраняется в соответствующих полях структуры &lt;code&gt;&lt;a href=&quot;../../chrono/c/tm&quot;&gt;std::tm&lt;/a&gt;&lt;/code&gt; указывает аргумент &lt;code&gt;t&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="14f5b5d4d2f8aed5cb8f99bcda8328dda074ac91" translate="yes" xml:space="preserve">
          <source>The parsed weekday is stored in the &lt;code&gt;&lt;a href=&quot;../../chrono/c/tm&quot;&gt;std::tm&lt;/a&gt;&lt;/code&gt; field &lt;code&gt;t-&amp;gt;tm_wday&lt;/code&gt;.</source>
          <target state="translated">Разобранный будний день хранится в &lt;code&gt;&lt;a href=&quot;../../chrono/c/tm&quot;&gt;std::tm&lt;/a&gt;&lt;/code&gt; поле &lt;code&gt;t-&amp;gt;tm_wday&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0cdf3188b56cdad85a77a2a64d2b697625de2a7b" translate="yes" xml:space="preserve">
          <source>The parsed year is stored in the &lt;code&gt;&lt;a href=&quot;../../chrono/c/tm&quot;&gt;std::tm&lt;/a&gt;&lt;/code&gt; structure field &lt;code&gt;t-&amp;gt;tm_year&lt;/code&gt;.</source>
          <target state="translated">Проанализированный год сохраняется в поле структуры &lt;code&gt;&lt;a href=&quot;../../chrono/c/tm&quot;&gt;std::tm&lt;/a&gt;&lt;/code&gt; &lt;code&gt;t-&amp;gt;tm_year&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c55bd34e7cff3055dc08d70fe226b40f2972b1b5" translate="yes" xml:space="preserve">
          <source>The partial specialization (5) only exists if &lt;code&gt;std::chrono::treat_as_floating_point_v&amp;lt;Rep&amp;gt;&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;duration&quot;&gt;std::chrono::duration&lt;/a&gt;&amp;lt;Rep, Period&amp;gt;&lt;/code&gt; is not convertible to &lt;code&gt;&lt;a href=&quot;duration&quot;&gt;std::chrono::seconds&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Частичная специализация (5) существует только в том случае, если &lt;code&gt;std::chrono::treat_as_floating_point_v&amp;lt;Rep&amp;gt;&lt;/code&gt; имеет значение &lt;code&gt;false&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;duration&quot;&gt;std::chrono::duration&lt;/a&gt;&amp;lt;Rep, Period&amp;gt;&lt;/code&gt; не может быть преобразовано в &lt;code&gt;&lt;a href=&quot;duration&quot;&gt;std::chrono::seconds&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="23f549c7dd61d901fe54500a09da11aa34be717c" translate="yes" xml:space="preserve">
          <source>The partial specialization of &lt;code&gt;&lt;a href=&quot;../tuple/tuple_size&quot;&gt;std::tuple_size&lt;/a&gt;&lt;/code&gt; for pairs provides a compile-time way to obtain the number of elements in a pair, which is always 2, using tuple-like syntax.</source>
          <target state="translated">Частичная специализация &lt;code&gt;&lt;a href=&quot;../tuple/tuple_size&quot;&gt;std::tuple_size&lt;/a&gt;&lt;/code&gt; для пар обеспечивает способ времени компиляции для получения количества элементов в паре, которое всегда равно 2, с использованием синтаксиса, подобного кортежу.</target>
        </trans-unit>
        <trans-unit id="c5221fc4cfc2057c802611cbc8029455768b8710" translate="yes" xml:space="preserve">
          <source>The partial specializations of &lt;code&gt;&lt;a href=&quot;../tuple/tuple_element&quot;&gt;std::tuple_element&lt;/a&gt;&lt;/code&gt; for pairs provide compile-time access to the types of the pair's elements, using tuple-like syntax. The program is ill-formed if &lt;code&gt;I &amp;gt;= 2&lt;/code&gt;.</source>
          <target state="translated">Частичные специализации &lt;code&gt;&lt;a href=&quot;../tuple/tuple_element&quot;&gt;std::tuple_element&lt;/a&gt;&lt;/code&gt; для пар обеспечивают доступ во время компиляции к типам элементов пары, используя синтаксис, подобный кортежу. Программа некорректна, если &lt;code&gt;I &amp;gt;= 2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c9182a1c88da6a522cf7ab9faaecc8994e994260" translate="yes" xml:space="preserve">
          <source>The partial template specialization of &lt;code&gt;&lt;a href=&quot;../../atomic/atomic&quot;&gt;std::atomic&lt;/a&gt;&lt;/code&gt; for &lt;code&gt;&lt;a href=&quot;../shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt; allows users to manipulate shared_ptr objects atomically.</source>
          <target state="translated">Частичная специализация шаблонов &lt;code&gt;&lt;a href=&quot;../../atomic/atomic&quot;&gt;std::atomic&lt;/a&gt;&lt;/code&gt; для &lt;code&gt;&lt;a href=&quot;../shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt; позволяет пользователям манипулировать объектами shared_ptr атомарно.</target>
        </trans-unit>
        <trans-unit id="eb0acd7ca55c8a975ce7a1790dcea9fa121ca3b5" translate="yes" xml:space="preserve">
          <source>The partial template specialization of &lt;code&gt;&lt;a href=&quot;../../atomic/atomic&quot;&gt;std::atomic&lt;/a&gt;&lt;/code&gt; for &lt;code&gt;&lt;a href=&quot;../weak_ptr&quot;&gt;std::weak_ptr&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt; allows users to manipulate weak_ptr objects atomically.</source>
          <target state="translated">Частичная специализация шаблона &lt;code&gt;&lt;a href=&quot;../../atomic/atomic&quot;&gt;std::atomic&lt;/a&gt;&lt;/code&gt; для &lt;code&gt;&lt;a href=&quot;../weak_ptr&quot;&gt;std::weak_ptr&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt; позволяет пользователям манипулировать объектами weak_ptr атомарно.</target>
        </trans-unit>
        <trans-unit id="3b413e1a3d2902ad2bd6f7353c7ed24fbd704a4c" translate="yes" xml:space="preserve">
          <source>The past-the-end iterator deserves particular mention. In general this iterator is invalidated as though it were a normal iterator to a non-erased element. So &lt;code&gt;&lt;a href=&quot;container/set/end&quot;&gt;std::set::end&lt;/a&gt;&lt;/code&gt; is never invalidated, &lt;code&gt;&lt;a href=&quot;container/unordered_set/end&quot;&gt;std::unordered_set::end&lt;/a&gt;&lt;/code&gt; is invalidated only on rehash, &lt;code&gt;&lt;a href=&quot;container/vector/end&quot;&gt;std::vector::end&lt;/a&gt;&lt;/code&gt; is always invalidated (since it is always after the modified elements), and so on.</source>
          <target state="translated">Последний итератор заслуживает особого упоминания. В общем случае этот итератор считается недействительным, как если бы он был обычным итератором для не стертого элемента. Таким образом, &lt;code&gt;&lt;a href=&quot;container/set/end&quot;&gt;std::set::end&lt;/a&gt;&lt;/code&gt; никогда не аннулируется, &lt;code&gt;&lt;a href=&quot;container/unordered_set/end&quot;&gt;std::unordered_set::end&lt;/a&gt;&lt;/code&gt; становится недействительным только при перефразировании, &lt;code&gt;&lt;a href=&quot;container/vector/end&quot;&gt;std::vector::end&lt;/a&gt;&lt;/code&gt; всегда недействителен (так как это всегда после измененных элементов) и так далее.</target>
        </trans-unit>
        <trans-unit id="4b284ed6473a51bd21fc130bcb9ebaf961cac342" translate="yes" xml:space="preserve">
          <source>The past-the-end iterator is also invalidated unless the erased elements are at the beginning of the container and the last element is not erased.</source>
          <target state="translated">Прошлый итератор также аннулируется,если стертые элементы не находятся в начале контейнера,а последний элемент не стирается.</target>
        </trans-unit>
        <trans-unit id="b0677f6c9e33d408c8fc74dad13a28a32a573cdb" translate="yes" xml:space="preserve">
          <source>The past-the-end iterator may be invalidated (implementation defined)</source>
          <target state="translated">Итератор прошлых лет может быть признан недействительным (реализация определена).</target>
        </trans-unit>
        <trans-unit id="3b5524c20e358d594b020e8bdb5b108f709ab7d9" translate="yes" xml:space="preserve">
          <source>The past-the-end iterator.</source>
          <target state="translated">Прошлый итератор.</target>
        </trans-unit>
        <trans-unit id="5e5a668c57f23b6460fdf63ef2455241134daf73" translate="yes" xml:space="preserve">
          <source>The path &lt;code&gt;&quot;/&quot;&lt;/code&gt; is absolute on a POSIX OS, but is relative on Windows.</source>
          <target state="translated">Путь &lt;code&gt;&quot;/&quot;&lt;/code&gt; является абсолютным в ОС POSIX, но относительным в Windows.</target>
        </trans-unit>
        <trans-unit id="82f5c6939e80a9a4b63791641284d31cb36ab963" translate="yes" xml:space="preserve">
          <source>The path can be traversed element-wise via iterators returned by the &lt;code&gt;&lt;a href=&quot;path/begin&quot;&gt;begin()&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;path/begin&quot;&gt;end()&lt;/a&gt;&lt;/code&gt; functions, which views the path in generic format and iterates over root name, root directory, and the subsequent file name elements (directory separators are skipped except the one that identifies the root directory). If the very last element in the path is a directory separator, the last iterator will dereference to an empty element.</source>
          <target state="translated">Путь может быть пройден поэлементно с помощью итераторов, возвращаемых функциями &lt;code&gt;&lt;a href=&quot;path/begin&quot;&gt;begin()&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;path/begin&quot;&gt;end()&lt;/a&gt;&lt;/code&gt; , который просматривает путь в общем формате и выполняет итерации по корневому имени, корневому каталогу и последующим элементам имени файла (разделители каталогов пропускаются, кроме тот, который идентифицирует корневой каталог). Если самый последний элемент в пути является разделителем каталогов, последний итератор будет разыменовывать пустой элемент.</target>
        </trans-unit>
        <trans-unit id="1e16e300f585e54bf938d0439911d56726dd815b" translate="yes" xml:space="preserve">
          <source>The path constructed from the input string after conversion from UTF-8 to the filesystem's native character encoding.</source>
          <target state="translated">Путь,построенный из входной строки после преобразования из UTF-8 в исходную кодировку файловой системы.</target>
        </trans-unit>
        <trans-unit id="6e603cf030e4d0195d580420c1da816f92ceb1c9" translate="yes" xml:space="preserve">
          <source>The path name has the following syntax:</source>
          <target state="translated">Имя пути имеет следующий синтаксис:</target>
        </trans-unit>
        <trans-unit id="e8eb701045d3a46c2ebb72285abb0e82f58fd37e" translate="yes" xml:space="preserve">
          <source>The path to the parent directory.</source>
          <target state="translated">Путь к родительскому каталогу.</target>
        </trans-unit>
        <trans-unit id="1ceffb6cd0e4fed5091cf63b5f6b9f72943aad5c" translate="yes" xml:space="preserve">
          <source>The perimeter of an ellipse with eccentricity &lt;code&gt;k&lt;/code&gt; and semimajor axis a equals 4aE(k), where E is &lt;code&gt;std::comp_ellint_2&lt;/code&gt;. When eccentricity equals 0, the ellipse degenerates to a circle with radius a and the perimeter equals 2&amp;pi;a, so E(0) = &amp;pi;/2. When eccentricity equals 1, the ellipse degenerates to a line of length 2a, whose perimeter is 4a, so E(1) = 1.</source>
          <target state="translated">Периметр эллипса с эксцентриситетом &lt;code&gt;k&lt;/code&gt; и большой полуосью a равен 4aE (k), где E - это &lt;code&gt;std::comp_ellint_2&lt;/code&gt; . Когда эксцентриситет равен 0, эллипс вырождается в круг с радиусом a, а периметр равен 2&amp;pi;a, поэтому E (0) = &amp;pi; / 2. Когда эксцентриситет равен 1, эллипс вырождается в линию длиной 2а, периметр которой равен 4а, поэтому E (1) = 1.</target>
        </trans-unit>
        <trans-unit id="e4b5a30aa03db848f6592cd57db56eefa2e1e7f9" translate="yes" xml:space="preserve">
          <source>The period of the resulting duration is the greatest common divisor of &lt;code&gt;Period1&lt;/code&gt; and &lt;code&gt;Period2&lt;/code&gt;.</source>
          <target state="translated">Период результирующей продолжительности является наибольшим общим делителем &lt;code&gt;Period1&lt;/code&gt; и &lt;code&gt;Period2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6b1ecc6341dad0825427d240ecf259972a63f062" translate="yes" xml:space="preserve">
          <source>The placeholder &lt;a href=&quot;auto&quot;&gt;auto&lt;/a&gt; can be used in conversion-type-id, indicating a &lt;a href=&quot;function#Return_type_deduction&quot;&gt;deduced return type&lt;/a&gt;:</source>
          <target state="translated">Заполнитель &lt;a href=&quot;auto&quot;&gt;auto&lt;/a&gt; может использоваться в ID-типа-преобразования, указывая &lt;a href=&quot;function#Return_type_deduction&quot;&gt;тип возвращаемого значения&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="11988032bccc6150348612dc3dc97330efc38f94" translate="yes" xml:space="preserve">
          <source>The placeholder &lt;code&gt;auto&lt;/code&gt; may be accompanied by modifiers, such as &lt;code&gt;const&lt;/code&gt; or &lt;code&gt;&amp;amp;&lt;/code&gt;, which will participate in the type deduction. The placeholder &lt;code&gt;decltype(auto)&lt;/code&gt; must be the the sole constituent of the declared type.(since C++14).</source>
          <target state="translated">Заполнитель &lt;code&gt;auto&lt;/code&gt; может сопровождаться модификаторами, такими как &lt;code&gt;const&lt;/code&gt; или &lt;code&gt;&amp;amp;&lt;/code&gt; , которые будут участвовать в выводе типа. Заполнитель &lt;code&gt;decltype(auto)&lt;/code&gt; должен быть единственным компонентом объявленного типа (начиная с C ++ 14).</target>
        </trans-unit>
        <trans-unit id="8188f0beadbdc9f67fbcab0cca288be6624dd85d" translate="yes" xml:space="preserve">
          <source>The placement form &lt;code&gt;void* operator new(std::size_t, std::size_t)&lt;/code&gt; is not allowed because the matching signature of the deallocation function, &lt;code&gt;void operator delete(void*, std::size_t)&lt;/code&gt;, is a usual (not placement) deallocation function.</source>
          <target state="translated">Оператор размещения &lt;code&gt;void* operator new(std::size_t, std::size_t)&lt;/code&gt; недопустим, потому что совпадающая сигнатура функции освобождения, &lt;code&gt;void operator delete(void*, std::size_t)&lt;/code&gt; , обычно (не размещение) функция освобождения.</target>
        </trans-unit>
        <trans-unit id="5912c23fdb49cda02bccb62c7fc1895dae110adc" translate="yes" xml:space="preserve">
          <source>The platform-dependent error value.</source>
          <target state="translated">Зависящее от платформы значение ошибки.</target>
        </trans-unit>
        <trans-unit id="22e0322c3fe2739912f4200c9d7cc04be3a7791f" translate="yes" xml:space="preserve">
          <source>The point of declaration for an &lt;a href=&quot;injected-class-name&quot;&gt;injected-class-name&lt;/a&gt; is immediately following the opening brace of its class (or class template) definition.</source>
          <target state="translated">Точка объявления для &lt;a href=&quot;injected-class-name&quot;&gt;введенного имени класса&lt;/a&gt; следует сразу после открывающей фигурной скобки его определения класса (или шаблона класса).</target>
        </trans-unit>
        <trans-unit id="0cc6d0e2bd00875eb3b647ab691eaf3a40b734e4" translate="yes" xml:space="preserve">
          <source>The point of declaration of a &lt;a href=&quot;structured_binding&quot;&gt;structured binding&lt;/a&gt; is immediately after the identifier-list of the structured binding declaration, but structured binding initializers are prohibited from referring to any of the names being introduced.</source>
          <target state="translated">Точка объявления &lt;a href=&quot;structured_binding&quot;&gt;структурированной привязки&lt;/a&gt; находится сразу после списка идентификаторов объявления структурированной привязки, но инициализаторам структурированной привязки запрещено ссылаться на любое из вводимых имен.</target>
        </trans-unit>
        <trans-unit id="d2eaa3ef9aed1f964e68ecd40fdb0b4090b12a22" translate="yes" xml:space="preserve">
          <source>The point of declaration of a &lt;a href=&quot;type_alias&quot;&gt;type alias or alias template&lt;/a&gt; is immediately after the type-id to which the alias refers:</source>
          <target state="translated">Точка объявления &lt;a href=&quot;type_alias&quot;&gt;псевдонима типа или шаблона псевдонима&lt;/a&gt; находится сразу после идентификатора типа, к которому относится псевдоним:</target>
        </trans-unit>
        <trans-unit id="fead0939c1b9750ab484b917a8bc503ed969f8da" translate="yes" xml:space="preserve">
          <source>The point of declaration of a class or template is immediately after the identifier that names the class (or the &lt;a href=&quot;templates#template-id&quot;&gt;template-id&lt;/a&gt; that names the template specialization) appears in its &lt;a href=&quot;classes&quot;&gt;class-head&lt;/a&gt;, and is already in scope in the list of the base classes:</source>
          <target state="translated">Точка объявления класса или шаблона находится сразу после того, как идентификатор, который называет класс (или &lt;a href=&quot;templates#template-id&quot;&gt;идентификатор шаблона,&lt;/a&gt; который называет специализацию шаблона), появляется в его &lt;a href=&quot;classes&quot;&gt;заголовке класса&lt;/a&gt; и уже находится в области видимости в списке базовых классов:</target>
        </trans-unit>
        <trans-unit id="9f0644324f7e4cf1aefd74a5866f04764d1f1056" translate="yes" xml:space="preserve">
          <source>The point of declaration of an enumeration is immediately after the identifier that names it appears in the &lt;a href=&quot;enum&quot;&gt;enum specifier&lt;/a&gt; or opaque enum declaration, whichever is used first:</source>
          <target state="translated">Точка объявления перечисления находится сразу после идентификатора, имена которого появляются в &lt;a href=&quot;enum&quot;&gt;спецификаторе перечисления&lt;/a&gt; или непрозрачном объявлении перечисления, в зависимости от того, что используется первым:</target>
        </trans-unit>
        <trans-unit id="47421c40dd3c8897ae17db10f6de7045e0604b49" translate="yes" xml:space="preserve">
          <source>The point of declaration of an enumerator is immediately after its definition (not before the initializer as it is for variables):</source>
          <target state="translated">Точка объявления перечислителя находится сразу после его определения (не перед инициализатором,как для переменных):</target>
        </trans-unit>
        <trans-unit id="82b67920a9148c6fc228fb43bc313b703cc12c0e" translate="yes" xml:space="preserve">
          <source>The pointed-to type of a pointer-to-member may be a pointer-to-member itself: pointers to members can be multilevel, and can be cv-qualifed differently at every level. Mixed multi-level combinations of pointers and pointers-to-members are also allowed:</source>
          <target state="translated">Тип указателя на члена может быть указателем на самого члена:указатели на членов могут быть многоуровневыми и могут быть cv-квалифицированы по-разному на каждом уровне.Допускаются также смешанные многоуровневые комбинации указателей и указателей на членов:</target>
        </trans-unit>
        <trans-unit id="857df6b1a996ed03a792d5426b8be017166c9590" translate="yes" xml:space="preserve">
          <source>The pointer held by &lt;code&gt;*this&lt;/code&gt;.</source>
          <target state="translated">Указатель, удерживаемый &lt;code&gt;*this&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1a569ae03f99a2e029c35053360ec402ea8825c3" translate="yes" xml:space="preserve">
          <source>The pointer held by the &lt;code&gt;shared_ptr&lt;/code&gt; directly is the one returned by &lt;code&gt;&lt;a href=&quot;shared_ptr/get&quot;&gt;get()&lt;/a&gt;&lt;/code&gt;, while the pointer/object held by the control block is the one that will be deleted when the number of shared owners reaches zero. These pointers are not necessarily equal.</source>
          <target state="translated">Указатель, &lt;code&gt;shared_ptr&lt;/code&gt; непосредственно в shared_ptr, является указателем, возвращаемым функцией &lt;code&gt;&lt;a href=&quot;shared_ptr/get&quot;&gt;get()&lt;/a&gt;&lt;/code&gt; , а указатель / объект, содержащийся в блоке управления, будет удален, когда число общих владельцев достигнет нуля. Эти указатели не обязательно равны.</target>
        </trans-unit>
        <trans-unit id="0b9194591fdc314a0ecc3f4298cf510d1793c0b0" translate="yes" xml:space="preserve">
          <source>The pointer is such that the range &lt;code&gt;[c_str(); c_str() + size()]&lt;/code&gt; is valid and the values in it correspond to the values stored in the string with an additional null character after the last position.</source>
          <target state="translated">Указатель таков, что range &lt;code&gt;[c_str(); c_str() + size()]&lt;/code&gt; является допустимым, и значения в нем соответствуют значениям, хранящимся в строке с дополнительным нулевым символом после последней позиции.</target>
        </trans-unit>
        <trans-unit id="bc4de43f158ae279800dabe183ad787c290be28c" translate="yes" xml:space="preserve">
          <source>The pointer obtained from &lt;code&gt;c_str()&lt;/code&gt; may be invalidated by:</source>
          <target state="translated">Указатель, полученный из &lt;code&gt;c_str()&lt;/code&gt; может быть признан недействительным:</target>
        </trans-unit>
        <trans-unit id="25f266f248c76589a2ccd4234acbb0c2d4e4eacd" translate="yes" xml:space="preserve">
          <source>The pointer obtained from &lt;code&gt;c_str()&lt;/code&gt; may only be treated as a pointer to a null-terminated character string if the string object does not contain other null characters.</source>
          <target state="translated">Указатель, полученный из &lt;code&gt;c_str()&lt;/code&gt; может рассматриваться как указатель на символьную строку с нулевым символом в конце, если строковый объект не содержит других нулевых символов.</target>
        </trans-unit>
        <trans-unit id="83480f14010d5cb1f67d2563b68adf44bf7bc56e" translate="yes" xml:space="preserve">
          <source>The pointer obtained from &lt;code&gt;data()&lt;/code&gt; may be invalidated by:</source>
          <target state="translated">Указатель, полученный из &lt;code&gt;data()&lt;/code&gt; может быть признан недействительным:</target>
        </trans-unit>
        <trans-unit id="f8a783b19ce6451ba52b4dc182db830ef0e17f42" translate="yes" xml:space="preserve">
          <source>The pointer returned by the call to &lt;code&gt;a.allocate(n)&lt;/code&gt;.</source>
          <target state="translated">Указатель, возвращаемый при вызове &lt;code&gt;a.allocate(n)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="62efe07fde27af3eb6cd42fa101df3a460a161fb" translate="yes" xml:space="preserve">
          <source>The pointer safety used by this implementation.</source>
          <target state="translated">Безопасность указателя,используемая этой реализацией.</target>
        </trans-unit>
        <trans-unit id="cdcc993eb7230b5cf2a0e319e9141223d606af16" translate="yes" xml:space="preserve">
          <source>The pointer to convert</source>
          <target state="translated">Указатель на преобразование</target>
        </trans-unit>
        <trans-unit id="3616897fc4a7fb62d60e2791e6f3b00f4006b358" translate="yes" xml:space="preserve">
          <source>The pointer to the allocated storage.</source>
          <target state="translated">Указатель на выделенное хранилище.</target>
        </trans-unit>
        <trans-unit id="3c8844a746827bb53e8a970ddaf5df27d6244fac" translate="yes" xml:space="preserve">
          <source>The pointer to the block of storage to be reclaimed is passed to the &lt;a href=&quot;../memory/new/operator_delete&quot;&gt;deallocation function&lt;/a&gt; that was selected by the process above as the first argument. The size of the block is passed as the optional &lt;code&gt;std::size_t&lt;/code&gt; argument. The alignment requirement is passed as the optional &lt;code&gt;std::align_val_t&lt;/code&gt; argument.(since C++17).</source>
          <target state="translated">Указатель на блок памяти, подлежащий восстановлению, передается &lt;a href=&quot;../memory/new/operator_delete&quot;&gt;функции освобождения,&lt;/a&gt; которая была выбрана вышеописанным процессом в качестве первого аргумента. Размер блока передается как необязательный аргумент &lt;code&gt;std::size_t&lt;/code&gt; . Требование выравнивания передается как необязательный аргумент &lt;code&gt;std::align_val_t&lt;/code&gt; . ( Начиная с C ++ 17).</target>
        </trans-unit>
        <trans-unit id="2f9790c4ee1ba3e3c2d585a13b1c938331446c70" translate="yes" xml:space="preserve">
          <source>The popular Edsger W. Dijkstra essay, &lt;a href=&quot;http://david.tribble.com/text/goto.html&quot;&gt;&amp;ldquo;Goto Considered Harmful&amp;rdquo;&lt;/a&gt;, presents a survey of the many subtle problems the careless use of this keyword can introduce.</source>
          <target state="translated">В популярном эссе Эдсгера В. Дейкстры &lt;a href=&quot;http://david.tribble.com/text/goto.html&quot;&gt;&amp;laquo;Гото считается вредным&amp;raquo;&lt;/a&gt; представлен обзор многих тонких проблем, которые может привести неосторожное использование этого ключевого слова.</target>
        </trans-unit>
        <trans-unit id="3db1aee0e463b1a7e37a693db9028dc4dd6c01b3" translate="yes" xml:space="preserve">
          <source>The portion of the declaration preceding &lt;code&gt;[&lt;/code&gt; applies to the hidden variable &lt;code&gt;&lt;i&gt;e&lt;/i&gt;&lt;/code&gt;, not to the introduced identifiers.</source>
          <target state="translated">Часть объявления, предшествующая &lt;code&gt;[&lt;/code&gt; , применяется к скрытой переменной &lt;code&gt;&lt;i&gt;e&lt;/i&gt;&lt;/code&gt; , а не к введенным идентификаторам.</target>
        </trans-unit>
        <trans-unit id="63e5a10c38c160db27db345693a402cc1e1242ee" translate="yes" xml:space="preserve">
          <source>The position of the first character of the specified match or sub-match.</source>
          <target state="translated">Положение первого символа указанного матча или подматча.</target>
        </trans-unit>
        <trans-unit id="28cd458ec55f909805d8bb05b742449475997ff5" translate="yes" xml:space="preserve">
          <source>The possible values for this type (&lt;code&gt;icase&lt;/code&gt;, &lt;code&gt;optimize&lt;/code&gt;, etc.) are duplicated inside &lt;a href=&quot;basic_regex/constants&quot;&gt;std::basic_regex&lt;/a&gt;.</source>
          <target state="translated">Возможные значения для этого типа ( &lt;code&gt;icase&lt;/code&gt; , &lt;code&gt;optimize&lt;/code&gt; и т. Д.) Дублируются внутри &lt;a href=&quot;basic_regex/constants&quot;&gt;std :: basic_regex&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f158078e6b12f488989a09d27a17236fe92bc958" translate="yes" xml:space="preserve">
          <source>The possible values of FLT_ROUNDS match the possible values of &lt;code&gt;&lt;a href=&quot;../numeric_limits/float_round_style&quot;&gt;std::float_round_style&lt;/a&gt;&lt;/code&gt;, returned by &lt;code&gt;&lt;a href=&quot;../numeric_limits/round_style&quot;&gt;std::numeric_limits::round_style&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Возможные значения FLT_ROUNDS соответствуют возможным значениям &lt;code&gt;&lt;a href=&quot;../numeric_limits/float_round_style&quot;&gt;std::float_round_style&lt;/a&gt;&lt;/code&gt; , возвращаемым &lt;code&gt;&lt;a href=&quot;../numeric_limits/round_style&quot;&gt;std::numeric_limits::round_style&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="eb1f284e6c90d25d80dca04b6d988a3435fc3bfd" translate="yes" xml:space="preserve">
          <source>The postconditions are as follows:</source>
          <target state="translated">Постусловия таковы:</target>
        </trans-unit>
        <trans-unit id="61121624309d02b453ed84455806314e9c9e17f9" translate="yes" xml:space="preserve">
          <source>The postfix increment and decrement expressions have the form.</source>
          <target state="translated">Постфиксный инкремент и декремент имеют форму.</target>
        </trans-unit>
        <trans-unit id="6bb958d510683e21b0e77aaa67075c099774e223" translate="yes" xml:space="preserve">
          <source>The potential scope of a function parameter (including parameters of a lambda expression) or of a function-local predefined variable begins at its point of declaration.</source>
          <target state="translated">Потенциальная область действия параметра функции (включая параметры выражения лямбда)или предопределенной функции-локальной переменной начинается с момента ее объявления.</target>
        </trans-unit>
        <trans-unit id="f221d1f923c37987bf0e3c89da004e995c3dde61" translate="yes" xml:space="preserve">
          <source>The potential scope of a name declared in a &lt;a href=&quot;class&quot;&gt;class&lt;/a&gt; begins at the point of declaration and includes the rest of the class body and all function bodies (even if defined outside the class definition or before the declaration of the name), default arguments, exception specifications, in-class brace-or-equal initializers, &lt;a href=&quot;attributes/contract&quot;&gt;contract conditions&lt;/a&gt;(since C++20), and all these things in nested classes, recursively.</source>
          <target state="translated">Потенциальная область действия имени, объявленного в &lt;a href=&quot;class&quot;&gt;классе,&lt;/a&gt; начинается с точки объявления и включает остальную часть тела класса и все тела функций (даже если они определены вне определения класса или до объявления имени), аргументы по умолчанию, спецификации исключений рекурсивно в инициализаторах класса или скобках в классе, &lt;a href=&quot;attributes/contract&quot;&gt;условий контракта&lt;/a&gt; (начиная с C ++ 20) и всего этого во вложенных классах.</target>
        </trans-unit>
        <trans-unit id="2d5497083d21c504b3ed59ade0ed30f3ffbb92bc" translate="yes" xml:space="preserve">
          <source>The potential scope of a name declared in an exception handler begins at the point of declaration and ends when the exception handler ends, and is not in scope in another exception handler or in the enclosing block.</source>
          <target state="translated">Потенциальный объем имени,объявленного в обработчике исключения,начинается с момента объявления и заканчивается в момент окончания обработчика исключения,и не входит в объем другого обработчика исключения или в прилагаемый блок.</target>
        </trans-unit>
        <trans-unit id="86aa2a90d28cbbde1fb0589dd802c3a11b1e29f7" translate="yes" xml:space="preserve">
          <source>The potential scope of a name declared in the</source>
          <target state="translated">Потенциальный объем имени,заявленного в</target>
        </trans-unit>
        <trans-unit id="a17d45e1f219a3300a9f28b3d08fce8f429503aa" translate="yes" xml:space="preserve">
          <source>The potential scope of a template parameter name begins immediately at the point of declaration and continues to the end of the smallest template declaration in which it was introduced. In particular, a template parameter can be used in the declarations of subsequent template parameters and in the specifications of base classes, but can't be used in the declarations of the preceding template parameters.</source>
          <target state="translated">Потенциальный объем имени параметра шаблона начинается непосредственно с момента объявления и продолжается до конца наименьшего шаблонного объявления,в котором оно было введено.В частности,шаблонный параметр может использоваться в объявлениях последующих шаблонных параметров и в спецификациях базовых классов,но не может использоваться в объявлениях предыдущих шаблонных параметров.</target>
        </trans-unit>
        <trans-unit id="32a82cbca985e3e0dfa23c0dbaf5a6027c95d501" translate="yes" xml:space="preserve">
          <source>The potential scope of a variable introduced by a declaration in a &lt;a href=&quot;statements#Compound_statements&quot;&gt;block (compound statement)&lt;/a&gt; begins at the point of declaration and ends at the end of the block. Actual scope is the same as potential scope unless there is a nested block with a declaration that introduces identical name (in which case, the entire potential scope of the nested declaration is excluded from the scope of the outer declaration).</source>
          <target state="translated">Потенциальная область действия переменной, представленной объявлением в &lt;a href=&quot;statements#Compound_statements&quot;&gt;блоке (составной оператор),&lt;/a&gt; начинается в точке объявления и заканчивается в конце блока. Фактическая область действия такая же, как и потенциальная область действия, если только нет вложенного блока с объявлением, которое вводит идентичное имя (в этом случае вся потенциальная область действия вложенного объявления исключается из области действия внешнего объявления).</target>
        </trans-unit>
        <trans-unit id="3ba3386f44571d8f14970c593d609182dd9626af" translate="yes" xml:space="preserve">
          <source>The potential scope of any entity declared in a &lt;a href=&quot;namespace&quot;&gt;namespace&lt;/a&gt; begins at the declaration and consists of the concatenation of all namespace definitions for the same namespace name that follow, plus, for any &lt;a href=&quot;namespace&quot;&gt;using-directive&lt;/a&gt; that introduced this name or its entire namespace into another scope, the rest of that scope.</source>
          <target state="translated">Потенциальная область действия любой сущности, объявленной в &lt;a href=&quot;namespace&quot;&gt;пространстве имен,&lt;/a&gt; начинается с объявления и состоит из объединения всех определений пространства имен для того же имени пространства имен, которое следует, плюс для любой &lt;a href=&quot;namespace&quot;&gt;директивы using,&lt;/a&gt; которая ввела это имя или все его пространство имен в другую область, остальная часть этого объема.</target>
        </trans-unit>
        <trans-unit id="4ae5d318818acfe339b9d375cb9ce2cfc0456829" translate="yes" xml:space="preserve">
          <source>The potential scope of the name of the parameter of a template template parameter is the smallest template parameter list in which that name appears.</source>
          <target state="translated">Потенциальная область действия имени параметра шаблона-наименьший список параметров шаблона,в котором это имя появляется.</target>
        </trans-unit>
        <trans-unit id="124da4714b4bf54af7be4c07efe71d32136057e5" translate="yes" xml:space="preserve">
          <source>The precision of the result is at least &lt;code&gt;std::chrono::seconds&lt;/code&gt;, and will be finer if the argument has finer precision.</source>
          <target state="translated">Точность результата равна как минимум &lt;code&gt;std::chrono::seconds&lt;/code&gt; , и будет более точной, если аргумент имеет более высокую точность.</target>
        </trans-unit>
        <trans-unit id="a20b15248f8c5353561f8b4cb6be91d86d20e646" translate="yes" xml:space="preserve">
          <source>The predicate of a contract condition has the same semantic restrictions as if it appeared as the first &lt;a href=&quot;../statements#Expression_statements&quot;&gt;expression statement&lt;/a&gt; in the body of the function it applies to.</source>
          <target state="translated">Предикат условия контракта имеет те же семантические ограничения, как если бы он появился в качестве первого &lt;a href=&quot;../statements#Expression_statements&quot;&gt;выражения выражения&lt;/a&gt; в теле функции, к которой он применяется.</target>
        </trans-unit>
        <trans-unit id="e2463bc948c065d9d75e509585a1ee11887f0dca" translate="yes" xml:space="preserve">
          <source>The prefix increment and decrement expressions have the form.</source>
          <target state="translated">Префиксные выражения инкремента и декремента имеют форму.</target>
        </trans-unit>
        <trans-unit id="05a52076d2dc5c8b894927a5e244dc4ac56fe7ce" translate="yes" xml:space="preserve">
          <source>The preprocessing directives control the behavior of the preprocessor. Each directive occupies one line and has the following format:</source>
          <target state="translated">Директивы препроцессинга контролируют поведение препроцессора.Каждая директива занимает одну строку и имеет следующий формат:</target>
        </trans-unit>
        <trans-unit id="cb413a6249ff3f9ad8dd052d27dcc328f60aee81" translate="yes" xml:space="preserve">
          <source>The preprocessor has the source file translation capabilities:</source>
          <target state="translated">Препроцессор имеет возможности перевода исходных файлов:</target>
        </trans-unit>
        <trans-unit id="6aa350ea11bb9c5aa25e6e5ec9306cca0035172c" translate="yes" xml:space="preserve">
          <source>The preprocessor is executed at &lt;a href=&quot;language/translation_phases&quot;&gt;translation phase 4&lt;/a&gt;, before the compilation. The result of preprocessing is a single file which is then passed to the actual compiler.</source>
          <target state="translated">Препроцессор выполняется на &lt;a href=&quot;language/translation_phases&quot;&gt;этапе 4 трансляции&lt;/a&gt; , перед компиляцией. Результатом предварительной обработки является отдельный файл, который затем передается фактическому компилятору.</target>
        </trans-unit>
        <trans-unit id="e2bdd9572501029c63f84fab6d94f93d8f91603f" translate="yes" xml:space="preserve">
          <source>The preprocessor supports conditional compilation of parts of source file. This behavior is controlled by &lt;code&gt;#if&lt;/code&gt;, &lt;code&gt;#else&lt;/code&gt;, &lt;code&gt;#elif&lt;/code&gt;, &lt;code&gt;#ifdef&lt;/code&gt;, &lt;code&gt;#ifndef&lt;/code&gt; and &lt;code&gt;#endif&lt;/code&gt; directives.</source>
          <target state="translated">Препроцессор поддерживает условную компиляцию частей исходного файла. Такое поведение контролируется &lt;code&gt;#if&lt;/code&gt; , &lt;code&gt;#else&lt;/code&gt; , &lt;code&gt;#elif&lt;/code&gt; , &lt;code&gt;#ifdef&lt;/code&gt; , &lt;code&gt;#ifndef&lt;/code&gt; и &lt;code&gt;#endif&lt;/code&gt; директивы.</target>
        </trans-unit>
        <trans-unit id="d389a7945641ac5522e189cd36aef892dd202d1a" translate="yes" xml:space="preserve">
          <source>The preprocessor supports text macro replacement. Function-like text macro replacement is also supported.</source>
          <target state="translated">Препроцессор поддерживает замену текстовых макросов.Также поддерживается функциональная замена текстовых макросов.</target>
        </trans-unit>
        <trans-unit id="0e2ac736e4b9518fd1201761b13af480e31f9a2e" translate="yes" xml:space="preserve">
          <source>The previous locale, as returned by &lt;code&gt;ios_base::imbue(loc)&lt;/code&gt;.</source>
          <target state="translated">Предыдущая локаль, возвращаемая &lt;code&gt;ios_base::imbue(loc)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4e848927c4ddc2faed727fdcad88567a9f851617" translate="yes" xml:space="preserve">
          <source>The previous value of the global C++ locale.</source>
          <target state="translated">Предыдущее значение глобальной локали С++.</target>
        </trans-unit>
        <trans-unit id="cf70cdf040bccb32e02858713f2da17f9c793063" translate="yes" xml:space="preserve">
          <source>The previously-installed new handler, or a null pointer value if none was installed.</source>
          <target state="translated">Ранее установленный новый обработчик,или нулевое значение указателя,если ни один из них не был установлен.</target>
        </trans-unit>
        <trans-unit id="a35f0efbfe83164488e9c67a5958dce490abc58e" translate="yes" xml:space="preserve">
          <source>The previously-installed terminate handler, or a null pointer value if none was installed.</source>
          <target state="translated">Ранее установленный обработчик завершения,или нулевое значение указателя,если ни один из них не был установлен.</target>
        </trans-unit>
        <trans-unit id="d1f9375683ee644e852554818b0e7f65b024d681" translate="yes" xml:space="preserve">
          <source>The previously-installed unexpected handler, or a null pointer value if none was installed.</source>
          <target state="translated">Ранее установленный неожиданный обработчик,или нулевое значение указателя,если ни один из них не был установлен.</target>
        </trans-unit>
        <trans-unit id="9af84654120543bdc403c77640e19172f575072a" translate="yes" xml:space="preserve">
          <source>The primary &lt;code&gt;std::atomic&lt;/code&gt; template may be instantiated with any &lt;a href=&quot;../named_req/triviallycopyable&quot;&gt;TriviallyCopyable&lt;/a&gt; type &lt;code&gt;T&lt;/code&gt; satisfying both &lt;a href=&quot;../named_req/copyconstructible&quot;&gt;CopyConstructible&lt;/a&gt; and &lt;a href=&quot;../named_req/copyassignable&quot;&gt;CopyAssignable&lt;/a&gt;. The program is ill-formed if any of following values is &lt;code&gt;false&lt;/code&gt;:</source>
          <target state="translated">Первичный шаблон &lt;code&gt;std::atomic&lt;/code&gt; может быть &lt;a href=&quot;../named_req/triviallycopyable&quot;&gt;создан&lt;/a&gt; с любым типом &lt;code&gt;T&lt;/code&gt; &lt;a href=&quot;../named_req/copyconstructible&quot;&gt;TriviallyCopyable,&lt;/a&gt; удовлетворяющим как CopyConstructible, так и &lt;a href=&quot;../named_req/copyassignable&quot;&gt;CopyAssignable&lt;/a&gt; . Программа некорректна, если любое из следующих значений &lt;code&gt;false&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="175466bae183473a68237507d57dfae6c15d71d1" translate="yes" xml:space="preserve">
          <source>The primary &lt;code&gt;std::atomic_ref&lt;/code&gt; template may be instantiated with any &lt;a href=&quot;../named_req/triviallycopyable&quot;&gt;TriviallyCopyable&lt;/a&gt; type &lt;code&gt;T&lt;/code&gt; (including &lt;code&gt;bool&lt;/code&gt;):</source>
          <target state="translated">Первичный шаблон &lt;code&gt;std::atomic_ref&lt;/code&gt; может быть &lt;a href=&quot;../named_req/triviallycopyable&quot;&gt;создан&lt;/a&gt; с любым типом TriviallyCopyable &lt;code&gt;T&lt;/code&gt; (включая &lt;code&gt;bool&lt;/code&gt; ):</target>
        </trans-unit>
        <trans-unit id="7b6fd84220d2a0c86df329eafb7ba3556e2d99b3" translate="yes" xml:space="preserve">
          <source>The primary purpose of function-try-blocks is to respond to an exception thrown from the member initializer list in a constructor by logging and rethrowing, modifying the exception object and rethrowing, throwing a different exception instead, or terminating the program. They are rarely used with destructors or with regular functions.</source>
          <target state="translated">Основное назначение функций-три-блоков-реагировать на исключение,брошенное из списка инициализаторов членов в конструкторе,протоколируя и перебрасывая,изменяя объект исключения и перебрасывая,бросая вместо него другое исключение,или завершая программу.Они редко используются с деструкторами или с обычными функциями.</target>
        </trans-unit>
        <trans-unit id="3f7bdf2c45988d2e398ec47fc464d9bf36ad8ecc" translate="yes" xml:space="preserve">
          <source>The primary sort key for the character sequence &lt;code&gt;[first, last)&lt;/code&gt; in the currently imbued locale, ignoring case, variant, diacritics, etc.</source>
          <target state="translated">Основной ключ сортировки для последовательности символов &lt;code&gt;[first, last)&lt;/code&gt; в текущей набранной локали, игнорируя регистр, вариант, диакритические знаки и т. Д.</target>
        </trans-unit>
        <trans-unit id="f9b3c50b7c4e0adf0fa987d32fbfaf6e0639923e" translate="yes" xml:space="preserve">
          <source>The primary template (1) is not defined; four specializations are provided to handle four different levels of precision.</source>
          <target state="translated">Основной шаблон (1)не определен;предусмотрены четыре специализации для работы с четырьмя различными уровнями точности.</target>
        </trans-unit>
        <trans-unit id="4f13817f1998ddc17a9521a91f34ffa2754e64b4" translate="yes" xml:space="preserve">
          <source>The primary template is an empty struct. The standard defines the following specializations:</source>
          <target state="translated">Основной шаблон-пустая структура.Стандарт определяет следующие специализации:</target>
        </trans-unit>
        <trans-unit id="32aa772a60f7448e2e58e9b419a72a7e62908590" translate="yes" xml:space="preserve">
          <source>The primary template is empty. A specialization is provided for &lt;code&gt;const &lt;a href=&quot;time_zone&quot;&gt;std::chrono::time_zone&lt;/a&gt;*&lt;/code&gt;, the default time zone pointer type.</source>
          <target state="translated">Основной шаблон пуст. Специализация предоставляется для &lt;code&gt;const &lt;a href=&quot;time_zone&quot;&gt;std::chrono::time_zone&lt;/a&gt;*&lt;/code&gt; , тип указателя часового пояса по умолчанию.</target>
        </trans-unit>
        <trans-unit id="5795dc517124b691e8ea332cfeb4ab8696d76a2b" translate="yes" xml:space="preserve">
          <source>The primary use of &lt;code&gt;&lt;a href=&quot;../vector&quot;&gt;std::vector&lt;/a&gt;&amp;lt;bool&amp;gt;::reference&lt;/code&gt; is to provide an l-value that can be returned from &lt;code&gt;operator[]&lt;/code&gt;.</source>
          <target state="translated">Основное использование &lt;code&gt;&lt;a href=&quot;../vector&quot;&gt;std::vector&lt;/a&gt;&amp;lt;bool&amp;gt;::reference&lt;/code&gt; - предоставить l-значение, которое может быть возвращено &lt;code&gt;operator[]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="895b09aec5064e185b6472594b973b52d8ec16a6" translate="yes" xml:space="preserve">
          <source>The primary use of &lt;code&gt;std::bitset::reference&lt;/code&gt; is to provide an l-value that can be returned from &lt;a href=&quot;operator_at&quot;&gt;&lt;code&gt;operator[]&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Основное использование &lt;code&gt;std::bitset::reference&lt;/code&gt; - предоставить l-значение, которое может быть возвращено &lt;a href=&quot;operator_at&quot;&gt; &lt;code&gt;operator[]&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="44ca87a7b0da64f5b77109af8b1bf5da6aee13a7" translate="yes" xml:space="preserve">
          <source>The private &lt;code&gt;std::weak_ptr&amp;lt;T&amp;gt;&lt;/code&gt; member is not affected by this assignment operator.</source>
          <target state="translated">Этот закрытый член &lt;code&gt;std::weak_ptr&amp;lt;T&amp;gt;&lt;/code&gt; не затронут этим оператором присваивания.</target>
        </trans-unit>
        <trans-unit id="b15b5ef90ed5ddcf44be29f564148c6afcb6afcc" translate="yes" xml:space="preserve">
          <source>The probability of &lt;code&gt;h(a)==h(b)&lt;/code&gt; for &lt;code&gt;a!=b&lt;/code&gt; should approach &lt;code&gt;1.0/&lt;a href=&quot;../types/numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;&lt;a href=&quot;../types/size_t&quot;&gt;std::size_t&lt;/a&gt;&amp;gt;::max()&lt;/code&gt;.</source>
          <target state="translated">Вероятность &lt;code&gt;h(a)==h(b)&lt;/code&gt; для &lt;code&gt;a!=b&lt;/code&gt; должна приближаться к &lt;code&gt;1.0/&lt;a href=&quot;../types/numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;&lt;a href=&quot;../types/size_t&quot;&gt;std::size_t&lt;/a&gt;&amp;gt;::max()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="95fdc02e0f2a75a69ee3b45caa87c045c455c0be" translate="yes" xml:space="preserve">
          <source>The program is ill-formed</source>
          <target state="translated">Программа плохо сформирована</target>
        </trans-unit>
        <trans-unit id="f17c9446e3d0891d6f0a550093638571c34482fa" translate="yes" xml:space="preserve">
          <source>The program is ill-formed if &lt;code&gt;(std::is_same_v&amp;lt;T, U&amp;gt; &amp;amp;&amp;amp; ...)&lt;/code&gt; is not true.</source>
          <target state="translated">Программа некорректна, если &lt;code&gt;(std::is_same_v&amp;lt;T, U&amp;gt; &amp;amp;&amp;amp; ...)&lt;/code&gt; не соответствует действительности.</target>
        </trans-unit>
        <trans-unit id="80681cb4437f6410dadbaf99fd1bc0640c36b450" translate="yes" xml:space="preserve">
          <source>The program is ill-formed if &lt;code&gt;Duration&lt;/code&gt; is not a specialization of &lt;code&gt;&lt;a href=&quot;duration&quot;&gt;std::chrono::duration&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Программа некорректна, если &lt;code&gt;Duration&lt;/code&gt; не является специализацией &lt;code&gt;&lt;a href=&quot;duration&quot;&gt;std::chrono::duration&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ba17539f8936e17a1b0aee08e3a960ba67a68e62" translate="yes" xml:space="preserve">
          <source>The program is ill-formed if &lt;code&gt;N&lt;/code&gt; is negative. If &lt;code&gt;N&lt;/code&gt; is zero, the indicated type is &lt;code&gt;integer_sequence&amp;lt;T&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">Программа плохо сформирована, если &lt;code&gt;N&lt;/code&gt; отрицательно. Если &lt;code&gt;N&lt;/code&gt; равно нулю, указанным типом является &lt;code&gt;integer_sequence&amp;lt;T&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d5a8f5795052236111eac68e22aa48d3e329cc1b" translate="yes" xml:space="preserve">
          <source>The program is ill-formed if &lt;code&gt;N&lt;/code&gt; is not a power of 2. The behavior is undefined if &lt;code&gt;ptr&lt;/code&gt; does not point to an object of type &lt;code&gt;T&lt;/code&gt; (ignoring cv-qualification at every level), or if the object's alignment is not at least &lt;code&gt;N&lt;/code&gt;.</source>
          <target state="translated">Программа плохо сформирована, если &lt;code&gt;N&lt;/code&gt; не является степенью 2. Поведение не определено, если &lt;code&gt;ptr&lt;/code&gt; не указывает на объект типа &lt;code&gt;T&lt;/code&gt; (игнорируя квалификацию cv на каждом уровне), или если выравнивание объекта не меньше, чем &lt;code&gt;N&lt;/code&gt; ,</target>
        </trans-unit>
        <trans-unit id="67bdd1bd8f7bc35a5850d5aff836099617861a78" translate="yes" xml:space="preserve">
          <source>The program is ill-formed if &lt;code&gt;T&lt;/code&gt; is a function type or (possibly cv-qualified) &lt;code&gt;void&lt;/code&gt;.</source>
          <target state="translated">Программа плохо сформирована, если &lt;code&gt;T&lt;/code&gt; является типом функции или (возможно, cv-квалифицированным) &lt;code&gt;void&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="965acd7bfed42ab433acdc02bbf59b653e8dc291" translate="yes" xml:space="preserve">
          <source>The program is ill-formed if an explicit or partial specialization of &lt;code&gt;std::initializer_list&lt;/code&gt; is declared.</source>
          <target state="translated">Программа плохо сформирована, если объявлена ​​явная или частичная специализация &lt;code&gt;std::initializer_list&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a07725707756ca1bff455b3ddbe27d61f7822a9f" translate="yes" xml:space="preserve">
          <source>The program is ill-formed if any of the following is not &lt;code&gt;true&lt;/code&gt;:</source>
          <target state="translated">Программа некорректна, если любое из следующего не &lt;code&gt;true&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="f0c2c540025d21052bca08f15510071c65acf1a0" translate="yes" xml:space="preserve">
          <source>The program is well-formed (compiles) only if there exists one unambiguous</source>
          <target state="translated">Программа хорошо сформирована (компилируется)только в том случае,если существует однозначный</target>
        </trans-unit>
        <trans-unit id="86e09b8d70231ec8b200a5fc3393b854ca51d06f" translate="yes" xml:space="preserve">
          <source>The programmer must ensure that no threads attempt to wait on &lt;code&gt;*this&lt;/code&gt; once the destructor has been started, especially when the waiting threads are calling the wait functions in a loop or are using the overloads of the wait functions that take a predicate.</source>
          <target state="translated">Программист должен убедиться, что никакие потоки не будут &lt;code&gt;*this&lt;/code&gt; ожидать этого, как только деструктор будет запущен, особенно когда ожидающие потоки вызывают функции ожидания в цикле или используют перегрузки функций ожидания, которые принимают предикат.</target>
        </trans-unit>
        <trans-unit id="74ef69212c8f3a8d15110cc0d0e198f7faccc793" translate="yes" xml:space="preserve">
          <source>The programming language &lt;a href=&quot;https://en.wikipedia.org/wiki/CPL_(programming_language)&quot;&gt;CPL&lt;/a&gt; was first to introduce value categories for expressions: all CPL expressions can be evaluated in &quot;right-hand mode&quot;, but only certain kinds of expression are meaningful in &quot;left-hand mode&quot;. When evaluated in right-hand mode, an expression is regarded as being a rule for the computation of a value (the right-hand value, or</source>
          <target state="translated">Язык программирования &lt;a href=&quot;https://en.wikipedia.org/wiki/CPL_(programming_language)&quot;&gt;CPL&lt;/a&gt; был первым, кто ввел категории значений для выражений: все выражения CPL могут оцениваться в &amp;laquo;режиме правой руки&amp;raquo;, но только &amp;laquo;определенные виды выражений&amp;raquo; имеют смысл в &amp;laquo;режиме левой руки&amp;raquo;. При оценке в правостороннем режиме выражение рассматривается как правило для вычисления значения (правого значения или</target>
        </trans-unit>
        <trans-unit id="67ad89355eacc86b3d6314eddebeebee7f14036d" translate="yes" xml:space="preserve">
          <source>The promise is the &quot;push&quot; end of the promise-future communication channel: the operation that stores a value in the shared state</source>
          <target state="translated">Обещание-это &quot;толкающий&quot; конец promise-future канала связи:операция,сохраняющая ценность в общем состоянии.</target>
        </trans-unit>
        <trans-unit id="3f2caa469d3c691e3afe5b09718f95bd2b49a72b" translate="yes" xml:space="preserve">
          <source>The public functions of &lt;code&gt;&lt;a href=&quot;../basic_streambuf&quot;&gt;std::streambuf&lt;/a&gt;&lt;/code&gt; call this function only if &lt;code&gt;gptr() == nullptr&lt;/code&gt; or &lt;code&gt;gptr() &amp;gt;= egptr()&lt;/code&gt;.</source>
          <target state="translated">Публичные функции &lt;code&gt;&lt;a href=&quot;../basic_streambuf&quot;&gt;std::streambuf&lt;/a&gt;&lt;/code&gt; вызывают эту функцию, только если &lt;code&gt;gptr() == nullptr&lt;/code&gt; или &lt;code&gt;gptr() &amp;gt;= egptr()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="775a778b55294eaa175c0471abd743cb50326787" translate="yes" xml:space="preserve">
          <source>The purpose of strict aliasing and related rules is to enable type-based alias analysis, which would be decimated if a program can validly create a situation where two pointers to unrelated types (e.g., an &lt;code&gt;int*&lt;/code&gt; and a &lt;code&gt;float*&lt;/code&gt;) could simultaneously exist and both can be used to load or store the same memory (see &lt;a href=&quot;http://www.open-std.org/pipermail/ub/2016-February/000565.html&quot;&gt;this email on SG12 reflector&lt;/a&gt;). Thus, any technique that is seemingly capable of creating such a situation necessarily invokes undefined behavior.</source>
          <target state="translated">Цель строгих псевдонимов и связанных с ними правил состоит в том, чтобы включить анализ псевдонимов на основе типов, который был бы уничтожен, если бы программа могла правильно создать ситуацию, в которой два указателя на несвязанные типы (например, &lt;code&gt;int*&lt;/code&gt; и &lt;code&gt;float*&lt;/code&gt; ) могли бы одновременно существовать и оба могут использоваться для загрузки или хранения одной и той же памяти (см. &lt;a href=&quot;http://www.open-std.org/pipermail/ub/2016-February/000565.html&quot;&gt;это письмо на отражателе SG12&lt;/a&gt; ). Таким образом, любая техника, способная создать такую ​​ситуацию, обязательно вызывает неопределенное поведение.</target>
        </trans-unit>
        <trans-unit id="537f9c0125fb3b536c8c2bddb97b517098935b00" translate="yes" xml:space="preserve">
          <source>The purpose of this adaptor is to correctly initialize stateful allocators in nested containers, such as when all levels of a nested container must be placed in the same shared memory segment. The adaptor's constructor takes the arguments for all allocators in the list, and each nested container obtains its allocator's state from the adaptor as needed.</source>
          <target state="translated">Назначение этого адаптера-правильно инициализировать статические аллокаторы во вложенных контейнерах,например,когда все уровни вложенного контейнера должны быть помещены в один и тот же сегмент общей памяти.Конструктор адаптера принимает аргументы для всех аллокаторов в списке,и каждый вложенный контейнер получает состояние своего аллокатора от адаптера по мере необходимости.</target>
        </trans-unit>
        <trans-unit id="7c2a811b6c5574010f60bbd62805b17f3c0731ed" translate="yes" xml:space="preserve">
          <source>The purpose of this exception type is similar to the error condition &lt;code&gt;&lt;a href=&quot;../errc&quot;&gt;std::errc::invalid_argument&lt;/a&gt;&lt;/code&gt; (thrown in &lt;code&gt;&lt;a href=&quot;../system_error&quot;&gt;std::system_error&lt;/a&gt;&lt;/code&gt; from member functions of &lt;code&gt;&lt;a href=&quot;../../thread/thread&quot;&gt;std::thread&lt;/a&gt;&lt;/code&gt;) and the related errno constant &lt;code&gt;&lt;a href=&quot;../errno_macros&quot;&gt;EINVAL&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Назначение этого типа исключения аналогично условию ошибки &lt;code&gt;&lt;a href=&quot;../errc&quot;&gt;std::errc::invalid_argument&lt;/a&gt;&lt;/code&gt; (выбрасывается в &lt;code&gt;&lt;a href=&quot;../system_error&quot;&gt;std::system_error&lt;/a&gt;&lt;/code&gt; из функций-членов &lt;code&gt;&lt;a href=&quot;../../thread/thread&quot;&gt;std::thread&lt;/a&gt;&lt;/code&gt; ) и связанной с ним константе errno &lt;code&gt;&lt;a href=&quot;../errno_macros&quot;&gt;EINVAL&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1e645b45a5ffa08db62d4e0d26bad721f50ada62" translate="yes" xml:space="preserve">
          <source>The purpose of this rule is to help guard against violations of the &lt;a href=&quot;definition#One_Definition_Rule&quot;&gt;ODR&lt;/a&gt; for template instantiations:</source>
          <target state="translated">Цель этого правила состоит в том, чтобы помочь предотвратить нарушения &lt;a href=&quot;definition#One_Definition_Rule&quot;&gt;ODR&lt;/a&gt; для шаблонов:</target>
        </trans-unit>
        <trans-unit id="e80a3e01ac05bea47ec62aef3af475352cd5d29f" translate="yes" xml:space="preserve">
          <source>The question mark escape sequence &lt;code&gt;\?&lt;/code&gt; is used to prevent &lt;a href=&quot;operator_alternative&quot;&gt;trigraphs&lt;/a&gt; from being interpreted inside string literals: a string such as &lt;code&gt;&quot;??/&quot;&lt;/code&gt; is compiled as &lt;code&gt;&quot;\&quot;&lt;/code&gt;, but if the second question mark is escaped, as in &lt;code&gt;&quot;?\?/&quot;&lt;/code&gt;, it becomes &lt;code&gt;&quot;??/&quot;&lt;/code&gt;</source>
          <target state="translated">Escape-последовательность вопросительного знака &lt;code&gt;\?&lt;/code&gt; используется для предотвращения интерпретации &lt;a href=&quot;operator_alternative&quot;&gt;триграфов&lt;/a&gt; внутри строковых литералов: строка, такая как &lt;code&gt;&quot;??/&quot;&lt;/code&gt; , компилируется как &lt;code&gt;&quot;\&quot;&lt;/code&gt; , но если после второго знака вопроса, как в &lt;code&gt;&quot;?\?/&quot;&lt;/code&gt; , она становится &lt;code&gt;&quot;??/&quot;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="20eb771689c7638596c471df8669135309db406f" translate="yes" xml:space="preserve">
          <source>The quiet NaN value that corresponds to the identifying string &lt;code&gt;arg&lt;/code&gt; or zero if the implementation does not support quiet NaNs.</source>
          <target state="translated">Значение тихого NaN, которое соответствует идентифицирующей строке &lt;code&gt;arg&lt;/code&gt; или нулю, если реализация не поддерживает тихие NaN.</target>
        </trans-unit>
        <trans-unit id="eeac3ad06c66b3de50e5a83b3d29765e5993887a" translate="yes" xml:space="preserve">
          <source>The quotient is rounded in implementation-defined direction.</source>
          <target state="translated">Коэффициент округляется в направлении,определенном реализацией.</target>
        </trans-unit>
        <trans-unit id="ee33d1b33c8c2f838818ad7eab65d1c620ffa44b" translate="yes" xml:space="preserve">
          <source>The quotient is the algebraic quotient with any fractional part discarded (truncated towards zero). The remainder is such that &lt;code&gt;quot * y + rem == x&lt;/code&gt;.</source>
          <target state="translated">Частное является алгебраическим частным с любой отброшенной дробной частью (усеченной до нуля). Остаток таков, что &lt;code&gt;quot * y + rem == x&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="501288be26edd4ded7871c5498abfbb8d63a43ff" translate="yes" xml:space="preserve">
          <source>The quotient is the result of the expression &lt;code&gt;x/y&lt;/code&gt;. The remainder is the result of the expression &lt;code&gt;x%y&lt;/code&gt;.</source>
          <target state="translated">Частное является результатом выражения &lt;code&gt;x/y&lt;/code&gt; . Остальная часть является результатом выражения &lt;code&gt;x%y&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0fcb33188a4836ac6fb56038cd09dd6ed5942b11" translate="yes" xml:space="preserve">
          <source>The quotient is truncated towards zero (fractional part is discarded).</source>
          <target state="translated">Коэффициент усекается в сторону нуля (дробная часть отбрасывается).</target>
        </trans-unit>
        <trans-unit id="9dadf256e2d94d3cccaced5125b0d93a91578c9e" translate="yes" xml:space="preserve">
          <source>The random number library provides classes that generate random and pseudo-random numbers. These classes include:</source>
          <target state="translated">Библиотека случайных чисел предоставляет классы,генерирующие случайные и псевдослучайные числа.Эти классы включают в себя:</target>
        </trans-unit>
        <trans-unit id="b2af36c522baaa6141e4d68a47e9b38cf32d1814" translate="yes" xml:space="preserve">
          <source>The range &lt;code&gt;[first, last)&lt;/code&gt; must be at least partially ordered with respect to &lt;code&gt;value&lt;/code&gt;, i.e. it must satisfy all of the following requirements:</source>
          <target state="translated">Диапазон &lt;code&gt;[first, last)&lt;/code&gt; должен быть хотя бы частично упорядочен относительно &lt;code&gt;value&lt;/code&gt; , то есть он должен удовлетворять всем следующим требованиям:</target>
        </trans-unit>
        <trans-unit id="cc9d0a4e1c6b28a575aa6a4d6fa56412715ff389" translate="yes" xml:space="preserve">
          <source>The range &lt;code&gt;[first, last)&lt;/code&gt; must be partitioned with respect to the expression &lt;code&gt;!(value &amp;lt; element)&lt;/code&gt; or &lt;code&gt;!comp(value, element)&lt;/code&gt;, i.e., all elements for which the expression is &lt;code&gt;true&lt;/code&gt; must precede all elements for which the expression is &lt;code&gt;false&lt;/code&gt;. A fully-sorted range meets this criterion.</source>
          <target state="translated">Диапазон &lt;code&gt;[first, last)&lt;/code&gt; должен быть разделен по отношению к выражению &lt;code&gt;!(value &amp;lt; element)&lt;/code&gt; или &lt;code&gt;!comp(value, element)&lt;/code&gt; , т. Е. Все элементы, для которых выражение является &lt;code&gt;true&lt;/code&gt; должны предшествовать всем элементам, для которых выражение является &lt;code&gt;false&lt;/code&gt; , Полностью отсортированный диапазон соответствует этому критерию.</target>
        </trans-unit>
        <trans-unit id="531a6257f348bdfa0bffcab8f3aeb4dc7a540c17" translate="yes" xml:space="preserve">
          <source>The range &lt;code&gt;[first, last)&lt;/code&gt; must be partitioned with respect to the expression &lt;code&gt;element &amp;lt; value&lt;/code&gt; or &lt;code&gt;comp(element, value)&lt;/code&gt;, i.e., all elements for which the expression is &lt;code&gt;true&lt;/code&gt; must precede all elements for which the expression is &lt;code&gt;false&lt;/code&gt;. A fully-sorted range meets this criterion.</source>
          <target state="translated">Диапазон &lt;code&gt;[first, last)&lt;/code&gt; должен быть разделен по отношению к &lt;code&gt;element &amp;lt; value&lt;/code&gt; выражения &amp;lt;value или &lt;code&gt;comp(element, value)&lt;/code&gt; , т. Е. Все элементы, для которых выражение является &lt;code&gt;true&lt;/code&gt; должны предшествовать всем элементам, для которых выражение является &lt;code&gt;false&lt;/code&gt; . Полностью отсортированный диапазон соответствует этому критерию.</target>
        </trans-unit>
        <trans-unit id="17dad5b9e23c675ce64ce4c16ba529098428b325" translate="yes" xml:space="preserve">
          <source>The ranges library provides components for dealing with ranges of elements, including a variety of view adapters.</source>
          <target state="translated">Библиотека диапазонов содержит компоненты для работы с диапазонами элементов,включая различные адаптеры видов.</target>
        </trans-unit>
        <trans-unit id="bce2ca348110e7ef080f1a3a0d8246186d739693" translate="yes" xml:space="preserve">
          <source>The rank of the standard conversion sequence is the worst of the ranks of the standard conversions it holds (there may be up to &lt;a href=&quot;implicit_cast&quot;&gt;three conversions&lt;/a&gt;).</source>
          <target state="translated">Ранг стандартной конверсионной последовательности является худшим из рангов стандартных конверсий, которые он имеет (может быть до &lt;a href=&quot;implicit_cast&quot;&gt;трех конверсий&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="ebf3fa4c200bf79dc188b73503ec27a644a93938" translate="yes" xml:space="preserve">
          <source>The raw pointer overloads assume ownership of the pointed-to object. Therefore, constructing a &lt;code&gt;shared_ptr&lt;/code&gt; using the raw pointer overload for an object that is already managed by a &lt;code&gt;shared_ptr&lt;/code&gt;, such as by &lt;code&gt;shared_ptr(ptr.get())&lt;/code&gt; is likely to lead to undefined behavior, even if the object is of a type derived from &lt;code&gt;&lt;a href=&quot;../enable_shared_from_this&quot;&gt;std::enable_shared_from_this&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Перегрузки необработанного указателя предполагают владение указанным объектом. Следовательно, создание &lt;code&gt;shared_ptr&lt;/code&gt; с использованием перегрузки необработанного указателя для объекта, которым уже управляет &lt;code&gt;shared_ptr&lt;/code&gt; , например &lt;code&gt;shared_ptr(ptr.get())&lt;/code&gt; , может привести к неопределенному поведению, даже если объект имеет тип, производный от &lt;code&gt;&lt;a href=&quot;../enable_shared_from_this&quot;&gt;std::enable_shared_from_this&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ad324bd2c8bc22b00758a73ea2fd6b6e48382778" translate="yes" xml:space="preserve">
          <source>The reallocation is done by either:</source>
          <target state="translated">Перераспределение осуществляется либо тем,либо другим:</target>
        </trans-unit>
        <trans-unit id="cb5dae53afd6af85ce084febad2ae76f3864e626" translate="yes" xml:space="preserve">
          <source>The rebind member template alias makes it possible, given a pointer-like type that points to T, to obtain the same pointer-like type that points to U. For example,</source>
          <target state="translated">Псевдоним шаблона перепривязки позволяет,при наличии указателя-подобного типа,указывающего на T,получить тот же указатель-подобный тип,который указывает на U.Например,</target>
        </trans-unit>
        <trans-unit id="3a46abffdd1369d6dca8a8856866579f7f37a7e3" translate="yes" xml:space="preserve">
          <source>The recognized byte order marks are:</source>
          <target state="translated">Распознанные метки порядка байтов:</target>
        </trans-unit>
        <trans-unit id="39e0ee2810678b74b9059ddc4c64426403f4f32c" translate="yes" xml:space="preserve">
          <source>The reference may be invalidated by any operation on this &lt;code&gt;ios_base&lt;/code&gt; object, including another call to &lt;code&gt;iword()&lt;/code&gt;, but the stored values are retained, so that reading from &lt;code&gt;iword(index)&lt;/code&gt; with the same index later will produce the same value (until the next call to &lt;code&gt;&lt;a href=&quot;../basic_ios/copyfmt&quot;&gt;std::basic_ios::copyfmt()&lt;/a&gt;&lt;/code&gt;). The value can be used for any purpose. The index of the element must be obtained by a previous call to &lt;code&gt;&lt;a href=&quot;xalloc&quot;&gt;xalloc()&lt;/a&gt;&lt;/code&gt;, otherwise the behavior is undefined. New elements are initialized to &lt;code&gt;​0​&lt;/code&gt;.</source>
          <target state="translated">Ссылка может быть признана недействительной любой операцией над этим объектом &lt;code&gt;ios_base&lt;/code&gt; , включая другой вызов &lt;code&gt;iword()&lt;/code&gt; , но сохраненные значения сохраняются, так что чтение из &lt;code&gt;iword(index)&lt;/code&gt; с тем же индексом позже приведет к тому же значению (до следующего вызов &lt;code&gt;&lt;a href=&quot;../basic_ios/copyfmt&quot;&gt;std::basic_ios::copyfmt()&lt;/a&gt;&lt;/code&gt; ). Значение может быть использовано для любых целей. Индекс элемента должен быть получен предыдущим вызовом &lt;code&gt;&lt;a href=&quot;xalloc&quot;&gt;xalloc()&lt;/a&gt;&lt;/code&gt; , в противном случае поведение не определено. Новые элементы инициализируются &lt;code&gt;​0​&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6ac5c33641fd17dd4dcc39d735304c205b8e343f" translate="yes" xml:space="preserve">
          <source>The reference may be invalidated by any operation on this &lt;code&gt;ios_base&lt;/code&gt; object, including another call to &lt;code&gt;pword()&lt;/code&gt;, but the stored values are retained, so that reading from &lt;code&gt;pword(index)&lt;/code&gt; with the same index later will produce the same value (until the next call to &lt;code&gt;copyfmt()&lt;/code&gt;). The value can be used for any purpose. The index of the element must be obtained by &lt;code&gt;&lt;a href=&quot;xalloc&quot;&gt;xalloc()&lt;/a&gt;&lt;/code&gt;, otherwise the behavior is undefined. New elements are initialized to &lt;code&gt;&lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Ссылка может быть признана недействительной любой операцией над этим объектом &lt;code&gt;ios_base&lt;/code&gt; , включая другой вызов &lt;code&gt;pword()&lt;/code&gt; , но сохраненные значения сохраняются, так что чтение из &lt;code&gt;pword(index)&lt;/code&gt; с тем же индексом позже приведет к тому же значению (до следующего вызовите &lt;code&gt;copyfmt()&lt;/code&gt; ). Значение может быть использовано для любых целей. Индекс элемента должен быть получен с помощью &lt;code&gt;&lt;a href=&quot;xalloc&quot;&gt;xalloc()&lt;/a&gt;&lt;/code&gt; , в противном случае поведение не определено. Новые элементы инициализируются в &lt;code&gt;&lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f727f18de8aecc68a97ca4d05e8709c96ae21252" translate="yes" xml:space="preserve">
          <source>The referenced bit.</source>
          <target state="translated">Ссылающийся бит.</target>
        </trans-unit>
        <trans-unit id="01bad1a5bcb168d5223121e0f4bf36c7d217674b" translate="yes" xml:space="preserve">
          <source>The regex iterators are used to traverse the entire set of regular expression matches found within a sequence.</source>
          <target state="translated">Регекс-итераторы используются для того,чтобы обойти весь набор найденных в последовательности совпадений регулярных выражений.</target>
        </trans-unit>
        <trans-unit id="743f5a5a38b3f31dca5dec3dbda309eac3fee182" translate="yes" xml:space="preserve">
          <source>The regex library uses this trait to match characters against equivalence classes. For example, the regex &lt;code&gt;[[=a=]]&lt;/code&gt; is equivalent to the character &lt;code&gt;c1&lt;/code&gt; if &lt;code&gt;traits.transform_primary(c1)&lt;/code&gt; is equivalent to &lt;code&gt;traits.transform_primary(&quot;a&quot;)&lt;/code&gt; (which is true for any &lt;code&gt;c1&lt;/code&gt; from &lt;code&gt;&quot;A&amp;Agrave;&amp;Aacute;&amp;Acirc;&amp;Atilde;&amp;Auml;&amp;Aring;a&amp;agrave;&amp;aacute;&amp;acirc;&amp;atilde;&amp;auml;&amp;aring;&quot;&lt;/code&gt; in the U.S. English locale). Note that &lt;code&gt;transform_primary()&lt;/code&gt; takes a character sequence argument because equivalence classes may be multicharacter, such as &lt;code&gt;[[=ch=]]&lt;/code&gt; in Czech or &lt;code&gt;[[=dzs=]]&lt;/code&gt; in Hungarian.</source>
          <target state="translated">Библиотека регулярных выражений использует эту черту для сопоставления символов с классами эквивалентности. Например, регулярное выражение &lt;code&gt;[[=a=]]&lt;/code&gt; эквивалентно символу &lt;code&gt;c1&lt;/code&gt; , если &lt;code&gt;traits.transform_primary(c1)&lt;/code&gt; эквивалентно &lt;code&gt;traits.transform_primary(&quot;a&quot;)&lt;/code&gt; (что верно для любого &lt;code&gt;c1&lt;/code&gt; из &lt;code&gt;&quot;A&amp;Agrave;&amp;Aacute;&amp;Acirc;&amp;Atilde;&amp;Auml;&amp;Aring;a&amp;agrave;&amp;aacute;&amp;acirc;&amp;atilde;&amp;auml;&amp;aring;&quot;&lt;/code&gt; в США. Английский язык). Обратите внимание, что &lt;code&gt;transform_primary()&lt;/code&gt; принимает аргумент символьной последовательности, поскольку классы эквивалентности могут иметь несколько символов, например &lt;code&gt;[[=ch=]]&lt;/code&gt; на чешском языке или &lt;code&gt;[[=dzs=]]&lt;/code&gt; на венгерском языке.</target>
        </trans-unit>
        <trans-unit id="9f22234d3d01dbb3d192f98f1564dcc90f3845ce" translate="yes" xml:space="preserve">
          <source>The regex traits class is used to encapsulate the localizable aspects of a regex.</source>
          <target state="translated">Класс регексных признаков используется для инкапсуляции локализуемых аспектов регекса.</target>
        </trans-unit>
        <trans-unit id="8e02428e99c6a674a0fa0458c46a3675989e16b2" translate="yes" xml:space="preserve">
          <source>The registered functions will not be called on &lt;a href=&quot;exit&quot;&gt;normal program termination&lt;/a&gt;. If a function need to be called in that case, &lt;code&gt;&lt;a href=&quot;atexit&quot;&gt;std::atexit&lt;/a&gt;&lt;/code&gt; must be used.</source>
          <target state="translated">Зарегистрированные функции не будут вызываться при &lt;a href=&quot;exit&quot;&gt;нормальном завершении программы&lt;/a&gt; . Если в этом случае требуется вызвать функцию, необходимо использовать &lt;code&gt;&lt;a href=&quot;atexit&quot;&gt;std::atexit&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f472a11dda174644bf194c3cc7207153d73cf754" translate="yes" xml:space="preserve">
          <source>The regular expressions library provides a class that represents &lt;a href=&quot;https://en.wikipedia.org/wiki/Regular_expression&quot;&gt;regular expressions&lt;/a&gt;, which are a kind of mini-language used to perform pattern matching within strings. Almost all operations with regexes can be characterized by operating on several of the following objects:</source>
          <target state="translated">Библиотека регулярных выражений предоставляет класс, который представляет &lt;a href=&quot;https://en.wikipedia.org/wiki/Regular_expression&quot;&gt;регулярные выражения&lt;/a&gt; , которые являются своего рода мини-языком, используемым для сопоставления с образцом в строках. Почти все операции с регулярными выражениями можно охарактеризовать, работая с несколькими из следующих объектов:</target>
        </trans-unit>
        <trans-unit id="2e11489a7a30fc1b23c96dca40b2ff8e966f4c67" translate="yes" xml:space="preserve">
          <source>The related POSIX function &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/popen.html&quot;&gt;popen&lt;/a&gt; makes the output generated by &lt;code&gt;command&lt;/code&gt; available to the caller.</source>
          <target state="translated">Связанная функция POSIX &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/popen.html&quot;&gt;popen&lt;/a&gt; делает вывод, сгенерированный &lt;code&gt;command&lt;/code&gt; доступным для вызывающей стороны.</target>
        </trans-unit>
        <trans-unit id="882b56e07684c56a82fb47ac99ca4f95e58df12c" translate="yes" xml:space="preserve">
          <source>The related POSIX function &lt;a href=&quot;https://pubs.opengroup.org/onlinepubs/9699919799/functions/popen.html&quot;&gt;popen&lt;/a&gt; makes the output generated by &lt;code&gt;command&lt;/code&gt; available to the caller.</source>
          <target state="translated">Связанная функция POSIX &lt;a href=&quot;https://pubs.opengroup.org/onlinepubs/9699919799/functions/popen.html&quot;&gt;popen&lt;/a&gt; делает вывод, сгенерированный &lt;code&gt;command&lt;/code&gt; доступным для вызывающего.</target>
        </trans-unit>
        <trans-unit id="315f5ac4df7e6df130a13d2b962900690dfeac97" translate="yes" xml:space="preserve">
          <source>The related function &lt;code&gt;&lt;a href=&quot;puts&quot;&gt;std::puts&lt;/a&gt;&lt;/code&gt; appends a newline character to the output, while &lt;code&gt;std::fputs&lt;/code&gt; writes the string unmodified.</source>
          <target state="translated">Связанная функция &lt;code&gt;&lt;a href=&quot;puts&quot;&gt;std::puts&lt;/a&gt;&lt;/code&gt; добавляет символ вывода новой строки к выводу, в то время как &lt;code&gt;std::fputs&lt;/code&gt; записывает строку без изменений.</target>
        </trans-unit>
        <trans-unit id="d291a968b1bde0de4066d9697100b3323d6aed59" translate="yes" xml:space="preserve">
          <source>The removal of the top-level cv-qualifiers does not affect the type of the parameter as it appears within the function:</source>
          <target state="translated">Удаление cv-квалификаторов верхнего уровня не влияет на тип параметра,как он появляется внутри функции:</target>
        </trans-unit>
        <trans-unit id="5f57795c7e42d94ba6cd16bf8ded7489abce05bb" translate="yes" xml:space="preserve">
          <source>The replaceable deallocation functions (1-10) are implicitly declared in each translation unit even if the &lt;code&gt;&amp;lt;new&amp;gt;&lt;/code&gt; header is not included. These functions are</source>
          <target state="translated">Сменные функции освобождения (1-10) неявно объявляются в каждой единице перевода, даже если заголовок &lt;code&gt;&amp;lt;new&amp;gt;&lt;/code&gt; не включен. Эти функции</target>
        </trans-unit>
        <trans-unit id="757b1dc67e0f36307d54e167b8d8bfa8908ff42c" translate="yes" xml:space="preserve">
          <source>The representation of the named collating element as a character string.</source>
          <target state="translated">Представление именованного коллекционирующего элемента в виде строки символов.</target>
        </trans-unit>
        <trans-unit id="b55071f5f9ba9ea7bf92c82884c22a3d16d81678" translate="yes" xml:space="preserve">
          <source>The representation type of &lt;code&gt;C1::duration&lt;/code&gt;.</source>
          <target state="translated">Тип представления &lt;code&gt;C1::duration&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1064d717e4d3fd4142b0aa2898a18bce9888f7d4" translate="yes" xml:space="preserve">
          <source>The requested subspan &lt;code&gt;r&lt;/code&gt;, such that &lt;code&gt;r.data() == this-&amp;gt;data() + Offset&lt;/code&gt;. If &lt;code&gt;Count&lt;/code&gt; is &lt;code&gt;std::dynamic_extent&lt;/code&gt;, &lt;code&gt;r.size() == this-&amp;gt;size() - Offset&lt;/code&gt;; otherwise &lt;code&gt;r.size() == Count&lt;/code&gt;.</source>
          <target state="translated">Запрашиваемый подпанель &lt;code&gt;r&lt;/code&gt; , такой что &lt;code&gt;r.data() == this-&amp;gt;data() + Offset&lt;/code&gt; . Если &lt;code&gt;Count&lt;/code&gt; равен &lt;code&gt;std::dynamic_extent&lt;/code&gt; , &lt;code&gt;r.size() == this-&amp;gt;size() - Offset&lt;/code&gt; ; в противном случае &lt;code&gt;r.size() == Count&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fe5a8c15412cf1fce3c28473df37a2f3d1062165" translate="yes" xml:space="preserve">
          <source>The requirements that are imposed on the elements depend on the actual operations performed on the container. Generally, it is required that element type is a complete type and meets the requirements of &lt;a href=&quot;../named_req/eraseable&quot;&gt;Erasable&lt;/a&gt;, but many member functions impose stricter requirements.</source>
          <target state="translated">Требования, предъявляемые к элементам, зависят от фактических операций, выполняемых над контейнером. Как правило, требуется, чтобы тип элемента был полным и соответствовал требованиям &lt;a href=&quot;../named_req/eraseable&quot;&gt;Erasable&lt;/a&gt; , но многие функции-члены предъявляют более строгие требования.</target>
        </trans-unit>
        <trans-unit id="f623316ac29c804d31fa0890dce0da472d8e6d58" translate="yes" xml:space="preserve">
          <source>The requirements that are imposed on the elements depend on the actual operations performed on the container. Generally, it is required that element type meets the requirements of &lt;a href=&quot;../named_req/eraseable&quot;&gt;Erasable&lt;/a&gt;, but many member functions impose stricter requirements. This container (but not its members) can be instantiated with an incomplete element type if the allocator satisfies the &lt;a href=&quot;../named_req/allocator#Allocator_completeness_requirements&quot;&gt;allocator completeness requirements&lt;/a&gt;.</source>
          <target state="translated">Требования, предъявляемые к элементам, зависят от фактических операций, выполняемых над контейнером. Как правило, требуется, чтобы тип элемента соответствовал требованиям &lt;a href=&quot;../named_req/eraseable&quot;&gt;Erasable&lt;/a&gt; , но многие функции-члены предъявляют более строгие требования. Этот контейнер (но не его члены) может быть создан с неполным типом элемента, если распределитель удовлетворяет &lt;a href=&quot;../named_req/allocator#Allocator_completeness_requirements&quot;&gt;требованиям полноты распределителя&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7e9510a237cd6950e335a276b93cd34d804cbc1a" translate="yes" xml:space="preserve">
          <source>The result is</source>
          <target state="translated">В результате</target>
        </trans-unit>
        <trans-unit id="c3b6b8e653050978d1c05509c50d363265c5437e" translate="yes" xml:space="preserve">
          <source>The result is &lt;code&gt;false&lt;/code&gt; if the expression contains at least one of the following potentially evaluated constructs:</source>
          <target state="translated">Результат равен &lt;code&gt;false&lt;/code&gt; , если выражение содержит хотя бы одну из следующих потенциально оцененных конструкций:</target>
        </trans-unit>
        <trans-unit id="d1a4aaa48d46c71750bcb89a022288521d191ab7" translate="yes" xml:space="preserve">
          <source>The result is &lt;code&gt;true&lt;/code&gt; if the set of &lt;a href=&quot;except_spec&quot;&gt;&lt;i&gt;potential exceptions&lt;/i&gt;&lt;/a&gt; of the expression is empty, and &lt;code&gt;false&lt;/code&gt; otherwise.</source>
          <target state="translated">Результат равен &lt;code&gt;true&lt;/code&gt; , если набор &lt;a href=&quot;except_spec&quot;&gt;&lt;i&gt;потенциальных исключений&lt;/i&gt;&lt;/a&gt; выражения пуст, и &lt;code&gt;false&lt;/code&gt; в противном случае.</target>
        </trans-unit>
        <trans-unit id="be94375a32ef05e8f88fd30d56ae6e5233b9d27e" translate="yes" xml:space="preserve">
          <source>The result is a &lt;code&gt;&lt;a href=&quot;ratio&quot;&gt;std::ratio&lt;/a&gt;&lt;/code&gt; specialization &lt;code&gt;&lt;a href=&quot;ratio&quot;&gt;std::ratio&lt;/a&gt;&amp;lt;U, V&amp;gt;&lt;/code&gt;, such that given &lt;code&gt;Num == R1::num * R2::den + R2::num * R1::den&lt;/code&gt; and &lt;code&gt;Denom == R1::den * R2::den&lt;/code&gt; (computed without arithmetic overflow), &lt;code&gt;U&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;ratio&quot;&gt;std::ratio&lt;/a&gt;&amp;lt;Num, Denom&amp;gt;::num&lt;/code&gt; and &lt;code&gt;V&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;ratio&quot;&gt;std::ratio&lt;/a&gt;&amp;lt;Num, Denom&amp;gt;::den&lt;/code&gt;.</source>
          <target state="translated">Результатом является &lt;code&gt;&lt;a href=&quot;ratio&quot;&gt;std::ratio&lt;/a&gt;&lt;/code&gt; специализации &lt;code&gt;&lt;a href=&quot;ratio&quot;&gt;std::ratio&lt;/a&gt;&amp;lt;U, V&amp;gt;&lt;/code&gt; , такое , что при &lt;code&gt;Num == R1::num * R2::den + R2::num * R1::den&lt;/code&gt; и &lt;code&gt;Denom == R1::den * R2::den&lt;/code&gt; (вычисляется без арифметического переполнения), &lt;code&gt;U&lt;/code&gt; - это &lt;code&gt;&lt;a href=&quot;ratio&quot;&gt;std::ratio&lt;/a&gt;&amp;lt;Num, Denom&amp;gt;::num&lt;/code&gt; а &lt;code&gt;V&lt;/code&gt; - это &lt;code&gt;&lt;a href=&quot;ratio&quot;&gt;std::ratio&lt;/a&gt;&amp;lt;Num, Denom&amp;gt;::den&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2524aa66759b404de95e3dd437f92ac60fcc7942" translate="yes" xml:space="preserve">
          <source>The result is a &lt;code&gt;&lt;a href=&quot;ratio&quot;&gt;std::ratio&lt;/a&gt;&lt;/code&gt; specialization &lt;code&gt;&lt;a href=&quot;ratio&quot;&gt;std::ratio&lt;/a&gt;&amp;lt;U, V&amp;gt;&lt;/code&gt;, such that given &lt;code&gt;Num == R1::num * R2::den - R2::num * R1::den&lt;/code&gt; and &lt;code&gt;Denom == R1::den * R2::den&lt;/code&gt; (computed without arithmetic overflow), &lt;code&gt;U&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;ratio&quot;&gt;std::ratio&lt;/a&gt;&amp;lt;Num, Denom&amp;gt;::num&lt;/code&gt; and &lt;code&gt;V&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;ratio&quot;&gt;std::ratio&lt;/a&gt;&amp;lt;Num, Denom&amp;gt;::den&lt;/code&gt;.</source>
          <target state="translated">Результатом является &lt;code&gt;&lt;a href=&quot;ratio&quot;&gt;std::ratio&lt;/a&gt;&lt;/code&gt; специализации &lt;code&gt;&lt;a href=&quot;ratio&quot;&gt;std::ratio&lt;/a&gt;&amp;lt;U, V&amp;gt;&lt;/code&gt; , такое , что при &lt;code&gt;Num == R1::num * R2::den - R2::num * R1::den&lt;/code&gt; и &lt;code&gt;Denom == R1::den * R2::den&lt;/code&gt; (вычисляется без арифметического переполнения), &lt;code&gt;U&lt;/code&gt; - это &lt;code&gt;&lt;a href=&quot;ratio&quot;&gt;std::ratio&lt;/a&gt;&amp;lt;Num, Denom&amp;gt;::num&lt;/code&gt; а &lt;code&gt;V&lt;/code&gt; - это &lt;code&gt;&lt;a href=&quot;ratio&quot;&gt;std::ratio&lt;/a&gt;&amp;lt;Num, Denom&amp;gt;::den&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="acb3b2cb8d2a5ff6feda727827cb87392d9546ad" translate="yes" xml:space="preserve">
          <source>The result is a &lt;code&gt;&lt;a href=&quot;ratio&quot;&gt;std::ratio&lt;/a&gt;&lt;/code&gt; specialization &lt;code&gt;&lt;a href=&quot;ratio&quot;&gt;std::ratio&lt;/a&gt;&amp;lt;U, V&amp;gt;&lt;/code&gt;, such that given &lt;code&gt;Num == R1::num * R2::den&lt;/code&gt; and &lt;code&gt;Denom == R1::den * R2::num&lt;/code&gt; (computed without arithmetic overflow), &lt;code&gt;U&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;ratio&quot;&gt;std::ratio&lt;/a&gt;&amp;lt;Num, Denom&amp;gt;::num&lt;/code&gt; and &lt;code&gt;V&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;ratio&quot;&gt;std::ratio&lt;/a&gt;&amp;lt;Num, Denom&amp;gt;::den&lt;/code&gt;.</source>
          <target state="translated">Результатом является &lt;code&gt;&lt;a href=&quot;ratio&quot;&gt;std::ratio&lt;/a&gt;&lt;/code&gt; специализации &lt;code&gt;&lt;a href=&quot;ratio&quot;&gt;std::ratio&lt;/a&gt;&amp;lt;U, V&amp;gt;&lt;/code&gt; , такое , что при &lt;code&gt;Num == R1::num * R2::den&lt;/code&gt; и &lt;code&gt;Denom == R1::den * R2::num&lt;/code&gt; (вычисляется без арифметическое переполнение), &lt;code&gt;U&lt;/code&gt; - это &lt;code&gt;&lt;a href=&quot;ratio&quot;&gt;std::ratio&lt;/a&gt;&amp;lt;Num, Denom&amp;gt;::num&lt;/code&gt; а &lt;code&gt;V&lt;/code&gt; - это &lt;code&gt;&lt;a href=&quot;ratio&quot;&gt;std::ratio&lt;/a&gt;&amp;lt;Num, Denom&amp;gt;::den&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6f389c36e6b41ab6b3fdb4d5ce8f967c0c0ccebe" translate="yes" xml:space="preserve">
          <source>The result is a &lt;code&gt;&lt;a href=&quot;ratio&quot;&gt;std::ratio&lt;/a&gt;&lt;/code&gt; specialization &lt;code&gt;&lt;a href=&quot;ratio&quot;&gt;std::ratio&lt;/a&gt;&amp;lt;U, V&amp;gt;&lt;/code&gt;, such that given &lt;code&gt;Num == R1::num * R2::num&lt;/code&gt; and &lt;code&gt;Denom == R1::den * R2::den&lt;/code&gt; (computed without arithmetic overflow), &lt;code&gt;U&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;ratio&quot;&gt;std::ratio&lt;/a&gt;&amp;lt;Num, Denom&amp;gt;::num&lt;/code&gt; and &lt;code&gt;V&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;ratio&quot;&gt;std::ratio&lt;/a&gt;&amp;lt;Num, Denom&amp;gt;::den&lt;/code&gt;.</source>
          <target state="translated">Результатом является &lt;code&gt;&lt;a href=&quot;ratio&quot;&gt;std::ratio&lt;/a&gt;&lt;/code&gt; специализации &lt;code&gt;&lt;a href=&quot;ratio&quot;&gt;std::ratio&lt;/a&gt;&amp;lt;U, V&amp;gt;&lt;/code&gt; , такое , что при &lt;code&gt;Num == R1::num * R2::num&lt;/code&gt; и &lt;code&gt;Denom == R1::den * R2::den&lt;/code&gt; (вычисляется без арифметическое переполнение), &lt;code&gt;U&lt;/code&gt; - это &lt;code&gt;&lt;a href=&quot;ratio&quot;&gt;std::ratio&lt;/a&gt;&amp;lt;Num, Denom&amp;gt;::num&lt;/code&gt; а &lt;code&gt;V&lt;/code&gt; - это &lt;code&gt;&lt;a href=&quot;ratio&quot;&gt;std::ratio&lt;/a&gt;&amp;lt;Num, Denom&amp;gt;::den&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e68dbec571d137df08d9f883c38ccb0b5e7b5985" translate="yes" xml:space="preserve">
          <source>The result is a &lt;code&gt;bool&lt;/code&gt; prvalue.</source>
          <target state="translated">Результатом является предварительное значение &lt;code&gt;bool&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e2c4bb4518db49d6f285ab22da7870886f0081c4" translate="yes" xml:space="preserve">
          <source>The result is ready</source>
          <target state="translated">Результат готов</target>
        </trans-unit>
        <trans-unit id="580dbf951c94723d3af7b9d08b23514681e24e3d" translate="yes" xml:space="preserve">
          <source>The result is the same as &lt;a href=&quot;implicit_cast&quot;&gt;implicit conversion&lt;/a&gt; from the enum's underlying type to the destination type.</source>
          <target state="translated">Результат аналогичен &lt;a href=&quot;implicit_cast&quot;&gt;неявному преобразованию&lt;/a&gt; базового типа перечисления в тип назначения.</target>
        </trans-unit>
        <trans-unit id="cbbaf37dfe4267e58c22583ee6fab6ad33d0d8fd" translate="yes" xml:space="preserve">
          <source>The result is the same as &lt;a href=&quot;implicit_cast#Floating.E2.80.93integral_conversions&quot;&gt;converting&lt;/a&gt; the original value first to the underlying type of the enumeration, and then to the enumeration type.</source>
          <target state="translated">Результат аналогичен &lt;a href=&quot;implicit_cast#Floating.E2.80.93integral_conversions&quot;&gt;преобразованию&lt;/a&gt; исходного значения сначала в базовый тип перечисления, а затем в тип перечисления.</target>
        </trans-unit>
        <trans-unit id="a957f8ea1f391e7935ddb74dad2e1448951ecef7" translate="yes" xml:space="preserve">
          <source>The result may have little or no significance if the magnitude of &lt;code&gt;arg&lt;/code&gt; is large.</source>
          <target state="translated">Результат может иметь небольшое значение или не иметь значения, если величина &lt;code&gt;arg&lt;/code&gt; велика.</target>
        </trans-unit>
        <trans-unit id="870fcd3df093829aaa26fd2db3dbce5ac0e9700e" translate="yes" xml:space="preserve">
          <source>The result of &lt;code&gt;!arg&lt;/code&gt;.</source>
          <target state="translated">Результат &lt;code&gt;!arg&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e6e1af8324720028e132b94fe61c4514f56e4941" translate="yes" xml:space="preserve">
          <source>The result of &lt;code&gt;-arg&lt;/code&gt;.</source>
          <target state="translated">Результат &lt;code&gt;-arg&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3a411985e21ab920e38a5852e204b8af0e20a27e" translate="yes" xml:space="preserve">
          <source>The result of &lt;code&gt;&lt;a href=&quot;../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;T&amp;gt;(lhs) == &lt;a href=&quot;../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;U&amp;gt;(rhs)&lt;/code&gt;.</source>
          <target state="translated">Результат &lt;code&gt;&lt;a href=&quot;../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;T&amp;gt;(lhs) == &lt;a href=&quot;../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;U&amp;gt;(rhs)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="80ec200a207a639219d15d9ccfe372f86eab6036" translate="yes" xml:space="preserve">
          <source>The result of &lt;code&gt;&lt;a href=&quot;../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;T&amp;gt;(lhs) | &lt;a href=&quot;../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;U&amp;gt;(rhs)&lt;/code&gt;.</source>
          <target state="translated">Результат &lt;code&gt;&lt;a href=&quot;../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;T&amp;gt;(lhs) | &lt;a href=&quot;../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;U&amp;gt;(rhs)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7e64ce1e5aed1c40811afecb3dc7fbb9b0c9b98a" translate="yes" xml:space="preserve">
          <source>The result of &lt;code&gt;&lt;a href=&quot;../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;T&amp;gt;(lhs) || &lt;a href=&quot;../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;U&amp;gt;(rhs)&lt;/code&gt;.</source>
          <target state="translated">Результат &lt;code&gt;&lt;a href=&quot;../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;T&amp;gt;(lhs) || &lt;a href=&quot;../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;U&amp;gt;(rhs)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ee0825f237fb1718d9a9117588e0d38939c42fd3" translate="yes" xml:space="preserve">
          <source>The result of &lt;code&gt;&lt;a href=&quot;../math/pow&quot;&gt;std::pow&lt;/a&gt;(0, 0)&lt;/code&gt; is implementation-defined.</source>
          <target state="translated">Результат &lt;code&gt;&lt;a href=&quot;../math/pow&quot;&gt;std::pow&lt;/a&gt;(0, 0)&lt;/code&gt; определяется реализацией.</target>
        </trans-unit>
        <trans-unit id="acf2c3f21b47e9f1630796369e072a4335640eda" translate="yes" xml:space="preserve">
          <source>The result of &lt;code&gt;lhs != rhs&lt;/code&gt;.</source>
          <target state="translated">Результат &lt;code&gt;lhs != rhs&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4e6e472de88efa439e4f8ac01ef503fb42158a44" translate="yes" xml:space="preserve">
          <source>The result of &lt;code&gt;lhs % rhs&lt;/code&gt;.</source>
          <target state="translated">Результат &lt;code&gt;lhs % rhs&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d4c5e47c305ac62f9aa59e69771dddcae5c999a2" translate="yes" xml:space="preserve">
          <source>The result of &lt;code&gt;lhs &amp;amp; rhs&lt;/code&gt;.</source>
          <target state="translated">Результат &lt;code&gt;lhs &amp;amp; rhs&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e95d02148bc8a4f7ae12814dcba7c7fe81fbedaf" translate="yes" xml:space="preserve">
          <source>The result of &lt;code&gt;lhs &amp;amp;&amp;amp; rhs&lt;/code&gt;.</source>
          <target state="translated">Результат &lt;code&gt;lhs &amp;amp;&amp;amp; rhs&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fa6dd6207a762f8224d24ca1b87c1fcc621652fa" translate="yes" xml:space="preserve">
          <source>The result of &lt;code&gt;lhs &amp;gt; rhs&lt;/code&gt;.</source>
          <target state="translated">Результат &lt;code&gt;lhs &amp;gt; rhs&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9f4b083947ef6aa836be0e4780f07e0aadcf1e43" translate="yes" xml:space="preserve">
          <source>The result of &lt;code&gt;lhs &amp;gt;= rhs&lt;/code&gt;.</source>
          <target state="translated">Результат &lt;code&gt;lhs &amp;gt;= rhs&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e8f2b531e796e45b234ba714ef92019621ac8f1b" translate="yes" xml:space="preserve">
          <source>The result of &lt;code&gt;lhs &amp;lt; rhs&lt;/code&gt;.</source>
          <target state="translated">Результат &lt;code&gt;lhs &amp;lt; rhs&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d3e99c51790273d3fd02297fcb57fd200d05fec1" translate="yes" xml:space="preserve">
          <source>The result of &lt;code&gt;lhs &amp;lt;= rhs&lt;/code&gt;.</source>
          <target state="translated">Результат &lt;code&gt;lhs &amp;lt;= rhs&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e05f6b812268f1065a685db8b9a51d0ed85af871" translate="yes" xml:space="preserve">
          <source>The result of &lt;code&gt;lhs * rhs&lt;/code&gt;.</source>
          <target state="translated">Результат &lt;code&gt;lhs * rhs&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fa8335ddae097460592407def0f6f7f6531b4bde" translate="yes" xml:space="preserve">
          <source>The result of &lt;code&gt;lhs + rhs&lt;/code&gt;.</source>
          <target state="translated">Результат &lt;code&gt;lhs + rhs&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="632ae131fa96ce384c426b305a35eb2730ac7e17" translate="yes" xml:space="preserve">
          <source>The result of &lt;code&gt;lhs - rhs&lt;/code&gt;.</source>
          <target state="translated">Результат &lt;code&gt;lhs - rhs&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="914a5eae959d8077c3946fcd30325aab12d6c2f1" translate="yes" xml:space="preserve">
          <source>The result of &lt;code&gt;lhs / rhs&lt;/code&gt;.</source>
          <target state="translated">Результат &lt;code&gt;lhs / rhs&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1542bda1bc0df08cd4e2da32ce9c1c4158ea1b29" translate="yes" xml:space="preserve">
          <source>The result of &lt;code&gt;lhs ^ rhs&lt;/code&gt;.</source>
          <target state="translated">Результат &lt;code&gt;lhs ^ rhs&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f829b25d22cfb56ef72ca8c031ffcc768468e0a2" translate="yes" xml:space="preserve">
          <source>The result of &lt;code&gt;lhs | rhs&lt;/code&gt;.</source>
          <target state="translated">Результат &lt;code&gt;lhs | rhs&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c15c8b1e6d71bff19e0100cd1bb43d0aaf22d25a" translate="yes" xml:space="preserve">
          <source>The result of &lt;code&gt;lhs || rhs&lt;/code&gt;.</source>
          <target state="translated">Результат &lt;code&gt;lhs || rhs&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8a2cfe39bb4bca238a75c100d57a8e16e49b74ab" translate="yes" xml:space="preserve">
          <source>The result of &lt;code&gt;operator*&lt;/code&gt; or &lt;code&gt;operator-&amp;gt;&lt;/code&gt; on the end iterator is undefined behavior.</source>
          <target state="translated">Результат &lt;code&gt;operator*&lt;/code&gt; или &lt;code&gt;operator-&amp;gt;&lt;/code&gt; в конце итератора - неопределенное поведение.</target>
        </trans-unit>
        <trans-unit id="006f10ce7b3c5cdf0abdf83cfb46f3ea491450f3" translate="yes" xml:space="preserve">
          <source>The result of &lt;code&gt;sizeof&lt;/code&gt; is always nonzero, even if applied to an empty class type.</source>
          <target state="translated">Результат &lt;code&gt;sizeof&lt;/code&gt; всегда ненулевой, даже если применяется к пустому типу класса.</target>
        </trans-unit>
        <trans-unit id="cff04ad9446c1f408f431157236a6d0631af546f" translate="yes" xml:space="preserve">
          <source>The result of &lt;code&gt;~arg&lt;/code&gt;.</source>
          <target state="translated">Результат &lt;code&gt;~arg&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e9685a2aebbafc6d384174b50e75064f891cc1ef" translate="yes" xml:space="preserve">
          <source>The result of attempting to determine the size of a directory (as well as any other file that is not a regular file or a symlink) is implementation-defined.</source>
          <target state="translated">Результат попытки определить размер директории (а также любого другого файла,который не является обычным файлом или сим-ссылкой)определяется реализацией.</target>
        </trans-unit>
        <trans-unit id="247e8d93cf388f43a2c1c6cc6c4100ee34ada80f" translate="yes" xml:space="preserve">
          <source>The result of calling most member functions of the match_results object that is not</source>
          <target state="translated">Результатом вызова большинства функций-членов объекта match_results является не</target>
        </trans-unit>
        <trans-unit id="21e3ce4be4c110e9cc76bfe73bc7a78e82910174" translate="yes" xml:space="preserve">
          <source>The result of comparing two pointers to members (after conversions) is defined as follows:</source>
          <target state="translated">Результат сравнения двух указателей с членами (после преобразования)определяется следующим образом:</target>
        </trans-unit>
        <trans-unit id="32f37ca48793604634e4bf49c6103814193272fa" translate="yes" xml:space="preserve">
          <source>The result of comparing two pointers to objects (after conversions) is defined as follows:</source>
          <target state="translated">Результат сравнения двух указателей на объекты (после преобразования)определяется следующим образом:</target>
        </trans-unit>
        <trans-unit id="0290b3221f34a8546049c1fe37f0a1d16a5a5bef" translate="yes" xml:space="preserve">
          <source>The result of converting a negative number string into an unsigned integer was specified to produce zero until C++17, although some implementations followed the protocol of &lt;code&gt;&lt;a href=&quot;../../string/byte/strtoul&quot;&gt;std::strtoull&lt;/a&gt;&lt;/code&gt; which negates in the target type, giving &lt;code&gt;&lt;a href=&quot;../../types/climits&quot;&gt;ULLONG_MAX&lt;/a&gt;&lt;/code&gt; for &lt;code&gt;&quot;-1&quot;&lt;/code&gt;, and so produce the largest value of the target type instead. As of C++17, strictly following &lt;code&gt;&lt;a href=&quot;../../string/byte/strtoul&quot;&gt;std::strtoull&lt;/a&gt;&lt;/code&gt; is the correct behavior.</source>
          <target state="translated">Результат преобразования строки с отрицательным числом в целое число без знака было указано для получения нуля до C ++ 17, хотя некоторые реализации следовали протоколу &lt;code&gt;&lt;a href=&quot;../../string/byte/strtoul&quot;&gt;std::strtoull&lt;/a&gt;&lt;/code&gt; который отрицает в целевом типе, давая &lt;code&gt;&lt;a href=&quot;../../types/climits&quot;&gt;ULLONG_MAX&lt;/a&gt;&lt;/code&gt; для &lt;code&gt;&quot;-1&quot;&lt;/code&gt; , и поэтому вместо этого создайте наибольшее значение целевого типа. Начиная с C ++ 17, строгое следование &lt;code&gt;&lt;a href=&quot;../../string/byte/strtoul&quot;&gt;std::strtoull&lt;/a&gt;&lt;/code&gt; - правильное поведение.</target>
        </trans-unit>
        <trans-unit id="dd0729a11dfb5de4b72c38a2205cbf06dfb22a46" translate="yes" xml:space="preserve">
          <source>The result of equality comparison of two pointers (after conversions) is defined as follows:</source>
          <target state="translated">Результат сравнения равенства двух указателей (после преобразования)определяется следующим образом:</target>
        </trans-unit>
        <trans-unit id="47a73f53b39aa715441c99e5f455152b99e4705b" translate="yes" xml:space="preserve">
          <source>The result of operator~ is the bitwise NOT (one's complement) value of the argument (after promotion). The result of operator&amp;amp; is the bitwise AND value of the operands (after usual arithmetic conversions). The result of operator| is the bitwise OR value of the operands (after usual arithmetic conversions). The result of operator^ is the bitwise XOR value of the operands (after usual arithmetic conversions).</source>
          <target state="translated">Результатом оператора ~ является побитовое НЕ (одно дополнение) значение аргумента (после повышения). Результатом оператора &amp;amp; является побитовое значение И операндов (после обычных арифметических преобразований). Результат оператора | является побитовым значением ИЛИ операндов (после обычных арифметических преобразований). Результатом оператора ^ является побитовое значение XOR операндов (после обычных арифметических преобразований).</target>
        </trans-unit>
        <trans-unit id="e0eb608d51cf5832fadd72c5babd7a6e03e98a43" translate="yes" xml:space="preserve">
          <source>The result of path concatenation.</source>
          <target state="translated">Результат конкатенирования путей.</target>
        </trans-unit>
        <trans-unit id="4f62a6ed94a5ad3247f5fc515a6a3e14d480ed26" translate="yes" xml:space="preserve">
          <source>The result of subtracting two &lt;code&gt;month&lt;/code&gt; values is a duration of type &lt;code&gt;std::chrono::months&lt;/code&gt;. That duration unit represents the length of the average Gregorian month, and the resulting duration bears no relationship to the number of days in the particular months represented by the operands. For example, &lt;code&gt;&lt;a href=&quot;../duration&quot;&gt;std::chrono::seconds&lt;/a&gt;(&lt;a href=&quot;../month&quot;&gt;std::chrono::April&lt;/a&gt; - &lt;a href=&quot;../month&quot;&gt;std::chrono::March&lt;/a&gt;)&lt;/code&gt; is not the number of seconds in March (&lt;code&gt;2678400s&lt;/code&gt;), but &lt;code&gt;2629746s&lt;/code&gt; (30.436875 days).</source>
          <target state="translated">Результатом вычитания &lt;code&gt;month&lt;/code&gt; значений является длительность типа &lt;code&gt;std::chrono::months&lt;/code&gt; . Эта единица длительности представляет собой длину среднего григорианского месяца, и результирующая продолжительность не имеет отношения к количеству дней в конкретных месяцах, представленных операндами. Например, &lt;code&gt;&lt;a href=&quot;../duration&quot;&gt;std::chrono::seconds&lt;/a&gt;(&lt;a href=&quot;../month&quot;&gt;std::chrono::April&lt;/a&gt; - &lt;a href=&quot;../month&quot;&gt;std::chrono::March&lt;/a&gt;)&lt;/code&gt; - это не количество секунд в марте ( &lt;code&gt;2678400s&lt;/code&gt; ), а &lt;code&gt;2629746s&lt;/code&gt; (30,436875 дней).</target>
        </trans-unit>
        <trans-unit id="17172fd81702e28b82e8d13798f7b61c7c8f7b83" translate="yes" xml:space="preserve">
          <source>The result of subtracting two &lt;code&gt;year&lt;/code&gt; values is a duration of type &lt;code&gt;std::chrono::years&lt;/code&gt;. This duration unit represents the length of the average Gregorian year, and the resulting duration bears no relationship to the number of days in the particular years represented by the operands. For example, the result of &lt;code&gt;2018y - 2017y&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;../duration&quot;&gt;std::chrono::years&lt;/a&gt;(1)&lt;/code&gt;, which represents 365.2425 days, not 365 days.</source>
          <target state="translated">Результатом вычитания &lt;code&gt;year&lt;/code&gt; значений является длительность типа &lt;code&gt;std::chrono::years&lt;/code&gt; . Эта единица длительности представляет длину среднего григорианского года, и результирующая продолжительность не имеет отношения к количеству дней в конкретных годах, представленных операндами. Например, результат &lt;code&gt;2018y - 2017y&lt;/code&gt; равен &lt;code&gt;&lt;a href=&quot;../duration&quot;&gt;std::chrono::years&lt;/a&gt;(1)&lt;/code&gt; , что соответствует 365,2425 дням, а не 365 дням.</target>
        </trans-unit>
        <trans-unit id="36c4afa551c41832fffe70e348da9af50d440abe" translate="yes" xml:space="preserve">
          <source>The result of subtracting two &lt;code&gt;year_month&lt;/code&gt; values is a duration of type &lt;code&gt;std::chrono::months&lt;/code&gt;. This duration unit represents the length of the average Gregorian month (30.436875 days), and the resulting duration bears no relationship to the actual number of days in the time period at issue. For example, the result of &lt;code&gt;2017y/3 - 2017y/2&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;../duration&quot;&gt;std::chrono::months&lt;/a&gt;(1)&lt;/code&gt;, even though February 2017 only contains 28 days.</source>
          <target state="translated">Результатом вычитания двух значений &lt;code&gt;year_month&lt;/code&gt; является длительность типа &lt;code&gt;std::chrono::months&lt;/code&gt; . Эта единица продолжительности представляет собой продолжительность среднего григорианского месяца (30,436875 дней), и результирующая продолжительность не имеет отношения к фактическому количеству дней в рассматриваемом периоде времени. Например, результат &lt;code&gt;2017y/3 - 2017y/2&lt;/code&gt; - &lt;code&gt;&lt;a href=&quot;../duration&quot;&gt;std::chrono::months&lt;/a&gt;(1)&lt;/code&gt; , хотя февраль 2017 года содержит только 28 дней.</target>
        </trans-unit>
        <trans-unit id="a3315b545d55c361d494aaf334e4af2659a2548d" translate="yes" xml:space="preserve">
          <source>The result of the comparison: &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;*obj&lt;/code&gt; was equal to &lt;code&gt;*expected&lt;/code&gt;, &lt;code&gt;false&lt;/code&gt; otherwise.</source>
          <target state="translated">Результат сравнения: &lt;code&gt;true&lt;/code&gt; если &lt;code&gt;*obj&lt;/code&gt; был равен &lt;code&gt;*expected&lt;/code&gt; , &lt;code&gt;false&lt;/code&gt; противном случае.</target>
        </trans-unit>
        <trans-unit id="e25c0d3525dfeb8bfa6ff74fcf703d161b32cfb4" translate="yes" xml:space="preserve">
          <source>The result of the conversion as described above:</source>
          <target state="translated">Результат преобразования,как описано выше:</target>
        </trans-unit>
        <trans-unit id="3870571eecc090d22dc21a8b93d45f1df9a1dda1" translate="yes" xml:space="preserve">
          <source>The result of the conversion, determined as described above.</source>
          <target state="translated">Результат конвертации,определенный,как описано выше.</target>
        </trans-unit>
        <trans-unit id="5cfae012b116826024fbc12ba5aac5a29cc79ff0" translate="yes" xml:space="preserve">
          <source>The result of the expression always has type &lt;code&gt;void&lt;/code&gt;.</source>
          <target state="translated">Результат выражения всегда имеет тип &lt;code&gt;void&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d11a68b7fc68b552ec64c618e13fe680bd75b63e" translate="yes" xml:space="preserve">
          <source>The result type generated by the generator. The effect is undefined if this is not one of &lt;code&gt;float&lt;/code&gt;, &lt;code&gt;double&lt;/code&gt;, or &lt;code&gt;long double&lt;/code&gt;.</source>
          <target state="translated">Тип результата, сгенерированный генератором. Эффект не определен, если это не один из типов &lt;code&gt;float&lt;/code&gt; , &lt;code&gt;double&lt;/code&gt; или &lt;code&gt;long double&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9e80eecc0596c35730188bd9f4d1c551f3febc94" translate="yes" xml:space="preserve">
          <source>The result type generated by the generator. The effect is undefined if this is not one of &lt;code&gt;short&lt;/code&gt;, &lt;code&gt;int&lt;/code&gt;, &lt;code&gt;long&lt;/code&gt;, &lt;code&gt;long long&lt;/code&gt;, &lt;code&gt;unsigned short&lt;/code&gt;, &lt;code&gt;unsigned int&lt;/code&gt;, &lt;code&gt;unsigned long&lt;/code&gt;, or &lt;code&gt;unsigned long long&lt;/code&gt;.</source>
          <target state="translated">Тип результата, сгенерированный генератором. Эффект не определен, если это не один из &lt;code&gt;short&lt;/code&gt; , &lt;code&gt;int&lt;/code&gt; , &lt;code&gt;long&lt;/code&gt; , &lt;code&gt;long long&lt;/code&gt; , &lt;code&gt;unsigned short&lt;/code&gt; , &lt;code&gt;unsigned int&lt;/code&gt; , &lt;code&gt;unsigned long&lt;/code&gt; или &lt;code&gt;unsigned long long&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5521797ee22c876e97965af0d7522808846e3d59" translate="yes" xml:space="preserve">
          <source>The result value can be unambiguously converted to &lt;code&gt;T&lt;/code&gt; (1-3) or &lt;code&gt;bool&lt;/code&gt; (4).</source>
          <target state="translated">Значение результата может быть однозначно преобразовано в &lt;code&gt;T&lt;/code&gt; (1-3) или &lt;code&gt;bool&lt;/code&gt; (4).</target>
        </trans-unit>
        <trans-unit id="f6bb786c46da806f276663a0a370a0140bec8af4" translate="yes" xml:space="preserve">
          <source>The result value can be unambiguously converted to &lt;code&gt;bool&lt;/code&gt;.</source>
          <target state="translated">Значение результата может быть однозначно преобразовано в &lt;code&gt;bool&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="43655266ec179e649b00784deeb0b1a3c97d236d" translate="yes" xml:space="preserve">
          <source>The resultant offset converted to &lt;code&gt;pos_type&lt;/code&gt; on success or &lt;code&gt;pos_type(off_type(-1))&lt;/code&gt; on failure.</source>
          <target state="translated">Результирующее смещение преобразуется в &lt;code&gt;pos_type&lt;/code&gt; в случае успеха или &lt;code&gt;pos_type(off_type(-1))&lt;/code&gt; в случае ошибки.</target>
        </trans-unit>
        <trans-unit id="ef23966d370102deb412213da03cdcdb6c680d1f" translate="yes" xml:space="preserve">
          <source>The resulting range cannot overlap with either of the input ranges.</source>
          <target state="translated">Полученный диапазон не может пересекаться ни с одним из входных диапазонов.</target>
        </trans-unit>
        <trans-unit id="29d5035de2621e71a90038d6802a888a677db3c5" translate="yes" xml:space="preserve">
          <source>The resulting range is also sorted. Equivalent elements are treated individually, that is, if some element is found &lt;code&gt;m&lt;/code&gt; times in &lt;code&gt;[first1, last1)&lt;/code&gt; and &lt;code&gt;n&lt;/code&gt; times in &lt;code&gt;[first2, last2)&lt;/code&gt;, it will be copied to &lt;code&gt;d_first&lt;/code&gt; exactly &lt;code&gt;&lt;a href=&quot;max&quot;&gt;std::max&lt;/a&gt;(m-n, 0)&lt;/code&gt; times. The resulting range cannot overlap with either of the input ranges.</source>
          <target state="translated">Полученный диапазон также отсортирован. Эквивалентные элементы обрабатываются индивидуально, то есть, если какой-то элемент найден &lt;code&gt;m&lt;/code&gt; раз в &lt;code&gt;[first1, last1)&lt;/code&gt; и &lt;code&gt;n&lt;/code&gt; раз в &lt;code&gt;[first2, last2)&lt;/code&gt; , он будет скопирован в &lt;code&gt;d_first&lt;/code&gt; точно в &lt;code&gt;&lt;a href=&quot;max&quot;&gt;std::max&lt;/a&gt;(m-n, 0)&lt;/code&gt; раз. Результирующий диапазон не может перекрываться ни с одним из входных диапазонов.</target>
        </trans-unit>
        <trans-unit id="aaddb0a6756a877f4864ff06a8fc5e72ffd2f6e1" translate="yes" xml:space="preserve">
          <source>The resulting string contains &lt;code&gt;N&lt;/code&gt; characters with the first character corresponds to the last (&lt;code&gt;N-1&lt;/code&gt;th) bit and the last character corresponding to the first bit.</source>
          <target state="translated">Результирующая строка содержит &lt;code&gt;N&lt;/code&gt; символов, причем первый символ соответствует последнему ( &lt;code&gt;N-1&lt;/code&gt; - му) биту, а последний символ соответствует первому биту.</target>
        </trans-unit>
        <trans-unit id="b17d4cd7b0868b24196c899cf5191cb1faa7ed25" translate="yes" xml:space="preserve">
          <source>The resulting valarray with circularly shifted elements.</source>
          <target state="translated">Получившийся валаррей с элементами с круговым смещением.</target>
        </trans-unit>
        <trans-unit id="7458cef4d81e04aca531157faaf437f90b8b5f76" translate="yes" xml:space="preserve">
          <source>The resulting valarray with shifted elements.</source>
          <target state="translated">Получившийся валаррей со смещенными элементами.</target>
        </trans-unit>
        <trans-unit id="83ad9cb498edc1aa4891b4efbe63cabce32603fe" translate="yes" xml:space="preserve">
          <source>The resulting valarray with values acquired by applying function &lt;code&gt;func&lt;/code&gt;.</source>
          <target state="translated">Результирующий valarray со значениями, полученными путем применения функции &lt;code&gt;func&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4e5c65b16e68930d61a611b38a71296f2506a4cf" translate="yes" xml:space="preserve">
          <source>The resulting value (that is, the result of applying the corresponding binary operator to the value immediately preceding the effects of the corresponding member function in the &lt;a href=&quot;../memory_order#Modification_order&quot;&gt;modification order&lt;/a&gt; of &lt;code&gt;*this&lt;/code&gt;).</source>
          <target state="translated">Полученное значение (то есть, результат применения соответствующего двоичный оператора к значению , непосредственно предшествующих эффекты соответствующей функции - члена в &lt;a href=&quot;../memory_order#Modification_order&quot;&gt;порядке модификации&lt;/a&gt; из &lt;code&gt;*this&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="e814d10c5d370f3f42c2fca47efc512b44b14a3c" translate="yes" xml:space="preserve">
          <source>The resulting value (that is, the result of applying the corresponding binary operator to the value immediately preceding the effects of the corresponding member function).</source>
          <target state="translated">Результирующее значение (т.е.результат применения соответствующего двоичного оператора к значению,непосредственно предшествующему действию соответствующей функции-члену).</target>
        </trans-unit>
        <trans-unit id="3389100e45b720cf6eb81e6827f7706cb90c9259" translate="yes" xml:space="preserve">
          <source>The return from the</source>
          <target state="translated">Возвращение из</target>
        </trans-unit>
        <trans-unit id="53209406292002d9313d7e4939097156f31cc15e" translate="yes" xml:space="preserve">
          <source>The return statements in a discarded statement do not participate in function return type deduction:</source>
          <target state="translated">Заявления о возврате в отбракованном заявлении не участвуют в вычете типа возврата функции:</target>
        </trans-unit>
        <trans-unit id="3ed22644873dd55c750986fea93019dbd3388a1d" translate="yes" xml:space="preserve">
          <source>The return type does not add more than two levels of template nesting over the most deeply-nested argument type.</source>
          <target state="translated">Возвращаемый тип не добавляет более двух уровней вложенности шаблона по наиболее глубоко вложенному типу аргумента.</target>
        </trans-unit>
        <trans-unit id="7613f3aef88eece4db1f4660060fab1d18285727" translate="yes" xml:space="preserve">
          <source>The return type is &lt;code&gt;void*&lt;/code&gt; (rather than, e.g., &lt;code&gt;&lt;a href=&quot;../../types/byte&quot;&gt;std::byte&lt;/a&gt;*&lt;/code&gt;) to support conversion to an arbitrary pointer type &lt;code&gt;U*&lt;/code&gt; by &lt;code&gt;static_cast&amp;lt;U*&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">Возвращаемый тип &lt;code&gt;void*&lt;/code&gt; (вместо, например, &lt;code&gt;&lt;a href=&quot;../../types/byte&quot;&gt;std::byte&lt;/a&gt;*&lt;/code&gt; ) для поддержки преобразования в произвольный тип указателя &lt;code&gt;U*&lt;/code&gt; с помощью &lt;code&gt;static_cast&amp;lt;U*&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4d5d71418aa972f29b239eb90d69468e90bb0941" translate="yes" xml:space="preserve">
          <source>The return type is the type of the left operand after integral promotions.</source>
          <target state="translated">Тип возврата-это тип левого оперного театра после интегральных промо-акций.</target>
        </trans-unit>
        <trans-unit id="4fa9717f5967413803e02aa6bb2883c955d4365a" translate="yes" xml:space="preserve">
          <source>The return type of &lt;a href=&quot;../numeric/valarray/begin2&quot;&gt;&lt;code&gt;begin(valarray)&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../numeric/valarray/end2&quot;&gt;&lt;code&gt;end(valarray)&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">Тип возвращаемого значения: &lt;a href=&quot;../numeric/valarray/begin2&quot;&gt; &lt;code&gt;begin(valarray)&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;../numeric/valarray/end2&quot;&gt; &lt;code&gt;end(valarray)&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="4b467b24eb3e95658db04cc2efccee281ce62fa6" translate="yes" xml:space="preserve">
          <source>The return type of &lt;code&gt;T&lt;/code&gt; if &lt;code&gt;T&lt;/code&gt; is a function. Otherwise, not defined</source>
          <target state="translated">Тип возвращаемого значения &lt;code&gt;T&lt;/code&gt; , если &lt;code&gt;T&lt;/code&gt; является функцией. В противном случае не определено</target>
        </trans-unit>
        <trans-unit id="fc619118262950fb869b5d544147bd07c7f92619" translate="yes" xml:space="preserve">
          <source>The return type of &lt;code&gt;filter_view::begin&lt;/code&gt;.</source>
          <target state="translated">Возвращаемый тип &lt;code&gt;filter_view::begin&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8a173a812528e6c04c2d8704d2f8d1773cc20a31" translate="yes" xml:space="preserve">
          <source>The return type of &lt;code&gt;filter_view::end&lt;/code&gt;.</source>
          <target state="translated">Тип возвращаемого значения &lt;code&gt;filter_view::end&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7f8cc94f3fe57edcbe4e00cf3aaac26990fe1598" translate="yes" xml:space="preserve">
          <source>The return type of &lt;code&gt;iota_view::begin&lt;/code&gt;.</source>
          <target state="translated">Тип возвращаемого значения &lt;code&gt;iota_view::begin&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7eef554336055de8435461fe71844804d344403e" translate="yes" xml:space="preserve">
          <source>The return type of &lt;code&gt;iota_view::end&lt;/code&gt;.</source>
          <target state="translated">Тип возвращаемого значения &lt;code&gt;iota_view::end&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7d16c75ab67ddd9e46691a2a894ba5baeac787d8" translate="yes" xml:space="preserve">
          <source>The return type of &lt;code&gt;std::bind&lt;/code&gt; holds a member object of type &lt;code&gt;&lt;a href=&quot;../../types/decay&quot;&gt;std::decay&lt;/a&gt;&amp;lt;F&amp;gt;::type&lt;/code&gt; constructed from &lt;code&gt;&lt;a href=&quot;../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;F&amp;gt;(f)&lt;/code&gt;, and one object per each of &lt;code&gt;args...&lt;/code&gt;, of type &lt;code&gt;&lt;a href=&quot;../../types/decay&quot;&gt;std::decay&lt;/a&gt;&amp;lt;Arg_i&amp;gt;::type&lt;/code&gt;, similarly constructed from &lt;code&gt;&lt;a href=&quot;../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;Arg_i&amp;gt;(arg_i)&lt;/code&gt;.</source>
          <target state="translated">Возвращаемый тип &lt;code&gt;std::bind&lt;/code&gt; содержит объект-член типа &lt;code&gt;&lt;a href=&quot;../../types/decay&quot;&gt;std::decay&lt;/a&gt;&amp;lt;F&amp;gt;::type&lt;/code&gt; созданный из &lt;code&gt;&lt;a href=&quot;../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;F&amp;gt;(f)&lt;/code&gt; , и по одному объекту на каждое из &lt;code&gt;args...&lt;/code&gt; , типа &lt;code&gt;&lt;a href=&quot;../../types/decay&quot;&gt;std::decay&lt;/a&gt;&amp;lt;Arg_i&amp;gt;::type&lt;/code&gt; , аналогичным образом &lt;code&gt;&lt;a href=&quot;../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;Arg_i&amp;gt;(arg_i)&lt;/code&gt; из &lt;a href=&quot;../forward&quot;&gt;std :: forward&lt;/a&gt; &amp;lt;Arg_i&amp;gt; (arg_i) .</target>
        </trans-unit>
        <trans-unit id="fde0844a0606e7893f2ea00fd18105a16696460c" translate="yes" xml:space="preserve">
          <source>The return type of &lt;code&gt;std::bind&lt;/code&gt; is &lt;a href=&quot;../../named_req/copyconstructible&quot;&gt;CopyConstructible&lt;/a&gt; if all of its member objects (specified above) are CopyConstructible, and is &lt;a href=&quot;../../named_req/moveconstructible&quot;&gt;MoveConstructible&lt;/a&gt; otherwise. The type defines the following members:</source>
          <target state="translated">Тип возвращаемого значения &lt;code&gt;std::bind&lt;/code&gt; - &lt;a href=&quot;../../named_req/copyconstructible&quot;&gt;CopyConstructible,&lt;/a&gt; если все его объекты-члены (указанные выше) являются CopyConstructible, а иначе - &lt;a href=&quot;../../named_req/moveconstructible&quot;&gt;MoveConstructible&lt;/a&gt; . Тип определяет следующие члены:</target>
        </trans-unit>
        <trans-unit id="6c0953e38415f15fb34763f7446d0d031ca5c65a" translate="yes" xml:space="preserve">
          <source>The return type of &lt;code&gt;std::bind_front&lt;/code&gt; behaves as if its copy/move constructors perform a memberwise copy/move. It is &lt;a href=&quot;../../named_req/copyconstructible&quot;&gt;CopyConstructible&lt;/a&gt; if all of its member objects (specified above) are CopyConstructible, and is &lt;a href=&quot;../../named_req/moveconstructible&quot;&gt;MoveConstructible&lt;/a&gt; otherwise.</source>
          <target state="translated">Возвращаемый тип &lt;code&gt;std::bind_front&lt;/code&gt; ведет себя так, как если бы его конструкторы копирования / перемещения выполняли элементарное копирование / перемещение. Это &lt;a href=&quot;../../named_req/copyconstructible&quot;&gt;CopyConstructible,&lt;/a&gt; если все его объекты-члены (указанные выше) являются CopyConstructible, и &lt;a href=&quot;../../named_req/moveconstructible&quot;&gt;MoveConstructible в&lt;/a&gt; противном случае.</target>
        </trans-unit>
        <trans-unit id="f29ace211ba147bca17300e0f5b8c1b51fd281da" translate="yes" xml:space="preserve">
          <source>The return type of &lt;code&gt;std::not_fn&lt;/code&gt; holds a member object of type &lt;code&gt;&lt;a href=&quot;../../types/decay&quot;&gt;std::decay_t&lt;/a&gt;&amp;lt;F&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">Возвращаемый тип &lt;code&gt;std::not_fn&lt;/code&gt; содержит объект-член типа &lt;code&gt;&lt;a href=&quot;../../types/decay&quot;&gt;std::decay_t&lt;/a&gt;&amp;lt;F&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="313e4bd0b86dc792bb66113e7c07635c9c275b3f" translate="yes" xml:space="preserve">
          <source>The return type of a conditional operator is also accessible as the binary type trait &lt;code&gt;&lt;a href=&quot;../types/common_type&quot;&gt;std::common_type&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Возвращаемый тип условного оператора также доступен в виде бинарного типа trait &lt;code&gt;&lt;a href=&quot;../types/common_type&quot;&gt;std::common_type&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="76f32cdf7dc810987e937f22df27363914ee508e" translate="yes" xml:space="preserve">
          <source>The return type of a function call expression is the return type of the chosen function, decided using static binding (ignoring the &lt;code&gt;virtual&lt;/code&gt; keyword), even if the overriding function that's actually called returns a different type. This allows the overriding functions to return pointers or references to classes that are derived from the return type returned by the base function, i.e. C++ supports &lt;a href=&quot;https://en.wikipedia.org/wiki/Covariant_return_type&quot;&gt;covariant return types&lt;/a&gt;. If &lt;code&gt;E&lt;/code&gt; specifies a destructor, the return type is &lt;code&gt;void&lt;/code&gt;.</source>
          <target state="translated">Тип возвращаемого значения выражения вызова функции - это тип возвращаемого значения выбранной функции, решенный с помощью статической привязки (игнорируя &lt;code&gt;virtual&lt;/code&gt; ключевое слово), даже если фактически вызываемая переопределяющая функция возвращает другой тип. Это позволяет переопределяющим функциям возвращать указатели или ссылки на классы, которые являются производными от типа возврата, возвращаемого базовой функцией, т.е. C ++ поддерживает &lt;a href=&quot;https://en.wikipedia.org/wiki/Covariant_return_type&quot;&gt;ковариантные типы возврата&lt;/a&gt; . Если &lt;code&gt;E&lt;/code&gt; указывает деструктор, тип возвращаемого значения &lt;code&gt;void&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e6bd94bee25a2724e9aec02300daa9aa8d7ac730" translate="yes" xml:space="preserve">
          <source>The return type of a function cannot be a function type or an array type (but can be a pointer or reference to those).</source>
          <target state="translated">Типом возвращаемой функции не может быть тип функции или тип массива (а может быть указателем или ссылкой на них).</target>
        </trans-unit>
        <trans-unit id="a43d728e1df955f1a8f98c6da37b2ab9a5744ca1" translate="yes" xml:space="preserve">
          <source>The return value may differ significantly from what &lt;code&gt;std::cout&lt;/code&gt; prints by default, see the example.</source>
          <target state="translated">Возвращаемое значение может значительно отличаться от того, что выводит &lt;code&gt;std::cout&lt;/code&gt; по умолчанию, см. Пример.</target>
        </trans-unit>
        <trans-unit id="39db23f7094ebdbb293d88cb43a6cdf8f30e157e" translate="yes" xml:space="preserve">
          <source>The return value of the called function.</source>
          <target state="translated">Возвращаемое значение вызываемой функции.</target>
        </trans-unit>
        <trans-unit id="181f5da030f77aa6d4d1c3eb608e9f1004e2dfd0" translate="yes" xml:space="preserve">
          <source>The return value of the function call operation applied to an object of a type satisfying Compare, when &lt;a href=&quot;../language/implicit_cast&quot;&gt;contextually converted&lt;/a&gt; to &lt;code&gt;bool&lt;/code&gt;, yields &lt;code&gt;true&lt;/code&gt; if the first argument of the call appears before the second in the</source>
          <target state="translated">Возвращаемое значение операции вызова функции применяется к объекту типа , удовлетворяющие сравнениям, когда &lt;a href=&quot;../language/implicit_cast&quot;&gt;контекстуально преобразуются&lt;/a&gt; в &lt;code&gt;bool&lt;/code&gt; , дает &lt;code&gt;true&lt;/code&gt; , если первый аргумент вызова появляется перед вторым в</target>
        </trans-unit>
        <trans-unit id="f9d8bf866400df7265b9950e52989553174c0d39" translate="yes" xml:space="preserve">
          <source>The returned array is not required to be null-terminated.</source>
          <target state="translated">Возвращаемый массив не обязательно должен быть нуль-терминированным.</target>
        </trans-unit>
        <trans-unit id="ee570e1ba2b43205f25df937e0cf18a3c9775dfe" translate="yes" xml:space="preserve">
          <source>The returned array is null-terminated, that is, &lt;code&gt;data()&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;c_str&quot;&gt;c_str()&lt;/a&gt;&lt;/code&gt; perform the same function.</source>
          <target state="translated">Возвращаемый массив завершается нулем, то есть &lt;code&gt;data()&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;c_str&quot;&gt;c_str()&lt;/a&gt;&lt;/code&gt; выполняют одну и ту же функцию.</target>
        </trans-unit>
        <trans-unit id="15def1750d934cba236118e97433bceee9bb7467" translate="yes" xml:space="preserve">
          <source>The returned object (call wrapper) has the following properties:</source>
          <target state="translated">Возвращаемый объект (обертка вызова)имеет следующие свойства:</target>
        </trans-unit>
        <trans-unit id="be9a9d8ae5b68cc7ac697a304429ef14785fc160" translate="yes" xml:space="preserve">
          <source>The returned object behaves as if it holds a member object &lt;code&gt;fd&lt;/code&gt; of type &lt;code&gt;&lt;a href=&quot;../../types/decay&quot;&gt;std::decay_t&lt;/a&gt;&amp;lt;F&amp;gt;&lt;/code&gt; constructed from &lt;code&gt;&lt;a href=&quot;../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;F&amp;gt;(f)&lt;/code&gt;, and an &lt;code&gt;&lt;a href=&quot;../tuple&quot;&gt;std::tuple&lt;/a&gt;&lt;/code&gt; object &lt;code&gt;tup&lt;/code&gt; constructed with &lt;code&gt;&lt;a href=&quot;../tuple/make_tuple&quot;&gt;std::make_tuple&lt;/a&gt;(&lt;a href=&quot;../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;Args&amp;gt;(args)...)&lt;/code&gt; (this unwraps any &lt;code&gt;&lt;a href=&quot;reference_wrapper&quot;&gt;std::reference_wrapper&lt;/a&gt;&lt;/code&gt;s), except that the returned object's assignment behavior is unspecified and the names are for exposition only.</source>
          <target state="translated">Возвращаемый объект ведет себя так , как будто он держит объект члена &lt;code&gt;fd&lt;/code&gt; типа &lt;code&gt;&lt;a href=&quot;../../types/decay&quot;&gt;std::decay_t&lt;/a&gt;&amp;lt;F&amp;gt;&lt;/code&gt; построено из &lt;code&gt;&lt;a href=&quot;../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;F&amp;gt;(f)&lt;/code&gt; , и &lt;code&gt;&lt;a href=&quot;../tuple&quot;&gt;std::tuple&lt;/a&gt;&lt;/code&gt; объекта &lt;code&gt;tup&lt;/code&gt; , построенный с &lt;code&gt;&lt;a href=&quot;../tuple/make_tuple&quot;&gt;std::make_tuple&lt;/a&gt;(&lt;a href=&quot;../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;Args&amp;gt;(args)...)&lt;/code&gt; (это разворачивает любые &lt;code&gt;&lt;a href=&quot;reference_wrapper&quot;&gt;std::reference_wrapper&lt;/a&gt;&lt;/code&gt; s), за исключением того, что поведение присваивания возвращаемого объекта не определено, а имена только для экспозиции.</target>
        </trans-unit>
        <trans-unit id="0b9ca1ed6de835f3a54269685f7c58a1fccb4f90" translate="yes" xml:space="preserve">
          <source>The returned pointer may outlive the last &lt;code&gt;shared_ptr&lt;/code&gt; if, for example, &lt;code&gt;&lt;a href=&quot;../weak_ptr&quot;&gt;std::weak_ptr&lt;/a&gt;&lt;/code&gt;s remain and the implementation doesn't destroy the deleter until the entire control block is destroyed.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../weak_ptr&quot;&gt;std::weak_ptr&lt;/a&gt;&lt;/code&gt; указатель может пережить последний &lt;code&gt;shared_ptr&lt;/code&gt; , если, например, остаются std :: weak_ptr и реализация не уничтожает средство удаления до тех пор, пока не будет уничтожен весь блок управления.</target>
        </trans-unit>
        <trans-unit id="db84c45c9a8b4735697eb1edd0bf4e4888aff852" translate="yes" xml:space="preserve">
          <source>The returned range is defined by two iterators, one pointing to the first element that is</source>
          <target state="translated">Возвращаемый диапазон определяется двумя итераторами,один из которых указывает на первый элемент,которым является</target>
        </trans-unit>
        <trans-unit id="fe922ac7f6db254043abd336f6ccd992ca241559" translate="yes" xml:space="preserve">
          <source>The returned string is constructed as if by &lt;code&gt;basic_string(data()+pos, count)&lt;/code&gt;, which implies that the returned string's allocator will be default-constructed &amp;mdash; the new allocator will</source>
          <target state="translated">Возвращаемая строка &lt;code&gt;basic_string(data()+pos, count)&lt;/code&gt; как бы с помощью basic_string (data () + pos, count) , что подразумевает, что распределитель возвращаемой строки будет создан по умолчанию - новый распределитель будет</target>
        </trans-unit>
        <trans-unit id="be7ba042cf486f9205da2c739695a1dd6890e1f2" translate="yes" xml:space="preserve">
          <source>The returned string must not be modified by the program, but may be overwritten by a subsequent call to the &lt;code&gt;strerror&lt;/code&gt; function. &lt;code&gt;strerror&lt;/code&gt; is not required to be thread-safe. Implementations may be returning different pointers to static read-only string literals or may be returning the same pointer over and over, pointing at a static buffer in which strerror places the string.</source>
          <target state="translated">Возвращенная строка не должна быть изменена программой, но может быть перезаписана последующим вызовом функции &lt;code&gt;strerror&lt;/code&gt; . &lt;code&gt;strerror&lt;/code&gt; не обязан быть потокобезопасным. Реализации могут возвращать разные указатели на статические строковые литералы, доступные только для чтения, или могут возвращать один и тот же указатель снова и снова, указывая на статический буфер, в который strerror помещает строку.</target>
        </trans-unit>
        <trans-unit id="6d5cdc0268f97ea1271d25f2faca49793842f74b" translate="yes" xml:space="preserve">
          <source>The returned value has the same sign as &lt;code&gt;x&lt;/code&gt; and is less than &lt;code&gt;y&lt;/code&gt; in magnitude.</source>
          <target state="translated">Возвращаемое значение имеет тот же знак, что и &lt;code&gt;x&lt;/code&gt; , и меньше величины &lt;code&gt;y&lt;/code&gt; по величине.</target>
        </trans-unit>
        <trans-unit id="d9cdb2a3429ed04aaceb9e604669e39a56f8c661" translate="yes" xml:space="preserve">
          <source>The returned value is exact (&lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INEXACT&lt;/a&gt;&lt;/code&gt; is never raised) and independent of the current &lt;a href=&quot;../fenv/fe_round&quot;&gt;rounding mode&lt;/a&gt;.</source>
          <target state="translated">Возвращаемое значение является точным ( &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INEXACT&lt;/a&gt;&lt;/code&gt; никогда не повышается) и не зависит от текущего &lt;a href=&quot;../fenv/fe_round&quot;&gt;режима округления&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="724b8307d3008dac328f6b273599dff3480427e3" translate="yes" xml:space="preserve">
          <source>The returned value is exact, &lt;a href=&quot;../fenv/fe_round&quot;&gt;the current rounding mode&lt;/a&gt; is ignored</source>
          <target state="translated">Возвращаемое значение является точным, &lt;a href=&quot;../fenv/fe_round&quot;&gt;текущий режим округления&lt;/a&gt; игнорируется</target>
        </trans-unit>
        <trans-unit id="f67fd770b1a87fd05c53e4a98601aa49812e9bb3" translate="yes" xml:space="preserve">
          <source>The reverse is not necessarily true: two objects of &lt;a href=&quot;../named_req/triviallycopyable&quot;&gt;TriviallyCopyable&lt;/a&gt; type with different object representations may represent the same value. For example, multiple floating-point bit patterns represent the same special value &lt;a href=&quot;../numeric/math/nan&quot;&gt;NaN&lt;/a&gt;. More commonly, some bits of the object representation may not participate in the value representation at all; such bits may be padding introduced to satisfy &lt;a href=&quot;objects#Alignment&quot;&gt;alignment requirements&lt;/a&gt;, &lt;a href=&quot;bit_field&quot;&gt;bit field&lt;/a&gt; sizes, etc.</source>
          <target state="translated">Обратное не обязательно верно: два объекта типа &lt;a href=&quot;../named_req/triviallycopyable&quot;&gt;TriviallyCopyable&lt;/a&gt; с разными представлениями объектов могут представлять одно и то же значение. Например, несколько битовых комбинаций с плавающей точкой представляют одно и то же специальное значение &lt;a href=&quot;../numeric/math/nan&quot;&gt;NaN&lt;/a&gt; . Чаще, некоторые биты представления объекта могут вообще не участвовать в представлении значения; такие биты могут быть дополнены, чтобы соответствовать &lt;a href=&quot;objects#Alignment&quot;&gt;требованиям выравнивания&lt;/a&gt; , размерам &lt;a href=&quot;bit_field&quot;&gt;битовых полей&lt;/a&gt; и т. д.</target>
        </trans-unit>
        <trans-unit id="4612adf8349954cddb8de34f362396a471ea78cb" translate="yes" xml:space="preserve">
          <source>The root directory of the path.</source>
          <target state="translated">Корневая директория пути.</target>
        </trans-unit>
        <trans-unit id="48c9793d32d94f49061760abdfca8adc649ed9d7" translate="yes" xml:space="preserve">
          <source>The root name of the path.</source>
          <target state="translated">Корневое имя пути.</target>
        </trans-unit>
        <trans-unit id="6a021f552f47982e6c4bf64045a925f56bdd2012" translate="yes" xml:space="preserve">
          <source>The root path of the path.</source>
          <target state="translated">Корневой путь.</target>
        </trans-unit>
        <trans-unit id="744a04bfacb0b83210251e4e038c93877d0b3385" translate="yes" xml:space="preserve">
          <source>The rounding mode can be changed with &lt;code&gt;&lt;a href=&quot;../../numeric/fenv/feround&quot;&gt;std::fesetround&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;FLT_ROUNDS&lt;/code&gt; reflects that change.</source>
          <target state="translated">Режим округления можно изменить с помощью &lt;code&gt;&lt;a href=&quot;../../numeric/fenv/feround&quot;&gt;std::fesetround&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;FLT_ROUNDS&lt;/code&gt; отражает это изменение.</target>
        </trans-unit>
        <trans-unit id="cfa7f1285b2f2a30572b8c02c0ae8fcae8230942" translate="yes" xml:space="preserve">
          <source>The rule about &quot;more efficient implementations&quot; permits bulk I/O without intermediate buffering: that's how &lt;code&gt;&lt;a href=&quot;../basic_istream/read&quot;&gt;std::ifstream::read&lt;/a&gt;&lt;/code&gt; simply passes the pointer to the POSIX &lt;code&gt;read()&lt;/code&gt; system call in some implementations of iostreams.</source>
          <target state="translated">Правило о &amp;laquo;более эффективных реализациях&amp;raquo; разрешает массовый ввод-вывод без промежуточной буферизации: именно так &lt;code&gt;&lt;a href=&quot;../basic_istream/read&quot;&gt;std::ifstream::read&lt;/a&gt;&lt;/code&gt; просто передает указатель на системный вызов &lt;code&gt;read()&lt;/code&gt; POSIX в некоторых реализациях iostreams.</target>
        </trans-unit>
        <trans-unit id="f0e4bed8bfc25aa394d951bf5cd88212770eda2b" translate="yes" xml:space="preserve">
          <source>The rule of three/five/zero</source>
          <target state="translated">Правило трех/пяти/ноля</target>
        </trans-unit>
        <trans-unit id="d764d84251b9e1e79eaf8ddf3fa38a07d394b2ff" translate="yes" xml:space="preserve">
          <source>The safe bool problem</source>
          <target state="translated">Проблема с &quot;безопасными дураками</target>
        </trans-unit>
        <trans-unit id="f2d334ca41df29ef25e36114b826d7adfb1af5ef" translate="yes" xml:space="preserve">
          <source>The same applies to the constructors of the next class in the I/O hierarchy, &lt;code&gt;&lt;a href=&quot;../basic_ios&quot;&gt;std::basic_ios&lt;/a&gt;&lt;/code&gt;. Further-derived classes (&lt;code&gt;&lt;a href=&quot;../basic_istream&quot;&gt;std::istream&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../basic_ostream&quot;&gt;std::ostream&lt;/a&gt;&lt;/code&gt;) are always constructed with a concrete streambuffer object and call &lt;a href=&quot;../basic_ios/init&quot;&gt;&lt;code&gt;basic_ios::init()&lt;/code&gt;&lt;/a&gt;, possibly more than once, to complete initialization of their virtual base.</source>
          <target state="translated">То же самое относится и к конструкторам следующего класса в иерархии ввода / вывода &lt;code&gt;&lt;a href=&quot;../basic_ios&quot;&gt;std::basic_ios&lt;/a&gt;&lt;/code&gt; . Производные классы ( &lt;code&gt;&lt;a href=&quot;../basic_istream&quot;&gt;std::istream&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;../basic_ostream&quot;&gt;std::ostream&lt;/a&gt;&lt;/code&gt; ) всегда создаются с конкретным объектом потокового буфера и вызывают &lt;a href=&quot;../basic_ios/init&quot;&gt; &lt;code&gt;basic_ios::init()&lt;/code&gt; &lt;/a&gt; , возможно, несколько раз, чтобы завершить инициализацию своей виртуальной базы.</target>
        </trans-unit>
        <trans-unit id="49089319d0e011162dc486f0fa5c79c193f99bb8" translate="yes" xml:space="preserve">
          <source>The same as &lt;code&gt;S(il.begin(), il.end())&lt;/code&gt;</source>
          <target state="translated">Так же, как &lt;code&gt;S(il.begin(), il.end())&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1208e3c0bd83fd14a6cdf867c21125c8a325392a" translate="yes" xml:space="preserve">
          <source>The same function may be registered more than once.</source>
          <target state="translated">Одна и та же функция может быть зарегистрирована несколько раз.</target>
        </trans-unit>
        <trans-unit id="9cb1515f8feac0bd625cac49b53fdf5bc0c4a06a" translate="yes" xml:space="preserve">
          <source>The same value is returned every time this function is called.</source>
          <target state="translated">При каждом вызове этой функции возвращается одно и то же значение.</target>
        </trans-unit>
        <trans-unit id="16a9673c83d6b7f5a89950887b3ffafe04e2f9d5" translate="yes" xml:space="preserve">
          <source>The same words are defined in the C programming language in the include file &lt;code&gt;&amp;lt;iso646.h&amp;gt;&lt;/code&gt; as macros. Because in C++ these are built into the language, the C++ version of &lt;code&gt;&amp;lt;iso646.h&amp;gt;&lt;/code&gt;, as well as &lt;code&gt;&amp;lt;ciso646&amp;gt;&lt;/code&gt;, does not define anything.</source>
          <target state="translated">Те же слова определены в языке программирования C во включаемом файле &lt;code&gt;&amp;lt;iso646.h&amp;gt;&lt;/code&gt; как макросы. Поскольку в C ++ они встроены в язык, версия &lt;code&gt;&amp;lt;iso646.h&amp;gt;&lt;/code&gt; для C ++ , а также &lt;code&gt;&amp;lt;ciso646&amp;gt;&lt;/code&gt; ничего не определяет.</target>
        </trans-unit>
        <trans-unit id="73fcd6a6bc40829dafc0c35e7f085fcf47650726" translate="yes" xml:space="preserve">
          <source>The scope of an entity declared in an unnamed namespace or in an inline namespace includes the enclosing namespace;</source>
          <target state="translated">Объем сущности,объявленной в безымянном пространстве имён или в строчном пространстве имён,включает в себя окружающее пространство имён;</target>
        </trans-unit>
        <trans-unit id="3bae590b6111c1b60bedc945d731d9c449dedcba" translate="yes" xml:space="preserve">
          <source>The scope of the name introduced by condition, if it is a declaration, is the combined scope of both statements' bodies:</source>
          <target state="translated">Сфера применения наименования,вводимого условием,если это заявление,является совокупной сферой применения обоих тел заявления:</target>
        </trans-unit>
        <trans-unit id="3e817d7c9bc7bbed9e0982e173160a7e98299780" translate="yes" xml:space="preserve">
          <source>The scoped enumeration &lt;code&gt;choose&lt;/code&gt; can be passed to certain member functions of &lt;code&gt;std::chrono::time_zone&lt;/code&gt; and &lt;code&gt;std::chrono::zoned_time&lt;/code&gt; to control how ambiguous or nonexistent local times should be resolved. Passing &lt;code&gt;choose::earliest&lt;/code&gt; causes the earlier time point to be returned, while passing &lt;code&gt;choose::latest&lt;/code&gt; causes the later time point to be returned. (For nonexistent local times, these two time points are identical.).</source>
          <target state="translated">Область действия перечисления &lt;code&gt;choose&lt;/code&gt; могут быть переданы некоторые функции членов &lt;code&gt;std::chrono::time_zone&lt;/code&gt; и &lt;code&gt;std::chrono::zoned_time&lt;/code&gt; контролировать как неоднозначные или несуществующие местное время должны быть решены. Передача &lt;code&gt;choose::earliest&lt;/code&gt; вызывает возврат более раннего момента времени, в то время как передача &lt;code&gt;choose::latest&lt;/code&gt; вызывает возврат более позднего момента времени. (Для несуществующего местного времени эти два момента времени идентичны.).</target>
        </trans-unit>
        <trans-unit id="840423b9be273862a9c8be4dd758424980f72802" translate="yes" xml:space="preserve">
          <source>The scoped enumeration &lt;code&gt;std::cv_status&lt;/code&gt; describes whether a timed wait returned because of timeout or not.</source>
          <target state="translated">Перечисление &lt;code&gt;std::cv_status&lt;/code&gt; перечисления std :: cv_status описывает, вернулось ли время ожидания из-за истечения времени ожидания или нет.</target>
        </trans-unit>
        <trans-unit id="a95fd75e62cf2bde9aca6a6e4779c05a5b287de7" translate="yes" xml:space="preserve">
          <source>The scoped enumeration &lt;code&gt;std::errc&lt;/code&gt; defines the values of portable error conditions that correspond to the POSIX error codes.</source>
          <target state="translated">Перечисление в области видимости &lt;code&gt;std::errc&lt;/code&gt; определяет значения переносимых состояний ошибок, которые соответствуют кодам ошибок POSIX.</target>
        </trans-unit>
        <trans-unit id="0ef7ce4c4de2f78554ef3fcfe42b9b69c424fdff" translate="yes" xml:space="preserve">
          <source>The scoped enumeration &lt;code&gt;std::future_errc&lt;/code&gt; defines the error codes reported by &lt;code&gt;&lt;a href=&quot;future&quot;&gt;std::future&lt;/a&gt;&lt;/code&gt; and related classes in &lt;code&gt;&lt;a href=&quot;future_error&quot;&gt;std::future_error&lt;/a&gt;&lt;/code&gt; exception objects. Only four error codes are required, although the implementation may define additional error codes. Because the appropriate specialization of &lt;code&gt;&lt;a href=&quot;../error/error_code/is_error_code_enum&quot;&gt;std::is_error_code_enum&lt;/a&gt;&lt;/code&gt; is provided, values of type &lt;code&gt;std::future_errc&lt;/code&gt; are implicitly convertible to &lt;code&gt;&lt;a href=&quot;../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Перечисление &lt;code&gt;std::future_errc&lt;/code&gt; определяет коды ошибок, о которых сообщают &lt;code&gt;&lt;a href=&quot;future&quot;&gt;std::future&lt;/a&gt;&lt;/code&gt; и связанные классы в &lt;code&gt;&lt;a href=&quot;future_error&quot;&gt;std::future_error&lt;/a&gt;&lt;/code&gt; исключений std :: future_error . Требуются только четыре кода ошибки, хотя реализация может определять дополнительные коды ошибок. Поскольку обеспечивается соответствующая специализация &lt;code&gt;&lt;a href=&quot;../error/error_code/is_error_code_enum&quot;&gt;std::is_error_code_enum&lt;/a&gt;&lt;/code&gt; , значения типа &lt;code&gt;std::future_errc&lt;/code&gt; неявно преобразуются в &lt;code&gt;&lt;a href=&quot;../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ca50a2fc4180751cf2b50c765d0d95358b35a4a9" translate="yes" xml:space="preserve">
          <source>The scoped enumeration &lt;code&gt;std::io_errc&lt;/code&gt; defines the error codes reported by I/O streams in &lt;code&gt;&lt;a href=&quot;ios_base/failure&quot;&gt;std::ios_base::failure&lt;/a&gt;&lt;/code&gt; exception objects. Only one error code (&lt;code&gt;std::io_errc::stream&lt;/code&gt;) is required, although the implementation may define additional error codes. Because the appropriate specialization of &lt;code&gt;&lt;a href=&quot;../error/error_code/is_error_code_enum&quot;&gt;std::is_error_code_enum&lt;/a&gt;&lt;/code&gt; is provided, values of type &lt;code&gt;std::io_errc&lt;/code&gt; are implicitly convertible to &lt;code&gt;&lt;a href=&quot;../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Перечисление &lt;code&gt;std::io_errc&lt;/code&gt; определяет коды ошибок, сообщаемые потоками ввода-вывода в &lt;code&gt;&lt;a href=&quot;ios_base/failure&quot;&gt;std::ios_base::failure&lt;/a&gt;&lt;/code&gt; исключений std :: ios_base :: fail . &lt;code&gt;std::io_errc::stream&lt;/code&gt; только один код ошибки ( std :: io_errc :: stream ), хотя реализация может определять дополнительные коды ошибок. Поскольку обеспечивается соответствующая специализация &lt;code&gt;&lt;a href=&quot;../error/error_code/is_error_code_enum&quot;&gt;std::is_error_code_enum&lt;/a&gt;&lt;/code&gt; , значения типа &lt;code&gt;std::io_errc&lt;/code&gt; неявно преобразуются в &lt;code&gt;&lt;a href=&quot;../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bf90aead8c2a5530e7c352d89f0a4c787a4c9dca" translate="yes" xml:space="preserve">
          <source>The scoped enumeration type &lt;code&gt;pointer_safety&lt;/code&gt; lists the pointer safety modes supported by C++</source>
          <target state="translated">Перечисляемый тип &lt;code&gt;pointer_safety&lt;/code&gt; с указателем в виде_обезопасности перечисляет режимы безопасности указателя, поддерживаемые C ++</target>
        </trans-unit>
        <trans-unit id="2dc9a7f6fd0f7a91a7650300695af1e539734973" translate="yes" xml:space="preserve">
          <source>The second operand of both operators is a name of (formally, an &lt;a href=&quot;name#In_expressions&quot;&gt;id-expression&lt;/a&gt; that names) a data member or member function of &lt;code&gt;T&lt;/code&gt; or of an unambiguous and accessible base class &lt;code&gt;B&lt;/code&gt; of &lt;code&gt;T&lt;/code&gt; (e.g. &lt;code&gt;E1.E2&lt;/code&gt; or &lt;code&gt;E1-&amp;gt;E2&lt;/code&gt;), optionally &lt;a href=&quot;name#Qualified_identifiers&quot;&gt;qualified&lt;/a&gt; (e.g. &lt;code&gt;E1.B::E2&lt;/code&gt; or &lt;code&gt;E1-&amp;gt;B::E2&lt;/code&gt;), optionally using &lt;a href=&quot;dependent_name&quot;&gt;template disambiguator&lt;/a&gt; (e.g. &lt;code&gt;E1.template E2&lt;/code&gt; or &lt;code&gt;E1-&amp;gt;template E2&lt;/code&gt;).</source>
          <target state="translated">Второй операнд обоих операторов является имя (Формально &lt;a href=&quot;name#In_expressions&quot;&gt;идентификатор-выражение&lt;/a&gt; , что имен) член данных или член функции &lt;code&gt;T&lt;/code&gt; или однозначного и доступного базового класса &lt;code&gt;B&lt;/code&gt; из &lt;code&gt;T&lt;/code&gt; (например , &lt;code&gt;E1.E2&lt;/code&gt; или &lt;code&gt;E1-&amp;gt;E2&lt;/code&gt; ) необязательно &lt;a href=&quot;name#Qualified_identifiers&quot;&gt;квалифицирован&lt;/a&gt; (например &lt;code&gt;E1.B::E2&lt;/code&gt; или &lt;code&gt;E1-&amp;gt;B::E2&lt;/code&gt; ), необязательно с использованием &lt;a href=&quot;dependent_name&quot;&gt;шаблона disambiguator&lt;/a&gt; (например &lt;code&gt;E1.template E2&lt;/code&gt; или &lt;code&gt;E1-&amp;gt;template E2&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="19215a02c420276aa98badc49ffb9d2736ab482c" translate="yes" xml:space="preserve">
          <source>The second operand of both operators is an expression of type pointer to member ( &lt;a href=&quot;pointer#Pointers_to_data_members&quot;&gt;data&lt;/a&gt; or &lt;a href=&quot;pointer#Pointers_to_member_functions&quot;&gt;function&lt;/a&gt;) of &lt;code&gt;T&lt;/code&gt; or pointer to member of an unambiguous and accessible base class &lt;code&gt;B&lt;/code&gt; of &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">Второй операнд обоих операторов является выражением типа указателя для члена ( &lt;a href=&quot;pointer#Pointers_to_data_members&quot;&gt;данные&lt;/a&gt; или &lt;a href=&quot;pointer#Pointers_to_member_functions&quot;&gt;функции&lt;/a&gt; ) от &lt;code&gt;T&lt;/code&gt; или указатель на член однозначного и доступного базового класса &lt;code&gt;B&lt;/code&gt; из &lt;code&gt;T&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0c55eea87a0f8d8889265157fbe6787960184823" translate="yes" xml:space="preserve">
          <source>The second overload contains a separate template parameter for the head of the arguments and a parameter pack, this allows the recursive call to pass only the tail of the parameters until it becomes empty.</source>
          <target state="translated">Вторая перегрузка содержит отдельный шаблонный параметр для заголовка аргументов и пакет параметров,что позволяет рекурсивному вызову передавать только хвост параметров до тех пор,пока он не станет пустым.</target>
        </trans-unit>
        <trans-unit id="be075fc3b764cc15641e30da0af7956f238d21f0" translate="yes" xml:space="preserve">
          <source>The second pass through the callbacks may be used to deep-copy the user-defined objects pointed to by the pointers in &lt;code&gt;&lt;a href=&quot;../ios_base/pword&quot;&gt;std::ios_base::pword&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Второй проход через обратные вызовы может быть использован для глубокого копирования пользовательских объектов, на которые указывают указатели в &lt;code&gt;&lt;a href=&quot;../ios_base/pword&quot;&gt;std::ios_base::pword&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b0a5b7b985ce580725fc7689da25a9594bd797ad" translate="yes" xml:space="preserve">
          <source>The second signature behaves as if called with &lt;code&gt;opts&lt;/code&gt; set to &lt;code&gt;perm_options::replace&lt;/code&gt;.</source>
          <target state="translated">Вторая подпись ведет себя так , как будто вызывается с &lt;code&gt;opts&lt;/code&gt; , установленной в &lt;code&gt;perm_options::replace&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2748b8b2515518309d2bd896dc6dc045638385c8" translate="yes" xml:space="preserve">
          <source>The selected elements must exist.</source>
          <target state="translated">Выбранные элементы должны существовать.</target>
        </trans-unit>
        <trans-unit id="da6776cef8700dee0f22e58931e5d3627bef7c47" translate="yes" xml:space="preserve">
          <source>The semantics of inheriting constructors were retroactively changed by a &lt;a href=&quot;using_declaration#Defect_reports&quot;&gt;defect report against C++11&lt;/a&gt;. Previously, an inheriting constructor declaration caused a set of synthesized constructor declarations to be injected into the derived class, which caused redundant argument copies/moves, had problematic interactions with some forms of SFINAE, and in some cases can be unimplementable on major ABIs. Older compilers may still implement the previous semantics.</source>
          <target state="translated">Семантика наследующих конструкторов задним числом изменена в &lt;a href=&quot;using_declaration#Defect_reports&quot;&gt;отчете&lt;/a&gt; о дефектах в C ++ 11 . Ранее объявление наследующего конструктора приводило к тому, что набор синтезированных объявлений конструктора вставлялся в производный класс, что вызывало избыточные копии / перемещения аргументов, имело проблемные взаимодействия с некоторыми формами SFINAE, а в некоторых случаях может быть неосуществимо в основных ABI. Старые компиляторы могут все еще реализовать предыдущую семантику.</target>
        </trans-unit>
        <trans-unit id="bfeb9ddde9efbc3c0ab3714a0a6e7a8a3efc2e2c" translate="yes" xml:space="preserve">
          <source>The semantics of the member functions are defined are as follows.</source>
          <target state="translated">Семантика функций членов определяется следующим образом.</target>
        </trans-unit>
        <trans-unit id="276fbc8f397db984b2189ed81138a185a9b8f9c5" translate="yes" xml:space="preserve">
          <source>The semantics of this function are intended to be consistent with the C function &lt;a href=&quot;http://en.cppreference.com/w/c/numeric/complex/clog.html&quot;&gt;&lt;code&gt;clog&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Семантика этой функции предназначены быть совместимы с функцией C &lt;a href=&quot;http://en.cppreference.com/w/c/numeric/complex/clog.html&quot;&gt; &lt;code&gt;clog&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="630a0686e90df2d1198d4a4bff7aa262b9655ed1" translate="yes" xml:space="preserve">
          <source>The semantics of this function are intended to be consistent with the C function &lt;a href=&quot;http://en.cppreference.com/w/c/numeric/complex/csqrt.html&quot;&gt;&lt;code&gt;csqrt&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Семантика этой функции предназначена для соответствия C-функции &lt;a href=&quot;http://en.cppreference.com/w/c/numeric/complex/csqrt.html&quot;&gt; &lt;code&gt;csqrt&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f09342387ba1e64c32080173dab4604297f52ab0" translate="yes" xml:space="preserve">
          <source>The sequence denoted by this pair of iterators consists of the following:</source>
          <target state="translated">Последовательность,обозначаемая этой парой итераторов,состоит из следующего:</target>
        </trans-unit>
        <trans-unit id="8cf1423eae846ac729f66d139e28a402cef688fa" translate="yes" xml:space="preserve">
          <source>The sequence of &lt;code&gt;char&lt;/code&gt;s accumulated in Stage 2 is converted to a numeric value</source>
          <target state="translated">Последовательность &lt;code&gt;char&lt;/code&gt; накопленных на этапе 2, преобразуется в числовое значение</target>
        </trans-unit>
        <trans-unit id="61ab9fb3fc586d17241f33750480c6a753617cad" translate="yes" xml:space="preserve">
          <source>The sequence of numbers returned by successive invocations of this call with the same &lt;code&gt;g&lt;/code&gt; are randomly distributed according to the distribution parametrized by &lt;code&gt;d.param()&lt;/code&gt;</source>
          <target state="translated">Последовательность чисел, возвращаемых последовательными вызовами этого вызова с одним и тем же &lt;code&gt;g&lt;/code&gt; , распределяется случайным образом в соответствии с распределением, параметризованным &lt;code&gt;d.param()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8ad57e0d60c4213ba3be7acf41e0955df808546a" translate="yes" xml:space="preserve">
          <source>The sequence of numbers returned by successive invocations of this call with the same &lt;code&gt;g&lt;/code&gt; are randomly distributed according to the distribution parametrized by &lt;code&gt;p&lt;/code&gt;</source>
          <target state="translated">Последовательность чисел, возвращаемых последовательными вызовами этого вызова с одним и тем же &lt;code&gt;g&lt;/code&gt; , распределяется случайным образом в соответствии с распределением, параметризованным &lt;code&gt;p&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="326be078a4bda5f44b21dfc8b70dd484a2be09be" translate="yes" xml:space="preserve">
          <source>The set of candidate functions and the list of arguments is prepared in a unique way for each of the contexts where overload resolution is used:</source>
          <target state="translated">Набор функций кандидата и список аргументов подготавливается уникальным образом для каждого из контекстов,в которых используется разрешение перегрузки:</target>
        </trans-unit>
        <trans-unit id="5fc5fc4fdccda5729ebc678de9b6bf863450c8f5" translate="yes" xml:space="preserve">
          <source>The set of candidate functions to be submitted for overload resolution is a union of the sets above. The argument list for the purpose of overload resolution consists of the operands of the operator except for &lt;code&gt;operator-&amp;gt;&lt;/code&gt;, where the second operand is not an argument for the function call (see &lt;a href=&quot;operator_member_access#Built-in_member_access_operators&quot;&gt;member access operator&lt;/a&gt;).</source>
          <target state="translated">Набор функций-кандидатов, которые должны быть представлены для разрешения перегрузки, представляет собой объединение вышеперечисленных наборов. Список аргументов для разрешения перегрузки состоит из операндов оператора, за исключением &lt;code&gt;operator-&amp;gt;&lt;/code&gt; , где второй операнд не является аргументом для вызова функции (см. &lt;a href=&quot;operator_member_access#Built-in_member_access_operators&quot;&gt;Оператор доступа к члену&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="a1904e66df24bc3e43e3c61d84a3ad2129497a05" translate="yes" xml:space="preserve">
          <source>The set of declarations found by ordinary &lt;a href=&quot;lookup&quot;&gt;unqualified lookup&lt;/a&gt; and the set of declarations found in all elements of the associated set produced by ADL, are merged, with the following special rules.</source>
          <target state="translated">Набор объявлений, найденных обычным &lt;a href=&quot;lookup&quot;&gt;безусловным поиском,&lt;/a&gt; и набор объявлений, найденных во всех элементах связанного набора, созданного ADL, объединяются со следующими специальными правилами.</target>
        </trans-unit>
        <trans-unit id="633b59c91cf4f999e02e8403d839498119457c8d" translate="yes" xml:space="preserve">
          <source>The set of interval boundaries b</source>
          <target state="translated">Набор границ интервалов b</target>
        </trans-unit>
        <trans-unit id="e3b735a300b426d2245b4cf296a3150fc21a63b1" translate="yes" xml:space="preserve">
          <source>The set of valid values for base is {0,2,3,...,36}. The set of valid digits for base-2 integers is &lt;code&gt;{0,1&lt;/code&gt;}, for base-3 integers is &lt;code&gt;{0,1,2&lt;/code&gt;}, and so on. For bases larger than &lt;code&gt;10&lt;/code&gt;, valid digits include alphabetic characters, starting from &lt;code&gt;Aa&lt;/code&gt; for base-11 integer, to &lt;code&gt;Zz&lt;/code&gt; for base-36 integer. The case of the characters is ignored.</source>
          <target state="translated">Набор допустимых значений для базы: {0,2,3, ..., 36}. Набор действительных цифр для целых чисел с основанием 2 равен &lt;code&gt;{0,1&lt;/code&gt; }, для целых чисел с основанием 3 равен &lt;code&gt;{0,1,2&lt;/code&gt; } и т. Д. Для оснований больше &lt;code&gt;10&lt;/code&gt; допустимые цифры включают буквенные символы, начиная от &lt;code&gt;Aa&lt;/code&gt; для целого числа base-11, до &lt;code&gt;Zz&lt;/code&gt; для целого числа base-36. Регистр символов игнорируется.</target>
        </trans-unit>
        <trans-unit id="54f77766bc9f988f0c109a0b9a274a2d62a58aff" translate="yes" xml:space="preserve">
          <source>The shared state already stores a value or exception. The error category is set to &lt;a href=&quot;../future_errc&quot;&gt;&lt;code&gt;promise_already_satisfied&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Общее состояние уже хранит значение или исключение. Категория ошибки установлена ​​в &lt;a href=&quot;../future_errc&quot;&gt; &lt;code&gt;promise_already_satisfied&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="dd74c3ed26047fa14c5abbda7f8120251339635c" translate="yes" xml:space="preserve">
          <source>The shared state has already been retrieved via a call to &lt;code&gt;get_future&lt;/code&gt;. The error category is set to &lt;a href=&quot;../future_errc&quot;&gt;&lt;code&gt;future_already_retrieved&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Общее состояние уже было получено с помощью вызова &lt;code&gt;get_future&lt;/code&gt; . Категория ошибки установлена ​​в &lt;a href=&quot;../future_errc&quot;&gt; &lt;code&gt;future_already_retrieved&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="817c4cd2132343bd97c84575fd05e4ae8b2ee89e" translate="yes" xml:space="preserve">
          <source>The shared state is only made ready after the current thread exits and all objects of</source>
          <target state="translated">Общее состояние становится готовым только после того,как текущий поток выйдет и все объекты</target>
        </trans-unit>
        <trans-unit id="6e13e04bbcf515d86b1c971f508fc8ad239fb065" translate="yes" xml:space="preserve">
          <source>The short-circuit instantiation differentiates &lt;code&gt;conjunction&lt;/code&gt; from fold expressions: a fold expression like &lt;code&gt;(... &amp;amp;&amp;amp; Bs::value)&lt;/code&gt; instantiates every &lt;code&gt;B&lt;/code&gt; in &lt;code&gt;Bs&lt;/code&gt;, while &lt;code&gt;std::conjunction_v&amp;lt;Bs...&amp;gt;&lt;/code&gt; stops instantiation once the value can be determined. This is particularly useful if the later type is expensive to instantiate or can cause a hard error when instantiated with the wrong type.</source>
          <target state="translated">Создание экземпляров при коротком замыкании отличает &lt;code&gt;conjunction&lt;/code&gt; от выражений сгиба: выражение сгиба, подобное &lt;code&gt;(... &amp;amp;&amp;amp; Bs::value)&lt;/code&gt; создает каждый &lt;code&gt;B&lt;/code&gt; в &lt;code&gt;Bs&lt;/code&gt; , в то время как &lt;code&gt;std::conjunction_v&amp;lt;Bs...&amp;gt;&lt;/code&gt; останавливает создание экземпляра после определения значения , Это особенно полезно, если более поздний тип является дорогостоящим для создания экземпляра или может вызвать серьезную ошибку при создании экземпляра с неправильным типом.</target>
        </trans-unit>
        <trans-unit id="4b6b7f6a466d865c0d71c17ba70598d418424cc5" translate="yes" xml:space="preserve">
          <source>The short-circuit instantiation differentiates &lt;code&gt;disjunction&lt;/code&gt; from fold expressions: a fold expression like &lt;code&gt;(... || Bs::value)&lt;/code&gt; instantiates every &lt;code&gt;B&lt;/code&gt; in &lt;code&gt;Bs&lt;/code&gt;, while &lt;code&gt;std::disjunction_v&amp;lt;Bs...&amp;gt;&lt;/code&gt; stops instantiation once the value can be determined. This is particularly useful if the later type is expensive to instantiate or can cause a hard error when instantiated with the wrong type.</source>
          <target state="translated">Создание экземпляров при коротком замыкании отличает &lt;code&gt;disjunction&lt;/code&gt; от выражений сгиба: выражение сгиба, подобное &lt;code&gt;(... || Bs::value)&lt;/code&gt; создает каждый &lt;code&gt;B&lt;/code&gt; в &lt;code&gt;Bs&lt;/code&gt; , тогда как &lt;code&gt;std::disjunction_v&amp;lt;Bs...&amp;gt;&lt;/code&gt; останавливает создание экземпляра, как только значение может быть определяется. Это особенно полезно, если более поздний тип является дорогостоящим для создания экземпляра или может вызвать серьезную ошибку при создании экземпляра с неправильным типом.</target>
        </trans-unit>
        <trans-unit id="a6fb9e43d23dc62112f027d6321e004ed3458fa2" translate="yes" xml:space="preserve">
          <source>The side-effect A on a scalar M (a write) is</source>
          <target state="translated">Побочный эффект A на скаляре М (запись)-это</target>
        </trans-unit>
        <trans-unit id="35d03624f1f46c34b182260c7be6e91d340366f1" translate="yes" xml:space="preserve">
          <source>The sign of the result is the sign of the difference between the values of the first pair of bytes (both interpreted as &lt;code&gt;unsigned char&lt;/code&gt;) that differ in the objects being compared.</source>
          <target state="translated">Знак результата - это знак различия между значениями первой пары байтов (оба интерпретируются как &lt;code&gt;unsigned char&lt;/code&gt; ), которые различаются в сравниваемых объектах.</target>
        </trans-unit>
        <trans-unit id="e97cc12d1f3f2487de1b90ed0cc2090797374f8e" translate="yes" xml:space="preserve">
          <source>The sign of the result is the sign of the difference between the values of the first pair of characters (both interpreted as &lt;code&gt;unsigned char&lt;/code&gt;) that differ in the strings being compared.</source>
          <target state="translated">Знак результата - это знак различия между значениями первой пары символов (оба интерпретируются как &lt;code&gt;unsigned char&lt;/code&gt; ), которые различаются в сравниваемых строках.</target>
        </trans-unit>
        <trans-unit id="cde6f3dc011075607068991f0904ec95fd72723b" translate="yes" xml:space="preserve">
          <source>The sign of the result is the sign of the difference between the values of the first pair of wide characters that differ in the arrays being compared.</source>
          <target state="translated">Знак результата-это признак разницы между значениями первой пары широких символов,отличающихся в сравниваемых массивах.</target>
        </trans-unit>
        <trans-unit id="f67aeb4832459c9bfc7aeb9f457a87aa921f1247" translate="yes" xml:space="preserve">
          <source>The sign of the result is the sign of the difference between the values of the first pair of wide characters that differ in the strings being compared.</source>
          <target state="translated">Знак результата-это признак разницы между значениями первой пары широких символов,отличающихся в сравниваемых строках.</target>
        </trans-unit>
        <trans-unit id="7c011cc304f5801ea8e7fc6376c1a87eaf494c1e" translate="yes" xml:space="preserve">
          <source>The signature does not need to have &lt;code&gt;const &amp;amp;&lt;/code&gt;.</source>
          <target state="translated">Подпись не должна иметь &lt;code&gt;const &amp;amp;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4d5cf620ffd0c069fb09e6109069ba28e165d978" translate="yes" xml:space="preserve">
          <source>The signature of the comparison function should be equivalent to the following:</source>
          <target state="translated">Подпись функции сравнения должна быть эквивалентна следующей:</target>
        </trans-unit>
        <trans-unit id="a6eece811de82334f897e04a0286d22b8a1880ad" translate="yes" xml:space="preserve">
          <source>The signature of the function should be equivalent to the following:</source>
          <target state="translated">Подпись функции должна быть эквивалентна следующей:</target>
        </trans-unit>
        <trans-unit id="e16d376fc732d9fd890a8e68862e00b90427d089" translate="yes" xml:space="preserve">
          <source>The signature of the predicate function should be equivalent to the following:</source>
          <target state="translated">Подпись предикатной функции должна быть эквивалентна следующей:</target>
        </trans-unit>
        <trans-unit id="5471ac941bf0f0fd4abf99ed5f3d659518a0c817" translate="yes" xml:space="preserve">
          <source>The similarly-named container member functions &lt;a href=&quot;../container/list/remove&quot;&gt;&lt;code&gt;list::remove&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../container/list/remove&quot;&gt;&lt;code&gt;list::remove_if&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../container/forward_list/remove&quot;&gt;&lt;code&gt;forward_list::remove&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;../container/forward_list/remove&quot;&gt;&lt;code&gt;forward_list::remove_if&lt;/code&gt;&lt;/a&gt; erase the removed elements.</source>
          <target state="translated">Функции-члены контейнера с одинаковыми именами &lt;a href=&quot;../container/list/remove&quot;&gt; &lt;code&gt;list::remove&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../container/list/remove&quot;&gt; &lt;code&gt;list::remove_if&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../container/forward_list/remove&quot;&gt; &lt;code&gt;forward_list::remove&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;../container/forward_list/remove&quot;&gt; &lt;code&gt;forward_list::remove_if&lt;/code&gt; &lt;/a&gt; удаляют удаленные элементы.</target>
        </trans-unit>
        <trans-unit id="d18977a380068b230c78baa2354437eff8114c95" translate="yes" xml:space="preserve">
          <source>The sine is an entire function on the complex plane, and has no branch cuts.  Mathematical definition of the sine is sin z =</source>
          <target state="translated">Синус является целой функцией на комплексной плоскости,и не имеет разрезов ветвей.Математическое определение синуса-грех z =</target>
        </trans-unit>
        <trans-unit id="b269c185388406409d66b389ee290905aa3250c2" translate="yes" xml:space="preserve">
          <source>The single total order might not be consistent with</source>
          <target state="translated">Единый общий заказ может не соответствовать</target>
        </trans-unit>
        <trans-unit id="a1e4ac9052c7611ed3e612ed7782e64fa0ddd565" translate="yes" xml:space="preserve">
          <source>The size of &lt;code&gt;A&lt;/code&gt;'s state is no less than the size of &lt;code&gt;b&lt;/code&gt;</source>
          <target state="translated">Размер состояния &lt;code&gt;A&lt;/code&gt; не меньше размера &lt;code&gt;b&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ffa4ef58b6f217f15dfbc54c8b0b3fa97f978e5a" translate="yes" xml:space="preserve">
          <source>The size of &lt;code&gt;c&lt;/code&gt; or &lt;code&gt;array&lt;/code&gt;.</source>
          <target state="translated">Размер &lt;code&gt;c&lt;/code&gt; или &lt;code&gt;array&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1a42f803c92acdfd49c509a1473d94317255f86f" translate="yes" xml:space="preserve">
          <source>The size of any &lt;a href=&quot;objects&quot;&gt;object&lt;/a&gt; or member subobject (unless &lt;code&gt;[[no_unique_address]]&lt;/code&gt; -- see below)(since C++20) is required to be at least 1 even if the type is an empty &lt;a href=&quot;class&quot;&gt;class type&lt;/a&gt; (that is, a class or struct that has no non-static data members), in order to be able to guarantee that the addresses of distinct objects of the same type are always distinct.</source>
          <target state="translated">Размер любого &lt;a href=&quot;objects&quot;&gt;объекта&lt;/a&gt; или подобъекта члена (если только &lt;code&gt;[[no_unique_address]]&lt;/code&gt; - см. Ниже) (начиная с C ++ 20) должен быть не менее 1, даже если тип является пустым &lt;a href=&quot;class&quot;&gt;типом класса&lt;/a&gt; (то есть класс или структура, которая не имеет нестатических членов данных), чтобы гарантировать, что адреса различных объектов одного типа всегда различны.</target>
        </trans-unit>
        <trans-unit id="60fb803f3af93287267581b597b353fbed331445" translate="yes" xml:space="preserve">
          <source>The size of the file, in bytes.</source>
          <target state="translated">Размер файла,в байтах.</target>
        </trans-unit>
        <trans-unit id="fdc6fa0a097f223b138fc7c44f70083d5b4bcb5a" translate="yes" xml:space="preserve">
          <source>The size of the private container that was populated at construction time.</source>
          <target state="translated">Размер частного контейнера,который был заселен во время строительства.</target>
        </trans-unit>
        <trans-unit id="3facb159d302e57398e2b32d50c748002ccee995" translate="yes" xml:space="preserve">
          <source>The size of the pushback buffer varies in practice from 4k (Linux, MacOS) to as little as 4 (Solaris) or the guaranteed minimum 1 (HPUX, AIX).</source>
          <target state="translated">Размер буфера обратной связи на практике варьируется от 4k (Linux,MacOS)до всего 4 (Solaris)или гарантированного минимума 1 (HPUX,AIX).</target>
        </trans-unit>
        <trans-unit id="c2459bce198cb000b381177d5cc738c181699405" translate="yes" xml:space="preserve">
          <source>The size of the referred-to filesystem object.</source>
          <target state="translated">Размер объекта ссылочной файловой системы.</target>
        </trans-unit>
        <trans-unit id="2a786a72bf82ea447c9d87b5be65ed00ac14cb03" translate="yes" xml:space="preserve">
          <source>The size of the sequence in bytes, i.e., &lt;code&gt;size() * sizeof(element_type)&lt;/code&gt;.</source>
          <target state="translated">Размер последовательности в байтах, т.е. &lt;code&gt;size() * sizeof(element_type)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="66997ef04e230b1f79e491df0b1540977ef30033" translate="yes" xml:space="preserve">
          <source>The sizeof... operator</source>
          <target state="translated">Размер...оператора</target>
        </trans-unit>
        <trans-unit id="e03ce5e1c2c2d6a504f6be8da7e802aa894a2643" translate="yes" xml:space="preserve">
          <source>The smallest &lt;code&gt;q&lt;/code&gt; in &lt;code&gt;[p,p+n)&lt;/code&gt; such that &lt;code&gt;X​::​eq(*q, c)&lt;/code&gt; is true</source>
          <target state="translated">Наименьшее &lt;code&gt;q&lt;/code&gt; в &lt;code&gt;[p,p+n)&lt;/code&gt; такое, что &lt;code&gt;X​::​eq(*q, c)&lt;/code&gt; истинно</target>
        </trans-unit>
        <trans-unit id="164a8a1e2ed3ac9211701d99d6d1f9abf5da92d6" translate="yes" xml:space="preserve">
          <source>The smallest integral power of two that is not smaller than &lt;code&gt;x&lt;/code&gt;, or an unspecified value if the result cannot be represented in &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">Наименьшая интегральная мощность двух , что не меньше , чем &lt;code&gt;x&lt;/code&gt; , или неопределенное значение , если результат не может быть представлен в &lt;code&gt;T&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6019aa352c36bf78f73a83e660e2da74f2e4c2ce" translate="yes" xml:space="preserve">
          <source>The socket is not connected</source>
          <target state="translated">Розетка не подключена</target>
        </trans-unit>
        <trans-unit id="c1a77c31870ff87a240876e0120da8708b5e5e1e" translate="yes" xml:space="preserve">
          <source>The sole exceptions to the maximal munch rule are:</source>
          <target state="translated">Единственное исключение из правила максимального жевания:</target>
        </trans-unit>
        <trans-unit id="023ae07779bac9c8efdef6a9eb724121da731b80" translate="yes" xml:space="preserve">
          <source>The source of the messages is implementation-defined.</source>
          <target state="translated">Источник сообщений определяется реализацией.</target>
        </trans-unit>
        <trans-unit id="be9039b113cba4c87f833cb8a33bdd196413e28b" translate="yes" xml:space="preserve">
          <source>The span must have static extent (i.e., &lt;code&gt;N != &lt;a href=&quot;dynamic_extent&quot;&gt;std::dynamic_extent&lt;/a&gt;&lt;/code&gt;) and &lt;code&gt;I&lt;/code&gt; must be an integer value in range &lt;code&gt;[0, N)&lt;/code&gt;. This is enforced at compile time as opposed to &lt;code&gt;operator[]&lt;/code&gt;.</source>
          <target state="translated">Диапазон должен иметь статический экстент (т. Е. &lt;code&gt;N != &lt;a href=&quot;dynamic_extent&quot;&gt;std::dynamic_extent&lt;/a&gt;&lt;/code&gt; ), и &lt;code&gt;I&lt;/code&gt; должен быть целочисленным значением в диапазоне &lt;code&gt;[0, N)&lt;/code&gt; . Это применяется во время компиляции, в отличие от &lt;code&gt;operator[]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2e5608fbdb3aeacdd6ea3d40e4a18d5358477dba" translate="yes" xml:space="preserve">
          <source>The special pathname dot (&lt;code&gt;&quot;.&quot;&lt;/code&gt;) is a hard link to its parent directory. The special pathname dot-dot &lt;code&gt;&quot;..&quot;&lt;/code&gt; is a hard link to the directory that is the parent of its parent.</source>
          <target state="translated">Точка специального пути ( &lt;code&gt;&quot;.&quot;&lt;/code&gt; ) - это жесткая ссылка на родительский каталог. Специальное имя пути точка-точка &lt;code&gt;&quot;..&quot;&lt;/code&gt; - это жесткая ссылка на каталог, который является родителем его родителя.</target>
        </trans-unit>
        <trans-unit id="d5b3112d1aecd8e0bc024d6e95c5b21d74c58b9f" translate="yes" xml:space="preserve">
          <source>The special pathnames dot and dot-dot are skipped.</source>
          <target state="translated">Специальные патнамы точка и точка пропущены.</target>
        </trans-unit>
        <trans-unit id="3fec246ae7b3831f5d777421b3527ac038580e09" translate="yes" xml:space="preserve">
          <source>The special unnamed bit field of size zero can be forced to break up padding. It specifies that the next bit field begins at the beginning of its allocation unit:</source>
          <target state="translated">Специальное безымянное битовое поле нулевого размера может быть вынуждено разбивать обивку.Оно указывает,что следующее битовое поле начинается с начала единицы распределения:</target>
        </trans-unit>
        <trans-unit id="05614a0a97be351dbad65c4504f830ce86618f1b" translate="yes" xml:space="preserve">
          <source>The specialization &lt;a href=&quot;../vector_bool&quot;&gt;std::vector&amp;lt;bool&amp;gt;&lt;/a&gt; did not have &lt;code&gt;emplace()&lt;/code&gt; member until C++14.</source>
          <target state="translated">Специализация &lt;a href=&quot;../vector_bool&quot;&gt;std :: vector &amp;lt;bool&amp;gt;&lt;/a&gt; не имела &lt;code&gt;emplace()&lt;/code&gt; до C ++ 14.</target>
        </trans-unit>
        <trans-unit id="c0c58597769cd63f71580480f8d3215395bbf758" translate="yes" xml:space="preserve">
          <source>The specialization &lt;a href=&quot;../vector_bool&quot;&gt;std::vector&amp;lt;bool&amp;gt;&lt;/a&gt; did not have &lt;code&gt;emplace_back()&lt;/code&gt; member until C++14.</source>
          <target state="translated">Специализация &lt;a href=&quot;../vector_bool&quot;&gt;std :: vector &amp;lt;bool&amp;gt;&lt;/a&gt; не имела &lt;code&gt;emplace_back()&lt;/code&gt; до C ++ 14.</target>
        </trans-unit>
        <trans-unit id="8bec2e9d713031b66c24ef679d2b78ee8bb1782e" translate="yes" xml:space="preserve">
          <source>The specialization &lt;code&gt;std::conjunction&amp;lt;B1, ..., BN&amp;gt;&lt;/code&gt; has a public and unambiguous base that is.</source>
          <target state="translated">Специализация &lt;code&gt;std::conjunction&amp;lt;B1, ..., BN&amp;gt;&lt;/code&gt; имеет открытую и однозначную базу.</target>
        </trans-unit>
        <trans-unit id="3d5cf9884b92e823e93ea4f01a9bf287d1156634" translate="yes" xml:space="preserve">
          <source>The specialization &lt;code&gt;std::disjunction&amp;lt;B1, ..., BN&amp;gt;&lt;/code&gt; has a public and unambiguous base that is.</source>
          <target state="translated">Специализация &lt;code&gt;std::disjunction&amp;lt;B1, ..., BN&amp;gt;&lt;/code&gt; имеет открытую и однозначную базу.</target>
        </trans-unit>
        <trans-unit id="186f2d291b8a6a9a42e951016f0b61a5ce492295" translate="yes" xml:space="preserve">
          <source>The specialization &lt;code&gt;std::hash&amp;lt;optional&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; is enabled (see &lt;code&gt;&lt;a href=&quot;../hash&quot;&gt;std::hash&lt;/a&gt;&lt;/code&gt;) if &lt;code&gt;std::hash&amp;lt;std::remove_const_t&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; is enabled, and is disabled otherwise.</source>
          <target state="translated">Специализация &lt;code&gt;std::hash&amp;lt;optional&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; включена (см. &lt;code&gt;&lt;a href=&quot;../hash&quot;&gt;std::hash&lt;/a&gt;&lt;/code&gt; ), если включена &lt;code&gt;std::hash&amp;lt;std::remove_const_t&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; , и отключена в противном случае.</target>
        </trans-unit>
        <trans-unit id="600411d4c48669f0d407c466842e7104a0cdd005" translate="yes" xml:space="preserve">
          <source>The specialization &lt;code&gt;std::hash&amp;lt;std::unique_ptr&amp;lt;T,D&amp;gt;&amp;gt;&lt;/code&gt; is enabled (see &lt;code&gt;&lt;a href=&quot;../../utility/hash&quot;&gt;std::hash&lt;/a&gt;&lt;/code&gt;) if &lt;code&gt;std::hash&amp;lt;typename std::unique_ptr&amp;lt;T,D&amp;gt;::pointer&amp;gt;&lt;/code&gt; is enabled, and is disabled otherwise.</source>
          <target state="translated">Специализация &lt;code&gt;std::hash&amp;lt;std::unique_ptr&amp;lt;T,D&amp;gt;&amp;gt;&lt;/code&gt; включена (см. &lt;code&gt;&lt;a href=&quot;../../utility/hash&quot;&gt;std::hash&lt;/a&gt;&lt;/code&gt; ), если включено &lt;code&gt;std::hash&amp;lt;typename std::unique_ptr&amp;lt;T,D&amp;gt;::pointer&amp;gt;&lt;/code&gt; , и иначе отключено.</target>
        </trans-unit>
        <trans-unit id="42f1297302612956b663a74e0024532e227a782e" translate="yes" xml:space="preserve">
          <source>The specialization &lt;code&gt;std::hash&amp;lt;std::variant&amp;lt;Types...&amp;gt;&amp;gt;&lt;/code&gt; is enabled (see &lt;code&gt;&lt;a href=&quot;../hash&quot;&gt;std::hash&lt;/a&gt;&lt;/code&gt;) if every specialization in &lt;code&gt;std::hash&amp;lt;std::remove_const_t&amp;lt;Types&amp;gt;&amp;gt;...&lt;/code&gt; is enabled, and is disabled otherwise.</source>
          <target state="translated">Специализация &lt;code&gt;std::hash&amp;lt;std::variant&amp;lt;Types...&amp;gt;&amp;gt;&lt;/code&gt; включена (см. &lt;code&gt;&lt;a href=&quot;../hash&quot;&gt;std::hash&lt;/a&gt;&lt;/code&gt; ), если каждая специализация в &lt;code&gt;std::hash&amp;lt;std::remove_const_t&amp;lt;Types&amp;gt;&amp;gt;...&lt;/code&gt; включена, и отключен в противном случае.</target>
        </trans-unit>
        <trans-unit id="2c76460cbd0b8d4d937dbc5c694d6c7635ce71fd" translate="yes" xml:space="preserve">
          <source>The specializations &lt;code&gt;std::complex&amp;lt;float&amp;gt;&lt;/code&gt;, &lt;code&gt;std::complex&amp;lt;double&amp;gt;&lt;/code&gt;, and &lt;code&gt;std::complex&amp;lt;long double&amp;gt;&lt;/code&gt; are &lt;a href=&quot;../named_req/literaltype&quot;&gt;LiteralTypes&lt;/a&gt; for representing and manipulating &lt;a href=&quot;https://en.wikipedia.org/wiki/Complex_number&quot;&gt;complex numbers&lt;/a&gt;.</source>
          <target state="translated">Специализации &lt;code&gt;std::complex&amp;lt;float&amp;gt;&lt;/code&gt; , &lt;code&gt;std::complex&amp;lt;double&amp;gt;&lt;/code&gt; и &lt;code&gt;std::complex&amp;lt;long double&amp;gt;&lt;/code&gt; являются &lt;a href=&quot;../named_req/literaltype&quot;&gt;литеральными типами&lt;/a&gt; для представления и управления &lt;a href=&quot;https://en.wikipedia.org/wiki/Complex_number&quot;&gt;комплексными числами&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="86590d0709c4e9c53d7a3642895c8ee4ba57e923" translate="yes" xml:space="preserve">
          <source>The specification of release-consume ordering is being revised, and the use of &lt;code&gt;memory_order_consume&lt;/code&gt; is temporarily discouraged.</source>
          <target state="translated">Спецификация порядка выпуска-потребления пересматривается, и использование &lt;code&gt;memory_order_consume&lt;/code&gt; временно не рекомендуется.</target>
        </trans-unit>
        <trans-unit id="29817af7f9fc3c9588fba123d6e7dc6efdcdd019" translate="yes" xml:space="preserve">
          <source>The specified non-type arguments must either match the types of the corresponding non-type template parameters, or be &lt;a href=&quot;template_parameters#Template_non-type_arguments&quot;&gt;convertible to them&lt;/a&gt;.</source>
          <target state="translated">Указанные не типовые аргументы должны либо соответствовать типам соответствующих нетиповых параметров шаблона, либо быть &lt;a href=&quot;template_parameters#Template_non-type_arguments&quot;&gt;преобразованными в них&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5cd71ab6119537a05f604ee514973d18be587dd3" translate="yes" xml:space="preserve">
          <source>The specified template arguments must match the template parameters in kind (i.e., type for type, non-type for non-type, and template for template). There cannot be more arguments than there are parameters (unless one parameter is a parameter pack, in which case there has to be an argument for each non-pack parameter).</source>
          <target state="translated">Указанные аргументы шаблона должны соответствовать параметрам шаблона по типу (т.е.тип для типа,не тип для не-типа и шаблон для шаблона).Не может быть больше аргументов,чем их количество (если только один параметр не является пакетом параметров,в этом случае для каждого параметра,не входящего в пакет,должен быть аргумент).</target>
        </trans-unit>
        <trans-unit id="f0a5a1232f69709176b03e5e2f09bcf1138b3d55" translate="yes" xml:space="preserve">
          <source>The standard 32-bit IEEE 754 floating-point type has a 24 bit fractional part (23 bits written, one implied), which may suggest that it can represent 7 digit decimals (&lt;code&gt;24 * &lt;a href=&quot;../../numeric/math/log10&quot;&gt;std::log10&lt;/a&gt;(2)&lt;/code&gt; is 7.22), but relative rounding errors are non-uniform and some floating-point values with 7 decimal digits do not survive conversion to 32-bit float and back: the smallest positive example is &lt;code&gt;8.589973e9&lt;/code&gt;, which becomes &lt;code&gt;8.589974e9&lt;/code&gt; after the roundtrip. These rounding errors cannot exceed one bit in the representation, and &lt;code&gt;digits10&lt;/code&gt; is calculated as &lt;code&gt;(24-1)*&lt;a href=&quot;../../numeric/math/log10&quot;&gt;std::log10&lt;/a&gt;(2)&lt;/code&gt;, which is 6.92. Rounding down results in the value 6.</source>
          <target state="translated">Стандартный 32-битный тип IEEE 754 с плавающей запятой имеет 24-битную дробную часть (записано 23 бита, подразумевается один), что может указывать на то, что он может представлять 7-значные десятичные дроби ( &lt;code&gt;24 * &lt;a href=&quot;../../numeric/math/log10&quot;&gt;std::log10&lt;/a&gt;(2)&lt;/code&gt; равно 7.22), но относительные ошибки округления неоднородны, и некоторые значения с плавающей запятой с 7 десятичными цифрами не сохраняются при преобразовании в 32-разрядные числа с плавающей запятой и обратно: наименьший положительный пример - &lt;code&gt;8.589973e9&lt;/code&gt; , который становится &lt;code&gt;8.589974e9&lt;/code&gt; после обхода . Эти ошибки округления не могут превышать один бит в представлении, и &lt;code&gt;digits10&lt;/code&gt; рассчитываются как &lt;code&gt;(24-1)*&lt;a href=&quot;../../numeric/math/log10&quot;&gt;std::log10&lt;/a&gt;(2)&lt;/code&gt; , что составляет 6,92. Округление приводит к значению 6.</target>
        </trans-unit>
        <trans-unit id="73e09cdf1b741ad1b3350d5372e33ae3558bb73f" translate="yes" xml:space="preserve">
          <source>The standard C streams are the following: &lt;code&gt;&lt;a href=&quot;../c&quot;&gt;stdin&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../c&quot;&gt;stdout&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../c&quot;&gt;stderr&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Стандартные потоки C следующие: &lt;code&gt;&lt;a href=&quot;../c&quot;&gt;stdin&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../c&quot;&gt;stdout&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;../c&quot;&gt;stderr&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0bc3d7739fd70319e077ff236f69aa7397545b58" translate="yes" xml:space="preserve">
          <source>The standard C++ streams are the following: &lt;code&gt;&lt;a href=&quot;../cin&quot;&gt;std::cin&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../cout&quot;&gt;std::cout&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../cerr&quot;&gt;std::cerr&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../clog&quot;&gt;std::clog&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../cin&quot;&gt;std::wcin&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../cout&quot;&gt;std::wcout&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../cerr&quot;&gt;std::wcerr&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../clog&quot;&gt;std::wclog&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Стандартные потоки C ++: &lt;code&gt;&lt;a href=&quot;../cin&quot;&gt;std::cin&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../cout&quot;&gt;std::cout&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../cerr&quot;&gt;std::cerr&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../clog&quot;&gt;std::clog&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../cin&quot;&gt;std::wcin&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../cout&quot;&gt;std::wcout&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../cerr&quot;&gt;std::wcerr&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;../clog&quot;&gt;std::wclog&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e1559238f4f96f1308a43f7cac736eb900505d58" translate="yes" xml:space="preserve">
          <source>The standard containers &lt;code&gt;&lt;a href=&quot;deque&quot;&gt;std::deque&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;list&quot;&gt;std::list&lt;/a&gt;&lt;/code&gt; satisfy these requirements.</source>
          <target state="translated">Стандартные контейнеры &lt;code&gt;&lt;a href=&quot;deque&quot;&gt;std::deque&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;list&quot;&gt;std::list&lt;/a&gt;&lt;/code&gt; удовлетворяют этим требованиям.</target>
        </trans-unit>
        <trans-unit id="9b92ff236d7217d097c5d77ce3d7b6e24187e96b" translate="yes" xml:space="preserve">
          <source>The standard containers &lt;code&gt;&lt;a href=&quot;vector&quot;&gt;std::vector&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;deque&quot;&gt;std::deque&lt;/a&gt;&lt;/code&gt; satisfy these requirements.</source>
          <target state="translated">Стандартные контейнеры &lt;code&gt;&lt;a href=&quot;vector&quot;&gt;std::vector&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;deque&quot;&gt;std::deque&lt;/a&gt;&lt;/code&gt; удовлетворяют этим требованиям.</target>
        </trans-unit>
        <trans-unit id="3348805983e91545ed6f0183b3ad7d17819a000e" translate="yes" xml:space="preserve">
          <source>The standard containers &lt;code&gt;&lt;a href=&quot;vector&quot;&gt;std::vector&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;deque&quot;&gt;std::deque&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;list&quot;&gt;std::list&lt;/a&gt;&lt;/code&gt; satisfy these requirements. By default, if no container class is specified for a particular stack class instantiation, the standard container &lt;code&gt;&lt;a href=&quot;deque&quot;&gt;std::deque&lt;/a&gt;&lt;/code&gt; is used.</source>
          <target state="translated">Стандартные контейнеры &lt;code&gt;&lt;a href=&quot;vector&quot;&gt;std::vector&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;deque&quot;&gt;std::deque&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;list&quot;&gt;std::list&lt;/a&gt;&lt;/code&gt; удовлетворяют этим требованиям. По умолчанию, если класс контейнера не указан для конкретного экземпляра класса стека, используется стандартный контейнер &lt;code&gt;&lt;a href=&quot;deque&quot;&gt;std::deque&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="da4c870ff1fa0a006bae378b114850461217f6df" translate="yes" xml:space="preserve">
          <source>The standard defines a set of &lt;a href=&quot;preprocessor/replace&quot;&gt;preprocessor macros&lt;/a&gt; corresponding to C++ language and library features introduced in C++11 or later. They are intended as a simple and portable way to detect the presence of said features.</source>
          <target state="translated">Стандарт определяет набор &lt;a href=&quot;preprocessor/replace&quot;&gt;макросов препроцессора,&lt;/a&gt; соответствующих языку C ++ и функциям библиотеки, представленным в C ++ 11 или более поздних версиях. Они предназначены в качестве простого и портативного способа обнаружения наличия указанных функций.</target>
        </trans-unit>
        <trans-unit id="7a975074992a026641c667980782c267b65820dd" translate="yes" xml:space="preserve">
          <source>The standard does not define any behavior for this function except that &lt;code&gt;setbuf(0, 0)&lt;/code&gt; called before any I/O has taken place is required to set unbuffered output.</source>
          <target state="translated">Стандарт не определяет никакого поведения для этой функции, за исключением того, что &lt;code&gt;setbuf(0, 0)&lt;/code&gt; вызываемый до того, как произойдет какой-либо ввод-вывод, требуется для установки небуферизованного вывода.</target>
        </trans-unit>
        <trans-unit id="11c9f11d649487cf00471f2a0a3ced302b1b169d" translate="yes" xml:space="preserve">
          <source>The standard encourages, but doesn't require that the main thread and the threads started by &lt;code&gt;&lt;a href=&quot;../thread/thread&quot;&gt;std::thread&lt;/a&gt;&lt;/code&gt; offer concurrent forward progress guarantee.</source>
          <target state="translated">Стандарт поощряет, но не требует, чтобы основной поток и потоки, запущенные &lt;code&gt;&lt;a href=&quot;../thread/thread&quot;&gt;std::thread&lt;/a&gt;&lt;/code&gt; предлагали параллельную гарантию прямого продвижения.</target>
        </trans-unit>
        <trans-unit id="3769b4f39ad7629c09afe04cb807040c01f86974" translate="yes" xml:space="preserve">
          <source>The standard error condition &lt;code&gt;&lt;a href=&quot;../errc&quot;&gt;std::errc::result_out_of_range&lt;/a&gt;&lt;/code&gt; typically indicates the condition where the result, rather than the input, is out of range, and is more closely related to &lt;code&gt;&lt;a href=&quot;../range_error/range_error&quot;&gt;std::range_error&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../errno_macros&quot;&gt;ERANGE&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Стандартное условие ошибки &lt;code&gt;&lt;a href=&quot;../errc&quot;&gt;std::errc::result_out_of_range&lt;/a&gt;&lt;/code&gt; обычно указывает условие, когда результат, а не входные данные, находится вне диапазона и более тесно связан с &lt;code&gt;&lt;a href=&quot;../range_error/range_error&quot;&gt;std::range_error&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;../errno_macros&quot;&gt;ERANGE&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6ea76ab6562da741fc1f1f80fa940f195cc6f7f0" translate="yes" xml:space="preserve">
          <source>The standard itself doesn't specify precedence levels. They are derived from the grammar.</source>
          <target state="translated">В самом стандарте не указаны уровни старшинства.Они выведены из грамматики.</target>
        </trans-unit>
        <trans-unit id="464d44c8fa9af2bc062b88f7cb6e09d51921375c" translate="yes" xml:space="preserve">
          <source>The standard library</source>
          <target state="translated">Стандартная библиотека</target>
        </trans-unit>
        <trans-unit id="501d2fd270600c1ad4722fe615b8c6d60795a8cf" translate="yes" xml:space="preserve">
          <source>The standard library also defines a function template &lt;a href=&quot;../../algorithm/remove&quot;&gt;&lt;code&gt;std::remove&lt;/code&gt;&lt;/a&gt; taking a pair of iterators and a value, this overload is one of the standard &lt;a href=&quot;../../algorithm&quot;&gt;algorithms&lt;/a&gt;.</source>
          <target state="translated">Стандартная библиотека также определяет шаблон функции &lt;a href=&quot;../../algorithm/remove&quot;&gt; &lt;code&gt;std::remove&lt;/code&gt; &lt;/a&gt; принимающий пару итераторов и значение, эта перегрузка является одним из стандартных &lt;a href=&quot;../../algorithm&quot;&gt;алгоритмов&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6f9befce5f0ccf765011ba595f540e481507757b" translate="yes" xml:space="preserve">
          <source>The standard library also defines an overload of &lt;code&gt;std::remove&lt;/code&gt; taking &lt;code&gt;const char*&lt;/code&gt;, used to delete files: &lt;a href=&quot;../io/c/remove&quot;&gt;&lt;code&gt;std::remove&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Стандартная библиотека также определяет перегрузку &lt;code&gt;std::remove&lt;/code&gt; с использованием &lt;code&gt;const char*&lt;/code&gt; , используемого для удаления файлов: &lt;a href=&quot;../io/c/remove&quot;&gt; &lt;code&gt;std::remove&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0eb84bf9201f6099169c60c1dc16401b24988119" translate="yes" xml:space="preserve">
          <source>The standard library also provides a number of pre-defined &lt;a href=&quot;../utility/functional&quot;&gt;function object templates&lt;/a&gt; as well as the methods to compose new ones (including &lt;code&gt;&lt;a href=&quot;../utility/functional/mem_fn&quot;&gt;std::mem_fn&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../utility/functional/bind&quot;&gt;std::bind&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;../utility/functional/function&quot;&gt;std::function&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">Стандартная библиотека также предоставляет несколько предопределенных &lt;a href=&quot;../utility/functional&quot;&gt;шаблонов объектов функций,&lt;/a&gt; а также методы для создания новых (включая &lt;code&gt;&lt;a href=&quot;../utility/functional/mem_fn&quot;&gt;std::mem_fn&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../utility/functional/bind&quot;&gt;std::bind&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;../utility/functional/function&quot;&gt;std::function&lt;/a&gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="b555b9bc9fd6124abd76d1e9d57fcd86813932ea" translate="yes" xml:space="preserve">
          <source>The standard library component &lt;code&gt;&lt;a href=&quot;../types/enable_if&quot;&gt;std::enable_if&lt;/a&gt;&lt;/code&gt; allows for creating a substitution failure in order to enable or disable particular overloads based on a condition evaluated at compile time.</source>
          <target state="translated">Стандартный компонент библиотеки &lt;code&gt;&lt;a href=&quot;../types/enable_if&quot;&gt;std::enable_if&lt;/a&gt;&lt;/code&gt; позволяет создать ошибку замещения, чтобы включить или отключить определенные перегрузки на основе условия, оцененного во время компиляции.</target>
        </trans-unit>
        <trans-unit id="4fdaf88b78e9440c1d7c4b829cd2c20de63b3687" translate="yes" xml:space="preserve">
          <source>The standard library component &lt;code&gt;&lt;a href=&quot;../types/void_t&quot;&gt;std::void_t&lt;/a&gt;&lt;/code&gt; is another utility metafunction that simplifies SFINAE applications.</source>
          <target state="translated">Стандартный компонент библиотеки &lt;code&gt;&lt;a href=&quot;../types/void_t&quot;&gt;std::void_t&lt;/a&gt;&lt;/code&gt; - это еще одна метафункция утилиты, которая упрощает приложения SFINAE.</target>
        </trans-unit>
        <trans-unit id="90d7e9c58cdd097e6e1be1842b8c59bbecc70529" translate="yes" xml:space="preserve">
          <source>The standard library components do not throw this exception (mathematical functions report domain errors as specified in &lt;code&gt;&lt;a href=&quot;../../numeric/math/math_errhandling&quot;&gt;math_errhandling&lt;/a&gt;&lt;/code&gt;). Third-party libraries, however, use this. For example, &lt;a href=&quot;http://www.boost.org/doc/libs/1_55_0/libs/math/doc/html/math_toolkit/error_handling.html&quot;&gt;boost.math&lt;/a&gt; throws &lt;code&gt;std::domain_error&lt;/code&gt; if &lt;code&gt;boost::math::policies::throw_on_error&lt;/code&gt; is enabled (the default setting).</source>
          <target state="translated">Компоненты стандартной библиотеки не выдают это исключение (математические функции сообщают об ошибках домена, как указано в &lt;code&gt;&lt;a href=&quot;../../numeric/math/math_errhandling&quot;&gt;math_errhandling&lt;/a&gt;&lt;/code&gt; ). Сторонние библиотеки, однако, используют это. Например, &lt;a href=&quot;http://www.boost.org/doc/libs/1_55_0/libs/math/doc/html/math_toolkit/error_handling.html&quot;&gt;boost.math&lt;/a&gt; выбрасывает &lt;code&gt;std::domain_error&lt;/code&gt; если включен &lt;code&gt;boost::math::policies::throw_on_error&lt;/code&gt; (настройка по умолчанию).</target>
        </trans-unit>
        <trans-unit id="4dffee91fae753bda05b684cabb9727f41e1ecf3" translate="yes" xml:space="preserve">
          <source>The standard library components do not throw this exception (mathematical functions report domain errors as specified in &lt;code&gt;&lt;a href=&quot;../../numeric/math/math_errhandling&quot;&gt;math_errhandling&lt;/a&gt;&lt;/code&gt;). Third-party libraries, however, use this. For example, &lt;a href=&quot;https://www.boost.org/doc/libs/1_55_0/libs/math/doc/html/math_toolkit/error_handling.html&quot;&gt;boost.math&lt;/a&gt; throws &lt;code&gt;std::domain_error&lt;/code&gt; if &lt;code&gt;boost::math::policies::throw_on_error&lt;/code&gt; is enabled (the default setting).</source>
          <target state="translated">Компоненты стандартной библиотеки не генерируют это исключение (математические функции сообщают об ошибках домена, как указано в &lt;code&gt;&lt;a href=&quot;../../numeric/math/math_errhandling&quot;&gt;math_errhandling&lt;/a&gt;&lt;/code&gt; ). Однако сторонние библиотеки используют это. Например, &lt;a href=&quot;https://www.boost.org/doc/libs/1_55_0/libs/math/doc/html/math_toolkit/error_handling.html&quot;&gt;boost.math&lt;/a&gt; выбрасывает &lt;code&gt;std::domain_error&lt;/code&gt; если включен &lt;code&gt;boost::math::policies::throw_on_error&lt;/code&gt; (настройка по умолчанию).</target>
        </trans-unit>
        <trans-unit id="46dcc8a3d08bda1ff1e95e9b8404ca3dc28f1aeb" translate="yes" xml:space="preserve">
          <source>The standard library components do not throw this exception (mathematical functions report underflow errors as specified in &lt;code&gt;&lt;a href=&quot;../../numeric/math/math_errhandling&quot;&gt;math_errhandling&lt;/a&gt;&lt;/code&gt;). Third-party libraries, however, use this. For example, &lt;a href=&quot;http://www.boost.org/doc/libs/1_66_0/libs/math/doc/html/math_toolkit/error_handling.html&quot;&gt;boost.math&lt;/a&gt; throws &lt;code&gt;std::underflow_error&lt;/code&gt; if &lt;code&gt;boost::math::policies::throw_on_error&lt;/code&gt; is enabled (the default setting).</source>
          <target state="translated">Компоненты стандартной библиотеки не выдают это исключение (математические функции сообщают об ошибках &lt;code&gt;&lt;a href=&quot;../../numeric/math/math_errhandling&quot;&gt;math_errhandling&lt;/a&gt;&lt;/code&gt; как указано в math_errhandling ). Сторонние библиотеки, однако, используют это. Например, &lt;a href=&quot;http://www.boost.org/doc/libs/1_66_0/libs/math/doc/html/math_toolkit/error_handling.html&quot;&gt;boost.math&lt;/a&gt; бросает &lt;code&gt;std::underflow_error&lt;/code&gt; , если &lt;code&gt;boost::math::policies::throw_on_error&lt;/code&gt; включена (настройка по умолчанию).</target>
        </trans-unit>
        <trans-unit id="5163045812559a0cfa0dfff651b770d63211f5c3" translate="yes" xml:space="preserve">
          <source>The standard library components do not throw this exception (mathematical functions report underflow errors as specified in &lt;code&gt;&lt;a href=&quot;../../numeric/math/math_errhandling&quot;&gt;math_errhandling&lt;/a&gt;&lt;/code&gt;). Third-party libraries, however, use this. For example, &lt;a href=&quot;https://www.boost.org/doc/libs/1_66_0/libs/math/doc/html/math_toolkit/error_handling.html&quot;&gt;boost.math&lt;/a&gt; throws &lt;code&gt;std::underflow_error&lt;/code&gt; if &lt;code&gt;boost::math::policies::throw_on_error&lt;/code&gt; is enabled (the default setting).</source>
          <target state="translated">Компоненты стандартной библиотеки не генерируют это исключение (математические функции сообщают об ошибках недополнения, как указано в &lt;code&gt;&lt;a href=&quot;../../numeric/math/math_errhandling&quot;&gt;math_errhandling&lt;/a&gt;&lt;/code&gt; ). Однако сторонние библиотеки используют это. Например, &lt;a href=&quot;https://www.boost.org/doc/libs/1_66_0/libs/math/doc/html/math_toolkit/error_handling.html&quot;&gt;boost.math&lt;/a&gt; выдает &lt;code&gt;std::underflow_error&lt;/code&gt; underflow_error, если включен &lt;code&gt;boost::math::policies::throw_on_error&lt;/code&gt; (настройка по умолчанию).</target>
        </trans-unit>
        <trans-unit id="45b5eeaea89ac1fd73a4e45ba45af272f555ab4a" translate="yes" xml:space="preserve">
          <source>The standard library defines two trivial awaitables: &lt;code&gt;std::suspend_always&lt;/code&gt; and &lt;code&gt;std::suspend_never&lt;/code&gt;.</source>
          <target state="translated">Стандартная библиотека определяет две тривиальные функции: &lt;code&gt;std::suspend_always&lt;/code&gt; и &lt;code&gt;std::suspend_never&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="131ce88470ae44f681ca4c49d07e5f0002f442b1" translate="yes" xml:space="preserve">
          <source>The standard library implementations of the nothrow versions (5-8) directly calls the corresponding throwing versions (1-4). The standard library implementation of the throwing array versions (2,4) directly calls the corresponding single-object version (1,3). Thus, replacing the throwing single object allocation functions is sufficient to handle all allocations.</source>
          <target state="translated">Стандартные реализации библиотек nothrow версий (5-8)напрямую вызывают соответствующие бросающие версии (1-4).В стандартной библиотечной реализации версий метательных массивов (2,4)непосредственно вызывается соответствующая однообъектная версия (1,3).Таким образом,для обработки всех распределений достаточно замены бросающих функций распределения одиночных объектов.</target>
        </trans-unit>
        <trans-unit id="987bfd8dffed15aac50d7b564b0338f3cfc187ca" translate="yes" xml:space="preserve">
          <source>The standard library implementations of the nothrow versions (9,10) directly call the corresponding throwing versions (1,2). The standard library implementations of the size-aware deallocation functions (5-8) directly call the corresponding size-unaware deallocation functions (1-4). The standard library implementations of size-unaware throwing array forms (2,4) directly calls the corresponding single-object forms (1,3).</source>
          <target state="translated">Стандартные реализации библиотек nothrow версий (9,10)напрямую вызывают соответствующие бросающие версии (1,2).Стандартные реализации реализаций библиотек размерно-развлекательных функций (5-8)напрямую вызывают соответствующие размерно-развлекательные функции (1-4).Стандартные библиотечные реализации размернонезависимых бросающих массивов (2,4)напрямую вызывают соответствующие однообъектные формы (1,3).</target>
        </trans-unit>
        <trans-unit id="6f67e8db943a7e5f11fa3e591652be01e6c72c81" translate="yes" xml:space="preserve">
          <source>The standard library placement forms of operator delete (13,14) cannot be replaced and can only be customized if the placement new-expression did not use the &lt;code&gt;::new&lt;/code&gt; syntax, by providing a class-specific placement delete (25,26) with matching signature: &lt;code&gt;void T::operator delete(void*, void*)&lt;/code&gt; or &lt;code&gt;void T::operator delete[](void*, void*)&lt;/code&gt;.</source>
          <target state="translated">Стандартные формы размещения библиотеки оператора delete (13,14) не могут быть заменены и могут быть настроены только в том случае, если в новом выражении размещения не использовался синтаксис &lt;code&gt;::new&lt;/code&gt; , предоставляя удаление для конкретного класса (25,26) с помощью соответствующая подпись: &lt;code&gt;void T::operator delete(void*, void*)&lt;/code&gt; или &lt;code&gt;void T::operator delete[](void*, void*)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7f331f596fff7bf452e9368230c890e4ad858b73" translate="yes" xml:space="preserve">
          <source>The standard library provides a specialization of &lt;code&gt;std::bit_and&lt;/code&gt; when &lt;code&gt;T&lt;/code&gt; is not specified, which leaves the parameter types and return type to be deduced.</source>
          <target state="translated">Стандартная библиотека обеспечивает специализацию &lt;code&gt;std::bit_and&lt;/code&gt; когда &lt;code&gt;T&lt;/code&gt; не указан, что оставляет типы параметров и возвращаемый тип для вывода.</target>
        </trans-unit>
        <trans-unit id="51b8639942df5edd3c966b0d456710b62ece3289" translate="yes" xml:space="preserve">
          <source>The standard library provides a specialization of &lt;code&gt;std::bit_not&lt;/code&gt; when &lt;code&gt;T&lt;/code&gt; is not specified, which leaves the parameter types and return type to be deduced.</source>
          <target state="translated">Стандартная библиотека обеспечивает специализацию &lt;code&gt;std::bit_not&lt;/code&gt; когда &lt;code&gt;T&lt;/code&gt; не указан, что оставляет типы параметров и возвращаемый тип для вывода.</target>
        </trans-unit>
        <trans-unit id="3f85f5fb8d6b87c4f54a098871a34860fd38598a" translate="yes" xml:space="preserve">
          <source>The standard library provides a specialization of &lt;code&gt;std::bit_or&lt;/code&gt; when &lt;code&gt;T&lt;/code&gt; is not specified, which leaves the parameter types and return type to be deduced.</source>
          <target state="translated">Стандартная библиотека обеспечивает специализацию &lt;code&gt;std::bit_or&lt;/code&gt; когда &lt;code&gt;T&lt;/code&gt; не указан, что оставляет типы параметров и возвращаемый тип для вывода.</target>
        </trans-unit>
        <trans-unit id="0cf5638980a6e182479f5dbc4a0b88370ff66486" translate="yes" xml:space="preserve">
          <source>The standard library provides a specialization of &lt;code&gt;std::bit_xor&lt;/code&gt; when &lt;code&gt;T&lt;/code&gt; is not specified, which leaves the parameter types and return type to be deduced.</source>
          <target state="translated">Стандартная библиотека обеспечивает специализацию &lt;code&gt;std::bit_xor&lt;/code&gt; когда &lt;code&gt;T&lt;/code&gt; не указан, что оставляет типы параметров и возвращаемый тип для вывода.</target>
        </trans-unit>
        <trans-unit id="b457595199deea57bcd493866c929556b33e76c3" translate="yes" xml:space="preserve">
          <source>The standard library provides a specialization of &lt;code&gt;std::divides&lt;/code&gt; when &lt;code&gt;T&lt;/code&gt; is not specified, which leaves the parameter types and return type to be deduced.</source>
          <target state="translated">Стандартная библиотека обеспечивает специализацию &lt;code&gt;std::divides&lt;/code&gt; когда &lt;code&gt;T&lt;/code&gt; не указан, что оставляет типы параметров и возвращаемый тип для вывода.</target>
        </trans-unit>
        <trans-unit id="424b00c8e42201af9548ab0448e6ee7a2e60cfef" translate="yes" xml:space="preserve">
          <source>The standard library provides a specialization of &lt;code&gt;std::equal_to&lt;/code&gt; when &lt;code&gt;T&lt;/code&gt; is not specified, which leaves the parameter types and return type to be deduced.</source>
          <target state="translated">Стандартная библиотека обеспечивает специализацию &lt;code&gt;std::equal_to&lt;/code&gt; когда &lt;code&gt;T&lt;/code&gt; не указан, что оставляет типы параметров и возвращаемый тип для вывода.</target>
        </trans-unit>
        <trans-unit id="445dfbf3571b7bf4a2bdaa8ee7d29b4668dc155f" translate="yes" xml:space="preserve">
          <source>The standard library provides a specialization of &lt;code&gt;std::greater&lt;/code&gt; when &lt;code&gt;T&lt;/code&gt; is not specified, which leaves the parameter types and return type to be deduced.</source>
          <target state="translated">Стандартная библиотека обеспечивает специализацию &lt;code&gt;std::greater&lt;/code&gt; когда &lt;code&gt;T&lt;/code&gt; не указан, что оставляет типы параметров и возвращаемый тип для вывода.</target>
        </trans-unit>
        <trans-unit id="2e57796087a77aba47733fc29c950505cf26b1be" translate="yes" xml:space="preserve">
          <source>The standard library provides a specialization of &lt;code&gt;std::greater_equal&lt;/code&gt; when &lt;code&gt;T&lt;/code&gt; is not specified, which leaves the parameter types and return type to be deduced.</source>
          <target state="translated">Стандартная библиотека обеспечивает специализацию &lt;code&gt;std::greater_equal&lt;/code&gt; когда &lt;code&gt;T&lt;/code&gt; не указан, что оставляет типы параметров и возвращаемый тип для вывода.</target>
        </trans-unit>
        <trans-unit id="d03ee57547fa44cc25d3f2cc6819498bf61e5b4f" translate="yes" xml:space="preserve">
          <source>The standard library provides a specialization of &lt;code&gt;std::less&lt;/code&gt; when &lt;code&gt;T&lt;/code&gt; is not specified, which leaves the parameter types and return type to be deduced.</source>
          <target state="translated">Стандартная библиотека обеспечивает специализацию &lt;code&gt;std::less&lt;/code&gt; когда &lt;code&gt;T&lt;/code&gt; не указан, что оставляет типы параметров и возвращаемый тип для вывода.</target>
        </trans-unit>
        <trans-unit id="1df3c94ad21dfdfe9d3b7d094b740848f19b97b6" translate="yes" xml:space="preserve">
          <source>The standard library provides a specialization of &lt;code&gt;std::less_equal&lt;/code&gt; when &lt;code&gt;T&lt;/code&gt; is not specified, which leaves the parameter types and return type to be deduced.</source>
          <target state="translated">Стандартная библиотека обеспечивает специализацию &lt;code&gt;std::less_equal&lt;/code&gt; когда &lt;code&gt;T&lt;/code&gt; не указан, что оставляет типы параметров и возвращаемый тип для вывода.</target>
        </trans-unit>
        <trans-unit id="c43777e85f59e5d1bbafcf4b62e738707fc73cc8" translate="yes" xml:space="preserve">
          <source>The standard library provides a specialization of &lt;code&gt;std::logical_and&lt;/code&gt; when &lt;code&gt;T&lt;/code&gt; is not specified, which leaves the parameter types and return type to be deduced.</source>
          <target state="translated">Стандартная библиотека обеспечивает специализацию &lt;code&gt;std::logical_and&lt;/code&gt; когда &lt;code&gt;T&lt;/code&gt; не указан, что оставляет типы параметров и возвращаемый тип для вывода.</target>
        </trans-unit>
        <trans-unit id="22cce0c9b0e471c051bc216994974900fed662a5" translate="yes" xml:space="preserve">
          <source>The standard library provides a specialization of &lt;code&gt;std::logical_not&lt;/code&gt; when &lt;code&gt;T&lt;/code&gt; is not specified, which leaves the parameter types and return type to be deduced.</source>
          <target state="translated">Стандартная библиотека обеспечивает специализацию &lt;code&gt;std::logical_not&lt;/code&gt; когда &lt;code&gt;T&lt;/code&gt; не указан, что оставляет типы параметров и возвращаемый тип для вывода.</target>
        </trans-unit>
        <trans-unit id="b18a6f7d7f176eaa205b868246f5b1e0eaa0fbbe" translate="yes" xml:space="preserve">
          <source>The standard library provides a specialization of &lt;code&gt;std::logical_or&lt;/code&gt; when &lt;code&gt;T&lt;/code&gt; is not specified, which leaves the parameter types and return type to be deduced.</source>
          <target state="translated">Стандартная библиотека обеспечивает специализацию &lt;code&gt;std::logical_or&lt;/code&gt; когда &lt;code&gt;T&lt;/code&gt; не указан, что оставляет типы параметров и возвращаемый тип для вывода.</target>
        </trans-unit>
        <trans-unit id="4a1acb46cad97b294ab7069cf7f2c49e0f7cf8b1" translate="yes" xml:space="preserve">
          <source>The standard library provides a specialization of &lt;code&gt;std::minus&lt;/code&gt; when &lt;code&gt;T&lt;/code&gt; is not specified, which leaves the parameter types and return type to be deduced.</source>
          <target state="translated">Стандартная библиотека обеспечивает специализацию &lt;code&gt;std::minus&lt;/code&gt; когда &lt;code&gt;T&lt;/code&gt; не указан, что оставляет типы параметров и возвращаемый тип для вывода.</target>
        </trans-unit>
        <trans-unit id="6416b0b039efddd187d08d4923fac1b5ea6b2919" translate="yes" xml:space="preserve">
          <source>The standard library provides a specialization of &lt;code&gt;std::modulus&lt;/code&gt; when &lt;code&gt;T&lt;/code&gt; is not specified, which leaves the parameter types and return type to be deduced.</source>
          <target state="translated">Стандартная библиотека обеспечивает специализацию &lt;code&gt;std::modulus&lt;/code&gt; когда &lt;code&gt;T&lt;/code&gt; не указан, что оставляет типы параметров и возвращаемый тип для вывода.</target>
        </trans-unit>
        <trans-unit id="9e894075f88d07cc0fe2281d2c4c9b7877d9b39c" translate="yes" xml:space="preserve">
          <source>The standard library provides a specialization of &lt;code&gt;std::multiplies&lt;/code&gt; when &lt;code&gt;T&lt;/code&gt; is not specified, which leaves the parameter types and return type to be deduced.</source>
          <target state="translated">Стандартная библиотека обеспечивает специализацию &lt;code&gt;std::multiplies&lt;/code&gt; когда &lt;code&gt;T&lt;/code&gt; не указан, что оставляет типы параметров и возвращаемый тип для вывода.</target>
        </trans-unit>
        <trans-unit id="f5aca230aea77b0bd8892a57f74c1c692d9e92c8" translate="yes" xml:space="preserve">
          <source>The standard library provides a specialization of &lt;code&gt;std::negate&lt;/code&gt; when &lt;code&gt;T&lt;/code&gt; is not specified, which leaves the parameter types and return type to be deduced.</source>
          <target state="translated">Стандартная библиотека обеспечивает специализацию &lt;code&gt;std::negate&lt;/code&gt; когда &lt;code&gt;T&lt;/code&gt; не указан, что оставляет типы параметров и возвращаемый тип для вывода.</target>
        </trans-unit>
        <trans-unit id="3a6ba7f3f95659a4fcbc1e1535d8d51d3f4d4522" translate="yes" xml:space="preserve">
          <source>The standard library provides a specialization of &lt;code&gt;std::not_equal_to&lt;/code&gt; when &lt;code&gt;T&lt;/code&gt; is not specified, which leaves the parameter types and return type to be deduced.</source>
          <target state="translated">Стандартная библиотека обеспечивает специализацию &lt;code&gt;std::not_equal_to&lt;/code&gt; когда &lt;code&gt;T&lt;/code&gt; не указан, что оставляет типы параметров и возвращаемый тип для вывода.</target>
        </trans-unit>
        <trans-unit id="b5b5790ca4e3a36f7013249f817e8e9a00cbb0f8" translate="yes" xml:space="preserve">
          <source>The standard library provides a specialization of &lt;code&gt;std::owner_less&lt;/code&gt; when &lt;code&gt;T&lt;/code&gt; is not specified. In this case, the parameter types are deduced from the arguments (each of which must still be either a &lt;code&gt;&lt;a href=&quot;shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&lt;/code&gt; or a &lt;code&gt;&lt;a href=&quot;weak_ptr&quot;&gt;std::weak_ptr&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">Стандартная библиотека обеспечивает специализацию &lt;code&gt;std::owner_less&lt;/code&gt; когда &lt;code&gt;T&lt;/code&gt; не указан. В этом случае типы параметров выводятся из аргументов (каждый из которых по-прежнему должен быть либо &lt;code&gt;&lt;a href=&quot;shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&lt;/code&gt; либо &lt;code&gt;&lt;a href=&quot;weak_ptr&quot;&gt;std::weak_ptr&lt;/a&gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="120610675bef9d2af7c4846670094bb75886286b" translate="yes" xml:space="preserve">
          <source>The standard library provides a specialization of &lt;code&gt;std::plus&lt;/code&gt; when &lt;code&gt;T&lt;/code&gt; is not specified, which leaves the parameter types and return type to be deduced.</source>
          <target state="translated">Стандартная библиотека обеспечивает специализацию &lt;code&gt;std::plus&lt;/code&gt; когда &lt;code&gt;T&lt;/code&gt; не указан, что оставляет типы параметров и возвращаемый тип для вывода.</target>
        </trans-unit>
        <trans-unit id="e47ae8777ca4465b596890ef95a90b212d5b7e1a" translate="yes" xml:space="preserve">
          <source>The standard library provides a specialization of &lt;code&gt;std::vector&lt;/code&gt; for the type &lt;code&gt;bool&lt;/code&gt;, which may be optimized for space efficiency.</source>
          <target state="translated">Стандартная библиотека обеспечивает специализацию &lt;code&gt;std::vector&lt;/code&gt; для типа &lt;code&gt;bool&lt;/code&gt; , которая может быть оптимизирована для экономии пространства.</target>
        </trans-unit>
        <trans-unit id="0fefa50e2fa7d26d5c3b1a75d91a4ce66ae1e5fa" translate="yes" xml:space="preserve">
          <source>The standard library provides facilities to obtain values that are returned and to catch exceptions that are thrown by asynchronous tasks (i.e. functions launched in separate threads). These values are communicated in a</source>
          <target state="translated">Стандартная библиотека предоставляет средства для получения возвращаемых значений и перехвата исключений,бросаемых асинхронными задачами (т.е.функциями,запускаемыми в отдельных потоках).Эти значения передаются в</target>
        </trans-unit>
        <trans-unit id="093ef8202a6c5dfcd0f104f718c58b45c3a78863" translate="yes" xml:space="preserve">
          <source>The standard library provides partial specializations of the &lt;code&gt;std::atomic&lt;/code&gt; template for the following types with additional properties that the primary template does not have:</source>
          <target state="translated">Стандартная библиотека предоставляет частичные специализации шаблона &lt;code&gt;std::atomic&lt;/code&gt; для следующих типов с дополнительными свойствами, которых у основного шаблона нет:</target>
        </trans-unit>
        <trans-unit id="228f6a886c12bbc3f7a888fe93cf312d114dba7e" translate="yes" xml:space="preserve">
          <source>The standard library provides partial specializations of the &lt;code&gt;std::atomic_ref&lt;/code&gt; template for for all pointer types. In addition to the operations provided for all atomic types, these specializations additionally support atomic arithmetic operations appropriate to pointer types, such as &lt;a href=&quot;atomic_ref/fetch_add&quot;&gt;&lt;code&gt;fetch_add&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;atomic_ref/fetch_sub&quot;&gt;&lt;code&gt;fetch_sub&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Стандартная библиотека обеспечивает частичные специализации шаблона &lt;code&gt;std::atomic_ref&lt;/code&gt; для всех типов указателей. В дополнение к операциям, предусмотренным для всех атомарных типов, эти специализации дополнительно поддерживают атомарные арифметические операции, соответствующие типам указателей, таким как &lt;a href=&quot;atomic_ref/fetch_add&quot;&gt; &lt;code&gt;fetch_add&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;atomic_ref/fetch_sub&quot;&gt; &lt;code&gt;fetch_sub&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ad36dcf418bbed48c178ac3a02f2b5e9c8c7da73" translate="yes" xml:space="preserve">
          <source>The standard library provides the following searchers:</source>
          <target state="translated">Стандартная библиотека предоставляет следующие возможности поиска:</target>
        </trans-unit>
        <trans-unit id="3b2efd68490dfb7a4918757f6cf2c4bb0801f472" translate="yes" xml:space="preserve">
          <source>The standard library types that are aliases of arithmetic types (such as &lt;code&gt;&lt;a href=&quot;size_t&quot;&gt;std::size_t&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../io/streamsize&quot;&gt;std::streamsize&lt;/a&gt;&lt;/code&gt;) may also be examined with the &lt;code&gt;std::numeric_limits&lt;/code&gt; type traits.</source>
          <target state="translated">Типы стандартных библиотек, которые являются псевдонимами арифметических типов (например, &lt;code&gt;&lt;a href=&quot;size_t&quot;&gt;std::size_t&lt;/a&gt;&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;../io/streamsize&quot;&gt;std::streamsize&lt;/a&gt;&lt;/code&gt; ), также могут быть проверены с помощью признаков типа &lt;code&gt;std::numeric_limits&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ffd7a9f649b4d9408cc4e3d1e7589d2c8b29d694" translate="yes" xml:space="preserve">
          <source>The standard library's non-allocating placement forms of operator new (9-10) cannot be replaced and can only be customized if the placement new-expression did not use the &lt;code&gt;::new&lt;/code&gt; syntax, by providing a class-specific placement new (19,20) with matching signature: &lt;code&gt;void* T::operator new(size_t, void*)&lt;/code&gt; or &lt;code&gt;void* T::operator new[](size_t, void*)&lt;/code&gt;.</source>
          <target state="translated">Нераспределительные формы размещения стандартной команды оператора new (9-10) не могут быть заменены и могут быть изменены только в том случае, если выражение new-размещения не использовало синтаксис &lt;code&gt;::new&lt;/code&gt; , предоставляя специфичное для класса размещение new (19, 20) с соответствующей подписью: &lt;code&gt;void* T::operator new(size_t, void*)&lt;/code&gt; или &lt;code&gt;void* T::operator new[](size_t, void*)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4981b4624e460e124e89bf34f4ff3f0393f76006" translate="yes" xml:space="preserve">
          <source>The standard output objects &lt;code&gt;&lt;a href=&quot;../cerr&quot;&gt;std::cerr&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../cerr&quot;&gt;std::wcerr&lt;/a&gt;&lt;/code&gt; have their &lt;code&gt;unitbuf&lt;/code&gt; bit set by default.</source>
          <target state="translated">Стандартные выходные объекты &lt;code&gt;&lt;a href=&quot;../cerr&quot;&gt;std::cerr&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;../cerr&quot;&gt;std::wcerr&lt;/a&gt;&lt;/code&gt; имеют свой бит &lt;code&gt;unitbuf&lt;/code&gt; , установленный по умолчанию.</target>
        </trans-unit>
        <trans-unit id="9e153cc38ba0d2871317e848fbb767c71742cdb1" translate="yes" xml:space="preserve">
          <source>The standard recommends that a &lt;a href=&quot;../../chrono/steady_clock&quot;&gt;&lt;code&gt;steady_clock&lt;/code&gt;&lt;/a&gt; is used to measure the duration. If an implementation uses a &lt;a href=&quot;../../chrono/system_clock&quot;&gt;&lt;code&gt;system_clock&lt;/code&gt;&lt;/a&gt; instead, the wait time may also be sensitive to clock adjustments.</source>
          <target state="translated">Стандарт рекомендует использовать &lt;a href=&quot;../../chrono/steady_clock&quot;&gt; &lt;code&gt;steady_clock&lt;/code&gt; &lt;/a&gt; для измерения продолжительности. Если в реализации вместо этого используется &lt;a href=&quot;../../chrono/system_clock&quot;&gt; &lt;code&gt;system_clock&lt;/code&gt; &lt;/a&gt; , время ожидания также может зависеть от настроек часов.</target>
        </trans-unit>
        <trans-unit id="4670d79858faa026fd927ad092884ff7288c02f9" translate="yes" xml:space="preserve">
          <source>The standard recommends that a steady clock is used to measure the duration. If an implementation uses a system clock instead, the wait time may also be sensitive to clock adjustments.</source>
          <target state="translated">Стандарт рекомендует использовать стабильные часы для измерения продолжительности.Если в реализации вместо них используются системные часы,время ожидания также может быть чувствительным к настройке часов.</target>
        </trans-unit>
        <trans-unit id="3e741a6a70c81c69a623d13af6d5fd11444c21c7" translate="yes" xml:space="preserve">
          <source>The standard signed integer types: &lt;code&gt;signed char&lt;/code&gt;, &lt;code&gt;short&lt;/code&gt;, &lt;code&gt;int&lt;/code&gt;, &lt;code&gt;long&lt;/code&gt;, and &lt;code&gt;long long&lt;/code&gt;;</source>
          <target state="translated">Стандартные целочисленные типы со знаком: &lt;code&gt;signed char&lt;/code&gt; , &lt;code&gt;short&lt;/code&gt; , &lt;code&gt;int&lt;/code&gt; , &lt;code&gt;long&lt;/code&gt; и &lt;code&gt;long long&lt;/code&gt; ;</target>
        </trans-unit>
        <trans-unit id="f7faa7d4edc03214148f1c3967ed705a6e4cf33e" translate="yes" xml:space="preserve">
          <source>The standard specializations of &lt;code&gt;&lt;a href=&quot;../moneypunct&quot;&gt;std::moneypunct&lt;/a&gt;&lt;/code&gt; return the pattern &lt;code&gt;{symbol, sign, none, value}&lt;/code&gt;</source>
          <target state="translated">Стандартные специализации &lt;code&gt;&lt;a href=&quot;../moneypunct&quot;&gt;std::moneypunct&lt;/a&gt;&lt;/code&gt; возвращают шаблон &lt;code&gt;{symbol, sign, none, value}&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="297a7545b93be6b8ae2bf103d5942d598d8acf23" translate="yes" xml:space="preserve">
          <source>The standard unsigned integer types: &lt;code&gt;unsigned char&lt;/code&gt;, &lt;code&gt;unsigned short&lt;/code&gt;, &lt;code&gt;unsigned int&lt;/code&gt;, &lt;code&gt;unsigned long&lt;/code&gt;, and &lt;code&gt;unsigned long long&lt;/code&gt;;</source>
          <target state="translated">Стандартные целочисленные типы &lt;code&gt;unsigned char&lt;/code&gt; : unsigned char , &lt;code&gt;unsigned short&lt;/code&gt; , &lt;code&gt;unsigned int&lt;/code&gt; , &lt;code&gt;unsigned long&lt;/code&gt; и &lt;code&gt;unsigned long long&lt;/code&gt; ;</target>
        </trans-unit>
        <trans-unit id="b3faee826fe7d429ac217f2296c04e167f193a78" translate="yes" xml:space="preserve">
          <source>The start of the get area, for all writeable &lt;code&gt;std::strstreambuf&lt;/code&gt; objects constructed through the interface provided by &lt;code&gt;&lt;a href=&quot;../strstream&quot;&gt;std::strstream&lt;/a&gt;&lt;/code&gt;, is also the start of the put area.</source>
          <target state="translated">Начало области get для всех &lt;code&gt;std::strstreambuf&lt;/code&gt; объектов std :: strstreambuf, созданных через интерфейс, предоставленный &lt;code&gt;&lt;a href=&quot;../strstream&quot;&gt;std::strstream&lt;/a&gt;&lt;/code&gt; , также является началом области put.</target>
        </trans-unit>
        <trans-unit id="29e1675652ac7f6393431e47f0ec2642d6a47e2b" translate="yes" xml:space="preserve">
          <source>The starting directory has depth of 0, its subdirectories have depth 1, etc.</source>
          <target state="translated">Начальный каталог имеет глубину 0,его подкаталоги имеют глубину 1 и т.д.</target>
        </trans-unit>
        <trans-unit id="9c4774217cf581390531d456216df78cfba88d58" translate="yes" xml:space="preserve">
          <source>The state of &lt;code&gt;A&lt;/code&gt; includes the state of &lt;code&gt;B&lt;/code&gt;</source>
          <target state="translated">Состояние &lt;code&gt;A&lt;/code&gt; включает состояние &lt;code&gt;B&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="bf3c2fc8c65fee8f63cb40617161a425c9833d2a" translate="yes" xml:space="preserve">
          <source>The statement that begins with &lt;code&gt;if constexpr&lt;/code&gt; is known as the</source>
          <target state="translated">Утверждение, начинающееся с того, &lt;code&gt;if constexpr&lt;/code&gt; известен как</target>
        </trans-unit>
        <trans-unit id="8d7a45218be20de00c71ea80e61b6068a9ec7bbd" translate="yes" xml:space="preserve">
          <source>The static data members &lt;code&gt;nom&lt;/code&gt; and &lt;code&gt;den&lt;/code&gt; representing the numerator and denominator are calculated by dividing &lt;code&gt;Num&lt;/code&gt; and &lt;code&gt;Denom&lt;/code&gt; by their greatest common divisor. However, two &lt;code&gt;std::ratio&lt;/code&gt; with different &lt;code&gt;Num&lt;/code&gt; or &lt;code&gt;Denom&lt;/code&gt; are distinct types even if they represent the same rational number (after reduction). A &lt;code&gt;ratio&lt;/code&gt; type can be reduced to the lowest terms via its &lt;code&gt;type&lt;/code&gt; member: &lt;code&gt;std::ratio&amp;lt;3, 6&amp;gt;::type&lt;/code&gt; is &lt;code&gt;std::ratio&amp;lt;1, 2&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">Статические члены данных &lt;code&gt;nom&lt;/code&gt; и &lt;code&gt;den&lt;/code&gt; , представляющие числитель и знаменатель, рассчитываются путем деления &lt;code&gt;Num&lt;/code&gt; и &lt;code&gt;Denom&lt;/code&gt; на их наибольший общий делитель. Однако два типа &lt;code&gt;std::ratio&lt;/code&gt; с разными &lt;code&gt;Num&lt;/code&gt; или &lt;code&gt;Denom&lt;/code&gt; являются разными типами, даже если они представляют одно и то же рациональное число (после сокращения). Тип &lt;code&gt;ratio&lt;/code&gt; может быть уменьшен до самых низких членов с помощью его члена &lt;code&gt;type&lt;/code&gt; : &lt;code&gt;std::ratio&amp;lt;3, 6&amp;gt;::type&lt;/code&gt; is &lt;code&gt;std::ratio&amp;lt;1, 2&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d0f731b0d49e9b2f3318f0fcd7bbe6ca8c907339" translate="yes" xml:space="preserve">
          <source>The status of the file referred to by the entry.</source>
          <target state="translated">Статус файла,на который ссылается запись.</target>
        </trans-unit>
        <trans-unit id="6e3ebc55efb178a42fb9d7d48d59cf130b8a23d3" translate="yes" xml:space="preserve">
          <source>The status of the pending recursion flag can be queried with &lt;a href=&quot;recursion_pending&quot;&gt;&lt;code&gt;recursion_pending()&lt;/code&gt;&lt;/a&gt;, which is &lt;code&gt;false&lt;/code&gt; after this call. It is reset back to &lt;code&gt;true&lt;/code&gt; after &lt;a href=&quot;increment&quot;&gt;&lt;code&gt;increment&lt;/code&gt;&lt;/a&gt;, and its initial value is also &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">Состояние флага ожидающей рекурсии может быть запрошено с помощью &lt;a href=&quot;recursion_pending&quot;&gt; &lt;code&gt;recursion_pending()&lt;/code&gt; &lt;/a&gt; , которая имеет значение &lt;code&gt;false&lt;/code&gt; после этого вызова. После &lt;a href=&quot;increment&quot;&gt; &lt;code&gt;increment&lt;/code&gt; &lt;/a&gt; оно сбрасывается обратно в &lt;code&gt;true&lt;/code&gt; , и его начальное значение также равно &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0cb43bc5c74e77ae80142a18f784fbac3e0c33b7" translate="yes" xml:space="preserve">
          <source>The stem of the filename identified by the path (i.e. the filename without the final extension).</source>
          <target state="translated">Стержень имени файла,идентифицируемая путем (т.е.имя файла без конечного расширения).</target>
        </trans-unit>
        <trans-unit id="11590b2e7256668527e3216f99ac4fd9c7a4d00b" translate="yes" xml:space="preserve">
          <source>The storage class specifiers are a part of the decl-specifier-seq of a name's &lt;a href=&quot;declarations&quot;&gt;declaration syntax&lt;/a&gt;. Together with the &lt;a href=&quot;scope&quot;&gt;scope&lt;/a&gt; of the name, they control two independent properties of the name: its</source>
          <target state="translated">Спецификаторы класса хранения являются частью decl-specier-seq &lt;a href=&quot;declarations&quot;&gt;синтаксиса объявления имени&lt;/a&gt; . Вместе с &lt;a href=&quot;scope&quot;&gt;областью&lt;/a&gt; имени они управляют двумя независимыми свойствами имени: его</target>
        </trans-unit>
        <trans-unit id="2f39d087c3a629b33b3a42976145e493b6fa58f5" translate="yes" xml:space="preserve">
          <source>The storage of a deque is automatically expanded and contracted as needed. Expansion of a deque is cheaper than the expansion of a &lt;code&gt;&lt;a href=&quot;vector&quot;&gt;std::vector&lt;/a&gt;&lt;/code&gt; because it does not involve copying of the existing elements to a new memory location. On the other hand, deques typically have large minimal memory cost; a deque holding just one element has to allocate its full internal array (e.g. 8 times the object size on 64-bit libstdc++; 16 times the object size or 4096 bytes, whichever is larger, on 64-bit libc++).</source>
          <target state="translated">Хранение deque автоматически расширяется и сокращается по мере необходимости. Расширение deque дешевле, чем расширение &lt;code&gt;&lt;a href=&quot;vector&quot;&gt;std::vector&lt;/a&gt;&lt;/code&gt; потому что оно не включает копирование существующих элементов в новую ячейку памяти. С другой стороны, запросы обычно имеют большую минимальную стоимость памяти; deque, содержащий только один элемент, должен выделить свой полный внутренний массив (например, 8-кратный размер объекта на 64-битной libstdc ++; 16-кратный размер объекта или 4096 байт, в зависимости от того, что больше, на 64-битной libc ++).</target>
        </trans-unit>
        <trans-unit id="b072292a5a1e2322c8e92bfdf268810f5282c203" translate="yes" xml:space="preserve">
          <source>The storage of the vector is handled automatically, being expanded and contracted as needed. Vectors usually occupy more space than static arrays, because more memory is allocated to handle future growth. This way a vector does not need to reallocate each time an element is inserted, but only when the additional memory is exhausted. The total amount of allocated memory can be queried using &lt;code&gt;&lt;a href=&quot;vector/capacity&quot;&gt;capacity()&lt;/a&gt;&lt;/code&gt; function.  Extra memory can be returned to the system via a call to &lt;code&gt;&lt;a href=&quot;vector/shrink_to_fit&quot;&gt;shrink_to_fit()&lt;/a&gt;&lt;/code&gt;.(since C++11).</source>
          <target state="translated">Хранение вектора обрабатывается автоматически, расширяется и сокращается по мере необходимости. Векторы обычно занимают больше места, чем статические массивы, потому что больше памяти выделяется для обработки будущего роста. Таким образом, вектору не нужно перераспределять каждый раз при вставке элемента, а только тогда, когда дополнительная память исчерпана. Общий объем выделенной памяти может быть запрошен с помощью функции Capacity &lt;code&gt;&lt;a href=&quot;vector/capacity&quot;&gt;capacity()&lt;/a&gt;&lt;/code&gt; . Дополнительная память может быть возвращена в систему через вызов &lt;code&gt;&lt;a href=&quot;vector/shrink_to_fit&quot;&gt;shrink_to_fit()&lt;/a&gt;&lt;/code&gt; . ( Начиная с C ++ 11).</target>
        </trans-unit>
        <trans-unit id="5892901fc4af7c4daeffcdff331dcbef5c156bb6" translate="yes" xml:space="preserve">
          <source>The stored callable object is called the</source>
          <target state="translated">Хранимый вызываемый объект называется</target>
        </trans-unit>
        <trans-unit id="80952d2ca5513e2ab7bc4e81a28581ccd51f605f" translate="yes" xml:space="preserve">
          <source>The stored deleter object.</source>
          <target state="translated">Сохраненный объект удаления.</target>
        </trans-unit>
        <trans-unit id="17b16ef531268271e85ec6f43ec173d4f90c59ff" translate="yes" xml:space="preserve">
          <source>The stored duration.</source>
          <target state="translated">Сохраненная продолжительность.</target>
        </trans-unit>
        <trans-unit id="09a69b97d4bafa467ed76343a615b25a40c0cb70" translate="yes" xml:space="preserve">
          <source>The stored error category.</source>
          <target state="translated">Сохраненная категория ошибки.</target>
        </trans-unit>
        <trans-unit id="2281cefb9cf8d901883c448695a82804629a024b" translate="yes" xml:space="preserve">
          <source>The stored error code.</source>
          <target state="translated">Сохраненный код ошибки.</target>
        </trans-unit>
        <trans-unit id="8af42892a4e54ba3e506e55de93429bf0536f70e" translate="yes" xml:space="preserve">
          <source>The stored pointer.</source>
          <target state="translated">Сохраненный указатель.</target>
        </trans-unit>
        <trans-unit id="433b5f42f978f29dcfd09128154cee8fea3f71e9" translate="yes" xml:space="preserve">
          <source>The stored reference.</source>
          <target state="translated">Сохраненная ссылка.</target>
        </trans-unit>
        <trans-unit id="6c6f751d334cb9f8c0297588312a1852b3d27541" translate="yes" xml:space="preserve">
          <source>The stored task has already been invoked. The error category is set to &lt;a href=&quot;../future_errc&quot;&gt;&lt;code&gt;promise_already_satisfied&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Хранимая задача уже была вызвана. Категория ошибки установлена ​​в &lt;a href=&quot;../future_errc&quot;&gt; &lt;code&gt;promise_already_satisfied&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4df572d2c0e354b7f394388b3d124d21e95f48d8" translate="yes" xml:space="preserve">
          <source>The stored task has already been invoked. The error category is set to &lt;code&gt;promise_already_satisfied&lt;/code&gt;.</source>
          <target state="translated">Хранимая задача уже была вызвана. Категория ошибки установлена ​​в &lt;code&gt;promise_already_satisfied&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="657cc28deb3f80f24e72e3ed2e272bb85d039858" translate="yes" xml:space="preserve">
          <source>The stream-based I/O library uses &lt;a href=&quot;io/manip&quot;&gt; I/O manipulators&lt;/a&gt; (e.g. &lt;code&gt;&lt;a href=&quot;io/manip/boolalpha&quot;&gt;std::boolalpha&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;io/manip/hex&quot;&gt;std::hex&lt;/a&gt;&lt;/code&gt;, etc.) to control how streams behave.</source>
          <target state="translated">В потоковой библиотеке ввода / вывода используются &lt;a href=&quot;io/manip&quot;&gt;манипуляторы ввода / вывода&lt;/a&gt; (например, &lt;code&gt;&lt;a href=&quot;io/manip/boolalpha&quot;&gt;std::boolalpha&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;io/manip/hex&quot;&gt;std::hex&lt;/a&gt;&lt;/code&gt; и т. Д.) Для управления поведением потоков.</target>
        </trans-unit>
        <trans-unit id="f1f8e1bf31666f17d818c7fb3629dbe63dce8038" translate="yes" xml:space="preserve">
          <source>The stream-based input/output library is organized around abstract input/output devices. These abstract devices allow the same code to handle input/output to files, memory streams, or custom adaptor devices that perform arbitrary operations (e.g. compression) on the fly.</source>
          <target state="translated">Потоковая библиотека ввода/вывода организована вокруг абстрактных устройств ввода/вывода.Эти абстрактные устройства ввода/вывода позволяют одному и тому же коду обрабатывать входы/выходы в файлы,потоки памяти или пользовательские адаптеры,которые выполняют произвольные операции (например,сжатие)&quot;на лету&quot;.</target>
        </trans-unit>
        <trans-unit id="685e0728588ef7b354ca6ae06a3e39b651660d7d" translate="yes" xml:space="preserve">
          <source>The streambuf overload of &lt;a href=&quot;../basic_istream/operator_gtgt&quot;&gt;&lt;code&gt;basic_istream::operator&amp;gt;&amp;gt;&lt;/code&gt;&lt;/a&gt; if the streambuf argument is a null pointer or if no characters were inserted into the streambuf.</source>
          <target state="translated">Перегрузка streambuf для &lt;a href=&quot;../basic_istream/operator_gtgt&quot;&gt; &lt;code&gt;basic_istream::operator&amp;gt;&amp;gt;&lt;/code&gt; &lt;/a&gt; если аргумент streambuf является нулевым указателем или если в streambuf не было вставлено ни одного символа.</target>
        </trans-unit>
        <trans-unit id="2d18ba3c4f605fc8501feb5b3351b46aa1577fcc" translate="yes" xml:space="preserve">
          <source>The streambuf overload of &lt;a href=&quot;../basic_ostream/operator_ltlt&quot;&gt;&lt;code&gt;basic_ostream::operator&amp;lt;&amp;lt;&lt;/code&gt;&lt;/a&gt; if the function inserts no characters.</source>
          <target state="translated">Перегрузка streambuf для &lt;a href=&quot;../basic_ostream/operator_ltlt&quot;&gt; &lt;code&gt;basic_ostream::operator&amp;lt;&amp;lt;&lt;/code&gt; &lt;/a&gt; если функция не вставляет символы.</target>
        </trans-unit>
        <trans-unit id="1ef23ffa702914245f81e5026dac9d4ebc2e587a" translate="yes" xml:space="preserve">
          <source>The string converted to the specified floating point type.</source>
          <target state="translated">Строка,приведенная к указанному типу с плавающей точкой.</target>
        </trans-unit>
        <trans-unit id="47c093236b31b3a204fe8f923fb21ca46aefe47b" translate="yes" xml:space="preserve">
          <source>The string converted to the specified signed integer type.</source>
          <target state="translated">Строка,приведенная к указанному знаковому целочисленному типу.</target>
        </trans-unit>
        <trans-unit id="ce8f7eeb006b0c3d2b2b94eccb0b5ba0bb13623e" translate="yes" xml:space="preserve">
          <source>The string converted to the specified unsigned integer type.</source>
          <target state="translated">Строка,приведенная к указанному беззнаковому целочисленному типу.</target>
        </trans-unit>
        <trans-unit id="90cd8c741b9656548cd7c47ccb8f4e7b236d4d51" translate="yes" xml:space="preserve">
          <source>The string input function &lt;code&gt;&lt;a href=&quot;../../string/basic_string/getline&quot;&gt;std::getline&lt;/a&gt;&lt;/code&gt; if it completes by reaching the end of the stream, as opposed to reaching the specified terminating character.</source>
          <target state="translated">Функция ввода строки &lt;code&gt;&lt;a href=&quot;../../string/basic_string/getline&quot;&gt;std::getline&lt;/a&gt;&lt;/code&gt; если она завершается достижением конца потока, а не достижением указанного завершающего символа.</target>
        </trans-unit>
        <trans-unit id="fe144c3255daec881252d2a4f155b9abf0e72d73" translate="yes" xml:space="preserve">
          <source>The string library also provides class template &lt;code&gt;&lt;a href=&quot;string/char_traits&quot;&gt;std::char_traits&lt;/a&gt;&lt;/code&gt; that defines types and functions for &lt;code&gt;&lt;a href=&quot;string/basic_string&quot;&gt;std::basic_string&lt;/a&gt;&lt;/code&gt;and &lt;code&gt;&lt;a href=&quot;string/basic_string_view&quot;&gt;std::basic_string_view&lt;/a&gt;&lt;/code&gt;(since C++17). The following specializations are defined:</source>
          <target state="translated">Библиотека строк также предоставляет шаблон класса &lt;code&gt;&lt;a href=&quot;string/char_traits&quot;&gt;std::char_traits&lt;/a&gt;&lt;/code&gt; который определяет типы и функции для &lt;code&gt;&lt;a href=&quot;string/basic_string&quot;&gt;std::basic_string&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;string/basic_string_view&quot;&gt;std::basic_string_view&lt;/a&gt;&lt;/code&gt; (начиная с C ++ 17). Определены следующие специализации:</target>
        </trans-unit>
        <trans-unit id="7a1c4ed4b5630d5ddaa1db0afbceba65c0447876" translate="yes" xml:space="preserve">
          <source>The string literal.</source>
          <target state="translated">Строковый букварь.</target>
        </trans-unit>
        <trans-unit id="fe351b72d36bc72e8b0524c53861ac272e34795a" translate="yes" xml:space="preserve">
          <source>The string of type &lt;code&gt;string_type&lt;/code&gt; holding the characters to be used as positive or negative sign.</source>
          <target state="translated">Строка типа &lt;code&gt;string_type&lt;/code&gt; , содержащая символы, которые будут использоваться в качестве положительного или отрицательного знака.</target>
        </trans-unit>
        <trans-unit id="645bada75f5704a14a70ee6b3ad9c4dbbc4a0cd1" translate="yes" xml:space="preserve">
          <source>The string transformed so that lexicographic comparison of the transformed strings may be used instead of collating of the originals. In the &quot;C&quot; locale, the returned string is the exact copy of &lt;code&gt;[low, high)&lt;/code&gt;. In other locales, the contents of the returned string are implementation-defined, and the size may be considerably longer.</source>
          <target state="translated">Строка преобразована таким образом, что вместо сопоставления оригиналов можно использовать лексикографическое сравнение преобразованных строк. В локали &quot;C&quot; возвращаемая строка является точной копией &lt;code&gt;[low, high)&lt;/code&gt; . В других локалях содержимое возвращаемой строки определяется реализацией, и размер может быть значительно длиннее.</target>
        </trans-unit>
        <trans-unit id="bed8f4fdf0727af913eee7d7f8de3facf8e379a9" translate="yes" xml:space="preserve">
          <source>The string_literal is typically a short program written in assembly language, which is executed whenever this declaration is executed. Different C++ compilers have wildly varying rules for asm-declarations, and different conventions for the interaction with the surrounding C++ code.</source>
          <target state="translated">Строковый_литерал-это,как правило,короткая программа,написанная на ассемблерном языке,которая выполняется всякий раз,когда выполняется это объявление.Различные компиляторы Си++имеют сильно различающиеся правила для asm-деклараций,а также различные конвенции для взаимодействия с окружающим Си++кодом.</target>
        </trans-unit>
        <trans-unit id="f3fd3bc3bb5bbc2174bee8f5c8d22f3d7dbcda9d" translate="yes" xml:space="preserve">
          <source>The string_view literal.</source>
          <target state="translated">Строковый литерал.</target>
        </trans-unit>
        <trans-unit id="9ed1cae434c8ab95486c8c0f6cf75e8ebd7662a2" translate="yes" xml:space="preserve">
          <source>The struct combines the performance and accessibility of a C-style array with the benefits of a standard container, such as knowing its own size, supporting assignment, random access iterators, etc.</source>
          <target state="translated">Структура сочетает в себе производительность и доступность массива в стиле C с преимуществами стандартного контейнера,такими как знание собственного размера,поддерживаемые назначения,итераторы случайного доступа и т.д.</target>
        </trans-unit>
        <trans-unit id="771b48d395936f4ddd7641ad97ebda6634abdf95" translate="yes" xml:space="preserve">
          <source>The subscript operator expressions have the form.</source>
          <target state="translated">Выражения операторов подписки имеют форму.</target>
        </trans-unit>
        <trans-unit id="1ee3ffed03585e5f9ff776a096eb8348d437e9c7" translate="yes" xml:space="preserve">
          <source>The substitution of template arguments into a requires-expression used in a declaration of a &lt;a href=&quot;templates#Templated_entity&quot;&gt;templated entity&lt;/a&gt; may result in the formation of invalid types or expressions in its requirements, or the violation of semantic constraints of those requirements. In such cases, the requires-expression evaluates to &lt;code&gt;false&lt;/code&gt; and does not cause the program to be ill-formed. The substitution and semantic constraint checking proceeds in lexical order and stops when a condition that determines the result of the requires-expression is encountered. If substitution (if any) and semantic constraint checking succeed, the requires-expression evaluates to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">Подстановка аргументов шаблона в выражение require, используемое в объявлении &lt;a href=&quot;templates#Templated_entity&quot;&gt;шаблонного объекта,&lt;/a&gt; может привести к образованию недопустимых типов или выражений в его требованиях или нарушению семантических ограничений этих требований. В таких случаях выражение require оценивается как &lt;code&gt;false&lt;/code&gt; и не приводит к некорректной работе программы. Проверка подстановки и семантического ограничения продолжается в лексическом порядке и останавливается, когда встречается условие, которое определяет результат выражения require. Если подстановка (если есть) и проверка семантических ограничений завершаются успешно, выражение require-expression оценивается как &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2246f7cf19b24f35ba44d7128f9f00cdf8cea437" translate="yes" xml:space="preserve">
          <source>The sum of the elements.</source>
          <target state="translated">Сумма элементов.</target>
        </trans-unit>
        <trans-unit id="89d93f088c99aca77c5be8b564b1d94b144b5b67" translate="yes" xml:space="preserve">
          <source>The sum of the returned value and the value stored in &lt;code&gt;*iptr&lt;/code&gt; gives &lt;code&gt;x&lt;/code&gt; (allowing for rounding).</source>
          <target state="translated">Сумма возвращенного значения и значения, хранящегося в &lt;code&gt;*iptr&lt;/code&gt; , дает &lt;code&gt;x&lt;/code&gt; (с учетом округления).</target>
        </trans-unit>
        <trans-unit id="ff4ca6cf4d2e109c127290c18455fd2a7491a92c" translate="yes" xml:space="preserve">
          <source>The supplied lock &lt;code&gt;lk&lt;/code&gt; is held until the thread exits. Once this function has been called, no more threads may acquire the same lock in order to wait on &lt;code&gt;cond&lt;/code&gt;. If some thread is waiting on this condition variable, it should not attempt to release and reacquire the lock when it wakes up spuriously.</source>
          <target state="translated">Поставляемая блокировка &lt;code&gt;lk&lt;/code&gt; удерживается до тех пор, пока нить не выйдет. Как только эта функция была вызвана, никакие потоки не могут получить такую ​​же блокировку для ожидания на &lt;code&gt;cond&lt;/code&gt; . Если какой-то поток ожидает этой условной переменной, он не должен пытаться освободить и повторно получить блокировку, когда он внезапно просыпается.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
