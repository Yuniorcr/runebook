<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="cpp">
    <body>
      <group id="cpp">
        <trans-unit id="419ec8df85caf452084df24b9de678dedfbc50bf" translate="yes" xml:space="preserve">
          <source>-&lt;code&gt;Key&lt;/code&gt; must meet the requirements of &lt;a href=&quot;../../named_req/equalitycomparable&quot;&gt;EqualityComparable&lt;/a&gt; in order to use overloads (1-2).</source>
          <target state="translated">- &lt;code&gt;Key&lt;/code&gt; должен соответствовать требованиям &lt;a href=&quot;../../named_req/equalitycomparable&quot;&gt;EqualityComparable&lt;/a&gt; , чтобы использовать перегрузки (1-2).</target>
        </trans-unit>
        <trans-unit id="a4e09b6b6e2a7b3a2ac2a06b04359abecdd52cc3" translate="yes" xml:space="preserve">
          <source>-&lt;code&gt;Key&lt;/code&gt; must meet the requirements of &lt;a href=&quot;../../named_req/lessthancomparable&quot;&gt;LessThanComparable&lt;/a&gt; in order to use overloads (3-6). The ordering relation must establish total order.</source>
          <target state="translated">- &lt;code&gt;Key&lt;/code&gt; должен соответствовать требованиям &lt;a href=&quot;../../named_req/lessthancomparable&quot;&gt;LessThanComparable&lt;/a&gt; , чтобы использовать перегрузки (3-6). Отношение заказа должно устанавливать общий порядок.</target>
        </trans-unit>
        <trans-unit id="b9361c83e3b358d5a3956e330cbd7371301b7ad7" translate="yes" xml:space="preserve">
          <source>-&lt;code&gt;OutputIt1, OutputIt2&lt;/code&gt; must meet the requirements of &lt;a href=&quot;../named_req/outputiterator&quot;&gt;LegacyOutputIterator&lt;/a&gt;.</source>
          <target state="translated">- &lt;code&gt;OutputIt1, OutputIt2&lt;/code&gt; должен соответствовать требованиям &lt;a href=&quot;../named_req/outputiterator&quot;&gt;LegacyOutputIterator&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="698247f9c442eed3999e5a308ab1fc6756e36992" translate="yes" xml:space="preserve">
          <source>-&lt;code&gt;OutputIt&lt;/code&gt; must meet the requirements of &lt;a href=&quot;../../../named_req/outputiterator&quot;&gt;LegacyOutputIterator&lt;/a&gt;.</source>
          <target state="translated">- &lt;code&gt;OutputIt&lt;/code&gt; должен соответствовать требованиям &lt;a href=&quot;../../../named_req/outputiterator&quot;&gt;LegacyOutputIterator&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="55c36864300a0332162362f1e29021f2ab4046bf" translate="yes" xml:space="preserve">
          <source>-&lt;code&gt;OutputIt&lt;/code&gt; must meet the requirements of &lt;a href=&quot;../../named_req/outputiterator&quot;&gt;LegacyOutputIterator&lt;/a&gt;.</source>
          <target state="translated">- &lt;code&gt;OutputIt&lt;/code&gt; должен соответствовать требованиям &lt;a href=&quot;../../named_req/outputiterator&quot;&gt;LegacyOutputIterator&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="deed4a8e960de7cf907cc39e9c0acfd7ac778bf6" translate="yes" xml:space="preserve">
          <source>-&lt;code&gt;OutputIt&lt;/code&gt; must meet the requirements of &lt;a href=&quot;../named_req/outputiterator&quot;&gt;LegacyOutputIterator&lt;/a&gt;.</source>
          <target state="translated">- &lt;code&gt;OutputIt&lt;/code&gt; должен соответствовать требованиям &lt;a href=&quot;../named_req/outputiterator&quot;&gt;LegacyOutputIterator&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7e86ead3f4d883e644468b1c73f514708a02964c" translate="yes" xml:space="preserve">
          <source>-&lt;code&gt;OutputIt&lt;/code&gt; must meet the requirements of &lt;a href=&quot;../named_req/outputiterator&quot;&gt;LegacyOutputIterator&lt;/a&gt;. both &lt;code&gt;acc&lt;/code&gt; (the accumulated value) and the result of &lt;code&gt;val - acc&lt;/code&gt; or &lt;code&gt;op(val, acc)&lt;/code&gt;(until C++20)&lt;code&gt;val - std::move(acc)&lt;/code&gt; or &lt;code&gt;op(val, std::move(acc))&lt;/code&gt;(since C++20) must be writable to &lt;code&gt;OutputIt&lt;/code&gt;</source>
          <target state="translated">- &lt;code&gt;OutputIt&lt;/code&gt; должен соответствовать требованиям &lt;a href=&quot;../named_req/outputiterator&quot;&gt;LegacyOutputIterator&lt;/a&gt; . и &lt;code&gt;acc&lt;/code&gt; (накопленное значение), и результат &lt;code&gt;val - acc&lt;/code&gt; или &lt;code&gt;op(val, acc)&lt;/code&gt; (до C ++ 20) &lt;code&gt;val - std::move(acc)&lt;/code&gt; или &lt;code&gt;op(val, std::move(acc))&lt;/code&gt; (начиная с C ++ 20) должен быть доступен для записи в &lt;code&gt;OutputIt&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="29da965fe354af11657ff5012d6cd7bb66771aa3" translate="yes" xml:space="preserve">
          <source>-&lt;code&gt;PopulationIterator&lt;/code&gt; must meet the requirements of &lt;a href=&quot;../named_req/inputiterator&quot;&gt;LegacyInputIterator&lt;/a&gt;.</source>
          <target state="translated">- &lt;code&gt;PopulationIterator&lt;/code&gt; должен соответствовать требованиям &lt;a href=&quot;../named_req/inputiterator&quot;&gt;LegacyInputIterator&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d962f474ba3dfaef590a955a0518ed4efa12212e" translate="yes" xml:space="preserve">
          <source>-&lt;code&gt;PopulationIterator&lt;/code&gt;'s value type must be writeable to &lt;code&gt;out&lt;/code&gt;</source>
          <target state="translated">- &lt;code&gt;PopulationIterator&lt;/code&gt; тип значения &amp;laquo;s должен быть записываемым на &lt;code&gt;out&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="71157d30139e1a4b4b81eda084b08fc43eb764e1" translate="yes" xml:space="preserve">
          <source>-&lt;code&gt;RandomIt&lt;/code&gt; must meet the requirements of &lt;a href=&quot;../../../named_req/randomaccessiterator&quot;&gt;LegacyRandomAccessIterator&lt;/a&gt;.</source>
          <target state="translated">- &lt;code&gt;RandomIt&lt;/code&gt; должен соответствовать требованиям &lt;a href=&quot;../../../named_req/randomaccessiterator&quot;&gt;LegacyRandomAccessIterator&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d2f607ae40468ef5797894774fc38482f0178173" translate="yes" xml:space="preserve">
          <source>-&lt;code&gt;RandomIt&lt;/code&gt; must meet the requirements of &lt;a href=&quot;../named_req/randomaccessiterator&quot;&gt;LegacyRandomAccessIterator&lt;/a&gt;.</source>
          <target state="translated">- &lt;code&gt;RandomIt&lt;/code&gt; должен соответствовать требованиям &lt;a href=&quot;../named_req/randomaccessiterator&quot;&gt;LegacyRandomAccessIterator&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="98251c9b55e7f4abf11f37378ad898be6c5fadbe" translate="yes" xml:space="preserve">
          <source>-&lt;code&gt;RandomIt&lt;/code&gt; must meet the requirements of &lt;a href=&quot;../named_req/valueswappable&quot;&gt;ValueSwappable&lt;/a&gt; and &lt;a href=&quot;../named_req/randomaccessiterator&quot;&gt;LegacyRandomAccessIterator&lt;/a&gt;.</source>
          <target state="translated">- &lt;code&gt;RandomIt&lt;/code&gt; должен соответствовать требованиям &lt;a href=&quot;../named_req/valueswappable&quot;&gt;ValueSwappable&lt;/a&gt; и &lt;a href=&quot;../named_req/randomaccessiterator&quot;&gt;LegacyRandomAccessIterator&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="eaa2c05a56bacd05704242d3bd6df30c4b6e4975" translate="yes" xml:space="preserve">
          <source>-&lt;code&gt;SampleIterator&lt;/code&gt; must also meet the requirements of &lt;a href=&quot;../named_req/randomaccessiterator&quot;&gt;LegacyRandomAccessIterator&lt;/a&gt; if &lt;code&gt;PopulationIterator&lt;/code&gt; doesn't meet &lt;a href=&quot;../named_req/forwarditerator&quot;&gt;LegacyForwardIterator&lt;/a&gt;</source>
          <target state="translated">- &lt;code&gt;SampleIterator&lt;/code&gt; также должен соответствовать требованиям &lt;a href=&quot;../named_req/randomaccessiterator&quot;&gt;LegacyRandomAccessIterator,&lt;/a&gt; если &lt;code&gt;PopulationIterator&lt;/code&gt; не соответствует &lt;a href=&quot;../named_req/forwarditerator&quot;&gt;LegacyForwardIterator&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d5cd603525645d89d81ecb0a97fa5b1104647059" translate="yes" xml:space="preserve">
          <source>-&lt;code&gt;SampleIterator&lt;/code&gt; must meet the requirements of &lt;a href=&quot;../named_req/outputiterator&quot;&gt;LegacyOutputIterator&lt;/a&gt;.</source>
          <target state="translated">- &lt;code&gt;SampleIterator&lt;/code&gt; должен соответствовать требованиям &lt;a href=&quot;../named_req/outputiterator&quot;&gt;LegacyOutputIterator&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6c4c58a4b3733fe1a63015c88ad95da66afcddc7" translate="yes" xml:space="preserve">
          <source>-&lt;code&gt;Searcher&lt;/code&gt; must meet the requirements of &lt;a href=&quot;https://en.cppreference.com/mwiki/index.php?title=cpp/named_req/Searcher&amp;amp;action=edit&amp;amp;redlink=1&quot;&gt;Searcher&lt;/a&gt;.</source>
          <target state="translated">- &lt;code&gt;Searcher&lt;/code&gt; должен соответствовать требованиям &lt;a href=&quot;https://en.cppreference.com/mwiki/index.php?title=cpp/named_req/Searcher&amp;amp;action=edit&amp;amp;redlink=1&quot;&gt;Searcher&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="49b4b6f9f94d3a83ae0da6bac2f0d41b3f5ec92f" translate="yes" xml:space="preserve">
          <source>-&lt;code&gt;State&lt;/code&gt; must meet the requirements of &lt;a href=&quot;../named_req/destructible&quot;&gt;Destructible&lt;/a&gt;, &lt;a href=&quot;../named_req/copyassignable&quot;&gt;CopyAssignable&lt;/a&gt;, &lt;a href=&quot;../named_req/copyconstructible&quot;&gt;CopyConstructible&lt;/a&gt; and &lt;a href=&quot;../named_req/defaultconstructible&quot;&gt;DefaultConstructible&lt;/a&gt;.</source>
          <target state="translated">- &lt;code&gt;State&lt;/code&gt; должно соответствовать требованиям &lt;a href=&quot;../named_req/destructible&quot;&gt;Destructible&lt;/a&gt; , &lt;a href=&quot;../named_req/copyassignable&quot;&gt;CopyAssignable&lt;/a&gt; , &lt;a href=&quot;../named_req/copyconstructible&quot;&gt;CopyConstructible&lt;/a&gt; и &lt;a href=&quot;../named_req/defaultconstructible&quot;&gt;DefaultConstructible&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5a348b317d61568eab4c548d7c228a34e3f64305" translate="yes" xml:space="preserve">
          <source>-&lt;code&gt;T (if init is provided)&lt;/code&gt; must meet the requirements of &lt;a href=&quot;../named_req/moveconstructible&quot;&gt;MoveConstructible&lt;/a&gt;. All of &lt;code&gt;binary_op(init, *first)&lt;/code&gt;, &lt;code&gt;binary_op(init, init)&lt;/code&gt;, and &lt;code&gt;binary_op(*first, *first)&lt;/code&gt; must be convertible to T</source>
          <target state="translated">- &lt;code&gt;T (if init is provided)&lt;/code&gt; &lt;a href=&quot;../named_req/moveconstructible&quot;&gt;указан &lt;/a&gt;init) должен соответствовать требованиям MoveConstructible . Все &lt;code&gt;binary_op(init, *first)&lt;/code&gt; , &lt;code&gt;binary_op(init, init)&lt;/code&gt; и &lt;code&gt;binary_op(*first, *first)&lt;/code&gt; должны быть преобразованы в T</target>
        </trans-unit>
        <trans-unit id="c2a5020c510f0262502557c93ed89e0865951c7c" translate="yes" xml:space="preserve">
          <source>-&lt;code&gt;T (if init is provided)&lt;/code&gt; must meet the requirements of &lt;a href=&quot;../named_req/moveconstructible&quot;&gt;MoveConstructible&lt;/a&gt;. All of &lt;code&gt;binary_op(init, unary_op(*first))&lt;/code&gt;, &lt;code&gt;binary_op(init, init)&lt;/code&gt;, and &lt;code&gt;binary_op(unary_op(*first), unary_op(*first))&lt;/code&gt; must be convertible to T</source>
          <target state="translated">- &lt;code&gt;T (if init is provided)&lt;/code&gt; &lt;a href=&quot;../named_req/moveconstructible&quot;&gt;указан &lt;/a&gt;init) должен соответствовать требованиям MoveConstructible . Все из &lt;code&gt;binary_op(init, unary_op(*first))&lt;/code&gt; , &lt;code&gt;binary_op(init, init)&lt;/code&gt; и &lt;code&gt;binary_op(unary_op(*first), unary_op(*first))&lt;/code&gt; должны быть конвертируемыми в T</target>
        </trans-unit>
        <trans-unit id="7810d2997b36f05550f6cb1bf31a4fa633ff590f" translate="yes" xml:space="preserve">
          <source>-&lt;code&gt;T (the container's element type)&lt;/code&gt; must meet the requirements of &lt;a href=&quot;../../named_req/emplaceconstructible&quot;&gt;EmplaceConstructible&lt;/a&gt;.</source>
          <target state="translated">- &lt;code&gt;T (the container's element type)&lt;/code&gt; должен соответствовать требованиям &lt;a href=&quot;../../named_req/emplaceconstructible&quot;&gt;EmplaceConstructible&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="905e21cacfad5c81bbffce9900de32849620bb35" translate="yes" xml:space="preserve">
          <source>-&lt;code&gt;T (the container's element type)&lt;/code&gt; must meet the requirements of &lt;a href=&quot;../../named_req/moveassignable&quot;&gt;MoveAssignable&lt;/a&gt;, &lt;a href=&quot;../../named_req/moveinsertable&quot;&gt;MoveInsertable&lt;/a&gt; and &lt;a href=&quot;../../named_req/emplaceconstructible&quot;&gt;EmplaceConstructible&lt;/a&gt;.</source>
          <target state="translated">- &lt;code&gt;T (the container's element type)&lt;/code&gt; должен соответствовать требованиям &lt;a href=&quot;../../named_req/moveassignable&quot;&gt;MoveAssignable&lt;/a&gt; , &lt;a href=&quot;../../named_req/moveinsertable&quot;&gt;MoveInsertable&lt;/a&gt; и &lt;a href=&quot;../../named_req/emplaceconstructible&quot;&gt;EmplaceConstructible&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c5106e515e150117a5ed081858723525bce75264" translate="yes" xml:space="preserve">
          <source>-&lt;code&gt;T (the container's element type)&lt;/code&gt; must meet the requirements of &lt;a href=&quot;../../named_req/moveinsertable&quot;&gt;MoveInsertable&lt;/a&gt; and &lt;a href=&quot;../../named_req/emplaceconstructible&quot;&gt;EmplaceConstructible&lt;/a&gt;.</source>
          <target state="translated">- &lt;code&gt;T (the container's element type)&lt;/code&gt; должен соответствовать требованиям &lt;a href=&quot;../../named_req/moveinsertable&quot;&gt;MoveInsertable&lt;/a&gt; и &lt;a href=&quot;../../named_req/emplaceconstructible&quot;&gt;EmplaceConstructible&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="084180c1730ee9ff3511af3a7074aed52956ecd0" translate="yes" xml:space="preserve">
          <source>-&lt;code&gt;T, Key&lt;/code&gt; must meet the requirements of &lt;a href=&quot;../../named_req/equalitycomparable&quot;&gt;EqualityComparable&lt;/a&gt; in order to use overloads (1-2).</source>
          <target state="translated">- &lt;code&gt;T, Key&lt;/code&gt; должен соответствовать требованиям &lt;a href=&quot;../../named_req/equalitycomparable&quot;&gt;EqualityComparable&lt;/a&gt; , чтобы использовать перегрузки (1-2).</target>
        </trans-unit>
        <trans-unit id="fa70cdcafe4b0432bf8e4d5ec413cbc51a7d1ce1" translate="yes" xml:space="preserve">
          <source>-&lt;code&gt;T2&lt;/code&gt; must meet the requirements of &lt;a href=&quot;../named_req/swappable&quot;&gt;Swappable&lt;/a&gt;.</source>
          <target state="translated">- &lt;code&gt;T2&lt;/code&gt; должен соответствовать требованиям &lt;a href=&quot;../named_req/swappable&quot;&gt;Swappable&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ff7f4cc18db9ac03597b82461300318cff643a4e" translate="yes" xml:space="preserve">
          <source>-&lt;code&gt;T&lt;/code&gt; must be a complete object type for overload (2)</source>
          <target state="translated">- &lt;code&gt;T&lt;/code&gt; должен быть полным типом объекта для перегрузки (2)</target>
        </trans-unit>
        <trans-unit id="22d8a29c2d428307356a96301dfe48b10dd001df" translate="yes" xml:space="preserve">
          <source>-&lt;code&gt;T&lt;/code&gt; must be an arithmetic type other than &lt;code&gt;bool&lt;/code&gt; for overload (1)</source>
          <target state="translated">- &lt;code&gt;T&lt;/code&gt; должен быть арифметическим типом, отличным от &lt;code&gt;bool&lt;/code&gt; для перегрузки (1)</target>
        </trans-unit>
        <trans-unit id="d4b7bba184604960afabdacbe04cef7c29efc646" translate="yes" xml:space="preserve">
          <source>-&lt;code&gt;T&lt;/code&gt; must be constructible from &lt;code&gt;&lt;a href=&quot;../initializer_list&quot;&gt;std::initializer_list&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;Args...&lt;/code&gt; for overload (2)</source>
          <target state="translated">- &lt;code&gt;T&lt;/code&gt; должен быть конструируемым из &lt;code&gt;&lt;a href=&quot;../initializer_list&quot;&gt;std::initializer_list&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;Args...&lt;/code&gt; для перегрузки (2)</target>
        </trans-unit>
        <trans-unit id="14bba7cc3b7a63c191dec2116f925714b85fb80e" translate="yes" xml:space="preserve">
          <source>-&lt;code&gt;T&lt;/code&gt; must be constructible from &lt;code&gt;Args...&lt;/code&gt; for overload (1)</source>
          <target state="translated">- &lt;code&gt;T&lt;/code&gt; должен быть конструируемым из &lt;code&gt;Args...&lt;/code&gt; для перегрузки (1)</target>
        </trans-unit>
        <trans-unit id="cffb5df90bd109b7434a393187dfa1b30b748828" translate="yes" xml:space="preserve">
          <source>-&lt;code&gt;T&lt;/code&gt; must meet the requirements of &lt;a href=&quot;../../named_req/copyassignable&quot;&gt;CopyAssignable&lt;/a&gt; and &lt;a href=&quot;../../named_req/copyinsertable&quot;&gt;CopyInsertable&lt;/a&gt; in order to use overload (1).</source>
          <target state="translated">- &lt;code&gt;T&lt;/code&gt; должен соответствовать требованиям &lt;a href=&quot;../../named_req/copyassignable&quot;&gt;CopyAssignable&lt;/a&gt; и &lt;a href=&quot;../../named_req/copyinsertable&quot;&gt;CopyInsertable&lt;/a&gt; , чтобы использовать перегрузку (1).</target>
        </trans-unit>
        <trans-unit id="7930781c7243e63a8390ec04eb0aa2c04af85f82" translate="yes" xml:space="preserve">
          <source>-&lt;code&gt;T&lt;/code&gt; must meet the requirements of &lt;a href=&quot;../../named_req/copyassignable&quot;&gt;CopyAssignable&lt;/a&gt; and &lt;a href=&quot;../../named_req/copyinsertable&quot;&gt;CopyInsertable&lt;/a&gt; in order to use overload (3).</source>
          <target state="translated">- &lt;code&gt;T&lt;/code&gt; должен соответствовать требованиям &lt;a href=&quot;../../named_req/copyassignable&quot;&gt;CopyAssignable&lt;/a&gt; и &lt;a href=&quot;../../named_req/copyinsertable&quot;&gt;CopyInsertable&lt;/a&gt; , чтобы использовать перегрузку (3).</target>
        </trans-unit>
        <trans-unit id="471088387fa31e08d2a02da4c72d9a7a716ef167" translate="yes" xml:space="preserve">
          <source>-&lt;code&gt;T&lt;/code&gt; must meet the requirements of &lt;a href=&quot;../../named_req/copyconstructible&quot;&gt;CopyConstructible&lt;/a&gt; in order to use overload (1).</source>
          <target state="translated">- &lt;code&gt;T&lt;/code&gt; должен соответствовать требованиям &lt;a href=&quot;../../named_req/copyconstructible&quot;&gt;CopyConstructible&lt;/a&gt; , чтобы использовать перегрузку (1).</target>
        </trans-unit>
        <trans-unit id="73f5abb3110caba0a3cbfda038bb47a33bd701aa" translate="yes" xml:space="preserve">
          <source>-&lt;code&gt;T&lt;/code&gt; must meet the requirements of &lt;a href=&quot;../../named_req/copyinsertable&quot;&gt;CopyInsertable&lt;/a&gt; in order to use overload (1).</source>
          <target state="translated">- &lt;code&gt;T&lt;/code&gt; должен соответствовать требованиям &lt;a href=&quot;../../named_req/copyinsertable&quot;&gt;CopyInsertable&lt;/a&gt; , чтобы использовать перегрузку (1).</target>
        </trans-unit>
        <trans-unit id="e73f59dbfdbaf5c4dcce09ce496037063fb9358b" translate="yes" xml:space="preserve">
          <source>-&lt;code&gt;T&lt;/code&gt; must meet the requirements of &lt;a href=&quot;../../named_req/copyinsertable&quot;&gt;CopyInsertable&lt;/a&gt; in order to use overload (2).</source>
          <target state="translated">- &lt;code&gt;T&lt;/code&gt; должен соответствовать требованиям &lt;a href=&quot;../../named_req/copyinsertable&quot;&gt;CopyInsertable&lt;/a&gt; , чтобы использовать перегрузку (2).</target>
        </trans-unit>
        <trans-unit id="eb108a09e5c7c38be67b06f6c9bffab1dded20be" translate="yes" xml:space="preserve">
          <source>-&lt;code&gt;T&lt;/code&gt; must meet the requirements of &lt;a href=&quot;../../named_req/defaultinsertable&quot;&gt;DefaultInsertable&lt;/a&gt; in order to use overload (1).</source>
          <target state="translated">- &lt;code&gt;T&lt;/code&gt; должен соответствовать требованиям &lt;a href=&quot;../../named_req/defaultinsertable&quot;&gt;DefaultInsertable&lt;/a&gt; , чтобы использовать перегрузку (1).</target>
        </trans-unit>
        <trans-unit id="81a64d3f2c5aed9f2ea58d39ee0dc7d25692b198" translate="yes" xml:space="preserve">
          <source>-&lt;code&gt;T&lt;/code&gt; must meet the requirements of &lt;a href=&quot;../../named_req/emplaceconstructible&quot;&gt;EmplaceConstructible&lt;/a&gt; in order to use overload (4,5).</source>
          <target state="translated">- &lt;code&gt;T&lt;/code&gt; должен соответствовать требованиям &lt;a href=&quot;../../named_req/emplaceconstructible&quot;&gt;EmplaceConstructible&lt;/a&gt; , чтобы использовать перегрузку (4,5).</target>
        </trans-unit>
        <trans-unit id="f777ee2027b95d030923b905f9b74c5248eea4b9" translate="yes" xml:space="preserve">
          <source>-&lt;code&gt;T&lt;/code&gt; must meet the requirements of &lt;a href=&quot;../../named_req/equalitycomparable&quot;&gt;EqualityComparable&lt;/a&gt; in order to use overloads (1-2).</source>
          <target state="translated">- &lt;code&gt;T&lt;/code&gt; должен соответствовать требованиям &lt;a href=&quot;../../named_req/equalitycomparable&quot;&gt;EqualityComparable&lt;/a&gt; , чтобы использовать перегрузки (1-2).</target>
        </trans-unit>
        <trans-unit id="96a89708385e36960066ed1cb1ad4a6270b18f9e" translate="yes" xml:space="preserve">
          <source>-&lt;code&gt;T&lt;/code&gt; must meet the requirements of &lt;a href=&quot;../../named_req/equalitycomparable&quot;&gt;EqualityComparable&lt;/a&gt;.</source>
          <target state="translated">- &lt;code&gt;T&lt;/code&gt; должен соответствовать требованиям &lt;a href=&quot;../../named_req/equalitycomparable&quot;&gt;EqualityComparable&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f655a15216004caebe0d4c1842ff1c7c85e72dc8" translate="yes" xml:space="preserve">
          <source>-&lt;code&gt;T&lt;/code&gt; must meet the requirements of &lt;a href=&quot;../../named_req/lessthancomparable&quot;&gt;LessThanComparable&lt;/a&gt; in order to use overloads (3-6). The ordering relation must establish total order.</source>
          <target state="translated">- &lt;code&gt;T&lt;/code&gt; должен соответствовать требованиям &lt;a href=&quot;../../named_req/lessthancomparable&quot;&gt;LessThanComparable&lt;/a&gt; , чтобы использовать перегрузки (3-6). Отношение заказа должно устанавливать общий порядок.</target>
        </trans-unit>
        <trans-unit id="8bc0ec3645431f4a729c83f7d0b332dedc67a6c2" translate="yes" xml:space="preserve">
          <source>-&lt;code&gt;T&lt;/code&gt; must meet the requirements of &lt;a href=&quot;../../named_req/moveassignable&quot;&gt;MoveAssignable&lt;/a&gt; and &lt;a href=&quot;../../named_req/moveinsertable&quot;&gt;MoveInsertable&lt;/a&gt; in order to use overload (2).</source>
          <target state="translated">- &lt;code&gt;T&lt;/code&gt; должен соответствовать требованиям &lt;a href=&quot;../../named_req/moveassignable&quot;&gt;MoveAssignable&lt;/a&gt; и &lt;a href=&quot;../../named_req/moveinsertable&quot;&gt;MoveInsertable&lt;/a&gt; , чтобы использовать перегрузку (2).</target>
        </trans-unit>
        <trans-unit id="83b8abfb3b109f24460367855ff84231d42acd86" translate="yes" xml:space="preserve">
          <source>-&lt;code&gt;T&lt;/code&gt; must meet the requirements of &lt;a href=&quot;../../named_req/moveassignable&quot;&gt;MoveAssignable&lt;/a&gt; and &lt;a href=&quot;../../named_req/moveinsertable&quot;&gt;MoveInsertable&lt;/a&gt; in order to use overload (4). required only if &lt;code&gt;InputIt&lt;/code&gt; satisfies &lt;a href=&quot;../../named_req/inputiterator&quot;&gt;LegacyInputIterator&lt;/a&gt; but not &lt;a href=&quot;../../named_req/forwarditerator&quot;&gt;LegacyForwardIterator&lt;/a&gt;. (until C++17)</source>
          <target state="translated">- &lt;code&gt;T&lt;/code&gt; должен соответствовать требованиям &lt;a href=&quot;../../named_req/moveassignable&quot;&gt;MoveAssignable&lt;/a&gt; и &lt;a href=&quot;../../named_req/moveinsertable&quot;&gt;MoveInsertable&lt;/a&gt; , чтобы использовать перегрузку (4). требуется только в том случае, если &lt;code&gt;InputIt&lt;/code&gt; удовлетворяет &lt;a href=&quot;../../named_req/inputiterator&quot;&gt;LegacyInputIterator,&lt;/a&gt; но не &lt;a href=&quot;../../named_req/forwarditerator&quot;&gt;LegacyForwardIterator&lt;/a&gt; . (до C ++ 17)</target>
        </trans-unit>
        <trans-unit id="46f5218ad771272834f2938c2efb000b08e092d8" translate="yes" xml:space="preserve">
          <source>-&lt;code&gt;T&lt;/code&gt; must meet the requirements of &lt;a href=&quot;../../named_req/moveassignable&quot;&gt;MoveAssignable&lt;/a&gt;.</source>
          <target state="translated">- &lt;code&gt;T&lt;/code&gt; должен соответствовать требованиям &lt;a href=&quot;../../named_req/moveassignable&quot;&gt;MoveAssignable&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a30288177c8d2ae9070305e88321759803254602" translate="yes" xml:space="preserve">
          <source>-&lt;code&gt;T&lt;/code&gt; must meet the requirements of &lt;a href=&quot;../../named_req/moveconstructible&quot;&gt;MoveConstructible&lt;/a&gt; in order to use overload (2).</source>
          <target state="translated">- &lt;code&gt;T&lt;/code&gt; должен соответствовать требованиям &lt;a href=&quot;../../named_req/moveconstructible&quot;&gt;MoveConstructible&lt;/a&gt; для использования перегрузки (2).</target>
        </trans-unit>
        <trans-unit id="df2dc067304b7bdd11cb64bd744da7390dc15e7c" translate="yes" xml:space="preserve">
          <source>-&lt;code&gt;T&lt;/code&gt; must meet the requirements of &lt;a href=&quot;../../named_req/moveinsertable&quot;&gt;MoveInsertable&lt;/a&gt; and &lt;a href=&quot;../../named_req/defaultinsertable&quot;&gt;DefaultInsertable&lt;/a&gt; in order to use overload (1).</source>
          <target state="translated">- &lt;code&gt;T&lt;/code&gt; должен соответствовать требованиям &lt;a href=&quot;../../named_req/moveinsertable&quot;&gt;MoveInsertable&lt;/a&gt; и &lt;a href=&quot;../../named_req/defaultinsertable&quot;&gt;DefaultInsertable&lt;/a&gt; , чтобы использовать перегрузку (1).</target>
        </trans-unit>
        <trans-unit id="c75ea7942181849fe154d4fe56f7d5a7e8e077b3" translate="yes" xml:space="preserve">
          <source>-&lt;code&gt;T&lt;/code&gt; must meet the requirements of &lt;a href=&quot;../../named_req/moveinsertable&quot;&gt;MoveInsertable&lt;/a&gt; in order to use overload (2).</source>
          <target state="translated">- &lt;code&gt;T&lt;/code&gt; должен соответствовать требованиям &lt;a href=&quot;../../named_req/moveinsertable&quot;&gt;MoveInsertable&lt;/a&gt; , чтобы использовать перегрузку (2).</target>
        </trans-unit>
        <trans-unit id="dd12a83a8a21dd2faf8db14c717a62119dacb3df" translate="yes" xml:space="preserve">
          <source>-&lt;code&gt;T&lt;/code&gt; must meet the requirements of &lt;a href=&quot;../../named_req/moveinsertable&quot;&gt;MoveInsertable&lt;/a&gt;.</source>
          <target state="translated">- &lt;code&gt;T&lt;/code&gt; должен соответствовать требованиям &lt;a href=&quot;../../named_req/moveinsertable&quot;&gt;MoveInsertable&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="955e988bcc8c424fa42f194f883da98cda7a48a2" translate="yes" xml:space="preserve">
          <source>-&lt;code&gt;T&lt;/code&gt; must meet the requirements of &lt;a href=&quot;../../named_req/swappable&quot;&gt;Swappable&lt;/a&gt;, &lt;a href=&quot;../../named_req/moveassignable&quot;&gt;MoveAssignable&lt;/a&gt;, &lt;a href=&quot;../../named_req/moveconstructible&quot;&gt;MoveConstructible&lt;/a&gt; and &lt;a href=&quot;../../named_req/moveinsertable&quot;&gt;MoveInsertable&lt;/a&gt; in order to use overload (4,5). (since C++17)</source>
          <target state="translated">- &lt;code&gt;T&lt;/code&gt; должна соответствовать требованиям &lt;a href=&quot;../../named_req/swappable&quot;&gt;Swappable&lt;/a&gt; , &lt;a href=&quot;../../named_req/moveassignable&quot;&gt;MoveAssignable&lt;/a&gt; , &lt;a href=&quot;../../named_req/moveconstructible&quot;&gt;MoveConstructible&lt;/a&gt; и &lt;a href=&quot;../../named_req/moveinsertable&quot;&gt;MoveInsertable&lt;/a&gt; для того , чтобы использовать перегрузки (4,5). (начиная с C ++ 17)</target>
        </trans-unit>
        <trans-unit id="afbeaf062ea6fd0595970eeb503e2e6f5c5e7744" translate="yes" xml:space="preserve">
          <source>-&lt;code&gt;T&lt;/code&gt; must meet the requirements of &lt;a href=&quot;../named_req/copyassignable&quot;&gt;CopyAssignable&lt;/a&gt; and &lt;a href=&quot;../named_req/copyconstructible&quot;&gt;CopyConstructible&lt;/a&gt;.</source>
          <target state="translated">- &lt;code&gt;T&lt;/code&gt; должен соответствовать требованиям &lt;a href=&quot;../named_req/copyassignable&quot;&gt;CopyAssignable&lt;/a&gt; и &lt;a href=&quot;../named_req/copyconstructible&quot;&gt;CopyConstructible&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ab460245f5ca1cfa08f3d1ec2722e5c78976ffcb" translate="yes" xml:space="preserve">
          <source>-&lt;code&gt;T&lt;/code&gt; must meet the requirements of &lt;a href=&quot;../named_req/copyconstructible&quot;&gt;CopyConstructible&lt;/a&gt; in order to use overloads (3,4).</source>
          <target state="translated">- &lt;code&gt;T&lt;/code&gt; должен соответствовать требованиям &lt;a href=&quot;../named_req/copyconstructible&quot;&gt;CopyConstructible&lt;/a&gt; , чтобы использовать перегрузки (3,4).</target>
        </trans-unit>
        <trans-unit id="7b670662fdaf16909ed9b4448468795dec02b564" translate="yes" xml:space="preserve">
          <source>-&lt;code&gt;T&lt;/code&gt; must meet the requirements of &lt;a href=&quot;../named_req/lessthancomparable&quot;&gt;LessThanComparable&lt;/a&gt; in order to use overloads (1).</source>
          <target state="translated">- &lt;code&gt;T&lt;/code&gt; должен соответствовать требованиям &lt;a href=&quot;../named_req/lessthancomparable&quot;&gt;LessThanComparable&lt;/a&gt; , чтобы использовать перегрузки (1).</target>
        </trans-unit>
        <trans-unit id="a320cda4651b152682eb79c8e8e99ea2769e8c5e" translate="yes" xml:space="preserve">
          <source>-&lt;code&gt;T&lt;/code&gt; must meet the requirements of &lt;a href=&quot;../named_req/lessthancomparable&quot;&gt;LessThanComparable&lt;/a&gt; in order to use overloads (1,3).</source>
          <target state="translated">- &lt;code&gt;T&lt;/code&gt; должен соответствовать требованиям &lt;a href=&quot;../named_req/lessthancomparable&quot;&gt;LessThanComparable&lt;/a&gt; , чтобы использовать перегрузки (1,3).</target>
        </trans-unit>
        <trans-unit id="48fe196760fc1f1946ea79d3075055f7b6aeaabd" translate="yes" xml:space="preserve">
          <source>-&lt;code&gt;T&lt;/code&gt; must meet the requirements of &lt;a href=&quot;../named_req/moveassignable&quot;&gt;MoveAssignable&lt;/a&gt; and &lt;a href=&quot;../named_req/moveconstructible&quot;&gt;MoveConstructible&lt;/a&gt;.</source>
          <target state="translated">- &lt;code&gt;T&lt;/code&gt; должен соответствовать требованиям &lt;a href=&quot;../named_req/moveassignable&quot;&gt;MoveAssignable&lt;/a&gt; и &lt;a href=&quot;../named_req/moveconstructible&quot;&gt;MoveConstructible&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="32c23e4f427e0609ed933c05aa132bcda1ee2718" translate="yes" xml:space="preserve">
          <source>-&lt;code&gt;T&lt;/code&gt; must meet the requirements of &lt;a href=&quot;../named_req/moveconstructible&quot;&gt;MoveConstructible&lt;/a&gt; in order to use overloads (2,5). and the result of the expressions &lt;code&gt;binary_op1(init, binary_op2(*first1, *first2))&lt;/code&gt;, &lt;code&gt;binary_op1(binary_op2(*first1, *first2), init)&lt;/code&gt;, &lt;code&gt;binary_op1(init, init)&lt;/code&gt;, and &lt;code&gt;binary_op1(binary_op2(*first1, *first2), binary_op2(*first1, *first2))&lt;/code&gt; must be convertible to T</source>
          <target state="translated">- &lt;code&gt;T&lt;/code&gt; должен соответствовать требованиям &lt;a href=&quot;../named_req/moveconstructible&quot;&gt;MoveConstructible&lt;/a&gt; для использования перегрузок (2,5). и результат выражений &lt;code&gt;binary_op1(init, binary_op2(*first1, *first2))&lt;/code&gt; , &lt;code&gt;binary_op1(binary_op2(*first1, *first2), init)&lt;/code&gt; , &lt;code&gt;binary_op1(init, init)&lt;/code&gt; и &lt;code&gt;binary_op1(binary_op2(*first1, *first2), binary_op2(*first1, *first2))&lt;/code&gt; должен быть преобразован в T</target>
        </trans-unit>
        <trans-unit id="b61c2e4c2acdbcf060f22b54d7687f0c61f22811" translate="yes" xml:space="preserve">
          <source>-&lt;code&gt;T&lt;/code&gt; must meet the requirements of &lt;a href=&quot;../named_req/moveconstructible&quot;&gt;MoveConstructible&lt;/a&gt; in order to use overloads (3,6). and the result of the expressions &lt;code&gt;binary_op(init, unary_op(*first))&lt;/code&gt;, &lt;code&gt;binary_op(unary_op(*first), init)&lt;/code&gt;, &lt;code&gt;binary_op(init, init)&lt;/code&gt;, and &lt;code&gt;binary_op(unary_op(*first), unary_op(*first))&lt;/code&gt; must be convertible to T</source>
          <target state="translated">- &lt;code&gt;T&lt;/code&gt; должен соответствовать требованиям &lt;a href=&quot;../named_req/moveconstructible&quot;&gt;MoveConstructible&lt;/a&gt; для использования перегрузок (3,6). и результат выражений &lt;code&gt;binary_op(init, unary_op(*first))&lt;/code&gt; , &lt;code&gt;binary_op(unary_op(*first), init)&lt;/code&gt; , &lt;code&gt;binary_op(init, init)&lt;/code&gt; и &lt;code&gt;binary_op(unary_op(*first), unary_op(*first))&lt;/code&gt; должен быть конвертируемым в T</target>
        </trans-unit>
        <trans-unit id="735f48ddde8598786438eb6c8a0e27a9a20e41fa" translate="yes" xml:space="preserve">
          <source>-&lt;code&gt;T&lt;/code&gt; must meet the requirements of &lt;a href=&quot;../named_req/moveconstructible&quot;&gt;MoveConstructible&lt;/a&gt;. All of &lt;code&gt;binary_op(init, unary_op(*first))&lt;/code&gt;, &lt;code&gt;binary_op(init, init)&lt;/code&gt;, and &lt;code&gt;binary_op(unary_op(*first), unary_op(*first))&lt;/code&gt; must be convertible to &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">- &lt;code&gt;T&lt;/code&gt; должен соответствовать требованиям &lt;a href=&quot;../named_req/moveconstructible&quot;&gt;MoveConstructible&lt;/a&gt; . Все &lt;code&gt;binary_op(init, unary_op(*first))&lt;/code&gt; , &lt;code&gt;binary_op(init, init)&lt;/code&gt; , и &lt;code&gt;binary_op(unary_op(*first), unary_op(*first))&lt;/code&gt; должны быть конвертированы в &lt;code&gt;T&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4830e7790cb0a3a97c614ec99dee4fd4f76bde82" translate="yes" xml:space="preserve">
          <source>-&lt;code&gt;T&lt;/code&gt; must meet the requirements of &lt;a href=&quot;../named_req/moveconstructible&quot;&gt;MoveConstructible&lt;/a&gt;. Also, it must be possible to move-assign objects of type &lt;code&gt;U&lt;/code&gt; to objects of type &lt;code&gt;T&lt;/code&gt;</source>
          <target state="translated">- &lt;code&gt;T&lt;/code&gt; должен соответствовать требованиям &lt;a href=&quot;../named_req/moveconstructible&quot;&gt;MoveConstructible&lt;/a&gt; . Кроме того, должна быть возможность перемещать-назначать объекты типа &lt;code&gt;U&lt;/code&gt; объектам типа &lt;code&gt;T&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="070995c3e11380f1a759c287d70004246a336f84" translate="yes" xml:space="preserve">
          <source>-&lt;code&gt;T&lt;/code&gt; must meet the requirements of &lt;a href=&quot;../named_req/moveconstructible&quot;&gt;MoveConstructible&lt;/a&gt;. and &lt;code&gt;binary_op(init, *first)&lt;/code&gt;, &lt;code&gt;binary_op(*first, init)&lt;/code&gt;, &lt;code&gt;binary_op(init, init)&lt;/code&gt;, and &lt;code&gt;binary_op(*first, *first)&lt;/code&gt; must be convertible to &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">- &lt;code&gt;T&lt;/code&gt; должен соответствовать требованиям &lt;a href=&quot;../named_req/moveconstructible&quot;&gt;MoveConstructible&lt;/a&gt; . и &lt;code&gt;binary_op(init, *first)&lt;/code&gt; , &lt;code&gt;binary_op(*first, init)&lt;/code&gt; , &lt;code&gt;binary_op(init, init)&lt;/code&gt; и &lt;code&gt;binary_op(*first, *first)&lt;/code&gt; должны быть конвертированы в &lt;code&gt;T&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="24ebbe51e0d271ce6d4ccbb7dd18d09cb13e0244" translate="yes" xml:space="preserve">
          <source>-&lt;code&gt;T&lt;/code&gt; must meet the requirements of &lt;a href=&quot;../named_req/moveconstructible&quot;&gt;MoveConstructible&lt;/a&gt;. and &lt;code&gt;binary_op(init, *first)&lt;/code&gt;, &lt;code&gt;binary_op(init, init)&lt;/code&gt;, and &lt;code&gt;binary_op(*first, *first)&lt;/code&gt; must be convertible to &lt;code&gt;T&lt;/code&gt;</source>
          <target state="translated">- &lt;code&gt;T&lt;/code&gt; должен соответствовать требованиям &lt;a href=&quot;../named_req/moveconstructible&quot;&gt;MoveConstructible&lt;/a&gt; . а &lt;code&gt;binary_op(init, *first)&lt;/code&gt; , &lt;code&gt;binary_op(init, init)&lt;/code&gt; и &lt;code&gt;binary_op(*first, *first)&lt;/code&gt; должны быть конвертируемыми в &lt;code&gt;T&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="240b36ac63aedc5650c0eebdca5e66141ce3bde5" translate="yes" xml:space="preserve">
          <source>-&lt;code&gt;U&amp;amp;&amp;amp;&lt;/code&gt; must be convertible to &lt;code&gt;T&lt;/code&gt;</source>
          <target state="translated">- &lt;code&gt;U&amp;amp;&amp;amp;&lt;/code&gt; должен быть конвертируемым в &lt;code&gt;T&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b81d5e3c63c353df7206ad9ffec731b9d09453db" translate="yes" xml:space="preserve">
          <source>-&lt;code&gt;UnaryFunction2&lt;/code&gt; must meet the requirements of &lt;a href=&quot;../named_req/copyconstructible&quot;&gt;CopyConstructible&lt;/a&gt;.</source>
          <target state="translated">- &lt;code&gt;UnaryFunction2&lt;/code&gt; должен соответствовать требованиям &lt;a href=&quot;../named_req/copyconstructible&quot;&gt;CopyConstructible&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6014d7e4016480f38e962647d7142d9618786712" translate="yes" xml:space="preserve">
          <source>-&lt;code&gt;UnaryFunction&lt;/code&gt; must meet the requirements of &lt;a href=&quot;../named_req/moveconstructible&quot;&gt;MoveConstructible&lt;/a&gt;. Does not have to be &lt;a href=&quot;../named_req/copyconstructible&quot;&gt;CopyConstructible&lt;/a&gt;</source>
          <target state="translated">- &lt;code&gt;UnaryFunction&lt;/code&gt; должна соответствовать требованиям &lt;a href=&quot;../named_req/moveconstructible&quot;&gt;MoveConstructible&lt;/a&gt; . Не должен быть &lt;a href=&quot;../named_req/copyconstructible&quot;&gt;CopyConstructible&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ec2173dc69a67195292305ee0f463384bf04a493" translate="yes" xml:space="preserve">
          <source>-&lt;code&gt;UnaryPredicate&lt;/code&gt; must meet the requirements of &lt;a href=&quot;../named_req/predicate&quot;&gt;Predicate&lt;/a&gt;.</source>
          <target state="translated">- &lt;code&gt;UnaryPredicate&lt;/code&gt; должен соответствовать требованиям &lt;a href=&quot;../named_req/predicate&quot;&gt;Predicate&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="29292267e10038a5997139362f189f03885b9b0c" translate="yes" xml:space="preserve">
          <source>-&lt;code&gt;W&lt;/code&gt; must be greater than zero, and no greater than &lt;code&gt;&lt;a href=&quot;../../types/numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;UIntType&amp;gt;::digits&lt;/code&gt;.</source>
          <target state="translated">- &lt;code&gt;W&lt;/code&gt; должен быть больше нуля и не больше, чем &lt;code&gt;&lt;a href=&quot;../../types/numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;UIntType&amp;gt;::digits&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f89b6a8131c4a3381b15946e9051f71792126a60" translate="yes" xml:space="preserve">
          <source>-&lt;code&gt;key_type&lt;/code&gt; must meet the requirements of &lt;a href=&quot;../../named_req/copyconstructible&quot;&gt;CopyConstructible&lt;/a&gt;.</source>
          <target state="translated">- &lt;code&gt;key_type&lt;/code&gt; должен соответствовать требованиям &lt;a href=&quot;../../named_req/copyconstructible&quot;&gt;CopyConstructible&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="129d57481bdef249acefaffbce24cd66b9f3b73a" translate="yes" xml:space="preserve">
          <source>-&lt;code&gt;mapped_type&lt;/code&gt; must meet the requirements of &lt;a href=&quot;../../named_req/copyconstructible&quot;&gt;CopyConstructible&lt;/a&gt; and &lt;a href=&quot;../../named_req/defaultconstructible&quot;&gt;DefaultConstructible&lt;/a&gt;.</source>
          <target state="translated">- &lt;code&gt;mapped_type&lt;/code&gt; должен соответствовать требованиям &lt;a href=&quot;../../named_req/copyconstructible&quot;&gt;CopyConstructible&lt;/a&gt; и &lt;a href=&quot;../../named_req/defaultconstructible&quot;&gt;DefaultConstructible&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="debd7c798d0035e7d613bf22525a497feb4eac68" translate="yes" xml:space="preserve">
          <source>-&lt;code&gt;std::decay_t&amp;lt;ValueType&amp;gt;&lt;/code&gt; must meet the requirements of &lt;a href=&quot;../../named_req/copyconstructible&quot;&gt;CopyConstructible&lt;/a&gt;.</source>
          <target state="translated">- &lt;code&gt;std::decay_t&amp;lt;ValueType&amp;gt;&lt;/code&gt; должен соответствовать требованиям &lt;a href=&quot;../../named_req/copyconstructible&quot;&gt;CopyConstructible&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1d5acc57403e947250368f57577287097a8c8cc4" translate="yes" xml:space="preserve">
          <source>-&lt;code&gt;std::is_constructible_v&amp;lt;&lt;a href=&quot;../../types/decay&quot;&gt;std::decay_t&lt;/a&gt;&amp;lt;F&amp;gt;, F&amp;gt;&lt;/code&gt; is required to be true</source>
          <target state="translated">- &lt;code&gt;std::is_constructible_v&amp;lt;&lt;a href=&quot;../../types/decay&quot;&gt;std::decay_t&lt;/a&gt;&amp;lt;F&amp;gt;, F&amp;gt;&lt;/code&gt; должно быть истинным</target>
        </trans-unit>
        <trans-unit id="3a79a46e3b7ff92c381844fb9a39002a4b0fa232" translate="yes" xml:space="preserve">
          <source>-&lt;code&gt;value_type&lt;/code&gt; must be &lt;a href=&quot;../../named_req/emplaceconstructible&quot;&gt;EmplaceConstructible&lt;/a&gt; from &lt;code&gt;&lt;a href=&quot;../../utility/piecewise_construct&quot;&gt;std::piecewise_construct&lt;/a&gt;, &lt;a href=&quot;../../utility/tuple/forward_as_tuple&quot;&gt;std::forward_as_tuple&lt;/a&gt;(key), &lt;a href=&quot;../../utility/tuple&quot;&gt;std::tuple&lt;/a&gt;&amp;lt;&amp;gt;()&lt;/code&gt;. When the default allocator is used, this means that &lt;code&gt;key_type&lt;/code&gt; must be &lt;a href=&quot;../../named_req/copyconstructible&quot;&gt;CopyConstructible&lt;/a&gt; and &lt;code&gt;mapped_type&lt;/code&gt; must be &lt;a href=&quot;../../named_req/defaultconstructible&quot;&gt;DefaultConstructible&lt;/a&gt;.</source>
          <target state="translated">- &lt;code&gt;value_type&lt;/code&gt; должен быть &lt;a href=&quot;../../named_req/emplaceconstructible&quot;&gt;EmplaceConstructible&lt;/a&gt; из &lt;code&gt;&lt;a href=&quot;../../utility/piecewise_construct&quot;&gt;std::piecewise_construct&lt;/a&gt;, &lt;a href=&quot;../../utility/tuple/forward_as_tuple&quot;&gt;std::forward_as_tuple&lt;/a&gt;(key), &lt;a href=&quot;../../utility/tuple&quot;&gt;std::tuple&lt;/a&gt;&amp;lt;&amp;gt;()&lt;/code&gt; piecewise_construct , std :: forward_as_tuple (key), std :: tuple &amp;lt;&amp;gt; () . Когда используется распределитель по умолчанию, это означает, что &lt;code&gt;key_type&lt;/code&gt; должен быть &lt;a href=&quot;../../named_req/copyconstructible&quot;&gt;CopyConstructible,&lt;/a&gt; а &lt;code&gt;mapped_type&lt;/code&gt; должен быть &lt;a href=&quot;../../named_req/defaultconstructible&quot;&gt;DefaultConstructible&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d97831a170788f8d67b47b8d93ff132ec0bb8c06" translate="yes" xml:space="preserve">
          <source>-&lt;code&gt;value_type&lt;/code&gt; must be &lt;a href=&quot;../../named_req/emplaceconstructible&quot;&gt;EmplaceConstructible&lt;/a&gt; from &lt;code&gt;&lt;a href=&quot;../../utility/piecewise_construct&quot;&gt;std::piecewise_construct&lt;/a&gt;, &lt;a href=&quot;../../utility/tuple/forward_as_tuple&quot;&gt;std::forward_as_tuple&lt;/a&gt;(std::move(key)), &lt;a href=&quot;../../utility/tuple&quot;&gt;std::tuple&lt;/a&gt;&amp;lt;&amp;gt;()&lt;/code&gt;. When the default allocator is used, this means that &lt;code&gt;key_type&lt;/code&gt; must be &lt;a href=&quot;../../named_req/moveconstructible&quot;&gt;MoveConstructible&lt;/a&gt; and &lt;code&gt;mapped_type&lt;/code&gt; must be &lt;a href=&quot;../../named_req/defaultconstructible&quot;&gt;DefaultConstructible&lt;/a&gt;.</source>
          <target state="translated">- &lt;code&gt;value_type&lt;/code&gt; должен быть &lt;a href=&quot;../../named_req/emplaceconstructible&quot;&gt;EmplaceConstructible&lt;/a&gt; из &lt;code&gt;&lt;a href=&quot;../../utility/piecewise_construct&quot;&gt;std::piecewise_construct&lt;/a&gt;, &lt;a href=&quot;../../utility/tuple/forward_as_tuple&quot;&gt;std::forward_as_tuple&lt;/a&gt;(std::move(key)), &lt;a href=&quot;../../utility/tuple&quot;&gt;std::tuple&lt;/a&gt;&amp;lt;&amp;gt;()&lt;/code&gt; piecewise_construct , std :: forward_as_tuple (std :: move (key)), std :: tuple &amp;lt;&amp;gt; () . Когда используется распределитель по умолчанию, это означает, что &lt;code&gt;key_type&lt;/code&gt; должен быть &lt;a href=&quot;../../named_req/moveconstructible&quot;&gt;MoveConstructible,&lt;/a&gt; а &lt;code&gt;mapped_type&lt;/code&gt; должен быть &lt;a href=&quot;../../named_req/defaultconstructible&quot;&gt;DefaultConstructible&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ff8015eb2b1855f53bb4336bf8d4411ac6c84c5b" translate="yes" xml:space="preserve">
          <source>-E</source>
          <target state="translated">-E</target>
        </trans-unit>
        <trans-unit id="47c47adf6da44571449c368a24b1dbbce9c4896b" translate="yes" xml:space="preserve">
          <source>-No increment, assignment, comparison, or indirection through valid instances of &lt;code&gt;ForwardIt&lt;/code&gt; may throw exceptions.</source>
          <target state="translated">-Нет приращения, присваивания, сравнения или косвенного обращения через допустимые экземпляры &lt;code&gt;ForwardIt&lt;/code&gt; могут выдавать исключения.</target>
        </trans-unit>
        <trans-unit id="eb831d16a34da446211de736f7a976a6da2d183b" translate="yes" xml:space="preserve">
          <source>-The type of dereferenced &lt;code&gt;BidirIt&lt;/code&gt; must meet the requirements of &lt;a href=&quot;../named_req/moveassignable&quot;&gt;MoveAssignable&lt;/a&gt; and &lt;a href=&quot;../named_req/moveconstructible&quot;&gt;MoveConstructible&lt;/a&gt;.</source>
          <target state="translated">- Тип разыменованного &lt;code&gt;BidirIt&lt;/code&gt; должен соответствовать требованиям &lt;a href=&quot;../named_req/moveassignable&quot;&gt;MoveAssignable&lt;/a&gt; и &lt;a href=&quot;../named_req/moveconstructible&quot;&gt;MoveConstructible&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="fea212bdfb63511131a24166d6cf8c37f24a9977" translate="yes" xml:space="preserve">
          <source>-The type of dereferenced &lt;code&gt;ForwardIt&lt;/code&gt; must meet the requirements of &lt;a href=&quot;../named_req/moveassignable&quot;&gt;MoveAssignable&lt;/a&gt; and &lt;a href=&quot;../named_req/moveconstructible&quot;&gt;MoveConstructible&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;ForwardIt&lt;/code&gt; разыменованного ForwardIt должен соответствовать требованиям &lt;a href=&quot;../named_req/moveassignable&quot;&gt;MoveAssignable&lt;/a&gt; и &lt;a href=&quot;../named_req/moveconstructible&quot;&gt;MoveConstructible&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9070dc7500842363fa2c05017f765046615dbb95" translate="yes" xml:space="preserve">
          <source>-The type of dereferenced &lt;code&gt;ForwardIt&lt;/code&gt; must meet the requirements of &lt;a href=&quot;../named_req/moveassignable&quot;&gt;MoveAssignable&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;ForwardIt&lt;/code&gt; разыменованного ForwardIt должен соответствовать требованиям &lt;a href=&quot;../named_req/moveassignable&quot;&gt;MoveAssignable&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e6111d8d5184d2a92b766306033c8f746e15ff45" translate="yes" xml:space="preserve">
          <source>-The type of dereferenced &lt;code&gt;InputIt&lt;/code&gt; must meet the requirements of &lt;a href=&quot;../named_req/copyassignable&quot;&gt;CopyAssignable&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;InputIt&lt;/code&gt; разыменованного InputIt должен соответствовать требованиям &lt;a href=&quot;../named_req/copyassignable&quot;&gt;CopyAssignable&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5f5377d372d149a9da9efea14ca7295541e3b278" translate="yes" xml:space="preserve">
          <source>-The type of dereferenced &lt;code&gt;InputIt&lt;/code&gt; must meet the requirements of &lt;a href=&quot;../named_req/copyassignable&quot;&gt;CopyAssignable&lt;/a&gt;. if &lt;code&gt;InputIt&lt;/code&gt; does not satisfy &lt;a href=&quot;../named_req/forwarditerator&quot;&gt;LegacyForwardIterator&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;InputIt&lt;/code&gt; разыменованного InputIt должен соответствовать требованиям &lt;a href=&quot;../named_req/copyassignable&quot;&gt;CopyAssignable&lt;/a&gt; . если &lt;code&gt;InputIt&lt;/code&gt; не удовлетворяет &lt;a href=&quot;../named_req/forwarditerator&quot;&gt;LegacyForwardIterator&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="35d8052956297290de757a81ca77db43e329f302" translate="yes" xml:space="preserve">
          <source>-The type of dereferenced &lt;code&gt;InputIt&lt;/code&gt; must meet the requirements of &lt;a href=&quot;../named_req/copyconstructible&quot;&gt;CopyConstructible&lt;/a&gt;. if neither &lt;code&gt;InputIt&lt;/code&gt; nor &lt;code&gt;OutputIt&lt;/code&gt; satisfies &lt;a href=&quot;../named_req/forwarditerator&quot;&gt;LegacyForwardIterator&lt;/a&gt;, or if &lt;code&gt;InputIt&lt;/code&gt; does not satisfy &lt;a href=&quot;../named_req/forwarditerator&quot;&gt;LegacyForwardIterator&lt;/a&gt; and the value type of &lt;code&gt;InputIt&lt;/code&gt; differs from that of &lt;code&gt;OutputIt&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;InputIt&lt;/code&gt; разыменованного InputIt должен соответствовать требованиям &lt;a href=&quot;../named_req/copyconstructible&quot;&gt;CopyConstructible&lt;/a&gt; . если ни &lt;code&gt;InputIt&lt;/code&gt; , ни &lt;code&gt;OutputIt&lt;/code&gt; не удовлетворяют &lt;a href=&quot;../named_req/forwarditerator&quot;&gt;LegacyForwardIterator&lt;/a&gt; , или если &lt;code&gt;InputIt&lt;/code&gt; не удовлетворяет &lt;a href=&quot;../named_req/forwarditerator&quot;&gt;LegacyForwardIterator&lt;/a&gt; и типу значения &lt;code&gt;InputIt&lt;/code&gt; отличается от типа &lt;code&gt;OutputIt&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1033b058712ba4bd32d56b528177040435614bb2" translate="yes" xml:space="preserve">
          <source>-The type of dereferenced &lt;code&gt;RandomIt&lt;/code&gt; must meet the requirements of &lt;a href=&quot;../named_req/moveassignable&quot;&gt;MoveAssignable&lt;/a&gt; and &lt;a href=&quot;../named_req/moveconstructible&quot;&gt;MoveConstructible&lt;/a&gt;.</source>
          <target state="translated">Тип разыменованного &lt;code&gt;RandomIt&lt;/code&gt; должен соответствовать требованиям &lt;a href=&quot;../named_req/moveassignable&quot;&gt;MoveAssignable&lt;/a&gt; и &lt;a href=&quot;../named_req/moveconstructible&quot;&gt;MoveConstructible&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="961a73e39e89cb3f2795f5bbf3cbdb9625270fdd" translate="yes" xml:space="preserve">
          <source>-The types of dereferenced &lt;code&gt;ForwardIt1&lt;/code&gt; and &lt;code&gt;ForwardIt2&lt;/code&gt; must meet the requirements of &lt;a href=&quot;../named_req/swappable&quot;&gt;Swappable&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;ForwardIt1&lt;/code&gt; разыменованными ForwardIt1 и &lt;code&gt;ForwardIt2&lt;/code&gt; должны соответствовать требованиям &lt;a href=&quot;../named_req/swappable&quot;&gt;Swappable&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ee0fc4c6e8c36c2cdf1bf0caedd9cb01843102d7" translate="yes" xml:space="preserve">
          <source>-The value type of &lt;code&gt;InputIt&lt;/code&gt; must be &lt;code&gt;char&lt;/code&gt;</source>
          <target state="translated">Тип значения &lt;code&gt;InputIt&lt;/code&gt; должен быть &lt;code&gt;char&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="943fa25d062c8405568c4ff3a57ad45d9288723a" translate="yes" xml:space="preserve">
          <source>-The value type of &lt;code&gt;InputIt&lt;/code&gt; must be &lt;code&gt;char&lt;/code&gt; to use the overload (7))</source>
          <target state="translated">Тип значения &lt;code&gt;InputIt&lt;/code&gt; должен быть &lt;code&gt;char&lt;/code&gt; чтобы использовать перегрузку (7)</target>
        </trans-unit>
        <trans-unit id="386d13b86abcf4b9bca6e76ef852ed6b2ad732cb" translate="yes" xml:space="preserve">
          <source>-The value type of &lt;code&gt;InputIt&lt;/code&gt; must be one of the character types &lt;code&gt;char&lt;/code&gt;, &lt;code&gt;wchar_t&lt;/code&gt;, &lt;code&gt;char8_t&lt;/code&gt;, (since C++20)&lt;code&gt;char16_t&lt;/code&gt; and &lt;code&gt;char32_t&lt;/code&gt; to use the overload (5))</source>
          <target state="translated">Тип значения &lt;code&gt;InputIt&lt;/code&gt; должен быть одним из типов &lt;code&gt;char&lt;/code&gt; , &lt;code&gt;wchar_t&lt;/code&gt; , &lt;code&gt;char8_t&lt;/code&gt; , (начиная с C ++ 20) &lt;code&gt;char16_t&lt;/code&gt; и &lt;code&gt;char32_t&lt;/code&gt; чтобы использовать перегрузку (5))</target>
        </trans-unit>
        <trans-unit id="85af98cd8f2584c8a1bf3193d2a9453c4a0696b3" translate="yes" xml:space="preserve">
          <source>-The value type of &lt;code&gt;InputIt&lt;/code&gt; must be one of the encoded character types (&lt;code&gt;char&lt;/code&gt;, &lt;code&gt;wchar_t&lt;/code&gt;, &lt;code&gt;char16_t&lt;/code&gt; and &lt;code&gt;char32_t&lt;/code&gt;)</source>
          <target state="translated">Тип значения &lt;code&gt;InputIt&lt;/code&gt; должен быть одним из типов закодированных символов ( &lt;code&gt;char&lt;/code&gt; , &lt;code&gt;wchar_t&lt;/code&gt; , &lt;code&gt;char16_t&lt;/code&gt; и &lt;code&gt;char32_t&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="781c92c6f4232004d3a5ca088f526ac147d9db22" translate="yes" xml:space="preserve">
          <source>-a, where &lt;code&gt;b&lt;/code&gt; is the number of bits after promotion.</source>
          <target state="translated">-а, где &lt;code&gt;b&lt;/code&gt; - количество битов после повышения.</target>
        </trans-unit>
        <trans-unit id="8a9cd7781044a79a622806d2c71e18d259189aab" translate="yes" xml:space="preserve">
          <source>-arg</source>
          <target state="translated">-arg</target>
        </trans-unit>
        <trans-unit id="16372868051b38c9793bfcfb1bab9865824a7cf8" translate="yes" xml:space="preserve">
          <source>-e-arg</source>
          <target state="translated">-e-arg</target>
        </trans-unit>
        <trans-unit id="36105b9bc31e91d70aff56af9dcd73894e1e5181" translate="yes" xml:space="preserve">
          <source>-e-iz</source>
          <target state="translated">-e-iz</target>
        </trans-unit>
        <trans-unit id="c6ea641826a7102b4cb61da3fbe5c8784257cca9" translate="yes" xml:space="preserve">
          <source>-e-z</source>
          <target state="translated">-e-z</target>
        </trans-unit>
        <trans-unit id="af8605005221d6158480c209167abfb0fad20613" translate="yes" xml:space="preserve">
          <source>-eiz</source>
          <target state="translated">-eiz</target>
        </trans-unit>
        <trans-unit id="6d358556e5f27dfee6bf6eb686c8965aebf7a90e" translate="yes" xml:space="preserve">
          <source>-th</source>
          <target state="translated">-th</target>
        </trans-unit>
        <trans-unit id="3a52ce780950d4d969792a2559cd519d7ee8c727" translate="yes" xml:space="preserve">
          <source>.</source>
          <target state="translated">.</target>
        </trans-unit>
        <trans-unit id="9ab9cbe186911e3306c2471a07f4d73488a998c2" translate="yes" xml:space="preserve">
          <source>. (the value of M, determined by B, will be the value stored by one of these side effects).</source>
          <target state="translated">, (значение M, определяемое B, будет значением, сохраненным одним из этих побочных эффектов).</target>
        </trans-unit>
        <trans-unit id="4c867670cfdf2b3d78e9b9332a77e4cae54f2ca7" translate="yes" xml:space="preserve">
          <source>. &lt;code&gt;*this&lt;/code&gt; is</source>
          <target state="translated">, &lt;code&gt;*this&lt;/code&gt; есть</target>
        </trans-unit>
        <trans-unit id="858e49b217359edfde089556fcb3a0afd53dff9d" translate="yes" xml:space="preserve">
          <source>. A program that has two conflicting evaluations has a</source>
          <target state="translated">, Программа, которая имеет две противоречивые оценки, имеет</target>
        </trans-unit>
        <trans-unit id="40cdcbb4fcaaf112141529b2f4aa097584351c61" translate="yes" xml:space="preserve">
          <source>. Always stores a null character in addition to the characters matched (so the argument array must have room for at least</source>
          <target state="translated">, Всегда хранит нулевой символ в дополнение к совпадающим символам (поэтому в массиве аргументов должно быть место как минимум</target>
        </trans-unit>
        <trans-unit id="6c8c268081021c567c19d1d620072b0fc7e50c0e" translate="yes" xml:space="preserve">
          <source>. Any use of a deleted function is ill-formed (the program will not compile). This includes calls, both explicit (with a function call operator) and implicit (a call to deleted overloaded operator, special member function, allocation function etc), constructing a pointer or pointer-to-member to a deleted function, and even the use of a deleted function in an unevaluated expression. However, implicit &lt;a href=&quot;definition#ODR-use&quot;&gt;ODR-use&lt;/a&gt; of a non-pure virtual member function that happens to be deleted is allowed.</source>
          <target state="translated">, Любое использование удаленной функции некорректно (программа не будет компилироваться). Это включает вызовы, как явные (с оператором вызова функции), так и неявные (вызов удаленного перегруженного оператора, специальную функцию-член, функцию выделения и т. Д.), Создание указателя или указателя на член для удаленной функции и даже использование удаленной функции в неоцененном выражении. Однако неявное &lt;a href=&quot;definition#ODR-use&quot;&gt;использование ODR&lt;/a&gt; не чистой виртуальной функции-члена, которая может быть удалена, разрешено.</target>
        </trans-unit>
        <trans-unit id="a1b0da760b32f18ba3fc29ea2034487403e7abfa" translate="yes" xml:space="preserve">
          <source>. Each byte in memory has a unique</source>
          <target state="translated">, Каждый байт в памяти имеет уникальный</target>
        </trans-unit>
        <trans-unit id="5cddd5dfbecb9801772fe2221afa601ead96b52d" translate="yes" xml:space="preserve">
          <source>. Each concept is a predicate, evaluated at compile time, and becomes a part of the interface of a template where it is used as a constraint:</source>
          <target state="translated">, Каждая концепция является предикатом, оценивается во время компиляции и становится частью интерфейса шаблона, где она используется в качестве ограничения:</target>
        </trans-unit>
        <trans-unit id="33dec4f9c20f32729da42cd862630e951a31724b" translate="yes" xml:space="preserve">
          <source>. Each expression has some non-reference type, and each expression belongs to exactly one of the three primary value categories:</source>
          <target state="translated">, Каждое выражение имеет некоторый не ссылочный тип, и каждое выражение принадлежит ровно к одной из трех основных категорий значений:</target>
        </trans-unit>
        <trans-unit id="b705286f65efb9ff5d067129a4b52aa7b3a64f86" translate="yes" xml:space="preserve">
          <source>. Evaluation of the predicate must not have any side effects other than modification of non-volatile objects whose lifetimes begin and end within that evaluation; otherwise the behavior is undefined. If the evaluation of a predicate exits via an exception, &lt;code&gt;&lt;a href=&quot;../../error/terminate&quot;&gt;std::terminate&lt;/a&gt;&lt;/code&gt; is called.</source>
          <target state="translated">, Оценка предиката не должна иметь никаких побочных эффектов, кроме модификации нелетучих объектов, время жизни которых начинается и заканчивается в этой оценке; в противном случае поведение не определено. Если оценка предиката завершается через исключение, вызывается &lt;code&gt;&lt;a href=&quot;../../error/terminate&quot;&gt;std::terminate&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bdbadb9492e1aaa923f351b943afd53e801082db" translate="yes" xml:space="preserve">
          <source>. For example, &lt;code&gt;&quot;ch&quot;&lt;/code&gt; in Czech follows &lt;code&gt;&quot;h&quot;&lt;/code&gt; and precedes &lt;code&gt;&quot;i&quot;&lt;/code&gt;, and &lt;code&gt;&quot;dzs&quot;&lt;/code&gt; in Hungarian follows &lt;code&gt;&quot;dz&quot;&lt;/code&gt; and precedes &lt;code&gt;&quot;g&quot;&lt;/code&gt;.</source>
          <target state="translated">, Например, &lt;code&gt;&quot;ch&quot;&lt;/code&gt; на чешском языке следует за &lt;code&gt;&quot;h&quot;&lt;/code&gt; и предшествует &lt;code&gt;&quot;i&quot;&lt;/code&gt; , а &lt;code&gt;&quot;dzs&quot;&lt;/code&gt; на венгерском языке следует за &lt;code&gt;&quot;dz&quot;&lt;/code&gt; и предшествует &lt;code&gt;&quot;g&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d82d917e197ae463a094b584241f35f782aec1e5" translate="yes" xml:space="preserve">
          <source>. Four data models found wide acceptance:</source>
          <target state="translated">, Четыре модели данных нашли широкое признание:</target>
        </trans-unit>
        <trans-unit id="a33d10a95384cd1ea7eb9f897911c689939d7a04" translate="yes" xml:space="preserve">
          <source>. If &lt;code&gt;count1 &amp;gt; size() - pos1&lt;/code&gt; the first substring is &lt;code&gt;[pos1, size())&lt;/code&gt;. Likewise, &lt;code&gt;count2 &amp;gt; str.size() - pos2&lt;/code&gt; the second substring is &lt;code&gt;[pos2, str.size())&lt;/code&gt;.</source>
          <target state="translated">, Если &lt;code&gt;count1 &amp;gt; size() - pos1&lt;/code&gt; первая подстрока будет &lt;code&gt;[pos1, size())&lt;/code&gt; . Аналогично, &lt;code&gt;count2 &amp;gt; str.size() - pos2&lt;/code&gt; вторая подстрока - это &lt;code&gt;[pos2, str.size())&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="60d4561c4e6d1d28e7602ab1f96bac585b6ca3dc" translate="yes" xml:space="preserve">
          <source>. If &lt;code&gt;count1 &amp;gt; size() - pos1&lt;/code&gt; the substring is &lt;code&gt;[pos1, size())&lt;/code&gt;.</source>
          <target state="translated">, Если &lt;code&gt;count1 &amp;gt; size() - pos1&lt;/code&gt; подстрока будет &lt;code&gt;[pos1, size())&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b84f7bfde392ca0b0a0eb7c2fd807319d5660eee" translate="yes" xml:space="preserve">
          <source>. If a name has linkage, it refers to the same entity as the same name introduced by a declaration in another scope. If a variable, function, or another entity with the same name is declared in several scopes, but does not have sufficient linkage, then several instances of the entity are generated.</source>
          <target state="translated">, Если имя имеет связь, оно ссылается на ту же сущность, что и имя, введенное объявлением в другой области. Если переменная, функция или другой объект с тем же именем объявлен в нескольких областях, но не имеет достаточной связи, то генерируется несколько экземпляров объекта.</target>
        </trans-unit>
        <trans-unit id="68e5fa4e1855031b0502b2881746502d1ee32b93" translate="yes" xml:space="preserve">
          <source>. If an expression of class type is used where an integral constant expression is expected, the expression is &lt;a href=&quot;implicit_cast&quot;&gt;contextually implicitly converted&lt;/a&gt; to an integral or unscoped enumeration type.</source>
          <target state="translated">, Если выражение типа класса используется там, где ожидается целочисленное константное выражение, это выражение &lt;a href=&quot;implicit_cast&quot;&gt;контекстно неявно преобразуется&lt;/a&gt; в тип перечисления с целым числом или с незаданной областью.</target>
        </trans-unit>
        <trans-unit id="bf4f7b247734c7ffb151a9d2d9c1116744a29510" translate="yes" xml:space="preserve">
          <source>. If it is missing (and the first element other than the root name is a file name), then the path is</source>
          <target state="translated">, Если он отсутствует (и первым элементом, отличным от корневого имени, является имя файла), тогда путь</target>
        </trans-unit>
        <trans-unit id="3cdae61a821a7400c029c87da2e0ad8e4d9f82b6" translate="yes" xml:space="preserve">
          <source>. If new_type is (possibly &lt;a href=&quot;cv&quot;&gt;cv-qualified&lt;/a&gt;) &lt;code&gt;void&lt;/code&gt;, the expression is a void prvalue without a result object(since C++17).. This is the only cast expression that can create an &lt;a href=&quot;array#Array_rvalues&quot;&gt;array prvalue&lt;/a&gt;.</source>
          <target state="translated">, Если new_type является (возможно, &lt;a href=&quot;cv&quot;&gt;cv-qualified&lt;/a&gt; ) &lt;code&gt;void&lt;/code&gt; , выражение является vval prvalue без объекта результата (начиная с C ++ 17). Это единственное выражение приведения, которое может создать &lt;a href=&quot;array#Array_rvalues&quot;&gt;массив prvalue&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="77e403132e08047bd2d3bc12dda0f4a4a2d76de8" translate="yes" xml:space="preserve">
          <source>. If the character specified by a universal character name isn't a member of the execution character set, the result is implementation-defined, but is guaranteed not to be a null (wide) character.</source>
          <target state="translated">, Если символ, указанный универсальным именем символа, не является членом набора символов выполнения, результат определяется реализацией, но гарантированно не будет нулевым (широким) символом.</target>
        </trans-unit>
        <trans-unit id="2055582e493f90d8029965151d08ca03337c25b6" translate="yes" xml:space="preserve">
          <source>. In other words, class members in each of the three member access modes are positioned in memory in order of declaration.</source>
          <target state="translated">, Другими словами, члены класса в каждом из трех режимов доступа к элементам располагаются в памяти в порядке объявления.</target>
        </trans-unit>
        <trans-unit id="a005fba78ddbc77b4129b39813eedeab22a6e135" translate="yes" xml:space="preserve">
          <source>. In other words, they results of comparing the pointers is the same as the result of comparing the indexes of the elements they point to.</source>
          <target state="translated">, Другими словами, результаты сравнения указателей совпадают с результатами сравнения индексов элементов, на которые они указывают.</target>
        </trans-unit>
        <trans-unit id="99a683fd566c429de6986c8efcc6c2533955f501" translate="yes" xml:space="preserve">
          <source>. In particular, OS-dependent end-of-line indicators are replaced by newline characters. The</source>
          <target state="translated">, В частности, OS-зависимые индикаторы конца строки заменяются символами новой строки.</target>
        </trans-unit>
        <trans-unit id="2971dbfe9f7c9e49e1f8b10e03b7c5f6dac51f41" translate="yes" xml:space="preserve">
          <source>. Invoking the</source>
          <target state="translated">, Вызывая</target>
        </trans-unit>
        <trans-unit id="c1128618249b42b2681dcf948859823c7068abc2" translate="yes" xml:space="preserve">
          <source>. It is a form of &lt;a href=&quot;list_initialization&quot;&gt;list-initialization&lt;/a&gt;(since C++11) or &lt;a href=&quot;direct_initialization&quot;&gt;direct initialization&lt;/a&gt;(since C++20).</source>
          <target state="translated">, Это форма &lt;a href=&quot;list_initialization&quot;&gt;инициализации списка&lt;/a&gt; (начиная с C ++ 11) или &lt;a href=&quot;direct_initialization&quot;&gt;прямой инициализации&lt;/a&gt; (начиная с C ++ 20).</target>
        </trans-unit>
        <trans-unit id="356bc0604f7850722bb7374a264e1089f903613e" translate="yes" xml:space="preserve">
          <source>. It is implementation-defined if &lt;a href=&quot;new&quot;&gt;new-expression&lt;/a&gt;, &lt;code&gt;&lt;a href=&quot;../memory/allocator/allocate&quot;&gt;std::allocator::allocate&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;../memory/get_temporary_buffer&quot;&gt;std::get_temporary_buffer&lt;/a&gt;&lt;/code&gt; support over-aligned types. &lt;a href=&quot;../named_req/allocator&quot;&gt;Allocators&lt;/a&gt; instantiated with over-aligned types are allowed to fail to instantiate at compile time, to throw &lt;code&gt;&lt;a href=&quot;../memory/new/bad_alloc&quot;&gt;std::bad_alloc&lt;/a&gt;&lt;/code&gt; at runtime, to silently ignore unsupported alignment requirement, or to handle them correctly.</source>
          <target state="translated">, Это определяется реализацией, если &lt;a href=&quot;new&quot;&gt;new-expression&lt;/a&gt; , &lt;code&gt;&lt;a href=&quot;../memory/allocator/allocate&quot;&gt;std::allocator::allocate&lt;/a&gt;&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;../memory/get_temporary_buffer&quot;&gt;std::get_temporary_buffer&lt;/a&gt;&lt;/code&gt; и std :: get_teilitary_buffer поддерживают переопределенные типы. &lt;a href=&quot;../named_req/allocator&quot;&gt;Распределителям,&lt;/a&gt; созданным с использованием более выровненных типов, разрешается не создавать экземпляры во время компиляции, генерировать &lt;code&gt;&lt;a href=&quot;../memory/new/bad_alloc&quot;&gt;std::bad_alloc&lt;/a&gt;&lt;/code&gt; во время выполнения, молча игнорировать неподдерживаемые требования выравнивания или обрабатывать их правильно.</target>
        </trans-unit>
        <trans-unit id="ab7e947eb2a49ecc9700edf726245f07e8311cd4" translate="yes" xml:space="preserve">
          <source>. It is often used to provide an empty body to a &lt;a href=&quot;for&quot;&gt;for&lt;/a&gt; or &lt;a href=&quot;while&quot;&gt;while&lt;/a&gt; loop. It can also be used to carry a label in the end of a compound statement.</source>
          <target state="translated">, Он часто используется , чтобы обеспечить пустое тело к &lt;a href=&quot;for&quot;&gt;для&lt;/a&gt; или во &lt;a href=&quot;while&quot;&gt;время&lt;/a&gt; цикла. Его также можно использовать для переноса метки в конце составного оператора.</target>
        </trans-unit>
        <trans-unit id="ab056dbc0ad8ac12b777fec3697e10f3e1de1b4a" translate="yes" xml:space="preserve">
          <source>. It takes no arguments, returns void, and performs no action other than initial evaluation of &lt;code&gt;E1&lt;/code&gt;. This is the only case where the left-hand operand of &lt;code&gt;operator.&lt;/code&gt; has non-class type. Allowing pseudo destructor call makes it possible to write code without having to know if a destructor exists for a given type.</source>
          <target state="translated">, Он не принимает аргументов, возвращает void и не выполняет никаких действий, кроме начальной оценки &lt;code&gt;E1&lt;/code&gt; . Это единственный случай, когда левый операнд &lt;code&gt;operator.&lt;/code&gt; имеет неклассный тип. Разрешение вызова псевдо-деструктора позволяет писать код без необходимости знать, существует ли деструктор для данного типа.</target>
        </trans-unit>
        <trans-unit id="eef30cb415d5d8eda6e82cbfa234d079d7a185fc" translate="yes" xml:space="preserve">
          <source>. Language linkage encapsulates the set of requirements necessary to link with a module written in another programming language: &lt;a href=&quot;https://en.wikipedia.org/wiki/Calling_convention&quot;&gt;calling convention&lt;/a&gt;, &lt;a href=&quot;https://en.wikipedia.org/wiki/Name_mangling&quot;&gt;name mangling&lt;/a&gt; algorithm, etc.</source>
          <target state="translated">, Языковая связь заключает в себе набор требований, необходимых для связи с модулем, написанным на другом языке программирования: &lt;a href=&quot;https://en.wikipedia.org/wiki/Calling_convention&quot;&gt;соглашение о вызовах&lt;/a&gt; , алгоритм &lt;a href=&quot;https://en.wikipedia.org/wiki/Name_mangling&quot;&gt;искажения имени&lt;/a&gt; и т. Д.</target>
        </trans-unit>
        <trans-unit id="5e2ad60e04fa8a32b82dd4ab36a67fe1ce73577f" translate="yes" xml:space="preserve">
          <source>. Literal types are the types of &lt;a href=&quot;../language/constexpr&quot;&gt;constexpr variables&lt;/a&gt; and they can be constructed, manipulated, and returned from &lt;a href=&quot;../language/constexpr&quot;&gt;constexpr functions&lt;/a&gt;.</source>
          <target state="translated">, Литеральные типы - это типы &lt;a href=&quot;../language/constexpr&quot;&gt;переменных constexpr,&lt;/a&gt; и их можно создавать, обрабатывать и возвращать из &lt;a href=&quot;../language/constexpr&quot;&gt;функций constexpr&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3fd05493594e79b94be80621c509c9e737da3b3c" translate="yes" xml:space="preserve">
          <source>. No memory reads or writes in the current thread can be reordered before or after this store. All writes in other threads that release the same atomic variable are visible before the modification and the modification is visible in other threads that acquire the same atomic variable.</source>
          <target state="translated">, Никакие операции чтения или записи в памяти в текущем потоке не могут быть переупорядочены ни до, ни после этого хранилища. Все записи в других потоках, которые выпускают одну и ту же атомарную переменную, видны до модификации, а модификация видна в других потоках, которые получают ту же атомарную переменную.</target>
        </trans-unit>
        <trans-unit id="4043f50b8367eb4e26dc8f87a7a82decf69d22dd" translate="yes" xml:space="preserve">
          <source>. Objects of this type are &lt;a href=&quot;objects#Polymorphic_objects&quot;&gt;polymorphic objects&lt;/a&gt; and have runtime type information stored as part of the object representation, which may be queried with &lt;a href=&quot;dynamic_cast&quot;&gt;dynamic_cast&lt;/a&gt; and &lt;a href=&quot;typeid&quot;&gt;typeid&lt;/a&gt;. Virtual member functions participate in dynamic binding.</source>
          <target state="translated">, Объекты этого типа являются &lt;a href=&quot;objects#Polymorphic_objects&quot;&gt;полиморфными объектами&lt;/a&gt; и имеют информацию о типе среды выполнения, хранящуюся как часть представления объекта, которую можно запрашивать с помощью &lt;a href=&quot;dynamic_cast&quot;&gt;dynamic_cast&lt;/a&gt; и &lt;a href=&quot;typeid&quot;&gt;typeid&lt;/a&gt; . Виртуальные функции-участники участвуют в динамическом связывании.</target>
        </trans-unit>
        <trans-unit id="a9a5f93018a465748262f4fd922c0b10831e96e6" translate="yes" xml:space="preserve">
          <source>. Only then &lt;code&gt;std::feof&lt;/code&gt; returns non-zero.</source>
          <target state="translated">, Только тогда &lt;code&gt;std::feof&lt;/code&gt; возвращает ненулевое значение.</target>
        </trans-unit>
        <trans-unit id="2a930ffd122a65a9f25ff1e6d9f9938ba49636a8" translate="yes" xml:space="preserve">
          <source>. Otherwise the pointer value is unchanged. Conversion of any pointer to pointer to void and back to pointer to the original (or more cv-qualified) type preserves its original value.</source>
          <target state="translated">, В противном случае значение указателя не изменяется. Преобразование любого указателя на указатель на void и обратно на указатель на исходный (или более квалифицированный по cv) тип сохраняет свое первоначальное значение.</target>
        </trans-unit>
        <trans-unit id="f7c05934e49017a55ffd7f8db5e6be448b7c6949" translate="yes" xml:space="preserve">
          <source>. Otherwise, it is a</source>
          <target state="translated">, В противном случае это</target>
        </trans-unit>
        <trans-unit id="7d7ba1a37c76c90cfc05299fdb7d66d00cdf8dca" translate="yes" xml:space="preserve">
          <source>. Pointers to single objects are treated as pointers to arrays of one: &lt;code&gt;&amp;amp;obj+1&lt;/code&gt; compares greater than &lt;code&gt;&amp;amp;obj&lt;/code&gt;(since C++17)</source>
          <target state="translated">, Указатели на отдельные объекты обрабатываются как указатели на массивы из одного: &lt;code&gt;&amp;amp;obj+1&lt;/code&gt; сравнивает больше чем &lt;code&gt;&amp;amp;obj&lt;/code&gt; (начиная с C ++ 17)</target>
        </trans-unit>
        <trans-unit id="79ab5295086cf1cff1d188640da5082b74e6f20b" translate="yes" xml:space="preserve">
          <source>. Rounding to nearest representable value results in 0x1.999999999999a*2-4</source>
          <target state="translated">, Округление до ближайшего представимого значения приводит к 0x1.999999999999a * 2-4</target>
        </trans-unit>
        <trans-unit id="cbad6d2df5c35e8f921fcaa593ace506841238a7" translate="yes" xml:space="preserve">
          <source>. See &lt;a href=&quot;virtual&quot;&gt;virtual functions&lt;/a&gt; and &lt;a href=&quot;abstract_class&quot;&gt;abstract classes&lt;/a&gt; for details.</source>
          <target state="translated">, Смотрите &lt;a href=&quot;virtual&quot;&gt;виртуальные функции&lt;/a&gt; и &lt;a href=&quot;abstract_class&quot;&gt;абстрактные классы&lt;/a&gt; для деталей.</target>
        </trans-unit>
        <trans-unit id="1ac736feb756a0662765565c1ddf5c54714fbc2b" translate="yes" xml:space="preserve">
          <source>. That is, the last iterator &lt;code&gt;it&lt;/code&gt; for which range &lt;code&gt;[first, it)&lt;/code&gt; is a</source>
          <target state="translated">, То есть последний итератор &lt;code&gt;it&lt;/code&gt; для которого диапазон &lt;code&gt;[first, it)&lt;/code&gt; является</target>
        </trans-unit>
        <trans-unit id="3cb17b45da870b7ec9baaca006a81afb0e3f404f" translate="yes" xml:space="preserve">
          <source>. The function then searches from that point on for the first character that</source>
          <target state="translated">, Затем функция с этого момента ищет первый символ, который</target>
        </trans-unit>
        <trans-unit id="2923ece4a0bd3546cfdc4f62787758294b263ad1" translate="yes" xml:space="preserve">
          <source>. The function then searches from that point on for the first wide character that</source>
          <target state="translated">, Затем функция с этого момента ищет первый широкий символ, который</target>
        </trans-unit>
        <trans-unit id="61b94db5d99f08f0c694055d17375cb798fa4521" translate="yes" xml:space="preserve">
          <source>. The name</source>
          <target state="translated">, Имя</target>
        </trans-unit>
        <trans-unit id="85de12fb456918c6facd124a016788e336a84025" translate="yes" xml:space="preserve">
          <source>. The name can be referred to from all scopes in the current translation unit.</source>
          <target state="translated">, На имя можно ссылаться из всех областей текущего модуля перевода.</target>
        </trans-unit>
        <trans-unit id="f523417ea4918f53f6a9f95baf7712b34a86eae4" translate="yes" xml:space="preserve">
          <source>. The name can be referred to from the scopes in the other translation units. Variables and functions with external linkage also have &lt;a href=&quot;language_linkage&quot;&gt;language linkage&lt;/a&gt;, which makes it possible to link translation units written in different programming languages.</source>
          <target state="translated">, На имя можно ссылаться из областей в других единицах перевода. Переменные и функции с внешней связью также имеют &lt;a href=&quot;language_linkage&quot;&gt;языковые связи&lt;/a&gt; , что позволяет связывать единицы перевода, написанные на разных языках программирования.</target>
        </trans-unit>
        <trans-unit id="8a09d851d0a6928714c77e7574c1b6d959c9da3c" translate="yes" xml:space="preserve">
          <source>. The name can be referred to only from the scope it is in.</source>
          <target state="translated">, На имя можно ссылаться только из области, в которой оно находится.</target>
        </trans-unit>
        <trans-unit id="b998270ca375ea5551f58f59298525f0cd92ff73" translate="yes" xml:space="preserve">
          <source>. The name of such a class only exists within the function scope, and is not accessible outside.</source>
          <target state="translated">, Имя такого класса существует только в области действия функции и не доступно снаружи.</target>
        </trans-unit>
        <trans-unit id="3aca28dc5685eb1627cfa6227295b744c7c32887" translate="yes" xml:space="preserve">
          <source>. The parent directory can be represented by the relative pathname &lt;code&gt;&quot;..&quot;&lt;/code&gt;.</source>
          <target state="translated">, Родительский каталог может быть представлен относительным путем &lt;code&gt;&quot;..&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="af5191925264a6f1222eec36d0e558d7114acafb" translate="yes" xml:space="preserve">
          <source>. The point of declaration of the name is immediately following the opening brace of the class definition.</source>
          <target state="translated">, Точка объявления имени следует сразу за открывающей фигурной скобкой определения класса.</target>
        </trans-unit>
        <trans-unit id="d73ce905c7e8caed5bcf6a0c8b9740ee594fd215" translate="yes" xml:space="preserve">
          <source>. The syntax of the type-id that names type T is exactly the syntax of a &lt;a href=&quot;declarations&quot;&gt;declaration&lt;/a&gt; of a variable or function of type T, with the identifier omitted, except that</source>
          <target state="translated">, Синтаксис идентификатора типа, который именует тип T, является в точности синтаксисом &lt;a href=&quot;declarations&quot;&gt;объявления&lt;/a&gt; переменной или функции типа T с опущенным идентификатором, за исключением того, что</target>
        </trans-unit>
        <trans-unit id="0cd178f8d5684f66e16a2083635f91143d51a96e" translate="yes" xml:space="preserve">
          <source>. These attributes may be applied to the function type in a function declaration:</source>
          <target state="translated">, Эти атрибуты могут быть применены к типу функции в объявлении функции:</target>
        </trans-unit>
        <trans-unit id="e0b9b65bd5ab61cf0eba414c562588f6d88e9b46" translate="yes" xml:space="preserve">
          <source>. These include.</source>
          <target state="translated">, Это включает.</target>
        </trans-unit>
        <trans-unit id="9b6b8144c37744c4c78e2ca9a7775e22e96ba479" translate="yes" xml:space="preserve">
          <source>. This allows certain errors to be detected at the point of definition, rather than instantiation, and removes the requirement on the &lt;code&gt;typename&lt;/code&gt; and &lt;code&gt;template&lt;/code&gt; disambiguators for dependent names, see below.</source>
          <target state="translated">, Это позволяет обнаруживать определенные ошибки в точке определения, а не в момент создания экземпляра, и устраняет требование в отношении неоднозначности &lt;code&gt;typename&lt;/code&gt; и &lt;code&gt;template&lt;/code&gt; для зависимых имен, см. Ниже.</target>
        </trans-unit>
        <trans-unit id="844564e7cf1c47f7ea75e5e1bf440e8f19afffd2" translate="yes" xml:space="preserve">
          <source>. This allows more efficient implementation of &lt;code&gt;memory_order_acquire&lt;/code&gt; and &lt;code&gt;memory_order_release&lt;/code&gt; on some CPUs. It can produce surprising results when &lt;code&gt;memory_order_acquire&lt;/code&gt; and &lt;code&gt;memory_order_release&lt;/code&gt; are mixed with &lt;code&gt;memory_order_seq_cst&lt;/code&gt;.</source>
          <target state="translated">, Это обеспечивает более эффективную реализацию &lt;code&gt;memory_order_acquire&lt;/code&gt; и &lt;code&gt;memory_order_release&lt;/code&gt; на некоторых процессорах. Это может привести к неожиданным результатам, когда &lt;code&gt;memory_order_acquire&lt;/code&gt; и &lt;code&gt;memory_order_release&lt;/code&gt; смешаны с &lt;code&gt;memory_order_seq_cst&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c6ccbd031282697c64122e93a678f06f4c45fff4" translate="yes" xml:space="preserve">
          <source>. This constructor does not participate in overload resolution unless &lt;code&gt;&lt;a href=&quot;../../types/is_move_constructible&quot;&gt;std::is_move_constructible_v&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;. It is a trivial constructor if &lt;code&gt;&lt;a href=&quot;../../types/is_move_constructible&quot;&gt;std::is_trivially_move_constructible_v&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">, Этот конструктор не участвует в разрешении перегрузки, если только &lt;code&gt;&lt;a href=&quot;../../types/is_move_constructible&quot;&gt;std::is_move_constructible_v&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt; имеет значение &lt;code&gt;true&lt;/code&gt; . Это тривиальный конструктор, если &lt;code&gt;&lt;a href=&quot;../../types/is_move_constructible&quot;&gt;std::is_trivially_move_constructible_v&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt; имеет значение &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="732d85aea2bce0e040fb4cd1659b35c6d1bc3c4a" translate="yes" xml:space="preserve">
          <source>. This constructor is defined as deleted if &lt;code&gt;&lt;a href=&quot;../../types/is_copy_constructible&quot;&gt;std::is_copy_constructible_v&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;. It is a trivial constructor if &lt;code&gt;&lt;a href=&quot;../../types/is_copy_constructible&quot;&gt;std::is_trivially_copy_constructible_v&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">, Этот конструктор определяется как удаленный, если &lt;code&gt;&lt;a href=&quot;../../types/is_copy_constructible&quot;&gt;std::is_copy_constructible_v&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt; имеет значение &lt;code&gt;false&lt;/code&gt; . Это &lt;code&gt;&lt;a href=&quot;../../types/is_copy_constructible&quot;&gt;std::is_trivially_copy_constructible_v&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt; конструктор, если std :: is_trivially_copy_constructible_v &amp;lt;T&amp;gt; имеет значение &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="026c3d7e9a1fe8d5a967d61011a3beec752b15fd" translate="yes" xml:space="preserve">
          <source>. This distribution is used when estimating the</source>
          <target state="translated">, Это распределение используется при оценке</target>
        </trans-unit>
        <trans-unit id="b316862e19fe4e350514297be86c991beb03e9ba" translate="yes" xml:space="preserve">
          <source>. This downcast is ill-formed if &lt;code&gt;B&lt;/code&gt; is ambiguous, inaccessible, or virtual base (or a base of a virtual base) of &lt;code&gt;D&lt;/code&gt;. Such &lt;code&gt;static_cast&lt;/code&gt; makes no runtime checks to ensure that the object's runtime type is actually &lt;code&gt;D&lt;/code&gt;, and may only be used safely if this precondition is guaranteed by other means, such as when implementing &lt;a href=&quot;https://en.wikipedia.org/wiki/Curiously_recurring_template_pattern#Static_polymorphism&quot;&gt;static polymorphism&lt;/a&gt;. Safe downcast may be done with &lt;a href=&quot;dynamic_cast&quot;&gt;&lt;code&gt;dynamic_cast&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">, Это опущенный плохо сформированный , если &lt;code&gt;B&lt;/code&gt; является неоднозначным, недоступным, или виртуальным базовым (или базовым виртуальной базой) из &lt;code&gt;D&lt;/code&gt; . Такой &lt;code&gt;static_cast&lt;/code&gt; не проверяет во время выполнения, чтобы гарантировать, что тип времени выполнения объекта на самом деле является &lt;code&gt;D&lt;/code&gt; , и может безопасно использоваться только в том случае, если это предварительное условие гарантировано другими средствами, например, при реализации &lt;a href=&quot;https://en.wikipedia.org/wiki/Curiously_recurring_template_pattern#Static_polymorphism&quot;&gt;статического полиморфизма&lt;/a&gt; . Безопасное снижение может быть сделано с помощью &lt;a href=&quot;dynamic_cast&quot;&gt; &lt;code&gt;dynamic_cast&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b398f2ef722f3eef80e8eb8655b49aa4fcb0fcec" translate="yes" xml:space="preserve">
          <source>. This has the effect of removing the first (largest) element from the heap defined by the range &lt;code&gt;[first, last)&lt;/code&gt;.</source>
          <target state="translated">, Это приводит к удалению первого (самого большого) элемента из кучи, определенной диапазоном &lt;code&gt;[first, last)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="23e6923e524364fd639ec62ad6d11c97fd7da1cf" translate="yes" xml:space="preserve">
          <source>. Two types are covariant if they satisfy all of the following requirements:</source>
          <target state="translated">, Два типа являются ковариантными, если они удовлетворяют всем следующим требованиям:</target>
        </trans-unit>
        <trans-unit id="a9b5d1fd23fc7c5b4e6066615fc95994a5d113ca" translate="yes" xml:space="preserve">
          <source>. init-declarator-list is optional when declaring a named class/struct/union or a named enumeration</source>
          <target state="translated">, init-декларатор-список является необязательным при объявлении именованного класса / структуры / объединения или именованного перечисления</target>
        </trans-unit>
        <trans-unit id="e996ce306a5268a292c41ab30ab0b1d4f7db02b0" translate="yes" xml:space="preserve">
          <source>. where S is the sum of all weights.</source>
          <target state="translated">, где S - сумма всех весов.</target>
        </trans-unit>
        <trans-unit id="9786fc35b53afb831a179c1e43a95571ec28165a" translate="yes" xml:space="preserve">
          <source>.(since C++14)</source>
          <target state="translated">. (начиная с C ++ 14)</target>
        </trans-unit>
        <trans-unit id="6eae3a5b062c6d0d79f070c26e6d62486b40cb46" translate="yes" xml:space="preserve">
          <source>...</source>
          <target state="translated">...</target>
        </trans-unit>
        <trans-unit id="faffb901ea5e603d448d5c651bc2ce1feb7ab56d" translate="yes" xml:space="preserve">
          <source>...Ints</source>
          <target state="translated">...Ints</target>
        </trans-unit>
        <trans-unit id="f29a917fc93c5cb1d8973220b883033399f48be1" translate="yes" xml:space="preserve">
          <source>...Ts</source>
          <target state="translated">...Ts</target>
        </trans-unit>
        <trans-unit id="e5f0d5fb385bca81078ad2a8707bbb8625cae265" translate="yes" xml:space="preserve">
          <source>...unless the parameter was expanded from a parameter pack</source>
          <target state="translated">... если параметр не был расширен из пакета параметров</target>
        </trans-unit>
        <trans-unit id="19f7ec135b5a79de79d6e7cc40d22413fe2af23d" translate="yes" xml:space="preserve">
          <source>/* implementation-defined */</source>
          <target state="translated">/ * определяется реализацией * /</target>
        </trans-unit>
        <trans-unit id="1ac5a1a38af02527751fd769c995e2b77199e5bf" translate="yes" xml:space="preserve">
          <source>/* non-specialized */</source>
          <target state="translated">/ * неспециализированная * /</target>
        </trans-unit>
        <trans-unit id="3555c1ad8bfe63c321204c247721dcd8a380c1e1" translate="yes" xml:space="preserve">
          <source>/* proxy */</source>
          <target state="translated">/ * прокси * /</target>
        </trans-unit>
        <trans-unit id="a269eaf502d0961ec13dad33647c50aef6df1f0b" translate="yes" xml:space="preserve">
          <source>/* unspecified */</source>
          <target state="translated">/* неопределенные */</target>
        </trans-unit>
        <trans-unit id="b6589fc6ab0dc82cf12099d1c2d40ab994e8410c" translate="yes" xml:space="preserve">
          <source>0</source>
          <target state="translated">0</target>
        </trans-unit>
        <trans-unit id="3e51cc904afd7e59e35c80a6ddcf5cd8135109f4" translate="yes" xml:space="preserve">
          <source>0 and the rest are initialized iteratively, for i=1-n,...,-1, each X</source>
          <target state="translated">0,а остальные инициализируются итеративно,для i=1-n,...,-1,каждый X.</target>
        </trans-unit>
        <trans-unit id="a234edb1dd1ba7b125c0f9eacd66f79c2ee53496" translate="yes" xml:space="preserve">
          <source>0 are zero, and if all other X</source>
          <target state="translated">0-ноль,и если все остальные Х</target>
        </trans-unit>
        <trans-unit id="cbdfc7a60b2a1b991b37673e31df028f7727131b" translate="yes" xml:space="preserve">
          <source>0 if for each &lt;code&gt;i&lt;/code&gt; in &lt;code&gt;[0,n)&lt;/code&gt;, &lt;code&gt;X​::​eq(p[i], q[i])&lt;/code&gt; is true</source>
          <target state="translated">0 , если для каждого &lt;code&gt;i&lt;/code&gt; в &lt;code&gt;[0,n)&lt;/code&gt; , &lt;code&gt;X​::​eq(p[i], q[i])&lt;/code&gt; верно</target>
        </trans-unit>
        <trans-unit id="a385b6d4430ed31871595e71093124d9e635d5b3" translate="yes" xml:space="preserve">
          <source>0 with 2w-1</source>
          <target state="translated">0 с 2w-1</target>
        </trans-unit>
        <trans-unit id="a0bd242d4e9823dde121cf81241caa8cb18b052a" translate="yes" xml:space="preserve">
          <source>0&amp;ndash;8</source>
          <target state="translated">0&amp;ndash;8</target>
        </trans-unit>
        <trans-unit id="a8df62a2404776e4a9f650425f66aba3e1c6eafd" translate="yes" xml:space="preserve">
          <source>0&amp;radic;1-k2</source>
          <target state="translated">0&amp;radic;1-k2</target>
        </trans-unit>
        <trans-unit id="b7a2c9b34dc2f4bec112398ca4ad2750f1912a7c" translate="yes" xml:space="preserve">
          <source>0,...,P</source>
          <target state="translated">0,...,P</target>
        </trans-unit>
        <trans-unit id="2bd186dce3970b7834f34e8ecaf95f82ee6270fe" translate="yes" xml:space="preserve">
          <source>0-qualified pointer to cv1</source>
          <target state="translated">0-квалифицированный указатель на cv1</target>
        </trans-unit>
        <trans-unit id="fe1e007660532039a2e8edd7bcd53a0d3a1d5908" translate="yes" xml:space="preserve">
          <source>0-qualified pointer to cv2</source>
          <target state="translated">0-квалифицированный указатель на cv2</target>
        </trans-unit>
        <trans-unit id="7abe581e3bbbaa5fdd179596f8a0dc409c4c5006" translate="yes" xml:space="preserve">
          <source>0tx-1</source>
          <target state="translated">0tx-1</target>
        </trans-unit>
        <trans-unit id="356a192b7913b04c54574d18c28d46e6395428ab" translate="yes" xml:space="preserve">
          <source>1</source>
          <target state="translated">1</target>
        </trans-unit>
        <trans-unit id="6811f7a8f41e917fb0d97233a1567d9f7103a1c6" translate="yes" xml:space="preserve">
          <source>1 &amp;lt; K+1 = M &amp;le; N</source>
          <target state="translated">1 &amp;lt;K + 1 = M &amp;le; N</target>
        </trans-unit>
        <trans-unit id="f785463204330c080875e98ef24f1d1d3a6bddb4" translate="yes" xml:space="preserve">
          <source>1 &amp;minus; p if &lt;code&gt;b == false&lt;/code&gt;</source>
          <target state="translated">1 - p, если &lt;code&gt;b == false&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1948bd668a05b546ade4e87c5dc1e44b28d6388d" translate="yes" xml:space="preserve">
          <source>1 if the first string is greater than the second (that is, follows the second in the collation order), -1 if the first string is less than the second (precedes the second in the collation order), zero if the two strings are equivalent.</source>
          <target state="translated">1,если первая строка больше второй (то есть следует за второй в порядке считывания),-1,если первая строка меньше второй (предшествует второй в порядке считывания),-ноль,если две строки эквивалентны.</target>
        </trans-unit>
        <trans-unit id="47b4d0a7e4e7a4b47f71461424c2bc278b9cf1bf" translate="yes" xml:space="preserve">
          <source>1 op (... op (E</source>
          <target state="translated">1 на ...на (E</target>
        </trans-unit>
        <trans-unit id="86fb1242522651d4f696d9af9c16480d53bf7888" translate="yes" xml:space="preserve">
          <source>1 op E</source>
          <target state="translated">1 на Е</target>
        </trans-unit>
        <trans-unit id="7856021a1dd28ad72b926a915ecc0aad8c99768f" translate="yes" xml:space="preserve">
          <source>1) (deprecated in C++17) If &lt;code&gt;F&lt;/code&gt; is a pointer to function or a pointer to member function, &lt;code&gt;result_type&lt;/code&gt; is the return type of &lt;code&gt;F&lt;/code&gt;. If &lt;code&gt;F&lt;/code&gt; is a class type with nested typedef &lt;code&gt;result_type&lt;/code&gt;, then &lt;code&gt;result_type&lt;/code&gt; is &lt;code&gt;F::result_type&lt;/code&gt;. Otherwise no &lt;code&gt;result_type&lt;/code&gt; is defined.</source>
          <target state="translated">1) (устаревшее в C ++ 17) Если &lt;code&gt;F&lt;/code&gt; представляет собой указатель на функцию или указатель на функцию - член, &lt;code&gt;result_type&lt;/code&gt; является тип возвращаемого &lt;code&gt;F&lt;/code&gt; . Если &lt;code&gt;F&lt;/code&gt; является типом класса с вложенным typedef &lt;code&gt;result_type&lt;/code&gt; , тогда &lt;code&gt;result_type&lt;/code&gt; является &lt;code&gt;F::result_type&lt;/code&gt; . В противном случае &lt;code&gt;result_type&lt;/code&gt; не определен.</target>
        </trans-unit>
        <trans-unit id="83ea50c76bc44cdd9e4f766c317db5c2037df0e1" translate="yes" xml:space="preserve">
          <source>1) (none)</source>
          <target state="translated">1)(нет)</target>
        </trans-unit>
        <trans-unit id="86452ff75dcaffc8160d808ad365b65ef26fd4f4" translate="yes" xml:space="preserve">
          <source>1) (none)  2).</source>
          <target state="translated">1)(нет)2).</target>
        </trans-unit>
        <trans-unit id="34a572a24e5822c38c6b3ac46db113826995572c" translate="yes" xml:space="preserve">
          <source>1) &lt;code&gt;CT(lhs).count() == CT(rhs).count()&lt;/code&gt;.</source>
          <target state="translated">1) &lt;code&gt;CT(lhs).count() == CT(rhs).count()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a6a38143daa43b50349154fefdef085b81c3ad69" translate="yes" xml:space="preserve">
          <source>1) &lt;code&gt;U&amp;amp;&lt;/code&gt; if &lt;code&gt;T&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;reference_wrapper&quot;&gt;std::reference_wrapper&lt;/a&gt;&amp;lt;U&amp;gt;&lt;/code&gt;; &lt;code&gt;T&lt;/code&gt; otherwise.</source>
          <target state="translated">1) &lt;code&gt;U&amp;amp;&lt;/code&gt; если &lt;code&gt;T&lt;/code&gt; является &lt;code&gt;&lt;a href=&quot;reference_wrapper&quot;&gt;std::reference_wrapper&lt;/a&gt;&amp;lt;U&amp;gt;&lt;/code&gt; ; &lt;code&gt;T&lt;/code&gt; иначе.</target>
        </trans-unit>
        <trans-unit id="356a0877a891d6c9b60ef01cb7aaa9edeed1d1b1" translate="yes" xml:space="preserve">
          <source>1) &lt;code&gt;os&lt;/code&gt;.</source>
          <target state="translated">1) &lt;code&gt;os&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c22d94e3201de96926713e0b0f3b78a82a762b89" translate="yes" xml:space="preserve">
          <source>1) &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;other&lt;/code&gt; is a copy of &lt;code&gt;*this&lt;/code&gt; or has an identical name, &lt;code&gt;false&lt;/code&gt; otherwise.</source>
          <target state="translated">1) &lt;code&gt;true&lt;/code&gt; , если &lt;code&gt;other&lt;/code&gt; является копией &lt;code&gt;*this&lt;/code&gt; или имеет идентичное имя, иначе &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d6622eb011b611aae7e8c72a24755377368ad3a3" translate="yes" xml:space="preserve">
          <source>1) &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;std::get&amp;lt;i&amp;gt;(lhs) == std::get&amp;lt;i&amp;gt;(rhs)&lt;/code&gt; for all i in &lt;code&gt;[0, sizeof...(Types))&lt;/code&gt;, otherwise &lt;code&gt;false&lt;/code&gt;. For two empty tuples returns &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">1) &lt;code&gt;true&lt;/code&gt; , если &lt;code&gt;std::get&amp;lt;i&amp;gt;(lhs) == std::get&amp;lt;i&amp;gt;(rhs)&lt;/code&gt; для всех i в &lt;code&gt;[0, sizeof...(Types))&lt;/code&gt; , иначе &lt;code&gt;false&lt;/code&gt; . Для двух пустых кортежей возвращается &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="287dd3f95063f279870312b22bda28b87cd0fd6d" translate="yes" xml:space="preserve">
          <source>1) &lt;code&gt;true&lt;/code&gt; if both &lt;code&gt;lhs.first == rhs.first&lt;/code&gt; and &lt;code&gt;lhs.second == rhs.second&lt;/code&gt;, otherwise &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">1) &lt;code&gt;true&lt;/code&gt; , если оба параметра &lt;code&gt;lhs.first == rhs.first&lt;/code&gt; и &lt;code&gt;lhs.second == rhs.second&lt;/code&gt; , в противном случае - &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="27a520d2b54a1f6646b3759539dd07d9fa75978e" translate="yes" xml:space="preserve">
          <source>1) &lt;code&gt;true&lt;/code&gt; if the distribution objects are equal, &lt;code&gt;false&lt;/code&gt; otherwise.</source>
          <target state="translated">1) &lt;code&gt;true&lt;/code&gt; если объекты распределения равны, &lt;code&gt;false&lt;/code&gt; противном случае.</target>
        </trans-unit>
        <trans-unit id="1288e43751f25875bb27e07c4078a20e14710ced" translate="yes" xml:space="preserve">
          <source>1) &lt;code&gt;true&lt;/code&gt; if the underlying &lt;code&gt;&lt;a href=&quot;../type_info&quot;&gt;std::type_info&lt;/a&gt;&lt;/code&gt; objects refer to the same type, &lt;code&gt;false&lt;/code&gt; otherwise.</source>
          <target state="translated">1) &lt;code&gt;true&lt;/code&gt; , если базовые объекты &lt;code&gt;&lt;a href=&quot;../type_info&quot;&gt;std::type_info&lt;/a&gt;&lt;/code&gt; ссылаются на один и тот же тип, в противном случае - &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="104870c8f3088e1326f88bd2c5413aebdc6b362c" translate="yes" xml:space="preserve">
          <source>1) &lt;code&gt;true&lt;/code&gt; if the value of each bit in &lt;code&gt;*this&lt;/code&gt; equals the value of the corresponding bit in &lt;code&gt;rhs&lt;/code&gt;, otherwise &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">1) &lt;code&gt;true&lt;/code&gt; , если значение каждого бита в &lt;code&gt;*this&lt;/code&gt; равно значению соответствующего бита в &lt;code&gt;rhs&lt;/code&gt; , в противном случае - &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f71bf93702e13dec1d236cb721728da440f6f871" translate="yes" xml:space="preserve">
          <source>1) &lt;code&gt;x.get() == y.get()&lt;/code&gt;.</source>
          <target state="translated">1) &lt;code&gt;x.get() == y.get()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="11d9b8b52ebd3e1a3a024e6ccd57926c21a2e926" translate="yes" xml:space="preserve">
          <source>1) &lt;code&gt;​0​&lt;/code&gt; on success, non-zero otherwise.</source>
          <target state="translated">1) &lt;code&gt;​0​&lt;/code&gt; в случае успеха, не ноль в противном случае.</target>
        </trans-unit>
        <trans-unit id="6a3ae1acf7b6dec0a07ba83e824584db212e3584" translate="yes" xml:space="preserve">
          <source>1) A</source>
          <target state="translated">1)A</target>
        </trans-unit>
        <trans-unit id="20fbef856206918a3d8fb45dbe16ba8dc8b0ab41" translate="yes" xml:space="preserve">
          <source>1) A &lt;code&gt;std::chrono::sys_info&lt;/code&gt; structure &lt;code&gt;i&lt;/code&gt; containing the time zone information in effect for this time zone at the time point &lt;code&gt;tp&lt;/code&gt;. &lt;code&gt;tp&lt;/code&gt; will be in the range &lt;code&gt;[i.begin, i.end)&lt;/code&gt;.</source>
          <target state="translated">1) Структура &lt;code&gt;std::chrono::sys_info&lt;/code&gt; &lt;code&gt;i&lt;/code&gt; , содержащая информацию о часовом поясе, действующую для этого часового пояса в момент времени &lt;code&gt;tp&lt;/code&gt; . &lt;code&gt;tp&lt;/code&gt; будет в диапазоне &lt;code&gt;[i.begin, i.end)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d73fc0de5837fb35ed94e495176a1ab53919bb87" translate="yes" xml:space="preserve">
          <source>1) A &lt;code&gt;sys_time&lt;/code&gt; representing the same point in time as the argument.</source>
          <target state="translated">1) &lt;code&gt;sys_time&lt;/code&gt; , представляющее тот же момент времени, что и аргумент.</target>
        </trans-unit>
        <trans-unit id="cabaf2c8fe8bd5c8a1098bdc266583d59f4973d7" translate="yes" xml:space="preserve">
          <source>1) A &lt;code&gt;utc_time&lt;/code&gt; representing the same point in time as the argument.</source>
          <target state="translated">1) &lt;code&gt;utc_time&lt;/code&gt; , представляющий тот же момент времени, что и аргумент.</target>
        </trans-unit>
        <trans-unit id="b8328f6a84aae122e8939d2fec2a952c6930f619" translate="yes" xml:space="preserve">
          <source>1) A is</source>
          <target state="translated">1)А есть</target>
        </trans-unit>
        <trans-unit id="5f587efae23c247ca28924e943089a9746064083" translate="yes" xml:space="preserve">
          <source>1) A is a modification, and B reads the value stored by A 2) A precedes B in the</source>
          <target state="translated">1)А является модификацией,и В считывает значение,сохраненное в А 2)А предшествует В в</target>
        </trans-unit>
        <trans-unit id="2dbafc39b4109d874a6ef2cacd1b60fbe55da610" translate="yes" xml:space="preserve">
          <source>1) A non-type template parameter pack with an optional name</source>
          <target state="translated">1)Пакет нетиповых шаблонных параметров с дополнительным именем.</target>
        </trans-unit>
        <trans-unit id="af46537a854cfc07af90d00edb90238c2ee6d6fd" translate="yes" xml:space="preserve">
          <source>1) A non-type template parameter with an optional name.</source>
          <target state="translated">1)Не типовой параметр шаблона с дополнительным именем.</target>
        </trans-unit>
        <trans-unit id="4fe90bdfc834565a8e6349626f28a49a60b68cd0" translate="yes" xml:space="preserve">
          <source>1) A performs a</source>
          <target state="translated">1)А выполняет</target>
        </trans-unit>
        <trans-unit id="fbc6fe14c6af3cf8418f033f94d06174d8d80ddb" translate="yes" xml:space="preserve">
          <source>1) A range adaptor that produces a &lt;a href=&quot;view&quot;&gt;&lt;code&gt;View&lt;/code&gt;&lt;/a&gt; of no elements of a particular type.</source>
          <target state="translated">1) Адаптер диапазона, который создает &lt;a href=&quot;view&quot;&gt; &lt;code&gt;View&lt;/code&gt; &lt;/a&gt; без элементов определенного типа.</target>
        </trans-unit>
        <trans-unit id="0b9ae19f16d299250d9ad0aaf00550a8d1c41fae" translate="yes" xml:space="preserve">
          <source>1) A range adaptor that represents &lt;a href=&quot;view&quot;&gt;&lt;code&gt;View&lt;/code&gt;&lt;/a&gt; of an underlying sequence without the elements that fail to satisfy a predicate.</source>
          <target state="translated">1) Адаптер диапазон , который представляет собой &lt;a href=&quot;view&quot;&gt; &lt;code&gt;View&lt;/code&gt; &lt;/a&gt; лежащую в основе последовательности без элементов , которые не удовлетворяют предикат.</target>
        </trans-unit>
        <trans-unit id="b9956ba464175b6f57bff8b5d832269a811d8115" translate="yes" xml:space="preserve">
          <source>1) A range factory that generates a sequence of elements by repeatedly incrementing an initial value. Can be both bounded and unbounded (infinite)</source>
          <target state="translated">1)Завод-изготовитель диапазона,который генерирует последовательность элементов,многократно увеличивая начальное значение.Может быть как ограниченным,так и неограниченным (бесконечным).</target>
        </trans-unit>
        <trans-unit id="fe4686de1a7da6422a6cf066a0610a3a80118153" translate="yes" xml:space="preserve">
          <source>1) A reference to the global &lt;code&gt;std::chrono::tzdb_list&lt;/code&gt; singleton.</source>
          <target state="translated">1) Ссылка на глобальный синглтон &lt;code&gt;std::chrono::tzdb_list&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="82947af8d2369ef592a5e98e3d4604eb5d6af50d" translate="yes" xml:space="preserve">
          <source>1) A set of</source>
          <target state="translated">1)комплект</target>
        </trans-unit>
        <trans-unit id="a299040649a8f9f824a466b99cd8accb4069fd60" translate="yes" xml:space="preserve">
          <source>1) A span constructed with &lt;code&gt;{reinterpret_cast&amp;lt;const &lt;a href=&quot;../../types/byte&quot;&gt;std::byte&lt;/a&gt;*&amp;gt;(s.data()), s.size_bytes()}&lt;/code&gt;.</source>
          <target state="translated">1) &lt;code&gt;{reinterpret_cast&amp;lt;const &lt;a href=&quot;../../types/byte&quot;&gt;std::byte&lt;/a&gt;*&amp;gt;(s.data()), s.size_bytes()}&lt;/code&gt; с помощью {reinterpret_cast &amp;lt;const &lt;a href=&quot;../../types/byte&quot;&gt;std :: byte&lt;/a&gt; *&amp;gt; (s.data ()), s.size_bytes ()} .</target>
        </trans-unit>
        <trans-unit id="424f7940a81075143bd01c42816d096ec4cc3e70" translate="yes" xml:space="preserve">
          <source>1) A standard conversion sequence is always</source>
          <target state="translated">1)Стандартная последовательность преобразования всегда</target>
        </trans-unit>
        <trans-unit id="a46604118cc45bb8f1fc823ba39ae021f0682a23" translate="yes" xml:space="preserve">
          <source>1) A string object holding a copy of this buffer's underlying character sequence.</source>
          <target state="translated">1)Строковый объект,содержащий копию последовательности символов,лежащих в основе этого буфера.</target>
        </trans-unit>
        <trans-unit id="46e69a24f3f32aa99efec236d8f802a03d6df127" translate="yes" xml:space="preserve">
          <source>1) A template template parameter with an optional name.</source>
          <target state="translated">1)Параметр шаблона с дополнительным именем.</target>
        </trans-unit>
        <trans-unit id="bf76071f8f71da36945babb431edddf84fe21626" translate="yes" xml:space="preserve">
          <source>1) A type alias declaration introduces a name which can be used as a synonym for the type denoted by type-id. It does not introduce a new type and it cannot change the meaning of an existing type name. There is no difference between a type alias declaration and &lt;a href=&quot;typedef&quot;&gt;typedef&lt;/a&gt; declaration. This declaration may appear in block scope, class scope, or namespace scope.</source>
          <target state="translated">1) Объявление псевдонима типа вводит имя, которое может использоваться в качестве синонима для типа, обозначаемого type-id. Он не вводит новый тип и не может изменить значение имени существующего типа. Нет разницы между объявлением псевдонима типа и объявлением &lt;a href=&quot;typedef&quot;&gt;typedef&lt;/a&gt; . Это объявление может появляться в области блока, области класса или области пространства имен.</target>
        </trans-unit>
        <trans-unit id="d39d12e44cd655e37c42c123e3133548497ae9ed" translate="yes" xml:space="preserve">
          <source>1) A type template parameter without a default.</source>
          <target state="translated">1)Параметр шаблона типа без значения по умолчанию.</target>
        </trans-unit>
        <trans-unit id="173390dfcc7b8ee2a586fea4454de09b477814e3" translate="yes" xml:space="preserve">
          <source>1) Accesses (reads and writes) to &lt;a href=&quot;cv&quot;&gt;volatile&lt;/a&gt; objects occur strictly according to the semantics of the expressions in which they occur. In particular, they are &lt;a href=&quot;../atomic/memory_order&quot;&gt;not reordered&lt;/a&gt; with respect to other volatile accesses on the same thread.</source>
          <target state="translated">1) Доступ (чтение и запись) к &lt;a href=&quot;cv&quot;&gt;изменчивым&lt;/a&gt; объектам происходит строго в соответствии с семантикой выражений, в которых они встречаются. В частности, они &lt;a href=&quot;../atomic/memory_order&quot;&gt;не переупорядочены&lt;/a&gt; относительно других изменчивых обращений в том же потоке.</target>
        </trans-unit>
        <trans-unit id="82db348ccd128d42ca8c97273d60b073e85127a3" translate="yes" xml:space="preserve">
          <source>1) All characters in &lt;a href=&quot;character_literal&quot;&gt;character literals&lt;/a&gt; and &lt;a href=&quot;string_literal&quot;&gt;string literals&lt;/a&gt; are converted from the source character set to the</source>
          <target state="translated">1) Все символы в &lt;a href=&quot;character_literal&quot;&gt;символьных литералах&lt;/a&gt; и &lt;a href=&quot;string_literal&quot;&gt;строковых литералах&lt;/a&gt; преобразуются из исходного набора символов в</target>
        </trans-unit>
        <trans-unit id="66bfdbf9083c74e9a1866c3e2e464fc8189cefc5" translate="yes" xml:space="preserve">
          <source>1) All memory allocations are performed by &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">1) Все выделения памяти выполняется . &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="048a26efa0caafdd751840d3dafcd66eba62dbea" translate="yes" xml:space="preserve">
          <source>1) Amortized constant</source>
          <target state="translated">1)Амортизированная константа</target>
        </trans-unit>
        <trans-unit id="5981b7305017c9545a89a5a35fe66de383130acf" translate="yes" xml:space="preserve">
          <source>1) An expression of integral, enumeration, pointer, or pointer-to-member type can be converted to its own type. The resulting value is the same as the value of &lt;code&gt;expression&lt;/code&gt;. (since C++11)</source>
          <target state="translated">1) Выражение типа целого, перечисления, указателя или указателя на член может быть преобразовано в его собственный тип. Полученное значение совпадает со значением &lt;code&gt;expression&lt;/code&gt; . (начиная с C ++ 11)</target>
        </trans-unit>
        <trans-unit id="95cffb88bccbe314e1530157850332433d961b24" translate="yes" xml:space="preserve">
          <source>1) An implementation-defined type that holds a reference to &lt;code&gt;*this&lt;/code&gt;</source>
          <target state="translated">1) Определенный реализацией тип, который содержит ссылку на &lt;code&gt;*this&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="66c9b9f664df38161f10437106d4643e64c7e947" translate="yes" xml:space="preserve">
          <source>1) An object of class &lt;code&gt;any&lt;/code&gt; stores an instance of any type that satisfies the constructor requirements or is empty, and this is referred to as the</source>
          <target state="translated">1) Объект класса &lt;code&gt;any&lt;/code&gt; хранит экземпляр любого типа, который удовлетворяет требованиям конструктора или является пустым, и это называется</target>
        </trans-unit>
        <trans-unit id="61dc882dd7d34d7d4ad75d6cb735240681e1867e" translate="yes" xml:space="preserve">
          <source>1) Analyzes generic range &lt;code&gt;[first,last)&lt;/code&gt;. Match results are returned in &lt;code&gt;m&lt;/code&gt;.</source>
          <target state="translated">1) Анализирует общий диапазон &lt;code&gt;[first,last)&lt;/code&gt; . Результаты матчей возвращаются в &lt;code&gt;m&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="80ba3076eb89d7a3ef079f9e8618c645e77976f7" translate="yes" xml:space="preserve">
          <source>1) Appends &lt;code&gt;count&lt;/code&gt; copies of character &lt;code&gt;ch&lt;/code&gt;</source>
          <target state="translated">1) Добавляет &lt;code&gt;count&lt;/code&gt; копий символа &lt;code&gt;ch&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0f4fd2232e22aac2b19529e6e3b82510ab23c6ef" translate="yes" xml:space="preserve">
          <source>1) Applies the given function object &lt;code&gt;f&lt;/code&gt; to the result of dereferencing every iterator in the range &lt;code&gt;[first, first + n)&lt;/code&gt;, in order.</source>
          <target state="translated">1) Применяет данный функциональный объект &lt;code&gt;f&lt;/code&gt; к результату разыменования каждого итератора в диапазоне &lt;code&gt;[first, first + n)&lt;/code&gt; , по порядку.</target>
        </trans-unit>
        <trans-unit id="9326d78a127c522e3d8f1f7afedde286e2d81452" translate="yes" xml:space="preserve">
          <source>1) Applies the given function object &lt;code&gt;f&lt;/code&gt; to the result of dereferencing every iterator in the range &lt;code&gt;[first, last)&lt;/code&gt;, in order.</source>
          <target state="translated">1) Применяет данный функциональный объект &lt;code&gt;f&lt;/code&gt; к результату разыменования каждого итератора в диапазоне &lt;code&gt;[first, last)&lt;/code&gt; , по порядку.</target>
        </trans-unit>
        <trans-unit id="a269e932f278e6dc2ae1bfe911e2855a58c5ae13" translate="yes" xml:space="preserve">
          <source>1) Applies the language specification string-literal to all function types, function names with external linkage and variables with external linkage declared in declaration-seq.</source>
          <target state="translated">1)Применяет строково-литеральную спецификацию языка ко всем типам функций,именам функций с внешней связью и переменным с внешней связью,объявленным в объявлении-seq.</target>
        </trans-unit>
        <trans-unit id="0f9581ab834f137fbae8882fe84416428e32951d" translate="yes" xml:space="preserve">
          <source>1) Applies the offset &lt;code&gt;d&lt;/code&gt; to &lt;code&gt;pt&lt;/code&gt;. Effectively, &lt;code&gt;d&lt;/code&gt; is added to the internally stored duration &lt;code&gt;d_&lt;/code&gt; as &lt;code&gt;d_ += d&lt;/code&gt;.</source>
          <target state="translated">1) Применяет смещение &lt;code&gt;d&lt;/code&gt; к &lt;code&gt;pt&lt;/code&gt; . По сути, &lt;code&gt;d&lt;/code&gt; добавляется к внутренней сохраненной продолжительности &lt;code&gt;d_&lt;/code&gt; как &lt;code&gt;d_ += d&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bd44368f1ec313c9be1e54cec6967210632f57be" translate="yes" xml:space="preserve">
          <source>1) Applies to a statement to allow the compiler to optimize for the case where paths of execution including that statement are more likely than any alternative path of execution that does not include such a statement.</source>
          <target state="translated">1)Применяется к оператору,чтобы позволить компилятору оптимизировать для случая,когда пути выполнения,включая этот оператор,более вероятны,чем любой альтернативный путь выполнения,который не включает такой оператор.</target>
        </trans-unit>
        <trans-unit id="8f5ccf9c295ab95bc3305d17a3414892b4f79ae1" translate="yes" xml:space="preserve">
          <source>1) As a part of class member access expression, in which the class either has this member or is derived from a class that has this member, including the implicit &lt;code&gt;this-&amp;gt;&lt;/code&gt; member access expressions that appear when a non-static member name is used in any of the contexts where &lt;a href=&quot;this&quot;&gt;this&lt;/a&gt; is allowed (inside member function bodies, in member initializer lists, in the in-class default member initializers).</source>
          <target state="translated">1) Как часть выражения доступа к члену класса, в котором класс либо имеет этот член, либо является производным от класса, имеющего этот член, включая неявные выражения доступа &lt;code&gt;this-&amp;gt;&lt;/code&gt; member, которые появляются при использовании нестатического имени члена в любом из контекстов, где &lt;a href=&quot;this&quot;&gt;это&lt;/a&gt; разрешено (внутри тел функций-членов, в списках инициализаторов членов, в инициализаторах членов класса по умолчанию).</target>
        </trans-unit>
        <trans-unit id="0cc54ba39b78a1ff9452057d5e234e2f1c5cc09c" translate="yes" xml:space="preserve">
          <source>1) As the comma may be used in the current locale as decimal separator, the output may be ambiguous. This can be solved with &lt;code&gt;&lt;a href=&quot;../../io/manip/showpoint&quot;&gt;std::showpoint&lt;/a&gt;&lt;/code&gt; which forces the decimal separator to be visible.</source>
          <target state="translated">1) Поскольку запятая может использоваться в текущей локали в качестве десятичного разделителя, вывод может быть неоднозначным. Это может быть решено с помощью &lt;code&gt;&lt;a href=&quot;../../io/manip/showpoint&quot;&gt;std::showpoint&lt;/a&gt;&lt;/code&gt; который заставляет десятичный разделитель быть видимым.</target>
        </trans-unit>
        <trans-unit id="bf4f5eebb3756e5992406e2db6b3544a4860b1b1" translate="yes" xml:space="preserve">
          <source>1) Assigns &lt;code&gt;value&lt;/code&gt; to all of the elements.</source>
          <target state="translated">1) Присваивает &lt;code&gt;value&lt;/code&gt; всем элементам.</target>
        </trans-unit>
        <trans-unit id="0471cc16b46b1f8592b99a5def70ecd023e5db86" translate="yes" xml:space="preserve">
          <source>1) Assigns &lt;code&gt;x&lt;/code&gt; to the real part of the complex number. Imaginary part is set to zero.</source>
          <target state="translated">1) Присваивает &lt;code&gt;x&lt;/code&gt; действительной части комплексного числа. Мнимая часть установлена ​​на ноль.</target>
        </trans-unit>
        <trans-unit id="bd74c1606493d2cb5c5263fcb597f13362ee0e84" translate="yes" xml:space="preserve">
          <source>1) Assigns a copy of</source>
          <target state="translated">1)Назначает копию</target>
        </trans-unit>
        <trans-unit id="14686248fd4c999e4263d1cbae14e46f33834fac" translate="yes" xml:space="preserve">
          <source>1) Assigns by copying the state of &lt;code&gt;rhs&lt;/code&gt;, as if by &lt;code&gt;any(rhs).swap(*this)&lt;/code&gt;.</source>
          <target state="translated">1) Назначает путем копирования состояния &lt;code&gt;rhs&lt;/code&gt; , как будто с помощью &lt;code&gt;any(rhs).swap(*this)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="79f8283f561eb803af10bf64d307d128f5f83943" translate="yes" xml:space="preserve">
          <source>1) Assigns character &lt;code&gt;a&lt;/code&gt; to character &lt;code&gt;r&lt;/code&gt;.</source>
          <target state="translated">1) Назначает символ &lt;code&gt;a&lt;/code&gt; символу &lt;code&gt;r&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b50adfd66ed3872fa645e5d68c15f0490c3528ad" translate="yes" xml:space="preserve">
          <source>1) Assigns each element in range &lt;code&gt;[first, last)&lt;/code&gt; a value generated by the given function object &lt;code&gt;g&lt;/code&gt;.</source>
          <target state="translated">1) Назначает каждому элементу в диапазоне &lt;code&gt;[first, last)&lt;/code&gt; значение, сгенерированное данным функциональным объектом &lt;code&gt;g&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="27023b4931499f367feb0a7ac32948b060a43b0d" translate="yes" xml:space="preserve">
          <source>1) Assigns the contents of &lt;code&gt;other&lt;/code&gt;. &lt;code&gt;&lt;a href=&quot;flags&quot;&gt;flags()&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;mark_count&quot;&gt;mark_count()&lt;/a&gt;&lt;/code&gt; are equivalent to the values of &lt;code&gt;other.flags()&lt;/code&gt; and &lt;code&gt;other.mark_count()&lt;/code&gt; after the call.</source>
          <target state="translated">1) Назначает содержимое &lt;code&gt;other&lt;/code&gt; . &lt;code&gt;&lt;a href=&quot;flags&quot;&gt;flags()&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;mark_count&quot;&gt;mark_count()&lt;/a&gt;&lt;/code&gt; эквивалентны значениям &lt;code&gt;other.flags()&lt;/code&gt; и &lt;code&gt;other.mark_count()&lt;/code&gt; после вызова.</target>
        </trans-unit>
        <trans-unit id="3cb923639f2556c1a0b92d6585fc6bae83d4f775" translate="yes" xml:space="preserve">
          <source>1) Assigns the given &lt;code&gt;value&lt;/code&gt; to the elements in the range &lt;code&gt;[first, last)&lt;/code&gt;.</source>
          <target state="translated">1) Присваивает заданное &lt;code&gt;value&lt;/code&gt; элементам в диапазоне &lt;code&gt;[first, last)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cc010e5348cf35fe3386539e2bcb8ef2deb9b2f0" translate="yes" xml:space="preserve">
          <source>1) Assigns the given &lt;code&gt;value&lt;/code&gt; to the first &lt;code&gt;count&lt;/code&gt; elements in the range beginning at &lt;code&gt;first&lt;/code&gt; if &lt;code&gt;count &amp;gt; 0&lt;/code&gt;. Does nothing otherwise.</source>
          <target state="translated">1) Присваивает заданное &lt;code&gt;value&lt;/code&gt; первым элементам &lt;code&gt;count&lt;/code&gt; в диапазоне, начинающемся &lt;code&gt;first&lt;/code&gt; если &lt;code&gt;count &amp;gt; 0&lt;/code&gt; . Ничего не делает иначе.</target>
        </trans-unit>
        <trans-unit id="44657b2873420948c5a550c8cea126cd3bcf8a02" translate="yes" xml:space="preserve">
          <source>1) Assigns the pathname identified by the detected-format string &lt;code&gt;source&lt;/code&gt;, which is left in valid, but unspecified state.</source>
          <target state="translated">1) Назначает путь, идентифицированный &lt;code&gt;source&lt;/code&gt; строки обнаруженного формата , который остается в допустимом, но неопределенном состоянии.</target>
        </trans-unit>
        <trans-unit id="1c5a2378f7a4b4f8c3112c22372e803c7c5df859" translate="yes" xml:space="preserve">
          <source>1) Assigns values, generated by given function object &lt;code&gt;g&lt;/code&gt;, to the first &lt;code&gt;count&lt;/code&gt; elements in the range beginning at &lt;code&gt;first&lt;/code&gt;, if &lt;code&gt;count&amp;gt;0&lt;/code&gt;. Does nothing otherwise.</source>
          <target state="translated">1) Присваивает значения, сгенерированные заданным функциональным объектом &lt;code&gt;g&lt;/code&gt; , первым элементам &lt;code&gt;count&lt;/code&gt; в диапазоне, начинающемся &lt;code&gt;first&lt;/code&gt; , если &lt;code&gt;count&amp;gt;0&lt;/code&gt; . Ничего не делает иначе.</target>
        </trans-unit>
        <trans-unit id="1eab96dc5e46fc4e8f1977dffe840d7d81e24fe4" translate="yes" xml:space="preserve">
          <source>1) At every &lt;a href=&quot;eval_order&quot;&gt;sequence point&lt;/a&gt;, the values of all &lt;a href=&quot;cv&quot;&gt;volatile&lt;/a&gt; objects are stable (previous evaluations are complete, new evaluations not started)</source>
          <target state="translated">1) В каждой &lt;a href=&quot;eval_order&quot;&gt;точке последовательности&lt;/a&gt; значения всех &lt;a href=&quot;cv&quot;&gt;изменчивых&lt;/a&gt; объектов стабильны (предыдущие оценки завершены, новые оценки не начаты)</target>
        </trans-unit>
        <trans-unit id="2d2df9e87c835521a32a8b38e0df7638b8c0360b" translate="yes" xml:space="preserve">
          <source>1) Atomic types are not copy/move assignable</source>
          <target state="translated">1)Атомные типы не копируются/перемещаются.</target>
        </trans-unit>
        <trans-unit id="1e1dd757f206c6d84410b18d446f5857c8473733" translate="yes" xml:space="preserve">
          <source>1) Atomically assigns a value &lt;code&gt;desired&lt;/code&gt; to the atomic variable. Equivalent to &lt;code&gt;store(desired)&lt;/code&gt;.</source>
          <target state="translated">1) Атомно назначает значение, &lt;code&gt;desired&lt;/code&gt; для атомарной переменной. Эквивалент для &lt;code&gt;store(desired)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="20eba43ce6c7c735f06737453bb9f5d0dcd49f5a" translate="yes" xml:space="preserve">
          <source>1) Atomically assigns a value &lt;code&gt;desired&lt;/code&gt; to the referenced object. Equivalent to &lt;code&gt;store(desired)&lt;/code&gt;.</source>
          <target state="translated">1) атомно присваивает &lt;code&gt;desired&lt;/code&gt; значение указанному объекту. Эквивалент для &lt;code&gt;store(desired)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="917158b5056f9fcbc3944d1e3cd72bab0516b4f5" translate="yes" xml:space="preserve">
          <source>1) Atomically obtains the value pointed to by &lt;code&gt;obj&lt;/code&gt; as if by &lt;code&gt;obj-&amp;gt;load()&lt;/code&gt;</source>
          <target state="translated">1) атомно получает значение, на которое указывает &lt;code&gt;obj&lt;/code&gt; , как если бы &lt;code&gt;obj-&amp;gt;load()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d17583e702426f0634bea84e519c1633a6c029e1" translate="yes" xml:space="preserve">
          <source>1) Atomically releases &lt;code&gt;lock&lt;/code&gt;, blocks the current executing thread, and adds it to the list of threads waiting on &lt;code&gt;*this&lt;/code&gt;. The thread will be unblocked when &lt;code&gt;&lt;a href=&quot;notify_all&quot;&gt;notify_all()&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;notify_one&quot;&gt;notify_one()&lt;/a&gt;&lt;/code&gt; is executed, or when the absolute time point &lt;code&gt;timeout_time&lt;/code&gt; is reached. It may also be unblocked spuriously. When unblocked, regardless of the reason, &lt;code&gt;lock&lt;/code&gt; is reacquired and &lt;code&gt;wait_until&lt;/code&gt; exits. If this function exits via exception, &lt;code&gt;lock&lt;/code&gt; is also reacquired.(until C++14)</source>
          <target state="translated">1) Атомно снимает &lt;code&gt;lock&lt;/code&gt; , блокирует текущий исполняющий поток и добавляет его в список потоков, ожидающих &lt;code&gt;*this&lt;/code&gt; . Поток будет разблокирован при выполнении &lt;code&gt;&lt;a href=&quot;notify_all&quot;&gt;notify_all()&lt;/a&gt;&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;notify_one&quot;&gt;notify_one()&lt;/a&gt;&lt;/code&gt; , или когда достигнут абсолютный момент времени &lt;code&gt;timeout_time&lt;/code&gt; . Он также может быть разблокирован с помощью лихорадки. Когда разблокировано, независимо от причины, &lt;code&gt;lock&lt;/code&gt; &lt;code&gt;wait_until&lt;/code&gt; и wait_until выходит. Если эта функция завершается через исключение, &lt;code&gt;lock&lt;/code&gt; также восстанавливается (до C ++ 14).</target>
        </trans-unit>
        <trans-unit id="39228d6c9d016ca7d710e477075b422412a6e3a1" translate="yes" xml:space="preserve">
          <source>1) Atomically releases &lt;code&gt;lock&lt;/code&gt;, blocks the current executing thread, and adds it to the list of threads waiting on &lt;code&gt;*this&lt;/code&gt;. The thread will be unblocked when &lt;code&gt;&lt;a href=&quot;notify_all&quot;&gt;notify_all()&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;notify_one&quot;&gt;notify_one()&lt;/a&gt;&lt;/code&gt; is executed, or when the relative timeout &lt;code&gt;rel_time&lt;/code&gt; expires. It may also be unblocked spuriously. When unblocked, regardless of the reason, &lt;code&gt;lock&lt;/code&gt; is reacquired and &lt;code&gt;wait_for()&lt;/code&gt; exits. If this function exits via exception, &lt;code&gt;lock&lt;/code&gt; is also reacquired.(until C++14)</source>
          <target state="translated">1) Атомно снимает &lt;code&gt;lock&lt;/code&gt; , блокирует текущий исполняющий поток и добавляет его в список потоков, ожидающих &lt;code&gt;*this&lt;/code&gt; . Поток будет разблокирован при выполнении &lt;code&gt;&lt;a href=&quot;notify_all&quot;&gt;notify_all()&lt;/a&gt;&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;notify_one&quot;&gt;notify_one()&lt;/a&gt;&lt;/code&gt; или по истечении относительного тайм-аута &lt;code&gt;rel_time&lt;/code&gt; . Он также может быть разблокирован с помощью лихорадки. Когда разблокировано, независимо от причины, &lt;code&gt;lock&lt;/code&gt; возобновляется, и &lt;code&gt;wait_for()&lt;/code&gt; завершается. Если эта функция завершается через исключение, &lt;code&gt;lock&lt;/code&gt; также восстанавливается (до C ++ 14).</target>
        </trans-unit>
        <trans-unit id="2fda25784c4cf15cdc68975c9a93b19127874b2f" translate="yes" xml:space="preserve">
          <source>1) Atomically replaces the value pointed to by &lt;code&gt;obj&lt;/code&gt; with the value of &lt;code&gt;desr&lt;/code&gt; and returns the value &lt;code&gt;obj&lt;/code&gt; held previously, as if by &lt;code&gt;obj-&amp;gt;exchange(desr)&lt;/code&gt;</source>
          <target state="translated">1) Атомно заменяет значение, на которое указывает &lt;code&gt;obj&lt;/code&gt; , значением &lt;code&gt;desr&lt;/code&gt; и возвращает ранее сохраненное значение &lt;code&gt;obj&lt;/code&gt; , как если бы это было &lt;code&gt;obj-&amp;gt;exchange(desr)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5a87743df627f94e6483569a8db0b5f5cafd7d8e" translate="yes" xml:space="preserve">
          <source>1) Atomically replaces the value pointed to by &lt;code&gt;obj&lt;/code&gt; with the value of &lt;code&gt;desr&lt;/code&gt; as if by &lt;code&gt;obj-&amp;gt;store(desr)&lt;/code&gt;</source>
          <target state="translated">1) Атомно заменяет значение, на которое указывает &lt;code&gt;obj&lt;/code&gt; , значением &lt;code&gt;desr&lt;/code&gt; , как если бы оно было &lt;code&gt;obj-&amp;gt;store(desr)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="407470d00a6b62854b98afb591359164b8cb7889" translate="yes" xml:space="preserve">
          <source>1) Atomically unlocks &lt;code&gt;lock&lt;/code&gt;, blocks the current executing thread, and adds it to the list of threads waiting on &lt;code&gt;*this&lt;/code&gt;. The thread will be unblocked when &lt;code&gt;&lt;a href=&quot;notify_all&quot;&gt;notify_all()&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;notify_one&quot;&gt;notify_one()&lt;/a&gt;&lt;/code&gt; is executed. It may also be unblocked spuriously. When unblocked, regardless of the reason, &lt;code&gt;lock&lt;/code&gt; is reacquired and &lt;code&gt;wait&lt;/code&gt; exits. If this function exits via exception, &lt;code&gt;lock&lt;/code&gt; is also reacquired.(until C++14)</source>
          <target state="translated">1) Атомно разблокирует &lt;code&gt;lock&lt;/code&gt; , блокирует текущий исполняющий поток и добавляет его в список потоков, ожидающих &lt;code&gt;*this&lt;/code&gt; . Поток будет разблокирован при выполнении &lt;code&gt;&lt;a href=&quot;notify_all&quot;&gt;notify_all()&lt;/a&gt;&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;notify_one&quot;&gt;notify_one()&lt;/a&gt;&lt;/code&gt; . Он также может быть разблокирован с помощью лихорадки. Когда разблокировано, независимо от причины, &lt;code&gt;lock&lt;/code&gt; возобновляется и &lt;code&gt;wait&lt;/code&gt; завершается. Если эта функция завершается через исключение, &lt;code&gt;lock&lt;/code&gt; также восстанавливается (до C ++ 14).</target>
        </trans-unit>
        <trans-unit id="84cf693490eeb5e15a9f6ac3f4c02c6a3441ac7b" translate="yes" xml:space="preserve">
          <source>1) Attempts to create an object of type, denoted by the &lt;a href=&quot;type-id#Type_naming&quot;&gt;type-id&lt;/a&gt;&lt;code&gt;type&lt;/code&gt;, which may be array type, and may include a &lt;a href=&quot;auto&quot;&gt;placeholder type specifier&lt;/a&gt;(since C++11), or include a class template name whose argument is to be deduced by &lt;a href=&quot;deduction_guide&quot;&gt;class template argument deduction&lt;/a&gt;(since C++17).</source>
          <target state="translated">1) попытки создать объект типа, обозначенный в &lt;a href=&quot;type-id#Type_naming&quot;&gt;типа идентификатора &lt;/a&gt; &lt;code&gt;type&lt;/code&gt; , который может быть типом массива, и может включать в себя &lt;a href=&quot;auto&quot;&gt;тип заполнитель спецификатор&lt;/a&gt; (так как C ++ , 11), или включать в себя имя шаблона класса , чей аргумент должен быть выводится путем &lt;a href=&quot;deduction_guide&quot;&gt;вывода аргументов шаблона класса&lt;/a&gt; (начиная с C ++ 17).</target>
        </trans-unit>
        <trans-unit id="f48a394185752e2c4944c4fec900dc772a3b157b" translate="yes" xml:space="preserve">
          <source>1) Attempts to establish the floating-point rounding direction equal to the argument &lt;code&gt;round&lt;/code&gt;, which is expected to be one of the &lt;a href=&quot;fe_round&quot;&gt;floating point rounding macros&lt;/a&gt;.</source>
          <target state="translated">1) Попытки установить направление округления с плавающей точкой, равное аргументу &lt;code&gt;round&lt;/code&gt; , который, как ожидается, будет одним из &lt;a href=&quot;fe_round&quot;&gt;макросов округления&lt;/a&gt; с плавающей точкой .</target>
        </trans-unit>
        <trans-unit id="7e3a5800b099aa0f75fced4ac6f2262d5f08936e" translate="yes" xml:space="preserve">
          <source>1) Attempts to obtain the full contents of the floating-point exception flags that are listed in the bitmask argument &lt;code&gt;excepts&lt;/code&gt;, which is a bitwise OR of the &lt;a href=&quot;fe_exceptions&quot;&gt;floating point exception macros&lt;/a&gt;.</source>
          <target state="translated">1) Попытки получить полное содержимое флагов исключений с плавающей точкой, перечисленных в &lt;code&gt;excepts&lt;/code&gt; аргумента битовой маски , который является побитовым ИЛИ &lt;a href=&quot;fe_exceptions&quot;&gt;макросов исключений&lt;/a&gt; с плавающей точкой .</target>
        </trans-unit>
        <trans-unit id="76935444316711f1ef025f07ccf80865f5a71493" translate="yes" xml:space="preserve">
          <source>1) Attempts to store the status of the floating-point environment in the object pointed to by &lt;code&gt;envp&lt;/code&gt;.</source>
          <target state="translated">1) Попытки сохранить состояние среды с плавающей запятой в объекте, на который указывает &lt;code&gt;envp&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c537d0344b241074eb3e0571ce11684b3a4576f9" translate="yes" xml:space="preserve">
          <source>1) Average case: constant, worst case: &lt;code&gt;c.size()&lt;/code&gt;</source>
          <target state="translated">1) Средний случай: постоянный, худший: &lt;code&gt;c.size()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f9b3845de48d795b10c6d53a55eac9b66f856548" translate="yes" xml:space="preserve">
          <source>1) Behaves as &lt;a href=&quot;../../named_req/unformattedinputfunction&quot;&gt;UnformattedInputFunction&lt;/a&gt;, except that &lt;code&gt;input.gcount()&lt;/code&gt; is not affected. After constructing and checking the sentry object, performs the following:</source>
          <target state="translated">1) Ведет себя как &lt;a href=&quot;../../named_req/unformattedinputfunction&quot;&gt;UnformattedInputFunction&lt;/a&gt; , за исключением того, что &lt;code&gt;input.gcount()&lt;/code&gt; не затрагивается. После построения и проверки сторожевого объекта выполняется следующее:</target>
        </trans-unit>
        <trans-unit id="6af5c4964210e22b364a62aef34f203069bc01d3" translate="yes" xml:space="preserve">
          <source>1) Behaves as a &lt;a href=&quot;../../named_req/formattedoutputfunction&quot;&gt;FormattedOutputFunction&lt;/a&gt;. After constructing and checking the sentry object, determines the output format padding as follows:</source>
          <target state="translated">1) ведет себя как &lt;a href=&quot;../../named_req/formattedoutputfunction&quot;&gt;FormattedOutputFunction&lt;/a&gt; . После создания и проверки сторожевого объекта определяется заполнение выходного формата следующим образом:</target>
        </trans-unit>
        <trans-unit id="abde054c511c98ef59ea6a6219a0d40067429c5f" translate="yes" xml:space="preserve">
          <source>1) Behaves as an &lt;a href=&quot;../../named_req/formattedinputfunction&quot;&gt;FormattedInputFunction&lt;/a&gt;. After constructing and checking the sentry object, which may skip leading whitespace, extracts a character and stores it to &lt;code&gt;ch&lt;/code&gt;. If no character is available, sets &lt;a href=&quot;../ios_base/iostate&quot;&gt;&lt;code&gt;failbit&lt;/code&gt;&lt;/a&gt; (in addition to &lt;a href=&quot;../ios_base/iostate&quot;&gt;&lt;code&gt;eofbit&lt;/code&gt;&lt;/a&gt; that is set as required of a &lt;a href=&quot;../../named_req/formattedinputfunction&quot;&gt;FormattedInputFunction&lt;/a&gt;).</source>
          <target state="translated">1) Ведет себя как &lt;a href=&quot;../../named_req/formattedinputfunction&quot;&gt;FormattedInputFunction&lt;/a&gt; . После создания и проверки сторожевого объекта, который может пропустить начальные пробелы, извлекается символ и сохраняется его в &lt;code&gt;ch&lt;/code&gt; . Если символ не доступен, наборы &lt;a href=&quot;../ios_base/iostate&quot;&gt; &lt;code&gt;failbit&lt;/code&gt; &lt;/a&gt; (в дополнение к &lt;a href=&quot;../ios_base/iostate&quot;&gt; &lt;code&gt;eofbit&lt;/code&gt; &lt;/a&gt; , который устанавливается в соответствии с требованиями о &lt;a href=&quot;../../named_req/formattedinputfunction&quot;&gt;FormattedInputFunction&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="66cf5e2bc278327aafd28d7df89e620a0de46000" translate="yes" xml:space="preserve">
          <source>1) Behaves as an &lt;a href=&quot;../../named_req/formattedoutputfunction&quot;&gt;FormattedOutputFunction&lt;/a&gt;. After constructing and checking the sentry object, inserts the character &lt;code&gt;ch&lt;/code&gt;. If the type of the character is not &lt;code&gt;CharT&lt;/code&gt;, it is first converted with &lt;code&gt;os.widen(ch)&lt;/code&gt;. Padding is determined as follows: if &lt;code&gt;os.width()&amp;gt;1&lt;/code&gt;, then &lt;code&gt;os.width()-1&lt;/code&gt; copies of &lt;code&gt;os.fill()&lt;/code&gt; are added to the output character to form the output character sequence. If &lt;code&gt;(out.flags()&amp;amp;&lt;a href=&quot;../ios_base/fmtflags&quot;&gt;std::ios_base::adjustfield&lt;/a&gt;) == &lt;a href=&quot;../ios_base/fmtflags&quot;&gt;std::ios_base::left&lt;/a&gt;&lt;/code&gt;, the fill characters are placed after the output character, otherwise before. After insertion, &lt;code&gt;os.width(0)&lt;/code&gt; is called to cancel the effects of &lt;code&gt;&lt;a href=&quot;../manip/setw&quot;&gt;std::setw&lt;/a&gt;&lt;/code&gt;, if any.</source>
          <target state="translated">1) Ведет себя как &lt;a href=&quot;../../named_req/formattedoutputfunction&quot;&gt;функция FormattedOutput&lt;/a&gt; . После создания и проверки сторожевого объекта вставьте символ &lt;code&gt;ch&lt;/code&gt; . Если тип символа не &lt;code&gt;CharT&lt;/code&gt; , он сначала конвертируется с помощью &lt;code&gt;os.widen(ch)&lt;/code&gt; . Заполнение определяется следующим образом: если &lt;code&gt;os.width()&amp;gt;1&lt;/code&gt; , то &lt;code&gt;os.width()-1&lt;/code&gt; копия &lt;code&gt;os.fill()&lt;/code&gt; добавляется к выходному символу для формирования последовательности выходных символов. Если &lt;code&gt;(out.flags()&amp;amp;&lt;a href=&quot;../ios_base/fmtflags&quot;&gt;std::ios_base::adjustfield&lt;/a&gt;) == &lt;a href=&quot;../ios_base/fmtflags&quot;&gt;std::ios_base::left&lt;/a&gt;&lt;/code&gt; , символы заполнения помещаются после выходного символа, в противном случае перед. После вставки &lt;code&gt;os.width(0)&lt;/code&gt; вызывается для отмены эффектов &lt;code&gt;&lt;a href=&quot;../manip/setw&quot;&gt;std::setw&lt;/a&gt;&lt;/code&gt; , если есть.</target>
        </trans-unit>
        <trans-unit id="c4d17ec70cbf5d4f592fc6b2f432bf9f5427d7e3" translate="yes" xml:space="preserve">
          <source>1) Behaves as if (2) is called with &lt;code&gt;policy&lt;/code&gt; being &lt;code&gt;&lt;a href=&quot;launch&quot;&gt;std::launch::async&lt;/a&gt; | &lt;a href=&quot;launch&quot;&gt;std::launch::deferred&lt;/a&gt;&lt;/code&gt;. In other words, &lt;code&gt;f&lt;/code&gt; may be executed in another thread or it may be run synchronously when the resulting &lt;code&gt;&lt;a href=&quot;future&quot;&gt;std::future&lt;/a&gt;&lt;/code&gt; is queried for a value.</source>
          <target state="translated">1) ведет себя так, как будто (2) вызывается с &lt;code&gt;policy&lt;/code&gt; являющейся &lt;code&gt;&lt;a href=&quot;launch&quot;&gt;std::launch::async&lt;/a&gt; | &lt;a href=&quot;launch&quot;&gt;std::launch::deferred&lt;/a&gt;&lt;/code&gt; . Другими словами, &lt;code&gt;f&lt;/code&gt; может выполняться в другом потоке или может выполняться синхронно, когда результирующий &lt;code&gt;&lt;a href=&quot;future&quot;&gt;std::future&lt;/a&gt;&lt;/code&gt; запрашивается для значения.</target>
        </trans-unit>
        <trans-unit id="1561ba4be61858948b7fed01763fdb3a6eb95b15" translate="yes" xml:space="preserve">
          <source>1) Behaves as if defined as follows:</source>
          <target state="translated">1)Ведет себя так,как если бы было определено ниже:</target>
        </trans-unit>
        <trans-unit id="8175e77df8cae0e91832bcbf197a16dc79ef925d" translate="yes" xml:space="preserve">
          <source>1) Behaves in implementation-defined manner</source>
          <target state="translated">1)ведет себя определенным образом в рамках реализации</target>
        </trans-unit>
        <trans-unit id="9b4755491e2aea36644386cd6d0dbcbbe4600c5a" translate="yes" xml:space="preserve">
          <source>1) Binds the first argument of &lt;code&gt;f&lt;/code&gt; to &lt;code&gt;x&lt;/code&gt;. Effectively calls &lt;code&gt;&lt;a href=&quot;binder12&quot;&gt;std::binder1st&lt;/a&gt;&amp;lt;F&amp;gt;(f, typename F::first_argument_type(x))&lt;/code&gt;.</source>
          <target state="translated">1) Привязывает первый аргумент &lt;code&gt;f&lt;/code&gt; к &lt;code&gt;x&lt;/code&gt; . Эффективно вызывает &lt;code&gt;&lt;a href=&quot;binder12&quot;&gt;std::binder1st&lt;/a&gt;&amp;lt;F&amp;gt;(f, typename F::first_argument_type(x))&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="984a8150c7ac39a66022118522276911d7cc5f49" translate="yes" xml:space="preserve">
          <source>1) Binds the first parameter to the value &lt;code&gt;value&lt;/code&gt; given at the construction of the object.</source>
          <target state="translated">1) Связывает первый параметр со &lt;code&gt;value&lt;/code&gt; заданным при построении объекта.</target>
        </trans-unit>
        <trans-unit id="64831980f81dae6254ff1d82d0c72182c81bbba9" translate="yes" xml:space="preserve">
          <source>1) Both ranges must be sorted with &lt;code&gt;operator&amp;lt;&lt;/code&gt;.</source>
          <target state="translated">1) Оба диапазона должны быть отсортированы с помощью &lt;code&gt;operator&amp;lt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6e7001be6592e516d5b51c004a74838c40e04025" translate="yes" xml:space="preserve">
          <source>1) Called by &lt;a href=&quot;../../language/delete&quot;&gt;delete-expressions&lt;/a&gt; to deallocate storage previously allocated for a single object. The behavior of the standard library implementation of this function is undefined unless &lt;code&gt;ptr&lt;/code&gt; is a null pointer or is a pointer previously obtained from the standard library implementation of &lt;code&gt;&lt;a href=&quot;operator_new&quot;&gt;operator new&lt;/a&gt;(size_t)&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;operator_new&quot;&gt;operator new&lt;/a&gt;(size_t, &lt;a href=&quot;nothrow_t&quot;&gt;std::nothrow_t&lt;/a&gt;)&lt;/code&gt;.</source>
          <target state="translated">1) Вызывается выражениями &lt;a href=&quot;../../language/delete&quot;&gt;delete&lt;/a&gt; для освобождения памяти, ранее выделенной для одного объекта. Поведение стандартной реализации библиотеки этой функции не определено, если &lt;code&gt;ptr&lt;/code&gt; не является нулевым указателем или указателем, ранее полученным из стандартной реализации библиотеки &lt;code&gt;&lt;a href=&quot;operator_new&quot;&gt;operator new&lt;/a&gt;(size_t)&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;operator_new&quot;&gt;operator new&lt;/a&gt;(size_t, &lt;a href=&quot;nothrow_t&quot;&gt;std::nothrow_t&lt;/a&gt;)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b29fa0fabda5d69f4442be6c5fdef616a24dd581" translate="yes" xml:space="preserve">
          <source>1) Called by non-array &lt;a href=&quot;../../language/new&quot;&gt;new-expressions&lt;/a&gt; to allocate storage required for a single object. The standard library implementation allocates &lt;code&gt;count&lt;/code&gt; bytes from free store. In case of failure, the standard library implementation calls the function pointer returned by &lt;code&gt;&lt;a href=&quot;get_new_handler&quot;&gt;std::get_new_handler&lt;/a&gt;&lt;/code&gt; and repeats allocation attempts until new handler does not return or becomes a null pointer, at which time it throws &lt;code&gt;&lt;a href=&quot;bad_alloc&quot;&gt;std::bad_alloc&lt;/a&gt;&lt;/code&gt;. This function is required to return a pointer suitably aligned to hold an object of any fundamental alignment.</source>
          <target state="translated">1) Вызывается &lt;a href=&quot;../../language/new&quot;&gt;новыми выражениями,&lt;/a&gt; не являющимися массивами, для выделения памяти, необходимой для отдельного объекта. Реализация стандартной библиотеки выделяет &lt;code&gt;count&lt;/code&gt; байтов из свободного хранилища. В случае сбоя стандартная реализация библиотеки вызывает указатель функции, возвращаемый &lt;code&gt;&lt;a href=&quot;get_new_handler&quot;&gt;std::get_new_handler&lt;/a&gt;&lt;/code&gt; и повторяет попытки выделения, пока новый обработчик не вернётся или не станет нулевым указателем, после чего он выбрасывает &lt;code&gt;&lt;a href=&quot;bad_alloc&quot;&gt;std::bad_alloc&lt;/a&gt;&lt;/code&gt; . Эта функция требуется для возврата указателя, соответствующим образом выровненного, чтобы удерживать объект любого фундаментального выравнивания.</target>
        </trans-unit>
        <trans-unit id="1201c06b6c4799b1fe55caec61e97450a74c02c7" translate="yes" xml:space="preserve">
          <source>1) Calls &lt;code&gt;((T*)p)-&amp;gt;~T()&lt;/code&gt;</source>
          <target state="translated">1) Звонки &lt;code&gt;((T*)p)-&amp;gt;~T()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="60cf179e7f48d67030a9b02c5b10f02cbd88fc74" translate="yes" xml:space="preserve">
          <source>1) Calls &lt;code&gt;&lt;a href=&quot;../allocator_traits&quot;&gt;std::allocator_traits&lt;/a&gt;&amp;lt;OuterAlloc&amp;gt;::allocate(outer_allocator(), n)&lt;/code&gt;</source>
          <target state="translated">1) Вызывает &lt;code&gt;&lt;a href=&quot;../allocator_traits&quot;&gt;std::allocator_traits&lt;/a&gt;&amp;lt;OuterAlloc&amp;gt;::allocate(outer_allocator(), n)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="75d0c1937c63022053420ca73afdc6c6c3f42d8d" translate="yes" xml:space="preserve">
          <source>1) Calls &lt;code&gt;a.allocate(n)&lt;/code&gt;</source>
          <target state="translated">1) Вызывает &lt;code&gt;a.allocate(n)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="612ce7599a47183d9e5a7f878c33edddf6b15c5f" translate="yes" xml:space="preserve">
          <source>1) Calls &lt;code&gt;delete&lt;/code&gt; (primary template) or &lt;code&gt;delete[]&lt;/code&gt; (array specialization) on &lt;code&gt;ptr&lt;/code&gt;2) Defined as deleted</source>
          <target state="translated">1) Вызовы &lt;code&gt;delete&lt;/code&gt; (основной шаблон) или &lt;code&gt;delete[]&lt;/code&gt; (специализация массива) в &lt;code&gt;ptr&lt;/code&gt; 2) Определяется как удаленный</target>
        </trans-unit>
        <trans-unit id="f9949dd29b950802c3d58375f6e80bddb5aa08d9" translate="yes" xml:space="preserve">
          <source>1) Calls &lt;code&gt;delete&lt;/code&gt; on &lt;code&gt;ptr&lt;/code&gt;2) Calls &lt;code&gt;delete[]&lt;/code&gt; on &lt;code&gt;ptr&lt;/code&gt;. This function will only participate in overload resolution if &lt;code&gt;U(*)[]&lt;/code&gt; is implicitly convertible to &lt;code&gt;T(*)[]&lt;/code&gt;.</source>
          <target state="translated">1) &lt;code&gt;delete&lt;/code&gt; вызовов на &lt;code&gt;ptr&lt;/code&gt; 2) &lt;code&gt;delete[]&lt;/code&gt; вызовов [] на &lt;code&gt;ptr&lt;/code&gt; . Эта функция будет участвовать в разрешении перегрузки, только если &lt;code&gt;U(*)[]&lt;/code&gt; неявно преобразуется в &lt;code&gt;T(*)[]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="18edfbb5ff4b58d729699ca4db1ff32af0d3018f" translate="yes" xml:space="preserve">
          <source>1) Calls &lt;code&gt;new((void *)p) T(val)&lt;/code&gt;</source>
          <target state="translated">1) Вызывает &lt;code&gt;new((void *)p) T(val)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d55a7910f52d41d1727553c431ed7d3dd8fbe500" translate="yes" xml:space="preserve">
          <source>1) Calls &lt;code&gt;seekoff(off, dir, which)&lt;/code&gt; of the most derived class.</source>
          <target state="translated">1) Вызывает &lt;code&gt;seekoff(off, dir, which)&lt;/code&gt; самого производного класса.</target>
        </trans-unit>
        <trans-unit id="1275e8a0c91e8f2137761ada491aefdcab7cbfe3" translate="yes" xml:space="preserve">
          <source>1) Calls &lt;code&gt;seekpos(pos, which)&lt;/code&gt; of the most derived class.</source>
          <target state="translated">1) Вызывает &lt;code&gt;seekpos(pos, which)&lt;/code&gt; наиболее производного класса.</target>
        </trans-unit>
        <trans-unit id="2ce04d40fb13795e660c624012ebc10673555aff" translate="yes" xml:space="preserve">
          <source>1) Calls &lt;code&gt;setbuf(s, n)&lt;/code&gt; of the most derived class</source>
          <target state="translated">1) Вызывает &lt;code&gt;setbuf(s, n)&lt;/code&gt; самого производного класса</target>
        </trans-unit>
        <trans-unit id="189c8c3b03cc9ff928fbd4420e4f08a2f0060d6d" translate="yes" xml:space="preserve">
          <source>1) Calls &lt;code&gt;str.erase()&lt;/code&gt;</source>
          <target state="translated">1) Звонит &lt;code&gt;str.erase()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="968bf3d903f71b89d9f7ec9294f33c57ce120fc1" translate="yes" xml:space="preserve">
          <source>1) Calls &lt;code&gt;sync()&lt;/code&gt; of the most derived class.</source>
          <target state="translated">1) Вызывает &lt;code&gt;sync()&lt;/code&gt; самого производного класса.</target>
        </trans-unit>
        <trans-unit id="730f19f3ac0934ef27532bf7c9384f807d2f9aed" translate="yes" xml:space="preserve">
          <source>1) Calls &lt;code&gt;xsgetn(s, count)&lt;/code&gt; of the most derived class.</source>
          <target state="translated">1) Вызывает &lt;code&gt;xsgetn(s, count)&lt;/code&gt; самого производного класса.</target>
        </trans-unit>
        <trans-unit id="ec64be5663b85a72b50b7ff9f40df45f3c1977e7" translate="yes" xml:space="preserve">
          <source>1) Calls &lt;code&gt;xsputn(s, count)&lt;/code&gt; of the most derived class.</source>
          <target state="translated">1) Вызывает &lt;code&gt;xsputn(s, count)&lt;/code&gt; самого производного класса.</target>
        </trans-unit>
        <trans-unit id="168b614f9f40ac5f9718c1bbf48c0be54f15eee3" translate="yes" xml:space="preserve">
          <source>1) Calls every callback registered by &lt;code&gt;&lt;a href=&quot;../ios_base/register_callback&quot;&gt;register_callback()&lt;/a&gt;&lt;/code&gt; passing &lt;a href=&quot;../ios_base/event&quot;&gt;&lt;code&gt;erase_event&lt;/code&gt;&lt;/a&gt; as parameter</source>
          <target state="translated">1) Вызывает каждый обратный вызов, зарегистрированный &lt;code&gt;&lt;a href=&quot;../ios_base/register_callback&quot;&gt;register_callback()&lt;/a&gt;&lt;/code&gt; передавая &lt;a href=&quot;../ios_base/event&quot;&gt; &lt;code&gt;erase_event&lt;/code&gt; в&lt;/a&gt; качестве параметра</target>
        </trans-unit>
        <trans-unit id="9815ff59a707fc80fc245c084207918bbda81cd8" translate="yes" xml:space="preserve">
          <source>1) Catch-clause that declares a named formal parameter</source>
          <target state="translated">1)Причина уловки,которая объявляет именованный формальный параметр.</target>
        </trans-unit>
        <trans-unit id="a2e6973b14cedb89a76d6c2303ae23c129573389" translate="yes" xml:space="preserve">
          <source>1) Changes the current preprocessor line number to lineno. Expansions of the macro &lt;code&gt;__LINE__&lt;/code&gt; beyond this point will expand to lineno plus the number of actual source code lines encountered since.</source>
          <target state="translated">1) Изменяет текущий номер строки препроцессора на lineno. Расширения макроса &lt;code&gt;__LINE__&lt;/code&gt; за пределами этой точки будут расширены до lineno плюс количество фактических строк исходного кода, встреченных с тех пор.</target>
        </trans-unit>
        <trans-unit id="251ac3216df00c46dba0c1fcacce145761ea51d6" translate="yes" xml:space="preserve">
          <source>1) Character width: unset, narrow or wide</source>
          <target state="translated">1)Ширина символа:неразборчивый,узкий или широкий</target>
        </trans-unit>
        <trans-unit id="528a3c47bcb0f4bda9d76624cab85acce69f7c8b" translate="yes" xml:space="preserve">
          <source>1) Checks if &lt;code&gt;lhs&lt;/code&gt; and &lt;code&gt;rhs&lt;/code&gt; are equal.</source>
          <target state="translated">1) Проверяет , равны ли &lt;code&gt;lhs&lt;/code&gt; и &lt;code&gt;rhs&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="653944661bbab0d4335db30edc3fcd7d09dead4d" translate="yes" xml:space="preserve">
          <source>1) Checks if all bits are set to &lt;code&gt;true&lt;/code&gt;</source>
          <target state="translated">1) Проверяет, все ли биты установлены в &lt;code&gt;true&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2c372d3881ed1d3880dc2bcd3c0763ed5a3e843a" translate="yes" xml:space="preserve">
          <source>1) Checks if the character &lt;code&gt;c&lt;/code&gt; is classified by the mask &lt;code&gt;m&lt;/code&gt; according to the classification table returned by the member function &lt;code&gt;table()&lt;/code&gt;. Effectively calculates &lt;code&gt;table()[(unsigned char)c] &amp;amp; m&lt;/code&gt;</source>
          <target state="translated">1) Проверяет, классифицирован ли символ &lt;code&gt;c&lt;/code&gt; по маске &lt;code&gt;m&lt;/code&gt; в соответствии с таблицей классификации, возвращенной &lt;code&gt;table()&lt;/code&gt; функций-членов () . Эффективно вычисляет &lt;code&gt;table()[(unsigned char)c] &amp;amp; m&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="055fc3ccc188ca6bb065e219ee940c38e7022dff" translate="yes" xml:space="preserve">
          <source>1) Checks if there is an element with key equivalent to &lt;code&gt;key&lt;/code&gt; in the container.</source>
          <target state="translated">1) Проверяет, есть ли в контейнере элемент с ключом, эквивалентным &lt;code&gt;key&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="01ce0d85d642a69a60a7bd7021acaa1e1acddc49" translate="yes" xml:space="preserve">
          <source>1) Checks if unary predicate &lt;code&gt;p&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt; for all elements in the range &lt;code&gt;[first, last)&lt;/code&gt;.</source>
          <target state="translated">1) Проверка , если унарный предикатный &lt;code&gt;p&lt;/code&gt; возвращает &lt;code&gt;true&lt;/code&gt; для всех элементов в диапазоне &lt;code&gt;[first, last)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="807fd23a250c000cd2d3ce89e2e7e20500a459ae" translate="yes" xml:space="preserve">
          <source>1) Checks if unary predicate &lt;code&gt;pred&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt; for all elements in the range &lt;code&gt;[first, last)&lt;/code&gt; (after projecting with the projection &lt;code&gt;proj&lt;/code&gt;).</source>
          <target state="translated">1) Проверяет, возвращает ли унарный предикат &lt;code&gt;pred&lt;/code&gt; значение &lt;code&gt;true&lt;/code&gt; для всех элементов в диапазоне &lt;code&gt;[first, last)&lt;/code&gt; (после проецирования с проекцией &lt;code&gt;proj&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="af5a0d7b95029857fc67f9aec30edea70c5bdbe5" translate="yes" xml:space="preserve">
          <source>1) Checks whether &lt;a href=&quot;root_path&quot;&gt;&lt;code&gt;root_path()&lt;/code&gt;&lt;/a&gt; is empty.</source>
          <target state="translated">1) Проверяет, является ли &lt;a href=&quot;root_path&quot;&gt; &lt;code&gt;root_path()&lt;/code&gt; &lt;/a&gt; пустым.</target>
        </trans-unit>
        <trans-unit id="faa74b887ee96c25a3492d6735e13770ce680b0e" translate="yes" xml:space="preserve">
          <source>1) Checks whether &lt;code&gt;*this&lt;/code&gt; and &lt;code&gt;rhs&lt;/code&gt; refer to the same object.</source>
          <target state="translated">1) Проверяет, относятся ли &lt;code&gt;*this&lt;/code&gt; и &lt;code&gt;rhs&lt;/code&gt; к одному и тому же объекту.</target>
        </trans-unit>
        <trans-unit id="2dba4b22cc7fa19bfacb9c9df88e70c92a237039" translate="yes" xml:space="preserve">
          <source>1) Checks whether &lt;code&gt;lhs&lt;/code&gt; and &lt;code&gt;rhs&lt;/code&gt; are equal.</source>
          <target state="translated">1) Проверяет, равны ли &lt;code&gt;lhs&lt;/code&gt; и &lt;code&gt;rhs&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e8185a1925a4fbfb166981361f79075e2ee33f60" translate="yes" xml:space="preserve">
          <source>1) Checks whether &lt;code&gt;lhs&lt;/code&gt; and &lt;code&gt;rhs&lt;/code&gt; are equal. Equivalent to &lt;code&gt;!(lhs &amp;lt; rhs) &amp;amp;&amp;amp; !(rhs &amp;lt; lhs)&lt;/code&gt;.</source>
          <target state="translated">1) Проверяет, равны ли &lt;code&gt;lhs&lt;/code&gt; и &lt;code&gt;rhs&lt;/code&gt; . Эквивалент &lt;code&gt;!(lhs &amp;lt; rhs) &amp;amp;&amp;amp; !(rhs &amp;lt; lhs)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0fcbd95aabb4ff5227cf670c7cd313a716db3f1b" translate="yes" xml:space="preserve">
          <source>1) Checks whether &lt;code&gt;lhs&lt;/code&gt; is</source>
          <target state="translated">1) Проверяет, является ли &lt;code&gt;lhs&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="025b85874b3e1d46d1eddf5eb17f542191097060" translate="yes" xml:space="preserve">
          <source>1) Compares &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; for equality.</source>
          <target state="translated">1) Сравнивает &lt;code&gt;a&lt;/code&gt; и &lt;code&gt;b&lt;/code&gt; на равенство.</target>
        </trans-unit>
        <trans-unit id="ba27d1cf06b36c7b4c27679328ea9f73d35759e5" translate="yes" xml:space="preserve">
          <source>1) Compares &lt;code&gt;lhs&lt;/code&gt; and &lt;code&gt;rhs&lt;/code&gt; for equality.</source>
          <target state="translated">1) Сравнивает &lt;code&gt;lhs&lt;/code&gt; и &lt;code&gt;rhs&lt;/code&gt; на равенство.</target>
        </trans-unit>
        <trans-unit id="379cb0f357c5f6804b447714bf22e588013d0adb" translate="yes" xml:space="preserve">
          <source>1) Compares this string to</source>
          <target state="translated">1)Сравнивает эту строку с</target>
        </trans-unit>
        <trans-unit id="95bc5c17aaacd83f1d13fbd093132d7300e74abf" translate="yes" xml:space="preserve">
          <source>1) Compares two &lt;code&gt;sub_match&lt;/code&gt; directly by comparing their underlying character sequences. Equivalent to &lt;code&gt;str().compare(m.str())&lt;/code&gt;.</source>
          <target state="translated">1) Сравнивает два &lt;code&gt;sub_match&lt;/code&gt; напрямую, сравнивая их основные последовательности символов. Эквивалентно &lt;code&gt;str().compare(m.str())&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="babefe1ac4774ec2ba6d2f9315221ca39913970c" translate="yes" xml:space="preserve">
          <source>1) Compares two distribution objects for equality.</source>
          <target state="translated">1)Сравнивает два объекта распределения для равенства.</target>
        </trans-unit>
        <trans-unit id="35a9eb1fa11c8a233e6c0a2c9a6bd06330c5cb30" translate="yes" xml:space="preserve">
          <source>1) Computes the</source>
          <target state="translated">1)Рассчитывает</target>
        </trans-unit>
        <trans-unit id="29e45200813ec27005f84e8b35b75cfdc6f3c406" translate="yes" xml:space="preserve">
          <source>1) Computes the (physicist's) &lt;a href=&quot;https://en.wikipedia.org/wiki/Hermite_polynomials&quot;&gt;Hermite polynomials&lt;/a&gt; of the degree &lt;code&gt;n&lt;/code&gt; and argument &lt;code&gt;x&lt;/code&gt;</source>
          <target state="translated">1) Вычисляет &lt;a href=&quot;https://en.wikipedia.org/wiki/Hermite_polynomials&quot;&gt;полиномы Эрмита&lt;/a&gt; (физика) степени &lt;code&gt;n&lt;/code&gt; и аргумента &lt;code&gt;x&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5cd529178d75829687d759cf3575835519db392b" translate="yes" xml:space="preserve">
          <source>1) Computes the &lt;a href=&quot;https://en.wikipedia.org/wiki/Associated_Legendre_polynomials&quot;&gt;associated Legendre polynomials&lt;/a&gt; of the degree &lt;code&gt;n&lt;/code&gt;, order &lt;code&gt;m&lt;/code&gt;, and argument &lt;code&gt;x&lt;/code&gt;</source>
          <target state="translated">1) Вычисляет &lt;a href=&quot;https://en.wikipedia.org/wiki/Associated_Legendre_polynomials&quot;&gt;связанные многочлены Лежандра&lt;/a&gt; степени &lt;code&gt;n&lt;/code&gt; , порядка &lt;code&gt;m&lt;/code&gt; и аргумента &lt;code&gt;x&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="11b6095d1bbc46a80dd8c941788ea2de6b4c76aa" translate="yes" xml:space="preserve">
          <source>1) Computes the &lt;a href=&quot;https://en.wikipedia.org/wiki/Bessel_function#Bessel_functions_of_the_first_kind:_J.CE.B1&quot;&gt;cylindrical Bessel function of the first kind&lt;/a&gt; of &lt;code&gt;&amp;nu;&lt;/code&gt; and &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">1) Вычислить &lt;a href=&quot;https://en.wikipedia.org/wiki/Bessel_function#Bessel_functions_of_the_first_kind:_J.CE.B1&quot;&gt;цилиндрическую функцию Бесселя первого рода&lt;/a&gt; от &lt;code&gt;&amp;nu;&lt;/code&gt; , и &lt;code&gt;x&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="09a1bb2811a36108b87f462b1c39d364fc3d72dc" translate="yes" xml:space="preserve">
          <source>1) Computes the &lt;a href=&quot;https://en.wikipedia.org/wiki/Bessel_function#Bessel_functions_of_the_second_kind:_Y.CE.B1&quot;&gt;cylindrical Neumann function&lt;/a&gt; (also known as Bessel function of the second kind or Weber function) of &lt;code&gt;&amp;nu;&lt;/code&gt; and &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">1) Вычисляет &lt;a href=&quot;https://en.wikipedia.org/wiki/Bessel_function#Bessel_functions_of_the_second_kind:_Y.CE.B1&quot;&gt;цилиндрическую функцию Неймана&lt;/a&gt; (также известную как функция Бесселя второго рода или функция Вебера) для &lt;code&gt;&amp;nu;&lt;/code&gt; и &lt;code&gt;x&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4c4124d09b398c54819810bb7083904eeb5106df" translate="yes" xml:space="preserve">
          <source>1) Computes the &lt;a href=&quot;https://en.wikipedia.org/wiki/Bessel_function#Modified_Bessel_functions:_I.CE.B1_.2C_K.CE.B1&quot;&gt;irregular modified cylindrical Bessel function&lt;/a&gt; (also known as modified Bessel function of the second kind) of &lt;code&gt;&amp;nu;&lt;/code&gt; and &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">1) Вычисляет &lt;a href=&quot;https://en.wikipedia.org/wiki/Bessel_function#Modified_Bessel_functions:_I.CE.B1_.2C_K.CE.B1&quot;&gt;нерегулярную модифицированную цилиндрическую функцию Бесселя&lt;/a&gt; (также известную как модифицированная функция Бесселя второго рода) для &lt;code&gt;&amp;nu;&lt;/code&gt; и &lt;code&gt;x&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ccf9684995d2a46db4ec7d7201afb8deb62574e0" translate="yes" xml:space="preserve">
          <source>1) Computes the &lt;a href=&quot;https://en.wikipedia.org/wiki/Bessel_function#Modified_Bessel_functions:_I.CE.B1_.2C_K.CE.B1&quot;&gt;regular modified cylindrical Bessel function&lt;/a&gt; of &lt;code&gt;&amp;nu;&lt;/code&gt; and &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">1) Вычисляет &lt;a href=&quot;https://en.wikipedia.org/wiki/Bessel_function#Modified_Bessel_functions:_I.CE.B1_.2C_K.CE.B1&quot;&gt;регулярную модифицированную цилиндрическую функцию Бесселя&lt;/a&gt; от &lt;code&gt;&amp;nu;&lt;/code&gt; и &lt;code&gt;x&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="61a6248b455016d83fb9f4ae46600e92647e97f9" translate="yes" xml:space="preserve">
          <source>1) Computes the &lt;a href=&quot;https://en.wikipedia.org/wiki/Bessel_function#Spherical_Bessel_functions:_jn.2C_yn&quot;&gt;spherical Bessel function of the first kind&lt;/a&gt; of &lt;code&gt;n&lt;/code&gt; and &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">1) Вычислить &lt;a href=&quot;https://en.wikipedia.org/wiki/Bessel_function#Spherical_Bessel_functions:_jn.2C_yn&quot;&gt;сферическую функцию Бесселя первого рода&lt;/a&gt; из &lt;code&gt;n&lt;/code&gt; и &lt;code&gt;x&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="58bd3e8ee95098c0c96f4de4b3b5b3f2da549f3f" translate="yes" xml:space="preserve">
          <source>1) Computes the &lt;a href=&quot;https://en.wikipedia.org/wiki/Bessel_function#Spherical_Bessel_functions:_jn.2C_yn&quot;&gt;spherical Bessel function of the second kind&lt;/a&gt;, also known as the spherical Neumann function, of &lt;code&gt;n&lt;/code&gt; and &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">1) Вычисляет &lt;a href=&quot;https://en.wikipedia.org/wiki/Bessel_function#Spherical_Bessel_functions:_jn.2C_yn&quot;&gt;сферическую функцию Бесселя второго рода&lt;/a&gt; , также известную как сферическая функция Неймана, для &lt;code&gt;n&lt;/code&gt; и &lt;code&gt;x&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bd5509c7dd414eeed186d9c04f5e19a8ae9447d6" translate="yes" xml:space="preserve">
          <source>1) Computes the &lt;a href=&quot;https://en.wikipedia.org/wiki/Beta_function&quot;&gt;beta function&lt;/a&gt; of &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;.</source>
          <target state="translated">1) Вычислить &lt;a href=&quot;https://en.wikipedia.org/wiki/Beta_function&quot;&gt;функцию беты&lt;/a&gt; из &lt;code&gt;x&lt;/code&gt; и &lt;code&gt;y&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="20e020a9e1ce8ef730c0d0cab5e6865004161b48" translate="yes" xml:space="preserve">
          <source>1) Computes the &lt;a href=&quot;https://en.wikipedia.org/wiki/Complex_conjugate&quot;&gt;complex conjugate&lt;/a&gt; of &lt;code&gt;z&lt;/code&gt; by reversing the sign of the imaginary part.</source>
          <target state="translated">1) Вычисляет &lt;a href=&quot;https://en.wikipedia.org/wiki/Complex_conjugate&quot;&gt;комплексное сопряжение&lt;/a&gt; с &lt;code&gt;z&lt;/code&gt; при изменении знака мнимой части.</target>
        </trans-unit>
        <trans-unit id="bed7cd35295f9a8460aa9f26a5fd423e0f5632e6" translate="yes" xml:space="preserve">
          <source>1) Computes the &lt;a href=&quot;https://en.wikipedia.org/wiki/Elliptic_integral#Complete_elliptic_integral_of_the_first_kind&quot;&gt;complete elliptic integral of the first kind&lt;/a&gt; of &lt;code&gt;k&lt;/code&gt;.</source>
          <target state="translated">1) Вычисляет &lt;a href=&quot;https://en.wikipedia.org/wiki/Elliptic_integral#Complete_elliptic_integral_of_the_first_kind&quot;&gt;полный эллиптический интеграл первого рода&lt;/a&gt; от &lt;code&gt;k&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="33b1e6d2c533af4241eec10ee1fc6c7a568c2e97" translate="yes" xml:space="preserve">
          <source>1) Computes the &lt;a href=&quot;https://en.wikipedia.org/wiki/Elliptic_integral#Complete_elliptic_integral_of_the_second_kind&quot;&gt;complete elliptic integral of the second kind&lt;/a&gt; of &lt;code&gt;k&lt;/code&gt;.</source>
          <target state="translated">1) Вычисляет &lt;a href=&quot;https://en.wikipedia.org/wiki/Elliptic_integral#Complete_elliptic_integral_of_the_second_kind&quot;&gt;полный эллиптический интеграл второго рода&lt;/a&gt; от &lt;code&gt;k&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d44887ee66b13404fd46bfb48d18761afabeb530" translate="yes" xml:space="preserve">
          <source>1) Computes the &lt;a href=&quot;https://en.wikipedia.org/wiki/Elliptic_integral#Complete_elliptic_integral_of_the_third_kind&quot;&gt;complete elliptic integral of the third kind&lt;/a&gt; of the arguments &lt;code&gt;k&lt;/code&gt; and &lt;code&gt;&amp;nu;&lt;/code&gt;.</source>
          <target state="translated">1) Вычисляет &lt;a href=&quot;https://en.wikipedia.org/wiki/Elliptic_integral#Complete_elliptic_integral_of_the_third_kind&quot;&gt;полный эллиптический интеграл третьего рода&lt;/a&gt; аргументов &lt;code&gt;k&lt;/code&gt; и &lt;code&gt;&amp;nu;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="34c90fd51c4b11003b3fbb3c42c725019e1184d5" translate="yes" xml:space="preserve">
          <source>1) Computes the &lt;a href=&quot;https://en.wikipedia.org/wiki/Elliptic_integral#Elliptic_integral_of_the_first_kind&quot;&gt;incomplete elliptic integral of the first kind&lt;/a&gt; of &lt;code&gt;k&lt;/code&gt; and &lt;code&gt;&amp;phi;&lt;/code&gt;.</source>
          <target state="translated">1) Вычислить &lt;a href=&quot;https://en.wikipedia.org/wiki/Elliptic_integral#Elliptic_integral_of_the_first_kind&quot;&gt;неполный эллиптический интеграл первого рода&lt;/a&gt; от &lt;code&gt;k&lt;/code&gt; и &lt;code&gt;&amp;phi;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="18c3b8c68fe18231bc4683a4dab18461556c8a6e" translate="yes" xml:space="preserve">
          <source>1) Computes the &lt;a href=&quot;https://en.wikipedia.org/wiki/Elliptic_integral#Incomplete_elliptic_integral_of_the_second_kind&quot;&gt;incomplete elliptic integral of the second kind&lt;/a&gt; of &lt;code&gt;k&lt;/code&gt; and &lt;code&gt;&amp;phi;&lt;/code&gt;.</source>
          <target state="translated">1) Вычисляет &lt;a href=&quot;https://en.wikipedia.org/wiki/Elliptic_integral#Incomplete_elliptic_integral_of_the_second_kind&quot;&gt;неполный эллиптический интеграл второго рода&lt;/a&gt; от &lt;code&gt;k&lt;/code&gt; и &lt;code&gt;&amp;phi;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d2a10c9a8d077e7cf3be02757334df49842de441" translate="yes" xml:space="preserve">
          <source>1) Computes the &lt;a href=&quot;https://en.wikipedia.org/wiki/Elliptic_integral#Incomplete_elliptic_integral_of_the_third_kind&quot;&gt;incomplete elliptic integral of the third kind&lt;/a&gt; of &lt;code&gt;k&lt;/code&gt;, &lt;code&gt;&amp;nu;&lt;/code&gt;, and &lt;code&gt;&amp;phi;&lt;/code&gt;.</source>
          <target state="translated">1) Вычислить &lt;a href=&quot;https://en.wikipedia.org/wiki/Elliptic_integral#Incomplete_elliptic_integral_of_the_third_kind&quot;&gt;неполный эллиптический интеграл третьего рода&lt;/a&gt; из &lt;code&gt;k&lt;/code&gt; , &lt;code&gt;&amp;nu;&lt;/code&gt; , и &lt;code&gt;&amp;phi;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a057675fa979fcdd978ffe3a864ce85d4f81ad27" translate="yes" xml:space="preserve">
          <source>1) Computes the &lt;a href=&quot;https://en.wikipedia.org/wiki/Exponential_integral&quot;&gt;exponential integral&lt;/a&gt; of &lt;code&gt;arg&lt;/code&gt;.</source>
          <target state="translated">1) Вычисляет &lt;a href=&quot;https://en.wikipedia.org/wiki/Exponential_integral&quot;&gt;экспоненциальный интеграл&lt;/a&gt; от &lt;code&gt;arg&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="194521a0cc3e924de1e24b00830776378f111bf6" translate="yes" xml:space="preserve">
          <source>1) Computes the &lt;a href=&quot;https://en.wikipedia.org/wiki/Laguerre_polynomials#Generalized_Laguerre_polynomials&quot;&gt;associated Laguerre polynomials&lt;/a&gt; of the degree &lt;code&gt;n&lt;/code&gt;, order &lt;code&gt;m&lt;/code&gt;, and argument &lt;code&gt;x&lt;/code&gt;</source>
          <target state="translated">1) Вычисляет &lt;a href=&quot;https://en.wikipedia.org/wiki/Laguerre_polynomials#Generalized_Laguerre_polynomials&quot;&gt;связанные многочлены Лагерра&lt;/a&gt; степени &lt;code&gt;n&lt;/code&gt; , порядка &lt;code&gt;m&lt;/code&gt; и аргумента &lt;code&gt;x&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="447c8a8a3695dfb2c0135ecd809d50a81ac60799" translate="yes" xml:space="preserve">
          <source>1) Computes the &lt;a href=&quot;https://en.wikipedia.org/wiki/Riemann_zeta_function&quot;&gt;Riemann zeta function&lt;/a&gt; of &lt;code&gt;arg&lt;/code&gt;.</source>
          <target state="translated">1) Вычисляет &lt;a href=&quot;https://en.wikipedia.org/wiki/Riemann_zeta_function&quot;&gt;дзета-функцию Римана&lt;/a&gt; от &lt;code&gt;arg&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ec4c5063d8c1e5217253c6566900149f02eb3ff3" translate="yes" xml:space="preserve">
          <source>1) Computes the inverse tangent of each pair of corresponding values from &lt;code&gt;y&lt;/code&gt; and &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">1) Вычисляет арктангенс каждой пары соответствующих значений из &lt;code&gt;y&lt;/code&gt; и &lt;code&gt;x&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9f69a96b516d331be6b80e58bbf178ccead673fa" translate="yes" xml:space="preserve">
          <source>1) Computes the non-associated &lt;a href=&quot;https://en.wikipedia.org/wiki/Laguerre_polynomials&quot;&gt;Laguerre polynomials&lt;/a&gt; of the degree &lt;code&gt;n&lt;/code&gt; and argument &lt;code&gt;x&lt;/code&gt;</source>
          <target state="translated">1) Вычисляет неассоциированные &lt;a href=&quot;https://en.wikipedia.org/wiki/Laguerre_polynomials&quot;&gt;полиномы Лагерра&lt;/a&gt; степени &lt;code&gt;n&lt;/code&gt; и аргумента &lt;code&gt;x&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="96823949bd54a22f8ca1311f8a8c38cf707e34c9" translate="yes" xml:space="preserve">
          <source>1) Computes the spherical associated Legendre function of degree &lt;code&gt;l&lt;/code&gt;, order &lt;code&gt;m&lt;/code&gt;, and polar angle &lt;code&gt;&amp;theta;&lt;/code&gt;.</source>
          <target state="translated">1) Вычисляет сферическую ассоциированную функцию Лежандра степени &lt;code&gt;l&lt;/code&gt; , порядка &lt;code&gt;m&lt;/code&gt; и полярного угла &lt;code&gt;&amp;theta;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="494b5451cb229192203200646404e640730476f1" translate="yes" xml:space="preserve">
          <source>1) Computes the unassociated &lt;a href=&quot;https://en.wikipedia.org/wiki/Legendre_polynomials&quot;&gt;Legendre polynomials&lt;/a&gt; of the degree &lt;code&gt;n&lt;/code&gt; and argument &lt;code&gt;x&lt;/code&gt;</source>
          <target state="translated">1) Вычисляет неассоциированные &lt;a href=&quot;https://en.wikipedia.org/wiki/Legendre_polynomials&quot;&gt;полиномы Лежандра&lt;/a&gt; степени &lt;code&gt;n&lt;/code&gt; и аргумента &lt;code&gt;x&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="021f4354ef970a1b656513a9b0be260507748eec" translate="yes" xml:space="preserve">
          <source>1) Computes the values of each element in the numeric array &lt;code&gt;base&lt;/code&gt; raised to the power specified by the corresponding element from the numeric array &lt;code&gt;exp&lt;/code&gt;.</source>
          <target state="translated">1) вычисляют значения каждого элемента в цифровом массиве &lt;code&gt;base&lt;/code&gt; , возведенной в степень , заданной с помощью соответствующего элемента из числового массива &lt;code&gt;exp&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="58d25c5a734cad90917e4f1983b210515311a450" translate="yes" xml:space="preserve">
          <source>1) Const reference to the value stored in the shared state. Accessing the value through this reference is undefined after the shared state has been destroyed.</source>
          <target state="translated">1)Константная ссылка на значение,сохраненное в общем состоянии.Доступ к значению по этой ссылке не определен после уничтожения общего состояния.</target>
        </trans-unit>
        <trans-unit id="1fda2d3df21980fc0c991439c0b017a5cbfcceaa" translate="yes" xml:space="preserve">
          <source>1) Constant</source>
          <target state="translated">1)Постоянный</target>
        </trans-unit>
        <trans-unit id="883376fb1cd5c259eb6c95ea63e4001892914fb5" translate="yes" xml:space="preserve">
          <source>1) Constant.</source>
          <target state="translated">1)Постоянно.</target>
        </trans-unit>
        <trans-unit id="8348152efcbbea63fdeddd6840b070be4fb7a774" translate="yes" xml:space="preserve">
          <source>1) Constructs &lt;code&gt;n&lt;/code&gt; objects of type &lt;code&gt;typename iterator_traits&amp;lt;ForwardIt&amp;gt;::value_type&lt;/code&gt; in the uninitialized storage starting at &lt;code&gt;first&lt;/code&gt; by &lt;a href=&quot;../language/default_initialization&quot;&gt;default-initialization&lt;/a&gt;, as if by</source>
          <target state="translated">1) Создает &lt;code&gt;n&lt;/code&gt; объектов типа &lt;code&gt;typename iterator_traits&amp;lt;ForwardIt&amp;gt;::value_type&lt;/code&gt; в неинициализированном хранилище, начиная &lt;code&gt;first&lt;/code&gt; с &lt;a href=&quot;../language/default_initialization&quot;&gt;инициализации&lt;/a&gt; по умолчанию , как если бы</target>
        </trans-unit>
        <trans-unit id="a76414f38c38467178589672432e927144d5fca1" translate="yes" xml:space="preserve">
          <source>1) Constructs &lt;code&gt;n&lt;/code&gt; objects of type &lt;code&gt;typename iterator_traits&amp;lt;ForwardIt&amp;gt;::value_type&lt;/code&gt; in the uninitialized storage starting at &lt;code&gt;first&lt;/code&gt; by &lt;a href=&quot;../language/value_initialization&quot;&gt;value-initialization&lt;/a&gt;, as if by</source>
          <target state="translated">1) Создает &lt;code&gt;n&lt;/code&gt; объектов типа &lt;code&gt;typename iterator_traits&amp;lt;ForwardIt&amp;gt;::value_type&lt;/code&gt; в неинициализированном хранилище, начиная &lt;code&gt;first&lt;/code&gt; с &lt;a href=&quot;../language/value_initialization&quot;&gt;инициализации значения&lt;/a&gt; , как если бы</target>
        </trans-unit>
        <trans-unit id="8cfad2bd0fe265d0360e216522ed743e93e164f6" translate="yes" xml:space="preserve">
          <source>1) Constructs a &lt;code&gt;polymorphic_allocator&lt;/code&gt; using the return value of &lt;code&gt;&lt;a href=&quot;../get_default_resource&quot;&gt;std::pmr::get_default_resource&lt;/a&gt;()&lt;/code&gt; as the underlying memory resource.</source>
          <target state="translated">1) Создает &lt;code&gt;polymorphic_allocator&lt;/code&gt; , используя возвращаемое значение &lt;code&gt;&lt;a href=&quot;../get_default_resource&quot;&gt;std::pmr::get_default_resource&lt;/a&gt;()&lt;/code&gt; в качестве основного ресурса памяти.</target>
        </trans-unit>
        <trans-unit id="caf585f0b2cbecc991027b2c5d5ade0ff9fa6a44" translate="yes" xml:space="preserve">
          <source>1) Constructs a &lt;code&gt;shared_lock&lt;/code&gt; with no associated mutex.</source>
          <target state="translated">1) Создает &lt;code&gt;shared_lock&lt;/code&gt; без ассоциированного мьютекса.</target>
        </trans-unit>
        <trans-unit id="c1691406fb44b80bf86d25e8199ea7826da306af" translate="yes" xml:space="preserve">
          <source>1) Constructs a &lt;code&gt;std::basic_filebuf&lt;/code&gt; object, initializing the base class by calling the default constructor of &lt;code&gt;&lt;a href=&quot;../basic_streambuf&quot;&gt;std::basic_streambuf&lt;/a&gt;&lt;/code&gt;. The created &lt;code&gt;basic_filebuf&lt;/code&gt; is not associated with a file, and &lt;code&gt;&lt;a href=&quot;is_open&quot;&gt;is_open()&lt;/a&gt;&lt;/code&gt; returns &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">1) Создает объект &lt;code&gt;std::basic_filebuf&lt;/code&gt; , инициализируя базовый класс, вызывая конструктор по умолчанию &lt;code&gt;&lt;a href=&quot;../basic_streambuf&quot;&gt;std::basic_streambuf&lt;/a&gt;&lt;/code&gt; . Созданный &lt;code&gt;basic_filebuf&lt;/code&gt; не связан с файлом, а &lt;code&gt;&lt;a href=&quot;is_open&quot;&gt;is_open()&lt;/a&gt;&lt;/code&gt; возвращает &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0ed2e91b75fa0fbaf5c3602ace32ee3a481e1def" translate="yes" xml:space="preserve">
          <source>1) Constructs a &lt;code&gt;std::default_delete&lt;/code&gt; object.</source>
          <target state="translated">1) Создает объект &lt;code&gt;std::default_delete&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d62c4ae5cb1598e1b293081929462849a710f111" translate="yes" xml:space="preserve">
          <source>1) Constructs a &lt;code&gt;std::packaged_task&lt;/code&gt; object with no task and no shared state.</source>
          <target state="translated">1) Создает объект &lt;code&gt;std::packaged_task&lt;/code&gt; без задачи и общего состояния.</target>
        </trans-unit>
        <trans-unit id="28c93deb18867bda8fc7f9df6c0fa46001aabb5a" translate="yes" xml:space="preserve">
          <source>1) Constructs a &lt;code&gt;std::strstreambuf&lt;/code&gt; object: initializes the base class by calling the default constructor of &lt;code&gt;&lt;a href=&quot;../basic_streambuf&quot;&gt;std::streambuf&lt;/a&gt;&lt;/code&gt;, initializes the buffer state to &quot;dynamic&quot; (the buffer will be allocated as needed), initializes allocated size to the provided &lt;code&gt;alsize&lt;/code&gt;, initializes the allocation and the deallocation functions to null (will use &lt;code&gt;new[]&lt;/code&gt; and &lt;code&gt;delete[]&lt;/code&gt;)</source>
          <target state="translated">1) Создает объект &lt;code&gt;std::strstreambuf&lt;/code&gt; : инициализирует базовый класс, вызывая конструктор по умолчанию &lt;code&gt;&lt;a href=&quot;../basic_streambuf&quot;&gt;std::streambuf&lt;/a&gt;&lt;/code&gt; , инициализирует состояние буфера как &amp;laquo;динамическое&amp;raquo; (буфер будет выделяться по мере необходимости), инициализирует выделенный размер для предоставленного &lt;code&gt;alsize&lt;/code&gt; , инициализирует функции выделения и освобождения нулями (будет использовать &lt;code&gt;new[]&lt;/code&gt; и &lt;code&gt;delete[]&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="64cc8935216e3aea1780a77626ea547c25b59b13" translate="yes" xml:space="preserve">
          <source>1) Constructs a &lt;code&gt;std::unique_ptr&lt;/code&gt; that owns nothing. Value-initializes the stored pointer and the stored deleter. Requires that &lt;code&gt;Deleter&lt;/code&gt; is &lt;a href=&quot;../../named_req/defaultconstructible&quot;&gt;DefaultConstructible&lt;/a&gt; and that construction does not throw an exception.</source>
          <target state="translated">1) Создает &lt;code&gt;std::unique_ptr&lt;/code&gt; , которому ничего не принадлежит. Значение - инициализирует сохраненный указатель и сохраненный удалитель. Требует, чтобы &lt;code&gt;Deleter&lt;/code&gt; был &lt;a href=&quot;../../named_req/defaultconstructible&quot;&gt;DefaultConstructible,&lt;/a&gt; и эта конструкция не выдает исключение.</target>
        </trans-unit>
        <trans-unit id="2d37caf20ed678ee45772f6932c0c59569e653b3" translate="yes" xml:space="preserve">
          <source>1) Constructs a &lt;code&gt;unique_lock&lt;/code&gt; with no associated mutex.</source>
          <target state="translated">1) Создает &lt;code&gt;unique_lock&lt;/code&gt; без ассоциированного мьютекса.</target>
        </trans-unit>
        <trans-unit id="b90797f613a746c0c6afab39848b6f01ca99d6fc" translate="yes" xml:space="preserve">
          <source>1) Constructs a &lt;code&gt;weekday_indexed&lt;/code&gt; from &lt;code&gt;*this&lt;/code&gt; and &lt;code&gt;index&lt;/code&gt;. The result represents the &lt;code&gt;index&lt;/code&gt;-th weekday in some yet-to-be-specified month. If &lt;code&gt;index&lt;/code&gt; is not in the range [1, 5] or if &lt;code&gt;!ok()&lt;/code&gt; the values held in the result is unspecified.</source>
          <target state="translated">1) Создает &lt;code&gt;weekday_indexed&lt;/code&gt; из &lt;code&gt;*this&lt;/code&gt; и &lt;code&gt;index&lt;/code&gt; . Результат представляет собой &lt;code&gt;index&lt;/code&gt; -й день недели в некотором еще не указанном месяце. Если &lt;code&gt;index&lt;/code&gt; не находится в диапазоне [1, 5] или если &lt;code&gt;!ok()&lt;/code&gt; значения, содержащиеся в результате, не определены.</target>
        </trans-unit>
        <trans-unit id="a877e234ee1a9651490a92e199612268aa6c085f" translate="yes" xml:space="preserve">
          <source>1) Constructs a distribution object with</source>
          <target state="translated">1)Строит объект распределения с</target>
        </trans-unit>
        <trans-unit id="5839abe97e388fd0beeb46fbe0cbbe23df700f9c" translate="yes" xml:space="preserve">
          <source>1) Constructs a distribution object with n = 1, &amp;rho;0 = 1, b0 = 0, and b1 = 1.</source>
          <target state="translated">1) Создает объект распределения с n = 1, &amp;rho;0 = 1, b0 = 0 и b1 = 1.</target>
        </trans-unit>
        <trans-unit id="5c36468c5ae16e3151bf49dbb6037065bdee5887" translate="yes" xml:space="preserve">
          <source>1) Constructs a non-array type &lt;code&gt;T&lt;/code&gt;. The arguments &lt;code&gt;args&lt;/code&gt; are passed to the constructor of &lt;code&gt;T&lt;/code&gt;. This overload only participates in overload resolution if &lt;code&gt;T&lt;/code&gt; is not an array type. The function is equivalent to:</source>
          <target state="translated">1) Создает не-массив типа &lt;code&gt;T&lt;/code&gt; . Аргументы &lt;code&gt;args&lt;/code&gt; передаются в конструктор &lt;code&gt;T&lt;/code&gt; . Эта перегрузка участвует только в разрешении перегрузки, если &lt;code&gt;T&lt;/code&gt; не является типом массива. Функция эквивалентна:</target>
        </trans-unit>
        <trans-unit id="b5bbbb231a62824534ca087741ebf1ecc513e1ae" translate="yes" xml:space="preserve">
          <source>1) Constructs a value at the location the iterator points to from &lt;code&gt;el&lt;/code&gt;.</source>
          <target state="translated">1) Создает значение в месте, на которое указывает итератор из &lt;code&gt;el&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c1e6b4ba149ed3478a1436d89169e5bb7c611e15" translate="yes" xml:space="preserve">
          <source>1) Constructs an &lt;code&gt;atomic_ref&lt;/code&gt; object referencing the object &lt;code&gt;obj&lt;/code&gt;. The behavior is undefined if &lt;code&gt;obj&lt;/code&gt; is not aligned to &lt;a href=&quot;required_alignment&quot;&gt;&lt;code&gt;required_alignment&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">1) &lt;code&gt;atomic_ref&lt;/code&gt; объект atomic_ref, ссылающийся на объект &lt;code&gt;obj&lt;/code&gt; . Поведение не определено, если &lt;code&gt;obj&lt;/code&gt; не выровнен с &lt;a href=&quot;required_alignment&quot;&gt; &lt;code&gt;required_alignment&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3f46d867616b349884c0eaec36a04a2b5e2f106e" translate="yes" xml:space="preserve">
          <source>1) Constructs an empty container.</source>
          <target state="translated">1)Создает пустой контейнер.</target>
        </trans-unit>
        <trans-unit id="bb6630efd81f0800437bcdd0637108688772c997" translate="yes" xml:space="preserve">
          <source>1) Constructs an empty object.</source>
          <target state="translated">1)Строит пустой объект.</target>
        </trans-unit>
        <trans-unit id="4aba85a0be5aa34c1a435f0e6a4e3db1b5c1bb67" translate="yes" xml:space="preserve">
          <source>1) Constructs an empty path.</source>
          <target state="translated">1)Строит пустой путь.</target>
        </trans-unit>
        <trans-unit id="92b1b20a2cb45b6fe0dfa5cf07ed62cbeefa5879" translate="yes" xml:space="preserve">
          <source>1) Constructs an empty span whose &lt;code&gt;data() == nullptr&lt;/code&gt; and &lt;code&gt;size() == 0&lt;/code&gt;. This overload only participates in overload resolution if &lt;code&gt;extent == 0 || extent == &lt;a href=&quot;dynamic_extent&quot;&gt;std::dynamic_extent&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">1) Создает пустой диапазон, &lt;code&gt;data() == nullptr&lt;/code&gt; и &lt;code&gt;size() == 0&lt;/code&gt; . Эта перегрузка участвует только в разрешении перегрузки, если &lt;code&gt;extent == 0 || extent == &lt;a href=&quot;dynamic_extent&quot;&gt;std::dynamic_extent&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3c2ed7e86ad1634668a4421e8843d4216d314452" translate="yes" xml:space="preserve">
          <source>1) Constructs an end-of-stream iterator.</source>
          <target state="translated">1)Строит итератор в конце потока.</target>
        </trans-unit>
        <trans-unit id="6a91b7a4528438ec1c732b76f2082be352aaa60b" translate="yes" xml:space="preserve">
          <source>1) Constructs an object of type &lt;code&gt;T&lt;/code&gt; and wraps it in a &lt;code&gt;&lt;a href=&quot;../shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&lt;/code&gt; using &lt;code&gt;args&lt;/code&gt; as the parameter list for the constructor of &lt;code&gt;T&lt;/code&gt;. The object is constructed as if by the expression &lt;code&gt;::new (pv) T(&lt;a href=&quot;../../utility/forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;Args&amp;gt;(args)...)&lt;/code&gt;, where &lt;code&gt;pv&lt;/code&gt; is an internal &lt;code&gt;void*&lt;/code&gt; pointer to storage suitable to hold an object of type &lt;code&gt;T&lt;/code&gt;. The storage is typically larger than &lt;code&gt;sizeof(T)&lt;/code&gt; in order to use one allocation for both the control block of the shared pointer and the &lt;code&gt;T&lt;/code&gt; object. The &lt;code&gt;std::shared_ptr&lt;/code&gt; constructor called by this function enables &lt;code&gt;shared_from_this&lt;/code&gt; with a pointer to the newly constructed object of type &lt;code&gt;T&lt;/code&gt;. This overload only participates in overload resolution if T is not an array type</source>
          <target state="translated">1) Создает объект типа &lt;code&gt;T&lt;/code&gt; и оборачивает его в &lt;code&gt;&lt;a href=&quot;../shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&lt;/code&gt; с использованием &lt;code&gt;args&lt;/code&gt; как список параметров для конструктора &lt;code&gt;T&lt;/code&gt; . Объект создается как бы выражением &lt;code&gt;::new (pv) T(&lt;a href=&quot;../../utility/forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;Args&amp;gt;(args)...)&lt;/code&gt; , где &lt;code&gt;pv&lt;/code&gt; - внутренний указатель &lt;code&gt;void*&lt;/code&gt; на хранилище, подходящее для хранения объекта типа &lt;code&gt;T&lt;/code&gt; , Хранилище обычно больше, чем &lt;code&gt;sizeof(T)&lt;/code&gt; , чтобы использовать одно выделение как для блока управления общего указателя, так и для &lt;code&gt;T&lt;/code&gt; - объекта. Конструктор &lt;code&gt;std::shared_ptr&lt;/code&gt; вызываемый этой функцией, включает &lt;code&gt;shared_from_this&lt;/code&gt; с указателем создаваемого объекта типа &lt;code&gt;T&lt;/code&gt; . Эта перегрузка участвует только в разрешении перегрузки, если T не является типом массива</target>
        </trans-unit>
        <trans-unit id="c65fce56c4a3fe00bfc3974bed79655a9cad1369" translate="yes" xml:space="preserve">
          <source>1) Constructs an object of type &lt;code&gt;T&lt;/code&gt; and wraps it in a &lt;code&gt;&lt;a href=&quot;../shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&lt;/code&gt; using &lt;code&gt;args&lt;/code&gt; as the parameter list for the constructor of &lt;code&gt;T&lt;/code&gt;. The object is constructed as if by the expression &lt;code&gt;&lt;a href=&quot;../allocator_traits&quot;&gt;std::allocator_traits&lt;/a&gt;&amp;lt;A2&amp;gt;::construct(a, pv, v)&lt;/code&gt;, where &lt;code&gt;pv&lt;/code&gt; is an internal &lt;code&gt;void*&lt;/code&gt; pointer to storage suitable to hold an object of type &lt;code&gt;T&lt;/code&gt; and &lt;code&gt;a&lt;/code&gt; is a copy of the allocator rebound to &lt;code&gt;&lt;a href=&quot;../../types/remove_cv&quot;&gt;std::remove_cv_t&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt;. The storage is typically larger than &lt;code&gt;sizeof(T)&lt;/code&gt; in order to use one allocation for both the control block of the shared pointer and the &lt;code&gt;T&lt;/code&gt; object. The &lt;code&gt;std::shared_ptr&lt;/code&gt; constructor called by this function enables &lt;code&gt;shared_from_this&lt;/code&gt; with a pointer to the newly constructed object of type &lt;code&gt;T&lt;/code&gt;. All memory allocation is done using a copy of &lt;code&gt;alloc&lt;/code&gt;, which must satisfy the &lt;a href=&quot;../../named_req/allocator&quot;&gt;Allocator&lt;/a&gt; requirements. This overload only participates in overload resolution if T is not an array type</source>
          <target state="translated">1) Создает объект типа &lt;code&gt;T&lt;/code&gt; и оборачивает его в &lt;code&gt;&lt;a href=&quot;../shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&lt;/code&gt; с использованием &lt;code&gt;args&lt;/code&gt; как список параметров для конструктора &lt;code&gt;T&lt;/code&gt; . Объект &lt;code&gt;&lt;a href=&quot;../allocator_traits&quot;&gt;std::allocator_traits&lt;/a&gt;&amp;lt;A2&amp;gt;::construct(a, pv, v)&lt;/code&gt; как бы выражением &lt;a href=&quot;../allocator_traits&quot;&gt;std :: allocator_traits&lt;/a&gt; &amp;lt;A2&amp;gt; :: construct (a, pv, v) , где &lt;code&gt;pv&lt;/code&gt; - внутренний указатель &lt;code&gt;void*&lt;/code&gt; на хранилище, подходящее для хранения объекта типа &lt;code&gt;T&lt;/code&gt; , а &lt;code&gt;a&lt;/code&gt; - копия &lt;code&gt;&lt;a href=&quot;../../types/remove_cv&quot;&gt;std::remove_cv_t&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt; до std :: remove_cv_t &amp;lt;T&amp;gt; . Хранилище обычно больше, чем &lt;code&gt;sizeof(T)&lt;/code&gt; , чтобы использовать одно выделение как для блока управления общего указателя, так и для &lt;code&gt;T&lt;/code&gt; объект. &lt;code&gt;std::shared_ptr&lt;/code&gt; конструктор вызывается эта функция позволяет &lt;code&gt;shared_from_this&lt;/code&gt; с указателем на вновь построенный объект типа &lt;code&gt;T&lt;/code&gt; . Все выделение памяти выполняется с использованием копии &lt;code&gt;alloc&lt;/code&gt; , которая должна удовлетворять требованиям &lt;a href=&quot;../../named_req/allocator&quot;&gt;Allocator&lt;/a&gt; . Эта перегрузка участвует только в разрешении перегрузки, если T не является типом массива</target>
        </trans-unit>
        <trans-unit id="d78eaa4f8c9d96c9388558353abf67888821bd40" translate="yes" xml:space="preserve">
          <source>1) Constructs an object of type &lt;code&gt;std::condition_variable&lt;/code&gt;.</source>
          <target state="translated">1) Создает объект типа &lt;code&gt;std::condition_variable&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c33554f7a405b880b69fcd197b5b45d0faf555d7" translate="yes" xml:space="preserve">
          <source>1) Constructs an object of type &lt;code&gt;std::condition_variable_any&lt;/code&gt;.</source>
          <target state="translated">1) Создает объект типа &lt;code&gt;std::condition_variable_any&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4dca4893623f5a9eb91426447332e43a629e5e08" translate="yes" xml:space="preserve">
          <source>1) Constructs an object that</source>
          <target state="translated">1)Строит объект,который</target>
        </trans-unit>
        <trans-unit id="a42c5463387778d35ce09fb74ca7c06a1d5d3fe5" translate="yes" xml:space="preserve">
          <source>1) Constructs empty container. Sets &lt;code&gt;max_load_factor()&lt;/code&gt; to 1.0. For the default constructor, the number of buckets is implementation-defined.</source>
          <target state="translated">1) Создает пустой контейнер. Устанавливает &lt;code&gt;max_load_factor()&lt;/code&gt; в 1,0. Для конструктора по умолчанию количество сегментов определяется реализацией.</target>
        </trans-unit>
        <trans-unit id="cc74e3008936c370fbc2e91fcb346c72690c77ec" translate="yes" xml:space="preserve">
          <source>1) Constructs error code with default value. Equivalent to &lt;code&gt;error_code(0, &lt;a href=&quot;../system_category&quot;&gt;std::system_category&lt;/a&gt;())&lt;/code&gt;.</source>
          <target state="translated">1) Создает код ошибки со значением по умолчанию. Эквивалентен &lt;code&gt;error_code(0, &lt;a href=&quot;../system_category&quot;&gt;std::system_category&lt;/a&gt;())&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f925a3f60c069a032e3937c5003b55a8c2dfe979" translate="yes" xml:space="preserve">
          <source>1) Constructs objects of type &lt;code&gt;typename iterator_traits&amp;lt;ForwardIt&amp;gt;::value_type&lt;/code&gt; in the uninitialized storage designated by the range &lt;code&gt;[first, last)&lt;/code&gt; by &lt;a href=&quot;../language/default_initialization&quot;&gt;default-initialization&lt;/a&gt;, as if by</source>
          <target state="translated">1) Создает объекты типа &lt;code&gt;typename iterator_traits&amp;lt;ForwardIt&amp;gt;::value_type&lt;/code&gt; в неинициализированном хранилище, обозначенном диапазоном &lt;code&gt;[first, last)&lt;/code&gt; по &lt;a href=&quot;../language/default_initialization&quot;&gt;умолчанию-инициализацией&lt;/a&gt; , как если бы</target>
        </trans-unit>
        <trans-unit id="5ca8d62a3455adf4d9e43d7b921708a6d8a9a285" translate="yes" xml:space="preserve">
          <source>1) Constructs objects of type &lt;code&gt;typename iterator_traits&amp;lt;ForwardIt&amp;gt;::value_type&lt;/code&gt; in the uninitialized storage designated by the range &lt;code&gt;[first, last)&lt;/code&gt; by &lt;a href=&quot;../language/value_initialization&quot;&gt;value-initialization&lt;/a&gt;, as if by</source>
          <target state="translated">1) Создает объекты типа &lt;code&gt;typename iterator_traits&amp;lt;ForwardIt&amp;gt;::value_type&lt;/code&gt; в неинициализированном хранилище, обозначенном диапазоном &lt;code&gt;[first, last)&lt;/code&gt; путем &lt;a href=&quot;../language/value_initialization&quot;&gt;инициализации значения&lt;/a&gt; , как если бы</target>
        </trans-unit>
        <trans-unit id="c7e73e079cc70c58b19eccb9290637293ccbae99" translate="yes" xml:space="preserve">
          <source>1) Constructs the &lt;code&gt;auto_ptr&lt;/code&gt; with pointer &lt;code&gt;p&lt;/code&gt;.</source>
          <target state="translated">1) Создает &lt;code&gt;auto_ptr&lt;/code&gt; с указателем &lt;code&gt;p&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0164e8149e0956c863ac9c36b9359f6da1d2d078" translate="yes" xml:space="preserve">
          <source>1) Constructs the &lt;code&gt;basic_istream&lt;/code&gt; object, assigning initial values to the base class by calling &lt;code&gt;basic_ios::init(sb)&lt;/code&gt;. The value of &lt;code&gt;gcount()&lt;/code&gt; is initialized to zero.</source>
          <target state="translated">1) &lt;code&gt;basic_istream&lt;/code&gt; объект basic_istream , присваивая начальные значения базовому классу, вызывая &lt;code&gt;basic_ios::init(sb)&lt;/code&gt; . Значение &lt;code&gt;gcount()&lt;/code&gt; инициализируется нулем.</target>
        </trans-unit>
        <trans-unit id="9f59a9d9a66d857f281383b9ee9838b4c7e8b9e9" translate="yes" xml:space="preserve">
          <source>1) Constructs the &lt;code&gt;basic_ostream&lt;/code&gt; object, assigning initial values to the base class by calling &lt;code&gt;&lt;a href=&quot;../basic_ios/init&quot;&gt;basic_ios::init(sb)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">1) &lt;code&gt;basic_ostream&lt;/code&gt; объект basic_ostream , присваивая начальные значения базовому классу, вызывая &lt;code&gt;&lt;a href=&quot;../basic_ios/init&quot;&gt;basic_ios::init(sb)&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e770895769dd6c60169d7f4420f35a940b3c3d4d" translate="yes" xml:space="preserve">
          <source>1) Constructs the &lt;code&gt;basic_streambuf&lt;/code&gt; object, initializes the six pointer members (&lt;code&gt;eback()&lt;/code&gt;, &lt;code&gt;gptr()&lt;/code&gt;, &lt;code&gt;egptr()&lt;/code&gt;, &lt;code&gt;pbase()&lt;/code&gt;, &lt;code&gt;pptr()&lt;/code&gt;, and &lt;code&gt;epptr()&lt;/code&gt;) to null pointer values, and the locale member to &lt;code&gt;&lt;a href=&quot;../../locale/locale&quot;&gt;std::locale&lt;/a&gt;()&lt;/code&gt;, a copy of the global C++ locale at the time of construction.</source>
          <target state="translated">1) &lt;code&gt;basic_streambuf&lt;/code&gt; объект basic_streambuf , инициализирует шесть членов-указателей ( &lt;code&gt;eback()&lt;/code&gt; , &lt;code&gt;gptr()&lt;/code&gt; , &lt;code&gt;egptr()&lt;/code&gt; , &lt;code&gt;pbase()&lt;/code&gt; , &lt;code&gt;pptr()&lt;/code&gt; и &lt;code&gt;epptr()&lt;/code&gt; ) для нулевых значений указателя, а член языкового стандарта для &lt;code&gt;&lt;a href=&quot;../../locale/locale&quot;&gt;std::locale&lt;/a&gt;()&lt;/code&gt; , копия глобальной локали C ++ во время создания.</target>
        </trans-unit>
        <trans-unit id="5a712e507b705a86029303f1b2e6b91abd34eca3" translate="yes" xml:space="preserve">
          <source>1) Constructs the complex number from real and imaginary parts.</source>
          <target state="translated">1)Построит комплексное число из реальной и мнимой частей.</target>
        </trans-unit>
        <trans-unit id="4d3565cc629e222a14a77967cd93c38e99b2c25e" translate="yes" xml:space="preserve">
          <source>1) Constructs the end iterator.</source>
          <target state="translated">1)Создает концевой итератор.</target>
        </trans-unit>
        <trans-unit id="36c43a3b623f36dd562263833f62942dcde59be1" translate="yes" xml:space="preserve">
          <source>1) Constructs the end-of-stream iterator, value-initializes the stored value. This constructor is constexpr if the initializer in the definition &lt;code&gt;auto x = T();&lt;/code&gt; is a constant initializer.</source>
          <target state="translated">1) Создает итератор конца потока, инициализирует значение сохраненного значения. Этот конструктор является constexpr, если инициализатор в определении &lt;code&gt;auto x = T();&lt;/code&gt; постоянный инициализатор</target>
        </trans-unit>
        <trans-unit id="567317c97bb9e808725c51c31daff371c53a7183" translate="yes" xml:space="preserve">
          <source>1) Constructs the iterator with &lt;code&gt;stream&lt;/code&gt; as the associated stream and &lt;code&gt;delim&lt;/code&gt; as the delimiter.</source>
          <target state="translated">1) Создает итератор с &lt;code&gt;stream&lt;/code&gt; в качестве ассоциированного потока и &lt;code&gt;delim&lt;/code&gt; в качестве разделителя.</target>
        </trans-unit>
        <trans-unit id="21e8282094e94dff47b05cfa55b86fa929f80bfb" translate="yes" xml:space="preserve">
          <source>1) Constructs the iterator with the private &lt;code&gt;streambuf_type*&lt;/code&gt; member set to &lt;code&gt;buffer&lt;/code&gt; and the failed() bit set to &lt;code&gt;false&lt;/code&gt;. The behavior is undefined if &lt;code&gt;buffer&lt;/code&gt; is a null pointer.</source>
          <target state="translated">1) Создает итератор с &lt;code&gt;streambuf_type*&lt;/code&gt; членом streambuf_type *, установленным в &lt;code&gt;buffer&lt;/code&gt; и битом fail (), установленным в &lt;code&gt;false&lt;/code&gt; . Поведение не определено, если &lt;code&gt;buffer&lt;/code&gt; является нулевым указателем.</target>
        </trans-unit>
        <trans-unit id="c0e385bee1b61c9f84d4023fcbdea59f912b0207" translate="yes" xml:space="preserve">
          <source>1) Constructs the mutex. The mutex is in unlocked state after the call.</source>
          <target state="translated">1)Создает мьютекс.После вызова мьютекс находится в разблокированном состоянии.</target>
        </trans-unit>
        <trans-unit id="6facaef49db759622faeb9fa50ba66a91993a2b8" translate="yes" xml:space="preserve">
          <source>1) Constructs the mutex. The mutex is in unlocked state after the constructor completes.</source>
          <target state="translated">1)Создает мьютекс.Мьютекс находится в разблокированном состоянии после завершения строительства.</target>
        </trans-unit>
        <trans-unit id="29377ade75ac8ee862d1d21eb062d5bb53a5931b" translate="yes" xml:space="preserve">
          <source>1) Constructs with error code &lt;code&gt;ec&lt;/code&gt;</source>
          <target state="translated">1) Создает с кодом ошибки &lt;code&gt;ec&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0535a299ea56e25c15331c583b9b9f5ad995759c" translate="yes" xml:space="preserve">
          <source>1) Conversion that involves pointer to bool or pointer-to-member to bool is worse than the one that doesn't</source>
          <target state="translated">1)Преобразование,включающее указатель на bool или указатель на члена в bool,хуже,чем то,которое не включает в себя</target>
        </trans-unit>
        <trans-unit id="e16d54f0bf7a4de50ea66eef76a20a090e2f4413" translate="yes" xml:space="preserve">
          <source>1) Converts &lt;code&gt;byte&lt;/code&gt; as if it was a string of length &lt;code&gt;1&lt;/code&gt; to wide_string.</source>
          <target state="translated">1) Преобразует &lt;code&gt;byte&lt;/code&gt; как если бы это была строка длиной &lt;code&gt;1&lt;/code&gt; в wide_string.</target>
        </trans-unit>
        <trans-unit id="197a10e3da9ede6e2bf81aba04bc89f7b2c98603" translate="yes" xml:space="preserve">
          <source>1) Converts &lt;code&gt;wchar&lt;/code&gt; as if it was a string of length &lt;code&gt;1&lt;/code&gt;, to &lt;code&gt;byte_string&lt;/code&gt;.</source>
          <target state="translated">1) Преобразует &lt;code&gt;wchar&lt;/code&gt; , как если бы это была строка длиной &lt;code&gt;1&lt;/code&gt; , в &lt;code&gt;byte_string&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ce60559adca1ecbc763b846b0ebcd3ea0bcd2729" translate="yes" xml:space="preserve">
          <source>1) Converts &lt;code&gt;x&lt;/code&gt; to &lt;code&gt;T&amp;amp;&lt;/code&gt; as if by &lt;code&gt;T&amp;amp; t = &lt;a href=&quot;../../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;U&amp;gt;(x);&lt;/code&gt;, then stores a reference to &lt;code&gt;t&lt;/code&gt;. This overload only participates in overload resolution if &lt;code&gt;typename &lt;a href=&quot;../../../types/decay&quot;&gt;std::decay&lt;/a&gt;&amp;lt;U&amp;gt;::type&lt;/code&gt; is not the same type as &lt;code&gt;reference_wrapper&lt;/code&gt; and the expression &lt;code&gt;FUN(&lt;a href=&quot;../../declval&quot;&gt;std::declval&lt;/a&gt;&amp;lt;U&amp;gt;())&lt;/code&gt; is well-formed, where &lt;code&gt;FUN&lt;/code&gt; names the set of imaginary functions</source>
          <target state="translated">1) Преобразует &lt;code&gt;x&lt;/code&gt; в &lt;code&gt;T&amp;amp;&lt;/code&gt; как если бы &lt;code&gt;T&amp;amp; t = &lt;a href=&quot;../../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;U&amp;gt;(x);&lt;/code&gt; , а затем сохраняет ссылку на &lt;code&gt;t&lt;/code&gt; . Эта перегрузка участвует только в разрешении перегрузки, если &lt;code&gt;typename &lt;a href=&quot;../../../types/decay&quot;&gt;std::decay&lt;/a&gt;&amp;lt;U&amp;gt;::type&lt;/code&gt; не совпадает с типом &lt;code&gt;reference_wrapper&lt;/code&gt; , и выражение &lt;code&gt;FUN(&lt;a href=&quot;../../declval&quot;&gt;std::declval&lt;/a&gt;&amp;lt;U&amp;gt;())&lt;/code&gt; правильно сформировано, где &lt;code&gt;FUN&lt;/code&gt; называет имя набор мнимых функций</target>
        </trans-unit>
        <trans-unit id="3b2e425231980e3b26025193db6c0158ff8d1aa6" translate="yes" xml:space="preserve">
          <source>1) Converts a signed decimal integer to a string with the same content as what &lt;code&gt;&lt;a href=&quot;../../io/c/fprintf&quot;&gt;std::sprintf&lt;/a&gt;(buf, &quot;%d&quot;, value)&lt;/code&gt; would produce for sufficiently large &lt;code&gt;buf&lt;/code&gt;.</source>
          <target state="translated">1) Преобразует десятичное целое число со знаком в строку с тем же содержимым, что и &lt;code&gt;&lt;a href=&quot;../../io/c/fprintf&quot;&gt;std::sprintf&lt;/a&gt;(buf, &quot;%d&quot;, value)&lt;/code&gt; , для достаточно большого &lt;code&gt;buf&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8e981b67a7ad4cb8a3d3ec53bfb06c19e2cd41df" translate="yes" xml:space="preserve">
          <source>1) Converts a signed decimal integer to a wide string with the same content as what &lt;code&gt;&lt;a href=&quot;../../io/c/fwprintf&quot;&gt;std::swprintf&lt;/a&gt;(buf, sz, L&quot;%d&quot;, value)&lt;/code&gt; would produce for sufficiently large &lt;code&gt;buf&lt;/code&gt;.</source>
          <target state="translated">1) Преобразует десятичное целое число со знаком в широкую строку с тем же содержимым, что и &lt;code&gt;&lt;a href=&quot;../../io/c/fwprintf&quot;&gt;std::swprintf&lt;/a&gt;(buf, sz, L&quot;%d&quot;, value)&lt;/code&gt; , для достаточно большого &lt;code&gt;buf&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4dc8e4275413329fa1e66540999bd4062579b6f2" translate="yes" xml:space="preserve">
          <source>1) Converts the &lt;code&gt;file_time&lt;/code&gt;&lt;code&gt;t&lt;/code&gt; to a &lt;code&gt;sys_time&lt;/code&gt; representing the same point in time.</source>
          <target state="translated">1) Преобразует &lt;code&gt;file_time&lt;/code&gt; &lt;code&gt;t&lt;/code&gt; в &lt;code&gt;sys_time&lt;/code&gt; , представляющий тот же момент времени.</target>
        </trans-unit>
        <trans-unit id="bbc6867b0f47d015a04ea763b2e464a464fd6f94" translate="yes" xml:space="preserve">
          <source>1) Converts the &lt;code&gt;file_time&lt;/code&gt;&lt;code&gt;t&lt;/code&gt; to a &lt;code&gt;utc_time&lt;/code&gt; representing the same point in time.</source>
          <target state="translated">1) Преобразует &lt;code&gt;file_time&lt;/code&gt; &lt;code&gt;t&lt;/code&gt; в &lt;code&gt;utc_time&lt;/code&gt; , представляющий тот же момент времени.</target>
        </trans-unit>
        <trans-unit id="076c6e693f308ce0f6a0c89dfaa4b7efdd201143" translate="yes" xml:space="preserve">
          <source>1) Converts the two durations to their common type and creates a duration whose tick count is the sum of the tick counts after conversion.</source>
          <target state="translated">1)Преобразует две длительности в их общий тип и создает длительность,чей тиковый номер является суммой тиковых номеров после преобразования.</target>
        </trans-unit>
        <trans-unit id="888ab527c89c913804d1c2c29b389f2611f52687" translate="yes" xml:space="preserve">
          <source>1) Copies &lt;code&gt;count&lt;/code&gt; elements from a range beginning at &lt;code&gt;first&lt;/code&gt; to an uninitialized memory area beginning at &lt;code&gt;d_first&lt;/code&gt; as if by</source>
          <target state="translated">1) Копирует &lt;code&gt;count&lt;/code&gt; элементов из диапазона, начинающегося &lt;code&gt;first&lt;/code&gt; в неинициализированную область памяти, начинающуюся с &lt;code&gt;d_first&lt;/code&gt; , как если бы</target>
        </trans-unit>
        <trans-unit id="a5b971875873e04ebbd8f3dd90705985a75d4ec9" translate="yes" xml:space="preserve">
          <source>1) Copies all elements in the range &lt;code&gt;[first, last)&lt;/code&gt; starting from first and proceeding to last - 1. The behavior is undefined if &lt;code&gt;d_first&lt;/code&gt; is within the range &lt;code&gt;[first, last)&lt;/code&gt;. In this case, &lt;code&gt;&lt;a href=&quot;copy_backward&quot;&gt;std::copy_backward&lt;/a&gt;&lt;/code&gt; may be used instead.</source>
          <target state="translated">1) Копирует все элементы в диапазоне &lt;code&gt;[first, last)&lt;/code&gt; начиная с первого и заканчивая последним - 1. Поведение не определено, если &lt;code&gt;d_first&lt;/code&gt; находится в диапазоне &lt;code&gt;[first, last)&lt;/code&gt; . В этом случае вместо этого можно использовать &lt;code&gt;&lt;a href=&quot;copy_backward&quot;&gt;std::copy_backward&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="06ea4d57b4c85fc6e7bcfe101f3b3fdc533f62f9" translate="yes" xml:space="preserve">
          <source>1) Copies characters in the range &lt;code&gt;[first,last)&lt;/code&gt; to &lt;code&gt;out&lt;/code&gt;, replacing any sequences that match &lt;code&gt;re&lt;/code&gt; with characters formatted by &lt;code&gt;fmt&lt;/code&gt;. In other words:</source>
          <target state="translated">1) Копирует символы из диапазона &lt;code&gt;[first,last)&lt;/code&gt; в &lt;code&gt;out&lt;/code&gt; , заменяя любые последовательности, соответствующие &lt;code&gt;re&lt;/code&gt; , символами, отформатированными в &lt;code&gt;fmt&lt;/code&gt; . Другими словами:</target>
        </trans-unit>
        <trans-unit id="3c0e21f1d72032ced3cf99d25a163352df8fb16d" translate="yes" xml:space="preserve">
          <source>1) Copies elements from the range &lt;code&gt;[first, last)&lt;/code&gt; to an uninitialized memory area beginning at &lt;code&gt;d_first&lt;/code&gt; as if by</source>
          <target state="translated">1) Копирует элементы из диапазона &lt;code&gt;[first, last)&lt;/code&gt; в неинициализированную область памяти, начиная с &lt;code&gt;d_first&lt;/code&gt; , как если бы</target>
        </trans-unit>
        <trans-unit id="eaa8b895fbfe22af946e0d1f21d2e21b2ccbf6f4" translate="yes" xml:space="preserve">
          <source>1) Copies exactly &lt;code&gt;count&lt;/code&gt; values from the range beginning at &lt;code&gt;first&lt;/code&gt; to the range beginning at &lt;code&gt;result&lt;/code&gt;. Formally, for each non-negative integer &lt;code&gt;i &amp;lt; n&lt;/code&gt;, performs &lt;code&gt;*(result + i) = *(first + i)&lt;/code&gt;. Overlap of ranges is not permitted.</source>
          <target state="translated">1) Копия точно &lt;code&gt;count&lt;/code&gt; значения с начала диапазона на &lt;code&gt;first&lt;/code&gt; в диапазон , начиная с &lt;code&gt;result&lt;/code&gt; . Формально для каждого неотрицательного целого числа &lt;code&gt;i &amp;lt; n&lt;/code&gt; выполняется &lt;code&gt;*(result + i) = *(first + i)&lt;/code&gt; . Перекрытие диапазонов не допускается.</target>
        </trans-unit>
        <trans-unit id="2428bbef7516a0c37d09fb2808331b76c9c46ca3" translate="yes" xml:space="preserve">
          <source>1) Copies the elements from the range &lt;code&gt;[first, last)&lt;/code&gt; to another range beginning at &lt;code&gt;d_first&lt;/code&gt; in such a way that the elements in the new range are in reverse order.</source>
          <target state="translated">1) Копирует элементы из диапазона &lt;code&gt;[first, last)&lt;/code&gt; в другой диапазон, начинающийся с &lt;code&gt;d_first&lt;/code&gt; , таким образом, что элементы в новом диапазоне располагаются в обратном порядке.</target>
        </trans-unit>
        <trans-unit id="4614ab1a6d2346fd0652f2db85a8f495164eebe2" translate="yes" xml:space="preserve">
          <source>1) Copies the elements from the range &lt;code&gt;[first, last)&lt;/code&gt; to two different ranges depending on the value returned by the predicate &lt;code&gt;p&lt;/code&gt;. The elements that satisfy the predicate &lt;code&gt;p&lt;/code&gt; are copied to the range beginning at &lt;code&gt;d_first_true&lt;/code&gt;. The rest of the elements are copied to the range beginning at &lt;code&gt;d_first_false&lt;/code&gt;.</source>
          <target state="translated">1) Копирует элементы из диапазона &lt;code&gt;[first, last)&lt;/code&gt; в два разных диапазона в зависимости от значения, возвращаемого предикатом &lt;code&gt;p&lt;/code&gt; . Элементы, которые удовлетворяют предикату &lt;code&gt;p&lt;/code&gt; , копируются в диапазон, начинающийся с &lt;code&gt;d_first_true&lt;/code&gt; . Остальные элементы копируются в диапазон, начинающийся с &lt;code&gt;d_first_false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="98b63d2d9267bc9998d8406ce508196f6fbe30f0" translate="yes" xml:space="preserve">
          <source>1) Copies the elements from the range &lt;code&gt;[first, last)&lt;/code&gt;, to another range beginning at &lt;code&gt;d_first&lt;/code&gt; in such a way, that the element &lt;code&gt;n_first&lt;/code&gt; becomes the first element of the new range and &lt;code&gt;n_first - 1&lt;/code&gt; becomes the last element.</source>
          <target state="translated">1) Копирует элементы из диапазона &lt;code&gt;[first, last)&lt;/code&gt; в другой диапазон, начинающийся с &lt;code&gt;d_first&lt;/code&gt; , таким образом, что элемент &lt;code&gt;n_first&lt;/code&gt; становится первым элементом нового диапазона, а &lt;code&gt;n_first - 1&lt;/code&gt; становится последним элементом.</target>
        </trans-unit>
        <trans-unit id="84fa46dde26717bac9ce3f7378e2314898b8e7d1" translate="yes" xml:space="preserve">
          <source>1) Copies the given &lt;code&gt;value&lt;/code&gt; to an uninitialized memory area, defined by the range &lt;code&gt;[first, last)&lt;/code&gt; as if by</source>
          <target state="translated">1) Копирует данное &lt;code&gt;value&lt;/code&gt; в неинициализированную область памяти, определенную диапазоном &lt;code&gt;[first, last)&lt;/code&gt; как если бы</target>
        </trans-unit>
        <trans-unit id="3b6ae258a56e6dc4788e6367a261c4cc04b85921" translate="yes" xml:space="preserve">
          <source>1) Copies the given value &lt;code&gt;value&lt;/code&gt; to the first &lt;code&gt;count&lt;/code&gt; elements in an uninitialized memory area beginning at &lt;code&gt;first&lt;/code&gt; as if by</source>
          <target state="translated">1) Копирует заданное значение &lt;code&gt;value&lt;/code&gt; в первые элементы &lt;code&gt;count&lt;/code&gt; в неинициализированной области памяти, начиная &lt;code&gt;first&lt;/code&gt; как если бы</target>
        </trans-unit>
        <trans-unit id="09509cf45826977c55e1dec4baf1527dc8caefbb" translate="yes" xml:space="preserve">
          <source>1) Copy assignment is not allowed.</source>
          <target state="translated">1)Назначение копирования не разрешено.</target>
        </trans-unit>
        <trans-unit id="3a5410a123be4ffd9084e19a34d5ec5f619c3034" translate="yes" xml:space="preserve">
          <source>1) Copy assignment operator is deleted, &lt;code&gt;std::packaged_task&lt;/code&gt; is move-only.</source>
          <target state="translated">1) Оператор назначения копирования удален, &lt;code&gt;std::packaged_task&lt;/code&gt; только для перемещения.</target>
        </trans-unit>
        <trans-unit id="2aca2d494628bc0ffa5751c1c324f784c030e885" translate="yes" xml:space="preserve">
          <source>1) Copy assignment operator. Assigns each element of &lt;code&gt;other&lt;/code&gt; to the corresponding element of &lt;code&gt;*this&lt;/code&gt;.</source>
          <target state="translated">1) Копировать оператор присваивания. Назначает каждый элемент &lt;code&gt;other&lt;/code&gt; соответствующему элементу &lt;code&gt;*this&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8cc354b87930ded2400ee0d9fd474ddaa0df3e93" translate="yes" xml:space="preserve">
          <source>1) Copy assignment operator. Assigns the contents of &lt;code&gt;other&lt;/code&gt;.</source>
          <target state="translated">1) Копировать оператор присваивания. Назначает содержимое &lt;code&gt;other&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="192e116d8a3105a5b39d34793a6599ce2a2b2376" translate="yes" xml:space="preserve">
          <source>1) Copy assignment operator. Assigns the contents of &lt;code&gt;other&lt;/code&gt;. Equivalent to &lt;code&gt;assign(other);&lt;/code&gt;.</source>
          <target state="translated">1) Копировать оператор присваивания. Назначает содержимое &lt;code&gt;other&lt;/code&gt; . Эквивалент для &lt;code&gt;assign(other);&lt;/code&gt; ,</target>
        </trans-unit>
        <trans-unit id="dc11fa7946da37481c60d78d0a9d3a526f8a12a0" translate="yes" xml:space="preserve">
          <source>1) Copy assignment operator. Each element of &lt;code&gt;*this&lt;/code&gt; is assigned the value of the corresponding element of &lt;code&gt;other&lt;/code&gt;. If the length of &lt;code&gt;other&lt;/code&gt; does not equal the length of &lt;code&gt;*this&lt;/code&gt;,  the behavior is undefined(until C++11) first resizes as if by &lt;code&gt;resize(other.size())&lt;/code&gt;(since C++11).</source>
          <target state="translated">1) Копировать оператор присваивания. Каждому элементу &lt;code&gt;*this&lt;/code&gt; присваивается значение соответствующего элемента &lt;code&gt;other&lt;/code&gt; . Если длина &lt;code&gt;other&lt;/code&gt; не равна длине &lt;code&gt;*this&lt;/code&gt; , поведение не определено (до C ++ 11), сначала изменяет &lt;code&gt;resize(other.size())&lt;/code&gt; как если бы он изменял размер (other.size ()) (начиная с C ++ 11).</target>
        </trans-unit>
        <trans-unit id="36cd900ec1105ec865ef3f158da0f2320e8c8dbc" translate="yes" xml:space="preserve">
          <source>1) Copy assignment operator. Replaces the contents with a copy of the contents of &lt;code&gt;other&lt;/code&gt;. Effectively calls &lt;code&gt;c = other.c; comp = other.comp;&lt;/code&gt;. (implicitly declared)</source>
          <target state="translated">1) Копировать оператор присваивания. Заменяет содержимое копией содержимого &lt;code&gt;other&lt;/code&gt; . Эффективно вызывает &lt;code&gt;c = other.c; comp = other.comp;&lt;/code&gt; , (неявно объявлено)</target>
        </trans-unit>
        <trans-unit id="a351a0527d89498a7bcb02cb3b6924c0e3fbd9ec" translate="yes" xml:space="preserve">
          <source>1) Copy assignment operator. Replaces the contents with a copy of the contents of &lt;code&gt;other&lt;/code&gt;. Effectively calls &lt;code&gt;c = other.c;&lt;/code&gt;. (implicitly declared)</source>
          <target state="translated">1) Копировать оператор присваивания. Заменяет содержимое копией содержимого &lt;code&gt;other&lt;/code&gt; . Эффективно вызывает &lt;code&gt;c = other.c;&lt;/code&gt; , (неявно объявлено)</target>
        </trans-unit>
        <trans-unit id="0ad06eaa3c6a3a682c837daad2aa45d6956113f6" translate="yes" xml:space="preserve">
          <source>1) Copy assignment operator. Replaces the contents with a copy of the contents of &lt;code&gt;other&lt;/code&gt;.If &lt;code&gt;&lt;a href=&quot;../../memory/allocator_traits&quot;&gt;std::allocator_traits&lt;/a&gt;&amp;lt;allocator_type&amp;gt;::propagate_on_container_copy_assignment::value&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, the target allocator is replaced by a copy of the source allocator. If the target and the source allocators do not compare equal, the target (&lt;code&gt;*this&lt;/code&gt;) allocator is used to deallocate the memory, then &lt;code&gt;other&lt;/code&gt;'s allocator is used to allocate it before copying the elements.(since C++11).</source>
          <target state="translated">1) Копировать оператор присваивания. Заменяет содержимое копией содержимого &lt;code&gt;other&lt;/code&gt; Если &lt;code&gt;&lt;a href=&quot;../../memory/allocator_traits&quot;&gt;std::allocator_traits&lt;/a&gt;&amp;lt;allocator_type&amp;gt;::propagate_on_container_copy_assignment::value&lt;/code&gt; равно &lt;code&gt;true&lt;/code&gt; , целевой распределитель заменяется копией исходного распределителя. Если целевые и исходные распределители не сравниваются равными, целевой ( &lt;code&gt;*this&lt;/code&gt; ) распределитель используется для освобождения памяти, тогда &lt;code&gt;other&lt;/code&gt; распределитель используется для выделения ее перед копированием элементов (начиная с C ++ 11).</target>
        </trans-unit>
        <trans-unit id="1e0dbe7fed5c788b8dad718a8b915f89fb6eb4b1" translate="yes" xml:space="preserve">
          <source>1) Copy assignment operator. Replaces the contents with a copy of the contents of other.</source>
          <target state="translated">1)Оператор копирования заданий.Заменяет содержимое на копию содержимого другого.</target>
        </trans-unit>
        <trans-unit id="7ee786d01693b06ebeb3b6d27fc4eca9ecd9d102" translate="yes" xml:space="preserve">
          <source>1) Creates an object of the given type &lt;code&gt;T&lt;/code&gt; by means of &lt;a href=&quot;../uses_allocator#Uses-allocator_construction&quot;&gt;uses-allocator construction&lt;/a&gt; at the uninitialized memory location indicated by p, using OUTERMOST as the allocator. After adjustment for uses-allocator convention expected by T's constructor, calls &lt;code&gt;OUTERMOST_ALLOC_TRAITS(*this)::construct&lt;/code&gt;.</source>
          <target state="translated">1) Создает объект данного типа &lt;code&gt;T&lt;/code&gt; с помощью конструкции &lt;a href=&quot;../uses_allocator#Uses-allocator_construction&quot;&gt;использования-распределителя&lt;/a&gt; в неинициализированной ячейке памяти, обозначенной p, используя OUTERMOST в качестве распределителя. После корректировки соглашения об использовании-распределителя, ожидаемого конструктором T, вызывается &lt;code&gt;OUTERMOST_ALLOC_TRAITS(*this)::construct&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c2a543f321b7366feb622ab638584f7e34068656" translate="yes" xml:space="preserve">
          <source>1) Creates an object of the given type &lt;code&gt;U&lt;/code&gt; by means of &lt;a href=&quot;../uses_allocator#Uses-allocator_construction&quot;&gt;uses-allocator construction&lt;/a&gt; at the uninitialized memory location indicated by p, using &lt;code&gt;*this&lt;/code&gt; as the allocator. This overload only participates in overload resolution if &lt;code&gt;U&lt;/code&gt; is not a specialization of &lt;code&gt;&lt;a href=&quot;../../utility/pair&quot;&gt;std::pair&lt;/a&gt;&lt;/code&gt;.(until C++20)</source>
          <target state="translated">1) Создает объект заданного типа &lt;code&gt;U&lt;/code&gt; с помощью конструкции &lt;a href=&quot;../uses_allocator#Uses-allocator_construction&quot;&gt;использования-распределителя&lt;/a&gt; в неинициализированной ячейке памяти, обозначенной p, используя &lt;code&gt;*this&lt;/code&gt; в качестве распределителя. Эта перегрузка участвует только в разрешении перегрузки, если &lt;code&gt;U&lt;/code&gt; не является специализацией &lt;code&gt;&lt;a href=&quot;../../utility/pair&quot;&gt;std::pair&lt;/a&gt;&lt;/code&gt; . (До C ++ 20)</target>
        </trans-unit>
        <trans-unit id="a9a98b74dec90269333d869db789c5323e20c4d2" translate="yes" xml:space="preserve">
          <source>1) Creates an optional object from &lt;code&gt;value&lt;/code&gt;. Effectively calls &lt;code&gt;&lt;a href=&quot;../optional&quot;&gt;std::optional&lt;/a&gt;&amp;lt;&lt;a href=&quot;../../types/decay&quot;&gt;std::decay_t&lt;/a&gt;&amp;lt;T&amp;gt;&amp;gt;(&lt;a href=&quot;../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;T&amp;gt;(value))&lt;/code&gt;</source>
          <target state="translated">1) Создает необязательный объект из &lt;code&gt;value&lt;/code&gt; . Эффективно вызывает &lt;code&gt;&lt;a href=&quot;../optional&quot;&gt;std::optional&lt;/a&gt;&amp;lt;&lt;a href=&quot;../../types/decay&quot;&gt;std::decay_t&lt;/a&gt;&amp;lt;T&amp;gt;&amp;gt;(&lt;a href=&quot;../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;T&amp;gt;(value))&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c480710a43a80e8adcfecc3be2f3cd25cb1baa89" translate="yes" xml:space="preserve">
          <source>1) Creates and returns a &lt;code&gt;&lt;a href=&quot;../../string/basic_string&quot;&gt;std::basic_string&lt;/a&gt;&lt;/code&gt; object containing a copy of this &lt;code&gt;std::basic_stringbuf&lt;/code&gt;'s underlying character sequence. For input-only streams, the returned string contains the characters from the range &lt;code&gt;[eback(), egptr())&lt;/code&gt;. For input/output or output-only streams, contains the characters from &lt;code&gt;pbase()&lt;/code&gt; to the last character in the sequence regardless of &lt;code&gt;egptr()&lt;/code&gt; and &lt;code&gt;epptr()&lt;/code&gt;.</source>
          <target state="translated">1) Создает и возвращает объект &lt;code&gt;&lt;a href=&quot;../../string/basic_string&quot;&gt;std::basic_string&lt;/a&gt;&lt;/code&gt; содержащий копию последовательности символов этого &lt;code&gt;std::basic_stringbuf&lt;/code&gt; . Для потоков только для ввода возвращаемая строка содержит символы из диапазона &lt;code&gt;[eback(), egptr())&lt;/code&gt; . Для потоков ввода / вывода или только для вывода содержит символы от &lt;code&gt;pbase()&lt;/code&gt; до последнего символа в последовательности независимо от &lt;code&gt;egptr()&lt;/code&gt; и &lt;code&gt;epptr()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a5389ceb0bc0b5a3365c91e4e5a33417369a0e1f" translate="yes" xml:space="preserve">
          <source>1) Creates new thread object which does not represent a thread.</source>
          <target state="translated">1)Создает новый объект потока,который не представляет поток.</target>
        </trans-unit>
        <trans-unit id="0327a6fbad3860b481ce60cfaf07be7bf277056c" translate="yes" xml:space="preserve">
          <source>1) Creates the directory &lt;code&gt;p&lt;/code&gt; as if by POSIX &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/mkdir.html&quot;&gt;&lt;code&gt;mkdir()&lt;/code&gt;&lt;/a&gt; with a second argument of &lt;code&gt;static_cast&amp;lt;int&amp;gt;(&lt;a href=&quot;perms&quot;&gt;std::filesystem::perms::all&lt;/a&gt;)&lt;/code&gt; (the parent directory must already exist). If the function fails because &lt;code&gt;p&lt;/code&gt; resolves to an existing directory, no error is reported. Otherwise on failure an error is reported.</source>
          <target state="translated">1) Создает каталог &lt;code&gt;p&lt;/code&gt; как бы с помощью POSIX &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/mkdir.html&quot;&gt; &lt;code&gt;mkdir()&lt;/code&gt; &lt;/a&gt; со вторым аргументом &lt;code&gt;static_cast&amp;lt;int&amp;gt;(&lt;a href=&quot;perms&quot;&gt;std::filesystem::perms::all&lt;/a&gt;)&lt;/code&gt; (родительский каталог уже должен существовать). Если функция завершается ошибкой из-за того, что &lt;code&gt;p&lt;/code&gt; преобразуется в существующий каталог, об ошибке не сообщается. В противном случае при ошибке сообщается об ошибке.</target>
        </trans-unit>
        <trans-unit id="26a64ab38ecb224858cfd7b2b44b0643ae394d5b" translate="yes" xml:space="preserve">
          <source>1) Creates the directory &lt;code&gt;p&lt;/code&gt; as if by POSIX &lt;a href=&quot;https://pubs.opengroup.org/onlinepubs/9699919799/functions/mkdir.html&quot;&gt;&lt;code&gt;mkdir()&lt;/code&gt;&lt;/a&gt; with a second argument of &lt;code&gt;static_cast&amp;lt;int&amp;gt;(&lt;a href=&quot;perms&quot;&gt;std::filesystem::perms::all&lt;/a&gt;)&lt;/code&gt; (the parent directory must already exist). If the function fails because &lt;code&gt;p&lt;/code&gt; resolves to an existing directory, no error is reported. Otherwise on failure an error is reported.</source>
          <target state="translated">1) Создает каталог &lt;code&gt;p&lt;/code&gt; , как будто с помощью POSIX &lt;a href=&quot;https://pubs.opengroup.org/onlinepubs/9699919799/functions/mkdir.html&quot;&gt; &lt;code&gt;mkdir()&lt;/code&gt; &lt;/a&gt; со вторым аргументом &lt;code&gt;static_cast&amp;lt;int&amp;gt;(&lt;a href=&quot;perms&quot;&gt;std::filesystem::perms::all&lt;/a&gt;)&lt;/code&gt; (родительский каталог уже должен существовать). Если функция не работает из-за того, что &lt;code&gt;p&lt;/code&gt; преобразуется в существующий каталог, об ошибке не сообщается. В противном случае при сбое выдается сообщение об ошибке.</target>
        </trans-unit>
        <trans-unit id="bdf75898238d98a307ea5bb83b21e825fa5f14e6" translate="yes" xml:space="preserve">
          <source>1) Decimal integer literal (base 10, the first digit is the most significant)</source>
          <target state="translated">1)Десятичный целочисленный литерал (база 10,первая цифра-самая значимая)</target>
        </trans-unit>
        <trans-unit id="2c073db79516e7eb32cc3d9bb547356532b4dc4d" translate="yes" xml:space="preserve">
          <source>1) Declaration of a default constructor inside of class definition.</source>
          <target state="translated">1)Объявление конструктора по умолчанию внутри определения класса.</target>
        </trans-unit>
        <trans-unit id="b4e1003653c1efe0f901decca5b2245ba63c2f97" translate="yes" xml:space="preserve">
          <source>1) Declares a named (formal) parameter. For the meanings of decl-specifier-seq and declarator, see &lt;a href=&quot;declarations&quot;&gt;declarations&lt;/a&gt;.</source>
          <target state="translated">1) Объявляет именованный (формальный) параметр. Для значений decl-specier-seq и декларатора см. &lt;a href=&quot;declarations&quot;&gt;Объявления&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7c4a1c3ae36aa2a523075a60794a76350d1cbb46" translate="yes" xml:space="preserve">
          <source>1) Declares a static data member.</source>
          <target state="translated">1)Объявляет о статическом члене данных.</target>
        </trans-unit>
        <trans-unit id="aef76cc087fec5259881aa2a31282705f7c15ad1" translate="yes" xml:space="preserve">
          <source>1) Declares a user-defined conversion function that participates in all &lt;a href=&quot;implicit_cast&quot;&gt;implicit&lt;/a&gt; and &lt;a href=&quot;explicit_cast&quot;&gt;explicit conversions&lt;/a&gt;</source>
          <target state="translated">1) Объявляет пользовательскую функцию преобразования, которая участвует во всех &lt;a href=&quot;implicit_cast&quot;&gt;неявных&lt;/a&gt; и &lt;a href=&quot;explicit_cast&quot;&gt;явных преобразованиях&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f9bbb455cc0049834ffda69e633f84b7ffdce2f6" translate="yes" xml:space="preserve">
          <source>1) Declares an unscoped enumeration type whose underlying type is not fixed (in this case, the underlying type is an implementation-defined integral type that can represent all enumerator values; this type is not larger than &lt;code&gt;int&lt;/code&gt; unless the value of an enumerator cannot fit in an &lt;code&gt;int&lt;/code&gt; or &lt;code&gt;unsigned int&lt;/code&gt;. If the enumerator-list is empty, the underlying type is as if the enumeration had a single enumerator with value 0).</source>
          <target state="translated">1) Объявляет тип перечисления с незаданной областью, базовый тип которого не является фиксированным (в этом случае базовый тип является целочисленным типом, определяемым реализацией, который может представлять все значения перечислителя; этот тип не больше, чем &lt;code&gt;int&lt;/code&gt; , если значение перечислителя не может соответствовать в &lt;code&gt;int&lt;/code&gt; или &lt;code&gt;unsigned int&lt;/code&gt; . Если список-перечислитель пуст, базовый тип такой, как если бы перечисление имело единственный перечислитель со значением 0).</target>
        </trans-unit>
        <trans-unit id="aad5551fd8cb89e8bb0fe35f15a0c5a90ee8d2c9" translate="yes" xml:space="preserve">
          <source>1) Default constructor leaves both the &lt;code&gt;std::chrono::weekday&lt;/code&gt; and the index value uninitialized.</source>
          <target state="translated">1) Конструктор по умолчанию оставляет как &lt;code&gt;std::chrono::weekday&lt;/code&gt; и значение индекса не инициализированным.</target>
        </trans-unit>
        <trans-unit id="2428761890c8eee7869837b591a34b4aeb8dae13" translate="yes" xml:space="preserve">
          <source>1) Default constructor leaves the date uninitialized.</source>
          <target state="translated">1)Конструктор по умолчанию оставляет дату неинициализированной.</target>
        </trans-unit>
        <trans-unit id="499e023d2657c02b2972ab6ce587b2b5cf8946cd" translate="yes" xml:space="preserve">
          <source>1) Default constructor leaves the day value uninitialized.</source>
          <target state="translated">1)Конструктор по умолчанию оставляет значение дня неинициализированным.</target>
        </trans-unit>
        <trans-unit id="d7eaca31c34a6ae5693ef338f73e6bcd8c29ffb4" translate="yes" xml:space="preserve">
          <source>1) Default constructor leaves the fields uninitialized.</source>
          <target state="translated">1)Конструктор по умолчанию оставляет поля неинициализированными.</target>
        </trans-unit>
        <trans-unit id="078562fd7069664d06229783df9c7e3002067686" translate="yes" xml:space="preserve">
          <source>1) Default constructor leaves the month value uninitialized.</source>
          <target state="translated">1)Конструктор по умолчанию оставляет значение месяца неинициализированным.</target>
        </trans-unit>
        <trans-unit id="c36a47fb197929eeaca91e2ccaae79725f495a3f" translate="yes" xml:space="preserve">
          <source>1) Default constructor leaves the object uninitialized.</source>
          <target state="translated">1)Конструктор по умолчанию оставляет объект неинициализированным.</target>
        </trans-unit>
        <trans-unit id="f177bc21211b9f9814da5723e9d7b52c483ab492" translate="yes" xml:space="preserve">
          <source>1) Default constructor leaves the stored month and day values uninitialized.</source>
          <target state="translated">1)Конструктор по умолчанию оставляет сохраненные значения месяца и дня неинициализированными.</target>
        </trans-unit>
        <trans-unit id="2b51b3017e5534f01a4fcc3714ba6f3fcca53ace" translate="yes" xml:space="preserve">
          <source>1) Default constructor leaves the weekday value uninitialized.</source>
          <target state="translated">1)Конструктор по умолчанию оставляет значение дня недели неинициализированным.</target>
        </trans-unit>
        <trans-unit id="0e624fa6115013ca80f6e91997dffec7202273f9" translate="yes" xml:space="preserve">
          <source>1) Default constructor leaves the year and month uninitialized.</source>
          <target state="translated">1)Конструктор по умолчанию оставляет год и месяц неинициализированными.</target>
        </trans-unit>
        <trans-unit id="131de4c9bed3f450ed7010d48d5a3fdb80330c32" translate="yes" xml:space="preserve">
          <source>1) Default constructor leaves the year value uninitialized.</source>
          <target state="translated">1)Конструктор по умолчанию оставляет значение года неинициализированным.</target>
        </trans-unit>
        <trans-unit id="9115058f2c43fa98792950ebe40f71f59fbd9aa0" translate="yes" xml:space="preserve">
          <source>1) Default constructor that calls (4) with &lt;code&gt;&lt;a href=&quot;../file_type&quot;&gt;std::filesystem::file_type::none&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">1) Конструктор по умолчанию, который вызывает (4) с помощью &lt;code&gt;&lt;a href=&quot;../file_type&quot;&gt;std::filesystem::file_type::none&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e9d0e85becce06778b271a974bf41a26b72cc575" translate="yes" xml:space="preserve">
          <source>1) Default constructor, creates a &lt;code&gt;time_point&lt;/code&gt; representing the &lt;code&gt;Clock&lt;/code&gt;'s epoch (i.e., &lt;code&gt;&lt;a href=&quot;time_since_epoch&quot;&gt;time_since_epoch()&lt;/a&gt;&lt;/code&gt; is zero).</source>
          <target state="translated">1) Конструктор по умолчанию, создает &lt;code&gt;time_point&lt;/code&gt; представляющую эпоху &lt;code&gt;Clock&lt;/code&gt; (т. &lt;code&gt;&lt;a href=&quot;time_since_epoch&quot;&gt;time_since_epoch()&lt;/a&gt;&lt;/code&gt; - ноль).</target>
        </trans-unit>
        <trans-unit id="ca62ce9ba5ae98ed6cfeefae6805879eef5662f6" translate="yes" xml:space="preserve">
          <source>1) Default constructor.</source>
          <target state="translated">1)Конструктор по умолчанию.</target>
        </trans-unit>
        <trans-unit id="4672d91b62baf7495b356cbf3fd2d4ab7185bb97" translate="yes" xml:space="preserve">
          <source>1) Default constructor. &lt;a href=&quot;../../language/value_initialization&quot;&gt;Value-initializes&lt;/a&gt; all elements.</source>
          <target state="translated">1) Конструктор по умолчанию. &lt;a href=&quot;../../language/value_initialization&quot;&gt;Значение-инициализирует&lt;/a&gt; все элементы.</target>
        </trans-unit>
        <trans-unit id="2e8a32fa473b151fe2837e9a637eec271c2f495b" translate="yes" xml:space="preserve">
          <source>1) Default constructor. &lt;a href=&quot;what&quot;&gt;&lt;code&gt;what()&lt;/code&gt;&lt;/a&gt; returns an implementation-defined string.</source>
          <target state="translated">1) Конструктор по умолчанию. &lt;a href=&quot;what&quot;&gt; &lt;code&gt;what()&lt;/code&gt; &lt;/a&gt; возвращает строку, определяемую реализацией.</target>
        </trans-unit>
        <trans-unit id="c75332d6c29abfeb6ab9132695635439c25e48b8" translate="yes" xml:space="preserve">
          <source>1) Default constructor. Constructs a &lt;code&gt;std::future&lt;/code&gt; with no shared state. After construction, &lt;a href=&quot;valid&quot;&gt;&lt;code&gt;valid()&lt;/code&gt;&lt;/a&gt;&lt;code&gt;== false&lt;/code&gt;.</source>
          <target state="translated">1) Конструктор по умолчанию. Создает &lt;code&gt;std::future&lt;/code&gt; без общего состояния. После построения &lt;a href=&quot;valid&quot;&gt; &lt;code&gt;valid()&lt;/code&gt; &lt;/a&gt; &lt;code&gt;== false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="79261dde24b2758d36f9430c665e3f176df44f39" translate="yes" xml:space="preserve">
          <source>1) Default constructor. Constructs a bitset with all bits set to zero.</source>
          <target state="translated">1)Конструктор по умолчанию.Конструирует битсет с установкой всех битов на ноль.</target>
        </trans-unit>
        <trans-unit id="011ecb3fe17914dffa88456a32eaa298e263e47b" translate="yes" xml:space="preserve">
          <source>1) Default constructor. Constructs a copy of the global C++ locale, which is the locale most recently used as the argument to &lt;code&gt;&lt;a href=&quot;global&quot;&gt;std::locale::global&lt;/a&gt;&lt;/code&gt; or a copy of &lt;code&gt;&lt;a href=&quot;classic&quot;&gt;std::locale::classic&lt;/a&gt;&lt;/code&gt; if no call to &lt;code&gt;&lt;a href=&quot;global&quot;&gt;std::locale::global&lt;/a&gt;&lt;/code&gt; has been made.</source>
          <target state="translated">1) Конструктор по умолчанию. Создаёт копию глобального языкового стандарта C ++, который является локаль совсем недавно используется в качестве аргумента &lt;code&gt;&lt;a href=&quot;global&quot;&gt;std::locale::global&lt;/a&gt;&lt;/code&gt; или копия &lt;code&gt;&lt;a href=&quot;classic&quot;&gt;std::locale::classic&lt;/a&gt;&lt;/code&gt; , если нет вызова &lt;code&gt;&lt;a href=&quot;global&quot;&gt;std::locale::global&lt;/a&gt;&lt;/code&gt; не имеет было сделано.</target>
        </trans-unit>
        <trans-unit id="895580b59835cf3ea8b8e9ef9fcc3a2446be6649" translate="yes" xml:space="preserve">
          <source>1) Default constructor. Constructs a variant holding the &lt;a href=&quot;../../language/value_initialization&quot;&gt;value-initialized&lt;/a&gt; value of the first alternative (&lt;a href=&quot;index&quot;&gt;&lt;code&gt;index()&lt;/code&gt;&lt;/a&gt; is zero). This constructor is &lt;code&gt;constexpr&lt;/code&gt; if and only if the value initialization of the alternative type T_0 would satisfy the requirements for a &lt;a href=&quot;../../language/constexpr&quot;&gt;constexpr function&lt;/a&gt;. This overload only participates in overload resolution if &lt;code&gt;&lt;a href=&quot;../../types/is_default_constructible&quot;&gt;std::is_default_constructible_v&lt;/a&gt;&amp;lt;T_0&amp;gt;&lt;/code&gt; is true.</source>
          <target state="translated">1) Конструктор по умолчанию. Создает вариант, содержащий &lt;a href=&quot;../../language/value_initialization&quot;&gt;инициализированное&lt;/a&gt; значением значение первой альтернативы ( &lt;a href=&quot;index&quot;&gt; &lt;code&gt;index()&lt;/code&gt; &lt;/a&gt; равен нулю). Этот конструктор является &lt;code&gt;constexpr&lt;/code&gt; тогда и только тогда, когда инициализация значения альтернативного типа T_0 будет удовлетворять требованиям для &lt;a href=&quot;../../language/constexpr&quot;&gt;функции constexpr&lt;/a&gt; . Эта перегрузка участвует только в разрешении перегрузки, если &lt;code&gt;&lt;a href=&quot;../../types/is_default_constructible&quot;&gt;std::is_default_constructible_v&lt;/a&gt;&amp;lt;T_0&amp;gt;&lt;/code&gt; имеет значение true.</target>
        </trans-unit>
        <trans-unit id="9d0e5fa5fa920ac3791488de3b572932835b95ee" translate="yes" xml:space="preserve">
          <source>1) Default constructor. Constructs an empty &lt;code&gt;basic_string_view&lt;/code&gt;. After construction, &lt;code&gt;&lt;a href=&quot;data&quot;&gt;data()&lt;/a&gt;&lt;/code&gt; is equal to &lt;code&gt;nullptr&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;size&quot;&gt;size()&lt;/a&gt;&lt;/code&gt; is equal to &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">1) Конструктор по умолчанию. Создает пустой &lt;code&gt;basic_string_view&lt;/code&gt; . После построения &lt;code&gt;&lt;a href=&quot;data&quot;&gt;data()&lt;/a&gt;&lt;/code&gt; равно &lt;code&gt;nullptr&lt;/code&gt; , а &lt;code&gt;&lt;a href=&quot;size&quot;&gt;size()&lt;/a&gt;&lt;/code&gt; равно &lt;code&gt;0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="eacc35685d23a4fecd10da59ea5f06868759d796" translate="yes" xml:space="preserve">
          <source>1) Default constructor. Constructs an empty container. If no allocator is supplied, allocator is obtained from a default-constructed instance.</source>
          <target state="translated">1)Конструктор по умолчанию.Конструирует пустой контейнер.Если аллокатор не поставляется,то аллокатор получается из экземпляра по умолчанию.</target>
        </trans-unit>
        <trans-unit id="6c17b4644d6ac209e7f22c17144138b18c5931e9" translate="yes" xml:space="preserve">
          <source>1) Default constructor. Constructs an empty numeric array.</source>
          <target state="translated">1)Конструктор по умолчанию.Конструирует пустой числовой массив.</target>
        </trans-unit>
        <trans-unit id="de0ff732be5a241f66c48250f820f0547487440b" translate="yes" xml:space="preserve">
          <source>1) Default constructor. Constructs an empty regular expression which will match nothing.</source>
          <target state="translated">1)Конструктор по умолчанию.Конструирует пустое регулярное выражение,которое ничему не будет соответствовать.</target>
        </trans-unit>
        <trans-unit id="e669d70f06155beb00ecca03586e5c258a586219" translate="yes" xml:space="preserve">
          <source>1) Default constructor. Constructs an empty shared future, that doesn't refer to a shared state, that is &lt;code&gt;valid() == false&lt;/code&gt;.</source>
          <target state="translated">1) Конструктор по умолчанию. Создает пустое общее будущее, которое не относится к общему состоянию, которое является &lt;code&gt;valid() == false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7565190dee6671c76d3a56a2e2e2a2350105a5f5" translate="yes" xml:space="preserve">
          <source>1) Default constructor. Constructs an end iterator.</source>
          <target state="translated">1)Конструктор по умолчанию.Создает итератор конца.</target>
        </trans-unit>
        <trans-unit id="cb5ed3cd804429aa2c7dde21da7ca9ead64884cb" translate="yes" xml:space="preserve">
          <source>1) Default constructor. Constructs an end-of-sequence iterator.</source>
          <target state="translated">1)Конструктор по умолчанию.Создает итератор конца последовательности.</target>
        </trans-unit>
        <trans-unit id="9cd879bc1abea042190566e8fd2e0be2513b8de1" translate="yes" xml:space="preserve">
          <source>1) Default constructor. Constructs empty &lt;code&gt;weak_ptr&lt;/code&gt;.</source>
          <target state="translated">1) Конструктор по умолчанию. Создаёт пустой &lt;code&gt;weak_ptr&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8f5913ec53e778795e8ead732e87ecf9cfcfc151" translate="yes" xml:space="preserve">
          <source>1) Default constructor. Constructs empty string (zero size and unspecified capacity). If no allocator is supplied, allocator is obtained from a default-constructed instance.</source>
          <target state="translated">1)Конструктор по умолчанию.Конструирует пустую строку (нулевой размер и неопределенная емкость).Если аллокатор не поставляется,то аллокатор получается из экземпляра,построенного по умолчанию.</target>
        </trans-unit>
        <trans-unit id="fea889f6b10c364b364bead59870fc1ead08d127" translate="yes" xml:space="preserve">
          <source>1) Default constructor. Constructs new underlying string device with the default open mode</source>
          <target state="translated">1)Конструктор по умолчанию.Конструирует новое устройство базовой строки с открытым режимом по умолчанию.</target>
        </trans-unit>
        <trans-unit id="47dfb990d09b6cf7741d11d703850522bdd37ac1" translate="yes" xml:space="preserve">
          <source>1) Default constructor. Constructs the distribution with a single weight p={1}. This distribution will always generate &lt;code&gt;​0​&lt;/code&gt;.</source>
          <target state="translated">1) Конструктор по умолчанию. Создает распределение с одним весом p = {1}. Это распределение всегда будет генерировать &lt;code&gt;​0​&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e80f107318c31b0c58e6aeef75360f44ffd05c03" translate="yes" xml:space="preserve">
          <source>1) Default constructor. Constructs the end-of-sequence iterator.</source>
          <target state="translated">1)Конструктор по умолчанию.Создает итератор конца последовательности.</target>
        </trans-unit>
        <trans-unit id="5bf185507087fc694124074f527682377e4e4b06" translate="yes" xml:space="preserve">
          <source>1) Default constructor. Constructs the promise with an empty shared state.</source>
          <target state="translated">1)Конструктор по умолчанию.Конструирует обещание с пустым общим состоянием.</target>
        </trans-unit>
        <trans-unit id="25239fa19574ad09c0768600521365122e69a28f" translate="yes" xml:space="preserve">
          <source>1) Default constructor. Equivalent to &lt;code&gt;gslice(0, &lt;a href=&quot;../valarray&quot;&gt;std::valarray&lt;/a&gt;&amp;lt;&lt;a href=&quot;../../types/size_t&quot;&gt;std::size_t&lt;/a&gt;&amp;gt;(), &lt;a href=&quot;../valarray&quot;&gt;std::valarray&lt;/a&gt;&amp;lt;&lt;a href=&quot;../../types/size_t&quot;&gt;std::size_t&lt;/a&gt;&amp;gt;())&lt;/code&gt;. This constructor exists only to allow construction of arrays of slices.</source>
          <target state="translated">1) Конструктор по умолчанию. Эквивалент &lt;code&gt;gslice(0, &lt;a href=&quot;../valarray&quot;&gt;std::valarray&lt;/a&gt;&amp;lt;&lt;a href=&quot;../../types/size_t&quot;&gt;std::size_t&lt;/a&gt;&amp;gt;(), &lt;a href=&quot;../valarray&quot;&gt;std::valarray&lt;/a&gt;&amp;lt;&lt;a href=&quot;../../types/size_t&quot;&gt;std::size_t&lt;/a&gt;&amp;gt;())&lt;/code&gt; . Этот конструктор существует только для создания массивов срезов.</target>
        </trans-unit>
        <trans-unit id="25b86c4ec98dd08e9433550d3d731d786fa40f88" translate="yes" xml:space="preserve">
          <source>1) Default constructor. Equivalent to &lt;code&gt;slice(0, 0, 0)&lt;/code&gt;. This constructor exists only to allow construction of arrays of slices.</source>
          <target state="translated">1) Конструктор по умолчанию. Эквивалент &lt;code&gt;slice(0, 0, 0)&lt;/code&gt; . Этот конструктор существует только для создания массивов срезов.</target>
        </trans-unit>
        <trans-unit id="0f2c9964918fbbbec4b2a2f80259c25e38ce89a5" translate="yes" xml:space="preserve">
          <source>1) Default constructor. Initializes the error condition with generic category and error code &lt;code&gt;​0​&lt;/code&gt;.</source>
          <target state="translated">1) Конструктор по умолчанию. Инициализирует состояние ошибки с общей категорией и кодом ошибки &lt;code&gt;​0​&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a16bc65a9c0bb02a38efb33e034e628db8375633" translate="yes" xml:space="preserve">
          <source>1) Default constructor. It is implementation-defined whether the sequence pointers (&lt;code&gt;eback()&lt;/code&gt;, &lt;code&gt;gptr()&lt;/code&gt;, &lt;code&gt;egptr()&lt;/code&gt;, &lt;code&gt;pbase()&lt;/code&gt;, &lt;code&gt;pptr()&lt;/code&gt;, &lt;code&gt;epptr()&lt;/code&gt;) are initialized to null pointers.</source>
          <target state="translated">1) Конструктор по умолчанию. Это определяется реализацией, &lt;code&gt;eback()&lt;/code&gt; ли указатели последовательности ( eback () , &lt;code&gt;gptr()&lt;/code&gt; , &lt;code&gt;egptr()&lt;/code&gt; , &lt;code&gt;pbase()&lt;/code&gt; , &lt;code&gt;pptr()&lt;/code&gt; , &lt;code&gt;epptr()&lt;/code&gt; ) в нулевые указатели.</target>
        </trans-unit>
        <trans-unit id="18cc22e95dd49ea3310825efa9be211fee3b3c2f" translate="yes" xml:space="preserve">
          <source>1) Default constructor. Seeds the engine with &lt;code&gt;default_seed&lt;/code&gt;.</source>
          <target state="translated">1) Конструктор по умолчанию. Запускает двигатель с &lt;code&gt;default_seed&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1a1f3b78577783b96afca946ecfdb044a2e2fe03" translate="yes" xml:space="preserve">
          <source>1) Default constructor. Stores an exception object obtained by calling &lt;code&gt;&lt;a href=&quot;../current_exception&quot;&gt;std::current_exception&lt;/a&gt;()&lt;/code&gt; within the new &lt;code&gt;nested_exception&lt;/code&gt; object.</source>
          <target state="translated">1) Конструктор по умолчанию. Сохраняет объект исключения, полученный путем вызова &lt;code&gt;&lt;a href=&quot;../current_exception&quot;&gt;std::current_exception&lt;/a&gt;()&lt;/code&gt; в новом объекте &lt;code&gt;nested_exception&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8a32db41a403e2f63a4fd28475b603a4ec46df42" translate="yes" xml:space="preserve">
          <source>1) Default constructor. The internal state is not initialized. &lt;code&gt;&lt;a href=&quot;init&quot;&gt;init()&lt;/a&gt;&lt;/code&gt; must be called before the first use of the object or before destructor, otherwise the behavior is undefined.</source>
          <target state="translated">1) Конструктор по умолчанию. Внутреннее состояние не инициализировано. &lt;code&gt;&lt;a href=&quot;init&quot;&gt;init()&lt;/a&gt;&lt;/code&gt; должен быть вызван перед первым использованием объекта или перед деструктором, иначе поведение не определено.</target>
        </trans-unit>
        <trans-unit id="55062aaea6619514669480e39506ff7c999ff520" translate="yes" xml:space="preserve">
          <source>1) Default constructor. The underlying engine is also default-constructed.</source>
          <target state="translated">1)Конструктор по умолчанию.Основной движок также построен по умолчанию.</target>
        </trans-unit>
        <trans-unit id="15f4029d373e079f41db83cdd93169d4f5785dcf" translate="yes" xml:space="preserve">
          <source>1) Default constructor. The underlying iterator is value-initialized. Operations on the resulting iterator have defined behavior if and only if the corresponding operations on a value-initialized &lt;code&gt;Iterator&lt;/code&gt; also have defined behavior.</source>
          <target state="translated">1) Конструктор по умолчанию. Базовый итератор инициализируется значением. Операции на результирующем итераторе имеют определенное поведение тогда и только тогда, когда соответствующие операции с инициализированным значением &lt;code&gt;Iterator&lt;/code&gt; также имеют определенное поведение.</target>
        </trans-unit>
        <trans-unit id="2a9d616bbf3734e2be9b10dbac57548362a533dd" translate="yes" xml:space="preserve">
          <source>1) Default constructor. Value-initializes both elements of the pair, &lt;code&gt;first&lt;/code&gt; and &lt;code&gt;second&lt;/code&gt;.</source>
          <target state="translated">1) Конструктор по умолчанию. Значение-инициализирует оба элемента пары, &lt;code&gt;first&lt;/code&gt; и &lt;code&gt;second&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d50a8b3aca03c89f83a8e00c8035cce2b2f943dc" translate="yes" xml:space="preserve">
          <source>1) Default constructor. Value-initializes the comparator and the underlying container.</source>
          <target state="translated">1)Конструктор по умолчанию.Значение-инициализирует компаратор и лежащий в его основе контейнер.</target>
        </trans-unit>
        <trans-unit id="d57453057acaf238aba5d7c9f55019284642f9be" translate="yes" xml:space="preserve">
          <source>1) Default constructor. Value-initializes the container.</source>
          <target state="translated">1)Конструктор по умолчанию.Значение-инициализирует контейнер.</target>
        </trans-unit>
        <trans-unit id="85aa7b5f36dda27d22e0568ece5d170840dd6df4" translate="yes" xml:space="preserve">
          <source>1) Default constructor: constructs a stream that is not associated with a file: default-constructs the &lt;code&gt;&lt;a href=&quot;../basic_filebuf&quot;&gt;std::basic_filebuf&lt;/a&gt;&lt;/code&gt; and constructs the base with the pointer to this default-constructed &lt;code&gt;&lt;a href=&quot;../basic_filebuf&quot;&gt;std::basic_filebuf&lt;/a&gt;&lt;/code&gt; member.</source>
          <target state="translated">1) Конструктор по умолчанию: создает поток, который не связан с файлом: по умолчанию - конструирует &lt;code&gt;&lt;a href=&quot;../basic_filebuf&quot;&gt;std::basic_filebuf&lt;/a&gt;&lt;/code&gt; и создает базу с указателем на этот конструктор по умолчанию. &lt;code&gt;&lt;a href=&quot;../basic_filebuf&quot;&gt;std::basic_filebuf&lt;/a&gt;&lt;/code&gt; член std :: basic_filebuf .</target>
        </trans-unit>
        <trans-unit id="3cab7b4fb28e5286d6fa395d1c88c741664448fe" translate="yes" xml:space="preserve">
          <source>1) Default constructor: value-initializes the &lt;code&gt;OuterAlloc&lt;/code&gt; base class and the inner allocator member object, if used by the implementation.</source>
          <target state="translated">1) Конструктор по умолчанию: значение инициализирует &lt;code&gt;OuterAlloc&lt;/code&gt; базовый класс OuterAlloc и объект-член внутреннего распределителя, если используется реализацией.</target>
        </trans-unit>
        <trans-unit id="f147745323c3c84fec33aec7c8557ca0d3395b0a" translate="yes" xml:space="preserve">
          <source>1) Default constructs a new &lt;code&gt;&lt;a href=&quot;../random_device&quot;&gt;std::random_device&lt;/a&gt;&lt;/code&gt; object with an implementation-defined &lt;code&gt;token&lt;/code&gt;.</source>
          <target state="translated">1) По умолчанию создается новый &lt;code&gt;&lt;a href=&quot;../random_device&quot;&gt;std::random_device&lt;/a&gt;&lt;/code&gt; объект с &lt;code&gt;token&lt;/code&gt; определяемым реализацией .</target>
        </trans-unit>
        <trans-unit id="3d254d4e4e041dda90a59631d7b2960792e803ef" translate="yes" xml:space="preserve">
          <source>1) Default-constructor. Constructs a match result with no established result state (&lt;code&gt;ready() != true&lt;/code&gt;).</source>
          <target state="translated">1) Конструктор по умолчанию. Создает результат совпадения без установленного состояния результата ( &lt;code&gt;ready() != true&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="1af4fb69cdbe20bca957ea5aab4e348af2793199" translate="yes" xml:space="preserve">
          <source>1) Default-constructs the underlying &lt;code&gt;&lt;a href=&quot;../strstreambuf&quot;&gt;std::strstreambuf&lt;/a&gt;&lt;/code&gt;, which creates a dynamically growing buffer, and initializes the base class with the address of the strstreambuf member.</source>
          <target state="translated">1) Default- &lt;code&gt;&lt;a href=&quot;../strstreambuf&quot;&gt;std::strstreambuf&lt;/a&gt;&lt;/code&gt; базовый std :: strstreambuf создает , который создает динамически растущий буфер и инициализирует базовый класс адресом члена strstreambuf.</target>
        </trans-unit>
        <trans-unit id="7d13af42ec3f2ddb8462a572d1b26587eccb3d92" translate="yes" xml:space="preserve">
          <source>1) Default-initializes &lt;code&gt;base_&lt;/code&gt; and &lt;code&gt;pred_&lt;/code&gt;</source>
          <target state="translated">1) По умолчанию инициализирует &lt;code&gt;base_&lt;/code&gt; и &lt;code&gt;pred_&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1ac5a4d8f549ae70b68112a4ef17cd868cd57e69" translate="yes" xml:space="preserve">
          <source>1) Default-initializes &lt;code&gt;value_&lt;/code&gt; and &lt;code&gt;bound_&lt;/code&gt;</source>
          <target state="translated">1) По умолчанию инициализирует &lt;code&gt;value_&lt;/code&gt; и &lt;code&gt;bound_&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b1dbaabdc4ff6b70020a151bf2e9abc440948c50" translate="yes" xml:space="preserve">
          <source>1) Defaulted copy assignment operator. Copy-assigns both the stored time point and the stored time zone pointer. &lt;code&gt;zoned_time&lt;/code&gt; has no move assignment operator; a move is a copy.</source>
          <target state="translated">1) Оператор присвоения копии по умолчанию. Копировать - назначает как сохраненный момент времени, так и указатель сохраненного часового пояса. &lt;code&gt;zoned_time&lt;/code&gt; не имеет оператора присваивания ходов ; ход это копия.</target>
        </trans-unit>
        <trans-unit id="78b7cc430f5922607ee43272f394fa79b6ed0bac" translate="yes" xml:space="preserve">
          <source>1) Define a non-member swap in the enclosing namespace, which may forward to a member swap if access to non-public data members is required</source>
          <target state="translated">1)Определите нечленский своп в прилагаемом пространстве имён,который может быть направлен на членский своп,если требуется доступ к непубличным данным членов.</target>
        </trans-unit>
        <trans-unit id="a7de1a6f8b3cc0594b28dcfd6a8f7980d955fbbc" translate="yes" xml:space="preserve">
          <source>1) Defines a</source>
          <target state="translated">1)Определяет</target>
        </trans-unit>
        <trans-unit id="c6408478c098043618abdb9b577727df78dd08ab" translate="yes" xml:space="preserve">
          <source>1) Definition of an enumeration type.</source>
          <target state="translated">1)Определение типа перечисления.</target>
        </trans-unit>
        <trans-unit id="ebbd2ad38e5fa6237bba264cce1284f0bd1cec2c" translate="yes" xml:space="preserve">
          <source>1) Denormalization loss: the delivered result differs from what would have been computed were exponent range unbounded.</source>
          <target state="translated">1)Потеря денорализации:полученный результат отличается от того,что было бы вычислено,если бы экспонентный диапазон был неограничен.</target>
        </trans-unit>
        <trans-unit id="4a1bd34fda9394675a66721b9472df8d48990386" translate="yes" xml:space="preserve">
          <source>1) Designates a function or several functions as friends of this class</source>
          <target state="translated">1)Назначает функцию или несколько функций в качестве друзей данного класса.</target>
        </trans-unit>
        <trans-unit id="cda85d78ffc7280c614df8e23678c3c173935a15" translate="yes" xml:space="preserve">
          <source>1) Destroys one non-array object created by a &lt;a href=&quot;new&quot;&gt;new-expression&lt;/a&gt;</source>
          <target state="translated">1) Уничтожает один объект, не являющийся массивом, созданный &lt;a href=&quot;new&quot;&gt;выражением new&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="2cba7eb8d44c15125cdc52986458ca13f73ba7d1" translate="yes" xml:space="preserve">
          <source>1) Destroys the &lt;code&gt;n&lt;/code&gt; objects in the range starting at &lt;code&gt;first&lt;/code&gt;, as if by</source>
          <target state="translated">1) Уничтожает &lt;code&gt;n&lt;/code&gt; объектов в диапазоне, начиная с &lt;code&gt;first&lt;/code&gt; , как если бы</target>
        </trans-unit>
        <trans-unit id="f998857faa7d72f442a5b64bb7bd57852afbb2f4" translate="yes" xml:space="preserve">
          <source>1) Destroys the iterator, including the cached value.</source>
          <target state="translated">1)Уничтожает итератор,включая значение кэша.</target>
        </trans-unit>
        <trans-unit id="a3f6de15f76b6e6f118c50c482f5797660572e61" translate="yes" xml:space="preserve">
          <source>1) Destroys the objects in the range &lt;code&gt;[first, last)&lt;/code&gt;, as if by</source>
          <target state="translated">1) Уничтожает объекты в диапазоне &lt;code&gt;[first, last)&lt;/code&gt; , как если бы</target>
        </trans-unit>
        <trans-unit id="8e3aa580452b25d9999027f1b3cb229e40ec1851" translate="yes" xml:space="preserve">
          <source>1) Detects if the current thread has a live exception object, that is, an exception has been thrown or rethrown and not yet entered a matching catch clause, &lt;code&gt;&lt;a href=&quot;../terminate&quot;&gt;std::terminate&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;unexpected&quot;&gt;std::unexpected&lt;/a&gt;&lt;/code&gt;. In other words, &lt;code&gt;std::uncaught_exception&lt;/code&gt; detects if &lt;a href=&quot;../../language/throw#Stack_unwinding&quot;&gt;stack unwinding&lt;/a&gt; is currently in progress.</source>
          <target state="translated">1) Обнаруживает, есть ли у текущего потока живой объект исключения, то есть исключение было брошено или переброшено и еще не введено в соответствующее предложение catch, &lt;code&gt;&lt;a href=&quot;../terminate&quot;&gt;std::terminate&lt;/a&gt;&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;unexpected&quot;&gt;std::unexpected&lt;/a&gt;&lt;/code&gt; . Другими словами, &lt;code&gt;std::uncaught_exception&lt;/code&gt; определяет, выполняется ли в данный момент &lt;a href=&quot;../../language/throw#Stack_unwinding&quot;&gt;разматывание стека&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="df7a3ba6b3fba13efda3c048c64afee201d66f99" translate="yes" xml:space="preserve">
          <source>1) Determines if the atomic object pointed to by &lt;code&gt;obj&lt;/code&gt; is implemented lock-free, as if by calling &lt;code&gt;obj-&amp;gt;is_lock_free()&lt;/code&gt;. In any given program execution, the result of the lock-free query is the same for all pointers of the same type.</source>
          <target state="translated">1) Определяет, реализован ли атомарный объект, на который указывает &lt;code&gt;obj&lt;/code&gt; ,без блокировки, как если бы он вызывал &lt;code&gt;obj-&amp;gt;is_lock_free()&lt;/code&gt; . При любом выполнении программы результат запроса без блокировки одинаков для всех указателей одного типа.</target>
        </trans-unit>
        <trans-unit id="91e01796abcfa6eddc0b11eb63b158b9aba3771c" translate="yes" xml:space="preserve">
          <source>1) Determines if there is a match between the regular expression &lt;code&gt;e&lt;/code&gt; and the entire target character sequence &lt;code&gt;[first,last)&lt;/code&gt;, taking into account the effect of &lt;code&gt;flags&lt;/code&gt;. When determining if there is a match, only potential matches that match the entire character sequence are considered. Match results are returned in &lt;code&gt;m&lt;/code&gt;.</source>
          <target state="translated">1) Определяет, есть ли совпадение между регулярным выражением &lt;code&gt;e&lt;/code&gt; и всей целевой последовательностью символов &lt;code&gt;[first,last)&lt;/code&gt; с учетом влияния &lt;code&gt;flags&lt;/code&gt; . При определении совпадения учитываются только потенциальные совпадения, которые соответствуют всей последовательности символов. Результаты матчей возвращаются в &lt;code&gt;m&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b58fdc599cf255bac2ae50522ea05922284c1bea" translate="yes" xml:space="preserve">
          <source>1) Determines the type and attributes of the filesystem object identified by &lt;code&gt;p&lt;/code&gt; as if by POSIX &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/stat.html&quot;&gt;stat&lt;/a&gt; (symlinks are followed to their targets). In the following description, &lt;code&gt;prms&lt;/code&gt; is the result of &lt;code&gt;(m &amp;amp; perms::mask)&lt;/code&gt;, where &lt;code&gt;m&lt;/code&gt; is obtained as if by taking &lt;code&gt;st_mode&lt;/code&gt; from the POSIX &lt;code&gt;struct stat&lt;/code&gt; and converting it to the type &lt;code&gt;&lt;a href=&quot;perms&quot;&gt;std::filesystem::perms&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">1) Определяет тип и атрибуты объекта файловой системы, идентифицируемого &lt;code&gt;p&lt;/code&gt; , как если бы он был POSIX &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/stat.html&quot;&gt;stat&lt;/a&gt; (символические ссылки следуют к своим целям). В следующем описании &lt;code&gt;prms&lt;/code&gt; является результатом &lt;code&gt;(m &amp;amp; perms::mask)&lt;/code&gt; , где &lt;code&gt;m&lt;/code&gt; получается, как если бы, взяв &lt;code&gt;st_mode&lt;/code&gt; из &lt;code&gt;struct stat&lt;/code&gt; POSIX и преобразовав его в тип &lt;code&gt;&lt;a href=&quot;perms&quot;&gt;std::filesystem::perms&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c5469bf43c306c8999eb2674dfaa4919563536e4" translate="yes" xml:space="preserve">
          <source>1) Determines the type and attributes of the filesystem object identified by &lt;code&gt;p&lt;/code&gt; as if by POSIX &lt;a href=&quot;https://pubs.opengroup.org/onlinepubs/9699919799/functions/stat.html&quot;&gt;stat&lt;/a&gt; (symlinks are followed to their targets). In the following description, &lt;code&gt;prms&lt;/code&gt; is the result of &lt;code&gt;(m &amp;amp; perms::mask)&lt;/code&gt;, where &lt;code&gt;m&lt;/code&gt; is obtained as if by taking &lt;code&gt;st_mode&lt;/code&gt; from the POSIX &lt;code&gt;struct stat&lt;/code&gt; and converting it to the type &lt;code&gt;&lt;a href=&quot;perms&quot;&gt;std::filesystem::perms&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">1) Определяет тип и атрибуты объекта файловой системы, идентифицированного &lt;code&gt;p&lt;/code&gt; , как если бы POSIX &lt;a href=&quot;https://pubs.opengroup.org/onlinepubs/9699919799/functions/stat.html&quot;&gt;stat&lt;/a&gt; (символические ссылки следуют к их целям). В следующем описании &lt;code&gt;prms&lt;/code&gt; является результатом &lt;code&gt;(m &amp;amp; perms::mask)&lt;/code&gt; , где &lt;code&gt;m&lt;/code&gt; получается так, как если бы он брал &lt;code&gt;st_mode&lt;/code&gt; из POSIX &lt;code&gt;struct stat&lt;/code&gt; и преобразовывал его в тип &lt;code&gt;&lt;a href=&quot;perms&quot;&gt;std::filesystem::perms&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6a44ae052e348f0eb5abeb579d93acfea11ea715" translate="yes" xml:space="preserve">
          <source>1) Determines whether &lt;code&gt;Fn&lt;/code&gt; can be invoked with the arguments &lt;code&gt;ArgTypes...&lt;/code&gt;. Formally, determines whether &lt;code&gt;INVOKE(declval&amp;lt;Fn&amp;gt;(), declval&amp;lt;ArgTypes&amp;gt;()...)&lt;/code&gt; is well formed when treated as an unevaluated operand, where &lt;code&gt;INVOKE&lt;/code&gt; is the operation defined in &lt;a href=&quot;../named_req/callable&quot;&gt;Callable&lt;/a&gt;.</source>
          <target state="translated">1) Определяет , будет ли &lt;code&gt;Fn&lt;/code&gt; может быть вызвана с аргументами &lt;code&gt;ArgTypes...&lt;/code&gt; . Формально определяет, &lt;code&gt;INVOKE(declval&amp;lt;Fn&amp;gt;(), declval&amp;lt;ArgTypes&amp;gt;()...)&lt;/code&gt; ли сформирован INVOKE (declval &amp;lt;Fn&amp;gt; (), declval &amp;lt;ArgTypes&amp;gt; () ...) при обработке его как неоцененного операнда, где &lt;code&gt;INVOKE&lt;/code&gt; - операция, определенная в &lt;a href=&quot;../named_req/callable&quot;&gt;Callable&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ca298188df78ab4f447d54b4bad5cd57815e3fe1" translate="yes" xml:space="preserve">
          <source>1) Determines whether atomic access to the shared pointer pointed-to by &lt;code&gt;p&lt;/code&gt; is lock-free.</source>
          <target state="translated">1) Определяет, является ли атомарный доступ к общему указателю, на который указывает &lt;code&gt;p&lt;/code&gt; , свободным от блокировки.</target>
        </trans-unit>
        <trans-unit id="65005f1a4f1673e794ca8fd566db8cadc1934b30" translate="yes" xml:space="preserve">
          <source>1) Does not throw</source>
          <target state="translated">1)не бросает</target>
        </trans-unit>
        <trans-unit id="fab8fda7614e477a6f71346517837d8a3e567c5f" translate="yes" xml:space="preserve">
          <source>1) Each element is assigned value obtained by applying the corresponding operator to the previous value of the element and corresponding element from &lt;code&gt;v&lt;/code&gt;.</source>
          <target state="translated">1) Каждому элементу присваивается значение, полученное путем применения соответствующего оператора к предыдущему значению элемента и соответствующего элемента из &lt;code&gt;v&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8a8ff4bbb77a97d615fec33736a3f814af766ce7" translate="yes" xml:space="preserve">
          <source>1) Effectively calls &lt;code&gt;&lt;a href=&quot;mem_fun_ref_t&quot;&gt;std::mem_fun_ref_t&lt;/a&gt;&amp;lt;S,T&amp;gt;(f)&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;mem_fun_ref_t&quot;&gt;std::const_mem_fun_ref_t&lt;/a&gt;&amp;lt;S,T&amp;gt;(f)&lt;/code&gt;.</source>
          <target state="translated">1) Эффективно вызывает &lt;code&gt;&lt;a href=&quot;mem_fun_ref_t&quot;&gt;std::mem_fun_ref_t&lt;/a&gt;&amp;lt;S,T&amp;gt;(f)&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;mem_fun_ref_t&quot;&gt;std::const_mem_fun_ref_t&lt;/a&gt;&amp;lt;S,T&amp;gt;(f)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="31e828b09b6dcd4b69af6c0189e9702fd814cda6" translate="yes" xml:space="preserve">
          <source>1) Effectively calls &lt;code&gt;&lt;a href=&quot;mem_fun_t&quot;&gt;std::mem_fun_t&lt;/a&gt;&amp;lt;S,T&amp;gt;(f)&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;mem_fun_t&quot;&gt;std::const_mem_fun_t&lt;/a&gt;&amp;lt;S,T&amp;gt;(f)&lt;/code&gt;.</source>
          <target state="translated">1) Эффективно вызывает &lt;code&gt;&lt;a href=&quot;mem_fun_t&quot;&gt;std::mem_fun_t&lt;/a&gt;&amp;lt;S,T&amp;gt;(f)&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;mem_fun_t&quot;&gt;std::const_mem_fun_t&lt;/a&gt;&amp;lt;S,T&amp;gt;(f)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="46acfc8106489874b0a683e5cfada60e0e48401e" translate="yes" xml:space="preserve">
          <source>1) Effectively calls &lt;code&gt;&lt;a href=&quot;pointer_to_unary_function&quot;&gt;std::pointer_to_unary_function&lt;/a&gt;&amp;lt;Arg,Result&amp;gt;(f)&lt;/code&gt;.</source>
          <target state="translated">1) Эффективно вызывает &lt;code&gt;&lt;a href=&quot;pointer_to_unary_function&quot;&gt;std::pointer_to_unary_function&lt;/a&gt;&amp;lt;Arg,Result&amp;gt;(f)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c7400b67aeeb319d2c89e9f0544cebe1005e1706" translate="yes" xml:space="preserve">
          <source>1) Effectively calls &lt;code&gt;c.push_back(value); &lt;a href=&quot;../../algorithm/push_heap&quot;&gt;std::push_heap&lt;/a&gt;(c.begin(), c.end(), comp);&lt;/code&gt;</source>
          <target state="translated">1) Эффективно вызывает &lt;code&gt;c.push_back(value); &lt;a href=&quot;../../algorithm/push_heap&quot;&gt;std::push_heap&lt;/a&gt;(c.begin(), c.end(), comp);&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8d470e4c140bedbd34a1126e97e4400dc788fa04" translate="yes" xml:space="preserve">
          <source>1) Effectively calls &lt;code&gt;c.push_back(value)&lt;/code&gt;</source>
          <target state="translated">1) Эффективно вызывает &lt;code&gt;c.push_back(value)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="011d1f5ba60bd9d74dea06b316bbfe4e137bcdaa" translate="yes" xml:space="preserve">
          <source>1) Effectively calls &lt;code&gt;f(read_symlink(from), to)&lt;/code&gt; where &lt;code&gt;f&lt;/code&gt; is &lt;a href=&quot;create_symlink&quot;&gt;&lt;code&gt;create_symlink&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;create_symlink&quot;&gt;&lt;code&gt;create_directory_symlink&lt;/code&gt;&lt;/a&gt; depending on whether &lt;code&gt;from&lt;/code&gt; resolves to a file or directory.</source>
          <target state="translated">1) Эффективно вызывает &lt;code&gt;f(read_symlink(from), to)&lt;/code&gt; где &lt;code&gt;f&lt;/code&gt; это &lt;a href=&quot;create_symlink&quot;&gt; &lt;code&gt;create_symlink&lt;/code&gt; &lt;/a&gt; или &lt;a href=&quot;create_symlink&quot;&gt; &lt;code&gt;create_directory_symlink&lt;/code&gt; в&lt;/a&gt; зависимости от того, &lt;code&gt;from&lt;/code&gt; разрешает файл или каталог.</target>
        </trans-unit>
        <trans-unit id="e2c0e9b14b9519968975e29f74ca4f737cc3b463" translate="yes" xml:space="preserve">
          <source>1) Effectively calls &lt;code&gt;m.lock()&lt;/code&gt;. The behavior is undefined if &lt;code&gt;m&lt;/code&gt; is not a recursive mutex and the current thread already owns &lt;code&gt;m&lt;/code&gt;.</source>
          <target state="translated">1) Эффективно вызывает &lt;code&gt;m.lock()&lt;/code&gt; . Поведение не определено, если &lt;code&gt;m&lt;/code&gt; не является рекурсивным мьютексом и текущий поток уже владеет &lt;code&gt;m&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8fbed931d739878efe2242dc69e3c3ec188c93c6" translate="yes" xml:space="preserve">
          <source>1) Effectively calls &lt;code&gt;reset(r.release())&lt;/code&gt;.</source>
          <target state="translated">1) Эффективно &lt;code&gt;reset(r.release())&lt;/code&gt; вызовы (r.release ()) .</target>
        </trans-unit>
        <trans-unit id="588791ac3459488ee09ba487973c4664a54285ba" translate="yes" xml:space="preserve">
          <source>1) Elements are compared using &lt;code&gt;operator&amp;lt;&lt;/code&gt; and the ranges must be sorted with respect to the same.</source>
          <target state="translated">1) Элементы сравниваются с использованием &lt;code&gt;operator&amp;lt;&lt;/code&gt; и диапазоны должны быть отсортированы по одному и тому же.</target>
        </trans-unit>
        <trans-unit id="8cc3c33d923eee557c7b587363c490e22bf00f05" translate="yes" xml:space="preserve">
          <source>1) Elements are compared using &lt;code&gt;operator&amp;lt;&lt;/code&gt;.</source>
          <target state="translated">1) Элементы сравниваются с использованием &lt;code&gt;operator&amp;lt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0d09f5debbd2155a625dbd1f35e701b7e3c2ab3b" translate="yes" xml:space="preserve">
          <source>1) Elements are compared using &lt;code&gt;operator==&lt;/code&gt;.</source>
          <target state="translated">1) Элементы сравниваются с использованием &lt;code&gt;operator==&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fc915779f9828f296793ebde353de4de9e382deb" translate="yes" xml:space="preserve">
          <source>1) Elements are compared using &lt;code&gt;operator==&lt;/code&gt;. The behavior is undefined if it is not an &lt;a href=&quot;https://en.wikipedia.org/wiki/equivalence_relation&quot;&gt;equivalence relation&lt;/a&gt;.</source>
          <target state="translated">1) Элементы сравниваются с использованием &lt;code&gt;operator==&lt;/code&gt; . Поведение не определено, если оно не является &lt;a href=&quot;https://en.wikipedia.org/wiki/equivalence_relation&quot;&gt;отношением эквивалентности&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="05030b7bb4349fc087ee762a2cc6879e74372695" translate="yes" xml:space="preserve">
          <source>1) Enables the &lt;code&gt;boolalpha&lt;/code&gt; flag in the stream &lt;code&gt;str&lt;/code&gt; as if by calling &lt;code&gt;str.setf(&lt;a href=&quot;../ios_base/fmtflags&quot;&gt;std::ios_base::boolalpha&lt;/a&gt;)&lt;/code&gt;</source>
          <target state="translated">1) Включает флаг &lt;code&gt;boolalpha&lt;/code&gt; в потоке &lt;code&gt;str&lt;/code&gt; , как если бы он вызывал &lt;code&gt;str.setf(&lt;a href=&quot;../ios_base/fmtflags&quot;&gt;std::ios_base::boolalpha&lt;/a&gt;)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="96a972a826ee3fcdba20885c2506d308930acc88" translate="yes" xml:space="preserve">
          <source>1) Equality operator for variants:</source>
          <target state="translated">1)Оператор равенства для вариантов:</target>
        </trans-unit>
        <trans-unit id="82f9550a944d3a8df60f3b265cda2b488c9da5d5" translate="yes" xml:space="preserve">
          <source>1) Equivalent to &lt;code&gt;*this = *this + d;&lt;/code&gt;</source>
          <target state="translated">1) Эквивалент &lt;code&gt;*this = *this + d;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="41d083e1f8110bfe1557758d4d4695c37d622fdb" translate="yes" xml:space="preserve">
          <source>1) Equivalent to &lt;code&gt;*this = *this + dy;&lt;/code&gt;</source>
          <target state="translated">1) Эквивалент &lt;code&gt;*this = *this + dy;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9ce04fa95ba678e6e255c69e3ebde6576457d731" translate="yes" xml:space="preserve">
          <source>1) Equivalent to &lt;code&gt;*this = *this + y;&lt;/code&gt;</source>
          <target state="translated">1) Эквивалент &lt;code&gt;*this = *this + y;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1d9406b90ecb5fc7caa6afd7e187ab3217839eea" translate="yes" xml:space="preserve">
          <source>1) Equivalent to &lt;code&gt;++d_; return *this;&lt;/code&gt;</source>
          <target state="translated">1) Эквивалентен &lt;code&gt;++d_; return *this;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2f1d88d98b52d4717f7dcfd15653a17e454989f4" translate="yes" xml:space="preserve">
          <source>1) Equivalent to &lt;code&gt;++rep_; return *this;&lt;/code&gt;</source>
          <target state="translated">1) Эквивалентен &lt;code&gt;++rep_; return *this;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9c52d71237ed4fde0f7863911f0865e168009fdf" translate="yes" xml:space="preserve">
          <source>1) Equivalent to &lt;code&gt;&lt;a href=&quot;../system_clock&quot;&gt;std::chrono::sys_days&lt;/a&gt;(year()/month()/day())&lt;/code&gt;</source>
          <target state="translated">1) Эквивалентно &lt;code&gt;&lt;a href=&quot;../system_clock&quot;&gt;std::chrono::sys_days&lt;/a&gt;(year()/month()/day())&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="aace9380526b20cb700bec8018bdc6d389438aec" translate="yes" xml:space="preserve">
          <source>1) Equivalent to &lt;code&gt;Iter tmp = current; return *--tmp;&lt;/code&gt;</source>
          <target state="translated">1) Эквивалентно &lt;code&gt;Iter tmp = current; return *--tmp;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2aaf37e2ad0a4d3314a70e8a4edea0af77b29fd6" translate="yes" xml:space="preserve">
          <source>1) Equivalent to &lt;code&gt;bool(*this) ? **this : static_cast&amp;lt;T&amp;gt;(&lt;a href=&quot;../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;U&amp;gt;(default_value))&lt;/code&gt;</source>
          <target state="translated">1) Эквивалентно &lt;code&gt;bool(*this) ? **this : static_cast&amp;lt;T&amp;gt;(&lt;a href=&quot;../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;U&amp;gt;(default_value))&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="27ca6cdc924e29f6abac7e6f89eb8af6bc1cf7bd" translate="yes" xml:space="preserve">
          <source>1) Equivalent to &lt;code&gt;default_error_condition(code) == condition&lt;/code&gt;.</source>
          <target state="translated">1) Эквивалентен &lt;code&gt;default_error_condition(code) == condition&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="aaf68a0e9a1753e7c451d7db374905454c1660ab" translate="yes" xml:space="preserve">
          <source>1) Equivalent to &lt;code&gt;emplace&amp;lt;I&amp;gt;(&lt;a href=&quot;../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;Args&amp;gt;(args)...)&lt;/code&gt;, where &lt;code&gt;I&lt;/code&gt; is the zero-based index of &lt;code&gt;T&lt;/code&gt; in &lt;code&gt;Types...&lt;/code&gt;. This overload only participates in overload resolution if &lt;code&gt;std::is_constructible_v&amp;lt;T, Args...&amp;gt;&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, and &lt;code&gt;T&lt;/code&gt; occurs exactly once in &lt;code&gt;Types...&lt;/code&gt;</source>
          <target state="translated">1) Эквивалент &lt;code&gt;emplace&amp;lt;I&amp;gt;(&lt;a href=&quot;../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;Args&amp;gt;(args)...)&lt;/code&gt; , где &lt;code&gt;I&lt;/code&gt; с нуля индекс &lt;code&gt;T&lt;/code&gt; в &lt;code&gt;Types...&lt;/code&gt; . Эта перегрузка участвует только в разрешении перегрузки, если &lt;code&gt;std::is_constructible_v&amp;lt;T, Args...&amp;gt;&lt;/code&gt; имеет значение &lt;code&gt;true&lt;/code&gt; , и &lt;code&gt;T&lt;/code&gt; встречается ровно один раз в &lt;code&gt;Types...&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0c1e7f7def0b0c1e4bc97e06e0f684adad56ecd5" translate="yes" xml:space="preserve">
          <source>1) Equivalent to &lt;code&gt;exists(s) &amp;amp;&amp;amp; !is_regular_file(s) &amp;amp;&amp;amp; !is_directory(s) &amp;amp;&amp;amp; !is_symlink(s)&lt;/code&gt;.</source>
          <target state="translated">1) Эквивалент &lt;code&gt;exists(s) &amp;amp;&amp;amp; !is_regular_file(s) &amp;amp;&amp;amp; !is_directory(s) &amp;amp;&amp;amp; !is_symlink(s)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d3c543a72231a15ed9a65b4120bd54a699a7d90c" translate="yes" xml:space="preserve">
          <source>1) Equivalent to &lt;code&gt;lhs.equal(rhs)&lt;/code&gt;.</source>
          <target state="translated">1) Эквивалентно &lt;code&gt;lhs.equal(rhs)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6f78f1b1933f2be104c9b36333cbd8655ec420b2" translate="yes" xml:space="preserve">
          <source>1) Equivalent to &lt;code&gt;native().c_str()&lt;/code&gt;.</source>
          <target state="translated">1) Эквивалентно &lt;code&gt;native().c_str()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5960311674c16cc0cc1bf3867e9d05c22ddeb540" translate="yes" xml:space="preserve">
          <source>1) Equivalent to &lt;code&gt;rep_ += d.count(); return *this;&lt;/code&gt;</source>
          <target state="translated">1) Эквивалентен &lt;code&gt;rep_ += d.count(); return *this;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9df00ac4a641d9e8760432c2ae7533cb453b1bce" translate="yes" xml:space="preserve">
          <source>1) Equivalent to &lt;code&gt;return !&lt;a href=&quot;invoke&quot;&gt;std::invoke&lt;/a&gt;(fd, &lt;a href=&quot;../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;Args&amp;gt;(args)...)&lt;/code&gt;</source>
          <target state="translated">1) Эквивалент &lt;code&gt;return !&lt;a href=&quot;invoke&quot;&gt;std::invoke&lt;/a&gt;(fd, &lt;a href=&quot;../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;Args&amp;gt;(args)...)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d36ac7d6e30651e85b700452df731bf1029a32f0" translate="yes" xml:space="preserve">
          <source>1) Equivalent to &lt;code&gt;return &lt;a href=&quot;../any&quot;&gt;std::any&lt;/a&gt;(&lt;a href=&quot;../in_place&quot;&gt;std::in_place_type&lt;/a&gt;&amp;lt;T&amp;gt;, &lt;a href=&quot;../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;Args&amp;gt;(args)...);&lt;/code&gt;</source>
          <target state="translated">1) Эквивалент &lt;code&gt;return &lt;a href=&quot;../any&quot;&gt;std::any&lt;/a&gt;(&lt;a href=&quot;../in_place&quot;&gt;std::in_place_type&lt;/a&gt;&amp;lt;T&amp;gt;, &lt;a href=&quot;../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;Args&amp;gt;(args)...);&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="47f69e5f8468517d7589e267f72b1dbbba5c3293" translate="yes" xml:space="preserve">
          <source>1) Equivalent to &lt;code&gt;return D(*this);&lt;/code&gt;</source>
          <target state="translated">1) Эквивалент &lt;code&gt;return D(*this);&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="783946ea6f8a3464885e40163c1c9564f4ceea63" translate="yes" xml:space="preserve">
          <source>1) Equivalent to &lt;code&gt;return r.begin();&lt;/code&gt;</source>
          <target state="translated">1) Эквивалентен для &lt;code&gt;return r.begin();&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3f4fc870674f5fb012dd975ee57837cfeab7d645" translate="yes" xml:space="preserve">
          <source>1) Equivalent to &lt;code&gt;s.type() == file_type::block&lt;/code&gt;.</source>
          <target state="translated">1) Эквивалентно &lt;code&gt;s.type() == file_type::block&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9b1ed7de20f555f8534e2a84d964c966bd9d5cde" translate="yes" xml:space="preserve">
          <source>1) Equivalent to &lt;code&gt;s.type() == file_type::character&lt;/code&gt;.</source>
          <target state="translated">1) Эквивалентно &lt;code&gt;s.type() == file_type::character&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="897ad8584bbbaddb6b9248b6dea56350ebb88d4c" translate="yes" xml:space="preserve">
          <source>1) Equivalent to &lt;code&gt;s.type() == file_type::directory&lt;/code&gt;.</source>
          <target state="translated">1) Эквивалентно &lt;code&gt;s.type() == file_type::directory&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a63e546b555f8572521590a9d2ea549dc2ae2235" translate="yes" xml:space="preserve">
          <source>1) Equivalent to &lt;code&gt;s.type() == file_type::fifo&lt;/code&gt;.</source>
          <target state="translated">1) Эквивалентно &lt;code&gt;s.type() == file_type::fifo&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="98720eb9c80b5e9a08ada8eb5db1b51aa2e92d32" translate="yes" xml:space="preserve">
          <source>1) Equivalent to &lt;code&gt;s.type() == file_type::regular&lt;/code&gt;.</source>
          <target state="translated">1) Эквивалентно &lt;code&gt;s.type() == file_type::regular&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="05305515a6902b55a79c88270ce56bc514f70239" translate="yes" xml:space="preserve">
          <source>1) Equivalent to &lt;code&gt;s.type() == file_type::socket&lt;/code&gt;.</source>
          <target state="translated">1) Эквивалентно &lt;code&gt;s.type() == file_type::socket&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ab8b95a7b2ea4746283ea27160065e146ccff49a" translate="yes" xml:space="preserve">
          <source>1) Equivalent to &lt;code&gt;s.type() == file_type::symlink&lt;/code&gt;.</source>
          <target state="translated">1) Эквивалентно &lt;code&gt;s.type() == file_type::symlink&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="179ac5c7fc855225a87152301381a704450b6c4a" translate="yes" xml:space="preserve">
          <source>1) Equivalent to &lt;code&gt;static_cast&amp;lt;reference&amp;gt;(*base())&lt;/code&gt;;</source>
          <target state="translated">1) Эквивалентно &lt;code&gt;static_cast&amp;lt;reference&amp;gt;(*base())&lt;/code&gt; ;</target>
        </trans-unit>
        <trans-unit id="538ab1915dd3230391d766df1b4a3748da3f84c1" translate="yes" xml:space="preserve">
          <source>1) Equivalent to &lt;code&gt;status_known(s) &amp;amp;&amp;amp; s.type() != file_type::not_found&lt;/code&gt;.</source>
          <target state="translated">1) Эквивалентен &lt;code&gt;status_known(s) &amp;amp;&amp;amp; s.type() != file_type::not_found&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9d8fb771283367cf610ecf5e023e663a4fe8645b" translate="yes" xml:space="preserve">
          <source>1) Equivalent to &lt;code&gt;std::move(*base())&lt;/code&gt;;</source>
          <target state="translated">1) Эквивалентен &lt;code&gt;std::move(*base())&lt;/code&gt; ;</target>
        </trans-unit>
        <trans-unit id="8df252cd519d51da4b9b18b92bb448ad32a642e9" translate="yes" xml:space="preserve">
          <source>1) Equivalent to &lt;code&gt;transform_reduce(first1, last1, first2, init, std::plus&amp;lt;&amp;gt;(), std::multiplies&amp;lt;&amp;gt;());&lt;/code&gt;, effectively parallelized version of the default &lt;code&gt;&lt;a href=&quot;inner_product&quot;&gt;std::inner_product&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">1) Эквивалентен &lt;code&gt;transform_reduce(first1, last1, first2, init, std::plus&amp;lt;&amp;gt;(), std::multiplies&amp;lt;&amp;gt;());&lt;/code&gt; , эффективно распараллеленная версия стандартного &lt;code&gt;&lt;a href=&quot;inner_product&quot;&gt;std::inner_product&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8a1464ca469f44a3064f6e7b09b363ce619c9a97" translate="yes" xml:space="preserve">
          <source>1) Equivalent to:</source>
          <target state="translated">1)Эквивалентно:</target>
        </trans-unit>
        <trans-unit id="f32c1f81db0f32f22596c137532eaf553b842a7b" translate="yes" xml:space="preserve">
          <source>1) Equivalent to: &lt;code&gt;return b = b &amp;lt;&amp;lt; shift;&lt;/code&gt; This overload only participates in overload resolution if &lt;code&gt;&lt;a href=&quot;is_integral&quot;&gt;std::is_integral_v&lt;/a&gt;&amp;lt;IntegerType&amp;gt;&lt;/code&gt; is true.</source>
          <target state="translated">1) Эквивалентно: &lt;code&gt;return b = b &amp;lt;&amp;lt; shift;&lt;/code&gt; Эта перегрузка участвует только в разрешении перегрузки, если &lt;code&gt;&lt;a href=&quot;is_integral&quot;&gt;std::is_integral_v&lt;/a&gt;&amp;lt;IntegerType&amp;gt;&lt;/code&gt; имеет значение true.</target>
        </trans-unit>
        <trans-unit id="ce50226b3eed2748aea0ee2f4a0f21490b16d346" translate="yes" xml:space="preserve">
          <source>1) Equivalent to: &lt;code&gt;return l = l | r;&lt;/code&gt;.</source>
          <target state="translated">1) Эквивалентно: &lt;code&gt;return l = l | r;&lt;/code&gt; ,</target>
        </trans-unit>
        <trans-unit id="a824e001a18c6b6d534ce889aabe17e30fbd0108" translate="yes" xml:space="preserve">
          <source>1) Equivalent to: &lt;code&gt;return std::byte(static_cast&amp;lt;unsigned int&amp;gt;(b) &amp;lt;&amp;lt; shift);&lt;/code&gt; This overload only participates in overload resolution if &lt;code&gt;&lt;a href=&quot;is_integral&quot;&gt;std::is_integral_v&lt;/a&gt;&amp;lt;IntegerType&amp;gt;&lt;/code&gt; is true.</source>
          <target state="translated">1) Эквивалентно: &lt;code&gt;return std::byte(static_cast&amp;lt;unsigned int&amp;gt;(b) &amp;lt;&amp;lt; shift);&lt;/code&gt; Эта перегрузка участвует только в разрешении перегрузки, если &lt;code&gt;&lt;a href=&quot;is_integral&quot;&gt;std::is_integral_v&lt;/a&gt;&amp;lt;IntegerType&amp;gt;&lt;/code&gt; имеет значение true.</target>
        </trans-unit>
        <trans-unit id="50ddbf3ee011e6961ef6494bf423ec3c2c018228" translate="yes" xml:space="preserve">
          <source>1) Equivalent to: &lt;code&gt;return std::byte(static_cast&amp;lt;unsigned int&amp;gt;(l) | static_cast&amp;lt;unsigned int&amp;gt;(r));&lt;/code&gt;.</source>
          <target state="translated">1) Эквивалентно: &lt;code&gt;return std::byte(static_cast&amp;lt;unsigned int&amp;gt;(l) | static_cast&amp;lt;unsigned int&amp;gt;(r));&lt;/code&gt; ,</target>
        </trans-unit>
        <trans-unit id="b33dd7c481fdd2621d129a0b3503bdf96a3c1775" translate="yes" xml:space="preserve">
          <source>1) Erases all elements that compare equal to &lt;code&gt;value&lt;/code&gt; from the container. Equivalent to &lt;code&gt;c.erase(std::remove(c.begin(), c.end(), value), c.end());&lt;/code&gt;</source>
          <target state="translated">1) Стирает все элементы, которые сравниваются равными &lt;code&gt;value&lt;/code&gt; из контейнера. Эквивалент &lt;code&gt;c.erase(std::remove(c.begin(), c.end(), value), c.end());&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0cb1efcdcc78f435229d9add9af0fde373e753a3" translate="yes" xml:space="preserve">
          <source>1) Erases all elements that compare equal to &lt;code&gt;value&lt;/code&gt; from the container. Equivalent to &lt;code&gt;c.remove_if([&amp;amp;](auto&amp;amp; elem) { return elem == value; });&lt;/code&gt;</source>
          <target state="translated">1) Стирает все элементы, которые сравниваются равными &lt;code&gt;value&lt;/code&gt; из контейнера. Эквивалент &lt;code&gt;c.remove_if([&amp;amp;](auto&amp;amp; elem) { return elem == value; });&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1797656c42e6ae99b3e7edb8a97b39fe346fd5bd" translate="yes" xml:space="preserve">
          <source>1) Evaluates the expression, terminates the current function and returns the result of the expression to the caller, after &lt;a href=&quot;implicit_cast&quot;&gt;implicit conversion&lt;/a&gt; to the function return type. The expression is optional in functions whose return type is (possibly cv-qualified) &lt;code&gt;void&lt;/code&gt;, and disallowed in constructors and in destructors.</source>
          <target state="translated">1) Оценивает выражение, завершает текущую функцию и возвращает результат выражения вызывающей стороне после &lt;a href=&quot;implicit_cast&quot;&gt;неявного преобразования&lt;/a&gt; в возвращаемый тип функции. Выражение является необязательным в функциях, чей тип возврата (возможно, cv-квалифицированный) &lt;code&gt;void&lt;/code&gt; , и запрещен в конструкторах и в деструкторах.</target>
        </trans-unit>
        <trans-unit id="4a7dddb18cbda7dbc3e902e0510c2c2998153f38" translate="yes" xml:space="preserve">
          <source>1) Exactly &lt;code&gt;N&lt;/code&gt; applications of the predicate and &lt;code&gt;O(N)&lt;/code&gt; swaps if there is enough extra memory. If memory is insufficient, at most &lt;code&gt;N log N&lt;/code&gt; swaps.</source>
          <target state="translated">1) Ровно &lt;code&gt;N&lt;/code&gt; приложений предиката и &lt;code&gt;O(N)&lt;/code&gt; подкачки, если есть достаточно дополнительной памяти. Если памяти недостаточно, самое большее &lt;code&gt;N log N&lt;/code&gt; перестановок.</target>
        </trans-unit>
        <trans-unit id="d85c974f9fac4ed00ac82960b3a7f736c51ad8ce" translate="yes" xml:space="preserve">
          <source>1) Exactly N applications of the predicate. At most N/2 swaps if &lt;code&gt;ForwardIt&lt;/code&gt; meets the requirements of &lt;a href=&quot;../named_req/bidirectionaliterator&quot;&gt;LegacyBidirectionalIterator&lt;/a&gt;, and at most N swaps otherwise.</source>
          <target state="translated">1) Точно N приложений предиката. Не более N / 2 свопов, если &lt;code&gt;ForwardIt&lt;/code&gt; соответствует требованиям &lt;a href=&quot;../named_req/bidirectionaliterator&quot;&gt;LegacyBidirectionalIterator&lt;/a&gt; , и не более N свопов в противном случае.</target>
        </trans-unit>
        <trans-unit id="3898a5e907961e19d6f3818b3f6c38e485189ef0" translate="yes" xml:space="preserve">
          <source>1) Exchanges elements between range &lt;code&gt;[first1, last1)&lt;/code&gt; and another range starting at &lt;code&gt;first2&lt;/code&gt;.</source>
          <target state="translated">1) Обмен элементами между диапазоном &lt;code&gt;[first1, last1)&lt;/code&gt; и другим диапазоном, начинающимся с &lt;code&gt;first2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2cd67e4d55cd7feca04c7b3f2ebf39800dd11361" translate="yes" xml:space="preserve">
          <source>1) Explicit instantiation definition</source>
          <target state="translated">1)Прямое определение конкретизации</target>
        </trans-unit>
        <trans-unit id="06804e68db44d5febdac7eef45d88e3b0a1f984d" translate="yes" xml:space="preserve">
          <source>1) Explicit instantiation definition (without &lt;a href=&quot;template_argument_deduction&quot;&gt;template argument deduction&lt;/a&gt; if every non-default template parameter is explicitly specified)</source>
          <target state="translated">1) Явное определение экземпляра (без &lt;a href=&quot;template_argument_deduction&quot;&gt;вычета аргумента шаблона,&lt;/a&gt; если явно указан каждый параметр шаблона не по умолчанию)</target>
        </trans-unit>
        <trans-unit id="e49d0053d14d536a2855f480783e3fc7be7596bc" translate="yes" xml:space="preserve">
          <source>1) Explicitly defaulted copy assignment operator that copy assigns the base class (&lt;code&gt;OuterAlloc&lt;/code&gt;, the outer allocator) and all inner allocators.</source>
          <target state="translated">1) Явно &lt;code&gt;OuterAlloc&lt;/code&gt; умолчанию оператор присвоения копии, который копирует, назначает базовый класс ( OuterAlloc , внешний распределитель) и все внутренние распределители.</target>
        </trans-unit>
        <trans-unit id="a4749611efc7cb267b48bb41ce78225481d0be01" translate="yes" xml:space="preserve">
          <source>1) Fancy pointer overload: If the expression &lt;code&gt;&lt;a href=&quot;pointer_traits&quot;&gt;std::pointer_traits&lt;/a&gt;&amp;lt;Ptr&amp;gt;::to_address(p)&lt;/code&gt; is well-formed, returns the result of that expression. Otherwise, returns &lt;code&gt;std::to_address(p.operator-&amp;gt;())&lt;/code&gt;.</source>
          <target state="translated">1) Необычная перегрузка указателя: если выражение &lt;code&gt;&lt;a href=&quot;pointer_traits&quot;&gt;std::pointer_traits&lt;/a&gt;&amp;lt;Ptr&amp;gt;::to_address(p)&lt;/code&gt; правильно сформировано, возвращает результат этого выражения. В противном случае возвращает &lt;code&gt;std::to_address(p.operator-&amp;gt;())&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7990d512de136056ee815911efb4602f71ddedef" translate="yes" xml:space="preserve">
          <source>1) File permissions information.</source>
          <target state="translated">1)Информация о разрешениях на доступ к файлам.</target>
        </trans-unit>
        <trans-unit id="27c1e10d4c10af58dfddd5cff99066596a87eea5" translate="yes" xml:space="preserve">
          <source>1) File type information.</source>
          <target state="translated">1)Информация о типе файла.</target>
        </trans-unit>
        <trans-unit id="f4fc5fa63bf321ae1e98780408b5986c98eb7933" translate="yes" xml:space="preserve">
          <source>1) Finds the first character equal to none of characters in &lt;code&gt;str&lt;/code&gt;.</source>
          <target state="translated">1) Находит первый символ, равный ни одному из символов в &lt;code&gt;str&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7e79c22b35aadf16bbb2bbdbbd059e4bce47a02e" translate="yes" xml:space="preserve">
          <source>1) Finds the first character equal to one of the characters in &lt;code&gt;str&lt;/code&gt;.</source>
          <target state="translated">1) Находит первый символ, равный одному из символов в &lt;code&gt;str&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="442f6a60a472a2e1141c1b6fb37c658af721c0e6" translate="yes" xml:space="preserve">
          <source>1) Finds the first character not equal to any of the characters of &lt;code&gt;v&lt;/code&gt; in this view, starting at position &lt;code&gt;pos&lt;/code&gt;.</source>
          <target state="translated">1) Находит первый символ, не равный ни одному из символов &lt;code&gt;v&lt;/code&gt; в этом представлении, начиная с позиции &lt;code&gt;pos&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="51cda46cabb3895bd9df4ec43f3daadbc2f64384" translate="yes" xml:space="preserve">
          <source>1) Finds the first occurence of &lt;code&gt;v&lt;/code&gt; in this view, starting at position &lt;code&gt;pos&lt;/code&gt;.</source>
          <target state="translated">1) Находит первое вхождение &lt;code&gt;v&lt;/code&gt; в этом представлении, начиная с позиции &lt;code&gt;pos&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fd62aaa68509bd9a4fb9fb278bc9c7d8c255380a" translate="yes" xml:space="preserve">
          <source>1) Finds the first occurence of any of the characters of &lt;code&gt;v&lt;/code&gt; in this view, starting at position &lt;code&gt;pos&lt;/code&gt;.</source>
          <target state="translated">1) Находит первое вхождение любого из символов &lt;code&gt;v&lt;/code&gt; в этом представлении, начиная с позиции &lt;code&gt;pos&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="991eb68c46670361f174f149c9bbff9453009cbe" translate="yes" xml:space="preserve">
          <source>1) Finds the first substring equal to &lt;code&gt;str&lt;/code&gt;.</source>
          <target state="translated">1) Находит первую подстроку, равную &lt;code&gt;str&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6704dbd43b3ce3882e6b0b77ffcd5282c0cd6ca9" translate="yes" xml:space="preserve">
          <source>1) Finds the last character equal to none of characters in &lt;code&gt;str&lt;/code&gt;.</source>
          <target state="translated">1) Находит последний символ, равный ни одному из символов в &lt;code&gt;str&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ce86bceaea369df79d331c69a11951d70d544899" translate="yes" xml:space="preserve">
          <source>1) Finds the last character equal to one of characters in &lt;code&gt;str&lt;/code&gt;.</source>
          <target state="translated">1) Находит последний символ, равный одному из символов в &lt;code&gt;str&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="70fd55a6b81aaf507648a0cddd92b8c633cda844" translate="yes" xml:space="preserve">
          <source>1) Finds the last character not equal to any of the characters of &lt;code&gt;v&lt;/code&gt; in this view, starting at position &lt;code&gt;pos&lt;/code&gt;.</source>
          <target state="translated">1) Находит последний символ, не равный ни одному из символов &lt;code&gt;v&lt;/code&gt; в этом представлении, начиная с позиции &lt;code&gt;pos&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7a117a35d4790c36ea6419c73a7d006ccff236b7" translate="yes" xml:space="preserve">
          <source>1) Finds the last occurence of &lt;code&gt;v&lt;/code&gt; in this view, starting at position &lt;code&gt;pos&lt;/code&gt;.</source>
          <target state="translated">1) Находит последнее вхождение &lt;code&gt;v&lt;/code&gt; в этом представлении, начиная с позиции &lt;code&gt;pos&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="950316330142526c0ea12d1cb0ce500d7d27ceb8" translate="yes" xml:space="preserve">
          <source>1) Finds the last occurence of any of the characters of &lt;code&gt;v&lt;/code&gt; in this view, ending at position &lt;code&gt;pos&lt;/code&gt;.</source>
          <target state="translated">1) Находит последнее вхождение любого из символов &lt;code&gt;v&lt;/code&gt; в этом представлении, заканчивающееся в позиции &lt;code&gt;pos&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cc6591ef2b8655c84fe527417b8508f21209a752" translate="yes" xml:space="preserve">
          <source>1) Finds the last substring equal to &lt;code&gt;str&lt;/code&gt;.</source>
          <target state="translated">1) Находит последнюю подстроку, равную &lt;code&gt;str&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bfb87cff99851f1a19a7bc551155598781e3afd7" translate="yes" xml:space="preserve">
          <source>1) First calls &lt;code&gt;&lt;a href=&quot;close&quot;&gt;close()&lt;/a&gt;&lt;/code&gt; to close the associated file, then moves the contents of &lt;code&gt;rhs&lt;/code&gt; into &lt;code&gt;*this&lt;/code&gt;: the put and get buffers, the associated file, the locale, the openmode, the is_open flag, and any other state. After the move, &lt;code&gt;rhs&lt;/code&gt; is not associated with a file and &lt;code&gt;rhs.is_open() == false&lt;/code&gt;.</source>
          <target state="translated">1) Сначала вызывается &lt;code&gt;&lt;a href=&quot;close&quot;&gt;close()&lt;/a&gt;&lt;/code&gt; чтобы закрыть связанный файл, затем перемещает содержимое &lt;code&gt;rhs&lt;/code&gt; в &lt;code&gt;*this&lt;/code&gt; : буферы put и get, связанный файл, языковой стандарт, openmode, флаг is_open и любое другое состояние. После перемещения &lt;code&gt;rhs&lt;/code&gt; не ассоциируется с файлом, а &lt;code&gt;rhs.is_open() == false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="dd18b72a5a285015ba6ec06d12d8ef6d1cba7955" translate="yes" xml:space="preserve">
          <source>1) First converts &lt;code&gt;f&lt;/code&gt; to some temporary value &lt;code&gt;m&lt;/code&gt; of type &lt;code&gt;&lt;a href=&quot;../../locale/ctype_base&quot;&gt;std::ctype_base::mask&lt;/a&gt;&lt;/code&gt; in implementation-defined manner</source>
          <target state="translated">1) Сначала преобразует &lt;code&gt;f&lt;/code&gt; в некоторое временное значение &lt;code&gt;m&lt;/code&gt; типа &lt;code&gt;&lt;a href=&quot;../../locale/ctype_base&quot;&gt;std::ctype_base::mask&lt;/a&gt;&lt;/code&gt; в соответствии с реализацией</target>
        </trans-unit>
        <trans-unit id="66258cec208a65037d1db76ff3382868c359cbe4" translate="yes" xml:space="preserve">
          <source>1) First, &lt;a href=&quot;copy_initialization&quot;&gt;copy-initializes&lt;/a&gt; the</source>
          <target state="translated">1) Во- первых, &lt;a href=&quot;copy_initialization&quot;&gt;копирования инициализирует&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="cd33253b53a6763ed072481c1c0f67e8204b5635" translate="yes" xml:space="preserve">
          <source>1) First, decl-specifier-seq and the declarator are combined as in any &lt;a href=&quot;declarations&quot;&gt;declaration&lt;/a&gt; to determine the type.</source>
          <target state="translated">1) Во-первых, decl-specier-seq и декларатор объединяются, как и в любом &lt;a href=&quot;declarations&quot;&gt;объявлении,&lt;/a&gt; для определения типа.</target>
        </trans-unit>
        <trans-unit id="24a19262c4d1f80ce9e0dc9caab9f79a6b0bff5b" translate="yes" xml:space="preserve">
          <source>1) Flips all bits (like &lt;code&gt;&lt;a href=&quot;operator_logic&quot;&gt;operator~&lt;/a&gt;&lt;/code&gt;, but in-place)</source>
          <target state="translated">1) Переворачивает все биты (как &lt;code&gt;&lt;a href=&quot;operator_logic&quot;&gt;operator~&lt;/a&gt;&lt;/code&gt; , но на месте)</target>
        </trans-unit>
        <trans-unit id="5300a7112838d676f5f66db26a00a4959307ece8" translate="yes" xml:space="preserve">
          <source>1) Floating point value identifying the &amp;alpha; parameter</source>
          <target state="translated">1) Значение с плавающей точкой, определяющее параметр &amp;alpha;</target>
        </trans-unit>
        <trans-unit id="0e6b85b611c8ca2ab85cbbefdb0db71abdb9bd30" translate="yes" xml:space="preserve">
          <source>1) For an object of type X using the class member access operator</source>
          <target state="translated">1)Для объекта типа X с помощью оператора доступа члена класса</target>
        </trans-unit>
        <trans-unit id="620d62ba1adcb76635cafe39e1be9ff044838905" translate="yes" xml:space="preserve">
          <source>1) For arguments of fundamental type, the associated set of namespaces and classes is empty</source>
          <target state="translated">1)Для аргументов фундаментального типа соответствующий набор пространств имен и классов пуст.</target>
        </trans-unit>
        <trans-unit id="0c378136ab43e1fdcea07a911ec40f85b088db94" translate="yes" xml:space="preserve">
          <source>1) For every named variable with static or thread-local &lt;a href=&quot;storage_duration&quot;&gt;storage duration&lt;/a&gt;that is not subject to &lt;a href=&quot;constant_initialization&quot;&gt;constant initialization&lt;/a&gt;(since C++14), before any other initialization.</source>
          <target state="translated">1) Для каждой именованной переменной со статическим или локальным потоком &lt;a href=&quot;storage_duration&quot;&gt;хранилища,&lt;/a&gt; которая не подлежит &lt;a href=&quot;constant_initialization&quot;&gt;постоянной инициализации&lt;/a&gt; (начиная с C ++ 14), перед любой другой инициализацией.</target>
        </trans-unit>
        <trans-unit id="a2228ff5f261316a14c0c628f07410bc975495de" translate="yes" xml:space="preserve">
          <source>1) For the built-in operator, one of the expressions (either expr1 or expr2) must be a glvalue of type &amp;ldquo;array of T&amp;rdquo; or a prvalue of type &amp;ldquo;pointer to T&amp;rdquo;, while the other expression (expr2 or expr1, respectively) must be a prvalue of unscoped enumeration or integral type. The result of this expression has the type &lt;code&gt;T&lt;/code&gt;</source>
          <target state="translated">1) Для встроенного оператора одно из выражений (expr1 или expr2) должно быть glvalue типа &amp;laquo;массив T&amp;raquo; или prvalue типа &amp;laquo;указатель на T&amp;raquo;, тогда как другое выражение (expr2 или expr1, соответственно) должно быть типом перечисления с незаданной областью или целочисленного типа. Результат этого выражения имеет тип &lt;code&gt;T&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="908b6cc5f8feeba46b723cf8345b6e77ca24c647" translate="yes" xml:space="preserve">
          <source>1) For user-defined integer literals</source>
          <target state="translated">1)Для заданных пользователем целочисленных литералов</target>
        </trans-unit>
        <trans-unit id="8f2bdea671ba63209e8908fa5f60f318cc0d7593" translate="yes" xml:space="preserve">
          <source>1) Forms lvalue reference to const type of &lt;code&gt;t&lt;/code&gt;</source>
          <target state="translated">1) Формирует lvalue ссылку на const тип &lt;code&gt;t&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="10e52e4189c8c4f69c3b43f760a5733f16a0cecd" translate="yes" xml:space="preserve">
          <source>1) Forwards lvalues as either lvalues or as rvalues, depending on T</source>
          <target state="translated">1)Передает значения как значения или как значения,в зависимости от T</target>
        </trans-unit>
        <trans-unit id="0aa251b9780dd1a068e6af33ad51fdab09a9b853" translate="yes" xml:space="preserve">
          <source>1) Full declaration.</source>
          <target state="translated">1)Полная декларация.</target>
        </trans-unit>
        <trans-unit id="d52437442bfb9b172705dc9281744b3b9dabeae9" translate="yes" xml:space="preserve">
          <source>1) Given &lt;code&gt;current_ptr&lt;/code&gt;, the pointer that was managed by &lt;code&gt;*this&lt;/code&gt;, performs the following actions, in this order:</source>
          <target state="translated">1) С учетом &lt;code&gt;current_ptr&lt;/code&gt; , указатель, которым управлял &lt;code&gt;*this&lt;/code&gt; , выполняет следующие действия в следующем порядке:</target>
        </trans-unit>
        <trans-unit id="c25bb4537de07ca2e9c955609fc621b56b5c86ae" translate="yes" xml:space="preserve">
          <source>1) Half the sum of &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt;. No overflow occurs. If &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; have integer type and the sum is odd, the result is rounded towards &lt;code&gt;a&lt;/code&gt;. If &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; have floating-point type, at most one inexact operation occurs.</source>
          <target state="translated">1) Половина суммы &lt;code&gt;a&lt;/code&gt; и &lt;code&gt;b&lt;/code&gt; . Переполнения не происходит. Если &lt;code&gt;a&lt;/code&gt; и &lt;code&gt;b&lt;/code&gt; имеют целочисленный тип, а сумма нечетная, результат округляется до &lt;code&gt;a&lt;/code&gt; . Если &lt;code&gt;a&lt;/code&gt; и &lt;code&gt;b&lt;/code&gt; имеют тип с плавающей запятой, происходит не более одной неточной операции.</target>
        </trans-unit>
        <trans-unit id="389c5e318417b817814b4e4cfab6dc113e1fc480" translate="yes" xml:space="preserve">
          <source>1) If &lt;code&gt;*this&lt;/code&gt; contains a value before the call, the contained value is destroyed by calling its destructor as if by &lt;code&gt;value().T::~T()&lt;/code&gt;. &lt;code&gt;*this&lt;/code&gt; does not contain a value after this call.</source>
          <target state="translated">1) Если &lt;code&gt;*this&lt;/code&gt; содержит значение перед вызовом, содержащееся в нем значение уничтожается путем вызова его деструктора, как будто через &lt;code&gt;value().T::~T()&lt;/code&gt; . &lt;code&gt;*this&lt;/code&gt; не содержит значения после этого вызова.</target>
        </trans-unit>
        <trans-unit id="5c29eb73572b5b54b5bde81bc8cece3cd885b3b2" translate="yes" xml:space="preserve">
          <source>1) If &lt;code&gt;&lt;a href=&quot;../concepts/assignable&quot;&gt;Assignable&lt;/a&gt;&amp;lt;T&amp;amp;, const T&amp;amp;&amp;gt;&lt;/code&gt; is not satisfied, the copy assignment operator's body is equivalent to &lt;code&gt;if (other) emplace(*other); else reset(); return *this;&lt;/code&gt;.</source>
          <target state="translated">1) Если &lt;code&gt;&lt;a href=&quot;../concepts/assignable&quot;&gt;Assignable&lt;/a&gt;&amp;lt;T&amp;amp;, const T&amp;amp;&amp;gt;&lt;/code&gt; не выполняется, тело оператора копирования равнозначно &lt;code&gt;if (other) emplace(*other); else reset(); return *this;&lt;/code&gt; ,</target>
        </trans-unit>
        <trans-unit id="6d43ce007d320a6fcb3a66694c64b2aa6772b3c7" translate="yes" xml:space="preserve">
          <source>1) If &lt;code&gt;&lt;a href=&quot;exception_ptr&quot;&gt;std::exception_ptr&lt;/a&gt;&lt;/code&gt; stores a copy of the caught exception and if the copy constructor of the exception object caught by &lt;code&gt;&lt;a href=&quot;current_exception&quot;&gt;std::current_exception&lt;/a&gt;&lt;/code&gt; throws an exception, the captured exception is an instance of &lt;code&gt;std::bad_exception&lt;/code&gt;.</source>
          <target state="translated">1) Если &lt;code&gt;&lt;a href=&quot;exception_ptr&quot;&gt;std::exception_ptr&lt;/a&gt;&lt;/code&gt; хранит копию перехваченного исключения и если конструктор копирования объекта исключения, перехваченного &lt;code&gt;&lt;a href=&quot;current_exception&quot;&gt;std::current_exception&lt;/a&gt;&lt;/code&gt; выдает исключение, захваченное исключение является экземпляром &lt;code&gt;std::bad_exception&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="871b74ba2e944632eb24642e2095fcaae5540862" translate="yes" xml:space="preserve">
          <source>1) If &lt;code&gt;&lt;a href=&quot;is_constructible&quot;&gt;std::is_constructible&lt;/a&gt;&amp;lt;T&amp;gt;::value&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, provides the member constant &lt;code&gt;value&lt;/code&gt; equal to &lt;code&gt;true&lt;/code&gt;, otherwise &lt;code&gt;value&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">1) Если &lt;code&gt;&lt;a href=&quot;is_constructible&quot;&gt;std::is_constructible&lt;/a&gt;&amp;lt;T&amp;gt;::value&lt;/code&gt; имеет значение &lt;code&gt;true&lt;/code&gt; , &lt;code&gt;value&lt;/code&gt; константы члена равно &lt;code&gt;true&lt;/code&gt; , в противном случае &lt;code&gt;value&lt;/code&gt; равно &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2558dfd99cfdc502e01a5c094f7431492308ad2e" translate="yes" xml:space="preserve">
          <source>1) If &lt;code&gt;P&lt;/code&gt; is a reference type, the deduced &lt;code&gt;A&lt;/code&gt; (i.e., the type referred to by the reference) can be more cv-qualified than the transformed &lt;code&gt;A&lt;/code&gt;:</source>
          <target state="translated">1) Если &lt;code&gt;P&lt;/code&gt; является ссылочным типом, выведенный &lt;code&gt;A&lt;/code&gt; (т. Е. Тип, на который ссылается ссылка) может быть более квалифицированным по cv, чем преобразованный &lt;code&gt;A&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="e6b573b161e778f9527a59ca867befe70e44b598" translate="yes" xml:space="preserve">
          <source>1) If &lt;code&gt;P&lt;/code&gt; is not a reference type,</source>
          <target state="translated">1) Если &lt;code&gt;P&lt;/code&gt; не является ссылочным типом,</target>
        </trans-unit>
        <trans-unit id="6f224d7d59ccb2a0648c9f79474f4f6215450b64" translate="yes" xml:space="preserve">
          <source>1) If &lt;code&gt;T&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;reference_wrapper&quot;&gt;std::reference_wrapper&lt;/a&gt;&amp;lt;U&amp;gt;&lt;/code&gt; for some type &lt;code&gt;U&lt;/code&gt;, provides a member typedef &lt;code&gt;type&lt;/code&gt; that names &lt;code&gt;U&amp;amp;&lt;/code&gt;; otherwise, provides a member typedef &lt;code&gt;type&lt;/code&gt; that names &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">1) Если &lt;code&gt;T&lt;/code&gt; является &lt;code&gt;&lt;a href=&quot;reference_wrapper&quot;&gt;std::reference_wrapper&lt;/a&gt;&amp;lt;U&amp;gt;&lt;/code&gt; для некоторого типа &lt;code&gt;U&lt;/code&gt; , предоставляет &lt;code&gt;type&lt;/code&gt; typedef члена, который называет &lt;code&gt;U&amp;amp;&lt;/code&gt; ; в противном случае, обеспечивает элемент ЬурейеГо &lt;code&gt;type&lt;/code&gt; , что имена &lt;code&gt;T&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="533c4f52ff1cea4318aa8c59d1192a5f19648e8c" translate="yes" xml:space="preserve">
          <source>1) If &lt;code&gt;T&lt;/code&gt; is a reference type, provides the member constant &lt;code&gt;value&lt;/code&gt; equal &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">1) Если &lt;code&gt;T&lt;/code&gt; является ссылочным типом, &lt;code&gt;value&lt;/code&gt; константы члена равно &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="46015a38f56b223eca9255c907b1367791f0fb7e" translate="yes" xml:space="preserve">
          <source>1) If &lt;code&gt;T&lt;/code&gt; is an object or reference type and the variable definition &lt;code&gt;T obj(&lt;a href=&quot;../utility/declval&quot;&gt;std::declval&lt;/a&gt;&amp;lt;Args&amp;gt;()...);&lt;/code&gt; is well-formed, provides the member constant &lt;code&gt;value&lt;/code&gt; equal to &lt;code&gt;true&lt;/code&gt;. In all other cases, &lt;code&gt;value&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">1) Если &lt;code&gt;T&lt;/code&gt; - объект или ссылочный тип и определение переменной &lt;code&gt;T obj(&lt;a href=&quot;../utility/declval&quot;&gt;std::declval&lt;/a&gt;&amp;lt;Args&amp;gt;()...);&lt;/code&gt; является правильно сформированным, обеспечивает постоянное &lt;code&gt;value&lt;/code&gt; члена, равное &lt;code&gt;true&lt;/code&gt; . Во всех остальных случаях &lt;code&gt;value&lt;/code&gt; является &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a3b72851ab3519141cf487432144a3f31b79335b" translate="yes" xml:space="preserve">
          <source>1) If &lt;code&gt;T&lt;/code&gt; is an object type or a function type that has no cv- or ref- qualifier, provides a member typedef &lt;code&gt;type&lt;/code&gt; which is &lt;code&gt;T&amp;amp;&lt;/code&gt;. If &lt;code&gt;T&lt;/code&gt; is an rvalue reference to some type &lt;code&gt;U&lt;/code&gt;, then &lt;code&gt;type&lt;/code&gt; is &lt;code&gt;U&amp;amp;&lt;/code&gt;. Otherwise, &lt;code&gt;type&lt;/code&gt; is &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">1) Если &lt;code&gt;T&lt;/code&gt; является типом объекта или типом функции, который не имеет cv- или ref-определителя, предоставляет &lt;code&gt;type&lt;/code&gt; typedef члена, который является &lt;code&gt;T&amp;amp;&lt;/code&gt; . Если &lt;code&gt;T&lt;/code&gt; является rvalue ссылкой на некоторый тип &lt;code&gt;U&lt;/code&gt; , тогда &lt;code&gt;type&lt;/code&gt; - &lt;code&gt;U&amp;amp;&lt;/code&gt; . В противном случае &lt;code&gt;type&lt;/code&gt; является &lt;code&gt;T&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="84341e9136029ad471cfa5b9061bb952f1306ba2" translate="yes" xml:space="preserve">
          <source>1) If &lt;code&gt;T&lt;/code&gt; is not a referenceable type (i.e., possibly cv-qualified &lt;code&gt;void&lt;/code&gt; or a function type with a</source>
          <target state="translated">1) Если &lt;code&gt;T&lt;/code&gt; не является ссылочным типом (т. Е. Возможно cv-квалифицированным &lt;code&gt;void&lt;/code&gt; или типом функции с</target>
        </trans-unit>
        <trans-unit id="55b2f140ddb9e139d3eddb758d445d70f330d38a" translate="yes" xml:space="preserve">
          <source>1) If &lt;code&gt;bool(lhs) != bool(rhs)&lt;/code&gt;, returns &lt;code&gt;false&lt;/code&gt;</source>
          <target state="translated">1) Если &lt;code&gt;bool(lhs) != bool(rhs)&lt;/code&gt; , возвращает &lt;code&gt;false&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0a4d89d7c12b3e0fdc5475924278afccc9fcb9a0" translate="yes" xml:space="preserve">
          <source>1) If &lt;code&gt;c==EOF&lt;/code&gt;, does nothing</source>
          <target state="translated">1) Если &lt;code&gt;c==EOF&lt;/code&gt; , ничего не делает</target>
        </trans-unit>
        <trans-unit id="48cff9cec5eee4d48df8a56a52bf392dc360ed81" translate="yes" xml:space="preserve">
          <source>1) If &lt;code&gt;e&lt;/code&gt; is a function call expression, and</source>
          <target state="translated">1) Если &lt;code&gt;e&lt;/code&gt; является выражением вызова функции, и</target>
        </trans-unit>
        <trans-unit id="8cb38dc250b911397e4c0873f26f0012d9d8ab6e" translate="yes" xml:space="preserve">
          <source>1) If &lt;code&gt;ok()&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, returns a &lt;code&gt;sys_days&lt;/code&gt; that represents the last &lt;code&gt;weekday()&lt;/code&gt; of the &lt;code&gt;year()&lt;/code&gt; and &lt;code&gt;month()&lt;/code&gt;. Otherwise, the returned value is unspecified.</source>
          <target state="translated">1) Если &lt;code&gt;ok()&lt;/code&gt; это &lt;code&gt;true&lt;/code&gt; , то возвращается &lt;code&gt;sys_days&lt;/code&gt; , что представляет последний &lt;code&gt;weekday()&lt;/code&gt; в &lt;code&gt;year()&lt;/code&gt; и &lt;code&gt;month()&lt;/code&gt; . В противном случае возвращаемое значение не указано.</target>
        </trans-unit>
        <trans-unit id="ae1ac36ae20a2ced74aaccf2496e723144a48341" translate="yes" xml:space="preserve">
          <source>1) If &lt;code&gt;ok()&lt;/code&gt; is true, the return value holds a count of days from the &lt;code&gt;&lt;a href=&quot;../system_clock&quot;&gt;std::chrono::system_clock&lt;/a&gt;&lt;/code&gt; epoch (1970-01-01) to &lt;code&gt;*this&lt;/code&gt;. The result is negative if &lt;code&gt;*this&lt;/code&gt; represent a date prior to it.</source>
          <target state="translated">1) Если &lt;code&gt;ok()&lt;/code&gt; истинно, возвращаемое значение содержит количество дней от эпохи &lt;code&gt;&lt;a href=&quot;../system_clock&quot;&gt;std::chrono::system_clock&lt;/a&gt;&lt;/code&gt; (1970-01-01) до &lt;code&gt;*this&lt;/code&gt; . Результат отрицательный, если &lt;code&gt;*this&lt;/code&gt; соответствует дате до него.</target>
        </trans-unit>
        <trans-unit id="775e0551aa7721ab9c56d7c9c8e95ac883de5834" translate="yes" xml:space="preserve">
          <source>1) If &lt;code&gt;p.is_absolute() || (p.has_root_name() &amp;amp;&amp;amp; p.root_name() != root_name())&lt;/code&gt;, then replaces the current path with p as if by &lt;code&gt;operator=(p)&lt;/code&gt; and finishes.</source>
          <target state="translated">1) Если &lt;code&gt;p.is_absolute() || (p.has_root_name() &amp;amp;&amp;amp; p.root_name() != root_name())&lt;/code&gt; , затем заменяет текущий путь на p, как если бы &lt;code&gt;operator=(p)&lt;/code&gt; и завершается.</target>
        </trans-unit>
        <trans-unit id="5df1170b75f3b245eb679518c7086990da875b8a" translate="yes" xml:space="preserve">
          <source>1) If &lt;code&gt;pos == size()&lt;/code&gt;, the behavior is undefined. 2) If &lt;code&gt;pos == size()&lt;/code&gt;, a reference to the character with value &lt;code&gt;CharT()&lt;/code&gt; (the null character) is returned.</source>
          <target state="translated">1) Если &lt;code&gt;pos == size()&lt;/code&gt; , поведение не определено. 2) Если &lt;code&gt;pos == size()&lt;/code&gt; , возвращается ссылка на символ со значением &lt;code&gt;CharT()&lt;/code&gt; (нулевой символ).</target>
        </trans-unit>
        <trans-unit id="23b154b4ece6fb3ebf14c379625abd81a94b12f9" translate="yes" xml:space="preserve">
          <source>1) If &lt;code&gt;root_name().native().compare(p.root_name().native())&lt;/code&gt; is nonzero, returns that value.</source>
          <target state="translated">1) Если &lt;code&gt;root_name().native().compare(p.root_name().native())&lt;/code&gt; равен нулю, возвращает это значение.</target>
        </trans-unit>
        <trans-unit id="8adfe00a74db942dc8cc130967e0f6e088361d3c" translate="yes" xml:space="preserve">
          <source>1) If &lt;code&gt;sizeof...(MutexTypes) == 0&lt;/code&gt;, does nothing. Otherwise, If &lt;code&gt;sizeof...(MutexTypes) == 1&lt;/code&gt;, effectively calls &lt;code&gt;m.lock()&lt;/code&gt;. Otherwise, effectively calls &lt;code&gt;&lt;a href=&quot;../lock&quot;&gt;std::lock&lt;/a&gt;(m...)&lt;/code&gt;. The behavior is undefined if one of &lt;code&gt;MutexTypes&lt;/code&gt; is not a recursive mutex and the current thread already owns the corresponding argument in &lt;code&gt;m...&lt;/code&gt;.</source>
          <target state="translated">1) Если &lt;code&gt;sizeof...(MutexTypes) == 0&lt;/code&gt; , ничего не делает. В противном случае, если &lt;code&gt;sizeof...(MutexTypes) == 1&lt;/code&gt; , эффективно вызывает &lt;code&gt;m.lock()&lt;/code&gt; . В противном случае эффективно вызывает &lt;code&gt;&lt;a href=&quot;../lock&quot;&gt;std::lock&lt;/a&gt;(m...)&lt;/code&gt; . Поведение не определено , если один из &lt;code&gt;MutexTypes&lt;/code&gt; не рекурсивный мьютекс и текущий поток уже владеет соответствующий аргумент в &lt;code&gt;m...&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5ce02c5f4f1088b1082aa38dc45c7ca3365e6a7f" translate="yes" xml:space="preserve">
          <source>1) If &lt;code&gt;v&lt;/code&gt; compares less than &lt;code&gt;lo&lt;/code&gt;, returns &lt;code&gt;lo&lt;/code&gt;; otherwise if &lt;code&gt;hi&lt;/code&gt; compares less than &lt;code&gt;v&lt;/code&gt;, returns &lt;code&gt;hi&lt;/code&gt;; otherwise returns &lt;code&gt;v&lt;/code&gt;. Uses &lt;code&gt;operator&amp;lt;&lt;/code&gt; to compare the values.</source>
          <target state="translated">1) Если &lt;code&gt;v&lt;/code&gt; сравнивает меньше, чем &lt;code&gt;lo&lt;/code&gt; , возвращает &lt;code&gt;lo&lt;/code&gt; ; в противном случае, если &lt;code&gt;hi&lt;/code&gt; сравнивает меньше чем &lt;code&gt;v&lt;/code&gt; , возвращает &lt;code&gt;hi&lt;/code&gt; ; в противном случае возвращает &lt;code&gt;v&lt;/code&gt; . Использует &lt;code&gt;operator&amp;lt;&lt;/code&gt; для сравнения значений.</target>
        </trans-unit>
        <trans-unit id="4d06e0518b8e9559ed2e398da1df96960c59c244" translate="yes" xml:space="preserve">
          <source>1) If &lt;code&gt;year().ok() &amp;amp;&amp;amp; month().ok() &amp;amp;&amp;amp; weekday().ok()&lt;/code&gt;:</source>
          <target state="translated">1) Если &lt;code&gt;year().ok() &amp;amp;&amp;amp; month().ok() &amp;amp;&amp;amp; weekday().ok()&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="953c7b17bedfe4cec3a6964917bcb6dd438c090c" translate="yes" xml:space="preserve">
          <source>1) If a key equivalent to &lt;code&gt;k&lt;/code&gt; already exists in the container, does nothing. Otherwise, behaves like &lt;a href=&quot;emplace&quot;&gt;emplace&lt;/a&gt; except that the element is constructed as &lt;code&gt;value_type(std::piecewise_construct, std::forward_as_tuple(k), std::forward_as_tuple(std::forward&amp;lt;Args&amp;gt;(args)...))&lt;/code&gt;</source>
          <target state="translated">1) Если ключ, эквивалентный &lt;code&gt;k&lt;/code&gt; , уже существует в контейнере, ничего не делает. В противном случае ведет себя как &lt;a href=&quot;emplace&quot;&gt;emplace,&lt;/a&gt; за исключением того, что элемент &lt;code&gt;value_type(std::piecewise_construct, std::forward_as_tuple(k), std::forward_as_tuple(std::forward&amp;lt;Args&amp;gt;(args)...))&lt;/code&gt; как value_type (std :: piecewise_construct, std :: forward_as_tuple (k), std :: forward_as_tuple (std :: forward &amp;lt;Args&amp;gt; (args) ...))</target>
        </trans-unit>
        <trans-unit id="27c9cac424cf306f64712cae4c73131e4ecf8efa" translate="yes" xml:space="preserve">
          <source>1) If an exception is thrown, &lt;code&gt;&lt;a href=&quot;../utility/program/abort&quot;&gt;std::abort&lt;/a&gt;&lt;/code&gt; is called</source>
          <target state="translated">1) Если исключение, &lt;code&gt;&lt;a href=&quot;../utility/program/abort&quot;&gt;std::abort&lt;/a&gt;&lt;/code&gt; называется</target>
        </trans-unit>
        <trans-unit id="053707ffbcc5a261ff2e9f6e03a44ce4aa6bea54" translate="yes" xml:space="preserve">
          <source>1) If an imaginary struct containing a member object of type &lt;code&gt;T&lt;/code&gt; has a non-deleted destructor, provides the member constant &lt;code&gt;value&lt;/code&gt; equal &lt;code&gt;true&lt;/code&gt;. For any other type, &lt;code&gt;value&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">1) Если воображаемая структура, содержащая объект-член типа &lt;code&gt;T&lt;/code&gt; , имеет неразрушенный деструктор, &lt;code&gt;value&lt;/code&gt; константы-члена будет равно &lt;code&gt;true&lt;/code&gt; . Для любого другого типа &lt;code&gt;value&lt;/code&gt; равно &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d6c0a2e0ad065651ccf574c46ce2ec1d6a32e799" translate="yes" xml:space="preserve">
          <source>1) If both operands are null pointer constants, the composite pointer type is &lt;code&gt;&lt;a href=&quot;../types/nullptr_t&quot;&gt;std::nullptr_t&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">1) Если оба операнда являются константами нулевого указателя, тип составного указателя является &lt;code&gt;&lt;a href=&quot;../types/nullptr_t&quot;&gt;std::nullptr_t&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="001a94641182b36fb39ecd7c6f316dc79e18bf05" translate="yes" xml:space="preserve">
          <source>1) If both pointers to member are null member pointer values, they</source>
          <target state="translated">1)Если оба указателя на член являются нулевыми значениями указателя,то они</target>
        </trans-unit>
        <trans-unit id="d696aa7c360446c7c92bbb49a9fa4b905e4ea6af" translate="yes" xml:space="preserve">
          <source>1) If either &lt;code&gt;E2&lt;/code&gt; or &lt;code&gt;E3&lt;/code&gt; has type &lt;code&gt;void&lt;/code&gt;, then one of the following must be true, or the program is ill-formed:</source>
          <target state="translated">1) Если тип &lt;code&gt;E2&lt;/code&gt; или &lt;code&gt;E3&lt;/code&gt; имеет тип &lt;code&gt;void&lt;/code&gt; , то должно быть выполнено одно из следующих действий, иначе программа имеет неверный формат:</target>
        </trans-unit>
        <trans-unit id="619b57caddc542baf25a7d1c5e7745307a747df0" translate="yes" xml:space="preserve">
          <source>1) If only one specialization matches the template arguments, that specialization is used</source>
          <target state="translated">1)Если только одна специализация совпадает с аргументами шаблона,то используется эта специализация</target>
        </trans-unit>
        <trans-unit id="4ae7d33e86f2455f29507118c461d795dd425ce1" translate="yes" xml:space="preserve">
          <source>1) If permitted, &lt;a href=&quot;constant_initialization&quot;&gt;Constant initialization&lt;/a&gt; takes place first (see &lt;a href=&quot;constant_initialization&quot;&gt;Constant initialization&lt;/a&gt; for the list of those situations). In practice, constant initialization is usually performed at compile time, and pre-calculated object representations are stored as part of the program image. If the compiler doesn't do that, it still has to guarantee that this initialization happens before any dynamic initialization.</source>
          <target state="translated">1) Если разрешено, &lt;a href=&quot;constant_initialization&quot;&gt;инициализация константы&lt;/a&gt; происходит в первую очередь ( список этих ситуаций см. В разделе &lt;a href=&quot;constant_initialization&quot;&gt;Инициализация константы&lt;/a&gt; ). На практике постоянная инициализация обычно выполняется во время компиляции, а предварительно рассчитанные представления объектов сохраняются как часть образа программы. Если компилятор этого не делает, он все равно должен гарантировать, что эта инициализация произойдет до любой динамической инициализации.</target>
        </trans-unit>
        <trans-unit id="ec76cf635ed5977262cf9ddcc3fb5fe13eaaff7b" translate="yes" xml:space="preserve">
          <source>1) If set to &lt;code&gt;ON&lt;/code&gt;, informs the compiler that the program will access or modify &lt;a href=&quot;../numeric/fenv&quot;&gt;floating-point environment&lt;/a&gt;, which means that optimizations that could subvert flag tests and mode changes (e.g., global common subexpression elimination, code motion, and constant folding) are prohibited. The default value is implementation-defined, usually &lt;code&gt;OFF&lt;/code&gt;.</source>
          <target state="translated">1) Если установлено значение &lt;code&gt;ON&lt;/code&gt; , информирует компилятор о том, что программа получит доступ или изменит &lt;a href=&quot;../numeric/fenv&quot;&gt;среду с плавающей запятой&lt;/a&gt; , что означает, что оптимизации, которые могут подорвать тесты флагов и изменения режима (например, устранение глобальных общих подвыражений, перемещение кода и постоянное свертывание) запрещено. Значение по умолчанию определяется реализацией, обычно &lt;code&gt;OFF&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f906d81a6d06437984e964c4636da5851fdcf58f" translate="yes" xml:space="preserve">
          <source>1) If the argument is an unparenthesized &lt;a href=&quot;name&quot;&gt;id-expression&lt;/a&gt; naming a &lt;a href=&quot;structured_binding&quot;&gt;structured binding&lt;/a&gt;, then decltype yields the</source>
          <target state="translated">1) Если аргумент представляет собой не заключенное в скобки &lt;a href=&quot;name&quot;&gt;id-выражение с&lt;/a&gt; именем &lt;a href=&quot;structured_binding&quot;&gt;структурированной привязки&lt;/a&gt; , тогда decltype возвращает</target>
        </trans-unit>
        <trans-unit id="826d68e87870ec49b6a7fffcc26f9ce675d5f52a" translate="yes" xml:space="preserve">
          <source>1) If the constructor is for the most-derived class, virtual base classes are initialized in the order in which they appear in depth-first left-to-right traversal of the base class declarations (left-to-right refers to the appearance in base-specifier lists)</source>
          <target state="translated">1)Если конструктор предназначен для наиболее выдающегося класса,то виртуальные базовые классы инициализируются в том порядке,в котором они появляются в первом по глубине обходе деклараций базового класса влево-право (лево-право относится к появлению в списках базовых спецификаторов)</target>
        </trans-unit>
        <trans-unit id="64bc0d09554e2852fae96f29e67b670b931676e8" translate="yes" xml:space="preserve">
          <source>1) If the current output format is 24-hour, converts to 12-hour time. Otherwise no effects.</source>
          <target state="translated">1)Если текущий выходной формат 24-часовой,преобразуется в 12-часовой.В противном случае никаких эффектов.</target>
        </trans-unit>
        <trans-unit id="0f38fe0a520fad6c56ed541e8d99a4cb99844d3f" translate="yes" xml:space="preserve">
          <source>1) If the declaration of &lt;code&gt;f&lt;/code&gt;, &lt;code&gt;pf&lt;/code&gt;, or &lt;code&gt;pmf&lt;/code&gt; uses &lt;code&gt;throw()&lt;/code&gt;(deprecated) or &lt;a href=&quot;noexcept&quot;&gt;noexcept&lt;/a&gt;, the set is empty. 2) Otherwise, if the declaration of &lt;code&gt;f&lt;/code&gt;, &lt;code&gt;pf&lt;/code&gt;, or &lt;code&gt;pmf&lt;/code&gt; uses a dynamic exception specification(deprecated), the set consists of the types listed in that specification 3) Otherwise, the set is the set of all types</source>
          <target state="translated">1) Если в объявлении &lt;code&gt;f&lt;/code&gt; , &lt;code&gt;pf&lt;/code&gt; или &lt;code&gt;pmf&lt;/code&gt; используется метод &lt;code&gt;throw()&lt;/code&gt; (устарел) или &lt;a href=&quot;noexcept&quot;&gt;noexcept&lt;/a&gt; , набор пуст. 2) В противном случае, если в объявлении &lt;code&gt;f&lt;/code&gt; , &lt;code&gt;pf&lt;/code&gt; или &lt;code&gt;pmf&lt;/code&gt; используется спецификация динамического исключения (не рекомендуется), набор состоит из типов, перечисленных в этой спецификации. 3) В противном случае набор представляет собой набор всех типов.</target>
        </trans-unit>
        <trans-unit id="f9ccd33ddb11cbe7fee8dbccd1e293df7c5318d1" translate="yes" xml:space="preserve">
          <source>1) If the expression &lt;code&gt;&lt;a href=&quot;../utility/declval&quot;&gt;std::declval&lt;/a&gt;&amp;lt;T&amp;gt;() = &lt;a href=&quot;../utility/declval&quot;&gt;std::declval&lt;/a&gt;&amp;lt;U&amp;gt;()&lt;/code&gt; is well-formed in unevaluated context, provides the member constant &lt;code&gt;value&lt;/code&gt; equal &lt;code&gt;true&lt;/code&gt;. Otherwise, &lt;code&gt;value&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;. &lt;a href=&quot;../language/access&quot;&gt;Access checks&lt;/a&gt; are performed as if from a context unrelated to either type.</source>
          <target state="translated">1) Если выражение &lt;code&gt;&lt;a href=&quot;../utility/declval&quot;&gt;std::declval&lt;/a&gt;&amp;lt;T&amp;gt;() = &lt;a href=&quot;../utility/declval&quot;&gt;std::declval&lt;/a&gt;&amp;lt;U&amp;gt;()&lt;/code&gt; правильно сформировано в неоцененном контексте, &lt;code&gt;value&lt;/code&gt; константы члена равно &lt;code&gt;true&lt;/code&gt; . В противном случае &lt;code&gt;value&lt;/code&gt; является &lt;code&gt;false&lt;/code&gt; . &lt;a href=&quot;../language/access&quot;&gt;Проверки доступа&lt;/a&gt; выполняются как будто из контекста, не связанного ни с одним из типов.</target>
        </trans-unit>
        <trans-unit id="3daeab1387736a2e7813fdad3d2e852a5f18e577" translate="yes" xml:space="preserve">
          <source>1) If the expressions &lt;code&gt;swap(&lt;a href=&quot;../utility/declval&quot;&gt;std::declval&lt;/a&gt;&amp;lt;T&amp;gt;(), &lt;a href=&quot;../utility/declval&quot;&gt;std::declval&lt;/a&gt;&amp;lt;U&amp;gt;())&lt;/code&gt; and &lt;code&gt;swap(&lt;a href=&quot;../utility/declval&quot;&gt;std::declval&lt;/a&gt;&amp;lt;U&amp;gt;(), &lt;a href=&quot;../utility/declval&quot;&gt;std::declval&lt;/a&gt;&amp;lt;T&amp;gt;())&lt;/code&gt; are both well-formed in unevaluated context after &lt;code&gt;using &lt;a href=&quot;../algorithm/swap&quot;&gt;std::swap&lt;/a&gt;;&lt;/code&gt; (see &lt;a href=&quot;../named_req/swappable&quot;&gt;Swappable&lt;/a&gt;), provides the member constant &lt;code&gt;value&lt;/code&gt; equal &lt;code&gt;true&lt;/code&gt;. Otherwise, &lt;code&gt;value&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;. &lt;a href=&quot;../language/access&quot;&gt;Access checks&lt;/a&gt; are performed as if from a context unrelated to either type.</source>
          <target state="translated">1) Если выражения &lt;code&gt;swap(&lt;a href=&quot;../utility/declval&quot;&gt;std::declval&lt;/a&gt;&amp;lt;T&amp;gt;(), &lt;a href=&quot;../utility/declval&quot;&gt;std::declval&lt;/a&gt;&amp;lt;U&amp;gt;())&lt;/code&gt; и &lt;code&gt;swap(&lt;a href=&quot;../utility/declval&quot;&gt;std::declval&lt;/a&gt;&amp;lt;U&amp;gt;(), &lt;a href=&quot;../utility/declval&quot;&gt;std::declval&lt;/a&gt;&amp;lt;T&amp;gt;())&lt;/code&gt; оба правильно сформированы в неоцененном контексте после &lt;code&gt;using &lt;a href=&quot;../algorithm/swap&quot;&gt;std::swap&lt;/a&gt;;&lt;/code&gt; (см. &lt;a href=&quot;../named_req/swappable&quot;&gt;Swappable&lt;/a&gt; ), &lt;code&gt;value&lt;/code&gt; константы члена равно &lt;code&gt;true&lt;/code&gt; . В противном случае &lt;code&gt;value&lt;/code&gt; является &lt;code&gt;false&lt;/code&gt; . &lt;a href=&quot;../language/access&quot;&gt;Проверки доступа&lt;/a&gt; выполняются как будто из контекста, не связанного ни с одним из типов.</target>
        </trans-unit>
        <trans-unit id="45059787b4fa742a740d89cbe94d8b03372e1106" translate="yes" xml:space="preserve">
          <source>1) If the imaginary function definition &lt;code&gt;To test() { return &lt;a href=&quot;../utility/declval&quot;&gt;std::declval&lt;/a&gt;&amp;lt;From&amp;gt;(); }&lt;/code&gt; is well-formed, (that is, either &lt;code&gt;&lt;a href=&quot;../utility/declval&quot;&gt;std::declval&lt;/a&gt;&amp;lt;From&amp;gt;()&lt;/code&gt; can be converted to &lt;code&gt;To&lt;/code&gt; using &lt;a href=&quot;../language/implicit_cast&quot;&gt;implicit conversions&lt;/a&gt;, or both &lt;code&gt;From&lt;/code&gt; and &lt;code&gt;To&lt;/code&gt; are possibly cv-qualified &lt;code&gt;void&lt;/code&gt;), provides the member constant &lt;code&gt;value&lt;/code&gt; equal to &lt;code&gt;true&lt;/code&gt;. Otherwise &lt;code&gt;value&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;. For the purposes of this check, the use of &lt;code&gt;&lt;a href=&quot;../utility/declval&quot;&gt;std::declval&lt;/a&gt;&lt;/code&gt; in the return statement is not considered an &lt;a href=&quot;../language/definition#ODR-use&quot;&gt;odr-use&lt;/a&gt;.</source>
          <target state="translated">1) Если определение мнимой функции &lt;code&gt;To test() { return &lt;a href=&quot;../utility/declval&quot;&gt;std::declval&lt;/a&gt;&amp;lt;From&amp;gt;(); }&lt;/code&gt; правильно сформирован (то есть, либо &lt;code&gt;&lt;a href=&quot;../utility/declval&quot;&gt;std::declval&lt;/a&gt;&amp;lt;From&amp;gt;()&lt;/code&gt; может быть преобразован в &lt;code&gt;To&lt;/code&gt; с использованием &lt;a href=&quot;../language/implicit_cast&quot;&gt;неявных преобразований&lt;/a&gt; , либо оба &lt;code&gt;From&lt;/code&gt; и &lt;code&gt;To&lt;/code&gt; , возможно, cv-квалифицированные &lt;code&gt;void&lt;/code&gt; ), предоставляют &lt;code&gt;value&lt;/code&gt; константы члена, равное &lt;code&gt;true&lt;/code&gt; , В противном случае &lt;code&gt;value&lt;/code&gt; является &lt;code&gt;false&lt;/code&gt; . Для целей этой проверки использование &lt;code&gt;&lt;a href=&quot;../utility/declval&quot;&gt;std::declval&lt;/a&gt;&lt;/code&gt; в операторе return не считается &lt;a href=&quot;../language/definition#ODR-use&quot;&gt;odr-использованием&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6f0b8672e5f29b8486f7709d207643d87be596d9" translate="yes" xml:space="preserve">
          <source>1) If the input sequence has a read position available (&lt;code&gt;egptr() &amp;gt; gptr()&lt;/code&gt;), returns &lt;code&gt;Traits::to_int_type(*gptr())&lt;/code&gt;</source>
          <target state="translated">1) Если входная последовательность имеет доступную позицию чтения ( &lt;code&gt;egptr() &amp;gt; gptr()&lt;/code&gt; ), возвращает &lt;code&gt;Traits::to_int_type(*gptr())&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1c32163286e69234ea02701a99ebdecfd40c8e43" translate="yes" xml:space="preserve">
          <source>1) If the next pointer is null, the operation fails</source>
          <target state="translated">1)Если следующий указатель окажется нулевым,операция завершится неудачно.</target>
        </trans-unit>
        <trans-unit id="91c47dc3e02728253e0cce0bb00f6bc9a4d38d28" translate="yes" xml:space="preserve">
          <source>1) If the operand is an lvalue expression of some object or function type &lt;code&gt;T&lt;/code&gt;, &lt;code&gt;operator&amp;amp;&lt;/code&gt; creates and returns a prvalue of type &lt;code&gt;T*&lt;/code&gt;, with the same cv qualification, that is pointing to the object or function designated by the operand. If the operand has incomplete type, the pointer can be formed, but if that incomplete type happens to be a class that defines its own &lt;code&gt;operator&amp;amp;&lt;/code&gt;, the behavior is undefined(until C++14)it is unspecified whether the built-in or the overload is used(since C++14). For the operands of type with user-defined &lt;code&gt;operator&amp;amp;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../memory/addressof&quot;&gt;std::addressof&lt;/a&gt;&lt;/code&gt; may be used to obtain the true pointer.</source>
          <target state="translated">1) Если операнд является выражением lvalue какого-либо объекта или типа функции &lt;code&gt;T&lt;/code&gt; , &lt;code&gt;operator&amp;amp;&lt;/code&gt; создает и возвращает значение типа &lt;code&gt;T*&lt;/code&gt; с той же квалификацией cv, которое указывает на объект или функцию, обозначенную операндом. Если операнд имеет неполный тип, указатель может быть сформирован, но если этот неполный тип окажется классом, который определяет свой собственный &lt;code&gt;operator&amp;amp;&lt;/code&gt; , поведение не определено (до C ++ 14), то не определено, является ли встроенный или используется перегрузка (начиная с C ++ 14). Для операндов типа с пользовательским &lt;code&gt;operator&amp;amp;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../memory/addressof&quot;&gt;std::addressof&lt;/a&gt;&lt;/code&gt; может использоваться для получения истинного указателя.</target>
        </trans-unit>
        <trans-unit id="a1256320cbee9651ed515f01789527567a38d98e" translate="yes" xml:space="preserve">
          <source>1) If the path is empty, stop (normal form of an empty path is an empty path)</source>
          <target state="translated">1)Если путь пустой,остановитесь (обычная форма пустого пути-это пустой путь).</target>
        </trans-unit>
        <trans-unit id="582111318ab00f1208e85c21c22bca92315c07e6" translate="yes" xml:space="preserve">
          <source>1) If the pointer to be repositioned is a null pointer and the new offset &lt;code&gt;newoff&lt;/code&gt; would be non-zero, this function fails.</source>
          <target state="translated">1) Если указатель, который нужно переместить, является нулевым указателем, а новое смещение &lt;code&gt;newoff&lt;/code&gt; будет ненулевым, эта функция завершится ошибкой.</target>
        </trans-unit>
        <trans-unit id="fe93a7c23cff4516602f15cbb778ed98afe55fb4" translate="yes" xml:space="preserve">
          <source>1) If the pointers are both null pointer values, they</source>
          <target state="translated">1)Если оба указателя являются нулевыми значениями,то они</target>
        </trans-unit>
        <trans-unit id="fc198593bd9ec378434428d9afd2c41063e2a0a5" translate="yes" xml:space="preserve">
          <source>1) If the type of expression is exactly new_type or a less cv-qualified version of new_type, the result is the value of expression, with type new_type. (In other words, &lt;code&gt;dynamic_cast&lt;/code&gt; can be used to add constness. An implicit conversion and &lt;code&gt;static_cast&lt;/code&gt; can perform this conversion as well.)</source>
          <target state="translated">1) Если тип выражения является точно новым_типом или менее квалифицированной cv версией нового_типа, результатом является значение выражения с типом new_type. (Другими словами, &lt;code&gt;dynamic_cast&lt;/code&gt; может использоваться для добавления константности. Неявное преобразование и &lt;code&gt;static_cast&lt;/code&gt; также могут выполнять это преобразование.)</target>
        </trans-unit>
        <trans-unit id="81e1b3a4903489b6c6f5290600d72bbbee763b8f" translate="yes" xml:space="preserve">
          <source>1) If the underlying &lt;code&gt;&lt;a href=&quot;../shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt; stores the same &lt;code&gt;T*&lt;/code&gt; as &lt;code&gt;expected&lt;/code&gt; and shares ownership with it, or if both underlying and &lt;code&gt;expected&lt;/code&gt; are empty, assigns from &lt;code&gt;desired&lt;/code&gt; to the underlying &lt;code&gt;&lt;a href=&quot;../shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt;, returns &lt;code&gt;true&lt;/code&gt;, and orders memory according to &lt;code&gt;success&lt;/code&gt;, otherwise assigns from the underlying &lt;code&gt;&lt;a href=&quot;../shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt; to &lt;code&gt;expected&lt;/code&gt;, returns &lt;code&gt;false&lt;/code&gt;, and orders memory according to &lt;code&gt;failure&lt;/code&gt;. The behavior is undefined if &lt;code&gt;failure&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;../../atomic/memory_order&quot;&gt;std::memory_order_release&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../../atomic/memory_order&quot;&gt;std::memory_order_acq_rel&lt;/a&gt;&lt;/code&gt;. On success, the operation is an atomic read-modify-write operation on &lt;code&gt;*this&lt;/code&gt; and &lt;code&gt;expected&lt;/code&gt; is not accessed after the atomic update. On failure, the operation is an atomic load operation on &lt;code&gt;*this&lt;/code&gt; and &lt;code&gt;expected&lt;/code&gt; is updated with the existing value read from the atomic object. This update to &lt;code&gt;expected&lt;/code&gt;'s use_count is part of this atomic operation, although the write itself (and any subsequent deallocation/destruction) is not required to be.</source>
          <target state="translated">1) Если основной &lt;code&gt;&lt;a href=&quot;../shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt; сохраняет тот же &lt;code&gt;T*&lt;/code&gt; , как &lt;code&gt;expected&lt;/code&gt; , и владение акций с ним, или если оба лежащими в основе и &lt;code&gt;expected&lt;/code&gt; , пустые, правопреемники от &lt;code&gt;desired&lt;/code&gt; к основному &lt;code&gt;&lt;a href=&quot;../shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt; , возвращает &lt;code&gt;true&lt;/code&gt; , и заказы память в соответствии с &lt;code&gt;success&lt;/code&gt; , в противном случае назначает от лежащей в основе &lt;code&gt;&lt;a href=&quot;../shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt; к &lt;code&gt;expected&lt;/code&gt; , возвращает &lt;code&gt;false&lt;/code&gt; , а заказы памяти в соответствии с &lt;code&gt;failure&lt;/code&gt; . Поведение не определено, если &lt;code&gt;failure&lt;/code&gt; равен &lt;code&gt;&lt;a href=&quot;../../atomic/memory_order&quot;&gt;std::memory_order_release&lt;/a&gt;&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;../../atomic/memory_order&quot;&gt;std::memory_order_acq_rel&lt;/a&gt;&lt;/code&gt; . В случае успеха операция является атомарной операцией чтения-изменения-записи &lt;code&gt;*this&lt;/code&gt; и &lt;code&gt;expected&lt;/code&gt; что после атомарного обновления к ней нет доступа. В случае сбоя операция представляет собой операцию атомарной загрузки &lt;code&gt;*this&lt;/code&gt; и &lt;code&gt;expected&lt;/code&gt; она обновляется с использованием существующего значения, считанного из атомарного объекта. Это обновление &lt;code&gt;expected&lt;/code&gt; use_count является частью этой атомарной операции, хотя сама запись (и любое последующее освобождение / уничтожение) не обязательна.</target>
        </trans-unit>
        <trans-unit id="debd587f8b5b3f706f78c4d8eb91989d3f630fe5" translate="yes" xml:space="preserve">
          <source>1) If the underlying &lt;code&gt;&lt;a href=&quot;../weak_ptr&quot;&gt;std::weak_ptr&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt; stores the same pointer value as &lt;code&gt;expected&lt;/code&gt; and shares ownership with it, or if both underlying and &lt;code&gt;expected&lt;/code&gt; are empty, assigns from &lt;code&gt;desired&lt;/code&gt; to the underlying &lt;code&gt;&lt;a href=&quot;../weak_ptr&quot;&gt;std::weak_ptr&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt;, returns &lt;code&gt;true&lt;/code&gt;, and orders memory according to &lt;code&gt;success&lt;/code&gt;, otherwise assigns from the underlying &lt;code&gt;&lt;a href=&quot;../weak_ptr&quot;&gt;std::weak_ptr&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt; to &lt;code&gt;expected&lt;/code&gt;, returns &lt;code&gt;false&lt;/code&gt;, and orders memory according to &lt;code&gt;failure&lt;/code&gt;. The behavior is undefined if &lt;code&gt;failure&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;../../atomic/memory_order&quot;&gt;std::memory_order_release&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../../atomic/memory_order&quot;&gt;std::memory_order_acq_rel&lt;/a&gt;&lt;/code&gt;. On success, the operation is an atomic read-modify-write operation on &lt;code&gt;*this&lt;/code&gt; and &lt;code&gt;expected&lt;/code&gt; is not accessed after the atomic update. On failure, the operation is an atomic load operation on &lt;code&gt;*this&lt;/code&gt; and &lt;code&gt;expected&lt;/code&gt; is updated with the existing value read from the atomic object. This update to &lt;code&gt;expected&lt;/code&gt;'s use_count is part of this atomic operation, although the write itself (and any subsequent deallocation/destruction) is not required to be.</source>
          <target state="translated">1) Если базовый &lt;code&gt;&lt;a href=&quot;../weak_ptr&quot;&gt;std::weak_ptr&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt; хранит то же значение указателя, &lt;code&gt;expected&lt;/code&gt; и ожидалось, и разделяет владение им, или если оба базовых и &lt;code&gt;expected&lt;/code&gt; являются пустыми, присваивает из &lt;code&gt;desired&lt;/code&gt; базовый &lt;code&gt;&lt;a href=&quot;../weak_ptr&quot;&gt;std::weak_ptr&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt; , возвращает &lt;code&gt;true&lt;/code&gt; , и заказы память в соответствии с &lt;code&gt;success&lt;/code&gt; , в противном случае назначает от лежащей в основе &lt;code&gt;&lt;a href=&quot;../weak_ptr&quot;&gt;std::weak_ptr&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt; к &lt;code&gt;expected&lt;/code&gt; , возвращает &lt;code&gt;false&lt;/code&gt; , а заказы памяти в соответствии с &lt;code&gt;failure&lt;/code&gt; . Поведение не определено, если &lt;code&gt;failure&lt;/code&gt; равен &lt;code&gt;&lt;a href=&quot;../../atomic/memory_order&quot;&gt;std::memory_order_release&lt;/a&gt;&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;../../atomic/memory_order&quot;&gt;std::memory_order_acq_rel&lt;/a&gt;&lt;/code&gt; . В случае успеха операция является атомарной операцией чтения-изменения-записи &lt;code&gt;*this&lt;/code&gt; и &lt;code&gt;expected&lt;/code&gt; что после атомарного обновления к ней нет доступа. В случае сбоя операция представляет собой операцию атомарной загрузки &lt;code&gt;*this&lt;/code&gt; и &lt;code&gt;expected&lt;/code&gt; она обновляется с использованием существующего значения, считанного из атомарного объекта. Это обновление &lt;code&gt;expected&lt;/code&gt; use_count является частью этой атомарной операции, хотя сама запись (и любое последующее освобождение / уничтожение) не обязательна.</target>
        </trans-unit>
        <trans-unit id="e34721beb2d7e5dc88963d3e677eec93a6ef94e9" translate="yes" xml:space="preserve">
          <source>1) If there are &lt;code&gt;M&lt;/code&gt; arguments, the candidate function that has exactly &lt;code&gt;M&lt;/code&gt; parameters is viable</source>
          <target state="translated">1) Если имеется &lt;code&gt;M&lt;/code&gt; аргументов, функция-кандидат, которая имеет ровно &lt;code&gt;M&lt;/code&gt; параметров, является жизнеспособной</target>
        </trans-unit>
        <trans-unit id="ec64a20a9d24c39e596bf41c76e737d99a86058d" translate="yes" xml:space="preserve">
          <source>1) If there is an &lt;a href=&quot;implicit_cast&quot;&gt;implicit conversion sequence&lt;/a&gt; from expression to new_type, or if overload resolution for a &lt;a href=&quot;direct_initialization&quot;&gt;direct initialization&lt;/a&gt; of an object or reference of type new_type from expression would find at least one viable function, then &lt;code&gt;static_cast&amp;lt;new_type&amp;gt;(expression)&lt;/code&gt; returns the imaginary variable &lt;code&gt;Temp&lt;/code&gt; initialized as if by &lt;code&gt;new_type Temp(expression);&lt;/code&gt;, which may involve &lt;a href=&quot;implicit_cast&quot;&gt;implicit conversions&lt;/a&gt;, a call to the &lt;a href=&quot;constructor&quot;&gt;constructor&lt;/a&gt; of new_type or a call to a &lt;a href=&quot;cast_operator&quot;&gt;user-defined conversion operator&lt;/a&gt;. For non-reference new_type, the result object of the static_cast prvalue expression is what's direct-initialized(since C++17)</source>
          <target state="translated">1) Если существует &lt;a href=&quot;implicit_cast&quot;&gt;неявная последовательность преобразования&lt;/a&gt; из выражения в new_type или если при разрешении перегрузки для &lt;a href=&quot;direct_initialization&quot;&gt;прямой инициализации&lt;/a&gt; объекта или ссылки типа new_type из выражения будет найдена хотя бы одна жизнеспособная функция, то &lt;code&gt;static_cast&amp;lt;new_type&amp;gt;(expression)&lt;/code&gt; возвращает мнимая переменная &lt;code&gt;Temp&lt;/code&gt; инициализируется как бы &lt;code&gt;new_type Temp(expression);&lt;/code&gt; , который может включать &lt;a href=&quot;implicit_cast&quot;&gt;неявные преобразования&lt;/a&gt; , вызов &lt;a href=&quot;constructor&quot;&gt;конструктора&lt;/a&gt; new_type или вызов &lt;a href=&quot;cast_operator&quot;&gt;пользовательского оператора преобразования&lt;/a&gt; . Для нереферентного new_type объект результата выражения static_cast prvalue является тем, что инициализируется напрямую (начиная с C ++ 17)</target>
        </trans-unit>
        <trans-unit id="5e61488d7d7b15353ad536c26150cc3f3d9dfc2a" translate="yes" xml:space="preserve">
          <source>1) If two pointers point to different elements of the same array, or to subobjects within different elements of the same array, the pointer to the element with the higher subscript</source>
          <target state="translated">1)Если два указателя указывают на разные элементы одного и того же массива,или на подсубъекты внутри разных элементов одного и того же массива,то указатель на элемент с более высоким подскриптом</target>
        </trans-unit>
        <trans-unit id="a1ef97817e3de9be1ea70784e7655c53546a2dc5" translate="yes" xml:space="preserve">
          <source>1) Ignores all elements that are equal to &lt;code&gt;value&lt;/code&gt;.</source>
          <target state="translated">1) Игнорирует все элементы, которые равны &lt;code&gt;value&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e94af7fe131aa943bb89af9451c2c83b03715052" translate="yes" xml:space="preserve">
          <source>1) Implements &lt;code&gt;operator!=&lt;/code&gt; in terms of &lt;code&gt;operator==&lt;/code&gt;.</source>
          <target state="translated">1) Реализует &lt;code&gt;operator!=&lt;/code&gt; В терминах &lt;code&gt;operator==&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="dab585f3da6ef91bb449ba583df62136d68e6d58" translate="yes" xml:space="preserve">
          <source>1) Implicitly declared default constructor.</source>
          <target state="translated">1)Неявно объявленный конструктор по умолчанию.</target>
        </trans-unit>
        <trans-unit id="5c681d4553e954943a32a867bbdf85235d7bbe9b" translate="yes" xml:space="preserve">
          <source>1) In a member function declaration, &lt;code&gt;final&lt;/code&gt; may appear in virt-specifier-seq immediately after the declarator, and before the &lt;a href=&quot;abstract_class&quot;&gt;pure-specifier&lt;/a&gt;, if used.</source>
          <target state="translated">1) В объявлении функции-члена &lt;code&gt;final&lt;/code&gt; может появиться в virt-specier-seq сразу после объявления и перед &lt;a href=&quot;abstract_class&quot;&gt;чисто спецификатором&lt;/a&gt; , если он используется.</target>
        </trans-unit>
        <trans-unit id="e87713d6a39f4e0ea9a3dfa0acccc59bf85daffe" translate="yes" xml:space="preserve">
          <source>1) In a member function declaration, &lt;code&gt;override&lt;/code&gt; may appear in virt-specifier-seq immediately after the declarator, and before the &lt;a href=&quot;abstract_class&quot;&gt;pure-specifier&lt;/a&gt;, if used.</source>
          <target state="translated">1) В объявлении функции-члена &lt;code&gt;override&lt;/code&gt; может появиться в virt-specier-seq сразу после декларатора и перед &lt;a href=&quot;abstract_class&quot;&gt;чисто спецификатором&lt;/a&gt; , если он используется.</target>
        </trans-unit>
        <trans-unit id="b7f2af54ab23b9453df13b695a120657cdbb78f5" translate="yes" xml:space="preserve">
          <source>1) In the &lt;a href=&quot;constructor&quot;&gt;member initializer list&lt;/a&gt; of the constructor.</source>
          <target state="translated">1) В &lt;a href=&quot;constructor&quot;&gt;списке инициализатора члена&lt;/a&gt; конструктора.</target>
        </trans-unit>
        <trans-unit id="ad85e856c86edd9721a76169fb3382fbd0691a1a" translate="yes" xml:space="preserve">
          <source>1) Index-based non-throwing accessor: If &lt;code&gt;pv&lt;/code&gt; is not a null pointer and &lt;code&gt;pv-&amp;gt;index() == I&lt;/code&gt;, returns a pointer to the value stored in the variant pointed to by &lt;code&gt;pv&lt;/code&gt;. Otherwise, returns a null pointer value. The call is ill-formed if &lt;code&gt;I&lt;/code&gt; is not a valid index in the variant.</source>
          <target state="translated">1) &lt;code&gt;pv-&amp;gt;index() == I&lt;/code&gt; : если &lt;code&gt;pv&lt;/code&gt; не является нулевым указателем и pv-&amp;gt; index () == I , возвращает указатель на значение, сохраненное в варианте, на который указывает &lt;code&gt;pv&lt;/code&gt; . В противном случае возвращает значение нулевого указателя. Вызов неправильный, если &lt;code&gt;I&lt;/code&gt; не верный индекс в варианте.</target>
        </trans-unit>
        <trans-unit id="9aabcbed245a33739cb3035c8ee0b94c11b43add" translate="yes" xml:space="preserve">
          <source>1) Index-based value accessor: If &lt;code&gt;v.index() == I&lt;/code&gt;, returns a reference to the value stored in &lt;code&gt;v&lt;/code&gt;. Otherwise, throws &lt;code&gt;&lt;a href=&quot;bad_variant_access&quot;&gt;std::bad_variant_access&lt;/a&gt;&lt;/code&gt;. The call is ill-formed if &lt;code&gt;I&lt;/code&gt; is not a valid index in the variant.</source>
          <target state="translated">1) &lt;code&gt;v.index() == I&lt;/code&gt; доступа к значению на основе индекса: если v.index () == I , возвращает ссылку на значение, сохраненное в &lt;code&gt;v&lt;/code&gt; . В противном случае выдает &lt;code&gt;&lt;a href=&quot;bad_variant_access&quot;&gt;std::bad_variant_access&lt;/a&gt;&lt;/code&gt; . Вызов неправильный, если &lt;code&gt;I&lt;/code&gt; не верный индекс в варианте.</target>
        </trans-unit>
        <trans-unit id="af4fb35a5ec3b4df2a4082311967437cd6c9b5db" translate="yes" xml:space="preserve">
          <source>1) Informs a &lt;code&gt;std::basic_string&lt;/code&gt; object of a planned change in size, so that it can manage the storage allocation appropriately.</source>
          <target state="translated">1) Информирует объект &lt;code&gt;std::basic_string&lt;/code&gt; о планируемом изменении размера, чтобы он мог надлежащим образом распределить хранилище.</target>
        </trans-unit>
        <trans-unit id="c71413d04de99f2d5426060b5049fea7209088cd" translate="yes" xml:space="preserve">
          <source>1) Initializes &lt;code&gt;r_&lt;/code&gt; with &lt;code&gt;nullptr&lt;/code&gt;. A default-initialized &lt;code&gt;ref_view&lt;/code&gt; references no &lt;a href=&quot;range&quot;&gt;&lt;code&gt;Range&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">1) Инициализирует &lt;code&gt;r_&lt;/code&gt; с помощью &lt;code&gt;nullptr&lt;/code&gt; . Инициализированный по умолчанию &lt;code&gt;ref_view&lt;/code&gt; ссылается на отсутствие &lt;a href=&quot;range&quot;&gt; &lt;code&gt;Range&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d666e6ac7a857628bc04dc566500208a77dfdfa4" translate="yes" xml:space="preserve">
          <source>1) Initializes the accumulator &lt;code&gt;acc&lt;/code&gt; with the initial value &lt;code&gt;init&lt;/code&gt; and then</source>
          <target state="translated">1) инициализирует аккумулятора в &lt;code&gt;acc&lt;/code&gt; с начальным значением &lt;code&gt;init&lt;/code&gt; , а затем</target>
        </trans-unit>
        <trans-unit id="390208e5ec0095fd5b6b97b7b3f847fcb7002d96" translate="yes" xml:space="preserve">
          <source>1) Initializes the base or member named by class-or-identifier using &lt;a href=&quot;direct_initialization&quot;&gt;direct initialization&lt;/a&gt; or, if expression-list is empty, &lt;a href=&quot;value_initialization&quot;&gt;value-initialization&lt;/a&gt;</source>
          <target state="translated">1) Инициализирует базу или член, названный по классу или идентификатору, используя &lt;a href=&quot;direct_initialization&quot;&gt;прямую инициализацию&lt;/a&gt; или, если выражение-список пуст, &lt;a href=&quot;value_initialization&quot;&gt;инициализацию значения&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="0738aa8c98109913fcc387730825b9c7aaa58446" translate="yes" xml:space="preserve">
          <source>1) Initializes the contained value by &lt;a href=&quot;../../language/direct_initialization&quot;&gt;direct-initializing&lt;/a&gt; (but not direct-list-initializing) with &lt;code&gt;&lt;a href=&quot;../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;Args&amp;gt;(args)...&lt;/code&gt; as parameters.</source>
          <target state="translated">1) Инициализирует содержащееся значение путем &lt;a href=&quot;../../language/direct_initialization&quot;&gt;прямой инициализации&lt;/a&gt; (но не прямой инициализации списка) с использованием &lt;code&gt;&lt;a href=&quot;../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;Args&amp;gt;(args)...&lt;/code&gt; качестве параметров.</target>
        </trans-unit>
        <trans-unit id="55b3a7a556eb22d3fddafb6be7ce6a255efdaa60" translate="yes" xml:space="preserve">
          <source>1) Initializes the underlying &lt;code&gt;shared_ptr&amp;lt;T&amp;gt;&lt;/code&gt; to default-constructed value</source>
          <target state="translated">1) Инициализирует базовый &lt;code&gt;shared_ptr&amp;lt;T&amp;gt;&lt;/code&gt; в значение по умолчанию</target>
        </trans-unit>
        <trans-unit id="56d3077b0b0cef44db878906aa8a6c39943f7a5f" translate="yes" xml:space="preserve">
          <source>1) Initializes the underlying &lt;code&gt;weak_ptr&amp;lt;T&amp;gt;&lt;/code&gt; to default-constructed value</source>
          <target state="translated">1) Инициализирует нижележащее &lt;code&gt;weak_ptr&amp;lt;T&amp;gt;&lt;/code&gt; до значения, созданного по умолчанию</target>
        </trans-unit>
        <trans-unit id="4ac80d611dc008ae2fce6aea9e7cf692cd5e7b32" translate="yes" xml:space="preserve">
          <source>1) Initializes the underlying pointer to container with &lt;code&gt;nullptr&lt;/code&gt; and value-initializes the underlying iterator.</source>
          <target state="translated">1) Инициализирует базовый указатель на контейнер с помощью &lt;code&gt;nullptr&lt;/code&gt; и значение инициализирует базовый итератор.</target>
        </trans-unit>
        <trans-unit id="e37bfcf43e090a94cd623e83017e50e5bca2fc1a" translate="yes" xml:space="preserve">
          <source>1) Initializes the underlying pointer to container with &lt;code&gt;nullptr&lt;/code&gt;.</source>
          <target state="translated">1) Инициализирует базовый указатель на контейнер с &lt;code&gt;nullptr&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="dcd29c5e81afcd584e544f121d5f47dadd0f4de1" translate="yes" xml:space="preserve">
          <source>1) Initializes with streambuf &lt;code&gt;sb&lt;/code&gt;. The base classes are initialized as &lt;code&gt;basic_istream&amp;lt;CharT,Traits&amp;gt;(sb)&lt;/code&gt; and &lt;code&gt;basic_ostream&amp;lt;CharT,Traits&amp;gt;(sb)&lt;/code&gt;. After the call &lt;code&gt;rdbuf() == sb&lt;/code&gt; and &lt;code&gt;gcount() == 0&lt;/code&gt;.</source>
          <target state="translated">1) Инициализируется с помощью streambuf &lt;code&gt;sb&lt;/code&gt; . Базовые классы инициализируются как &lt;code&gt;basic_istream&amp;lt;CharT,Traits&amp;gt;(sb)&lt;/code&gt; и &lt;code&gt;basic_ostream&amp;lt;CharT,Traits&amp;gt;(sb)&lt;/code&gt; . После вызова &lt;code&gt;rdbuf() == sb&lt;/code&gt; и &lt;code&gt;gcount() == 0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="597197c59314c93c55128912be74ee54b394e721" translate="yes" xml:space="preserve">
          <source>1) Inserts &lt;code&gt;count&lt;/code&gt; copies of character &lt;code&gt;ch&lt;/code&gt; at the position &lt;code&gt;index&lt;/code&gt;</source>
          <target state="translated">1) Вставляет &lt;code&gt;count&lt;/code&gt; копий символа &lt;code&gt;ch&lt;/code&gt; в &lt;code&gt;index&lt;/code&gt; позиции</target>
        </trans-unit>
        <trans-unit id="2f9e626ebe4226924cf0f29adddd15e2078d9dc6" translate="yes" xml:space="preserve">
          <source>1) Inserts &lt;code&gt;value_type(key, T())&lt;/code&gt; if the key does not exist. This function is equivalent to &lt;code&gt;return insert(&lt;a href=&quot;../../utility/pair/make_pair&quot;&gt;std::make_pair&lt;/a&gt;(key, T())).first-&amp;gt;second;&lt;/code&gt;</source>
          <target state="translated">1) Вставляет &lt;code&gt;value_type(key, T())&lt;/code&gt; если ключ не существует. Эта функция эквивалентна &lt;code&gt;return insert(&lt;a href=&quot;../../utility/pair/make_pair&quot;&gt;std::make_pair&lt;/a&gt;(key, T())).first-&amp;gt;second;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1bbcdba0d1f411974c0900c76adfb06fb4ddf41c" translate="yes" xml:space="preserve">
          <source>1) Inserts a &lt;code&gt;value_type&lt;/code&gt; object constructed in-place from &lt;code&gt;&lt;a href=&quot;../../utility/piecewise_construct&quot;&gt;std::piecewise_construct&lt;/a&gt;, &lt;a href=&quot;../../utility/tuple/forward_as_tuple&quot;&gt;std::forward_as_tuple&lt;/a&gt;(key), &lt;a href=&quot;../../utility/tuple&quot;&gt;std::tuple&lt;/a&gt;&amp;lt;&amp;gt;()&lt;/code&gt; if the key does not exist.  This function is equivalent to &lt;code&gt;return this-&amp;gt;try_emplace(key).first-&amp;gt;second;&lt;/code&gt;.(since C++17)</source>
          <target state="translated">1) Вставляет объект &lt;code&gt;value_type&lt;/code&gt; ,созданный на месте из &lt;code&gt;&lt;a href=&quot;../../utility/piecewise_construct&quot;&gt;std::piecewise_construct&lt;/a&gt;, &lt;a href=&quot;../../utility/tuple/forward_as_tuple&quot;&gt;std::forward_as_tuple&lt;/a&gt;(key), &lt;a href=&quot;../../utility/tuple&quot;&gt;std::tuple&lt;/a&gt;&amp;lt;&amp;gt;()&lt;/code&gt; если ключ не существует. Эта функция эквивалентна &lt;code&gt;return this-&amp;gt;try_emplace(key).first-&amp;gt;second;&lt;/code&gt; . (начиная с C ++ 17)</target>
        </trans-unit>
        <trans-unit id="1ed499190167ff7f4a4dca5f353727adf6c5d67d" translate="yes" xml:space="preserve">
          <source>1) Integer formatters: &lt;code&gt;value&lt;/code&gt; is converted to a string of digits in the given &lt;code&gt;base&lt;/code&gt; (with no redundant leading zeroes). Digits in the range &lt;code&gt;10..35&lt;/code&gt; (inclusive) are represented as lowercase characters &lt;code&gt;a..z&lt;/code&gt;. If value is less than zero, the representation starts with a minus sign. The library provides overloads for all signed and unsigned integer types and for the type &lt;code&gt;char&lt;/code&gt; as the type of the parameter &lt;code&gt;value&lt;/code&gt;.</source>
          <target state="translated">1) Целочисленные форматеры: &lt;code&gt;value&lt;/code&gt; преобразуется в строку цифр в заданной &lt;code&gt;base&lt;/code&gt; (без избыточных начальных нулей). Цифры в диапазоне &lt;code&gt;10..35&lt;/code&gt; (включительно) представлены строчными буквами &lt;code&gt;a..z&lt;/code&gt; . Если значение меньше нуля, представление начинается со знака минус. Библиотека обеспечивает перегрузки для всех целочисленных типов со знаком и без знака, а также для типа &lt;code&gt;char&lt;/code&gt; в качестве типа &lt;code&gt;value&lt;/code&gt; параметра .</target>
        </trans-unit>
        <trans-unit id="2cd742de2bf8d435baa1eb1ba04960df29830e0c" translate="yes" xml:space="preserve">
          <source>1) Integer parsers: Expects the pattern identical to the one used by &lt;code&gt;&lt;a href=&quot;../string/byte/strtol&quot;&gt;std::strtol&lt;/a&gt;&lt;/code&gt; in the default (&quot;C&quot;) locale and the given non-zero numeric base, except that</source>
          <target state="translated">1) Целочисленные парсеры: ожидает шаблон, идентичный шаблону, используемому &lt;code&gt;&lt;a href=&quot;../string/byte/strtol&quot;&gt;std::strtol&lt;/a&gt;&lt;/code&gt; в локали по умолчанию (&quot;C&quot;) и заданной ненулевой числовой базе, за исключением того, что</target>
        </trans-unit>
        <trans-unit id="8a213779ff6418b03ee0523325685afdc5d484b9" translate="yes" xml:space="preserve">
          <source>1) It cannot be used anywhere in the program</source>
          <target state="translated">1)Она не может быть использована нигде в программе.</target>
        </trans-unit>
        <trans-unit id="52283fc726cca49a55017924c746b83c68a86057" translate="yes" xml:space="preserve">
          <source>1) It must be declared &lt;code&gt;inline&lt;/code&gt; in every translation unit.</source>
          <target state="translated">1) Он должен быть объявлен &lt;code&gt;inline&lt;/code&gt; в каждой единице перевода.</target>
        </trans-unit>
        <trans-unit id="93c41523dfecbacf0866640c365002e86309d551" translate="yes" xml:space="preserve">
          <source>1) Iterator to the element following the erased one, or &lt;code&gt;&lt;a href=&quot;end&quot;&gt;end()&lt;/a&gt;&lt;/code&gt; if no such element exists.</source>
          <target state="translated">1) Итератор для элемента, следующего за стертым, или &lt;code&gt;&lt;a href=&quot;end&quot;&gt;end()&lt;/a&gt;&lt;/code&gt; если такого элемента не существует.</target>
        </trans-unit>
        <trans-unit id="db998b65059f221b9947c1e2b84b7328aa9c6731" translate="yes" xml:space="preserve">
          <source>1) Iterator to the first element of the path.</source>
          <target state="translated">1)Итератор к первому элементу пути.</target>
        </trans-unit>
        <trans-unit id="5f63d6bacd5c75bb3d9c40afba52d76d0aa26b7a" translate="yes" xml:space="preserve">
          <source>1) Linear in &lt;code&gt;count&lt;/code&gt;</source>
          <target state="translated">1) Линейный по &lt;code&gt;count&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="bad57cdbf49ee5c9cf8b15794f0ba25ea25faaf6" translate="yes" xml:space="preserve">
          <source>1) Linear in the number of characters compared.</source>
          <target state="translated">1)Линейное количество сравниваемых символов.</target>
        </trans-unit>
        <trans-unit id="bfbdf175b676848b3b112f3b7622116e7ae24018" translate="yes" xml:space="preserve">
          <source>1) Linear in the size of &lt;code&gt;*this&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt;.</source>
          <target state="translated">1) Линейный по размеру &lt;code&gt;*this&lt;/code&gt; и &lt;code&gt;other&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ae3d9bc82a6c5df2515038c2bc04f8922fb3612d" translate="yes" xml:space="preserve">
          <source>1) Linear in the size of &lt;code&gt;other&lt;/code&gt;</source>
          <target state="translated">1) Линейный по размеру &lt;code&gt;other&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b7138a1f54274e2bc82a87855f742eb60f4fcddc" translate="yes" xml:space="preserve">
          <source>1) Literal operators with this parameter list are the</source>
          <target state="translated">1)Буквальные операторы с этим перечнем параметров-это</target>
        </trans-unit>
        <trans-unit id="d4f26c9f8811c2aa27521ffafb650efe7f636432" translate="yes" xml:space="preserve">
          <source>1) Literals (e.g. &lt;code&gt;2&lt;/code&gt; or &lt;code&gt;&quot;Hello, world&quot;&lt;/code&gt;)</source>
          <target state="translated">1) Литералы (например, &lt;code&gt;2&lt;/code&gt; или &lt;code&gt;&quot;Hello, world&quot;&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="692f0144de0296503caf6eb540cde981dab090e2" translate="yes" xml:space="preserve">
          <source>1) Logical AND (&lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt;). The value for the empty pack is &lt;code&gt;true&lt;/code&gt;</source>
          <target state="translated">1) Логическое И ( &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; ). Значение для пустой упаковки - &lt;code&gt;true&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="be220faf928704a940a2cf9ed4835d69e6844ef4" translate="yes" xml:space="preserve">
          <source>1) Logical NOT</source>
          <target state="translated">1)Логическое ЗАМЕЧАНИЕ</target>
        </trans-unit>
        <trans-unit id="dad928c0d3430b473633cea25234a47b689119c3" translate="yes" xml:space="preserve">
          <source>1) Manages a single object (e.g. allocated with &lt;code&gt;new&lt;/code&gt;)</source>
          <target state="translated">1) Управляет одним объектом (например, назначается с &lt;code&gt;new&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="c2dafa4c13c344cdd5b36d49ab1c8f9cb1618f3e" translate="yes" xml:space="preserve">
          <source>1) May throw &lt;code&gt;&lt;a href=&quot;../../error/system_error&quot;&gt;std::system_error&lt;/a&gt;&lt;/code&gt; with &lt;code&gt;&lt;a href=&quot;../../error/error_condition&quot;&gt;std::error_condition&lt;/a&gt;&lt;/code&gt; equal to &lt;code&gt;&lt;a href=&quot;../../error/errc&quot;&gt;std::errc::operation_not_permitted&lt;/a&gt;&lt;/code&gt; if the thread has no privilege to create a condition variable, &lt;code&gt;&lt;a href=&quot;../../error/errc&quot;&gt;std::errc::resource_unavailable_try_again&lt;/a&gt;&lt;/code&gt; if a non-memory resource limitation prevents this initialization, or another implementation-defined value.</source>
          <target state="translated">1) Может бросить &lt;code&gt;&lt;a href=&quot;../../error/system_error&quot;&gt;std::system_error&lt;/a&gt;&lt;/code&gt; с &lt;code&gt;&lt;a href=&quot;../../error/error_condition&quot;&gt;std::error_condition&lt;/a&gt;&lt;/code&gt; равен &lt;code&gt;&lt;a href=&quot;../../error/errc&quot;&gt;std::errc::operation_not_permitted&lt;/a&gt;&lt;/code&gt; если поток не имеет никаких привилегий для создания переменного условия, &lt;code&gt;&lt;a href=&quot;../../error/errc&quot;&gt;std::errc::resource_unavailable_try_again&lt;/a&gt;&lt;/code&gt; если ограничение ресурса без памяти предотвращает это инициализация или другое значение, определяемое реализацией.</target>
        </trans-unit>
        <trans-unit id="e0f5008a342755f8d0c7df43b3ab66846dd152a1" translate="yes" xml:space="preserve">
          <source>1) May throw &lt;code&gt;&lt;a href=&quot;../ios_base/failure&quot;&gt;std::ios_base::failure&lt;/a&gt;&lt;/code&gt; in case of failure, if &lt;code&gt;exceptions() &amp;amp; failbit != 0&lt;/code&gt;.</source>
          <target state="translated">1) Может &lt;code&gt;&lt;a href=&quot;../ios_base/failure&quot;&gt;std::ios_base::failure&lt;/a&gt;&lt;/code&gt; в случае сбоя, если &lt;code&gt;exceptions() &amp;amp; failbit != 0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fec14884289d124fcea9cdbca0e3487bb3fefeab" translate="yes" xml:space="preserve">
          <source>1) May throw any exception thrown by the value initialization of the first alternative.</source>
          <target state="translated">1)Может бросить любое исключение,брошенное инициализацией значения первой альтернативы.</target>
        </trans-unit>
        <trans-unit id="6d9856c647bd6f18f2c4199f99dda0d7103b839f" translate="yes" xml:space="preserve">
          <source>1) Member declarations of the form</source>
          <target state="translated">1)Заявления членов на бланке</target>
        </trans-unit>
        <trans-unit id="f54b805bef5f1481100f7bcad5d8d8c57550f520" translate="yes" xml:space="preserve">
          <source>1) Minimum offset between two objects to avoid false sharing. Guaranteed to be at least &lt;code&gt;alignof(&lt;a href=&quot;../types/max_align_t&quot;&gt;std::max_align_t&lt;/a&gt;)&lt;/code&gt;</source>
          <target state="translated">1) Минимальное смещение между двумя объектами, чтобы избежать ложного обмена. Гарантируется как минимум &lt;code&gt;alignof(&lt;a href=&quot;../types/max_align_t&quot;&gt;std::max_align_t&lt;/a&gt;)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="cc024f12038108f0c21d9b9bb7028dab37fcc8fc" translate="yes" xml:space="preserve">
          <source>1) Modifies the &lt;code&gt;&lt;a href=&quot;timespec&quot;&gt;std::timespec&lt;/a&gt;&lt;/code&gt; object pointed to by &lt;code&gt;ts&lt;/code&gt; to hold the current calendar time in the time base &lt;code&gt;base&lt;/code&gt;.</source>
          <target state="translated">1) Изменяет &lt;code&gt;&lt;a href=&quot;timespec&quot;&gt;std::timespec&lt;/a&gt;&lt;/code&gt; объект , на который указует &lt;code&gt;ts&lt;/code&gt; для хранения текущего времени календаря в базовых временных &lt;code&gt;base&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="019c13e7183a754e9d764c5fd9f436c7e5d5c9dd" translate="yes" xml:space="preserve">
          <source>1) Modifying the character array accessed through the const overload of &lt;code&gt;data&lt;/code&gt; has undefined behavior.</source>
          <target state="translated">1) Изменение массива символов, доступ к которому осуществляется через константную перегрузку &lt;code&gt;data&lt;/code&gt; имеет неопределенное поведение.</target>
        </trans-unit>
        <trans-unit id="32267b5e71f7ec1d742dce72b339a8c92ce8f8bc" translate="yes" xml:space="preserve">
          <source>1) Move assignment operator. First, abandons the shared state (as in &lt;code&gt;~promise()&lt;/code&gt;), then assigns the shared state of &lt;code&gt;other&lt;/code&gt; as if by executing &lt;code&gt;&lt;a href=&quot;../promise&quot;&gt;std::promise&lt;/a&gt;(std::move(other)).swap(*this)&lt;/code&gt;.</source>
          <target state="translated">1) Оператор назначения перемещения. Во-первых, отказывается от общего состояния (как в &lt;code&gt;~promise()&lt;/code&gt; ), затем назначает общее состояние &lt;code&gt;other&lt;/code&gt; как будто, выполняя &lt;code&gt;&lt;a href=&quot;../promise&quot;&gt;std::promise&lt;/a&gt;(std::move(other)).swap(*this)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="87be123334c79f86e66db927b0f1e69d4152ff3f" translate="yes" xml:space="preserve">
          <source>1) Move assignment operator: Moves the contents of &lt;code&gt;rhs&lt;/code&gt; into &lt;code&gt;*this&lt;/code&gt;. After the move, &lt;code&gt;*this&lt;/code&gt; has the associated string, the open mode, the locale, and all other state formerly held by &lt;code&gt;rhs&lt;/code&gt;. The six pointers of &lt;code&gt;&lt;a href=&quot;../basic_streambuf&quot;&gt;std::basic_streambuf&lt;/a&gt;&lt;/code&gt; in &lt;code&gt;*this&lt;/code&gt; are guaranteed to be different from the corresponding pointers in the moved-from &lt;code&gt;rhs&lt;/code&gt; unless null.</source>
          <target state="translated">1) Оператор присваивания перемещения: перемещает содержимое &lt;code&gt;rhs&lt;/code&gt; в &lt;code&gt;*this&lt;/code&gt; . После перемещения &lt;code&gt;*this&lt;/code&gt; него есть связанная строка, режим открытия, локаль и все остальные состояния, ранее принадлежавшие &lt;code&gt;rhs&lt;/code&gt; . Шесть указателей &lt;code&gt;&lt;a href=&quot;../basic_streambuf&quot;&gt;std::basic_streambuf&lt;/a&gt;&lt;/code&gt; в &lt;code&gt;*this&lt;/code&gt; гарантированно будут отличаться от соответствующих указателей в &lt;code&gt;rhs&lt;/code&gt; с перемещением, если только они не равны нулю.</target>
        </trans-unit>
        <trans-unit id="7d6353cf0852cf732b2e80b3c54029fc7ed0252d" translate="yes" xml:space="preserve">
          <source>1) Moves &lt;code&gt;count&lt;/code&gt; elements from a range beginning at &lt;code&gt;first&lt;/code&gt; to an uninitialized memory area beginning at &lt;code&gt;d_first&lt;/code&gt; as if by</source>
          <target state="translated">1) Перемещает &lt;code&gt;count&lt;/code&gt; элементов из диапазона, начинающегося &lt;code&gt;first&lt;/code&gt; в неинициализированную область памяти, начинающуюся с &lt;code&gt;d_first&lt;/code&gt; , как если бы</target>
        </trans-unit>
        <trans-unit id="baeda8b2207e79e0e28d467dccba16a337675b05" translate="yes" xml:space="preserve">
          <source>1) Moves all elements from &lt;code&gt;other&lt;/code&gt; into &lt;code&gt;*this&lt;/code&gt;. The elements are inserted after the element pointed to by &lt;code&gt;pos&lt;/code&gt;. The container &lt;code&gt;other&lt;/code&gt; becomes empty after the operation. The behavior is undefined if &lt;code&gt;other&lt;/code&gt; refers to the same object as &lt;code&gt;*this&lt;/code&gt;.</source>
          <target state="translated">1) Перемещает все элементы из &lt;code&gt;other&lt;/code&gt; в &lt;code&gt;*this&lt;/code&gt; . Элементы вставляются после элемента, на который указывает &lt;code&gt;pos&lt;/code&gt; . Контейнер &lt;code&gt;other&lt;/code&gt; становится пустым после операции. Поведение не определено, если &lt;code&gt;other&lt;/code&gt; относится к тому же объекту, что и &lt;code&gt;*this&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cbee85f489bfd5c711863ceb3ce35d639917da93" translate="yes" xml:space="preserve">
          <source>1) Moves elements from the range &lt;code&gt;[first, last)&lt;/code&gt; to an uninitialized memory area beginning at &lt;code&gt;d_first&lt;/code&gt; as if by</source>
          <target state="translated">1) Перемещает элементы из диапазона &lt;code&gt;[first, last)&lt;/code&gt; в неинициализированную область памяти, начиная с &lt;code&gt;d_first&lt;/code&gt; , как если бы</target>
        </trans-unit>
        <trans-unit id="a02bfb3935e9c4bd8c50e3ceaa51a1ac20773de1" translate="yes" xml:space="preserve">
          <source>1) Moves the elements in the range &lt;code&gt;[first, last)&lt;/code&gt;, to another range beginning at &lt;code&gt;d_first&lt;/code&gt;, starting from first and proceeding to last - 1. After this operation the elements in the moved-from range will still contain valid values of the appropriate type, but not necessarily the same values as before the move.</source>
          <target state="translated">1) Перемещает элементы в диапазоне &lt;code&gt;[first, last)&lt;/code&gt; , в другой диапазон, начинающийся с &lt;code&gt;d_first&lt;/code&gt; , начиная с первого и продолжая до последнего - 1. После этой операции элементы в диапазоне отодвинутых будут по-прежнему содержать действительные значения соответствующего введите, но не обязательно те же значения, что и до перемещения.</target>
        </trans-unit>
        <trans-unit id="3e96eedb6a4729d6cd532f90b4c42d7009c20ae6" translate="yes" xml:space="preserve">
          <source>1) Names declared by the init-statement (if init-statement is a declaration) and names declared by condition (if condition is a declaration) are in the same scope (which is also the scope of statement).</source>
          <target state="translated">1)Наименования,заявленные в заявлении init (если заявление init является декларацией),и наименования,заявленные в заявлении condition (если условие является декларацией),входят в одну и ту же область применения (что также входит в сферу применения заявления).</target>
        </trans-unit>
        <trans-unit id="29f0125e541e7b6cb76f5dbbc2fb2c46cdd5ba5f" translate="yes" xml:space="preserve">
          <source>1) Narrow multibyte string literal. The type of an unprefixed string literal is &lt;code&gt;const char[N]&lt;/code&gt;, where &lt;code&gt;N&lt;/code&gt; is the size of the string in code units of the execution narrow encoding, including the null terminator.</source>
          <target state="translated">1) Узкий многобайтовый строковый литерал. Тип строкового литерала без префикса - &lt;code&gt;const char[N]&lt;/code&gt; , где &lt;code&gt;N&lt;/code&gt; - размер строки в единицах кода узкой кодировки выполнения, включая нулевой терминатор.</target>
        </trans-unit>
        <trans-unit id="d4f47d080da433e4df7de35bc1790426bc94e157" translate="yes" xml:space="preserve">
          <source>1) Non-throwing dynamic exception specification</source>
          <target state="translated">1)Небросающая динамическая спецификация исключений</target>
        </trans-unit>
        <trans-unit id="6a6a9ceef837057cbc352d5ec70b0fd0f2b2c8bd" translate="yes" xml:space="preserve">
          <source>1) Number of elements with key &lt;code&gt;key&lt;/code&gt;, that is either 1 or 0.</source>
          <target state="translated">1) Количество элементов с ключом &lt;code&gt;key&lt;/code&gt; , то есть 1 или 0.</target>
        </trans-unit>
        <trans-unit id="1564a87a6e67740b705461f9434aea174e148c19" translate="yes" xml:space="preserve">
          <source>1) Number of elements with key &lt;code&gt;key&lt;/code&gt;.</source>
          <target state="translated">1) Количество элементов с ключом &lt;code&gt;key&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3517215f133f6ebfae6482995743c32e01ac79c9" translate="yes" xml:space="preserve">
          <source>1) Obtains the actual address of the object or function &lt;code&gt;arg&lt;/code&gt;, even in presence of overloaded &lt;code&gt;operator&amp;amp;&lt;/code&gt;</source>
          <target state="translated">1) Получает фактический адрес объекта или функции &lt;code&gt;arg&lt;/code&gt; даже при наличии перегруженного &lt;code&gt;operator&amp;amp;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="63c030571149d7aea7d192bb60285199d1752b0e" translate="yes" xml:space="preserve">
          <source>1) Often known as &quot;C-style&quot; or &quot;multi-line&quot; comments.</source>
          <target state="translated">1)Часто известный как &quot;С-стиль&quot; или &quot;многострочный&quot; комментарий.</target>
        </trans-unit>
        <trans-unit id="842c5f199cfee8d76155c07d299c1fe9ce02bab8" translate="yes" xml:space="preserve">
          <source>1) Parses the date and time from the input character sequence &lt;code&gt;[beg, end)&lt;/code&gt; according to the format provided in the character sequence &lt;code&gt;[fmtbeg, fmtend)&lt;/code&gt;. The format is expected to follow the format described below, although actual processing of each format specifier can be customized by overriding &lt;code&gt;do_get&lt;/code&gt;. The &lt;code&gt;get&lt;/code&gt; function performs the following: First, clears the error bits in &lt;code&gt;err&lt;/code&gt; by executing &lt;code&gt;err = &lt;a href=&quot;../../io/ios_base/iostate&quot;&gt;std::ios_base::goodbit&lt;/a&gt;&lt;/code&gt;. Then enters a loop, which terminates whenever any of the following conditions becomes true (checked in this order):</source>
          <target state="translated">1) Анализирует дату и время из входной последовательности символов &lt;code&gt;[beg, end)&lt;/code&gt; соответствии с форматом, предоставленным в последовательности символов &lt;code&gt;[fmtbeg, fmtend)&lt;/code&gt; . Ожидается, что формат будет соответствовать формату, описанному ниже, хотя фактическая обработка каждого спецификатора формата может быть настроена путем переопределения &lt;code&gt;do_get&lt;/code&gt; . Функция &lt;code&gt;get&lt;/code&gt; выполняет следующее: во-первых, очищает ошибочные биты в &lt;code&gt;err&lt;/code&gt; , выполняя &lt;code&gt;err = &lt;a href=&quot;../../io/ios_base/iostate&quot;&gt;std::ios_base::goodbit&lt;/a&gt;&lt;/code&gt; . Затем входит в цикл, который завершается всякий раз, когда выполняется любое из следующих условий (проверяется в следующем порядке):</target>
        </trans-unit>
        <trans-unit id="4251fa4ac37443b00ba495f01dec70943d49534e" translate="yes" xml:space="preserve">
          <source>1) Performs &lt;code&gt;*this = *this + d;&lt;/code&gt;</source>
          <target state="translated">1) Выполняет &lt;code&gt;*this = *this + d;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="06459854688602a24bce5db298f1ff763c820069" translate="yes" xml:space="preserve">
          <source>1) Performs &lt;code&gt;*this = *this + m;&lt;/code&gt;</source>
          <target state="translated">1) Выполняет &lt;code&gt;*this = *this + m;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="65fb962cbf281356d7871dec0c276ca503ae02f5" translate="yes" xml:space="preserve">
          <source>1) Performs a left rotation on a range of elements.</source>
          <target state="translated">1)Выполняет вращение влево на ряде элементов.</target>
        </trans-unit>
        <trans-unit id="24157bdc426e8751a205fa626eea64b65972c149" translate="yes" xml:space="preserve">
          <source>1) Performs atomic addition. Equivalent to &lt;code&gt;fetch_add(arg)&lt;/code&gt; + arg.</source>
          <target state="translated">1) Выполняет атомарное сложение. Эквивалент &lt;code&gt;fetch_add(arg)&lt;/code&gt; + arg.</target>
        </trans-unit>
        <trans-unit id="b7b35043c329a05e326ecc4ac09efa80c7ee56f7" translate="yes" xml:space="preserve">
          <source>1) Performs atomic addition. Equivalent to &lt;code&gt;return fetch_add(arg) + arg;&lt;/code&gt;.</source>
          <target state="translated">1) Выполняет атомарное сложение. Эквивалентно &lt;code&gt;return fetch_add(arg) + arg;&lt;/code&gt; ,</target>
        </trans-unit>
        <trans-unit id="0419ff58b80e0ea3e34dbe1120d304b2154ccd33" translate="yes" xml:space="preserve">
          <source>1) Performs atomic pre-increment. Equivalent to &lt;code&gt;fetch_add(1)+1&lt;/code&gt;.</source>
          <target state="translated">1) Выполняет атомарный предварительный прирост. Эквивалент &lt;code&gt;fetch_add(1)+1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9d7cb0da243e1e814c426ca15e77bf948db18b30" translate="yes" xml:space="preserve">
          <source>1) Performs atomic pre-increment. Equivalent to &lt;code&gt;return fetch_add(1) + 1;&lt;/code&gt;.</source>
          <target state="translated">1) Выполняет атомарный предварительный прирост. Эквивалент &lt;code&gt;return fetch_add(1) + 1;&lt;/code&gt; ,</target>
        </trans-unit>
        <trans-unit id="8165604074e09874cc008cd54a9677022761ce36" translate="yes" xml:space="preserve">
          <source>1) Pre-increment. Returns the updated iterator.</source>
          <target state="translated">1)Предварительное включение.Возвращает обновленный итератор.</target>
        </trans-unit>
        <trans-unit id="98b2b73f529f9a9c81704e2afa46fe127b827d7f" translate="yes" xml:space="preserve">
          <source>1) Previous associated locale.</source>
          <target state="translated">1)Предыдущая ассоциированная местность.</target>
        </trans-unit>
        <trans-unit id="90eaf4a181c70f4e6dd5dad828ce93c49a0f00b7" translate="yes" xml:space="preserve">
          <source>1) Primary template is an empty struct.</source>
          <target state="translated">1)Основной шаблон-пустая структура.</target>
        </trans-unit>
        <trans-unit id="d3b8bab61ba0a04eca35d2c18428e6aaa3ccf10f" translate="yes" xml:space="preserve">
          <source>1) Public member function, calls the member function &lt;code&gt;do_always_noconv&lt;/code&gt; of the most derived class.</source>
          <target state="translated">1) &lt;code&gt;do_always_noconv&lt;/code&gt; функция-член, вызывает функцию-член do_always_noconv самого производного класса.</target>
        </trans-unit>
        <trans-unit id="baf1382568df4bb859c2f19d25f5fa51f0d6c8b6" translate="yes" xml:space="preserve">
          <source>1) Public member function, calls the member function &lt;code&gt;do_curr_symbol&lt;/code&gt; of the most derived class.</source>
          <target state="translated">1) &lt;code&gt;do_curr_symbol&lt;/code&gt; функция-член, вызывает функцию-член do_curr_symbol самого производного класса.</target>
        </trans-unit>
        <trans-unit id="8803148252b377ffcd4da972f99e35584fa057b1" translate="yes" xml:space="preserve">
          <source>1) Public member function, calls the member function &lt;code&gt;do_decimal_point&lt;/code&gt; of the most derived class.</source>
          <target state="translated">1) &lt;code&gt;do_decimal_point&lt;/code&gt; функция-член, вызывает функцию-член do_decimal_point наиболее производного класса.</target>
        </trans-unit>
        <trans-unit id="6f5e8bfa91bd146e3eb1c442796dcc622fd2cb53" translate="yes" xml:space="preserve">
          <source>1) Public member function, calls the member function &lt;code&gt;do_frac_digits&lt;/code&gt; of the most derived class.</source>
          <target state="translated">1) &lt;code&gt;do_frac_digits&lt;/code&gt; функция-член, вызывает функцию-член do_frac_digits самого производного класса.</target>
        </trans-unit>
        <trans-unit id="cd263bbd005fdfda08890b70706b6c4d80e469da" translate="yes" xml:space="preserve">
          <source>1) Public member function, calls the member function &lt;code&gt;do_get&lt;/code&gt; of the most derived class.</source>
          <target state="translated">1) &lt;code&gt;do_get&lt;/code&gt; функция-член, вызывает функцию-член do_get самого производного класса.</target>
        </trans-unit>
        <trans-unit id="2ea4e6b7dcb9f599bddec78e09271c36d3302c0e" translate="yes" xml:space="preserve">
          <source>1) Public member function, calls the member function &lt;code&gt;do_grouping&lt;/code&gt; of the most derived class.</source>
          <target state="translated">1) &lt;code&gt;do_grouping&lt;/code&gt; функция-член, вызывает функцию-член do_grouping самого производного класса.</target>
        </trans-unit>
        <trans-unit id="2f1cefcfa79a30f86558cc5d92aa1f12547b1071" translate="yes" xml:space="preserve">
          <source>1) Public member function, calls the member function &lt;code&gt;do_in&lt;/code&gt; of the most derived class.</source>
          <target state="translated">1) &lt;code&gt;do_in&lt;/code&gt; функция-член, вызывает функцию-член do_in самого производного класса.</target>
        </trans-unit>
        <trans-unit id="caad5ee2da96131cd137488a3b8e49826497e05d" translate="yes" xml:space="preserve">
          <source>1) Public member function, calls the member function &lt;code&gt;do_max_length&lt;/code&gt; of the most derived class.</source>
          <target state="translated">1) &lt;code&gt;do_max_length&lt;/code&gt; функция-член, вызывает функцию-член do_max_length самого производного класса.</target>
        </trans-unit>
        <trans-unit id="c42e6d12a6460383165ecd093240a382422e7a50" translate="yes" xml:space="preserve">
          <source>1) Public member function, calls the member function &lt;code&gt;do_pos_format&lt;/code&gt; of the most derived class.</source>
          <target state="translated">1) &lt;code&gt;do_pos_format&lt;/code&gt; функция-член, вызывает функцию-член do_pos_format самого производного класса.</target>
        </trans-unit>
        <trans-unit id="bc5bc70d6c3c7d1b63e978e2bb5f510449787adf" translate="yes" xml:space="preserve">
          <source>1) Public member function, calls the member function &lt;code&gt;do_positive_sign&lt;/code&gt; of the most derived class.</source>
          <target state="translated">1) &lt;code&gt;do_positive_sign&lt;/code&gt; функция-член, вызывает функцию-член do_positive_sign самого производного класса.</target>
        </trans-unit>
        <trans-unit id="6a7fb6649c9c1933430d44d28c9be6af80e73282" translate="yes" xml:space="preserve">
          <source>1) Public member function, calls the member function &lt;code&gt;do_thousands_sep&lt;/code&gt; of the most derived class.</source>
          <target state="translated">1) &lt;code&gt;do_thousands_sep&lt;/code&gt; функция-член, вызывает функцию-член do_thousands_sep самого производного класса.</target>
        </trans-unit>
        <trans-unit id="a05a1a4712a55bd65ed1b7c2d0c6498741ebcfac" translate="yes" xml:space="preserve">
          <source>1) Public member function, calls the protected virtual member function &lt;code&gt;do_compare&lt;/code&gt; of the most derived class.</source>
          <target state="translated">1) &lt;code&gt;do_compare&lt;/code&gt; функция-член, вызывает защищенную виртуальную функцию-член do_compare самого производного класса.</target>
        </trans-unit>
        <trans-unit id="50240ff8cfc5297f7dea433cf9aa0e95cbb740bd" translate="yes" xml:space="preserve">
          <source>1) Public member function, calls the protected virtual member function &lt;code&gt;do_date_order&lt;/code&gt; of the most derived class.</source>
          <target state="translated">1) &lt;code&gt;do_date_order&lt;/code&gt; функция-член, вызывает защищенную виртуальную функцию-член do_date_order самого производного класса.</target>
        </trans-unit>
        <trans-unit id="dc988aac8e2069c8157a164371668baa84732662" translate="yes" xml:space="preserve">
          <source>1) Public member function, calls the protected virtual member function &lt;code&gt;do_get&lt;/code&gt; of the most derived class.</source>
          <target state="translated">1) &lt;code&gt;do_get&lt;/code&gt; функция-член, вызывает защищенную виртуальную функцию-член do_get самого производного класса.</target>
        </trans-unit>
        <trans-unit id="e3956434b335523e445a7f66b881b7d9081d9286" translate="yes" xml:space="preserve">
          <source>1) Public member function, calls the protected virtual member function &lt;code&gt;do_get_date()&lt;/code&gt; of the most derived class.</source>
          <target state="translated">1) &lt;code&gt;do_get_date()&lt;/code&gt; функция-член, вызывает защищенную виртуальную функцию-член do_get_date () самого производного класса.</target>
        </trans-unit>
        <trans-unit id="aa8c3a179dd224f964496fd3cf87120527402883" translate="yes" xml:space="preserve">
          <source>1) Public member function, calls the protected virtual member function &lt;code&gt;do_hash&lt;/code&gt; of the most derived class.</source>
          <target state="translated">1) &lt;code&gt;do_hash&lt;/code&gt; функция-член, вызывает защищенную виртуальную функцию-член do_hash самого производного класса.</target>
        </trans-unit>
        <trans-unit id="f5b1e143ebb344d5c93a9cd3e3d5c1234ffeed9a" translate="yes" xml:space="preserve">
          <source>1) Public member function, calls the protected virtual member function &lt;code&gt;do_open&lt;/code&gt; of the most derived class.</source>
          <target state="translated">1) &lt;code&gt;do_open&lt;/code&gt; функция-член, вызывает защищенную виртуальную функцию-член do_open самого производного класса.</target>
        </trans-unit>
        <trans-unit id="c3021e1c4d5e1cb04a9c13b29e49851c5fc32a48" translate="yes" xml:space="preserve">
          <source>1) Public member function, calls the protected virtual member function &lt;code&gt;do_put&lt;/code&gt; of the most derived class.</source>
          <target state="translated">1) &lt;code&gt;do_put&lt;/code&gt; функция-член, вызывает защищенную виртуальную функцию-член do_put самого производного класса.</target>
        </trans-unit>
        <trans-unit id="02f297d72b24e5ec0b50eab50682c4aeb7a9ac16" translate="yes" xml:space="preserve">
          <source>1) Public member function, calls the protected virtual member function &lt;code&gt;do_transform&lt;/code&gt; of the most derived class.</source>
          <target state="translated">1) &lt;code&gt;do_transform&lt;/code&gt; функция-член, вызывает защищенную виртуальную функцию-член do_transform самого производного класса.</target>
        </trans-unit>
        <trans-unit id="8792ca5b24450313548e3eafb8702266f2eb881c" translate="yes" xml:space="preserve">
          <source>1) Reads one character and returns it if available. Otherwise, returns &lt;code&gt;Traits::eof()&lt;/code&gt; and sets &lt;code&gt;&lt;a href=&quot;../ios_base/iostate&quot;&gt;failbit&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../ios_base/iostate&quot;&gt;eofbit&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">1) Читает один символ и возвращает его, если доступно. В противном случае возвращает &lt;code&gt;Traits::eof()&lt;/code&gt; и устанавливает &lt;code&gt;&lt;a href=&quot;../ios_base/iostate&quot;&gt;failbit&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;../ios_base/iostate&quot;&gt;eofbit&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b24556d7aac836f48afb6674f5c717012f92f983" translate="yes" xml:space="preserve">
          <source>1) Reads the data from &lt;code&gt;&lt;a href=&quot;../c&quot;&gt;stdin&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">1) Читает данные из стандартного &lt;code&gt;&lt;a href=&quot;../c&quot;&gt;stdin&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7396d1f8b950a76b6370b58eb711a32d6d49c388" translate="yes" xml:space="preserve">
          <source>1) Reads the data from &lt;code&gt;&lt;a href=&quot;../c&quot;&gt;stdin&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">1) Читает данные из стандартного &lt;code&gt;&lt;a href=&quot;../c&quot;&gt;stdin&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6a217932442a1d0a2f62a838e385afc124dbe4bd" translate="yes" xml:space="preserve">
          <source>1) Refers to a &lt;code&gt;&lt;a href=&quot;../types/type_info&quot;&gt;std::type_info&lt;/a&gt;&lt;/code&gt; object representing the type type. If type is a reference type, the result refers to a &lt;code&gt;&lt;a href=&quot;../types/type_info&quot;&gt;std::type_info&lt;/a&gt;&lt;/code&gt; object representing the referenced type.</source>
          <target state="translated">1) Относится к объекту &lt;code&gt;&lt;a href=&quot;../types/type_info&quot;&gt;std::type_info&lt;/a&gt;&lt;/code&gt; представляющему тип. Если тип является ссылочным типом, результат ссылается на объект &lt;code&gt;&lt;a href=&quot;../types/type_info&quot;&gt;std::type_info&lt;/a&gt;&lt;/code&gt; представляющий ссылочный тип.</target>
        </trans-unit>
        <trans-unit id="861842b860dc887a6543ee6224b6ce48a8a61aa1" translate="yes" xml:space="preserve">
          <source>1) Regular function declarator syntax</source>
          <target state="translated">1)Синтаксис декларатора регулярных функций</target>
        </trans-unit>
        <trans-unit id="6cbbb4ec5d9adc038750b690542f0bc0dae8623a" translate="yes" xml:space="preserve">
          <source>1) Releases any shared state and assigns the contents of &lt;code&gt;other&lt;/code&gt; to &lt;code&gt;*this&lt;/code&gt;. After the assignment, &lt;code&gt;this-&amp;gt;valid() == other.valid()&lt;/code&gt;.</source>
          <target state="translated">1) Освобождает любое общее состояние и правопреемников содержимое &lt;code&gt;other&lt;/code&gt; в &lt;code&gt;*this&lt;/code&gt; . После назначения &lt;code&gt;this-&amp;gt;valid() == other.valid()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="38bb6282680f52e2fda17aa9983f1073eb7c0c47" translate="yes" xml:space="preserve">
          <source>1) Releases any shared state and move-assigns the contents of &lt;code&gt;other&lt;/code&gt; to &lt;code&gt;*this&lt;/code&gt;. After the assignment, &lt;code&gt;other.valid() == false&lt;/code&gt; and &lt;a href=&quot;valid&quot;&gt;&lt;code&gt;this-&amp;gt;valid()&lt;/code&gt;&lt;/a&gt; will yield the same value as &lt;code&gt;other.valid()&lt;/code&gt; before the assignment.</source>
          <target state="translated">1) выпускает какое - либо общее государственное и перемещение присваивает содержимое &lt;code&gt;other&lt;/code&gt; , чтобы &lt;code&gt;*this&lt;/code&gt; . После присваивания &lt;code&gt;other.valid() == false&lt;/code&gt; и &lt;a href=&quot;valid&quot;&gt; &lt;code&gt;this-&amp;gt;valid()&lt;/code&gt; &lt;/a&gt; приведут к тому же значению, что и &lt;code&gt;other.valid()&lt;/code&gt; перед присваиванием.</target>
        </trans-unit>
        <trans-unit id="b5b667ade567f1b29b3c27fd07f95ac68433c004" translate="yes" xml:space="preserve">
          <source>1) Releases the ownership of the managed object, if any. After the call, &lt;code&gt;*this&lt;/code&gt; manages no object. Equivalent to &lt;code&gt;shared_ptr().swap(*this);&lt;/code&gt;</source>
          <target state="translated">1) Освобождает владельца управляемого объекта, если таковой имеется. После вызова &lt;code&gt;*this&lt;/code&gt; управляет объектом. Эквивалентен &lt;code&gt;shared_ptr().swap(*this);&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="058dae359c875bb8aea961ac9a8c89d60ef65185" translate="yes" xml:space="preserve">
          <source>1) Removes</source>
          <target state="translated">1)Удаления</target>
        </trans-unit>
        <trans-unit id="8c4e68b9d2c4305008d048fc061e3772b5809315" translate="yes" xml:space="preserve">
          <source>1) Removes all elements that are equal to &lt;code&gt;value&lt;/code&gt;.</source>
          <target state="translated">1) Удаляет все элементы, которые равны &lt;code&gt;value&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="869efa782ed2427565d277c2e6014424441dd053" translate="yes" xml:space="preserve">
          <source>1) Removes the element at &lt;code&gt;pos&lt;/code&gt;.</source>
          <target state="translated">1) Удаляет элемент в &lt;code&gt;pos&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ffec9f7979d764e0359835e77f17747b23d8b2dd" translate="yes" xml:space="preserve">
          <source>1) Removes the element following &lt;code&gt;pos&lt;/code&gt;.</source>
          <target state="translated">1) Удаляет элемент, следующий за &lt;code&gt;pos&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="17ef257965eb0ab3b49b26ba1ea702b626c6aa3f" translate="yes" xml:space="preserve">
          <source>1) Reorders the elements in the range &lt;code&gt;[first, last)&lt;/code&gt; in such a way that all elements for which the predicate &lt;code&gt;p&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt; precede the elements for which predicate &lt;code&gt;p&lt;/code&gt; returns &lt;code&gt;false&lt;/code&gt;. Relative order of the elements is not preserved.</source>
          <target state="translated">1) Переупорядочивает элементы в диапазоне &lt;code&gt;[first, last)&lt;/code&gt; таким образом, что все элементы, для которых предикат &lt;code&gt;p&lt;/code&gt; возвращает &lt;code&gt;true&lt;/code&gt; , предшествуют элементам, для которых предикат &lt;code&gt;p&lt;/code&gt; возвращает &lt;code&gt;false&lt;/code&gt; . Относительный порядок элементов не сохраняется.</target>
        </trans-unit>
        <trans-unit id="adce2245dd094ab71b482b217c791cf528174e3e" translate="yes" xml:space="preserve">
          <source>1) Reorders the elements in the range &lt;code&gt;[first, last)&lt;/code&gt; in such a way that all elements for which the predicate &lt;code&gt;p&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt; precede the elements for which predicate &lt;code&gt;p&lt;/code&gt; returns &lt;code&gt;false&lt;/code&gt;. Relative order of the elements is preserved.</source>
          <target state="translated">1) Переупорядочивает элементы в диапазоне &lt;code&gt;[first, last)&lt;/code&gt; таким образом, что все элементы, для которых предикат &lt;code&gt;p&lt;/code&gt; возвращает &lt;code&gt;true&lt;/code&gt; , предшествуют элементам, для которых предикат &lt;code&gt;p&lt;/code&gt; возвращает &lt;code&gt;false&lt;/code&gt; . Относительный порядок элементов сохраняется.</target>
        </trans-unit>
        <trans-unit id="2dac5da3d02f4d437123f2a0b9d56eb2e4fd0857" translate="yes" xml:space="preserve">
          <source>1) Replaces all elements that are equal to &lt;code&gt;old_value&lt;/code&gt;.</source>
          <target state="translated">1) Заменяет все элементы, которые равны &lt;code&gt;old_value&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2e3318a609e82a644898d7222b1da6b96eacbe12" translate="yes" xml:space="preserve">
          <source>1) Replaces the contents of &lt;code&gt;*this&lt;/code&gt; with a pathname whose both native and generic format representations equal those of &lt;code&gt;p&lt;/code&gt;.</source>
          <target state="translated">1) Заменяет содержимое &lt;code&gt;*this&lt;/code&gt; на путь, чьи представления как в собственном, так и в общем формате совпадают &lt;code&gt;p&lt;/code&gt; представлениями из p .</target>
        </trans-unit>
        <trans-unit id="e240befa148e0203cedd59eee5956df5acad945f" translate="yes" xml:space="preserve">
          <source>1) Replaces the contents with &lt;code&gt;count&lt;/code&gt; copies of character &lt;code&gt;ch&lt;/code&gt;.</source>
          <target state="translated">1) Заменяет содержимое на &lt;code&gt;count&lt;/code&gt; копий символа &lt;code&gt;ch&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a6b05f959c13293d5a5d5af2a8637f634e41da89" translate="yes" xml:space="preserve">
          <source>1) Replaces the contents with &lt;code&gt;count&lt;/code&gt; copies of value &lt;code&gt;value&lt;/code&gt;</source>
          <target state="translated">1) Заменяет содержимое с &lt;code&gt;count&lt;/code&gt; копий значения &lt;code&gt;value&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="29d8d55620552a2c6832d320259ce67308463212" translate="yes" xml:space="preserve">
          <source>1) Replaces the contents with a copy of &lt;code&gt;str&lt;/code&gt;. If &lt;code&gt;*this&lt;/code&gt; and &lt;code&gt;str&lt;/code&gt; are the same object, this function has no effect.</source>
          <target state="translated">1) Заменяет содержимое на копию &lt;code&gt;str&lt;/code&gt; . Если &lt;code&gt;*this&lt;/code&gt; и &lt;code&gt;str&lt;/code&gt; - один и тот же объект, эта функция не действует.</target>
        </trans-unit>
        <trans-unit id="270b4bf667b635c284aba5086d9e163a6e0904f5" translate="yes" xml:space="preserve">
          <source>1) Results in &lt;code&gt;container-&amp;gt;push_back(value)&lt;/code&gt;</source>
          <target state="translated">1) Результаты в &lt;code&gt;container-&amp;gt;push_back(value)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="40ecaa5e7b5b215ddbaec386d81fbe27a35ad522" translate="yes" xml:space="preserve">
          <source>1) Results in &lt;code&gt;container-&amp;gt;push_front(value)&lt;/code&gt;</source>
          <target state="translated">1) Результаты в &lt;code&gt;container-&amp;gt;push_front(value)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8712ae4fa015816336c007fe3a9a6dcf1cb77223" translate="yes" xml:space="preserve">
          <source>1) Results in &lt;code&gt;iter = container-&amp;gt;insert(iter, value); ++iter;&lt;/code&gt;</source>
          <target state="translated">1) Результат в &lt;code&gt;iter = container-&amp;gt;insert(iter, value); ++iter;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="65e2795a9414bee5546a758244d76abfed9cefbf" translate="yes" xml:space="preserve">
          <source>1) Returns &lt;code&gt;*lhs.resource() == *rhs.resource()&lt;/code&gt;</source>
          <target state="translated">1) Возвращает &lt;code&gt;*lhs.resource() == *rhs.resource()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2502d83ce08382fe677e2911a3d1cccaddcc99f3" translate="yes" xml:space="preserve">
          <source>1) Returns &lt;code&gt;*this&lt;/code&gt; converted to &lt;a href=&quot;../path&quot;&gt;normal form&lt;/a&gt; in its generic format</source>
          <target state="translated">1) Возвращает &lt;code&gt;*this&lt;/code&gt; преобразовано в &lt;a href=&quot;../path&quot;&gt;обычную форму&lt;/a&gt; в его общем формате</target>
        </trans-unit>
        <trans-unit id="3a923a689d5fab3840318f3d549827b3318bcbf5" translate="yes" xml:space="preserve">
          <source>1) Returns &lt;code&gt;iter&lt;/code&gt; unchanged</source>
          <target state="translated">1) Возвращает &lt;code&gt;iter&lt;/code&gt; без изменений</target>
        </trans-unit>
        <trans-unit id="b92bef1e9a732e0b29effd33edcabf38014c435d" translate="yes" xml:space="preserve">
          <source>1) Returns &lt;code&gt;relative(p, current_path(), ec)&lt;/code&gt;</source>
          <target state="translated">1) Возвращает &lt;code&gt;relative(p, current_path(), ec)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5de64d91bbdbee0c01c0e8e9cb2b99b1df930700" translate="yes" xml:space="preserve">
          <source>1) Returns &lt;code&gt;true&lt;/code&gt;</source>
          <target state="translated">1) возвращает &lt;code&gt;true&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a484b37cffb98b770d8354adcf0625dcd7c1759e" translate="yes" xml:space="preserve">
          <source>1) Returns &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;*this&lt;/code&gt; and &lt;code&gt;rhs&lt;/code&gt; are both end-of-sequence iterators, or if all of the following conditions are true:</source>
          <target state="translated">1) Возвращает &lt;code&gt;true&lt;/code&gt; , если &lt;code&gt;*this&lt;/code&gt; и &lt;code&gt;rhs&lt;/code&gt; оба являются итераторами конца последовательности, или если выполняются все следующие условия:</target>
        </trans-unit>
        <trans-unit id="56de7954cc2d00b655ce1ec3c457bb6134e5cbf3" translate="yes" xml:space="preserve">
          <source>1) Returns &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;lhs&lt;/code&gt; and &lt;code&gt;rhs&lt;/code&gt; are equal, &lt;code&gt;false&lt;/code&gt; otherwise.</source>
          <target state="translated">1) Возвращает &lt;code&gt;true&lt;/code&gt; , если &lt;code&gt;lhs&lt;/code&gt; и &lt;code&gt;rhs&lt;/code&gt; равны, иначе &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c94da87dbdee081478fa1d7dee357f47bd78ed41" translate="yes" xml:space="preserve">
          <source>1) Returns &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;lhs&lt;/code&gt; is</source>
          <target state="translated">1) Возвращает &lt;code&gt;true&lt;/code&gt; если &lt;code&gt;lhs&lt;/code&gt; является</target>
        </trans-unit>
        <trans-unit id="7fac7f5450d225457e6b78589c98f2513f4014ce" translate="yes" xml:space="preserve">
          <source>1) Returns &lt;code&gt;true&lt;/code&gt; if all elements in the range &lt;code&gt;[first, last)&lt;/code&gt; that satisfy the predicate &lt;code&gt;p&lt;/code&gt; appear before all elements that don't. Also returns &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;[first, last)&lt;/code&gt; is empty.</source>
          <target state="translated">1) Возвращает &lt;code&gt;true&lt;/code&gt; , если все элементы в диапазоне &lt;code&gt;[first, last)&lt;/code&gt; которые удовлетворяют предикату &lt;code&gt;p&lt;/code&gt; , появляются перед всеми элементами, которые этого не делают. Также возвращает &lt;code&gt;true&lt;/code&gt; , если &lt;code&gt;[first, last)&lt;/code&gt; пусто.</target>
        </trans-unit>
        <trans-unit id="2aba12f91ced7a05bef1178e9c4fd5864add3fd6" translate="yes" xml:space="preserve">
          <source>1) Returns &lt;code&gt;true&lt;/code&gt; if lhs is less than rhs, &lt;code&gt;false&lt;/code&gt; otherwise.</source>
          <target state="translated">1) Возвращает &lt;code&gt;true&lt;/code&gt; , если lhs меньше rhs, в противном случае - &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8a60b75738d79d6ba929ed47e4bcd56cf5f07f4d" translate="yes" xml:space="preserve">
          <source>1) Returns a &lt;code&gt;bitset&amp;lt;N&amp;gt;&lt;/code&gt; containing the result of binary AND on corresponding pairs of bits of &lt;code&gt;lhs&lt;/code&gt; and &lt;code&gt;rhs&lt;/code&gt;.</source>
          <target state="translated">1) Возвращает набор &lt;code&gt;bitset&amp;lt;N&amp;gt;&lt;/code&gt; содержащий результат двоичного И для соответствующих пар битов &lt;code&gt;lhs&lt;/code&gt; и &lt;code&gt;rhs&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e56d712102c4d0fe2dae24e3b57a4a8cfd5aa505" translate="yes" xml:space="preserve">
          <source>1) Returns a copy of &lt;code&gt;*this&lt;/code&gt;.</source>
          <target state="translated">1) Возвращает копию &lt;code&gt;*this&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ca096d06281ae150d54482a6cc1e549ce108c224" translate="yes" xml:space="preserve">
          <source>1) Returns a copy of the underlying string as if by calling &lt;code&gt;rdbuf()-&amp;gt;str()&lt;/code&gt;.</source>
          <target state="translated">1) Возвращает копию базовой строки, как будто вызывая &lt;code&gt;rdbuf()-&amp;gt;str()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a1c616be8d7e9418723ddfcbc3e52606258ec3df" translate="yes" xml:space="preserve">
          <source>1) Returns a null pointer if &lt;code&gt;fail()&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt;, otherwise returns a non-null pointer. This pointer is implicitly convertible to &lt;code&gt;bool&lt;/code&gt; and may be used in boolean contexts.</source>
          <target state="translated">1) Возвращает нулевой указатель, если &lt;code&gt;fail()&lt;/code&gt; возвращает &lt;code&gt;true&lt;/code&gt; , в противном случае возвращает ненулевой указатель. Этот указатель неявно конвертируется в &lt;code&gt;bool&lt;/code&gt; и может использоваться в логических контекстах.</target>
        </trans-unit>
        <trans-unit id="c2284f1e367243c98935f80fc109c83a94a54f3c" translate="yes" xml:space="preserve">
          <source>1) Returns a numeric array of &lt;code&gt;bool&lt;/code&gt; containing elements each of which is obtained by applying the indicated comparison operator to the corresponding values of &lt;code&gt;lhs&lt;/code&gt; and &lt;code&gt;rhs&lt;/code&gt;</source>
          <target state="translated">1) Возвращает числовой массив элементов &lt;code&gt;bool&lt;/code&gt; , каждый из которых получен путем применения указанного оператора сравнения к соответствующим значениям &lt;code&gt;lhs&lt;/code&gt; и &lt;code&gt;rhs&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3100a3df15f07b6e5ef0d2e827ee2f7cdbf6175d" translate="yes" xml:space="preserve">
          <source>1) Returns a pointer to the contained value.</source>
          <target state="translated">1)Возвращает указатель на содержащееся в нем значение.</target>
        </trans-unit>
        <trans-unit id="0d2c31549336b964b7be2eb179a144f92cc116bc" translate="yes" xml:space="preserve">
          <source>1) Returns a possibly const-qualified iterator to the reverse-beginning of the container &lt;code&gt;c&lt;/code&gt;.</source>
          <target state="translated">1) Возвращает возможный константный итератор в обратное начало контейнера &lt;code&gt;c&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7a063c1b9ad5e32ce34dcdfd8ca4b82cf3c236ca" translate="yes" xml:space="preserve">
          <source>1) Returns a possibly const-qualified iterator to the reverse-end of the container &lt;code&gt;c&lt;/code&gt;.</source>
          <target state="translated">1) Возвращает, возможно, константный итератор обратному концу контейнера &lt;code&gt;c&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="13631d6a37bc7ed73ea92514ab164c6764fc704e" translate="yes" xml:space="preserve">
          <source>1) Returns a reference to the current &lt;code&gt;&lt;a href=&quot;../match_results&quot;&gt;std::match_results&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">1) Возвращает ссылку на текущий &lt;code&gt;&lt;a href=&quot;../match_results&quot;&gt;std::match_results&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f3b6280f71abf114f54373c3e7590153910cd5d6" translate="yes" xml:space="preserve">
          <source>1) Returns a reference to the global &lt;code&gt;std::chrono::tzdb_list&lt;/code&gt; singleton. If this is the first access to the database, initialize the database. After the initialization, the database will hold a single initialized &lt;code&gt;std::chrono::tzdb&lt;/code&gt; object. This function is thread-safe: concurrent calls to this function from multiple threads do not introduce a data race.</source>
          <target state="translated">1) Возвращает ссылку на глобальный синглтон &lt;code&gt;std::chrono::tzdb_list&lt;/code&gt; . Если это первый доступ к базе данных, инициализируйте базу данных. После инициализации база данных будет содержать один инициализированный объект &lt;code&gt;std::chrono::tzdb&lt;/code&gt; . Эта функция является поточно-ориентированной: одновременные вызовы этой функции из нескольких потоков не создают гонки данных</target>
        </trans-unit>
        <trans-unit id="a81e180b9a39b86ed42f18915e1912a4b70010f8" translate="yes" xml:space="preserve">
          <source>1) Returns an implementation-defined type that holds a reference to &lt;code&gt;*this&lt;/code&gt;. &lt;code&gt;&lt;a href=&quot;../auto_ptr&quot;&gt;std::auto_ptr&lt;/a&gt;&lt;/code&gt; is &lt;a href=&quot;auto_ptr&quot;&gt;convertible&lt;/a&gt; and &lt;a href=&quot;operator=&quot;&gt;assignable&lt;/a&gt; from this template. The implementation is allowed to provide the template with a different name or implement equivalent functionality in other ways.</source>
          <target state="translated">1) Возвращает определенный реализацией тип, который содержит ссылку на &lt;code&gt;*this&lt;/code&gt; . &lt;code&gt;&lt;a href=&quot;../auto_ptr&quot;&gt;std::auto_ptr&lt;/a&gt;&lt;/code&gt; можно &lt;a href=&quot;auto_ptr&quot;&gt;преобразовать&lt;/a&gt; и &lt;a href=&quot;operator=&quot;&gt;назначить&lt;/a&gt; из этого шаблона. Реализация может предоставлять шаблону другое имя или реализовывать эквивалентную функциональность другими способами.</target>
        </trans-unit>
        <trans-unit id="1ed78a0dd559758ebfb9c2949e5a988bace3ce62" translate="yes" xml:space="preserve">
          <source>1) Returns an iterator pointing to the first element that is</source>
          <target state="translated">1)Возвращает итератор,указывающий на первый элемент,которым является</target>
        </trans-unit>
        <trans-unit id="6844338cdc96e911c46728c0c867f432dd1a50ec" translate="yes" xml:space="preserve">
          <source>1) Returns an iterator to the first character of the view. Equivalent to &lt;code&gt;sv.begin()&lt;/code&gt;.</source>
          <target state="translated">1) Возвращает итератор к первому символу представления. Эквивалент &lt;code&gt;sv.begin()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6cd397aaa829398a2797783162cadf8568d17dba" translate="yes" xml:space="preserve">
          <source>1) Returns an iterator to the first element of the path. If the path is empty, the returned iterator is equal to &lt;code&gt;end()&lt;/code&gt;.</source>
          <target state="translated">1) Возвращает итератор к первому элементу пути. Если путь пуст, возвращаемый итератор равен &lt;code&gt;end()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cbc84a634be5255d1d6be17b5b6cfff82d9198c3" translate="yes" xml:space="preserve">
          <source>1) Returns an iterator to the first element of the span. Equivalent to &lt;code&gt;s.begin()&lt;/code&gt;.</source>
          <target state="translated">1) Возвращает итератор к первому элементу диапазона. Эквивалент &lt;code&gt;s.begin()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="964e9b36a5abe52ebf725814fc0423c129fbe227" translate="yes" xml:space="preserve">
          <source>1) Returns current maximum load factor.</source>
          <target state="translated">1)Возвращает коэффициент максимальной нагрузки по току.</target>
        </trans-unit>
        <trans-unit id="cc6b701735443a9096b6e72058c3c17fa0eb40fd" translate="yes" xml:space="preserve">
          <source>1) Returns exactly &lt;code&gt;c.begin()&lt;/code&gt;, which is typically an iterator to the beginning of the sequence represented by &lt;code&gt;c&lt;/code&gt;. If &lt;code&gt;C&lt;/code&gt; is a standard &lt;a href=&quot;../named_req/container&quot;&gt;Container&lt;/a&gt;, this returns &lt;code&gt;C::iterator&lt;/code&gt; when &lt;code&gt;c&lt;/code&gt; is not const-qualified, and &lt;code&gt;C::const_iterator&lt;/code&gt; otherwise.</source>
          <target state="translated">1) Возвращает ровно &lt;code&gt;c.begin()&lt;/code&gt; , который обычно является итератором в начале последовательности, представленной &lt;code&gt;c&lt;/code&gt; . Если &lt;code&gt;C&lt;/code&gt; является стандартным &lt;a href=&quot;../named_req/container&quot;&gt;контейнером&lt;/a&gt; , это возвращает &lt;code&gt;C::iterator&lt;/code&gt; когда &lt;code&gt;c&lt;/code&gt; не является const-квалифицированным, и &lt;code&gt;C::const_iterator&lt;/code&gt; противном случае.</target>
        </trans-unit>
        <trans-unit id="c8e94140f9ef40bf1d36874da1c9ebca27cad214" translate="yes" xml:space="preserve">
          <source>1) Returns exactly &lt;code&gt;c.end()&lt;/code&gt;, which is typically an iterator one past the end of the sequence represented by &lt;code&gt;c&lt;/code&gt;. If &lt;code&gt;C&lt;/code&gt; is a standard &lt;a href=&quot;../named_req/container&quot;&gt;Container&lt;/a&gt;, this returns a &lt;code&gt;C::iterator&lt;/code&gt; when &lt;code&gt;c&lt;/code&gt; is not const-qualified, and a &lt;code&gt;C::const_iterator&lt;/code&gt; otherwise.</source>
          <target state="translated">1) Возвращает ровно &lt;code&gt;c.end()&lt;/code&gt; , который обычно является итератором за концом последовательности, представленной &lt;code&gt;c&lt;/code&gt; . Если &lt;code&gt;C&lt;/code&gt; является стандартным &lt;a href=&quot;../named_req/container&quot;&gt;контейнером&lt;/a&gt; , это возвращает &lt;code&gt;C::iterator&lt;/code&gt; когда &lt;code&gt;c&lt;/code&gt; не является const-квалифицированным, и &lt;code&gt;C::const_iterator&lt;/code&gt; противном случае.</target>
        </trans-unit>
        <trans-unit id="d2d79bb6bfb415bc4799cd03340ea976f5e1ad4e" translate="yes" xml:space="preserve">
          <source>1) Returns file permissions information.</source>
          <target state="translated">1)Возвращает информацию о разрешениях на использование файлов.</target>
        </trans-unit>
        <trans-unit id="ca8cb5bb5515d3f764ff15bb64205d48c54ff968" translate="yes" xml:space="preserve">
          <source>1) Returns file type information.</source>
          <target state="translated">1)Возвращает информацию о типе файла.</target>
        </trans-unit>
        <trans-unit id="cbec588b4dae3ad630f2f6af2e54b55a2be244d6" translate="yes" xml:space="preserve">
          <source>1) Returns status of the entry, as if determined by a &lt;a href=&quot;../status&quot;&gt;status&lt;/a&gt; call (symlinks are followed to their targets)</source>
          <target state="translated">1) Возвращает статус записи, как если бы она определялась вызовом &lt;a href=&quot;../status&quot;&gt;состояния&lt;/a&gt; (символические ссылки следуют к своим целям)</target>
        </trans-unit>
        <trans-unit id="292239ac393513bb2a73e81850757d26b7552c99" translate="yes" xml:space="preserve">
          <source>1) Returns the</source>
          <target state="translated">1)Возвращает</target>
        </trans-unit>
        <trans-unit id="0fb0365146c39ac72ff8fc5a9c4e8c203a48497d" translate="yes" xml:space="preserve">
          <source>1) Returns the &amp;alpha; distribution parameter. It is also known as the shape parameter. The default value is &lt;code&gt;1.0&lt;/code&gt;.</source>
          <target state="translated">1) Возвращает параметр распределения &amp;alpha;. Он также известен как параметр формы. Значением по умолчанию является &lt;code&gt;1.0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="21227b553d58a19b72f0fe801e0f03bd0a1049b3" translate="yes" xml:space="preserve">
          <source>1) Returns the a distribution parameter (location). The default value is &lt;code&gt;1.0&lt;/code&gt;.</source>
          <target state="translated">1) Возвращает параметр распределения (местоположение). Значением по умолчанию является &lt;code&gt;1.0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="143347fc7ff8e780591f1e29b03e2d7669e75b6f" translate="yes" xml:space="preserve">
          <source>1) Returns the a parameter. It defines the shape of the distribution. The default value is &lt;code&gt;1.0&lt;/code&gt;.</source>
          <target state="translated">1) Возвращает параметр. Он определяет форму распределения. Значением по умолчанию является &lt;code&gt;1.0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a2d1f91a5f400fc1fd6adcb1746a21b04fe35b6f" translate="yes" xml:space="preserve">
          <source>1) Returns the associated parameter set.</source>
          <target state="translated">1)Возвращает соответствующий набор параметров.</target>
        </trans-unit>
        <trans-unit id="a15f06fffff72065df3b268612d6a17f5310aa58" translate="yes" xml:space="preserve">
          <source>1) Returns the associated stream buffer. If there is no associated stream buffer, returns a null pointer.</source>
          <target state="translated">1)Возвращает ассоциированный буфер потока.Если буфер ассоциированного потока отсутствует,возвращает нулевой указатель.</target>
        </trans-unit>
        <trans-unit id="22cd7377868adb410066182a3c8def7ed5f1fa07" translate="yes" xml:space="preserve">
          <source>1) Returns the current field width.</source>
          <target state="translated">1)Возвращает текущую ширину поля.</target>
        </trans-unit>
        <trans-unit id="f41a7bceca1233658cedea4989b3de36c56d029f" translate="yes" xml:space="preserve">
          <source>1) Returns the current precision.</source>
          <target state="translated">1)Возвращает текущую точность.</target>
        </trans-unit>
        <trans-unit id="001731be05f0e739b1a39d0921456a3adf786c45" translate="yes" xml:space="preserve">
          <source>1) Returns the current tied stream. If there is no tied stream, a null pointer is returned.</source>
          <target state="translated">1)Возвращает текущий связанный поток.Если нет привязанного потока,возвращается нулевой указатель.</target>
        </trans-unit>
        <trans-unit id="5acdce3496544fa0bd7b2c030f8bf1d9c5f72571" translate="yes" xml:space="preserve">
          <source>1) Returns the exception mask.</source>
          <target state="translated">1)Возвращает маску исключения.</target>
        </trans-unit>
        <trans-unit id="1694f8d96fa622b3f17ae9121b869a1b0312a6ef" translate="yes" xml:space="preserve">
          <source>1) Returns the imaginary component of the complex number &lt;code&gt;z&lt;/code&gt;, i.e. &lt;code&gt;z.imag()&lt;/code&gt;.</source>
          <target state="translated">1) Возвращает мнимую составляющую комплексного числа &lt;code&gt;z&lt;/code&gt; , т.е. &lt;code&gt;z.imag()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="49125a8b6077342f10be4d243d2ed33fbfe22de1" translate="yes" xml:space="preserve">
          <source>1) Returns the imaginary part.</source>
          <target state="translated">1)Возвращает воображаемую часть.</target>
        </trans-unit>
        <trans-unit id="af75cb25c63821285d34593afc3031d58d00ddf9" translate="yes" xml:space="preserve">
          <source>1) Returns the list of boundaries of the intervals.</source>
          <target state="translated">1)Возвращает список границ интервалов.</target>
        </trans-unit>
        <trans-unit id="4c3aa7a255032d162e6721d758482183c8e0d4e5" translate="yes" xml:space="preserve">
          <source>1) Returns the log-mean m distribution parameter. It defines the location of the peak. The default value is &lt;code&gt;0.0&lt;/code&gt;.</source>
          <target state="translated">1) Возвращает логарифмический параметр распределения m. Это определяет местоположение вершины. Значением по умолчанию является &lt;code&gt;0.0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cb15710c8fbb6d1b45fb72076cb13894fb56f750" translate="yes" xml:space="preserve">
          <source>1) Returns the m (the first degree of freedom) distribution parameter. The default value is &lt;code&gt;1.0&lt;/code&gt;.</source>
          <target state="translated">1) Возвращает параметр распределения m (первая степень свободы). Значением по умолчанию является &lt;code&gt;1.0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="12bbddb8b9d6e0fbda5e7775b18ff17adbbacb80" translate="yes" xml:space="preserve">
          <source>1) Returns the mean &amp;mu; distribution parameter. The mean specifies the location of the peak. The default value is &lt;code&gt;0.0&lt;/code&gt;.</source>
          <target state="translated">1) Возвращает средний параметр распределения &amp;mu;. Среднее указывает местоположение пика. Значением по умолчанию является &lt;code&gt;0.0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="47a018754522c2f9b7cd2238570b2ebdebe1376b" translate="yes" xml:space="preserve">
          <source>1) Returns the number of elements with key &lt;code&gt;key&lt;/code&gt;.</source>
          <target state="translated">1) Возвращает количество элементов с ключом &lt;code&gt;key&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4307f7beb5cbf30b6fd034cf152d44ddfc23058a" translate="yes" xml:space="preserve">
          <source>1) Returns the number of elements with key that compares equal to the specified argument &lt;code&gt;key&lt;/code&gt;, which is either 1 or 0 since this container does not allow duplicates.</source>
          <target state="translated">1) Возвращает количество элементов с ключом, которое сравнивается с указанным &lt;code&gt;key&lt;/code&gt; аргумента , равным 1 или 0, так как этот контейнер не допускает дублирования.</target>
        </trans-unit>
        <trans-unit id="eb9b09c24f4dd3756959d45d14cfe7322d3d6eb0" translate="yes" xml:space="preserve">
          <source>1) Returns the number of elements with key that compares equal to the specified argument &lt;code&gt;key&lt;/code&gt;.</source>
          <target state="translated">1) Возвращает количество элементов с ключом, которое сравнивается равным указанному аргументу &lt;code&gt;key&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d0b0dd6464e410f3559cc88a021648404b61cfba" translate="yes" xml:space="preserve">
          <source>1) Returns the object owned by &lt;code&gt;*this&lt;/code&gt;, equivalent to &lt;code&gt;*get()&lt;/code&gt;.</source>
          <target state="translated">1) Возвращает объект, принадлежащий &lt;code&gt;*this&lt;/code&gt; , эквивалентно &lt;code&gt;*get()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="efadb8f443ff52a8a06ff3cca490584c99089f22" translate="yes" xml:space="preserve">
          <source>1) Returns the p distribution parameter. It defines the probability of a trial generating &lt;code&gt;true&lt;/code&gt;. The default value is &lt;code&gt;0.5&lt;/code&gt;.</source>
          <target state="translated">1) Возвращает параметр распределения p. Это определяет вероятность того, что испытание породит &lt;code&gt;true&lt;/code&gt; . Значение по умолчанию составляет &lt;code&gt;0.5&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="06ea4503952409f3d220d8a31ac2c3d9a0b87e8b" translate="yes" xml:space="preserve">
          <source>1) Returns the pointer to the beginning (&quot;base&quot;) of the put area.</source>
          <target state="translated">1)Возвращает указатель на начало (&quot;основание&quot;)области ввода.</target>
        </trans-unit>
        <trans-unit id="d711b398059e09252c735c5b767a6c4f3b8c2d28" translate="yes" xml:space="preserve">
          <source>1) Returns the pointer to the beginning of the get area.</source>
          <target state="translated">1)Возвращает указатель на начало области получения.</target>
        </trans-unit>
        <trans-unit id="81b834f0d5a61937ab85cb95196e573fab4dbf45" translate="yes" xml:space="preserve">
          <source>1) Returns the real component of the complex number &lt;code&gt;z&lt;/code&gt;, i.e. &lt;code&gt;z.real()&lt;/code&gt;.</source>
          <target state="translated">1) Возвращает вещественную составляющую комплексного числа &lt;code&gt;z&lt;/code&gt; , т.е. &lt;code&gt;z.real()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="088dec1497a550df9243695c3279f03c8fb7947b" translate="yes" xml:space="preserve">
          <source>1) Returns the real part.</source>
          <target state="translated">1)Возвращает настоящую часть.</target>
        </trans-unit>
        <trans-unit id="8f3e1ba68c1324385714f799b9c29d179d2e6b88" translate="yes" xml:space="preserve">
          <source>1) Returns the squared magnitude of the complex number &lt;code&gt;z&lt;/code&gt;.</source>
          <target state="translated">1) Возвращает квадратную величину комплексного числа &lt;code&gt;z&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c70906930f9cd42e8f972b6ea9d3588d75bb9758" translate="yes" xml:space="preserve">
          <source>1) Returns the stored &lt;code&gt;std::chrono::month&lt;/code&gt; value.</source>
          <target state="translated">1) Возвращает сохраненное значение &lt;code&gt;std::chrono::month&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ce5d3c03147c08fafbfcc97025b8268f78f5aaea" translate="yes" xml:space="preserve">
          <source>1) Returns the stored &lt;code&gt;std::chrono::year&lt;/code&gt; value.</source>
          <target state="translated">1) Возвращает сохраненное значение &lt;code&gt;std::chrono::year&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="61dadd5c36bffe5a48255156199fa6c44fd84e1d" translate="yes" xml:space="preserve">
          <source>1) Returns the time of the last modification of &lt;code&gt;p&lt;/code&gt;, determined as if by accessing the member &lt;code&gt;st_mtime&lt;/code&gt; of the POSIX &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/stat.html&quot;&gt;stat&lt;/a&gt; (symlinks are followed) The non-throwing overload returns &lt;code&gt;file_time_type::min()&lt;/code&gt; on errors.</source>
          <target state="translated">1) Возвращает время последней модификации &lt;code&gt;p&lt;/code&gt; , определяется как если бы при обращении к членам &lt;code&gt;st_mtime&lt;/code&gt; в POSIX &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/stat.html&quot;&gt;стата&lt;/a&gt; (символьные ссылки следуют) В не-метание возвращает перегрузки &lt;code&gt;file_time_type::min()&lt;/code&gt; на наличие ошибок.</target>
        </trans-unit>
        <trans-unit id="2941cfcccb903d8c412b126eb85c8fa8bc0af6f7" translate="yes" xml:space="preserve">
          <source>1) Returns the time of the last modification of &lt;code&gt;p&lt;/code&gt;, determined as if by accessing the member &lt;code&gt;st_mtime&lt;/code&gt; of the POSIX &lt;a href=&quot;https://pubs.opengroup.org/onlinepubs/9699919799/functions/stat.html&quot;&gt;stat&lt;/a&gt; (symlinks are followed) The non-throwing overload returns &lt;code&gt;file_time_type::min()&lt;/code&gt; on errors.</source>
          <target state="translated">1) Возвращает время последней модификации &lt;code&gt;p&lt;/code&gt; , определяемое, как если бы при доступе к члену &lt;code&gt;st_mtime&lt;/code&gt; POSIX &lt;a href=&quot;https://pubs.opengroup.org/onlinepubs/9699919799/functions/stat.html&quot;&gt;stat&lt;/a&gt; (следуют символические ссылки ). Не &lt;code&gt;file_time_type::min()&lt;/code&gt; перегрузка возвращает file_time_type :: min () при ошибках.</target>
        </trans-unit>
        <trans-unit id="aa97c65b799f5efb0b02504a22a02ad70a88e318" translate="yes" xml:space="preserve">
          <source>1) Returns the value of its argument</source>
          <target state="translated">1)Возвращает значение своего аргумента</target>
        </trans-unit>
        <trans-unit id="533e65d4cbce1169e96cd03deb423e1ebed9ef4f" translate="yes" xml:space="preserve">
          <source>1) Returns the value of the file position state</source>
          <target state="translated">1)Возвращает значение состояния позиции файла</target>
        </trans-unit>
        <trans-unit id="8bd1eba1fbdf89c5698365e7fe91902373d9c621" translate="yes" xml:space="preserve">
          <source>1) Returns true if all of the bits in &lt;code&gt;*this&lt;/code&gt; and &lt;code&gt;rhs&lt;/code&gt; are equal.</source>
          <target state="translated">1) Возвращает true, если все биты в &lt;code&gt;*this&lt;/code&gt; и &lt;code&gt;rhs&lt;/code&gt; равны.</target>
        </trans-unit>
        <trans-unit id="998c1c493c58a67ce9bb205f050c7dbaf76aed9b" translate="yes" xml:space="preserve">
          <source>1) Reverses the order of the elements in the range &lt;code&gt;[first, last)&lt;/code&gt;</source>
          <target state="translated">1) Меняет порядок элементов в диапазоне &lt;code&gt;[first, last)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8d1ddbebd20349684cf4acb8ec8e6b2d4f4d96e9" translate="yes" xml:space="preserve">
          <source>1) Same as &lt;a href=&quot;iterator_t&quot;&gt;&lt;code&gt;ranges::iterator_t&lt;/code&gt;&lt;/a&gt; when &lt;code&gt;R&lt;/code&gt; models exposition-only concept &lt;a href=&quot;range&quot;&gt;&lt;code&gt;__ForwardingRange&lt;/code&gt;&lt;/a&gt;, otherwise yields &lt;a href=&quot;dangling&quot;&gt;&lt;code&gt;ranges::dangling&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">1) То же, что &lt;a href=&quot;range&quot;&gt; &lt;code&gt;__ForwardingRange&lt;/code&gt; &lt;/a&gt;&lt;a href=&quot;iterator_t&quot;&gt; &lt;code&gt;ranges::iterator_t&lt;/code&gt; &lt;/a&gt; когда &lt;code&gt;R&lt;/code&gt; моделирует концепцию &amp;laquo;только экспозиция&amp;raquo; __ForwardingRange , в противном случае вместо этого выдается range &lt;a href=&quot;dangling&quot;&gt; &lt;code&gt;ranges::dangling&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="14f30d52df1968fd80f273b59c9c1e7531df510b" translate="yes" xml:space="preserve">
          <source>1) Same as &lt;a href=&quot;noexcept_spec&quot;&gt;&lt;code&gt;noexcept(true)&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">1) То же, что и &lt;a href=&quot;noexcept_spec&quot;&gt; &lt;code&gt;noexcept(true)&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="4def597a1104c9ab9fae317a750663a62c536d96" translate="yes" xml:space="preserve">
          <source>1) Same as &lt;code&gt;noexcept&lt;/code&gt;&lt;code&gt;(&lt;/code&gt;&lt;code&gt;true&lt;/code&gt;&lt;code&gt;)&lt;/code&gt;</source>
          <target state="translated">1) То же, что и &lt;code&gt;noexcept&lt;/code&gt; &lt;code&gt;(&lt;/code&gt; &lt;code&gt;true&lt;/code&gt; &lt;code&gt;)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3c9b60d20817d9dc8664bdd29847776bc1e84582" translate="yes" xml:space="preserve">
          <source>1) Searches for the file in implementation-defined manner. The intent of this syntax is to search for the files under control of the implementation. Typical implementations search only standard include directories. The standard C++ library and the standard C library are implicitly included in these standard include directories. The standard include directories usually can be controlled by the user through compiler options.</source>
          <target state="translated">1)Поиск файла в режиме реализации.Целью данного синтаксиса является поиск файлов,находящихся под контролем реализации.Стандартный поиск реализаций включает в себя только каталоги.Стандартная библиотека C++и стандартная библиотека C неявно включаются в эти стандартные включаемые каталоги.Стандартные директории include обычно могут управляться пользователем с помощью опций компилятора.</target>
        </trans-unit>
        <trans-unit id="40b026d27109ca4160eaec8af9d9260a322193ab" translate="yes" xml:space="preserve">
          <source>1) Seeds the underlying engine with the default seed value. Effectively calls &lt;code&gt;e.seed()&lt;/code&gt;, where &lt;code&gt;e&lt;/code&gt; is the underlying engine.</source>
          <target state="translated">1) Заполняет базовый движок начальным значением по умолчанию. Эффективно вызывает &lt;code&gt;e.seed()&lt;/code&gt; , где &lt;code&gt;e&lt;/code&gt; - базовый движок.</target>
        </trans-unit>
        <trans-unit id="f142d0432d80c80b2801b2b54dcc353009676c5d" translate="yes" xml:space="preserve">
          <source>1) Serializes the internal state of the pseudo-random number engine &lt;code&gt;e&lt;/code&gt; as a sequence of decimal numbers separated by one or more spaces, and inserts it to the stream &lt;code&gt;ost&lt;/code&gt;. The fill character and the formatting flags of the stream are ignored and unaffected.</source>
          <target state="translated">1) Сериализует внутреннее состояние механизма &lt;code&gt;e&lt;/code&gt; псевдослучайных чисел как последовательность десятичных чисел, разделенных одним или несколькими пробелами, и вставляет его в поток &lt;code&gt;ost&lt;/code&gt; . Символ заполнения и флаги форматирования потока игнорируются и не затрагиваются.</target>
        </trans-unit>
        <trans-unit id="08f8da6462aba2a7fffaed13b8fbb52f524e794c" translate="yes" xml:space="preserve">
          <source>1) Serializes the internal state of the pseudo-random number engine adaptor as a sequence of decimal numbers separated by one or more spaces, and inserts it to the stream &lt;code&gt;ost&lt;/code&gt;. The fill character and the formatting flags of the stream are ignored and unaffected.</source>
          <target state="translated">1) Сериализует внутреннее состояние адаптера механизма псевдослучайных чисел в виде последовательности десятичных чисел, разделенных одним или несколькими пробелами, и вставляет его в поток &lt;code&gt;ost&lt;/code&gt; . Символ заполнения и флаги форматирования потока игнорируются и не затрагиваются.</target>
        </trans-unit>
        <trans-unit id="36a998e3dc0e13d7209092f6c20763322ec5b8e6" translate="yes" xml:space="preserve">
          <source>1) Sets &lt;code&gt;loc&lt;/code&gt; as the associated locale. Calls &lt;code&gt;imbue(loc)&lt;/code&gt; of the most derived class.</source>
          <target state="translated">1) Устанавливает &lt;code&gt;loc&lt;/code&gt; в качестве связанной локали. Вызывает &lt;code&gt;imbue(loc)&lt;/code&gt; самого производного класса.</target>
        </trans-unit>
        <trans-unit id="ed7ef78eb4d8ac7ad642d4f6b0d28e5671d8ee52" translate="yes" xml:space="preserve">
          <source>1) Sets all bits to &lt;code&gt;false&lt;/code&gt;</source>
          <target state="translated">1) Устанавливает все биты в &lt;code&gt;false&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="748a476f9f45c4cb135ddad1e581399045772b64" translate="yes" xml:space="preserve">
          <source>1) Sets all bits to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">1) Устанавливает все биты в &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2021569fa06d5efa69909df75d00a3f4cd2a9408" translate="yes" xml:space="preserve">
          <source>1) Sets the &lt;code&gt;floatfield&lt;/code&gt; of the stream &lt;code&gt;str&lt;/code&gt; to &lt;code&gt;fixed&lt;/code&gt; as if by calling &lt;code&gt;str.setf(&lt;a href=&quot;../ios_base/fmtflags&quot;&gt;std::ios_base::fixed&lt;/a&gt;, &lt;a href=&quot;../ios_base/fmtflags&quot;&gt;std::ios_base::floatfield&lt;/a&gt;)&lt;/code&gt;</source>
          <target state="translated">1) Устанавливает &lt;code&gt;floatfield&lt;/code&gt; потока &lt;code&gt;str&lt;/code&gt; к &lt;code&gt;fixed&lt;/code&gt; как при вызове &lt;code&gt;str.setf(&lt;a href=&quot;../ios_base/fmtflags&quot;&gt;std::ios_base::fixed&lt;/a&gt;, &lt;a href=&quot;../ios_base/fmtflags&quot;&gt;std::ios_base::floatfield&lt;/a&gt;)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="50dc184d36fecae99d3273c9a89db78d54bc50c8" translate="yes" xml:space="preserve">
          <source>1) Sets the bits to the result of binary AND on corresponding pairs of bits of &lt;code&gt;*this&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt;.</source>
          <target state="translated">1) Устанавливает биты в результат двоичного И на соответствующих парах битов &lt;code&gt;*this&lt;/code&gt; и &lt;code&gt;other&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a1cd0d7ac969813ee13818267a9de7c1936f1da7" translate="yes" xml:space="preserve">
          <source>1) Sets the formatting flags identified by &lt;code&gt;flags&lt;/code&gt;. Effectively the following operation is performed &lt;code&gt;fl = fl | flags&lt;/code&gt; where &lt;code&gt;fl&lt;/code&gt; defines the state of internal formatting flags.</source>
          <target state="translated">1) Устанавливает флаги форматирования, обозначенные &lt;code&gt;flags&lt;/code&gt; . Эффективно выполняется следующая операция &lt;code&gt;fl = fl | flags&lt;/code&gt; где &lt;code&gt;fl&lt;/code&gt; определяет состояние внутренних флагов форматирования.</target>
        </trans-unit>
        <trans-unit id="5a76f71dc224d669d3f23245ebcbc6fe12cf100b" translate="yes" xml:space="preserve">
          <source>1) Shares ownership of the object managed by &lt;code&gt;r&lt;/code&gt;. If &lt;code&gt;r&lt;/code&gt; manages no object, &lt;code&gt;*this&lt;/code&gt; manages no object too. Equivalent to &lt;code&gt;shared_ptr&amp;lt;T&amp;gt;(r).swap(*this)&lt;/code&gt;.</source>
          <target state="translated">1) Доли владения объектом, управляемым &lt;code&gt;r&lt;/code&gt; . Если &lt;code&gt;r&lt;/code&gt; не управляет объектом, &lt;code&gt;*this&lt;/code&gt; управляет объектом. Эквивалент &lt;code&gt;shared_ptr&amp;lt;T&amp;gt;(r).swap(*this)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="33d51240dc329ad03133b83ed63c310835b93f14" translate="yes" xml:space="preserve">
          <source>1) Shifts the elements towards the beginning of the range. If &lt;code&gt;n &amp;lt;= 0 || n &amp;gt;= last - first&lt;/code&gt;, there are no effects. Otherwise, for every integer &lt;code&gt;i&lt;/code&gt; in &lt;code&gt;[0, last - first - n)&lt;/code&gt;, moves the element originally at position &lt;code&gt;first + n + i&lt;/code&gt; to position &lt;code&gt;first + i&lt;/code&gt;. The moves are performed in increasing order of &lt;code&gt;i&lt;/code&gt; starting from &lt;code&gt;​0​&lt;/code&gt;.</source>
          <target state="translated">1) Смещает элементы к началу диапазона. Если &lt;code&gt;n &amp;lt;= 0 || n &amp;gt;= last - first&lt;/code&gt; , нет никаких эффектов. В противном случае для каждого целого числа &lt;code&gt;i&lt;/code&gt; в &lt;code&gt;[0, last - first - n)&lt;/code&gt; элемент перемещается первоначально в позицию &lt;code&gt;first + n + i&lt;/code&gt; в позицию &lt;code&gt;first + i&lt;/code&gt; . Эти шаги выполняются в порядке возрастания &lt;code&gt;i&lt;/code&gt; , начиная с &lt;code&gt;​0​&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c3c379223399d99299e4dd0ec4e8ae7d2df828f1" translate="yes" xml:space="preserve">
          <source>1) Specifies that a constructor  or conversion function(since C++11) is explicit, that is, it cannot be used for &lt;a href=&quot;implicit_cast&quot;&gt;implicit conversions&lt;/a&gt; and &lt;a href=&quot;copy_initialization&quot;&gt;copy-initialization&lt;/a&gt;.</source>
          <target state="translated">1) Указывает, что конструктор или функция преобразования (начиная с C ++ 11) явные, то есть не могут использоваться для &lt;a href=&quot;implicit_cast&quot;&gt;неявных преобразований&lt;/a&gt; и &lt;a href=&quot;copy_initialization&quot;&gt;инициализации копирования&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3fc72a8629768287c31cd486267125fa2a02f24d" translate="yes" xml:space="preserve">
          <source>1) Static or thread-local references, if it is bound to static glvalue, to a temporary object (or its subobject), or to a function, and if every expression (including implicit conversions) in &lt;a href=&quot;reference_initialization&quot;&gt;the initializer&lt;/a&gt; of the reference is a &lt;a href=&quot;constant_expression&quot;&gt;constant expression&lt;/a&gt;.</source>
          <target state="translated">1) Статические или локальные ссылки потока, если он связан со статическим glvalue, временным объектом (или его подобъектом) или функцией, и если каждое выражение (включая неявные преобразования) в &lt;a href=&quot;reference_initialization&quot;&gt;инициализаторе&lt;/a&gt; ссылки является &lt;a href=&quot;constant_expression&quot;&gt;константой выражение&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7bba5893de10ec808038f251574bf599363a4baa" translate="yes" xml:space="preserve">
          <source>1) Steps through the character sequence &lt;code&gt;[fmtbeg, fmtend)&lt;/code&gt;, examining the characters. Every character that is not a part of a format sequence is written to the output iterator &lt;code&gt;out&lt;/code&gt; immediately. To identify format sequences, this function narrows the next character &lt;code&gt;c&lt;/code&gt; in &lt;code&gt;[fmtbeg, fmtend)&lt;/code&gt; as if by &lt;code&gt;&lt;a href=&quot;../ctype&quot;&gt;std::ctype&lt;/a&gt;&amp;lt;char_type&amp;gt;(str.getloc()).narrow(c,0)&lt;/code&gt; and if it equals &lt;code&gt;'%'&lt;/code&gt;, the next one or two characters are compared to the list of format sequences recognized by &lt;code&gt;&lt;a href=&quot;../../chrono/c/strftime&quot;&gt;std::strftime&lt;/a&gt;&lt;/code&gt; plus any additional implementation-defined formats supported by this locale. For each valid format sequence, a call to &lt;code&gt;do_put(out, str, fill, t, format, modifier)&lt;/code&gt; is made, where &lt;code&gt;format&lt;/code&gt; is the format sequence character, and &lt;code&gt;modifier&lt;/code&gt; is the optional format sequence modifier (&lt;code&gt;'E'&lt;/code&gt; or &lt;code&gt;'O'&lt;/code&gt;). A value of &lt;code&gt;'\0'&lt;/code&gt; is used if the modifier is absent.</source>
          <target state="translated">1) &lt;code&gt;[fmtbeg, fmtend)&lt;/code&gt; последовательность символов [fmtbeg, fmtend) , проверка символов. Каждый символ, который не является частью последовательности форматирования &lt;code&gt;out&lt;/code&gt; немедленно записывается в выходной итератор . Чтобы идентифицировать последовательности форматов, эта функция сужает следующий символ &lt;code&gt;c&lt;/code&gt; в &lt;code&gt;[fmtbeg, fmtend)&lt;/code&gt; как бы с помощью &lt;code&gt;&lt;a href=&quot;../ctype&quot;&gt;std::ctype&lt;/a&gt;&amp;lt;char_type&amp;gt;(str.getloc()).narrow(c,0)&lt;/code&gt; и, если он равен &lt;code&gt;'%'&lt;/code&gt; , следующие один или два символа сравниваются со списком последовательностей форматов, распознаваемых &lt;code&gt;&lt;a href=&quot;../../chrono/c/strftime&quot;&gt;std::strftime&lt;/a&gt;&lt;/code&gt; плюс любые дополнительные определяемые реализацией форматы, поддерживаемые этим языковым стандартом. Для каждой действительной последовательности форматов вызывается &lt;code&gt;do_put(out, str, fill, t, format, modifier)&lt;/code&gt; производится, где &lt;code&gt;format&lt;/code&gt; - символ последовательности формата, а &lt;code&gt;modifier&lt;/code&gt; - необязательный модификатор последовательности формата ( &lt;code&gt;'E'&lt;/code&gt; или &lt;code&gt;'O'&lt;/code&gt; ). Значение &lt;code&gt;'\0'&lt;/code&gt; используется, если модификатор отсутствует.</target>
        </trans-unit>
        <trans-unit id="dbe4d06a8673e9980bbd8a34d0a33460ddce561c" translate="yes" xml:space="preserve">
          <source>1) Swaps the values &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt;. This overload does not participate in overload resolution unless &lt;code&gt;&lt;a href=&quot;../types/is_move_constructible&quot;&gt;std::is_move_constructible_v&lt;/a&gt;&amp;lt;T&amp;gt; &amp;amp;&amp;amp; &lt;a href=&quot;../types/is_move_assignable&quot;&gt;std::is_move_assignable_v&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;.(since C++17)</source>
          <target state="translated">1) Меняет местами значения &lt;code&gt;a&lt;/code&gt; и &lt;code&gt;b&lt;/code&gt; . Эта перегрузка не участвует в разрешении перегрузки, если только &lt;code&gt;&lt;a href=&quot;../types/is_move_constructible&quot;&gt;std::is_move_constructible_v&lt;/a&gt;&amp;lt;T&amp;gt; &amp;amp;&amp;amp; &lt;a href=&quot;../types/is_move_assignable&quot;&gt;std::is_move_assignable_v&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt; имеет значение &lt;code&gt;true&lt;/code&gt; (начиная с C ++ 17)</target>
        </trans-unit>
        <trans-unit id="0e334356b91d7cf3ca8b843c79afa340cb4f3a9d" translate="yes" xml:space="preserve">
          <source>1) Template arguments (if any) are substituted into expression;</source>
          <target state="translated">1)В выражение подставляются аргументы шаблонов (если таковые имеются);</target>
        </trans-unit>
        <trans-unit id="ce2782af810444b02f25f93a1dd29f5756552166" translate="yes" xml:space="preserve">
          <source>1) The</source>
          <target state="translated">1)</target>
        </trans-unit>
        <trans-unit id="2bf42c2016441eb61ea13c6e9fa609da95361a52" translate="yes" xml:space="preserve">
          <source>1) The &lt;a href=&quot;../preprocessor&quot;&gt;preprocessor&lt;/a&gt; is executed.</source>
          <target state="translated">1) &lt;a href=&quot;../preprocessor&quot;&gt;Препроцессор&lt;/a&gt; выполнен.</target>
        </trans-unit>
        <trans-unit id="65e8aa1cffd8b645e51e443b4510d72178b7b831" translate="yes" xml:space="preserve">
          <source>1) The &lt;a href=&quot;name&quot;&gt;name&lt;/a&gt; that is declared.</source>
          <target state="translated">1) &lt;a href=&quot;name&quot;&gt;Имя&lt;/a&gt; , которое объявлено.</target>
        </trans-unit>
        <trans-unit id="f433a0c89c7f1e8799b60485288073c016147e00" translate="yes" xml:space="preserve">
          <source>1) The &lt;code&gt;&lt;a href=&quot;../range/view&quot;&gt;View&lt;/a&gt;&lt;/code&gt; concept specifies the requirements of a &lt;a href=&quot;range&quot;&gt;&lt;code&gt;Range&lt;/code&gt;&lt;/a&gt; type that has constant time copy, move, and assignment operations (e.g. a pair of iterators, or a generator Range that creates its elements on-demand. Notably, the standard library containers are Ranges, but not Views)</source>
          <target state="translated">1) Концепция &lt;code&gt;&lt;a href=&quot;../range/view&quot;&gt;View&lt;/a&gt;&lt;/code&gt; определяет требования к типу &lt;a href=&quot;range&quot;&gt; &lt;code&gt;Range&lt;/code&gt; &lt;/a&gt; , в котором выполняются операции копирования, перемещения и присваивания с постоянным временем (например, пара итераторов или генератор Range, который создает свои элементы по требованию. В частности, контейнеры стандартной библиотеки представляют собой Ranges , но не виды)</target>
        </trans-unit>
        <trans-unit id="ec5eeb1c920435edfac9357c193554b45fa0d085" translate="yes" xml:space="preserve">
          <source>1) The &lt;code&gt;Range&lt;/code&gt; concept defines the requirements of a type that allows iteration over its elements by providing an iterator and sentinel that denote the elements of the range.</source>
          <target state="translated">1) Концепция &lt;code&gt;Range&lt;/code&gt; определяет требования типа, который допускает итерацию по его элементам, предоставляя итератор и страж, которые обозначают элементы диапазона.</target>
        </trans-unit>
        <trans-unit id="5664b3fe1fc216eb8579abb8ca6fc0ab64244ff1" translate="yes" xml:space="preserve">
          <source>1) The &lt;code&gt;auto&lt;/code&gt; specifier was only allowed for objects declared at block scope or in function parameter lists. It indicated automatic storage duration, which is the default for these kinds of declarations. The meaning of this keyword was changed in C++11.</source>
          <target state="translated">1) &lt;code&gt;auto&lt;/code&gt; спецификатор был разрешен только для объектов, объявленных в области блока или в списках параметров функции. В нем указана длительность автоматического хранения, которая используется по умолчанию для объявлений такого типа. Значение этого ключевого слова было изменено в C ++ 11.</target>
        </trans-unit>
        <trans-unit id="5771f1de4aaeaaa160fa4e631f3e630380eaf437" translate="yes" xml:space="preserve">
          <source>1) The a distribution parameter (location).</source>
          <target state="translated">1)Параметр распределения (местоположение).</target>
        </trans-unit>
        <trans-unit id="a56f4b7e28c5e16ec27cb41041cbe5d377ab7dae" translate="yes" xml:space="preserve">
          <source>1) The alternative name this &lt;code&gt;link&lt;/code&gt; object represents.</source>
          <target state="translated">1) Альтернативное имя, которое представляет этот объект &lt;code&gt;link&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="13892ed49e94589b6b3b35aa23f26504383e1f3e" translate="yes" xml:space="preserve">
          <source>1) The argument list cannot be identical to the non-specialized argument list (it must specialize something)</source>
          <target state="translated">1)Список аргументов не может быть идентичен списку неспециализированных аргументов (он должен что-то специализировать).</target>
        </trans-unit>
        <trans-unit id="55233ebd70c2b08df11e491094ea36d0775f225f" translate="yes" xml:space="preserve">
          <source>1) The associated parameter set.</source>
          <target state="translated">1)Соответствующий набор параметров.</target>
        </trans-unit>
        <trans-unit id="8cb340ccead28657a0f96c703f2768d7cbbcc0cb" translate="yes" xml:space="preserve">
          <source>1) The caller is requesting that the get area is backed up by one character (&lt;code&gt;pbackfail()&lt;/code&gt; is called with no arguments or with &lt;code&gt;&lt;a href=&quot;../c&quot;&gt;EOF&lt;/a&gt;&lt;/code&gt; as the argument)</source>
          <target state="translated">1) Вызывающая &lt;code&gt;pbackfail()&lt;/code&gt; запрашивает, чтобы область get поддерживалась одним символом ( pbackfail () вызывается без аргументов или с &lt;code&gt;&lt;a href=&quot;../c&quot;&gt;EOF&lt;/a&gt;&lt;/code&gt; в качестве аргумента)</target>
        </trans-unit>
        <trans-unit id="3b59d07570db328903bdf39c6ee15b2e5874d234" translate="yes" xml:space="preserve">
          <source>1) The caller is requesting that the get area is backed up by one character (&lt;code&gt;pbackfail()&lt;/code&gt; is called with no arguments or with &lt;code&gt;Traits::eof()&lt;/code&gt; as the argument)</source>
          <target state="translated">1) Вызывающая &lt;code&gt;pbackfail()&lt;/code&gt; запрашивает, чтобы область get была зарезервирована одним символом ( pbackfail () вызывается без аргументов или с &lt;code&gt;Traits::eof()&lt;/code&gt; в качестве аргумента)</target>
        </trans-unit>
        <trans-unit id="61adb3e6b0b307a7e54bcae25d20d2e0a7936478" translate="yes" xml:space="preserve">
          <source>1) The caller is requesting that the get area is backed up by one character (&lt;code&gt;pbackfail()&lt;/code&gt; is called with no arguments), in which case, this function re-reads the file starting one byte earlier and decrements &lt;a href=&quot;../basic_streambuf/gptr&quot;&gt;&lt;code&gt;basic_streambuf::gptr()&lt;/code&gt;&lt;/a&gt;, e.g. by calling &lt;code&gt;gbump(-1)&lt;/code&gt;.</source>
          <target state="translated">1) Вызывающая &lt;code&gt;pbackfail()&lt;/code&gt; запрашивает, чтобы область получения была зарезервирована одним символом ( pbackfail () вызывается без аргументов), и в этом случае эта функция перечитывает файл, начинающийся на один байт раньше, и уменьшает &lt;a href=&quot;../basic_streambuf/gptr&quot;&gt; &lt;code&gt;basic_streambuf::gptr()&lt;/code&gt; &lt;/a&gt; Например, вызвав &lt;code&gt;gbump(-1)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e1ae7223669c573a68efa4c16b06f3ce8570f1d7" translate="yes" xml:space="preserve">
          <source>1) The concept &lt;code&gt;StrictTotallyOrdered&amp;lt;T&amp;gt;&lt;/code&gt; specifies that the comparison operators &lt;code&gt;==,!=,&amp;lt;,&amp;gt;,&amp;lt;=,&amp;gt;=&lt;/code&gt; on &lt;code&gt;T&lt;/code&gt; yield results consistent with a &lt;a href=&quot;https://en.wikipedia.org/wiki/Total_order#Strict_total_order&quot;&gt;strict total order&lt;/a&gt; on &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">1) Концепция &lt;code&gt;StrictTotallyOrdered&amp;lt;T&amp;gt;&lt;/code&gt; указывает , что операторы сравнения &lt;code&gt;==,!=,&amp;lt;,&amp;gt;,&amp;lt;=,&amp;gt;=&lt;/code&gt; На &lt;code&gt;T&lt;/code&gt; дают результаты в соответствии с &lt;a href=&quot;https://en.wikipedia.org/wiki/Total_order#Strict_total_order&quot;&gt;строгим общего порядка&lt;/a&gt; на &lt;code&gt;T&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="692cf4b8d8f5f53ecfe4d474f1ec25af3dddecf7" translate="yes" xml:space="preserve">
          <source>1) The constructor initializes the member object (of type &lt;code&gt;&lt;a href=&quot;../../types/decay&quot;&gt;std::decay_t&lt;/a&gt;&amp;lt;F&amp;gt;&lt;/code&gt;) from &lt;code&gt;&lt;a href=&quot;../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;F&amp;gt;(f)&lt;/code&gt;. Throws any exception thrown by the constructor selected</source>
          <target state="translated">1) Конструктор инициализирует объект-член (типа &lt;code&gt;&lt;a href=&quot;../../types/decay&quot;&gt;std::decay_t&lt;/a&gt;&amp;lt;F&amp;gt;&lt;/code&gt; ) из &lt;code&gt;&lt;a href=&quot;../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;F&amp;gt;(f)&lt;/code&gt; . Выдает любое исключение, выброшенное выбранным конструктором</target>
        </trans-unit>
        <trans-unit id="2b56e5f14d5ec78f7a1a9e935292dc9c4e9c4bc1" translate="yes" xml:space="preserve">
          <source>1) The copy assignment operator is protected, and is deleted. Input streams are not CopyAssignable.</source>
          <target state="translated">1)Оператор назначения копии защищен и удален.Входные потоки не являются CopyAssignable.</target>
        </trans-unit>
        <trans-unit id="cb957de92fc95959bfc746d86ce3609a64f1a4fd" translate="yes" xml:space="preserve">
          <source>1) The copy assignment operator is protected, and is deleted. Output streams are not CopyAssignable.</source>
          <target state="translated">1)Оператор назначения копии защищен и удален.Выходные потоки не являются CopyAssignable.</target>
        </trans-unit>
        <trans-unit id="e34654c2e919d3a91813ff3288559504fc22e14a" translate="yes" xml:space="preserve">
          <source>1) The copy constructor is deleted: streams are not copyable.</source>
          <target state="translated">1)Конструктор копирования удаляется:потоки не копируются.</target>
        </trans-unit>
        <trans-unit id="10e7c6895d9ef10be5943bb1587dc03b33198d2f" translate="yes" xml:space="preserve">
          <source>1) The current exception mask.</source>
          <target state="translated">1)Текущая маска исключений.</target>
        </trans-unit>
        <trans-unit id="3abfb5553c81efc2e23dc953228b75d755237163" translate="yes" xml:space="preserve">
          <source>1) The default constructor creates a &lt;code&gt;std::seed_seq&lt;/code&gt; object with an initial seed sequence of length zero.</source>
          <target state="translated">1) Конструктор по умолчанию создает объект &lt;code&gt;std::seed_seq&lt;/code&gt; с начальной последовательностью начальных значений нулевой длины.</target>
        </trans-unit>
        <trans-unit id="4e2c38841269bc097ae1c47eda71b3fbdeb21c7e" translate="yes" xml:space="preserve">
          <source>1) The default constructor is defaulted.</source>
          <target state="translated">1)Конструктор по умолчанию дефолтный.</target>
        </trans-unit>
        <trans-unit id="eaa9c330e0c1827f710a288a9214aaa3553943cf" translate="yes" xml:space="preserve">
          <source>1) The default constructor is trivial: no initialization takes place other than &lt;a href=&quot;../../language/zero_initialization&quot;&gt;zero initialization&lt;/a&gt; of static and thread-local objects. &lt;code&gt;&lt;a href=&quot;../atomic_init&quot;&gt;std::atomic_init&lt;/a&gt;&lt;/code&gt; may be used to complete initialization.</source>
          <target state="translated">1) Конструктор по умолчанию тривиален: никакая инициализация не происходит, кроме &lt;a href=&quot;../../language/zero_initialization&quot;&gt;нулевой инициализации&lt;/a&gt; статических и локальных потоков объектов. &lt;code&gt;&lt;a href=&quot;../atomic_init&quot;&gt;std::atomic_init&lt;/a&gt;&lt;/code&gt; может использоваться для завершения инициализации.</target>
        </trans-unit>
        <trans-unit id="a6475c63291c6da877aa299aa6f4d12b026b2cf4" translate="yes" xml:space="preserve">
          <source>1) The default, equivalent to (2) with &lt;code&gt;copy_options::none&lt;/code&gt; used as &lt;code&gt;options&lt;/code&gt;</source>
          <target state="translated">1) Значение по умолчанию, эквивалентное (2) с &lt;code&gt;copy_options::none&lt;/code&gt; используемым в качестве &lt;code&gt;options&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="bf4124c6a6217a2beb35fda41d126dc7a4ceaa8e" translate="yes" xml:space="preserve">
          <source>1) The destructors of objects with thread local &lt;a href=&quot;../../language/storage_duration&quot;&gt;storage duration&lt;/a&gt; that are associated with the current thread, the destructors of objects with static storage duration, and the functions registered with &lt;code&gt;&lt;a href=&quot;atexit&quot;&gt;std::atexit&lt;/a&gt;&lt;/code&gt; are executed concurrently, while maintaining the following guarantees: a) The last destructor for thread-local objects is &lt;a href=&quot;../../language/eval_order&quot;&gt;sequenced-before&lt;/a&gt; the first destructor for a static object b) If the completion of the constructor or &lt;a href=&quot;../../language/initialization#Dynamic_initialization&quot;&gt;dynamic initialization&lt;/a&gt; for thread-local or static object A was sequenced-before thread-local or static object B, the completion of the destruction of B is sequenced-before the start of the destruction of A c) If the completion of the initialization of a static object A was sequenced-before the call to &lt;code&gt;&lt;a href=&quot;atexit&quot;&gt;std::atexit&lt;/a&gt;&lt;/code&gt; for some function F, the call to F during termination is sequenced-before the start of the destruction of A d) If the call to &lt;code&gt;&lt;a href=&quot;atexit&quot;&gt;std::atexit&lt;/a&gt;&lt;/code&gt; for some function F was sequenced-before the completion of initialization of a static object A, the start of the destruction of A is sequenced-before the call to F during termination. e) If a call to &lt;code&gt;&lt;a href=&quot;atexit&quot;&gt;std::atexit&lt;/a&gt;&lt;/code&gt; for some function F1 was sequenced-before the call to &lt;code&gt;&lt;a href=&quot;atexit&quot;&gt;std::atexit&lt;/a&gt;&lt;/code&gt; for some function F2, then the call to F2 during termination is sequenced-before the call to F1</source>
          <target state="translated">1) Деструкторы объектов с &lt;a href=&quot;../../language/storage_duration&quot;&gt;длительностью&lt;/a&gt; локального хранения потока , которые связаны с текущим потоком, деструкторы объектов с длительностью статического хранения и функции, зарегистрированные с помощью &lt;code&gt;&lt;a href=&quot;atexit&quot;&gt;std::atexit&lt;/a&gt;&lt;/code&gt; , выполняются одновременно, сохраняя следующие гарантии: a) последний деструктор для локальных объектов потока &lt;a href=&quot;../../language/eval_order&quot;&gt;секвенируется перед&lt;/a&gt; первым деструктором для статического объекта б) Если завершение конструктора или &lt;a href=&quot;../../language/initialization#Dynamic_initialization&quot;&gt;динамическая инициализация&lt;/a&gt; для локального или статического объекта потока было выполнено последовательно перед локальным потоком или статическим объектом B, завершение уничтожения B выполняется последовательно - до начала уничтожения A c) Если завершение инициализации статического объекта A было выполнено последовательно - до вызова &lt;code&gt;&lt;a href=&quot;atexit&quot;&gt;std::atexit&lt;/a&gt;&lt;/code&gt; для некоторой функции F, вызов F во время завершения секвенируется - до начала уничтожения A d) Если вызов &lt;code&gt;&lt;a href=&quot;atexit&quot;&gt;std::atexit&lt;/a&gt;&lt;/code&gt; для некоторой функции F был секвенирован - до завершения инициализации a статический объект A, начало уничтожения A чередуется до вызова F во время завершения. e) Если вызов &lt;code&gt;&lt;a href=&quot;atexit&quot;&gt;std::atexit&lt;/a&gt;&lt;/code&gt; для некоторой функции F1 был секвенирован до вызова &lt;code&gt;&lt;a href=&quot;atexit&quot;&gt;std::atexit&lt;/a&gt;&lt;/code&gt; для некоторой функции F2, то вызов F2 во время завершения будет секвенирован до вызова F1</target>
        </trans-unit>
        <trans-unit id="984436ed4409399ee56d2edafaa76fa5827ade9b" translate="yes" xml:space="preserve">
          <source>1) The execution policy type used as a unique type to disambiguate parallel algorithm overloading and require that a parallel algorithm's execution may not be parallelized. The invocations of element access functions in parallel algorithms invoked with this policy (usually specified as &lt;code&gt;&lt;a href=&quot;execution_policy_tag&quot;&gt;std::execution::seq&lt;/a&gt;&lt;/code&gt;) are indeterminately sequenced in the calling thread.</source>
          <target state="translated">1) Тип политики выполнения, используемый как уникальный тип для устранения неоднозначности перегрузки параллельного алгоритма и требует, чтобы выполнение параллельного алгоритма не было распараллелено. Вызовы функций доступа к элементам в параллельных алгоритмах, вызываемых этой политикой (обычно указывается как &lt;code&gt;&lt;a href=&quot;execution_policy_tag&quot;&gt;std::execution::seq&lt;/a&gt;&lt;/code&gt; ), неопределенно упорядочены в вызывающем потоке.</target>
        </trans-unit>
        <trans-unit id="e362b206dffda02474ab2c007c80f4e6c881bbd6" translate="yes" xml:space="preserve">
          <source>1) The exponent syntax for a decimal floating-point literal</source>
          <target state="translated">1)Синтаксис экспоненты для буквы с плавающей запятой в десятичной запятой</target>
        </trans-unit>
        <trans-unit id="64cdf221b5add07010de335de6d59fa388267951" translate="yes" xml:space="preserve">
          <source>1) The file or empty directory identified by the path &lt;code&gt;p&lt;/code&gt; is deleted as if by the POSIX &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/remove.html&quot;&gt;remove&lt;/a&gt;. Symlinks are not followed (symlink is removed, not its target)</source>
          <target state="translated">1) Файл или пустой каталог определены пути &lt;code&gt;p&lt;/code&gt; удаляется , как будто в POSIX &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/remove.html&quot;&gt;Вытащите&lt;/a&gt; . Симлинки не идут (симлинк удален, а не его цель)</target>
        </trans-unit>
        <trans-unit id="efff08eeeee41b2824631c7af356a9f4b8b0d101" translate="yes" xml:space="preserve">
          <source>1) The file or empty directory identified by the path &lt;code&gt;p&lt;/code&gt; is deleted as if by the POSIX &lt;a href=&quot;https://pubs.opengroup.org/onlinepubs/9699919799/functions/remove.html&quot;&gt;remove&lt;/a&gt;. Symlinks are not followed (symlink is removed, not its target)</source>
          <target state="translated">1) Файл или пустой каталог определены пути &lt;code&gt;p&lt;/code&gt; удаляется , как будто в POSIX &lt;a href=&quot;https://pubs.opengroup.org/onlinepubs/9699919799/functions/remove.html&quot;&gt;Вытащите&lt;/a&gt; . Символьные ссылки не соблюдаются (символическая ссылка удаляется, а не ее цель)</target>
        </trans-unit>
        <trans-unit id="9be6415eb11ca6d2a6ae2ef6b1a8ebf53b49733f" translate="yes" xml:space="preserve">
          <source>1) The first operand must be an expression of &lt;a href=&quot;incomplete_type&quot;&gt;complete class type&lt;/a&gt;&lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">1) Первый операнд должен быть выражением &lt;a href=&quot;incomplete_type&quot;&gt;полного типа класса &lt;/a&gt; &lt;code&gt;T&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5f5ef6f6f7feb816947d23a3ea4f22b9c37b4705" translate="yes" xml:space="preserve">
          <source>1) The format character sequence is defined by the range &lt;code&gt;[fmt_first, fmt_last)&lt;/code&gt;. The resulting character sequence is copied to &lt;code&gt;out&lt;/code&gt;.</source>
          <target state="translated">1) Последовательность символов формата определяется диапазоном &lt;code&gt;[fmt_first, fmt_last)&lt;/code&gt; . Результирующая последовательность символов копируется в &lt;code&gt;out&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="95de870e8f49a93ec939ffd632a40a00558bdce7" translate="yes" xml:space="preserve">
          <source>1) The individual bytes of the source code file are mapped (in implementation-defined manner) to the characters of the</source>
          <target state="translated">1)Отдельные байты файла исходного кода привязываются (в порядке,определенном реализацией)к символам</target>
        </trans-unit>
        <trans-unit id="f69e48ffceb6307d147e62ebd3e15bb7bcf22d41" translate="yes" xml:space="preserve">
          <source>1) The length &lt;code&gt;rlen&lt;/code&gt; of the sequences to compare is the smaller of &lt;code&gt;size()&lt;/code&gt; and &lt;code&gt;v.size()&lt;/code&gt;. The function compares the two views by calling &lt;code&gt;traits::compare(data(), v.data(), rlen)&lt;/code&gt;, and returns a value according to the following table:</source>
          <target state="translated">1) Длина &lt;code&gt;rlen&lt;/code&gt; сравниваемых последовательностей меньше: &lt;code&gt;size()&lt;/code&gt; и &lt;code&gt;v.size()&lt;/code&gt; . Функция сравнивает два представления, вызывая &lt;code&gt;traits::compare(data(), v.data(), rlen)&lt;/code&gt; , и возвращает значение в соответствии со следующей таблицей:</target>
        </trans-unit>
        <trans-unit id="4037f7821b91877636d406cbce1bcacb0689bf42" translate="yes" xml:space="preserve">
          <source>1) The lifetime of the object allocated by E1 strictly contains the lifetime of the object allocated by E2, 2) E1 and E2 would invoke the same replaceable global allocation function 3) For a throwing allocation function, exceptions in E1 and E2 would be first caught in the same handler.</source>
          <target state="translated">1)Время жизни объекта,выделенного E1,строго содержит время жизни объекта,выделенного E2,2)E1 и E2 будут вызывать одну и ту же замещаемую функцию глобального распределения 3)Для функции распределения бросков исключения в E1 и E2 будут сначала попадать в один и тот же обработчик.</target>
        </trans-unit>
        <trans-unit id="b5680fbc09a44d73240f35e66072e9eb23f44a63" translate="yes" xml:space="preserve">
          <source>1) The list of boundaries of the intervals.</source>
          <target state="translated">1)Список границ интервалов.</target>
        </trans-unit>
        <trans-unit id="b88da70e98e0b2688aca929c023fd479e8e2afd6" translate="yes" xml:space="preserve">
          <source>1) The log-mean m distribution parameter.</source>
          <target state="translated">1)Параметр распределения лога m.</target>
        </trans-unit>
        <trans-unit id="58a51494ba725af135bdfe4838b9d7d460044580" translate="yes" xml:space="preserve">
          <source>1) The m (the first degree of freedom) distribution parameter.</source>
          <target state="translated">1)Параметр распределения m (первая степень свободы).</target>
        </trans-unit>
        <trans-unit id="253b910778e1d968599094f0f2559f6818ab03e8" translate="yes" xml:space="preserve">
          <source>1) The mean &amp;mu; distribution parameter.</source>
          <target state="translated">1) Средний параметр распределения &amp;mu;.</target>
        </trans-unit>
        <trans-unit id="419ac7c350c315de0c2fc313d43dafe994bfe4ae" translate="yes" xml:space="preserve">
          <source>1) The members declared after the specifier have public member access</source>
          <target state="translated">1)Члены,объявленные после спецификатора,имеют публичный доступ к ним.</target>
        </trans-unit>
        <trans-unit id="bd8f7818635373bb03d0e69a14d67db0b342bd5c" translate="yes" xml:space="preserve">
          <source>1) The nested-name-specifier (everything to the left of the scope resolution operator &lt;code&gt;::&lt;/code&gt;) of a type that was specified using a &lt;a href=&quot;name#Qualified_identifiers&quot;&gt;qualified-id&lt;/a&gt;:</source>
          <target state="translated">1) вложенное имя-спецификатор (все , слева от оператора разрешения области видимости &lt;code&gt;::&lt;/code&gt; ) такого типа , который был указан с помощью &lt;a href=&quot;name#Qualified_identifiers&quot;&gt;квалифицированного идентификатора&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="c5d2d5ea95e95309310a1f70f09cdbb08741b9eb" translate="yes" xml:space="preserve">
          <source>1) The new element is initialized as a copy of &lt;code&gt;value&lt;/code&gt;.</source>
          <target state="translated">1) Новый элемент инициализируется как копия &lt;code&gt;value&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="805754d1d5d23696faf5387fb9f75302e9f3de82" translate="yes" xml:space="preserve">
          <source>1) The non-specialized &lt;code&gt;default_delete&lt;/code&gt; uses &lt;code&gt;delete&lt;/code&gt; to deallocate memory for a single object.</source>
          <target state="translated">1) Неспециализированный &lt;code&gt;default_delete&lt;/code&gt; использует &lt;code&gt;delete&lt;/code&gt; для освобождения памяти для одного объекта.</target>
        </trans-unit>
        <trans-unit id="078ba3fdb2f0208dd9e2307c39e67cfe68c5c1db" translate="yes" xml:space="preserve">
          <source>1) The non-specialized &lt;code&gt;pointer_traits&lt;/code&gt; declares the following types:</source>
          <target state="translated">1) Неспециализированный &lt;code&gt;pointer_traits&lt;/code&gt; объявляет следующие типы:</target>
        </trans-unit>
        <trans-unit id="92f8554972361f85396cc946915b450c4ce836c2" translate="yes" xml:space="preserve">
          <source>1) The normal form of the path</source>
          <target state="translated">1)Нормальная форма пути</target>
        </trans-unit>
        <trans-unit id="7fcadaf3a1d0805d8241d4dcda9467625d082466" translate="yes" xml:space="preserve">
          <source>1) The operators works on valarrays of the same size and returns a valarray with the same size as the parameters with the operation applied to every elements of the two arguments.</source>
          <target state="translated">1)Операторы работают на валарреях одинакового размера и возвращают валаррей с тем же размером,что и параметры,с операцией,применяемой к каждому элементу двух аргументов.</target>
        </trans-unit>
        <trans-unit id="2682843d9db3de2fe0979f65226c8ec0ffc4a1ff" translate="yes" xml:space="preserve">
          <source>1) The p distribution parameter.</source>
          <target state="translated">1)Параметр распределения p.</target>
        </trans-unit>
        <trans-unit id="52a76b9c4dc5d777618976dffcda053ec848076c" translate="yes" xml:space="preserve">
          <source>1) The pointer to the beginning of the get area.</source>
          <target state="translated">1)Указатель на начало зоны досягаемости.</target>
        </trans-unit>
        <trans-unit id="2788ad850b2bbb3bcd1e26f30ae2197560170280" translate="yes" xml:space="preserve">
          <source>1) The pointer to the beginning of the put area.</source>
          <target state="translated">1)Указатель на начало области ставить.</target>
        </trans-unit>
        <trans-unit id="ecd0301c6f2ffe2d0819343a365dcb5dd5fc514c" translate="yes" xml:space="preserve">
          <source>1) The program is ill-formed if &lt;code&gt;&lt;a href=&quot;../../types/is_constructible&quot;&gt;std::is_constructible_v&lt;/a&gt;&amp;lt;T, const U&amp;amp;&amp;gt;&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">1) Программа некорректна, если &lt;code&gt;&lt;a href=&quot;../../types/is_constructible&quot;&gt;std::is_constructible_v&lt;/a&gt;&amp;lt;T, const U&amp;amp;&amp;gt;&lt;/code&gt; равно &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="76d0af0682d39a23e608870d902e924d40731f41" translate="yes" xml:space="preserve">
          <source>1) The random number generator is implementation-defined, but the function &lt;code&gt;&lt;a href=&quot;../numeric/random/rand&quot;&gt;std::rand&lt;/a&gt;&lt;/code&gt; is often used.</source>
          <target state="translated">1) Генератор случайных чисел определяется реализацией, но часто используется функция &lt;code&gt;&lt;a href=&quot;../numeric/random/rand&quot;&gt;std::rand&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fcb6ec55992b506b45ac666f76eb78e9d99e9237" translate="yes" xml:space="preserve">
          <source>1) The real part.</source>
          <target state="translated">1)Настоящая часть.</target>
        </trans-unit>
        <trans-unit id="04499347610e4d853510728a08aea977c3eea26d" translate="yes" xml:space="preserve">
          <source>1) The result of &lt;code&gt;lhs.equal(rhs)&lt;/code&gt;.</source>
          <target state="translated">1) Результат &lt;code&gt;lhs.equal(rhs)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="acdfeea6d1916156d222310691b55c364fcf71aa" translate="yes" xml:space="preserve">
          <source>1) The result of dereferencing the stored pointer, i.e., &lt;code&gt;*get()&lt;/code&gt;</source>
          <target state="translated">1) Результат разыменования сохраненного указателя, т.е. &lt;code&gt;*get()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="85369193a6efe2baa8eac212d4d41eca7c7a29a4" translate="yes" xml:space="preserve">
          <source>1) The return type is deduced from the returned expression as if by &lt;code&gt;decltype&lt;/code&gt;. The call is ill-formed if the invocation above is not a valid expression of the same type and value category, for all combinations of alternative types of all variants.</source>
          <target state="translated">1) Тип возвращаемого значения выводится из возвращаемого выражения, как если бы он был &lt;code&gt;decltype&lt;/code&gt; . Вызов некорректен, если приведенный выше вызов не является допустимым выражением одного типа и категории значения для всех комбинаций альтернативных типов всех вариантов.</target>
        </trans-unit>
        <trans-unit id="7a36ba71f6e55e9d3da53e756c59b3b06287b854" translate="yes" xml:space="preserve">
          <source>1) The return type meets the requirements of mutable &lt;a href=&quot;../../named_req/randomaccessiterator&quot;&gt;LegacyRandomAccessIterator&lt;/a&gt;.</source>
          <target state="translated">1) Тип возврата соответствует требованиям изменяемого &lt;a href=&quot;../../named_req/randomaccessiterator&quot;&gt;LegacyRandomAccessIterator&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6d3e7aa24867d0d8995a957c6318cd61a05292ec" translate="yes" xml:space="preserve">
          <source>1) The return value of &lt;code&gt;seekoff(off, dir, which)&lt;/code&gt;.</source>
          <target state="translated">1) Возвращаемое значение &lt;code&gt;seekoff(off, dir, which)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="dae9b5cd9ae861b669c70c471b4d08d50f4c940b" translate="yes" xml:space="preserve">
          <source>1) The return value of &lt;code&gt;seekpos(pos, which)&lt;/code&gt;.</source>
          <target state="translated">1) Возвращаемое значение &lt;code&gt;seekpos(pos, which)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="898a982d82a90b60748ffe31055974436184caf1" translate="yes" xml:space="preserve">
          <source>1) The return value of &lt;code&gt;setbuf(s, n)&lt;/code&gt;</source>
          <target state="translated">1) Возвращаемое значение &lt;code&gt;setbuf(s, n)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1e96b281892b82cedb8d59abb7f447580daa3b5f" translate="yes" xml:space="preserve">
          <source>1) The return value of &lt;code&gt;sync()&lt;/code&gt;.</source>
          <target state="translated">1) Возвращаемое значение &lt;code&gt;sync()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7ca5f89c229d3f7753b51b3a66ee13e45d0b0f54" translate="yes" xml:space="preserve">
          <source>1) The source file is decomposed into &lt;a href=&quot;../comments&quot;&gt;comments&lt;/a&gt;, sequences of whitespace characters (space, horizontal tab, new-line, vertical tab, and form-feed), and</source>
          <target state="translated">1) Исходный файл разбит на &lt;a href=&quot;../comments&quot;&gt;комментарии&lt;/a&gt; , последовательности пробельных символов (пробел, горизонтальная табуляция, новая строка, вертикальная табуляция и подача формы), и</target>
        </trans-unit>
        <trans-unit id="36843ad5bce393e021d99643d395dab108c20cf9" translate="yes" xml:space="preserve">
          <source>1) The sum of the given value and elements in the given range.</source>
          <target state="translated">1)Сумма заданного значения и элементов в заданном диапазоне.</target>
        </trans-unit>
        <trans-unit id="3b61bf4f0d9f6b04457c1b40ba6668a669b49d56" translate="yes" xml:space="preserve">
          <source>1) The time of the last modification of &lt;code&gt;p&lt;/code&gt;</source>
          <target state="translated">1) Время последней модификации &lt;code&gt;p&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="79302ea48e89e5dd8b66c9d489a0b5d0f35c2a34" translate="yes" xml:space="preserve">
          <source>1) The unary operation &lt;code&gt;unary_op&lt;/code&gt; is applied to the range defined by &lt;code&gt;[first1, last1)&lt;/code&gt;.</source>
          <target state="translated">1) &lt;code&gt;unary_op&lt;/code&gt; операция unary_op применяется к диапазону, определенному &lt;code&gt;[first1, last1)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="367330e87475392565d07397877349fb08e6bda2" translate="yes" xml:space="preserve">
          <source>1) The value &lt;code&gt;v&lt;/code&gt; stored in the shared state, as &lt;code&gt;std::move(v)&lt;/code&gt;.</source>
          <target state="translated">1) Значение &lt;code&gt;v&lt;/code&gt; хранится в общем состоянии как &lt;code&gt;std::move(v)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="86eb511f8878afb18a55683fb47df9cdcc07ce8f" translate="yes" xml:space="preserve">
          <source>1) The value of A is used as an operand of B, &lt;b&gt;except&lt;/b&gt;</source>
          <target state="translated">1) значение A используется как операнд B, &lt;b&gt;кроме&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="7811702fe1807599a0bc78db6abc9c5bbdecab5f" translate="yes" xml:space="preserve">
          <source>1) The value of the</source>
          <target state="translated">1)стоимость</target>
        </trans-unit>
        <trans-unit id="411cbaa6e8bdadb2ed80c96fcee27228278863bb" translate="yes" xml:space="preserve">
          <source>1) The value of the a parameter.</source>
          <target state="translated">1)Значение параметра.</target>
        </trans-unit>
        <trans-unit id="ba3ffa0db89ccb1cd6d655154c05da75ee6c8142" translate="yes" xml:space="preserve">
          <source>1) The value of the obtained character.</source>
          <target state="translated">1)Значение полученного символа.</target>
        </trans-unit>
        <trans-unit id="d34b7e1f53cc8550900ee8f2d0ed3e332b4489a8" translate="yes" xml:space="preserve">
          <source>1) The value returned by the selected invocation of the visitor.</source>
          <target state="translated">1)Значение,возвращаемое выбранным вызовом посетителя.</target>
        </trans-unit>
        <trans-unit id="12cff07a54521cd958ba1ef6524cdcabff900eb6" translate="yes" xml:space="preserve">
          <source>1) The version of this function in the non-specialized &lt;code&gt;&lt;a href=&quot;../pointer_traits&quot;&gt;std::pointer_traits&lt;/a&gt;&lt;/code&gt; template simply calls &lt;code&gt;Ptr::pointer_to(r)&lt;/code&gt;, and if Ptr does not provide a static member function &lt;code&gt;pointer_to&lt;/code&gt;, instantiation of this function is a compile-time error.</source>
          <target state="translated">1) Версия этой функции в неспециализированном шаблоне &lt;code&gt;&lt;a href=&quot;../pointer_traits&quot;&gt;std::pointer_traits&lt;/a&gt;&lt;/code&gt; просто вызывает &lt;code&gt;Ptr::pointer_to(r)&lt;/code&gt; , и если Ptr не предоставляет статическую функцию-член &lt;code&gt;pointer_to&lt;/code&gt; , создание этой функции является ошибкой во время компиляции.</target>
        </trans-unit>
        <trans-unit id="77538230530c6dca9afa92eaff1c01d3485f9dd2" translate="yes" xml:space="preserve">
          <source>1) There is no putback position in the get area (&lt;code&gt;pbackfail()&lt;/code&gt; is called with no arguments). In this situation, the purpose of &lt;code&gt;pbackfail()&lt;/code&gt; is to back up the get area by one character, if the associated character sequence allows this (e.g. a file-backed streambuf may reload the buffer from a file, starting one character earlier).</source>
          <target state="translated">1) В зоне get нет позиции возврата ( &lt;code&gt;pbackfail()&lt;/code&gt; вызывается без аргументов). В этой ситуации целью &lt;code&gt;pbackfail()&lt;/code&gt; является резервное копирование области получения на один символ, если соответствующая символьная последовательность позволяет это (например, потоковый буфер с файловой поддержкой может перезагрузить буфер из файла, начиная на один символ раньше).</target>
        </trans-unit>
        <trans-unit id="082233e2ccf1fae9f66efcf578a3583588a32ecb" translate="yes" xml:space="preserve">
          <source>1) There may be &lt;a href=&quot;definition#One_Definition_Rule&quot;&gt;more than one definition&lt;/a&gt; of an inline function or variable(since C++17) in the program as long as each definition appears in a different translation unit and (for non-static inline functions and variables(since C++17)) all definitions are identical. For example, an inline function or an inline variable(since C++17) may be defined in a header file that is #include'd in multiple source files.</source>
          <target state="translated">1) В программе может быть &lt;a href=&quot;definition#One_Definition_Rule&quot;&gt;несколько определений&lt;/a&gt; встроенной функции или переменной (начиная с C ++ 17), если каждое определение отображается в разных единицах перевода и (для нестатических встроенных функций и переменных (начиная с C +) +17)) все определения идентичны. Например, встроенная функция или встроенная переменная (начиная с C ++ 17) могут быть определены в заголовочном файле, который # include'd в нескольких исходных файлах.</target>
        </trans-unit>
        <trans-unit id="7d6e10081835eca22b9e463651b1d3a90697a7c7" translate="yes" xml:space="preserve">
          <source>1) This &lt;a href=&quot;../../../language/deduction_guide&quot;&gt;deduction guide&lt;/a&gt; is provided for &lt;code&gt;&lt;a href=&quot;../function&quot;&gt;std::function&lt;/a&gt;&lt;/code&gt; to allow deduction from functions.</source>
          <target state="translated">1) Это &lt;a href=&quot;../../../language/deduction_guide&quot;&gt;руководство&lt;/a&gt; по &lt;code&gt;&lt;a href=&quot;../function&quot;&gt;std::function&lt;/a&gt;&lt;/code&gt; предусмотрено для std :: function, чтобы разрешить вывод из функций.</target>
        </trans-unit>
        <trans-unit id="e77ab4d038ceec4a1c67d2938de66955af3e7eb7" translate="yes" xml:space="preserve">
          <source>1) This &lt;a href=&quot;../../language/deduction_guide&quot;&gt;deduction guide&lt;/a&gt; is provided for &lt;code&gt;&lt;a href=&quot;../basic_string&quot;&gt;std::basic_string&lt;/a&gt;&lt;/code&gt; to allow deduction from an iterator range. This overload only participates in overload resolution if &lt;code&gt;InputIt&lt;/code&gt; satisfies &lt;a href=&quot;../../named_req/inputiterator&quot;&gt;LegacyInputIterator&lt;/a&gt; and &lt;code&gt;Alloc&lt;/code&gt; satisfies &lt;a href=&quot;../../named_req/allocator&quot;&gt;Allocator&lt;/a&gt;.</source>
          <target state="translated">1) Это &lt;a href=&quot;../../language/deduction_guide&quot;&gt;руководство&lt;/a&gt; по &lt;code&gt;&lt;a href=&quot;../basic_string&quot;&gt;std::basic_string&lt;/a&gt;&lt;/code&gt; предусмотрено для std :: basic_string, чтобы разрешить вывод из диапазона итератора. Эта перегрузка участвует только в разрешении перегрузки, если &lt;code&gt;InputIt&lt;/code&gt; удовлетворяет &lt;a href=&quot;../../named_req/inputiterator&quot;&gt;LegacyInputIterator,&lt;/a&gt; а &lt;code&gt;Alloc&lt;/code&gt; удовлетворяет &lt;a href=&quot;../../named_req/allocator&quot;&gt;Allocator&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4e69d6a2bc178876f9e3235945528240ffcb9250" translate="yes" xml:space="preserve">
          <source>1) This overload only participates in overload resolution if T is not a specialization of std::pair. Returns &lt;code&gt;&lt;a href=&quot;../utility/tuple&quot;&gt;std::tuple&lt;/a&gt;&lt;/code&gt; determined as follows:</source>
          <target state="translated">1) Эта перегрузка участвует только в разрешении перегрузки, если T не является специализацией std :: pair. Возвращает &lt;code&gt;&lt;a href=&quot;../utility/tuple&quot;&gt;std::tuple&lt;/a&gt;&lt;/code&gt; определенный следующим образом:</target>
        </trans-unit>
        <trans-unit id="5fbbf8a15549659900cafa2f8939bbc4169ae318" translate="yes" xml:space="preserve">
          <source>1) Throws a &lt;code&gt;std::chrono::ambiguous_local_time&lt;/code&gt; if the conversion is ambiguous. Throws a &lt;code&gt;std::chrono::nonexistent_local_time&lt;/code&gt; if &lt;code&gt;tp&lt;/code&gt; represents a nonexistent time.</source>
          <target state="translated">1) Выдает &lt;code&gt;std::chrono::ambiguous_local_time&lt;/code&gt; если преобразование неоднозначно. Выдает &lt;code&gt;std::chrono::nonexistent_local_time&lt;/code&gt; если &lt;code&gt;tp&lt;/code&gt; представляет несуществующее время.</target>
        </trans-unit>
        <trans-unit id="2906ceaa024eb508139cc21c6337dbb9e099baa0" translate="yes" xml:space="preserve">
          <source>1) Throws an exception if the conversion is ambiguous or if &lt;code&gt;tp&lt;/code&gt; represents a nonexistent time.</source>
          <target state="translated">1) Выдает исключение, если преобразование неоднозначно или если &lt;code&gt;tp&lt;/code&gt; представляет несуществующее время.</target>
        </trans-unit>
        <trans-unit id="c11d4dcc55409becc8aa818ff21922ca67ab791c" translate="yes" xml:space="preserve">
          <source>1) Throws any exceptions thrown by &lt;code&gt;m.lock()&lt;/code&gt;</source>
          <target state="translated">1) Выдает любые исключения, &lt;code&gt;m.lock()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="843bb0e7d49c747ed1e190035bed5b051758038e" translate="yes" xml:space="preserve">
          <source>1) Throws any exceptions thrown by &lt;code&gt;m.lock()&lt;/code&gt;.</source>
          <target state="translated">1) Выдает любые исключения, &lt;code&gt;m.lock()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="50ee3b5d9f3ed3870841a5598217596f3a883f2a" translate="yes" xml:space="preserve">
          <source>1) Transfers all elements from &lt;code&gt;other&lt;/code&gt; into &lt;code&gt;*this&lt;/code&gt;. The elements are inserted before the element pointed to by &lt;code&gt;pos&lt;/code&gt;. The container &lt;code&gt;other&lt;/code&gt; becomes empty after the operation. The behavior is undefined if &lt;code&gt;other&lt;/code&gt; refers to the same object as &lt;code&gt;*this&lt;/code&gt;.</source>
          <target state="translated">1) Переносит все элементы из &lt;code&gt;other&lt;/code&gt; в &lt;code&gt;*this&lt;/code&gt; . Элементы вставляются перед элементом, указанным в &lt;code&gt;pos&lt;/code&gt; . Контейнер &lt;code&gt;other&lt;/code&gt; становится пустым после операции. Поведение не определено, если &lt;code&gt;other&lt;/code&gt; относится к тому же объекту, что и &lt;code&gt;*this&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6fff766c5a8c7a2f8e138a2e07caea5eb67929f1" translate="yes" xml:space="preserve">
          <source>1) Transfers ownership from &lt;code&gt;r&lt;/code&gt; to &lt;code&gt;*this&lt;/code&gt; as if by calling &lt;code&gt;reset(r.release())&lt;/code&gt; followed by an assignment of &lt;code&gt;&lt;a href=&quot;get_deleter&quot;&gt;get_deleter()&lt;/a&gt;&lt;/code&gt; from &lt;code&gt;&lt;a href=&quot;../../utility/forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;E&amp;gt;(r.get_deleter())&lt;/code&gt;.</source>
          <target state="translated">1) Переносит владение из &lt;code&gt;r&lt;/code&gt; в &lt;code&gt;*this&lt;/code&gt; как если бы он вызывал &lt;code&gt;reset(r.release())&lt;/code&gt; последующим присвоением &lt;code&gt;&lt;a href=&quot;get_deleter&quot;&gt;get_deleter()&lt;/a&gt;&lt;/code&gt; из &lt;code&gt;&lt;a href=&quot;../../utility/forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;E&amp;gt;(r.get_deleter())&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f0d222c1ebe564b2e355ea589fe01bb4acb55570" translate="yes" xml:space="preserve">
          <source>1) Trivial default constructor, initializes &lt;code&gt;&lt;a href=&quot;../atomic_flag&quot;&gt;std::atomic_flag&lt;/a&gt;&lt;/code&gt; to unspecified state.</source>
          <target state="translated">1) Простой конструктор по умолчанию, инициализирует &lt;code&gt;&lt;a href=&quot;../atomic_flag&quot;&gt;std::atomic_flag&lt;/a&gt;&lt;/code&gt; в неопределенное состояние.</target>
        </trans-unit>
        <trans-unit id="fae808fef90ab07a5794289ac4c023c5fa8d10a8" translate="yes" xml:space="preserve">
          <source>1) Turns off the &lt;code&gt;skipws&lt;/code&gt; flag on the input stream</source>
          <target state="translated">1) &lt;code&gt;skipws&lt;/code&gt; флаг skipws на входном потоке</target>
        </trans-unit>
        <trans-unit id="4dfdb643b8926ec8e33691a11829911540004f8c" translate="yes" xml:space="preserve">
          <source>1) Two possibly multilevel pointers to the same type may be converted between each other, regardless of cv-qualifiers at each level.</source>
          <target state="translated">1)Два возможно многоуровневых указателя одного и того же типа могут быть преобразованы между собой,независимо от cv-квалификаторов на каждом уровне.</target>
        </trans-unit>
        <trans-unit id="b27ef1c6720ded3dab7eb347fb4e754d45f36dfc" translate="yes" xml:space="preserve">
          <source>1) Typical declaration of a destructor</source>
          <target state="translated">1)Типичное объявление деструктора</target>
        </trans-unit>
        <trans-unit id="c4708cafcd797737afa27ba9753427840fb5b5fb" translate="yes" xml:space="preserve">
          <source>1) Unary right fold (E op ...) becomes (E</source>
          <target state="translated">1)Неправильный правый сгиб (E op...)становится (E</target>
        </trans-unit>
        <trans-unit id="257eeefa2a69c169c4e78577629e312d119acf41" translate="yes" xml:space="preserve">
          <source>1) Underflow occurs (and &lt;code&gt;&lt;a href=&quot;../../numeric/fenv/fe_exceptions&quot;&gt;FE_UNDERFLOW&lt;/a&gt;&lt;/code&gt; may be raised) if a computation produces a result whose absolute value, computed as though both the exponent range and the precision were unbounded, is smaller than &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::min()&lt;/code&gt;. Such implementation detects tinyness before rounding (e.g. UltraSparc, POWER).</source>
          <target state="translated">1) Переполнение происходит (и &lt;code&gt;&lt;a href=&quot;../../numeric/fenv/fe_exceptions&quot;&gt;FE_UNDERFLOW&lt;/a&gt;&lt;/code&gt; может быть повышен), если вычисление дает результат, абсолютное значение которого, вычисленное так, как если бы диапазон экспоненты и точность были неограниченными, меньше, чем &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::min()&lt;/code&gt; . Такая реализация обнаруживает крошечность перед округлением (например, UltraSparc, POWER).</target>
        </trans-unit>
        <trans-unit id="5cd6d3f996be4c51f3f6895463d6cd072a7b915f" translate="yes" xml:space="preserve">
          <source>1) Unlinks the node that contains the element pointed to by &lt;code&gt;position&lt;/code&gt; and returns a &lt;a href=&quot;../node_handle&quot;&gt;node handle&lt;/a&gt; that owns it</source>
          <target state="translated">1) Отсоединяет узел, который содержит элемент, на который указывает &lt;code&gt;position&lt;/code&gt; и возвращает &lt;a href=&quot;../node_handle&quot;&gt;дескриптор узла&lt;/a&gt; , которому он принадлежит</target>
        </trans-unit>
        <trans-unit id="6f8ce56ad604ec015f939e3d33efff5a54fb49aa" translate="yes" xml:space="preserve">
          <source>1) Unspecified (typically same as &lt;code&gt;Ptr::pointer_to&lt;/code&gt;)</source>
          <target state="translated">1) Не указано (обычно то же самое, что и &lt;code&gt;Ptr::pointer_to&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="2316f7e9cdbdf01d620f24a734118320daa43c7c" translate="yes" xml:space="preserve">
          <source>1) Used to obtain the iterator type of the type &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">1) Используется для получения типа итератора типа &lt;code&gt;T&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4cb8f5cd2ca3417e49783847dbe0430c7912497b" translate="yes" xml:space="preserve">
          <source>1) Value of the &lt;a href=&quot;../directory_entry&quot;&gt;&lt;code&gt;directory_entry&lt;/code&gt;&lt;/a&gt; referred to by this iterator</source>
          <target state="translated">1) Значение &lt;a href=&quot;../directory_entry&quot;&gt; &lt;code&gt;directory_entry&lt;/code&gt; ,на которое&lt;/a&gt; ссылается этот итератор</target>
        </trans-unit>
        <trans-unit id="aba73510e6e868d87c0be08e6f8342096504cd67" translate="yes" xml:space="preserve">
          <source>1) When a named &lt;a href=&quot;reference#Lvalue_references&quot;&gt;lvalue reference&lt;/a&gt; variable is declared with an initializer</source>
          <target state="translated">1) Когда именованная &lt;a href=&quot;reference#Lvalue_references&quot;&gt;ссылочная&lt;/a&gt; переменная lvalue объявляется с инициализатором</target>
        </trans-unit>
        <trans-unit id="d0bcc30ae3863a5e08bd6f03dc42a4e874ce1e74" translate="yes" xml:space="preserve">
          <source>1) When class member declarations and member function type declarations appear in a &lt;code&gt;&quot;C&quot;&lt;/code&gt; language block, their linkage remains &lt;code&gt;&quot;C++&quot;&lt;/code&gt;.</source>
          <target state="translated">1) Когда объявления членов класса и объявления типов функций-членов появляются в языковом блоке &lt;code&gt;&quot;C&quot;&lt;/code&gt; , их связь остается &lt;code&gt;&quot;C++&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b3820fb6503add189fb9d0185eccf94528cea1c0" translate="yes" xml:space="preserve">
          <source>1) When the</source>
          <target state="translated">1)Когда</target>
        </trans-unit>
        <trans-unit id="7b36527e4c99ad21a3b5acc56406892e9699bef5" translate="yes" xml:space="preserve">
          <source>1) Whenever backslash appears at the end of a line (immediately followed by the newline character), both backslash and newline are deleted, combining two physical source lines into one logical source line. This is a single-pass operation; a line ending in two backslashes followed by an empty line does not combine three lines into one. If a universal character name (&lt;code&gt;\uXXXX&lt;/code&gt;) is formed in this phase, the behavior is undefined.</source>
          <target state="translated">1) Всякий раз, когда обратная косая черта появляется в конце строки (сразу после которой следует символ новой строки), как обратная косая черта, так и новая строка удаляются, объединяя две строки физического источника в одну строку логического источника. Это однопроходная операция; строка, заканчивающаяся двумя обратными слешами, за которыми следует пустая строка, не объединяет три строки в одну. Если на этом этапе формируется универсальное имя символа ( &lt;code&gt;\uXXXX&lt;/code&gt; ), поведение не определено.</target>
        </trans-unit>
        <trans-unit id="84212c704512f8a7c5c7f860970eb1e0b2a423f0" translate="yes" xml:space="preserve">
          <source>1) Within the body of any non-static &lt;a href=&quot;member_functions&quot;&gt;member function&lt;/a&gt;, including &lt;a href=&quot;constructor&quot;&gt;member initializer list&lt;/a&gt;</source>
          <target state="translated">1) В теле любой нестатической &lt;a href=&quot;member_functions&quot;&gt;функции&lt;/a&gt; - члена , включая &lt;a href=&quot;constructor&quot;&gt;список инициализатора элемента&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="575e5597bcb538c0ad9a57aef9059faafb04f903" translate="yes" xml:space="preserve">
          <source>1) Wraps a non-const member function with no parameters.</source>
          <target state="translated">1)Обертывает функцию,не являющуюся членом константы,без параметров.</target>
        </trans-unit>
        <trans-unit id="7d767b3af0e8610ce09659c8206561af10fa3322" translate="yes" xml:space="preserve">
          <source>1) Writes a textual representation of the distribution parameters and internal state to &lt;code&gt;ost&lt;/code&gt; as textual representation. The formatting flags and fill character of &lt;code&gt;ost&lt;/code&gt; are unchanged.</source>
          <target state="translated">1) Записывает текстовое представление параметров распределения и внутреннее состояние в &lt;code&gt;ost&lt;/code&gt; как текстовое представление. Флаги форматирования и символ заполнения &lt;code&gt;ost&lt;/code&gt; неизменны.</target>
        </trans-unit>
        <trans-unit id="d9c461a040145efb71a7d3ac968e14b99a1e726a" translate="yes" xml:space="preserve">
          <source>1) Writes performed by the same thread that performed A</source>
          <target state="translated">1)Письма,выполненные той же самой нитью,что и A</target>
        </trans-unit>
        <trans-unit id="0a2b6a35046c21b8b1cdded7e012e4e02b54a352" translate="yes" xml:space="preserve">
          <source>1) Writes the bitset &lt;code&gt;x&lt;/code&gt; to the character stream &lt;code&gt;os&lt;/code&gt; as if by first converting it to a &lt;code&gt;basic_string&amp;lt;CharT,Traits&amp;gt;&lt;/code&gt; using &lt;code&gt;&lt;a href=&quot;to_string&quot;&gt;to_string()&lt;/a&gt;&lt;/code&gt;, and then writing it into &lt;code&gt;os&lt;/code&gt; using the &lt;a href=&quot;../../string/basic_string/operator_ltltgtgt&quot;&gt;&lt;code&gt;operator&amp;lt;&amp;lt;&lt;/code&gt;&lt;/a&gt; (which is a &lt;a href=&quot;../../named_req/formattedoutputfunction&quot;&gt;FormattedOutputFunction&lt;/a&gt; for strings). The characters to use for ones and zeroes are obtained from the currently-imbued locale by calling &lt;code&gt;&lt;a href=&quot;../../locale/use_facet&quot;&gt;std::use_facet&lt;/a&gt;&amp;lt;&lt;a href=&quot;../../locale/ctype&quot;&gt;std::ctype&lt;/a&gt;&amp;lt;CharT&amp;gt;(os.getloc()).widen()&lt;/code&gt; with &lt;code&gt;'1'&lt;/code&gt; and &lt;code&gt;'0'&lt;/code&gt; as arguments.</source>
          <target state="translated">1) Записывает BitSet &lt;code&gt;x&lt;/code&gt; в поток символов &lt;code&gt;os&lt;/code&gt; , как если бы сначала путем преобразования его в &lt;code&gt;basic_string&amp;lt;CharT,Traits&amp;gt;&lt;/code&gt; с помощью &lt;code&gt;&lt;a href=&quot;to_string&quot;&gt;to_string()&lt;/a&gt;&lt;/code&gt; , а затем записывает их в &lt;code&gt;os&lt;/code&gt; с помощью &lt;a href=&quot;../../string/basic_string/operator_ltltgtgt&quot;&gt; &lt;code&gt;operator&amp;lt;&amp;lt;&lt;/code&gt; &lt;/a&gt; (который является &lt;a href=&quot;../../named_req/formattedoutputfunction&quot;&gt;FormattedOutputFunction&lt;/a&gt; для строк). Символы, используемые для единиц и нулей, получаются из текущей локали, вызывая &lt;code&gt;&lt;a href=&quot;../../locale/use_facet&quot;&gt;std::use_facet&lt;/a&gt;&amp;lt;&lt;a href=&quot;../../locale/ctype&quot;&gt;std::ctype&lt;/a&gt;&amp;lt;CharT&amp;gt;(os.getloc()).widen()&lt;/code&gt; с &lt;code&gt;'1'&lt;/code&gt; и &lt;code&gt;'0'&lt;/code&gt; как аргументы.</target>
        </trans-unit>
        <trans-unit id="db026f9be530b92309db59bd7e0e007f78c55584" translate="yes" xml:space="preserve">
          <source>1) Writes the results to &lt;code&gt;&lt;a href=&quot;../c&quot;&gt;stdout&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">1) Записывает результаты в стандартный &lt;code&gt;&lt;a href=&quot;../c&quot;&gt;stdout&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9ca66f352a8a2c3fbfbb18ec52c430b1d4c5c3b4" translate="yes" xml:space="preserve">
          <source>1) Writes to &lt;code&gt;os&lt;/code&gt; the complex number in the form &lt;code&gt;(real,imaginary)&lt;/code&gt;.</source>
          <target state="translated">1) Записывает &lt;code&gt;os&lt;/code&gt; комплексное число в виде &lt;code&gt;(real,imaginary)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ccfe5f32416ac78a6db71cb95900b356b4fac608" translate="yes" xml:space="preserve">
          <source>1) Yields the size in bytes of the &lt;a href=&quot;objects&quot;&gt;object representation&lt;/a&gt; of type.</source>
          <target state="translated">1) Возвращает размер в байтах &lt;a href=&quot;objects&quot;&gt;объектного представления&lt;/a&gt; типа.</target>
        </trans-unit>
        <trans-unit id="bf3ab90f79f6983b5959522a0d973a0239a4ed67" translate="yes" xml:space="preserve">
          <source>1) a copy of the &lt;code&gt;std::chrono::month&lt;/code&gt; object stored in &lt;code&gt;*this&lt;/code&gt;</source>
          <target state="translated">1) копия объекта &lt;code&gt;std::chrono::month&lt;/code&gt; хранящаяся в &lt;code&gt;*this&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f9872d13b34d100347a4789dbcf716915a245364" translate="yes" xml:space="preserve">
          <source>1) a copy of the argument, &lt;code&gt;&lt;a href=&quot;../complex&quot;&gt;std::complex&lt;/a&gt;&amp;lt;T&amp;gt;(val)&lt;/code&gt;</source>
          <target state="translated">1) копия аргумента, &lt;code&gt;&lt;a href=&quot;../complex&quot;&gt;std::complex&lt;/a&gt;&amp;lt;T&amp;gt;(val)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5641277263a9a2b3de3620beebf734b8386a9a9d" translate="yes" xml:space="preserve">
          <source>1) a copy of the underlying string object.</source>
          <target state="translated">1)копия объекта базовой строки.</target>
        </trans-unit>
        <trans-unit id="5c3bdc31cd27db3964c2112a2726a87812d74790" translate="yes" xml:space="preserve">
          <source>1) a copy of this duration object</source>
          <target state="translated">1)копия объекта длительности</target>
        </trans-unit>
        <trans-unit id="038d7ce390c65cda2b59d3877a61b171fd122d75" translate="yes" xml:space="preserve">
          <source>1) a declaration of a class member</source>
          <target state="translated">1)декларация члена класса</target>
        </trans-unit>
        <trans-unit id="d9e22ca8e57fb001efaf8220898429709ee9f67f" translate="yes" xml:space="preserve">
          <source>1) a variable &lt;code&gt;x&lt;/code&gt; in a</source>
          <target state="translated">1) переменная &lt;code&gt;x&lt;/code&gt; в</target>
        </trans-unit>
        <trans-unit id="2b6abfcba2f16f34c4b766c8332a1b0e568f8205" translate="yes" xml:space="preserve">
          <source>1) addition</source>
          <target state="translated">1)добавление</target>
        </trans-unit>
        <trans-unit id="a2d89e8d3bf7717ac619bee8df3e581c758d7c08" translate="yes" xml:space="preserve">
          <source>1) additional &lt;a href=&quot;../../named_req/defaultinsertable&quot;&gt;default-inserted&lt;/a&gt; elements are appended</source>
          <target state="translated">1) добавляются дополнительные &lt;a href=&quot;../../named_req/defaultinsertable&quot;&gt;вставленные по умолчанию&lt;/a&gt; элементы</target>
        </trans-unit>
        <trans-unit id="ac7f27c304fab3327d4825700e7346a78e13d81e" translate="yes" xml:space="preserve">
          <source>1) additional &lt;a href=&quot;../../named_req/defaultinsertable&quot;&gt;default-inserted&lt;/a&gt; elements are appended 2) additional copies of &lt;code&gt;value&lt;/code&gt; are appended</source>
          <target state="translated">1) дополнительные &lt;a href=&quot;../../named_req/defaultinsertable&quot;&gt;стандартные вставленные&lt;/a&gt; элементы добавляются 2) дополнительные копии &lt;code&gt;value&lt;/code&gt; добавляется</target>
        </trans-unit>
        <trans-unit id="6430a3b1d8a483dd3a81fb0ac4d2a6320ef9e24a" translate="yes" xml:space="preserve">
          <source>1) adds both &lt;code&gt;const&lt;/code&gt; and &lt;code&gt;volatile&lt;/code&gt;.</source>
          <target state="translated">1) добавляет как &lt;code&gt;const&lt;/code&gt; ,так и &lt;code&gt;volatile&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d59d7e196d66c2c5698b37c5fed11d45adb3fba0" translate="yes" xml:space="preserve">
          <source>1) amortized constant</source>
          <target state="translated">1)амортизированная постоянная</target>
        </trans-unit>
        <trans-unit id="fec155bd296ef9eab4b5d4cff65799934437e2a4" translate="yes" xml:space="preserve">
          <source>1) an &lt;a href=&quot;../language/throw&quot;&gt;exception is thrown&lt;/a&gt; and not caught (it is implementation-defined whether any stack unwinding is done in this case)</source>
          <target state="translated">1) &lt;a href=&quot;../language/throw&quot;&gt;исключение выдается&lt;/a&gt; и не перехватывается (определяется реализацией, выполняется ли в этом случае разматывание стека)</target>
        </trans-unit>
        <trans-unit id="0795e639e2d423d045556b10922218964d38d551" translate="yes" xml:space="preserve">
          <source>1) array length is negative.</source>
          <target state="translated">1)длина массива отрицательна.</target>
        </trans-unit>
        <trans-unit id="b0fb04259e9dabc8e1469a331eb44c9e0e5ae305" translate="yes" xml:space="preserve">
          <source>1) as soon as atomic operations that are not tagged &lt;code&gt;memory_order_seq_cst&lt;/code&gt; enter the picture, the sequential consistency guarantee for the program is lost 2) in many cases, &lt;code&gt;memory_order_seq_cst&lt;/code&gt; atomic operations are reorderable with respect to other atomic operations performed by the same thread</source>
          <target state="translated">1) как только &lt;code&gt;memory_order_seq_cst&lt;/code&gt; операции, которые не помечены как memory_order_seq_cst, входят в изображение, гарантия последовательной согласованности программы теряется 2) во многих случаях &lt;code&gt;memory_order_seq_cst&lt;/code&gt; операции memory_order_seq_cst переупорядочиваются относительно других элементарных операций, выполняемых тем же потоком</target>
        </trans-unit>
        <trans-unit id="2e8ab0d12b743aef878ea9e6130cac353570c696" translate="yes" xml:space="preserve">
          <source>1) as soon as atomic operations that are not tagged &lt;code&gt;memory_order_seq_cst&lt;/code&gt; enter the picture, the sequential consistency is lost 2) the sequentially-consistent fences are only establishing total ordering for the fences themselves, not for the atomic operations in the general case (</source>
          <target state="translated">1) как только &lt;code&gt;memory_order_seq_cst&lt;/code&gt; операции, которые не помечены как memory_order_seq_cst, входят в изображение, последовательная согласованность теряется 2) последовательно согласованные ограждения устанавливают только полное упорядочение для самих ограждений, а не для атомарных операций в общем случае (</target>
        </trans-unit>
        <trans-unit id="27196f9d734245d194416b40b601d5214e843c87" translate="yes" xml:space="preserve">
          <source>1) base template</source>
          <target state="translated">1)базовый шаблон</target>
        </trans-unit>
        <trans-unit id="cb41c99c432b78323d4f377b74a0c397256353fa" translate="yes" xml:space="preserve">
          <source>1) bitwise NOT</source>
          <target state="translated">1)побитовым методом НЕ</target>
        </trans-unit>
        <trans-unit id="f724933955aea428b179d4bd6c5ef4df12c510d5" translate="yes" xml:space="preserve">
          <source>1) buffer state, a bitmask type which can represent any combination of the four values &quot;allocated&quot; (destructor will deallocate), &quot;constant&quot; (output not allowed), &quot;dynamic&quot; (output may reallocate), or &quot;frozen&quot; (deallocation and reallocation are not allowed)</source>
          <target state="translated">1)состояние буфера,тип битовой маски,которая может представлять собой любую комбинацию из четырех значений &quot;выделено&quot; (деструктор будет перераспределять),&quot;константа&quot; (вывод не разрешен),&quot;динамический&quot; (вывод может перераспределять)или &quot;заморожено&quot; (перераспределение и перераспределение не разрешено)</target>
        </trans-unit>
        <trans-unit id="9bd596e30c7448227178639da643b5d2845998b0" translate="yes" xml:space="preserve">
          <source>1) by the members and friends of &lt;code&gt;Base&lt;/code&gt;</source>
          <target state="translated">1) членами и друзьями &lt;code&gt;Base&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="de134b2dabb1a0cc9228c6962d95367bc50eab97" translate="yes" xml:space="preserve">
          <source>1) calls &lt;code&gt;&lt;a href=&quot;../byte/strtof&quot;&gt;std::strtod&lt;/a&gt;(str.c_str(), &amp;amp;ptr)&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../wide/wcstof&quot;&gt;std::wcstod&lt;/a&gt;(str.c_str(), &amp;amp;ptr)&lt;/code&gt;</source>
          <target state="translated">1) вызывает &lt;code&gt;&lt;a href=&quot;../byte/strtof&quot;&gt;std::strtod&lt;/a&gt;(str.c_str(), &amp;amp;ptr)&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;../wide/wcstof&quot;&gt;std::wcstod&lt;/a&gt;(str.c_str(), &amp;amp;ptr)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c34ba446a37c84b0cf54a590242f4ba5233f98dd" translate="yes" xml:space="preserve">
          <source>1) calls &lt;code&gt;&lt;a href=&quot;../byte/strtof&quot;&gt;std::strtof&lt;/a&gt;(str.c_str(), &amp;amp;ptr)&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../wide/wcstof&quot;&gt;std::wcstof&lt;/a&gt;(str.c_str(), &amp;amp;ptr)&lt;/code&gt;</source>
          <target state="translated">1) вызывает &lt;code&gt;&lt;a href=&quot;../byte/strtof&quot;&gt;std::strtof&lt;/a&gt;(str.c_str(), &amp;amp;ptr)&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;../wide/wcstof&quot;&gt;std::wcstof&lt;/a&gt;(str.c_str(), &amp;amp;ptr)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="77e091034262c03ebbe67a594c859ba4cd168524" translate="yes" xml:space="preserve">
          <source>1) calls &lt;code&gt;&lt;a href=&quot;../byte/strtol&quot;&gt;std::strtol&lt;/a&gt;(str.c_str(), &amp;amp;ptr, base)&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../wide/wcstol&quot;&gt;std::wcstol&lt;/a&gt;(str.c_str(), &amp;amp;ptr, base)&lt;/code&gt;</source>
          <target state="translated">1) вызывает &lt;code&gt;&lt;a href=&quot;../byte/strtol&quot;&gt;std::strtol&lt;/a&gt;(str.c_str(), &amp;amp;ptr, base)&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;../wide/wcstol&quot;&gt;std::wcstol&lt;/a&gt;(str.c_str(), &amp;amp;ptr, base)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="26e3683b3a1f07d2796ab25306d2631c55c16c20" translate="yes" xml:space="preserve">
          <source>1) calls &lt;code&gt;&lt;a href=&quot;../byte/strtoul&quot;&gt;std::strtoul&lt;/a&gt;(str.c_str(), &amp;amp;ptr, base)&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../wide/wcstoul&quot;&gt;std::wcstoul&lt;/a&gt;(str.c_str(), &amp;amp;ptr, base)&lt;/code&gt;</source>
          <target state="translated">1) вызывает &lt;code&gt;&lt;a href=&quot;../byte/strtoul&quot;&gt;std::strtoul&lt;/a&gt;(str.c_str(), &amp;amp;ptr, base)&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;../wide/wcstoul&quot;&gt;std::wcstoul&lt;/a&gt;(str.c_str(), &amp;amp;ptr, base)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="aaa2f9b040d07d7262ac1b6d9ffdb1abe31c9d94" translate="yes" xml:space="preserve">
          <source>1) calls &lt;code&gt;buf.set_emit_on_sync(true)&lt;/code&gt;</source>
          <target state="translated">1) вызывает &lt;code&gt;buf.set_emit_on_sync(true)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c82f9dfecce0de1545c8b1bc95f3a2951730d87a" translate="yes" xml:space="preserve">
          <source>1) comma-separated list of arbitrary expressions and braced-init-lists in parentheses</source>
          <target state="translated">1)разделенный запятыми список произвольных выражений и заключенные в скобки списки в квадратных скобках</target>
        </trans-unit>
        <trans-unit id="292744bfc0b144652fe365e89093b1f3f3546203" translate="yes" xml:space="preserve">
          <source>1) conjunctions</source>
          <target state="translated">1)соединения</target>
        </trans-unit>
        <trans-unit id="a27605e813fa2e284a617a94d0b1c02a41db1130" translate="yes" xml:space="preserve">
          <source>1) constant</source>
          <target state="translated">1)постоянная</target>
        </trans-unit>
        <trans-unit id="04557674944b51204be3247544693f0e0724501f" translate="yes" xml:space="preserve">
          <source>1) constructs an object of type &lt;code&gt;&lt;a href=&quot;../../types/decay&quot;&gt;std::decay_t&lt;/a&gt;&amp;lt;ValueType&amp;gt;&lt;/code&gt;, &lt;a href=&quot;../../language/direct_initialization&quot;&gt;direct-non-list-initialized&lt;/a&gt; from &lt;code&gt;&lt;a href=&quot;../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;Args&amp;gt;(args)...&lt;/code&gt;, as the contained object. This overload only participates in overload resolution if &lt;code&gt;&lt;a href=&quot;../../types/is_constructible&quot;&gt;std::is_constructible_v&lt;/a&gt;&amp;lt;&lt;a href=&quot;../../types/decay&quot;&gt;std::decay_t&lt;/a&gt;&amp;lt;ValueType&amp;gt;, Args...&amp;gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../../types/is_copy_constructible&quot;&gt;std::is_copy_constructible_v&lt;/a&gt;&amp;lt;&lt;a href=&quot;../../types/decay&quot;&gt;std::decay_t&lt;/a&gt;&amp;lt;ValueType&amp;gt;&amp;gt;&lt;/code&gt; are both &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">1) создает объект типа &lt;code&gt;&lt;a href=&quot;../../types/decay&quot;&gt;std::decay_t&lt;/a&gt;&amp;lt;ValueType&amp;gt;&lt;/code&gt; , &lt;a href=&quot;../../language/direct_initialization&quot;&gt;прямой инициализированный без списка&lt;/a&gt; из &lt;code&gt;&lt;a href=&quot;../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;Args&amp;gt;(args)...&lt;/code&gt; , как содержащийся объект. Эта перегрузка участвует только в разрешении перегрузки, если &lt;code&gt;&lt;a href=&quot;../../types/is_constructible&quot;&gt;std::is_constructible_v&lt;/a&gt;&amp;lt;&lt;a href=&quot;../../types/decay&quot;&gt;std::decay_t&lt;/a&gt;&amp;lt;ValueType&amp;gt;, Args...&amp;gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;../../types/is_copy_constructible&quot;&gt;std::is_copy_constructible_v&lt;/a&gt;&amp;lt;&lt;a href=&quot;../../types/decay&quot;&gt;std::decay_t&lt;/a&gt;&amp;lt;ValueType&amp;gt;&amp;gt;&lt;/code&gt; имеют значение &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ecf7299f36a57142311fe5ff018991aec05d1d9b" translate="yes" xml:space="preserve">
          <source>1) counts the elements that are equal to &lt;code&gt;value&lt;/code&gt;.</source>
          <target state="translated">1) считает элементы, равные &lt;code&gt;value&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="78923f4701cc466ff69a7e4c618b38c216680976" translate="yes" xml:space="preserve">
          <source>1) creates a facet with starting reference count &lt;code&gt;refs&lt;/code&gt;. If &lt;code&gt;refs&lt;/code&gt; is non-zero, the facet will not be deleted when the last locale referencing it goes out of scope. A facet with static or dynamic storage duration should always be constructed with a non-zero &lt;code&gt;refs&lt;/code&gt;.</source>
          <target state="translated">1) создает фаску с началом счетчика ссылок &lt;code&gt;refs&lt;/code&gt; . Если &lt;code&gt;refs&lt;/code&gt; не равен нулю, фасет не будет удален, когда последняя локаль, ссылающаяся на него, выйдет из области видимости. Фасет со статической или динамической продолжительностью хранения всегда должен быть создан с ненулевыми &lt;code&gt;refs&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="16f7bc88ebe12e9f46129bbcbe37a17442c63648" translate="yes" xml:space="preserve">
          <source>1) current maximum load factor.</source>
          <target state="translated">1)коэффициент максимальной нагрузки по току.</target>
        </trans-unit>
        <trans-unit id="020d736193c4f224afbc308288813ddd03120330" translate="yes" xml:space="preserve">
          <source>1) declares a scoped enumeration type whose underlying type is &lt;code&gt;int&lt;/code&gt; (the keywords &lt;code&gt;class&lt;/code&gt; and &lt;code&gt;struct&lt;/code&gt; are exactly equivalent) 2) declares a scoped enumeration type whose underlying type is type3) opaque enum declaration for a scoped enumeration whose underlying type is &lt;code&gt;int&lt;/code&gt;4) opaque enum declaration for a scoped enumeration whose underlying type is type</source>
          <target state="translated">1) объявляет тип перечисления с ограниченным диапазоном, базовый тип которого равен &lt;code&gt;int&lt;/code&gt; (ключевые слова &lt;code&gt;class&lt;/code&gt; и &lt;code&gt;struct&lt;/code&gt; точно эквивалентны) 2) объявляет тип перечисления с ограниченным объемом, базовый тип которого равен type3) объявление непрозрачного перечисления для перечисления с ограниченным диапазоном, базовый тип которого равен &lt;code&gt;int&lt;/code&gt; 4) opaque объявление enum для перечисления с областью действия, базовым типом которого является тип</target>
        </trans-unit>
        <trans-unit id="9a00831c1516deb4278ae9da70bb95962035c0b1" translate="yes" xml:space="preserve">
          <source>1) default constructor: creates an object of type &lt;code&gt;&lt;a href=&quot;../id&quot;&gt;std::locale::id&lt;/a&gt;&lt;/code&gt; with implementation-specific content.</source>
          <target state="translated">1) конструктор по умолчанию: создает объект типа &lt;code&gt;&lt;a href=&quot;../id&quot;&gt;std::locale::id&lt;/a&gt;&lt;/code&gt; с контентом для конкретной реализации.</target>
        </trans-unit>
        <trans-unit id="dde1237e4c299d5a88703d284c2d9f1b0330d7bc" translate="yes" xml:space="preserve">
          <source>1) destructors of objects with static storage duration are called in reverse order of completion of their constructors or the completion of their &lt;a href=&quot;../../language/initialization#Dynamic_initialization&quot;&gt;dynamic initialization&lt;/a&gt;, and the functions passed to &lt;code&gt;&lt;a href=&quot;atexit&quot;&gt;std::atexit&lt;/a&gt;&lt;/code&gt; are called in reverse order they are registered (last one first). a) any static objects whose initialization was completed before the call to &lt;code&gt;&lt;a href=&quot;atexit&quot;&gt;std::atexit&lt;/a&gt;&lt;/code&gt; for some function F will be destroyed after the call to F during program termination. b) any static objects whose construction began after the call to &lt;code&gt;&lt;a href=&quot;atexit&quot;&gt;std::atexit&lt;/a&gt;&lt;/code&gt; for some function F will be destroyed before the call to F during program termination (this includes the case where &lt;code&gt;&lt;a href=&quot;atexit&quot;&gt;std::atexit&lt;/a&gt;&lt;/code&gt; was called from the constructor of the static object)</source>
          <target state="translated">1) деструкторы объектов со статической длительностью хранения вызываются в обратном порядке завершения их конструкторов или завершения их &lt;a href=&quot;../../language/initialization#Dynamic_initialization&quot;&gt;динамической инициализации&lt;/a&gt; , а функции, передаваемые в &lt;code&gt;&lt;a href=&quot;atexit&quot;&gt;std::atexit&lt;/a&gt;&lt;/code&gt; , вызываются в обратном порядке их регистрации (последний - первый). a) любые статические объекты, инициализация которых была завершена до вызова &lt;code&gt;&lt;a href=&quot;atexit&quot;&gt;std::atexit&lt;/a&gt;&lt;/code&gt; для некоторой функции F, будут уничтожены после вызова F во время завершения программы. б) любые статические объекты, создание которых началось после вызова &lt;code&gt;&lt;a href=&quot;atexit&quot;&gt;std::atexit&lt;/a&gt;&lt;/code&gt; для некоторой функции F, будут уничтожены до вызова F во время завершения программы (это включает случай, когда &lt;code&gt;&lt;a href=&quot;atexit&quot;&gt;std::atexit&lt;/a&gt;&lt;/code&gt; был вызван из конструктора статического объекта )</target>
        </trans-unit>
        <trans-unit id="dcf7f086d26c92140d5665521d6f972ea28b4075" translate="yes" xml:space="preserve">
          <source>1) elaborated type specifier for a class type</source>
          <target state="translated">1)разработанный спецификатор типа для типа класса</target>
        </trans-unit>
        <trans-unit id="6160fe4e565fb3d9b2b12c87b05a83e491dcc6e4" translate="yes" xml:space="preserve">
          <source>1) enables the &lt;code&gt;showbase&lt;/code&gt; flag in the stream &lt;code&gt;str&lt;/code&gt; as if by calling &lt;code&gt;str.setf(&lt;a href=&quot;../ios_base/fmtflags&quot;&gt;std::ios_base::showbase&lt;/a&gt;)&lt;/code&gt;.</source>
          <target state="translated">1) позволяет &lt;code&gt;showbase&lt;/code&gt; флаг в потоке &lt;code&gt;str&lt;/code&gt; как при вызове &lt;code&gt;str.setf(&lt;a href=&quot;../ios_base/fmtflags&quot;&gt;std::ios_base::showbase&lt;/a&gt;)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3c9bb54bfcf8d4b0934ee7a2b61ffada58ca8f70" translate="yes" xml:space="preserve">
          <source>1) enables the &lt;code&gt;showpoint&lt;/code&gt; flag in the stream &lt;code&gt;str&lt;/code&gt; as if by calling &lt;code&gt;str.setf(&lt;a href=&quot;../ios_base/fmtflags&quot;&gt;std::ios_base::showpoint&lt;/a&gt;)&lt;/code&gt;</source>
          <target state="translated">1) включает флаг &lt;code&gt;showpoint&lt;/code&gt; в потоке &lt;code&gt;str&lt;/code&gt; , как если бы он вызывал &lt;code&gt;str.setf(&lt;a href=&quot;../ios_base/fmtflags&quot;&gt;std::ios_base::showpoint&lt;/a&gt;)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5cbc68830f2af6be690ee57ddb1a020743ee8a1f" translate="yes" xml:space="preserve">
          <source>1) enables the &lt;code&gt;showpos&lt;/code&gt; flag in the stream &lt;code&gt;str&lt;/code&gt; as if by calling &lt;code&gt;str.setf(&lt;a href=&quot;../ios_base/fmtflags&quot;&gt;std::ios_base::showpos&lt;/a&gt;)&lt;/code&gt;.</source>
          <target state="translated">1) включает флаг &lt;code&gt;showpos&lt;/code&gt; в потоке &lt;code&gt;str&lt;/code&gt; как будто путем вызова &lt;code&gt;str.setf(&lt;a href=&quot;../ios_base/fmtflags&quot;&gt;std::ios_base::showpos&lt;/a&gt;)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ec4fee75897569d1ba002fd796b242776e66d768" translate="yes" xml:space="preserve">
          <source>1) enables the &lt;code&gt;skipws&lt;/code&gt; flag in the stream &lt;code&gt;str&lt;/code&gt; as if by calling &lt;code&gt;str.setf(&lt;a href=&quot;../ios_base/fmtflags&quot;&gt;std::ios_base::skipws&lt;/a&gt;)&lt;/code&gt;.</source>
          <target state="translated">1) включает флаг &lt;code&gt;skipws&lt;/code&gt; в потоке &lt;code&gt;str&lt;/code&gt; , как будто вызывая &lt;code&gt;str.setf(&lt;a href=&quot;../ios_base/fmtflags&quot;&gt;std::ios_base::skipws&lt;/a&gt;)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e78cc3813053d3dcc3353f63d38c9f3c40480169" translate="yes" xml:space="preserve">
          <source>1) enables the &lt;code&gt;unitbuf&lt;/code&gt; flag in the stream &lt;code&gt;str&lt;/code&gt; as if by calling &lt;code&gt;str.setf(&lt;a href=&quot;../ios_base/fmtflags&quot;&gt;std::ios_base::unitbuf&lt;/a&gt;)&lt;/code&gt;.</source>
          <target state="translated">1) включает флаг &lt;code&gt;unitbuf&lt;/code&gt; в потоке &lt;code&gt;str&lt;/code&gt; как будто вызывая &lt;code&gt;str.setf(&lt;a href=&quot;../ios_base/fmtflags&quot;&gt;std::ios_base::unitbuf&lt;/a&gt;)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e6c512f457d94c1407d26442e22f6caaa812de6e" translate="yes" xml:space="preserve">
          <source>1) enables the &lt;code&gt;uppercase&lt;/code&gt; flag in the stream &lt;code&gt;str&lt;/code&gt; as if by calling &lt;code&gt;str.setf(&lt;a href=&quot;../ios_base/fmtflags&quot;&gt;std::ios_base::uppercase&lt;/a&gt;)&lt;/code&gt;.</source>
          <target state="translated">1) включает флаг &lt;code&gt;uppercase&lt;/code&gt; в потоке &lt;code&gt;str&lt;/code&gt; , как если бы он вызывал &lt;code&gt;str.setf(&lt;a href=&quot;../ios_base/fmtflags&quot;&gt;std::ios_base::uppercase&lt;/a&gt;)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fca12c96ad1be6c8785cc47ea43d3c81665b28d0" translate="yes" xml:space="preserve">
          <source>1) expression statements;</source>
          <target state="translated">1)выражения;</target>
        </trans-unit>
        <trans-unit id="4f15378fe06eb783737d9e09aa30928eef4d729d" translate="yes" xml:space="preserve">
          <source>1) forms a literal &lt;code&gt;&lt;a href=&quot;../complex&quot;&gt;std::complex&lt;/a&gt;&amp;lt;double&amp;gt;&lt;/code&gt; with the real part zero and imaginary part &lt;code&gt;arg&lt;/code&gt;</source>
          <target state="translated">1) образует литерал &lt;code&gt;&lt;a href=&quot;../complex&quot;&gt;std::complex&lt;/a&gt;&amp;lt;double&amp;gt;&lt;/code&gt; с вещественной частью ноль и мнимой частью &lt;code&gt;arg&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b1be539d05656ffe16187d9f074b5f435a3f1a78" translate="yes" xml:space="preserve">
          <source>1) function parameter of a function template declared as rvalue reference to cv-unqualified &lt;a href=&quot;template_parameters&quot;&gt;type template parameter&lt;/a&gt; of that same function template:</source>
          <target state="translated">1) параметр функции шаблона функции, объявленный как rvalue ссылка на &lt;a href=&quot;template_parameters&quot;&gt;параметр шаблона&lt;/a&gt; cv-unqualified типа того же самого шаблона функции:</target>
        </trans-unit>
        <trans-unit id="933951affe5827f2ddb2f2c9addfe63c922b58e8" translate="yes" xml:space="preserve">
          <source>1) if &lt;code&gt;E2&lt;/code&gt; is a &lt;a href=&quot;static&quot;&gt;static data member&lt;/a&gt;:</source>
          <target state="translated">1) если &lt;code&gt;E2&lt;/code&gt; является &lt;a href=&quot;static&quot;&gt;статическим членом данных&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="f24447a09ca19b04649b1c980278aea007b7651a" translate="yes" xml:space="preserve">
          <source>1) if &lt;code&gt;E2&lt;/code&gt; is a pointer to data member,</source>
          <target state="translated">1) если &lt;code&gt;E2&lt;/code&gt; является указателем на член данных,</target>
        </trans-unit>
        <trans-unit id="fd8cbf371492e8ec4bdc5da5949d838ae310b0b6" translate="yes" xml:space="preserve">
          <source>1) if &lt;code&gt;T&lt;/code&gt; is a class type with at least one user-provided constructor of any kind, the &lt;a href=&quot;default_constructor&quot;&gt;default constructor&lt;/a&gt; is called; 2) if &lt;code&gt;T&lt;/code&gt; is a non-union class type without any user-provided constructors, every non-static data member and base-class component of T is value-initialized;</source>
          <target state="translated">1) если &lt;code&gt;T&lt;/code&gt; является типом класса по крайней мере с одним предоставленным пользователем конструктором любого вида, вызывается &lt;a href=&quot;default_constructor&quot;&gt;конструктор&lt;/a&gt; по умолчанию ; 2) если &lt;code&gt;T&lt;/code&gt; является типом класса без объединения без каких-либо предоставленных пользователем конструкторов, каждый элемент нестатических данных и компонент базового класса в T инициализируется значением;</target>
        </trans-unit>
        <trans-unit id="cc5cbe2c36375ecb8459cbffdcc5e56194637eb7" translate="yes" xml:space="preserve">
          <source>1) if &lt;code&gt;T&lt;/code&gt; is a class type with no default constructor or with a user-provided or deleted default constructor, the object is &lt;a href=&quot;default_initialization&quot;&gt;default-initialized&lt;/a&gt;; 2) if &lt;code&gt;T&lt;/code&gt; is a class type with a default constructor that is neither user-provided nor deleted (that is, it may be a class with an implicitly-defined or defaulted default constructor), the object is &lt;a href=&quot;zero_initialization&quot;&gt;zero-initialized&lt;/a&gt; and then it is &lt;a href=&quot;default_initialization&quot;&gt;default-initialized&lt;/a&gt; if it has a non-trivial default constructor;</source>
          <target state="translated">1) если &lt;code&gt;T&lt;/code&gt; является типом класса без конструктора по умолчанию или с предоставленным пользователем или удаленным конструктором по умолчанию, объект &lt;a href=&quot;default_initialization&quot;&gt;инициализируется по умолчанию&lt;/a&gt; ; 2) если &lt;code&gt;T&lt;/code&gt; является типом класса с конструктором по умолчанию, который не предоставлен и не удален пользователем (то есть это может быть класс с неявно определенным или дефолтным конструктором по умолчанию), объект &lt;a href=&quot;zero_initialization&quot;&gt;инициализируется нулями,&lt;/a&gt; а затем &lt;a href=&quot;default_initialization&quot;&gt;инициализируется по умолчанию,&lt;/a&gt; если у него есть нетривиальный конструктор по умолчанию;</target>
        </trans-unit>
        <trans-unit id="2567e503e479ddfa34c6e4c7e7e466e63c7a9083" translate="yes" xml:space="preserve">
          <source>1) if &lt;code&gt;T&lt;/code&gt; is a function or pointer to function that takes one argument of type &lt;code&gt;A1&lt;/code&gt;, then &lt;code&gt;argument_type&lt;/code&gt; is &lt;code&gt;A1&lt;/code&gt;.</source>
          <target state="translated">1) если &lt;code&gt;T&lt;/code&gt; является функцией или указателем на функцию, которая принимает один аргумент типа &lt;code&gt;A1&lt;/code&gt; , тогда &lt;code&gt;argument_type&lt;/code&gt; равен &lt;code&gt;A1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="05248e1e5cafa82d974bc4d2920820bbd80169d6" translate="yes" xml:space="preserve">
          <source>1) if &lt;code&gt;T&lt;/code&gt; is a function or pointer to function that takes two arguments of type s &lt;code&gt;A1&lt;/code&gt; and &lt;code&gt;A2&lt;/code&gt;, then &lt;code&gt;second_argument_type&lt;/code&gt; is &lt;code&gt;A2&lt;/code&gt;.</source>
          <target state="translated">1) если &lt;code&gt;T&lt;/code&gt; - функция или указатель на функцию, которая принимает два аргумента типа s &lt;code&gt;A1&lt;/code&gt; и &lt;code&gt;A2&lt;/code&gt; , то &lt;code&gt;second_argument_type&lt;/code&gt; - это &lt;code&gt;A2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ccfd08717e620a2adb1e880c6d6d8a684f02c9b9" translate="yes" xml:space="preserve">
          <source>1) if &lt;code&gt;T&lt;/code&gt; is a function or pointer to function that takes two arguments of types &lt;code&gt;A1&lt;/code&gt; and &lt;code&gt;A2&lt;/code&gt;, then &lt;code&gt;first_argument_type&lt;/code&gt; is &lt;code&gt;A1&lt;/code&gt;.</source>
          <target state="translated">1) если &lt;code&gt;T&lt;/code&gt; - функция или указатель на функцию, которая принимает два аргумента типов &lt;code&gt;A1&lt;/code&gt; и &lt;code&gt;A2&lt;/code&gt; , то &lt;code&gt;first_argument_type&lt;/code&gt; - это &lt;code&gt;A1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a431179612485d24bc273e5248075c581ebeb99d" translate="yes" xml:space="preserve">
          <source>1) if A and B are &lt;code&gt;memory_order_seq_cst&lt;/code&gt; operations, and A</source>
          <target state="translated">1) если A и B - операции &lt;code&gt;memory_order_seq_cst&lt;/code&gt; , и A</target>
        </trans-unit>
        <trans-unit id="649d80319d06d238094897a0c7387db3f34a9dba" translate="yes" xml:space="preserve">
          <source>1) initialization of a named variable with a</source>
          <target state="translated">1)инициализация именованной переменной с помощью функции a</target>
        </trans-unit>
        <trans-unit id="1368a73e49095bf4c57e55786671e41410e57ea6" translate="yes" xml:space="preserve">
          <source>1) initialization with a nonempty parenthesized list of expressions or braced-init-lists(since C++11)</source>
          <target state="translated">1)инициализация непустым списком выражений в скобках или списками в скобках (начиная с C++11)</target>
        </trans-unit>
        <trans-unit id="99f4faeed3de5d70f2b4ff261841eff7c00945ba" translate="yes" xml:space="preserve">
          <source>1) integer literal, returns exactly &lt;code&gt;&lt;a href=&quot;duration&quot;&gt;std::chrono::hours&lt;/a&gt;(hrs)&lt;/code&gt;</source>
          <target state="translated">1) целочисленный литерал, возвращает ровно &lt;code&gt;&lt;a href=&quot;duration&quot;&gt;std::chrono::hours&lt;/a&gt;(hrs)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b87dde5587a9a2ce938326ff6f293bb389b57a11" translate="yes" xml:space="preserve">
          <source>1) integer literal, returns exactly &lt;code&gt;&lt;a href=&quot;duration&quot;&gt;std::chrono::microseconds&lt;/a&gt;(us)&lt;/code&gt;</source>
          <target state="translated">1) целочисленный литерал, возвращает ровно &lt;code&gt;&lt;a href=&quot;duration&quot;&gt;std::chrono::microseconds&lt;/a&gt;(us)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="73237f5b88515e9f07510adba322ff008703bf77" translate="yes" xml:space="preserve">
          <source>1) integer literal, returns exactly &lt;code&gt;&lt;a href=&quot;duration&quot;&gt;std::chrono::milliseconds&lt;/a&gt;(ms)&lt;/code&gt;</source>
          <target state="translated">1) целочисленный литерал, возвращает ровно &lt;code&gt;&lt;a href=&quot;duration&quot;&gt;std::chrono::milliseconds&lt;/a&gt;(ms)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="75957235d93ab14971c5ead82631c15f8903fa9f" translate="yes" xml:space="preserve">
          <source>1) integer literal, returns exactly &lt;code&gt;&lt;a href=&quot;duration&quot;&gt;std::chrono::minutes&lt;/a&gt;(mins)&lt;/code&gt;</source>
          <target state="translated">1) целочисленный литерал, возвращает ровно &lt;code&gt;&lt;a href=&quot;duration&quot;&gt;std::chrono::minutes&lt;/a&gt;(mins)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9a65c38cb3e887f8107e9bb7e034295d9e9ba661" translate="yes" xml:space="preserve">
          <source>1) integer literal, returns exactly &lt;code&gt;&lt;a href=&quot;duration&quot;&gt;std::chrono::nanoseconds&lt;/a&gt;(nsec)&lt;/code&gt;</source>
          <target state="translated">1) целочисленный литерал, возвращает ровно &lt;code&gt;&lt;a href=&quot;duration&quot;&gt;std::chrono::nanoseconds&lt;/a&gt;(nsec)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d2ff5af48ac230f178ca8f7aae38f7e5b97cd4ae" translate="yes" xml:space="preserve">
          <source>1) integer literal, returns exactly &lt;code&gt;&lt;a href=&quot;duration&quot;&gt;std::chrono::seconds&lt;/a&gt;(secs)&lt;/code&gt;</source>
          <target state="translated">1) целочисленный литерал, возвращает ровно &lt;code&gt;&lt;a href=&quot;duration&quot;&gt;std::chrono::seconds&lt;/a&gt;(secs)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3c2ec705f86909dc012b45e0a5e5eac830bf7b5e" translate="yes" xml:space="preserve">
          <source>1) it may apply to the parameter declarations of a function or lambda-expressions, in which case it indicates that initialization of the parameter carries dependency into lvalue-to-rvalue conversion of that object.</source>
          <target state="translated">1)он может применяться к объявлениям параметров функции или лямбда-выражениям,и в этом случае он указывает,что инициализация параметра несет в себе зависимость от преобразования значения l в значение-значение этого объекта.</target>
        </trans-unit>
        <trans-unit id="f08aa13ffd87bf5b57bd2b5c39f8fe2c531e8de4" translate="yes" xml:space="preserve">
          <source>1) left shift of lhs by rhs bits</source>
          <target state="translated">1)смещение влево lhs на rhs-биты</target>
        </trans-unit>
        <trans-unit id="a0ef1b765d867fe5ee7805c81437d622e4207832" translate="yes" xml:space="preserve">
          <source>1) linear in &lt;code&gt;count&lt;/code&gt;</source>
          <target state="translated">1) линейный по &lt;code&gt;count&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0ff0e7aba3a51ab3e96b766a29da0e2d4e95d71e" translate="yes" xml:space="preserve">
          <source>1) linear in size of &lt;code&gt;str&lt;/code&gt;</source>
          <target state="translated">1) линейный по размеру &lt;code&gt;str&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9ba4f8c918b38171c581014561921c19d85a056e" translate="yes" xml:space="preserve">
          <source>1) make more memory available</source>
          <target state="translated">1)сделать больше памяти доступным</target>
        </trans-unit>
        <trans-unit id="a0c8b5c53f4a3270d0819e3eea46631ace784dc4" translate="yes" xml:space="preserve">
          <source>1) may throw &lt;code&gt;&lt;a href=&quot;../../io/ios_base/failure&quot;&gt;std::ios_base::failure&lt;/a&gt;&lt;/code&gt; if an exception is thrown during output.</source>
          <target state="translated">1) может &lt;code&gt;&lt;a href=&quot;../../io/ios_base/failure&quot;&gt;std::ios_base::failure&lt;/a&gt;&lt;/code&gt; если во время вывода выдается исключение.</target>
        </trans-unit>
        <trans-unit id="818942971c8d5e6d4f974a900c33b24a7f7a56bb" translate="yes" xml:space="preserve">
          <source>1) may throw, e.g. if &lt;code&gt;pointer&lt;/code&gt; defines a throwing &lt;code&gt;operator*&lt;/code&gt;</source>
          <target state="translated">1) может бросить, например, если &lt;code&gt;pointer&lt;/code&gt; определяет &lt;code&gt;operator*&lt;/code&gt; броска *</target>
        </trans-unit>
        <trans-unit id="b746d566df1bafa8f84adef1c6b1bd18579c2ad4" translate="yes" xml:space="preserve">
          <source>1) multiplication</source>
          <target state="translated">1)умножение</target>
        </trans-unit>
        <trans-unit id="63b22e6c68841953ed2ca6a9ca96cff9639efe85" translate="yes" xml:space="preserve">
          <source>1) narrow character literal or ordinary character literal, e.g. &lt;code&gt;'a'&lt;/code&gt; or &lt;code&gt;'\n'&lt;/code&gt; or &lt;code&gt;'\13'&lt;/code&gt;. Such literal has type &lt;code&gt;char&lt;/code&gt; and the value equal to the representation of c-char in the execution character set. If c-char is not representable as a single byte in the execution character set, the literal has type &lt;code&gt;int&lt;/code&gt; and implementation-defined value</source>
          <target state="translated">1) узкий символьный литерал или обычный символьный литерал, например &lt;code&gt;'a'&lt;/code&gt; или &lt;code&gt;'\n'&lt;/code&gt; или &lt;code&gt;'\13'&lt;/code&gt; . Такой литерал имеет тип &lt;code&gt;char&lt;/code&gt; и значение, равное представлению c-char в наборе символов выполнения. Если c-char не может быть представлен как один байт в наборе символов выполнения, литерал имеет тип &lt;code&gt;int&lt;/code&gt; и значение, определяемое реализацией</target>
        </trans-unit>
        <trans-unit id="b3526fa909cbee863631df5a0dd6e3dfe3d40b87" translate="yes" xml:space="preserve">
          <source>1) op E</source>
          <target state="translated">1)в Е</target>
        </trans-unit>
        <trans-unit id="4adc80c0600353b3a1170e14f5e464ff13775a27" translate="yes" xml:space="preserve">
          <source>1) overloaded operator;</source>
          <target state="translated">1)перегруженный оператор;</target>
        </trans-unit>
        <trans-unit id="5e09baa491e636964ed3becfd3445f8709e44fad" translate="yes" xml:space="preserve">
          <source>1) p made relative against base.</source>
          <target state="translated">1)p сделано относительно основания.</target>
        </trans-unit>
        <trans-unit id="f807176049911b041a40e01ee8ab370dcdb89766" translate="yes" xml:space="preserve">
          <source>1) postfix increment (post-increment)</source>
          <target state="translated">1)постфиксный инкремент (пост-инкремент)</target>
        </trans-unit>
        <trans-unit id="2d5856705fcd5ea07c48025861fe3b1f79bc0d2c" translate="yes" xml:space="preserve">
          <source>1) prefix increment (pre-increment)</source>
          <target state="translated">1)префиксный инкремент (пре-инкремент)</target>
        </trans-unit>
        <trans-unit id="daa92feecb37a0d054ee8b707dc9aac07a31a3ea" translate="yes" xml:space="preserve">
          <source>1) public member function, calls the member function &lt;code&gt;do_encoding&lt;/code&gt; of the most derived class.</source>
          <target state="translated">1) открытая функция-член, вызывает функцию-член &lt;code&gt;do_encoding&lt;/code&gt; наиболее производного класса.</target>
        </trans-unit>
        <trans-unit id="5328462b7087b609c543e78bd8d46692bea782df" translate="yes" xml:space="preserve">
          <source>1) public member function, calls the member function &lt;code&gt;do_length&lt;/code&gt; of the most derived class.</source>
          <target state="translated">1) открытая функция-член, вызывает функцию-член &lt;code&gt;do_length&lt;/code&gt; самого производного класса.</target>
        </trans-unit>
        <trans-unit id="53f57d286d6e754d726ea6cccf746a676dfa1638" translate="yes" xml:space="preserve">
          <source>1) public member function, calls the member function &lt;code&gt;do_out&lt;/code&gt; of the most derived class.</source>
          <target state="translated">1) открытая функция-член, вызывает функцию-член &lt;code&gt;do_out&lt;/code&gt; самого производного класса.</target>
        </trans-unit>
        <trans-unit id="e4db4e3900ed888101fc0f5f38719bd3c6326b25" translate="yes" xml:space="preserve">
          <source>1) public member function, calls the member function &lt;code&gt;do_unshift&lt;/code&gt; of the most derived class.</source>
          <target state="translated">1) открытая функция-член, вызывает функцию-член &lt;code&gt;do_unshift&lt;/code&gt; наиболее производного класса.</target>
        </trans-unit>
        <trans-unit id="36bebe33f8e9dfba4ec0a7482223647307e5d502" translate="yes" xml:space="preserve">
          <source>1) public member function, calls the protected virtual member function &lt;code&gt;do_close&lt;/code&gt; of the most derived class.</source>
          <target state="translated">1) открытая функция-член, вызывает защищенную виртуальную функцию-член &lt;code&gt;do_close&lt;/code&gt; наиболее производного класса.</target>
        </trans-unit>
        <trans-unit id="087deceeef2229bfa0f69093a5dde5435352bc10" translate="yes" xml:space="preserve">
          <source>1) public member function, calls the protected virtual member function &lt;code&gt;do_get_monthname&lt;/code&gt; of the most derived class.</source>
          <target state="translated">1) открытая функция-член, вызывает защищенную виртуальную функцию-член &lt;code&gt;do_get_monthname&lt;/code&gt; самого производного класса.</target>
        </trans-unit>
        <trans-unit id="54d273175a96ff13269f617ec3bfb9a5e807469d" translate="yes" xml:space="preserve">
          <source>1) public member function, calls the protected virtual member function &lt;code&gt;do_get_time&lt;/code&gt; of the most derived class.</source>
          <target state="translated">1) открытая функция-член, вызывает защищенную виртуальную функцию-член &lt;code&gt;do_get_time&lt;/code&gt; самого производного класса.</target>
        </trans-unit>
        <trans-unit id="2a24196c23f9b282e50225c8ce404605af1d591e" translate="yes" xml:space="preserve">
          <source>1) public member function, calls the protected virtual member function &lt;code&gt;do_get_weekday&lt;/code&gt; of the most derived class.</source>
          <target state="translated">1) открытая функция-член, вызывает защищенную виртуальную функцию-член &lt;code&gt;do_get_weekday&lt;/code&gt; самого производного класса.</target>
        </trans-unit>
        <trans-unit id="c90b5960dcfdbae543519fd42dff106975cf6a49" translate="yes" xml:space="preserve">
          <source>1) public member function, calls the protected virtual member function &lt;code&gt;do_get_year&lt;/code&gt; of the most derived class.</source>
          <target state="translated">1) открытая функция-член, вызывает защищенную виртуальную функцию-член &lt;code&gt;do_get_year&lt;/code&gt; самого производного класса.</target>
        </trans-unit>
        <trans-unit id="ced48bdf0ef79442409261aece9019fc894855a2" translate="yes" xml:space="preserve">
          <source>1) public member function, calls the protected virtual member function &lt;code&gt;do_scan_is&lt;/code&gt; of the most derived class.</source>
          <target state="translated">1) открытая функция-член, вызывает защищенную виртуальную функцию-член &lt;code&gt;do_scan_is&lt;/code&gt; самого производного класса.</target>
        </trans-unit>
        <trans-unit id="278c95483ac183d21fe5237adc621b7ef3fd15ff" translate="yes" xml:space="preserve">
          <source>1) public member function, calls the protected virtual member function &lt;code&gt;do_scan_not&lt;/code&gt; of the most derived class.</source>
          <target state="translated">1) открытая функция-член, вызывает защищенную виртуальную функцию-член &lt;code&gt;do_scan_not&lt;/code&gt; самого производного класса.</target>
        </trans-unit>
        <trans-unit id="a5100d04826728fa57d41699139922616240294d" translate="yes" xml:space="preserve">
          <source>1) regular function body</source>
          <target state="translated">1)регулярный функциональный орган</target>
        </trans-unit>
        <trans-unit id="aeec3a3b882e59daf64402de22ed548e3658687c" translate="yes" xml:space="preserve">
          <source>1) removes the topmost &lt;code&gt;const&lt;/code&gt;, the topmost &lt;code&gt;volatile&lt;/code&gt;, or both, if present.</source>
          <target state="translated">1) удаляет самый верхний &lt;code&gt;const&lt;/code&gt; , самый верхний &lt;code&gt;volatile&lt;/code&gt; или оба, если они есть.</target>
        </trans-unit>
        <trans-unit id="1791c7ad104cbda662a1ae0402149dd47873c5da" translate="yes" xml:space="preserve">
          <source>1) returns &lt;code&gt;&lt;a href=&quot;../basic_string&quot;&gt;std::string&lt;/a&gt;{str, len}&lt;/code&gt;</source>
          <target state="translated">1) возвращает &lt;code&gt;&lt;a href=&quot;../basic_string&quot;&gt;std::string&lt;/a&gt;{str, len}&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6f85b4809a3f0e34d7e0945ed1b8a2c6c86889a9" translate="yes" xml:space="preserve">
          <source>1) returns &lt;code&gt;&lt;a href=&quot;../basic_string_view&quot;&gt;std::string_view&lt;/a&gt;{str, len}&lt;/code&gt;</source>
          <target state="translated">1) возвращает &lt;code&gt;&lt;a href=&quot;../basic_string_view&quot;&gt;std::string_view&lt;/a&gt;{str, len}&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3e1e200684cc13c5bab72f139037d8694e2ed55a" translate="yes" xml:space="preserve">
          <source>1) returns &lt;code&gt;c.empty()&lt;/code&gt;</source>
          <target state="translated">1) возвращает &lt;code&gt;c.empty()&lt;/code&gt;</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
