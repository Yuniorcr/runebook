<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="gcc">
    <body>
      <group id="gcc">
        <trans-unit id="89ecfe4db21e974dbc1daddf5e580b9450304991" translate="yes" xml:space="preserve">
          <source>The maximum amount of similar bbs to compare a bb with. This is used to avoid quadratic behavior in tree tail merging.</source>
          <target state="translated">Максимальное количество похожих bb для сравнения с bb.Это используется,чтобы избежать квадратичного поведения при слиянии хвоста дерева.</target>
        </trans-unit>
        <trans-unit id="b6556ebb0621924348132da881ea97c1a248f5ac" translate="yes" xml:space="preserve">
          <source>The maximum code size expansion factor when copying basic blocks instead of jumping. The expansion is relative to a jump instruction.</source>
          <target state="translated">Максимальный коэффициент расширения размера кода при копировании основных блоков вместо прыжков.Расширение относительно инструкции по прыжку.</target>
        </trans-unit>
        <trans-unit id="fce841f0d7fbba4e3b6b48cb84aa6e927eb09594" translate="yes" xml:space="preserve">
          <source>The maximum code size growth ratio when expanding into a jump table (in percent). The parameter is used when optimizing for size.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e2d12fa5294a85cba03b250f3a5bea21673f3bb2" translate="yes" xml:space="preserve">
          <source>The maximum code size growth ratio when expanding into a jump table (in percent). The parameter is used when optimizing for speed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="936a590636d845b92624c7728a4827fce9d92d06" translate="yes" xml:space="preserve">
          <source>The maximum conflict delay for an insn to be considered for speculative motion.</source>
          <target state="translated">Максимальная задержка конфликта для INSN должна быть рассмотрена для спекулятивного движения.</target>
        </trans-unit>
        <trans-unit id="fbb7200dcbf807a75160beecc432fa62ed3e9728" translate="yes" xml:space="preserve">
          <source>The maximum depth of a loop nest suitable for complete peeling.</source>
          <target state="translated">Максимальная глубина петлевого гнезда,пригодного для полного пилинга.</target>
        </trans-unit>
        <trans-unit id="26a797ef806eaaf765b7a781b669b0a1ee2786d8" translate="yes" xml:space="preserve">
          <source>The maximum depth of recursive inlining for non-inline functions.</source>
          <target state="translated">Максимальная глубина рекурсивной вставки для нестрочных функций.</target>
        </trans-unit>
        <trans-unit id="20b08dcc7587be3ab6eef2848d7ad81b5a152655" translate="yes" xml:space="preserve">
          <source>The maximum length of a constant string for a builtin string cmp call eligible for inlining.</source>
          <target state="translated">Максимальная длина строки константы для вызова встроенной строки cmp,допустимой для встраивания.</target>
        </trans-unit>
        <trans-unit id="be0d3936975ebff6f26b92e20318105d1c7db49a" translate="yes" xml:space="preserve">
          <source>The maximum number of &amp;rsquo;after supernode&amp;rsquo; exploded nodes within the analyzer per supernode, before terminating analysis.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="38e85e4670d6f7ac0961160fd225824b117f4e1d" translate="yes" xml:space="preserve">
          <source>The maximum number of &lt;code&gt;case&lt;/code&gt; values in a &lt;code&gt;switch&lt;/code&gt; statement (C90 6.6.4.2).</source>
          <target state="translated">Максимальное количество значений &lt;code&gt;case&lt;/code&gt; в операторе &lt;code&gt;switch&lt;/code&gt; (C90 6.6.4.2).</target>
        </trans-unit>
        <trans-unit id="0a2afaa6d3ae61c2d6492935df7934433f87eae8" translate="yes" xml:space="preserve">
          <source>The maximum number of SSA_NAME assignments to follow in determining a property of a variable such as its value. This limits the number of iterations or recursive calls GCC performs when optimizing certain statements or when determining their validity prior to issuing diagnostics.</source>
          <target state="translated">Максимальное количество присваиваний SSA_NAME для определения свойства переменной,такого как ее значение.Это ограничивает количество итераций или рекурсивных вызовов,выполняемых GCC при оптимизации определенных утверждений или при определении их действительности до выдачи диагностики.</target>
        </trans-unit>
        <trans-unit id="f915c9b0ddf0bbc0779c3cf7dd483c9574fb303a" translate="yes" xml:space="preserve">
          <source>The maximum number of artificial accesses that Scalar Replacement of Aggregates (SRA) will track, per one local variable, in order to facilitate copy propagation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1cfdd5d91556b4dd893a62b6a75874eee03cf513" translate="yes" xml:space="preserve">
          <source>The maximum number of assertions to add along the default edge of a switch statement during VRP.</source>
          <target state="translated">Максимальное количество утверждений для добавления по умолчанию по краю оператора переключения во время VRP.</target>
        </trans-unit>
        <trans-unit id="c6e6bc4dbd514d325e3c749eca0229393e1fb788" translate="yes" xml:space="preserve">
          <source>The maximum number of backtrack attempts the scheduler should make when modulo scheduling a loop. Larger values can exponentially increase compilation time.</source>
          <target state="translated">Максимальное количество попыток обратного хода,которое планировщик должен сделать при модульном планировании цикла.Большие значения могут экспоненциально увеличить время компиляции.</target>
        </trans-unit>
        <trans-unit id="018c7375a2caf17039c26fd694620cad7ebfaa5f" translate="yes" xml:space="preserve">
          <source>The maximum number of basic blocks on path that CSE considers.</source>
          <target state="translated">Максимальное количество основных блоков на пути,которое рассматривает CSE.</target>
        </trans-unit>
        <trans-unit id="c79967caf66fa10b13e953918175f64b9fd85351" translate="yes" xml:space="preserve">
          <source>The maximum number of best instructions in the ready list that are considered for renaming in the selective scheduler.</source>
          <target state="translated">Максимальное количество лучших инструкций в готовом списке,которые рассматриваются для переименования в селективном планировщике.</target>
        </trans-unit>
        <trans-unit id="79a02e3d5ce6c0b561178810954860635f75b277" translate="yes" xml:space="preserve">
          <source>The maximum number of blocks in a region to be considered for interblock scheduling.</source>
          <target state="translated">Максимальное количество блоков в регионе для межблокового планирования.</target>
        </trans-unit>
        <trans-unit id="3225f5aa45adb6a455e07adb58dbc4331ca98962" translate="yes" xml:space="preserve">
          <source>The maximum number of blocks in a region to be considered for pipelining in the selective scheduler.</source>
          <target state="translated">Максимальное количество блоков в регионе,которое должно учитываться для трубопроводов в селективном планировщике.</target>
        </trans-unit>
        <trans-unit id="d26d722dd2f733f712aeb0f605ec58066091d632" translate="yes" xml:space="preserve">
          <source>The maximum number of branches on the hot path through the peeled sequence.</source>
          <target state="translated">Максимальное количество ветвей на горячем пути через очищенную последовательность.</target>
        </trans-unit>
        <trans-unit id="d2fe875bfce475e08e430e98ccc72ad1afca879e" translate="yes" xml:space="preserve">
          <source>The maximum number of branches unswitched in a single loop.</source>
          <target state="translated">Максимальное количество ветвей,не отключенных в одном цикле.</target>
        </trans-unit>
        <trans-unit id="9965c595ccb073bed98dc2ae6e76b73f1d6e9fe2" translate="yes" xml:space="preserve">
          <source>The maximum number of conditional store pairs that can be sunk. Set to 0 if either vectorization (</source>
          <target state="translated">Максимальное количество пар условных магазинов,которые могут быть потоплены.Установите 0,если любая из векторизаций (</target>
        </trans-unit>
        <trans-unit id="126cc6769740c4d71bac9ace9af0b249f19d3967" translate="yes" xml:space="preserve">
          <source>The maximum number of declarators that may modify an arithmetic, structure or union type (C90 6.5.4).</source>
          <target state="translated">Максимальное число деклараторов,которые могут изменить арифметику,структуру или тип союза (С90 6.5.4).</target>
        </trans-unit>
        <trans-unit id="4d5793f890c15f6b518ebfeeddd6bdf92fc933a4" translate="yes" xml:space="preserve">
          <source>The maximum number of exploded nodes per program point within the analyzer, before terminating analysis of that point.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="046b54d8dec00a923499bbe98f2011a4caa2c4d1" translate="yes" xml:space="preserve">
          <source>The maximum number of incoming edges to consider for cross-jumping. The algorithm used by</source>
          <target state="translated">Максимальное количество входящих кроссов для перекрестных прыжков.Алгоритм,используемый</target>
        </trans-unit>
        <trans-unit id="23db9a7b1aa156bfdeb79b1a74ceb92745f99df4" translate="yes" xml:space="preserve">
          <source>The maximum number of insns in a region to be considered for interblock scheduling.</source>
          <target state="translated">Максимальное количество вставок в регионе для межблочного планирования.</target>
        </trans-unit>
        <trans-unit id="64755c0a10d7b896808172cc7335112d4911d239" translate="yes" xml:space="preserve">
          <source>The maximum number of insns in a region to be considered for pipelining in the selective scheduler.</source>
          <target state="translated">Максимальное количество вставок в регионе,которое должно быть учтено для трубопроводов в селективном планировщике.</target>
        </trans-unit>
        <trans-unit id="7549b9d59e547801a424f6394451c0c5eb284456" translate="yes" xml:space="preserve">
          <source>The maximum number of insns in loop header duplicated by the copy loop headers pass.</source>
          <target state="translated">Максимальное количество вставок в заголовке петли,дублированное прохождением заголовков копирования петли.</target>
        </trans-unit>
        <trans-unit id="557a1591041c896c87813c7c44591df470e1d549" translate="yes" xml:space="preserve">
          <source>The maximum number of insns of a completely peeled loop.</source>
          <target state="translated">Максимальное количество вставок полностью очищенной петли.</target>
        </trans-unit>
        <trans-unit id="6e77354bbeeb82418d9ce51f0cd208bdb1bdb528" translate="yes" xml:space="preserve">
          <source>The maximum number of insns of a peeled loop that rolls only once.</source>
          <target state="translated">Максимальное количество вставок очищенной петли,которая скатывается только один раз.</target>
        </trans-unit>
        <trans-unit id="e1366f0a190b8fba2e81ce94bc72ef8becba23f7" translate="yes" xml:space="preserve">
          <source>The maximum number of insns of an unswitched loop.</source>
          <target state="translated">Максимальное количество вставок в непереключенном контуре.</target>
        </trans-unit>
        <trans-unit id="cf7612b99e9ada1082074daa96e9458c5473af04" translate="yes" xml:space="preserve">
          <source>The maximum number of instruction reload should look backward for equivalent register. Increasing values mean more aggressive optimization, making the compilation time increase with probably slightly better performance.</source>
          <target state="translated">Максимальное количество перезагрузок инструкций должно оглядываться назад для эквивалентного регистра.Увеличение значений означает более агрессивную оптимизацию,что увеличивает время компиляции с возможно немного лучшей производительностью.</target>
        </trans-unit>
        <trans-unit id="9005923e6a32b4692818d139c898763d96182dda" translate="yes" xml:space="preserve">
          <source>The maximum number of instructions CSE processes before flushing.</source>
          <target state="translated">Максимальное количество инструкций CSE перед промывкой.</target>
        </trans-unit>
        <trans-unit id="c9f4ccd7bf5ad2020d3e593506c55f6c162a5002" translate="yes" xml:space="preserve">
          <source>The maximum number of instructions biased by probabilities of their execution that a loop may have to be unrolled. If a loop is unrolled, this parameter also determines how many times the loop code is unrolled.</source>
          <target state="translated">Максимальное количество инструкций,смещенных в зависимости от вероятности их выполнения,что цикл может быть разворачиваемым.Если цикл разворачивается,данный параметр также определяет,сколько раз разворачивается код цикла.</target>
        </trans-unit>
        <trans-unit id="6459fa6f8aa47f72deca9d3c9064156b11b3b7ad" translate="yes" xml:space="preserve">
          <source>The maximum number of instructions non-inline function can grow to via recursive inlining.</source>
          <target state="translated">Максимальное количество инструкций,не входящих в строку,может вырасти до рекурсивной вставки.</target>
        </trans-unit>
        <trans-unit id="f088738722ed99797643c1cd7fd24995b8cb099a" translate="yes" xml:space="preserve">
          <source>The maximum number of instructions ready to be issued the scheduler should consider at any given time during the first scheduling pass. Increasing values mean more thorough searches, making the compilation time increase with probably little benefit.</source>
          <target state="translated">Максимальное количество готовых к выдаче инструкций планировщик должен учитывать в любой момент времени при первом проходе по расписанию.Увеличение значений означает более тщательный поиск,что увеличивает время компиляции,вероятно,с небольшой выгодой.</target>
        </trans-unit>
        <trans-unit id="751361661372b9f65beccbd7de6c9e13c4fb111d" translate="yes" xml:space="preserve">
          <source>The maximum number of instructions that a loop may have to be peeled. If a loop is peeled, this parameter also determines how many times the loop code is peeled.</source>
          <target state="translated">Максимальное количество инструкций,которое может потребоваться очистить петлю.Если цикл очищен,то этот параметр также определяет,сколько раз будет очищен код цикла.</target>
        </trans-unit>
        <trans-unit id="7edf4c141bc3a24bbf2d50e04de689b5700fa130" translate="yes" xml:space="preserve">
          <source>The maximum number of instructions that a loop may have to be unrolled. If a loop is unrolled, this parameter also determines how many times the loop code is unrolled.</source>
          <target state="translated">Максимальное количество инструкций,которое может потребоваться для разворачивания петли.Если цикл разворачивается,данный параметр также определяет,сколько раз разворачивается код цикла.</target>
        </trans-unit>
        <trans-unit id="b5c3a913df725fc3842845c874668062bf683170" translate="yes" xml:space="preserve">
          <source>The maximum number of instructions that an inner loop can have before the loop versioning pass considers it too big to copy.</source>
          <target state="translated">Максимальное количество инструкций,которое внутренний цикл может иметь перед прохождением версионного цикла,считает его слишком большим для копирования.</target>
        </trans-unit>
        <trans-unit id="0347a5207a00a0a94142de3b1cb1207696bb8750" translate="yes" xml:space="preserve">
          <source>The maximum number of instructions that an outer loop can have before the loop versioning pass considers it too big to copy, discounting any instructions in inner loops that directly benefit from versioning.</source>
          <target state="translated">Максимальное количество инструкций,которое может иметь внешний контур до прохождения версионирования петли,считает его слишком большим для копирования,с дисконтом к любым инструкциям во внутренних контурах,которые получают прямую выгоду от версионирования.</target>
        </trans-unit>
        <trans-unit id="cd3296c189a6eb29be66f9d755ea47f2387ef49d" translate="yes" xml:space="preserve">
          <source>The maximum number of instructions the RTL combiner tries to combine.</source>
          <target state="translated">Максимальное количество инструкций,которые RTL-комбайнер пытается комбинировать.</target>
        </trans-unit>
        <trans-unit id="cf3b05a5fc34087d71a21bfbdc9daebc782fc835" translate="yes" xml:space="preserve">
          <source>The maximum number of instructions to consider when looking for an instruction to fill a delay slot. If more than this arbitrary number of instructions are searched, the time savings from filling the delay slot are minimal, so stop searching. Increasing values mean more aggressive optimization, making the compilation time increase with probably small improvement in execution time.</source>
          <target state="translated">Максимальное количество инструкций,которые необходимо учитывать при поиске инструкции по заполнению слота задержки.Если ищется больше,чем это произвольное количество инструкций,экономия времени от заполнения слота задержки минимальна,поэтому прекратите поиск.Увеличение значений означает более агрессивную оптимизацию,что увеличивает время компиляции при возможно небольшом увеличении времени исполнения.</target>
        </trans-unit>
        <trans-unit id="f5be3b82586aa080f1846e1d109f72232bc815fe" translate="yes" xml:space="preserve">
          <source>The maximum number of instructions to duplicate to a block that jumps to a computed goto. To avoid &lt;em&gt;O(N^2)&lt;/em&gt; behavior in a number of passes, GCC factors computed gotos early in the compilation process, and unfactors them as late as possible. Only computed jumps at the end of a basic blocks with no more than max-goto-duplication-insns are unfactored.</source>
          <target state="translated">Максимальное количество инструкций для дублирования в блок, который переходит к вычисленному goto. Чтобы избежать поведения &lt;em&gt;O (N ^ 2)&lt;/em&gt; на нескольких проходах, факторы GCC вычисляют gotos на ранних этапах процесса компиляции и восстанавливают их как можно позже. Не учитываются только вычисленные переходы в конце базовых блоков с не более чем max-goto-duplication-insns.</target>
        </trans-unit>
        <trans-unit id="f826bd5a9f2e555af6e39cc55fa38f4c63598849" translate="yes" xml:space="preserve">
          <source>The maximum number of iterations of a loop the brute-force algorithm for analysis of the number of iterations of the loop tries to evaluate.</source>
          <target state="translated">Максимальное количество итераций цикла пытается оценить алгоритм перебора для анализа количества итераций цикла.</target>
        </trans-unit>
        <trans-unit id="827bc9985068a19acb40103212322373c4817b20" translate="yes" xml:space="preserve">
          <source>The maximum number of iterations of a loop to be suitable for complete peeling.</source>
          <target state="translated">Максимальное количество итераций петли для полного пилинга.</target>
        </trans-unit>
        <trans-unit id="6ed380824467ca338cf023f1dcb3f2de07822555" translate="yes" xml:space="preserve">
          <source>The maximum number of iterations through CFG to extend regions. A value of 0 disables region extensions.</source>
          <target state="translated">Максимальное количество итераций через CFG для расширения регионов.Значение 0 отключает расширение регионов.</target>
        </trans-unit>
        <trans-unit id="3a4fe5f590fb9f1538c537c1032bfe7e933f8b30" translate="yes" xml:space="preserve">
          <source>The maximum number of loop iterations we predict statically. This is useful in cases where a function contains a single loop with known bound and another loop with unknown bound. The known number of iterations is predicted correctly, while the unknown number of iterations average to roughly 10. This means that the loop without bounds appears artificially cold relative to the other one.</source>
          <target state="translated">Максимальное количество итераций цикла,которое мы предсказываем статически.Это полезно в тех случаях,когда функция содержит один цикл с известной привязкой и другой цикл с неизвестной привязкой.Известное количество итераций предсказывается корректно,а неизвестное количество итераций усредняется примерно до 10.Это означает,что цикл без границ оказывается искусственно холодным относительно другого.</target>
        </trans-unit>
        <trans-unit id="6c4f0955c671eedabc4872cd4110ae5643c1e035" translate="yes" xml:space="preserve">
          <source>The maximum number of loop peels to enhance access alignment for vectorizer. Value -1 means no limit.</source>
          <target state="translated">Максимальное количество пилингов для улучшения выравнивания доступа для векторизатора.Значение -1 означает отсутствие ограничений.</target>
        </trans-unit>
        <trans-unit id="15a4d50649a3963909b22c32025925dae63b4133" translate="yes" xml:space="preserve">
          <source>The maximum number of may-defs we analyze when looking for a must-def specifying the dynamic type of an object that invokes a virtual call we may be able to devirtualize speculatively.</source>
          <target state="translated">Максимальное количество may-def,которое мы анализируем при поиске must-def,указывая динамический тип объекта,вызывающего виртуальный вызов,мы можем девальвировать спекулятивно.</target>
        </trans-unit>
        <trans-unit id="6a35d2bdd1c57297696d12360403e48281b63730" translate="yes" xml:space="preserve">
          <source>The maximum number of memory locations cselib should take into account. Increasing values mean more aggressive optimization, making the compilation time increase with probably slightly better performance.</source>
          <target state="translated">Следует учитывать максимальное количество ячеек памяти.Увеличение значений означает более агрессивную оптимизацию,что увеличивает время компиляции с возможно несколько лучшей производительностью.</target>
        </trans-unit>
        <trans-unit id="d6a0df289b9860c6b27b724bd89cb2e25afbef7b" translate="yes" xml:space="preserve">
          <source>The maximum number of namespaces to consult for suggestions when C++ name lookup fails for an identifier.</source>
          <target state="translated">Максимальное количество пространств имен,с которыми можно ознакомиться для предложений,когда поиск имени на C++не удается найти идентификатор.</target>
        </trans-unit>
        <trans-unit id="511118b67bad71c8756d22dc67344a5b3d5a2116" translate="yes" xml:space="preserve">
          <source>The maximum number of peelings of a single loop.</source>
          <target state="translated">Максимальное количество пилингов одной петли.</target>
        </trans-unit>
        <trans-unit id="e8f1f05653238e3a565a30b9f73246f26306aaea" translate="yes" xml:space="preserve">
          <source>The maximum number of pending dependencies scheduling allows before flushing the current state and starting over. Large functions with few branches or calls can create excessively large lists which needlessly consume memory and resources.</source>
          <target state="translated">Максимальное количество планируемых отложенных зависимостей позволяет перед промывкой текущего состояния и запуском заново.Большие функции с небольшим количеством ветвей или вызовов могут создавать чрезмерно большие списки,которые излишне потребляют память и ресурсы.</target>
        </trans-unit>
        <trans-unit id="f0e89b0526dda27a2d7f3e6b7314e208af696219" translate="yes" xml:space="preserve">
          <source>The maximum number of run-time checks that can be performed when doing loop versioning for alias in the vectorizer.</source>
          <target state="translated">Максимальное количество циклических проверок,которые могут быть выполнены при версионировании псевдонимов в векторизаторе.</target>
        </trans-unit>
        <trans-unit id="db0f184d4982d10802b0494be89c63889d9e1ea5" translate="yes" xml:space="preserve">
          <source>The maximum number of run-time checks that can be performed when doing loop versioning for alignment in the vectorizer.</source>
          <target state="translated">Максимальное количество проверок,которые можно выполнить при версионировании цикла для выравнивания в векторизаторе.</target>
        </trans-unit>
        <trans-unit id="50ff624d5ca7c27e89395fa51bbbe5ce28d3f9f1" translate="yes" xml:space="preserve">
          <source>The maximum number of stmts in a loop to be interchanged.</source>
          <target state="translated">Максимальное количество взаимозаменяемых stmts в цикле.</target>
        </trans-unit>
        <trans-unit id="2862b2a5dc2c56cf5f469134e2bd6bad6e5964e7" translate="yes" xml:space="preserve">
          <source>The maximum number of stores to attempt to merge into wider stores in the store merging pass.</source>
          <target state="translated">Максимальное количество магазинов для попытки слияния в более широкие магазины в магазине слияния проходят.</target>
        </trans-unit>
        <trans-unit id="ae1a00d3b58c9f16d33b3348661fd11eee89c1d8" translate="yes" xml:space="preserve">
          <source>The maximum number of times a callsite can appear in a call stack within the analyzer, before terminating analysis of a call that would recurse deeper.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6caef17bd294964937582b8b58bab7601c99e27b" translate="yes" xml:space="preserve">
          <source>The maximum number of times that an instruction is scheduled during selective scheduling. This is the limit on the number of iterations through which the instruction may be pipelined.</source>
          <target state="translated">Максимальное количество запланированных инструкций во время выборочного планирования.Это ограничение на количество итераций,через которые может проходить инструкция.</target>
        </trans-unit>
        <trans-unit id="ddefe1cfc3442fba935b71446bc04ed2a446b364" translate="yes" xml:space="preserve">
          <source>The maximum number of times the outer loop should be unrolled by the unroll-and-jam transformation.</source>
          <target state="translated">Максимальное количество раз разворачивания внешнего контура должно быть выполнено с помощью преобразования unroll-and-jam (разворачивание и заклинивание).</target>
        </trans-unit>
        <trans-unit id="1df2840a57590d0c992c35b1f7cd4db504ccf715" translate="yes" xml:space="preserve">
          <source>The maximum number of unrollings of a single loop.</source>
          <target state="translated">Максимальное количество разворачиваний одного цикла.</target>
        </trans-unit>
        <trans-unit id="06e4b31a55ed6d6ed41d2b2d48b6006b46bfa532" translate="yes" xml:space="preserve">
          <source>The maximum relative execution frequency (in percents) of the target block relative to a statement&amp;rsquo;s original block to allow statement sinking of a statement. Larger numbers result in more aggressive statement sinking. A small positive adjustment is applied for statements with memory operands as those are even more profitable so sink.</source>
          <target state="translated">Максимальная относительная частота выполнения (в процентах) целевого блока по отношению к исходному блоку оператора, позволяющая поглотить инструкцию. Большие числа приводят к более агрессивному опусканию заявления. Небольшая положительная корректировка применяется к операторам с операндами в памяти, так как они еще более выгодны, поэтому опускаются.</target>
        </trans-unit>
        <trans-unit id="c4e2688875615cab366f32942394edf8b4b91705" translate="yes" xml:space="preserve">
          <source>The maximum size measured as number of RTLs that can be recorded in an expression in combiner for a pseudo register as last known value of that register.</source>
          <target state="translated">Максимальный размер,измеряемый как количество RTL,которое может быть записано в выражении в комбинаторе для псевдорегистра как последнее известное значение этого регистра.</target>
        </trans-unit>
        <trans-unit id="159ffd5e6070239f87afd549cbfcfd8ded2b299d" translate="yes" xml:space="preserve">
          <source>The maximum size of the lookahead window of selective scheduling. It is a depth of search for available instructions.</source>
          <target state="translated">Максимальный размер окна просмотра выборочного планирования.Это глубина поиска доступных инструкций.</target>
        </trans-unit>
        <trans-unit id="f3da3af33190929d9965056fd52af9e74099ff3d" translate="yes" xml:space="preserve">
          <source>The memory order parameter is a signed int, but only the lower 16 bits are reserved for the memory order. The remainder of the signed int is reserved for target use and should be 0. Use of the predefined atomic values ensures proper usage.</source>
          <target state="translated">Параметр &quot;Ордер памяти&quot; является знаковым int,но для него резервируются только младшие 16 бит.Оставшаяся часть значащей int зарезервирована для целевого использования и должна быть равна 0.Использование предопределенных атомных значений обеспечивает правильное использование.</target>
        </trans-unit>
        <trans-unit id="9c9000c0e6476a4bcab6775fb476be520bb235b5" translate="yes" xml:space="preserve">
          <source>The memory-based pseudo-registers $mem0 through $mem15.</source>
          <target state="translated">Псевдорегистры на основе памяти от $mem0 до $mem15.</target>
        </trans-unit>
        <trans-unit id="5f9aeac04a443a9f208cd4c4e6f4207cbf2bb24b" translate="yes" xml:space="preserve">
          <source>The message attached to the attribute is affected by the setting of the</source>
          <target state="translated">На сообщение,прикрепленное к атрибуту,влияет настройка параметра</target>
        </trans-unit>
        <trans-unit id="535f4a6df8d49970089b47a9552616a59f08c505" translate="yes" xml:space="preserve">
          <source>The message is in keeping with the output of</source>
          <target state="translated">Сообщение соответствует выводу</target>
        </trans-unit>
        <trans-unit id="22d9ad2ced8af2273cacd0833b5a4654b153618b" translate="yes" xml:space="preserve">
          <source>The method by which preprocessing tokens (possibly resulting from macro expansion) in a &lt;code&gt;#include&lt;/code&gt; directive are combined into a header name (C90 6.8.2, C99 and C11 6.10.2).</source>
          <target state="translated">Метод, с помощью которого токены предварительной обработки (возможно, полученные в результате расширения макроса) в директиве &lt;code&gt;#include&lt;/code&gt; объединяются в имя заголовка (C90 6.8.2, C99 и C11 6.10.2).</target>
        </trans-unit>
        <trans-unit id="64dacbdf1cd80117047022b9711381d6ea5221d3" translate="yes" xml:space="preserve">
          <source>The method is called repeatedly during a fast enumeration to retrieve batches of objects. Each invocation of the method should retrieve the next batch of objects.</source>
          <target state="translated">Метод вызывается многократно во время быстрого подсчета для получения партий объектов.При каждом вызове метода должна быть получена очередная партия объектов.</target>
        </trans-unit>
        <trans-unit id="c7fa0fb8f65f5da5a26a900516ca2af75a19d924" translate="yes" xml:space="preserve">
          <source>The method used by GCC is as follows: a structure or union which is 1, 2, 4 or 8 bytes long is returned like a scalar. A structure or union with any other size is stored into an address supplied by the caller (usually in a special, fixed register, but on some machines it is passed on the stack). The target hook &lt;code&gt;TARGET_STRUCT_VALUE_RTX&lt;/code&gt; tells GCC where to pass this address.</source>
          <target state="translated">GCC использует следующий метод: структура или объединение длиной 1, 2, 4 или 8 байтов возвращается как скаляр. Структура или объединение с любым другим размером хранится по адресу, предоставленному вызывающей стороной (обычно в специальном фиксированном регистре, но на некоторых машинах они передаются в стек). Целевая ловушка &lt;code&gt;TARGET_STRUCT_VALUE_RTX&lt;/code&gt; сообщает GCC, куда передать этот адрес.</target>
        </trans-unit>
        <trans-unit id="cea71b7dec6652fd1c586605bdaf1afaabd9e0d7" translate="yes" xml:space="preserve">
          <source>The middle operand in a conditional expression may be omitted. Then if the first operand is nonzero, its value is the value of the conditional expression.</source>
          <target state="translated">Средний операнд в условном выражении может быть опущен.Тогда,если первый операнд ненулевой,его значение является значением условного выражения.</target>
        </trans-unit>
        <trans-unit id="6b9ca9444f11bb1174b6690d0f150eb398c757b0" translate="yes" xml:space="preserve">
          <source>The mini registers r0 - r7.</source>
          <target state="translated">Мини регистры r0-r7.</target>
        </trans-unit>
        <trans-unit id="e080de9f963115473e6c7f8a5387551ad83e48b0" translate="yes" xml:space="preserve">
          <source>The minimal probability of speculation success (in percents), so that speculative insns are scheduled.</source>
          <target state="translated">Минимальная вероятность успеха спекуляции (в процентах),так что спекулятивные вкладыши запланированы.</target>
        </trans-unit>
        <trans-unit id="aaffaaa968786a2da6ad4d8b8e0d5b378cb65a74" translate="yes" xml:space="preserve">
          <source>The minimum cost of an expensive expression in the loop invariant motion.</source>
          <target state="translated">Минимальная стоимость дорогостоящего выражения в цикле инвариантного движения.</target>
        </trans-unit>
        <trans-unit id="efe3bb81fc851386e4b7cee22649ff792c38641a" translate="yes" xml:space="preserve">
          <source>The minimum fraction of profile runs a given basic block execution count must be not to be considered unlikely.</source>
          <target state="translated">Минимальная доля профиля,проходящего через заданный базовый блок,не должна считаться маловероятной.</target>
        </trans-unit>
        <trans-unit id="92f1b567f7a83d5184bace5014aac03377eeb221" translate="yes" xml:space="preserve">
          <source>The minimum number of instructions that must be matched at the end of two blocks before cross-jumping is performed on them. This value is ignored in the case where all instructions in the block being cross-jumped from are matched.</source>
          <target state="translated">Минимальное количество инструкций,которые должны быть сопоставлены в конце двух блоков перед выполнением перекрестных прыжков на них.Это значение игнорируется в случае совпадения всех инструкций в перепрыгивающем блоке.</target>
        </trans-unit>
        <trans-unit id="02c154dc267dae6541e650ecc75738b7fc1946c1" translate="yes" xml:space="preserve">
          <source>The minimum number of iterations per thread of an innermost parallelized loop for which the parallelized variant is preferred over the single threaded one. Note that for a parallelized loop nest the minimum number of iterations of the outermost loop per thread is two.</source>
          <target state="translated">Минимальное количество итераций на поток самого внутреннего распараллеленного цикла,для которого предпочтительнее распараллеленный вариант,чем однопоточный.Обратите внимание,что для гнезда распараллеленного цикла минимальное количество итераций самого внешнего цикла на поток равно двум.</target>
        </trans-unit>
        <trans-unit id="2647f0a952db726e7e97cf159b9a0ce4dc6514c9" translate="yes" xml:space="preserve">
          <source>The minimum number of iterations under which loops are not vectorized when</source>
          <target state="translated">Минимальное количество итераций,при которых циклы не векторизуются,когда</target>
        </trans-unit>
        <trans-unit id="a016de6d4b3751317d101162f7adccf0bba87a22" translate="yes" xml:space="preserve">
          <source>The minimum number of supernodes within a function for the analyzer to consider summarizing its effects at call sites.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="44ff09fc2cb3e08a9eb4ff0c94daf816032e979a" translate="yes" xml:space="preserve">
          <source>The minimum percentage of memory references that must be optimized away for the unroll-and-jam transformation to be considered profitable.</source>
          <target state="translated">Минимальный процент обращений к памяти,который должен быть оптимизирован для того,чтобы преобразование unroll-and-jam считалось прибыльным.</target>
        </trans-unit>
        <trans-unit id="129a020d6e4e2d22eefb43a7999c4dc2402a1a50" translate="yes" xml:space="preserve">
          <source>The minimum probability (in percents) of reaching a source block for interblock speculative scheduling.</source>
          <target state="translated">Минимальная вероятность (в процентах)достижения исходного блока для межблочного спекулятивного планирования.</target>
        </trans-unit>
        <trans-unit id="dc4b50e8ed53d44237971958e2e83e18524eb941" translate="yes" xml:space="preserve">
          <source>The minimum probability an edge must have for the scheduler to save its state across it.</source>
          <target state="translated">Минимальная вероятность,которую должен иметь фронт,чтобы планировщик сохранил свое состояние через него.</target>
        </trans-unit>
        <trans-unit id="61926ef9181910c24fa1d9136e2e7aa3bdc9bb32" translate="yes" xml:space="preserve">
          <source>The minimum ratio between stride of two loops for interchange to be profitable.</source>
          <target state="translated">Минимальное соотношение между шагами двух циклов для того,чтобы обмен был прибыльным.</target>
        </trans-unit>
        <trans-unit id="8e01e027a6a504c434a5c40600808d2984b71737" translate="yes" xml:space="preserve">
          <source>The minimum ratio between the number of instructions and the number of memory references to enable prefetching in a loop.</source>
          <target state="translated">Минимальное соотношение между количеством инструкций и количеством обращений к памяти для включения предварительной выборки в цикле.</target>
        </trans-unit>
        <trans-unit id="0c8448923459ab38ab3cc0b8bb13a936b3627b06" translate="yes" xml:space="preserve">
          <source>The minimum ratio between the number of instructions and the number of prefetches to enable prefetching in a loop.</source>
          <target state="translated">Минимальное соотношение между количеством инструкций и количеством предварительной выборки для включения предварительной выборки в цикле.</target>
        </trans-unit>
        <trans-unit id="8220c9492a5b7435fa642b1e05152b364a262db5" translate="yes" xml:space="preserve">
          <source>The minimum size of buffers (i.e. arrays) that receive stack smashing protection when</source>
          <target state="translated">Минимальный размер буферов (т.е.массивов),которые получают защиту от разбивания стека,когда</target>
        </trans-unit>
        <trans-unit id="13054edb9e1ab6c7cefbb0f40ba19b0915f9beae" translate="yes" xml:space="preserve">
          <source>The minimum size of variables taking part in stack slot sharing when not optimizing.</source>
          <target state="translated">Минимальный размер переменных,участвующих в разделении слотов стека при неоптимизации.</target>
        </trans-unit>
        <trans-unit id="2c2de50582a702ec4d7ad2fc7c8e60438b0f0aa8" translate="yes" xml:space="preserve">
          <source>The minimum value of stage count that swing modulo scheduler generates.</source>
          <target state="translated">Минимальное значение счетчика этапов,которое генерирует планировщик по модулю качания.</target>
        </trans-unit>
        <trans-unit id="e61665509912f06aa6c9cfa2083ef8e16d79724c" translate="yes" xml:space="preserve">
          <source>The most straightforward way to link a program to use a particular C++ library is to use a C++ driver that specifies that C++ library by default. The &lt;code&gt;g++&lt;/code&gt; driver, for example, tells the linker where to find GCC&amp;rsquo;s C++ library (</source>
          <target state="translated">Самый простой способ связать программу для использования определенной библиотеки C ++ - использовать драйвер C ++, который по умолчанию указывает эту библиотеку C ++. &lt;code&gt;g++&lt;/code&gt; драйвера, например, сообщает компоновщик , где найти библиотеку GCC в C ++ (</target>
        </trans-unit>
        <trans-unit id="df6349c8ef5b50987899abffe38003acbe800a64" translate="yes" xml:space="preserve">
          <source>The multiprocessing extension.</source>
          <target state="translated">Многопроцессорное расширение.</target>
        </trans-unit>
        <trans-unit id="8d24347b639fc5c1199b8f3590bff6a146e13c82" translate="yes" xml:space="preserve">
          <source>The name of the function.</source>
          <target state="translated">Название функции.</target>
        </trans-unit>
        <trans-unit id="62e8e383964ec0763f310d8e73ac1d3feb12f8de" translate="yes" xml:space="preserve">
          <source>The names of specific parameters, and the meaning of the values, are tied to the internals of the compiler, and are subject to change without notice in future releases.</source>
          <target state="translated">Имена конкретных параметров и значение значений привязаны к внутренним компонентам компилятора и могут быть изменены без уведомления в будущих релизах.</target>
        </trans-unit>
        <trans-unit id="329fe73400bc50b68cb243f0ab550043e7c95935" translate="yes" xml:space="preserve">
          <source>The native Linux/GNU toolchain also supports the value &amp;lsquo;</source>
          <target state="translated">Собственный набор инструментов Linux / GNU также поддерживает значение '</target>
        </trans-unit>
        <trans-unit id="04c44aa6fff9d063f62cf98bb0599d7c6a3d3bb6" translate="yes" xml:space="preserve">
          <source>The nested function can access all the variables of the containing function that are visible at the point of its definition. This is called &lt;em&gt;lexical scoping&lt;/em&gt;. For example, here we show a nested function which uses an inherited variable named &lt;code&gt;offset&lt;/code&gt;:</source>
          <target state="translated">Вложенная функция может получить доступ ко всем переменным содержащейся функции, которые видны в точке ее определения. Это называется &lt;em&gt;лексической областью видимости&lt;/em&gt; . Например, здесь мы показываем вложенную функцию, которая использует унаследованную переменную с именем &lt;code&gt;offset&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="d50cb616ffb2082a3e3b7e7c2d21914b6c5a5b8a" translate="yes" xml:space="preserve">
          <source>The nested function&amp;rsquo;s name is local to the block where it is defined. For example, here we define a nested function named &lt;code&gt;square&lt;/code&gt;, and call it twice:</source>
          <target state="translated">Имя вложенной функции является локальным для блока, в котором она определена. Например, здесь мы определяем вложенную функцию с именем &lt;code&gt;square&lt;/code&gt; и вызываем ее дважды:</target>
        </trans-unit>
        <trans-unit id="2a845c4dca5c001e6d102157bfd313918d6f8a24" translate="yes" xml:space="preserve">
          <source>The nesting limit for &lt;code&gt;#include&lt;/code&gt; processing (C90 6.8.2, C99 and C11 6.10.2).</source>
          <target state="translated">Предел вложенности для обработки &lt;code&gt;#include&lt;/code&gt; (C90 6.8.2, C99 и C11 6.10.2).</target>
        </trans-unit>
        <trans-unit id="1446b5bc47ae4093c3d59b0d15fb2e41a888d931" translate="yes" xml:space="preserve">
          <source>The next example shows a case where the optimizers can recognize that the input (&lt;code&gt;dwSomeValue&lt;/code&gt;) never changes during the execution of the function and can therefore move the &lt;code&gt;asm&lt;/code&gt; outside the loop to produce more efficient code. Again, using the &lt;code&gt;volatile&lt;/code&gt; qualifier disables this type of optimization.</source>
          <target state="translated">В следующем примере показан случай, когда оптимизаторы могут распознать, что входные данные ( &lt;code&gt;dwSomeValue&lt;/code&gt; ) никогда не изменяются во время выполнения функции, и поэтому могут переместить &lt;code&gt;asm&lt;/code&gt; за пределы цикла для создания более эффективного кода. Опять же, использование квалификатора &lt;code&gt;volatile&lt;/code&gt; отключает этот тип оптимизации.</target>
        </trans-unit>
        <trans-unit id="90026784c98f629fb36fb07ae9132c36ffa32047" translate="yes" xml:space="preserve">
          <source>The next revision of the ISO C++ standard, planned for 2020. Support is highly experimental, and will almost certainly change in incompatible ways in future releases.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1737091e750836f7db5ac991c2404cb583f13f75" translate="yes" xml:space="preserve">
          <source>The next revision of the ISO C++ standard, tentatively planned for 2020. Support is highly experimental, and will almost certainly change in incompatible ways in future releases.</source>
          <target state="translated">Следующая редакция стандарта ИСО С++,предварительно запланированная на 2020 год.Поддержка является в высшей степени экспериментальной и почти наверняка изменится несовместимыми способами в будущих релизах.</target>
        </trans-unit>
        <trans-unit id="07fa07f1abd567516650f6c81218681c600c92af" translate="yes" xml:space="preserve">
          <source>The next version of the ISO C standard, still under development, plus GNU extensions. The support for this version is experimental and incomplete.</source>
          <target state="translated">Следующая версия стандарта ISO C,все еще находящаяся в разработке,плюс расширения GNU.Поддержка этой версии экспериментальная и неполная.</target>
        </trans-unit>
        <trans-unit id="2b02aa6b6d3d78493fbc1dc480d37a214f73df64" translate="yes" xml:space="preserve">
          <source>The next version of the ISO C standard, still under development. The support for this version is experimental and incomplete.</source>
          <target state="translated">Следующая версия стандарта ИСО С,все еще находится в стадии разработки.Поддержка этой версии является экспериментальной и неполной.</target>
        </trans-unit>
        <trans-unit id="2f0fbf82a063b2707d9377f7fa702f1fc2dca6a1" translate="yes" xml:space="preserve">
          <source>The nine trigraphs and their replacements are</source>
          <target state="translated">Девять триграфов и их замещение -</target>
        </trans-unit>
        <trans-unit id="d3e272d2493136e9ddd803eb8bb6b214c461ac69" translate="yes" xml:space="preserve">
          <source>The nineteen 32-bit registers comprising general register R0 to R14, control register GBR, and system registers MACH, MACL, and PR and the vector table address offset are saved into a register bank. Register banks are stacked in first-in last-out (FILO) sequence. Restoration from the bank is executed by issuing a RESBANK instruction.</source>
          <target state="translated">Девятнадцать 32-битных регистров,включающих общий регистр R0-R14,управляющий регистр GBR,а также системные регистры MACH,MACL и PR и смещение адресов в векторных таблицах,сохраняются в банке регистров.Регистровые банки складываются в последовательность FILO (first-in lastt-out).Восстановление из банка осуществляется путем выдачи распоряжения RESBANK.</target>
        </trans-unit>
        <trans-unit id="3ee0e8fe4a16194f52480c8cf2068fc9bdcd0c7f" translate="yes" xml:space="preserve">
          <source>The non-atomic types are encoded as follows:</source>
          <target state="translated">Неатомные типы кодируются следующим образом:</target>
        </trans-unit>
        <trans-unit id="7bfaebfb4258608ad40629ce440aac9193290911" translate="yes" xml:space="preserve">
          <source>The normal vector extract, and set operations work on &lt;var&gt;vector __int128&lt;/var&gt; and &lt;var&gt;vector __uint128&lt;/var&gt; types, but the index value must be 0.</source>
          <target state="translated">Операции извлечения вектора нормали и операции набора работают с &lt;var&gt;vector __int128&lt;/var&gt; и &lt;var&gt;vector __uint128&lt;/var&gt; , но значение индекса должно быть 0.</target>
        </trans-unit>
        <trans-unit id="ec51f6eb264a163ff7656783d752463b0cf474e2" translate="yes" xml:space="preserve">
          <source>The null pointer constant to which the macro &lt;code&gt;NULL&lt;/code&gt; expands (C90 7.1.6, C99 7.17, C11 7.19).</source>
          <target state="translated">Константа нулевого указателя, до которой расширяется макрос &lt;code&gt;NULL&lt;/code&gt; (C90 7.1.6, C99 7.17, C11 7.19).</target>
        </trans-unit>
        <trans-unit id="28be55da2d33dfd035a16c7e12609f9fde68fbf1" translate="yes" xml:space="preserve">
          <source>The number of Newton iterations for calculating the reciprocal for double type. The precision of division is propotional to this param when division approximation is enabled. The default value is 2.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6669979f69801134fe5425b263914957ab4a88a7" translate="yes" xml:space="preserve">
          <source>The number of Newton iterations for calculating the reciprocal for float type. The precision of division is proportional to this param when division approximation is enabled. The default value is 1.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="38d03781cbc2651157f17e0c5fbab40ff5879c62" translate="yes" xml:space="preserve">
          <source>The number of bits in a byte (C90 3.4, C99 and C11 3.6).</source>
          <target state="translated">Количество битов в байте (C90 3.4,C99 и C11 3.6).</target>
        </trans-unit>
        <trans-unit id="5116832175ad50d3f8b15e3495e553905314a198" translate="yes" xml:space="preserve">
          <source>The number of cycles the swing modulo scheduler considers when checking conflicts using DFA.</source>
          <target state="translated">Количество циклов,которое планировщик качающегося модуля учитывает при проверке конфликтов с помощью DFA.</target>
        </trans-unit>
        <trans-unit id="4fb7b94d708168700c159e251d0f9d5fce1fc8c3" translate="yes" xml:space="preserve">
          <source>The number of elements for which hash table verification is done for each searched element.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0a72ad254c79a1eea72a19a4968bbd0e5a7dddcb" translate="yes" xml:space="preserve">
          <source>The number of executions of a basic block which is considered hot. The parameter is used only in GIMPLE FE.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce1f697b40b6aa8756d941d13116c5069d63cf0d" translate="yes" xml:space="preserve">
          <source>The number of most executed permilles, ranging from 0 to 1000, of the profiled execution of the entire program to which the execution count of a basic block must be part of in order to be considered hot. The default is 990, which means that a basic block is considered hot if its execution count contributes to the upper 990 permilles, or 99.0%, of the profiled execution of the entire program. 0 means that it is never considered hot. Used in LTO mode.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1520c1ee154295eb07c627660dca8d1a6b6092fb" translate="yes" xml:space="preserve">
          <source>The number of significant initial characters in an identifier (C90 6.1.2, C90, C99 and C11 5.2.4.1, C99 and C11 6.4.2).</source>
          <target state="translated">Количество значимых начальных знаков в идентификаторе (C90 6.1.2,C90,C99 и C11 5.2.4.1,C99 и C11 6.4.2).</target>
        </trans-unit>
        <trans-unit id="070362ab17f17b33a3ae34d59055a18a1e302bf9" translate="yes" xml:space="preserve">
          <source>The number, order, and encoding of bytes in any object (when not explicitly specified in this International Standard) (C99 and C11 6.2.6.1).</source>
          <target state="translated">Номер,порядок и кодировка байтов в любом объекте (если в данном международном стандарте это явно не указано)(C99 и C11 6.2.6.1).</target>
        </trans-unit>
        <trans-unit id="b604e74e2e851789383571b70ad652997e4e66f6" translate="yes" xml:space="preserve">
          <source>The object is accessed with the respective segment override prefix.</source>
          <target state="translated">Доступ к объекту осуществляется с помощью префикса переопределения соответствующего сегмента.</target>
        </trans-unit>
        <trans-unit id="3a5091aabdc201178dc68e9213e404a14e73a3fa" translate="yes" xml:space="preserve">
          <source>The object pointed to by the first argument must be of integer or pointer type. It must not be a boolean type.</source>
          <target state="translated">Объект,на который указывает первый аргумент,должен иметь целочисленный или указатель.Он не должен быть булевым типом.</target>
        </trans-unit>
        <trans-unit id="a4db2564696e493fee1ef7423f76307823d51b1d" translate="yes" xml:space="preserve">
          <source>The object pointed to by the first argument must be of integer or pointer type. It must not be a boolean type. All memory orders are valid.</source>
          <target state="translated">Объект,на который указывает первый аргумент,должен иметь целочисленный или указатель.Он не должен быть булевым типом.Все порядки памяти действительны.</target>
        </trans-unit>
        <trans-unit id="13e4eecfa7c007179ae8943f279500072d8d783d" translate="yes" xml:space="preserve">
          <source>The only difference between &amp;lsquo;</source>
          <target state="translated">Единственная разница между '</target>
        </trans-unit>
        <trans-unit id="e3de508e233b8d2680fdf435e3d6c8313768a8db" translate="yes" xml:space="preserve">
          <source>The only supported use for this feature is to specify registers for input and output operands when calling Extended &lt;code&gt;asm&lt;/code&gt; (see &lt;a href=&quot;extended-asm#Extended-Asm&quot;&gt;Extended Asm&lt;/a&gt;). This may be necessary if the constraints for a particular machine don&amp;rsquo;t provide sufficient control to select the desired register. To force an operand into a register, create a local variable and specify the register name after the variable&amp;rsquo;s declaration. Then use the local variable for the &lt;code&gt;asm&lt;/code&gt; operand and specify any constraint letter that matches the register:</source>
          <target state="translated">Единственное поддерживаемое использование этой функции - указание регистров для входных и выходных операндов при вызове Extended &lt;code&gt;asm&lt;/code&gt; (см. &lt;a href=&quot;extended-asm#Extended-Asm&quot;&gt;Extended Asm&lt;/a&gt; ). Это может быть необходимо, если ограничения для конкретной машины не обеспечивают достаточного контроля для выбора желаемого регистра. Чтобы принудительно поместить операнд в регистр, создайте локальную переменную и укажите имя регистра после объявления переменной. Затем используйте локальную переменную для операнда &lt;code&gt;asm&lt;/code&gt; и укажите любую букву ограничения, соответствующую регистру:</target>
        </trans-unit>
        <trans-unit id="80fd38457618adab2fab3528f71d1285f53dd5df" translate="yes" xml:space="preserve">
          <source>The operand is the number of a register to be read. Generates:</source>
          <target state="translated">Операнд-это номер реестра,который нужно прочитать.Генерирует:</target>
        </trans-unit>
        <trans-unit id="164925c793e36006eed2abf2f19f4ef48755a0ed" translate="yes" xml:space="preserve">
          <source>The operand of &lt;code&gt;typeof&lt;/code&gt; is evaluated for its side effects if and only if it is an expression of variably modified type or the name of such a type.</source>
          <target state="translated">Операнд &lt;code&gt;typeof&lt;/code&gt; оценивается на предмет его побочных эффектов тогда и только тогда, когда он является выражением изменяемого типа или именем такого типа.</target>
        </trans-unit>
        <trans-unit id="6d2a4c2f3546ef01bb01773e4920ca0359e67ac5" translate="yes" xml:space="preserve">
          <source>The operand, &lt;var&gt;auxv&lt;/var&gt;, is the address of an auxiliary register and must be a compile time constant. Generates:</source>
          <target state="translated">Операнд, &lt;var&gt;auxv&lt;/var&gt; , является адресом вспомогательного регистра и должен быть постоянной времени компиляции. Формирует:</target>
        </trans-unit>
        <trans-unit id="3479099f68d087cc74ace860bc00a95f5b731c1f" translate="yes" xml:space="preserve">
          <source>The operations behave like C++ &lt;code&gt;valarrays&lt;/code&gt;. Addition is defined as the addition of the corresponding elements of the operands. For example, in the code below, each of the 4 elements in &lt;var&gt;a&lt;/var&gt; is added to the corresponding 4 elements in &lt;var&gt;b&lt;/var&gt; and the resulting vector is stored in &lt;var&gt;c&lt;/var&gt;.</source>
          <target state="translated">Операции ведут себя как &lt;code&gt;valarrays&lt;/code&gt; C ++ . Добавление определяется как добавление соответствующих элементов операндов. Например, в приведенном ниже коде каждый из 4 элементов в &lt;var&gt;a&lt;/var&gt; добавляется к соответствующим 4 элементам в &lt;var&gt;b&lt;/var&gt; , а результирующий вектор сохраняется в &lt;var&gt;c&lt;/var&gt; .</target>
        </trans-unit>
        <trans-unit id="fde6238c26830fa82a53914b9244e589ab1e426d" translate="yes" xml:space="preserve">
          <source>The operator &amp;lsquo;</source>
          <target state="translated">Оператор '</target>
        </trans-unit>
        <trans-unit id="e6c35a6661bd8051bda6c84d11bcf3693039836f" translate="yes" xml:space="preserve">
          <source>The opposite</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d9594a87362ce1971b7a9efe4bfc116ba95e426" translate="yes" xml:space="preserve">
          <source>The option</source>
          <target state="translated">Опция</target>
        </trans-unit>
        <trans-unit id="ae1ce068a17e5dbe0ea035d1beb9f2b11368df02" translate="yes" xml:space="preserve">
          <source>The option also sets the ISA to use. If the MCU name is one that is known to only support the 430 ISA then that is selected, otherwise the 430X ISA is selected. A generic MCU name of &amp;lsquo;</source>
          <target state="translated">Эта опция также устанавливает ISA для использования. Если известно, что имя MCU поддерживает только 430 ISA, то выбирается оно, в противном случае выбирается 430X ISA. Общее имя MCU '</target>
        </trans-unit>
        <trans-unit id="bace175215f4c9a9a5086a4520e874099d58bc7b" translate="yes" xml:space="preserve">
          <source>The option cannot be combined with</source>
          <target state="translated">Опция не может быть объединена с</target>
        </trans-unit>
        <trans-unit id="c9e6b8f7b2e1e4a87728188dd3bdb8e34222fb03" translate="yes" xml:space="preserve">
          <source>The option has three forms:</source>
          <target state="translated">Вариант имеет три формы:</target>
        </trans-unit>
        <trans-unit id="f57372a8b45a9a651870f464f28239ea0a9400c1" translate="yes" xml:space="preserve">
          <source>The option is equivalent to</source>
          <target state="translated">Опцион эквивалентен</target>
        </trans-unit>
        <trans-unit id="25431ae1de44b7a0042861eaf001a15d12b77c5c" translate="yes" xml:space="preserve">
          <source>The option is similar to</source>
          <target state="translated">Опция аналогична</target>
        </trans-unit>
        <trans-unit id="3f0b2b21730ed2a5e07ab579f0c874433e03d81f" translate="yes" xml:space="preserve">
          <source>The option&amp;rsquo;s behavior depends on the</source>
          <target state="translated">Поведение опции зависит от</target>
        </trans-unit>
        <trans-unit id="7003d8dcf16f832eac06c03046c9a171fa807708" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;volatile&lt;/code&gt; qualifier has no effect. All basic &lt;code&gt;asm&lt;/code&gt; blocks are implicitly volatile.</source>
          <target state="translated">Необязательный квалификатор &lt;code&gt;volatile&lt;/code&gt; не действует. Все базовые блоки &lt;code&gt;asm&lt;/code&gt; неявно изменчивы.</target>
        </trans-unit>
        <trans-unit id="74a01a1e7aeded7ac16f376b31f6e97656f61592" translate="yes" xml:space="preserve">
          <source>The optional &lt;var&gt;sirevision&lt;/var&gt; specifies the silicon revision of the target Blackfin processor. Any workarounds available for the targeted silicon revision are enabled. If &lt;var&gt;sirevision&lt;/var&gt; is &amp;lsquo;</source>
          <target state="translated">Дополнительное &lt;var&gt;sirevision&lt;/var&gt; указывает версию микросхемы целевого процессора Blackfin. Включены любые обходные пути, доступные для целевой версии кремния. Если &lt;var&gt;sirevision&lt;/var&gt; '</target>
        </trans-unit>
        <trans-unit id="875be52030ba25094435899fd42d910088a7a954" translate="yes" xml:space="preserve">
          <source>The optional &lt;var&gt;size-index&lt;/var&gt; positional argument denotes a function argument of integer type that specifies the maximum size of the access. The size is the number of elements of the type referenced by &lt;var&gt;ref-index&lt;/var&gt;, or the number of bytes when the pointer type is &lt;code&gt;void*&lt;/code&gt;. When no &lt;var&gt;size-index&lt;/var&gt; argument is specified, the pointer argument must be either null or point to a space that is suitably aligned and large for at least one object of the referenced type (this implies that a past-the-end pointer is not a valid argument). The actual size of the access may be less but it must not be more.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f72849bef73954b968c2b10753acfe7d2de97d61" translate="yes" xml:space="preserve">
          <source>The optional argument &lt;var&gt;mask&lt;/var&gt; may have the value &lt;code&gt;notinbranch&lt;/code&gt; or &lt;code&gt;inbranch&lt;/code&gt;, and instructs the compiler to generate non-masked or masked clones correspondingly. By default, all clones are generated.</source>
          <target state="translated">Необязательная &lt;var&gt;mask&lt;/var&gt; аргумента может иметь значение &lt;code&gt;notinbranch&lt;/code&gt; или &lt;code&gt;inbranch&lt;/code&gt; и инструктирует компилятор генерировать немаскированные или замаскированные клоны соответственно. По умолчанию создаются все клоны.</target>
        </trans-unit>
        <trans-unit id="bf601c68a359b3325301de84f8214ec6cb3bee0d" translate="yes" xml:space="preserve">
          <source>The optional extension of specifying vector constants in parentheses is not supported.</source>
          <target state="translated">Необязательное расширение указания векторных констант в круглых скобках не поддерживается.</target>
        </trans-unit>
        <trans-unit id="8e1def618310843db3ebed1e3d40c1b748262844" translate="yes" xml:space="preserve">
          <source>The optional first word limits the specification to structs that are used directly (&amp;lsquo;</source>
          <target state="translated">Необязательное первое слово ограничивает спецификацию структурами, которые используются напрямую ('</target>
        </trans-unit>
        <trans-unit id="a9fe5708942d28978cc841b9258dd8862934e265" translate="yes" xml:space="preserve">
          <source>The optional second word limits the specification to ordinary structs (&amp;lsquo;</source>
          <target state="translated">Необязательное второе слово ограничивает спецификацию обычными структурами ('</target>
        </trans-unit>
        <trans-unit id="01a150b476753c90be937c4eb85655e5b29ceeef" translate="yes" xml:space="preserve">
          <source>The options</source>
          <target state="translated">Опции</target>
        </trans-unit>
        <trans-unit id="ac4a8e159eb45db26e41d6b181749d12e91d13f3" translate="yes" xml:space="preserve">
          <source>The options from each group can be freely mixed as they are non-overlapping. However, in case of any conflicts, the later options override the earlier options on the command line.</source>
          <target state="translated">Опции из каждой группы могут свободно смешиваться,так как они не пересекаются.Однако,в случае каких-либо конфликтов,более поздние опции переопределяют более ранние опции в командной строке.</target>
        </trans-unit>
        <trans-unit id="03370c70b8d685b972b4178e392c07f67da021e0" translate="yes" xml:space="preserve">
          <source>The options in this section are defined for all VxWorks targets. Options specific to the target hardware are listed with the other options for that target.</source>
          <target state="translated">Опции в этом разделе определены для всех целей VxWorks.Опции,специфичные для целевого оборудования,перечислены с другими опциями для этой цели.</target>
        </trans-unit>
        <trans-unit id="ee4645ad9aafdb886f64431f817492a531da45bb" translate="yes" xml:space="preserve">
          <source>The options supported are specific to each target; refer to &lt;a href=&quot;x86-function-attributes#x86-Function-Attributes&quot;&gt;x86 Function Attributes&lt;/a&gt;, &lt;a href=&quot;powerpc-function-attributes#PowerPC-Function-Attributes&quot;&gt;PowerPC Function Attributes&lt;/a&gt;, &lt;a href=&quot;arm-function-attributes#ARM-Function-Attributes&quot;&gt;ARM Function Attributes&lt;/a&gt;, &lt;a href=&quot;aarch64-function-attributes#AArch64-Function-Attributes&quot;&gt;AArch64 Function Attributes&lt;/a&gt;, &lt;a href=&quot;nios-ii-function-attributes#Nios-II-Function-Attributes&quot;&gt;Nios II Function Attributes&lt;/a&gt;, and &lt;a href=&quot;s_002f390-function-attributes#S_002f390-Function-Attributes&quot;&gt;S/390 Function Attributes&lt;/a&gt; for details.</source>
          <target state="translated">Поддерживаемые параметры зависят от каждой цели; см &lt;a href=&quot;x86-function-attributes#x86-Function-Attributes&quot;&gt;х86 функциональных атрибутов&lt;/a&gt; , &lt;a href=&quot;powerpc-function-attributes#PowerPC-Function-Attributes&quot;&gt;PowerPC функциональных атрибутов&lt;/a&gt; , &lt;a href=&quot;arm-function-attributes#ARM-Function-Attributes&quot;&gt;ARM атрибутов функции&lt;/a&gt; , &lt;a href=&quot;aarch64-function-attributes#AArch64-Function-Attributes&quot;&gt;AArch64 атрибутов функции&lt;/a&gt; , &lt;a href=&quot;nios-ii-function-attributes#Nios-II-Function-Attributes&quot;&gt;функциональные атрибуты Nios II&lt;/a&gt; и &lt;a href=&quot;s_002f390-function-attributes#S_002f390-Function-Attributes&quot;&gt;S / 390 Функция Атрибуты&lt;/a&gt; для деталей.</target>
        </trans-unit>
        <trans-unit id="91a395788ed90836d2997bb1c84003ea7ffde770" translate="yes" xml:space="preserve">
          <source>The options work exactly like the S/390 specific command line options (without the prefix</source>
          <target state="translated">Опции работают точно так же,как и специфические опции командной строки S/390 (без префикса</target>
        </trans-unit>
        <trans-unit id="e9e8fa6c8ae05f8e2a34557e6036eae0a9b76ff8" translate="yes" xml:space="preserve">
          <source>The order in which &lt;code&gt;+load&lt;/code&gt; and &lt;code&gt;+initialize&lt;/code&gt; are called could be problematic if this matters. If you don&amp;rsquo;t allocate objects inside &lt;code&gt;+load&lt;/code&gt;, it is guaranteed that &lt;code&gt;+load&lt;/code&gt; is called before &lt;code&gt;+initialize&lt;/code&gt;. If you create an object inside &lt;code&gt;+load&lt;/code&gt; the &lt;code&gt;+initialize&lt;/code&gt; method of object&amp;rsquo;s class is invoked even if &lt;code&gt;+load&lt;/code&gt; was not invoked. Note if you explicitly call &lt;code&gt;+load&lt;/code&gt; on a class, &lt;code&gt;+initialize&lt;/code&gt; will be called first. To avoid possible problems try to implement only one of these methods.</source>
          <target state="translated">Порядок, в котором вызываются &lt;code&gt;+load&lt;/code&gt; и &lt;code&gt;+initialize&lt;/code&gt; , может быть проблематичным, если это имеет значение. Если вы не размещаете объекты внутри &lt;code&gt;+load&lt;/code&gt; , гарантируется, что &lt;code&gt;+load&lt;/code&gt; вызывается перед &lt;code&gt;+initialize&lt;/code&gt; . При создании объекта внутри &lt;code&gt;+load&lt;/code&gt; &lt;code&gt;+initialize&lt;/code&gt; метод класса объекта вызывается даже если &lt;code&gt;+load&lt;/code&gt; не была вызвана. Обратите внимание, что если вы явно вызываете &lt;code&gt;+load&lt;/code&gt; для класса, сначала вызывается &lt;code&gt;+initialize&lt;/code&gt; . Чтобы избежать возможных проблем, попробуйте реализовать только один из этих методов.</target>
        </trans-unit>
        <trans-unit id="d72c8cfa2bf4559a476794fbcac9230458dd1acf" translate="yes" xml:space="preserve">
          <source>The order of allocation of bit-fields within a unit (C90 6.5.2.1, C99 and C11 6.7.2.1).</source>
          <target state="translated">Порядок распределения полей битов внутри блока (С90 6.5.2.1,С99 и С11 6.7.2.1).</target>
        </trans-unit>
        <trans-unit id="13bf99243d90e9f90c583730aacfa820007d4c7a" translate="yes" xml:space="preserve">
          <source>The ordering and number of these preamble lines will be augmented as &lt;code&gt;gcov&lt;/code&gt; development progresses &amp;mdash; do not rely on them remaining unchanged. Use &lt;var&gt;tag&lt;/var&gt; to locate a particular preamble line.</source>
          <target state="translated">Порядок и количество этих строк преамбулы будут увеличиваться по мере развития &lt;code&gt;gcov&lt;/code&gt; - не рассчитывайте, что они останутся неизменными. Используйте &lt;var&gt;tag&lt;/var&gt; чтобы найти конкретную строку преамбулы.</target>
        </trans-unit>
        <trans-unit id="f78a9eb6841c341650bf4b7b23dd41a17afa341e" translate="yes" xml:space="preserve">
          <source>The original ANSI C standard (X3.159-1989) was ratified in 1989 and published in 1990. This standard was ratified as an ISO standard (ISO/IEC 9899:1990) later in 1990. There were no technical differences between these publications, although the sections of the ANSI standard were renumbered and became clauses in the ISO standard. The ANSI standard, but not the ISO standard, also came with a Rationale document. This standard, in both its forms, is commonly known as &lt;em&gt;C89&lt;/em&gt;, or occasionally as &lt;em&gt;C90&lt;/em&gt;, from the dates of ratification. To select this standard in GCC, use one of the options</source>
          <target state="translated">Исходный стандарт ANSI C (X3.159-1989) был ратифицирован в 1989 году и опубликован в 1990 году. Этот стандарт был ратифицирован как стандарт ISO (ISO / IEC 9899: 1990) позже, в 1990 году. Между этими публикациями не было технических различий, хотя разделы стандарта ANSI были перенумерованы и стали пунктами в стандарте ISO. Стандарт ANSI, но не стандарт ISO, также сопровождался обоснованием. Этот стандарт в обеих его формах обычно известен как &lt;em&gt;C89&lt;/em&gt; , а иногда и как &lt;em&gt;C90&lt;/em&gt; , начиная с даты ратификации. Чтобы выбрать этот стандарт в GCC, воспользуйтесь одним из вариантов</target>
        </trans-unit>
        <trans-unit id="21c496279e266f5ecd75f883afecb2192cd2a917" translate="yes" xml:space="preserve">
          <source>The original ISO C++ standard was published as the ISO standard (ISO/IEC 14882:1998) and amended by a Technical Corrigenda published in 2003 (ISO/IEC 14882:2003). These standards are referred to as C++98 and C++03, respectively. GCC implements the majority of C++98 (&lt;code&gt;export&lt;/code&gt; is a notable exception) and most of the changes in C++03. To select this standard in GCC, use one of the options</source>
          <target state="translated">Исходный стандарт ISO C ++ был опубликован как стандарт ISO (ISO / IEC 14882: 1998) и изменен Техническим исправлением, опубликованным в 2003 году (ISO / IEC 14882: 2003). Эти стандарты называются C ++ 98 и C ++ 03 соответственно. GCC реализует большую часть C ++ 98 ( заметным исключением является &lt;code&gt;export&lt;/code&gt; ) и большинство изменений в C ++ 03. Чтобы выбрать этот стандарт в GCC, воспользуйтесь одним из вариантов</target>
        </trans-unit>
        <trans-unit id="d55c2d645aa0f80881178d7412aa07a062ca969b" translate="yes" xml:space="preserve">
          <source>The other options specify a specific processor. Code generated under those options runs best on that processor, and may not run at all on others.</source>
          <target state="translated">Остальные опции указывают конкретный процессор.Код,сгенерированный в этих опциях,лучше всего работает на этом процессоре,и может вообще не выполняться на других.</target>
        </trans-unit>
        <trans-unit id="7b5fefa619d556bce9b8629c20698a9fbaa045b6" translate="yes" xml:space="preserve">
          <source>The output is sensitive to the effects of previous command-line options, so for example it is possible to find out which optimizations are enabled at</source>
          <target state="translated">Вывод чувствителен к эффектам предыдущих опций командной строки,так что,например,можно узнать,какие оптимизации включены в</target>
        </trans-unit>
        <trans-unit id="ee1f8d32c864542b44f4a83fd30d75feed01b2e0" translate="yes" xml:space="preserve">
          <source>The output shows that this block of code, combined by optimization, executed 100 times. In one sense this result is correct, because there was only one instruction representing all four of these lines. However, the output does not indicate how many times the result was 0 and how many times the result was 1.</source>
          <target state="translated">Вывод показывает,что этот блок кода,объединенный оптимизацией,выполнялся 100 раз.В одном смысле этот результат корректен,так как была только одна инструкция,представляющая все четыре эти строки.Однако в выводе не указано,сколько раз результат был 0 и сколько раз результат был 1.</target>
        </trans-unit>
        <trans-unit id="25cd388eab46b62953cbdcb13acb11f5a206e81f" translate="yes" xml:space="preserve">
          <source>The parameter &lt;var&gt;archetype&lt;/var&gt; determines how the format string is interpreted, and should be &lt;code&gt;printf&lt;/code&gt;, &lt;code&gt;scanf&lt;/code&gt;, &lt;code&gt;strftime&lt;/code&gt;, &lt;code&gt;gnu_printf&lt;/code&gt;, &lt;code&gt;gnu_scanf&lt;/code&gt;, &lt;code&gt;gnu_strftime&lt;/code&gt; or &lt;code&gt;strfmon&lt;/code&gt;. (You can also use &lt;code&gt;__printf__&lt;/code&gt;, &lt;code&gt;__scanf__&lt;/code&gt;, &lt;code&gt;__strftime__&lt;/code&gt; or &lt;code&gt;__strfmon__&lt;/code&gt;.) On MinGW targets, &lt;code&gt;ms_printf&lt;/code&gt;, &lt;code&gt;ms_scanf&lt;/code&gt;, and &lt;code&gt;ms_strftime&lt;/code&gt; are also present. &lt;var&gt;archetype&lt;/var&gt; values such as &lt;code&gt;printf&lt;/code&gt; refer to the formats accepted by the system&amp;rsquo;s C runtime library, while values prefixed with &amp;lsquo;</source>
          <target state="translated">Параметр &lt;var&gt;archetype&lt;/var&gt; определяет, как интерпретируется строка формата, и должен быть &lt;code&gt;printf&lt;/code&gt; , &lt;code&gt;scanf&lt;/code&gt; , &lt;code&gt;strftime&lt;/code&gt; , &lt;code&gt;gnu_printf&lt;/code&gt; , &lt;code&gt;gnu_scanf&lt;/code&gt; , &lt;code&gt;gnu_strftime&lt;/code&gt; или &lt;code&gt;strfmon&lt;/code&gt; . (Вы также можете использовать &lt;code&gt;__printf__&lt;/code&gt; , &lt;code&gt;__scanf__&lt;/code&gt; , &lt;code&gt;__strftime__&lt;/code&gt; или &lt;code&gt;__strfmon__&lt;/code&gt; .) В целях MinGW также присутствуют &lt;code&gt;ms_printf&lt;/code&gt; , &lt;code&gt;ms_scanf&lt;/code&gt; и &lt;code&gt;ms_strftime&lt;/code&gt; . значения &lt;var&gt;archetype&lt;/var&gt; такие как &lt;code&gt;printf&lt;/code&gt; относятся к форматам, принятым системной библиотекой времени выполнения C, а значения с префиксом '</target>
        </trans-unit>
        <trans-unit id="a3f3b990be6aa69326bd74ae4681ebc09216102d" translate="yes" xml:space="preserve">
          <source>The parameter &lt;var&gt;string-index&lt;/var&gt; specifies which argument is the format string argument (starting from one). Since non-static C++ methods have an implicit &lt;code&gt;this&lt;/code&gt; argument, the arguments of such methods should be counted from two.</source>
          <target state="translated">Параметр &lt;var&gt;string-index&lt;/var&gt; указывает, какой аргумент является аргументом строки формата (начиная с единицы). Поскольку нестатические методы C ++ имеют неявный аргумент &lt;code&gt;this&lt;/code&gt; , аргументы таких методов следует считать от двух.</target>
        </trans-unit>
        <trans-unit id="0bb73878f5340c14052a29fb8e00d23ff62b384d" translate="yes" xml:space="preserve">
          <source>The part of a compiler that is specific to a particular language is called the &amp;ldquo;front end&amp;rdquo;. In addition to the front ends that are integrated components of GCC, there are several other front ends that are maintained separately. These support languages such as Mercury, and COBOL. To use these, they must be built together with GCC proper.</source>
          <target state="translated">Часть компилятора, относящаяся к определенному языку, называется &amp;laquo;интерфейсом&amp;raquo;. В дополнение к интерфейсам, которые являются интегрированными компонентами GCC, существует несколько других интерфейсов, которые обслуживаются отдельно. Они поддерживают такие языки, как Mercury и COBOL. Чтобы использовать их, они должны быть собраны вместе с собственно GCC.</target>
        </trans-unit>
        <trans-unit id="27b45d0ebc931e1e733ecb9fb1c3f4c5240b8194" translate="yes" xml:space="preserve">
          <source>The particular options set for any particular CPU varies between compiler versions, depending on what setting seems to produce optimal code for that CPU; it doesn&amp;rsquo;t necessarily reflect the actual hardware&amp;rsquo;s capabilities. If you wish to set an individual option to a particular value, you may specify it after the</source>
          <target state="translated">Конкретные параметры, установленные для любого конкретного ЦП, различаются в зависимости от версии компилятора, в зависимости от того, какой параметр создает оптимальный код для этого ЦП; он не обязательно отражает фактические возможности оборудования. Если вы хотите установить для отдельной опции определенное значение, вы можете указать его после</target>
        </trans-unit>
        <trans-unit id="452dc4aa50f4dd1fa4974069451a474c59e40f9c" translate="yes" xml:space="preserve">
          <source>The parts that differ are highlighted with color (&amp;ldquo;double&amp;rdquo; and &amp;ldquo;float&amp;rdquo; in this case).</source>
          <target state="translated">Отличающиеся части выделяются цветом (в данном случае &amp;laquo;двойной&amp;raquo; и &amp;laquo;плавающий&amp;raquo;).</target>
        </trans-unit>
        <trans-unit id="9af1a3f7e74758af6362de95fe293ce9aa19535b" translate="yes" xml:space="preserve">
          <source>The percentage of function, weighted by execution frequency, that must be covered by trace formation. Used when profile feedback is available.</source>
          <target state="translated">Процентная доля функции,взвешенная по частоте выполнения,которая должна быть покрыта образованием следов.Используется при наличии обратной связи по профилю.</target>
        </trans-unit>
        <trans-unit id="2679379ebc643273c71ff53ef41c24d477972525" translate="yes" xml:space="preserve">
          <source>The permissible values for &lt;var&gt;arch&lt;/var&gt; are &amp;lsquo;</source>
          <target state="translated">Допустимые значения для &lt;var&gt;arch&lt;/var&gt; : '</target>
        </trans-unit>
        <trans-unit id="f2d47f57e4f2874c39d4b9abd17b4e23013a44ad" translate="yes" xml:space="preserve">
          <source>The permissible values for &lt;var&gt;feature&lt;/var&gt; are listed in the sub-section on &lt;a href=&quot;#aarch64_002dfeature_002dmodifiers&quot;&gt;&lt;samp&gt;-march&lt;/samp&gt; and &lt;samp&gt;-mcpu&lt;/samp&gt; Feature Modifiers&lt;/a&gt;. Where conflicting feature modifiers are specified, the right-most feature is used.</source>
          <target state="translated">Допустимые значения для &lt;var&gt;feature&lt;/var&gt; перечислены в подразделе на&lt;a href=&quot;#aarch64_002dfeature_002dmodifiers&quot;&gt;&lt;samp&gt;-марш&lt;/samp&gt; и &lt;samp&gt;-mcpu&lt;/samp&gt;Модификаторы функций&lt;/a&gt; . Если указаны конфликтующие модификаторы функций, используется самая правая функция.</target>
        </trans-unit>
        <trans-unit id="c7e86233015dde5cd1c78847180c34b2f1e2bf2b" translate="yes" xml:space="preserve">
          <source>The places that are searched for an included &amp;lsquo;</source>
          <target state="translated">Места, которые ищут включенные '</target>
        </trans-unit>
        <trans-unit id="dd8b187fae5590414120f103d445af72242d5c3b" translate="yes" xml:space="preserve">
          <source>The position in the bit-field is the position, counting in bits, of the bit closest to the beginning of the structure.</source>
          <target state="translated">Позиция в битовом поле-это позиция,считающаяся в битах,ближайшая к началу структуры.</target>
        </trans-unit>
        <trans-unit id="c4b546e403df1ecde52f18e1df9da4aeb8d7bc41" translate="yes" xml:space="preserve">
          <source>The possible values of &lt;var&gt;visibility_type&lt;/var&gt; correspond to the visibility settings in the ELF gABI.</source>
          <target state="translated">Возможные значения &lt;var&gt;visibility_type&lt;/var&gt; соответствуют настройкам видимости в ELF gABI.</target>
        </trans-unit>
        <trans-unit id="f6264d8e91343ef3a61a9b344f8646bf4aba8cc7" translate="yes" xml:space="preserve">
          <source>The practice of reading from a different union member than the one most recently written to (called &amp;ldquo;type-punning&amp;rdquo;) is common. Even with</source>
          <target state="translated">Распространена практика чтения из другого члена профсоюза, чем тот, которому в последний раз писали (так называемая &amp;laquo;каламбур&amp;raquo;). Даже с</target>
        </trans-unit>
        <trans-unit id="3fcfc9f88180eb2f1134228de5ee485783fb7bf2" translate="yes" xml:space="preserve">
          <source>The pragmas defined by the AArch64 target correspond to the AArch64 target function attributes. They can be specified as below:</source>
          <target state="translated">Прагмы,определенные целью AArch64,соответствуют атрибутам целевой функции AArch64.Их можно указать ниже:</target>
        </trans-unit>
        <trans-unit id="645dbf1ac450b591d9e4ddc2872516c2fa74709d" translate="yes" xml:space="preserve">
          <source>The pragmas defined by the S/390 target correspond to the S/390 target function attributes and some the additional options:</source>
          <target state="translated">Прагмы,определенные целью S/390,соответствуют атрибутам целевой функции S/390 и некоторым дополнительным опциям:</target>
        </trans-unit>
        <trans-unit id="2c0f7aae6dce4abe2e06c56745ef40bd52aa8844" translate="yes" xml:space="preserve">
          <source>The precise convention for returning structures in memory depends on the target configuration macros.</source>
          <target state="translated">Точное соглашение для возврата структур в памяти зависит от макросов целевой конфигурации.</target>
        </trans-unit>
        <trans-unit id="91248f1a5a5155ccc98999905b33b441a4c0b382" translate="yes" xml:space="preserve">
          <source>The precompiled header file must be produced for the same language as the current compilation. You cannot use a C precompiled header for a C++ compilation.</source>
          <target state="translated">Прекомпилированный заголовочный файл должен быть создан на том же языке,что и текущая компиляция.Вы не можете использовать прекомпилированный заголовок C для C++компиляции.</target>
        </trans-unit>
        <trans-unit id="a7364d3dac14debc46aa1590555ff15d8a2c5504" translate="yes" xml:space="preserve">
          <source>The precompiled header file must have been produced by the same compiler binary as the current compilation is using.</source>
          <target state="translated">Прекомпилированный заголовочный файл должен быть создан тем же бинарным компилятором,что и при текущей компиляции.</target>
        </trans-unit>
        <trans-unit id="fa601548ca48cf3a1634bdb3b2571be6608e559a" translate="yes" xml:space="preserve">
          <source>The preferred mechanism to declare variable-length types like &lt;code&gt;struct line&lt;/code&gt; above is the ISO C99 &lt;em&gt;flexible array member&lt;/em&gt;, with slightly different syntax and semantics:</source>
          <target state="translated">Предпочтительным механизмом для объявления типов переменной длины, таких как &lt;code&gt;struct line&lt;/code&gt; выше, является &lt;em&gt;гибкий член массива&lt;/em&gt; ISO C99 с немного другим синтаксисом и семантикой:</target>
        </trans-unit>
        <trans-unit id="781223d90b25e173d9a1c191f04f39b92b12674b" translate="yes" xml:space="preserve">
          <source>The preprocessor constants &lt;code&gt;__v850&lt;/code&gt; and &lt;code&gt;__v851__&lt;/code&gt; are always defined, regardless of which processor variant is the target.</source>
          <target state="translated">Константы препроцессора &lt;code&gt;__v850&lt;/code&gt; и &lt;code&gt;__v851__&lt;/code&gt; всегда определены, независимо от того, какой вариант процессора является целевым.</target>
        </trans-unit>
        <trans-unit id="516a25c40cc84aaf870728160964e02be2e34941" translate="yes" xml:space="preserve">
          <source>The preprocessor macro &lt;code&gt;__nios2_arch__&lt;/code&gt; is available to programs, with value 1 or 2, indicating the targeted ISA level.</source>
          <target state="translated">Макрос препроцессора &lt;code&gt;__nios2_arch__&lt;/code&gt; доступен программам со значением 1 или 2, указывающим целевой уровень ISA.</target>
        </trans-unit>
        <trans-unit id="e7e3cb02afe1efb7ea595142066c8a4b5aee7508" translate="yes" xml:space="preserve">
          <source>The preprocessor macros &lt;code&gt;__GNUC_GNU_INLINE__&lt;/code&gt; and &lt;code&gt;__GNUC_STDC_INLINE__&lt;/code&gt; may be used to check which semantics are in effect for &lt;code&gt;inline&lt;/code&gt; functions. See &lt;a href=&quot;http://gcc.gnu.org/onlinedocs/cpp/Common-Predefined-Macros.html#Common-Predefined-Macros&quot;&gt;Common Predefined Macros&lt;/a&gt; in The C Preprocessor.</source>
          <target state="translated">&lt;code&gt;__GNUC_GNU_INLINE__&lt;/code&gt; препроцессора __GNUC_GNU_INLINE__ и &lt;code&gt;__GNUC_STDC_INLINE__&lt;/code&gt; могут использоваться для проверки того, какая семантика действует для &lt;code&gt;inline&lt;/code&gt; функций. См. &lt;a href=&quot;http://gcc.gnu.org/onlinedocs/cpp/Common-Predefined-Macros.html#Common-Predefined-Macros&quot;&gt;Общие предопределенные макросы&lt;/a&gt; в Препроцессоре C.</target>
        </trans-unit>
        <trans-unit id="0134a051339bcf92f32e609bcd02925b15816b59" translate="yes" xml:space="preserve">
          <source>The preprocessor macros &lt;code&gt;__GNUC_GNU_INLINE__&lt;/code&gt; and &lt;code&gt;__GNUC_STDC_INLINE__&lt;/code&gt; may be used to check which semantics are in effect for &lt;code&gt;inline&lt;/code&gt; functions. See &lt;a href=&quot;https://gcc.gnu.org/onlinedocs/cpp/Common-Predefined-Macros.html#Common-Predefined-Macros&quot;&gt;Common Predefined Macros&lt;/a&gt; in The C Preprocessor.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e144b8574fca5ee84d650870787998db8cc0a6cc" translate="yes" xml:space="preserve">
          <source>The preprocessor symbols &lt;code&gt;__SEG_FS&lt;/code&gt; and &lt;code&gt;__SEG_GS&lt;/code&gt; are defined when these address spaces are supported.</source>
          <target state="translated">Символы препроцессора &lt;code&gt;__SEG_FS&lt;/code&gt; и &lt;code&gt;__SEG_GS&lt;/code&gt; определены, когда эти адресные пространства поддерживаются.</target>
        </trans-unit>
        <trans-unit id="59cc56242765d93d1139cc69346a113ae66f0437" translate="yes" xml:space="preserve">
          <source>The preprocessor treatment of escaped newlines is more relaxed than that specified by the C90 standard, which requires the newline to immediately follow a backslash. GCC&amp;rsquo;s implementation allows whitespace in the form of spaces, horizontal and vertical tabs, and form feeds between the backslash and the subsequent newline. The preprocessor issues a warning, but treats it as a valid escaped newline and combines the two lines to form a single logical line. This works within comments and tokens, as well as between tokens. Comments are &lt;em&gt;not&lt;/em&gt; treated as whitespace for the purposes of this relaxation, since they have not yet been replaced with spaces.</source>
          <target state="translated">Обработка препроцессором экранированных символов новой строки более мягкая, чем указанная в стандарте C90, который требует, чтобы новая строка сразу следовала за обратной косой чертой. Реализация GCC позволяет использовать пробелы в виде пробелов, горизонтальных и вертикальных табуляций, а также каналы формы между обратной косой чертой и следующей за ней новой строкой. Препроцессор выдает предупреждение, но рассматривает его как действительный экранированный символ новой строки и объединяет две строки в одну логическую строку. Это работает в комментариях и токенах, а также между токенами. Комментарии &lt;em&gt;не&lt;/em&gt; рассматриваются как пробелы для целей этого ослабления, поскольку они еще не заменены пробелами.</target>
        </trans-unit>
        <trans-unit id="a2282938cc4db5b60fc722ea3f4e0b1558cfa2dc" translate="yes" xml:space="preserve">
          <source>The program counter (PC) is 2 bytes wide. This is the case for devices with up to 128 KiB of program memory.</source>
          <target state="translated">Счетчик программ (ПК)имеет ширину 2 байта.Это относится к устройствам с объемом программной памяти до 128 КБ.</target>
        </trans-unit>
        <trans-unit id="bdec771ba3fce1f14ccbe2f783eeba3b5eb697cc" translate="yes" xml:space="preserve">
          <source>The programs that fix the header files do not understand this special way of using symbolic links; therefore, the directory of fixed header files is good only for the machine model used to build it.</source>
          <target state="translated">Программы,которые исправляют заголовочные файлы,не понимают этот особый способ использования символических ссылок,поэтому каталог фиксированных заголовочных файлов хорош только для модели машины,используемой для его сборки.</target>
        </trans-unit>
        <trans-unit id="09f7403716543aa22328bdac3e1ded4dc52aedb3" translate="yes" xml:space="preserve">
          <source>The qualifier &lt;code&gt;dynamic&lt;/code&gt; means that the function manipulates the stack dynamically: in addition to the static allocation described above, stack adjustments are made in the body of the function, for example to push/pop arguments around function calls. If the qualifier &lt;code&gt;bounded&lt;/code&gt; is also present, the amount of these adjustments is bounded at compile time and the second field is an upper bound of the total amount of stack used by the function. If it is not present, the amount of these adjustments is not bounded at compile time and the second field only represents the bounded part.</source>
          <target state="translated">Квалификатор &lt;code&gt;dynamic&lt;/code&gt; означает, что функция динамически манипулирует стеком: в дополнение к статическому распределению, описанному выше, в теле функции производятся корректировки стека, например, для добавления / извлечения аргументов вокруг вызовов функций. Если также присутствует квалификатор &lt;code&gt;bounded&lt;/code&gt; , количество этих корректировок ограничено во время компиляции, а второе поле является верхней границей общего количества стека, используемого функцией. Если его нет, количество этих корректировок не ограничено во время компиляции, а второе поле представляет только ограниченную часть.</target>
        </trans-unit>
        <trans-unit id="16b6ee8f6057a92bf82347dbc31b9360f115d43a" translate="yes" xml:space="preserve">
          <source>The qualifier &lt;code&gt;static&lt;/code&gt; means that the function manipulates the stack statically: a fixed number of bytes are allocated for the frame on function entry and released on function exit; no stack adjustments are otherwise made in the function. The second field is this fixed number of bytes.</source>
          <target state="translated">Квалификатор &lt;code&gt;static&lt;/code&gt; означает, что функция управляет стеком статически: фиксированное количество байтов выделяется для кадра при входе в функцию и освобождается при выходе из функции; никакие другие настройки стека в функции не выполняются. Второе поле - это фиксированное количество байтов.</target>
        </trans-unit>
        <trans-unit id="d99c785e19e25b0fcfa2c0d8dc79cf7ec34db9e9" translate="yes" xml:space="preserve">
          <source>The rank of any extended integer type relative to another extended integer type with the same precision (C99 and C11 6.3.1.1).</source>
          <target state="translated">Ранг любого расширенного целочисленного типа относительно другого расширенного целочисленного типа с той же точностью (C99 и C11 6.3.1.1).</target>
        </trans-unit>
        <trans-unit id="cf6573d176933b5e09eb83df2d5615b45a3bb76e" translate="yes" xml:space="preserve">
          <source>The reason for using names that start with underscores for the local variables is to avoid conflicts with variable names that occur within the expressions that are substituted for &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt;. Eventually we hope to design a new form of declaration syntax that allows you to declare variables whose scopes start only after their initializers; this will be a more reliable way to prevent such conflicts.</source>
          <target state="translated">Причина использования имен, начинающихся с подчеркивания для локальных переменных, состоит в том, чтобы избежать конфликтов с именами переменных, которые встречаются в выражениях, которые заменяются на &lt;code&gt;a&lt;/code&gt; и &lt;code&gt;b&lt;/code&gt; . В конце концов мы надеемся разработать новую форму синтаксиса объявления, которая позволит вам объявлять переменные, область действия которых начинается только после их инициализаторов; это будет более надежный способ предотвратить такие конфликты.</target>
        </trans-unit>
        <trans-unit id="17b5e6eec29945ad1cdc98a53fb0e13f400b8a4b" translate="yes" xml:space="preserve">
          <source>The register assignments for arguments and return values remain the same, but each scalar value is passed in a single 64-bit register rather than a pair of 32-bit registers. For example, scalar floating-point values are returned in &amp;lsquo;</source>
          <target state="translated">Назначения регистров для аргументов и возвращаемых значений остаются прежними, но каждое скалярное значение передается в одном 64-битном регистре, а не в паре 32-битных регистров. Например, скалярные значения с плавающей запятой возвращаются в '</target>
        </trans-unit>
        <trans-unit id="df089519561a6aaf6b0d5462a2d12a16f51ac16a" translate="yes" xml:space="preserve">
          <source>The register class usable in short insns. This is a register class constraint, and can thus drive register allocation. This constraint won&amp;rsquo;t match unless</source>
          <target state="translated">Класс регистров, используемый в коротких insns. Это ограничение класса регистров и, таким образом, может управлять распределением регистров. Это ограничение не будет соответствовать, если</target>
        </trans-unit>
        <trans-unit id="ce5827517313f66ee35c67440ea785808e96b2d8" translate="yes" xml:space="preserve">
          <source>The register group usable in short insns. This constraint does not use a register class, so that it only passively matches suitable registers, and doesn&amp;rsquo;t drive register allocation.</source>
          <target state="translated">Группа регистров, которую можно использовать в коротких инсн. Это ограничение не использует класс регистров, поэтому оно только пассивно сопоставляет подходящие регистры и не управляет распределением регистров.</target>
        </trans-unit>
        <trans-unit id="72d3acac63bf69f2e9cbe4802b6dfb23c1a3dc0a" translate="yes" xml:space="preserve">
          <source>The register indicated by Rx (not implemented yet).</source>
          <target state="translated">Реестр,указанный Rx (еще не реализован).</target>
        </trans-unit>
        <trans-unit id="b14ae46b310b2d10e38a2d9126edc47d0a1b7438" translate="yes" xml:space="preserve">
          <source>The registers reserved for interrupts (&lt;code&gt;R24&lt;/code&gt; to &lt;code&gt;R31&lt;/code&gt;).</source>
          <target state="translated">Регистры зарезервированы для прерываний (с &lt;code&gt;R24&lt;/code&gt; по &lt;code&gt;R31&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="5b9c9dc3621d339e8f64077eedb5da8839ab6a60" translate="yes" xml:space="preserve">
          <source>The relevant bytes of the representation of the object are treated as an object of the type used for the access. See &lt;a href=&quot;optimize-options#Type_002dpunning&quot;&gt;Type-punning&lt;/a&gt;. This may be a trap representation.</source>
          <target state="translated">Соответствующие байты представления объекта рассматриваются как объект того типа, который используется для доступа. См. &lt;a href=&quot;optimize-options#Type_002dpunning&quot;&gt;Тип каламбура&lt;/a&gt; . Это может быть ловушка.</target>
        </trans-unit>
        <trans-unit id="f41e3aebc6e71662ecec887032e93bdb3882f388" translate="yes" xml:space="preserve">
          <source>The remainder of this section is specific to GNU C90 inlining.</source>
          <target state="translated">Остальная часть этого раздела относится к GNU C90 inlining.</target>
        </trans-unit>
        <trans-unit id="558c61b7cf4311ca70d848b51262ab1898c102b3" translate="yes" xml:space="preserve">
          <source>The remaining environment variables apply only when preprocessing the particular language indicated. Each specifies a list of directories to be searched as if specified with</source>
          <target state="translated">Остальные переменные окружения применяются только при препроцессировании указанного языка.Каждая из них задает список каталогов для поиска,как если бы он был задан с помощью параметра</target>
        </trans-unit>
        <trans-unit id="c96b85add00a5f322d58fcbd72ee7befb1dea21f" translate="yes" xml:space="preserve">
          <source>The remaining functions are provided for optimization purposes.</source>
          <target state="translated">Остальные функции предоставляются в целях оптимизации.</target>
        </trans-unit>
        <trans-unit id="1f81fad037120bbd5cb1f32f0f1474309573caa7" translate="yes" xml:space="preserve">
          <source>The required &lt;var&gt;ref-index&lt;/var&gt; positional argument denotes a function argument of pointer (or in C++, reference) type that is subject to the access. The same pointer argument can be referenced by at most one distinct &lt;code&gt;access&lt;/code&gt; attribute.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4420491dd7bf1c05e945f7d72f0a1731089f6301" translate="yes" xml:space="preserve">
          <source>The respective segment base must be set via some method specific to the operating system. Rather than require an expensive system call to retrieve the segment base, these address spaces are not considered to be subspaces of the generic (flat) address space. This means that explicit casts are required to convert pointers between these address spaces and the generic address space. In practice the application should cast to &lt;code&gt;uintptr_t&lt;/code&gt; and apply the segment base offset that it installed previously.</source>
          <target state="translated">Соответствующая база сегмента должна быть установлена ​​каким-либо методом, специфичным для операционной системы. Вместо того, чтобы требовать дорогостоящего системного вызова для извлечения базы сегмента, эти адресные пространства не считаются подпространствами общего (плоского) адресного пространства. Это означает, что для преобразования указателей между этими адресными пространствами и общим адресным пространством требуется явное приведение типов. На практике приложение должно привести к &lt;code&gt;uintptr_t&lt;/code&gt; и применить базовое смещение сегмента, которое оно установило ранее.</target>
        </trans-unit>
        <trans-unit id="9b4574d542eb42ca2e1f7130ac8122d2979c3b76" translate="yes" xml:space="preserve">
          <source>The rest of this discussion uses the following code for illustrative purposes.</source>
          <target state="translated">В остальной части дискуссии для иллюстрации используется следующий код.</target>
        </trans-unit>
        <trans-unit id="6771696cde55a31392f32b7d1552e2429667db0a" translate="yes" xml:space="preserve">
          <source>The restrictions on &lt;code&gt;offsetof&lt;/code&gt; may be relaxed in a future version of the C++ standard.</source>
          <target state="translated">Ограничения на &lt;code&gt;offsetof&lt;/code&gt; могут быть ослаблены в будущей версии стандарта C ++.</target>
        </trans-unit>
        <trans-unit id="dd1a1a42d6420a3422e966b9e8baa0847229727c" translate="yes" xml:space="preserve">
          <source>The result of &lt;code&gt;vec_rlmi&lt;/code&gt; is obtained by rotating each element of the first argument vector left and inserting it under mask into the second argument vector. The third argument vector contains the mask beginning in bits 11:15, the mask end in bits 19:23, and the shift count in bits 27:31, of each element.</source>
          <target state="translated">Результат &lt;code&gt;vec_rlmi&lt;/code&gt; получается путем поворота каждого элемента первого вектора аргумента влево и вставки его под маской во второй вектор аргумента. Третий вектор аргументов содержит маску, начинающуюся в битах 11:15, конец маски в битах 19:23 и счетчик сдвигов в битах 27:31 каждого элемента.</target>
        </trans-unit>
        <trans-unit id="b9a3f0d57a834ed4eba9054b925159bf84ea4a8e" translate="yes" xml:space="preserve">
          <source>The result of &lt;code&gt;vec_rlnm&lt;/code&gt; is obtained by rotating each element of the first argument vector left and ANDing it with a mask specified by the second and third argument vectors. The second argument vector contains the shift count for each element in the low-order byte. The third argument vector contains the mask end for each element in the low-order byte, with the mask begin in the next higher byte.</source>
          <target state="translated">Результат &lt;code&gt;vec_rlnm&lt;/code&gt; получается вращением каждого элемента первого вектора аргумента влево и операцией AND с маской, заданной вторым и третьим векторами аргументов. Второй вектор аргумента содержит счетчик сдвигов для каждого элемента младшего байта. Третий вектор аргумента содержит конец маски для каждого элемента младшего байта, а начало маски - в следующем старшем байте.</target>
        </trans-unit>
        <trans-unit id="8ac79b53c282a3e1bdc553acd00140fe5cdb87cf" translate="yes" xml:space="preserve">
          <source>The result of &lt;code&gt;vec_vrlnm&lt;/code&gt; is obtained by rotating each element of the first argument vector left and ANDing it with a mask. The second argument vector contains the mask beginning in bits 11:15, the mask end in bits 19:23, and the shift count in bits 27:31, of each element.</source>
          <target state="translated">Результат &lt;code&gt;vec_vrlnm&lt;/code&gt; получается вращением каждого элемента вектора первого аргумента влево и операцией AND с маской. Второй вектор аргументов содержит маску, начинающуюся в битах 11:15, конец маски в битах 19:23 и счетчик сдвигов в битах 27:31 каждого элемента.</target>
        </trans-unit>
        <trans-unit id="9316b131e727e77ff29281dc2e9a7402d2bc6522" translate="yes" xml:space="preserve">
          <source>The result of attempting to indirectly access an object with automatic or thread storage duration from a thread other than the one with which it is associated (C11 6.2.4).</source>
          <target state="translated">Результат попытки косвенного доступа к объекту с автоматическим или потоковым хранением длительности из потока,отличного от того,с которым он связан (C11 6.2.4).</target>
        </trans-unit>
        <trans-unit id="293312cb8a66343c5e00cc15dc2d11a748b78cdb" translate="yes" xml:space="preserve">
          <source>The result of converting a pointer to an integer or vice versa (C90 6.3.4, C99 and C11 6.3.2.3).</source>
          <target state="translated">Результат преобразования указателя в целое или наоборот (С90 6.3.4,С99 и С11 6.3.2.3).</target>
        </trans-unit>
        <trans-unit id="d8adce6949d651dd3877dd8fc89775a368e6c5a5" translate="yes" xml:space="preserve">
          <source>The result of, or the signal raised by, converting an integer to a signed integer type when the value cannot be represented in an object of that type (C90 6.2.1.2, C99 and C11 6.3.1.3).</source>
          <target state="translated">Результат или сигнал,вызванный преобразованием целого числа в знаковый целочисленный тип,когда значение не может быть представлено в объекте этого типа (С90 6.2.1.2,С99 и С11 6.3.1.3).</target>
        </trans-unit>
        <trans-unit id="6372dea778f1e54932d501af42dec0c2c6cb7a32" translate="yes" xml:space="preserve">
          <source>The resulting code should be considerably faster in the majority of cases and avoid the numerical instability problems of 387 code, but may break some existing code that expects temporaries to be 80 bits.</source>
          <target state="translated">Полученный код в большинстве случаев должен быть значительно быстрее и избегать проблем с числовой нестабильностью в коде 387,но может нарушить некоторый существующий код,который ожидает,что временные значения будут 80 бит.</target>
        </trans-unit>
        <trans-unit id="602584d89b66e12499de96c6abd45f1820a6ab70" translate="yes" xml:space="preserve">
          <source>The results of some bitwise operations on signed integers (C90 6.3, C99 and C11 6.5).</source>
          <target state="translated">Результаты некоторых битовых операций над подписанными целыми числами (C90 6.3,C99 и C11 6.5).</target>
        </trans-unit>
        <trans-unit id="08e0446d619f737b8b3d1bfcead4987221134fe0" translate="yes" xml:space="preserve">
          <source>The return type, including type qualifiers. For example, a method returning &lt;code&gt;int&lt;/code&gt; would have &lt;code&gt;i&lt;/code&gt; here.</source>
          <target state="translated">Тип возвращаемого значения, включая квалификаторы типа. Например, метод, возвращающий &lt;code&gt;int&lt;/code&gt; , будет иметь здесь &lt;code&gt;i&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d722a3f7a5a03ca6f3a20b50840f8dad2ad4a0a2" translate="yes" xml:space="preserve">
          <source>The return value is the value of &lt;var&gt;exp&lt;/var&gt;, which should be an integral expression. The semantics of the built-in are that it is expected that &lt;var&gt;exp&lt;/var&gt; == &lt;var&gt;c&lt;/var&gt;. For example:</source>
          <target state="translated">Возвращаемое значение - это значение &lt;var&gt;exp&lt;/var&gt; , которое должно быть интегральным выражением. Семантика встроенного в том, что ожидается, что &lt;var&gt;exp&lt;/var&gt; == &lt;var&gt;c&lt;/var&gt; . Например:</target>
        </trans-unit>
        <trans-unit id="66b2899a0dec22c6c49cc318d7875f38a40fbcdb" translate="yes" xml:space="preserve">
          <source>The return value of the method is the number of objects in the current batch; this should not exceed &lt;code&gt;len&lt;/code&gt;, which is the maximum size of a batch as requested by the caller. The batch itself is returned in the &lt;code&gt;itemsPtr&lt;/code&gt; field of the &lt;code&gt;NSFastEnumerationState&lt;/code&gt; struct.</source>
          <target state="translated">Возвращаемое значение метода - количество объектов в текущем пакете; это не должно превышать &lt;code&gt;len&lt;/code&gt; , что является максимальным размером пакета по запросу вызывающей стороны. Сама партия возвращается в &lt;code&gt;itemsPtr&lt;/code&gt; поле &lt;code&gt;NSFastEnumerationState&lt;/code&gt; структуры.</target>
        </trans-unit>
        <trans-unit id="bd39f3563e6cdbea884ac0f3b2596eb7ac3835c0" translate="yes" xml:space="preserve">
          <source>The rounding behaviors characterized by non-standard values of &lt;code&gt;FLT_ROUNDS&lt;/code&gt; (C90, C99 and C11 5.2.4.2.2).</source>
          <target state="translated">Поведение округления, характеризующееся нестандартными значениями &lt;code&gt;FLT_ROUNDS&lt;/code&gt; (C90, C99 и C11 5.2.4.2.2).</target>
        </trans-unit>
        <trans-unit id="ca0bfeda9cecd5551824a4a4e37d54810853db32" translate="yes" xml:space="preserve">
          <source>The runtime support file</source>
          <target state="translated">Файл поддержки выполнения</target>
        </trans-unit>
        <trans-unit id="b4c4c0226af27718cbd914b43f7be4de41a152cd" translate="yes" xml:space="preserve">
          <source>The safe way to write such code is to give the temporary a name, which forces it to remain until the end of the scope of the name. For example:</source>
          <target state="translated">Безопасный способ написания такого кода-дать временное название,которое заставляет его оставаться до конца области действия названия.Например:</target>
        </trans-unit>
        <trans-unit id="ba4b69f3a9e8d7ca80206177b8876cf920e6f11b" translate="yes" xml:space="preserve">
          <source>The same</source>
          <target state="translated">Аналогичный</target>
        </trans-unit>
        <trans-unit id="e53e3a35319895514d679977563fa8e554b518de" translate="yes" xml:space="preserve">
          <source>The same constraints on arguments apply as for the corresponding &lt;code&gt;__atomic_op_fetch&lt;/code&gt; built-in functions. All memory orders are valid.</source>
          <target state="translated">Применяются те же ограничения на аргументы, что и для соответствующих встроенных функций &lt;code&gt;__atomic_op_fetch&lt;/code&gt; . Все заказы на память действительны.</target>
        </trans-unit>
        <trans-unit id="1d3bb42125b4caec8cf7a192592fcd99a8477b57" translate="yes" xml:space="preserve">
          <source>The same constraints on arguments apply as for the corresponding &lt;code&gt;__sync_op_and_fetch&lt;/code&gt; built-in functions.</source>
          <target state="translated">Применяются те же ограничения на аргументы, что и для соответствующих встроенных функций &lt;code&gt;__sync_op_and_fetch&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e9ffb18b7d09b9daf66ff3c77ffe4ceee695ef40" translate="yes" xml:space="preserve">
          <source>The same problem can occur if one output parameter (&lt;var&gt;a&lt;/var&gt;) allows a register constraint and another output parameter (&lt;var&gt;b&lt;/var&gt;) allows a memory constraint. The code generated by GCC to access the memory address in &lt;var&gt;b&lt;/var&gt; can contain registers which &lt;em&gt;might&lt;/em&gt; be shared by &lt;var&gt;a&lt;/var&gt;, and GCC considers those registers to be inputs to the asm. As above, GCC assumes that such input registers are consumed before any outputs are written. This assumption may result in incorrect behavior if the &lt;code&gt;asm&lt;/code&gt; statement writes to &lt;var&gt;a&lt;/var&gt; before using &lt;var&gt;b&lt;/var&gt;. Combining the &amp;lsquo;</source>
          <target state="translated">Та же проблема может возникнуть, если один выходной параметр ( &lt;var&gt;a&lt;/var&gt; ) допускает ограничение регистра, а другой выходной параметр ( &lt;var&gt;b&lt;/var&gt; ) допускает ограничение памяти. Код, сгенерированный GCC для доступа к адресу памяти в &lt;var&gt;b&lt;/var&gt; , может содержать регистры, которые &lt;em&gt;могут&lt;/em&gt; совместно использоваться &lt;var&gt;a&lt;/var&gt; , и GCC считает эти регистры входными данными для asm. Как и выше, GCC предполагает, что такие входные регистры потребляются до записи каких-либо выходных данных. Это предположение может привести к неправильному поведению, если оператор &lt;code&gt;asm&lt;/code&gt; записывает в &lt;var&gt;a&lt;/var&gt; перед использованием &lt;var&gt;b&lt;/var&gt; . Объединяя '</target>
        </trans-unit>
        <trans-unit id="84eb297a7c7adafda6643fbbc1a64827529d36ab" translate="yes" xml:space="preserve">
          <source>The same values for</source>
          <target state="translated">Одинаковые значения для</target>
        </trans-unit>
        <trans-unit id="10b4b93db032b4ab2baad7ea49ce309b241f5e8b" translate="yes" xml:space="preserve">
          <source>The scale (in percents) applied to</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ee0deba9d1e7e31914904f7de96ff06cf02541a" translate="yes" xml:space="preserve">
          <source>The second and third &lt;code&gt;FOO&lt;/code&gt; should be in comments. This warning is on by default.</source>
          <target state="translated">Второй и третий &lt;code&gt;FOO&lt;/code&gt; должны быть в комментариях. Это предупреждение включено по умолчанию.</target>
        </trans-unit>
        <trans-unit id="498b43ab0ba23ca5cccab7efec7dc706e6795ec7" translate="yes" xml:space="preserve">
          <source>The second argument to &lt;var&gt;__builtin_crypto_vshasigmad&lt;/var&gt; and &lt;var&gt;__builtin_crypto_vshasigmaw&lt;/var&gt; must be a constant integer that is 0 or 1. The third argument to these built-in functions must be a constant integer in the range of 0 to 15.</source>
          <target state="translated">Второй аргумент для &lt;var&gt;__builtin_crypto_vshasigmad&lt;/var&gt; и &lt;var&gt;__builtin_crypto_vshasigmaw&lt;/var&gt; должен быть постоянным целым числом, равным 0 или 1. Третий аргумент этих встроенных функций должен быть постоянным целым числом в диапазоне от 0 до 15.</target>
        </trans-unit>
        <trans-unit id="a7455b53d8f1101ab3b5613a9bfe23cea1588051" translate="yes" xml:space="preserve">
          <source>The second argument, &lt;var&gt;failval&lt;/var&gt;, is optional and defaults to zero if omitted.</source>
          <target state="translated">Второй аргумент, &lt;var&gt;failval&lt;/var&gt; , является необязательным и по умолчанию равен нулю, если он опущен.</target>
        </trans-unit>
        <trans-unit id="e5696540b2cb16b0a24c5184cde684653dcb48a5" translate="yes" xml:space="preserve">
          <source>The second form of this directive is useful for the case where you have multiple headers with the same name in different directories. If you use this form, you must specify the same string to &amp;lsquo;</source>
          <target state="translated">Вторая форма этой директивы полезна в случае, когда у вас есть несколько заголовков с одинаковым именем в разных каталогах. Если вы используете эту форму, вы должны указать ту же строку для '</target>
        </trans-unit>
        <trans-unit id="f7af4ae65c75a113a136191463890951e0da2e45" translate="yes" xml:space="preserve">
          <source>The second pair of &lt;var&gt;n2&lt;/var&gt;:&lt;var&gt;m2&lt;/var&gt; values allows you to specify a secondary alignment:</source>
          <target state="translated">Вторая пара значений &lt;var&gt;n2&lt;/var&gt; : &lt;var&gt;m2&lt;/var&gt; позволяет указать вторичное выравнивание:</target>
        </trans-unit>
        <trans-unit id="3ab6989d4c1c4f47e25307deb785d43e56803a5f" translate="yes" xml:space="preserve">
          <source>The security extension.</source>
          <target state="translated">Расширение системы безопасности.</target>
        </trans-unit>
        <trans-unit id="227e1ad96cf49ba3c90eaa74176faf5e4ae6abc9" translate="yes" xml:space="preserve">
          <source>The sense of a qualifier can be inverted by prefixing it with the &amp;lsquo;</source>
          <target state="translated">Смысл квалификатора можно инвертировать, поставив перед ним префикс '</target>
        </trans-unit>
        <trans-unit id="555ceee2bb9cf5f8f3e29c4052854238c7fb191f" translate="yes" xml:space="preserve">
          <source>The set of runtime conventions followed by all of the tools that deal with binary representations of a program, including compilers, assemblers, linkers, and language runtime support. Some ABIs are formal with a written specification, possibly designed by multiple interested parties. Others are simply the way things are actually done by a particular set of tools.</source>
          <target state="translated">Набор исполнительных соглашений,за которыми следуют все инструменты,работающие с бинарными представлениями программы,включая компиляторы,ассемблеры,компоновщики и поддержку языка исполнения.Некоторые ABI формальны с письменной спецификацией,возможно,разработанной несколькими заинтересованными сторонами.Другие-это просто то,как все на самом деле делается конкретным набором инструментов.</target>
        </trans-unit>
        <trans-unit id="3a0b9082dbf784ec48751abb46feb9a84f16889b" translate="yes" xml:space="preserve">
          <source>The setting &amp;lsquo;</source>
          <target state="translated">Настройки '</target>
        </trans-unit>
        <trans-unit id="be945ed951ef5a61f5eae361b911de27ce4736fe" translate="yes" xml:space="preserve">
          <source>The shadow stack unwind code looks like:</source>
          <target state="translated">Похоже на код размотки теневого стека:</target>
        </trans-unit>
        <trans-unit id="5e51279e9e910972feb51c0c337d5562d0a6bae6" translate="yes" xml:space="preserve">
          <source>The sign of the remainder on integer division (C90 6.3.5).</source>
          <target state="translated">Знак остатка при целочисленном делении (C90 6.3.5).</target>
        </trans-unit>
        <trans-unit id="3873ede6c61e304d381b113f1c8a01eb501fad5a" translate="yes" xml:space="preserve">
          <source>The simplest kind of constraint is a string full of letters, each of which describes one kind of operand that is permitted. Here are the letters that are allowed:</source>
          <target state="translated">Самым простым видом ограничения является строка,полная букв,каждая из которых описывает один тип разрешенного операнда.Вот разрешенные буквы:</target>
        </trans-unit>
        <trans-unit id="f57db1d7a87e06c8af2c5a7b6a9b449af372d773" translate="yes" xml:space="preserve">
          <source>The single- and double-precision FPv5 floating-point instructions.</source>
          <target state="translated">Инструкции с плавающей запятой FPv5 одинарной и двойной точности.</target>
        </trans-unit>
        <trans-unit id="8bf5f529e48bebb5ac22844826b001e3be0c3afe" translate="yes" xml:space="preserve">
          <source>The single- and double-precision floating-point instructions.</source>
          <target state="translated">Инструкции с плавающей запятой одинарной и двойной точности.</target>
        </trans-unit>
        <trans-unit id="8ac5488ac14854117c1393d98f83c5a93f21526b" translate="yes" xml:space="preserve">
          <source>The single-precision FPv5 floating-point instructions.</source>
          <target state="translated">Одноточная инструкция FPv5 с плавающей запятой.</target>
        </trans-unit>
        <trans-unit id="1ebaf382d5bdec22e2b7379aab4b7c48ea9e912b" translate="yes" xml:space="preserve">
          <source>The single-precision VFPv3 floating-point instructions with 16 double-precision registers and the half-precision floating-point conversion operations.</source>
          <target state="translated">Инструкции VFPv3 с плавающей запятой с одинарной точностью,содержащие 16 регистров двойной точности и операции преобразования с плавающей запятой с половинной точностью.</target>
        </trans-unit>
        <trans-unit id="e7ad435877ea887d34b1b37f15d7368e56cc4675" translate="yes" xml:space="preserve">
          <source>The single-precision VFPv3 floating-point instructions. The extension &amp;lsquo;</source>
          <target state="translated">Инструкции с плавающей запятой одинарной точности VFPv3. Расширение '</target>
        </trans-unit>
        <trans-unit id="3e79bc7e04e01647f6facb0d53f8d2ca1a7bc417" translate="yes" xml:space="preserve">
          <source>The single-precision VFPv4 floating-point instructions.</source>
          <target state="translated">Одноточная инструкция VFPv4 с плавающей запятой.</target>
        </trans-unit>
        <trans-unit id="d793936d7de82c8ba0aab481f238e4822e465c4a" translate="yes" xml:space="preserve">
          <source>The single-precision floating-point instructions.</source>
          <target state="translated">Инструкции с плавающей запятой с одной точностью.</target>
        </trans-unit>
        <trans-unit id="2d2a7508c4cb1900d0918961e8e0427152b72902" translate="yes" xml:space="preserve">
          <source>The size in bits of &lt;code&gt;double&lt;/code&gt; if</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ecbdd892eade8e6d4362e90240ff9047e6b2c01" translate="yes" xml:space="preserve">
          <source>The size of &lt;code&gt;t1&lt;/code&gt; is 8 bytes with the zero-length bit-field. If the zero-length bit-field were removed, &lt;code&gt;t1&lt;/code&gt;&amp;rsquo;s size would be 4 bytes.</source>
          <target state="translated">Размер &lt;code&gt;t1&lt;/code&gt; составляет 8 байтов с битовым полем нулевой длины. Если бы битовое поле нулевой длины было удалено, размер &lt;code&gt;t1&lt;/code&gt; составил бы 4 байта.</target>
        </trans-unit>
        <trans-unit id="d897dab500e785baf0afcdb6330501b34e2fb781" translate="yes" xml:space="preserve">
          <source>The size of L1 data cache, in kilobytes.</source>
          <target state="translated">Размер кэша данных L1,в килобайтах.</target>
        </trans-unit>
        <trans-unit id="ff6dd15bf08b6f82cff4329c9e979dcd9c6cbe07" translate="yes" xml:space="preserve">
          <source>The size of L2 data cache, in kilobytes.</source>
          <target state="translated">Размер кэша данных L2,в килобайтах.</target>
        </trans-unit>
        <trans-unit id="71e800ceb09e88f57e9df529fb883fbfe1a95ef2" translate="yes" xml:space="preserve">
          <source>The size of cache line in L1 data cache, in bytes.</source>
          <target state="translated">Размер строки кэша в кэше данных L1,в байтах.</target>
        </trans-unit>
        <trans-unit id="3f610b8af116509d824f7fee0527a19292abfbc2" translate="yes" xml:space="preserve">
          <source>The size of the result of subtracting two pointers to elements of the same array (C90 6.3.6, C99 and C11 6.5.6).</source>
          <target state="translated">Размер результата вычитания двух указателей из элементов одного и того же массива (C90 6.3.6,C99 и C11 6.5.6).</target>
        </trans-unit>
        <trans-unit id="bcebc70f5d364873d98786d882fbb6e891304f9b" translate="yes" xml:space="preserve">
          <source>The sizes of all structures and unions are rounded up to a multiple of the number of bits set by this option. Permissible values are 8, 32 and 64. The default value varies for different toolchains. For the COFF targeted toolchain the default value is 8. A value of 64 is only allowed if the underlying ABI supports it.</source>
          <target state="translated">Размеры всех структур и союзов округляются до кратного числа битов,заданного этой опцией.Допустимые значения 8,32 и 64.Значение по умолчанию варьируется для разных цепочек инструментов.Для целевой цепочки инструментов COFF значение по умолчанию равно 8.Значение 64 допустимо только в том случае,если базовый ABI поддерживает его.</target>
        </trans-unit>
        <trans-unit id="90ff87dc2c61fa6c28fc00209d8623b3de0f7131" translate="yes" xml:space="preserve">
          <source>The small data area consists of sections &lt;code&gt;.sdata&lt;/code&gt; and &lt;code&gt;.sbss&lt;/code&gt;. Objects may be explicitly put in the small data area with the &lt;code&gt;section&lt;/code&gt; attribute using one of these sections.</source>
          <target state="translated">Небольшая область данных состоит из разделов &lt;code&gt;.sdata&lt;/code&gt; и &lt;code&gt;.sbss&lt;/code&gt; . Объекты могут быть явно помещены в небольшую область данных с атрибутом &lt;code&gt;section&lt;/code&gt; используя один из этих разделов.</target>
        </trans-unit>
        <trans-unit id="1c7aae5531671a570fbd2d9e15330b629b257be9" translate="yes" xml:space="preserve">
          <source>The smallest number of different values for which it is best to use a jump-table instead of a tree of conditional branches. If the value is 0, use the default for the machine.</source>
          <target state="translated">Наименьшее количество различных значений,для которых лучше всего использовать прыжковый стол,а не дерево условных ветвей.Если значение 0,используйте значение по умолчанию для машины.</target>
        </trans-unit>
        <trans-unit id="792c114efc46a607cc045f1ab679489dd4452c8d" translate="yes" xml:space="preserve">
          <source>The solution is to change your program to use appropriate system headers (&lt;code&gt;&amp;lt;time.h&amp;gt;&lt;/code&gt; on systems with ISO C headers) and not to declare &lt;code&gt;time&lt;/code&gt; if the system header files declare it, or failing that to use &lt;code&gt;time_t&lt;/code&gt; as the return type of &lt;code&gt;time&lt;/code&gt;.</source>
          <target state="translated">Решение состоит в том, чтобы изменить вашу программу, чтобы использовать соответствующие системные заголовки ( &lt;code&gt;&amp;lt;time.h&amp;gt;&lt;/code&gt; в системах с заголовками ISO C) и не объявлять &lt;code&gt;time&lt;/code&gt; если файлы системных заголовков декларируют его, или, если это не &lt;code&gt;time_t&lt;/code&gt; использовать time_t в качестве возвращаемого типа &lt;code&gt;time&lt;/code&gt; ,</target>
        </trans-unit>
        <trans-unit id="7081cb8d8850184ab64a42d1afab009a2529d69a" translate="yes" xml:space="preserve">
          <source>The solution is to not use the</source>
          <target state="translated">Решение заключается в том,чтобы не использовать</target>
        </trans-unit>
        <trans-unit id="3f3e873518a99bceb250e9bd12263d250fd2ddde" translate="yes" xml:space="preserve">
          <source>The solution to these problems is to change the program to use &lt;code&gt;char&lt;/code&gt;-array variables with initialization strings for these purposes instead of string constants.</source>
          <target state="translated">Решение этих проблем состоит в том, чтобы изменить программу для использования переменных &lt;code&gt;char&lt;/code&gt; -array со строками инициализации для этих целей вместо строковых констант.</target>
        </trans-unit>
        <trans-unit id="65b067ba968d3fec2486b7d081b6185964ff8af7" translate="yes" xml:space="preserve">
          <source>The stack is not unwound before std::terminate is called.</source>
          <target state="translated">Стек не разворачивается перед вызовом std::termination.</target>
        </trans-unit>
        <trans-unit id="2ac8658551fc80e0b476a0a64406cc85ed6f059b" translate="yes" xml:space="preserve">
          <source>The stack pointer (SP) register is treated as 8-bit respectively 16-bit register by the compiler. The definition of these macros is affected by</source>
          <target state="translated">Регистр указателя стека (SP)компилятор рассматривает как 8-битный соответственно 16-битный регистр.На определение этих макросов влияет</target>
        </trans-unit>
        <trans-unit id="ba04d525c72586baf4467ca71d2abc7ef4aa1e82" translate="yes" xml:space="preserve">
          <source>The stack pointer register (&lt;code&gt;SP&lt;/code&gt;)</source>
          <target state="translated">Регистр указателя стека ( &lt;code&gt;SP&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="0015c9e48f6bee73194b21376b4a1e1666cb6b7a" translate="yes" xml:space="preserve">
          <source>The stack pointer register.</source>
          <target state="translated">Регистр указателей стека.</target>
        </trans-unit>
        <trans-unit id="7d93215dea1d74a35177f108c830b25b0a828601" translate="yes" xml:space="preserve">
          <source>The standard also defines two environments for programs, a &lt;em&gt;freestanding environment&lt;/em&gt;, required of all implementations and which may not have library facilities beyond those required of freestanding implementations, where the handling of program startup and termination are implementation-defined; and a &lt;em&gt;hosted environment&lt;/em&gt;, which is not required, in which all the library facilities are provided and startup is through a function &lt;code&gt;int
main (void)&lt;/code&gt; or &lt;code&gt;int main (int, char *[])&lt;/code&gt;. An OS kernel is an example of a program running in a freestanding environment; a program using the facilities of an operating system is an example of a program running in a hosted environment.</source>
          <target state="translated">Стандарт также определяет две среды для программ: &lt;em&gt;автономную среду&lt;/em&gt; , требуемую для всех реализаций и которая может не иметь библиотечных средств, помимо тех, которые требуются для автономных реализаций, где обработка запуска и завершения программы определяется реализацией; и &lt;em&gt;размещенная среда&lt;/em&gt; , которая не требуется, в которой предоставляются все возможности библиотеки, а запуск осуществляется с помощью функции &lt;code&gt;int main (void)&lt;/code&gt; или &lt;code&gt;int main (int, char *[])&lt;/code&gt; . Ядро ОС - это пример программы, работающей в автономной среде; программа, использующая возможности операционной системы, является примером программы, выполняемой в размещенной среде.</target>
        </trans-unit>
        <trans-unit id="aa6db7352466c6267511c0ba5dc350845fe3cad9" translate="yes" xml:space="preserve">
          <source>The standard is worded confusingly, therefore there is some debate over the precise meaning of the sequence point rules in subtle cases. Links to discussions of the problem, including proposed formal definitions, may be found on the GCC readings page, at &lt;a href=&quot;http://gcc.gnu.org/readings.html&quot;&gt;http://gcc.gnu.org/readings.html&lt;/a&gt;.</source>
          <target state="translated">Стандарт сформулирован запутанно, поэтому ведутся споры о точном значении правил точки последовательности в неуловимых случаях. Ссылки на обсуждение проблемы, включая предлагаемые формальные определения, можно найти на странице чтения GCC по адресу &lt;a href=&quot;http://gcc.gnu.org/readings.html&quot;&gt;http://gcc.gnu.org/readings.html&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9812a0f3e947d30b75931a27d53356e01e7c6d55" translate="yes" xml:space="preserve">
          <source>The standard is worded confusingly, therefore there is some debate over the precise meaning of the sequence point rules in subtle cases. Links to discussions of the problem, including proposed formal definitions, may be found on the GCC readings page, at &lt;a href=&quot;https://gcc.gnu.org/readings.html&quot;&gt;http://gcc.gnu.org/readings.html&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="69cda6ddbf344279c641ca143790b176ad293ac4" translate="yes" xml:space="preserve">
          <source>The standard rules for &lt;code&gt;&amp;lt;tgmath.h&amp;gt;&lt;/code&gt; macros are used to find a common type &lt;var&gt;u&lt;/var&gt; from the types of the arguments for parameters whose types vary between the functions; complex integer types (a GNU extension) are treated like &lt;code&gt;_Complex double&lt;/code&gt; for this purpose (or &lt;code&gt;_Complex _Float64&lt;/code&gt; if all the function return types are the same &lt;code&gt;_Float&lt;var&gt;n&lt;/var&gt;&lt;/code&gt; or &lt;code&gt;_Float&lt;var&gt;n&lt;/var&gt;x&lt;/code&gt; type). If the function return types vary, or are all the same integer type, the function called is the one for which &lt;var&gt;t&lt;/var&gt; is &lt;var&gt;u&lt;/var&gt;, and it is an error if there is no such function. If the function return types are all the same floating-point type, the type-generic macro is taken to be one of those from TS 18661 that rounds the result to a narrower type; if there is a function for which &lt;var&gt;t&lt;/var&gt; is &lt;var&gt;u&lt;/var&gt;, it is called, and otherwise the first function, if any, for which &lt;var&gt;t&lt;/var&gt; has at least the range and precision of &lt;var&gt;u&lt;/var&gt; is called, and it is an error if there is no such function.</source>
          <target state="translated">Стандартные правила для макросов &lt;code&gt;&amp;lt;tgmath.h&amp;gt;&lt;/code&gt; используются для поиска общего типа &lt;var&gt;u&lt;/var&gt; из типов аргументов для параметров, типы которых различаются между функциями; сложные целочисленные типы (расширение GNU) для этой цели обрабатываются как &lt;code&gt;_Complex double&lt;/code&gt; (или &lt;code&gt;_Complex _Float64&lt;/code&gt; , если все типы, возвращаемые функцией, являются одним и тем же &lt;code&gt;_Float&lt;var&gt;n&lt;/var&gt;&lt;/code&gt; или &lt;code&gt;_Float&lt;var&gt;n&lt;/var&gt;x&lt;/code&gt; ). Если типы, возвращаемые функцией, различаются или имеют один и тот же целочисленный тип, вызываемая функция является той, для которой &lt;var&gt;t&lt;/var&gt; равно &lt;var&gt;u&lt;/var&gt; ., и это ошибка, если такой функции нет. Если все типы, возвращаемые функцией, относятся к одному и тому же типу с плавающей запятой, общий макрос типа считается одним из макросов из TS 18661, который округляет результат до более узкого типа; если есть функция, для которой &lt;var&gt;t&lt;/var&gt; равно &lt;var&gt;u&lt;/var&gt; , она вызывается, в противном случае вызывается первая функция, если таковая имеется, для которой &lt;var&gt;t&lt;/var&gt; имеет по крайней мере диапазон и точность &lt;var&gt;u&lt;/var&gt; , и это ошибка, если такой функции нет ,</target>
        </trans-unit>
        <trans-unit id="806ce7f42e8deb00dbd822deaceb91e1417e5da0" translate="yes" xml:space="preserve">
          <source>The startup code from libgcc never sets &lt;code&gt;EIND&lt;/code&gt;. Notice that startup code is a blend of code from libgcc and AVR-LibC. For the impact of AVR-LibC on &lt;code&gt;EIND&lt;/code&gt;, see the &lt;a href=&quot;http://nongnu.org/avr-libc/user-manual/&quot;&gt;AVR-LibC user manual&lt;/a&gt;.</source>
          <target state="translated">Код запуска из libgcc никогда не устанавливает &lt;code&gt;EIND&lt;/code&gt; . Обратите внимание, что код запуска представляет собой смесь кода из libgcc и AVR-LibC. О влиянии AVR-LibC на &lt;code&gt;EIND&lt;/code&gt; см. &lt;a href=&quot;http://nongnu.org/avr-libc/user-manual/&quot;&gt;Руководство пользователя AVR-LibC&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f6e047a2c66caad1542c711e1ac7bf32d335f9de" translate="yes" xml:space="preserve">
          <source>The startup code from libgcc never sets &lt;code&gt;EIND&lt;/code&gt;. Notice that startup code is a blend of code from libgcc and AVR-LibC. For the impact of AVR-LibC on &lt;code&gt;EIND&lt;/code&gt;, see the &lt;a href=&quot;https://nongnu.org/avr-libc/user-manual/&quot;&gt;AVR-LibC user manual&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f98c1752aa45287d5195f68be596da96d8fbbbe6" translate="yes" xml:space="preserve">
          <source>The startup code initializes the &lt;code&gt;RAMP&lt;/code&gt; special function registers with zero.</source>
          <target state="translated">Код запуска инициализирует регистры специальной функции &lt;code&gt;RAMP&lt;/code&gt; нулем.</target>
        </trans-unit>
        <trans-unit id="e0593142bdd3bdb84b9aebea225043f72be034cf" translate="yes" xml:space="preserve">
          <source>The storage for an object of thread storage duration shall be statically initialized before the first statement of the thread startup function. An object of thread storage duration shall not require dynamic initialization.</source>
          <target state="translated">Хранилище для объекта нитевого хранения должно быть статически инициализировано перед первым оператором функции нитевого ввода в эксплуатацию.Объект хранения длительности нити не должен требовать динамической инициализации.</target>
        </trans-unit>
        <trans-unit id="641e9d242dbf689a8dfa4b2d4275700a77a5107c" translate="yes" xml:space="preserve">
          <source>The stored representation of the return address in memory may be different from the address returned by &lt;code&gt;__builtin_return_address&lt;/code&gt;. For example, on AArch64 the stored address may be mangled with return address signing whereas the address returned by &lt;code&gt;__builtin_return_address&lt;/code&gt; is not.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f4b780083ada416a6c378ae8867cc1c7fb0b433" translate="yes" xml:space="preserve">
          <source>The structure has size zero. In C++, empty structures are part of the language. G++ treats empty structures as if they had a single member of type &lt;code&gt;char&lt;/code&gt;.</source>
          <target state="translated">Структура имеет нулевой размер. В C ++ пустые структуры являются частью языка. G ++ обрабатывает пустые структуры, как если бы они имели единственный член типа &lt;code&gt;char&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3c2ecce652896fa952e1019513fab67001397b36" translate="yes" xml:space="preserve">
          <source>The subtype of the file created (like &amp;lsquo;</source>
          <target state="translated">Подтип созданного файла (например, '</target>
        </trans-unit>
        <trans-unit id="ca6a165fe3653c2eaa19af3a9cacad8cee1b0aa0" translate="yes" xml:space="preserve">
          <source>The switch matching text &lt;code&gt;S&lt;/code&gt; in a &amp;lsquo;</source>
          <target state="translated">Переключатель соответствует тексту &lt;code&gt;S&lt;/code&gt; в '</target>
        </trans-unit>
        <trans-unit id="2591c1475ef50f2d7871f5727f318ca9819d88ef" translate="yes" xml:space="preserve">
          <source>The syntax for this extension is</source>
          <target state="translated">Синтаксис этого расширения</target>
        </trans-unit>
        <trans-unit id="c37c4e36af6f9d7c15727a683845a9a4d1ae812e" translate="yes" xml:space="preserve">
          <source>The synthetic compare types&amp;ndash;gt, lt, ge, and le.</source>
          <target state="translated">Синтетические типы сравнения - gt, lt, ge и le.</target>
        </trans-unit>
        <trans-unit id="de0ec84c43a433725bea4939d7d6aa41982b5bb6" translate="yes" xml:space="preserve">
          <source>The system will help save all registers into stack before entering interrupt handler.</source>
          <target state="translated">Система поможет сохранить все регистры в стек перед вводом обработчика прерываний.</target>
        </trans-unit>
        <trans-unit id="0b39e2e7f8f008a32869aef147d2dc6314988d7d" translate="yes" xml:space="preserve">
          <source>The system will help save caller registers into stack before entering interrupt handler.</source>
          <target state="translated">Система поможет сохранить регистры вызывающих абонентов в стек до ввода обработчика прерываний.</target>
        </trans-unit>
        <trans-unit id="ebaa5c15171a87ae7a332bb49a3f32f19a3aad26" translate="yes" xml:space="preserve">
          <source>The table below lists the &lt;code&gt;v2i16&lt;/code&gt; operation for which hardware support exists for the DSP ASE REV 2. &lt;code&gt;e&lt;/code&gt; and &lt;code&gt;f&lt;/code&gt; are &lt;code&gt;v2i16&lt;/code&gt; values.</source>
          <target state="translated">В таблице ниже перечислены операции &lt;code&gt;v2i16&lt;/code&gt; , для которых существует аппаратная поддержка DSP ASE REV 2. &lt;code&gt;e&lt;/code&gt; и &lt;code&gt;f&lt;/code&gt; - значения &lt;code&gt;v2i16&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="896165ef2a0dc9f91cdad7ea07b67fa41d120e44" translate="yes" xml:space="preserve">
          <source>The table below lists the &lt;code&gt;v2sf&lt;/code&gt; operations for which hardware support exists. &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;b&lt;/code&gt; and &lt;code&gt;c&lt;/code&gt; are &lt;code&gt;v2sf&lt;/code&gt; values and &lt;code&gt;x&lt;/code&gt; is an integral value.</source>
          <target state="translated">В таблице ниже перечислены операции &lt;code&gt;v2sf&lt;/code&gt; , для которых существует поддержка оборудования. &lt;code&gt;a&lt;/code&gt; , &lt;code&gt;b&lt;/code&gt; и &lt;code&gt;c&lt;/code&gt; - значения &lt;code&gt;v2sf&lt;/code&gt; , а &lt;code&gt;x&lt;/code&gt; - целое значение.</target>
        </trans-unit>
        <trans-unit id="9b038d441c31fe7fb35f36ddaf2d9c7ea6b680b8" translate="yes" xml:space="preserve">
          <source>The table below lists the &lt;code&gt;v4i8&lt;/code&gt; and &lt;code&gt;v2q15&lt;/code&gt; operations for which hardware support exists. &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; are &lt;code&gt;v4i8&lt;/code&gt; values, and &lt;code&gt;c&lt;/code&gt; and &lt;code&gt;d&lt;/code&gt; are &lt;code&gt;v2q15&lt;/code&gt; values.</source>
          <target state="translated">В таблице ниже перечислены операции &lt;code&gt;v4i8&lt;/code&gt; и &lt;code&gt;v2q15&lt;/code&gt; , для которых существует поддержка оборудования. &lt;code&gt;a&lt;/code&gt; и &lt;code&gt;b&lt;/code&gt; - значения &lt;code&gt;v4i8&lt;/code&gt; , а &lt;code&gt;c&lt;/code&gt; и &lt;code&gt;d&lt;/code&gt; - значения &lt;code&gt;v2q15&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3f249ccb08815c6079cbd323b97a2c4ac2204382" translate="yes" xml:space="preserve">
          <source>The table below lists the supported extensions for each architecture. Architectures not mentioned do not support any extensions.</source>
          <target state="translated">В таблице ниже перечислены поддерживаемые расширения для каждой архитектуры.Не упомянутые архитектуры не поддерживают никаких расширений.</target>
        </trans-unit>
        <trans-unit id="e73d22c03412d342b6a999932c3fa6fbeb3a35b8" translate="yes" xml:space="preserve">
          <source>The table below shows the list of supported modifiers and their effects.</source>
          <target state="translated">В таблице ниже приведен список поддерживаемых модификаторов и их эффектов.</target>
        </trans-unit>
        <trans-unit id="52323f293e0d860891a87bc29f48cbde573c5856" translate="yes" xml:space="preserve">
          <source>The table below summarizes the permissible values for &lt;var&gt;arch&lt;/var&gt; and the features that they enable by default:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="15aee3d23ffff41850eb55f63ba2913dcc2593de" translate="yes" xml:space="preserve">
          <source>The target may also allow additional types in &lt;code&gt;format-arg&lt;/code&gt; attributes. See &lt;a href=&quot;target-format-checks#Target-Format-Checks&quot;&gt;Format Checks Specific to Particular Target Machines&lt;/a&gt;.</source>
          <target state="translated">Целевой объект может также разрешать дополнительные типы в атрибутах &lt;code&gt;format-arg&lt;/code&gt; . См. &lt;a href=&quot;target-format-checks#Target-Format-Checks&quot;&gt;Проверки формата, относящиеся к конкретным целевым машинам&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2e1eb5143cb3645d3e56fe87871163fa73c09f83" translate="yes" xml:space="preserve">
          <source>The target may also provide additional types of format checks. See &lt;a href=&quot;target-format-checks#Target-Format-Checks&quot;&gt;Format Checks Specific to Particular Target Machines&lt;/a&gt;.</source>
          <target state="translated">Целевой объект также может предоставлять дополнительные типы проверок формата. См. &lt;a href=&quot;target-format-checks#Target-Format-Checks&quot;&gt;Проверки формата, относящиеся к конкретным целевым машинам&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0b814fff953e9628f2b901dd62490d599d61582c" translate="yes" xml:space="preserve">
          <source>The the register class of registers that can be used to hold a sibcall call address. I.e., a caller-saved register.</source>
          <target state="translated">Класс регистров,который может быть использован для удержания адреса вызова sibcall.Т.е.регистр,сохраненный звонящим.</target>
        </trans-unit>
        <trans-unit id="e9067dbfe61d5583898a4c222466eaecdc743a7f" translate="yes" xml:space="preserve">
          <source>The third word specifies the source files for those structs for which the compiler should emit debug information. The values &amp;lsquo;</source>
          <target state="translated">Третье слово определяет исходные файлы для тех структур, для которых компилятор должен выдавать отладочную информацию. Ценности '</target>
        </trans-unit>
        <trans-unit id="3c2caf56b0822fe7bc0594ac85f716ffb2f0188f" translate="yes" xml:space="preserve">
          <source>The thread that begins execution at the &lt;code&gt;main&lt;/code&gt; function is called the &lt;em&gt;main thread&lt;/em&gt;. It is implementation defined how functions beginning threads other than the main thread are designated or typed. A function so designated, as well as the &lt;code&gt;main&lt;/code&gt; function, is called a &lt;em&gt;thread startup function&lt;/em&gt;. It is implementation defined what happens if a thread startup function returns. It is implementation defined what happens to other threads when any thread calls &lt;code&gt;exit&lt;/code&gt;.</source>
          <target state="translated">Поток, который начинает выполнение с &lt;code&gt;main&lt;/code&gt; функции, называется &lt;em&gt;основным потоком&lt;/em&gt; . Реализация определяет, как назначаются или типизируются функции, начинающие потоки, отличные от основного потока. Обозначенная таким образом функция, как и &lt;code&gt;main&lt;/code&gt; функция, называется &lt;em&gt;функцией запуска потока&lt;/em&gt; . Реализация определяет, что произойдет, если функция запуска потока вернется. Реализация определяет, что происходит с другими потоками при &lt;code&gt;exit&lt;/code&gt; любого потока .</target>
        </trans-unit>
        <trans-unit id="b44a5b130a3ceb5fe8f03b1aaa3178d1eeebc449" translate="yes" xml:space="preserve">
          <source>The three types of inlining behave similarly in two important cases: when the &lt;code&gt;inline&lt;/code&gt; keyword is used on a &lt;code&gt;static&lt;/code&gt; function, like the example above, and when a function is first declared without using the &lt;code&gt;inline&lt;/code&gt; keyword and then is defined with &lt;code&gt;inline&lt;/code&gt;, like this:</source>
          <target state="translated">Три типа встраивания ведут себя одинаково в двух важных случаях: когда ключевое слово &lt;code&gt;inline&lt;/code&gt; используется в &lt;code&gt;static&lt;/code&gt; функции, как в примере выше, и когда функция сначала объявляется без использования ключевого слова &lt;code&gt;inline&lt;/code&gt; , а затем определяется с помощью &lt;code&gt;inline&lt;/code&gt; , например:</target>
        </trans-unit>
        <trans-unit id="603ab7e85053589e42da345836681d51d569791a" translate="yes" xml:space="preserve">
          <source>The threshold ratio for performing partial redundancy elimination after reload.</source>
          <target state="translated">Пороговое соотношение для выполнения устранения частичного дублирования после перезарядки.</target>
        </trans-unit>
        <trans-unit id="423954d242ed49c029dc872280561e1e359efe72" translate="yes" xml:space="preserve">
          <source>The threshold ratio of critical edges execution count that permit performing redundancy elimination after reload.</source>
          <target state="translated">Пороговое значение коэффициента выполнения критических кромок,позволяющее выполнить устранение избыточности после перезарядки.</target>
        </trans-unit>
        <trans-unit id="a881665cedd4653a3bb7d98fcef7595547272bb0" translate="yes" xml:space="preserve">
          <source>The total number of input + output + goto operands is limited to 30.</source>
          <target state="translated">Общее количество входных и выходных операндов и операндов goto ограничено до 30.</target>
        </trans-unit>
        <trans-unit id="b51a43aea88607f1a48139a383f2efbea483ea5b" translate="yes" xml:space="preserve">
          <source>The total size (in bytes) required to pass all the parameters. This includes the two hidden parameters (the object &lt;code&gt;self&lt;/code&gt; and the method selector &lt;code&gt;_cmd&lt;/code&gt;).</source>
          <target state="translated">Общий размер (в байтах), необходимый для передачи всех параметров. Сюда входят два скрытых параметра (объект &lt;code&gt;self&lt;/code&gt; и селектор метода &lt;code&gt;_cmd&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="d0dea0413ee420eebb0c3352fcc9737b26d047ac" translate="yes" xml:space="preserve">
          <source>The transaction aborted due to a persistent failure. Re-execution under same circumstances will not be productive.</source>
          <target state="translated">Сделка была прервана из-за постоянной неудачи.Повторное исполнение при тех же обстоятельствах не будет продуктивным.</target>
        </trans-unit>
        <trans-unit id="7970397dce5e9b8e0cc50cc8d7046872a5452379" translate="yes" xml:space="preserve">
          <source>The transaction aborted due to a transient failure. The transaction should be re-executed in that case.</source>
          <target state="translated">Сделка была прервана в связи с кратковременным отказом.В этом случае сделка должна быть исполнена заново.</target>
        </trans-unit>
        <trans-unit id="885e4cc2a7b2481bfb38880d5bc544bde78ed78c" translate="yes" xml:space="preserve">
          <source>The transaction was aborted due to an indeterminate condition which might be persistent.</source>
          <target state="translated">Сделка была прервана в связи с неопределенным условием,которое может быть постоянным.</target>
        </trans-unit>
        <trans-unit id="eed635303d722768beed9ca9a2d786f5922ad4e3" translate="yes" xml:space="preserve">
          <source>The two Scalar Reduction of Aggregates passes (SRA and IPA-SRA) aim to replace scalar parts of aggregates with uses of independent scalar variables. These parameters control the maximum size, in storage units, of aggregate which is considered for replacement when compiling for speed (</source>
          <target state="translated">Два прохода Scalar Reduction of Aggregates (SRA и IPA-SRA)направлены на замену скалярных частей агрегатов на использование независимых скалярных переменных.Эти параметры контролируют максимальный размер в хранилищах агрегатов,который учитывается для замены при компиляции для скорости (</target>
        </trans-unit>
        <trans-unit id="d922516e422c7b0576d05743cb3430b4c8056971" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;char&lt;/code&gt; is always a distinct type from each of &lt;code&gt;signed char&lt;/code&gt; or &lt;code&gt;unsigned char&lt;/code&gt;, even though its behavior is always just like one of those two.</source>
          <target state="translated">Тип &lt;code&gt;char&lt;/code&gt; всегда отличается от каждого типа &lt;code&gt;signed char&lt;/code&gt; или &lt;code&gt;unsigned char&lt;/code&gt; , хотя его поведение всегда аналогично одному из этих двух.</target>
        </trans-unit>
        <trans-unit id="7f1531d2ff0ef2100fb6dbf78b0a6f5c969ddbe3" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;int[]&lt;/code&gt; and &lt;code&gt;int[5]&lt;/code&gt; are compatible. On the other hand, &lt;code&gt;int&lt;/code&gt; and &lt;code&gt;char *&lt;/code&gt; are not compatible, even if the size of their types, on the particular architecture are the same. Also, the amount of pointer indirection is taken into account when determining similarity. Consequently, &lt;code&gt;short *&lt;/code&gt; is not similar to &lt;code&gt;short **&lt;/code&gt;. Furthermore, two types that are typedefed are considered compatible if their underlying types are compatible.</source>
          <target state="translated">Типы &lt;code&gt;int[]&lt;/code&gt; и &lt;code&gt;int[5]&lt;/code&gt; совместимы. С другой стороны, &lt;code&gt;int&lt;/code&gt; и &lt;code&gt;char *&lt;/code&gt; несовместимы, даже если размер их типов в конкретной архитектуре одинаков. Кроме того, при определении подобия учитывается степень косвенного обращения указателя. Следовательно, &lt;code&gt;short *&lt;/code&gt; не похоже на &lt;code&gt;short **&lt;/code&gt; . Более того, два типа, которые определены как typedefed, считаются совместимыми, если совместимы их базовые типы.</target>
        </trans-unit>
        <trans-unit id="8f524b48e32ad47b9a83509e089c5a5e1558b871" translate="yes" xml:space="preserve">
          <source>The type of an object with thread storage duration shall not have a non-trivial destructor, nor shall it be an array type whose elements (directly or indirectly) have non-trivial destructors.</source>
          <target state="translated">Тип объекта с длительностью ниточного хранения не должен иметь нетривиального деструктора,равно как и тип массива,элементы которого (прямо или косвенно)имеют нетривиальные деструкторы.</target>
        </trans-unit>
        <trans-unit id="c90fc1cb110409689f90a0be940bc7d5911aa3a0" translate="yes" xml:space="preserve">
          <source>The type of these constants follows the same rules as for octal or hexadecimal integer constants, so suffixes like &amp;lsquo;</source>
          <target state="translated">Тип этих констант подчиняется тем же правилам, что и для восьмеричных или шестнадцатеричных целочисленных констант, поэтому суффиксы вроде '</target>
        </trans-unit>
        <trans-unit id="3e1c0747061b6e04e40c5232315c9ae3b95fbcea" translate="yes" xml:space="preserve">
          <source>The type specifiers are encoded just before the type. Unlike types however, the type specifiers are only encoded when they appear in method argument types.</source>
          <target state="translated">Спецификаторы типа кодируются непосредственно перед типом.Однако,в отличие от типов,спецификаторы типов кодируются только тогда,когда они появляются в типах аргументов метода.</target>
        </trans-unit>
        <trans-unit id="235cfb0079f1cae5d7bcfb5a4109668420b1ba20" translate="yes" xml:space="preserve">
          <source>The types are encoded in the following way:</source>
          <target state="translated">Типы кодируются следующим образом:</target>
        </trans-unit>
        <trans-unit id="a29416c27e6f97b9abc061da191be4a6083d70bc" translate="yes" xml:space="preserve">
          <source>The types defined in this manner can be used with a subset of normal C operations. Currently, GCC allows using the following operators on these types: &lt;code&gt;+, -, *, /, unary minus, ^, |, &amp;amp;, ~, %&lt;/code&gt;.</source>
          <target state="translated">Типы, определенные таким образом, могут использоваться с подмножеством обычных операций C. В настоящее время GCC позволяет использовать для этих типов следующие операторы: &lt;code&gt;+, -, *, /, unary minus, ^, |, &amp;amp;, ~, %&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e3fa8117933503d7edf67d6eb175e6d2d580176b" translate="yes" xml:space="preserve">
          <source>The types of long calls used depends on the capabilities of the assembler and linker, and the type of code being generated. The impact on systems that support long absolute calls, and long pic symbol-difference or pc-relative calls should be relatively small. However, an indirect call is used on 32-bit ELF systems in pic code and it is quite long.</source>
          <target state="translated">Типы используемых длинных вызовов зависят от возможностей ассемблера и компоновщика,а также от типа генерируемого кода.Влияние на системы,поддерживающие длинные абсолютные вызовы,а также длинные пиковые символы-дифференциация или pc-относительные вызовы должны быть относительно небольшими.Однако на 32-битных ELF-системах в коде pic используется косвенный вызов,и он достаточно длинный.</target>
        </trans-unit>
        <trans-unit id="ec5bc88005ecf61d67656c8a050fcb6e58f804f9" translate="yes" xml:space="preserve">
          <source>The types of the specified functions must all be different, but related to each other in the same way as a set of functions that may be selected between by a macro in &lt;code&gt;&amp;lt;tgmath.h&amp;gt;&lt;/code&gt;. This means that the functions are parameterized by a floating-point type &lt;var&gt;t&lt;/var&gt;, different for each such function. The function return types may all be the same type, or they may be &lt;var&gt;t&lt;/var&gt; for each function, or they may be the real type corresponding to &lt;var&gt;t&lt;/var&gt; for each function (if some of the types &lt;var&gt;t&lt;/var&gt; are complex). Likewise, for each parameter position, the type of the parameter in that position may always be the same type, or may be &lt;var&gt;t&lt;/var&gt; for each function (this case must apply for at least one parameter position), or may be the real type corresponding to &lt;var&gt;t&lt;/var&gt; for each function.</source>
          <target state="translated">Типы указанных функций должны быть разными, но связаны друг с другом таким же образом, как и набор функций, которые могут быть выбраны с помощью макроса в &lt;code&gt;&amp;lt;tgmath.h&amp;gt;&lt;/code&gt; . Это означает, что функции параметризованы типом с плавающей запятой &lt;var&gt;t&lt;/var&gt; , разным для каждой такой функции. Все типы, возвращаемые функцией, могут быть одного типа, или они могут быть &lt;var&gt;t&lt;/var&gt; для каждой функции, или они могут быть реальным типом, соответствующим &lt;var&gt;t&lt;/var&gt; для каждой функции (если некоторые из типов &lt;var&gt;t&lt;/var&gt; являются сложными). Аналогично, для каждой позиции параметра тип параметра в этой позиции всегда может быть одного и того же типа или может быть &lt;var&gt;t&lt;/var&gt; для каждой функции (этот случай должен применяться по крайней мере для одной позиции параметра) или может быть реальным типом, соответствующим &lt;var&gt;t&lt;/var&gt; для каждой функции.</target>
        </trans-unit>
        <trans-unit id="562884deec4ebf19cace230c1d8314c9d6fd11a3" translate="yes" xml:space="preserve">
          <source>The typical use of extended &lt;code&gt;asm&lt;/code&gt; statements is to manipulate input values to produce output values. However, your &lt;code&gt;asm&lt;/code&gt; statements may also produce side effects. If so, you may need to use the &lt;code&gt;volatile&lt;/code&gt; qualifier to disable certain optimizations. See &lt;a href=&quot;#Volatile&quot;&gt;Volatile&lt;/a&gt;.</source>
          <target state="translated">Типичное использование расширенных операторов &lt;code&gt;asm&lt;/code&gt; - манипулирование входными значениями для получения выходных значений. Однако ваши &lt;code&gt;asm&lt;/code&gt; - инструкции также могут вызывать побочные эффекты. Если это так, вам может потребоваться использовать квалификатор &lt;code&gt;volatile&lt;/code&gt; для отключения определенных оптимизаций. См. &quot; &lt;a href=&quot;#Volatile&quot;&gt;Летучие&quot;&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="45e652bb27a2083165bac75933fd850a0641a946" translate="yes" xml:space="preserve">
          <source>The unary plus operator.</source>
          <target state="translated">Унарный плюс оператор.</target>
        </trans-unit>
        <trans-unit id="5b7b641512751385c6d2814d121dfa7956a428c3" translate="yes" xml:space="preserve">
          <source>The underlying type of &lt;code&gt;type&lt;/code&gt;. Requires: &lt;code&gt;type&lt;/code&gt; shall be an enumeration type ([dcl.enum]).</source>
          <target state="translated">Базовый тип &lt;code&gt;type&lt;/code&gt; . Требуется: &lt;code&gt;type&lt;/code&gt; должен быть перечислимым типом ([dcl.enum]).</target>
        </trans-unit>
        <trans-unit id="4c9e93062c090121b29c563680d663f3d3e33b8a" translate="yes" xml:space="preserve">
          <source>The unique value of the member of the execution character set produced for each of the standard alphabetic escape sequences (C90, C99 and C11 5.2.2).</source>
          <target state="translated">Уникальное значение члена набора символов исполнения,производимого для каждой из стандартных алфавитных эвакуационных последовательностей (C90,C99 и C11 5.2.2).</target>
        </trans-unit>
        <trans-unit id="6e9148f286cc806482521d7ebb582ea948e1076d" translate="yes" xml:space="preserve">
          <source>The use of default arguments in function pointers, function typedefs and other places where they are not permitted by the standard is deprecated and will be removed from a future version of G++.</source>
          <target state="translated">Использование аргументов по умолчанию в указателях на функции,типизированных функциях и других местах,где они не разрешены стандартом,устарело и будет удалено из будущей версии G++.</target>
        </trans-unit>
        <trans-unit id="cb0aac07569b8c035da4f2196d548847237b0a9f" translate="yes" xml:space="preserve">
          <source>The usual calling convention has functions return values of types &lt;code&gt;float&lt;/code&gt; and &lt;code&gt;double&lt;/code&gt; in an FPU register, even if there is no FPU. The idea is that the operating system should emulate an FPU.</source>
          <target state="translated">В обычном соглашении о вызовах функции возвращают значения типов &lt;code&gt;float&lt;/code&gt; и &lt;code&gt;double&lt;/code&gt; в регистре FPU, даже если FPU отсутствует. Идея состоит в том, что операционная система должна эмулировать FPU.</target>
        </trans-unit>
        <trans-unit id="ad7784f3ecb2fcf462bcebb606253d24e3e9713b" translate="yes" xml:space="preserve">
          <source>The usual way to run GCC is to run the executable called &lt;code&gt;gcc&lt;/code&gt;, or &lt;code&gt;&lt;var&gt;machine&lt;/var&gt;-gcc&lt;/code&gt; when cross-compiling, or &lt;code&gt;&lt;var&gt;machine&lt;/var&gt;-gcc-&lt;var&gt;version&lt;/var&gt;&lt;/code&gt; to run a specific version of GCC. When you compile C++ programs, you should invoke GCC as &lt;code&gt;g++&lt;/code&gt; instead. See &lt;a href=&quot;invoking-g_002b_002b#Invoking-G_002b_002b&quot;&gt;Compiling C++ Programs&lt;/a&gt;, for information about the differences in behavior between &lt;code&gt;gcc&lt;/code&gt; and &lt;code&gt;g++&lt;/code&gt; when compiling C++ programs.</source>
          <target state="translated">Обычный способ запустить GCC - запустить исполняемый файл с именем &lt;code&gt;gcc&lt;/code&gt; , или &lt;code&gt;&lt;var&gt;machine&lt;/var&gt;-gcc&lt;/code&gt; при кросс-компиляции, или &lt;code&gt;&lt;var&gt;machine&lt;/var&gt;-gcc-&lt;var&gt;version&lt;/var&gt;&lt;/code&gt; для запуска определенной версии GCC. Когда вы компилируете программы на C ++, вы должны вместо этого вызывать GCC как &lt;code&gt;g++&lt;/code&gt; . См. В разделе &lt;a href=&quot;invoking-g_002b_002b#Invoking-G_002b_002b&quot;&gt;Компиляция программ&lt;/a&gt; на C ++ информацию о различиях в поведении &lt;code&gt;gcc&lt;/code&gt; и &lt;code&gt;g++&lt;/code&gt; при компиляции программ на C ++.</target>
        </trans-unit>
        <trans-unit id="b063501b645eb4fe8a716599b0b7b68ac7473998" translate="yes" xml:space="preserve">
          <source>The valid memory order variants are &lt;code&gt;__ATOMIC_RELAXED&lt;/code&gt;, &lt;code&gt;__ATOMIC_SEQ_CST&lt;/code&gt;, &lt;code&gt;__ATOMIC_ACQUIRE&lt;/code&gt;, &lt;code&gt;__ATOMIC_RELEASE&lt;/code&gt;, and &lt;code&gt;__ATOMIC_ACQ_REL&lt;/code&gt;.</source>
          <target state="translated">Допустимые варианты порядка памяти: &lt;code&gt;__ATOMIC_RELAXED&lt;/code&gt; , &lt;code&gt;__ATOMIC_SEQ_CST&lt;/code&gt; , &lt;code&gt;__ATOMIC_ACQUIRE&lt;/code&gt; , &lt;code&gt;__ATOMIC_RELEASE&lt;/code&gt; и &lt;code&gt;__ATOMIC_ACQ_REL&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6cc836f5cd3d793de6c86ebfa23594977254dab4" translate="yes" xml:space="preserve">
          <source>The valid memory order variants are &lt;code&gt;__ATOMIC_RELAXED&lt;/code&gt;, &lt;code&gt;__ATOMIC_SEQ_CST&lt;/code&gt;, &lt;code&gt;__ATOMIC_ACQUIRE&lt;/code&gt;, and &lt;code&gt;__ATOMIC_CONSUME&lt;/code&gt;.</source>
          <target state="translated">Допустимые варианты порядка памяти: &lt;code&gt;__ATOMIC_RELAXED&lt;/code&gt; , &lt;code&gt;__ATOMIC_SEQ_CST&lt;/code&gt; , &lt;code&gt;__ATOMIC_ACQUIRE&lt;/code&gt; и &lt;code&gt;__ATOMIC_CONSUME&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1b387c15b8d7905431f6ee70a72792d2b995cec6" translate="yes" xml:space="preserve">
          <source>The valid memory order variants are &lt;code&gt;__ATOMIC_RELAXED&lt;/code&gt;, &lt;code&gt;__ATOMIC_SEQ_CST&lt;/code&gt;, and &lt;code&gt;__ATOMIC_RELEASE&lt;/code&gt;.</source>
          <target state="translated">Допустимые варианты порядка памяти: &lt;code&gt;__ATOMIC_RELAXED&lt;/code&gt; , &lt;code&gt;__ATOMIC_SEQ_CST&lt;/code&gt; и &lt;code&gt;__ATOMIC_RELEASE&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b6608eaa83f451be81718292f24c656e5976df89" translate="yes" xml:space="preserve">
          <source>The value &amp;lsquo;</source>
          <target state="translated">Значение '</target>
        </trans-unit>
        <trans-unit id="9b81b1fa621fe4401621371ef2fb0416c4e7ec83" translate="yes" xml:space="preserve">
          <source>The value &lt;code&gt;branch&lt;/code&gt; tells the compiler to implement checking of validity of control-flow transfer at the point of indirect branch instructions, i.e. call/jmp instructions. The value &lt;code&gt;return&lt;/code&gt; implements checking of validity at the point of returning from a function. The value &lt;code&gt;full&lt;/code&gt; is an alias for specifying both &lt;code&gt;branch&lt;/code&gt; and &lt;code&gt;return&lt;/code&gt;. The value &lt;code&gt;none&lt;/code&gt; turns off instrumentation.</source>
          <target state="translated">&lt;code&gt;branch&lt;/code&gt; значения указывает компилятору реализовать проверку действительности передачи потока управления в точке косвенных инструкций перехода, то есть инструкций call / jmp. &lt;code&gt;return&lt;/code&gt; значение реализует проверку действительности в точке возврата из функции. Значение &lt;code&gt;full&lt;/code&gt; - это псевдоним для указания &lt;code&gt;branch&lt;/code&gt; и &lt;code&gt;return&lt;/code&gt; . Значение &lt;code&gt;none&lt;/code&gt; выключает инструментарий.</target>
        </trans-unit>
        <trans-unit id="cec00d8fc6d0d865baf91db330b98c794be36fbd" translate="yes" xml:space="preserve">
          <source>The value &lt;var&gt;N&lt;/var&gt; can be between 0 and 4. A value of 0 (the default) or 4 means that constants of any size are allowed.</source>
          <target state="translated">Значение &lt;var&gt;N&lt;/var&gt; может быть от 0 до 4. Значение 0 (по умолчанию) или 4 означает, что разрешены константы любого размера.</target>
        </trans-unit>
        <trans-unit id="bb7289e160f23adf91cfa58505c60106049d9e55" translate="yes" xml:space="preserve">
          <source>The value is as specified in the standard and the type is determined by the ABI.</source>
          <target state="translated">Значение указано в стандарте,а тип определяется ABI.</target>
        </trans-unit>
        <trans-unit id="da848852806dcfc33f52696b5619522d23c88e8e" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;COMPILER_PATH&lt;/code&gt; is a colon-separated list of directories, much like &lt;code&gt;PATH&lt;/code&gt;. GCC tries the directories thus specified when searching for subprograms, if it cannot find the subprograms using &lt;code&gt;GCC_EXEC_PREFIX&lt;/code&gt;.</source>
          <target state="translated">Значение &lt;code&gt;COMPILER_PATH&lt;/code&gt; - это список каталогов, разделенных двоеточиями, как и &lt;code&gt;PATH&lt;/code&gt; . GCC пробует указанные таким образом каталоги при поиске подпрограмм, если он не может найти подпрограммы с помощью &lt;code&gt;GCC_EXEC_PREFIX&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d72005aff0d80d4d1734d968cb3fab8a6e254f4d" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;DEPENDENCIES_OUTPUT&lt;/code&gt; can be just a file name, in which case the Make rules are written to that file, guessing the target name from the source file name. Or the value can have the form &amp;lsquo;</source>
          <target state="translated">Значение &lt;code&gt;DEPENDENCIES_OUTPUT&lt;/code&gt; может быть просто именем файла, и в этом случае правила Make записываются в этот файл, угадывая целевое имя из имени исходного файла. Или значение может иметь форму '</target>
        </trans-unit>
        <trans-unit id="edab9250e0babd1761a6140212faa3d4e9be6f54" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;LIBRARY_PATH&lt;/code&gt; is a colon-separated list of directories, much like &lt;code&gt;PATH&lt;/code&gt;. When configured as a native compiler, GCC tries the directories thus specified when searching for special linker files, if it cannot find them using &lt;code&gt;GCC_EXEC_PREFIX&lt;/code&gt;. Linking using GCC also uses these directories when searching for ordinary libraries for the</source>
          <target state="translated">Значение &lt;code&gt;LIBRARY_PATH&lt;/code&gt; - это список каталогов, разделенных двоеточиями, как и &lt;code&gt;PATH&lt;/code&gt; . При настройке как собственный компилятор GCC пробует указанные таким образом каталоги при поиске специальных файлов компоновщика, если он не может найти их с помощью &lt;code&gt;GCC_EXEC_PREFIX&lt;/code&gt; . Связывание с использованием GCC также использует эти каталоги при поиске обычных библиотек для</target>
        </trans-unit>
        <trans-unit id="43d97475c2600c7120869f306bf4b7bed4d2e9bd" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;SOURCE_DATE_EPOCH&lt;/code&gt; must be a UNIX timestamp, defined as the number of seconds (excluding leap seconds) since 01 Jan 1970 00:00:00 represented in ASCII; identical to the output of &amp;lsquo;</source>
          <target state="translated">Значение &lt;code&gt;SOURCE_DATE_EPOCH&lt;/code&gt; должно быть меткой времени UNIX, определяемой как количество секунд (исключая дополнительные секунды) с 00:00:00 01 января 1970 года, представленное в ASCII; идентичен выходу '</target>
        </trans-unit>
        <trans-unit id="66e4ba46bd46984b6c4ee052416293525cc2110b" translate="yes" xml:space="preserve">
          <source>The value of &lt;var&gt;addr&lt;/var&gt; is the address of the memory to prefetch. There are two optional arguments, &lt;var&gt;rw&lt;/var&gt; and &lt;var&gt;locality&lt;/var&gt;. The value of &lt;var&gt;rw&lt;/var&gt; is a compile-time constant one or zero; one means that the prefetch is preparing for a write to the memory address and zero, the default, means that the prefetch is preparing for a read. The value &lt;var&gt;locality&lt;/var&gt; must be a compile-time constant integer between zero and three. A value of zero means that the data has no temporal locality, so it need not be left in the cache after the access. A value of three means that the data has a high degree of temporal locality and should be left in all levels of cache possible. Values of one and two mean, respectively, a low or moderate degree of temporal locality. The default is three.</source>
          <target state="translated">Значение &lt;var&gt;addr&lt;/var&gt; - это адрес памяти для предварительной выборки. Есть два необязательных аргумента: &lt;var&gt;rw&lt;/var&gt; и &lt;var&gt;locality&lt;/var&gt; . Значение &lt;var&gt;rw&lt;/var&gt; - это постоянная времени компиляции, равная единице или нулю; один означает, что предварительная выборка готовится к записи по адресу памяти, а ноль, значение по умолчанию, означает, что предварительная выборка готовится к чтению. Ценность &lt;var&gt;locality&lt;/var&gt; должно быть целым числом константы времени компиляции от нуля до трех. Нулевое значение означает, что данные не имеют временной локальности, поэтому их не нужно оставлять в кэше после доступа. Значение три означает, что данные имеют высокую степень временной локальности и должны быть оставлены на всех возможных уровнях кеша. Значения &amp;laquo;один&amp;raquo; и &amp;laquo;два&amp;raquo; означают, соответственно, низкую или умеренную степень временной локальности. По умолчанию - три.</target>
        </trans-unit>
        <trans-unit id="70e11268aef227bb1a15172e67ca65858facec52" translate="yes" xml:space="preserve">
          <source>The value of &lt;var&gt;arguments&lt;/var&gt; should be the value returned by &lt;code&gt;__builtin_apply_args&lt;/code&gt;. The argument &lt;var&gt;size&lt;/var&gt; specifies the size of the stack argument data, in bytes.</source>
          <target state="translated">Значением &lt;var&gt;arguments&lt;/var&gt; должно быть значение, возвращаемое &lt;code&gt;__builtin_apply_args&lt;/code&gt; . Аргумент &lt;var&gt;size&lt;/var&gt; определяет размер данных стека аргументов в байтах.</target>
        </trans-unit>
        <trans-unit id="e97b2ef46aa7ac364dbf54d200c4936fb0a11aa0" translate="yes" xml:space="preserve">
          <source>The value of a &lt;code&gt;char&lt;/code&gt; object into which has been stored any character other than a member of the basic execution character set (C90 6.1.2.5, C99 and C11 6.2.5).</source>
          <target state="translated">Значение объекта &lt;code&gt;char&lt;/code&gt; , в котором был сохранен любой символ, кроме члена основного набора символов выполнения (C90 6.1.2.5, C99 и C11 6.2.5).</target>
        </trans-unit>
        <trans-unit id="c90677fad3803708fba68301854948c65ad2e0dc" translate="yes" xml:space="preserve">
          <source>The value of a string literal containing a multibyte character or escape sequence not represented in the execution character set (C90 6.1.4, C99 and C11 6.4.5).</source>
          <target state="translated">Значение строкового литерала,содержащего многобайтовую символьную или экранирующую последовательность,не представленную в наборе символов исполнения (С90 6.1.4,С99 и С11 6.4.5).</target>
        </trans-unit>
        <trans-unit id="0799bf13992e78d42dd3b2499d660140de9cd663" translate="yes" xml:space="preserve">
          <source>The value of a wide character constant containing more than one multibyte character or a single multibyte character that maps to multiple members of the extended execution character set, or containing a multibyte character or escape sequence not represented in the extended execution character set (C90 6.1.3.4, C99 and C11 6.4.4.4).</source>
          <target state="translated">Значение широкой символьной константы,содержащей более одного многобайтового символа или одного многобайтового символа,который сопоставляется нескольким членам расширенного набора символов исполнения,или содержащей многобайтовую символьную или экранирующую последовательность,не представленную в расширенном наборе символов исполнения (С90 6.1.3.4,С99 и С11 6.4.4.4).</target>
        </trans-unit>
        <trans-unit id="2de23bcdd7f53de07c13a72f7ab5e75f0f064b9a" translate="yes" xml:space="preserve">
          <source>The value of an integer character constant containing more than one character or containing a character or escape sequence that does not map to a single-byte execution character (C90 6.1.3.4, C99 and C11 6.4.4.4).</source>
          <target state="translated">Значение целочисленной символьной константы,содержащей более одного символа или содержащей символ или экранирующую последовательность,которая не сопоставляется с однобайтовым символом выполнения (С90 6.1.3.4,С99 и С11 6.4.4.4).</target>
        </trans-unit>
        <trans-unit id="bddf51b03e8582ac60e5e332485e2f5dfdaadff5" translate="yes" xml:space="preserve">
          <source>The value of the result of the &lt;code&gt;sizeof&lt;/code&gt; and &lt;code&gt;_Alignof&lt;/code&gt; operators (C90 6.3.3.4, C99 and C11 6.5.3.4).</source>
          <target state="translated">Значение результата операторов &lt;code&gt;sizeof&lt;/code&gt; и &lt;code&gt;_Alignof&lt;/code&gt; (C90 6.3.3.4, C99 и C11 6.5.3.4).</target>
        </trans-unit>
        <trans-unit id="c0b2873e2d72ded9fcc9fee52452da75fb562815" translate="yes" xml:space="preserve">
          <source>The value should be a known timestamp such as the last modification time of the source or package and it should be set by the build process.</source>
          <target state="translated">Значение должно быть известной меткой времени,например,время последней модификации исходного текста или пакета,и оно должно быть установлено в процессе сборки.</target>
        </trans-unit>
        <trans-unit id="e30741bdd1a5b46b18e6720866027b16cbef67a9" translate="yes" xml:space="preserve">
          <source>The values &amp;lsquo;</source>
          <target state="translated">Ценности '</target>
        </trans-unit>
        <trans-unit id="0725ef659b65323c744f64d2a18ca8ec4185c000" translate="yes" xml:space="preserve">
          <source>The values of the members of the execution character set (C90, C99 and C11 5.2.1).</source>
          <target state="translated">Значения членов набора символов исполнения (C90,C99 и C11 5.2.1).</target>
        </trans-unit>
        <trans-unit id="c50dd57103792a97d47d46235c3239eae04dabde" translate="yes" xml:space="preserve">
          <source>The values or expressions assigned to the macros specified in the headers &lt;code&gt;&amp;lt;float.h&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;limits.h&amp;gt;&lt;/code&gt;, and &lt;code&gt;&amp;lt;stdint.h&amp;gt;&lt;/code&gt; (C90, C99 and C11 5.2.4.2, C99 7.18.2, C99 7.18.3, C11 7.20.2, C11 7.20.3).</source>
          <target state="translated">Значения или выражения, присвоенные макросам, указанным в заголовках &lt;code&gt;&amp;lt;float.h&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;limits.h&amp;gt;&lt;/code&gt; и &lt;code&gt;&amp;lt;stdint.h&amp;gt;&lt;/code&gt; (C90, C99 и C11 5.2.4.2, C99 7.18.2, C99 7.18.3, C11 7.20.2, C11 7.20.3).</target>
        </trans-unit>
        <trans-unit id="c24e1e6a031d69e73f1ce7f443d81ca980894830" translate="yes" xml:space="preserve">
          <source>The vector type associated with paired-single values is usually called &lt;code&gt;v2sf&lt;/code&gt;. It can be defined in C as follows:</source>
          <target state="translated">Тип вектора, связанный с одиночными парными значениями, обычно называется &lt;code&gt;v2sf&lt;/code&gt; . Его можно определить в C следующим образом:</target>
        </trans-unit>
        <trans-unit id="37fd6ea52bde5e4eca142e1cb75092f72771ffd7" translate="yes" xml:space="preserve">
          <source>The virtual registers.</source>
          <target state="translated">Виртуальные регистры.</target>
        </trans-unit>
        <trans-unit id="72d4e21a353ad4b2c91fcbc017d8cd072d1cc8a4" translate="yes" xml:space="preserve">
          <source>The visibility attribute should be applied only to declarations that would otherwise have external linkage. The attribute should be applied consistently, so that the same entity should not be declared with different settings of the attribute.</source>
          <target state="translated">Атрибут видимости должен применяться только к тем декларациям,которые в противном случае имели бы внешнюю связь.Атрибут должен применяться последовательно,чтобы один и тот же объект не был объявлен с разными настройками атрибута.</target>
        </trans-unit>
        <trans-unit id="dcdff986b782b656015cb9e4191209d1fd6e3439" translate="yes" xml:space="preserve">
          <source>The warning is not issued after a &lt;code&gt;#line&lt;/code&gt; directive, since this typically indicates autogenerated code, and no assumptions can be made about the layout of the file that the directive references.</source>
          <target state="translated">Предупреждение не выдается после директивы &lt;code&gt;#line&lt;/code&gt; , поскольку это обычно указывает на автоматически сгенерированный код, и нельзя делать никаких предположений относительно макета файла, на который ссылается директива.</target>
        </trans-unit>
        <trans-unit id="c1d163df4c56e51212f1f69dc140213a05352c42" translate="yes" xml:space="preserve">
          <source>The warning is not issued for code involving multiline preprocessor logic such as the following example.</source>
          <target state="translated">Предупреждение не выдается для кода с многопоточной логикой препроцессора,как,например,в следующем примере.</target>
        </trans-unit>
        <trans-unit id="dcb7b8cd90065f04f3725df949fc5d9c95db8632" translate="yes" xml:space="preserve">
          <source>The warning message for each controllable warning includes the option that controls the warning. That option can then be used with</source>
          <target state="translated">Предупреждающее сообщение для каждого управляемого предупреждения включает опцию,управляющую предупреждением.Эта опция может быть использована с</target>
        </trans-unit>
        <trans-unit id="f1f31ebd493031aa0be9fb191d41eda3a3e18dd4" translate="yes" xml:space="preserve">
          <source>The warnings for missing or incorrect sentinels are enabled with</source>
          <target state="translated">Предупреждения о пропущенных или неправильных часовых включаются с помощью функции</target>
        </trans-unit>
        <trans-unit id="6fb1f41a4e1e0161c8bf4c849af0ffb5ebafd481" translate="yes" xml:space="preserve">
          <source>The way to solve these problems is to put &amp;lsquo;</source>
          <target state="translated">Способ решения этих проблем - поставить '</target>
        </trans-unit>
        <trans-unit id="206a81db22964ace6231b75566fe4c7da1707abe" translate="yes" xml:space="preserve">
          <source>The workarounds for the division errata rely on special functions in</source>
          <target state="translated">Обходные пути для обходных путей при ошибках деления полагаются на специальные функции в</target>
        </trans-unit>
        <trans-unit id="3ecc69e9abd77cc6ec0f76d76bb1dccaddb7e950" translate="yes" xml:space="preserve">
          <source>The x86 architecture supports additional memory ordering flags to mark critical sections for hardware lock elision. These must be specified in addition to an existing memory order to atomic intrinsics.</source>
          <target state="translated">Архитектура x86 поддерживает дополнительные флаги заказа памяти для маркировки критических участков для элиминации аппаратной блокировки.Они должны быть указаны в дополнение к существующему порядку заказа памяти для атомарных intrinsics.</target>
        </trans-unit>
        <trans-unit id="f94474d9a2fee2945e274919425bc2dedd2ef21c" translate="yes" xml:space="preserve">
          <source>The x86-32 and x86-64 family of processors use additional built-in functions for efficient use of &lt;code&gt;TF&lt;/code&gt; (&lt;code&gt;__float128&lt;/code&gt;) 128-bit floating point and &lt;code&gt;TC&lt;/code&gt; 128-bit complex floating-point values.</source>
          <target state="translated">Семейство процессоров x86-32 и x86-64 использует дополнительные встроенные функции для эффективного использования 128-битных значений с плавающей запятой &lt;code&gt;TF&lt;/code&gt; ( &lt;code&gt;__float128&lt;/code&gt; ) и 128-битных сложных значений с плавающей запятой &lt;code&gt;TC&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d02b4be795b4b009422772986429301880a6ca1d" translate="yes" xml:space="preserve">
          <source>Then use the &lt;code&gt;create_gcov&lt;/code&gt; tool to convert the raw profile data to a format that can be used by GCC. You must also supply the unstripped binary for your program to this tool. See &lt;a href=&quot;https://github.com/google/autofdo&quot;&gt;https://github.com/google/autofdo&lt;/a&gt;.</source>
          <target state="translated">Затем используйте инструмент &lt;code&gt;create_gcov&lt;/code&gt; для преобразования необработанных данных профиля в формат, который может использоваться GCC. Вы также должны предоставить этому инструменту распакованный двоичный файл для вашей программы. См. &lt;a href=&quot;https://github.com/google/autofdo&quot;&gt;Https://github.com/google/autofdo&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="926b284ef06d8680215f804da3458309f6cd9668" translate="yes" xml:space="preserve">
          <source>Then you can select a label with indexing, like this:</source>
          <target state="translated">Затем можно выбрать метку с индексацией,например,вот так:</target>
        </trans-unit>
        <trans-unit id="cea728bf3b20beeae36b33c3b1a8dc7982befc50" translate="yes" xml:space="preserve">
          <source>There are 6 different memory orders that can be specified. These map to the C++11 memory orders with the same names, see the C++11 standard or the &lt;a href=&quot;http://gcc.gnu.org/wiki/Atomic/GCCMM/AtomicSync&quot;&gt;GCC wiki on atomic synchronization&lt;/a&gt; for detailed definitions. Individual targets may also support additional memory orders for use on specific architectures. Refer to the target documentation for details of these.</source>
          <target state="translated">Можно указать 6 различных порядков памяти. Они сопоставляются с порядками памяти C ++ 11 с такими же именами, подробные определения см. В стандарте C ++ 11 или в &lt;a href=&quot;http://gcc.gnu.org/wiki/Atomic/GCCMM/AtomicSync&quot;&gt;вики GCC по атомарной синхронизации&lt;/a&gt; . Отдельные цели могут также поддерживать дополнительные заказы памяти для использования на определенных архитектурах. Обратитесь к целевой документации для получения подробной информации.</target>
        </trans-unit>
        <trans-unit id="31b7e6def3a5383489256a492d966516e1a8f033" translate="yes" xml:space="preserve">
          <source>There are 6 different memory orders that can be specified. These map to the C++11 memory orders with the same names, see the C++11 standard or the &lt;a href=&quot;https://gcc.gnu.org/wiki/Atomic/GCCMM/AtomicSync&quot;&gt;GCC wiki on atomic synchronization&lt;/a&gt; for detailed definitions. Individual targets may also support additional memory orders for use on specific architectures. Refer to the target documentation for details of these.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="02f6ba3037fb7689eee8ed8968fd8f0d8ac13840" translate="yes" xml:space="preserve">
          <source>There are also GNU extension functions &lt;code&gt;clog10&lt;/code&gt;, &lt;code&gt;clog10f&lt;/code&gt; and &lt;code&gt;clog10l&lt;/code&gt; which names are reserved by ISO C99 for future use. All these functions have versions prefixed with &lt;code&gt;__builtin_&lt;/code&gt;.</source>
          <target state="translated">Также существуют функции расширения GNU &lt;code&gt;clog10&lt;/code&gt; , &lt;code&gt;clog10f&lt;/code&gt; и &lt;code&gt;clog10l&lt;/code&gt; , имена которых зарезервированы ISO C99 для использования в будущем. Все эти функции имеют версии с префиксом &lt;code&gt;__builtin_&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="875ce1195c45f2b46d9a99c39e44fd3ec9b5e9cf" translate="yes" xml:space="preserve">
          <source>There are also built-in functions &lt;code&gt;__builtin_fabsf&lt;var&gt;n&lt;/var&gt;&lt;/code&gt;, &lt;code&gt;__builtin_fabsf&lt;var&gt;n&lt;/var&gt;x&lt;/code&gt;, &lt;code&gt;__builtin_copysignf&lt;var&gt;n&lt;/var&gt;&lt;/code&gt; and &lt;code&gt;__builtin_copysignf&lt;var&gt;n&lt;/var&gt;x&lt;/code&gt;, corresponding to the TS 18661-3 functions &lt;code&gt;fabsf&lt;var&gt;n&lt;/var&gt;&lt;/code&gt;, &lt;code&gt;fabsf&lt;var&gt;n&lt;/var&gt;x&lt;/code&gt;, &lt;code&gt;copysignf&lt;var&gt;n&lt;/var&gt;&lt;/code&gt; and &lt;code&gt;copysignf&lt;var&gt;n&lt;/var&gt;x&lt;/code&gt;, for supported types &lt;code&gt;_Float&lt;var&gt;n&lt;/var&gt;&lt;/code&gt; and &lt;code&gt;_Float&lt;var&gt;n&lt;/var&gt;x&lt;/code&gt;.</source>
          <target state="translated">Там также встроенные функции &lt;code&gt;__builtin_fabsf&lt;var&gt;n&lt;/var&gt;&lt;/code&gt; , &lt;code&gt;__builtin_fabsf&lt;var&gt;n&lt;/var&gt;x&lt;/code&gt; , &lt;code&gt;__builtin_copysignf&lt;var&gt;n&lt;/var&gt;&lt;/code&gt; и &lt;code&gt;__builtin_copysignf&lt;var&gt;n&lt;/var&gt;x&lt;/code&gt; , соответствующие функциям TS 18661-3 &lt;code&gt;fabsf&lt;var&gt;n&lt;/var&gt;&lt;/code&gt; , &lt;code&gt;fabsf&lt;var&gt;n&lt;/var&gt;x&lt;/code&gt; , &lt;code&gt;copysignf&lt;var&gt;n&lt;/var&gt;&lt;/code&gt; и &lt;code&gt;copysignf&lt;var&gt;n&lt;/var&gt;x&lt;/code&gt; , для поддерживаемых типов &lt;code&gt;_Float&lt;var&gt;n&lt;/var&gt;&lt;/code&gt; и &lt;code&gt;_Float&lt;var&gt;n&lt;/var&gt;x&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="10087f06f9970243ffcf86e55d1829b3627290b7" translate="yes" xml:space="preserve">
          <source>There are also built-in versions of the ISO C99 functions &lt;code&gt;acosf&lt;/code&gt;, &lt;code&gt;acosl&lt;/code&gt;, &lt;code&gt;asinf&lt;/code&gt;, &lt;code&gt;asinl&lt;/code&gt;, &lt;code&gt;atan2f&lt;/code&gt;, &lt;code&gt;atan2l&lt;/code&gt;, &lt;code&gt;atanf&lt;/code&gt;, &lt;code&gt;atanl&lt;/code&gt;, &lt;code&gt;ceilf&lt;/code&gt;, &lt;code&gt;ceill&lt;/code&gt;, &lt;code&gt;cosf&lt;/code&gt;, &lt;code&gt;coshf&lt;/code&gt;, &lt;code&gt;coshl&lt;/code&gt;, &lt;code&gt;cosl&lt;/code&gt;, &lt;code&gt;expf&lt;/code&gt;, &lt;code&gt;expl&lt;/code&gt;, &lt;code&gt;fabsf&lt;/code&gt;, &lt;code&gt;fabsl&lt;/code&gt;, &lt;code&gt;floorf&lt;/code&gt;, &lt;code&gt;floorl&lt;/code&gt;, &lt;code&gt;fmodf&lt;/code&gt;, &lt;code&gt;fmodl&lt;/code&gt;, &lt;code&gt;frexpf&lt;/code&gt;, &lt;code&gt;frexpl&lt;/code&gt;, &lt;code&gt;ldexpf&lt;/code&gt;, &lt;code&gt;ldexpl&lt;/code&gt;, &lt;code&gt;log10f&lt;/code&gt;, &lt;code&gt;log10l&lt;/code&gt;, &lt;code&gt;logf&lt;/code&gt;, &lt;code&gt;logl&lt;/code&gt;, &lt;code&gt;modfl&lt;/code&gt;, &lt;code&gt;modf&lt;/code&gt;, &lt;code&gt;powf&lt;/code&gt;, &lt;code&gt;powl&lt;/code&gt;, &lt;code&gt;sinf&lt;/code&gt;, &lt;code&gt;sinhf&lt;/code&gt;, &lt;code&gt;sinhl&lt;/code&gt;, &lt;code&gt;sinl&lt;/code&gt;, &lt;code&gt;sqrtf&lt;/code&gt;, &lt;code&gt;sqrtl&lt;/code&gt;, &lt;code&gt;tanf&lt;/code&gt;, &lt;code&gt;tanhf&lt;/code&gt;, &lt;code&gt;tanhl&lt;/code&gt; and &lt;code&gt;tanl&lt;/code&gt; that are recognized in any mode since ISO C90 reserves these names for the purpose to which ISO C99 puts them. All these functions have corresponding versions prefixed with &lt;code&gt;__builtin_&lt;/code&gt;.</source>
          <target state="translated">Существуют также встроенные версии функций ISO C99: &lt;code&gt;acosf&lt;/code&gt; , &lt;code&gt;acosl&lt;/code&gt; , &lt;code&gt;asinf&lt;/code&gt; , &lt;code&gt;asinl&lt;/code&gt; , &lt;code&gt;atan2f&lt;/code&gt; , &lt;code&gt;atan2l&lt;/code&gt; , &lt;code&gt;atanf&lt;/code&gt; , &lt;code&gt;atanl&lt;/code&gt; , &lt;code&gt;ceilf&lt;/code&gt; , &lt;code&gt;ceill&lt;/code&gt; , &lt;code&gt;cosf&lt;/code&gt; , &lt;code&gt;coshf&lt;/code&gt; , &lt;code&gt;coshl&lt;/code&gt; , &lt;code&gt;cosl&lt;/code&gt; , &lt;code&gt;expf&lt;/code&gt; , &lt;code&gt;expl&lt;/code&gt; orer , &lt;code&gt;fabsf&lt;/code&gt; , &lt;code&gt;fabsl&lt;/code&gt; , &lt;code&gt;floorf&lt;/code&gt; , &lt;code&gt;floorl&lt;/code&gt; , &lt;code&gt;fmodf&lt;/code&gt; , &lt;code&gt;fmodl&lt;/code&gt; , &lt;code&gt;frexpf&lt;/code&gt; , &lt;code&gt;frexpl&lt;/code&gt; , &lt;code&gt;ldexpf&lt;/code&gt; , &lt;code&gt;ldexpl&lt;/code&gt; , &lt;code&gt;log10f&lt;/code&gt; , &lt;code&gt;log10l&lt;/code&gt; , &lt;code&gt;logf&lt;/code&gt; , &lt;code&gt;logl&lt;/code&gt; , &lt;code&gt;modfl&lt;/code&gt; , &lt;code&gt;modf&lt;/code&gt; , &lt;code&gt;powf&lt;/code&gt; , &lt;code&gt;powl&lt;/code&gt; , &lt;code&gt;sinf&lt;/code&gt; , &lt;code&gt;sinhf&lt;/code&gt; , &lt;code&gt;sinhl&lt;/code&gt; , &lt;code&gt;sinl&lt;/code&gt; , &lt;code&gt;sqrtf&lt;/code&gt; , &lt;code&gt;sqrtl&lt;/code&gt; , &lt;code&gt;tanf&lt;/code&gt; , &lt;code&gt;tanhf&lt;/code&gt; , &lt;code&gt;tanhl&lt;/code&gt; и &lt;code&gt;tanl&lt;/code&gt; , которые распознаются в любом режиме, поскольку ISO C90 резервирует эти имена соответствуют той цели, для которой их ставит ISO C99. Все эти функции имеют соответствующие версии с префиксом &lt;code&gt;__builtin_&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e32bac703972f0098c171900bd4cc85df014dde5" translate="yes" xml:space="preserve">
          <source>There are also checking built-in functions for formatted output functions.</source>
          <target state="translated">Имеются также встроенные функции проверки форматированных выходных функций.</target>
        </trans-unit>
        <trans-unit id="4f8ad06fe6014524cc57bfacf331d94eea076d2f" translate="yes" xml:space="preserve">
          <source>There are built-in functions added for many common string operation functions, e.g., for &lt;code&gt;memcpy&lt;/code&gt;&lt;code&gt;__builtin___memcpy_chk&lt;/code&gt; built-in is provided. This built-in has an additional last argument, which is the number of bytes remaining in the object the &lt;var&gt;dest&lt;/var&gt; argument points to or &lt;code&gt;(size_t) -1&lt;/code&gt; if the size is not known.</source>
          <target state="translated">Для многих стандартных функций строковых операций добавлены встроенные функции, например, для &lt;code&gt;memcpy&lt;/code&gt; предоставляется встроенный &lt;code&gt;__builtin___memcpy_chk&lt;/code&gt; . Эта встроенная функция имеет дополнительный последний аргумент, который представляет собой количество байтов, оставшихся в объекте, на который указывает аргумент &lt;var&gt;dest&lt;/var&gt; , или &lt;code&gt;(size_t) -1&lt;/code&gt; если размер неизвестен.</target>
        </trans-unit>
        <trans-unit id="e8ecb3f393a336df7fd790409c78fca65366bb71" translate="yes" xml:space="preserve">
          <source>There are four levels of warning supported by GCC. The default is</source>
          <target state="translated">Существует четыре уровня предупреждений,поддерживаемых GCC.По умолчанию</target>
        </trans-unit>
        <trans-unit id="c5c6335a792caea07ef43ebcfd0dbedc3bba84b4" translate="yes" xml:space="preserve">
          <source>There are four supported &lt;var&gt;visibility_type&lt;/var&gt; values: default, hidden, protected or internal visibility.</source>
          <target state="translated">Существует четыре поддерживаемых значения &lt;var&gt;visibility_type&lt;/var&gt; : по умолчанию, скрытый, защищенный или внутренняя видимость.</target>
        </trans-unit>
        <trans-unit id="ce8ba713c06a7d9c57fd70b516918aacdd01bbce" translate="yes" xml:space="preserve">
          <source>There are many more AVR-specific built-in functions that are used to implement the ISO/IEC TR 18037 &amp;ldquo;Embedded C&amp;rdquo; fixed-point functions of section 7.18a.6. You don&amp;rsquo;t need to use these built-ins directly. Instead, use the declarations as supplied by the &lt;code&gt;stdfix.h&lt;/code&gt; header with GNU-C99:</source>
          <target state="translated">Существует гораздо больше встроенных функций, специфичных для AVR, которые используются для реализации функций фиксированной точки ISO / IEC TR 18037 &amp;laquo;Встроенный C&amp;raquo; раздела 7.18a.6. Вам не нужно использовать эти встроенные модули напрямую. Вместо этого используйте объявления, предоставленные заголовком &lt;code&gt;stdfix.h&lt;/code&gt; с GNU-C99:</target>
        </trans-unit>
        <trans-unit id="82e7d52ba0a431ff758889d5327a13ddffa9df26" translate="yes" xml:space="preserve">
          <source>There are many other possibilities, limited only by your imagination, good sense, and the constraints of your build system.</source>
          <target state="translated">Есть много других возможностей,ограниченных только вашим воображением,здравым смыслом и ограничениями вашей системы сборки.</target>
        </trans-unit>
        <trans-unit id="15ef48c0fb35d807a55378bf489805cb806add15" translate="yes" xml:space="preserve">
          <source>There are other differences between these two methods. Space allocated with &lt;code&gt;alloca&lt;/code&gt; exists until the containing &lt;em&gt;function&lt;/em&gt; returns. The space for a variable-length array is deallocated as soon as the array name&amp;rsquo;s scope ends, unless you also use &lt;code&gt;alloca&lt;/code&gt; in this scope.</source>
          <target state="translated">Между этими двумя методами есть и другие различия. Пространство, выделенное с помощью &lt;code&gt;alloca&lt;/code&gt; , существует до возврата из содержащей его &lt;em&gt;функции&lt;/em&gt; . Пространство для массива переменной длины освобождается, как только область видимости имени массива заканчивается, если вы также не используете &lt;code&gt;alloca&lt;/code&gt; в этой области.</target>
        </trans-unit>
        <trans-unit id="ec4c204c6335b8fb2d87ba86456a428609cad26b" translate="yes" xml:space="preserve">
          <source>There are several caveats to using the new exception mechanism:</source>
          <target state="translated">Существует несколько предостережений относительно использования нового механизма исключений:</target>
        </trans-unit>
        <trans-unit id="c35ba4e6fe38d832f24909aadf0cb677e0066a30" translate="yes" xml:space="preserve">
          <source>There are several constructs in C++ that require space in the object file but are not clearly tied to a single translation unit. We say that these constructs have &amp;ldquo;vague linkage&amp;rdquo;. Typically such constructs are emitted wherever they are needed, though sometimes we can be more clever.</source>
          <target state="translated">В C ++ есть несколько конструкций, которым требуется место в объектном файле, но которые явно не привязаны к одной единице перевода. Мы говорим, что эти конструкции имеют &amp;laquo;неопределенную связь&amp;raquo;. Обычно такие конструкции генерируются везде, где они нужны, хотя иногда мы можем быть более умными.</target>
        </trans-unit>
        <trans-unit id="973e35674df499ab71700555edbe1a93e1641ce5" translate="yes" xml:space="preserve">
          <source>There are several noteworthy incompatibilities between GNU C and K&amp;amp;R (non-ISO) versions of C.</source>
          <target state="translated">Есть несколько примечательных несовместимостей между GNU C и K&amp;amp;R (не ISO) версиями C.</target>
        </trans-unit>
        <trans-unit id="0f04da83ffcbe77658a4a2fadeea31bbf52a4d35" translate="yes" xml:space="preserve">
          <source>There are several situations in which an application should use the shared</source>
          <target state="translated">Существует несколько ситуаций,в которых приложение должно использовать общий</target>
        </trans-unit>
        <trans-unit id="7959f13cb983e884f2106a8d8e6aa988bd66a9f9" translate="yes" xml:space="preserve">
          <source>There are some arguments for making bit-fields unsigned by default on all machines. If, for example, this becomes a universal de facto standard, it would make sense for GCC to go along with it. This is something to be considered in the future.</source>
          <target state="translated">Есть некоторые аргументы в пользу того,чтобы сделать битовые поля неподписанными по умолчанию на всех машинах.Если,например,это станет универсальным де-факто стандартом,то GCC имеет смысл согласиться с ним.Это нужно будет учесть в будущем.</target>
        </trans-unit>
        <trans-unit id="451c9c37af0f9094bf98f147452ec7b2c1e8a8be" translate="yes" xml:space="preserve">
          <source>There are some code generation flags preserved by GCC when generating bytecodes, as they need to be used during the final link. Currently, the following options and their settings are taken from the first object file that explicitly specifies them:</source>
          <target state="translated">При генерации байткодов GCC сохраняет некоторые флаги генерации кода,так как они должны использоваться во время конечной ссылки.В настоящее время следующие опции и их настройки взяты из первого объектного файла,который их явно указывает:</target>
        </trans-unit>
        <trans-unit id="d537bfaa9f6c3001fc1a88f5b799ca08bd61a582" translate="yes" xml:space="preserve">
          <source>There are some constraints on how this can be used&amp;mdash;</source>
          <target state="translated">Есть некоторые ограничения на то, как это можно использовать -</target>
        </trans-unit>
        <trans-unit id="136389e963628b14cbedd792ceed996572d52240" translate="yes" xml:space="preserve">
          <source>There are some problems with the semantics of attributes in C++. For example, there are no manglings for attributes, although they may affect code generation, so problems may arise when attributed types are used in conjunction with templates or overloading. Similarly, &lt;code&gt;typeid&lt;/code&gt; does not distinguish between types with different attributes. Support for attributes in C++ may be restricted in future to attributes on declarations only, but not on nested declarators.</source>
          <target state="translated">В C ++ есть некоторые проблемы с семантикой атрибутов. Например, нет изменений для атрибутов, хотя они могут повлиять на генерацию кода, поэтому могут возникнуть проблемы, когда атрибутные типы используются вместе с шаблонами или перегрузкой. Точно так же &lt;code&gt;typeid&lt;/code&gt; не различает типы с разными атрибутами. В будущем поддержка атрибутов в C ++ может быть ограничена атрибутами только в объявлениях, но не во вложенных деклараторах.</target>
        </trans-unit>
        <trans-unit id="f0a43a1a2abc532264a4772bfd3acfd532a1ab60" translate="yes" xml:space="preserve">
          <source>There are two ways of writing the argument to &lt;code&gt;typeof&lt;/code&gt;: with an expression or with a type. Here is an example with an expression:</source>
          <target state="translated">Есть два способа записать аргумент в &lt;code&gt;typeof&lt;/code&gt; : с выражением или с типом. Вот пример с выражением:</target>
        </trans-unit>
        <trans-unit id="bc25dda9b9f38426b4a5c6b4195fea59e37ab096" translate="yes" xml:space="preserve">
          <source>There is a new runtime function &lt;code&gt;class_ivar_set_gcinvisible()&lt;/code&gt; which can be used to declare a so-called &lt;em&gt;weak pointer&lt;/em&gt; reference. Such a pointer is basically hidden for the garbage collector; this can be useful in certain situations, especially when you want to keep track of the allocated objects, yet allow them to be collected. This kind of pointers can only be members of objects, you cannot declare a global pointer as a weak reference. Every type which is a pointer type can be declared a weak pointer, including &lt;code&gt;id&lt;/code&gt;, &lt;code&gt;Class&lt;/code&gt; and &lt;code&gt;SEL&lt;/code&gt;.</source>
          <target state="translated">Есть новая функция времени выполнения &lt;code&gt;class_ivar_set_gcinvisible()&lt;/code&gt; которую можно использовать для объявления так называемой ссылки на &lt;em&gt;слабый указатель&lt;/em&gt; . Такой указатель в основном скрыт для сборщика мусора; это может быть полезно в определенных ситуациях, особенно когда вы хотите отслеживать выделенные объекты, но разрешить их сбор. Указатели такого типа могут быть только членами объектов, вы не можете объявить глобальный указатель как слабую ссылку. Каждый тип, являющийся типом указателя, может быть объявлен слабым указателем, включая &lt;code&gt;id&lt;/code&gt; , &lt;code&gt;Class&lt;/code&gt; и &lt;code&gt;SEL&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6782eab9d50f7c071e99f8fc866abd4eb5cd6fa7" translate="yes" xml:space="preserve">
          <source>There is a proposed representation for view numbers that is not backward compatible with the location list format introduced in DWARF 5, that can be enabled with</source>
          <target state="translated">Существует предлагаемое представление для номеров видов,которое не обратно совместимо с форматом списка местоположения,введенным в DWARF 5,которое может быть включено с помощью</target>
        </trans-unit>
        <trans-unit id="923e1f4510dc236d985b28a823797fd535b1836b" translate="yes" xml:space="preserve">
          <source>There is no</source>
          <target state="translated">Нет</target>
        </trans-unit>
        <trans-unit id="29b7356a3e71c6ac7b87a32d1d5d861dca74d15e" translate="yes" xml:space="preserve">
          <source>There is no formal written standard for Objective-C or Objective-C++. The authoritative manual on traditional Objective-C (1.0) is &amp;ldquo;Object-Oriented Programming and the Objective-C Language&amp;rdquo;: &lt;a href=&quot;http://www.gnustep.org/resources/documentation/ObjectivCBook.pdf&quot;&gt;http://www.gnustep.org/resources/documentation/ObjectivCBook.pdf&lt;/a&gt; is the original NeXTstep document.</source>
          <target state="translated">Для Objective-C или Objective-C ++ не существует формального письменного стандарта. Авторитетное руководство по традиционному Objective-C (1.0) называется &amp;laquo;Объектно-ориентированное программирование и язык Objective-C&amp;raquo;: &lt;a href=&quot;http://www.gnustep.org/resources/documentation/ObjectivCBook.pdf&quot;&gt;http://www.gnustep.org/resources/documentation/ObjectivCBook.pdf&lt;/a&gt; - это оригинальный документ NeXTstep.</target>
        </trans-unit>
        <trans-unit id="533538e5f5aef48cf028f3ce488b08d6002276fb" translate="yes" xml:space="preserve">
          <source>There is no guarantee (in either the C or the C++ standard language definitions) that the increments will be evaluated in any particular order. Either increment might happen first. &lt;code&gt;func&lt;/code&gt; might get the arguments &amp;lsquo;</source>
          <target state="translated">Нет гарантии (в определениях стандартного языка C или C ++), что приращения будут оцениваться в каком-либо конкретном порядке. Любое приращение может произойти первым. &lt;code&gt;func&lt;/code&gt; может получить аргументы '</target>
        </trans-unit>
        <trans-unit id="734d8f3426c5c4d551e49ff2012c542f74ef1c08" translate="yes" xml:space="preserve">
          <source>There is no guarantee any transaction ever succeeds, so there always needs to be a valid fallback path.</source>
          <target state="translated">Нет никакой гарантии,что какая-либо транзакция когда-либо будет успешной,поэтому всегда должен быть действительный запасной путь.</target>
        </trans-unit>
        <trans-unit id="df09188c09c71974483614543b07ff3dea71c626" translate="yes" xml:space="preserve">
          <source>There is no support for nesting dialect alternatives.</source>
          <target state="translated">Нет поддержки альтернатив вложению диалектов.</target>
        </trans-unit>
        <trans-unit id="7415b415266f5ddf918da08e3399f543c97fb7d5" translate="yes" xml:space="preserve">
          <source>There is no way to split up the contents of a single header file into multiple implementation files.</source>
          <target state="translated">Нет способа разделить содержимое одного заголовочного файла на несколько реализационных файлов.</target>
        </trans-unit>
        <trans-unit id="b35fa3005d504f47c5b76912e05a2d94970ddd97" translate="yes" xml:space="preserve">
          <source>There is no way within the template to determine which alternative was chosen. However you may be able to wrap your &lt;code&gt;asm&lt;/code&gt; statements with builtins such as &lt;code&gt;__builtin_constant_p&lt;/code&gt; to achieve the desired results.</source>
          <target state="translated">В шаблоне нет возможности определить, какая альтернатива была выбрана. Однако вы можете обернуть свои &lt;code&gt;asm&lt;/code&gt; - операторы встроенными функциями, такими как &lt;code&gt;__builtin_constant_p&lt;/code&gt; , для достижения желаемых результатов.</target>
        </trans-unit>
        <trans-unit id="ae8b54db3c2d81811451aec9ad4c249cf9c17c8b" translate="yes" xml:space="preserve">
          <source>There is some overlap between the purposes of attributes and pragmas (see &lt;a href=&quot;pragmas#Pragmas&quot;&gt;Pragmas Accepted by GCC&lt;/a&gt;). It has been found convenient to use &lt;code&gt;__attribute__&lt;/code&gt; to achieve a natural attachment of attributes to their corresponding declarations, whereas &lt;code&gt;#pragma&lt;/code&gt; is of use for compatibility with other compilers or constructs that do not naturally form part of the grammar.</source>
          <target state="translated">Существует некоторое совпадение между назначением атрибутов и прагм (см. &lt;a href=&quot;pragmas#Pragmas&quot;&gt;Прагмы, принятые GCC&lt;/a&gt; ). Было обнаружено, что удобно использовать &lt;code&gt;__attribute__&lt;/code&gt; для достижения естественного присоединения атрибутов к их соответствующим объявлениям, тогда как &lt;code&gt;#pragma&lt;/code&gt; используется для совместимости с другими компиляторами или конструкциями, которые естественным образом не являются частью грамматики.</target>
        </trans-unit>
        <trans-unit id="07be20761a89905e90146c4650de03345401fe54" translate="yes" xml:space="preserve">
          <source>There may be pitfalls when you use &lt;code&gt;long long&lt;/code&gt; types for function arguments without function prototypes. If a function expects type &lt;code&gt;int&lt;/code&gt; for its argument, and you pass a value of type &lt;code&gt;long long int&lt;/code&gt;, confusion results because the caller and the subroutine disagree about the number of bytes for the argument. Likewise, if the function expects &lt;code&gt;long long int&lt;/code&gt; and you pass &lt;code&gt;int&lt;/code&gt;. The best way to avoid such problems is to use prototypes.</source>
          <target state="translated">При использовании &lt;code&gt;long long&lt;/code&gt; типов для аргументов функции без прототипов функций могут возникнуть подводные камни . Если функция ожидает тип &lt;code&gt;int&lt;/code&gt; в качестве аргумента, а вы передаете значение типа &lt;code&gt;long long int&lt;/code&gt; , возникает путаница, потому что вызывающая сторона и подпрограмма расходятся во мнениях относительно количества байтов для аргумента. Точно так же, если функция ожидает &lt;code&gt;long long int&lt;/code&gt; и вы передаете &lt;code&gt;int&lt;/code&gt; . Лучший способ избежать подобных проблем - использовать прототипы.</target>
        </trans-unit>
        <trans-unit id="4d9628a707838f509cf0a37ebb92916da132e1d6" translate="yes" xml:space="preserve">
          <source>Therefore, the G++ driver automatically adds</source>
          <target state="translated">Поэтому драйвер G++автоматически добавляет</target>
        </trans-unit>
        <trans-unit id="47997e2980ed03d4553af1541dc131cfa6cb91bc" translate="yes" xml:space="preserve">
          <source>Therefore, the expression</source>
          <target state="translated">Поэтому выражение</target>
        </trans-unit>
        <trans-unit id="6ea5dc6096c9bd173073ecde828a55eabd5d76e4" translate="yes" xml:space="preserve">
          <source>These</source>
          <target state="translated">These</target>
        </trans-unit>
        <trans-unit id="322fe3b4715f9524d383adeb084e8533651edeb7" translate="yes" xml:space="preserve">
          <source>These &amp;lsquo;</source>
          <target state="translated">Эти '</target>
        </trans-unit>
        <trans-unit id="cdc6fb4722bc714d5fae1673f7398b196f782701" translate="yes" xml:space="preserve">
          <source>These additional &amp;lsquo;</source>
          <target state="translated">Эти дополнительные</target>
        </trans-unit>
        <trans-unit id="2dea8e42e0ac78d81c1030a34ffa5859fb43e5e8" translate="yes" xml:space="preserve">
          <source>These additional options are available for Microsoft Windows targets:</source>
          <target state="translated">Эти дополнительные опции доступны для целей Microsoft Windows:</target>
        </trans-unit>
        <trans-unit id="429200a04514f92caf3b4499a491ca222d5caed0" translate="yes" xml:space="preserve">
          <source>These additional options are available on System V Release 4 for compatibility with other compilers on those systems:</source>
          <target state="translated">Эти дополнительные опции доступны в System V Release 4 для совместимости с другими компиляторами на этих системах:</target>
        </trans-unit>
        <trans-unit id="aee4beda520b02d216d51ad833fd44f1904ba2f8" translate="yes" xml:space="preserve">
          <source>These are 16-bit address spaces locating data in section &lt;code&gt;.progmem&lt;var&gt;N&lt;/var&gt;.data&lt;/code&gt; where &lt;var&gt;N&lt;/var&gt; refers to address space &lt;code&gt;__flash&lt;var&gt;N&lt;/var&gt;&lt;/code&gt;. The compiler sets the &lt;code&gt;RAMPZ&lt;/code&gt; segment register appropriately before reading data by means of the &lt;code&gt;ELPM&lt;/code&gt; instruction.</source>
          <target state="translated">Эти 16-разрядные адресные пространства установочные данные в секции &lt;code&gt;.progmem&lt;var&gt;N&lt;/var&gt;.data&lt;/code&gt; , где &lt;var&gt;N&lt;/var&gt; ссылается на адресное пространство &lt;code&gt;__flash&lt;var&gt;N&lt;/var&gt;&lt;/code&gt; . Компилятор соответствующим образом устанавливает &lt;code&gt;RAMPZ&lt;/code&gt; сегмента RAMPZ перед чтением данных с помощью инструкции &lt;code&gt;ELPM&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9bc1925e612ca94ca27a8264a7444be5df20595d" translate="yes" xml:space="preserve">
          <source>These are aliases for the corresponding</source>
          <target state="translated">Это псевдонимы для соответствующего</target>
        </trans-unit>
        <trans-unit id="779c6f17661e07ac4152f7dc676778ae7628f8f4" translate="yes" xml:space="preserve">
          <source>These are listed under See &lt;a href=&quot;rs_002f6000-and-powerpc-options#RS_002f6000-and-PowerPC-Options&quot;&gt;RS/6000 and PowerPC Options&lt;/a&gt;.</source>
          <target state="translated">Они перечислены в разделе &amp;laquo; &lt;a href=&quot;rs_002f6000-and-powerpc-options#RS_002f6000-and-PowerPC-Options&quot;&gt;Параметры RS / 6000 и PowerPC&amp;raquo;&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ae931926b0b87957b809699bfe98630faaab5aad" translate="yes" xml:space="preserve">
          <source>These are listed under See &lt;a href=&quot;s_002f390-and-zseries-options#S_002f390-and-zSeries-Options&quot;&gt;S/390 and zSeries Options&lt;/a&gt;.</source>
          <target state="translated">Они перечислены в разделе &amp;laquo; &lt;a href=&quot;s_002f390-and-zseries-options#S_002f390-and-zSeries-Options&quot;&gt;Параметры S / 390 и zSeries&amp;raquo;&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="40acc5623309fbea5623f2aba009e341f97fe7cb" translate="yes" xml:space="preserve">
          <source>These are the &amp;lsquo;</source>
          <target state="translated">Эти '</target>
        </trans-unit>
        <trans-unit id="25a9625ab38cfd983e37ec2df20ad8c1cd341393" translate="yes" xml:space="preserve">
          <source>These are the options defined for the Altera Nios II processor.</source>
          <target state="translated">Это опции,определенные для процессора Altera Nios II.</target>
        </trans-unit>
        <trans-unit id="ddfdc15ea502fdc771fd53ee7ee413d91e5a491a" translate="yes" xml:space="preserve">
          <source>These are the supported qualifiers:</source>
          <target state="translated">Это поддерживаемые квалификаторы:</target>
        </trans-unit>
        <trans-unit id="3f0f74a8692c7935b66e165ba67cb1a501ff0206" translate="yes" xml:space="preserve">
          <source>These attributes are the same as the MSP430 function attributes of the same name (see &lt;a href=&quot;msp430-function-attributes#MSP430-Function-Attributes&quot;&gt;MSP430 Function Attributes&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea04fd9aefe63e6f009323195856f23e96723b58" translate="yes" xml:space="preserve">
          <source>These attributes are the same as the MSP430 function attributes of the same name (see &lt;a href=&quot;msp430-function-attributes#MSP430-Function-Attributes&quot;&gt;MSP430 Function Attributes&lt;/a&gt;). These attributes can be applied to both functions and variables.</source>
          <target state="translated">Эти атрибуты аналогичны одноименным функциональным атрибутам &lt;a href=&quot;msp430-function-attributes#MSP430-Function-Attributes&quot;&gt;MSP430&lt;/a&gt; (см. Функциональные атрибуты MSP430 ). Эти атрибуты могут применяться как к функциям, так и к переменным.</target>
        </trans-unit>
        <trans-unit id="bc9f0c12140351e3fedd51dae4c1164e0be835e5" translate="yes" xml:space="preserve">
          <source>These attributes indicate that the specified function is an interrupt handler. The compiler generates function entry and exit sequences suitable for use in an interrupt handler when this attribute is present.</source>
          <target state="translated">Эти атрибуты указывают на то,что указанная функция является обработчиком прерываний.Компилятор генерирует последовательности входа и выхода функции,подходящие для использования в обработчике прерывания при наличии данного атрибута.</target>
        </trans-unit>
        <trans-unit id="90cae17a8377f793b8674b8db0decc44a0b2b0db" translate="yes" xml:space="preserve">
          <source>These attributes indicate that the specified function is an interrupt handler. Use the &lt;code&gt;fast_interrupt&lt;/code&gt; attribute to indicate handlers used in low-latency interrupt mode, and &lt;code&gt;interrupt_handler&lt;/code&gt; for interrupts that do not use low-latency handlers. In both cases, GCC emits appropriate prologue code and generates a return from the handler using &lt;code&gt;rtid&lt;/code&gt; instead of &lt;code&gt;rtsd&lt;/code&gt;.</source>
          <target state="translated">Эти атрибуты указывают, что указанная функция является обработчиком прерывания. Используйте атрибут &lt;code&gt;fast_interrupt&lt;/code&gt; , чтобы указать обработчики, используемые в режиме прерывания с малой задержкой, и &lt;code&gt;interrupt_handler&lt;/code&gt; для прерываний, которые не используют обработчики с низкой задержкой. В обоих случаях GCC испускает соответствующий код пролога и генерирует возврат от обработчика, используя &lt;code&gt;rtid&lt;/code&gt; вместо &lt;code&gt;rtsd&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0f83b1fb8a50c976a446dd169ccf0caf9284a311" translate="yes" xml:space="preserve">
          <source>These attributes override the default chosen by the</source>
          <target state="translated">Эти атрибуты переопределяют атрибуты по умолчанию,выбранные параметром</target>
        </trans-unit>
        <trans-unit id="af47925da5d7dad5e220bfdf28a73cd1e09ade04" translate="yes" xml:space="preserve">
          <source>These attributes specify how a particular function is called on MIPS. The attributes override the</source>
          <target state="translated">Эти атрибуты определяют,как на MIPS вызывается конкретная функция.Атрибуты переопределяют</target>
        </trans-unit>
        <trans-unit id="c245dc24a2c3a655d76f63a05d461d62dfaa1098" translate="yes" xml:space="preserve">
          <source>These attributes specify how a particular function is called. These attributes override the</source>
          <target state="translated">Эти атрибуты определяют,как вызывается конкретная функция.Эти атрибуты отменяют</target>
        </trans-unit>
        <trans-unit id="3aa2c83f10183032d2c290e0fbfc5503038ef4f2" translate="yes" xml:space="preserve">
          <source>These built-in functions are available for calling kernel helpers, and they are available depending on the kernel version selected as the CPU.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d2db2e0a6cd3c160ce892077b566038f69a5d12" translate="yes" xml:space="preserve">
          <source>These built-in functions are available for the AArch64 family of processors.</source>
          <target state="translated">Эти встроенные функции доступны для процессоров семейства AArch64.</target>
        </trans-unit>
        <trans-unit id="99ee134b7e3302b89897afcdd306492cac3af896" translate="yes" xml:space="preserve">
          <source>These built-in functions are available for the ARM family of processors when the</source>
          <target state="translated">Эти встроенные функции доступны для процессоров семейства ARM,когда</target>
        </trans-unit>
        <trans-unit id="a2c021905865fa6d163412cd97d22f339e716b63" translate="yes" xml:space="preserve">
          <source>These built-in functions are available for the ARM family of processors with floating-point unit.</source>
          <target state="translated">Эти встроенные функции доступны для процессоров семейства ARM с плавающей запятой.</target>
        </trans-unit>
        <trans-unit id="48306035fd811f8d35a44f11213546ba486a0570" translate="yes" xml:space="preserve">
          <source>These built-in functions are available for the Alpha family of processors, depending on the command-line switches used.</source>
          <target state="translated">Эти встроенные функции доступны для процессоров семейства Alpha,в зависимости от используемых переключателей командной строки.</target>
        </trans-unit>
        <trans-unit id="7b3ba21ab5439a452d301344eaf50af645d462ac" translate="yes" xml:space="preserve">
          <source>These built-in functions are available for the Altera Nios II family of processors.</source>
          <target state="translated">Эти встроенные функции доступны для процессоров семейства Altera Nios II.</target>
        </trans-unit>
        <trans-unit id="89f6765d03c89956e564760cefe25b8258f2acc4" translate="yes" xml:space="preserve">
          <source>These built-in functions are available for the NDS32 target:</source>
          <target state="translated">Эти встроенные функции доступны для цели NDS32:</target>
        </trans-unit>
        <trans-unit id="2fccae182b2f224cc802c582d293665235932f6e" translate="yes" xml:space="preserve">
          <source>These built-in functions are available for the x86-32 and x86-64 family of computers, depending on the command-line switches used.</source>
          <target state="translated">Эти встроенные функции доступны для компьютеров семейства x86-32 и x86-64 в зависимости от используемых переключателей командной строки.</target>
        </trans-unit>
        <trans-unit id="74fa1603a77cd22b8b03844382316cb7fce3f487" translate="yes" xml:space="preserve">
          <source>These built-in functions are similar to &lt;code&gt;__builtin_add_overflow&lt;/code&gt;, &lt;code&gt;__builtin_sub_overflow&lt;/code&gt;, or &lt;code&gt;__builtin_mul_overflow&lt;/code&gt;, except that they don&amp;rsquo;t store the result of the arithmetic operation anywhere and the last argument is not a pointer, but some expression with integral type other than enumerated or boolean type.</source>
          <target state="translated">Эти встроенные функции похожи на &lt;code&gt;__builtin_add_overflow&lt;/code&gt; , &lt;code&gt;__builtin_sub_overflow&lt;/code&gt; или &lt;code&gt;__builtin_mul_overflow&lt;/code&gt; , за исключением того, что они нигде не хранят результат арифметической операции, а последний аргумент является не указателем, а некоторым выражением с целочисленным типом, отличным от перечислимого или логического типа. ,</target>
        </trans-unit>
        <trans-unit id="49cc0a5435c96c360dc8a007e08ab18d83b226a2" translate="yes" xml:space="preserve">
          <source>These built-in functions are similar to the add overflow checking built-in functions above, except they perform multiplication, instead of addition.</source>
          <target state="translated">Эти встроенные функции похожи на встроенную проверку переполнения,описанную выше,за исключением того,что они выполняют умножение,а не сложение.</target>
        </trans-unit>
        <trans-unit id="60566210b0678cb1c3591a4a16d4062b4b5565ab" translate="yes" xml:space="preserve">
          <source>These built-in functions are similar to the add overflow checking built-in functions above, except they perform subtraction, subtract the second argument from the first one, instead of addition.</source>
          <target state="translated">Эти встроенные функции похожи на встроенную проверку переполнения,описанную выше,за исключением того,что они выполняют вычитание,вычитание второго аргумента из первого,а не сложение.</target>
        </trans-unit>
        <trans-unit id="f2854f4ac5cfaad00730f8aa21e163c5b047dff2" translate="yes" xml:space="preserve">
          <source>These built-in functions map to the respective machine instruction, i.e. &lt;code&gt;nop&lt;/code&gt;, &lt;code&gt;sei&lt;/code&gt;, &lt;code&gt;cli&lt;/code&gt;, &lt;code&gt;sleep&lt;/code&gt;, &lt;code&gt;wdr&lt;/code&gt;, &lt;code&gt;swap&lt;/code&gt;, &lt;code&gt;fmul&lt;/code&gt;, &lt;code&gt;fmuls&lt;/code&gt; resp. &lt;code&gt;fmulsu&lt;/code&gt;. The three &lt;code&gt;fmul*&lt;/code&gt; built-ins are implemented as library call if no hardware multiplier is available.</source>
          <target state="translated">Эти встроенные функции отображаются на соответствующие машинные инструкции, т.е. &lt;code&gt;nop&lt;/code&gt; , &lt;code&gt;sei&lt;/code&gt; , &lt;code&gt;cli&lt;/code&gt; , &lt;code&gt;sleep&lt;/code&gt; , &lt;code&gt;wdr&lt;/code&gt; , &lt;code&gt;swap&lt;/code&gt; , &lt;code&gt;fmul&lt;/code&gt; , &lt;code&gt;fmuls&lt;/code&gt; соответственно. &lt;code&gt;fmulsu&lt;/code&gt; . Три встроенных модуля &lt;code&gt;fmul*&lt;/code&gt; реализуются как вызов библиотеки, если аппаратный множитель недоступен.</target>
        </trans-unit>
        <trans-unit id="b498367f60152015d5067b4b4501b71daee8b167" translate="yes" xml:space="preserve">
          <source>These built-in functions perform an atomic compare and swap. That is, if the current value of &lt;code&gt;*&lt;var&gt;ptr&lt;/var&gt;&lt;/code&gt; is &lt;var&gt;oldval&lt;/var&gt;, then write &lt;var&gt;newval&lt;/var&gt; into &lt;code&gt;*&lt;var&gt;ptr&lt;/var&gt;&lt;/code&gt;.</source>
          <target state="translated">Эти встроенные функции выполняют атомарное сравнение и замену. То есть, если текущее значение &lt;code&gt;*&lt;var&gt;ptr&lt;/var&gt;&lt;/code&gt; - &lt;var&gt;oldval&lt;/var&gt; , то записать &lt;var&gt;newval&lt;/var&gt; в &lt;code&gt;*&lt;var&gt;ptr&lt;/var&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="457d48795ac8a304362adc0940095ddd5561f409" translate="yes" xml:space="preserve">
          <source>These built-in functions perform the operation suggested by the name, and return the new value. That is, operations on integer operands have the following semantics. Operations on pointer operands are performed as if the operand&amp;rsquo;s type were &lt;code&gt;uintptr_t&lt;/code&gt;.</source>
          <target state="translated">Эти встроенные функции выполняют операцию, предложенную именем, и возвращают новое значение. То есть операции с целочисленными операндами имеют следующую семантику. Операции с операндами-указателями выполняются так, как если бы тип операнда был &lt;code&gt;uintptr_t&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c4af2a3302ed8abb6fe6e394796ceea4bd21df1d" translate="yes" xml:space="preserve">
          <source>These built-in functions perform the operation suggested by the name, and return the result of the operation. Operations on pointer arguments are performed as if the operands were of the &lt;code&gt;uintptr_t&lt;/code&gt; type. That is, they are not scaled by the size of the type to which the pointer points.</source>
          <target state="translated">Эти встроенные функции выполняют операцию, предложенную по имени, и возвращают результат операции. Операции с аргументами указателя выполняются так, как если бы операнды имели тип &lt;code&gt;uintptr_t&lt;/code&gt; . То есть они не масштабируются по размеру типа, на который указывает указатель.</target>
        </trans-unit>
        <trans-unit id="79ddce6ba857523eabbfd2cdfa6462c8733df6a0" translate="yes" xml:space="preserve">
          <source>These built-in functions perform the operation suggested by the name, and return the value that had previously been in &lt;code&gt;*&lt;var&gt;ptr&lt;/var&gt;&lt;/code&gt;. Operations on pointer arguments are performed as if the operands were of the &lt;code&gt;uintptr_t&lt;/code&gt; type. That is, they are not scaled by the size of the type to which the pointer points.</source>
          <target state="translated">Эти встроенные функции выполняют операцию, предложенную именем, и возвращают значение, которое ранее было в &lt;code&gt;*&lt;var&gt;ptr&lt;/var&gt;&lt;/code&gt; . Операции с аргументами указателя выполняются так, как если бы операнды имели тип &lt;code&gt;uintptr_t&lt;/code&gt; . То есть они не масштабируются по размеру типа, на который указывает указатель.</target>
        </trans-unit>
        <trans-unit id="9d9da03d00f1fd8e4ece7f58ac8080d895ff5310" translate="yes" xml:space="preserve">
          <source>These built-in functions perform the operation suggested by the name, and returns the value that had previously been in memory. That is, operations on integer operands have the following semantics. Operations on pointer arguments are performed as if the operands were of the &lt;code&gt;uintptr_t&lt;/code&gt; type. That is, they are not scaled by the size of the type to which the pointer points.</source>
          <target state="translated">Эти встроенные функции выполняют операцию, предложенную именем, и возвращают значение, которое ранее было в памяти. То есть операции с целочисленными операндами имеют следующую семантику. Операции с аргументами указателя выполняются так, как если бы операнды имели тип &lt;code&gt;uintptr_t&lt;/code&gt; . То есть они не масштабируются по размеру типа, на который указывает указатель.</target>
        </trans-unit>
        <trans-unit id="55de8240dbd3fc7547da89964b220023f7b63ac6" translate="yes" xml:space="preserve">
          <source>These built-in functions promote the first two operands into infinite precision signed type and perform addition on those promoted operands. The result is then cast to the type the third pointer argument points to and stored there. If the stored result is equal to the infinite precision result, the built-in functions return &lt;code&gt;false&lt;/code&gt;, otherwise they return &lt;code&gt;true&lt;/code&gt;. As the addition is performed in infinite signed precision, these built-in functions have fully defined behavior for all argument values.</source>
          <target state="translated">Эти встроенные функции переводят первые два операнда в знаковый тип бесконечной точности и выполняют сложение этих продвинутых операндов. Затем результат приводится к типу, на который указывает третий аргумент-указатель, и сохраняется там. Если сохраненный результат равен результату с бесконечной точностью, встроенные функции возвращают &lt;code&gt;false&lt;/code&gt; , в противном случае они возвращают &lt;code&gt;true&lt;/code&gt; . Поскольку сложение выполняется с бесконечной точностью со знаком, эти встроенные функции имеют полностью определенное поведение для всех значений аргументов.</target>
        </trans-unit>
        <trans-unit id="889254cac4522dec29d7418673ff86e35bc69fa4" translate="yes" xml:space="preserve">
          <source>These command-line options are defined for PRU target:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="272a12ae7cc5710c521265d94a65c2d1952b524a" translate="yes" xml:space="preserve">
          <source>These command-line options are defined for RISC-V targets:</source>
          <target state="translated">Эти опции командной строки определены для целей RISC-V:</target>
        </trans-unit>
        <trans-unit id="cde559b30a769153d7e8ca70dcc17ecf58e436b4" translate="yes" xml:space="preserve">
          <source>These command-line options are defined for RX targets:</source>
          <target state="translated">Эти опции командной строки определены для целей RX:</target>
        </trans-unit>
        <trans-unit id="51a802ea6adfbbd5a44e165efe9f9442f0fe2c45" translate="yes" xml:space="preserve">
          <source>These considerations mean that it is probably a bad idea to use statement expressions of this form in header files that are designed to work with C++. (Note that some versions of the GNU C Library contained header files using statement expressions that lead to precisely this bug.)</source>
          <target state="translated">Эти соображения означают,что использование выражений этой формы в заголовочных файлах,предназначенных для работы с Си++,наверное,плохая идея.(Обратите внимание,что некоторые версии библиотеки Си GNU содержали заголовочные файлы с использованием выражений операторов,которые приводили именно к этой ошибке).</target>
        </trans-unit>
        <trans-unit id="8bb762532560d78d44fe7f3daaea45c8583b0854" translate="yes" xml:space="preserve">
          <source>These constraints are represented as multiple alternatives. An alternative can be described by a series of letters for each operand. The overall constraint for an operand is made from the letters for this operand from the first alternative, a comma, the letters for this operand from the second alternative, a comma, and so on until the last alternative. All operands for a single instruction must have the same number of alternatives.</source>
          <target state="translated">Эти ограничения представлены в виде нескольких альтернатив.Альтернатива может быть описана серией букв для каждого операнда.Общее ограничение для операнда состоит из букв для этого операнда из первой альтернативы,запятой,букв для этого операнда из второй альтернативы,запятой и т.д.до последней альтернативы.Все операнды для одной команды должны иметь одинаковое количество альтернатив.</target>
        </trans-unit>
        <trans-unit id="38cef76099a34e5010638d4a8b6cdd6e8c967f30" translate="yes" xml:space="preserve">
          <source>These dumps are defined but always produce empty files.</source>
          <target state="translated">Эти дампы определены,но всегда создают пустые файлы.</target>
        </trans-unit>
        <trans-unit id="dee9b2ccc9b3a342087894f7b0b9e01286328c92" translate="yes" xml:space="preserve">
          <source>These environment variables control the way that GCC uses localization information which allows GCC to work with different national conventions. GCC inspects the locale categories &lt;code&gt;LC_CTYPE&lt;/code&gt; and &lt;code&gt;LC_MESSAGES&lt;/code&gt; if it has been configured to do so. These locale categories can be set to any value supported by your installation. A typical value is &amp;lsquo;</source>
          <target state="translated">Эти переменные среды управляют тем, как GCC использует информацию о локализации, что позволяет GCC работать с различными национальными соглашениями. GCC проверяет категории локали &lt;code&gt;LC_CTYPE&lt;/code&gt; и &lt;code&gt;LC_MESSAGES&lt;/code&gt; , если он настроен для этого. Для этих категорий локали можно задать любое значение, поддерживаемое вашей установкой. Типичное значение - '</target>
        </trans-unit>
        <trans-unit id="a489f50971ce1280d886918f48a3bb50c7a159d8" translate="yes" xml:space="preserve">
          <source>These extensions are also available as built-in functions: see &lt;a href=&quot;x86-built_002din-functions#x86-Built_002din-Functions&quot;&gt;x86 Built-in Functions&lt;/a&gt;, for details of the functions enabled and disabled by these switches.</source>
          <target state="translated">Эти расширения также доступны как встроенные функции: см. &amp;laquo; &lt;a href=&quot;x86-built_002din-functions#x86-Built_002din-Functions&quot;&gt;Встроенные&lt;/a&gt; функции x86&amp;raquo; , где подробно описаны функции, включаемые и отключаемые этими переключателями.</target>
        </trans-unit>
        <trans-unit id="8d27c12c180a98e05723ed39f8b22c27ed9edb1c" translate="yes" xml:space="preserve">
          <source>These extensions are available in C and Objective-C. Most of them are also available in C++. See &lt;a href=&quot;c_002b_002b-extensions#C_002b_002b-Extensions&quot;&gt;Extensions to the C++ Language&lt;/a&gt;, for extensions that apply &lt;em&gt;only&lt;/em&gt; to C++.</source>
          <target state="translated">Эти расширения доступны в C и Objective-C. Большинство из них также доступно на C ++. См. &lt;a href=&quot;c_002b_002b-extensions#C_002b_002b-Extensions&quot;&gt;Расширения языка C ++&lt;/a&gt; , где описаны расширения, применимые &lt;em&gt;только&lt;/em&gt; к C ++.</target>
        </trans-unit>
        <trans-unit id="543b06dcdf13923e1595eba210fefb04ac8d69e6" translate="yes" xml:space="preserve">
          <source>These function attributes are available for H8/300 targets:</source>
          <target state="translated">Эти атрибуты функции доступны для целей H8/300:</target>
        </trans-unit>
        <trans-unit id="bfd06787a8c3016d0f2f433589a9910af31152c9" translate="yes" xml:space="preserve">
          <source>These function attributes are supported by the AMD GCN back end:</source>
          <target state="translated">Эти атрибуты функции поддерживаются задней частью AMD GCN:</target>
        </trans-unit>
        <trans-unit id="31d4d22755862f6885158e789fb6bd235507e320" translate="yes" xml:space="preserve">
          <source>These function attributes are supported by the ARC back end:</source>
          <target state="translated">Эти атрибуты функции поддерживаются задней частью ARC:</target>
        </trans-unit>
        <trans-unit id="55c618a070b2ba6452534765be65dfbcbd06c924" translate="yes" xml:space="preserve">
          <source>These function attributes are supported by the AVR back end:</source>
          <target state="translated">Эти атрибуты функции поддерживаются задней частью AVR:</target>
        </trans-unit>
        <trans-unit id="4000ac271516da07336a51da8c25e0b8f6d448c0" translate="yes" xml:space="preserve">
          <source>These function attributes are supported by the Blackfin back end:</source>
          <target state="translated">Эти атрибуты функции поддерживаются задней частью Blackfin:</target>
        </trans-unit>
        <trans-unit id="4afa11f7ee30e42598bbee2d62763ae6434a6f20" translate="yes" xml:space="preserve">
          <source>These function attributes are supported by the C-SKY back end:</source>
          <target state="translated">Эти атрибуты функции поддерживаются задней частью C-SKY:</target>
        </trans-unit>
        <trans-unit id="0b39cd5a4dc8327b896c51c9d022f5933b3f9958" translate="yes" xml:space="preserve">
          <source>These function attributes are supported by the CR16 back end:</source>
          <target state="translated">Эти атрибуты функции поддерживаются задней частью CR16:</target>
        </trans-unit>
        <trans-unit id="eec1909818ce8c44d18b66d9f611b39270c8c989" translate="yes" xml:space="preserve">
          <source>These function attributes are supported by the Epiphany back end:</source>
          <target state="translated">Эти атрибуты функции поддерживаются задней частью Epiphany:</target>
        </trans-unit>
        <trans-unit id="ff8d3405ae11a67438cd3ed6cb92d4bcf36611d0" translate="yes" xml:space="preserve">
          <source>These function attributes are supported by the M32C back end:</source>
          <target state="translated">Эти атрибуты функции поддерживаются задней частью M32C:</target>
        </trans-unit>
        <trans-unit id="d47de44c955eeba7615b17fd0bd7f27454a04ff3" translate="yes" xml:space="preserve">
          <source>These function attributes are supported by the M32R/D back end:</source>
          <target state="translated">Эти атрибуты функции поддерживаются задней частью M32R/D:</target>
        </trans-unit>
        <trans-unit id="ed7b01cf6c9218a3fa99b80d586881bd94ea12ed" translate="yes" xml:space="preserve">
          <source>These function attributes are supported by the MCORE back end:</source>
          <target state="translated">Эти атрибуты функции поддерживаются задней частью MCORE:</target>
        </trans-unit>
        <trans-unit id="226e80259699476cba4da72f29c0d2be0439d85d" translate="yes" xml:space="preserve">
          <source>These function attributes are supported by the MIPS back end:</source>
          <target state="translated">Эти атрибуты функции поддерживаются бэк-концом MIPS:</target>
        </trans-unit>
        <trans-unit id="7edfb198d558bea136b268d07a4ee17096f4b111" translate="yes" xml:space="preserve">
          <source>These function attributes are supported by the MSP430 back end:</source>
          <target state="translated">Эти атрибуты функции поддерживаются задней частью MSP430:</target>
        </trans-unit>
        <trans-unit id="7afb37f2786a0500cde5b0e77a1405ec0aa689e9" translate="yes" xml:space="preserve">
          <source>These function attributes are supported by the MeP back end:</source>
          <target state="translated">Эти атрибуты функции поддерживаются обратной стороной MeP:</target>
        </trans-unit>
        <trans-unit id="823340689a226c514215ae7cf6199d5c7033ae04" translate="yes" xml:space="preserve">
          <source>These function attributes are supported by the NDS32 back end:</source>
          <target state="translated">Эти атрибуты функции поддерживаются задней частью NDS32:</target>
        </trans-unit>
        <trans-unit id="7264e105fd00f62eb30200660903a8276158683f" translate="yes" xml:space="preserve">
          <source>These function attributes are supported by the Nios II back end:</source>
          <target state="translated">Эти атрибуты функции поддерживаются задней частью Nios II:</target>
        </trans-unit>
        <trans-unit id="d367738aef5894acaadafa553c801d1b43d3e9d3" translate="yes" xml:space="preserve">
          <source>These function attributes are supported by the Nvidia PTX back end:</source>
          <target state="translated">Эти атрибуты функции поддерживаются задней частью Nvidia PTX:</target>
        </trans-unit>
        <trans-unit id="8128fd2ec01bae5154b0679102e4367fb3f53fc5" translate="yes" xml:space="preserve">
          <source>These function attributes are supported by the PowerPC back end:</source>
          <target state="translated">Эти атрибуты функции поддерживаются задней частью PowerPC:</target>
        </trans-unit>
        <trans-unit id="923f5bd26a54897b08d5acdad9b09a52e975ce30" translate="yes" xml:space="preserve">
          <source>These function attributes are supported by the RISC-V back end:</source>
          <target state="translated">Эти атрибуты функции поддерживаются задней частью RISC-V:</target>
        </trans-unit>
        <trans-unit id="47e5203aed5d0b18481b945b5507d949e4d7c31f" translate="yes" xml:space="preserve">
          <source>These function attributes are supported by the RL78 back end:</source>
          <target state="translated">Эти атрибуты функции поддерживаются обратной стороной RL78:</target>
        </trans-unit>
        <trans-unit id="8f4c53e48bbca37bc1541d4a60d57426dc8a00e7" translate="yes" xml:space="preserve">
          <source>These function attributes are supported by the RX back end:</source>
          <target state="translated">Эти атрибуты функции поддерживаются задней частью RX:</target>
        </trans-unit>
        <trans-unit id="d7ce9850ed4dcd80e265a07962ae081b178c8abb" translate="yes" xml:space="preserve">
          <source>These function attributes are supported by the SPU back end:</source>
          <target state="translated">Эти атрибуты функции поддерживаются задней частью SPU:</target>
        </trans-unit>
        <trans-unit id="c4ade06aab9acf44e5ce57399ee7881faa6de0a6" translate="yes" xml:space="preserve">
          <source>These function attributes are supported by the Visium back end:</source>
          <target state="translated">Эти атрибуты функции поддерживаются задней частью Visium:</target>
        </trans-unit>
        <trans-unit id="ae2ef0b2bdfca9b1c67e94cbe7badc64e01b063f" translate="yes" xml:space="preserve">
          <source>These function attributes are supported by the Xstormy16 back end:</source>
          <target state="translated">Эти атрибуты функции поддерживаются задней частью Xstormy16:</target>
        </trans-unit>
        <trans-unit id="e7b7833e42af4f0fe80d613be09a87490ccd7b43" translate="yes" xml:space="preserve">
          <source>These function attributes are supported by the m68k back end:</source>
          <target state="translated">Эти атрибуты функции поддерживаются задней частью m68k:</target>
        </trans-unit>
        <trans-unit id="fe7ac1f444547a0c0a07d6dfab0c75fe5199553c" translate="yes" xml:space="preserve">
          <source>These function attributes are supported by the x86 back end:</source>
          <target state="translated">Эти атрибуты функции поддерживаются задней частью x86:</target>
        </trans-unit>
        <trans-unit id="5189be0ccd445175d7b77e932fb4808ff6d615fa" translate="yes" xml:space="preserve">
          <source>These function attributes are supported for ARM targets:</source>
          <target state="translated">Эти атрибуты функции поддерживаются для целей ARM:</target>
        </trans-unit>
        <trans-unit id="bbd6ef1a2308a92983d4f92536fdde005890291f" translate="yes" xml:space="preserve">
          <source>These function attributes are supported on IA-64 targets:</source>
          <target state="translated">Эти атрибуты функции поддерживаются на объектах IA-64:</target>
        </trans-unit>
        <trans-unit id="f64b227810fa6c9b50983f03140d568f7d9fed74" translate="yes" xml:space="preserve">
          <source>These function attributes are supported on MicroBlaze targets:</source>
          <target state="translated">Эти атрибуты функции поддерживаются на мишенях MicroBlaze:</target>
        </trans-unit>
        <trans-unit id="9585f4effc5a2f8970b020be9771782ca105dbb1" translate="yes" xml:space="preserve">
          <source>These function attributes are supported on the S/390:</source>
          <target state="translated">Эти атрибуты функции поддерживаются на S/390:</target>
        </trans-unit>
        <trans-unit id="18888f95dfd62b9fe90e4d6af61fe2ecdcb6ad4f" translate="yes" xml:space="preserve">
          <source>These function attributes are supported on the SH family of processors:</source>
          <target state="translated">Эти атрибуты функции поддерживаются в процессорах семейства SH:</target>
        </trans-unit>
        <trans-unit id="98428d8e4eba9c792163f590881b9a318e73170e" translate="yes" xml:space="preserve">
          <source>These functions are implemented in terms of the &amp;lsquo;</source>
          <target state="translated">Эти функции реализованы в виде '</target>
        </trans-unit>
        <trans-unit id="8d57779f821090bd738e90d984c08a5bc5b3499b" translate="yes" xml:space="preserve">
          <source>These functions are intended to replace the legacy &amp;lsquo;</source>
          <target state="translated">Эти функции предназначены для замены устаревшего '</target>
        </trans-unit>
        <trans-unit id="ad90f9504c295e2f97ffc9946ebca4f6b5d5ccf1" translate="yes" xml:space="preserve">
          <source>These functions compare &lt;var&gt;a&lt;/var&gt; and &lt;var&gt;b&lt;/var&gt; using &lt;code&gt;c.&lt;var&gt;cond&lt;/var&gt;.ps&lt;/code&gt; and return either the upper or lower half of the result. For example:</source>
          <target state="translated">Эти функции сравнивают &lt;var&gt;a&lt;/var&gt; и &lt;var&gt;b&lt;/var&gt; с помощью &lt;code&gt;c.&lt;var&gt;cond&lt;/var&gt;.ps&lt;/code&gt; и возвращает либо верхнюю, либо нижнюю половину результата. Например:</target>
        </trans-unit>
        <trans-unit id="03c7a748fe1ee1ae1b17cfc9b1186d6994642291" translate="yes" xml:space="preserve">
          <source>These functions compare &lt;var&gt;a&lt;/var&gt; and &lt;var&gt;b&lt;/var&gt; using &lt;code&gt;c.&lt;var&gt;cond&lt;/var&gt;.ps&lt;/code&gt; or &lt;code&gt;cabs.&lt;var&gt;cond&lt;/var&gt;.ps&lt;/code&gt;. The &lt;code&gt;any&lt;/code&gt; forms return &lt;code&gt;true&lt;/code&gt; if either result is &lt;code&gt;true&lt;/code&gt; and the &lt;code&gt;all&lt;/code&gt; forms return &lt;code&gt;true&lt;/code&gt; if both results are &lt;code&gt;true&lt;/code&gt;. For example:</source>
          <target state="translated">Эти функции сравнивают &lt;var&gt;a&lt;/var&gt; и &lt;var&gt;b&lt;/var&gt; с помощью &lt;code&gt;c.&lt;var&gt;cond&lt;/var&gt;.ps&lt;/code&gt; или &lt;code&gt;cabs.&lt;var&gt;cond&lt;/var&gt;.ps&lt;/code&gt; . В &lt;code&gt;any&lt;/code&gt; формах возврата &lt;code&gt;true&lt;/code&gt; , если либо результат &lt;code&gt;true&lt;/code&gt; , и &lt;code&gt;all&lt;/code&gt; формы возвращают &lt;code&gt;true&lt;/code&gt; , если оба результата &lt;code&gt;true&lt;/code&gt; . Например:</target>
        </trans-unit>
        <trans-unit id="c195ff99103a21f524d4637aac5069ea8a395ea9" translate="yes" xml:space="preserve">
          <source>These functions compare &lt;var&gt;a&lt;/var&gt; and &lt;var&gt;b&lt;/var&gt; using &lt;code&gt;cabs.&lt;var&gt;cond&lt;/var&gt;.ps&lt;/code&gt; and return either the upper or lower half of the result. For example:</source>
          <target state="translated">Эти функции сравнивают &lt;var&gt;a&lt;/var&gt; и &lt;var&gt;b&lt;/var&gt; с помощью &lt;code&gt;cabs.&lt;var&gt;cond&lt;/var&gt;.ps&lt;/code&gt; и возвращает либо верхнюю, либо нижнюю половину результата. Например:</target>
        </trans-unit>
        <trans-unit id="46c037085992dbec65501906e5e93cf40d6de82a" translate="yes" xml:space="preserve">
          <source>These functions compare &lt;var&gt;a&lt;/var&gt; and &lt;var&gt;b&lt;/var&gt; using &lt;code&gt;cabs.&lt;var&gt;cond&lt;/var&gt;.s&lt;/code&gt; or &lt;code&gt;cabs.&lt;var&gt;cond&lt;/var&gt;.d&lt;/code&gt; and return the result as a boolean value. For example:</source>
          <target state="translated">Эти функции сравнивают &lt;var&gt;a&lt;/var&gt; и &lt;var&gt;b&lt;/var&gt; с помощью &lt;code&gt;cabs.&lt;var&gt;cond&lt;/var&gt;.s&lt;/code&gt; или &lt;code&gt;cabs.&lt;var&gt;cond&lt;/var&gt;.d&lt;/code&gt; и вернуть результат как логическое значение. Например:</target>
        </trans-unit>
        <trans-unit id="e664732594a1533360445b60577eaf62e517fa5e" translate="yes" xml:space="preserve">
          <source>These functions may be used to get information about the callers of a function.</source>
          <target state="translated">Эти функции могут быть использованы для получения информации об абонентах функции.</target>
        </trans-unit>
        <trans-unit id="1dfc3d7d206adff68ce67f88a57319430a6ab850" translate="yes" xml:space="preserve">
          <source>These functions use &lt;code&gt;c.&lt;var&gt;cond&lt;/var&gt;.ps&lt;/code&gt; or &lt;code&gt;cabs.&lt;var&gt;cond&lt;/var&gt;.ps&lt;/code&gt; to compare &lt;var&gt;a&lt;/var&gt; with &lt;var&gt;b&lt;/var&gt; and to compare &lt;var&gt;c&lt;/var&gt; with &lt;var&gt;d&lt;/var&gt;. The &lt;code&gt;any&lt;/code&gt; forms return &lt;code&gt;true&lt;/code&gt; if any of the four results are &lt;code&gt;true&lt;/code&gt; and the &lt;code&gt;all&lt;/code&gt; forms return &lt;code&gt;true&lt;/code&gt; if all four results are &lt;code&gt;true&lt;/code&gt;. For example:</source>
          <target state="translated">Эти функции используют &lt;code&gt;c.&lt;var&gt;cond&lt;/var&gt;.ps&lt;/code&gt; или &lt;code&gt;cabs.&lt;var&gt;cond&lt;/var&gt;.ps&lt;/code&gt; чтобы сравнить &lt;var&gt;a&lt;/var&gt; с &lt;var&gt;b&lt;/var&gt; и сравнить &lt;var&gt;c&lt;/var&gt; с &lt;var&gt;d&lt;/var&gt; . В &lt;code&gt;any&lt;/code&gt; формах возврата &lt;code&gt;true&lt;/code&gt; , если какая - либо из четырех результатов являются &lt;code&gt;true&lt;/code&gt; , и &lt;code&gt;all&lt;/code&gt; формы возвращают &lt;code&gt;true&lt;/code&gt; , если все четыре результата является &lt;code&gt;true&lt;/code&gt; . Например:</target>
        </trans-unit>
        <trans-unit id="93f3cb76d903b1b5ffde931b05d3fa75fc2f5327" translate="yes" xml:space="preserve">
          <source>These hardware transactional memory intrinsics for x86 allow you to use memory transactions with RTM (Restricted Transactional Memory). This support is enabled with the</source>
          <target state="translated">Эти аппаратные транзакционные памяти,присущие x86,позволяют использовать транзакции с МРВ (Ограниченная транзакционная память).Эта поддержка включается при помощи</target>
        </trans-unit>
        <trans-unit id="3b8547b042f5482e49423b8a94ba89797760897f" translate="yes" xml:space="preserve">
          <source>These identifiers are variables, not preprocessor macros, and may not be used to initialize &lt;code&gt;char&lt;/code&gt; arrays or be concatenated with string literals.</source>
          <target state="translated">Эти идентификаторы являются переменными, а не макросами препроцессора, и их нельзя использовать для инициализации массивов &lt;code&gt;char&lt;/code&gt; или объединять со строковыми литералами.</target>
        </trans-unit>
        <trans-unit id="d7ada7b6e3845c0a5e68e19752115e91ad7e714e" translate="yes" xml:space="preserve">
          <source>These issues were corrected in</source>
          <target state="translated">Эти вопросы были исправлены</target>
        </trans-unit>
        <trans-unit id="9b9701e15c9d94aa04294acbc1a1a03ddc6872e2" translate="yes" xml:space="preserve">
          <source>These machine-independent options control the interface conventions used in code generation.</source>
          <target state="translated">Эти не зависящие от машины опции управляют условными обозначениями интерфейса,используемыми при генерации кода.</target>
        </trans-unit>
        <trans-unit id="1408af6170149b7254d4dd6bcdcfd495ec7436ce" translate="yes" xml:space="preserve">
          <source>These mangling issues were fixed in</source>
          <target state="translated">Эти калечащие проблемы были зафиксированы в</target>
        </trans-unit>
        <trans-unit id="07b49ceeb21cede5a3a2711e37a7de019bfde35f" translate="yes" xml:space="preserve">
          <source>These memory models are formally defined in Appendix D of the SPARC-V9 architecture manual, as set in the processor&amp;rsquo;s &lt;code&gt;PSTATE.MM&lt;/code&gt; field.</source>
          <target state="translated">Эти модели памяти формально определены в Приложении D к руководству по архитектуре SPARC-V9, как установлено в поле процессора &lt;code&gt;PSTATE.MM&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b1c28027a49e0f9f937405f5f5d9848e5c4e1880" translate="yes" xml:space="preserve">
          <source>These modifiers generate this assembler code:</source>
          <target state="translated">Эти модификаторы генерируют этот ассемблерный код:</target>
        </trans-unit>
        <trans-unit id="743e02542ccafa4975400ec872a7ad2395932b78" translate="yes" xml:space="preserve">
          <source>These options (&amp;lsquo;</source>
          <target state="translated">Эти параметры ('</target>
        </trans-unit>
        <trans-unit id="4958c6c5d677addc8f58eab0c0d2cf3562ddc1ad" translate="yes" xml:space="preserve">
          <source>These options are defined for AArch64 implementations:</source>
          <target state="translated">Эти опции определены для реализаций AArch64:</target>
        </trans-unit>
        <trans-unit id="48d92fc742af2bfa615c74329a584a34db9bd186" translate="yes" xml:space="preserve">
          <source>These options are defined for AVR implementations:</source>
          <target state="translated">Эти опции определены для реализаций AVR:</target>
        </trans-unit>
        <trans-unit id="b2e06ccfcce04ef8518c59faf9fdd99422ee95ce" translate="yes" xml:space="preserve">
          <source>These options are defined for NDS32 implementations:</source>
          <target state="translated">Эти опции определены для реализаций NDS32:</target>
        </trans-unit>
        <trans-unit id="5d910c773d7a92c5968f91520cb1c96e846ae694" translate="yes" xml:space="preserve">
          <source>These options are defined for Nvidia PTX:</source>
          <target state="translated">Эти опции определены для Nvidia PTX:</target>
        </trans-unit>
        <trans-unit id="70a11512edb73659010487af7574c61b869ed8dd" translate="yes" xml:space="preserve">
          <source>These options are defined for OpenRISC:</source>
          <target state="translated">Эти опции определены для OpenRISC:</target>
        </trans-unit>
        <trans-unit id="c280d854c3b143f60be7e0eaa4e7170900086fe5" translate="yes" xml:space="preserve">
          <source>These options are defined for Score implementations:</source>
          <target state="translated">Эти опции определены для реализаций Score:</target>
        </trans-unit>
        <trans-unit id="3fb4c45c0c5f292728f019e5710497a0ec8817f3" translate="yes" xml:space="preserve">
          <source>These options are defined for Xstormy16:</source>
          <target state="translated">Эти опции определены для Xstormy16:</target>
        </trans-unit>
        <trans-unit id="8b09b81649730921d2e9ab3de0a2c88ec62a4975" translate="yes" xml:space="preserve">
          <source>These options are defined for all architectures running the Darwin operating system.</source>
          <target state="translated">Эти параметры определяются для всех архитектур под управлением операционной системы Darwin.</target>
        </trans-unit>
        <trans-unit id="7cb3b867f983940ea2e4ebd67efa329a40f483ce" translate="yes" xml:space="preserve">
          <source>These options are defined for the MMIX:</source>
          <target state="translated">Эти опции определены для MMIX:</target>
        </trans-unit>
        <trans-unit id="385fe3117f02cef23e8d723690c0cfc308b93e2c" translate="yes" xml:space="preserve">
          <source>These options are defined for the MSP430:</source>
          <target state="translated">Эти опции определены для MSP430:</target>
        </trans-unit>
        <trans-unit id="adcca40803ff77f8885d53e3bb9902253e5f5f3e" translate="yes" xml:space="preserve">
          <source>These options are defined for the PDP-11:</source>
          <target state="translated">Эти опции определены для PDP-11:</target>
        </trans-unit>
        <trans-unit id="9bfa23d8fe1cfc039288a92db83209397de4a2aa" translate="yes" xml:space="preserve">
          <source>These options are defined specifically for the AMD GCN port.</source>
          <target state="translated">Эти опции определены специально для порта AMD GCN.</target>
        </trans-unit>
        <trans-unit id="08c86a5f185d6c276d710a46803063b57baac6b5" translate="yes" xml:space="preserve">
          <source>These options are defined specifically for the CR16 ports.</source>
          <target state="translated">Эти опции определены специально для портов CR16.</target>
        </trans-unit>
        <trans-unit id="bbab2a1744111610f4ef1fc49ca09af76e7d1a32" translate="yes" xml:space="preserve">
          <source>These options are defined specifically for the CRIS ports.</source>
          <target state="translated">Эти опции определены специально для портов CRIS.</target>
        </trans-unit>
        <trans-unit id="9926932fa2a7f92eb437e1b2ac02cd6adfeca6d5" translate="yes" xml:space="preserve">
          <source>These options are defined specifically for the FR30 port.</source>
          <target state="translated">Эти опции определены специально для порта FR30.</target>
        </trans-unit>
        <trans-unit id="3dab4ff68a4f656f1c031b134a3ea5a7f3fcf21b" translate="yes" xml:space="preserve">
          <source>These options are defined specifically for the FT32 port.</source>
          <target state="translated">Эти опции определены специально для порта FT32.</target>
        </trans-unit>
        <trans-unit id="75c959329e4528f6f7066c03da92ac9a3ae209b8" translate="yes" xml:space="preserve">
          <source>These options are passed down to the linker. They are defined for compatibility with Diab.</source>
          <target state="translated">Эти опции передаются в линкер.Они определяются для совместимости с Diab.</target>
        </trans-unit>
        <trans-unit id="514cb6ef588bccc0cfd12c2a6ee53c62e3980343" translate="yes" xml:space="preserve">
          <source>These options are passed to the Darwin linker. The Darwin linker man page describes them in detail.</source>
          <target state="translated">Эти опции передаются в линкер Дарвина.Страница Дарвина в линкере подробно описывает их.</target>
        </trans-unit>
        <trans-unit id="921e998e0a7514666b6cd58d10b556dced0e17ae" translate="yes" xml:space="preserve">
          <source>These options are similar to</source>
          <target state="translated">Эти варианты схожи с</target>
        </trans-unit>
        <trans-unit id="c15cb110a025cb053a49b0cc23a8ae49630d084e" translate="yes" xml:space="preserve">
          <source>These options are supported for Xtensa targets:</source>
          <target state="translated">Эти опции поддерживаются для целей Xtensa:</target>
        </trans-unit>
        <trans-unit id="024672ba12f6533c6267ee5ffbe7b18b0036fae5" translate="yes" xml:space="preserve">
          <source>These options come into play when the compiler links object files into an executable output file. They are meaningless if the compiler is not doing a link step.</source>
          <target state="translated">Эти опции вступают в игру,когда компилятор связывает объектные файлы в исполняемый выходной файл.Они бессмысленны,если компилятор не делает шаг компоновки.</target>
        </trans-unit>
        <trans-unit id="4133c0873f5f47fa3d2f753863bb9a83e1789d05" translate="yes" xml:space="preserve">
          <source>These options control the C preprocessor, which is run on each C source file before actual compilation.</source>
          <target state="translated">Эти опции управляют препроцессором C,который запускается на каждом исходном файле C перед фактической компиляцией.</target>
        </trans-unit>
        <trans-unit id="5ef76ab842e5d74de09c81a688676470bc03ede7" translate="yes" xml:space="preserve">
          <source>These options control the encoding of the special not-a-number (NaN) IEEE 754 floating-point data.</source>
          <target state="translated">Эти опции управляют кодированием специальных данных с плавающей запятой не по номеру (NaN)IEEE 754.</target>
        </trans-unit>
        <trans-unit id="b6d05ca58952f18a481361248697cafe54bd4e24" translate="yes" xml:space="preserve">
          <source>These options control the treatment of literal pools. The default is</source>
          <target state="translated">Эти опции контролируют обработку буквальных бассейнов.По умолчанию</target>
        </trans-unit>
        <trans-unit id="63f8686ec125e23f83695f3f62c70b1f7e4905ad" translate="yes" xml:space="preserve">
          <source>These options control the treatment of the special not-a-number (NaN) IEEE 754 floating-point data with the &lt;code&gt;abs.&lt;i&gt;fmt&lt;/i&gt;&lt;/code&gt; and &lt;code&gt;neg.&lt;i&gt;fmt&lt;/i&gt;&lt;/code&gt; machine instructions.</source>
          <target state="translated">Эти параметры управляют обработкой специальных данных с плавающей запятой IEEE 754, не являющихся числом (NaN), с &lt;code&gt;abs.&lt;i&gt;fmt&lt;/i&gt;&lt;/code&gt; и &lt;code&gt;neg.&lt;i&gt;fmt&lt;/i&gt;&lt;/code&gt; машинные инструкции.</target>
        </trans-unit>
        <trans-unit id="fe30970c8506c0b34e204983d37e0e48b0b22605" translate="yes" xml:space="preserve">
          <source>These options control various sorts of optimizations.</source>
          <target state="translated">Эти опции контролируют различные виды оптимизации.</target>
        </trans-unit>
        <trans-unit id="ca73d9226e349bbe9ceb8794e7b1f792d3ed7055" translate="yes" xml:space="preserve">
          <source>These options control warnings about left shift overflows.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8077ddc9c44325d74d2e32e67e952882010bc964" translate="yes" xml:space="preserve">
          <source>These options control whether a bit-field is signed or unsigned, when the declaration does not use either &lt;code&gt;signed&lt;/code&gt; or &lt;code&gt;unsigned&lt;/code&gt;. By default, such a bit-field is signed, because this is consistent: the basic integer types such as &lt;code&gt;int&lt;/code&gt; are signed types.</source>
          <target state="translated">Эти параметры определяют, является ли битовое поле подписанным или беззнаковым, если в объявлении не используются &lt;code&gt;signed&lt;/code&gt; или &lt;code&gt;unsigned&lt;/code&gt; . По умолчанию такое битовое поле подписано, потому что это согласовано: основные целочисленные типы, такие как &lt;code&gt;int&lt;/code&gt; , являются типами со знаком.</target>
        </trans-unit>
        <trans-unit id="04984b17ce3993112173c90b978bdade9a561d21" translate="yes" xml:space="preserve">
          <source>These options control which form of branches will be generated. The default is</source>
          <target state="translated">Эти опции управляют тем,какая форма ветвей будет сгенерирована.По умолчанию</target>
        </trans-unit>
        <trans-unit id="75acf55e945580c3df0ebbfbfe506d046bc6e85c" translate="yes" xml:space="preserve">
          <source>These options enable GCC to use these extended instructions in generated code, even without</source>
          <target state="translated">Эти опции позволяют GCC использовать эти расширенные инструкции в сгенерированном коде даже без</target>
        </trans-unit>
        <trans-unit id="e7fd9ac7bed816cccc6942a8d8998c84e682fcba" translate="yes" xml:space="preserve">
          <source>These options enable dumping after five rounds of instruction splitting.</source>
          <target state="translated">Эти опции позволяют выполнять сброс после пяти раундов разделения инструкций.</target>
        </trans-unit>
        <trans-unit id="b5b2a58223d63058f35e9cfc3fe268fbe52e4e8c" translate="yes" xml:space="preserve">
          <source>These options have no effect unless GCC is generating position independent code.</source>
          <target state="translated">Эти опции не имеют эффекта,если только GCC не генерирует позиционно-независимый код.</target>
        </trans-unit>
        <trans-unit id="0d11fb15204ab5a9c7be14b9ed2aaeffe527ddd6" translate="yes" xml:space="preserve">
          <source>These options have no effect unless GCC is generating position-independent code.</source>
          <target state="translated">Эти опции не действуют,если только GCC не генерирует позиционно-независимый код.</target>
        </trans-unit>
        <trans-unit id="32e82c10f4ef0470986d8f101c75c3deb8c3bb8b" translate="yes" xml:space="preserve">
          <source>These options specify directories to search for header files, for libraries and for parts of the compiler:</source>
          <target state="translated">Эти опции задают каталоги для поиска заголовочных файлов,библиотек и частей компилятора:</target>
        </trans-unit>
        <trans-unit id="e76a02704dc0e3839f8323b052aabfba6ae282f0" translate="yes" xml:space="preserve">
          <source>These options tell the compiler where to place functions and data that do not have one of the &lt;code&gt;lower&lt;/code&gt;, &lt;code&gt;upper&lt;/code&gt;, &lt;code&gt;either&lt;/code&gt; or &lt;code&gt;section&lt;/code&gt; attributes. Possible values are &lt;code&gt;lower&lt;/code&gt;, &lt;code&gt;upper&lt;/code&gt;, &lt;code&gt;either&lt;/code&gt; or &lt;code&gt;any&lt;/code&gt;. The first three behave like the corresponding attribute. The fourth possible value - &lt;code&gt;any&lt;/code&gt; - is the default. It leaves placement entirely up to the linker script and how it assigns the standard sections (&lt;code&gt;.text&lt;/code&gt;, &lt;code&gt;.data&lt;/code&gt;, etc) to the memory regions.</source>
          <target state="translated">Эти опции указать компилятор , где размещать функции и данные , которые не имеют одного из &lt;code&gt;lower&lt;/code&gt; , &lt;code&gt;upper&lt;/code&gt; , &lt;code&gt;either&lt;/code&gt; или &lt;code&gt;section&lt;/code&gt; атрибутов. Возможные значения: &lt;code&gt;lower&lt;/code&gt; , &lt;code&gt;upper&lt;/code&gt; , &lt;code&gt;either&lt;/code&gt; или &lt;code&gt;any&lt;/code&gt; . Первые три ведут себя как соответствующие атрибуты. Четвертое возможное значение - &lt;code&gt;any&lt;/code&gt; - по умолчанию. Он оставляет размещение полностью на усмотрение сценария компоновщика и того, как он назначает стандартные разделы ( &lt;code&gt;.text&lt;/code&gt; , &lt;code&gt;.data&lt;/code&gt; и т. Д.) Областям памяти.</target>
        </trans-unit>
        <trans-unit id="e0b73ff2eada76f8ac9ebd9981af9354d96c99aa" translate="yes" xml:space="preserve">
          <source>These pragmas maintain a stack of the current target and optimization options. It is intended for include files where you temporarily want to switch to using a different &amp;lsquo;</source>
          <target state="translated">Эти прагмы поддерживают стек текущей цели и опций оптимизации. Он предназначен для включаемых файлов, в которых вы временно хотите переключиться на использование другого '</target>
        </trans-unit>
        <trans-unit id="603f3636cf78ad4d753498b11957f65672ebe2cb" translate="yes" xml:space="preserve">
          <source>These problems are perhaps regrettable, but we don&amp;rsquo;t know any practical way around them.</source>
          <target state="translated">Эти проблемы, возможно, достойны сожаления, но мы не знаем практических способов их решения.</target>
        </trans-unit>
        <trans-unit id="65b9fcf5c8f8750409b0be6384fa9bc28cb10f52" translate="yes" xml:space="preserve">
          <source>These programs work properly with GNU C++ if &lt;code&gt;__STDC__&lt;/code&gt; is defined. They would not work otherwise.</source>
          <target state="translated">Эти программы правильно работают с GNU C ++, если определено &lt;code&gt;__STDC__&lt;/code&gt; . В противном случае они бы не работали.</target>
        </trans-unit>
        <trans-unit id="8668b2099e0b980048c9ff0d8e19c4e25e485197" translate="yes" xml:space="preserve">
          <source>These pseudo types are not defined by GCC, they are simply a notational convenience used in this manual.</source>
          <target state="translated">Эти псевдотипы не определяются GCC,они просто удобны в использовании в данном руководстве.</target>
        </trans-unit>
        <trans-unit id="f405633d47d5e6bb41585f2bd9ddbfca800a1d10" translate="yes" xml:space="preserve">
          <source>These restrictions exist because the storage order attribute is lost when the address of a scalar or the address of an array with scalar component is taken, so storing indirectly through this address generally does not work. The second case is nevertheless allowed to be able to perform a block copy from or to the array.</source>
          <target state="translated">Эти ограничения существуют из-за того,что атрибут порядка хранения теряется при взятии адреса скаляра или адреса массива со скалярным компонентом,поэтому хранение косвенно через этот адрес обычно не работает.Во втором случае,тем не менее,разрешается выполнять блочную копию из массива или в массив.</target>
        </trans-unit>
        <trans-unit id="617ec4855cb2c9a651bfd784a1ec34d6b14a3c49" translate="yes" xml:space="preserve">
          <source>These switches are supported in addition to the above on Solaris 2:</source>
          <target state="translated">Эти переключатели поддерживаются в дополнение к вышеописанному на Solaris 2:</target>
        </trans-unit>
        <trans-unit id="bc8a75785b95174e69ab84ca725881f92373e1de" translate="yes" xml:space="preserve">
          <source>These switches control the size of &lt;code&gt;long double&lt;/code&gt; type. A size of 64 bits makes the &lt;code&gt;long double&lt;/code&gt; type equivalent to the &lt;code&gt;double&lt;/code&gt; type. This is the default for 32-bit Bionic C library. A size of 128 bits makes the &lt;code&gt;long double&lt;/code&gt; type equivalent to the &lt;code&gt;__float128&lt;/code&gt; type. This is the default for 64-bit Bionic C library.</source>
          <target state="translated">Эти переключатели регулируют размер &lt;code&gt;long double&lt;/code&gt; типа. Размер в 64 бита делает тип &lt;code&gt;long double&lt;/code&gt; эквивалентным типу &lt;code&gt;double&lt;/code&gt; . Это значение по умолчанию для 32-разрядной библиотеки Bionic C. Размер 128 бит делает тип &lt;code&gt;long double&lt;/code&gt; эквивалентным типу &lt;code&gt;__float128&lt;/code&gt; . Это значение по умолчанию для 64-битной библиотеки Bionic C.</target>
        </trans-unit>
        <trans-unit id="ee4c72bd4a51cef29e53fde4cebb62a0cdc42ecb" translate="yes" xml:space="preserve">
          <source>These switches control the size of &lt;code&gt;long double&lt;/code&gt; type. A size of 64 bits makes the &lt;code&gt;long double&lt;/code&gt; type equivalent to the &lt;code&gt;double&lt;/code&gt; type. This is the default.</source>
          <target state="translated">Эти переключатели регулируют размер &lt;code&gt;long double&lt;/code&gt; типа. Размер в 64 бита делает тип &lt;code&gt;long double&lt;/code&gt; эквивалентным типу &lt;code&gt;double&lt;/code&gt; . Это значение по умолчанию.</target>
        </trans-unit>
        <trans-unit id="cfe1fb390a0357110cca04fd8837b1f7aac6050f" translate="yes" xml:space="preserve">
          <source>These switches control the size of &lt;code&gt;long double&lt;/code&gt; type. The x86-32 application binary interface specifies the size to be 96 bits, so</source>
          <target state="translated">Эти переключатели регулируют размер &lt;code&gt;long double&lt;/code&gt; типа. Двоичный интерфейс приложения x86-32 определяет размер 96 бит, поэтому</target>
        </trans-unit>
        <trans-unit id="10e0a73d40a50d884864ada5af6042c707554338" translate="yes" xml:space="preserve">
          <source>These switches enable the use of instructions in the MMX, SSE, SSE2, SSE3, SSSE3, SSE4, SSE4A, SSE4.1, SSE4.2, AVX, AVX2, AVX512F, AVX512PF, AVX512ER, AVX512CD, AVX512VL, AVX512BW, AVX512DQ, AVX512IFMA, AVX512VBMI, SHA, AES, PCLMUL, CLFLUSHOPT, CLWB, FSGSBASE, PTWRITE, RDRND, F16C, FMA, PCONFIG, WBNOINVD, FMA4, PREFETCHW, RDPID, PREFETCHWT1, RDSEED, SGX, XOP, LWP, 3DNow!, enhanced 3DNow!, POPCNT, ABM, ADX, BMI, BMI2, LZCNT, FXSR, XSAVE, XSAVEOPT, XSAVEC, XSAVES, RTM, HLE, TBM, MWAITX, CLZERO, PKU, AVX512VBMI2, GFNI, VAES, WAITPKG, VPCLMULQDQ, AVX512BITALG, MOVDIRI, MOVDIR64B, AVX512BF16, ENQCMD, AVX512VPOPCNTDQ, AVX5124FMAPS, AVX512VNNI, AVX5124VNNIW, or CLDEMOTE extended instruction sets. Each has a corresponding</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c7348ef4aa27c2888870c0a37711f33df4fe6ef4" translate="yes" xml:space="preserve">
          <source>These switches enable the use of instructions in the MMX, SSE, SSE2, SSE3, SSSE3, SSE4, SSE4A, SSE4.1, SSE4.2, AVX, AVX2, AVX512F, AVX512PF, AVX512ER, AVX512CD, AVX512VL, AVX512BW, AVX512DQ, AVX512IFMA, AVX512VBMI, SHA, AES, PCLMUL, CLFLUSHOPT, CLWB, FSGSBASE, PTWRITE, RDRND, F16C, FMA, PCONFIG, WBNOINVD, FMA4, PREFETCHW, RDPID, PREFETCHWT1, RDSEED, SGX, XOP, LWP, 3DNow!, enhanced 3DNow!, POPCNT, ABM, ADX, BMI, BMI2, LZCNT, FXSR, XSAVE, XSAVEOPT, XSAVEC, XSAVES, RTM, HLE, TBM, MWAITX, CLZERO, PKU, AVX512VBMI2, GFNI, VAES, WAITPKG, VPCLMULQDQ, AVX512BITALG, MOVDIRI, MOVDIR64B, AVX512VPOPCNTDQ, AVX5124FMAPS, AVX512VNNI, AVX5124VNNIW, or CLDEMOTE extended instruction sets. Each has a corresponding</source>
          <target state="translated">Эти переключатели позволяют использовать инструкции в MMX,SSE,SSE2,SSE3,SSSE3,SSE4,SSE4A,SSE4.1,SSE4.2,AVX,AVX2,AVX512F,AVX512PF,AVX512ER,AVX512CD,AVX512VL,AVX512BW,AVX512DQ,AVX512IFMA,AVX512VBMI,SHA,AES,PCLMUL,CLFLUSHOPT,CLWB,FSGSBASE,PTWRITE,RDRND,F16C,FMA,PCONFIG,WBNOINVD,FMA4,PREFETCHW,RDPID,PREFETCHWT1,RDSEED,SGX,XOP,LWP,3DNow!,улучшенный 3DNow! POPCNT,ABM,ADX,BMI,BMI2,LZCNT,FXSR,XSAVE,XSAVEOPT,XSAVEC,XSAVES,RTM,HLE,TBM,MWAITX,CLZERO,PKU,AVX512VBMI2,GFNI,VAES,WAITPKG,VPCLMULQDQ,AVX512BITALG,MOVDIRI,MOVDIR64B,AVX512VPOPCNTDQ,AVX5124FMAPS,AVX512VNNI,AVX5124VNIW или расширенные наборы инструкций CLDEMOTE.Каждый из них имеет соответствующий</target>
        </trans-unit>
        <trans-unit id="cf9495d6f00684499ee4c826615f4071694dd898" translate="yes" xml:space="preserve">
          <source>These types can be used to define 128-bit variables. The built-in functions listed in the following section can be used on these variables to generate the vector operations.</source>
          <target state="translated">Эти типы могут быть использованы для определения 128-битных переменных.Встроенные функции,перечисленные в следующем разделе,могут быть использованы для генерации векторных операций.</target>
        </trans-unit>
        <trans-unit id="e668693b38e6c57f5102ee95a3e05249f7244a77" translate="yes" xml:space="preserve">
          <source>These usages are only permitted when they are not ambiguous.</source>
          <target state="translated">Такое использование разрешено только в том случае,если оно не является двусмысленным.</target>
        </trans-unit>
        <trans-unit id="5f38a05c071c60c51e986980de83378738afc905" translate="yes" xml:space="preserve">
          <source>These variable attributes are available for H8/300 targets:</source>
          <target state="translated">Эти переменные атрибуты доступны для целей H8/300:</target>
        </trans-unit>
        <trans-unit id="241d1accd4905e80f5a34fe3dc64f1b3deee21e2" translate="yes" xml:space="preserve">
          <source>These variable attributes are supported by the Nvidia PTX back end:</source>
          <target state="translated">Эти атрибуты переменных поддерживаются бэк-эндом Nvidia PTX:</target>
        </trans-unit>
        <trans-unit id="f806a524d1696f92091d57f9cf53c9146e9a15bf" translate="yes" xml:space="preserve">
          <source>These variable attributes are supported by the V850 back end:</source>
          <target state="translated">Эти атрибуты переменных поддерживаются задней частью V850:</target>
        </trans-unit>
        <trans-unit id="e1ed20f7dd8c240bdd89fa6c4be557443a983d56" translate="yes" xml:space="preserve">
          <source>These warnings are enabled by default.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b949d9fe4918e4b913002b1484d0c6602fa25eb3" translate="yes" xml:space="preserve">
          <source>These warnings are harmless and can be safely ignored.</source>
          <target state="translated">Эти предупреждения безвредны и могут быть безопасно проигнорированы.</target>
        </trans-unit>
        <trans-unit id="e451fc6c4b4d61a1351149a72dc14d1a6505cb95" translate="yes" xml:space="preserve">
          <source>These warnings are made optional because GCC may not be able to determine when the code is correct in spite of appearing to have an error. Here is one example of how this can happen:</source>
          <target state="translated">Эти предупреждения сделаны необязательными,так как GCC может не определить,когда код корректен,несмотря на то,что кажется,что он содержит ошибку.Приведем один пример,как это может произойти:</target>
        </trans-unit>
        <trans-unit id="94e18fe51f3f4e2e5c1a093907e436f1a7eab080" translate="yes" xml:space="preserve">
          <source>These warnings are only possible in optimizing compilation, because otherwise GCC does not keep track of the state of variables.</source>
          <target state="translated">Эти предупреждения возможны только при оптимизации компиляции,так как в противном случае GCC не отслеживает состояние переменных.</target>
        </trans-unit>
        <trans-unit id="e68200a8afffeb4dc68ba2a9ef927363c09a49e9" translate="yes" xml:space="preserve">
          <source>These warnings occur for individual uninitialized elements of structure, union or array variables as well as for variables that are uninitialized as a whole. They do not occur for variables or elements declared &lt;code&gt;volatile&lt;/code&gt;. Because these warnings depend on optimization, the exact variables or elements for which there are warnings depend on the precise optimization options and version of GCC used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e773c8b72ecdbdff1f92adf539e992bd54211f66" translate="yes" xml:space="preserve">
          <source>These warnings occur for individual uninitialized or clobbered elements of structure, union or array variables as well as for variables that are uninitialized or clobbered as a whole. They do not occur for variables or elements declared &lt;code&gt;volatile&lt;/code&gt;. Because these warnings depend on optimization, the exact variables or elements for which there are warnings depends on the precise optimization options and version of GCC used.</source>
          <target state="translated">Эти предупреждения появляются для отдельных неинициализированных или затертых элементов структуры, переменных объединения или массива, а также для переменных, которые не инициализированы или затерты в целом. Они не встречаются для переменных или элементов, объявленных &lt;code&gt;volatile&lt;/code&gt; . Поскольку эти предупреждения зависят от оптимизации, точные переменные или элементы, для которых есть предупреждения, зависят от точных параметров оптимизации и используемой версии GCC.</target>
        </trans-unit>
        <trans-unit id="54f2498a22474b067e488cbcf73df92835b4dcbc" translate="yes" xml:space="preserve">
          <source>Things we think are right, but some others disagree.</source>
          <target state="translated">Вещи,которые мы считаем правильными,но некоторые другие не согласны.</target>
        </trans-unit>
        <trans-unit id="1997b0ca2cbaa31341990ddcffc48330394de3bf" translate="yes" xml:space="preserve">
          <source>Things will disappear from G++.</source>
          <target state="translated">Вещи исчезнут с G++.</target>
        </trans-unit>
        <trans-unit id="c779d1bd661026f38150c16245e1a66cae977330" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;asm&lt;/code&gt; takes one input, which is internally popped, and produces two outputs.</source>
          <target state="translated">Этот &lt;code&gt;asm&lt;/code&gt; принимает один вход, который извлекается изнутри, и производит два выхода.</target>
        </trans-unit>
        <trans-unit id="7ea744591db59b72a57a82ebc78f06c0a9beaefd" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;asm&lt;/code&gt; takes two inputs, which are popped by the &lt;code&gt;fyl2xp1&lt;/code&gt; opcode, and replaces them with one output. The &lt;code&gt;st(1)&lt;/code&gt; clobber is necessary for the compiler to know that &lt;code&gt;fyl2xp1&lt;/code&gt; pops both inputs.</source>
          <target state="translated">Этот &lt;code&gt;asm&lt;/code&gt; принимает два входа, которые &lt;code&gt;fyl2xp1&lt;/code&gt; операции fyl2xp1 , и заменяет их одним выходом. &lt;code&gt;st(1)&lt;/code&gt; колошматить необходимо для компилятора , чтобы знать , что &lt;code&gt;fyl2xp1&lt;/code&gt; выскакивает оба входа.</target>
        </trans-unit>
        <trans-unit id="49059cf2744a33f2c89b82b703d94b0c5663c6e8" translate="yes" xml:space="preserve">
          <source>This IA-64 HP-UX attribute, attached to a global variable or function, renames a symbol to contain a version string, thus allowing for function level versioning. HP-UX system header files may use function level versioning for some system calls.</source>
          <target state="translated">Данный атрибут IA-64 HP-UX,прикрепленный к глобальной переменной или функции,переименовывает символ,содержащий строку версий,что позволяет версионировать его на уровне функции.В заголовочных системных файлах HP-UX для некоторых системных вызовов может использоваться версионирование на уровне функций.</target>
        </trans-unit>
        <trans-unit id="241afcfcf7826d27f6d46a14ffc5e97907ebd792" translate="yes" xml:space="preserve">
          <source>This ISA is implemented by the minimal AVR core and supported for assembler only. &lt;var&gt;mcu&lt;/var&gt; = &lt;code&gt;attiny11&lt;/code&gt;, &lt;code&gt;attiny12&lt;/code&gt;, &lt;code&gt;attiny15&lt;/code&gt;, &lt;code&gt;attiny28&lt;/code&gt;, &lt;code&gt;at90s1200&lt;/code&gt;.</source>
          <target state="translated">Этот ISA реализуется минимальным ядром AVR и поддерживается только для ассемблера. &lt;var&gt;mcu&lt;/var&gt; = &lt;code&gt;attiny11&lt;/code&gt; , &lt;code&gt;attiny12&lt;/code&gt; , &lt;code&gt;attiny15&lt;/code&gt; , &lt;code&gt;attiny28&lt;/code&gt; , &lt;code&gt;at90s1200&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7707ff43d31f77dd6414b616a64487e73ac2f610" translate="yes" xml:space="preserve">
          <source>This RX attribute is similar to the &lt;code&gt;interrupt&lt;/code&gt; attribute, including its parameters, but does not make the function an interrupt-handler type function (i.e. it retains the normal C function calling ABI). See the &lt;code&gt;interrupt&lt;/code&gt; attribute for a description of its arguments.</source>
          <target state="translated">Этот атрибут RX аналогичен атрибуту &lt;code&gt;interrupt&lt;/code&gt; , включая его параметры, но не делает функцию функцией типа обработчика прерывания (то есть сохраняет обычную функцию C, вызывающую ABI). См. Атрибут &lt;code&gt;interrupt&lt;/code&gt; для описания его аргументов.</target>
        </trans-unit>
        <trans-unit id="5e3ace91b836f39e130a69b032cbc00b174ef7e1" translate="yes" xml:space="preserve">
          <source>This allows classes to dynamically register methods (by adding them to the class using &lt;code&gt;class_addMethod&lt;/code&gt;) when they are first called. To do so, a class should implement &lt;code&gt;+resolveInstanceMethod:&lt;/code&gt; (or, depending on the case, &lt;code&gt;+resolveClassMethod:&lt;/code&gt;) and have it recognize the selectors of methods that can be registered dynamically at runtime, register them, and return &lt;code&gt;YES&lt;/code&gt;. It should return &lt;code&gt;NO&lt;/code&gt; for methods that it does not dynamically registered at runtime.</source>
          <target state="translated">Это позволяет классам динамически регистрировать методы (путем добавления их в класс с помощью &lt;code&gt;class_addMethod&lt;/code&gt; ) при их первом вызове. Для этого класс должен реализовать &lt;code&gt;+resolveInstanceMethod:&lt;/code&gt; (или, в зависимости от случая, &lt;code&gt;+resolveClassMethod:&lt;/code&gt; ) и должен распознавать селекторы методов, которые могут быть зарегистрированы динамически во время выполнения, регистрировать их и возвращать &lt;code&gt;YES&lt;/code&gt; . Он должен возвращать &lt;code&gt;NO&lt;/code&gt; для методов, которые не регистрируются динамически во время выполнения.</target>
        </trans-unit>
        <trans-unit id="08bbed031d0bdc80dfc8c12fb03bbad77feeb085" translate="yes" xml:space="preserve">
          <source>This also works with</source>
          <target state="translated">Это также работает с</target>
        </trans-unit>
        <trans-unit id="ebf24102acffe4ee7e0e4cb4b714de13fd9ab15c" translate="yes" xml:space="preserve">
          <source>This analysis is much more expensive than other GCC warnings.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="70958ab1135f4d3b760976f6ea18b5ad5e6cd4ca" translate="yes" xml:space="preserve">
          <source>This assumes that &lt;code&gt;x&lt;/code&gt; is an array of pointers to functions; the type described is that of the values of the functions.</source>
          <target state="translated">Это предполагает, что &lt;code&gt;x&lt;/code&gt; - это массив указателей на функции; описываемый тип - это тип значений функций.</target>
        </trans-unit>
        <trans-unit id="0e587899e8439ab096a171178bf777e82d34203e" translate="yes" xml:space="preserve">
          <source>This attribute adds stack protection code to the function if flags</source>
          <target state="translated">Этот атрибут добавляет код защиты стека в функцию,если флаги</target>
        </trans-unit>
        <trans-unit id="ffa1a8a02f8237f39f16f9e3141f209d4e6ecc0a" translate="yes" xml:space="preserve">
          <source>This attribute affects the linkage of the declaration to which it is attached. It can be applied to variables (see &lt;a href=&quot;common-variable-attributes#Common-Variable-Attributes&quot;&gt;Common Variable Attributes&lt;/a&gt;) and types (see &lt;a href=&quot;common-type-attributes#Common-Type-Attributes&quot;&gt;Common Type Attributes&lt;/a&gt;) as well as functions.</source>
          <target state="translated">Этот атрибут влияет на привязку объявления, к которому он прикреплен. Его можно применять к переменным (см. &lt;a href=&quot;common-variable-attributes#Common-Variable-Attributes&quot;&gt;Общие атрибуты переменных&lt;/a&gt; ) и типам (см. &lt;a href=&quot;common-type-attributes#Common-Type-Attributes&quot;&gt;Атрибуты общих типов&lt;/a&gt; ), а также к функциям.</target>
        </trans-unit>
        <trans-unit id="b70510133f65523747a3309a22314ce44be57270" translate="yes" xml:space="preserve">
          <source>This attribute affects the linkage of the declaration to which it is attached. The &lt;code&gt;visibility&lt;/code&gt; attribute is described in &lt;a href=&quot;common-function-attributes#Common-Function-Attributes&quot;&gt;Common Function Attributes&lt;/a&gt;.</source>
          <target state="translated">Этот атрибут влияет на привязку объявления, к которому он прикреплен. &lt;code&gt;visibility&lt;/code&gt; атрибута описывается в &lt;a href=&quot;common-function-attributes#Common-Function-Attributes&quot;&gt;общих атрибутов функции&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2662beeb7225f89f9b3b830e684251c6d287e4ea" translate="yes" xml:space="preserve">
          <source>This attribute allows one to mark secure-code functions that are callable from normal mode. The location of the secure call function into the &lt;code&gt;sjli&lt;/code&gt; table needs to be passed as argument.</source>
          <target state="translated">Этот атрибут позволяет отмечать функции безопасного кода, которые можно вызывать из нормального режима. Местоположение функции безопасного вызова в таблице &lt;code&gt;sjli&lt;/code&gt; необходимо передать в качестве аргумента.</target>
        </trans-unit>
        <trans-unit id="f72283dc6a14cbd57d6d6c7ceadcc8425ca927f4" translate="yes" xml:space="preserve">
          <source>This attribute allows the compiler to construct the requisite function declaration, while allowing the body of the function to be assembly code. The specified function will not have prologue/epilogue sequences generated by the compiler. Only basic &lt;code&gt;asm&lt;/code&gt; statements can safely be included in naked functions (see &lt;a href=&quot;basic-asm#Basic-Asm&quot;&gt;Basic Asm&lt;/a&gt;). While using extended &lt;code&gt;asm&lt;/code&gt; or a mixture of basic &lt;code&gt;asm&lt;/code&gt; and C code may appear to work, they cannot be depended upon to work reliably and are not supported.</source>
          <target state="translated">Этот атрибут позволяет компилятору создать необходимое объявление функции, в то же время позволяя телу функции быть кодом сборки. У указанной функции не будет последовательностей пролога / эпилога, сгенерированных компилятором. В голые функции можно безопасно включать только базовые операторы &lt;code&gt;asm&lt;/code&gt; (см. &lt;a href=&quot;basic-asm#Basic-Asm&quot;&gt;Basic Asm&lt;/a&gt; ). Хотя использование расширенного &lt;code&gt;asm&lt;/code&gt; или смеси базового &lt;code&gt;asm&lt;/code&gt; и кода C может показаться работоспособным, они не могут быть надежными и не поддерживаются.</target>
        </trans-unit>
        <trans-unit id="2da8d71f1e17b2c08ea57936e512e0f37aa70a9f" translate="yes" xml:space="preserve">
          <source>This attribute applies only to the particular namespace body, not to other definitions of the same namespace; it is equivalent to using &amp;lsquo;</source>
          <target state="translated">Этот атрибут применяется только к конкретному телу пространства имен, а не к другим определениям того же пространства имен; это эквивалентно использованию '</target>
        </trans-unit>
        <trans-unit id="1a6b9ade066129340d2b93cc21dd28696f004a1b" translate="yes" xml:space="preserve">
          <source>This attribute causes the compiler to assume the called function is close enough to use the normal calling convention, overriding the</source>
          <target state="translated">Данный атрибут заставляет компилятор предположить,что вызываемая функция достаточно близка,чтобы использовать обычное соглашение о вызовах,переопределяющее</target>
        </trans-unit>
        <trans-unit id="02e0a7b8749b1724d33369b4ea037bd0b071529e" translate="yes" xml:space="preserve">
          <source>This attribute causes the compiler to emit instructions to disable interrupts for the duration of the given function.</source>
          <target state="translated">Данный атрибут заставляет компилятор выдавать инструкции по отключению прерываний на время работы данной функции.</target>
        </trans-unit>
        <trans-unit id="b8e219dd9b57732e157d707be34c1c904f638a7d" translate="yes" xml:space="preserve">
          <source>This attribute corresponds to the</source>
          <target state="translated">Этот атрибут соответствует</target>
        </trans-unit>
        <trans-unit id="0da402fe02e024fb03bb5a3ac4167c5cbafc19db" translate="yes" xml:space="preserve">
          <source>This attribute enables creation of one or more function versions that can process multiple arguments using SIMD instructions from a single invocation. Specifying this attribute allows compiler to assume that such versions are available at link time (provided in the same or another translation unit). Generated versions are target-dependent and described in the corresponding Vector ABI document. For x86_64 target this document can be found &lt;a href=&quot;https://sourceware.org/glibc/wiki/libmvec?action=AttachFile&amp;amp;do=view&amp;amp;target=VectorABI.txt&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">Этот атрибут позволяет создавать одну или несколько версий функции, которые могут обрабатывать несколько аргументов с помощью инструкций SIMD из одного вызова. Указание этого атрибута позволяет компилятору предположить, что такие версии доступны во время компоновки (предоставлены в той же или другой единице перевода). Сгенерированные версии зависят от цели и описаны в соответствующем документе Vector ABI. Для цели x86_64 этот документ можно найти &lt;a href=&quot;https://sourceware.org/glibc/wiki/libmvec?action=AttachFile&amp;amp;do=view&amp;amp;target=VectorABI.txt&quot;&gt;здесь&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="660859d290d769bde079f1e74652268ebbc1b062" translate="yes" xml:space="preserve">
          <source>This attribute indicates that the corresponding function should be compiled as a kernel function, that is an entry point that can be invoked from the host via the HSA runtime library. By default functions are only callable only from other GCN functions.</source>
          <target state="translated">Этот атрибут указывает на то,что соответствующая функция должна быть скомпилирована как функция ядра,т.е.как точка входа,которая может быть вызвана с хоста через библиотеку времени выполнения HSA.По умолчанию функции вызываются только из других GCN функций.</target>
        </trans-unit>
        <trans-unit id="f2fad3c190739d8e505c7ea63fef5f7267f258de" translate="yes" xml:space="preserve">
          <source>This attribute indicates that the corresponding function should be compiled as a kernel function, which can be invoked from the host via the CUDA RT library. By default functions are only callable only from other PTX functions.</source>
          <target state="translated">Данный атрибут указывает на то,что соответствующая функция должна быть скомпилирована как функция ядра,которая может быть вызвана с хоста через библиотеку CUDA RT.По умолчанию функции вызываются только из других PTX-функций.</target>
        </trans-unit>
        <trans-unit id="57e17cc8aacf2250a0265d50a2b47adfbfe456c6" translate="yes" xml:space="preserve">
          <source>This attribute is also accepted in C, but it is unnecessary because C does not have constructors or destructors.</source>
          <target state="translated">Этот атрибут также принимается в C,но он не нужен,так как в C нет конструкторов или деструкторов.</target>
        </trans-unit>
        <trans-unit id="503a85109e1de0e8ce0564d361fa1038358344dc" translate="yes" xml:space="preserve">
          <source>This attribute is appropriate for types which just represent a value, such as &lt;code&gt;std::string&lt;/code&gt;; it is not appropriate for types which control a resource, such as &lt;code&gt;std::lock_guard&lt;/code&gt;.</source>
          <target state="translated">Этот атрибут подходит для типов, которые просто представляют значение, например &lt;code&gt;std::string&lt;/code&gt; ; он не подходит для типов, которые управляют ресурсом, например &lt;code&gt;std::lock_guard&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ba2d583dcd0ca68ace008c0dc9fbd8ec6f90be8f" translate="yes" xml:space="preserve">
          <source>This attribute is ignored for R8C target.</source>
          <target state="translated">Этот атрибут игнорируется для цели R8C.</target>
        </trans-unit>
        <trans-unit id="34e03794349850af7bdeb66f9a9d6ef490386eec" translate="yes" xml:space="preserve">
          <source>This attribute is implicitly applied to any function named &lt;code&gt;main&lt;/code&gt;, using default parameters.</source>
          <target state="translated">Этот атрибут неявно применяется к любой функции с именем &lt;code&gt;main&lt;/code&gt; с использованием параметров по умолчанию.</target>
        </trans-unit>
        <trans-unit id="d9346f70ea23c21af36c756ae2b79002b57ffa81" translate="yes" xml:space="preserve">
          <source>This attribute is only applicable to integral and floating scalar types. In function declarations the attribute applies to the function return type.</source>
          <target state="translated">Данный атрибут применим только к интегральным и плавающим скалярным типам.В декларациях функций атрибут применяется к возвращаемому типу функции.</target>
        </trans-unit>
        <trans-unit id="4d7f394253f35fa8db5ca6f449a44ff4b56ba334" translate="yes" xml:space="preserve">
          <source>This attribute is only applicable to integral and floating scalars, although arrays, pointers, and function return values are allowed in conjunction with this construct.</source>
          <target state="translated">Данный атрибут применим только к интегральному и плавающему скалярам,хотя массивы,указатели и возвращаемые функцией значения допустимы в сочетании с данной конструкцией.</target>
        </trans-unit>
        <trans-unit id="7e555249b47de74e90649b8eebd9bb76b767b366" translate="yes" xml:space="preserve">
          <source>This attribute is supported only for targets that use a uniform default scalar storage order (fortunately, most of them), i.e. targets that store the scalars either all in big-endian or all in little-endian.</source>
          <target state="translated">Этот атрибут поддерживается только для целей,которые используют единый порядок хранения скаляров по умолчанию (к счастью,большинство из них),т.е.целей,которые хранят скаляры либо все в big-endian,либо все в little-endian.</target>
        </trans-unit>
        <trans-unit id="0c3dbf2eda48cb59aebda306917b7f78672e9f61" translate="yes" xml:space="preserve">
          <source>This attribute is used to modify the IA-64 calling convention by marking all input registers as live at all function exits. This makes it possible to restart a system call after an interrupt without having to save/restore the input registers. This also prevents kernel data from leaking into application code.</source>
          <target state="translated">Этот атрибут используется для изменения соглашения о вызове IA-64 путем пометки всех входных регистров как живых на всех выходах функций.Это позволяет перезапустить системный вызов после прерывания без необходимости сохранения/восстановления входных регистров.Это также предотвращает утечку данных ядра в код приложения.</target>
        </trans-unit>
        <trans-unit id="b29e16cc249effe80d848bb9db8d32ddaa499113" translate="yes" xml:space="preserve">
          <source>This attribute is useful for small inline wrappers that if possible should appear during debugging as a unit. Depending on the debug info format it either means marking the function as artificial or using the caller location for all instructions within the inlined body.</source>
          <target state="translated">Этот атрибут полезен для маленьких встроенных оберток,которые по возможности должны появляться во время отладки как единое целое.В зависимости от формата отладочной информации это означает либо пометку функции как искусственной,либо использование местоположения вызывающего абонента для всех инструкций внутри отладочного тела.</target>
        </trans-unit>
        <trans-unit id="eebce69b5ee57e7d9f9e53b8f77d9b2143a8f71f" translate="yes" xml:space="preserve">
          <source>This attribute locally overrides the</source>
          <target state="translated">Этот атрибут локально отменяет</target>
        </trans-unit>
        <trans-unit id="b079e0e5e6910cff82e9ecf2f5a99d46287bccb2" translate="yes" xml:space="preserve">
          <source>This attribute may only be applied to structure types. It indicates that any initialization of an object of this type must use designated initializers rather than positional initializers. The intent of this attribute is to allow the programmer to indicate that a structure&amp;rsquo;s layout may change, and that therefore relying on positional initialization will result in future breakage.</source>
          <target state="translated">Этот атрибут может применяться только к типам структур. Он указывает, что любая инициализация объекта этого типа должна использовать назначенные инициализаторы, а не позиционные инициализаторы. Назначение этого атрибута - позволить программисту указать, что макет структуры может измениться, и что, таким образом, использование позиционной инициализации приведет к поломке в будущем.</target>
        </trans-unit>
        <trans-unit id="c5c62ef86997f4e170b106b5387843679fbba8d0" translate="yes" xml:space="preserve">
          <source>This attribute modifies the behavior of an interrupt handler. The interrupt handler may be in external memory which cannot be reached by a branch instruction, so generate a local memory trampoline to transfer control. The single parameter identifies the section where the trampoline is placed.</source>
          <target state="translated">Этот атрибут изменяет поведение обработчика прерываний.Обработчик прерываний может находиться во внешней памяти,которая не может быть доступна командой ветви,поэтому для передачи управления генерируется локальный батут памяти.Одиночный параметр идентифицирует участок,на котором располагается батут.</target>
        </trans-unit>
        <trans-unit id="effaae1a1a3c582ea4cc6ec90afe0b02dd3b515f" translate="yes" xml:space="preserve">
          <source>This attribute only applies to interrupt functions. It is silently ignored if applied to a non-interrupt function. A wakeup interrupt function will rouse the processor from any low-power state that it might be in when the function exits.</source>
          <target state="translated">Данный атрибут применяется только к функциям прерывания.При применении к функции,не имеющей прерывания,он беззвучно игнорируется.Функция прерывания будильника вызовет процессор из любого маломощного состояния,в котором он может находиться при выходе из функции.</target>
        </trans-unit>
        <trans-unit id="b26152314a60738ffd8a5e7f3727dd841bf2cfd9" translate="yes" xml:space="preserve">
          <source>This attribute requires assembler and object file support, and may not be available on all targets.</source>
          <target state="translated">Данный атрибут требует поддержки ассемблера и объектного файла,и может быть доступен не на всех объектах.</target>
        </trans-unit>
        <trans-unit id="91b2af80c8a3a275efbd609425500eed5fe647aa" translate="yes" xml:space="preserve">
          <source>This attribute should be used with a function that is also declared with the &lt;code&gt;inline&lt;/code&gt; keyword. It directs GCC to treat the function as if it were defined in gnu90 mode even when compiling in C99 or gnu99 mode.</source>
          <target state="translated">Этот атрибут следует использовать с функцией, которая также объявлена ​​с помощью ключевого слова &lt;code&gt;inline&lt;/code&gt; . Он предписывает GCC обрабатывать функцию так, как если бы она была определена в режиме gnu90, даже при компиляции в режиме C99 или gnu99.</target>
        </trans-unit>
        <trans-unit id="673dc92ba9f751f0e2d252934e26bb46b7e48dac" translate="yes" xml:space="preserve">
          <source>This attribute specifies a function to be placed into L1 Instruction SRAM. The function is put into a specific section named &lt;code&gt;.l1.text&lt;/code&gt;. With</source>
          <target state="translated">Этот атрибут определяет функцию, которая должна быть помещена в SRAM инструкции L1. Функция помещается в специальный раздел с именем &lt;code&gt;.l1.text&lt;/code&gt; . С участием</target>
        </trans-unit>
        <trans-unit id="87042e05584213c1ab77c9f22219578def878d66" translate="yes" xml:space="preserve">
          <source>This attribute specifies a function to be placed into L2 SRAM. The function is put into a specific section named &lt;code&gt;.l2.text&lt;/code&gt;. With</source>
          <target state="translated">Этот атрибут определяет функцию, которая должна быть помещена в L2 SRAM. Функция помещается в специальный раздел с именем &lt;code&gt;.l2.text&lt;/code&gt; . С участием</target>
        </trans-unit>
        <trans-unit id="79629b6015ecde4f64aa5edeebdeed4ca22350b1" translate="yes" xml:space="preserve">
          <source>This attribute specifies a threshold for the structure field, measured in bytes. If the structure field is aligned below the threshold, a warning will be issued. For example, the declaration:</source>
          <target state="translated">Данный атрибут задает порог для поля структуры,измеряемый в байтах.Если поле структуры выровнено ниже порога,то выдается предупреждение.Например,декларация:</target>
        </trans-unit>
        <trans-unit id="304795dd4f7d1f35b54a689f0ca428f75b402b8c" translate="yes" xml:space="preserve">
          <source>This attribute specifies the data type for the declaration&amp;mdash;whichever type corresponds to the mode &lt;var&gt;mode&lt;/var&gt;. This in effect lets you request an integer or floating-point type according to its width.</source>
          <target state="translated">Этот атрибут определяет тип данных для объявления - в зависимости от того, какой тип соответствует режиму &lt;var&gt;mode&lt;/var&gt; . Фактически это позволяет вам запрашивать целочисленный тип или тип с плавающей запятой в соответствии с его шириной.</target>
        </trans-unit>
        <trans-unit id="9c9083d141dfccd0e26e0504dbf2c594ddf0afc0" translate="yes" xml:space="preserve">
          <source>This attribute specifies the vector size for the type of the declared variable, measured in bytes. The type to which it applies is known as the &lt;em&gt;base type&lt;/em&gt;. The &lt;var&gt;bytes&lt;/var&gt; argument must be a positive power-of-two multiple of the base type size. For example, the declaration:</source>
          <target state="translated">Этот атрибут определяет размер вектора для типа объявленной переменной, измеряемый в байтах. Тип, к которому он применяется, известен как &lt;em&gt;базовый тип&lt;/em&gt; . &lt;var&gt;bytes&lt;/var&gt; аргумент должен быть положительной мощность из-двух кратных размера базового типа. Например, объявление:</target>
        </trans-unit>
        <trans-unit id="4812a74afb4965dd971b67251a8e1a47c47bf670" translate="yes" xml:space="preserve">
          <source>This attribute specifies the vector size for the type, measured in bytes. The type to which it applies is known as the &lt;em&gt;base type&lt;/em&gt;. The &lt;var&gt;bytes&lt;/var&gt; argument must be a positive power-of-two multiple of the base type size. For example, the following declarations:</source>
          <target state="translated">Этот атрибут определяет размер вектора для типа, измеряемый в байтах. Тип, к которому он применяется, известен как &lt;em&gt;базовый тип&lt;/em&gt; . &lt;var&gt;bytes&lt;/var&gt; аргумент должен быть положительной мощность из-двух кратных размера базового типа. Например, следующие объявления:</target>
        </trans-unit>
        <trans-unit id="721933cb3a33d0b7e6bbaf2079ece1bfb6d52c2e" translate="yes" xml:space="preserve">
          <source>This attribute, attached to a &lt;code&gt;struct&lt;/code&gt;, &lt;code&gt;union&lt;/code&gt;, or C++ &lt;code&gt;class&lt;/code&gt; type definition, specifies that each of its members (other than zero-width bit-fields) is placed to minimize the memory required. This is equivalent to specifying the &lt;code&gt;packed&lt;/code&gt; attribute on each of the members.</source>
          <target state="translated">Этот атрибут, присоединенный к определению типа &lt;code&gt;struct&lt;/code&gt; , &lt;code&gt;union&lt;/code&gt; или &lt;code&gt;class&lt;/code&gt; C ++ , указывает, что каждый из его членов (кроме битовых полей нулевой ширины) помещается для минимизации требуемой памяти. Это эквивалентно указанию &lt;code&gt;packed&lt;/code&gt; атрибута для каждого из членов.</target>
        </trans-unit>
        <trans-unit id="f26328ece7307f514a47cc876ff83560893a099c" translate="yes" xml:space="preserve">
          <source>This attribute, attached to a &lt;code&gt;union&lt;/code&gt; type definition, indicates that any function parameter having that union type causes calls to that function to be treated in a special way.</source>
          <target state="translated">Этот атрибут, присоединенный к определению типа &lt;code&gt;union&lt;/code&gt; , указывает, что любой параметр функции, имеющий этот тип объединения, вызывает особую обработку вызовов этой функции.</target>
        </trans-unit>
        <trans-unit id="dea2c8428220fbb29ff9bb397fcc0cd8bc82fcc8" translate="yes" xml:space="preserve">
          <source>This attribute, attached to a function, means that code must be emitted for the function even if it appears that the function is not referenced. This is useful, for example, when the function is referenced only in inline assembly.</source>
          <target state="translated">Данный атрибут,прикрепленный к функции,означает,что код должен быть выдан для функции,даже если кажется,что на функцию нет ссылок.Это полезно,например,когда на функцию дается ссылка только в последовательном сборе.</target>
        </trans-unit>
        <trans-unit id="f26a8e83a7c29f151aef9f7d69a0073e42ed7b63" translate="yes" xml:space="preserve">
          <source>This attribute, attached to a function, means that the function is meant to be possibly unused. GCC does not produce a warning for this function.</source>
          <target state="translated">Этот атрибут,прикрепленный к функции,означает,что функция предназначена для возможного неиспользования.GCC не выдает предупреждение для этой функции.</target>
        </trans-unit>
        <trans-unit id="0cda8d2a406df80f5c3c1e70abd61657e961b09d" translate="yes" xml:space="preserve">
          <source>This attribute, attached to a global variable or function, nullifies the effect of the</source>
          <target state="translated">Этот атрибут,привязанный к глобальной переменной или функции,сводит на нет эффект от</target>
        </trans-unit>
        <trans-unit id="b693f4e1b31df32d21cd97a87984062ca5cf0e7b" translate="yes" xml:space="preserve">
          <source>This attribute, attached to a variable with static storage, means that the variable must be emitted even if it appears that the variable is not referenced.</source>
          <target state="translated">Этот атрибут,прикрепленный к переменной со статическим запоминающим устройством,означает,что переменная должна излучаться,даже если кажется,что на нее нет ссылок.</target>
        </trans-unit>
        <trans-unit id="09cf2bdd650a42affb72357abc94b2d76134170c" translate="yes" xml:space="preserve">
          <source>This attribute, attached to a variable, means that the variable is meant to be possibly unused. GCC does not produce a warning for this variable.</source>
          <target state="translated">Этот атрибут,привязанный к переменной,означает,что переменная предназначена для возможного неиспользования.GCC не выдает предупреждение для этой переменной.</target>
        </trans-unit>
        <trans-unit id="f6a9f3d41b5e82d7b9c83b17f60c49a3dab84962" translate="yes" xml:space="preserve">
          <source>This behavior may seem silly, but it&amp;rsquo;s what the ISO standard specifies. It is easy enough for you to make your code work by moving the definition of &lt;code&gt;struct mumble&lt;/code&gt; above the prototype. It&amp;rsquo;s not worth being incompatible with ISO C just to avoid an error for the example shown above.</source>
          <target state="translated">Такое поведение может показаться глупым, но это то, что определяет стандарт ISO. Вам достаточно легко заставить ваш код работать, переместив определение &lt;code&gt;struct mumble&lt;/code&gt; над прототипом. Не стоит быть несовместимым с ISO C, чтобы избежать ошибки в примере, показанном выше.</target>
        </trans-unit>
        <trans-unit id="8818c6d89ffa44c89646c897a4e574f7b71484ee" translate="yes" xml:space="preserve">
          <source>This built-in can be used to determine the current transaction state using the following code example:</source>
          <target state="translated">Данная встроенная функция может быть использована для определения текущего состояния транзакции на следующем примере кода:</target>
        </trans-unit>
        <trans-unit id="92883b24f84fe55e50f3d20ded0b1b0331344202" translate="yes" xml:space="preserve">
          <source>This built-in function acts as a synchronization fence between a thread and signal handlers based in the same thread.</source>
          <target state="translated">Эта встроенная функция действует как синхронизационное ограждение между обработчиками сигналов и потоком,находящимся в одном потоке.</target>
        </trans-unit>
        <trans-unit id="5a20473e8d5898eb62d474e73fb635a7caf013c9" translate="yes" xml:space="preserve">
          <source>This built-in function acts as a synchronization fence between threads based on the specified memory order.</source>
          <target state="translated">Эта встроенная функция действует как ограждение синхронизации между потоками на основе заданного порядка памяти.</target>
        </trans-unit>
        <trans-unit id="8c179d50784fac3eee427384f1e34f1d0ea28d01" translate="yes" xml:space="preserve">
          <source>This built-in function can be used to help mitigate against unsafe speculative execution. &lt;var&gt;type&lt;/var&gt; may be any integral type or any pointer type.</source>
          <target state="translated">Эту встроенную функцию можно использовать для предотвращения небезопасного спекулятивного исполнения. &lt;var&gt;type&lt;/var&gt; может быть любым целым типом или любым типом указателя.</target>
        </trans-unit>
        <trans-unit id="cdfcca8b913445e45652ce81bc13dc531eb31f5a" translate="yes" xml:space="preserve">
          <source>This built-in function can return an lvalue if the chosen argument is an lvalue.</source>
          <target state="translated">Эта встроенная функция может возвращать значение l,если выбранным аргументом является lvalue.</target>
        </trans-unit>
        <trans-unit id="42b10a642d35506bdb301b36c3b2dbb7b1a29af0" translate="yes" xml:space="preserve">
          <source>This built-in function ignores top level qualifiers (e.g., &lt;code&gt;const&lt;/code&gt;, &lt;code&gt;volatile&lt;/code&gt;). For example, &lt;code&gt;int&lt;/code&gt; is equivalent to &lt;code&gt;const
int&lt;/code&gt;.</source>
          <target state="translated">Эта встроенная функция игнорирует квалификаторы верхнего уровня (например, &lt;code&gt;const&lt;/code&gt; , &lt;code&gt;volatile&lt;/code&gt; ). Например, &lt;code&gt;int&lt;/code&gt; эквивалентно &lt;code&gt;const int&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="de3196f175db1b7bf9e191bc879315daa8c8ea4f" translate="yes" xml:space="preserve">
          <source>This built-in function implements an atomic compare and exchange operation. This compares the contents of &lt;code&gt;*&lt;var&gt;ptr&lt;/var&gt;&lt;/code&gt; with the contents of &lt;code&gt;*&lt;var&gt;expected&lt;/var&gt;&lt;/code&gt;. If equal, the operation is a &lt;em&gt;read-modify-write&lt;/em&gt; operation that writes &lt;var&gt;desired&lt;/var&gt; into &lt;code&gt;*&lt;var&gt;ptr&lt;/var&gt;&lt;/code&gt;. If they are not equal, the operation is a &lt;em&gt;read&lt;/em&gt; and the current contents of &lt;code&gt;*&lt;var&gt;ptr&lt;/var&gt;&lt;/code&gt; are written into &lt;code&gt;*&lt;var&gt;expected&lt;/var&gt;&lt;/code&gt;. &lt;var&gt;weak&lt;/var&gt; is &lt;code&gt;true&lt;/code&gt; for weak compare_exchange, which may fail spuriously, and &lt;code&gt;false&lt;/code&gt; for the strong variation, which never fails spuriously. Many targets only offer the strong variation and ignore the parameter. When in doubt, use the strong variation.</source>
          <target state="translated">Эта встроенная функция реализует атомарную операцию сравнения и обмена. Это сравнивает содержимое &lt;code&gt;*&lt;var&gt;ptr&lt;/var&gt;&lt;/code&gt; с содержимым &lt;code&gt;*&lt;var&gt;expected&lt;/var&gt;&lt;/code&gt; * . Если равно, то операция представляет собой операцию &lt;em&gt;чтения-изменения-записи,&lt;/em&gt; которая записывает &lt;var&gt;desired&lt;/var&gt; в &lt;code&gt;*&lt;var&gt;ptr&lt;/var&gt;&lt;/code&gt; . Если они не равны, выполняется &lt;em&gt;чтение,&lt;/em&gt; и текущее содержимое &lt;code&gt;*&lt;var&gt;ptr&lt;/var&gt;&lt;/code&gt; записывается в &lt;code&gt;*&lt;var&gt;expected&lt;/var&gt;&lt;/code&gt; . &lt;var&gt;weak&lt;/var&gt; это &lt;code&gt;true&lt;/code&gt; для слабых compare_exchange, которые могут не поддельно, и &lt;code&gt;false&lt;/code&gt; для сильного варианта, который никогда не терпит неудач. Многие цели предлагают только сильные вариации и игнорируют параметр. Если сомневаетесь, используйте сильную вариацию.</target>
        </trans-unit>
        <trans-unit id="56f42bd96c55f1e604c896fe2e73d0e93c4e17e7" translate="yes" xml:space="preserve">
          <source>This built-in function implements an atomic exchange operation. It writes &lt;var&gt;val&lt;/var&gt; into &lt;code&gt;*&lt;var&gt;ptr&lt;/var&gt;&lt;/code&gt;, and returns the previous contents of &lt;code&gt;*&lt;var&gt;ptr&lt;/var&gt;&lt;/code&gt;.</source>
          <target state="translated">Эта встроенная функция реализует операцию атомарного обмена. Он записывает &lt;var&gt;val&lt;/var&gt; в &lt;code&gt;*&lt;var&gt;ptr&lt;/var&gt;&lt;/code&gt; и возвращает предыдущее содержимое &lt;code&gt;*&lt;var&gt;ptr&lt;/var&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e39a26f774d21850134f1ad4ec8601fd024a4508" translate="yes" xml:space="preserve">
          <source>This built-in function implements an atomic load operation. It returns the contents of &lt;code&gt;*&lt;var&gt;ptr&lt;/var&gt;&lt;/code&gt;.</source>
          <target state="translated">Эта встроенная функция реализует операцию атомарной загрузки. Он возвращает содержимое &lt;code&gt;*&lt;var&gt;ptr&lt;/var&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6b2685600611aa3929789e72b13593b02a524004" translate="yes" xml:space="preserve">
          <source>This built-in function implements an atomic store operation. It writes &lt;code&gt;&lt;var&gt;val&lt;/var&gt;&lt;/code&gt; into &lt;code&gt;*&lt;var&gt;ptr&lt;/var&gt;&lt;/code&gt;.</source>
          <target state="translated">Эта встроенная функция реализует операцию атомарного хранилища. Он записывает &lt;code&gt;&lt;var&gt;val&lt;/var&gt;&lt;/code&gt; в &lt;code&gt;*&lt;var&gt;ptr&lt;/var&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ea16c3e951ac6e4e93bda6af660c19a372791953" translate="yes" xml:space="preserve">
          <source>This built-in function implements the generic version of &lt;code&gt;__atomic_compare_exchange&lt;/code&gt;. The function is virtually identical to &lt;code&gt;__atomic_compare_exchange_n&lt;/code&gt;, except the desired value is also a pointer.</source>
          <target state="translated">Эта встроенная функция реализует общую версию &lt;code&gt;__atomic_compare_exchange&lt;/code&gt; . Функция практически идентична &lt;code&gt;__atomic_compare_exchange_n&lt;/code&gt; , за исключением того, что желаемое значение также является указателем.</target>
        </trans-unit>
        <trans-unit id="8296c6507414677ec38273521ab8df96daa500be" translate="yes" xml:space="preserve">
          <source>This built-in function invokes &lt;var&gt;function&lt;/var&gt; with a copy of the parameters described by &lt;var&gt;arguments&lt;/var&gt; and &lt;var&gt;size&lt;/var&gt;.</source>
          <target state="translated">Эта встроенная функция вызывает &lt;var&gt;function&lt;/var&gt; с копией параметров, описанных &lt;var&gt;arguments&lt;/var&gt; и &lt;var&gt;size&lt;/var&gt; .</target>
        </trans-unit>
        <trans-unit id="8f5c4780f25bedcea7655683b3a1f0ac5e0f5ed0" translate="yes" xml:space="preserve">
          <source>This built-in function is analogous to the &amp;lsquo;</source>
          <target state="translated">Эта встроенная функция аналогична '</target>
        </trans-unit>
        <trans-unit id="6e1bff7892551ba3b77dbb599f93fb2a84f960cc" translate="yes" xml:space="preserve">
          <source>This built-in function is not a full barrier, but rather a &lt;em&gt;release barrier&lt;/em&gt;. This means that all previous memory stores are globally visible, and all previous memory loads have been satisfied, but following memory reads are not prevented from being speculated to before the barrier.</source>
          <target state="translated">Эта встроенная функция не является полным барьером, а скорее &lt;em&gt;препятствием для освобождения&lt;/em&gt; . Это означает, что все предыдущие хранилища памяти являются глобально видимыми, и все предыдущие загрузки памяти были удовлетворены, но не предотвращается предположение о последующих чтениях памяти до барьера.</target>
        </trans-unit>
        <trans-unit id="d70719484366a8b3c252ddc3ff84790bc06cc3ad" translate="yes" xml:space="preserve">
          <source>This built-in function is not a full barrier, but rather an &lt;em&gt;acquire barrier&lt;/em&gt;. This means that references after the operation cannot move to (or be speculated to) before the operation, but previous memory stores may not be globally visible yet, and previous memory loads may not yet be satisfied.</source>
          <target state="translated">Эта встроенная функция не является полным препятствием, а скорее &lt;em&gt;препятствием&lt;/em&gt; для &lt;em&gt;приобретения&lt;/em&gt; . Это означает, что ссылки после операции не могут перемещаться (или предполагаться) до операции, но предыдущие хранилища памяти могут еще не быть глобально видимыми, а предыдущие загрузки памяти могут еще не выполняться.</target>
        </trans-unit>
        <trans-unit id="073757ac658ed7f6a9f1d03295b93f00125aefcc" translate="yes" xml:space="preserve">
          <source>This built-in function issues a full memory barrier.</source>
          <target state="translated">Эта встроенная функция создает полный барьер памяти.</target>
        </trans-unit>
        <trans-unit id="7e033b3b4f9c857696bc2244ed32f0a7d140cd57" translate="yes" xml:space="preserve">
          <source>This built-in function performs an atomic clear operation on &lt;code&gt;*&lt;var&gt;ptr&lt;/var&gt;&lt;/code&gt;. After the operation, &lt;code&gt;*&lt;var&gt;ptr&lt;/var&gt;&lt;/code&gt; contains 0. It should be only used for operands of type &lt;code&gt;bool&lt;/code&gt; or &lt;code&gt;char&lt;/code&gt; and in conjunction with &lt;code&gt;__atomic_test_and_set&lt;/code&gt;. For other types it may only clear partially. If the type is not &lt;code&gt;bool&lt;/code&gt; prefer using &lt;code&gt;__atomic_store&lt;/code&gt;.</source>
          <target state="translated">Эта встроенная функция выполняет атомарную операцию очистки &lt;code&gt;*&lt;var&gt;ptr&lt;/var&gt;&lt;/code&gt; . После операции &lt;code&gt;*&lt;var&gt;ptr&lt;/var&gt;&lt;/code&gt; содержит 0. Его следует использовать только для операндов типа &lt;code&gt;bool&lt;/code&gt; или &lt;code&gt;char&lt;/code&gt; и в сочетании с &lt;code&gt;__atomic_test_and_set&lt;/code&gt; . Для других типов он может очищаться только частично. Если тип не является &lt;code&gt;bool&lt;/code&gt; предпочтительнее использовать &lt;code&gt;__atomic_store&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b9c97edabae382ebead73a4652d8d69259efed11" translate="yes" xml:space="preserve">
          <source>This built-in function performs an atomic test-and-set operation on the byte at &lt;code&gt;*&lt;var&gt;ptr&lt;/var&gt;&lt;/code&gt;. The byte is set to some implementation defined nonzero &amp;ldquo;set&amp;rdquo; value and the return value is &lt;code&gt;true&lt;/code&gt; if and only if the previous contents were &amp;ldquo;set&amp;rdquo;. It should be only used for operands of type &lt;code&gt;bool&lt;/code&gt; or &lt;code&gt;char&lt;/code&gt;. For other types only part of the value may be set.</source>
          <target state="translated">Эта встроенная функция выполняет атомарную операцию проверки и установки для байта в &lt;code&gt;*&lt;var&gt;ptr&lt;/var&gt;&lt;/code&gt; . Байт устанавливается в определенное реализацией ненулевое &amp;laquo;установленное&amp;raquo; значение, а возвращаемое значение &lt;code&gt;true&lt;/code&gt; тогда и только тогда, когда предыдущее содержимое было &amp;laquo;установлено&amp;raquo;. Его следует использовать только для операндов типа &lt;code&gt;bool&lt;/code&gt; или &lt;code&gt;char&lt;/code&gt; . Для других типов может быть установлена ​​только часть значения.</target>
        </trans-unit>
        <trans-unit id="b288561de8012f0a5e9cadf66cc0631f6c354855" translate="yes" xml:space="preserve">
          <source>This built-in function releases the lock acquired by &lt;code&gt;__sync_lock_test_and_set&lt;/code&gt;. Normally this means writing the constant 0 to &lt;code&gt;*&lt;var&gt;ptr&lt;/var&gt;&lt;/code&gt;.</source>
          <target state="translated">Эта встроенная функция снимает блокировку, установленную &lt;code&gt;__sync_lock_test_and_set&lt;/code&gt; . Обычно это означает запись константы 0 в &lt;code&gt;*&lt;var&gt;ptr&lt;/var&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6fbd055aee266ab03001d14151e03de46793e79e" translate="yes" xml:space="preserve">
          <source>This built-in function represents all anonymous arguments of an inline function. It can be used only in inline functions that are always inlined, never compiled as a separate function, such as those using &lt;code&gt;__attribute__ ((__always_inline__))&lt;/code&gt; or &lt;code&gt;__attribute__ ((__gnu_inline__))&lt;/code&gt; extern inline functions. It must be only passed as last argument to some other function with variable arguments. This is useful for writing small wrapper inlines for variable argument functions, when using preprocessor macros is undesirable. For example:</source>
          <target state="translated">Эта встроенная функция представляет все анонимные аргументы встроенной функции. Его можно использовать только во встроенных функциях, которые всегда встроены, никогда не компилируются как отдельная функция, например те, которые используют &lt;code&gt;__attribute__ ((__always_inline__))&lt;/code&gt; или &lt;code&gt;__attribute__ ((__gnu_inline__))&lt;/code&gt; extern встроенные функции. Он должен быть передан только в качестве последнего аргумента какой-либо другой функции с переменными аргументами. Это полезно для написания небольших встроенных оберток для функций с переменными аргументами, когда использование макросов препроцессора нежелательно. Например:</target>
        </trans-unit>
        <trans-unit id="a645e8bd97d4c4a4974b86fe42f50e43f5945898" translate="yes" xml:space="preserve">
          <source>This built-in function returns 1 if the unqualified versions of the types &lt;var&gt;type1&lt;/var&gt; and &lt;var&gt;type2&lt;/var&gt; (which are types, not expressions) are compatible, 0 otherwise. The result of this built-in function can be used in integer constant expressions.</source>
          <target state="translated">Эта встроенная функция возвращает 1, если неквалифицированные версии типов &lt;var&gt;type1&lt;/var&gt; и &lt;var&gt;type2&lt;/var&gt; (которые являются типами, а не выражениями) совместимы, в противном случае - 0. Результат этой встроенной функции можно использовать в целочисленных постоянных выражениях.</target>
        </trans-unit>
        <trans-unit id="adfe1d809ee98496092f61c8ed5ff01343455bef" translate="yes" xml:space="preserve">
          <source>This built-in function returns &lt;code&gt;true&lt;/code&gt; if objects of &lt;var&gt;size&lt;/var&gt; bytes always generate lock-free atomic instructions for the target architecture. &lt;var&gt;size&lt;/var&gt; must resolve to a compile-time constant and the result also resolves to a compile-time constant.</source>
          <target state="translated">Эта встроенная функция возвращает &lt;code&gt;true&lt;/code&gt; если объекты &lt;var&gt;size&lt;/var&gt; байты всегда генерируют безблокирующие атомарные инструкции для целевой архитектуры. &lt;var&gt;size&lt;/var&gt; должен разрешаться в константу времени компиляции, а результат также разрешается в константу времени компиляции.</target>
        </trans-unit>
        <trans-unit id="81bd1267444e0c22cd6d3d40974c7c8c9aa88d05" translate="yes" xml:space="preserve">
          <source>This built-in function returns &lt;code&gt;true&lt;/code&gt; if objects of &lt;var&gt;size&lt;/var&gt; bytes always generate lock-free atomic instructions for the target architecture. If the built-in function is not known to be lock-free, a call is made to a runtime routine named &lt;code&gt;__atomic_is_lock_free&lt;/code&gt;.</source>
          <target state="translated">Эта встроенная функция возвращает &lt;code&gt;true&lt;/code&gt; если объекты &lt;var&gt;size&lt;/var&gt; байты всегда генерируют безблокирующие атомарные инструкции для целевой архитектуры. Если неизвестно, что встроенная функция свободна от блокировки, выполняется вызов подпрограммы времени выполнения с именем &lt;code&gt;__atomic_is_lock_free&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7c6d5e134400518a60b0f022ce70bc3a88ebfc9d" translate="yes" xml:space="preserve">
          <source>This built-in function returns a pointer to data describing how to perform a call with the same arguments as are passed to the current function.</source>
          <target state="translated">Эта встроенная функция возвращает указатель на данные,описывающие,как выполнить вызов с теми же аргументами,которые передаются в текущую функцию.</target>
        </trans-unit>
        <trans-unit id="a965c005ba35ec687e9a6eef5b255a00ddffc5d3" translate="yes" xml:space="preserve">
          <source>This built-in function returns the number of anonymous arguments of an inline function. It can be used only in inline functions that are always inlined, never compiled as a separate function, such as those using &lt;code&gt;__attribute__ ((__always_inline__))&lt;/code&gt; or &lt;code&gt;__attribute__ ((__gnu_inline__))&lt;/code&gt; extern inline functions. For example following does link- or run-time checking of open arguments for optimized code:</source>
          <target state="translated">Эта встроенная функция возвращает количество анонимных аргументов встроенной функции. Его можно использовать только во встроенных функциях, которые всегда встроены, никогда не компилируются как отдельные функции, например, те, которые используют &lt;code&gt;__attribute__ ((__always_inline__))&lt;/code&gt; или &lt;code&gt;__attribute__ ((__gnu_inline__))&lt;/code&gt; extern встроенные функции. Например, ниже выполняется проверка ссылок или времени выполнения открытых аргументов для оптимизированного кода:</target>
        </trans-unit>
        <trans-unit id="23a152f3eb0d609efeaccc0dfd600b3f1ca33a36" translate="yes" xml:space="preserve">
          <source>This built-in function returns the value described by &lt;var&gt;result&lt;/var&gt; from the containing function. You should specify, for &lt;var&gt;result&lt;/var&gt;, a value returned by &lt;code&gt;__builtin_apply&lt;/code&gt;.</source>
          <target state="translated">Эта встроенная функция возвращает значение, описываемое &lt;var&gt;result&lt;/var&gt; содержащейся функции. Вы должны указать, для &lt;var&gt;result&lt;/var&gt; , значение , возвращаемое &lt;code&gt;__builtin_apply&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="93f8e4f9c5ee35c6668a2b80b5a01f58cf7b3cac" translate="yes" xml:space="preserve">
          <source>This built-in function, as described by Intel, is not a traditional test-and-set operation, but rather an atomic exchange operation. It writes &lt;var&gt;value&lt;/var&gt; into &lt;code&gt;*&lt;var&gt;ptr&lt;/var&gt;&lt;/code&gt;, and returns the previous contents of &lt;code&gt;*&lt;var&gt;ptr&lt;/var&gt;&lt;/code&gt;.</source>
          <target state="translated">Эта встроенная функция, как описано в Intel, не является традиционной операцией &amp;laquo;тест-установка&amp;raquo;, а скорее операцией атомарного обмена. Он записывает &lt;var&gt;value&lt;/var&gt; в &lt;code&gt;*&lt;var&gt;ptr&lt;/var&gt;&lt;/code&gt; и возвращает предыдущее содержимое &lt;code&gt;*&lt;var&gt;ptr&lt;/var&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="568a9d62c8cf52e8d6dd28fe3fede9225dfafd5c" translate="yes" xml:space="preserve">
          <source>This built-in implements the C99 fpclassify functionality. The first five int arguments should be the target library&amp;rsquo;s notion of the possible FP classes and are used for return values. They must be constant values and they must appear in this order: &lt;code&gt;FP_NAN&lt;/code&gt;, &lt;code&gt;FP_INFINITE&lt;/code&gt;, &lt;code&gt;FP_NORMAL&lt;/code&gt;, &lt;code&gt;FP_SUBNORMAL&lt;/code&gt; and &lt;code&gt;FP_ZERO&lt;/code&gt;. The ellipsis is for exactly one floating-point value to classify. GCC treats the last argument as type-generic, which means it does not do default promotion from float to double.</source>
          <target state="translated">Этот встроенный реализует функциональность C99 fpclassify. Первые пять аргументов типа int должны быть представлением целевой библиотеки о возможных классах FP и использоваться для возвращаемых значений. Они должны быть постоянными значениями и располагаться в следующем порядке: &lt;code&gt;FP_NAN&lt;/code&gt; , &lt;code&gt;FP_INFINITE&lt;/code&gt; , &lt;code&gt;FP_NORMAL&lt;/code&gt; , &lt;code&gt;FP_SUBNORMAL&lt;/code&gt; и &lt;code&gt;FP_ZERO&lt;/code&gt; . Многоточие предназначено для классификации только одного значения с плавающей запятой. GCC обрабатывает последний аргумент как универсальный, что означает, что он не выполняет продвижение по умолчанию с float на double.</target>
        </trans-unit>
        <trans-unit id="de56bb64bcd269982e143b48fca7664ac4ccd934" translate="yes" xml:space="preserve">
          <source>This built-in takes a byte address to the 24-bit &lt;a href=&quot;named-address-spaces#AVR-Named-Address-Spaces&quot;&gt;address space&lt;/a&gt;&lt;code&gt;__memx&lt;/code&gt; and returns the number of the flash segment (the 64 KiB chunk) where the address points to. Counting starts at &lt;code&gt;0&lt;/code&gt;. If the address does not point to flash memory, return &lt;code&gt;-1&lt;/code&gt;.</source>
          <target state="translated">Эта встроенная &lt;code&gt;__memx&lt;/code&gt; принимает байтовый адрес в 24-битное &lt;a href=&quot;named-address-spaces#AVR-Named-Address-Spaces&quot;&gt;адресное пространство &lt;/a&gt;__memx и возвращает номер сегмента флэш-памяти (блок размером 64 КиБ), на который указывает адрес. Подсчет начинается с &lt;code&gt;0&lt;/code&gt; . Если адрес не указывает на флэш-память, верните &lt;code&gt;-1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="12afcfe5b0cb2421e366cb4bf6d262a7225b43e1" translate="yes" xml:space="preserve">
          <source>This calling convention is incompatible with the one normally used on Unix, so you cannot use it if you need to call libraries compiled with the Unix compiler.</source>
          <target state="translated">Это соглашение о вызовах несовместимо с соглашением,обычно используемым на Unix,поэтому вы не можете использовать его,если вам нужно вызвать библиотеки,скомпилированные с компилятором Unix.</target>
        </trans-unit>
        <trans-unit id="c59930047a3dbe1a0da0d3c55b5832603831020b" translate="yes" xml:space="preserve">
          <source>This can be a suitable option for application code written for the Borland model, as it usually just works. Code written for the Cfront model needs to be modified so that the template definitions are available at one or more points of instantiation; usually this is as simple as adding &lt;code&gt;#include &amp;lt;tmethods.cc&amp;gt;&lt;/code&gt; to the end of each template header.</source>
          <target state="translated">Это может быть подходящим вариантом для кода приложения, написанного для модели Borland, поскольку обычно он просто работает. Код, написанный для модели Cfront, необходимо изменить, чтобы определения шаблона были доступны в одной или нескольких точках создания экземпляров; обычно это так же просто, как добавление &lt;code&gt;#include &amp;lt;tmethods.cc&amp;gt;&lt;/code&gt; в конец каждого заголовка шаблона.</target>
        </trans-unit>
        <trans-unit id="8138fe5070f142675bd6f047c11ca6604b5e4b89" translate="yes" xml:space="preserve">
          <source>This causes GCC&amp;rsquo;s output file to have the &amp;lsquo;</source>
          <target state="translated">Это приводит к тому, что выходной файл GCC имеет '</target>
        </trans-unit>
        <trans-unit id="0b096441ddb3f545a4e7491763e07ff42aa42c7a" translate="yes" xml:space="preserve">
          <source>This causes an error messages saying:</source>
          <target state="translated">Это вызывает сообщения об ошибках:</target>
        </trans-unit>
        <trans-unit id="37b13c019e57e81567c1e4f0f77d055f628a1482" translate="yes" xml:space="preserve">
          <source>This clears the indicated bits in the saved copy of the status register currently residing on the stack. This only works inside interrupt handlers and the changes to the status register will only take affect once the handler returns.</source>
          <target state="translated">Это очищает указанные биты в сохраненной копии реестра состояния,находящейся в настоящее время в стеке.Это работает только внутри обработчиков прерываний,и изменения в статусном регистре будут действовать только после возвращения обработчика.</target>
        </trans-unit>
        <trans-unit id="52348806f9132146a3d5c83435b59d49467218d2" translate="yes" xml:space="preserve">
          <source>This code copies &lt;code&gt;src&lt;/code&gt; to &lt;code&gt;dst&lt;/code&gt; and add 1 to &lt;code&gt;dst&lt;/code&gt;.</source>
          <target state="translated">Этот код копирует &lt;code&gt;src&lt;/code&gt; в &lt;code&gt;dst&lt;/code&gt; и добавляет 1 к &lt;code&gt;dst&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5a1cd197f5f5bea21b21e4898acbd5a40235dc12" translate="yes" xml:space="preserve">
          <source>This code makes no use of the optional &lt;var&gt;asmSymbolicName&lt;/var&gt;. Therefore it references the first output operand as &lt;code&gt;%0&lt;/code&gt; (were there a second, it would be &lt;code&gt;%1&lt;/code&gt;, etc). The number of the first input operand is one greater than that of the last output operand. In this i386 example, that makes &lt;code&gt;Mask&lt;/code&gt; referenced as &lt;code&gt;%1&lt;/code&gt;:</source>
          <target state="translated">В этом коде не используется необязательный &lt;var&gt;asmSymbolicName&lt;/var&gt; . Поэтому он ссылается на первый выходной операнд как на &lt;code&gt;%0&lt;/code&gt; (если бы был второй, это был бы &lt;code&gt;%1&lt;/code&gt; и т. Д.). Номер первого входного операнда на единицу больше, чем номер последнего выходного операнда. В этом примере i386 &lt;code&gt;Mask&lt;/code&gt; указывается как &lt;code&gt;%1&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="f9f2247acfc64bac06fade1fb9f20f85e4652f3a" translate="yes" xml:space="preserve">
          <source>This code really is erroneous, because the scope of &lt;code&gt;struct
mumble&lt;/code&gt; in the prototype is limited to the argument list containing it. It does not refer to the &lt;code&gt;struct mumble&lt;/code&gt; defined with file scope immediately below&amp;mdash;they are two unrelated types with similar names in different scopes.</source>
          <target state="translated">Этот код действительно ошибочен, потому что объем &lt;code&gt;struct mumble&lt;/code&gt; в прототипе ограничен списком аргументов, содержащим его. Он не относится к &lt;code&gt;struct mumble&lt;/code&gt; , определенной с областью действия файла непосредственно ниже - это два несвязанных типа с похожими именами в разных областях.</target>
        </trans-unit>
        <trans-unit id="337163816650f5c7db30e6d4ef7d7194c7c7dcdf" translate="yes" xml:space="preserve">
          <source>This code runs unconditionally on all 64-bit processors. For 32-bit processors the code runs on those that support multi-byte NOP instructions.</source>
          <target state="translated">Данный код работает безоговорочно на всех 64-битных процессорах.Для 32-битных процессоров код выполняется на тех,которые поддерживают многобайтовые NOP инструкции.</target>
        </trans-unit>
        <trans-unit id="5f60ecfa36c1d209e897848d1465d421ffe66fd4" translate="yes" xml:space="preserve">
          <source>This code says that input &lt;code&gt;b&lt;/code&gt; is not popped by the &lt;code&gt;asm&lt;/code&gt;, and that the &lt;code&gt;asm&lt;/code&gt; pushes a result onto the reg-stack, i.e., the stack is one deeper after the &lt;code&gt;asm&lt;/code&gt; than it was before. But, it is possible that reload may think that it can use the same register for both the input and the output.</source>
          <target state="translated">Этот код говорит, что вход &lt;code&gt;b&lt;/code&gt; не извлекается из &lt;code&gt;asm&lt;/code&gt; , и что &lt;code&gt;asm&lt;/code&gt; помещает результат в reg-стек, т. Е. Стек на один глубже после &lt;code&gt;asm&lt;/code&gt; , чем был раньше. Но возможно, что reload может подумать, что он может использовать один и тот же регистр как для ввода, так и для вывода.</target>
        </trans-unit>
        <trans-unit id="5158b0e232baa68e812ae0b3c5ff1e7b6dd2495a" translate="yes" xml:space="preserve">
          <source>This combination of &lt;code&gt;inline&lt;/code&gt; and &lt;code&gt;extern&lt;/code&gt; has almost the effect of a macro. The way to use it is to put a function definition in a header file with these keywords, and put another copy of the definition (lacking &lt;code&gt;inline&lt;/code&gt; and &lt;code&gt;extern&lt;/code&gt;) in a library file. The definition in the header file causes most calls to the function to be inlined. If any uses of the function remain, they refer to the single copy in the library.</source>
          <target state="translated">Эта комбинация &lt;code&gt;inline&lt;/code&gt; и &lt;code&gt;extern&lt;/code&gt; имеет почти эффект макроса. Способ его использования - поместить определение функции в файл заголовка с этими ключевыми словами и поместить другую копию определения (без &lt;code&gt;inline&lt;/code&gt; и &lt;code&gt;extern&lt;/code&gt; ) в файл библиотеки. Определение в файле заголовка заставляет большинство вызовов функции быть встроенными. Если какие-либо варианты использования функции остаются, они относятся к единственной копии в библиотеке.</target>
        </trans-unit>
        <trans-unit id="b81343c69409df406d64f943e849b1b69e1c3338" translate="yes" xml:space="preserve">
          <source>This construct outputs &lt;code&gt;dialect0&lt;/code&gt; when using dialect #0 to compile the code, &lt;code&gt;dialect1&lt;/code&gt; for dialect #1, etc. If there are fewer alternatives within the braces than the number of dialects the compiler supports, the construct outputs nothing.</source>
          <target state="translated">Эта конструкция выводит &lt;code&gt;dialect0&lt;/code&gt; при использовании диалекта № 0 для компиляции кода, &lt;code&gt;dialect1&lt;/code&gt; для диалекта № 1 и т. Д. Если в фигурных скобках меньше альтернатив, чем количество диалектов, поддерживаемых компилятором, конструкция ничего не выводит.</target>
        </trans-unit>
        <trans-unit id="4418d19029db54262a2982d0fc11517ca360b079" translate="yes" xml:space="preserve">
          <source>This could also be written using a statement expression:</source>
          <target state="translated">Это также может быть написано с использованием выражения высказывания:</target>
        </trans-unit>
        <trans-unit id="d3561933d5b27303ad0b1eed1db35f7bce90fa0b" translate="yes" xml:space="preserve">
          <source>This declaration only establishes that the class &lt;code&gt;Foo&lt;/code&gt; has an &lt;code&gt;int&lt;/code&gt; named &lt;code&gt;Foo::bar&lt;/code&gt;, and a member function named &lt;code&gt;Foo::method&lt;/code&gt;. But you still need to define &lt;em&gt;both&lt;/em&gt;&lt;code&gt;method&lt;/code&gt; and &lt;code&gt;bar&lt;/code&gt; elsewhere. According to the ISO standard, you must supply an initializer in one (and only one) source file, such as:</source>
          <target state="translated">Это объявление только устанавливает, что у класса &lt;code&gt;Foo&lt;/code&gt; есть &lt;code&gt;int&lt;/code&gt; с именем &lt;code&gt;Foo::bar&lt;/code&gt; и функция-член с именем &lt;code&gt;Foo::method&lt;/code&gt; . Но вам все равно нужно определить &lt;em&gt;как &lt;/em&gt; &lt;code&gt;method&lt;/code&gt; и &lt;code&gt;bar&lt;/code&gt; другом месте. Согласно стандарту ISO, вы должны предоставить инициализатор в одном (и только одном) исходном файле, например:</target>
        </trans-unit>
        <trans-unit id="aa5d48aae2a8d70a04aa98c11ed292ce987fe6e4" translate="yes" xml:space="preserve">
          <source>This declares &lt;code&gt;y&lt;/code&gt; as an array of pointers to characters:</source>
          <target state="translated">Это объявляет &lt;code&gt;y&lt;/code&gt; как массив указателей на символы:</target>
        </trans-unit>
        <trans-unit id="d5984e00c4ab800b89abb234fbcf6672036013a3" translate="yes" xml:space="preserve">
          <source>This declares &lt;code&gt;y&lt;/code&gt; as an array of such values.</source>
          <target state="translated">Это объявляет &lt;code&gt;y&lt;/code&gt; как массив таких значений.</target>
        </trans-unit>
        <trans-unit id="1cddb3ab7751ac13216d638e5a732f674e3c8eeb" translate="yes" xml:space="preserve">
          <source>This declares &lt;code&gt;y&lt;/code&gt; with the type of what &lt;code&gt;x&lt;/code&gt; points to.</source>
          <target state="translated">Это объявляет &lt;code&gt;y&lt;/code&gt; с типом того, на что указывает &lt;code&gt;x&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="faab4d37a48d574a707b33549eb07bcf03d70747" translate="yes" xml:space="preserve">
          <source>This deduction was implemented as a possible extension to the originally proposed semantics for the C++11 standard, but was not part of the final standard, so it is disabled by default. This option is deprecated, and may be removed in a future version of G++.</source>
          <target state="translated">Этот вычет был реализован как возможное расширение изначально предложенной семантики для стандарта C++11,но не являлся частью финального стандарта,поэтому по умолчанию он отключен.Эта опция устарела,и может быть удалена в будущей версии G++.</target>
        </trans-unit>
        <trans-unit id="c879d3e8cb77a4fc10b608d3eb2285203202e61b" translate="yes" xml:space="preserve">
          <source>This defaults to &amp;lsquo;</source>
          <target state="translated">По умолчанию это '</target>
        </trans-unit>
        <trans-unit id="951c7938f85853a27d5c7d2c75acbe672c4155a1" translate="yes" xml:space="preserve">
          <source>This diagnostic warns for paths through the code in which &lt;code&gt;free&lt;/code&gt; is called on a non-heap pointer (e.g. an on-stack buffer, or a global).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a1c5da5f3c1afd18968f173e07657e7302351a3" translate="yes" xml:space="preserve">
          <source>This diagnostic warns for paths through the code in which &lt;code&gt;longjmp&lt;/code&gt; is called to rewind to a &lt;code&gt;jmp_buf&lt;/code&gt; relating to a &lt;code&gt;setjmp&lt;/code&gt; call in a function that has returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac21f5dcf2d09b0cae014f784d56a15b158edf70" translate="yes" xml:space="preserve">
          <source>This diagnostic warns for paths through the code in which a &lt;code&gt;&amp;lt;stdio.h&amp;gt;&lt;/code&gt;&lt;code&gt;FILE *&lt;/code&gt; stream object is leaked.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0839228138ef335cef6fd42894f9d1b11c2d55f0" translate="yes" xml:space="preserve">
          <source>This diagnostic warns for paths through the code in which a &lt;code&gt;FILE *&lt;/code&gt; can have &lt;code&gt;fclose&lt;/code&gt; called on it more than once.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="69065a1147c573eab2950f6087ec4e566a67c9a6" translate="yes" xml:space="preserve">
          <source>This diagnostic warns for paths through the code in which a function known to be async-signal-unsafe (such as &lt;code&gt;fprintf&lt;/code&gt;) is called from a signal handler.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="21154539e36b0472f9191b1b593654ca89275a98" translate="yes" xml:space="preserve">
          <source>This diagnostic warns for paths through the code in which a pointer allocated via &lt;code&gt;malloc&lt;/code&gt; is leaked.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="11378cc6703dc8c65838b338e0ff6edde259a680" translate="yes" xml:space="preserve">
          <source>This diagnostic warns for paths through the code in which a pointer can have &lt;code&gt;free&lt;/code&gt; called on it more than once.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8f9dc818bd4f109cde1dcf9e6dc005ab06fd45c6" translate="yes" xml:space="preserve">
          <source>This diagnostic warns for paths through the code in which a pointer is dereferenced that points to a variable in a stale stack frame.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ec5073148ee9d8b883f3325ddcb7fb0c4d813dc" translate="yes" xml:space="preserve">
          <source>This diagnostic warns for paths through the code in which a pointer is used after &lt;code&gt;free&lt;/code&gt; is called on it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fad14ca24b0d656f13db98b7bf5a30df3b6adb8e" translate="yes" xml:space="preserve">
          <source>This diagnostic warns for paths through the code in which a possibly-NULL value is dereferenced.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f2a9ffda1fede774b63029feba567cccbb607842" translate="yes" xml:space="preserve">
          <source>This diagnostic warns for paths through the code in which a possibly-NULL value is passed to a function argument marked with &lt;code&gt;__attribute__((nonnull))&lt;/code&gt; as requiring a non-NULL value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e828b08ddbeb8b76319f7c2f75bb782a082fba40" translate="yes" xml:space="preserve">
          <source>This diagnostic warns for paths through the code in which a security-sensitive value is written to an output file (such as writing a password to a log file).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e36f8c84c0a1d9f61a3991f2dd1bc00f7fd261b" translate="yes" xml:space="preserve">
          <source>This diagnostic warns for paths through the code in which a value known to be NULL is dereferenced.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="409bd5dd675e6fd0250a68f96b1c476f5f6aaaac" translate="yes" xml:space="preserve">
          <source>This diagnostic warns for paths through the code in which a value known to be NULL is passed to a function argument marked with &lt;code&gt;__attribute__((nonnull))&lt;/code&gt; as requiring a non-NULL value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3abf773f1e1f311cc5692173d305b2448d2aae95" translate="yes" xml:space="preserve">
          <source>This diagnostic warns for paths through the code in which a value that could be under an attacker&amp;rsquo;s control is used as the index of an array access without being sanitized.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f436df92076512b77fe92317bd65f3d39a6a1f34" translate="yes" xml:space="preserve">
          <source>This distinction between lookup of dependent and non-dependent names is called two-stage (or dependent) name lookup. G++ implements it since version 3.4.</source>
          <target state="translated">Это различие между поиском зависимых и не зависимых имен называется двухэтапным (или зависимым)поиском имен.G++реализует его начиная с версии 3.4.</target>
        </trans-unit>
        <trans-unit id="995cd6d9a17d418485ea5c0854d97ede3bab24ec" translate="yes" xml:space="preserve">
          <source>This document is meant to describe some of the GNU Objective-C features. It is not intended to teach you Objective-C. There are several resources on the Internet that present the language.</source>
          <target state="translated">Этот документ предназначен для описания некоторых возможностей GNU Objective-C.Он не предназначен для того,чтобы научить вас Цели C.В Интернете есть несколько ресурсов,где представлен язык.</target>
        </trans-unit>
        <trans-unit id="bdd119f74d4b60b69c880f2448f8e713a89672c3" translate="yes" xml:space="preserve">
          <source>This enables</source>
          <target state="translated">Это позволяет</target>
        </trans-unit>
        <trans-unit id="0e09a1e0e5fd69eecab75ac51a34aa77d0b56b77" translate="yes" xml:space="preserve">
          <source>This enables all the warnings about constructions that some users consider questionable, and that are easy to avoid (or modify to prevent the warning), even in conjunction with macros. This also enables some language-specific warnings described in &lt;a href=&quot;c_002b_002b-dialect-options#C_002b_002b-Dialect-Options&quot;&gt;C++ Dialect Options&lt;/a&gt; and &lt;a href=&quot;objective_002dc-and-objective_002dc_002b_002b-dialect-options#Objective_002dC-and-Objective_002dC_002b_002b-Dialect-Options&quot;&gt;Objective-C and Objective-C++ Dialect Options&lt;/a&gt;.</source>
          <target state="translated">Это включает все предупреждения о конструкциях, которые некоторые пользователи считают сомнительными и которых легко избежать (или изменить, чтобы предотвратить предупреждение), даже в сочетании с макросами. Это также включает некоторые предупреждения для конкретного языка, описанные в &lt;a href=&quot;c_002b_002b-dialect-options#C_002b_002b-Dialect-Options&quot;&gt;разделах Параметры диалекта C ++&lt;/a&gt; и Параметры диалекта &lt;a href=&quot;objective_002dc-and-objective_002dc_002b_002b-dialect-options#Objective_002dC-and-Objective_002dC_002b_002b-Dialect-Options&quot;&gt;Objective-C и Objective-C ++&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="10c0c908290715ca8a4902d77d9d099c7818ae8f" translate="yes" xml:space="preserve">
          <source>This enables some extra warning flags that are not enabled by</source>
          <target state="translated">Это позволяет включить некоторые дополнительные предупреждающие флаги,которые не включаются при помощи</target>
        </trans-unit>
        <trans-unit id="b7f682e7e0e71202769284a5f29ad044bc452f34" translate="yes" xml:space="preserve">
          <source>This enables use of the locked load/store conditional extension to implement atomic memory built-in functions. Not available for ARC 6xx or ARC EM cores.</source>
          <target state="translated">Это позволяет использовать заблокированное условное расширение загрузки/хранилища для реализации встроенных функций памяти атома.Не доступно для ядер ARC 6xx или ARC EM.</target>
        </trans-unit>
        <trans-unit id="c5419693b2d5b267f6af681a001ebef359580125" translate="yes" xml:space="preserve">
          <source>This example assigns a function to two slots in the default table (using preprocessor macros defined elsewhere) and makes it the default for the &lt;code&gt;dct&lt;/code&gt; table:</source>
          <target state="translated">В этом примере функция назначается двум слотам в таблице по умолчанию (с использованием макросов препроцессора, определенных в другом месте), и становится значением по умолчанию для таблицы &lt;code&gt;dct&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="1f3b599da5422ada6f5dd38b7f237af6695d9dff" translate="yes" xml:space="preserve">
          <source>This example creates an alias of &lt;code&gt;foo_v1&lt;/code&gt; with symbol name &lt;code&gt;symver_foo_v1&lt;/code&gt; which will be version &lt;code&gt;VERS_2&lt;/code&gt; of &lt;code&gt;foo&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c93813cffc93eab710482b42f488b7bb9eff10b0" translate="yes" xml:space="preserve">
          <source>This example is perfectly equivalent to</source>
          <target state="translated">Этот пример полностью эквивалентен</target>
        </trans-unit>
        <trans-unit id="d3e949e9ca160ba7c9c4c48936e0ebb9e6567bec" translate="yes" xml:space="preserve">
          <source>This example renames the spec called &amp;lsquo;</source>
          <target state="translated">Этот пример переименовывает спецификацию под названием '</target>
        </trans-unit>
        <trans-unit id="17efc27880dcdd0f4c6216f48227b6a6d20fb6a4" translate="yes" xml:space="preserve">
          <source>This example shows a simple assignment of a function to one vector in the default table (note that preprocessor macros may be used for chip-specific symbolic vector names):</source>
          <target state="translated">В данном примере показано простое назначение функции одному вектору в таблице по умолчанию (обратите внимание,что для имен символьных векторов,специфичных для чипа,могут использоваться препроцессорные макросы):</target>
        </trans-unit>
        <trans-unit id="f26530d0d01a4039c695b96fdd00747a2bd4aaea" translate="yes" xml:space="preserve">
          <source>This example uses the &lt;code&gt;cold&lt;/code&gt; label attribute to indicate the &lt;code&gt;ErrorHandling&lt;/code&gt; branch is unlikely to be taken and that the &lt;code&gt;ErrorHandling&lt;/code&gt; label is unused:</source>
          <target state="translated">В этом примере используется атрибут &lt;code&gt;cold&lt;/code&gt; метки, чтобы указать, что ветвь &lt;code&gt;ErrorHandling&lt;/code&gt; вряд ли будет взята и что метка &lt;code&gt;ErrorHandling&lt;/code&gt; не используется:</target>
        </trans-unit>
        <trans-unit id="0d3998b5540160156094948f334d5843b7f7f046" translate="yes" xml:space="preserve">
          <source>This example uses the &lt;code&gt;deprecated&lt;/code&gt; enumerator attribute to indicate the &lt;code&gt;oldval&lt;/code&gt; enumerator is deprecated:</source>
          <target state="translated">В этом примере используется &lt;code&gt;deprecated&lt;/code&gt; атрибут перечислителя, чтобы указать, что перечислитель &lt;code&gt;oldval&lt;/code&gt; устарел:</target>
        </trans-unit>
        <trans-unit id="215cf5b89400516fe24140191ed923d2f09bd20b" translate="yes" xml:space="preserve">
          <source>This example uses the &lt;code&gt;fallthrough&lt;/code&gt; statement attribute to indicate that the</source>
          <target state="translated">В этом примере используется &lt;code&gt;fallthrough&lt;/code&gt; оператора fallthrough, чтобы указать, что</target>
        </trans-unit>
        <trans-unit id="7f112db8072d753fab06651e1a77010d4e9ebe45" translate="yes" xml:space="preserve">
          <source>This example:</source>
          <target state="translated">Вот этот пример:</target>
        </trans-unit>
        <trans-unit id="101c080fa9daf91a22a5c3746a65d406ce7eb831" translate="yes" xml:space="preserve">
          <source>This extension is not supported by GNU C++.</source>
          <target state="translated">Это расширение не поддерживается GNU C++.</target>
        </trans-unit>
        <trans-unit id="f68ab67a136425be8901f00690401dbac036957d" translate="yes" xml:space="preserve">
          <source>This extension is sufficient such that</source>
          <target state="translated">Этого расширения достаточно,чтобы</target>
        </trans-unit>
        <trans-unit id="73b411a471e59249b2c99728d68299ae469991d2" translate="yes" xml:space="preserve">
          <source>This extension may not be very useful, but it makes the handling of &lt;code&gt;enum&lt;/code&gt; more consistent with the way &lt;code&gt;struct&lt;/code&gt; and &lt;code&gt;union&lt;/code&gt; are handled.</source>
          <target state="translated">Это расширение может быть не очень полезным, но оно делает обработку &lt;code&gt;enum&lt;/code&gt; более согласованной с тем, как обрабатываются &lt;code&gt;struct&lt;/code&gt; и &lt;code&gt;union&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5605d8fdd1bc286fd5dac21c8bc67cef9a0ffdd5" translate="yes" xml:space="preserve">
          <source>This extra alignment does consume extra stack space, and generally increases code size. Code that is sensitive to stack space usage, such as embedded systems and operating system kernels, may want to reduce the preferred alignment to</source>
          <target state="translated">Это дополнительное выравнивание потребляет дополнительное пространство стека и,как правило,увеличивает размер кода.Код,чувствительный к использованию стекового пространства,такой как встраиваемые системы и ядра операционной системы,может захотеть уменьшить предпочтительное выравнивание до</target>
        </trans-unit>
        <trans-unit id="e786b1c4f43cf240524b9e361ead5cdf6cfb070b" translate="yes" xml:space="preserve">
          <source>This facility is very useful if you want to initialize global variables which can be accessed by the program directly, without sending a message to the class first. The usual way to initialize global variables, in the &lt;code&gt;+initialize&lt;/code&gt; method, might not be useful because &lt;code&gt;+initialize&lt;/code&gt; is only called when the first message is sent to a class object, which in some cases could be too late.</source>
          <target state="translated">Эта возможность очень полезна, если вы хотите инициализировать глобальные переменные, к которым программа может получить доступ напрямую, без предварительной отправки сообщения классу. Обычный способ инициализации глобальных переменных в методе &lt;code&gt;+initialize&lt;/code&gt; может оказаться бесполезным, потому что &lt;code&gt;+initialize&lt;/code&gt; вызывается только тогда, когда первое сообщение отправляется объекту класса, что в некоторых случаях может быть слишком поздно.</target>
        </trans-unit>
        <trans-unit id="5301c866b6ac40f65d4bd67792ec94bc126ba1c2" translate="yes" xml:space="preserve">
          <source>This feature is especially useful for ranges of ASCII character codes:</source>
          <target state="translated">Эта функция особенно полезна для диапазонов ASCII-символьных кодов:</target>
        </trans-unit>
        <trans-unit id="4b7eade7c951c9b37c2e852a014cd189c7b49192" translate="yes" xml:space="preserve">
          <source>This feature is especially useful in making macro definitions &amp;ldquo;safe&amp;rdquo; (so that they evaluate each operand exactly once). For example, the &amp;ldquo;maximum&amp;rdquo; function is commonly defined as a macro in standard C as follows:</source>
          <target state="translated">Эта функция особенно полезна для обеспечения &amp;laquo;безопасности&amp;raquo; макроопределений (чтобы они оценивали каждый операнд только один раз). Например, &amp;laquo;максимальная&amp;raquo; функция обычно определяется как макрос в стандарте C следующим образом:</target>
        </trans-unit>
        <trans-unit id="cf86da6582486ace0550eafa0f42f9a96d5c2a2b" translate="yes" xml:space="preserve">
          <source>This feature is intended for program-generated code that may contain unused labels, but which is compiled with</source>
          <target state="translated">Эта особенность предназначена для программного кода,который может содержать неиспользуемые метки,но который скомпилирован с помощью</target>
        </trans-unit>
        <trans-unit id="0c1076e2c167a24356587893b7b6c8a8375aa3a4" translate="yes" xml:space="preserve">
          <source>This feature is not enabled by default. Specifying</source>
          <target state="translated">По умолчанию эта функция не включена.Указание</target>
        </trans-unit>
        <trans-unit id="9420f79a451b4efac8e962af58f495ad7ac181c7" translate="yes" xml:space="preserve">
          <source>This feature is used in automatic updating of makefiles.</source>
          <target state="translated">Эта функция используется при автоматическом обновлении makefiles.</target>
        </trans-unit>
        <trans-unit id="a8f11fa97afc8a9f70ed0e1fb16cbd9bede804da" translate="yes" xml:space="preserve">
          <source>This file documents the use of the GNU compilers.</source>
          <target state="translated">Этот файл документирует применение компиляторов GNU.</target>
        </trans-unit>
        <trans-unit id="6c21848b1d55804d72743a6693d101b63cd47544" translate="yes" xml:space="preserve">
          <source>This flag attempts to use visibility settings to make GCC&amp;rsquo;s C++ linkage model compatible with that of Microsoft Visual Studio.</source>
          <target state="translated">Этот флаг пытается использовать настройки видимости, чтобы сделать модель связывания GCC C ++ совместимой с моделью Microsoft Visual Studio.</target>
        </trans-unit>
        <trans-unit id="2db7dd43d8e02c47fc0a85c5c3e38b591f0a3877" translate="yes" xml:space="preserve">
          <source>This flag does not have a negative form, because it specifies a three-way choice.</source>
          <target state="translated">Этот флаг не имеет отрицательной формы,так как он задает трехсторонний выбор.</target>
        </trans-unit>
        <trans-unit id="c1b1af85f2a6f09c7615fb9953621e2594fc2498" translate="yes" xml:space="preserve">
          <source>This flag is disabled by default.</source>
          <target state="translated">Этот флаг отключен по умолчанию.</target>
        </trans-unit>
        <trans-unit id="ef23e3f8b62106f744c396a536baec3f85486f03" translate="yes" xml:space="preserve">
          <source>This flag is enabled by default at</source>
          <target state="translated">Этот флаг включен по умолчанию на</target>
        </trans-unit>
        <trans-unit id="7fb1ed0a0aaf28dac933fdc7dd7aadf9b8292636" translate="yes" xml:space="preserve">
          <source>This flag is enabled by default for</source>
          <target state="translated">Этот флаг включен по умолчанию для</target>
        </trans-unit>
        <trans-unit id="c025ee0fe2aca271d6bc8b1c3c04c156ee4d07a6" translate="yes" xml:space="preserve">
          <source>This flag is included in</source>
          <target state="translated">Этот флаг включен в</target>
        </trans-unit>
        <trans-unit id="03d3b3aedc1d8ba8a1241588ebdb03f76fc4bd8e" translate="yes" xml:space="preserve">
          <source>This function attribute indicates that an argument in a call to the function is expected to be an explicit &lt;code&gt;NULL&lt;/code&gt;. The attribute is only valid on variadic functions. By default, the sentinel is expected to be the last argument of the function call. If the optional &lt;var&gt;position&lt;/var&gt; argument is specified to the attribute, the sentinel must be located at &lt;var&gt;position&lt;/var&gt; counting backwards from the end of the argument list.</source>
          <target state="translated">Этот атрибут функции указывает, что аргумент в вызове функции должен иметь явный &lt;code&gt;NULL&lt;/code&gt; . Атрибут действителен только для функций с переменным числом аргументов. По умолчанию ожидается, что дозорный будет последним аргументом вызова функции. Если для атрибута указан необязательный аргумент &lt;var&gt;position&lt;/var&gt; , то сигнальное устройство должно располагаться в &lt;var&gt;position&lt;/var&gt; считая в обратном порядке от конца списка аргументов.</target>
        </trans-unit>
        <trans-unit id="3eace8a8897f53986baecdd557c9bed95be5eb95" translate="yes" xml:space="preserve">
          <source>This function attribute prevents a function from being considered for cloning&amp;mdash;a mechanism that produces specialized copies of functions and which is (currently) performed by interprocedural constant propagation.</source>
          <target state="translated">Этот атрибут функции предотвращает рассмотрение функции для клонирования - механизма, который создает специализированные копии функций и который (в настоящее время) выполняется путем межпроцедурного распространения констант.</target>
        </trans-unit>
        <trans-unit id="0185a8637e8440da0db0d53dd62eb7167b8eb84c" translate="yes" xml:space="preserve">
          <source>This function attribute prevents a function from being considered for inlining. If the function does not have side effects, there are optimizations other than inlining that cause function calls to be optimized away, although the function call is live. To keep such calls from being optimized away, put</source>
          <target state="translated">Этот атрибут функции предотвращает рассмотрение функции для встраивания.Если функция не имеет побочных эффектов,существуют оптимизации,кроме встраивания,которые приводят к тому,что вызовы функции не оптимизируются,хотя вызов функции находится в режиме реального времени.Чтобы такие вызовы не были оптимизированы,поставьте</target>
        </trans-unit>
        <trans-unit id="c2eae0ac690e115a386b22c2c033e3d207f73749" translate="yes" xml:space="preserve">
          <source>This function attribute prevents a functions from being merged with another semantically equivalent function.</source>
          <target state="translated">Этот атрибут функции предотвращает слияние функции с другой семантически эквивалентной функцией.</target>
        </trans-unit>
        <trans-unit id="cfa0a9aeda6626f962564eda6d7bc9ae77a9f9e7" translate="yes" xml:space="preserve">
          <source>This function causes the program to exit abnormally. GCC implements this function by using a target-dependent mechanism (such as intentionally executing an illegal instruction) or by calling &lt;code&gt;abort&lt;/code&gt;. The mechanism used may vary from release to release so you should not rely on any particular implementation.</source>
          <target state="translated">Эта функция приводит к аварийному завершению программы. GCC реализует эту функцию, используя механизм, зависящий от цели (например, намеренное выполнение недопустимой инструкции) или вызывая &lt;code&gt;abort&lt;/code&gt; . Используемый механизм может варьироваться от выпуска к выпуску, поэтому вам не следует полагаться на какую-либо конкретную реализацию.</target>
        </trans-unit>
        <trans-unit id="e524eeb8ecfc131aac67b7d8a458ea88f19f0eed" translate="yes" xml:space="preserve">
          <source>This function does the reverse of &lt;code&gt;__builtin_extract_return_addr&lt;/code&gt;.</source>
          <target state="translated">Эта функция делает обратное &lt;code&gt;__builtin_extract_return_addr&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="95420bd588ca997857f34739b8ed2c2d2dc9b407" translate="yes" xml:space="preserve">
          <source>This function has the same semantics as &lt;code&gt;__builtin_expect&lt;/code&gt;, but the caller provides the expected probability that &lt;var&gt;exp&lt;/var&gt; == &lt;var&gt;c&lt;/var&gt;. The last argument, &lt;var&gt;probability&lt;/var&gt;, is a floating-point value in the range 0.0 to 1.0, inclusive. The &lt;var&gt;probability&lt;/var&gt; argument must be constant floating-point expression.</source>
          <target state="translated">Эта функция имеет ту же семантику, что и &lt;code&gt;__builtin_expect&lt;/code&gt; , но вызывающий объект предоставляет ожидаемую вероятность того, что &lt;var&gt;exp&lt;/var&gt; == &lt;var&gt;c&lt;/var&gt; . Последний аргумент, &lt;var&gt;probability&lt;/var&gt; , представляет собой значение с плавающей запятой в диапазоне от 0,0 до 1,0 включительно. &lt;var&gt;probability&lt;/var&gt; того, аргумент должен быть постоянным выражением с плавающей точкой.</target>
        </trans-unit>
        <trans-unit id="dad1828780de0ec7cb4d2651f782e659f7669888" translate="yes" xml:space="preserve">
          <source>This function is a &lt;code&gt;nop&lt;/code&gt; on the PowerPC platform and is included solely to maintain API compatibility with the x86 builtins.</source>
          <target state="translated">Эта функция является &lt;code&gt;nop&lt;/code&gt; на платформе PowerPC и включается только для поддержания совместимости API с x86 встроенных команд.</target>
        </trans-unit>
        <trans-unit id="cc1de5cdd4f293c4a48810df067ace8dfe7d6d91" translate="yes" xml:space="preserve">
          <source>This function is similar to &lt;code&gt;__builtin_return_address&lt;/code&gt;, but it returns the address of the function frame rather than the return address of the function. Calling &lt;code&gt;__builtin_frame_address&lt;/code&gt; with a value of &lt;code&gt;0&lt;/code&gt; yields the frame address of the current function, a value of &lt;code&gt;1&lt;/code&gt; yields the frame address of the caller of the current function, and so forth.</source>
          <target state="translated">Эта функция похожа на &lt;code&gt;__builtin_return_address&lt;/code&gt; , но возвращает адрес фрейма функции, а не адрес возврата функции. Вызов &lt;code&gt;__builtin_frame_address&lt;/code&gt; со значением &lt;code&gt;0&lt;/code&gt; дает адрес кадра текущей функции, значение &lt;code&gt;1&lt;/code&gt; дает адрес кадра вызывающего текущую функцию и так далее.</target>
        </trans-unit>
        <trans-unit id="a0b7342f9f274d12e577265101ded1a69579dafe" translate="yes" xml:space="preserve">
          <source>This function is the equivalent of the &lt;code&gt;__FUNCTION__&lt;/code&gt; symbol and returns an address constant pointing to the name of the function from which the built-in was invoked, or the empty string if the invocation is not at function scope. When used as a C++ default argument for a function &lt;var&gt;F&lt;/var&gt;, it returns the name of &lt;var&gt;F&lt;/var&gt;&amp;rsquo;s caller or the empty string if the call was not made at function scope.</source>
          <target state="translated">Эта функция является эквивалентом символа &lt;code&gt;__FUNCTION__&lt;/code&gt; и возвращает адресную константу, указывающую на имя функции, из которой была вызвана встроенная функция, или пустую строку, если вызов не находится в области действия функции. При использовании в качестве аргумента C ++ по умолчанию для функции &lt;var&gt;F&lt;/var&gt; он возвращает имя вызывающего &lt;var&gt;F&lt;/var&gt; или пустую строку, если вызов не был сделан в области действия функции.</target>
        </trans-unit>
        <trans-unit id="86e1f1b709cdf3bbdf962d668f4ccf9699d7ee2e" translate="yes" xml:space="preserve">
          <source>This function is the equivalent of the preprocessor &lt;code&gt;__FILE__&lt;/code&gt; macro and returns an address constant pointing to the file name containing the invocation of the built-in, or the empty string if the invocation is not at function scope. When used as a C++ default argument for a function &lt;var&gt;F&lt;/var&gt;, it returns the file name of the call to &lt;var&gt;F&lt;/var&gt; or the empty string if the call was not made at function scope.</source>
          <target state="translated">Эта функция является эквивалентом макроса препроцессора &lt;code&gt;__FILE__&lt;/code&gt; и возвращает адресную константу, указывающую на имя файла, содержащего вызов встроенной функции, или пустую строку, если вызов не находится в области действия функции. При использовании в качестве аргумента C ++ по умолчанию для функции &lt;var&gt;F&lt;/var&gt; , он возвращает имя файла вызова &lt;var&gt;F&lt;/var&gt; или пустую строку, если вызов не был выполнен в области действия функции.</target>
        </trans-unit>
        <trans-unit id="bc294999db99ded1854e8f5e1e4b8ef679553e0d" translate="yes" xml:space="preserve">
          <source>This function is the equivalent of the preprocessor &lt;code&gt;__LINE__&lt;/code&gt; macro and returns a constant integer expression that evaluates to the line number of the invocation of the built-in. When used as a C++ default argument for a function &lt;var&gt;F&lt;/var&gt;, it returns the line number of the call to &lt;var&gt;F&lt;/var&gt;.</source>
          <target state="translated">Эта функция является эквивалентом макроса препроцессора &lt;code&gt;__LINE__&lt;/code&gt; и возвращает постоянное целочисленное выражение, которое оценивается как номер строки вызова встроенного. При использовании в качестве C ++ аргумента по умолчанию для функции &lt;var&gt;F&lt;/var&gt; , то она возвращает номер строки вызова &lt;var&gt;F&lt;/var&gt; .</target>
        </trans-unit>
        <trans-unit id="b4965b81131ff05edb23e4ac2cd86ee54e42a982" translate="yes" xml:space="preserve">
          <source>This function is used to flush the processor&amp;rsquo;s instruction cache for the region of memory between &lt;var&gt;begin&lt;/var&gt; inclusive and &lt;var&gt;end&lt;/var&gt; exclusive. Some targets require that the instruction cache be flushed, after modifying memory containing code, in order to obtain deterministic behavior.</source>
          <target state="translated">Эта функция используется для очистки кэша инструкций процессора для области памяти между &lt;var&gt;begin&lt;/var&gt; включительно и исключительным &lt;var&gt;end&lt;/var&gt; . Некоторые цели требуют, чтобы кэш инструкций был очищен после изменения памяти, содержащей код, чтобы получить детерминированное поведение.</target>
        </trans-unit>
        <trans-unit id="a3fe2b1a97278967d04d0a166eb411721a963d62" translate="yes" xml:space="preserve">
          <source>This function is used to minimize cache-miss latency by moving data into a cache before it is accessed. You can insert calls to &lt;code&gt;__builtin_prefetch&lt;/code&gt; into code for which you know addresses of data in memory that is likely to be accessed soon. If the target supports them, data prefetch instructions are generated. If the prefetch is done early enough before the access then the data will be in the cache by the time it is accessed.</source>
          <target state="translated">Эта функция используется для минимизации задержки при пропуске кэша путем перемещения данных в кэш до того, как к ним будет осуществлен доступ. Вы можете вставлять вызовы &lt;code&gt;__builtin_prefetch&lt;/code&gt; в код, для которого вам известны адреса данных в памяти, к которым, вероятно, скоро будет получен доступ. Если цель поддерживает их, генерируются инструкции предварительной выборки данных. Если предварительная выборка выполняется достаточно рано до доступа, данные будут в кэше к моменту обращения к ним.</target>
        </trans-unit>
        <trans-unit id="8919a966ee8dd6af4dbf0f92a03208a705be1969" translate="yes" xml:space="preserve">
          <source>This function restores the stack context in &lt;var&gt;buf&lt;/var&gt;, saved by a previous call to &lt;code&gt;__builtin_setjmp&lt;/code&gt;. After &lt;code&gt;__builtin_longjmp&lt;/code&gt; is finished, the program resumes execution as if the matching &lt;code&gt;__builtin_setjmp&lt;/code&gt; returns the value &lt;var&gt;val&lt;/var&gt;, which must be 1.</source>
          <target state="translated">Эта функция восстанавливает контекст стека в &lt;var&gt;buf&lt;/var&gt; , сохраненный предыдущим вызовом &lt;code&gt;__builtin_setjmp&lt;/code&gt; . После завершения &lt;code&gt;__builtin_longjmp&lt;/code&gt; программа возобновляет выполнение, как если бы совпадающий &lt;code&gt;__builtin_setjmp&lt;/code&gt; возвращает значение &lt;var&gt;val&lt;/var&gt; , которое должно быть 1.</target>
        </trans-unit>
        <trans-unit id="d321f2ee318af6c2dd764431e17a984bfaa18ec1" translate="yes" xml:space="preserve">
          <source>This function returns a pointer to data describing how to return whatever value is returned by &lt;var&gt;function&lt;/var&gt;. The data is saved in a block of memory allocated on the stack.</source>
          <target state="translated">Эта функция возвращает указатель на данные, описывающий, как вернуть любое значение, возвращаемое &lt;var&gt;function&lt;/var&gt; . Данные сохраняются в блоке памяти, выделенном в стеке.</target>
        </trans-unit>
        <trans-unit id="b71039af8a1d11c8d83124bcb2f420630a5a1ce8" translate="yes" xml:space="preserve">
          <source>This function returns a positive integer if the run-time CPU is of type &lt;var&gt;cpuname&lt;/var&gt; and returns &lt;code&gt;0&lt;/code&gt; otherwise. The following CPU names can be detected:</source>
          <target state="translated">Эта функция возвращает положительное целое число, если ЦП времени выполнения имеет тип &lt;var&gt;cpuname&lt;/var&gt; , и возвращает &lt;code&gt;0&lt;/code&gt; в противном случае. Могут быть обнаружены следующие имена ЦП:</target>
        </trans-unit>
        <trans-unit id="dfdc7462f357d955c59d1a21b41e74d15ee8d83b" translate="yes" xml:space="preserve">
          <source>This function returns a positive integer if the run-time CPU supports &lt;var&gt;feature&lt;/var&gt; and returns &lt;code&gt;0&lt;/code&gt; otherwise. The following features can be detected:</source>
          <target state="translated">Эта функция возвращает положительное целое число, если ЦП времени выполнения поддерживает &lt;var&gt;feature&lt;/var&gt; и возвращает &lt;code&gt;0&lt;/code&gt; в противном случае. Могут быть обнаружены следующие особенности:</target>
        </trans-unit>
        <trans-unit id="5bf6bbb0ff1bf6eb1b3c656f4cca7e925e10e2a5" translate="yes" xml:space="preserve">
          <source>This function returns a value of &lt;code&gt;1&lt;/code&gt; if the run-time CPU is of type &lt;var&gt;cpuname&lt;/var&gt; and returns &lt;code&gt;0&lt;/code&gt; otherwise</source>
          <target state="translated">Эта функция возвращает значение &lt;code&gt;1&lt;/code&gt; , если ЦП времени выполнения имеет тип &lt;var&gt;cpuname&lt;/var&gt; , и возвращает &lt;code&gt;0&lt;/code&gt; в противном случае.</target>
        </trans-unit>
        <trans-unit id="27852be90385733f670b1f53118c6fb5c9f99598" translate="yes" xml:space="preserve">
          <source>This function returns a value of &lt;code&gt;1&lt;/code&gt; if the run-time CPU supports the HWCAP feature &lt;var&gt;feature&lt;/var&gt; and returns &lt;code&gt;0&lt;/code&gt; otherwise.</source>
          <target state="translated">Эта функция возвращает значение &lt;code&gt;1&lt;/code&gt; , если ЦП времени выполнения поддерживает функцию &lt;var&gt;feature&lt;/var&gt; HWCAP, и возвращает &lt;code&gt;0&lt;/code&gt; в противном случае.</target>
        </trans-unit>
        <trans-unit id="213b2aa2268e34e2f3e902cc0c4fc9d3fae623d8" translate="yes" xml:space="preserve">
          <source>This function returns its first argument, and allows the compiler to assume that the returned pointer is at least &lt;var&gt;align&lt;/var&gt; bytes aligned. This built-in can have either two or three arguments, if it has three, the third argument should have integer type, and if it is nonzero means misalignment offset. For example:</source>
          <target state="translated">Эта функция возвращает свой первый аргумент и позволяет компилятору предположить, что возвращаемый указатель по крайней мере &lt;var&gt;align&lt;/var&gt; байтам. Этот встроенный может иметь два или три аргумента, если у него три, третий аргумент должен иметь целочисленный тип, а если он не равен нулю, это означает смещение несовпадения. Например:</target>
        </trans-unit>
        <trans-unit id="0dc83a066fc8a8ed7ae8cb097e4deaf1084d4a2b" translate="yes" xml:space="preserve">
          <source>This function returns the return address of the current function, or of one of its callers. The &lt;var&gt;level&lt;/var&gt; argument is number of frames to scan up the call stack. A value of &lt;code&gt;0&lt;/code&gt; yields the return address of the current function, a value of &lt;code&gt;1&lt;/code&gt; yields the return address of the caller of the current function, and so forth. When inlining the expected behavior is that the function returns the address of the function that is returned to. To work around this behavior use the &lt;code&gt;noinline&lt;/code&gt; function attribute.</source>
          <target state="translated">Эта функция возвращает адрес возврата текущей функции или одного из ее вызывающих. &lt;var&gt;level&lt;/var&gt; аргумент число кадров для сканирования стеки вызовов. Значение &lt;code&gt;0&lt;/code&gt; дает адрес возврата текущей функции, значение &lt;code&gt;1&lt;/code&gt; дает адрес возврата вызывающей стороны текущей функции и так далее. Ожидаемое поведение при встраивании состоит в том, что функция возвращает адрес возвращаемой функции. Чтобы обойти это поведение, используйте &lt;code&gt;noinline&lt;/code&gt; функции noinline .</target>
        </trans-unit>
        <trans-unit id="a8c68121ab03a5059f1b4257b6c2b3c7234cacf3" translate="yes" xml:space="preserve">
          <source>This function runs the CPU detection code to check the type of CPU and the features supported. This built-in function needs to be invoked along with the built-in functions to check CPU type and features, &lt;code&gt;__builtin_cpu_is&lt;/code&gt; and &lt;code&gt;__builtin_cpu_supports&lt;/code&gt;, only when used in a function that is executed before any constructors are called. The CPU detection code is automatically executed in a very high priority constructor.</source>
          <target state="translated">Эта функция запускает код обнаружения ЦП для проверки типа ЦП и поддерживаемых функций. Эту встроенную функцию необходимо вызывать вместе со встроенными функциями для проверки типа и возможностей ЦП, &lt;code&gt;__builtin_cpu_is&lt;/code&gt; и &lt;code&gt;__builtin_cpu_supports&lt;/code&gt; , только при использовании в функции, которая выполняется до вызова каких-либо конструкторов. Код обнаружения ЦП автоматически выполняется в конструкторе с очень высоким приоритетом.</target>
        </trans-unit>
        <trans-unit id="0f58a4af763a22a01173db535b0e84cbf679fc29" translate="yes" xml:space="preserve">
          <source>This function saves the current stack context in &lt;var&gt;buf&lt;/var&gt;. &lt;code&gt;__builtin_setjmp&lt;/code&gt; returns 0 when returning directly, and 1 when returning from &lt;code&gt;__builtin_longjmp&lt;/code&gt; using the same &lt;var&gt;buf&lt;/var&gt;.</source>
          <target state="translated">Эта функция сохраняет текущий контекст стека в &lt;var&gt;buf&lt;/var&gt; . &lt;code&gt;__builtin_setjmp&lt;/code&gt; возвращает 0 при прямом возврате и 1 при возврате из &lt;code&gt;__builtin_longjmp&lt;/code&gt; с использованием того же &lt;var&gt;buf&lt;/var&gt; .</target>
        </trans-unit>
        <trans-unit id="69e7849ff4cbe4d496d1ff31f3b20212a375c758" translate="yes" xml:space="preserve">
          <source>This function, if given a string literal all of which would have been consumed by &lt;code&gt;strtol&lt;/code&gt;, is evaluated early enough that it is considered a compile-time constant.</source>
          <target state="translated">Эта функция, если ей задан строковый литерал, все из которых были бы использованы &lt;code&gt;strtol&lt;/code&gt; , вычисляется достаточно рано, чтобы считаться константой времени компиляции.</target>
        </trans-unit>
        <trans-unit id="1b248fa09ed8681d529d9f22aaa2c70eb149364a" translate="yes" xml:space="preserve">
          <source>This has symmetry with normal static arrays, in that an array of unknown size is also written with &lt;code&gt;[]&lt;/code&gt;.</source>
          <target state="translated">Он имеет симметрию с обычными статическими массивами, поскольку массив неизвестного размера также записывается с помощью &lt;code&gt;[]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8646e863ba587311636afd56af70cd4124b64132" translate="yes" xml:space="preserve">
          <source>This has the same effect as the proper number of individual &lt;code&gt;case&lt;/code&gt; labels, one for each integer value from &lt;var&gt;low&lt;/var&gt; to &lt;var&gt;high&lt;/var&gt;, inclusive.</source>
          <target state="translated">Это имеет тот же эффект, что и правильное количество индивидуальных меток &lt;code&gt;case&lt;/code&gt; , по одной для каждого целочисленного значения от &lt;var&gt;low&lt;/var&gt; до &lt;var&gt;high&lt;/var&gt; включительно.</target>
        </trans-unit>
        <trans-unit id="83169887a69a2b08bab1ebc54a9588ce551d545e" translate="yes" xml:space="preserve">
          <source>This hook is generally reserved for &amp;ldquo;Foundation&amp;rdquo; libraries such as GNUstep Base, which use it to implement their high-level method forwarding API, typically based around the &lt;code&gt;forwardInvocation:&lt;/code&gt; method. So, unless you are implementing your own &amp;ldquo;Foundation&amp;rdquo; library, you should not set this hook.</source>
          <target state="translated">Этот хук обычно зарезервирован для библиотек &amp;laquo;Foundation&amp;raquo;, таких как GNUstep Base, которые используют его для реализации своего высокоуровневого API пересылки методов, обычно основанного на &lt;code&gt;forwardInvocation:&lt;/code&gt; method. Так что, если вы не реализуете свою собственную библиотеку &amp;laquo;Foundation&amp;raquo;, вам не следует устанавливать эту ловушку.</target>
        </trans-unit>
        <trans-unit id="968e5049fab7f4bdf3b3205d394535ad648ef39e" translate="yes" xml:space="preserve">
          <source>This i386 code demonstrates a case that does not use (or require) the &lt;code&gt;volatile&lt;/code&gt; qualifier. If it is performing assertion checking, this code uses &lt;code&gt;asm&lt;/code&gt; to perform the validation. Otherwise, &lt;code&gt;dwRes&lt;/code&gt; is unreferenced by any code. As a result, the optimizers can discard the &lt;code&gt;asm&lt;/code&gt; statement, which in turn removes the need for the entire &lt;code&gt;DoCheck&lt;/code&gt; routine. By omitting the &lt;code&gt;volatile&lt;/code&gt; qualifier when it isn&amp;rsquo;t needed you allow the optimizers to produce the most efficient code possible.</source>
          <target state="translated">Этот код i386 демонстрирует случай, в котором не используется (или не требуется) квалификатор &lt;code&gt;volatile&lt;/code&gt; . Если он выполняет проверку утверждения, этот код использует &lt;code&gt;asm&lt;/code&gt; для выполнения проверки. В противном случае на &lt;code&gt;dwRes&lt;/code&gt; не будет ссылаться какой-либо код. В результате оптимизаторы могут отказаться от инструкции &lt;code&gt;asm&lt;/code&gt; , что, в свою очередь, устраняет необходимость во всей подпрограмме &lt;code&gt;DoCheck&lt;/code&gt; . Опуская квалификатор &lt;code&gt;volatile&lt;/code&gt; , когда он не нужен, вы позволяете оптимизаторам создавать максимально эффективный код.</target>
        </trans-unit>
        <trans-unit id="808f6f4a24d0e37061696da154166d6ac70ac880" translate="yes" xml:space="preserve">
          <source>This implies that the choice of angle brackets or double quotes in an &amp;lsquo;</source>
          <target state="translated">Это означает, что выбор угловых скобок или двойных кавычек в '</target>
        </trans-unit>
        <trans-unit id="e1db8a962787e8ba6275999130017fe253b89359" translate="yes" xml:space="preserve">
          <source>This inserts an instruction sequence that takes exactly &lt;var&gt;cycles&lt;/var&gt; cycles (between 0 and about 17E9) to complete. The inserted sequence may use jumps, loops, or no-ops, and does not interfere with any other instructions. Note that &lt;var&gt;cycles&lt;/var&gt; must be a compile-time constant integer - that is, you must pass a number, not a variable that may be optimized to a constant later. The number of cycles delayed by this builtin is exact.</source>
          <target state="translated">Это вставляет последовательность команд, которая занимает ровно столько &lt;var&gt;cycles&lt;/var&gt; (от 0 до примерно 17E9) для завершения. Вставленная последовательность может использовать переходы, циклы или запреты операций и не мешает другим инструкциям. Обратите внимание, что &lt;var&gt;cycles&lt;/var&gt; должны быть целыми числами константы времени компиляции, то есть вы должны передавать число, а не переменную, которая может быть оптимизирована до константы позже. Количество циклов, задержанных этой встроенной функцией, является точным.</target>
        </trans-unit>
        <trans-unit id="8e5d39ccb505b20a7de4368cf8c74cd0bd9b0602" translate="yes" xml:space="preserve">
          <source>This instrumentation is also done for functions expanded inline in other functions. The profiling calls indicate where, conceptually, the inline function is entered and exited. This means that addressable versions of such functions must be available. If all your uses of a function are expanded inline, this may mean an additional expansion of code size. If you use &lt;code&gt;extern inline&lt;/code&gt; in your C code, an addressable version of such functions must be provided. (This is normally the case anyway, but if you get lucky and the optimizer always expands the functions inline, you might have gotten away without providing static copies.)</source>
          <target state="translated">Этот инструментарий также предназначен для функций, встроенных в другие функции. Вызовы профилирования указывают, где, концептуально, встроенная функция вводится и завершается. Это означает, что должны быть доступны адресные версии таких функций. Если все ваши варианты использования функции расширяются встроенно, это может означать дополнительное увеличение размера кода. Если вы используете &lt;code&gt;extern inline&lt;/code&gt; в своем коде C, должна быть предоставлена ​​адресная версия таких функций. (В любом случае это обычно так, но если вам повезет и оптимизатор всегда расширяет встроенные функции, вы, возможно, обойдетесь без статических копий.)</target>
        </trans-unit>
        <trans-unit id="c5f757d83923a2f4750aa24fef819d39fd7c764d" translate="yes" xml:space="preserve">
          <source>This interface allows either &lt;code&gt;int *&lt;/code&gt; or &lt;code&gt;union wait *&lt;/code&gt; arguments to be passed, using the &lt;code&gt;int *&lt;/code&gt; calling convention. The program can call &lt;code&gt;wait&lt;/code&gt; with arguments of either type:</source>
          <target state="translated">Этот интерфейс позволяет передавать аргументы &lt;code&gt;int *&lt;/code&gt; или &lt;code&gt;union wait *&lt;/code&gt; , используя соглашение о вызовах &lt;code&gt;int *&lt;/code&gt; . Программа может вызывать &lt;code&gt;wait&lt;/code&gt; с аргументами любого типа:</target>
        </trans-unit>
        <trans-unit id="7fa6e20d0ad9607fec20c7fa93797725b39e7225" translate="yes" xml:space="preserve">
          <source>This interrupt service routine is interruptible after &lt;code&gt;PSW.GIE&lt;/code&gt; (global interrupt enable) is set. This allows interrupt service routine to finish some short critical code before enabling interrupts.</source>
          <target state="translated">Эта процедура обслуживания прерывания может быть прервана после установки &lt;code&gt;PSW.GIE&lt;/code&gt; (глобального разрешения прерывания). Это позволяет программе обработки прерываний завершить некоторый короткий критический код перед включением прерываний.</target>
        </trans-unit>
        <trans-unit id="f39211b611ed78b8a4cda99c2d1b9f90b52f7b8c" translate="yes" xml:space="preserve">
          <source>This interrupt service routine is interruptible.</source>
          <target state="translated">Эта процедура прерывания обслуживания прерывается.</target>
        </trans-unit>
        <trans-unit id="8cc90603ecbdd7ae47dd33c675b43de2d13b14cf" translate="yes" xml:space="preserve">
          <source>This interrupt service routine is not interruptible.</source>
          <target state="translated">Эта процедура обслуживания прерывания не является прерывистой.</target>
        </trans-unit>
        <trans-unit id="98ed58186125da377f3558ec8512de6f6dbbf8ae" translate="yes" xml:space="preserve">
          <source>This invokes all subprograms of &lt;code&gt;gcc&lt;/code&gt; under &amp;lsquo;</source>
          <target state="translated">Это вызывает все подпрограммы &lt;code&gt;gcc&lt;/code&gt; под '</target>
        </trans-unit>
        <trans-unit id="36c68f63258bf418514a8d6d7b59387b054a571e" translate="yes" xml:space="preserve">
          <source>This is a 24-bit address space that linearizes flash and RAM: If the high bit of the address is set, data is read from RAM using the lower two bytes as RAM address. If the high bit of the address is clear, data is read from flash with &lt;code&gt;RAMPZ&lt;/code&gt; set according to the high byte of the address. See &lt;a href=&quot;avr-built_002din-functions#AVR-Built_002din-Functions&quot;&gt;&lt;code&gt;__builtin_avr_flash_segment&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Это 24-битное адресное пространство, которое линеаризует флэш-память и ОЗУ: если установлен старший бит адреса, данные считываются из ОЗУ с использованием младших двух байтов в качестве адреса ОЗУ. Если старший бит адреса очищен, данные считываются из флэш-памяти с &lt;code&gt;RAMPZ&lt;/code&gt; , установленным в соответствии со старшим байтом адреса. См. &lt;a href=&quot;avr-built_002din-functions#AVR-Built_002din-Functions&quot;&gt; &lt;code&gt;__builtin_avr_flash_segment&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c3eadc5a720e67193fff3510f3b6d516e5846adb" translate="yes" xml:space="preserve">
          <source>This is a debugging flag. When used in conjunction with</source>
          <target state="translated">Это флаг отладки.При использовании в сочетании с</target>
        </trans-unit>
        <trans-unit id="c173adebd0002ff9b3abf598cd2d9f90729d1e99" translate="yes" xml:space="preserve">
          <source>This is a literal string that is the template for the assembler code. It is a combination of fixed text and tokens that refer to the input, output, and goto parameters. See &lt;a href=&quot;#AssemblerTemplate&quot;&gt;AssemblerTemplate&lt;/a&gt;.</source>
          <target state="translated">Это буквальная строка, которая является шаблоном для кода ассемблера. Это комбинация фиксированного текста и токенов, которые относятся к параметрам ввода, вывода и перехода. См. &lt;a href=&quot;#AssemblerTemplate&quot;&gt;AssemblerTemplate&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0266778a01da6e94c7dbdd70401e030bc44b9214" translate="yes" xml:space="preserve">
          <source>This is a literal string that specifies the assembler code. The string can contain any instructions recognized by the assembler, including directives. GCC does not parse the assembler instructions themselves and does not know what they mean or even whether they are valid assembler input.</source>
          <target state="translated">Это литературная строка,задающая код ассемблера.Строка может содержать любые инструкции,распознанные ассемблером,включая директивы.GCC не разбирает сами инструкции ассемблера и не знает,что они означают или даже являются ли они действительными входными данными ассемблера.</target>
        </trans-unit>
        <trans-unit id="b220cd2425897f657363d80f6f8c621c9e9dc4d4" translate="yes" xml:space="preserve">
          <source>This is a more fine-grained version of</source>
          <target state="translated">Это более мелкозернистая версия</target>
        </trans-unit>
        <trans-unit id="210265ec50f329c0444d753e710536de44906855" translate="yes" xml:space="preserve">
          <source>This is a property of the linker. C99 and C11 require that case distinctions are always significant in identifiers with external linkage and systems without this property are not supported by GCC.</source>
          <target state="translated">Это собственность компоновщика.C99 и C11 требуют,чтобы различия в регистре всегда были значительными в идентификаторах с внешней связью,а системы без этого свойства не поддерживаются GCC.</target>
        </trans-unit>
        <trans-unit id="efc75a30c66eb95f41ba11f1badfcb67f0cc09c0" translate="yes" xml:space="preserve">
          <source>This is a set of options that are used to explicitly disable/enable optimization passes. These options are intended for use for debugging GCC. Compiler users should use regular options for enabling/disabling passes instead.</source>
          <target state="translated">Это набор опций,которые используются для явного отключения/подключения проходов оптимизации.Эти опции предназначены для использования при отладке GCC.Пользователи компилятора должны использовать обычные опции для включения/выключения передач.</target>
        </trans-unit>
        <trans-unit id="c7a5bbf22b220bbd15b9398c9ef72c66a3e9df59" translate="yes" xml:space="preserve">
          <source>This is a synonym for</source>
          <target state="translated">Это синоним</target>
        </trans-unit>
        <trans-unit id="fe3ee5c4bc9712f6bcac0ed8f03115711a2bebe4" translate="yes" xml:space="preserve">
          <source>This is an acceptable initializer even if &lt;var&gt;EXPRESSION&lt;/var&gt; is not a constant expression, including the case where &lt;code&gt;__builtin_constant_p&lt;/code&gt; returns 1 because &lt;var&gt;EXPRESSION&lt;/var&gt; can be folded to a constant but &lt;var&gt;EXPRESSION&lt;/var&gt; contains operands that are not otherwise permitted in a static initializer (for example, &lt;code&gt;0 &amp;amp;&amp;amp; foo ()&lt;/code&gt;). GCC must be more conservative about evaluating the built-in in this case, because it has no opportunity to perform optimization.</source>
          <target state="translated">Это приемлемый инициализатор, даже если &lt;var&gt;EXPRESSION&lt;/var&gt; не является постоянным выражением, включая случай, когда &lt;code&gt;__builtin_constant_p&lt;/code&gt; возвращает 1, потому что &lt;var&gt;EXPRESSION&lt;/var&gt; может быть свернут до константы, но &lt;var&gt;EXPRESSION&lt;/var&gt; содержит операнды, которые иначе не разрешены в статическом инициализаторе (например, &lt;code&gt;0 &amp;amp;&amp;amp; foo ()&lt;/code&gt; ). GCC должен быть более консервативным в оценке встроенного в этом случае, потому что у него нет возможности выполнить оптимизацию.</target>
        </trans-unit>
        <trans-unit id="e0aaa7cf6754c8cbdc72fa557e1be8935391e808" translate="yes" xml:space="preserve">
          <source>This is an advanced section. Type encodings are used extensively by the compiler and by the runtime, but you generally do not need to know about them to use Objective-C.</source>
          <target state="translated">Это продвинутая секция.Кодировки типов широко используются компилятором и во время выполнения,но,как правило,для использования Objective-C вам не нужно знать о них.</target>
        </trans-unit>
        <trans-unit id="7f363131e14be21e154381e2dda1e3e5a071a820" translate="yes" xml:space="preserve">
          <source>This is an alternative to creating a union with a &lt;code&gt;double&lt;/code&gt; member, which forces the union to be double-word aligned.</source>
          <target state="translated">Это альтернатива созданию объединения с &lt;code&gt;double&lt;/code&gt; элементом, при котором объединение выравнивается по двойному слову.</target>
        </trans-unit>
        <trans-unit id="07d312a53d8e7c9544d42f284a8fb92ee207ce56" translate="yes" xml:space="preserve">
          <source>This is an implementation of the ISO C99 function &lt;code&gt;nan&lt;/code&gt;.</source>
          <target state="translated">Это реализация функции ISO C99 &lt;code&gt;nan&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6bb58cdaec11ea8785a298afd036692620cb8a71" translate="yes" xml:space="preserve">
          <source>This is because 2147483648 cannot fit in the type &lt;code&gt;int&lt;/code&gt;, so (following the ISO C rules) its data type is &lt;code&gt;unsigned long int&lt;/code&gt;. Negating this value yields 2147483648 again.</source>
          <target state="translated">Это связано с тем, что 2147483648 не может соответствовать типу &lt;code&gt;int&lt;/code&gt; , поэтому (согласно правилам ISO C) его тип данных - &lt;code&gt;unsigned long int&lt;/code&gt; . Отрицание этого значения снова дает 2147483648.</target>
        </trans-unit>
        <trans-unit id="cbcf60838e5c265166bf0d438d003168c4b74356" translate="yes" xml:space="preserve">
          <source>This is bound applied to calls which are considered relevant with</source>
          <target state="translated">Это относится к звонкам,которые считаются релевантными для</target>
        </trans-unit>
        <trans-unit id="5195f538541a2304ddd489646469dec48a8ccb37" translate="yes" xml:space="preserve">
          <source>This is bound applied to calls which are optimized for size. Small growth may be desirable to anticipate optimization oppurtunities exposed by inlining.</source>
          <target state="translated">Это привязывается к вызовам,оптимизированным по размеру.Небольшой рост может быть желателен для того,чтобы предвидеть возможности оптимизации,выявляемые с помощью подчёркивания.</target>
        </trans-unit>
        <trans-unit id="6762670483f9855e0a3aefbae371bb5703501c2b" translate="yes" xml:space="preserve">
          <source>This is called a &lt;em&gt;matching constraint&lt;/em&gt; and what it really means is that the assembler has only a single operand that fills two roles which &lt;code&gt;asm&lt;/code&gt; distinguishes. For example, an add instruction uses two input operands and an output operand, but on most CISC machines an add instruction really has only two operands, one of them an input-output operand:</source>
          <target state="translated">Это называется &lt;em&gt;ограничением соответствия,&lt;/em&gt; и на самом деле это означает, что ассемблер имеет только один операнд, который выполняет две роли, которые различаются в &lt;code&gt;asm&lt;/code&gt; . Например, инструкция добавления использует два входных операнда и выходной операнд, но на большинстве машин CISC инструкция добавления действительно имеет только два операнда, один из которых является операндом ввода-вывода:</target>
        </trans-unit>
        <trans-unit id="c074cd27c3a79447115b4b73b7a639c3b4fa2a8e" translate="yes" xml:space="preserve">
          <source>This is currently implemented using the stronger &lt;code&gt;__ATOMIC_ACQUIRE&lt;/code&gt; memory order because of a deficiency in C++11&amp;rsquo;s semantics for &lt;code&gt;memory_order_consume&lt;/code&gt;.</source>
          <target state="translated">В настоящее время это реализовано с использованием более сильного &lt;code&gt;__ATOMIC_ACQUIRE&lt;/code&gt; памяти __ATOMIC_ACQUIRE из-за недостатка семантики C ++ 11 для &lt;code&gt;memory_order_consume&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2b3d9a8a2627972c9a778aee53c0d0ec3f855978" translate="yes" xml:space="preserve">
          <source>This is dependent on the implementation of the C library, and is not defined by GCC itself.</source>
          <target state="translated">Это зависит от реализации библиотеки Си и не определяется самим GCC.</target>
        </trans-unit>
        <trans-unit id="9b7b67a920492c1fed38bbae2d29e3b5c143fedc" translate="yes" xml:space="preserve">
          <source>This is enabled by default when outputting DWARF 2 debug information at the normal level, as long as there is assembler support,</source>
          <target state="translated">Это включено по умолчанию при выводе отладочной информации DWARF 2 на обычном уровне,при условии наличия поддержки ассемблера,</target>
        </trans-unit>
        <trans-unit id="99ef91485a4d9927171b8579ed4d91ac7ed3d923" translate="yes" xml:space="preserve">
          <source>This is equivalent to writing the following:</source>
          <target state="translated">Это эквивалентно написанию следующего:</target>
        </trans-unit>
        <trans-unit id="aebe9f9ed1ec955a9599f55edc4af825e40a4ee7" translate="yes" xml:space="preserve">
          <source>This is generally desirable, because assembler-generated line-number tables are a lot more compact than those the compiler can generate itself.</source>
          <target state="translated">В целом это желательно,так как сгенерированные ассемблером таблицы нумерации строк намного компактнее,чем те,которые компилятор может сгенерировать сам.</target>
        </trans-unit>
        <trans-unit id="bfbcbb929b36a00d46e328a1a9742a8d812ee911" translate="yes" xml:space="preserve">
          <source>This is how GCC traditionally handled functions declared &lt;code&gt;inline&lt;/code&gt;. Since ISO C99 specifies a different semantics for &lt;code&gt;inline&lt;/code&gt;, this function attribute is provided as a transition measure and as a useful feature in its own right. This attribute is available in GCC 4.1.3 and later. It is available if either of the preprocessor macros &lt;code&gt;__GNUC_GNU_INLINE__&lt;/code&gt; or &lt;code&gt;__GNUC_STDC_INLINE__&lt;/code&gt; are defined. See &lt;a href=&quot;inline#Inline&quot;&gt;An Inline Function is As Fast As a Macro&lt;/a&gt;.</source>
          <target state="translated">Именно так GCC традиционно обрабатывает функции, объявленные &lt;code&gt;inline&lt;/code&gt; . Поскольку ISO C99 определяет другую семантику для &lt;code&gt;inline&lt;/code&gt; , этот атрибут функции предоставляется как мера перехода и как самостоятельная полезная функция. Этот атрибут доступен в GCC 4.1.3 и новее. Он доступен, если определен любой из макросов препроцессора &lt;code&gt;__GNUC_GNU_INLINE__&lt;/code&gt; или &lt;code&gt;__GNUC_STDC_INLINE__&lt;/code&gt; . См. &lt;a href=&quot;inline#Inline&quot;&gt;&amp;laquo;Встроенная функция работает так же быстро, как макрос&amp;raquo;&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3659f6c91bb02b5cd8a55719f9462825417fbf7f" translate="yes" xml:space="preserve">
          <source>This is in all ways equivalent to the ISO C example above, but arguably more readable and descriptive.</source>
          <target state="translated">Это во всех отношениях эквивалентно приведенному выше примеру ИСО С,но,возможно,более читабельно и описательно.</target>
        </trans-unit>
        <trans-unit id="1eaa9666a3a5435e04f459b069a65e1a2259a5c1" translate="yes" xml:space="preserve">
          <source>This is intended for use by GCC developers and plugin developers when debugging diagnostics that report interprocedural control flow.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e833378dc7330796a80aef851e1b40fc5a1e0901" translate="yes" xml:space="preserve">
          <source>This is just like &amp;lsquo;</source>
          <target state="translated">Это похоже на</target>
        </trans-unit>
        <trans-unit id="87943af8f7660938d198a190217b23c8ea1f6e48" translate="yes" xml:space="preserve">
          <source>This is like</source>
          <target state="translated">Это как</target>
        </trans-unit>
        <trans-unit id="37d0e0a31c79678362e2daef4bb85a617b64f850" translate="yes" xml:space="preserve">
          <source>This is more friendly to code living in shared libraries, as it reduces the number of dynamic relocations that are needed, and by consequence, allows the data to be read-only. This alternative with label differences is not supported for the AVR target, please use the first approach for AVR programs.</source>
          <target state="translated">Это более удобно для кода,живущего в разделяемых библиотеках,так как сокращает количество необходимых динамических перемещений,и,как следствие,позволяет данным быть доступными только для чтения.Эта альтернатива с различиями в метках не поддерживается для целей AVR,пожалуйста,используйте первый подход для программ AVR.</target>
        </trans-unit>
        <trans-unit id="52f8a99adebca7a079e1f334d570e3be716912f1" translate="yes" xml:space="preserve">
          <source>This is not correct on x86-64 as it would allocate tick in either &lt;code&gt;ax&lt;/code&gt; or &lt;code&gt;dx&lt;/code&gt;. You have to use the following variant instead:</source>
          <target state="translated">Это неверно для x86-64, так как тик будет выделен либо в &lt;code&gt;ax&lt;/code&gt; , либо в &lt;code&gt;dx&lt;/code&gt; . Вместо этого используйте следующий вариант:</target>
        </trans-unit>
        <trans-unit id="73c90434e16b0f55c0b872ec23da22fc830bc9a4" translate="yes" xml:space="preserve">
          <source>This is particularly useful for assumed-shape arrays in Fortran where (for example) it allows better vectorization assuming contiguous accesses. This flag is enabled by default at</source>
          <target state="translated">Это особенно полезно для массивов предполагаемой формы в Фортране,где (например)это позволяет лучше векторизовать,предполагая смежные доступы.Этот флаг включен по умолчанию на</target>
        </trans-unit>
        <trans-unit id="031672016e4d502c018309428e47661800aac1a9" translate="yes" xml:space="preserve">
          <source>This is similar to</source>
          <target state="translated">Это похоже на</target>
        </trans-unit>
        <trans-unit id="b5bdec22d274cc0ce57cbe3e424189dc32fd8d9a" translate="yes" xml:space="preserve">
          <source>This is the C variable or expression being passed to the &lt;code&gt;asm&lt;/code&gt; statement as input. The enclosing parentheses are a required part of the syntax.</source>
          <target state="translated">Это переменная или выражение C, передаваемое в оператор &lt;code&gt;asm&lt;/code&gt; в качестве входных данных. Заключительные скобки являются обязательной частью синтаксиса.</target>
        </trans-unit>
        <trans-unit id="08fb1a095794b3c3899440175335ee88759da275" translate="yes" xml:space="preserve">
          <source>This is the default (normal) setting. The only traps that are enabled are the ones that cannot be disabled in software (e.g., division by zero trap).</source>
          <target state="translated">Это настройка по умолчанию (нормальная).Включены только ловушки,которые не могут быть отключены в программном обеспечении (например,деление на нулевую ловушку).</target>
        </trans-unit>
        <trans-unit id="1a4c45120ca7a63ffc2a2ee3465224f90ffe09ce" translate="yes" xml:space="preserve">
          <source>This is the default choice for non-Darwin x86-32 targets.</source>
          <target state="translated">Это выбор по умолчанию для целей,не относящихся к Darwin x86-32.</target>
        </trans-unit>
        <trans-unit id="59c124a9358a8d1126f10890f1eb504cdd7df946" translate="yes" xml:space="preserve">
          <source>This is the default choice for the x86-64 compiler, Darwin x86-32 targets, and the default choice for x86-32 targets with the SSE2 instruction set when</source>
          <target state="translated">Это выбор по умолчанию для x86-64 компилятора,Darwin x86-32 целей,и выбор по умолчанию для x86-32 целей с набором инструкций SSE2,когда</target>
        </trans-unit>
        <trans-unit id="b74e8d3240c6f67db12f1d7fa81a7aa2edb28fb1" translate="yes" xml:space="preserve">
          <source>This is the default on some targets.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a72e96be7931cf0f817380bd16aa70bcfafbbfe8" translate="yes" xml:space="preserve">
          <source>This is the default warning level of</source>
          <target state="translated">Это уровень предупреждений по умолчанию</target>
        </trans-unit>
        <trans-unit id="2cf92c2da398ed082aa03bcf05470475390ec8ef" translate="yes" xml:space="preserve">
          <source>This is the generic version of an atomic exchange. It stores the contents of &lt;code&gt;*&lt;var&gt;val&lt;/var&gt;&lt;/code&gt; into &lt;code&gt;*&lt;var&gt;ptr&lt;/var&gt;&lt;/code&gt;. The original value of &lt;code&gt;*&lt;var&gt;ptr&lt;/var&gt;&lt;/code&gt; is copied into &lt;code&gt;*&lt;var&gt;ret&lt;/var&gt;&lt;/code&gt;.</source>
          <target state="translated">Это общая версия атомарного обмена. Он сохраняет содержимое &lt;code&gt;*&lt;var&gt;val&lt;/var&gt;&lt;/code&gt; в &lt;code&gt;*&lt;var&gt;ptr&lt;/var&gt;&lt;/code&gt; . Исходное значение &lt;code&gt;*&lt;var&gt;ptr&lt;/var&gt;&lt;/code&gt; копируется в &lt;code&gt;*&lt;var&gt;ret&lt;/var&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="544eb750f0727dd454c0757327b302d011f9d8e4" translate="yes" xml:space="preserve">
          <source>This is the generic version of an atomic load. It returns the contents of &lt;code&gt;*&lt;var&gt;ptr&lt;/var&gt;&lt;/code&gt; in &lt;code&gt;*&lt;var&gt;ret&lt;/var&gt;&lt;/code&gt;.</source>
          <target state="translated">Это общая версия атомарной загрузки. Он возвращает содержимое &lt;code&gt;*&lt;var&gt;ptr&lt;/var&gt;&lt;/code&gt; в &lt;code&gt;*&lt;var&gt;ret&lt;/var&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="21175b474269d19f2c711f8904d430397eb7f000" translate="yes" xml:space="preserve">
          <source>This is the generic version of an atomic store. It stores the value of &lt;code&gt;*&lt;var&gt;val&lt;/var&gt;&lt;/code&gt; into &lt;code&gt;*&lt;var&gt;ptr&lt;/var&gt;&lt;/code&gt;.</source>
          <target state="translated">Это общая версия атомарного хранилища. Он сохраняет значение &lt;code&gt;*&lt;var&gt;val&lt;/var&gt;&lt;/code&gt; в &lt;code&gt;*&lt;var&gt;ptr&lt;/var&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="38581f9b32f6622e3fe0d5bb58e5ec8a4bb25cbf" translate="yes" xml:space="preserve">
          <source>This is the mode used for floating-point calculations with round-to-nearest-or-even rounding mode.</source>
          <target state="translated">Этот режим используется для вычислений с плавающей точкой с округлением до ближайшего или равномерного округления.</target>
        </trans-unit>
        <trans-unit id="2425d7e7a37939aa94f7a4685eaf2c7dc785155a" translate="yes" xml:space="preserve">
          <source>This is the mode used for floating-point calculations with truncating (i.e. round towards zero) rounding mode. That includes conversion from floating point to integer.</source>
          <target state="translated">Этот режим используется для вычислений с плавающей точкой с усечением (т.е.округлением до нуля).Включает в себя преобразование из плавающей точки в целое число.</target>
        </trans-unit>
        <trans-unit id="35b95ca7a0555a082526c5eeface6f56baa751e7" translate="yes" xml:space="preserve">
          <source>This is the mode used to perform integer calculations in the FPU, e.g. integer multiply, or integer multiply-and-accumulate.</source>
          <target state="translated">Этот режим используется для выполнения целочисленных вычислений в программируемом терминале,например,целочисленного умножения или целочисленного умножения и накопления.</target>
        </trans-unit>
        <trans-unit id="4098e33c6565f575396e0bc34dbbf7c96adebca6" translate="yes" xml:space="preserve">
          <source>This is the same as &amp;lsquo;</source>
          <target state="translated">Это то же самое, что и '</target>
        </trans-unit>
        <trans-unit id="63f530e06bab16bd703cfd6e987a5d2afe910c22" translate="yes" xml:space="preserve">
          <source>This is the simplest option, but also offers flexibility and fine-grained control when necessary. It is also the most portable alternative and programs using this approach will work with most modern compilers.</source>
          <target state="translated">Это самая простая опция,но в то же время она обеспечивает гибкость и тонкий контроль в случае необходимости.Он также является наиболее переносимой альтернативой,и программы,использующие этот подход,будут работать с большинством современных компиляторов.</target>
        </trans-unit>
        <trans-unit id="92ad0261cb0958c1d426eccb32a1c93544a5dc43" translate="yes" xml:space="preserve">
          <source>This is the warning level of</source>
          <target state="translated">Это уровень предупреждений</target>
        </trans-unit>
        <trans-unit id="77e89dce84a517cc123ca42eb8de81a6643ce569" translate="yes" xml:space="preserve">
          <source>This is the warning level that is enabled by</source>
          <target state="translated">Это уровень предупреждений,который включается с помощью</target>
        </trans-unit>
        <trans-unit id="760cf4bac038578756206c93dae00fb9cba073c6" translate="yes" xml:space="preserve">
          <source>This is typical output:</source>
          <target state="translated">Это типичный выход:</target>
        </trans-unit>
        <trans-unit id="da7f2d31c6f9672e3ba4ae5efbb305bb596a464e" translate="yes" xml:space="preserve">
          <source>This is useful when &lt;code&gt;gcc&lt;/code&gt; prints the error message &amp;lsquo;</source>
          <target state="translated">Это полезно, когда &lt;code&gt;gcc&lt;/code&gt; выводит сообщение об ошибке '</target>
        </trans-unit>
        <trans-unit id="61900c28d4f89d472663c0fb34d75c4a85cd7c53" translate="yes" xml:space="preserve">
          <source>This is useful when you use</source>
          <target state="translated">Это полезно,когда вы используете</target>
        </trans-unit>
        <trans-unit id="f021b4a2b4ebd3ad97c6de7e5e1dd3f9efc1450f" translate="yes" xml:space="preserve">
          <source>This is why GCC does and will treat plain bit-fields in the same fashion on all types of machines (by default).</source>
          <target state="translated">Вот почему GCC делает и будет обрабатывать обычные битовые поля одинаково на всех типах машин (по умолчанию).</target>
        </trans-unit>
        <trans-unit id="4b959d24ea2462316c67c3712ca90973257d6c02" translate="yes" xml:space="preserve">
          <source>This level is intended for analyzer developers; it adds various other events intended for debugging the analyzer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c1b93195f2512278e6a6fff2538323d8e57d38c" translate="yes" xml:space="preserve">
          <source>This level is the default.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="700e39a7f2669dafee2d84e8e1e01bff08feb798" translate="yes" xml:space="preserve">
          <source>This macro reflects the</source>
          <target state="translated">Этот макрос отражает</target>
        </trans-unit>
        <trans-unit id="7d487e0152f8e873aae65c9ae3d1ffd07da68324" translate="yes" xml:space="preserve">
          <source>This manual documents how to use the GNU compilers, as well as their features and incompatibilities, and how to report bugs. It corresponds to the compilers (GCC) version 10.2.0. The internals of the GNU compilers, including how to port them to new targets and some information about how to write front ends for new languages, are documented in a separate manual. See &lt;a href=&quot;http://gcc.gnu.org/onlinedocs/gccint/index.html#Top&quot;&gt;Introduction&lt;/a&gt; in GNU Compiler Collection (GCC) Internals.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6bdcb3e9969165c215f71af0ae0651edbd99ccc3" translate="yes" xml:space="preserve">
          <source>This manual documents how to use the GNU compilers, as well as their features and incompatibilities, and how to report bugs. It corresponds to the compilers (GCC) version 10.2.0. The internals of the GNU compilers, including how to port them to new targets and some information about how to write front ends for new languages, are documented in a separate manual. See &lt;a href=&quot;https://gcc.gnu.org/onlinedocs/gccint/index.html#Top&quot;&gt;Introduction&lt;/a&gt; in GNU Compiler Collection (GCC) Internals.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1653245bf51b1f0c3c2fa674b4064d9aab7d9670" translate="yes" xml:space="preserve">
          <source>This manual documents how to use the GNU compilers, as well as their features and incompatibilities, and how to report bugs. It corresponds to the compilers (GCC) version 9.2.0. The internals of the GNU compilers, including how to port them to new targets and some information about how to write front ends for new languages, are documented in a separate manual. See &lt;a href=&quot;http://gcc.gnu.org/onlinedocs/gccint/index.html#Top&quot;&gt;Introduction&lt;/a&gt; in GNU Compiler Collection (GCC) Internals.</source>
          <target state="translated">В этом руководстве описано, как использовать компиляторы GNU, а также их функции и несовместимости, а также как сообщать об ошибках. Соответствует компиляторам (GCC) версии 9.2.0. Внутреннее устройство компиляторов GNU, включая то, как их переносить на новые цели, и некоторая информация о том, как писать интерфейсы для новых языков, задокументированы в отдельном руководстве. См. &lt;a href=&quot;http://gcc.gnu.org/onlinedocs/gccint/index.html#Top&quot;&gt;Введение&lt;/a&gt; во внутреннее устройство GNU Compiler Collection (GCC).</target>
        </trans-unit>
        <trans-unit id="d1e0ea996271f7db110a1aacecb995078842dd10" translate="yes" xml:space="preserve">
          <source>This mechanism is not intended to be a replacement for &lt;code&gt;+initialize&lt;/code&gt;. You should be aware of its limitations when you decide to use it instead of &lt;code&gt;+initialize&lt;/code&gt;.</source>
          <target state="translated">Этот механизм не предназначен для замены &lt;code&gt;+initialize&lt;/code&gt; . Вы должны знать о его ограничениях, когда решите использовать его вместо &lt;code&gt;+initialize&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0b86e98dae575f25e7dd277f55069259f5a76e0f" translate="yes" xml:space="preserve">
          <source>This might appear strange; if an insn allows a constant operand with a value not known at compile time, it certainly must allow any known value. So why use &amp;lsquo;</source>
          <target state="translated">Это может показаться странным; Если insn допускает постоянный операнд со значением, неизвестным во время компиляции, он, безусловно, должен разрешать любое известное значение. Так зачем использовать '</target>
        </trans-unit>
        <trans-unit id="93b2398d0b07a68172b830b044a2e5af1fdcea09" translate="yes" xml:space="preserve">
          <source>This number is allowed to be more than a single digit. If multiple digits are encountered consecutively, they are interpreted as a single decimal integer. There is scant chance for ambiguity, since to-date it has never been desirable that &amp;lsquo;</source>
          <target state="translated">Этот номер может состоять более чем из одной цифры. Если последовательно встречаются несколько цифр, они интерпретируются как одно десятичное целое число. Вероятность двусмысленности очень мала, поскольку на сегодняшний день это никогда не было желательным.</target>
        </trans-unit>
        <trans-unit id="22e75e50204b22e1eb4e9e0ef88e476b337f8735" translate="yes" xml:space="preserve">
          <source>This occurs because sometimes GCC optimizes the variable out of existence. There is no way to tell the debugger how to compute the value such a variable &amp;ldquo;would have had&amp;rdquo;, and it is not clear that would be desirable anyway. So GCC simply does not mention the eliminated variable when it writes debugging information.</source>
          <target state="translated">Это происходит потому, что иногда GCC оптимизирует отсутствие переменной. Невозможно указать отладчику, как вычислить значение, которое такая переменная &amp;laquo;могла бы иметь&amp;raquo;, и неясно, что в любом случае было бы желательно. Таким образом, GCC просто не упоминает исключенную переменную при записи отладочной информации.</target>
        </trans-unit>
        <trans-unit id="5ce0fa0b0cabdd9e15b52efa7f6d71eba5c1f802" translate="yes" xml:space="preserve">
          <source>This only makes sense when scheduling after register allocation, i.e. with</source>
          <target state="translated">Это имеет смысл только при планировании после распределения регистров,т.е.с помощью</target>
        </trans-unit>
        <trans-unit id="db13c5371ec3d6856069cde7f84c42a79ba4d667" translate="yes" xml:space="preserve">
          <source>This optimization is automatically turned off in the presence of exception handling or unwind tables (on targets using setjump/longjump or target specific scheme), for linkonce sections, for functions with a user-defined section attribute and on any architecture that does not support named sections. When</source>
          <target state="translated">Данная оптимизация автоматически отключается при наличии обработки исключений или размотки таблиц (на объектах с использованием setjump/longjump или целевой специфической схемы),для линковочных секций,для функций с пользовательским атрибутом секции и на любой архитектуре,не поддерживающей именованные секции.При</target>
        </trans-unit>
        <trans-unit id="96a50b9ceb3aa5aae8cfa612292d0e06f418fdee" translate="yes" xml:space="preserve">
          <source>This optimization is enabled by default for PowerPC targets, but disabled by default otherwise.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="03a904b6f6255ac7a46cba1abdfa2fc80dcd97c1" translate="yes" xml:space="preserve">
          <source>This optimization is enabled by default.</source>
          <target state="translated">Эта оптимизация включена по умолчанию.</target>
        </trans-unit>
        <trans-unit id="cd622740636a8f6bc187abc5bbcb4be9fb8826dc" translate="yes" xml:space="preserve">
          <source>This optimization is off by default at all optimization levels.</source>
          <target state="translated">По умолчанию эта оптимизация отключена на всех уровнях оптимизации.</target>
        </trans-unit>
        <trans-unit id="96c9c932cfd47ab32407f6161d42f932d1499bb6" translate="yes" xml:space="preserve">
          <source>This option allows further control over excess precision on machines where floating-point operations occur in a format with more precision or range than the IEEE standard and interchange floating-point types. By default,</source>
          <target state="translated">Эта опция позволяет дополнительно контролировать избыточную точность на станках,на которых операции с плавающей запятой выполняются в формате с большей точностью или диапазоном,чем стандарт IEEE и сменные типы плавающей запятой.По умолчанию,</target>
        </trans-unit>
        <trans-unit id="0cd275b48533fab7a99c41cb026721abbe83dfbd" translate="yes" xml:space="preserve">
          <source>This option allows use of a precompiled header (see &lt;a href=&quot;precompiled-headers#Precompiled-Headers&quot;&gt;Precompiled Headers&lt;/a&gt;) together with</source>
          <target state="translated">Эта опция позволяет использовать предварительно скомпилированный заголовок (см. &lt;a href=&quot;precompiled-headers#Precompiled-Headers&quot;&gt;Предварительно скомпилированные заголовки&lt;/a&gt; ) вместе с</target>
        </trans-unit>
        <trans-unit id="bc138a12e44acf9ec0d9c17239119bb46de565b8" translate="yes" xml:space="preserve">
          <source>This option also controls warnings when a user-defined literal operator is declared with a literal suffix identifier that doesn&amp;rsquo;t begin with an underscore. Literal suffix identifiers that don&amp;rsquo;t begin with an underscore are reserved for future standardization.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="176e6d10a5020dcedfe440b551f5e25423a91471" translate="yes" xml:space="preserve">
          <source>This option also enables</source>
          <target state="translated">Эта опция также позволяет</target>
        </trans-unit>
        <trans-unit id="f64cb852c815528bec1c35d19339c840b9bc9852" translate="yes" xml:space="preserve">
          <source>This option also enables warnings about psABI-related changes. The known psABI changes at this point include:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="44de7a78056937b7baedfa3be44429b20f8420b9" translate="yes" xml:space="preserve">
          <source>This option also warns when &lt;code&gt;alloca&lt;/code&gt; is used in a loop.</source>
          <target state="translated">Эта опция также предупреждает, когда &lt;code&gt;alloca&lt;/code&gt; используется в цикле.</target>
        </trans-unit>
        <trans-unit id="8dcb0d8b589589b99a6d5de3a4fa4b5fc06db20b" translate="yes" xml:space="preserve">
          <source>This option also warns when a non-volatile automatic variable might be changed by a call to &lt;code&gt;longjmp&lt;/code&gt;. The compiler sees only the calls to &lt;code&gt;setjmp&lt;/code&gt;. It cannot know where &lt;code&gt;longjmp&lt;/code&gt; will be called; in fact, a signal handler could call it at any point in the code. As a result, you may get a warning even when there is in fact no problem because &lt;code&gt;longjmp&lt;/code&gt; cannot in fact be called at the place that would cause a problem.</source>
          <target state="translated">Эта опция также предупреждает, когда энергонезависимая автоматическая переменная может быть изменена вызовом &lt;code&gt;longjmp&lt;/code&gt; . Компилятор видит только вызовы &lt;code&gt;setjmp&lt;/code&gt; . Он не может знать, где будет вызван &lt;code&gt;longjmp&lt;/code&gt; ; фактически, обработчик сигнала может вызвать его в любой точке кода. В результате вы можете получить предупреждение, даже если на самом деле проблем нет, потому что &lt;code&gt;longjmp&lt;/code&gt; фактически не может быть вызван в месте, которое могло бы вызвать проблему.</target>
        </trans-unit>
        <trans-unit id="647a82f2f84be9cba875128f0dca433a10d57f59" translate="yes" xml:space="preserve">
          <source>This option and its counterpart,</source>
          <target state="translated">Этот вариант и его аналог,</target>
        </trans-unit>
        <trans-unit id="5138f290e3826f8790e3e713269029e9ccdb5e45" translate="yes" xml:space="preserve">
          <source>This option behaves mostly the same as the MSP430 function attribute of the same name (see &lt;a href=&quot;msp430-function-attributes#MSP430-Function-Attributes&quot;&gt;MSP430 Function Attributes&lt;/a&gt;), but it has some additional functionality.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d7bf60baf10d559ca0b1b6d693e3ba93b5e1f2d3" translate="yes" xml:space="preserve">
          <source>This option can also serve as a replacement for the older way of specifying custom device-specs files that needed</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="51f89764d458f9e6ce2a9e5debf60911dcf32abd" translate="yes" xml:space="preserve">
          <source>This option can be overridden for individual functions with the &lt;code&gt;hotpatch&lt;/code&gt; attribute.</source>
          <target state="translated">Этот параметр можно переопределить для отдельных функций с &lt;code&gt;hotpatch&lt;/code&gt; атрибута hotpatch .</target>
        </trans-unit>
        <trans-unit id="b9d6d68f8663846b608b68015e96e5892b5536f8" translate="yes" xml:space="preserve">
          <source>This option can be used in combination with</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6031ab076087301a6d0abbb423cf52dcdfaad6ad" translate="yes" xml:space="preserve">
          <source>This option can be used with</source>
          <target state="translated">Эта опция может быть использована с</target>
        </trans-unit>
        <trans-unit id="ffe3df6bb53541974a1831b4cc4d1b56a60baa8e" translate="yes" xml:space="preserve">
          <source>This option can lead to reduced code size for functions that perform several calls to functions that get their arguments on the stack like calls to printf-like functions.</source>
          <target state="translated">Эта опция может привести к уменьшению размера кода для функций,которые выполняют несколько вызовов функций,получающих свои аргументы на стеке,например,вызовы printf-подобных функций.</target>
        </trans-unit>
        <trans-unit id="659720e1c331361819e1f19306618a073823d1ae" translate="yes" xml:space="preserve">
          <source>This option can only be used if the target architecture supports branch-likely instructions.</source>
          <target state="translated">Эта опция может быть использована только в том случае,если целевая архитектура поддерживает инструкции,похожие на ветки.</target>
        </trans-unit>
        <trans-unit id="fc3a9caac6f7198e302fb437322053279f7c71d0" translate="yes" xml:space="preserve">
          <source>This option cannot be suffixed by feature modifiers.</source>
          <target state="translated">Эта опция не может быть дополнена модификаторами функций.</target>
        </trans-unit>
        <trans-unit id="c576211fac72dc023de0044164971c10d96f526d" translate="yes" xml:space="preserve">
          <source>This option causes GCC to create markers in the internal representation at the beginning of statements, and to keep them roughly in place throughout compilation, using them to guide the output of &lt;code&gt;is_stmt&lt;/code&gt; markers in the line number table. This is enabled by default when compiling with optimization (</source>
          <target state="translated">Эта опция заставляет GCC создавать маркеры во внутреннем представлении в начале операторов и поддерживать их примерно на месте на протяжении компиляции, используя их для направления вывода маркеров &lt;code&gt;is_stmt&lt;/code&gt; в таблице номеров строк. Это включено по умолчанию при компиляции с оптимизацией (</target>
        </trans-unit>
        <trans-unit id="95c8757dd3d3337f46ca394f8f8769868a644ecd" translate="yes" xml:space="preserve">
          <source>This option causes r2 and r5 to be treated as fixed registers.</source>
          <target state="translated">Эта опция приводит к тому,что r2 и r5 обрабатываются как фиксированные регистры.</target>
        </trans-unit>
        <trans-unit id="b5e090b60ad88e1f4ec2772be778990575505b68" translate="yes" xml:space="preserve">
          <source>This option causes r2 and r5 to be used in the code generated by the compiler. This setting is the default.</source>
          <target state="translated">Эта опция приводит к использованию r2 и r5 в коде,генерируемом компилятором.Данная настройка является настройкой по умолчанию.</target>
        </trans-unit>
        <trans-unit id="d3d04b742fdf172a830cc81fd460a113af18fcfc" translate="yes" xml:space="preserve">
          <source>This option causes run-time data structures to be built at program startup, which are used for verifying the vtable pointers. The options &amp;lsquo;</source>
          <target state="translated">Эта опция вызывает создание структур данных времени выполнения при запуске программы, которые используются для проверки указателей vtable. Варианты '</target>
        </trans-unit>
        <trans-unit id="a26b4242bc022197a5b469c4333379231dcfd91c" translate="yes" xml:space="preserve">
          <source>This option causes the compiler to abort compilation on the first error occurred rather than trying to keep going and printing further error messages.</source>
          <target state="translated">Эта опция приводит к тому,что компилятор прерывает компиляцию при первой возникшей ошибке,а не пытается продолжать работу и печатать дальнейшие сообщения об ошибках.</target>
        </trans-unit>
        <trans-unit id="5e90ed4f8d16ef658451b5bbc4a698c1ccbdaac4" translate="yes" xml:space="preserve">
          <source>This option causes the preprocessor macro &lt;code&gt;__FAST_MATH__&lt;/code&gt; to be defined.</source>
          <target state="translated">Эта опция вызывает определение макроса препроцессора &lt;code&gt;__FAST_MATH__&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="59f74610163bdce44c421694716dba7eea2f36f3" translate="yes" xml:space="preserve">
          <source>This option causes the preprocessor macro &lt;code&gt;__SUPPORT_SNAN__&lt;/code&gt; to be defined.</source>
          <target state="translated">Эта опция вызывает определение макроса препроцессора &lt;code&gt;__SUPPORT_SNAN__&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c130859b377ff82df01657d63e921773dd0c4fe8" translate="yes" xml:space="preserve">
          <source>This option controls code generation of the link-time optimizer. By default the linker output is automatically determined by the linker plugin. For debugging the compiler and if incremental linking with a non-LTO object file is desired, it may be useful to control the type manually.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc144b835e4ef20a9b868419ab10431eef1dc3bb" translate="yes" xml:space="preserve">
          <source>This option controls stack space reuse for user declared local/auto variables and compiler generated temporaries. &lt;var&gt;reuse_level&lt;/var&gt; can be &amp;lsquo;</source>
          <target state="translated">Эта опция управляет повторным использованием пространства стека для объявленных пользователем локальных / автоматических переменных и временных библиотек, созданных компилятором. &lt;var&gt;reuse_level&lt;/var&gt; может быть '</target>
        </trans-unit>
        <trans-unit id="68a88d1554ed1aa2b217aa4277399c9f56f7ad9c" translate="yes" xml:space="preserve">
          <source>This option controls the code generation of the link time optimizer. By default the linker output is determined by the linker plugin automatically. For debugging the compiler and in the case of incremental linking to non-lto object file is desired, it may be useful to control the type manually.</source>
          <target state="translated">Эта опция управляет генерацией кода оптимизатора времени соединения.По умолчанию вывод линкера определяется плагином линкера автоматически.Для отладки компилятора и в случае необходимости инкрементной линковки на нелинквенный объектный файл,может быть полезно управлять типом вручную.</target>
        </trans-unit>
        <trans-unit id="9a86853e0ed7deb868803dd87757662761aedfd9" translate="yes" xml:space="preserve">
          <source>This option controls the complexity of the control flow paths that are emitted for analyzer diagnostics.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d9b7ff3f71ba23e9705b0d93e8591071e6bba1a" translate="yes" xml:space="preserve">
          <source>This option controls the default setting of the ISO C99 &lt;code&gt;CX_LIMITED_RANGE&lt;/code&gt; pragma. Nevertheless, the option applies to all languages.</source>
          <target state="translated">Этот параметр управляет настройкой по умолчанию &lt;code&gt;CX_LIMITED_RANGE&lt;/code&gt; ISO C99 CX_LIMITED_RANGE . Тем не менее, опция применима ко всем языкам.</target>
        </trans-unit>
        <trans-unit id="149f5a9a7f4ee5991089ef9512f0da137f76588e" translate="yes" xml:space="preserve">
          <source>This option controls the minimum width of the left margin printed by</source>
          <target state="translated">Эта опция контролирует минимальную ширину левого поля,напечатанного с помощью</target>
        </trans-unit>
        <trans-unit id="37de330d3f523306c4e20d85e9fac76a8d0f7abf" translate="yes" xml:space="preserve">
          <source>This option controls the priority that is assigned to dispatch-slot restricted instructions during the second scheduling pass. The argument &lt;var&gt;priority&lt;/var&gt; takes the value &amp;lsquo;</source>
          <target state="translated">Эта опция управляет приоритетом, который назначается инструкциям с ограниченным интервалом отправки во время второго прохода планирования. &lt;var&gt;priority&lt;/var&gt; аргумента принимает значение '</target>
        </trans-unit>
        <trans-unit id="00ce7609ded1a0ff2fbbb9740f9f2209c0f8ef1e" translate="yes" xml:space="preserve">
          <source>This option controls the version of libgcc that the compiler links to an executable and selects a software-managed cache for accessing variables in the &lt;code&gt;__ea&lt;/code&gt; address space with a particular cache size. Possible options for &lt;var&gt;cache-size&lt;/var&gt; are &amp;lsquo;</source>
          <target state="translated">Этот параметр управляет версией libgcc, которую компилятор связывает с исполняемым файлом, и выбирает программно управляемый кеш для доступа к переменным в адресном пространстве &lt;code&gt;__ea&lt;/code&gt; с определенным размером кеша. Возможные варианты &lt;var&gt;cache-size&lt;/var&gt; :</target>
        </trans-unit>
        <trans-unit id="9caa6f342fbdbf76f119015b6337636546395e60" translate="yes" xml:space="preserve">
          <source>This option controls the version of libgcc that the compiler links to an executable and selects whether atomic updates to the software-managed cache of PPU-side variables are used. If you use atomic updates, changes to a PPU variable from SPU code using the &lt;code&gt;__ea&lt;/code&gt; named address space qualifier do not interfere with changes to other PPU variables residing in the same cache line from PPU code. If you do not use atomic updates, such interference may occur; however, writing back cache lines is more efficient. The default behavior is to use atomic updates.</source>
          <target state="translated">Эта опция управляет версией libgcc, которую компилятор связывает с исполняемым файлом, и выбирает, используются ли атомарные обновления в программном кэше переменных на стороне PPU. Если вы используете атомарные обновления, изменения переменной PPU из кода SPU с использованием &lt;code&gt;__ea&lt;/code&gt; именованного адресного пространства __ea не мешают изменениям других переменных PPU, находящихся в той же строке кэша из кода PPU. Если вы не используете атомарные обновления, такое вмешательство может произойти; однако обратная запись строк кэша более эффективна. По умолчанию используются атомарные обновления.</target>
        </trans-unit>
        <trans-unit id="f61295df1d57ff262d461369dde8c3f32294d711" translate="yes" xml:space="preserve">
          <source>This option controls warnings for invocations of &lt;a href=&quot;_005f_005fatomic-builtins#g_t_005f_005fatomic-Builtins&quot;&gt;__atomic Builtins&lt;/a&gt;, &lt;a href=&quot;_005f_005fsync-builtins#g_t_005f_005fsync-Builtins&quot;&gt;__sync Builtins&lt;/a&gt;, and the C11 atomic generic functions with a memory consistency argument that is either invalid for the operation or outside the range of values of the &lt;code&gt;memory_order&lt;/code&gt; enumeration. For example, since the &lt;code&gt;__atomic_store&lt;/code&gt; and &lt;code&gt;__atomic_store_n&lt;/code&gt; built-ins are only defined for the relaxed, release, and sequentially consistent memory orders the following code is diagnosed:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d64a7975973f5229e105c9130aabc92aaaa20581" translate="yes" xml:space="preserve">
          <source>This option controls warnings if feedback profiles are missing when using the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="db5b3a6e625e42c517fab36eef17aa077a6434f1" translate="yes" xml:space="preserve">
          <source>This option controls warnings when a &lt;code&gt;switch&lt;/code&gt; case has a value that is outside of its respective type range. This warning is enabled by default for C and C++ programs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d647e87ba0a1edc0a3d0d54b53d61b0d1016c986" translate="yes" xml:space="preserve">
          <source>This option controls warnings when a base class is inaccessible in a class derived from it due to ambiguity. The warning is enabled by default. Note that the warning for ambiguous virtual bases is enabled by the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6199fdb67a75703bc6938c6426b3cd53c0cf499e" translate="yes" xml:space="preserve">
          <source>This option controls warnings when a declaration does not specify a type. This warning is enabled by default in C99 and later dialects of C, and also by</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="925a6115338780b00aeb738e9eb85ce67e1d1212" translate="yes" xml:space="preserve">
          <source>This option controls warnings when a function is used before being declared. This warning is enabled by default in C99 and later dialects of C, and also by</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e630e657c926dcb14e35c4ecbe7b78750ea05b99" translate="yes" xml:space="preserve">
          <source>This option controls warnings when an attribute is ignored. This is different from the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="23e0eea7f94b4ed1e828e2932547c5127c9ba599" translate="yes" xml:space="preserve">
          <source>This option controls what floating-point related traps are enabled. Other Alpha compilers call this option</source>
          <target state="translated">Эта опция контролирует,какие ловушки с плавающей точкой включены.Другие компиляторы Alpha вызывают эту опцию</target>
        </trans-unit>
        <trans-unit id="f1154974a88b020f8daf5bb4dc20170e8131c728" translate="yes" xml:space="preserve">
          <source>This option controls whether any out-of-line instance of the &lt;code&gt;__sync&lt;/code&gt; family of functions may be used to implement the C++11 &lt;code&gt;__atomic&lt;/code&gt; family of functions.</source>
          <target state="translated">Этот параметр определяет, можно ли использовать какой-либо &lt;code&gt;__sync&lt;/code&gt; семейства функций __sync для реализации семейства функций &lt;code&gt;__atomic&lt;/code&gt; C ++ 11 .</target>
        </trans-unit>
        <trans-unit id="a4a02927707c45d100e334cb80281cfb05688e67" translate="yes" xml:space="preserve">
          <source>This option controls which NOP insertion scheme is used during the second scheduling pass. The argument &lt;var&gt;scheme&lt;/var&gt; takes one of the following values:</source>
          <target state="translated">Эта опция контролирует, какая схема вставки NOP используется во время второго прохода планирования. Довод &lt;var&gt;scheme&lt;/var&gt; принимает один из следующих значений:</target>
        </trans-unit>
        <trans-unit id="c08ef18f138d574270868ecf3d1af53b2152507f" translate="yes" xml:space="preserve">
          <source>This option controls which dependences are considered costly by the target during instruction scheduling. The argument &lt;var&gt;dependence_type&lt;/var&gt; takes one of the following values:</source>
          <target state="translated">Эта опция контролирует, какие зависимости считаются дорогостоящими для цели при планировании инструкций. Аргумент &lt;var&gt;dependence_type&lt;/var&gt; принимает одно из следующих значений:</target>
        </trans-unit>
        <trans-unit id="eabb06a775f104526b72d8801ca8d34d938d08ee" translate="yes" xml:space="preserve">
          <source>This option controls which reciprocal estimate instructions may be used. &lt;var&gt;opt&lt;/var&gt; is a comma-separated list of options, which may be preceded by a &amp;lsquo;</source>
          <target state="translated">Эта опция контролирует, какие инструкции взаимной оценки могут использоваться. &lt;var&gt;opt&lt;/var&gt; - это список параметров, разделенных запятыми, которому может предшествовать символ '</target>
        </trans-unit>
        <trans-unit id="c61955646b487d462957b5ea4ab670cca58e8127" translate="yes" xml:space="preserve">
          <source>This option controls which reciprocal estimate instructions may be used. &lt;var&gt;opt&lt;/var&gt; is a comma-separated list of options, which may be preceded by a &lt;code&gt;!&lt;/code&gt; to invert the option:</source>
          <target state="translated">Эта опция контролирует, какие инструкции взаимной оценки могут использоваться. &lt;var&gt;opt&lt;/var&gt; - это список опций, разделенных запятыми, которому может предшествовать &lt;code&gt;!&lt;/code&gt; чтобы инвертировать опцию:</target>
        </trans-unit>
        <trans-unit id="a2ecce718b608dfca621af1742e2244436537a5c" translate="yes" xml:space="preserve">
          <source>This option currently only works for RTL dumps, and the RTL is always dumped in slim form.</source>
          <target state="translated">В настоящее время эта опция работает только для дампов RTL,а RTL всегда сбрасывается в тонком виде.</target>
        </trans-unit>
        <trans-unit id="a0efcaa928c1eb50d04d69e5ea5969a7461e4235" translate="yes" xml:space="preserve">
          <source>This option defaults to</source>
          <target state="translated">По умолчанию эта опция имеет следующие значения</target>
        </trans-unit>
        <trans-unit id="9fc2236cfdc032c6f548639c70136cdca6a33540" translate="yes" xml:space="preserve">
          <source>This option disables a target-specific pass in</source>
          <target state="translated">Эта опция отключает проход по цели в</target>
        </trans-unit>
        <trans-unit id="c70b4cbddab92e21116da323b06dd29142551856" translate="yes" xml:space="preserve">
          <source>This option disables all previously enabled sanitizers.</source>
          <target state="translated">Эта опция отключает все ранее включенные дезинфектанты.</target>
        </trans-unit>
        <trans-unit id="331b4b3e9a10408d9fe49b419ac451d5b43afbf6" translate="yes" xml:space="preserve">
          <source>This option does not affect the behavior of the</source>
          <target state="translated">Эта опция не влияет на поведение</target>
        </trans-unit>
        <trans-unit id="654b3209c6de0a321e02002e434d9a9983c5a1bb" translate="yes" xml:space="preserve">
          <source>This option does not suppress the preprocessor&amp;rsquo;s debug output, such as</source>
          <target state="translated">Эта опция не подавляет отладочные данные препроцессора, такие как</target>
        </trans-unit>
        <trans-unit id="90399aa992409c6c8444d2b7bc23fef6bd0b23f1" translate="yes" xml:space="preserve">
          <source>This option does not warn about designated initializers, so the following modification does not trigger a warning:</source>
          <target state="translated">Эта опция не предупреждает о назначенных инициализаторах,поэтому следующая модификация не вызывает предупреждения:</target>
        </trans-unit>
        <trans-unit id="637d485d36be088d5dc6290430edcc3559942fb2" translate="yes" xml:space="preserve">
          <source>This option does not work in the presence of shared libraries or nested functions.</source>
          <target state="translated">Этот вариант не работает при наличии разделяемых библиотек или вложенных функций.</target>
        </trans-unit>
        <trans-unit id="b6cfd2996b7bd042cf9971ccd157a3b5ed5d4172" translate="yes" xml:space="preserve">
          <source>This option enable the compiler to emit &lt;code&gt;enter&lt;/code&gt; and &lt;code&gt;leave&lt;/code&gt; instructions. These instructions are only valid for CPUs with code-density feature.</source>
          <target state="translated">Эта опция позволяет компилятору выдавать инструкции &lt;code&gt;enter&lt;/code&gt; и &lt;code&gt;leave&lt;/code&gt; . Эти инструкции действительны только для ЦП с функцией плотности кода.</target>
        </trans-unit>
        <trans-unit id="f36e3ffcf2c8e8b04ebd85e66df66aa0c1508360" translate="yes" xml:space="preserve">
          <source>This option enables GCC to generate &lt;code&gt;CMPXCHG16B&lt;/code&gt; instructions in 64-bit code to implement compare-and-exchange operations on 16-byte aligned 128-bit objects. This is useful for atomic updates of data structures exceeding one machine word in size. The compiler uses this instruction to implement &lt;a href=&quot;_005f_005fsync-builtins#g_t_005f_005fsync-Builtins&quot;&gt;__sync Builtins&lt;/a&gt;. However, for &lt;a href=&quot;_005f_005fatomic-builtins#g_t_005f_005fatomic-Builtins&quot;&gt;__atomic Builtins&lt;/a&gt; operating on 128-bit integers, a library call is always used.</source>
          <target state="translated">Эта опция позволяет GCC генерировать инструкции &lt;code&gt;CMPXCHG16B&lt;/code&gt; в 64-битном коде для реализации операций сравнения и обмена с выровненными по 16 байт 128-битными объектами. Это полезно для атомарных обновлений структур данных, размер которых превышает одно машинное слово. Компилятор использует эту инструкцию для реализации &lt;a href=&quot;_005f_005fsync-builtins#g_t_005f_005fsync-Builtins&quot;&gt;встроенных функций __sync&lt;/a&gt; . Однако для &lt;a href=&quot;_005f_005fatomic-builtins#g_t_005f_005fatomic-Builtins&quot;&gt;__atomic Builtins,&lt;/a&gt; работающих со 128-битными целыми числами, всегда используется вызов библиотеки.</target>
        </trans-unit>
        <trans-unit id="111a14f183c415ed55eeae4c39a6e2dbf86ced81" translate="yes" xml:space="preserve">
          <source>This option enables a predefined, named set of custom instruction encodings (see</source>
          <target state="translated">Эта опция включает предопределенный,именованный набор пользовательских кодировок команд (смотрите раздел</target>
        </trans-unit>
        <trans-unit id="ba4e36ba668d3f1644121ffdad98a65c14adabae" translate="yes" xml:space="preserve">
          <source>This option enables an static analysis of program flow which looks for &amp;ldquo;interesting&amp;rdquo; interprocedural paths through the code, and issues warnings for problems found on them.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d1bfbfd499b3c5f5bc13445a47161400b4906077" translate="yes" xml:space="preserve">
          <source>This option enables built-in functions &lt;code&gt;__builtin_ia32_crc32qi&lt;/code&gt;, &lt;code&gt;__builtin_ia32_crc32hi&lt;/code&gt;, &lt;code&gt;__builtin_ia32_crc32si&lt;/code&gt; and &lt;code&gt;__builtin_ia32_crc32di&lt;/code&gt; to generate the &lt;code&gt;crc32&lt;/code&gt; machine instruction.</source>
          <target state="translated">Эта опция включает встроенные функции &lt;code&gt;__builtin_ia32_crc32qi&lt;/code&gt; , &lt;code&gt;__builtin_ia32_crc32hi&lt;/code&gt; , &lt;code&gt;__builtin_ia32_crc32si&lt;/code&gt; и &lt;code&gt;__builtin_ia32_crc32di&lt;/code&gt; для генерации машинной инструкции &lt;code&gt;crc32&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2cd918ec8f0e039c766cf7fe1d48f22e6df60ce4" translate="yes" xml:space="preserve">
          <source>This option enables checking of alignment of pointers when they are dereferenced, or when a reference is bound to insufficiently aligned target, or when a method or constructor is invoked on insufficiently aligned object.</source>
          <target state="translated">Эта опция позволяет проверить выравнивание указателей,когда они разыменованы,или когда ссылка привязана к недостаточно выровненной цели,или когда метод или конструктор вызывается на недостаточно выровненном объекте.</target>
        </trans-unit>
        <trans-unit id="50199f80fe90cda9539f52ff8308973833026d26" translate="yes" xml:space="preserve">
          <source>This option enables checking that the result of a shift operation is not undefined. Note that what exactly is considered undefined differs slightly between C and C++, as well as between ISO C90 and C99, etc. This option has two suboptions,</source>
          <target state="translated">Эта опция позволяет проверить,не является ли результат операции сдвига неопределенным.Обратите внимание,что то,что именно считается неопределенным,немного отличается между С и С++,а также между ISO C90 и C99 и др.Эта опция имеет две подопции,</target>
        </trans-unit>
        <trans-unit id="85b4168b985dbcf1d69994ce5cb2c45b6d1daccb" translate="yes" xml:space="preserve">
          <source>This option enables checking that the second argument of a shift operation is not negative and is smaller than the precision of the promoted first argument.</source>
          <target state="translated">Эта опция позволяет проверить,что второй аргумент операции сдвига не является отрицательным и меньше точности выдвигаемого первого аргумента.</target>
        </trans-unit>
        <trans-unit id="938ba4d02fa2f3fd34289d2d8d2d36eb752b42e2" translate="yes" xml:space="preserve">
          <source>This option enables floating-point type to integer conversion checking. We check that the result of the conversion does not overflow. Unlike other similar options,</source>
          <target state="translated">Эта опция позволяет проверять тип с плавающей точкой на целочисленное преобразование.Проверяется,что результат преобразования не переполняется.В отличие от других подобных опций,</target>
        </trans-unit>
        <trans-unit id="2be71ee2359ef67de5a090bb541bf4acc1394953" translate="yes" xml:space="preserve">
          <source>This option enables functions to be overloaded for ordinary and UTF-8 strings:</source>
          <target state="translated">Эта опция позволяет перегружать функции для обычных и UTF-8 строк:</target>
        </trans-unit>
        <trans-unit id="f2c29fc89d033f54fcdc9384885989225fe300ca" translate="yes" xml:space="preserve">
          <source>This option enables generation of &lt;code&gt;SAHF&lt;/code&gt; instructions in 64-bit code. Early Intel Pentium 4 CPUs with Intel 64 support, prior to the introduction of Pentium 4 G1 step in December 2005, lacked the &lt;code&gt;LAHF&lt;/code&gt; and &lt;code&gt;SAHF&lt;/code&gt; instructions which are supported by AMD64. These are load and store instructions, respectively, for certain status flags. In 64-bit mode, the &lt;code&gt;SAHF&lt;/code&gt; instruction is used to optimize &lt;code&gt;fmod&lt;/code&gt;, &lt;code&gt;drem&lt;/code&gt;, and &lt;code&gt;remainder&lt;/code&gt; built-in functions; see &lt;a href=&quot;other-builtins#Other-Builtins&quot;&gt;Other Builtins&lt;/a&gt; for details.</source>
          <target state="translated">Эта опция позволяет генерировать инструкции &lt;code&gt;SAHF&lt;/code&gt; в 64-битном коде. Ранние процессоры Intel Pentium 4 с поддержкой Intel 64, до появления Pentium 4 G1 step в декабре 2005 г., не &lt;code&gt;LAHF&lt;/code&gt; инструкций LAHF и &lt;code&gt;SAHF&lt;/code&gt; , которые поддерживаются AMD64. Это инструкции загрузки и сохранения, соответственно, для определенных флагов состояния. В 64-битном режиме, &lt;code&gt;SAHF&lt;/code&gt; инструкция используется для оптимизации &lt;code&gt;fmod&lt;/code&gt; , &lt;code&gt;drem&lt;/code&gt; , а &lt;code&gt;remainder&lt;/code&gt; встроенные функции; подробности см. в разделе &amp;laquo; &lt;a href=&quot;other-builtins#Other-Builtins&quot;&gt;Другие встроенные функции&amp;raquo;&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="bf9eedf73e4d0015fa244bb4f5c3569d74469415" translate="yes" xml:space="preserve">
          <source>This option enables instrumentation of C++ member function calls, member accesses and some conversions between pointers to base and derived classes, to verify the referenced object has the correct dynamic type.</source>
          <target state="translated">Эта опция позволяет инструментировать вызовы функций членов С++,доступы членов и некоторые приведения указателей к базовому и производному классам,для проверки того,что ссылающийся объект имеет правильный динамический тип.</target>
        </trans-unit>
        <trans-unit id="7dd18b0f972bb3a966564c3387d23513ed8f1114" translate="yes" xml:space="preserve">
          <source>This option enables instrumentation of arguments to selected builtin functions. If an invalid value is passed to such arguments, a run-time error is issued. E.g. passing 0 as the argument to &lt;code&gt;__builtin_ctz&lt;/code&gt; or &lt;code&gt;__builtin_clz&lt;/code&gt; invokes undefined behavior and is diagnosed by this option.</source>
          <target state="translated">Эта опция включает инструментирование аргументов для выбранных встроенных функций. Если таким аргументам передается недопустимое значение, выдается ошибка времени выполнения. Например, передача 0 в качестве аргумента для &lt;code&gt;__builtin_ctz&lt;/code&gt; или &lt;code&gt;__builtin_clz&lt;/code&gt; вызывает неопределенное поведение и диагностируется этой опцией.</target>
        </trans-unit>
        <trans-unit id="4707da904f3b017d856d15dd2d0965e19870e1d8" translate="yes" xml:space="preserve">
          <source>This option enables instrumentation of array bounds. Various out of bounds accesses are detected. Flexible array members, flexible array member-like arrays, and initializers of variables with static storage are not instrumented.</source>
          <target state="translated">Эта опция позволяет приборостроить границы массивов.Обнаруживаются различные внеграничные доступы.Гибкие члены массива,гибкие массивы,похожие на члены массива,и инициализаторы переменных со статическим запоминающим устройством не инструментируются.</target>
        </trans-unit>
        <trans-unit id="2e349da95c57c4503e630d88b725ecb09ef50689" translate="yes" xml:space="preserve">
          <source>This option enables instrumentation of calls, checking whether null values are not passed to arguments marked as requiring a non-null value by the &lt;code&gt;nonnull&lt;/code&gt; function attribute.</source>
          <target state="translated">Эта опция включает инструментирование вызовов, проверяя, не передаются ли нулевые значения аргументам, помеченным как требующие &lt;code&gt;nonnull&lt;/code&gt; атрибутом функции, отличным от NULL .</target>
        </trans-unit>
        <trans-unit id="8d56bee13b4f38d072afa312adba62366dd96324" translate="yes" xml:space="preserve">
          <source>This option enables instrumentation of loads from an enum type. If a value outside the range of values for the enum type is loaded, a run-time error is issued.</source>
          <target state="translated">Эта опция позволяет измерить нагрузки из перечислительного типа.При загрузке значения,выходящего за пределы диапазона значений для типа перечисления,выдается ошибка выполнения.</target>
        </trans-unit>
        <trans-unit id="8bae34f78ab33cc208a29bdcebb31b30f37fdfdb" translate="yes" xml:space="preserve">
          <source>This option enables instrumentation of loads from bool. If a value other than 0/1 is loaded, a run-time error is issued.</source>
          <target state="translated">Эта опция позволяет измерить грузы из шерсти.При загрузке значения,отличного от 0/1,выдается ошибка выполнения.</target>
        </trans-unit>
        <trans-unit id="46c1b7dde6bdde5a1a374986dc5119119957fbe3" translate="yes" xml:space="preserve">
          <source>This option enables instrumentation of memory references using the &lt;code&gt;__builtin_object_size&lt;/code&gt; function. Various out of bounds pointer accesses are detected.</source>
          <target state="translated">Эта опция включает инструментирование ссылок на память с помощью функции &lt;code&gt;__builtin_object_size&lt;/code&gt; . Обнаружены различные обращения за пределами указателя.</target>
        </trans-unit>
        <trans-unit id="0292138149978c95eacc8642af7ff43cfe7b2264" translate="yes" xml:space="preserve">
          <source>This option enables instrumentation of pointer arithmetics. If the pointer arithmetics overflows, a run-time error is issued.</source>
          <target state="translated">Эта опция включает приборы арифметики указателей.Если арифметика указателей переполняется,то выдается ошибка во время выполнения.</target>
        </trans-unit>
        <trans-unit id="430110abdd161cbe658a0d2f529325e1208cd453" translate="yes" xml:space="preserve">
          <source>This option enables instrumentation of return statements in functions marked with &lt;code&gt;returns_nonnull&lt;/code&gt; function attribute, to detect returning of null values from such functions.</source>
          <target state="translated">Эта опция включает инструментирование операторов возврата в функциях, отмеченных &lt;code&gt;returns_nonnull&lt;/code&gt; функции returns_nonnull , для обнаружения возврата нулевых значений из таких функций.</target>
        </trans-unit>
        <trans-unit id="cb16ef94b917da96c006db5cf05527388bed65b9" translate="yes" xml:space="preserve">
          <source>This option enables or disables warnings about conflicts between the MCU name specified by the</source>
          <target state="translated">Эта опция включает или отключает предупреждения о конфликтах между именами MCU,указанными в параметре</target>
        </trans-unit>
        <trans-unit id="f864b078493b6651bb86e363b143af67066fe079" translate="yes" xml:space="preserve">
          <source>This option enables pointer checking. Particularly, the application built with this option turned on will issue an error message when it tries to dereference a NULL pointer, or if a reference (possibly an rvalue reference) is bound to a NULL pointer, or if a method is invoked on an object pointed by a NULL pointer.</source>
          <target state="translated">Эта опция позволяет проверять указатели.В частности,приложение,собранное с включенной опцией,выдаст сообщение об ошибке при попытке разыменования NULL указателя,или если ссылка (возможно,ссылка на значение rvalue)привязана к указателю NULL,или если метод вызывается на объект,на который указывает указатель NULL.</target>
        </trans-unit>
        <trans-unit id="9390f84ab3c6840aa43bf14f385886239ff26f9c" translate="yes" xml:space="preserve">
          <source>This option enables return statement checking. Programs built with this option turned on will issue an error message when the end of a non-void function is reached without actually returning a value. This option works in C++ only.</source>
          <target state="translated">Эта опция позволяет проверять отчет о возврате.Программы,построенные с включенной опцией,будут выдавать сообщение об ошибке при достижении конца неотвратимой функции без фактического возврата значения.Эта опция работает только на C++.</target>
        </trans-unit>
        <trans-unit id="c5e06b2ed5aaf18ef55b254444b859dc73b64e5e" translate="yes" xml:space="preserve">
          <source>This option enables signed integer overflow checking. We check that the result of &lt;code&gt;+&lt;/code&gt;, &lt;code&gt;*&lt;/code&gt;, and both unary and binary &lt;code&gt;-&lt;/code&gt; does not overflow in the signed arithmetics. Note, integer promotion rules must be taken into account. That is, the following is not an overflow:</source>
          <target state="translated">Эта опция включает проверку переполнения целого числа со знаком. Мы проверяем, что результат &lt;code&gt;+&lt;/code&gt; , &lt;code&gt;*&lt;/code&gt; и как унарных, так и двоичных &lt;code&gt;-&lt;/code&gt; не переполняется в знаковой арифметике. Обратите внимание, правила целочисленного продвижения должны быть приняты во внимание. То есть переполнением не является:</target>
        </trans-unit>
        <trans-unit id="5aa6ebd08f1df0b8312082dee55c79f646e3aa80" translate="yes" xml:space="preserve">
          <source>This option enables strict instrumentation of array bounds. Most out of bounds accesses are detected, including flexible array members and flexible array member-like arrays. Initializers of variables with static storage are not instrumented.</source>
          <target state="translated">Эта опция позволяет выполнять строгую контрольную обработку границ массива.Обнаруживается большая часть внеграничных обращений,в том числе к гибким членам массива и к гибким массивам,похожим на члены массива.Инициализаторы переменных со статическим запоминающим устройством не инструментируются.</target>
        </trans-unit>
        <trans-unit id="35547d9fdeedd115e10a5da6add0bd1af02febf6" translate="yes" xml:space="preserve">
          <source>This option enables the extraction of object files with GIMPLE bytecode out of library archives. This improves the quality of optimization by exposing more code to the link-time optimizer. This information specifies what symbols can be accessed externally (by non-LTO object or during dynamic linking). Resulting code quality improvements on binaries (and shared libraries that use hidden visibility) are similar to</source>
          <target state="translated">Данная опция позволяет извлекать объектные файлы с GIMPLE байткодом из библиотечных архивов.Это улучшает качество оптимизации,предоставляя больше кода для линк-оптимизатора времени.Эта информация определяет,к каким символам можно получить внешний доступ (не-LTO-объектом или при динамическом связывании).В результате улучшение качества кода на двоичных файлах (и разделяемых библиотеках,использующих скрытую видимость)похоже на</target>
        </trans-unit>
        <trans-unit id="aff42a7c223b12e8af263b78f8decfd79d138482" translate="yes" xml:space="preserve">
          <source>This option enables transitivity of constraints within the analyzer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e139de52e12e355ab2f4aceaceda024599afb6f0" translate="yes" xml:space="preserve">
          <source>This option enables use of &lt;code&gt;RCPSS&lt;/code&gt; and &lt;code&gt;RSQRTSS&lt;/code&gt; instructions (and their vectorized variants &lt;code&gt;RCPPS&lt;/code&gt; and &lt;code&gt;RSQRTPS&lt;/code&gt;) with an additional Newton-Raphson step to increase precision instead of &lt;code&gt;DIVSS&lt;/code&gt; and &lt;code&gt;SQRTSS&lt;/code&gt; (and their vectorized variants) for single-precision floating-point arguments. These instructions are generated only when</source>
          <target state="translated">Эта опция позволяет использовать инструкции &lt;code&gt;RCPSS&lt;/code&gt; и &lt;code&gt;RSQRTSS&lt;/code&gt; (и их векторизованные варианты &lt;code&gt;RCPPS&lt;/code&gt; и &lt;code&gt;RSQRTPS&lt;/code&gt; ) с дополнительным шагом Ньютона-Рафсона для повышения точности вместо &lt;code&gt;DIVSS&lt;/code&gt; и &lt;code&gt;SQRTSS&lt;/code&gt; (и их векторизованных вариантов) для аргументов с плавающей запятой одинарной точности. Эти инструкции генерируются только тогда, когда</target>
        </trans-unit>
        <trans-unit id="060df32e86c55ba7cad1df047f45c9f196518594" translate="yes" xml:space="preserve">
          <source>This option enables use of the &lt;code&gt;movbe&lt;/code&gt; instruction to implement &lt;code&gt;__builtin_bswap32&lt;/code&gt; and &lt;code&gt;__builtin_bswap64&lt;/code&gt;.</source>
          <target state="translated">Эта опция позволяет использовать инструкцию &lt;code&gt;movbe&lt;/code&gt; для реализации &lt;code&gt;__builtin_bswap32&lt;/code&gt; и &lt;code&gt;__builtin_bswap64&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3be41468437cbd33ddbb5938cf95baa409134252" translate="yes" xml:space="preserve">
          <source>This option enables use of the reciprocal estimate and reciprocal square root estimate instructions with additional Newton-Raphson steps to increase precision instead of doing a divide or square root and divide for floating-point arguments. You should use the</source>
          <target state="translated">Эта опция позволяет использовать инструкции по взаимному вычислению и взаимному квадратному корню с дополнительными шагами Ньютона-Рафсона для повышения точности вместо того,чтобы делать деление или квадратный корень и деление для аргументов с плавающей точкой.Вы должны использовать</target>
        </trans-unit>
        <trans-unit id="b8b0cc8f7ad08d6547ab80b77c947a16db351cd7" translate="yes" xml:space="preserve">
          <source>This option forces GCC to use custom shadow offset in AddressSanitizer checks. It is useful for experimenting with different shadow memory layouts in Kernel AddressSanitizer.</source>
          <target state="translated">Эта опция заставляет GCC использовать пользовательское смещение теней при проверке AddressSanitizer.Она полезна для экспериментов с различными раскладками теневой памяти в Kernel AddressSanitizer.</target>
        </trans-unit>
        <trans-unit id="3233daa383d4066b02b1657216dd534dd8974913" translate="yes" xml:space="preserve">
          <source>This option generates traps for signed overflow on addition, subtraction, multiplication operations. The options</source>
          <target state="translated">Эта опция генерирует ловушки для подписанных переполнений при операциях сложения,вычитания,умножения.Опции</target>
        </trans-unit>
        <trans-unit id="bc361006809087722b4665eda3af889c660cf7bb" translate="yes" xml:space="preserve">
          <source>This option has no effect on abicalls code. The default is</source>
          <target state="translated">Эта опция не влияет на код Абикалс.По умолчанию</target>
        </trans-unit>
        <trans-unit id="ce202009f104c41c762f668a2d6d18c3bbd55f2a" translate="yes" xml:space="preserve">
          <source>This option ignored; it is provided for compatibility purposes only. Software floating-point code is emitted by default, and this default can overridden by FPX options;</source>
          <target state="translated">Эта опция игнорируется;она предоставляется только в целях совместимости.Программный код с плавающей запятой выдается по умолчанию,и это умолчание может быть переопределено опциями FPX;</target>
        </trans-unit>
        <trans-unit id="d295e879be9d8d469fabe64723a6a09c1d8dadcc" translate="yes" xml:space="preserve">
          <source>This option implies</source>
          <target state="translated">Этот вариант подразумевает</target>
        </trans-unit>
        <trans-unit id="8ef84b2b0112928af774bc0bf4f11244d39995fa" translate="yes" xml:space="preserve">
          <source>This option inhibits the use of 68020 and 68881/68882 instructions that have to be emulated by software on the 68060. Use this option if your 68060 does not have code to emulate those instructions.</source>
          <target state="translated">Эта опция запрещает использование инструкций 68020 и 68881/68882,которые должны эмулироваться программным обеспечением на 68060.Используйте эту опцию,если Ваш 68060 не имеет кода для эмуляции этих инструкций.</target>
        </trans-unit>
        <trans-unit id="efb405ef4149f232764b47255e26eb73c1775fc9" translate="yes" xml:space="preserve">
          <source>This option inhibits the use of 68881/68882 instructions that have to be emulated by software on the 68040. Use this option if your 68040 does not have code to emulate those instructions.</source>
          <target state="translated">Эта опция запрещает использование инструкций 68881/68882,которые должны эмулироваться программным обеспечением на 68040.Используйте эту опцию,если на устройстве 68040 нет кода для эмуляции этих инструкций.</target>
        </trans-unit>
        <trans-unit id="e0c66bcd77c8bed54eff907c145c1ea37c3f6555" translate="yes" xml:space="preserve">
          <source>This option instructs CPP to add a phony target for each dependency other than the main file, causing each to depend on nothing. These dummy rules work around errors &lt;code&gt;make&lt;/code&gt; gives if you remove header files without updating the</source>
          <target state="translated">Эта опция указывает CPP добавлять фальшивую цель для каждой зависимости, кроме основного файла, в результате чего каждая из них ни от чего не зависит. Эти фиктивные правила &lt;code&gt;make&lt;/code&gt; обходить ошибки, возникающие при удалении файлов заголовков без обновления</target>
        </trans-unit>
        <trans-unit id="3c687d2d1d2116a0ccc32795fd0f0f68e88ed641" translate="yes" xml:space="preserve">
          <source>This option instructs GCC to dump the names of the x86 performance tuning features and default settings. The names can be used in</source>
          <target state="translated">Эта опция инструктирует GCC сбрасывать имена функций настройки производительности x86 и параметров по умолчанию.Имена можно использовать в</target>
        </trans-unit>
        <trans-unit id="38a021cb20751050e831beceef3d4668ce4cf298" translate="yes" xml:space="preserve">
          <source>This option instructs GCC to emit a &lt;code&gt;cld&lt;/code&gt; instruction in the prologue of functions that use string instructions. String instructions depend on the DF flag to select between autoincrement or autodecrement mode. While the ABI specifies the DF flag to be cleared on function entry, some operating systems violate this specification by not clearing the DF flag in their exception dispatchers. The exception handler can be invoked with the DF flag set, which leads to wrong direction mode when string instructions are used. This option can be enabled by default on 32-bit x86 targets by configuring GCC with the</source>
          <target state="translated">Эта опция инструктирует GCC &lt;code&gt;cld&lt;/code&gt; инструкцию cld в прологе функций, которые используют строковые инструкции. Строковые инструкции зависят от флага DF для выбора между режимом автоинкремента или автоматического уменьшения. Хотя ABI указывает, что флаг DF должен сбрасываться при входе в функцию, некоторые операционные системы нарушают эту спецификацию, не сбрасывая флаг DF в своих диспетчерах исключений. Обработчик исключений может быть вызван с установленным флагом DF, что приводит к неправильному режиму направления при использовании строковых инструкций. Этот параметр можно включить по умолчанию для 32-разрядных целей x86, настроив GCC с</target>
        </trans-unit>
        <trans-unit id="657b508727e487887f711193a95e39499f48960e" translate="yes" xml:space="preserve">
          <source>This option instructs GCC to emit a &lt;code&gt;vzeroupper&lt;/code&gt; instruction before a transfer of control flow out of the function to minimize the AVX to SSE transition penalty as well as remove unnecessary &lt;code&gt;zeroupper&lt;/code&gt; intrinsics.</source>
          <target state="translated">Эта опция предписывает GCC &lt;code&gt;vzeroupper&lt;/code&gt; команду vzeroupper перед передачей потока управления из функции, чтобы минимизировать штраф за переход от AVX к SSE, а также удалить ненужные внутренние функции &lt;code&gt;zeroupper&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3c78872fcf66a452b582423621f5fae766269c85" translate="yes" xml:space="preserve">
          <source>This option instructs GCC to turn off all tunable features. See also</source>
          <target state="translated">Эта опция предписывает GCC отключить все настраиваемые функции.См.также</target>
        </trans-unit>
        <trans-unit id="3d9dd501c30e561cb69d40cbc9373ad471302725" translate="yes" xml:space="preserve">
          <source>This option instructs GCC to use 128-bit AVX instructions instead of 256-bit AVX instructions in the auto-vectorizer.</source>
          <target state="translated">Эта опция предписывает GCC использовать 128-битные инструкции AVX вместо 256-битных инструкций AVX в авто-векторизаторе.</target>
        </trans-unit>
        <trans-unit id="e6945bdd3deb13214c6bf659bc52045e04a70f0e" translate="yes" xml:space="preserve">
          <source>This option instructs GCC to use &lt;var&gt;opt&lt;/var&gt;-bit vector width in instructions instead of default on the selected platform.</source>
          <target state="translated">Этот параметр указывает GCC использовать в инструкциях &lt;var&gt;opt&lt;/var&gt; бит ширины вектора вместо значения по умолчанию на выбранной платформе.</target>
        </trans-unit>
        <trans-unit id="dbda0a70a5f352dad89f90d04caa28e3bd6d0703" translate="yes" xml:space="preserve">
          <source>This option instructs the compiler to assume that pointer arithmetic overflow on addition and subtraction wraps around using twos-complement representation. This flag disables some optimizations which assume pointer overflow is invalid.</source>
          <target state="translated">Эта опция инструктирует компилятор предположить,что переполнение арифметики с указателями при сложении и вычитании обертывается с использованием представления twos-complement.Этот флаг отключает некоторые оптимизации,которые предполагают,что переполнение указателя является недействительным.</target>
        </trans-unit>
        <trans-unit id="f816312ce41ee12df0f414176d9a5763b90df530" translate="yes" xml:space="preserve">
          <source>This option instructs the compiler to assume that signed arithmetic overflow of addition, subtraction and multiplication wraps around using twos-complement representation. This flag enables some optimizations and disables others. The options</source>
          <target state="translated">Эта опция предписывает компилятору предполагать,что signed arithmetic overflow of adding,subtraction and multiplication wraps around using twos-complement representation.Этот флаг включает одни оптимизации и отключает другие.Опции</target>
        </trans-unit>
        <trans-unit id="c431c0c08a8246794b17639d38f5f9732adef200" translate="yes" xml:space="preserve">
          <source>This option instructs the compiler to check that the size of a variable length array is positive.</source>
          <target state="translated">Данная опция предписывает компилятору проверить размер массива переменной длины на положительный результат.</target>
        </trans-unit>
        <trans-unit id="0d3ab8d594e88fea27629172c62534cedd7e9ccd" translate="yes" xml:space="preserve">
          <source>This option instructs the compiler to generate code for a 16-entry register file. This option defines the &lt;code&gt;__ARC_RF16__&lt;/code&gt; preprocessor macro.</source>
          <target state="translated">Этот параметр указывает компилятору сгенерировать код для файла регистров с 16 записями. Эта опция определяет &lt;code&gt;__ARC_RF16__&lt;/code&gt; препроцессора __ARC_RF16__ .</target>
        </trans-unit>
        <trans-unit id="b138f51e639bc0b32ca1dc63d0195b9a7cfb2e6c" translate="yes" xml:space="preserve">
          <source>This option is a detailed version of</source>
          <target state="translated">Этот вариант является подробной версией</target>
        </trans-unit>
        <trans-unit id="0777795174f336ed7d700a302e0b548f3225ecd3" translate="yes" xml:space="preserve">
          <source>This option is also passed on to the assembler.</source>
          <target state="translated">Эта опция также передается ассемблеру.</target>
        </trans-unit>
        <trans-unit id="0a8a587d88750f4b64f0573d837060922995e692" translate="yes" xml:space="preserve">
          <source>This option is always enabled by default on certain machines, usually those which have no call-preserved registers to use instead.</source>
          <target state="translated">Эта опция всегда включена по умолчанию на определенных машинах,обычно на тех,которые не имеют резервируемых по вызову регистров для использования вместо них.</target>
        </trans-unit>
        <trans-unit id="87c9194e0e60c9d507f16257e56fa4da6140cc2a" translate="yes" xml:space="preserve">
          <source>This option is available for Cygwin and MinGW targets. It specifies that a DLL&amp;mdash;a dynamic link library&amp;mdash;is to be generated, enabling the selection of the required runtime startup object and entry point.</source>
          <target state="translated">Эта опция доступна для целей Cygwin и MinGW. Он указывает, что должна быть сгенерирована DLL - библиотека динамической компоновки, позволяющая выбрать требуемый объект запуска среды выполнения и точку входа.</target>
        </trans-unit>
        <trans-unit id="34974b8a3ddccb37978e6f7f3ab9b870fb775b53" translate="yes" xml:space="preserve">
          <source>This option is available for Cygwin and MinGW targets. It specifies that a GUI application is to be generated by instructing the linker to set the PE header subsystem type appropriately.</source>
          <target state="translated">Эта опция доступна для целей Cygwin и MinGW.Она указывает,что GUI-приложение должно быть сгенерировано путем указания компоновщику установить тип подсистемы заголовков PE соответствующим образом.</target>
        </trans-unit>
        <trans-unit id="f9c956bb65a4ef29b2924781000ede172dfe35c9" translate="yes" xml:space="preserve">
          <source>This option is available for Cygwin and MinGW targets. It specifies that the &lt;code&gt;dllimport&lt;/code&gt; attribute should be ignored.</source>
          <target state="translated">Эта опция доступна для целей Cygwin и MinGW. Он указывает, что атрибут &lt;code&gt;dllimport&lt;/code&gt; следует игнорировать.</target>
        </trans-unit>
        <trans-unit id="7e0dc3ae21d5985659301b368b4c95c1db9366f7" translate="yes" xml:space="preserve">
          <source>This option is available for Cygwin and MinGW targets. It specifies that the GNU extension to the PE file format that permits the correct alignment of COMMON variables should be used when generating code. It is enabled by default if GCC detects that the target assembler found during configuration supports the feature.</source>
          <target state="translated">Эта опция доступна для целей Cygwin и MinGW.В нем указано,что при генерации кода следует использовать расширение GNU до формата файла PE,допускающее правильное выравнивание переменных COMMON.Она включена по умолчанию,если GCC обнаруживает,что целевой ассемблер,найденный во время конфигурации,поддерживает эту возможность.</target>
        </trans-unit>
        <trans-unit id="9161324109587b09b1694f29c23c72102885dbb9" translate="yes" xml:space="preserve">
          <source>This option is available for Cygwin and MinGW targets. It specifies that the typical Microsoft Windows predefined macros are to be set in the pre-processor, but does not influence the choice of runtime library/startup code.</source>
          <target state="translated">Эта опция доступна для целей Cygwin и MinGW.Она указывает,что типичные предопределенные макросы Microsoft Windows должны быть установлены в препроцессоре,но не влияет на выбор библиотеки/кода запуска.</target>
        </trans-unit>
        <trans-unit id="9e0a3afbd291f88cb3c95726f31687bd36f164b7" translate="yes" xml:space="preserve">
          <source>This option is available for MinGW and Cygwin targets. It specifies that relocated-data in read-only section is put into the &lt;code&gt;.data&lt;/code&gt; section. This is a necessary for older runtimes not supporting modification of &lt;code&gt;.rdata&lt;/code&gt; sections for pseudo-relocation.</source>
          <target state="translated">Эта опция доступна для целей MinGW и Cygwin. Он указывает, что перемещенные данные в разделе только для чтения помещаются в раздел &lt;code&gt;.data&lt;/code&gt; . Это необходимо для старых сред выполнения, не поддерживающих модификацию разделов &lt;code&gt;.rdata&lt;/code&gt; для псевдоперемещения.</target>
        </trans-unit>
        <trans-unit id="acdd2b492fbf0ebaa317f2c48f132b3b62ecde92" translate="yes" xml:space="preserve">
          <source>This option is available for MinGW targets. It specifies that MinGW-specific thread support is to be used.</source>
          <target state="translated">Эта опция доступна для целей MinGW.Она указывает,что должна использоваться специальная поддержка резьбы MinGW.</target>
        </trans-unit>
        <trans-unit id="faee952b0f4c06ee910b880bfbdf149d4685f355" translate="yes" xml:space="preserve">
          <source>This option is available for MinGW targets. It specifies that the executable flag for the stack used by nested functions isn&amp;rsquo;t set. This is necessary for binaries running in kernel mode of Microsoft Windows, as there the User32 API, which is used to set executable privileges, isn&amp;rsquo;t available.</source>
          <target state="translated">Эта опция доступна для целей MinGW. Он указывает, что флаг исполняемого файла для стека, используемого вложенными функциями, не установлен. Это необходимо для двоичных файлов, работающих в режиме ядра Microsoft Windows, поскольку там API User32, который используется для установки привилегий для исполняемых файлов, недоступен.</target>
        </trans-unit>
        <trans-unit id="e934759656573ab06e7b01542f8d07b3197cbe74" translate="yes" xml:space="preserve">
          <source>This option is available for MinGW-w64 targets. It causes the &lt;code&gt;UNICODE&lt;/code&gt; preprocessor macro to be predefined, and chooses Unicode-capable runtime startup code.</source>
          <target state="translated">Эта опция доступна для целей MinGW-w64. Он вызывает предопределение макроса препроцессора &lt;code&gt;UNICODE&lt;/code&gt; и выбирает код запуска среды выполнения, поддерживающий Unicode.</target>
        </trans-unit>
        <trans-unit id="d398f6bbd65088d4b5a66179b5d137a011940d08" translate="yes" xml:space="preserve">
          <source>This option is deprecated and has no effect.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2059e693abf7ce7ec777bf5e7cc1b18ffae32137" translate="yes" xml:space="preserve">
          <source>This option is deprecated.</source>
          <target state="translated">Эта опция устарела.</target>
        </trans-unit>
        <trans-unit id="aabeb9acbf850798bff5dd7ad77029ce8ab9ac73" translate="yes" xml:space="preserve">
          <source>This option is deprecated. It pads structures to multiple of 4 bytes, which is incompatible with the SH ABI.</source>
          <target state="translated">Эта опция устарела.Он накладывает структуры,кратные 4 байтам,что несовместимо с SH ABI.</target>
        </trans-unit>
        <trans-unit id="9d29c4b41311afb57bb108b16e155cb489ec134b" translate="yes" xml:space="preserve">
          <source>This option is deprecated. Use</source>
          <target state="translated">Эта опция устарела.Использовать</target>
        </trans-unit>
        <trans-unit id="4053a3fd19d3968881e6f8e01595ecadbdd30069" translate="yes" xml:space="preserve">
          <source>This option is enabled at level</source>
          <target state="translated">Эта опция включена на уровне</target>
        </trans-unit>
        <trans-unit id="bf488b640ab82c12aa83d2d5d585a8acb0774751" translate="yes" xml:space="preserve">
          <source>This option is enabled by</source>
          <target state="translated">Эта опция включена с помощью</target>
        </trans-unit>
        <trans-unit id="1157d5cea597fdcb95a42f4efe9767ae5da67d67" translate="yes" xml:space="preserve">
          <source>This option is enabled by default at</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a1ed53d314baadd464fa2b14f3800bf95fa8ca0" translate="yes" xml:space="preserve">
          <source>This option is enabled by default at optimization levels</source>
          <target state="translated">Эта опция включена по умолчанию на уровнях оптимизации</target>
        </trans-unit>
        <trans-unit id="d247bcb1695bed692a8726f3533be3d2fb1fee0b" translate="yes" xml:space="preserve">
          <source>This option is enabled by default for Microsoft Windows targets. This behavior can also be controlled locally by use of variable or type attributes. For more information, see &lt;a href=&quot;variable-attributes#x86-Variable-Attributes&quot;&gt;x86 Variable Attributes&lt;/a&gt; and &lt;a href=&quot;type-attributes#x86-Type-Attributes&quot;&gt;x86 Type Attributes&lt;/a&gt;.</source>
          <target state="translated">Этот параметр включен по умолчанию для целей Microsoft Windows. Этим поведением также можно управлять локально с помощью переменных или атрибутов типа. Дополнительные сведения см. В &lt;a href=&quot;variable-attributes#x86-Variable-Attributes&quot;&gt;разделах Атрибуты переменных &lt;/a&gt;&lt;a href=&quot;type-attributes#x86-Type-Attributes&quot;&gt;x86&lt;/a&gt; и Атрибуты типа x86 .</target>
        </trans-unit>
        <trans-unit id="2652d68534c6f88541191086fa1485e27def7fc6" translate="yes" xml:space="preserve">
          <source>This option is enabled by default on most targets. On Nios II ELF, it defaults to off. On AVR, CR16, and MSP430, this option is completely disabled.</source>
          <target state="translated">Эта опция включена по умолчанию для большинства целей.На Nios II ELF по умолчанию выключен.На устройствах AVR,CR16 и MSP430 эта опция полностью отключена.</target>
        </trans-unit>
        <trans-unit id="3d8c17f97f0a71b6e6913867ec6d9569fa353e80" translate="yes" xml:space="preserve">
          <source>This option is enabled by default when LTO support in GCC is enabled and GCC was configured for use with a linker supporting plugins (GNU ld 2.21 or newer or gold).</source>
          <target state="translated">Эта опция включена по умолчанию,когда включена поддержка LTO в GCC и GCC был сконфигурирован для использования с подключаемыми модулями,поддерживающими компоновщик (GNU ld 2.21 или более новыми или золотыми).</target>
        </trans-unit>
        <trans-unit id="7d53846e4ad58929426e4a8a561e1ca04e4dae26" translate="yes" xml:space="preserve">
          <source>This option is enabled by default when the RH850 ABI is in use (see</source>
          <target state="translated">Эта опция включена по умолчанию,когда используется RH850 ABI (смотрите раздел</target>
        </trans-unit>
        <trans-unit id="e8f3025aa92d2d4f667e2309b49f93dcbd8a2cc1" translate="yes" xml:space="preserve">
          <source>This option is experimental and does not currently guarantee to disable all GCC optimizations that affect signaling NaN behavior.</source>
          <target state="translated">Эта опция является экспериментальной и в настоящее время не гарантирует отключение всех GCC-оптимизаций,которые влияют на поведение NaN-сигнала.</target>
        </trans-unit>
        <trans-unit id="6bf7bb3d6ca95f65181405f388dc4f38acb33184" translate="yes" xml:space="preserve">
          <source>This option is experimental and does not currently guarantee to disable all GCC optimizations that are affected by rounding mode. Future versions of GCC may provide finer control of this setting using C99&amp;rsquo;s &lt;code&gt;FENV_ACCESS&lt;/code&gt; pragma. This command-line option will be used to specify the default state for &lt;code&gt;FENV_ACCESS&lt;/code&gt;.</source>
          <target state="translated">Этот вариант является экспериментальным и в настоящее время не гарантирует отключения всех оптимизаций GCC, на которые влияет режим округления. В будущих версиях GCC может быть обеспечено более &lt;code&gt;FENV_ACCESS&lt;/code&gt; управление этим параметром с помощью прагмы C99 FENV_ACCESS . Этот параметр командной строки будет использоваться для указания состояния по умолчанию для &lt;code&gt;FENV_ACCESS&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="41c5b1ff9a4b2c16f0283cc8b3e6a1c1ee4e99a0" translate="yes" xml:space="preserve">
          <source>This option is experimental and the format of the data within the compressed JSON file is subject to change.</source>
          <target state="translated">Эта опция является экспериментальной,и формат данных в сжатом JSON-файле может быть изменен.</target>
        </trans-unit>
        <trans-unit id="77c067b7272c8dfb1940d673f7549a9c970673d8" translate="yes" xml:space="preserve">
          <source>This option is ignored and provided for compatibility purposes only.</source>
          <target state="translated">Эта опция игнорируется и предоставляется только в целях совместимости.</target>
        </trans-unit>
        <trans-unit id="988bc726815f60352325aa80e3adb73dc59e56eb" translate="yes" xml:space="preserve">
          <source>This option is ignored; it is for compatibility purposes only. This used to select linker and preprocessor options for use with newlib.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="39bc415cf1072ef041b852cccab7caeb03cebbe9" translate="yes" xml:space="preserve">
          <source>This option is implicitly passed to the compiler for the second compilation requested by</source>
          <target state="translated">Данная опция неявно передается компилятору для второй компиляции по запросу</target>
        </trans-unit>
        <trans-unit id="223090f1188ac1bc38c64fe292f4f4b2503fac75" translate="yes" xml:space="preserve">
          <source>This option is implied by</source>
          <target state="translated">Этот вариант подразумевает</target>
        </trans-unit>
        <trans-unit id="d3193c2234bb7da293261732a9d8d77268c8fc1c" translate="yes" xml:space="preserve">
          <source>This option is intended for analyzer developers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a6f2c53d2e68d97cb3dfd3ec9c7aa21718a8745f" translate="yes" xml:space="preserve">
          <source>This option is intended for analyzer developers. It enables more verbose, lower-level detail in the descriptions of control flow within diagnostic paths.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d656b9a9c9fb5f6bcdc2b59dc196d049700bd1b2" translate="yes" xml:space="preserve">
          <source>This option is intended for analyzer developers. It enables more verbose, lower-level detail in the descriptions of events relating to state machines within diagnostic paths.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f67300ba0c3c74acfb2d8150e18a2987b0d6f05" translate="yes" xml:space="preserve">
          <source>This option is intended for analyzer developers: if multiple diagnostics have been detected as being duplicates of each other, it emits a note when reporting the best diagnostic, giving the number of additional diagnostics that were suppressed by the deduplication logic.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9711864ac531d244797123498f9a9fe143b47ace" translate="yes" xml:space="preserve">
          <source>This option is left for compatibility reasons.</source>
          <target state="translated">Эта опция оставлена по соображениям совместимости.</target>
        </trans-unit>
        <trans-unit id="705dd214fcbbda555d2c25430996631d43106884" translate="yes" xml:space="preserve">
          <source>This option is like the</source>
          <target state="translated">Этот вариант похож на</target>
        </trans-unit>
        <trans-unit id="7ea37451ed423d9b4f565d2cd48781668a2b5f65" translate="yes" xml:space="preserve">
          <source>This option is not turned on by any</source>
          <target state="translated">Эта опция не включена ни одним</target>
        </trans-unit>
        <trans-unit id="9abb00a56e1a1d91dc73fdc3ecd2a22dd97e1ddc" translate="yes" xml:space="preserve">
          <source>This option is off by default, because the resulting preprocessed output is only really suitable as input to GCC. It is switched on by</source>
          <target state="translated">Эта опция выключена по умолчанию,потому что результирующий предварительно обработанный вывод действительно подходит только в качестве входа в GCC.Он включается по</target>
        </trans-unit>
        <trans-unit id="4f3ef2c8071d14f453caa189ada503a69384e247" translate="yes" xml:space="preserve">
          <source>This option is only active when</source>
          <target state="translated">Эта опция активна только в том случае,если</target>
        </trans-unit>
        <trans-unit id="a6188b363cf7403f6936d8ff4d2c56a28d236e61" translate="yes" xml:space="preserve">
          <source>This option is only active when signed overflow is undefined. It warns about cases where the compiler optimizes based on the assumption that signed overflow does not occur. Note that it does not warn about all cases where the code might overflow: it only warns about cases where the compiler implements some optimization. Thus this warning depends on the optimization level.</source>
          <target state="translated">Данная опция активна только в том случае,если подписанное переполнение не определено.Она предупреждает о случаях,когда компилятор оптимизирует,исходя из предположения,что знакового переполнения не происходит.Отметим,что она предупреждает не обо всех случаях,когда код может переполниться.Она только предупреждает о случаях,когда компилятор реализует некоторую оптимизацию.Таким образом,данное предупреждение зависит от уровня оптимизации.</target>
        </trans-unit>
        <trans-unit id="84e9b00e2175bed56ae8768cc7c1a2405f67103d" translate="yes" xml:space="preserve">
          <source>This option is only applicable when compiling for the base ARMv8.0 instruction set. If using a later revision, e.g.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d25fc758589cd4be71db515ac5f7ca7241f83be" translate="yes" xml:space="preserve">
          <source>This option is only available for ARCv2 cores.</source>
          <target state="translated">Эта опция доступна только для ядер ARCv2.</target>
        </trans-unit>
        <trans-unit id="bb2b96b2a317107a5bbb2f1d27d819613a30b1f8" translate="yes" xml:space="preserve">
          <source>This option is only available if GCC was configured with analyzer support enabled.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="47efc2541291ec81a8db6b59aeed231c895bc9c4" translate="yes" xml:space="preserve">
          <source>This option is only available when compiling C++ code. It turns on (or off, if using</source>
          <target state="translated">Эта опция доступна только при компиляции Си++кода.Она включает (или выключает,если используется</target>
        </trans-unit>
        <trans-unit id="f33ea172ac2795eac5ebb478ce17a5afc41091f3" translate="yes" xml:space="preserve">
          <source>This option is only intended to be useful when developing GCC.</source>
          <target state="translated">Эта опция предназначена только для использования при разработке GCC.</target>
        </trans-unit>
        <trans-unit id="034517546050c1e22d79385d031d17520c531cb2" translate="yes" xml:space="preserve">
          <source>This option is only useful for debugging GCC. When used from CPP or with</source>
          <target state="translated">Эта опция полезна только для отладки GCC.При использовании с CPP или с</target>
        </trans-unit>
        <trans-unit id="05b6c3c24d858a91f50ac46c4cd92ae8eecb3f01" translate="yes" xml:space="preserve">
          <source>This option is passed to the assembler and linker, and allows the linker to perform certain optimizations that cannot be done until the final link.</source>
          <target state="translated">Эта опция передается ассемблеру и компоновщику и позволяет компоновщику выполнять определенные оптимизации,которые не могут быть выполнены до получения конечной ссылки.</target>
        </trans-unit>
        <trans-unit id="b562e6b75c17a9e319c7220a396dd42baef9b10e" translate="yes" xml:space="preserve">
          <source>This option is supported from MIPS Release 6 onwards.</source>
          <target state="translated">Эта опция поддерживается начиная с версии 6 MIPS.</target>
        </trans-unit>
        <trans-unit id="69521eee9b087ee047a6dc4f213a5e965016b754" translate="yes" xml:space="preserve">
          <source>This option is the default for optimized compilation if the assembler and linker support it. Use</source>
          <target state="translated">Эта опция по умолчанию используется для оптимизированной компиляции,если ассемблер и компоновщик поддерживают ее.Использовать .</target>
        </trans-unit>
        <trans-unit id="a6be6b9afb7bd451d149acef44e3204c0799fa3d" translate="yes" xml:space="preserve">
          <source>This option is used internally by the compiler to select and build multilibs for architectures &lt;code&gt;avr2&lt;/code&gt; and &lt;code&gt;avr25&lt;/code&gt;. These architectures mix devices with and without &lt;code&gt;SPH&lt;/code&gt;. For any setting other than</source>
          <target state="translated">Эта опция используется внутри компилятора для выбора и построения мультибиблиотечного файла для архитектур &lt;code&gt;avr2&lt;/code&gt; и &lt;code&gt;avr25&lt;/code&gt; . Эти архитектуры смешивают устройства с &lt;code&gt;SPH&lt;/code&gt; и без него . Для любых настроек, кроме</target>
        </trans-unit>
        <trans-unit id="929f4574a14bae8a52d6ca406bb8cbc25e260697" translate="yes" xml:space="preserve">
          <source>This option is used internally for multilib selection. It is not an optimization option, and you don&amp;rsquo;t need to set it by hand.</source>
          <target state="translated">Эта опция используется внутри для выбора мультибиблиотеки. Это не вариант оптимизации, и вам не нужно настраивать его вручную.</target>
        </trans-unit>
        <trans-unit id="7cc2eb8f428f100756f402b24615715e373e0e44" translate="yes" xml:space="preserve">
          <source>This option is used to compile and link code instrumented for coverage analysis. The option is a synonym for</source>
          <target state="translated">Эта опция используется для компиляции и компоновки кода,инструментализированного для анализа покрытия.Опция является синонимом</target>
        </trans-unit>
        <trans-unit id="48d0c19a39e93a3e805a541c3dbbe3e7dee413d8" translate="yes" xml:space="preserve">
          <source>This option is used to do fine grain control of x86 code generation features. &lt;var&gt;feature-list&lt;/var&gt; is a comma separated list of &lt;var&gt;feature&lt;/var&gt; names. See also</source>
          <target state="translated">Этот параметр используется для точного управления функциями генерации кода x86. &lt;var&gt;feature-list&lt;/var&gt; - это список имен &lt;var&gt;feature&lt;/var&gt; разделенных запятыми . Смотрите также</target>
        </trans-unit>
        <trans-unit id="d9b5652a39108319ff242af91d4906cb16765dd8" translate="yes" xml:space="preserve">
          <source>This option isn&amp;rsquo;t effective unless you either provide profile feedback (see</source>
          <target state="translated">Этот вариант не эффективен, если вы не предоставите отзыв профиля (см.</target>
        </trans-unit>
        <trans-unit id="fad34c4a13c209b4406d2d95140526d0990b695b" translate="yes" xml:space="preserve">
          <source>This option makes symbolic debugging impossible.</source>
          <target state="translated">Эта опция делает отладку символов невозможной.</target>
        </trans-unit>
        <trans-unit id="f70581e1a11d2a9335f77e119a8e847340333cc1" translate="yes" xml:space="preserve">
          <source>This option marks the generated code as IEEE conformant. You must not use this option unless you also specify</source>
          <target state="translated">Эта опция отмечает сгенерированный код как IEEE-конформент.Вы не должны использовать эту опцию,если не укажете также</target>
        </trans-unit>
        <trans-unit id="15ded195f72714a7729c2ba3f65b232ddd1df723" translate="yes" xml:space="preserve">
          <source>This option may generate better or worse code; results are highly dependent on the structure of loops within the source code.</source>
          <target state="translated">Этот вариант может генерировать лучший или худший код,результат сильно зависит от структуры циклов в исходном коде.</target>
        </trans-unit>
        <trans-unit id="aaf0c177eee46432379774f3339106e6fdf38879" translate="yes" xml:space="preserve">
          <source>This option only has an effect when optimizing for the VR4130. It normally makes code faster, but at the expense of making it bigger. It is enabled by default at optimization level</source>
          <target state="translated">Эта опция действует только при оптимизации для VR4130.Обычно она делает код быстрее,но за счет увеличения.По умолчанию она включена на уровне оптимизации</target>
        </trans-unit>
        <trans-unit id="ab6cda42cf644e48c433b85f306f3dac6f8ee9b8" translate="yes" xml:space="preserve">
          <source>This option passes on a request to assembler to enable the fixes for the named silicon errata.</source>
          <target state="translated">Эта опция передает ассемблеру запрос на включение исправления для именованных кремниевых ошибок.</target>
        </trans-unit>
        <trans-unit id="845f7cfd869d00c4405522a461f9c235cb5eee1d" translate="yes" xml:space="preserve">
          <source>This option passes on a request to the assembler to enable warning messages when a silicon errata might need to be applied.</source>
          <target state="translated">Эта опция передает запрос ассемблеру для включения предупреждающих сообщений,когда может потребоваться применение кремниевых ошибок.</target>
        </trans-unit>
        <trans-unit id="c17f45a4bb601880d3a1ed4ec74cc989340e16f4" translate="yes" xml:space="preserve">
          <source>This option prevents undesirable excess precision on machines such as the 68000 where the floating registers (of the 68881) keep more precision than a &lt;code&gt;double&lt;/code&gt; is supposed to have. Similarly for the x86 architecture. For most programs, the excess precision does only good, but a few programs rely on the precise definition of IEEE floating point. Use</source>
          <target state="translated">Эта опция предотвращает нежелательную избыточную точность на машинах, таких как 68000, где регистры с плавающей запятой (68881) сохраняют большую точность, чем предполагается в &lt;code&gt;double&lt;/code&gt; . Аналогично для архитектуры x86. Для большинства программ избыточная точность приносит только пользу, но некоторые программы полагаются на точное определение числа с плавающей запятой IEEE. использование</target>
        </trans-unit>
        <trans-unit id="85c0b69978ecc16b1bd0d2e9088bf661716f775e" translate="yes" xml:space="preserve">
          <source>This option provides a seed that GCC uses in place of random numbers in generating certain symbol names that have to be different in every compiled file. It is also used to place unique stamps in coverage data files and the object files that produce them. You can use the</source>
          <target state="translated">Эта опция обеспечивает семя,которое GCC использует вместо случайных чисел при генерации определенных имен символов,которые должны быть разными в каждом скомпилированном файле.Она также используется для размещения уникальных меток в файлах данных покрытия и в объектных файлах,которые их создают.Вы можете использовать</target>
        </trans-unit>
        <trans-unit id="5d13842ae6ab4ca478a1a5e72b6a9207042790a6" translate="yes" xml:space="preserve">
          <source>This option provides additional information when printing control-flow paths associated with a diagnostic.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4fc311cf74252b7ed7aa80360e3b9606e9388cce" translate="yes" xml:space="preserve">
          <source>This option requires Newlib Nano IO, so GCC must be configured with &amp;lsquo;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c9dc1b607f48375a6d4f6012661eaa5b1b5ed1be" translate="yes" xml:space="preserve">
          <source>This option results in less efficient code, but some strange hacks that alter the assembler output may be confused by the optimizations performed when this option is not used.</source>
          <target state="translated">Эта опция приводит к менее эффективному коду,но некоторые странные взломы,которые изменяют вывод ассемблера,могут быть сбиты с толку оптимизациями,выполняемыми,когда эта опция не используется.</target>
        </trans-unit>
        <trans-unit id="c631110b4d2abceaccb1bae4ccf22e852178fc73" translate="yes" xml:space="preserve">
          <source>This option runs the standard link-time optimizer. When invoked with source code, it generates GIMPLE (one of GCC&amp;rsquo;s internal representations) and writes it to special ELF sections in the object file. When the object files are linked together, all the function bodies are read from these ELF sections and instantiated as if they had been part of the same translation unit.</source>
          <target state="translated">Эта опция запускает стандартный оптимизатор времени компоновки. При вызове с исходным кодом он генерирует GIMPLE (одно из внутренних представлений GCC) и записывает его в специальные разделы ELF в объектном файле. Когда объектные файлы связаны вместе, все тела функций считываются из этих разделов ELF и создаются, как если бы они были частью одной единицы перевода.</target>
        </trans-unit>
        <trans-unit id="42349550220727ae2e299d4a2015499909d245e5" translate="yes" xml:space="preserve">
          <source>This option should be used if accesses to volatile bit-fields (or other structure fields, although the compiler usually honors those types anyway) should use a single access of the width of the field&amp;rsquo;s type, aligned to a natural alignment if possible. For example, targets with memory-mapped peripheral registers might require all such accesses to be 16 bits wide; with this flag you can declare all peripheral bit-fields as &lt;code&gt;unsigned short&lt;/code&gt; (assuming short is 16 bits on these targets) to force GCC to use 16-bit accesses instead of, perhaps, a more efficient 32-bit access.</source>
          <target state="translated">Эту опцию следует использовать, если доступ к изменчивым битовым полям (или другим полям структуры, хотя компилятор обычно учитывает эти типы в любом случае) должен использовать один доступ ширины типа поля, выровненный по естественному выравниванию, если это возможно. Например, для целей с отображенными в память периферийными регистрами может потребоваться, чтобы все такие обращения были шириной 16 бит; с помощью этого флага вы можете объявить все периферийные битовые поля как &lt;code&gt;unsigned short&lt;/code&gt; (при условии, что short составляет 16 бит для этих целей), чтобы заставить GCC использовать 16-битный доступ вместо, возможно, более эффективного 32-битного доступа.</target>
        </trans-unit>
        <trans-unit id="7a6ef28258c0d1484a7407799fe40321a370f499" translate="yes" xml:space="preserve">
          <source>This option should never be turned on by any</source>
          <target state="translated">Эта опция никогда не должна быть включена</target>
        </trans-unit>
        <trans-unit id="701b657607612b9b9057df52c63d10c751e2ef8a" translate="yes" xml:space="preserve">
          <source>This option should not be used in combination with</source>
          <target state="translated">Эта опция не должна использоваться в сочетании с</target>
        </trans-unit>
        <trans-unit id="c0219c53e7274021b5f6207f588b3446cadfa388" translate="yes" xml:space="preserve">
          <source>This option significantly reduces the size of debugging information, with some potential loss in type information to the debugger. See</source>
          <target state="translated">Эта опция значительно уменьшает размер отладочной информации,с некоторой потенциальной потерей типовой информации для отладчика.См..</target>
        </trans-unit>
        <trans-unit id="3ed6d18a71b1db6dc14656f8dda97ef522ec526e" translate="yes" xml:space="preserve">
          <source>This option specifies additional section names that can be accessed via GP-relative addressing. It is most useful in conjunction with &lt;code&gt;section&lt;/code&gt; attributes on variable declarations (see &lt;a href=&quot;common-variable-attributes#Common-Variable-Attributes&quot;&gt;Common Variable Attributes&lt;/a&gt;) and a custom linker script. The &lt;var&gt;regexp&lt;/var&gt; is a POSIX Extended Regular Expression.</source>
          <target state="translated">Эта опция определяет дополнительные имена разделов, к которым можно получить доступ через относительную адресацию GP. Это наиболее полезно в сочетании с атрибутами &lt;code&gt;section&lt;/code&gt; в объявлениях переменных (см. &lt;a href=&quot;common-variable-attributes#Common-Variable-Attributes&quot;&gt;Общие атрибуты переменных&lt;/a&gt; ) и настраиваемым сценарием компоновщика. &lt;var&gt;regexp&lt;/var&gt; является POSIX Extended Regular Expression.</target>
        </trans-unit>
        <trans-unit id="66f5529b3cbbe7b599cd5d6be9976188f77dac0f" translate="yes" xml:space="preserve">
          <source>This option specifies names of sections that can be accessed via a 16-bit offset from &lt;code&gt;r0&lt;/code&gt;; that is, in the low 32K or high 32K of the 32-bit address space. It is most useful in conjunction with &lt;code&gt;section&lt;/code&gt; attributes on variable declarations (see &lt;a href=&quot;common-variable-attributes#Common-Variable-Attributes&quot;&gt;Common Variable Attributes&lt;/a&gt;) and a custom linker script. The &lt;var&gt;regexp&lt;/var&gt; is a POSIX Extended Regular Expression.</source>
          <target state="translated">Эта опция определяет имена разделов, к которым можно получить доступ через 16-битное смещение от &lt;code&gt;r0&lt;/code&gt; ; то есть в младших 32 КБ или высоких 32 КБ 32-битного адресного пространства. Это наиболее полезно в сочетании с атрибутами &lt;code&gt;section&lt;/code&gt; в объявлениях переменных (см. &lt;a href=&quot;common-variable-attributes#Common-Variable-Attributes&quot;&gt;Общие атрибуты переменных&lt;/a&gt; ) и настраиваемым сценарием компоновщика. &lt;var&gt;regexp&lt;/var&gt; является POSIX Extended Regular Expression.</target>
        </trans-unit>
        <trans-unit id="4f2c2ce6a978cb353a59c6932941834cbab3c970" translate="yes" xml:space="preserve">
          <source>This option specifies that a console application is to be generated, by instructing the linker to set the PE header subsystem type required for console applications. This option is available for Cygwin and MinGW targets and is enabled by default on those targets.</source>
          <target state="translated">Эта опция указывает,что должно быть сгенерировано консольное приложение,поручая компоновщику установить тип подсистемы заголовков PE,требуемый для консольных приложений.Эта опция доступна для целей Cygwin и MinGW и включена по умолчанию для этих целей.</target>
        </trans-unit>
        <trans-unit id="21795b6b968aeddf2d8b82bab0643ab8d796f517" translate="yes" xml:space="preserve">
          <source>This option specifies the &lt;var&gt;executable&lt;/var&gt; that will load the build output file being linked. See man ld(1) for more information.</source>
          <target state="translated">Этот параметр указывает &lt;var&gt;executable&lt;/var&gt; который будет загружать связанный выходной файл сборки. См. Man ld (1) для получения дополнительной информации.</target>
        </trans-unit>
        <trans-unit id="699a780e6b546e7cd31621b332df13065645e8b9" translate="yes" xml:space="preserve">
          <source>This option specifies the level of compression used for intermediate language written to LTO object files, and is only meaningful in conjunction with LTO mode (</source>
          <target state="translated">Эта опция определяет уровень сжатия,используемый для промежуточных языков,записываемых в объектные файлы LTO,и имеет смысл только в сочетании с режимом LTO (</target>
        </trans-unit>
        <trans-unit id="a52135fd3bb8dd77ca2f36e74d648a4fe294ca69" translate="yes" xml:space="preserve">
          <source>This option specifies the name of the target ARM processor for which GCC should tune the performance of the code. For some ARM implementations better performance can be obtained by using this option. Permissible names are: &amp;lsquo;</source>
          <target state="translated">Эта опция указывает имя целевого процессора ARM, для которого GCC должен настроить производительность кода. Для некоторых реализаций ARM лучшая производительность может быть получена с помощью этой опции. Допустимые имена: '</target>
        </trans-unit>
        <trans-unit id="0092bbb4f5a1fce13bf85587ba520d02478db7fa" translate="yes" xml:space="preserve">
          <source>This option specifies where to find the executables, libraries, include files, and data files of the compiler itself.</source>
          <target state="translated">Данная опция определяет,где найти исполняемые файлы,библиотеки,включаемые файлы и файлы данных самого компилятора.</target>
        </trans-unit>
        <trans-unit id="34fcd55b8224119aadeadea926ce6d80328cc8e5" translate="yes" xml:space="preserve">
          <source>This option substantially reduces the size of debugging information, but at significant potential loss in type information to the debugger. See</source>
          <target state="translated">Эта опция существенно уменьшает размер отладочной информации,но при этом существенно снижает потенциальную потерю отладчиком типовой информации.См..</target>
        </trans-unit>
        <trans-unit id="12955e4ea22dbc03ccc95585111e9bd2b3cf0146" translate="yes" xml:space="preserve">
          <source>This option suppresses generation of the &lt;code&gt;CALLT&lt;/code&gt; instruction for the v850e, v850e1, v850e2, v850e2v3 and v850e3v5 flavors of the v850 architecture.</source>
          <target state="translated">Эта опция подавляет создание инструкции &lt;code&gt;CALLT&lt;/code&gt; для вариантов v850e, v850e1, v850e2, v850e2v3 и v850e3v5 архитектуры v850.</target>
        </trans-unit>
        <trans-unit id="f8fc982c11de8dc3374f1f50078380019a3e1f62" translate="yes" xml:space="preserve">
          <source>This option suppresses the printing of these labels (in the example above, the vertical bars and the &amp;ldquo;char *&amp;rdquo; and &amp;ldquo;long int&amp;rdquo; text).</source>
          <target state="translated">Этот параметр подавляет печать этих этикеток (в приведенном выше примере вертикальные полосы и текст &amp;laquo;char *&amp;raquo; и &amp;laquo;long int&amp;raquo;).</target>
        </trans-unit>
        <trans-unit id="06538fd1399a51a29e2046a8c18ed4e9d2f3a0ec" translate="yes" xml:space="preserve">
          <source>This option tells the compiler that variables declared in common blocks (e.g. Fortran) may later be overridden with longer trailing arrays. This prevents certain optimizations that depend on knowing the array bounds.</source>
          <target state="translated">Эта опция сообщает компилятору,что переменные,объявленные в общих блоках (например,Fortran),могут быть позже переопределены более длинными трейлинговыми массивами.Это предотвращает определенные оптимизации,зависящие от знания границ массивов.</target>
        </trans-unit>
        <trans-unit id="2d836f8c7fd152c1f4c1e229195acd7d1d9aa958" translate="yes" xml:space="preserve">
          <source>This option tells the loop optimizer to use language constraints to derive bounds for the number of iterations of a loop. This assumes that loop code does not invoke undefined behavior by for example causing signed integer overflows or out-of-bound array accesses. The bounds for the number of iterations of a loop are used to guide loop unrolling and peeling and loop exit test optimizations. This option is enabled by default.</source>
          <target state="translated">Эта опция говорит оптимизатору цикла использовать языковые ограничения для получения ограничений на количество итераций цикла.Это предполагает,что код цикла не вызывает неопределенного поведения,например,вызывая переполнение знаковых целых чисел или доступ к массивам вне пределов.Ограничения на количество итераций цикла используются для управления разворачиванием и пилингом цикла,а также для оптимизации выхода из цикла.Эта опция включена по умолчанию.</target>
        </trans-unit>
        <trans-unit id="4eb8a2fe595c9e8241e6ef6590e0c3c77e876a48" translate="yes" xml:space="preserve">
          <source>This option turns off this behavior because some programs explicitly rely on variables going to the data section&amp;mdash;e.g., so that the resulting executable can find the beginning of that section and/or make assumptions based on that.</source>
          <target state="translated">Эта опция отключает такое поведение, потому что некоторые программы явно полагаются на переменные, идущие в раздел данных, например, чтобы получившийся исполняемый файл мог найти начало этого раздела и / или сделать предположения на его основе.</target>
        </trans-unit>
        <trans-unit id="a03fa036158e8a2d0e9cc5e169d9035da63e693f" translate="yes" xml:space="preserve">
          <source>This option warns on all uses of &lt;code&gt;alloca&lt;/code&gt; in the source.</source>
          <target state="translated">Эта опция предупреждает обо всех случаях использования &lt;code&gt;alloca&lt;/code&gt; в источнике.</target>
        </trans-unit>
        <trans-unit id="620c263a82fa884ae16095490ed1aafd4abf9e58" translate="yes" xml:space="preserve">
          <source>This option warns on calls to &lt;code&gt;alloca&lt;/code&gt; with an integer argument whose value is either zero, or that is not bounded by a controlling predicate that limits its value to at most &lt;var&gt;byte-size&lt;/var&gt;. It also warns for calls to &lt;code&gt;alloca&lt;/code&gt; where the bound value is unknown. Arguments of non-integer types are considered unbounded even if they appear to be constrained to the expected range.</source>
          <target state="translated">Этот параметр предупреждает о вызовах &lt;code&gt;alloca&lt;/code&gt; с целочисленным аргументом, значение которого либо равно нулю, либо не ограничено управляющим предикатом, ограничивающим его значение &lt;var&gt;byte-size&lt;/var&gt; не более байта . Он также предупреждает о вызовах &lt;code&gt;alloca&lt;/code&gt; , где связанное значение неизвестно. Аргументы нецелочисленных типов считаются неограниченными, даже если они кажутся ограниченными ожидаемым диапазоном.</target>
        </trans-unit>
        <trans-unit id="61e70b725867d5de470ac626de798dde99007b65" translate="yes" xml:space="preserve">
          <source>This option will be enabled by default if, at GCC configure time, the assembler was found to support such directives.</source>
          <target state="translated">Эта опция будет включена по умолчанию,если во время настройки GCC было обнаружено,что ассемблер поддерживает такие директивы.</target>
        </trans-unit>
        <trans-unit id="a7e38bb2c3d97b5a7df94e2d4b17a0b93c48b4a5" translate="yes" xml:space="preserve">
          <source>This option will be enabled by default if, at GCC configure time, the assembler was found to support them.</source>
          <target state="translated">Эта опция будет включена по умолчанию,если во время настройки GCC было обнаружено,что ассемблер поддерживает их.</target>
        </trans-unit>
        <trans-unit id="1c545350367038810cd2987773d5c2915271f3c6" translate="yes" xml:space="preserve">
          <source>This option works only with DWARF debug output.</source>
          <target state="translated">Эта опция работает только с отладочным выводом DWARF.</target>
        </trans-unit>
        <trans-unit id="bbaec7f2023839aa97132788cd132448147454c0" translate="yes" xml:space="preserve">
          <source>This option, recognized for the cris-axis-elf, arranges to link with input-output functions from a simulator library. Code, initialized data and zero-initialized data are allocated consecutively.</source>
          <target state="translated">Эта опция,распознанная для cris-axis-elf,организует связь с функциями ввода-вывода из библиотеки симулятора.Код,инициализированные данные и нулевые инициализированные данные распределяются последовательно.</target>
        </trans-unit>
        <trans-unit id="f3e5914b613a32a5cb2f8fca3e63e01d9cf519e2" translate="yes" xml:space="preserve">
          <source>This parameter prevents mixed usage of multiple atomic models, even if they are compatible, and makes the compiler generate atomic sequences of the specified model only.</source>
          <target state="translated">Данный параметр предотвращает смешанное использование нескольких атомных моделей,даже если они совместимы,и заставляет компилятор генерировать только атомные последовательности указанной модели.</target>
        </trans-unit>
        <trans-unit id="a5d669f5cfd64a65baaa023d25d50f1d31d908f7" translate="yes" xml:space="preserve">
          <source>This parameter specifies the offset in bytes of the variable in the thread control block structure that should be used by the generated atomic sequences when the &amp;lsquo;</source>
          <target state="translated">Этот параметр определяет смещение в байтах переменной в структуре блока управления потоком, которое должно использоваться сгенерированными атомарными последовательностями, когда '</target>
        </trans-unit>
        <trans-unit id="a089b6884ff458754998285328ae2911c61445c4" translate="yes" xml:space="preserve">
          <source>This pass distributes the initialization loops and generates a call to memset zero. For example, the loop</source>
          <target state="translated">Этот проход распределяет циклы инициализации и генерирует вызов к нулевому значению memset.Например,цикл</target>
        </trans-unit>
        <trans-unit id="f9c1c873e049f9ba7fb7727e6d4eeb92324da6de" translate="yes" xml:space="preserve">
          <source>This pass only applies to certain targets that cannot explicitly represent the comparison operation before register allocation is complete.</source>
          <target state="translated">Этот проход применяется только к определенным целям,которые не могут явным образом представить операцию сравнения до завершения выделения регистра.</target>
        </trans-unit>
        <trans-unit id="461faf3624a4165b061a68a094b7ad69f3e94c46" translate="yes" xml:space="preserve">
          <source>This pragma allows the user to set the visibility for multiple declarations without having to give each a visibility attribute (see &lt;a href=&quot;function-attributes#Function-Attributes&quot;&gt;Function Attributes&lt;/a&gt;).</source>
          <target state="translated">Эта прагма позволяет пользователю устанавливать видимость для нескольких объявлений без необходимости указывать каждому атрибут видимости (см. &lt;a href=&quot;function-attributes#Function-Attributes&quot;&gt;Атрибуты функции&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="e202730c1bfc48c0778f7ea2bd0c6eb45186cc47" translate="yes" xml:space="preserve">
          <source>This pragma allows you to set global optimization options for functions defined later in the source file. One or more strings can be specified. Each function that is defined after this point is treated as if it had been declared with one &lt;code&gt;optimize(&lt;/code&gt;&lt;var&gt;string&lt;/var&gt;&lt;code&gt;)&lt;/code&gt; attribute for each &lt;var&gt;string&lt;/var&gt; argument. The parentheses around the strings in the pragma are optional. See &lt;a href=&quot;function-attributes#Function-Attributes&quot;&gt;Function Attributes&lt;/a&gt;, for more information about the &lt;code&gt;optimize&lt;/code&gt; attribute and the attribute syntax.</source>
          <target state="translated">Эта прагма позволяет вам установить параметры глобальной оптимизации для функций, определенных позже в исходном файле. Можно указать одну или несколько строк. Каждая функция, определенная после этой точки, обрабатывается так, как если бы она была объявлена ​​с одним атрибутом &lt;code&gt;optimize(&lt;/code&gt; &lt;var&gt;string&lt;/var&gt; &lt;code&gt;)&lt;/code&gt; для каждого &lt;var&gt;string&lt;/var&gt; аргумента. Скобки вокруг строк в прагме необязательны. См. Раздел &amp;laquo; &lt;a href=&quot;function-attributes#Function-Attributes&quot;&gt;Атрибуты функции&amp;raquo;&lt;/a&gt; для получения дополнительной информации об атрибуте &lt;code&gt;optimize&lt;/code&gt; и синтаксисе атрибута.</target>
        </trans-unit>
        <trans-unit id="1c9f09620296c49e0c152a1252d539d7a1599030" translate="yes" xml:space="preserve">
          <source>This pragma allows you to set target-specific options for functions defined later in the source file. One or more strings can be specified. Each function that is defined after this point is treated as if it had been declared with one &lt;code&gt;target(&lt;/code&gt;&lt;var&gt;string&lt;/var&gt;&lt;code&gt;)&lt;/code&gt; attribute for each &lt;var&gt;string&lt;/var&gt; argument. The parentheses around the strings in the pragma are optional. See &lt;a href=&quot;function-attributes#Function-Attributes&quot;&gt;Function Attributes&lt;/a&gt;, for more information about the &lt;code&gt;target&lt;/code&gt; attribute and the attribute syntax.</source>
          <target state="translated">Эта прагма позволяет вам устанавливать параметры для конкретных целей для функций, определенных позже в исходном файле. Можно указать одну или несколько строк. Каждая функция, определенная после этой точки, обрабатывается так, как если бы она была объявлена ​​с одним &lt;code&gt;target(&lt;/code&gt; &lt;var&gt;string&lt;/var&gt; &lt;code&gt;)&lt;/code&gt; атрибутом для каждого &lt;var&gt;string&lt;/var&gt; аргумента. Скобки вокруг строк в прагме необязательны. См. &lt;a href=&quot;function-attributes#Function-Attributes&quot;&gt;Атрибуты функции&lt;/a&gt; для получения дополнительной информации о &lt;code&gt;target&lt;/code&gt; атрибуте и синтаксисе атрибута.</target>
        </trans-unit>
        <trans-unit id="e5bdf333d1a9b5e255036222cc92af1884c97c92" translate="yes" xml:space="preserve">
          <source>This pragma and the &lt;code&gt;asm&lt;/code&gt; labels extension interact in a complicated manner. Here are some corner cases you may want to be aware of:</source>
          <target state="translated">Эта прагма и расширение &lt;code&gt;asm&lt;/code&gt; labels взаимодействуют сложным образом. Вот несколько важных случаев, о которых вы, возможно, захотите знать:</target>
        </trans-unit>
        <trans-unit id="df6ea502dad4ed3727dbc5aab1f84068b260e566" translate="yes" xml:space="preserve">
          <source>This pragma causes each listed &lt;var&gt;function&lt;/var&gt; to be called after main, or during shared module unloading, by adding a call to the &lt;code&gt;.fini&lt;/code&gt; section.</source>
          <target state="translated">Эта прагма заставляет каждую перечисленную &lt;var&gt;function&lt;/var&gt; вызываться после основной или во время выгрузки разделяемого модуля путем добавления вызова в раздел &lt;code&gt;.fini&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7ef98ac7a5a65ac560b0183a0711ed56313ca3a4" translate="yes" xml:space="preserve">
          <source>This pragma causes each listed &lt;var&gt;function&lt;/var&gt; to be called during initialization (before &lt;code&gt;main&lt;/code&gt;) or during shared module loading, by adding a call to the &lt;code&gt;.init&lt;/code&gt; section.</source>
          <target state="translated">Эта прагма заставляет каждую перечисленную &lt;var&gt;function&lt;/var&gt; вызываться во время инициализации (перед &lt;code&gt;main&lt;/code&gt; ) или во время загрузки разделяемого модуля, путем добавления вызова в раздел &lt;code&gt;.init&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4305b5e7eee9369ab0724af50f66a74eaee06881" translate="yes" xml:space="preserve">
          <source>This pragma clears the current &lt;code&gt;#pragma GCC target&lt;/code&gt; and &lt;code&gt;#pragma GCC optimize&lt;/code&gt; to use the default switches as specified on the command line.</source>
          <target state="translated">Эта прагма очищает текущую &lt;code&gt;#pragma GCC target&lt;/code&gt; и &lt;code&gt;#pragma GCC optimize&lt;/code&gt; , чтобы использовать параметры по умолчанию, указанные в командной строке.</target>
        </trans-unit>
        <trans-unit id="c86f808ebf265d2793b4414b964c355b2c508a5f" translate="yes" xml:space="preserve">
          <source>This pragma declares &lt;var&gt;symbol1&lt;/var&gt; to be a weak alias of &lt;var&gt;symbol2&lt;/var&gt;. It is an error if &lt;var&gt;symbol2&lt;/var&gt; is not defined in the current translation unit.</source>
          <target state="translated">Прагма заявляет &lt;var&gt;symbol1&lt;/var&gt; слабый псевдоним &lt;var&gt;symbol2&lt;/var&gt; . Это ошибка, если &lt;var&gt;symbol2&lt;/var&gt; не определен в текущей единице перевода.</target>
        </trans-unit>
        <trans-unit id="2e41ab6e510f688ee4c0ac9d61fab50b654b5c94" translate="yes" xml:space="preserve">
          <source>This pragma declares &lt;var&gt;symbol&lt;/var&gt; to be weak, as if the declaration had the attribute of the same name. The pragma may appear before or after the declaration of &lt;var&gt;symbol&lt;/var&gt;. It is not an error for &lt;var&gt;symbol&lt;/var&gt; to never be defined at all.</source>
          <target state="translated">Эта прагма объявляет &lt;var&gt;symbol&lt;/var&gt; слабым, как если бы объявление имело одноименный атрибут. Прагма может появляться до или после объявления &lt;var&gt;symbol&lt;/var&gt; . Отсутствие определения &lt;var&gt;symbol&lt;/var&gt; - не ошибка .</target>
        </trans-unit>
        <trans-unit id="6d680236fdbf196915aaf992aecdb77c6a8b587b" translate="yes" xml:space="preserve">
          <source>This pragma declares variables to be possibly unused. GCC does not produce warnings for the listed variables. The effect is similar to that of the &lt;code&gt;unused&lt;/code&gt; attribute, except that this pragma may appear anywhere within the variables&amp;rsquo; scopes.</source>
          <target state="translated">Эта прагма объявляет, что переменные, возможно, не используются. GCC не выдает предупреждений для перечисленных переменных. Эффект аналогичен эффекту &lt;code&gt;unused&lt;/code&gt; атрибута, за исключением того, что эта прагма может появляться где угодно в пределах области действия переменных.</target>
        </trans-unit>
        <trans-unit id="297d6f917f11b7d696df277d2ac80b8a527dc0e9" translate="yes" xml:space="preserve">
          <source>This pragma gives the C function &lt;var&gt;oldname&lt;/var&gt; the assembly symbol &lt;var&gt;newname&lt;/var&gt;. The preprocessor macro &lt;code&gt;__PRAGMA_REDEFINE_EXTNAME&lt;/code&gt; is defined if this pragma is available (currently on all platforms).</source>
          <target state="translated">Эта прагма дает функции C &lt;var&gt;oldname&lt;/var&gt; символ сборки &lt;var&gt;newname&lt;/var&gt; . Макрос препроцессора &lt;code&gt;__PRAGMA_REDEFINE_EXTNAME&lt;/code&gt; определяется, если эта прагма доступна (в настоящее время на всех платформах).</target>
        </trans-unit>
        <trans-unit id="1d47f09719c8273483bc0daaf5859bab9562dec9" translate="yes" xml:space="preserve">
          <source>This pragma is accepted, but has no effect.</source>
          <target state="translated">Эта прагма принята,но не имеет никакого эффекта.</target>
        </trans-unit>
        <trans-unit id="d1d3fa1a452de5b39a96a52139032ce525a57ad0" translate="yes" xml:space="preserve">
          <source>This pragma is not implemented, but the default is to &amp;ldquo;off&amp;rdquo; unless</source>
          <target state="translated">Эта прагма не реализована, но по умолчанию отключено, если</target>
        </trans-unit>
        <trans-unit id="df0d00bf5dd61e1e80f9e58129099c35fef14b94" translate="yes" xml:space="preserve">
          <source>This pragma is not implemented. Expressions are currently only contracted if</source>
          <target state="translated">Эта прагма не реализуется.Выражение мнений в настоящее время является контрактным только в том случае,если</target>
        </trans-unit>
        <trans-unit id="42570b540208a522195f34bdcb31e38a4d6b0221" translate="yes" xml:space="preserve">
          <source>This pragma saves the value of the macro named as &lt;var&gt;macro_name&lt;/var&gt; to the top of the stack for this macro.</source>
          <target state="translated">Эта прагма сохраняет значение макроса с именем &lt;var&gt;macro_name&lt;/var&gt; в верхнюю часть стека для этого макроса.</target>
        </trans-unit>
        <trans-unit id="0d99cb35c6101970038eaf301a0c3beb6107bf5a" translate="yes" xml:space="preserve">
          <source>This pragma sets the alignment of fields in structures. The values of &lt;var&gt;alignment&lt;/var&gt; may be &lt;code&gt;mac68k&lt;/code&gt;, to emulate m68k alignment, or &lt;code&gt;power&lt;/code&gt;, to emulate PowerPC alignment. Uses of this pragma nest properly; to restore the previous setting, use &lt;code&gt;reset&lt;/code&gt; for the &lt;var&gt;alignment&lt;/var&gt;.</source>
          <target state="translated">Эта прагма устанавливает выравнивание полей в структурах. Значения &lt;var&gt;alignment&lt;/var&gt; могут быть &lt;code&gt;mac68k&lt;/code&gt; , чтобы имитировать выравнивание m68k, или &lt;code&gt;power&lt;/code&gt; , чтобы имитировать выравнивание PowerPC. Правильное использование этой прагмы; чтобы восстановить предыдущую настройку, используйте &lt;code&gt;reset&lt;/code&gt; для &lt;var&gt;alignment&lt;/var&gt; .</target>
        </trans-unit>
        <trans-unit id="6e23a1d175eeaabf52f59f12be4c55b597b0251f" translate="yes" xml:space="preserve">
          <source>This pragma sets the value of the macro named as &lt;var&gt;macro_name&lt;/var&gt; to the value on top of the stack for this macro. If the stack for &lt;var&gt;macro_name&lt;/var&gt; is empty, the value of the macro remains unchanged.</source>
          <target state="translated">Эта прагма устанавливает значение макроса с именем &lt;var&gt;macro_name&lt;/var&gt; равным значению в верхней части стека для этого макроса. Если стек для &lt;var&gt;macro_name&lt;/var&gt; пуст, значение макроса остается неизменным.</target>
        </trans-unit>
        <trans-unit id="03b17cd16d3c44521375b42df7bda966fe331c0e" translate="yes" xml:space="preserve">
          <source>This pragma silently applies only to declarations with external linkage. The &lt;code&gt;asm&lt;/code&gt; label feature does not have this restriction.</source>
          <target state="translated">Эта прагма молча применяется только к объявлениям с внешней связью. Функция метки &lt;code&gt;asm&lt;/code&gt; не имеет этого ограничения.</target>
        </trans-unit>
        <trans-unit id="263438c853ee982ccc7a3904487e0cd3d115c742" translate="yes" xml:space="preserve">
          <source>This prefix is also used for finding files such as</source>
          <target state="translated">Этот префикс также используется для поиска файлов,таких как</target>
        </trans-unit>
        <trans-unit id="853d289c160cc93497a02e37abb2f9f0217d9d34" translate="yes" xml:space="preserve">
          <source>This problem may for instance occur when we use this pattern recursively, like so:</source>
          <target state="translated">Эта проблема может,например,возникнуть,когда мы используем этот паттерн рекурсивно:</target>
        </trans-unit>
        <trans-unit id="92bb145abdc75a03d83add48a654c73cbe5bd131" translate="yes" xml:space="preserve">
          <source>This problem only affects kernel stores and, depending on the system, kernel loads. As an example, a speculatively-executed store may load the target memory into cache and mark the cache line as dirty, even if the store itself is later aborted. If a DMA operation writes to the same area of memory before the &amp;ldquo;dirty&amp;rdquo; line is flushed, the cached data overwrites the DMA-ed data. See the R10K processor manual for a full description, including other potential problems.</source>
          <target state="translated">Эта проблема затрагивает только хранилища ядра и, в зависимости от системы, загрузку ядра. Например, предположительно выполняемое хранилище может загрузить целевую память в кэш и пометить строку кэша как грязную, даже если само хранилище позже будет прервано. Если операция DMA выполняет запись в ту же область памяти до того, как &amp;laquo;грязная&amp;raquo; строка очищается, кэшированные данные перезаписывают данные, редактируемые DMA. См. Полное описание процессора R10K, включая другие возможные проблемы.</target>
        </trans-unit>
        <trans-unit id="6bba2aa8d001273821fc7a22f52c80ae052e1b79" translate="yes" xml:space="preserve">
          <source>This qualifier informs the compiler that the &lt;code&gt;asm&lt;/code&gt; statement may perform a jump to one of the labels listed in the &lt;var&gt;GotoLabels&lt;/var&gt;. See &lt;a href=&quot;#GotoLabels&quot;&gt;GotoLabels&lt;/a&gt;.</source>
          <target state="translated">Этот квалификатор сообщает компилятору, что оператор &lt;code&gt;asm&lt;/code&gt; может выполнить переход к одной из меток, перечисленных в &lt;var&gt;GotoLabels&lt;/var&gt; . См. &lt;a href=&quot;#GotoLabels&quot;&gt;GotoLabels&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4093c1766b06cd06224229c5ab31374f32640737" translate="yes" xml:space="preserve">
          <source>This restriction of ISO C makes it hard to write code that is portable to traditional C compilers, because the programmer does not know whether the &lt;code&gt;uid_t&lt;/code&gt; type is &lt;code&gt;short&lt;/code&gt;, &lt;code&gt;int&lt;/code&gt;, or &lt;code&gt;long&lt;/code&gt;. Therefore, in cases like these GNU C allows a prototype to override a later old-style definition. More precisely, in GNU C, a function prototype argument type overrides the argument type specified by a later old-style definition if the former type is the same as the latter type before promotion. Thus in GNU C the above example is equivalent to the following:</source>
          <target state="translated">Это ограничение ISO C затрудняет написание кода, переносимого для традиционных компиляторов C, потому что программист не знает, является &lt;code&gt;uid_t&lt;/code&gt; тип uid_t &lt;code&gt;short&lt;/code&gt; , &lt;code&gt;int&lt;/code&gt; или &lt;code&gt;long&lt;/code&gt; . Следовательно, в подобных случаях GNU C позволяет прототипу отменять более позднее определение старого стиля. Точнее, в GNU C тип аргумента прототипа функции переопределяет тип аргумента, указанный более поздним определением в старом стиле, если первый тип совпадает с последним типом до продвижения. Таким образом, в GNU C приведенный выше пример эквивалентен следующему:</target>
        </trans-unit>
        <trans-unit id="b4ab6e646b44f4632464748755730b2c272ad5f1" translate="yes" xml:space="preserve">
          <source>This sample shows how to specify the assembler name for data:</source>
          <target state="translated">Этот пример показывает,как указать имя ассемблера для данных:</target>
        </trans-unit>
        <trans-unit id="e5b05b60d6f2ee21a98f997beb1f9023f6a4e7bc" translate="yes" xml:space="preserve">
          <source>This says that any input file whose name ends in &amp;lsquo;</source>
          <target state="translated">Это говорит о том, что любой входной файл, имя которого заканчивается на '</target>
        </trans-unit>
        <trans-unit id="8bc7756ea229cad62f19381d0aec545c10cece4c" translate="yes" xml:space="preserve">
          <source>This says that the suffix is an alias for a known &lt;var&gt;language&lt;/var&gt;. This is similar to using the</source>
          <target state="translated">Это говорит о том, что суффикс - это псевдоним известного &lt;var&gt;language&lt;/var&gt; . Это похоже на использование</target>
        </trans-unit>
        <trans-unit id="77e07f2febdffcd9c896323de91d75db17316bb7" translate="yes" xml:space="preserve">
          <source>This section describes PowerPC built-in functions that do not require the inclusion of any special header files to declare prototypes or provide macro definitions. The sections that follow describe additional PowerPC built-in functions.</source>
          <target state="translated">В этом разделе описаны встроенные функции PowerPC,которые не требуют включения специальных заголовочных файлов для объявления прототипов или предоставления макроопределений.В последующих разделах описаны дополнительные встроенные функции PowerPC.</target>
        </trans-unit>
        <trans-unit id="4b61f221f0794b55701031d13518070c0255286e" translate="yes" xml:space="preserve">
          <source>This section describes built-in functions that are not named after a specific FR-V instruction.</source>
          <target state="translated">В этом разделе описаны встроенные функции,которые не названы в честь конкретной инструкции FR-V.</target>
        </trans-unit>
        <trans-unit id="d7abf825d737ed6aeedbed114bb5b1fa96d1d588" translate="yes" xml:space="preserve">
          <source>This section describes command-line options that are primarily of interest to GCC developers, including options to support compiler testing and investigation of compiler bugs and compile-time performance problems. This includes options that produce debug dumps at various points in the compilation; that print statistics such as memory use and execution time; and that print information about GCC&amp;rsquo;s configuration, such as where it searches for libraries. You should rarely need to use any of these options for ordinary compilation and linking tasks.</source>
          <target state="translated">В этом разделе описаны параметры командной строки, которые в первую очередь представляют интерес для разработчиков GCC, включая параметры для поддержки тестирования компилятора и исследования ошибок компилятора и проблем с производительностью во время компиляции. Сюда входят параметры, которые создают отладочные дампы на различных этапах компиляции; которые печатают статистику, такую ​​как использование памяти и время выполнения; и печатающая информация о конфигурации GCC, например о том, где он ищет библиотеки. Вам редко придется использовать какие-либо из этих параметров для обычных задач компиляции и связывания.</target>
        </trans-unit>
        <trans-unit id="2bedaec624c9942033ae97b423071f6ba2ad1456" translate="yes" xml:space="preserve">
          <source>This section describes known problems that affect users of GCC. Most of these are not GCC bugs per se&amp;mdash;if they were, we would fix them. But the result for a user may be like the result of a bug.</source>
          <target state="translated">В этом разделе описаны известные проблемы, с которыми сталкиваются пользователи GCC. Большинство из них не являются ошибками GCC сами по себе - если бы они были, мы бы исправили их. Но результат для пользователя может быть похож на результат ошибки.</target>
        </trans-unit>
        <trans-unit id="5b43873b1eac185b9fa8755ff87aff197f92a2f8" translate="yes" xml:space="preserve">
          <source>This section describes several environment variables that affect how GCC operates. Some of them work by specifying directories or prefixes to use when searching for various kinds of files. Some are used to specify other aspects of the compilation environment.</source>
          <target state="translated">В этом разделе описаны несколько переменных окружения,которые влияют на работу GCC.Некоторые из них работают путем указания каталогов или префиксов для использования при поиске различных типов файлов.Некоторые из них используются для указания других аспектов среды компиляции.</target>
        </trans-unit>
        <trans-unit id="9055e1a522ff74558948ff04f5b4f164a424da3a" translate="yes" xml:space="preserve">
          <source>This section describes the command-line options that are only meaningful for C++ programs. You can also use most of the GNU compiler options regardless of what language your program is in. For example, you might compile a file</source>
          <target state="translated">В этом разделе описаны опции командной строки,которые имеют смысл только для программ на Си++.Вы также можете использовать большинство вариантов компилятора GNU независимо от того,на каком языке написана ваша программа.Например,вы можете скомпилировать файл</target>
        </trans-unit>
        <trans-unit id="378b3683f59604e4695371da6c2fddfaacd92ba1" translate="yes" xml:space="preserve">
          <source>This section describes the command-line options that are only meaningful for Objective-C and Objective-C++ programs. You can also use most of the language-independent GNU compiler options. For example, you might compile a file</source>
          <target state="translated">В данном разделе описаны опции командной строки,имеющие значение только для программ Objective-C и Objective-C++.Вы также можете использовать большинство опций компилятора GNU,не зависящих от языка.Например,вы можете скомпилировать файл</target>
        </trans-unit>
        <trans-unit id="382e6f59f6c971fab95547a05668a5918cd72126" translate="yes" xml:space="preserve">
          <source>This section describes the syntax with which &lt;code&gt;__attribute__&lt;/code&gt; may be used, and the constructs to which attribute specifiers bind, for the C language. Some details may vary for C++ and Objective-C. Because of infelicities in the grammar for attributes, some forms described here may not be successfully parsed in all cases.</source>
          <target state="translated">В этом разделе описывается синтаксис, с которым может использоваться &lt;code&gt;__attribute__&lt;/code&gt; , и конструкции, с которыми связываются спецификаторы атрибутов, для языка C. Некоторые детали могут отличаться для C ++ и Objective-C. Из-за ошибок в грамматике для атрибутов некоторые формы, описанные здесь, не во всех случаях могут быть успешно проанализированы.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
